```diff
diff --git a/.azure-pipelines.yml b/.azure-pipelines.yml
index 5c789637c..96c36933e 100644
--- a/.azure-pipelines.yml
+++ b/.azure-pipelines.yml
@@ -34,7 +34,6 @@ trigger:
   paths:
     exclude:
       - '.circleci/*'
-      - '.cirrus.yml'
       - '.github/*'
       - '.github/workflows/*'
       - 'appveyor.*'
@@ -48,7 +47,6 @@ pr:
   paths:
     exclude:
       - '.circleci/*'
-      - '.cirrus.yml'
       - '.github/*'
       - '.github/workflows/*'
       - 'appveyor.*'
@@ -88,7 +86,7 @@ stages:
             disable_http_smtp_imap:
               name: w/o HTTP/SMTP/IMAP
               configure: --disable-http --disable-smtp --disable-imap --without-ssl
-            disable_thredres:
+            disable_threadres:
               name: sync resolver
               configure: --disable-threaded-resolver --with-openssl
             https_only:
@@ -104,7 +102,7 @@ stages:
             displayName: 'apt install'
             retryCountOnTaskFailure: 3
 
-          - script: autoreconf -fi && ./configure --enable-warnings --enable-werror $(configure)
+          - script: autoreconf -fi && ./configure --disable-dependency-tracking --enable-warnings --enable-werror $(configure)
             displayName: 'configure $(name)'
 
           - script: make V=1 && make V=1 examples && cd tests && make V=1
@@ -131,7 +129,7 @@ stages:
           - script: autoreconf -fi
             displayName: 'autoreconf'
 
-          - script: scan-build ./configure --enable-debug --enable-werror --with-openssl --with-libssh2
+          - script: scan-build ./configure --disable-dependency-tracking --enable-debug --enable-werror --with-openssl --with-libssh2
             displayName: 'configure'
             env:
               CC: "clang"
@@ -233,7 +231,7 @@ stages:
             condition: variables.prepare
             retryCountOnTaskFailure: 3
 
-          - script: $(container_cmd) -l -c "cd $(echo '%cd%') && autoreconf -fi && ./configure $(configure)"
+          - script: $(container_cmd) -l -c "cd $(echo '%cd%') && autoreconf -fi && ./configure --disable-dependency-tracking $(configure)"
             displayName: 'configure $(name)'
 
           - script: $(container_cmd) -l -c "cd $(echo '%cd%') && make V=1 && make V=1 examples && cd tests && make V=1"
diff --git a/.circleci/config.yml b/.circleci/config.yml
index 99667b45e..12661cbc0 100644
--- a/.circleci/config.yml
+++ b/.circleci/config.yml
@@ -23,11 +23,8 @@
 ###########################################################################
 
 # View these jobs in the browser: https://app.circleci.com/pipelines/github/curl/curl
-#
-# The macOS builds use M1 (ARM) machines for platform diversity.
-# See https://circleci.com/docs/configuration-reference/#macos-execution-environment
 
-# Use the latest 2.1 version of CircleCI pipeline process engine. See: https://circleci.com/docs/2.0/configuration-reference
+# Use the latest 2.1 version of CircleCI pipeline process engine. See: https://circleci.com/docs/configuration-reference/
 version: 2.1
 
 commands:
@@ -36,105 +33,24 @@ commands:
       - run:
           command: |
             autoreconf -fi
-            ./configure --enable-warnings --enable-werror --with-openssl || { tail -1000 config.log; false; }
+            ./configure --enable-warnings --enable-werror --with-openssl \
+              || { tail -1000 config.log; false; }
 
   configure-openssl-no-verbose:
     steps:
       - run:
           command: |
             autoreconf -fi
-            ./configure --disable-verbose --enable-werror --with-openssl || { tail -1000 config.log; false; }
+            ./configure --disable-verbose --enable-werror --with-openssl \
+              || { tail -1000 config.log; false; }
 
   configure-no-proxy:
     steps:
       - run:
           command: |
             autoreconf -fi
-            ./configure --disable-proxy --enable-werror --with-openssl || { tail -1000 config.log; false; }
-
-  configure-macos-normal:
-    steps:
-      - run:
-          command: |
-            autoreconf -fi
-            ./configure --enable-warnings --enable-websockets --without-ssl CFLAGS='-Wno-vla -mmacosx-version-min=10.9' CPPFLAGS="-I$(brew --prefix libpsl)/include" LDFLAGS="-L$(brew --prefix libpsl)/lib -L$(brew --prefix icu4c)/lib" LIBS="-licuuc -licudata" || { tail -1000 config.log; false; }
-
-  configure-macos-debug:
-    steps:
-      - run:
-          command: |
-            autoreconf -fi
-            ./configure --enable-warnings --enable-websockets --without-ssl --enable-debug CPPFLAGS="-I$(brew --prefix libpsl)/include" CFLAGS='-Wno-vla -mmacosx-version-min=10.9' LDFLAGS="-L$(brew --prefix libpsl)/lib -L$(brew --prefix icu4c)/lib" LIBS="-licuuc -licudata" || { tail -1000 config.log; false; }
-
-  configure-macos-libssh2:
-    steps:
-      - run:
-          command: |
-            autoreconf -fi
-            ./configure --enable-warnings --enable-websockets --without-ssl --with-libssh2=/opt/homebrew/opt/libssh2 --enable-debug CPPFLAGS="-I$(brew --prefix libpsl)/include" CFLAGS='-Wno-vla -mmacosx-version-min=10.9' LDFLAGS="-L$(brew --prefix libpsl)/lib -L$(brew --prefix icu4c)/lib" LIBS="-licuuc -licudata" || { tail -1000 config.log; false; }
-
-  configure-macos-libssh-c-ares:
-    steps:
-      - run:
-          command: |
-            autoreconf -fi
-            ./configure --enable-warnings --enable-websockets --with-openssl --with-libssh --enable-ares --enable-debug PKG_CONFIG_PATH="$(brew --prefix openssl)/lib/pkgconfig" CPPFLAGS="-I$(brew --prefix libpsl)/include" CFLAGS='-Wno-vla -mmacosx-version-min=10.9' LDFLAGS="-L$(brew --prefix libpsl)/lib -L$(brew --prefix icu4c)/lib" LIBS="-licuuc -licudata" || { tail -1000 config.log; false; }
-
-  configure-macos-libssh:
-    steps:
-      - run:
-          command: |
-            autoreconf -fi
-            ./configure --enable-warnings --enable-websockets --with-openssl --with-libssh --enable-debug PKG_CONFIG_PATH="$(brew --prefix openssl)/lib/pkgconfig" CPPFLAGS="-I$(brew --prefix libpsl)/include" CFLAGS='-Wno-vla -mmacosx-version-min=10.9' LDFLAGS="-L$(brew --prefix libpsl)/lib -L$(brew --prefix icu4c)/lib" LIBS="-licuuc -licudata" || { tail -1000 config.log; false; }
-
-  configure-macos-c-ares:
-    steps:
-      - run:
-          command: |
-            autoreconf -fi
-            ./configure --enable-warnings --enable-websockets --without-ssl --enable-ares --enable-debug CPPFLAGS="-I$(brew --prefix libpsl)/include" CFLAGS='-Wno-vla -mmacosx-version-min=10.9' LDFLAGS="-L$(brew --prefix libpsl)/lib -L$(brew --prefix icu4c)/lib" LIBS="-licuuc -licudata" || { tail -1000 config.log; false; }
-
-  configure-macos-http-only:
-    steps:
-      - run:
-          command: |
-            autoreconf -fi
-            ./configure --enable-warnings --enable-maintainer-mode --disable-dict --disable-file --disable-ftp --disable-gopher --disable-imap --disable-ldap --disable-mqtt --disable-pop3 --disable-rtsp --disable-smb --disable-smtp --disable-telnet --disable-tftp --disable-unix-sockets --disable-shared --without-brotli --without-gssapi --without-libidn2 --without-libpsl --without-librtmp --without-libssh2 --without-nghttp2 --without-ssl --without-zlib --enable-debug CFLAGS='-Wno-vla -mmacosx-version-min=10.15' || { tail -1000 config.log; false; }
-
-  configure-macos-securetransport-http2:
-    steps:
-      - run:
-          command: |
-            autoreconf -fi
-            ./configure --enable-warnings --enable-websockets --with-secure-transport CPPFLAGS="-I$(brew --prefix libpsl)/include" CFLAGS='-Wno-vla -mmacosx-version-min=10.8' LDFLAGS="-L$(brew --prefix libpsl)/lib -L$(brew --prefix icu4c)/lib" LIBS="-licuuc -licudata" || { tail -1000 config.log; false; }
-
-  configure-macos-openssl-http2:
-    steps:
-      - run:
-          command: |
-            autoreconf -fi
-            ./configure --enable-warnings --enable-websockets --with-openssl --enable-debug PKG_CONFIG_PATH="$(brew --prefix openssl)/lib/pkgconfig" CPPFLAGS="-I$(brew --prefix libpsl)/include" CFLAGS='-Wno-vla -mmacosx-version-min=10.9' LDFLAGS="-L$(brew --prefix libpsl)/lib -L$(brew --prefix icu4c)/lib" LIBS="-licuuc -licudata" || { tail -1000 config.log; false; }
-
-  configure-macos-libressl-http2:
-    steps:
-      - run:
-          command: |
-            autoreconf -fi
-            ./configure --enable-warnings --enable-websockets --with-openssl --enable-debug PKG_CONFIG_PATH="$(brew --prefix libressl)/lib/pkgconfig" CPPFLAGS="-I$(brew --prefix libpsl)/include" CFLAGS='-Wno-vla -mmacosx-version-min=10.9' LDFLAGS="-L$(brew --prefix libpsl)/lib -L$(brew --prefix icu4c)/lib" LIBS="-licuuc -licudata" || { tail -1000 config.log; false; }
-
-  configure-macos-torture:
-    steps:
-      - run:
-          command: |
-            autoreconf -fi
-            ./configure --enable-warnings --enable-websockets --disable-shared --disable-threaded-resolver --with-openssl --enable-debug PKG_CONFIG_PATH="$(brew --prefix openssl)/lib/pkgconfig" CPPFLAGS="-I$(brew --prefix libpsl)/include" CFLAGS='-Wno-vla -mmacosx-version-min=10.9' LDFLAGS="-L$(brew --prefix libpsl)/lib -L$(brew --prefix icu4c)/lib" LIBS="-licuuc -licudata" || { tail -1000 config.log; false; }
-
-  configure-macos-torture-ftp:
-    steps:
-      - run:
-          command: |
-            autoreconf -fi
-            ./configure --enable-warnings --enable-websockets --disable-shared --disable-threaded-resolver --with-openssl --enable-debug PKG_CONFIG_PATH="$(brew --prefix openssl)/lib/pkgconfig" CPPFLAGS="-I$(brew --prefix libpsl)/include" CFLAGS='-Wno-vla -mmacosx-version-min=10.9' LDFLAGS="-L$(brew --prefix libpsl)/lib -L$(brew --prefix icu4c)/lib" LIBS="-licuuc -licudata" || { tail -1000 config.log; false; }
+            ./configure --disable-proxy --enable-werror --with-openssl \
+              || { tail -1000 config.log; false; }
 
   install-cares:
     steps:
@@ -155,21 +71,13 @@ commands:
             sudo apt-get update && sudo apt-get install -y libpsl-dev libbrotli-dev libzstd-dev zlib1g-dev python3-pip libpsl-dev
             sudo python3 -m pip install impacket
 
-  install-deps-brew:
-    steps:
-      - run:
-          command: |
-            # Drop libressl as long as we're not trying to build it
-            echo libtool autoconf automake pkg-config nghttp2 libssh2 openssl libssh c-ares libpsl icu4c | xargs -Ix -n1 echo brew '"x"' > /tmp/Brewfile
-            while [ $? -eq 0 ]; do for i in 1 2 3; do brew update && brew bundle install --no-lock --file /tmp/Brewfile && break 2 || { echo Error: wait to try again; sleep 10; } done; false Too many retries; done
-            sudo python3 -m pip install impacket
-
   configure-libssh:
     steps:
       - run:
           command: |
             autoreconf -fi
-            ./configure --enable-warnings --enable-werror --with-openssl --with-libssh || { tail -1000 config.log; false; }
+            ./configure --enable-warnings --enable-werror --with-openssl --with-libssh \
+              || { tail -1000 config.log; false; }
 
   install-wolfssl:
     steps:
@@ -202,48 +110,33 @@ commands:
       - run:
           command: |
             autoreconf -fi
-            ./configure --enable-warnings --enable-werror --with-openssl --enable-ares || { tail -1000 config.log; false; }
+            ./configure --enable-warnings --enable-werror --with-openssl --enable-ares \
+              || { tail -1000 config.log; false; }
 
   configure-wolfssh:
     steps:
       - run:
           command: |
             autoreconf -fi
-            LDFLAGS="-Wl,-rpath,$HOME/wssh/lib" ./configure --enable-warnings --enable-werror --with-wolfssl=$HOME/wssl --with-wolfssh=$HOME/wssh || { tail -1000 config.log; false; }
+            LDFLAGS="-Wl,-rpath,$HOME/wssh/lib" ./configure --enable-warnings --enable-werror --with-wolfssl=$HOME/wssl --with-wolfssh=$HOME/wssh \
+              || { tail -1000 config.log; false; }
 
   configure-cares-debug:
     steps:
       - run:
           command: |
             autoreconf -fi
-            ./configure --enable-debug --enable-werror --with-openssl --enable-ares || { tail -1000 config.log; false; }
+            ./configure --enable-debug --enable-werror --with-openssl --enable-ares \
+              || { tail -1000 config.log; false; }
 
   build:
     steps:
       - run: make -j3 V=1
       - run: make -j3 V=1 examples
 
-  build-macos:
-    steps:
-      - run: make -j5 V=1
-      - run: make -j5 V=1 examples
-
   test:
     steps:
-      - run: make -j3 V=1 test-ci
-
-  test-macos:
-    steps:
-      - run: make -j5 V=1 test-ci
-
-  test-torture:
-    steps:
-      - run: make -j5 V=1 test-ci TFLAGS="-n -t --shallow=25 !FTP"
-
-  test-torture-ftp:
-    steps:
-      # Test 250 takes too long, causing Circle CI to kill the job
-      - run: make -j5 V=1 test-ci TFLAGS="-n -t --shallow=20 FTP !250 !251"
+      - run: make -j3 V=1 test-ci TFLAGS='-j14'
 
 executors:
   ubuntu:
@@ -330,138 +223,6 @@ jobs:
       - build
       - test
 
-  macos-arm-normal:
-    macos:
-      xcode: 15.0.0
-    resource_class: macos.m1.medium.gen1
-    steps:
-      - checkout
-      - install-deps-brew
-      - configure-macos-normal
-      - build-macos
-      - test-macos
-
-  macos-arm-debug:
-    macos:
-      xcode: 15.0.0
-    resource_class: macos.m1.medium.gen1
-    steps:
-      - checkout
-      - install-deps-brew
-      - configure-macos-debug
-      - build-macos
-      - test-macos
-
-  macos-arm-libssh2:
-    macos:
-      xcode: 15.0.0
-    resource_class: macos.m1.medium.gen1
-    steps:
-      - checkout
-      - install-deps-brew
-      - configure-macos-libssh2
-      - build-macos
-      - test-macos
-
-  macos-arm-libssh-c-ares:
-    macos:
-      xcode: 15.0.0
-    resource_class: macos.m1.medium.gen1
-    steps:
-      - checkout
-      - install-deps-brew
-      - configure-macos-libssh-c-ares
-      - build-macos
-      - test-macos
-
-  macos-arm-libssh:
-    macos:
-      xcode: 15.0.0
-    resource_class: macos.m1.medium.gen1
-    steps:
-      - checkout
-      - install-deps-brew
-      - configure-macos-libssh
-      - build-macos
-      - test-macos
-
-  macos-arm-c-ares:
-    macos:
-      xcode: 15.0.0
-    resource_class: macos.m1.medium.gen1
-    steps:
-      - checkout
-      - install-deps-brew
-      - configure-macos-c-ares
-      - build-macos
-      - test-macos
-
-  macos-arm-http-only:
-    macos:
-      xcode: 15.0.0
-    resource_class: macos.m1.medium.gen1
-    steps:
-      - checkout
-      - install-deps-brew
-      - configure-macos-http-only
-      - build-macos
-      - test-macos
-
-  macos-arm-http-securetransport-http2:
-    macos:
-      xcode: 15.0.0
-    resource_class: macos.m1.medium.gen1
-    steps:
-      - checkout
-      - install-deps-brew
-      - configure-macos-securetransport-http2
-      - build-macos
-      - test-macos
-
-  macos-arm-http-openssl-http2:
-    macos:
-      xcode: 15.0.0
-    resource_class: macos.m1.medium.gen1
-    steps:
-      - checkout
-      - install-deps-brew
-      - configure-macos-openssl-http2
-      - build-macos
-      - test-macos
-
-  macos-arm-http-libressl-http2:
-    macos:
-      xcode: 15.0.0
-    resource_class: macos.m1.medium.gen1
-    steps:
-      - checkout
-      - install-deps-brew
-      - configure-macos-libressl-http2
-      - build-macos
-      - test-macos
-
-  macos-arm-http-torture:
-    macos:
-      xcode: 15.0.0
-    resource_class: macos.m1.medium.gen1
-    steps:
-      - checkout
-      - install-deps-brew
-      - configure-macos-torture
-      - build-macos
-      - test-torture
-
-  macos-arm-http-torture-ftp:
-    macos:
-      xcode: 15.0.0
-    resource_class: macos.m1.medium.gen1
-    steps:
-      - checkout
-      - install-deps-brew
-      - configure-macos-torture-ftp
-      - build-macos
-      - test-torture-ftp
-
 workflows:
   x86-openssl:
     jobs:
@@ -494,53 +255,3 @@ workflows:
   arm-openssl-c-ares:
     jobs:
       - arm-cares
-
-  macos-arm-normal:
-    jobs:
-      - macos-arm-normal
-
-  macos-arm-debug:
-    jobs:
-      - macos-arm-debug
-
-  macos-arm-libssh2:
-    jobs:
-      - macos-arm-libssh2
-
-  macos-arm-libssh-c-ares:
-    jobs:
-      - macos-arm-libssh-c-ares
-
-  macos-arm-libssh:
-    jobs:
-      - macos-arm-libssh
-
-  macos-arm-c-ares:
-    jobs:
-      - macos-arm-c-ares
-
-  macos-arm-http-only:
-    jobs:
-      - macos-arm-http-only
-
-  macos-arm-http-securetransport-http2:
-    jobs:
-      - macos-arm-http-securetransport-http2
-
-  macos-arm-http-openssl-http2:
-    jobs:
-      - macos-arm-http-openssl-http2
-
-  # There are problem linking with LibreSSL on the CI boxes that prevent this
-  # from working.
-  # macos-arm-http-libressl-http2:
-  #   jobs:
-  #     - macos-arm-http-libressl-http2
-
-  macos-arm-http-torture:
-    jobs:
-      - macos-arm-http-torture
-
-  macos-arm-http-torture-ftp:
-    jobs:
-      - macos-arm-http-torture-ftp
diff --git a/.cirrus.yml b/.cirrus.yml
deleted file mode 100644
index 05c92756a..000000000
--- a/.cirrus.yml
+++ /dev/null
@@ -1,85 +0,0 @@
-#***************************************************************************
-#                                  _   _ ____  _
-#  Project                     ___| | | |  _ \| |
-#                             / __| | | | |_) | |
-#                            | (__| |_| |  _ <| |___
-#                             \___|\___/|_| \_\_____|
-#
-# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
-#
-# This software is licensed as described in the file COPYING, which
-# you should have received as part of this distribution. The terms
-# are also available at https://curl.se/docs/copyright.html.
-#
-# You may opt to use, copy, modify, merge, publish, distribute and/or sell
-# copies of the Software, and permit persons to whom the Software is
-# furnished to do so, under the terms of the COPYING file.
-#
-# This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
-# KIND, either express or implied.
-#
-# SPDX-License-Identifier: curl
-#
-###########################################################################
-# https://cirrus-ci.com/github/curl/curl
-#
-# Cirrus CI configuration:
-# https://cirrus-ci.org/guide/writing-tasks/
-
-freebsd_task:
-  skip: "changesIncludeOnly(
-    '**/CMakeLists.txt',
-    '.azure-pipelines.yml',
-    '.circleci/**',
-    '.github/**',
-    'appveyor.*',
-    'CMake/**',
-    'packages/**',
-    'plan9/**',
-    'projects/**',
-    'winbuild/**'
-    )"
-
-  name: FreeBSD
-
-  matrix:
-    - name: FreeBSD 14.0
-      freebsd_instance:
-        image_family: freebsd-14-0
-
-  env:
-    CIRRUS_CLONE_DEPTH: 10
-    CRYPTOGRAPHY_DONT_BUILD_RUST: 1
-    MAKEFLAGS: -j 3
-
-  pkginstall_script:
-    - pkg update -f
-    - pkg install -y autoconf automake libtool pkgconf brotli openldap26-client heimdal libpsl libssh2 libidn2 librtmp libnghttp2 nghttp2 stunnel py39-openssl py39-impacket py39-cryptography libpsl
-    - pkg delete -y curl
-  configure_script:
-    - autoreconf -fi
-    # Building with the address sanitizer is causing unexplainable test issues due to timeouts
-    # - case `uname -r` in
-    #     12.2*)
-    #     export CC=clang;
-    #     export CFLAGS="-fsanitize=address,undefined,signed-integer-overflow -fno-sanitize-recover=undefined,integer -Wformat -Werror=format-security -Werror=array-bounds -g";
-    #     export CXXFLAGS="-fsanitize=address,undefined -fno-sanitize-recover=undefined,integer -Wformat -Werror=format-security -Werror=array-bounds -g";
-    #     export LDFLAGS="-fsanitize=address,undefined -fno-sanitize-recover=undefined,integer" ;;
-    #   esac
-    - ./configure --prefix="${HOME}"/install --enable-debug --with-openssl --with-libssh2 --with-brotli --with-gssapi --with-libidn2 --enable-manual --enable-ldap --enable-ldaps --with-librtmp --with-libpsl --with-nghttp2 || { tail -300 config.log; false; }
-  compile_script:
-    - make V=1 && make V=1 examples && cd tests && make V=1
-  test_script:
-    # blackhole?
-    - sysctl net.inet.tcp.blackhole
-    # make sure we don't run blackhole != 0
-    - sudo sysctl net.inet.tcp.blackhole=0
-    # Some tests won't run if run as root so run them as another user.
-    # Make directories world writable so the test step can write wherever it needs.
-    - find . -type d -exec chmod 777 {} \;
-    # The OpenSSH server instance for the testsuite cannot be started on FreeBSD,
-    # therefore the SFTP and SCP tests are disabled right away from the beginning.
-    #
-    - sudo -u nobody make V=1 TFLAGS="-n !SFTP !SCP" test-ci
-  install_script:
-    - make V=1 install
diff --git a/.gitattributes b/.gitattributes
index 481fd5cff..41a5aff8d 100644
--- a/.gitattributes
+++ b/.gitattributes
@@ -2,7 +2,6 @@
 #
 # SPDX-License-Identifier: curl
 
-*.dsw -crlf
 buildconf eol=lf
 configure.ac eol=lf
 *.m4 eol=lf
@@ -11,8 +10,6 @@ configure.ac eol=lf
 *.sh eol=lf
 *.[ch] whitespace=tab-in-indent
 
-# Batch files (bat,btm,cmd) must be run with CRLF line endings.
+# Batch files must be run with CRLF line endings.
 # Refer to https://github.com/curl/curl/pull/6442
 *.bat text eol=crlf
-*.btm text eol=crlf
-*.cmd text eol=crlf
diff --git a/.github/CODEOWNERS b/.github/CODEOWNERS
index 9e7b6e391..7e1eea50f 100644
--- a/.github/CODEOWNERS
+++ b/.github/CODEOWNERS
@@ -1,3 +1,3 @@
-# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
-#
-# SPDX-License-Identifier: curl
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+#
+# SPDX-License-Identifier: curl
diff --git a/.github/ISSUE_TEMPLATE/bug_report.yml b/.github/ISSUE_TEMPLATE/bug_report.yml
index e74ac0817..a857700fe 100644
--- a/.github/ISSUE_TEMPLATE/bug_report.yml
+++ b/.github/ISSUE_TEMPLATE/bug_report.yml
@@ -2,8 +2,8 @@
 #
 # SPDX-License-Identifier: curl
 
-name: Bug Report
-description: Create a report to help us improve
+name: Bug Report on code
+description: Tell us about your problem with curl or libcurl
 
 body:
   - type: markdown
diff --git a/.github/ISSUE_TEMPLATE/docs.yml b/.github/ISSUE_TEMPLATE/docs.yml
new file mode 100644
index 000000000..1b60a597a
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/docs.yml
@@ -0,0 +1,32 @@
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+#
+# SPDX-License-Identifier: curl
+
+name: Bug Report on documentation
+description: Problems, errors, mistakes or typos in documentation.
+labels: documentation
+
+body:
+  - type: markdown
+    attributes:
+      value: |
+        Thanks for taking the time to fill out this bug report!
+
+        Only file documentation bugs here! Ask questions on the mailing lists https://curl.se/mail/
+
+  - type: textarea
+    id: source
+    attributes:
+      label: Specify which documentation you found a problem with
+      description: |
+        Include function name, URL, tarball version and all other relevant
+        details that identify the documentation source.
+    validations:
+      required: true
+
+  - type: textarea
+    id: problem
+    attributes:
+      label: The problem
+    validations:
+      required: true
diff --git a/.github/labeler.yml b/.github/labeler.yml
index 9b6c3fcc2..43d42808f 100644
--- a/.github/labeler.yml
+++ b/.github/labeler.yml
@@ -44,7 +44,6 @@ CI:
           - any-glob-to-any-file:
               - '.azure-pipelines.yml'
               - '.circleci/**'
-              - '.cirrus.yml'
               - '.github/**'
               - 'appveyor.*'
               - 'scripts/ci*'
@@ -109,13 +108,13 @@ GOPHER:
   - all:
       - changed-files:
           - any-glob-to-all-files:
-              - '{lib/gopher*}'
+              - 'lib/gopher*'
 
 HTTP:
   - all:
       - changed-files:
           - any-glob-to-all-files:
-              - '{docs/examples/hsts*,docs/examples/http-*,docs/examples/httpput*,docs/examples/https*,docs/examples/*post*,docs/HSTS.md,docs/HTTP-COOKIES.md,docs/libcurl/opts/CURLINFO_COOKIE*,docs/libcurl/opts/CURLOPT_COOKIE*,docs/libcurl/opts/CURLINFO_HTTP_**,docs/libcurl/opts/CURLINFO_REDIRECT*,docs/libcurl/opts/CURLINFO_REFER*,docs/libcurl/opts/CURLOPT_FOLLOWLOCATION*,docs/libcurl/opts/CURLOPT_HSTS*,docs/libcurl/opts/CURLOPT_HTTP*,docs/libcurl/opts/CURLOPT_POST.*,docs/libcurl/opts/CURLOPT_POSTFIELD*,docs/libcurl/opts/CURLOPT_POSTREDIR*,docs/libcurl/opts/CURLOPT_REDIR*,docs/libcurl/opts/CURLOPT_REFER*,docs/libcurl/opts/CURLOPT_TRAILER*,docs/libcurl/opts/CURLOPT_TRANSFER_ENCODING*,lib/cf-https*,lib/cf-h1*,lib/cf-h2*,lib/cookie.*,lib/http*,tests/http*,tests/http-server.pl,tests/http/*,tests/nghttp*}'
+              - '{docs/examples/hsts*,docs/examples/http-*,docs/examples/httpput*,docs/examples/https*,docs/examples/*post*,docs/HSTS.md,docs/HTTP-COOKIES.md,docs/libcurl/opts/CURLINFO_COOKIE*,docs/libcurl/opts/CURLOPT_COOKIE*,docs/libcurl/opts/CURLINFO_HTTP_**,docs/libcurl/opts/CURLINFO_REDIRECT*,docs/libcurl/opts/CURLINFO_REFER*,docs/libcurl/opts/CURLOPT_FOLLOWLOCATION*,docs/libcurl/opts/CURLOPT_HSTS*,docs/libcurl/opts/CURLOPT_HTTP*,docs/libcurl/opts/CURLOPT_POST.*,docs/libcurl/opts/CURLOPT_POSTFIELD*,docs/libcurl/opts/CURLOPT_POSTREDIR*,docs/libcurl/opts/CURLOPT_REDIR*,docs/libcurl/opts/CURLOPT_REFER*,docs/libcurl/opts/CURLOPT_TRAILER*,docs/libcurl/opts/CURLOPT_TRANSFER_ENCODING*,lib/cf-https*,lib/cf-h1*,lib/cf-h2*,lib/cookie.*,lib/hsts.*,lib/http*,tests/http*,tests/http-server.pl,tests/http/*,tests/nghttp*}'
 
 HTTP/2:
   - all:
@@ -145,7 +144,7 @@ LDAP:
   - all:
       - changed-files:
           - any-glob-to-all-files:
-              - '{lib/*ldap*}'
+              - 'lib/*ldap*'
 
 libcurl API:
   - all:
@@ -189,7 +188,7 @@ RTMP:
   - all:
       - changed-files:
           - any-glob-to-all-files:
-              - '{lib/curl_rtmp.*}'
+              - 'lib/curl_rtmp.*'
 
 RTSP:
   - all:
diff --git a/.github/scripts/VERSIONS b/.github/scripts/VERSIONS
index 33787d1bf..8e9c72894 100644
--- a/.github/scripts/VERSIONS
+++ b/.github/scripts/VERSIONS
@@ -3,7 +3,7 @@
 # SPDX-License-Identifier: curl
 
 # renovate: datasource=github-tags depName=wolfSSL/wolfssl versioning=semver extractVersion=^v?(?<version>.+)-stable$ registryUrl=https://github.com
-WOLFSSL_VER=5.7.0
+WOLFSSL_VER=5.7.2
 
 # renovate: datasource=github-tags depName=wolfSSL/wolfssh versioning=semver extractVersion=^v?(?<version>.+)-stable$ registryUrl=https://github.com
 WOLFSSH_VER=1.4.17
diff --git a/.github/scripts/badwords.pl b/.github/scripts/badwords.pl
index ffebad94e..3b215e43f 100755
--- a/.github/scripts/badwords.pl
+++ b/.github/scripts/badwords.pl
@@ -1,4 +1,4 @@
-#!/usr/bin/perl
+#!/usr/bin/env perl
 # Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 #
 # SPDX-License-Identifier: curl
diff --git a/.github/scripts/badwords.txt b/.github/scripts/badwords.txt
index 2942ce8d8..5b65736c1 100644
--- a/.github/scripts/badwords.txt
+++ b/.github/scripts/badwords.txt
@@ -12,13 +12,24 @@ wild-card:wildcard
 wild card:wildcard
 i'm:I am
 you've:You have
+we've:we have
+we're:we are
+we'll:we will
+we'd:we would
 they've:They have
 they're:They are
+they'll:They will
+they'd:They would
+you've:you have
+you'd:you would
+you'll:you will
+you're:you are
 should've:should have
-don't:do not
+don't=do not
 could've:could have
 doesn't:does not
 isn't:is not
+aren't:are not
  a html: an html
  a http: an http
  a ftp: an ftp
@@ -26,14 +37,13 @@ isn't:is not
 internet\b=Internet
 isation:ization
 it's:it is
+it'd:it would
 there's:there is
 [^.]\. And: Rewrite it somehow?
 ^(And|So|But) = Rewrite it somehow?
 \. But: Rewrite it somehow?
 \. So : Rewrite without "so" ?
  dir :directory
-you'd:you would
-you'll:you will
 can't:cannot
 that's:that is
 web page:webpage
@@ -43,8 +53,15 @@ file name\b:filename
 file names\b:filenames
 \buser name\b:username
 \buser names\b:usernames
+\bpass phrase:passphrase
 didn't:did not
 doesn't:does not
 won't:will not
 couldn't:could not
 \bwill\b:rewrite to present tense
+\b32bit=32-bit
+\b64bit=64-bit
+32 bit\b=32-bit
+64 bit\b=64-bit
+64-bits:64 bits or 64-bit
+32-bits:32 bits or 32-bit
diff --git a/.github/scripts/cleancmd.pl b/.github/scripts/cleancmd.pl
index fabcce23b..e9366de74 100755
--- a/.github/scripts/cleancmd.pl
+++ b/.github/scripts/cleancmd.pl
@@ -1,9 +1,9 @@
-#!/usr/bin/perl
+#!/usr/bin/env perl
 # Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 #
 # SPDX-License-Identifier: curl
 #
-# Input: a cmdline docs markdown, it gets modfied *in place*
+# Input: a cmdline docs markdown, it gets modified *in place*
 #
 # The main purpose is to strip off the leading meta-data part, but also to
 # clean up whatever else the spell checker might have a problem with that we
diff --git a/.github/scripts/cleanspell.pl b/.github/scripts/cleanspell.pl
index 9a0d79f58..bfa07dc05 100755
--- a/.github/scripts/cleanspell.pl
+++ b/.github/scripts/cleanspell.pl
@@ -1,4 +1,4 @@
-#!/usr/bin/perl
+#!/usr/bin/env perl
 # Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 #
 # SPDX-License-Identifier: curl
diff --git a/.github/scripts/spacecheck.pl b/.github/scripts/spacecheck.pl
new file mode 100755
index 000000000..b2473b154
--- /dev/null
+++ b/.github/scripts/spacecheck.pl
@@ -0,0 +1,153 @@
+#!/usr/bin/env perl
+#***************************************************************************
+#                                  _   _ ____  _
+#  Project                     ___| | | |  _ \| |
+#                             / __| | | | |_) | |
+#                            | (__| |_| |  _ <| |___
+#                             \___|\___/|_| \_\_____|
+#
+# Copyright (C) Viktor Szakats
+#
+# This software is licensed as described in the file COPYING, which
+# you should have received as part of this distribution. The terms
+# are also available at https://curl.se/docs/copyright.html.
+#
+# You may opt to use, copy, modify, merge, publish, distribute and/or sell
+# copies of the Software, and permit persons to whom the Software is
+# furnished to do so, under the terms of the COPYING file.
+#
+# This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+# KIND, either express or implied.
+#
+# SPDX-License-Identifier: curl
+#
+###########################################################################
+
+use strict;
+use warnings;
+
+my @tabs = (
+    "^m4/zz40-xc-ovr.m4",
+    "Makefile\\.[a-z]+\$",
+    "/mkfile",
+    "\\.(bat|sln|vc)\$",
+    "^tests/certs/.+\\.der\$",
+    "^tests/data/test",
+);
+
+my @mixed_eol = (
+    "^tests/certs/.+\\.(crt|der)\$",
+    "^tests/certs/Server-localhost0h-sv.pem",
+    "^tests/data/test",
+);
+
+my @need_crlf = (
+    "\\.(bat|sln)\$",
+    "^winbuild/.+\\.md\$",
+);
+
+my @space_at_eol = (
+    "^tests/.+\\.(cacert|crt|pem)\$",
+    "^tests/data/test",
+);
+
+my @eol_at_eof = (
+    "^tests/certs/.+\\.der\$",
+);
+
+sub fn_match {
+    my ($filename, @masklist) = @_;
+
+    foreach my $mask (@masklist) {
+        if ($filename =~ $mask) {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+sub eol_detect {
+    my ($content) = @_;
+
+    my $cr = () = $content =~ /\r/g;
+    my $lf = () = $content =~ /\n/g;
+
+    if ($cr > 0 && $lf == 0) {
+        return "cr"
+    }
+    elsif ($cr == 0 && $lf > 0) {
+        return "lf"
+    }
+    elsif ($cr == 0 && $lf == 0) {
+        return "bin"
+    }
+    elsif ($cr == $lf) {
+        return "crlf"
+    }
+
+    return ""
+}
+
+my $issues = 0;
+
+open my $git_ls_files, '-|', 'git ls-files' or die "Failed running git ls-files: $!";
+while (my $filename = <$git_ls_files>) {
+    chomp $filename;
+
+    open my $fh, '<', $filename or die "Cannot open '$filename': $!";
+    my $content = do { local $/; <$fh> };
+    close $fh;
+
+    my @err = ();
+
+    if (!fn_match($filename, @tabs) &&
+        $content =~ /\t/) {
+        push @err, "content: has tab";
+    }
+
+    my $eol = eol_detect($content);
+
+    if ($eol eq "" &&
+        !fn_match($filename, @mixed_eol)) {
+        push @err, "content: has mixed EOL types";
+    }
+
+    if ($eol ne "crlf" &&
+        fn_match($filename, @need_crlf)) {
+        push @err, "content: must use CRLF EOL for this file type";
+    }
+
+    if ($eol ne "lf" && $content ne "" &&
+        !fn_match($filename, @need_crlf) &&
+        !fn_match($filename, @mixed_eol)) {
+        push @err, "content: must use LF EOL for this file type";
+    }
+
+    if (!fn_match($filename, @space_at_eol) &&
+        $content =~ /[ \t]\n/) {
+        push @err, "content: has line-ending whitespace";
+    }
+
+    if ($content ne "" &&
+        !fn_match($filename, @eol_at_eof) &&
+        $content !~ /\n\z/) {
+        push @err, "content: has no EOL at EOF";
+    }
+
+    if ($content =~ /\n\n\z/ ||
+        $content =~ /\r\n\r\n\z/) {
+        push @err, "content: has multiple EOL at EOF";
+    }
+
+    if (@err) {
+        $issues++;
+        foreach my $err (@err) {
+            print "$filename: $err\n";
+        }
+    }
+}
+close $git_ls_files;
+
+if ($issues) {
+    exit 1;
+}
diff --git a/.github/scripts/spellcheck.words b/.github/scripts/spellcheck.words
index 9d96c3578..be12d3c9d 100644
--- a/.github/scripts/spellcheck.words
+++ b/.github/scripts/spellcheck.words
@@ -69,7 +69,6 @@ BjÃ¸rn
 bool
 boolean
 BoringSSL
-boringssl
 Boukris
 Broadcom
 brotli
@@ -119,10 +118,10 @@ CMake
 cmake
 CMake's
 cmake's
-CNAME
-CNAMEs
 CMakeLists
 CNA
+CNAME
+CNAMEs
 CodeQL
 codeql
 CODESET
@@ -174,6 +173,8 @@ decrypting
 deepcode
 DELE
 DER
+dereference
+dereferences
 deselectable
 deserialization
 Deserialized
@@ -209,11 +210,13 @@ EBCDIC
 ECC
 ECDHE
 ECH
-ecl
 ECHConfig
 ECHConfigList
+ecl
 ECONNREFUSED
 eCOS
+ECT
+EF
 EFnet
 EGD
 EHLO
@@ -289,7 +292,6 @@ globbed
 globbing
 gmail
 GnuTLS
-gnutls
 Golemon
 GOST
 GPG
@@ -358,6 +360,7 @@ ifdef
 ifdefed
 Ifdefs
 ifdefs
+ifhost
 IIS
 ILE
 Illumos
@@ -436,11 +439,9 @@ libpsl
 Libre
 libre
 LibreSSL
-libressl
 librtmp
 libs
 libssh
-libSSH
 libssh2
 Libtool
 libtool
@@ -456,6 +457,8 @@ LOGDIR
 logfile
 lookups
 loopback
+LOWCOST
+LOWDELAY
 LPRT
 LSB
 lseek
@@ -487,6 +490,7 @@ Micrium
 MicroBlaze
 MicroOS
 middlebox
+MINCOST
 mingw
 MinGW
 MINIX
@@ -503,6 +507,7 @@ MorphOS
 MPE
 MPL
 mprintf
+MPTCP
 MQTT
 mqtt
 mqtts
@@ -522,6 +527,7 @@ mTLS
 MUA
 multicwd
 multiparts
+multipath
 MultiSSL
 mumbo
 musedev
@@ -836,6 +842,7 @@ toolchain
 toolchains
 toolset
 toplevel
+TOS
 TPF
 TrackMemory
 transcode
@@ -899,6 +906,7 @@ VC
 vcpkg
 vexxhost
 Viktor
+VLAN
 VM
 VMS
 VMware
diff --git a/.github/scripts/verify-synopsis.pl b/.github/scripts/verify-synopsis.pl
index 9d3218503..aa2691794 100755
--- a/.github/scripts/verify-synopsis.pl
+++ b/.github/scripts/verify-synopsis.pl
@@ -46,17 +46,17 @@ sub extract {
     open(O, ">$cfile");
     while(<F>) {
         $iline++;
-        if(/^.SH SYNOPSIS/) {
+        if(/^# SYNOPSIS/) {
             $syn = 1
         }
         elsif($syn == 1) {
-            if(/^.nf/) {
+            if(/^\~\~\~/) {
                 $syn++;
                 print O "#line $iline \"$f\"\n";
             }
         }
         elsif($syn == 2) {
-            if(/^.fi/) {
+            if(/^\~\~\~/) {
                 last;
             }
             # turn the vararg argument into vararg
@@ -68,13 +68,17 @@ sub extract {
     close(F);
     close(O);
 
+    if($syn < 2) {
+        print STDERR "Found no synopsis in $f\n";
+        return 1;
+    }
+
     return 0;
 }
 
 my $error;
 for my $m (@files) {
-    print "Verify $m\n";
-    extract($m);
+    $error |= extract($m);
     $error |= testcompile($m);
 }
 exit $error;
diff --git a/.github/workflows/awslc.yml b/.github/workflows/awslc.yml
index 7e1a9f053..a45ef7d65 100644
--- a/.github/workflows/awslc.yml
+++ b/.github/workflows/awslc.yml
@@ -13,7 +13,6 @@ on:
       - '**/*.md'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'packages/**'
       - 'plan9/**'
@@ -26,7 +25,6 @@ on:
       - '**/*.md'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'packages/**'
       - 'plan9/**'
@@ -41,10 +39,10 @@ concurrency:
 permissions: {}
 
 env:
-  MAKEFLAGS: -j 3
+  MAKEFLAGS: -j 5
 
   # renovate: datasource=github-tags depName=awslabs/aws-lc versioning=semver registryUrl=https://github.com
-  awslc-version: 1.27.0
+  awslc-version: 1.31.0
 
 jobs:
   autoconf:
@@ -83,7 +81,7 @@ jobs:
           cmake --build . --parallel
           cmake --install .
 
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
 
       - run: autoreconf -fi
         name: 'autoreconf'
@@ -91,7 +89,7 @@ jobs:
       - run: |
           mkdir build
           cd build
-          ../configure --enable-warnings --enable-werror --with-openssl=$HOME/awslc
+          ../configure --disable-dependency-tracking --enable-warnings --enable-werror --with-openssl=$HOME/awslc
           cd ..
         name: 'configure out-of-tree'
 
@@ -143,7 +141,7 @@ jobs:
           cmake --build . --parallel
           cmake --install .
 
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
 
       - run: cmake -Bbuild -DCMAKE_UNITY_BUILD=ON -DCURL_WERROR=ON -DOPENSSL_ROOT_DIR=$HOME/awslc -DBUILD_SHARED_LIBS=ON .
         name: 'cmake generate out-of-tree'
diff --git a/.github/workflows/badwords.yml b/.github/workflows/badwords.yml
index 2bb821603..e863afabe 100644
--- a/.github/workflows/badwords.yml
+++ b/.github/workflows/badwords.yml
@@ -9,21 +9,34 @@ on:
   # master branch
   push:
     branches:
-    - master
-    - '*/ci'
+      - master
+      - '*/ci'
   pull_request:
     branches:
-    - master
+      - master
 
 permissions: {}
 
 jobs:
-  check:
+  docs:
 
     runs-on: ubuntu-latest
 
     steps:
-    - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
 
-    - name: check
-      run: ./.github/scripts/badwords.pl < .github/scripts/badwords.txt docs/*.md docs/libcurl/*.md docs/libcurl/opts/*.md docs/cmdline-opts/*.md
+      - name: check
+        run: ./.github/scripts/badwords.pl < .github/scripts/badwords.txt docs/*.md docs/libcurl/*.md docs/libcurl/opts/*.md docs/cmdline-opts/*.md docs/TODO docs/KNOWN_BUGS
+
+  source:
+    runs-on: ubuntu-latest
+
+    steps:
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
+
+      # we allow some extra in source code
+      - name: trim wordlist
+        run: grep -Ev '(\\bwill| url | dir )' .github/scripts/badwords.txt > .github/scripts/source.txt
+
+      - name: check
+        run: ./.github/scripts/badwords.pl < .github/scripts/source.txt `git ls-files -- src lib include`
diff --git a/.github/workflows/codeql-analysis.yml b/.github/workflows/codeql-analysis.yml
index a4e834653..d70ff3523 100644
--- a/.github/workflows/codeql-analysis.yml
+++ b/.github/workflows/codeql-analysis.yml
@@ -13,7 +13,6 @@ on:
       - '**/*.md'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'docs/**'
       - 'packages/**'
@@ -28,7 +27,6 @@ on:
       - '**/*.md'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'docs/**'
       - 'packages/**'
@@ -51,11 +49,11 @@ jobs:
       security-events: write
     steps:
       - name: Checkout repository
-        uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
 
       # Initializes the CodeQL tools for scanning.
       - name: Initialize CodeQL
-        uses: github/codeql-action/init@b7cec7526559c32f1616476ff32d17ba4c59b2d6 # v3
+        uses: github/codeql-action/init@afb54ba388a7dca6ecae48f608c4ff05ff4cc77a # v3
         with:
           languages: cpp
           queries: security-extended
@@ -63,7 +61,7 @@ jobs:
       # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).
       # If this step fails, then you should remove it and run the build manually (see below)
       - name: Autobuild
-        uses: github/codeql-action/autobuild@b7cec7526559c32f1616476ff32d17ba4c59b2d6 # v3
+        uses: github/codeql-action/autobuild@afb54ba388a7dca6ecae48f608c4ff05ff4cc77a # v3
 
       # â„¹ï¸ Command-line programs to run using the OS shell.
       # ðŸ“š https://git.io/JvXDl
@@ -77,4 +75,4 @@ jobs:
       #    make release
 
       - name: Perform CodeQL Analysis
-        uses: github/codeql-action/analyze@b7cec7526559c32f1616476ff32d17ba4c59b2d6 # v3
+        uses: github/codeql-action/analyze@afb54ba388a7dca6ecae48f608c4ff05ff4cc77a # v3
diff --git a/.github/workflows/codespell.yml b/.github/workflows/codespell.yml
index 01e64c433..4aa8cda89 100644
--- a/.github/workflows/codespell.yml
+++ b/.github/workflows/codespell.yml
@@ -27,7 +27,7 @@ jobs:
     runs-on: ubuntu-latest
     steps:
       - name: Checkout
-        uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
 
       - name: install
         run: |
diff --git a/.github/workflows/configure-vs-cmake.yml b/.github/workflows/configure-vs-cmake.yml
index eca6cbc71..231e76918 100644
--- a/.github/workflows/configure-vs-cmake.yml
+++ b/.github/workflows/configure-vs-cmake.yml
@@ -30,7 +30,7 @@ jobs:
   check:
     runs-on: ubuntu-latest
     steps:
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
 
       - name: run configure --with-openssl
         run: |
diff --git a/.github/workflows/curl-for-win.yml b/.github/workflows/curl-for-win.yml
index 97dc562a1..87927278c 100644
--- a/.github/workflows/curl-for-win.yml
+++ b/.github/workflows/curl-for-win.yml
@@ -9,9 +9,27 @@ on:
     branches:
       - master
       - '*/ci'
+    paths-ignore:
+      - '**/*.md'
+      - '.azure-pipelines.yml'
+      - '.circleci/**'
+      - 'appveyor.*'
+      - 'packages/**'
+      - 'plan9/**'
+      - 'projects/**'
+      - 'winbuild/**'
   pull_request:
     branches:
       - master
+    paths-ignore:
+      - '**/*.md'
+      - '.azure-pipelines.yml'
+      - '.circleci/**'
+      - 'appveyor.*'
+      - 'packages/**'
+      - 'plan9/**'
+      - 'projects/**'
+      - 'winbuild/**'
 
 concurrency:
   group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.sha }}
@@ -22,7 +40,7 @@ permissions: {}
 env:
   CW_NOGET: 'curl trurl'
   CW_MAP: '0'
-  CW_JOBS: '3'
+  CW_JOBS: '5'
   CW_NOPKG: '1'
   DOCKER_CONTENT_TRUST: '1'
 
@@ -31,7 +49,7 @@ jobs:
     runs-on: ubuntu-latest
     timeout-minutes: 30
     steps:
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
         with:
           path: 'curl'
           fetch-depth: 8
@@ -54,8 +72,10 @@ jobs:
   mac-clang:
     runs-on: macos-latest
     timeout-minutes: 30
+    env:
+      CW_JOBS: '4'
     steps:
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
         with:
           path: 'curl'
           fetch-depth: 8
@@ -70,7 +90,7 @@ jobs:
   win-llvm:
     runs-on: ubuntu-latest
     steps:
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
         with:
           path: 'curl'
           fetch-depth: 8
diff --git a/.github/workflows/distcheck.yml b/.github/workflows/distcheck.yml
index b7a1d3098..aa047c2cb 100644
--- a/.github/workflows/distcheck.yml
+++ b/.github/workflows/distcheck.yml
@@ -24,7 +24,7 @@ jobs:
     runs-on: ubuntu-latest
     timeout-minutes: 30
     steps:
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
 
       - run: sudo apt-get purge -y curl libcurl4 libcurl4-doc
         name: 'remove preinstalled curl libcurl4{-doc}'
@@ -50,7 +50,7 @@ jobs:
           mkdir run2; cp -p ./curl-99.98.97.* run2/
           diff run1 run2
 
-      - uses: actions/upload-artifact@65462800fd760344b1a7b4382951275a0abb4808 # v4
+      - uses: actions/upload-artifact@0b2256b8c012f0828dc542b3febcab082c67f72b # v4
         with:
           name: 'release-tgz'
           path: 'curl-99.98.97.tar.gz'
@@ -60,9 +60,9 @@ jobs:
           tar xvf curl-99.98.97.tar.gz
           pushd curl-99.98.97
           ./configure --prefix=$HOME/temp --without-ssl --without-libpsl
-          make -j3
-          make -j3 test-ci
-          make -j3 install
+          make -j5
+          make -j5 test-ci
+          make -j5 install
           popd
           # basic check of the installed files
           bash scripts/installcheck.sh $HOME/temp
@@ -74,7 +74,7 @@ jobs:
     timeout-minutes: 30
     needs: maketgz-and-verify-in-tree
     steps:
-      - uses: actions/download-artifact@65a9edc5881444af0b9093a5e628f2fe47ea3b2e # v4
+      - uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4
         with:
           name: 'release-tgz'
 
@@ -85,8 +85,8 @@ jobs:
           mkdir build
           pushd build
           ../curl-99.98.97/configure --without-ssl --without-libpsl
-          make -j3
-          make -j3 test-ci
+          make -j5
+          make -j5 test-ci
           popd
           rm -rf build
           rm -rf curl-99.98.97
@@ -97,7 +97,7 @@ jobs:
     timeout-minutes: 30
     needs: maketgz-and-verify-in-tree
     steps:
-      - uses: actions/download-artifact@65a9edc5881444af0b9093a5e628f2fe47ea3b2e # v4
+      - uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4
         with:
           name: 'release-tgz'
 
@@ -108,9 +108,9 @@ jobs:
           mkdir build
           pushd build
           ../configure --without-ssl --enable-debug "--prefix=${PWD}/pkg" --without-libpsl
-          make -j3
-          make -j3 test-ci
-          make -j3 install
+          make -j5
+          make -j5 test-ci
+          make -j5 install
         name: 'verify out-of-tree autotools debug build'
 
   verify-out-of-tree-cmake:
@@ -118,7 +118,7 @@ jobs:
     timeout-minutes: 30
     needs: maketgz-and-verify-in-tree
     steps:
-      - uses: actions/download-artifact@65a9edc5881444af0b9093a5e628f2fe47ea3b2e # v4
+      - uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4
         with:
           name: 'release-tgz'
 
@@ -127,5 +127,5 @@ jobs:
           tar xvf curl-99.98.97.tar.gz
           pushd curl-99.98.97
           cmake -B build -DCURL_WERROR=ON
-          make -C build -j3
+          make -C build -j5
         name: 'verify out-of-tree cmake build'
diff --git a/.github/workflows/fuzz.yml b/.github/workflows/fuzz.yml
index 247a1c0ab..20774292b 100644
--- a/.github/workflows/fuzz.yml
+++ b/.github/workflows/fuzz.yml
@@ -14,7 +14,6 @@ on:
       - '**/CMakeLists.txt'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'CMake/**'
       - 'packages/**'
@@ -30,7 +29,6 @@ on:
       - '**/CMakeLists.txt'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'CMake/**'
       - 'packages/**'
diff --git a/.github/workflows/hacktoberfest-accepted.yml b/.github/workflows/hacktoberfest-accepted.yml
index 17ab6557d..02afb53de 100644
--- a/.github/workflows/hacktoberfest-accepted.yml
+++ b/.github/workflows/hacktoberfest-accepted.yml
@@ -26,7 +26,7 @@ jobs:
       issues: write
       pull-requests: write
     steps:
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
         with:
           fetch-depth: 100
 
diff --git a/.github/workflows/http3-linux.yml b/.github/workflows/http3-linux.yml
new file mode 100644
index 000000000..618f3769c
--- /dev/null
+++ b/.github/workflows/http3-linux.yml
@@ -0,0 +1,477 @@
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+#
+# SPDX-License-Identifier: curl
+
+name: http3-linux
+
+on:
+  push:
+    branches:
+      - master
+      - '*/ci'
+    paths-ignore:
+      - '**/*.md'
+      - '**/CMakeLists.txt'
+      - '.azure-pipelines.yml'
+      - '.circleci/**'
+      - 'appveyor.*'
+      - 'CMake/**'
+      - 'packages/**'
+      - 'plan9/**'
+      - 'projects/**'
+      - 'winbuild/**'
+  pull_request:
+    branches:
+      - master
+    paths-ignore:
+      - '**/*.md'
+      - '**/CMakeLists.txt'
+      - '.azure-pipelines.yml'
+      - '.circleci/**'
+      - 'appveyor.*'
+      - 'CMake/**'
+      - 'packages/**'
+      - 'plan9/**'
+      - 'projects/**'
+      - 'winbuild/**'
+
+concurrency:
+  # Hardcoded workflow filename as workflow name above is just Linux again
+  group: http3-${{ github.event.pull_request.number || github.sha }}
+  cancel-in-progress: true
+
+permissions: {}
+
+env:
+  MAKEFLAGS: -j 5
+  # handled in renovate.json
+  openssl3-version: openssl-3.3.0
+  # unhandled
+  quictls-version: 3.1.4+quic
+  # renovate: datasource=github-tags depName=gnutls/gnutls versioning=semver registryUrl=https://github.com
+  gnutls-version: 3.8.6
+  wolfssl-version: master
+  # renovate: datasource=github-tags depName=ngtcp2/nghttp3 versioning=semver registryUrl=https://github.com
+  nghttp3-version: 1.4.0
+  # renovate: datasource=github-tags depName=ngtcp2/ngtcp2 versioning=semver registryUrl=https://github.com
+  ngtcp2-version: 1.6.0
+  # renovate: datasource=github-tags depName=nghttp2/nghttp2 versioning=semver registryUrl=https://github.com
+  nghttp2-version: 1.62.1
+  # renovate: datasource=github-tags depName=cloudflare/quiche versioning=semver registryUrl=https://github.com
+  quiche-version: 0.22.0
+  # renovate: datasource=github-tags depName=icing/mod_h2 versioning=semver registryUrl=https://github.com
+  mod_h2-version: 2.0.29
+
+jobs:
+  setup:
+    runs-on: ubuntu-latest
+    outputs:
+      wolfssl-version: ${{ steps.wolfssl-version.outputs.result }}
+
+    steps:
+      - id: wolfssl-version
+        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
+        with:
+          result-encoding: string
+          script: |
+            let version = '${{ env.wolfssl-version }}'
+
+            if (version != 'master') {
+                return version
+            }
+
+            let { data: commits } = await github.rest.repos.listCommits({
+                owner: 'wolfSSL',
+                repo: 'wolfssl',
+            })
+
+            return commits[0].sha
+
+  build-cache:
+    needs:
+      - setup
+    runs-on: ubuntu-latest
+
+    steps:
+      - name: cache quictls
+        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
+        id: cache-quictls-no-deprecated
+        env:
+          cache-name: cache-quictls-no-deprecated
+        with:
+          path: /home/runner/quictls/build
+          key: ${{ runner.os }}-http3-build-${{ env.cache-name }}-${{ env.quictls-version }}
+
+      - name: cache gnutls
+        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
+        id: cache-gnutls
+        env:
+          cache-name: cache-gnutls
+        with:
+          path: /home/runner/gnutls/build
+          key: ${{ runner.os }}-http3-build-${{ env.cache-name }}-${{ env.gnutls-version }}
+
+      - name: cache wolfssl
+        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
+        id: cache-wolfssl
+        env:
+          cache-name: cache-wolfssl
+          wolfssl-version: ${{ needs.setup.outputs.wolfssl-version }}
+        with:
+          path: /home/runner/wolfssl/build
+          key: ${{ runner.os }}-http3-build-${{ env.cache-name }}-${{ env.wolfssl-version }}
+
+      - name: cache nghttp3
+        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
+        id: cache-nghttp3
+        env:
+          cache-name: cache-nghttp3
+        with:
+          path: /home/runner/nghttp3/build
+          key: ${{ runner.os }}-http3-build-${{ env.cache-name }}-${{ env.nghttp3-version }}
+
+      - name: cache ngtcp2
+        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
+        id: cache-ngtcp2
+        env:
+          cache-name: cache-ngtcp2
+        with:
+          path: /home/runner/ngtcp2/build
+          key: ${{ runner.os }}-http3-build-${{ env.cache-name }}-${{ env.ngtcp2-version }}
+
+      - name: cache nghttp2
+        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
+        id: cache-nghttp2
+        env:
+          cache-name: cache-nghttp2
+        with:
+          path: /home/runner/nghttp2/build
+          key: ${{ runner.os }}-http3-build-${{ env.cache-name }}-${{ env.nghttp2-version }}
+
+      - id: settings
+        if: |
+          steps.cache-quictls-no-deprecated.outputs.cache-hit != 'true' ||
+          steps.cache-gnutls.outputs.cache-hit != 'true' ||
+          steps.cache-wolfssl.outputs.cache-hit != 'true' ||
+          steps.cache-nghttp3.outputs.cache-hit != 'true' ||
+          steps.cache-ngtcp2.outputs.cache-hit != 'true' ||
+          steps.cache-nghttp2.outputs.cache-hit != 'true'
+        run: |
+          echo 'needs-build=true' >> $GITHUB_OUTPUT
+
+      - name: install build prerequisites
+        if: steps.settings.outputs.needs-build == 'true'
+        run: |
+          sudo rm -f /etc/apt/sources.list.d/microsoft-prod.list
+          sudo apt-get update
+          sudo apt-get install libtool autoconf automake pkg-config stunnel4 \
+            libpsl-dev libbrotli-dev libzstd-dev zlib1g-dev libev-dev libc-ares-dev \
+            nettle-dev libp11-kit-dev libtspi-dev libunistring-dev guile-2.2-dev libtasn1-bin \
+            libtasn1-6-dev libidn2-0-dev gawk gperf libtss2-dev dns-root-data bison gtk-doc-tools \
+            texinfo texlive texlive-extra-utils autopoint libev-dev \
+            apache2 apache2-dev libnghttp2-dev
+          echo 'CC=gcc-12' >> $GITHUB_ENV
+          echo 'CXX=g++-12' >> $GITHUB_ENV
+
+      - if: steps.cache-quictls-no-deprecated.outputs.cache-hit != 'true'
+        run: |
+          cd $HOME
+          git clone --quiet --depth=1 -b openssl-${{ env.quictls-version }} https://github.com/quictls/openssl quictls
+          cd quictls
+          ./config no-deprecated --prefix=$PWD/build --libdir=lib
+          make
+          make -j1 install_sw
+        name: 'build quictls'
+
+      - if: steps.cache-gnutls.outputs.cache-hit != 'true'
+        run: |
+          cd $HOME
+          git clone --quiet --depth=1 -b ${{ env.gnutls-version }} https://github.com/gnutls/gnutls.git
+          cd gnutls
+          ./bootstrap
+          ./configure --disable-dependency-tracking --prefix=$PWD/build \
+            LDFLAGS="-Wl,-rpath,$PWD/build/lib -L$PWD/build/lib" \
+            --with-included-libtasn1 --with-included-unistring \
+            --disable-guile --disable-doc --disable-tests --disable-tools
+          make
+          make install
+        name: 'build gnutls'
+
+      - if: steps.cache-wolfssl.outputs.cache-hit != 'true'
+        env:
+          wolfssl-version: ${{ needs.setup.outputs.wolfssl-version }}
+        run: |
+          cd $HOME
+          mkdir wolfssl
+          cd wolfssl
+          git init
+          git remote add origin https://github.com/wolfSSL/wolfssl.git
+          git fetch origin --depth=1 ${{ env.wolfssl-version }}
+          git checkout ${{ env.wolfssl-version }}
+          ./autogen.sh
+          ./configure --disable-dependency-tracking --enable-all --enable-quic --prefix=$PWD/build
+          make
+          make install
+        name: 'build wolfssl'
+
+      - if: steps.cache-nghttp3.outputs.cache-hit != 'true'
+        run: |
+          cd $HOME
+          git clone --quiet --depth=1 -b v${{ env.nghttp3-version }} https://github.com/ngtcp2/nghttp3
+          cd nghttp3
+          git submodule update --init
+          autoreconf -fi
+          ./configure --disable-dependency-tracking --prefix=$PWD/build PKG_CONFIG_PATH="$PWD/build/lib/pkgconfig" --enable-lib-only
+          make
+          make install
+        name: 'build nghttp3'
+
+      - if: steps.cache-ngtcp2.outputs.cache-hit != 'true'
+        run: |
+          cd $HOME
+          git clone --quiet --depth=1 -b v${{ env.ngtcp2-version }} https://github.com/ngtcp2/ngtcp2
+          cd ngtcp2
+          autoreconf -fi
+          ./configure --disable-dependency-tracking --prefix=$PWD/build \
+            PKG_CONFIG_PATH="$PWD/build/lib/pkgconfig:$HOME/quictls/build/lib/pkgconfig:$HOME/gnutls/build/lib/pkgconfig:$HOME/wolfssl/build/lib/pkgconfig:$HOME/nghttp3/build/lib/pkgconfig" \
+            --enable-lib-only --with-openssl --with-gnutls --with-wolfssl
+          make install
+        name: 'build ngtcp2'
+
+      - if: steps.cache-nghttp2.outputs.cache-hit != 'true'
+        run: |
+          cd $HOME
+          git clone --quiet --depth=1 -b v${{ env.nghttp2-version }} https://github.com/nghttp2/nghttp2
+          cd nghttp2
+          autoreconf -fi
+          ./configure --disable-dependency-tracking --prefix=$PWD/build \
+            PKG_CONFIG_PATH="$HOME/build/lib/pkgconfig:$HOME/quictls/build/lib/pkgconfig:$HOME/nghttp3/build/lib/pkgconfig:$HOME/ngtcp2/build/lib/pkgconfig" \
+            LDFLAGS="-Wl,-rpath,$HOME/quictls/build/lib" \
+            --enable-http3
+          make install
+        name: 'build nghttp2'
+
+  autotools:
+    name: ${{ matrix.build.name }}
+    needs:
+      - setup
+      - build-cache
+    runs-on: 'ubuntu-latest'
+    timeout-minutes: 60
+    strategy:
+      fail-fast: false
+      matrix:
+        build:
+          - name: quictls
+            configure: >-
+              PKG_CONFIG_PATH="$HOME/quictls/build/lib/pkgconfig:$HOME/nghttp3/build/lib/pkgconfig:$HOME/ngtcp2/build/lib/pkgconfig:$HOME/nghttp2/build/lib/pkgconfig" LDFLAGS="-Wl,-rpath,$HOME/quictls/build/lib"
+              --with-ngtcp2=$HOME/ngtcp2/build --enable-warnings --enable-werror --enable-debug --disable-ntlm
+              --with-test-nghttpx="$HOME/nghttp2/build/bin/nghttpx"
+              --with-openssl=$HOME/quictls/build
+          - name: gnutls
+            configure: >-
+              PKG_CONFIG_PATH="$HOME/gnutls/build/lib/pkgconfig:$HOME/nghttp3/build/lib/pkgconfig:$HOME/ngtcp2/build/lib/pkgconfig:$HOME/nghttp2/build/lib/pkgconfig" LDFLAGS="-Wl,-rpath,$HOME/gnutls/build/lib"
+              --with-ngtcp2=$HOME/ngtcp2/build --enable-warnings --enable-werror --enable-debug
+              --with-test-nghttpx="$HOME/nghttp2/build/bin/nghttpx"
+              --with-gnutls=$HOME/gnutls/build
+          - name: wolfssl
+            configure: >-
+              PKG_CONFIG_PATH="$HOME/wolfssl/build/lib/pkgconfig:$HOME/nghttp3/build/lib/pkgconfig:$HOME/ngtcp2/build/lib/pkgconfig:$HOME/nghttp2/build/lib/pkgconfig" LDFLAGS="-Wl,-rpath,$HOME/wolfssl/build/lib"
+              --with-ngtcp2=$HOME/ngtcp2/build --enable-warnings --enable-werror --enable-debug
+              --with-test-nghttpx="$HOME/nghttp2/build/bin/nghttpx"
+              --with-wolfssl=$HOME/wolfssl/build
+          - name: openssl-quic
+            configure: >-
+              PKG_CONFIG_PATH="$HOME/openssl3/build/lib64/pkgconfig" LDFLAGS="-Wl,-rpath,$HOME/openssl3/build/lib64"
+              --enable-warnings --enable-werror --enable-debug --disable-ntlm
+              --with-test-nghttpx="$HOME/nghttp2/build/bin/nghttpx"
+              --with-openssl=$HOME/openssl3/build --with-openssl-quic
+              --with-nghttp3=$HOME/nghttp3/build
+          - name: quiche
+            configure: >-
+              LDFLAGS="-Wl,-rpath,/home/runner/quiche/target/release"
+              --with-openssl=/home/runner/quiche/quiche/deps/boringssl/src
+              --enable-warnings --enable-werror --enable-debug
+              --with-quiche=/home/runner/quiche/target/release
+              --with-test-nghttpx="$HOME/nghttp2/build/bin/nghttpx"
+              --with-ca-fallback
+
+    steps:
+      - run: |
+          sudo rm -f /etc/apt/sources.list.d/microsoft-prod.list
+          sudo apt-get update
+          sudo apt-get install libtool autoconf automake pkg-config stunnel4 \
+            libpsl-dev libbrotli-dev libzstd-dev zlib1g-dev libev-dev libc-ares-dev \
+            nettle-dev libp11-kit-dev libtspi-dev libunistring-dev guile-2.2-dev libtasn1-bin \
+            libtasn1-6-dev libidn2-0-dev gawk gperf libtss2-dev dns-root-data bison gtk-doc-tools \
+            texinfo texlive texlive-extra-utils autopoint libev-dev \
+            apache2 apache2-dev libnghttp2-dev vsftpd
+          echo 'CC=gcc-12' >> $GITHUB_ENV
+          echo 'CXX=g++-12' >> $GITHUB_ENV
+        name: 'install prereqs and impacket, pytest, crypto, apache2'
+
+      - name: cache quictls
+        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
+        id: cache-quictls-no-deprecated
+        env:
+          cache-name: cache-quictls-no-deprecated
+        with:
+          path: /home/runner/quictls/build
+          key: ${{ runner.os }}-http3-build-${{ env.cache-name }}-${{ env.quictls-version }}
+          fail-on-cache-miss: true
+
+      - name: cache gnutls
+        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
+        id: cache-gnutls
+        env:
+          cache-name: cache-gnutls
+        with:
+          path: /home/runner/gnutls/build
+          key: ${{ runner.os }}-http3-build-${{ env.cache-name }}-${{ env.gnutls-version }}
+          fail-on-cache-miss: true
+
+      - name: cache wolfssl
+        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
+        id: cache-wolfssl
+        env:
+          cache-name: cache-wolfssl
+          wolfssl-version: ${{ needs.setup.outputs.wolfssl-version }}
+        with:
+          path: /home/runner/wolfssl/build
+          key: ${{ runner.os }}-http3-build-${{ env.cache-name }}-${{ env.wolfssl-version }}
+          fail-on-cache-miss: true
+
+      - name: cache nghttp3
+        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
+        id: cache-nghttp3
+        env:
+          cache-name: cache-nghttp3
+        with:
+          path: /home/runner/nghttp3/build
+          key: ${{ runner.os }}-http3-build-${{ env.cache-name }}-${{ env.nghttp3-version }}
+          fail-on-cache-miss: true
+
+      - name: cache ngtcp2
+        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
+        id: cache-ngtcp2
+        env:
+          cache-name: cache-ngtcp2
+        with:
+          path: /home/runner/ngtcp2/build
+          key: ${{ runner.os }}-http3-build-${{ env.cache-name }}-${{ env.ngtcp2-version }}
+          fail-on-cache-miss: true
+
+      - name: cache nghttp2
+        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
+        id: cache-nghttp2
+        env:
+          cache-name: cache-nghttp2
+        with:
+          path: /home/runner/nghttp2/build
+          key: ${{ runner.os }}-http3-build-${{ env.cache-name }}-${{ env.nghttp2-version }}
+          fail-on-cache-miss: true
+
+      - name: cache openssl3
+        if: matrix.build.name == 'openssl-quic'
+        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
+        id: cache-openssl3
+        env:
+          cache-name: cache-openssl3
+        with:
+          path: /home/runner/openssl3/build
+          key: ${{ runner.os }}-http3-build-${{ env.cache-name }}-${{ env.openssl3-version }}
+
+      - name: 'install openssl3'
+        if: matrix.build.name == 'openssl-quic' && steps.cache-openssl3.outputs.cache-hit != 'true'
+        run: |
+          git clone --quiet --depth=1 -b ${{ env.openssl3-version }} https://github.com/openssl/openssl
+          cd openssl
+          ./config --prefix=$HOME/openssl3/build
+          make -j1 install_sw
+          cat exporters/openssl.pc
+
+      - name: cache quiche
+        if: matrix.build.name == 'quiche'
+        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
+        id: cache-quiche
+        env:
+          cache-name: cache-quiche
+        with:
+          path: /home/runner/quiche
+          key: ${{ runner.os }}-http3-build-${{ env.cache-name }}-quiche-${{ env.quiche-version }}
+
+      - if: matrix.build.name == 'quiche' && steps.cache-quiche.outputs.cache-hit != 'true'
+        run: |
+          cd $HOME
+          git clone --quiet --depth=1 -b ${{ env.quiche-version }} --recursive https://github.com/cloudflare/quiche.git
+          cd quiche
+          #### Work-around https://github.com/curl/curl/issues/7927 #######
+          #### See https://github.com/alexcrichton/cmake-rs/issues/131 ####
+          sed -i -e 's/cmake = "0.1"/cmake = "=0.1.45"/' quiche/Cargo.toml
+
+          cargo build -v --package quiche --release --features ffi,pkg-config-meta,qlog --verbose
+          ln -s libquiche.so target/release/libquiche.so.0
+          mkdir -v quiche/deps/boringssl/src/lib
+          ln -vnf $(find target/release -name libcrypto.a -o -name libssl.a) quiche/deps/boringssl/src/lib/
+
+          # include dir
+          # /home/runner/quiche/quiche/deps/boringssl/src/include
+          # lib dir
+          # /home/runner/quiche/quiche/deps/boringssl/src/lib
+        name: 'build quiche and boringssl'
+
+      - name: cache mod_h2
+        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
+        id: cache-mod_h2
+        env:
+          cache-name: cache-mod_h2
+        with:
+          path: /home/runner/mod_h2
+          key: ${{ runner.os }}-http3-build-${{ env.cache-name }}-${{ env.mod_h2-version }}
+
+      - if: steps.cache-mod_h2.outputs.cache-hit != 'true'
+        run: |
+          cd $HOME
+          git clone --quiet --depth=1 -b v${{ env.mod_h2-version }} https://github.com/icing/mod_h2
+          cd mod_h2
+          autoreconf -fi
+          ./configure
+          make
+        name: 'build mod_h2'
+
+      - run: |
+          cd $HOME/mod_h2
+          sudo make install
+        name: 'install mod_h2'
+
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
+
+      - run: |
+          sudo python3 -m pip install -r tests/requirements.txt -r tests/http/requirements.txt
+        name: 'install python test prereqs'
+
+      - run: autoreconf -fi
+        name: 'autoreconf'
+
+      - run: ./configure --disable-dependency-tracking ${{ matrix.build.configure }}
+        name: 'configure'
+
+      - run: make V=1
+        name: 'make'
+
+      - run: make V=1 examples
+        name: 'make examples'
+
+      - run: make V=1 -C tests
+        name: 'make tests'
+
+      - run: make V=1 test-ci
+        name: 'run tests'
+        env:
+          TFLAGS: "${{ matrix.build.tflags }}"
+
+      - run: pytest -v tests
+        name: 'run pytest'
+        env:
+          TFLAGS: "${{ matrix.build.tflags }}"
+          CURL_CI: github
diff --git a/.github/workflows/linkcheck.yml b/.github/workflows/linkcheck.yml
index 0b7e08792..fff8515d4 100644
--- a/.github/workflows/linkcheck.yml
+++ b/.github/workflows/linkcheck.yml
@@ -30,7 +30,7 @@ jobs:
   check:
     runs-on: ubuntu-latest
     steps:
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
         name: checkout
 
       - name: trim the cmdline docs markdown files
diff --git a/.github/workflows/linux-old.yml b/.github/workflows/linux-old.yml
index ff1663580..0aec21683 100644
--- a/.github/workflows/linux-old.yml
+++ b/.github/workflows/linux-old.yml
@@ -9,7 +9,7 @@
 # Debian stretch is chosen as it closely matches some of the oldest major
 # versions we support (especially cmake); see docs/INTERNALS.md and it
 # is still supported (as of this writing).
-# stretch has ELTS support from Feexian until 2027-06-30
+# stretch has ELTS support from Freexian until 2027-06-30
 # For ELTS info see https://www.freexian.com/lts/extended/docs/how-to-use-extended-lts/
 # The Debian key will expire 2025-05-20, after which package signature
 # verification may need to be disabled.
@@ -27,7 +27,6 @@ on:
       - '**/*.md'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'packages/**'
       - 'plan9/**'
@@ -40,7 +39,6 @@ on:
       - '**/*.md'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'packages/**'
       - 'plan9/**'
@@ -50,7 +48,7 @@ on:
 permissions: {}
 
 env:
-  MAKEFLAGS: -j 3
+  MAKEFLAGS: -j 5
   DEBIAN_FRONTEND: noninteractive
 
 jobs:
@@ -74,10 +72,10 @@ jobs:
           apt-get install -y --no-install-suggests --no-install-recommends cmake make gcc pkg-config libpsl-dev libzstd-dev zlib1g-dev libssl1.0-dev libssh-dev libssh2-1-dev libc-ares-dev heimdal-dev libldap2-dev stunnel4 groff
           # GitHub's actions/checkout needs a newer glibc. This one is the
           # latest available for buster, the next stable release after stretch.
-          httrack --get https://security.debian.org/debian-security/pool/updates/main/g/glibc/libc6_2.28-10+deb10u3_amd64.deb
-          dpkg -i libc6_2.28-10+deb10u3_amd64.deb
+          httrack --get https://security.debian.org/debian-security/pool/updates/main/g/glibc/libc6_2.28-10+deb10u4_amd64.deb
+          dpkg -i libc6_*_amd64.deb
 
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
 
       - name: 'cmake build-only (out-of-tree, libssh2)'
         run: |
@@ -91,8 +89,7 @@ jobs:
         run: |
           mkdir bld-cares
           cd bld-cares
-          cmake .. -DCMAKE_UNITY_BUILD=ON -DCURL_WERROR=ON -DBUILD_SHARED_LIBS=ON -DENABLE_ARES=ON -DCURL_ZSTD=ON -DCURL_USE_GSSAPI=ON -DCURL_USE_LIBSSH2=OFF \
-            -DUSE_LIBSSH=ON '-DCMAKE_C_FLAGS=-I/usr/include -L/usr/lib -lssh'
+          cmake .. -DCMAKE_UNITY_BUILD=ON -DCURL_WERROR=ON -DBUILD_SHARED_LIBS=ON -DENABLE_ARES=ON -DCURL_ZSTD=ON -DCURL_USE_GSSAPI=ON -DCURL_USE_LIBSSH2=OFF -DCURL_USE_LIBSSH=ON
 
       - name: 'build'
         run: |
diff --git a/.github/workflows/linux.yml b/.github/workflows/linux.yml
index d974f28b1..bde8fb60a 100644
--- a/.github/workflows/linux.yml
+++ b/.github/workflows/linux.yml
@@ -13,7 +13,6 @@ on:
       - '**/*.md'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'packages/**'
       - 'plan9/**'
@@ -26,7 +25,6 @@ on:
       - '**/*.md'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'packages/**'
       - 'plan9/**'
@@ -40,15 +38,15 @@ concurrency:
 permissions: {}
 
 env:
-  MAKEFLAGS: -j 3
+  MAKEFLAGS: -j 5
   # unhandled
   bearssl-version: 0.6
   # renovate: datasource=github-tags depName=libressl-portable/portable versioning=semver registryUrl=https://github.com
   libressl-version: 3.9.2
   # renovate: datasource=github-tags depName=ARMmbed/mbedtls versioning=semver registryUrl=https://github.com
-  mbedtls-version: 3.5.0
+  mbedtls-version: 3.6.0
   # renovate: datasource=github-tags depName=icing/mod_h2 versioning=semver registryUrl=https://github.com
-  mod_h2-version: 2.0.27
+  mod_h2-version: 2.0.29
   # renovate: datasource=github-tags depName=nibanks/msh3 versioning=semver registryUrl=https://github.com
   msh3-version: 0.6.0
   # handled in renovate.json
@@ -204,7 +202,7 @@ jobs:
           apk add --no-cache build-base autoconf automake libtool perl openssl-dev libssh2-dev zlib-dev brotli-dev zstd-dev libidn2-dev openldap-dev heimdal-dev libpsl-dev py3-impacket py3-asn1 py3-six py3-pycryptodomex perl-time-hires openssh stunnel sudo git
         name: 'install dependencies'
 
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
 
       - name: Fix kernel mmap rnd bits
         # Asan in llvm 14 provided in ubuntu 22.04 is incompatible with
@@ -261,7 +259,7 @@ jobs:
           git clone --quiet --depth=1 -b v${{ env.libressl-version }} https://github.com/libressl-portable/portable.git libressl-git
           cd libressl-git
           ./autogen.sh
-          ./configure --prefix=$HOME/libressl
+          ./configure --disable-dependency-tracking --prefix=$HOME/libressl
           make install
 
       - name: cache mbedtls
@@ -297,7 +295,7 @@ jobs:
         run: |
           git clone --quiet --depth=1 -b ${{ env.openssl3-version }} https://github.com/openssl/openssl
           cd openssl
-          ./config --prefix=$HOME/openssl3 --libdir=$HOME/openssl3/lib
+          ./config --prefix=$HOME/openssl3 --libdir=lib
           make -j1 install_sw
 
       - name: cache quictls
@@ -315,7 +313,7 @@ jobs:
         run: |
           git clone --quiet --depth=1 -b openssl-${{ env.quictls-version }} https://github.com/quictls/openssl
           cd openssl
-          ./config --prefix=$HOME/quictls --libdir=$HOME/quictls/lib
+          ./config --prefix=$HOME/quictls --libdir=lib
           make -j1 install_sw
 
       - name: cache msh3
@@ -416,7 +414,7 @@ jobs:
       - run: autoreconf -fi
         name: 'autoreconf'
 
-      - run: ./configure --enable-warnings --enable-werror ${{ matrix.build.configure }}
+      - run: ./configure --disable-dependency-tracking --enable-warnings --enable-werror ${{ matrix.build.configure }}
         name: 'configure'
 
       - run: make V=1
diff --git a/.github/workflows/linux32.yml b/.github/workflows/linux32.yml
index a9a4d9535..eb7cb8ac8 100644
--- a/.github/workflows/linux32.yml
+++ b/.github/workflows/linux32.yml
@@ -14,7 +14,6 @@ on:
       - '**/CMakeLists.txt'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'CMake/**'
       - 'packages/**'
@@ -29,7 +28,6 @@ on:
       - '**/CMakeLists.txt'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'CMake/**'
       - 'packages/**'
@@ -44,7 +42,7 @@ concurrency:
 permissions: {}
 
 env:
-  MAKEFLAGS: -j 3
+  MAKEFLAGS: -j 5
 
 jobs:
   linux-i686:
@@ -68,12 +66,12 @@ jobs:
           sudo python3 -m pip install impacket
         name: 'install prereqs'
 
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
 
       - run: autoreconf -fi
         name: 'autoreconf'
 
-      - run: ./configure --enable-warnings --enable-werror ${{ matrix.build.configure }}
+      - run: ./configure --disable-dependency-tracking --enable-warnings --enable-werror ${{ matrix.build.configure }}
         name: 'configure'
 
       - run: make V=1
diff --git a/.github/workflows/macos.yml b/.github/workflows/macos.yml
index 72b303d60..c5e8e4535 100644
--- a/.github/workflows/macos.yml
+++ b/.github/workflows/macos.yml
@@ -13,7 +13,6 @@ on:
       - '**/*.md'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'packages/**'
       - 'plan9/**'
@@ -26,7 +25,6 @@ on:
       - '**/*.md'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'packages/**'
       - 'plan9/**'
@@ -39,124 +37,129 @@ concurrency:
 
 permissions: {}
 
+# Deprecated Apple APIs and the macos-version-min value required to avoid
+# deprecation warnings with llvm/clang:
+#
+# - 10.7  Lion (2011)          - GSS
+# - 10.8  Mountain Lion (2012) - CFURLCreateDataAndPropertiesFromResource (used by curl SecureTransport code)
+# - 10.9  Maverick (2013)      - LDAP
+# - 10.14 Mojave (2018)        - SecureTransport
+#
+# For SecureTransport, curl implements features that require a target
+# newer than the 10.8 required by `CFURLCreateDataAndPropertiesFromResource`.
+# In this case `-Wno-deprecated-declarations` still comes handy to pacify
+# deprecation warnings, though the real solution would be to avoid calling
+# that function.
+
 env:
-  DEVELOPER_DIR: /Applications/Xcode.app/Contents/Developer
-  MAKEFLAGS: -j 5
+  LDFLAGS: -w  # suppress 'object file was built for newer macOS version than being linked' warnings
+  MAKEFLAGS: -j 4
 
 jobs:
   autotools:
-    name: ${{ matrix.build.name }}
+    name: 'AM ${{ matrix.compiler }} ${{ matrix.name }}'
     runs-on: 'macos-latest'
-    timeout-minutes: 90
+    timeout-minutes: 60
+    env:
+      DEVELOPER_DIR: "/Applications/Xcode${{ matrix.xcode && format('_{0}', matrix.xcode) || '' }}.app/Contents/Developer"
+      CC: ${{ matrix.compiler }}
+      CFLAGS: '-mmacosx-version-min=${{ matrix.macos-version-min }}'
     strategy:
       fail-fast: false
       matrix:
-        build:
-          - name: normal
-            install: nghttp2
+        include:
+          - name: '!ssl !debug'
+            compiler: clang
             configure: --without-ssl --enable-websockets
-            macosx-version-min: 10.9
-          - name: debug
-            install: nghttp2
+            macos-version-min: '10.9'
+          - name: '!ssl !debug'
+            compiler: gcc-12
+            configure: --without-ssl --enable-websockets
+            macos-version-min: '10.9'
+          - name: '!ssl'
+            compiler: clang
             configure: --enable-debug --without-ssl --enable-websockets
-            macosx-version-min: 10.9
-          - name: libssh2
-            install: nghttp2 libssh2
-            configure: --enable-debug --with-libssh2=$(brew --prefix)/opt/libssh2 --without-ssl --enable-websockets
-            macosx-version-min: 10.9
-          - name: libssh-c-ares
-            install: openssl nghttp2 libssh
-            configure: --enable-debug --with-libssh --with-openssl=$(brew --prefix)/opt/openssl --enable-ares --enable-websockets
-            macosx-version-min: 10.9
-          - name: libssh
-            install: openssl nghttp2 libssh
-            configure: --enable-debug --with-libssh --with-openssl=$(brew --prefix)/opt/openssl --enable-websockets
-            macosx-version-min: 10.9
-          - name: c-ares
-            install: nghttp2
+            macos-version-min: '10.9'
+          - name: '!ssl libssh2'
+            compiler: clang
+            configure: --enable-debug --with-libssh2=$(brew --prefix libssh2) --without-ssl --enable-websockets
+            macos-version-min: '10.9'
+          - name: 'OpenSSL libssh c-ares'
+            compiler: clang
+            install: libssh
+            configure: --enable-debug --with-libssh --with-openssl=$(brew --prefix openssl) --enable-ares --enable-websockets
+            macos-version-min: '10.9'
+          - name: 'OpenSSL libssh'
+            compiler: llvm@15
+            install: libssh
+            configure: --enable-debug --with-libssh --with-openssl=$(brew --prefix openssl) --enable-websockets
+            macos-version-min: '10.9'
+          - name: '!ssl c-ares'
+            compiler: clang
             configure: --enable-debug --enable-ares --without-ssl --enable-websockets
-            macosx-version-min: 10.9
-          - name: HTTP only
-            install: nghttp2
+            macos-version-min: '10.9'
+          - name: '!ssl HTTP-only'
+            compiler: clang
             configure: |
               --enable-debug \
-              --enable-maintainer-mode \
-              --disable-alt-svc \
-              --disable-dict \
-              --disable-file \
-              --disable-ftp \
-              --disable-gopher \
-              --disable-imap \
-              --disable-ldap \
-              --disable-pop3 \
-              --disable-rtmp \
-              --disable-rtsp \
-              --disable-scp \
-              --disable-sftp \
-              --disable-shared \
-              --disable-smb \
-              --disable-smtp \
-              --disable-telnet \
-              --disable-tftp \
-              --disable-unix-sockets \
-              --without-brotli \
-              --without-gssapi \
-              --without-libidn2 \
-              --without-libpsl \
-              --without-librtmp \
-              --without-libssh2 \
-              --without-nghttp2 \
-              --without-ntlm-auth \
-              --without-ssl \
-              --without-zlib \
-              --without-zstd
-
-            macosx-version-min: 10.15
-          - name: SecureTransport http2
-            install: nghttp2
-            configure: --enable-debug --with-secure-transport --enable-websockets
-            macosx-version-min: 10.8
-          # fails now with linker error on missing symbols, macos no longer old enough?
-          # - name: gcc SecureTransport
-          #   configure: CC=gcc-12 --enable-debug --with-secure-transport --enable-websockets --without-libpsl
-          #   macosx-version-min: 10.8
-          - name: OpenSSL http2
-            install: nghttp2 openssl
-            configure: --enable-debug --with-openssl=$(brew --prefix)/opt/openssl --enable-websockets
-            macosx-version-min: 10.9
-          - name: LibreSSL http2
-            install: nghttp2 libressl
-            configure: --enable-debug --with-openssl=$(brew --prefix)/opt/libressl --enable-websockets
-            macosx-version-min: 10.9
-          - name: torture
-            install: nghttp2 openssl
-            configure: --enable-debug --disable-shared --disable-threaded-resolver --with-openssl=$(brew --prefix)/opt/openssl --enable-websockets
+              --disable-alt-svc --disable-dict --disable-file --disable-ftp --disable-gopher --disable-imap \
+              --disable-ldap --disable-pop3 --disable-rtmp --disable-rtsp --disable-scp --disable-sftp \
+              --disable-shared --disable-smb --disable-smtp --disable-telnet --disable-tftp --disable-unix-sockets \
+              --without-brotli --without-gssapi --without-libidn2 --without-libpsl --without-librtmp --without-libssh2 \
+              --without-nghttp2 --without-ntlm-auth --without-ssl --without-zlib --without-zstd
+
+            macos-version-min: '10.15'  # Catalina (2019)
+          - name: 'SecureTransport libssh2'
+            compiler: clang
+            configure: --enable-debug --with-secure-transport --enable-websockets --with-libssh2=$(brew --prefix libssh2)
+            macos-version-min: '10.8'
+          - name: 'SecureTransport libssh2 10.12'
+            compiler: clang
+            configure: --enable-debug --with-secure-transport --enable-websockets --with-libssh2=$(brew --prefix libssh2)
+            macos-version-min: '10.12'  # for monotonic timers
+            cflags: '-Wno-deprecated-declarations'
+          - name: 'SecureTransport libssh2'
+            compiler: gcc-12
+            configure: --enable-debug --with-secure-transport --enable-websockets --with-libssh2=$(brew --prefix libssh2)
+            macos-version-min: '10.8'
+          - name: 'LibreSSL'
+            compiler: clang
+            install: libressl
+            configure: --enable-debug --with-openssl=$(brew --prefix libressl) --enable-websockets
+            macos-version-min: '10.9'
+          - name: 'OpenSSL'
+            compiler: clang
+            configure: --enable-debug --with-openssl=$(brew --prefix openssl) --enable-websockets
+            macos-version-min: '10.9'
+          - name: 'OpenSSL torture !FTP'
+            compiler: clang
+            configure: --enable-debug --disable-shared --disable-threaded-resolver --with-openssl=$(brew --prefix openssl) --enable-websockets
             tflags: -n -t --shallow=25 !FTP
-            macosx-version-min: 10.9
-          - name: torture-ftp
-            install: nghttp2 openssl
-            configure: --enable-debug --disable-shared --disable-threaded-resolver --with-openssl=$(brew --prefix)/opt/openssl --enable-websockets
+            macos-version-min: '10.9'
+          - name: 'OpenSSL torture FTP'
+            compiler: clang
+            configure: --enable-debug --disable-shared --disable-threaded-resolver --with-openssl=$(brew --prefix openssl) --enable-websockets
             tflags: -n -t --shallow=20 FTP
-            macosx-version-min: 10.9
-          - name: macOS 10.15
-            install: nghttp2 libssh2 openssl
-            configure: --enable-debug --disable-ldap --with-openssl=$(brew --prefix)/opt/openssl --enable-websockets
-            macosx-version-min: 10.15
+            macos-version-min: '10.9'
+          - name: 'OpenSSL libssh2 !ldap 10.15'
+            compiler: clang
+            configure: --enable-debug --disable-ldap --with-openssl=$(brew --prefix openssl) --enable-websockets
+            macos-version-min: '10.15'
     steps:
-      - run: echo libtool autoconf automake pkg-config libpsl ${{ matrix.build.install }} | xargs -Ix -n1 echo brew '"x"' > /tmp/Brewfile
-        name: 'brew bundle'
+      - name: 'brew install'
+        # Run this command with retries because of spurious failures seen
+        # while running the tests, for example
+        # https://github.com/curl/curl/runs/4095721123?check_suite_focus=true
+        run: |
+          echo libtool autoconf automake pkg-config libpsl libssh2 nghttp2 openssl ${{ matrix.install }} | xargs -Ix -n1 echo brew '"x"' > /tmp/Brewfile
+          while [[ $? == 0 ]]; do for i in 1 2 3; do brew update && brew bundle install --no-lock --file /tmp/Brewfile && break 2 || { echo Error: wait to try again; sleep 10; } done; false Too many retries; done
 
-      # Run this command with retries because of spurious failures seen
-      # while running the tests, for example
-      # https://github.com/curl/curl/runs/4095721123?check_suite_focus=true
-      - run: "while [[ $? == 0 ]]; do for i in 1 2 3; do brew update && brew bundle install --no-lock --file /tmp/Brewfile && break 2 || { echo Error: wait to try again; sleep 10; } done; false Too many retries; done"
-        name: 'brew install'
-
-      - run: |
-          case "${{ matrix.build.install }}" in
+      - name: 'brew unlink openssl'
+        run: |
+          case "${{ matrix.install }}" in
             *openssl*)
               (
-                cd $(brew --prefix)/opt/openssl/lib/pkgconfig/
+                cd $(brew --prefix openssl)/lib/pkgconfig/
                 for i in libssl.pc libcrypto.pc; do
                   sudo cp $i $i.orig
                   sudo sed s,libdir=$(brew --prefix)'/Cellar/openssl@3/3.3.0$',libdir=$(brew --prefix)/Cellar/openssl@3/3.3.0/lib,g < $i.orig > /tmp/$i
@@ -170,75 +173,139 @@ jobs:
                 brew unlink openssl
               fi;;
           esac
-        name: 'brew unlink openssl'
 
-      - run: |
+      - name: 'pip3 install'
+        run: |
           python3 -m venv $HOME/venv
           source $HOME/venv/bin/activate
           python3 -m pip install impacket
-        name: 'pip3 install'
 
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
 
-      - run: rm -f $HOME/.curlrc
-        name: remove $HOME/.curlrc
+      - name: 'toolchain versions'
+        run: |
+          [[ '${{ matrix.compiler }}' = 'llvm'* ]] && CC="$(brew --prefix ${{ matrix.compiler }})/bin/clang"
+          [[ '${{ matrix.compiler }}' = 'gcc'* ]] && \
+            grep -h -r -E -o '.+[0-9.]+\.sdk/' "$(dirname "$("${CC}" -print-libgcc-file-name)")/include-fixed" | sed -E 's/^\t+//g' | tr -d '"' | sort -u || true
+          which "${CC}"; "${CC}" --version || true
+          xcodebuild -version || true
+          xcrun -sdk macosx --show-sdk-path 2>/dev/null || true
+          echo '::group::macros predefined'; "${CC}" -dM -E - < /dev/null | sort || true; echo '::endgroup::'
+          echo '::group::brew packages preinstalled'; ls -l "$(brew --prefix)/opt"; echo '::endgroup::'
 
-      - run: autoreconf -fi
-        name: 'autoreconf'
+      - name: 'autoreconf'
+        run: autoreconf -fi
 
-      - run: ./configure --enable-warnings --enable-werror ${{ matrix.build.configure }}
-        name: 'configure'
-        env:
-          CFLAGS: "-mmacosx-version-min=${{ matrix.build.macosx-version-min }}"
+      - name: 'configure'
+        run: |
+          [[ '${{ matrix.compiler }}' = 'llvm'* ]] && CC="$(brew --prefix ${{ matrix.compiler }})/bin/clang"
+          CFLAGS+=' ${{ matrix.cflags }}'
+          if [[ '${{ matrix.compiler }}' = 'gcc'* ]]; then
+            libgccdir="$(dirname "$("${CC}" -print-libgcc-file-name)")"
+            echo '::group::gcc include-fixed details'; find "${libgccdir}/include-fixed" | sort; echo '::endgroup::'
+            for f in dispatch os AvailabilityInternal.h stdio.h; do
+              if [ -r "${libgccdir}/include-fixed/${f}" ]; then
+                echo "Zap gcc hack: '${libgccdir}/include-fixed/${f}'"
+                mv "${libgccdir}/include-fixed/${f}" "${libgccdir}/include-fixed/${f}-BAK"
+              fi
+            done
+          fi
+          if [[ '${{ matrix.compiler }}' = 'llvm'* ]]; then
+            options+=" --target=$(uname -m)-apple-darwin"
+            CC+=" --target=$(uname -m)-apple-darwin"
+          fi
+          if [ '${{ matrix.compiler }}' != 'clang' ]; then
+            options+=" --with-sysroot=$(xcrun -sdk macosx --show-sdk-path 2>/dev/null)"
+            CFLAGS+=" --sysroot=$(xcrun -sdk macosx --show-sdk-path 2>/dev/null)"
+          fi
+          mkdir bld && cd bld && ../configure --enable-warnings --enable-werror \
+            --disable-dependency-tracking \
+            --with-libpsl=$(brew --prefix libpsl) \
+            ${{ matrix.configure }} ${options}
 
-      - run: make V=1
-        name: 'make'
+      - name: 'configure log'
+        if: ${{ !cancelled() }}
+        run: cat bld/config.log || true
 
-      - run: make V=1 examples
-        name: 'make examples'
+      - name: 'curl_config.h'
+        run: |
+          echo '::group::raw'; cat bld/lib/curl_config.h || true; echo '::endgroup::'
+          cat bld/lib/curl_config.h | grep -F '#define' | sort || true
 
-      - run: make V=1 -C tests
-        name: 'make tests'
+      - name: 'make'
+        run: make -C bld V=1
 
-      - run: make V=1 test-ci
-        name: 'run tests'
-        env:
-          TFLAGS: "${{ matrix.build.tflags }} ~1452"
+      - name: 'curl version'
+        run: bld/src/curl --disable --version
+
+      - name: 'make examples'
+        run: make -C bld V=1 examples
+
+      - name: 'make tests'
+        run: make -C bld V=1 -C tests
+
+      - name: 'run tests'
+        run: |
+          export TFLAGS='${{ matrix.tflags }} -j10'
+          if [[ '${{ matrix.compiler }}' = 'gcc'* ]]; then
+            TFLAGS+=' ~RTSP'  # 567 568 569 570 571 572 577 689 3100
+            TFLAGS+=' ~1156 ~1539'  # HTTP Content-Range, Content-Length
+            if [[ '${{ matrix.configure }}' = *'--with-secure-transport'* ]]; then
+              TFLAGS+=' ~2100'  # 2100:'HTTP GET using DoH' https://github.com/curl/curl/actions/runs/9942146678/job/27462937524#step:15:5059
+              TFLAGS+=' ~HTTP/2'  # 2400 2401 2402 2403 2404 2406, SecureTransport + nghttp2
+            else
+              TFLAGS+=' ~2402 ~2404'  # non-SecureTransport + nghttp2
+            fi
+          fi
+          rm -f $HOME/.curlrc
+          make -C bld V=1 test-ci
 
   cmake:
-    name: cmake ${{ matrix.compiler.CC }} ${{ matrix.build.name }}
+    name: 'CM ${{ matrix.compiler }} ${{ matrix.build.name }}'
     runs-on: 'macos-latest'
+    timeout-minutes: 10
     env:
-      CC: ${{ matrix.compiler.CC }}
-      # '-Wno-deprecated-declarations' required for LDAP and BUILD_EXAMPLES
-      CFLAGS: '-DCMAKE_C_FLAGS=-mmacosx-version-min=10.15 -Wno-deprecated-declarations'
+      DEVELOPER_DIR: "/Applications/Xcode${{ matrix.xcode && format('_{0}', matrix.xcode) || '' }}.app/Contents/Developer"
+      CC: ${{ matrix.compiler }}
     strategy:
       fail-fast: false
       matrix:
-        compiler:
-          - CC: clang
-          - CC: gcc-12
+        compiler: [clang, llvm@15, gcc-12]
         build:
-          - name: OpenSSL
-            install: nghttp2 openssl
-            generate: -DOPENSSL_ROOT_DIR=$(brew --prefix)/opt/openssl -DCMAKE_OSX_DEPLOYMENT_TARGET=10.9
-          - name: LibreSSL
-            install: nghttp2 libressl
-            generate: -DOPENSSL_ROOT_DIR=$(brew --prefix)/opt/libressl -DCURL_DISABLE_LDAP=ON -DCURL_DISABLE_LDAPS=ON -DBUILD_EXAMPLES=ON
-          - name: libssh2
-            install: nghttp2 openssl libssh2
-            generate: -DOPENSSL_ROOT_DIR=$(brew --prefix)/opt/openssl -DCURL_USE_LIBSSH2=ON -DBUILD_SHARED_LIBS=ON -DBUILD_STATIC_LIBS=ON
-          - name: GnuTLS
-            install: gnutls
-            generate: -DCURL_USE_GNUTLS=ON -DCURL_USE_OPENSSL=OFF -DCURL_DISABLE_LDAP=ON -DCURL_DISABLE_LDAPS=ON -DCMAKE_SHARED_LINKER_FLAGS=-L$(brew --prefix)/lib -DCMAKE_EXE_LINKER_FLAGS=-L$(brew --prefix)/lib
+          - name: 'OpenSSL ws gsasl AppleIDN'
+            install: gsasl
+            generate: -DOPENSSL_ROOT_DIR=$(brew --prefix openssl) -DCURL_USE_GSASL=ON -DUSE_APPLE_IDN=ON -DENABLE_WEBSOCKETS=ON
+            macos-version-min: '10.9'
+            tflags: '~1034 ~1035'  # AppleIDN issues: https://github.com/curl/curl/issues/14176
+          - name: 'OpenSSL +static'
+            generate: -DOPENSSL_ROOT_DIR=$(brew --prefix openssl) -DBUILD_STATIC_LIBS=ON
+            macos-version-min: '10.9'
+          - name: 'SecureTransport ws debug+'
+            generate: -DCURL_USE_SECTRANSP=ON -DENABLE_WEBSOCKETS=ON -DENABLE_DEBUG=ON -DENABLE_CURLDEBUG=ON
+            macos-version-min: '10.8'
+          - name: 'LibreSSL !ldap'
+            install: libressl
+            generate: -DOPENSSL_ROOT_DIR=$(brew --prefix libressl) -DCURL_DISABLE_LDAP=ON -DCURL_DISABLE_LDAPS=ON -DBUILD_EXAMPLES=ON
+            macos-version-min: '10.15'
+          - name: 'wolfSSL !ldap'
+            install: wolfssl
+            generate: -DCURL_USE_WOLFSSL=ON -DCURL_DISABLE_LDAP=ON -DCURL_DISABLE_LDAPS=ON
+            macos-version-min: '10.15'
+          - name: 'GnuTLS !ldap'
+            install: gnutls nettle
+            generate: -DCURL_USE_GNUTLS=ON -DCURL_USE_OPENSSL=OFF -DCURL_DISABLE_LDAP=ON -DCURL_DISABLE_LDAPS=ON
+            macos-version-min: '10.15'
+        exclude:
+          - { compiler: llvm@15, build: { macos-version-min: '10.15' } }
+          - { compiler: llvm@15, build: { macos-version-min: '10.9' } }
     steps:
-      - run: echo libtool autoconf automake pkg-config ${{ matrix.build.install }} | xargs -Ix -n1 echo brew '"x"' > /tmp/Brewfile
-        name: 'brew bundle'
+      - name: 'brew install'
+        run: |
+          echo libtool autoconf automake pkg-config libpsl libssh2 nghttp2 openssl ${{ matrix.build.install }} | xargs -Ix -n1 echo brew '"x"' > /tmp/Brewfile
+          while [[ $? == 0 ]]; do for i in 1 2 3; do brew update && brew bundle install --no-lock --file /tmp/Brewfile && break 2 || { echo Error: wait to try again; sleep 10; } done; false Too many retries; done
 
-      - run: "while [[ $? == 0 ]]; do for i in 1 2 3; do brew update && brew bundle install --no-lock --file /tmp/Brewfile && break 2 || { echo Error: wait to try again; sleep 10; } done; false Too many retries; done"
-        name: 'brew install'
-
-      - run: |
+      - name: 'brew unlink openssl'
+        run: |
           case "${{ matrix.build.install }}" in
             *openssl*)
               ;;
@@ -247,12 +314,304 @@ jobs:
                 brew unlink openssl
               fi;;
           esac
-        name: 'brew unlink openssl'
 
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
+
+      - name: 'toolchain versions'
+        run: |
+          [[ '${{ matrix.compiler }}' = 'llvm'* ]] && CC="$(brew --prefix ${{ matrix.compiler }})/bin/clang"
+          [[ '${{ matrix.compiler }}' = 'gcc'* ]] && \
+            grep -h -r -E -o '.+[0-9.]+\.sdk/' "$(dirname "$("${CC}" -print-libgcc-file-name)")/include-fixed" | sed -E 's/^\t+//g' | tr -d '"' | sort -u || true
+          which "${CC}"; "${CC}" --version || true
+          xcodebuild -version || true
+          xcrun -sdk macosx --show-sdk-path 2>/dev/null || true
+          echo '::group::macros predefined'; "${CC}" -dM -E - < /dev/null | sort || true; echo '::endgroup::'
+          echo '::group::brew packages preinstalled'; ls -l "$(brew --prefix)/opt"; echo '::endgroup::'
+
+      - name: 'cmake configure'
+        run: |
+          [[ '${{ matrix.compiler }}' = 'llvm'* ]] && CC="$(brew --prefix ${{ matrix.compiler }})/bin/clang"
+          if [[ '${{ matrix.compiler }}' = 'gcc'* ]]; then
+            libgccdir="$(dirname "$("${CC}" -print-libgcc-file-name)")"
+            echo '::group::gcc include-fixed details'; find "${libgccdir}/include-fixed" | sort; echo '::endgroup::'
+            for f in dispatch os AvailabilityInternal.h stdio.h; do
+              if [ -r "${libgccdir}/include-fixed/${f}" ]; then
+                echo "Zap gcc hack: '${libgccdir}/include-fixed/${f}'"
+                mv "${libgccdir}/include-fixed/${f}" "${libgccdir}/include-fixed/${f}-BAK"
+              fi
+            done
+          fi
+          cmake -B bld -DCMAKE_UNITY_BUILD=ON -DCURL_WERROR=ON \
+            -DCMAKE_OSX_DEPLOYMENT_TARGET=${{ matrix.build.macos-version-min }} \
+            "-DCMAKE_C_COMPILER_TARGET=$(uname -m | sed 's/arm64/aarch64/')-apple-darwin$(uname -r)" \
+            -DUSE_NGHTTP2=ON \
+            ${{ matrix.build.generate }}
+
+      - name: 'configure log'
+        if: ${{ !cancelled() }}
+        run: cat bld/CMakeFiles/CMakeConfigureLog.yaml 2>/dev/null || true
+
+      - name: 'curl_config.h'
+        run: |
+          echo '::group::raw'; cat bld/lib/curl_config.h || true; echo '::endgroup::'
+          cat bld/lib/curl_config.h | grep -F '#define' | sort || true
+
+      - name: 'cmake build'
+        run: make -C bld VERBOSE=1
+
+      - name: 'curl version'
+        run: bld/src/curl --disable --version
+
+      - name: 'cmake build tests'
+        run: make -C bld testdeps
+
+      - name: 'cmake run tests'
+        run: |
+          export TFLAGS='${{ matrix.build.tflags }} -j10'
+          if [[ '${{ matrix.compiler }}' = 'gcc'* ]]; then
+            TFLAGS+=' ~RTSP'  # 567 568 569 570 571 572 577 689 3100
+            TFLAGS+=' ~1156 ~1539'  # HTTP Content-Range, Content-Length
+            if [[ '${{ matrix.build.generate }}' = *'-DCURL_USE_SECTRANSP=ON'* ]]; then
+              TFLAGS+=' ~2100'  # 2100:'HTTP GET using DoH' https://github.com/curl/curl/actions/runs/9942146678/job/27462937524#step:15:5059
+              TFLAGS+=' ~HTTP/2'  # 2400 2401 2402 2403 2404 2406, SecureTransport + nghttp2
+            else
+              TFLAGS+=' ~2402 ~2404'  # non-SecureTransport + nghttp2
+            fi
+          fi
+          rm -f $HOME/.curlrc
+          make -C bld test-ci
+
+  combinations:  # Test buildability with host OS, Xcode / SDK, compiler, target-OS, SecureTransport/not, built tool, combinations
+    if: true  # Set to `true` to enable this test matrix. It runs quickly.
+    name: "${{ matrix.build == 'cmake' && 'CM' || 'AM' }} ${{ matrix.compiler }} ${{ matrix.image }} ${{ matrix.xcode }} ${{ matrix.config }}"
+    runs-on: ${{ matrix.image }}
+    timeout-minutes: 30
+    env:
+      DEVELOPER_DIR: "/Applications/Xcode${{ matrix.xcode && format('_{0}', matrix.xcode) || '' }}.app/Contents/Developer"
+      CC: ${{ matrix.compiler }}
+    strategy:
+      fail-fast: false
+      matrix:
+        config: [SecureTransport]  # also: OpenSSL
+        compiler: [gcc-11, gcc-12, gcc-13, gcc-14, llvm@15, clang]
+        # Xcode support matrix as of 2024-07, with default macOS SDK versions and OS names, years:
+        # * = default Xcode on the runner.
+        # macos-12: 13.1, 13.2.1, 13.3.1, 13.4.1, 14.0.1, 14.1,*14.2
+        # macos-13:                                       14.1, 14.2, 14.3.1,*15.0.1, 15.1, 15.2
+        # macos-14:                                                   14.3.1, 15.0.1, 15.1, 15.2, 15.3,*15.4, 16.0
+        # macOSSDK: 12.0, 12.1,   12.3,   12.3,   12.3,   13.0, 13.1, 13.3,   14.0,   14.2, 14.2, 14.4, 14.5, 15.0
+        #           Monterey (2021)                       Ventura (2022)      Sonoma (2023)                   Sequoia (2024)
+        # https://github.com/actions/runner-images/tree/main/images/macos
+        # https://en.wikipedia.org/wiki/MacOS_version_history
+        image: [macos-12, macos-13, macos-14]
+        # Can skip these to reduce jobs:
+        #   13.1, 13.2.1 are fairly old.
+        #   13.3.1, 14.0.1 have the same default macOS SDK as 13.4.1 and identical test results.
+        #   15.1 has the same default macOS SDK as 15.2 and identical test result.
+        #   14.1, 15.4 not revealing new fallouts.
+        #xcode: ['13.1', '13.2.1', '13.3.1', '13.4.1', '14.0.1', '14.1', '14.2', '14.3.1', '15.0.1', '15.1', '15.2', '15.3', '15.4', '16.0']  # all Xcode
+        #xcode: ['13.1', '13.2.1', '13.4.1', '14.1', '14.2', '14.3.1', '15.0.1', '15.2', '15.3', '15.4', '16.0']  # all SDK
+        #xcode: ['13.4.1', '14.2', '14.3.1', '15.0.1', '15.2', '15.3', '16.0']  # coverage
+        xcode: ['']  # default Xcodes
+        macos-version-min: ['10.8']
+        build: [autotools, cmake]
+        exclude:
+          # Combinations uncovered by runner images:
+          - { image: macos-12, xcode: '14.3.1' }
+          - { image: macos-12, xcode: '15.0.1' }
+          - { image: macos-12, xcode: '15.1'   }
+          - { image: macos-12, xcode: '15.2'   }
+          - { image: macos-12, xcode: '15.3'   }
+          - { image: macos-12, xcode: '15.4'   }
+          - { image: macos-12, xcode: '16.0'   }
+          - { image: macos-13, xcode: '13.1'   }
+          - { image: macos-13, xcode: '13.2.1' }
+          - { image: macos-13, xcode: '13.3.1' }
+          - { image: macos-13, xcode: '13.4.1' }
+          - { image: macos-13, xcode: '14.0.1' }
+          - { image: macos-13, xcode: '15.3'   }
+          - { image: macos-13, xcode: '15.4'   }
+          - { image: macos-13, xcode: '16.0'   }
+          - { image: macos-14, xcode: '13.1'   }
+          - { image: macos-14, xcode: '13.2.1' }
+          - { image: macos-14, xcode: '13.3.1' }
+          - { image: macos-14, xcode: '13.4.1' }
+          - { image: macos-14, xcode: '14.0.1' }
+          - { image: macos-14, xcode: '14.1'   }
+          - { image: macos-14, xcode: '14.2'   }
+          # Reduce build combinations, by dropping less interesting ones
+          - { compiler: gcc-11, build: autotools }
+          - { compiler: gcc-11, image: macos-14 }
+          - { compiler: gcc-12, config: SecureTransport }
+          - { compiler: gcc-13, build: cmake }
+          - { compiler: gcc-13, image: macos-13 }
+          - { compiler: gcc-14, config: SecureTransport }
+    steps:
+      - name: 'install autotools'
+        if: ${{ matrix.build == 'autotools' }}
+        run: |
+          echo autoconf automake libtool openssl | xargs -Ix -n1 echo brew '"x"' > /tmp/Brewfile
+          while [[ $? == 0 ]]; do for i in 1 2 3; do brew update && brew bundle install --no-lock --file /tmp/Brewfile && break 2 || { echo Error: wait to try again; sleep 10; } done; false Too many retries; done
+
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
+
+      - name: 'toolchain versions'
+        run: |
+          [[ '${{ matrix.compiler }}' = 'llvm'* ]] && CC="$(brew --prefix ${{ matrix.compiler }})/bin/clang"
+          [[ '${{ matrix.compiler }}' = 'gcc'* ]] && \
+            grep -h -r -E -o '.+[0-9.]+\.sdk/' "$(dirname "$("${CC}" -print-libgcc-file-name)")/include-fixed" | sed -E 's/^\t+//g' | tr -d '"' | sort -u || true
+          which "${CC}"; "${CC}" --version || true
+          xcodebuild -version || true
+          xcrun -sdk macosx --show-sdk-path 2>/dev/null || true
+          echo '::group::macros predefined'; "${CC}" -dM -E - < /dev/null | sort || true; echo '::endgroup::'
+          echo '::group::brew packages preinstalled'; ls -l "$(brew --prefix)/opt"; echo '::endgroup::'
+
+      - name: 'autoreconf'
+        if: ${{ matrix.build == 'autotools' }}
+        run: autoreconf -fi
+
+      - name: 'configure / ${{ matrix.build }}'
+        run: |
+          [[ '${{ matrix.compiler }}' = 'llvm'* ]] && CC="$(brew --prefix ${{ matrix.compiler }})/bin/clang"
+
+          # gcc ships with an `include-fixed` header set, which overrides SDK
+          # headers with the intent of making them compatible with gcc. The
+          # source for these headers is:
+          #   https://github.com/gcc-mirror/gcc/tree/master/fixincludes
+          # with extra Apple-specific patches applied from here for Homebrew:
+          #   https://github.com/iains/gcc-12-branch
+          #
+          # They pass through a generator phase at build-time which seems to
+          # pick the SDK installed on the build machine (maintained by the
+          # Homebrew project in our case) and patches it according to a set
+          # of rules in `inclhack.def`.
+          #
+          # Homebrew builds and ships different binaries for different macOS
+          # versions and CPUs, built on machines using the same OS version as
+          # the target one. Each of these machines have a particular version
+          # of Apple CommandLineTools with a default SDK version installed with
+          # them.
+          #
+          # Then this binary gets installed onto the end-user machine,
+          # matching the OS version at the time of installation.
+          #
+          # The problem with this approach is that the SDK version picked up
+          # at gcc build-time has a high chance of being or becoming out of
+          # sync with actual SDK installed on the end-user machine. This
+          # can happen after upgrading the OS, Xcode, selecting an SDK version
+          # manually, or other reasons.
+          #
+          # When the SDK versions do not match, the gcc hacks, instead of
+          # improving compatibility the SDK, are actively _breaking_
+          # compatibility, in an unexpected, hard to diagnose way.
+          #
+          # The SDK version used for gcc-hacks is not advertised. We can
+          # extract the major SDK version from the generated gcc-hack header
+          # files, assuming someone knows what to look for and where.
+          #
+          # Basically it also means that the same `gcc-N` Homebrew package
+          # behaves differently depending on the OS it was built on. Causing
+          # an explosion of build combination. It may also mean that a minor
+          # gcc version bump is built against a different SDK version, and due
+          # to the extra patch for the hack applied by Homebrew, there may
+          # be extra changes as well.
+          #
+          # For GHA runners, it means that the default Xcode + OS combo is
+          # broken in 8 out of 12 combinations (66%) have an SDK mismatch,
+          # and 9 fail to build (75%). These are the 3 lucky default
+          # combinations that worked to build curl:
+          #   macos-14 + Xcode 15.0.1 + gcc-11, gcc-12, gcc-14
+          #
+          # Of all possible valid GHA runner, gcc, manually selected Xcode
+          # combinations, 40% are broken.
+          #
+          # Compared to mainline llvm: llvm ships the same binaries regardless
+          # of build-OS or environent, it contains no SDK-version-specific
+          # hacks, and has no 3rd party patches. This still leaves some
+          # occasional issues, but works much closer to expectations.
+          #
+          # Some of these hacks are helpful, in particular for fixing this
+          # issue via math.h:
+          #   /Applications/Xcode_14.3.1.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/math.h:53:5: error: #error "Unsupported value of
+          #      53 | #   error "Unsupported value of __FLT_EVAL_METHOD__."
+          #
+          # Errors seen in available CI combinations:
+          #   error: two or more data types in declaration specifiers # fatal error: AvailabilityInternalLegacy.h: No such file or directory
+          #     gcc-11, gcc-13 + macos-14 + Xcode 14.3.1
+          #   error: two or more data types in declaration specifiers
+          #     gcc-13 + macos-12 + Xcode 14.1, 14.2
+          #     gcc-13 + Xcode 15.0.1, 15.1, 5.2
+          #   error: expected ';' before 'extern'
+          #     gcc-11, gcc-12, gcc-14 + macos-12 + Xcode 14.1, 14.2
+          #   error: unknown type name 'dispatch_queue_t'
+          #     gcc-11, gcc-12 + macos-13 + Xcode 15.0.1, 15.1, 15.2
+          #   error: type defaults to 'int' in declaration of 'DISPATCH_DECL_FACTORY_CLASS_SWIFT' [-Wimplicit-int]
+          #     gcc-14 macos-13 Xcode 15.0.1, 15.1, 15.2
+          #   error: unknown type name 'FILE'
+          #     Xcode 16.0
+          #
+          # Unbreak Homebrew gcc builds by moving problematic SDK header overlay
+          # directories/files out of the way:
+          if [[ '${{ matrix.compiler }}' = 'gcc'* ]]; then
+            # E.g.:
+            #   $(brew --prefix)/Cellar/gcc@11/11.4.0/lib/gcc/11/gcc/aarch64-apple-darwin23/11/include-fixed
+            #   $(brew --prefix)/Cellar/gcc@11/11.4.0/lib/gcc/11/gcc/x86_64-apple-darwin21/11/include-fixed
+            #   $(brew --prefix)/Cellar/gcc/14.1.0_1/lib/gcc/14/gcc/x86_64-apple-darwin21/14/include-fixed
+            libgccdir="$(dirname "$("${CC}" -print-libgcc-file-name)")"
+            echo '::group::gcc include-fixed details'; find "${libgccdir}/include-fixed" | sort; echo '::endgroup::'
+            patch_out='dispatch os AvailabilityInternal.h'
+            patch_out+=' stdio.h'  # for Xcode 16 error: unknown type name 'FILE'
+            for f in ${patch_out}; do
+              if [ -r "${libgccdir}/include-fixed/${f}" ]; then
+                echo "Zap gcc hack: '${libgccdir}/include-fixed/${f}'"
+                mv "${libgccdir}/include-fixed/${f}" "${libgccdir}/include-fixed/${f}-BAK"
+              fi
+            done
+          fi
+
+          if [ '${{ matrix.build }}' = 'autotools' ]; then
+            export CFLAGS
+            if [[ '${{ matrix.compiler }}' = 'llvm'* ]]; then
+              options+=" --target=$(uname -m)-apple-darwin"
+              CC+=" --target=$(uname -m)-apple-darwin"
+            fi
+            if [ '${{ matrix.compiler }}' != 'clang' ]; then
+              options+=" --with-sysroot=$(xcrun -sdk macosx --show-sdk-path 2>/dev/null)"
+              CFLAGS+=" --sysroot=$(xcrun -sdk macosx --show-sdk-path 2>/dev/null)"
+            fi
+            [ '${{ matrix.config }}' = 'OpenSSL' ]         && options+=" --with-openssl=$(brew --prefix openssl)"
+            [ '${{ matrix.config }}' = 'SecureTransport' ] && options+=' --with-secure-transport'
+            CFLAGS+=' -mmacosx-version-min=${{ matrix.macos-version-min }}'
+            # would pick up nghttp2, libidn2, but libssh2 is disabled by default
+            mkdir bld && cd bld && ../configure --enable-warnings --enable-werror \
+              --disable-dependency-tracking \
+              --disable-docs --disable-manual \
+              --without-nghttp2 --without-libidn2 \
+              ${options}
+          else
+            [ '${{ matrix.config }}' = 'OpenSSL' ]         && options+=' -DCURL_USE_OPENSSL=ON'
+            [ '${{ matrix.config }}' = 'SecureTransport' ] && options+=' -DCURL_USE_SECTRANSP=ON'
+            # would pick up nghttp2, libidn2, and libssh2
+            cmake -B bld -DCMAKE_UNITY_BUILD=ON -DCURL_WERROR=ON \
+              -DCMAKE_OSX_DEPLOYMENT_TARGET=${{ matrix.macos-version-min }} \
+              "-DCMAKE_IGNORE_PREFIX_PATH=$(brew --prefix)" \
+              "-DCMAKE_C_COMPILER_TARGET=$(uname -m | sed 's/arm64/aarch64/')-apple-darwin$(uname -r)" \
+              -DBUILD_LIBCURL_DOCS=OFF -DBUILD_MISC_DOCS=OFF -DENABLE_CURL_MANUAL=OFF \
+              -DUSE_APPLE_IDN=OFF \
+              ${options}
+          fi
+
+      - name: 'configure log'
+        if: ${{ !cancelled() }}
+        run: cat bld/config.log bld/CMakeFiles/CMakeConfigureLog.yaml 2>/dev/null || true
+
+      - name: 'curl_config.h'
+        run: |
+          echo '::group::raw'; cat bld/lib/curl_config.h || true; echo '::endgroup::'
+          cat bld/lib/curl_config.h | grep -F '#define' | sort || true
 
-      - run: cmake -B build -DCMAKE_UNITY_BUILD=ON -DCURL_WERROR=ON -DUSE_APPLE_IDN=ON ${{ matrix.build.generate }}
-        name: 'cmake generate'
+      - name: 'build / ${{ matrix.build }}'
+        run: make -C bld V=1 VERBOSE=1
 
-      - run: cmake --build build --parallel 3
-        name: 'cmake build'
+      - name: 'curl version'
+        run: bld/src/curl --disable --version
diff --git a/.github/workflows/man-examples.yml b/.github/workflows/man-examples.yml
index b0e7902f4..502d590bc 100644
--- a/.github/workflows/man-examples.yml
+++ b/.github/workflows/man-examples.yml
@@ -28,7 +28,7 @@ jobs:
     runs-on: ubuntu-latest
     steps:
       - name: Checkout
-        uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
 
       - name: render nroff versions
         run: autoreconf -fi && ./configure --without-ssl --without-libpsl && make -C docs
diff --git a/.github/workflows/ngtcp2-linux.yml b/.github/workflows/ngtcp2-linux.yml
deleted file mode 100644
index b061a78c9..000000000
--- a/.github/workflows/ngtcp2-linux.yml
+++ /dev/null
@@ -1,279 +0,0 @@
-# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
-#
-# SPDX-License-Identifier: curl
-
-name: ngtcp2-linux
-
-on:
-  push:
-    branches:
-      - master
-      - '*/ci'
-    paths-ignore:
-      - '**/*.md'
-      - '**/CMakeLists.txt'
-      - '.azure-pipelines.yml'
-      - '.circleci/**'
-      - '.cirrus.yml'
-      - 'appveyor.*'
-      - 'CMake/**'
-      - 'packages/**'
-      - 'plan9/**'
-      - 'projects/**'
-      - 'winbuild/**'
-  pull_request:
-    branches:
-      - master
-    paths-ignore:
-      - '**/*.md'
-      - '**/CMakeLists.txt'
-      - '.azure-pipelines.yml'
-      - '.circleci/**'
-      - '.cirrus.yml'
-      - 'appveyor.*'
-      - 'CMake/**'
-      - 'packages/**'
-      - 'plan9/**'
-      - 'projects/**'
-      - 'winbuild/**'
-
-concurrency:
-  # Hardcoded workflow filename as workflow name above is just Linux again
-  group: ngtcp2-${{ github.event.pull_request.number || github.sha }}
-  cancel-in-progress: true
-
-permissions: {}
-
-env:
-  MAKEFLAGS: -j 3
-  # unhandled
-  quictls-version: 3.1.4+quic
-  # renovate: datasource=github-tags depName=gnutls/gnutls versioning=semver registryUrl=https://github.com
-  gnutls-version: 3.8.5
-  wolfssl-version: master
-  # renovate: datasource=github-tags depName=ngtcp2/nghttp3 versioning=semver registryUrl=https://github.com
-  nghttp3-version: 1.3.0
-  # renovate: datasource=github-tags depName=ngtcp2/ngtcp2 versioning=semver registryUrl=https://github.com
-  ngtcp2-version: 1.5.0
-  # renovate: datasource=github-tags depName=nghttp2/nghttp2 versioning=semver registryUrl=https://github.com
-  nghttp2-version: 1.62.1
-  # renovate: datasource=github-tags depName=icing/mod_h2 versioning=semver registryUrl=https://github.com
-  mod_h2-version: 2.0.27
-
-jobs:
-  autotools:
-    name: ${{ matrix.build.name }}
-    runs-on: 'ubuntu-latest'
-    timeout-minutes: 60
-    strategy:
-      fail-fast: false
-      matrix:
-        build:
-          - name: quictls
-            configure: >-
-              PKG_CONFIG_PATH="$HOME/nghttpx/lib/pkgconfig" LDFLAGS="-Wl,-rpath,$HOME/nghttpx/lib"
-              --with-ngtcp2=$HOME/nghttpx --enable-warnings --enable-werror --enable-debug --disable-ntlm
-              --with-test-nghttpx="$HOME/nghttpx/bin/nghttpx"
-              --with-openssl=$HOME/nghttpx
-          - name: gnutls
-            configure: >-
-              PKG_CONFIG_PATH="$HOME/nghttpx/lib/pkgconfig" LDFLAGS="-Wl,-rpath,$HOME/nghttpx/lib"
-              --with-ngtcp2=$HOME/nghttpx --enable-warnings --enable-werror --enable-debug
-              --with-test-nghttpx="$HOME/nghttpx/bin/nghttpx"
-              --with-gnutls=$HOME/nghttpx
-          - name: wolfssl
-            configure: >-
-              PKG_CONFIG_PATH="$HOME/nghttpx/lib/pkgconfig" LDFLAGS="-Wl,-rpath,$HOME/nghttpx/lib"
-              --with-ngtcp2=$HOME/nghttpx --enable-warnings --enable-werror --enable-debug
-              --with-test-nghttpx="$HOME/nghttpx/bin/nghttpx"
-              --with-wolfssl=$HOME/nghttpx
-
-    steps:
-      - run: |
-          sudo rm -f /etc/apt/sources.list.d/microsoft-prod.list
-          sudo apt-get update
-          sudo apt-get install libtool autoconf automake pkg-config stunnel4 \
-            libpsl-dev libbrotli-dev libzstd-dev zlib1g-dev libev-dev libc-ares-dev \
-            nettle-dev libp11-kit-dev libtspi-dev libunistring-dev guile-2.2-dev libtasn1-bin \
-            libtasn1-6-dev libidn2-0-dev gawk gperf libtss2-dev dns-root-data bison gtk-doc-tools \
-            texinfo texlive texlive-extra-utils autopoint libev-dev \
-            apache2 apache2-dev libnghttp2-dev
-          echo 'CC=gcc-12' >> $GITHUB_ENV
-          echo 'CXX=g++-12' >> $GITHUB_ENV
-        name: 'install prereqs and impacket, pytest, crypto, apache2'
-
-      - name: cache quictls
-        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
-        id: cache-quictls-no-deprecated
-        env:
-          cache-name: cache-quictls-no-deprecated
-        with:
-          path: /home/runner/quictls
-          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ env.quictls-version }}
-
-      - if: steps.cache-quictls-no-deprecated.outputs.cache-hit != 'true'
-        run: |
-          cd $HOME
-          git clone --quiet --depth=1 -b openssl-${{ env.quictls-version }} https://github.com/quictls/openssl quictls
-          cd quictls
-          ./config no-deprecated --prefix=$HOME/nghttpx --libdir=$HOME/nghttpx/lib
-          make
-        name: 'build quictls'
-
-      - run: |
-          cd $HOME/quictls
-          make -j1 install_sw
-        name: 'install quictls'
-
-
-      - name: cache gnutls
-        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
-        id: cache-gnutls
-        env:
-          cache-name: cache-gnutls
-        with:
-          path: /home/runner/gnutls
-          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ env.gnutls-version }}
-
-      - if: steps.cache-gnutls.outputs.cache-hit != 'true'
-        run: |
-          cd $HOME
-          git clone --quiet --depth=1 -b ${{ env.gnutls-version }} https://github.com/gnutls/gnutls.git
-          cd gnutls
-          ./bootstrap
-          ./configure  --prefix=$HOME/nghttpx \
-            PKG_CONFIG_PATH="$HOME/nghttpx/lib/pkgconfig" LDFLAGS="-Wl,-rpath,$HOME/nghttpx/lib -L$HOME/nghttpx/lib" \
-            --with-included-libtasn1 --with-included-unistring \
-            --disable-guile --disable-doc --disable-tests --disable-tools
-          make
-        name: 'build gnutls'
-
-      - run: |
-          cd $HOME/gnutls
-          make install
-        name: 'install gnutls'
-
-      - name: cache wolfssl
-        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
-        id: cache-wolfssl
-        env:
-          cache-name: cache-wolfssl
-        with:
-          path: /home/runner/wolfssl
-          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ env.wolfssl-version }}
-
-      - if: steps.cache-wolfssl.outputs.cache-hit != 'true' || ${{ env.wolfssl-version }} == 'master'
-        run: |
-          cd $HOME
-          rm -rf wolfssl
-          git clone --quiet --depth=1 -b ${{ env.wolfssl-version }} https://github.com/wolfSSL/wolfssl.git
-          cd wolfssl
-          ./autogen.sh
-          ./configure --enable-all --enable-quic --prefix=$HOME/nghttpx
-          make
-        name: 'build wolfssl'
-
-      - run: |
-          cd $HOME/wolfssl
-          make install
-        name: 'install wolfssl'
-
-
-      - name: cache nghttp3
-        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
-        id: cache-nghttp3
-        env:
-          cache-name: cache-nghttp3
-        with:
-          path: /home/runner/nghttp3
-          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ env.nghttp3-version }}
-
-      - if: steps.cache-nghttp3.outputs.cache-hit != 'true'
-        run: |
-          cd $HOME
-          git clone --quiet --depth=1 -b v${{ env.nghttp3-version }} https://github.com/ngtcp2/nghttp3
-          cd nghttp3
-          git submodule update --init
-          autoreconf -fi
-          ./configure --prefix=$HOME/nghttpx PKG_CONFIG_PATH="$HOME/nghttpx/lib/pkgconfig" --enable-lib-only
-          make
-        name: 'build nghttp3'
-
-      - run: |
-          cd $HOME/nghttp3
-          make install
-        name: 'install nghttp3'
-
-      # depends on all other cached libs built so far
-      - run: |
-          git clone --quiet --depth=1 -b v${{ env.ngtcp2-version }} https://github.com/ngtcp2/ngtcp2
-          cd ngtcp2
-          autoreconf -fi
-          ./configure --prefix=$HOME/nghttpx PKG_CONFIG_PATH="$HOME/nghttpx/lib/pkgconfig" --enable-lib-only --with-openssl --with-gnutls --with-wolfssl
-          make install
-        name: 'install ngtcp2'
-
-      # depends on all other cached libs built so far
-      - run: |
-          git clone --quiet --depth=1 -b v${{ env.nghttp2-version }} https://github.com/nghttp2/nghttp2
-          cd nghttp2
-          autoreconf -fi
-          ./configure --prefix=$HOME/nghttpx PKG_CONFIG_PATH="$HOME/nghttpx/lib/pkgconfig" --enable-http3
-          make install
-        name: 'install nghttp2'
-
-      - name: cache mod_h2
-        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
-        id: cache-mod_h2
-        env:
-          cache-name: cache-mod_h2
-        with:
-          path: /home/runner/mod_h2
-          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ env.mod_h2-version }}
-
-      - if: steps.cache-mod_h2.outputs.cache-hit != 'true'
-        run: |
-          cd $HOME
-          git clone --quiet --depth=1 -b v${{ env.mod_h2-version }} https://github.com/icing/mod_h2
-          cd mod_h2
-          autoreconf -fi
-          ./configure
-          make
-        name: 'build mod_h2'
-
-      - run: |
-          cd $HOME/mod_h2
-          sudo make install
-        name: 'install mod_h2'
-
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
-
-      - run: |
-          sudo python3 -m pip install -r tests/requirements.txt -r tests/http/requirements.txt
-        name: 'install python test prereqs'
-
-      - run: autoreconf -fi
-        name: 'autoreconf'
-
-      - run: ./configure ${{ matrix.build.configure }}
-        name: 'configure'
-
-      - run: make V=1
-        name: 'make'
-
-      - run: make V=1 examples
-        name: 'make examples'
-
-      - run: make V=1 -C tests
-        name: 'make tests'
-
-      - run: make V=1 test-ci
-        name: 'run tests'
-        env:
-          TFLAGS: "${{ matrix.build.tflags }}"
-
-      - run: pytest -v tests
-        name: 'run pytest'
-        env:
-          TFLAGS: "${{ matrix.build.tflags }}"
-          CURL_CI: github
diff --git a/.github/workflows/non-native.yml b/.github/workflows/non-native.yml
index eb019a5d5..e7a158cf7 100644
--- a/.github/workflows/non-native.yml
+++ b/.github/workflows/non-native.yml
@@ -13,7 +13,6 @@ on:
       - '**/*.md'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'packages/**'
       - 'plan9/**'
@@ -26,7 +25,6 @@ on:
       - '**/*.md'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'packages/**'
       - 'plan9/**'
@@ -48,16 +46,16 @@ jobs:
       matrix:
         arch: ['x86_64']
     steps:
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
       - name: 'cmake'
-        uses: cross-platform-actions/action@b2e15da1e667187766fff4945d20b98ac7055576 # v0.24.0
+        uses: cross-platform-actions/action@cdc9ee69ef84a5f2e59c9058335d9c57bcb4ac86 # v0.25.0
         with:
           operating_system: 'netbsd'
           version: '10.0'
           architecture: ${{ matrix.arch }}
           run: |
             # https://pkgsrc.se/
-            sudo pkgin -y install cmake perl brotli heimdal openldap-client libssh2 libidn2 libpsl nghttp2  # python311 py311-impacket
+            sudo pkgin -y install cmake pkg-config perl brotli heimdal openldap-client libssh2 libidn2 libpsl nghttp2  # python311 py311-impacket
             cmake -B bld \
               -DCMAKE_UNITY_BUILD=ON \
               -DCURL_WERROR=ON \
@@ -65,12 +63,13 @@ jobs:
               -DBUILD_EXAMPLES=ON \
               -DENABLE_WEBSOCKETS=ON \
               -DCURL_USE_OPENSSL=ON \
-              -DCURL_BROTLI=ON -DUSE_NGHTTP2=ON -DCURL_USE_GSSAPI=ON
+              -DCURL_BROTLI=ON -DUSE_NGHTTP2=ON -DCURL_USE_GSSAPI=ON \
+              || { cat bld/CMakeFiles/CMake*.yaml; false; }
             cmake --build bld --config Debug --parallel 3
-            export CURL=$(pwd)/bld/src/curl
-            "${CURL}" --disable --version
+            bld/src/curl --disable --version
             if [ '${{ matrix.arch }}' = 'x86_64' ]; then  # Slow on emulated CPU
               cmake --build bld --config Debug --parallel 3 --target testdeps
+              export TFLAGS='-j0'  # flakies: ~389 ~392 ~TFTP and more
               cmake --build bld --config Debug --target test-ci
             fi
 
@@ -82,9 +81,9 @@ jobs:
       matrix:
         arch: ['x86_64']
     steps:
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
       - name: 'cmake'
-        uses: cross-platform-actions/action@b2e15da1e667187766fff4945d20b98ac7055576 # v0.24.0
+        uses: cross-platform-actions/action@cdc9ee69ef84a5f2e59c9058335d9c57bcb4ac86 # v0.25.0
         with:
           operating_system: 'openbsd'
           version: '7.5'
@@ -99,13 +98,13 @@ jobs:
               -DBUILD_EXAMPLES=ON \
               -DENABLE_WEBSOCKETS=ON \
               -DCURL_USE_OPENSSL=ON \
-              -DCURL_BROTLI=ON -DUSE_NGHTTP2=ON
+              -DCURL_BROTLI=ON -DUSE_NGHTTP2=ON \
+              || { cat bld/CMakeFiles/CMake*.yaml; false; }
             cmake --build bld --config Debug --parallel 3
-            export CURL=$(pwd)/bld/src/curl
-            "${CURL}" --disable --version
+            bld/src/curl --disable --version
             if [ '${{ matrix.arch }}' = 'x86_64' ]; then  # Slow on emulated CPU
               cmake --build bld --config Debug --parallel 3 --target testdeps
-              export TFLAGS='-j8 ~TFTP'  # FIXME: TFTP requests executed twice? Related: `curl: (69) TFTP: Access Violation`?
+              export TFLAGS='-j8 ~3017 ~TFTP'  # FIXME: TFTP requests executed twice? Related: `curl: (69) TFTP: Access Violation`?
               cmake --build bld --config Debug --target test-ci
             fi
 
@@ -116,22 +115,22 @@ jobs:
     strategy:
       matrix:
         include:
+          - { build: 'autotools', arch: 'x86_64', compiler: 'clang' }
           - { build: 'autotools', arch: 'arm64', compiler: 'clang' }
           - { build: 'cmake'    , arch: 'arm64', compiler: 'clang' }
       fail-fast: false
     steps:
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
       - name: 'autotools'
         if: ${{ matrix.build == 'autotools' }}
-        uses: cross-platform-actions/action@b2e15da1e667187766fff4945d20b98ac7055576 # v0.24.0
+        uses: cross-platform-actions/action@cdc9ee69ef84a5f2e59c9058335d9c57bcb4ac86 # v0.25.0
         with:
           operating_system: 'freebsd'
-          version: '14.0'
+          version: '14.1'
           architecture: ${{ matrix.arch }}
           run: |
             # https://ports.freebsd.org/
-            sudo pkg install -y autoconf automake libtool pkgconf brotli openldap26-client libidn2 libnghttp2 nghttp2 stunnel py39-openssl py39-impacket py39-cryptography
-            sudo pkg delete -y curl
+            sudo pkg install -y autoconf automake libtool pkgconf brotli openldap26-client libidn2 libnghttp2 nghttp2 stunnel py311-openssl py311-impacket py311-cryptography
             autoreconf -fi
             export CC='${{ matrix.compiler }}'
             mkdir bld && cd bld && ../configure --enable-debug --enable-warnings --enable-werror \
@@ -144,52 +143,54 @@ jobs:
             src/curl --disable --version
             make -j3 examples
             if [ '${{ matrix.arch }}' = 'x86_64' ]; then  # Slow on emulated CPU
-              export TFLAGS='-j12'
-              make check V=1
+              make -j3 -C tests
+              # The OpenSSH server instance for the testsuite cannot be started on FreeBSD,
+              # therefore the SFTP and SCP tests are disabled right away from the beginning.
+              make test-ci V=1 TFLAGS='-j12 !SFTP !SCP'
             fi
 
       - name: 'cmake'
         if: ${{ matrix.build == 'cmake' }}
-        uses: cross-platform-actions/action@b2e15da1e667187766fff4945d20b98ac7055576 # v0.24.0
+        uses: cross-platform-actions/action@cdc9ee69ef84a5f2e59c9058335d9c57bcb4ac86 # v0.25.0
         with:
           operating_system: 'freebsd'
-          version: '14.0'
+          version: '14.1'
           architecture: ${{ matrix.arch }}
           run: |
             # https://ports.freebsd.org/
-            sudo pkg install -y cmake brotli openldap26-client libidn2 libnghttp2 nghttp2 stunnel py39-openssl py39-impacket py39-cryptography
-            sudo pkg delete -y curl
+            sudo pkg install -y cmake pkgconf brotli openldap26-client libidn2 libnghttp2 nghttp2 stunnel py311-openssl py311-impacket py311-cryptography
             cmake -B bld \
-              -DCMAKE_C_COMPILER=${{ matrix.compiler }} \
+              '-DCMAKE_C_COMPILER=${{ matrix.compiler }}' \
               -DCMAKE_UNITY_BUILD=ON \
               -DCURL_WERROR=ON \
               -DENABLE_DEBUG=ON -DCMAKE_BUILD_TYPE=Debug -DCMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG= \
               -DBUILD_EXAMPLES=ON \
               -DENABLE_WEBSOCKETS=ON \
               -DCURL_USE_OPENSSL=ON \
-              -DCURL_BROTLI=ON -DUSE_NGHTTP2=ON -DCURL_USE_GSSAPI=ON
+              -DCURL_BROTLI=ON -DUSE_NGHTTP2=ON -DCURL_USE_GSSAPI=ON \
+              || { cat bld/CMakeFiles/CMake*.yaml; false; }
             cmake --build bld --config Debug --parallel 3
             bld/src/curl --disable --version
             if [ '${{ matrix.arch }}' = 'x86_64' ]; then  # Slow on emulated CPU
               cmake --build bld --config Debug --parallel 3 --target testdeps
-              export TFLAGS='-j12'
-              cmake --build bld --config Debug --target test-ci
+              # The OpenSSH server instance for the testsuite cannot be started on FreeBSD,
+              # therefore the SFTP and SCP tests are disabled right away from the beginning.
+              make test-ci V=1 TFLAGS='-j12 !SFTP !SCP'
             fi
 
   omnios:
     name: 'OmniOS (autotools, openssl, gcc, amd64)'
-    runs-on: ubuntu-22.04
+    runs-on: ubuntu-latest
     timeout-minutes: 30
     steps:
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
       - name: 'autotools'
-        uses: vmactions/omnios-vm@7c0ff6e623ee96d9fd7c4dc4cfc92bebd3c4f64a # v1
+        uses: vmactions/omnios-vm@a61ca1ebafdcb14a9d986928d070c9834ee66fd3 # v1
         with:
           usesh: true
-          # https://pkg.omnios.org/r151048/core/en/index.shtml
+          # https://pkg.omnios.org/r151050/core/en/index.shtml
           prepare: pkg install build-essential libtool
           run: |
-            pkg uninstall curl
             ln -s /usr/bin/gcpp /usr/bin/cpp  # Some tests expect `cpp`, which is named `gcpp` in this env.
             autoreconf -fi
             mkdir bld && cd bld && ../configure --enable-debug --enable-warnings --enable-werror \
@@ -200,5 +201,5 @@ jobs:
             gmake -j3 install
             src/curl --disable --version
             gmake -j3 examples
-            export TFLAGS='-j12'
-            gmake check V=1
+            gmake -j3 -C tests
+            gmake test-ci V=1 TFLAGS='-j12 ~MQTT ~FTP'
diff --git a/.github/workflows/osslq-linux.yml b/.github/workflows/osslq-linux.yml
deleted file mode 100644
index 07e7e8e60..000000000
--- a/.github/workflows/osslq-linux.yml
+++ /dev/null
@@ -1,241 +0,0 @@
-# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
-#
-# SPDX-License-Identifier: curl
-
-name: osslq-linux
-
-on:
-  push:
-    branches:
-      - master
-      - '*/ci'
-    paths-ignore:
-      - '**/*.md'
-      - '**/CMakeLists.txt'
-      - '.azure-pipelines.yml'
-      - '.circleci/**'
-      - '.cirrus.yml'
-      - 'appveyor.*'
-      - 'CMake/**'
-      - 'packages/**'
-      - 'plan9/**'
-      - 'projects/**'
-      - 'winbuild/**'
-  pull_request:
-    branches:
-      - master
-    paths-ignore:
-      - '**/*.md'
-      - '**/CMakeLists.txt'
-      - '.azure-pipelines.yml'
-      - '.circleci/**'
-      - '.cirrus.yml'
-      - 'appveyor.*'
-      - 'CMake/**'
-      - 'packages/**'
-      - 'plan9/**'
-      - 'projects/**'
-      - 'winbuild/**'
-
-concurrency:
-  # Hardcoded workflow filename as workflow name above is just Linux again
-  group: osslq-${{ github.event.pull_request.number || github.sha }}
-  cancel-in-progress: true
-
-permissions: {}
-
-env:
-  MAKEFLAGS: -j 3
-  # handled in renovate.json
-  openssl3-version: openssl-3.3.0
-  # unhandled
-  quictls-version: 3.1.4+quic
-  # renovate: datasource=github-tags depName=ngtcp2/nghttp3 versioning=semver registryUrl=https://github.com
-  nghttp3-version: 1.3.0
-  # renovate: datasource=github-tags depName=ngtcp2/ngtcp2 versioning=semver registryUrl=https://github.com
-  ngtcp2-version: 1.5.0
-  # renovate: datasource=github-tags depName=nghttp2/nghttp2 versioning=semver registryUrl=https://github.com
-  nghttp2-version: 1.62.1
-  # renovate: datasource=github-tags depName=icing/mod_h2 versioning=semver registryUrl=https://github.com
-  mod_h2-version: 2.0.27
-
-jobs:
-  autotools:
-    name: ${{ matrix.build.name }}
-    runs-on: 'ubuntu-latest'
-    timeout-minutes: 60
-    strategy:
-      fail-fast: false
-      matrix:
-        build:
-          - name: openssl-quic
-            configure: >-
-              PKG_CONFIG_PATH="$HOME/openssl3/lib64/pkgconfig" LDFLAGS="-Wl,-rpath,$HOME/openssl3/lib64"
-              --enable-warnings --enable-werror --enable-debug --disable-ntlm
-              --with-test-nghttpx="$HOME/nghttpx/bin/nghttpx"
-              --with-openssl=$HOME/openssl3 --with-openssl-quic
-              --with-nghttp3=$HOME/nghttpx
-
-    steps:
-      - run: |
-          sudo rm -f /etc/apt/sources.list.d/microsoft-prod.list
-          sudo apt-get update
-          sudo apt-get install libtool autoconf automake pkg-config stunnel4 \
-            libpsl-dev libbrotli-dev libzstd-dev zlib1g-dev libev-dev libc-ares-dev \
-            nettle-dev libp11-kit-dev libtspi-dev libunistring-dev guile-2.2-dev libtasn1-bin \
-            libtasn1-6-dev libidn2-0-dev gawk gperf libtss2-dev dns-root-data bison gtk-doc-tools \
-            texinfo texlive texlive-extra-utils autopoint libev-dev \
-            apache2 apache2-dev libnghttp2-dev
-          echo 'CC=gcc-12' >> $GITHUB_ENV
-          echo 'CXX=g++-12' >> $GITHUB_ENV
-        name: 'install prereqs and impacket, pytest, crypto, apache2'
-
-      - name: cache openssl3
-        if: contains(matrix.build.install_steps, 'openssl3')
-        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
-        id: cache-openssl3
-        env:
-          cache-name: cache-openssl3
-        with:
-          path: /home/runner/openssl3
-          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ env.openssl3-version }}
-
-      - name: 'install openssl3'
-        if: steps.cache-openssl3.outputs.cache-hit != 'true'
-        run: |
-          git clone --quiet --depth=1 -b ${{ env.openssl3-version }} https://github.com/openssl/openssl
-          cd openssl
-          ./config --prefix=$HOME/openssl3
-          make -j1 install_sw
-          cat exporters/openssl.pc
-
-      - name: cache quictls
-        if: contains(matrix.build.install_steps, 'quictls')
-        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
-        id: cache-quictls
-        env:
-          cache-name: cache-quictls
-        with:
-          path: /home/runner/quictls
-          key: ${{ runner.os }}-build-${{ env.cache-name }}-quictls-${{ env.quictls-version }}
-
-      - name: cache quictls
-        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
-        id: cache-quictls-no-deprecated
-        env:
-          cache-name: cache-quictls-no-deprecated
-        with:
-          path: /home/runner/quictls
-          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ env.quictls-version }}
-
-      - if: steps.cache-quictls-no-deprecated.outputs.cache-hit != 'true'
-        run: |
-          cd $HOME
-          git clone --quiet --depth=1 -b openssl-${{ env.quictls-version }} https://github.com/quictls/openssl quictls
-          cd quictls
-          ./config no-deprecated --prefix=$HOME/nghttpx --libdir=$HOME/nghttpx/lib
-          make
-        name: 'build quictls'
-
-      - run: |
-          cd $HOME/quictls
-          make -j1 install_sw
-        name: 'install quictls'
-
-
-      - name: cache nghttp3
-        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
-        id: cache-nghttp3
-        env:
-          cache-name: cache-nghttp3
-        with:
-          path: /home/runner/nghttp3
-          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ env.nghttp3-version }}
-
-      - if: steps.cache-nghttp3.outputs.cache-hit != 'true'
-        run: |
-          cd $HOME
-          git clone --quiet --depth=1 -b v${{ env.nghttp3-version }} https://github.com/ngtcp2/nghttp3
-          cd nghttp3
-          git submodule update --init
-          autoreconf -fi
-          ./configure --prefix=$HOME/nghttpx PKG_CONFIG_PATH="$HOME/nghttpx/lib/pkgconfig" --enable-lib-only
-          make
-        name: 'build nghttp3'
-
-      - run: |
-          cd $HOME/nghttp3
-          make install
-        name: 'install nghttp3'
-
-      # depends on all other cached libs built so far
-      - run: |
-          git clone --quiet --depth=1 -b v${{ env.ngtcp2-version }} https://github.com/ngtcp2/ngtcp2
-          cd ngtcp2
-          autoreconf -fi
-          ./configure --prefix=$HOME/nghttpx PKG_CONFIG_PATH="$HOME/nghttpx/lib/pkgconfig" --enable-lib-only --with-openssl
-          make install
-        name: 'install ngtcp2'
-
-      # depends on all other cached libs built so far
-      - run: |
-          git clone --quiet --depth=1 -b v${{ env.nghttp2-version }} https://github.com/nghttp2/nghttp2
-          cd nghttp2
-          autoreconf -fi
-          ./configure --prefix=$HOME/nghttpx PKG_CONFIG_PATH="$HOME/nghttpx/lib/pkgconfig" --enable-http3
-          make install
-        name: 'install nghttp2'
-
-      - name: cache mod_h2
-        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
-        id: cache-mod_h2
-        env:
-          cache-name: cache-mod_h2
-        with:
-          path: /home/runner/mod_h2
-          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ env.mod_h2-version }}
-
-      - if: steps.cache-mod_h2.outputs.cache-hit != 'true'
-        run: |
-          cd $HOME
-          git clone --quiet --depth=1 -b v${{ env.mod_h2-version }} https://github.com/icing/mod_h2
-          cd mod_h2
-          autoreconf -fi
-          ./configure
-          make
-        name: 'build mod_h2'
-
-      - run: |
-          cd $HOME/mod_h2
-          sudo make install
-        name: 'install mod_h2'
-
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
-
-      - run: |
-          sudo python3 -m pip install -r tests/requirements.txt -r tests/http/requirements.txt
-        name: 'install python test prereqs'
-
-      - run: autoreconf -fi
-        name: 'autoreconf'
-
-      - run: ./configure ${{ matrix.build.configure }}
-        name: 'configure'
-
-      - run: make V=1
-        name: 'make'
-
-      - run: make V=1 examples
-        name: 'make examples'
-
-      - run: make V=1 -C tests
-        name: 'make tests'
-
-      - run: make V=1 test-ci
-        name: 'run tests'
-
-      - run: pytest -v tests
-        name: 'run pytest'
-        env:
-          TFLAGS: "${{ matrix.build.tflags }}"
-          CURL_CI: github
diff --git a/.github/workflows/proselint.yml b/.github/workflows/proselint.yml
index 634e19bcc..177f247b2 100644
--- a/.github/workflows/proselint.yml
+++ b/.github/workflows/proselint.yml
@@ -29,7 +29,7 @@ jobs:
   check:
     runs-on: ubuntu-latest
     steps:
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
 
       - name: install prereqs
         run: |
@@ -51,7 +51,7 @@ jobs:
           JSON
 
       - name: check prose
-        run: a=`git ls-files '*.md' | grep -Ev '(docs/CHECKSRC.md|docs/DISTROS.md)'` && proselint $a README
+        run: git ls-files '*.md' | grep -Ev 'CHECKSRC.md|DISTROS.md|CURLOPT_INTERFACE.md' | xargs proselint README
 
       # This is for CHECKSRC and files with aggressive exclamation mark needs
       - name: create second proselint config
@@ -68,4 +68,4 @@ jobs:
           JSON
 
       - name: check special prose
-        run: a=docs/CHECKSRC.md && proselint $a
+        run: proselint docs/CHECKSRC.md docs/libcurl/opts/CURLOPT_INTERFACE.md
diff --git a/.github/workflows/quiche-linux.yml b/.github/workflows/quiche-linux.yml
deleted file mode 100644
index dc41c875d..000000000
--- a/.github/workflows/quiche-linux.yml
+++ /dev/null
@@ -1,220 +0,0 @@
-# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
-#
-# SPDX-License-Identifier: curl
-
-name: quiche
-
-on:
-  push:
-    branches:
-      - master
-      - '*/ci'
-    paths-ignore:
-      - '**/*.md'
-      - '**/CMakeLists.txt'
-      - '.azure-pipelines.yml'
-      - '.circleci/**'
-      - '.cirrus.yml'
-      - 'appveyor.*'
-      - 'CMake/**'
-      - 'packages/**'
-      - 'plan9/**'
-      - 'projects/**'
-      - 'winbuild/**'
-  pull_request:
-    branches:
-      - master
-    paths-ignore:
-      - '**/*.md'
-      - '**/CMakeLists.txt'
-      - '.azure-pipelines.yml'
-      - '.circleci/**'
-      - '.cirrus.yml'
-      - 'appveyor.*'
-      - 'CMake/**'
-      - 'packages/**'
-      - 'plan9/**'
-      - 'projects/**'
-      - 'winbuild/**'
-
-concurrency:
-  # Hardcoded workflow filename as workflow name above is just Linux again
-  group: quiche-${{ github.event.pull_request.number || github.sha }}
-  cancel-in-progress: true
-
-permissions: {}
-
-env:
-  MAKEFLAGS: -j 3
-  # unhandled
-  openssl-version: 3.1.4+quic
-  # renovate: datasource=github-tags depName=ngtcp2/nghttp3 versioning=semver registryUrl=https://github.com
-  nghttp3-version: 1.3.0
-  # renovate: datasource=github-tags depName=ngtcp2/ngtcp2 versioning=semver registryUrl=https://github.com
-  ngtcp2-version: 1.5.0
-  # renovate: datasource=github-tags depName=nghttp2/nghttp2 versioning=semver registryUrl=https://github.com
-  nghttp2-version: 1.62.1
-  # renovate: datasource=github-tags depName=cloudflare/quiche versioning=semver registryUrl=https://github.com
-  quiche-version: 0.21.0
-  # renovate: datasource=github-tags depName=icing/mod_h2 versioning=semver registryUrl=https://github.com
-  mod_h2-version: 2.0.27
-
-jobs:
-  autotools:
-    name: ${{ matrix.build.name }}
-    runs-on: 'ubuntu-latest'
-    timeout-minutes: 60
-    strategy:
-      fail-fast: false
-      matrix:
-        build:
-          - name: quiche
-            install: >-
-              libpsl-dev libbrotli-dev libzstd-dev zlib1g-dev libev-dev libc-ares-dev
-            install_steps: pytest
-            configure: >-
-              LDFLAGS="-Wl,-rpath,/home/runner/quiche/target/release"
-              --with-openssl=/home/runner/quiche/quiche/deps/boringssl/src
-              --enable-debug
-              --with-quiche=/home/runner/quiche/target/release
-              --with-test-nghttpx="$HOME/nghttpx/bin/nghttpx"
-              --with-ca-fallback
-
-    steps:
-      - run: |
-          sudo rm -f /etc/apt/sources.list.d/microsoft-prod.list
-          sudo apt-get update
-          sudo apt-get install libtool autoconf automake pkg-config stunnel4 ${{ matrix.build.install }}
-          sudo apt-get install apache2 apache2-dev libnghttp2-dev
-          echo 'CC=gcc-12' >> $GITHUB_ENV
-          echo 'CXX=g++-12' >> $GITHUB_ENV
-        name: 'install prereqs and impacket, pytest, crypto'
-
-      - name: cache nghttpx
-        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
-        id: cache-nghttpx
-        env:
-          cache-name: cache-nghttpx
-        with:
-          path: /home/runner/nghttpx
-          key: ${{ runner.os }}-build-${{ env.cache-name }}-openssl-${{ env.openssl-version }}-nghttp3-${{ env.nghttp3-version }}-ngtcp2-${{ env.ngtcp2-version }}-nghttp2-${{ env.nghttp2-version }}
-
-      - if: steps.cache-nghttpx.outputs.cache-hit != 'true'
-        run: |
-          git clone --quiet --depth=1 -b openssl-${{ env.openssl-version }} https://github.com/quictls/openssl
-          cd openssl
-          ./config --prefix=$HOME/nghttpx --libdir=$HOME/nghttpx/lib
-          make -j1 install_sw
-        name: 'install quictls'
-
-      - if: steps.cache-nghttpx.outputs.cache-hit != 'true'
-        run: |
-          git clone --quiet --depth=1 -b v${{ env.nghttp3-version }} https://github.com/ngtcp2/nghttp3
-          cd nghttp3
-          git submodule update --init
-          autoreconf -fi
-          ./configure --prefix=$HOME/nghttpx PKG_CONFIG_PATH="$HOME/nghttpx/lib/pkgconfig" --enable-lib-only
-          make install
-        name: 'install nghttp3'
-
-      - if: steps.cache-nghttpx.outputs.cache-hit != 'true'
-        run: |
-          git clone --quiet --depth=1 -b v${{ env.ngtcp2-version }} https://github.com/ngtcp2/ngtcp2
-          cd ngtcp2
-          autoreconf -fi
-          ./configure --prefix=$HOME/nghttpx PKG_CONFIG_PATH="$HOME/nghttpx/lib/pkgconfig" --enable-lib-only --with-openssl
-          make install
-        name: 'install ngtcp2'
-
-      - if: steps.cache-nghttpx.outputs.cache-hit != 'true'
-        run: |
-          git clone --quiet --depth=1 -b v${{ env.nghttp2-version }} https://github.com/nghttp2/nghttp2
-          cd nghttp2
-          autoreconf -fi
-          ./configure --prefix=$HOME/nghttpx PKG_CONFIG_PATH="$HOME/nghttpx/lib/pkgconfig" --enable-http3
-          make install
-        name: 'install nghttp2'
-
-      - name: cache quiche
-        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
-        id: cache-quiche
-        env:
-          cache-name: cache-quiche
-        with:
-          path: /home/runner/quiche
-          key: ${{ runner.os }}-build-${{ env.cache-name }}-quiche-${{ env.quiche-version }}
-
-      - if: steps.cache-quiche.outputs.cache-hit != 'true'
-        run: |
-          cd $HOME
-          git clone --quiet --depth=1 -b ${{ env.quiche-version }} --recursive https://github.com/cloudflare/quiche.git
-          cd quiche
-          #### Work-around https://github.com/curl/curl/issues/7927 #######
-          #### See https://github.com/alexcrichton/cmake-rs/issues/131 ####
-          sed -i -e 's/cmake = "0.1"/cmake = "=0.1.45"/' quiche/Cargo.toml
-
-          cargo build -v --package quiche --release --features ffi,pkg-config-meta,qlog --verbose
-          mkdir -v quiche/deps/boringssl/src/lib
-          ln -vnf $(find target/release -name libcrypto.a -o -name libssl.a) quiche/deps/boringssl/src/lib/
-
-          # include dir
-          # /home/runner/quiche/quiche/deps/boringssl/src/include
-          # lib dir
-          # /home/runner/quiche/quiche/deps/boringssl/src/lib
-        name: 'build quiche and boringssl'
-
-      - name: cache mod_h2
-        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
-        id: cache-mod_h2
-        env:
-          cache-name: cache-mod_h2
-        with:
-          path: /home/runner/mod_h2
-          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ env.mod_h2-version }}
-
-      - if: steps.cache-mod_h2.outputs.cache-hit != 'true'
-        run: |
-          cd $HOME
-          git clone --quiet --depth=1 -b v${{ env.mod_h2-version }} https://github.com/icing/mod_h2
-          cd mod_h2
-          autoreconf -fi
-          ./configure
-          make
-        name: 'build mod_h2'
-
-      - run: |
-          cd $HOME/mod_h2
-          sudo make install
-        name: 'install mod_h2'
-
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
-
-      - run: |
-          sudo python3 -m pip install -r tests/requirements.txt -r tests/http/requirements.txt
-        name: 'install python test prereqs'
-
-      - run: autoreconf -fi
-        name: 'autoreconf'
-
-      - run: ./configure ${{ matrix.build.configure }}
-        name: 'configure'
-
-      - run: make V=1
-        name: 'make'
-
-      - run: make V=1 examples
-        name: 'make examples'
-
-      - run: make V=1 -C tests
-        name: 'make tests'
-
-      - run: make V=1 test-ci
-        name: 'run tests'
-        env:
-          TFLAGS: "${{ matrix.build.tflags }}"
-
-      - run: pytest -v tests
-        name: 'run pytest'
-        env:
-          TFLAGS: "${{ matrix.build.tflags }}"
-          CURL_CI: github
diff --git a/.github/workflows/reuse.yml b/.github/workflows/reuse.yml
index f8e196919..fc2371fc4 100644
--- a/.github/workflows/reuse.yml
+++ b/.github/workflows/reuse.yml
@@ -24,6 +24,6 @@ jobs:
   check:
     runs-on: ubuntu-latest
     steps:
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
       - name: REUSE Compliance Check
-        uses: fsfe/reuse-action@a46482ca367aef4454a87620aa37c2be4b2f8106 # v3
+        uses: fsfe/reuse-action@3ae3c6bdf1257ab19397fab11fd3312144692083 # v4
diff --git a/.github/workflows/shellcheck.yml b/.github/workflows/shellcheck.yml
index 03b28ad6a..524a82848 100644
--- a/.github/workflows/shellcheck.yml
+++ b/.github/workflows/shellcheck.yml
@@ -23,6 +23,6 @@ jobs:
     runs-on: ubuntu-latest
     timeout-minutes: 5
     steps:
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
       - name: 'shellcheck'
         run: .github/scripts/shellcheck.sh
diff --git a/.github/workflows/spacecheck.yml b/.github/workflows/spacecheck.yml
new file mode 100644
index 000000000..1a68185f9
--- /dev/null
+++ b/.github/workflows/spacecheck.yml
@@ -0,0 +1,28 @@
+# Copyright (C) Viktor Szakats
+#
+# SPDX-License-Identifier: curl
+
+name: spacecheck
+
+on:
+  push:
+    branches:
+      - master
+  pull_request:
+    branches:
+      - master
+
+concurrency:
+  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.sha }}
+  cancel-in-progress: true
+
+permissions: {}
+
+jobs:
+  spacecheck:
+    runs-on: ubuntu-latest
+    timeout-minutes: 2
+    steps:
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
+      - name: 'spacecheck'
+        run: .github/scripts/spacecheck.pl
diff --git a/.github/workflows/spellcheck.yml b/.github/workflows/spellcheck.yml
index ada417029..12f82a079 100644
--- a/.github/workflows/spellcheck.yml
+++ b/.github/workflows/spellcheck.yml
@@ -27,7 +27,7 @@ jobs:
   check:
     runs-on: ubuntu-latest
     steps:
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
 
       - name: trim all man page *.md files
         run: find docs -name "*.md" ! -name "_*" | xargs -n1 ./.github/scripts/cleancmd.pl
@@ -45,6 +45,6 @@ jobs:
         run: grep -v '^#' .github/scripts/spellcheck.words >  wordlist.txt
 
       - name: Check Spelling
-        uses: rojopolis/spellcheck-github-actions@dbd2f1da869c05ad874fffeb6fe1ed50cd1a6e98 # v0
+        uses: rojopolis/spellcheck-github-actions@d354a4dc525c8067555c7481b60416cedb0060ff # v0
         with:
           config_path: .github/scripts/spellcheck.yaml
diff --git a/.github/workflows/synopsis.yml b/.github/workflows/synopsis.yml
index 4bd6c5b67..10e7949b6 100644
--- a/.github/workflows/synopsis.yml
+++ b/.github/workflows/synopsis.yml
@@ -10,12 +10,16 @@ on:
       - master
       - '*/ci'
     paths:
-      - 'docs/libcurl/curl_*.3'
+      - 'docs/libcurl/curl_*.md'
+      - 'scripts/*.pl'
+      - '.github/workflows/*.yml'
   pull_request:
     branches:
       - master
     paths:
-      - 'docs/libcurl/curl_*.3'
+      - 'docs/libcurl/curl_*.md'
+      - 'scripts/*.pl'
+      - '.github/workflows/*.yml'
 
 permissions: {}
 
@@ -24,7 +28,7 @@ jobs:
     runs-on: ubuntu-latest
     steps:
       - name: Checkout
-        uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
 
       - name: verify-synopsis
-        run: ./.github/scripts/verify-synopsis.pl docs/libcurl/curl*.3
+        run: ./.github/scripts/verify-synopsis.pl docs/libcurl/curl*.md
diff --git a/.github/workflows/torture.yml b/.github/workflows/torture.yml
index b5330776d..10bd34ce9 100644
--- a/.github/workflows/torture.yml
+++ b/.github/workflows/torture.yml
@@ -14,7 +14,6 @@ on:
       - '**/CMakeLists.txt'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'CMake/**'
       - 'packages/**'
@@ -29,7 +28,6 @@ on:
       - '**/CMakeLists.txt'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'CMake/**'
       - 'packages/**'
@@ -45,7 +43,7 @@ concurrency:
 permissions: {}
 
 env:
-  MAKEFLAGS: -j 3
+  MAKEFLAGS: -j 5
 
 jobs:
   autotools:
@@ -73,12 +71,12 @@ jobs:
           sudo python3 -m pip install impacket
         name: 'install prereqs and impacket'
 
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
 
       - run: autoreconf -fi
         name: 'autoreconf'
 
-      - run: ./configure --enable-warnings --enable-werror ${{ matrix.build.configure }}
+      - run: ./configure --disable-dependency-tracking --enable-warnings --enable-werror ${{ matrix.build.configure }}
         name: 'configure'
 
       - run: make V=1
diff --git a/.github/workflows/windows.yml b/.github/workflows/windows.yml
index c41337bee..148f148aa 100644
--- a/.github/workflows/windows.yml
+++ b/.github/workflows/windows.yml
@@ -13,7 +13,6 @@ on:
       - '**/*.md'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'packages/**'
       - 'plan9/**'
@@ -26,7 +25,6 @@ on:
       - '**/*.md'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'packages/**'
       - 'plan9/**'
@@ -41,20 +39,24 @@ permissions: {}
 
 jobs:
   cygwin:
-    name: "cygwin (${{ matrix.build }}, ${{ matrix.platform }}, ${{ matrix.config }})"
+    name: "cygwin, ${{ matrix.build == 'cmake' && 'CM' || 'AM' }} ${{ matrix.platform }} ${{ matrix.name }}"
     runs-on: windows-latest
     timeout-minutes: 45
+    defaults:
+      run:
+        shell: C:\cygwin\bin\bash.exe '{0}'
     env:
       SHELLOPTS: 'igncr'
     strategy:
       matrix:
         include:
-          - { build: 'automake', platform: 'x86_64', tflags: '', config: '--enable-debug --disable-threaded-resolver' }
-          - { build: 'cmake'   , platform: 'x86_64', tflags: '', config: '-DCURL_USE_OPENSSL=ON' }
+          - { build: 'automake', platform: 'x86_64', tflags: ''       , config: '--enable-debug --disable-threaded-resolver', name: 'openssl' }
+          - { build: 'cmake'   , platform: 'x86_64', tflags: 'skipall', config: '-DCURL_USE_OPENSSL=ON', name: 'openssl R' }
       fail-fast: false
     steps:
       - run: git config --global core.autocrlf input
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+        shell: pwsh
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
       - uses: cygwin/cygwin-install-action@006ad0b0946ca6d0a3ea2d4437677fa767392401 # v4
         with:
           platform: ${{ matrix.platform }}
@@ -62,103 +64,154 @@ jobs:
           packages: autoconf libtool ${{ matrix.build }} gcc-core gcc-g++ binutils make libssl-devel zlib-devel libbrotli-devel libnghttp2-devel libpsl-devel libssh2-devel
           site: https://mirrors.kernel.org/sourceware/cygwin/
 
+      - name: 'autotools autoreconf'
+        if: ${{ matrix.build == 'automake' }}
+        timeout-minutes: 2
+        run: autoreconf -fi
+
       - name: 'autotools configure'
         if: ${{ matrix.build == 'automake' }}
         timeout-minutes: 5
-        shell: C:\cygwin\bin\bash.exe '{0}'
         run: |
-          export PATH="/usr/bin:$(cygpath ${SYSTEMROOT})/system32"
-          autoreconf -fi
+          PATH="/usr/bin:$(cygpath "${SYSTEMROOT}")/System32"
           mkdir bld && cd bld && ../configure --enable-warnings --enable-werror \
             --prefix="${HOME}"/install \
             --enable-websockets \
             --with-openssl \
             --with-libssh2 \
-            ${{ matrix.config }} || { tail -n 1200 config.log; false; }
+            --disable-dependency-tracking \
+            ${{ matrix.config }}
+
+      - name: 'autotools configure log'
+        if: ${{ matrix.build == 'automake' && !cancelled() }}
+        run: cat bld/config.log 2>/dev/null || true
+
+      - name: 'curl_config.h'
+        if: ${{ matrix.build == 'automake' }}
+        run: cat bld/lib/curl_config.h | grep -F '#define' | sort || true
+
+      - name: 'curl_config.h (full)'
+        if: ${{ matrix.build == 'automake' }}
+        run: cat bld/lib/curl_config.h || true
 
       - name: 'autotools build'
         if: ${{ matrix.build == 'automake' }}
         timeout-minutes: 10
-        shell: C:\cygwin\bin\bash.exe '{0}'
+        run: make -C bld -j5 V=1 install
+
+      - name: 'curl version'
+        if: ${{ matrix.build == 'automake' }}
+        timeout-minutes: 1
         run: |
-          make -C bld -j3 V=1 install
           find . -name '*.exe' -o -name '*.dll'
           bld/src/curl.exe --disable --version
 
       - name: 'autotools build examples'
         if: ${{ matrix.build == 'automake' }}
         timeout-minutes: 5
-        shell: C:\cygwin\bin\bash.exe '{0}'
-        run: |
-          make -C bld -j3 V=1 examples
+        run: make -C bld -j5 V=1 examples
 
       - name: 'autotools build tests'
-        if: ${{ matrix.build == 'automake' }}
-        timeout-minutes: 10
-        shell: C:\cygwin\bin\bash.exe '{0}'
-        run: |
-          make -C bld -j3 -C tests V=1
+        if: ${{ matrix.build == 'automake' && matrix.tflags != 'skipall' }}
+        timeout-minutes: 15
+        run: make -C bld -j5 V=1 -C tests
 
       - name: 'autotools run tests'
-        if: ${{ matrix.build == 'automake' && matrix.tflags != 'skip' }}
+        if: ${{ matrix.build == 'automake' && matrix.tflags != 'skipall' && matrix.tflags != 'skiprun' }}
         timeout-minutes: 40
-        shell: C:\cygwin\bin\bash.exe '{0}'
         run: |
           export TFLAGS='-j8 ${{ matrix.tflags }}'
-          if [ -x "$(cygpath -u "${SYSTEMROOT}/System32/curl.exe")" ]; then
-            TFLAGS+=" -ac $(cygpath -u "${SYSTEMROOT}/System32/curl.exe")"
+          if [ -x "$(cygpath "${SYSTEMROOT}/System32/curl.exe")" ]; then
+            TFLAGS+=" -ac $(cygpath "${SYSTEMROOT}/System32/curl.exe")"
           fi
-          make -C bld -j3 V=1 test-ci
+          make -C bld -j5 V=1 test-ci
 
       - name: 'cmake configure'
         if: ${{ matrix.build == 'cmake' }}
         timeout-minutes: 5
-        shell: C:\cygwin\bin\bash.exe '{0}'
         run: |
-          export PATH="/usr/bin:$(cygpath ${SYSTEMROOT})/system32"
-          cmake -B bld ${options} ${{ matrix.config }} \
-            "-DCMAKE_C_FLAGS=${cflags}" \
+          PATH="/usr/bin:$(cygpath "${SYSTEMROOT}")/System32"
+          cmake -B bld ${options} \
             -DCMAKE_UNITY_BUILD=ON \
             -DCURL_WERROR=ON \
             -DBUILD_EXAMPLES=ON \
             -DENABLE_WEBSOCKETS=ON \
-            -DCURL_BROTLI=ON -DUSE_NGHTTP2=ON
+            -DCURL_BROTLI=ON -DUSE_NGHTTP2=ON \
+            ${{ matrix.config }}
+
+      - name: 'cmake configure log'
+        if: ${{ matrix.build == 'cmake' && !cancelled() }}
+        run: cat bld/CMakeFiles/CMake*.yaml 2>/dev/null || true
+
+      - name: 'curl_config.h'
+        if: ${{ matrix.build == 'cmake' }}
+        run: cat bld/lib/curl_config.h | grep -F '#define' | sort || true
+
+      - name: 'curl_config.h (full)'
+        if: ${{ matrix.build == 'cmake' }}
+        run: cat bld/lib/curl_config.h || true
 
       - name: 'cmake build'
         if: ${{ matrix.build == 'cmake' }}
         timeout-minutes: 10
-        shell: C:\cygwin\bin\bash.exe '{0}'
+        run: cmake --build bld --config '${{ matrix.type }}' --parallel 5
+
+      - name: 'curl version'
+        if: ${{ matrix.build == 'cmake' }}
+        timeout-minutes: 1
         run: |
-          cmake --build bld --config '${{ matrix.type }}' --parallel 3
-          [[ '${{ matrix.config }}' != *'BUILD_SHARED_LIBS=OFF'* ]] && cp -f -p bld/lib/*.dll bld/src/
-          find . -name '*.exe' -o -name '*.dll'
+          find . -name '*.exe' -o -name '*.dll' | grep -v '/examples/'
+          PATH="$PWD/bld/lib:$PATH"
           bld/src/curl.exe --disable --version
 
-  msys2:
-    name: "msys2 (${{ matrix.build }}, ${{ matrix.sys }}, ${{ matrix.env }}, ${{ matrix.config }})"
+      - name: 'cmake build tests'
+        if: ${{ matrix.build == 'cmake' && matrix.tflags != 'skipall' }}
+        timeout-minutes: 15
+        run: cmake --build bld --config '${{ matrix.type }}' --parallel 5 --target testdeps
+
+      - name: 'cmake run tests'
+        if: ${{ matrix.build == 'cmake' && matrix.tflags != 'skipall' && matrix.tflags != 'skiprun' }}
+        timeout-minutes: 40
+        run: |
+          export TFLAGS='-j8 ${{ matrix.tflags }}'
+          if [ -x "$(cygpath "${SYSTEMROOT}/System32/curl.exe")" ]; then
+            TFLAGS+=" -ac $(cygpath "${SYSTEMROOT}/System32/curl.exe")"
+          fi
+          PATH="$PWD/bld/lib:$PATH"
+          cmake --build bld --config '${{ matrix.type }}' --target test-ci
+
+  msys2:  # both msys and mingw-w64
+    name: "${{ matrix.sys == 'msys' && 'msys2' || 'mingw' }}, ${{ matrix.build == 'cmake' && 'CM' || 'AM' }} ${{ matrix.env }} ${{ matrix.name }} ${{ matrix.test }}"
     runs-on: windows-latest
     timeout-minutes: 45
+    defaults:
+      run:
+        shell: msys2 {0}
     strategy:
       matrix:
         include:
-          - { build: 'autotools', sys: 'msys'   , env: 'x86_64'      , tflags: '!19                !1233', config: '--enable-debug --disable-threaded-resolver --disable-proxy' }
-          - { build: 'autotools', sys: 'msys'   , env: 'x86_64'      , tflags: '!19 !504 !704 !705 !1233', config: '--enable-debug --disable-threaded-resolver' }
-          - { build: 'autotools', sys: 'msys'   , env: 'x86_64'      , tflags: '!19 !504 !704 !705 !1233', config: '' }
+          - { build: 'autotools', sys: 'msys'   , env: 'x86_64'      , tflags: '!19                !1233', config: '--enable-debug --disable-threaded-resolver --disable-proxy', name: '!proxy' }
+          - { build: 'autotools', sys: 'msys'   , env: 'x86_64'      , tflags: '!19 !504 !704 !705 !1233', config: '--enable-debug --disable-threaded-resolver', name: 'default' }
+          - { build: 'cmake'    , sys: 'msys'   , env: 'x86_64'      , tflags: 'skipall'                 , config: '-DENABLE_DEBUG=ON -DENABLE_THREADED_RESOLVER=OFF', name: 'default' }
+          - { build: 'autotools', sys: 'msys'   , env: 'x86_64'      , tflags: '!19 !504 !704 !705 !1233', config: '', name: 'default R' }
+          - { build: 'autotools', sys: 'mingw64', env: 'x86_64'      , tflags: 'skiprun'                 , config: '--enable-debug --disable-threaded-resolver --disable-curldebug --enable-static=no', name: 'default' }
           # FIXME: WebSockets test results ignored due to frequent failures on native Windows:
-          - { build: 'cmake'    , sys: 'mingw64', env: 'x86_64'      , tflags: '!TFTP ~2301 ~2302'       , config: '-DENABLE_DEBUG=ON -DBUILD_SHARED_LIBS=OFF -DCURL_USE_SCHANNEL=ON -DENABLE_UNICODE=ON', type: 'Debug' }
-          - { build: 'cmake'    , sys: 'mingw64', env: 'x86_64'      , tflags: 'skip'                    , config: '-DENABLE_DEBUG=ON -DBUILD_SHARED_LIBS=OFF -DCURL_USE_SCHANNEL=ON -DENABLE_UNICODE=ON', type: 'Release' }
-          - { build: 'cmake'    , sys: 'clang64', env: 'clang-x86_64', tflags: 'skip'                    , config: '-DENABLE_DEBUG=ON -DBUILD_SHARED_LIBS=OFF -DCURL_USE_OPENSSL=ON -DENABLE_UNICODE=OFF', type: 'Release' }
+          - { build: 'cmake'    , sys: 'mingw64', env: 'x86_64'      , tflags: '~2301 ~2302'             , config: '-DENABLE_DEBUG=ON -DBUILD_SHARED_LIBS=OFF -DCURL_USE_SCHANNEL=ON -DENABLE_UNICODE=ON', type: 'Debug', name: 'schannel U' }
+          - { build: 'cmake'    , sys: 'ucrt64' , env: 'ucrt-x86_64' , tflags: 'skiprun'                 , config: '-DENABLE_DEBUG=OFF -DBUILD_SHARED_LIBS=ON -DCURL_USE_SCHANNEL=ON -DENABLE_UNICODE=ON -DENABLE_CURLDEBUG=ON', type: 'Release', name: 'schannel R TrackMemory' }
+          - { build: 'cmake'    , sys: 'clang64', env: 'clang-x86_64', tflags: 'skiprun'                 , config: '-DENABLE_DEBUG=ON -DBUILD_SHARED_LIBS=OFF -DCURL_USE_OPENSSL=ON -DENABLE_UNICODE=OFF', type: 'Release', name: 'openssl' }
+          - { build: 'cmake'    , sys: 'mingw64', env: 'x86_64'      , tflags: 'skiprun'                 , config: '-DENABLE_DEBUG=OFF -DBUILD_SHARED_LIBS=ON -DCURL_USE_SCHANNEL=ON -DENABLE_UNICODE=ON -DBUILD_EXAMPLES=OFF', type: 'Release', test: 'uwp', name: 'schannel R' }
       fail-fast: false
     steps:
       - run: git config --global core.autocrlf input
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
-      - uses: msys2/setup-msys2@d0e80f58dffbc64f6a3a1f43527d469b4fc7b6c8 # v2
+        shell: pwsh
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
+      - uses: msys2/setup-msys2@5df0ca6cbf14efcd08f8d5bd5e049a3cc8e07fd2 # v2
         if: ${{ matrix.sys == 'msys' }}
         with:
           msystem: ${{ matrix.sys }}
           # https://packages.msys2.org/search
           install: gcc ${{ matrix.build }} make openssl-devel zlib-devel brotli-devel libnghttp2-devel libpsl-devel libssh2-devel
-      - uses: msys2/setup-msys2@d0e80f58dffbc64f6a3a1f43527d469b4fc7b6c8 # v2
+      - uses: msys2/setup-msys2@5df0ca6cbf14efcd08f8d5bd5e049a3cc8e07fd2 # v2
         if: ${{ matrix.sys != 'msys' }}
         with:
           msystem: ${{ matrix.sys }}
@@ -166,71 +219,87 @@ jobs:
             mingw-w64-${{ matrix.env }}-cc
             mingw-w64-${{ matrix.env }}-${{ matrix.build }} make
             mingw-w64-${{ matrix.env }}-openssl
+            mingw-w64-${{ matrix.env }}-libssh2
+
+      - name: 'autotools autoreconf'
+        if: ${{ matrix.build == 'autotools' }}
+        timeout-minutes: 2
+        run: autoreconf -fi
 
       - name: 'autotools configure'
         if: ${{ matrix.build == 'autotools' }}
         timeout-minutes: 5
-        shell: msys2 {0}
         run: |
-          autoreconf -fi
           mkdir bld && cd bld && ../configure --enable-warnings --enable-werror \
             --prefix="${HOME}"/install \
             --enable-websockets \
             --with-openssl \
             --with-libssh2 \
-            ${{ matrix.config }} || { tail -n 1200 config.log; false; }
+            --disable-dependency-tracking \
+            ${{ matrix.config }}
+
+      - name: 'autotools configure log'
+        if: ${{ matrix.build == 'autotools' && !cancelled() }}
+        run: cat bld/config.log 2>/dev/null || true
+
+      - name: 'curl_config.h'
+        if: ${{ matrix.build == 'autotools' }}
+        run: cat bld/lib/curl_config.h | grep -F '#define' | sort || true
+
+      - name: 'curl_config.h (full)'
+        if: ${{ matrix.build == 'autotools' }}
+        run: cat bld/lib/curl_config.h || true
 
       - name: 'autotools build'
         if: ${{ matrix.build == 'autotools' }}
         timeout-minutes: 10
-        shell: msys2 {0}
+        run: make -C bld -j5 V=1 install
+
+      - name: 'curl version'
+        if: ${{ matrix.build == 'autotools' }}
+        timeout-minutes: 11
         run: |
-          make -C bld -j3 V=1 install
           find . -name '*.exe' -o -name '*.dll'
           bld/src/curl.exe --disable --version
 
       - name: 'autotools build examples'
         if: ${{ matrix.build == 'autotools' }}
         timeout-minutes: 5
-        shell: msys2 {0}
-        run: |
-          make -C bld -j3 V=1 examples
+        run: make -C bld -j5 V=1 examples
 
       - name: 'autotools build tests'
-        if: ${{ matrix.build == 'autotools' }}
+        if: ${{ matrix.build == 'autotools' && matrix.tflags != 'skipall' }}
         timeout-minutes: 10
-        shell: msys2 {0}
-        run: |
-          make -C bld -j3 -C tests V=1
+        run: make -C bld -j5 V=1 -C tests
 
       - name: 'autotools run tests'
-        if: ${{ matrix.build == 'autotools' && matrix.tflags != 'skip' }}
+        if: ${{ matrix.build == 'autotools' && matrix.tflags != 'skipall' && matrix.tflags != 'skiprun' }}
         timeout-minutes: 30
-        shell: msys2 {0}
         run: |
           export TFLAGS='-j14 ${{ matrix.tflags }}'
-          if [ -x "$(cygpath -u 'C:/msys64/usr/bin/curl.exe')" ]; then
-            TFLAGS+=" -ac $(cygpath -u 'C:/msys64/usr/bin/curl.exe')"
+          if [ '${{ matrix.sys }}' != 'msys' ]; then
+            TFLAGS+=' !TFTP !MQTT !WebSockets !SMTP ~FTP'
+          fi
+          if [ -x "$(cygpath "${SYSTEMROOT}/System32/curl.exe")" ]; then
+            TFLAGS+=" -ac $(cygpath "${SYSTEMROOT}/System32/curl.exe")"
           fi
-          make -C bld -j3 V=1 test-ci
+          make -C bld -j5 V=1 test-ci
 
       - name: 'cmake configure'
         if: ${{ matrix.build == 'cmake' }}
         timeout-minutes: 5
-        shell: msys2 {0}
         run: |
           if [[ '${{ matrix.env }}' = 'clang'* ]]; then
             options='-DCMAKE_C_COMPILER=clang'
           else
             options='-DCMAKE_C_COMPILER=gcc'
           fi
-          cflags='-Wno-deprecated-declarations'
           if [ '${{ matrix.test }}' = 'uwp' ]; then
             options+=' -DCMAKE_SYSTEM_NAME=WindowsStore -DCMAKE_SYSTEM_VERSION=10.0'
             pacman --noconfirm --ask 20 --noprogressbar --sync --needed 'mingw-w64-${{ matrix.env }}-winstorecompat-git'
             specs="$(realpath gcc-specs-uwp)"
             gcc -dumpspecs | sed -e 's/-lmingwex/-lwindowsapp -lmingwex -lwindowsapp -lwindowsappcompat/' -e 's/-lmsvcrt/-lmsvcr120_app/' > "${specs}"
-            cflags+=" -specs=${specs} -DWINSTORECOMPAT -DWINAPI_FAMILY=WINAPI_FAMILY_APP"
+            cflags="-specs=$(cygpath -w "${specs}") -DWINSTORECOMPAT -DWINAPI_FAMILY=WINAPI_FAMILY_APP"
             # CMake (as of v3.26.4) gets confused and applies the MSVC rc.exe command-line
             # template to windres. Reset it to the windres template manually:
             rcopts='<CMAKE_RC_COMPILER> -O coff <DEFINES> <INCLUDES> <FLAGS> <SOURCE> <OBJECT>'
@@ -239,42 +308,326 @@ jobs:
           fi
           [ '${{ matrix.type }}' = 'Debug' ] && options+=' -DCMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG='
           [ '${{ matrix.type }}' = 'Release' ] && options+=' -DCMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE='
-          [ '${{ matrix.type }}' = 'Release' ] && [[ '${{ matrix.config }}' = *'ENABLE_DEBUG=ON'* ]] && cflags+=' -DDEBUGBUILD'
-          cmake -B bld ${options} ${{ matrix.config }} \
+          cmake -B bld ${options} \
             "-DCMAKE_C_FLAGS=${cflags}" \
             "-DCMAKE_RC_COMPILE_OBJECT=${rcopts}" \
-            "-DCMAKE_BUILD_TYPE=${{ matrix.type }}" \
+            '-DCMAKE_BUILD_TYPE=${{ matrix.type }}' \
             -DCMAKE_UNITY_BUILD=ON \
             -DCURL_WERROR=ON \
             -DBUILD_EXAMPLES=ON \
             -DENABLE_WEBSOCKETS=ON \
-            -DCURL_BROTLI=ON -DUSE_NGHTTP2=ON
+            -DCURL_BROTLI=ON -DUSE_NGHTTP2=ON \
+            ${{ matrix.config }}
+
+      - name: 'cmake configure log'
+        if: ${{ matrix.build == 'cmake' && !cancelled() }}
+        run: cat bld/CMakeFiles/CMake*.yaml 2>/dev/null || true
+
+      - name: 'curl_config.h'
+        if: ${{ matrix.build == 'cmake' }}
+        run: cat bld/lib/curl_config.h | grep -F '#define' | sort || true
+
+      - name: 'curl_config.h (full)'
+        if: ${{ matrix.build == 'cmake' }}
+        run: cat bld/lib/curl_config.h || true
 
       - name: 'cmake build'
         if: ${{ matrix.build == 'cmake' }}
         timeout-minutes: 10
-        shell: msys2 {0}
+        run: cmake --build bld --config '${{ matrix.type }}' --parallel 5
+
+      - name: 'curl version'
+        if: ${{ matrix.build == 'cmake' }}
+        timeout-minutes: 1
         run: |
-          cmake --build bld --config '${{ matrix.type }}' --parallel 3
-          [[ '${{ matrix.config }}' != *'BUILD_SHARED_LIBS=OFF'* ]] && cp -f -p bld/lib/*.dll bld/src/
-          find . -name '*.exe' -o -name '*.dll'
+          find . -name '*.exe' -o -name '*.dll' | grep -v '/examples/'
+          if [ '${{ matrix.test }}' != 'uwp' ]; then  # UWP missing 'msvcr120_app.dll', fails with exit code 0xc0000135
+            PATH="$PWD/bld/lib:$PATH"
+            bld/src/curl.exe --disable --version
+          fi
+
+      - name: 'cmake build tests'
+        if: ${{ matrix.build == 'cmake' && matrix.tflags != 'skipall' }}
+        timeout-minutes: 10
+        run: cmake --build bld --config '${{ matrix.type }}' --parallel 5 --target testdeps
+
+      - name: 'cmake run tests'
+        if: ${{ matrix.build == 'cmake' && matrix.tflags != 'skipall' && matrix.tflags != 'skiprun' }}
+        timeout-minutes: 40
+        run: |
+          export TFLAGS='-j14 ${{ matrix.tflags }}'
+          if [ '${{ matrix.sys }}' != 'msys' ]; then
+            TFLAGS+=' !TFTP !MQTT !WebSockets !SMTP ~FTP'
+          fi
+          if [ -x "$(cygpath "${SYSTEMROOT}/System32/curl.exe")" ]; then
+            TFLAGS+=" -ac $(cygpath "${SYSTEMROOT}/System32/curl.exe")"
+          fi
+          PATH="$PWD/bld/lib:$PATH"
+          cmake --build bld --config '${{ matrix.type }}' --target test-ci
+
+  old-mingw-w64:
+    name: 'old-mingw, CM ${{ matrix.env }} ${{ matrix.name }}'
+    runs-on: windows-latest
+    timeout-minutes: 45
+    defaults:
+      run:
+        shell: C:\msys64\usr\bin\bash.exe {0}
+    strategy:
+      matrix:
+        include:
+          - name: 'schannel'
+            env: '9.5.0-x86_64'
+            dir: 'mingw64'
+            url: 'https://github.com/brechtsanders/winlibs_mingw/releases/download/9.5.0-10.0.0-msvcrt-r1/winlibs-x86_64-posix-seh-gcc-9.5.0-mingw-w64msvcrt-10.0.0-r1.7z'
+            config: '-DENABLE_DEBUG=ON -DBUILD_SHARED_LIBS=OFF -DCURL_USE_SCHANNEL=ON -DENABLE_UNICODE=OFF'
+            type: 'Release'
+            tflags: '~2301 ~2302 ~3027'
+          - name: 'schannel U'
+            env: '7.3.0-x86_64'
+            dir: 'mingw64'
+            url: 'https://downloads.sourceforge.net/mingw-w64/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/7.3.0/threads-win32/seh/x86_64-7.3.0-release-win32-seh-rt_v5-rev0.7z'
+            config: '-DENABLE_DEBUG=ON -DBUILD_SHARED_LIBS=OFF -DCURL_USE_SCHANNEL=ON -DENABLE_UNICODE=ON'
+            type: 'Release'
+            tflags: '~2301 ~2302 ~3027'
+          - name: 'schannel !unity'
+            env: '6.4.0-i686'
+            dir: 'mingw32'
+            url: 'https://downloads.sourceforge.net/mingw-w64/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/6.4.0/threads-win32/dwarf/i686-6.4.0-release-win32-dwarf-rt_v5-rev0.7z'
+            config: '-DENABLE_DEBUG=ON -DBUILD_SHARED_LIBS=OFF -DCURL_USE_SCHANNEL=ON -DENABLE_UNICODE=OFF -DCMAKE_UNITY_BUILD=OFF'
+            type: 'Debug'
+            tflags: 'skiprun'
+      fail-fast: false
+    steps:
+      - name: 'cache compiler (gcc ${{ matrix.env }})'
+        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4
+        id: cache-compiler
+        with:
+          path: ~\my-cache
+          key: ${{ runner.os }}-mingw-w64-${{ matrix.env }}
+
+      - name: 'install compiler (gcc ${{ matrix.env }})'
+        if: ${{ steps.cache-compiler.outputs.cache-hit != 'true' }}
+        timeout-minutes: 5
+        run: |
+          cd "${USERPROFILE}" || exit 1
+          mkdir my-cache
+          cd my-cache || exit 1
+          curl --fail --silent --show-error --retry 3 --retry-connrefused --output pack.bin --location --proto-redir =https '${{ matrix.url }}'
+          pwd
+          7z x -y pack.bin >/dev/null
+          rm -r -f pack.bin
+          ls -l
+
+      - run: git config --global core.autocrlf input
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
+
+      - name: 'cmake configure'
+        timeout-minutes: 5
+        run: |
+          PATH="$(cygpath "${USERPROFILE}")/my-cache/${{ matrix.dir }}/bin:/c/msys64/usr/bin:$PATH"
+          [ '${{ matrix.type }}' = 'Debug' ] && options+=' -DCMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG='
+          [ '${{ matrix.type }}' = 'Release' ] && options+=' -DCMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE='
+          cmake -B bld ${options} \
+            '-GMSYS Makefiles' \
+            -DCMAKE_C_COMPILER=gcc \
+            '-DCMAKE_BUILD_TYPE=${{ matrix.type }}' \
+            -DCMAKE_UNITY_BUILD=ON \
+            -DCURL_WERROR=ON \
+            -DBUILD_EXAMPLES=ON \
+            -DENABLE_WEBSOCKETS=ON \
+            ${{ matrix.config }}
+
+      - name: 'cmake configure log'
+        if: ${{ !cancelled() }}
+        run: cat bld/CMakeFiles/CMake*.yaml 2>/dev/null || true
+
+      - name: 'curl_config.h'
+        run: cat bld/lib/curl_config.h | grep -F '#define' | sort || true
+
+      - name: 'curl_config.h (full)'
+        run: cat bld/lib/curl_config.h || true
+
+      - name: 'cmake build'
+        timeout-minutes: 10
+        run: |
+          PATH="$(cygpath "${USERPROFILE}")/my-cache/${{ matrix.dir }}/bin:/c/msys64/usr/bin:$PATH"
+          cmake --build bld --config '${{ matrix.type }}' --parallel 5
+
+      - name: 'curl version'
+        timeout-minutes: 1
+        run: |
+          find . -name '*.exe' -o -name '*.dll' | grep -v '/examples/'
+          PATH="$PWD/bld/lib:$PATH"
           bld/src/curl.exe --disable --version
 
       - name: 'cmake build tests'
-        if: ${{ matrix.build == 'cmake' }}
+        if: ${{ matrix.tflags != 'skipall' }}
         timeout-minutes: 10
-        shell: msys2 {0}
         run: |
-          cmake --build bld --config '${{ matrix.type }}' --parallel 3 --target testdeps
+          PATH="$(cygpath "${USERPROFILE}")/my-cache/${{ matrix.dir }}/bin:/c/msys64/usr/bin:$PATH"
+          cmake --build bld --config '${{ matrix.type }}' --parallel 5 --target testdeps
 
       - name: 'cmake run tests'
-        if: ${{ matrix.build == 'cmake' && matrix.tflags != 'skip' }}
+        if: ${{ matrix.tflags != 'skipall' && matrix.tflags != 'skiprun' }}
         timeout-minutes: 40
-        shell: msys2 {0}
         run: |
-          export TFLAGS='-j14 ${{ matrix.tflags }}'
-          if [ -x "$(cygpath -u 'C:/msys64/usr/bin/curl.exe')" ]; then
-            TFLAGS+=" -ac $(cygpath -u 'C:/msys64/usr/bin/curl.exe')"
+          PATH="$(cygpath "${USERPROFILE}")/my-cache/${{ matrix.dir }}/bin:/c/msys64/usr/bin:$PATH"
+          export TFLAGS='-j14 !TFTP !MQTT !WebSockets ~FTP ${{ matrix.tflags }}'
+          if [ -x "$(cygpath "${SYSTEMROOT}/System32/curl.exe")" ]; then
+            TFLAGS+=" -ac $(cygpath "${SYSTEMROOT}/System32/curl.exe")"
+          fi
+          PATH="$PWD/bld/lib:$PATH"
+          cmake --build bld --config '${{ matrix.type }}' --target test-ci
+
+  msvc:
+    name: 'msvc, CM ${{ matrix.arch }}-${{ matrix.plat }} ${{ matrix.name }}'
+    runs-on: windows-latest
+    timeout-minutes: 55
+    defaults:
+      run:
+        shell: bash
+    env:
+      VCPKG_BINARY_SOURCES: 'clear;x-gha,readwrite'
+      VCPKG_DISABLE_METRICS: '1'
+    strategy:
+      matrix:
+        include:
+        - name: 'schannel U'
+          install: 'brotli zlib zstd libpsl nghttp2 libssh2[core,zlib] pkgconf gsasl'
+          arch: 'x64'
+          plat: 'windows'
+          type: 'Debug'
+          tflags: '~1516 ~2301 ~2302 ~2303 ~2307'
+          config: '-DENABLE_DEBUG=ON -DENABLE_UNICODE=ON  -DCURL_USE_SCHANNEL=ON  -DCURL_BROTLI=ON -DCURL_ZSTD=ON -DCURL_USE_LIBPSL=ON -DUSE_NGHTTP2=ON -DBUILD_SHARED_LIBS=OFF -DCURL_USE_LIBSSH2=ON -DUSE_WIN32_IDN=ON -DCURL_USE_GSASL=ON'
+        - name: 'openssl'
+          install: 'brotli zlib zstd libpsl nghttp2 nghttp3 openssl libssh2 pkgconf gsasl'
+          arch: 'x64'
+          plat: 'windows'
+          type: 'Debug'
+          tflags: '~1516 ~2301 ~2302 ~2303 ~2307'
+          config: '-DENABLE_DEBUG=ON -DENABLE_UNICODE=OFF -DCURL_USE_SCHANNEL=OFF -DCURL_BROTLI=ON -DCURL_ZSTD=ON -DCURL_USE_LIBPSL=ON -DUSE_NGHTTP2=ON -DBUILD_SHARED_LIBS=OFF -DCURL_USE_LIBSSH2=ON -DCURL_USE_OPENSSL=ON -DUSE_OPENSSL_QUIC=ON -DCURL_USE_GSASL=ON'
+        - name: 'openssl'
+          install: 'brotli zlib zstd        nghttp2 nghttp3 openssl libssh2'
+          arch: 'x64'
+          plat: 'uwp'
+          type: 'Debug'
+          tflags: 'skipall'
+          config: '-DENABLE_DEBUG=ON -DENABLE_UNICODE=OFF -DCURL_USE_SCHANNEL=OFF -DCURL_BROTLI=ON -DCURL_ZSTD=ON                      -DUSE_NGHTTP2=ON -DBUILD_SHARED_LIBS=OFF -DCURL_USE_LIBSSH2=ON -DCURL_USE_OPENSSL=ON -DUSE_OPENSSL_QUIC=ON'
+        - name: 'libressl'
+          install: 'brotli zlib zstd libpsl nghttp2 libressl libssh2[core,zlib]'
+          arch: 'x64'
+          plat: 'windows'
+          type: 'Debug'
+          tflags: '~1516 ~2301 ~2302 ~2303 ~2307'
+          config: '-DENABLE_DEBUG=ON -DENABLE_UNICODE=OFF -DCURL_USE_SCHANNEL=OFF -DCURL_BROTLI=ON -DCURL_ZSTD=ON -DCURL_USE_LIBPSL=ON -DUSE_NGHTTP2=ON -DBUILD_SHARED_LIBS=OFF -DCURL_USE_LIBSSH2=ON -DCURL_USE_OPENSSL=ON'
+        - name: 'boringssl-ECH'
+          install: 'brotli zlib zstd libpsl nghttp2 boringssl libssh2[core,zlib]'
+          arch: 'x64'
+          plat: 'windows'
+          type: 'Debug'
+          tflags: '~1516 ~2301 ~2302 ~2303 ~2307'
+          config: '-DENABLE_DEBUG=ON -DENABLE_UNICODE=OFF -DCURL_USE_SCHANNEL=OFF -DCURL_BROTLI=ON -DCURL_ZSTD=ON -DCURL_USE_LIBPSL=ON -DUSE_NGHTTP2=ON -DBUILD_SHARED_LIBS=OFF -DCURL_USE_LIBSSH2=ON -DCURL_USE_OPENSSL=ON -DUSE_HTTPSRR=ON -DUSE_ECH=ON'
+        - name: '!ssl'
+          install: 'brotli zlib zstd libpsl pkgconf libidn2 libssh'
+          arch: 'x64'
+          plat: 'windows'
+          type: 'Debug'
+          tflags: '~1516 ~2301 ~2302 ~2303 ~2307'
+          # WARNING: libssh uses hard-coded world-writable paths (/etc/..., ~/.ssh/) to
+          #          read its configuration from, making it vulnerable to attacks on
+          #          Windows. Do not use this component till there is a fix for these.
+          # https://github.com/curl/curl-for-win/blob/3951808deb04df9489ee17430f236ed54436f81a/libssh.sh#L6-L8
+          config: '-DENABLE_DEBUG=ON -DENABLE_UNICODE=OFF -DCURL_USE_SCHANNEL=OFF -DCURL_BROTLI=ON -DCURL_ZSTD=ON -DCURL_USE_LIBPSL=ON -DHTTP_ONLY=ON -DUSE_LIBIDN2=ON -DCURL_USE_LIBSSH2=OFF -DCURL_USE_LIBSSH=ON'
+        - name: 'wolfssl'
+          install: 'brotli zlib zstd libpsl nghttp2 wolfssl libssh2 pkgconf gsasl'
+          arch: 'x64'
+          plat: 'windows'
+          type: 'Debug'
+          tflags: '~1516'
+          config: '-DENABLE_DEBUG=ON -DENABLE_UNICODE=OFF -DCURL_USE_SCHANNEL=OFF -DCURL_BROTLI=ON -DCURL_ZSTD=ON -DCURL_USE_LIBPSL=ON -DUSE_NGHTTP2=ON -DBUILD_SHARED_LIBS=OFF -DCURL_USE_LIBSSH2=ON -DCURL_USE_WOLFSSL=ON -DCURL_USE_GSASL=ON'
+      fail-fast: false
+    steps:
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
+
+      - name: 'vcpkg cache setup'
+        uses: actions/github-script@v7
+        with:
+          script: |
+            core.exportVariable('ACTIONS_CACHE_URL', process.env.ACTIONS_CACHE_URL || '');
+            core.exportVariable('ACTIONS_RUNTIME_TOKEN', process.env.ACTIONS_RUNTIME_TOKEN || '');
+
+      - name: 'vcpkg versions'
+        timeout-minutes: 1
+        run: |
+          git -C "$VCPKG_INSTALLATION_ROOT" show --no-patch --format='%H %ai'
+          vcpkg version
+
+      - name: 'vcpkg build'
+        timeout-minutes: 35
+        run: vcpkg x-set-installed ${{ matrix.install }} '--triplet=${{ matrix.arch }}-${{ matrix.plat }}'
+
+      - name: 'cmake configure'
+        timeout-minutes: 5
+        run: |
+          if [[ '${{ matrix.install }}' = *'libressl'* ]]; then
+            # without this, CMake gets confused about the non-vcpkg OpenSSL
+            # installed on the runner and fails when linking.
+            options+=" -DOPENSSL_ROOT_DIR=$VCPKG_INSTALLATION_ROOT/installed/${{ matrix.arch }}-${{ matrix.plat }}"
+          fi
+          cmake -B bld ${options} \
+            "-DCMAKE_TOOLCHAIN_FILE=$VCPKG_INSTALLATION_ROOT/scripts/buildsystems/vcpkg.cmake" \
+            "-DVCPKG_INSTALLED_DIR=$VCPKG_INSTALLATION_ROOT/installed" \
+            '-DVCPKG_TARGET_TRIPLET=${{ matrix.arch }}-${{ matrix.plat }}' \
+            -DCMAKE_VS_GLOBALS=TrackFileAccess=false \
+            '-DCMAKE_BUILD_TYPE=${{ matrix.type }}' \
+            -DCMAKE_UNITY_BUILD=ON \
+            -DCURL_WERROR=ON \
+            -DBUILD_EXAMPLES=ON \
+            -DENABLE_WEBSOCKETS=ON \
+            -DCMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG= \
+            -DCMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE= \
+            ${{ matrix.config }}
+
+      - name: 'cmake configure log'
+        if: ${{ !cancelled() }}
+        run: cat bld/CMakeFiles/CMake*.yaml 2>/dev/null || true
+
+      - name: 'curl_config.h'
+        run: cat bld/lib/curl_config.h | grep -F '#define' | sort || true
+
+      - name: 'curl_config.h (full)'
+        run: cat bld/lib/curl_config.h || true
+
+      - name: 'cmake build'
+        timeout-minutes: 5
+        run: cmake --build bld --config '${{ matrix.type }}' --parallel 5
+
+      - name: 'curl version'
+        timeout-minutes: 5
+        run: |
+          find . -name '*.exe' -o -name '*.dll' | grep -v '/examples/'
+          if [ '${{ matrix.plat }}' != 'uwp' ]; then
+            PATH="$PWD/bld/lib:$VCPKG_INSTALLATION_ROOT/installed/${{ matrix.arch }}-${{ matrix.plat }}/bin:$PATH"
+            bld/src/curl.exe --disable --version
+          fi
+
+      - name: 'cmake build tests'
+        if: ${{ matrix.tflags != 'skipall' }}
+        timeout-minutes: 10
+        run: cmake --build bld --config '${{ matrix.type }}' --parallel 5 --target testdeps
+
+      - name: 'cmake run tests'
+        if: ${{ matrix.tflags != 'skipall' && matrix.tflags != 'skiprun' }}
+        timeout-minutes: 30
+        run: |
+          export TFLAGS='-j14 !TFTP !MQTT !WebSockets !SMTP ~FTP ${{ matrix.tflags }}'
+          if [[ '${{ matrix.config }}' = *'-DUSE_WIN32_IDN=ON'* ]]; then
+            TFLAGS+=' ~165'
+            if [[ '${{ matrix.config }}' != *'-DENABLE_UNICODE=ON'* ]]; then
+              TFLAGS+=' ~1448 ~2046 ~2047'
+            fi
+          elif [[ '${{ matrix.config }}' = *'-DUSE_LIBIDN2=ON'* ]]; then
+            TFLAGS+=' ~165 ~1448 ~2046 ~2047'
           fi
-          ls bld/lib/*.dll >/dev/null 2>&1 && cp -f -p bld/lib/*.dll bld/tests/libtest/
+          PATH="$PWD/bld/lib:$VCPKG_INSTALLATION_ROOT/installed/${{ matrix.arch }}-${{ matrix.plat }}/bin:$PATH"
           cmake --build bld --config '${{ matrix.type }}' --target test-ci
diff --git a/.github/workflows/wolfssl.yml b/.github/workflows/wolfssl.yml
index 9183a3a4c..c4156497e 100644
--- a/.github/workflows/wolfssl.yml
+++ b/.github/workflows/wolfssl.yml
@@ -14,7 +14,6 @@ on:
       - '**/CMakeLists.txt'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'CMake/**'
       - 'packages/**'
@@ -29,7 +28,6 @@ on:
       - '**/CMakeLists.txt'
       - '.azure-pipelines.yml'
       - '.circleci/**'
-      - '.cirrus.yml'
       - 'appveyor.*'
       - 'CMake/**'
       - 'packages/**'
@@ -45,7 +43,7 @@ concurrency:
 permissions: {}
 
 env:
-  MAKEFLAGS: -j 3
+  MAKEFLAGS: -j 5
 
 jobs:
   autotools:
@@ -73,7 +71,7 @@ jobs:
           sudo python3 -m pip install impacket
         name: 'install prereqs and impacket'
 
-      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
+      - uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
 
       - run: |
           source .github/scripts/VERSIONS
@@ -81,14 +79,14 @@ jobs:
           tar -xzf v$WOLFSSL_VER-stable.tar.gz
           cd wolfssl-$WOLFSSL_VER-stable
           ./autogen.sh
-          ./configure --enable-tls13 ${{ matrix.build.wolfssl-configure }} --enable-harden --prefix=$HOME/wssl
+          ./configure --disable-dependency-tracking --enable-tls13 ${{ matrix.build.wolfssl-configure }} --enable-harden --prefix=$HOME/wssl
           make install
         name: 'install wolfssl'
 
       - run: autoreconf -fi
         name: 'autoreconf'
 
-      - run: ./configure --enable-warnings --enable-werror ${{ matrix.build.configure }}
+      - run: ./configure --disable-dependency-tracking --enable-warnings --enable-werror ${{ matrix.build.configure }}
         name: 'configure'
 
       - run: make V=1
diff --git a/.mailmap b/.mailmap
index f36dc69f1..f87925149 100644
--- a/.mailmap
+++ b/.mailmap
@@ -108,3 +108,4 @@ Brad Harder <brad.harder@gmail.com>
 Derzsi DÃ¡niel <daniel@tohka.us>
 Michael Osipov <michael.osipov@siemens.com> <1983-01-06@gmx.net>
 Michael Osipov <michael.osipov@siemens.com> <michael-o@users.sf.net>
+Christian Weisgerber <naddy@mips.inka.de> <curl-library@lists.haxx.se>
diff --git a/.reuse/dep5 b/.reuse/dep5
deleted file mode 100644
index 0715ee38e..000000000
--- a/.reuse/dep5
+++ /dev/null
@@ -1,89 +0,0 @@
-Format: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
-Upstream-Name: curl
-Upstream-Contact: Daniel Stenberg <daniel@haxx.se>
-Source: https://curl.se
-
-# Tests
-Files: tests/data/test* tests/certs/* tests/stunnel.pem tests/valgrind.supp
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-# Docs in docs/
-Files: docs/FAQ docs/INSTALL docs/KNOWN_BUGS docs/MAIL-ETIQUETTE docs/THANKS docs/TODO docs/libcurl/symbols-in-versions docs/options-in-versions
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-# Windows
-Files: projects/Windows/*
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-Files: libcurl.def
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-# Single files we do not want to edit directly
-Files: CHANGES
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-Files: GIT-INFO.md
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-Files: RELEASE-NOTES
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-# checksrc control files
-Files: lib/.checksrc src/.checksrc docs/examples/.checksrc tests/libtest/.checksrc
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-Files: lib/libcurl.vers.in
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-Files: packages/OS400/README.OS400
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-Files: packages/vms/build_vms.com
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-Files: packages/vms/curl_release_note_start.txt
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-Files: packages/vms/curlmsg.sdl
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-Files: packages/vms/macro32_exactcase.patch
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-Files: packages/vms/readme
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-Files: plan9/README
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-Files: projects/wolfssl_override.props
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-Files: README
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-Files: renovate.json
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
-
-Files: .mailmap
-Copyright: Daniel Stenberg, <daniel@haxx.se>, et al.
-License: curl
diff --git a/CMake/CurlSymbolHiding.cmake b/CMake/CurlSymbolHiding.cmake
index 8289b4924..07f4fc0b6 100644
--- a/CMake/CurlSymbolHiding.cmake
+++ b/CMake/CurlSymbolHiding.cmake
@@ -26,9 +26,10 @@ include(CheckCSourceCompiles)
 option(CURL_HIDDEN_SYMBOLS "Set to ON to hide libcurl internal symbols (=hide all symbols that aren't officially external)." ON)
 mark_as_advanced(CURL_HIDDEN_SYMBOLS)
 
-if(WIN32 AND ENABLE_CURLDEBUG)
-  # We need to export internal debug functions (e.g. curl_dbg_*), so disable
-  # symbol hiding for debug builds.
+if(WIN32 AND (ENABLE_DEBUG OR ENABLE_CURLDEBUG))
+  # We need to export internal debug functions,
+  # e.g. curl_easy_perform_ev() or curl_dbg_*(),
+  # so disable symbol hiding for debug builds and for memory tracking.
   set(CURL_HIDDEN_SYMBOLS OFF)
 endif()
 
diff --git a/CMake/CurlTests.c b/CMake/CurlTests.c
index 483b9a218..f04abd79b 100644
--- a/CMake/CurlTests.c
+++ b/CMake/CurlTests.c
@@ -380,7 +380,7 @@ int main(void)
 #ifdef HAVE_BUILTIN_AVAILABLE
 int main(void)
 {
-  if(__builtin_available(macOS 10.12, *)) {}
+  if(__builtin_available(macOS 10.12, iOS 5.0, *)) {}
   return 0;
 }
 #endif
diff --git a/CMake/FindBearSSL.cmake b/CMake/FindBearSSL.cmake
index 56a064eac..653ca9dde 100644
--- a/CMake/FindBearSSL.cmake
+++ b/CMake/FindBearSSL.cmake
@@ -27,6 +27,6 @@ find_library(BEARSSL_LIBRARY bearssl)
 
 include(FindPackageHandleStandardArgs)
 find_package_handle_standard_args(BEARSSL DEFAULT_MSG
-    BEARSSL_INCLUDE_DIRS BEARSSL_LIBRARY)
+  BEARSSL_INCLUDE_DIRS BEARSSL_LIBRARY)
 
 mark_as_advanced(BEARSSL_INCLUDE_DIRS BEARSSL_LIBRARY)
diff --git a/CMake/FindBrotli.cmake b/CMake/FindBrotli.cmake
index 11ab7f825..7f316aaa1 100644
--- a/CMake/FindBrotli.cmake
+++ b/CMake/FindBrotli.cmake
@@ -29,15 +29,15 @@ find_library(BROTLICOMMON_LIBRARY NAMES brotlicommon)
 find_library(BROTLIDEC_LIBRARY NAMES brotlidec)
 
 find_package_handle_standard_args(Brotli
-    FOUND_VAR
-      BROTLI_FOUND
-    REQUIRED_VARS
-      BROTLIDEC_LIBRARY
-      BROTLICOMMON_LIBRARY
-      BROTLI_INCLUDE_DIR
-    FAIL_MESSAGE
-      "Could NOT find Brotli"
+  FOUND_VAR
+    BROTLI_FOUND
+  REQUIRED_VARS
+    BROTLIDEC_LIBRARY
+    BROTLICOMMON_LIBRARY
+    BROTLI_INCLUDE_DIR
+  FAIL_MESSAGE
+    "Could NOT find Brotli"
 )
 
 set(BROTLI_INCLUDE_DIRS ${BROTLI_INCLUDE_DIR})
-set(BROTLI_LIBRARIES ${BROTLICOMMON_LIBRARY} ${BROTLIDEC_LIBRARY})
+set(BROTLI_LIBRARIES ${BROTLIDEC_LIBRARY} ${BROTLICOMMON_LIBRARY})
diff --git a/CMake/FindCARES.cmake b/CMake/FindCARES.cmake
index fa7589118..e82b1de4a 100644
--- a/CMake/FindCARES.cmake
+++ b/CMake/FindCARES.cmake
@@ -39,7 +39,7 @@ find_library(CARES_LIBRARY
 
 include(FindPackageHandleStandardArgs)
 find_package_handle_standard_args(CARES
-    REQUIRED_VARS CARES_LIBRARY CARES_INCLUDE_DIR)
+  REQUIRED_VARS CARES_LIBRARY CARES_INCLUDE_DIR)
 
 mark_as_advanced(
   CARES_LIBRARY
diff --git a/CMake/FindGSS.cmake b/CMake/FindGSS.cmake
index b244e610e..9061e6c85 100644
--- a/CMake/FindGSS.cmake
+++ b/CMake/FindGSS.cmake
@@ -45,8 +45,8 @@ include(CheckIncludeFiles)
 include(CheckTypeSize)
 
 set(_GSS_ROOT_HINTS
-    "${GSS_ROOT_DIR}"
-    "$ENV{GSS_ROOT_DIR}"
+  "${GSS_ROOT_DIR}"
+  "$ENV{GSS_ROOT_DIR}"
 )
 
 # try to find library using system pkg-config if user didn't specify root dir
@@ -62,30 +62,30 @@ endif()
 
 if(NOT _GSS_FOUND) #not found by pkg-config. Let's take more traditional approach.
   find_file(_GSS_CONFIGURE_SCRIPT
-      NAMES
-          "krb5-config"
-      HINTS
-          ${_GSS_ROOT_HINTS}
-      PATH_SUFFIXES
-          bin
-      NO_CMAKE_PATH
-      NO_CMAKE_ENVIRONMENT_PATH
+    NAMES
+      "krb5-config"
+    HINTS
+      ${_GSS_ROOT_HINTS}
+    PATH_SUFFIXES
+      bin
+    NO_CMAKE_PATH
+    NO_CMAKE_ENVIRONMENT_PATH
   )
 
   # if not found in user-supplied directories, maybe system knows better
   find_file(_GSS_CONFIGURE_SCRIPT
-      NAMES
-          "krb5-config"
-      PATH_SUFFIXES
-          bin
+    NAMES
+      "krb5-config"
+    PATH_SUFFIXES
+      bin
   )
 
   if(_GSS_CONFIGURE_SCRIPT)
     execute_process(
-          COMMAND ${_GSS_CONFIGURE_SCRIPT} "--cflags" "gssapi"
-          OUTPUT_VARIABLE _GSS_CFLAGS
-          RESULT_VARIABLE _GSS_CONFIGURE_FAILED
-          OUTPUT_STRIP_TRAILING_WHITESPACE
+      COMMAND ${_GSS_CONFIGURE_SCRIPT} "--cflags" "gssapi"
+      OUTPUT_VARIABLE _GSS_CFLAGS
+      RESULT_VARIABLE _GSS_CONFIGURE_FAILED
+      OUTPUT_STRIP_TRAILING_WHITESPACE
       )
     message(STATUS "CFLAGS: ${_GSS_CFLAGS}")
     if(NOT _GSS_CONFIGURE_FAILED) # 0 means success
@@ -105,10 +105,10 @@ if(NOT _GSS_FOUND) #not found by pkg-config. Let's take more traditional approac
     endif()
 
     execute_process(
-        COMMAND ${_GSS_CONFIGURE_SCRIPT} "--libs" "gssapi"
-        OUTPUT_VARIABLE _GSS_LIB_FLAGS
-        RESULT_VARIABLE _GSS_CONFIGURE_FAILED
-        OUTPUT_STRIP_TRAILING_WHITESPACE
+      COMMAND ${_GSS_CONFIGURE_SCRIPT} "--libs" "gssapi"
+      OUTPUT_VARIABLE _GSS_LIB_FLAGS
+      RESULT_VARIABLE _GSS_CONFIGURE_FAILED
+      OUTPUT_STRIP_TRAILING_WHITESPACE
     )
     message(STATUS "LDFLAGS: ${_GSS_LIB_FLAGS}")
 
@@ -132,10 +132,10 @@ if(NOT _GSS_FOUND) #not found by pkg-config. Let's take more traditional approac
     endif()
 
     execute_process(
-        COMMAND ${_GSS_CONFIGURE_SCRIPT} "--version"
-        OUTPUT_VARIABLE _GSS_VERSION
-        RESULT_VARIABLE _GSS_CONFIGURE_FAILED
-        OUTPUT_STRIP_TRAILING_WHITESPACE
+      COMMAND ${_GSS_CONFIGURE_SCRIPT} "--version"
+      OUTPUT_VARIABLE _GSS_VERSION
+      RESULT_VARIABLE _GSS_CONFIGURE_FAILED
+      OUTPUT_STRIP_TRAILING_WHITESPACE
     )
 
     # older versions may not have the "--version" parameter. In this case we just don't care.
@@ -144,10 +144,10 @@ if(NOT _GSS_FOUND) #not found by pkg-config. Let's take more traditional approac
     endif()
 
     execute_process(
-        COMMAND ${_GSS_CONFIGURE_SCRIPT} "--vendor"
-        OUTPUT_VARIABLE _GSS_VENDOR
-        RESULT_VARIABLE _GSS_CONFIGURE_FAILED
-        OUTPUT_STRIP_TRAILING_WHITESPACE
+      COMMAND ${_GSS_CONFIGURE_SCRIPT} "--vendor"
+      OUTPUT_VARIABLE _GSS_VENDOR
+      RESULT_VARIABLE _GSS_CONFIGURE_FAILED
+      OUTPUT_STRIP_TRAILING_WHITESPACE
     )
 
     # older versions may not have the "--vendor" parameter. In this case we just don't care.
@@ -164,13 +164,13 @@ if(NOT _GSS_FOUND) #not found by pkg-config. Let's take more traditional approac
   else() # either there is no config script or we are on a platform that doesn't provide one (Windows?)
 
     find_path(_GSS_INCLUDE_DIR
-        NAMES
-            "gssapi/gssapi.h"
-        HINTS
-            ${_GSS_ROOT_HINTS}
-        PATH_SUFFIXES
-            include
-            inc
+      NAMES
+        "gssapi/gssapi.h"
+      HINTS
+        ${_GSS_ROOT_HINTS}
+      PATH_SUFFIXES
+        include
+        inc
     )
 
     if(_GSS_INCLUDE_DIR) #jay, we've found something
@@ -193,13 +193,13 @@ if(NOT _GSS_FOUND) #not found by pkg-config. Let's take more traditional approac
     else()
       # I'm not convinced if this is the right way but this is what autotools do at the moment
       find_path(_GSS_INCLUDE_DIR
-          NAMES
-              "gssapi.h"
-          HINTS
-              ${_GSS_ROOT_HINTS}
-          PATH_SUFFIXES
-              include
-              inc
+        NAMES
+          "gssapi.h"
+        HINTS
+          ${_GSS_ROOT_HINTS}
+        PATH_SUFFIXES
+          include
+          inc
       )
 
       if(_GSS_INCLUDE_DIR)
@@ -240,12 +240,12 @@ if(NOT _GSS_FOUND) #not found by pkg-config. Let's take more traditional approac
       endif()
 
       find_library(_GSS_LIBRARIES
-          NAMES
-              ${_GSS_LIBNAME}
-          HINTS
-              ${_GSS_LIBDIR_HINTS}
-          PATH_SUFFIXES
-              ${_GSS_LIBDIR_SUFFIXES}
+        NAMES
+          ${_GSS_LIBNAME}
+        HINTS
+          ${_GSS_LIBDIR_HINTS}
+        PATH_SUFFIXES
+          ${_GSS_LIBDIR_SUFFIXES}
       )
 
     endif()
@@ -301,12 +301,12 @@ include(FindPackageHandleStandardArgs)
 set(_GSS_REQUIRED_VARS GSS_LIBRARIES GSS_FLAVOUR)
 
 find_package_handle_standard_args(GSS
-    REQUIRED_VARS
-        ${_GSS_REQUIRED_VARS}
-    VERSION_VAR
-        GSS_VERSION
-    FAIL_MESSAGE
-        "Could NOT find GSS, try to set the path to GSS root folder in the system variable GSS_ROOT_DIR"
+  REQUIRED_VARS
+    ${_GSS_REQUIRED_VARS}
+  VERSION_VAR
+    GSS_VERSION
+  FAIL_MESSAGE
+    "Could NOT find GSS, try to set the path to GSS root folder in the system variable GSS_ROOT_DIR"
 )
 
 mark_as_advanced(GSS_INCLUDE_DIR GSS_LIBRARIES)
diff --git a/CMake/FindLibPSL.cmake b/CMake/FindLibPSL.cmake
index e3bd68d1d..9ad4bc639 100644
--- a/CMake/FindLibPSL.cmake
+++ b/CMake/FindLibPSL.cmake
@@ -39,7 +39,7 @@ endif()
 
 include(FindPackageHandleStandardArgs)
 find_package_handle_standard_args(LibPSL
-    REQUIRED_VARS LIBPSL_LIBRARY LIBPSL_INCLUDE_DIR
-    VERSION_VAR LIBPSL_VERSION)
+  REQUIRED_VARS LIBPSL_LIBRARY LIBPSL_INCLUDE_DIR
+  VERSION_VAR LIBPSL_VERSION)
 
 mark_as_advanced(LIBPSL_INCLUDE_DIR LIBPSL_LIBRARY)
diff --git a/CMake/FindLibSSH2.cmake b/CMake/FindLibSSH2.cmake
index a0c251ae3..3466b6bfc 100644
--- a/CMake/FindLibSSH2.cmake
+++ b/CMake/FindLibSSH2.cmake
@@ -39,7 +39,7 @@ endif()
 
 include(FindPackageHandleStandardArgs)
 find_package_handle_standard_args(LibSSH2
-    REQUIRED_VARS LIBSSH2_LIBRARY LIBSSH2_INCLUDE_DIR
-    VERSION_VAR LIBSSH2_VERSION)
+  REQUIRED_VARS LIBSSH2_LIBRARY LIBSSH2_INCLUDE_DIR
+  VERSION_VAR LIBSSH2_VERSION)
 
 mark_as_advanced(LIBSSH2_INCLUDE_DIR LIBSSH2_LIBRARY)
diff --git a/CMake/FindMbedTLS.cmake b/CMake/FindMbedTLS.cmake
index 814bd97da..7692a2587 100644
--- a/CMake/FindMbedTLS.cmake
+++ b/CMake/FindMbedTLS.cmake
@@ -31,6 +31,6 @@ set(MBEDTLS_LIBRARIES "${MBEDTLS_LIBRARY}" "${MBEDX509_LIBRARY}" "${MBEDCRYPTO_L
 
 include(FindPackageHandleStandardArgs)
 find_package_handle_standard_args(MbedTLS DEFAULT_MSG
-    MBEDTLS_INCLUDE_DIRS MBEDTLS_LIBRARY MBEDX509_LIBRARY MBEDCRYPTO_LIBRARY)
+  MBEDTLS_INCLUDE_DIRS MBEDTLS_LIBRARY MBEDX509_LIBRARY MBEDCRYPTO_LIBRARY)
 
 mark_as_advanced(MBEDTLS_INCLUDE_DIRS MBEDTLS_LIBRARY MBEDX509_LIBRARY MBEDCRYPTO_LIBRARY)
diff --git a/CMake/FindNGHTTP2.cmake b/CMake/FindNGHTTP2.cmake
index d3528cb27..88ac03741 100644
--- a/CMake/FindNGHTTP2.cmake
+++ b/CMake/FindNGHTTP2.cmake
@@ -28,11 +28,11 @@ find_path(NGHTTP2_INCLUDE_DIR "nghttp2/nghttp2.h")
 find_library(NGHTTP2_LIBRARY NAMES nghttp2 nghttp2_static)
 
 find_package_handle_standard_args(NGHTTP2
-    FOUND_VAR
-      NGHTTP2_FOUND
-    REQUIRED_VARS
-      NGHTTP2_LIBRARY
-      NGHTTP2_INCLUDE_DIR
+  FOUND_VAR
+    NGHTTP2_FOUND
+  REQUIRED_VARS
+    NGHTTP2_LIBRARY
+    NGHTTP2_INCLUDE_DIR
 )
 
 set(NGHTTP2_INCLUDE_DIRS ${NGHTTP2_INCLUDE_DIR})
diff --git a/CMake/FindNettle.cmake b/CMake/FindNettle.cmake
new file mode 100644
index 000000000..96d7d6f6a
--- /dev/null
+++ b/CMake/FindNettle.cmake
@@ -0,0 +1,75 @@
+#***************************************************************************
+#                                  _   _ ____  _
+#  Project                     ___| | | |  _ \| |
+#                             / __| | | | |_) | |
+#                            | (__| |_| |  _ <| |___
+#                             \___|\___/|_| \_\_____|
+#
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+#
+# This software is licensed as described in the file COPYING, which
+# you should have received as part of this distribution. The terms
+# are also available at https://curl.se/docs/copyright.html.
+#
+# You may opt to use, copy, modify, merge, publish, distribute and/or sell
+# copies of the Software, and permit persons to whom the Software is
+# furnished to do so, under the terms of the COPYING file.
+#
+# This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+# KIND, either express or implied.
+#
+# SPDX-License-Identifier: curl
+#
+###########################################################################
+# - Try to find the nettle library
+# Once done this will define
+#
+# NETTLE_FOUND - system has nettle
+# NETTLE_INCLUDE_DIRS - nettle include directories
+# NETTLE_LIBRARIES - nettle library names
+
+if(UNIX)
+  find_package(PkgConfig QUIET)
+  pkg_check_modules(NETTLE "nettle")
+endif()
+
+if(NETTLE_FOUND)
+  set(NETTLE_LIBRARIES ${NETTLE_LINK_LIBRARIES})
+else()
+  find_path(NETTLE_INCLUDE_DIR NAMES "nettle/sha2.h")
+  find_library(NETTLE_LIBRARY NAMES "nettle")
+
+  if(NETTLE_INCLUDE_DIR)
+    if(EXISTS "${NETTLE_INCLUDE_DIR}/nettle/version.h")
+      set(_version_regex_major "^#define[ \t]+NETTLE_VERSION_MAJOR[ \t]+([0-9]+).*")
+      set(_version_regex_minor "^#define[ \t]+NETTLE_VERSION_MINOR[ \t]+([0-9]+).*")
+      file(STRINGS "${NETTLE_INCLUDE_DIR}/nettle/version.h"
+        _version_major REGEX "${_version_regex_major}")
+      file(STRINGS "${NETTLE_INCLUDE_DIR}/nettle/version.h"
+        _version_minor REGEX "${_version_regex_minor}")
+      string(REGEX REPLACE "${_version_regex_major}" "\\1" _version_major "${_version_major}")
+      string(REGEX REPLACE "${_version_regex_minor}" "\\1" _version_minor "${_version_minor}")
+      unset(_version_regex_major)
+      unset(_version_regex_minor)
+      set(NETTLE_VERSION "${_version_major}.${_version_minor}")
+      unset(_version_major)
+      unset(_version_minor)
+    else()
+      set(NETTLE_VERSION "0.0")
+    endif()
+  endif()
+
+  include(FindPackageHandleStandardArgs)
+  find_package_handle_standard_args("nettle"
+    REQUIRED_VARS
+      NETTLE_INCLUDE_DIR
+      NETTLE_LIBRARY
+    VERSION_VAR NETTLE_VERSION)
+
+  if(NETTLE_FOUND)
+    set(NETTLE_INCLUDE_DIRS ${NETTLE_INCLUDE_DIR})
+    set(NETTLE_LIBRARIES    ${NETTLE_LIBRARY})
+  endif()
+
+  mark_as_advanced(NETTLE_INCLUDE_DIR NETTLE_LIBRARY)
+endif()
diff --git a/CMake/FindWolfSSL.cmake b/CMake/FindWolfSSL.cmake
index d67c0eb24..7336c8f4d 100644
--- a/CMake/FindWolfSSL.cmake
+++ b/CMake/FindWolfSSL.cmake
@@ -21,16 +21,40 @@
 # SPDX-License-Identifier: curl
 #
 ###########################################################################
-find_path(WolfSSL_INCLUDE_DIR NAMES wolfssl/ssl.h)
-find_library(WolfSSL_LIBRARY NAMES wolfssl)
-mark_as_advanced(WolfSSL_INCLUDE_DIR WolfSSL_LIBRARY)
+
+find_package(PkgConfig QUIET)
+pkg_check_modules(PC_WOLFSSL QUIET "wolfssl")
+
+find_path(WolfSSL_INCLUDE_DIR
+  NAMES "wolfssl/ssl.h"
+  HINTS ${PC_WOLFSSL_INCLUDE_DIRS}
+)
+
+find_library(WolfSSL_LIBRARY
+  NAMES "wolfssl"
+  HINTS ${PC_WOLFSSL_LIBRARY_DIRS}
+)
+
+if(WolfSSL_INCLUDE_DIR)
+  set(_version_regex "^#define[ \t]+LIBWOLFSSL_VERSION_STRING[ \t]+\"([^\"]+)\".*")
+  file(STRINGS "${WolfSSL_INCLUDE_DIR}/wolfssl/version.h"
+    WolfSSL_VERSION REGEX "${_version_regex}")
+  string(REGEX REPLACE "${_version_regex}" "\\1"
+    WolfSSL_VERSION "${WolfSSL_VERSION}")
+  unset(_version_regex)
+endif()
 
 include(FindPackageHandleStandardArgs)
 find_package_handle_standard_args(WolfSSL
-  REQUIRED_VARS WolfSSL_INCLUDE_DIR WolfSSL_LIBRARY
-  )
+  REQUIRED_VARS
+    WolfSSL_INCLUDE_DIR
+    WolfSSL_LIBRARY
+  VERSION_VAR WolfSSL_VERSION
+)
 
 if(WolfSSL_FOUND)
   set(WolfSSL_INCLUDE_DIRS ${WolfSSL_INCLUDE_DIR})
-  set(WolfSSL_LIBRARIES ${WolfSSL_LIBRARY})
+  set(WolfSSL_LIBRARIES    ${WolfSSL_LIBRARY})
 endif()
+
+mark_as_advanced(WolfSSL_INCLUDE_DIR WolfSSL_LIBRARY)
diff --git a/CMake/OtherTests.cmake b/CMake/OtherTests.cmake
index 7701c0ee9..2fddb867c 100644
--- a/CMake/OtherTests.cmake
+++ b/CMake/OtherTests.cmake
@@ -137,7 +137,7 @@ if(NOT DEFINED HAVE_GETADDRINFO_THREADSAFE)
     #ifdef h_errno
       return 0;
     #else
-      force compilation error
+      #error force compilation error
     #endif
     }" HAVE_H_ERRNO)
 
@@ -158,7 +158,7 @@ if(NOT DEFINED HAVE_GETADDRINFO_THREADSAFE)
         #elif defined(_XOPEN_SOURCE) && (_XOPEN_SOURCE >= 700)
           return 0;
         #else
-          force compilation error
+          #error force compilation error
         #endif
         }" HAVE_H_ERRNO_SBS_ISSUE_7)
     endif()
diff --git a/CMake/PickyWarnings.cmake b/CMake/PickyWarnings.cmake
index d1183fe39..96e45f0e8 100644
--- a/CMake/PickyWarnings.cmake
+++ b/CMake/PickyWarnings.cmake
@@ -33,6 +33,16 @@ if(CURL_WERROR AND
   set(WPICKY "${WPICKY} -pedantic-errors")
 endif()
 
+if(APPLE AND
+   (CMAKE_C_COMPILER_ID STREQUAL "Clang"      AND NOT CMAKE_C_COMPILER_VERSION VERSION_LESS 3.6) OR
+   (CMAKE_C_COMPILER_ID STREQUAL "AppleClang" AND NOT CMAKE_C_COMPILER_VERSION VERSION_LESS 6.3))
+  set(WPICKY "${WPICKY} -Werror=partial-availability")  # clang 3.6  appleclang 6.3
+endif()
+
+if(CMAKE_COMPILER_IS_GNUCC OR CMAKE_C_COMPILER_ID MATCHES "Clang")
+  set(WPICKY "${WPICKY} -Werror-implicit-function-declaration")  # clang 1.0  gcc 2.95
+endif()
+
 if(PICKY_COMPILER)
   if(CMAKE_COMPILER_IS_GNUCC OR CMAKE_C_COMPILER_ID MATCHES "Clang")
 
diff --git a/CMake/Platforms/WindowsCache.cmake b/CMake/Platforms/WindowsCache.cmake
index 082154ff9..5346f595e 100644
--- a/CMake/Platforms/WindowsCache.cmake
+++ b/CMake/Platforms/WindowsCache.cmake
@@ -88,6 +88,7 @@ set(HAVE_GETPWUID_R 0)
 set(HAVE_STRERROR_R 0)
 set(HAVE_SIGINTERRUPT 0)
 set(HAVE_PIPE 0)
+set(HAVE_EVENTFD 0)
 set(HAVE_IF_NAMETOINDEX 0)
 set(HAVE_GETRLIMIT 0)
 set(HAVE_SETRLIMIT 0)
@@ -121,6 +122,7 @@ set(HAVE_POLL_H 0)
 set(HAVE_POLL_FINE 0)
 set(HAVE_PWD_H 0)
 set(HAVE_STRINGS_H 0)  # mingw-w64 has it (wrapper to string.h)
+set(HAVE_SYS_EVENTFD_H 0)
 set(HAVE_SYS_FILIO_H 0)
 set(HAVE_SYS_WAIT_H 0)
 set(HAVE_SYS_IOCTL_H 0)
@@ -171,7 +173,6 @@ set(HAVE_IOCTLSOCKET_FIONBIO 1)
 set(HAVE_IOCTL_FIONBIO 0)
 set(HAVE_SETSOCKOPT_SO_NONBLOCK 0)
 set(HAVE_POSIX_STRERROR_R 0)
-set(HAVE_BUILTIN_AVAILABLE 0)
 set(HAVE_MSG_NOSIGNAL 0)
 set(HAVE_STRUCT_TIMEVAL 1)
 set(HAVE_STRUCT_SOCKADDR_STORAGE 1)
diff --git a/CMake/curl-config.cmake.in b/CMake/curl-config.cmake.in
index 9adb96e0a..2ce8625ef 100644
--- a/CMake/curl-config.cmake.in
+++ b/CMake/curl-config.cmake.in
@@ -38,3 +38,7 @@ check_required_components("@PROJECT_NAME@")
 if(NOT TARGET @PROJECT_NAME@::libcurl)
   add_library(@PROJECT_NAME@::libcurl ALIAS @PROJECT_NAME@::@LIB_SELECTED@)
 endif()
+
+# For compatibility with CMake's FindCURL.cmake
+set(CURL_LIBRARIES @PROJECT_NAME@::libcurl)
+set_and_check(CURL_INCLUDE_DIRS "@PACKAGE_CMAKE_INSTALL_INCLUDEDIR@")
diff --git a/CMakeLists.txt b/CMakeLists.txt
index c3525d3fc..580cc4357 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -64,13 +64,13 @@ string(REGEX REPLACE "[^0]+0x" "" CURL_VERSION_NUM ${CURL_VERSION_NUM})
 
 
 # Setup package meta-data
-# SET(PACKAGE "curl")
+# set(PACKAGE "curl")
 message(STATUS "curl version=[${CURL_VERSION}]")
-# SET(PACKAGE_TARNAME "curl")
-# SET(PACKAGE_NAME "curl")
-# SET(PACKAGE_VERSION "-")
-# SET(PACKAGE_STRING "curl-")
-# SET(PACKAGE_BUGREPORT "a suitable curl mailing list => https://curl.se/mail/")
+# set(PACKAGE_TARNAME "curl")
+# set(PACKAGE_NAME "curl")
+# set(PACKAGE_VERSION "-")
+# set(PACKAGE_STRING "curl-")
+# set(PACKAGE_BUGREPORT "a suitable curl mailing list => https://curl.se/mail/")
 set(OPERATING_SYSTEM "${CMAKE_SYSTEM_NAME}")
 if(CMAKE_C_COMPILER_TARGET)
   set(OS "\"${CMAKE_C_COMPILER_TARGET}\"")
@@ -110,18 +110,16 @@ endif()
 option(CURL_LTO "Turn on compiler Link Time Optimizations" OFF)
 
 cmake_dependent_option(ENABLE_THREADED_RESOLVER "Set to ON to enable threaded DNS lookup"
-        ON "NOT ENABLE_ARES"
-        OFF)
-
-option(ENABLE_DEBUG "Set to ON to enable curl debug features" OFF)
-option(ENABLE_CURLDEBUG "Set to ON to build with TrackMemory feature enabled" OFF)
+  ON "NOT ENABLE_ARES"
+  OFF)
 
 include(PickyWarnings)
 
+option(ENABLE_DEBUG "Set to ON to enable curl debug features" OFF)
+option(ENABLE_CURLDEBUG "Set to ON to build with TrackMemory feature enabled" ${ENABLE_DEBUG})
+
 if(ENABLE_DEBUG)
-  # DEBUGBUILD will be defined only for Debug builds
-  set_property(DIRECTORY APPEND PROPERTY COMPILE_DEFINITIONS $<$<CONFIG:Debug>:DEBUGBUILD>)
-  set(ENABLE_CURLDEBUG ON)
+  set_property(DIRECTORY APPEND PROPERTY COMPILE_DEFINITIONS DEBUGBUILD)
 endif()
 
 if(ENABLE_CURLDEBUG)
@@ -161,11 +159,13 @@ endif()
 
 # initialize CURL_LIBS
 set(CURL_LIBS "")
+set(LIBCURL_PC_REQUIRES_PRIVATE "")
 
 if(ENABLE_ARES)
   set(USE_ARES 1)
   find_package(CARES REQUIRED)
   list(APPEND CURL_LIBS ${CARES_LIBRARY})
+  list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "libcares")
 endif()
 
 include(CurlSymbolHiding)
@@ -278,6 +278,10 @@ if(HTTP_ONLY)
   set(CURL_DISABLE_TFTP ON)
 endif()
 
+if(WINDOWS_STORE)
+  set(CURL_DISABLE_TELNET ON)  # telnet code needs fixing to compile for UWP.
+endif()
+
 option(ENABLE_IPV6 "Define if you want to enable IPv6 support" ON)
 mark_as_advanced(ENABLE_IPV6)
 if(ENABLE_IPV6 AND NOT WIN32)
@@ -293,7 +297,7 @@ if(ENABLE_IPV6 AND NOT WIN32)
         CACHE BOOL "Define if you want to enable IPv6 support" FORCE)
   endif()
 
-  if(CMAKE_SYSTEM_NAME STREQUAL "Darwin" AND NOT ENABLE_ARES)
+  if(APPLE AND NOT ENABLE_ARES)
     set(use_core_foundation_and_core_services ON)
 
     find_library(SYSTEMCONFIGURATION_FRAMEWORK "SystemConfiguration")
@@ -422,8 +426,8 @@ endif()
 
 if(CURL_USE_SCHANNEL)
   set(SSL_ENABLED ON)
-  set(USE_SCHANNEL ON) # Windows native SSL/TLS support
-  set(USE_WINDOWS_SSPI ON) # CURL_USE_SCHANNEL implies CURL_WINDOWS_SSPI
+  set(USE_SCHANNEL ON)  # Windows native SSL/TLS support
+  set(USE_WINDOWS_SSPI ON)  # CURL_USE_SCHANNEL implies CURL_WINDOWS_SSPI
 
   if(CURL_DEFAULT_SSL_BACKEND AND CURL_DEFAULT_SSL_BACKEND STREQUAL "schannel")
     set(valid_default_ssl_backend TRUE)
@@ -461,7 +465,7 @@ if(use_core_foundation_and_core_services)
     message(FATAL_ERROR "CoreServices framework not found")
   endif()
 
-  list(APPEND CURL_LIBS "-framework CoreFoundation -framework CoreServices")
+  list(APPEND CURL_LIBS "-framework CoreFoundation" "-framework CoreServices")
 endif()
 
 if(CURL_USE_OPENSSL)
@@ -470,7 +474,7 @@ if(CURL_USE_OPENSSL)
   set(USE_OPENSSL ON)
 
   # Depend on OpenSSL via imported targets if supported by the running
-  # version of CMake.  This allows our dependents to get our dependencies
+  # version of CMake. This allows our dependents to get our dependencies
   # transitively.
   if(NOT CMAKE_VERSION VERSION_LESS 3.4)
     list(APPEND CURL_LIBS OpenSSL::SSL OpenSSL::Crypto)
@@ -478,10 +482,12 @@ if(CURL_USE_OPENSSL)
     list(APPEND CURL_LIBS ${OPENSSL_LIBRARIES})
     include_directories(${OPENSSL_INCLUDE_DIR})
   endif()
+  list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "openssl")
 
   if(CURL_DEFAULT_SSL_BACKEND AND CURL_DEFAULT_SSL_BACKEND STREQUAL "openssl")
     set(valid_default_ssl_backend TRUE)
   endif()
+  set(curl_ca_bundle_supported TRUE)
 
   set(CMAKE_REQUIRED_INCLUDES ${OPENSSL_INCLUDE_DIR})
   if(NOT DEFINED HAVE_BORINGSSL)
@@ -497,11 +503,13 @@ if(CURL_USE_MBEDTLS)
   set(SSL_ENABLED ON)
   set(USE_MBEDTLS ON)
   list(APPEND CURL_LIBS ${MBEDTLS_LIBRARIES})
+  list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "mbedtls")
   include_directories(${MBEDTLS_INCLUDE_DIRS})
 
   if(CURL_DEFAULT_SSL_BACKEND AND CURL_DEFAULT_SSL_BACKEND STREQUAL "mbedtls")
     set(valid_default_ssl_backend TRUE)
   endif()
+  set(curl_ca_bundle_supported TRUE)
 endif()
 
 if(CURL_USE_BEARSSL)
@@ -514,6 +522,7 @@ if(CURL_USE_BEARSSL)
   if(CURL_DEFAULT_SSL_BACKEND AND CURL_DEFAULT_SSL_BACKEND STREQUAL "bearssl")
     set(valid_default_ssl_backend TRUE)
   endif()
+  set(curl_ca_bundle_supported TRUE)
 endif()
 
 if(CURL_USE_WOLFSSL)
@@ -521,23 +530,28 @@ if(CURL_USE_WOLFSSL)
   set(SSL_ENABLED ON)
   set(USE_WOLFSSL ON)
   list(APPEND CURL_LIBS ${WolfSSL_LIBRARIES})
+  list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "wolfssl")
   include_directories(${WolfSSL_INCLUDE_DIRS})
 
   if(CURL_DEFAULT_SSL_BACKEND AND CURL_DEFAULT_SSL_BACKEND STREQUAL "wolfssl")
     set(valid_default_ssl_backend TRUE)
   endif()
+  set(curl_ca_bundle_supported TRUE)
 endif()
 
 if(CURL_USE_GNUTLS)
   find_package(GnuTLS REQUIRED)
+  find_package(nettle REQUIRED)
   set(SSL_ENABLED ON)
   set(USE_GNUTLS ON)
-  list(APPEND CURL_LIBS ${GNUTLS_LIBRARIES} "nettle")
-  include_directories(${GNUTLS_INCLUDE_DIRS})
+  list(APPEND CURL_LIBS ${GNUTLS_LIBRARIES} ${NETTLE_LIBRARIES})
+  list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "gnutls" "nettle")
+  include_directories(${GNUTLS_INCLUDE_DIRS} ${NETTLE_INCLUDE_DIRS})
 
   if(CURL_DEFAULT_SSL_BACKEND AND CURL_DEFAULT_SSL_BACKEND STREQUAL "gnutls")
     set(valid_default_ssl_backend TRUE)
   endif()
+  set(curl_ca_bundle_supported TRUE)
 
   if(NOT DEFINED HAVE_GNUTLS_SRP AND NOT CURL_DISABLE_SRP)
     cmake_push_check_state()
@@ -571,6 +585,7 @@ if(ZLIB_FOUND)
     list(APPEND CURL_LIBS ${ZLIB_LIBRARIES})
     include_directories(${ZLIB_INCLUDE_DIRS})
   endif()
+  list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "zlib")
   list(APPEND CMAKE_REQUIRED_INCLUDES ${ZLIB_INCLUDE_DIRS})
 endif()
 
@@ -580,8 +595,8 @@ if(CURL_BROTLI)
   find_package(Brotli REQUIRED)
   if(BROTLI_FOUND)
     set(HAVE_BROTLI ON)
-    set(CURL_LIBS "${BROTLI_LIBRARIES};${CURL_LIBS}")  # For 'ld' linker. Emulate `list(PREPEND ...)` to stay compatible with <v3.15 CMake.
     list(APPEND CURL_LIBS ${BROTLI_LIBRARIES})
+    list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "libbrotlidec")
     include_directories(${BROTLI_INCLUDE_DIRS})
     list(APPEND CMAKE_REQUIRED_INCLUDES ${BROTLI_INCLUDE_DIRS})
   endif()
@@ -594,6 +609,7 @@ if(CURL_ZSTD)
   if(Zstd_FOUND AND NOT Zstd_VERSION VERSION_LESS "1.0.0")
     set(HAVE_ZSTD ON)
     list(APPEND CURL_LIBS ${Zstd_LIBRARIES})
+    list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "libzstd")
     include_directories(${Zstd_INCLUDE_DIRS})
   else()
     message(WARNING "zstd v1.0.0 or newer is required, disabling zstd support.")
@@ -646,6 +662,11 @@ macro(openssl_check_quic)
   endif()
 endmacro()
 
+if(USE_WOLFSSL)
+  openssl_check_symbol_exists(wolfSSL_DES_ecb_encrypt "wolfssl/openssl/des.h" HAVE_WOLFSSL_DES_ECB_ENCRYPT "")
+  openssl_check_symbol_exists(wolfSSL_BIO_set_shutdown "wolfssl/ssl.h" HAVE_WOLFSSL_FULL_BIO "")
+endif()
+
 if(USE_OPENSSL OR USE_WOLFSSL)
   if(NOT DEFINED HAVE_SSL_SET0_WBIO)
     openssl_check_symbol_exists(SSL_set0_wbio "openssl/ssl.h" HAVE_SSL_SET0_WBIO "")
@@ -684,6 +705,7 @@ if(USE_NGHTTP2)
   find_package(NGHTTP2 REQUIRED)
   include_directories(${NGHTTP2_INCLUDE_DIRS})
   list(APPEND CURL_LIBS ${NGHTTP2_LIBRARIES})
+  list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "libnghttp2")
 endif()
 
 option(USE_NGTCP2 "Use ngtcp2 and nghttp3 libraries for HTTP/3 support" OFF)
@@ -691,25 +713,31 @@ if(USE_NGTCP2)
   if(USE_OPENSSL OR USE_WOLFSSL)
     if(USE_WOLFSSL)
       find_package(NGTCP2 REQUIRED wolfSSL)
+      list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "libngtcp2_crypto_wolfssl")
     elseif(HAVE_BORINGSSL OR HAVE_AWSLC)
       find_package(NGTCP2 REQUIRED BoringSSL)
+      list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "libngtcp2_crypto_boringssl")
     else()
       find_package(NGTCP2 REQUIRED quictls)
+      list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "libngtcp2_crypto_quictls")
     endif()
     openssl_check_quic()
   elseif(USE_GNUTLS)
     find_package(NGTCP2 REQUIRED GnuTLS)
+    list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "libngtcp2_crypto_gnutls")
   else()
     message(FATAL_ERROR "ngtcp2 requires OpenSSL, wolfSSL or GnuTLS")
   endif()
   set(USE_NGTCP2 ON)
   include_directories(${NGTCP2_INCLUDE_DIRS})
   list(APPEND CURL_LIBS ${NGTCP2_LIBRARIES})
+  list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "libngtcp2")
 
   find_package(NGHTTP3 REQUIRED)
   set(USE_NGHTTP3 ON)
   include_directories(${NGHTTP3_INCLUDE_DIRS})
   list(APPEND CURL_LIBS ${NGHTTP3_LIBRARIES})
+  list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "libnghttp3")
 endif()
 
 option(USE_QUICHE "Use quiche library for HTTP/3 support" OFF)
@@ -725,6 +753,7 @@ if(USE_QUICHE)
   set(USE_QUICHE ON)
   include_directories(${QUICHE_INCLUDE_DIRS})
   list(APPEND CURL_LIBS ${QUICHE_LIBRARIES})
+  list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "quiche")
   if(NOT DEFINED HAVE_QUICHE_CONN_SET_QLOG_FD)
     cmake_push_check_state()
     set(CMAKE_REQUIRED_INCLUDES   "${QUICHE_INCLUDE_DIRS}")
@@ -742,6 +771,7 @@ if(USE_MSH3)
   set(USE_MSH3 ON)
   include_directories(${MSH3_INCLUDE_DIRS})
   list(APPEND CURL_LIBS ${MSH3_LIBRARIES})
+  list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "libmsh3")
 endif()
 
 option(USE_OPENSSL_QUIC "Use openssl and nghttp3 libraries for HTTP/3 support" OFF)
@@ -749,12 +779,13 @@ if(USE_OPENSSL_QUIC)
   if(USE_NGTCP2 OR USE_QUICHE OR USE_MSH3)
     message(FATAL_ERROR "Only one HTTP/3 backend can be selected!")
   endif()
-  find_package(OpenSSL 3.2.0 REQUIRED)
+  find_package(OpenSSL 3.3.0 REQUIRED)
 
   find_package(NGHTTP3 REQUIRED)
   set(USE_NGHTTP3 ON)
   include_directories(${NGHTTP3_INCLUDE_DIRS})
   list(APPEND CURL_LIBS ${NGHTTP3_LIBRARIES})
+  list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "libnghttp3")
 endif()
 
 if(USE_MBEDTLS OR
@@ -772,7 +803,7 @@ if(NOT CURL_DISABLE_SRP AND (HAVE_GNUTLS_SRP OR HAVE_OPENSSL_SRP))
 endif()
 
 if(NOT CURL_DISABLE_LDAP)
-  if(WIN32)
+  if(WIN32 AND NOT WINDOWS_STORE)
     option(USE_WIN32_LDAP "Use Windows LDAP implementation" ON)
     if(USE_WIN32_LDAP)
       list(APPEND CURL_LIBS "wldap32")
@@ -885,9 +916,22 @@ option(USE_LIBIDN2 "Use libidn2 for IDN support" ON)
 if(USE_LIBIDN2)
   check_library_exists("idn2" "idn2_lookup_ul" "" HAVE_LIBIDN2)
   if(HAVE_LIBIDN2)
-    set(CURL_LIBS "idn2;${CURL_LIBS}")
+    set(LIBIDN2_LINK_LIBRARIES "idn2")
     check_include_file_concat("idn2.h" HAVE_IDN2_H)
   endif()
+  if(NOT HAVE_LIBIDN2 OR NOT HAVE_IDN2_H)
+    find_package(PkgConfig QUIET)
+    pkg_check_modules(LIBIDN2 "libidn2")
+    if(LIBIDN2_FOUND)
+      include_directories(${LIBIDN2_INCLUDE_DIRS})
+      set(HAVE_LIBIDN2 ON)
+      set(HAVE_IDN2_H ON)
+    endif()
+  endif()
+  if(HAVE_LIBIDN2 AND HAVE_IDN2_H)
+    set(CURL_LIBS "${LIBIDN2_LINK_LIBRARIES};${CURL_LIBS}")
+    set(LIBCURL_PC_REQUIRES_PRIVATE "libidn2;${LIBCURL_PC_REQUIRES_PRIVATE}")
+  endif()
 else()
   set(HAVE_LIBIDN2 OFF)
 endif()
@@ -914,8 +958,8 @@ if(APPLE)
   endif()
 endif()
 
-#libpsl
-option(CURL_USE_LIBPSL "Use libPSL" ON)
+# libpsl
+option(CURL_USE_LIBPSL "Use libpsl" ON)
 mark_as_advanced(CURL_USE_LIBPSL)
 set(USE_LIBPSL OFF)
 
@@ -923,14 +967,15 @@ if(CURL_USE_LIBPSL)
   find_package(LibPSL)
   if(LIBPSL_FOUND)
     list(APPEND CURL_LIBS ${LIBPSL_LIBRARY})
+    list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "libpsl")
     list(APPEND CMAKE_REQUIRED_INCLUDES "${LIBPSL_INCLUDE_DIR}")
     include_directories("${LIBPSL_INCLUDE_DIR}")
     set(USE_LIBPSL ON)
   endif()
 endif()
 
-#libSSH2
-option(CURL_USE_LIBSSH2 "Use libSSH2" ON)
+# libssh2
+option(CURL_USE_LIBSSH2 "Use libssh2" ON)
 mark_as_advanced(CURL_USE_LIBSSH2)
 set(USE_LIBSSH2 OFF)
 
@@ -938,6 +983,7 @@ if(CURL_USE_LIBSSH2)
   find_package(LibSSH2)
   if(LIBSSH2_FOUND)
     list(APPEND CURL_LIBS ${LIBSSH2_LIBRARY})
+    list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "libssh2")
     list(APPEND CMAKE_REQUIRED_INCLUDES "${LIBSSH2_INCLUDE_DIR}")
     include_directories("${LIBSSH2_INCLUDE_DIR}")
     set(USE_LIBSSH2 ON)
@@ -945,18 +991,38 @@ if(CURL_USE_LIBSSH2)
 endif()
 
 # libssh
-option(CURL_USE_LIBSSH "Use libSSH" OFF)
+option(CURL_USE_LIBSSH "Use libssh" OFF)
 mark_as_advanced(CURL_USE_LIBSSH)
 if(NOT USE_LIBSSH2 AND CURL_USE_LIBSSH)
-  find_package(libssh CONFIG)
+  find_package(libssh CONFIG QUIET)
   if(libssh_FOUND)
     message(STATUS "Found libssh ${libssh_VERSION}")
-    # Use imported target for include and library paths.
-    list(APPEND CURL_LIBS ssh)
+  else()
+    find_package(PkgConfig QUIET)
+    pkg_check_modules(LIBSSH "libssh")
+    if(LIBSSH_FOUND)
+      include_directories(${LIBSSH_INCLUDE_DIRS})
+    endif()
+  endif()
+  if(libssh_FOUND OR LIBSSH_FOUND)
+    if(NOT DEFINED LIBSSH_LINK_LIBRARIES)
+      set(LIBSSH_LINK_LIBRARIES "ssh")  # for find_package() with broken pkg-config (e.g. linux-old CI workflow)
+    endif()
+    list(APPEND CURL_LIBS ${LIBSSH_LINK_LIBRARIES})
+    list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "libssh")
     set(USE_LIBSSH ON)
   endif()
 endif()
 
+option(CURL_USE_GSASL "Use GSASL implementation" OFF)
+mark_as_advanced(CURL_USE_GSASL)
+if(CURL_USE_GSASL)
+  find_package(PkgConfig REQUIRED)
+  pkg_check_modules(GSASL REQUIRED libgsasl)
+  list(APPEND CURL_LIBS ${GSASL_LINK_LIBRARIES})
+  set(USE_GSASL ON)
+endif()
+
 option(CURL_USE_GSSAPI "Use GSSAPI implementation (right now only Heimdal is supported with CMake build)" OFF)
 mark_as_advanced(CURL_USE_GSSAPI)
 
@@ -1011,7 +1077,9 @@ if(CURL_USE_GSSAPI)
     set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} ${GSS_LINKER_FLAGS}")
     set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${GSS_LINKER_FLAGS}")
     list(APPEND CURL_LIBS ${GSS_LIBRARIES})
-
+    if(GSS_FLAVOUR STREQUAL "MIT")
+      list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "mit-krb5-gssapi")
+    endif()
   else()
     message(WARNING "GSSAPI support has been requested but no supporting libraries found. Skipping.")
   endif()
@@ -1028,6 +1096,7 @@ if(USE_LIBRTMP)
   cmake_pop_check_state()
   if(HAVE_LIBRTMP)
     list(APPEND CURL_LIBS "rtmp")
+    list(APPEND LIBCURL_PC_REQUIRES_PRIVATE "librtmp")
     if(WIN32)
       list(APPEND CURL_LIBS "winmm")
     endif()
@@ -1049,88 +1118,81 @@ else()
   unset(USE_UNIX_SOCKETS CACHE)
 endif()
 
-
 #
 # CA handling
 #
-set(CURL_CA_BUNDLE "auto" CACHE STRING
-    "Path to the CA bundle. Set 'none' to disable or 'auto' for auto-detection. Defaults to 'auto'.")
-set(CURL_CA_FALLBACK OFF CACHE BOOL
-    "Set ON to use built-in CA store of TLS backend. Defaults to OFF")
-set(CURL_CA_PATH "auto" CACHE STRING
-    "Location of default CA path. Set 'none' to disable or 'auto' for auto-detection. Defaults to 'auto'.")
-
-if("${CURL_CA_BUNDLE}" STREQUAL "")
-  message(FATAL_ERROR "Invalid value of CURL_CA_BUNDLE. Use 'none', 'auto' or file path.")
-elseif("${CURL_CA_BUNDLE}" STREQUAL "none")
-  unset(CURL_CA_BUNDLE CACHE)
-elseif("${CURL_CA_BUNDLE}" STREQUAL "auto")
-  unset(CURL_CA_BUNDLE CACHE)
-  if(NOT CMAKE_CROSSCOMPILING)
-    set(CURL_CA_BUNDLE_AUTODETECT TRUE)
+if(curl_ca_bundle_supported)
+  set(CURL_CA_BUNDLE "auto" CACHE STRING
+      "Path to the CA bundle. Set 'none' to disable or 'auto' for auto-detection. Defaults to 'auto'.")
+  set(CURL_CA_FALLBACK OFF CACHE BOOL
+      "Set ON to use built-in CA store of TLS backend. Defaults to OFF")
+  set(CURL_CA_PATH "auto" CACHE STRING
+      "Location of default CA path. Set 'none' to disable or 'auto' for auto-detection. Defaults to 'auto'.")
+
+  if(CURL_CA_BUNDLE STREQUAL "")
+    message(FATAL_ERROR "Invalid value of CURL_CA_BUNDLE. Use 'none', 'auto' or file path.")
+  elseif(CURL_CA_BUNDLE STREQUAL "none")
+    unset(CURL_CA_BUNDLE CACHE)
+  elseif(CURL_CA_BUNDLE STREQUAL "auto")
+    unset(CURL_CA_BUNDLE CACHE)
+    if(NOT CMAKE_CROSSCOMPILING AND NOT WIN32)
+      set(CURL_CA_BUNDLE_AUTODETECT TRUE)
+    endif()
+  else()
+    set(CURL_CA_BUNDLE_SET TRUE)
   endif()
-else()
-  set(CURL_CA_BUNDLE_SET TRUE)
-endif()
 
-if("${CURL_CA_PATH}" STREQUAL "")
-  message(FATAL_ERROR "Invalid value of CURL_CA_PATH. Use 'none', 'auto' or directory path.")
-elseif("${CURL_CA_PATH}" STREQUAL "none")
-  unset(CURL_CA_PATH CACHE)
-elseif("${CURL_CA_PATH}" STREQUAL "auto")
-  unset(CURL_CA_PATH CACHE)
-  if(NOT CMAKE_CROSSCOMPILING)
-    set(CURL_CA_PATH_AUTODETECT TRUE)
-  endif()
-else()
-  set(CURL_CA_PATH_SET TRUE)
-endif()
-
-if(CURL_CA_BUNDLE_SET AND CURL_CA_PATH_AUTODETECT)
-  # Skip autodetection of unset CA path because CA bundle is set explicitly
-elseif(CURL_CA_PATH_SET AND CURL_CA_BUNDLE_AUTODETECT)
-  # Skip autodetection of unset CA bundle because CA path is set explicitly
-elseif(CURL_CA_PATH_AUTODETECT OR CURL_CA_BUNDLE_AUTODETECT)
-  # first try autodetecting a CA bundle, then a CA path
-
-  if(CURL_CA_BUNDLE_AUTODETECT)
-    set(SEARCH_CA_BUNDLE_PATHS
-        /etc/ssl/certs/ca-certificates.crt
-        /etc/pki/tls/certs/ca-bundle.crt
-        /usr/share/ssl/certs/ca-bundle.crt
-        /usr/local/share/certs/ca-root-nss.crt
-        /etc/ssl/cert.pem)
-
-    foreach(SEARCH_CA_BUNDLE_PATH ${SEARCH_CA_BUNDLE_PATHS})
-      if(EXISTS "${SEARCH_CA_BUNDLE_PATH}")
-        message(STATUS "Found CA bundle: ${SEARCH_CA_BUNDLE_PATH}")
-        set(CURL_CA_BUNDLE "${SEARCH_CA_BUNDLE_PATH}" CACHE STRING
-            "Path to the CA bundle. Set 'none' to disable or 'auto' for auto-detection. Defaults to 'auto'.")
-        set(CURL_CA_BUNDLE_SET TRUE CACHE BOOL "Path to the CA bundle has been set")
-        break()
-      endif()
-    endforeach()
-  endif()
+  if(CURL_CA_PATH STREQUAL "")
+    message(FATAL_ERROR "Invalid value of CURL_CA_PATH. Use 'none', 'auto' or directory path.")
+  elseif(CURL_CA_PATH STREQUAL "none")
+    unset(CURL_CA_PATH CACHE)
+  elseif(CURL_CA_PATH STREQUAL "auto")
+    unset(CURL_CA_PATH CACHE)
+    if(NOT CMAKE_CROSSCOMPILING AND NOT WIN32)
+      set(CURL_CA_PATH_AUTODETECT TRUE)
+    endif()
+  else()
+    set(CURL_CA_PATH_SET TRUE)
+  endif()
+
+  if(CURL_CA_BUNDLE_SET AND CURL_CA_PATH_AUTODETECT)
+    # Skip auto-detection of unset CA path because CA bundle is set explicitly
+  elseif(CURL_CA_PATH_SET AND CURL_CA_BUNDLE_AUTODETECT)
+    # Skip auto-detection of unset CA bundle because CA path is set explicitly
+  elseif(CURL_CA_BUNDLE_AUTODETECT OR CURL_CA_PATH_AUTODETECT)
+    # First try auto-detecting a CA bundle, then a CA path
+
+    if(CURL_CA_BUNDLE_AUTODETECT)
+      foreach(SEARCH_CA_BUNDLE_PATH IN ITEMS
+          "/etc/ssl/certs/ca-certificates.crt"
+          "/etc/pki/tls/certs/ca-bundle.crt"
+          "/usr/share/ssl/certs/ca-bundle.crt"
+          "/usr/local/share/certs/ca-root-nss.crt"
+          "/etc/ssl/cert.pem")
+        if(EXISTS "${SEARCH_CA_BUNDLE_PATH}")
+          message(STATUS "Found CA bundle: ${SEARCH_CA_BUNDLE_PATH}")
+          set(CURL_CA_BUNDLE "${SEARCH_CA_BUNDLE_PATH}" CACHE STRING
+              "Path to the CA bundle. Set 'none' to disable or 'auto' for auto-detection. Defaults to 'auto'.")
+          set(CURL_CA_BUNDLE_SET TRUE CACHE BOOL "Path to the CA bundle has been set")
+          break()
+        endif()
+      endforeach()
+    endif()
 
-  if(CURL_CA_PATH_AUTODETECT AND (NOT CURL_CA_PATH_SET))
-    if(EXISTS "/etc/ssl/certs")
-      set(CURL_CA_PATH "/etc/ssl/certs" CACHE STRING
-          "Location of default CA path. Set 'none' to disable or 'auto' for auto-detection. Defaults to 'auto'.")
-      set(CURL_CA_PATH_SET TRUE CACHE BOOL "Path to the CA bundle has been set")
+    if(CURL_CA_PATH_AUTODETECT AND NOT CURL_CA_PATH_SET)
+      set(SEARCH_CA_PATH "/etc/ssl/certs")
+      file(GLOB curl_ca_files_found "${SEARCH_CA_PATH}/[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f].0")
+      if(curl_ca_files_found)
+        unset(curl_ca_files_found)
+        message(STATUS "Found CA path: ${SEARCH_CA_PATH}")
+        set(CURL_CA_PATH "${SEARCH_CA_PATH}" CACHE STRING
+            "Location of default CA path. Set 'none' to disable or 'auto' for auto-detection. Defaults to 'auto'.")
+        set(CURL_CA_PATH_SET TRUE CACHE BOOL "Path to the CA bundle has been set")
+      endif()
     endif()
   endif()
 endif()
 
-if(CURL_CA_PATH_SET AND
-   NOT USE_OPENSSL AND
-   NOT USE_WOLFSSL AND
-   NOT USE_GNUTLS AND
-   NOT USE_MBEDTLS)
-  message(STATUS
-          "CA path only supported by OpenSSL, wolfSSL, GnuTLS or mbedTLS. "
-          "Set CURL_CA_PATH=none or enable one of those TLS backends.")
-endif()
-
 # Check for header files
 if(WIN32)
   set(CURL_INCLUDES ${CURL_INCLUDES} "winsock2.h")
@@ -1172,6 +1234,7 @@ if(WIN32)
   endif()
 endif()
 
+check_include_file_concat("sys/eventfd.h"    HAVE_SYS_EVENTFD_H)
 check_include_file_concat("sys/filio.h"      HAVE_SYS_FILIO_H)
 check_include_file_concat("sys/wait.h"       HAVE_SYS_WAIT_H)
 check_include_file_concat("sys/ioctl.h"      HAVE_SYS_IOCTL_H)
@@ -1292,6 +1355,7 @@ check_symbol_exists(getaddrinfo    "${CURL_INCLUDES};stdlib.h;string.h" HAVE_GET
 check_symbol_exists(getifaddrs     "${CURL_INCLUDES};stdlib.h" HAVE_GETIFADDRS)
 check_symbol_exists(freeaddrinfo   "${CURL_INCLUDES}" HAVE_FREEADDRINFO)
 check_symbol_exists(pipe           "${CURL_INCLUDES}" HAVE_PIPE)
+check_symbol_exists(eventfd        "${CURL_INCLUDES};sys/eventfd.h" HAVE_EVENTFD)
 check_symbol_exists(ftruncate      "${CURL_INCLUDES}" HAVE_FTRUNCATE)
 check_symbol_exists(_fseeki64      "${CURL_INCLUDES};stdio.h" HAVE__FSEEKI64)
 check_symbol_exists(getpeername    "${CURL_INCLUDES}" HAVE_GETPEERNAME)
@@ -1441,8 +1505,10 @@ if(NOT WIN32)
   curl_internal_test(HAVE_CLOCK_GETTIME_MONOTONIC)
 endif()
 
-# Check compiler support of __builtin_available()
-curl_internal_test(HAVE_BUILTIN_AVAILABLE)
+if(APPLE)
+  # Check compiler support of __builtin_available()
+  curl_internal_test(HAVE_BUILTIN_AVAILABLE)
+endif()
 
 # Some other minor tests
 
@@ -1453,9 +1519,9 @@ endif()
 # Check for nonblocking
 set(HAVE_DISABLED_NONBLOCKING 1)
 if(HAVE_FIONBIO OR
-    HAVE_IOCTLSOCKET OR
-    HAVE_IOCTLSOCKET_CASE OR
-    HAVE_O_NONBLOCK)
+   HAVE_IOCTLSOCKET OR
+   HAVE_IOCTLSOCKET_CASE OR
+   HAVE_O_NONBLOCK)
   set(HAVE_DISABLED_NONBLOCKING)
 endif()
 
@@ -1463,7 +1529,7 @@ if(CMAKE_COMPILER_IS_GNUCC AND APPLE)
   include(CheckCCompilerFlag)
   check_c_compiler_flag(-Wno-long-double HAVE_C_FLAG_Wno_long_double)
   if(HAVE_C_FLAG_Wno_long_double)
-    # The Mac version of GCC warns about use of long double.  Disable it.
+    # The Mac version of GCC warns about use of long double. Disable it.
     get_source_file_property(MPRINTF_COMPILE_FLAGS mprintf.c COMPILE_FLAGS)
     if(MPRINTF_COMPILE_FLAGS)
       set(MPRINTF_COMPILE_FLAGS "${MPRINTF_COMPILE_FLAGS} -Wno-long-double")
@@ -1540,7 +1606,8 @@ if(CURL_LTO)
 endif()
 
 
-# Ugly (but functional) way to include "Makefile.inc" by transforming it (= regenerate it).
+# Ugly (but functional) way to include "Makefile.inc" by transforming it
+# (= regenerate it).
 function(transform_makefile_inc INPUT_FILE OUTPUT_FILE)
   file(READ ${INPUT_FILE} MAKEFILE_INC_TEXT)
   string(REPLACE "$(top_srcdir)"   "\${CURL_SOURCE_DIR}" MAKEFILE_INC_TEXT ${MAKEFILE_INC_TEXT})
@@ -1550,8 +1617,8 @@ function(transform_makefile_inc INPUT_FILE OUTPUT_FILE)
   string(REGEX REPLACE "([a-zA-Z_][a-zA-Z0-9_]*)[\t ]*=[\t ]*([^\n]*)" "SET(\\1 \\2)" MAKEFILE_INC_TEXT ${MAKEFILE_INC_TEXT})
   string(REPLACE "!Ï€!Î±!" "\n" MAKEFILE_INC_TEXT ${MAKEFILE_INC_TEXT})
 
-  string(REGEX REPLACE "\\$\\(([a-zA-Z_][a-zA-Z0-9_]*)\\)" "\${\\1}" MAKEFILE_INC_TEXT ${MAKEFILE_INC_TEXT})    # Replace $() with ${}
-  string(REGEX REPLACE "@([a-zA-Z_][a-zA-Z0-9_]*)@" "\${\\1}" MAKEFILE_INC_TEXT ${MAKEFILE_INC_TEXT})    # Replace @@ with ${}, even if that may not be read by CMake scripts.
+  string(REGEX REPLACE "\\$\\(([a-zA-Z_][a-zA-Z0-9_]*)\\)" "\${\\1}" MAKEFILE_INC_TEXT ${MAKEFILE_INC_TEXT})  # Replace $() with ${}
+  string(REGEX REPLACE "@([a-zA-Z_][a-zA-Z0-9_]*)@" "\${\\1}" MAKEFILE_INC_TEXT ${MAKEFILE_INC_TEXT})  # Replace @@ with ${}, even if that may not be read by CMake scripts.
   file(WRITE ${OUTPUT_FILE} ${MAKEFILE_INC_TEXT})
   set_property(DIRECTORY APPEND PROPERTY CMAKE_CONFIGURE_DEPENDS "${INPUT_FILE}")
 endfunction()
@@ -1596,8 +1663,8 @@ if(NOT CURL_DISABLE_INSTALL)
             GROUP_READ GROUP_EXECUTE
             WORLD_READ WORLD_EXECUTE)
 
-  # Helper to populate a list (_items) with a label when conditions (the remaining
-  # args) are satisfied
+  # Helper to populate a list (_items) with a label when conditions
+  # (the remaining args) are satisfied
   macro(_add_if label)
     # needs to be a macro to allow this indirection
     if(${ARGN})
@@ -1605,58 +1672,24 @@ if(NOT CURL_DISABLE_INSTALL)
     endif()
   endmacro()
 
-  # NTLM support requires crypto function adaptions from various SSL libs
-  if(NOT (CURL_DISABLE_NTLM) AND
-      (USE_OPENSSL OR USE_MBEDTLS OR USE_DARWINSSL OR USE_WIN32_CRYPTO OR USE_GNUTLS))
+  # NTLM support requires crypto functions from various SSL libs.
+  # These conditions must match those in lib/curl_setup.h.
+  if(NOT CURL_DISABLE_NTLM AND
+     (USE_OPENSSL OR
+      USE_MBEDTLS OR
+      USE_GNUTLS OR
+      USE_SECTRANSP OR
+      USE_WIN32_CRYPTO OR
+      (USE_WOLFSSL AND HAVE_WOLFSSL_DES_ECB_ENCRYPT)))
     set(use_curl_ntlm_core ON)
   endif()
 
-  # Clear list and try to detect available features
-  set(_items)
-  _add_if("SSL"           SSL_ENABLED)
-  _add_if("IPv6"          ENABLE_IPV6)
-  _add_if("UnixSockets"   USE_UNIX_SOCKETS)
-  _add_if("libz"          HAVE_LIBZ)
-  _add_if("brotli"        HAVE_BROTLI)
-  _add_if("zstd"          HAVE_ZSTD)
-  _add_if("AsynchDNS"     USE_ARES OR USE_THREADS_POSIX OR USE_THREADS_WIN32)
-  _add_if("IDN"           HAVE_LIBIDN2 OR USE_WIN32_IDN OR USE_APPLE_IDN)
-  _add_if("Largefile"     (SIZEOF_CURL_OFF_T GREATER 4) AND
-                          ((SIZEOF_OFF_T GREATER 4) OR USE_WIN32_LARGE_FILES))
-  _add_if("SSPI"          USE_WINDOWS_SSPI)
-  _add_if("GSS-API"       HAVE_GSSAPI)
-  _add_if("alt-svc"       NOT CURL_DISABLE_ALTSVC)
-  _add_if("HSTS"          NOT CURL_DISABLE_HSTS)
-  _add_if("SPNEGO"        NOT CURL_DISABLE_NEGOTIATE_AUTH AND
-                          (HAVE_GSSAPI OR USE_WINDOWS_SSPI))
-  _add_if("Kerberos"      NOT CURL_DISABLE_KERBEROS_AUTH AND
-                          (HAVE_GSSAPI OR USE_WINDOWS_SSPI))
-  _add_if("NTLM"          NOT (CURL_DISABLE_NTLM) AND
-                          (use_curl_ntlm_core OR USE_WINDOWS_SSPI))
-  _add_if("TLS-SRP"       USE_TLS_SRP)
-  _add_if("HTTP2"         USE_NGHTTP2)
-  _add_if("HTTP3"         USE_NGTCP2 OR USE_QUICHE OR USE_OPENSSL_QUIC)
-  _add_if("MultiSSL"      CURL_WITH_MULTI_SSL)
-  # TODO wolfSSL only support this from v5.0.0 onwards
-  _add_if("HTTPS-proxy"   SSL_ENABLED AND (USE_OPENSSL OR USE_GNUTLS
-                          OR USE_SCHANNEL OR USE_RUSTLS OR USE_BEARSSL OR
-                          USE_MBEDTLS OR USE_SECTRANSP))
-  _add_if("unicode"       ENABLE_UNICODE)
-  _add_if("threadsafe"    HAVE_ATOMIC OR
-                          (USE_THREADS_POSIX AND HAVE_PTHREAD_H) OR
-                          (WIN32 AND HAVE_WIN32_WINNT GREATER_EQUAL 0x600))
-  _add_if("PSL"           USE_LIBPSL)
-  string(REPLACE ";" " " SUPPORT_FEATURES "${_items}")
-  message(STATUS "Enabled features: ${SUPPORT_FEATURES}")
-
   # Clear list and try to detect available protocols
   set(_items)
   _add_if("HTTP"          NOT CURL_DISABLE_HTTP)
   _add_if("IPFS"          NOT CURL_DISABLE_HTTP)
   _add_if("IPNS"          NOT CURL_DISABLE_HTTP)
   _add_if("HTTPS"         NOT CURL_DISABLE_HTTP AND SSL_ENABLED)
-  _add_if("ECH"           HAVE_ECH)
-  _add_if("HTTPSRR"       HAVE_ECH)
   _add_if("FTP"           NOT CURL_DISABLE_FTP)
   _add_if("FTPS"          NOT CURL_DISABLE_FTP AND SSL_ENABLED)
   _add_if("FILE"          NOT CURL_DISABLE_FILE)
@@ -1686,12 +1719,64 @@ if(NOT CURL_DISABLE_INSTALL)
   _add_if("RTMP"          USE_LIBRTMP)
   _add_if("MQTT"          NOT CURL_DISABLE_MQTT)
   _add_if("WS"            USE_WEBSOCKETS)
-  _add_if("WSS"           USE_WEBSOCKETS)
+  _add_if("WSS"           USE_WEBSOCKETS AND SSL_ENABLED)
   if(_items)
     list(SORT _items)
   endif()
   string(REPLACE ";" " " SUPPORT_PROTOCOLS "${_items}")
-  message(STATUS "Enabled protocols: ${SUPPORT_PROTOCOLS}")
+  string(TOLOWER "${SUPPORT_PROTOCOLS}" SUPPORT_PROTOCOLS_LOWER)
+  message(STATUS "Protocols: ${SUPPORT_PROTOCOLS_LOWER}")
+
+  # Clear list and try to detect available features
+  set(_items)
+  _add_if("SSL"           SSL_ENABLED)
+  _add_if("IPv6"          ENABLE_IPV6)
+  _add_if("UnixSockets"   USE_UNIX_SOCKETS)
+  _add_if("libz"          HAVE_LIBZ)
+  _add_if("brotli"        HAVE_BROTLI)
+  _add_if("gsasl"         USE_GSASL)
+  _add_if("zstd"          HAVE_ZSTD)
+  _add_if("AsynchDNS"     USE_ARES OR USE_THREADS_POSIX OR USE_THREADS_WIN32)
+  _add_if("IDN"           (HAVE_LIBIDN2 AND HAVE_IDN2_H) OR
+                          USE_WIN32_IDN OR
+                          USE_APPLE_IDN)
+  _add_if("Largefile"     (SIZEOF_CURL_OFF_T GREATER 4) AND
+                          ((SIZEOF_OFF_T GREATER 4) OR USE_WIN32_LARGE_FILES))
+  _add_if("SSPI"          USE_WINDOWS_SSPI)
+  _add_if("GSS-API"       HAVE_GSSAPI)
+  _add_if("alt-svc"       NOT CURL_DISABLE_ALTSVC)
+  _add_if("HSTS"          NOT CURL_DISABLE_HSTS)
+  _add_if("SPNEGO"        NOT CURL_DISABLE_NEGOTIATE_AUTH AND
+                          (HAVE_GSSAPI OR USE_WINDOWS_SSPI))
+  _add_if("Kerberos"      NOT CURL_DISABLE_KERBEROS_AUTH AND
+                          (HAVE_GSSAPI OR USE_WINDOWS_SSPI))
+  _add_if("NTLM"          NOT (CURL_DISABLE_NTLM) AND
+                          (use_curl_ntlm_core OR USE_WINDOWS_SSPI))
+  _add_if("TLS-SRP"       USE_TLS_SRP)
+  _add_if("HTTP2"         USE_NGHTTP2)
+  _add_if("HTTP3"         USE_NGTCP2 OR USE_QUICHE OR USE_OPENSSL_QUIC)
+  _add_if("MultiSSL"      CURL_WITH_MULTI_SSL)
+  _add_if("HTTPS-proxy"   SSL_ENABLED AND (USE_OPENSSL OR USE_GNUTLS
+                          OR USE_SCHANNEL OR USE_RUSTLS OR USE_BEARSSL OR
+                          USE_MBEDTLS OR USE_SECTRANSP OR
+                          (USE_WOLFSSL AND HAVE_WOLFSSL_FULL_BIO)))
+  _add_if("Unicode"       ENABLE_UNICODE)
+  _add_if("threadsafe"    HAVE_ATOMIC OR
+                          (USE_THREADS_POSIX AND HAVE_PTHREAD_H) OR
+                          (WIN32 AND HAVE_WIN32_WINNT GREATER_EQUAL 0x600))
+  _add_if("Debug"         ENABLE_DEBUG)
+  _add_if("TrackMemory"   ENABLE_CURLDEBUG)
+  _add_if("ECH"           SSL_ENABLED AND HAVE_ECH)
+  _add_if("PSL"           USE_LIBPSL)
+  if(_items)
+    if(NOT CMAKE_VERSION VERSION_LESS 3.13)
+      list(SORT _items CASE INSENSITIVE)
+    else()
+      list(SORT _items)
+    endif()
+  endif()
+  string(REPLACE ";" " " SUPPORT_FEATURES "${_items}")
+  message(STATUS "Features: ${SUPPORT_FEATURES}")
 
   # Clear list and collect SSL backends
   set(_items)
@@ -1704,7 +1789,11 @@ if(NOT CURL_DISABLE_INSTALL)
   _add_if("GnuTLS"           SSL_ENABLED AND USE_GNUTLS)
 
   if(_items)
-    list(SORT _items)
+    if(NOT CMAKE_VERSION VERSION_LESS 3.13)
+      list(SORT _items CASE INSENSITIVE)
+    else()
+      list(SORT _items)
+    endif()
   endif()
   string(REPLACE ";" " " SSL_BACKENDS "${_items}")
   message(STATUS "Enabled SSL backends: ${SSL_BACKENDS}")
@@ -1783,12 +1872,21 @@ if(NOT CURL_DISABLE_INSTALL)
       set(LIBCURL_LIBS          "${LIBCURL_LIBS} -l${_lib}")
     endif()
   endforeach()
+
+  # Export a .pc file for client projects not using CMake
+  if(LIBCURL_PC_REQUIRES_PRIVATE)
+    string(REPLACE ";" "," LIBCURL_PC_REQUIRES_PRIVATE "${LIBCURL_PC_REQUIRES_PRIVATE}")
+  endif()
+
+  # Merge pkg-config private fields into public ones when static-only
   if(BUILD_SHARED_LIBS)
     set(ENABLE_SHARED         "yes")
+    set(LIBCURL_PC_REQUIRES   "")
     set(LIBCURL_NO_SHARED     "")
     set(CPPFLAG_CURL_STATICLIB "")
   else()
     set(ENABLE_SHARED         "no")
+    set(LIBCURL_PC_REQUIRES   "${LIBCURL_PC_REQUIRES_PRIVATE}")
     set(LIBCURL_NO_SHARED     "${LIBCURL_LIBS}")
     set(CPPFLAG_CURL_STATICLIB "-DCURL_STATICLIB")
   endif()
@@ -1811,7 +1909,7 @@ if(NOT CURL_DISABLE_INSTALL)
   # * ENABLE_SHARED
   # * ENABLE_STATIC
   configure_file("${CURL_SOURCE_DIR}/curl-config.in"
-                "${CURL_BINARY_DIR}/curl-config" @ONLY)
+                 "${CURL_BINARY_DIR}/curl-config" @ONLY)
   install(FILES "${CURL_BINARY_DIR}/curl-config"
           DESTINATION ${CMAKE_INSTALL_BINDIR}
           PERMISSIONS
@@ -1821,7 +1919,7 @@ if(NOT CURL_DISABLE_INSTALL)
 
   # Finally generate a pkg-config file matching this config
   configure_file("${CURL_SOURCE_DIR}/libcurl.pc.in"
-                "${CURL_BINARY_DIR}/libcurl.pc" @ONLY)
+                 "${CURL_BINARY_DIR}/libcurl.pc" @ONLY)
   install(FILES "${CURL_BINARY_DIR}/libcurl.pc"
           DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)
 
@@ -1837,11 +1935,11 @@ if(NOT CURL_DISABLE_INSTALL)
       COMPATIBILITY SameMajorVersion
   )
   file(READ "${version_config}" generated_version_config)
-  file(WRITE "${version_config}"
-  "if(NOT PACKAGE_FIND_VERSION_RANGE AND PACKAGE_FIND_VERSION_MAJOR STREQUAL \"7\")
-      # Version 8 satisfies version 7... requirements
-      set(PACKAGE_FIND_VERSION_MAJOR 8)
-      set(PACKAGE_FIND_VERSION_COUNT 1)
+  file(WRITE "${version_config}" "
+  if(NOT PACKAGE_FIND_VERSION_RANGE AND PACKAGE_FIND_VERSION_MAJOR STREQUAL \"7\")
+    # Version 8 satisfies version 7... requirements
+    set(PACKAGE_FIND_VERSION_MAJOR 8)
+    set(PACKAGE_FIND_VERSION_COUNT 1)
   endif()
   ${generated_version_config}"
   )
@@ -1850,20 +1948,19 @@ if(NOT CURL_DISABLE_INSTALL)
   # * TARGETS_EXPORT_NAME
   # * PROJECT_NAME
   configure_package_config_file(CMake/curl-config.cmake.in
-          "${project_config}"
-          INSTALL_DESTINATION ${CURL_INSTALL_CMAKE_DIR}
+    "${project_config}"
+    INSTALL_DESTINATION ${CURL_INSTALL_CMAKE_DIR}
+    PATH_VARS CMAKE_INSTALL_INCLUDEDIR
   )
 
   if(CURL_ENABLE_EXPORT_TARGET)
-    install(
-            EXPORT "${TARGETS_EXPORT_NAME}"
+    install(EXPORT "${TARGETS_EXPORT_NAME}"
             NAMESPACE "${PROJECT_NAME}::"
             DESTINATION ${CURL_INSTALL_CMAKE_DIR}
     )
   endif()
 
-  install(
-          FILES ${version_config} ${project_config}
+  install(FILES ${version_config} ${project_config}
           DESTINATION ${CURL_INSTALL_CMAKE_DIR}
   )
 
@@ -1878,12 +1975,12 @@ if(NOT CURL_DISABLE_INSTALL)
 
   if(NOT TARGET curl_uninstall)
     configure_file(
-        ${CMAKE_CURRENT_SOURCE_DIR}/CMake/cmake_uninstall.cmake.in
-        ${CMAKE_CURRENT_BINARY_DIR}/CMake/cmake_uninstall.cmake
-        IMMEDIATE @ONLY)
+      ${CMAKE_CURRENT_SOURCE_DIR}/CMake/cmake_uninstall.cmake.in
+      ${CMAKE_CURRENT_BINARY_DIR}/CMake/cmake_uninstall.cmake
+      IMMEDIATE @ONLY)
 
     add_custom_target(curl_uninstall
-        COMMAND ${CMAKE_COMMAND} -P
-        ${CMAKE_CURRENT_BINARY_DIR}/CMake/cmake_uninstall.cmake)
+      COMMAND ${CMAKE_COMMAND} -P
+      ${CMAKE_CURRENT_BINARY_DIR}/CMake/cmake_uninstall.cmake)
   endif()
 endif()
diff --git a/Dockerfile b/Dockerfile
index 834e27515..240dc22b2 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -24,7 +24,7 @@
 #   $ ./maketgz 8.7.1
 
 # To update, get the latest digest e.g. from https://hub.docker.com/_/debian/tags
-FROM debian:bookworm-slim@sha256:911821c26cc366231183098f489068afff2d55cf56911cb5b7bd32796538dfe1
+FROM debian:bookworm-slim@sha256:39868a6f452462b70cf720a8daff250c63e7342970e749059c105bf7c1e8eeaf
 
 RUN apt-get update -qq && apt-get install -qq -y --no-install-recommends \
     build-essential make autoconf automake libtool git perl zip zlib1g-dev gawk && \
diff --git a/GIT-INFO.md b/GIT-INFO.md
index 825476c96..71a8b0375 100644
--- a/GIT-INFO.md
+++ b/GIT-INFO.md
@@ -27,16 +27,6 @@ In environments that don't support configure (i.e. Windows), do this:
 
 ## REQUIREMENTS
 
-For `autoreconf` and `configure` (not `buildconf.bat`) to work, you need the
-following software installed:
-
- o autoconf 2.57  (or later)
- o automake 1.7   (or later)
- o libtool  1.4.2 (or later)
- o GNU m4 (required by autoconf)
- o perl
-
-If you don't have perl and don't want to install it, you can rename the source
-file `src/tool_hugehelp.c.cvs` to `src/tool_hugehelp.c` and avoid having to
-generate this file. This will give you a stubbed version of the file that
-doesn't contain actual content.
+See [docs/INTERNALS.md][0] for requirement details.
+
+[0]: docs/INTERNALS.md
diff --git a/METADATA b/METADATA
index f53faad68..b388b2b76 100644
--- a/METADATA
+++ b/METADATA
@@ -1,6 +1,6 @@
 # This project was upgraded with external_updater.
-# Usage: tools/external_updater/updater.sh update external/<absolute path to project>
-# For more info, check https://cs.android.com/android/platform/superproject/+/main:tools/external_updater/README.md
+# Usage: tools/external_updater/updater.sh update external/curl
+# For more info, check https://cs.android.com/android/platform/superproject/main/+/main:tools/external_updater/README.md
 
 name: "curl"
 description: "A command line tool and library for transferring data with URLs."
@@ -11,13 +11,13 @@ third_party {
   }
   last_upgrade_date {
     year: 2024
-    month: 6
-    day: 12
+    month: 8
+    day: 13
   }
   homepage: "https://curl.haxx.se/"
   identifier {
     type: "Git"
     value: "https://github.com/curl/curl/"
-    version: "curl-8_8_0"
+    version: "curl-8_9_1"
   }
 }
diff --git a/Makefile.am b/Makefile.am
index ad8651c77..6d604ea89 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -62,7 +62,7 @@ VC_DIST = projects/README.md                           \
  projects/wolfssl_override.props
 
 WINBUILD_DIST = winbuild/README.md winbuild/gen_resp_file.bat \
- winbuild/MakefileBuild.vc winbuild/Makefile.vc winbuild/makedebug.cmd
+ winbuild/MakefileBuild.vc winbuild/Makefile.vc winbuild/makedebug.bat
 
 PLAN9_DIST = plan9/include/mkfile \
  plan9/include/mkfile             \
diff --git a/RELEASE-NOTES b/RELEASE-NOTES
index a48c8efc9..81a78ccb7 100644
--- a/RELEASE-NOTES
+++ b/RELEASE-NOTES
@@ -1,244 +1,44 @@
-curl and libcurl 8.8.0
+curl and libcurl 8.9.1
 
- Public curl releases:         257
- Command line options:         259
- curl_easy_setopt() options:   305
+ Public curl releases:         259
+ Command line options:         263
+ curl_easy_setopt() options:   306
  Public functions in libcurl:  94
- Contributors:                 3173
+ Contributors:                 3211
 
 This release includes the following changes:
 
- o curl_version_info: provide librtmp version [73]
- o file: add support for directory listings [63]
- o idn: add native AppleIDN (icucore) support for macOS/iOS [95]
- o lib: add curl_multi_waitfds [34]
- o mbedTLS: implement CURLOPT_SSL_CIPHER_LIST option [103]
- o NTLM_WB: drop support [67]
- o TLS: add support for ECH (Encrypted Client Hello) [109]
- o urlapi: add CURLU_GET_EMPTY for empty queries and fragments [111]
 
 This release includes the following bugfixes:
 
- o appveyor: drop unnecessary `--clean-first` cmake option [197]
- o appveyor: guard against crash-build with VS2008 [193]
- o appveyor: make gcc 6 mingw64 job build-only [152]
- o asyn-thread: fix curl_global_cleanup crash in Windows [161]
- o asyn-thread: fix Curl_thread_create result check [162]
- o autotools: delete unused functions [177]
- o autotools: fix `HAVE_IOCTLSOCKET_FIONBIO` test for gcc 14 [186]
- o autotools: only probe for SGI MIPS compilers on IRIX [213]
- o bearssl: fix compiler warnings [43]
- o bearssl: use common code for cipher suite lookup [126]
- o bufq: remove duplicate word in comment [154]
- o BUG-BOUNTY.md: clarify the third party situation [210]
- o build: prefer `USE_IPV6` macro internally (was: `ENABLE_IPV6`) [85]
- o build: remove MacOSX-Framework script [60]
- o cd2nroff/manage: use UTC when SOURCE_DATE_EPOCH is set [36]
- o cf-https-connect: use timeouts as unsigned ints [143]
- o cf-socket: don't try getting local IP without socket [188]
- o cf-socket: remove references to l_ip, l_port [9]
- o ci: add curl-for-win builds: Linux MUSL, macOS, Windows [68]
- o cmake: add `BUILD_EXAMPLES` option to build examples [128]
- o cmake: add librtmp/rtmpdump option and detection [108]
- o cmake: check fseeko after detecting HAVE_FILE_OFFSET_BITS [64]
- o cmake: do not pass linker flags to the static library tool [203]
- o cmake: enable `-pedantic-errors` for clang when `CURL_WERROR=ON` [47]
- o cmake: FindNGHTTP2 add static lib name to find_library call [141]
- o cmake: fix `CURL_WERROR=ON` for old CMake and use it in GHA/linux-old [48]
- o cmake: fix `HAVE_IOCTLSOCKET_FIONBIO` test with gcc 14 [179]
- o cmake: fixup `DEPENDS` filename [51]
- o cmake: forward `USE_LIBRTMP` option to C [59]
- o cmake: generate misc manpages and install `mk-ca-bundle.pl` [24]
- o cmake: initialize `BUILD_TESTING` before first use [227]
- o cmake: speed up libcurl doc building again [15]
- o cmake: tidy-up to use `WORKING_DIRECTORY` [23]
- o cmake: use namespaced custom target names [80]
- o cmdline-docs: fix make install with configure --disable-docs [1]
- o configure: error on missing perl if docs or manual is enabled [135]
- o configure: make --disable-docs imply --disable-manual [2]
- o content_encoding: brotli and others, pass through 0-length writes [5]
- o content_encoding: ignore duplicate chunked encoding [137]
- o content_encoding: reject transfer-encoding after chunked [200]
- o contrithanks: honor `CURLWWW` variable [69]
- o curl-confopts.m4: define CARES_NO_DEPRECATED when c-ares is used [17]
- o curl.h: change CURL_SSLVERSION_* from enum to defines [132]
- o curl: make --help adapt to the terminal width [11]
- o curl: use curl_getenv instead of the curlx_ version [20]
- o Curl_creader_read: init two variables to avoid using them uninited [99]
- o curl_easy_pause.md: use correct defines in example [187]
- o curl_getdate.md: document two-digit year handling [127]
- o curl_global_trace.md: shorten the description [29]
- o curl_multibyte: remove access() function wrapper for Windows [163]
- o curl_path: make Curl_get_pathname use dynbuf [158]
- o curl_setup.h: add support for IAR compiler [191]
- o curl_setup.h: detect 'inline' support [133]
- o curl_sha512_256: do not use workaround for NetBSD when not needed [21]
- o curl_sha512_256: fix detection of OpenSSL 1.1.1 or later [8]
- o curl_url_get.md: clarify queries and fragments and CURLU_GET_EMPTY [105]
- o CURLINFO_REQUEST_SIZE: fixed, add tests for transfer infos reported [52]
- o CURLOPT_WRITEFUNCTION.md: fix the callback proto in the example [215]
- o cw-out: improved error handling [104]
- o DEPRECATE.md: TLS libraries without 1.3 support [199]
- o digest: replace strcpy for empty string with simple assignment [185]
- o dist: `set -eu`, fix shellcheck, make reproducible and smaller tarballs [38]
- o dist: add files missing from release tarball [53]
- o dist: add reproducible dir entries to tarballs [56]
- o dist: do not require Perl in `maketgz` [71]
- o dist: remove the curl-config.1 from the tarball [28]
- o dist: verify tarball reproducibility in CI [40]
- o DISTROS: add patch and issues link for curl-for-win [110]
- o DISTROS: Cygwin updates [44]
- o dllmain: Call OpenSSL thread cleanup for Windows and Cygwin [114]
- o doc: pytest `--repeat` -> `--count` [58]
- o docs/cmdline-opts: invoke managen using a relative path [30]
- o docs/cmdline-opts: mention STARTTLS for --ssl and --ssl-reqd [175]
- o docs: add CURLOPT_NOPROGRESS to CURLOPT_XFERINFOFUNCTION example [61]
- o docs: clarify CURLOPT_MAXFILESIZE and CURLOPT_MAXFILESIZE_LARGE [74]
- o docs: fix some CURLINFO examples [147]
- o doh: fix typo in comment [173]
- o doh: remove unused function prototype [169]
- o dynbuf: fix returncode on memory error [174]
- o examples: fix/silence `-Wsign-conversion` [178]
- o EXPERIMENTAL: add graduation requirements for each feature [166]
- o file: remove useless assignment [89]
- o ftp: add tracing support [181]
- o ftp: fix build for CURL_DISABLE_VERBOSE_STRINGS
- o ftp: fix socket leak on rare error [102]
- o GHA: add NetBSD, OpenBSD, FreeBSD/arm64 and OmniOS jobs [201]
- o GHA: add shellcheck job and fix warnings, shell tidy-ups [70]
- o GHA: add valgrind to a wolfSSL build [37]
- o GHA: on macOS remove $HOME/.curlrc [50]
- o GHA: pin dependencies [194]
- o gnutls: lazy init the trust settings [75]
- o h3/ngtcp2: improve error handling [140]
- o hash: change 'slots' to size_t from int [144]
- o hash: delete unused debug function [198]
- o hsts: explicitly skip blank lines [212]
- o hsts: remove single-use single-line function [151]
- o http tests: in CI skip test_02_23* for quiche [211]
- o http2 + ngtcp2: pass CURLcode errors from callbacks [94]
- o http2, http3: decouple stream state from easy handle [92]
- o http2: emit RST when client write fails [65]
- o http3: quiche+ngtcp2 improvements [129]
- o http: acknowledge a returned error code [123]
- o http: HEAD response body tolerance [170]
- o http: reject HTTP major version switch mid connection [100]
- o http: remove redundant check [182]
- o http: with chunked POST forced, disable length check on read callback [31]
- o http_aws_sigv4: remove useless assignment [88]
- o idn: make Curl_idnconvert_hostname() use Curl_idn_decode() [16]
- o if2ip: make the buf_size arg a size_t [142]
- o INSTALL-CMAKE.md: explain `cmake -G <generator-name>` [32]
- o krb5: use dynbuf [149]
- o ldap: fix unused variables (seen on OmniOS) [183]
- o lib/cf-h1-proxy: silence compiler warnings (gcc 14) [155]
- o lib: add trace support for client reads and writes [45]
- o lib: bump hash sizes to `size_t` [153]
- o lib: clear the easy handle's saved errno before transfer [180]
- o lib: fix compiler warnings (gcc) [222]
- o lib: make protocol handlers store scheme name lowercase [159]
- o lib: merge `ENABLE_QUIC` C macro into `USE_HTTP3` [84]
- o lib: remove two instances of "only only" messages [160]
- o lib: silence `-Wsign-conversion` in base64, strcase, mprintf [139]
- o lib: silence warnings on comma misuse [91]
- o lib: use `#error` instead of invalid syntax in `curl_setup_once.h` [49]
- o lib: use multi instead of multi_easy for the active multi [41]
- o libcurl-opts: mention pipelining less [33]
- o libssh2: delete redundant feature guard [171]
- o libssh2: replace `access()` with `stat()` [145]
- o libssh2: set length to 0 if strdup failed [6]
- o m4: fix rustls pkg-config codepath [22]
- o MAIL-ETIQUETTE: convert to markdown [12]
- o makefile: remove the sorting from the vc-ide action [42]
- o maketgz: put docs/RELEASE-TOOL.md into the tarball [35]
- o managen: fix the option sort order [150]
- o mbedtls: call mbedtls_ssl_setup() after RNG callback is set [66]
- o mbedtls: cut off trailing newlines from debug logs [87]
- o mbedtls: fix building with v3 in CMake Unity mode [107]
- o mbedtls: support TLS 1.3 [156]
- o mime: avoid using access() [125]
- o misc: fix typos [62]
- o misc: fix typos, quoting and spelling [167]
- o mprintf: check fputc error rather than matching returned character [82]
- o mqtt: when Curl_xfer_recv returns error, don't use nread [101]
- o multi: avoid memory-leak risk [134]
- o multi: introduce SETUP state for better timeouts [26]
- o multi: multi_wait improvements [131]
- o multi: remove the unused Curl_preconnect function [98]
- o multi: remove useless assignment [146]
- o multi: timeout handles even without connection [81]
- o openldap: create ldap URLs correctly for IPv6 addresses [19]
- o openssl: do not set SSL_MODE_RELEASE_BUFFERS [10]
- o openssl: revert keylog_callback support for LibreSSL [192]
- o OS400: fix shellcheck warnings in scripts [72]
- o projects: drop MSVC project files for recent versions [79]
- o pytest: add DELETE tests, check server version [225]
- o pytest: fixes for recent python, add FTP tests [206]
- o quic: fixup duplicate static function name (for cmake unity) [77]
- o quiche: expire all active transfers on connection close [116]
- o quiche: trust its timeout handling [190]
- o RELEASE-PROCEDURE: mention an initial working build [7]
- o request: make Curl_req_init return void [96]
- o request: paused upload on completed download, assess connection [54]
- o reuse: add copyright + license info to individual docs/*.md files [13]
- o ROADMAP: remove completed entries, mention websocket
- o rustls: fix handshake done handling [207]
- o rustls: fix partial send handling [224]
- o rustls: remove incorrect SSLSUPP_TLS13_CIPHERSUITES flag [115]
- o rustsls: fix error code on receive [230]
- o sendf: fix two typos in comments [90]
- o sendf: useless assignment in cr_lc_read() [120]
- o setopt: acknowledge errors proper for CURLOPT_COOKIEJAR [216]
- o setopt: make the setstropt_userpwd args compulsory [221]
- o setopt: remove check for 'option' that is always true [219]
- o setopt: warn on Curl_set*opt() uses not using the return value [176]
- o smtp: result of Curl_bufq_cread was not used [78]
- o socket: remove redundant call to getsockname [195]
- o socketpair: fix compilation when USE_UNIX_SOCKETS is not defined [229]
- o src: tidy up types, add necessary casts [217]
- o telnet: check return code from fileno() [112]
- o tests/http: fix compiler warning [39]
- o tests: add -q as first option when invoking curl for tests [97]
- o tests: check caddy server version to match test expectations [106]
- o tests: enable test 1117 for hyper [119]
- o tests: fix feature case in test1481 [117]
- o tests: fix test 1167 to skip digit-only symbols [214]
- o tests: make the unit test result type `CURLcode` [165]
- o tests: Mark tftpd timer function as noreturn [168]
- o tests: tidy up types in server code [220]
- o tls: fix SecureTransport + BearSSL cmake unity builds [113]
- o tls: remove EXAMPLEs from deprecated options [164]
- o tls: use shared init code for TCP+QUIC [57]
- o tool: move tool_ftruncate64 to tool_util.c [138]
- o tool_cb_rea: limit rate unpause for -T . uploads [136]
- o tool_cfgable: free {proxy_}cipher13_list on exit [172]
- o tool_getparam: output warning for leading unicode quote character [14]
- o tool_getparam: remove two redundant conditions [189]
- o tool_operate: don't truncate the etag save file by default [118]
- o tool_operate: init vars unconditionally in post_per_transfer [124]
- o tool_paramhlp: remove duplicate assign [121]
- o tool_xattr: "guess" URL scheme if none is provided [3]
- o tool_xattr: in debug builds, act normally if CURL_FAKE_XATTR is not set [4]
- o transfer: remove useless assignment [122]
- o url: do not URL decode proxy crendentials [55]
- o url: fix use of an uninitialized variable [86]
- o url: make parse_login_details use memdup0 [184]
- o url: remove duplicate call to Curl_conncache_remove_conn when pruning [196]
- o urlapi: allow setting port number zero [76]
- o urlapi: fix relative redirects to fragment-only [83]
- o urldata: remove fields not used depending on used features [46]
- o vauth: make two functions void that always just returned OK [218]
- o version: use msnprintf instead of strncpy [157]
- o vquic-tls: use correct cert name check API for wolfSSL [226]
- o vquic: use CURL_FORMAT_CURL_OFF_T for 64 bit printf output [18]
- o vtls: TLS session storage overhaul [130]
- o wakeup_create: use FD_CLOEXEC/SOCK_CLOEXEC [223]
- o warnless: delete orphan declarations [209]
- o websocket: avoid memory leak in error path [148]
- o winbuild: add ENABLE_WEBSOCKETS option [93]
- o winbuild: use $(RC) correctly [27]
- o wolfssl: plug memory leak in wolfssl_connect_step2() [25]
- o x509asn1: return error on missing OID [208]
+ o cmake: detect `libssh` via `pkg-config` [10]
+ o cmake: detect `nettle` when building with GnuTLS [12]
+ o cmake: drop `if(PKG_CONFIG_FOUND)` guard for `pkg_check_modules()` [25]
+ o configure: limit `__builtin_available` test to Darwin [22]
+ o connect: fix connection shutdown for event based processing [17]
+ o contrithanks.sh: use -F with -v to match lines as strings
+ o curl: more defensive socket code for --ip-tos [21]
+ o CURLOPT_SSL_CTX_FUNCTION.md: mention CA caching [9]
+ o CURLSHOPT_SHARE.md: mention sessions/cookies as not thread-safe [20]
+ o example/multi-uv: remove the use of globals [3]
+ o ftpserver.pl: make POP3 LIST serve content from the test file [19]
+ o GHA/windows: increase timeout for vcpkg build step
+ o lib: survive some NULL input args [8]
+ o macos: fix Apple SDK bug workaround for non-macOS targets [13]
+ o misc: cleanup after removing years from copyright [26]
+ o os400: build cli manual. [2]
+ o os400: workaround an IBM ASCII run-time library bug [5]
+ o RELEASE-PROCEDURE.md: remove the initial build step [1]
+ o runtests: fold timing details with GHA, sync `-r` tflags [4]
+ o tests: provide FTP directory contents in the test file [18]
+ o tidy-up: URL updates [24]
+ o TODO: thread-safe sharing
+ o transfer: speed limiting fix for 32bit systems [6]
+ o vtls: avoid forward declaration in MultiSSL builds [23]
+ o wolfSSL: allow wolfSSL's implementation of kyber to be used [7]
+ o wolfssl: avoid calling get_cached_x509_store if store is uncachable [11]
+ o wolfssl: CA store share fix [14]
+ o x509asn1: unittests and fixes for gtime2str [15]
 
 This release includes the following known bugs:
 
@@ -246,260 +46,43 @@ This release includes the following known bugs:
 
 Planned upcoming removals include:
 
- o support for space-separated NOPROXY patterns
+ o TLS libraries not supporting TLS 1.3
 
  See https://curl.se/dev/deprecate.html for details
 
 This release would not have looked like this without help, code, reports and
 advice from friends like these:
 
-  Abdullah Alyan, Andrew, Antoine Bollengier, blankie, Brian Inglis,
-  Carlos Henrique Lima Melara, Ch40zz on github, Christian Schmitz, Chris Webb,
-  Colin Leroy-Mira, Dagfinn Ilmari MannsÃ¥ker, Dan Fandrich, Daniel Gustafsson,
-  Daniel J. H., Daniel McCarney, Daniel Stenberg, Dmitry Karpov,
-  Emanuele Torre, Evgeny Grin (Karlson2k), Fabian Keil, farazrbx on github,
-  fuzzard, Gisle Vanem, GonÃ§alo Carvalho, Gusted, hammlee96 on github,
-  Harmen Stoppels, Harry Sintonen, Hongfei Li, Ivan, Jan Macku, Jan Venekamp,
-  Jeff King, Jeroen Ooms, JÃ©rÃ´me Leclercq, Jiwoo Park,
-  Johann Sebastian Schicho, Jonatan Vela, Joseph Chen, Juliusz Sosinowicz,
-  Kailun Qin, kalvdans on github, Keitagit-kun on github, Konstantin Kuzov,
-  kpcyrd on github, Laramie Leavitt, LigH, Lucas Nussbaum,
-  magisterquis on hackerone, Marcel Raad, Matt Jolly, Max Dymond, Mel Zuser,
-  Michael Kaufmann, Michael Litwak, MichaÅ‚ Antoniak, Nathan Moinvaziri,
-  Orgad Shaneh, Patrick Monnerat, Paul Gilmartin, Paul Howarth,
-  Pavel Kropachev, Pavel Pavlov, Philip Heiduck, Rahul Krishna M, RainRat,
-  Ray Satiro, renovate[bot], riastradh on github, Robert Moreton,
-  Sanjay Pujare, Sergey Bronnikov, Sergey Ogryzkov, Sergio Durigan Junior,
-  southernedge on github, Stefan Eissing, Stephen Farrell, Tal Regev,
-  Tatsuhiro Tsujikawa, Tobias Stoeckmann, Toon Claes, Trumeet on github,
-  Trzik on github, Viktor Szakats, zmcx16 on github
-  (85 contributors)
+  Aki Sakurai, Alex Snast, Anthony Hu, Daniel Stenberg, dependabot[bot],
+  Dov Murik, extrimexxx on github, Gordon Parke, Harry Sintonen,
+  icy17 on github, Ivan Kuchin, Mamoru Tasaka, Marcel Raad, Patrick Monnerat,
+  Randall S. Becker, Sergey, Stefan Eissing, Tal Regev, Viktor Szakats
+  (19 contributors)
 
 References to bug reports and discussions on issues:
 
- [1] = https://curl.se/bug/?i=13198
- [2] = https://curl.se/bug/?i=13191
- [3] = https://curl.se/bug/?i=13205
- [4] = https://curl.se/bug/?i=13220
- [5] = https://curl.se/bug/?i=13209
- [6] = https://curl.se/bug/?i=13213
- [7] = https://curl.se/bug/?i=13216
- [8] = https://curl.se/bug/?i=13208
- [9] = https://curl.se/bug/?i=13210
- [10] = https://curl.se/bug/?i=13203
- [11] = https://curl.se/bug/?i=13171
- [12] = https://curl.se/bug/?i=13247
- [13] = https://curl.se/bug/?i=13245
- [14] = https://curl.se/bug/?i=13214
- [15] = https://curl.se/bug/?i=13207
- [16] = https://curl.se/bug/?i=13236
- [17] = https://curl.se/bug/?i=13240
- [18] = https://curl.se/bug/?i=13224
- [19] = https://curl.se/bug/?i=13228
- [20] = https://curl.se/bug/?i=13230
- [21] = https://curl.se/bug/?i=13225
- [22] = https://curl.se/bug/?i=13200
- [23] = https://curl.se/bug/?i=13206
- [24] = https://curl.se/bug/?i=13197
- [25] = https://curl.se/bug/?i=13272
- [26] = https://curl.se/bug/?i=13371
- [27] = https://curl.se/bug/?i=13267
- [28] = https://curl.se/bug/?i=13268
- [29] = https://curl.se/bug/?i=13263
- [30] = https://curl.se/bug/?i=13281
- [31] = https://curl.se/bug/?i=13229
- [32] = https://curl.se/bug/?i=13244
- [33] = https://curl.se/bug/?i=13254
- [34] = https://curl.se/bug/?i=13135
- [35] = https://curl.se/bug/?i=13239
- [36] = https://curl.se/bug/?i=13242
- [37] = https://curl.se/bug/?i=13274
- [38] = https://curl.se/bug/?i=13299
- [39] = https://curl.se/bug/?i=13301
- [40] = https://curl.se/bug/?i=13327
- [41] = https://curl.se/bug/?i=12665
- [42] = https://curl.se/bug/?i=13294
- [43] = https://curl.se/bug/?i=13290
- [44] = https://curl.se/bug/?i=13258
- [45] = https://curl.se/bug/?i=13223
- [46] = https://curl.se/bug/?i=13188
- [47] = https://curl.se/bug/?i=13286
- [48] = https://curl.se/bug/?i=13282
- [49] = https://curl.se/bug/?i=13287
- [50] = https://curl.se/bug/?i=13284
- [51] = https://curl.se/bug/?i=13283
- [52] = https://curl.se/bug/?i=13269
- [53] = https://curl.se/bug/?i=13346
- [54] = https://curl.se/bug/?i=13260
- [55] = https://curl.se/bug/?i=13265
- [56] = https://curl.se/bug/?i=13322
- [57] = https://curl.se/bug/?i=13172
- [58] = https://curl.se/bug/?i=13218
- [59] = https://curl.se/bug/?i=13364
- [60] = https://curl.se/bug/?i=13313
- [61] = https://curl.se/bug/?i=13348
- [62] = https://curl.se/bug/?i=13344
- [63] = https://curl.se/bug/?i=13137
- [64] = https://curl.se/bug/?i=13264
- [65] = https://curl.se/bug/?i=13292
- [66] = https://curl.se/bug/?i=13314
- [67] = https://curl.se/bug/?i=13249
- [68] = https://curl.se/bug/?i=13335
- [69] = https://curl.se/bug/?i=13315
- [70] = https://curl.se/bug/?i=13307
- [71] = https://curl.se/bug/?i=13310
- [72] = https://curl.se/bug/?i=13309
- [73] = https://curl.se/bug/?i=13368
- [74] = https://curl.se/bug/?i=13372
- [75] = https://curl.se/bug/?i=13339
- [76] = https://curl.se/bug/?i=13427
- [77] = https://curl.se/bug/?i=13332
- [78] = https://curl.se/bug/?i=13398
- [79] = https://curl.se/bug/?i=13311
- [80] = https://curl.se/bug/?i=13324
- [81] = https://curl.se/bug/?i=13276
- [82] = https://curl.se/bug/?i=13367
- [83] = https://curl.se/bug/?i=13394
- [84] = https://curl.se/bug/?i=13352
- [85] = https://curl.se/bug/?i=13349
- [86] = https://curl.se/bug/?i=13399
- [87] = https://curl.se/bug/?i=13321
- [88] = https://curl.se/bug/?i=13426
- [89] = https://curl.se/bug/?i=13425
- [90] = https://curl.se/bug/?i=13393
- [91] = https://curl.se/bug/?i=13392
- [92] = https://curl.se/bug/?i=13204
- [93] = https://curl.se/bug/?i=13232
- [94] = https://curl.se/bug/?i=13411
- [95] = https://curl.se/bug/?i=13246
- [96] = https://curl.se/bug/?i=13423
- [97] = https://curl.se/bug/?i=13387
- [98] = https://curl.se/bug/?i=13422
- [99] = https://curl.se/bug/?i=13419
- [100] = https://curl.se/bug/?i=13421
- [101] = https://curl.se/bug/?i=13418
- [102] = https://curl.se/bug/?i=13417
- [103] = https://curl.se/bug/?i=13442
- [104] = https://curl.se/bug/?i=13337
- [105] = https://curl.se/bug/?i=13407
- [106] = https://curl.se/bug/?i=13405
- [107] = https://curl.se/bug/?i=13377
- [108] = https://curl.se/bug/?i=13373
- [109] = https://curl.se/bug/?i=11922
- [110] = https://curl.se/bug/?i=13499
- [111] = https://curl.se/bug/?i=13396
- [112] = https://curl.se/bug/?i=13457
- [113] = https://curl.se/bug/?i=13450
- [114] = https://curl.se/bug/?i=12327
- [115] = https://curl.se/bug/?i=13452
- [116] = https://curl.se/bug/?i=13439
- [117] = https://curl.se/bug/?i=13445
- [118] = https://curl.se/bug/?i=13432
- [119] = https://curl.se/bug/?i=13436
- [120] = https://curl.se/bug/?i=13437
- [121] = https://curl.se/bug/?i=13433
- [122] = https://curl.se/bug/?i=13435
- [123] = https://curl.se/bug/?i=13434
- [124] = https://curl.se/bug/?i=13430
- [125] = https://curl.se/bug/?i=13497
- [126] = https://curl.se/bug/?i=13464
- [127] = https://curl.se/bug/?i=13494
- [128] = https://curl.se/bug/?i=13491
- [129] = https://curl.se/bug/?i=13475
- [130] = https://curl.se/bug/?i=13386
- [131] = https://curl.se/bug/?i=13150
- [132] = https://curl.se/bug/?i=13510
- [133] = https://curl.se/bug/?i=13355
- [134] = https://curl.se/bug/?i=13471
- [135] = https://curl.se/bug/?i=13508
- [136] = https://curl.se/bug/?i=13174
- [137] = https://curl.se/bug/?i=13451
- [138] = https://curl.se/bug/?i=13458
- [139] = https://curl.se/bug/?i=13467
- [140] = https://curl.se/bug/?i=13562
- [141] = https://curl.se/bug/?i=13495
- [142] = https://curl.se/bug/?i=13505
- [143] = https://curl.se/bug/?i=13503
- [144] = https://curl.se/bug/?i=13502
- [145] = https://curl.se/bug/?i=13498
- [146] = https://curl.se/bug/?i=13500
- [147] = https://curl.se/bug/?i=13557
- [148] = https://curl.se/bug/?i=13602
- [149] = https://curl.se/bug/?i=13568
- [150] = https://curl.se/bug/?i=13567
- [151] = https://curl.se/bug/?i=13604
- [152] = https://curl.se/bug/?i=13566
- [153] = https://curl.se/bug/?i=13601
- [154] = https://curl.se/bug/?i=13554
- [155] = https://curl.se/bug/?i=13237
- [156] = https://curl.se/bug/?i=13539
- [157] = https://curl.se/bug/?i=13549
- [158] = https://curl.se/bug/?i=13550
- [159] = https://curl.se/bug/?i=13553
- [160] = https://curl.se/bug/?i=13551
- [161] = https://curl.se/bug/?i=13509
- [162] = https://curl.se/bug/?i=13542
- [163] = https://curl.se/bug/?i=13529
- [164] = https://curl.se/bug/?i=13540
- [165] = https://curl.se/bug/?i=13600
- [166] = https://curl.se/bug/?i=13541
- [167] = https://curl.se/bug/?i=13538
- [168] = https://curl.se/bug/?i=13534
- [169] = https://curl.se/bug/?i=13536
- [170] = https://curl.se/bug/?i=13725
- [171] = https://curl.se/bug/?i=13537
- [172] = https://curl.se/bug/?i=13531
- [173] = https://curl.se/bug/?i=13504
- [174] = https://curl.se/bug/?i=13533
- [175] = https://curl.se/bug/?i=13590
- [176] = https://curl.se/bug/?i=13591
- [177] = https://curl.se/bug/?i=13605
- [178] = https://curl.se/bug/?i=13501
- [179] = https://curl.se/bug/?i=13578
- [180] = https://curl.se/bug/?i=13574
- [181] = https://curl.se/bug/?i=13580
- [182] = https://curl.se/bug/?i=13582
- [183] = https://curl.se/bug/?i=13588
- [184] = https://curl.se/bug/?i=13584
- [185] = https://curl.se/bug/?i=13586
- [186] = https://curl.se/bug/?i=13579
- [187] = https://curl.se/bug/?i=13664
- [188] = https://curl.se/bug/?i=13577
- [189] = https://curl.se/bug/?i=13576
- [190] = https://curl.se/bug/?i=13581
- [191] = https://curl.se/bug/?i=13728
- [192] = https://curl.se/bug/?i=13672
- [193] = https://curl.se/bug/?i=13654
- [194] = https://curl.se/bug/?i=13628
- [195] = https://curl.se/bug/?i=13655
- [196] = https://curl.se/bug/?i=13710
- [197] = https://curl.se/bug/?i=13707
- [198] = https://curl.se/bug/?i=13729
- [199] = https://curl.se/bug/?i=13544
- [200] = https://curl.se/bug/?i=13733
- [201] = https://curl.se/bug/?i=13583
- [203] = https://curl.se/bug/?i=13697
- [206] = https://curl.se/bug/?i=13661
- [207] = https://curl.se/bug/?i=13686
- [208] = https://curl.se/bug/?i=13684
- [209] = https://curl.se/bug/?i=13639
- [210] = https://curl.se/bug/?i=13560
- [211] = https://curl.se/bug/?i=13638
- [212] = https://curl.se/bug/?i=13603
- [213] = https://curl.se/bug/?i=13611
- [214] = https://curl.se/bug/?i=13634
- [215] = https://curl.se/bug/?i=13681
- [216] = https://curl.se/bug/?i=13624
- [217] = https://curl.se/bug/?i=13614
- [218] = https://curl.se/bug/?i=13621
- [219] = https://curl.se/bug/?i=13619
- [220] = https://curl.se/bug/?i=13610
- [221] = https://curl.se/bug/?i=13608
- [222] = https://curl.se/bug/?i=13643
- [223] = https://curl.se/bug/?i=13618
- [224] = https://curl.se/bug/?i=13676
- [225] = https://curl.se/bug/?i=13679
- [226] = https://curl.se/bug/?i=13487
- [227] = https://curl.se/bug/?i=13668
- [229] = https://curl.se/bug/?i=13666
- [230] = https://curl.se/bug/?i=13670
+ [1] = https://curl.se/bug/?i=14267
+ [2] = https://curl.se/bug/?i=14289
+ [3] = https://curl.se/bug/?i=14287
+ [4] = https://curl.se/bug/?i=14284
+ [5] = https://curl.se/bug/?i=14281
+ [6] = https://curl.se/bug/?i=14272
+ [7] = https://curl.se/bug/?i=14268
+ [8] = https://curl.se/bug/?i=14247
+ [9] = https://curl.se/bug/?i=14302
+ [10] = https://curl.se/bug/?i=14199
+ [11] = https://curl.se/bug/?i=14306
+ [12] = https://curl.se/bug/?i=14285
+ [13] = https://curl.se/bug/?i=14269
+ [14] = https://curl.se/bug/?i=14278
+ [15] = https://curl.se/bug/?i=14316
+ [17] = https://curl.se/bug/?i=14280
+ [18] = https://curl.se/bug/?i=14295
+ [19] = https://curl.se/bug/?i=14293
+ [20] = https://curl.se/bug/?i=14292
+ [21] = https://curl.se/bug/?i=14304
+ [22] = https://curl.se/bug/?i=14196
+ [23] = https://curl.se/bug/?i=14305
+ [24] = https://curl.se/bug/?i=14318
+ [25] = https://curl.se/bug/?i=14309
+ [26] = https://curl.se/bug/?i=14312
diff --git a/REUSE.toml b/REUSE.toml
new file mode 100644
index 000000000..c973868b4
--- /dev/null
+++ b/REUSE.toml
@@ -0,0 +1,53 @@
+# SPDX-License-Identifier: curl
+# SPDX-FileCopyrightText: Daniel Stenberg, <daniel@haxx.se>, et al.
+
+# This file describes the licensing and copyright situation for files that
+# cannot be annotated directly, for example because of being simply
+# uncommentable. Unless this is the case, a file should be annotated directly.
+#
+# This follows the REUSE specification: https://reuse.software/spec-3.2/#reusetoml
+
+version = 1
+SPDX-PackageName = "curl"
+SPDX-PackageDownloadLocation = "https://curl.se/"
+
+[[annotations]]
+path = [
+  ".mailmap",
+  "CHANGES",
+  "docs/FAQ",
+  "docs/INSTALL",
+  "docs/KNOWN_BUGS",
+  "docs/libcurl/symbols-in-versions",
+  "docs/MAIL-ETIQUETTE",
+  "docs/options-in-versions",
+  "docs/THANKS",
+  "docs/TODO",
+  "GIT-INFO.md",
+  "lib/libcurl.vers.in",
+  "libcurl.def",
+  "packages/OS400/README.OS400",
+  "packages/vms/build_vms.com",
+  "packages/vms/curl_release_note_start.txt",
+  "packages/vms/curlmsg.sdl",
+  "packages/vms/macro32_exactcase.patch",
+  "packages/vms/readme",
+  "plan9/README",
+  "projects/Windows/**", "projects/wolfssl_override.props",
+  "README",
+  "RELEASE-NOTES",
+  "renovate.json",
+  "tests/certs/**",
+  "tests/data/test**",
+  "tests/stunnel.pem",
+  "tests/valgrind.supp",
+  # checksrc control files
+  "docs/examples/.checksrc",
+  "lib/.checksrc",
+  "src/.checksrc",
+  "tests/libtest/.checksrc",
+]
+SPDX-FileCopyrightText = "Daniel Stenberg, <daniel@haxx.se>, et al."
+SPDX-License-Identifier = "curl"
+# If there is licensing/copyright information in or next to these files, prefer that
+precedence = "closest"
diff --git a/acinclude.m4 b/acinclude.m4
index a44ae350e..7a26ecedc 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -94,7 +94,7 @@ int main (void)
 #ifdef $1
   return 0;
 #else
-  force compilation error
+  #error force compilation error
 #endif
 }
     ]])
@@ -130,7 +130,7 @@ int main (void)
 #elif defined(__hpux) && defined(_XOPEN_SOURCE_EXTENDED)
   return 0;
 #else
-  force compilation error
+  #error force compilation error
 #endif
 }
     ]])
@@ -1256,24 +1256,19 @@ AS_HELP_STRING([--without-ca-path], [Don't use a default CA path]),
     capath="no"
   elif test "x$want_capath" != "xno" -a "x$want_capath" != "xunset"; then
     dnl --with-ca-path given
-    if test "x$OPENSSL_ENABLED" != "x1" -a \
-            "x$GNUTLS_ENABLED" != "x1" -a \
-            "x$MBEDTLS_ENABLED" != "x1" -a \
-            "x$WOLFSSL_ENABLED" != "x1"; then
-      AC_MSG_ERROR([--with-ca-path only works with OpenSSL, GnuTLS, mbedTLS or wolfSSL])
-    fi
     capath="$want_capath"
     ca="no"
   else
-    dnl first try autodetecting a CA bundle , then a CA path
-    dnl both autodetections can be skipped by --without-ca-*
+    dnl First try auto-detecting a CA bundle, then a CA path.
+    dnl Both auto-detections can be skipped by --without-ca-*
     ca="no"
     capath="no"
-    if test "x$cross_compiling" != "xyes"; then
+    if test "x$cross_compiling" != "xyes" -a \
+            "x$curl_cv_native_windows" != "xyes"; then
       dnl NOT cross-compiling and...
       dnl neither of the --with-ca-* options are provided
       if test "x$want_ca" = "xunset"; then
-        dnl the path we previously would have installed the curl ca bundle
+        dnl the path we previously would have installed the curl CA bundle
         dnl to, and thus we now check for an already existing cert in that
         dnl place in case we find no other
         if test "x$prefix" != xNONE; then
@@ -1296,12 +1291,7 @@ AS_HELP_STRING([--without-ca-path], [Don't use a default CA path]),
       fi
       AC_MSG_NOTICE([want $want_capath ca $ca])
       if test "x$want_capath" = "xunset"; then
-        if test "x$OPENSSL_ENABLED" = "x1" -o \
-                "x$GNUTLS_ENABLED" = "x1" -o \
-                "x$MBEDTLS_ENABLED" = "x1" -o \
-                "x$WOLFSSL_ENABLED" = "x1"; then
-          check_capath="/etc/ssl/certs"
-        fi
+        check_capath="/etc/ssl/certs"
       fi
     else
       dnl no option given and cross-compiling
@@ -1649,9 +1639,8 @@ AC_DEFUN([CURL_SUPPORTS_BUILTIN_AVAILABLE], [
   AC_MSG_CHECKING([to see if the compiler supports __builtin_available()])
   AC_COMPILE_IFELSE([
     AC_LANG_PROGRAM([[
-#include <stdlib.h>
     ]],[[
-      if (__builtin_available(macOS 10.8, iOS 5.0, *)) {}
+      if(__builtin_available(macOS 10.12, iOS 5.0, *)) {}
     ]])
   ],[
     AC_MSG_RESULT([yes])
diff --git a/aclocal.m4 b/aclocal.m4
index a1af02ca7..9b6fbc904 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -1244,7 +1244,6 @@ m4_include([m4/lt~obsolete.m4])
 m4_include([m4/xc-am-iface.m4])
 m4_include([m4/xc-cc-check.m4])
 m4_include([m4/xc-lt-iface.m4])
-m4_include([m4/xc-translit.m4])
 m4_include([m4/xc-val-flgs.m4])
 m4_include([m4/zz40-xc-ovr.m4])
 m4_include([m4/zz50-xc-ovr.m4])
diff --git a/androidconfigure b/androidconfigure
deleted file mode 100755
index 91c1456c6..000000000
--- a/androidconfigure
+++ /dev/null
@@ -1,99 +0,0 @@
-#!/bin/bash
-
-set -e
-
-if [[ "${TARGET_PRODUCT}" != "aosp_arm" ]]; then
-  # Some of the include paths below assume that this is an arm 32bit configure
-  # run.
-  echo "Run 'lunch aosp_arm-eng' and build the current version first." >&2
-  exit 1
-fi
-
-T="${ANDROID_BUILD_TOP}"
-cd $(dirname "$0")
-
-# Build all the dependencies we'll need, so we can find them under
-# /system/lib in the out directory.
-source ${T}/build/envsetup.sh
-mm
-
-HOST="arm-linux-androideabi"
-CLANG_VERSION="$(exec ${T}/build/soong/scripts/get_clang_version.py)"
-export CC="${T}/prebuilts/clang/host/linux-x86/${CLANG_VERSION}/bin/clang"
-export LD="${T}/prebuilts/clang/host/linux-x86/${CLANG_VERSION}/bin/lld"
-
-CFLAGS=(
-  # We don't have an NDK sysroot prebuilt in AOSP, so we'll have use
-  # soong's.
-  "--sysroot ${T}/out/soong/ndk/sysroot/"
-  # We also need zlib. (We don't have to do anything for boringssl here,
-  # because we provide that path directly on the configure command line.)
-  "-I${T}/external/zlib/"
-  # We don't have target-specific clang binaries like the NDK, so provide
-  # a target. The "34" here is arbitrary.
-  "--target=armv7a-linux-androideabi34"
-)
-CFLAGS="${CFLAGS[@]}"
-
-LDFLAGS=(
-  # We need the device zlib and openssl/boringssl libraries, so tell ld
-  # where they are.
-  "-L${ANDROID_PRODUCT_OUT}/system/lib/"
-)
-LDFLAGS="${LDFLAGS[@]}"
-
-CONFIGURE_ARGS=(
-  --host="${HOST}"
-  CFLAGS="${CFLAGS}"
-  CPPFLAGS="${CFLAGS}"
-  LDFLAGS="${LDFLAGS}"
-
-  # Disable NTLM delegation to winbind's ntlm_auth.
-  --disable-ntlm-wb
-
-  ### Disable many protocols unused in Android systems:
-  --disable-telnet
-  --disable-tftp
-  --disable-smb
-  --disable-gopher
-
-  # Disable FTP and FTPS support.
-  --disable-ftp
-
-  # Disable LDAP and LDAPS support.
-  --disable-ldap
-  --disable-ldaps
-
-  # Disable mail protocols (IMAP, POP3).
-  --disable-pop3
-  --disable-imap
-  --disable-smtp
-
-  # Disable RTSP support (RFC 2326 / 7826).
-  --disable-rtsp
-
-  # Disable DICT support (RFC 2229).
-  --disable-dict
-
-  ### Enable HTTP and FILE explicitly. These are enabled by default but
-  # listed here as documentation.
-  --enable-http
-  --enable-file
-  --enable-proxy
-
-  # Enabled IPv6.
-  --enable-ipv6
-
-  --with-ssl="${T}/external/boringssl"
-  --with-zlib
-  --with-ca-path="/system/etc/security/cacerts"
-)
-
-# Show the commands on the terminal.
-set -x
-
-./buildconf
-./configure "${CONFIGURE_ARGS[@]}"
-
-# Apply local changes to the default configure output.
-patch -p1 --no-backup-if-mismatch < local-configure.patch
diff --git a/appveyor.sh b/appveyor.sh
index 9a71c9b7c..9e5dac84c 100644
--- a/appveyor.sh
+++ b/appveyor.sh
@@ -33,17 +33,18 @@ if [ "${APPVEYOR_BUILD_WORKER_IMAGE}" = 'Visual Studio 2022' ]; then
 else
   openssl_root_win='C:/OpenSSL-v111-Win64'
 fi
-openssl_root="$(cygpath -u "${openssl_root_win}")"
+openssl_root="$(cygpath "${openssl_root_win}")"
 
 if [ "${BUILD_SYSTEM}" = 'CMake' ]; then
   options=''
   [[ "${TARGET:-}" = *'ARM64'* ]] && SKIP_RUN='ARM64 architecture'
   [ "${OPENSSL}" = 'ON' ] && options+=" -DOPENSSL_ROOT_DIR=${openssl_root_win}"
+  [ -n "${CURLDEBUG:-}" ] && options+=" -DENABLE_CURLDEBUG=${CURLDEBUG}"
   [ "${PRJ_CFG}" = 'Debug' ] && options+=' -DCMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG='
   [ "${PRJ_CFG}" = 'Release' ] && options+=' -DCMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE='
   [[ "${PRJ_GEN}" = *'Visual Studio'* ]] && options+=' -DCMAKE_VS_GLOBALS=TrackFileAccess=false'
   if [ "${PRJ_GEN}" = 'Visual Studio 9 2008' ]; then
-    [ "${PRJ_CFG}" = 'Debug' ] && [ "${DEBUG}" = 'ON' ] && [ "${SHARED}" = 'ON' ] && SKIP_RUN='Crash on startup in -DDEBUGBUILD shared builds'
+    [ "${DEBUG}" = 'ON' ] && [ "${SHARED}" = 'ON' ] && SKIP_RUN='Crash on startup in ENABLE_DEBUG=ON shared builds'
     # Fails to run without this due to missing MSVCR90.dll / MSVCR90D.dll
     options+=' -DCURL_STATIC_CRT=ON'
   fi
@@ -53,7 +54,6 @@ if [ "${BUILD_SYSTEM}" = 'CMake' ]; then
     "-DCURL_USE_SCHANNEL=${SCHANNEL}" \
     "-DHTTP_ONLY=${HTTP_ONLY}" \
     "-DBUILD_SHARED_LIBS=${SHARED}" \
-    "-DBUILD_TESTING=${TESTING}" \
     "-DENABLE_WEBSOCKETS=${WEBSOCKETS:-}" \
     "-DCMAKE_UNITY_BUILD=${UNITY}" \
     '-DCURL_WERROR=ON' \
@@ -62,12 +62,18 @@ if [ "${BUILD_SYSTEM}" = 'CMake' ]; then
     '-DCMAKE_INSTALL_PREFIX=C:/curl' \
     "-DCMAKE_BUILD_TYPE=${PRJ_CFG}"
   # shellcheck disable=SC2086
-  cmake --build _bld --config "${PRJ_CFG}" --parallel 2 -- ${BUILD_OPT:-}
+  if ! cmake --build _bld --config "${PRJ_CFG}" --parallel 2 -- ${BUILD_OPT:-}; then
+    if [ "${PRJ_GEN}" = 'Visual Studio 9 2008' ]; then
+      find . -name BuildLog.htm -exec dos2unix '{}' +
+      find . -name BuildLog.htm -exec cat '{}' +
+    fi
+    false
+  fi
   if [ "${SHARED}" = 'ON' ]; then
-    cp -f -p _bld/lib/*.dll _bld/src/
+    PATH="$PWD/_bld/lib:$PATH"
   fi
   if [ "${OPENSSL}" = 'ON' ]; then
-    cp -f -p "${openssl_root}"/*.dll _bld/src/
+    PATH="$PWD/_bld/lib:${openssl_root}:$PATH"
   fi
   curl='_bld/src/curl.exe'
 elif [ "${BUILD_SYSTEM}" = 'VisualStudioSolution' ]; then
@@ -117,19 +123,23 @@ if false; then
   done
 fi
 
-# test
+# build tests
+
+if [[ "${TFLAGS}" != 'skipall' ]] && \
+   [ "${BUILD_SYSTEM}" = 'CMake' ]; then
+  cmake --build _bld --config "${PRJ_CFG}" --parallel 2 --target testdeps
+fi
+
+# run tests
 
-if [ "${TESTING}" = 'ON' ]; then
-  export TFLAGS=''
-  if [ -x "$(cygpath -u "${WINDIR}/System32/curl.exe")" ]; then
-    TFLAGS+=" -ac $(cygpath -u "${WINDIR}/System32/curl.exe")"
-  elif [ -x "$(cygpath -u 'C:/msys64/usr/bin/curl.exe')" ]; then
-    TFLAGS+=" -ac $(cygpath -u 'C:/msys64/usr/bin/curl.exe')"
+if [[ "${TFLAGS}" != 'skipall' ]] && \
+   [[ "${TFLAGS}" != 'skiprun' ]]; then
+  if [ -x "$(cygpath "${SYSTEMROOT}/System32/curl.exe")" ]; then
+    TFLAGS+=" -ac $(cygpath "${SYSTEMROOT}/System32/curl.exe")"
+  elif [ -x "$(cygpath 'C:/msys64/usr/bin/curl.exe')" ]; then
+    TFLAGS+=" -ac $(cygpath 'C:/msys64/usr/bin/curl.exe')"
   fi
-  TFLAGS+=" ${DISABLED_TESTS:-}"
   if [ "${BUILD_SYSTEM}" = 'CMake' ]; then
-    cmake --build _bld --config "${PRJ_CFG}" --parallel 2 --target testdeps
-    ls _bld/lib/*.dll >/dev/null 2>&1 && cp -f -p _bld/lib/*.dll _bld/tests/libtest/
     cmake --build _bld --config "${PRJ_CFG}" --target test-ci
   else
     (
diff --git a/appveyor.yml b/appveyor.yml
index 33f5b35ca..bc0cb4a15 100644
--- a/appveyor.yml
+++ b/appveyor.yml
@@ -35,19 +35,21 @@ environment:
   OPENSSL: 'OFF'
   DEBUG: 'ON'
   SHARED: 'OFF'
+  TFLAGS: 'skipall'
   matrix:
-    # generated CMake-based Visual Studio Release builds
+
+    # generated CMake-based Visual Studio builds
+
     - job_name: 'CMake, VS2008, Release, x86, Schannel, Build-only'
       APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2015'
       BUILD_SYSTEM: CMake
       PRJ_GEN: 'Visual Studio 9 2008'
       PRJ_CFG: Release
+      DEBUG: 'OFF'
       SCHANNEL: 'ON'
       ENABLE_UNICODE: 'OFF'
       HTTP_ONLY: 'OFF'
       SHARED: 'ON'
-      TESTING: 'OFF'
-      DISABLED_TESTS: ''
     - job_name: 'CMake, VS2008, Debug, x86, Schannel, Build-only'
       APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2015'
       BUILD_SYSTEM: CMake
@@ -57,8 +59,6 @@ environment:
       ENABLE_UNICODE: 'OFF'
       HTTP_ONLY: 'OFF'
       SHARED: 'ON'
-      TESTING: 'OFF'
-      DISABLED_TESTS: ''
     - job_name: 'CMake, VS2022, Release, x64, OpenSSL 3.2, WebSockets, Build-only'
       APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2022'
       BUILD_SYSTEM: CMake
@@ -70,10 +70,8 @@ environment:
       ENABLE_UNICODE: 'OFF'
       HTTP_ONLY: 'OFF'
       SHARED: 'ON'
-      TESTING: 'OFF'
-      DISABLED_TESTS: ''
       WEBSOCKETS: 'ON'
-    - job_name: 'CMake, VS2022, Release, arm64, Schannel, Static, Build-only'
+    - job_name: 'CMake, VS2022, Release, arm64, Schannel, Static, Build-tests'
       APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2022'
       BUILD_SYSTEM: CMake
       PRJ_GEN: 'Visual Studio 17 2022'
@@ -82,9 +80,9 @@ environment:
       SCHANNEL: 'ON'
       ENABLE_UNICODE: 'OFF'
       HTTP_ONLY: 'OFF'
-      TESTING: 'OFF'
-      DISABLED_TESTS: ''
-    # generated CMake-based Visual Studio Debug builds
+      DEBUG: 'OFF'
+      CURLDEBUG: 'ON'
+      TFLAGS: 'skiprun'
     - job_name: 'CMake, VS2010, Debug, x64, Schannel, Static, Build-only'
       APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2015'
       BUILD_SYSTEM: CMake
@@ -93,9 +91,7 @@ environment:
       SCHANNEL: 'ON'
       ENABLE_UNICODE: 'OFF'
       HTTP_ONLY: 'OFF'
-      TESTING: 'OFF'
-      DISABLED_TESTS: ''
-    - job_name: 'CMake, VS2022, Debug, x64, Schannel, Static, Unicode'
+    - job_name: 'CMake, VS2022, Debug, x64, Schannel, Static, Unicode, Build-only'
       APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2022'
       BUILD_SYSTEM: CMake
       PRJ_GEN: 'Visual Studio 17 2022'
@@ -104,20 +100,18 @@ environment:
       SCHANNEL: 'ON'
       ENABLE_UNICODE: 'ON'
       HTTP_ONLY: 'OFF'
-      TESTING: 'ON'
-      DISABLED_TESTS: '!1139 !1501 !1177 !1477'
-    - job_name: 'CMake, VS2022, Debug, x64, no SSL, Static'
+    - job_name: 'CMake, VS2022, Release, x64, Schannel, Shared, Unicode, DEBUGBULID, no-CURLDEBUG, Build-only'
       APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2022'
       BUILD_SYSTEM: CMake
       PRJ_GEN: 'Visual Studio 17 2022'
       TARGET: '-A x64'
-      PRJ_CFG: Debug
-      SCHANNEL: 'OFF'
-      ENABLE_UNICODE: 'OFF'
+      PRJ_CFG: Release
+      SCHANNEL: 'ON'
+      ENABLE_UNICODE: 'ON'
       HTTP_ONLY: 'OFF'
-      TESTING: 'ON'
-      DISABLED_TESTS: '!1139 !1501 !1177 !1477'
-    - job_name: 'CMake, VS2022, Debug, x64, no SSL, Static, HTTP only'
+      SHARED: 'ON'
+      CURLDEBUG: 'OFF'
+    - job_name: 'CMake, VS2022, Debug, x64, no SSL, Static, Build-only'
       APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2022'
       BUILD_SYSTEM: CMake
       PRJ_GEN: 'Visual Studio 17 2022'
@@ -125,54 +119,16 @@ environment:
       PRJ_CFG: Debug
       SCHANNEL: 'OFF'
       ENABLE_UNICODE: 'OFF'
-      HTTP_ONLY: 'ON'
-      TESTING: 'ON'
-      DISABLED_TESTS: '!1139 !1501 !1177 !1477'
-
-    # generated CMake-based MSYS Makefiles builds (mingw cross-compiling)
-
-    - job_name: 'CMake, mingw-w64, gcc 7, Debug, x64, Schannel, Static, Unicode'
-      APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2017'
-      BUILD_SYSTEM: CMake
-      PRJ_GEN: 'MSYS Makefiles'
-      PRJ_CFG: Debug
-      SCHANNEL: 'ON'
-      ENABLE_UNICODE: 'ON'
-      HTTP_ONLY: 'OFF'
-      TESTING: 'ON'
-      # test 286 disabled due to https://github.com/curl/curl/issues/12040
-      DISABLED_TESTS: '~286 !1086 !1139 !1451 !1501 !1177 !1477'
-      ADD_PATH: 'C:/mingw-w64/x86_64-7.2.0-posix-seh-rt_v5-rev1/mingw64/bin'
-      MSYS2_ARG_CONV_EXCL: '/*'
-      BUILD_OPT: -k
-    - job_name: 'CMake, mingw-w64, gcc 9, Debug, x64, Schannel, Static'
-      APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2017'
-      BUILD_SYSTEM: CMake
-      PRJ_GEN: 'MSYS Makefiles'
-      PRJ_CFG: Debug
-      SCHANNEL: 'ON'
-      ENABLE_UNICODE: 'OFF'
       HTTP_ONLY: 'OFF'
-      TESTING: 'ON'
-      # test 286 disabled due to https://github.com/curl/curl/issues/12040
-      DISABLED_TESTS: '~286 !1086 !1139 !1451 !1501 !1177 !1477'
-      ADD_PATH: 'C:/msys64/mingw64/bin'
-      MSYS2_ARG_CONV_EXCL: '/*'
-      BUILD_OPT: -k
-    - job_name: 'CMake, mingw-w64, gcc 6, Debug, x86, Schannel, Static, no-unity'
-      APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2015'
+    - job_name: 'CMake, VS2022, Debug, x64, no SSL, Static, HTTP only, Build-only'
+      APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2022'
       BUILD_SYSTEM: CMake
-      PRJ_GEN: 'MSYS Makefiles'
+      PRJ_GEN: 'Visual Studio 17 2022'
+      TARGET: '-A x64'
       PRJ_CFG: Debug
-      SCHANNEL: 'ON'
+      SCHANNEL: 'OFF'
       ENABLE_UNICODE: 'OFF'
-      HTTP_ONLY: 'OFF'
-      TESTING: 'OFF'
-      DISABLED_TESTS: ''
-      ADD_PATH: 'C:/mingw-w64/i686-6.3.0-posix-dwarf-rt_v5-rev1/mingw32/bin'
-      MSYS2_ARG_CONV_EXCL: '/*'
-      BUILD_OPT: -k
-      UNITY: 'OFF'
+      HTTP_ONLY: 'ON'
 
     # winbuild-based builds
 
@@ -181,56 +137,48 @@ environment:
       BUILD_SYSTEM: winbuild_vs2015
       DEBUG: 'yes'
       PATHPART: debug
-      TESTING: 'OFF'
       ENABLE_UNICODE: 'no'
     - job_name: 'winbuild, VS2015, Release, x64, OpenSSL 1.1.1, Build-only'
       APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2015'
       BUILD_SYSTEM: winbuild_vs2015
       DEBUG: 'no'
       PATHPART: release
-      TESTING: 'OFF'
       ENABLE_UNICODE: 'no'
     - job_name: 'winbuild, VS2017, Debug, x64, OpenSSL 1.1.1, Build-only'
       APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2017'
       BUILD_SYSTEM: winbuild_vs2017
       DEBUG: 'yes'
       PATHPART: debug
-      TESTING: 'OFF'
       ENABLE_UNICODE: 'no'
     - job_name: 'winbuild, VS2017, Release, x64, OpenSSL 1.1.1, Build-only'
       APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2017'
       BUILD_SYSTEM: winbuild_vs2017
       DEBUG: 'no'
       PATHPART: release
-      TESTING: 'OFF'
       ENABLE_UNICODE: 'no'
     - job_name: 'winbuild, VS2015, Debug, x64, OpenSSL 1.1.1, Unicode, Build-only'
       APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2015'
       BUILD_SYSTEM: winbuild_vs2015
       DEBUG: 'yes'
       PATHPART: debug
-      TESTING: 'OFF'
       ENABLE_UNICODE: 'yes'
     - job_name: 'winbuild, VS2015, Release, x64, OpenSSL 1.1.1, Unicode, Build-only'
       APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2015'
       BUILD_SYSTEM: winbuild_vs2015
       DEBUG: 'no'
       PATHPART: release
-      TESTING: 'OFF'
       ENABLE_UNICODE: 'yes'
     - job_name: 'winbuild, VS2017, Debug, x64, OpenSSL 1.1.1, Unicode, Build-only'
       APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2017'
       BUILD_SYSTEM: winbuild_vs2017
       DEBUG: 'yes'
       PATHPART: debug
-      TESTING: 'OFF'
       ENABLE_UNICODE: 'yes'
     - job_name: 'winbuild, VS2017, Release, x64, OpenSSL 1.1.1, Unicode, Build-only'
       APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2017'
       BUILD_SYSTEM: winbuild_vs2017
       DEBUG: 'no'
       PATHPART: release
-      TESTING: 'OFF'
       ENABLE_UNICODE: 'yes'
 
     # generated VisualStudioSolution-based builds
@@ -239,20 +187,10 @@ environment:
       APPVEYOR_BUILD_WORKER_IMAGE: 'Visual Studio 2015'
       BUILD_SYSTEM: VisualStudioSolution
       PRJ_CFG: 'DLL Debug - DLL Windows SSPI - DLL WinIDN'
-      TESTING: 'OFF'
       VC_VERSION: VC12
 
 install:
-  - ps: |
-      if($env:ADD_SHELL -ne $null) {
-        $env:PATH = "$env:ADD_SHELL;$env:PATH"
-      }
-      else {
-        $env:PATH = "C:/msys64/usr/bin;$env:PATH"
-      }
-      if($env:ADD_PATH -ne $null) {
-        $env:PATH = "$env:ADD_PATH;$env:PATH"
-      }
+  - ps: $env:PATH = "C:/msys64/usr/bin;$env:PATH"
 
 build_script:
   - cmd: sh -c ./appveyor.sh
@@ -269,7 +207,6 @@ skip_commits:
   files:
     - '.azure-pipelines.yml'
     - '.circleci/*'
-    - '.cirrus.yml'
     - '.github/**/*'
     - 'packages/**/*'
     - 'plan9/**/*'
diff --git a/configure b/configure
index 42e8ee92b..03effc57d 100755
--- a/configure
+++ b/configure
@@ -906,6 +906,8 @@ SSL_BACKENDS
 SUPPORT_PROTOCOLS
 SUPPORT_FEATURES
 LIBCURL_NO_SHARED
+LIBCURL_PC_REQUIRES
+LIBCURL_PC_REQUIRES_PRIVATE
 ENABLE_STATIC
 ENABLE_SHARED
 CROSSCOMPILING_FALSE
@@ -1011,8 +1013,6 @@ USE_WIN32_SMALL_FILES
 USE_WIN32_LARGE_FILES
 BUILD_UNITTESTS_FALSE
 BUILD_UNITTESTS_TRUE
-CURLDEBUG_FALSE
-CURLDEBUG_TRUE
 CURL_CFLAG_EXTRAS
 DOING_NATIVE_WINDOWS_FALSE
 DOING_NATIVE_WINDOWS_TRUE
@@ -1121,6 +1121,8 @@ EGREP
 GREP
 SED
 CONFIGURE_OPTIONS
+DEBUGBUILD_FALSE
+DEBUGBUILD_TRUE
 AM_BACKSLASH
 AM_DEFAULT_VERBOSITY
 AM_DEFAULT_V
@@ -2096,7 +2098,7 @@ Optional Packages:
                           installation root
   --with-mbedtls=PATH     where to look for mbedTLS, PATH points to the
                           installation root
-  --with-wolfssl=PATH     where to look for WolfSSL, PATH points to the
+  --with-wolfssl=PATH     where to look for wolfSSL, PATH points to the
                           installation root (default: system lib default)
   --with-bearssl=PATH     where to look for BearSSL, PATH points to the
                           installation root
@@ -3601,6 +3603,14 @@ printf "%s\n" "#define DEBUGBUILD 1" >>confdefs.h
   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $want_debug" >&5
 printf "%s\n" "$want_debug" >&6; }
 
+ if test x$want_debug = xyes; then
+  DEBUGBUILD_TRUE=
+  DEBUGBUILD_FALSE='#'
+else
+  DEBUGBUILD_TRUE='#'
+  DEBUGBUILD_FALSE=
+fi
+
 
       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether to enable compiler optimizer" >&5
 printf %s "checking whether to enable compiler optimizer... " >&6; }
@@ -3832,7 +3842,6 @@ printf "%s\n" "no" >&6; }
     *)
             want_httpsrr="yes"
       curl_httpsrr_msg="enabled (--disable-httpsrr)"
-      experimental="httpsrr"
       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 printf "%s\n" "yes" >&6; }
       ;;
@@ -3864,7 +3873,6 @@ printf "%s\n" "no" >&6; }
     *)
             want_ech="yes"
       curl_ech_msg="enabled (--disable-ech)"
-      experimental="ech"
       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 printf "%s\n" "yes" >&6; }
       ;;
@@ -7330,7 +7338,7 @@ Select from these:
   --with-bearssl
   --with-gnutls
   --with-mbedtls
-  --with-openssl (also works for BoringSSL and libressl)
+  --with-openssl (also works for BoringSSL and LibreSSL)
   --with-rustls
   --with-schannel
   --with-secure-transport
@@ -7620,7 +7628,7 @@ int main (void)
 #ifdef _THREAD_SAFE
       int dummy=1;
 #else
-      force compilation error
+      #error force compilation error
 #endif
 
  ;
@@ -7706,7 +7714,7 @@ int main (void)
 #ifdef _REENTRANT
       int dummy=1;
 #else
-      force compilation error
+      #error force compilation error
 #endif
 
  ;
@@ -7786,7 +7794,7 @@ int main (void)
 #ifdef errno
         int dummy=1;
 #else
-        force compilation error
+        #error force compilation error
 #endif
 
  ;
@@ -7814,7 +7822,7 @@ int main (void)
 #ifdef errno
           int dummy=1;
 #else
-          force compilation error
+          #error force compilation error
 #endif
 
  ;
@@ -18482,6 +18490,7 @@ squeeze() {
       CLANG)
         #
                                 tmp_CFLAGS="$tmp_CFLAGS -Qunused-arguments"
+        tmp_CFLAGS="$tmp_CFLAGS -Werror-implicit-function-declaration"
         ;;
         #
       DEC_C)
@@ -19986,7 +19995,6 @@ printf "%s\n" "$as_me: WARNING: compiler options rejected: $tmp_options" >&2;}
             tmp_CFLAGS="$tmp_CFLAGS -Wimplicit-fallthrough"  # we have silencing markup for clang 10.0 and above only
           fi
         fi
-                                tmp_CFLAGS="$tmp_CFLAGS -Wno-pointer-bool-conversion"
         ;;
         #
       DEC_C)
@@ -21217,6 +21225,8 @@ if test X"$want_werror" = Xyes; then
             if test "$compiler_num" -ge "500"; then
       CURL_CFLAG_EXTRAS="$CURL_CFLAG_EXTRAS -pedantic-errors"
     fi
+  elif test "$compiler_id" = "CLANG"; then
+    CURL_CFLAG_EXTRAS="$CURL_CFLAG_EXTRAS -pedantic-errors"
   fi
 fi
 
@@ -21463,53 +21473,6 @@ printf "%s\n" "no" >&6; }
   fi
 
 
-
-      supports_curldebug="unknown"
-  if test "$want_curldebug" = "yes"; then
-    if test "x$enable_shared" != "xno" &&
-      test "x$enable_shared" != "xyes"; then
-      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: unknown enable_shared setting." >&5
-printf "%s\n" "$as_me: WARNING: unknown enable_shared setting." >&2;}
-      supports_curldebug="no"
-    fi
-    if test "x$enable_static" != "xno" &&
-      test "x$enable_static" != "xyes"; then
-      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: unknown enable_static setting." >&5
-printf "%s\n" "$as_me: WARNING: unknown enable_static setting." >&2;}
-      supports_curldebug="no"
-    fi
-    if test "$supports_curldebug" != "no"; then
-      if test "$enable_shared" = "yes" &&
-        test "x$xc_lt_shlib_use_no_undefined" = 'xyes'; then
-        supports_curldebug="no"
-        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: shared library does not support undefined symbols." >&5
-printf "%s\n" "$as_me: WARNING: shared library does not support undefined symbols." >&2;}
-      fi
-    fi
-  fi
-  #
-  if test "$want_curldebug" = "yes"; then
-    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking if curl debug memory tracking can be enabled" >&5
-printf %s "checking if curl debug memory tracking can be enabled... " >&6; }
-    test "$supports_curldebug" = "no" || supports_curldebug="yes"
-    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $supports_curldebug" >&5
-printf "%s\n" "$supports_curldebug" >&6; }
-    if test "$supports_curldebug" = "no"; then
-      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: cannot enable curl debug memory tracking." >&5
-printf "%s\n" "$as_me: WARNING: cannot enable curl debug memory tracking." >&2;}
-      want_curldebug="no"
-    fi
-  fi
-
- if test x$want_curldebug = xyes; then
-  CURLDEBUG_TRUE=
-  CURLDEBUG_FALSE='#'
-else
-  CURLDEBUG_TRUE='#'
-  CURLDEBUG_FALSE=
-fi
-
-
 supports_unittests=yes
 # cross-compilation of unit tests static library/programs fails when
 # libcurl shared library is built. This might be due to a libtool or
@@ -21739,56 +21702,8 @@ rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
   fi
 
 
-
-{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether to link macOS CoreFoundation, CoreServices, and SystemConfiguration frameworks" >&5
-printf %s "checking whether to link macOS CoreFoundation, CoreServices, and SystemConfiguration frameworks... " >&6; }
 case $host_os in
   darwin*)
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-
-#include <TargetConditionals.h>
-
-int main (void)
-{
-
-#if TARGET_OS_MAC && !(defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE)
-      return 0;
-#else
-#error Not macOS
-#endif
-
- ;
- return 0;
-}
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"
-then :
-
-      build_for_macos="yes"
-
-else $as_nop
-
-      build_for_macos="no"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
-    if test "x$build_for_macos" != xno; then
-      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-printf "%s\n" "yes" >&6; }
-      LDFLAGS="$LDFLAGS -framework CoreFoundation -framework CoreServices -framework SystemConfiguration"
-    else
-      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
-printf "%s\n" "no" >&6; }
-    fi
-    ;;
-  *)
-    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
-printf "%s\n" "no" >&6; }
-esac
-
 
   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking to see if the compiler supports __builtin_available()" >&5
 printf %s "checking to see if the compiler supports __builtin_available()... " >&6; }
@@ -21796,12 +21711,11 @@ printf %s "checking to see if the compiler supports __builtin_available()... " >
 /* end confdefs.h.  */
 
 
-#include <stdlib.h>
 
 int main (void)
 {
 
-      if (__builtin_available(macOS 10.8, iOS 5.0, *)) {}
+      if(__builtin_available(macOS 10.12, iOS 5.0, *)) {}
 
  ;
  return 0;
@@ -21825,6 +21739,8 @@ printf "%s\n" "no" >&6; }
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 
+    ;;
+esac
 
  if test "$curl_cv_native_windows" = "yes" && test -n "${RC}"; then
   HAVE_WINDRES_TRUE=
@@ -22297,6 +22213,8 @@ printf "%s\n" "#define USE_HYPER 1" >>confdefs.h
           export CURL_LIBRARY_PATH
           { printf "%s\n" "$as_me:${as_lineno-$LINENO}: Added $DIR_HYPER to CURL_LIBRARY_PATH" >&5
 printf "%s\n" "$as_me: Added $DIR_HYPER to CURL_LIBRARY_PATH" >&6;}
+          LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE hyper"
+
 fi
 
 done
@@ -22738,7 +22656,7 @@ int main (void)
 #elif defined(__hpux) && defined(_XOPEN_SOURCE_EXTENDED)
   return 0;
 #else
-  force compilation error
+  #error force compilation error
 #endif
 }
 
@@ -23971,6 +23889,7 @@ printf "%s\n" "#define HAVE_LIBZ 1" >>confdefs.h
         AMFIXLIB="1"
     { printf "%s\n" "$as_me:${as_lineno-$LINENO}: found both libz and libz.h header" >&5
 printf "%s\n" "$as_me: found both libz and libz.h header" >&6;}
+    LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE zlib"
     curl_zlib_msg="enabled"
   fi
 fi
@@ -24244,6 +24163,7 @@ done
 printf "%s\n" "$as_me: Added $DIR_BROTLI to CURL_LIBRARY_PATH" >&6;}
        fi
     fi
+    LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libbrotlidec"
   else
         LDFLAGS=$CLEANLDFLAGS
     CPPFLAGS=$CLEANCPPFLAGS
@@ -24509,6 +24429,7 @@ done
 printf "%s\n" "$as_me: Added $DIR_ZSTD to CURL_LIBRARY_PATH" >&6;}
        fi
     fi
+    LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libzstd"
   else
         LDFLAGS=$CLEANLDFLAGS
     CPPFLAGS=$CLEANCPPFLAGS
@@ -27044,8 +26965,8 @@ printf "%s\n" "no" >&6; }
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 
-    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for libressl" >&5
-printf %s "checking for libressl... " >&6; }
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for LibreSSL" >&5
+printf %s "checking for LibreSSL... " >&6; }
     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -27070,7 +26991,7 @@ printf "%s\n" "yes" >&6; }
 
 printf "%s\n" "#define HAVE_LIBRESSL 1" >>confdefs.h
 
-      ssl_msg="libressl"
+      ssl_msg="LibreSSL"
 
 else $as_nop
 
@@ -27150,6 +27071,7 @@ printf "%s\n" "$as_me: Added $LIB_OPENSSL to CURL_LIBRARY_PATH" >&6;}
        fi
     fi
     check_for_ca_bundle=1
+    LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE openssl"
   fi
 
   test -z "$ssl_msg" || ssl_backends="${ssl_backends:+$ssl_backends, }$ssl_msg"
@@ -27271,8 +27193,8 @@ fi
 fi
 
 if test "$OPENSSL_ENABLED" = "1"; then
-  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for QUIC support in OpenSSL" >&5
-printf %s "checking for QUIC support in OpenSSL... " >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for QUIC support and OpenSSL >= 3.3" >&5
+printf %s "checking for QUIC support and OpenSSL >= 3.3... " >&6; }
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -27282,6 +27204,9 @@ printf %s "checking for QUIC support in OpenSSL... " >&6; }
 int main (void)
 {
 
+      #if (OPENSSL_VERSION_NUMBER < 0x30300000L)
+      #error need at least version 3.3.0
+      #endif
       OSSL_QUIC_client_method();
 
  ;
@@ -27577,6 +27502,7 @@ printf "%s\n" "$as_me: detected GnuTLS version $version" >&6;}
 printf "%s\n" "$as_me: Added $gtlslib to CURL_LIBRARY_PATH" >&6;}
           fi
         fi
+        LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE gnutls nettle"
       fi
 
     fi
@@ -27883,6 +27809,7 @@ printf "%s\n" "$as_me: detected mbedTLS" >&6;}
 printf "%s\n" "$as_me: Added $mbedtlslib to CURL_LIBRARY_PATH" >&6;}
         fi
       fi
+      LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE mbedtls"
     fi
 
   fi
@@ -28116,7 +28043,7 @@ printf %s "checking for wolfSSL_Init in -lwolfssl... " >&6; }
 /* end confdefs.h.  */
 
 
-/* These aren't needed for detection and confuse WolfSSL.
+/* These are not needed for detection and confuse wolfSSL.
    They are set up properly later if it is detected.  */
 #undef SIZEOF_LONG
 #undef SIZEOF_LONG_LONG
@@ -28145,7 +28072,7 @@ printf "%s\n" "#define USE_WOLFSSL 1" >>confdefs.h
 
          WOLFSSL_ENABLED=1
          USE_WOLFSSL="yes"
-         ssl_msg="WolfSSL"
+         ssl_msg="wolfSSL"
          QUIC_ENABLED=yes
          test wolfssl != "$DEFAULT_SSL_BACKEND" || VALID_DEFAULT_SSL_BACKEND=yes
 
@@ -28209,7 +28136,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
   fi
   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $r" >&5
 printf "%s\n" "$r" >&6; }
-    tname=$(echo "ac_cv_sizeof_long long" | tr A-Z a-z | tr " " "_")
+    tname=`echo "ac_cv_sizeof_long long" | tr A-Z a-z | tr " " "_"`
   eval "$tname=$r"
 
 
@@ -28268,6 +28195,7 @@ fi
 printf "%s\n" "$as_me: Added $wolfssllibpath to CURL_LIBRARY_PATH" >&6;}
         fi
       fi
+      LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE wolfssl"
     else
         as_fn_error $? "--with-wolfssl but wolfSSL was not found or doesn't work" "$LINENO" 5
     fi
@@ -28759,6 +28687,7 @@ printf "%s\n" "$as_me: detected rustls" >&6;}
 printf "%s\n" "$as_me: Added $LIB_RUSTLS to CURL_LIBRARY_PATH" >&6;}
       fi
     fi
+    LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE rustls"
   fi
 
   test -z "$ssl_msg" || ssl_backends="${ssl_backends:+$ssl_backends, }$ssl_msg"
@@ -28884,18 +28813,13 @@ fi
         ca="$want_ca"
     capath="no"
   elif test "x$want_capath" != "xno" -a "x$want_capath" != "xunset"; then
-        if test "x$OPENSSL_ENABLED" != "x1" -a \
-            "x$GNUTLS_ENABLED" != "x1" -a \
-            "x$MBEDTLS_ENABLED" != "x1" -a \
-            "x$WOLFSSL_ENABLED" != "x1"; then
-      as_fn_error $? "--with-ca-path only works with OpenSSL, GnuTLS, mbedTLS or wolfSSL" "$LINENO" 5
-    fi
-    capath="$want_capath"
+        capath="$want_capath"
     ca="no"
   else
             ca="no"
     capath="no"
-    if test "x$cross_compiling" != "xyes"; then
+    if test "x$cross_compiling" != "xyes" -a \
+            "x$curl_cv_native_windows" != "xyes"; then
                   if test "x$want_ca" = "xunset"; then
                                 if test "x$prefix" != xNONE; then
           cac="${prefix}/share/curl/curl-ca-bundle.crt"
@@ -28918,12 +28842,7 @@ fi
       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: want $want_capath ca $ca" >&5
 printf "%s\n" "$as_me: want $want_capath ca $ca" >&6;}
       if test "x$want_capath" = "xunset"; then
-        if test "x$OPENSSL_ENABLED" = "x1" -o \
-                "x$GNUTLS_ENABLED" = "x1" -o \
-                "x$MBEDTLS_ENABLED" = "x1" -o \
-                "x$WOLFSSL_ENABLED" = "x1"; then
-          check_capath="/etc/ssl/certs"
-        fi
+        check_capath="/etc/ssl/certs"
       fi
     else
             { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: skipped the ca-cert path detection when cross-compiling" >&5
@@ -29237,6 +29156,7 @@ printf "%s\n" "#define USE_LIBPSL 1" >>confdefs.h
 
         USE_LIBPSL=1
 
+        LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libpsl"
 
 fi
 
@@ -29616,7 +29536,7 @@ fi
   ac_fn_c_check_header_compile "$LINENO" "libssh2.h" "ac_cv_header_libssh2_h" "$ac_includes_default"
 if test "x$ac_cv_header_libssh2_h" = xyes
 then :
-  curl_ssh_msg="enabled (libSSH2)"
+  curl_ssh_msg="enabled (libssh2)"
     LIBSSH2_ENABLED=1
 
 printf "%s\n" "#define USE_LIBSSH2 1" >>confdefs.h
@@ -29629,7 +29549,7 @@ fi
 
   if test X"$OPT_LIBSSH2" != Xoff &&
      test "$LIBSSH2_ENABLED" != "1"; then
-    as_fn_error $? "libSSH2 libs and/or directories were not found where specified!" "$LINENO" 5
+    as_fn_error $? "libssh2 libs and/or directories were not found where specified!" "$LINENO" 5
   fi
 
   if test "$LIBSSH2_ENABLED" = "1"; then
@@ -29642,6 +29562,7 @@ fi
 printf "%s\n" "$as_me: Added $DIR_SSH2 to CURL_LIBRARY_PATH" >&6;}
        fi
     fi
+    LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libssh2"
   else
         LDFLAGS=$CLEANLDFLAGS
     CPPFLAGS=$CLEANCPPFLAGS
@@ -29865,7 +29786,7 @@ fi
   ac_fn_c_check_header_compile "$LINENO" "libssh/libssh.h" "ac_cv_header_libssh_libssh_h" "$ac_includes_default"
 if test "x$ac_cv_header_libssh_libssh_h" = xyes
 then :
-  curl_ssh_msg="enabled (libSSH)"
+  curl_ssh_msg="enabled (libssh)"
     LIBSSH_ENABLED=1
 
 printf "%s\n" "#define USE_LIBSSH 1" >>confdefs.h
@@ -29878,7 +29799,7 @@ fi
 
   if test X"$OPT_LIBSSH" != Xoff &&
      test "$LIBSSH_ENABLED" != "1"; then
-    as_fn_error $? "libSSH libs and/or directories were not found where specified!" "$LINENO" 5
+    as_fn_error $? "libssh libs and/or directories were not found where specified!" "$LINENO" 5
   fi
 
   if test "$LIBSSH_ENABLED" = "1"; then
@@ -29891,6 +29812,7 @@ fi
 printf "%s\n" "$as_me: Added $DIR_SSH to CURL_LIBRARY_PATH" >&6;}
        fi
     fi
+    LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libssh"
   else
         LDFLAGS=$CLEANLDFLAGS
     CPPFLAGS=$CLEANCPPFLAGS
@@ -30207,6 +30129,7 @@ printf "%s\n" "#define USE_LIBRTMP 1" >>confdefs.h
 
         USE_LIBRTMP=1
 
+        LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE librtmp"
 
 fi
 
@@ -30878,6 +30801,7 @@ printf "%s\n" "#define HAVE_LIBIDN2 1" >>confdefs.h
       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: Added $IDN_DIR to CURL_LIBRARY_PATH" >&5
 printf "%s\n" "$as_me: Added $IDN_DIR to CURL_LIBRARY_PATH" >&6;}
     fi
+    LIBCURL_PC_REQUIRES_PRIVATE="libidn2 $LIBCURL_PC_REQUIRES_PRIVATE"
   else
     { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: Cannot find libraries for IDN support: IDN disabled" >&5
 printf "%s\n" "$as_me: WARNING: Cannot find libraries for IDN support: IDN disabled" >&2;}
@@ -31159,6 +31083,7 @@ printf "%s\n" "#define USE_NGHTTP2 1" >>confdefs.h
 
         USE_NGHTTP2=1
 
+        LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libnghttp2"
 
 fi
 
@@ -31446,6 +31371,7 @@ printf "%s\n" "#define USE_NGTCP2 1" >>confdefs.h
           export CURL_LIBRARY_PATH
           { printf "%s\n" "$as_me:${as_lineno-$LINENO}: Added $DIR_TCP2 to CURL_LIBRARY_PATH" >&5
 printf "%s\n" "$as_me: Added $DIR_TCP2 to CURL_LIBRARY_PATH" >&6;}
+          LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libngtcp2"
 
 fi
 
@@ -31700,6 +31626,7 @@ printf "%s\n" "#define USE_NGTCP2_CRYPTO_QUICTLS 1" >>confdefs.h
           export CURL_LIBRARY_PATH
           { printf "%s\n" "$as_me:${as_lineno-$LINENO}: Added $DIR_NGTCP2_CRYPTO_QUICTLS to CURL_LIBRARY_PATH" >&5
 printf "%s\n" "$as_me: Added $DIR_NGTCP2_CRYPTO_QUICTLS to CURL_LIBRARY_PATH" >&6;}
+          LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libngtcp2_crypto_quictls"
 
 fi
 
@@ -31953,6 +31880,7 @@ printf "%s\n" "#define USE_NGTCP2_CRYPTO_BORINGSSL 1" >>confdefs.h
           export CURL_LIBRARY_PATH
           { printf "%s\n" "$as_me:${as_lineno-$LINENO}: Added $DIR_NGTCP2_CRYPTO_BORINGSSL to CURL_LIBRARY_PATH" >&5
 printf "%s\n" "$as_me: Added $DIR_NGTCP2_CRYPTO_BORINGSSL to CURL_LIBRARY_PATH" >&6;}
+          LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libngtcp2_crypto_boringssl"
 
 fi
 
@@ -32206,6 +32134,7 @@ printf "%s\n" "#define USE_NGTCP2_CRYPTO_GNUTLS 1" >>confdefs.h
           export CURL_LIBRARY_PATH
           { printf "%s\n" "$as_me:${as_lineno-$LINENO}: Added $DIR_NGTCP2_CRYPTO_GNUTLS to CURL_LIBRARY_PATH" >&5
 printf "%s\n" "$as_me: Added $DIR_NGTCP2_CRYPTO_GNUTLS to CURL_LIBRARY_PATH" >&6;}
+          LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libngtcp2_crypto_gnutls"
 
 fi
 
@@ -32459,6 +32388,7 @@ printf "%s\n" "#define USE_NGTCP2_CRYPTO_WOLFSSL 1" >>confdefs.h
           export CURL_LIBRARY_PATH
           { printf "%s\n" "$as_me:${as_lineno-$LINENO}: Added $DIR_NGTCP2_CRYPTO_WOLFSSL to CURL_LIBRARY_PATH" >&5
 printf "%s\n" "$as_me: Added $DIR_NGTCP2_CRYPTO_WOLFSSL to CURL_LIBRARY_PATH" >&6;}
+          LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libngtcp2_crypto_wolfssl"
 
 fi
 
@@ -32510,7 +32440,7 @@ if test "x$want_openssl_quic" = "xyes"; then
     as_fn_error $? "--with-openssl-quic and --with-ngtcp2 are mutually exclusive" "$LINENO" 5
   fi
   if test "$HAVE_OPENSSL_QUIC" != 1; then
-    as_fn_error $? "--with-openssl-quic requires quic support in OpenSSL" "$LINENO" 5
+    as_fn_error $? "--with-openssl-quic requires quic support and OpenSSL >= 3.3.0" "$LINENO" 5
   fi
 
 printf "%s\n" "#define USE_OPENSSL_QUIC 1" >>confdefs.h
@@ -32552,6 +32482,11 @@ esac
 curl_http3_msg="no      (--with-nghttp3)"
 if test X"$want_nghttp3" != Xno; then
 
+  if test "x$USE_NGTCP2" != "x1" -a "x$USE_OPENSSL_QUIC" != "x1"; then
+    # without ngtcp2 or openssl quic, nghttp3 is of no use for us
+    as_fn_error $? "nghttp3 enabled without a QUIC library; enable ngtcp2 or OpenSSL-QUIC" "$LINENO" 5
+  fi
+
     CLEANLDFLAGS="$LDFLAGS"
   CLEANCPPFLAGS="$CPPFLAGS"
   CLEANLIBS="$LIBS"
@@ -32783,6 +32718,7 @@ printf "%s\n" "#define USE_NGHTTP3 1" >>confdefs.h
           export CURL_LIBRARY_PATH
           { printf "%s\n" "$as_me:${as_lineno-$LINENO}: Added $DIR_NGHTTP3 to CURL_LIBRARY_PATH" >&5
 printf "%s\n" "$as_me: Added $DIR_NGHTTP3 to CURL_LIBRARY_PATH" >&6;}
+          LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libnghttp3"
 
 fi
 
@@ -33116,6 +33052,7 @@ fi
           export CURL_LIBRARY_PATH
           { printf "%s\n" "$as_me:${as_lineno-$LINENO}: Added $DIR_QUICHE to CURL_LIBRARY_PATH" >&5
 printf "%s\n" "$as_me: Added $DIR_QUICHE to CURL_LIBRARY_PATH" >&6;}
+          LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE quiche"
 fi
 
 done
@@ -33247,8 +33184,8 @@ printf "%s\n" "#define USE_MSH3 1" >>confdefs.h
         export CURL_LIBRARY_PATH
         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: Added $DIR_MSH3 to CURL_LIBRARY_PATH" >&5
 printf "%s\n" "$as_me: Added $DIR_MSH3 to CURL_LIBRARY_PATH" >&6;}
-else $as_nop
-  experimental="$experimental HTTP3"
+        LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libmsh3"
+        experimental="$experimental HTTP3"
 
 fi
 
@@ -33443,7 +33380,7 @@ printf "%s\n" "found" >&6; }
     fi
 
     if test "$PKGCONFIG" != "no" ; then
-      FISH_FUNCTIONS_DIR="$($PKGCONFIG --variable completionsdir fish)"
+      FISH_FUNCTIONS_DIR=`$PKGCONFIG --variable completionsdir fish`
     else
       FISH_FUNCTIONS_DIR="$datarootdir/fish/vendor_completions.d"
     fi
@@ -34582,6 +34519,38 @@ if test "x$ac_cv_header_sys_wait_h" = xyes
 then :
   printf "%s\n" "#define HAVE_SYS_WAIT_H 1" >>confdefs.h
 
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/eventfd.h" "ac_cv_header_sys_eventfd_h" "
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#ifdef HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#elif defined(HAVE_UNISTD_H)
+#include <unistd.h>
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_IN6_H
+#include <netinet/in6.h>
+#endif
+#ifdef HAVE_SYS_UN_H
+#include <sys/un.h>
+#endif
+
+
+"
+if test "x$ac_cv_header_sys_eventfd_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_EVENTFD_H 1" >>confdefs.h
+
 fi
 ac_fn_c_check_header_compile "$LINENO" "setjmp.h" "ac_cv_header_setjmp_h" "
 #ifdef HAVE_SYS_TYPES_H
@@ -34921,7 +34890,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
   fi
   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $r" >&5
 printf "%s\n" "$r" >&6; }
-    tname=$(echo "ac_cv_sizeof_size_t" | tr A-Z a-z | tr " " "_")
+    tname=`echo "ac_cv_sizeof_size_t" | tr A-Z a-z | tr " " "_"`
   eval "$tname=$r"
 
 
@@ -34970,7 +34939,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
   fi
   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $r" >&5
 printf "%s\n" "$r" >&6; }
-    tname=$(echo "ac_cv_sizeof_long" | tr A-Z a-z | tr " " "_")
+    tname=`echo "ac_cv_sizeof_long" | tr A-Z a-z | tr " " "_"`
   eval "$tname=$r"
 
 
@@ -35019,7 +34988,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
   fi
   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $r" >&5
 printf "%s\n" "$r" >&6; }
-    tname=$(echo "ac_cv_sizeof_int" | tr A-Z a-z | tr " " "_")
+    tname=`echo "ac_cv_sizeof_int" | tr A-Z a-z | tr " " "_"`
   eval "$tname=$r"
 
 
@@ -35068,7 +35037,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
   fi
   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $r" >&5
 printf "%s\n" "$r" >&6; }
-    tname=$(echo "ac_cv_sizeof_time_t" | tr A-Z a-z | tr " " "_")
+    tname=`echo "ac_cv_sizeof_time_t" | tr A-Z a-z | tr " " "_"`
   eval "$tname=$r"
 
 
@@ -35117,7 +35086,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
   fi
   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $r" >&5
 printf "%s\n" "$r" >&6; }
-    tname=$(echo "ac_cv_sizeof_off_t" | tr A-Z a-z | tr " " "_")
+    tname=`echo "ac_cv_sizeof_off_t" | tr A-Z a-z | tr " " "_"`
   eval "$tname=$r"
 
 
@@ -35171,7 +35140,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
   fi
   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $r" >&5
 printf "%s\n" "$r" >&6; }
-    tname=$(echo "ac_cv_sizeof_curl_off_t" | tr A-Z a-z | tr " " "_")
+    tname=`echo "ac_cv_sizeof_curl_off_t" | tr A-Z a-z | tr " " "_"`
   eval "$tname=$r"
 
 
@@ -35222,7 +35191,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
   fi
   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $r" >&5
 printf "%s\n" "$r" >&6; }
-    tname=$(echo "ac_cv_sizeof_curl_socket_t" | tr A-Z a-z | tr " " "_")
+    tname=`echo "ac_cv_sizeof_curl_socket_t" | tr A-Z a-z | tr " " "_"`
   eval "$tname=$r"
 
 
@@ -37845,7 +37814,7 @@ int main (void)
 #ifdef h_errno
   return 0;
 #else
-  force compilation error
+  #error force compilation error
 #endif
 }
 
@@ -37918,7 +37887,7 @@ int main (void)
 #elif defined(_XOPEN_SOURCE) && (_XOPEN_SOURCE >= 700)
           return 0;
 #else
-          force compilation error
+          #error force compilation error
 #endif
 
  ;
@@ -44170,65 +44139,145 @@ printf "%s\n" "#define HAVE_DECL_GETPWUID_R_MISSING 1" >>confdefs.h
 fi
 
 
+ac_fn_c_check_func "$LINENO" "_fseeki64" "ac_cv_func__fseeki64"
+if test "x$ac_cv_func__fseeki64" = xyes
+then :
+  printf "%s\n" "#define HAVE__FSEEKI64 1" >>confdefs.h
 
-  for ac_func in _fseeki64 arc4random fnmatch fseeko geteuid getpass_r getppid getpwuid getpwuid_r getrlimit gettimeofday if_nametoindex mach_absolute_time pipe sched_yield sendmsg setlocale setmode setrlimit snprintf utime utimes
-do :
-  as_ac_var=`printf "%s\n" "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-if eval test \"x\$"$as_ac_var"\" = x"yes"
+fi
+ac_fn_c_check_func "$LINENO" "arc4random" "ac_cv_func_arc4random"
+if test "x$ac_cv_func_arc4random" = xyes
 then :
-  cat >>confdefs.h <<_ACEOF
-#define `printf "%s\n" "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
+  printf "%s\n" "#define HAVE_ARC4RANDOM 1" >>confdefs.h
 
+fi
+ac_fn_c_check_func "$LINENO" "eventfd" "ac_cv_func_eventfd"
+if test "x$ac_cv_func_eventfd" = xyes
+then :
+  printf "%s\n" "#define HAVE_EVENTFD 1" >>confdefs.h
 
-else $as_nop
+fi
+ac_fn_c_check_func "$LINENO" "fnmatch" "ac_cv_func_fnmatch"
+if test "x$ac_cv_func_fnmatch" = xyes
+then :
+  printf "%s\n" "#define HAVE_FNMATCH 1" >>confdefs.h
 
-  func="$ac_func"
-  eval skipcheck=\$skipcheck_$func
-  if test "x$skipcheck" != "xyes"; then
-    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking deeper for $func" >&5
-printf %s "checking deeper for $func... " >&6; }
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+fi
+ac_fn_c_check_func "$LINENO" "fseeko" "ac_cv_func_fseeko"
+if test "x$ac_cv_func_fseeko" = xyes
+then :
+  printf "%s\n" "#define HAVE_FSEEKO 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "geteuid" "ac_cv_func_geteuid"
+if test "x$ac_cv_func_geteuid" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETEUID 1" >>confdefs.h
 
+fi
+ac_fn_c_check_func "$LINENO" "getpass_r" "ac_cv_func_getpass_r"
+if test "x$ac_cv_func_getpass_r" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETPASS_R 1" >>confdefs.h
 
+fi
+ac_fn_c_check_func "$LINENO" "getppid" "ac_cv_func_getppid"
+if test "x$ac_cv_func_getppid" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETPPID 1" >>confdefs.h
 
-int main (void)
-{
+fi
+ac_fn_c_check_func "$LINENO" "getpwuid" "ac_cv_func_getpwuid"
+if test "x$ac_cv_func_getpwuid" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETPWUID 1" >>confdefs.h
 
-        $func ();
+fi
+ac_fn_c_check_func "$LINENO" "getpwuid_r" "ac_cv_func_getpwuid_r"
+if test "x$ac_cv_func_getpwuid_r" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETPWUID_R 1" >>confdefs.h
 
- ;
- return 0;
-}
+fi
+ac_fn_c_check_func "$LINENO" "getrlimit" "ac_cv_func_getrlimit"
+if test "x$ac_cv_func_getrlimit" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETRLIMIT 1" >>confdefs.h
 
-_ACEOF
-if ac_fn_c_try_link "$LINENO"
+fi
+ac_fn_c_check_func "$LINENO" "gettimeofday" "ac_cv_func_gettimeofday"
+if test "x$ac_cv_func_gettimeofday" = xyes
 then :
+  printf "%s\n" "#define HAVE_GETTIMEOFDAY 1" >>confdefs.h
 
-      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-printf "%s\n" "yes" >&6; }
-      eval "ac_cv_func_$func=yes"
+fi
+ac_fn_c_check_func "$LINENO" "if_nametoindex" "ac_cv_func_if_nametoindex"
+if test "x$ac_cv_func_if_nametoindex" = xyes
+then :
+  printf "%s\n" "#define HAVE_IF_NAMETOINDEX 1" >>confdefs.h
 
-cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$func" | sed 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/' | sed 's/^A-Z0-9_/_/g'` 1
-_ACEOF
+fi
+ac_fn_c_check_func "$LINENO" "mach_absolute_time" "ac_cv_func_mach_absolute_time"
+if test "x$ac_cv_func_mach_absolute_time" = xyes
+then :
+  printf "%s\n" "#define HAVE_MACH_ABSOLUTE_TIME 1" >>confdefs.h
 
+fi
+ac_fn_c_check_func "$LINENO" "pipe" "ac_cv_func_pipe"
+if test "x$ac_cv_func_pipe" = xyes
+then :
+  printf "%s\n" "#define HAVE_PIPE 1" >>confdefs.h
 
-else $as_nop
+fi
+ac_fn_c_check_func "$LINENO" "sched_yield" "ac_cv_func_sched_yield"
+if test "x$ac_cv_func_sched_yield" = xyes
+then :
+  printf "%s\n" "#define HAVE_SCHED_YIELD 1" >>confdefs.h
 
-      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: but still no" >&5
-printf "%s\n" "but still no" >&6; }
+fi
+ac_fn_c_check_func "$LINENO" "sendmsg" "ac_cv_func_sendmsg"
+if test "x$ac_cv_func_sendmsg" = xyes
+then :
+  printf "%s\n" "#define HAVE_SENDMSG 1" >>confdefs.h
 
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.beam \
-    conftest$ac_exeext conftest.$ac_ext
-  fi
+ac_fn_c_check_func "$LINENO" "setlocale" "ac_cv_func_setlocale"
+if test "x$ac_cv_func_setlocale" = xyes
+then :
+  printf "%s\n" "#define HAVE_SETLOCALE 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "setmode" "ac_cv_func_setmode"
+if test "x$ac_cv_func_setmode" = xyes
+then :
+  printf "%s\n" "#define HAVE_SETMODE 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "setrlimit" "ac_cv_func_setrlimit"
+if test "x$ac_cv_func_setrlimit" = xyes
+then :
+  printf "%s\n" "#define HAVE_SETRLIMIT 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "snprintf" "ac_cv_func_snprintf"
+if test "x$ac_cv_func_snprintf" = xyes
+then :
+  printf "%s\n" "#define HAVE_SNPRINTF 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "utime" "ac_cv_func_utime"
+if test "x$ac_cv_func_utime" = xyes
+then :
+  printf "%s\n" "#define HAVE_UTIME 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "utimes" "ac_cv_func_utimes"
+if test "x$ac_cv_func_utimes" = xyes
+then :
+  printf "%s\n" "#define HAVE_UTIMES 1" >>confdefs.h
 
 fi
 
-done
 
 ac_fn_check_decl "$LINENO" "fseeko" "ac_cv_have_decl_fseeko" "#include <stdio.h>
 " "$ac_c_undeclared_builtin_options" "CFLAGS"
@@ -44738,6 +44787,7 @@ printf "%s\n" "#define CARES_NO_DEPRECATED 1" >>confdefs.h
 
       USE_ARES=1
 
+      LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libcares"
       curl_res_msg="c-ares"
     fi
   fi
@@ -44780,6 +44830,60 @@ fi
   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $want_thres" >&5
 printf "%s\n" "$want_thres" >&6; }
 
+
+  if test "$ipv6" = yes; then
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether to link macOS CoreFoundation, CoreServices, and SystemConfiguration frameworks" >&5
+printf %s "checking whether to link macOS CoreFoundation, CoreServices, and SystemConfiguration frameworks... " >&6; }
+case $host_os in
+  darwin*)
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#include <TargetConditionals.h>
+
+int main (void)
+{
+
+#if TARGET_OS_MAC && !(defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE)
+      return 0;
+#else
+#error Not macOS
+#endif
+
+ ;
+ return 0;
+}
+
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+
+      build_for_macos="yes"
+
+else $as_nop
+
+      build_for_macos="no"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+    if test "x$build_for_macos" != xno; then
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
+      LDFLAGS="$LDFLAGS -framework CoreFoundation -framework CoreServices -framework SystemConfiguration"
+    else
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+    fi
+    ;;
+  *)
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+esac
+
+  fi
 fi
 
 { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether to use POSIX threads for threaded resolver" >&5
@@ -45766,7 +45870,7 @@ do :
 if test "x$ac_cv_func_SSL_set1_ech_config_list" = xyes
 then :
   printf "%s\n" "#define HAVE_SSL_SET1_ECH_CONFIG_LIST 1" >>confdefs.h
- ECH_SUPPORT="ECH support available via boringssl with SSL_set1_ech_config_list"
+ ECH_SUPPORT="ECH support available via BoringSSL with SSL_set1_ech_config_list"
       ECH_ENABLED=1
 fi
 
@@ -45780,7 +45884,7 @@ do :
 if test "x$ac_cv_func_wolfSSL_CTX_GenerateEchConfig" = xyes
 then :
   printf "%s\n" "#define HAVE_WOLFSSL_CTX_GENERATEECHCONFIG 1" >>confdefs.h
- ECH_SUPPORT="ECH support available via WolfSSL with wolfSSL_CTX_GenerateEchConfig"
+ ECH_SUPPORT="ECH support available via wolfSSL with wolfSSL_CTX_GenerateEchConfig"
       ECH_ENABLED=1
 fi
 
@@ -45904,13 +46008,21 @@ ENABLE_SHARED="$enable_shared"
 ENABLE_STATIC="$enable_static"
 
 
+squeeze LIBCURL_PC_REQUIRES_PRIVATE
+LIBCURL_PC_REQUIRES_PRIVATE=`echo $LIBCURL_PC_REQUIRES_PRIVATE | tr ' ' ','`
+
+
+
 if test "x$enable_shared" = "xno"; then
+  LIBCURL_PC_REQUIRES=$LIBCURL_PC_REQUIRES_PRIVATE
   LIBCURL_NO_SHARED=$LIBCURL_LIBS
 else
+  LIBCURL_PC_REQUIRES=
   LIBCURL_NO_SHARED=
 fi
 
 
+
 rm $compilersh
 
 
@@ -46043,6 +46155,12 @@ else
 printf "%s\n" "no" >&6; }
 fi
 
+if test "x$OPENSSL_ENABLED" = "x1" -o -n "$SSL_ENABLED"; then
+  if test "x$ECH_ENABLED" = "x1"; then
+    SUPPORT_FEATURES="$SUPPORT_FEATURES ECH"
+  fi
+fi
+
 if test ${ac_cv_sizeof_curl_off_t} -gt 4; then
   if test ${ac_cv_sizeof_off_t} -gt 4 -o \
      "$curl_win32_file_api" = "win32_large_files"; then
@@ -46083,7 +46201,18 @@ fi
 rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-SUPPORT_FEATURES=`echo $SUPPORT_FEATURES | tr ' ' '\012' | sort | tr '\012' ' '`
+if test "x$want_debug" = "xyes"; then
+  SUPPORT_FEATURES="$SUPPORT_FEATURES Debug"
+fi
+if test "x$want_curldebug" = "xyes"; then
+  SUPPORT_FEATURES="$SUPPORT_FEATURES TrackMemory"
+fi
+
+if sort -f </dev/null >/dev/null 2>&1; then
+  SUPPORT_FEATURES=`echo $SUPPORT_FEATURES | tr ' ' '\012' | sort -f | tr '\012' ' '`
+else
+  SUPPORT_FEATURES=`echo $SUPPORT_FEATURES | tr ' ' '\012' | sort | tr '\012' ' '`
+fi
 
 
 if test "x$CURL_DISABLE_HTTP" != "x1"; then
@@ -46480,6 +46609,10 @@ if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
   as_fn_error $? "conditional \"MAINTAINER_MODE\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${DEBUGBUILD_TRUE}" && test -z "${DEBUGBUILD_FALSE}"; then
+  as_fn_error $? "conditional \"DEBUGBUILD\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking that generated files are newer than configure" >&5
 printf %s "checking that generated files are newer than configure... " >&6; }
    if test -n "$am_sleep_pid"; then
@@ -46528,10 +46661,6 @@ if test -z "${DOING_NATIVE_WINDOWS_TRUE}" && test -z "${DOING_NATIVE_WINDOWS_FAL
   as_fn_error $? "conditional \"DOING_NATIVE_WINDOWS\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
-if test -z "${CURLDEBUG_TRUE}" && test -z "${CURLDEBUG_FALSE}"; then
-  as_fn_error $? "conditional \"CURLDEBUG\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
-fi
 if test -z "${BUILD_UNITTESTS_TRUE}" && test -z "${BUILD_UNITTESTS_FALSE}"; then
   as_fn_error $? "conditional \"BUILD_UNITTESTS\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
@@ -49019,12 +49148,15 @@ use vars qw(
 _EOF
 
 
+SUPPORT_PROTOCOLS_LOWER=`echo "$SUPPORT_PROTOCOLS" | tr A-Z a-z`
+
 { printf "%s\n" "$as_me:${as_lineno-$LINENO}: Configured to build curl/libcurl:
 
   Host setup:       ${host}
   Install prefix:   ${prefix}
   Compiler:         ${CC}
    CFLAGS:          ${CFLAGS}
+   CFLAGS extras:   ${CURL_CFLAG_EXTRAS}
    CPPFLAGS:        ${CPPFLAGS}
    LDFLAGS:         ${LDFLAGS}
    LIBS:            ${LIBS}
@@ -49065,7 +49197,7 @@ _EOF
   HTTP3:            ${curl_h3_msg}
   ECH:              ${curl_ech_msg}
   WebSockets:       ${curl_ws_msg}
-  Protocols:        ${SUPPORT_PROTOCOLS}
+  Protocols:        ${SUPPORT_PROTOCOLS_LOWER}
   Features:         ${SUPPORT_FEATURES}
 " >&5
 printf "%s\n" "$as_me: Configured to build curl/libcurl:
@@ -49074,6 +49206,7 @@ printf "%s\n" "$as_me: Configured to build curl/libcurl:
   Install prefix:   ${prefix}
   Compiler:         ${CC}
    CFLAGS:          ${CFLAGS}
+   CFLAGS extras:   ${CURL_CFLAG_EXTRAS}
    CPPFLAGS:        ${CPPFLAGS}
    LDFLAGS:         ${LDFLAGS}
    LIBS:            ${LIBS}
@@ -49114,20 +49247,22 @@ printf "%s\n" "$as_me: Configured to build curl/libcurl:
   HTTP3:            ${curl_h3_msg}
   ECH:              ${curl_ech_msg}
   WebSockets:       ${curl_ws_msg}
-  Protocols:        ${SUPPORT_PROTOCOLS}
+  Protocols:        ${SUPPORT_PROTOCOLS_LOWER}
   Features:         ${SUPPORT_FEATURES}
 " >&6;}
 
-non13=`echo "$TLSCHOICE" | grep -Ei 'bearssl|secure-transport|mbedtls'`;
+non13=`echo "$TLSCHOICE" | $EGREP -io 'bearssl|secure-transport'`;
 if test -n "$non13"; then
- cat >&2 << _EOF
-  WARNING: A selected TLS library ($TLSCHOICE) does not support TLS 1.3!
-_EOF
+ for a in $non13; do
+   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: $a is enabled for TLS but it does not support TLS 1.3" >&5
+printf "%s\n" "$as_me: WARNING: $a is enabled for TLS but it does not support TLS 1.3" >&2;}
+ done
 fi
 
 if test -n "$experimental"; then
- cat >&2 << _EOF
-  WARNING: $experimental enabled but marked EXPERIMENTAL. Use with caution!
-_EOF
+ for a in $experimental; do
+   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: $a is enabled but marked EXPERIMENTAL. Use with caution!" >&5
+printf "%s\n" "$as_me: WARNING: $a is enabled but marked EXPERIMENTAL. Use with caution!" >&2;}
+ done
 fi
 
diff --git a/configure.ac b/configure.ac
index a4ea9f72d..1e18b8156 100644
--- a/configure.ac
+++ b/configure.ac
@@ -44,6 +44,7 @@ AM_MAINTAINER_MODE
 m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
 
 CURL_CHECK_OPTION_DEBUG
+AM_CONDITIONAL(DEBUGBUILD, test x$want_debug = xyes)
 CURL_CHECK_OPTION_OPTIMIZE
 CURL_CHECK_OPTION_WARNINGS
 CURL_CHECK_OPTION_WERROR
@@ -274,7 +275,7 @@ AS_HELP_STRING([--with-mbedtls=PATH],[where to look for mbedTLS, PATH points to
 
 OPT_WOLFSSL=no
 AC_ARG_WITH(wolfssl,dnl
-AS_HELP_STRING([--with-wolfssl=PATH],[where to look for WolfSSL, PATH points to the installation root (default: system lib default)]),[
+AS_HELP_STRING([--with-wolfssl=PATH],[where to look for wolfSSL, PATH points to the installation root (default: system lib default)]),[
   OPT_WOLFSSL=$withval
   if test X"$withval" != Xno; then
     TLSCHOICE="${TLSCHOICE:+$TLSCHOICE, }wolfSSL"
@@ -417,7 +418,7 @@ Select from these:
   --with-bearssl
   --with-gnutls
   --with-mbedtls
-  --with-openssl (also works for BoringSSL and libressl)
+  --with-openssl (also works for BoringSSL and LibreSSL)
   --with-rustls
   --with-schannel
   --with-secure-transport
@@ -539,6 +540,8 @@ if test X"$want_werror" = Xyes; then
     if test "$compiler_num" -ge "500"; then
       CURL_CFLAG_EXTRAS="$CURL_CFLAG_EXTRAS -pedantic-errors"
     fi
+  elif test "$compiler_id" = "CLANG"; then
+    CURL_CFLAG_EXTRAS="$CURL_CFLAG_EXTRAS -pedantic-errors"
   fi
 fi
 AC_SUBST(CURL_CFLAG_EXTRAS)
@@ -548,9 +551,6 @@ CURL_CHECK_COMPILER_ARRAY_SIZE_NEGATIVE
 CURL_CHECK_COMPILER_PROTOTYPE_MISMATCH
 CURL_CHECK_COMPILER_SYMBOL_HIDING
 
-CURL_CHECK_CURLDEBUG
-AM_CONDITIONAL(CURLDEBUG, test x$want_curldebug = xyes)
-
 supports_unittests=yes
 # cross-compilation of unit tests static library/programs fails when
 # libcurl shared library is built. This might be due to a libtool or
@@ -597,8 +597,11 @@ CURL_CHECK_WIN32_LARGEFILE
 CURL_CHECK_WIN32_CRYPTO
 
 CURL_DARWIN_CFLAGS
-CURL_DARWIN_SYSTEMCONFIGURATION
-CURL_SUPPORTS_BUILTIN_AVAILABLE
+case $host_os in
+  darwin*)
+    CURL_SUPPORTS_BUILTIN_AVAILABLE
+    ;;
+esac
 
 AM_CONDITIONAL([HAVE_WINDRES],
   [test "$curl_cv_native_windows" = "yes" && test -n "${RC}"])
@@ -799,7 +802,8 @@ if test X"$want_hyper" != Xno; then
           AC_SUBST(USE_HYPER, [1])
           CURL_LIBRARY_PATH="$CURL_LIBRARY_PATH:$DIR_HYPER"
           export CURL_LIBRARY_PATH
-          AC_MSG_NOTICE([Added $DIR_HYPER to CURL_LIBRARY_PATH]),
+          AC_MSG_NOTICE([Added $DIR_HYPER to CURL_LIBRARY_PATH])
+          LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE hyper"
        )
       ],
       for d in `echo $DIR_HYPER | $SED -e 's/:/ /'`; do
@@ -1381,6 +1385,7 @@ else
     dnl replace 'HAVE_LIBZ' in the automake makefile.ams
     AMFIXLIB="1"
     AC_MSG_NOTICE([found both libz and libz.h header])
+    LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE zlib"
     curl_zlib_msg="enabled"
   fi
 fi
@@ -1469,6 +1474,7 @@ if test X"$OPT_BROTLI" != Xno; then
          AC_MSG_NOTICE([Added $DIR_BROTLI to CURL_LIBRARY_PATH])
        fi
     fi
+    LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libbrotlidec"
   else
     dnl no brotli, revert back to clean variables
     LDFLAGS=$CLEANLDFLAGS
@@ -1556,6 +1562,7 @@ if test X"$OPT_ZSTD" != Xno; then
          AC_MSG_NOTICE([Added $DIR_ZSTD to CURL_LIBRARY_PATH])
        fi
     fi
+    LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libzstd"
   else
     dnl no zstd, revert back to clean variables
     LDFLAGS=$CLEANLDFLAGS
@@ -2142,6 +2149,7 @@ if test X"$OPT_LIBPSL" != Xno; then
         LIBPSL_ENABLED=1
         AC_DEFINE(USE_LIBPSL, 1, [if libpsl is in use])
         AC_SUBST(USE_LIBPSL, [1])
+        LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libpsl"
      )
     ],
       dnl not found, revert back to clean variables
@@ -2183,10 +2191,10 @@ AC_ARG_WITH(libmetalink,,
   AC_MSG_ERROR([--with-libmetalink and --without-libmetalink no longer work!]))
 
 dnl **********************************************************************
-dnl Check for the presence of LIBSSH2 libraries and headers
+dnl Check for the presence of libssh2 libraries and headers
 dnl **********************************************************************
 
-dnl Default to compiler & linker defaults for LIBSSH2 files & libraries.
+dnl Default to compiler & linker defaults for libssh2 files & libraries.
 OPT_LIBSSH2=off
 AC_ARG_WITH(libssh2,dnl
 AS_HELP_STRING([--with-libssh2=PATH],[Where to look for libssh2, PATH points to the libssh2 installation; when possible, set the PKG_CONFIG_PATH environment variable instead of using this option])
@@ -2251,15 +2259,15 @@ if test X"$OPT_LIBSSH2" != Xno; then
   AC_CHECK_LIB(ssh2, libssh2_session_block_directions)
 
   AC_CHECK_HEADER(libssh2.h,
-    curl_ssh_msg="enabled (libSSH2)"
+    curl_ssh_msg="enabled (libssh2)"
     LIBSSH2_ENABLED=1
-    AC_DEFINE(USE_LIBSSH2, 1, [if libSSH2 is in use])
+    AC_DEFINE(USE_LIBSSH2, 1, [if libssh2 is in use])
     AC_SUBST(USE_LIBSSH2, [1])
   )
 
   if test X"$OPT_LIBSSH2" != Xoff &&
      test "$LIBSSH2_ENABLED" != "1"; then
-    AC_MSG_ERROR([libSSH2 libs and/or directories were not found where specified!])
+    AC_MSG_ERROR([libssh2 libs and/or directories were not found where specified!])
   fi
 
   if test "$LIBSSH2_ENABLED" = "1"; then
@@ -2274,6 +2282,7 @@ if test X"$OPT_LIBSSH2" != Xno; then
          AC_MSG_NOTICE([Added $DIR_SSH2 to CURL_LIBRARY_PATH])
        fi
     fi
+    LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libssh2"
   else
     dnl no libssh2, revert back to clean variables
     LDFLAGS=$CLEANLDFLAGS
@@ -2324,15 +2333,15 @@ elif test X"$OPT_LIBSSH" != Xno; then
   AC_CHECK_LIB(ssh, ssh_new)
 
   AC_CHECK_HEADER(libssh/libssh.h,
-    curl_ssh_msg="enabled (libSSH)"
+    curl_ssh_msg="enabled (libssh)"
     LIBSSH_ENABLED=1
-    AC_DEFINE(USE_LIBSSH, 1, [if libSSH is in use])
+    AC_DEFINE(USE_LIBSSH, 1, [if libssh is in use])
     AC_SUBST(USE_LIBSSH, [1])
   )
 
   if test X"$OPT_LIBSSH" != Xoff &&
      test "$LIBSSH_ENABLED" != "1"; then
-    AC_MSG_ERROR([libSSH libs and/or directories were not found where specified!])
+    AC_MSG_ERROR([libssh libs and/or directories were not found where specified!])
   fi
 
   if test "$LIBSSH_ENABLED" = "1"; then
@@ -2347,6 +2356,7 @@ elif test X"$OPT_LIBSSH" != Xno; then
          AC_MSG_NOTICE([Added $DIR_SSH to CURL_LIBRARY_PATH])
        fi
     fi
+    LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libssh"
   else
     dnl no libssh, revert back to clean variables
     LDFLAGS=$CLEANLDFLAGS
@@ -2441,6 +2451,7 @@ if test X"$OPT_LIBRTMP" != Xno; then
         LIBRTMP_ENABLED=1
         AC_DEFINE(USE_LIBRTMP, 1, [if librtmp is in use])
         AC_SUBST(USE_LIBRTMP, [1])
+        LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE librtmp"
      )
     ],
       dnl not found, revert back to clean variables
@@ -2724,6 +2735,7 @@ if test "$want_idn" = "yes"; then
       export CURL_LIBRARY_PATH
       AC_MSG_NOTICE([Added $IDN_DIR to CURL_LIBRARY_PATH])
     fi
+    LIBCURL_PC_REQUIRES_PRIVATE="libidn2 $LIBCURL_PC_REQUIRES_PRIVATE"
   else
     AC_MSG_WARN([Cannot find libraries for IDN support: IDN disabled])
     CPPFLAGS="$clean_CPPFLAGS"
@@ -2814,6 +2826,7 @@ if test X"$want_nghttp2" != Xno; then
         NGHTTP2_ENABLED=1
         AC_DEFINE(USE_NGHTTP2, 1, [if nghttp2 is in use])
         AC_SUBST(USE_NGHTTP2, [1])
+        LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libnghttp2"
      )
 
      CURL_LIBRARY_PATH="$CURL_LIBRARY_PATH:$DIR_H2"
@@ -2902,6 +2915,7 @@ if test X"$want_tcp2" != Xno; then
           CURL_LIBRARY_PATH="$CURL_LIBRARY_PATH:$DIR_TCP2"
           export CURL_LIBRARY_PATH
           AC_MSG_NOTICE([Added $DIR_TCP2 to CURL_LIBRARY_PATH])
+          LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libngtcp2"
        )
       ],
         dnl not found, revert back to clean variables
@@ -2958,6 +2972,7 @@ if test "x$NGTCP2_ENABLED" = "x1" -a "x$OPENSSL_ENABLED" = "x1" -a "x$OPENSSL_IS
           CURL_LIBRARY_PATH="$CURL_LIBRARY_PATH:$DIR_NGTCP2_CRYPTO_QUICTLS"
           export CURL_LIBRARY_PATH
           AC_MSG_NOTICE([Added $DIR_NGTCP2_CRYPTO_QUICTLS to CURL_LIBRARY_PATH])
+          LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libngtcp2_crypto_quictls"
        )
       ],
         dnl not found, revert back to clean variables
@@ -3013,6 +3028,7 @@ if test "x$NGTCP2_ENABLED" = "x1" -a "x$OPENSSL_ENABLED" = "x1" -a "x$OPENSSL_IS
           CURL_LIBRARY_PATH="$CURL_LIBRARY_PATH:$DIR_NGTCP2_CRYPTO_BORINGSSL"
           export CURL_LIBRARY_PATH
           AC_MSG_NOTICE([Added $DIR_NGTCP2_CRYPTO_BORINGSSL to CURL_LIBRARY_PATH])
+          LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libngtcp2_crypto_boringssl"
        )
       ],
         dnl not found, revert back to clean variables
@@ -3068,6 +3084,7 @@ if test "x$NGTCP2_ENABLED" = "x1" -a "x$GNUTLS_ENABLED" = "x1"; then
           CURL_LIBRARY_PATH="$CURL_LIBRARY_PATH:$DIR_NGTCP2_CRYPTO_GNUTLS"
           export CURL_LIBRARY_PATH
           AC_MSG_NOTICE([Added $DIR_NGTCP2_CRYPTO_GNUTLS to CURL_LIBRARY_PATH])
+          LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libngtcp2_crypto_gnutls"
        )
       ],
         dnl not found, revert back to clean variables
@@ -3123,6 +3140,7 @@ if test "x$NGTCP2_ENABLED" = "x1" -a "x$WOLFSSL_ENABLED" = "x1"; then
           CURL_LIBRARY_PATH="$CURL_LIBRARY_PATH:$DIR_NGTCP2_CRYPTO_WOLFSSL"
           export CURL_LIBRARY_PATH
           AC_MSG_NOTICE([Added $DIR_NGTCP2_CRYPTO_WOLFSSL to CURL_LIBRARY_PATH])
+          LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libngtcp2_crypto_wolfssl"
        )
       ],
         dnl not found, revert back to clean variables
@@ -3174,7 +3192,7 @@ if test "x$want_openssl_quic" = "xyes"; then
     AC_MSG_ERROR([--with-openssl-quic and --with-ngtcp2 are mutually exclusive])
   fi
   if test "$HAVE_OPENSSL_QUIC" != 1; then
-    AC_MSG_ERROR([--with-openssl-quic requires quic support in OpenSSL])
+    AC_MSG_ERROR([--with-openssl-quic requires quic support and OpenSSL >= 3.3.0])
   fi
   AC_DEFINE(USE_OPENSSL_QUIC, 1, [if openssl QUIC is in use])
   AC_SUBST(USE_OPENSSL_QUIC, [1])
@@ -3216,6 +3234,11 @@ esac
 curl_http3_msg="no      (--with-nghttp3)"
 if test X"$want_nghttp3" != Xno; then
 
+  if test "x$USE_NGTCP2" != "x1" -a "x$USE_OPENSSL_QUIC" != "x1"; then
+    # without ngtcp2 or openssl quic, nghttp3 is of no use for us
+    AC_MSG_ERROR([nghttp3 enabled without a QUIC library; enable ngtcp2 or OpenSSL-QUIC])
+  fi
+
   dnl backup the pre-nghttp3 variables
   CLEANLDFLAGS="$LDFLAGS"
   CLEANCPPFLAGS="$CPPFLAGS"
@@ -3251,6 +3274,7 @@ if test X"$want_nghttp3" != Xno; then
           CURL_LIBRARY_PATH="$CURL_LIBRARY_PATH:$DIR_NGHTTP3"
           export CURL_LIBRARY_PATH
           AC_MSG_NOTICE([Added $DIR_NGHTTP3 to CURL_LIBRARY_PATH])
+          LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libnghttp3"
        )
       ],
         dnl not found, revert back to clean variables
@@ -3374,7 +3398,8 @@ if test X"$want_quiche" != Xno; then
           AC_CHECK_FUNCS([quiche_conn_set_qlog_fd])
           CURL_LIBRARY_PATH="$CURL_LIBRARY_PATH:$DIR_QUICHE"
           export CURL_LIBRARY_PATH
-          AC_MSG_NOTICE([Added $DIR_QUICHE to CURL_LIBRARY_PATH]),
+          AC_MSG_NOTICE([Added $DIR_QUICHE to CURL_LIBRARY_PATH])
+          LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE quiche",
           [],
           [
 AC_INCLUDES_DEFAULT
@@ -3469,7 +3494,8 @@ if test X"$want_msh3" != Xno; then
         AC_SUBST(USE_MSH3, [1])
         CURL_LIBRARY_PATH="$CURL_LIBRARY_PATH:$DIR_MSH3"
         export CURL_LIBRARY_PATH
-        AC_MSG_NOTICE([Added $DIR_MSH3 to CURL_LIBRARY_PATH]),
+        AC_MSG_NOTICE([Added $DIR_MSH3 to CURL_LIBRARY_PATH])
+        LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libmsh3"
         experimental="$experimental HTTP3"
      )
     ],
@@ -3523,7 +3549,7 @@ case "$OPT_FISH_FPATH" in
     dnl --with-fish-functions-dir option used without path
     CURL_CHECK_PKGCONFIG(fish)
     if test "$PKGCONFIG" != "no" ; then
-      FISH_FUNCTIONS_DIR="$($PKGCONFIG --variable completionsdir fish)"
+      FISH_FUNCTIONS_DIR=`$PKGCONFIG --variable completionsdir fish`
     else
       FISH_FUNCTIONS_DIR="$datarootdir/fish/vendor_completions.d"
     fi
@@ -3575,6 +3601,7 @@ AC_CHECK_HEADERS(
         stdbool.h \
         sys/filio.h \
         sys/wait.h \
+        sys/eventfd.h \
         setjmp.h,
 dnl to do if not found
 [],
@@ -3780,6 +3807,7 @@ AC_CHECK_DECLS([getpwuid_r], [], [AC_DEFINE(HAVE_DECL_GETPWUID_R_MISSING, 1, "Se
 AC_CHECK_FUNCS([\
   _fseeki64 \
   arc4random \
+  eventfd \
   fnmatch \
   fseeko \
   geteuid \
@@ -3800,26 +3828,6 @@ AC_CHECK_FUNCS([\
   snprintf \
   utime \
   utimes \
-],[
-],[
-  func="$ac_func"
-  eval skipcheck=\$skipcheck_$func
-  if test "x$skipcheck" != "xyes"; then
-    AC_MSG_CHECKING([deeper for $func])
-    AC_LINK_IFELSE([
-      AC_LANG_PROGRAM([[
-      ]],[[
-        $func ();
-      ]])
-    ],[
-      AC_MSG_RESULT([yes])
-      eval "ac_cv_func_$func=yes"
-      AC_DEFINE_UNQUOTED(XC_SH_TR_CPP([HAVE_$func]), [1],
-        [Define to 1 if you have the $func function.])
-    ],[
-      AC_MSG_RESULT([but still no])
-    ])
-  fi
 ])
 
 dnl On Android, the only way to know if fseeko can be used is to see if it is
@@ -3870,6 +3878,10 @@ AM_CONDITIONAL(BUILD_LIBHOSTNAME, test x$build_libhostname = xyes)
 
 if test "x$want_ares" != xyes; then
   CURL_CHECK_OPTION_THREADED_RESOLVER
+
+  if test "$ipv6" = yes; then
+    CURL_DARWIN_SYSTEMCONFIGURATION
+  fi
 fi
 
 dnl ************************************************************
@@ -3917,7 +3929,7 @@ if test "$want_pthreads" != "no"; then
   AC_CHECK_HEADER(pthread.h,
     [ AC_DEFINE(HAVE_PTHREAD_H, 1, [if you have <pthread.h>])
       save_CFLAGS="$CFLAGS"
-      dnl When statically linking against boringssl, -lpthread is added to LIBS.
+      dnl When statically linking against BoringSSL, -lpthread is added to LIBS.
       dnl Make sure to that this does not pass the check below, we really want
       dnl -pthread in CFLAGS as recommended for GCC. This also ensures that
       dnl lib1541 and lib1565 tests are built with these options. Otherwise
@@ -4571,15 +4583,15 @@ if test "x$want_ech" != "xno"; then
       ECH_SUPPORT="ECH support available via OpenSSL with SSL_ech_set1_echconfig"
       ECH_ENABLED=1)
   fi
-  dnl check for boringssl equivalent
+  dnl check for BoringSSL equivalent
   if test "x$OPENSSL_ENABLED" = "x1"; then
     AC_CHECK_FUNCS(SSL_set1_ech_config_list,
-      ECH_SUPPORT="ECH support available via boringssl with SSL_set1_ech_config_list"
+      ECH_SUPPORT="ECH support available via BoringSSL with SSL_set1_ech_config_list"
       ECH_ENABLED=1)
   fi
   if test "x$WOLFSSL_ENABLED" = "x1"; then
     AC_CHECK_FUNCS(wolfSSL_CTX_GenerateEchConfig,
-      ECH_SUPPORT="ECH support available via WolfSSL with wolfSSL_CTX_GenerateEchConfig"
+      ECH_SUPPORT="ECH support available via wolfSSL with wolfSSL_CTX_GenerateEchConfig"
       ECH_ENABLED=1)
   fi
 
@@ -4665,12 +4677,20 @@ dnl to let curl-config output the static libraries correctly
 ENABLE_STATIC="$enable_static"
 AC_SUBST(ENABLE_STATIC)
 
-dnl merge the pkg-config Libs.private field into Libs when static-only
+squeeze LIBCURL_PC_REQUIRES_PRIVATE
+LIBCURL_PC_REQUIRES_PRIVATE=`echo $LIBCURL_PC_REQUIRES_PRIVATE | tr ' ' ','`
+
+AC_SUBST(LIBCURL_PC_REQUIRES_PRIVATE)
+
+dnl Merge pkg-config private fields into public ones when static-only
 if test "x$enable_shared" = "xno"; then
+  LIBCURL_PC_REQUIRES=$LIBCURL_PC_REQUIRES_PRIVATE
   LIBCURL_NO_SHARED=$LIBCURL_LIBS
 else
+  LIBCURL_PC_REQUIRES=
   LIBCURL_NO_SHARED=
 fi
+AC_SUBST(LIBCURL_PC_REQUIRES)
 AC_SUBST(LIBCURL_NO_SHARED)
 
 rm $compilersh
@@ -4804,6 +4824,12 @@ else
   AC_MSG_RESULT([no])
 fi
 
+if test "x$OPENSSL_ENABLED" = "x1" -o -n "$SSL_ENABLED"; then
+  if test "x$ECH_ENABLED" = "x1"; then
+    SUPPORT_FEATURES="$SUPPORT_FEATURES ECH"
+  fi
+fi
+
 if test ${ac_cv_sizeof_curl_off_t} -gt 4; then
   if test ${ac_cv_sizeof_off_t} -gt 4 -o \
      "$curl_win32_file_api" = "win32_large_files"; then
@@ -4831,10 +4857,21 @@ else
   ])
 fi
 
+if test "x$want_debug" = "xyes"; then
+  SUPPORT_FEATURES="$SUPPORT_FEATURES Debug"
+fi
+if test "x$want_curldebug" = "xyes"; then
+  SUPPORT_FEATURES="$SUPPORT_FEATURES TrackMemory"
+fi
+
 dnl replace spaces with newlines
 dnl sort the lines
 dnl replace the newlines back to spaces
-SUPPORT_FEATURES=`echo $SUPPORT_FEATURES | tr ' ' '\012' | sort | tr '\012' ' '`
+if sort -f </dev/null >/dev/null 2>&1; then
+  SUPPORT_FEATURES=`echo $SUPPORT_FEATURES | tr ' ' '\012' | sort -f | tr '\012' ' '`
+else
+  SUPPORT_FEATURES=`echo $SUPPORT_FEATURES | tr ' ' '\012' | sort | tr '\012' ' '`
+fi
 AC_SUBST(SUPPORT_FEATURES)
 
 dnl For supported protocols in pkg-config file
@@ -4987,12 +5024,15 @@ AC_OUTPUT
 
 CURL_GENERATE_CONFIGUREHELP_PM
 
+SUPPORT_PROTOCOLS_LOWER=`echo "$SUPPORT_PROTOCOLS" | tr A-Z a-z`
+
 AC_MSG_NOTICE([Configured to build curl/libcurl:
 
   Host setup:       ${host}
   Install prefix:   ${prefix}
   Compiler:         ${CC}
    CFLAGS:          ${CFLAGS}
+   CFLAGS extras:   ${CURL_CFLAG_EXTRAS}
    CPPFLAGS:        ${CPPFLAGS}
    LDFLAGS:         ${LDFLAGS}
    LIBS:            ${LIBS}
@@ -5033,19 +5073,19 @@ AC_MSG_NOTICE([Configured to build curl/libcurl:
   HTTP3:            ${curl_h3_msg}
   ECH:              ${curl_ech_msg}
   WebSockets:       ${curl_ws_msg}
-  Protocols:        ${SUPPORT_PROTOCOLS}
+  Protocols:        ${SUPPORT_PROTOCOLS_LOWER}
   Features:         ${SUPPORT_FEATURES}
 ])
 
-non13=`echo "$TLSCHOICE" | grep -Ei 'bearssl|secure-transport|mbedtls'`;
+non13=`echo "$TLSCHOICE" | $EGREP -io 'bearssl|secure-transport'`;
 if test -n "$non13"; then
- cat >&2 << _EOF
-  WARNING: A selected TLS library ($TLSCHOICE) does not support TLS 1.3!
-_EOF
+ for a in $non13; do
+   AC_MSG_WARN([$a is enabled for TLS but it does not support TLS 1.3])
+ done
 fi
 
 if test -n "$experimental"; then
- cat >&2 << _EOF
-  WARNING: $experimental enabled but marked EXPERIMENTAL. Use with caution!
-_EOF
+ for a in $experimental; do
+   AC_MSG_WARN([$a is enabled but marked EXPERIMENTAL. Use with caution!])
+ done
 fi
diff --git a/curl-config.in b/curl-config.in
index 085bb1ef5..5d40bc39f 100644
--- a/curl-config.in
+++ b/curl-config.in
@@ -23,6 +23,8 @@
 #
 ###########################################################################
 
+# shellcheck disable=SC2006
+
 prefix="@prefix@"
 # Used in @libdir@
 # shellcheck disable=SC2034
@@ -100,17 +102,17 @@ while test "$#" -gt 0; do
 
   --checkfor)
     checkfor=$2
-    cmajor=$(echo "$checkfor" | cut -d. -f1)
-    cminor=$(echo "$checkfor" | cut -d. -f2)
+    cmajor=`echo "$checkfor" | cut -d. -f1`
+    cminor=`echo "$checkfor" | cut -d. -f2`
     # when extracting the patch part we strip off everything after a
     # dash as that's used for things like version 1.2.3-pre1
-    cpatch=$(echo "$checkfor" | cut -d. -f3 | cut -d- -f1)
+    cpatch=`echo "$checkfor" | cut -d. -f3 | cut -d- -f1`
 
-    vmajor=$(echo '@CURLVERSION@' | cut -d. -f1)
-    vminor=$(echo '@CURLVERSION@' | cut -d. -f2)
+    vmajor=`echo '@CURLVERSION@' | cut -d. -f1`
+    vminor=`echo '@CURLVERSION@' | cut -d. -f2`
     # when extracting the patch part we strip off everything after a
     # dash as that's used for things like version 1.2.3-pre1
-    vpatch=$(echo '@CURLVERSION@' | cut -d. -f3 | cut -d- -f1)
+    vpatch=`echo '@CURLVERSION@' | cut -d. -f3 | cut -d- -f1`
 
     if test "$vmajor" -gt "$cmajor"; then
       exit 0
diff --git a/docs/.gitignore b/docs/.gitignore
index a087be744..31ca7656e 100644
--- a/docs/.gitignore
+++ b/docs/.gitignore
@@ -4,3 +4,4 @@
 
 *.1
 *.3
+RELEASE-TOOLS.md.dist
diff --git a/docs/BINDINGS.md b/docs/BINDINGS.md
index e2580b42b..970df396c 100644
--- a/docs/BINDINGS.md
+++ b/docs/BINDINGS.md
@@ -63,7 +63,7 @@ Go: [go-curl](https://github.com/andelf/go-curl) by ShuYu Wang
 
 [Hollywood](https://www.hollywood-mal.com/download.html) hURL by Andreas Falkenhahn
 
-[Java](https://github.com/pjlegato/curl-java)
+[Java](https://github.com/covers1624/curl4j)
 
 [Julia](https://github.com/JuliaWeb/LibCURL.jl) Written by Amit Murthy
 
diff --git a/docs/CIPHERS.md b/docs/CIPHERS.md
index d55989bfa..607810c04 100644
--- a/docs/CIPHERS.md
+++ b/docs/CIPHERS.md
@@ -25,7 +25,7 @@ libcurl was built to use. This is an attempt to list known cipher names.
 
 ## OpenSSL
 
-(based on [OpenSSL docs](https://www.openssl.org/docs/manmaster/man1/openssl-ciphers.html))
+(based on [OpenSSL docs](https://docs.openssl.org/master/man1/openssl-ciphers/))
 
 When specifying multiple cipher names, separate them with colon (`:`).
 
@@ -171,7 +171,7 @@ When specifying multiple cipher names, separate them with colon (`:`).
 `TLS_AES_128_CCM_8_SHA256`
 `TLS_AES_128_CCM_SHA256`
 
-## WolfSSL
+## wolfSSL
 
 `RC4-SHA`,
 `RC4-MD5`,
diff --git a/docs/CLIENT-READERS.md b/docs/CLIENT-READERS.md
index 30a4725b1..073063845 100644
--- a/docs/CLIENT-READERS.md
+++ b/docs/CLIENT-READERS.md
@@ -123,7 +123,7 @@ Readers operating on callbacks to the application need to "rewind" the underlyin
 
 ## Summary and Outlook
 
-By adding the client reader interface, any protocol can control how/if it wants the curl transfer to send bytes for a request. The transfer loop becomes then blissfully ignorant of the specifics. 
+By adding the client reader interface, any protocol can control how/if it wants the curl transfer to send bytes for a request. The transfer loop becomes then blissfully ignorant of the specifics.
 
 The protocols on the other hand no longer have to care to package data most efficiently. At any time, should more data be needed, it can be read from the client. This is used when sending HTTP requests headers to add as much request body data to the initial sending as there is room for.
 
diff --git a/docs/CMakeLists.txt b/docs/CMakeLists.txt
index cb7999645..9fd494408 100644
--- a/docs/CMakeLists.txt
+++ b/docs/CMakeLists.txt
@@ -21,7 +21,7 @@
 # SPDX-License-Identifier: curl
 #
 ###########################################################################
-#add_subdirectory(examples)
+
 if(BUILD_LIBCURL_DOCS)
   add_subdirectory(libcurl)
 endif()
diff --git a/docs/CODE_REVIEW.md b/docs/CODE_REVIEW.md
index b78992a3e..bee26a3f3 100644
--- a/docs/CODE_REVIEW.md
+++ b/docs/CODE_REVIEW.md
@@ -141,13 +141,13 @@ data. Where it comes from and where it goes.
 `size_t` is not a fixed size. `time_t` can be signed or unsigned and have
 different sizes. Relying on variable sizes is a red flag.
 
-Also remember that endianness and >= 32 bit accesses to unaligned addresses
+Also remember that endianness and >= 32-bit accesses to unaligned addresses
 are problematic areas.
 
 ## Integer overflows
 
-Be careful about integer overflows. Some variable types can be either 32 bit
-or 64 bit. Integer overflows must be detected and acted on *before* they
+Be careful about integer overflows. Some variable types can be either 32-bit
+or 64-bit. Integer overflows must be detected and acted on *before* they
 happen.
 
 ## Dangerous use of functions
diff --git a/docs/CONNECTION-FILTERS.md b/docs/CONNECTION-FILTERS.md
index 6b20f93de..629e769b9 100644
--- a/docs/CONNECTION-FILTERS.md
+++ b/docs/CONNECTION-FILTERS.md
@@ -271,7 +271,7 @@ conn[curl.se] --> SETUP[TCP] --> HAPPY-EYEBALLS --> TCP[2a04:4e42:c00::347]:443
 * transfer
 ```
 
-The modular design of connection filters and that we can plug them into each other is used to control the parallel attempts. When a `TCP` filter does not connect (in time), it is torn down and another one is created for the next address. This keeps the `TCP` filter simple. 
+The modular design of connection filters and that we can plug them into each other is used to control the parallel attempts. When a `TCP` filter does not connect (in time), it is torn down and another one is created for the next address. This keeps the `TCP` filter simple.
 
 The `HAPPY-EYEBALLS` on the other hand stays focused on its side of the problem. We can use it also to make other type of connection by just giving it another filter type to try to have happy eyeballing for QUIC:
 
diff --git a/docs/CONTRIBUTE.md b/docs/CONTRIBUTE.md
index bffcd5a94..156ea0bef 100644
--- a/docs/CONTRIBUTE.md
+++ b/docs/CONTRIBUTE.md
@@ -316,8 +316,8 @@ fine.
 This means that all files need to have their license and copyright information
 clearly stated. Ideally by having the standard curl source code header, with
 the SPDX-License-Identifier included. If the header does not work, you can use a
-smaller header or add the information for a specific file to the `.reuse/dep5`
+smaller header or add the information for a specific file to the `REUSE.toml`
 file.
 
 You can manually verify the copyright and compliance status by running the
-`./scripts/copyright.pl` script in the root of the git repository.
+[REUSE helper tool](https://github.com/fsfe/reuse-tool): `reuse lint`
diff --git a/docs/CURLDOWN.md b/docs/CURLDOWN.md
index 910438976..18c1cbc3c 100644
--- a/docs/CURLDOWN.md
+++ b/docs/CURLDOWN.md
@@ -80,6 +80,7 @@ Each curldown starts with a header with meta-data:
       - CURLOPT_HTTPAUTH (3)
     TLS-backend:
       - [name]
+    Added-in: [version or "n/a"]
     ---
 
 All curldown files *must* have all the headers present and at least one
@@ -97,7 +98,7 @@ option. The available TLS backends are:
 - `BearSSL`
 - `GnuTLS`
 - `mbedTLS`
-- `OpenSSL` (also covers BoringSSL, libressl, quictls, AWS-LC and AmiSSL)
+- `OpenSSL` (also covers BoringSSL, LibreSSL, quictls, AWS-LC and AmiSSL)
 - `rustls`
 - `Schannel`
 - `Secure Transport`
@@ -147,7 +148,15 @@ readable.
 To make sure curldown documents render correctly as markdown, all literal
 occurrences of `<` or `>` need to be escaped by a leading backslash.
 
-## symbols
+## Generating contents
+
+`# %PROTOCOLS%` - inserts a **PROTOCOLS** section based on the metadata
+provided in the header.
+
+`# %AVAILABILITY%` - inserts an **AVAILABILITY** section based on the metadata
+provided in the header.
+
+## Symbols
 
 All mentioned curl symbols that have their own man pages, like
 `curl_easy_perform(3)` are automatically rendered using italics in the output
diff --git a/docs/DEPRECATE.md b/docs/DEPRECATE.md
index 0e39903e1..6ad931723 100644
--- a/docs/DEPRECATE.md
+++ b/docs/DEPRECATE.md
@@ -23,33 +23,15 @@ and use TLS 1.3, or else it is not good enough.
 As of May 2024, the libraries that need to get fixed to remain supported after
 May 2025 are: BearSSL and Secure Transport.
 
-## space-separated `NOPROXY` patterns
-
-When specifying patterns/domain names for curl that should *not* go through a
-proxy, the curl tool features the `--noproxy` command line option and the
-library supports the `NO_PROXY` environment variable and the `CURLOPT_NOPROXY`
-libcurl option.
-
-They all set the same list of patterns. This list is documented to be a set of
-**comma-separated** names, but can also be provided separated with just
-space. The ability to just use spaces for this has never been documented but
-some users may still have come to rely on this.
-
-Several other tools and utilities also parse the `NO_PROXY` environment
-variable but do not consider a space to be a valid separator. Using spaces for
-separator is probably less portable and might cause more friction than commas
-do. Users should use commas for this for greater portability.
-
-curl removes the support for space-separated names in July 2024.
-
-## past removals
+## Past removals
 
  - Pipelining
  - axTLS
  - PolarSSL
  - NPN
- - Support for systems without 64 bit data types
+ - Support for systems without 64-bit data types
  - NSS
  - gskit
  - mingw v1
  - NTLM_WB
+ - space-separated `NOPROXY` patterns
diff --git a/docs/DISTROS.md b/docs/DISTROS.md
index 863b0fec7..c3ae64c81 100644
--- a/docs/DISTROS.md
+++ b/docs/DISTROS.md
@@ -14,11 +14,12 @@ distro. Those marked *Rolling Release* typically run the latest version of curl
 and are therefore less likely to have back-ported patches to older versions.
 
 We discuss curl distro issues, patches and collaboration on the [curl-distros
-mailing list](https://lists.haxx.se/listinfo/curl-distros).
+mailing list](https://lists.haxx.se/listinfo/curl-distros) ([list
+archives](https://curl.se/mail/list.cgi?list=curl-distros)).
 
 ## AlmaLinux
 
-- curl package source and patches: curl package source and patches
+- curl package source and patches: https://git.almalinux.org/rpms/curl/
 - curl issues: https://bugs.almalinux.org/view_all_bug_page.php click Category and choose curl
 - curl security: https://errata.almalinux.org/ search for curl
 
@@ -165,6 +166,14 @@ unless it is very specific to Homebrew's way of packaging software.
 
 *Rolling Release*
 
+- curl: https://github.com/msys2/MSYS2-packages/tree/master/curl
+- curl issues: https://github.com/msys2/MSYS2-packages/issues
+- curl patches: https://github.com/msys2/MSYS2-packages/tree/master/curl (`*.patch`)
+
+## MSYS2 (mingw-w64)
+
+*Rolling Release*
+
 - curl: https://github.com/msys2/MINGW-packages/tree/master/mingw-w64-curl
 - curl issues: https://github.com/msys2/MINGW-packages/issues
 - curl patches: https://github.com/msys2/MINGW-packages/tree/master/mingw-w64-curl (`*.patch`)
diff --git a/docs/ECH.md b/docs/ECH.md
index 150ef2afc..9c7cbf15f 100644
--- a/docs/ECH.md
+++ b/docs/ECH.md
@@ -6,16 +6,15 @@ SPDX-License-Identifier: curl
 
 # Building curl with HTTPS-RR and ECH support
 
-We've added support for ECH to in this curl build. That can use HTTPS RRs
-published in the DNS, if curl is using DoH, or else can accept the relevant
-ECHConfigList values from the command line. That works with OpenSSL,
-WolfSSL or boringssl as the TLS provider, depending on how you build curl.
+We have added support for ECH to curl. It can use HTTPS RRs published in the
+DNS if curl uses DoH, or else can accept the relevant ECHConfigList values
+from the command line. This works with OpenSSL, wolfSSL or BoringSSL as the
+TLS provider.
 
 This feature is EXPERIMENTAL. DO NOT USE IN PRODUCTION.
 
 This should however provide enough of a proof-of-concept to prompt an informed
-discussion about a good path forward for ECH support in curl, when using
-OpenSSL, or other TLS libraries, as those add ECH support.
+discussion about a good path forward for ECH support in curl.
 
 ## OpenSSL Build
 
@@ -42,21 +41,21 @@ To build curl ECH-enabled, making use of the above:
     autoreconf -fi
     LDFLAGS="-Wl,-rpath,$HOME/code/openssl-local-inst/lib/" ./configure --with-ssl=$HOME/code/openssl-local-inst --enable-ech --enable-httpsrr
     ...lots of output...
-    WARNING: ech ECH HTTPSRR enabled but marked EXPERIMENTAL...
+    WARNING: ECH HTTPSRR enabled but marked EXPERIMENTAL...
     make
     ...lots more output...
 ```
 
-If you do not get that WARNING at the end of the ``configure`` command, then ECH
-is not enabled, so go back some steps and re-do whatever needs re-doing:-) If you
-want to debug curl then you should add ``--enable-debug`` to the ``configure``
-command.
+If you do not get that WARNING at the end of the ``configure`` command, then
+ECH is not enabled, so go back some steps and re-do whatever needs re-doing:-)
+If you want to debug curl then you should add ``--enable-debug`` to the
+``configure`` command.
 
 In a recent (2024-05-20) build on one machine, configure failed to find the
 ECH-enabled SSL library, apparently due to the existence of
 ``$HOME/code/openssl-local-inst/lib/pkgconfig`` as a directory containing
-various settings. Deleting that directory worked around the problem but may not
-be the best solution.
+various settings. Deleting that directory worked around the problem but may
+not be the best solution.
 
 ## Using ECH and DoH
 
@@ -150,7 +149,7 @@ the verbose output, e.g.:
 ```
 
 At that point, you could copy the base64 encoded value above and try again.
-For now, this only works for the OpenSSL and boringssl builds.
+For now, this only works for the OpenSSL and BoringSSL builds.
 
 ## Default settings
 
@@ -216,7 +215,7 @@ or IP address hints.
 - ``USE_ECH`` protects ECH specific code.
 
 There are various obvious code blocks for handling the new command line
-arguments which aren't described here, but should be fairly clear.
+arguments which are not described here, but should be fairly clear.
 
 As shown in the ``configure`` usage above, there are ``configure.ac`` changes
 that allow separately dis/enabling ``USE_HTTPSRR`` and ``USE_ECH``. If ``USE_ECH``
@@ -270,7 +269,7 @@ curl might handle those values when present in the DNS.
   ("aliasMode") - the current code takes no account of that at all. One could
 envisage implementing the equivalent of following CNAMEs in such cases, but
 it is not clear if that'd be a good plan. (As of now, chrome browsers do not seem
-to have any support for that "aliasMode" and we've not checked Firefox for that
+to have any support for that "aliasMode" and we have not checked Firefox for that
 recently.)
 
 - We have not investigated what related changes or additions might be needed
@@ -282,7 +281,7 @@ doing so would seem to require re-implementing an ECH-enabled server as part
 of the curl test harness. For now, we have a ``./tests/ech_test.sh`` script
 that attempts ECH with various test servers and with many combinations of the
 allowed command line options. While that is a useful test and has find issues,
-it is not comprehensive and we're not (as yet) sure what would be the right
+it is not comprehensive and we are not (as yet) sure what would be the right
 level of coverage. When running that script you should not have a
 ``$HOME/.curlrc`` file that affects ECH or some of the negative tests could
 produce spurious failures.
@@ -307,7 +306,7 @@ To build with cmake, assuming our ECH-enabled OpenSSL is as before:
 The binary produced by the cmake build does not need any ECH-specific
 ``LD_LIBRARY_PATH`` setting.
 
-## boringssl build
+## BoringSSL build
 
 BoringSSL is also supported by curl and also supports ECH, so to build
 with that, instead of our ECH-enabled OpenSSL:
@@ -331,20 +330,20 @@ Then:
     autoreconf -fi
     LDFLAGS="-Wl,-rpath,$HOME/code/boringssl/inst/lib" ./configure --with-ssl=$HOME/code/boringssl/inst --enable-ech --enable-httpsrr
     ...lots of output...
-    WARNING: ech ECH HTTPSRR enabled but marked EXPERIMENTAL. Use with caution!
+    WARNING: ECH HTTPSRR enabled but marked EXPERIMENTAL. Use with caution!
     make
 ```
 
-The boringssl APIs are fairly similar to those in our ECH-enabled OpenSSL
+The BoringSSL APIs are fairly similar to those in our ECH-enabled OpenSSL
 fork, so code changes are also in ``lib/vtls/openssl.c``, protected
 via ``#ifdef OPENSSL_IS_BORINGSSL`` and are mostly obvious API variations.
- 
-The boringssl APIs however do not support the ``--ech pn:`` command line
+
+The BoringSSL APIs however do not support the ``--ech pn:`` command line
 variant as of now.
 
-## WolfSSL build
+## wolfSSL build
 
-WolfSSL also supports ECH and can be used by curl, so here's how:
+wolfSSL also supports ECH and can be used by curl, so here's how:
 
 ```bash
     cd $HOME/code
@@ -356,7 +355,7 @@ WolfSSL also supports ECH and can be used by curl, so here's how:
     make install
 ```
 
-The install prefix (``inst``) in the above causes WolfSSL to be installed there
+The install prefix (``inst``) in the above causes wolfSSL to be installed there
 and we seem to need that for the curl configure command to work out. The
 ``--enable-opensslextra`` turns out (after much faffing about;-) to be
 important or else we get build problems with curl below.
@@ -370,7 +369,7 @@ important or else we get build problems with curl below.
     make
 ```
 
-There are some known issues with the ECH implementation in WolfSSL:
+There are some known issues with the ECH implementation in wolfSSL:
 
 - The main issue is that the client currently handles HelloRetryRequest
   incorrectly.  [HRR issue](https://github.com/wolfSSL/wolfssl/issues/6802).)
@@ -378,32 +377,31 @@ There are some known issues with the ECH implementation in WolfSSL:
   [this ECH test web site](https://tls-ech.dev) and any other similarly configured
   sites.
 - There is also an issue related to so-called middlebox compatibility mode.
-  [middlebox compatibility issue](https://github.com/wolfSSL/wolfssl/issues/6774) 
+  [middlebox compatibility issue](https://github.com/wolfSSL/wolfssl/issues/6774)
 
-### Code changes to support WolfSSL
+### Code changes to support wolfSSL
 
 There are what seem like oddball differences:
 
-- The DoH URL in``$HOME/.curlrc`` can use "1.1.1.1" for OpenSSL but has to be
-  "one.one.one.one" for WolfSSL. The latter works for both, so OK, we'll change
-  to that.
-- There seems to be some difference in CA databases too - the WolfSSL version
-  does not like ``defo.ie``, whereas the system and OpenSSL ones do. We can ignore
-  that for our purposes via ``--insecure``/``-k`` but would need to fix for a
-  real setup. (Browsers do like those certificates though.)
+- The DoH URL in``$HOME/.curlrc`` can use `1.1.1.1` for OpenSSL but has to be
+  `one.one.one.one` for wolfSSL. The latter works for both, so OK, we us that.
+- There seems to be some difference in CA databases too - the wolfSSL version
+  does not like ``defo.ie``, whereas the system and OpenSSL ones do. We can
+  ignore that for our purposes via ``--insecure``/``-k`` but would need to fix
+  for a real setup. (Browsers do like those certificates though.)
 
 Then there are some functional code changes:
 
-- tweak to ``configure.ac`` to check if WolfSSL has ECH or not
+- tweak to ``configure.ac`` to check if wolfSSL has ECH or not
 - added code to ``lib/vtls/wolfssl.c`` mirroring what's done in the
   OpenSSL equivalent above.
-- WolfSSL does not support ``--ech false`` or the ``--ech pn:`` command line
+- wolfSSL does not support ``--ech false`` or the ``--ech pn:`` command line
   argument.
 
 The lack of support for ``--ech false`` is because wolfSSL has decided to
 always at least GREASE if built to support ECH. In other words, GREASE is
 a compile time choice for wolfSSL, but a runtime choice for OpenSSL or
-boringssl. (Both are reasonable.)
+BoringSSL. (Both are reasonable.)
 
 ## Additional notes
 
@@ -418,22 +416,22 @@ on localhost:53, so would fit this use-case. That said, it is unclear if
 this is a niche that is worth trying to address. (The author is just as happy to
 let curl use DoH to talk to the same public recursive that stubby might use:-)
 
-Assuming for the moment this is a use-case we'd like to support, then
-if DoH is not being used by curl, it is not clear at this time how to provide
+Assuming for the moment this is a use-case we would like to support, then if
+DoH is not being used by curl, it is not clear at this time how to provide
 support for ECH. One option would seem to be to extend the ``c-ares`` library
-to support HTTPS RRs, but in that case it is not now clear whether such changes
-would be attractive to the ``c-ares`` maintainers, nor whether the "tag=value"
-extensibility inherent in the HTTPS/SVCB specification is a good match for the
-``c-ares`` approach of defining structures specific to decoded answers for each
-supported RRtype. We're also not sure how many downstream curl deployments
-actually make use of the ``c-ares`` library, which would affect the utility of
-such changes. Another option might be to consider using some other generic DNS
-library that does support HTTPS RRs, but it is unclear if such a library could
-or would be used by all or almost all curl builds and downstream releases of
-curl.
+to support HTTPS RRs, but in that case it is not now clear whether such
+changes would be attractive to the ``c-ares`` maintainers, nor whether the
+"tag=value" extensibility inherent in the HTTPS/SVCB specification is a good
+match for the ``c-ares`` approach of defining structures specific to decoded
+answers for each supported RRtype. We are also not sure how many downstream
+curl deployments actually make use of the ``c-ares`` library, which would
+affect the utility of such changes. Another option might be to consider using
+some other generic DNS library that does support HTTPS RRs, but it is unclear
+if such a library could or would be used by all or almost all curl builds and
+downstream releases of curl.
 
 Our current conclusion is that doing the above is likely best left until we
-have some experience with the "using DoH" approach, so we're going to punt on
+have some experience with the "using DoH" approach, so we are going to punt on
 this for now.
 
 ### Debugging
@@ -447,7 +445,7 @@ LD_LIBRARY_PATH=$HOME/code/openssl:./lib/.libs gdb ./src/.libs/curl
 ### Localhost testing
 
 It can be useful to be able to run against a localhost OpenSSL ``s_server``
-for testing. We have published instructions for such 
+for testing. We have published instructions for such
 [localhost tests](https://github.com/defo-project/ech-dev-utils/blob/main/howtos/localhost-tests.md)
 in another repository. Once you have that set up, you can start a server
 and then run curl against that:
@@ -476,5 +474,5 @@ to get the HTTPS RR and pass the ECHConfigList from that on the command line,
 if needed, or one can access the value from command line output in verbose more
 and then re-use that in another invocation.
 
-Both our OpenSSL fork and boringssl have APIs for both controlling GREASE and
-accessing and logging ``retry_configs``, it seems WolfSSL has neither.
+Both our OpenSSL fork and BoringSSL have APIs for both controlling GREASE and
+accessing and logging ``retry_configs``, it seems wolfSSL has neither.
diff --git a/docs/FAQ b/docs/FAQ
index 0303a262a..12c743bb5 100644
--- a/docs/FAQ
+++ b/docs/FAQ
@@ -56,7 +56,7 @@ FAQ
  4. Running Problems
   4.2 Why do I get problems when I use & or % in the URL?
   4.3 How can I use {, }, [ or ] to specify multiple URLs?
-  4.4 Why do I get downloaded data even though the web page does not exist?
+  4.4 Why do I get downloaded data even though the webpage does not exist?
   4.5 Why do I get return code XXX from an HTTP server?
    4.5.1 "400 Bad Request"
    4.5.2 "401 Unauthorized"
@@ -65,7 +65,7 @@ FAQ
    4.5.5 "405 Method Not Allowed"
    4.5.6 "301 Moved Permanently"
   4.6 Can you tell me what error code 142 means?
-  4.7 How do I keep user names and passwords secret in curl command lines?
+  4.7 How do I keep usernames and passwords secret in curl command lines?
   4.8 I found a bug
   4.9 curl cannot authenticate to a server that requires NTLM?
   4.10 My HTTP request using HEAD, PUT or DELETE does not work
@@ -89,7 +89,7 @@ FAQ
   5.6 What about Keep-Alive or persistent connections?
   5.7 Link errors when building libcurl on Windows
   5.8 libcurl.so.X: open failed: No such file or directory
-  5.9 How does libcurl resolve host names?
+  5.9 How does libcurl resolve hostnames?
   5.10 How do I prevent libcurl from writing the response to stdout?
   5.11 How do I make libcurl not receive the whole HTTP response?
   5.12 Can I make libcurl fake or hide my real IP address?
@@ -423,7 +423,7 @@ FAQ
   backends.
 
   curl can be built to use one of the following SSL alternatives: OpenSSL,
-  libressl, BoringSSL, AWS-LC, GnuTLS, wolfSSL, mbedTLS, Secure Transport
+  LibreSSL, BoringSSL, AWS-LC, GnuTLS, wolfSSL, mbedTLS, Secure Transport
   (native iOS/OS X), Schannel (native Windows), BearSSL or Rustls. They all
   have their pros and cons, and we try to maintain a comparison of them here:
   https://curl.se/docs/ssl-compared.html
@@ -624,7 +624,7 @@ FAQ
 
   3.14 Does curl support JavaScript or PAC (automated proxy config)?
 
-  Many web pages do magic stuff using embedded JavaScript. curl and libcurl
+  Many webpages do magic stuff using embedded JavaScript. curl and libcurl
   have no built-in support for that, so it will be treated just like any other
   contents.
 
@@ -722,7 +722,7 @@ FAQ
 
     curl --header "Host: www.example.com" http://127.0.0.1/
 
-  You can also opt to add faked host name entries to curl with the --resolve
+  You can also opt to add faked hostname entries to curl with the --resolve
   option. That has the added benefit that things like redirects will also work
   properly. The above operation would instead be done as:
 
@@ -771,11 +771,10 @@ FAQ
   [WHATEVER]. This way you can for example send a DELETE by doing "curl -X
   DELETE [URL]".
 
-  It is thus pointless to do "curl -XGET [URL]" as GET would be used
-  anyway. In the same vein it is pointless to do "curl -X POST -d data
-  [URL]"... But you can make a fun and somewhat rare request that sends a
-  request-body in a GET request with something like "curl -X GET -d data
-  [URL]"
+  It is thus pointless to do "curl -XGET [URL]" as GET would be used anyway.
+  In the same vein it is pointless to do "curl -X POST -d data [URL]". You can
+  make a fun and somewhat rare request that sends a request-body in a GET
+  request with something like "curl -X GET -d data [URL]"
 
   Note that -X does not actually change curl's behavior as it only modifies the
   actual string sent in the request, but that may of course trigger a
@@ -822,7 +821,7 @@ FAQ
 
     curl -g 'www.example.com/weirdname[].html'
 
-  4.4 Why do I get downloaded data even though the web page does not exist?
+  4.4 Why do I get downloaded data even though the webpage does not exist?
 
   curl asks remote servers for the page you specify. If the page does not exist
   at the server, the HTTP protocol defines how the server should respond and
@@ -883,7 +882,7 @@ FAQ
   appreciate a detailed bug report from you that describes how we could go
   ahead and repeat this.
 
-  4.7 How do I keep user names and passwords secret in curl command lines?
+  4.7 How do I keep usernames and passwords secret in curl command lines?
 
   This problem has two sides:
 
@@ -1100,7 +1099,7 @@ FAQ
   When doing HTTP transfers, curl will perform exactly what you are asking it
   to do and if successful it will not return an error. You can use curl to
   test your web server's "file not found" page (that gets 404 back), you can
-  use it to check your authentication protected web pages (that gets a 401
+  use it to check your authentication protected webpages (that gets a 401
   back) and so on.
 
   The specific HTTP response code does not constitute a problem or error for
@@ -1192,7 +1191,7 @@ FAQ
   5.6 What about Keep-Alive or persistent connections?
 
   curl and libcurl have excellent support for persistent connections when
-  transferring several files from the same server.  curl will attempt to reuse
+  transferring several files from the same server. curl will attempt to reuse
   connections for all URLs specified on the same command line/config file, and
   libcurl will reuse connections for all transfers that are made using the
   same libcurl handle.
@@ -1252,14 +1251,14 @@ FAQ
 
   'man ld.so' and 'man ld' will tell you more details
 
-  5.9 How does libcurl resolve host names?
+  5.9 How does libcurl resolve hostnames?
 
   libcurl supports a large number of name resolve functions. One of them is
   picked at build-time and will be used unconditionally. Thus, if you want to
   change name resolver function you must rebuild libcurl and tell it to use a
   different function.
 
-  - The non-IPv6 resolver that can use one of four different host name resolve
+  - The non-IPv6 resolver that can use one of four different hostname resolve
   calls (depending on what your system supports):
 
       A - gethostbyname()
diff --git a/docs/FEATURES.md b/docs/FEATURES.md
index 3121fcc90..ef5fd0fc1 100644
--- a/docs/FEATURES.md
+++ b/docs/FEATURES.md
@@ -12,7 +12,6 @@ SPDX-License-Identifier: curl
  - multiple URLs in a single command line
  - range "globbing" support: [0-13], {one,two,three}
  - multiple file upload on a single command line
- - custom maximum transfer rate
  - redirect stderr
  - parallel transfers
 
@@ -20,39 +19,74 @@ SPDX-License-Identifier: curl
 
  - URL RFC 3986 syntax
  - custom maximum download time
- - custom least download speed acceptable
+ - custom lowest download speed acceptable
  - custom output result after completion
  - guesses protocol from hostname unless specified
- - uses .netrc
+ - supports .netrc
  - progress bar with time statistics while downloading
- - "standard" proxy environment variables support
- - compiles on win32 (reported builds on 70+ operating systems)
+ - standard proxy environment variables support
+ - have run on 101 operating systems and 28 CPU architectures
  - selectable network interface for outgoing traffic
  - IPv6 support on Unix and Windows
- - happy eyeballs dual-stack connects
+ - happy eyeballs dual-stack IPv4 + IPv6 connects
  - persistent connections
  - SOCKS 4 + 5 support, with or without local name resolving
+ - *pre-proxy* support, for *proxy chaining*
  - supports username and password in proxy environment variables
  - operations through HTTP proxy "tunnel" (using CONNECT)
  - replaceable memory functions (malloc, free, realloc, etc)
- - asynchronous name resolving (6)
+ - asynchronous name resolving
  - both a push and a pull style interface
- - international domain names (10)
+ - international domain names (IDN)
+ - transfer late limiting
+ - stable API and ABI
+ - TCP keep alive
+ - TCP Fast Open
+ - DNS cache (that can be shared between transfers)
+ - non-blocking single-threaded parallel transfers
+ - unix domain sockets to server or proxy
+ - DNS-over-HTTPS
+ - uses non-blocking name resolves
+ - selectable name resolver backend
+
+## URL API
+
+ - parses RFC 3986 URLs
+ - generates URLs from individual components
+ - manages "redirects"
+
+## Header API
+
+ - easy access to HTTP response headers, from all contexts
+ - named headers
+ - iterate over headers
+
+## TLS
+
+ - selectable TLS backend(s)
+ - TLS False Start
+ - TLS version control
+ - TLS session resumption
+ - key pinning
+ - mutual authentication
+ - Use dedicated CA cert bundle
+ - Use OS-provided CA store
+ - separate TLS options for HTTPS proxy
 
 ## HTTP
 
  - HTTP/0.9 responses are optionally accepted
  - HTTP/1.0
  - HTTP/1.1
- - HTTP/2, including multiplexing and server push (5)
+ - HTTP/2, including multiplexing and server push
  - GET
  - PUT
  - HEAD
  - POST
  - multipart formpost (RFC 1867-style)
- - authentication: Basic, Digest, NTLM (9) and Negotiate (SPNEGO) (3)
+ - authentication: Basic, Digest, NTLM (9) and Negotiate (SPNEGO)
    to server and proxy
- - resume (both GET and PUT)
+ - resume transfers
  - follow redirects
  - maximum amount of redirects to follow
  - custom HTTP request
@@ -65,26 +99,30 @@ SPDX-License-Identifier: curl
  - proxy authentication
  - time conditions
  - via HTTP proxy, HTTPS proxy or SOCKS proxy
+ - HTTP/2 or HTTP/1.1 to HTTPS proxy
  - retrieve file modification date
- - Content-Encoding support for deflate and gzip
+ - Content-Encoding support for deflate, gzip, brotli and zstd
  - "Transfer-Encoding: chunked" support in uploads
- - automatic data compression (11)
+ - HSTS
+ - alt-svc
+ - ETags
+ - HTTP/1.1 trailers, both sending and getting
 
-## HTTPS (1)
+## HTTPS
 
- - (all the HTTP features)
- - HTTP/3 experimental support
+ - HTTP/3
  - using client certificates
  - verify server certificate
  - via HTTP proxy, HTTPS proxy or SOCKS proxy
  - select desired encryption
- - select usage of a specific SSL version
+ - select usage of a specific TLS version
+ - ECH
 
 ## FTP
 
  - download
  - authentication
- - Kerberos 5 (12)
+ - Kerberos 5
  - active/passive using PORT, EPRT, PASV or EPSV
  - single file size information (compare to HTTP HEAD)
  - 'type=' URL support
@@ -102,20 +140,24 @@ SPDX-License-Identifier: curl
  - customizable to retrieve file modification date
  - no directory depth limit
 
-## FTPS (1)
+## FTPS
 
  - implicit `ftps://` support that use SSL on both connections
  - explicit "AUTH TLS" and "AUTH SSL" usage to "upgrade" plain `ftp://`
    connection to use SSL for both or one of the connections
 
-## SCP (8)
+## SSH (both SCP and SFTP)
 
+ - selectable SSH backend
+ - known hosts support
+ - public key fingerprinting
  - both password and public key auth
 
-## SFTP (7)
+## SFTP
 
  - both password and public key auth
  - with custom commands sent before/after the transfer
+ - directory listing
 
 ## TFTP
 
@@ -128,7 +170,7 @@ SPDX-License-Identifier: curl
  - custom telnet options
  - stdin/stdout I/O
 
-## LDAP (2)
+## LDAP
 
  - full LDAP URL support
 
@@ -151,8 +193,8 @@ SPDX-License-Identifier: curl
 
 ## SMTP
 
- - authentication: Plain, Login, CRAM-MD5, Digest-MD5, NTLM (9), Kerberos 5
-   (4) and External.
+ - authentication: Plain, Login, CRAM-MD5, Digest-MD5, NTLM, Kerberos 5 and
+   External
  - send emails
  - mail from support
  - mail size support
@@ -160,7 +202,7 @@ SPDX-License-Identifier: curl
  - multiple recipients
  - via http-proxy
 
-## SMTPS (1)
+## SMTPS
 
  - implicit `smtps://` support
  - explicit "STARTTLS" usage to "upgrade" plain `smtp://` connections to use SSL
@@ -169,15 +211,15 @@ SPDX-License-Identifier: curl
 ## POP3
 
  - authentication: Clear Text, APOP and SASL
- - SASL based authentication: Plain, Login, CRAM-MD5, Digest-MD5, NTLM (9),
-   Kerberos 5 (4) and External.
+ - SASL based authentication: Plain, Login, CRAM-MD5, Digest-MD5, NTLM,
+   Kerberos 5 and External
  - list emails
  - retrieve emails
  - enhanced command support for: CAPA, DELE, TOP, STAT, UIDL and NOOP via
    custom requests
  - via http-proxy
 
-## POP3S (1)
+## POP3S
 
  - implicit `pop3s://` support
  - explicit `STLS` usage to "upgrade" plain `pop3://` connections to use SSL
@@ -186,8 +228,8 @@ SPDX-License-Identifier: curl
 ## IMAP
 
  - authentication: Clear Text and SASL
- - SASL based authentication: Plain, Login, CRAM-MD5, Digest-MD5, NTLM (9),
-   Kerberos 5 (4) and External.
+ - SASL based authentication: Plain, Login, CRAM-MD5, Digest-MD5, NTLM,
+   Kerberos 5 and External
  - list the folders of a mailbox
  - select a mailbox with support for verifying the `UIDVALIDITY`
  - fetch emails with support for specifying the UID and SECTION
@@ -196,7 +238,7 @@ SPDX-License-Identifier: curl
    STORE, COPY and UID via custom requests
  - via http-proxy
 
-## IMAPS (1)
+## IMAPS
 
  - implicit `imaps://` support
  - explicit "STARTTLS" usage to "upgrade" plain `imap://` connections to use SSL
@@ -205,21 +247,3 @@ SPDX-License-Identifier: curl
 ## MQTT
 
  - Subscribe to and publish topics using URL scheme `mqtt://broker/topic`
-
-## Footnotes
-
-  1. requires a TLS library
-  2. requires OpenLDAP or WinLDAP
-  3. requires a GSS-API implementation (such as Heimdal or MIT Kerberos) or
-     SSPI (native Windows)
-  4. requires a GSS-API implementation, however, only Windows SSPI is
-     currently supported
-  5. requires nghttp2
-  6. requires c-ares
-  7. requires libssh2, libssh or wolfSSH
-  8. requires libssh2 or libssh
-  9. requires OpenSSL, GnuTLS, mbedTLS, Secure Transport or SSPI
-     (native Windows)
-  10. requires libidn2 or Windows
-  11. requires libz, brotli and/or zstd
-  12. requires a GSS-API implementation (such as Heimdal or MIT Kerberos)
diff --git a/docs/HISTORY.md b/docs/HISTORY.md
index bcc472cd9..96cf049dc 100644
--- a/docs/HISTORY.md
+++ b/docs/HISTORY.md
@@ -286,7 +286,7 @@ August:
 
 February: added support for the axTLS backend
 
-April: added the cyassl backend (later renamed to WolfSSL)
+April: added the cyassl backend (later renamed to wolfSSL)
 
 2012
 ----
diff --git a/docs/HTTP2.md b/docs/HTTP2.md
index aed06f548..55d3db588 100644
--- a/docs/HTTP2.md
+++ b/docs/HTTP2.md
@@ -13,7 +13,7 @@ HTTP/2 with curl
 Build prerequisites
 -------------------
   - nghttp2
-  - OpenSSL, libressl, BoringSSL, GnuTLS, mbedTLS, wolfSSL or Schannel
+  - OpenSSL, LibreSSL, BoringSSL, GnuTLS, mbedTLS, wolfSSL or Schannel
     with a new enough version.
 
 [nghttp2](https://nghttp2.org/)
diff --git a/docs/HTTP3.md b/docs/HTTP3.md
index 1a528a8c1..c1c6bf249 100644
--- a/docs/HTTP3.md
+++ b/docs/HTTP3.md
@@ -182,13 +182,14 @@ quiche support is **EXPERIMENTAL**
 
 Since the quiche build manages its dependencies, curl can be built against the latest version. You are *probably* able to build against their main branch, but in case of problems, we recommend their latest release tag.
 
-## build
+## Build
 
 Build quiche and BoringSSL:
 
-     % git clone --recursive -b 0.20.0 https://github.com/cloudflare/quiche
+     % git clone --recursive -b 0.22.0 https://github.com/cloudflare/quiche
      % cd quiche
      % cargo build --package quiche --release --features ffi,pkg-config-meta,qlog
+     % ln -s libquiche.so target/release/libquiche.so.0
      % mkdir quiche/deps/boringssl/src/lib
      % ln -vnf $(find target/release -name libcrypto.a -o -name libssl.a) quiche/deps/boringssl/src/lib/
 
@@ -209,12 +210,12 @@ Build curl:
 
 QUIC support is **EXPERIMENTAL**
 
-Build OpenSSL 3.2.0
+Build OpenSSL 3.3.1
 
      % cd ..
-     % git clone -b openssl-3.2.0 https://github.com/openssl/openssl
+     % git clone -b openssl-3.3.1 https://github.com/openssl/openssl
      % cd openssl
-     % ./config enable-tls1_3 --prefix=<somewhere> --libdir=<somewhere>/lib
+     % ./config enable-tls1_3 --prefix=<somewhere> --libdir=lib
      % make
      % make install
 
@@ -235,7 +236,7 @@ Build curl:
      % git clone https://github.com/curl/curl
      % cd curl
      % autoreconf -fi
-     % LDFLAGS="-Wl,-rpath,<somewhere>/lib" ./configure --with-openssl=<somewhere> --with-openssl-quic --with-nghttp3=<somewhere2> 
+     % LDFLAGS="-Wl,-rpath,<somewhere>/lib" ./configure --with-openssl=<somewhere> --with-openssl-quic --with-nghttp3=<somewhere2>
      % make
      % make install
 
diff --git a/docs/HYPER.md b/docs/HYPER.md
index 84b37593d..591b6fc30 100644
--- a/docs/HYPER.md
+++ b/docs/HYPER.md
@@ -21,7 +21,7 @@ in the master branch using pull-requests, just like ordinary changes.
 
 The C API for Hyper is brand new and is still under development.
 
-## build curl with hyper
+## Build curl with hyper
 
 Using Rust 1.64.0 or later, build hyper and enable its C API like this:
 
@@ -39,7 +39,7 @@ Build curl to use hyper's C API:
      % ./configure LDFLAGS="-Wl,-rpath,<hyper-dir>/target/debug -Wl,-rpath,<hyper-dir>/target/release" --with-openssl --with-hyper=<hyper-dir>
      % make
 
-# using Hyper internally
+# Using Hyper internally
 
 Hyper is a low level HTTP transport library. curl itself provides all HTTP
 headers and Hyper provides all received headers back to curl.
diff --git a/docs/INSTALL-CMAKE.md b/docs/INSTALL-CMAKE.md
index 37231f9e4..0457efe2d 100644
--- a/docs/INSTALL-CMAKE.md
+++ b/docs/INSTALL-CMAKE.md
@@ -22,7 +22,7 @@ Missing features in the CMake build:
 
  - Builds libcurl without large file support
  - Does not support all SSL libraries (only OpenSSL, Schannel, Secure
-   Transport, and mbedTLS, WolfSSL)
+   Transport, and mbedTLS, wolfSSL)
  - Does not allow different resolver backends (no c-ares build support)
  - No RTMP support built
  - Does not allow build curl and libcurl debug enabled
diff --git a/docs/INSTALL.md b/docs/INSTALL.md
index eae54d521..d00f22dcb 100644
--- a/docs/INSTALL.md
+++ b/docs/INSTALL.md
@@ -4,7 +4,7 @@ Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
 -->
 
-# how to install curl and libcurl
+# How to install curl and libcurl
 
 ## Installing Binary Packages
 
@@ -140,7 +140,7 @@ These options are provided to select the TLS backend to use.
  - BearSSL: `--with-bearssl`
  - GnuTLS: `--with-gnutls`.
  - mbedTLS: `--with-mbedtls`
- - OpenSSL: `--with-openssl` (also for BoringSSL, AWS-LC, libressl, and quictls)
+ - OpenSSL: `--with-openssl` (also for BoringSSL, AWS-LC, LibreSSL, and quictls)
  - rustls: `--with-rustls`
  - Schannel: `--with-schannel`
  - Secure Transport: `--with-secure-transport`
@@ -154,7 +154,7 @@ conflicting identical symbol names.
 When you build with multiple TLS backends, you can select the active one at
 runtime when curl starts up.
 
-## configure finding libs in wrong directory
+## Configure finding libs in wrong directory
 
 When the configure script checks for third-party libraries, it adds those
 directories to the `LDFLAGS` variable and then tries linking to see if it
diff --git a/docs/INTERNALS.md b/docs/INTERNALS.md
index 827fcfd36..ff77bac77 100644
--- a/docs/INTERNALS.md
+++ b/docs/INTERNALS.md
@@ -47,7 +47,7 @@ versions of libs and build tools.
  - GNU Autoconf 2.59
  - GNU Automake 1.7
  - GNU M4       1.4
- - perl         5.6
+ - perl         5.8
  - roffit       0.5
  - cmake        3.7
 
diff --git a/docs/KNOWN_BUGS b/docs/KNOWN_BUGS
index cc1709def..be44d16c6 100644
--- a/docs/KNOWN_BUGS
+++ b/docs/KNOWN_BUGS
@@ -18,7 +18,7 @@ problems may have been fixed or changed somewhat since this was written.
  2. TLS
  2.1 IMAPS connection fails with rustls error
  2.3 Unable to use PKCS12 certificate with Secure Transport
- 2.4 Secure Transport will not import PKCS#12 client certificates without a password
+ 2.4 Secure Transport does not import PKCS#12 client certificates without a password
  2.5 Client cert handling with Issuer DN differs between backends
  2.7 Client cert (MTLS) issues with Schannel
  2.11 Schannel TLS 1.2 handshake bug in old Windows versions
@@ -33,6 +33,8 @@ problems may have been fixed or changed somewhat since this was written.
  3.6 POP3 issue when reading small chunks
 
  4. Command line
+ 4.1 -T /dev/stdin may upload with an incorrect content length
+ 4.2 -T - always uploads chunked
 
  5. Build and portability issues
  5.1 OS400 port requires deprecated IBM library
@@ -40,7 +42,6 @@ problems may have been fixed or changed somewhat since this was written.
  5.3 building for old macOS fails with gcc
  5.5 cannot handle Unicode arguments in non-Unicode builds on Windows
  5.6 cygwin: make install installs curl-config.1 twice
- 5.9 Utilize Requires.private directives in libcurl.pc
  5.11 configure --with-gssapi with Heimdal is ignored on macOS
  5.12 flaky CI builds
  5.13 long paths are not fully supported on Windows
@@ -61,12 +62,10 @@ problems may have been fixed or changed somewhat since this was written.
  6.13 Negotiate against Hadoop HDFS
 
  7. FTP
- 7.1 FTP upload fails if remembered dir is deleted
+ 7.1 FTP upload fails if remembered directory is deleted
  7.2 Implicit FTPS upload timeout
  7.3 FTP with NOBODY and FAILONERROR
  7.4 FTP with ACCT
- 7.5 FTPS upload, FileZilla, GnuTLS and close_notify
- 7.11 FTPS upload data loss with TLS 1.3
  7.12 FTPS directory listing hangs on Windows with Schannel
 
  9. SFTP and SCP
@@ -82,8 +81,10 @@ problems may have been fixed or changed somewhat since this was written.
  11. Internals
  11.1 gssapi library name + version is missing in curl_version_info()
  11.2 error buffer not set if connection to multiple addresses fails
+ 11.3 TFTP tests fail on OpenBSD
  11.4 HTTP test server 'connection-monitor' problems
  11.5 Connection information when using TCP Fast Open
+ 11.6 test cases sometimes timeout
 
  12. LDAP
  12.1 OpenLDAP hangs after returning results
@@ -105,15 +106,19 @@ problems may have been fixed or changed somewhat since this was written.
 
  16. aws-sigv4
  16.1 aws-sigv4 does not sign requests with * correctly
+ 16.2 aws-sigv4 does not handle multipart/form-data correctly
+ 16.3 aws-sigv4 has problems with particular URLs
  16.6 aws-sigv4 does not behave well with AWS VPC Lattice
 
  17. HTTP/2
  17.1 HTTP/2 prior knowledge over proxy
  17.2 HTTP/2 frames while in the connection pool kill reuse
  17.3 ENHANCE_YOUR_CALM causes infinite retries
+ 17.4 HTTP/2 + TLS spends a lot of time in recv
 
  18. HTTP/3
  18.1 connection migration does not work
+ 18.2 quiche: QUIC connection is draining
 
  19. RTSP
  19.1 Some methods do not support response bodies
@@ -145,7 +150,7 @@ problems may have been fixed or changed somewhat since this was written.
 
  See https://github.com/curl/curl/issues/5403
 
-2.4 Secure Transport will not import PKCS#12 client certificates without a password
+2.4 Secure Transport does not import PKCS#12 client certificates without a password
 
  libcurl calls SecPKCS12Import with the PKCS#12 client certificate, but that
  function rejects certificates that do not have a password.
@@ -214,6 +219,25 @@ problems may have been fixed or changed somewhat since this was written.
 
 4. Command line
 
+4.1 -T /dev/stdin may upload with an incorrect content length
+
+ -T stats the path to figure out its size in bytes to use it as Content-Length
+ if it is a regular file.
+
+ The problem with that is that, on BSDs and some other UNIXes (not Linux),
+ open(path) may not give you a file descriptor with a 0 offset from the start
+ of the file.
+
+ See https://github.com/curl/curl/issues/12177
+
+4.2 -T - always uploads chunked
+
+ When the `<` shell operator is used. curl should realise that stdin is a
+ regular file in this case, and that it can do a non-chunked upload, like it
+ would do if you used -T file.
+
+ See https://github.com/curl/curl/issues/12171
+
 5. Build and portability issues
 
 5.1 OS400 port requires deprecated IBM library
@@ -226,9 +250,9 @@ problems may have been fixed or changed somewhat since this was written.
 
 5.2 curl-config --libs contains private details
 
- "curl-config --libs" will include details set in LDFLAGS when configure is
- run that might be needed only for building libcurl. Further, curl-config
- --cflags suffers from the same effects with CFLAGS/CPPFLAGS.
+ "curl-config --libs" include details set in LDFLAGS when configure is run
+ that might be needed only for building libcurl. Further, curl-config --cflags
+ suffers from the same effects with CFLAGS/CPPFLAGS.
 
 5.3 building for old macOS fails with gcc
 
@@ -243,8 +267,8 @@ problems may have been fixed or changed somewhat since this was written.
  it can only be encoded properly in the Unicode character set. Windows uses
  UTF-16 encoding for Unicode and stores it in wide characters, however curl
  and libcurl are not equipped for that at the moment except when built with
- _UNICODE and UNICODE defined. And, except for Cygwin, Windows cannot use UTF-8
- as a locale.
+ _UNICODE and UNICODE defined. Except for Cygwin, Windows cannot use UTF-8 as
+ a locale.
 
   https://curl.se/bug/?i=345
   https://curl.se/bug/?i=731
@@ -254,10 +278,6 @@ problems may have been fixed or changed somewhat since this was written.
 
  https://github.com/curl/curl/issues/8839
 
-5.9 Utilize Requires.private directives in libcurl.pc
-
- https://github.com/curl/curl/issues/864
-
 5.11 configure --with-gssapi with Heimdal is ignored on macOS
 
  ... unless you also pass --with-gssapi-libs
@@ -307,7 +327,7 @@ problems may have been fixed or changed somewhat since this was written.
 
 6.1 NTLM authentication and unicode
 
- NTLM authentication involving unicode user name or password only works
+ NTLM authentication involving unicode username or password only works
  properly if built with UNICODE defined together with the Schannel
  backend. The original problem was mentioned in:
  https://curl.se/mail/lib-2009-10/0024.html
@@ -325,8 +345,8 @@ problems may have been fixed or changed somewhat since this was written.
 6.3 NTLM in system context uses wrong name
 
  NTLM authentication using SSPI (on Windows) when (lib)curl is running in
- "system context" will make it use wrong(?) user name - at least when compared
- to what winhttp does. See https://curl.se/bug/view.cgi?id=535
+ "system context" makes it use wrong(?) username - at least when compared to
+ what winhttp does. See https://curl.se/bug/view.cgi?id=535
 
 6.5 NTLM does not support password with Â§ character
 
@@ -335,11 +355,11 @@ problems may have been fixed or changed somewhat since this was written.
 6.6 libcurl can fail to try alternatives with --proxy-any
 
  When connecting via a proxy using --proxy-any, a failure to establish an
- authentication will cause libcurl to abort trying other options if the
- failed method has a higher preference than the alternatives. As an example,
+ authentication causes libcurl to abort trying other options if the failed
+ method has a higher preference than the alternatives. As an example,
  --proxy-any against a proxy which advertise Negotiate and NTLM, but which
- fails to set up Kerberos authentication will not proceed to try authentication
- using NTLM.
+ fails to set up Kerberos authentication does not proceed to try
+ authentication using NTLM.
 
  https://github.com/curl/curl/issues/876
 
@@ -382,7 +402,7 @@ problems may have been fixed or changed somewhat since this was written.
 
 7. FTP
 
-7.1 FTP upload fails if remembered dir is deleted
+7.1 FTP upload fails if remembered directory is deleted
 
  curl's FTP code assumes that the directory it entered in a previous transfer
  still exists when it comes back to do a second transfer, and does not respond
@@ -403,41 +423,16 @@ problems may have been fixed or changed somewhat since this was written.
 7.4 FTP with ACCT
 
  When doing an operation over FTP that requires the ACCT command (but not when
- logging in), the operation will fail since libcurl does not detect this and
- thus fails to issue the correct command:
- https://curl.se/bug/view.cgi?id=635
-
-7.5 FTPS upload, FileZilla, GnuTLS and close_notify
-
- An issue where curl does not send the TLS alert close_notify, which triggers
- the wrath of GnuTLS in FileZilla server, and a FTP reply 426 ECONNABORTED.
-
- https://github.com/curl/curl/issues/11383
-
-7.11 FTPS upload data loss with TLS 1.3
-
- During FTPS upload curl does not attempt to read TLS handshake messages sent
- after the initial handshake. OpenSSL servers running TLS 1.3 may send such a
- message. When curl closes the upload connection if unread data has been
- received (such as a TLS handshake message) then the TCP protocol sends an
- RST to the server, which may cause the server to discard or truncate the
- upload if it has not read all sent data yet, and then return an error to curl
- on the control channel connection.
-
- Since 7.78.0 this is mostly fixed. curl will do a single read before closing
- TLS connections (which causes the TLS library to read handshake messages),
- however there is still possibility of an RST if more messages need to be read
- or a message arrives after the read but before close (network race condition).
-
- https://github.com/curl/curl/issues/6149
+ logging in), the operation fails since libcurl does not detect this and thus
+ fails to issue the correct command: https://curl.se/bug/view.cgi?id=635
 
 7.12 FTPS server compatibility on Windows with Schannel
 
- FTPS is not widely used with the Schannel TLS backend and so there may be more
- bugs compared to other TLS backends such as OpenSSL. In the past users have
- reported hanging and failed connections. It's very likely some changes to curl
- since then fixed the issues. None of the reported issues can be reproduced any
- longer.
+ FTPS is not widely used with the Schannel TLS backend and so there may be
+ more bugs compared to other TLS backends such as OpenSSL. In the past users
+ have reported hanging and failed connections. It is likely some changes to
+ curl since then fixed the issues. None of the reported issues can be
+ reproduced any longer.
 
  If you encounter an issue connecting to your server via FTPS with the latest
  curl and Schannel then please search for open issues or file a new issue.
@@ -472,7 +467,7 @@ problems may have been fixed or changed somewhat since this was written.
 
  In the SSH_SFTP_INIT state for libssh, the ssh session working mode is set to
  blocking mode. If the network is suddenly disconnected during sftp
- transmission, curl will be stuck, even if curl is configured with a timeout.
+ transmission, curl is stuck, even if curl is configured with a timeout.
 
  https://github.com/curl/curl/issues/8632
 
@@ -500,10 +495,17 @@ problems may have been fixed or changed somewhat since this was written.
 11.2 error buffer not set if connection to multiple addresses fails
 
  If you ask libcurl to resolve a hostname like example.com to IPv6 addresses
- only. But you only have IPv4 connectivity. libcurl will correctly fail with
- CURLE_COULDNT_CONNECT. But the error buffer set by CURLOPT_ERRORBUFFER
+ when you only have IPv4 connectivity. libcurl fails with
+ CURLE_COULDNT_CONNECT, but the error buffer set by CURLOPT_ERRORBUFFER
  remains empty. Issue: https://github.com/curl/curl/issues/544
 
+11.3 TFTP tests fail on OpenBSD
+
+ When adding an OpenBSD job with tests to GHA, some tests consistently fail
+ to run.
+
+ See https://github.com/curl/curl/issues/13623
+
 11.4 HTTP test server 'connection-monitor' problems
 
  The 'connection-monitor' feature of the sws HTTP test server does not work
@@ -519,6 +521,12 @@ problems may have been fixed or changed somewhat since this was written.
  See https://github.com/curl/curl/issues/1332 and
  https://github.com/curl/curl/issues/4296
 
+11.6 test cases sometimes timeout
+
+ Occasionally, one of the tests timeouts. Inexplicably.
+
+ See https://github.com/curl/curl/issues/13350
+
 12. LDAP
 
 12.1 OpenLDAP hangs after returning results
@@ -560,8 +568,8 @@ problems may have been fixed or changed somewhat since this was written.
 13.2 Trying local ports fails on Windows
 
  This makes '--local-port [range]' to not work since curl cannot properly
- detect if a port is already in use, so it will try the first port, use that and
- then subsequently fail anyway if that was actually in use.
+ detect if a port is already in use, so it tries the first port, uses that and
+ then subsequently fails anyway if that was actually in use.
 
  https://github.com/curl/curl/issues/8112
 
@@ -614,6 +622,14 @@ problems may have been fixed or changed somewhat since this was written.
 
  https://github.com/curl/curl/issues/7559
 
+16.2 aws-sigv4 does not handle multipart/form-data correctly
+
+ https://github.com/curl/curl/issues/13351
+
+16.3 aws-sigv4 has problems with particular URLs
+
+ https://github.com/curl/curl/issues/13058
+
 16.6 aws-sigv4 does not behave well with AWS VPC Lattice
 
  https://github.com/curl/curl/issues/11007
@@ -627,9 +643,9 @@ problems may have been fixed or changed somewhat since this was written.
 17.2 HTTP/2 frames while in the connection pool kill reuse
 
  If the server sends HTTP/2 frames (like for example an HTTP/2 PING frame) to
- curl while the connection is held in curl's connection pool, the socket will
- be found readable when considered for reuse and that makes curl think it is
- dead and then it will be closed and a new connection gets created instead.
+ curl while the connection is held in curl's connection pool, the socket is
+ found readable when considered for reuse and that makes curl think it is dead
+ and then it is closed and a new connection gets created instead.
 
  This is *best* fixed by adding monitoring to connections while they are kept
  in the pool so that pings can be responded to appropriately.
@@ -641,18 +657,34 @@ problems may have been fixed or changed somewhat since this was written.
 
  See https://github.com/curl/curl/issues/5119
 
+17.4 HTTP/2 + TLS spends a lot of time in recv
+
+ It has been observered that by making the speed limit less accurate we could
+ improve this performance. (by reverting
+ https://github.com/curl/curl/commit/db5c9f4f9e0779b49624752b135281a0717b277b)
+ Can we find a golden middle ground?
+
+ See https://curl.se/mail/lib-2024-05/0026.html and
+ https://github.com/curl/curl/issues/13416
+
 18. HTTP/3
 
 18.1 connection migration does not work
 
  https://github.com/curl/curl/issues/7695
 
+18.2 quiche: QUIC connection is draining
+
+ The transfer ends with error "QUIC connection is draining".
+
+ https://github.com/curl/curl/issues/12037
+
 19. RTSP
 
 19.1 Some methods do not support response bodies
 
  The RTSP implementation is written to assume that a number of RTSP methods
- will always get responses without bodies, even though there seems to be no
+ always get responses without bodies, even though there seems to be no
  indication in the RFC that this is always the case.
 
  https://github.com/curl/curl/issues/12414
diff --git a/docs/MANUAL.md b/docs/MANUAL.md
index 03de0eb39..33596663c 100644
--- a/docs/MANUAL.md
+++ b/docs/MANUAL.md
@@ -309,7 +309,8 @@ Post a simple `name` and `phone` guestbook.
 
 Or automatically [URL encode the data](https://everything.curl.dev/http/post/url-encode).
 
-    curl --data-urlencode "name=Rafael Sagula&phone=3320780" http://www.example.com/guest.cgi
+    curl --data-urlencode "name=Rafael Sagula&phone=3320780"
+      http://www.example.com/guest.cgi
 
 How to post a form with curl, lesson #1:
 
@@ -343,7 +344,8 @@ We want to enter user `foobar` with password `12345`.
 
 To post to this, you would enter a curl command line like:
 
-    curl -d "user=foobar&pass=12345&id=blablabla&ding=submit" http://example.com/post.cgi
+    curl -d "user=foobar&pass=12345&id=blablabla&ding=submit"
+      http://example.com/post.cgi
 
 While `-d` uses the application/x-www-form-urlencoded mime-type, generally
 understood by CGI's and similar, curl also supports the more capable
diff --git a/docs/Makefile.am b/docs/Makefile.am
index 83f5b0c46..e9ef62848 100644
--- a/docs/Makefile.am
+++ b/docs/Makefile.am
@@ -28,6 +28,7 @@ if BUILD_DOCS
 # if we disable man page building, ignore these
 MK_CA_DOCS = mk-ca-bundle.1
 CURLCONF_DOCS = curl-config.1
+man_MANS = curl-config.1
 endif
 
 CURLPAGES = curl-config.md mk-ca-bundle.md
diff --git a/docs/RELEASE-PROCEDURE.md b/docs/RELEASE-PROCEDURE.md
index 03db8ae2f..043e3afd0 100644
--- a/docs/RELEASE-PROCEDURE.md
+++ b/docs/RELEASE-PROCEDURE.md
@@ -10,9 +10,6 @@ curl release procedure - how to do a release
 in the source code repo
 -----------------------
 
-- do a *regular build* with a sensible build config to make sure the
-  `src/tool_hugehelp.c` file etc is correctly generated
-
 - edit `RELEASE-NOTES` to be accurate
 
 - update `docs/THANKS`
@@ -111,11 +108,11 @@ Coming dates
 Based on the description above, here are some planned release dates (at the
 time of this writing):
 
-- May 22, 2024
-- July 17, 2024
 - September 11, 2024
 - November 6, 2024
 - January 8, 2025
 - March 5, 2025
 - April 30, 2025
 - June 25, 2025
+- August 20, 2025
+- October 15, 2025
diff --git a/docs/ROADMAP.md b/docs/ROADMAP.md
index 03cc4c707..abf306b33 100644
--- a/docs/ROADMAP.md
+++ b/docs/ROADMAP.md
@@ -14,4 +14,4 @@ participation.
 
 Agree that it is a good enough API and remove the EXPERIMENTAL label.
 
-## 
+##
diff --git a/docs/SSLCERTS.md b/docs/SSLCERTS.md
index 5edd5c477..ba349ed63 100644
--- a/docs/SSLCERTS.md
+++ b/docs/SSLCERTS.md
@@ -117,8 +117,8 @@ server, do one of the following:
     order:
       1. application's directory
       2. current working directory
-      3. Windows System directory (e.g. C:\windows\system32)
-      4. Windows Directory (e.g. C:\windows)
+      3. Windows System directory (e.g. C:\Windows\System32)
+      4. Windows Directory (e.g. C:\Windows)
       5. all directories along %PATH%
 
  5. Get another CA cert bundle. One option is to extract the one a recent
diff --git a/docs/THANKS b/docs/THANKS
index c8edc8bb0..03bd1b7ac 100644
--- a/docs/THANKS
+++ b/docs/THANKS
@@ -51,6 +51,7 @@ Ajit Dhumale
 Akhil Kedia
 Akhilesh Nema
 Aki Koskinen
+Aki Sakurai
 Akos Pasztory
 Akshay Vernekar
 Alain Danteny
@@ -68,6 +69,7 @@ Aleksandar Milivojevic
 Aleksander Mazur
 Aleksandr Krotov
 Aleksey Tulinov
+alervd on github
 Ales Mlakar
 Ales Novak
 Alessandro Ghedini
@@ -93,6 +95,7 @@ Alex Nichols
 Alex Potapenko
 Alex Rousskov
 Alex Samorukov
+Alex Snast
 Alex Suykov
 Alex Vinnik
 Alex Xu
@@ -109,6 +112,7 @@ Alexander Krasnostavsky
 Alexander Lazic
 Alexander Pepper
 Alexander Peslyak
+Alexander Shtuchkin
 Alexander Sinditskiy
 Alexander Traud
 Alexander V. Tikhonov
@@ -209,6 +213,8 @@ AndrÃ©s GarcÃ­a
 Andy Alt
 Andy Cedilnik
 Andy Fiddaman
+Andy Pan
+Andy Reitz
 Andy Serpa
 Andy Stamp
 Andy Tsouladze
@@ -270,6 +276,7 @@ AtariDreams on github
 Ates Goral
 atjg on github
 Augustus Saunders
+AurÃ©lien Pierre
 Austin Green
 av223119 on github
 Avery Fay
@@ -340,6 +347,7 @@ Bertrand Demiddelaer
 Bertrand Simonnet
 beslick5 on github
 Bevan Weiss
+Bhanu Prakash
 Bill Doyle
 Bill Egert
 Bill Hoffman
@@ -404,6 +412,7 @@ Brian Green
 Brian Inglis
 Brian J. Murrell
 Brian Lund
+brian m. carlson
 Brian Nixon
 Brian Prodoehl
 Brian R Duffy
@@ -497,6 +506,7 @@ Christian Fillion
 Christian Grothoff
 Christian Heimes
 Christian Hesse
+Christian Heusel
 Christian HÃ¤gele
 Christian Krause
 Christian Kurz
@@ -534,6 +544,7 @@ Clifford Wolf
 Clint Clayton
 Cloudogu Siebels
 ClÃ©ment Notin
+CMD
 cmfrolick on github
 codesniffer13 on github
 Cody Jones
@@ -714,6 +725,7 @@ Denis Laxalde
 Denis Ollier
 Dennis Clarke
 Dennis Felsing
+dependabot[bot]
 Derek Higgins
 Derzsi DÃ¡niel
 Desmond O. Chang
@@ -768,16 +780,19 @@ Dmitry S. Baikov
 Dmitry Tretyakov
 Dmitry Wagin
 dnivras on github
+dogma
 Dolbneff A.V
 Domen KoÅ¾ar
 Domenico Andreoli
 Dominick Meglio
 Dominik HÃ¶lzl
 Dominik Klemba
+Dominik PiÄ…tkowski
 Dominik Thalhammer
 Dominique Leuenberger
 Don J Olmstead
 Dongliang Mu
+Dorian Craps
 Doron Behar
 Doug Kaufman
 Doug Porter
@@ -838,6 +853,7 @@ Eli Schwartz
 Elia Tufarolo
 Elliot Killick
 Elliot Saba
+Elliott Balsley
 Ellis Pritchard
 Elmira A Semenova
 Elms
@@ -907,6 +923,7 @@ Evert Pot
 Evgeny Grin (Karlson2k)
 Evgeny Turnaev
 eXeC64 on github
+extrimexxx on github
 Eygene Ryabinkin
 Eylem Ugurel
 Fabian Fischer
@@ -1047,6 +1064,7 @@ Godwin Stewart
 GonÃ§alo Carvalho
 Google Inc.
 Gordon Marler
+Gordon Parke
 Gorilla Maguila
 Goro FUJI
 Gou Lingfeng
@@ -1071,6 +1089,7 @@ Grigory Entin
 Grisha Levit
 Guenole Bescon
 Guido Berhoerster
+Guilherme Puida
 Guillaume Algis
 Guillaume Arluison
 guitared on github
@@ -1210,6 +1229,7 @@ Ishan SinghLevett
 Ithubg on github
 Ivan
 Ivan Avdeev
+Ivan Kuchin
 Ivan Tsybulin
 ivanfywang
 IvanoG on github
@@ -1236,6 +1256,7 @@ Jakub Bochenski
 Jakub Jelen
 Jakub Wilk
 Jakub Zakrzewski
+James Abbatiello
 James Atwill
 James Brown
 James Bursa
@@ -1293,6 +1314,7 @@ Javier Navarro
 Javier Sixto
 Jay Austin
 Jay Dommaschk
+Jay Guerette
 Jay Wu
 Jayesh A Shah
 Jaz Fresh
@@ -1354,6 +1376,7 @@ Jesse Noller
 Jesse Tan
 jethrogb on github
 jhoyla on github
+Jiang Wenjian
 Jiawen Geng
 Jie He
 Jiehong on github
@@ -1460,6 +1483,7 @@ Jonatan Lander
 Jonatan Vela
 Jonathan Cardoso Machado
 Jonathan Hseu
+Jonathan Matthews
 Jonathan Moerman
 Jonathan Nieder
 Jonathan Perkin
@@ -1557,6 +1581,7 @@ Kari Pahula
 Karl Chen
 Karl Moerder
 Karol Pietrzak
+kartatz
 Kartatz on Github
 Karthikdasari0423
 Karthikdasari0423 on github
@@ -1566,6 +1591,7 @@ Katie Wang
 Katsuhiko YOSHIDA
 Kazuho Oku
 kchow-FTNT on github
+Keerthi Timmaraju
 Kees Cook
 Kees Dekker
 Keitagit-kun on github
@@ -1675,6 +1701,7 @@ Lawrence Wagerfield
 Leah Neukirchen
 Lealem Amedie
 Leandro Coutinho
+Lee Li
 LeeRiva
 Legoff Vincent
 Lehel Bernadt
@@ -1748,6 +1775,7 @@ Luke Amery
 Luke Call
 Luke Dashjr
 Luke Granger-Brown
+Luke Hamburg
 LukÃ¡Å¡ Zaoral
 luminixinc on github
 Luo Jinghua
@@ -1865,6 +1893,7 @@ Martin Jansen
 Martin Kammerhofer
 Martin Kepplinger
 Martin Lemke
+Martin Peck
 Martin Schmatz
 Martin Skinner
 Martin Staael
@@ -1874,6 +1903,7 @@ Martin V
 Martin VejnÃ¡r
 Martin Waleczek
 Martin Ã…gren
+martinevsky
 Marty Kuhrt
 Maruko
 Masaya Suzuki
@@ -1915,6 +1945,7 @@ Matthew Whitehead
 Matthias Bolte
 Matthias Gatto
 Matthias Naegler
+Matthieu Baerts
 Mattias Fornander
 Matus Uzak
 Maurice Barnum
@@ -2051,6 +2082,7 @@ momala454 on github
 Momoka Yamamoto
 MonkeybreadSoftware on github
 moohoorama on github
+Morgan Willcock
 Morten Minde Neergaard
 Mostyn Bramley-Moore
 Moti Avrahami
@@ -2175,6 +2207,7 @@ Oliver Schindler
 Oliver Urbann
 oliverpool on github
 Olivier Berger
+Olivier Bonaventure
 Olivier Brunel
 Omar Ramadan
 omau on github
@@ -2429,6 +2462,7 @@ Renaud Lehoux
 Rene Bernhardt
 Rene Rebe
 renovate[bot]
+renovate[bot]
 Reuven Wachtfogel
 RevaliQaQ on github
 Reza Arbab
@@ -2615,6 +2649,7 @@ Sascha Zengler
 Satadru Pramanik
 Satana de Sant'Ana
 Saul good
+saurabhsingh-dev on github
 Saurav Babu
 sayrer on github
 SBKarr on github
@@ -2634,6 +2669,7 @@ Sean McArthur
 Sean Miller
 Sean Molenaar
 Sebastiaan van Erk
+Sebastian Andersson
 Sebastian Haglund
 Sebastian Mundry
 Sebastian Neubauer
@@ -2663,6 +2699,7 @@ Sergio Mijatovic
 Sergio-IME on github
 sergio-nsk on github
 Serj Kalichev
+Sertonix
 SerusDev on github
 Seshubabu Pasam
 Seth Mos
@@ -2946,6 +2983,7 @@ Tommy Chiang
 Tommy Odom
 Tommy Petty
 Tommy Tam
+tomy2105 on github
 Ton Voon
 Toni Moreno
 Tony Kelman
@@ -3040,6 +3078,7 @@ Volker Schmid
 Vsevolod Novikov
 vshmuk on hackerone
 vulnerabilityspotter on hackerone
+vuonganh1993 on github
 vvb2060
 vvb2060 on github
 Vyron Tsingaras
@@ -3134,8 +3173,7 @@ Yusuke Nakamura
 Yves Arrouye
 Yves Lejeune
 YX Hao
-z2-2z on github
-z2_ on hackerone
+z2_
 Zachary Seguin
 Zdenek Pavlas
 Zekun Ni
@@ -3173,5 +3211,7 @@ zzq1015 on github
 åŠ è—¤éƒä¹‹
 å—å®«é›ªçŠ
 å·¦æ½‡å³°
+æŽå››
 æ¢¦ç»ˆæ— ç—•
 ç©ä¸¹å°¼ Dan Jacobson
+ç½—æœè¾‰
diff --git a/docs/THANKS-filter b/docs/THANKS-filter
index 8fd92aa8c..ede27dc68 100644
--- a/docs/THANKS-filter
+++ b/docs/THANKS-filter
@@ -140,3 +140,5 @@ s/Randall$/Randall S. Becker/
 s/talregev on github/Tal Regev/
 s/daniel-j-h/Daniel J. H./
 s/hongfei.li/Hongfei Li/
+s/z2_ on hackerone/z2_/
+s/z2-2z on github/z2_/
diff --git a/docs/TODO b/docs/TODO
index e5bf09243..914b9a312 100644
--- a/docs/TODO
+++ b/docs/TODO
@@ -20,14 +20,16 @@
  1.1 TFO support on Windows
  1.2 Consult %APPDATA% also for .netrc
  1.3 struct lifreq
- 1.4 Better and more sharing
+ 1.4 alt-svc sharing
  1.5 get rid of PATH_MAX
+ 1.6 thread-safe sharing
  1.8 CURLOPT_RESOLVE for any port number
  1.9 Cache negative name resolves
  1.10 auto-detect proxy
  1.11 minimize dependencies with dynamically loaded modules
  1.12 updated DNS server while running
  1.13 c-ares and CURLOPT_OPENSOCKETFUNCTION
+ 1.14 connect to multiple IPs in parallel
  1.15 Monitor connections in the connection pool
  1.16 Try to URL encode given URL
  1.17 Add support for IRIs
@@ -62,8 +64,7 @@
  4. FTP
  4.1 HOST
  4.2 Alter passive/active on failure and retry
- 4.3 Earlier bad letter detection
- 4.4 Support CURLOPT_PREQUOTE for dir listings too
+ 4.4 Support CURLOPT_PREQUOTE for directories listings
  4.5 ASCII support
  4.6 GSSAPI via Windows SSPI
  4.7 STAT for LIST without data connection
@@ -108,13 +109,12 @@
  11.4 Create remote directories
 
  12. FILE
- 12.1 Directory listing for FILE:
+ 12.1 Directory listing on non-POSIX
 
  13. TLS
  13.1 TLS-PSK with OpenSSL
- 13.2 Provide mutex locking API
+ 13.2 TLS channel binding
  13.3 Defeat TLS fingerprinting
- 13.4 Cache/share OpenSSL contexts
  13.5 Export session ids
  13.6 Provide callback for cert verification
  13.7 Less memory massaging with Schannel
@@ -122,13 +122,11 @@
  13.9 TLS record padding
  13.10 Support Authority Information Access certificate extension (AIA)
  13.11 Some TLS options are not offered for HTTPS proxies
- 13.12 Reduce CA certificate bundle reparsing
  13.13 Make sure we forbid TLS 1.3 post-handshake authentication
  13.14 Support the clienthello extension
  13.15 Select signature algorithms
-
- 14. GnuTLS
- 14.2 check connection
+ 13.16 Share the CA cache
+ 13.17 Add missing features to TLS backends
 
  15. Schannel
  15.1 Extend support for client certificate authentication
@@ -150,28 +148,29 @@
  18. Command line tool
  18.1 sync
  18.2 glob posts
+ 18.3 -h option
  18.4 --proxycommand
  18.5 UTF-8 filenames in Content-Disposition
  18.6 Option to make -Z merge lined based outputs on stdout
- 18.8 Consider convenience options for JSON and XML?
+ 18.7 specify which response codes that make -f/--fail return error
  18.9 Choose the name of file in braces for complex URLs
  18.10 improve how curl works in a windows console window
  18.11 Windows: set attribute 'archive' for completed downloads
  18.12 keep running, read instructions from pipe/socket
- 18.13 Ratelimit or wait between serial requests
+ 18.13 Acknowledge Ratelimit headers
  18.14 --dry-run
  18.15 --retry should resume
  18.16 send only part of --data
- 18.17 consider file name from the redirected URL with -O ?
+ 18.17 consider filename from the redirected URL with -O ?
  18.18 retry on network is unreachable
  18.19 expand ~/ in config files
- 18.20 host name sections in config files
+ 18.20 hostname sections in config files
  18.21 retry on the redirected-to URL
  18.23 Set the modification date on an uploaded file
  18.24 Use multiple parallel transfers for a single download
  18.25 Prevent terminal injection when writing to terminal
  18.26 Custom progress meter update interval
- 18.27 -J and -O with %-encoded file names
+ 18.27 -J and -O with %-encoded filenames
  18.28 -J with -C -
  18.29 --retry and transfer timeouts
 
@@ -187,16 +186,15 @@
  20.2 nicer lacking perl message
  20.3 more protocols supported
  20.4 more platforms supported
- 20.5 Add support for concurrent connections
  20.6 Use the RFC 6265 test suite
- 20.7 Support LD_PRELOAD on macOS
  20.8 Run web-platform-tests URL tests
 
  21. MQTT
  21.1 Support rate-limiting
+ 21.2 Support MQTTS
 
  22. TFTP
- 22.1 TFTP doesn't convert LF to CRLF for mode=netascii
+ 22.1 TFTP does not convert LF to CRLF for mode=netascii
 
 ==============================================================================
 
@@ -225,7 +223,7 @@
  SIOCGIFADDR on newer Solaris versions as they claim the latter is obsolete.
  To support IPv6 interface addresses for network interfaces properly.
 
-1.4 Better and more sharing
+1.4 alt-svc sharing
 
  The share interface could benefit from allowing the alt-svc cache to be
  possible to share between easy handles.
@@ -250,11 +248,18 @@
  there we need libssh2 to properly tell us when we pass in a too small buffer
  and its current API (as of libssh2 1.2.7) does not.
 
+1.6 thread-safe sharing
+
+ Using the share interface users can share some data between easy handles but
+ several of the sharing options are documented as as not safe and supported to
+ share between multiple concurrent threads. Fixing this would enable more
+ users to share data in more powerful ways.
+
 1.8 CURLOPT_RESOLVE for any port number
 
  This option allows applications to set a replacement IP address for a given
  host + port pair. Consider making support for providing a replacement address
- for the host name on all port numbers.
+ for the hostname on all port numbers.
 
  See https://github.com/curl/curl/issues/1264
 
@@ -295,14 +300,26 @@
 
 1.13 c-ares and CURLOPT_OPENSOCKETFUNCTION
 
- curl will create most sockets via the CURLOPT_OPENSOCKETFUNCTION callback and
+ curl creates most sockets via the CURLOPT_OPENSOCKETFUNCTION callback and
  close them with the CURLOPT_CLOSESOCKETFUNCTION callback. However, c-ares
- does not use those functions and instead opens and closes the sockets
- itself. This means that when curl passes the c-ares socket to the
- CURLMOPT_SOCKETFUNCTION it is not owned by the application like other sockets.
+ does not use those functions and instead opens and closes the sockets itself.
+ This means that when curl passes the c-ares socket to the
+ CURLMOPT_SOCKETFUNCTION it is not owned by the application like other
+ sockets.
 
  See https://github.com/curl/curl/issues/2734
 
+1.14 connect to multiple IPs in parallel
+
+ curl currently implements the happy eyeball algorithm for connecting to the
+ IPv4 and IPv6 alternatives for a host in parallel, sticking with the
+ connection that "wins". We could implement a similar algorithm per individual
+ IP family as well when there are multiple available addresses: start with the
+ first address, then start a second attempt N milliseconds after and then a
+ third another N milliseconds later. That way there would be less waiting when
+ the first IP has problems. It also improves the connection timeout value
+ handling for multiple address situations.
+
 1.15 Monitor connections in the connection pool
 
  libcurl's connection cache or pool holds a number of open connections for the
@@ -485,8 +502,8 @@
 2.4 Split connect and authentication process
 
  The multi interface treats the authentication process as part of the connect
- phase. As such any failures during authentication will not trigger the relevant
- QUIT or LOGOFF for protocols such as IMAP, POP3 and SMTP.
+ phase. As such any failures during authentication does not trigger the
+ relevant QUIT or LOGOFF for protocols such as IMAP, POP3 and SMTP.
 
 2.5 Edge-triggered sockets should work
 
@@ -536,7 +553,7 @@
 
 4.1 HOST
 
- HOST is a command for a client to tell which host name to use, to offer FTP
+ HOST is a command for a client to tell which hostname to use, to offer FTP
  servers named-based virtual hosting:
 
  https://datatracker.ietf.org/doc/html/rfc7151
@@ -548,12 +565,7 @@
  connection. There could be a way to fallback to an active connection (and
  vice versa). https://curl.se/bug/feature.cgi?id=1754793
 
-4.3 Earlier bad letter detection
-
- Make the detection of (bad) %0d and %0a codes in FTP URL parts earlier in the
- process to avoid doing a resolve and connect in vain.
-
-4.4 Support CURLOPT_PREQUOTE for dir listings too
+4.4 Support CURLOPT_PREQUOTE for directions listings
 
  The lack of support is mostly an oversight and requires the FTP state machine
  to get updated to get fixed.
@@ -594,10 +606,10 @@
 
 5.1 Provide the error body from a CONNECT response
 
- When curl receives a body response from a CONNECT request to a proxy, it will
- always just read and ignore it. It would make some users happy if curl
- instead optionally would be able to make that responsible available. Via a new
- callback? Through some other means?
+ When curl receives a body response from a CONNECT request to a proxy, it
+ always just reads and ignores it. It would make some users happy if curl
+ instead optionally would be able to make that responsible available. Via a
+ new callback? Through some other means?
 
  See https://github.com/curl/curl/issues/9513
 
@@ -624,7 +636,7 @@
 5.4 Allow SAN names in HTTP/2 server push
 
  curl only allows HTTP/2 push promise if the provided :authority header value
- exactly matches the host name given in the URL. It could be extended to allow
+ exactly matches the hostname given in the URL. It could be extended to allow
  any name that would match the Subject Alternative Names in the server's TLS
  certificate.
 
@@ -669,7 +681,7 @@
 6.2 ditch telnet-specific select
 
  Move the telnet support's network select() loop go away and merge the code
- into the main transfer loop. Until this is done, the multi interface will not
+ into the main transfer loop. Until this is done, the multi interface does not
  work for telnet.
 
 6.3 feature negotiation debug data
@@ -775,11 +787,11 @@
 
 12. FILE
 
-12.1 Directory listing for FILE:
-
- Add support for listing the contents of a directory accessed with FILE. The
- output should probably be the same as/similar to FTP.
+12.1 Directory listing on non-POSIX
 
+ Listing the contents of a directory accessed with FILE only works on
+ platforms with opendir. Support could be added for more systems, like
+ Windows.
 
 13. TLS
 
@@ -792,11 +804,22 @@
 
  https://github.com/curl/curl/issues/5081
 
-13.2 Provide mutex locking API
+13.2 TLS channel binding
 
- Provide a libcurl API for setting mutex callbacks in the underlying SSL
- library, so that the same application code can use mutex-locking
- independently of OpenSSL or GnutTLS being used.
+ TLS 1.2 and 1.3 provide the ability to extract some secret data from the TLS
+ connection and use it in the client request (usually in some sort of
+ authentication) to ensure that the data sent is bound to the specific TLS
+ connection and cannot be successfully intercepted by a proxy. This
+ functionality can be used in a standard authentication mechanism such as
+ GSS-API or SCRAM, or in custom approaches like custom HTTP Authentication
+ headers.
+
+ For TLS 1.2, the binding type is usually tls-unique, and for TLS 1.3 it is
+ tls-exporter.
+
+ https://datatracker.ietf.org/doc/html/rfc5929
+ https://datatracker.ietf.org/doc/html/rfc9266
+ https://github.com/curl/curl/issues/9226
 
 13.3 Defeat TLS fingerprinting
 
@@ -806,22 +829,6 @@
 
  See https://github.com/curl/curl/issues/8119
 
-13.4 Cache/share OpenSSL contexts
-
- "Look at SSL cafile - quick traces look to me like these are done on every
- request as well, when they should only be necessary once per SSL context (or
- once per handle)". The major improvement we can rather easily do is to make
- sure we do not create and kill a new SSL "context" for every request, but
- instead make one for every connection and reuse that SSL context in the same
- style connections are reused. It will make us use slightly more memory but it
- will libcurl do less creations and deletions of SSL contexts.
-
- Technically, the "caching" is probably best implemented by getting added to
- the share interface so that easy handles who want to and can reuse the
- context specify that by sharing with the right properties set.
-
- https://github.com/curl/curl/issues/1110
-
 13.5 Export session ids
 
  Add an interface to libcurl that enables "session IDs" to get
@@ -887,15 +894,6 @@
 
  https://github.com/curl/curl/issues/12286
 
-13.12 Reduce CA certificate bundle reparsing
-
- When using the OpenSSL backend, curl will load and reparse the CA bundle at
- the creation of the "SSL context" when it sets up a connection to do a TLS
- handshake. A more effective way would be to somehow cache the CA bundle to
- avoid it having to be repeatedly reloaded and reparsed.
-
- See https://github.com/curl/curl/issues/9379
-
 13.13 Make sure we forbid TLS 1.3 post-handshake authentication
 
  RFC 8740 explains how using HTTP/2 must forbid the use of TLS 1.3
@@ -921,12 +919,18 @@
 
  https://github.com/curl/curl/issues/12982
 
-14. GnuTLS
+13.16 Share the CA cache
 
-14.2 check connection
+ For TLS backends that supports CA caching, it makes sense to allow the share
+ object to be used to store the CA cache as well via the share API. Would
+ allow multiple easy handles to reuse the CA cache and save themselves from a
+ lot of extra processing overhead.
 
- Add a way to check if the connection seems to be alive, to correspond to the
- SSL_peak() way we use with OpenSSL.
+13.17 Add missing features to TLS backends
+
+ The feature matrix at https://curl.se/libcurl/c/tls-options.html shows which
+ features are supported by which TLS backends, and thus also where there are
+ feature gaps.
 
 15. Schannel
 
@@ -946,10 +950,10 @@
 
 15.4 Add option to allow abrupt server closure
 
- libcurl w/schannel will error without a known termination point from the
- server (such as length of transfer, or SSL "close notify" alert) to prevent
- against a truncation attack. Really old servers may neglect to send any
- termination point. An option could be added to ignore such abrupt closures.
+ libcurl w/schannel errors without a known termination point from the server
+ (such as length of transfer, or SSL "close notify" alert) to prevent against
+ a truncation attack. Really old servers may neglect to send any termination
+ point. An option could be added to ignore such abrupt closures.
 
  https://github.com/curl/curl/issues/4427
 
@@ -975,7 +979,7 @@
  SSH is a perfectly fine multiplexed protocols which would allow libcurl to do
  multiple parallel transfers from the same host using the same connection,
  much in the same spirit as HTTP/2 does. libcurl however does not take
- advantage of that ability but will instead always create a new connection for
+ advantage of that ability but does instead always create a new connection for
  new transfers even if an existing connection already exists to the host.
 
  To fix this, libcurl would have to detect an existing connection and "attach"
@@ -985,7 +989,7 @@
 
  The SFTP code in libcurl checks the file size *before* a transfer starts and
  then proceeds to transfer exactly that amount of data. If the remote file
- grows while the transfer is in progress libcurl will not notice and will not
+ grows while the transfer is in progress libcurl does not notice and does not
  adapt. The OpenSSH SFTP command line tool does and libcurl could also just
  attempt to download more to see if there is more to get...
 
@@ -1033,6 +1037,12 @@
  Globbing support for -d and -F, as in 'curl -d "name=foo[0-9]" URL'.
  This is easily scripted though.
 
+18.3 -h option
+
+ Support "curl -h --insecure" etc to output the manpage section for the
+ --insecure command line option in the terminal. Should be possible to work
+ with either long or short versions of command line options.
+
 18.4 --proxycommand
 
  Allow the user to make curl run a command and use its stdio to make requests
@@ -1053,24 +1063,15 @@
 18.6 Option to make -Z merge lined based outputs on stdout
 
  When a user requests multiple lined based files using -Z and sends them to
- stdout, curl will not "merge" and send complete lines fine but may send
+ stdout, curl does not "merge" and send complete lines fine but may send
  partial lines from several sources.
 
  https://github.com/curl/curl/issues/5175
 
-18.8 Consider convenience options for JSON and XML?
-
- Could we add `--xml` or `--json` to add headers needed to call rest API:
-
- `--xml` adds -H 'Content-Type: application/xml' -H "Accept: application/xml" and
- `--json` adds -H 'Content-Type: application/json' -H "Accept: application/json"
-
- Setting Content-Type when doing a GET or any other method without a body
- would be a bit strange I think - so maybe only add CT for requests with body?
- Maybe plain `--xml` and ` --json` are a bit too brief and generic. Maybe
- `--http-json` etc?
+18.7 specify which response codes that make -f/--fail return error
 
- See https://github.com/curl/curl/issues/5203
+ Allows a user to better specify exacly which error code(s) that are fine
+ and which are errors for their specific uses cases
 
 18.9 Choose the name of file in braces for complex URLs
 
@@ -1096,7 +1097,7 @@
  backed up from those that are either not ready or have not changed.
 
  Downloads in progress are neither ready to be backed up, nor should they be
- opened by a different process. Only after a download has been completed it's
+ opened by a different process. Only after a download has been completed it is
  sensible to include it in any integer snapshot or backup of the system.
 
  See https://github.com/curl/curl/issues/3354
@@ -1109,12 +1110,10 @@
  invoke can talk to the still running instance and ask for transfers to get
  done, and thus maintain its connection pool, DNS cache and more.
 
-18.13 Ratelimit or wait between serial requests
+18.13 Acknowledge Ratelimit headers
 
  Consider a command line option that can make curl do multiple serial requests
- slow, potentially with a (random) wait between transfers. There is also a
- proposed set of standard HTTP headers to let servers let the client adapt to
- its rate limits:
+ while acknowledging server specified rate limits:
  https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/
 
  See https://github.com/curl/curl/issues/5406
@@ -1144,22 +1143,22 @@
 
  See https://github.com/curl/curl/issues/1200
 
-18.17 consider file name from the redirected URL with -O ?
+18.17 consider filename from the redirected URL with -O ?
 
  When a user gives a URL and uses -O, and curl follows a redirect to a new
- URL, the file name is not extracted and used from the newly redirected-to URL
- even if the new URL may have a much more sensible file name.
+ URL, the filename is not extracted and used from the newly redirected-to URL
+ even if the new URL may have a much more sensible filename.
 
  This is clearly documented and helps for security since there is no surprise
- to users which file name that might get overwritten. But maybe a new option
+ to users which filename that might get overwritten, but maybe a new option
  could allow for this or maybe -J should imply such a treatment as well as -J
- already allows for the server to decide what file name to use so it already
+ already allows for the server to decide what filename to use so it already
  provides the "may overwrite any file" risk.
 
- This is extra tricky if the original URL has no file name part at all since
- then the current code path will error out with an error message, and we cannot
- *know* already at that point if curl will be redirected to a URL that has a
- file name...
+ This is extra tricky if the original URL has no filename part at all since
+ then the current code path does error out with an error message, and we
+ cannot *know* already at that point if curl is redirected to a URL that has a
+ filename...
 
  See https://github.com/curl/curl/issues/1241
 
@@ -1181,10 +1180,10 @@
 
  See https://github.com/curl/curl/issues/2317
 
-18.20 host name sections in config files
+18.20 hostname sections in config files
 
  config files would be more powerful if they could set different
- configurations depending on used URLs, host name or possibly origin. Then a
+ configurations depending on used URLs, hostname or possibly origin. Then a
  default .curlrc could a specific user-agent only when doing requests against
  a certain site.
 
@@ -1222,7 +1221,7 @@
  - If splitting up the work improves the transfer rate, it could then be done
    again. Then again, etc up to a limit.
 
- This way, if transfer B fails (because Range: is not supported) it will let
+ This way, if transfer B fails (because Range: is not supported) it lets
  transfer A remain the single one. N and M could be set to some sensible
  defaults.
 
@@ -1243,9 +1242,9 @@
  progressing and has not stuck, but they may not appreciate the
  many-times-a-second frequency curl can end up doing it with now.
 
-18.27 -J and -O with %-encoded file names
+18.27 -J and -O with %-encoded filenames
 
- -J/--remote-header-name does not decode %-encoded file names. RFC 6266 details
+ -J/--remote-header-name does not decode %-encoded filenames. RFC 6266 details
  how it should be done. The can of worm is basically that we have no charset
  handling in curl and ascii >=128 is a challenge for us. Not to mention that
  decoding also means that we need to check for nastiness that is attempted,
@@ -1256,15 +1255,15 @@
  -O also does not decode %-encoded names, and while it has even less
  information about the charset involved the process is similar to the -J case.
 
- Note that we will not add decoding to -O without the user asking for it with
- some other means as well, since -O has always been documented to use the name
- exactly as specified in the URL.
+ Note that we do not decode -O without the user asking for it with some other
+ means, since -O has always been documented to use the name exactly as
+ specified in the URL.
 
 18.28 -J with -C -
 
  When using -J (with -O), automatically resumed downloading together with "-C
  -" fails. Without -J the same command line works. This happens because the
- resume logic is worked out before the target file name (and thus its
+ resume logic is worked out before the target filename (and thus its
  pre-transfer size) has been figured out. This can be improved.
 
  https://curl.se/bug/view.cgi?id=1169
@@ -1273,8 +1272,8 @@
 
  If using --retry and the transfer timeouts (possibly due to using -m or
  -y/-Y) the next attempt does not resume the transfer properly from what was
- downloaded in the previous attempt but will truncate and restart at the
- original position where it was at before the previous failed attempt. See
+ downloaded in the previous attempt but truncates and restarts at the original
+ position where it was at before the previous failed attempt. See
  https://curl.se/mail/lib-2008-01/0080.html and Mandriva bug report
  https://qa.mandriva.com/show_bug.cgi?id=22565
 
@@ -1294,12 +1293,13 @@
  curl.
 
 19.3 Do not use GNU libtool on OpenBSD
- When compiling curl on OpenBSD with "--enable-debug" it will give linking
- errors when you use GNU libtool. This can be fixed by using the libtool
- provided by OpenBSD itself. However for this the user always needs to invoke
- make with "LIBTOOL=/usr/bin/libtool". It would be nice if the script could
- have some magic to detect if this system is an OpenBSD host and then use the
- OpenBSD libtool instead.
+
+ When compiling curl on OpenBSD with "--enable-debug" it gives linking errors
+ when you use GNU libtool. This can be fixed by using the libtool provided by
+ OpenBSD itself. However for this the user always needs to invoke make with
+ "LIBTOOL=/usr/bin/libtool". It would be nice if the script could have some
+ magic to detect if this system is an OpenBSD host and then use the OpenBSD
+ libtool instead.
 
  See https://github.com/curl/curl/issues/5862
 
@@ -1344,35 +1344,15 @@
  Make the test suite work on more platforms. OpenBSD and Mac OS. Remove
  fork()s and it should become even more portable.
 
-20.5 Add support for concurrent connections
-
- Tests 836, 882 and 938 were designed to verify that separate connections are
- not used when using different login credentials in protocols that should not
- reuse a connection under such circumstances.
-
- Unfortunately, ftpserver.pl does not appear to support multiple concurrent
- connections. The read while() loop seems to loop until it receives a
- disconnect from the client, where it then enters the waiting for connections
- loop. When the client opens a second connection to the server, the first
- connection has not been dropped (unless it has been forced - which we
- should not do in these tests) and thus the wait for connections loop is never
- entered to receive the second connection.
-
 20.6 Use the RFC 6265 test suite
 
  A test suite made for HTTP cookies (RFC 6265) by Adam Barth is available at
  https://github.com/abarth/http-state/tree/master/tests
 
- It'd be really awesome if someone would write a script/setup that would run
- curl with that test suite and detect deviances. Ideally, that would even be
+ It would be good if someone would write a script/setup that would run curl
+ with that test suite and detect deviances. Ideally, that would even be
  incorporated into our regular test suite.
 
-20.7 Support LD_PRELOAD on macOS
-
- LD_RELOAD does not work on macOS, but there are tests which require it to run
- properly. Look into making the preload support in runtests.pl portable such
- that it uses DYLD_INSERT_LIBRARIES on macOS.
-
 20.8 Run web-platform-tests URL tests
 
  Run web-platform-tests URL tests and compare results with browsers on wpt.fyi
@@ -1389,9 +1369,11 @@
  The rate-limiting logic is done in the PERFORMING state in multi.c but MQTT
  is not (yet) implemented to use that.
 
+21.2 Support MQTTS
+
 22. TFTP
 
-22.1 TFTP doesn't convert LF to CRLF for mode=netascii
+22.1 TFTP does not convert LF to CRLF for mode=netascii
 
  RFC 3617 defines that an TFTP transfer can be done using "netascii"
  mode. curl does not support extracting that mode from the URL nor does it treat
diff --git a/docs/TheArtOfHttpScripting.md b/docs/TheArtOfHttpScripting.md
index 5bb15a457..659fbdd11 100644
--- a/docs/TheArtOfHttpScripting.md
+++ b/docs/TheArtOfHttpScripting.md
@@ -578,12 +578,12 @@ SPDX-License-Identifier: curl
 
 ## Certificates
 
- In the HTTPS world, you use certificates to validate that you are the one
- you claim to be, as an addition to normal passwords. Curl supports client-
- side certificates. All certificates are locked with a pass phrase, which you
- need to enter before the certificate can be used by curl. The pass phrase
- can be specified on the command line or if not, entered interactively when
- curl queries for it. Use a certificate with curl on an HTTPS server like:
+ In the HTTPS world, you use certificates to validate that you are the one you
+ claim to be, as an addition to normal passwords. Curl supports client- side
+ certificates. All certificates are locked with a passphrase, which you need
+ to enter before the certificate can be used by curl. The passphrase can be
+ specified on the command line or if not, entered interactively when curl
+ queries for it. Use a certificate with curl on an HTTPS server like:
 
     curl --cert mycert.pem https://secure.example.com
 
diff --git a/docs/URL-SYNTAX.md b/docs/URL-SYNTAX.md
index 52e0ece15..30aaea9cf 100644
--- a/docs/URL-SYNTAX.md
+++ b/docs/URL-SYNTAX.md
@@ -67,7 +67,7 @@ and curl using scripts remain working.
 curl's URL parser allows a few deviations from the spec in order to
 inter-operate better with URLs that appear in the wild.
 
-### spaces
+### Spaces
 
 A URL provided to curl cannot contain spaces. They need to be provided URL
 encoded to be accepted in a URL by curl.
@@ -77,12 +77,12 @@ client where a resource has been redirected to, sometimes contain spaces. This
 is a violation of RFC 3986 but is fine in the WHATWG spec. curl handles these
 by re-encoding them to `%20`.
 
-### non-ASCII
+### Non-ASCII
 
 Byte values in a provided URL that are outside of the printable ASCII range
 are percent-encoded by curl.
 
-### multiple slashes
+### Multiple slashes
 
 An absolute URL always starts with a "scheme" followed by a colon. For all the
 schemes curl supports, the colon must be followed by two slashes according to
@@ -108,7 +108,7 @@ Based on what the hostname starts with, curl "guesses" what protocol to use:
  - `pop3.` means POP3
  - all other means HTTP
 
-### globbing letters
+### Globbing letters
 
 The curl command line tool supports "globbing" of URLs. It means that you can
 create ranges and lists using `[N-M]` and `{one,two,three}` sequences. The
diff --git a/docs/VULN-DISCLOSURE-POLICY.md b/docs/VULN-DISCLOSURE-POLICY.md
index 0f89816e0..e6d6f3450 100644
--- a/docs/VULN-DISCLOSURE-POLICY.md
+++ b/docs/VULN-DISCLOSURE-POLICY.md
@@ -298,3 +298,18 @@ is curl working as designed and is not a curl security problem. Escape
 sequences, moving cursor, changing color etc, is also frequently used for
 good. To reduce the risk of getting fooled, save files and browse them after
 download using a display method that minimizes risks.
+
+## NULL dereferences and crashes
+
+If a malicious server can trigger a NULL dereference in curl or otherwise
+cause curl to crash (and nothing worse), chances are big that we do not
+consider that a security problem.
+
+Malicious servers can already cause considerable harm and denial of service
+like scenarios without having to trigger such code paths. For example by
+stalling, being terribly slow or by delivering enormous amounts of data.
+Additionally, applications are expected to handle "normal" crashes without
+that being the end of the world.
+
+There need to be more and special circumstances to treat such problems as
+security issues.
diff --git a/docs/cmdline-opts/MANPAGE.md b/docs/cmdline-opts/MANPAGE.md
index 1f9749bc5..3e2e7151f 100644
--- a/docs/cmdline-opts/MANPAGE.md
+++ b/docs/cmdline-opts/MANPAGE.md
@@ -45,7 +45,7 @@ A line that starts with `<!--` is a comment. It should also end with `-->`.
     Help: (short text for the --help output for this option)
     Long: (long form name, without dashes)
     Magic: (description of "magic" options)
-    Multi: single/append/boolean/mutex/custom (if used more than once)
+    Multi: single/append/boolean/mutex/custom/per-URL (if used more than once)
     Mutexed: (space separated list of options this overrides, no dashes)
     Protocols: (space separated list for which protocols this option works)
     Requires: (space separated list of features this requires, no dashes)
diff --git a/docs/cmdline-opts/Makefile.am b/docs/cmdline-opts/Makefile.am
index 7d62c4f45..0aa8a44fa 100644
--- a/docs/cmdline-opts/Makefile.am
+++ b/docs/cmdline-opts/Makefile.am
@@ -54,7 +54,7 @@ $(ASCIIPAGE): $(DPAGES) $(SUPPORT) mainpage.idx Makefile.inc $(MANAGEN)
 	$(GEN)(rm -f $(ASCIIPAGE) && @PERL@ $(MANAGEN) -d $(srcdir) -I $(INCDIR) ascii $(DPAGES) > asciipage.tmp.$$$$ && mv asciipage.tmp.$$$$ $(ASCIIPAGE))
 
 listhelp:
-	$(MANAGEN) listhelp $(DPAGES) > $(top_builddir)/src/tool_listhelp.c
+	$(MANAGEN) -d $(srcdir) listhelp $(DPAGES) > $(top_builddir)/src/tool_listhelp.c
 
 listcats:
 	@$(MANAGEN) listcats $(DPAGES)
diff --git a/docs/cmdline-opts/Makefile.inc b/docs/cmdline-opts/Makefile.inc
index deb4c7c32..d69635e49 100644
--- a/docs/cmdline-opts/Makefile.inc
+++ b/docs/cmdline-opts/Makefile.inc
@@ -136,11 +136,13 @@ DPAGES = \
   include.md \
   insecure.md \
   interface.md \
+  ip-tos.md \
   ipfs-gateway.md \
   ipv4.md \
   ipv6.md \
   json.md \
   junk-session-cookies.md \
+  keepalive-cnt.md \
   keepalive-time.md \
   key-type.md \
   key.md \
@@ -161,6 +163,7 @@ DPAGES = \
   max-redirs.md \
   max-time.md \
   metalink.md \
+  mptcp.md \
   negotiate.md \
   netrc-file.md \
   netrc-optional.md \
@@ -302,5 +305,6 @@ DPAGES = \
   variable.md \
   verbose.md \
   version.md \
+  vlan-priority.md \
   write-out.md \
   xattr.md
diff --git a/docs/cmdline-opts/_PROTOCOLS.md b/docs/cmdline-opts/_PROTOCOLS.md
index 0d4c2374e..af7019ab0 100644
--- a/docs/cmdline-opts/_PROTOCOLS.md
+++ b/docs/cmdline-opts/_PROTOCOLS.md
@@ -49,3 +49,5 @@ Fetching a telnet URL starts an interactive session where it sends what it
 reads on stdin and outputs what the server sends it.
 ## TFTP
 curl can do TFTP downloads and uploads.
+## WS(S)
+WebSocket done over HTTP/1. WSS implies that it works over HTTPS.
diff --git a/docs/cmdline-opts/connect-timeout.md b/docs/cmdline-opts/connect-timeout.md
index e1400811e..dc5f92704 100644
--- a/docs/cmdline-opts/connect-timeout.md
+++ b/docs/cmdline-opts/connect-timeout.md
@@ -4,7 +4,7 @@ SPDX-License-Identifier: curl
 Long: connect-timeout
 Arg: <seconds>
 Help: Maximum time allowed to connect
-Category: connection
+Category: connection timeout
 Added: 7.7
 Multi: single
 See-also:
diff --git a/docs/cmdline-opts/connect-to.md b/docs/cmdline-opts/connect-to.md
index 360ef0da2..578256165 100644
--- a/docs/cmdline-opts/connect-to.md
+++ b/docs/cmdline-opts/connect-to.md
@@ -3,9 +3,9 @@ c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
 Long: connect-to
 Arg: <HOST1:PORT1:HOST2:PORT2>
-Help: Connect to host
+Help: Connect to host2 instead of host1
 Added: 7.49.0
-Category: connection
+Category: connection dns
 Multi: append
 See-also:
   - resolve
@@ -28,3 +28,13 @@ original hostname and port number.
 A hostname specified to this option is compared as a string, so it needs to
 match the name used in request URL. It can be either numerical such as
 `127.0.0.1` or the full host name such as `example.org`.
+
+Example: redirect connects from the example.com hostname to 127.0.0.1
+independently of port number:
+
+    curl --connect-to example.com::127.0.0.1: https://example.com/
+
+Example: redirect connects from all hostnames to 127.0.0.1 independently of
+port number:
+
+    curl --connect-to ::127.0.0.1: http://example.com/
diff --git a/docs/cmdline-opts/cookie-jar.md b/docs/cmdline-opts/cookie-jar.md
index f99368591..49a9440bf 100644
--- a/docs/cmdline-opts/cookie-jar.md
+++ b/docs/cmdline-opts/cookie-jar.md
@@ -11,6 +11,7 @@ Added: 7.9
 Multi: single
 See-also:
   - cookie
+  - junk-session-cookies
 Example:
   - -c store-here.txt $URL
   - -c store-here.txt -b read-these $URL
diff --git a/docs/cmdline-opts/create-dirs.md b/docs/cmdline-opts/create-dirs.md
index fcbeb3343..c509efb0f 100644
--- a/docs/cmdline-opts/create-dirs.md
+++ b/docs/cmdline-opts/create-dirs.md
@@ -3,7 +3,7 @@ c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
 Long: create-dirs
 Help: Create necessary local directory hierarchy
-Category: curl
+Category: output
 Added: 7.10.3
 Multi: boolean
 See-also:
diff --git a/docs/cmdline-opts/crlf.md b/docs/cmdline-opts/crlf.md
index 81a14ef6f..c36884113 100644
--- a/docs/cmdline-opts/crlf.md
+++ b/docs/cmdline-opts/crlf.md
@@ -17,5 +17,3 @@ Example:
 
 Convert line feeds to carriage return plus line feeds in upload. Useful for
 **MVS (OS/390)**.
-
-(SMTP added in 7.40.0)
diff --git a/docs/cmdline-opts/disable.md b/docs/cmdline-opts/disable.md
index e22a2bb4a..1370b91d7 100644
--- a/docs/cmdline-opts/disable.md
+++ b/docs/cmdline-opts/disable.md
@@ -18,6 +18,3 @@ Example:
 If used as the **first** parameter on the command line, the *curlrc* config
 file is not read or used. See the --config for details on the default config
 file search path.
-
-Prior to 7.50.0 curl supported the short option name *q* but not the long
-option name *disable*.
diff --git a/docs/cmdline-opts/doh-insecure.md b/docs/cmdline-opts/doh-insecure.md
index 684428ddf..72f3cb772 100644
--- a/docs/cmdline-opts/doh-insecure.md
+++ b/docs/cmdline-opts/doh-insecure.md
@@ -8,10 +8,20 @@ Category: dns tls
 Multi: boolean
 See-also:
   - doh-url
+  - insecure
+  - proxy-insecure
 Example:
   - --doh-insecure --doh-url https://doh.example $URL
 ---
 
 # `--doh-insecure`
 
-Same as --insecure but used for DoH (DNS-over-HTTPS).
+By default, every connection curl makes to a DoH server is verified to be
+secure before the transfer takes place. This option tells curl to skip the
+verification step and proceed without checking.
+
+**WARNING**: using this option makes the DoH transfer and name resolution
+insecure.
+
+This option is equivalent to --insecure and --proxy-insecure but used for DoH
+(DNS-over-HTTPS) only.
diff --git a/docs/cmdline-opts/dump-header.md b/docs/cmdline-opts/dump-header.md
index 42d3e85ed..925e6da66 100644
--- a/docs/cmdline-opts/dump-header.md
+++ b/docs/cmdline-opts/dump-header.md
@@ -13,12 +13,14 @@ See-also:
   - output
 Example:
   - --dump-header store.txt $URL
+  - --dump-header - $URL -o save
 ---
 
 # `--dump-header`
 
 Write the received protocol headers to the specified file. If no headers are
-received, the use of this option creates an empty file.
+received, the use of this option creates an empty file. Specify `-` as file
+name (a single minus) to have it written to stdout.
 
 When used in FTP, the FTP server response lines are considered being "headers"
 and thus are saved there.
diff --git a/docs/cmdline-opts/ech.md b/docs/cmdline-opts/ech.md
index 5c76f5bf2..6c2ba31cb 100644
--- a/docs/cmdline-opts/ech.md
+++ b/docs/cmdline-opts/ech.md
@@ -3,9 +3,9 @@ c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
 Long: ech
 Arg: <config>
-Help: Configure Encrypted Client Hello (ECH) for use with the TLS session
+Help: Configure ECH
 Added: 8.8.0
-Category: tls ECH
+Category: tls
 Protocols: HTTPS
 Multi: single
 See-also:
diff --git a/docs/cmdline-opts/egd-file.md b/docs/cmdline-opts/egd-file.md
index b68b7d496..ef16b9964 100644
--- a/docs/cmdline-opts/egd-file.md
+++ b/docs/cmdline-opts/egd-file.md
@@ -5,7 +5,7 @@ Long: egd-file
 Arg: <file>
 Help: EGD socket path for random data
 Protocols: TLS
-Category: tls
+Category: deprecated
 Added: 7.7
 Multi: single
 See-also:
diff --git a/docs/cmdline-opts/expect100-timeout.md b/docs/cmdline-opts/expect100-timeout.md
index ce69227ad..854761818 100644
--- a/docs/cmdline-opts/expect100-timeout.md
+++ b/docs/cmdline-opts/expect100-timeout.md
@@ -6,7 +6,7 @@ Arg: <seconds>
 Help: How long to wait for 100-continue
 Protocols: HTTP
 Added: 7.47.0
-Category: http
+Category: http timeout
 Multi: single
 See-also:
   - connect-timeout
diff --git a/docs/cmdline-opts/fail-early.md b/docs/cmdline-opts/fail-early.md
index bb22e1470..67edbf919 100644
--- a/docs/cmdline-opts/fail-early.md
+++ b/docs/cmdline-opts/fail-early.md
@@ -4,7 +4,7 @@ SPDX-License-Identifier: curl
 Long: fail-early
 Help: Fail on first transfer error
 Added: 7.52.0
-Category: curl
+Category: curl global
 Multi: boolean
 Scope: global
 See-also:
diff --git a/docs/cmdline-opts/fail.md b/docs/cmdline-opts/fail.md
index 8591e330d..0c8db1367 100644
--- a/docs/cmdline-opts/fail.md
+++ b/docs/cmdline-opts/fail.md
@@ -18,11 +18,17 @@ Example:
 
 # `--fail`
 
-Fail fast with no output at all on server errors. This is useful to enable
-scripts and users to better deal with failed attempts. In normal cases when an
-HTTP server fails to deliver a document, it returns an HTML document stating
-so (which often also describes why and more). This command line option
-prevents curl from outputting that and return error 22.
+Fail with error code 22 and with no response body output at all for HTTP
+transfers returning HTTP response codes at 400 or greater.
+
+In normal cases when an HTTP server fails to deliver a document, it returns a
+body of text stating so (which often also describes why and more) and a 4xx
+HTTP response code. This command line option prevents curl from outputting
+that data and instead returns error 22 early. By default, curl does not
+consider HTTP response codes to indicate failure.
+
+To get both the error code and also save the content, use --fail-with-body
+instead.
 
 This method is not fail-safe and there are occasions where non-successful
 response codes slip through, especially when authentication is involved
diff --git a/docs/cmdline-opts/form-escape.md b/docs/cmdline-opts/form-escape.md
index 083c29e16..0f93fde7e 100644
--- a/docs/cmdline-opts/form-escape.md
+++ b/docs/cmdline-opts/form-escape.md
@@ -3,9 +3,9 @@ c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
 Long: form-escape
 Help: Escape form fields using backslash
-Protocols: HTTP
+Protocols: HTTP imap smtp
 Added: 7.81.0
-Category: http upload
+Category: http upload post
 Multi: single
 See-also:
   - form
diff --git a/docs/cmdline-opts/form-string.md b/docs/cmdline-opts/form-string.md
index 3c1f7b532..e58ad625d 100644
--- a/docs/cmdline-opts/form-string.md
+++ b/docs/cmdline-opts/form-string.md
@@ -5,7 +5,7 @@ Long: form-string
 Help: Specify multipart MIME data
 Protocols: HTTP SMTP IMAP
 Arg: <name=string>
-Category: http upload
+Category: http upload post smtp imap
 Added: 7.13.2
 Multi: append
 See-also:
diff --git a/docs/cmdline-opts/form.md b/docs/cmdline-opts/form.md
index 8a4c91e5a..5daa571e6 100644
--- a/docs/cmdline-opts/form.md
+++ b/docs/cmdline-opts/form.md
@@ -7,7 +7,7 @@ Arg: <name=content>
 Help: Specify multipart MIME data
 Protocols: HTTP SMTP IMAP
 Mutexed: data head upload-file
-Category: http upload
+Category: http upload post imap smtp
 Added: 5.0
 Multi: append
 See-also:
diff --git a/docs/cmdline-opts/ftp-create-dirs.md b/docs/cmdline-opts/ftp-create-dirs.md
index 5151e336c..3e851ccae 100644
--- a/docs/cmdline-opts/ftp-create-dirs.md
+++ b/docs/cmdline-opts/ftp-create-dirs.md
@@ -4,7 +4,7 @@ SPDX-License-Identifier: curl
 Long: ftp-create-dirs
 Protocols: FTP SFTP
 Help: Create the remote dirs if not present
-Category: ftp sftp curl
+Category: ftp sftp
 Added: 7.10.7
 Multi: boolean
 See-also:
diff --git a/docs/cmdline-opts/get.md b/docs/cmdline-opts/get.md
index f8c8cf2f9..ac0560ab6 100644
--- a/docs/cmdline-opts/get.md
+++ b/docs/cmdline-opts/get.md
@@ -5,7 +5,7 @@ Long: get
 Short: G
 Help: Put the post data in the URL and use GET
 Protocols: HTTP
-Category: http upload
+Category: http
 Added: 7.8.1
 Multi: boolean
 See-also:
@@ -19,10 +19,10 @@ Example:
 
 # `--get`
 
-When used, this option makes all data specified with --data, --data-binary
-or --data-urlencode to be used in an HTTP GET request instead of the POST
-request that otherwise would be used. The data is appended to the URL
-with a '?' separator.
+When used, this option makes all data specified with --data, --data-binary or
+--data-urlencode to be used in an HTTP GET request instead of the POST request
+that otherwise would be used. curl appends the provided data to the URL as a
+query string.
 
 If used in combination with --head, the POST data is instead appended to the
 URL with a HEAD request.
diff --git a/docs/cmdline-opts/happy-eyeballs-timeout-ms.md b/docs/cmdline-opts/happy-eyeballs-timeout-ms.md
index 8370ee92b..f4b492db0 100644
--- a/docs/cmdline-opts/happy-eyeballs-timeout-ms.md
+++ b/docs/cmdline-opts/happy-eyeballs-timeout-ms.md
@@ -5,7 +5,7 @@ Long: happy-eyeballs-timeout-ms
 Arg: <ms>
 Help: Time for IPv6 before IPv4
 Added: 7.59.0
-Category: connection
+Category: connection timeout
 Multi: single
 See-also:
   - max-time
diff --git a/docs/cmdline-opts/header.md b/docs/cmdline-opts/header.md
index 13ca4cb32..17219f383 100644
--- a/docs/cmdline-opts/header.md
+++ b/docs/cmdline-opts/header.md
@@ -46,14 +46,14 @@ other safe guards. That includes white space and control characters.
 
 This option can take an argument in @filename style, which then adds a header
 for each line in the input file. Using @- makes curl read the header file from
-stdin. Added in 7.55.0.
+stdin. (Added in 7.55.0)
 
 Please note that most anti-spam utilities check the presence and value of
 several MIME mail headers: these are `From:`, `To:`, `Date:` and `Subject:`
 among others and should be added with this option.
 
-You need --proxy-header to send custom headers intended for an HTTP
-proxy. Added in 7.37.0.
+You need --proxy-header to send custom headers intended for an HTTP proxy.
+(Added in 7.37.0)
 
 Passing on a "Transfer-Encoding: chunked" header when doing an HTTP request
 with a request body, makes curl send the data using chunked encoding.
diff --git a/docs/cmdline-opts/hostpubmd5.md b/docs/cmdline-opts/hostpubmd5.md
index 7dc873254..5d480a5bc 100644
--- a/docs/cmdline-opts/hostpubmd5.md
+++ b/docs/cmdline-opts/hostpubmd5.md
@@ -6,7 +6,7 @@ Arg: <md5>
 Help: Acceptable MD5 hash of host public key
 Protocols: SFTP SCP
 Added: 7.17.1
-Category: sftp scp
+Category: sftp scp ssh
 Multi: single
 See-also:
   - hostpubsha256
diff --git a/docs/cmdline-opts/hostpubsha256.md b/docs/cmdline-opts/hostpubsha256.md
index 8ec080551..35aa8ff7d 100644
--- a/docs/cmdline-opts/hostpubsha256.md
+++ b/docs/cmdline-opts/hostpubsha256.md
@@ -6,7 +6,7 @@ Arg: <sha256>
 Help: Acceptable SHA256 hash of host public key
 Protocols: SFTP SCP
 Added: 7.80.0
-Category: sftp scp
+Category: sftp scp ssh
 Multi: single
 See-also:
   - hostpubmd5
diff --git a/docs/cmdline-opts/include.md b/docs/cmdline-opts/include.md
index c4f6beb81..e48799128 100644
--- a/docs/cmdline-opts/include.md
+++ b/docs/cmdline-opts/include.md
@@ -21,6 +21,3 @@ things like server name, cookies, date of the document, HTTP version and
 more... With non-HTTP protocols, the "headers" are other server communication.
 
 To view the request headers, consider the --verbose option.
-
-Prior to 7.75.0 curl did not print the headers if --fail was used in
-combination with this option and there was error reported by server.
diff --git a/docs/cmdline-opts/insecure.md b/docs/cmdline-opts/insecure.md
index b1c056b44..6b7009f25 100644
--- a/docs/cmdline-opts/insecure.md
+++ b/docs/cmdline-opts/insecure.md
@@ -5,7 +5,7 @@ Long: insecure
 Short: k
 Help: Allow insecure server connections
 Protocols: TLS SFTP SCP
-Category: tls sftp scp
+Category: tls sftp scp ssh
 Added: 7.10
 Multi: boolean
 See-also:
diff --git a/docs/cmdline-opts/interface.md b/docs/cmdline-opts/interface.md
index c938fd271..539e39272 100644
--- a/docs/cmdline-opts/interface.md
+++ b/docs/cmdline-opts/interface.md
@@ -3,7 +3,7 @@ c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
 Long: interface
 Arg: <name>
-Help: Use network INTERFACE (or address)
+Help: Use network interface
 Category: connection
 Added: 7.3
 Multi: single
@@ -11,15 +11,41 @@ See-also:
   - dns-interface
 Example:
   - --interface eth0 $URL
+  - --interface "host!10.0.0.1" $URL
+  - --interface "if!enp3s0" $URL
 ---
 
 # `--interface`
 
-Perform an operation using a specified interface. You can enter interface
-name, IP address or hostname. An example could look like:
+Perform the operation using a specified interface. You can enter interface
+name, IP address or hostname. If you prefer to be specific, you can use the
+following special syntax:
 
-    curl --interface eth0:1 https://www.example.com/
+## if!<name>
 
-On Linux it can be used to specify a **VRF**, but the binary needs to either
-have **CAP_NET_RAW** or to be run as root. More information about Linux
-**VRF**: https://www.kernel.org/doc/Documentation/networking/vrf.txt
+Interface name. If the provided name does not match an existing interface,
+curl returns with error 45.
+
+## host!<name>
+
+IP address or hostname.
+
+## ifhost!<interface>!<host>
+
+Interface name and IP address or hostname. This syntax requires libcurl 8.9.0
+or later.
+
+If the provided name does not match an existing interface, curl returns with
+error 45.
+
+##
+
+curl does not support using network interface names for this option on
+Windows.
+
+That name resolve operation if a hostname is provided does **not** use
+DNS-over-HTTPS even if --doh-url is set.
+
+On Linux this option can be used to specify a **VRF** (Virtual Routing and
+Forwarding) device, but the binary then needs to either have the
+**CAP_NET_RAW** capability set or to be run as root.
diff --git a/docs/cmdline-opts/ip-tos.md b/docs/cmdline-opts/ip-tos.md
new file mode 100644
index 000000000..3d6473f31
--- /dev/null
+++ b/docs/cmdline-opts/ip-tos.md
@@ -0,0 +1,27 @@
+---
+c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+SPDX-License-Identifier: curl
+Long: ip-tos
+Arg: <string>
+Help: Set IP Type of Service or Traffic Class
+Added: 8.9.0
+Category: connection
+Protocols: All
+Multi: single
+See-also:
+  - tcp-nodelay
+  - vlan-priority
+Example:
+  - --ip-tos CS5 $URL
+---
+
+# `--ip-tos`
+
+Set Type of Service (TOS) for IPv4 or Traffic Class for IPv6.
+
+The values allowed for \<string\> can be a numeric value between 1 and 255
+or one of the following:
+
+CS0, CS1, CS2, CS3, CS4, CS5, CS6, CS7, AF11, AF12, AF13, AF21, AF22, AF23,
+AF31, AF32, AF33, AF41, AF42, AF43, EF, VOICE-ADMIT, ECT1, ECT0, CE, LE,
+LOWCOST, LOWDELAY, THROUGHPUT, RELIABILITY, MINCOST
diff --git a/docs/cmdline-opts/ipfs-gateway.md b/docs/cmdline-opts/ipfs-gateway.md
index 63429d83d..70ca717a7 100644
--- a/docs/cmdline-opts/ipfs-gateway.md
+++ b/docs/cmdline-opts/ipfs-gateway.md
@@ -6,7 +6,7 @@ Arg: <URL>
 Help: Gateway for IPFS
 Protocols: IPFS
 Added: 8.4.0
-Category: ipfs
+Category: curl
 Multi: single
 See-also:
   - help
diff --git a/docs/cmdline-opts/keepalive-cnt.md b/docs/cmdline-opts/keepalive-cnt.md
new file mode 100644
index 000000000..e56c976ec
--- /dev/null
+++ b/docs/cmdline-opts/keepalive-cnt.md
@@ -0,0 +1,27 @@
+---
+c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+SPDX-License-Identifier: curl
+Long: keepalive-cnt
+Arg: <integer>
+Help: Maximum number of keepalive probes
+Added: 8.9.0
+Category: connection
+Multi: single
+See-also:
+  - keepalive-time
+  - no-keepalive
+Example:
+  - --keepalive-cnt 3 $URL
+---
+
+# `--keepalive-cnt`
+
+Set the maximum number of keepalive probes TCP should send but get no response
+before dropping the connection. This option is usually used in conjunction
+with --keepalive-time.
+
+This option is supported on Linux, *BSD/macOS, Windows \>=10.0.16299, Solaris
+11.4, and recent AIX, HP-UX and more. This option has no effect if
+--no-keepalive is used.
+
+If unspecified, the option defaults to 9.
diff --git a/docs/cmdline-opts/keepalive-time.md b/docs/cmdline-opts/keepalive-time.md
index 41c09031e..4b10ff6f4 100644
--- a/docs/cmdline-opts/keepalive-time.md
+++ b/docs/cmdline-opts/keepalive-time.md
@@ -5,10 +5,11 @@ Long: keepalive-time
 Arg: <seconds>
 Help: Interval time for keepalive probes
 Added: 7.18.0
-Category: connection
+Category: connection timeout
 Multi: single
 See-also:
   - no-keepalive
+  - keepalive-cnt
   - max-time
 Example:
   - --keepalive-time 20 $URL
@@ -19,9 +20,11 @@ Example:
 Set the time a connection needs to remain idle before sending keepalive probes
 and the time between individual keepalive probes. It is currently effective on
 operating systems offering the `TCP_KEEPIDLE` and `TCP_KEEPINTVL` socket
-options (meaning Linux, recent AIX, HP-UX and more). Keepalive is used by the
-TCP stack to detect broken networks on idle connections. The number of missed
-keepalive probes before declaring the connection down is OS dependent and is
-commonly 9 or 10. This option has no effect if --no-keepalive is used.
+options (meaning Linux, *BSD/macOS, Windows, Solaris, and recent AIX, HP-UX and more).
+Keepalive is used by the TCP stack to detect broken networks on idle connections.
+The number of missed keepalive probes before declaring the connection down is OS
+dependent and is commonly 8 (*BSD/macOS/AIX), 9 (Linux/AIX) or 5/10 (Windows), and
+this number can be changed by specifying the curl option `keepalive-cnt`.
+Note that this option has no effect if --no-keepalive is used.
 
 If unspecified, the option defaults to 60 seconds.
diff --git a/docs/cmdline-opts/libcurl.md b/docs/cmdline-opts/libcurl.md
index eeae596d0..60af60540 100644
--- a/docs/cmdline-opts/libcurl.md
+++ b/docs/cmdline-opts/libcurl.md
@@ -5,7 +5,7 @@ Long: libcurl
 Arg: <file>
 Help: Generate libcurl code for this command line
 Added: 7.16.1
-Category: curl
+Category: curl global
 Multi: single
 Scope: global
 See-also:
diff --git a/docs/cmdline-opts/location-trusted.md b/docs/cmdline-opts/location-trusted.md
index 4f4e7def5..edbd0b539 100644
--- a/docs/cmdline-opts/location-trusted.md
+++ b/docs/cmdline-opts/location-trusted.md
@@ -2,7 +2,7 @@
 c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
 Long: location-trusted
-Help: Like --location, but send auth to other hosts
+Help: As --location, but send auth to other hosts
 Protocols: HTTP
 Category: http auth
 Added: 7.10.4
diff --git a/docs/cmdline-opts/login-options.md b/docs/cmdline-opts/login-options.md
index fdeeda52a..fc8292a2b 100644
--- a/docs/cmdline-opts/login-options.md
+++ b/docs/cmdline-opts/login-options.md
@@ -6,7 +6,7 @@ Arg: <options>
 Protocols: IMAP LDAP POP3 SMTP
 Help: Server login options
 Added: 7.34.0
-Category: imap pop3 smtp auth
+Category: imap pop3 smtp auth ldap
 Multi: single
 See-also:
   - user
diff --git a/docs/cmdline-opts/mail-auth.md b/docs/cmdline-opts/mail-auth.md
index 3692c1596..deabb38b9 100644
--- a/docs/cmdline-opts/mail-auth.md
+++ b/docs/cmdline-opts/mail-auth.md
@@ -12,7 +12,7 @@ See-also:
   - mail-rcpt
   - mail-from
 Example:
-  - --mail-auth user@example.come -T mail smtp://example.com/
+  - --mail-auth user@example.com -T mail smtp://example.com/
 ---
 
 # `--mail-auth`
diff --git a/docs/cmdline-opts/max-time.md b/docs/cmdline-opts/max-time.md
index 9102442aa..1d19e4972 100644
--- a/docs/cmdline-opts/max-time.md
+++ b/docs/cmdline-opts/max-time.md
@@ -5,7 +5,7 @@ Long: max-time
 Short: m
 Arg: <seconds>
 Help: Maximum time allowed for transfer
-Category: connection
+Category: connection timeout
 Added: 4.0
 Multi: single
 See-also:
diff --git a/docs/cmdline-opts/metalink.md b/docs/cmdline-opts/metalink.md
index 0c39b46ed..d3d3e2574 100644
--- a/docs/cmdline-opts/metalink.md
+++ b/docs/cmdline-opts/metalink.md
@@ -4,7 +4,7 @@ SPDX-License-Identifier: curl
 Long: metalink
 Help: Process given URLs as metalink XML file
 Added: 7.27.0
-Category: misc
+Category: deprecated
 Multi: single
 See-also:
   - parallel
diff --git a/docs/cmdline-opts/mptcp.md b/docs/cmdline-opts/mptcp.md
new file mode 100644
index 000000000..698b69370
--- /dev/null
+++ b/docs/cmdline-opts/mptcp.md
@@ -0,0 +1,31 @@
+---
+c: Copyright (C) Dorian Craps, <dorian.craps@student.vinci.be>
+SPDX-License-Identifier: curl
+Long: mptcp
+Added: 8.9.0
+Help: Enable Multipath TCP
+Category: connection
+Multi: boolean
+See-also:
+  - tcp-fastopen
+Example:
+  - --mptcp $URL
+---
+
+# `--mptcp`
+
+Enables the use of Multipath TCP (MPTCP) for connections. MPTCP is an extension
+to the standard TCP that allows multiple TCP streams over different network
+paths between the same source and destination. This can enhance bandwidth and
+improve reliability by using multiple paths simultaneously.
+
+MPTCP is beneficial in networks where multiple paths exist between clients and
+servers, such as mobile networks where a device may switch between WiFi and
+cellular data or in wired networks with multiple Internet Service Providers.
+
+This option is currently only supported on Linux starting from kernel 5.6. Only
+TCP connections are modified, hence this option does not effect HTTP/3 (QUIC)
+or UDP connections.
+
+The server curl connects to must also support MPTCP. If not, the connection
+seamlessly falls back to TCP.
diff --git a/docs/cmdline-opts/netrc-file.md b/docs/cmdline-opts/netrc-file.md
index 841f23c48..3df72ce14 100644
--- a/docs/cmdline-opts/netrc-file.md
+++ b/docs/cmdline-opts/netrc-file.md
@@ -6,7 +6,7 @@ Help: Specify FILE for netrc
 Arg: <filename>
 Added: 7.21.5
 Mutexed: netrc
-Category: curl
+Category: auth
 Multi: single
 See-also:
   - netrc
diff --git a/docs/cmdline-opts/netrc-optional.md b/docs/cmdline-opts/netrc-optional.md
index 6aa76954a..9b9c068c8 100644
--- a/docs/cmdline-opts/netrc-optional.md
+++ b/docs/cmdline-opts/netrc-optional.md
@@ -4,7 +4,7 @@ SPDX-License-Identifier: curl
 Long: netrc-optional
 Help: Use either .netrc or URL
 Mutexed: netrc
-Category: curl
+Category: auth
 Added: 7.9.8
 Multi: boolean
 See-also:
diff --git a/docs/cmdline-opts/netrc.md b/docs/cmdline-opts/netrc.md
index 4c07f9b75..26e1ccd21 100644
--- a/docs/cmdline-opts/netrc.md
+++ b/docs/cmdline-opts/netrc.md
@@ -4,7 +4,7 @@ SPDX-License-Identifier: curl
 Long: netrc
 Short: n
 Help: Must read .netrc for username and password
-Category: curl
+Category: auth
 Added: 4.6
 Mutexed: netrc-file netrc-optional
 Multi: boolean
diff --git a/docs/cmdline-opts/next.md b/docs/cmdline-opts/next.md
index 2cf65c65a..cb67e907f 100644
--- a/docs/cmdline-opts/next.md
+++ b/docs/cmdline-opts/next.md
@@ -7,7 +7,7 @@ Tags:
 Protocols:
 Added: 7.36.0
 Magic: divider
-Help: Make next URL use its separate set of options
+Help: Make next URL use separate options
 Category: curl
 Multi: append
 See-also:
diff --git a/docs/cmdline-opts/no-buffer.md b/docs/cmdline-opts/no-buffer.md
index 41328b165..e0860155c 100644
--- a/docs/cmdline-opts/no-buffer.md
+++ b/docs/cmdline-opts/no-buffer.md
@@ -4,7 +4,7 @@ SPDX-License-Identifier: curl
 Long: no-buffer
 Short: N
 Help: Disable buffering of the output stream
-Category: curl
+Category: output
 Added: 6.5
 Multi: boolean
 See-also:
diff --git a/docs/cmdline-opts/no-clobber.md b/docs/cmdline-opts/no-clobber.md
index 58646224c..690900563 100644
--- a/docs/cmdline-opts/no-clobber.md
+++ b/docs/cmdline-opts/no-clobber.md
@@ -3,7 +3,7 @@ c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
 Long: no-clobber
 Help: Do not overwrite files that already exist
-Category: curl output
+Category: output
 Added: 7.83.0
 Multi: boolean
 See-also:
diff --git a/docs/cmdline-opts/no-keepalive.md b/docs/cmdline-opts/no-keepalive.md
index 1829e8c4e..2c2115fe0 100644
--- a/docs/cmdline-opts/no-keepalive.md
+++ b/docs/cmdline-opts/no-keepalive.md
@@ -8,6 +8,7 @@ Added: 7.18.0
 Multi: boolean
 See-also:
   - keepalive-time
+  - keepalive-cnt
 Example:
   - --no-keepalive $URL
 ---
diff --git a/docs/cmdline-opts/no-npn.md b/docs/cmdline-opts/no-npn.md
index d8ad6a251..dbb69e91b 100644
--- a/docs/cmdline-opts/no-npn.md
+++ b/docs/cmdline-opts/no-npn.md
@@ -8,7 +8,7 @@ Added: 7.36.0
 Mutexed:
 Requires: TLS
 Help: Disable the NPN TLS extension
-Category: tls http
+Category: deprecated
 Multi: boolean
 See-also:
   - no-alpn
diff --git a/docs/cmdline-opts/ntlm-wb.md b/docs/cmdline-opts/ntlm-wb.md
index 4cc52b65e..3a1d35cb1 100644
--- a/docs/cmdline-opts/ntlm-wb.md
+++ b/docs/cmdline-opts/ntlm-wb.md
@@ -4,7 +4,7 @@ SPDX-License-Identifier: curl
 Long: ntlm-wb
 Help: HTTP NTLM authentication with winbind
 Protocols: HTTP
-Category: auth http
+Category: deprecated
 Added: 7.22.0
 Multi: mutex
 See-also:
diff --git a/docs/cmdline-opts/oauth2-bearer.md b/docs/cmdline-opts/oauth2-bearer.md
index ee9ec5dcc..b66477fc7 100644
--- a/docs/cmdline-opts/oauth2-bearer.md
+++ b/docs/cmdline-opts/oauth2-bearer.md
@@ -5,7 +5,7 @@ Long: oauth2-bearer
 Help: OAuth 2 Bearer Token
 Arg: <token>
 Protocols: IMAP LDAP POP3 SMTP HTTP
-Category: auth
+Category: auth imap pop3 smtp ldap
 Added: 7.33.0
 Multi: single
 See-also:
diff --git a/docs/cmdline-opts/output-dir.md b/docs/cmdline-opts/output-dir.md
index 04d780f29..468ecc8a1 100644
--- a/docs/cmdline-opts/output-dir.md
+++ b/docs/cmdline-opts/output-dir.md
@@ -5,7 +5,7 @@ Long: output-dir
 Arg: <dir>
 Help: Directory to save files in
 Added: 7.73.0
-Category: curl
+Category: output
 Multi: single
 See-also:
   - remote-name
diff --git a/docs/cmdline-opts/output.md b/docs/cmdline-opts/output.md
index 53f658327..48360a498 100644
--- a/docs/cmdline-opts/output.md
+++ b/docs/cmdline-opts/output.md
@@ -5,9 +5,9 @@ Long: output
 Arg: <file>
 Short: o
 Help: Write to file instead of stdout
-Category: important curl
+Category: important output
 Added: 4.0
-Multi: append
+Multi: per-URL
 See-also:
   - remote-name
   - remote-name-all
diff --git a/docs/cmdline-opts/parallel-immediate.md b/docs/cmdline-opts/parallel-immediate.md
index f93a355f2..4d7a3ad51 100644
--- a/docs/cmdline-opts/parallel-immediate.md
+++ b/docs/cmdline-opts/parallel-immediate.md
@@ -2,9 +2,9 @@
 c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
 Long: parallel-immediate
-Help: Do not wait for multiplexing (with --parallel)
+Help: Do not wait for multiplexing
 Added: 7.68.0
-Category: connection curl
+Category: connection curl global
 Multi: boolean
 Scope: global
 See-also:
@@ -16,7 +16,10 @@ Example:
 
 # `--parallel-immediate`
 
-When doing parallel transfers, this option instructs curl that it should
-rather prefer opening up more connections in parallel at once rather than
-waiting to see if new transfers can be added as multiplexed streams on another
-connection.
+When doing parallel transfers, this option instructs curl to prefer opening up
+more connections in parallel at once rather than waiting to see if new
+transfers can be added as multiplexed streams on another connection.
+
+By default, without this option set, curl prefers to wait a little and
+multiplex new transfers over existing connections. It keeps the number of
+connections low at the expense of risking a slightly slower transfer startup.
diff --git a/docs/cmdline-opts/parallel-max.md b/docs/cmdline-opts/parallel-max.md
index f3d2ad198..6b3684b8f 100644
--- a/docs/cmdline-opts/parallel-max.md
+++ b/docs/cmdline-opts/parallel-max.md
@@ -5,8 +5,9 @@ Long: parallel-max
 Arg: <num>
 Help: Maximum concurrency for parallel transfers
 Added: 7.66.0
-Category: connection curl
+Category: connection curl global
 Multi: single
+Scope: global
 See-also:
   - parallel
 Example:
@@ -18,7 +19,4 @@ Example:
 When asked to do parallel transfers, using --parallel, this option controls
 the maximum amount of transfers to do simultaneously.
 
-This option is global and does not need to be specified for each use of
---next.
-
-The default is 50.
+The default is 50. 300 is the largest supported value.
diff --git a/docs/cmdline-opts/parallel.md b/docs/cmdline-opts/parallel.md
index f67598a0b..fb9221bc6 100644
--- a/docs/cmdline-opts/parallel.md
+++ b/docs/cmdline-opts/parallel.md
@@ -5,17 +5,28 @@ Short: Z
 Long: parallel
 Help: Perform transfers in parallel
 Added: 7.66.0
-Category: connection curl
+Category: connection curl global
 Multi: boolean
 Scope: global
 See-also:
   - next
   - verbose
+  - parallel-max
+  - parallel-immediate
 Example:
   - --parallel $URL -o file1 $URL -o file2
 ---
 
 # `--parallel`
 
-Makes curl perform its transfers in parallel as compared to the regular serial
-manner.
+Makes curl perform all transfers in parallel as compared to the regular serial
+manner. Parallel transfer means that curl runs up to N concurrent transfers
+simultaneously and if there are more than N transfers to handle, it starts new
+ones when earlier transfers finish.
+
+With parallel transfers, the progress meter output is different than when
+doing serial transfers, as it then displays the transfer status for multiple
+transfers in a single line.
+
+The maximum amount of concurrent transfers is set with --parallel-max and it
+defaults to 50.
diff --git a/docs/cmdline-opts/pass.md b/docs/cmdline-opts/pass.md
index a0d94563e..98bc35b24 100644
--- a/docs/cmdline-opts/pass.md
+++ b/docs/cmdline-opts/pass.md
@@ -3,7 +3,7 @@ c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
 Long: pass
 Arg: <phrase>
-Help: Pass phrase for the private key
+Help: Passphrase for the private key
 Protocols: SSH TLS
 Category: ssh tls auth
 Added: 7.9.3
diff --git a/docs/cmdline-opts/pinnedpubkey.md b/docs/cmdline-opts/pinnedpubkey.md
index 53c79912a..d21a18f69 100644
--- a/docs/cmdline-opts/pinnedpubkey.md
+++ b/docs/cmdline-opts/pinnedpubkey.md
@@ -3,7 +3,7 @@ c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
 Long: pinnedpubkey
 Arg: <hashes>
-Help: FILE/HASHES Public key to verify peer against
+Help: Public key to verify peer against
 Protocols: TLS
 Category: tls
 Added: 7.39.0
@@ -33,12 +33,13 @@ together then the peer is still verified by public key.
 PEM/DER support:
 
 OpenSSL and GnuTLS (added in 7.39.0), wolfSSL (added in 7.43.0), mbedTLS
-(added in 7.47.0), Secure Transport macOS 10.7+/iOS 10+ (7.54.1), Schannel
-(7.58.1)
+(added in 7.47.0), Secure Transport macOS 10.7+/iOS 10+ (added in 7.54.1),
+Schannel (added in 7.58.1)
 
 sha256 support:
 
 OpenSSL, GnuTLS and wolfSSL (added in 7.44.0), mbedTLS (added in 7.47.0),
-Secure Transport macOS 10.7+/iOS 10+ (7.54.1), Schannel (7.58.1)
+Secure Transport macOS 10.7+/iOS 10+ (added in 7.54.1), Schannel
+(added in 7.58.1)
 
 Other SSL backends not supported.
diff --git a/docs/cmdline-opts/progress-bar.md b/docs/cmdline-opts/progress-bar.md
index 7b9c599b9..6f08d7f7c 100644
--- a/docs/cmdline-opts/progress-bar.md
+++ b/docs/cmdline-opts/progress-bar.md
@@ -4,7 +4,7 @@ SPDX-License-Identifier: curl
 Short: #
 Long: progress-bar
 Help: Display transfer progress as a bar
-Category: verbose
+Category: verbose global
 Added: 5.10
 Multi: boolean
 Scope: global
diff --git a/docs/cmdline-opts/proto-redir.md b/docs/cmdline-opts/proto-redir.md
index 51fb7bd3a..9332f3f0d 100644
--- a/docs/cmdline-opts/proto-redir.md
+++ b/docs/cmdline-opts/proto-redir.md
@@ -22,6 +22,6 @@ Example, allow only HTTP and HTTPS on redirect:
 
     curl --proto-redir -all,http,https http://example.com
 
-By default curl only allows HTTP, HTTPS, FTP and FTPS on redirects (added in
-7.65.2). Specifying *all* or *+all* enables all protocols on redirects, which
-is not good for security.
+By default curl only allows HTTP, HTTPS, FTP and FTPS on redirects
+(added in 7.65.2). Specifying *all* or *+all* enables all protocols on
+redirects, which is not good for security.
diff --git a/docs/cmdline-opts/proxy-ca-native.md b/docs/cmdline-opts/proxy-ca-native.md
index 6158b6cf6..fd78f12fb 100644
--- a/docs/cmdline-opts/proxy-ca-native.md
+++ b/docs/cmdline-opts/proxy-ca-native.md
@@ -12,7 +12,7 @@ See-also:
   - capath
   - insecure
 Example:
-  - --ca-native $URL
+  - --proxy-ca-native $URL
 ---
 
 # `--proxy-ca-native`
diff --git a/docs/cmdline-opts/proxy-cacert.md b/docs/cmdline-opts/proxy-cacert.md
index ec0dd9f14..189ed390d 100644
--- a/docs/cmdline-opts/proxy-cacert.md
+++ b/docs/cmdline-opts/proxy-cacert.md
@@ -18,4 +18,10 @@ Example:
 
 # `--proxy-cacert`
 
-Same as --cacert but used in HTTPS proxy context.
+Use the specified certificate file to verify the HTTPS proxy. The file may
+contain multiple CA certificates. The certificate(s) must be in PEM format.
+
+This allows you to use a different trust for the proxy compared to the remote
+server connected to via the proxy.
+
+Equivalent to --cacert but used in HTTPS proxy context.
diff --git a/docs/cmdline-opts/proxy-cert-type.md b/docs/cmdline-opts/proxy-cert-type.md
index 3f46bb618..c2e8ed1ec 100644
--- a/docs/cmdline-opts/proxy-cert-type.md
+++ b/docs/cmdline-opts/proxy-cert-type.md
@@ -9,10 +9,18 @@ Category: proxy tls
 Multi: single
 See-also:
   - proxy-cert
+  - proxy-key
 Example:
   - --proxy-cert-type PEM --proxy-cert file -x https://proxy $URL
 ---
 
 # `--proxy-cert-type`
 
-Same as --cert-type but used in HTTPS proxy context.
+Set type of the provided client certificate when using HTTPS proxy. PEM, DER,
+ENG and P12 are recognized types.
+
+The default type depends on the TLS backend and is usually PEM, however for
+Secure Transport and Schannel it is P12. If --proxy-cert is a pkcs11: URI then
+ENG is the default type.
+
+Equivalent to --cert-type but used in HTTPS proxy context.
diff --git a/docs/cmdline-opts/proxy-cert.md b/docs/cmdline-opts/proxy-cert.md
index 3068f3cd1..a588329d0 100644
--- a/docs/cmdline-opts/proxy-cert.md
+++ b/docs/cmdline-opts/proxy-cert.md
@@ -8,6 +8,8 @@ Added: 7.52.0
 Category: proxy tls
 Multi: single
 See-also:
+  - proxy
+  - proxy-key
   - proxy-cert-type
 Example:
   - --proxy-cert file -x https://proxy $URL
@@ -15,4 +17,10 @@ Example:
 
 # `--proxy-cert`
 
-Same as --cert but used in HTTPS proxy context.
+Use the specified client certificate file when communicating with an HTTPS
+proxy. The certificate must be in PKCS#12 format if using Secure Transport, or
+PEM format if using any other engine. If the optional password is not
+specified, it is queried for on the terminal. Use --proxy-key to provide the
+private key.
+
+This option is the equivalent to --cert but used in HTTPS proxy context.
diff --git a/docs/cmdline-opts/proxy-crlfile.md b/docs/cmdline-opts/proxy-crlfile.md
index ab47fb0a0..726e44955 100644
--- a/docs/cmdline-opts/proxy-crlfile.md
+++ b/docs/cmdline-opts/proxy-crlfile.md
@@ -16,4 +16,8 @@ Example:
 
 # `--proxy-crlfile`
 
-Same as --crlfile but used in HTTPS proxy context.
+Provide filename for a PEM formatted file with a Certificate Revocation List
+that specifies peer certificates that are considered revoked when
+communicating with an HTTPS proxy.
+
+Equivalent to --crlfile but only used in HTTPS proxy context.
diff --git a/docs/cmdline-opts/proxy-key-type.md b/docs/cmdline-opts/proxy-key-type.md
index 8740935b5..587c13c59 100644
--- a/docs/cmdline-opts/proxy-key-type.md
+++ b/docs/cmdline-opts/proxy-key-type.md
@@ -16,4 +16,7 @@ Example:
 
 # `--proxy-key-type`
 
-Same as --key-type but used in HTTPS proxy context.
+Specify the private key file type your --proxy-key provided private key uses.
+DER, PEM, and ENG are supported. If not specified, PEM is assumed.
+
+Equivalent to --key-type but used in HTTPS proxy context.
diff --git a/docs/cmdline-opts/proxy-key.md b/docs/cmdline-opts/proxy-key.md
index cfe507845..7caa636e3 100644
--- a/docs/cmdline-opts/proxy-key.md
+++ b/docs/cmdline-opts/proxy-key.md
@@ -16,4 +16,6 @@ Example:
 
 # `--proxy-key`
 
-Same as --key but used in HTTPS proxy context.
+Specify the filename for your private key when using client certificates with
+your HTTPS proxy. This option is the equivalent to --key but used in HTTPS
+proxy context.
diff --git a/docs/cmdline-opts/proxy-negotiate.md b/docs/cmdline-opts/proxy-negotiate.md
index 9bedf5dc4..0285155c6 100644
--- a/docs/cmdline-opts/proxy-negotiate.md
+++ b/docs/cmdline-opts/proxy-negotiate.md
@@ -9,6 +9,7 @@ Multi: mutex
 See-also:
   - proxy-anyauth
   - proxy-basic
+  - proxy-service-name
 Example:
   - --proxy-negotiate --proxy-user user:passwd -x proxy $URL
 ---
diff --git a/docs/cmdline-opts/proxy-ntlm.md b/docs/cmdline-opts/proxy-ntlm.md
index f8375a620..e403f98ec 100644
--- a/docs/cmdline-opts/proxy-ntlm.md
+++ b/docs/cmdline-opts/proxy-ntlm.md
@@ -9,6 +9,7 @@ Multi: mutex
 See-also:
   - proxy-negotiate
   - proxy-anyauth
+  - proxy-user
 Example:
   - --proxy-ntlm --proxy-user user:passwd -x http://proxy $URL
 ---
diff --git a/docs/cmdline-opts/proxy-pass.md b/docs/cmdline-opts/proxy-pass.md
index feba6e083..88cefd54c 100644
--- a/docs/cmdline-opts/proxy-pass.md
+++ b/docs/cmdline-opts/proxy-pass.md
@@ -3,7 +3,7 @@ c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
 Long: proxy-pass
 Arg: <phrase>
-Help: Pass phrase for the private key for HTTPS proxy
+Help: Passphrase for private key for HTTPS proxy
 Added: 7.52.0
 Category: proxy tls auth
 Multi: single
@@ -16,4 +16,6 @@ Example:
 
 # `--proxy-pass`
 
-Same as --pass but used in HTTPS proxy context.
+Passphrase for the private key for HTTPS proxy client certificate.
+
+Equivalent to --pass but used in HTTPS proxy context.
diff --git a/docs/cmdline-opts/proxy-service-name.md b/docs/cmdline-opts/proxy-service-name.md
index 534222f44..b3d665d8b 100644
--- a/docs/cmdline-opts/proxy-service-name.md
+++ b/docs/cmdline-opts/proxy-service-name.md
@@ -10,10 +10,11 @@ Multi: single
 See-also:
   - service-name
   - proxy
+  - proxy-negotiate
 Example:
   - --proxy-service-name "shrubbery" -x proxy $URL
 ---
 
 # `--proxy-service-name`
 
-Set the service name for proxy negotiation.
+Set the service name for SPNEGO when doing proxy authentication.
diff --git a/docs/cmdline-opts/proxy-ssl-allow-beast.md b/docs/cmdline-opts/proxy-ssl-allow-beast.md
index f2deedbb5..089038dec 100644
--- a/docs/cmdline-opts/proxy-ssl-allow-beast.md
+++ b/docs/cmdline-opts/proxy-ssl-allow-beast.md
@@ -2,7 +2,7 @@
 c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
 Long: proxy-ssl-allow-beast
-Help: Allow security flaw for interop for HTTPS proxy
+Help: Allow this security flaw for HTTPS proxy
 Added: 7.52.0
 Category: proxy tls
 Multi: boolean
@@ -15,4 +15,15 @@ Example:
 
 # `--proxy-ssl-allow-beast`
 
-Same as --ssl-allow-beast but used in HTTPS proxy context.
+Do not work around a security flaw in the TLS1.0 protocol known as BEAST when
+communicating to an HTTPS proxy. If this option is not used, the TLS layer may
+use workarounds known to cause interoperability problems with some older
+server implementations.
+
+This option only changes how curl does TLS 1.0 with an HTTPS proxy and has no
+effect on later TLS versions.
+
+**WARNING**: this option loosens the TLS security, and by using this flag you
+ask for exactly that.
+
+Equivalent to --ssl-allow-beast but used in HTTPS proxy context.
diff --git a/docs/cmdline-opts/proxy-tlsauthtype.md b/docs/cmdline-opts/proxy-tlsauthtype.md
index 067e4c598..684a7d55e 100644
--- a/docs/cmdline-opts/proxy-tlsauthtype.md
+++ b/docs/cmdline-opts/proxy-tlsauthtype.md
@@ -10,10 +10,15 @@ Multi: single
 See-also:
   - proxy
   - proxy-tlsuser
+  - proxy-tlspassword
 Example:
   - --proxy-tlsauthtype SRP -x https://proxy $URL
 ---
 
 # `--proxy-tlsauthtype`
 
-Same as --tlsauthtype but used in HTTPS proxy context.
+Set TLS authentication type with HTTPS proxy. The only supported option is
+`SRP`, for TLS-SRP (RFC 5054). This option works only if the underlying
+libcurl is built with TLS-SRP support.
+
+Equivalent to --tlsauthtype but used in HTTPS proxy context.
diff --git a/docs/cmdline-opts/proxy-tlspassword.md b/docs/cmdline-opts/proxy-tlspassword.md
index 3c6d06c6a..fe9ae7d2e 100644
--- a/docs/cmdline-opts/proxy-tlspassword.md
+++ b/docs/cmdline-opts/proxy-tlspassword.md
@@ -16,4 +16,10 @@ Example:
 
 # `--proxy-tlspassword`
 
-Same as --tlspassword but used in HTTPS proxy context.
+Set password to use with the TLS authentication method specified with
+--proxy-tlsauthtype when using HTTPS proxy. Requires that --proxy-tlsuser is
+set.
+
+This option does not work with TLS 1.3.
+
+Equivalent to --tlspassword but used in HTTPS proxy context.
diff --git a/docs/cmdline-opts/proxy-tlsuser.md b/docs/cmdline-opts/proxy-tlsuser.md
index 1c626ee75..351770111 100644
--- a/docs/cmdline-opts/proxy-tlsuser.md
+++ b/docs/cmdline-opts/proxy-tlsuser.md
@@ -16,4 +16,8 @@ Example:
 
 # `--proxy-tlsuser`
 
-Same as --tlsuser but used in HTTPS proxy context.
+Set username for use for HTTPS proxy with the TLS authentication method
+specified with --proxy-tlsauthtype. Requires that --proxy-tlspassword also is
+set.
+
+This option does not work with TLS 1.3.
diff --git a/docs/cmdline-opts/proxy-tlsv1.md b/docs/cmdline-opts/proxy-tlsv1.md
index 0dda72f4b..7b322e3a3 100644
--- a/docs/cmdline-opts/proxy-tlsv1.md
+++ b/docs/cmdline-opts/proxy-tlsv1.md
@@ -14,4 +14,7 @@ Example:
 
 # `--proxy-tlsv1`
 
-Same as --tlsv1 but used in HTTPS proxy context.
+Use at least TLS version 1.x when negotiating with an HTTPS proxy. That means
+TLS version 1.0 or higher
+
+Equivalent to --tlsv1 but for an HTTPS proxy context.
diff --git a/docs/cmdline-opts/pubkey.md b/docs/cmdline-opts/pubkey.md
index 94e50e4e9..373d113c3 100644
--- a/docs/cmdline-opts/pubkey.md
+++ b/docs/cmdline-opts/pubkey.md
@@ -5,7 +5,7 @@ Long: pubkey
 Arg: <key>
 Protocols: SFTP SCP
 Help: SSH Public key filename
-Category: sftp scp auth
+Category: sftp scp ssh auth
 Added: 7.16.2
 Multi: single
 See-also:
diff --git a/docs/cmdline-opts/random-file.md b/docs/cmdline-opts/random-file.md
index 0f564d9d7..e2c8624ab 100644
--- a/docs/cmdline-opts/random-file.md
+++ b/docs/cmdline-opts/random-file.md
@@ -4,7 +4,7 @@ SPDX-License-Identifier: curl
 Long: random-file
 Arg: <file>
 Help: File for reading random data from
-Category: misc
+Category: deprecated
 Added: 7.7
 Multi: single
 See-also:
diff --git a/docs/cmdline-opts/rate.md b/docs/cmdline-opts/rate.md
index fb2901e7e..49d0010b8 100644
--- a/docs/cmdline-opts/rate.md
+++ b/docs/cmdline-opts/rate.md
@@ -4,7 +4,7 @@ SPDX-License-Identifier: curl
 Long: rate
 Arg: <max request rate>
 Help: Request rate for serial transfers
-Category: connection
+Category: connection global
 Added: 7.84.0
 Multi: single
 Scope: global
diff --git a/docs/cmdline-opts/remote-name.md b/docs/cmdline-opts/remote-name.md
index 5d2fcdcb2..041800fa9 100644
--- a/docs/cmdline-opts/remote-name.md
+++ b/docs/cmdline-opts/remote-name.md
@@ -6,13 +6,14 @@ Short: O
 Help: Write output to file named as remote file
 Category: important output
 Added: 4.0
-Multi: append
+Multi: per-URL
 See-also:
   - remote-name-all
   - output-dir
   - remote-header-name
 Example:
   - -O https://example.com/filename
+  - -O https://example.com/filename -O https://example.com/file2
 ---
 
 # `--remote-name`
diff --git a/docs/cmdline-opts/remove-on-error.md b/docs/cmdline-opts/remove-on-error.md
index b0064ae31..4f9cf90de 100644
--- a/docs/cmdline-opts/remove-on-error.md
+++ b/docs/cmdline-opts/remove-on-error.md
@@ -3,7 +3,7 @@ c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
 Long: remove-on-error
 Help: Remove output file on errors
-Category: curl
+Category: output
 Added: 7.83.0
 Multi: boolean
 See-also:
diff --git a/docs/cmdline-opts/request.md b/docs/cmdline-opts/request.md
index 4a6304c1b..86cf10dea 100644
--- a/docs/cmdline-opts/request.md
+++ b/docs/cmdline-opts/request.md
@@ -5,7 +5,7 @@ Long: request
 Short: X
 Arg: <method>
 Help: Specify request method to use
-Category: connection
+Category: connection pop3 ftp imap smtp
 Added: 6.0
 Multi: single
 See-also:
@@ -19,7 +19,7 @@ Example:
 
 Change the method to use when starting the transfer.
 
-curl passes on the verbatim string you give it its the request without any
+curl passes on the verbatim string you give it in the request without any
 filter or other safe guards. That includes white space and control characters.
 
 ## HTTP
diff --git a/docs/cmdline-opts/resolve.md b/docs/cmdline-opts/resolve.md
index ca1f930fc..2b71d9a59 100644
--- a/docs/cmdline-opts/resolve.md
+++ b/docs/cmdline-opts/resolve.md
@@ -37,9 +37,8 @@ parallel transfers with a lot of files. In such cases, if this option is used
 curl tries to resolve the host as it normally would once the timeout has
 expired.
 
-Support for providing the IP address within [brackets] was added in 7.57.0.
-
-Support for providing multiple IP addresses per entry was added in 7.59.0.
+To redirect connects from a specific hostname or any hostname, independently
+of port number, consider the --connect-to option.
 
 Support for resolving with wildcard was added in 7.64.0.
 
diff --git a/docs/cmdline-opts/retry-delay.md b/docs/cmdline-opts/retry-delay.md
index b2a405b63..fcee1767a 100644
--- a/docs/cmdline-opts/retry-delay.md
+++ b/docs/cmdline-opts/retry-delay.md
@@ -5,7 +5,7 @@ Long: retry-delay
 Arg: <seconds>
 Help: Wait time between retries
 Added: 7.12.3
-Category: curl
+Category: curl timeout
 Multi: single
 See-also:
   - retry
diff --git a/docs/cmdline-opts/retry-max-time.md b/docs/cmdline-opts/retry-max-time.md
index f7346475b..e95a381a4 100644
--- a/docs/cmdline-opts/retry-max-time.md
+++ b/docs/cmdline-opts/retry-max-time.md
@@ -5,7 +5,7 @@ Long: retry-max-time
 Arg: <seconds>
 Help: Retry only within this period
 Added: 7.12.3
-Category: curl
+Category: curl timeout
 Multi: single
 See-also:
   - retry
diff --git a/docs/cmdline-opts/service-name.md b/docs/cmdline-opts/service-name.md
index b39bad4f1..f98409aa2 100644
--- a/docs/cmdline-opts/service-name.md
+++ b/docs/cmdline-opts/service-name.md
@@ -5,7 +5,7 @@ Long: service-name
 Help: SPNEGO service name
 Arg: <name>
 Added: 7.43.0
-Category: misc
+Category: auth
 Multi: single
 See-also:
   - negotiate
diff --git a/docs/cmdline-opts/show-error.md b/docs/cmdline-opts/show-error.md
index 0517c37bb..aaf865bc0 100644
--- a/docs/cmdline-opts/show-error.md
+++ b/docs/cmdline-opts/show-error.md
@@ -4,7 +4,7 @@ SPDX-License-Identifier: curl
 Long: show-error
 Short: S
 Help: Show error even when -s is used
-Category: curl
+Category: curl global
 Added: 5.9
 Multi: boolean
 Scope: global
diff --git a/docs/cmdline-opts/socks5.md b/docs/cmdline-opts/socks5.md
index f17dfeb71..192adef4a 100644
--- a/docs/cmdline-opts/socks5.md
+++ b/docs/cmdline-opts/socks5.md
@@ -33,4 +33,4 @@ used with an HTTP/HTTPS proxy (added in 7.52.0). In such a case, curl first
 connects to the SOCKS proxy and then connects (through SOCKS) to the HTTP or
 HTTPS proxy.
 
-This option (as well as --socks4) does not work with IPV6, FTPS or LDAP.
+This option does not work with FTPS or LDAP.
diff --git a/docs/cmdline-opts/speed-time.md b/docs/cmdline-opts/speed-time.md
index ef8759ee5..f27702bec 100644
--- a/docs/cmdline-opts/speed-time.md
+++ b/docs/cmdline-opts/speed-time.md
@@ -5,7 +5,7 @@ Long: speed-time
 Short: y
 Arg: <seconds>
 Help: Trigger 'speed-limit' abort after this time
-Category: connection
+Category: connection timeout
 Added: 4.7
 Multi: single
 See-also:
diff --git a/docs/cmdline-opts/ssl-allow-beast.md b/docs/cmdline-opts/ssl-allow-beast.md
index 29f2b450c..f9933b77a 100644
--- a/docs/cmdline-opts/ssl-allow-beast.md
+++ b/docs/cmdline-opts/ssl-allow-beast.md
@@ -16,9 +16,12 @@ Example:
 
 # `--ssl-allow-beast`
 
-Do not work around a security flaw in the SSL3 and TLS1.0 protocols known as
-BEAST. If this option is not used, the SSL layer may use workarounds known to
-cause interoperability problems with some older SSL implementations.
+Do not work around a security flaw in the TLS1.0 protocol known as BEAST. If
+this option is not used, the TLS layer may use workarounds known to cause
+interoperability problems with some older server implementations.
 
-**WARNING**: this option loosens the SSL security, and by using this flag you
+This option only changes how curl does TLS 1.0 and has no effect on later TLS
+versions.
+
+**WARNING**: this option loosens the TLS security, and by using this flag you
 ask for exactly that.
diff --git a/docs/cmdline-opts/ssl-reqd.md b/docs/cmdline-opts/ssl-reqd.md
index 63f77807a..f21c145f5 100644
--- a/docs/cmdline-opts/ssl-reqd.md
+++ b/docs/cmdline-opts/ssl-reqd.md
@@ -5,7 +5,7 @@ Long: ssl-reqd
 Help: Require SSL/TLS
 Protocols: FTP IMAP POP3 SMTP LDAP
 Added: 7.20.0
-Category: tls
+Category: tls imap pop3 smtp ldap
 Multi: boolean
 See-also:
   - ssl
diff --git a/docs/cmdline-opts/ssl.md b/docs/cmdline-opts/ssl.md
index c83332f22..0c0f28172 100644
--- a/docs/cmdline-opts/ssl.md
+++ b/docs/cmdline-opts/ssl.md
@@ -5,7 +5,7 @@ Long: ssl
 Help: Try enabling TLS
 Protocols: FTP IMAP POP3 SMTP LDAP
 Added: 7.20.0
-Category: tls
+Category: tls imap pop3 smtp ldap
 Multi: boolean
 See-also:
   - ssl-reqd
diff --git a/docs/cmdline-opts/sslv2.md b/docs/cmdline-opts/sslv2.md
index 3bd36f02c..ea92a2cb4 100644
--- a/docs/cmdline-opts/sslv2.md
+++ b/docs/cmdline-opts/sslv2.md
@@ -9,7 +9,7 @@ Added: 5.9
 Mutexed: sslv3 tlsv1 tlsv1.1 tlsv1.2
 Requires: TLS
 Help: SSLv2
-Category: tls
+Category: deprecated
 Multi: mutex
 See-also:
   - http1.1
diff --git a/docs/cmdline-opts/sslv3.md b/docs/cmdline-opts/sslv3.md
index 32d4c1206..f022124e1 100644
--- a/docs/cmdline-opts/sslv3.md
+++ b/docs/cmdline-opts/sslv3.md
@@ -9,7 +9,7 @@ Added: 5.9
 Mutexed: sslv2 tlsv1 tlsv1.1 tlsv1.2
 Requires: TLS
 Help: SSLv3
-Category: tls
+Category: deprecated
 Multi: mutex
 See-also:
   - http1.1
diff --git a/docs/cmdline-opts/stderr.md b/docs/cmdline-opts/stderr.md
index bb42497de..7030e557b 100644
--- a/docs/cmdline-opts/stderr.md
+++ b/docs/cmdline-opts/stderr.md
@@ -4,7 +4,7 @@ SPDX-License-Identifier: curl
 Long: stderr
 Arg: <file>
 Help: Where to redirect stderr
-Category: verbose
+Category: verbose global
 Added: 6.2
 Multi: single
 Scope: global
diff --git a/docs/cmdline-opts/styled-output.md b/docs/cmdline-opts/styled-output.md
index bb324532b..8193896c5 100644
--- a/docs/cmdline-opts/styled-output.md
+++ b/docs/cmdline-opts/styled-output.md
@@ -4,7 +4,7 @@ SPDX-License-Identifier: curl
 Long: styled-output
 Help: Enable styled output for HTTP headers
 Added: 7.61.0
-Category: verbose
+Category: verbose global
 Multi: boolean
 Scope: global
 See-also:
diff --git a/docs/cmdline-opts/tlspassword.md b/docs/cmdline-opts/tlspassword.md
index 4b1817994..6a1bb23a1 100644
--- a/docs/cmdline-opts/tlspassword.md
+++ b/docs/cmdline-opts/tlspassword.md
@@ -16,7 +16,7 @@ Example:
 
 # `--tlspassword`
 
-Set password for use with the TLS authentication method specified with
---tlsauthtype. Requires that --tlsuser also be set.
+Set password to use with the TLS authentication method specified with
+--tlsauthtype. Requires that --tlsuser is set.
 
 This option does not work with TLS 1.3.
diff --git a/docs/cmdline-opts/trace-ascii.md b/docs/cmdline-opts/trace-ascii.md
index 34f4d9f41..f46f0a6f3 100644
--- a/docs/cmdline-opts/trace-ascii.md
+++ b/docs/cmdline-opts/trace-ascii.md
@@ -5,7 +5,7 @@ Long: trace-ascii
 Arg: <file>
 Help: Like --trace, but without hex output
 Mutexed: trace verbose
-Category: verbose
+Category: verbose global
 Added: 7.9.7
 Multi: single
 Scope: global
@@ -20,7 +20,7 @@ Example:
 
 Save a full trace dump of all incoming and outgoing data, including
 descriptive information, in the given output file. Use `-` as filename to have
-the output sent to stdout.
+the output sent to stdout. Use `%` as filename to send the output to stderr.
 
 This is similar to --trace, but leaves out the hex part and only shows the
 ASCII part of the dump. It makes smaller output that might be easier to read
diff --git a/docs/cmdline-opts/trace-config.md b/docs/cmdline-opts/trace-config.md
index d7c7e0daa..2f095401d 100644
--- a/docs/cmdline-opts/trace-config.md
+++ b/docs/cmdline-opts/trace-config.md
@@ -4,7 +4,7 @@ SPDX-License-Identifier: curl
 Long: trace-config
 Arg: <string>
 Help: Details to log in trace/verbose output
-Category: verbose
+Category: verbose global
 Added: 8.3.0
 Multi: append
 Scope: global
diff --git a/docs/cmdline-opts/trace-ids.md b/docs/cmdline-opts/trace-ids.md
index bf54ecb34..dc7d61e7f 100644
--- a/docs/cmdline-opts/trace-ids.md
+++ b/docs/cmdline-opts/trace-ids.md
@@ -4,7 +4,7 @@ SPDX-License-Identifier: curl
 Long: trace-ids
 Help: Transfer + connection ids in verbose output
 Added: 8.2.0
-Category: verbose
+Category: verbose global
 Multi: boolean
 Scope: global
 See-also:
diff --git a/docs/cmdline-opts/trace-time.md b/docs/cmdline-opts/trace-time.md
index 79206ba9e..d3e0f47c1 100644
--- a/docs/cmdline-opts/trace-time.md
+++ b/docs/cmdline-opts/trace-time.md
@@ -4,7 +4,7 @@ SPDX-License-Identifier: curl
 Long: trace-time
 Help: Add time stamps to trace/verbose output
 Added: 7.14.0
-Category: verbose
+Category: verbose global
 Multi: boolean
 Scope: global
 See-also:
diff --git a/docs/cmdline-opts/trace.md b/docs/cmdline-opts/trace.md
index f6e3e4b55..875e756fd 100644
--- a/docs/cmdline-opts/trace.md
+++ b/docs/cmdline-opts/trace.md
@@ -5,7 +5,7 @@ Long: trace
 Arg: <file>
 Help: Write a debug trace to FILE
 Mutexed: verbose trace-ascii
-Category: verbose
+Category: verbose global
 Added: 7.9.7
 Multi: single
 Scope: global
@@ -21,8 +21,8 @@ Example:
 # `--trace`
 
 Save a full trace dump of all incoming and outgoing data, including
-descriptive information, in the given output file. Use "-" as filename to have
-the output sent to stdout. Use "%" as filename to have the output sent to
+descriptive information, in the given output file. Use `-` as filename to have
+the output sent to stdout. Use `%` as filename to have the output sent to
 stderr.
 
 Note that verbose output of curl activities and network traffic might contain
diff --git a/docs/cmdline-opts/upload-file.md b/docs/cmdline-opts/upload-file.md
index 74e7af302..7e9ffbf1e 100644
--- a/docs/cmdline-opts/upload-file.md
+++ b/docs/cmdline-opts/upload-file.md
@@ -7,7 +7,7 @@ Arg: <file>
 Help: Transfer local FILE to destination
 Category: important upload
 Added: 4.0
-Multi: append
+Multi: per-URL
 See-also:
   - get
   - head
@@ -17,6 +17,7 @@ Example:
   - -T file $URL
   - -T "img[1-1000].png" ftp://ftp.example.com/
   - --upload-file "{file1,file2}" $URL
+  - -T file -T file2 $URL $URL
 ---
 
 # `--upload-file`
diff --git a/docs/cmdline-opts/url.md b/docs/cmdline-opts/url.md
index c3680b641..851f0abac 100644
--- a/docs/cmdline-opts/url.md
+++ b/docs/cmdline-opts/url.md
@@ -22,8 +22,8 @@ If the given URL is missing a scheme name (such as `http://` or `ftp://` etc)
 then curl makes a guess based on the host. If the outermost subdomain name
 matches DICT, FTP, IMAP, LDAP, POP3 or SMTP then that protocol is used,
 otherwise HTTP is used. Guessing can be avoided by providing a full URL
-including the scheme, or disabled by setting a default protocol (added in
-7.45.0), see --proto-default for details.
+including the scheme, or disabled by setting a default protocol, see
+--proto-default for details.
 
 To control where this URL is written, use the --output or the --remote-name
 options.
diff --git a/docs/cmdline-opts/use-ascii.md b/docs/cmdline-opts/use-ascii.md
index 3586aa212..c452ffbb1 100644
--- a/docs/cmdline-opts/use-ascii.md
+++ b/docs/cmdline-opts/use-ascii.md
@@ -5,7 +5,7 @@ Short: B
 Long: use-ascii
 Help: Use ASCII/text transfer
 Protocols: FTP LDAP
-Category: misc
+Category: ftp output ldap
 Added: 5.0
 Multi: boolean
 See-also:
diff --git a/docs/cmdline-opts/variable.md b/docs/cmdline-opts/variable.md
index 9da1d3fee..9fe057236 100644
--- a/docs/cmdline-opts/variable.md
+++ b/docs/cmdline-opts/variable.md
@@ -10,7 +10,7 @@ Multi: append
 See-also:
   - config
 Example:
-  - --variable name=smith $URL
+  - --variable name=smith --expand-url "$URL/{{name}}"
 ---
 
 # `--variable`
diff --git a/docs/cmdline-opts/verbose.md b/docs/cmdline-opts/verbose.md
index 53096c546..9c42981ad 100644
--- a/docs/cmdline-opts/verbose.md
+++ b/docs/cmdline-opts/verbose.md
@@ -5,7 +5,7 @@ Short: v
 Long: verbose
 Mutexed: trace trace-ascii
 Help: Make the operation more talkative
-Category: important verbose
+Category: important verbose global
 Added: 4.0
 Multi: boolean
 Scope: global
diff --git a/docs/cmdline-opts/vlan-priority.md b/docs/cmdline-opts/vlan-priority.md
new file mode 100644
index 000000000..34dc8ce06
--- /dev/null
+++ b/docs/cmdline-opts/vlan-priority.md
@@ -0,0 +1,23 @@
+---
+c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+SPDX-License-Identifier: curl
+Long: vlan-priority
+Arg: <priority>
+Help: Set VLAN priority
+Added: 8.9.0
+Category: connection
+Protocols: All
+Multi: single
+See-also:
+  - ip-tos
+Example:
+  - --vlan-priority 4 $URL
+---
+
+# `--vlan-priority`
+
+Set VLAN priority as defined in IEEE 802.1Q.
+
+This field is set on Ethernet level, and only works within a local network.
+
+The valid range for \<priority\> is 0 to 7.
diff --git a/docs/cmdline-opts/write-out.md b/docs/cmdline-opts/write-out.md
index bb1422c99..acfb59dcc 100644
--- a/docs/cmdline-opts/write-out.md
+++ b/docs/cmdline-opts/write-out.md
@@ -63,6 +63,11 @@ The variables available are:
 Output the certificate chain with details. Supported only by the OpenSSL,
 GnuTLS, Schannel and Secure Transport backends. (Added in 7.88.0)
 
+## `conn_id`
+The connection identifier last used by the transfer. The connection id is
+unique number among all connections using the same connection cache.
+(Added in 8.2.0)
+
 ## `content_type`
 The Content-Type of the requested document, if there was any.
 
@@ -75,8 +80,8 @@ The numerical exit code of the transfer. (Added in 7.75.0)
 ## `filename_effective`
 The ultimate filename that curl writes out to. This is only meaningful if curl
 is told to write to a file with the --remote-name or --output option. It is
-most useful in combination with the --remote-header-name option. (Added in
-7.26.0)
+most useful in combination with the --remote-header-name option.
+(Added in 7.26.0)
 
 ## `ftp_entry_path`
 The initial path curl ended up in when logging on to the remote FTP
@@ -130,6 +135,10 @@ redirect). Note that the status line IS NOT a header. (Added in 7.73.0)
 ## `num_redirects`
 Number of redirects that were followed in the request. (Added in 7.12.3)
 
+## `num_retries`
+Number of retries actually performed when `--retry` has been used.
+(Added in 8.9.0)
+
 ## `onerror`
 The rest of the output is only shown if the transfer returned a non-zero error.
 (Added in 7.75.0)
@@ -305,3 +314,9 @@ same index number as the origin globbed URL. (Added in 7.75.0)
 ## `url_effective`
 The URL that was fetched last. This is most meaningful if you have told curl
 to follow location: headers.
+
+## `xfer_id`
+The numerical identifier of the last transfer done. -1 if no transfer has been
+started yet for the handle. The transfer id is unique among all transfers
+performed using the same connection cache.
+(Added in 8.2.0)
diff --git a/docs/cmdline-opts/xattr.md b/docs/cmdline-opts/xattr.md
index bfa74cf5a..9dd7dc585 100644
--- a/docs/cmdline-opts/xattr.md
+++ b/docs/cmdline-opts/xattr.md
@@ -3,7 +3,7 @@ c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
 Long: xattr
 Help: Store metadata in extended file attributes
-Category: misc
+Category: output
 Added: 7.21.3
 Multi: boolean
 See-also:
diff --git a/docs/curl-config.md b/docs/curl-config.md
index d82725082..4dfaab6ad 100644
--- a/docs/curl-config.md
+++ b/docs/curl-config.md
@@ -6,6 +6,7 @@ Section: 1
 Source: curl-config
 See-also:
   - curl (1)
+Added-in: 7.7.2
 ---
 
 # NAME
diff --git a/docs/examples/.gitignore b/docs/examples/.gitignore
index f9a2c7797..68f96939a 100644
--- a/docs/examples/.gitignore
+++ b/docs/examples/.gitignore
@@ -3,12 +3,15 @@
 # SPDX-License-Identifier: curl
 
 10-at-a-time
+address-scope
 altsvc
 anyauthput
 certinfo
 chkspeed
+connect-to
 cookie_interface
 debug
+default-scheme
 externalsocket
 fileupload
 fopen
@@ -20,10 +23,13 @@ ftpsget
 ftpupload
 ftpuploadfrommem
 ftpuploadresume
-getreferrer
 getinfo
 getinmemory
 getredirect
+getreferrer
+headerapi
+hsts-preload
+http-options
 http-post
 http2-download
 http2-pushinmemory
@@ -50,6 +56,11 @@ imap-search
 imap-ssl
 imap-store
 imap-tls
+interface
+ipv6
+keepalive
+localport
+maxconnects
 multi-app
 multi-debugcallback
 multi-double
@@ -58,6 +69,8 @@ multi-legacy
 multi-poll
 multi-post
 multi-single
+netrc
+new-gitignore
 parseurl
 persistent
 pop3-authzid
@@ -76,8 +89,11 @@ postinmemory
 postit2
 postit2-formadd
 progressfunc
+protofeats
+range
 resolve
 rtsp
+rtsp-options
 sendrecv
 sepheaders
 sftpget
@@ -95,7 +111,10 @@ smtp-ssl
 smtp-tls
 smtp-vrfy
 sslbackend
-urlapi
+unixsocket
 url2file
+urlapi
 usercertinmem
+websocket
+websocket-cb
 xmlstream
diff --git a/docs/examples/10-at-a-time.c b/docs/examples/10-at-a-time.c
index a622410fd..38a0f24ac 100644
--- a/docs/examples/10-at-a-time.c
+++ b/docs/examples/10-at-a-time.c
@@ -26,12 +26,8 @@
  * </DESC>
  */
 
-#include <errno.h>
 #include <stdlib.h>
 #include <string.h>
-#ifndef _WIN32
-#  include <unistd.h>
-#endif
 #include <curl/curl.h>
 
 static const char *urls[] = {
@@ -127,7 +123,8 @@ int main(void)
     int still_alive = 1;
     curl_multi_perform(cm, &still_alive);
 
-    while((msg = curl_multi_info_read(cm, &msgs_left))) {
+    /* !checksrc! disable EQUALSNULL 1 */
+    while((msg = curl_multi_info_read(cm, &msgs_left)) != NULL) {
       if(msg->msg == CURLMSG_DONE) {
         char *url;
         CURL *e = msg->easy_handle;
diff --git a/docs/examples/Makefile.example b/docs/examples/Makefile.example
index b10cdecf5..cfb59c94e 100644
--- a/docs/examples/Makefile.example
+++ b/docs/examples/Makefile.example
@@ -36,7 +36,7 @@ CFLAGS = -c -g
 
 # This should point to a directory that holds libcurl, if it is not
 # in the system's standard lib dir
-# We also set a -L to include the directory where we have the openssl
+# We also set a -L to include the directory where we have the OpenSSL
 # libraries
 LDFLAGS = -L/home/dast/lib -L/usr/local/ssl/lib
 
diff --git a/docs/examples/cookie_interface.c b/docs/examples/cookie_interface.c
index 0cc47cff7..2b11b4868 100644
--- a/docs/examples/cookie_interface.c
+++ b/docs/examples/cookie_interface.c
@@ -29,7 +29,6 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
-#include <errno.h>
 #include <time.h>
 
 #include <curl/curl.h>
diff --git a/docs/examples/externalsocket.c b/docs/examples/externalsocket.c
index 21e9a9c47..010654298 100644
--- a/docs/examples/externalsocket.c
+++ b/docs/examples/externalsocket.c
@@ -25,19 +25,24 @@
  * Pass in a custom socket for libcurl to use.
  * </DESC>
  */
+#ifdef _WIN32
+#ifndef _WINSOCK_DEPRECATED_NO_WARNINGS
+#define _WINSOCK_DEPRECATED_NO_WARNINGS  /* for inet_addr() */
+#endif
+#endif
+
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <curl/curl.h>
 
 #ifdef _WIN32
-#include <winsock2.h>
 #define close closesocket
 #else
 #include <sys/types.h>        /*  socket types              */
 #include <sys/socket.h>       /*  socket definitions        */
 #include <netinet/in.h>
-#include <arpa/inet.h>        /*  inet (3) functions         */
+#include <arpa/inet.h>        /*  inet (3) functions        */
 #include <unistd.h>           /*  misc. Unix functions      */
 #endif
 
diff --git a/docs/examples/http2-download.c b/docs/examples/http2-download.c
index c45a1c2d6..952b2cd4c 100644
--- a/docs/examples/http2-download.c
+++ b/docs/examples/http2-download.c
@@ -30,10 +30,6 @@
 #include <string.h>
 #include <errno.h>
 
-/* somewhat unix-specific */
-#include <sys/time.h>
-#include <unistd.h>
-
 /* curl stuff */
 #include <curl/curl.h>
 #include <curl/mprintf.h>
diff --git a/docs/examples/http2-pushinmemory.c b/docs/examples/http2-pushinmemory.c
index 74c64e0a6..53c368e01 100644
--- a/docs/examples/http2-pushinmemory.c
+++ b/docs/examples/http2-pushinmemory.c
@@ -29,10 +29,6 @@
 #include <stdlib.h>
 #include <string.h>
 
-/* somewhat unix-specific */
-#include <sys/time.h>
-#include <unistd.h>
-
 /* curl stuff */
 #include <curl/curl.h>
 
diff --git a/docs/examples/http2-serverpush.c b/docs/examples/http2-serverpush.c
index e830aa95d..29e266306 100644
--- a/docs/examples/http2-serverpush.c
+++ b/docs/examples/http2-serverpush.c
@@ -29,10 +29,6 @@
 #include <stdlib.h>
 #include <string.h>
 
-/* somewhat unix-specific */
-#include <sys/time.h>
-#include <unistd.h>
-
 /* curl stuff */
 #include <curl/curl.h>
 
diff --git a/docs/examples/http2-upload.c b/docs/examples/http2-upload.c
index 56d0c9825..4758a2fac 100644
--- a/docs/examples/http2-upload.c
+++ b/docs/examples/http2-upload.c
@@ -33,8 +33,10 @@
 #include <errno.h>
 
 /* somewhat unix-specific */
+#ifndef _MSC_VER
 #include <sys/time.h>
 #include <unistd.h>
+#endif
 
 /* curl stuff */
 #include <curl/curl.h>
@@ -49,6 +51,26 @@
 
 #define NUM_HANDLES 1000
 
+#ifdef _MSC_VER
+#define gettimeofday(a, b) my_gettimeofday((a), (b))
+int my_gettimeofday(struct timeval *tp, void *tzp)
+{
+  (void)tzp;
+  if(tp) {
+    /* Offset between 1601-01-01 and 1970-01-01 in 100 nanosec units */
+    #define _WIN32_FT_OFFSET (116444736000000000)
+    union {
+      CURL_TYPEOF_CURL_OFF_T ns100; /* time since 1 Jan 1601 in 100ns units */
+      FILETIME ft;
+    } _now;
+    GetSystemTimeAsFileTime(&_now.ft);
+    tp->tv_usec = (long)((_now.ns100 / 10) % 1000000);
+    tp->tv_sec = (long)((_now.ns100 - _WIN32_FT_OFFSET) / 10000000);
+  }
+  return 0;
+}
+#endif
+
 struct input {
   FILE *in;
   size_t bytes_read; /* count up */
diff --git a/docs/examples/keepalive.c b/docs/examples/keepalive.c
index 1c876bb1f..e06d7ff37 100644
--- a/docs/examples/keepalive.c
+++ b/docs/examples/keepalive.c
@@ -44,6 +44,9 @@ int main(void)
     /* interval time between keep-alive probes: 60 seconds */
     curl_easy_setopt(curl, CURLOPT_TCP_KEEPINTVL, 60L);
 
+    /* maximum number of keep-alive probes: 3 */
+    curl_easy_setopt(curl, CURLOPT_TCP_KEEPCNT, 3L);
+
     curl_easy_setopt(curl, CURLOPT_URL, "https://curl.se/");
 
     res = curl_easy_perform(curl);
diff --git a/docs/examples/multi-app.c b/docs/examples/multi-app.c
index 63918f182..87a23fb27 100644
--- a/docs/examples/multi-app.c
+++ b/docs/examples/multi-app.c
@@ -30,10 +30,6 @@
 #include <stdio.h>
 #include <string.h>
 
-/* somewhat unix-specific */
-#include <sys/time.h>
-#include <unistd.h>
-
 /* curl stuff */
 #include <curl/curl.h>
 
@@ -84,7 +80,8 @@ int main(void)
       break;
   }
   /* See how the transfers went */
-  while((msg = curl_multi_info_read(multi_handle, &msgs_left))) {
+  /* !checksrc! disable EQUALSNULL 1 */
+  while((msg = curl_multi_info_read(multi_handle, &msgs_left)) != NULL) {
     if(msg->msg == CURLMSG_DONE) {
       int idx;
 
diff --git a/docs/examples/multi-debugcallback.c b/docs/examples/multi-debugcallback.c
index 2feb214d5..a5be174da 100644
--- a/docs/examples/multi-debugcallback.c
+++ b/docs/examples/multi-debugcallback.c
@@ -29,10 +29,6 @@
 #include <stdio.h>
 #include <string.h>
 
-/* somewhat unix-specific */
-#include <sys/time.h>
-#include <unistd.h>
-
 /* curl stuff */
 #include <curl/curl.h>
 
diff --git a/docs/examples/multi-double.c b/docs/examples/multi-double.c
index 62295a92c..99bd736a9 100644
--- a/docs/examples/multi-double.c
+++ b/docs/examples/multi-double.c
@@ -28,10 +28,6 @@
 #include <stdio.h>
 #include <string.h>
 
-/* somewhat unix-specific */
-#include <sys/time.h>
-#include <unistd.h>
-
 /* curl stuff */
 #include <curl/curl.h>
 
diff --git a/docs/examples/multi-formadd.c b/docs/examples/multi-formadd.c
index 801b61e6d..6a927bba7 100644
--- a/docs/examples/multi-formadd.c
+++ b/docs/examples/multi-formadd.c
@@ -33,10 +33,14 @@
 
 #include <stdio.h>
 #include <string.h>
-#include <sys/time.h>
 
 #include <curl/curl.h>
 
+#ifdef __GNUC__
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+#endif
+
 int main(void)
 {
   CURL *curl;
@@ -113,3 +117,7 @@ int main(void)
   }
   return 0;
 }
+
+#ifdef __GNUC__
+#pragma GCC diagnostic pop
+#endif
diff --git a/docs/examples/multi-legacy.c b/docs/examples/multi-legacy.c
index 67575418e..4c1c760ef 100644
--- a/docs/examples/multi-legacy.c
+++ b/docs/examples/multi-legacy.c
@@ -31,8 +31,10 @@
 #include <string.h>
 
 /* somewhat unix-specific */
+#ifndef _WIN32
 #include <sys/time.h>
 #include <unistd.h>
+#endif
 
 /* curl stuff */
 #include <curl/curl.h>
@@ -147,7 +149,8 @@ int main(void)
   }
 
   /* See how the transfers went */
-  while((msg = curl_multi_info_read(multi_handle, &msgs_left))) {
+  /* !checksrc! disable EQUALSNULL 1 */
+  while((msg = curl_multi_info_read(multi_handle, &msgs_left)) != NULL) {
     if(msg->msg == CURLMSG_DONE) {
       int idx;
 
diff --git a/docs/examples/multi-post.c b/docs/examples/multi-post.c
index 112f3c0cd..84af48f4b 100644
--- a/docs/examples/multi-post.c
+++ b/docs/examples/multi-post.c
@@ -28,7 +28,6 @@
 
 #include <stdio.h>
 #include <string.h>
-#include <sys/time.h>
 
 #include <curl/curl.h>
 
diff --git a/docs/examples/multi-single.c b/docs/examples/multi-single.c
index f5077850b..0ead96f48 100644
--- a/docs/examples/multi-single.c
+++ b/docs/examples/multi-single.c
@@ -29,10 +29,6 @@
 #include <stdio.h>
 #include <string.h>
 
-/* somewhat unix-specific */
-#include <sys/time.h>
-#include <unistd.h>
-
 /* curl stuff */
 #include <curl/curl.h>
 
diff --git a/docs/examples/multi-uv.c b/docs/examples/multi-uv.c
index 3e967ccd8..27a073194 100644
--- a/docs/examples/multi-uv.c
+++ b/docs/examples/multi-uv.c
@@ -26,12 +26,12 @@
  * multi_socket API using libuv
  * </DESC>
  */
-/* Example application using the multi socket interface to download multiple
-   files in parallel, powered by libuv.
+/* Use the socket_action interface to download multiple files in parallel,
+   powered by libuv.
 
    Requires libuv and (of course) libcurl.
 
-   See https://nikhilm.github.io/uvbook/ for more information on libuv.
+   See https://docs.libuv.org/en/v1.x/index.html libuv API documentation
 */
 
 #include <stdio.h>
@@ -39,24 +39,30 @@
 #include <uv.h>
 #include <curl/curl.h>
 
-uv_loop_t *loop;
-CURLM *curl_handle;
-uv_timer_t timeout;
+/* object to pass to the callbacks */
+struct datauv {
+  uv_timer_t timeout;
+  uv_loop_t *loop;
+  CURLM *multi;
+};
 
 typedef struct curl_context_s {
   uv_poll_t poll_handle;
   curl_socket_t sockfd;
+  struct datauv *uv;
 } curl_context_t;
 
-static curl_context_t *create_curl_context(curl_socket_t sockfd)
+static curl_context_t *create_curl_context(curl_socket_t sockfd,
+                                           struct datauv *uv)
 {
   curl_context_t *context;
 
   context = (curl_context_t *) malloc(sizeof(*context));
 
   context->sockfd = sockfd;
+  context->uv = uv;
 
-  uv_poll_init_socket(loop, &context->poll_handle, sockfd);
+  uv_poll_init_socket(uv->loop, &context->poll_handle, sockfd);
   context->poll_handle.data = context;
 
   return context;
@@ -73,7 +79,7 @@ static void destroy_curl_context(curl_context_t *context)
   uv_close((uv_handle_t *) &context->poll_handle, curl_close_cb);
 }
 
-static void add_download(const char *url, int num)
+static void add_download(const char *url, int num, CURLM *multi)
 {
   char filename[50];
   FILE *file;
@@ -91,11 +97,11 @@ static void add_download(const char *url, int num)
   curl_easy_setopt(handle, CURLOPT_WRITEDATA, file);
   curl_easy_setopt(handle, CURLOPT_PRIVATE, file);
   curl_easy_setopt(handle, CURLOPT_URL, url);
-  curl_multi_add_handle(curl_handle, handle);
+  curl_multi_add_handle(multi, handle);
   fprintf(stderr, "Added download %s -> %s\n", url, filename);
 }
 
-static void check_multi_info(void)
+static void check_multi_info(curl_context_t *context)
 {
   char *done_url;
   CURLMsg *message;
@@ -103,7 +109,7 @@ static void check_multi_info(void)
   CURL *easy_handle;
   FILE *file;
 
-  while((message = curl_multi_info_read(curl_handle, &pending))) {
+  while((message = curl_multi_info_read(context->uv->multi, &pending))) {
     switch(message->msg) {
     case CURLMSG_DONE:
       /* Do not use message data after calling curl_multi_remove_handle() and
@@ -117,7 +123,7 @@ static void check_multi_info(void)
       curl_easy_getinfo(easy_handle, CURLINFO_PRIVATE, &file);
       printf("%s DONE\n", done_url);
 
-      curl_multi_remove_handle(curl_handle, easy_handle);
+      curl_multi_remove_handle(context->uv->multi, easy_handle);
       curl_easy_cleanup(easy_handle);
       if(file) {
         fclose(file);
@@ -131,73 +137,82 @@ static void check_multi_info(void)
   }
 }
 
-static void curl_perform(uv_poll_t *req, int status, int events)
+/* callback from libuv on socket activity */
+static void on_uv_socket(uv_poll_t *req, int status, int events)
 {
   int running_handles;
   int flags = 0;
-  curl_context_t *context;
-
+  curl_context_t *context = (curl_context_t *) req->data;
+  (void)status;
   if(events & UV_READABLE)
     flags |= CURL_CSELECT_IN;
   if(events & UV_WRITABLE)
     flags |= CURL_CSELECT_OUT;
 
-  context = (curl_context_t *) req->data;
-
-  curl_multi_socket_action(curl_handle, context->sockfd, flags,
+  curl_multi_socket_action(context->uv->multi, context->sockfd, flags,
                            &running_handles);
-
-  check_multi_info();
+  check_multi_info(context);
 }
 
-static void on_timeout(uv_timer_t *req)
+/* callback from libuv when timeout expires */
+static void on_uv_timeout(uv_timer_t *req)
 {
-  int running_handles;
-  curl_multi_socket_action(curl_handle, CURL_SOCKET_TIMEOUT, 0,
-                           &running_handles);
-  check_multi_info();
+  curl_context_t *context = (curl_context_t *) req->data;
+  if(context) {
+    int running_handles;
+    curl_multi_socket_action(context->uv->multi, CURL_SOCKET_TIMEOUT, 0,
+                             &running_handles);
+    check_multi_info(context);
+  }
 }
 
-static int start_timeout(CURLM *multi, long timeout_ms, void *userp)
+/* callback from libcurl to update the timeout expiry */
+static int cb_timeout(CURLM *multi, long timeout_ms,
+                      struct datauv *uv)
 {
-  if(timeout_ms < 0) {
-    uv_timer_stop(&timeout);
-  }
+  (void)multi;
+  if(timeout_ms < 0)
+    uv_timer_stop(&uv->timeout);
   else {
     if(timeout_ms == 0)
-      timeout_ms = 1; /* 0 means call socket_action asap */
-    uv_timer_start(&timeout, on_timeout, timeout_ms, 0);
+      timeout_ms = 1; /* 0 means call curl_multi_socket_action asap but NOT
+                         within the callback itself */
+    uv_timer_start(&uv->timeout, on_uv_timeout, timeout_ms,
+                   0); /* do not repeat */
   }
   return 0;
 }
 
-static int handle_socket(CURL *easy, curl_socket_t s, int action, void *userp,
-                  void *socketp)
+/* callback from libcurl to update socket activity to wait for */
+static int cb_socket(CURL *easy, curl_socket_t s, int action,
+                     struct datauv *uv,
+                     void *socketp)
 {
   curl_context_t *curl_context;
   int events = 0;
+  (void)easy;
 
   switch(action) {
   case CURL_POLL_IN:
   case CURL_POLL_OUT:
   case CURL_POLL_INOUT:
     curl_context = socketp ?
-      (curl_context_t *) socketp : create_curl_context(s);
+      (curl_context_t *) socketp : create_curl_context(s, uv);
 
-    curl_multi_assign(curl_handle, s, (void *) curl_context);
+    curl_multi_assign(uv->multi, s, (void *) curl_context);
 
     if(action != CURL_POLL_IN)
       events |= UV_WRITABLE;
     if(action != CURL_POLL_OUT)
       events |= UV_READABLE;
 
-    uv_poll_start(&curl_context->poll_handle, events, curl_perform);
+    uv_poll_start(&curl_context->poll_handle, events, on_uv_socket);
     break;
   case CURL_POLL_REMOVE:
     if(socketp) {
       uv_poll_stop(&((curl_context_t*)socketp)->poll_handle);
       destroy_curl_context((curl_context_t*) socketp);
-      curl_multi_assign(curl_handle, s, NULL);
+      curl_multi_assign(uv->multi, s, NULL);
     }
     break;
   default:
@@ -209,28 +224,31 @@ static int handle_socket(CURL *easy, curl_socket_t s, int action, void *userp,
 
 int main(int argc, char **argv)
 {
-  loop = uv_default_loop();
+  struct datauv uv = { 0 };
+  int running_handles;
 
   if(argc <= 1)
     return 0;
 
-  if(curl_global_init(CURL_GLOBAL_ALL)) {
-    fprintf(stderr, "Could not init curl\n");
-    return 1;
-  }
+  curl_global_init(CURL_GLOBAL_ALL);
 
-  uv_timer_init(loop, &timeout);
+  uv.loop = uv_default_loop();
+  uv_timer_init(uv.loop, &uv.timeout);
 
-  curl_handle = curl_multi_init();
-  curl_multi_setopt(curl_handle, CURLMOPT_SOCKETFUNCTION, handle_socket);
-  curl_multi_setopt(curl_handle, CURLMOPT_TIMERFUNCTION, start_timeout);
+  uv.multi = curl_multi_init();
+  curl_multi_setopt(uv.multi, CURLMOPT_SOCKETFUNCTION, cb_socket);
+  curl_multi_setopt(uv.multi, CURLMOPT_SOCKETDATA, &uv);
+  curl_multi_setopt(uv.multi, CURLMOPT_TIMERFUNCTION, cb_timeout);
+  curl_multi_setopt(uv.multi, CURLMOPT_TIMERDATA, &uv);
 
   while(argc-- > 1) {
-    add_download(argv[argc], argc);
+    add_download(argv[argc], argc, uv.multi);
   }
 
-  uv_run(loop, UV_RUN_DEFAULT);
-  curl_multi_cleanup(curl_handle);
+  /* kickstart the thing */
+  curl_multi_socket_action(uv.multi, CURL_SOCKET_TIMEOUT, 0, &running_handles);
+  uv_run(uv.loop, UV_RUN_DEFAULT);
+  curl_multi_cleanup(uv.multi);
 
   return 0;
 }
diff --git a/docs/examples/persistent.c b/docs/examples/persistent.c
index 4be7d6f2a..be5e8c33e 100644
--- a/docs/examples/persistent.c
+++ b/docs/examples/persistent.c
@@ -26,7 +26,7 @@
  * </DESC>
  */
 #include <stdio.h>
-#include <unistd.h>
+
 #include <curl/curl.h>
 
 int main(void)
diff --git a/docs/examples/postit2-formadd.c b/docs/examples/postit2-formadd.c
index 02e50aa3d..6000245b1 100644
--- a/docs/examples/postit2-formadd.c
+++ b/docs/examples/postit2-formadd.c
@@ -47,6 +47,11 @@
 
 #include <curl/curl.h>
 
+#ifdef __GNUC__
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+#endif
+
 int main(int argc, char *argv[])
 {
   CURL *curl;
@@ -110,3 +115,7 @@ int main(int argc, char *argv[])
   }
   return 0;
 }
+
+#ifdef __GNUC__
+#pragma GCC diagnostic pop
+#endif
diff --git a/docs/examples/sepheaders.c b/docs/examples/sepheaders.c
index 0d090ed81..31a320124 100644
--- a/docs/examples/sepheaders.c
+++ b/docs/examples/sepheaders.c
@@ -27,7 +27,6 @@
  */
 #include <stdio.h>
 #include <stdlib.h>
-#include <unistd.h>
 
 #include <curl/curl.h>
 
diff --git a/docs/examples/threaded-ssl.c b/docs/examples/threaded-ssl.c
index f58e44741..5f287460d 100644
--- a/docs/examples/threaded-ssl.c
+++ b/docs/examples/threaded-ssl.c
@@ -27,13 +27,13 @@
  * </DESC>
  */
 /* A multi-threaded example that uses pthreads and fetches 4 remote files at
- * once over HTTPS. The lock callbacks and stuff assume OpenSSL <1.1 or GnuTLS
- * (libgcrypt) so far.
+ * once over HTTPS.
  *
- * OpenSSL docs for this:
- *   https://www.openssl.org/docs/man1.0.2/man3/CRYPTO_num_locks.html
- * gcrypt docs for this:
- *   https://gnupg.org/documentation/manuals/gcrypt/Multi_002dThreading.html
+ * Recent versions of OpenSSL and GnuTLS are thread safe by design, assuming
+ * support for the underlying OS threading API is built-in. Older revisions
+ * of this example demonstrated locking callbacks for the SSL library, which
+ * are no longer necessary. An older revision with callbacks can be found at
+ * https://github.com/curl/curl/blob/curl-7_88_1/docs/examples/threaded-ssl.c
  */
 
 #define USE_OPENSSL /* or USE_GNUTLS accordingly */
@@ -44,71 +44,6 @@
 
 #define NUMT 4
 
-/* we have this global to let the callback get easy access to it */
-static pthread_mutex_t *lockarray;
-
-#ifdef USE_OPENSSL
-#include <openssl/crypto.h>
-static void lock_callback(int mode, int type, char *file, int line)
-{
-  (void)file;
-  (void)line;
-  if(mode & CRYPTO_LOCK) {
-    pthread_mutex_lock(&(lockarray[type]));
-  }
-  else {
-    pthread_mutex_unlock(&(lockarray[type]));
-  }
-}
-
-static unsigned long thread_id(void)
-{
-  unsigned long ret;
-
-  ret = (unsigned long)pthread_self();
-  return ret;
-}
-
-static void init_locks(void)
-{
-  int i;
-
-  lockarray = (pthread_mutex_t *)OPENSSL_malloc(CRYPTO_num_locks() *
-                                                sizeof(pthread_mutex_t));
-  for(i = 0; i<CRYPTO_num_locks(); i++) {
-    pthread_mutex_init(&(lockarray[i]), NULL);
-  }
-
-  CRYPTO_set_id_callback((unsigned long (*)())thread_id);
-  CRYPTO_set_locking_callback((void (*)())lock_callback);
-}
-
-static void kill_locks(void)
-{
-  int i;
-
-  CRYPTO_set_locking_callback(NULL);
-  for(i = 0; i<CRYPTO_num_locks(); i++)
-    pthread_mutex_destroy(&(lockarray[i]));
-
-  OPENSSL_free(lockarray);
-}
-#endif
-
-#ifdef USE_GNUTLS
-#include <gcrypt.h>
-#include <errno.h>
-
-GCRY_THREAD_OPTION_PTHREAD_IMPL;
-
-void init_locks(void)
-{
-  gcry_control(GCRYCTL_SET_THREAD_CBS);
-}
-
-#define kill_locks()
-#endif
-
 /* List of URLs to fetch.*/
 const char * const urls[]= {
   "https://www.example.com/",
@@ -143,8 +78,6 @@ int main(int argc, char **argv)
   /* Must initialize libcurl before any threads are started */
   curl_global_init(CURL_GLOBAL_ALL);
 
-  init_locks();
-
   for(i = 0; i< NUMT; i++) {
     int error = pthread_create(&tid[i],
                                NULL, /* default attributes please */
@@ -162,7 +95,5 @@ int main(int argc, char **argv)
     fprintf(stderr, "Thread %d terminated\n", i);
   }
 
-  kill_locks();
-
   return 0;
 }
diff --git a/docs/examples/url2file.c b/docs/examples/url2file.c
index f95d57464..9ed7da5a8 100644
--- a/docs/examples/url2file.c
+++ b/docs/examples/url2file.c
@@ -27,7 +27,6 @@
  */
 #include <stdio.h>
 #include <stdlib.h>
-#include <unistd.h>
 
 #include <curl/curl.h>
 
diff --git a/docs/examples/usercertinmem.c b/docs/examples/usercertinmem.c
index b35d98203..7b338cd98 100644
--- a/docs/examples/usercertinmem.c
+++ b/docs/examples/usercertinmem.c
@@ -157,7 +157,7 @@ static CURLcode sslctx_function(CURL *curl, void *sslctx, void *parm)
     printf("Use Key failed\n");
   }
 
-  /* free resources that have been allocated by openssl functions */
+  /* free resources that have been allocated by OpenSSL functions */
   if(bio)
     BIO_free(bio);
 
diff --git a/docs/examples/websocket.c b/docs/examples/websocket.c
index 4487b5009..996f2a024 100644
--- a/docs/examples/websocket.c
+++ b/docs/examples/websocket.c
@@ -27,7 +27,13 @@
  */
 #include <stdio.h>
 #include <string.h>
+#ifdef _WIN32
+#include <windows.h>
+#define sleep(s) Sleep((DWORD)(s))
+#else
 #include <unistd.h>
+#endif
+
 #include <curl/curl.h>
 
 static int ping(CURL *curl, const char *send_payload)
diff --git a/docs/examples/xmlstream.c b/docs/examples/xmlstream.c
index 76a8e48cc..d779e6e7c 100644
--- a/docs/examples/xmlstream.c
+++ b/docs/examples/xmlstream.c
@@ -36,7 +36,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <assert.h>
 
 #include <expat.h>
 #include <curl/curl.h>
diff --git a/docs/libcurl/curl_easy_cleanup.md b/docs/libcurl/curl_easy_cleanup.md
index e939dddc7..fc653e3a5 100644
--- a/docs/libcurl/curl_easy_cleanup.md
+++ b/docs/libcurl/curl_easy_cleanup.md
@@ -12,11 +12,12 @@ See-also:
   - curl_multi_remove_handle (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
 
-curl_easy_cleanup - End a libcurl easy handle
+curl_easy_cleanup - free an easy handle
 
 # SYNOPSIS
 
@@ -52,6 +53,8 @@ before it is closed.
 Passing in a NULL pointer in *handle* makes this function return immediately
 with no action.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -69,9 +72,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_duphandle.md b/docs/libcurl/curl_easy_duphandle.md
index 49d95ad98..45e738f30 100644
--- a/docs/libcurl/curl_easy_duphandle.md
+++ b/docs/libcurl/curl_easy_duphandle.md
@@ -11,11 +11,12 @@ See-also:
   - curl_global_init (3)
 Protocol:
   - All
+Added-in: 7.9
 ---
 
 # NAME
 
-curl_easy_duphandle - Clone a libcurl session handle
+curl_easy_duphandle - clone an easy handle
 
 # SYNOPSIS
 
@@ -46,6 +47,8 @@ data from the main filename to populate the cache.
 In multi-threaded programs, this function must be called in a synchronous way,
 the input handle may not be in use when cloned.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.9
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_escape.md b/docs/libcurl/curl_easy_escape.md
index dfe4bf5f3..b10500ac2 100644
--- a/docs/libcurl/curl_easy_escape.md
+++ b/docs/libcurl/curl_easy_escape.md
@@ -6,14 +6,16 @@ Section: 3
 Source: libcurl
 See-also:
   - curl_easy_unescape (3)
-  - curl_free (3)
+  - curl_url_set (3)
+  - curl_url_get (3)
 Protocol:
   - All
+Added-in: 7.15.4
 ---
 
 # NAME
 
-curl_easy_escape - URL encodes the given string
+curl_easy_escape - URL encode a string
 
 # SYNOPSIS
 
@@ -25,18 +27,14 @@ char *curl_easy_escape(CURL *curl, const char *string, int length);
 
 # DESCRIPTION
 
-This function converts the given input *string* to a URL encoded string
-and returns that as a new allocated string. All input characters that are not
-a-z, A-Z, 0-9, '-', '.', '_' or '~' are converted to their "URL escaped"
-version (**%NN** where **NN** is a two-digit hexadecimal number).
+This function converts the given input *string* to a URL encoded string and
+returns that as a new allocated string. All input characters that are not a-z,
+A-Z, 0-9, '-', '.', '_' or '~' are converted to their "URL escaped" version
+(**%NN** where **NN** is a two-digit hexadecimal number).
 
-If *length* is set to 0 (zero), curl_easy_escape(3) uses strlen() on
-the input *string* to find out the size. This function does not accept
-input strings longer than **CURL_MAX_INPUT_LENGTH** (8 MB).
-
-Since 7.82.0, the **curl** parameter is ignored. Prior to that there was
-per-handle character conversion support for some old operating systems such as
-TPF, but it was otherwise ignored.
+If *length* is set to 0 (zero), curl_easy_escape(3) uses strlen() on the input
+*string* to find out the size. This function does not accept input strings
+longer than **CURL_MAX_INPUT_LENGTH** (8 MB).
 
 You must curl_free(3) the returned string when you are done with it.
 
@@ -51,6 +49,19 @@ uses.
 The caller of curl_easy_escape(3) must make sure that the data passed in
 to the function is encoded correctly.
 
+# URLs
+
+URLs are by definition *URL encoded*. To create a proper URL from a set of
+components that may not be URL encoded already, you cannot just URL encode the
+entire URL string with curl_easy_escape(3), because it then also converts
+colons, slashes and other symbols that you probably want untouched.
+
+To create a proper URL from strings that are not already URL encoded, we
+recommend using libcurl's URL API: set the pieces with curl_url_set(3) and get
+the final correct URL with curl_url_get(3).
+
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -68,9 +79,13 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
+
+Since 7.82.0, the **curl** parameter is ignored. Prior to that there was
+per-handle character conversion support for some old operating systems such as
+TPF, but it was otherwise ignored.
 
-Added in 7.15.4 and replaces the old curl_escape(3) function.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_getinfo.md b/docs/libcurl/curl_easy_getinfo.md
index a4e4e4715..ce328d6c5 100644
--- a/docs/libcurl/curl_easy_getinfo.md
+++ b/docs/libcurl/curl_easy_getinfo.md
@@ -8,6 +8,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.4.1
 ---
 
 # NAME
@@ -33,362 +34,335 @@ performed transfer if you want to get transfer related data.
 You should not free the memory returned by this function unless it is
 explicitly mentioned below.
 
-# AVAILABLE INFORMATION
+# OPTIONS
 
 The following information can be extracted:
 
-## CURLINFO_EFFECTIVE_METHOD
+## CURLINFO_ACTIVESOCKET
 
-Last used HTTP method. See CURLINFO_EFFECTIVE_METHOD(3)
+The session's active socket. See CURLINFO_ACTIVESOCKET(3)
 
-## CURLINFO_EFFECTIVE_URL
+## CURLINFO_APPCONNECT_TIME
 
-Last used URL. See CURLINFO_EFFECTIVE_URL(3)
+The time it took from the start until the SSL connect/handshake with the
+remote host was completed as a double in number of seconds. (Added in 7.19.0)
 
-## CURLINFO_RESPONSE_CODE
+## CURLINFO_APPCONNECT_TIME_T
 
-Last received response code. See CURLINFO_RESPONSE_CODE(3)
+The time it took from the start until the SSL connect/handshake with the
+remote host was completed in number of microseconds. (Added in 7.60.0) See
+CURLINFO_APPCONNECT_TIME_T(3)
 
-## CURLINFO_REFERER
+## CURLINFO_CAINFO
 
-Referrer header. See CURLINFO_REFERER(3)
+Get the default value for CURLOPT_CAINFO(3). See CURLINFO_CAINFO(3)
 
-## CURLINFO_HTTP_CONNECTCODE
+## CURLINFO_CAPATH
 
-Last proxy CONNECT response code. See CURLINFO_HTTP_CONNECTCODE(3)
+Get the default value for CURLOPT_CAPATH(3). See CURLINFO_CAPATH(3)
 
-## CURLINFO_HTTP_VERSION
+## CURLINFO_CERTINFO
 
-The http version used in the connection. See CURLINFO_HTTP_VERSION(3)
+Certificate chain. See CURLINFO_CERTINFO(3)
 
-## CURLINFO_FILETIME
+## CURLINFO_CONDITION_UNMET
 
-Remote time of the retrieved document. See CURLINFO_FILETIME(3)
+Whether or not a time conditional was met or 304 HTTP response.
+See CURLINFO_CONDITION_UNMET(3)
 
-## CURLINFO_FILETIME_T
+## CURLINFO_CONNECT_TIME
 
-Remote time of the retrieved document. See CURLINFO_FILETIME_T(3)
+The time it took from the start until the connect to the remote host (or
+proxy) was completed. As a double. See CURLINFO_CONNECT_TIME(3)
 
-## CURLINFO_TOTAL_TIME
+## CURLINFO_CONNECT_TIME_T
 
-Total time of previous transfer. See CURLINFO_TOTAL_TIME(3)
+The time it took from the start until the connect to the remote host (or
+proxy) was completed. In microseconds. See CURLINFO_CONNECT_TIME_T(3).
 
-## CURLINFO_TOTAL_TIME_T
+## CURLINFO_CONN_ID
 
-Total time of previous transfer. See CURLINFO_TOTAL_TIME_T(3)
+The ID of the last connection used by the transfer. (Added in 8.2.0)
+See CURLINFO_CONN_ID(3)
 
-## CURLINFO_NAMELOOKUP_TIME
+## CURLINFO_CONTENT_LENGTH_DOWNLOAD
 
-Time from start until name resolving completed. See
-CURLINFO_NAMELOOKUP_TIME(3)
+(**Deprecated**) Content length from the Content-Length header.
+See CURLINFO_CONTENT_LENGTH_DOWNLOAD(3)
 
-## CURLINFO_NAMELOOKUP_TIME_T
+## CURLINFO_CONTENT_LENGTH_DOWNLOAD_T
 
-Time from start until name resolving completed. See
-CURLINFO_NAMELOOKUP_TIME_T(3)
+Content length from the Content-Length header.
+See CURLINFO_CONTENT_LENGTH_DOWNLOAD_T(3)
 
-## CURLINFO_CONNECT_TIME
+## CURLINFO_CONTENT_LENGTH_UPLOAD
 
-Time from start until remote host or proxy completed.
-See CURLINFO_CONNECT_TIME(3)
+(**Deprecated**) Upload size. See CURLINFO_CONTENT_LENGTH_UPLOAD(3)
 
-## CURLINFO_CONNECT_TIME_T
+## CURLINFO_CONTENT_LENGTH_UPLOAD_T
 
-Time from start until remote host or proxy completed.
-See CURLINFO_CONNECT_TIME_T(3)
+Upload size. See CURLINFO_CONTENT_LENGTH_UPLOAD_T(3)
 
-## CURLINFO_APPCONNECT_TIME
+## CURLINFO_CONTENT_TYPE
 
-Time from start until SSL/SSH handshake completed.
-See CURLINFO_APPCONNECT_TIME(3)
+Content type from the `Content-Type:` header. We recommend using
+curl_easy_header(3) instead. See CURLINFO_CONTENT_TYPE(3)
 
-## CURLINFO_APPCONNECT_TIME_T
+## CURLINFO_COOKIELIST
 
-Time from start until SSL/SSH handshake completed.
-See CURLINFO_APPCONNECT_TIME_T(3)
+List of all known cookies. See CURLINFO_COOKIELIST(3)
 
-## CURLINFO_PRETRANSFER_TIME
+## CURLINFO_EFFECTIVE_METHOD
 
-Time from start until just before the transfer begins.
-See CURLINFO_PRETRANSFER_TIME(3)
+Last used HTTP method. See CURLINFO_EFFECTIVE_METHOD(3)
 
-## CURLINFO_PRETRANSFER_TIME_T
+## CURLINFO_EFFECTIVE_URL
 
-Time from start until just before the transfer begins.
-See CURLINFO_PRETRANSFER_TIME_T(3)
+Last used URL. See CURLINFO_EFFECTIVE_URL(3)
 
-## CURLINFO_QUEUE_TIME_T
+## CURLINFO_FILETIME
 
-Time during which this transfer was held in a waiting queue.
-See CURLINFO_QUEUE_TIME_T(3)
+Remote time of the retrieved document. See CURLINFO_FILETIME(3)
 
-## CURLINFO_USED_PROXY
+## CURLINFO_FILETIME_T
 
-Whether the proxy was used (Added in 8.7.0). See CURLINFO_USED_PROXY(3)
+Remote time of the retrieved document. See CURLINFO_FILETIME_T(3)
 
-## CURLINFO_STARTTRANSFER_TIME
+## CURLINFO_FTP_ENTRY_PATH
 
-Time from start until just when the first byte is received.
-See CURLINFO_STARTTRANSFER_TIME(3)
+The entry path after logging in to an FTP server. See
+CURLINFO_FTP_ENTRY_PATH(3)
 
-## CURLINFO_STARTTRANSFER_TIME_T
+## CURLINFO_HEADER_SIZE
 
-Time from start until just when the first byte is received.
-See CURLINFO_STARTTRANSFER_TIME_T(3)
+Number of bytes of all headers received. See CURLINFO_HEADER_SIZE(3)
 
-## CURLINFO_REDIRECT_TIME
+## CURLINFO_HTTPAUTH_AVAIL
 
-Time taken for all redirect steps before the final transfer.
-See CURLINFO_REDIRECT_TIME(3)
+Available HTTP authentication methods. See CURLINFO_HTTPAUTH_AVAIL(3)
 
-## CURLINFO_REDIRECT_TIME_T
+## CURLINFO_HTTP_CONNECTCODE
 
-Time taken for all redirect steps before the final transfer.
-See CURLINFO_REDIRECT_TIME_T(3)
+Last proxy CONNECT response code. See CURLINFO_HTTP_CONNECTCODE(3)
 
-## CURLINFO_REDIRECT_COUNT
+## CURLINFO_HTTP_VERSION
 
-Total number of redirects that were followed.
-See CURLINFO_REDIRECT_COUNT(3)
+The http version used in the connection. See CURLINFO_HTTP_VERSION(3)
 
-## CURLINFO_REDIRECT_URL
+## CURLINFO_LASTSOCKET
 
-URL a redirect would take you to, had you enabled redirects.
-See CURLINFO_REDIRECT_URL(3)
+(**Deprecated**) Last socket used. See CURLINFO_LASTSOCKET(3)
 
-## CURLINFO_SIZE_UPLOAD
+## CURLINFO_LOCAL_IP
 
-(Deprecated) Number of bytes uploaded.
-See CURLINFO_SIZE_UPLOAD(3)
+Source IP address of the last connection. See CURLINFO_LOCAL_IP(3)
 
-## CURLINFO_SIZE_UPLOAD_T
+## CURLINFO_LOCAL_PORT
 
-Number of bytes uploaded.
-See CURLINFO_SIZE_UPLOAD_T(3)
+Source port number of the last connection. See CURLINFO_LOCAL_PORT(3)
 
-## CURLINFO_SIZE_DOWNLOAD
+## CURLINFO_NAMELOOKUP_TIME
 
-(Deprecated) Number of bytes downloaded.
-See CURLINFO_SIZE_DOWNLOAD(3)
+Time from start until name resolving completed as a double. See
+CURLINFO_NAMELOOKUP_TIME(3)
 
-## CURLINFO_SIZE_DOWNLOAD_T
+## CURLINFO_NAMELOOKUP_TIME_T
 
-Number of bytes downloaded.
-See CURLINFO_SIZE_DOWNLOAD_T(3)
+Time from start until name resolving completed in number of microseconds. See
+CURLINFO_NAMELOOKUP_TIME_T(3)
 
-## CURLINFO_SPEED_DOWNLOAD
+## CURLINFO_NUM_CONNECTS
 
-(Deprecated) Average download speed.
-See CURLINFO_SPEED_DOWNLOAD(3)
+Number of new successful connections used for previous transfer.
+See CURLINFO_NUM_CONNECTS(3)
 
-## CURLINFO_SPEED_DOWNLOAD_T
+## CURLINFO_OS_ERRNO
 
-Average download speed.
-See CURLINFO_SPEED_DOWNLOAD_T(3)
+The errno from the last failure to connect. See CURLINFO_OS_ERRNO(3)
 
-## CURLINFO_SPEED_UPLOAD
+## CURLINFO_PRETRANSFER_TIME
 
-(Deprecated) Average upload speed.
-See CURLINFO_SPEED_UPLOAD(3)
+The time it took from the start until the file transfer is just about to
+begin. This includes all pre-transfer commands and negotiations that are
+specific to the particular protocol(s) involved. See
+CURLINFO_PRETRANSFER_TIME(3)
 
-## CURLINFO_SPEED_UPLOAD_T
+## CURLINFO_PRETRANSFER_TIME_T
 
-Average upload speed.
-See CURLINFO_SPEED_UPLOAD_T(3)
+The time it took from the start until the file transfer is just about to
+begin. This includes all pre-transfer commands and negotiations that are
+specific to the particular protocol(s) involved. In microseconds. See
+CURLINFO_PRETRANSFER_TIME_T(3)
 
-## CURLINFO_HEADER_SIZE
+## CURLINFO_PRIMARY_IP
 
-Number of bytes of all headers received.
-See CURLINFO_HEADER_SIZE(3)
+Destination IP address of the last connection. See CURLINFO_PRIMARY_IP(3)
 
-## CURLINFO_REQUEST_SIZE
+## CURLINFO_PRIMARY_PORT
 
-Number of bytes sent in the issued HTTP requests.
-See CURLINFO_REQUEST_SIZE(3)
+Destination port of the last connection. See CURLINFO_PRIMARY_PORT(3)
 
-## CURLINFO_SSL_VERIFYRESULT
+## CURLINFO_PRIVATE
 
-Certificate verification result.
-See CURLINFO_SSL_VERIFYRESULT(3)
+User's private data pointer. See CURLINFO_PRIVATE(3)
 
-## CURLINFO_PROXY_ERROR
+## CURLINFO_PROTOCOL
 
-Detailed proxy error.
-See CURLINFO_PROXY_ERROR(3)
+(**Deprecated**) The protocol used for the connection. (Added in 7.52.0) See
+CURLINFO_PROTOCOL(3)
 
-## CURLINFO_PROXY_SSL_VERIFYRESULT
+## CURLINFO_PROXYAUTH_AVAIL
 
-Proxy certificate verification result.
-See CURLINFO_PROXY_SSL_VERIFYRESULT(3)
+Available HTTP proxy authentication methods. See CURLINFO_PROXYAUTH_AVAIL(3)
 
-## CURLINFO_SSL_ENGINES
+## CURLINFO_PROXY_ERROR
 
-A list of OpenSSL crypto engines.
-See CURLINFO_SSL_ENGINES(3)
+Detailed proxy error. See CURLINFO_PROXY_ERROR(3)
 
-## CURLINFO_CONTENT_LENGTH_DOWNLOAD
+## CURLINFO_PROXY_SSL_VERIFYRESULT
 
-(Deprecated) Content length from the Content-Length header.
-See CURLINFO_CONTENT_LENGTH_DOWNLOAD(3)
+Proxy certificate verification result. See CURLINFO_PROXY_SSL_VERIFYRESULT(3)
 
-## CURLINFO_CONTENT_LENGTH_DOWNLOAD_T
+## CURLINFO_QUEUE_TIME_T
 
-Content length from the Content-Length header.
-See CURLINFO_CONTENT_LENGTH_DOWNLOAD_T(3)
+The time during which the transfer was held in a waiting queue before it could
+start for real in number of microseconds. (Added in 8.6.0) See
+CURLINFO_QUEUE_TIME_T(3)
 
-## CURLINFO_CONTENT_LENGTH_UPLOAD
+## CURLINFO_REDIRECT_COUNT
 
-(Deprecated) Upload size. See CURLINFO_CONTENT_LENGTH_UPLOAD(3)
+Total number of redirects that were followed. See CURLINFO_REDIRECT_COUNT(3)
 
-## CURLINFO_CONTENT_LENGTH_UPLOAD_T
+## CURLINFO_REDIRECT_TIME
 
-Upload size. See CURLINFO_CONTENT_LENGTH_UPLOAD_T(3)
+The time it took for all redirection steps include name lookup, connect,
+pretransfer and transfer before final transaction was started. So, this is
+zero if no redirection took place. As a double. See CURLINFO_REDIRECT_TIME(3)
 
-## CURLINFO_CONTENT_TYPE
+## CURLINFO_REDIRECT_TIME_T
 
-Content type from the Content-Type header.
-See CURLINFO_CONTENT_TYPE(3)
+The time it took for all redirection steps include name lookup, connect,
+pretransfer and transfer before final transaction was started. So, this is
+zero if no redirection took place. In number of microseconds. See
+CURLINFO_REDIRECT_TIME_T(3)
 
-## CURLINFO_RETRY_AFTER
+## CURLINFO_REDIRECT_URL
 
-The value from the Retry-After header.
-See CURLINFO_RETRY_AFTER(3)
+URL a redirect would take you to, had you enabled redirects. See
+CURLINFO_REDIRECT_URL(3)
 
-## CURLINFO_PRIVATE
+## CURLINFO_REFERER
 
-User's private data pointer.
-See CURLINFO_PRIVATE(3)
+Referrer header. See CURLINFO_REFERER(3)
 
-## CURLINFO_HTTPAUTH_AVAIL
+## CURLINFO_REQUEST_SIZE
 
-Available HTTP authentication methods.
-See CURLINFO_HTTPAUTH_AVAIL(3)
+Number of bytes sent in the issued HTTP requests. See CURLINFO_REQUEST_SIZE(3)
 
-## CURLINFO_PROXYAUTH_AVAIL
+## CURLINFO_RESPONSE_CODE
 
-Available HTTP proxy authentication methods.
-See CURLINFO_PROXYAUTH_AVAIL(3)
+Last received response code. See CURLINFO_RESPONSE_CODE(3)
 
-## CURLINFO_OS_ERRNO
+## CURLINFO_RETRY_AFTER
 
-The errno from the last failure to connect.
-See CURLINFO_OS_ERRNO(3)
+The value from the Retry-After header. See CURLINFO_RETRY_AFTER(3)
 
-## CURLINFO_NUM_CONNECTS
+## CURLINFO_RTSP_CLIENT_CSEQ
 
-Number of new successful connections used for previous transfer.
-See CURLINFO_NUM_CONNECTS(3)
+The RTSP client CSeq that is expected next. See CURLINFO_RTSP_CLIENT_CSEQ(3)
 
-## CURLINFO_PRIMARY_IP
+## CURLINFO_RTSP_CSEQ_RECV
 
-Destination IP address of the last connection.
-See CURLINFO_PRIMARY_IP(3)
+RTSP CSeq last received. See CURLINFO_RTSP_CSEQ_RECV(3)
 
-## CURLINFO_PRIMARY_PORT
+## CURLINFO_RTSP_SERVER_CSEQ
 
-Destination port of the last connection.
-See CURLINFO_PRIMARY_PORT(3)
+The RTSP server CSeq that is expected next. See CURLINFO_RTSP_SERVER_CSEQ(3)
 
-## CURLINFO_LOCAL_IP
+## CURLINFO_RTSP_SESSION_ID
 
-Source IP address of the last connection.
-See CURLINFO_LOCAL_IP(3)
+RTSP session ID. See CURLINFO_RTSP_SESSION_ID(3)
 
-## CURLINFO_LOCAL_PORT
+## CURLINFO_SCHEME
 
-Source port number of the last connection.
-See CURLINFO_LOCAL_PORT(3)
+The scheme used for the connection. (Added in 7.52.0) See CURLINFO_SCHEME(3)
 
-## CURLINFO_COOKIELIST
+## CURLINFO_SIZE_DOWNLOAD
 
-List of all known cookies.
-See CURLINFO_COOKIELIST(3)
+(**Deprecated**) Number of bytes downloaded. See CURLINFO_SIZE_DOWNLOAD(3)
 
-## CURLINFO_LASTSOCKET
+## CURLINFO_SIZE_DOWNLOAD_T
 
-(Deprecated) Last socket used.
-See CURLINFO_LASTSOCKET(3)
+Number of bytes downloaded. See CURLINFO_SIZE_DOWNLOAD_T(3)
 
-## CURLINFO_ACTIVESOCKET
+## CURLINFO_SIZE_UPLOAD
 
-The session's active socket.
-See CURLINFO_ACTIVESOCKET(3)
+(**Deprecated**) Number of bytes uploaded. See CURLINFO_SIZE_UPLOAD(3)
 
-## CURLINFO_FTP_ENTRY_PATH
+## CURLINFO_SIZE_UPLOAD_T
 
-The entry path after logging in to an FTP server.
-See CURLINFO_FTP_ENTRY_PATH(3)
+Number of bytes uploaded. See CURLINFO_SIZE_UPLOAD_T(3)
 
-## CURLINFO_CAPATH
+## CURLINFO_SPEED_DOWNLOAD
 
-Get the default value for CURLOPT_CAPATH(3).
-See CURLINFO_CAPATH(3)
+(**Deprecated**) Average download speed. See CURLINFO_SPEED_DOWNLOAD(3)
 
-## CURLINFO_CAINFO
+## CURLINFO_SPEED_DOWNLOAD_T
 
-Get the default value for CURLOPT_CAINFO(3).
-See CURLINFO_CAINFO(3)
+Average download speed. See CURLINFO_SPEED_DOWNLOAD_T(3)
 
-## CURLINFO_CERTINFO
+## CURLINFO_SPEED_UPLOAD
 
-Certificate chain.
-See CURLINFO_CERTINFO(3)
+(**Deprecated**) Average upload speed. See CURLINFO_SPEED_UPLOAD(3)
 
-## CURLINFO_TLS_SSL_PTR
+## CURLINFO_SPEED_UPLOAD_T
 
-TLS session info that can be used for further processing.
-See CURLINFO_TLS_SSL_PTR(3)
+Average upload speed in number of bytes per second. See
+CURLINFO_SPEED_UPLOAD_T(3)
 
-## CURLINFO_TLS_SESSION
+## CURLINFO_SSL_ENGINES
 
-TLS session info that can be used for further processing. See
-CURLINFO_TLS_SESSION(3). Deprecated option, use
-CURLINFO_TLS_SSL_PTR(3) instead!
+A list of OpenSSL crypto engines. See CURLINFO_SSL_ENGINES(3)
 
-## CURLINFO_CONDITION_UNMET
+## CURLINFO_SSL_VERIFYRESULT
 
-Whether or not a time conditional was met or 304 HTTP response.
-See CURLINFO_CONDITION_UNMET(3)
+Certificate verification result. See CURLINFO_SSL_VERIFYRESULT(3)
 
-## CURLINFO_RTSP_SESSION_ID
+## CURLINFO_STARTTRANSFER_TIME
 
-RTSP session ID.
-See CURLINFO_RTSP_SESSION_ID(3)
+The time it took from the start until the first byte is received by libcurl.
+As a double. See CURLINFO_STARTTRANSFER_TIME(3)
 
-## CURLINFO_RTSP_CLIENT_CSEQ
+## CURLINFO_STARTTRANSFER_TIME_T
 
-The RTSP client CSeq that is expected next.
-See CURLINFO_RTSP_CLIENT_CSEQ(3)
+The time it took from the start until the first byte is received by libcurl.
+In microseconds. See CURLINFO_STARTTRANSFER_TIME_T(3)
 
-## CURLINFO_RTSP_SERVER_CSEQ
+## CURLINFO_TLS_SESSION
 
-The RTSP server CSeq that is expected next.
-See CURLINFO_RTSP_SERVER_CSEQ(3)
+(**Deprecated**) TLS session info that can be used for further processing. See
+CURLINFO_TLS_SESSION(3). Use CURLINFO_TLS_SSL_PTR(3) instead!
 
-## CURLINFO_RTSP_CSEQ_RECV
+## CURLINFO_TLS_SSL_PTR
 
-RTSP CSeq last received.
-See CURLINFO_RTSP_CSEQ_RECV(3)
+TLS session info that can be used for further processing. See
+CURLINFO_TLS_SSL_PTR(3)
 
-## CURLINFO_PROTOCOL
+## CURLINFO_TOTAL_TIME
 
-(Deprecated) The protocol used for the connection. (Added in 7.52.0)
-See CURLINFO_PROTOCOL(3)
+Total time of previous transfer. See CURLINFO_TOTAL_TIME(3)
 
-## CURLINFO_SCHEME
+## CURLINFO_TOTAL_TIME_T
 
-The scheme used for the connection. (Added in 7.52.0)
-See CURLINFO_SCHEME(3)
+Total time of previous transfer. See CURLINFO_TOTAL_TIME_T(3)
 
-## CURLINFO_CONN_ID
+## CURLINFO_USED_PROXY
 
-The ID of the last connection used by the transfer. (Added in 8.2.0)
-See CURLINFO_CONN_ID(3)
+Whether the proxy was used (Added in 8.7.0). See CURLINFO_USED_PROXY(3)
 
 ## CURLINFO_XFER_ID
 
-The ID of the transfer. (Added in 8.2.0)
-See CURLINFO_XFER_ID(3)
+The ID of the transfer. (Added in 8.2.0) See CURLINFO_XFER_ID(3)
 
 # TIMES
 
@@ -405,51 +379,13 @@ An overview of the time values available from curl_easy_getinfo(3)
         |--|--|--|--|--|--|--TOTAL
         |--|--|--|--|--|--|--REDIRECT
 
-## CURLINFO_QUEUE_TIME
-
-CURLINFO_QUEUE_TIME_T(3). The time during which the transfer was held in a
-waiting queue before it could start for real. (Added in 8.6.0)
-
-## CURLINFO_NAMELOOKUP_TIME
-
-CURLINFO_NAMELOOKUP_TIME(3) and CURLINFO_NAMELOOKUP_TIME_T(3). The time it
-took from the start until the name resolving was completed.
-
-## CURLINFO_CONNECT_TIME
-
-CURLINFO_CONNECT_TIME(3) and CURLINFO_CONNECT_TIME_T(3). The time it took from
-the start until the connect to the remote host (or proxy) was completed.
-
-## CURLINFO_APPCONNECT_TIME
-
-CURLINFO_APPCONNECT_TIME(3) and CURLINFO_APPCONNECT_TIME_T(3). The time it
-took from the start until the SSL connect/handshake with the remote host was
-completed. (Added in 7.19.0) The latter is the integer version (measuring
-microseconds). (Added in 7.60.0)
 
-## CURLINFO_PRETRANSFER_TIME
+ CURLINFO_QUEUE_TIME_T(3), CURLINFO_NAMELOOKUP_TIME_T(3),
+ CURLINFO_CONNECT_TIME_T(3), CURLINFO_APPCONNECT_TIME_T(3),
+ CURLINFO_PRETRANSFER_TIME_T(3), CURLINFO_STARTTRANSFER_TIME_T(3),
+ CURLINFO_TOTAL_TIME_T(3), CURLINFO_REDIRECT_TIME_T(3)
 
-CURLINFO_PRETRANSFER_TIME(3) and CURLINFO_PRETRANSFER_TIME_T(3). The time it
-took from the start until the file transfer is just about to begin. This
-includes all pre-transfer commands and negotiations that are specific to the
-particular protocol(s) involved.
-
-## CURLINFO_STARTTRANSFER_TIME
-
-CURLINFO_STARTTRANSFER_TIME(3) and CURLINFO_STARTTRANSFER_TIME_T(3). The time
-it took from the start until the first byte is received by libcurl.
-
-## CURLINFO_TOTAL_TIME
-
-CURLINFO_TOTAL_TIME(3) and CURLINFO_TOTAL_TIME_T(3). Total time
-of the previous request.
-
-## CURLINFO_REDIRECT_TIME
-
-CURLINFO_REDIRECT_TIME(3) and CURLINFO_REDIRECT_TIME_T(3). The time it took
-for all redirection steps include name lookup, connect, pretransfer and
-transfer before final transaction was started. So, this is zero if no
-redirection took place.
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -477,9 +413,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.4.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_header.md b/docs/libcurl/curl_easy_header.md
index 6bc743436..7a911116d 100644
--- a/docs/libcurl/curl_easy_header.md
+++ b/docs/libcurl/curl_easy_header.md
@@ -12,6 +12,7 @@ See-also:
   - libcurl-errors (3)
 Protocol:
   - HTTP
+Added-in: 7.83.0
 ---
 
 # NAME
@@ -136,6 +137,8 @@ response that might happen before the "real" response.
 
 The header is an HTTP/2 or HTTP/3 pseudo header
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -153,9 +156,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.83.0. Officially supported since 7.84.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_init.md b/docs/libcurl/curl_easy_init.md
index 9d282bdf3..3a5d2be41 100644
--- a/docs/libcurl/curl_easy_init.md
+++ b/docs/libcurl/curl_easy_init.md
@@ -13,11 +13,12 @@ See-also:
   - curl_multi_init (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
 
-curl_easy_init - Start a libcurl easy session
+curl_easy_init - create an easy handle
 
 # SYNOPSIS
 
@@ -42,14 +43,16 @@ all the options that were set in the source handle set in the new copy as
 well.
 
 If you did not already call curl_global_init(3) before calling this function,
-curl_easy_init(3) does it automatically. This may be lethal in multi-threaded
-cases, if curl_global_init(3) is not thread-safe in your system, and it may
+curl_easy_init(3) does it automatically. This can be lethal in multi-threaded
+cases for platforms where curl_global_init(3) is not thread-safe, and it may
 then result in resource problems because there is no corresponding cleanup.
 
 You are strongly advised to not allow this automatic behavior, by calling
 curl_global_init(3) yourself properly. See the description in libcurl(3) of
 global environment requirements for details of how to use this function.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -65,9 +68,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_nextheader.md b/docs/libcurl/curl_easy_nextheader.md
index 683a9d9d1..2dbdf61cc 100644
--- a/docs/libcurl/curl_easy_nextheader.md
+++ b/docs/libcurl/curl_easy_nextheader.md
@@ -9,6 +9,7 @@ See-also:
   - curl_easy_perform (3)
 Protocol:
   - HTTP
+Added-in: 7.83.0
 ---
 
 # NAME
@@ -60,6 +61,8 @@ The memory for the struct this points to, is owned and managed by libcurl and
 is associated with the easy handle. Applications must copy the data if they
 want it to survive subsequent API calls or the life-time of the easy handle.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -89,9 +92,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.83.0. Officially supported since 7.84.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_option_by_id.md b/docs/libcurl/curl_easy_option_by_id.md
index 697fc7e53..87cdeeb21 100644
--- a/docs/libcurl/curl_easy_option_by_id.md
+++ b/docs/libcurl/curl_easy_option_by_id.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.73.0
 ---
 
 # NAME
@@ -35,6 +36,8 @@ well.
 
 If libcurl has no option with the given id, this function returns NULL.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -47,9 +50,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-This function was added in libcurl 7.73.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_option_by_name.md b/docs/libcurl/curl_easy_option_by_name.md
index d03ff8b43..d237bd354 100644
--- a/docs/libcurl/curl_easy_option_by_name.md
+++ b/docs/libcurl/curl_easy_option_by_name.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.73.0
 ---
 
 # NAME
@@ -34,6 +35,8 @@ insensitive.
 
 If libcurl has no option with the given name, this function returns NULL.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -46,9 +49,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-This function was added in libcurl 7.73.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_option_next.md b/docs/libcurl/curl_easy_option_next.md
index 42f4409b6..836dee2d7 100644
--- a/docs/libcurl/curl_easy_option_next.md
+++ b/docs/libcurl/curl_easy_option_next.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.73.0
 ---
 
 # NAME
@@ -66,6 +67,8 @@ struct curl_easyoption {
 };
 ~~~
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -81,9 +84,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-This function was added in libcurl 7.73.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_pause.md b/docs/libcurl/curl_easy_pause.md
index 5794dc50c..fa8159acd 100644
--- a/docs/libcurl/curl_easy_pause.md
+++ b/docs/libcurl/curl_easy_pause.md
@@ -9,6 +9,7 @@ See-also:
   - curl_easy_reset (3)
 Protocol:
   - All
+Added-in: 7.18.0
 ---
 
 # NAME
@@ -97,6 +98,8 @@ buffering 32 megabyte of data for a paused stream.
 When such a paused stream is unpaused again, any buffered data is delivered
 first.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -131,9 +134,7 @@ size worth of data that curl cannot stop but instead needs to cache while the
 transfer is paused. This means that if a window size of 64 MB is used, libcurl
 might end up having to cache 64 MB of data.
 
-# AVAILABILITY
-
-Added in 7.18.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_perform.md b/docs/libcurl/curl_easy_perform.md
index b24ae50db..4c4c5668e 100644
--- a/docs/libcurl/curl_easy_perform.md
+++ b/docs/libcurl/curl_easy_perform.md
@@ -12,11 +12,12 @@ See-also:
   - libcurl-errors (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
 
-curl_easy_perform - perform a blocking file transfer
+curl_easy_perform - perform a blocking network transfer
 
 # SYNOPSIS
 
@@ -58,6 +59,8 @@ CURLOPT_POSTFIELDS(3).
 While the **easy_handle** is added to a multi handle, it cannot be used by
 curl_easy_perform(3).
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -73,9 +76,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_recv.md b/docs/libcurl/curl_easy_recv.md
index fa3c8f4c6..94491b63c 100644
--- a/docs/libcurl/curl_easy_recv.md
+++ b/docs/libcurl/curl_easy_recv.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.18.2
 ---
 
 # NAME
@@ -57,6 +58,8 @@ Furthermore if you wait on the socket and it tells you there is data to read,
 curl_easy_recv(3) may return **CURLE_AGAIN** if the only data that was
 read was for internal SSL processing, and no other data is available.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -85,9 +88,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.18.2.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_reset.md b/docs/libcurl/curl_easy_reset.md
index 1b09d12e7..3f4e7ae7f 100644
--- a/docs/libcurl/curl_easy_reset.md
+++ b/docs/libcurl/curl_easy_reset.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.12.1
 ---
 
 # NAME
@@ -35,6 +36,8 @@ It does not change the following information kept in the handle: live
 connections, the Session ID cache, the DNS cache, the cookies, the shares or
 the alt-svc cache.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -49,9 +52,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-This function was added in libcurl 7.12.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_send.md b/docs/libcurl/curl_easy_send.md
index ff51eca84..04d295a45 100644
--- a/docs/libcurl/curl_easy_send.md
+++ b/docs/libcurl/curl_easy_send.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.18.2
 ---
 
 # NAME
@@ -52,6 +53,8 @@ Furthermore if you wait on the socket and it tells you it is writable,
 curl_easy_send(3) may return **CURLE_AGAIN** if the only data that was sent
 was for internal SSL processing, and no other data could be sent.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -78,9 +81,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.18.2.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_setopt.md b/docs/libcurl/curl_easy_setopt.md
index b80d0b664..e9df2469b 100644
--- a/docs/libcurl/curl_easy_setopt.md
+++ b/docs/libcurl/curl_easy_setopt.md
@@ -15,6 +15,7 @@ See-also:
   - curl_multi_setopt (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -62,1030 +63,1046 @@ keep them available until libcurl no longer needed them.
 The *handle* is the return code from a curl_easy_init(3) or
 curl_easy_duphandle(3) call.
 
-# BEHAVIOR OPTIONS
+# OPTIONS
 
-## CURLOPT_VERBOSE
+## CURLOPT_ABSTRACT_UNIX_SOCKET
 
-Display verbose information. See CURLOPT_VERBOSE(3)
+Path to an abstract Unix domain socket. See CURLOPT_ABSTRACT_UNIX_SOCKET(3)
 
-## CURLOPT_HEADER
+## CURLOPT_ACCEPTTIMEOUT_MS
 
-Include the header in the body output. See CURLOPT_HEADER(3)
+Timeout for waiting for the server's connect back to be accepted. See
+CURLOPT_ACCEPTTIMEOUT_MS(3)
 
-## CURLOPT_NOPROGRESS
+## CURLOPT_ACCEPT_ENCODING
 
-Shut off the progress meter. See CURLOPT_NOPROGRESS(3)
+Accept-Encoding and automatic decompressing data. See
+CURLOPT_ACCEPT_ENCODING(3)
 
-## CURLOPT_NOSIGNAL
+## CURLOPT_ADDRESS_SCOPE
 
-Do not install signal handlers. See CURLOPT_NOSIGNAL(3)
+IPv6 scope for local addresses. See CURLOPT_ADDRESS_SCOPE(3)
 
-## CURLOPT_WILDCARDMATCH
+## CURLOPT_ALTSVC
 
-Transfer multiple files according to a filename pattern. See
-CURLOPT_WILDCARDMATCH(3)
+Specify the Alt-Svc: cache filename. See CURLOPT_ALTSVC(3)
 
-# CALLBACK OPTIONS
+## CURLOPT_ALTSVC_CTRL
 
-## CURLOPT_WRITEFUNCTION
+Enable and configure Alt-Svc: treatment. See CURLOPT_ALTSVC_CTRL(3)
 
-Callback for writing data. See CURLOPT_WRITEFUNCTION(3)
+## CURLOPT_APPEND
 
-## CURLOPT_WRITEDATA
+Append to remote file. See CURLOPT_APPEND(3)
 
-Data pointer to pass to the write callback. See CURLOPT_WRITEDATA(3)
+## CURLOPT_AUTOREFERER
 
-## CURLOPT_READFUNCTION
+Automatically set Referer: header. See CURLOPT_AUTOREFERER(3)
 
-Callback for reading data. See CURLOPT_READFUNCTION(3)
+## CURLOPT_AWS_SIGV4
 
-## CURLOPT_READDATA
+AWS HTTP V4 Signature. See CURLOPT_AWS_SIGV4(3)
 
-Data pointer to pass to the read callback. See CURLOPT_READDATA(3)
+## CURLOPT_BUFFERSIZE
 
-## CURLOPT_IOCTLFUNCTION
+Ask for alternate buffer size. See CURLOPT_BUFFERSIZE(3)
 
-**Deprecated option** Callback for I/O operations.
-See CURLOPT_IOCTLFUNCTION(3)
+## CURLOPT_CAINFO
 
-## CURLOPT_IOCTLDATA
+CA cert bundle. See CURLOPT_CAINFO(3)
 
-**Deprecated option** Data pointer to pass to the I/O callback.
-See CURLOPT_IOCTLDATA(3)
+## CURLOPT_CAINFO_BLOB
 
-## CURLOPT_SEEKFUNCTION
+CA cert bundle memory buffer. See CURLOPT_CAINFO_BLOB(3)
 
-Callback for seek operations. See CURLOPT_SEEKFUNCTION(3)
+## CURLOPT_CAPATH
 
-## CURLOPT_SEEKDATA
+Path to CA cert bundle. See CURLOPT_CAPATH(3)
 
-Data pointer to pass to the seek callback. See CURLOPT_SEEKDATA(3)
+## CURLOPT_CA_CACHE_TIMEOUT
 
-## CURLOPT_SOCKOPTFUNCTION
+Timeout for CA cache. See CURLOPT_CA_CACHE_TIMEOUT(3)
 
-Callback for sockopt operations. See CURLOPT_SOCKOPTFUNCTION(3)
+## CURLOPT_CERTINFO
 
-## CURLOPT_SOCKOPTDATA
+Extract certificate info. See CURLOPT_CERTINFO(3)
 
-Data pointer to pass to the sockopt callback. See CURLOPT_SOCKOPTDATA(3)
+## CURLOPT_CHUNK_BGN_FUNCTION
 
-## CURLOPT_OPENSOCKETFUNCTION
+Callback for wildcard download start of chunk. See
+CURLOPT_CHUNK_BGN_FUNCTION(3)
 
-Callback for socket creation. See CURLOPT_OPENSOCKETFUNCTION(3)
+## CURLOPT_CHUNK_DATA
 
-## CURLOPT_OPENSOCKETDATA
+Data pointer to pass to the chunk callbacks. See CURLOPT_CHUNK_DATA(3)
 
-Data pointer to pass to the open socket callback. See CURLOPT_OPENSOCKETDATA(3)
+## CURLOPT_CHUNK_END_FUNCTION
+
+Callback for wildcard download end of chunk. See CURLOPT_CHUNK_END_FUNCTION(3)
+
+## CURLOPT_CLOSESOCKETDATA
+
+Data pointer to pass to the close socket callback. See
+CURLOPT_CLOSESOCKETDATA(3)
 
 ## CURLOPT_CLOSESOCKETFUNCTION
 
 Callback for closing socket. See CURLOPT_CLOSESOCKETFUNCTION(3)
 
-## CURLOPT_CLOSESOCKETDATA
+## CURLOPT_CONNECTTIMEOUT
 
-Data pointer to pass to the close socket callback. See CURLOPT_CLOSESOCKETDATA(3)
+Timeout for the connection phase. See CURLOPT_CONNECTTIMEOUT(3)
 
-## CURLOPT_PROGRESSFUNCTION
+## CURLOPT_CONNECTTIMEOUT_MS
 
-**OBSOLETE** callback for progress meter.
-See CURLOPT_PROGRESSFUNCTION(3)
+Millisecond timeout for the connection phase. See CURLOPT_CONNECTTIMEOUT_MS(3)
 
-## CURLOPT_PROGRESSDATA
+## CURLOPT_CONNECT_ONLY
 
-Data pointer to pass to the progress meter callback. See CURLOPT_PROGRESSDATA(3)
+Only connect, nothing else. See CURLOPT_CONNECT_ONLY(3)
 
-## CURLOPT_XFERINFOFUNCTION
+## CURLOPT_CONNECT_TO
 
-Callback for progress meter. See CURLOPT_XFERINFOFUNCTION(3)
+Connect to a specific host and port. See CURLOPT_CONNECT_TO(3)
 
-## CURLOPT_XFERINFODATA
+## CURLOPT_CONV_FROM_NETWORK_FUNCTION
 
-Data pointer to pass to the progress meter callback. See CURLOPT_XFERINFODATA(3)
+**OBSOLETE** Callback for code base conversion.
+See CURLOPT_CONV_FROM_NETWORK_FUNCTION(3)
 
-## CURLOPT_HEADERFUNCTION
+## CURLOPT_CONV_FROM_UTF8_FUNCTION
 
-Callback for writing received headers. See CURLOPT_HEADERFUNCTION(3)
+**OBSOLETE** Callback for code base conversion.
+See CURLOPT_CONV_FROM_UTF8_FUNCTION(3)
 
-## CURLOPT_HEADERDATA
+## CURLOPT_CONV_TO_NETWORK_FUNCTION
 
-Data pointer to pass to the header callback. See CURLOPT_HEADERDATA(3)
+**OBSOLETE** Callback for code base conversion.
+See CURLOPT_CONV_TO_NETWORK_FUNCTION(3)
 
-## CURLOPT_DEBUGFUNCTION
+## CURLOPT_COOKIE
 
-Callback for debug information. See CURLOPT_DEBUGFUNCTION(3)
+Cookie(s) to send. See CURLOPT_COOKIE(3)
 
-## CURLOPT_DEBUGDATA
+## CURLOPT_COOKIEFILE
 
-Data pointer to pass to the debug callback. See CURLOPT_DEBUGDATA(3)
+File to read cookies from. See CURLOPT_COOKIEFILE(3)
 
-## CURLOPT_SSL_CTX_FUNCTION
+## CURLOPT_COOKIEJAR
 
-Callback for SSL context logic. See CURLOPT_SSL_CTX_FUNCTION(3)
+File to write cookies to. See CURLOPT_COOKIEJAR(3)
 
-## CURLOPT_SSL_CTX_DATA
+## CURLOPT_COOKIELIST
 
-Data pointer to pass to the SSL context callback. See CURLOPT_SSL_CTX_DATA(3)
+Add or control cookies. See CURLOPT_COOKIELIST(3)
 
-## CURLOPT_CONV_TO_NETWORK_FUNCTION
+## CURLOPT_COOKIESESSION
 
-**OBSOLETE** Callback for code base conversion.
-See CURLOPT_CONV_TO_NETWORK_FUNCTION(3)
+Start a new cookie session. See CURLOPT_COOKIESESSION(3)
 
-## CURLOPT_CONV_FROM_NETWORK_FUNCTION
+## CURLOPT_COPYPOSTFIELDS
 
-**OBSOLETE** Callback for code base conversion.
-See CURLOPT_CONV_FROM_NETWORK_FUNCTION(3)
+Send a POST with this data - and copy it. See CURLOPT_COPYPOSTFIELDS(3)
 
-## CURLOPT_CONV_FROM_UTF8_FUNCTION
+## CURLOPT_CRLF
 
-**OBSOLETE** Callback for code base conversion.
-See CURLOPT_CONV_FROM_UTF8_FUNCTION(3)
+Convert newlines. See CURLOPT_CRLF(3)
 
-## CURLOPT_INTERLEAVEFUNCTION
+## CURLOPT_CRLFILE
 
-Callback for RTSP interleaved data. See CURLOPT_INTERLEAVEFUNCTION(3)
+Certificate Revocation List. See CURLOPT_CRLFILE(3)
 
-## CURLOPT_INTERLEAVEDATA
+## CURLOPT_CURLU
 
-Data pointer to pass to the RTSP interleave callback. See CURLOPT_INTERLEAVEDATA(3)
+Set URL to work on with a URL handle. See CURLOPT_CURLU(3)
 
-## CURLOPT_CHUNK_BGN_FUNCTION
+## CURLOPT_CUSTOMREQUEST
 
-Callback for wildcard download start of chunk. See CURLOPT_CHUNK_BGN_FUNCTION(3)
+Custom request/method. See CURLOPT_CUSTOMREQUEST(3)
 
-## CURLOPT_CHUNK_END_FUNCTION
+## CURLOPT_DEBUGDATA
 
-Callback for wildcard download end of chunk. See CURLOPT_CHUNK_END_FUNCTION(3)
+Data pointer to pass to the debug callback. See CURLOPT_DEBUGDATA(3)
 
-## CURLOPT_CHUNK_DATA
+## CURLOPT_DEBUGFUNCTION
 
-Data pointer to pass to the chunk callbacks. See CURLOPT_CHUNK_DATA(3)
+Callback for debug information. See CURLOPT_DEBUGFUNCTION(3)
 
-## CURLOPT_FNMATCH_FUNCTION
+## CURLOPT_DEFAULT_PROTOCOL
 
-Callback for wildcard matching. See CURLOPT_FNMATCH_FUNCTION(3)
+Default protocol. See CURLOPT_DEFAULT_PROTOCOL(3)
 
-## CURLOPT_FNMATCH_DATA
+## CURLOPT_DIRLISTONLY
 
-Data pointer to pass to the wildcard matching callback. See CURLOPT_FNMATCH_DATA(3)
+List only. See CURLOPT_DIRLISTONLY(3)
 
-## CURLOPT_SUPPRESS_CONNECT_HEADERS
+## CURLOPT_DISALLOW_USERNAME_IN_URL
 
-Suppress proxy CONNECT response headers from user callbacks. See
-CURLOPT_SUPPRESS_CONNECT_HEADERS(3)
+Do not allow username in URL. See CURLOPT_DISALLOW_USERNAME_IN_URL(3)
 
-## CURLOPT_RESOLVER_START_FUNCTION
+## CURLOPT_DNS_CACHE_TIMEOUT
 
-Callback to be called before a new resolve request is started. See
-CURLOPT_RESOLVER_START_FUNCTION(3)
+Timeout for DNS cache. See CURLOPT_DNS_CACHE_TIMEOUT(3)
 
-## CURLOPT_RESOLVER_START_DATA
+## CURLOPT_DNS_INTERFACE
 
-Data pointer to pass to resolver start callback. See CURLOPT_RESOLVER_START_DATA(3)
+Bind name resolves to this interface. See CURLOPT_DNS_INTERFACE(3)
 
-## CURLOPT_PREREQFUNCTION
+## CURLOPT_DNS_LOCAL_IP4
 
-Callback to be called after a connection is established but before a request
-is made on that connection. See CURLOPT_PREREQFUNCTION(3)
+Bind name resolves to this IP4 address. See CURLOPT_DNS_LOCAL_IP4(3)
 
-## CURLOPT_PREREQDATA
+## CURLOPT_DNS_LOCAL_IP6
 
-Data pointer to pass to the CURLOPT_PREREQFUNCTION callback. See
-CURLOPT_PREREQDATA(3)
+Bind name resolves to this IP6 address. See CURLOPT_DNS_LOCAL_IP6(3)
 
-# ERROR OPTIONS
+## CURLOPT_DNS_SERVERS
 
-## CURLOPT_ERRORBUFFER
+Preferred DNS servers. See CURLOPT_DNS_SERVERS(3)
 
-Error message buffer. See CURLOPT_ERRORBUFFER(3)
+## CURLOPT_DNS_SHUFFLE_ADDRESSES
 
-## CURLOPT_STDERR
+Shuffle addresses before use. See CURLOPT_DNS_SHUFFLE_ADDRESSES(3)
 
-stderr replacement stream. See CURLOPT_STDERR(3)
+## CURLOPT_DNS_USE_GLOBAL_CACHE
 
-## CURLOPT_FAILONERROR
+**OBSOLETE** Enable global DNS cache. See CURLOPT_DNS_USE_GLOBAL_CACHE(3)
 
-Fail on HTTP 4xx errors. CURLOPT_FAILONERROR(3)
+## CURLOPT_DOH_SSL_VERIFYHOST
 
-## CURLOPT_KEEP_SENDING_ON_ERROR
+Verify the hostname in the DoH (DNS-over-HTTPS) SSL certificate. See
+CURLOPT_DOH_SSL_VERIFYHOST(3)
 
-Keep sending on HTTP \>= 300 errors. CURLOPT_KEEP_SENDING_ON_ERROR(3)
+## CURLOPT_DOH_SSL_VERIFYPEER
 
-# NETWORK OPTIONS
+Verify the DoH (DNS-over-HTTPS) SSL certificate. See
+CURLOPT_DOH_SSL_VERIFYPEER(3)
 
-## CURLOPT_URL
+## CURLOPT_DOH_SSL_VERIFYSTATUS
 
-URL to work on. See CURLOPT_URL(3)
+Verify the DoH (DNS-over-HTTPS) SSL certificate's status. See
+CURLOPT_DOH_SSL_VERIFYSTATUS(3)
 
-## CURLOPT_PATH_AS_IS
+## CURLOPT_DOH_URL
 
-Disable squashing /../ and /./ sequences in the path. See CURLOPT_PATH_AS_IS(3)
+Use this DoH server for name resolves. See CURLOPT_DOH_URL(3)
 
-## CURLOPT_PROTOCOLS
+## CURLOPT_ECH
 
-**Deprecated option** Allowed protocols. See CURLOPT_PROTOCOLS(3)
+Set the configuration for ECH. See CURLOPT_ECH(3)
 
-## CURLOPT_PROTOCOLS_STR
+## CURLOPT_EGDSOCKET
 
-Allowed protocols. See CURLOPT_PROTOCOLS_STR(3)
+**OBSOLETE** Identify EGD socket for entropy. See CURLOPT_EGDSOCKET(3)
 
-## CURLOPT_REDIR_PROTOCOLS
+## CURLOPT_ERRORBUFFER
 
-**Deprecated option** Protocols to allow redirects to. See
-CURLOPT_REDIR_PROTOCOLS(3)
+Error message buffer. See CURLOPT_ERRORBUFFER(3)
 
-## CURLOPT_REDIR_PROTOCOLS_STR
+## CURLOPT_EXPECT_100_TIMEOUT_MS
 
-Protocols to allow redirects to. See CURLOPT_REDIR_PROTOCOLS_STR(3)
+100-continue timeout. See CURLOPT_EXPECT_100_TIMEOUT_MS(3)
 
-## CURLOPT_DEFAULT_PROTOCOL
+## CURLOPT_FAILONERROR
 
-Default protocol. See CURLOPT_DEFAULT_PROTOCOL(3)
+Fail on HTTP 4xx errors. CURLOPT_FAILONERROR(3)
 
-## CURLOPT_PROXY
+## CURLOPT_FILETIME
 
-Proxy to use. See CURLOPT_PROXY(3)
+Request file modification date and time. See CURLOPT_FILETIME(3)
 
-## CURLOPT_PRE_PROXY
+## CURLOPT_FNMATCH_DATA
 
-Socks proxy to use. See CURLOPT_PRE_PROXY(3)
+Data pointer to pass to the wildcard matching callback. See
+CURLOPT_FNMATCH_DATA(3)
 
-## CURLOPT_PROXYPORT
+## CURLOPT_FNMATCH_FUNCTION
 
-Proxy port to use. See CURLOPT_PROXYPORT(3)
+Callback for wildcard matching. See CURLOPT_FNMATCH_FUNCTION(3)
 
-## CURLOPT_PROXYTYPE
+## CURLOPT_FOLLOWLOCATION
 
-Proxy type. See CURLOPT_PROXYTYPE(3)
+Follow HTTP redirects. See CURLOPT_FOLLOWLOCATION(3)
 
-## CURLOPT_NOPROXY
+## CURLOPT_FORBID_REUSE
 
-Filter out hosts from proxy use. CURLOPT_NOPROXY(3)
+Prevent subsequent connections from reusing this. See CURLOPT_FORBID_REUSE(3)
 
-## CURLOPT_HTTPPROXYTUNNEL
+## CURLOPT_FRESH_CONNECT
 
-Tunnel through the HTTP proxy. CURLOPT_HTTPPROXYTUNNEL(3)
+Use a new connection. CURLOPT_FRESH_CONNECT(3)
 
-## CURLOPT_CONNECT_TO
+## CURLOPT_FTPPORT
 
-Connect to a specific host and port. See CURLOPT_CONNECT_TO(3)
+Use active FTP. See CURLOPT_FTPPORT(3)
 
-## CURLOPT_SOCKS5_AUTH
+## CURLOPT_FTPSSLAUTH
 
-Socks5 authentication methods. See CURLOPT_SOCKS5_AUTH(3)
+Control how to do TLS. See CURLOPT_FTPSSLAUTH(3)
 
-## CURLOPT_SOCKS5_GSSAPI_SERVICE
+## CURLOPT_FTP_ACCOUNT
 
-**Deprecated option** Socks5 GSSAPI service name.
-See CURLOPT_SOCKS5_GSSAPI_SERVICE(3)
+Send ACCT command. See CURLOPT_FTP_ACCOUNT(3)
 
-## CURLOPT_SOCKS5_GSSAPI_NEC
+## CURLOPT_FTP_ALTERNATIVE_TO_USER
 
-Socks5 GSSAPI NEC mode. See CURLOPT_SOCKS5_GSSAPI_NEC(3)
+Alternative to USER. See CURLOPT_FTP_ALTERNATIVE_TO_USER(3)
 
-## CURLOPT_PROXY_SERVICE_NAME
+## CURLOPT_FTP_CREATE_MISSING_DIRS
 
-Proxy authentication service name. CURLOPT_PROXY_SERVICE_NAME(3)
+Create missing directories on the remote server. See
+CURLOPT_FTP_CREATE_MISSING_DIRS(3)
 
-## CURLOPT_HAPROXYPROTOCOL
+## CURLOPT_FTP_FILEMETHOD
 
-Send an HAProxy PROXY protocol v1 header. See CURLOPT_HAPROXYPROTOCOL(3)
+Specify how to reach files. See CURLOPT_FTP_FILEMETHOD(3)
 
-## CURLOPT_HAPROXY_CLIENT_IP
+## CURLOPT_FTP_SKIP_PASV_IP
 
-Spoof the client IP in an HAProxy PROXY protocol v1 header. See
-CURLOPT_HAPROXY_CLIENT_IP(3)
+Ignore the IP address in the PASV response. See CURLOPT_FTP_SKIP_PASV_IP(3)
 
-## CURLOPT_SERVICE_NAME
+## CURLOPT_FTP_SSL_CCC
 
-Authentication service name. CURLOPT_SERVICE_NAME(3)
+Back to non-TLS again after authentication. See CURLOPT_FTP_SSL_CCC(3)
 
-## CURLOPT_INTERFACE
+## CURLOPT_FTP_USE_EPRT
 
-Bind connection locally to this. See CURLOPT_INTERFACE(3)
+Use EPRT. See CURLOPT_FTP_USE_EPRT(3)
 
-## CURLOPT_LOCALPORT
+## CURLOPT_FTP_USE_EPSV
 
-Bind connection locally to this port. See CURLOPT_LOCALPORT(3)
+Use EPSV. See CURLOPT_FTP_USE_EPSV(3)
 
-## CURLOPT_LOCALPORTRANGE
+## CURLOPT_FTP_USE_PRET
 
-Bind connection locally to port range. See CURLOPT_LOCALPORTRANGE(3)
+Use PRET. See CURLOPT_FTP_USE_PRET(3)
 
-## CURLOPT_DNS_CACHE_TIMEOUT
+## CURLOPT_GSSAPI_DELEGATION
 
-Timeout for DNS cache. See CURLOPT_DNS_CACHE_TIMEOUT(3)
+Disable GSS-API delegation. See CURLOPT_GSSAPI_DELEGATION(3)
 
-## CURLOPT_DNS_USE_GLOBAL_CACHE
+## CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS
 
-**OBSOLETE** Enable global DNS cache.
-See CURLOPT_DNS_USE_GLOBAL_CACHE(3)
+Timeout for happy eyeballs. See CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS(3)
 
-## CURLOPT_DOH_URL
+## CURLOPT_HAPROXYPROTOCOL
 
-Use this DoH server for name resolves. See CURLOPT_DOH_URL(3)
+Send an HAProxy PROXY protocol v1 header. See CURLOPT_HAPROXYPROTOCOL(3)
 
-## CURLOPT_BUFFERSIZE
+## CURLOPT_HAPROXY_CLIENT_IP
 
-Ask for alternate buffer size. See CURLOPT_BUFFERSIZE(3)
+Spoof the client IP in an HAProxy PROXY protocol v1 header. See
+CURLOPT_HAPROXY_CLIENT_IP(3)
 
-## CURLOPT_PORT
+## CURLOPT_HEADER
 
-Port number to connect to. See CURLOPT_PORT(3)
+Include the header in the body output. See CURLOPT_HEADER(3)
 
-## CURLOPT_TCP_FASTOPEN
+## CURLOPT_HEADERDATA
 
-Enable TCP Fast Open. See CURLOPT_TCP_FASTOPEN(3)
+Data pointer to pass to the header callback. See CURLOPT_HEADERDATA(3)
 
-## CURLOPT_TCP_NODELAY
+## CURLOPT_HEADERFUNCTION
 
-Disable the Nagle algorithm. See CURLOPT_TCP_NODELAY(3)
+Callback for writing received headers. See CURLOPT_HEADERFUNCTION(3)
 
-## CURLOPT_ADDRESS_SCOPE
+## CURLOPT_HEADEROPT
 
-IPv6 scope for local addresses. See CURLOPT_ADDRESS_SCOPE(3)
+Control custom headers. See CURLOPT_HEADEROPT(3)
 
-## CURLOPT_TCP_KEEPALIVE
+## CURLOPT_HSTS
 
-Enable TCP keep-alive. See CURLOPT_TCP_KEEPALIVE(3)
+Set HSTS cache file. See CURLOPT_HSTS(3)
 
-## CURLOPT_TCP_KEEPIDLE
+## CURLOPT_HSTSREADDATA
 
-Idle time before sending keep-alive. See CURLOPT_TCP_KEEPIDLE(3)
+Pass pointer to the HSTS read callback. See CURLOPT_HSTSREADDATA(3)
 
-## CURLOPT_TCP_KEEPINTVL
+## CURLOPT_HSTSREADFUNCTION
 
-Interval between keep-alive probes. See CURLOPT_TCP_KEEPINTVL(3)
+Set HSTS read callback. See CURLOPT_HSTSREADFUNCTION(3)
 
-## CURLOPT_UNIX_SOCKET_PATH
+## CURLOPT_HSTSWRITEDATA
 
-Path to a Unix domain socket. See CURLOPT_UNIX_SOCKET_PATH(3)
+Pass pointer to the HSTS write callback. See CURLOPT_HSTSWRITEDATA(3)
 
-## CURLOPT_ABSTRACT_UNIX_SOCKET
+## CURLOPT_HSTSWRITEFUNCTION
 
-Path to an abstract Unix domain socket. See CURLOPT_ABSTRACT_UNIX_SOCKET(3)
+Set HSTS write callback. See CURLOPT_HSTSWRITEFUNCTION(3)
 
-# NAMES and PASSWORDS OPTIONS (Authentication)
+## CURLOPT_HSTS_CTRL
 
-## CURLOPT_NETRC
+Enable HSTS. See CURLOPT_HSTS_CTRL(3)
 
-Enable .netrc parsing. See CURLOPT_NETRC(3)
+## CURLOPT_HTTP09_ALLOWED
 
-## CURLOPT_NETRC_FILE
+Allow HTTP/0.9 responses. CURLOPT_HTTP09_ALLOWED(3)
 
-.netrc filename. See CURLOPT_NETRC_FILE(3)
+## CURLOPT_HTTP200ALIASES
 
-## CURLOPT_USERPWD
+Alternative versions of 200 OK. See CURLOPT_HTTP200ALIASES(3)
 
-Username and password. See CURLOPT_USERPWD(3)
+## CURLOPT_HTTPAUTH
 
-## CURLOPT_PROXYUSERPWD
+HTTP server authentication methods. See CURLOPT_HTTPAUTH(3)
 
-Proxy username and password. See CURLOPT_PROXYUSERPWD(3)
+## CURLOPT_HTTPGET
 
-## CURLOPT_USERNAME
+Do an HTTP GET request. See CURLOPT_HTTPGET(3)
 
-Username. See CURLOPT_USERNAME(3)
+## CURLOPT_HTTPHEADER
 
-## CURLOPT_PASSWORD
+Custom HTTP headers. See CURLOPT_HTTPHEADER(3)
 
-Password. See CURLOPT_PASSWORD(3)
+## CURLOPT_HTTPPOST
 
-## CURLOPT_LOGIN_OPTIONS
+**Deprecated option** Multipart formpost HTTP POST.
+See CURLOPT_HTTPPOST(3)
 
-Login options. See CURLOPT_LOGIN_OPTIONS(3)
+## CURLOPT_HTTPPROXYTUNNEL
 
-## CURLOPT_PROXYUSERNAME
+Tunnel through the HTTP proxy. CURLOPT_HTTPPROXYTUNNEL(3)
 
-Proxy username. See CURLOPT_PROXYUSERNAME(3)
+## CURLOPT_HTTP_CONTENT_DECODING
 
-## CURLOPT_PROXYPASSWORD
+Disable Content decoding. See CURLOPT_HTTP_CONTENT_DECODING(3)
 
-Proxy password. See CURLOPT_PROXYPASSWORD(3)
+## CURLOPT_HTTP_TRANSFER_DECODING
 
-## CURLOPT_HTTPAUTH
+Disable Transfer decoding. See CURLOPT_HTTP_TRANSFER_DECODING(3)
 
-HTTP server authentication methods. See CURLOPT_HTTPAUTH(3)
+## CURLOPT_HTTP_VERSION
 
-## CURLOPT_TLSAUTH_USERNAME
+HTTP version to use. CURLOPT_HTTP_VERSION(3)
 
-TLS authentication username. See CURLOPT_TLSAUTH_USERNAME(3)
+## CURLOPT_IGNORE_CONTENT_LENGTH
 
-## CURLOPT_PROXY_TLSAUTH_USERNAME
+Ignore Content-Length. See CURLOPT_IGNORE_CONTENT_LENGTH(3)
 
-Proxy TLS authentication username. See CURLOPT_PROXY_TLSAUTH_USERNAME(3)
+## CURLOPT_INFILESIZE
 
-## CURLOPT_TLSAUTH_PASSWORD
+Size of file to send. CURLOPT_INFILESIZE(3)
 
-TLS authentication password. See CURLOPT_TLSAUTH_PASSWORD(3)
+## CURLOPT_INFILESIZE_LARGE
 
-## CURLOPT_PROXY_TLSAUTH_PASSWORD
+Size of file to send. CURLOPT_INFILESIZE_LARGE(3)
 
-Proxy TLS authentication password. See CURLOPT_PROXY_TLSAUTH_PASSWORD(3)
+## CURLOPT_INTERFACE
 
-## CURLOPT_TLSAUTH_TYPE
+Bind connection locally to this. See CURLOPT_INTERFACE(3)
 
-TLS authentication methods. See CURLOPT_TLSAUTH_TYPE(3)
+## CURLOPT_INTERLEAVEDATA
 
-## CURLOPT_PROXY_TLSAUTH_TYPE
+Data pointer to pass to the RTSP interleave callback. See
+CURLOPT_INTERLEAVEDATA(3)
 
-Proxy TLS authentication methods. See CURLOPT_PROXY_TLSAUTH_TYPE(3)
+## CURLOPT_INTERLEAVEFUNCTION
 
-## CURLOPT_PROXYAUTH
+Callback for RTSP interleaved data. See CURLOPT_INTERLEAVEFUNCTION(3)
 
-HTTP proxy authentication methods. See CURLOPT_PROXYAUTH(3)
+## CURLOPT_IOCTLDATA
 
-## CURLOPT_SASL_AUTHZID
+**Deprecated option** Data pointer to pass to the I/O callback.
+See CURLOPT_IOCTLDATA(3)
 
-SASL authorization identity (identity to act as). See CURLOPT_SASL_AUTHZID(3)
+## CURLOPT_IOCTLFUNCTION
 
-## CURLOPT_SASL_IR
+**Deprecated option** Callback for I/O operations.
+See CURLOPT_IOCTLFUNCTION(3)
 
-Enable SASL initial response. See CURLOPT_SASL_IR(3)
+## CURLOPT_IPRESOLVE
 
-## CURLOPT_XOAUTH2_BEARER
+IP version to use. See CURLOPT_IPRESOLVE(3)
 
-OAuth2 bearer token. See CURLOPT_XOAUTH2_BEARER(3)
+## CURLOPT_ISSUERCERT
 
-## CURLOPT_DISALLOW_USERNAME_IN_URL
+Issuer certificate. See CURLOPT_ISSUERCERT(3)
 
-Do not allow username in URL. See CURLOPT_DISALLOW_USERNAME_IN_URL(3)
+## CURLOPT_ISSUERCERT_BLOB
 
-# HTTP OPTIONS
+Issuer certificate memory buffer. See CURLOPT_ISSUERCERT_BLOB(3)
 
-## CURLOPT_AUTOREFERER
+## CURLOPT_KEEP_SENDING_ON_ERROR
 
-Automatically set Referer: header. See CURLOPT_AUTOREFERER(3)
+Keep sending on HTTP \>= 300 errors. CURLOPT_KEEP_SENDING_ON_ERROR(3)
 
-## CURLOPT_ACCEPT_ENCODING
+## CURLOPT_KEYPASSWD
 
-Accept-Encoding and automatic decompressing data. See CURLOPT_ACCEPT_ENCODING(3)
+Client key password. See CURLOPT_KEYPASSWD(3)
 
-## CURLOPT_TRANSFER_ENCODING
+## CURLOPT_KRBLEVEL
 
-Request Transfer-Encoding. See CURLOPT_TRANSFER_ENCODING(3)
+Kerberos security level. See CURLOPT_KRBLEVEL(3)
 
-## CURLOPT_FOLLOWLOCATION
+## CURLOPT_LOCALPORT
 
-Follow HTTP redirects. See CURLOPT_FOLLOWLOCATION(3)
+Bind connection locally to this port. See CURLOPT_LOCALPORT(3)
 
-## CURLOPT_UNRESTRICTED_AUTH
+## CURLOPT_LOCALPORTRANGE
 
-Do not restrict authentication to original host. CURLOPT_UNRESTRICTED_AUTH(3)
+Bind connection locally to port range. See CURLOPT_LOCALPORTRANGE(3)
 
-## CURLOPT_MAXREDIRS
+## CURLOPT_LOGIN_OPTIONS
+
+Login options. See CURLOPT_LOGIN_OPTIONS(3)
+
+## CURLOPT_LOW_SPEED_LIMIT
+
+Low speed limit to abort transfer. See CURLOPT_LOW_SPEED_LIMIT(3)
+
+## CURLOPT_LOW_SPEED_TIME
 
-Maximum number of redirects to follow. See CURLOPT_MAXREDIRS(3)
+Time to be below the speed to trigger low speed abort. See
+CURLOPT_LOW_SPEED_TIME(3)
 
-## CURLOPT_POSTREDIR
+## CURLOPT_MAIL_AUTH
 
-How to act on redirects after POST. See CURLOPT_POSTREDIR(3)
+Authentication address. See CURLOPT_MAIL_AUTH(3)
 
-## CURLOPT_PUT
+## CURLOPT_MAIL_FROM
 
-**Deprecated option** Issue an HTTP PUT request. See CURLOPT_PUT(3)
+Address of the sender. See CURLOPT_MAIL_FROM(3)
 
-## CURLOPT_POST
+## CURLOPT_MAIL_RCPT
 
-Issue an HTTP POST request. See CURLOPT_POST(3)
+Address of the recipients. See CURLOPT_MAIL_RCPT(3)
 
-## CURLOPT_POSTFIELDS
+## CURLOPT_MAIL_RCPT_ALLOWFAILS
 
-Send a POST with this data. See CURLOPT_POSTFIELDS(3)
+Allow RCPT TO command to fail for some recipients. See
+CURLOPT_MAIL_RCPT_ALLOWFAILS(3)
 
-## CURLOPT_POSTFIELDSIZE
+## CURLOPT_MAXAGE_CONN
 
-The POST data is this big. See CURLOPT_POSTFIELDSIZE(3)
+Limit the age (idle time) of connections for reuse. See CURLOPT_MAXAGE_CONN(3)
 
-## CURLOPT_POSTFIELDSIZE_LARGE
+## CURLOPT_MAXCONNECTS
 
-The POST data is this big. See CURLOPT_POSTFIELDSIZE_LARGE(3)
+Maximum number of connections in the connection pool. See
+CURLOPT_MAXCONNECTS(3)
 
-## CURLOPT_COPYPOSTFIELDS
+## CURLOPT_MAXFILESIZE
 
-Send a POST with this data - and copy it. See CURLOPT_COPYPOSTFIELDS(3)
+Maximum file size to get. See CURLOPT_MAXFILESIZE(3)
 
-## CURLOPT_HTTPPOST
+## CURLOPT_MAXFILESIZE_LARGE
 
-**Deprecated option** Multipart formpost HTTP POST.
-See CURLOPT_HTTPPOST(3)
+Maximum file size to get. See CURLOPT_MAXFILESIZE_LARGE(3)
 
-## CURLOPT_REFERER
+## CURLOPT_MAXLIFETIME_CONN
 
-Referer: header. See CURLOPT_REFERER(3)
+Limit the age (since creation) of connections for reuse. See
+CURLOPT_MAXLIFETIME_CONN(3)
 
-## CURLOPT_USERAGENT
+## CURLOPT_MAXREDIRS
 
-User-Agent: header. See CURLOPT_USERAGENT(3)
+Maximum number of redirects to follow. See CURLOPT_MAXREDIRS(3)
 
-## CURLOPT_HTTPHEADER
+## CURLOPT_MAX_RECV_SPEED_LARGE
 
-Custom HTTP headers. See CURLOPT_HTTPHEADER(3)
+Cap the download speed to this. See CURLOPT_MAX_RECV_SPEED_LARGE(3)
 
-## CURLOPT_HEADEROPT
+## CURLOPT_MAX_SEND_SPEED_LARGE
 
-Control custom headers. See CURLOPT_HEADEROPT(3)
+Cap the upload speed to this. See CURLOPT_MAX_SEND_SPEED_LARGE(3)
 
-## CURLOPT_PROXYHEADER
+## CURLOPT_MIMEPOST
 
-Custom HTTP headers sent to proxy. See CURLOPT_PROXYHEADER(3)
+Post/send MIME data. See CURLOPT_MIMEPOST(3)
 
-## CURLOPT_HTTP200ALIASES
+## CURLOPT_MIME_OPTIONS
 
-Alternative versions of 200 OK. See CURLOPT_HTTP200ALIASES(3)
+Set MIME option flags. See CURLOPT_MIME_OPTIONS(3)
 
-## CURLOPT_COOKIE
+## CURLOPT_NETRC
 
-Cookie(s) to send. See CURLOPT_COOKIE(3)
+Enable .netrc parsing. See CURLOPT_NETRC(3)
 
-## CURLOPT_COOKIEFILE
+## CURLOPT_NETRC_FILE
 
-File to read cookies from. See CURLOPT_COOKIEFILE(3)
+.netrc filename. See CURLOPT_NETRC_FILE(3)
 
-## CURLOPT_COOKIEJAR
+## CURLOPT_NEW_DIRECTORY_PERMS
 
-File to write cookies to. See CURLOPT_COOKIEJAR(3)
+Mode for creating new remote directories. See CURLOPT_NEW_DIRECTORY_PERMS(3)
 
-## CURLOPT_COOKIESESSION
+## CURLOPT_NEW_FILE_PERMS
 
-Start a new cookie session. See CURLOPT_COOKIESESSION(3)
+Mode for creating new remote files. See CURLOPT_NEW_FILE_PERMS(3)
 
-## CURLOPT_COOKIELIST
+## CURLOPT_NOBODY
 
-Add or control cookies. See CURLOPT_COOKIELIST(3)
+Do not get the body contents. See CURLOPT_NOBODY(3)
 
-## CURLOPT_ALTSVC
+## CURLOPT_NOPROGRESS
 
-Specify the Alt-Svc: cache filename. See CURLOPT_ALTSVC(3)
+Shut off the progress meter. See CURLOPT_NOPROGRESS(3)
 
-## CURLOPT_ALTSVC_CTRL
+## CURLOPT_NOPROXY
 
-Enable and configure Alt-Svc: treatment. See CURLOPT_ALTSVC_CTRL(3)
+Filter out hosts from proxy use. CURLOPT_NOPROXY(3)
 
-## CURLOPT_HSTS
+## CURLOPT_NOSIGNAL
 
-Set HSTS cache file. See CURLOPT_HSTS(3)
+Do not install signal handlers. See CURLOPT_NOSIGNAL(3)
 
-## CURLOPT_HSTS_CTRL
+## CURLOPT_OPENSOCKETDATA
 
-Enable HSTS. See CURLOPT_HSTS_CTRL(3)
+Data pointer to pass to the open socket callback. See CURLOPT_OPENSOCKETDATA(3)
 
-## CURLOPT_HSTSREADFUNCTION
+## CURLOPT_OPENSOCKETFUNCTION
 
-Set HSTS read callback. See CURLOPT_HSTSREADFUNCTION(3)
+Callback for socket creation. See CURLOPT_OPENSOCKETFUNCTION(3)
 
-## CURLOPT_HSTSREADDATA
+## CURLOPT_PASSWORD
 
-Pass pointer to the HSTS read callback. See CURLOPT_HSTSREADDATA(3)
+Password. See CURLOPT_PASSWORD(3)
 
-## CURLOPT_HSTSWRITEFUNCTION
+## CURLOPT_PATH_AS_IS
 
-Set HSTS write callback. See CURLOPT_HSTSWRITEFUNCTION(3)
+Disable squashing /../ and /./ sequences in the path. See CURLOPT_PATH_AS_IS(3)
 
-## CURLOPT_HSTSWRITEDATA
+## CURLOPT_PINNEDPUBLICKEY
 
-Pass pointer to the HSTS write callback. See CURLOPT_HSTSWRITEDATA(3)
+Set pinned SSL public key . See CURLOPT_PINNEDPUBLICKEY(3)
 
-## CURLOPT_HTTPGET
+## CURLOPT_PIPEWAIT
 
-Do an HTTP GET request. See CURLOPT_HTTPGET(3)
+Wait on connection to pipeline on it. See CURLOPT_PIPEWAIT(3)
 
-## CURLOPT_REQUEST_TARGET
+## CURLOPT_PORT
 
-Set the request target. CURLOPT_REQUEST_TARGET(3)
+Port number to connect to. See CURLOPT_PORT(3)
 
-## CURLOPT_HTTP_VERSION
+## CURLOPT_POST
 
-HTTP version to use. CURLOPT_HTTP_VERSION(3)
+Make an HTTP POST. See CURLOPT_POST(3)
 
-## CURLOPT_HTTP09_ALLOWED
+## CURLOPT_POSTFIELDSIZE
 
-Allow HTTP/0.9 responses. CURLOPT_HTTP09_ALLOWED(3)
+The POST data is this big. See CURLOPT_POSTFIELDSIZE(3)
 
-## CURLOPT_IGNORE_CONTENT_LENGTH
+## CURLOPT_POSTFIELDSIZE_LARGE
 
-Ignore Content-Length. See CURLOPT_IGNORE_CONTENT_LENGTH(3)
+The POST data is this big. See CURLOPT_POSTFIELDSIZE_LARGE(3)
 
-## CURLOPT_HTTP_CONTENT_DECODING
+## CURLOPT_POSTQUOTE
 
-Disable Content decoding. See CURLOPT_HTTP_CONTENT_DECODING(3)
+Commands to run after transfer. See CURLOPT_POSTQUOTE(3)
 
-## CURLOPT_HTTP_TRANSFER_DECODING
+## CURLOPT_POSTREDIR
 
-Disable Transfer decoding. See CURLOPT_HTTP_TRANSFER_DECODING(3)
+How to act on redirects after POST. See CURLOPT_POSTREDIR(3)
 
-## CURLOPT_EXPECT_100_TIMEOUT_MS
+## CURLOPT_PREQUOTE
 
-100-continue timeout. See CURLOPT_EXPECT_100_TIMEOUT_MS(3)
+Commands to run just before transfer. See CURLOPT_PREQUOTE(3)
 
-## CURLOPT_TRAILERFUNCTION
+## CURLOPT_PREREQDATA
 
-Set callback for sending trailing headers. See
-CURLOPT_TRAILERFUNCTION(3)
+Data pointer to pass to the CURLOPT_PREREQFUNCTION callback. See
+CURLOPT_PREREQDATA(3)
 
-## CURLOPT_TRAILERDATA
+## CURLOPT_PREREQFUNCTION
 
-Custom pointer passed to the trailing headers callback. See
-CURLOPT_TRAILERDATA(3)
+Callback to be called after a connection is established but before a request
+is made on that connection. See CURLOPT_PREREQFUNCTION(3)
 
-## CURLOPT_PIPEWAIT
+## CURLOPT_PRE_PROXY
 
-Wait on connection to pipeline on it. See CURLOPT_PIPEWAIT(3)
+Socks proxy to use. See CURLOPT_PRE_PROXY(3)
 
-## CURLOPT_STREAM_DEPENDS
+## CURLOPT_PRIVATE
 
-This HTTP/2 stream depends on another. See CURLOPT_STREAM_DEPENDS(3)
+Private pointer to store. See CURLOPT_PRIVATE(3)
 
-## CURLOPT_STREAM_DEPENDS_E
+## CURLOPT_PROGRESSDATA
 
-This HTTP/2 stream depends on another exclusively. See
-CURLOPT_STREAM_DEPENDS_E(3)
+Data pointer to pass to the progress meter callback. See
+CURLOPT_PROGRESSDATA(3)
 
-## CURLOPT_STREAM_WEIGHT
+## CURLOPT_PROGRESSFUNCTION
 
-Set this HTTP/2 stream's weight. See CURLOPT_STREAM_WEIGHT(3)
+**OBSOLETE** callback for progress meter. See CURLOPT_PROGRESSFUNCTION(3)
 
-# SMTP OPTIONS
+## CURLOPT_PROTOCOLS
 
-## CURLOPT_MAIL_FROM
+**Deprecated option** Allowed protocols. See CURLOPT_PROTOCOLS(3)
 
-Address of the sender. See CURLOPT_MAIL_FROM(3)
+## CURLOPT_PROTOCOLS_STR
 
-## CURLOPT_MAIL_RCPT
+Allowed protocols. See CURLOPT_PROTOCOLS_STR(3)
 
-Address of the recipients. See CURLOPT_MAIL_RCPT(3)
+## CURLOPT_PROXY
 
-## CURLOPT_MAIL_AUTH
+Proxy to use. See CURLOPT_PROXY(3)
 
-Authentication address. See CURLOPT_MAIL_AUTH(3)
+## CURLOPT_PROXYAUTH
 
-## CURLOPT_MAIL_RCPT_ALLOWFAILS
+HTTP proxy authentication methods. See CURLOPT_PROXYAUTH(3)
 
-Allow RCPT TO command to fail for some recipients. See
-CURLOPT_MAIL_RCPT_ALLOWFAILS(3)
+## CURLOPT_PROXYHEADER
 
-# TFTP OPTIONS
+Custom HTTP headers sent to proxy. See CURLOPT_PROXYHEADER(3)
 
-## CURLOPT_TFTP_BLKSIZE
+## CURLOPT_PROXYPASSWORD
 
-TFTP block size. See CURLOPT_TFTP_BLKSIZE(3)
+Proxy password. See CURLOPT_PROXYPASSWORD(3)
 
-## CURLOPT_TFTP_NO_OPTIONS
+## CURLOPT_PROXYPORT
 
-Do not send TFTP options requests. See CURLOPT_TFTP_NO_OPTIONS(3)
+Proxy port to use. See CURLOPT_PROXYPORT(3)
 
-# FTP OPTIONS
+## CURLOPT_PROXYTYPE
 
-## CURLOPT_FTPPORT
+Proxy type. See CURLOPT_PROXYTYPE(3)
 
-Use active FTP. See CURLOPT_FTPPORT(3)
+## CURLOPT_PROXYUSERNAME
+Proxy username. See CURLOPT_PROXYUSERNAME(3)
 
-## CURLOPT_QUOTE
+## CURLOPT_PROXYUSERPWD
 
-Commands to run before transfer. See CURLOPT_QUOTE(3)
+Proxy username and password. See CURLOPT_PROXYUSERPWD(3)
 
-## CURLOPT_POSTQUOTE
+## CURLOPT_PROXY_CAINFO
 
-Commands to run after transfer. See CURLOPT_POSTQUOTE(3)
+Proxy CA cert bundle. See CURLOPT_PROXY_CAINFO(3)
 
-## CURLOPT_PREQUOTE
+## CURLOPT_PROXY_CAINFO_BLOB
 
-Commands to run just before transfer. See CURLOPT_PREQUOTE(3)
+Proxy CA cert bundle memory buffer. See CURLOPT_PROXY_CAINFO_BLOB(3)
 
-## CURLOPT_APPEND
+## CURLOPT_PROXY_CAPATH
 
-Append to remote file. See CURLOPT_APPEND(3)
+Path to proxy CA cert bundle. See CURLOPT_PROXY_CAPATH(3)
 
-## CURLOPT_FTP_USE_EPRT
+## CURLOPT_PROXY_CRLFILE
 
-Use EPRT. See CURLOPT_FTP_USE_EPRT(3)
+Proxy Certificate Revocation List. See CURLOPT_PROXY_CRLFILE(3)
 
-## CURLOPT_FTP_USE_EPSV
+## CURLOPT_PROXY_ISSUERCERT
 
-Use EPSV. See CURLOPT_FTP_USE_EPSV(3)
+Proxy issuer certificate. See CURLOPT_PROXY_ISSUERCERT(3)
 
-## CURLOPT_FTP_USE_PRET
+## CURLOPT_PROXY_ISSUERCERT_BLOB
 
-Use PRET. See CURLOPT_FTP_USE_PRET(3)
+Proxy issuer certificate memory buffer. See CURLOPT_PROXY_ISSUERCERT_BLOB(3)
 
-## CURLOPT_FTP_CREATE_MISSING_DIRS
+## CURLOPT_PROXY_KEYPASSWD
 
-Create missing directories on the remote server. See CURLOPT_FTP_CREATE_MISSING_DIRS(3)
+Proxy client key password. See CURLOPT_PROXY_KEYPASSWD(3)
 
-## CURLOPT_SERVER_RESPONSE_TIMEOUT
+## CURLOPT_PROXY_PINNEDPUBLICKEY
 
-Timeout for server responses. See CURLOPT_SERVER_RESPONSE_TIMEOUT(3)
+Set the proxy's pinned SSL public key. See
+CURLOPT_PROXY_PINNEDPUBLICKEY(3)
 
-## CURLOPT_SERVER_RESPONSE_TIMEOUT_MS
+## CURLOPT_PROXY_SERVICE_NAME
 
-Timeout for server responses. See CURLOPT_SERVER_RESPONSE_TIMEOUT_MS(3)
+Proxy authentication service name. CURLOPT_PROXY_SERVICE_NAME(3)
 
-## CURLOPT_FTP_ALTERNATIVE_TO_USER
+## CURLOPT_PROXY_SSLCERT
 
-Alternative to USER. See CURLOPT_FTP_ALTERNATIVE_TO_USER(3)
+Proxy client cert. See CURLOPT_PROXY_SSLCERT(3)
 
-## CURLOPT_FTP_SKIP_PASV_IP
+## CURLOPT_PROXY_SSLCERTTYPE
 
-Ignore the IP address in the PASV response. See CURLOPT_FTP_SKIP_PASV_IP(3)
+Proxy client cert type. See CURLOPT_PROXY_SSLCERTTYPE(3)
 
-## CURLOPT_FTPSSLAUTH
+## CURLOPT_PROXY_SSLCERT_BLOB
 
-Control how to do TLS. See CURLOPT_FTPSSLAUTH(3)
+Proxy client cert memory buffer. See CURLOPT_PROXY_SSLCERT_BLOB(3)
 
-## CURLOPT_FTP_SSL_CCC
+## CURLOPT_PROXY_SSLKEY
 
-Back to non-TLS again after authentication. See CURLOPT_FTP_SSL_CCC(3)
+Proxy client key. See CURLOPT_PROXY_SSLKEY(3)
 
-## CURLOPT_FTP_ACCOUNT
+## CURLOPT_PROXY_SSLKEYTYPE
 
-Send ACCT command. See CURLOPT_FTP_ACCOUNT(3)
+Proxy client key type. See CURLOPT_PROXY_SSLKEYTYPE(3)
 
-## CURLOPT_FTP_FILEMETHOD
+## CURLOPT_PROXY_SSLKEY_BLOB
 
-Specify how to reach files. See CURLOPT_FTP_FILEMETHOD(3)
+Proxy client key. See CURLOPT_PROXY_SSLKEY_BLOB(3)
 
-# RTSP OPTIONS
+## CURLOPT_PROXY_SSLVERSION
 
-## CURLOPT_RTSP_REQUEST
+Proxy SSL version to use. See CURLOPT_PROXY_SSLVERSION(3)
 
-RTSP request. See CURLOPT_RTSP_REQUEST(3)
+## CURLOPT_PROXY_SSL_CIPHER_LIST
 
-## CURLOPT_RTSP_SESSION_ID
+Proxy ciphers to use. See CURLOPT_PROXY_SSL_CIPHER_LIST(3)
 
-RTSP session-id. See CURLOPT_RTSP_SESSION_ID(3)
+## CURLOPT_PROXY_SSL_OPTIONS
 
-## CURLOPT_RTSP_STREAM_URI
+Control proxy SSL behavior. See CURLOPT_PROXY_SSL_OPTIONS(3)
 
-RTSP stream URI. See CURLOPT_RTSP_STREAM_URI(3)
+## CURLOPT_PROXY_SSL_VERIFYHOST
 
-## CURLOPT_RTSP_TRANSPORT
+Verify the hostname in the proxy SSL certificate. See
+CURLOPT_PROXY_SSL_VERIFYHOST(3)
 
-RTSP Transport: header. See CURLOPT_RTSP_TRANSPORT(3)
+## CURLOPT_PROXY_SSL_VERIFYPEER
 
-## CURLOPT_RTSP_CLIENT_CSEQ
+Verify the proxy SSL certificate. See CURLOPT_PROXY_SSL_VERIFYPEER(3)
 
-Client CSEQ number. See CURLOPT_RTSP_CLIENT_CSEQ(3)
+## CURLOPT_PROXY_TLS13_CIPHERS
 
-## CURLOPT_RTSP_SERVER_CSEQ
+Proxy TLS 1.3 cipher suites to use. See CURLOPT_PROXY_TLS13_CIPHERS(3)
 
-CSEQ number for RTSP Server-\>Client request. See CURLOPT_RTSP_SERVER_CSEQ(3)
+## CURLOPT_PROXY_TLSAUTH_PASSWORD
 
-## CURLOPT_AWS_SIGV4
+Proxy TLS authentication password. See CURLOPT_PROXY_TLSAUTH_PASSWORD(3)
 
-AWS HTTP V4 Signature. See CURLOPT_AWS_SIGV4(3)
+## CURLOPT_PROXY_TLSAUTH_TYPE
 
-# PROTOCOL OPTIONS
+Proxy TLS authentication methods. See CURLOPT_PROXY_TLSAUTH_TYPE(3)
 
-## CURLOPT_TRANSFERTEXT
+## CURLOPT_PROXY_TLSAUTH_USERNAME
 
-Use text transfer. See CURLOPT_TRANSFERTEXT(3)
+Proxy TLS authentication username. See CURLOPT_PROXY_TLSAUTH_USERNAME(3)
 
 ## CURLOPT_PROXY_TRANSFER_MODE
 
 Add transfer mode to URL over proxy. See CURLOPT_PROXY_TRANSFER_MODE(3)
 
-## CURLOPT_CRLF
+## CURLOPT_PUT
 
-Convert newlines. See CURLOPT_CRLF(3)
+**Deprecated option** Issue an HTTP PUT request. See CURLOPT_PUT(3)
 
-## CURLOPT_RANGE
+## CURLOPT_QUICK_EXIT
 
-Range requests. See CURLOPT_RANGE(3)
+To be set by toplevel tools like "curl" to skip lengthy cleanups when they are
+about to call exit() anyway. See CURLOPT_QUICK_EXIT(3)
 
-## CURLOPT_RESUME_FROM
+## CURLOPT_QUOTE
 
-Resume a transfer. See CURLOPT_RESUME_FROM(3)
+Commands to run before transfer. See CURLOPT_QUOTE(3)
 
-## CURLOPT_RESUME_FROM_LARGE
+## CURLOPT_RANDOM_FILE
 
-Resume a transfer. See CURLOPT_RESUME_FROM_LARGE(3)
+**OBSOLETE** Provide source for entropy random data.
+See CURLOPT_RANDOM_FILE(3)
 
-## CURLOPT_CURLU
+## CURLOPT_RANGE
 
-Set URL to work on with a URL handle. See CURLOPT_CURLU(3)
+Range requests. See CURLOPT_RANGE(3)
 
-## CURLOPT_CUSTOMREQUEST
+## CURLOPT_READDATA
 
-Custom request/method. See CURLOPT_CUSTOMREQUEST(3)
+Data pointer to pass to the read callback. See CURLOPT_READDATA(3)
 
-## CURLOPT_FILETIME
+## CURLOPT_READFUNCTION
 
-Request file modification date and time. See CURLOPT_FILETIME(3)
+Callback for reading data. See CURLOPT_READFUNCTION(3)
 
-## CURLOPT_DIRLISTONLY
+## CURLOPT_REDIR_PROTOCOLS
 
-List only. See CURLOPT_DIRLISTONLY(3)
+**Deprecated option** Protocols to allow redirects to. See
+CURLOPT_REDIR_PROTOCOLS(3)
 
-## CURLOPT_NOBODY
+## CURLOPT_REDIR_PROTOCOLS_STR
 
-Do not get the body contents. See CURLOPT_NOBODY(3)
+Protocols to allow redirects to. See CURLOPT_REDIR_PROTOCOLS_STR(3)
 
-## CURLOPT_INFILESIZE
+## CURLOPT_REFERER
 
-Size of file to send. CURLOPT_INFILESIZE(3)
+Referer: header. See CURLOPT_REFERER(3)
 
-## CURLOPT_INFILESIZE_LARGE
+## CURLOPT_REQUEST_TARGET
 
-Size of file to send. CURLOPT_INFILESIZE_LARGE(3)
+Set the request target. CURLOPT_REQUEST_TARGET(3)
 
-## CURLOPT_UPLOAD
+## CURLOPT_RESOLVE
 
-Upload data. See CURLOPT_UPLOAD(3)
+Provide fixed/fake name resolves. See CURLOPT_RESOLVE(3)
 
-## CURLOPT_UPLOAD_BUFFERSIZE
+## CURLOPT_RESOLVER_START_DATA
 
-Set upload buffer size. See CURLOPT_UPLOAD_BUFFERSIZE(3)
+Data pointer to pass to resolver start callback. See
+CURLOPT_RESOLVER_START_DATA(3)
 
-## CURLOPT_MIMEPOST
+## CURLOPT_RESOLVER_START_FUNCTION
 
-Post/send MIME data. See CURLOPT_MIMEPOST(3)
+Callback to be called before a new resolve request is started. See
+CURLOPT_RESOLVER_START_FUNCTION(3)
 
-## CURLOPT_MIME_OPTIONS
+## CURLOPT_RESUME_FROM
 
-Set MIME option flags. See CURLOPT_MIME_OPTIONS(3)
+Resume a transfer. See CURLOPT_RESUME_FROM(3)
 
-## CURLOPT_MAXFILESIZE
+## CURLOPT_RESUME_FROM_LARGE
 
-Maximum file size to get. See CURLOPT_MAXFILESIZE(3)
+Resume a transfer. See CURLOPT_RESUME_FROM_LARGE(3)
 
-## CURLOPT_MAXFILESIZE_LARGE
+## CURLOPT_RTSP_CLIENT_CSEQ
 
-Maximum file size to get. See CURLOPT_MAXFILESIZE_LARGE(3)
+Client CSEQ number. See CURLOPT_RTSP_CLIENT_CSEQ(3)
 
-## CURLOPT_TIMECONDITION
+## CURLOPT_RTSP_REQUEST
 
-Make a time conditional request. See CURLOPT_TIMECONDITION(3)
+RTSP request. See CURLOPT_RTSP_REQUEST(3)
 
-## CURLOPT_TIMEVALUE
+## CURLOPT_RTSP_SERVER_CSEQ
 
-Time value for the time conditional request. See CURLOPT_TIMEVALUE(3)
+CSEQ number for RTSP Server-\>Client request. See CURLOPT_RTSP_SERVER_CSEQ(3)
 
-## CURLOPT_TIMEVALUE_LARGE
+## CURLOPT_RTSP_SESSION_ID
 
-Time value for the time conditional request. See CURLOPT_TIMEVALUE_LARGE(3)
+RTSP session-id. See CURLOPT_RTSP_SESSION_ID(3)
 
-# CONNECTION OPTIONS
+## CURLOPT_RTSP_STREAM_URI
 
-## CURLOPT_TIMEOUT
+RTSP stream URI. See CURLOPT_RTSP_STREAM_URI(3)
 
-Timeout for the entire request. See CURLOPT_TIMEOUT(3)
+## CURLOPT_RTSP_TRANSPORT
 
-## CURLOPT_TIMEOUT_MS
+RTSP Transport: header. See CURLOPT_RTSP_TRANSPORT(3)
 
-Millisecond timeout for the entire request. See CURLOPT_TIMEOUT_MS(3)
+## CURLOPT_SASL_AUTHZID
 
-## CURLOPT_LOW_SPEED_LIMIT
+SASL authorization identity (identity to act as). See CURLOPT_SASL_AUTHZID(3)
 
-Low speed limit to abort transfer. See CURLOPT_LOW_SPEED_LIMIT(3)
+## CURLOPT_SASL_IR
 
-## CURLOPT_LOW_SPEED_TIME
+Enable SASL initial response. See CURLOPT_SASL_IR(3)
 
-Time to be below the speed to trigger low speed abort. See CURLOPT_LOW_SPEED_TIME(3)
+## CURLOPT_SEEKDATA
 
-## CURLOPT_MAX_SEND_SPEED_LARGE
+Data pointer to pass to the seek callback. See CURLOPT_SEEKDATA(3)
 
-Cap the upload speed to this. See CURLOPT_MAX_SEND_SPEED_LARGE(3)
+## CURLOPT_SEEKFUNCTION
 
-## CURLOPT_MAX_RECV_SPEED_LARGE
+Callback for seek operations. See CURLOPT_SEEKFUNCTION(3)
 
-Cap the download speed to this. See CURLOPT_MAX_RECV_SPEED_LARGE(3)
+## CURLOPT_SERVER_RESPONSE_TIMEOUT
 
-## CURLOPT_MAXCONNECTS
+Timeout for server responses. See CURLOPT_SERVER_RESPONSE_TIMEOUT(3)
 
-Maximum number of connections in the connection pool. See CURLOPT_MAXCONNECTS(3)
+## CURLOPT_SERVER_RESPONSE_TIMEOUT_MS
 
-## CURLOPT_FRESH_CONNECT
+Timeout for server responses. See CURLOPT_SERVER_RESPONSE_TIMEOUT_MS(3)
 
-Use a new connection. CURLOPT_FRESH_CONNECT(3)
+## CURLOPT_SERVICE_NAME
 
-## CURLOPT_FORBID_REUSE
+Authentication service name. CURLOPT_SERVICE_NAME(3)
 
-Prevent subsequent connections from reusing this. See CURLOPT_FORBID_REUSE(3)
+## CURLOPT_SHARE
 
-## CURLOPT_MAXAGE_CONN
+Share object to use. See CURLOPT_SHARE(3)
 
-Limit the age (idle time) of connections for reuse. See CURLOPT_MAXAGE_CONN(3)
+## CURLOPT_SOCKOPTDATA
 
-## CURLOPT_MAXLIFETIME_CONN
+Data pointer to pass to the sockopt callback. See CURLOPT_SOCKOPTDATA(3)
 
-Limit the age (since creation) of connections for reuse. See
-CURLOPT_MAXLIFETIME_CONN(3)
+## CURLOPT_SOCKOPTFUNCTION
 
-## CURLOPT_CONNECTTIMEOUT
+Callback for sockopt operations. See CURLOPT_SOCKOPTFUNCTION(3)
 
-Timeout for the connection phase. See CURLOPT_CONNECTTIMEOUT(3)
+## CURLOPT_SOCKS5_AUTH
 
-## CURLOPT_CONNECTTIMEOUT_MS
+Socks5 authentication methods. See CURLOPT_SOCKS5_AUTH(3)
 
-Millisecond timeout for the connection phase. See CURLOPT_CONNECTTIMEOUT_MS(3)
+## CURLOPT_SOCKS5_GSSAPI_NEC
 
-## CURLOPT_IPRESOLVE
+Socks5 GSSAPI NEC mode. See CURLOPT_SOCKS5_GSSAPI_NEC(3)
 
-IP version to use. See CURLOPT_IPRESOLVE(3)
+## CURLOPT_SOCKS5_GSSAPI_SERVICE
 
-## CURLOPT_CONNECT_ONLY
+**Deprecated option** Socks5 GSSAPI service name.
+See CURLOPT_SOCKS5_GSSAPI_SERVICE(3)
 
-Only connect, nothing else. See CURLOPT_CONNECT_ONLY(3)
+## CURLOPT_SSH_AUTH_TYPES
 
-## CURLOPT_USE_SSL
+SSH authentication types. See CURLOPT_SSH_AUTH_TYPES(3)
 
-Use TLS/SSL. See CURLOPT_USE_SSL(3)
+## CURLOPT_SSH_COMPRESSION
 
-## CURLOPT_RESOLVE
+Enable SSH compression. See CURLOPT_SSH_COMPRESSION(3)
 
-Provide fixed/fake name resolves. See CURLOPT_RESOLVE(3)
+## CURLOPT_SSH_HOSTKEYDATA
 
-## CURLOPT_DNS_INTERFACE
+Custom pointer to pass to ssh host key callback. See CURLOPT_SSH_HOSTKEYDATA(3)
 
-Bind name resolves to this interface. See CURLOPT_DNS_INTERFACE(3)
+## CURLOPT_SSH_HOSTKEYFUNCTION
 
-## CURLOPT_DNS_LOCAL_IP4
+Callback for checking host key handling. See CURLOPT_SSH_HOSTKEYFUNCTION(3)
 
-Bind name resolves to this IP4 address. See CURLOPT_DNS_LOCAL_IP4(3)
+## CURLOPT_SSH_HOST_PUBLIC_KEY_MD5
 
-## CURLOPT_DNS_LOCAL_IP6
+MD5 of host's public key. See CURLOPT_SSH_HOST_PUBLIC_KEY_MD5(3)
 
-Bind name resolves to this IP6 address. See CURLOPT_DNS_LOCAL_IP6(3)
+## CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256
 
-## CURLOPT_DNS_SERVERS
+SHA256 of host's public key. See CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256(3)
 
-Preferred DNS servers. See CURLOPT_DNS_SERVERS(3)
+## CURLOPT_SSH_KEYDATA
 
-## CURLOPT_DNS_SHUFFLE_ADDRESSES
+Custom pointer to pass to ssh key callback. See CURLOPT_SSH_KEYDATA(3)
 
-Shuffle addresses before use. See CURLOPT_DNS_SHUFFLE_ADDRESSES(3)
+## CURLOPT_SSH_KEYFUNCTION
 
-## CURLOPT_ACCEPTTIMEOUT_MS
+Callback for known hosts handling. See CURLOPT_SSH_KEYFUNCTION(3)
 
-Timeout for waiting for the server's connect back to be accepted. See
-CURLOPT_ACCEPTTIMEOUT_MS(3)
+## CURLOPT_SSH_KNOWNHOSTS
 
-## CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS
+Filename with known hosts. See CURLOPT_SSH_KNOWNHOSTS(3)
 
-Timeout for happy eyeballs. See CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS(3)
+## CURLOPT_SSH_PRIVATE_KEYFILE
 
-## CURLOPT_UPKEEP_INTERVAL_MS
+Filename of the private key. See CURLOPT_SSH_PRIVATE_KEYFILE(3)
 
-Sets the interval at which connection upkeep are performed. See
-CURLOPT_UPKEEP_INTERVAL_MS(3)
+## CURLOPT_SSH_PUBLIC_KEYFILE
 
-# SSL and SECURITY OPTIONS
+Filename of the public key. See CURLOPT_SSH_PUBLIC_KEYFILE(3)
 
 ## CURLOPT_SSLCERT
 
 Client cert. See CURLOPT_SSLCERT(3)
 
-## CURLOPT_SSLCERT_BLOB
-
-Client cert memory buffer. See CURLOPT_SSLCERT_BLOB(3)
-
-## CURLOPT_PROXY_SSLCERT
-
-Proxy client cert. See CURLOPT_PROXY_SSLCERT(3)
-
-## CURLOPT_PROXY_SSLCERT_BLOB
-
-Proxy client cert memory buffer. See CURLOPT_PROXY_SSLCERT_BLOB(3)
-
 ## CURLOPT_SSLCERTTYPE
 
 Client cert type. See CURLOPT_SSLCERTTYPE(3)
 
-## CURLOPT_PROXY_SSLCERTTYPE
-
-Proxy client cert type. See CURLOPT_PROXY_SSLCERTTYPE(3)
-
-## CURLOPT_SSLKEY
+## CURLOPT_SSLCERT_BLOB
 
-Client key. See CURLOPT_SSLKEY(3)
+Client cert memory buffer. See CURLOPT_SSLCERT_BLOB(3)
 
-## CURLOPT_SSLKEY_BLOB
+## CURLOPT_SSLENGINE
 
-Client key memory buffer. See CURLOPT_SSLKEY_BLOB(3)
+Use identifier with SSL engine. See CURLOPT_SSLENGINE(3)
 
-## CURLOPT_PROXY_SSLKEY
+## CURLOPT_SSLENGINE_DEFAULT
 
-Proxy client key. See CURLOPT_PROXY_SSLKEY(3)
+Default SSL engine. See CURLOPT_SSLENGINE_DEFAULT(3)
 
-## CURLOPT_PROXY_SSLKEY_BLOB
+## CURLOPT_SSLKEY
 
-Proxy client key. See CURLOPT_PROXY_SSLKEY_BLOB(3)
+Client key. See CURLOPT_SSLKEY(3)
 
 ## CURLOPT_SSLKEYTYPE
 
 Client key type. See CURLOPT_SSLKEYTYPE(3)
 
-## CURLOPT_PROXY_SSLKEYTYPE
+## CURLOPT_SSLKEY_BLOB
 
-Proxy client key type. See CURLOPT_PROXY_SSLKEYTYPE(3)
+Client key memory buffer. See CURLOPT_SSLKEY_BLOB(3)
 
-## CURLOPT_KEYPASSWD
+## CURLOPT_SSLVERSION
 
-Client key password. See CURLOPT_KEYPASSWD(3)
+SSL version to use. See CURLOPT_SSLVERSION(3)
 
-## CURLOPT_PROXY_KEYPASSWD
+## CURLOPT_SSL_CIPHER_LIST
 
-Proxy client key password. See CURLOPT_PROXY_KEYPASSWD(3)
+Ciphers to use. See CURLOPT_SSL_CIPHER_LIST(3)
+
+## CURLOPT_SSL_CTX_DATA
+
+Data pointer to pass to the SSL context callback. See CURLOPT_SSL_CTX_DATA(3)
+
+## CURLOPT_SSL_CTX_FUNCTION
+
+Callback for SSL context logic. See CURLOPT_SSL_CTX_FUNCTION(3)
 
 ## CURLOPT_SSL_EC_CURVES
 
@@ -1099,252 +1116,218 @@ Enable use of ALPN. See CURLOPT_SSL_ENABLE_ALPN(3)
 
 **OBSOLETE** Enable use of NPN. See CURLOPT_SSL_ENABLE_NPN(3)
 
-## CURLOPT_SSLENGINE
-
-Use identifier with SSL engine. See CURLOPT_SSLENGINE(3)
-
-## CURLOPT_SSLENGINE_DEFAULT
-
-Default SSL engine. See CURLOPT_SSLENGINE_DEFAULT(3)
-
 ## CURLOPT_SSL_FALSESTART
 
 Enable TLS False Start. See CURLOPT_SSL_FALSESTART(3)
 
-## CURLOPT_SSLVERSION
+## CURLOPT_SSL_OPTIONS
 
-SSL version to use. See CURLOPT_SSLVERSION(3)
+Control SSL behavior. See CURLOPT_SSL_OPTIONS(3)
 
-## CURLOPT_PROXY_SSLVERSION
+## CURLOPT_SSL_SESSIONID_CACHE
 
-Proxy SSL version to use. See CURLOPT_PROXY_SSLVERSION(3)
+Disable SSL session-id cache. See CURLOPT_SSL_SESSIONID_CACHE(3)
 
 ## CURLOPT_SSL_VERIFYHOST
 
 Verify the hostname in the SSL certificate. See CURLOPT_SSL_VERIFYHOST(3)
 
-## CURLOPT_DOH_SSL_VERIFYHOST
-
-Verify the hostname in the DoH (DNS-over-HTTPS) SSL certificate. See
-CURLOPT_DOH_SSL_VERIFYHOST(3)
-
-## CURLOPT_PROXY_SSL_VERIFYHOST
-
-Verify the hostname in the proxy SSL certificate. See
-CURLOPT_PROXY_SSL_VERIFYHOST(3)
-
 ## CURLOPT_SSL_VERIFYPEER
 
 Verify the SSL certificate. See CURLOPT_SSL_VERIFYPEER(3)
 
-## CURLOPT_DOH_SSL_VERIFYPEER
-
-Verify the DoH (DNS-over-HTTPS) SSL certificate. See
-CURLOPT_DOH_SSL_VERIFYPEER(3)
-
-## CURLOPT_PROXY_SSL_VERIFYPEER
-
-Verify the proxy SSL certificate. See CURLOPT_PROXY_SSL_VERIFYPEER(3)
-
 ## CURLOPT_SSL_VERIFYSTATUS
 
 Verify the SSL certificate's status. See CURLOPT_SSL_VERIFYSTATUS(3)
 
-## CURLOPT_DOH_SSL_VERIFYSTATUS
-
-Verify the DoH (DNS-over-HTTPS) SSL certificate's status. See
-CURLOPT_DOH_SSL_VERIFYSTATUS(3)
-
-## CURLOPT_CAINFO
-
-CA cert bundle. See CURLOPT_CAINFO(3)
-
-## CURLOPT_CAINFO_BLOB
+## CURLOPT_STDERR
 
-CA cert bundle memory buffer. See CURLOPT_CAINFO_BLOB(3)
+Redirect stderr to another stream. See CURLOPT_STDERR(3)
 
-## CURLOPT_PROXY_CAINFO
+## CURLOPT_STREAM_DEPENDS
 
-Proxy CA cert bundle. See CURLOPT_PROXY_CAINFO(3)
+This HTTP/2 stream depends on another. See CURLOPT_STREAM_DEPENDS(3)
 
-## CURLOPT_PROXY_CAINFO_BLOB
+## CURLOPT_STREAM_DEPENDS_E
 
-Proxy CA cert bundle memory buffer. See CURLOPT_PROXY_CAINFO_BLOB(3)
+This HTTP/2 stream depends on another exclusively. See
+CURLOPT_STREAM_DEPENDS_E(3)
 
-## CURLOPT_ISSUERCERT
+## CURLOPT_STREAM_WEIGHT
 
-Issuer certificate. See CURLOPT_ISSUERCERT(3)
+Set this HTTP/2 stream's weight. See CURLOPT_STREAM_WEIGHT(3)
 
-## CURLOPT_ISSUERCERT_BLOB
+## CURLOPT_SUPPRESS_CONNECT_HEADERS
 
-Issuer certificate memory buffer. See CURLOPT_ISSUERCERT_BLOB(3)
+Suppress proxy CONNECT response headers from user callbacks. See
+CURLOPT_SUPPRESS_CONNECT_HEADERS(3)
 
-## CURLOPT_PROXY_ISSUERCERT
+## CURLOPT_TCP_FASTOPEN
 
-Proxy issuer certificate. See CURLOPT_PROXY_ISSUERCERT(3)
+Enable TCP Fast Open. See CURLOPT_TCP_FASTOPEN(3)
 
-## CURLOPT_PROXY_ISSUERCERT_BLOB
+## CURLOPT_TCP_KEEPALIVE
 
-Proxy issuer certificate memory buffer. See CURLOPT_PROXY_ISSUERCERT_BLOB(3)
+Enable TCP keep-alive. See CURLOPT_TCP_KEEPALIVE(3)
 
-## CURLOPT_CAPATH
+## CURLOPT_TCP_KEEPCNT
 
-Path to CA cert bundle. See CURLOPT_CAPATH(3)
+Maximum number of keep-alive probes. See CURLOPT_TCP_KEEPCNT(3)
 
-## CURLOPT_PROXY_CAPATH
+## CURLOPT_TCP_KEEPIDLE
 
-Path to proxy CA cert bundle. See CURLOPT_PROXY_CAPATH(3)
+Idle time before sending keep-alive. See CURLOPT_TCP_KEEPIDLE(3)
 
-## CURLOPT_CRLFILE
+## CURLOPT_TCP_KEEPINTVL
 
-Certificate Revocation List. See CURLOPT_CRLFILE(3)
+Interval between keep-alive probes. See CURLOPT_TCP_KEEPINTVL(3)
 
-## CURLOPT_PROXY_CRLFILE
+## CURLOPT_TCP_NODELAY
 
-Proxy Certificate Revocation List. See CURLOPT_PROXY_CRLFILE(3)
+Disable the Nagle algorithm. See CURLOPT_TCP_NODELAY(3)
 
-## CURLOPT_CA_CACHE_TIMEOUT
+## CURLOPT_TELNETOPTIONS
 
-Timeout for CA cache. See CURLOPT_CA_CACHE_TIMEOUT(3)
+TELNET options. See CURLOPT_TELNETOPTIONS(3)
 
-## CURLOPT_CERTINFO
+## CURLOPT_TFTP_BLKSIZE
 
-Extract certificate info. See CURLOPT_CERTINFO(3)
+TFTP block size. See CURLOPT_TFTP_BLKSIZE(3)
 
-## CURLOPT_PINNEDPUBLICKEY
+## CURLOPT_TFTP_NO_OPTIONS
 
-Set pinned SSL public key . See CURLOPT_PINNEDPUBLICKEY(3)
+Do not send TFTP options requests. See CURLOPT_TFTP_NO_OPTIONS(3)
 
-## CURLOPT_PROXY_PINNEDPUBLICKEY
+## CURLOPT_TIMECONDITION
 
-Set the proxy's pinned SSL public key. See
-CURLOPT_PROXY_PINNEDPUBLICKEY(3)
+Make a time conditional request. See CURLOPT_TIMECONDITION(3)
 
-## CURLOPT_RANDOM_FILE
+## CURLOPT_TIMEOUT
 
-**OBSOLETE** Provide source for entropy random data.
-See CURLOPT_RANDOM_FILE(3)
+Timeout for the entire request. See CURLOPT_TIMEOUT(3)
 
-## CURLOPT_EGDSOCKET
+## CURLOPT_TIMEOUT_MS
 
-**OBSOLETE** Identify EGD socket for entropy. See CURLOPT_EGDSOCKET(3)
+Millisecond timeout for the entire request. See CURLOPT_TIMEOUT_MS(3)
 
-## CURLOPT_SSL_CIPHER_LIST
+## CURLOPT_TIMEVALUE
 
-Ciphers to use. See CURLOPT_SSL_CIPHER_LIST(3)
+Time value for the time conditional request. See CURLOPT_TIMEVALUE(3)
 
-## CURLOPT_PROXY_SSL_CIPHER_LIST
+## CURLOPT_TIMEVALUE_LARGE
 
-Proxy ciphers to use. See CURLOPT_PROXY_SSL_CIPHER_LIST(3)
+Time value for the time conditional request. See CURLOPT_TIMEVALUE_LARGE(3)
 
 ## CURLOPT_TLS13_CIPHERS
 
 TLS 1.3 cipher suites to use. See CURLOPT_TLS13_CIPHERS(3)
 
-## CURLOPT_PROXY_TLS13_CIPHERS
-
-Proxy TLS 1.3 cipher suites to use. See CURLOPT_PROXY_TLS13_CIPHERS(3)
+## CURLOPT_TLSAUTH_PASSWORD
 
-## CURLOPT_SSL_SESSIONID_CACHE
+TLS authentication password. See CURLOPT_TLSAUTH_PASSWORD(3)
 
-Disable SSL session-id cache. See CURLOPT_SSL_SESSIONID_CACHE(3)
+## CURLOPT_TLSAUTH_TYPE
 
-## CURLOPT_SSL_OPTIONS
+TLS authentication methods. See CURLOPT_TLSAUTH_TYPE(3)
 
-Control SSL behavior. See CURLOPT_SSL_OPTIONS(3)
+## CURLOPT_TLSAUTH_USERNAME
 
-## CURLOPT_PROXY_SSL_OPTIONS
+TLS authentication username. See CURLOPT_TLSAUTH_USERNAME(3)
 
-Control proxy SSL behavior. See CURLOPT_PROXY_SSL_OPTIONS(3)
+## CURLOPT_TRAILERDATA
 
-## CURLOPT_KRBLEVEL
+Custom pointer passed to the trailing headers callback. See
+CURLOPT_TRAILERDATA(3)
 
-Kerberos security level. See CURLOPT_KRBLEVEL(3)
+## CURLOPT_TRAILERFUNCTION
 
-## CURLOPT_GSSAPI_DELEGATION
+Set callback for sending trailing headers. See
+CURLOPT_TRAILERFUNCTION(3)
 
-Disable GSS-API delegation. See CURLOPT_GSSAPI_DELEGATION(3)
+## CURLOPT_TRANSFERTEXT
 
-# SSH OPTIONS
+Use text transfer. See CURLOPT_TRANSFERTEXT(3)
 
-## CURLOPT_SSH_AUTH_TYPES
+## CURLOPT_TRANSFER_ENCODING
 
-SSH authentication types. See CURLOPT_SSH_AUTH_TYPES(3)
+Request Transfer-Encoding. See CURLOPT_TRANSFER_ENCODING(3)
 
-## CURLOPT_SSH_COMPRESSION
+## CURLOPT_UNIX_SOCKET_PATH
 
-Enable SSH compression. See CURLOPT_SSH_COMPRESSION(3)
+Path to a Unix domain socket. See CURLOPT_UNIX_SOCKET_PATH(3)
 
-## CURLOPT_SSH_HOST_PUBLIC_KEY_MD5
+## CURLOPT_UNRESTRICTED_AUTH
 
-MD5 of host's public key. See CURLOPT_SSH_HOST_PUBLIC_KEY_MD5(3)
+Do not restrict authentication to original host. CURLOPT_UNRESTRICTED_AUTH(3)
 
-## CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256
+## CURLOPT_UPKEEP_INTERVAL_MS
 
-SHA256 of host's public key. See CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256(3)
+Sets the interval at which connection upkeep are performed. See
+CURLOPT_UPKEEP_INTERVAL_MS(3)
 
-## CURLOPT_SSH_PUBLIC_KEYFILE
+## CURLOPT_UPLOAD
 
-Filename of the public key. See CURLOPT_SSH_PUBLIC_KEYFILE(3)
+Upload data. See CURLOPT_UPLOAD(3)
 
-## CURLOPT_SSH_PRIVATE_KEYFILE
+## CURLOPT_UPLOAD_BUFFERSIZE
 
-Filename of the private key. See CURLOPT_SSH_PRIVATE_KEYFILE(3)
+Set upload buffer size. See CURLOPT_UPLOAD_BUFFERSIZE(3)
 
-## CURLOPT_SSH_KNOWNHOSTS
+## CURLOPT_URL
 
-Filename with known hosts. See CURLOPT_SSH_KNOWNHOSTS(3)
+URL to work on. See CURLOPT_URL(3)
 
-## CURLOPT_SSH_KEYFUNCTION
+## CURLOPT_USERAGENT
 
-Callback for known hosts handling. See CURLOPT_SSH_KEYFUNCTION(3)
+User-Agent: header. See CURLOPT_USERAGENT(3)
 
-## CURLOPT_SSH_KEYDATA
+## CURLOPT_USERNAME
 
-Custom pointer to pass to ssh key callback. See CURLOPT_SSH_KEYDATA(3)
+Username. See CURLOPT_USERNAME(3)
 
-## CURLOPT_SSH_HOSTKEYFUNCTION
+## CURLOPT_USERPWD
 
-Callback for checking host key handling. See CURLOPT_SSH_HOSTKEYFUNCTION(3)
+Username and password. See CURLOPT_USERPWD(3)
 
-## CURLOPT_SSH_HOSTKEYDATA
+## CURLOPT_USE_SSL
 
-Custom pointer to pass to ssh host key callback. See CURLOPT_SSH_HOSTKEYDATA(3)
+Use TLS/SSL. See CURLOPT_USE_SSL(3)
 
-# WEBSOCKET
+## CURLOPT_VERBOSE
 
-## CURLOPT_WS_OPTIONS
+Display verbose information. See CURLOPT_VERBOSE(3)
 
-Set WebSocket options. See CURLOPT_WS_OPTIONS(3)
+## CURLOPT_WILDCARDMATCH
 
-# OTHER OPTIONS
+Transfer multiple files according to a filename pattern. See
+CURLOPT_WILDCARDMATCH(3)
 
-## CURLOPT_PRIVATE
+## CURLOPT_WRITEDATA
 
-Private pointer to store. See CURLOPT_PRIVATE(3)
+Data pointer to pass to the write callback. See CURLOPT_WRITEDATA(3)
 
-## CURLOPT_SHARE
+## CURLOPT_WRITEFUNCTION
 
-Share object to use. See CURLOPT_SHARE(3)
+Callback for writing data. See CURLOPT_WRITEFUNCTION(3)
 
-## CURLOPT_NEW_FILE_PERMS
+## CURLOPT_WS_OPTIONS
 
-Mode for creating new remote files. See CURLOPT_NEW_FILE_PERMS(3)
+Set WebSocket options. See CURLOPT_WS_OPTIONS(3)
 
-## CURLOPT_NEW_DIRECTORY_PERMS
+## CURLOPT_XFERINFODATA
 
-Mode for creating new remote directories. See CURLOPT_NEW_DIRECTORY_PERMS(3)
+Data pointer to pass to the progress meter callback. See
+CURLOPT_XFERINFODATA(3)
 
-## CURLOPT_QUICK_EXIT
+## CURLOPT_XFERINFOFUNCTION
 
-To be set by toplevel tools like "curl" to skip lengthy cleanups when they are
-about to call exit() anyway. See CURLOPT_QUICK_EXIT(3)
+Callback for progress meter. See CURLOPT_XFERINFOFUNCTION(3)
 
-# TELNET OPTIONS
+## CURLOPT_XOAUTH2_BEARER
 
-## CURLOPT_TELNETOPTIONS
+OAuth2 bearer token. See CURLOPT_XOAUTH2_BEARER(3)
 
-TELNET options. See CURLOPT_TELNETOPTIONS(3)
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -1361,15 +1344,7 @@ int main(void)
 }
 ~~~
 
-# ENCRYPTED CLIENT HELLO OPTIONS
-
-## CURLOPT_ECH
-
-Set the configuration for ECH. See CURLOPT_ECH(3)
-
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_strerror.md b/docs/libcurl/curl_easy_strerror.md
index 0555fe783..37040a1c1 100644
--- a/docs/libcurl/curl_easy_strerror.md
+++ b/docs/libcurl/curl_easy_strerror.md
@@ -11,6 +11,7 @@ See-also:
   - libcurl-errors (3)
 Protocol:
   - All
+Added-in: 7.12.0
 ---
 
 # NAME
@@ -33,6 +34,8 @@ CURLcode error code passed in the argument *errornum*.
 Typically applications also appreciate CURLOPT_ERRORBUFFER(3) for more
 specific error descriptions generated at runtime.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -52,9 +55,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-This function was added in libcurl 7.12.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_unescape.md b/docs/libcurl/curl_easy_unescape.md
index 00951d96e..b6b25993c 100644
--- a/docs/libcurl/curl_easy_unescape.md
+++ b/docs/libcurl/curl_easy_unescape.md
@@ -6,14 +6,15 @@ Section: 3
 Source: libcurl
 See-also:
   - curl_easy_escape (3)
-  - curl_free (3)
+  - curl_url_get (3)
 Protocol:
   - All
+Added-in: 7.15.4
 ---
 
 # NAME
 
-curl_easy_unescape - URL decodes the given string
+curl_easy_unescape - URL decode a string
 
 # SYNOPSIS
 
@@ -46,6 +47,8 @@ TPF, but it was otherwise ignored.
 
 You must curl_free(3) the returned string when you are done with it.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -66,9 +69,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.15.4 and replaces the old curl_unescape(3) function.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_easy_upkeep.md b/docs/libcurl/curl_easy_upkeep.md
index eec4ed2f4..c2d798d2d 100644
--- a/docs/libcurl/curl_easy_upkeep.md
+++ b/docs/libcurl/curl_easy_upkeep.md
@@ -9,11 +9,12 @@ See-also:
   - CURLOPT_TCP_KEEPIDLE (3)
 Protocol:
   - All
+Added-in: 7.62.0
 ---
 
 # NAME
 
-curl_easy_upkeep - Perform any connection upkeep checks.
+curl_easy_upkeep - keep existing connections alive
 
 # SYNOPSIS
 
@@ -38,6 +39,8 @@ This function must be explicitly called in order to perform the upkeep work.
 The connection upkeep interval is set with
 CURLOPT_UPKEEP_INTERVAL_MS(3).
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -68,9 +71,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.62.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_escape.md b/docs/libcurl/curl_escape.md
index d15a4debc..6dce68ec6 100644
--- a/docs/libcurl/curl_escape.md
+++ b/docs/libcurl/curl_escape.md
@@ -9,11 +9,12 @@ See-also:
   - curl_unescape (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
 
-curl_escape - URL encodes the given string
+curl_escape - URL encode a string
 
 # SYNOPSIS
 
@@ -37,6 +38,8 @@ on **string** to find out the size.
 
 You must curl_free(3) the returned string when you are done with it.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -50,11 +53,13 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 Since 7.15.4, curl_easy_escape(3) should be used. This function might be
 removed in a future release.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 A pointer to a null-terminated string or NULL if it failed.
diff --git a/docs/libcurl/curl_formadd.md b/docs/libcurl/curl_formadd.md
index 0aefb26ee..6e0993bb0 100644
--- a/docs/libcurl/curl_formadd.md
+++ b/docs/libcurl/curl_formadd.md
@@ -10,6 +10,7 @@ See-also:
   - curl_mime_init (3)
 Protocol:
   - HTTP
+Added-in: 7.1
 ---
 
 # NAME
@@ -202,6 +203,8 @@ for the curl handle.
 
 See example below.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -299,7 +302,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
 
 Deprecated in 7.56.0. Before this release, field names were allowed to contain
 zero-valued bytes. The pseudo-filename "-" to read stdin is discouraged
@@ -308,6 +311,8 @@ effective data size can then not be automatically determined, resulting in a
 chunked encoding transfer. Backslashes and double quotes in field and
 filenames are now escaped before transmission.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 0 means everything was OK, non-zero means an error occurred corresponding to a
diff --git a/docs/libcurl/curl_formfree.md b/docs/libcurl/curl_formfree.md
index 1e0db8417..e431f3aca 100644
--- a/docs/libcurl/curl_formfree.md
+++ b/docs/libcurl/curl_formfree.md
@@ -10,6 +10,7 @@ See-also:
   - curl_mime_init (3)
 Protocol:
   - HTTP
+Added-in: 7.1
 ---
 
 # NAME
@@ -42,6 +43,8 @@ curl_formadd(3) and may be NULL.
 Passing in a NULL pointer in *form* makes this function return immediately
 with no action.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -69,10 +72,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
 
 Deprecated in 7.56.0.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 None
diff --git a/docs/libcurl/curl_formget.md b/docs/libcurl/curl_formget.md
index 2ec8d119c..4724bba62 100644
--- a/docs/libcurl/curl_formget.md
+++ b/docs/libcurl/curl_formget.md
@@ -9,11 +9,12 @@ See-also:
   - curl_mime_init (3)
 Protocol:
   - HTTP
+Added-in: 7.15.5
 ---
 
 # NAME
 
-curl_formget - serialize a previously built multipart form POST chain
+curl_formget - serialize a multipart form POST chain
 
 # SYNOPSIS
 
@@ -26,9 +27,11 @@ int curl_formget(struct curl_httppost * form, void *userp,
 
 # DESCRIPTION
 
+The form API (including this function) is deprecated since libcurl 7.56.0.
+
 curl_formget() serializes data previously built with curl_formadd(3). It
-accepts a void pointer as second argument named *userp* which is passed as
-the first argument to the curl_formget_callback function.
+accepts a void pointer as second argument named *userp* which is passed as the
+first argument to the curl_formget_callback function.
 
 ~~~c
  typedef size_t (*curl_formget_callback)(void *userp, const char *buf,
@@ -40,9 +43,10 @@ character buffer passed to the callback must not be freed. The callback should
 return the buffer length passed to it on success.
 
 If the **CURLFORM_STREAM** option is used in the formpost, it prevents
-curl_formget(3) from working until you have performed the actual HTTP
-request. This, because first then does libcurl known which actual read
-callback to use!
+curl_formget(3) from working until you have performed the actual HTTP request.
+This, because first then does libcurl known which actual read callback to use!
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -64,10 +68,7 @@ size_t print_httppost(struct curl_httppost *post)
 }
 ~~~
 
-# AVAILABILITY
-
-This function was added in libcurl 7.15.5. The form API is deprecated in
-libcurl 7.56.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_free.md b/docs/libcurl/curl_free.md
index a758adf59..f59e1218f 100644
--- a/docs/libcurl/curl_free.md
+++ b/docs/libcurl/curl_free.md
@@ -9,6 +9,7 @@ See-also:
   - curl_easy_unescape (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -32,6 +33,8 @@ differences in memory management between your application and libcurl.
 Passing in a NULL pointer in *ptr* makes this function return immediately
 with no action.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -45,9 +48,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_getdate.md b/docs/libcurl/curl_getdate.md
index 8df080ce9..00b4f9b73 100644
--- a/docs/libcurl/curl_getdate.md
+++ b/docs/libcurl/curl_getdate.md
@@ -11,11 +11,12 @@ See-also:
   - curl_easy_unescape (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
 
-curl_getdate - Convert a date string to number of seconds
+curl_getdate - convert date string to number of seconds
 
 # SYNOPSIS
 
@@ -74,6 +75,8 @@ If a decimal number of the form YYYYMMDD appears, then YYYY is read as the
 year, MM as the month number and DD as the day of the month, for the specified
 calendar date.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -113,21 +116,19 @@ RFC 1036) and ANSI C's *asctime()* format.
 
 These formats are the only ones RFC 7231 says HTTP applications may use.
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
 This function returns -1 when it fails to parse the date string. Otherwise it
 returns the number of seconds as described.
 
-On systems with a signed 32 bit time_t: if the year is larger than 2037 or
+On systems with a signed 32-bit time_t: if the year is larger than 2037 or
 less than 1903, this function returns -1.
 
-On systems with an unsigned 32 bit time_t: if the year is larger than 2106 or
+On systems with an unsigned 32-bit time_t: if the year is larger than 2106 or
 less than 1970, this function returns -1.
 
-On systems with 64 bit time_t: if the year is less than 1583, this function
+On systems with 64-bit time_t: if the year is less than 1583, this function
 returns -1. (The Gregorian calendar was first introduced 1582 so no "real"
 dates in this way of doing dates existed before then.)
diff --git a/docs/libcurl/curl_getenv.md b/docs/libcurl/curl_getenv.md
index 0092c676b..c6f0c268f 100644
--- a/docs/libcurl/curl_getenv.md
+++ b/docs/libcurl/curl_getenv.md
@@ -8,6 +8,7 @@ See-also:
   - getenv (3C)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -30,6 +31,8 @@ systems libcurl builds on (including win32).
 
 You must curl_free(3) the returned string when you are done with it.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -43,9 +46,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_global_cleanup.md b/docs/libcurl/curl_global_cleanup.md
index 7f346c7ef..60a761ed5 100644
--- a/docs/libcurl/curl_global_cleanup.md
+++ b/docs/libcurl/curl_global_cleanup.md
@@ -10,6 +10,7 @@ See-also:
   - libcurl-thread (3)
 Protocol:
   - All
+Added-in: 7.8
 ---
 
 # NAME
@@ -59,6 +60,8 @@ depending on how OpenSSL was built and loaded as a library. It is possible in
 some rare circumstances a memory leak could occur unless you implement your own
 OpenSSL thread cleanup. Refer to libcurl-thread(3).
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -72,9 +75,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.8
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_global_init.md b/docs/libcurl/curl_global_init.md
index e48a1f36f..4ce880f9e 100644
--- a/docs/libcurl/curl_global_init.md
+++ b/docs/libcurl/curl_global_init.md
@@ -13,11 +13,12 @@ See-also:
   - libcurl (3)
 Protocol:
   - All
+Added-in: 7.8
 ---
 
 # NAME
 
-curl_global_init - Global libcurl initialization
+curl_global_init - global libcurl initialization
 
 # SYNOPSIS
 
@@ -44,16 +45,15 @@ In normal operation, you must specify CURL_GLOBAL_ALL. Do not use any other
 value unless you are familiar with it and mean to control internal operations
 of libcurl.
 
-This function is thread-safe since libcurl 7.84.0 if
-curl_version_info(3) has the CURL_VERSION_THREADSAFE feature bit set
-(most platforms).
+This function is thread-safe on most platforms. Then curl_version_info(3) has
+the `threadsafe` feature set (added in 7.84.0).
 
-If this is not thread-safe, you must not call this function when any other
-thread in the program (i.e. a thread sharing the same memory) is running.
-This does not just mean no other thread that is using libcurl. Because
-curl_global_init(3) calls functions of other libraries that are
-similarly thread unsafe, it could conflict with any other thread that uses
-these other libraries.
+If this is not thread-safe (the bit mentioned above is not set), you must not
+call this function when any other thread in the program (i.e. a thread sharing
+the same memory) is running. This does not just mean no other thread that is
+using libcurl. Because curl_global_init(3) calls functions of other libraries
+that are similarly thread unsafe, it could conflict with any other thread that
+uses these other libraries.
 
 If you are initializing libcurl from a Windows DLL you should not initialize
 it from *DllMain* or a static initializer because Windows holds the loader
@@ -110,6 +110,8 @@ Before 7.69.0: when this flag is set, curl acknowledges EINTR condition when
 connecting or when waiting for data. Otherwise, curl waits until full timeout
 elapses. (Added in 7.30.0)
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -123,9 +125,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.8
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_global_init_mem.md b/docs/libcurl/curl_global_init_mem.md
index 229d4d606..6f49abfad 100644
--- a/docs/libcurl/curl_global_init_mem.md
+++ b/docs/libcurl/curl_global_init_mem.md
@@ -9,11 +9,12 @@ See-also:
   - curl_global_init (3)
 Protocol:
   - All
+Added-in: 7.12.0
 ---
 
 # NAME
 
-curl_global_init_mem - Global libcurl initialization with memory callbacks
+curl_global_init_mem - global libcurl initialization with memory callbacks
 
 # SYNOPSIS
 
@@ -70,6 +71,8 @@ to that man page for documentation.
 Manipulating these gives considerable powers to the application to severely
 screw things up for libcurl. Take care!
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -87,9 +90,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.12.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_global_sslset.md b/docs/libcurl/curl_global_sslset.md
index 1fdc2d320..42123d71c 100644
--- a/docs/libcurl/curl_global_sslset.md
+++ b/docs/libcurl/curl_global_sslset.md
@@ -9,11 +9,12 @@ See-also:
   - libcurl (3)
 Protocol:
   - All
+Added-in: 7.56.0
 ---
 
 # NAME
 
-curl_global_sslset - Select SSL backend to use with libcurl
+curl_global_sslset - select SSL backend to use
 
 # SYNOPSIS
 
@@ -66,7 +67,7 @@ This does not just mean no other thread that is using libcurl.
 # OpenSSL
 
 The name "OpenSSL" is used for all versions of OpenSSL and its associated
-forks/flavors in this function. OpenSSL, BoringSSL, libressl, quictls and
+forks/flavors in this function. OpenSSL, BoringSSL, LibreSSL, quictls and
 AmiSSL are all supported by libcurl, but in the eyes of
 curl_global_sslset(3) they are all just "OpenSSL". They all mostly
 provide the same API.
@@ -100,6 +101,8 @@ typedef enum {
 } curl_sslbackend;
 ~~~
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -119,10 +122,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-This function was added in libcurl 7.56.0. Before this version, there was no
-support for choosing SSL backends at runtime.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_global_trace.md b/docs/libcurl/curl_global_trace.md
index 4f011d32e..a76462570 100644
--- a/docs/libcurl/curl_global_trace.md
+++ b/docs/libcurl/curl_global_trace.md
@@ -9,6 +9,7 @@ See-also:
   - libcurl (3)
 Protocol:
   - All
+Added-in: 8.3
 ---
 
 # NAME
@@ -108,6 +109,8 @@ Traces reading of upload data from the application in order to send it to the se
 
 Traces writing of download data, received from the server, to the application.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -131,9 +134,7 @@ of an enabled component appears at the beginning in brackets.
 ...
 ~~~
 
-# AVAILABILITY
-
-Added in 8.3
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_mime_addpart.md b/docs/libcurl/curl_mime_addpart.md
index 53aea78b8..9a21295d5 100644
--- a/docs/libcurl/curl_mime_addpart.md
+++ b/docs/libcurl/curl_mime_addpart.md
@@ -19,6 +19,7 @@ Protocol:
   - HTTP
   - IMAP
   - SMTP
+Added-in: 7.56.0
 ---
 
 # NAME
@@ -42,6 +43,8 @@ subsequently be populated using functions from the mime API.
 *mime* is the handle of the mime structure in which the new part must be
 appended.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -65,9 +68,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-As long as at least one of HTTP, SMTP or IMAP is enabled. Added in 7.56.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_mime_data.md b/docs/libcurl/curl_mime_data.md
index a7f0571a9..5db64a951 100644
--- a/docs/libcurl/curl_mime_data.md
+++ b/docs/libcurl/curl_mime_data.md
@@ -13,6 +13,7 @@ Protocol:
   - HTTP
   - IMAP
   - SMTP
+Added-in: 7.56.0
 ---
 
 # NAME
@@ -49,6 +50,8 @@ last call is retained. It is possible to unassign part's contents by setting
 Setting large data is memory consuming: one might consider using
 curl_mime_data_cb(3) in such a case.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -71,9 +74,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-As long as at least one of HTTP, SMTP or IMAP is enabled. Added in 7.56.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_mime_data_cb.md b/docs/libcurl/curl_mime_data_cb.md
index e63ae42f2..f85e23e96 100644
--- a/docs/libcurl/curl_mime_data_cb.md
+++ b/docs/libcurl/curl_mime_data_cb.md
@@ -13,6 +13,7 @@ Protocol:
   - HTTP
   - IMAP
   - SMTP
+Added-in: 7.56.0
 ---
 
 # NAME
@@ -97,6 +98,8 @@ the pointed item to be shared between the original and the copied handle. In
 particular, special attention should be given to the *freefunc* procedure
 code since it then gets called twice with the same argument.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 Sending a huge data string causes the same amount of memory to be allocated:
@@ -163,9 +166,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-As long as at least one of HTTP, SMTP or IMAP is enabled. Added in 7.56.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_mime_encoder.md b/docs/libcurl/curl_mime_encoder.md
index 8bd6bbdf2..1479bd7ff 100644
--- a/docs/libcurl/curl_mime_encoder.md
+++ b/docs/libcurl/curl_mime_encoder.md
@@ -12,6 +12,7 @@ Protocol:
   - HTTP
   - IMAP
   - SMTP
+Added-in: 7.56.0
 ---
 
 # NAME
@@ -70,6 +71,8 @@ Encoding should not be applied to multiparts, thus the use of this function on
 a part with content set with curl_mime_subparts(3) is strongly
 discouraged.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -95,9 +98,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-As long as at least one of HTTP, SMTP or IMAP is enabled. Added in 7.56.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_mime_filedata.md b/docs/libcurl/curl_mime_filedata.md
index 3f4640911..079330ed9 100644
--- a/docs/libcurl/curl_mime_filedata.md
+++ b/docs/libcurl/curl_mime_filedata.md
@@ -13,6 +13,7 @@ Protocol:
   - HTTP
   - IMAP
   - SMTP
+Added-in: 7.56.0
 ---
 
 # NAME
@@ -55,6 +56,8 @@ part is transferred using chunks by HTTP but is rejected by IMAP.
 Setting a part's contents multiple times is valid: only the value set by the
 last call is retained.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -80,9 +83,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-As long as at least one of HTTP, SMTP or IMAP is enabled. Added in 7.56.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_mime_filename.md b/docs/libcurl/curl_mime_filename.md
index d642a6683..cfaeada8e 100644
--- a/docs/libcurl/curl_mime_filename.md
+++ b/docs/libcurl/curl_mime_filename.md
@@ -12,6 +12,7 @@ Protocol:
   - HTTP
   - IMAP
   - SMTP
+Added-in: 7.56.0
 ---
 
 # NAME
@@ -43,6 +44,8 @@ The remote filename string is copied into the part, thus the associated
 storage may safely be released or reused after call. Setting a part's file
 name multiple times is valid: only the value set by the last call is retained.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -74,9 +77,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-As long as at least one of HTTP, SMTP or IMAP is enabled. Added in 7.56.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_mime_free.md b/docs/libcurl/curl_mime_free.md
index 92106c33b..851b1c521 100644
--- a/docs/libcurl/curl_mime_free.md
+++ b/docs/libcurl/curl_mime_free.md
@@ -11,6 +11,7 @@ Protocol:
   - HTTP
   - IMAP
   - SMTP
+Added-in: 7.56.0
 ---
 
 # NAME
@@ -42,6 +43,8 @@ curl_mime_init(3) and may be NULL.
 Passing in a NULL pointer in *mime* makes this function return immediately
 with no action.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-As long as at least one of HTTP, SMTP or IMAP is enabled. Added in 7.56.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_mime_headers.md b/docs/libcurl/curl_mime_headers.md
index 77669ac59..996266112 100644
--- a/docs/libcurl/curl_mime_headers.md
+++ b/docs/libcurl/curl_mime_headers.md
@@ -11,6 +11,7 @@ Protocol:
   - HTTP
   - IMAP
   - SMTP
+Added-in: 7.56.0
 ---
 
 # NAME
@@ -42,6 +43,8 @@ freed explicitly.
 Setting a part's custom headers list multiple times is valid: only the value
 set by the last call is retained.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -73,9 +76,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-As long as at least one of HTTP, SMTP or IMAP is enabled. Added in 7.56.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_mime_init.md b/docs/libcurl/curl_mime_init.md
index 6702021ad..7d1513dfb 100644
--- a/docs/libcurl/curl_mime_init.md
+++ b/docs/libcurl/curl_mime_init.md
@@ -13,6 +13,7 @@ Protocol:
   - HTTP
   - IMAP
   - SMTP
+Added-in: 7.56.0
 ---
 
 # NAME
@@ -41,6 +42,8 @@ reporting. Since 7.87.0, it does not need to be the final target handle.
 Using a mime handle is the recommended way to post an HTTP form, format and
 send a multi-part email with SMTP or upload such an email to an IMAP server.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -67,9 +70,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-As long as at least one of HTTP, SMTP or IMAP is enabled. Added in 7.56.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_mime_name.md b/docs/libcurl/curl_mime_name.md
index 7f0d308f4..862784431 100644
--- a/docs/libcurl/curl_mime_name.md
+++ b/docs/libcurl/curl_mime_name.md
@@ -12,6 +12,7 @@ Protocol:
   - HTTP
   - IMAP
   - SMTP
+Added-in: 7.56.0
 ---
 
 # NAME
@@ -40,6 +41,8 @@ safely be released or reused after call. Setting a part's name multiple times
 is valid: only the value set by the last call is retained. It is possible to
 reset the name of a part by setting *name* to NULL.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -62,9 +65,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-As long as at least one of HTTP, SMTP or IMAP is enabled. Added in 7.56.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_mime_subparts.md b/docs/libcurl/curl_mime_subparts.md
index 9c57297af..8056a3350 100644
--- a/docs/libcurl/curl_mime_subparts.md
+++ b/docs/libcurl/curl_mime_subparts.md
@@ -11,6 +11,7 @@ Protocol:
   - HTTP
   - IMAP
   - SMTP
+Added-in: 7.56.0
 ---
 
 # NAME
@@ -41,6 +42,8 @@ Setting a part's contents multiple times is valid: only the value set by the
 last call is retained. It is possible to unassign previous part's contents by
 setting *subparts* to NULL.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -78,9 +81,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-As long as at least one of HTTP, SMTP or IMAP is enabled. Added in 7.56.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_mime_type.md b/docs/libcurl/curl_mime_type.md
index 59ac01950..76f3d710d 100644
--- a/docs/libcurl/curl_mime_type.md
+++ b/docs/libcurl/curl_mime_type.md
@@ -12,6 +12,7 @@ Protocol:
   - HTTP
   - IMAP
   - SMTP
+Added-in: 7.56.0
 ---
 
 # NAME
@@ -53,6 +54,8 @@ extension, or application/octet-stream by default.
 
 - text/plain in other cases.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -81,9 +84,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-As long as at least one of HTTP, SMTP or IMAP is enabled. Added in 7.56.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_mprintf.md b/docs/libcurl/curl_mprintf.md
index b98bcec21..ef88e4ed2 100644
--- a/docs/libcurl/curl_mprintf.md
+++ b/docs/libcurl/curl_mprintf.md
@@ -11,11 +11,12 @@ See-also:
   - vprintf (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
 
-curl_maprintf, curl_mfprintf, curl_mprintf, curl_msnprintf, curl_msprintf
+curl_maprintf, curl_mfprintf, curl_mprintf, curl_msnprintf, curl_msprintf,
 curl_mvaprintf, curl_mvfprintf, curl_mvprintf, curl_mvsnprintf,
 curl_mvsprintf - formatted output conversion
 
@@ -263,6 +264,8 @@ by the corresponding argument.
 
 A '%' symbol is written. No argument is converted.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -275,10 +278,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-These functions might be removed from the public libcurl API in the future. Do
-not use them in new programs or projects.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_add_handle.md b/docs/libcurl/curl_multi_add_handle.md
index 3f6120fc4..9082e9c48 100644
--- a/docs/libcurl/curl_multi_add_handle.md
+++ b/docs/libcurl/curl_multi_add_handle.md
@@ -12,6 +12,7 @@ See-also:
   - curl_multi_socket_action (3)
 Protocol:
   - All
+Added-in: 7.9.6
 ---
 
 # NAME
@@ -63,6 +64,8 @@ first the easy handle and then the multi handle:
 
 3 - curl_multi_cleanup(3)
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -81,9 +84,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.9.6
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_assign.md b/docs/libcurl/curl_multi_assign.md
index dd32b36b0..507291004 100644
--- a/docs/libcurl/curl_multi_assign.md
+++ b/docs/libcurl/curl_multi_assign.md
@@ -9,6 +9,7 @@ See-also:
   - curl_multi_socket_action (3)
 Protocol:
   - All
+Added-in: 7.15.5
 ---
 
 # NAME
@@ -47,6 +48,8 @@ functionality.
 
 It is acceptable to call this function from your multi callback functions.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -63,14 +66,6 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.15.5
-
-# RETURN VALUE
-
-The standard CURLMcode for multi interface error codes.
-
 # TYPICAL USAGE
 
 In a typical application you allocate a struct or at least use some kind of
@@ -78,6 +73,12 @@ semi-dynamic data for each socket that we must wait for action on when using
 the curl_multi_socket_action(3) approach.
 
 When our socket-callback gets called by libcurl and we get to know about yet
-another socket to wait for, we can use curl_multi_assign(3) to point out
-the particular data so that when we get updates about this same socket again,
-we do not have to find the struct associated with this socket by ourselves.
+another socket to wait for, we can use curl_multi_assign(3) to point out the
+particular data so that when we get updates about this same socket again, we
+do not have to find the struct associated with this socket by ourselves.
+
+# %AVAILABILITY%
+
+# RETURN VALUE
+
+The standard CURLMcode for multi interface error codes.
diff --git a/docs/libcurl/curl_multi_cleanup.md b/docs/libcurl/curl_multi_cleanup.md
index e8e02a4b0..fb56e6468 100644
--- a/docs/libcurl/curl_multi_cleanup.md
+++ b/docs/libcurl/curl_multi_cleanup.md
@@ -11,6 +11,7 @@ See-also:
   - curl_multi_init (3)
 Protocol:
   - All
+Added-in: 7.9.6
 ---
 
 # NAME
@@ -27,10 +28,10 @@ CURLMcode curl_multi_cleanup(CURLM *multi_handle);
 
 # DESCRIPTION
 
-Cleans up and removes a whole multi stack. It does not free or touch any
-individual easy handles in any way - they still need to be closed
-individually, using the usual curl_easy_cleanup(3) way. The order of
-cleaning up should be:
+This function is the opposite of curl_multi_init(3). Cleans up and removes a
+whole multi stack. It does not free or touch any individual easy handles in
+any way - they still need to be closed individually, using the usual
+curl_easy_cleanup(3) way. The order of cleaning up should be:
 
 1 - curl_multi_remove_handle(3) before any easy handles are cleaned up
 
@@ -43,6 +44,10 @@ removed
 Passing in a NULL pointer in *multi_handle* makes this function return
 CURLM_BAD_HANDLE immediately with no other action.
 
+Any use of the **multi_handle** after this function has been called and have
+returned, is illegal.
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,9 +62,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.9.6
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_fdset.md b/docs/libcurl/curl_multi_fdset.md
index 78299610c..e1b869411 100644
--- a/docs/libcurl/curl_multi_fdset.md
+++ b/docs/libcurl/curl_multi_fdset.md
@@ -14,11 +14,12 @@ See-also:
   - select (2)
 Protocol:
   - All
+Added-in: 7.9.6
 ---
 
 # NAME
 
-curl_multi_fdset - extracts file descriptor information from a multi handle
+curl_multi_fdset - extract file descriptor information from a multi handle
 
 # SYNOPSIS
 
@@ -78,6 +79,8 @@ which can cause crashes, or worse. The effect of NOT storing it might possibly
 save you from the crash, but makes your program NOT wait for sockets it should
 wait for...
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -112,9 +115,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.9.6
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_get_handles.md b/docs/libcurl/curl_multi_get_handles.md
index a0b4bfb9c..f94436a88 100644
--- a/docs/libcurl/curl_multi_get_handles.md
+++ b/docs/libcurl/curl_multi_get_handles.md
@@ -11,11 +11,12 @@ See-also:
   - curl_multi_remove_handle (3)
 Protocol:
   - All
+Added-in: 8.4.0
 ---
 
 # NAME
 
-curl_multi_get_handles - returns all added easy handles
+curl_multi_get_handles - return all added easy handles
 
 # SYNOPSIS
 
@@ -42,6 +43,8 @@ The order of the easy handles within the array is not guaranteed.
 
 The returned array must be freed with a call to curl_free(3) after use.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -70,9 +73,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 8.4.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_info_read.md b/docs/libcurl/curl_multi_info_read.md
index 0ba3ee352..3a8af88d0 100644
--- a/docs/libcurl/curl_multi_info_read.md
+++ b/docs/libcurl/curl_multi_info_read.md
@@ -10,6 +10,7 @@ See-also:
   - curl_multi_perform (3)
 Protocol:
   - All
+Added-in: 7.9.6
 ---
 
 # NAME
@@ -66,6 +67,8 @@ that just completed.
 
 At this point, there are no other **msg** types defined.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -93,9 +96,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.9.6
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_init.md b/docs/libcurl/curl_multi_init.md
index 043198557..7c3dac843 100644
--- a/docs/libcurl/curl_multi_init.md
+++ b/docs/libcurl/curl_multi_init.md
@@ -12,6 +12,7 @@ See-also:
   - curl_multi_get_handles (3)
 Protocol:
   - All
+Added-in: 7.9.6
 ---
 
 # NAME
@@ -33,6 +34,8 @@ all the other multi-functions, sometimes referred to as a multi handle in some
 places in the documentation. This init call MUST have a corresponding call to
 curl_multi_cleanup(3) when the operation is complete.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -49,9 +52,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.9.6
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_perform.md b/docs/libcurl/curl_multi_perform.md
index eebed6e7d..9b854d146 100644
--- a/docs/libcurl/curl_multi_perform.md
+++ b/docs/libcurl/curl_multi_perform.md
@@ -14,11 +14,12 @@ See-also:
   - libcurl-errors (3)
 Protocol:
   - All
+Added-in: 7.9.6
 ---
 
 # NAME
 
-curl_multi_perform - reads/writes available data from easy handles
+curl_multi_perform - run all transfers until it would block
 
 # SYNOPSIS
 
@@ -60,6 +61,8 @@ they cannot be continued. curl_multi_perform(3) should not be called
 again on the same multi handle after an error has been returned, unless first
 removing all the handles and adding new ones.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -88,9 +91,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.9.6
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_poll.md b/docs/libcurl/curl_multi_poll.md
index 360e14d8e..2c2ccee6e 100644
--- a/docs/libcurl/curl_multi_poll.md
+++ b/docs/libcurl/curl_multi_poll.md
@@ -11,11 +11,12 @@ See-also:
   - curl_multi_wakeup (3)
 Protocol:
   - All
+Added-in: 7.66.0
 ---
 
 # NAME
 
-curl_multi_poll - polls on all easy handles in a multi handle
+curl_multi_poll - poll on all easy handles in a multi handle
 
 # SYNOPSIS
 
@@ -86,6 +87,8 @@ priority read events such as out of band data.
 Bit flag to curl_waitfd.events indicating the socket should poll on write
 events such as the socket being clear to write without blocking.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -94,6 +97,7 @@ int main(void)
   CURL *easy_handle;
   CURLM *multi_handle;
   int still_running = 0;
+  int myfd; /* this is our own file descriptor */
 
   /* add the individual easy handle */
   curl_multi_add_handle(multi_handle, easy_handle);
@@ -105,8 +109,19 @@ int main(void)
     mc = curl_multi_perform(multi_handle, &still_running);
 
     if(mc == CURLM_OK) {
-      /* wait for activity or timeout */
-      mc = curl_multi_poll(multi_handle, NULL, 0, 1000, &numfds);
+      struct curl_waitfd myown;
+      myown.fd = myfd;
+      myown.events = CURL_WAIT_POLLIN; /* wait for input */
+      myown.revents = 0; /* clear it */
+
+      /* wait for activity on curl's descriptors or on our own,
+         or timeout */
+      mc = curl_multi_poll(multi_handle, &myown, 1, 1000, &numfds);
+
+      if(myown.revents) {
+        /* did our descriptor receive an event? */
+        handle_fd(myfd);
+      }
     }
 
     if(mc != CURLM_OK) {
@@ -120,9 +135,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.66.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_remove_handle.md b/docs/libcurl/curl_multi_remove_handle.md
index b026466ac..ac43a592e 100644
--- a/docs/libcurl/curl_multi_remove_handle.md
+++ b/docs/libcurl/curl_multi_remove_handle.md
@@ -10,6 +10,7 @@ See-also:
   - curl_multi_init (3)
 Protocol:
   - All
+Added-in: 7.9.6
 ---
 
 # NAME
@@ -46,6 +47,8 @@ libcurl keeps the connection alive in the connection pool associated with the
 multi handle, ready to get reused for a future transfer using this multi
 handle.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -66,9 +69,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.9.6
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_setopt.md b/docs/libcurl/curl_multi_setopt.md
index 399060fc2..3f326be76 100644
--- a/docs/libcurl/curl_multi_setopt.md
+++ b/docs/libcurl/curl_multi_setopt.md
@@ -11,6 +11,7 @@ See-also:
   - curl_multi_socket (3)
 Protocol:
   - All
+Added-in: 7.15.4
 ---
 
 # NAME
@@ -22,85 +23,88 @@ curl_multi_setopt - set options for a curl multi handle
 ~~~c
 #include <curl/curl.h>
 
-CURLMcode curl_multi_setopt(CURLM *multi_handle, CURLMoption option, parameter);
+CURLMcode curl_multi_setopt(CURLM *multi, CURLMoption option, parameter);
 ~~~
 
 # DESCRIPTION
 
-curl_multi_setopt(3) is used to tell a libcurl multi handle how to
-behave. By using the appropriate options to curl_multi_setopt(3), you
-can change libcurl's behavior when using that multi handle. All options are
-set with the *option* followed by the *parameter*. That parameter can
-be a **long**, a **function pointer**, an **object pointer** or a
-**curl_off_t** type, depending on what the specific option expects. Read
-this manual carefully as bad input values may cause libcurl to behave
-badly. You can only set one option in each function call.
+curl_multi_setopt(3) is used to tell a libcurl multi handle how to behave. By
+using the appropriate options to curl_multi_setopt(3), you can change
+libcurl's behavior when using that multi handle. All options are set with the
+*option* followed by the *parameter*. That parameter can be a **long**, a
+**function pointer**, an **object pointer** or a **curl_off_t** type,
+depending on what the specific option expects. Read this manual carefully as
+bad input values may cause libcurl to behave badly. You can only set one
+option in each function call.
 
 # OPTIONS
 
 ## CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE
 
-See CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE(3)
+**deprecated** See CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE(3)
 
 ## CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE
 
-See CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE(3)
+**deprecated** See CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE(3)
 
-## CURLMOPT_MAX_HOST_CONNECTIONS
+## CURLMOPT_MAXCONNECTS
 
-See CURLMOPT_MAX_HOST_CONNECTIONS(3)
+Size of connection cache. See CURLMOPT_MAXCONNECTS(3)
 
-## CURLMOPT_MAX_PIPELINE_LENGTH
+## CURLMOPT_MAX_CONCURRENT_STREAMS
 
-See CURLMOPT_MAX_PIPELINE_LENGTH(3)
+Max concurrent streams for http2. See CURLMOPT_MAX_CONCURRENT_STREAMS(3)
 
-## CURLMOPT_MAX_TOTAL_CONNECTIONS
+## CURLMOPT_MAX_HOST_CONNECTIONS
 
-See CURLMOPT_MAX_TOTAL_CONNECTIONS(3)
+Max number of connections to a single host. See
+CURLMOPT_MAX_HOST_CONNECTIONS(3)
 
-## CURLMOPT_MAXCONNECTS
+## CURLMOPT_MAX_PIPELINE_LENGTH
 
-See CURLMOPT_MAXCONNECTS(3)
+**deprecated**. See CURLMOPT_MAX_PIPELINE_LENGTH(3)
 
-## CURLMOPT_PIPELINING
+## CURLMOPT_MAX_TOTAL_CONNECTIONS
 
-See CURLMOPT_PIPELINING(3)
+Max simultaneously open connections. See CURLMOPT_MAX_TOTAL_CONNECTIONS(3)
 
-## CURLMOPT_PIPELINING_SITE_BL
+## CURLMOPT_PIPELINING
 
-See CURLMOPT_PIPELINING_SITE_BL(3)
+Enable HTTP multiplexing. See CURLMOPT_PIPELINING(3)
 
 ## CURLMOPT_PIPELINING_SERVER_BL
 
-See CURLMOPT_PIPELINING_SERVER_BL(3)
+**deprecated**. See CURLMOPT_PIPELINING_SERVER_BL(3)
 
-## CURLMOPT_PUSHFUNCTION
+## CURLMOPT_PIPELINING_SITE_BL
 
-See CURLMOPT_PUSHFUNCTION(3)
+**deprecated**. See CURLMOPT_PIPELINING_SITE_BL(3)
 
 ## CURLMOPT_PUSHDATA
 
-See CURLMOPT_PUSHDATA(3)
+Pointer to pass to push callback. See CURLMOPT_PUSHDATA(3)
 
-## CURLMOPT_SOCKETFUNCTION
+## CURLMOPT_PUSHFUNCTION
 
-See CURLMOPT_SOCKETFUNCTION(3)
+Callback that approves or denies server pushes. See CURLMOPT_PUSHFUNCTION(3)
 
 ## CURLMOPT_SOCKETDATA
 
-See CURLMOPT_SOCKETDATA(3)
+Custom pointer passed to the socket callback. See CURLMOPT_SOCKETDATA(3)
 
-## CURLMOPT_TIMERFUNCTION
+## CURLMOPT_SOCKETFUNCTION
 
-See CURLMOPT_TIMERFUNCTION(3)
+Callback informed about what to wait for. See CURLMOPT_SOCKETFUNCTION(3)
 
 ## CURLMOPT_TIMERDATA
 
-See CURLMOPT_TIMERDATA(3)
+Custom pointer to pass to timer callback. See CURLMOPT_TIMERDATA(3)
 
-## CURLMOPT_MAX_CONCURRENT_STREAMS
+## CURLMOPT_TIMERFUNCTION
 
-See CURLMOPT_MAX_CONCURRENT_STREAMS(3)
+Callback to receive timeout values. See CURLMOPT_TIMERFUNCTION(3)
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -116,9 +120,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.15.4
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_socket.md b/docs/libcurl/curl_multi_socket.md
index 4c85d0199..53fe2f7ee 100644
--- a/docs/libcurl/curl_multi_socket.md
+++ b/docs/libcurl/curl_multi_socket.md
@@ -12,11 +12,12 @@ See-also:
   - the hiperfifo.c example
 Protocol:
   - All
+Added-in: 7.15.4
 ---
 
 # NAME
 
-curl_multi_socket - reads/writes available data
+curl_multi_socket - read/write available data
 
 # SYNOPSIS
 
@@ -24,47 +25,39 @@ curl_multi_socket - reads/writes available data
 #include <curl/curl.h>
 CURLMcode curl_multi_socket(CURLM *multi_handle, curl_socket_t sockfd,
                             int *running_handles);
-
-CURLMcode curl_multi_socket_all(CURLM *multi_handle,
-                                int *running_handles);
 ~~~
 
 # DESCRIPTION
 
-These functions are deprecated. Do not use. See
-curl_multi_socket_action(3) instead.
+This function is deprecated. Do not use. See curl_multi_socket_action(3)
+instead.
 
 At return, the integer **running_handles** points to contains the number of
 still running easy handles within the multi handle. When this number reaches
 zero, all transfers are complete/done. Note that when you call
-curl_multi_socket_action(3) on a specific socket and the counter
-decreases by one, it DOES NOT necessarily mean that this exact socket/transfer
-is the one that completed. Use curl_multi_info_read(3) to figure out
-which easy handle that completed.
-
-The curl_multi_socket_action(3) functions inform the application about
-updates in the socket (file descriptor) status by doing none, one, or multiple
-calls to the socket callback function set with the
-CURLMOPT_SOCKETFUNCTION(3) option to curl_multi_setopt(3). They
-update the status with changes since the previous time the callback was
-called.
-
-Get the timeout time by setting the CURLMOPT_TIMERFUNCTION(3) option
-with curl_multi_setopt(3). Your application then gets called with
-information on how long to wait for socket actions at most before doing the
-timeout action: call the curl_multi_socket_action(3) function with the
-**sockfd** argument set to CURL_SOCKET_TIMEOUT. You can also use the
-curl_multi_timeout(3) function to poll the value at any given time, but
-for an event-based system using the callback is far better than relying on
-polling the timeout value.
+curl_multi_socket(3) on a specific socket and the counter decreases by one, it
+DOES NOT necessarily mean that this exact socket/transfer is the one that
+completed. Use curl_multi_info_read(3) to figure out which easy handle that
+completed.
+
+The curl_multi_socket(3) functions inform the application about updates in the
+socket (file descriptor) status by doing none, one, or multiple calls to the
+socket callback function set with the CURLMOPT_SOCKETFUNCTION(3) option to
+curl_multi_setopt(3). They update the status with changes since the previous
+time the callback was called.
+
+Get the timeout time by setting the CURLMOPT_TIMERFUNCTION(3) option with
+curl_multi_setopt(3). Your application then gets called with information on
+how long to wait for socket actions at most before doing the timeout action:
+call the curl_multi_socket_action(3) function with the **sockfd** argument set
+to CURL_SOCKET_TIMEOUT. You can also use the curl_multi_timeout(3) function to
+poll the value at any given time, but for an event-based system using the
+callback is far better than relying on polling the timeout value.
 
 Usage of curl_multi_socket(3) is deprecated, whereas the function is
-equivalent to curl_multi_socket_action(3) with **ev_bitmask** set to
-0.
+equivalent to curl_multi_socket_action(3) with **ev_bitmask** set to 0.
 
-Force libcurl to (re-)check all its internal sockets and transfers instead of
-just a single one by calling curl_multi_socket_all(3). Note that there
-should not be any reason to use this function.
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -81,13 +74,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
 
-This function was added in libcurl 7.15.4, and is deemed stable since
-7.16.0.
+curl_multi_socket(3) is deprecated, use curl_multi_socket_action(3) instead!
 
-curl_multi_socket(3) is deprecated, use
-curl_multi_socket_action(3) instead!
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_socket_action.md b/docs/libcurl/curl_multi_socket_action.md
index c7faa7637..536bf3cb6 100644
--- a/docs/libcurl/curl_multi_socket_action.md
+++ b/docs/libcurl/curl_multi_socket_action.md
@@ -12,11 +12,12 @@ See-also:
   - the hiperfifo.c example
 Protocol:
   - All
+Added-in: 7.15.4
 ---
 
 # NAME
 
-curl_multi_socket_action - reads/writes available data given an action
+curl_multi_socket_action - read/write available data given an action
 
 # SYNOPSIS
 
@@ -95,6 +96,8 @@ callback has been told.
 socket(s) that got action. If no activity is detected and the timeout expires,
 call curl_multi_socket_action(3) with *CURL_SOCKET_TIMEOUT*.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -112,9 +115,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-This function was added in libcurl 7.15.4, and is deemed stable since 7.16.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_socket_all.md b/docs/libcurl/curl_multi_socket_all.md
index 4c85d0199..37a605bde 100644
--- a/docs/libcurl/curl_multi_socket_all.md
+++ b/docs/libcurl/curl_multi_socket_all.md
@@ -1,7 +1,7 @@
 ---
 c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
-Title: curl_multi_socket
+Title: curl_multi_socket_all
 Section: 3
 Source: libcurl
 See-also:
@@ -12,18 +12,17 @@ See-also:
   - the hiperfifo.c example
 Protocol:
   - All
+Added-in: 7.15.4
 ---
 
 # NAME
 
-curl_multi_socket - reads/writes available data
+curl_multi_socket_all - reads/writes available data for all easy handles
 
 # SYNOPSIS
 
 ~~~c
 #include <curl/curl.h>
-CURLMcode curl_multi_socket(CURLM *multi_handle, curl_socket_t sockfd,
-                            int *running_handles);
 
 CURLMcode curl_multi_socket_all(CURLM *multi_handle,
                                 int *running_handles);
@@ -31,63 +30,32 @@ CURLMcode curl_multi_socket_all(CURLM *multi_handle,
 
 # DESCRIPTION
 
-These functions are deprecated. Do not use. See
-curl_multi_socket_action(3) instead.
+This function is deprecated. Do not use. See curl_multi_socket_action(3)
+instead.
 
 At return, the integer **running_handles** points to contains the number of
 still running easy handles within the multi handle. When this number reaches
-zero, all transfers are complete/done. Note that when you call
-curl_multi_socket_action(3) on a specific socket and the counter
-decreases by one, it DOES NOT necessarily mean that this exact socket/transfer
-is the one that completed. Use curl_multi_info_read(3) to figure out
-which easy handle that completed.
-
-The curl_multi_socket_action(3) functions inform the application about
-updates in the socket (file descriptor) status by doing none, one, or multiple
-calls to the socket callback function set with the
-CURLMOPT_SOCKETFUNCTION(3) option to curl_multi_setopt(3). They
-update the status with changes since the previous time the callback was
-called.
-
-Get the timeout time by setting the CURLMOPT_TIMERFUNCTION(3) option
-with curl_multi_setopt(3). Your application then gets called with
-information on how long to wait for socket actions at most before doing the
-timeout action: call the curl_multi_socket_action(3) function with the
-**sockfd** argument set to CURL_SOCKET_TIMEOUT. You can also use the
-curl_multi_timeout(3) function to poll the value at any given time, but
-for an event-based system using the callback is far better than relying on
-polling the timeout value.
-
-Usage of curl_multi_socket(3) is deprecated, whereas the function is
-equivalent to curl_multi_socket_action(3) with **ev_bitmask** set to
-0.
+zero, all transfers are complete/done.
 
 Force libcurl to (re-)check all its internal sockets and transfers instead of
-just a single one by calling curl_multi_socket_all(3). Note that there
-should not be any reason to use this function.
+just a single one by calling curl_multi_socket_all(3). Note that there should
+not be any reason to use this function.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
 ~~~c
 int main(void)
 {
-  /* the event-library gets told when there activity on the socket 'fd',
-     which we translate to a call to curl_multi_socket_action() */
   int running;
   int rc;
-  int fd;
   CURLM *multi;
-  rc = curl_multi_socket(multi, fd, &running);
+  rc = curl_multi_socket_all(multi, &running);
 }
 ~~~
 
-# AVAILABILITY
-
-This function was added in libcurl 7.15.4, and is deemed stable since
-7.16.0.
-
-curl_multi_socket(3) is deprecated, use
-curl_multi_socket_action(3) instead!
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_strerror.md b/docs/libcurl/curl_multi_strerror.md
index 4b53d6787..d419ab2e8 100644
--- a/docs/libcurl/curl_multi_strerror.md
+++ b/docs/libcurl/curl_multi_strerror.md
@@ -11,6 +11,7 @@ See-also:
   - libcurl-errors (3)
 Protocol:
   - All
+Added-in: 7.12.0
 ---
 
 # NAME
@@ -30,6 +31,8 @@ const char *curl_multi_strerror(CURLMcode errornum);
 This function returns a string describing the *CURLMcode* error code
 passed in the argument *errornum*.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -44,9 +47,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-This function was added in libcurl 7.12.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_timeout.md b/docs/libcurl/curl_multi_timeout.md
index ed8a8acbc..de59c3920 100644
--- a/docs/libcurl/curl_multi_timeout.md
+++ b/docs/libcurl/curl_multi_timeout.md
@@ -11,6 +11,7 @@ See-also:
   - curl_multi_socket (3)
 Protocol:
   - All
+Added-in: 7.15.4
 ---
 
 # NAME
@@ -48,6 +49,8 @@ Note: if libcurl returns a -1 timeout here, it just means that libcurl
 currently has no stored timeout value. You must not wait too long (more than a
 few seconds perhaps) before you call curl_multi_perform(3) again.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -82,9 +85,7 @@ out which sockets to wait for by calling curl_multi_fdset(3).
 When there is activity or timeout, call curl_multi_perform(3) and then
 loop - until all transfers are complete.
 
-# AVAILABILITY
-
-This function was added in libcurl 7.15.4.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_wait.md b/docs/libcurl/curl_multi_wait.md
index 7440d7b3d..7e9553d76 100644
--- a/docs/libcurl/curl_multi_wait.md
+++ b/docs/libcurl/curl_multi_wait.md
@@ -10,11 +10,12 @@ See-also:
   - curl_multi_poll (3)
 Protocol:
   - All
+Added-in: 7.28.0
 ---
 
 # NAME
 
-curl_multi_wait - polls on all easy handles in a multi handle
+curl_multi_wait - poll on all easy handles in a multi handle
 
 # SYNOPSIS
 
@@ -79,6 +80,8 @@ priority read events such as out of band data.
 Bit flag to *curl_waitfd.events* indicating the socket should poll on
 write events such as the socket being clear to write without blocking.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -113,9 +116,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-This function was added in libcurl 7.28.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_waitfds.md b/docs/libcurl/curl_multi_waitfds.md
index 3e4c26091..a64223027 100644
--- a/docs/libcurl/curl_multi_waitfds.md
+++ b/docs/libcurl/curl_multi_waitfds.md
@@ -1,5 +1,5 @@
 ---
-c: Copyright (C) Daniel Stenberg, <daniel.se>, et al.
+c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
 Title: curl_multi_waitfds
 Section: 3
@@ -11,11 +11,12 @@ See-also:
   - curl_multi_fdset (3)
 Protocol:
   - All
+Added-in: 8.8.0
 ---
 
 # NAME
 
-curl_multi_waitfds - extracts file descriptor information from a multi handle
+curl_multi_waitfds - extract file descriptor information from a multi handle
 
 # SYNOPSIS
 
@@ -51,6 +52,8 @@ The client code can pass *size* equal to zero just to get the number of the
 descriptors and allocate appropriate storage for them to be used in a
 subsequent function call.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -99,9 +102,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 8.8.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_multi_wakeup.md b/docs/libcurl/curl_multi_wakeup.md
index cadaeaa31..a920847a6 100644
--- a/docs/libcurl/curl_multi_wakeup.md
+++ b/docs/libcurl/curl_multi_wakeup.md
@@ -9,11 +9,12 @@ See-also:
   - curl_multi_wait (3)
 Protocol:
   - All
+Added-in: 7.68.0
 ---
 
 # NAME
 
-curl_multi_wakeup - wakes up a sleeping curl_multi_poll call
+curl_multi_wakeup - wake up a sleeping curl_multi_poll call
 
 # SYNOPSIS
 
@@ -38,6 +39,8 @@ that multiple calls to this function wake up the same waiting operation.
 
 This function has no effect on curl_multi_wait(3) calls.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -84,9 +87,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.68.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_pushheader_byname.md b/docs/libcurl/curl_pushheader_byname.md
index 700f51106..d066ea7b8 100644
--- a/docs/libcurl/curl_pushheader_byname.md
+++ b/docs/libcurl/curl_pushheader_byname.md
@@ -9,6 +9,7 @@ See-also:
   - curl_pushheader_bynum (3)
 Protocol:
   - HTTP
+Added-in: 7.44.0
 ---
 
 # NAME
@@ -35,6 +36,8 @@ not have to loop through all headers to find the one it is interested in. The
 data this function points to is freed when this callback returns. If more than
 one header field use the same name, this returns only the first one.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -75,9 +78,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.44.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_pushheader_bynum.md b/docs/libcurl/curl_pushheader_bynum.md
index f39836fc5..12555c57f 100644
--- a/docs/libcurl/curl_pushheader_bynum.md
+++ b/docs/libcurl/curl_pushheader_bynum.md
@@ -9,6 +9,7 @@ See-also:
   - curl_pushheader_byname (3)
 Protocol:
   - HTTP
+Added-in: 7.44.0
 ---
 
 # NAME
@@ -34,6 +35,8 @@ the incoming server push request or NULL. The data pointed to is freed by
 libcurl when this callback returns. The returned pointer points to a
 "name:value" string that gets freed when this callback returns.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -62,9 +65,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.44.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_share_cleanup.md b/docs/libcurl/curl_share_cleanup.md
index 36acc6f08..afb06d008 100644
--- a/docs/libcurl/curl_share_cleanup.md
+++ b/docs/libcurl/curl_share_cleanup.md
@@ -9,11 +9,12 @@ See-also:
   - curl_share_setopt (3)
 Protocol:
   - All
+Added-in: 7.10
 ---
 
 # NAME
 
-curl_share_cleanup - Clean up a shared object
+curl_share_cleanup - close a shared object
 
 # SYNOPSIS
 
@@ -31,6 +32,11 @@ when this function has been called.
 Passing in a NULL pointer in *share_handle* makes this function return
 immediately with no action.
 
+Any use of the **share_handle** after this function has been called and have
+returned, is illegal.
+
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -44,9 +50,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_share_init.md b/docs/libcurl/curl_share_init.md
index 2e74dfed8..deb61733c 100644
--- a/docs/libcurl/curl_share_init.md
+++ b/docs/libcurl/curl_share_init.md
@@ -9,11 +9,12 @@ See-also:
   - curl_share_setopt (3)
 Protocol:
   - All
+Added-in: 7.10
 ---
 
 # NAME
 
-curl_share_init - Create a shared object
+curl_share_init - create a share object
 
 # SYNOPSIS
 
@@ -35,6 +36,8 @@ This *share handle* is what you pass to curl using the
 CURLOPT_SHARE(3) option with curl_easy_setopt(3), to make that
 specific curl handle use the data in this share.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -48,9 +51,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_share_setopt.md b/docs/libcurl/curl_share_setopt.md
index 166f5f6ba..a15955e4c 100644
--- a/docs/libcurl/curl_share_setopt.md
+++ b/docs/libcurl/curl_share_setopt.md
@@ -9,11 +9,12 @@ See-also:
   - curl_share_init (3)
 Protocol:
   - All
+Added-in: 7.10
 ---
 
 # NAME
 
-curl_share_setopt - Set options for a shared object
+curl_share_setopt - set options for a shared object
 
 # SYNOPSIS
 
@@ -49,6 +50,8 @@ See CURLSHOPT_UNSHARE(3).
 
 See CURLSHOPT_USERDATA(3).
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -62,9 +65,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_share_strerror.md b/docs/libcurl/curl_share_strerror.md
index 9137115a2..9c45278f5 100644
--- a/docs/libcurl/curl_share_strerror.md
+++ b/docs/libcurl/curl_share_strerror.md
@@ -11,6 +11,7 @@ See-also:
   - libcurl-errors (3)
 Protocol:
   - All
+Added-in: 7.12.0
 ---
 
 # NAME
@@ -30,6 +31,8 @@ const char *curl_share_strerror(CURLSHcode errornum);
 The curl_share_strerror(3) function returns a string describing the
 *CURLSHcode* error code passed in the argument *errornum*.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -43,9 +46,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-This function was added in libcurl 7.12.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_slist_append.md b/docs/libcurl/curl_slist_append.md
index dd3dabb77..27ec45da1 100644
--- a/docs/libcurl/curl_slist_append.md
+++ b/docs/libcurl/curl_slist_append.md
@@ -8,6 +8,7 @@ See-also:
   - curl_slist_free_all (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -34,6 +35,8 @@ returns. curl_slist_append(3) copies the string.
 The list should be freed again (after usage) with
 curl_slist_free_all(3).
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -65,9 +68,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_slist_free_all.md b/docs/libcurl/curl_slist_free_all.md
index 5f54fabc1..91491aa6c 100644
--- a/docs/libcurl/curl_slist_free_all.md
+++ b/docs/libcurl/curl_slist_free_all.md
@@ -8,6 +8,7 @@ See-also:
   - curl_slist_append (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -30,6 +31,11 @@ linked list.
 Passing in a NULL pointer in *list* makes this function return immediately
 with no action.
 
+Any use of the **list** after this function has been called and have returned,
+is illegal.
+
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -51,9 +57,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_strequal.md b/docs/libcurl/curl_strequal.md
index 70de794aa..e7270d874 100644
--- a/docs/libcurl/curl_strequal.md
+++ b/docs/libcurl/curl_strequal.md
@@ -5,15 +5,17 @@ Title: curl_strequal
 Section: 3
 Source: libcurl
 See-also:
+  - curl_strnequal (3)
   - strcasecmp (3)
   - strcmp (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
 
-curl_strequal, curl_strnequal - case insensitive string comparisons
+curl_strequal - compare two strings ignoring case
 
 # SYNOPSIS
 
@@ -21,21 +23,23 @@ curl_strequal, curl_strnequal - case insensitive string comparisons
 #include <curl/curl.h>
 
 int curl_strequal(const char *str1, const char *str2);
-int curl_strnequal(const char *str1, const char *str2, size_t length);
 ~~~
 
 # DESCRIPTION
 
-The curl_strequal(3) function compares the two strings *str1* and
-*str2*, ignoring the case of the characters. It returns a non-zero (TRUE)
-integer if the strings are identical.
+The curl_strequal(3) function compares the two strings *str1* and *str2*,
+ignoring the case of the characters. It returns a non-zero (TRUE) integer if
+the strings are identical.
 
-The **curl_strnequal()** function is similar, except it only compares the
-first *length* characters of *str1*.
+This function uses plain ASCII based comparisons completely disregarding the
+locale - contrary to how **strcasecmp** and other system case insensitive
+string comparisons usually work.
 
-These functions are provided by libcurl to enable applications to compare
-strings in a truly portable manner. There are no standard portable case
-insensitive string comparison functions. These two work on all platforms.
+This function is provided by libcurl to enable applications to compare strings
+in a truly portable manner. There are no standard portable case insensitive
+string comparison functions. This function works on all platforms.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -45,14 +49,10 @@ int main(int argc, char **argv)
   const char *name = "compare";
   if(curl_strequal(name, argv[1]))
     printf("Name and input matches\n");
-  if(curl_strnequal(name, argv[1], 5))
-    printf("Name and input matches in the 5 first bytes\n");
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_strnequal.md b/docs/libcurl/curl_strnequal.md
index 70de794aa..db42bcdf8 100644
--- a/docs/libcurl/curl_strnequal.md
+++ b/docs/libcurl/curl_strnequal.md
@@ -1,41 +1,48 @@
 ---
 c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
-Title: curl_strequal
+Title: curl_strnequal
 Section: 3
 Source: libcurl
 See-also:
+  - curl_strequal (3)
   - strcasecmp (3)
   - strcmp (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
 
-curl_strequal, curl_strnequal - case insensitive string comparisons
+curl_strnequal - compare two strings ignoring case
 
 # SYNOPSIS
 
 ~~~c
 #include <curl/curl.h>
 
-int curl_strequal(const char *str1, const char *str2);
 int curl_strnequal(const char *str1, const char *str2, size_t length);
 ~~~
 
 # DESCRIPTION
 
-The curl_strequal(3) function compares the two strings *str1* and
-*str2*, ignoring the case of the characters. It returns a non-zero (TRUE)
-integer if the strings are identical.
+The curl_strnequal(3) function compares the two strings *str1* and *str2*,
+ignoring the case of the characters. It returns a non-zero (TRUE) integer if
+the strings are identical.
 
-The **curl_strnequal()** function is similar, except it only compares the
-first *length* characters of *str1*.
+This function compares no more than the first *length* bytes of *str1* and
+*str2*.
 
-These functions are provided by libcurl to enable applications to compare
-strings in a truly portable manner. There are no standard portable case
-insensitive string comparison functions. These two work on all platforms.
+This function uses plain ASCII based comparisons completely disregarding the
+locale - contrary to how **strcasecmp** and other system case insensitive
+string comparisons usually work.
+
+This function is provided by libcurl to enable applications to compare strings
+in a truly portable manner. There are no standard portable case insensitive
+string comparison functions. This function works on all platforms.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -43,16 +50,12 @@ insensitive string comparison functions. These two work on all platforms.
 int main(int argc, char **argv)
 {
   const char *name = "compare";
-  if(curl_strequal(name, argv[1]))
-    printf("Name and input matches\n");
   if(curl_strnequal(name, argv[1], 5))
     printf("Name and input matches in the 5 first bytes\n");
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_unescape.md b/docs/libcurl/curl_unescape.md
index adcce8b14..2600f1436 100644
--- a/docs/libcurl/curl_unescape.md
+++ b/docs/libcurl/curl_unescape.md
@@ -11,11 +11,12 @@ See-also:
   - curl_free (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
 
-curl_unescape - URL decodes the given string
+curl_unescape - URL decode a string
 
 # SYNOPSIS
 
@@ -27,7 +28,7 @@ char *curl_unescape(const char *input, int length);
 
 # DESCRIPTION
 
-Obsolete function. Use curl_easy_unescape(3) instead.
+Deprecated. Use curl_easy_unescape(3) instead.
 
 This function converts the URL encoded string **input** to a "plain string"
 and return that as a new allocated string. All input characters that are URL
@@ -39,6 +40,8 @@ strlen() on **input** to find out the size.
 
 You must curl_free(3) the returned string when you are done with it.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,11 +60,13 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
 
 Since 7.15.4, curl_easy_unescape(3) should be used. This function might
 be removed in a future release.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 A pointer to a null-terminated string or NULL if it failed.
diff --git a/docs/libcurl/curl_url.md b/docs/libcurl/curl_url.md
index acab43d88..5872134e1 100644
--- a/docs/libcurl/curl_url.md
+++ b/docs/libcurl/curl_url.md
@@ -13,11 +13,12 @@ See-also:
   - curl_url_strerror (3)
 Protocol:
   - All
+Added-in: 7.62.0
 ---
 
 # NAME
 
-curl_url - returns a new URL handle
+curl_url - create a URL handle
 
 # SYNOPSIS
 
@@ -37,6 +38,8 @@ single URL. When the object is first created, there is of course no components
 stored. They are then set in the object with the curl_url_set(3)
 function.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,9 +60,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.62.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_url_cleanup.md b/docs/libcurl/curl_url_cleanup.md
index ab0acdce8..80eff3590 100644
--- a/docs/libcurl/curl_url_cleanup.md
+++ b/docs/libcurl/curl_url_cleanup.md
@@ -12,6 +12,7 @@ See-also:
   - curl_url_set (3)
 Protocol:
   - All
+Added-in: 7.62.0
 ---
 
 # NAME
@@ -33,6 +34,11 @@ Frees all the resources associated with the given *CURLU* handle!
 Passing in a NULL pointer in *handle* makes this function return
 immediately with no action.
 
+Any use of the **handle** after this function has been called and have
+returned, is illegal.
+
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -44,9 +50,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.62.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_url_dup.md b/docs/libcurl/curl_url_dup.md
index 43b54eb29..5c0b4b021 100644
--- a/docs/libcurl/curl_url_dup.md
+++ b/docs/libcurl/curl_url_dup.md
@@ -12,6 +12,7 @@ See-also:
   - curl_url_set (3)
 Protocol:
   - All
+Added-in: 7.62.0
 ---
 
 # NAME
@@ -32,6 +33,8 @@ Duplicates the URL object the input *CURLU* *inhandle* identifies and
 returns a pointer to the copy as a new *CURLU* handle. The new handle also
 needs to be freed with curl_url_cleanup(3).
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -49,9 +52,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.62.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_url_get.md b/docs/libcurl/curl_url_get.md
index 54041180f..e7aa6baa5 100644
--- a/docs/libcurl/curl_url_get.md
+++ b/docs/libcurl/curl_url_get.md
@@ -13,6 +13,7 @@ See-also:
   - curl_url_strerror (3)
 Protocol:
   - All
+Added-in: 7.62.0
 ---
 
 # NAME
@@ -125,6 +126,22 @@ nothing following the hash sign.
 
 (Added in curl 8.8.0)
 
+## CURLU_NO_GUESS_SCHEME
+
+When this flag is used in curl_url_get(), it treats the scheme as non-existing
+if it was set as a result of a previous guess; when CURLU_GUESS_SCHEME was
+used parsing a URL.
+
+Using this flag when getting CURLUPART_SCHEME if the scheme was set as the
+result of a guess makes curl_url_get() return CURLUE_NO_SCHEME.
+
+Using this flag when getting CURLUPART_URL if the scheme was set as the result
+of a guess makes curl_url_get() return the full URL without the scheme
+component. Such a URL can then only be parsed with curl_url_set() if
+CURLU_GUESS_SCHEME is used.
+
+(Added in curl 8.9.0)
+
 # PARTS
 
 ## CURLUPART_URL
@@ -199,6 +216,8 @@ A not-present fragment returns *part* set to NULL.
 
 A zero-length fragment returns *part* as NULL unless CURLU_GET_EMPTY is set.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -219,9 +238,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.62.0. CURLUPART_ZONEID was added in 7.65.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_url_set.md b/docs/libcurl/curl_url_set.md
index 985ba44fe..390f52493 100644
--- a/docs/libcurl/curl_url_set.md
+++ b/docs/libcurl/curl_url_set.md
@@ -13,6 +13,7 @@ See-also:
   - curl_url_strerror (3)
 Protocol:
   - All
+Added-in: 7.78.0
 ---
 
 # NAME
@@ -75,15 +76,17 @@ populated with a URL, the new URL can be relative to the previous.
 When successfully setting a new URL, relative or absolute, the handle contents
 is replaced with the components of the newly set URL.
 
-Pass a pointer to a null-terminated string to the *url* parameter. The
-string must point to a correctly formatted "RFC 3986+" URL or be a NULL
-pointer.
+Pass a pointer to a null-terminated string to the *url* parameter. The string
+must point to a correctly formatted "RFC 3986+" URL or be a NULL pointer. The
+URL parser only understands and parses the subset of URLS that are
+"hierarchical" and therefore contain a :// separator - not the ones that are
+normally specified with only a colon separator.
 
-By default, this API only accepts setting URLs using schemes for protocols
-that are supported built-in. To make libcurl parse URLs generically even for
-schemes it does not know about, the **CURLU_NON_SUPPORT_SCHEME** flags bit
-must be set. Otherwise, this function returns *CURLUE_UNSUPPORTED_SCHEME* for
-URL schemes it does not recognize.
+By default this API only parses URLs using schemes for protocols that are
+supported built-in. To make libcurl parse URLs generically even for schemes it
+does not know about, the **CURLU_NON_SUPPORT_SCHEME** flags bit must be set.
+Otherwise, this function returns *CURLUE_UNSUPPORTED_SCHEME* for URL schemes
+it does not recognize.
 
 Unless *CURLU_NO_AUTHORITY* is set, a blank hostname is not allowed in
 the URL.
@@ -167,7 +170,8 @@ first '=' symbol is not URL encoded.
 
 ## CURLU_NON_SUPPORT_SCHEME
 
-If set, allows curl_url_set(3) to set a non-supported scheme.
+If set, allows curl_url_set(3) to set a non-supported scheme. It then of
+course cannot know if the provided scheme is a valid one or not.
 
 ## CURLU_URLENCODE
 
@@ -186,8 +190,8 @@ manner.
 ## CURLU_DEFAULT_SCHEME
 
 If set, allows the URL to be set without a scheme and then sets that to the
-default scheme: HTTPS. Overrides the *CURLU_GUESS_SCHEME* option if both
-are set.
+default scheme: HTTPS. Overrides the *CURLU_GUESS_SCHEME* option if both are
+set.
 
 ## CURLU_GUESS_SCHEME
 
@@ -197,6 +201,14 @@ subdomain name matches DICT, FTP, IMAP, LDAP, POP3 or SMTP then that scheme is
 used, otherwise it picks HTTP. Conflicts with the *CURLU_DEFAULT_SCHEME*
 option which takes precedence if both are set.
 
+If guessing is not allowed and there is no default scheme set, trying to parse
+a URL without a scheme returns error.
+
+If the scheme ends up set as a result of guessing, i.e. it is not actually
+present in the parsed URL, it can later be figured out by using the
+**CURLU_NO_GUESS_SCHEME** flag when subsequently getting the URL or the scheme
+with curl_url_get(3).
+
 ## CURLU_NO_AUTHORITY
 
 If set, skips authority checks. The RFC allows individual schemes to omit the
@@ -228,6 +240,8 @@ If set, the URL parser does not accept embedded credentials for the
 **CURLUPART_URL**, and instead returns **CURLUE_USER_NOT_ALLOWED** for
 such URLs.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -244,9 +258,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.62.0. CURLUPART_ZONEID was added in 7.65.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_url_strerror.md b/docs/libcurl/curl_url_strerror.md
index a57e19df1..33cdb148d 100644
--- a/docs/libcurl/curl_url_strerror.md
+++ b/docs/libcurl/curl_url_strerror.md
@@ -13,6 +13,7 @@ See-also:
   - libcurl-errors (3)
 Protocol:
   - All
+Added-in: 7.80.0
 ---
 
 # NAME
@@ -32,6 +33,8 @@ const char *curl_url_strerror(CURLUcode errornum);
 This function returns a string describing the CURLUcode error code passed in
 the argument *errornum*.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -46,9 +49,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.80.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_version.md b/docs/libcurl/curl_version.md
index 48a102f09..012be6ed8 100644
--- a/docs/libcurl/curl_version.md
+++ b/docs/libcurl/curl_version.md
@@ -8,6 +8,7 @@ See-also:
   - curl_version_info (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -29,6 +30,8 @@ its important components (like OpenSSL version).
 
 We recommend using curl_version_info(3) instead!
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -38,9 +41,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_version_info.md b/docs/libcurl/curl_version_info.md
index 1b538d363..2a0220d29 100644
--- a/docs/libcurl/curl_version_info.md
+++ b/docs/libcurl/curl_version_info.md
@@ -8,6 +8,7 @@ See-also:
   - curl_version (3)
 Protocol:
   - All
+Added-in: 7.10.0
 ---
 
 # NAME
@@ -369,6 +370,8 @@ supports HTTP GSS-Negotiate (added in 7.10.6, deprecated in 7.38.0)
 
 supports Kerberos V4 (when using FTP). Legacy bit. Deprecated since 7.33.0.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -382,9 +385,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_ws_meta.md b/docs/libcurl/curl_ws_meta.md
index a60ce1d66..f95f25e80 100644
--- a/docs/libcurl/curl_ws_meta.md
+++ b/docs/libcurl/curl_ws_meta.md
@@ -12,6 +12,7 @@ See-also:
   - libcurl-ws (3)
 Protocol:
   - WS
+Added-in: 7.86.0
 ---
 
 # NAME
@@ -97,6 +98,8 @@ This transfer is now closed.
 
 This as an incoming ping message, that expects a pong response.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -132,9 +135,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.86.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_ws_recv.md b/docs/libcurl/curl_ws_recv.md
index 38a8a2abc..d5df8b339 100644
--- a/docs/libcurl/curl_ws_recv.md
+++ b/docs/libcurl/curl_ws_recv.md
@@ -12,6 +12,7 @@ See-also:
   - libcurl-ws (3)
 Protocol:
   - WS
+Added-in: 7.86.0
 ---
 
 # NAME
@@ -43,6 +44,8 @@ The *meta* pointer gets set to point to a *const struct curl_ws_frame*
 that contains information about the received data. See the
 curl_ws_meta(3) for details on that struct.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.86.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/curl_ws_send.md b/docs/libcurl/curl_ws_send.md
index ddb4f8744..82fce1cff 100644
--- a/docs/libcurl/curl_ws_send.md
+++ b/docs/libcurl/curl_ws_send.md
@@ -12,6 +12,7 @@ See-also:
   - libcurl-ws (3)
 Protocol:
   - WS
+Added-in: 7.86.0
 ---
 
 # NAME
@@ -89,6 +90,8 @@ fragment like this, the *fragsize* must be provided with the total
 expected fragment size in the first call and it needs to be zero in subsequent
 calls.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -111,9 +114,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.86.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/libcurl-easy.md b/docs/libcurl/libcurl-easy.md
index 1286f4113..782108835 100644
--- a/docs/libcurl/libcurl-easy.md
+++ b/docs/libcurl/libcurl-easy.md
@@ -1,7 +1,7 @@
 ---
 c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
-Title: libcurl
+Title: libcurl-easy
 Section: 3
 Source: libcurl
 See-also:
@@ -13,6 +13,7 @@ See-also:
   - libcurl-multi (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -27,28 +28,27 @@ interface functions you use. Use curl_easy_init(3) to get the handle.
 
 You continue by setting all the options you want in the upcoming transfer, the
 most important among them is the URL itself (you cannot transfer anything
-without a specified URL as you may have figured out yourself). You might want
-to set some callbacks as well that are called from the library when data is
-available etc. curl_easy_setopt(3) is used for all this.
-
-CURLOPT_URL(3) is the only option you really must set, as otherwise
-there can be no transfer. Another commonly used option is
-CURLOPT_VERBOSE(3) that helps you see what libcurl is doing under the
-hood, which is useful when debugging for example. The
-curl_easy_setopt(3) man page has a full index of the almost 300
+without a specified URL). You might want to set some callbacks as well that
+are called from the library when data is available etc. For example
+CURLOPT_WRITEFUNCTION(3). curl_easy_setopt(3) is used for all this.
+
+CURLOPT_URL(3) is the only option you really must set, as otherwise there can
+be no transfer. Another commonly used option is CURLOPT_VERBOSE(3) that helps
+you see what libcurl is doing under the hood, which is useful when debugging
+for example. The curl_easy_setopt(3) man page has a full index of the over 300
 available options.
 
 If you at any point would like to blank all previously set options for a
-single easy handle, you can call curl_easy_reset(3) and you can also
-make a clone of an easy handle (with all its set options) using
+single easy handle, you can call curl_easy_reset(3) and you can also make a
+clone of an easy handle (with all its set options) using
 curl_easy_duphandle(3).
 
 When all is setup, you tell libcurl to perform the transfer using
-curl_easy_perform(3). It performs the entire transfer operation and does
-not return until it is done (successfully or not).
+curl_easy_perform(3). It performs the entire transfer operation and does not
+return until it is done (successfully or not).
 
 After the transfer has been made, you can set new options and make another
 transfer, or if you are done, cleanup the session by calling
-curl_easy_cleanup(3). If you want persistent connections, you do not
-cleanup immediately, but instead run ahead and perform other transfers using
-the same easy handle.
+curl_easy_cleanup(3). If you want persistent connections, you do not cleanup
+immediately, but instead run ahead and perform other transfers using the same
+easy handle.
diff --git a/docs/libcurl/libcurl-env-dbg.md b/docs/libcurl/libcurl-env-dbg.md
index 2ab8c2b95..3762b006b 100644
--- a/docs/libcurl/libcurl-env-dbg.md
+++ b/docs/libcurl/libcurl-env-dbg.md
@@ -8,6 +8,7 @@ See-also:
   - libcurl-env (3)
 Protocol:
   - All
+Added-in: n/a
 ---
 
 # NAME
@@ -123,3 +124,16 @@ greater. There is a number of debug levels, refer to *openldap.c* comments.
 
 Used to influence the buffer chunk size used for WebSocket encoding and
 decoding.
+
+## CURL_FORBID_REUSE
+
+Used to set the CURLOPT_FORBID_REUSE flag on each transfer initiated
+by the curl command line tool. The value of the environment variable
+does not matter.
+
+## CURL_GRACEFUL_SHUTDOWN
+
+Make a blocking, graceful shutdown of all remaining connections when
+a multi handle is destroyed. This implicitly triggers for easy handles
+that are run via easy_perform. The value of the environment variable
+gives the shutdown timeout in milliseconds.
diff --git a/docs/libcurl/libcurl-env.md b/docs/libcurl/libcurl-env.md
index 0db69ff95..bf5624f3c 100644
--- a/docs/libcurl/libcurl-env.md
+++ b/docs/libcurl/libcurl-env.md
@@ -8,6 +8,7 @@ See-also:
   - libcurl-env-dbg (3)
 Protocol:
   - All
+Added-in: n/a
 ---
 
 # NAME
diff --git a/docs/libcurl/libcurl-errors.md b/docs/libcurl/libcurl-errors.md
index ef31b2fc9..e994bd497 100644
--- a/docs/libcurl/libcurl-errors.md
+++ b/docs/libcurl/libcurl-errors.md
@@ -14,6 +14,7 @@ See-also:
   - curl_url_strerror (3)
 Protocol:
   - All
+Added-in: n/a
 ---
 
 # NAME
diff --git a/docs/libcurl/libcurl-multi.md b/docs/libcurl/libcurl-multi.md
index cf3bc5693..3becb648d 100644
--- a/docs/libcurl/libcurl-multi.md
+++ b/docs/libcurl/libcurl-multi.md
@@ -10,6 +10,7 @@ See-also:
   - libcurl-errors (3)
 Protocol:
   - All
+Added-in: 7.9.6
 ---
 
 # NAME
diff --git a/docs/libcurl/libcurl-security.md b/docs/libcurl/libcurl-security.md
index 541489d23..d13dceffe 100644
--- a/docs/libcurl/libcurl-security.md
+++ b/docs/libcurl/libcurl-security.md
@@ -8,6 +8,7 @@ See-also:
   - libcurl-thread (3)
 Protocol:
   - All
+Added-in: n/a
 ---
 <!-- markdown-link-check-disable -->
 # NAME
@@ -121,7 +122,7 @@ user running the libcurl application, SCP: or SFTP: URLs could access password
 or private-key protected resources,
 e.g. **sftp://user@some-internal-server/etc/passwd**
 
-The CURLOPT_REDIR_PROTOCOLS(3) and CURLOPT_NETRC(3) options can be
+The CURLOPT_REDIR_PROTOCOLS_STR(3) and CURLOPT_NETRC(3) options can be
 used to mitigate against this kind of attack.
 
 A redirect can also specify a location available only on the machine running
@@ -132,7 +133,7 @@ E.g. **http://127.0.0.1/** or **http://intranet/delete-stuff.cgi?delete=all** or
 Applications can mitigate against this by disabling
 CURLOPT_FOLLOWLOCATION(3) and handling redirects itself, sanitizing URLs
 as necessary. Alternately, an app could leave CURLOPT_FOLLOWLOCATION(3)
-enabled but set CURLOPT_REDIR_PROTOCOLS(3) and install a
+enabled but set CURLOPT_REDIR_PROTOCOLS_STR(3) and install a
 CURLOPT_OPENSOCKETFUNCTION(3) or CURLOPT_PREREQFUNCTION(3) callback
 function in which addresses are sanitized before use.
 
@@ -164,7 +165,7 @@ non-redirected URLs, if the user is allowed to specify an arbitrary URL that
 could point to a private resource. For example, a web app providing a
 translation service might happily translate **file://localhost/etc/passwd**
 and display the result. Applications can mitigate against this with the
-CURLOPT_PROTOCOLS(3) option as well as by similar mitigation techniques
+CURLOPT_PROTOCOLS_STR(3) option as well as by similar mitigation techniques
 for redirections.
 
 A malicious FTP server could in response to the PASV command return an IP
@@ -308,9 +309,9 @@ Remedies:
 
 curl command lines can use *--proto* to limit what URL schemes it accepts
 
-## Use CURLOPT_PROTOCOLS
+## Use CURLOPT_PROTOCOLS_STR
 
-libcurl programs can use CURLOPT_PROTOCOLS(3) to limit what URL schemes it accepts
+libcurl programs can use CURLOPT_PROTOCOLS_STR(3) to limit what URL schemes it accepts
 
 ## consider not allowing the user to set the full URL
 
diff --git a/docs/libcurl/libcurl-share.md b/docs/libcurl/libcurl-share.md
index f820967df..6d00c9c67 100644
--- a/docs/libcurl/libcurl-share.md
+++ b/docs/libcurl/libcurl-share.md
@@ -13,6 +13,7 @@ See-also:
   - libcurl-multi (3)
 Protocol:
   - All
+Added-in: n/a
 ---
 
 # NAME
diff --git a/docs/libcurl/libcurl-thread.md b/docs/libcurl/libcurl-thread.md
index 5f02aee2f..ef7ae9b7d 100644
--- a/docs/libcurl/libcurl-thread.md
+++ b/docs/libcurl/libcurl-thread.md
@@ -8,6 +8,7 @@ See-also:
   - libcurl-security (3)
 Protocol:
   - All
+Added-in: n/a
 ---
 
 # NAME
@@ -58,7 +59,7 @@ libcurl is built as a DLL and OpenSSL is linked statically to it then libcurl
 does this cleanup automatically and there is no leak (added in libcurl 8.8.0).
 
 Please review the OpenSSL documentation for a full list of circumstances:
-https://www.openssl.org/docs/man3.0/man3/OPENSSL_thread_stop.html#NOTES
+https://docs.openssl.org/3.0/man3/OPENSSL_init_crypto/#notes
 
 # Signals
 
diff --git a/docs/libcurl/libcurl-tutorial.md b/docs/libcurl/libcurl-tutorial.md
index c51d9f13c..4e16e38aa 100644
--- a/docs/libcurl/libcurl-tutorial.md
+++ b/docs/libcurl/libcurl-tutorial.md
@@ -11,6 +11,7 @@ See-also:
   - libcurl-url (3)
 Protocol:
   - All
+Added-in: n/a
 ---
 
 # NAME
diff --git a/docs/libcurl/libcurl-url.md b/docs/libcurl/libcurl-url.md
index e673873b4..1d9e59247 100644
--- a/docs/libcurl/libcurl-url.md
+++ b/docs/libcurl/libcurl-url.md
@@ -1,7 +1,7 @@
 ---
 c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
-Title: libcurl
+Title: libcurl-url
 Section: 3
 Source: libcurl
 See-also:
@@ -14,6 +14,7 @@ See-also:
   - curl_url_strerror (3)
 Protocol:
   - All
+Added-in: 7.62.0
 ---
 
 # NAME
@@ -156,9 +157,7 @@ Now the URL looks like
   https://example.com/?shoes=2&hat=1&candy=N%26N
 ~~~
 
-# AVAILABILITY
-
-The URL API was introduced in libcurl 7.62.0.
+# NOTES
 
 A URL with a literal IPv6 address can be parsed even when IPv6 support is not
 enabled.
diff --git a/docs/libcurl/libcurl-ws.md b/docs/libcurl/libcurl-ws.md
index 25550ecd6..60c9fa59a 100644
--- a/docs/libcurl/libcurl-ws.md
+++ b/docs/libcurl/libcurl-ws.md
@@ -1,7 +1,7 @@
 ---
 c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
-Title: libcurl
+Title: libcurl-ws
 Section: 3
 Source: libcurl
 See-also:
@@ -14,6 +14,7 @@ See-also:
   - curl_ws_send (3)
 Protocol:
   - All
+Added-in: 7.86.0
 ---
 
 # NAME
@@ -115,7 +116,7 @@ Once such a setup has been successfully performed, the application can proceed
 and use curl_ws_recv(3) and curl_ws_send(3) freely to exchange
 WebSocket messages with the server.
 
-# AVAILABILITY
+# EXPERIMENTAL
 
 The WebSocket API was introduced as experimental in 7.86.0 and is still
 experimental today.
diff --git a/docs/libcurl/libcurl.md b/docs/libcurl/libcurl.md
index 9031451cc..2f3a45197 100644
--- a/docs/libcurl/libcurl.md
+++ b/docs/libcurl/libcurl.md
@@ -11,6 +11,7 @@ See-also:
   - libcurl-thread (3)
 Protocol:
   - All
+Added-in: n/a
 ---
 
 # NAME
diff --git a/docs/libcurl/mksymbolsmanpage.pl b/docs/libcurl/mksymbolsmanpage.pl
index fc9a8b704..c1a6b9d61 100755
--- a/docs/libcurl/mksymbolsmanpage.pl
+++ b/docs/libcurl/mksymbolsmanpage.pl
@@ -48,6 +48,7 @@ See-also:
   - libcurl-multi (3)
   - libcurl-security (3)
   - libcurl-thread (3)
+Added-in: n/a
 ---
 # libcurl symbols
 
@@ -60,7 +61,7 @@ since that version no new code should be written to use the symbol as it is
 marked for getting removed in a future.
 
 The last version that featured the specific symbol. Using the symbol in source
-code will make it no longer compile error-free after that specified version.
+code makes it no longer compile error-free after that specified version.
 
 This man page is automatically generated from the symbols-in-versions file.
 HEADER
diff --git a/docs/libcurl/opts/CURLINFO_ACTIVESOCKET.md b/docs/libcurl/opts/CURLINFO_ACTIVESOCKET.md
index 1a799e1e5..2b849afc5 100644
--- a/docs/libcurl/opts/CURLINFO_ACTIVESOCKET.md
+++ b/docs/libcurl/opts/CURLINFO_ACTIVESOCKET.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.45.0
 ---
 
 # NAME
@@ -40,6 +41,8 @@ CURLOPT_CONNECT_ONLY(3), which skips the transfer phase.
 CURLINFO_ACTIVESOCKET(3) was added as a replacement for
 CURLINFO_LASTSOCKET(3) since that one is not working on all platforms.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -71,9 +74,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.45.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_APPCONNECT_TIME.md b/docs/libcurl/opts/CURLINFO_APPCONNECT_TIME.md
index 911ab391d..61ea7ba8b 100644
--- a/docs/libcurl/opts/CURLINFO_APPCONNECT_TIME.md
+++ b/docs/libcurl/opts/CURLINFO_APPCONNECT_TIME.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.19.0
 ---
 
 # NAME
@@ -37,6 +38,8 @@ When a redirect is followed, the time from each request is added together.
 
 See also the TIMES overview in the curl_easy_getinfo(3) man page.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.19.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_APPCONNECT_TIME_T.md b/docs/libcurl/opts/CURLINFO_APPCONNECT_TIME_T.md
index 116cc7812..4490fd032 100644
--- a/docs/libcurl/opts/CURLINFO_APPCONNECT_TIME_T.md
+++ b/docs/libcurl/opts/CURLINFO_APPCONNECT_TIME_T.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.61.0
 ---
 
 # NAME
@@ -37,6 +38,8 @@ When a redirect is followed, the time from each request is added together.
 
 See also the TIMES overview in the curl_easy_getinfo(3) man page.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -61,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.61.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_CAINFO.md b/docs/libcurl/opts/CURLINFO_CAINFO.md
index ea61a1a74..60c131d9e 100644
--- a/docs/libcurl/opts/CURLINFO_CAINFO.md
+++ b/docs/libcurl/opts/CURLINFO_CAINFO.md
@@ -12,6 +12,7 @@ Protocol:
   - TLS
 TLS-backend:
   - All
+Added-in: 7.84.0
 ---
 
 # NAME
@@ -40,6 +41,8 @@ This is a path identifying a single file containing CA certificates.
 
 The **path** pointer is set to NULL if there is no default path.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,9 +60,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.84.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_CAPATH.md b/docs/libcurl/opts/CURLINFO_CAPATH.md
index 8b6f8bf77..6211859a5 100644
--- a/docs/libcurl/opts/CURLINFO_CAPATH.md
+++ b/docs/libcurl/opts/CURLINFO_CAPATH.md
@@ -15,6 +15,7 @@ TLS-backend:
   - GnuTLS
   - mbedTLS
   - wolfSSL
+Added-in: 7.84.0
 ---
 
 # NAME
@@ -43,6 +44,8 @@ This is a path identifying a directory.
 
 The **path** pointer is set to NULL if there is no default path.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.84.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_CERTINFO.md b/docs/libcurl/opts/CURLINFO_CERTINFO.md
index 633beed17..e73b2aee7 100644
--- a/docs/libcurl/opts/CURLINFO_CERTINFO.md
+++ b/docs/libcurl/opts/CURLINFO_CERTINFO.md
@@ -15,6 +15,7 @@ TLS-backend:
   - GnuTLS
   - Schannel
   - Secure Transport
+Added-in: 7.19.1
 ---
 
 # NAME
@@ -50,6 +51,8 @@ items with textual information in the format "name:content" such as
 "Subject:Foo", "Issuer:Bar", etc. The items in each list varies depending on
 the SSL backend and the certificate.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -91,13 +94,12 @@ int main(void)
 
 See also the *certinfo.c* example.
 
-# AVAILABILITY
+# HISTORY
 
-This option is only working in libcurl built with OpenSSL, GnuTLS, Schannel or
-Secure Transport. GnuTLS support added in 7.42.0. Schannel support added in
-7.50.0. Secure Transport support added in 7.79.0.
+GnuTLS support added in 7.42.0. Schannel support added in 7.50.0. Secure
+Transport support added in 7.79.0. mbedTLS support added in 8.9.0.
 
-Added in 7.19.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_CONDITION_UNMET.md b/docs/libcurl/opts/CURLINFO_CONDITION_UNMET.md
index 00cbd5308..6befaf8a0 100644
--- a/docs/libcurl/opts/CURLINFO_CONDITION_UNMET.md
+++ b/docs/libcurl/opts/CURLINFO_CONDITION_UNMET.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - HTTP
+Added-in: 7.19.4
 ---
 
 # NAME
@@ -36,6 +37,8 @@ gets a zero stored if the condition instead was met. This can also return 1 if
 the server responded with a 304 HTTP status code, for example after sending a
 custom "If-Match-*" header.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -69,9 +72,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.19.4
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_CONNECT_TIME.md b/docs/libcurl/opts/CURLINFO_CONNECT_TIME.md
index 7a5b4bdfc..dbf1a56fc 100644
--- a/docs/libcurl/opts/CURLINFO_CONNECT_TIME.md
+++ b/docs/libcurl/opts/CURLINFO_CONNECT_TIME.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.4.1
 ---
 
 # NAME
@@ -33,6 +34,8 @@ When a redirect is followed, the time from each request is added together.
 
 See also the TIMES overview in the curl_easy_getinfo(3) man page.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -56,9 +59,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.4.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_CONNECT_TIME_T.md b/docs/libcurl/opts/CURLINFO_CONNECT_TIME_T.md
index 00d582388..073a93b9c 100644
--- a/docs/libcurl/opts/CURLINFO_CONNECT_TIME_T.md
+++ b/docs/libcurl/opts/CURLINFO_CONNECT_TIME_T.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.61.0
 ---
 
 # NAME
@@ -35,6 +36,8 @@ When a redirect is followed, the time from each request is added together.
 
 See also the TIMES overview in the curl_easy_getinfo(3) man page.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -59,9 +62,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.61.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_CONN_ID.md b/docs/libcurl/opts/CURLINFO_CONN_ID.md
index 3face4207..41a3b16fc 100644
--- a/docs/libcurl/opts/CURLINFO_CONN_ID.md
+++ b/docs/libcurl/opts/CURLINFO_CONN_ID.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 8.2.0
 ---
 
 # NAME
@@ -34,6 +35,8 @@ The connection id is unique among all connections using the same
 connection cache. This is implicitly the case for all connections in the
 same multi handle.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -59,9 +62,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 8.2.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_CONTENT_LENGTH_DOWNLOAD.md b/docs/libcurl/opts/CURLINFO_CONTENT_LENGTH_DOWNLOAD.md
index 0cb1b47d1..77b7be406 100644
--- a/docs/libcurl/opts/CURLINFO_CONTENT_LENGTH_DOWNLOAD.md
+++ b/docs/libcurl/opts/CURLINFO_CONTENT_LENGTH_DOWNLOAD.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.6.1
 ---
 
 # NAME
@@ -34,6 +35,8 @@ is the value read from the Content-Length: field. Since 7.19.4, this returns
 CURLINFO_CONTENT_LENGTH_DOWNLOAD_T(3) is a newer replacement that returns a more
 sensible variable type.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -59,9 +62,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
+
+Deprecated since 7.55.0.
 
-Added in 7.6.1. Deprecated since 7.55.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_CONTENT_LENGTH_DOWNLOAD_T.md b/docs/libcurl/opts/CURLINFO_CONTENT_LENGTH_DOWNLOAD_T.md
index 15b4f631f..ea08eb931 100644
--- a/docs/libcurl/opts/CURLINFO_CONTENT_LENGTH_DOWNLOAD_T.md
+++ b/docs/libcurl/opts/CURLINFO_CONTENT_LENGTH_DOWNLOAD_T.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - HTTP
+Added-in: 7.55.0
 ---
 
 # NAME
@@ -31,6 +32,8 @@ Pass a pointer to a *curl_off_t* to receive the content-length of the
 download. This is the value read from the Content-Length: field. Stores -1 if
 the size is not known.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -56,9 +59,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.55.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_CONTENT_LENGTH_UPLOAD.md b/docs/libcurl/opts/CURLINFO_CONTENT_LENGTH_UPLOAD.md
index 7cba9aa33..322a84a56 100644
--- a/docs/libcurl/opts/CURLINFO_CONTENT_LENGTH_UPLOAD.md
+++ b/docs/libcurl/opts/CURLINFO_CONTENT_LENGTH_UPLOAD.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.6.1
 ---
 
 # NAME
@@ -33,6 +34,8 @@ Pass a pointer to a double to receive the specified size of the upload. Since
 CURLINFO_CONTENT_LENGTH_UPLOAD_T(3) is a newer replacement that returns a
 more sensible variable type.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -58,9 +61,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
+
+Deprecated since 7.55.0.
 
-Added in 7.6.1. Deprecated since 7.55.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_CONTENT_LENGTH_UPLOAD_T.md b/docs/libcurl/opts/CURLINFO_CONTENT_LENGTH_UPLOAD_T.md
index babd796e3..4f018711a 100644
--- a/docs/libcurl/opts/CURLINFO_CONTENT_LENGTH_UPLOAD_T.md
+++ b/docs/libcurl/opts/CURLINFO_CONTENT_LENGTH_UPLOAD_T.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.55.0
 ---
 
 # NAME
@@ -30,6 +31,8 @@ CURLcode curl_easy_getinfo(CURL *handle, CURLINFO_CONTENT_LENGTH_UPLOAD_T,
 Pass a pointer to a *curl_off_t* to receive the specified size of the
 upload. Stores -1 if the size is not known.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -55,9 +58,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.55.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_CONTENT_TYPE.md b/docs/libcurl/opts/CURLINFO_CONTENT_TYPE.md
index 25cb737e0..9e1800f8d 100644
--- a/docs/libcurl/opts/CURLINFO_CONTENT_TYPE.md
+++ b/docs/libcurl/opts/CURLINFO_CONTENT_TYPE.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - HTTP
+Added-in: 7.9.4
 ---
 
 # NAME
@@ -39,6 +40,8 @@ corresponding CURL handle.
 The modern way to get this header from a response is to instead use the
 curl_easy_header(3) function.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.9.4
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_COOKIELIST.md b/docs/libcurl/opts/CURLINFO_COOKIELIST.md
index 64e9f4a65..0481c1277 100644
--- a/docs/libcurl/opts/CURLINFO_COOKIELIST.md
+++ b/docs/libcurl/opts/CURLINFO_COOKIELIST.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - HTTP
+Added-in: 7.14.1
 ---
 
 # NAME
@@ -36,6 +37,8 @@ received) the 'struct curl_slist *' is made a NULL pointer.
 Since 7.43.0 cookies that were imported in the Set-Cookie format without a
 domain name are not exported by this option.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -71,9 +74,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.14.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_EFFECTIVE_METHOD.md b/docs/libcurl/opts/CURLINFO_EFFECTIVE_METHOD.md
index e10142f5d..86080c579 100644
--- a/docs/libcurl/opts/CURLINFO_EFFECTIVE_METHOD.md
+++ b/docs/libcurl/opts/CURLINFO_EFFECTIVE_METHOD.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - HTTP
+Added-in: 7.72.0
 ---
 
 # NAME
@@ -38,6 +39,8 @@ The **methodp** pointer is NULL or points to private memory. You MUST NOT
 free - it gets freed when you call curl_easy_cleanup(3) on the
 corresponding CURL handle.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -61,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.72.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_EFFECTIVE_URL.md b/docs/libcurl/opts/CURLINFO_EFFECTIVE_URL.md
index 3892bd7bc..c1f395227 100644
--- a/docs/libcurl/opts/CURLINFO_EFFECTIVE_URL.md
+++ b/docs/libcurl/opts/CURLINFO_EFFECTIVE_URL.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - HTTP
+Added-in: 7.4
 ---
 
 # NAME
@@ -35,6 +36,8 @@ The **urlp** pointer is NULL or points to private memory. You MUST NOT free
 - it gets freed when you call curl_easy_cleanup(3) on the corresponding
 CURL handle.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,9 +60,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.4
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_FILETIME.md b/docs/libcurl/opts/CURLINFO_FILETIME.md
index 4e4d7f190..40482e36f 100644
--- a/docs/libcurl/opts/CURLINFO_FILETIME.md
+++ b/docs/libcurl/opts/CURLINFO_FILETIME.md
@@ -12,6 +12,7 @@ Protocol:
   - HTTP
   - FTP
   - SFTP
+Added-in: 7.5
 ---
 
 # NAME
@@ -34,12 +35,13 @@ in number of seconds since January 1 1970 in the GMT/UTC time zone. If you get
 hide it or the server does not support the command that tells document time
 etc) and the time of the document is unknown.
 
-You must tell libcurl to collect this information before the transfer is made,
-by using the CURLOPT_FILETIME(3) option to curl_easy_setopt(3) or
-you this unconditionally gets a -1 back.
+You must ask libcurl to collect this information before the transfer is made,
+by using the CURLOPT_FILETIME(3) option or you unconditionally get a -1 back.
 
-Consider using CURLINFO_FILETIME_T(3) to be able to extract dates beyond
-the year 2038 on systems using 32 bit longs (Windows).
+Consider CURLINFO_FILETIME_T(3) instead to be able to extract dates beyond the
+year 2038 on systems using 32-bit longs (Windows).
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -67,9 +69,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.5
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_FILETIME_T.md b/docs/libcurl/opts/CURLINFO_FILETIME_T.md
index 0ba24d61f..7cdec9b4c 100644
--- a/docs/libcurl/opts/CURLINFO_FILETIME_T.md
+++ b/docs/libcurl/opts/CURLINFO_FILETIME_T.md
@@ -1,7 +1,7 @@
 ---
 c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
-Title: CURLINFO_FILETIME
+Title: CURLINFO_FILETIME_T
 Section: 3
 Source: libcurl
 See-also:
@@ -12,6 +12,7 @@ Protocol:
   - HTTP
   - FTP
   - SFTP
+Added-in: 7.59.0
 ---
 
 # NAME
@@ -30,18 +31,18 @@ CURLcode curl_easy_getinfo(CURL *handle, CURLINFO_FILETIME_T,
 # DESCRIPTION
 
 Pass a pointer to a curl_off_t to receive the remote time of the retrieved
-document in number of seconds since January 1 1970 in the GMT/UTC time
-zone. If you get -1, it can be because of many reasons (it might be unknown,
-the server might hide it or the server does not support the command that tells
+document in number of seconds since January 1 1970 in the GMT/UTC time zone.
+If you get -1, it can be because of many reasons (it might be unknown, the
+server might hide it or the server does not support the command that tells
 document time etc) and the time of the document is unknown.
 
 You must ask libcurl to collect this information before the transfer is made,
-by using the CURLOPT_FILETIME(3) option to curl_easy_setopt(3) or
-you unconditionally get a -1 back.
+by using the CURLOPT_FILETIME(3) option or you unconditionally get a -1 back.
 
-This option is an alternative to CURLINFO_FILETIME(3) to allow systems
-with 32 bit long variables to extract dates outside of the 32bit timestamp
-range.
+This option is an alternative to CURLINFO_FILETIME(3) to allow systems with 32
+bit long variables to extract dates outside of the 32-bit timestamp range.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -69,9 +70,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.59.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_FTP_ENTRY_PATH.md b/docs/libcurl/opts/CURLINFO_FTP_ENTRY_PATH.md
index 2276a5513..245a84936 100644
--- a/docs/libcurl/opts/CURLINFO_FTP_ENTRY_PATH.md
+++ b/docs/libcurl/opts/CURLINFO_FTP_ENTRY_PATH.md
@@ -9,6 +9,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - FTP
+Added-in: 7.15.4
 ---
 
 # NAME
@@ -34,6 +35,8 @@ The **path** pointer is NULL or points to private memory. You MUST NOT free
 - it gets freed when you call curl_easy_cleanup(3) on the corresponding
 CURL handle.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -59,9 +62,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
+
+Works for SFTP since 7.21.4
 
-Added in 7.15.4. Works for SFTP since 7.21.4
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_HEADER_SIZE.md b/docs/libcurl/opts/CURLINFO_HEADER_SIZE.md
index f60ab5245..ce8764c96 100644
--- a/docs/libcurl/opts/CURLINFO_HEADER_SIZE.md
+++ b/docs/libcurl/opts/CURLINFO_HEADER_SIZE.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.4.1
 ---
 
 # NAME
@@ -33,6 +34,8 @@ received. Measured in number of bytes.
 The total includes the size of any received headers suppressed by
 CURLOPT_SUPPRESS_CONNECT_HEADERS(3).
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -54,9 +57,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.4.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_HTTPAUTH_AVAIL.md b/docs/libcurl/opts/CURLINFO_HTTPAUTH_AVAIL.md
index 21d92c323..b0b229eb3 100644
--- a/docs/libcurl/opts/CURLINFO_HTTPAUTH_AVAIL.md
+++ b/docs/libcurl/opts/CURLINFO_HTTPAUTH_AVAIL.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - HTTP
+Added-in: 7.10.8
 ---
 
 # NAME
@@ -29,8 +30,9 @@ CURLcode curl_easy_getinfo(CURL *handle, CURLINFO_HTTPAUTH_AVAIL, long *authp);
 
 Pass a pointer to a long to receive a bitmask indicating the authentication
 method(s) available according to the previous response. The meaning of the
-bits is explained in the CURLOPT_HTTPAUTH(3) option for
-curl_easy_setopt(3).
+bits is explained in the CURLOPT_HTTPAUTH(3) option for curl_easy_setopt(3).
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -65,10 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added RFC 2617 in 7.10.8
-Added RFC 7616 in 7.57.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_HTTP_CONNECTCODE.md b/docs/libcurl/opts/CURLINFO_HTTP_CONNECTCODE.md
index d5fb41c3d..b93f9d6f5 100644
--- a/docs/libcurl/opts/CURLINFO_HTTP_CONNECTCODE.md
+++ b/docs/libcurl/opts/CURLINFO_HTTP_CONNECTCODE.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - HTTP
+Added-in: 7.10.7
 ---
 
 # NAME
@@ -30,6 +31,8 @@ Pass a pointer to a long to receive the last received HTTP proxy response code
 to a CONNECT request. The returned value is zero if no such response code was
 available.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -54,9 +57,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10.7
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_HTTP_VERSION.md b/docs/libcurl/opts/CURLINFO_HTTP_VERSION.md
index 8ca341fe2..2721eb3fc 100644
--- a/docs/libcurl/opts/CURLINFO_HTTP_VERSION.md
+++ b/docs/libcurl/opts/CURLINFO_HTTP_VERSION.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - HTTP
+Added-in: 7.50.0
 ---
 
 # NAME
@@ -31,6 +32,8 @@ connection done using this handle. The returned value is
 CURL_HTTP_VERSION_1_0, CURL_HTTP_VERSION_1_1, CURL_HTTP_VERSION_2_0,
 CURL_HTTP_VERSION_3 or 0 if the version cannot be determined.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -50,9 +53,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.50.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_LASTSOCKET.md b/docs/libcurl/opts/CURLINFO_LASTSOCKET.md
index 318fe7151..5a7188624 100644
--- a/docs/libcurl/opts/CURLINFO_LASTSOCKET.md
+++ b/docs/libcurl/opts/CURLINFO_LASTSOCKET.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.15.2
 ---
 
 # NAME
@@ -40,6 +41,8 @@ NOTE: this API is deprecated since it is not working on win64 where the SOCKET
 type is 64 bits large while its 'long' is 32 bits. Use the
 CURLINFO_ACTIVESOCKET(3) instead, if possible.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -71,9 +74,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.15.2
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_LOCAL_IP.md b/docs/libcurl/opts/CURLINFO_LOCAL_IP.md
index d3e2118b1..ace1b7189 100644
--- a/docs/libcurl/opts/CURLINFO_LOCAL_IP.md
+++ b/docs/libcurl/opts/CURLINFO_LOCAL_IP.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.21.0
 ---
 
 # NAME
@@ -37,6 +38,8 @@ The **ip** pointer is NULL or points to private memory. You MUST NOT free -
 it gets freed when you call curl_easy_cleanup(3) on the corresponding
 CURL handle.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -61,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.21.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_LOCAL_PORT.md b/docs/libcurl/opts/CURLINFO_LOCAL_PORT.md
index 470341600..ff4bcbab3 100644
--- a/docs/libcurl/opts/CURLINFO_LOCAL_PORT.md
+++ b/docs/libcurl/opts/CURLINFO_LOCAL_PORT.md
@@ -11,6 +11,7 @@ See-also:
   - CURLINFO_PRIMARY_PORT (3)
   - curl_easy_getinfo (3)
   - curl_easy_setopt (3)
+Added-in: 7.21.0
 ---
 
 # NAME
@@ -30,6 +31,8 @@ CURLcode curl_easy_getinfo(CURL *handle, CURLINFO_LOCAL_PORT, long *portp);
 Pass a pointer to a long to receive the local port number of the most recent
 connection done with this **curl** handle.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,9 +60,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.21.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_NAMELOOKUP_TIME.md b/docs/libcurl/opts/CURLINFO_NAMELOOKUP_TIME.md
index 29dd375a5..349e300e8 100644
--- a/docs/libcurl/opts/CURLINFO_NAMELOOKUP_TIME.md
+++ b/docs/libcurl/opts/CURLINFO_NAMELOOKUP_TIME.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.4.1
 ---
 
 # NAME
@@ -34,6 +35,8 @@ When a redirect is followed, the time from each request is added together.
 
 See also the TIMES overview in the curl_easy_getinfo(3) man page.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,9 +60,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.4.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_NAMELOOKUP_TIME_T.md b/docs/libcurl/opts/CURLINFO_NAMELOOKUP_TIME_T.md
index eb0bae797..d263eb612 100644
--- a/docs/libcurl/opts/CURLINFO_NAMELOOKUP_TIME_T.md
+++ b/docs/libcurl/opts/CURLINFO_NAMELOOKUP_TIME_T.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.61.0
 ---
 
 # NAME
@@ -34,6 +35,8 @@ When a redirect is followed, the time from each request is added together.
 
 See also the TIMES overview in the curl_easy_getinfo(3) man page.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -58,9 +61,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.61.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_NUM_CONNECTS.md b/docs/libcurl/opts/CURLINFO_NUM_CONNECTS.md
index 56383de39..1a0a83f8f 100644
--- a/docs/libcurl/opts/CURLINFO_NUM_CONNECTS.md
+++ b/docs/libcurl/opts/CURLINFO_NUM_CONNECTS.md
@@ -9,6 +9,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.12.3
 ---
 
 # NAME
@@ -32,6 +33,8 @@ many times libcurl successfully reused existing connection(s) or not. See the
 connection options of curl_easy_setopt(3) to see how libcurl tries to make
 persistent connections to save time.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -54,9 +57,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.12.3
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_OS_ERRNO.md b/docs/libcurl/opts/CURLINFO_OS_ERRNO.md
index 0b60f2892..969f1a36c 100644
--- a/docs/libcurl/opts/CURLINFO_OS_ERRNO.md
+++ b/docs/libcurl/opts/CURLINFO_OS_ERRNO.md
@@ -9,6 +9,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.12.2
 ---
 
 # NAME
@@ -37,6 +38,8 @@ Since 8.8.0 libcurl clears the easy handle's saved errno before performing the
 transfer. Prior versions did not clear the saved errno, which means if a saved
 errno is retrieved it could be from a previous transfer on the same handle.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -59,9 +62,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.12.2
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_PRETRANSFER_TIME.md b/docs/libcurl/opts/CURLINFO_PRETRANSFER_TIME.md
index 04adf5aa6..0d3e3304d 100644
--- a/docs/libcurl/opts/CURLINFO_PRETRANSFER_TIME.md
+++ b/docs/libcurl/opts/CURLINFO_PRETRANSFER_TIME.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.4.1
 ---
 
 # NAME
@@ -39,6 +40,8 @@ When a redirect is followed, the time from each request is added together.
 
 See also the TIMES overview in the curl_easy_getinfo(3) man page.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -62,9 +65,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.4.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_PRETRANSFER_TIME_T.md b/docs/libcurl/opts/CURLINFO_PRETRANSFER_TIME_T.md
index b1049a663..0300312de 100644
--- a/docs/libcurl/opts/CURLINFO_PRETRANSFER_TIME_T.md
+++ b/docs/libcurl/opts/CURLINFO_PRETRANSFER_TIME_T.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.61.0
 ---
 
 # NAME
@@ -39,6 +40,8 @@ When a redirect is followed, the time from each request is added together.
 
 See also the TIMES overview in the curl_easy_getinfo(3) man page.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.61.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_PRIMARY_IP.md b/docs/libcurl/opts/CURLINFO_PRIMARY_IP.md
index 31237f656..83f431fd8 100644
--- a/docs/libcurl/opts/CURLINFO_PRIMARY_IP.md
+++ b/docs/libcurl/opts/CURLINFO_PRIMARY_IP.md
@@ -12,6 +12,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.19.0
 ---
 
 # NAME
@@ -38,6 +39,8 @@ The **ip** pointer is NULL or points to private memory. You MUST NOT free -
 it gets freed when you call curl_easy_cleanup(3) on the corresponding
 CURL handle.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -62,9 +65,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.19.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_PRIMARY_PORT.md b/docs/libcurl/opts/CURLINFO_PRIMARY_PORT.md
index a1de51db3..d44594e33 100644
--- a/docs/libcurl/opts/CURLINFO_PRIMARY_PORT.md
+++ b/docs/libcurl/opts/CURLINFO_PRIMARY_PORT.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.21.0
 ---
 
 # NAME
@@ -35,6 +36,8 @@ If a proxy was used for the most recent transfer, this is the port number of
 the proxy, if no proxy was used it is the port number of the most recently
 accessed URL.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -56,9 +59,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.21.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_PRIVATE.md b/docs/libcurl/opts/CURLINFO_PRIVATE.md
index 4a4d35150..0ce649924 100644
--- a/docs/libcurl/opts/CURLINFO_PRIVATE.md
+++ b/docs/libcurl/opts/CURLINFO_PRIVATE.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.10.3
 ---
 
 # NAME
@@ -31,6 +32,8 @@ associated with the curl handle (set with the CURLOPT_PRIVATE(3)).
 Please note that for internal reasons, the value is returned as a char
 pointer, although effectively being a 'void *'.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,9 +60,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10.3
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_PROTOCOL.md b/docs/libcurl/opts/CURLINFO_PROTOCOL.md
index 13c597381..9dadae91c 100644
--- a/docs/libcurl/opts/CURLINFO_PROTOCOL.md
+++ b/docs/libcurl/opts/CURLINFO_PROTOCOL.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -43,6 +44,8 @@ CURLPROTO_SCP, CURLPROTO_SFTP, CURLPROTO_SMB, CURLPROTO_SMBS, CURLPROTO_SMTP,
 CURLPROTO_SMTPS, CURLPROTO_TELNET, CURLPROTO_TFTP, CURLPROTO_MQTT
 ~~~
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -62,9 +65,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
+
+Deprecated since 7.85.0.
 
-Added in 7.52.0. Deprecated since 7.85.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_PROXYAUTH_AVAIL.md b/docs/libcurl/opts/CURLINFO_PROXYAUTH_AVAIL.md
index 823bdd385..201c0d996 100644
--- a/docs/libcurl/opts/CURLINFO_PROXYAUTH_AVAIL.md
+++ b/docs/libcurl/opts/CURLINFO_PROXYAUTH_AVAIL.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - HTTP
+Added-in: 7.10.8
 ---
 
 # NAME
@@ -29,8 +30,9 @@ CURLcode curl_easy_getinfo(CURL *handle, CURLINFO_PROXYAUTH_AVAIL,
 
 Pass a pointer to a long to receive a bitmask indicating the authentication
 method(s) available according to the previous response. The meaning of the
-bits is explained in the CURLOPT_PROXYAUTH(3) option for
-curl_easy_setopt(3).
+bits is explained in the CURLOPT_PROXYAUTH(3) option for curl_easy_setopt(3).
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -66,10 +68,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added RFC 2617 in 7.10.8
-Added RFC 7616 in 7.57.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_PROXY_ERROR.md b/docs/libcurl/opts/CURLINFO_PROXY_ERROR.md
index 1d8855f37..52572b99b 100644
--- a/docs/libcurl/opts/CURLINFO_PROXY_ERROR.md
+++ b/docs/libcurl/opts/CURLINFO_PROXY_ERROR.md
@@ -11,6 +11,7 @@ See-also:
   - libcurl-errors (3)
 Protocol:
   - All
+Added-in: 7.73.0
 ---
 
 # NAME
@@ -71,6 +72,8 @@ transfer returned a **CURLE_PROXY** error. That error code matches the
 
 The error code is zero (**CURLPX_OK**) if no response code was available.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -94,9 +97,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.73.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_PROXY_SSL_VERIFYRESULT.md b/docs/libcurl/opts/CURLINFO_PROXY_SSL_VERIFYRESULT.md
index 9ccf831f9..f1aeb052c 100644
--- a/docs/libcurl/opts/CURLINFO_PROXY_SSL_VERIFYRESULT.md
+++ b/docs/libcurl/opts/CURLINFO_PROXY_SSL_VERIFYRESULT.md
@@ -13,6 +13,7 @@ Protocol:
 TLS-backend:
   - OpenSSL
   - GnuTLS
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -36,6 +37,8 @@ option. This is only used for HTTPS proxies.
 
 0 is a positive result. Non-zero is an error.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -67,9 +70,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_QUEUE_TIME_T.md b/docs/libcurl/opts/CURLINFO_QUEUE_TIME_T.md
index c61ca2faa..c066e4ca5 100644
--- a/docs/libcurl/opts/CURLINFO_QUEUE_TIME_T.md
+++ b/docs/libcurl/opts/CURLINFO_QUEUE_TIME_T.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 8.6.0
 ---
 
 # NAME
@@ -35,6 +36,8 @@ connection etc due to set conditions and limits imposed by the application.
 
 See also the TIMES overview in the curl_easy_getinfo(3) man page.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -59,9 +62,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 8.6.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_REDIRECT_COUNT.md b/docs/libcurl/opts/CURLINFO_REDIRECT_COUNT.md
index bcfaa362d..c5999247e 100644
--- a/docs/libcurl/opts/CURLINFO_REDIRECT_COUNT.md
+++ b/docs/libcurl/opts/CURLINFO_REDIRECT_COUNT.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.9.7
 ---
 
 # NAME
@@ -31,6 +32,8 @@ CURLcode curl_easy_getinfo(CURL *handle, CURLINFO_REDIRECT_COUNT,
 Pass a pointer to a long to receive the total number of redirections that were
 actually followed.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -51,9 +54,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.9.7
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_REDIRECT_TIME.md b/docs/libcurl/opts/CURLINFO_REDIRECT_TIME.md
index 202343d61..f60b5e541 100644
--- a/docs/libcurl/opts/CURLINFO_REDIRECT_TIME.md
+++ b/docs/libcurl/opts/CURLINFO_REDIRECT_TIME.md
@@ -12,6 +12,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - HTTP
+Added-in: 7.9.7
 ---
 
 # NAME
@@ -36,6 +37,8 @@ the complete execution time for multiple redirections.
 
 See also the TIMES overview in the curl_easy_getinfo(3) man page.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -59,9 +62,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.9.7
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_REDIRECT_TIME_T.md b/docs/libcurl/opts/CURLINFO_REDIRECT_TIME_T.md
index 0ccafa077..1c69bfcf1 100644
--- a/docs/libcurl/opts/CURLINFO_REDIRECT_TIME_T.md
+++ b/docs/libcurl/opts/CURLINFO_REDIRECT_TIME_T.md
@@ -12,6 +12,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - HTTP
+Added-in: 7.61.0
 ---
 
 # NAME
@@ -37,6 +38,8 @@ multiple redirections.
 
 See also the TIMES overview in the curl_easy_getinfo(3) man page.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -61,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.61.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_REDIRECT_URL.md b/docs/libcurl/opts/CURLINFO_REDIRECT_URL.md
index 70a4f6cc3..9926a5edb 100644
--- a/docs/libcurl/opts/CURLINFO_REDIRECT_URL.md
+++ b/docs/libcurl/opts/CURLINFO_REDIRECT_URL.md
@@ -12,6 +12,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - HTTP
+Added-in: 7.18.2
 ---
 
 # NAME
@@ -28,14 +29,16 @@ CURLcode curl_easy_getinfo(CURL *handle, CURLINFO_REDIRECT_URL, char **urlp);
 
 # DESCRIPTION
 
-Pass a pointer to a char pointer to receive the URL a redirect *would*
-take you to if you would enable CURLOPT_FOLLOWLOCATION(3). This can come
-handy if you think using the built-in libcurl redirect logic is not good enough
-for you but you would still prefer to avoid implementing all the magic of
-figuring out the new URL.
+Pass a pointer to a char pointer to receive the URL a redirect *would* take
+you to if you would enable CURLOPT_FOLLOWLOCATION(3). This can come handy if
+you think using the built-in libcurl redirect logic is not good enough for you
+but you would still prefer to avoid implementing all the magic of figuring out
+the new URL.
 
-This URL is also set if the CURLOPT_MAXREDIRS(3) limit prevented a
-redirect to happen (since 7.54.1).
+This URL is also set if the CURLOPT_MAXREDIRS(3) limit prevented a redirect to
+happen (since 7.54.1).
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -58,9 +61,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.18.2
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_REFERER.md b/docs/libcurl/opts/CURLINFO_REFERER.md
index 6850b6de7..b74a7016b 100644
--- a/docs/libcurl/opts/CURLINFO_REFERER.md
+++ b/docs/libcurl/opts/CURLINFO_REFERER.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - HTTP
+Added-in: 7.76.0
 ---
 
 # NAME
@@ -34,6 +35,8 @@ The **hdrp** pointer is NULL or points to private memory you MUST NOT free -
 it gets freed when you call curl_easy_cleanup(3) on the corresponding
 CURL handle.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -56,9 +59,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.76.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_REQUEST_SIZE.md b/docs/libcurl/opts/CURLINFO_REQUEST_SIZE.md
index 89452d32b..3b0c66dc9 100644
--- a/docs/libcurl/opts/CURLINFO_REQUEST_SIZE.md
+++ b/docs/libcurl/opts/CURLINFO_REQUEST_SIZE.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.4.1
 ---
 
 # NAME
@@ -31,6 +32,8 @@ Pass a pointer to a long to receive the total size of the issued
 requests. This is so far only for HTTP requests. Note that this may be more
 than one request if CURLOPT_FOLLOWLOCATION(3) is enabled.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -52,9 +55,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.4.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_RESPONSE_CODE.md b/docs/libcurl/opts/CURLINFO_RESPONSE_CODE.md
index ea7d8f3f4..05e88387c 100644
--- a/docs/libcurl/opts/CURLINFO_RESPONSE_CODE.md
+++ b/docs/libcurl/opts/CURLINFO_RESPONSE_CODE.md
@@ -13,6 +13,7 @@ Protocol:
   - FTP
   - SMTP
   - LDAP
+Added-in: 7.10.8
 ---
 
 # NAME
@@ -37,6 +38,8 @@ no server response code has been received.
 Note that a proxy's CONNECT response should be read with
 CURLINFO_HTTP_CONNECTCODE(3) and not this.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -56,10 +59,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# NOTES
+
+The former name, CURLINFO_HTTP_CODE, was added in 7.4.1. Support for SMTP
+responses added in 7.25.0, for OpenLDAP in 7.81.0.
 
-Added in 7.10.8. CURLINFO_HTTP_CODE was added in 7.4.1.
-Support for SMTP responses added in 7.25.0, for OpenLDAP in 7.81.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_RETRY_AFTER.md b/docs/libcurl/opts/CURLINFO_RETRY_AFTER.md
index b194fc922..0dca2e509 100644
--- a/docs/libcurl/opts/CURLINFO_RETRY_AFTER.md
+++ b/docs/libcurl/opts/CURLINFO_RETRY_AFTER.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_header (3)
 Protocol:
   - All
+Added-in: 7.66.0
 ---
 
 # NAME
@@ -37,7 +38,9 @@ or zero if there was no header or the header could not be parsed.
 
 # DEFAULT
 
-Returns zero delay if there was no header.
+Zero if there was no header.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.66.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_RTSP_CLIENT_CSEQ.md b/docs/libcurl/opts/CURLINFO_RTSP_CLIENT_CSEQ.md
index d79e2cc70..52640e998 100644
--- a/docs/libcurl/opts/CURLINFO_RTSP_CLIENT_CSEQ.md
+++ b/docs/libcurl/opts/CURLINFO_RTSP_CLIENT_CSEQ.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - RTSP
+Added-in: 7.20.0
 ---
 
 # NAME
@@ -31,6 +32,8 @@ CURLcode curl_easy_getinfo(CURL *handle, CURLINFO_RTSP_CLIENT_CSEQ,
 Pass a pointer to a long to receive the next CSeq that is expected to be used
 by the application.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -50,9 +53,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.20.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_RTSP_CSEQ_RECV.md b/docs/libcurl/opts/CURLINFO_RTSP_CSEQ_RECV.md
index 3e9d17fcc..4eb11b411 100644
--- a/docs/libcurl/opts/CURLINFO_RTSP_CSEQ_RECV.md
+++ b/docs/libcurl/opts/CURLINFO_RTSP_CSEQ_RECV.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - RTSP
+Added-in: 7.20.0
 ---
 
 # NAME
@@ -31,6 +32,8 @@ server. If your application encounters a *CURLE_RTSP_CSEQ_ERROR* then you
 may wish to troubleshoot and/or fix the CSeq mismatch by peeking at this
 value.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -50,9 +53,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.20.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_RTSP_SERVER_CSEQ.md b/docs/libcurl/opts/CURLINFO_RTSP_SERVER_CSEQ.md
index 5b866c571..1b1d73d88 100644
--- a/docs/libcurl/opts/CURLINFO_RTSP_SERVER_CSEQ.md
+++ b/docs/libcurl/opts/CURLINFO_RTSP_SERVER_CSEQ.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - RTSP
+Added-in: 7.20.0
 ---
 
 # NAME
@@ -35,6 +36,8 @@ Listening for server initiated requests is not implemented!
 Applications wishing to resume an RTSP session on another connection should
 retrieve this info before closing the active connection.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -54,9 +57,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.20.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_RTSP_SESSION_ID.md b/docs/libcurl/opts/CURLINFO_RTSP_SESSION_ID.md
index 24a2b1d57..04feb1b6b 100644
--- a/docs/libcurl/opts/CURLINFO_RTSP_SESSION_ID.md
+++ b/docs/libcurl/opts/CURLINFO_RTSP_SESSION_ID.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - RTSP
+Added-in: 7.20.0
 ---
 
 # NAME
@@ -36,6 +37,8 @@ The **id** pointer is NULL or points to private memory. You MUST NOT free -
 it gets freed when you call curl_easy_cleanup(3) on the corresponding
 CURL handle.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -55,9 +58,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.20.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_SCHEME.md b/docs/libcurl/opts/CURLINFO_SCHEME.md
index 22e0a7a8e..8c109839e 100644
--- a/docs/libcurl/opts/CURLINFO_SCHEME.md
+++ b/docs/libcurl/opts/CURLINFO_SCHEME.md
@@ -12,6 +12,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -39,6 +40,8 @@ CURL handle.
 The returned scheme might be upper or lowercase. Do comparisons case
 insensitively.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_SIZE_DOWNLOAD.md b/docs/libcurl/opts/CURLINFO_SIZE_DOWNLOAD.md
index 6eaad7b7c..9c9866496 100644
--- a/docs/libcurl/opts/CURLINFO_SIZE_DOWNLOAD.md
+++ b/docs/libcurl/opts/CURLINFO_SIZE_DOWNLOAD.md
@@ -12,6 +12,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.4.1
 ---
 
 # NAME
@@ -37,6 +38,8 @@ number.
 CURLINFO_SIZE_DOWNLOAD_T(3) is a newer replacement that returns a more
 sensible variable type.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -62,9 +65,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
+
+Deprecated since 7.55.0.
 
-Added in 7.4.1. Deprecated since 7.55.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_SIZE_DOWNLOAD_T.md b/docs/libcurl/opts/CURLINFO_SIZE_DOWNLOAD_T.md
index 9c2a9cea6..e886f2c11 100644
--- a/docs/libcurl/opts/CURLINFO_SIZE_DOWNLOAD_T.md
+++ b/docs/libcurl/opts/CURLINFO_SIZE_DOWNLOAD_T.md
@@ -12,6 +12,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.55.0
 ---
 
 # NAME
@@ -34,6 +35,8 @@ were downloaded. The amount is only for the latest transfer and gets reset
 again for each new transfer. This counts actual payload data, what's also
 commonly called body. All meta and header data is excluded from this amount.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -59,9 +62,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.55.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_SIZE_UPLOAD.md b/docs/libcurl/opts/CURLINFO_SIZE_UPLOAD.md
index fa3989eed..1ecbddbea 100644
--- a/docs/libcurl/opts/CURLINFO_SIZE_UPLOAD.md
+++ b/docs/libcurl/opts/CURLINFO_SIZE_UPLOAD.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.4.1
 ---
 
 # NAME
@@ -34,6 +35,8 @@ uploaded.
 CURLINFO_SIZE_UPLOAD_T(3) is a newer replacement that returns a more
 sensible variable type.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -58,9 +61,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
+
+Deprecated since 7.55.0.
 
-Added in 7.4.1. Deprecated since 7.55.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_SIZE_UPLOAD_T.md b/docs/libcurl/opts/CURLINFO_SIZE_UPLOAD_T.md
index bea4078ca..06ee47dab 100644
--- a/docs/libcurl/opts/CURLINFO_SIZE_UPLOAD_T.md
+++ b/docs/libcurl/opts/CURLINFO_SIZE_UPLOAD_T.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.55.0
 ---
 
 # NAME
@@ -31,6 +32,8 @@ CURLcode curl_easy_getinfo(CURL *handle, CURLINFO_SIZE_UPLOAD_T,
 Pass a pointer to a *curl_off_t* to receive the total amount of bytes that
 were uploaded.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -55,9 +58,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.55.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_SPEED_DOWNLOAD.md b/docs/libcurl/opts/CURLINFO_SPEED_DOWNLOAD.md
index 98ada9adf..52e7cd0cb 100644
--- a/docs/libcurl/opts/CURLINFO_SPEED_DOWNLOAD.md
+++ b/docs/libcurl/opts/CURLINFO_SPEED_DOWNLOAD.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.4.1
 ---
 
 # NAME
@@ -34,6 +35,8 @@ measured for the complete download. Measured in bytes/second.
 CURLINFO_SPEED_DOWNLOAD_T(3) is a newer replacement that returns a more
 sensible variable type.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -58,9 +61,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
+
+Deprecated since 7.55.0.
 
-Added in 7.4.1. Deprecated since 7.55.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_SPEED_DOWNLOAD_T.md b/docs/libcurl/opts/CURLINFO_SPEED_DOWNLOAD_T.md
index a1f8178bd..a42356b36 100644
--- a/docs/libcurl/opts/CURLINFO_SPEED_DOWNLOAD_T.md
+++ b/docs/libcurl/opts/CURLINFO_SPEED_DOWNLOAD_T.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.55.0
 ---
 
 # NAME
@@ -31,6 +32,8 @@ CURLcode curl_easy_getinfo(CURL *handle, CURLINFO_SPEED_DOWNLOAD_T,
 Pass a pointer to a *curl_off_t* to receive the average download speed
 that curl measured for the complete download. Measured in bytes/second.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -56,9 +59,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.55.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_SPEED_UPLOAD.md b/docs/libcurl/opts/CURLINFO_SPEED_UPLOAD.md
index f963eca19..15d8cf23c 100644
--- a/docs/libcurl/opts/CURLINFO_SPEED_UPLOAD.md
+++ b/docs/libcurl/opts/CURLINFO_SPEED_UPLOAD.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.4.1
 ---
 
 # NAME
@@ -32,6 +33,8 @@ measured for the complete upload. Measured in bytes/second.
 CURLINFO_SPEED_UPLOAD_T(3) is a newer replacement that returns a more
 sensible variable type.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -56,9 +59,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
+
+Deprecated since 7.55.0.
 
-Added in 7.4.1. Deprecated since 7.55.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_SPEED_UPLOAD_T.md b/docs/libcurl/opts/CURLINFO_SPEED_UPLOAD_T.md
index 45cb6bf2d..446943433 100644
--- a/docs/libcurl/opts/CURLINFO_SPEED_UPLOAD_T.md
+++ b/docs/libcurl/opts/CURLINFO_SPEED_UPLOAD_T.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.55.0
 ---
 
 # NAME
@@ -30,6 +31,8 @@ CURLcode curl_easy_getinfo(CURL *handle, CURLINFO_SPEED_UPLOAD_T,
 Pass a pointer to a *curl_off_t* to receive the average upload speed that
 curl measured for the complete upload. Measured in bytes/second.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -54,9 +57,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.55.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_SSL_ENGINES.md b/docs/libcurl/opts/CURLINFO_SSL_ENGINES.md
index 9a4108734..553bd039b 100644
--- a/docs/libcurl/opts/CURLINFO_SSL_ENGINES.md
+++ b/docs/libcurl/opts/CURLINFO_SSL_ENGINES.md
@@ -12,6 +12,7 @@ Protocol:
   - TLS
 TLS-backend:
   - OpenSSL
+Added-in: 7.12.3
 ---
 
 # NAME
@@ -36,6 +37,8 @@ available at runtime. **NOTE:** you must call curl_slist_free_all(3)
 on the list pointer once you are done with it, as libcurl does not free this
 data for you.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -56,9 +59,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.12.3. Available in OpenSSL builds with "engine" support.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_SSL_VERIFYRESULT.md b/docs/libcurl/opts/CURLINFO_SSL_VERIFYRESULT.md
index 0e4fedf58..69726b352 100644
--- a/docs/libcurl/opts/CURLINFO_SSL_VERIFYRESULT.md
+++ b/docs/libcurl/opts/CURLINFO_SSL_VERIFYRESULT.md
@@ -13,6 +13,7 @@ Protocol:
 TLS-backend:
   - OpenSSL
   - GnuTLS
+Added-in: 7.5
 ---
 
 # NAME
@@ -36,6 +37,8 @@ option).
 
 0 is a positive result. Non-zero is an error.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -66,9 +69,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.5. Only set by the OpenSSL/libressl/boringssl and GnuTLS backends.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_STARTTRANSFER_TIME.md b/docs/libcurl/opts/CURLINFO_STARTTRANSFER_TIME.md
index b58e41ac5..0e64ba8bf 100644
--- a/docs/libcurl/opts/CURLINFO_STARTTRANSFER_TIME.md
+++ b/docs/libcurl/opts/CURLINFO_STARTTRANSFER_TIME.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.9.2
 ---
 
 # NAME
@@ -37,6 +38,8 @@ When a redirect is followed, the time from each request is added together.
 
 See also the TIMES overview in the curl_easy_getinfo(3) man page.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.9.2
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_STARTTRANSFER_TIME_T.md b/docs/libcurl/opts/CURLINFO_STARTTRANSFER_TIME_T.md
index 27c55bfc8..39894d6f7 100644
--- a/docs/libcurl/opts/CURLINFO_STARTTRANSFER_TIME_T.md
+++ b/docs/libcurl/opts/CURLINFO_STARTTRANSFER_TIME_T.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.61.0
 ---
 
 # NAME
@@ -38,6 +39,8 @@ When a redirect is followed, the time from each request is added together.
 
 See also the TIMES overview in the curl_easy_getinfo(3) man page.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -62,9 +65,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.61.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_TLS_SESSION.md b/docs/libcurl/opts/CURLINFO_TLS_SESSION.md
index 2dc710a4a..e990ec6ec 100644
--- a/docs/libcurl/opts/CURLINFO_TLS_SESSION.md
+++ b/docs/libcurl/opts/CURLINFO_TLS_SESSION.md
@@ -13,6 +13,7 @@ Protocol:
 TLS-backend:
   - OpenSSL
   - GnuTLS
+Added-in: 7.34.0
 ---
 
 # NAME
@@ -47,6 +48,8 @@ function *SSL_get_SSL_CTX(3)*. Therefore unless you need compatibility
 with older versions of libcurl use CURLINFO_TLS_SSL_PTR(3). Refer to
 that document for more information.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -66,10 +69,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
+
+Deprecated since 7.48.0
 
-Added in 7.34.0. Deprecated since 7.48.0 and supported by OpenSSL and GnuTLS
-only up until this version was released.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_TLS_SSL_PTR.md b/docs/libcurl/opts/CURLINFO_TLS_SSL_PTR.md
index 097bf98b3..de8965a19 100644
--- a/docs/libcurl/opts/CURLINFO_TLS_SSL_PTR.md
+++ b/docs/libcurl/opts/CURLINFO_TLS_SSL_PTR.md
@@ -18,6 +18,7 @@ TLS-backend:
   - Schannel
   - Secure Transport
   - wolfSSL
+Added-in: 7.48.0
 ---
 
 # NAME
@@ -60,8 +61,8 @@ struct curl_tlssessioninfo {
 The *backend* struct member is one of the defines in the CURLSSLBACKEND_*
 series: CURLSSLBACKEND_NONE (when built without TLS support),
 CURLSSLBACKEND_WOLFSSL, CURLSSLBACKEND_SECURETRANSPORT, CURLSSLBACKEND_GNUTLS,
-CURLSSLBACKEND_MBEDTLS, CURLSSLBACKEND_NSS, CURLSSLBACKEND_OPENSSL,
-CURLSSLBACKEND_SCHANNEL or CURLSSLBACKEND_MESALINK. (Note that the OpenSSL
+CURLSSLBACKEND_MBEDTLS, CURLSSLBACKEND_NSS, CURLSSLBACKEND_OPENSSL or
+CURLSSLBACKEND_SCHANNEL. (Note that the OpenSSL
 forks are all reported as just OpenSSL here.)
 
 The *internals* struct member points to a TLS library specific pointer for
@@ -95,6 +96,8 @@ as well:
 
 **SSL ***
 
+##
+
 If the *internals* pointer is NULL then either the SSL backend is not
 supported, an SSL session has not yet been established or the connection is no
 longer associated with the easy handle (e.g. curl_easy_perform(3) has
@@ -131,6 +134,8 @@ How are you using this option? Are you affected by any of these limitations?
 Please let us know by making a comment at
 https://github.com/curl/curl/issues/685
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -164,13 +169,13 @@ int main(int argc, char **argv)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.48.0.
+# HISTORY
 
 This option supersedes CURLINFO_TLS_SESSION(3) which was added in 7.34.0.
 This option is exactly the same as that option except in the case of OpenSSL.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, and CURLE_UNKNOWN_OPTION if not.
diff --git a/docs/libcurl/opts/CURLINFO_TOTAL_TIME.md b/docs/libcurl/opts/CURLINFO_TOTAL_TIME.md
index 022960590..f752a23de 100644
--- a/docs/libcurl/opts/CURLINFO_TOTAL_TIME.md
+++ b/docs/libcurl/opts/CURLINFO_TOTAL_TIME.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.4.1
 ---
 
 # NAME
@@ -35,6 +36,8 @@ When a redirect is followed, the time from each request is added together.
 
 See also the TIMES overview in the curl_easy_getinfo(3) man page.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -58,9 +61,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.4.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_TOTAL_TIME_T.md b/docs/libcurl/opts/CURLINFO_TOTAL_TIME_T.md
index 0bff41bd4..0b0d16ab7 100644
--- a/docs/libcurl/opts/CURLINFO_TOTAL_TIME_T.md
+++ b/docs/libcurl/opts/CURLINFO_TOTAL_TIME_T.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 7.61.0
 ---
 # NAME
 
@@ -35,6 +36,8 @@ When a redirect is followed, the time from each request is added together.
 
 See also the TIMES overview in the curl_easy_getinfo(3) man page.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -59,9 +62,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.61.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_USED_PROXY.md b/docs/libcurl/opts/CURLINFO_USED_PROXY.md
index 7b38ea027..aeabb97af 100644
--- a/docs/libcurl/opts/CURLINFO_USED_PROXY.md
+++ b/docs/libcurl/opts/CURLINFO_USED_PROXY.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 8.7.0
 ---
 
 # NAME
@@ -31,6 +32,8 @@ CURLcode curl_easy_getinfo(CURL *handle, CURLINFO_USED_PROXY,
 Pass a pointer to a long. It gets set to zero set if no proxy was used in the
 previous transfer or a non-zero value if a proxy was used.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -58,9 +61,7 @@ int main(int argc, char *argv[])
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 8.7.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLINFO_XFER_ID.md b/docs/libcurl/opts/CURLINFO_XFER_ID.md
index 0855ac9a1..f87559321 100644
--- a/docs/libcurl/opts/CURLINFO_XFER_ID.md
+++ b/docs/libcurl/opts/CURLINFO_XFER_ID.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_setopt (3)
 Protocol:
   - All
+Added-in: 8.2.0
 ---
 
 # NAME
@@ -35,6 +36,8 @@ The transfer id is unique among all transfers performed using the same
 connection cache. This is implicitly the case for all transfers in the
 same multi handle.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -59,9 +62,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 8.2.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE.md b/docs/libcurl/opts/CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE.md
index e292792ee..ff232ed64 100644
--- a/docs/libcurl/opts/CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE.md
+++ b/docs/libcurl/opts/CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE.md
@@ -10,6 +10,7 @@ See-also:
   - CURLMOPT_PIPELINING (3)
 Protocol:
   - HTTP
+Added-in: 7.30.0
 ---
 
 # NAME
@@ -37,7 +38,9 @@ than CURLMOPT_MAX_PIPELINE_LENGTH(3).
 
 # DEFAULT
 
-The default value is 0, which means that the penalization is inactive.
+0, which means that penalization is inactive.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -50,9 +53,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.30.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE.md b/docs/libcurl/opts/CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE.md
index 8f0783b60..bbd90553e 100644
--- a/docs/libcurl/opts/CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE.md
+++ b/docs/libcurl/opts/CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE.md
@@ -9,6 +9,7 @@ See-also:
   - CURLMOPT_PIPELINING (3)
 Protocol:
   - HTTP
+Added-in: 7.30.0
 ---
 
 # NAME
@@ -36,7 +37,9 @@ CURLMOPT_MAX_PIPELINE_LENGTH(3).
 
 # DEFAULT
 
-The default value is 0, which means that the size penalization is inactive.
+0, which means that the size penalization is inactive.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -49,9 +52,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.30.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLMOPT_MAXCONNECTS.md b/docs/libcurl/opts/CURLMOPT_MAXCONNECTS.md
index 1e5a947ed..d4223f126 100644
--- a/docs/libcurl/opts/CURLMOPT_MAXCONNECTS.md
+++ b/docs/libcurl/opts/CURLMOPT_MAXCONNECTS.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_MAXCONNECTS (3)
 Protocol:
   - All
+Added-in: 7.16.3
 ---
 
 # NAME
@@ -52,6 +53,8 @@ ones to get made.
 
 See DESCRIPTION
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -63,9 +66,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.16.3
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLMOPT_MAX_CONCURRENT_STREAMS.md b/docs/libcurl/opts/CURLMOPT_MAX_CONCURRENT_STREAMS.md
index b8e7fefdb..c628ca2bc 100644
--- a/docs/libcurl/opts/CURLMOPT_MAX_CONCURRENT_STREAMS.md
+++ b/docs/libcurl/opts/CURLMOPT_MAX_CONCURRENT_STREAMS.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_MAXCONNECTS (3)
 Protocol:
   - HTTP
+Added-in: 7.67.0
 ---
 
 # NAME
@@ -37,6 +38,8 @@ value passed here would be honored based on other system resources properties.
 
 100
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -48,9 +51,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.67.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLMOPT_MAX_HOST_CONNECTIONS.md b/docs/libcurl/opts/CURLMOPT_MAX_HOST_CONNECTIONS.md
index f798a4626..39567f1e2 100644
--- a/docs/libcurl/opts/CURLMOPT_MAX_HOST_CONNECTIONS.md
+++ b/docs/libcurl/opts/CURLMOPT_MAX_HOST_CONNECTIONS.md
@@ -9,6 +9,7 @@ See-also:
   - CURLMOPT_MAX_TOTAL_CONNECTIONS (3)
 Protocol:
   - All
+Added-in: 7.30.0
 ---
 
 # NAME
@@ -55,6 +56,8 @@ ones to get made.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -66,9 +69,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.30.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLMOPT_MAX_PIPELINE_LENGTH.md b/docs/libcurl/opts/CURLMOPT_MAX_PIPELINE_LENGTH.md
index 84ab65e62..9da9994ab 100644
--- a/docs/libcurl/opts/CURLMOPT_MAX_PIPELINE_LENGTH.md
+++ b/docs/libcurl/opts/CURLMOPT_MAX_PIPELINE_LENGTH.md
@@ -9,6 +9,7 @@ See-also:
   - CURLMOPT_PIPELINING (3)
 Protocol:
   - All
+Added-in: 7.30.0
 ---
 
 # NAME
@@ -42,6 +43,8 @@ CURLMOPT_MAX_PIPELINE_LENGTH(3).
 
 5
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -53,9 +56,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.30.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLMOPT_MAX_TOTAL_CONNECTIONS.md b/docs/libcurl/opts/CURLMOPT_MAX_TOTAL_CONNECTIONS.md
index a227a9cce..1a7fe170f 100644
--- a/docs/libcurl/opts/CURLMOPT_MAX_TOTAL_CONNECTIONS.md
+++ b/docs/libcurl/opts/CURLMOPT_MAX_TOTAL_CONNECTIONS.md
@@ -9,6 +9,7 @@ See-also:
   - CURLMOPT_MAX_HOST_CONNECTIONS (3)
 Protocol:
   - All
+Added-in: 7.30.0
 ---
 
 # NAME
@@ -45,8 +46,10 @@ timeout is however treated as a per-connect timeout.
 
 # DEFAULT
 
-The default value is 0, which means that there is no limit. It is then simply
-controlled by the number of easy handles added.
+0, which means that there is no limit. It is then simply controlled by the
+number of easy handles added.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -59,9 +62,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.30.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLMOPT_PIPELINING.md b/docs/libcurl/opts/CURLMOPT_PIPELINING.md
index 6072ae361..caee088dd 100644
--- a/docs/libcurl/opts/CURLMOPT_PIPELINING.md
+++ b/docs/libcurl/opts/CURLMOPT_PIPELINING.md
@@ -13,6 +13,7 @@ See-also:
   - CURLMOPT_PIPELINING_SITE_BL (3)
 Protocol:
   - HTTP
+Added-in: 7.16.0
 ---
 
 # NAME
@@ -50,9 +51,9 @@ existing connection if possible. This requires HTTP/2 or HTTP/3.
 
 # DEFAULT
 
-Since 7.62.0, **CURLPIPE_MULTIPLEX** is enabled by default.
+**CURLPIPE_MULTIPLEX**
 
-Before that, default was **CURLPIPE_NOTHING**.
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -65,10 +66,16 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
+
+The multiplex support bit was added in 7.43.0. HTTP/1 Pipelining support was
+disabled in 7.62.0.
+
+Since 7.62.0, **CURLPIPE_MULTIPLEX** is enabled by default.
+
+Before that, default was **CURLPIPE_NOTHING**.
 
-Added in 7.16.0. Multiplex support bit added in 7.43.0. HTTP/1 Pipelining
-support was disabled in 7.62.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLMOPT_PIPELINING_SERVER_BL.md b/docs/libcurl/opts/CURLMOPT_PIPELINING_SERVER_BL.md
index 0fc11fdc3..b009de81c 100644
--- a/docs/libcurl/opts/CURLMOPT_PIPELINING_SERVER_BL.md
+++ b/docs/libcurl/opts/CURLMOPT_PIPELINING_SERVER_BL.md
@@ -9,6 +9,7 @@ See-also:
   - CURLMOPT_PIPELINING_SITE_BL (3)
 Protocol:
   - HTTP
+Added-in: 7.30.0
 ---
 
 # NAME
@@ -41,7 +42,9 @@ Pass a NULL pointer to clear the block list.
 
 # DEFAULT
 
-The default value is NULL, which means that there is no block list.
+NULL, which means that there is no block list.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -59,9 +62,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.30.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLMOPT_PIPELINING_SITE_BL.md b/docs/libcurl/opts/CURLMOPT_PIPELINING_SITE_BL.md
index dc009a27d..9e9e20ac1 100644
--- a/docs/libcurl/opts/CURLMOPT_PIPELINING_SITE_BL.md
+++ b/docs/libcurl/opts/CURLMOPT_PIPELINING_SITE_BL.md
@@ -9,6 +9,7 @@ See-also:
   - CURLMOPT_PIPELINING_SERVER_BL (3)
 Protocol:
   - HTTP
+Added-in: 7.30.0
 ---
 
 # NAME
@@ -36,7 +37,9 @@ Pass a NULL pointer to clear the block list.
 
 # DEFAULT
 
-The default value is NULL, which means that there is no block list.
+NULL, which means that there is no block list.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -55,9 +58,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.30.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLMOPT_PUSHDATA.md b/docs/libcurl/opts/CURLMOPT_PUSHDATA.md
index 23399d17d..5499225da 100644
--- a/docs/libcurl/opts/CURLMOPT_PUSHDATA.md
+++ b/docs/libcurl/opts/CURLMOPT_PUSHDATA.md
@@ -11,6 +11,7 @@ See-also:
   - RFC 7540
 Protocol:
   - HTTP
+Added-in: 7.44.0
 ---
 
 # NAME
@@ -35,6 +36,8 @@ libcurl itself, only passed on to the callback function.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -76,9 +79,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.44.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLMOPT_PUSHFUNCTION.md b/docs/libcurl/opts/CURLMOPT_PUSHFUNCTION.md
index c80112839..d8f800380 100644
--- a/docs/libcurl/opts/CURLMOPT_PUSHFUNCTION.md
+++ b/docs/libcurl/opts/CURLMOPT_PUSHFUNCTION.md
@@ -11,6 +11,7 @@ See-also:
   - RFC 7540
 Protocol:
   - HTTP
+Added-in: 7.44.0
 ---
 
 # NAME
@@ -96,6 +97,8 @@ All other return codes are reserved for future use.
 
 NULL, no callback
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -137,9 +140,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.44.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLMOPT_SOCKETDATA.md b/docs/libcurl/opts/CURLMOPT_SOCKETDATA.md
index 7aea20c44..aade927a1 100644
--- a/docs/libcurl/opts/CURLMOPT_SOCKETDATA.md
+++ b/docs/libcurl/opts/CURLMOPT_SOCKETDATA.md
@@ -10,6 +10,7 @@ See-also:
   - curl_multi_socket_action (3)
 Protocol:
   - All
+Added-in: 7.15.4
 ---
 
 # NAME
@@ -36,6 +37,8 @@ callback's **clientp** argument.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -71,9 +74,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.15.4
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLMOPT_SOCKETFUNCTION.md b/docs/libcurl/opts/CURLMOPT_SOCKETFUNCTION.md
index a16747c04..a53ee43d3 100644
--- a/docs/libcurl/opts/CURLMOPT_SOCKETFUNCTION.md
+++ b/docs/libcurl/opts/CURLMOPT_SOCKETFUNCTION.md
@@ -10,6 +10,7 @@ See-also:
   - curl_multi_socket_action (3)
 Protocol:
   - All
+Added-in: 7.15.4
 ---
 
 # NAME
@@ -89,6 +90,8 @@ active transfer. It might soon be added again.
 
 NULL (no callback)
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -124,9 +127,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.15.4
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLMOPT_TIMERDATA.md b/docs/libcurl/opts/CURLMOPT_TIMERDATA.md
index fb830b1fb..4f0ce4e73 100644
--- a/docs/libcurl/opts/CURLMOPT_TIMERDATA.md
+++ b/docs/libcurl/opts/CURLMOPT_TIMERDATA.md
@@ -9,6 +9,7 @@ See-also:
   - CURLMOPT_TIMERFUNCTION (3)
 Protocol:
   - All
+Added-in: 7.16.0
 ---
 
 # NAME
@@ -35,6 +36,8 @@ callback's **clientp** argument.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.16.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLMOPT_TIMERFUNCTION.md b/docs/libcurl/opts/CURLMOPT_TIMERFUNCTION.md
index 85f9957a7..40ec76eb9 100644
--- a/docs/libcurl/opts/CURLMOPT_TIMERFUNCTION.md
+++ b/docs/libcurl/opts/CURLMOPT_TIMERFUNCTION.md
@@ -9,6 +9,7 @@ See-also:
   - CURLMOPT_TIMERDATA (3)
 Protocol:
   - All
+Added-in: 7.16.0
 ---
 
 # NAME
@@ -63,6 +64,8 @@ callback with a zero timeout...
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -92,9 +95,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.16.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_ABSTRACT_UNIX_SOCKET.md b/docs/libcurl/opts/CURLOPT_ABSTRACT_UNIX_SOCKET.md
index c34acbd63..c2b3a3ca1 100644
--- a/docs/libcurl/opts/CURLOPT_ABSTRACT_UNIX_SOCKET.md
+++ b/docs/libcurl/opts/CURLOPT_ABSTRACT_UNIX_SOCKET.md
@@ -9,6 +9,7 @@ See-also:
   - unix (7)
 Protocol:
   - All
+Added-in: 7.53.0
 ---
 
 # NAME
@@ -42,7 +43,9 @@ share the same storage and therefore only one of them can be set per handle.
 
 # DEFAULT
 
-Default is NULL.
+NULL
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.53.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_ACCEPTTIMEOUT_MS.md b/docs/libcurl/opts/CURLOPT_ACCEPTTIMEOUT_MS.md
index f1db8fa69..90c1060e6 100644
--- a/docs/libcurl/opts/CURLOPT_ACCEPTTIMEOUT_MS.md
+++ b/docs/libcurl/opts/CURLOPT_ACCEPTTIMEOUT_MS.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_STDERR (3)
 Protocol:
   - FTP
+Added-in: 7.24.0
 ---
 
 # NAME
@@ -33,6 +34,8 @@ server to connect back to libcurl when an active FTP connection is used.
 
 60000 milliseconds
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -50,9 +53,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.24.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_ACCEPT_ENCODING.md b/docs/libcurl/opts/CURLOPT_ACCEPT_ENCODING.md
index c090ef318..bd80d842f 100644
--- a/docs/libcurl/opts/CURLOPT_ACCEPT_ENCODING.md
+++ b/docs/libcurl/opts/CURLOPT_ACCEPT_ENCODING.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_TRANSFER_ENCODING (3)
 Protocol:
   - HTTP
+Added-in: 7.21.6
 ---
 
 # NAME
@@ -71,10 +72,23 @@ sending the length of the non-compressed content is a common server mistake).
 The application does not have to keep the string around after setting this
 option.
 
+# HISTORY
+
+This option was called CURLOPT_ENCODING before 7.21.6
+
+# NOTES
+
+The specific libcurl you are using must have been built with zlib to be able to
+decompress gzip and deflate responses, with the brotli library to
+decompress brotli responses and with the zstd library to decompress zstd
+responses.
+
 # DEFAULT
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -93,14 +107,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-This option was called CURLOPT_ENCODING before 7.21.6
-
-The specific libcurl you are using must have been built with zlib to be able to
-decompress gzip and deflate responses, with the brotli library to
-decompress brotli responses and with the zstd library to decompress zstd
-responses.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_ADDRESS_SCOPE.md b/docs/libcurl/opts/CURLOPT_ADDRESS_SCOPE.md
index 24ea2e581..e8ac90c0e 100644
--- a/docs/libcurl/opts/CURLOPT_ADDRESS_SCOPE.md
+++ b/docs/libcurl/opts/CURLOPT_ADDRESS_SCOPE.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_STDERR (3)
 Protocol:
   - All
+Added-in: 7.19.0
 ---
 
 # NAME
@@ -31,6 +32,8 @@ Pass a long specifying the scope id value to use when connecting to IPv6 address
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -51,9 +54,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.19.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_ALTSVC.md b/docs/libcurl/opts/CURLOPT_ALTSVC.md
index 8ca2de4be..43c52a47e 100644
--- a/docs/libcurl/opts/CURLOPT_ALTSVC.md
+++ b/docs/libcurl/opts/CURLOPT_ALTSVC.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_RESOLVE (3)
 Protocol:
   - HTTP
+Added-in: 7.64.1
 ---
 <!-- markdown-link-check-disable -->
 # NAME
@@ -38,6 +39,8 @@ Specify a blank filename ("") to make libcurl not load from a file at all.
 
 NULL. The alt-svc cache is not read nor written to file.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -100,9 +103,7 @@ Boolean (1 or 0) if "persist" was set for this entry
 
 Integer priority value (not currently used)
 
-# AVAILABILITY
-
-Added in 7.64.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_ALTSVC_CTRL.md b/docs/libcurl/opts/CURLOPT_ALTSVC_CTRL.md
index 971f33fcb..225585443 100644
--- a/docs/libcurl/opts/CURLOPT_ALTSVC_CTRL.md
+++ b/docs/libcurl/opts/CURLOPT_ALTSVC_CTRL.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_RESOLVE (3)
 Protocol:
   - HTTP
+Added-in: 7.64.1
 ---
 
 # NAME
@@ -43,6 +44,11 @@ Alternative services are only used when setting up new connections. If there
 exists an existing connection to the host in the connection pool, then that is
 preferred.
 
+If CURLOPT_ALTSVC(3) is set, CURLOPT_ALTSVC_CTRL(3) gets a default value
+corresponding to CURLALTSVC_H1 | CURLALTSVC_H2 | CURLALTSVC_H3 - the HTTP/2
+and HTTP/3 bits are only set if libcurl was built with support for those
+versions.
+
 Setting any bit enables the alt-svc engine.
 
 ## CURLALTSVC_READONLYFILE
@@ -67,10 +73,9 @@ was also built to actually support HTTP/3, otherwise this bit is ignored.
 
 # DEFAULT
 
-Alt-Svc handling is disabled by default. If CURLOPT_ALTSVC(3) is set,
-CURLOPT_ALTSVC_CTRL(3) has a default value corresponding to
-CURLALTSVC_H1 | CURLALTSVC_H2 | CURLALTSVC_H3 - the HTTP/2 and HTTP/3 bits are
-only set if libcurl was built with support for those versions.
+0 - Alt-Svc handling is disabled
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -86,9 +91,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.64.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_APPEND.md b/docs/libcurl/opts/CURLOPT_APPEND.md
index 6c5142b49..857f88012 100644
--- a/docs/libcurl/opts/CURLOPT_APPEND.md
+++ b/docs/libcurl/opts/CURLOPT_APPEND.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_UPLOAD (3)
 Protocol:
   - FTP
+Added-in: 7.17.0
 ---
 
 # NAME
@@ -33,6 +34,8 @@ instead of overwrite it. This is only useful when uploading to an FTP site.
 
 0 (disabled)
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -50,10 +53,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 This option was known as CURLOPT_FTPAPPEND up to 7.16.4
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, and CURLE_UNKNOWN_OPTION if not.
diff --git a/docs/libcurl/opts/CURLOPT_AUTOREFERER.md b/docs/libcurl/opts/CURLOPT_AUTOREFERER.md
index 754dee3ba..5106d84c8 100644
--- a/docs/libcurl/opts/CURLOPT_AUTOREFERER.md
+++ b/docs/libcurl/opts/CURLOPT_AUTOREFERER.md
@@ -12,6 +12,7 @@ See-also:
   - CURLOPT_REFERER (3)
 Protocol:
   - HTTP
+Added-in: 7.1
 ---
 
 # NAME
@@ -43,6 +44,8 @@ referer header after the transfer.
 
 0, disabled
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -66,9 +69,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with HTTP
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_AWS_SIGV4.md b/docs/libcurl/opts/CURLOPT_AWS_SIGV4.md
index adb6d6afd..2e61e897c 100644
--- a/docs/libcurl/opts/CURLOPT_AWS_SIGV4.md
+++ b/docs/libcurl/opts/CURLOPT_AWS_SIGV4.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_PROXYAUTH (3)
 Protocol:
   - HTTP
+Added-in: 7.75.0
 ---
 
 # NAME
@@ -50,23 +51,28 @@ It is extracted from the hostname specified in the URL if omitted.
 The argument is a function provided by a cloud. It is extracted from the
 hostname specified in the URL if omitted.
 
-NOTE: This call set CURLOPT_HTTPAUTH(3) to CURLAUTH_AWS_SIGV4.
-Calling CURLOPT_HTTPAUTH(3) with CURLAUTH_AWS_SIGV4 is the same
-as calling this with **"aws:amz"** in parameter.
+##
+
+NOTE: This call set CURLOPT_HTTPAUTH(3) to CURLAUTH_AWS_SIGV4. Calling
+CURLOPT_HTTPAUTH(3) with CURLAUTH_AWS_SIGV4 is the same as calling this with
+**"aws:amz"** in parameter.
 
 Example with "Test:Try", when curl uses the algorithm, it generates
-**"TEST-HMAC-SHA256"** for "Algorithm", **"x-try-date"** and
-**"X-Try-Date"** for "date", **"test4_request"** for "request type",
+**"TEST-HMAC-SHA256"** for "Algorithm", **"x-try-date"** and **"X-Try-Date"**
+for "date", **"test4_request"** for "request type",
 **"SignedHeaders=content-type;host;x-try-date"** for "signed headers"
 
 If you use just "test", instead of "test:try", test is used for every
 generated string.
 
+Setting CURLOPT_HTTPAUTH(3) with the CURLAUTH_AWS_SIGV4 bit set is the same as
+setting this option with a **"aws:amz"** parameter.
+
 # DEFAULT
 
-By default, the value of this parameter is NULL.
-Calling CURLOPT_HTTPAUTH(3) with CURLAUTH_AWS_SIGV4 is the same
-as calling this with **"aws:amz"** in parameter.
+NULL
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -91,19 +97,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.75.0
-
-# RETURN VALUE
-
-Returns CURLE_OK if the option is supported, and CURLE_UNKNOWN_OPTION if not.
-
 # NOTES
 
 This option overrides the other auth types you might have set in
-CURLOPT_HTTPAUTH(3) which should be highlighted as this makes this auth
-method special. This method cannot be combined with other auth types.
+CURLOPT_HTTPAUTH(3) which should be highlighted as this makes this auth method
+special. This method cannot be combined with other auth types.
 
 A sha256 checksum of the request payload is used as input to the signature
 calculation. For POST requests, this is a checksum of the provided
@@ -111,6 +109,12 @@ CURLOPT_POSTFIELDS(3). Otherwise, it is the checksum of an empty buffer. For
 requests like PUT, you can provide your own checksum in an HTTP header named
 **x-provider2-content-sha256**.
 
-For **aws:s3**, a **x-amz-content-sha256** header is added to every request
-if not already present. For s3 requests with unknown payload, this header takes
+For **aws:s3**, a **x-amz-content-sha256** header is added to every request if
+not already present. For s3 requests with unknown payload, this header takes
 the special value "UNSIGNED-PAYLOAD".
+
+# %AVAILABILITY%
+
+# RETURN VALUE
+
+Returns CURLE_OK if the option is supported, and CURLE_UNKNOWN_OPTION if not.
diff --git a/docs/libcurl/opts/CURLOPT_BUFFERSIZE.md b/docs/libcurl/opts/CURLOPT_BUFFERSIZE.md
index d2c13b6b3..5225dedf3 100644
--- a/docs/libcurl/opts/CURLOPT_BUFFERSIZE.md
+++ b/docs/libcurl/opts/CURLOPT_BUFFERSIZE.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_WRITEFUNCTION (3)
 Protocol:
   - All
+Added-in: 7.10
 ---
 
 # NAME
@@ -53,6 +54,8 @@ allocated as long as there are active transfers.
 
 CURL_MAX_WRITE_SIZE (16kB)
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -73,9 +76,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10. Growing the buffer was added in 7.53.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_CAINFO.md b/docs/libcurl/opts/CURLOPT_CAINFO.md
index 87d1a8809..2eeedd508 100644
--- a/docs/libcurl/opts/CURLOPT_CAINFO.md
+++ b/docs/libcurl/opts/CURLOPT_CAINFO.md
@@ -15,6 +15,7 @@ Protocol:
   - TLS
 TLS-backend:
   - All
+Added-in: 7.4.2
 ---
 
 # NAME
@@ -60,6 +61,8 @@ The default value for this can be figured out with CURLINFO_CAINFO(3).
 Built-in system specific. When curl is built with Secure Transport or
 Schannel, this option is not set by default.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -75,10 +78,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 Schannel support added in libcurl 7.60.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, CURLE_UNKNOWN_OPTION if not, or
diff --git a/docs/libcurl/opts/CURLOPT_CAINFO_BLOB.md b/docs/libcurl/opts/CURLOPT_CAINFO_BLOB.md
index d65024325..efb071737 100644
--- a/docs/libcurl/opts/CURLOPT_CAINFO_BLOB.md
+++ b/docs/libcurl/opts/CURLOPT_CAINFO_BLOB.md
@@ -19,6 +19,7 @@ TLS-backend:
   - wolfSSL
   - Secure Transport
   - Schannel
+Added-in: 7.77.0
 ---
 
 # NAME
@@ -53,6 +54,8 @@ This option overrides CURLOPT_CAINFO(3).
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -76,14 +79,14 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.77.0.
+# HISTORY
 
 This option is supported by the BearSSL (since 7.79.0), mbedTLS (since
 7.81.0), rustls (since 7.82.0), wolfSSL (since 8.2.0), OpenSSL, Secure
 Transport and Schannel backends.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, CURLE_UNKNOWN_OPTION if not, or
diff --git a/docs/libcurl/opts/CURLOPT_CAPATH.md b/docs/libcurl/opts/CURLOPT_CAPATH.md
index 08caf762a..3094bf8b5 100644
--- a/docs/libcurl/opts/CURLOPT_CAPATH.md
+++ b/docs/libcurl/opts/CURLOPT_CAPATH.md
@@ -16,6 +16,7 @@ TLS-backend:
   - GnuTLS
   - mbedTLS
   - wolfSSL
+Added-in: 7.9.8
 ---
 
 # NAME
@@ -48,7 +49,9 @@ The default value for this can be figured out with CURLINFO_CAPATH(3).
 
 # DEFAULT
 
-A default path detected at build time.
+A path detected at build time.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -66,9 +69,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-This option is supported by the OpenSSL, GnuTLS, mbedTLS and wolfSSL backends.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_CA_CACHE_TIMEOUT.md b/docs/libcurl/opts/CURLOPT_CA_CACHE_TIMEOUT.md
index aa479b6be..725efc365 100644
--- a/docs/libcurl/opts/CURLOPT_CA_CACHE_TIMEOUT.md
+++ b/docs/libcurl/opts/CURLOPT_CA_CACHE_TIMEOUT.md
@@ -13,7 +13,11 @@ See-also:
 Protocol:
   - TLS
 TLS-backend:
+  - GnuTLS
   - OpenSSL
+  - Schannel
+  - wolfSSL
+Added-in: 7.87.0
 ---
 
 # NAME
@@ -31,21 +35,24 @@ CURLcode curl_easy_setopt(CURL *handle, CURLOPT_CA_CACHE_TIMEOUT, long age);
 # DESCRIPTION
 
 Pass a long, this sets the timeout in seconds. This tells libcurl the maximum
-time any cached certificate store it has in memory may be kept and reused for
-new connections. Once the timeout has expired, a subsequent fetch requiring a
-certificate has to reload it.
+time any cached CA certificate store it has in memory may be kept and reused
+for new connections. Once the timeout has expired, a subsequent fetch
+requiring a CA certificate has to reload it.
 
-Building a certificate store from a CURLOPT_CAINFO(3) file is a slow
-operation so curl may cache the generated certificate store internally to speed
-up future connections.
+Building a CA certificate store from a CURLOPT_CAINFO(3) file is a slow
+operation so curl may cache the generated certificate store internally to
+speed up future connections.
 
-Set to zero to completely disable caching, or set to -1 to retain the cached
-store remain forever. By default, libcurl caches this info for 24 hours.
+Set the timeout to zero to completely disable caching, or set to -1 to retain
+the cached store remain forever. By default, libcurl caches this info for 24
+hours.
 
 # DEFAULT
 
 86400 (24 hours)
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -70,12 +77,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
-This option was added in curl 7.87.0.
+This option is supported by OpenSSL and its forks (since 7.87.0), Schannel
+(since 8.5.0), wolfSSL (since 8.9.0) and GnuTLS (since 8.9.0).
 
-This option is supported by OpenSSL and its forks (since 7.87.0) and Schannel
-(since 8.5.0).
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_CERTINFO.md b/docs/libcurl/opts/CURLOPT_CERTINFO.md
index 71339cd03..abceeb46d 100644
--- a/docs/libcurl/opts/CURLOPT_CERTINFO.md
+++ b/docs/libcurl/opts/CURLOPT_CERTINFO.md
@@ -17,6 +17,7 @@ TLS-backend:
   - GnuTLS
   - Schannel
   - Secure Transport
+Added-in: 7.19.1
 ---
 
 # NAME
@@ -43,6 +44,8 @@ its option CURLINFO_CERTINFO(3).
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -82,9 +85,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 Schannel support added in 7.50.0. Secure Transport support added in 7.79.0.
+mbedTLS support added in 8.9.0.
+
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_CHUNK_BGN_FUNCTION.md b/docs/libcurl/opts/CURLOPT_CHUNK_BGN_FUNCTION.md
index 01b6f78dc..5882a9e25 100644
--- a/docs/libcurl/opts/CURLOPT_CHUNK_BGN_FUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_CHUNK_BGN_FUNCTION.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_WILDCARDMATCH (3)
 Protocol:
   - FTP
+Added-in: 7.21.0
 ---
 
 # NAME
@@ -83,6 +84,8 @@ Return *CURL_CHUNK_BGN_FUNC_OK* if everything is fine,
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -141,9 +144,7 @@ int main()
 }
 ~~~
 
-# AVAILABILITY
-
-This was added in 7.21.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_CHUNK_DATA.md b/docs/libcurl/opts/CURLOPT_CHUNK_DATA.md
index b501138e9..5a7ebd6a3 100644
--- a/docs/libcurl/opts/CURLOPT_CHUNK_DATA.md
+++ b/docs/libcurl/opts/CURLOPT_CHUNK_DATA.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_WILDCARDMATCH (3)
 Protocol:
   - FTP
+Added-in: 7.21.0
 ---
 
 # NAME
@@ -33,6 +34,8 @@ CURLOPT_CHUNK_END_FUNCTION(3).
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -91,9 +94,7 @@ int main()
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.21.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_CHUNK_END_FUNCTION.md b/docs/libcurl/opts/CURLOPT_CHUNK_END_FUNCTION.md
index 295e29ea9..30a2efb12 100644
--- a/docs/libcurl/opts/CURLOPT_CHUNK_END_FUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_CHUNK_END_FUNCTION.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_WILDCARDMATCH (3)
 Protocol:
   - FTP
+Added-in: 7.21.0
 ---
 
 # NAME
@@ -41,6 +42,8 @@ Return *CURL_CHUNK_END_FUNC_OK* if everything is fine or
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -71,9 +74,7 @@ int main()
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.21.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_CLOSESOCKETDATA.md b/docs/libcurl/opts/CURLOPT_CLOSESOCKETDATA.md
index 7353af9ae..deea601cf 100644
--- a/docs/libcurl/opts/CURLOPT_CLOSESOCKETDATA.md
+++ b/docs/libcurl/opts/CURLOPT_CLOSESOCKETDATA.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_OPENSOCKETFUNCTION (3)
 Protocol:
   - All
+Added-in: 7.21.7
 ---
 
 # NAME
@@ -32,7 +33,9 @@ CURLOPT_CLOSESOCKETFUNCTION(3).
 
 # DEFAULT
 
-The default value of this parameter is NULL.
+NULL
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.21.7
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_CLOSESOCKETFUNCTION.md b/docs/libcurl/opts/CURLOPT_CLOSESOCKETFUNCTION.md
index 18e3bfe71..060df3a05 100644
--- a/docs/libcurl/opts/CURLOPT_CLOSESOCKETFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_CLOSESOCKETFUNCTION.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_OPENSOCKETFUNCTION (3)
 Protocol:
   - All
+Added-in: 7.21.7
 ---
 
 # NAME
@@ -43,7 +44,9 @@ closed.
 
 # DEFAULT
 
-By default libcurl uses the standard socket close function.
+Use the standard socket close function.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -75,9 +78,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.21.7
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_CONNECTTIMEOUT.md b/docs/libcurl/opts/CURLOPT_CONNECTTIMEOUT.md
index f8e51d88e..0106be8bd 100644
--- a/docs/libcurl/opts/CURLOPT_CONNECTTIMEOUT.md
+++ b/docs/libcurl/opts/CURLOPT_CONNECTTIMEOUT.md
@@ -5,12 +5,12 @@ Title: CURLOPT_CONNECTTIMEOUT
 Section: 3
 Source: libcurl
 See-also:
-  - CURLOPT_CONNECTTIMEOUT_MS (3)
   - CURLOPT_LOW_SPEED_LIMIT (3)
   - CURLOPT_MAX_RECV_SPEED_LARGE (3)
   - CURLOPT_TIMEOUT (3)
 Protocol:
   - All
+Added-in: 7.7
 ---
 
 # NAME
@@ -27,22 +27,22 @@ CURLcode curl_easy_setopt(CURL *handle, CURLOPT_CONNECTTIMEOUT, long timeout);
 
 # DESCRIPTION
 
-Pass a long. It should contain the maximum time in seconds that you allow the
-connection phase to the server to take. This timeout only limits the
-connection phase, it has no impact once it has connected. Set to zero to
-switch to the default built-in connection timeout - 300 seconds. See also the
-CURLOPT_TIMEOUT(3) option.
+Pass a long. It sets the maximum time in seconds that you allow the connection
+phase to take. This timeout only limits the connection phase, it has no impact
+once libcurl has connected. The connection phase includes the name resolve
+(DNS) and all protocol handshakes and negotiations until there is an
+established connection with the remote side.
+
+Set this option to zero to switch to the default built-in connection timeout -
+300 seconds. See also the CURLOPT_TIMEOUT(3) option.
 
 CURLOPT_CONNECTTIMEOUT_MS(3) is the same function but set in milliseconds.
 
 If both CURLOPT_CONNECTTIMEOUT(3) and CURLOPT_CONNECTTIMEOUT_MS(3)
 are set, the value set last is used.
 
-The "connection phase" is considered complete when the requested TCP, TLS or
-QUIC handshakes are done.
-
-The connection timeout set with CURLOPT_CONNECTTIMEOUT(3) is included in
-the general all-covering CURLOPT_TIMEOUT(3).
+The connection timeout is included in the general all-covering
+CURLOPT_TIMEOUT(3):
 
 With CURLOPT_CONNECTTIMEOUT(3) set to 3 and CURLOPT_TIMEOUT(3) set
 to 5, the operation can never last longer than 5 seconds, and the connection
@@ -60,6 +60,8 @@ signals to be used unless CURLOPT_NOSIGNAL(3) is set.
 
 300
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -77,9 +79,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_CONNECTTIMEOUT_MS.md b/docs/libcurl/opts/CURLOPT_CONNECTTIMEOUT_MS.md
index 1c22fd872..0baad3e61 100644
--- a/docs/libcurl/opts/CURLOPT_CONNECTTIMEOUT_MS.md
+++ b/docs/libcurl/opts/CURLOPT_CONNECTTIMEOUT_MS.md
@@ -5,11 +5,12 @@ Title: CURLOPT_CONNECTTIMEOUT_MS
 Section: 3
 Source: libcurl
 See-also:
-  - CURLOPT_CONNECTTIMEOUT (3)
   - CURLOPT_LOW_SPEED_LIMIT (3)
-  - CURLOPT_TIMEOUT (3)
+  - CURLOPT_MAX_RECV_SPEED_LARGE (3)
+  - CURLOPT_TIMEOUT_MS (3)
 Protocol:
   - All
+Added-in: 7.16.2
 ---
 
 # NAME
@@ -27,15 +28,41 @@ CURLcode curl_easy_setopt(CURL *handle, CURLOPT_CONNECTTIMEOUT_MS,
 
 # DESCRIPTION
 
-Pass a long. It should contain the maximum time in milliseconds that you allow
-the connection phase to the server to take.
+Pass a long. It sets the maximum time in milliseconds that you allow the
+connection phase to take. This timeout only limits the connection phase, it
+has no impact once libcurl has connected. The connection phase includes the
+name resolve (DNS) and all protocol handshakes and negotiations until there is
+an established connection with the remote side.
 
-See CURLOPT_CONNECTTIMEOUT(3) for details.
+Set this option to zero to switch to the default built-in connection timeout -
+300 seconds. See also the CURLOPT_TIMEOUT_MS(3) option.
+
+CURLOPT_CONNECTTIMEOUT(3) is the same function but set in seconds.
+
+If both CURLOPT_CONNECTTIMEOUT(3) and CURLOPT_CONNECTTIMEOUT_MS(3) are set,
+the value set last is used.
+
+The connection timeout is included in the general all-covering
+CURLOPT_TIMEOUT_MS(3):
+
+With CURLOPT_CONNECTTIMEOUT_MS(3) set to 3000 and CURLOPT_TIMEOUT_MS(3) set to
+5000, the operation can never last longer than 5000 milliseconds, and the
+connection phase cannot last longer than 3000 milliseconds.
+
+With CURLOPT_CONNECTTIMEOUT_MS(3) set to 4000 and CURLOPT_TIMEOUT_MS(3) set to
+2000, the operation can never last longer than 2000 milliseconds. Including
+the connection phase.
+
+This option may cause libcurl to use the SIGALRM signal to timeout system
+calls on builds not using asynch DNS. In unix-like systems, this might cause
+signals to be used unless CURLOPT_NOSIGNAL(3) is set.
 
 # DEFAULT
 
 300000
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -53,9 +80,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_CONNECT_ONLY.md b/docs/libcurl/opts/CURLOPT_CONNECT_ONLY.md
index 8fcb5a3b7..f5a87f00a 100644
--- a/docs/libcurl/opts/CURLOPT_CONNECT_ONLY.md
+++ b/docs/libcurl/opts/CURLOPT_CONNECT_ONLY.md
@@ -11,6 +11,7 @@ See-also:
   - curl_easy_send (3)
 Protocol:
   - All
+Added-in: 7.15.2
 ---
 
 # NAME
@@ -54,6 +55,8 @@ curl_easy_recv(3) do not function.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -72,9 +75,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
+
+WS and WSS support added in 7.86.0.
 
-Added in 7.15.2. WS and WSS support added in 7.86.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_CONNECT_TO.md b/docs/libcurl/opts/CURLOPT_CONNECT_TO.md
index 4714cb2bd..933e3b6a3 100644
--- a/docs/libcurl/opts/CURLOPT_CONNECT_TO.md
+++ b/docs/libcurl/opts/CURLOPT_CONNECT_TO.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_URL (3)
 Protocol:
   - All
+Added-in: 7.49.0
 ---
 
 # NAME
@@ -79,6 +80,8 @@ a transfer before you call curl_slist_free_all(3) on the list.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -103,9 +106,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.49.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_CONV_FROM_NETWORK_FUNCTION.md b/docs/libcurl/opts/CURLOPT_CONV_FROM_NETWORK_FUNCTION.md
index 6cde80b1f..6d233ef3a 100644
--- a/docs/libcurl/opts/CURLOPT_CONV_FROM_NETWORK_FUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_CONV_FROM_NETWORK_FUNCTION.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_CONV_TO_NETWORK_FUNCTION (3)
 Protocol:
   - All
+Added-in: 7.15.4
 ---
 
 # NAME
@@ -72,6 +73,8 @@ You need to override these definitions if they are different on your system.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -100,13 +103,15 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
 
 Not available and deprecated since 7.82.0.
 
 Available only if **CURL_DOES_CONVERSIONS** was defined when libcurl was
 built.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, and CURLE_UNKNOWN_OPTION if not.
diff --git a/docs/libcurl/opts/CURLOPT_CONV_FROM_UTF8_FUNCTION.md b/docs/libcurl/opts/CURLOPT_CONV_FROM_UTF8_FUNCTION.md
index 60cdcd0ed..9ea257f2b 100644
--- a/docs/libcurl/opts/CURLOPT_CONV_FROM_UTF8_FUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_CONV_FROM_UTF8_FUNCTION.md
@@ -9,6 +9,7 @@ Protocol:
 See-also:
   - CURLOPT_CONV_FROM_NETWORK_FUNCTION (3)
   - CURLOPT_CONV_TO_NETWORK_FUNCTION (3)
+Added-in: 7.15.4
 ---
 
 # NAME
@@ -69,6 +70,8 @@ You need to override these definitions if they are different on your system.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -93,13 +96,15 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
 
 Not available and deprecated since 7.82.0.
 
 Available only if **CURL_DOES_CONVERSIONS** was defined when libcurl was
 built.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, and CURLE_UNKNOWN_OPTION if not.
diff --git a/docs/libcurl/opts/CURLOPT_CONV_TO_NETWORK_FUNCTION.md b/docs/libcurl/opts/CURLOPT_CONV_TO_NETWORK_FUNCTION.md
index a8d22ed54..8644885ce 100644
--- a/docs/libcurl/opts/CURLOPT_CONV_TO_NETWORK_FUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_CONV_TO_NETWORK_FUNCTION.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_CONV_FROM_UTF8_FUNCTION (3)
 Protocol:
   - All
+Added-in: 7.15.4
 ---
 
 # NAME
@@ -71,6 +72,8 @@ You need to override these definitions if they are different on your system.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -96,13 +99,15 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
 
 Not available and deprecated since 7.82.0.
 
 Available only if **CURL_DOES_CONVERSIONS** was defined when libcurl was
 built.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, and CURLE_UNKNOWN_OPTION if not.
diff --git a/docs/libcurl/opts/CURLOPT_COOKIE.md b/docs/libcurl/opts/CURLOPT_COOKIE.md
index 7c6ae67c7..12d947020 100644
--- a/docs/libcurl/opts/CURLOPT_COOKIE.md
+++ b/docs/libcurl/opts/CURLOPT_COOKIE.md
@@ -12,6 +12,7 @@ See-also:
   - CURLOPT_HTTPHEADER (3)
 Protocol:
   - HTTP
+Added-in: 7.1
 ---
 
 # NAME
@@ -69,6 +70,8 @@ ability to stop super cookies. PSL support is identified by the
 
 NULL, no cookies
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -85,9 +88,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-If HTTP is enabled
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_COOKIEFILE.md b/docs/libcurl/opts/CURLOPT_COOKIEFILE.md
index 89ec0a43e..09c75d014 100644
--- a/docs/libcurl/opts/CURLOPT_COOKIEFILE.md
+++ b/docs/libcurl/opts/CURLOPT_COOKIEFILE.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_COOKIESESSION (3)
 Protocol:
   - HTTP
+Added-in: 7.1
 ---
 
 # NAME
@@ -67,6 +68,8 @@ run.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -92,9 +95,7 @@ int main(void)
 The cookie file format and general cookie concepts in curl are described
 online here: https://curl.se/docs/http-cookies.html
 
-# AVAILABILITY
-
-As long as HTTP is supported
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_COOKIEJAR.md b/docs/libcurl/opts/CURLOPT_COOKIEJAR.md
index f08e8078f..8fa3680aa 100644
--- a/docs/libcurl/opts/CURLOPT_COOKIEJAR.md
+++ b/docs/libcurl/opts/CURLOPT_COOKIEJAR.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_COOKIELIST (3)
 Protocol:
   - HTTP
+Added-in: 7.9
 ---
 
 # NAME
@@ -53,6 +54,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -74,9 +77,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with HTTP
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_COOKIELIST.md b/docs/libcurl/opts/CURLOPT_COOKIELIST.md
index 7be0c1deb..d7a6c0b12 100644
--- a/docs/libcurl/opts/CURLOPT_COOKIELIST.md
+++ b/docs/libcurl/opts/CURLOPT_COOKIELIST.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_COOKIEJAR (3)
 Protocol:
   - HTTP
+Added-in: 7.14.1
 ---
 
 # NAME
@@ -69,6 +70,8 @@ loads all cookies from the files specified by CURLOPT_COOKIEFILE(3)
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -118,7 +121,7 @@ int main(void)
 The cookie file format and general cookie concepts in curl are described
 online here: https://curl.se/docs/http-cookies.html
 
-# AVAILABILITY
+# HISTORY
 
 **ALL** was added in 7.14.1
 
@@ -128,6 +131,8 @@ online here: https://curl.se/docs/http-cookies.html
 
 **RELOAD** was added in 7.39.0
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, CURLE_UNKNOWN_OPTION if not, or
diff --git a/docs/libcurl/opts/CURLOPT_COOKIESESSION.md b/docs/libcurl/opts/CURLOPT_COOKIESESSION.md
index 705b1b7d8..19b9a301d 100644
--- a/docs/libcurl/opts/CURLOPT_COOKIESESSION.md
+++ b/docs/libcurl/opts/CURLOPT_COOKIESESSION.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_COOKIEJAR (3)
 Protocol:
   - HTTP
+Added-in: 7.9.7
 ---
 
 # NAME
@@ -41,6 +42,8 @@ the same session.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with HTTP
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_COPYPOSTFIELDS.md b/docs/libcurl/opts/CURLOPT_COPYPOSTFIELDS.md
index a48374014..6650008a6 100644
--- a/docs/libcurl/opts/CURLOPT_COPYPOSTFIELDS.md
+++ b/docs/libcurl/opts/CURLOPT_COPYPOSTFIELDS.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_UPLOAD (3)
 Protocol:
   - HTTP
+Added-in: 7.17.1
 ---
 
 # NAME
@@ -45,6 +46,8 @@ CURLOPT_COPYPOSTFIELDS(3) option is issued.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -66,9 +69,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.17.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_CRLF.md b/docs/libcurl/opts/CURLOPT_CRLF.md
index e49be9893..8c0c9a592 100644
--- a/docs/libcurl/opts/CURLOPT_CRLF.md
+++ b/docs/libcurl/opts/CURLOPT_CRLF.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_CONV_TO_NETWORK_FUNCTION (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -35,6 +36,8 @@ This is a legacy option of questionable use.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -51,9 +54,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-SMTP since 7.40.0, other protocols since they were introduced
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_CRLFILE.md b/docs/libcurl/opts/CURLOPT_CRLFILE.md
index b544f3777..1a6b21109 100644
--- a/docs/libcurl/opts/CURLOPT_CRLFILE.md
+++ b/docs/libcurl/opts/CURLOPT_CRLFILE.md
@@ -14,6 +14,7 @@ TLS-backend:
   - GnuTLS
   - mbedTLS
   - OpenSSL
+Added-in: 7.19.0
 ---
 
 # NAME
@@ -58,6 +59,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -74,9 +77,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.19.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_CURLU.md b/docs/libcurl/opts/CURLOPT_CURLU.md
index 2bb1e73a9..f9a3020b3 100644
--- a/docs/libcurl/opts/CURLOPT_CURLU.md
+++ b/docs/libcurl/opts/CURLOPT_CURLU.md
@@ -14,6 +14,7 @@ See-also:
   - curl_url_strerror (3)
 Protocol:
   - All
+Added-in: 7.63.0
 ---
 
 # NAME
@@ -44,7 +45,9 @@ updated contents is used.
 
 # DEFAULT
 
-The default value of this parameter is NULL.
+NULL
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -68,9 +71,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.63.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_CUSTOMREQUEST.md b/docs/libcurl/opts/CURLOPT_CUSTOMREQUEST.md
index 62c8cf87c..39da7ca00 100644
--- a/docs/libcurl/opts/CURLOPT_CUSTOMREQUEST.md
+++ b/docs/libcurl/opts/CURLOPT_CUSTOMREQUEST.md
@@ -15,6 +15,7 @@ Protocol:
   - IMAP
   - POP3
   - SMTP
+Added-in: 7.1
 ---
 
 # NAME
@@ -95,13 +96,12 @@ with CURLOPT_MAIL_RCPT(3), to specify an EXPN request. If the
 CURLOPT_NOBODY(3) option is specified then the request can be used to
 issue **NOOP** and **RSET** commands.
 
-The application does not have to keep the string around after setting this
-option.
-
 # DEFAULT
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -122,9 +122,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-IMAP is supported since 7.30.0, POP3 since 7.26.0 and SMTP since 7.34.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_DEBUGDATA.md b/docs/libcurl/opts/CURLOPT_DEBUGDATA.md
index 0864388c2..3df122d6a 100644
--- a/docs/libcurl/opts/CURLOPT_DEBUGDATA.md
+++ b/docs/libcurl/opts/CURLOPT_DEBUGDATA.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_STDERR (3)
 Protocol:
   - All
+Added-in: 7.9.6
 ---
 
 # NAME
@@ -33,6 +34,8 @@ not used by libcurl, it is only passed to the callback.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -75,9 +78,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_DEBUGFUNCTION.md b/docs/libcurl/opts/CURLOPT_DEBUGFUNCTION.md
index a0927e202..4887f6272 100644
--- a/docs/libcurl/opts/CURLOPT_DEBUGFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_DEBUGFUNCTION.md
@@ -12,6 +12,7 @@ See-also:
   - curl_global_trace (3)
 Protocol:
   - All
+Added-in: 7.9.6
 ---
 
 # NAME
@@ -91,16 +92,20 @@ The data is SSL/TLS (binary) data sent to the peer.
 
 The data is SSL/TLS (binary) data received from the peer.
 
-WARNING: This callback may be called with the curl *handle* set to an
-internal handle. (Added in 8.4.0)
+##
 
-If you need to distinguish your curl *handle* from internal handles then
-set CURLOPT_PRIVATE(3) on your handle.
+WARNING: This callback may be called with the curl *handle* set to an internal
+handle. (Added in 8.4.0)
+
+If you need to distinguish your curl *handle* from internal handles then set
+CURLOPT_PRIVATE(3) on your handle.
 
 # DEFAULT
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -205,9 +210,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_DEFAULT_PROTOCOL.md b/docs/libcurl/opts/CURLOPT_DEFAULT_PROTOCOL.md
index 7da62e18a..3787ff951 100644
--- a/docs/libcurl/opts/CURLOPT_DEFAULT_PROTOCOL.md
+++ b/docs/libcurl/opts/CURLOPT_DEFAULT_PROTOCOL.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_URL (3)
 Protocol:
   - All
+Added-in: 7.45.0
 ---
 
 # NAME
@@ -55,6 +56,8 @@ option.
 
 NULL (make a guess based on the host)
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -74,9 +77,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.45.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_DIRLISTONLY.md b/docs/libcurl/opts/CURLOPT_DIRLISTONLY.md
index 348faf386..1c5ee14c7 100644
--- a/docs/libcurl/opts/CURLOPT_DIRLISTONLY.md
+++ b/docs/libcurl/opts/CURLOPT_DIRLISTONLY.md
@@ -11,6 +11,7 @@ Protocol:
   - FTP
   - SFTP
   - POP3
+Added-in: 7.17.0
 ---
 
 # NAME
@@ -53,6 +54,8 @@ effectively breaks that feature.
 
 0, disabled
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -73,11 +76,13 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 This option was known as CURLOPT_FTPLISTONLY up to 7.16.4. POP3 is supported
 since 7.21.5.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, and CURLE_UNKNOWN_OPTION if not.
diff --git a/docs/libcurl/opts/CURLOPT_DISALLOW_USERNAME_IN_URL.md b/docs/libcurl/opts/CURLOPT_DISALLOW_USERNAME_IN_URL.md
index 788ef3018..66a5948bb 100644
--- a/docs/libcurl/opts/CURLOPT_DISALLOW_USERNAME_IN_URL.md
+++ b/docs/libcurl/opts/CURLOPT_DISALLOW_USERNAME_IN_URL.md
@@ -5,12 +5,13 @@ Title: CURLOPT_DISALLOW_USERNAME_IN_URL
 Section: 3
 Source: libcurl
 See-also:
-  - CURLOPT_PROTOCOLS (3)
+  - CURLOPT_PROTOCOLS_STR (3)
   - CURLOPT_URL (3)
   - curl_url_set (3)
   - libcurl-security (3)
 Protocol:
   - All
+Added-in: 7.61.0
 ---
 
 # NAME
@@ -36,7 +37,9 @@ curl_url_set(3) function.
 
 # DEFAULT
 
-0 (disabled) - usernames are allowed by default.
+0 (disabled)
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -54,9 +57,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.61.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_DNS_CACHE_TIMEOUT.md b/docs/libcurl/opts/CURLOPT_DNS_CACHE_TIMEOUT.md
index ca0c896e4..6ae904d65 100644
--- a/docs/libcurl/opts/CURLOPT_DNS_CACHE_TIMEOUT.md
+++ b/docs/libcurl/opts/CURLOPT_DNS_CACHE_TIMEOUT.md
@@ -12,6 +12,7 @@ See-also:
   - CURLOPT_RESOLVE (3)
 Protocol:
   - All
+Added-in: 7.9.3
 ---
 
 # NAME
@@ -54,6 +55,8 @@ Since version 8.1.0, libcurl prunes entries from the DNS cache if it exceeds
 
 60
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -78,9 +81,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_DNS_INTERFACE.md b/docs/libcurl/opts/CURLOPT_DNS_INTERFACE.md
index 20dc86edc..0d7f435ed 100644
--- a/docs/libcurl/opts/CURLOPT_DNS_INTERFACE.md
+++ b/docs/libcurl/opts/CURLOPT_DNS_INTERFACE.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_INTERFACE (3)
 Protocol:
   - All
+Added-in: 7.33.0
 ---
 
 # NAME
@@ -39,6 +40,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -55,11 +58,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# NOTES
+
+This option requires that libcurl was built with a resolver backend that
+supports this operation. The c-ares backend is the only such one.
 
-Added in 7.33.0. This option also requires that libcurl was built with a
-resolver backend that supports this operation. The c-ares backend is the only
-such one.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_DNS_LOCAL_IP4.md b/docs/libcurl/opts/CURLOPT_DNS_LOCAL_IP4.md
index 67a6bd204..cf3aae80e 100644
--- a/docs/libcurl/opts/CURLOPT_DNS_LOCAL_IP4.md
+++ b/docs/libcurl/opts/CURLOPT_DNS_LOCAL_IP4.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_DNS_SERVERS (3)
 Protocol:
   - All
+Added-in: 7.33.0
 ---
 
 # NAME
@@ -38,6 +39,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -54,12 +57,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# NOTES
 
 This option requires that libcurl was built with a resolver backend that
 supports this operation. The c-ares backend is the only such one.
 
-Added in 7.33.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_DNS_LOCAL_IP6.md b/docs/libcurl/opts/CURLOPT_DNS_LOCAL_IP6.md
index 332debd6b..4750367de 100644
--- a/docs/libcurl/opts/CURLOPT_DNS_LOCAL_IP6.md
+++ b/docs/libcurl/opts/CURLOPT_DNS_LOCAL_IP6.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_DNS_SERVERS (3)
 Protocol:
   - All
+Added-in: 7.33.0
 ---
 
 # NAME
@@ -38,6 +39,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -54,12 +57,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# NOTES
 
 This option requires that libcurl was built with a resolver backend that
 supports this operation. The c-ares backend is the only such one.
 
-Added in 7.33.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_DNS_SERVERS.md b/docs/libcurl/opts/CURLOPT_DNS_SERVERS.md
index 42874bd53..f345e3265 100644
--- a/docs/libcurl/opts/CURLOPT_DNS_SERVERS.md
+++ b/docs/libcurl/opts/CURLOPT_DNS_SERVERS.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_DNS_LOCAL_IP6 (3)
 Protocol:
   - All
+Added-in: 7.24.0
 ---
 
 # NAME
@@ -40,7 +41,9 @@ option.
 
 # DEFAULT
 
-NULL - use system default
+NULL
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -59,12 +62,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# NOTES
 
 This option requires that libcurl was built with a resolver backend that
 supports this operation. The c-ares backend is the only such one.
 
-Added in 7.24.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_DNS_SHUFFLE_ADDRESSES.md b/docs/libcurl/opts/CURLOPT_DNS_SHUFFLE_ADDRESSES.md
index 33dcb0f06..2074fff87 100644
--- a/docs/libcurl/opts/CURLOPT_DNS_SHUFFLE_ADDRESSES.md
+++ b/docs/libcurl/opts/CURLOPT_DNS_SHUFFLE_ADDRESSES.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_IPRESOLVE (3)
 Protocol:
   - All
+Added-in: 7.60.0
 ---
 
 # NAME
@@ -46,6 +47,8 @@ performance impacts and may cause IPv4 to be used before IPv6 or vice versa.
 
 0 (disabled)
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.60.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_DNS_USE_GLOBAL_CACHE.md b/docs/libcurl/opts/CURLOPT_DNS_USE_GLOBAL_CACHE.md
index 616ddb951..f236c3885 100644
--- a/docs/libcurl/opts/CURLOPT_DNS_USE_GLOBAL_CACHE.md
+++ b/docs/libcurl/opts/CURLOPT_DNS_USE_GLOBAL_CACHE.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_SHARE (3)
 Protocol:
   - All
+Added-in: 7.9.3
 ---
 
 # NAME
@@ -39,6 +40,8 @@ cache between transfers.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,9 +60,11 @@ int main(void)
 
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
+
+Deprecated since 7.11.1. Functionality removed in 7.62.0.
 
-Deprecated since 7.11.1. Function removed in 7.62.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_DOH_SSL_VERIFYHOST.md b/docs/libcurl/opts/CURLOPT_DOH_SSL_VERIFYHOST.md
index 4211f03cb..bcde0e106 100644
--- a/docs/libcurl/opts/CURLOPT_DOH_SSL_VERIFYHOST.md
+++ b/docs/libcurl/opts/CURLOPT_DOH_SSL_VERIFYHOST.md
@@ -14,6 +14,7 @@ Protocol:
   - TLS
 TLS-backend:
   - All
+Added-in: 7.76.0
 ---
 
 # NAME
@@ -59,6 +60,8 @@ of the DoH server certificate.
 
 2
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -79,11 +82,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.76.0
-
-If built TLS enabled.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_DOH_SSL_VERIFYPEER.md b/docs/libcurl/opts/CURLOPT_DOH_SSL_VERIFYPEER.md
index b35fa5272..e8674e06f 100644
--- a/docs/libcurl/opts/CURLOPT_DOH_SSL_VERIFYPEER.md
+++ b/docs/libcurl/opts/CURLOPT_DOH_SSL_VERIFYPEER.md
@@ -16,6 +16,7 @@ Protocol:
   - TLS
 TLS-backend:
   - All
+Added-in: 7.76.0
 ---
 
 # NAME
@@ -71,6 +72,8 @@ the correct end-point.
 
 1
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -91,11 +94,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.76.0
-
-If built TLS enabled.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_DOH_SSL_VERIFYSTATUS.md b/docs/libcurl/opts/CURLOPT_DOH_SSL_VERIFYSTATUS.md
index 8135cb4c7..fb861ae74 100644
--- a/docs/libcurl/opts/CURLOPT_DOH_SSL_VERIFYSTATUS.md
+++ b/docs/libcurl/opts/CURLOPT_DOH_SSL_VERIFYSTATUS.md
@@ -13,6 +13,7 @@ Protocol:
 TLS-backend:
   - OpenSSL
   - GnuTLS
+Added-in: 7.76.0
 ---
 
 # NAME
@@ -46,6 +47,8 @@ the verification fails.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -66,9 +69,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.76.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_DOH_URL.md b/docs/libcurl/opts/CURLOPT_DOH_URL.md
index d382ca67d..bd4372fb0 100644
--- a/docs/libcurl/opts/CURLOPT_DOH_URL.md
+++ b/docs/libcurl/opts/CURLOPT_DOH_URL.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_VERBOSE (3)
 Protocol:
   - All
+Added-in: 7.62.0
 ---
 
 # NAME
@@ -63,8 +64,9 @@ CURLOPT_FTPPORT(3), a proxy type set to **CURLPROXY_SOCKS4** or
 
 # DEFAULT
 
-NULL - there is no default DoH URL. If this option is not set, libcurl uses
-the default name resolver.
+NULL
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -80,9 +82,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.62.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_ECH.md b/docs/libcurl/opts/CURLOPT_ECH.md
index 4f93885df..a637b98be 100644
--- a/docs/libcurl/opts/CURLOPT_ECH.md
+++ b/docs/libcurl/opts/CURLOPT_ECH.md
@@ -1,5 +1,5 @@
 ---
-c: Copyright (C) Daniel Stenberg, <daniel.se>, et al.
+c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
 Title: CURLOPT_ECH
 Section: 3
@@ -11,6 +11,7 @@ Protocol:
 TLS-backend:
   - OpenSSL
   - wolfSSL
+Added-in: 8.8.0
 ---
 
 # NAME
@@ -55,7 +56,7 @@ ECH is not possible.
 
 ## hard
 
-Instructs client to attempt ECH and fail if if attempting ECH is not possible.
+Instructs client to attempt ECH and fail if attempting ECH is not possible.
 
 ## ecl:\<base64-value\>
 
@@ -73,6 +74,8 @@ ECHConfigList that is used for ECH.
 
 NULL, meaning ECH is disabled.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -84,9 +87,7 @@ if(curl) {
   curl_easy_perform(curl);
 }
 ~~~
-# AVAILABILITY
-
-Added in 8.8.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_EGDSOCKET.md b/docs/libcurl/opts/CURLOPT_EGDSOCKET.md
index f24da8619..05fb76ed0 100644
--- a/docs/libcurl/opts/CURLOPT_EGDSOCKET.md
+++ b/docs/libcurl/opts/CURLOPT_EGDSOCKET.md
@@ -10,6 +10,7 @@ Protocol:
   - TLS
 TLS-backend:
   - OpenSSL
+Added-in: 7.7
 ---
 
 # NAME
@@ -32,10 +33,12 @@ Deprecated option. It serves no purpose anymore.
 
 NULL
 
-# AVAILABILITY
+# DEPRECATED
 
 This option was deprecated in 7.84.0.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK.
diff --git a/docs/libcurl/opts/CURLOPT_ERRORBUFFER.md b/docs/libcurl/opts/CURLOPT_ERRORBUFFER.md
index 7a90f1d6c..4b8366840 100644
--- a/docs/libcurl/opts/CURLOPT_ERRORBUFFER.md
+++ b/docs/libcurl/opts/CURLOPT_ERRORBUFFER.md
@@ -13,6 +13,7 @@ See-also:
   - curl_url_strerror (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -51,6 +52,8 @@ debug and trace why errors happen.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -90,9 +93,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_EXPECT_100_TIMEOUT_MS.md b/docs/libcurl/opts/CURLOPT_EXPECT_100_TIMEOUT_MS.md
index 7f6f274b4..45997dcc1 100644
--- a/docs/libcurl/opts/CURLOPT_EXPECT_100_TIMEOUT_MS.md
+++ b/docs/libcurl/opts/CURLOPT_EXPECT_100_TIMEOUT_MS.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_POST (3)
 Protocol:
   - HTTP
+Added-in: 7.36.0
 ---
 
 # NAME
@@ -36,6 +37,8 @@ sent anyway.
 
 1000 milliseconds
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -53,9 +56,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.36.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FAILONERROR.md b/docs/libcurl/opts/CURLOPT_FAILONERROR.md
index aabee4e4d..d865b637c 100644
--- a/docs/libcurl/opts/CURLOPT_FAILONERROR.md
+++ b/docs/libcurl/opts/CURLOPT_FAILONERROR.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_KEEP_SENDING_ON_ERROR (3)
 Protocol:
   - HTTP
+Added-in: 7.1
 ---
 
 # NAME
@@ -45,6 +46,8 @@ get closed and *CURLE_HTTP_RETURNED_ERROR* is returned.
 
 0, do not fail on error
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -63,9 +66,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with HTTP.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FILETIME.md b/docs/libcurl/opts/CURLOPT_FILETIME.md
index 1f4782e3e..bca79ab90 100644
--- a/docs/libcurl/opts/CURLOPT_FILETIME.md
+++ b/docs/libcurl/opts/CURLOPT_FILETIME.md
@@ -13,6 +13,7 @@ Protocol:
   - SFTP
   - FILE
   - SMB
+Added-in: 7.5
 ---
 
 # NAME
@@ -39,6 +40,8 @@ transfer to extract the received time (if any).
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -65,9 +68,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always, for SFTP since 7.49.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FNMATCH_DATA.md b/docs/libcurl/opts/CURLOPT_FNMATCH_DATA.md
index 33dce7b0c..866333f14 100644
--- a/docs/libcurl/opts/CURLOPT_FNMATCH_DATA.md
+++ b/docs/libcurl/opts/CURLOPT_FNMATCH_DATA.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_WILDCARDMATCH (3)
 Protocol:
   - FTP
+Added-in: 7.21.0
 ---
 
 # NAME
@@ -33,6 +34,8 @@ the CURLOPT_FNMATCH_FUNCTION(3).
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -69,9 +72,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.21.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FNMATCH_FUNCTION.md b/docs/libcurl/opts/CURLOPT_FNMATCH_FUNCTION.md
index 16526931e..f9ff1d3b2 100644
--- a/docs/libcurl/opts/CURLOPT_FNMATCH_FUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_FNMATCH_FUNCTION.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_WILDCARDMATCH (3)
 Protocol:
   - FTP
+Added-in: 7.21.0
 ---
 
 # NAME
@@ -44,6 +45,8 @@ error occurred.
 
 NULL == an internal function for wildcard matching.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -77,9 +80,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.21.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FOLLOWLOCATION.md b/docs/libcurl/opts/CURLOPT_FOLLOWLOCATION.md
index 9dee48bef..bfbb3b545 100644
--- a/docs/libcurl/opts/CURLOPT_FOLLOWLOCATION.md
+++ b/docs/libcurl/opts/CURLOPT_FOLLOWLOCATION.md
@@ -8,10 +8,11 @@ See-also:
   - CURLINFO_REDIRECT_COUNT (3)
   - CURLINFO_REDIRECT_URL (3)
   - CURLOPT_POSTREDIR (3)
-  - CURLOPT_PROTOCOLS (3)
-  - CURLOPT_REDIR_PROTOCOLS (3)
+  - CURLOPT_PROTOCOLS_STR (3)
+  - CURLOPT_REDIR_PROTOCOLS_STR (3)
 Protocol:
   - HTTP
+Added-in: 7.1
 ---
 
 # NAME
@@ -38,7 +39,7 @@ maximum limit is reached. CURLOPT_MAXREDIRS(3) is used to limit the
 number of redirects libcurl follows.
 
 libcurl restricts what protocols it automatically follow redirects to. The
-accepted target protocols are set with CURLOPT_REDIR_PROTOCOLS(3). By
+accepted target protocols are set with CURLOPT_REDIR_PROTOCOLS_STR(3). By
 default libcurl allows HTTP, HTTPS, FTP and FTPS on redirects.
 
 When following a redirect, the specific 30x response code also dictates which
@@ -65,6 +66,8 @@ would otherwise select internally.
 
 0, disabled
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -82,9 +85,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with HTTP
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FORBID_REUSE.md b/docs/libcurl/opts/CURLOPT_FORBID_REUSE.md
index bbd1c48f7..2f452ff59 100644
--- a/docs/libcurl/opts/CURLOPT_FORBID_REUSE.md
+++ b/docs/libcurl/opts/CURLOPT_FORBID_REUSE.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_MAXLIFETIME_CONN (3)
 Protocol:
   - All
+Added-in: 7.7
 ---
 
 # NAME
@@ -39,6 +40,8 @@ Set to 0 to have libcurl keep the connection open for possible later reuse
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -58,9 +61,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FRESH_CONNECT.md b/docs/libcurl/opts/CURLOPT_FRESH_CONNECT.md
index f7ffbe89a..f64c6adc7 100644
--- a/docs/libcurl/opts/CURLOPT_FRESH_CONNECT.md
+++ b/docs/libcurl/opts/CURLOPT_FRESH_CONNECT.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_FORBID_REUSE (3)
   - CURLOPT_MAXAGE_CONN (3)
   - CURLOPT_MAXLIFETIME_CONN (3)
+Added-in: 7.7
 ---
 
 # NAME
@@ -41,6 +42,8 @@ Set *fresh* to 0 to have libcurl attempt reusing an existing connection
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,9 +60,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FTPPORT.md b/docs/libcurl/opts/CURLOPT_FTPPORT.md
index 869a862f9..d2f3eae7d 100644
--- a/docs/libcurl/opts/CURLOPT_FTPPORT.md
+++ b/docs/libcurl/opts/CURLOPT_FTPPORT.md
@@ -9,6 +9,7 @@ Protocol:
 See-also:
   - CURLOPT_FTP_USE_EPRT (3)
   - CURLOPT_FTP_USE_EPSV (3)
+Added-in: 7.1
 ---
 
 # NAME
@@ -70,6 +71,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -87,9 +90,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Port range support was added in 7.19.5
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FTPSSLAUTH.md b/docs/libcurl/opts/CURLOPT_FTPSSLAUTH.md
index d40c75fe4..5e1300dd6 100644
--- a/docs/libcurl/opts/CURLOPT_FTPSSLAUTH.md
+++ b/docs/libcurl/opts/CURLOPT_FTPSSLAUTH.md
@@ -9,6 +9,7 @@ Protocol:
 See-also:
   - CURLOPT_FTP_SSL_CCC (3)
   - CURLOPT_USE_SSL (3)
+Added-in: 7.12.2
 ---
 
 # NAME
@@ -47,6 +48,8 @@ Try "AUTH TLS" first, and only if that fails try "AUTH SSL".
 
 CURLFTPAUTH_DEFAULT
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -65,9 +68,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.12.2
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FTP_ACCOUNT.md b/docs/libcurl/opts/CURLOPT_FTP_ACCOUNT.md
index de6b2a50e..da6835cc7 100644
--- a/docs/libcurl/opts/CURLOPT_FTP_ACCOUNT.md
+++ b/docs/libcurl/opts/CURLOPT_FTP_ACCOUNT.md
@@ -9,6 +9,7 @@ Protocol:
 See-also:
   - CURLOPT_PASSWORD (3)
   - CURLOPT_USERNAME (3)
+Added-in: 7.13.0
 ---
 
 # NAME
@@ -36,6 +37,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -55,9 +58,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.13.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FTP_ALTERNATIVE_TO_USER.md b/docs/libcurl/opts/CURLOPT_FTP_ALTERNATIVE_TO_USER.md
index 7d334f545..54fd80b6e 100644
--- a/docs/libcurl/opts/CURLOPT_FTP_ALTERNATIVE_TO_USER.md
+++ b/docs/libcurl/opts/CURLOPT_FTP_ALTERNATIVE_TO_USER.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_FTP_SKIP_PASV_IP (3)
   - CURLOPT_SERVER_RESPONSE_TIMEOUT (3)
   - CURLOPT_USERNAME (3)
+Added-in: 7.15.5
 ---
 
 # NAME
@@ -41,6 +42,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -58,9 +61,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.15.5
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FTP_CREATE_MISSING_DIRS.md b/docs/libcurl/opts/CURLOPT_FTP_CREATE_MISSING_DIRS.md
index 5a6dbf696..7601278e4 100644
--- a/docs/libcurl/opts/CURLOPT_FTP_CREATE_MISSING_DIRS.md
+++ b/docs/libcurl/opts/CURLOPT_FTP_CREATE_MISSING_DIRS.md
@@ -9,6 +9,7 @@ Protocol:
 See-also:
   - CURLOPT_FTP_FILEMETHOD (3)
   - CURLOPT_FTP_USE_EPSV (3)
+Added-in: 7.10.7
 ---
 
 # NAME
@@ -55,6 +56,8 @@ but then another connection does **MKD** before this connection and thus
 
 CURLFTP_CREATE_DIR_NONE (0)
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -75,10 +78,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10.7. SFTP support added in 7.16.3. The retry option was added in
-7.19.4.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FTP_FILEMETHOD.md b/docs/libcurl/opts/CURLOPT_FTP_FILEMETHOD.md
index 351dfe10e..342f72f7c 100644
--- a/docs/libcurl/opts/CURLOPT_FTP_FILEMETHOD.md
+++ b/docs/libcurl/opts/CURLOPT_FTP_FILEMETHOD.md
@@ -9,6 +9,7 @@ Protocol:
 See-also:
   - CURLOPT_DIRLISTONLY (3)
   - CURLOPT_FTP_SKIP_PASV_IP (3)
+Added-in: 7.15.1
 ---
 
 # NAME
@@ -56,6 +57,8 @@ compliant than 'nocwd' but without the full penalty of 'multicwd'.
 
 CURLFTPMETHOD_MULTICWD
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -75,9 +78,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.15.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FTP_SKIP_PASV_IP.md b/docs/libcurl/opts/CURLOPT_FTP_SKIP_PASV_IP.md
index cdec3371b..65f88192a 100644
--- a/docs/libcurl/opts/CURLOPT_FTP_SKIP_PASV_IP.md
+++ b/docs/libcurl/opts/CURLOPT_FTP_SKIP_PASV_IP.md
@@ -9,6 +9,7 @@ Protocol:
 See-also:
   - CURLOPT_FTPPORT (3)
   - CURLOPT_FTP_USE_EPRT (3)
+Added-in: 7.15.0
 ---
 
 # NAME
@@ -42,6 +43,8 @@ This option has no effect if PORT, EPRT or EPSV is used instead of PASV.
 
 1 since 7.74.0, was 0 before then.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -61,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.14.2
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FTP_SSL_CCC.md b/docs/libcurl/opts/CURLOPT_FTP_SSL_CCC.md
index 6155c4aed..ccccc8c21 100644
--- a/docs/libcurl/opts/CURLOPT_FTP_SSL_CCC.md
+++ b/docs/libcurl/opts/CURLOPT_FTP_SSL_CCC.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_FTPSSLAUTH (3)
   - CURLOPT_PROTOCOLS_STR (3)
   - CURLOPT_USE_SSL (3)
+Added-in: 7.16.1
 ---
 
 # NAME
@@ -49,6 +50,8 @@ Initiate the shutdown and wait for a reply.
 
 CURLFTPSSL_CCC_NONE
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -67,9 +70,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.16.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FTP_USE_EPRT.md b/docs/libcurl/opts/CURLOPT_FTP_USE_EPRT.md
index 54df92573..c651fe949 100644
--- a/docs/libcurl/opts/CURLOPT_FTP_USE_EPRT.md
+++ b/docs/libcurl/opts/CURLOPT_FTP_USE_EPRT.md
@@ -9,6 +9,7 @@ Protocol:
 See-also:
   - CURLOPT_FTPPORT (3)
   - CURLOPT_FTP_USE_EPSV (3)
+Added-in: 7.10.5
 ---
 
 # NAME
@@ -41,6 +42,8 @@ then.
 
 # DEFAULT
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10.5
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FTP_USE_EPSV.md b/docs/libcurl/opts/CURLOPT_FTP_USE_EPSV.md
index 41d8f9ed0..8b8051fd8 100644
--- a/docs/libcurl/opts/CURLOPT_FTP_USE_EPSV.md
+++ b/docs/libcurl/opts/CURLOPT_FTP_USE_EPSV.md
@@ -9,6 +9,7 @@ Protocol:
 See-also:
   - CURLOPT_FTPPORT (3)
   - CURLOPT_FTP_USE_EPRT (3)
+Added-in: 7.9.2
 ---
 
 # NAME
@@ -41,6 +42,8 @@ If the server is an IPv6 host, this option has no effect.
 
 1
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -62,9 +65,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with FTP
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_FTP_USE_PRET.md b/docs/libcurl/opts/CURLOPT_FTP_USE_PRET.md
index 1d9507c78..1e078581f 100644
--- a/docs/libcurl/opts/CURLOPT_FTP_USE_PRET.md
+++ b/docs/libcurl/opts/CURLOPT_FTP_USE_PRET.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_FTP_USE_EPSV (3)
 Protocol:
   - FTP
+Added-in: 7.20.0
 ---
 
 # NAME
@@ -34,6 +35,8 @@ no effect when using the active FTP transfers mode.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -55,9 +58,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.20.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_GSSAPI_DELEGATION.md b/docs/libcurl/opts/CURLOPT_GSSAPI_DELEGATION.md
index 01bf42d17..e60b503b7 100644
--- a/docs/libcurl/opts/CURLOPT_GSSAPI_DELEGATION.md
+++ b/docs/libcurl/opts/CURLOPT_GSSAPI_DELEGATION.md
@@ -9,6 +9,7 @@ Protocol:
 See-also:
   - CURLOPT_HTTPAUTH (3)
   - CURLOPT_PROXYAUTH (3)
+Added-in: 7.22.0
 ---
 
 # NAME
@@ -37,6 +38,8 @@ available at compile-time.
 
 CURLGSSAPI_DELEGATION_NONE
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -54,9 +57,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.22.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS.md b/docs/libcurl/opts/CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS.md
index 5f51f9422..f13abddbd 100644
--- a/docs/libcurl/opts/CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS.md
+++ b/docs/libcurl/opts/CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_CONNECTTIMEOUT_MS (3)
   - CURLOPT_LOW_SPEED_LIMIT (3)
   - CURLOPT_TIMEOUT (3)
+Added-in: 7.59.0
 ---
 
 # NAME
@@ -42,6 +43,8 @@ currently defaults to 200 ms. Firefox and Chrome currently default to 300 ms.
 
 CURL_HET_DEFAULT (currently defined as 200L)
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.59.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HAPROXYPROTOCOL.md b/docs/libcurl/opts/CURLOPT_HAPROXYPROTOCOL.md
index da4f35ce5..99e7fce58 100644
--- a/docs/libcurl/opts/CURLOPT_HAPROXYPROTOCOL.md
+++ b/docs/libcurl/opts/CURLOPT_HAPROXYPROTOCOL.md
@@ -8,6 +8,7 @@ See-also:
   - CURLOPT_PROXY (3)
 Protocol:
   - All
+Added-in: 7.60.0
 ---
 
 # NAME
@@ -38,6 +39,8 @@ Most applications do not need this option.
 
 0, do not send any HAProxy PROXY protocol header
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -53,9 +56,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with HTTP. Added in 7.60.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HAPROXY_CLIENT_IP.md b/docs/libcurl/opts/CURLOPT_HAPROXY_CLIENT_IP.md
index fdb16fe64..64e0085fd 100644
--- a/docs/libcurl/opts/CURLOPT_HAPROXY_CLIENT_IP.md
+++ b/docs/libcurl/opts/CURLOPT_HAPROXY_CLIENT_IP.md
@@ -9,6 +9,7 @@ Protocol:
 See-also:
   - CURLOPT_HAPROXYPROTOCOL (3)
   - CURLOPT_PROXY (3)
+Added-in: 8.2.0
 ---
 
 # NAME
@@ -37,6 +38,8 @@ cannot use a specified address.
 
 NULL, no HAProxy header is sent
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -52,9 +55,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with HTTP. Added in 8.2.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HEADER.md b/docs/libcurl/opts/CURLOPT_HEADER.md
index 09262f697..348f4d99a 100644
--- a/docs/libcurl/opts/CURLOPT_HEADER.md
+++ b/docs/libcurl/opts/CURLOPT_HEADER.md
@@ -13,6 +13,7 @@ Protocol:
 See-also:
   - CURLOPT_HEADERFUNCTION (3)
   - CURLOPT_HTTPHEADER (3)
+Added-in: 7.1
 ---
 
 # NAME
@@ -53,6 +54,8 @@ custom HTTP headers!
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -69,9 +72,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Provided in all libcurl versions.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HEADERDATA.md b/docs/libcurl/opts/CURLOPT_HEADERDATA.md
index 84d232eb8..865cbb74d 100644
--- a/docs/libcurl/opts/CURLOPT_HEADERDATA.md
+++ b/docs/libcurl/opts/CURLOPT_HEADERDATA.md
@@ -10,6 +10,7 @@ See-also:
   - curl_easy_header (3)
 Protocol:
   - All
+Added-in: 7.10
 ---
 
 # NAME
@@ -43,6 +44,8 @@ this option or you might experience crashes.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -78,9 +81,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HEADERFUNCTION.md b/docs/libcurl/opts/CURLOPT_HEADERFUNCTION.md
index 6668c82c2..688f1f3ba 100644
--- a/docs/libcurl/opts/CURLOPT_HEADERFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_HEADERFUNCTION.md
@@ -14,6 +14,7 @@ Protocol:
   - POP3
   - IMAP
   - SMTP
+Added-in: 7.7.2
 ---
 
 # NAME
@@ -100,6 +101,8 @@ although strictly they are just continuations of the previous lines.
 
 Nothing.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -124,9 +127,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HEADEROPT.md b/docs/libcurl/opts/CURLOPT_HEADEROPT.md
index 833fda063..bf2a6f6bc 100644
--- a/docs/libcurl/opts/CURLOPT_HEADEROPT.md
+++ b/docs/libcurl/opts/CURLOPT_HEADEROPT.md
@@ -9,6 +9,7 @@ Protocol:
 See-also:
   - CURLOPT_HTTPHEADER (3)
   - CURLOPT_PROXYHEADER (3)
+Added-in: 7.37.0
 ---
 
 # NAME
@@ -44,6 +45,8 @@ proxy and then CURLOPT_HTTPHEADER(3) headers only to the server.
 
 CURLHEADER_SEPARATE (changed in 7.42.1, used CURLHEADER_UNIFIED before then)
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -70,9 +73,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.37.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HSTS.md b/docs/libcurl/opts/CURLOPT_HSTS.md
index b71476e5b..b838c9e95 100644
--- a/docs/libcurl/opts/CURLOPT_HSTS.md
+++ b/docs/libcurl/opts/CURLOPT_HSTS.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_ALTSVC (3)
   - CURLOPT_HSTS_CTRL (3)
   - CURLOPT_RESOLVE (3)
+Added-in: 7.74.0
 ---
 
 # NAME
@@ -59,6 +60,8 @@ currently no length or size limit.
 
 NULL, no filename
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -72,9 +75,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.74.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HSTSREADDATA.md b/docs/libcurl/opts/CURLOPT_HSTSREADDATA.md
index 8c3230982..eda180e30 100644
--- a/docs/libcurl/opts/CURLOPT_HSTSREADDATA.md
+++ b/docs/libcurl/opts/CURLOPT_HSTSREADDATA.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_HSTSREADFUNCTION (3)
   - CURLOPT_HSTSWRITEDATA (3)
   - CURLOPT_HSTSWRITEFUNCTION (3)
+Added-in: 7.74.0
 ---
 
 # NAME
@@ -38,6 +39,8 @@ do that.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -61,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.74.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HSTSREADFUNCTION.md b/docs/libcurl/opts/CURLOPT_HSTSREADFUNCTION.md
index fe55ab8de..5d03607fa 100644
--- a/docs/libcurl/opts/CURLOPT_HSTSREADFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_HSTSREADFUNCTION.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_HSTSREADDATA (3)
   - CURLOPT_HSTSWRITEFUNCTION (3)
   - CURLOPT_HSTS_CTRL (3)
+Added-in: 7.74.0
 ---
 
 # NAME
@@ -63,6 +64,8 @@ do that.
 
 NULL - no callback.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -95,9 +98,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.74.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HSTSWRITEDATA.md b/docs/libcurl/opts/CURLOPT_HSTSWRITEDATA.md
index 23c7302f0..6be5582db 100644
--- a/docs/libcurl/opts/CURLOPT_HSTSWRITEDATA.md
+++ b/docs/libcurl/opts/CURLOPT_HSTSWRITEDATA.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_HSTSREADDATA (3)
   - CURLOPT_HSTSREADFUNCTION (3)
   - CURLOPT_HSTSWRITEFUNCTION (3)
+Added-in: 7.74.0
 ---
 
 # NAME
@@ -38,6 +39,8 @@ do that.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -61,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.74.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HSTSWRITEFUNCTION.md b/docs/libcurl/opts/CURLOPT_HSTSWRITEFUNCTION.md
index 8fa621510..621268ea5 100644
--- a/docs/libcurl/opts/CURLOPT_HSTSWRITEFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_HSTSWRITEFUNCTION.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_HSTSWRITEDATA (3)
   - CURLOPT_HSTSWRITEFUNCTION (3)
   - CURLOPT_HSTS_CTRL (3)
+Added-in: 7.74.0
 ---
 
 # NAME
@@ -67,6 +68,8 @@ do that.
 
 NULL - no callback.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -99,9 +102,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.74.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HSTS_CTRL.md b/docs/libcurl/opts/CURLOPT_HSTS_CTRL.md
index dec7a3844..8dee60867 100644
--- a/docs/libcurl/opts/CURLOPT_HSTS_CTRL.md
+++ b/docs/libcurl/opts/CURLOPT_HSTS_CTRL.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_CONNECT_TO (3)
   - CURLOPT_HSTS (3)
   - CURLOPT_RESOLVE (3)
+Added-in: 7.74.0
 ---
 
 # NAME
@@ -52,7 +53,9 @@ to the file when closing the handle.
 
 # DEFAULT
 
-0. HSTS is disabled by default.
+0
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -67,9 +70,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.74.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HTTP09_ALLOWED.md b/docs/libcurl/opts/CURLOPT_HTTP09_ALLOWED.md
index 6312148c2..28fbe0a91 100644
--- a/docs/libcurl/opts/CURLOPT_HTTP09_ALLOWED.md
+++ b/docs/libcurl/opts/CURLOPT_HTTP09_ALLOWED.md
@@ -9,6 +9,7 @@ Protocol:
 See-also:
   - CURLOPT_HTTP_VERSION (3)
   - CURLOPT_SSLVERSION (3)
+Added-in: 7.64.0
 ---
 
 # NAME
@@ -33,10 +34,9 @@ that curl might consider to be HTTP/0.9!
 
 # DEFAULT
 
-curl allowed HTTP/0.9 responses by default before 7.66.0
+0
 
-Since 7.66.0, libcurl requires this option set to 1L to allow HTTP/0.9
-responses.
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -53,9 +53,14 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
+
+curl allowed HTTP/0.9 responses by default before 7.66.0
+
+Since 7.66.0, libcurl requires this option set to 1L to allow HTTP/0.9
+responses.
 
-Option added in 7.64.0, present along with HTTP.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HTTP200ALIASES.md b/docs/libcurl/opts/CURLOPT_HTTP200ALIASES.md
index 4363ef444..59cdfeef6 100644
--- a/docs/libcurl/opts/CURLOPT_HTTP200ALIASES.md
+++ b/docs/libcurl/opts/CURLOPT_HTTP200ALIASES.md
@@ -9,6 +9,7 @@ Protocol:
 See-also:
   - CURLOPT_HTTP09_ALLOWED (3)
   - CURLOPT_HTTP_VERSION (3)
+Added-in: 7.10.3
 ---
 
 # NAME
@@ -44,6 +45,8 @@ assumed to match HTTP 1.0 when an alias match.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10.3
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HTTPAUTH.md b/docs/libcurl/opts/CURLOPT_HTTPAUTH.md
index be1c77323..e436e078c 100644
--- a/docs/libcurl/opts/CURLOPT_HTTPAUTH.md
+++ b/docs/libcurl/opts/CURLOPT_HTTPAUTH.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_PASSWORD (3)
   - CURLOPT_PROXYAUTH (3)
   - CURLOPT_USERNAME (3)
+Added-in: 7.10.6
 ---
 
 # NAME
@@ -125,6 +126,8 @@ see CURLOPT_AWS_SIGV4(3).
 
 CURLAUTH_BASIC
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -142,9 +145,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Option Added in 7.10.6.
+# HISTORY
 
 CURLAUTH_DIGEST_IE was added in 7.19.3
 
@@ -156,6 +157,8 @@ CURLAUTH_BEARER was added in 7.61.0
 
 CURLAUTH_AWS_SIGV4 was added in 7.74.0
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, CURLE_UNKNOWN_OPTION if not, or
diff --git a/docs/libcurl/opts/CURLOPT_HTTPGET.md b/docs/libcurl/opts/CURLOPT_HTTPGET.md
index 8f5c35463..109fe9ce4 100644
--- a/docs/libcurl/opts/CURLOPT_HTTPGET.md
+++ b/docs/libcurl/opts/CURLOPT_HTTPGET.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_POST (3)
   - CURLOPT_UPLOAD (3)
   - curl_easy_reset (3)
+Added-in: 7.8.1
 ---
 
 # NAME
@@ -42,6 +43,8 @@ reset a handle to default method, consider curl_easy_reset(3).
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with HTTP
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HTTPHEADER.md b/docs/libcurl/opts/CURLOPT_HTTPHEADER.md
index 7f060ea89..35a67a12a 100644
--- a/docs/libcurl/opts/CURLOPT_HTTPHEADER.md
+++ b/docs/libcurl/opts/CURLOPT_HTTPHEADER.md
@@ -15,6 +15,7 @@ See-also:
   - CURLOPT_MIMEPOST (3)
   - CURLOPT_PROXYHEADER (3)
   - curl_mime_init (3)
+Added-in: 7.1
 ---
 
 # NAME
@@ -114,9 +115,11 @@ MIME mail is only composed of alternative representations of the same data
 In all cases the value must be of the form "multipart/*" to respect the
 document structure and may not include the "boundary=" parameter.
 
+##
+
 Other specific headers that do not have a libcurl default value but are
 strongly desired by mail delivery and user agents should also be included.
-These are "From:", "To:", "Date:" and "Subject:" among others and their
+These are `From:`, `To:`, `Date:` and `Subject:` among others and their
 presence and value is generally checked by anti-spam utilities.
 
 # SECURITY CONCERNS
@@ -148,6 +151,8 @@ with the CURLOPT_UNRESTRICTED_AUTH(3) option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -172,9 +177,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
+
+Use for MIME mail added in 7.56.0.
 
-As long as HTTP is enabled. Use in MIME mail added in 7.56.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HTTPPOST.md b/docs/libcurl/opts/CURLOPT_HTTPPOST.md
index 0c3947147..e9381c376 100644
--- a/docs/libcurl/opts/CURLOPT_HTTPPOST.md
+++ b/docs/libcurl/opts/CURLOPT_HTTPPOST.md
@@ -13,6 +13,7 @@ See-also:
   - curl_formadd (3)
   - curl_formfree (3)
   - curl_mime_init (3)
+Added-in: 7.1
 ---
 
 # NAME
@@ -49,6 +50,8 @@ CURLOPT_NOBODY(3) to 0.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -89,9 +92,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
+
+Deprecated in 7.56.0.
 
-As long as HTTP is enabled. Deprecated in 7.56.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HTTPPROXYTUNNEL.md b/docs/libcurl/opts/CURLOPT_HTTPPROXYTUNNEL.md
index 9591892df..60b4e6a80 100644
--- a/docs/libcurl/opts/CURLOPT_HTTPPROXYTUNNEL.md
+++ b/docs/libcurl/opts/CURLOPT_HTTPPROXYTUNNEL.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_PROXY (3)
   - CURLOPT_PROXYPORT (3)
   - CURLOPT_PROXYTYPE (3)
+Added-in: 7.3
 ---
 
 # NAME
@@ -49,6 +50,8 @@ rarely works through the proxy anyway).
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HTTP_CONTENT_DECODING.md b/docs/libcurl/opts/CURLOPT_HTTP_CONTENT_DECODING.md
index 10ff5ab4d..3c3e381ac 100644
--- a/docs/libcurl/opts/CURLOPT_HTTP_CONTENT_DECODING.md
+++ b/docs/libcurl/opts/CURLOPT_HTTP_CONTENT_DECODING.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_ACCEPT_ENCODING (3)
   - CURLOPT_DEBUGFUNCTION (3)
   - CURLOPT_STDERR (3)
+Added-in: 7.16.2
 ---
 
 # NAME
@@ -36,6 +37,8 @@ CURLOPT_ACCEPT_ENCODING(3) for that.
 
 1
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -51,9 +54,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.16.2
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HTTP_TRANSFER_DECODING.md b/docs/libcurl/opts/CURLOPT_HTTP_TRANSFER_DECODING.md
index c0b88b83f..52cee575b 100644
--- a/docs/libcurl/opts/CURLOPT_HTTP_TRANSFER_DECODING.md
+++ b/docs/libcurl/opts/CURLOPT_HTTP_TRANSFER_DECODING.md
@@ -9,6 +9,7 @@ Protocol:
 See-also:
   - CURLOPT_ACCEPT_ENCODING (3)
   - CURLOPT_HTTP_CONTENT_DECODING (3)
+Added-in: 7.16.2
 ---
 
 # NAME
@@ -30,10 +31,17 @@ Pass a long to tell libcurl how to act on transfer decoding. If set to zero,
 transfer decoding is disabled, if set to 1 it is enabled (default). libcurl
 does chunked transfer decoding by default unless this option is set to zero.
 
+# NOTES
+
+This option does not work with the hyper backend as that always has transfer
+decoding enabled.
+
 # DEFAULT
 
 1
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -49,10 +57,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.16.2 Does not work with the hyper backend (it always has transfer
-decoding enabled).
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_HTTP_VERSION.md b/docs/libcurl/opts/CURLOPT_HTTP_VERSION.md
index 88a7154b9..0a9215d8a 100644
--- a/docs/libcurl/opts/CURLOPT_HTTP_VERSION.md
+++ b/docs/libcurl/opts/CURLOPT_HTTP_VERSION.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_HTTP09_ALLOWED (3)
   - CURLOPT_HTTP200ALIASES (3)
   - CURLOPT_SSLVERSION (3)
+Added-in: 7.9.1
 ---
 
 # NAME
@@ -89,6 +90,8 @@ Since curl 7.62.0: CURL_HTTP_VERSION_2TLS
 
 Before that: CURL_HTTP_VERSION_1_1
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -108,9 +111,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with HTTP
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_IGNORE_CONTENT_LENGTH.md b/docs/libcurl/opts/CURLOPT_IGNORE_CONTENT_LENGTH.md
index a39573e6a..4b8228b40 100644
--- a/docs/libcurl/opts/CURLOPT_IGNORE_CONTENT_LENGTH.md
+++ b/docs/libcurl/opts/CURLOPT_IGNORE_CONTENT_LENGTH.md
@@ -10,6 +10,7 @@ Protocol:
 See-also:
   - CURLOPT_HTTP_VERSION (3)
   - CURLOPT_MAXFILESIZE_LARGE (3)
+Added-in: 7.14.1
 ---
 
 # NAME
@@ -45,6 +46,8 @@ Only use this option if strictly necessary.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -62,10 +65,16 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
+
+Support for FTP added in 7.46.0.
+
+# NOTES
+
+This option is not working for HTTP when libcurl is built to use the hyper
+backend.
 
-Added in 7.14.1. Support for FTP added in 7.46.0. This option is not working
-for HTTP when libcurl is built to use the hyper backend.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_INFILESIZE.md b/docs/libcurl/opts/CURLOPT_INFILESIZE.md
index 522bdb41a..8c9ab6243 100644
--- a/docs/libcurl/opts/CURLOPT_INFILESIZE.md
+++ b/docs/libcurl/opts/CURLOPT_INFILESIZE.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_UPLOAD (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -50,6 +51,8 @@ and sending a different amount may lead to errors.
 
 Unset
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -74,10 +77,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 SMTP support added in 7.23.0
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, and CURLE_UNKNOWN_OPTION if not.
diff --git a/docs/libcurl/opts/CURLOPT_INFILESIZE_LARGE.md b/docs/libcurl/opts/CURLOPT_INFILESIZE_LARGE.md
index 712cd5802..2fb736484 100644
--- a/docs/libcurl/opts/CURLOPT_INFILESIZE_LARGE.md
+++ b/docs/libcurl/opts/CURLOPT_INFILESIZE_LARGE.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_UPLOAD (3)
 Protocol:
   - All
+Added-in: 7.11.0
 ---
 
 # NAME
@@ -47,6 +48,8 @@ and sending a different amount may lead to errors.
 
 Unset
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -70,10 +73,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 SMTP support added in 7.23.0
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, and CURLE_UNKNOWN_OPTION if not.
diff --git a/docs/libcurl/opts/CURLOPT_INTERFACE.md b/docs/libcurl/opts/CURLOPT_INTERFACE.md
index f79a43078..f1ca875fc 100644
--- a/docs/libcurl/opts/CURLOPT_INTERFACE.md
+++ b/docs/libcurl/opts/CURLOPT_INTERFACE.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_SOCKOPTFUNCTION (3)
   - CURLOPT_TCP_NODELAY (3)
   - CURLOPT_LOCALPORT (3)
+Added-in: 7.3
 ---
 
 # NAME
@@ -28,15 +29,16 @@ CURLcode curl_easy_setopt(CURL *handle, CURLOPT_INTERFACE, char *interface);
 
 Pass a char pointer as parameter. This sets the *interface* name to use as
 outgoing network interface. The name can be an interface name, an IP address,
-or a hostname.
+or a hostname. If you prefer one of these, you can use the following special
+prefixes:
 
-If the parameter starts with "if!" then it is treated only as an interface
-name. If the parameter starts with "host!" it is treated as either an IP
-address or a hostname.
+* `if!\<name\>` - Interface name
+* `host!\<name\>` - IP address or hostname
+* `ifhost!\<interface\>!\<host\>` - Interface name and IP address or hostname
 
-If "if!" is specified but the parameter does not match an existing interface,
-*CURLE_INTERFACE_FAILED* is returned from the libcurl function used to perform
-the transfer.
+If `if!` or `ifhost!` is specified but the parameter does not match an existing
+interface, *CURLE_INTERFACE_FAILED* is returned from the libcurl function used
+to perform the transfer.
 
 libcurl does not support using network interface names for this option on
 Windows.
@@ -53,6 +55,8 @@ option.
 
 NULL, use whatever the TCP stack finds suitable
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -72,9 +76,13 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
+
+The `if!` and `host!` syntax was added in 7.24.0.
+
+The `ifhost!` syntax was added in 8.9.0.
 
-The "if!" and "host!" syntax was added in 7.24.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_INTERLEAVEDATA.md b/docs/libcurl/opts/CURLOPT_INTERLEAVEDATA.md
index 508c76f13..15f1c8332 100644
--- a/docs/libcurl/opts/CURLOPT_INTERLEAVEDATA.md
+++ b/docs/libcurl/opts/CURLOPT_INTERLEAVEDATA.md
@@ -9,6 +9,7 @@ Protocol:
 See-also:
   - CURLOPT_INTERLEAVEFUNCTION (3)
   - CURLOPT_RTSP_REQUEST (3)
+Added-in: 7.20.0
 ---
 
 # NAME
@@ -34,6 +35,8 @@ anywhere.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -61,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.20.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_INTERLEAVEFUNCTION.md b/docs/libcurl/opts/CURLOPT_INTERLEAVEFUNCTION.md
index 7d2e52857..6f9754229 100644
--- a/docs/libcurl/opts/CURLOPT_INTERLEAVEFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_INTERLEAVEFUNCTION.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_RTSP_REQUEST (3)
 Protocol:
   - RTSP
+Added-in: 7.20.0
 ---
 
 # NAME
@@ -65,6 +66,8 @@ You can also abort the transfer by returning CURL_WRITEFUNC_ERROR. (7.87.0)
 NULL, the interleave data is then passed to the regular write function:
 CURLOPT_WRITEFUNCTION(3).
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -91,9 +94,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.20.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_IOCTLDATA.md b/docs/libcurl/opts/CURLOPT_IOCTLDATA.md
index ef33d7ce5..b9cd9a509 100644
--- a/docs/libcurl/opts/CURLOPT_IOCTLDATA.md
+++ b/docs/libcurl/opts/CURLOPT_IOCTLDATA.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_SEEKFUNCTION (3)
 Protocol:
   - All
+Added-in: 7.12.3
 ---
 
 # NAME
@@ -30,7 +31,9 @@ argument in the ioctl callback set with CURLOPT_IOCTLFUNCTION(3).
 
 # DEFAULT
 
-By default, the value of this parameter is NULL.
+NULL
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -61,9 +64,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
+
+Deprecated since 7.18.0.
 
-Added in 7.12.3. Deprecated since 7.18.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_IOCTLFUNCTION.md b/docs/libcurl/opts/CURLOPT_IOCTLFUNCTION.md
index 75e04c302..b26a542f7 100644
--- a/docs/libcurl/opts/CURLOPT_IOCTLFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_IOCTLFUNCTION.md
@@ -9,6 +9,7 @@ Protocol:
 See-also:
   - CURLOPT_IOCTLDATA (3)
   - CURLOPT_SEEKFUNCTION (3)
+Added-in: 7.12.3
 ---
 
 # NAME
@@ -61,7 +62,9 @@ parameter is ignored when seeking.
 
 # DEFAULT
 
-By default, this parameter is set to NULL. Not used.
+NULL
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -92,9 +95,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
+
+Deprecated since 7.18.0.
 
-Added in 7.12.3. Deprecated since 7.18.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_IPRESOLVE.md b/docs/libcurl/opts/CURLOPT_IPRESOLVE.md
index acf0b3830..1b4369d22 100644
--- a/docs/libcurl/opts/CURLOPT_IPRESOLVE.md
+++ b/docs/libcurl/opts/CURLOPT_IPRESOLVE.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_SSLVERSION (3)
 Protocol:
   - All
+Added-in: 7.10.8
 ---
 
 # NAME
@@ -52,6 +53,8 @@ Uses only IPv6 addresses.
 
 CURL_IPRESOLVE_WHATEVER
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -72,9 +75,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_ISSUERCERT.md b/docs/libcurl/opts/CURLOPT_ISSUERCERT.md
index f9000559e..fa726b0cf 100644
--- a/docs/libcurl/opts/CURLOPT_ISSUERCERT.md
+++ b/docs/libcurl/opts/CURLOPT_ISSUERCERT.md
@@ -13,6 +13,7 @@ Protocol:
 TLS-backend:
   - OpenSSL
   - GnuTLS
+Added-in: 7.19.0
 ---
 
 # NAME
@@ -52,6 +53,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -68,9 +71,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-If built TLS enabled
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_ISSUERCERT_BLOB.md b/docs/libcurl/opts/CURLOPT_ISSUERCERT_BLOB.md
index 142225da6..77f0d87bf 100644
--- a/docs/libcurl/opts/CURLOPT_ISSUERCERT_BLOB.md
+++ b/docs/libcurl/opts/CURLOPT_ISSUERCERT_BLOB.md
@@ -13,6 +13,7 @@ Protocol:
   - TLS
 TLS-backend:
   - OpenSSL
+Added-in: 7.71.0
 ---
 
 # NAME
@@ -58,6 +59,8 @@ expects a filename as input.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -82,9 +85,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.71.0. This option is supported by the OpenSSL backends.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_KEEP_SENDING_ON_ERROR.md b/docs/libcurl/opts/CURLOPT_KEEP_SENDING_ON_ERROR.md
index 6a48523e8..fb52799f4 100644
--- a/docs/libcurl/opts/CURLOPT_KEEP_SENDING_ON_ERROR.md
+++ b/docs/libcurl/opts/CURLOPT_KEEP_SENDING_ON_ERROR.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_HTTPHEADER (3)
 Protocol:
   - HTTP
+Added-in: 7.51.0
 ---
 
 # NAME
@@ -41,6 +42,8 @@ Most applications do not need this option.
 
 0, stop sending on error
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,9 +60,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with HTTP. Added in 7.51.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_KEYPASSWD.md b/docs/libcurl/opts/CURLOPT_KEYPASSWD.md
index 408ccfbfb..79f31555a 100644
--- a/docs/libcurl/opts/CURLOPT_KEYPASSWD.md
+++ b/docs/libcurl/opts/CURLOPT_KEYPASSWD.md
@@ -14,6 +14,7 @@ TLS-backend:
   - mbedTLS
   - Schannel
   - wolfSSL
+Added-in: 7.17.0
 ---
 
 # NAME
@@ -32,7 +33,7 @@ CURLcode curl_easy_setopt(CURL *handle, CURLOPT_KEYPASSWD, char *pwd);
 
 Pass a pointer to a null-terminated string as parameter. It is used as the
 password required to use the CURLOPT_SSLKEY(3) or
-CURLOPT_SSH_PRIVATE_KEYFILE(3) private key. You never need a pass phrase to
+CURLOPT_SSH_PRIVATE_KEYFILE(3) private key. You never need a passphrase to
 load a certificate but you need one to load your private key.
 
 The application does not have to keep the string around after setting this
@@ -42,6 +43,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,11 +63,13 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 This option was known as CURLOPT_SSLKEYPASSWD up to 7.16.4 and
 CURLOPT_SSLCERTPASSWD up to 7.9.2.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if TLS enabled, CURLE_UNKNOWN_OPTION if not, or
diff --git a/docs/libcurl/opts/CURLOPT_KRBLEVEL.md b/docs/libcurl/opts/CURLOPT_KRBLEVEL.md
index dfadcf436..0c35b163f 100644
--- a/docs/libcurl/opts/CURLOPT_KRBLEVEL.md
+++ b/docs/libcurl/opts/CURLOPT_KRBLEVEL.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_USE_SSL (3)
 Protocol:
   - FTP
+Added-in: 7.16.4
 ---
 
 # NAME
@@ -38,6 +39,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -54,10 +57,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 This option was known as CURLOPT_KRB4LEVEL up to 7.16.3
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, CURLE_UNKNOWN_OPTION if not, or
diff --git a/docs/libcurl/opts/CURLOPT_LOCALPORT.md b/docs/libcurl/opts/CURLOPT_LOCALPORT.md
index 94b5d50f8..a7cc9fdc7 100644
--- a/docs/libcurl/opts/CURLOPT_LOCALPORT.md
+++ b/docs/libcurl/opts/CURLOPT_LOCALPORT.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_LOCALPORTRANGE (3)
 Protocol:
   - All
+Added-in: 7.15.2
 ---
 
 # NAME
@@ -35,6 +36,8 @@ this option is set. Valid port numbers are 1 - 65535.
 
 0, disabled - use whatever the system thinks is fine
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -53,9 +56,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.15.2
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_LOCALPORTRANGE.md b/docs/libcurl/opts/CURLOPT_LOCALPORTRANGE.md
index 4549cafe3..5d8c8a267 100644
--- a/docs/libcurl/opts/CURLOPT_LOCALPORTRANGE.md
+++ b/docs/libcurl/opts/CURLOPT_LOCALPORTRANGE.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_LOCALPORT (3)
 Protocol:
   - All
+Added-in: 7.15.2
 ---
 
 # NAME
@@ -38,6 +39,8 @@ setup failures.
 
 1
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -56,9 +59,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.15.2
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_LOGIN_OPTIONS.md b/docs/libcurl/opts/CURLOPT_LOGIN_OPTIONS.md
index 5c879603a..44f392250 100644
--- a/docs/libcurl/opts/CURLOPT_LOGIN_OPTIONS.md
+++ b/docs/libcurl/opts/CURLOPT_LOGIN_OPTIONS.md
@@ -12,6 +12,7 @@ Protocol:
   - LDAP
   - POP3
   - SMTP
+Added-in: 7.34.0
 ---
 
 # NAME
@@ -51,6 +52,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -67,9 +70,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
+
+Support for OpenLDAP added in 7.82.0.
 
-Added in 7.34.0. Support for OpenLDAP added in 7.82.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_LOW_SPEED_LIMIT.md b/docs/libcurl/opts/CURLOPT_LOW_SPEED_LIMIT.md
index d0131a4ee..58415df12 100644
--- a/docs/libcurl/opts/CURLOPT_LOW_SPEED_LIMIT.md
+++ b/docs/libcurl/opts/CURLOPT_LOW_SPEED_LIMIT.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_TIMEOUT (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -37,6 +38,8 @@ slow and abort.
 
 0, disabled
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -59,9 +62,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_LOW_SPEED_TIME.md b/docs/libcurl/opts/CURLOPT_LOW_SPEED_TIME.md
index 06e38c194..04edef334 100644
--- a/docs/libcurl/opts/CURLOPT_LOW_SPEED_TIME.md
+++ b/docs/libcurl/opts/CURLOPT_LOW_SPEED_TIME.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_TIMEOUT (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -34,6 +35,8 @@ library to consider it too slow and abort.
 
 0, disabled
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -56,9 +59,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_MAIL_AUTH.md b/docs/libcurl/opts/CURLOPT_MAIL_AUTH.md
index afe62b91c..44effd4ee 100644
--- a/docs/libcurl/opts/CURLOPT_MAIL_AUTH.md
+++ b/docs/libcurl/opts/CURLOPT_MAIL_AUTH.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_MAIL_RCPT (3)
 Protocol:
   - SMTP
+Added-in: 7.25.0
 ---
 
 # NAME
@@ -48,6 +49,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.25.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_MAIL_FROM.md b/docs/libcurl/opts/CURLOPT_MAIL_FROM.md
index 52a8e51fc..b0b66355c 100644
--- a/docs/libcurl/opts/CURLOPT_MAIL_FROM.md
+++ b/docs/libcurl/opts/CURLOPT_MAIL_FROM.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_MAIL_RCPT (3)
 Protocol:
   - SMTP
+Added-in: 7.20.0
 ---
 
 # NAME
@@ -41,6 +42,8 @@ option.
 
 blank
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,9 +60,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.20.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_MAIL_RCPT.md b/docs/libcurl/opts/CURLOPT_MAIL_RCPT.md
index 98b640e2e..9910860f3 100644
--- a/docs/libcurl/opts/CURLOPT_MAIL_RCPT.md
+++ b/docs/libcurl/opts/CURLOPT_MAIL_RCPT.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_MAIL_FROM (3)
 Protocol:
   - SMTP
+Added-in: 7.20.0
 ---
 
 # NAME
@@ -48,6 +49,8 @@ should be specified using the mailing list name, such as `Friends` or
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -68,9 +71,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.20.0. The **VRFY** and **EXPN** logic was added in 7.34.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_MAIL_RCPT_ALLOWFAILS.md b/docs/libcurl/opts/CURLOPT_MAIL_RCPT_ALLOWFAILS.md
index d315d2bc8..f17d56151 100644
--- a/docs/libcurl/opts/CURLOPT_MAIL_RCPT_ALLOWFAILS.md
+++ b/docs/libcurl/opts/CURLOPT_MAIL_RCPT_ALLOWFAILS.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_MAIL_RCPT (3)
 Protocol:
   - SMTP
+Added-in: 8.2.0
 ---
 
 # NAME
@@ -44,6 +45,8 @@ RCPT TO command.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -68,11 +71,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
-This option was called CURLOPT_MAIL_RCPT_ALLLOWFAILS before 8.2.0
+This option was called CURLOPT_MAIL_RCPT_ALLLOWFAILS (with three instead of
+two letter L) before 8.2.0
 
-Added in 7.69.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_MAXAGE_CONN.md b/docs/libcurl/opts/CURLOPT_MAXAGE_CONN.md
index 6d92fa4af..c834d88c7 100644
--- a/docs/libcurl/opts/CURLOPT_MAXAGE_CONN.md
+++ b/docs/libcurl/opts/CURLOPT_MAXAGE_CONN.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_TIMEOUT (3)
 Protocol:
   - All
+Added-in: 7.65.0
 ---
 
 # NAME
@@ -41,7 +42,9 @@ cache that is older than this set *age*, it is closed instead.
 
 # DEFAULT
 
-Default maximum age is set to 118 seconds.
+118 seconds
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.65.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_MAXCONNECTS.md b/docs/libcurl/opts/CURLOPT_MAXCONNECTS.md
index cd8b18dd0..e1e0c2565 100644
--- a/docs/libcurl/opts/CURLOPT_MAXCONNECTS.md
+++ b/docs/libcurl/opts/CURLOPT_MAXCONNECTS.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_MAXREDIRS (3)
 Protocol:
   - All
+Added-in: 7.7
 ---
 
 # NAME
@@ -48,6 +49,8 @@ CURLMOPT_MAXCONNECTS(3) option.
 
 5
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_MAXFILESIZE.md b/docs/libcurl/opts/CURLOPT_MAXFILESIZE.md
index 14f95f8cb..a90763012 100644
--- a/docs/libcurl/opts/CURLOPT_MAXFILESIZE.md
+++ b/docs/libcurl/opts/CURLOPT_MAXFILESIZE.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_MAX_RECV_SPEED_LARGE (3)
 Protocol:
   - All
+Added-in: 7.10.8
 ---
 
 # NAME
@@ -44,6 +45,8 @@ threshold.
 
 0, meaning disabled.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_MAXFILESIZE_LARGE.md b/docs/libcurl/opts/CURLOPT_MAXFILESIZE_LARGE.md
index 9ace0d6ec..ad6b10750 100644
--- a/docs/libcurl/opts/CURLOPT_MAXFILESIZE_LARGE.md
+++ b/docs/libcurl/opts/CURLOPT_MAXFILESIZE_LARGE.md
@@ -11,6 +11,7 @@ Protocol:
   - FTP
   - HTTP
   - MQTT
+Added-in: 7.11.0
 ---
 
 # NAME
@@ -45,6 +46,8 @@ threshold.
 
 0, meaning disabled.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -62,9 +65,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.11.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_MAXLIFETIME_CONN.md b/docs/libcurl/opts/CURLOPT_MAXLIFETIME_CONN.md
index 79b87245b..5615f1fd1 100644
--- a/docs/libcurl/opts/CURLOPT_MAXLIFETIME_CONN.md
+++ b/docs/libcurl/opts/CURLOPT_MAXLIFETIME_CONN.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_TIMEOUT (3)
 Protocol:
   - All
+Added-in: 7.80.0
 ---
 
 # NAME
@@ -43,7 +44,9 @@ If set to 0, this behavior is disabled: all connections are eligible for reuse.
 
 # DEFAULT
 
-Default *maxlifetime* is 0 seconds (i.e., disabled).
+0 seconds (i.e., disabled)
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -62,9 +65,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.80.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_MAXREDIRS.md b/docs/libcurl/opts/CURLOPT_MAXREDIRS.md
index 751b22ed0..4f94f8d37 100644
--- a/docs/libcurl/opts/CURLOPT_MAXREDIRS.md
+++ b/docs/libcurl/opts/CURLOPT_MAXREDIRS.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_FOLLOWLOCATION (3)
 Protocol:
   - HTTP
+Added-in: 7.5
 ---
 
 # NAME
@@ -40,6 +41,8 @@ to get stuck in never-ending redirect loops.
 
 30 (since 8.3.0), it was previously unlimited.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -61,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with HTTP
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_MAX_RECV_SPEED_LARGE.md b/docs/libcurl/opts/CURLOPT_MAX_RECV_SPEED_LARGE.md
index 9e08a68dc..987693e84 100644
--- a/docs/libcurl/opts/CURLOPT_MAX_RECV_SPEED_LARGE.md
+++ b/docs/libcurl/opts/CURLOPT_MAX_RECV_SPEED_LARGE.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_TIMEOUT (3)
 Protocol:
   - All
+Added-in: 7.15.5
 ---
 
 # NAME
@@ -43,6 +44,8 @@ This option does not affect transfer speeds done with FILE:// URLs.
 
 0, disabled
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -59,9 +62,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.15.5
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_MAX_SEND_SPEED_LARGE.md b/docs/libcurl/opts/CURLOPT_MAX_SEND_SPEED_LARGE.md
index d8927269a..22f3cb065 100644
--- a/docs/libcurl/opts/CURLOPT_MAX_SEND_SPEED_LARGE.md
+++ b/docs/libcurl/opts/CURLOPT_MAX_SEND_SPEED_LARGE.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_MAX_RECV_SPEED_LARGE (3)
 Protocol:
   - All
+Added-in: 7.15.5
 ---
 
 # NAME
@@ -44,6 +45,8 @@ This option does not affect transfer speeds done with FILE:// URLs.
 
 0, disabled
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -61,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.15.5
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_MIMEPOST.md b/docs/libcurl/opts/CURLOPT_MIMEPOST.md
index 8a4edb10b..9e3b3806c 100644
--- a/docs/libcurl/opts/CURLOPT_MIMEPOST.md
+++ b/docs/libcurl/opts/CURLOPT_MIMEPOST.md
@@ -13,6 +13,7 @@ Protocol:
   - HTTP
   - SMTP
   - IMAP
+Added-in: 7.56.0
 ---
 
 # NAME
@@ -43,6 +44,8 @@ When setting CURLOPT_MIMEPOST(3) to NULL, libcurl resets the request
 type for HTTP to the default to disable the POST. Typically that would mean it
 is reset to GET. Instead you should set a desired request method explicitly.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -72,9 +75,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.56.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_MIME_OPTIONS.md b/docs/libcurl/opts/CURLOPT_MIME_OPTIONS.md
index f1f5fe0da..5175570e5 100644
--- a/docs/libcurl/opts/CURLOPT_MIME_OPTIONS.md
+++ b/docs/libcurl/opts/CURLOPT_MIME_OPTIONS.md
@@ -11,6 +11,7 @@ Protocol:
   - HTTP
   - IMAP
   - SMTP
+Added-in: 7.81.0
 ---
 
 # NAME
@@ -56,6 +57,8 @@ containing multipart form is sent, this is normally transmitted as
 
 0, meaning disabled.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -88,9 +91,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Option added in 7.81.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_NETRC.md b/docs/libcurl/opts/CURLOPT_NETRC.md
index 6b5e1d2e8..98568cc91 100644
--- a/docs/libcurl/opts/CURLOPT_NETRC.md
+++ b/docs/libcurl/opts/CURLOPT_NETRC.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_USERPWD (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -30,8 +31,10 @@ This parameter controls the preference *level* of libcurl between using
 usernames and passwords from your *~/.netrc* file, relative to usernames and
 passwords in the URL supplied with CURLOPT_URL(3).
 
-On Windows, libcurl uses the file as *%HOME%/_netrc*. If *%HOME%* is
-not set on Windows, libcurl falls back to *%USERPROFILE%*.
+On Windows, libcurl primarily checks for *.netrc* in *%HOME%*. If *%HOME%* is
+not set on Windows, libcurl falls back to *%USERPROFILE%*. If the file does
+not exist, it falls back to check if there is instead a file named *_netrc* -
+using an underscore instead of period.
 
 You can also tell libcurl a different filename to use with
 CURLOPT_NETRC_FILE(3).
@@ -115,6 +118,8 @@ done with "macdef" that it finds.
 
 CURL_NETRC_IGNORED
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -130,9 +135,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_NETRC_FILE.md b/docs/libcurl/opts/CURLOPT_NETRC_FILE.md
index 57b2acb78..a27d470ae 100644
--- a/docs/libcurl/opts/CURLOPT_NETRC_FILE.md
+++ b/docs/libcurl/opts/CURLOPT_NETRC_FILE.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_USERNAME (3)
 Protocol:
   - All
+Added-in: 7.11.0
 ---
 
 # NAME
@@ -38,6 +39,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -54,9 +57,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10.9
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_NEW_DIRECTORY_PERMS.md b/docs/libcurl/opts/CURLOPT_NEW_DIRECTORY_PERMS.md
index 51863440e..94c778c7e 100644
--- a/docs/libcurl/opts/CURLOPT_NEW_DIRECTORY_PERMS.md
+++ b/docs/libcurl/opts/CURLOPT_NEW_DIRECTORY_PERMS.md
@@ -12,6 +12,7 @@ Protocol:
   - SFTP
   - SCP
   - FILE
+Added-in: 7.16.4
 ---
 
 # NAME
@@ -38,6 +39,8 @@ this are *sftp://*, *scp://*, and *file://*.
 
 0755
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -55,9 +58,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.16.4
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_NEW_FILE_PERMS.md b/docs/libcurl/opts/CURLOPT_NEW_FILE_PERMS.md
index a04b99585..f3fba5589 100644
--- a/docs/libcurl/opts/CURLOPT_NEW_FILE_PERMS.md
+++ b/docs/libcurl/opts/CURLOPT_NEW_FILE_PERMS.md
@@ -11,6 +11,7 @@ Protocol:
   - SFTP
   - SCP
   - FILE
+Added-in: 7.16.4
 ---
 
 # NAME
@@ -36,6 +37,8 @@ The only protocols that can use this are *sftp://*, *scp://*, and *file://*.
 
 0644
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -51,9 +54,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.16.4
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_NOBODY.md b/docs/libcurl/opts/CURLOPT_NOBODY.md
index 319b9ed61..0168912ad 100644
--- a/docs/libcurl/opts/CURLOPT_NOBODY.md
+++ b/docs/libcurl/opts/CURLOPT_NOBODY.md
@@ -12,6 +12,7 @@ See-also:
   - CURLOPT_UPLOAD (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -49,6 +50,8 @@ URL you request).
 
 0, the body is transferred
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -67,9 +70,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_NOPROGRESS.md b/docs/libcurl/opts/CURLOPT_NOPROGRESS.md
index 6363b18c1..5f3d7322e 100644
--- a/docs/libcurl/opts/CURLOPT_NOPROGRESS.md
+++ b/docs/libcurl/opts/CURLOPT_NOPROGRESS.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_XFERINFOFUNCTION (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -36,6 +37,8 @@ getting called.
 
 1, meaning it normally runs without a progress meter.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -54,9 +57,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_NOPROXY.md b/docs/libcurl/opts/CURLOPT_NOPROXY.md
index 1f181c780..1412a9a58 100644
--- a/docs/libcurl/opts/CURLOPT_NOPROXY.md
+++ b/docs/libcurl/opts/CURLOPT_NOPROXY.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_PROXY (3)
   - CURLOPT_PROXYAUTH (3)
   - CURLOPT_PROXYTYPE (3)
+Added-in: 7.19.4
 ---
 
 # NAME
@@ -60,6 +61,8 @@ the same way.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -78,9 +81,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.19.4
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_NOSIGNAL.md b/docs/libcurl/opts/CURLOPT_NOSIGNAL.md
index f2b2a3cd8..3aaac34c9 100644
--- a/docs/libcurl/opts/CURLOPT_NOSIGNAL.md
+++ b/docs/libcurl/opts/CURLOPT_NOSIGNAL.md
@@ -8,6 +8,7 @@ See-also:
   - CURLOPT_TIMEOUT (3)
 Protocol:
   - All
+Added-in: 7.10
 ---
 
 # NAME
@@ -46,6 +47,8 @@ corner cases when they may still happen, contrary to our desire.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -65,9 +68,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_OPENSOCKETDATA.md b/docs/libcurl/opts/CURLOPT_OPENSOCKETDATA.md
index 5118ffe96..1a73f2f14 100644
--- a/docs/libcurl/opts/CURLOPT_OPENSOCKETDATA.md
+++ b/docs/libcurl/opts/CURLOPT_OPENSOCKETDATA.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_SOCKOPTFUNCTION (3)
 Protocol:
   - All
+Added-in: 7.17.1
 ---
 
 # NAME
@@ -32,7 +33,9 @@ CURLOPT_OPENSOCKETFUNCTION(3).
 
 # DEFAULT
 
-The default value of this parameter is NULL.
+NULL
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -81,9 +84,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.17.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_OPENSOCKETFUNCTION.md b/docs/libcurl/opts/CURLOPT_OPENSOCKETFUNCTION.md
index 554ac8822..47bb7e132 100644
--- a/docs/libcurl/opts/CURLOPT_OPENSOCKETFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_OPENSOCKETFUNCTION.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_SOCKOPTFUNCTION (3)
 Protocol:
   - All
+Added-in: 7.17.1
 ---
 
 # NAME
@@ -70,11 +71,13 @@ CURLOPT_SOCKOPTFUNCTION(3) to signal that it already is connected.
 
 # DEFAULT
 
-The default behavior is the equivalent of this:
+The equivalent of this:
 ~~~c
    return socket(addr->family, addr->socktype, addr->protocol);
 ~~~
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -121,9 +124,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.17.1.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PASSWORD.md b/docs/libcurl/opts/CURLOPT_PASSWORD.md
index 3aa4489b6..94d90d0dc 100644
--- a/docs/libcurl/opts/CURLOPT_PASSWORD.md
+++ b/docs/libcurl/opts/CURLOPT_PASSWORD.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_USERPWD (3)
 Protocol:
   - All
+Added-in: 7.19.1
 ---
 
 # NAME
@@ -40,6 +41,8 @@ option.
 
 blank
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -59,9 +62,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.19.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PATH_AS_IS.md b/docs/libcurl/opts/CURLOPT_PATH_AS_IS.md
index 0c04b862b..744de5c3f 100644
--- a/docs/libcurl/opts/CURLOPT_PATH_AS_IS.md
+++ b/docs/libcurl/opts/CURLOPT_PATH_AS_IS.md
@@ -11,6 +11,7 @@ See-also:
   - curl_url_set (3)
 Protocol:
   - All
+Added-in: 7.42.0
 ---
 
 # NAME
@@ -47,6 +48,8 @@ The corresponding flag for the curl_url_set(3) function is called
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.42.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PINNEDPUBLICKEY.md b/docs/libcurl/opts/CURLOPT_PINNEDPUBLICKEY.md
index 357f387ef..10c7100cb 100644
--- a/docs/libcurl/opts/CURLOPT_PINNEDPUBLICKEY.md
+++ b/docs/libcurl/opts/CURLOPT_PINNEDPUBLICKEY.md
@@ -18,6 +18,7 @@ TLS-backend:
   - mbedTLS
   - Secure Transport
   - Schannel
+Added-in: 7.39.0
 ---
 
 # NAME
@@ -57,6 +58,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -116,7 +119,7 @@ footer:
 -----END PUBLIC KEY-----
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 ## PEM/DER support
 
@@ -142,6 +145,8 @@ footer:
 
 Other SSL backends not supported.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if TLS enabled, CURLE_UNKNOWN_OPTION if not, or
diff --git a/docs/libcurl/opts/CURLOPT_PIPEWAIT.md b/docs/libcurl/opts/CURLOPT_PIPEWAIT.md
index 6fdbcee84..8226791d4 100644
--- a/docs/libcurl/opts/CURLOPT_PIPEWAIT.md
+++ b/docs/libcurl/opts/CURLOPT_PIPEWAIT.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_FRESH_CONNECT (3)
 Protocol:
   - HTTP
+Added-in: 7.43.0
 ---
 
 # NAME
@@ -52,6 +53,8 @@ and support level.
 
 0 (off)
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -67,9 +70,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.43.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PORT.md b/docs/libcurl/opts/CURLOPT_PORT.md
index 15d57f503..812311bfd 100644
--- a/docs/libcurl/opts/CURLOPT_PORT.md
+++ b/docs/libcurl/opts/CURLOPT_PORT.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_URL (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -42,8 +43,10 @@ and therefore using a port number lower than zero or over 65535 causes a
 
 # DEFAULT
 
-By default this is 0 which makes it not used. This also makes port number zero
-impossible to set with this API.
+0 which makes it not used. This also makes port number zero impossible to set
+with this API.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -61,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_POST.md b/docs/libcurl/opts/CURLOPT_POST.md
index b2aef4f30..fe4656f17 100644
--- a/docs/libcurl/opts/CURLOPT_POST.md
+++ b/docs/libcurl/opts/CURLOPT_POST.md
@@ -9,7 +9,8 @@ Protocol:
 See-also:
   - CURLOPT_HTTPPOST (3)
   - CURLOPT_POSTFIELDS (3)
-  - CURLOPT_PUT (3)
+  - CURLOPT_UPLOAD (3)
+Added-in: 7.1
 ---
 
 # NAME
@@ -71,6 +72,8 @@ you should set a new request type explicitly as described above.
 
 0, disabled
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -91,9 +94,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with HTTP
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_POSTFIELDS.md b/docs/libcurl/opts/CURLOPT_POSTFIELDS.md
index 11f64d7f7..edd932c4e 100644
--- a/docs/libcurl/opts/CURLOPT_POSTFIELDS.md
+++ b/docs/libcurl/opts/CURLOPT_POSTFIELDS.md
@@ -13,6 +13,7 @@ See-also:
 Protocol:
   - HTTP
   - MQTT
+Added-in: 7.1
 ---
 
 # NAME
@@ -73,6 +74,8 @@ CURLOPT_MIMEPOST(3) option combined with curl_mime_init(3).
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -115,9 +118,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_POSTFIELDSIZE.md b/docs/libcurl/opts/CURLOPT_POSTFIELDSIZE.md
index 6fa83fdef..b23a486a3 100644
--- a/docs/libcurl/opts/CURLOPT_POSTFIELDSIZE.md
+++ b/docs/libcurl/opts/CURLOPT_POSTFIELDSIZE.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_POSTFIELDSIZE_LARGE (3)
 Protocol:
   - HTTP
+Added-in: 7.2
 ---
 
 # NAME
@@ -37,6 +38,8 @@ If you post more than 2GB, use CURLOPT_POSTFIELDSIZE_LARGE(3).
 
 -1
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with HTTP
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_POSTFIELDSIZE_LARGE.md b/docs/libcurl/opts/CURLOPT_POSTFIELDSIZE_LARGE.md
index a7adceca5..d06bf1a7e 100644
--- a/docs/libcurl/opts/CURLOPT_POSTFIELDSIZE_LARGE.md
+++ b/docs/libcurl/opts/CURLOPT_POSTFIELDSIZE_LARGE.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_POSTFIELDSIZE (3)
 Protocol:
   - HTTP
+Added-in: 7.11.1
 ---
 
 # NAME
@@ -37,6 +38,8 @@ CURLOPT_READFUNCTION(3) (if used) to signal the end of data.
 
 -1
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -61,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with HTTP
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_POSTQUOTE.md b/docs/libcurl/opts/CURLOPT_POSTQUOTE.md
index fbd55fc50..58c4d8710 100644
--- a/docs/libcurl/opts/CURLOPT_POSTQUOTE.md
+++ b/docs/libcurl/opts/CURLOPT_POSTQUOTE.md
@@ -10,6 +10,7 @@ See-also:
 Protocol:
   - FTP
   - SFTP
+Added-in: 7.1
 ---
 
 # NAME
@@ -38,6 +39,8 @@ Disable this operation again by setting a NULL to this option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -62,9 +65,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-If support for the protocols are built-in.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_POSTREDIR.md b/docs/libcurl/opts/CURLOPT_POSTREDIR.md
index 4f63fd1cd..c56ba990a 100644
--- a/docs/libcurl/opts/CURLOPT_POSTREDIR.md
+++ b/docs/libcurl/opts/CURLOPT_POSTREDIR.md
@@ -12,6 +12,7 @@ See-also:
   - CURLOPT_POSTFIELDS (3)
 Protocol:
   - HTTP
+Added-in: 7.19.1
 ---
 
 # NAME
@@ -48,6 +49,8 @@ when setting CURLOPT_FOLLOWLOCATION(3).
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -69,10 +72,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
+
+This option was known as CURLOPT_POST301 up to 7.19.0 as it only supported the
+301 then. CURL_REDIR_POST_303 was added in 7.26.0.
 
-Added in 7.17.1. This option was known as CURLOPT_POST301 up to 7.19.0 as it
-only supported the 301 then. CURL_REDIR_POST_303 was added in 7.26.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PREQUOTE.md b/docs/libcurl/opts/CURLOPT_PREQUOTE.md
index 887845875..5291edf06 100644
--- a/docs/libcurl/opts/CURLOPT_PREQUOTE.md
+++ b/docs/libcurl/opts/CURLOPT_PREQUOTE.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_QUOTE (3)
 Protocol:
   - FTP
+Added-in: 7.9.5
 ---
 
 # NAME
@@ -42,6 +43,8 @@ this option does not.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -65,9 +68,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with the protocol support
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PREREQDATA.md b/docs/libcurl/opts/CURLOPT_PREREQDATA.md
index 821451bed..f94ecc6fc 100644
--- a/docs/libcurl/opts/CURLOPT_PREREQDATA.md
+++ b/docs/libcurl/opts/CURLOPT_PREREQDATA.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_PREREQFUNCTION (3)
 Protocol:
   - All
+Added-in: 7.80.0
 ---
 
 # NAME
@@ -33,6 +34,8 @@ argument in the pre-request callback set with CURLOPT_PREREQFUNCTION(3).
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -62,9 +65,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.80.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PREREQFUNCTION.md b/docs/libcurl/opts/CURLOPT_PREREQFUNCTION.md
index 0ddd412b9..8024a9a89 100644
--- a/docs/libcurl/opts/CURLOPT_PREREQFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_PREREQFUNCTION.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_PREREQDATA (3)
 Protocol:
   - All
+Added-in: 7.80.0
 ---
 
 # NAME
@@ -83,7 +84,9 @@ The pointer you set with CURLOPT_PREREQDATA(3).
 
 # DEFAULT
 
-By default, this is NULL and unused.
+NULL
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -114,9 +117,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.80.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PRE_PROXY.md b/docs/libcurl/opts/CURLOPT_PRE_PROXY.md
index 746a80833..f6e5dbff0 100644
--- a/docs/libcurl/opts/CURLOPT_PRE_PROXY.md
+++ b/docs/libcurl/opts/CURLOPT_PRE_PROXY.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_PROXY (3)
 Protocol:
   - All
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -47,15 +48,17 @@ be used. Otherwise SOCKS4 is used as default.
 Setting the pre proxy string to "" (an empty string) explicitly disables the
 use of a pre proxy.
 
+When you set a hostname to use, do not assume that there is any particular
+single port number used widely for proxies. Specify it.
+
 The application does not have to keep the string around after setting this
 option.
 
 # DEFAULT
 
-Default is NULL, meaning no pre proxy is used.
+NULL
 
-When you set a hostname to use, do not assume that there is any particular
-single port number used widely for proxies. Specify it!
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -72,9 +75,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PRIVATE.md b/docs/libcurl/opts/CURLOPT_PRIVATE.md
index 0af8fc2e8..580ba243d 100644
--- a/docs/libcurl/opts/CURLOPT_PRIVATE.md
+++ b/docs/libcurl/opts/CURLOPT_PRIVATE.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_VERBOSE (3)
 Protocol:
   - All
+Added-in: 7.10.3
 ---
 
 # NAME
@@ -35,6 +36,8 @@ never does anything with this data.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -61,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10.3
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROGRESSDATA.md b/docs/libcurl/opts/CURLOPT_PROGRESSDATA.md
index fc915750b..6f501f2ee 100644
--- a/docs/libcurl/opts/CURLOPT_PROGRESSDATA.md
+++ b/docs/libcurl/opts/CURLOPT_PROGRESSDATA.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_XFERINFOFUNCTION (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -30,7 +31,9 @@ argument in the progress callback set with CURLOPT_PROGRESSFUNCTION(3).
 
 # DEFAULT
 
-The default value of this parameter is NULL.
+NULL
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -69,9 +72,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROGRESSFUNCTION.md b/docs/libcurl/opts/CURLOPT_PROGRESSFUNCTION.md
index 7bf26d637..d9a24382b 100644
--- a/docs/libcurl/opts/CURLOPT_PROGRESSFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_PROGRESSFUNCTION.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_XFERINFOFUNCTION (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -74,8 +75,9 @@ get called.
 
 # DEFAULT
 
-By default, libcurl has an internal progress meter. That is rarely wanted by
-users.
+NULL. libcurl has an internal progress meter. That is rarely wanted by users.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -114,10 +116,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
 
 Deprecated since 7.32.0.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK.
diff --git a/docs/libcurl/opts/CURLOPT_PROTOCOLS.md b/docs/libcurl/opts/CURLOPT_PROTOCOLS.md
index a63821713..e631bca9d 100644
--- a/docs/libcurl/opts/CURLOPT_PROTOCOLS.md
+++ b/docs/libcurl/opts/CURLOPT_PROTOCOLS.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_URL (3)
 Protocol:
   - All
+Added-in: 7.19.4
 ---
 
 # NAME
@@ -73,6 +74,8 @@ CURLPROTO_TFTP
 
 All protocols built-in.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -93,9 +96,11 @@ int main(int argc, char **argv)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
+
+Deprecated since 7.85.0.
 
-Added in 7.19.4. Deprecated since 7.85.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROTOCOLS_STR.md b/docs/libcurl/opts/CURLOPT_PROTOCOLS_STR.md
index f004d8d77..1015b993c 100644
--- a/docs/libcurl/opts/CURLOPT_PROTOCOLS_STR.md
+++ b/docs/libcurl/opts/CURLOPT_PROTOCOLS_STR.md
@@ -12,6 +12,7 @@ See-also:
   - curl_version_info (3)
 Protocol:
   - All
+Added-in: 7.85.0
 ---
 
 # NAME
@@ -56,6 +57,8 @@ way to figure out the protocol used in a previous transfer.
 
 All protocols built-in
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -75,9 +78,7 @@ int main(int argc, char **argv)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.85.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY.md b/docs/libcurl/opts/CURLOPT_PROXY.md
index a48f54e33..abc42d7f1 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_PROXYTYPE (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -69,15 +70,16 @@ SOCKS5 Proxy.
 
 SOCKS5 Proxy. Proxy resolves URL hostname.
 
-Without a scheme prefix, CURLOPT_PROXYTYPE(3) can be used to specify
-which kind of proxy the string identifies.
+##
+
+Without a scheme prefix, CURLOPT_PROXYTYPE(3) can be used to specify which
+kind of proxy the string identifies.
 
 When you tell the library to use an HTTP proxy, libcurl transparently converts
 operations to HTTP even if you specify an FTP URL etc. This may have an impact
-on what other features of the library you can use, such as
-CURLOPT_QUOTE(3) and similar FTP specifics that do not work unless you
-tunnel through the HTTP proxy. Such tunneling is activated with
-CURLOPT_HTTPPROXYTUNNEL(3).
+on what other features of the library you can use, such as CURLOPT_QUOTE(3)
+and similar FTP specifics that do not work unless you tunnel through the HTTP
+proxy. Such tunneling is activated with CURLOPT_HTTPPROXYTUNNEL(3).
 
 Setting the proxy string to "" (an empty string) explicitly disables the use
 of a proxy, even if there is an environment variable set for it.
@@ -88,8 +90,8 @@ user + password.
 Unix domain sockets are supported for socks proxies since 7.84.0. Set
 localhost for the host part. e.g. socks5h://localhost/path/to/socket.sock
 
-The application does not have to keep the string around after setting this
-option.
+When you set a hostname to use, do not assume that there is any particular
+single port number used widely for proxies. Specify it.
 
 When a proxy is used, the active FTP mode as set with *CUROPT_FTPPORT(3)*,
 cannot be used.
@@ -109,10 +111,9 @@ variables.
 
 # DEFAULT
 
-Default is NULL, meaning no proxy is used.
+NULL
 
-When you set a hostname to use, do not assume that there is any particular
-single port number used widely for proxies. Specify it!
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -128,7 +129,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 Since 7.14.1 the proxy environment variable names can include the protocol
 scheme.
@@ -138,6 +139,8 @@ Since 7.21.7 the proxy string supports the socks protocols as "schemes".
 Since 7.50.2, unsupported schemes in proxy strings cause libcurl to return
 error.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if proxies are supported, CURLE_UNKNOWN_OPTION if not, or
diff --git a/docs/libcurl/opts/CURLOPT_PROXYAUTH.md b/docs/libcurl/opts/CURLOPT_PROXYAUTH.md
index ca5204e5e..1609cbafa 100644
--- a/docs/libcurl/opts/CURLOPT_PROXYAUTH.md
+++ b/docs/libcurl/opts/CURLOPT_PROXYAUTH.md
@@ -12,6 +12,7 @@ See-also:
   - CURLOPT_PROXYUSERPWD (3)
 Protocol:
   - All
+Added-in: 7.10.7
 ---
 
 # NAME
@@ -43,6 +44,8 @@ CURLOPT_HTTPAUTH(3) man page.
 
 CURLAUTH_BASIC
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10.7
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXYHEADER.md b/docs/libcurl/opts/CURLOPT_PROXYHEADER.md
index 8fbb964c3..5bcd01767 100644
--- a/docs/libcurl/opts/CURLOPT_PROXYHEADER.md
+++ b/docs/libcurl/opts/CURLOPT_PROXYHEADER.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_HTTPHEADER (3)
 Protocol:
   - All
+Added-in: 7.37.0
 ---
 
 # NAME
@@ -44,6 +45,8 @@ Pass a NULL to this to reset back to no custom headers.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -69,9 +72,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.37.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXYPASSWORD.md b/docs/libcurl/opts/CURLOPT_PROXYPASSWORD.md
index f108bbf93..1b371b22c 100644
--- a/docs/libcurl/opts/CURLOPT_PROXYPASSWORD.md
+++ b/docs/libcurl/opts/CURLOPT_PROXYPASSWORD.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_PROXYUSERNAME (3)
 Protocol:
   - All
+Added-in: 7.19.1
 ---
 
 # NAME
@@ -40,6 +41,8 @@ option.
 
 blank
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -58,9 +61,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.19.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXYPORT.md b/docs/libcurl/opts/CURLOPT_PROXYPORT.md
index 2a5b796af..b0113ac0e 100644
--- a/docs/libcurl/opts/CURLOPT_PROXYPORT.md
+++ b/docs/libcurl/opts/CURLOPT_PROXYPORT.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_PROXYTYPE (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -30,15 +31,21 @@ CURLcode curl_easy_setopt(CURL *handle, CURLOPT_PROXYPORT, long port);
 We discourage use of this option.
 
 Pass a long with this option to set the proxy port to connect to unless it is
-specified in the proxy string CURLOPT_PROXY(3) or uses 443 for https
-proxies and 1080 for all others as default.
+specified in the proxy string CURLOPT_PROXY(3) or uses 443 for https proxies
+and 1080 for all others as default.
+
+Disabling this option, setting it to zero, makes it not specified which makes
+libcurl use the default proxy port number or the port number specified in the
+proxy URL string.
 
 While this accepts a 'long', the port number is 16 bit so it cannot be larger
 than 65535.
 
 # DEFAULT
 
-0, not specified which makes it use the default port
+0
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -57,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXYTYPE.md b/docs/libcurl/opts/CURLOPT_PROXYTYPE.md
index 50af1d819..dafd99603 100644
--- a/docs/libcurl/opts/CURLOPT_PROXYTYPE.md
+++ b/docs/libcurl/opts/CURLOPT_PROXYTYPE.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_PROXYPORT (3)
 Protocol:
   - All
+Added-in: 7.10
 ---
 
 # NAME
@@ -63,6 +64,8 @@ SOCKS5 Proxy.
 
 SOCKS5 Proxy. Proxy resolves URL hostname.
 
+##
+
 Often it is more convenient to specify the proxy type with the scheme part of
 the CURLOPT_PROXY(3) string.
 
@@ -70,6 +73,8 @@ the CURLOPT_PROXY(3) string.
 
 CURLPROXY_HTTP
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -88,9 +93,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXYUSERNAME.md b/docs/libcurl/opts/CURLOPT_PROXYUSERNAME.md
index a2b7b2aec..7e0b0caba 100644
--- a/docs/libcurl/opts/CURLOPT_PROXYUSERNAME.md
+++ b/docs/libcurl/opts/CURLOPT_PROXYUSERNAME.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_USERNAME (3)
 Protocol:
   - All
+Added-in: 7.19.1
 ---
 
 # NAME
@@ -43,6 +44,8 @@ option.
 
 blank
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -61,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.19.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXYUSERPWD.md b/docs/libcurl/opts/CURLOPT_PROXYUSERPWD.md
index 315761647..38b1288eb 100644
--- a/docs/libcurl/opts/CURLOPT_PROXYUSERPWD.md
+++ b/docs/libcurl/opts/CURLOPT_PROXYUSERPWD.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_PROXYUSERNAME (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -40,7 +41,9 @@ option.
 
 # DEFAULT
 
-This is NULL by default.
+NULL
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -59,9 +62,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_CAINFO.md b/docs/libcurl/opts/CURLOPT_PROXY_CAINFO.md
index 82b136170..ed0b5e6b3 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_CAINFO.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_CAINFO.md
@@ -18,6 +18,7 @@ Protocol:
   - TLS
 TLS-backend:
   - All
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -61,6 +62,8 @@ The default value for this can be figured out with CURLINFO_CAINFO(3).
 
 Built-in system specific
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -79,14 +82,14 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0
+# NOTES
 
 For TLS backends that do not support certificate files, the
 CURLOPT_PROXY_CAINFO(3) option is ignored. Refer to
 https://curl.se/docs/ssl-compared.html
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, CURLE_UNKNOWN_OPTION if not, or
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_CAINFO_BLOB.md b/docs/libcurl/opts/CURLOPT_PROXY_CAINFO_BLOB.md
index dff93aab4..91ef9a7c8 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_CAINFO_BLOB.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_CAINFO_BLOB.md
@@ -21,6 +21,7 @@ TLS-backend:
   - rustls
   - Secure Transport
   - Schannel
+Added-in: 7.77.0
 ---
 
 # NAME
@@ -57,6 +58,8 @@ This option overrides CURLOPT_PROXY_CAINFO(3).
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -82,12 +85,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.77.0.
-
-This option is supported by the rustls (since 7.82.0), OpenSSL, Secure
-Transport and Schannel backends.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_CAPATH.md b/docs/libcurl/opts/CURLOPT_PROXY_CAPATH.md
index 4a4f46d14..fe680df09 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_CAPATH.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_CAPATH.md
@@ -16,6 +16,7 @@ TLS-backend:
   - OpenSSL
   - GnuTLS
   - mbedTLS
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -47,6 +48,8 @@ The default value for this can be figured out with CURLINFO_CAPATH(3).
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -65,11 +68,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0
-
-mbedTLS support added in 7.56.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_CRLFILE.md b/docs/libcurl/opts/CURLOPT_PROXY_CRLFILE.md
index 498259756..f0cb86db1 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_CRLFILE.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_CRLFILE.md
@@ -15,6 +15,7 @@ TLS-backend:
   - GnuTLS
   - mbedTLS
   - OpenSSL
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -58,6 +59,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -75,9 +78,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_ISSUERCERT.md b/docs/libcurl/opts/CURLOPT_PROXY_ISSUERCERT.md
index 33714c9e1..954848b86 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_ISSUERCERT.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_ISSUERCERT.md
@@ -15,6 +15,7 @@ Protocol:
 TLS-backend:
   - OpenSSL
   - GnuTLS
+Added-in: 7.71.0
 ---
 
 # NAME
@@ -55,6 +56,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -73,9 +76,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.71.0. This option is supported by the OpenSSL and GnuTLS backends.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_ISSUERCERT_BLOB.md b/docs/libcurl/opts/CURLOPT_PROXY_ISSUERCERT_BLOB.md
index d8bcf09e6..002704fce 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_ISSUERCERT_BLOB.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_ISSUERCERT_BLOB.md
@@ -14,6 +14,7 @@ Protocol:
   - TLS
 TLS-backend:
   - OpenSSL
+Added-in: 7.71.0
 ---
 
 # NAME
@@ -59,6 +60,8 @@ instead expects a filename as input.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -85,9 +88,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.71.0. This option is supported by the OpenSSL backends.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_KEYPASSWD.md b/docs/libcurl/opts/CURLOPT_PROXY_KEYPASSWD.md
index cb1e4beca..1d7e2b050 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_KEYPASSWD.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_KEYPASSWD.md
@@ -16,6 +16,7 @@ TLS-backend:
   - mbedTLS
   - Schannel
   - wolfSSL
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -35,9 +36,9 @@ CURLcode curl_easy_setopt(CURL *handle, CURLOPT_PROXY_KEYPASSWD, char *pwd);
 This option is for connecting to an HTTPS proxy, not an HTTPS server.
 
 Pass a pointer to a null-terminated string as parameter. It is used as the
-password required to use the CURLOPT_PROXY_SSLKEY(3) private key. You
-never need a pass phrase to load a certificate but you need one to load your
-private key.
+password required to use the CURLOPT_PROXY_SSLKEY(3) private key. You never
+need a passphrase to load a certificate but you need one to load your private
+key.
 
 The application does not have to keep the string around after setting this
 option.
@@ -46,6 +47,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -63,9 +66,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_PINNEDPUBLICKEY.md b/docs/libcurl/opts/CURLOPT_PROXY_PINNEDPUBLICKEY.md
index a1a74258e..c2113a930 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_PINNEDPUBLICKEY.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_PINNEDPUBLICKEY.md
@@ -17,6 +17,7 @@ TLS-backend:
   - GnuTLS
   - mbedTLS
   - wolfSSL
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -53,6 +54,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -109,7 +112,7 @@ footer:
 -----END PUBLIC KEY-----
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 PEM/DER support:
 
@@ -121,6 +124,8 @@ sha256 support:
 
 Other SSL backends not supported.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if TLS enabled, CURLE_UNKNOWN_OPTION if not, or
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_SERVICE_NAME.md b/docs/libcurl/opts/CURLOPT_PROXY_SERVICE_NAME.md
index d1b9dd95b..b224557e1 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_SERVICE_NAME.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_SERVICE_NAME.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_SERVICE_NAME (3)
 Protocol:
   - All
+Added-in: 7.43.0
 ---
 
 # NAME
@@ -38,6 +39,8 @@ option.
 
 See above
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -53,9 +56,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.43.0 for HTTP proxies, 7.49.0 for SOCKS5 proxies.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_SSLCERT.md b/docs/libcurl/opts/CURLOPT_PROXY_SSLCERT.md
index 4b510b264..1e8555ae1 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_SSLCERT.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_SSLCERT.md
@@ -17,6 +17,7 @@ TLS-backend:
   - Schannel
   - Secure Transport
   - wolfSSL
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -55,6 +56,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -74,9 +77,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_SSLCERTTYPE.md b/docs/libcurl/opts/CURLOPT_PROXY_SSLCERTTYPE.md
index f14b73a19..5002b3a11 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_SSLCERTTYPE.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_SSLCERTTYPE.md
@@ -17,6 +17,7 @@ TLS-backend:
   - Schannel
   - Secure Transport
   - wolfSSL
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -48,6 +49,8 @@ option.
 
 "PEM"
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -68,11 +71,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0
-
-If built TLS enabled.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_SSLCERT_BLOB.md b/docs/libcurl/opts/CURLOPT_PROXY_SSLCERT_BLOB.md
index 05a41b9e7..2abbbb4df 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_SSLCERT_BLOB.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_SSLCERT_BLOB.md
@@ -15,6 +15,7 @@ TLS-backend:
   - OpenSSL
   - Schannel
   - Secure Transport
+Added-in: 7.71.0
 ---
 
 # NAME
@@ -49,6 +50,8 @@ expects a filename as input.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -76,9 +79,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.71.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_SSLKEY.md b/docs/libcurl/opts/CURLOPT_PROXY_SSLKEY.md
index e954969ea..c355c947c 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_SSLKEY.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_SSLKEY.md
@@ -17,6 +17,7 @@ TLS-backend:
   - mbedTLS
   - Schannel
   - wolfSSL
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -49,6 +50,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -68,11 +71,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0
-
-If built TLS enabled.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_SSLKEYTYPE.md b/docs/libcurl/opts/CURLOPT_PROXY_SSLKEYTYPE.md
index 16ddd035f..b59ee2623 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_SSLKEYTYPE.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_SSLKEYTYPE.md
@@ -14,6 +14,7 @@ TLS-backend:
   - OpenSSL
   - BearSSL
   - wolfSSL
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -38,6 +39,8 @@ the format of your private key. Supported formats are "PEM", "DER" and "ENG".
 The application does not have to keep the string around after setting this
 option.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -58,9 +61,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_SSLKEY_BLOB.md b/docs/libcurl/opts/CURLOPT_PROXY_SSLKEY_BLOB.md
index 7f3554442..06ccac498 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_SSLKEY_BLOB.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_SSLKEY_BLOB.md
@@ -12,6 +12,7 @@ Protocol:
   - TLS
 TLS-backend:
   - OpenSSL
+Added-in: 7.71.0
 ---
 
 # NAME
@@ -42,6 +43,8 @@ setting this.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -76,9 +79,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.71.0. This option is supported by the OpenSSL backends.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_SSLVERSION.md b/docs/libcurl/opts/CURLOPT_PROXY_SSLVERSION.md
index 9fb935f24..1b1795210 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_SSLVERSION.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_SSLVERSION.md
@@ -13,6 +13,7 @@ Protocol:
   - TLS
 TLS-backend:
   - All
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -59,10 +60,13 @@ TLSv1.2
 ## CURL_SSLVERSION_TLSv1_3
 
 TLSv1.3
-The maximum TLS version can be set by using *one* of the
-CURL_SSLVERSION_MAX_ macros below. It is also possible to OR *one* of the
-CURL_SSLVERSION_ macros with *one* of the CURL_SSLVERSION_MAX_ macros.
-The MAX macros are not supported for WolfSSL.
+
+##
+
+The maximum TLS version can be set by using *one* of the CURL_SSLVERSION_MAX_
+macros below. It is also possible to OR *one* of the CURL_SSLVERSION_ macros
+with *one* of the CURL_SSLVERSION_MAX_ macros. The MAX macros are not
+supported for wolfSSL.
 
 ## CURL_SSLVERSION_MAX_DEFAULT
 
@@ -90,6 +94,8 @@ The flag defines maximum supported TLS version as TLSv1.2.
 The flag defines maximum supported TLS version as TLSv1.3.
 (Added in 7.54.0)
 
+##
+
 In versions of curl prior to 7.54 the CURL_SSLVERSION_TLS options were
 documented to allow *only* the specified TLS version, but behavior was
 inconsistent depending on the TLS library.
@@ -98,6 +104,8 @@ inconsistent depending on the TLS library.
 
 CURL_SSLVERSION_DEFAULT
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -116,9 +124,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_SSL_CIPHER_LIST.md b/docs/libcurl/opts/CURLOPT_PROXY_SSL_CIPHER_LIST.md
index 06080f380..0c64abbc9 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_SSL_CIPHER_LIST.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_SSL_CIPHER_LIST.md
@@ -20,6 +20,7 @@ TLS-backend:
   - wolfSSL
   - GnuTLS
   - mbedTLS
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -47,7 +48,7 @@ For OpenSSL and GnuTLS valid examples of cipher lists include **RC4-SHA**,
 **SHA1+DES**, **TLSv1** and **DEFAULT**. The default list is normally
 set when you compile OpenSSL.
 
-For WolfSSL, valid examples of cipher lists include **ECDHE-RSA-RC4-SHA**,
+For wolfSSL, valid examples of cipher lists include **ECDHE-RSA-RC4-SHA**,
 **AES256-SHA:AES256-SHA256**, etc.
 
 For mbedTLS and BearSSL, valid examples of cipher lists include
@@ -67,7 +68,9 @@ option.
 
 # DEFAULT
 
-NULL, use internal default
+NULL, use internal built-in list.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -86,11 +89,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0, in 7.83.0 for BearSSL, in 8.8.0 for mbedTLS
-
-If built TLS enabled.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_SSL_OPTIONS.md b/docs/libcurl/opts/CURLOPT_PROXY_SSL_OPTIONS.md
index 541b13cb8..02bc267c9 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_SSL_OPTIONS.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_SSL_OPTIONS.md
@@ -13,6 +13,7 @@ Protocol:
   - TLS
 TLS-backend:
   - All
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -91,6 +92,8 @@ could be a privacy violation and unexpected.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -110,9 +113,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_SSL_VERIFYHOST.md b/docs/libcurl/opts/CURLOPT_PROXY_SSL_VERIFYHOST.md
index 01cbdb913..d97cd74bf 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_SSL_VERIFYHOST.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_SSL_VERIFYHOST.md
@@ -13,6 +13,7 @@ Protocol:
   - TLS
 TLS-backend:
   - All
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -64,6 +65,8 @@ of the proxy certificate.
 
 2
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -81,11 +84,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0.
-
-If built TLS enabled.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_SSL_VERIFYPEER.md b/docs/libcurl/opts/CURLOPT_PROXY_SSL_VERIFYPEER.md
index 86afeb72b..b29a4235f 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_SSL_VERIFYPEER.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_SSL_VERIFYPEER.md
@@ -12,6 +12,7 @@ Protocol:
   - TLS
 TLS-backend:
   - All
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -66,6 +67,8 @@ the correct end-point.
 
 1
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -83,11 +86,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0
-
-If built TLS enabled.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_TLS13_CIPHERS.md b/docs/libcurl/opts/CURLOPT_PROXY_TLS13_CIPHERS.md
index 626f088ef..42a871d09 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_TLS13_CIPHERS.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_TLS13_CIPHERS.md
@@ -15,6 +15,7 @@ Protocol:
 TLS-backend:
   - OpenSSL
   - Schannel
+Added-in: 7.61.0
 ---
 
 # NAME
@@ -50,7 +51,9 @@ option.
 
 # DEFAULT
 
-NULL, use internal default
+NULL, use internal built-in list
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -69,10 +72,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.61.0.
-Available when built with OpenSSL \>= 1.1.1.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_TLSAUTH_PASSWORD.md b/docs/libcurl/opts/CURLOPT_PROXY_TLSAUTH_PASSWORD.md
index e45f69e9b..edff372af 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_TLSAUTH_PASSWORD.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_TLSAUTH_PASSWORD.md
@@ -14,6 +14,7 @@ Protocol:
 TLS-backend:
   - OpenSSL
   - GnuTLS
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -43,6 +44,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -62,9 +65,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_TLSAUTH_TYPE.md b/docs/libcurl/opts/CURLOPT_PROXY_TLSAUTH_TYPE.md
index a10d78c5e..f67edd9f5 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_TLSAUTH_TYPE.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_TLSAUTH_TYPE.md
@@ -14,6 +14,7 @@ Protocol:
 TLS-backend:
   - OpenSSL
   - GnuTLS
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -40,16 +41,15 @@ method is "SRP".
 TLS-SRP authentication. Secure Remote Password authentication for TLS is
 defined in RFC 5054 and provides mutual authentication if both sides have a
 shared secret. To use TLS-SRP, you must also set the
-CURLOPT_PROXY_TLSAUTH_USERNAME(3) and
-CURLOPT_PROXY_TLSAUTH_PASSWORD(3) options.
-
-The application does not have to keep the string around after setting this
-option.
+CURLOPT_PROXY_TLSAUTH_USERNAME(3) and CURLOPT_PROXY_TLSAUTH_PASSWORD(3)
+options.
 
 # DEFAULT
 
 blank
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -69,12 +69,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0
-
-You need to build libcurl with GnuTLS or OpenSSL with TLS-SRP support for this
-to work.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_TLSAUTH_USERNAME.md b/docs/libcurl/opts/CURLOPT_PROXY_TLSAUTH_USERNAME.md
index 8d7b221b8..db66735ad 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_TLSAUTH_USERNAME.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_TLSAUTH_USERNAME.md
@@ -14,6 +14,7 @@ Protocol:
 TLS-backend:
   - OpenSSL
   - GnuTLS
+Added-in: 7.52.0
 ---
 
 # NAME
@@ -43,6 +44,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -62,9 +65,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.52.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PROXY_TRANSFER_MODE.md b/docs/libcurl/opts/CURLOPT_PROXY_TRANSFER_MODE.md
index 5daf5df37..a0ac94912 100644
--- a/docs/libcurl/opts/CURLOPT_PROXY_TRANSFER_MODE.md
+++ b/docs/libcurl/opts/CURLOPT_PROXY_TRANSFER_MODE.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_TRANSFERTEXT (3)
 Protocol:
     - All
+Added-in: 7.18.0
 ---
 
 # NAME
@@ -38,6 +39,8 @@ doing FTP via a proxy. Beware that not all proxies support this feature.
 
 0, disabled
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,9 +60,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.18.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_PUT.md b/docs/libcurl/opts/CURLOPT_PUT.md
index 6eb3a6bb1..43bf645de 100644
--- a/docs/libcurl/opts/CURLOPT_PUT.md
+++ b/docs/libcurl/opts/CURLOPT_PUT.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_UPLOAD (3)
 Protocol:
   - HTTP
+Added-in: 7.1
 ---
 
 # NAME
@@ -37,6 +38,8 @@ This option is **deprecated** since version 7.12.1. Use CURLOPT_UPLOAD(3).
 
 0, disabled
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -78,9 +81,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
+
+Deprecated since 7.12.1.
 
-Deprecated since 7.12.1. Do not use.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_QUICK_EXIT.md b/docs/libcurl/opts/CURLOPT_QUICK_EXIT.md
index 3e0d64ced..e13b43ca0 100644
--- a/docs/libcurl/opts/CURLOPT_QUICK_EXIT.md
+++ b/docs/libcurl/opts/CURLOPT_QUICK_EXIT.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_RESOLVE (3)
 Protocol:
   - All
+Added-in: 7.87.0
 ---
 
 # NAME
@@ -37,6 +38,8 @@ possible (though short-lived) leak of associated resources.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -51,9 +54,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.87.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_QUOTE.md b/docs/libcurl/opts/CURLOPT_QUOTE.md
index 4bdc1913c..58742b7b3 100644
--- a/docs/libcurl/opts/CURLOPT_QUOTE.md
+++ b/docs/libcurl/opts/CURLOPT_QUOTE.md
@@ -12,6 +12,7 @@ See-also:
 Protocol:
   - FTP
   - SFTP
+Added-in: 7.1
 ---
 
 # NAME
@@ -127,6 +128,8 @@ See ln.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -151,10 +154,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 SFTP support added in 7.16.3. *-prefix for SFTP added in 7.24.0
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK
diff --git a/docs/libcurl/opts/CURLOPT_RANDOM_FILE.md b/docs/libcurl/opts/CURLOPT_RANDOM_FILE.md
index 83a983172..41cc75f20 100644
--- a/docs/libcurl/opts/CURLOPT_RANDOM_FILE.md
+++ b/docs/libcurl/opts/CURLOPT_RANDOM_FILE.md
@@ -10,6 +10,7 @@ Protocol:
   - TLS
 TLS-backend:
   - OpenSSL
+Added-in: 7.7
 ---
 
 # NAME
@@ -32,9 +33,11 @@ Deprecated option. It serves no purpose anymore.
 
 NULL, not used
 
-# AVAILABILITY
+# DEPRECATED
 
-This option was deprecated in 7.84.0.
+Deprecated since 7.84.0.
+
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_RANGE.md b/docs/libcurl/opts/CURLOPT_RANGE.md
index 0a8343db3..417e77022 100644
--- a/docs/libcurl/opts/CURLOPT_RANGE.md
+++ b/docs/libcurl/opts/CURLOPT_RANGE.md
@@ -15,6 +15,7 @@ Protocol:
   - FILE
   - RTSP
   - SFTP
+Added-in: 7.1
 ---
 
 # NAME
@@ -58,6 +59,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -76,10 +79,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 FILE since 7.18.0, RTSP since 7.20.0
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK on success or
diff --git a/docs/libcurl/opts/CURLOPT_READDATA.md b/docs/libcurl/opts/CURLOPT_READDATA.md
index 20eb3c6d4..ae3ac3c48 100644
--- a/docs/libcurl/opts/CURLOPT_READDATA.md
+++ b/docs/libcurl/opts/CURLOPT_READDATA.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_WRITEFUNCTION (3)
 Protocol:
   - All
+Added-in: 7.9.7
 ---
 
 # NAME
@@ -40,7 +41,9 @@ might experience crashes.
 
 # DEFAULT
 
-By default, this is a FILE * to stdin.
+stdin
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -65,11 +68,13 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 This option was once known by the older name CURLOPT_INFILE, the name
 CURLOPT_READDATA(3) was introduced in 7.9.7.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 This returns CURLE_OK.
diff --git a/docs/libcurl/opts/CURLOPT_READFUNCTION.md b/docs/libcurl/opts/CURLOPT_READFUNCTION.md
index 06d2e638a..72e9e75bf 100644
--- a/docs/libcurl/opts/CURLOPT_READFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_READFUNCTION.md
@@ -13,6 +13,7 @@ See-also:
   - CURLOPT_WRITEFUNCTION (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -72,7 +73,9 @@ and it allows for better error checking.
 
 # DEFAULT
 
-The default internal read callback is fread().
+fread(3)
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -111,11 +114,13 @@ int main(int argc, char **argv)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 CURL_READFUNC_PAUSE return code was added in 7.18.0 and CURL_READFUNC_ABORT
 was added in 7.12.1.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 This returns CURLE_OK.
diff --git a/docs/libcurl/opts/CURLOPT_REDIR_PROTOCOLS.md b/docs/libcurl/opts/CURLOPT_REDIR_PROTOCOLS.md
index df6cb7163..278e4dcd0 100644
--- a/docs/libcurl/opts/CURLOPT_REDIR_PROTOCOLS.md
+++ b/docs/libcurl/opts/CURLOPT_REDIR_PROTOCOLS.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_REDIR_PROTOCOLS_STR (3)
 Protocol:
   - HTTP
+Added-in: 7.19.4
 ---
 
 # NAME
@@ -83,6 +84,8 @@ HTTP, HTTPS, FTP and FTPS (Added in 7.65.2).
 Older versions defaulted to all protocols except FILE, SCP and since 7.40.0
 SMB and SMBS.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -103,10 +106,11 @@ int main(int argc, char **argv)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
+
+Deprecated since 7.85.0.
 
-Added in 7.19.4, before then it would follow all protocols. Deprecated
-since 7.85.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_REDIR_PROTOCOLS_STR.md b/docs/libcurl/opts/CURLOPT_REDIR_PROTOCOLS_STR.md
index 69c2e7c9f..ea3a78cab 100644
--- a/docs/libcurl/opts/CURLOPT_REDIR_PROTOCOLS_STR.md
+++ b/docs/libcurl/opts/CURLOPT_REDIR_PROTOCOLS_STR.md
@@ -12,6 +12,7 @@ See-also:
   - CURLOPT_REDIR_PROTOCOLS (3)
 Protocol:
   - HTTP
+Added-in: 7.85.0
 ---
 
 # NAME
@@ -62,6 +63,8 @@ HTTP, HTTPS, FTP and FTPS (Added in 7.65.2).
 Older versions defaulted to all protocols except FILE, SCP and since 7.40.0
 SMB and SMBS.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -81,9 +84,7 @@ int main(int argc, char **argv)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.85.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_REFERER.md b/docs/libcurl/opts/CURLOPT_REFERER.md
index f5ac9a8b3..e4054e4ab 100644
--- a/docs/libcurl/opts/CURLOPT_REFERER.md
+++ b/docs/libcurl/opts/CURLOPT_REFERER.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_USERAGENT (3)
 Protocol:
   - HTTP
+Added-in: 7.1
 ---
 
 # NAME
@@ -38,6 +39,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -55,9 +58,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-If built with HTTP support
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_REQUEST_TARGET.md b/docs/libcurl/opts/CURLOPT_REQUEST_TARGET.md
index 582b88fa1..c96f0c352 100644
--- a/docs/libcurl/opts/CURLOPT_REQUEST_TARGET.md
+++ b/docs/libcurl/opts/CURLOPT_REQUEST_TARGET.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_URL (3)
 Protocol:
   - HTTP
+Added-in: 7.55.0
 ---
 
 # NAME
@@ -37,6 +38,8 @@ other safe guards. That includes white space and control characters.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -56,9 +59,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.55.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_RESOLVE.md b/docs/libcurl/opts/CURLOPT_RESOLVE.md
index 800e3a82d..f290a1c02 100644
--- a/docs/libcurl/opts/CURLOPT_RESOLVE.md
+++ b/docs/libcurl/opts/CURLOPT_RESOLVE.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_IPRESOLVE (3)
 Protocol:
   - All
+Added-in: 7.21.3
 ---
 
 # NAME
@@ -45,13 +46,17 @@ numerical IP addresses. If you specify multiple IP addresses they need to be
 separated by comma. If libcurl is built to support IPv6, each of the ADDRESS
 entries can of course be either IPv4 or IPv6 style addressing.
 
+Specify the host as a single ampersand (`*`) to match all names. This wildcard
+is resolved last so any resolve with a specific host and port number is given
+priority.
+
 This option effectively populates the DNS cache with entries for the host+port
 pair so redirects and everything that operations against the HOST+PORT instead
 use your provided ADDRESS.
 
-The optional leading "+" specifies that the new entry should time-out. Entries
-added without the leading plus character never times out whereas entries added
-with "+HOST:..." times out just like ordinary DNS cache entries.
+The optional leading plus (`+`) specifies that the new entry should timeout.
+Entries added without the leading plus character never times out whereas
+entries added with `+HOST:...` times out just like ordinary DNS cache entries.
 
 If the DNS cache already has an entry for the given host+port pair, the new
 entry overrides the former one.
@@ -62,7 +67,7 @@ setting of CURLOPT_IPRESOLVE(3) to a different IP version.
 To remove names from the DNS cache again, to stop providing these fake
 resolves, include a string in the linked list that uses the format
 
-~~~c
+~~~
   -HOST:PORT
 ~~~
 
@@ -73,6 +78,8 @@ number must exactly match what was added previously.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -97,7 +104,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 Added in 7.21.3. Removal support added in 7.42.0.
 
@@ -108,6 +115,8 @@ Support for providing multiple IP addresses per entry was added in 7.59.0.
 Support for adding non-permanent entries by using the "+" prefix was added in
 7.75.0.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, and CURLE_UNKNOWN_OPTION if not.
diff --git a/docs/libcurl/opts/CURLOPT_RESOLVER_START_DATA.md b/docs/libcurl/opts/CURLOPT_RESOLVER_START_DATA.md
index f1fdc4e98..e6ec836a0 100644
--- a/docs/libcurl/opts/CURLOPT_RESOLVER_START_DATA.md
+++ b/docs/libcurl/opts/CURLOPT_RESOLVER_START_DATA.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_RESOLVER_START_FUNCTION (3)
 Protocol:
   - All
+Added-in: 7.59.0
 ---
 
 # NAME
@@ -34,6 +35,8 @@ CURLOPT_RESOLVER_START_FUNCTION(3).
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -59,9 +62,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.59.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_RESOLVER_START_FUNCTION.md b/docs/libcurl/opts/CURLOPT_RESOLVER_START_FUNCTION.md
index 3ff66168d..2be7bcde6 100644
--- a/docs/libcurl/opts/CURLOPT_RESOLVER_START_FUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_RESOLVER_START_FUNCTION.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_RESOLVER_START_DATA (3)
 Protocol:
   - All
+Added-in: 7.59.0
 ---
 
 # NAME
@@ -52,6 +53,8 @@ resolve to fail.
 
 NULL (No callback)
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -77,9 +80,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.59.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_RESUME_FROM.md b/docs/libcurl/opts/CURLOPT_RESUME_FROM.md
index 34f84e3b8..681c1ace2 100644
--- a/docs/libcurl/opts/CURLOPT_RESUME_FROM.md
+++ b/docs/libcurl/opts/CURLOPT_RESUME_FROM.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_RESUME_FROM_LARGE (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -43,6 +44,8 @@ CURLOPT_RESUME_FROM_LARGE(3) instead.
 
 0, not used
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -69,9 +72,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_RESUME_FROM_LARGE.md b/docs/libcurl/opts/CURLOPT_RESUME_FROM_LARGE.md
index 7326a3df5..061890dd8 100644
--- a/docs/libcurl/opts/CURLOPT_RESUME_FROM_LARGE.md
+++ b/docs/libcurl/opts/CURLOPT_RESUME_FROM_LARGE.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_RESUME_FROM (3)
 Protocol:
   - All
+Added-in: 7.11.0
 ---
 
 # NAME
@@ -41,6 +42,8 @@ file to the remote target file.
 
 0, not used
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -68,9 +71,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.11.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_RTSP_CLIENT_CSEQ.md b/docs/libcurl/opts/CURLOPT_RTSP_CLIENT_CSEQ.md
index a02cd85ab..7b00069e0 100644
--- a/docs/libcurl/opts/CURLOPT_RTSP_CLIENT_CSEQ.md
+++ b/docs/libcurl/opts/CURLOPT_RTSP_CLIENT_CSEQ.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_RTSP_SERVER_CSEQ (3)
 Protocol:
   - RTSP
+Added-in: 7.20.0
 ---
 
 # NAME
@@ -35,6 +36,8 @@ increments from this new number henceforth.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -51,9 +54,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.20.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_RTSP_REQUEST.md b/docs/libcurl/opts/CURLOPT_RTSP_REQUEST.md
index 1a2603486..99a94bce4 100644
--- a/docs/libcurl/opts/CURLOPT_RTSP_REQUEST.md
+++ b/docs/libcurl/opts/CURLOPT_RTSP_REQUEST.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_RTSP_STREAM_URI (3)
 Protocol:
   - RTSP
+Added-in: 7.20.0
 ---
 
 # NAME
@@ -111,6 +112,8 @@ application a chance to run.
 
 # DEFAULT
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -128,9 +131,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.20.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_RTSP_SERVER_CSEQ.md b/docs/libcurl/opts/CURLOPT_RTSP_SERVER_CSEQ.md
index 096132bb3..01ea910a7 100644
--- a/docs/libcurl/opts/CURLOPT_RTSP_SERVER_CSEQ.md
+++ b/docs/libcurl/opts/CURLOPT_RTSP_SERVER_CSEQ.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_RTSP_STREAM_URI (3)
 Protocol:
   - RTSP
+Added-in: 7.20.0
 ---
 
 # NAME
@@ -34,6 +35,8 @@ unimplemented.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -50,9 +53,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.20.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_RTSP_SESSION_ID.md b/docs/libcurl/opts/CURLOPT_RTSP_SESSION_ID.md
index 39fd1621e..7ff0f7725 100644
--- a/docs/libcurl/opts/CURLOPT_RTSP_SESSION_ID.md
+++ b/docs/libcurl/opts/CURLOPT_RTSP_SESSION_ID.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_RTSP_STREAM_URI (3)
 Protocol:
   - RTSP
+Added-in: 7.20.0
 ---
 
 # NAME
@@ -39,6 +40,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -56,9 +59,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.20.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_RTSP_STREAM_URI.md b/docs/libcurl/opts/CURLOPT_RTSP_STREAM_URI.md
index ecd2eff2a..5e06afc43 100644
--- a/docs/libcurl/opts/CURLOPT_RTSP_STREAM_URI.md
+++ b/docs/libcurl/opts/CURLOPT_RTSP_STREAM_URI.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_RTSP_TRANSPORT (3)
 Protocol:
   - RTSP
+Added-in: 7.20.0
 ---
 
 # NAME
@@ -43,6 +44,8 @@ option.
 
 "*"
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.20.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_RTSP_TRANSPORT.md b/docs/libcurl/opts/CURLOPT_RTSP_TRANSPORT.md
index da98ee900..6e28650ca 100644
--- a/docs/libcurl/opts/CURLOPT_RTSP_TRANSPORT.md
+++ b/docs/libcurl/opts/CURLOPT_RTSP_TRANSPORT.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_RTSP_SESSION_ID (3)
 Protocol:
   - RTSP
+Added-in: 7.20.0
 ---
 
 # NAME
@@ -38,6 +39,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -56,9 +59,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.20.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SASL_AUTHZID.md b/docs/libcurl/opts/CURLOPT_SASL_AUTHZID.md
index f7012f27e..751141206 100644
--- a/docs/libcurl/opts/CURLOPT_SASL_AUTHZID.md
+++ b/docs/libcurl/opts/CURLOPT_SASL_AUTHZID.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_USERPWD (3)
 Protocol:
   - IMAP
+Added-in: 7.66.0
 ---
 
 # NAME
@@ -43,6 +44,8 @@ access to, or a shared mailbox for example.
 
 blank
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -61,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.66.0. Support for OpenLDAP added in 7.82.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SASL_IR.md b/docs/libcurl/opts/CURLOPT_SASL_IR.md
index ebc4c4aff..25d849500 100644
--- a/docs/libcurl/opts/CURLOPT_SASL_IR.md
+++ b/docs/libcurl/opts/CURLOPT_SASL_IR.md
@@ -11,6 +11,7 @@ See-also:
 Protocol:
   - SMTP
   - IMAP
+Added-in: 7.31.0
 ---
 
 # NAME
@@ -46,6 +47,8 @@ SASL-IR CAPABILITY.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -62,9 +65,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.31.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SEEKDATA.md b/docs/libcurl/opts/CURLOPT_SEEKDATA.md
index e660cb6a3..fd93aacd2 100644
--- a/docs/libcurl/opts/CURLOPT_SEEKDATA.md
+++ b/docs/libcurl/opts/CURLOPT_SEEKDATA.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_STDERR (3)
 Protocol:
   - All
+Added-in: 7.18.0
 ---
 
 # NAME
@@ -34,6 +35,8 @@ CURLOPT_SEEKFUNCTION(3) option, this is the pointer you get as input.
 
 If you do not set this, NULL is passed to the callback.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -61,8 +64,6 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.18.0
+# %AVAILABILITY%
 
 # RETURN VALUE
diff --git a/docs/libcurl/opts/CURLOPT_SEEKFUNCTION.md b/docs/libcurl/opts/CURLOPT_SEEKFUNCTION.md
index ac37cc596..120b254d5 100644
--- a/docs/libcurl/opts/CURLOPT_SEEKFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_SEEKFUNCTION.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_STDERR (3)
 Protocol:
   - All
+Added-in: 7.18.0
 ---
 
 # NAME
@@ -63,7 +64,9 @@ many systems!
 
 # DEFAULT
 
-By default, this is NULL and unused.
+NULL
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -91,9 +94,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.18.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SERVER_RESPONSE_TIMEOUT.md b/docs/libcurl/opts/CURLOPT_SERVER_RESPONSE_TIMEOUT.md
index 6c7d74fc8..03f8eddf3 100644
--- a/docs/libcurl/opts/CURLOPT_SERVER_RESPONSE_TIMEOUT.md
+++ b/docs/libcurl/opts/CURLOPT_SERVER_RESPONSE_TIMEOUT.md
@@ -15,6 +15,7 @@ Protocol:
   - SMTP
   - SFTP
   - SCP
+Added-in: 7.20.0
 ---
 
 # NAME
@@ -46,6 +47,8 @@ This option was formerly known as CURLOPT_FTP_RESPONSE_TIMEOUT.
 
 None
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,12 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10.8. Used under this name since 7.20.0
-
-Support for SSH is predicated on a new enough (1.11.0) version of libssh2
-being available when compiling libcurl.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SERVER_RESPONSE_TIMEOUT_MS.md b/docs/libcurl/opts/CURLOPT_SERVER_RESPONSE_TIMEOUT_MS.md
index 87e2820ca..57071d6d3 100644
--- a/docs/libcurl/opts/CURLOPT_SERVER_RESPONSE_TIMEOUT_MS.md
+++ b/docs/libcurl/opts/CURLOPT_SERVER_RESPONSE_TIMEOUT_MS.md
@@ -15,6 +15,7 @@ Protocol:
   - SMTP
   - SFTP
   - SCP
+Added-in: 8.6.0
 ---
 
 # NAME
@@ -48,6 +49,8 @@ This is the millisecond version of CURLOPT_SERVER_RESPONSE_TIMEOUT(3).
 
 None
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -66,9 +69,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 8.6.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SERVICE_NAME.md b/docs/libcurl/opts/CURLOPT_SERVICE_NAME.md
index 8276253b5..87d6c5c0e 100644
--- a/docs/libcurl/opts/CURLOPT_SERVICE_NAME.md
+++ b/docs/libcurl/opts/CURLOPT_SERVICE_NAME.md
@@ -15,6 +15,7 @@ Protocol:
   - POP3
   - SMTP
   - LDAP
+Added-in: 7.43.0
 ---
 
 # NAME
@@ -43,6 +44,8 @@ option.
 
 See above
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -58,10 +61,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.43.0 for HTTP, 7.49.0 for FTP, IMAP, POP3 and SMTP,
-7.82.0 for OpenLDAP.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SHARE.md b/docs/libcurl/opts/CURLOPT_SHARE.md
index 308d57af3..4e64cc748 100644
--- a/docs/libcurl/opts/CURLOPT_SHARE.md
+++ b/docs/libcurl/opts/CURLOPT_SHARE.md
@@ -9,6 +9,7 @@ See-also:
   - CURLSHOPT_SHARE (3)
 Protocol:
   - All
+Added-in: 7.10
 ---
 
 # NAME
@@ -47,6 +48,8 @@ Set this option to NULL again to stop using that share object.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -77,9 +80,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SOCKOPTDATA.md b/docs/libcurl/opts/CURLOPT_SOCKOPTDATA.md
index 678073745..dbf75da3b 100644
--- a/docs/libcurl/opts/CURLOPT_SOCKOPTDATA.md
+++ b/docs/libcurl/opts/CURLOPT_SOCKOPTDATA.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_SOCKOPTFUNCTION (3)
 Protocol:
   - All
+Added-in: 7.16.0
 ---
 
 # NAME
@@ -30,7 +31,9 @@ argument in the sockopt callback set with CURLOPT_SOCKOPTFUNCTION(3).
 
 # DEFAULT
 
-The default value of this parameter is NULL.
+NULL
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.16.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SOCKOPTFUNCTION.md b/docs/libcurl/opts/CURLOPT_SOCKOPTFUNCTION.md
index e35934be1..fbc3d8804 100644
--- a/docs/libcurl/opts/CURLOPT_SOCKOPTFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_SOCKOPTFUNCTION.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_SOCKOPTDATA (3)
 Protocol:
   - All
+Added-in: 7.16.0
 ---
 
 # NAME
@@ -72,7 +73,9 @@ not attempt to connect (again).
 
 # DEFAULT
 
-By default, this callback is NULL and unused.
+NULL
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -120,10 +123,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.16.0. The *CURL_SOCKOPT_ALREADY_CONNECTED* return code was
-added in 7.21.5.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SOCKS5_AUTH.md b/docs/libcurl/opts/CURLOPT_SOCKS5_AUTH.md
index 937da2c02..9a965933f 100644
--- a/docs/libcurl/opts/CURLOPT_SOCKS5_AUTH.md
+++ b/docs/libcurl/opts/CURLOPT_SOCKS5_AUTH.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_PROXYTYPE (3)
 Protocol:
   - All
+Added-in: 7.55.0
 ---
 
 # NAME
@@ -36,6 +37,8 @@ password with the CURLOPT_PROXYUSERPWD(3) option.
 
 CURLAUTH_BASIC|CURLAUTH_GSSAPI
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,9 +60,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.55.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SOCKS5_GSSAPI_NEC.md b/docs/libcurl/opts/CURLOPT_SOCKS5_GSSAPI_NEC.md
index b46713017..5bb2e42e5 100644
--- a/docs/libcurl/opts/CURLOPT_SOCKS5_GSSAPI_NEC.md
+++ b/docs/libcurl/opts/CURLOPT_SOCKS5_GSSAPI_NEC.md
@@ -6,9 +6,10 @@ Section: 3
 Source: libcurl
 See-also:
   - CURLOPT_PROXY (3)
-  - CURLOPT_SOCKS5_GSSAPI_SERVICE (3)
+  - CURLOPT_PROXY_SERVICE_NAME (3)
 Protocol:
   - All
+Added-in: 7.19.4
 ---
 
 # NAME
@@ -35,6 +36,8 @@ negotiation.
 
 ?
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -52,9 +55,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.19.4
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SOCKS5_GSSAPI_SERVICE.md b/docs/libcurl/opts/CURLOPT_SOCKS5_GSSAPI_SERVICE.md
index 86879589b..fe0c22df6 100644
--- a/docs/libcurl/opts/CURLOPT_SOCKS5_GSSAPI_SERVICE.md
+++ b/docs/libcurl/opts/CURLOPT_SOCKS5_GSSAPI_SERVICE.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_PROXYTYPE (3)
 Protocol:
   - All
+Added-in: 7.19.4
 ---
 
 # NAME
@@ -39,6 +40,8 @@ option.
 
 See above
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -56,9 +59,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
+
+Deprecated since 7.49.0
 
-Added in 7.19.4, deprecated in 7.49.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSH_AUTH_TYPES.md b/docs/libcurl/opts/CURLOPT_SSH_AUTH_TYPES.md
index e83d0a088..f111efe64 100644
--- a/docs/libcurl/opts/CURLOPT_SSH_AUTH_TYPES.md
+++ b/docs/libcurl/opts/CURLOPT_SSH_AUTH_TYPES.md
@@ -11,6 +11,7 @@ See-also:
 Protocol:
   - SFTP
   - SCP
+Added-in: 7.16.1
 ---
 
 # NAME
@@ -40,6 +41,8 @@ authentication.
 
 CURLSSH_AUTH_ANY (all available)
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,9 +60,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-CURLSSH_AUTH_HOST was added in 7.16.1, CURLSSH_AUTH_AGENT was added in 7.28.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSH_COMPRESSION.md b/docs/libcurl/opts/CURLOPT_SSH_COMPRESSION.md
index 884ef28e2..749dedf20 100644
--- a/docs/libcurl/opts/CURLOPT_SSH_COMPRESSION.md
+++ b/docs/libcurl/opts/CURLOPT_SSH_COMPRESSION.md
@@ -10,6 +10,7 @@ See-also:
 Protocol:
   - SFTP
   - SCP
+Added-in: 7.56.0
 ---
 
 # NAME
@@ -35,6 +36,8 @@ may or may not do it.
 
 0, disabled
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -53,9 +56,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.56.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSH_HOSTKEYDATA.md b/docs/libcurl/opts/CURLOPT_SSH_HOSTKEYDATA.md
index 858c59e5e..4629bb632 100644
--- a/docs/libcurl/opts/CURLOPT_SSH_HOSTKEYDATA.md
+++ b/docs/libcurl/opts/CURLOPT_SSH_HOSTKEYDATA.md
@@ -1,7 +1,7 @@
 ---
 c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 SPDX-License-Identifier: curl
-Title: CURLOPT_SSH_KEYDATA
+Title: CURLOPT_SSH_HOSTKEYDATA
 Section: 3
 Source: libcurl
 See-also:
@@ -9,6 +9,7 @@ See-also:
 Protocol:
   - SFTP
   - SCP
+Added-in: 7.84.0
 ---
 
 # NAME
@@ -32,6 +33,8 @@ the callback set with CURLOPT_SSH_HOSTKEYFUNCTION(3).
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -63,9 +66,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# NOTES
+
+Works only with the libssh2 backend.
 
-Added in 7.84.0, works only with libssh2 backend.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSH_HOSTKEYFUNCTION.md b/docs/libcurl/opts/CURLOPT_SSH_HOSTKEYFUNCTION.md
index 2c12fb877..ecaa078a1 100644
--- a/docs/libcurl/opts/CURLOPT_SSH_HOSTKEYFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_SSH_HOSTKEYFUNCTION.md
@@ -10,6 +10,7 @@ See-also:
 Protocol:
   - SFTP
   - SCP
+Added-in: 7.84.0
 ---
 
 # NAME
@@ -58,6 +59,8 @@ the host key is rejected, the connection is canceled.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -88,9 +91,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# NOTES
+
+Work only with the libssh2 backend.
 
-Added in 7.84.0 , work only with libssh2 backend.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSH_HOST_PUBLIC_KEY_MD5.md b/docs/libcurl/opts/CURLOPT_SSH_HOST_PUBLIC_KEY_MD5.md
index fd045f9f3..403570a4e 100644
--- a/docs/libcurl/opts/CURLOPT_SSH_HOST_PUBLIC_KEY_MD5.md
+++ b/docs/libcurl/opts/CURLOPT_SSH_HOST_PUBLIC_KEY_MD5.md
@@ -12,6 +12,7 @@ See-also:
 Protocol:
   - SFTP
   - SCP
+Added-in: 7.17.1
 ---
 
 # NAME
@@ -43,6 +44,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.17.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256.md b/docs/libcurl/opts/CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256.md
index 15e12d3f6..878e012e0 100644
--- a/docs/libcurl/opts/CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256.md
+++ b/docs/libcurl/opts/CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256.md
@@ -11,6 +11,7 @@ See-also:
 Protocol:
   - SFTP
   - SCP
+Added-in: 7.80.0
 ---
 
 # NAME
@@ -36,6 +37,8 @@ does not match the hash the remote host provides.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -53,11 +56,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# NOTES
 
-Added in 7.80.0
 Requires the libssh2 backend.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, CURLE_UNKNOWN_OPTION if not, or
diff --git a/docs/libcurl/opts/CURLOPT_SSH_KEYDATA.md b/docs/libcurl/opts/CURLOPT_SSH_KEYDATA.md
index 8e35a9315..64d98c41f 100644
--- a/docs/libcurl/opts/CURLOPT_SSH_KEYDATA.md
+++ b/docs/libcurl/opts/CURLOPT_SSH_KEYDATA.md
@@ -10,6 +10,7 @@ See-also:
 Protocol:
   - SFTP
   - SCP
+Added-in: 7.19.6
 ---
 
 # NAME
@@ -33,6 +34,8 @@ callback set with CURLOPT_SSH_KEYFUNCTION(3).
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -65,9 +68,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.19.6
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSH_KEYFUNCTION.md b/docs/libcurl/opts/CURLOPT_SSH_KEYFUNCTION.md
index ce71cf419..bf7f03710 100644
--- a/docs/libcurl/opts/CURLOPT_SSH_KEYFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_SSH_KEYFUNCTION.md
@@ -10,6 +10,7 @@ See-also:
 Protocol:
   - SFTP
   - SCP
+Added-in: 7.19.6
 ---
 
 # NAME
@@ -109,6 +110,8 @@ up from scratch again.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -142,9 +145,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.19.6
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSH_KNOWNHOSTS.md b/docs/libcurl/opts/CURLOPT_SSH_KNOWNHOSTS.md
index 86828c0a6..a099af3a2 100644
--- a/docs/libcurl/opts/CURLOPT_SSH_KNOWNHOSTS.md
+++ b/docs/libcurl/opts/CURLOPT_SSH_KNOWNHOSTS.md
@@ -10,6 +10,7 @@ See-also:
 Protocol:
   - SFTP
   - SCP
+Added-in: 7.19.6
 ---
 
 # NAME
@@ -40,6 +41,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,9 +60,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.19.6
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSH_PRIVATE_KEYFILE.md b/docs/libcurl/opts/CURLOPT_SSH_PRIVATE_KEYFILE.md
index fc24eb00b..fe7e5207e 100644
--- a/docs/libcurl/opts/CURLOPT_SSH_PRIVATE_KEYFILE.md
+++ b/docs/libcurl/opts/CURLOPT_SSH_PRIVATE_KEYFILE.md
@@ -10,6 +10,7 @@ See-also:
 Protocol:
   - SFTP
   - SCP
+Added-in: 7.16.1
 ---
 
 # NAME
@@ -47,6 +48,8 @@ option.
 
 As explained above
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -65,9 +68,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.16.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSH_PUBLIC_KEYFILE.md b/docs/libcurl/opts/CURLOPT_SSH_PUBLIC_KEYFILE.md
index 0c27b7edf..f6d2fb3c1 100644
--- a/docs/libcurl/opts/CURLOPT_SSH_PUBLIC_KEYFILE.md
+++ b/docs/libcurl/opts/CURLOPT_SSH_PUBLIC_KEYFILE.md
@@ -10,6 +10,7 @@ See-also:
 Protocol:
   - SFTP
   - SCP
+Added-in: 7.16.1
 ---
 
 # NAME
@@ -43,6 +44,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,10 +63,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 The "" trick was added in 7.26.0
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, CURLE_UNKNOWN_OPTION if not, or
diff --git a/docs/libcurl/opts/CURLOPT_SSLCERT.md b/docs/libcurl/opts/CURLOPT_SSLCERT.md
index f7d3b28f1..c9b3ab64b 100644
--- a/docs/libcurl/opts/CURLOPT_SSLCERT.md
+++ b/docs/libcurl/opts/CURLOPT_SSLCERT.md
@@ -17,6 +17,7 @@ TLS-backend:
   - Schannel
   - Secure Transport
   - wolfSSL
+Added-in: 7.1
 ---
 
 # NAME
@@ -65,6 +66,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -83,9 +86,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-If built TLS enabled.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSLCERTTYPE.md b/docs/libcurl/opts/CURLOPT_SSLCERTTYPE.md
index debbcd160..d08273550 100644
--- a/docs/libcurl/opts/CURLOPT_SSLCERTTYPE.md
+++ b/docs/libcurl/opts/CURLOPT_SSLCERTTYPE.md
@@ -16,6 +16,7 @@ TLS-backend:
   - Schannel
   - Secure Transport
   - wolfSSL
+Added-in: 7.9.3
 ---
 
 # NAME
@@ -47,6 +48,8 @@ option.
 
 "PEM"
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -66,9 +69,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-If built TLS enabled. Added in 7.9.3
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSLCERT_BLOB.md b/docs/libcurl/opts/CURLOPT_SSLCERT_BLOB.md
index 80a50c72f..88f60eb2a 100644
--- a/docs/libcurl/opts/CURLOPT_SSLCERT_BLOB.md
+++ b/docs/libcurl/opts/CURLOPT_SSLCERT_BLOB.md
@@ -15,6 +15,7 @@ TLS-backend:
   - Secure Transport
   - Schannel
   - mbedTLS
+Added-in: 7.71.0
 ---
 
 # NAME
@@ -49,6 +50,8 @@ expects a filename as input.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -75,10 +78,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.71.0. This option is supported by the OpenSSL, Secure Transport,
-Schannel and mbedTLS (since 7.78.0) backends.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSLENGINE.md b/docs/libcurl/opts/CURLOPT_SSLENGINE.md
index 44cd44cbe..2e66aa8d0 100644
--- a/docs/libcurl/opts/CURLOPT_SSLENGINE.md
+++ b/docs/libcurl/opts/CURLOPT_SSLENGINE.md
@@ -12,6 +12,7 @@ Protocol:
   - TLS
 TLS-backend:
   - OpenSSL
+Added-in: 7.9.3
 ---
 
 # NAME
@@ -38,6 +39,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -54,9 +57,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Only if OpenSSL is built with engine support.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSLENGINE_DEFAULT.md b/docs/libcurl/opts/CURLOPT_SSLENGINE_DEFAULT.md
index 963b9c1af..72e908b76 100644
--- a/docs/libcurl/opts/CURLOPT_SSLENGINE_DEFAULT.md
+++ b/docs/libcurl/opts/CURLOPT_SSLENGINE_DEFAULT.md
@@ -11,6 +11,7 @@ Protocol:
   - TLS
 TLS-backend:
   - OpenSSL
+Added-in: 7.9.3
 ---
 
 # NAME
@@ -36,6 +37,8 @@ This option has no effect unless set after CURLOPT_SSLENGINE(3).
 
 None
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -53,9 +56,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Only if the SSL backend is OpenSSL built with engine support.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSLKEY.md b/docs/libcurl/opts/CURLOPT_SSLKEY.md
index f87e8eb67..27f0f347c 100644
--- a/docs/libcurl/opts/CURLOPT_SSLKEY.md
+++ b/docs/libcurl/opts/CURLOPT_SSLKEY.md
@@ -15,6 +15,7 @@ TLS-backend:
   - mbedTLS
   - Schannel
   - wolfSSL
+Added-in: 7.9.3
 ---
 
 # NAME
@@ -46,6 +47,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-If built TLS enabled.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSLKEYTYPE.md b/docs/libcurl/opts/CURLOPT_SSLKEYTYPE.md
index 182f77748..73e1a7547 100644
--- a/docs/libcurl/opts/CURLOPT_SSLKEYTYPE.md
+++ b/docs/libcurl/opts/CURLOPT_SSLKEYTYPE.md
@@ -14,6 +14,7 @@ TLS-backend:
   - OpenSSL
   - BearSSL
   - wolfSSL
+Added-in: 7.9.3
 ---
 
 # NAME
@@ -45,6 +46,8 @@ option.
 
 "PEM"
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-If built TLS enabled.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSLKEY_BLOB.md b/docs/libcurl/opts/CURLOPT_SSLKEY_BLOB.md
index 4ef3b0751..10b047984 100644
--- a/docs/libcurl/opts/CURLOPT_SSLKEY_BLOB.md
+++ b/docs/libcurl/opts/CURLOPT_SSLKEY_BLOB.md
@@ -11,6 +11,7 @@ Protocol:
   - TLS
 TLS-backend:
   - OpenSSL
+Added-in: 7.71.0
 ---
 
 # NAME
@@ -43,6 +44,8 @@ filename as input.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -77,9 +80,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.71.0. This option is supported by the OpenSSL backends.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSLVERSION.md b/docs/libcurl/opts/CURLOPT_SSLVERSION.md
index c483b8268..e39159696 100644
--- a/docs/libcurl/opts/CURLOPT_SSLVERSION.md
+++ b/docs/libcurl/opts/CURLOPT_SSLVERSION.md
@@ -13,6 +13,7 @@ Protocol:
   - TLS
 TLS-backend:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -71,10 +72,12 @@ TLS v1.2 or later (Added in 7.34.0)
 
 TLS v1.3 or later (Added in 7.52.0)
 
+##
+
 The maximum TLS version can be set by using *one* of the
 CURL_SSLVERSION_MAX_ macros below. It is also possible to OR *one* of the
 CURL_SSLVERSION_ macros with *one* of the CURL_SSLVERSION_MAX_ macros.
-The MAX macros are not supported for WolfSSL.
+The MAX macros are not supported for wolfSSL.
 
 ## CURL_SSLVERSION_MAX_DEFAULT
 
@@ -103,6 +106,8 @@ The flag defines maximum supported TLS version as TLS v1.2.
 The flag defines maximum supported TLS version as TLS v1.3.
 (Added in 7.54.0)
 
+##
+
 In versions of curl prior to 7.54 the CURL_SSLVERSION_TLS options were
 documented to allow *only* the specified TLS version, but behavior was
 inconsistent depending on the TLS library.
@@ -111,6 +116,8 @@ inconsistent depending on the TLS library.
 
 CURL_SSLVERSION_DEFAULT
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -129,7 +136,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 SSLv2 and SSLv3 are refused completely since curl 7.77.0
 
@@ -138,6 +145,8 @@ vary depending on which backend libcurl has been built to use.
 
 SSLv3 is disabled by default since 7.39.0.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if the option is supported, and CURLE_UNKNOWN_OPTION if not.
diff --git a/docs/libcurl/opts/CURLOPT_SSL_CIPHER_LIST.md b/docs/libcurl/opts/CURLOPT_SSL_CIPHER_LIST.md
index a887fe9a1..c8923e66b 100644
--- a/docs/libcurl/opts/CURLOPT_SSL_CIPHER_LIST.md
+++ b/docs/libcurl/opts/CURLOPT_SSL_CIPHER_LIST.md
@@ -20,6 +20,7 @@ TLS-backend:
   - wolfSSL
   - GnuTLS
   - mbedTLS
+Added-in: 7.9
 ---
 
 # NAME
@@ -46,7 +47,7 @@ For OpenSSL and GnuTLS valid examples of cipher lists include **RC4-SHA**,
 **SHA1+DES**, **TLSv1** and **DEFAULT**. The default list is normally set when
 you compile OpenSSL.
 
-For WolfSSL, valid examples of cipher lists include **ECDHE-RSA-RC4-SHA**,
+For wolfSSL, valid examples of cipher lists include **ECDHE-RSA-RC4-SHA**,
 **AES256-SHA:AES256-SHA256**, etc.
 
 For mbedTLS and BearSSL, valid examples of cipher lists include
@@ -69,7 +70,9 @@ option.
 
 # DEFAULT
 
-NULL, use internal default
+NULL, use built-in list
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -87,11 +90,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 Added in 7.9, in 7.83.0 for BearSSL, in 8.8.0 for mbedTLS
 
-If built TLS enabled.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSL_CTX_DATA.md b/docs/libcurl/opts/CURLOPT_SSL_CTX_DATA.md
index 5e74f5a36..2dcdd57e1 100644
--- a/docs/libcurl/opts/CURLOPT_SSL_CTX_DATA.md
+++ b/docs/libcurl/opts/CURLOPT_SSL_CTX_DATA.md
@@ -14,6 +14,7 @@ TLS-backend:
   - wolfSSL
   - mbedTLS
   - BearSSL
+Added-in: 7.10.6
 ---
 
 # NAME
@@ -38,6 +39,8 @@ parameter.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -113,11 +116,13 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 Added in 7.11.0 for OpenSSL, in 7.42.0 for wolfSSL, in 7.54.0 for mbedTLS,
 in 7.83.0 in BearSSL.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 CURLE_OK if supported; or an error such as:
diff --git a/docs/libcurl/opts/CURLOPT_SSL_CTX_FUNCTION.md b/docs/libcurl/opts/CURLOPT_SSL_CTX_FUNCTION.md
index 64732c1a7..f461209bc 100644
--- a/docs/libcurl/opts/CURLOPT_SSL_CTX_FUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_SSL_CTX_FUNCTION.md
@@ -5,9 +5,12 @@ Title: CURLOPT_SSL_CTX_FUNCTION
 Section: 3
 Source: libcurl
 See-also:
+  - CURLOPT_CA_CACHE_TIMEOUT (3)
+  - CURLOPT_CAINFO (3)
+  - CURLOPT_CAINFO_BLOB (3)
   - CURLOPT_SSL_CTX_DATA (3)
+  - CURLOPT_SSL_VERIFYHOST (3)
   - CURLOPT_SSL_VERIFYPEER (3)
-  - CURLOPT_CAINFO (3)
 Protocol:
   - TLS
 TLS-backend:
@@ -15,6 +18,7 @@ TLS-backend:
   - wolfSSL
   - mbedTLS
   - BearSSL
+Added-in: 7.10.6
 ---
 
 # NAME
@@ -78,10 +82,16 @@ callback function has returned. Your application must not assume that it can
 keep using the SSL context or data derived from it once this function is
 completed.
 
+For libcurl builds using TLS backends that support CA caching and
+CURLOPT_CA_CACHE_TIMEOUT(3) is not set to zero, multiple calls to this
+callback may be done with the same CA store in memory.
+
 # DEFAULT
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -157,10 +167,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-OpenSSL (added in 7.11.0), wolfSSL (added in 7.42.0), mbedTLS (added in
-7.54.0) or BearSSL (added in 7.83.0)
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSL_EC_CURVES.md b/docs/libcurl/opts/CURLOPT_SSL_EC_CURVES.md
index e68ac37cd..d1459c420 100644
--- a/docs/libcurl/opts/CURLOPT_SSL_EC_CURVES.md
+++ b/docs/libcurl/opts/CURLOPT_SSL_EC_CURVES.md
@@ -13,6 +13,7 @@ Protocol:
 TLS-backend:
   - OpenSSL
   - wolfSSL
+Added-in: 7.73.0
 ---
 
 # NAME
@@ -37,6 +38,8 @@ the SSL backend libcurl is built to use supports it).
 
 "", embedded in SSL backend
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -53,9 +56,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.73.0. Supported by the OpenSSL backend.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSL_ENABLE_ALPN.md b/docs/libcurl/opts/CURLOPT_SSL_ENABLE_ALPN.md
index f53a6fc8d..e521c543d 100644
--- a/docs/libcurl/opts/CURLOPT_SSL_ENABLE_ALPN.md
+++ b/docs/libcurl/opts/CURLOPT_SSL_ENABLE_ALPN.md
@@ -11,6 +11,7 @@ Protocol:
   - TLS
 TLS-backend:
   - All
+Added-in: 7.36.0
 ---
 
 # NAME
@@ -35,6 +36,8 @@ is built to use supports it), which can be used to negotiate http2.
 
 1, enabled
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -51,9 +54,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.36.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSL_ENABLE_NPN.md b/docs/libcurl/opts/CURLOPT_SSL_ENABLE_NPN.md
index 26c79f33d..65ade8bd4 100644
--- a/docs/libcurl/opts/CURLOPT_SSL_ENABLE_NPN.md
+++ b/docs/libcurl/opts/CURLOPT_SSL_ENABLE_NPN.md
@@ -11,6 +11,7 @@ Protocol:
   - TLS
 TLS-backend:
   - All
+Added-in: 7.36.0
 ---
 
 # NAME
@@ -27,7 +28,7 @@ CURLcode curl_easy_setopt(CURL *handle, CURLOPT_SSL_ENABLE_NPN, long npn);
 
 # DESCRIPTION
 
-Deprecated in 7.86.0. Setting this option has no function.
+Deprecated since 7.86.0. Setting this option has no function.
 
 Pass a long as parameter, 0 or 1 where 1 is for enable and 0 for disable. This
 option enables/disables NPN in the SSL handshake (if the SSL backend libcurl
@@ -37,6 +38,8 @@ is built to use supports it), which can be used to negotiate http2.
 
 1, enabled
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -53,9 +56,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# DEPRECATED
+
+Deprecated since 7.86.0.
 
-Added in 7.36.0. Deprecated in 7.86.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSL_FALSESTART.md b/docs/libcurl/opts/CURLOPT_SSL_FALSESTART.md
index 7758f0d90..83b6b69da 100644
--- a/docs/libcurl/opts/CURLOPT_SSL_FALSESTART.md
+++ b/docs/libcurl/opts/CURLOPT_SSL_FALSESTART.md
@@ -10,6 +10,7 @@ Protocol:
   - TLS
 TLS-backend:
   - Secure Transport
+Added-in: 7.42.0
 ---
 
 # NAME
@@ -37,6 +38,8 @@ when performing a full handshake.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -51,10 +54,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.42.0. This option is currently only supported by the Secure
-Transport (on iOS 7.0 or later, or OS X 10.9 or later) TLS backend.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSL_OPTIONS.md b/docs/libcurl/opts/CURLOPT_SSL_OPTIONS.md
index ddf278e6f..21e0d75e3 100644
--- a/docs/libcurl/opts/CURLOPT_SSL_OPTIONS.md
+++ b/docs/libcurl/opts/CURLOPT_SSL_OPTIONS.md
@@ -12,6 +12,7 @@ Protocol:
   - TLS
 TLS-backend:
   - All
+Added-in: 7.25.0
 ---
 
 # NAME
@@ -89,6 +90,8 @@ could be a privacy violation and unexpected.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -107,9 +110,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.25.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSL_SESSIONID_CACHE.md b/docs/libcurl/opts/CURLOPT_SSL_SESSIONID_CACHE.md
index 364eb0409..1ed5a91f1 100644
--- a/docs/libcurl/opts/CURLOPT_SSL_SESSIONID_CACHE.md
+++ b/docs/libcurl/opts/CURLOPT_SSL_SESSIONID_CACHE.md
@@ -13,6 +13,7 @@ Protocol:
   - TLS
 TLS-backend:
   - All
+Added-in: 7.16.0
 ---
 
 # NAME
@@ -40,6 +41,8 @@ wild that may require you to disable this in order for you to succeed.
 
 1
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,9 +60,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.16.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSL_VERIFYHOST.md b/docs/libcurl/opts/CURLOPT_SSL_VERIFYHOST.md
index f432fecbd..30b1525fe 100644
--- a/docs/libcurl/opts/CURLOPT_SSL_VERIFYHOST.md
+++ b/docs/libcurl/opts/CURLOPT_SSL_VERIFYHOST.md
@@ -12,6 +12,7 @@ Protocol:
   - TLS
 TLS-backend:
   - All
+Added-in: 7.8.1
 ---
 
 # NAME
@@ -28,40 +29,27 @@ CURLcode curl_easy_setopt(CURL *handle, CURLOPT_SSL_VERIFYHOST, long verify);
 
 # DESCRIPTION
 
-Pass a long as parameter specifying what to *verify*.
+Pass a long set to 2L to make libcurl verify the host in the server's TLS
+certificate.
 
-This option determines whether libcurl verifies that the server cert is for
-the server it is known as.
+When negotiating a TLS connection, the server sends a certificate indicating
+its identity.
 
-When negotiating TLS and SSL connections, the server sends a certificate
-indicating its identity.
+When CURLOPT_SSL_VERIFYHOST(3) is set to 1 or 2, the server certificate must
+indicate that it was made for the hostname or address curl connects to, or the
+connection fails. Simply put, it means it has to have the same name in the
+certificate as is used in the URL you operate against.
 
-When CURLOPT_SSL_VERIFYHOST(3) is 2, that certificate must indicate that
-the server is the server to which you meant to connect, or the connection
-fails. Simply put, it means it has to have the same name in the certificate as
-is in the URL you operate against.
-
-Curl considers the server the intended one when the Common Name field or a
+curl considers the server the intended one when the Common Name field or a
 Subject Alternate Name field in the certificate matches the hostname in the
-URL to which you told Curl to connect.
-
-If *verify* value is set to 1:
-
-In 7.28.0 and earlier: treated as a debug option of some sorts, not supported
-anymore due to frequently leading to programmer mistakes.
+URL to which you told curl to connect.
 
-From 7.28.1 to 7.65.3: setting it to 1 made curl_easy_setopt(3) return
-an error and leaving the flag untouched.
+When the *verify* value is 0, the connection succeeds regardless of the names
+in the certificate. Use that ability with caution,
 
-From 7.66.0: treats 1 and 2 the same.
-
-When the *verify* value is 0, the connection succeeds regardless of the
-names in the certificate. Use that ability with caution!
-
-The default value for this option is 2.
-
-This option controls checking the server's certificate's claimed identity.
-The server could be lying. To control lying, see CURLOPT_SSL_VERIFYPEER(3).
+This option controls checking the server's certificate's claimed identity. The
+separate CURLOPT_SSL_VERIFYPEER(3) options enables/disables verification that
+the certificate is signed by a trusted Certificate Authority.
 
 WARNING: disabling verification of the certificate allows bad guys to
 man-in-the-middle the communication without you knowing it. Disabling
@@ -74,18 +62,31 @@ HSTS and Alt-Svc information to be stored and used subsequently. Disabling
 certificate verification can make libcurl trust and use such information from
 malicious servers.
 
+# MATCHING
+
+A certificate can have the name as a wildcard. The only asterisk (`*`) must
+then be the left-most character and it must be followed by a period. The
+wildcard must further contain more than one period as it cannot be set for a
+top-level domain.
+
+A certificate can be set for a numerical IP address (IPv4 or IPv6), but then
+it should be a Subject Alternate Name kind and its type should correctly
+identify the field as an IP address.
+
 # LIMITATIONS
 
-Secure Transport: If *verify* value is 0, then SNI is also disabled. SNI is
-a TLS extension that sends the hostname to the server. The server may use that
+Secure Transport: If *verify* value is 0, then SNI is also disabled. SNI is a
+TLS extension that sends the hostname to the server. The server may use that
 information to do such things as sending back a specific certificate for the
-hostname, or forwarding the request to a specific origin server. Some hostnames
-may be inaccessible if SNI is not sent.
+hostname, or forwarding the request to a specific origin server. Some
+hostnames may be inaccessible if SNI is not sent.
 
 # DEFAULT
 
 2
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -103,12 +104,18 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# %AVAILABILITY%
 
-If built TLS enabled.
+# HISTORY
+
+In 7.28.0 and earlier: the value 1 was treated as a debug option of some
+sorts, not supported anymore due to frequently leading to programmer mistakes.
+
+From 7.28.1 to 7.65.3: setting it to 1 made curl_easy_setopt(3) return
+an error and leaving the flag untouched.
+
+From 7.66.0: libcurl treats 1 and 2 to this option the same.
 
 # RETURN VALUE
 
 Returns CURLE_OK if TLS is supported, and CURLE_UNKNOWN_OPTION if not.
-
-If 1 is set as argument, *CURLE_BAD_FUNCTION_ARGUMENT* is returned.
diff --git a/docs/libcurl/opts/CURLOPT_SSL_VERIFYPEER.md b/docs/libcurl/opts/CURLOPT_SSL_VERIFYPEER.md
index 214da41cf..4d4bf7c6b 100644
--- a/docs/libcurl/opts/CURLOPT_SSL_VERIFYPEER.md
+++ b/docs/libcurl/opts/CURLOPT_SSL_VERIFYPEER.md
@@ -15,6 +15,7 @@ Protocol:
   - TLS
 TLS-backend:
   - All
+Added-in: 7.4.2
 ---
 
 # NAME
@@ -72,6 +73,8 @@ malicious servers.
 
 1 - enabled
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -89,9 +92,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-If built TLS enabled.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SSL_VERIFYSTATUS.md b/docs/libcurl/opts/CURLOPT_SSL_VERIFYSTATUS.md
index 7f6b1a019..d9ee57c0d 100644
--- a/docs/libcurl/opts/CURLOPT_SSL_VERIFYSTATUS.md
+++ b/docs/libcurl/opts/CURLOPT_SSL_VERIFYSTATUS.md
@@ -13,6 +13,7 @@ Protocol:
 TLS-backend:
   - OpenSSL
   - GnuTLS
+Added-in: 7.41.0
 ---
 
 # NAME
@@ -41,6 +42,8 @@ extension, the verification fails.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -58,10 +61,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.41.0. This option is currently only supported by the OpenSSL and
-GnuTLS TLS backends.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_STDERR.md b/docs/libcurl/opts/CURLOPT_STDERR.md
index f38aba25e..368944334 100644
--- a/docs/libcurl/opts/CURLOPT_STDERR.md
+++ b/docs/libcurl/opts/CURLOPT_STDERR.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_VERBOSE (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -38,6 +39,8 @@ application. A work-around is to instead use CURLOPT_DEBUGFUNCTION(3).
 
 stderr
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -54,9 +57,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_STREAM_DEPENDS.md b/docs/libcurl/opts/CURLOPT_STREAM_DEPENDS.md
index 7342f3bcf..99664423d 100644
--- a/docs/libcurl/opts/CURLOPT_STREAM_DEPENDS.md
+++ b/docs/libcurl/opts/CURLOPT_STREAM_DEPENDS.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_STREAM_WEIGHT (3)
 Protocol:
   - HTTP
+Added-in: 7.46.0
 ---
 
 # NAME
@@ -47,6 +48,8 @@ option to have an actual effect.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -66,9 +69,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.46.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_STREAM_DEPENDS_E.md b/docs/libcurl/opts/CURLOPT_STREAM_DEPENDS_E.md
index 8d109fb19..158c831a1 100644
--- a/docs/libcurl/opts/CURLOPT_STREAM_DEPENDS_E.md
+++ b/docs/libcurl/opts/CURLOPT_STREAM_DEPENDS_E.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_STREAM_WEIGHT (3)
 Protocol:
   - HTTP
+Added-in: 7.46.0
 ---
 
 # NAME
@@ -50,6 +51,8 @@ option to have an actual effect.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -69,9 +72,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.46.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_STREAM_WEIGHT.md b/docs/libcurl/opts/CURLOPT_STREAM_WEIGHT.md
index fdd2a1840..99558a199 100644
--- a/docs/libcurl/opts/CURLOPT_STREAM_WEIGHT.md
+++ b/docs/libcurl/opts/CURLOPT_STREAM_WEIGHT.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_STREAM_DEPENDS_E (3)
 Protocol:
   - HTTP
+Added-in: 7.46.0
 ---
 
 # NAME
@@ -47,8 +48,9 @@ streams).
 
 # DEFAULT
 
-If nothing is set, the HTTP/2 protocol itself uses its own default which is
-16.
+16
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -70,9 +72,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.46.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_SUPPRESS_CONNECT_HEADERS.md b/docs/libcurl/opts/CURLOPT_SUPPRESS_CONNECT_HEADERS.md
index b6357b503..b05824630 100644
--- a/docs/libcurl/opts/CURLOPT_SUPPRESS_CONNECT_HEADERS.md
+++ b/docs/libcurl/opts/CURLOPT_SUPPRESS_CONNECT_HEADERS.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_PROXY (3)
 Protocol:
   - All
+Added-in: 7.54.0
 ---
 
 # NAME
@@ -70,6 +71,8 @@ Content-Type: application/json
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -92,9 +95,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.54.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TCP_FASTOPEN.md b/docs/libcurl/opts/CURLOPT_TCP_FASTOPEN.md
index 42b44a567..8665c39d2 100644
--- a/docs/libcurl/opts/CURLOPT_TCP_FASTOPEN.md
+++ b/docs/libcurl/opts/CURLOPT_TCP_FASTOPEN.md
@@ -8,6 +8,7 @@ See-also:
   - CURLOPT_SSL_FALSESTART (3)
 Protocol:
   - All
+Added-in: 7.49.0
 ---
 
 # NAME
@@ -37,6 +38,8 @@ Fast Open is also known to be problematic on or across certain networks.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -51,10 +54,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# NOTES
+
+This option is only supported on Linux and macOS 10.11 or later.
 
-Added in 7.49.0. This option is currently only supported on Linux and macOS
-10.11 or later.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TCP_KEEPALIVE.md b/docs/libcurl/opts/CURLOPT_TCP_KEEPALIVE.md
index e9e80ac6a..3d9da660d 100644
--- a/docs/libcurl/opts/CURLOPT_TCP_KEEPALIVE.md
+++ b/docs/libcurl/opts/CURLOPT_TCP_KEEPALIVE.md
@@ -9,8 +9,10 @@ See-also:
   - CURLOPT_MAX_RECV_SPEED_LARGE (3)
   - CURLOPT_TCP_KEEPIDLE (3)
   - CURLOPT_TCP_KEEPINTVL (3)
+  - CURLOPT_TCP_KEEPCNT (3)
 Protocol:
-  - All
+  - TCP
+Added-in: 7.25.0
 ---
 
 # NAME
@@ -29,14 +31,16 @@ CURLcode curl_easy_setopt(CURL *handle, CURLOPT_TCP_KEEPALIVE, long probe);
 
 Pass a long. If set to 1, TCP keepalive probes are used. The delay and
 frequency of these probes can be controlled by the
-CURLOPT_TCP_KEEPIDLE(3) and CURLOPT_TCP_KEEPINTVL(3) options,
-provided the operating system supports them. Set to 0 (default behavior) to
-disable keepalive probes
+CURLOPT_TCP_KEEPIDLE(3), CURLOPT_TCP_KEEPINTVL(3), and CURLOPT_TCP_KEEPCNT(3)
+options, provided the operating system supports them. Set to 0 (default behavior)
+to disable keepalive probes.
 
 # DEFAULT
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -55,14 +59,15 @@ int main(void)
     /* interval time between keep-alive probes: 60 seconds */
     curl_easy_setopt(curl, CURLOPT_TCP_KEEPINTVL, 60L);
 
+    /* maximum number of keep-alive probes: 3 */
+    curl_easy_setopt(curl, CURLOPT_TCP_KEEPCNT, 3L);
+
     curl_easy_perform(curl);
   }
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.25.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TCP_KEEPCNT.md b/docs/libcurl/opts/CURLOPT_TCP_KEEPCNT.md
new file mode 100644
index 000000000..5a03f3cff
--- /dev/null
+++ b/docs/libcurl/opts/CURLOPT_TCP_KEEPCNT.md
@@ -0,0 +1,74 @@
+---
+c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+SPDX-License-Identifier: curl
+Title: CURLOPT_TCP_KEEPCNT
+Section: 3
+Source: libcurl
+See-also:
+  - CURLOPT_TCP_KEEPALIVE (3)
+  - CURLOPT_TCP_KEEPIDLE (3)
+  - CURLOPT_TCP_KEEPINTVL (3)
+Protocol:
+  - TCP
+Added-in: 8.9.0
+---
+
+# NAME
+
+CURLOPT_TCP_KEEPCNT - Maximum number of TCP keep-alive probes
+
+# SYNOPSIS
+
+~~~c
+#include <curl/curl.h>
+
+CURLcode curl_easy_setopt(CURL *handle, CURLOPT_TCP_KEEPCNT, long cnt);
+~~~
+
+# DESCRIPTION
+
+Pass a long. Sets the number of probes to send before dropping
+the connection. Not all operating systems support this option.
+(Added in 8.9.0)
+
+The maximum value this option accepts is INT_MAX or whatever your
+system allows.
+Any larger value is capped to this amount.
+
+# DEFAULT
+
+9
+
+# %PROTOCOLS%
+
+# EXAMPLE
+
+~~~c
+int main(void)
+{
+  CURL *curl = curl_easy_init();
+  if(curl) {
+    curl_easy_setopt(curl, CURLOPT_URL, "https://example.com");
+
+    /* enable TCP keep-alive for this transfer */
+    curl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, 1L);
+
+    /* set keep-alive idle time to 120 seconds */
+    curl_easy_setopt(curl, CURLOPT_TCP_KEEPIDLE, 120L);
+
+    /* interval time between keep-alive probes: 60 seconds */
+    curl_easy_setopt(curl, CURLOPT_TCP_KEEPINTVL, 60L);
+
+    /* maximum number of keep-alive probes: 3 */
+    curl_easy_setopt(curl, CURLOPT_TCP_KEEPCNT, 3L);
+
+    curl_easy_perform(curl);
+  }
+}
+~~~
+
+# %AVAILABILITY%
+
+# RETURN VALUE
+
+Returns CURLE_OK if the option is supported, and CURLE_UNKNOWN_OPTION if not.
diff --git a/docs/libcurl/opts/CURLOPT_TCP_KEEPIDLE.md b/docs/libcurl/opts/CURLOPT_TCP_KEEPIDLE.md
index 5f8841747..370ace4a2 100644
--- a/docs/libcurl/opts/CURLOPT_TCP_KEEPIDLE.md
+++ b/docs/libcurl/opts/CURLOPT_TCP_KEEPIDLE.md
@@ -7,8 +7,10 @@ Source: libcurl
 See-also:
   - CURLOPT_TCP_KEEPALIVE (3)
   - CURLOPT_TCP_KEEPINTVL (3)
+  - CURLOPT_TCP_KEEPCNT (3)
 Protocol:
-  - All
+  - TCP
+Added-in: 7.25.0
 ---
 
 # NAME
@@ -36,6 +38,8 @@ this amount.
 
 60
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -54,14 +58,15 @@ int main(void)
     /* interval time between keep-alive probes: 60 seconds */
     curl_easy_setopt(curl, CURLOPT_TCP_KEEPINTVL, 60L);
 
+    /* maximum number of keep-alive probes: 3 */
+    curl_easy_setopt(curl, CURLOPT_TCP_KEEPCNT, 3L);
+
     curl_easy_perform(curl);
   }
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.25.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TCP_KEEPINTVL.md b/docs/libcurl/opts/CURLOPT_TCP_KEEPINTVL.md
index 405b6ec82..9d0ebc7a8 100644
--- a/docs/libcurl/opts/CURLOPT_TCP_KEEPINTVL.md
+++ b/docs/libcurl/opts/CURLOPT_TCP_KEEPINTVL.md
@@ -7,8 +7,10 @@ Source: libcurl
 See-also:
   - CURLOPT_TCP_KEEPALIVE (3)
   - CURLOPT_TCP_KEEPIDLE (3)
+  - CURLOPT_TCP_KEEPCNT (3)
 Protocol:
-  - All
+  - TCP
+Added-in: 7.25.0
 ---
 
 # NAME
@@ -35,6 +37,8 @@ this amount.
 
 60
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -53,14 +57,15 @@ int main(void)
     /* interval time between keep-alive probes: 60 seconds */
     curl_easy_setopt(curl, CURLOPT_TCP_KEEPINTVL, 60L);
 
+    /* maximum number of keep-alive probes: 3 */
+    curl_easy_setopt(curl, CURLOPT_TCP_KEEPCNT, 3L);
+
     curl_easy_perform(curl);
   }
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TCP_NODELAY.md b/docs/libcurl/opts/CURLOPT_TCP_NODELAY.md
index a5b15abbf..6b30b5465 100644
--- a/docs/libcurl/opts/CURLOPT_TCP_NODELAY.md
+++ b/docs/libcurl/opts/CURLOPT_TCP_NODELAY.md
@@ -9,7 +9,8 @@ See-also:
   - CURLOPT_SOCKOPTFUNCTION (3)
   - CURLOPT_TCP_KEEPALIVE (3)
 Protocol:
-  - All
+  - TCP
+Added-in: 7.11.2
 ---
 
 # NAME
@@ -45,6 +46,8 @@ overdone.
 
 1
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,9 +63,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
+
+The default was changed to 1 from 0 in 7.50.2.
 
-Always. The default was changed to 1 from 0 in 7.50.2.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TELNETOPTIONS.md b/docs/libcurl/opts/CURLOPT_TELNETOPTIONS.md
index 9e45df837..34717cbed 100644
--- a/docs/libcurl/opts/CURLOPT_TELNETOPTIONS.md
+++ b/docs/libcurl/opts/CURLOPT_TELNETOPTIONS.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_QUOTE (3)
 Protocol:
   - TELNET
+Added-in: 7.7
 ---
 
 # NAME
@@ -35,6 +36,8 @@ standard for details.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -55,9 +58,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with TELNET
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TFTP_BLKSIZE.md b/docs/libcurl/opts/CURLOPT_TFTP_BLKSIZE.md
index 1b5c9ae6f..ab85fe45f 100644
--- a/docs/libcurl/opts/CURLOPT_TFTP_BLKSIZE.md
+++ b/docs/libcurl/opts/CURLOPT_TFTP_BLKSIZE.md
@@ -8,6 +8,7 @@ See-also:
   - CURLOPT_MAXFILESIZE (3)
 Protocol:
   - TFTP
+Added-in: 7.19.4
 ---
 
 # NAME
@@ -35,6 +36,8 @@ is used.
 
 512
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -52,9 +55,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.19.4
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TFTP_NO_OPTIONS.md b/docs/libcurl/opts/CURLOPT_TFTP_NO_OPTIONS.md
index 953702696..098ee3944 100644
--- a/docs/libcurl/opts/CURLOPT_TFTP_NO_OPTIONS.md
+++ b/docs/libcurl/opts/CURLOPT_TFTP_NO_OPTIONS.md
@@ -8,6 +8,7 @@ See-also:
   - CURLOPT_TFTP_BLKSIZE (3)
 Protocol:
   - TFTP
+Added-in: 7.48.0
 ---
 
 # NAME
@@ -35,6 +36,8 @@ CURLOPT_TFTP_BLKSIZE(3) is ignored.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -67,9 +70,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.48.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TIMECONDITION.md b/docs/libcurl/opts/CURLOPT_TIMECONDITION.md
index b4bdb4fa2..43c679bd6 100644
--- a/docs/libcurl/opts/CURLOPT_TIMECONDITION.md
+++ b/docs/libcurl/opts/CURLOPT_TIMECONDITION.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_TIMEVALUE (3)
 Protocol:
   - HTTP
+Added-in: 7.1
 ---
 
 # NAME
@@ -39,6 +40,8 @@ option can be used after a transfer to learn if a zero-byte successful
 
 CURL_TIMECOND_NONE (0)
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -61,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TIMEOUT.md b/docs/libcurl/opts/CURLOPT_TIMEOUT.md
index c35bb4076..0dc17f036 100644
--- a/docs/libcurl/opts/CURLOPT_TIMEOUT.md
+++ b/docs/libcurl/opts/CURLOPT_TIMEOUT.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_TIMEOUT_MS (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -59,7 +60,9 @@ signals to be used unless CURLOPT_NOSIGNAL(3) is set.
 
 # DEFAULT
 
-Default timeout is 0 (zero) which means it never times out during transfer.
+0 (zero) which means it never times out during transfer.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -78,9 +81,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TIMEOUT_MS.md b/docs/libcurl/opts/CURLOPT_TIMEOUT_MS.md
index 8f13480d3..e02261d5b 100644
--- a/docs/libcurl/opts/CURLOPT_TIMEOUT_MS.md
+++ b/docs/libcurl/opts/CURLOPT_TIMEOUT_MS.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_TIMEOUT (3)
 Protocol:
   - All
+Added-in: 7.16.2
 ---
 
 # NAME
@@ -34,7 +35,9 @@ See CURLOPT_TIMEOUT(3) for details.
 
 # DEFAULT
 
-Default timeout is 0 (zero) which means it never times out during transfer.
+0 (zero) which means it never times out during transfer.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -53,9 +56,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TIMEVALUE.md b/docs/libcurl/opts/CURLOPT_TIMEVALUE.md
index 5558e6d17..ef9b9dab1 100644
--- a/docs/libcurl/opts/CURLOPT_TIMEVALUE.md
+++ b/docs/libcurl/opts/CURLOPT_TIMEVALUE.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_TIMEVALUE_LARGE (3)
 Protocol:
   - HTTP
+Added-in: 7.1
 ---
 
 # NAME
@@ -29,7 +30,7 @@ Pass a long *val* as parameter. This should be the time counted as seconds
 since 1 Jan 1970, and the time is used in a condition as specified with
 CURLOPT_TIMECONDITION(3).
 
-On systems with 32 bit 'long' variables (such as Windows), this option cannot
+On systems with 32-bit 'long' variables (such as Windows), this option cannot
 set dates beyond the year 2038. Consider CURLOPT_TIMEVALUE_LARGE(3)
 instead.
 
@@ -37,6 +38,8 @@ instead.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -58,9 +61,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TIMEVALUE_LARGE.md b/docs/libcurl/opts/CURLOPT_TIMEVALUE_LARGE.md
index cd16c7589..9ae16e4e0 100644
--- a/docs/libcurl/opts/CURLOPT_TIMEVALUE_LARGE.md
+++ b/docs/libcurl/opts/CURLOPT_TIMEVALUE_LARGE.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_TIMEVALUE (3)
 Protocol:
   - HTTP
+Added-in: 7.59.0
 ---
 
 # NAME
@@ -31,14 +32,16 @@ Pass a curl_off_t *val* as parameter. This should be the time counted as
 seconds since 1 Jan 1970, and the time is used in a condition as specified
 with CURLOPT_TIMECONDITION(3).
 
-The difference between this option and CURLOPT_TIMEVALUE(3) is the type
-of the argument. On systems where 'long' is only 32 bit wide, this option has
-to be used to set dates beyond the year 2038.
+The difference between this option and CURLOPT_TIMEVALUE(3) is the type of the
+argument. On systems where 'long' is only 32 bits wide, this option has to be
+used to set dates beyond the year 2038.
 
 # DEFAULT
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.59.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TLS13_CIPHERS.md b/docs/libcurl/opts/CURLOPT_TLS13_CIPHERS.md
index a53fe2f9f..f9320560d 100644
--- a/docs/libcurl/opts/CURLOPT_TLS13_CIPHERS.md
+++ b/docs/libcurl/opts/CURLOPT_TLS13_CIPHERS.md
@@ -16,6 +16,7 @@ Protocol:
 TLS-backend:
   - OpenSSL
   - Schannel
+Added-in: 7.61.0
 ---
 
 # NAME
@@ -51,7 +52,9 @@ option.
 
 # DEFAULT
 
-NULL, use internal default
+NULL, use internal built-in
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -70,12 +73,14 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 Added in 7.61.0 for OpenSSL. Available when built with OpenSSL \>= 1.1.1.
 
 Added in 7.85.0 for Schannel.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 Returns CURLE_OK if supported, CURLE_NOT_BUILT_IN otherwise.
diff --git a/docs/libcurl/opts/CURLOPT_TLSAUTH_PASSWORD.md b/docs/libcurl/opts/CURLOPT_TLSAUTH_PASSWORD.md
index 6a9a83829..f97108a96 100644
--- a/docs/libcurl/opts/CURLOPT_TLSAUTH_PASSWORD.md
+++ b/docs/libcurl/opts/CURLOPT_TLSAUTH_PASSWORD.md
@@ -13,6 +13,7 @@ Protocol:
 TLS-backend:
   - OpenSSL
   - GnuTLS
+Added-in: 7.21.4
 ---
 
 # NAME
@@ -31,18 +32,20 @@ CURLcode curl_easy_setopt(CURL *handle, CURLOPT_TLSAUTH_PASSWORD, char *pwd);
 
 Pass a char pointer as parameter, which should point to the null-terminated
 password to use for the TLS authentication method specified with the
-CURLOPT_TLSAUTH_TYPE(3) option. Requires that the
-CURLOPT_TLSAUTH_USERNAME(3) option also be set.
+CURLOPT_TLSAUTH_TYPE(3) option. Requires that the CURLOPT_TLSAUTH_USERNAME(3)
+option also be set.
 
 The application does not have to keep the string around after setting this
 option.
 
-This feature relies in TLS SRP which does not work with TLS 1.3.
+This feature relies on TLS SRP which does not work with TLS 1.3.
 
 # DEFAULT
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -61,9 +64,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.21.4, with the OpenSSL and GnuTLS backends only
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TLSAUTH_TYPE.md b/docs/libcurl/opts/CURLOPT_TLSAUTH_TYPE.md
index 0611334e4..52c38a20d 100644
--- a/docs/libcurl/opts/CURLOPT_TLSAUTH_TYPE.md
+++ b/docs/libcurl/opts/CURLOPT_TLSAUTH_TYPE.md
@@ -12,6 +12,7 @@ Protocol:
 TLS-backend:
   - OpenSSL
   - GnuTLS
+Added-in: 7.21.4
 ---
 
 # NAME
@@ -36,11 +37,7 @@ the method of the TLS authentication. Supported method is "SRP".
 TLS-SRP authentication. Secure Remote Password authentication for TLS is
 defined in RFC 5054 and provides mutual authentication if both sides have a
 shared secret. To use TLS-SRP, you must also set the
-CURLOPT_TLSAUTH_USERNAME(3) and CURLOPT_TLSAUTH_PASSWORD(3)
-options.
-
-The application does not have to keep the string around after setting this
-option.
+CURLOPT_TLSAUTH_USERNAME(3) and CURLOPT_TLSAUTH_PASSWORD(3) options.
 
 TLS SRP does not work with TLS 1.3.
 
@@ -48,6 +45,8 @@ TLS SRP does not work with TLS 1.3.
 
 blank
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -66,10 +65,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-You need to build libcurl with GnuTLS or OpenSSL with TLS-SRP support for this
-to work. Added in 7.21.4
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TLSAUTH_USERNAME.md b/docs/libcurl/opts/CURLOPT_TLSAUTH_USERNAME.md
index c69ac8167..6715f75f1 100644
--- a/docs/libcurl/opts/CURLOPT_TLSAUTH_USERNAME.md
+++ b/docs/libcurl/opts/CURLOPT_TLSAUTH_USERNAME.md
@@ -12,6 +12,7 @@ Protocol:
 TLS-backend:
   - OpenSSL
   - GnuTLS
+Added-in: 7.21.4
 ---
 
 # NAME
@@ -30,18 +31,20 @@ CURLcode curl_easy_setopt(CURL *handle, CURLOPT_TLSAUTH_USERNAME, char *user);
 
 Pass a char pointer as parameter, which should point to the null-terminated
 username to use for the TLS authentication method specified with the
-CURLOPT_TLSAUTH_TYPE(3) option. Requires that the
-CURLOPT_TLSAUTH_PASSWORD(3) option also be set.
+CURLOPT_TLSAUTH_TYPE(3) option. Requires that the CURLOPT_TLSAUTH_PASSWORD(3)
+option also be set.
 
 The application does not have to keep the string around after setting this
 option.
 
-This feature relies in TLS SRP which does not work with TLS 1.3.
+This feature relies on TLS SRP which does not work with TLS 1.3.
 
 # DEFAULT
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.21.4, with the OpenSSL and GnuTLS backends only
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TRAILERDATA.md b/docs/libcurl/opts/CURLOPT_TRAILERDATA.md
index 2eceb16e7..bcc675303 100644
--- a/docs/libcurl/opts/CURLOPT_TRAILERDATA.md
+++ b/docs/libcurl/opts/CURLOPT_TRAILERDATA.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_WRITEFUNCTION (3)
 Protocol:
   - HTTP
+Added-in: 7.64.0
 ---
 
 # NAME
@@ -31,6 +32,8 @@ Data pointer to be passed to the HTTP trailer callback function.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -48,9 +51,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-This option was added in curl 7.64.0 and is present if HTTP support is enabled
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TRAILERFUNCTION.md b/docs/libcurl/opts/CURLOPT_TRAILERFUNCTION.md
index a6cd7fa5f..9c06a598c 100644
--- a/docs/libcurl/opts/CURLOPT_TRAILERFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_TRAILERFUNCTION.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_WRITEFUNCTION (3)
 Protocol:
   - HTTP
+Added-in: 7.64.0
 ---
 
 # NAME
@@ -59,6 +60,8 @@ without any interruptions.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 ~~~c
 static int trailer_cb(struct curl_slist **tr, void *data)
@@ -77,7 +80,7 @@ int main(void)
     /* Set the URL of the request */
     curl_easy_setopt(curl, CURLOPT_URL, "https://example.com/");
     /* Now set it as a put */
-    curl_easy_setopt(curl, CURLOPT_PUT, 1L);
+    curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);
 
     /* Assuming we have a function that returns the data to be pushed
        Let that function be read_cb */
@@ -99,9 +102,8 @@ int main(void)
   }
 }
 ~~~
-# AVAILABILITY
 
-This option was added in curl 7.64.0 and is present if HTTP support is enabled.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TRANSFERTEXT.md b/docs/libcurl/opts/CURLOPT_TRANSFERTEXT.md
index 9506c96ed..bde3b3164 100644
--- a/docs/libcurl/opts/CURLOPT_TRANSFERTEXT.md
+++ b/docs/libcurl/opts/CURLOPT_TRANSFERTEXT.md
@@ -8,6 +8,7 @@ See-also:
   - CURLOPT_CRLF (3)
 Protocol:
   - All
+Added-in: 7.1.1
 ---
 
 # NAME
@@ -38,6 +39,8 @@ simply sets the mode to ASCII and performs a standard transfer.
 
 0, disabled
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -54,9 +57,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with FTP
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_TRANSFER_ENCODING.md b/docs/libcurl/opts/CURLOPT_TRANSFER_ENCODING.md
index 6494d45d4..a66784560 100644
--- a/docs/libcurl/opts/CURLOPT_TRANSFER_ENCODING.md
+++ b/docs/libcurl/opts/CURLOPT_TRANSFER_ENCODING.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_HTTP_TRANSFER_DECODING (3)
 Protocol:
   - HTTP
+Added-in: 7.21.6
 ---
 
 # NAME
@@ -43,6 +44,8 @@ by both HTTP clients and HTTP servers.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -57,9 +60,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.21.6
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_UNIX_SOCKET_PATH.md b/docs/libcurl/opts/CURLOPT_UNIX_SOCKET_PATH.md
index fff993753..f5197ee62 100644
--- a/docs/libcurl/opts/CURLOPT_UNIX_SOCKET_PATH.md
+++ b/docs/libcurl/opts/CURLOPT_UNIX_SOCKET_PATH.md
@@ -10,6 +10,7 @@ See-also:
   - unix (7)
 Protocol:
   - All
+Added-in: 7.40.0
 ---
 
 # NAME
@@ -47,7 +48,9 @@ option.
 
 # DEFAULT
 
-Default is NULL, meaning that no Unix domain sockets are used.
+NULL - no Unix domain sockets are used.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -75,9 +78,7 @@ you can use the proc filesystem to bypass the limitation:
   /* Be sure to keep dirfd valid until you discard the handle */
 ~~~
 
-# AVAILABILITY
-
-Added in 7.40.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_UNRESTRICTED_AUTH.md b/docs/libcurl/opts/CURLOPT_UNRESTRICTED_AUTH.md
index 270ebd654..010ec09f2 100644
--- a/docs/libcurl/opts/CURLOPT_UNRESTRICTED_AUTH.md
+++ b/docs/libcurl/opts/CURLOPT_UNRESTRICTED_AUTH.md
@@ -12,6 +12,7 @@ See-also:
   - CURLOPT_USERPWD (3)
 Protocol:
   - HTTP
+Added-in: 7.10.4
 ---
 
 # NAME
@@ -52,6 +53,8 @@ again and again as the following hosts can keep redirecting to new hosts.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -67,9 +70,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Along with HTTP
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_UPKEEP_INTERVAL_MS.md b/docs/libcurl/opts/CURLOPT_UPKEEP_INTERVAL_MS.md
index 4813904d3..d8cdb90e3 100644
--- a/docs/libcurl/opts/CURLOPT_UPKEEP_INTERVAL_MS.md
+++ b/docs/libcurl/opts/CURLOPT_UPKEEP_INTERVAL_MS.md
@@ -8,6 +8,7 @@ See-also:
   - CURLOPT_TCP_KEEPALIVE (3)
 Protocol:
   - All
+Added-in: 7.62.0
 ---
 
 # NAME
@@ -41,6 +42,8 @@ is called, an HTTP/2 PING frame is sent on the connection.
 
 CURL_UPKEEP_INTERVAL_DEFAULT (currently defined as 60000L, which is 60 seconds)
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -71,9 +74,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.62.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_UPLOAD.md b/docs/libcurl/opts/CURLOPT_UPLOAD.md
index de64ada85..4576d27ff 100644
--- a/docs/libcurl/opts/CURLOPT_UPLOAD.md
+++ b/docs/libcurl/opts/CURLOPT_UPLOAD.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_READFUNCTION (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -27,23 +28,25 @@ CURLcode curl_easy_setopt(CURL *handle, CURLOPT_UPLOAD, long upload);
 # DESCRIPTION
 
 The long parameter *upload* set to 1 tells the library to prepare for and
-perform an upload. The CURLOPT_READDATA(3) and
-CURLOPT_INFILESIZE(3) or CURLOPT_INFILESIZE_LARGE(3) options are
-also interesting for uploads. If the protocol is HTTP, uploading means using
-the PUT request unless you tell libcurl otherwise.
+perform an upload. The CURLOPT_READDATA(3) and CURLOPT_INFILESIZE(3) or
+CURLOPT_INFILESIZE_LARGE(3) options are also interesting for uploads. If the
+protocol is HTTP, uploading means using the PUT request unless you tell
+libcurl otherwise.
 
 Using PUT with HTTP 1.1 implies the use of a "Expect: 100-continue" header.
 You can disable this header with CURLOPT_HTTPHEADER(3) as usual.
 
 If you use PUT to an HTTP 1.1 server, you can upload data without knowing the
 size before starting the transfer. The library enables this by adding a header
-"Transfer-Encoding: chunked". With HTTP 1.0 or if you prefer not to use chunked
-transfer, you must specify the size of the data with
+"Transfer-Encoding: chunked". With HTTP 1.0 or if you prefer not to use
+chunked transfer, you must specify the size of the data with
 CURLOPT_INFILESIZE(3) or CURLOPT_INFILESIZE_LARGE(3).
 
 # DEFAULT
 
-0, default is download
+0
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -86,9 +89,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_UPLOAD_BUFFERSIZE.md b/docs/libcurl/opts/CURLOPT_UPLOAD_BUFFERSIZE.md
index e1cbf244a..72a4b64d5 100644
--- a/docs/libcurl/opts/CURLOPT_UPLOAD_BUFFERSIZE.md
+++ b/docs/libcurl/opts/CURLOPT_UPLOAD_BUFFERSIZE.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_TCP_NODELAY (3)
 Protocol:
   - All
+Added-in: 7.62.0
 ---
 
 # NAME
@@ -49,6 +50,8 @@ transfer as that may lead to unintended consequences.
 
 65536 bytes
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -69,9 +72,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.62.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_URL.md b/docs/libcurl/opts/CURLOPT_URL.md
index 2522d96ba..45d823987 100644
--- a/docs/libcurl/opts/CURLOPT_URL.md
+++ b/docs/libcurl/opts/CURLOPT_URL.md
@@ -10,12 +10,13 @@ See-also:
   - CURLOPT_FORBID_REUSE (3)
   - CURLOPT_FRESH_CONNECT (3)
   - CURLOPT_PATH_AS_IS (3)
-  - CURLOPT_PROTOCOLS (3)
+  - CURLOPT_PROTOCOLS_STR (3)
   - curl_easy_perform (3)
   - curl_url_get (3)
   - curl_url_set (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -87,8 +88,7 @@ specified when passed to the name resolver functions.
 
 # DEFAULT
 
-There is no default URL. If this option is not set, no transfer can be
-performed.
+NULL. If this option is not set, no transfer can be performed.
 
 # SECURITY CONCERNS
 
@@ -109,11 +109,13 @@ custom port number can allow external users to play tricks with your local
 services.
 
 Accepting external URLs may also use other protocols than http:// or other
-common ones. Restrict what accept with CURLOPT_PROTOCOLS(3).
+common ones. Restrict what accept with CURLOPT_PROTOCOLS_STR(3).
 
 User provided URLs can also be made to point to sites that redirect further on
 (possibly to other protocols too). Consider your
-CURLOPT_FOLLOWLOCATION(3) and CURLOPT_REDIR_PROTOCOLS(3) settings.
+CURLOPT_FOLLOWLOCATION(3) and CURLOPT_REDIR_PROTOCOLS_STR(3) settings.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -129,9 +131,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-POP3 and SMTP were added in 7.31.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_USERAGENT.md b/docs/libcurl/opts/CURLOPT_USERAGENT.md
index 757f3edbd..1aeb1c9ab 100644
--- a/docs/libcurl/opts/CURLOPT_USERAGENT.md
+++ b/docs/libcurl/opts/CURLOPT_USERAGENT.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_REQUEST_TARGET (3)
 Protocol:
   - HTTP
+Added-in: 7.1
 ---
 
 # NAME
@@ -36,7 +37,9 @@ option.
 
 # DEFAULT
 
-NULL, no User-Agent: header is used by default.
+NULL, no User-Agent: header is used.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -54,9 +57,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-As long as HTTP is supported
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_USERNAME.md b/docs/libcurl/opts/CURLOPT_USERNAME.md
index 34d0a6793..727421946 100644
--- a/docs/libcurl/opts/CURLOPT_USERNAME.md
+++ b/docs/libcurl/opts/CURLOPT_USERNAME.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_USERPWD (3)
 Protocol:
   - All
+Added-in: 7.19.1
 ---
 
 # NAME
@@ -60,6 +61,8 @@ option.
 
 blank
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -79,9 +82,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.19.1
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_USERPWD.md b/docs/libcurl/opts/CURLOPT_USERPWD.md
index 726ec3e72..3d5e34d01 100644
--- a/docs/libcurl/opts/CURLOPT_USERPWD.md
+++ b/docs/libcurl/opts/CURLOPT_USERPWD.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_USERNAME (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -66,6 +67,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -85,9 +88,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_USE_SSL.md b/docs/libcurl/opts/CURLOPT_USE_SSL.md
index acb99e080..c74be586b 100644
--- a/docs/libcurl/opts/CURLOPT_USE_SSL.md
+++ b/docs/libcurl/opts/CURLOPT_USE_SSL.md
@@ -13,6 +13,7 @@ Protocol:
   - SMTP
   - POP3
   - IMAP
+Added-in: 7.17.0
 ---
 
 # NAME
@@ -58,6 +59,8 @@ Require SSL for all communication or fail with *CURLE_USE_SSL_FAILED*.
 
 CURLUSESSL_NONE
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -76,11 +79,13 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
+
+This option was known as CURLOPT_FTP_SSL up to 7.16.4, and the constants were
+known as CURLFTPSSL_* Handled by LDAP since 7.81.0. Fully supported by the
+OpenLDAP backend only.
 
-Added in 7.11.0. This option was known as CURLOPT_FTP_SSL up to 7.16.4, and
-the constants were known as CURLFTPSSL_*
-Handled by LDAP since 7.81.0. Fully supported by the OpenLDAP backend only.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_VERBOSE.md b/docs/libcurl/opts/CURLOPT_VERBOSE.md
index a144d29f9..b242fcbc4 100644
--- a/docs/libcurl/opts/CURLOPT_VERBOSE.md
+++ b/docs/libcurl/opts/CURLOPT_VERBOSE.md
@@ -11,6 +11,7 @@ See-also:
   - curl_global_trace (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -42,6 +43,8 @@ CURLOPT_DEBUGFUNCTION(3).
 
 0, meaning disabled.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -60,9 +63,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Always
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_WILDCARDMATCH.md b/docs/libcurl/opts/CURLOPT_WILDCARDMATCH.md
index bfcc82fc7..e6ca3d655 100644
--- a/docs/libcurl/opts/CURLOPT_WILDCARDMATCH.md
+++ b/docs/libcurl/opts/CURLOPT_WILDCARDMATCH.md
@@ -11,6 +11,7 @@ See-also:
   - CURLOPT_URL (3)
 Protocol:
   - FTP
+Added-in: 7.21.0
 ---
 
 # NAME
@@ -76,6 +77,8 @@ Using the rules above, a filename pattern can be constructed:
 
     ftp://example.com/some/path/[a-z[:upper:]\\].jpg
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -100,9 +103,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.21.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_WRITEDATA.md b/docs/libcurl/opts/CURLOPT_WRITEDATA.md
index 66744abbe..c042a19e0 100644
--- a/docs/libcurl/opts/CURLOPT_WRITEDATA.md
+++ b/docs/libcurl/opts/CURLOPT_WRITEDATA.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_WRITEFUNCTION (3)
 Protocol:
   - All
+Added-in: 7.9.7
 ---
 
 # NAME
@@ -41,20 +42,24 @@ crashes.
 
 # DEFAULT
 
-By default, this is a FILE * to stdout.
+stdout
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
 A common technique is to use the write callback to store the incoming data
 into a dynamically growing allocated buffer, and then this
-CURLOPT_WRITEDATA(3) is used to point to a struct or the buffer to store
-data in. Like in the getinmemory example:
+CURLOPT_WRITEDATA(3) is used to point to a struct or the buffer to store data
+in. Like in the getinmemory example:
 https://curl.se/libcurl/c/getinmemory.html
 
-# AVAILABILITY
+# HISTORY
+
+This option was formerly known as CURLOPT_FILE, the name CURLOPT_WRITEDATA(3)
+was added in 7.9.7.
 
-Available in all libcurl versions. This option was formerly known as
-CURLOPT_FILE, the name CURLOPT_WRITEDATA(3) was added in 7.9.7.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_WRITEFUNCTION.md b/docs/libcurl/opts/CURLOPT_WRITEFUNCTION.md
index dbf4cb35e..022f5da0b 100644
--- a/docs/libcurl/opts/CURLOPT_WRITEFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_WRITEFUNCTION.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_WRITEDATA (3)
 Protocol:
   - All
+Added-in: 7.1
 ---
 
 # NAME
@@ -72,7 +73,9 @@ do that.
 
 # DEFAULT
 
-libcurl uses 'fwrite' as a callback by default.
+fwrite(3)
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -125,10 +128,12 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
 
 Support for the CURL_WRITEFUNC_PAUSE return code was added in version 7.18.0.
 
+# %AVAILABILITY%
+
 # RETURN VALUE
 
 This returns CURLE_OK.
diff --git a/docs/libcurl/opts/CURLOPT_WS_OPTIONS.md b/docs/libcurl/opts/CURLOPT_WS_OPTIONS.md
index 23db0a47b..3eba3705f 100644
--- a/docs/libcurl/opts/CURLOPT_WS_OPTIONS.md
+++ b/docs/libcurl/opts/CURLOPT_WS_OPTIONS.md
@@ -10,6 +10,7 @@ See-also:
   - curl_ws_send (3)
 Protocol:
   - WS
+Added-in: 7.86.0
 ---
 
 # NAME
@@ -47,6 +48,8 @@ application.
 
 0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.86.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_XFERINFODATA.md b/docs/libcurl/opts/CURLOPT_XFERINFODATA.md
index 126dc11a4..4ed174eff 100644
--- a/docs/libcurl/opts/CURLOPT_XFERINFODATA.md
+++ b/docs/libcurl/opts/CURLOPT_XFERINFODATA.md
@@ -10,6 +10,7 @@ See-also:
   - CURLOPT_XFERINFOFUNCTION (3)
 Protocol:
   - All
+Added-in: 7.32.0
 ---
 
 # NAME
@@ -33,7 +34,9 @@ This is an alias for CURLOPT_PROGRESSDATA(3).
 
 # DEFAULT
 
-The default value of this parameter is NULL.
+NULL
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -69,9 +72,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.32.0
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_XFERINFOFUNCTION.md b/docs/libcurl/opts/CURLOPT_XFERINFOFUNCTION.md
index fd1fd2cb2..a7c130a50 100644
--- a/docs/libcurl/opts/CURLOPT_XFERINFOFUNCTION.md
+++ b/docs/libcurl/opts/CURLOPT_XFERINFOFUNCTION.md
@@ -9,6 +9,7 @@ See-also:
   - CURLOPT_XFERINFODATA (3)
 Protocol:
   - All
+Added-in: 7.32.0
 ---
 
 # NAME
@@ -70,8 +71,9 @@ get called.
 
 # DEFAULT
 
-By default, libcurl has an internal progress meter. That is rarely wanted by
-users.
+NULL - use the internal progress meter. That is rarely wanted by users.
+
+# %PROTOCOLS%
 
 # EXAMPLE
 
@@ -112,9 +114,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.32.0. This callback replaces CURLOPT_PROGRESSFUNCTION(3)
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLOPT_XOAUTH2_BEARER.md b/docs/libcurl/opts/CURLOPT_XOAUTH2_BEARER.md
index 8ae9901d6..061a1f69b 100644
--- a/docs/libcurl/opts/CURLOPT_XOAUTH2_BEARER.md
+++ b/docs/libcurl/opts/CURLOPT_XOAUTH2_BEARER.md
@@ -13,6 +13,7 @@ Protocol:
   - LDAP
   - POP3
   - SMTP
+Added-in: 7.33.0
 ---
 
 # NAME
@@ -43,6 +44,8 @@ option.
 
 NULL
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -59,9 +62,11 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
+# HISTORY
+
+Support for OpenLDAP added in 7.82.0.
 
-Added in 7.33.0. Support for OpenLDAP added in 7.82.0.
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLSHOPT_LOCKFUNC.md b/docs/libcurl/opts/CURLSHOPT_LOCKFUNC.md
index 46e210ad5..208dfdd62 100644
--- a/docs/libcurl/opts/CURLSHOPT_LOCKFUNC.md
+++ b/docs/libcurl/opts/CURLSHOPT_LOCKFUNC.md
@@ -11,6 +11,7 @@ See-also:
   - curl_share_setopt (3)
 Protocol:
   - All
+Added-in: 7.10.3
 ---
 
 # NAME
@@ -48,6 +49,8 @@ sure that the callback uses a different lock for each kind of data.
 *clientp* is the private pointer you set with CURLSHOPT_USERDATA(3).
 This pointer is not used by libcurl itself.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -64,9 +67,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLSHOPT_SHARE.md b/docs/libcurl/opts/CURLSHOPT_SHARE.md
index 6fb9b826f..fa6838cb8 100644
--- a/docs/libcurl/opts/CURLSHOPT_SHARE.md
+++ b/docs/libcurl/opts/CURLSHOPT_SHARE.md
@@ -11,6 +11,7 @@ See-also:
   - curl_share_setopt (3)
 Protocol:
   - All
+Added-in: 7.10.3
 ---
 
 # NAME
@@ -40,6 +41,8 @@ Cookie data is shared across the easy handles using this shared object. Note
 that this does not activate an easy handle's cookie handling. You can do that
 separately by using CURLOPT_COOKIEFILE(3) for example.
 
+It is not supported to share cookies between multiple concurrent threads.
+
 ## CURL_LOCK_DATA_DNS
 
 Cached DNS hosts are shared across the easy handles using this shared
@@ -54,6 +57,8 @@ the same server. Note SSL session IDs are reused within the same easy handle
 by default. Note this symbol was added in 7.10.3 but was not implemented until
 7.23.0.
 
+It is not supported to share SSL sessions between multiple concurrent threads.
+
 ## CURL_LOCK_DATA_CONNECT
 
 Put the connection cache in the share object and make all easy handles using
@@ -91,6 +96,8 @@ It is not supported to share the HSTS between multiple concurrent threads.
 
 Added in 7.88.0
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -104,9 +111,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLSHOPT_UNLOCKFUNC.md b/docs/libcurl/opts/CURLSHOPT_UNLOCKFUNC.md
index ae8ecb779..503918231 100644
--- a/docs/libcurl/opts/CURLSHOPT_UNLOCKFUNC.md
+++ b/docs/libcurl/opts/CURLSHOPT_UNLOCKFUNC.md
@@ -11,6 +11,7 @@ See-also:
   - curl_share_setopt (3)
 Protocol:
   - All
+Added-in: 7.10.3
 ---
 
 # NAME
@@ -44,6 +45,8 @@ sure that the callback uses a different lock for each kind of data.
 *clientp* is the private pointer you set with CURLSHOPT_USERDATA(3).
 This pointer is not used by libcurl itself.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -59,9 +62,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLSHOPT_UNSHARE.md b/docs/libcurl/opts/CURLSHOPT_UNSHARE.md
index 69ee517c7..43edb4d25 100644
--- a/docs/libcurl/opts/CURLSHOPT_UNSHARE.md
+++ b/docs/libcurl/opts/CURLSHOPT_UNSHARE.md
@@ -11,6 +11,7 @@ See-also:
   - curl_share_setopt (3)
 Protocol:
   - All
+Added-in: 7.10.3
 ---
 
 # NAME
@@ -58,6 +59,8 @@ The connection cache is no longer shared.
 
 The Public Suffix List is no longer shared.
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -71,9 +74,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/CURLSHOPT_USERDATA.md b/docs/libcurl/opts/CURLSHOPT_USERDATA.md
index 9cd042ec5..5796ce21b 100644
--- a/docs/libcurl/opts/CURLSHOPT_USERDATA.md
+++ b/docs/libcurl/opts/CURLSHOPT_USERDATA.md
@@ -11,6 +11,7 @@ See-also:
   - curl_share_setopt (3)
 Protocol:
   - All
+Added-in: 7.10.3
 ---
 
 # NAME
@@ -31,6 +32,8 @@ The *clientp* parameter is held verbatim by libcurl and is passed on as
 the *clientp* argument to the callbacks set with
 CURLSHOPT_LOCKFUNC(3) and CURLSHOPT_UNLOCKFUNC(3).
 
+# %PROTOCOLS%
+
 # EXAMPLE
 
 ~~~c
@@ -49,9 +52,7 @@ int main(void)
 }
 ~~~
 
-# AVAILABILITY
-
-Added in 7.10
+# %AVAILABILITY%
 
 # RETURN VALUE
 
diff --git a/docs/libcurl/opts/Makefile.inc b/docs/libcurl/opts/Makefile.inc
index bf5ea7645..f09c5863d 100644
--- a/docs/libcurl/opts/Makefile.inc
+++ b/docs/libcurl/opts/Makefile.inc
@@ -384,6 +384,7 @@ man_MANS =                                      \
   CURLOPT_TCP_KEEPALIVE.3                       \
   CURLOPT_TCP_KEEPIDLE.3                        \
   CURLOPT_TCP_KEEPINTVL.3                       \
+  CURLOPT_TCP_KEEPCNT.3                         \
   CURLOPT_TCP_NODELAY.3                         \
   CURLOPT_TELNETOPTIONS.3                       \
   CURLOPT_TFTP_BLKSIZE.3                        \
diff --git a/docs/libcurl/symbols-in-versions b/docs/libcurl/symbols-in-versions
index e5531df92..ebf2cee29 100644
--- a/docs/libcurl/symbols-in-versions
+++ b/docs/libcurl/symbols-in-versions
@@ -864,6 +864,7 @@ CURLOPT_TCP_FASTOPEN            7.49.0
 CURLOPT_TCP_KEEPALIVE           7.25.0
 CURLOPT_TCP_KEEPIDLE            7.25.0
 CURLOPT_TCP_KEEPINTVL           7.25.0
+CURLOPT_TCP_KEEPCNT             8.9.0
 CURLOPT_TCP_NODELAY             7.11.2
 CURLOPT_TELNETOPTIONS           7.7
 CURLOPT_TFTP_BLKSIZE            7.19.4
@@ -1068,6 +1069,7 @@ CURLU_GET_EMPTY                 8.8.0
 CURLU_GUESS_SCHEME              7.62.0
 CURLU_NO_AUTHORITY              7.67.0
 CURLU_NO_DEFAULT_PORT           7.62.0
+CURLU_NO_GUESS_SCHEME           8.9.0
 CURLU_NON_SUPPORT_SCHEME        7.62.0
 CURLU_PATH_AS_IS                7.62.0
 CURLU_PUNY2IDN                  8.3.0
diff --git a/docs/mk-ca-bundle.md b/docs/mk-ca-bundle.md
index 8a8130998..fe6863526 100644
--- a/docs/mk-ca-bundle.md
+++ b/docs/mk-ca-bundle.md
@@ -6,6 +6,7 @@ Section: 1
 Source: mk-ca-bundle
 See-also:
   - curl (1)
+Added-in: n/a
 ---
 
 # NAME
diff --git a/docs/options-in-versions b/docs/options-in-versions
index d3513ff11..e329f8723 100644
--- a/docs/options-in-versions
+++ b/docs/options-in-versions
@@ -98,6 +98,7 @@
 --http3                              7.66.0
 --http3-only                         7.88.0
 --ignore-content-length              7.14.1
+--ip-tos                             8.9.0
 --ipfs-gateway                       8.4.0
 --include (-i)                       4.8
 --insecure (-k)                      7.10
@@ -106,6 +107,7 @@
 --ipv6 (-6)                          7.10.8
 --json                               7.82.0
 --junk-session-cookies (-j)          7.9.7
+--keepalive-cnt                      8.9.0
 --keepalive-time                     7.18.0
 --key                                7.9.3
 --key-type                           7.9.3
@@ -126,6 +128,7 @@
 --max-redirs                         7.5
 --max-time (-m)                      4.0
 --metalink                           7.27.0
+--mptcp                              8.9.0
 --negotiate                          7.10.6
 --netrc (-n)                         4.6
 --netrc-file                         7.21.5
@@ -267,5 +270,6 @@
 --variable                           8.3.0
 --verbose (-v)                       4.0
 --version (-V)                       4.0
+--vlan-priority                      8.9.0
 --write-out (-w)                     6.5
 --xattr                              7.21.3
diff --git a/include/README.md b/include/README.md
index c96593263..b155d8c13 100644
--- a/include/README.md
+++ b/include/README.md
@@ -8,7 +8,7 @@ SPDX-License-Identifier: curl
 
 Public include files for libcurl, external users.
 
-They're all placed in the curl subdirectory here for better fit in any kind of
+They are all placed in the curl subdirectory here for better fit in any kind of
 environment. You must include files from here using...
 
     #include <curl/curl.h>
diff --git a/include/curl/Makefile.am b/include/curl/Makefile.am
index a655aff1c..8864d60e1 100644
--- a/include/curl/Makefile.am
+++ b/include/curl/Makefile.am
@@ -35,7 +35,7 @@ CS_ = $(CS_0)
 checksrc:
 	$(CHECKSRC)@PERL@ $(top_srcdir)/scripts/checksrc.pl -D$(top_srcdir)/include/curl $(pkginclude_HEADERS)
 
-if CURLDEBUG
+if DEBUGBUILD
 # for debug builds, we scan the sources on all regular make invokes
 all-local: checksrc
 endif
diff --git a/include/curl/curl.h b/include/curl/curl.h
index 91e11f62d..6da44ce9b 100644
--- a/include/curl/curl.h
+++ b/include/curl/curl.h
@@ -34,24 +34,32 @@
 #endif
 
 /* Compile-time deprecation macros. */
-#if defined(__GNUC__) &&                                                \
-  ((__GNUC__ > 12) || ((__GNUC__ == 12) && (__GNUC_MINOR__ >= 1 ))) &&  \
+#if (defined(__GNUC__) &&                                               \
+  ((__GNUC__ > 12) || ((__GNUC__ == 12) && (__GNUC_MINOR__ >= 1 ))) ||  \
+  defined(__IAR_SYSTEMS_ICC__)) &&                                      \
   !defined(__INTEL_COMPILER) &&                                         \
   !defined(CURL_DISABLE_DEPRECATION) && !defined(BUILDING_LIBCURL)
 #define CURL_DEPRECATED(version, message)                       \
   __attribute__((deprecated("since " # version ". " message)))
+#if defined(__IAR_SYSTEMS_ICC__)
+#define CURL_IGNORE_DEPRECATION(statements) \
+      _Pragma("diag_suppress=Pe1444") \
+      statements \
+      _Pragma("diag_default=Pe1444")
+#else
 #define CURL_IGNORE_DEPRECATION(statements) \
       _Pragma("GCC diagnostic push") \
       _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"") \
       statements \
       _Pragma("GCC diagnostic pop")
+#endif
 #else
 #define CURL_DEPRECATED(version, message)
 #define CURL_IGNORE_DEPRECATION(statements)     statements
 #endif
 
 #include "curlver.h"         /* libcurl version defines   */
-#include "system.h"          /* determine things run-time */
+#include "system.h"          /* determine things runtime */
 
 #include <stdio.h>
 #include <limits.h>
@@ -69,7 +77,7 @@
 #if !(defined(_WINSOCKAPI_) || defined(_WINSOCK_H) || \
       defined(__LWIP_OPT_H__) || defined(LWIP_HDR_OPT_H))
 /* The check above prevents the winsock2 inclusion if winsock.h already was
-   included, since they can't co-exist without problems */
+   included, since they cannot co-exist without problems */
 #include <winsock2.h>
 #include <ws2tcpip.h>
 #endif
@@ -189,9 +197,9 @@ struct curl_httppost {
                                        files */
   long flags;                       /* as defined below */
 
-/* specified content is a file name */
+/* specified content is a filename */
 #define CURL_HTTPPOST_FILENAME (1<<0)
-/* specified content is a file name */
+/* specified content is a filename */
 #define CURL_HTTPPOST_READFILE (1<<1)
 /* name is only stored pointer do not free in formfree */
 #define CURL_HTTPPOST_PTRNAME (1<<2)
@@ -207,8 +215,8 @@ struct curl_httppost {
 /* use size in 'contentlen', added in 7.46.0 */
 #define CURL_HTTPPOST_LARGE (1<<7)
 
-  char *showfilename;               /* The file name to show. If not set, the
-                                       actual file name will be used (if this
+  char *showfilename;               /* The filename to show. If not set, the
+                                       actual filename will be used (if this
                                        is a file part) */
   void *userp;                      /* custom pointer used for
                                        HTTPPOST_CALLBACK posts */
@@ -350,13 +358,13 @@ typedef long (*curl_chunk_bgn_callback)(const void *transfer_info,
    download of an individual chunk finished.
    Note! After this callback was set then it have to be called FOR ALL chunks.
    Even if downloading of this chunk was skipped in CHUNK_BGN_FUNC.
-   This is the reason why we don't need "transfer_info" parameter in this
+   This is the reason why we do not need "transfer_info" parameter in this
    callback and we are not interested in "remains" parameter too. */
 typedef long (*curl_chunk_end_callback)(void *ptr);
 
 /* return codes for FNMATCHFUNCTION */
 #define CURL_FNMATCHFUNC_MATCH    0 /* string corresponds to the pattern */
-#define CURL_FNMATCHFUNC_NOMATCH  1 /* pattern doesn't match the string */
+#define CURL_FNMATCHFUNC_NOMATCH  1 /* pattern does not match the string */
 #define CURL_FNMATCHFUNC_FAIL     2 /* an error occurred */
 
 /* callback type for wildcard downloading pattern matching. If the
@@ -368,7 +376,7 @@ typedef int (*curl_fnmatch_callback)(void *ptr,
 /* These are the return codes for the seek callbacks */
 #define CURL_SEEKFUNC_OK       0
 #define CURL_SEEKFUNC_FAIL     1 /* fail the entire transfer */
-#define CURL_SEEKFUNC_CANTSEEK 2 /* tell libcurl seeking can't be done, so
+#define CURL_SEEKFUNC_CANTSEEK 2 /* tell libcurl seeking cannot be done, so
                                     libcurl might try other means instead */
 typedef int (*curl_seek_callback)(void *instream,
                                   curl_off_t offset,
@@ -451,7 +459,7 @@ typedef curlioerr (*curl_ioctl_callback)(CURL *handle,
 #ifndef CURL_DID_MEMORY_FUNC_TYPEDEFS
 /*
  * The following typedef's are signatures of malloc, free, realloc, strdup and
- * calloc respectively.  Function pointers of these types can be passed to the
+ * calloc respectively. Function pointers of these types can be passed to the
  * curl_global_init_mem() function to set user defined memory management
  * callback routines.
  */
@@ -539,17 +547,17 @@ typedef enum {
   CURLE_WRITE_ERROR,             /* 23 */
   CURLE_OBSOLETE24,              /* 24 - NOT USED */
   CURLE_UPLOAD_FAILED,           /* 25 - failed upload "command" */
-  CURLE_READ_ERROR,              /* 26 - couldn't open/read from file */
+  CURLE_READ_ERROR,              /* 26 - could not open/read from file */
   CURLE_OUT_OF_MEMORY,           /* 27 */
   CURLE_OPERATION_TIMEDOUT,      /* 28 - the timeout time was reached */
   CURLE_OBSOLETE29,              /* 29 - NOT USED */
   CURLE_FTP_PORT_FAILED,         /* 30 - FTP PORT operation failed */
   CURLE_FTP_COULDNT_USE_REST,    /* 31 - the REST command failed */
   CURLE_OBSOLETE32,              /* 32 - NOT USED */
-  CURLE_RANGE_ERROR,             /* 33 - RANGE "command" didn't work */
+  CURLE_RANGE_ERROR,             /* 33 - RANGE "command" did not work */
   CURLE_HTTP_POST_ERROR,         /* 34 */
   CURLE_SSL_CONNECT_ERROR,       /* 35 - wrong when connecting with SSL */
-  CURLE_BAD_DOWNLOAD_RESUME,     /* 36 - couldn't resume download */
+  CURLE_BAD_DOWNLOAD_RESUME,     /* 36 - could not resume download */
   CURLE_FILE_COULDNT_READ_FILE,  /* 37 */
   CURLE_LDAP_CANNOT_BIND,        /* 38 */
   CURLE_LDAP_SEARCH_FAILED,      /* 39 */
@@ -573,9 +581,9 @@ typedef enum {
   CURLE_RECV_ERROR,              /* 56 - failure in receiving network data */
   CURLE_OBSOLETE57,              /* 57 - NOT IN USE */
   CURLE_SSL_CERTPROBLEM,         /* 58 - problem with the local certificate */
-  CURLE_SSL_CIPHER,              /* 59 - couldn't use specified cipher */
+  CURLE_SSL_CIPHER,              /* 59 - could not use specified cipher */
   CURLE_PEER_FAILED_VERIFICATION, /* 60 - peer's certificate or fingerprint
-                                     wasn't verified fine */
+                                     was not verified fine */
   CURLE_BAD_CONTENT_ENCODING,    /* 61 - Unrecognized/bad encoding */
   CURLE_OBSOLETE62,              /* 62 - NOT IN USE since 7.82.0 */
   CURLE_FILESIZE_EXCEEDED,       /* 63 - Maximum file size exceeded */
@@ -604,7 +612,7 @@ typedef enum {
   CURLE_SSL_SHUTDOWN_FAILED,     /* 80 - Failed to shut down the SSL
                                     connection */
   CURLE_AGAIN,                   /* 81 - socket is not ready for send/recv,
-                                    wait till it's ready and try again (Added
+                                    wait till it is ready and try again (Added
                                     in 7.18.2) */
   CURLE_SSL_CRL_BADFILE,         /* 82 - could not load CRL file, missing or
                                     wrong format (Added in 7.19.0) */
@@ -763,7 +771,7 @@ typedef CURLcode (*curl_conv_callback)(char *buffer, size_t length);
 
 typedef CURLcode (*curl_ssl_ctx_callback)(CURL *curl,    /* easy handle */
                                           void *ssl_ctx, /* actually an OpenSSL
-                                                            or WolfSSL SSL_CTX,
+                                                            or wolfSSL SSL_CTX,
                                                             or an mbedTLS
                                                           mbedtls_ssl_config */
                                           void *userptr);
@@ -780,7 +788,7 @@ typedef enum {
   CURLPROXY_SOCKS5 = 5, /* added in 7.10 */
   CURLPROXY_SOCKS4A = 6, /* added in 7.18.0 */
   CURLPROXY_SOCKS5_HOSTNAME = 7 /* Use the SOCKS5 protocol but pass along the
-                                   host name rather than the IP address. added
+                                   hostname rather than the IP address. added
                                    in 7.18.0 */
 } curl_proxytype;  /* this enum was added in 7.10 */
 
@@ -860,7 +868,7 @@ enum curl_khstat {
   CURLKHSTAT_FINE_ADD_TO_FILE,
   CURLKHSTAT_FINE,
   CURLKHSTAT_REJECT, /* reject the connection, return an error */
-  CURLKHSTAT_DEFER,  /* do not accept it, but we can't answer right now.
+  CURLKHSTAT_DEFER,  /* do not accept it, but we cannot answer right now.
                         Causes a CURLE_PEER_FAILED_VERIFICATION error but the
                         connection will be left intact etc */
   CURLKHSTAT_FINE_REPLACE, /* accept and replace the wrong key */
@@ -1080,7 +1088,7 @@ typedef CURLSTScode (*curl_hstswrite_callback)(CURL *easy,
 #define CURLOPT(na,t,nu) na = t + nu
 #define CURLOPTDEPRECATED(na,t,nu,v,m) na CURL_DEPRECATED(v,m) = t + nu
 
-/* CURLOPT aliases that make no run-time difference */
+/* CURLOPT aliases that make no runtime difference */
 
 /* 'char *' argument to a string with a trailing zero */
 #define CURLOPTTYPE_STRINGPOINT CURLOPTTYPE_OBJECTPOINT
@@ -1147,7 +1155,7 @@ typedef enum {
    *
    * For large file support, there is also a _LARGE version of the key
    * which takes an off_t type, allowing platforms with larger off_t
-   * sizes to handle larger files.  See below for INFILESIZE_LARGE.
+   * sizes to handle larger files. See below for INFILESIZE_LARGE.
    */
   CURLOPT(CURLOPT_INFILESIZE, CURLOPTTYPE_LONG, 14),
 
@@ -1180,7 +1188,7 @@ typedef enum {
    *
    * Note there is also a _LARGE version of this key which uses
    * off_t types, allowing for large file offsets on platforms which
-   * use larger-than-32-bit off_t's.  Look below for RESUME_FROM_LARGE.
+   * use larger-than-32-bit off_t's. Look below for RESUME_FROM_LARGE.
    */
   CURLOPT(CURLOPT_RESUME_FROM, CURLOPTTYPE_LONG, 21),
 
@@ -1316,9 +1324,9 @@ typedef enum {
   /* Set the interface string to use as outgoing network interface */
   CURLOPT(CURLOPT_INTERFACE, CURLOPTTYPE_STRINGPOINT, 62),
 
-  /* Set the krb4/5 security level, this also enables krb4/5 awareness.  This
-   * is a string, 'clear', 'safe', 'confidential' or 'private'.  If the string
-   * is set but doesn't match one of these, 'private' will be used.  */
+  /* Set the krb4/5 security level, this also enables krb4/5 awareness. This
+   * is a string, 'clear', 'safe', 'confidential' or 'private'. If the string
+   * is set but does not match one of these, 'private' will be used.  */
   CURLOPT(CURLOPT_KRBLEVEL, CURLOPTTYPE_STRINGPOINT, 63),
 
   /* Set if we should verify the peer in ssl handshake, set 1 to verify. */
@@ -1350,16 +1358,16 @@ typedef enum {
   /* 73 = OBSOLETE */
 
   /* Set to explicitly use a new connection for the upcoming transfer.
-     Do not use this unless you're absolutely sure of this, as it makes the
+     Do not use this unless you are absolutely sure of this, as it makes the
      operation slower and is less friendly for the network. */
   CURLOPT(CURLOPT_FRESH_CONNECT, CURLOPTTYPE_LONG, 74),
 
   /* Set to explicitly forbid the upcoming transfer's connection to be reused
-     when done. Do not use this unless you're absolutely sure of this, as it
+     when done. Do not use this unless you are absolutely sure of this, as it
      makes the operation slower and is less friendly for the network. */
   CURLOPT(CURLOPT_FORBID_REUSE, CURLOPTTYPE_LONG, 75),
 
-  /* Set to a file name that contains random data for libcurl to use to
+  /* Set to a filename that contains random data for libcurl to use to
      seed the random engine when doing SSL connects. */
   CURLOPTDEPRECATED(CURLOPT_RANDOM_FILE, CURLOPTTYPE_STRINGPOINT, 76,
                     7.84.0, "Serves no purpose anymore"),
@@ -1386,8 +1394,8 @@ typedef enum {
    * provided hostname. */
   CURLOPT(CURLOPT_SSL_VERIFYHOST, CURLOPTTYPE_LONG, 81),
 
-  /* Specify which file name to write all known cookies in after completed
-     operation. Set file name to "-" (dash) to make it go to stdout. */
+  /* Specify which filename to write all known cookies in after completed
+     operation. Set filename to "-" (dash) to make it go to stdout. */
   CURLOPT(CURLOPT_COOKIEJAR, CURLOPTTYPE_STRINGPOINT, 82),
 
   /* Specify which SSL ciphers to use */
@@ -1486,7 +1494,7 @@ typedef enum {
   CURLOPT(CURLOPT_HTTPAUTH, CURLOPTTYPE_VALUES, 107),
 
   /* Set the ssl context callback function, currently only for OpenSSL or
-     WolfSSL ssl_ctx, or mbedTLS mbedtls_ssl_config in the second argument.
+     wolfSSL ssl_ctx, or mbedTLS mbedtls_ssl_config in the second argument.
      The function must match the curl_ssl_ctx_callback prototype. */
   CURLOPT(CURLOPT_SSL_CTX_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 108),
 
@@ -1506,7 +1514,7 @@ typedef enum {
   CURLOPT(CURLOPT_PROXYAUTH, CURLOPTTYPE_VALUES, 111),
 
   /* Option that changes the timeout, in seconds, associated with getting a
-     response.  This is different from transfer timeout time and essentially
+     response. This is different from transfer timeout time and essentially
      places a demand on the server to acknowledge commands in a timely
      manner. For FTP, SMTP, IMAP and POP3. */
   CURLOPT(CURLOPT_SERVER_RESPONSE_TIMEOUT, CURLOPTTYPE_LONG, 112),
@@ -1520,7 +1528,7 @@ typedef enum {
      an HTTP or FTP server.
 
      Note there is also _LARGE version which adds large file support for
-     platforms which have larger off_t sizes.  See MAXFILESIZE_LARGE below. */
+     platforms which have larger off_t sizes. See MAXFILESIZE_LARGE below. */
   CURLOPT(CURLOPT_MAXFILESIZE, CURLOPTTYPE_LONG, 114),
 
   /* See the comment for INFILESIZE above, but in short, specifies
@@ -1528,17 +1536,17 @@ typedef enum {
    */
   CURLOPT(CURLOPT_INFILESIZE_LARGE, CURLOPTTYPE_OFF_T, 115),
 
-  /* Sets the continuation offset.  There is also a CURLOPTTYPE_LONG version
+  /* Sets the continuation offset. There is also a CURLOPTTYPE_LONG version
    * of this; look above for RESUME_FROM.
    */
   CURLOPT(CURLOPT_RESUME_FROM_LARGE, CURLOPTTYPE_OFF_T, 116),
 
   /* Sets the maximum size of data that will be downloaded from
-   * an HTTP or FTP server.  See MAXFILESIZE above for the LONG version.
+   * an HTTP or FTP server. See MAXFILESIZE above for the LONG version.
    */
   CURLOPT(CURLOPT_MAXFILESIZE_LARGE, CURLOPTTYPE_OFF_T, 117),
 
-  /* Set this option to the file name of your .netrc file you want libcurl
+  /* Set this option to the filename of your .netrc file you want libcurl
      to parse (using the CURLOPT_NETRC option). If not set, libcurl will do
      a poor attempt to find the user's home directory and check for a .netrc
      file in there. */
@@ -1685,7 +1693,7 @@ typedef enum {
 
   /* Callback function for opening socket (instead of socket(2)). Optionally,
      callback is able change the address or refuse to connect returning
-     CURL_SOCKET_BAD.  The callback should have type
+     CURL_SOCKET_BAD. The callback should have type
      curl_opensocket_callback */
   CURLOPT(CURLOPT_OPENSOCKETFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 163),
   CURLOPT(CURLOPT_OPENSOCKETDATA, CURLOPTTYPE_CBPOINT, 164),
@@ -1755,7 +1763,7 @@ typedef enum {
   CURLOPTDEPRECATED(CURLOPT_REDIR_PROTOCOLS, CURLOPTTYPE_LONG, 182,
                     7.85.0, "Use CURLOPT_REDIR_PROTOCOLS_STR"),
 
-  /* set the SSH knownhost file name to use */
+  /* set the SSH knownhost filename to use */
   CURLOPT(CURLOPT_SSH_KNOWNHOSTS, CURLOPTTYPE_STRINGPOINT, 183),
 
   /* set the SSH host key callback, must point to a curl_sshkeycallback
@@ -1836,7 +1844,7 @@ typedef enum {
      future libcurl release.
 
      libcurl will ask for the compressed methods it knows of, and if that
-     isn't any, it will not ask for transfer-encoding at all even if this
+     is not any, it will not ask for transfer-encoding at all even if this
      option is set to 1.
 
   */
@@ -1938,7 +1946,7 @@ typedef enum {
   /* Service Name */
   CURLOPT(CURLOPT_SERVICE_NAME, CURLOPTTYPE_STRINGPOINT, 236),
 
-  /* Wait/don't wait for pipe/mutex to clarify */
+  /* Wait/do not wait for pipe/mutex to clarify */
   CURLOPT(CURLOPT_PIPEWAIT, CURLOPTTYPE_LONG, 237),
 
   /* Set the protocol used when curl is given a URL without a protocol */
@@ -2099,7 +2107,7 @@ typedef enum {
   /* alt-svc control bitmask */
   CURLOPT(CURLOPT_ALTSVC_CTRL, CURLOPTTYPE_LONG, 286),
 
-  /* alt-svc cache file name to possibly read from/write to */
+  /* alt-svc cache filename to possibly read from/write to */
   CURLOPT(CURLOPT_ALTSVC, CURLOPTTYPE_STRINGPOINT, 287),
 
   /* maximum age (idle time) of a connection to consider it for reuse
@@ -2125,13 +2133,13 @@ typedef enum {
 
   /* the EC curves requested by the TLS client (RFC 8422, 5.1);
    * OpenSSL support via 'set_groups'/'set_curves':
-   * https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set1_groups.html
+   * https://docs.openssl.org/master/man3/SSL_CTX_set1_curves/
    */
   CURLOPT(CURLOPT_SSL_EC_CURVES, CURLOPTTYPE_STRINGPOINT, 298),
 
   /* HSTS bitmask */
   CURLOPT(CURLOPT_HSTS_CTRL, CURLOPTTYPE_LONG, 299),
-  /* HSTS file name */
+  /* HSTS filename */
   CURLOPT(CURLOPT_HSTS, CURLOPTTYPE_STRINGPOINT, 300),
 
   /* HSTS read callback */
@@ -2210,9 +2218,12 @@ typedef enum {
   /* millisecond version */
   CURLOPT(CURLOPT_SERVER_RESPONSE_TIMEOUT_MS, CURLOPTTYPE_LONG, 324),
 
-  /* set ECH configuration  */
+  /* set ECH configuration */
   CURLOPT(CURLOPT_ECH, CURLOPTTYPE_STRINGPOINT, 325),
 
+  /* maximum number of keepalive probes (Linux, *BSD, macOS, etc.) */
+  CURLOPT(CURLOPT_TCP_KEEPCNT, CURLOPTTYPE_LONG, 326),
+
   CURLOPT_LASTENTRY /* the last unused */
 } CURLoption;
 
@@ -2263,9 +2274,9 @@ typedef enum {
 
   /* These enums are for use with the CURLOPT_HTTP_VERSION option. */
 enum {
-  CURL_HTTP_VERSION_NONE, /* setting this means we don't care, and that we'd
-                             like the library to choose the best possible
-                             for us! */
+  CURL_HTTP_VERSION_NONE, /* setting this means we do not care, and that we
+                             would like the library to choose the best
+                             possible for us! */
   CURL_HTTP_VERSION_1_0,  /* please use HTTP 1.0 in the request */
   CURL_HTTP_VERSION_1_1,  /* please use HTTP 1.1 in the request */
   CURL_HTTP_VERSION_2_0,  /* please use HTTP 2 in the request */
@@ -2425,7 +2436,7 @@ CURL_EXTERN CURLcode curl_mime_name(curl_mimepart *part, const char *name);
  *
  * DESCRIPTION
  *
- * Set mime part remote file name.
+ * Set mime part remote filename.
  */
 CURL_EXTERN CURLcode curl_mime_filename(curl_mimepart *part,
                                         const char *filename);
@@ -2706,10 +2717,10 @@ CURL_EXTERN CURLcode curl_global_init(long flags);
  * DESCRIPTION
  *
  * curl_global_init() or curl_global_init_mem() should be invoked exactly once
- * for each application that uses libcurl.  This function can be used to
+ * for each application that uses libcurl. This function can be used to
  * initialize libcurl and set user defined memory management callback
- * functions.  Users can implement memory management routines to check for
- * memory leaks, check for mis-use of the curl library etc.  User registered
+ * functions. Users can implement memory management routines to check for
+ * memory leaks, check for mis-use of the curl library etc. User registered
  * callback routines will be invoked by this library instead of the system
  * memory management routines like malloc, free etc.
  */
@@ -2827,7 +2838,7 @@ CURL_EXTERN time_t curl_getdate(const char *p, const time_t *unused);
    for with CURLOPT_CERTINFO / CURLINFO_CERTINFO */
 struct curl_certinfo {
   int num_of_certs;             /* number of certificates with information */
-  struct curl_slist **certinfo; /* for each index in this array, there's a
+  struct curl_slist **certinfo; /* for each index in this array, there is a
                                    linked list with textual information for a
                                    certificate in the format "name:content".
                                    eg "Subject:foo", "Issuer:bar", etc. */
@@ -3018,7 +3029,7 @@ typedef enum {
 } CURLSHcode;
 
 typedef enum {
-  CURLSHOPT_NONE,  /* don't use */
+  CURLSHOPT_NONE,  /* do not use */
   CURLSHOPT_SHARE,   /* specify a data type to share */
   CURLSHOPT_UNSHARE, /* specify which data type to stop sharing */
   CURLSHOPT_LOCKFUNC,   /* pass in a 'curl_lock_function' pointer */
@@ -3177,7 +3188,7 @@ CURL_EXTERN curl_version_info_data *curl_version_info(CURLversion);
  * DESCRIPTION
  *
  * The curl_easy_strerror function may be used to turn a CURLcode value
- * into the equivalent human readable error string.  This is useful
+ * into the equivalent human readable error string. This is useful
  * for printing meaningful error messages.
  */
 CURL_EXTERN const char *curl_easy_strerror(CURLcode);
@@ -3188,7 +3199,7 @@ CURL_EXTERN const char *curl_easy_strerror(CURLcode);
  * DESCRIPTION
  *
  * The curl_share_strerror function may be used to turn a CURLSHcode value
- * into the equivalent human readable error string.  This is useful
+ * into the equivalent human readable error string. This is useful
  * for printing meaningful error messages.
  */
 CURL_EXTERN const char *curl_share_strerror(CURLSHcode);
@@ -3227,7 +3238,7 @@ CURL_EXTERN CURLcode curl_easy_pause(CURL *handle, int bitmask);
 #include "websockets.h"
 #include "mprintf.h"
 
-/* the typechecker doesn't work in C++ (yet) */
+/* the typechecker does not work in C++ (yet) */
 #if defined(__GNUC__) && defined(__GNUC_MINOR__) && \
     ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && \
     !defined(__cplusplus) && !defined(CURL_DISABLE_TYPECHECK)
diff --git a/include/curl/curlver.h b/include/curl/curlver.h
index e53c33d5f..79d920bff 100644
--- a/include/curl/curlver.h
+++ b/include/curl/curlver.h
@@ -32,13 +32,13 @@
 
 /* This is the version number of the libcurl package from which this header
    file origins: */
-#define LIBCURL_VERSION "8.8.0-DEV"
+#define LIBCURL_VERSION "8.9.1-DEV"
 
 /* The numeric version number is also available "in parts" by using these
    defines: */
 #define LIBCURL_VERSION_MAJOR 8
-#define LIBCURL_VERSION_MINOR 8
-#define LIBCURL_VERSION_PATCH 0
+#define LIBCURL_VERSION_MINOR 9
+#define LIBCURL_VERSION_PATCH 1
 
 /* This is the numeric version of the libcurl version number, meant for easier
    parsing and comparisons by programs. The LIBCURL_VERSION_NUM define will
@@ -48,7 +48,7 @@
 
    Where XX, YY and ZZ are the main version, release and patch numbers in
    hexadecimal (using 8 bits each). All three numbers are always represented
-   using two digits.  1.2 would appear as "0x010200" while version 9.11.7
+   using two digits. 1.2 would appear as "0x010200" while version 9.11.7
    appears as "0x090b07".
 
    This 6-digit (24 bits) hexadecimal number does not show pre-release number,
@@ -59,7 +59,7 @@
    CURL_VERSION_BITS() macro since curl's own configure script greps for it
    and needs it to contain the full number.
 */
-#define LIBCURL_VERSION_NUM 0x080800
+#define LIBCURL_VERSION_NUM 0x080901
 
 /*
  * This is the date and time when the full source package was created. The
diff --git a/include/curl/easy.h b/include/curl/easy.h
index 1285101c5..71b8dd467 100644
--- a/include/curl/easy.h
+++ b/include/curl/easy.h
@@ -50,7 +50,7 @@ CURL_EXTERN void curl_easy_cleanup(CURL *curl);
  *
  * Request internal information from the curl session with this function.
  * The third argument MUST be pointing to the specific type of the used option
- * which is documented in each man page of the option. The data pointed to
+ * which is documented in each manpage of the option. The data pointed to
  * will be filled in accordingly and can be relied upon only if the function
  * returns CURLE_OK. This function is intended to get used *AFTER* a performed
  * transfer, all results from this function are undefined until the transfer
diff --git a/include/curl/mprintf.h b/include/curl/mprintf.h
index 4f704548d..e6bc5bca4 100644
--- a/include/curl/mprintf.h
+++ b/include/curl/mprintf.h
@@ -32,7 +32,8 @@
 extern "C" {
 #endif
 
-#if (defined(__GNUC__) || defined(__clang__)) &&                        \
+#if (defined(__GNUC__) || defined(__clang__) ||                         \
+  defined(__IAR_SYSTEMS_ICC__)) &&                                      \
   defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) &&         \
   !defined(CURL_NO_FMT_CHECKS)
 #if defined(__MINGW32__) && !defined(__clang__)
diff --git a/include/curl/multi.h b/include/curl/multi.h
index 561470ce7..7b6c351ad 100644
--- a/include/curl/multi.h
+++ b/include/curl/multi.h
@@ -24,7 +24,7 @@
  *
  ***************************************************************************/
 /*
-  This is an "external" header file. Don't give away any internals here!
+  This is an "external" header file. Do not give away any internals here!
 
   GOALS
 
@@ -66,7 +66,7 @@ typedef enum {
   CURLM_OK,
   CURLM_BAD_HANDLE,      /* the passed-in handle is not a valid CURLM handle */
   CURLM_BAD_EASY_HANDLE, /* an easy handle was not good/valid */
-  CURLM_OUT_OF_MEMORY,   /* if you ever get this, you're in deep sh*t */
+  CURLM_OUT_OF_MEMORY,   /* if you ever get this, you are in deep sh*t */
   CURLM_INTERNAL_ERROR,  /* this is a libcurl bug */
   CURLM_BAD_SOCKET,      /* the passed in socket argument did not match */
   CURLM_UNKNOWN_OPTION,  /* curl_multi_setopt() with unsupported option */
@@ -109,7 +109,7 @@ struct CURLMsg {
 typedef struct CURLMsg CURLMsg;
 
 /* Based on poll(2) structure and values.
- * We don't use pollfd and POLL* constants explicitly
+ * We do not use pollfd and POLL* constants explicitly
  * to cover platforms without poll(). */
 #define CURL_WAIT_POLLIN    0x0001
 #define CURL_WAIT_POLLPRI   0x0002
@@ -205,7 +205,7 @@ CURL_EXTERN CURLMcode curl_multi_wakeup(CURLM *multi_handle);
  /*
   * Name:    curl_multi_perform()
   *
-  * Desc:    When the app thinks there's data available for curl it calls this
+  * Desc:    When the app thinks there is data available for curl it calls this
   *          function to read/write whatever there is right now. This returns
   *          as soon as the reads and writes are done. This function does not
   *          require that there actually is data available for reading or that
@@ -236,7 +236,7 @@ CURL_EXTERN CURLMcode curl_multi_cleanup(CURLM *multi_handle);
 /*
  * Name:    curl_multi_info_read()
  *
- * Desc:    Ask the multi handle if there's any messages/informationals from
+ * Desc:    Ask the multi handle if there is any messages/informationals from
  *          the individual transfers. Messages include informationals such as
  *          error code from the transfer or just the fact that a transfer is
  *          completed. More details on these should be written down as well.
@@ -253,7 +253,7 @@ CURL_EXTERN CURLMcode curl_multi_cleanup(CURLM *multi_handle);
  *          we will provide the particular "transfer handle" in that struct
  *          and that should/could/would be used in subsequent
  *          curl_easy_getinfo() calls (or similar). The point being that we
- *          must never expose complex structs to applications, as then we'll
+ *          must never expose complex structs to applications, as then we will
  *          undoubtably get backwards compatibility problems in the future.
  *
  * Returns: A pointer to a filled-in struct, or NULL if it failed or ran out
@@ -268,7 +268,7 @@ CURL_EXTERN CURLMsg *curl_multi_info_read(CURLM *multi_handle,
  * Name:    curl_multi_strerror()
  *
  * Desc:    The curl_multi_strerror function may be used to turn a CURLMcode
- *          value into the equivalent human readable error string.  This is
+ *          value into the equivalent human readable error string. This is
  *          useful for printing meaningful error messages.
  *
  * Returns: A pointer to a null-terminated error message.
@@ -282,7 +282,7 @@ CURL_EXTERN const char *curl_multi_strerror(CURLMcode);
  * Desc:    An alternative version of curl_multi_perform() that allows the
  *          application to pass in one of the file descriptors that have been
  *          detected to have "action" on them and let libcurl perform.
- *          See man page for details.
+ *          See manpage for details.
  */
 #define CURL_POLL_NONE   0
 #define CURL_POLL_IN     1
diff --git a/include/curl/system.h b/include/curl/system.h
index 81a1b817d..363914f20 100644
--- a/include/curl/system.h
+++ b/include/curl/system.h
@@ -46,7 +46,7 @@
  * As a general rule, curl_off_t shall not be mapped to off_t. This rule shall
  * only be violated if off_t is the only 64-bit data type available and the
  * size of off_t is independent of large file support settings. Keep your
- * build on the safe side avoiding an off_t gating.  If you have a 64-bit
+ * build on the safe side avoiding an off_t gating. If you have a 64-bit
  * off_t then take for sure that another 64-bit data type exists, dig deeper
  * and you will find it.
  *
@@ -402,7 +402,7 @@
 #  define CURL_PULL_SYS_SOCKET_H     1
 
 #else
-/* generic "safe guess" on old 32 bit style */
+/* generic "safe guess" on old 32-bit style */
 # define CURL_TYPEOF_CURL_OFF_T     long
 # define CURL_FORMAT_CURL_OFF_T     "ld"
 # define CURL_FORMAT_CURL_OFF_TU    "lu"
diff --git a/include/curl/typecheck-gcc.h b/include/curl/typecheck-gcc.h
index 873a49e02..e532e6997 100644
--- a/include/curl/typecheck-gcc.h
+++ b/include/curl/typecheck-gcc.h
@@ -34,11 +34,11 @@
  * _curl_easy_setopt_err_sometype below
  *
  * NOTE: We use two nested 'if' statements here instead of the && operator, in
- *       order to work around gcc bug #32061.  It affects only gcc 4.3.x/4.4.x
+ *       order to work around gcc bug #32061. It affects only gcc 4.3.x/4.4.x
  *       when compiling with -Wlogical-op.
  *
- * To add an option that uses the same type as an existing option, you'll just
- * need to extend the appropriate _curl_*_option macro
+ * To add an option that uses the same type as an existing option, you will
+ * just need to extend the appropriate _curl_*_option macro
  */
 #define curl_easy_setopt(handle, option, value)                         \
   __extension__({                                                       \
@@ -245,7 +245,7 @@ CURLWARNING(_curl_easy_getinfo_err_curl_off_t,
 
 /* To add a new option to one of the groups, just add
  *   (option) == CURLOPT_SOMETHING
- * to the or-expression. If the option takes a long or curl_off_t, you don't
+ * to the or-expression. If the option takes a long or curl_off_t, you do not
  * have to do anything
  */
 
@@ -678,7 +678,7 @@ typedef CURLcode (*_curl_ssl_ctx_callback4)(CURL *, const void *,
                                             const void *);
 #ifdef HEADER_SSL_H
 /* hack: if we included OpenSSL's ssl.h, we know about SSL_CTX
- * this will of course break if we're included before OpenSSL headers...
+ * this will of course break if we are included before OpenSSL headers...
  */
 typedef CURLcode (*_curl_ssl_ctx_callback5)(CURL *, SSL_CTX *, void *);
 typedef CURLcode (*_curl_ssl_ctx_callback6)(CURL *, SSL_CTX *, const void *);
diff --git a/include/curl/urlapi.h b/include/curl/urlapi.h
index 19388c3c0..b4a6e5d56 100644
--- a/include/curl/urlapi.h
+++ b/include/curl/urlapi.h
@@ -97,11 +97,12 @@ typedef enum {
 #define CURLU_NO_AUTHORITY (1<<10)      /* Allow empty authority when the
                                            scheme is unknown. */
 #define CURLU_ALLOW_SPACE (1<<11)       /* Allow spaces in the URL */
-#define CURLU_PUNYCODE (1<<12)          /* get the host name in punycode */
+#define CURLU_PUNYCODE (1<<12)          /* get the hostname in punycode */
 #define CURLU_PUNY2IDN (1<<13)          /* punycode => IDN conversion */
 #define CURLU_GET_EMPTY (1<<14)         /* allow empty queries and fragments
                                            when extracting the URL or the
                                            components */
+#define CURLU_NO_GUESS_SCHEME (1<<15)   /* for get, do not accept a guess */
 
 typedef struct Curl_URL CURLU;
 
@@ -142,7 +143,7 @@ CURL_EXTERN CURLUcode curl_url_set(CURLU *handle, CURLUPart what,
 
 /*
  * curl_url_strerror() turns a CURLUcode value into the equivalent human
- * readable error string.  This is useful for printing meaningful error
+ * readable error string. This is useful for printing meaningful error
  * messages.
  */
 CURL_EXTERN const char *curl_url_strerror(CURLUcode);
diff --git a/lib/CMakeLists.txt b/lib/CMakeLists.txt
index e80df5f5a..63e5b9139 100644
--- a/lib/CMakeLists.txt
+++ b/lib/CMakeLists.txt
@@ -65,29 +65,6 @@ if(ENABLE_CURLDEBUG)
   set_source_files_properties(memdebug.c curl_multibyte.c PROPERTIES SKIP_UNITY_BUILD_INCLUSION ON)
 endif()
 
-transform_makefile_inc("Makefile.soname" "${CMAKE_CURRENT_BINARY_DIR}/Makefile.soname.cmake")
-include(${CMAKE_CURRENT_BINARY_DIR}/Makefile.soname.cmake)
-
-if(CMAKE_SYSTEM_NAME STREQUAL "AIX" OR
-  CMAKE_SYSTEM_NAME STREQUAL "Linux" OR
-  CMAKE_SYSTEM_NAME STREQUAL "Darwin" OR
-  CMAKE_SYSTEM_NAME STREQUAL "SunOS" OR
-  CMAKE_SYSTEM_NAME STREQUAL "GNU/kFreeBSD" OR
-
-  # FreeBSD comes with the a.out and elf flavours
-  # but a.out was supported up to version 3.x and
-  # elf from 3.x. I cannot imagine someone running
-  # CMake on those ancient systems
-  CMAKE_SYSTEM_NAME STREQUAL "FreeBSD" OR
-
-  CMAKE_SYSTEM_NAME STREQUAL "Haiku")
-
-  math(EXPR CMAKESONAME "${VERSIONCHANGE} - ${VERSIONDEL}")
-  set(CMAKEVERSION "${CMAKESONAME}.${VERSIONDEL}.${VERSIONADD}")
-else()
-  unset(CMAKESONAME)
-endif()
-
 ## Library definition
 
 # Add "_imp" as a suffix before the extension to avoid conflicting with
@@ -169,10 +146,6 @@ if(BUILD_STATIC_LIBS)
       INTERPROCEDURAL_OPTIMIZATION_RELEASE TRUE
       INTERPROCEDURAL_OPTIMIZATION_RELWITHDEBINFO TRUE)
   endif()
-  if(CMAKEVERSION AND CMAKESONAME)
-    set_target_properties(${LIB_STATIC} PROPERTIES
-      VERSION ${CMAKEVERSION} SOVERSION ${CMAKESONAME})
-  endif()
 
   target_include_directories(${LIB_STATIC} INTERFACE
     $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
@@ -185,8 +158,8 @@ if(BUILD_SHARED_LIBS)
   add_library(${PROJECT_NAME}::${LIB_SHARED} ALIAS ${LIB_SHARED})
   if(WIN32 OR CYGWIN)
     if(CYGWIN)
-      # For cygwin always compile dllmain.c as a separate unit since it
-      # includes windows.h, which shouldn't be included in other units.
+      # For Cygwin always compile dllmain.c as a separate unit since it
+      # includes windows.h, which should not be included in other units.
       set_source_files_properties(dllmain.c PROPERTIES
         SKIP_UNITY_BUILD_INCLUSION ON)
     endif()
@@ -213,14 +186,40 @@ if(BUILD_SHARED_LIBS)
       INTERPROCEDURAL_OPTIMIZATION_RELEASE TRUE
       INTERPROCEDURAL_OPTIMIZATION_RELWITHDEBINFO TRUE)
   endif()
-  if(CMAKEVERSION AND CMAKESONAME)
-    set_target_properties(${LIB_SHARED} PROPERTIES
-      VERSION ${CMAKEVERSION} SOVERSION ${CMAKESONAME})
-  endif()
 
   target_include_directories(${LIB_SHARED} INTERFACE
     $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
     $<BUILD_INTERFACE:${CURL_SOURCE_DIR}/include>)
+
+  if(CMAKE_DLL_NAME_WITH_SOVERSION OR
+    CYGWIN OR
+    APPLE OR
+    CMAKE_SYSTEM_NAME STREQUAL "AIX" OR
+    CMAKE_SYSTEM_NAME STREQUAL "Linux" OR
+    CMAKE_SYSTEM_NAME STREQUAL "SunOS" OR
+    CMAKE_SYSTEM_NAME STREQUAL "Haiku" OR
+    CMAKE_SYSTEM_NAME STREQUAL "GNU/kFreeBSD" OR
+    # FreeBSD comes with the a.out and ELF flavours but a.out was supported
+    # up to v3.x and ELF from v3.x. I cannot imagine someone running CMake
+    # on those ancient systems.
+    CMAKE_SYSTEM_NAME STREQUAL "FreeBSD")
+    set(soversion_default TRUE)
+  else()
+    set(soversion_default FALSE)
+  endif()
+
+  option(CURL_LIBCURL_SOVERSION "Enable libcurl SOVERSION" ${soversion_default})
+
+  if(CURL_LIBCURL_SOVERSION)
+    transform_makefile_inc("Makefile.soname" "${CMAKE_CURRENT_BINARY_DIR}/Makefile.soname.cmake")
+    include(${CMAKE_CURRENT_BINARY_DIR}/Makefile.soname.cmake)
+
+    math(EXPR CMAKESONAME "${VERSIONCHANGE} - ${VERSIONDEL}")
+    set(CMAKEVERSION "${CMAKESONAME}.${VERSIONDEL}.${VERSIONADD}")
+
+    set_target_properties(${LIB_SHARED} PROPERTIES
+      VERSION "${CMAKEVERSION}" SOVERSION "${CMAKESONAME}")
+  endif()
 endif()
 
 add_library(${LIB_NAME} ALIAS ${LIB_SELECTED})
diff --git a/lib/Makefile.am b/lib/Makefile.am
index 96afc59ac..413fcd4d5 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -126,7 +126,7 @@ checksrc:
 	-W$(srcdir)/curl_config.h $(srcdir)/*.[ch] $(srcdir)/vauth/*.[ch]   \
 	$(srcdir)/vtls/*.[ch] $(srcdir)/vquic/*.[ch] $(srcdir)/vssh/*.[ch])
 
-if CURLDEBUG
+if DEBUGBUILD
 # for debug builds, we scan the sources on all regular make invokes
 all-local: checksrc
 endif
diff --git a/lib/altsvc.c b/lib/altsvc.c
index b72a59612..db9749c25 100644
--- a/lib/altsvc.c
+++ b/lib/altsvc.c
@@ -211,7 +211,7 @@ static CURLcode altsvc_load(struct altsvcinfo *asi, const char *file)
   CURLcode result = CURLE_OK;
   FILE *fp;
 
-  /* we need a private copy of the file name so that the altsvc cache file
+  /* we need a private copy of the filename so that the altsvc cache file
      name survives an easy handle reset */
   free(asi->filename);
   asi->filename = strdup(file);
@@ -270,7 +270,7 @@ static CURLcode altsvc_out(struct altsvc *as, FILE *fp)
           "%s %s%s%s %u "
           "\"%d%02d%02d "
           "%02d:%02d:%02d\" "
-          "%u %d\n",
+          "%u %u\n",
           Curl_alpnid2str(as->src.alpnid),
           src6_pre, as->src.host, src6_post,
           as->src.port,
@@ -373,7 +373,7 @@ CURLcode Curl_altsvc_save(struct Curl_easy *data,
     file = altsvc->filename;
 
   if((altsvc->flags & CURLALTSVC_READONLYFILE) || !file || !file[0])
-    /* marked as read-only, no file or zero length file name */
+    /* marked as read-only, no file or zero length filename */
     return CURLE_OK;
 
   result = Curl_fopen(data, file, &out, &tempstore);
@@ -430,7 +430,7 @@ static bool hostcompare(const char *host, const char *check)
   if(hlen && (host[hlen - 1] == '.'))
     hlen--;
   if(hlen != clen)
-    /* they can't match if they have different lengths */
+    /* they cannot match if they have different lengths */
     return FALSE;
   return strncasecompare(host, check, hlen);
 }
@@ -462,7 +462,7 @@ static time_t altsvc_debugtime(void *unused)
   char *timestr = getenv("CURL_TIME");
   (void)unused;
   if(timestr) {
-    unsigned long val = strtol(timestr, NULL, 10);
+    long val = strtol(timestr, NULL, 10);
     return (time_t)val;
   }
   return time(NULL);
@@ -477,11 +477,11 @@ static time_t altsvc_debugtime(void *unused)
  * Curl_altsvc_parse() takes an incoming alt-svc response header and stores
  * the data correctly in the cache.
  *
- * 'value' points to the header *value*. That's contents to the right of the
+ * 'value' points to the header *value*. That is contents to the right of the
  * header name.
  *
  * Currently this function rejects invalid data without returning an error.
- * Invalid host name, port number will result in the specific alternative
+ * Invalid hostname, port number will result in the specific alternative
  * being rejected. Unknown protocols are skipped.
  */
 CURLcode Curl_altsvc_parse(struct Curl_easy *data,
@@ -531,7 +531,7 @@ CURLcode Curl_altsvc_parse(struct Curl_easy *data,
         bool valid = TRUE;
         p++;
         if(*p != ':') {
-          /* host name starts here */
+          /* hostname starts here */
           const char *hostp = p;
           if(*p == '[') {
             /* pass all valid IPv6 letters - does not handle zone id */
@@ -549,7 +549,7 @@ CURLcode Curl_altsvc_parse(struct Curl_easy *data,
             len = p - hostp;
           }
           if(!len || (len >= MAX_ALTSVC_HOSTLEN)) {
-            infof(data, "Excessive alt-svc host name, ignoring.");
+            infof(data, "Excessive alt-svc hostname, ignoring.");
             valid = FALSE;
           }
           else {
@@ -624,7 +624,7 @@ CURLcode Curl_altsvc_parse(struct Curl_easy *data,
           num = strtoul(value_ptr, &end_ptr, 10);
           if((end_ptr != value_ptr) && (num < ULONG_MAX)) {
             if(strcasecompare("ma", option))
-              maxage = num;
+              maxage = (time_t)num;
             else if(strcasecompare("persist", option) && (num == 1))
               persist = TRUE;
           }
@@ -651,7 +651,7 @@ CURLcode Curl_altsvc_parse(struct Curl_easy *data,
       }
       else
         break;
-      /* after the double quote there can be a comma if there's another
+      /* after the double quote there can be a comma if there is another
          string or a semicolon if no more */
       if(*p == ',') {
         /* comma means another alternative is presented */
@@ -696,7 +696,7 @@ bool Curl_altsvc_lookup(struct altsvcinfo *asi,
     if((as->src.alpnid == srcalpnid) &&
        hostcompare(srchost, as->src.host) &&
        (as->src.port == srcport) &&
-       (versions & as->dst.alpnid)) {
+       (versions & (int)as->dst.alpnid)) {
       /* match */
       *dstentry = as;
       return TRUE;
diff --git a/lib/altsvc.h b/lib/altsvc.h
index 7fea1434a..58f1905da 100644
--- a/lib/altsvc.h
+++ b/lib/altsvc.h
@@ -47,7 +47,7 @@ struct altsvc {
   struct althost dst;
   time_t expires;
   bool persist;
-  int prio;
+  unsigned int prio;
   struct Curl_llist_element node;
 };
 
diff --git a/lib/amigaos.c b/lib/amigaos.c
index 139309b11..1321c53c4 100644
--- a/lib/amigaos.c
+++ b/lib/amigaos.c
@@ -117,7 +117,7 @@ void Curl_amiga_cleanup(void)
 
 #ifdef CURLRES_AMIGA
 /*
- * Because we need to handle the different cases in hostip4.c at run-time,
+ * Because we need to handle the different cases in hostip4.c at runtime,
  * not at compile-time, based on what was detected in Curl_amiga_init(),
  * we replace it completely with our own as to not complicate the baseline
  * code. Assumes malloc/calloc/free are thread safe because Curl_he2ai()
diff --git a/lib/arpa_telnet.h b/lib/arpa_telnet.h
index 228b4466e..d641a01da 100644
--- a/lib/arpa_telnet.h
+++ b/lib/arpa_telnet.h
@@ -77,7 +77,7 @@ static const char * const telnetoptions[]=
 #define CURL_GA   249 /* Go Ahead, reverse the line */
 #define CURL_SB   250 /* SuBnegotiation */
 #define CURL_WILL 251 /* Our side WILL use this option */
-#define CURL_WONT 252 /* Our side WON'T use this option */
+#define CURL_WONT 252 /* Our side will not use this option */
 #define CURL_DO   253 /* DO use this option! */
 #define CURL_DONT 254 /* DON'T use this option! */
 #define CURL_IAC  255 /* Interpret As Command */
diff --git a/lib/asyn-ares.c b/lib/asyn-ares.c
index 8fed61760..782e3ac65 100644
--- a/lib/asyn-ares.c
+++ b/lib/asyn-ares.c
@@ -65,7 +65,7 @@
 #  define CARES_STATICLIB
 #endif
 #include <ares.h>
-#include <ares_version.h> /* really old c-ares didn't include this by
+#include <ares_version.h> /* really old c-ares did not include this by
                              itself */
 
 #if ARES_VERSION >= 0x010500
@@ -112,8 +112,8 @@ struct thread_data {
 /* How long we are willing to wait for additional parallel responses after
    obtaining a "definitive" one. For old c-ares without getaddrinfo.
 
-   This is intended to equal the c-ares default timeout.  cURL always uses that
-   default value.  Unfortunately, c-ares doesn't expose its default timeout in
+   This is intended to equal the c-ares default timeout. cURL always uses that
+   default value. Unfortunately, c-ares does not expose its default timeout in
    its API, but it is officially documented as 5 seconds.
 
    See query_completed_cb() for an explanation of how this is used.
@@ -126,8 +126,8 @@ static int ares_ver = 0;
 
 /*
  * Curl_resolver_global_init() - the generic low-level asynchronous name
- * resolve API.  Called from curl_global_init() to initialize global resolver
- * environment.  Initializes ares library.
+ * resolve API. Called from curl_global_init() to initialize global resolver
+ * environment. Initializes ares library.
  */
 int Curl_resolver_global_init(void)
 {
@@ -169,7 +169,7 @@ static void sock_state_cb(void *data, ares_socket_t socket_fd,
  *
  * Called from curl_easy_init() -> Curl_open() to initialize resolver
  * URL-state specific environment ('resolver' member of the UrlState
- * structure).  Fills the passed pointer by the initialized ares_channel.
+ * structure). Fills the passed pointer by the initialized ares_channel.
  */
 CURLcode Curl_resolver_init(struct Curl_easy *easy, void **resolver)
 {
@@ -211,7 +211,7 @@ CURLcode Curl_resolver_init(struct Curl_easy *easy, void **resolver)
  *
  * Called from curl_easy_cleanup() -> Curl_close() to cleanup resolver
  * URL-state specific environment ('resolver' member of the UrlState
- * structure).  Destroys the ares channel.
+ * structure). Destroys the ares channel.
  */
 void Curl_resolver_cleanup(void *resolver)
 {
@@ -222,7 +222,7 @@ void Curl_resolver_cleanup(void *resolver)
  * Curl_resolver_duphandle()
  *
  * Called from curl_easy_duphandle() to duplicate resolver URL-state specific
- * environment ('resolver' member of the UrlState structure).  Duplicates the
+ * environment ('resolver' member of the UrlState structure). Duplicates the
  * 'from' ares channel and passes the resulting channel to the 'to' pointer.
  */
 CURLcode Curl_resolver_duphandle(struct Curl_easy *easy, void **to, void *from)
@@ -250,12 +250,12 @@ void Curl_resolver_cancel(struct Curl_easy *data)
 }
 
 /*
- * We're equivalent to Curl_resolver_cancel() for the c-ares resolver.  We
+ * We are equivalent to Curl_resolver_cancel() for the c-ares resolver. We
  * never block.
  */
 void Curl_resolver_kill(struct Curl_easy *data)
 {
-  /* We don't need to check the resolver state because we can be called safely
+  /* We do not need to check the resolver state because we can be called safely
      at any time and we always do the same thing. */
   Curl_resolver_cancel(data);
 }
@@ -280,7 +280,7 @@ static void destroy_async_data(struct Curl_async *async)
 
 /*
  * Curl_resolver_getsock() is called when someone from the outside world
- * (using curl_multi_fdset()) wants to get our fd_set setup and we're talking
+ * (using curl_multi_fdset()) wants to get our fd_set setup and we are talking
  * with ares. The caller must make sure that this function is only called when
  * we have a working ares channel.
  *
@@ -350,7 +350,7 @@ static int waitperform(struct Curl_easy *data, timediff_t timeout_ms)
   }
 
   if(num) {
-    nfds = Curl_poll(pfd, num, timeout_ms);
+    nfds = Curl_poll(pfd, (unsigned int)num, timeout_ms);
     if(nfds < 0)
       return -1;
   }
@@ -359,7 +359,7 @@ static int waitperform(struct Curl_easy *data, timediff_t timeout_ms)
 
   if(!nfds)
     /* Call ares_process() unconditionally here, even if we simply timed out
-       above, as otherwise the ares name resolve won't timeout! */
+       above, as otherwise the ares name resolve will not timeout! */
     ares_process_fd((ares_channel)data->state.async.resolver, ARES_SOCKET_BAD,
                     ARES_SOCKET_BAD);
   else {
@@ -394,8 +394,8 @@ CURLcode Curl_resolver_is_resolved(struct Curl_easy *data,
     return CURLE_UNRECOVERABLE_POLL;
 
 #ifndef HAVE_CARES_GETADDRINFO
-  /* Now that we've checked for any last minute results above, see if there are
-     any responses still pending when the EXPIRE_HAPPY_EYEBALLS_DNS timer
+  /* Now that we have checked for any last minute results above, see if there
+     are any responses still pending when the EXPIRE_HAPPY_EYEBALLS_DNS timer
      expires. */
   if(res
      && res->num_pending
@@ -410,7 +410,7 @@ CURLcode Curl_resolver_is_resolved(struct Curl_easy *data,
       &res->happy_eyeballs_dns_time, 0, sizeof(res->happy_eyeballs_dns_time));
 
     /* Cancel the raw c-ares request, which will fire query_completed_cb() with
-       ARES_ECANCELLED synchronously for all pending responses.  This will
+       ARES_ECANCELLED synchronously for all pending responses. This will
        leave us with res->num_pending == 0, which is perfect for the next
        block. */
     ares_cancel((ares_channel)data->state.async.resolver);
@@ -523,7 +523,7 @@ CURLcode Curl_resolver_wait_resolv(struct Curl_easy *data,
     *entry = data->state.async.dns;
 
   if(result)
-    /* close the connection, since we can't return failure here without
+    /* close the connection, since we cannot return failure here without
        cleaning up this connection properly. */
     connclose(data->conn, "c-ares resolve failed");
 
@@ -603,57 +603,57 @@ static void query_completed_cb(void *arg,  /* (struct connectdata *) */
 
     /* If there are responses still pending, we presume they must be the
        complementary IPv4 or IPv6 lookups that we started in parallel in
-       Curl_resolver_getaddrinfo() (for Happy Eyeballs).  If we've got a
+       Curl_resolver_getaddrinfo() (for Happy Eyeballs). If we have got a
        "definitive" response from one of a set of parallel queries, we need to
-       think about how long we're willing to wait for more responses. */
+       think about how long we are willing to wait for more responses. */
     if(res->num_pending
        /* Only these c-ares status values count as "definitive" for these
-          purposes.  For example, ARES_ENODATA is what we expect when there is
-          no IPv6 entry for a domain name, and that's not a reason to get more
-          aggressive in our timeouts for the other response.  Other errors are
+          purposes. For example, ARES_ENODATA is what we expect when there is
+          no IPv6 entry for a domain name, and that is not a reason to get more
+          aggressive in our timeouts for the other response. Other errors are
           either a result of bad input (which should affect all parallel
           requests), local or network conditions, non-definitive server
           responses, or us cancelling the request. */
        && (status == ARES_SUCCESS || status == ARES_ENOTFOUND)) {
-      /* Right now, there can only be up to two parallel queries, so don't
+      /* Right now, there can only be up to two parallel queries, so do not
          bother handling any other cases. */
       DEBUGASSERT(res->num_pending == 1);
 
-      /* It's possible that one of these parallel queries could succeed
-         quickly, but the other could always fail or timeout (when we're
+      /* it is possible that one of these parallel queries could succeed
+         quickly, but the other could always fail or timeout (when we are
          talking to a pool of DNS servers that can only successfully resolve
          IPv4 address, for example).
 
-         It's also possible that the other request could always just take
+         it is also possible that the other request could always just take
          longer because it needs more time or only the second DNS server can
-         fulfill it successfully.  But, to align with the philosophy of Happy
-         Eyeballs, we don't want to wait _too_ long or users will think
-         requests are slow when IPv6 lookups don't actually work (but IPv4 ones
-         do).
+         fulfill it successfully. But, to align with the philosophy of Happy
+         Eyeballs, we do not want to wait _too_ long or users will think
+         requests are slow when IPv6 lookups do not actually work (but IPv4
+         ones do).
 
          So, now that we have a usable answer (some IPv4 addresses, some IPv6
          addresses, or "no such domain"), we start a timeout for the remaining
-         pending responses.  Even though it is typical that this resolved
-         request came back quickly, that needn't be the case.  It might be that
-         this completing request didn't get a result from the first DNS server
-         or even the first round of the whole DNS server pool.  So it could
-         already be quite some time after we issued the DNS queries in the
-         first place.  Without modifying c-ares, we can't know exactly where in
-         its retry cycle we are.  We could guess based on how much time has
-         gone by, but it doesn't really matter.  Happy Eyeballs tells us that,
-         given usable information in hand, we simply don't want to wait "too
-         much longer" after we get a result.
+         pending responses. Even though it is typical that this resolved
+         request came back quickly, that needn't be the case. It might be that
+         this completing request did not get a result from the first DNS
+         server or even the first round of the whole DNS server pool. So it
+         could already be quite some time after we issued the DNS queries in
+         the first place. Without modifying c-ares, we cannot know exactly
+         where in its retry cycle we are. We could guess based on how much
+         time has gone by, but it does not really matter. Happy Eyeballs tells
+         us that, given usable information in hand, we simply do not want to
+         wait "too much longer" after we get a result.
 
          We simply wait an additional amount of time equal to the default
-         c-ares query timeout.  That is enough time for a typical parallel
-         response to arrive without being "too long".  Even on a network
+         c-ares query timeout. That is enough time for a typical parallel
+         response to arrive without being "too long". Even on a network
          where one of the two types of queries is failing or timing out
          constantly, this will usually mean we wait a total of the default
          c-ares timeout (5 seconds) plus the round trip time for the successful
-         request, which seems bearable.  The downside is that c-ares might race
+         request, which seems bearable. The downside is that c-ares might race
          with us to issue one more retry just before we give up, but it seems
          better to "waste" that request instead of trying to guess the perfect
-         timeout to prevent it.  After all, we don't even know where in the
+         timeout to prevent it. After all, we do not even know where in the
          c-ares retry cycle each request is.
       */
       res->happy_eyeballs_dns_time = Curl_now();
@@ -849,8 +849,8 @@ CURLcode Curl_set_dns_servers(struct Curl_easy *data,
 
   /* If server is NULL or empty, this would purge all DNS servers
    * from ares library, which will cause any and all queries to fail.
-   * So, just return OK if none are configured and don't actually make
-   * any changes to c-ares.  This lets c-ares use its defaults, which
+   * So, just return OK if none are configured and do not actually make
+   * any changes to c-ares. This lets c-ares use its defaults, which
    * it gets from the OS (for instance from /etc/resolv.conf on Linux).
    */
   if(!(servers && servers[0]))
diff --git a/lib/asyn-thread.c b/lib/asyn-thread.c
index 1760d6cb3..d91152fdf 100644
--- a/lib/asyn-thread.c
+++ b/lib/asyn-thread.c
@@ -168,7 +168,7 @@ struct thread_sync_data {
                             duplicate */
 #ifndef CURL_DISABLE_SOCKETPAIR
   struct Curl_easy *data;
-  curl_socket_t sock_pair[2]; /* socket pair */
+  curl_socket_t sock_pair[2]; /* eventfd/pipes/socket pair */
 #endif
   int sock_error;
   struct Curl_addrinfo *res;
@@ -251,7 +251,7 @@ int init_thread_sync_data(struct thread_data *td,
 
 #ifndef CURL_DISABLE_SOCKETPAIR
   /* create socket pair or pipe */
-  if(wakeup_create(&tsd->sock_pair[0]) < 0) {
+  if(wakeup_create(tsd->sock_pair, FALSE) < 0) {
     tsd->sock_pair[0] = CURL_SOCKET_BAD;
     tsd->sock_pair[1] = CURL_SOCKET_BAD;
     goto err_exit;
@@ -286,7 +286,7 @@ static CURLcode getaddrinfo_complete(struct Curl_easy *data)
 
   result = Curl_addrinfo_callback(data, tsd->sock_error, tsd->res);
   /* The tsd->res structure has been copied to async.dns and perhaps the DNS
-     cache.  Set our copy to NULL so destroy_thread_sync_data doesn't free it.
+     cache. Set our copy to NULL so destroy_thread_sync_data does not free it.
   */
   tsd->res = NULL;
 
@@ -302,6 +302,14 @@ query_complete(DWORD err, DWORD bytes, LPWSAOVERLAPPED overlapped)
   struct Curl_addrinfo *ca;
   struct Curl_addrinfo *cafirst = NULL;
   struct Curl_addrinfo *calast = NULL;
+#ifndef CURL_DISABLE_SOCKETPAIR
+#ifdef USE_EVENTFD
+  const void *buf;
+  const uint64_t val = 1;
+#else
+  char buf[1];
+#endif
+#endif
 #ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wcast-align"
@@ -421,11 +429,14 @@ query_complete(DWORD err, DWORD bytes, LPWSAOVERLAPPED overlapped)
   }
   else {
 #ifndef CURL_DISABLE_SOCKETPAIR
-    char buf[1];
     if(tsd->sock_pair[1] != CURL_SOCKET_BAD) {
-      /* DNS has been resolved, signal client task */
+#ifdef USE_EVENTFD
+      buf = &val;
+#else
       buf[0] = 1;
-      if(swrite(tsd->sock_pair[1],  buf, sizeof(buf)) < 0) {
+#endif
+      /* DNS has been resolved, signal client task */
+      if(wakeup_write(tsd->sock_pair[1], buf, sizeof(buf)) < 0) {
         /* update sock_erro to errno */
         tsd->sock_error = SOCKERRNO;
       }
@@ -447,14 +458,25 @@ query_complete(DWORD err, DWORD bytes, LPWSAOVERLAPPED overlapped)
  * For builds without ARES, but with USE_IPV6, create a resolver thread
  * and wait on it.
  */
-static unsigned int CURL_STDCALL getaddrinfo_thread(void *arg)
+static
+#if defined(_WIN32_WCE) || defined(CURL_WINDOWS_APP)
+DWORD
+#else
+unsigned int
+#endif
+CURL_STDCALL getaddrinfo_thread(void *arg)
 {
   struct thread_sync_data *tsd = (struct thread_sync_data *)arg;
   struct thread_data *td = tsd->td;
   char service[12];
   int rc;
 #ifndef CURL_DISABLE_SOCKETPAIR
+#ifdef USE_EVENTFD
+  const void *buf;
+  const uint64_t val = 1;
+#else
   char buf[1];
+#endif
 #endif
 
   msnprintf(service, sizeof(service), "%d", tsd->port);
@@ -480,9 +502,13 @@ static unsigned int CURL_STDCALL getaddrinfo_thread(void *arg)
   else {
 #ifndef CURL_DISABLE_SOCKETPAIR
     if(tsd->sock_pair[1] != CURL_SOCKET_BAD) {
-      /* DNS has been resolved, signal client task */
+#ifdef USE_EVENTFD
+      buf = &val;
+#else
       buf[0] = 1;
-      if(wakeup_write(tsd->sock_pair[1],  buf, sizeof(buf)) < 0) {
+#endif
+      /* DNS has been resolved, signal client task */
+      if(wakeup_write(tsd->sock_pair[1], buf, sizeof(buf)) < 0) {
         /* update sock_erro to errno */
         tsd->sock_error = SOCKERRNO;
       }
@@ -500,7 +526,13 @@ static unsigned int CURL_STDCALL getaddrinfo_thread(void *arg)
 /*
  * gethostbyname_thread() resolves a name and then exits.
  */
-static unsigned int CURL_STDCALL gethostbyname_thread(void *arg)
+static
+#if defined(_WIN32_WCE) || defined(CURL_WINDOWS_APP)
+DWORD
+#else
+unsigned int
+#endif
+CURL_STDCALL gethostbyname_thread(void *arg)
 {
   struct thread_sync_data *tsd = (struct thread_sync_data *)arg;
   struct thread_data *td = tsd->td;
@@ -638,7 +670,8 @@ static bool init_resolve_thread(struct Curl_easy *data,
 
 #ifdef _WIN32
   if(Curl_isWindows8OrGreater && Curl_FreeAddrInfoExW &&
-     Curl_GetAddrInfoExCancel && Curl_GetAddrInfoExW) {
+     Curl_GetAddrInfoExCancel && Curl_GetAddrInfoExW &&
+     !Curl_win32_impersonating()) {
 #define MAX_NAME_LEN 256 /* max domain name is 253 chars */
 #define MAX_PORT_LEN 8
     WCHAR namebuf[MAX_NAME_LEN];
@@ -664,7 +697,7 @@ static bool init_resolve_thread(struct Curl_easy *data,
                                   NULL, &td->tsd.w8.overlapped,
                                   &query_complete, &td->tsd.w8.cancel_ev);
         if(err != WSA_IO_PENDING)
-          query_complete(err, 0, &td->tsd.w8.overlapped);
+          query_complete((DWORD)err, 0, &td->tsd.w8.overlapped);
         return TRUE;
       }
     }
@@ -757,8 +790,8 @@ void Curl_resolver_kill(struct Curl_easy *data)
 {
   struct thread_data *td = data->state.async.tdata;
 
-  /* If we're still resolving, we must wait for the threads to fully clean up,
-     unfortunately.  Otherwise, we can simply cancel to clean up any resolver
+  /* If we are still resolving, we must wait for the threads to fully clean up,
+     unfortunately. Otherwise, we can simply cancel to clean up any resolver
      data. */
 #ifdef _WIN32
   if(td && td->complete_ev) {
@@ -829,7 +862,7 @@ CURLcode Curl_resolver_is_resolved(struct Curl_easy *data,
   }
   else {
     /* poll for name lookup done with exponential backoff up to 250ms */
-    /* should be fine even if this converts to 32 bit */
+    /* should be fine even if this converts to 32-bit */
     timediff_t elapsed = Curl_timediff(Curl_now(),
                                        data->progress.t_startsingle);
     if(elapsed < 0)
diff --git a/lib/asyn.h b/lib/asyn.h
index 7e207c4f5..0ff204884 100644
--- a/lib/asyn.h
+++ b/lib/asyn.h
@@ -58,7 +58,7 @@ void Curl_resolver_global_cleanup(void);
  * Curl_resolver_init()
  * Called from curl_easy_init() -> Curl_open() to initialize resolver
  * URL-state specific environment ('resolver' member of the UrlState
- * structure).  Should fill the passed pointer by the initialized handler.
+ * structure). Should fill the passed pointer by the initialized handler.
  * Returning anything else than CURLE_OK fails curl_easy_init() with the
  * correspondent code.
  */
@@ -68,7 +68,7 @@ CURLcode Curl_resolver_init(struct Curl_easy *easy, void **resolver);
  * Curl_resolver_cleanup()
  * Called from curl_easy_cleanup() -> Curl_close() to cleanup resolver
  * URL-state specific environment ('resolver' member of the UrlState
- * structure).  Should destroy the handler and free all resources connected to
+ * structure). Should destroy the handler and free all resources connected to
  * it.
  */
 void Curl_resolver_cleanup(void *resolver);
@@ -76,9 +76,9 @@ void Curl_resolver_cleanup(void *resolver);
 /*
  * Curl_resolver_duphandle()
  * Called from curl_easy_duphandle() to duplicate resolver URL-state specific
- * environment ('resolver' member of the UrlState structure).  Should
+ * environment ('resolver' member of the UrlState structure). Should
  * duplicate the 'from' handle and pass the resulting handle to the 'to'
- * pointer.  Returning anything else than CURLE_OK causes failed
+ * pointer. Returning anything else than CURLE_OK causes failed
  * curl_easy_duphandle() call.
  */
 CURLcode Curl_resolver_duphandle(struct Curl_easy *easy, void **to,
@@ -89,7 +89,7 @@ CURLcode Curl_resolver_duphandle(struct Curl_easy *easy, void **to,
  *
  * It is called from inside other functions to cancel currently performing
  * resolver request. Should also free any temporary resources allocated to
- * perform a request.  This never waits for resolver threads to complete.
+ * perform a request. This never waits for resolver threads to complete.
  *
  * It is safe to call this when conn is in any state.
  */
@@ -99,8 +99,8 @@ void Curl_resolver_cancel(struct Curl_easy *data);
  * Curl_resolver_kill().
  *
  * This acts like Curl_resolver_cancel() except it will block until any threads
- * associated with the resolver are complete.  This never blocks for resolvers
- * that do not use threads.  This is intended to be the "last chance" function
+ * associated with the resolver are complete. This never blocks for resolvers
+ * that do not use threads. This is intended to be the "last chance" function
  * that cleans up an in-progress resolver completely (before its owner is about
  * to die).
  *
@@ -161,7 +161,7 @@ struct Curl_addrinfo *Curl_resolver_getaddrinfo(struct Curl_easy *data,
                                                 int *waitp);
 
 #ifndef CURLRES_ASYNCH
-/* convert these functions if an asynch resolver isn't used */
+/* convert these functions if an asynch resolver is not used */
 #define Curl_resolver_cancel(x) Curl_nop_stmt
 #define Curl_resolver_kill(x) Curl_nop_stmt
 #define Curl_resolver_is_resolved(x,y) CURLE_COULDNT_RESOLVE_HOST
diff --git a/lib/bufref.c b/lib/bufref.c
index f0a0e2a7d..f048b5701 100644
--- a/lib/bufref.c
+++ b/lib/bufref.c
@@ -48,7 +48,7 @@ void Curl_bufref_init(struct bufref *br)
 }
 
 /*
- * Free the buffer and re-init the necessary fields. It doesn't touch the
+ * Free the buffer and re-init the necessary fields. It does not touch the
  * 'signature' field and thus this buffer reference can be reused.
  */
 
diff --git a/lib/c-hyper.c b/lib/c-hyper.c
index 0593d9706..3008d9a14 100644
--- a/lib/c-hyper.c
+++ b/lib/c-hyper.c
@@ -206,7 +206,7 @@ static int hyper_body_chunk(void *userdata, const hyper_buf *chunk)
   struct SingleRequest *k = &data->req;
   CURLcode result = CURLE_OK;
 
-  if(0 == k->bodywrites) {
+  if(!k->bodywritten) {
 #if defined(USE_NTLM)
     struct connectdata *conn = data->conn;
     if(conn->bits.close &&
@@ -324,7 +324,7 @@ static CURLcode empty_header(struct Curl_easy *data)
     result = hyper_each_header(data, NULL, 0, NULL, 0) ?
       CURLE_WRITE_ERROR : CURLE_OK;
     if(result)
-      failf(data, "hyperstream: couldn't pass blank header");
+      failf(data, "hyperstream: could not pass blank header");
     /* Hyper does chunked decoding itself. If it was added during
      * response header processing, remove it again. */
     Curl_cwriter_remove_by_name(data, "chunked");
@@ -420,8 +420,8 @@ CURLcode Curl_hyper_stream(struct Curl_easy *data,
         /* end of transfer */
         data->req.done = TRUE;
         infof(data, "hyperstream is done");
-        if(!k->bodywrites) {
-          /* hyper doesn't always call the body write callback */
+        if(!k->bodywritten) {
+          /* hyper does not always call the body write callback */
           result = Curl_http_firstwrite(data);
         }
         break;
@@ -439,7 +439,7 @@ CURLcode Curl_hyper_stream(struct Curl_easy *data,
 
     *didwhat = KEEP_RECV;
     if(!resp) {
-      failf(data, "hyperstream: couldn't get response");
+      failf(data, "hyperstream: could not get response");
       return CURLE_RECV_ERROR;
     }
 
@@ -462,7 +462,7 @@ CURLcode Curl_hyper_stream(struct Curl_easy *data,
 
     headers = hyper_response_headers(resp);
     if(!headers) {
-      failf(data, "hyperstream: couldn't get response headers");
+      failf(data, "hyperstream: could not get response headers");
       result = CURLE_RECV_ERROR;
       break;
     }
@@ -505,7 +505,7 @@ CURLcode Curl_hyper_stream(struct Curl_easy *data,
 
     resp_body = hyper_response_body(resp);
     if(!resp_body) {
-      failf(data, "hyperstream: couldn't get response body");
+      failf(data, "hyperstream: could not get response body");
       result = CURLE_RECV_ERROR;
       break;
     }
@@ -669,7 +669,7 @@ static int uploadstreamed(void *userdata, hyper_context *ctx,
       goto out;
     }
     /* increasing the writebytecount here is a little premature but we
-       don't know exactly when the body is sent */
+       do not know exactly when the body is sent */
     data->req.writebytecount += fillcount;
     Curl_pgrsSetUploadCounter(data, data->req.writebytecount);
     rc = HYPER_POLL_READY;
@@ -772,7 +772,7 @@ static void http1xx_cb(void *arg, struct hyper_response *resp)
   if(!result) {
     headers = hyper_response_headers(resp);
     if(!headers) {
-      failf(data, "hyperstream: couldn't get 1xx response headers");
+      failf(data, "hyperstream: could not get 1xx response headers");
       result = CURLE_RECV_ERROR;
     }
   }
@@ -1133,7 +1133,7 @@ CURLcode Curl_http(struct Curl_easy *data, bool *done)
     Curl_pgrsSetUploadSize(data, 0); /* nothing */
   }
 
-  Curl_xfer_setup(data, FIRSTSOCKET, -1, TRUE, FIRSTSOCKET);
+  Curl_xfer_setup1(data, CURL_XFER_SENDRECV, -1, TRUE);
   conn->datastream = Curl_hyper_stream;
 
   /* clear userpwd and proxyuserpwd to avoid reusing old credentials
@@ -1206,6 +1206,7 @@ static const struct Curl_crtype cr_hyper_protocol = {
   Curl_creader_def_resume_from,
   Curl_creader_def_rewind,
   cr_hyper_unpause,
+  Curl_creader_def_is_paused,
   Curl_creader_def_done,
   sizeof(struct Curl_creader)
 };
diff --git a/lib/cf-h1-proxy.c b/lib/cf-h1-proxy.c
index 093c33be5..6656b4ddc 100644
--- a/lib/cf-h1-proxy.c
+++ b/lib/cf-h1-proxy.c
@@ -65,7 +65,6 @@ typedef enum {
 
 /* struct for HTTP CONNECT tunneling */
 struct h1_tunnel_state {
-  struct HTTP CONNECT;
   struct dynbuf rcvbuf;
   struct dynbuf request_data;
   size_t nsent;
@@ -182,8 +181,8 @@ static void h1_tunnel_go_state(struct Curl_cfilter *cf,
     data->info.httpcode = 0; /* clear it as it might've been used for the
                                 proxy */
     /* If a proxy-authorization header was used for the proxy, then we should
-       make sure that it isn't accidentally used for the document request
-       after we've connected. So let's free and clear it here. */
+       make sure that it is not accidentally used for the document request
+       after we have connected. So let's free and clear it here. */
     Curl_safefree(data->state.aptr.proxyuserpwd);
 #ifdef USE_HYPER
     data->state.hconnect = FALSE;
@@ -222,8 +221,8 @@ static CURLcode start_CONNECT(struct Curl_cfilter *cf,
   int http_minor;
   CURLcode result;
 
-    /* This only happens if we've looped here due to authentication
-       reasons, and we don't really use the newly cloned URL here
+    /* This only happens if we have looped here due to authentication
+       reasons, and we do not really use the newly cloned URL here
        then. Just free() it. */
   Curl_safefree(data->req.newurl);
 
@@ -422,7 +421,7 @@ static CURLcode recv_CONNECT_resp(struct Curl_cfilter *cf,
 
       if(ts->cl) {
         /* A Content-Length based body: simply count down the counter
-           and make sure to break out of the loop when we're done! */
+           and make sure to break out of the loop when we are done! */
         ts->cl--;
         if(ts->cl <= 0) {
           ts->keepon = KEEPON_DONE;
@@ -440,7 +439,7 @@ static CURLcode recv_CONNECT_resp(struct Curl_cfilter *cf,
         if(result)
           return result;
         if(Curl_httpchunk_is_done(data, &ts->ch)) {
-          /* we're done reading chunks! */
+          /* we are done reading chunks! */
           infof(data, "chunk reading DONE");
           ts->keepon = KEEPON_DONE;
         }
@@ -475,7 +474,7 @@ static CURLcode recv_CONNECT_resp(struct Curl_cfilter *cf,
     if(result)
       return result;
 
-    /* Newlines are CRLF, so the CR is ignored as the line isn't
+    /* Newlines are CRLF, so the CR is ignored as the line is not
        really terminated until the LF comes. Treat a following CR
        as end-of-headers as well.*/
 
@@ -498,7 +497,7 @@ static CURLcode recv_CONNECT_resp(struct Curl_cfilter *cf,
         }
         else {
           /* without content-length or chunked encoding, we
-             can't keep the connection alive since the close is
+             cannot keep the connection alive since the close is
              the end signal so we bail out at once instead */
           CURL_TRC_CF(data, cf, "CONNECT: no content-length or chunked");
           ts->keepon = KEEPON_DONE;
@@ -518,7 +517,7 @@ static CURLcode recv_CONNECT_resp(struct Curl_cfilter *cf,
       return result;
 
     Curl_dyn_reset(&ts->rcvbuf);
-  } /* while there's buffer left and loop is requested */
+  } /* while there is buffer left and loop is requested */
 
   if(error)
     result = CURLE_RECV_ERROR;
@@ -666,8 +665,8 @@ static CURLcode start_CONNECT(struct Curl_cfilter *cf,
     goto error;
   }
 
-    /* This only happens if we've looped here due to authentication
-       reasons, and we don't really use the newly cloned URL here
+    /* This only happens if we have looped here due to authentication
+       reasons, and we do not really use the newly cloned URL here
        then. Just free() it. */
   Curl_safefree(data->req.newurl);
 
@@ -955,7 +954,7 @@ static CURLcode H1_CONNECT(struct Curl_cfilter *cf,
 
   DEBUGASSERT(ts->tunnel_state == H1_TUNNEL_RESPONSE);
   if(data->info.httpproxycode/100 != 2) {
-    /* a non-2xx response and we have no next url to try. */
+    /* a non-2xx response and we have no next URL to try. */
     Curl_safefree(data->req.newurl);
     /* failure, close this connection to avoid reuse */
     streamclose(conn, "proxy CONNECT failure");
@@ -1034,9 +1033,9 @@ static void cf_h1_proxy_adjust_pollset(struct Curl_cfilter *cf,
      * and not waiting on something, we are tunneling. */
     curl_socket_t sock = Curl_conn_cf_get_socket(cf, data);
     if(ts) {
-      /* when we've sent a CONNECT to a proxy, we should rather either
+      /* when we have sent a CONNECT to a proxy, we should rather either
          wait for the socket to become readable to be able to get the
-         response headers or if we're still sending the request, wait
+         response headers or if we are still sending the request, wait
          for write. */
       if(tunnel_want_send(ts))
         Curl_pollset_set_out_only(data, ps, sock);
@@ -1077,6 +1076,7 @@ struct Curl_cftype Curl_cft_h1_proxy = {
   cf_h1_proxy_destroy,
   cf_h1_proxy_connect,
   cf_h1_proxy_close,
+  Curl_cf_def_shutdown,
   Curl_cf_http_proxy_get_host,
   cf_h1_proxy_adjust_pollset,
   Curl_cf_def_data_pending,
diff --git a/lib/cf-h2-proxy.c b/lib/cf-h2-proxy.c
index 0bff15f38..7613b7828 100644
--- a/lib/cf-h2-proxy.c
+++ b/lib/cf-h2-proxy.c
@@ -162,8 +162,8 @@ static void h2_tunnel_go_state(struct Curl_cfilter *cf,
       CURL_TRC_CF(data, cf, "[%d] new tunnel state 'failed'", ts->stream_id);
     ts->state = new_state;
     /* If a proxy-authorization header was used for the proxy, then we should
-       make sure that it isn't accidentally used for the document request
-       after we've connected. So let's free and clear it here. */
+       make sure that it is not accidentally used for the document request
+       after we have connected. So let's free and clear it here. */
     Curl_safefree(data->state.aptr.proxyuserpwd);
     break;
   }
@@ -181,7 +181,8 @@ struct cf_h2_proxy_ctx {
   int32_t goaway_error;
   int32_t last_stream_id;
   BIT(conn_closed);
-  BIT(goaway);
+  BIT(rcvd_goaway);
+  BIT(sent_goaway);
   BIT(nw_out_blocked);
 };
 
@@ -694,7 +695,7 @@ static int proxy_h2_on_frame_recv(nghttp2_session *session,
       }
       break;
     case NGHTTP2_GOAWAY:
-      ctx->goaway = TRUE;
+      ctx->rcvd_goaway = TRUE;
       break;
     default:
       break;
@@ -1166,6 +1167,49 @@ static void cf_h2_proxy_destroy(struct Curl_cfilter *cf,
   }
 }
 
+static CURLcode cf_h2_proxy_shutdown(struct Curl_cfilter *cf,
+                                     struct Curl_easy *data, bool *done)
+{
+  struct cf_h2_proxy_ctx *ctx = cf->ctx;
+  struct cf_call_data save;
+  CURLcode result;
+  int rv;
+
+  if(!cf->connected || !ctx->h2 || cf->shutdown || ctx->conn_closed) {
+    *done = TRUE;
+    return CURLE_OK;
+  }
+
+  CF_DATA_SAVE(save, cf, data);
+
+  if(!ctx->sent_goaway) {
+    rv = nghttp2_submit_goaway(ctx->h2, NGHTTP2_FLAG_NONE,
+                               0, 0,
+                               (const uint8_t *)"shutown", sizeof("shutown"));
+    if(rv) {
+      failf(data, "nghttp2_submit_goaway() failed: %s(%d)",
+            nghttp2_strerror(rv), rv);
+      result = CURLE_SEND_ERROR;
+      goto out;
+    }
+    ctx->sent_goaway = TRUE;
+  }
+  /* GOAWAY submitted, process egress and ingress until nghttp2 is done. */
+  result = CURLE_OK;
+  if(nghttp2_session_want_write(ctx->h2))
+    result = proxy_h2_progress_egress(cf, data);
+  if(!result && nghttp2_session_want_read(ctx->h2))
+    result = proxy_h2_progress_ingress(cf, data);
+
+  *done = (ctx->conn_closed ||
+           (!result && !nghttp2_session_want_write(ctx->h2) &&
+            !nghttp2_session_want_read(ctx->h2)));
+out:
+  CF_DATA_RESTORE(cf, save);
+  cf->shutdown = (result || *done);
+  return result;
+}
+
 static bool cf_h2_proxy_data_pending(struct Curl_cfilter *cf,
                                      const struct Curl_easy *data)
 {
@@ -1182,12 +1226,18 @@ static void cf_h2_proxy_adjust_pollset(struct Curl_cfilter *cf,
                                        struct easy_pollset *ps)
 {
   struct cf_h2_proxy_ctx *ctx = cf->ctx;
+  struct cf_call_data save;
   curl_socket_t sock = Curl_conn_cf_get_socket(cf, data);
   bool want_recv, want_send;
 
-  Curl_pollset_check(data, ps, sock, &want_recv, &want_send);
+  if(!cf->connected && ctx->h2) {
+    want_send = nghttp2_session_want_write(ctx->h2);
+    want_recv = nghttp2_session_want_read(ctx->h2);
+  }
+  else
+    Curl_pollset_check(data, ps, sock, &want_recv, &want_send);
+
   if(ctx->h2 && (want_recv || want_send)) {
-    struct cf_call_data save;
     bool c_exhaust, s_exhaust;
 
     CF_DATA_SAVE(save, cf, data);
@@ -1202,6 +1252,14 @@ static void cf_h2_proxy_adjust_pollset(struct Curl_cfilter *cf,
     Curl_pollset_set(data, ps, sock, want_recv, want_send);
     CF_DATA_RESTORE(cf, save);
   }
+  else if(ctx->sent_goaway && !cf->shutdown) {
+    /* shutdown in progress */
+    CF_DATA_SAVE(save, cf, data);
+    want_send = nghttp2_session_want_write(ctx->h2);
+    want_recv = nghttp2_session_want_read(ctx->h2);
+    Curl_pollset_set(data, ps, sock, want_recv, want_send);
+    CF_DATA_RESTORE(cf, save);
+  }
 }
 
 static ssize_t h2_handle_tunnel_close(struct Curl_cfilter *cf,
@@ -1214,7 +1272,7 @@ static ssize_t h2_handle_tunnel_close(struct Curl_cfilter *cf,
   if(ctx->tunnel.error == NGHTTP2_REFUSED_STREAM) {
     CURL_TRC_CF(data, cf, "[%d] REFUSED_STREAM, try again on a new "
                 "connection", ctx->tunnel.stream_id);
-    connclose(cf->conn, "REFUSED_STREAM"); /* don't use this anymore */
+    connclose(cf->conn, "REFUSED_STREAM"); /* do not use this anymore */
     *err = CURLE_RECV_ERROR; /* trigger Curl_retry_request() later */
     return -1;
   }
@@ -1259,7 +1317,8 @@ static ssize_t tunnel_recv(struct Curl_cfilter *cf, struct Curl_easy *data,
     }
     else if(ctx->tunnel.reset ||
             (ctx->conn_closed && Curl_bufq_is_empty(&ctx->inbufq)) ||
-            (ctx->goaway && ctx->last_stream_id < ctx->tunnel.stream_id)) {
+            (ctx->rcvd_goaway &&
+             ctx->last_stream_id < ctx->tunnel.stream_id)) {
       *err = CURLE_RECV_ERROR;
       nread = -1;
     }
@@ -1306,7 +1365,7 @@ static ssize_t cf_h2_proxy_recv(struct Curl_cfilter *cf,
 
   result = proxy_h2_progress_egress(cf, data);
   if(result == CURLE_AGAIN) {
-    /* pending data to send, need to be called again. Ideally, we'd
+    /* pending data to send, need to be called again. Ideally, we would
      * monitor the socket for POLLOUT, but we might not be in SENDING
      * transfer state any longer and are unable to make this happen.
      */
@@ -1418,7 +1477,7 @@ static ssize_t cf_h2_proxy_send(struct Curl_cfilter *cf,
     /* Unable to send all data, due to connection blocked or H2 window
      * exhaustion. Data is left in our stream buffer, or nghttp2's internal
      * frame buffer or our network out buffer. */
-    size_t rwin = nghttp2_session_get_stream_remote_window_size(
+    size_t rwin = (size_t)nghttp2_session_get_stream_remote_window_size(
                     ctx->h2, ctx->tunnel.stream_id);
     if(rwin == 0) {
       /* H2 flow window exhaustion.
@@ -1489,8 +1548,8 @@ static bool proxy_h2_connisalive(struct Curl_cfilter *cf,
     return FALSE;
 
   if(*input_pending) {
-    /* This happens before we've sent off a request and the connection is
-       not in use by any other transfer, there shouldn't be any data here,
+    /* This happens before we have sent off a request and the connection is
+       not in use by any other transfer, there should not be any data here,
        only "protocol frames" */
     CURLcode result;
     ssize_t nread = -1;
@@ -1537,6 +1596,7 @@ struct Curl_cftype Curl_cft_h2_proxy = {
   cf_h2_proxy_destroy,
   cf_h2_proxy_connect,
   cf_h2_proxy_close,
+  cf_h2_proxy_shutdown,
   Curl_cf_http_proxy_get_host,
   cf_h2_proxy_adjust_pollset,
   cf_h2_proxy_data_pending,
diff --git a/lib/cf-haproxy.c b/lib/cf-haproxy.c
index 2abc4d754..200c13958 100644
--- a/lib/cf-haproxy.c
+++ b/lib/cf-haproxy.c
@@ -194,6 +194,7 @@ struct Curl_cftype Curl_cft_haproxy = {
   cf_haproxy_destroy,
   cf_haproxy_connect,
   cf_haproxy_close,
+  Curl_cf_def_shutdown,
   Curl_cf_def_get_host,
   cf_haproxy_adjust_pollset,
   Curl_cf_def_data_pending,
diff --git a/lib/cf-https-connect.c b/lib/cf-https-connect.c
index 50ac8d4bc..7a6bd97e1 100644
--- a/lib/cf-https-connect.c
+++ b/lib/cf-https-connect.c
@@ -55,7 +55,8 @@ struct cf_hc_baller {
   CURLcode result;
   struct curltime started;
   int reply_ms;
-  bool enabled;
+  BIT(enabled);
+  BIT(shutdown);
 };
 
 static void cf_hc_baller_reset(struct cf_hc_baller *b,
@@ -322,6 +323,49 @@ out:
   return result;
 }
 
+static CURLcode cf_hc_shutdown(struct Curl_cfilter *cf,
+                               struct Curl_easy *data, bool *done)
+{
+  struct cf_hc_ctx *ctx = cf->ctx;
+  struct cf_hc_baller *ballers[2];
+  size_t i;
+  CURLcode result = CURLE_OK;
+
+  DEBUGASSERT(data);
+  if(cf->connected) {
+    *done = TRUE;
+    return CURLE_OK;
+  }
+
+  /* shutdown all ballers that have not done so already. If one fails,
+   * continue shutting down others until all are shutdown. */
+  ballers[0] = &ctx->h3_baller;
+  ballers[1] = &ctx->h21_baller;
+  for(i = 0; i < sizeof(ballers)/sizeof(ballers[0]); i++) {
+    struct cf_hc_baller *b = ballers[i];
+    bool bdone = FALSE;
+    if(!cf_hc_baller_is_active(b) || b->shutdown)
+      continue;
+    b->result = b->cf->cft->do_shutdown(b->cf, data, &bdone);
+    if(b->result || bdone)
+      b->shutdown = TRUE; /* treat a failed shutdown as done */
+  }
+
+  *done = TRUE;
+  for(i = 0; i < sizeof(ballers)/sizeof(ballers[0]); i++) {
+    if(ballers[i] && !ballers[i]->shutdown)
+      *done = FALSE;
+  }
+  if(*done) {
+    for(i = 0; i < sizeof(ballers)/sizeof(ballers[0]); i++) {
+      if(ballers[i] && ballers[i]->result)
+        result = ballers[i]->result;
+    }
+  }
+  CURL_TRC_CF(data, cf, "shutdown -> %d, done=%d", result, *done);
+  return result;
+}
+
 static void cf_hc_adjust_pollset(struct Curl_cfilter *cf,
                                   struct Curl_easy *data,
                                   struct easy_pollset *ps)
@@ -434,6 +478,7 @@ struct Curl_cftype Curl_cft_http_connect = {
   cf_hc_destroy,
   cf_hc_connect,
   cf_hc_close,
+  cf_hc_shutdown,
   Curl_cf_def_get_host,
   cf_hc_adjust_pollset,
   cf_hc_data_pending,
@@ -510,7 +555,7 @@ CURLcode Curl_cf_https_setup(struct Curl_easy *data,
 
   if(data->state.httpwant == CURL_HTTP_VERSION_3ONLY) {
     result = Curl_conn_may_http3(data, conn);
-    if(result) /* can't do it */
+    if(result) /* cannot do it */
       goto out;
     try_h3 = TRUE;
     try_h21 = FALSE;
diff --git a/lib/cf-socket.c b/lib/cf-socket.c
index 3e87889f9..2e92db29d 100644
--- a/lib/cf-socket.c
+++ b/lib/cf-socket.c
@@ -35,6 +35,9 @@
 #elif defined(HAVE_NETINET_TCP_H)
 #include <netinet/tcp.h>
 #endif
+#ifdef HAVE_NETINET_UDP_H
+#include <netinet/udp.h>
+#endif
 #ifdef HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #endif
@@ -53,6 +56,11 @@
 #include <inet.h>
 #endif
 
+#ifdef __DragonFly__
+/* Required for __DragonFly_version */
+#include <sys/param.h>
+#endif
+
 #include "urldata.h"
 #include "bufq.h"
 #include "sendf.h"
@@ -73,6 +81,7 @@
 #include "multihandle.h"
 #include "rand.h"
 #include "share.h"
+#include "strdup.h"
 #include "version_win32.h"
 
 /* The last 3 #include files should be in this order */
@@ -137,8 +146,12 @@ static void nosigpipe(struct Curl_easy *data,
 #define nosigpipe(x,y) Curl_nop_stmt
 #endif
 
-#if defined(__DragonFly__) || defined(USE_WINSOCK)
-/* DragonFlyBSD and Windows use millisecond units */
+#if defined(USE_WINSOCK) || \
+   (defined(__sun) && !defined(TCP_KEEPIDLE)) || \
+   (defined(__DragonFly__) && __DragonFly_version < 500702) || \
+   (defined(_WIN32) && !defined(TCP_KEEPIDLE))
+/* Solaris < 11.4, DragonFlyBSD < 500702 and Windows < 10.0.16299
+ * use millisecond units. */
 #define KEEPALIVE_FACTOR(x) (x *= 1000)
 #else
 #define KEEPALIVE_FACTOR(x)
@@ -168,23 +181,50 @@ tcpkeepalive(struct Curl_easy *data,
           sockfd, SOCKERRNO);
   }
   else {
-#if defined(SIO_KEEPALIVE_VALS)
+#if defined(SIO_KEEPALIVE_VALS) /* Windows */
+/* Windows 10, version 1709 (10.0.16299) and later versions */
+#if defined(TCP_KEEPIDLE) && defined(TCP_KEEPINTVL) && defined(TCP_KEEPCNT)
+    optval = curlx_sltosi(data->set.tcp_keepidle);
+    KEEPALIVE_FACTOR(optval);
+    if(setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPIDLE,
+                (const char *)&optval, sizeof(optval)) < 0) {
+      infof(data, "Failed to set TCP_KEEPIDLE on fd "
+            "%" CURL_FORMAT_SOCKET_T ": errno %d",
+            sockfd, SOCKERRNO);
+    }
+    optval = curlx_sltosi(data->set.tcp_keepintvl);
+    KEEPALIVE_FACTOR(optval);
+    if(setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPINTVL,
+                (const char *)&optval, sizeof(optval)) < 0) {
+      infof(data, "Failed to set TCP_KEEPINTVL on fd "
+            "%" CURL_FORMAT_SOCKET_T ": errno %d",
+            sockfd, SOCKERRNO);
+    }
+    optval = curlx_sltosi(data->set.tcp_keepcnt);
+    if(setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPCNT,
+                (const char *)&optval, sizeof(optval)) < 0) {
+      infof(data, "Failed to set TCP_KEEPCNT on fd "
+            "%" CURL_FORMAT_SOCKET_T ": errno %d",
+            sockfd, SOCKERRNO);
+    }
+#else /* Windows < 10.0.16299 */
     struct tcp_keepalive vals;
     DWORD dummy;
     vals.onoff = 1;
     optval = curlx_sltosi(data->set.tcp_keepidle);
     KEEPALIVE_FACTOR(optval);
-    vals.keepalivetime = optval;
+    vals.keepalivetime = (u_long)optval;
     optval = curlx_sltosi(data->set.tcp_keepintvl);
     KEEPALIVE_FACTOR(optval);
-    vals.keepaliveinterval = optval;
+    vals.keepaliveinterval = (u_long)optval;
     if(WSAIoctl(sockfd, SIO_KEEPALIVE_VALS, (LPVOID) &vals, sizeof(vals),
                 NULL, 0, &dummy, NULL, NULL) != 0) {
       infof(data, "Failed to set SIO_KEEPALIVE_VALS on fd "
                   "%" CURL_FORMAT_SOCKET_T ": errno %d",
                   sockfd, SOCKERRNO);
     }
-#else
+#endif
+#else /* !Windows */
 #ifdef TCP_KEEPIDLE
     optval = curlx_sltosi(data->set.tcp_keepidle);
     KEEPALIVE_FACTOR(optval);
@@ -204,6 +244,16 @@ tcpkeepalive(struct Curl_easy *data,
             "%" CURL_FORMAT_SOCKET_T ": errno %d",
             sockfd, SOCKERRNO);
     }
+#elif defined(TCP_KEEPALIVE_THRESHOLD)
+    /* Solaris <11.4 style */
+    optval = curlx_sltosi(data->set.tcp_keepidle);
+    KEEPALIVE_FACTOR(optval);
+    if(setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPALIVE_THRESHOLD,
+      (void *)&optval, sizeof(optval)) < 0) {
+      infof(data, "Failed to set TCP_KEEPALIVE_THRESHOLD on fd "
+            "%" CURL_FORMAT_SOCKET_T ": errno %d",
+            sockfd, SOCKERRNO);
+    }
 #endif
 #ifdef TCP_KEEPINTVL
     optval = curlx_sltosi(data->set.tcp_keepintvl);
@@ -214,6 +264,36 @@ tcpkeepalive(struct Curl_easy *data,
             "%" CURL_FORMAT_SOCKET_T ": errno %d",
             sockfd, SOCKERRNO);
     }
+#elif defined(TCP_KEEPALIVE_ABORT_THRESHOLD)
+    /* Solaris <11.4 style */
+    /* TCP_KEEPALIVE_ABORT_THRESHOLD should equal to
+     * TCP_KEEPCNT * TCP_KEEPINTVL on other platforms.
+     * The default value of TCP_KEEPCNT is 9 on Linux,
+     * 8 on *BSD/macOS, 5 or 10 on Windows. We use the
+     * default config for Solaris <11.4 because there is
+     * no default value for TCP_KEEPCNT on Solaris 11.4.
+     *
+     * Note that the consequent probes will not be sent
+     * at equal intervals on Solaris, but will be sent
+     * using the exponential backoff algorithm. */
+    optval = curlx_sltosi(data->set.tcp_keepcnt) *
+             curlx_sltosi(data->set.tcp_keepintvl);
+    KEEPALIVE_FACTOR(optval);
+    if(setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPALIVE_ABORT_THRESHOLD,
+          (void *)&optval, sizeof(optval)) < 0) {
+      infof(data, "Failed to set TCP_KEEPALIVE_ABORT_THRESHOLD on fd "
+            "%" CURL_FORMAT_SOCKET_T ": errno %d",
+            sockfd, SOCKERRNO);
+    }
+#endif
+#ifdef TCP_KEEPCNT
+    optval = curlx_sltosi(data->set.tcp_keepcnt);
+    if(setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPCNT,
+                (void *)&optval, sizeof(optval)) < 0) {
+      infof(data, "Failed to set TCP_KEEPCNT on fd "
+            "%" CURL_FORMAT_SOCKET_T ": errno %d",
+            sockfd, SOCKERRNO);
+    }
 #endif
 #endif
   }
@@ -249,7 +329,7 @@ void Curl_sock_assign_addr(struct Curl_sockaddr_ex *dest,
     dest->protocol = IPPROTO_UDP;
     break;
   }
-  dest->addrlen = ai->ai_addrlen;
+  dest->addrlen = (unsigned int)ai->ai_addrlen;
 
   if(dest->addrlen > sizeof(struct Curl_sockaddr_storage))
     dest->addrlen = sizeof(struct Curl_sockaddr_storage);
@@ -314,7 +394,7 @@ CURLcode Curl_socket_open(struct Curl_easy *data,
   struct Curl_sockaddr_ex dummy;
 
   if(!addr)
-    /* if the caller doesn't want info back, use a local temp copy */
+    /* if the caller does not want info back, use a local temp copy */
     addr = &dummy;
 
   Curl_sock_assign_addr(addr, ai, transport);
@@ -363,14 +443,14 @@ int Curl_socket_close(struct Curl_easy *data, struct connectdata *conn,
    Buffer Size
 
    The problem described in this knowledge-base is applied only to pre-Vista
-   Windows.  Following function trying to detect OS version and skips
+   Windows. Following function trying to detect OS version and skips
    SO_SNDBUF adjustment for Windows Vista and above.
 */
 #define DETECT_OS_NONE 0
 #define DETECT_OS_PREVISTA 1
 #define DETECT_OS_VISTA_OR_LATER 2
 
-void Curl_sndbufset(curl_socket_t sockfd)
+void Curl_sndbuf_init(curl_socket_t sockfd)
 {
   int val = CURL_MAX_WRITE_SIZE + 32;
   int curval = 0;
@@ -395,7 +475,83 @@ void Curl_sndbufset(curl_socket_t sockfd)
 
   setsockopt(sockfd, SOL_SOCKET, SO_SNDBUF, (const char *)&val, sizeof(val));
 }
-#endif
+#endif /* USE_WINSOCK */
+
+/*
+ * Curl_parse_interface()
+ *
+ * This is used to parse interface argument in the following formats.
+ * In all the examples, `host` can be an IP address or a hostname.
+ *
+ *   <iface_or_host> - can be either an interface name or a host.
+ *   if!<iface> - interface name.
+ *   host!<host> - hostname.
+ *   ifhost!<iface>!<host> - interface name and hostname.
+ *
+ * Parameters:
+ *
+ * input  [in]     - input string.
+ * len    [in]     - length of the input string.
+ * dev    [in/out] - address where a pointer to newly allocated memory
+ *                   holding the interface-or-host will be stored upon
+ *                   completion.
+ * iface  [in/out] - address where a pointer to newly allocated memory
+ *                   holding the interface will be stored upon completion.
+ * host   [in/out] - address where a pointer to newly allocated memory
+ *                   holding the host will be stored upon completion.
+ *
+ * Returns CURLE_OK on success.
+ */
+CURLcode Curl_parse_interface(const char *input, size_t len,
+                              char **dev, char **iface, char **host)
+{
+  static const char if_prefix[] = "if!";
+  static const char host_prefix[] = "host!";
+  static const char if_host_prefix[] = "ifhost!";
+
+  DEBUGASSERT(dev);
+  DEBUGASSERT(iface);
+  DEBUGASSERT(host);
+
+  if(strncmp(if_prefix, input, strlen(if_prefix)) == 0) {
+    input += strlen(if_prefix);
+    if(!*input)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    *iface = Curl_memdup0(input, len - strlen(if_prefix));
+    return *iface ? CURLE_OK : CURLE_OUT_OF_MEMORY;
+  }
+  if(strncmp(host_prefix, input, strlen(host_prefix)) == 0) {
+    input += strlen(host_prefix);
+    if(!*input)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    *host = Curl_memdup0(input, len - strlen(host_prefix));
+    return *host ? CURLE_OK : CURLE_OUT_OF_MEMORY;
+  }
+  if(strncmp(if_host_prefix, input, strlen(if_host_prefix)) == 0) {
+    const char *host_part;
+    input += strlen(if_host_prefix);
+    len -= strlen(if_host_prefix);
+    host_part = memchr(input, '!', len);
+    if(!host_part || !*(host_part + 1))
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    *iface = Curl_memdup0(input, host_part - input);
+    if(!*iface)
+      return CURLE_OUT_OF_MEMORY;
+    ++host_part;
+    *host = Curl_memdup0(host_part, len - (host_part - input));
+    if(!*host) {
+      free(*iface);
+      *iface = NULL;
+      return CURLE_OUT_OF_MEMORY;
+    }
+    return CURLE_OK;
+  }
+
+  if(!*input)
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+  *dev = Curl_memdup0(input, len);
+  return *dev ? CURLE_OK : CURLE_OUT_OF_MEMORY;
+}
 
 #ifndef CURL_DISABLE_BINDLOCAL
 static CURLcode bindlocal(struct Curl_easy *data, struct connectdata *conn,
@@ -415,6 +571,10 @@ static CURLcode bindlocal(struct Curl_easy *data, struct connectdata *conn,
   /* how many port numbers to try to bind to, increasing one at a time */
   int portnum = data->set.localportrange;
   const char *dev = data->set.str[STRING_DEVICE];
+  const char *iface_input = data->set.str[STRING_INTERFACE];
+  const char *host_input = data->set.str[STRING_BINDHOST];
+  const char *iface = iface_input ? iface_input : dev;
+  const char *host = host_input ? host_input : dev;
   int error;
 #ifdef IP_BIND_ADDRESS_NO_PORT
   int on = 1;
@@ -426,83 +586,77 @@ static CURLcode bindlocal(struct Curl_easy *data, struct connectdata *conn,
   /*************************************************************
    * Select device to bind socket to
    *************************************************************/
-  if(!dev && !port)
+  if(!iface && !host && !port)
     /* no local kind of binding was requested */
     return CURLE_OK;
 
   memset(&sa, 0, sizeof(struct Curl_sockaddr_storage));
 
-  if(dev && (strlen(dev)<255) ) {
+  if(iface && (strlen(iface)<255) ) {
     char myhost[256] = "";
     int done = 0; /* -1 for error, 1 for address found */
-    bool is_interface = FALSE;
-    bool is_host = FALSE;
-    static const char *if_prefix = "if!";
-    static const char *host_prefix = "host!";
-
-    if(strncmp(if_prefix, dev, strlen(if_prefix)) == 0) {
-      dev += strlen(if_prefix);
-      is_interface = TRUE;
-    }
-    else if(strncmp(host_prefix, dev, strlen(host_prefix)) == 0) {
-      dev += strlen(host_prefix);
-      is_host = TRUE;
-    }
+    if2ip_result_t if2ip_result = IF2IP_NOT_FOUND;
 
     /* interface */
-    if(!is_host) {
 #ifdef SO_BINDTODEVICE
-      /*
-       * This binds the local socket to a particular interface. This will
-       * force even requests to other local interfaces to go out the external
-       * interface. Only bind to the interface when specified as interface,
-       * not just as a hostname or ip address.
-       *
-       * The interface might be a VRF, eg: vrf-blue, which means it cannot be
-       * converted to an IP address and would fail Curl_if2ip. Simply try to
-       * use it straight away.
-       */
-      if(setsockopt(sockfd, SOL_SOCKET, SO_BINDTODEVICE,
-                    dev, (curl_socklen_t)strlen(dev) + 1) == 0) {
-        /* This is often "errno 1, error: Operation not permitted" if you're
-         * not running as root or another suitable privileged user. If it
-         * succeeds it means the parameter was a valid interface and not an IP
-         * address. Return immediately.
-         */
-        infof(data, "socket successfully bound to interface '%s'", dev);
+    /*
+      * This binds the local socket to a particular interface. This will
+      * force even requests to other local interfaces to go out the external
+      * interface. Only bind to the interface when specified as interface,
+      * not just as a hostname or ip address.
+      *
+      * The interface might be a VRF, eg: vrf-blue, which means it cannot be
+      * converted to an IP address and would fail Curl_if2ip. Simply try to
+      * use it straight away.
+      */
+    if(setsockopt(sockfd, SOL_SOCKET, SO_BINDTODEVICE,
+                  iface, (curl_socklen_t)strlen(iface) + 1) == 0) {
+      /* This is often "errno 1, error: Operation not permitted" if you are
+        * not running as root or another suitable privileged user. If it
+        * succeeds it means the parameter was a valid interface and not an IP
+        * address. Return immediately.
+        */
+      if(!host_input) {
+        infof(data, "socket successfully bound to interface '%s'", iface);
         return CURLE_OK;
       }
+    }
 #endif
-
-      switch(Curl_if2ip(af,
+    if(!host_input) {
+      /* Discover IP from input device, then bind to it */
+      if2ip_result = Curl_if2ip(af,
 #ifdef USE_IPV6
-                        scope, conn->scope_id,
-#endif
-                        dev, myhost, sizeof(myhost))) {
-        case IF2IP_NOT_FOUND:
-          if(is_interface) {
-            /* Do not fall back to treating it as a host name */
-            failf(data, "Couldn't bind to interface '%s'", dev);
-            return CURLE_INTERFACE_FAILED;
-          }
-          break;
-        case IF2IP_AF_NOT_SUPPORTED:
-          /* Signal the caller to try another address family if available */
-          return CURLE_UNSUPPORTED_PROTOCOL;
-        case IF2IP_FOUND:
-          is_interface = TRUE;
-          /*
-           * We now have the numerical IP address in the 'myhost' buffer
-           */
-          infof(data, "Local Interface %s is ip %s using address family %i",
-                dev, myhost, af);
-          done = 1;
-          break;
-      }
+                      scope, conn->scope_id,
+#endif
+                      iface, myhost, sizeof(myhost));
+    }
+    switch(if2ip_result) {
+      case IF2IP_NOT_FOUND:
+        if(iface_input && !host_input) {
+          /* Do not fall back to treating it as a hostname */
+          char buffer[STRERROR_LEN];
+          data->state.os_errno = error = SOCKERRNO;
+          failf(data, "Couldn't bind to interface '%s' with errno %d: %s",
+                iface, error, Curl_strerror(error, buffer, sizeof(buffer)));
+          return CURLE_INTERFACE_FAILED;
+        }
+        break;
+      case IF2IP_AF_NOT_SUPPORTED:
+        /* Signal the caller to try another address family if available */
+        return CURLE_UNSUPPORTED_PROTOCOL;
+      case IF2IP_FOUND:
+        /*
+          * We now have the numerical IP address in the 'myhost' buffer
+          */
+        host = myhost;
+        infof(data, "Local Interface %s is ip %s using address family %i",
+              iface, host, af);
+        done = 1;
+        break;
     }
-    if(!is_interface) {
+    if(!iface_input || host_input) {
       /*
-       * This was not an interface, resolve the name as a host name
+       * This was not an interface, resolve the name as a hostname
        * or IP number
        *
        * Temporarily force name resolution to use only the address type
@@ -519,7 +673,7 @@ static CURLcode bindlocal(struct Curl_easy *data, struct connectdata *conn,
         conn->ip_version = CURL_IPRESOLVE_V6;
 #endif
 
-      rc = Curl_resolv(data, dev, 80, FALSE, &h);
+      rc = Curl_resolv(data, host, 80, FALSE, &h);
       if(rc == CURLRESOLV_PENDING)
         (void)Curl_resolver_wait_resolv(data, &h);
       conn->ip_version = ipver;
@@ -528,7 +682,7 @@ static CURLcode bindlocal(struct Curl_easy *data, struct connectdata *conn,
         /* convert the resolved address, sizeof myhost >= INET_ADDRSTRLEN */
         Curl_printable_address(h->addr, myhost, sizeof(myhost));
         infof(data, "Name '%s' family %i resolved to '%s' family %i",
-              dev, af, myhost, h->addr->ai_family);
+              host, af, myhost, h->addr->ai_family);
         Curl_resolv_unlock(data, h);
         if(af != h->addr->ai_family) {
           /* bad IP version combo, signal the caller to try another address
@@ -562,7 +716,7 @@ static CURLcode bindlocal(struct Curl_easy *data, struct connectdata *conn,
           if(scope_ptr) {
             /* The "myhost" string either comes from Curl_if2ip or from
                Curl_printable_address. The latter returns only numeric scope
-               IDs and the former returns none at all.  So the scope ID, if
+               IDs and the former returns none at all. So the scope ID, if
                present, is known to be numeric */
             unsigned long scope_id = strtoul(scope_ptr, NULL, 10);
             if(scope_id > UINT_MAX)
@@ -589,8 +743,11 @@ static CURLcode bindlocal(struct Curl_easy *data, struct connectdata *conn,
       /* errorbuf is set false so failf will overwrite any message already in
          the error buffer, so the user receives this error message instead of a
          generic resolve error. */
+      char buffer[STRERROR_LEN];
       data->state.errorbuf = FALSE;
-      failf(data, "Couldn't bind to '%s'", dev);
+      data->state.os_errno = error = SOCKERRNO;
+      failf(data, "Couldn't bind to '%s' with errno %d: %s",
+            host, error, Curl_strerror(error, buffer, sizeof(buffer)));
       return CURLE_INTERFACE_FAILED;
     }
   }
@@ -667,8 +824,8 @@ static bool verifyconnect(curl_socket_t sockfd, int *error)
    * Gisle Vanem could reproduce the former problems with this function, but
    * could avoid them by adding this SleepEx() call below:
    *
-   *    "I don't have Rational Quantify, but the hint from his post was
-   *    ntdll::NtRemoveIoCompletion(). So I'd assume the SleepEx (or maybe
+   *    "I do not have Rational Quantify, but the hint from his post was
+   *    ntdll::NtRemoveIoCompletion(). I would assume the SleepEx (or maybe
    *    just Sleep(0) would be enough?) would release whatever
    *    mutex/critical-section the ntdll call is waiting on.
    *
@@ -686,14 +843,14 @@ static bool verifyconnect(curl_socket_t sockfd, int *error)
   if(0 != getsockopt(sockfd, SOL_SOCKET, SO_ERROR, (void *)&err, &errSize))
     err = SOCKERRNO;
 #ifdef _WIN32_WCE
-  /* Old WinCE versions don't support SO_ERROR */
+  /* Old WinCE versions do not support SO_ERROR */
   if(WSAENOPROTOOPT == err) {
     SET_SOCKERRNO(0);
     err = 0;
   }
 #endif
 #if defined(EBADIOCTL) && defined(__minix)
-  /* Minix 3.1.x doesn't support getsockopt on UDP sockets */
+  /* Minix 3.1.x does not support getsockopt on UDP sockets */
   if(EBADIOCTL == err) {
     SET_SOCKERRNO(0);
     err = 0;
@@ -703,7 +860,7 @@ static bool verifyconnect(curl_socket_t sockfd, int *error)
     /* we are connected, awesome! */
     rc = TRUE;
   else
-    /* This wasn't a successful connect */
+    /* This was not a successful connect */
     rc = FALSE;
   if(error)
     *error = err;
@@ -765,11 +922,14 @@ struct cf_socket_ctx {
   int transport;
   struct Curl_sockaddr_ex addr;      /* address to connect to */
   curl_socket_t sock;                /* current attempt socket */
-  struct bufq recvbuf;               /* used when `buffer_recv` is set */
   struct ip_quadruple ip;            /* The IP quadruple 2x(addr+port) */
   struct curltime started_at;        /* when socket was created */
   struct curltime connected_at;      /* when socket connected/got first byte */
   struct curltime first_byte_at;     /* when first byte was recvd */
+#ifdef USE_WINSOCK
+  struct curltime last_sndbuf_query_at;  /* when SO_SNDBUF last queried */
+  ULONG sndbuf_size;                     /* the last set SO_SNDBUF size */
+#endif
   int error;                         /* errno of last failure or 0 */
 #ifdef DEBUGBUILD
   int wblock_percent;                /* percent of writes doing EAGAIN */
@@ -781,7 +941,6 @@ struct cf_socket_ctx {
   BIT(accepted);                     /* socket was accepted, not connected */
   BIT(sock_connected);               /* socket is "connected", e.g. in UDP */
   BIT(active);
-  BIT(buffer_recv);
 };
 
 static void cf_socket_ctx_init(struct cf_socket_ctx *ctx,
@@ -792,7 +951,6 @@ static void cf_socket_ctx_init(struct cf_socket_ctx *ctx,
   ctx->sock = CURL_SOCKET_BAD;
   ctx->transport = transport;
   Curl_sock_assign_addr(&ctx->addr, ai, transport);
-  Curl_bufq_init(&ctx->recvbuf, NW_RECV_CHUNK_SIZE, NW_RECV_CHUNKS);
 #ifdef DEBUGBUILD
   {
     char *p = getenv("CURL_DBG_SOCK_WBLOCK");
@@ -823,56 +981,6 @@ static void cf_socket_ctx_init(struct cf_socket_ctx *ctx,
 #endif
 }
 
-struct reader_ctx {
-  struct Curl_cfilter *cf;
-  struct Curl_easy *data;
-};
-
-static ssize_t nw_in_read(void *reader_ctx,
-                           unsigned char *buf, size_t len,
-                           CURLcode *err)
-{
-  struct reader_ctx *rctx = reader_ctx;
-  struct cf_socket_ctx *ctx = rctx->cf->ctx;
-  ssize_t nread;
-
-  *err = CURLE_OK;
-  nread = sread(ctx->sock, buf, len);
-
-  if(-1 == nread) {
-    int sockerr = SOCKERRNO;
-
-    if(
-#ifdef WSAEWOULDBLOCK
-      /* This is how Windows does it */
-      (WSAEWOULDBLOCK == sockerr)
-#else
-      /* errno may be EWOULDBLOCK or on some systems EAGAIN when it returned
-         due to its inability to send off data without blocking. We therefore
-         treat both error codes the same here */
-      (EWOULDBLOCK == sockerr) || (EAGAIN == sockerr) || (EINTR == sockerr)
-#endif
-      ) {
-      /* this is just a case of EWOULDBLOCK */
-      *err = CURLE_AGAIN;
-      nread = -1;
-    }
-    else {
-      char buffer[STRERROR_LEN];
-
-      failf(rctx->data, "Recv failure: %s",
-            Curl_strerror(sockerr, buffer, sizeof(buffer)));
-      rctx->data->state.os_errno = sockerr;
-      *err = CURLE_RECV_ERROR;
-      nread = -1;
-    }
-  }
-  CURL_TRC_CF(rctx->data, rctx->cf, "nw_in_read(len=%zu, fd=%"
-              CURL_FORMAT_SOCKET_T ") -> %d, err=%d",
-              len, ctx->sock, (int)nread, *err);
-  return nread;
-}
-
 static void cf_socket_close(struct Curl_cfilter *cf, struct Curl_easy *data)
 {
   struct cf_socket_ctx *ctx = cf->ctx;
@@ -886,9 +994,7 @@ static void cf_socket_close(struct Curl_cfilter *cf, struct Curl_easy *data)
     ctx->sock = CURL_SOCKET_BAD;
     if(ctx->active && cf->sockindex == FIRSTSOCKET)
       cf->conn->remote_addr = NULL;
-    Curl_bufq_reset(&ctx->recvbuf);
     ctx->active = FALSE;
-    ctx->buffer_recv = FALSE;
     memset(&ctx->started_at, 0, sizeof(ctx->started_at));
     memset(&ctx->connected_at, 0, sizeof(ctx->connected_at));
   }
@@ -896,13 +1002,35 @@ static void cf_socket_close(struct Curl_cfilter *cf, struct Curl_easy *data)
   cf->connected = FALSE;
 }
 
+static CURLcode cf_socket_shutdown(struct Curl_cfilter *cf,
+                                   struct Curl_easy *data,
+                                   bool *done)
+{
+  if(cf->connected) {
+    struct cf_socket_ctx *ctx = cf->ctx;
+
+    CURL_TRC_CF(data, cf, "cf_socket_shutdown(%" CURL_FORMAT_SOCKET_T
+                ")", ctx->sock);
+    /* On TCP, and when the socket looks well and non-blocking mode
+     * can be enabled, receive dangling bytes before close to avoid
+     * entering RST states unnecessarily. */
+    if(ctx->sock != CURL_SOCKET_BAD &&
+       ctx->transport == TRNSPRT_TCP &&
+       (curlx_nonblock(ctx->sock, TRUE) >= 0)) {
+      unsigned char buf[1024];
+      (void)sread(ctx->sock, buf, sizeof(buf));
+    }
+  }
+  *done = TRUE;
+  return CURLE_OK;
+}
+
 static void cf_socket_destroy(struct Curl_cfilter *cf, struct Curl_easy *data)
 {
   struct cf_socket_ctx *ctx = cf->ctx;
 
   cf_socket_close(cf, data);
   CURL_TRC_CF(data, cf, "destroy");
-  Curl_bufq_free(&ctx->recvbuf);
   free(ctx);
   cf->ctx = NULL;
 }
@@ -949,7 +1077,7 @@ static CURLcode set_remote_ip(struct Curl_cfilter *cf,
   struct cf_socket_ctx *ctx = cf->ctx;
 
   /* store remote address and port used in this connection attempt */
-  if(!Curl_addr2string(&ctx->addr.sa_addr, ctx->addr.addrlen,
+  if(!Curl_addr2string(&ctx->addr.sa_addr, (curl_socklen_t)ctx->addr.addrlen,
                        ctx->ip.remote_ip, &ctx->ip.remote_port)) {
     char buffer[STRERROR_LEN];
 
@@ -974,7 +1102,20 @@ static CURLcode cf_socket_open(struct Curl_cfilter *cf,
   (void)data;
   DEBUGASSERT(ctx->sock == CURL_SOCKET_BAD);
   ctx->started_at = Curl_now();
+#ifdef SOCK_NONBLOCK
+  /* Do not tuck SOCK_NONBLOCK into socktype when opensocket callback is set
+   * because we would not know how socketype is about to be used in the
+   * callback, SOCK_NONBLOCK might get factored out before calling socket().
+   */
+  if(!data->set.fopensocket)
+    ctx->addr.socktype |= SOCK_NONBLOCK;
+#endif
   result = socket_open(data, &ctx->addr, &ctx->sock);
+#ifdef SOCK_NONBLOCK
+  /* Restore the socktype after the socket is created. */
+  if(!data->set.fopensocket)
+    ctx->addr.socktype &= ~SOCK_NONBLOCK;
+#endif
   if(result)
     goto out;
 
@@ -1004,7 +1145,7 @@ static CURLcode cf_socket_open(struct Curl_cfilter *cf,
 
   nosigpipe(data, ctx->sock);
 
-  Curl_sndbufset(ctx->sock);
+  Curl_sndbuf_init(ctx->sock);
 
   if(is_tcp && data->set.tcp_keepalive)
     tcpkeepalive(data, ctx->sock);
@@ -1045,8 +1186,27 @@ static CURLcode cf_socket_open(struct Curl_cfilter *cf,
   }
 #endif
 
-  /* set socket non-blocking */
-  (void)curlx_nonblock(ctx->sock, TRUE);
+#ifndef SOCK_NONBLOCK
+  /* Set socket non-blocking, must be a non-blocking socket for
+   * a non-blocking connect. */
+  error = curlx_nonblock(ctx->sock, TRUE);
+  if(error < 0) {
+    result = CURLE_UNSUPPORTED_PROTOCOL;
+    ctx->error = SOCKERRNO;
+    goto out;
+  }
+#else
+  if(data->set.fopensocket) {
+    /* Set socket non-blocking, must be a non-blocking socket for
+     * a non-blocking connect. */
+    error = curlx_nonblock(ctx->sock, TRUE);
+    if(error < 0) {
+      result = CURLE_UNSUPPORTED_PROTOCOL;
+      ctx->error = SOCKERRNO;
+      goto out;
+    }
+  }
+#endif
   ctx->sock_connected = (ctx->addr.socktype != SOCK_DGRAM);
 out:
   if(result) {
@@ -1114,7 +1274,8 @@ static int do_connect(struct Curl_cfilter *cf, struct Curl_easy *data,
 #endif
   }
   else {
-    rc = connect(ctx->sock, &ctx->addr.sa_addr, ctx->addr.addrlen);
+    rc = connect(ctx->sock, &ctx->addr.sa_addr,
+                 (curl_socklen_t)ctx->addr.addrlen);
   }
   return rc;
 }
@@ -1257,13 +1418,36 @@ static bool cf_socket_data_pending(struct Curl_cfilter *cf,
   int readable;
 
   (void)data;
-  if(!Curl_bufq_is_empty(&ctx->recvbuf))
-    return TRUE;
-
   readable = SOCKET_READABLE(ctx->sock, 0);
   return (readable > 0 && (readable & CURL_CSELECT_IN));
 }
 
+#ifdef USE_WINSOCK
+
+#ifndef SIO_IDEAL_SEND_BACKLOG_QUERY
+#define SIO_IDEAL_SEND_BACKLOG_QUERY 0x4004747B
+#endif
+
+static void win_update_sndbuf_size(struct cf_socket_ctx *ctx)
+{
+  ULONG ideal;
+  DWORD ideallen;
+  struct curltime n = Curl_now();
+
+  if(Curl_timediff(n, ctx->last_sndbuf_query_at) > 1000) {
+    if(!WSAIoctl(ctx->sock, SIO_IDEAL_SEND_BACKLOG_QUERY, 0, 0,
+                  &ideal, sizeof(ideal), &ideallen, 0, 0) &&
+       ideal != ctx->sndbuf_size &&
+       !setsockopt(ctx->sock, SOL_SOCKET, SO_SNDBUF,
+                   (const char *)&ideal, sizeof(ideal))) {
+      ctx->sndbuf_size = ideal;
+    }
+    ctx->last_sndbuf_query_at = n;
+  }
+}
+
+#endif /* USE_WINSOCK */
+
 static ssize_t cf_socket_send(struct Curl_cfilter *cf, struct Curl_easy *data,
                               const void *buf, size_t len, CURLcode *err)
 {
@@ -1336,6 +1520,11 @@ static ssize_t cf_socket_send(struct Curl_cfilter *cf, struct Curl_easy *data,
     }
   }
 
+#if defined(USE_WINSOCK)
+  if(!*err)
+    win_update_sndbuf_size(ctx);
+#endif
+
   CURL_TRC_CF(data, cf, "send(len=%zu) -> %d, err=%d",
               orig_len, (int)nwritten, *err);
   cf->conn->sock[cf->sockindex] = fdsave;
@@ -1346,14 +1535,10 @@ static ssize_t cf_socket_recv(struct Curl_cfilter *cf, struct Curl_easy *data,
                               char *buf, size_t len, CURLcode *err)
 {
   struct cf_socket_ctx *ctx = cf->ctx;
-  curl_socket_t fdsave;
   ssize_t nread;
 
   *err = CURLE_OK;
 
-  fdsave = cf->conn->sock[cf->sockindex];
-  cf->conn->sock[cf->sockindex] = ctx->sock;
-
 #ifdef DEBUGBUILD
   /* simulate network blocking/partial reads */
   if(cf->cft != &Curl_cft_udp && ctx->rblock_percent > 0) {
@@ -1362,9 +1547,7 @@ static ssize_t cf_socket_recv(struct Curl_cfilter *cf, struct Curl_easy *data,
     if(c >= ((100-ctx->rblock_percent)*256/100)) {
       CURL_TRC_CF(data, cf, "recv(len=%zu) SIMULATE EWOULDBLOCK", len);
       *err = CURLE_AGAIN;
-      nread = -1;
-      cf->conn->sock[cf->sockindex] = fdsave;
-      return nread;
+      return -1;
     }
   }
   if(cf->cft != &Curl_cft_udp && ctx->recv_max && ctx->recv_max < len) {
@@ -1375,54 +1558,42 @@ static ssize_t cf_socket_recv(struct Curl_cfilter *cf, struct Curl_easy *data,
   }
 #endif
 
-  if(ctx->buffer_recv && !Curl_bufq_is_empty(&ctx->recvbuf)) {
-    CURL_TRC_CF(data, cf, "recv from buffer");
-    nread = Curl_bufq_read(&ctx->recvbuf, (unsigned char *)buf, len, err);
-  }
-  else {
-    struct reader_ctx rctx;
-
-    rctx.cf = cf;
-    rctx.data = data;
-
-    /* "small" reads may trigger filling our buffer, "large" reads
-     * are probably not worth the additional copy */
-    if(ctx->buffer_recv && len < NW_SMALL_READS) {
-      ssize_t nwritten;
-      nwritten = Curl_bufq_slurp(&ctx->recvbuf, nw_in_read, &rctx, err);
-      if(nwritten < 0 && !Curl_bufq_is_empty(&ctx->recvbuf)) {
-        /* we have a partial read with an error. need to deliver
-         * what we got, return the error later. */
-        CURL_TRC_CF(data, cf, "partial read: empty buffer first");
-        nread = Curl_bufq_read(&ctx->recvbuf, (unsigned char *)buf, len, err);
-      }
-      else if(nwritten < 0) {
-        nread = -1;
-        goto out;
-      }
-      else if(nwritten == 0) {
-        /* eof */
-        *err = CURLE_OK;
-        nread = 0;
-      }
-      else {
-        CURL_TRC_CF(data, cf, "buffered %zd additional bytes", nwritten);
-        nread = Curl_bufq_read(&ctx->recvbuf, (unsigned char *)buf, len, err);
-      }
+  *err = CURLE_OK;
+  nread = sread(ctx->sock, buf, len);
+
+  if(-1 == nread) {
+    int sockerr = SOCKERRNO;
+
+    if(
+#ifdef WSAEWOULDBLOCK
+      /* This is how Windows does it */
+      (WSAEWOULDBLOCK == sockerr)
+#else
+      /* errno may be EWOULDBLOCK or on some systems EAGAIN when it returned
+         due to its inability to send off data without blocking. We therefore
+         treat both error codes the same here */
+      (EWOULDBLOCK == sockerr) || (EAGAIN == sockerr) || (EINTR == sockerr)
+#endif
+      ) {
+      /* this is just a case of EWOULDBLOCK */
+      *err = CURLE_AGAIN;
     }
     else {
-      nread = nw_in_read(&rctx, (unsigned char *)buf, len, err);
+      char buffer[STRERROR_LEN];
+
+      failf(data, "Recv failure: %s",
+            Curl_strerror(sockerr, buffer, sizeof(buffer)));
+      data->state.os_errno = sockerr;
+      *err = CURLE_RECV_ERROR;
     }
   }
 
-out:
   CURL_TRC_CF(data, cf, "recv(len=%zu) -> %d, err=%d", len, (int)nread,
               *err);
   if(nread > 0 && !ctx->got_first_byte) {
     ctx->first_byte_at = Curl_now();
     ctx->got_first_byte = TRUE;
   }
-  cf->conn->sock[cf->sockindex] = fdsave;
   return nread;
 }
 
@@ -1444,11 +1615,6 @@ static void cf_socket_active(struct Curl_cfilter *cf, struct Curl_easy *data)
     cf->conn->bits.ipv6 = (ctx->addr.family == AF_INET6)? TRUE : FALSE;
   #endif
     Curl_persistconninfo(data, cf->conn, &ctx->ip);
-    /* buffering is currently disabled by default because we have stalls
-     * in parallel transfers where not all buffered data is consumed and no
-     * socket events happen.
-     */
-    ctx->buffer_recv = FALSE;
   }
   ctx->active = TRUE;
 }
@@ -1564,6 +1730,7 @@ struct Curl_cftype Curl_cft_tcp = {
   cf_socket_destroy,
   cf_tcp_connect,
   cf_socket_close,
+  cf_socket_shutdown,
   cf_socket_get_host,
   cf_socket_adjust_pollset,
   cf_socket_data_pending,
@@ -1608,25 +1775,23 @@ out:
 }
 
 static CURLcode cf_udp_setup_quic(struct Curl_cfilter *cf,
-                               struct Curl_easy *data)
+                                  struct Curl_easy *data)
 {
   struct cf_socket_ctx *ctx = cf->ctx;
   int rc;
+  int one = 1;
+
+  (void)one;
 
   /* QUIC needs a connected socket, nonblocking */
   DEBUGASSERT(ctx->sock != CURL_SOCKET_BAD);
 
-#if defined(__APPLE__) && defined(USE_OPENSSL_QUIC)
-  (void)rc;
-  /* On macOS OpenSSL QUIC fails on connected sockets.
-   * see: <https://github.com/openssl/openssl/issues/23251> */
-#else
-  rc = connect(ctx->sock, &ctx->addr.sa_addr, ctx->addr.addrlen);
+  rc = connect(ctx->sock, &ctx->addr.sa_addr,
+               (curl_socklen_t)ctx->addr.addrlen);
   if(-1 == rc) {
     return socket_connect_result(data, ctx->ip.remote_ip, SOCKERRNO);
   }
   ctx->sock_connected = TRUE;
-#endif
   set_local_ip(cf, data);
   CURL_TRC_CF(data, cf, "%s socket %" CURL_FORMAT_SOCKET_T
               " connected: [%s:%d] -> [%s:%d]",
@@ -1634,7 +1799,11 @@ static CURLcode cf_udp_setup_quic(struct Curl_cfilter *cf,
               ctx->sock, ctx->ip.local_ip, ctx->ip.local_port,
               ctx->ip.remote_ip, ctx->ip.remote_port);
 
-  (void)curlx_nonblock(ctx->sock, TRUE);
+  /* Currently, cf->ctx->sock is always non-blocking because the only
+   * caller to cf_udp_setup_quic() is cf_udp_connect() that passes the
+   * non-blocking socket created by cf_socket_open() to it. Thus, we
+   * do not need to call curlx_nonblock() in cf_udp_setup_quic() anymore.
+   */
   switch(ctx->addr.family) {
 #if defined(__linux__) && defined(IP_MTU_DISCOVER)
   case AF_INET: {
@@ -1653,6 +1822,14 @@ static CURLcode cf_udp_setup_quic(struct Curl_cfilter *cf,
   }
 #endif
   }
+
+#if defined(__linux__) && defined(UDP_GRO) &&                                 \
+  (defined(HAVE_SENDMMSG) || defined(HAVE_SENDMSG)) &&                        \
+  ((defined(USE_NGTCP2) && defined(USE_NGHTTP3)) || defined(USE_QUICHE))
+  (void)setsockopt(ctx->sock, IPPROTO_UDP, UDP_GRO, &one,
+                   (socklen_t)sizeof(one));
+#endif
+
   return CURLE_OK;
 }
 
@@ -1702,6 +1879,7 @@ struct Curl_cftype Curl_cft_udp = {
   cf_socket_destroy,
   cf_udp_connect,
   cf_socket_close,
+  cf_socket_shutdown,
   cf_socket_get_host,
   cf_socket_adjust_pollset,
   cf_socket_data_pending,
@@ -1753,6 +1931,7 @@ struct Curl_cftype Curl_cft_unix = {
   cf_socket_destroy,
   cf_tcp_connect,
   cf_socket_close,
+  cf_socket_shutdown,
   cf_socket_get_host,
   cf_socket_adjust_pollset,
   cf_socket_data_pending,
@@ -1817,6 +1996,7 @@ struct Curl_cftype Curl_cft_tcp_accept = {
   cf_socket_destroy,
   cf_tcp_accept_connect,
   cf_socket_close,
+  cf_socket_shutdown,
   cf_socket_get_host,              /* TODO: not accurate */
   cf_socket_adjust_pollset,
   cf_socket_data_pending,
diff --git a/lib/cf-socket.h b/lib/cf-socket.h
index 058af5009..6040058b0 100644
--- a/lib/cf-socket.h
+++ b/lib/cf-socket.h
@@ -54,6 +54,11 @@ struct Curl_sockaddr_ex {
 };
 #define sa_addr _sa_ex_u.addr
 
+/*
+ * Parse interface option, and return the interface name and the host part.
+*/
+CURLcode Curl_parse_interface(const char *input, size_t len,
+                              char **dev, char **iface, char **host);
 
 /*
  * Create a socket based on info from 'conn' and 'ai'.
@@ -81,9 +86,9 @@ int Curl_socket_close(struct Curl_easy *data, struct connectdata *conn,
    Buffer Size
 
 */
-void Curl_sndbufset(curl_socket_t sockfd);
+void Curl_sndbuf_init(curl_socket_t sockfd);
 #else
-#define Curl_sndbufset(y) Curl_nop_stmt
+#define Curl_sndbuf_init(y) Curl_nop_stmt
 #endif
 
 /**
diff --git a/lib/cfilters.c b/lib/cfilters.c
index a327fa194..9a5c3578d 100644
--- a/lib/cfilters.c
+++ b/lib/cfilters.c
@@ -45,7 +45,7 @@
 #define ARRAYSIZE(A) (sizeof(A)/sizeof((A)[0]))
 #endif
 
-#ifdef DEBUGBUILD
+#ifdef UNITTESTS
 /* used by unit2600.c */
 void Curl_cf_def_close(struct Curl_cfilter *cf, struct Curl_easy *data)
 {
@@ -55,6 +55,15 @@ void Curl_cf_def_close(struct Curl_cfilter *cf, struct Curl_easy *data)
 }
 #endif
 
+CURLcode Curl_cf_def_shutdown(struct Curl_cfilter *cf,
+                              struct Curl_easy *data, bool *done)
+{
+  (void)cf;
+  (void)data;
+  *done = TRUE;
+  return CURLE_OK;
+}
+
 static void conn_report_connect_stats(struct Curl_easy *data,
                                       struct connectdata *conn);
 
@@ -166,6 +175,61 @@ void Curl_conn_close(struct Curl_easy *data, int index)
   if(cf) {
     cf->cft->do_close(cf, data);
   }
+  Curl_shutdown_clear(data, index);
+}
+
+CURLcode Curl_conn_shutdown(struct Curl_easy *data, int sockindex, bool *done)
+{
+  struct Curl_cfilter *cf;
+  CURLcode result = CURLE_OK;
+  timediff_t timeout_ms;
+  struct curltime now;
+
+  DEBUGASSERT(data->conn);
+  /* Get the first connected filter that is not shut down already. */
+  cf = data->conn->cfilter[sockindex];
+  while(cf && (!cf->connected || cf->shutdown))
+    cf = cf->next;
+
+  if(!cf) {
+    *done = TRUE;
+    return CURLE_OK;
+  }
+
+  *done = FALSE;
+  now = Curl_now();
+  if(!Curl_shutdown_started(data, sockindex)) {
+    DEBUGF(infof(data, "shutdown start on%s connection",
+           sockindex? " secondary" : ""));
+    Curl_shutdown_start(data, sockindex, &now);
+  }
+  else {
+    timeout_ms = Curl_shutdown_timeleft(data->conn, sockindex, &now);
+    if(timeout_ms < 0) {
+      failf(data, "SSL shutdown timeout");
+      return CURLE_OPERATION_TIMEDOUT;
+    }
+  }
+
+  while(cf) {
+    if(!cf->shutdown) {
+      bool cfdone = FALSE;
+      result = cf->cft->do_shutdown(cf, data, &cfdone);
+      if(result) {
+        CURL_TRC_CF(data, cf, "shut down failed with %d", result);
+        return result;
+      }
+      else if(!cfdone) {
+        CURL_TRC_CF(data, cf, "shut down not done yet");
+        return CURLE_OK;
+      }
+      CURL_TRC_CF(data, cf, "shut down successfully");
+      cf->shutdown = TRUE;
+    }
+    cf = cf->next;
+  }
+  *done = (!result);
+  return result;
 }
 
 ssize_t Curl_cf_recv(struct Curl_easy *data, int num, char *buf,
@@ -345,8 +409,10 @@ CURLcode Curl_conn_connect(struct Curl_easy *data,
 
   cf = data->conn->cfilter[sockindex];
   DEBUGASSERT(cf);
-  if(!cf)
+  if(!cf) {
+    *done = FALSE;
     return CURLE_FAILED_INIT;
+  }
 
   *done = cf->connected;
   if(!*done) {
@@ -442,6 +508,9 @@ void Curl_conn_cf_adjust_pollset(struct Curl_cfilter *cf,
   /* Get the lowest not-connected filter, if there are any */
   while(cf && !cf->connected && cf->next && !cf->next->connected)
     cf = cf->next;
+  /* Skip all filters that have already shut down */
+  while(cf && cf->shutdown)
+    cf = cf->next;
   /* From there on, give all filters a chance to adjust the pollset.
    * Lower filters are called later, so they may override */
   while(cf) {
@@ -462,6 +531,42 @@ void Curl_conn_adjust_pollset(struct Curl_easy *data,
   }
 }
 
+int Curl_conn_cf_poll(struct Curl_cfilter *cf,
+                      struct Curl_easy *data,
+                      timediff_t timeout_ms)
+{
+  struct easy_pollset ps;
+  struct pollfd pfds[MAX_SOCKSPEREASYHANDLE];
+  unsigned int i, npfds = 0;
+
+  DEBUGASSERT(cf);
+  DEBUGASSERT(data);
+  DEBUGASSERT(data->conn);
+  memset(&ps, 0, sizeof(ps));
+  memset(pfds, 0, sizeof(pfds));
+
+  Curl_conn_cf_adjust_pollset(cf, data, &ps);
+  DEBUGASSERT(ps.num <= MAX_SOCKSPEREASYHANDLE);
+  for(i = 0; i < ps.num; ++i) {
+    short events = 0;
+    if(ps.actions[i] & CURL_POLL_IN) {
+      events |= POLLIN;
+    }
+    if(ps.actions[i] & CURL_POLL_OUT) {
+      events |= POLLOUT;
+    }
+    if(events) {
+      pfds[npfds].fd = ps.sockets[i];
+      pfds[npfds].events = events;
+      ++npfds;
+    }
+  }
+
+  if(!npfds)
+    DEBUGF(infof(data, "no sockets to poll!"));
+  return Curl_poll(pfds, npfds, timeout_ms);
+}
+
 void Curl_conn_get_host(struct Curl_easy *data, int sockindex,
                         const char **phost, const char **pdisplay_host,
                         int *pport)
@@ -718,7 +823,7 @@ CURLcode Curl_conn_send(struct Curl_easy *data, int sockindex,
   DEBUGASSERT(data);
   DEBUGASSERT(data->conn);
   conn = data->conn;
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
   {
     /* Allow debug builds to override this logic to force short sends
     */
diff --git a/lib/cfilters.h b/lib/cfilters.h
index dcfc1b71f..7d53607f8 100644
--- a/lib/cfilters.h
+++ b/lib/cfilters.h
@@ -24,6 +24,7 @@
  *
  ***************************************************************************/
 
+#include "timediff.h"
 
 struct Curl_cfilter;
 struct Curl_easy;
@@ -36,9 +37,17 @@ struct connectdata;
 typedef void     Curl_cft_destroy_this(struct Curl_cfilter *cf,
                                        struct Curl_easy *data);
 
+/* Callback to close the connection immediately. */
 typedef void     Curl_cft_close(struct Curl_cfilter *cf,
                                 struct Curl_easy *data);
 
+/* Callback to close the connection filter gracefully, non-blocking.
+ * Implementations MUST NOT chain calls to cf->next.
+ */
+typedef CURLcode Curl_cft_shutdown(struct Curl_cfilter *cf,
+                                   struct Curl_easy *data,
+                                   bool *done);
+
 typedef CURLcode Curl_cft_connect(struct Curl_cfilter *cf,
                                   struct Curl_easy *data,
                                   bool blocking, bool *done);
@@ -76,10 +85,10 @@ struct easy_pollset;
  * the pollset. Filters, whose filter "below" is not connected, should
  * also do no adjustments.
  *
- * Examples: a TLS handshake, while ongoing, might remove POLL_IN
- * when it needs to write, or vice versa. A HTTP/2 filter might remove
- * POLL_OUT when a stream window is exhausted and a WINDOW_UPDATE needs
- * to be received first and add instead POLL_IN.
+ * Examples: a TLS handshake, while ongoing, might remove POLL_IN when it
+ * needs to write, or vice versa. An HTTP/2 filter might remove POLL_OUT when
+ * a stream window is exhausted and a WINDOW_UPDATE needs to be received first
+ * and add instead POLL_IN.
  *
  * @param cf     the filter to ask
  * @param data   the easy handle the pollset is about
@@ -194,6 +203,7 @@ struct Curl_cftype {
   Curl_cft_destroy_this *destroy;         /* destroy resources of this cf */
   Curl_cft_connect *do_connect;           /* establish connection */
   Curl_cft_close *do_close;               /* close conn */
+  Curl_cft_shutdown *do_shutdown;         /* shutdown conn */
   Curl_cft_get_host *get_host;            /* host filter talks to */
   Curl_cft_adjust_pollset *adjust_pollset; /* adjust transfer poll set */
   Curl_cft_data_pending *has_data_pending;/* conn has data pending */
@@ -213,6 +223,7 @@ struct Curl_cfilter {
   struct connectdata *conn;      /* the connection this filter belongs to */
   int sockindex;                 /* the index the filter is installed at */
   BIT(connected);                /* != 0 iff this filter is connected */
+  BIT(shutdown);                 /* != 0 iff this filter has shut down */
 };
 
 /* Default implementations for the type functions, implementing nop. */
@@ -244,6 +255,8 @@ CURLcode Curl_cf_def_conn_keep_alive(struct Curl_cfilter *cf,
 CURLcode Curl_cf_def_query(struct Curl_cfilter *cf,
                            struct Curl_easy *data,
                            int query, int *pres1, void *pres2);
+CURLcode Curl_cf_def_shutdown(struct Curl_cfilter *cf,
+                              struct Curl_easy *data, bool *done);
 
 /**
  * Create a new filter instance, unattached to the filter chain.
@@ -371,6 +384,13 @@ bool Curl_conn_is_multiplex(struct connectdata *conn, int sockindex);
  */
 void Curl_conn_close(struct Curl_easy *data, int sockindex);
 
+/**
+ * Shutdown the connection at `sockindex` non-blocking, using timeout
+ * from `data->set.shutdowntimeout`, default DEFAULT_SHUTDOWN_TIMEOUT_MS.
+ * Will return CURLE_OK and *done == FALSE if not finished.
+ */
+CURLcode Curl_conn_shutdown(struct Curl_easy *data, int sockindex, bool *done);
+
 /**
  * Return if data is pending in some connection filter at chain
  * `sockindex` for connection `data->conn`.
@@ -402,6 +422,15 @@ void Curl_conn_cf_adjust_pollset(struct Curl_cfilter *cf,
 void Curl_conn_adjust_pollset(struct Curl_easy *data,
                                struct easy_pollset *ps);
 
+/**
+ * Curl_poll() the filter chain at `cf` with timeout `timeout_ms`.
+ * Returns 0 on timeout, negative on error or number of sockets
+ * with requested poll events.
+ */
+int Curl_conn_cf_poll(struct Curl_cfilter *cf,
+                      struct Curl_easy *data,
+                      timediff_t timeout_ms);
+
 /**
  * Receive data through the filter chain at `sockindex` for connection
  * `data->conn`. Copy at most `len` bytes into `buf`. Return the
@@ -486,7 +515,9 @@ CURLcode Curl_conn_keep_alive(struct Curl_easy *data,
                               struct connectdata *conn,
                               int sockindex);
 
+#ifdef UNITTESTS
 void Curl_cf_def_close(struct Curl_cfilter *cf, struct Curl_easy *data);
+#endif
 void Curl_conn_get_host(struct Curl_easy *data, int sockindex,
                         const char **phost, const char **pdisplay_host,
                         int *pport);
diff --git a/lib/config-os400.h b/lib/config-os400.h
index 018e90af7..ec83be923 100644
--- a/lib/config-os400.h
+++ b/lib/config-os400.h
@@ -107,9 +107,6 @@
 /* Define if you have the <io.h> header file. */
 #undef HAVE_IO_H
 
-/* Define if you have the `socket' library (-lsocket). */
-#undef HAVE_LIBSOCKET
-
 /* Define if you have GSS API. */
 #define HAVE_GSSAPI
 
diff --git a/lib/config-riscos.h b/lib/config-riscos.h
index eb1d26ec7..056f55405 100644
--- a/lib/config-riscos.h
+++ b/lib/config-riscos.h
@@ -108,9 +108,6 @@
 /* Define if you have the <io.h> header file. */
 #undef HAVE_IO_H
 
-/* Define if you have the `socket' library (-lsocket). */
-#undef HAVE_LIBSOCKET
-
 /* Define if you need the malloc.h header file even with stdlib.h  */
 /* #define NEED_MALLOC_H 1 */
 
diff --git a/lib/conncache.c b/lib/conncache.c
index 2b5ee4f25..92fd60c4d 100644
--- a/lib/conncache.c
+++ b/lib/conncache.c
@@ -29,13 +29,17 @@
 
 #include "urldata.h"
 #include "url.h"
+#include "cfilters.h"
 #include "progress.h"
 #include "multiif.h"
 #include "sendf.h"
 #include "conncache.h"
+#include "http_negotiate.h"
+#include "http_ntlm.h"
 #include "share.h"
 #include "sigpipe.h"
 #include "connect.h"
+#include "select.h"
 #include "strcase.h"
 
 /* The last 3 #include files should be in this order */
@@ -45,6 +49,24 @@
 
 #define HASHKEY_SIZE 128
 
+static void connc_discard_conn(struct conncache *connc,
+                               struct Curl_easy *last_data,
+                               struct connectdata *conn,
+                               bool aborted);
+static void connc_disconnect(struct Curl_easy *data,
+                             struct connectdata *conn,
+                             struct conncache *connc,
+                             bool do_shutdown);
+static void connc_run_conn_shutdown(struct Curl_easy *data,
+                                    struct connectdata *conn,
+                                    bool *done);
+static void connc_run_conn_shutdown_handler(struct Curl_easy *data,
+                                            struct connectdata *conn);
+static CURLMcode connc_update_shutdown_ev(struct Curl_multi *multi,
+                                          struct Curl_easy *data,
+                                          struct connectdata *conn);
+static void connc_shutdown_all(struct conncache *connc, int timeout_ms);
+
 static CURLcode bundle_create(struct connectbundle **bundlep)
 {
   DEBUGASSERT(*bundlep == NULL);
@@ -100,25 +122,35 @@ static void free_bundle_hash_entry(void *freethis)
   bundle_destroy(b);
 }
 
-int Curl_conncache_init(struct conncache *connc, size_t size)
+int Curl_conncache_init(struct conncache *connc,
+                        struct Curl_multi *multi, size_t size)
 {
   /* allocate a new easy handle to use when closing cached connections */
   connc->closure_handle = curl_easy_init();
   if(!connc->closure_handle)
     return 1; /* bad */
   connc->closure_handle->state.internal = true;
+ #ifdef DEBUGBUILD
+  if(getenv("CURL_DEBUG"))
+    connc->closure_handle->set.verbose = true;
+#endif
 
   Curl_hash_init(&connc->hash, size, Curl_hash_str,
                  Curl_str_key_compare, free_bundle_hash_entry);
   connc->closure_handle->state.conn_cache = connc;
+  connc->multi = multi;
+  Curl_llist_init(&connc->shutdowns.conn_list, NULL);
 
   return 0; /* good */
 }
 
 void Curl_conncache_destroy(struct conncache *connc)
 {
-  if(connc)
+  if(connc) {
     Curl_hash_destroy(&connc->hash);
+    connc->multi = NULL;
+    DEBUGASSERT(!Curl_llist_count(&connc->shutdowns.conn_list));
+  }
 }
 
 /* creates a key to find a bundle for this connection */
@@ -180,15 +212,14 @@ Curl_conncache_find_bundle(struct Curl_easy *data,
   return bundle;
 }
 
-static void *conncache_add_bundle(struct conncache *connc,
-                                  char *key,
-                                  struct connectbundle *bundle)
+static void *connc_add_bundle(struct conncache *connc,
+                              char *key, struct connectbundle *bundle)
 {
   return Curl_hash_add(&connc->hash, key, strlen(key), bundle);
 }
 
-static void conncache_remove_bundle(struct conncache *connc,
-                                    struct connectbundle *bundle)
+static void connc_remove_bundle(struct conncache *connc,
+                                struct connectbundle *bundle)
 {
   struct Curl_hash_iterator iter;
   struct Curl_hash_element *he;
@@ -231,7 +262,7 @@ CURLcode Curl_conncache_add_conn(struct Curl_easy *data)
 
     hashkey(conn, key, sizeof(key));
 
-    if(!conncache_add_bundle(data->state.conn_cache, key, bundle)) {
+    if(!connc_add_bundle(data->state.conn_cache, key, bundle)) {
       bundle_destroy(bundle);
       result = CURLE_OUT_OF_MEMORY;
       goto unlock;
@@ -252,6 +283,23 @@ unlock:
   return result;
 }
 
+static void connc_remove_conn(struct conncache *connc,
+                              struct connectdata *conn)
+{
+  struct connectbundle *bundle = conn->bundle;
+
+  /* The bundle pointer can be NULL, since this function can be called
+     due to a failed connection attempt, before being added to a bundle */
+  if(bundle) {
+    bundle_remove_conn(bundle, conn);
+    if(connc && bundle->num_connections == 0)
+      connc_remove_bundle(connc, bundle);
+    conn->bundle = NULL; /* removed from it */
+    if(connc)
+      connc->num_conn--;
+  }
+}
+
 /*
  * Removes the connectdata object from the connection cache, but the transfer
  * still owns this connection.
@@ -262,28 +310,16 @@ unlock:
 void Curl_conncache_remove_conn(struct Curl_easy *data,
                                 struct connectdata *conn, bool lock)
 {
-  struct connectbundle *bundle = conn->bundle;
   struct conncache *connc = data->state.conn_cache;
 
-  /* The bundle pointer can be NULL, since this function can be called
-     due to a failed connection attempt, before being added to a bundle */
-  if(bundle) {
-    if(lock) {
-      CONNCACHE_LOCK(data);
-    }
-    bundle_remove_conn(bundle, conn);
-    if(bundle->num_connections == 0)
-      conncache_remove_bundle(connc, bundle);
-    conn->bundle = NULL; /* removed from it */
-    if(connc) {
-      connc->num_conn--;
-      DEBUGF(infof(data, "The cache now contains %zu members",
-                   connc->num_conn));
-    }
-    if(lock) {
-      CONNCACHE_UNLOCK(data);
-    }
-  }
+  if(lock)
+    CONNCACHE_LOCK(data);
+  connc_remove_conn(connc, conn);
+  if(lock)
+    CONNCACHE_UNLOCK(data);
+  if(connc)
+    DEBUGF(infof(data, "The cache now contains %zu members",
+                 connc->num_conn));
 }
 
 /* This function iterates the entire connection cache and calls the function
@@ -345,7 +381,7 @@ bool Curl_conncache_foreach(struct Curl_easy *data,
    up a cache!
 */
 static struct connectdata *
-conncache_find_first_connection(struct conncache *connc)
+connc_find_first_connection(struct conncache *connc)
 {
   struct Curl_hash_iterator iter;
   struct Curl_hash_element *he;
@@ -394,8 +430,7 @@ bool Curl_conncache_return_conn(struct Curl_easy *data,
          important that details from this (unrelated) disconnect does not
          taint meta-data in the data handle. */
       struct conncache *connc = data->state.conn_cache;
-      Curl_disconnect(connc->closure_handle, conn_candidate,
-                      /* dead_connection */ FALSE);
+      connc_disconnect(NULL, conn_candidate, connc, TRUE);
     }
   }
 
@@ -516,33 +551,606 @@ Curl_conncache_extract_oldest(struct Curl_easy *data)
   return conn_candidate;
 }
 
-void Curl_conncache_close_all_connections(struct conncache *connc)
+static void connc_shutdown_discard_all(struct conncache *connc)
+{
+  struct Curl_llist_element *e = connc->shutdowns.conn_list.head;
+  struct connectdata *conn;
+
+  if(!e)
+    return;
+
+  DEBUGF(infof(connc->closure_handle, "conncache_shutdown_discard_all"));
+  DEBUGASSERT(!connc->shutdowns.iter_locked);
+  connc->shutdowns.iter_locked = TRUE;
+  while(e) {
+    conn = e->ptr;
+    Curl_llist_remove(&connc->shutdowns.conn_list, e, NULL);
+    DEBUGF(infof(connc->closure_handle, "discard connection #%"
+                 CURL_FORMAT_CURL_OFF_T, conn->connection_id));
+    connc_disconnect(NULL, conn, connc, FALSE);
+    e = connc->shutdowns.conn_list.head;
+  }
+  connc->shutdowns.iter_locked = FALSE;
+}
+
+static void connc_close_all(struct conncache *connc)
 {
+  struct Curl_easy *data = connc->closure_handle;
   struct connectdata *conn;
+  int timeout_ms = 0;
   SIGPIPE_VARIABLE(pipe_st);
-  if(!connc->closure_handle)
+
+  if(!data)
     return;
 
-  conn = conncache_find_first_connection(connc);
+  /* Move all connections to the shutdown list */
+  sigpipe_init(&pipe_st);
+  conn = connc_find_first_connection(connc);
   while(conn) {
-    sigpipe_ignore(connc->closure_handle, &pipe_st);
+    connc_remove_conn(connc, conn);
+    sigpipe_apply(data, &pipe_st);
     /* This will remove the connection from the cache */
     connclose(conn, "kill all");
     Curl_conncache_remove_conn(connc->closure_handle, conn, TRUE);
-    Curl_disconnect(connc->closure_handle, conn, FALSE);
-    sigpipe_restore(&pipe_st);
+    connc_discard_conn(connc, connc->closure_handle, conn, FALSE);
 
-    conn = conncache_find_first_connection(connc);
+    conn = connc_find_first_connection(connc);
   }
 
-  sigpipe_ignore(connc->closure_handle, &pipe_st);
+    /* Just for testing, run graceful shutdown */
+#ifdef DEBUGBUILD
+  {
+    char *p = getenv("CURL_GRACEFUL_SHUTDOWN");
+    if(p) {
+      long l = strtol(p, NULL, 10);
+      if(l > 0 && l < INT_MAX)
+        timeout_ms = (int)l;
+    }
+  }
+#endif
+  connc_shutdown_all(connc, timeout_ms);
+
+  /* discard all connections in the shutdown list */
+  connc_shutdown_discard_all(connc);
 
-  Curl_hostcache_clean(connc->closure_handle,
-                       connc->closure_handle->dns.hostcache);
-  Curl_close(&connc->closure_handle);
+  sigpipe_apply(data, &pipe_st);
+  Curl_hostcache_clean(data, data->dns.hostcache);
+  Curl_close(&data);
   sigpipe_restore(&pipe_st);
 }
 
+void Curl_conncache_close_all_connections(struct conncache *connc)
+{
+  connc_close_all(connc);
+}
+
+static void connc_shutdown_discard_oldest(struct conncache *connc)
+{
+  struct Curl_llist_element *e;
+  struct connectdata *conn;
+
+  DEBUGASSERT(!connc->shutdowns.iter_locked);
+  if(connc->shutdowns.iter_locked)
+    return;
+
+  e = connc->shutdowns.conn_list.head;
+  if(e) {
+    SIGPIPE_VARIABLE(pipe_st);
+    conn = e->ptr;
+    Curl_llist_remove(&connc->shutdowns.conn_list, e, NULL);
+    sigpipe_init(&pipe_st);
+    sigpipe_apply(connc->closure_handle, &pipe_st);
+    connc_disconnect(NULL, conn, connc, FALSE);
+    sigpipe_restore(&pipe_st);
+  }
+}
+
+static void connc_discard_conn(struct conncache *connc,
+                               struct Curl_easy *last_data,
+                               struct connectdata *conn,
+                               bool aborted)
+{
+  /* `last_data`, if present, is the transfer that last worked with
+   * the connection. It is present when the connection is being shut down
+   * via `Curl_conncache_discard_conn()`, e.g. when the transfer failed
+   * or does not allow connection reuse.
+   * Using the original handle is necessary for shutting down the protocol
+   * handler belonging to the connection. Protocols like 'file:' rely on
+   * being invoked to clean up their allocations in the easy handle.
+   * When a connection comes from the cache, the transfer is no longer
+   * there and we use the cache is own closure handle.
+   */
+  struct Curl_easy *data = last_data? last_data : connc->closure_handle;
+  bool done = FALSE;
+
+  DEBUGASSERT(data);
+  DEBUGASSERT(connc);
+  DEBUGASSERT(!conn->bundle);
+
+  /*
+   * If this connection is not marked to force-close, leave it open if there
+   * are other users of it
+   */
+  if(CONN_INUSE(conn) && !aborted) {
+    DEBUGF(infof(data, "[CCACHE] not discarding #%" CURL_FORMAT_CURL_OFF_T
+                       " still in use by %zu transfers", conn->connection_id,
+                       CONN_INUSE(conn)));
+    return;
+  }
+
+  /* treat the connection as aborted in CONNECT_ONLY situations, we do
+   * not know what the APP did with it. */
+  if(conn->connect_only)
+    aborted = TRUE;
+  conn->bits.aborted = aborted;
+
+  /* We do not shutdown dead connections. The term 'dead' can be misleading
+   * here, as we also mark errored connections/transfers as 'dead'.
+   * If we do a shutdown for an aborted transfer, the server might think
+   * it was successful otherwise (for example an ftps: upload). This is
+   * not what we want. */
+  if(aborted)
+    done = TRUE;
+  if(!done) {
+    /* Attempt to shutdown the connection right away. */
+    Curl_attach_connection(data, conn);
+    connc_run_conn_shutdown(data, conn, &done);
+    DEBUGF(infof(data, "[CCACHE] shutdown #%" CURL_FORMAT_CURL_OFF_T
+                       ", done=%d",conn->connection_id, done));
+    Curl_detach_connection(data);
+  }
+
+  if(done) {
+    connc_disconnect(data, conn, connc, FALSE);
+    return;
+  }
+
+  DEBUGASSERT(!connc->shutdowns.iter_locked);
+  if(connc->shutdowns.iter_locked) {
+    DEBUGF(infof(data, "[CCACHE] discarding #%" CURL_FORMAT_CURL_OFF_T
+                       ", list locked", conn->connection_id));
+    connc_disconnect(data, conn, connc, FALSE);
+    return;
+  }
+
+  /* Add the connection to our shutdown list for non-blocking shutdown
+   * during multi processing. */
+  if(data->multi && data->multi->max_shutdown_connections > 0 &&
+     (data->multi->max_shutdown_connections >=
+      (long)Curl_llist_count(&connc->shutdowns.conn_list))) {
+    DEBUGF(infof(data, "[CCACHE] discarding oldest shutdown connection "
+                       "due to limit of %ld",
+                       data->multi->max_shutdown_connections));
+    connc_shutdown_discard_oldest(connc);
+  }
+
+  if(data->multi && data->multi->socket_cb) {
+    DEBUGASSERT(connc == &data->multi->conn_cache);
+    /* Start with an empty shutdown pollset, so out internal closure handle
+     * is added to the sockets. */
+    memset(&conn->shutdown_poll, 0, sizeof(conn->shutdown_poll));
+    if(connc_update_shutdown_ev(data->multi, connc->closure_handle, conn)) {
+      DEBUGF(infof(data, "[CCACHE] update events for shutdown failed, "
+                         "discarding #%" CURL_FORMAT_CURL_OFF_T,
+                         conn->connection_id));
+      connc_disconnect(data, conn, connc, FALSE);
+      return;
+    }
+  }
+
+  Curl_llist_append(&connc->shutdowns.conn_list, conn, &conn->bundle_node);
+  DEBUGF(infof(data, "[CCACHE] added #%" CURL_FORMAT_CURL_OFF_T
+                     " to shutdown list of length %zu", conn->connection_id,
+                     Curl_llist_count(&connc->shutdowns.conn_list)));
+}
+
+void Curl_conncache_disconnect(struct Curl_easy *data,
+                               struct connectdata *conn,
+                               bool aborted)
+{
+  DEBUGASSERT(data);
+  /* Connection must no longer be in and connection cache */
+  DEBUGASSERT(!conn->bundle);
+
+  if(data->multi) {
+    /* Add it to the multi's conncache for shutdown handling */
+    infof(data, "%s connection #%" CURL_FORMAT_CURL_OFF_T,
+          aborted? "closing" : "shutting down", conn->connection_id);
+    connc_discard_conn(&data->multi->conn_cache, data, conn, aborted);
+  }
+  else {
+    /* No multi available. Make a best-effort shutdown + close */
+    infof(data, "closing connection #%" CURL_FORMAT_CURL_OFF_T,
+          conn->connection_id);
+    DEBUGASSERT(!conn->bundle);
+    connc_run_conn_shutdown_handler(data, conn);
+    connc_disconnect(data, conn, NULL, !aborted);
+  }
+}
+
+static void connc_run_conn_shutdown_handler(struct Curl_easy *data,
+                                            struct connectdata *conn)
+{
+  if(!conn->bits.shutdown_handler) {
+    if(conn->dns_entry) {
+      Curl_resolv_unlock(data, conn->dns_entry);
+      conn->dns_entry = NULL;
+    }
+
+    /* Cleanup NTLM connection-related data */
+    Curl_http_auth_cleanup_ntlm(conn);
+
+    /* Cleanup NEGOTIATE connection-related data */
+    Curl_http_auth_cleanup_negotiate(conn);
+
+    if(conn->handler && conn->handler->disconnect) {
+      /* This is set if protocol-specific cleanups should be made */
+      DEBUGF(infof(data, "connection #%" CURL_FORMAT_CURL_OFF_T
+                   ", shutdown protocol handler (aborted=%d)",
+                   conn->connection_id, conn->bits.aborted));
+      conn->handler->disconnect(data, conn, conn->bits.aborted);
+    }
+
+    /* possible left-overs from the async name resolvers */
+    Curl_resolver_cancel(data);
+
+    conn->bits.shutdown_handler = TRUE;
+  }
+}
+
+static void connc_run_conn_shutdown(struct Curl_easy *data,
+                                    struct connectdata *conn,
+                                    bool *done)
+{
+  CURLcode r1, r2;
+  bool done1, done2;
+
+  /* We expect to be attached when called */
+  DEBUGASSERT(data->conn == conn);
+
+  connc_run_conn_shutdown_handler(data, conn);
+
+  if(conn->bits.shutdown_filters) {
+    *done = TRUE;
+    return;
+  }
+
+  if(!conn->connect_only && Curl_conn_is_connected(conn, FIRSTSOCKET))
+    r1 = Curl_conn_shutdown(data, FIRSTSOCKET, &done1);
+  else {
+    r1 = CURLE_OK;
+    done1 = TRUE;
+  }
+
+  if(!conn->connect_only && Curl_conn_is_connected(conn, SECONDARYSOCKET))
+    r2 = Curl_conn_shutdown(data, SECONDARYSOCKET, &done2);
+  else {
+    r2 = CURLE_OK;
+    done2 = TRUE;
+  }
+
+  /* we are done when any failed or both report success */
+  *done = (r1 || r2 || (done1 && done2));
+  if(*done)
+    conn->bits.shutdown_filters = TRUE;
+}
+
+CURLcode Curl_conncache_add_pollfds(struct conncache *connc,
+                                    struct curl_pollfds *cpfds)
+{
+  CURLcode result = CURLE_OK;
+
+  DEBUGASSERT(!connc->shutdowns.iter_locked);
+  connc->shutdowns.iter_locked = TRUE;
+  if(connc->shutdowns.conn_list.head) {
+    struct Curl_llist_element *e;
+    struct easy_pollset ps;
+    struct connectdata *conn;
+
+    for(e = connc->shutdowns.conn_list.head; e; e = e->next) {
+      conn = e->ptr;
+      memset(&ps, 0, sizeof(ps));
+      Curl_attach_connection(connc->closure_handle, conn);
+      Curl_conn_adjust_pollset(connc->closure_handle, &ps);
+      Curl_detach_connection(connc->closure_handle);
+
+      result = Curl_pollfds_add_ps(cpfds, &ps);
+      if(result) {
+        Curl_pollfds_cleanup(cpfds);
+        goto out;
+      }
+    }
+  }
+out:
+  connc->shutdowns.iter_locked = FALSE;
+  return result;
+}
+
+CURLcode Curl_conncache_add_waitfds(struct conncache *connc,
+                                    struct curl_waitfds *cwfds)
+{
+  CURLcode result = CURLE_OK;
+
+  DEBUGASSERT(!connc->shutdowns.iter_locked);
+  connc->shutdowns.iter_locked = TRUE;
+  if(connc->shutdowns.conn_list.head) {
+    struct Curl_llist_element *e;
+    struct easy_pollset ps;
+    struct connectdata *conn;
+
+    for(e = connc->shutdowns.conn_list.head; e; e = e->next) {
+      conn = e->ptr;
+      memset(&ps, 0, sizeof(ps));
+      Curl_attach_connection(connc->closure_handle, conn);
+      Curl_conn_adjust_pollset(connc->closure_handle, &ps);
+      Curl_detach_connection(connc->closure_handle);
+
+      result = Curl_waitfds_add_ps(cwfds, &ps);
+      if(result)
+        goto out;
+    }
+  }
+out:
+  connc->shutdowns.iter_locked = FALSE;
+  return result;
+}
+
+static void connc_perform(struct conncache *connc)
+{
+  struct Curl_easy *data = connc->closure_handle;
+  struct Curl_llist_element *e = connc->shutdowns.conn_list.head;
+  struct Curl_llist_element *enext;
+  struct connectdata *conn;
+  struct curltime *nowp = NULL;
+  struct curltime now;
+  timediff_t next_from_now_ms = 0, ms;
+  bool done;
+
+  if(!e)
+    return;
+
+  DEBUGASSERT(data);
+  DEBUGASSERT(!connc->shutdowns.iter_locked);
+  DEBUGF(infof(data, "[CCACHE] perform, %zu connections being shutdown",
+               Curl_llist_count(&connc->shutdowns.conn_list)));
+  connc->shutdowns.iter_locked = TRUE;
+  while(e) {
+    enext = e->next;
+    conn = e->ptr;
+    Curl_attach_connection(data, conn);
+    connc_run_conn_shutdown(data, conn, &done);
+    DEBUGF(infof(data, "[CCACHE] shutdown #%" CURL_FORMAT_CURL_OFF_T
+                 ", done=%d", conn->connection_id, done));
+    Curl_detach_connection(data);
+    if(done) {
+      Curl_llist_remove(&connc->shutdowns.conn_list, e, NULL);
+      connc_disconnect(NULL, conn, connc, FALSE);
+    }
+    else {
+      /* Not done, when does this connection time out? */
+      if(!nowp) {
+        now = Curl_now();
+        nowp = &now;
+      }
+      ms = Curl_conn_shutdown_timeleft(conn, nowp);
+      if(ms && ms < next_from_now_ms)
+        next_from_now_ms = ms;
+    }
+    e = enext;
+  }
+  connc->shutdowns.iter_locked = FALSE;
+
+  if(next_from_now_ms)
+    Curl_expire(data, next_from_now_ms, EXPIRE_RUN_NOW);
+}
+
+void Curl_conncache_multi_perform(struct Curl_multi *multi)
+{
+  connc_perform(&multi->conn_cache);
+}
+
+
+/*
+ * Disconnects the given connection. Note the connection may not be the
+ * primary connection, like when freeing room in the connection cache or
+ * killing of a dead old connection.
+ *
+ * A connection needs an easy handle when closing down. We support this passed
+ * in separately since the connection to get closed here is often already
+ * disassociated from an easy handle.
+ *
+ * This function MUST NOT reset state in the Curl_easy struct if that
+ * is not strictly bound to the life-time of *this* particular connection.
+ *
+ */
+static void connc_disconnect(struct Curl_easy *data,
+                             struct connectdata *conn,
+                             struct conncache *connc,
+                             bool do_shutdown)
+{
+  bool done;
+
+  /* there must be a connection to close */
+  DEBUGASSERT(conn);
+  /* it must be removed from the connection cache */
+  DEBUGASSERT(!conn->bundle);
+  /* there must be an associated transfer */
+  DEBUGASSERT(data || connc);
+  if(!data)
+    data = connc->closure_handle;
+
+  /* the transfer must be detached from the connection */
+  DEBUGASSERT(data && !data->conn);
+
+  Curl_attach_connection(data, conn);
+
+  if(connc && connc->multi && connc->multi->socket_cb) {
+    struct easy_pollset ps;
+    /* With an empty pollset, all previously polled sockets will be removed
+     * via the multi_socket API callback. */
+    memset(&ps, 0, sizeof(ps));
+    (void)Curl_multi_pollset_ev(connc->multi, data, &ps, &conn->shutdown_poll);
+  }
+
+  connc_run_conn_shutdown_handler(data, conn);
+  if(do_shutdown) {
+    /* Make a last attempt to shutdown handlers and filters, if
+     * not done so already. */
+    connc_run_conn_shutdown(data, conn, &done);
+  }
+
+  if(connc)
+    DEBUGF(infof(data, "[CCACHE] closing #%" CURL_FORMAT_CURL_OFF_T,
+                 conn->connection_id));
+  else
+    DEBUGF(infof(data, "closing connection #%" CURL_FORMAT_CURL_OFF_T,
+                 conn->connection_id));
+  Curl_conn_close(data, SECONDARYSOCKET);
+  Curl_conn_close(data, FIRSTSOCKET);
+  Curl_detach_connection(data);
+
+  Curl_conn_free(data, conn);
+}
+
+
+static CURLMcode connc_update_shutdown_ev(struct Curl_multi *multi,
+                                          struct Curl_easy *data,
+                                          struct connectdata *conn)
+{
+  struct easy_pollset ps;
+  CURLMcode mresult;
+
+  DEBUGASSERT(data);
+  DEBUGASSERT(multi);
+  DEBUGASSERT(multi->socket_cb);
+
+  memset(&ps, 0, sizeof(ps));
+  Curl_attach_connection(data, conn);
+  Curl_conn_adjust_pollset(data, &ps);
+  Curl_detach_connection(data);
+
+  mresult = Curl_multi_pollset_ev(multi, data, &ps, &conn->shutdown_poll);
+
+  if(!mresult) /* Remember for next time */
+    memcpy(&conn->shutdown_poll, &ps, sizeof(ps));
+  return mresult;
+}
+
+void Curl_conncache_multi_socket(struct Curl_multi *multi,
+                                 curl_socket_t s, int ev_bitmask)
+{
+  struct conncache *connc = &multi->conn_cache;
+  struct Curl_easy *data = connc->closure_handle;
+  struct Curl_llist_element *e = connc->shutdowns.conn_list.head;
+  struct connectdata *conn;
+  bool done;
+
+  (void)ev_bitmask;
+  DEBUGASSERT(multi->socket_cb);
+  if(!e)
+    return;
+
+  connc->shutdowns.iter_locked = TRUE;
+  while(e) {
+    conn = e->ptr;
+    if(s == conn->sock[FIRSTSOCKET] || s == conn->sock[SECONDARYSOCKET]) {
+      Curl_attach_connection(data, conn);
+      connc_run_conn_shutdown(data, conn, &done);
+      DEBUGF(infof(data, "[CCACHE] shutdown #%" CURL_FORMAT_CURL_OFF_T
+                   ", done=%d", conn->connection_id, done));
+      Curl_detach_connection(data);
+      if(done || connc_update_shutdown_ev(multi, data, conn)) {
+        Curl_llist_remove(&connc->shutdowns.conn_list, e, NULL);
+        connc_disconnect(NULL, conn, connc, FALSE);
+      }
+      break;
+    }
+    e = e->next;
+  }
+  connc->shutdowns.iter_locked = FALSE;
+}
+
+void Curl_conncache_multi_close_all(struct Curl_multi *multi)
+{
+  connc_close_all(&multi->conn_cache);
+}
+
+
+#define NUM_POLLS_ON_STACK 10
+
+static CURLcode connc_shutdown_wait(struct conncache *connc, int timeout_ms)
+{
+  struct pollfd a_few_on_stack[NUM_POLLS_ON_STACK];
+  struct curl_pollfds cpfds;
+  CURLcode result;
+
+  Curl_pollfds_init(&cpfds, a_few_on_stack, NUM_POLLS_ON_STACK);
+
+  result = Curl_conncache_add_pollfds(connc, &cpfds);
+  if(result)
+    goto out;
+
+  Curl_poll(cpfds.pfds, cpfds.n, CURLMIN(timeout_ms, 1000));
+
+out:
+  Curl_pollfds_cleanup(&cpfds);
+  return result;
+}
+
+static void connc_shutdown_all(struct conncache *connc, int timeout_ms)
+{
+  struct Curl_easy *data = connc->closure_handle;
+  struct connectdata *conn;
+  struct curltime started = Curl_now();
+
+  if(!data)
+    return;
+  (void)data;
+
+  DEBUGF(infof(data, "conncache shutdown all"));
+
+  /* Move all connections into the shutdown queue */
+  conn = connc_find_first_connection(connc);
+  while(conn) {
+    /* This will remove the connection from the cache */
+    DEBUGF(infof(data, "moving connection %" CURL_FORMAT_CURL_OFF_T
+                 " to shutdown queue", conn->connection_id));
+    connc_remove_conn(connc, conn);
+    connc_discard_conn(connc, NULL, conn, FALSE);
+    conn = connc_find_first_connection(connc);
+  }
+
+  DEBUGASSERT(!connc->shutdowns.iter_locked);
+  while(connc->shutdowns.conn_list.head) {
+    timediff_t timespent;
+    int remain_ms;
+
+    connc_perform(connc);
+
+    if(!connc->shutdowns.conn_list.head) {
+      DEBUGF(infof(data, "conncache shutdown ok"));
+      break;
+    }
+
+    /* wait for activity, timeout or "nothing" */
+    timespent = Curl_timediff(Curl_now(), started);
+    if(timespent >= (timediff_t)timeout_ms) {
+      DEBUGF(infof(data, "conncache shutdown %s",
+                   (timeout_ms > 0)? "timeout" : "best effort done"));
+      break;
+    }
+
+    remain_ms = timeout_ms - (int)timespent;
+    if(connc_shutdown_wait(connc, remain_ms)) {
+      DEBUGF(infof(data, "conncache shutdown all, abort"));
+      break;
+    }
+  }
+
+  /* Due to errors/timeout, we might come here without being full ydone. */
+  connc_shutdown_discard_all(connc);
+}
+
 #if 0
 /* Useful for debugging the connection cache */
 void Curl_conncache_print(struct conncache *connc)
diff --git a/lib/conncache.h b/lib/conncache.h
index e68512394..30cc2e259 100644
--- a/lib/conncache.h
+++ b/lib/conncache.h
@@ -35,6 +35,14 @@
 #include "timeval.h"
 
 struct connectdata;
+struct curl_pollfds;
+struct curl_waitfds;
+struct Curl_multi;
+
+struct connshutdowns {
+  struct Curl_llist conn_list;  /* The connectdata to shut down */
+  BIT(iter_locked);  /* TRUE while iterating the list */
+};
 
 struct conncache {
   struct Curl_hash hash;
@@ -42,15 +50,17 @@ struct conncache {
   curl_off_t next_connection_id;
   curl_off_t next_easy_id;
   struct curltime last_cleanup;
+  struct connshutdowns shutdowns;
   /* handle used for closing cached connections */
   struct Curl_easy *closure_handle;
+  struct Curl_multi *multi; /* Optional, set if cache belongs to multi */
 };
 
 #define BUNDLE_NO_MULTIUSE -1
 #define BUNDLE_UNKNOWN     0  /* initial value */
 #define BUNDLE_MULTIPLEX   2
 
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
 /* the debug versions of these macros make extra certain that the lock is
    never doubly locked or unlocked */
 #define CONNCACHE_LOCK(x)                                               \
@@ -84,8 +94,12 @@ struct connectbundle {
   struct Curl_llist conn_list;  /* The connectdata members of the bundle */
 };
 
-/* returns 1 on error, 0 is fine */
-int Curl_conncache_init(struct conncache *, size_t size);
+/* Init the cache, pass multi only if cache is owned by it.
+ * returns 1 on error, 0 is fine.
+ */
+int Curl_conncache_init(struct conncache *,
+                        struct Curl_multi *multi,
+                        size_t size);
 void Curl_conncache_destroy(struct conncache *connc);
 
 /* return the correct bundle, to a host or a proxy */
@@ -119,4 +133,32 @@ Curl_conncache_extract_oldest(struct Curl_easy *data);
 void Curl_conncache_close_all_connections(struct conncache *connc);
 void Curl_conncache_print(struct conncache *connc);
 
+/**
+ * Tear down the connection. If `aborted` is FALSE, the connection
+ * will be shut down first before discarding. If the shutdown
+ * is not immediately complete, the connection
+ * will be placed into the cache is shutdown queue.
+ */
+void Curl_conncache_disconnect(struct Curl_easy *data,
+                               struct connectdata *conn,
+                               bool aborted);
+
+/**
+ * Add sockets and POLLIN/OUT flags for connections handled by the cache.
+ */
+CURLcode Curl_conncache_add_pollfds(struct conncache *connc,
+                                    struct curl_pollfds *cpfds);
+CURLcode Curl_conncache_add_waitfds(struct conncache *connc,
+                                    struct curl_waitfds *cwfds);
+
+/**
+ * Perform maintenance on connections in the cache. Specifically,
+ * progress the shutdown of connections in the queue.
+ */
+void Curl_conncache_multi_perform(struct Curl_multi *multi);
+
+void Curl_conncache_multi_socket(struct Curl_multi *multi,
+                                 curl_socket_t s, int ev_bitmask);
+void Curl_conncache_multi_close_all(struct Curl_multi *multi);
+
 #endif /* HEADER_CURL_CONNCACHE_H */
diff --git a/lib/connect.c b/lib/connect.c
index bf85e640f..9b68f15da 100644
--- a/lib/connect.c
+++ b/lib/connect.c
@@ -90,7 +90,7 @@
 
 /*
  * Curl_timeleft() returns the amount of milliseconds left allowed for the
- * transfer/connection. If the value is 0, there's no timeout (ie there's
+ * transfer/connection. If the value is 0, there is no timeout (ie there is
  * infinite time left). If the value is negative, the timeout time has already
  * elapsed.
  * @param data the transfer to check on
@@ -142,6 +142,72 @@ timediff_t Curl_timeleft(struct Curl_easy *data,
   return (ctimeleft_ms < timeleft_ms)? ctimeleft_ms : timeleft_ms;
 }
 
+void Curl_shutdown_start(struct Curl_easy *data, int sockindex,
+                         struct curltime *nowp)
+{
+  struct curltime now;
+
+  DEBUGASSERT(data->conn);
+  if(!nowp) {
+    now = Curl_now();
+    nowp = &now;
+  }
+  data->conn->shutdown.start[sockindex] = *nowp;
+  data->conn->shutdown.timeout_ms = (data->set.shutdowntimeout > 0) ?
+    data->set.shutdowntimeout : DEFAULT_SHUTDOWN_TIMEOUT_MS;
+}
+
+timediff_t Curl_shutdown_timeleft(struct connectdata *conn, int sockindex,
+                                  struct curltime *nowp)
+{
+  struct curltime now;
+  timediff_t left_ms;
+
+  if(!conn->shutdown.start[sockindex].tv_sec || !conn->shutdown.timeout_ms)
+    return 0; /* not started or no limits */
+
+  if(!nowp) {
+    now = Curl_now();
+    nowp = &now;
+  }
+  left_ms = conn->shutdown.timeout_ms -
+            Curl_timediff(*nowp, conn->shutdown.start[sockindex]);
+  return left_ms? left_ms : -1;
+}
+
+timediff_t Curl_conn_shutdown_timeleft(struct connectdata *conn,
+                                       struct curltime *nowp)
+{
+  timediff_t left_ms = 0, ms;
+  struct curltime now;
+  int i;
+
+  for(i = 0; conn->shutdown.timeout_ms && (i < 2); ++i) {
+    if(!conn->shutdown.start[i].tv_sec)
+      continue;
+    if(!nowp) {
+      now = Curl_now();
+      nowp = &now;
+    }
+    ms = Curl_shutdown_timeleft(conn, i, nowp);
+    if(ms && (!left_ms || ms < left_ms))
+      left_ms = ms;
+  }
+  return left_ms;
+}
+
+void Curl_shutdown_clear(struct Curl_easy *data, int sockindex)
+{
+  struct curltime *pt = &data->conn->shutdown.start[sockindex];
+  memset(pt, 0, sizeof(*pt));
+}
+
+bool Curl_shutdown_started(struct Curl_easy *data, int sockindex)
+{
+  struct curltime *pt = &data->conn->shutdown.start[sockindex];
+  return (pt->tv_sec > 0) || (pt->tv_usec > 0);
+}
+
 /* Copies connection info into the transfer handle to make it available when
    the transfer handle is no longer associated with the connection. */
 void Curl_persistconninfo(struct Curl_easy *data, struct connectdata *conn,
@@ -317,7 +383,7 @@ void Curl_conncontrol(struct connectdata *conn,
 #endif
   )
 {
-  /* close if a connection, or a stream that isn't multiplexed. */
+  /* close if a connection, or a stream that is not multiplexed. */
   /* This function will be called both before and after this connection is
      associated with a transfer. */
   bool closeit, is_multiplex;
@@ -358,6 +424,7 @@ struct eyeballer {
   BIT(has_started);                  /* attempts have started */
   BIT(is_done);                      /* out of addresses/time */
   BIT(connected);                    /* cf has connected */
+  BIT(shutdown);                     /* cf has shutdown */
   BIT(inconclusive);                 /* connect was not a hard failure, we
                                       * might talk to a restarting server */
 };
@@ -464,7 +531,7 @@ static void baller_initiate(struct Curl_cfilter *cf,
   CURLcode result;
 
 
-  /* Don't close a previous cfilter yet to ensure that the next IP's
+  /* Do not close a previous cfilter yet to ensure that the next IP's
      socket gets a different file descriptor, which can prevent bugs when
      the curl_multi_socket_action interface is used with certain select()
      replacements such as kqueue. */
@@ -744,7 +811,7 @@ evaluate:
 }
 
 /*
- * Connect to the given host with timeout, proxy or remote doesn't matter.
+ * Connect to the given host with timeout, proxy or remote does not matter.
  * There might be more than one IP address to try out.
  */
 static CURLcode start_connect(struct Curl_cfilter *cf,
@@ -857,6 +924,46 @@ static void cf_he_ctx_clear(struct Curl_cfilter *cf, struct Curl_easy *data)
   ctx->winner = NULL;
 }
 
+static CURLcode cf_he_shutdown(struct Curl_cfilter *cf,
+                               struct Curl_easy *data, bool *done)
+{
+  struct cf_he_ctx *ctx = cf->ctx;
+  size_t i;
+  CURLcode result = CURLE_OK;
+
+  DEBUGASSERT(data);
+  if(cf->connected) {
+    *done = TRUE;
+    return CURLE_OK;
+  }
+
+  /* shutdown all ballers that have not done so already. If one fails,
+   * continue shutting down others until all are shutdown. */
+  for(i = 0; i < ARRAYSIZE(ctx->baller); i++) {
+    struct eyeballer *baller = ctx->baller[i];
+    bool bdone = FALSE;
+    if(!baller || !baller->cf || baller->shutdown)
+      continue;
+    baller->result = baller->cf->cft->do_shutdown(baller->cf, data, &bdone);
+    if(baller->result || bdone)
+      baller->shutdown = TRUE; /* treat a failed shutdown as done */
+  }
+
+  *done = TRUE;
+  for(i = 0; i < ARRAYSIZE(ctx->baller); i++) {
+    if(ctx->baller[i] && !ctx->baller[i]->shutdown)
+      *done = FALSE;
+  }
+  if(*done) {
+    for(i = 0; i < ARRAYSIZE(ctx->baller); i++) {
+      if(ctx->baller[i] && ctx->baller[i]->result)
+        result = ctx->baller[i]->result;
+    }
+  }
+  CURL_TRC_CF(data, cf, "shutdown -> %d, done=%d", result, *done);
+  return result;
+}
+
 static void cf_he_adjust_pollset(struct Curl_cfilter *cf,
                                   struct Curl_easy *data,
                                   struct easy_pollset *ps)
@@ -917,7 +1024,7 @@ static CURLcode cf_he_connect(struct Curl_cfilter *cf,
                            CF_CTRL_CONN_INFO_UPDATE, 0, NULL);
 
         if(cf->conn->handler->protocol & PROTO_FAMILY_SSH)
-          Curl_pgrsTime(data, TIMER_APPCONNECT); /* we're connected already */
+          Curl_pgrsTime(data, TIMER_APPCONNECT); /* we are connected already */
         Curl_verboseconnect(data, cf->conn, cf->sockindex);
         data->info.numconnects++; /* to track the # of connections made */
       }
@@ -1052,6 +1159,7 @@ struct Curl_cftype Curl_cft_happy_eyeballs = {
   cf_he_destroy,
   cf_he_connect,
   cf_he_close,
+  cf_he_shutdown,
   Curl_cf_def_get_host,
   cf_he_adjust_pollset,
   cf_he_data_pending,
@@ -1112,7 +1220,7 @@ struct transport_provider {
 };
 
 static
-#ifndef DEBUGBUILD
+#ifndef UNITTESTS
 const
 #endif
 struct transport_provider transport_providers[] = {
@@ -1316,6 +1424,7 @@ struct Curl_cftype Curl_cft_setup = {
   cf_setup_destroy,
   cf_setup_connect,
   cf_setup_close,
+  Curl_cf_def_shutdown,
   Curl_cf_def_get_host,
   Curl_cf_def_adjust_pollset,
   Curl_cf_def_data_pending,
@@ -1378,7 +1487,7 @@ out:
   return result;
 }
 
-#ifdef DEBUGBUILD
+#ifdef UNITTESTS
 /* used by unit2600.c */
 void Curl_debug_set_transport_provider(int transport,
                                        cf_ip_connect_create *cf_create)
@@ -1391,7 +1500,7 @@ void Curl_debug_set_transport_provider(int transport,
     }
   }
 }
-#endif /* DEBUGBUILD */
+#endif /* UNITTESTS */
 
 CURLcode Curl_cf_setup_insert_after(struct Curl_cfilter *cf_at,
                                     struct Curl_easy *data,
diff --git a/lib/connect.h b/lib/connect.h
index 00efe6f34..e9a4f9c59 100644
--- a/lib/connect.h
+++ b/lib/connect.h
@@ -32,7 +32,7 @@
 struct Curl_dns_entry;
 struct ip_quadruple;
 
-/* generic function that returns how much time there's left to run, according
+/* generic function that returns how much time there is left to run, according
    to the timeouts set */
 timediff_t Curl_timeleft(struct Curl_easy *data,
                          struct curltime *nowp,
@@ -40,6 +40,26 @@ timediff_t Curl_timeleft(struct Curl_easy *data,
 
 #define DEFAULT_CONNECT_TIMEOUT 300000 /* milliseconds == five minutes */
 
+#define DEFAULT_SHUTDOWN_TIMEOUT_MS   (2 * 1000)
+
+void Curl_shutdown_start(struct Curl_easy *data, int sockindex,
+                         struct curltime *nowp);
+
+/* return how much time there is left to shutdown the connection at
+ * sockindex. Returns 0 if there is no limit or shutdown has not started. */
+timediff_t Curl_shutdown_timeleft(struct connectdata *conn, int sockindex,
+                                  struct curltime *nowp);
+
+/* return how much time there is left to shutdown the connection.
+ * Returns 0 if there is no limit or shutdown has not started. */
+timediff_t Curl_conn_shutdown_timeleft(struct connectdata *conn,
+                                       struct curltime *nowp);
+
+void Curl_shutdown_clear(struct Curl_easy *data, int sockindex);
+
+/* TRUE iff shutdown has been started */
+bool Curl_shutdown_started(struct Curl_easy *data, int sockindex);
+
 /*
  * Used to extract socket and connectdata struct for the most recent
  * transfer on the given Curl_easy.
@@ -125,7 +145,7 @@ CURLcode Curl_conn_setup(struct Curl_easy *data,
 extern struct Curl_cftype Curl_cft_happy_eyeballs;
 extern struct Curl_cftype Curl_cft_setup;
 
-#ifdef DEBUGBUILD
+#ifdef UNITTESTS
 void Curl_debug_set_transport_provider(int transport,
                                        cf_ip_connect_create *cf_create);
 #endif
diff --git a/lib/content_encoding.c b/lib/content_encoding.c
index d34d3a1f5..4dae41a89 100644
--- a/lib/content_encoding.c
+++ b/lib/content_encoding.c
@@ -82,7 +82,7 @@
 #define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
 #define HEAD_CRC     0x02 /* bit 1 set: header CRC present */
 #define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
-#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
+#define ORIG_NAME    0x08 /* bit 3 set: original filename present */
 #define COMMENT      0x10 /* bit 4 set: file comment present */
 #define RESERVED     0xE0 /* bits 5..7: reserved */
 
@@ -192,7 +192,7 @@ static CURLcode inflate_stream(struct Curl_easy *data,
      zp->zlib_init != ZLIB_GZIP_INFLATING)
     return exit_zlib(data, z, &zp->zlib_init, CURLE_WRITE_ERROR);
 
-  /* Dynamically allocate a buffer for decompression because it's uncommonly
+  /* Dynamically allocate a buffer for decompression because it is uncommonly
      large to hold on the stack */
   decomp = malloc(DSIZ);
   if(!decomp)
@@ -246,7 +246,7 @@ static CURLcode inflate_stream(struct Curl_easy *data,
          to fix and continue anyway */
       if(zp->zlib_init == ZLIB_INIT) {
         /* Do not use inflateReset2(): only available since zlib 1.2.3.4. */
-        (void) inflateEnd(z);     /* don't care about the return code */
+        (void) inflateEnd(z);     /* do not care about the return code */
         if(inflateInit2(z, -MAX_WBITS) == Z_OK) {
           z->next_in = orig_in;
           z->avail_in = nread;
@@ -266,7 +266,7 @@ static CURLcode inflate_stream(struct Curl_easy *data,
   }
   free(decomp);
 
-  /* We're about to leave this call so the `nread' data bytes won't be seen
+  /* We are about to leave this call so the `nread' data bytes will not be seen
      again. If we are in a state that would wrongly allow restart in raw mode
      at the next call, assume output has already started. */
   if(nread && zp->zlib_init == ZLIB_INIT)
@@ -388,7 +388,7 @@ static gzip_status check_gzip_header(unsigned char const *data, ssize_t len,
   flags = data[3];
 
   if(method != Z_DEFLATED || (flags & RESERVED) != 0) {
-    /* Can't handle this compression method or unknown flag */
+    /* cannot handle this compression method or unknown flag */
     return GZIP_BAD;
   }
 
@@ -412,7 +412,7 @@ static gzip_status check_gzip_header(unsigned char const *data, ssize_t len,
   }
 
   if(flags & ORIG_NAME) {
-    /* Skip over NUL-terminated file name */
+    /* Skip over NUL-terminated filename */
     while(len && *data) {
       --len;
       ++data;
@@ -474,10 +474,10 @@ static CURLcode gzip_do_write(struct Curl_easy *data,
   return exit_zlib(data, z, &zp->zlib_init, CURLE_WRITE_ERROR);
 
 #else
-  /* This next mess is to get around the potential case where there isn't
-   * enough data passed in to skip over the gzip header.  If that happens, we
-   * malloc a block and copy what we have then wait for the next call.  If
-   * there still isn't enough (this is definitely a worst-case scenario), we
+  /* This next mess is to get around the potential case where there is not
+   * enough data passed in to skip over the gzip header. If that happens, we
+   * malloc a block and copy what we have then wait for the next call. If
+   * there still is not enough (this is definitely a worst-case scenario), we
    * make the block bigger, copy the next part in and keep waiting.
    *
    * This is only required with zlib versions < 1.2.0.4 as newer versions
@@ -499,11 +499,11 @@ static CURLcode gzip_do_write(struct Curl_easy *data,
       break;
 
     case GZIP_UNDERFLOW:
-      /* We need more data so we can find the end of the gzip header.  It's
+      /* We need more data so we can find the end of the gzip header. it is
        * possible that the memory block we malloc here will never be freed if
-       * the transfer abruptly aborts after this point.  Since it's unlikely
+       * the transfer abruptly aborts after this point. Since it is unlikely
        * that circumstances will be right for this code path to be followed in
-       * the first place, and it's even more unlikely for a transfer to fail
+       * the first place, and it is even more unlikely for a transfer to fail
        * immediately afterwards, it should seldom be a problem.
        */
       z->avail_in = (uInt) nbytes;
@@ -513,7 +513,7 @@ static CURLcode gzip_do_write(struct Curl_easy *data,
       }
       memcpy(z->next_in, buf, z->avail_in);
       zp->zlib_init = ZLIB_GZIP_HEADER;  /* Need more gzip header data state */
-      /* We don't have any data to inflate yet */
+      /* We do not have any data to inflate yet */
       return CURLE_OK;
 
     case GZIP_BAD:
@@ -536,18 +536,18 @@ static CURLcode gzip_do_write(struct Curl_easy *data,
     /* Append the new block of data to the previous one */
     memcpy(z->next_in + z->avail_in - nbytes, buf, nbytes);
 
-    switch(check_gzip_header(z->next_in, z->avail_in, &hlen)) {
+    switch(check_gzip_header(z->next_in, (ssize_t)z->avail_in, &hlen)) {
     case GZIP_OK:
       /* This is the zlib stream data */
       free(z->next_in);
-      /* Don't point into the malloced block since we just freed it */
+      /* Do not point into the malloced block since we just freed it */
       z->next_in = (Bytef *) buf + hlen + nbytes - z->avail_in;
-      z->avail_in = (uInt) (z->avail_in - hlen);
+      z->avail_in = z->avail_in - (uInt)hlen;
       zp->zlib_init = ZLIB_GZIP_INFLATING;   /* Inflating stream state */
       break;
 
     case GZIP_UNDERFLOW:
-      /* We still don't have any data to inflate! */
+      /* We still do not have any data to inflate! */
       return CURLE_OK;
 
     case GZIP_BAD:
@@ -572,11 +572,11 @@ static CURLcode gzip_do_write(struct Curl_easy *data,
   }
 
   if(z->avail_in == 0) {
-    /* We don't have any data to inflate; wait until next time */
+    /* We do not have any data to inflate; wait until next time */
     return CURLE_OK;
   }
 
-  /* We've parsed the header, now uncompress the data */
+  /* We have parsed the header, now uncompress the data */
   return inflate_stream(data, writer, type, ZLIB_GZIP_INFLATING);
 #endif
 }
@@ -966,7 +966,7 @@ static const struct Curl_cwtype *find_unencode_writer(const char *name,
   return NULL;
 }
 
-/* Set-up the unencoding stack from the Content-Encoding header value.
+/* Setup the unencoding stack from the Content-Encoding header value.
  * See RFC 7231 section 3.1.2.2. */
 CURLcode Curl_build_unencoding_stack(struct Curl_easy *data,
                                      const char *enclist, int is_transfer)
@@ -994,6 +994,8 @@ CURLcode Curl_build_unencoding_stack(struct Curl_easy *data,
       const struct Curl_cwtype *cwt;
       struct Curl_cwriter *writer;
 
+      CURL_TRC_WRITE(data, "looking for %s decoder: %.*s",
+                     is_transfer? "transfer" : "content", (int)namelen, name);
       is_chunked = (is_transfer && (namelen == 7) &&
                     strncasecompare(name, "chunked", 7));
       /* if we skip the decoding in this phase, do not look further.
@@ -1001,6 +1003,8 @@ CURLcode Curl_build_unencoding_stack(struct Curl_easy *data,
       if((is_transfer && !data->set.http_transfer_encoding && !is_chunked) ||
          (!is_transfer && data->set.http_ce_skip)) {
         /* not requested, ignore */
+        CURL_TRC_WRITE(data, "decoder not requested, ignored: %.*s",
+                       (int)namelen, name);
         return CURLE_OK;
       }
 
@@ -1018,6 +1022,7 @@ CURLcode Curl_build_unencoding_stack(struct Curl_easy *data,
          * "A sender MUST NOT apply the chunked transfer coding more than
          *  once to a message body."
          */
+        CURL_TRC_WRITE(data, "ignoring duplicate 'chunked' decoder");
         return CURLE_OK;
       }
 
@@ -1040,6 +1045,8 @@ CURLcode Curl_build_unencoding_stack(struct Curl_easy *data,
         cwt = &error_writer;  /* Defer error at use. */
 
       result = Curl_cwriter_create(&writer, data, cwt, phase);
+      CURL_TRC_WRITE(data, "added %s decoder %s -> %d",
+                     is_transfer? "transfer" : "content", cwt->name, result);
       if(result)
         return result;
 
diff --git a/lib/cookie.c b/lib/cookie.c
index 837caaab3..b0d8d84be 100644
--- a/lib/cookie.c
+++ b/lib/cookie.c
@@ -61,7 +61,7 @@ struct Cookies *Curl_cookie_getlist(struct CookieInfo *cookie,
         boolean informs the cookie if a secure connection is achieved or
         not.
 
-        It shall only return cookies that haven't expired.
+        It shall only return cookies that have not expired.
 
 
 Example set of cookies:
@@ -150,7 +150,7 @@ static bool cookie_tailmatch(const char *cookie_domain,
 }
 
 /*
- * matching cookie path and url path
+ * matching cookie path and URL path
  * RFC6265 5.1.4 Paths and Path-Match
  */
 static bool pathmatch(const char *cookie_path, const char *request_uri)
@@ -262,8 +262,9 @@ static size_t cookie_hash_domain(const char *domain, const size_t len)
   size_t h = 5381;
 
   while(domain < end) {
+    size_t j = (size_t)Curl_raw_toupper(*domain++);
     h += h << 5;
-    h ^= Curl_raw_toupper(*domain++);
+    h ^= j;
   }
 
   return (h % COOKIE_HASH_SIZE);
@@ -373,7 +374,7 @@ static void strstore(char **str, const char *newstr, size_t len)
  *
  * Remove expired cookies from the hash by inspecting the expires timestamp on
  * each cookie in the hash, freeing and deleting any where the timestamp is in
- * the past.  If the cookiejar has recorded the next timestamp at which one or
+ * the past. If the cookiejar has recorded the next timestamp at which one or
  * more cookies expire, then processing will exit early in case this timestamp
  * is in the future.
  */
@@ -385,11 +386,11 @@ static void remove_expired(struct CookieInfo *cookies)
 
   /*
    * If the earliest expiration timestamp in the jar is in the future we can
-   * skip scanning the whole jar and instead exit early as there won't be any
-   * cookies to evict.  If we need to evict however, reset the next_expiration
-   * counter in order to track the next one. In case the recorded first
-   * expiration is the max offset, then perform the safe fallback of checking
-   * all cookies.
+   * skip scanning the whole jar and instead exit early as there will not be
+   * any cookies to evict. If we need to evict however, reset the
+   * next_expiration counter in order to track the next one. In case the
+   * recorded first expiration is the max offset, then perform the safe
+   * fallback of checking all cookies.
    */
   if(now < cookies->next_expiration &&
       cookies->next_expiration != CURL_OFF_T_MAX)
@@ -414,7 +415,7 @@ static void remove_expired(struct CookieInfo *cookies)
       }
       else {
         /*
-         * If this cookie has an expiration timestamp earlier than what we've
+         * If this cookie has an expiration timestamp earlier than what we have
          * seen so far then record it for the next round of expirations.
          */
         if(co->expires && co->expires < cookies->next_expiration)
@@ -473,7 +474,7 @@ static int invalid_octets(const char *p)
  * Curl_cookie_add
  *
  * Add a single cookie line to the cookie keeping object. Be aware that
- * sometimes we get an IP-only host name, and that might also be a numerical
+ * sometimes we get an IP-only hostname, and that might also be a numerical
  * IPv6 address.
  *
  * Returns NULL on out of memory or invalid cookie. This is suboptimal,
@@ -509,7 +510,7 @@ Curl_cookie_add(struct Curl_easy *data,
   /* First, alloc and init a new struct for it */
   co = calloc(1, sizeof(struct Cookie));
   if(!co)
-    return NULL; /* bail out if we're this low on memory */
+    return NULL; /* bail out if we are this low on memory */
 
   if(httpheader) {
     /* This line was read off an HTTP-header */
@@ -647,7 +648,7 @@ Curl_cookie_add(struct Curl_easy *data,
           else if((nlen == 8) && strncasecompare("httponly", namep, 8))
             co->httponly = TRUE;
           else if(sep)
-            /* there was a '=' so we're not done parsing this field */
+            /* there was a '=' so we are not done parsing this field */
             done = FALSE;
         }
         if(done)
@@ -681,9 +682,9 @@ Curl_cookie_add(struct Curl_easy *data,
 
 #ifndef USE_LIBPSL
           /*
-           * Without PSL we don't know when the incoming cookie is set on a
+           * Without PSL we do not know when the incoming cookie is set on a
            * TLD or otherwise "protected" suffix. To reduce risk, we require a
-           * dot OR the exact host name being "localhost".
+           * dot OR the exact hostname being "localhost".
            */
           if(bad_domain(valuep, vlen))
             domain = ":";
@@ -721,10 +722,10 @@ Curl_cookie_add(struct Curl_easy *data,
           /*
            * Defined in RFC2109:
            *
-           * Optional.  The Max-Age attribute defines the lifetime of the
-           * cookie, in seconds.  The delta-seconds value is a decimal non-
-           * negative integer.  After delta-seconds seconds elapse, the
-           * client should discard the cookie.  A value of zero means the
+           * Optional. The Max-Age attribute defines the lifetime of the
+           * cookie, in seconds. The delta-seconds value is a decimal non-
+           * negative integer. After delta-seconds seconds elapse, the
+           * client should discard the cookie. A value of zero means the
            * cookie should be discarded immediately.
            */
           CURLofft offt;
@@ -780,7 +781,7 @@ Curl_cookie_add(struct Curl_easy *data,
         }
 
         /*
-         * Else, this is the second (or more) name we don't know about!
+         * Else, this is the second (or more) name we do not know about!
          */
       }
       else {
@@ -806,7 +807,7 @@ Curl_cookie_add(struct Curl_easy *data,
 
     if(!badcookie && !co->path && path) {
       /*
-       * No path was given in the header line, set the default.  Note that the
+       * No path was given in the header line, set the default. Note that the
        * passed-in path to this function MAY have a '?' and following part that
        * MUST NOT be stored as part of the path.
        */
@@ -835,7 +836,7 @@ Curl_cookie_add(struct Curl_easy *data,
     }
 
     /*
-     * If we didn't get a cookie name, or a bad one, the this is an illegal
+     * If we did not get a cookie name, or a bad one, the this is an illegal
      * line so bail out.
      */
     if(badcookie || !co->name) {
@@ -868,7 +869,7 @@ Curl_cookie_add(struct Curl_easy *data,
     }
 
     if(lineptr[0]=='#') {
-      /* don't even try the comments */
+      /* do not even try the comments */
       free(co);
       return NULL;
     }
@@ -908,7 +909,7 @@ Curl_cookie_add(struct Curl_easy *data,
       case 2:
         /* The file format allows the path field to remain not filled in */
         if(strcmp("TRUE", ptr) && strcmp("FALSE", ptr)) {
-          /* only if the path doesn't look like a boolean option! */
+          /* only if the path does not look like a boolean option! */
           co->path = strdup(ptr);
           if(!co->path)
             badcookie = TRUE;
@@ -920,7 +921,7 @@ Curl_cookie_add(struct Curl_easy *data,
           }
           break;
         }
-        /* this doesn't look like a path, make one up! */
+        /* this does not look like a path, make one up! */
         co->path = strdup("/");
         if(!co->path)
           badcookie = TRUE;
@@ -1003,7 +1004,7 @@ Curl_cookie_add(struct Curl_easy *data,
 
   if(!c->running &&    /* read from a file */
      c->newsession &&  /* clean session cookies */
-     !co->expires) {   /* this is a session cookie since it doesn't expire! */
+     !co->expires) {   /* this is a session cookie since it does not expire! */
     freecookie(co);
     return NULL;
   }
@@ -1024,7 +1025,7 @@ Curl_cookie_add(struct Curl_easy *data,
 #ifdef USE_LIBPSL
   /*
    * Check if the domain is a Public Suffix and if yes, ignore the cookie. We
-   * must also check that the data handle isn't NULL since the psl code will
+   * must also check that the data handle is not NULL since the psl code will
    * dereference it.
    */
   if(data && (domain && co->domain && !Curl_host_is_ipnum(co->domain))) {
@@ -1124,10 +1125,10 @@ Curl_cookie_add(struct Curl_easy *data,
 
       if(replace_old && !co->livecookie && clist->livecookie) {
         /*
-         * Both cookies matched fine, except that the already present cookie is
-         * "live", which means it was set from a header, while the new one was
-         * read from a file and thus isn't "live". "live" cookies are preferred
-         * so the new cookie is freed.
+         * Both cookies matched fine, except that the already present cookie
+         * is "live", which means it was set from a header, while the new one
+         * was read from a file and thus is not "live". "live" cookies are
+         * preferred so the new cookie is freed.
          */
         freecookie(co);
         return NULL;
@@ -1178,7 +1179,7 @@ Curl_cookie_add(struct Curl_easy *data,
   }
 
   /*
-   * Now that we've added a new cookie to the jar, update the expiration
+   * Now that we have added a new cookie to the jar, update the expiration
    * tracker in case it is the next one to expire.
    */
   if(co->expires && (co->expires < c->next_expiration))
@@ -1211,12 +1212,12 @@ struct CookieInfo *Curl_cookie_init(struct Curl_easy *data,
   FILE *handle = NULL;
 
   if(!inc) {
-    /* we didn't get a struct, create one */
+    /* we did not get a struct, create one */
     c = calloc(1, sizeof(struct CookieInfo));
     if(!c)
       return NULL; /* failed to get memory */
     /*
-     * Initialize the next_expiration time to signal that we don't have enough
+     * Initialize the next_expiration time to signal that we do not have enough
      * information yet.
      */
     c->next_expiration = CURL_OFF_T_MAX;
@@ -1271,7 +1272,7 @@ struct CookieInfo *Curl_cookie_init(struct Curl_easy *data,
     }
     data->state.cookie_engine = TRUE;
   }
-  c->running = TRUE;          /* now, we're running */
+  c->running = TRUE;          /* now, we are running */
 
   return c;
 }
@@ -1367,7 +1368,7 @@ fail:
  * should send to the server if used now. The secure boolean informs the cookie
  * if a secure connection is achieved or not.
  *
- * It shall only return cookies that haven't expired.
+ * It shall only return cookies that have not expired.
  */
 struct Cookie *Curl_cookie_getlist(struct Curl_easy *data,
                                    struct CookieInfo *c,
@@ -1393,7 +1394,7 @@ struct Cookie *Curl_cookie_getlist(struct Curl_easy *data,
   co = c->cookies[myhash];
 
   while(co) {
-    /* if the cookie requires we're secure we must only continue if we are! */
+    /* if the cookie requires we are secure we must only continue if we are! */
     if(co->secure?secure:TRUE) {
 
       /* now check if the domain is correct */
@@ -1605,7 +1606,7 @@ static char *get_netscape_format(const struct Cookie *co)
  * cookie_output()
  *
  * Writes all internally known cookies to the specified file. Specify
- * "-" as file name to write to stdout.
+ * "-" as filename to write to stdout.
  *
  * The function returns non-zero on write failure.
  */
diff --git a/lib/cookie.h b/lib/cookie.h
index 012dd892c..838d74d82 100644
--- a/lib/cookie.h
+++ b/lib/cookie.h
@@ -75,7 +75,7 @@ struct CookieInfo {
 
 /** Limits for INCOMING cookies **/
 
-/* The longest we allow a line to be when reading a cookie from a HTTP header
+/* The longest we allow a line to be when reading a cookie from an HTTP header
    or from a cookie jar */
 #define MAX_COOKIE_LINE 5000
 
diff --git a/lib/curl_addrinfo.c b/lib/curl_addrinfo.c
index c32f24d01..d290d7da1 100644
--- a/lib/curl_addrinfo.c
+++ b/lib/curl_addrinfo.c
@@ -95,7 +95,7 @@ Curl_freeaddrinfo(struct Curl_addrinfo *cahead)
  * the only difference that instead of returning a linked list of
  * addrinfo structs this one returns a linked list of Curl_addrinfo
  * ones. The memory allocated by this function *MUST* be free'd with
- * Curl_freeaddrinfo().  For each successful call to this function
+ * Curl_freeaddrinfo(). For each successful call to this function
  * there must be an associated call later to Curl_freeaddrinfo().
  *
  * There should be no single call to system's getaddrinfo() in the
@@ -221,7 +221,7 @@ Curl_getaddrinfo_ex(const char *nodename,
  * stack, but usable also for IPv4, all hosts and environments.
  *
  * The memory allocated by this function *MUST* be free'd later on calling
- * Curl_freeaddrinfo().  For each successful call to this function there
+ * Curl_freeaddrinfo(). For each successful call to this function there
  * must be an associated call later to Curl_freeaddrinfo().
  *
  *   Curl_addrinfo defined in "lib/curl_addrinfo.h"
@@ -317,7 +317,11 @@ Curl_he2ai(const struct hostent *he, int port)
       addr = (void *)ai->ai_addr; /* storage area for this info */
 
       memcpy(&addr->sin_addr, curr, sizeof(struct in_addr));
+#ifdef __MINGW32__
+      addr->sin_family = (short)(he->h_addrtype);
+#else
       addr->sin_family = (CURL_SA_FAMILY_T)(he->h_addrtype);
+#endif
       addr->sin_port = htons((unsigned short)port);
       break;
 
@@ -326,7 +330,11 @@ Curl_he2ai(const struct hostent *he, int port)
       addr6 = (void *)ai->ai_addr; /* storage area for this info */
 
       memcpy(&addr6->sin6_addr, curr, sizeof(struct in6_addr));
+#ifdef __MINGW32__
+      addr6->sin6_family = (short)(he->h_addrtype);
+#else
       addr6->sin6_family = (CURL_SA_FAMILY_T)(he->h_addrtype);
+#endif
       addr6->sin6_port = htons((unsigned short)port);
       break;
 #endif
@@ -359,7 +367,7 @@ struct namebuff {
 /*
  * Curl_ip2addr()
  *
- * This function takes an internet address, in binary form, as input parameter
+ * This function takes an Internet address, in binary form, as input parameter
  * along with its address family and the string version of the address, and it
  * returns a Curl_addrinfo chain filled in correctly with information for the
  * given address/host
@@ -511,7 +519,7 @@ struct Curl_addrinfo *Curl_unix2addr(const char *path, bool *longpath,
  *
  * This is strictly for memory tracing and are using the same style as the
  * family otherwise present in memdebug.c. I put these ones here since they
- * require a bunch of structs I didn't want to include in memdebug.c
+ * require a bunch of structs I did not want to include in memdebug.c
  */
 
 void
@@ -535,7 +543,7 @@ curl_dbg_freeaddrinfo(struct addrinfo *freethis,
  *
  * This is strictly for memory tracing and are using the same style as the
  * family otherwise present in memdebug.c. I put these ones here since they
- * require a bunch of structs I didn't want to include in memdebug.c
+ * require a bunch of structs I did not want to include in memdebug.c
  */
 
 int
diff --git a/lib/curl_addrinfo.h b/lib/curl_addrinfo.h
index c757c49c5..9ceac997d 100644
--- a/lib/curl_addrinfo.h
+++ b/lib/curl_addrinfo.h
@@ -44,9 +44,9 @@
 
 /*
  * Curl_addrinfo is our internal struct definition that we use to allow
- * consistent internal handling of this data. We use this even when the
- * system provides an addrinfo structure definition. And we use this for
- * all sorts of IPv4 and IPV6 builds.
+ * consistent internal handling of this data. We use this even when the system
+ * provides an addrinfo structure definition. We use this for all sorts of
+ * IPv4 and IPV6 builds.
  */
 
 struct Curl_addrinfo {
diff --git a/lib/curl_config.h b/lib/curl_config.h
index 2080cc11a..520016528 100644
--- a/lib/curl_config.h
+++ b/lib/curl_config.h
@@ -22,12 +22,27 @@
 /* disable alt-svc */
 /* #undef CURL_DISABLE_ALTSVC */
 
+/* to disable AWS sig support */
+/* #undef CURL_DISABLE_AWS */
+
+/* to disable basic authentication */
+/* #undef CURL_DISABLE_BASIC_AUTH */
+
+/* to disable bearer authentication */
+/* #undef CURL_DISABLE_BEARER_AUTH */
+
+/* disable local binding support */
+/* #undef CURL_DISABLE_BINDLOCAL */
+
 /* to disable cookies support */
 /* #undef CURL_DISABLE_COOKIES */
 
 /* to disable DICT */
 #define CURL_DISABLE_DICT 1
 
+/* to disable digest authentication */
+/* #undef CURL_DISABLE_DIGEST_AUTH */
+
 /* disable DoH */
 /* #undef CURL_DISABLE_DOH */
 
@@ -61,6 +76,9 @@
 /* to disable IMAP */
 #define CURL_DISABLE_IMAP 1
 
+/* to disable kerberos authentication */
+/* #undef CURL_DISABLE_KERBEROS_AUTH */
+
 /* to disable LDAP */
 #define CURL_DISABLE_LDAP 1
 
@@ -76,6 +94,9 @@
 /* to disable MQTT */
 /* #undef CURL_DISABLE_MQTT */
 
+/* to disable negotiate authentication */
+/* #undef CURL_DISABLE_NEGOTIATE_AUTH */
+
 /* disable netrc parsing */
 /* #undef CURL_DISABLE_NETRC */
 
@@ -133,9 +154,6 @@
 /* enable debug build options */
 /* #undef DEBUGBUILD */
 
-/* Define if you want to enable IPv6 support */
-#define ENABLE_IPV6 1
-
 /* Define to the type of arg 2 for gethostname. */
 #define GETHOSTNAME_TYPE_ARG2 size_t
 
@@ -197,12 +215,18 @@
 /* "Set if getpwuid_r() declaration is missing" */
 /* #undef HAVE_DECL_GETPWUID_R_MISSING */
 
+/* if you have <dirent.h> */
+#define HAVE_DIRENT_H 1
+
 /* Define to 1 if you have the <dlfcn.h> header file. */
 #define HAVE_DLFCN_H 1
 
 /* Define to 1 if you have the <err.h> header file. */
 /* #undef HAVE_ERR_H */
 
+/* Define to 1 if you have the `eventfd' function. */
+#define HAVE_EVENTFD 1
+
 /* Define to 1 if you have the fcntl function. */
 #define HAVE_FCNTL 1
 
@@ -384,7 +408,10 @@
 /* Define to 1 if you have the `idn2' library (-lidn2). */
 /* #undef HAVE_LIBIDN2 */
 
-/* Define to 1 if using libressl. */
+/* Define to 1 if you have the <libpsl.h> header file. */
+/* #undef HAVE_LIBPSL_H */
+
+/* Define to 1 if using LibreSSL. */
 /* #undef HAVE_LIBRESSL */
 
 /* Define to 1 if you have the <librtmp/rtmp.h> header file. */
@@ -433,7 +460,7 @@
 #define HAVE_NETDB_H 1
 
 /* Define to 1 if you have the <netinet/in6.h> header file. */
-/* #undef HAVE_NETINET_IN6_H */
+/* #undef HAVE_NETINET_IN6_H 1 */
 
 /* Define to 1 if you have the <netinet/in.h> header file. */
 #define HAVE_NETINET_IN_H 1
@@ -463,6 +490,9 @@
    */
 /* #undef HAVE_OLD_GSSMIT */
 
+/* if you have opendir */
+#define HAVE_OPENDIR 1
+
 /* Define to 1 if using OpenSSL 3 or later. */
 /* #undef HAVE_OPENSSL3 */
 
@@ -475,6 +505,9 @@
 /* Define to 1 if you have the <openssl/pem.h> header file. */
 #define HAVE_OPENSSL_PEM_H 1
 
+/* if you have the functions OSSL_QUIC_client_method */
+/* #undef HAVE_OPENSSL_QUIC */
+
 /* Define to 1 if you have the <openssl/rsa.h> header file. */
 #define HAVE_OPENSSL_RSA_H 1
 
@@ -645,6 +678,9 @@
 /* Define to 1 if suseconds_t is an available type. */
 #define HAVE_SUSECONDS_T 1
 
+/* Define to 1 if you have the <sys/eventfd.h> header file. */
+#define HAVE_SYS_EVENTFD_H 1
+
 /* Define to 1 if you have the <sys/filio.h> header file. */
 /* #undef HAVE_SYS_FILIO_H */
 
@@ -790,7 +826,7 @@
 #define SIZEOF_INT 4
 
 /* Size of long in number of bytes */
-/* #undef SIZEOF_LONG 8 */
+/* #undef SIZEOF_LONG 4 */
 
 /* Size of long long in number of bytes */
 /* #undef SIZEOF_LONG_LONG */
@@ -799,10 +835,10 @@
 /* #undef SIZEOF_OFF_T 8 */
 
 /* Size of size_t in number of bytes */
-/* #undef SIZEOF_SIZE_T 8 */
+/* #undef SIZEOF_SIZE_T 4 */
 
 /* Size of time_t in number of bytes */
-/* #undef SIZEOF_TIME_T 8 */
+/* #undef SIZEOF_TIME_T 4 */
 
 /* Define to 1 if all of the C90 standard headers exist (not just the ones
    required in a freestanding environment). This macro is provided for
@@ -842,10 +878,10 @@
 /* if librtmp is in use */
 /* #undef USE_LIBRTMP */
 
-/* if libSSH is in use */
+/* if libssh is in use */
 /* #undef USE_LIBSSH */
 
-/* if libSSH2 is in use */
+/* if libssh2 is in use */
 /* #undef USE_LIBSSH2 */
 
 /* If you want to build curl with the built-in manual */
@@ -887,6 +923,12 @@
 /* if OpenSSL is in use */
 #define USE_OPENSSL 1
 
+/* if openssl quic + nghttp3 is in use */
+/* #undef USE_OPENSSL_H3 */
+
+/* if openssl QUIC is in use */
+/* #undef USE_OPENSSL_QUIC */
+
 /* if quiche is in use */
 /* #undef USE_QUICHE */
 
@@ -961,12 +1003,6 @@
 /* Type to use in place of in_addr_t when system does not provide it. */
 /* #undef in_addr_t */
 
-/* Define to `__inline__' or `__inline' if that's what the C compiler
-   calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef __cplusplus
-/* #undef inline */
-#endif
-
 /* Define to `unsigned int' if <sys/types.h> does not define. */
 /* #undef size_t */
 
diff --git a/lib/curl_config.h.cmake b/lib/curl_config.h.cmake
index 3a46c6490..631ee27b3 100644
--- a/lib/curl_config.h.cmake
+++ b/lib/curl_config.h.cmake
@@ -21,7 +21,7 @@
  * SPDX-License-Identifier: curl
  *
  ***************************************************************************/
-/* lib/curl_config.h.in.  Generated somehow by cmake.  */
+/* lib/curl_config.h.in. Generated somehow by cmake.  */
 
 /* Location of default ca bundle */
 #cmakedefine CURL_CA_BUNDLE "${CURL_CA_BUNDLE}"
@@ -368,12 +368,6 @@
 /* Define to 1 if you have the idn2.h header file. */
 #cmakedefine HAVE_IDN2_H 1
 
-/* Define to 1 if you have the `socket' library (-lsocket). */
-#cmakedefine HAVE_LIBSOCKET 1
-
-/* Define to 1 if you have the `ssh2' library (-lssh2). */
-#cmakedefine HAVE_LIBSSH2 1
-
 /* if zlib is available */
 #cmakedefine HAVE_LIBZ 1
 
@@ -419,6 +413,9 @@
 /* Define to 1 if you have the `pipe' function. */
 #cmakedefine HAVE_PIPE 1
 
+/* Define to 1 if you have the `eventfd' function. */
+#cmakedefine HAVE_EVENTFD 1
+
 /* If you have a fine poll */
 #cmakedefine HAVE_POLL_FINE 1
 
@@ -539,6 +536,9 @@
 /* Define to 1 if you have the timeval struct. */
 #cmakedefine HAVE_STRUCT_TIMEVAL 1
 
+/* Define to 1 if you have the <sys/eventfd.h> header file. */
+#cmakedefine HAVE_SYS_EVENTFD_H 1
+
 /* Define to 1 if you have the <sys/filio.h> header file. */
 #cmakedefine HAVE_SYS_FILIO_H 1
 
@@ -692,16 +692,22 @@ ${SIZEOF_TIME_T_CODE}
 /* if BearSSL is enabled */
 #cmakedefine USE_BEARSSL 1
 
-/* if WolfSSL is enabled */
+/* if wolfSSL is enabled */
 #cmakedefine USE_WOLFSSL 1
 
-/* if libSSH is in use */
+/* if wolfSSL has the wolfSSL_DES_ecb_encrypt function. */
+#cmakedefine HAVE_WOLFSSL_DES_ECB_ENCRYPT 1
+
+/* if wolfSSL has the wolfSSL_BIO_set_shutdown function. */
+#cmakedefine HAVE_WOLFSSL_FULL_BIO 1
+
+/* if libssh is in use */
 #cmakedefine USE_LIBSSH 1
 
-/* if libSSH2 is in use */
+/* if libssh2 is in use */
 #cmakedefine USE_LIBSSH2 1
 
-/* if libPSL is in use */
+/* if libpsl is in use */
 #cmakedefine USE_LIBPSL 1
 
 /* if you want to use OpenLDAP code instead of legacy ldap implementation */
@@ -713,7 +719,10 @@ ${SIZEOF_TIME_T_CODE}
 /* if librtmp/rtmpdump is in use */
 #cmakedefine USE_LIBRTMP 1
 
-/* Define to 1 if you don't want the OpenSSL configuration to be loaded
+/* if GSASL is in use */
+#cmakedefine USE_GSASL 1
+
+/* Define to 1 if you do not want the OpenSSL configuration to be loaded
    automatically */
 #cmakedefine CURL_DISABLE_OPENSSL_AUTO_LOAD_CONFIG 1
 
diff --git a/lib/curl_config.h.in b/lib/curl_config.h.in
index 50e075947..7871ac147 100644
--- a/lib/curl_config.h.in
+++ b/lib/curl_config.h.in
@@ -218,6 +218,9 @@
 /* Define to 1 if you have the <err.h> header file. */
 #undef HAVE_ERR_H
 
+/* Define to 1 if you have the `eventfd' function. */
+#undef HAVE_EVENTFD
+
 /* Define to 1 if you have the fcntl function. */
 #undef HAVE_FCNTL
 
@@ -402,7 +405,7 @@
 /* Define to 1 if you have the <libpsl.h> header file. */
 #undef HAVE_LIBPSL_H
 
-/* Define to 1 if using libressl. */
+/* Define to 1 if using LibreSSL. */
 #undef HAVE_LIBRESSL
 
 /* Define to 1 if you have the <librtmp/rtmp.h> header file. */
@@ -669,6 +672,9 @@
 /* Define to 1 if suseconds_t is an available type. */
 #undef HAVE_SUSECONDS_T
 
+/* Define to 1 if you have the <sys/eventfd.h> header file. */
+#undef HAVE_SYS_EVENTFD_H
+
 /* Define to 1 if you have the <sys/filio.h> header file. */
 #undef HAVE_SYS_FILIO_H
 
@@ -869,10 +875,10 @@
 /* if librtmp is in use */
 #undef USE_LIBRTMP
 
-/* if libSSH is in use */
+/* if libssh is in use */
 #undef USE_LIBSSH
 
-/* if libSSH2 is in use */
+/* if libssh2 is in use */
 #undef USE_LIBSSH2
 
 /* If you want to build curl with the built-in manual */
diff --git a/lib/curl_des.c b/lib/curl_des.c
index f8d2b2cc6..9662ba39a 100644
--- a/lib/curl_des.c
+++ b/lib/curl_des.c
@@ -36,7 +36,7 @@
  * Curl_des_set_odd_parity()
  *
  * This is used to apply odd parity to the given byte array. It is typically
- * used by when a cryptography engine doesn't have its own version.
+ * used by when a cryptography engine does not have its own version.
  *
  * The function is a port of the Java based oddParity() function over at:
  *
diff --git a/lib/curl_endian.c b/lib/curl_endian.c
index 11c662a4c..d982e3126 100644
--- a/lib/curl_endian.c
+++ b/lib/curl_endian.c
@@ -30,7 +30,7 @@
  * Curl_read16_le()
  *
  * This function converts a 16-bit integer from the little endian format, as
- * used in the incoming package to whatever endian format we're using
+ * used in the incoming package to whatever endian format we are using
  * natively.
  *
  * Parameters:
@@ -49,7 +49,7 @@ unsigned short Curl_read16_le(const unsigned char *buf)
  * Curl_read32_le()
  *
  * This function converts a 32-bit integer from the little endian format, as
- * used in the incoming package to whatever endian format we're using
+ * used in the incoming package to whatever endian format we are using
  * natively.
  *
  * Parameters:
@@ -68,7 +68,7 @@ unsigned int Curl_read32_le(const unsigned char *buf)
  * Curl_read16_be()
  *
  * This function converts a 16-bit integer from the big endian format, as
- * used in the incoming package to whatever endian format we're using
+ * used in the incoming package to whatever endian format we are using
  * natively.
  *
  * Parameters:
diff --git a/lib/curl_fnmatch.c b/lib/curl_fnmatch.c
index 5f9ca4f1b..ab848e8ff 100644
--- a/lib/curl_fnmatch.c
+++ b/lib/curl_fnmatch.c
@@ -80,7 +80,7 @@ static int parsekeyword(unsigned char **pattern, unsigned char *charset)
   unsigned char *p = *pattern;
   bool found = FALSE;
   for(i = 0; !found; i++) {
-    char c = *p++;
+    char c = (char)*p++;
     if(i >= KEYLEN)
       return SETCHARSET_FAIL;
     switch(state) {
diff --git a/lib/curl_gethostname.c b/lib/curl_gethostname.c
index bd9b220d4..cd111231d 100644
--- a/lib/curl_gethostname.c
+++ b/lib/curl_gethostname.c
@@ -28,14 +28,14 @@
 
 /*
  * Curl_gethostname() is a wrapper around gethostname() which allows
- * overriding the host name that the function would normally return.
+ * overriding the hostname that the function would normally return.
  * This capability is used by the test suite to verify exact matching
  * of NTLM authentication, which exercises libcurl's MD4 and DES code
  * as well as by the SMTP module when a hostname is not provided.
  *
- * For libcurl debug enabled builds host name overriding takes place
+ * For libcurl debug enabled builds hostname overriding takes place
  * when environment variable CURL_GETHOSTNAME is set, using the value
- * held by the variable to override returned host name.
+ * held by the variable to override returned hostname.
  *
  * Note: The function always returns the un-qualified hostname rather
  * than being provider dependent.
@@ -45,7 +45,7 @@
  * mechanism which intercepts, and might override, the gethostname()
  * function call. In this case a given platform must support the
  * LD_PRELOAD mechanism and additionally have environment variable
- * CURL_GETHOSTNAME set in order to override the returned host name.
+ * CURL_GETHOSTNAME set in order to override the returned hostname.
  *
  * For libcurl static library release builds no overriding takes place.
  */
@@ -65,7 +65,7 @@ int Curl_gethostname(char * const name, GETHOSTNAME_TYPE_ARG2 namelen)
 
 #ifdef DEBUGBUILD
 
-  /* Override host name when environment variable CURL_GETHOSTNAME is set */
+  /* Override hostname when environment variable CURL_GETHOSTNAME is set */
   const char *force_hostname = getenv("CURL_GETHOSTNAME");
   if(force_hostname) {
     strncpy(name, force_hostname, namelen - 1);
diff --git a/lib/curl_multibyte.h b/lib/curl_multibyte.h
index 8b9ac719e..2d31c28f4 100644
--- a/lib/curl_multibyte.h
+++ b/lib/curl_multibyte.h
@@ -49,9 +49,10 @@ char *curlx_convert_wchar_to_UTF8(const wchar_t *str_w);
  * Allocated memory should be free'd with curlx_unicodefree().
  *
  * Note: Because these are curlx functions their memory usage is not tracked
- * by the curl memory tracker memdebug. You'll notice that curlx function-like
- * macros call free and strdup in parentheses, eg (strdup)(ptr), and that's to
- * ensure that the curl memdebug override macros do not replace them.
+ * by the curl memory tracker memdebug. you will notice that curlx
+ * function-like macros call free and strdup in parentheses, eg (strdup)(ptr),
+ * and that is to ensure that the curl memdebug override macros do not replace
+ * them.
  */
 
 #if defined(UNICODE) && defined(_WIN32)
diff --git a/lib/curl_ntlm_core.c b/lib/curl_ntlm_core.c
index 6f6d75c03..62628c04e 100644
--- a/lib/curl_ntlm_core.c
+++ b/lib/curl_ntlm_core.c
@@ -110,7 +110,7 @@
 #elif defined(USE_WIN32_CRYPTO)
 #  include <wincrypt.h>
 #else
-#  error "Can't compile NTLM support without a crypto library with DES."
+#  error "cannot compile NTLM support without a crypto library with DES."
 #  define CURL_NTLM_NOT_SUPPORTED
 #endif
 
@@ -137,20 +137,20 @@
 */
 static void extend_key_56_to_64(const unsigned char *key_56, char *key)
 {
-  key[0] = key_56[0];
-  key[1] = (unsigned char)(((key_56[0] << 7) & 0xFF) | (key_56[1] >> 1));
-  key[2] = (unsigned char)(((key_56[1] << 6) & 0xFF) | (key_56[2] >> 2));
-  key[3] = (unsigned char)(((key_56[2] << 5) & 0xFF) | (key_56[3] >> 3));
-  key[4] = (unsigned char)(((key_56[3] << 4) & 0xFF) | (key_56[4] >> 4));
-  key[5] = (unsigned char)(((key_56[4] << 3) & 0xFF) | (key_56[5] >> 5));
-  key[6] = (unsigned char)(((key_56[5] << 2) & 0xFF) | (key_56[6] >> 6));
-  key[7] = (unsigned char) ((key_56[6] << 1) & 0xFF);
+  key[0] = (char)key_56[0];
+  key[1] = (char)(((key_56[0] << 7) & 0xFF) | (key_56[1] >> 1));
+  key[2] = (char)(((key_56[1] << 6) & 0xFF) | (key_56[2] >> 2));
+  key[3] = (char)(((key_56[2] << 5) & 0xFF) | (key_56[3] >> 3));
+  key[4] = (char)(((key_56[3] << 4) & 0xFF) | (key_56[4] >> 4));
+  key[5] = (char)(((key_56[4] << 3) & 0xFF) | (key_56[5] >> 5));
+  key[6] = (char)(((key_56[5] << 2) & 0xFF) | (key_56[6] >> 6));
+  key[7] = (char) ((key_56[6] << 1) & 0xFF);
 }
 #endif
 
 #if defined(USE_OPENSSL_DES) || defined(USE_WOLFSSL)
 /*
- * Turns a 56 bit key into the 64 bit, odd parity key and sets the key.  The
+ * Turns a 56-bit key into a 64-bit, odd parity key and sets the key. The
  * key schedule ks is also set.
  */
 static void setup_des_key(const unsigned char *key_56,
@@ -158,7 +158,7 @@ static void setup_des_key(const unsigned char *key_56,
 {
   DES_cblock key;
 
-  /* Expand the 56-bit key to 64-bits */
+  /* Expand the 56-bit key to 64 bits */
   extend_key_56_to_64(key_56, (char *) &key);
 
   /* Set the key parity to odd */
@@ -175,7 +175,7 @@ static void setup_des_key(const unsigned char *key_56,
 {
   char key[8];
 
-  /* Expand the 56-bit key to 64-bits */
+  /* Expand the 56-bit key to 64 bits */
   extend_key_56_to_64(key_56, key);
 
   /* Set the key parity to odd */
@@ -193,7 +193,7 @@ static bool encrypt_des(const unsigned char *in, unsigned char *out,
   mbedtls_des_context ctx;
   char key[8];
 
-  /* Expand the 56-bit key to 64-bits */
+  /* Expand the 56-bit key to 64 bits */
   extend_key_56_to_64(key_56, key);
 
   /* Set the key parity to odd */
@@ -214,7 +214,7 @@ static bool encrypt_des(const unsigned char *in, unsigned char *out,
   size_t out_len;
   CCCryptorStatus err;
 
-  /* Expand the 56-bit key to 64-bits */
+  /* Expand the 56-bit key to 64 bits */
   extend_key_56_to_64(key_56, key);
 
   /* Set the key parity to odd */
@@ -240,7 +240,7 @@ static bool encrypt_des(const unsigned char *in, unsigned char *out,
   ctl.Func_ID = ENCRYPT_ONLY;
   ctl.Data_Len = sizeof(key);
 
-  /* Expand the 56-bit key to 64-bits */
+  /* Expand the 56-bit key to 64 bits */
   extend_key_56_to_64(key_56, ctl.Crypto_Key);
 
   /* Set the key parity to odd */
@@ -278,7 +278,7 @@ static bool encrypt_des(const unsigned char *in, unsigned char *out,
   blob.hdr.aiKeyAlg = CALG_DES;
   blob.len = sizeof(blob.key);
 
-  /* Expand the 56-bit key to 64-bits */
+  /* Expand the 56-bit key to 64 bits */
   extend_key_56_to_64(key_56, blob.key);
 
   /* Set the key parity to odd */
@@ -466,13 +466,13 @@ static void time2filetime(struct ms_filetime *ft, time_t t)
   unsigned int r, s;
   unsigned int i;
 
-  ft->dwLowDateTime = t & 0xFFFFFFFF;
+  ft->dwLowDateTime = (unsigned int)t & 0xFFFFFFFF;
   ft->dwHighDateTime = 0;
 
 # ifndef HAVE_TIME_T_UNSIGNED
   /* Extend sign if needed. */
   if(ft->dwLowDateTime & 0x80000000)
-    ft->dwHighDateTime = ~0;
+    ft->dwHighDateTime = ~(unsigned int)0;
 # endif
 
   /* Bias seconds to Jan 1, 1601.
diff --git a/lib/curl_ntlm_core.h b/lib/curl_ntlm_core.h
index 0c62ee052..e2e4b1bd4 100644
--- a/lib/curl_ntlm_core.h
+++ b/lib/curl_ntlm_core.h
@@ -28,13 +28,6 @@
 
 #if defined(USE_CURL_NTLM_CORE)
 
-#if defined(USE_OPENSSL)
-#  include <openssl/ssl.h>
-#elif defined(USE_WOLFSSL)
-#  include <wolfssl/options.h>
-#  include <wolfssl/openssl/ssl.h>
-#endif
-
 /* Helpers to generate function byte arguments in little endian order */
 #define SHORTPAIR(x) ((int)((x) & 0xff)), ((int)(((x) >> 8) & 0xff))
 #define LONGQUARTET(x) ((int)((x) & 0xff)), ((int)(((x) >> 8) & 0xff)), \
diff --git a/lib/curl_rtmp.c b/lib/curl_rtmp.c
index 76eff787b..54d4f979f 100644
--- a/lib/curl_rtmp.c
+++ b/lib/curl_rtmp.c
@@ -236,7 +236,7 @@ static CURLcode rtmp_connect(struct Curl_easy *data, bool *done)
 
   r->m_sb.sb_socket = (int)conn->sock[FIRSTSOCKET];
 
-  /* We have to know if it's a write before we send the
+  /* We have to know if it is a write before we send the
    * connect request packet
    */
   if(data->state.upload)
@@ -273,10 +273,10 @@ static CURLcode rtmp_do(struct Curl_easy *data, bool *done)
 
   if(data->state.upload) {
     Curl_pgrsSetUploadSize(data, data->state.infilesize);
-    Curl_xfer_setup(data, -1, -1, FALSE, FIRSTSOCKET);
+    Curl_xfer_setup1(data, CURL_XFER_SEND, -1, FALSE);
   }
   else
-    Curl_xfer_setup(data, FIRSTSOCKET, -1, FALSE, -1);
+    Curl_xfer_setup1(data, CURL_XFER_RECV, -1, FALSE);
   *done = TRUE;
   return CURLE_OK;
 }
diff --git a/lib/curl_sasl.c b/lib/curl_sasl.c
index ba8911b72..24f8c8c53 100644
--- a/lib/curl_sasl.c
+++ b/lib/curl_sasl.c
@@ -328,7 +328,7 @@ bool Curl_sasl_can_authenticate(struct SASL *sasl, struct Curl_easy *data)
   if(data->state.aptr.user)
     return TRUE;
 
-  /* EXTERNAL can authenticate without a user name and/or password */
+  /* EXTERNAL can authenticate without a username and/or password */
   if(sasl->authmechs & sasl->prefmech & SASL_MECH_EXTERNAL)
     return TRUE;
 
diff --git a/lib/curl_setup.h b/lib/curl_setup.h
index 6c05b8752..c8dba5e2b 100644
--- a/lib/curl_setup.h
+++ b/lib/curl_setup.h
@@ -40,6 +40,45 @@
 #include <_mingw.h>
 #endif
 
+/* Workaround for Homebrew gcc 12.4.0, 13.3.0, 14.1.0 and newer (as of 14.1.0)
+   that started advertising the `availability` attribute, which then gets used
+   by Apple SDK, but, in a way incompatible with gcc, resulting in a misc
+   errors inside SDK headers, e.g.:
+     error: attributes should be specified before the declarator in a function
+            definition
+     error: expected ',' or '}' before
+   Followed by missing declarations.
+   Fix it by overriding the built-in feature-check macro used by the headers
+   to enable the problematic attributes. This makes the feature check fail. */
+#if defined(__APPLE__) &&                \
+  !defined(__clang__) &&                 \
+  defined(__GNUC__) && __GNUC__ >= 12 && \
+  defined(__has_attribute)
+#define availability curl_pp_attribute_disabled
+#endif
+
+#if defined(__APPLE__)
+#include <sys/types.h>
+#include <TargetConditionals.h>
+/* Fixup faulty target macro initialization in macOS SDK since v14.4 (as of
+   15.0 beta). The SDK target detection in `TargetConditionals.h` correctly
+   detects macOS, but fails to set the macro's old name `TARGET_OS_OSX`, then
+   continues to set it to a default value of 0. Other parts of the SDK still
+   rely on the old name, and with this inconsistency our builds fail due to
+   missing declarations. It happens when using mainline llvm older than v18.
+   Later versions fixed it by predefining these target macros, avoiding the
+   faulty dynamic detection. gcc is not affected (for now) because it lacks
+   the necessary dynamic detection features, so the SDK falls back to
+   a codepath that sets both the old and new macro to 1. */
+#if defined(TARGET_OS_MAC) && TARGET_OS_MAC && \
+  defined(TARGET_OS_OSX) && !TARGET_OS_OSX && \
+  (!defined(TARGET_OS_IPHONE) || !TARGET_OS_IPHONE) && \
+  (!defined(TARGET_OS_SIMULATOR) || !TARGET_OS_SIMULATOR)
+#undef TARGET_OS_OSX
+#define TARGET_OS_OSX TARGET_OS_MAC
+#endif
+#endif
+
 /*
  * Disable Visual Studio warnings:
  * 4127 "conditional expression is constant"
@@ -50,7 +89,7 @@
 
 #ifdef _WIN32
 /*
- * Don't include unneeded stuff in Windows headers to avoid compiler
+ * Do not include unneeded stuff in Windows headers to avoid compiler
  * warnings and macro clashes.
  * Make sure to define this macro before including any Windows headers.
  */
@@ -306,13 +345,25 @@
 #define CURL_PRINTF(fmt, arg)
 #endif
 
+/* Workaround for mainline llvm v16 and earlier missing a built-in macro
+   expected by macOS SDK v14 / Xcode v15 (2023) and newer.
+   gcc (as of v14) is also missing it. */
+#if defined(__APPLE__) &&                                   \
+  ((!defined(__apple_build_version__) &&                    \
+    defined(__clang__) && __clang_major__ < 17) ||          \
+   (defined(__GNUC__) && __GNUC__ <= 14)) &&                \
+  defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && \
+  !defined(__ENVIRONMENT_OS_VERSION_MIN_REQUIRED__)
+#define __ENVIRONMENT_OS_VERSION_MIN_REQUIRED__             \
+  __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
+#endif
+
 /*
  * Use getaddrinfo to resolve the IPv4 address literal. If the current network
- * interface doesn't support IPv4, but supports IPv6, NAT64, and DNS64,
+ * interface does not support IPv4, but supports IPv6, NAT64, and DNS64,
  * performing this task will result in a synthesized IPv6 address.
  */
 #if defined(__APPLE__) && !defined(USE_ARES)
-#include <TargetConditionals.h>
 #define USE_RESOLVE_ON_IPS 1
 #  if TARGET_OS_MAC && !(defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE) && \
      defined(USE_IPV6)
@@ -447,7 +498,7 @@
 #endif
 
 #ifndef SIZEOF_TIME_T
-/* assume default size of time_t to be 32 bit */
+/* assume default size of time_t to be 32 bits */
 #define SIZEOF_TIME_T 4
 #endif
 
@@ -470,7 +521,7 @@
 #endif
 
 /*
- * Default sizeof(off_t) in case it hasn't been defined in config file.
+ * Default sizeof(off_t) in case it has not been defined in config file.
  */
 
 #ifndef SIZEOF_OFF_T
@@ -537,7 +588,7 @@
 #endif
 
 #ifndef SIZE_T_MAX
-/* some limits.h headers have this defined, some don't */
+/* some limits.h headers have this defined, some do not */
 #if defined(SIZEOF_SIZE_T) && (SIZEOF_SIZE_T > 4)
 #define SIZE_T_MAX 18446744073709551615U
 #else
@@ -546,7 +597,7 @@
 #endif
 
 #ifndef SSIZE_T_MAX
-/* some limits.h headers have this defined, some don't */
+/* some limits.h headers have this defined, some do not */
 #if defined(SIZEOF_SIZE_T) && (SIZEOF_SIZE_T > 4)
 #define SSIZE_T_MAX 9223372036854775807
 #else
@@ -555,7 +606,7 @@
 #endif
 
 /*
- * Arg 2 type for gethostname in case it hasn't been defined in config file.
+ * Arg 2 type for gethostname in case it has not been defined in config file.
  */
 
 #ifndef GETHOSTNAME_TYPE_ARG2
@@ -770,7 +821,7 @@
 #endif
 
 /*
- * shutdown() flags for systems that don't define them
+ * shutdown() flags for systems that do not define them
  */
 
 #ifndef SHUT_RD
@@ -818,7 +869,7 @@ endings either CRLF or LF so 't' is appropriate.
 #define FOPEN_APPENDTEXT "a"
 #endif
 
-/* for systems that don't detect this in configure */
+/* for systems that do not detect this in configure */
 #ifndef CURL_SA_FAMILY_T
 #  if defined(HAVE_SA_FAMILY_T)
 #    define CURL_SA_FAMILY_T sa_family_t
@@ -847,7 +898,7 @@ int getpwuid_r(uid_t uid, struct passwd *pwd, char *buf,
                size_t buflen, struct passwd **result);
 #endif
 
-#ifdef DEBUGBUILD
+#ifdef UNITTESTS
 #define UNITTEST
 #else
 #define UNITTEST static
diff --git a/lib/curl_setup_once.h b/lib/curl_setup_once.h
index 40c7bcbff..1521e69f9 100644
--- a/lib/curl_setup_once.h
+++ b/lib/curl_setup_once.h
@@ -106,7 +106,7 @@
 #endif
 
 /*
- * Definition of timeval struct for platforms that don't have it.
+ * Definition of timeval struct for platforms that do not have it.
  */
 
 #ifndef HAVE_STRUCT_TIMEVAL
@@ -130,7 +130,7 @@ struct timeval {
 
 
 #if defined(__minix)
-/* Minix doesn't support recv on TCP sockets */
+/* Minix does not support recv on TCP sockets */
 #define sread(x,y,z) (ssize_t)read((RECV_TYPE_ARG1)(x), \
                                    (RECV_TYPE_ARG2)(y), \
                                    (RECV_TYPE_ARG3)(z))
@@ -143,7 +143,7 @@ struct timeval {
  *
  * HAVE_RECV is defined if you have a function named recv()
  * which is used to read incoming data from sockets. If your
- * function has another name then don't define HAVE_RECV.
+ * function has another name then do not define HAVE_RECV.
  *
  * If HAVE_RECV is defined then RECV_TYPE_ARG1, RECV_TYPE_ARG2,
  * RECV_TYPE_ARG3, RECV_TYPE_ARG4 and RECV_TYPE_RETV must also
@@ -151,7 +151,7 @@ struct timeval {
  *
  * HAVE_SEND is defined if you have a function named send()
  * which is used to write outgoing data on a connected socket.
- * If yours has another name then don't define HAVE_SEND.
+ * If yours has another name then do not define HAVE_SEND.
  *
  * If HAVE_SEND is defined then SEND_TYPE_ARG1, SEND_QUAL_ARG2,
  * SEND_TYPE_ARG2, SEND_TYPE_ARG3, SEND_TYPE_ARG4 and
@@ -170,7 +170,7 @@ struct timeval {
 
 
 #if defined(__minix)
-/* Minix doesn't support send on TCP sockets */
+/* Minix does not support send on TCP sockets */
 #define swrite(x,y,z) (ssize_t)write((SEND_TYPE_ARG1)(x), \
                                     (SEND_TYPE_ARG2)(y), \
                                     (SEND_TYPE_ARG3)(z))
@@ -226,7 +226,7 @@ struct timeval {
 
 /*
  * 'bool' exists on platforms with <stdbool.h>, i.e. C99 platforms.
- * On non-C99 platforms there's no bool, so define an enum for that.
+ * On non-C99 platforms there is no bool, so define an enum for that.
  * On C99 platforms 'false' and 'true' also exist. Enum uses a
  * global namespace though, so use bool_false and bool_true.
  */
@@ -238,7 +238,7 @@ struct timeval {
   } bool;
 
 /*
- * Use a define to let 'true' and 'false' use those enums.  There
+ * Use a define to let 'true' and 'false' use those enums. There
  * are currently no use of true and false in libcurl proper, but
  * there are some in the examples. This will cater for any later
  * code happening to use true and false.
diff --git a/lib/curl_sha512_256.c b/lib/curl_sha512_256.c
index 5f2e99517..e3533d8fc 100644
--- a/lib/curl_sha512_256.c
+++ b/lib/curl_sha512_256.c
@@ -270,9 +270,9 @@ Curl_sha512_256_finish(unsigned char *digest,
  * ** written by Evgeny Grin (Karlson2k) for GNU libmicrohttpd.          ** *
  * ** The author ported the code to libcurl. The ported code is provided ** *
  * ** under curl license.                                                ** *
- * ** This is a minimal version with minimal optimisations. Performance  ** *
+ * ** This is a minimal version with minimal optimizations. Performance  ** *
  * ** can be significantly improved. Big-endian store and load macros    ** *
- * ** are obvious targets for optimisation.                              ** */
+ * ** are obvious targets for optimization.                              ** */
 
 #ifdef __GNUC__
 #  if defined(__has_attribute) && defined(__STDC_VERSION__)
@@ -328,7 +328,7 @@ MHDx_rotr64(curl_uint64_t value, unsigned int bits)
   bits %= 64;
   if(0 == bits)
     return value;
-  /* Defined in a form which modern compiler could optimise. */
+  /* Defined in a form which modern compiler could optimize. */
   return (value >> bits) | (value << (64 - bits));
 }
 
@@ -474,10 +474,10 @@ MHDx_sha512_256_transform(curl_uint64_t H[SHA512_256_HASH_SIZE_WORDS],
      See FIPS PUB 180-4 section 5.2.2, 6.7, 6.4. */
   curl_uint64_t W[16];
 
-  /* 'Ch' and 'Maj' macro functions are defined with widely-used optimisation.
+  /* 'Ch' and 'Maj' macro functions are defined with widely-used optimization.
      See FIPS PUB 180-4 formulae 4.8, 4.9. */
-#define Ch(x,y,z)     ( (z) ^ ((x) & ((y) ^ (z))) )
-#define Maj(x,y,z)    ( ((x) & (y)) ^ ((z) & ((x) ^ (y))) )
+#define Sha512_Ch(x,y,z)     ( (z) ^ ((x) & ((y) ^ (z))) )
+#define Sha512_Maj(x,y,z)    ( ((x) & (y)) ^ ((z) & ((x) ^ (y))) )
 
   /* Four 'Sigma' macro functions.
      See FIPS PUB 180-4 formulae 4.10, 4.11, 4.12, 4.13. */
@@ -547,9 +547,9 @@ MHDx_sha512_256_transform(curl_uint64_t H[SHA512_256_HASH_SIZE_WORDS],
        * Note: 'wt' must be used exactly one time in this macro as macro for
        'wt' calculation may change other data as well every time when
        used. */
-#define SHA2STEP64(vA,vB,vC,vD,vE,vF,vG,vH,kt,wt) do {                  \
-      (vD) += ((vH) += SIG1 ((vE)) + Ch ((vE),(vF),(vG)) + (kt) + (wt)); \
-      (vH) += SIG0 ((vA)) + Maj ((vA),(vB),(vC)); } while (0)
+#define SHA2STEP64(vA,vB,vC,vD,vE,vF,vG,vH,kt,wt) do {                       \
+     (vD) += ((vH) += SIG1((vE)) + Sha512_Ch((vE),(vF),(vG)) + (kt) + (wt)); \
+     (vH) += SIG0((vA)) + Sha512_Maj((vA),(vB),(vC)); } while (0)
 
     /* One step of SHA-512/256 computation with working variables rotation,
        see FIPS PUB 180-4 section 6.4.2 step 3. This macro version reassigns
diff --git a/lib/curl_sspi.c b/lib/curl_sspi.c
index eb21e7e2b..2c9e38d90 100644
--- a/lib/curl_sspi.c
+++ b/lib/curl_sspi.c
@@ -134,7 +134,7 @@ void Curl_sspi_global_cleanup(void)
  *
  * Parameters:
  *
- * userp    [in]     - The user name in the format User or Domain\User.
+ * userp    [in]     - The username in the format User or Domain\User.
  * passwdp  [in]     - The user's password.
  * identity [in/out] - The identity structure.
  *
diff --git a/lib/curl_threads.c b/lib/curl_threads.c
index 93fa2dafb..fb4af73d0 100644
--- a/lib/curl_threads.c
+++ b/lib/curl_threads.c
@@ -100,18 +100,23 @@ int Curl_thread_join(curl_thread_t *hnd)
 
 #elif defined(USE_THREADS_WIN32)
 
-/* !checksrc! disable SPACEBEFOREPAREN 1 */
-curl_thread_t Curl_thread_create(unsigned int (CURL_STDCALL *func) (void *),
+curl_thread_t Curl_thread_create(
+#if defined(_WIN32_WCE) || defined(CURL_WINDOWS_APP)
+                                 DWORD
+#else
+                                 unsigned int
+#endif
+                                 (CURL_STDCALL *func) (void *),
                                  void *arg)
 {
-#ifdef _WIN32_WCE
+#if defined(_WIN32_WCE) || defined(CURL_WINDOWS_APP)
   typedef HANDLE curl_win_thread_handle_t;
 #else
   typedef uintptr_t curl_win_thread_handle_t;
 #endif
   curl_thread_t t;
   curl_win_thread_handle_t thread_handle;
-#ifdef _WIN32_WCE
+#if defined(_WIN32_WCE) || defined(CURL_WINDOWS_APP)
   thread_handle = CreateThread(NULL, 0, func, arg, 0, NULL);
 #else
   thread_handle = _beginthreadex(NULL, 0, func, arg, 0, NULL);
diff --git a/lib/curl_threads.h b/lib/curl_threads.h
index 27a478d4c..be22352dc 100644
--- a/lib/curl_threads.h
+++ b/lib/curl_threads.h
@@ -52,8 +52,13 @@
 
 #if defined(USE_THREADS_POSIX) || defined(USE_THREADS_WIN32)
 
-/* !checksrc! disable SPACEBEFOREPAREN 1 */
-curl_thread_t Curl_thread_create(unsigned int (CURL_STDCALL *func) (void *),
+curl_thread_t Curl_thread_create(
+#if defined(_WIN32_WCE) || defined(CURL_WINDOWS_APP)
+                                 DWORD
+#else
+                                 unsigned int
+#endif
+                                 (CURL_STDCALL *func) (void *),
                                  void *arg);
 
 void Curl_thread_destroy(curl_thread_t hnd);
diff --git a/lib/cw-out.c b/lib/cw-out.c
index 4e56c6a1b..56ec4162e 100644
--- a/lib/cw-out.c
+++ b/lib/cw-out.c
@@ -228,8 +228,8 @@ static CURLcode cw_out_ptr_flush(struct cw_out_ctx *ctx,
     if(CURL_WRITEFUNC_PAUSE == nwritten) {
       if(data->conn && data->conn->handler->flags & PROTOPT_NONETWORK) {
         /* Protocols that work without network cannot be paused. This is
-           actually only FILE:// just now, and it can't pause since the
-           transfer isn't done using the "normal" procedure. */
+           actually only FILE:// just now, and it cannot pause since the
+           transfer is not done using the "normal" procedure. */
         failf(data, "Write callback asked for PAUSE when not supported");
         return CURLE_WRITE_ERROR;
       }
diff --git a/lib/dict.c b/lib/dict.c
index a26a28b7b..35331ce22 100644
--- a/lib/dict.c
+++ b/lib/dict.c
@@ -241,7 +241,7 @@ static CURLcode dict_do(struct Curl_easy *data, bool *done)
       failf(data, "Failed sending DICT request");
       goto error;
     }
-    Curl_xfer_setup(data, FIRSTSOCKET, -1, FALSE, -1); /* no upload */
+    Curl_xfer_setup1(data, CURL_XFER_RECV, -1, FALSE); /* no upload */
   }
   else if(strncasecompare(path, DICT_DEFINE, sizeof(DICT_DEFINE)-1) ||
           strncasecompare(path, DICT_DEFINE2, sizeof(DICT_DEFINE2)-1) ||
@@ -287,7 +287,7 @@ static CURLcode dict_do(struct Curl_easy *data, bool *done)
       failf(data, "Failed sending DICT request");
       goto error;
     }
-    Curl_xfer_setup(data, FIRSTSOCKET, -1, FALSE, -1);
+    Curl_xfer_setup1(data, CURL_XFER_RECV, -1, FALSE);
   }
   else {
 
@@ -309,7 +309,7 @@ static CURLcode dict_do(struct Curl_easy *data, bool *done)
         goto error;
       }
 
-      Curl_xfer_setup(data, FIRSTSOCKET, -1, FALSE, -1);
+      Curl_xfer_setup1(data, CURL_XFER_RECV, -1, FALSE);
     }
   }
 
diff --git a/lib/doh.c b/lib/doh.c
index 03317ae27..0dcca17cc 100644
--- a/lib/doh.c
+++ b/lib/doh.c
@@ -93,21 +93,21 @@ UNITTEST DOHcode doh_encode(const char *host,
   const char *hostp = host;
 
   /* The expected output length is 16 bytes more than the length of
-   * the QNAME-encoding of the host name.
+   * the QNAME-encoding of the hostname.
    *
    * A valid DNS name may not contain a zero-length label, except at
-   * the end.  For this reason, a name beginning with a dot, or
+   * the end. For this reason, a name beginning with a dot, or
    * containing a sequence of two or more consecutive dots, is invalid
    * and cannot be encoded as a QNAME.
    *
-   * If the host name ends with a trailing dot, the corresponding
-   * QNAME-encoding is one byte longer than the host name. If (as is
+   * If the hostname ends with a trailing dot, the corresponding
+   * QNAME-encoding is one byte longer than the hostname. If (as is
    * also valid) the hostname is shortened by the omission of the
    * trailing dot, then its QNAME-encoding will be two bytes longer
-   * than the host name.
+   * than the hostname.
    *
    * Each [ label, dot ] pair is encoded as [ length, label ],
-   * preserving overall length.  A final [ label ] without a dot is
+   * preserving overall length. A final [ label ] without a dot is
    * also encoded as [ length, label ], increasing overall length
    * by one. The encoding is completed by appending a zero byte,
    * representing the zero-length root label, again increasing
@@ -191,7 +191,7 @@ doh_write_cb(const void *contents, size_t size, size_t nmemb, void *userp)
   return realsize;
 }
 
-#if defined(USE_HTTPSRR) && defined(CURLDEBUG)
+#if defined(USE_HTTPSRR) && defined(DEBUGBUILD)
 static void local_print_buf(struct Curl_easy *data,
                             const char *prefix,
                             unsigned char *buf, size_t len)
@@ -285,7 +285,7 @@ static CURLcode dohprobe(struct Curl_easy *data,
     ERROR_CHECK_SETOPT(CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_2TLS);
     ERROR_CHECK_SETOPT(CURLOPT_PIPEWAIT, 1L);
 #endif
-#ifndef CURLDEBUG
+#ifndef DEBUGBUILD
     /* enforce HTTPS if not debug */
     ERROR_CHECK_SETOPT(CURLOPT_PROTOCOLS, CURLPROTO_HTTPS);
 #else
@@ -400,7 +400,6 @@ struct Curl_addrinfo *Curl_doh(struct Curl_easy *data,
                                int *waitp)
 {
   CURLcode result = CURLE_OK;
-  int slot;
   struct dohdata *dohp;
   struct connectdata *conn = data->conn;
 #ifdef USE_HTTPSRR
@@ -455,9 +454,9 @@ struct Curl_addrinfo *Curl_doh(struct Curl_easy *data,
    * TODO: Figure out the conditions under which we want to make
    * a request for an HTTPS RR when we are not doing ECH. For now,
    * making this request breaks a bunch of DoH tests, e.g. test2100,
-   * where the additional request doesn't match the pre-cooked data
-   * files, so there's a bit of work attached to making the request
-   * in a non-ECH use-case. For the present, we'll only make the
+   * where the additional request does not match the pre-cooked data
+   * files, so there is a bit of work attached to making the request
+   * in a non-ECH use-case. For the present, we will only make the
    * request when ECH is enabled in the build and is being used for
    * the curl operation.
    */
@@ -473,7 +472,7 @@ struct Curl_addrinfo *Curl_doh(struct Curl_easy *data,
     result = dohprobe(data, &dohp->probe[DOH_PROBE_SLOT_HTTPS],
                       DNS_TYPE_HTTPS, qname, data->set.str[STRING_DOH],
                       data->multi, dohp->headers);
-    free(qname);
+    Curl_safefree(qname);
     if(result)
       goto error;
     dohp->pending++;
@@ -484,13 +483,7 @@ struct Curl_addrinfo *Curl_doh(struct Curl_easy *data,
   return NULL;
 
 error:
-  curl_slist_free_all(dohp->headers);
-  data->req.doh->headers = NULL;
-  for(slot = 0; slot < DOH_PROBE_SLOTS; slot++) {
-    (void)curl_multi_remove_handle(data->multi, dohp->probe[slot].easy);
-    Curl_close(&dohp->probe[slot].easy);
-  }
-  Curl_safefree(data->req.doh);
+  Curl_doh_cleanup(data);
   return NULL;
 }
 
@@ -518,12 +511,12 @@ static DOHcode skipqname(const unsigned char *doh, size_t dohlen,
   return DOH_OK;
 }
 
-static unsigned short get16bit(const unsigned char *doh, int index)
+static unsigned short get16bit(const unsigned char *doh, unsigned int index)
 {
   return (unsigned short)((doh[index] << 8) | doh[index + 1]);
 }
 
-static unsigned int get32bit(const unsigned char *doh, int index)
+static unsigned int get32bit(const unsigned char *doh, unsigned int index)
 {
   /* make clang and gcc optimize this to bswap by incrementing
      the pointer first. */
@@ -531,7 +524,7 @@ static unsigned int get32bit(const unsigned char *doh, int index)
 
   /* avoid undefined behavior by casting to unsigned before shifting
      24 bits, possibly into the sign bit. codegen is same, but
-     ub sanitizer won't be upset */
+     ub sanitizer will not be upset */
   return ((unsigned)doh[0] << 24) | ((unsigned)doh[1] << 16) |
          ((unsigned)doh[2] << 8) | doh[3];
 }
@@ -606,7 +599,7 @@ static DOHcode store_cname(const unsigned char *doh,
 
       /* move to the new index */
       newpos = (length & 0x3f) << 8 | doh[index + 1];
-      index = newpos;
+      index = (unsigned int)newpos;
       continue;
     }
     else if(length & 0xc0)
@@ -670,7 +663,7 @@ static DOHcode rdata(const unsigned char *doh,
     break;
 #endif
   case DNS_TYPE_CNAME:
-    rc = store_cname(doh, dohlen, index, d);
+    rc = store_cname(doh, dohlen, (unsigned int)index, d);
     if(rc)
       return rc;
     break;
@@ -771,7 +764,7 @@ UNITTEST DOHcode doh_decode(const unsigned char *doh,
     if(dohlen < (index + rdlength))
       return DOH_DNS_OUT_OF_RANGE;
 
-    rc = rdata(doh, dohlen, rdlength, type, index, d);
+    rc = rdata(doh, dohlen, rdlength, type, (int)index, d);
     if(rc)
       return rc; /* bad rdata */
     index += rdlength;
@@ -870,7 +863,7 @@ static void showdoh(struct Curl_easy *data,
   }
 #ifdef USE_HTTPSRR
   for(i = 0; i < d->numhttps_rrs; i++) {
-# ifdef CURLDEBUG
+# ifdef DEBUGBUILD
     local_print_buf(data, "DoH HTTPS",
                     d->https_rrs[i].val, d->https_rrs[i].len);
 # else
@@ -891,11 +884,11 @@ static void showdoh(struct Curl_easy *data,
  *
  * This function returns a pointer to the first element of a newly allocated
  * Curl_addrinfo struct linked list filled with the data from a set of DoH
- * lookups.  Curl_addrinfo is meant to work like the addrinfo struct does for
+ * lookups. Curl_addrinfo is meant to work like the addrinfo struct does for
  * a IPv6 stack, but usable also for IPv4, all hosts and environments.
  *
  * The memory allocated by this function *MUST* be free'd later on calling
- * Curl_freeaddrinfo().  For each successful call to this function there
+ * Curl_freeaddrinfo(). For each successful call to this function there
  * must be an associated call later to Curl_freeaddrinfo().
  */
 
@@ -923,7 +916,7 @@ static CURLcode doh2ai(const struct dohentry *de, const char *hostname,
     CURL_SA_FAMILY_T addrtype;
     if(de->addr[i].type == DNS_TYPE_AAAA) {
 #ifndef USE_IPV6
-      /* we can't handle IPv6 addresses */
+      /* we cannot handle IPv6 addresses */
       continue;
 #else
       ss_size = sizeof(struct sockaddr_in6);
@@ -967,7 +960,11 @@ static CURLcode doh2ai(const struct dohentry *de, const char *hostname,
       addr = (void *)ai->ai_addr; /* storage area for this info */
       DEBUGASSERT(sizeof(struct in_addr) == sizeof(de->addr[i].ip.v4));
       memcpy(&addr->sin_addr, &de->addr[i].ip.v4, sizeof(struct in_addr));
+#ifdef __MINGW32__
+      addr->sin_family = (short)addrtype;
+#else
       addr->sin_family = addrtype;
+#endif
       addr->sin_port = htons((unsigned short)port);
       break;
 
@@ -976,7 +973,11 @@ static CURLcode doh2ai(const struct dohentry *de, const char *hostname,
       addr6 = (void *)ai->ai_addr; /* storage area for this info */
       DEBUGASSERT(sizeof(struct in6_addr) == sizeof(de->addr[i].ip.v6));
       memcpy(&addr6->sin6_addr, &de->addr[i].ip.v6, sizeof(struct in6_addr));
+#ifdef __MINGW32__
+      addr6->sin6_family = (short)addrtype;
+#else
       addr6->sin6_family = addrtype;
+#endif
       addr6->sin6_port = htons((unsigned short)port);
       break;
 #endif
@@ -1020,7 +1021,7 @@ UNITTEST void de_cleanup(struct dohentry *d)
   }
 #ifdef USE_HTTPSRR
   for(i = 0; i < d->numhttps_rrs; i++)
-    free(d->https_rrs[i].val);
+    Curl_safefree(d->https_rrs[i].val);
 #endif
 }
 
@@ -1038,7 +1039,7 @@ UNITTEST void de_cleanup(struct dohentry *d)
  *
  * The input buffer pointer will be modified so it points to
  * just after the end of the DNS name encoding on output. (And
- * that's why it's an "unsigned char **" :-)
+ * that is why it is an "unsigned char **" :-)
  */
 static CURLcode local_decode_rdata_name(unsigned char **buf, size_t *remaining,
                                         char **dnsname)
@@ -1097,7 +1098,7 @@ static CURLcode local_decode_rdata_alpn(unsigned char *rrval, size_t len,
    * output is comma-sep list of the strings
    * implementations may or may not handle quoting of comma within
    * string values, so we might see a comma within the wire format
-   * version of a string, in which case we'll precede that by a
+   * version of a string, in which case we will precede that by a
    * backslash - same goes for a backslash character, and of course
    * we need to use two backslashes in strings when we mean one;-)
    */
@@ -1143,10 +1144,10 @@ err:
   return CURLE_BAD_CONTENT_ENCODING;
 }
 
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
 static CURLcode test_alpn_escapes(void)
 {
-  /* we'll use an example from draft-ietf-dnsop-svcb, figure 10 */
+  /* we will use an example from draft-ietf-dnsop-svcb, figure 10 */
   static unsigned char example[] = {
     0x08,                                           /* length 8 */
     0x66, 0x5c, 0x6f, 0x6f, 0x2c, 0x62, 0x61, 0x72, /* value "f\\oo,bar" */
@@ -1176,8 +1177,8 @@ static CURLcode Curl_doh_decode_httpsrr(unsigned char *rrval, size_t len,
   struct Curl_https_rrinfo *lhrr = NULL;
   char *dnsname = NULL;
 
-#ifdef CURLDEBUG
-  /* a few tests of escaping, shouldn't be here but ok for now */
+#ifdef DEBUGBUILD
+  /* a few tests of escaping, should not be here but ok for now */
   if(test_alpn_escapes() != CURLE_OK)
     return CURLE_OUT_OF_MEMORY;
 #endif
@@ -1209,18 +1210,24 @@ static CURLcode Curl_doh_decode_httpsrr(unsigned char *rrval, size_t len,
     if(pcode == HTTPS_RR_CODE_NO_DEF_ALPN)
       lhrr->no_def_alpn = TRUE;
     else if(pcode == HTTPS_RR_CODE_IPV4) {
+      if(!plen)
+        goto err;
       lhrr->ipv4hints = Curl_memdup(cp, plen);
       if(!lhrr->ipv4hints)
         goto err;
       lhrr->ipv4hints_len = (size_t)plen;
     }
     else if(pcode == HTTPS_RR_CODE_ECH) {
+      if(!plen)
+        goto err;
       lhrr->echconfiglist = Curl_memdup(cp, plen);
       if(!lhrr->echconfiglist)
         goto err;
       lhrr->echconfiglist_len = (size_t)plen;
     }
     else if(pcode == HTTPS_RR_CODE_IPV6) {
+      if(!plen)
+        goto err;
       lhrr->ipv6hints = Curl_memdup(cp, plen);
       if(!lhrr->ipv6hints)
         goto err;
@@ -1236,15 +1243,16 @@ static CURLcode Curl_doh_decode_httpsrr(unsigned char *rrval, size_t len,
   return CURLE_OK;
 err:
   if(lhrr) {
-    free(lhrr->target);
-    free(lhrr->echconfiglist);
-    free(lhrr->val);
-    free(lhrr);
+    Curl_safefree(lhrr->target);
+    Curl_safefree(lhrr->echconfiglist);
+    Curl_safefree(lhrr->val);
+    Curl_safefree(lhrr->alpns);
+    Curl_safefree(lhrr);
   }
   return CURLE_OUT_OF_MEMORY;
 }
 
-# ifdef CURLDEBUG
+# ifdef DEBUGBUILD
 static void local_print_httpsrr(struct Curl_easy *data,
                                 struct Curl_https_rrinfo *hrr)
 {
@@ -1310,10 +1318,7 @@ CURLcode Curl_doh_is_resolved(struct Curl_easy *data,
     struct dohentry de;
     int slot;
     /* remove DoH handles from multi handle and close them */
-    for(slot = 0; slot < DOH_PROBE_SLOTS; slot++) {
-      curl_multi_remove_handle(data->multi, dohp->probe[slot].easy);
-      Curl_close(&dohp->probe[slot].easy);
-    }
+    Curl_doh_close(data);
     /* parse the responses, create the struct and return it! */
     de_init(&de);
     for(slot = 0; slot < DOH_PROBE_SLOTS; slot++) {
@@ -1341,7 +1346,7 @@ CURLcode Curl_doh_is_resolved(struct Curl_easy *data,
 
 
       if(Curl_trc_ft_is_verbose(data, &Curl_doh_trc)) {
-        infof(data, "[DoH] Host name: %s", dohp->host);
+        infof(data, "[DoH] hostname: %s", dohp->host);
         showdoh(data, &de);
       }
 
@@ -1382,7 +1387,7 @@ CURLcode Curl_doh_is_resolved(struct Curl_easy *data,
         return result;
       }
       infof(data, "Some HTTPS RR to process");
-# ifdef CURLDEBUG
+# ifdef DEBUGBUILD
       local_print_httpsrr(data, hrr);
 # endif
       (*dnsp)->hinfo = hrr;
@@ -1400,4 +1405,32 @@ CURLcode Curl_doh_is_resolved(struct Curl_easy *data,
   return CURLE_OK;
 }
 
+void Curl_doh_close(struct Curl_easy *data)
+{
+  struct dohdata *doh = data->req.doh;
+  if(doh) {
+    size_t slot;
+    for(slot = 0; slot < DOH_PROBE_SLOTS; slot++) {
+      if(!doh->probe[slot].easy)
+        continue;
+      /* data->multi might already be reset at this time */
+      if(doh->probe[slot].easy->multi)
+        curl_multi_remove_handle(doh->probe[slot].easy->multi,
+                                 doh->probe[slot].easy);
+      Curl_close(&doh->probe[slot].easy);
+    }
+  }
+}
+
+void Curl_doh_cleanup(struct Curl_easy *data)
+{
+  struct dohdata *doh = data->req.doh;
+  if(doh) {
+    Curl_doh_close(data);
+    curl_slist_free_all(doh->headers);
+    data->req.doh->headers = NULL;
+    Curl_safefree(data->req.doh);
+  }
+}
+
 #endif /* CURL_DISABLE_DOH */
diff --git a/lib/doh.h b/lib/doh.h
index bb881ecc5..5e86bf44a 100644
--- a/lib/doh.h
+++ b/lib/doh.h
@@ -140,19 +140,22 @@ struct dohentry {
 #endif
 };
 
-
-#ifdef DEBUGBUILD
-DOHcode doh_encode(const char *host,
-                   DNStype dnstype,
-                   unsigned char *dnsp, /* buffer */
-                   size_t len,  /* buffer size */
-                   size_t *olen); /* output length */
-DOHcode doh_decode(const unsigned char *doh,
-                   size_t dohlen,
-                   DNStype dnstype,
-                   struct dohentry *d);
-void de_init(struct dohentry *d);
-void de_cleanup(struct dohentry *d);
+void Curl_doh_close(struct Curl_easy *data);
+void Curl_doh_cleanup(struct Curl_easy *data);
+
+#ifdef UNITTESTS
+UNITTEST DOHcode doh_encode(const char *host,
+                            DNStype dnstype,
+                            unsigned char *dnsp,  /* buffer */
+                            size_t len,  /* buffer size */
+                            size_t *olen);  /* output length */
+UNITTEST DOHcode doh_decode(const unsigned char *doh,
+                            size_t dohlen,
+                            DNStype dnstype,
+                            struct dohentry *d);
+
+UNITTEST void de_init(struct dohentry *d);
+UNITTEST void de_cleanup(struct dohentry *d);
 #endif
 
 extern struct curl_trc_feat Curl_doh_trc;
diff --git a/lib/dynbuf.c b/lib/dynbuf.c
index 3b62eaf8a..eab07efbf 100644
--- a/lib/dynbuf.c
+++ b/lib/dynbuf.c
@@ -51,7 +51,7 @@ void Curl_dyn_init(struct dynbuf *s, size_t toobig)
 }
 
 /*
- * free the buffer and re-init the necessary fields. It doesn't touch the
+ * free the buffer and re-init the necessary fields. It does not touch the
  * 'init' field and thus this buffer can be reused to add data to again.
  */
 void Curl_dyn_free(struct dynbuf *s)
@@ -71,7 +71,7 @@ static CURLcode dyn_nappend(struct dynbuf *s,
   size_t a = s->allc;
   size_t fit = len + indx + 1; /* new string + old string + zero byte */
 
-  /* try to detect if there's rubbish in the struct */
+  /* try to detect if there is rubbish in the struct */
   DEBUGASSERT(s->init == DYNINIT);
   DEBUGASSERT(s->toobig);
   DEBUGASSERT(indx < s->toobig);
diff --git a/lib/dynhds.c b/lib/dynhds.c
index d7548959b..9153838e3 100644
--- a/lib/dynhds.c
+++ b/lib/dynhds.c
@@ -275,7 +275,7 @@ CURLcode Curl_dynhds_h1_cadd_line(struct dynhds *dynhds, const char *line)
   return Curl_dynhds_h1_add_line(dynhds, line, line? strlen(line) : 0);
 }
 
-#ifdef DEBUGBUILD
+#ifdef UNITTESTS
 /* used by unit2602.c */
 
 bool Curl_dynhds_contains(struct dynhds *dynhds,
diff --git a/lib/dynhds.h b/lib/dynhds.h
index 3b536000a..fb162a30d 100644
--- a/lib/dynhds.h
+++ b/lib/dynhds.h
@@ -95,6 +95,9 @@ struct dynhds_entry *Curl_dynhds_get(struct dynhds *dynhds,
                                      const char *name, size_t namelen);
 struct dynhds_entry *Curl_dynhds_cget(struct dynhds *dynhds, const char *name);
 
+#ifdef UNITTESTS
+/* used by unit2602.c */
+
 /**
  * Return TRUE iff one or more headers with the given name exist.
  */
@@ -115,20 +118,6 @@ size_t Curl_dynhds_count_name(struct dynhds *dynhds,
  */
 size_t Curl_dynhds_ccount_name(struct dynhds *dynhds, const char *name);
 
-/**
- * Add a header, name + value, to `dynhds` at the end. Does *not*
- * check for duplicate names.
- */
-CURLcode Curl_dynhds_add(struct dynhds *dynhds,
-                         const char *name, size_t namelen,
-                         const char *value, size_t valuelen);
-
-/**
- * Add a header, c-string name + value, to `dynhds` at the end.
- */
-CURLcode Curl_dynhds_cadd(struct dynhds *dynhds,
-                          const char *name, const char *value);
-
 /**
  * Remove all entries with the given name.
  * Returns number of entries removed.
@@ -146,19 +135,34 @@ size_t Curl_dynhds_cremove(struct dynhds *dynhds, const char *name);
 CURLcode Curl_dynhds_set(struct dynhds *dynhds,
                          const char *name, size_t namelen,
                          const char *value, size_t valuelen);
+#endif
 
 CURLcode Curl_dynhds_cset(struct dynhds *dynhds,
                           const char *name, const char *value);
 
 /**
- * Add a single header from a HTTP/1.1 formatted line at the end. Line
+ * Add a header, name + value, to `dynhds` at the end. Does *not*
+ * check for duplicate names.
+ */
+CURLcode Curl_dynhds_add(struct dynhds *dynhds,
+                         const char *name, size_t namelen,
+                         const char *value, size_t valuelen);
+
+/**
+ * Add a header, c-string name + value, to `dynhds` at the end.
+ */
+CURLcode Curl_dynhds_cadd(struct dynhds *dynhds,
+                          const char *name, const char *value);
+
+/**
+ * Add a single header from an HTTP/1.1 formatted line at the end. Line
  * may contain a delimiting \r\n or just \n. Any characters after
  * that will be ignored.
  */
 CURLcode Curl_dynhds_h1_cadd_line(struct dynhds *dynhds, const char *line);
 
 /**
- * Add a single header from a HTTP/1.1 formatted line at the end. Line
+ * Add a single header from an HTTP/1.1 formatted line at the end. Line
  * may contain a delimiting \r\n or just \n. Any characters after
  * that will be ignored.
  */
diff --git a/lib/easy.c b/lib/easy.c
index a04dbedd8..2ba9af0b3 100644
--- a/lib/easy.c
+++ b/lib/easy.c
@@ -242,7 +242,7 @@ CURLcode curl_global_init_mem(long flags, curl_malloc_callback m,
   global_init_lock();
 
   if(initialized) {
-    /* Already initialized, don't do it again, but bump the variable anyway to
+    /* Already initialized, do not do it again, but bump the variable anyway to
        work like curl_global_init() and require the same amount of cleanup
        calls. */
     initialized++;
@@ -268,7 +268,8 @@ CURLcode curl_global_init_mem(long flags, curl_malloc_callback m,
 
 /**
  * curl_global_cleanup() globally cleanups curl, uses the value of
- * "easy_init_flags" to determine what needs to be cleaned up and what doesn't.
+ * "easy_init_flags" to determine what needs to be cleaned up and what does
+ * not.
  */
 void curl_global_cleanup(void)
 {
@@ -374,7 +375,7 @@ struct Curl_easy *curl_easy_init(void)
   return data;
 }
 
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
 
 struct socketmonitor {
   struct socketmonitor *next; /* the next node in the list or NULL */
@@ -579,7 +580,7 @@ static CURLcode wait_or_timeout(struct Curl_multi *multi, struct events *ev)
     before = Curl_now();
 
     /* wait for activity or timeout */
-    pollrc = Curl_poll(fds, numfds, ev->ms);
+    pollrc = Curl_poll(fds, (unsigned int)numfds, ev->ms);
     if(pollrc < 0)
       return CURLE_UNRECOVERABLE_POLL;
 
@@ -627,7 +628,7 @@ static CURLcode wait_or_timeout(struct Curl_multi *multi, struct events *ev)
     if(mcode)
       return CURLE_URL_MALFORMAT;
 
-    /* we don't really care about the "msgs_in_queue" value returned in the
+    /* we do not really care about the "msgs_in_queue" value returned in the
        second argument */
     msg = curl_multi_info_read(multi, &pollrc);
     if(msg) {
@@ -655,8 +656,8 @@ static CURLcode easy_events(struct Curl_multi *multi)
 
   return wait_or_timeout(multi, &evs);
 }
-#else /* CURLDEBUG */
-/* when not built with debug, this function doesn't exist */
+#else /* DEBUGBUILD */
+/* when not built with debug, this function does not exist */
 #define easy_events(x) CURLE_NOT_BUILT_IN
 #endif
 
@@ -706,7 +707,7 @@ static CURLcode easy_transfer(struct Curl_multi *multi)
  * easy handle, destroys the multi handle and returns the easy handle's return
  * code.
  *
- * REALITY: it can't just create and destroy the multi handle that easily. It
+ * REALITY: it cannot just create and destroy the multi handle that easily. It
  * needs to keep it around since if this easy handle is used again by this
  * function, the same multi handle must be reused so that the same pools and
  * caches can be used.
@@ -763,12 +764,13 @@ static CURLcode easy_perform(struct Curl_easy *data, bool events)
   /* assign this after curl_multi_add_handle() */
   data->multi_easy = multi;
 
-  sigpipe_ignore(data, &pipe_st);
+  sigpipe_init(&pipe_st);
+  sigpipe_apply(data, &pipe_st);
 
   /* run the transfer */
   result = events ? easy_events(multi) : easy_transfer(multi);
 
-  /* ignoring the return code isn't nice, but atm we can't really handle
+  /* ignoring the return code is not nice, but atm we cannot really handle
      a failure here, room for future improvement! */
   (void)curl_multi_remove_handle(multi, data);
 
@@ -788,7 +790,7 @@ CURLcode curl_easy_perform(struct Curl_easy *data)
   return easy_perform(data, FALSE);
 }
 
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
 /*
  * curl_easy_perform_ev() is the external interface that performs a blocking
  * transfer using the event-based API internally.
@@ -1090,7 +1092,7 @@ CURLcode curl_easy_pause(struct Curl_easy *data, int action)
   bool keep_changed, unpause_read, not_all_paused;
 
   if(!GOOD_EASY_HANDLE(data) || !data->conn)
-    /* crazy input, don't continue */
+    /* crazy input, do not continue */
     return CURLE_BAD_FUNCTION_ARGUMENT;
 
   if(Curl_is_in_callback(data))
@@ -1142,6 +1144,11 @@ CURLcode curl_easy_pause(struct Curl_easy *data, int action)
       goto out;
   }
 
+  if(!(k->keepon & KEEP_RECV_PAUSE) && Curl_cwriter_is_paused(data)) {
+    Curl_conn_ev_data_pause(data, FALSE);
+    result = Curl_cwriter_unpause(data);
+  }
+
 out:
   if(!result && !data->state.done && keep_changed)
     /* This transfer may have been moved in or out of the bundle, update the
diff --git a/lib/easygetopt.c b/lib/easygetopt.c
index a0239a89f..86833bf6b 100644
--- a/lib/easygetopt.c
+++ b/lib/easygetopt.c
@@ -42,7 +42,7 @@ static struct curl_easyoption *lookup(const char *name, CURLoption id)
       }
       else {
         if((o->id == id) && !(o->flags & CURLOT_FLAG_ALIAS))
-          /* don't match alias options */
+          /* do not match alias options */
           return o;
       }
       o++;
diff --git a/lib/easyif.h b/lib/easyif.h
index 6ce3483c6..d77bb98f9 100644
--- a/lib/easyif.h
+++ b/lib/easyif.h
@@ -34,7 +34,7 @@ CURLcode Curl_senddata(struct Curl_easy *data, const void *buffer,
 CURLcode Curl_connect_only_attach(struct Curl_easy *data);
 #endif
 
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
 CURL_EXTERN CURLcode curl_easy_perform_ev(struct Curl_easy *easy);
 #endif
 
diff --git a/lib/easyoptions.c b/lib/easyoptions.c
index c79d13670..81091c405 100644
--- a/lib/easyoptions.c
+++ b/lib/easyoptions.c
@@ -328,6 +328,7 @@ struct curl_easyoption Curl_easyopts[] = {
    CURLOT_LONG, 0},
   {"TCP_FASTOPEN", CURLOPT_TCP_FASTOPEN, CURLOT_LONG, 0},
   {"TCP_KEEPALIVE", CURLOPT_TCP_KEEPALIVE, CURLOT_LONG, 0},
+  {"TCP_KEEPCNT", CURLOPT_TCP_KEEPCNT, CURLOT_LONG, 0},
   {"TCP_KEEPIDLE", CURLOPT_TCP_KEEPIDLE, CURLOT_LONG, 0},
   {"TCP_KEEPINTVL", CURLOPT_TCP_KEEPINTVL, CURLOT_LONG, 0},
   {"TCP_NODELAY", CURLOPT_TCP_NODELAY, CURLOT_LONG, 0},
@@ -376,6 +377,6 @@ struct curl_easyoption Curl_easyopts[] = {
  */
 int Curl_easyopts_check(void)
 {
-  return ((CURLOPT_LASTENTRY%10000) != (325 + 1));
+  return ((CURLOPT_LASTENTRY%10000) != (326 + 1));
 }
 #endif
diff --git a/lib/escape.c b/lib/escape.c
index 5af00c351..1633c2da2 100644
--- a/lib/escape.c
+++ b/lib/escape.c
@@ -60,7 +60,7 @@ char *curl_easy_escape(struct Curl_easy *data, const char *string,
   struct dynbuf d;
   (void)data;
 
-  if(inlength < 0)
+  if(!string || (inlength < 0))
     return NULL;
 
   Curl_dyn_init(&d, CURL_MAX_INPUT_LENGTH * 3);
@@ -70,7 +70,8 @@ char *curl_easy_escape(struct Curl_easy *data, const char *string,
     return strdup("");
 
   while(length--) {
-    unsigned char in = *string++; /* treat the characters unsigned */
+    /* treat the characters unsigned */
+    unsigned char in = (unsigned char)*string++;
 
     if(ISUNRESERVED(in)) {
       /* append this */
@@ -137,7 +138,7 @@ CURLcode Curl_urldecode(const char *string, size_t length,
   *ostring = ns;
 
   while(alloc) {
-    unsigned char in = *string;
+    unsigned char in = (unsigned char)*string;
     if(('%' == in) && (alloc > 2) &&
        ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {
       /* this is two hexadecimal digits following a '%' */
@@ -157,7 +158,7 @@ CURLcode Curl_urldecode(const char *string, size_t length,
       return CURLE_URL_MALFORMAT;
     }
 
-    *ns++ = in;
+    *ns++ = (char)in;
   }
   *ns = 0; /* terminate it */
 
@@ -180,7 +181,7 @@ char *curl_easy_unescape(struct Curl_easy *data, const char *string,
 {
   char *str = NULL;
   (void)data;
-  if(length >= 0) {
+  if(string && (length >= 0)) {
     size_t inputlen = (size_t)length;
     size_t outputlen;
     CURLcode res = Curl_urldecode(string, inputlen, &str, &outputlen,
@@ -222,8 +223,8 @@ void Curl_hexencode(const unsigned char *src, size_t len, /* input length */
     while(len-- && (olen >= 3)) {
       /* clang-tidy warns on this line without this comment: */
       /* NOLINTNEXTLINE(clang-analyzer-core.UndefinedBinaryOperatorResult) */
-      *out++ = hex[(*src & 0xF0)>>4];
-      *out++ = hex[*src & 0x0F];
+      *out++ = (unsigned char)hex[(*src & 0xF0)>>4];
+      *out++ = (unsigned char)hex[*src & 0x0F];
       ++src;
       olen -= 2;
     }
diff --git a/lib/file.c b/lib/file.c
index db860225b..82ff151b6 100644
--- a/lib/file.c
+++ b/lib/file.c
@@ -147,7 +147,7 @@ static CURLcode file_setup_connection(struct Curl_easy *data,
 
 /*
  * file_connect() gets called from Curl_protocol_connect() to allow us to
- * do protocol-specific actions at connect-time.  We emulate a
+ * do protocol-specific actions at connect-time. We emulate a
  * connect-then-transfer protocol and "connect" to the file here
  */
 static CURLcode file_connect(struct Curl_easy *data, bool *done)
@@ -177,18 +177,18 @@ static CURLcode file_connect(struct Curl_easy *data, bool *done)
     return result;
 
 #ifdef DOS_FILESYSTEM
-  /* If the first character is a slash, and there's
+  /* If the first character is a slash, and there is
      something that looks like a drive at the beginning of
-     the path, skip the slash.  If we remove the initial
+     the path, skip the slash. If we remove the initial
      slash in all cases, paths without drive letters end up
-     relative to the current directory which isn't how
+     relative to the current directory which is not how
      browsers work.
 
      Some browsers accept | instead of : as the drive letter
      separator, so we do too.
 
      On other platforms, we need the slash to indicate an
-     absolute pathname.  On Windows, absolute paths start
+     absolute pathname. On Windows, absolute paths start
      with a drive letter.
   */
   actual_path = real_path;
@@ -308,7 +308,7 @@ static CURLcode file_upload(struct Curl_easy *data)
   bool eos = FALSE;
 
   /*
-   * Since FILE: doesn't do the full init, we need to provide some extra
+   * Since FILE: does not do the full init, we need to provide some extra
    * assignments here.
    */
 
@@ -331,7 +331,7 @@ static CURLcode file_upload(struct Curl_easy *data)
 
   fd = open(file->path, mode, data->set.new_file_perms);
   if(fd < 0) {
-    failf(data, "Can't open %s for writing", file->path);
+    failf(data, "cannot open %s for writing", file->path);
     return CURLE_WRITE_ERROR;
   }
 
@@ -343,7 +343,7 @@ static CURLcode file_upload(struct Curl_easy *data)
   if(data->state.resume_from < 0) {
     if(fstat(fd, &file_stat)) {
       close(fd);
-      failf(data, "Can't get the size of %s", file->path);
+      failf(data, "cannot get the size of %s", file->path);
       return CURLE_WRITE_ERROR;
     }
     data->state.resume_from = (curl_off_t)file_stat.st_size;
@@ -413,13 +413,13 @@ out:
  * file_do() is the protocol-specific function for the do-phase, separated
  * from the connect-phase above. Other protocols merely setup the transfer in
  * the do-phase, to have it done in the main transfer loop but since some
- * platforms we support don't allow select()ing etc on file handles (as
+ * platforms we support do not allow select()ing etc on file handles (as
  * opposed to sockets) we instead perform the whole do-operation in this
  * function.
  */
 static CURLcode file_do(struct Curl_easy *data, bool *done)
 {
-  /* This implementation ignores the host name in conformance with
+  /* This implementation ignores the hostname in conformance with
      RFC 1738. Only local files (reachable via the standard file system)
      are supported. This means that files on remotely mounted directories
      (via NFS, Samba, NT sharing) can be accessed through a file:// URL
@@ -465,17 +465,18 @@ static CURLcode file_do(struct Curl_easy *data, bool *done)
     const struct tm *tm = &buffer;
     char header[80];
     int headerlen;
-    char accept_ranges[24]= { "Accept-ranges: bytes\r\n" };
+    static const char accept_ranges[]= { "Accept-ranges: bytes\r\n" };
     if(expected_size >= 0) {
-      headerlen = msnprintf(header, sizeof(header),
-                "Content-Length: %" CURL_FORMAT_CURL_OFF_T "\r\n",
-                expected_size);
+      headerlen =
+        msnprintf(header, sizeof(header),
+                  "Content-Length: %" CURL_FORMAT_CURL_OFF_T "\r\n",
+                  expected_size);
       result = Curl_client_write(data, CLIENTWRITE_HEADER, header, headerlen);
       if(result)
         return result;
 
       result = Curl_client_write(data, CLIENTWRITE_HEADER,
-                                 accept_ranges, strlen(accept_ranges));
+                                 accept_ranges, sizeof(accept_ranges) - 1);
       if(result != CURLE_OK)
         return result;
     }
@@ -486,23 +487,26 @@ static CURLcode file_do(struct Curl_easy *data, bool *done)
       return result;
 
     /* format: "Tue, 15 Nov 1994 12:45:26 GMT" */
-    headerlen = msnprintf(header, sizeof(header),
-              "Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n%s",
-              Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
-              tm->tm_mday,
-              Curl_month[tm->tm_mon],
-              tm->tm_year + 1900,
-              tm->tm_hour,
-              tm->tm_min,
-              tm->tm_sec,
-              data->req.no_body ? "": "\r\n");
+    headerlen =
+      msnprintf(header, sizeof(header),
+                "Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n",
+                Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
+                tm->tm_mday,
+                Curl_month[tm->tm_mon],
+                tm->tm_year + 1900,
+                tm->tm_hour,
+                tm->tm_min,
+                tm->tm_sec);
     result = Curl_client_write(data, CLIENTWRITE_HEADER, header, headerlen);
+    if(!result)
+      /* end of headers */
+      result = Curl_client_write(data, CLIENTWRITE_HEADER, "\r\n", 2);
     if(result)
       return result;
     /* set the file size to make it available post transfer */
     Curl_pgrsSetDownloadSize(data, expected_size);
     if(data->req.no_body)
-      return result;
+      return CURLE_OK;
   }
 
   /* Check whether file range has been specified */
@@ -514,7 +518,7 @@ static CURLcode file_do(struct Curl_easy *data, bool *done)
    * of the stream if the filesize could be determined */
   if(data->state.resume_from < 0) {
     if(!fstated) {
-      failf(data, "Can't get the size of file.");
+      failf(data, "cannot get the size of file.");
       return CURLE_READ_ERROR;
     }
     data->state.resume_from += (curl_off_t)statbuf.st_size;
@@ -522,7 +526,7 @@ static CURLcode file_do(struct Curl_easy *data, bool *done)
 
   if(data->state.resume_from > 0) {
     /* We check explicitly if we have a start offset, because
-     * expected_size may be -1 if we don't know how large the file is,
+     * expected_size may be -1 if we do not know how large the file is,
      * in which case we should not adjust it. */
     if(data->state.resume_from <= expected_size)
       expected_size -= data->state.resume_from;
@@ -566,7 +570,7 @@ static CURLcode file_do(struct Curl_easy *data, bool *done)
   if(!S_ISDIR(statbuf.st_mode)) {
     while(!result) {
       ssize_t nread;
-      /* Don't fill a whole buffer if we want less than all data */
+      /* Do not fill a whole buffer if we want less than all data */
       size_t bytestoread;
 
       if(size_known) {
diff --git a/lib/fopen.c b/lib/fopen.c
index 0bdf2e11b..7373e0883 100644
--- a/lib/fopen.c
+++ b/lib/fopen.c
@@ -42,12 +42,12 @@
 /*
   The dirslash() function breaks a null-terminated pathname string into
   directory and filename components then returns the directory component up
-  to, *AND INCLUDING*, a final '/'.  If there is no directory in the path,
+  to, *AND INCLUDING*, a final '/'. If there is no directory in the path,
   this instead returns a "" string.
 
   This function returns a pointer to malloc'ed memory.
 
-  The input path to this function is expected to have a file name part.
+  The input path to this function is expected to have a filename part.
 */
 
 #ifdef _WIN32
@@ -88,7 +88,7 @@ static char *dirslash(const char *path)
  * Curl_fopen() opens a file for writing with a temp name, to be renamed
  * to the final name when completed. If there is an existing file using this
  * name at the time of the open, this function will clone the mode from that
- * file.  if 'tempname' is non-NULL, it needs a rename after the file is
+ * file. if 'tempname' is non-NULL, it needs a rename after the file is
  * written.
  */
 CURLcode Curl_fopen(struct Curl_easy *data, const char *filename,
@@ -117,7 +117,7 @@ CURLcode Curl_fopen(struct Curl_easy *data, const char *filename,
 
   dir = dirslash(filename);
   if(dir) {
-    /* The temp file name should not end up too long for the target file
+    /* The temp filename should not end up too long for the target file
        system */
     tempstore = aprintf("%s%s.tmp", dir, randbuf);
     free(dir);
diff --git a/lib/formdata.c b/lib/formdata.c
index d6a1697aa..7a282bdd3 100644
--- a/lib/formdata.c
+++ b/lib/formdata.c
@@ -216,8 +216,8 @@ CURLFORMcode FormAdd(struct curl_httppost **httppost,
   struct curl_forms *forms = NULL;
   char *array_value = NULL; /* value read from an array */
 
-  /* This is a state variable, that if TRUE means that we're parsing an
-     array that we got passed to us. If FALSE we're parsing the input
+  /* This is a state variable, that if TRUE means that we are parsing an
+     array that we got passed to us. If FALSE we are parsing the input
      va_list arguments. */
   bool array_state = FALSE;
 
@@ -260,7 +260,7 @@ CURLFORMcode FormAdd(struct curl_httppost **httppost,
     switch(option) {
     case CURLFORM_ARRAY:
       if(array_state)
-        /* we don't support an array from within an array */
+        /* we do not support an array from within an array */
         return_value = CURL_FORMADD_ILLEGAL_ARRAY;
       else {
         forms = va_arg(params, struct curl_forms *);
@@ -327,7 +327,7 @@ CURLFORMcode FormAdd(struct curl_httppost **httppost,
         array_state?(curl_off_t)(size_t)array_value:va_arg(params, curl_off_t);
       break;
 
-      /* Get contents from a given file name */
+      /* Get contents from a given filename */
     case CURLFORM_FILECONTENT:
       if(current_form->flags & (HTTPPOST_PTRCONTENTS|HTTPPOST_READFILE))
         return_value = CURL_FORMADD_OPTION_TWICE;
@@ -429,7 +429,7 @@ CURLFORMcode FormAdd(struct curl_httppost **httppost,
           array_state?array_value:va_arg(params, char *);
         if(userp) {
           current_form->userp = userp;
-          current_form->value = userp; /* this isn't strictly true but we
+          current_form->value = userp; /* this is not strictly true but we
                                           derive a value from this later on
                                           and we need this non-NULL to be
                                           accepted as a fine form part */
@@ -599,7 +599,7 @@ CURLFORMcode FormAdd(struct curl_httppost **httppost,
       }
       if(!(form->flags & HTTPPOST_PTRNAME) &&
          (form == first_form) ) {
-        /* Note that there's small risk that form->name is NULL here if the
+        /* Note that there is small risk that form->name is NULL here if the
            app passed in a bad combo, so we better check for that first. */
         if(form->name) {
           /* copy name (without strdup; possibly not null-terminated) */
@@ -764,7 +764,7 @@ void curl_formfree(struct curl_httppost *form)
       )
       free(form->contents); /* free the contents */
     free(form->contenttype); /* free the content type */
-    free(form->showfilename); /* free the faked file name */
+    free(form->showfilename); /* free the faked filename */
     free(form);       /* free the struct */
     form = next;
   } while(form); /* continue */
@@ -880,10 +880,10 @@ CURLcode Curl_getformdata(struct Curl_easy *data,
 
         if(post->flags & (HTTPPOST_FILENAME | HTTPPOST_READFILE)) {
           if(!strcmp(file->contents, "-")) {
-            /* There are a few cases where the code below won't work; in
+            /* There are a few cases where the code below will not work; in
                particular, freopen(stdin) by the caller is not guaranteed
                to result as expected. This feature has been kept for backward
-               compatibility: use of "-" pseudo file name should be avoided. */
+               compatibility: use of "-" pseudo filename should be avoided. */
             result = curl_mime_data_cb(part, (curl_off_t) -1,
                                        (curl_read_callback) fread,
                                        fseeko_wrapper,
@@ -915,7 +915,7 @@ CURLcode Curl_getformdata(struct Curl_easy *data,
         }
       }
 
-      /* Set fake file name. */
+      /* Set fake filename. */
       if(!result && post->showfilename)
         if(post->more || (post->flags & (HTTPPOST_FILENAME | HTTPPOST_BUFFER |
                                         HTTPPOST_CALLBACK)))
diff --git a/lib/formdata.h b/lib/formdata.h
index af466249f..2ed96ffcf 100644
--- a/lib/formdata.h
+++ b/lib/formdata.h
@@ -38,8 +38,8 @@ struct FormInfo {
   long flags;
   char *buffer;      /* pointer to existing buffer used for file upload */
   size_t bufferlength;
-  char *showfilename; /* The file name to show. If not set, the actual
-                         file name will be used */
+  char *showfilename; /* The filename to show. If not set, the actual
+                         filename will be used */
   char *userp;        /* pointer for the read callback */
   struct curl_slist *contentheader;
   struct FormInfo *more;
diff --git a/lib/ftp.c b/lib/ftp.c
index b88d4d7b0..ae340c44a 100644
--- a/lib/ftp.c
+++ b/lib/ftp.c
@@ -290,12 +290,11 @@ const struct Curl_handler Curl_handler_ftps = {
 };
 #endif
 
-static void close_secondarysocket(struct Curl_easy *data,
-                                  struct connectdata *conn)
+static void close_secondarysocket(struct Curl_easy *data)
 {
   CURL_TRC_FTP(data, "[%s] closing DATA connection", FTP_DSTATE(data));
   Curl_conn_close(data, SECONDARYSOCKET);
-  Curl_conn_cf_discard_all(data, conn, SECONDARYSOCKET);
+  Curl_conn_cf_discard_all(data, data->conn, SECONDARYSOCKET);
 }
 
 /*
@@ -475,7 +474,7 @@ static CURLcode AcceptServerConnect(struct Curl_easy *data)
     Curl_set_in_callback(data, false);
 
     if(error) {
-      close_secondarysocket(data, conn);
+      close_secondarysocket(data);
       return CURLE_ABORTED_BY_CALLBACK;
     }
   }
@@ -649,19 +648,19 @@ static CURLcode InitiateTransfer(struct Curl_easy *data)
     return result;
 
   if(conn->proto.ftpc.state_saved == FTP_STOR) {
-    /* When we know we're uploading a specified file, we can get the file
+    /* When we know we are uploading a specified file, we can get the file
        size prior to the actual upload. */
     Curl_pgrsSetUploadSize(data, data->state.infilesize);
 
     /* set the SO_SNDBUF for the secondary socket for those who need it */
-    Curl_sndbufset(conn->sock[SECONDARYSOCKET]);
+    Curl_sndbuf_init(conn->sock[SECONDARYSOCKET]);
 
-    Curl_xfer_setup(data, -1, -1, FALSE, SECONDARYSOCKET);
+    Curl_xfer_setup2(data, CURL_XFER_SEND, -1, TRUE);
   }
   else {
     /* FTP download: */
-    Curl_xfer_setup(data, SECONDARYSOCKET,
-                    conn->proto.ftpc.retr_size_saved, FALSE, -1);
+    Curl_xfer_setup2(data, CURL_XFER_RECV,
+                     conn->proto.ftpc.retr_size_saved, TRUE);
   }
 
   conn->proto.ftpc.pp.pending_resp = TRUE; /* expect server response */
@@ -674,7 +673,7 @@ static CURLcode InitiateTransfer(struct Curl_easy *data)
  *
  * AllowServerConnect()
  *
- * When we've issue the PORT command, we have told the server to connect to
+ * When we have issue the PORT command, we have told the server to connect to
  * us. This function checks whether data connection is established if so it is
  * accepted.
  *
@@ -806,7 +805,7 @@ CURLcode Curl_GetFTPResponse(struct Curl_easy *data,
 {
   /*
    * We cannot read just one byte per read() and then go back to select() as
-   * the OpenSSL read() doesn't grok that properly.
+   * the OpenSSL read() does not grok that properly.
    *
    * Alas, read as much as possible, split up into lines, use the ending
    * line in a response or continue reading.  */
@@ -849,16 +848,16 @@ CURLcode Curl_GetFTPResponse(struct Curl_easy *data,
      *
      * A caution here is that the ftp_readresp() function has a cache that may
      * contain pieces of a response from the previous invoke and we need to
-     * make sure we don't just wait for input while there is unhandled data in
+     * make sure we do not just wait for input while there is unhandled data in
      * that cache. But also, if the cache is there, we call ftp_readresp() and
-     * the cache wasn't good enough to continue we must not just busy-loop
+     * the cache was not good enough to continue we must not just busy-loop
      * around this function.
      *
      */
 
     if(Curl_dyn_len(&pp->recvbuf) && (cache_skip < 2)) {
       /*
-       * There's a cache left since before. We then skipping the wait for
+       * There is a cache left since before. We then skipping the wait for
        * socket action, unless this is the same cache like the previous round
        * as then the cache was deemed not enough to act on and we then need to
        * wait for more data anyway.
@@ -895,7 +894,7 @@ CURLcode Curl_GetFTPResponse(struct Curl_easy *data,
 
     *nreadp += nread;
 
-  } /* while there's buffer left and loop is requested */
+  } /* while there is buffer left and loop is requested */
 
   pp->pending_resp = FALSE;
 
@@ -948,7 +947,7 @@ static int ftp_domore_getsock(struct Curl_easy *data,
   CURL_TRC_FTP(data, "[%s] ftp_domore_getsock()", FTP_DSTATE(data));
 
   if(FTP_STOP == ftpc->state) {
-    /* if stopped and still in this state, then we're also waiting for a
+    /* if stopped and still in this state, then we are also waiting for a
        connect on the secondary connection */
     DEBUGASSERT(conn->sock[SECONDARYSOCKET] != CURL_SOCKET_BAD ||
                (conn->cfilter[SECONDARYSOCKET] &&
@@ -1136,13 +1135,13 @@ static CURLcode ftp_state_use_port(struct Curl_easy *data,
 #endif
                         ipstr, hbuf, sizeof(hbuf))) {
         case IF2IP_NOT_FOUND:
-          /* not an interface, use the given string as host name instead */
+          /* not an interface, use the given string as hostname instead */
           host = ipstr;
           break;
         case IF2IP_AF_NOT_SUPPORTED:
           goto out;
         case IF2IP_FOUND:
-          host = hbuf; /* use the hbuf for host name */
+          host = hbuf; /* use the hbuf for hostname */
           break;
       }
     }
@@ -1153,7 +1152,7 @@ static CURLcode ftp_state_use_port(struct Curl_easy *data,
 
   if(!host) {
     const char *r;
-    /* not an interface and not a host name, get default by extracting
+    /* not an interface and not a hostname, get default by extracting
        the IP from the control connection */
     sslen = sizeof(ss);
     if(getsockname(conn->sock[FIRSTSOCKET], sa, &sslen)) {
@@ -1174,7 +1173,7 @@ static CURLcode ftp_state_use_port(struct Curl_easy *data,
     if(!r) {
       goto out;
     }
-    host = hbuf; /* use this host name */
+    host = hbuf; /* use this hostname */
     possibly_non_local = FALSE; /* we know it is local now */
   }
 
@@ -1232,7 +1231,7 @@ static CURLcode ftp_state_use_port(struct Curl_easy *data,
       /* It failed. */
       error = SOCKERRNO;
       if(possibly_non_local && (error == EADDRNOTAVAIL)) {
-        /* The requested bind address is not local.  Use the address used for
+        /* The requested bind address is not local. Use the address used for
          * the control connection instead and restart the port loop
          */
         infof(data, "bind(port=%hu) on non-local address failed: %s", port,
@@ -1245,7 +1244,7 @@ static CURLcode ftp_state_use_port(struct Curl_easy *data,
           goto out;
         }
         port = port_min;
-        possibly_non_local = FALSE; /* don't try this again */
+        possibly_non_local = FALSE; /* do not try this again */
         continue;
       }
       if(error != EADDRINUSE && error != EACCES) {
@@ -1355,7 +1354,7 @@ static CURLcode ftp_state_use_port(struct Curl_easy *data,
       char *dest = target;
 
       /* translate x.x.x.x to x,x,x,x */
-      while(source && *source) {
+      while(*source) {
         if(*source == '.')
           *dest = ',';
         else
@@ -1444,7 +1443,7 @@ static CURLcode ftp_state_prepare_transfer(struct Curl_easy *data)
   struct connectdata *conn = data->conn;
 
   if(ftp->transfer != PPTRANSFER_BODY) {
-    /* doesn't transfer any data */
+    /* does not transfer any data */
 
     /* still possibly do PRE QUOTE jobs */
     ftp_state(data, FTP_RETR_PREQUOTE);
@@ -1512,7 +1511,7 @@ static CURLcode ftp_state_size(struct Curl_easy *data,
   if((ftp->transfer == PPTRANSFER_INFO) && ftpc->file) {
     /* if a "head"-like request is being made (on a file) */
 
-    /* we know ftpc->file is a valid pointer to a file name */
+    /* we know ftpc->file is a valid pointer to a filename */
     result = Curl_pp_sendf(data, &ftpc->pp, "SIZE %s", ftpc->file);
     if(!result)
       ftp_state(data, FTP_SIZE);
@@ -1590,13 +1589,13 @@ static CURLcode ftp_state_list(struct Curl_easy *data)
 
 static CURLcode ftp_state_retr_prequote(struct Curl_easy *data)
 {
-  /* We've sent the TYPE, now we must send the list of prequote strings */
+  /* We have sent the TYPE, now we must send the list of prequote strings */
   return ftp_state_quote(data, TRUE, FTP_RETR_PREQUOTE);
 }
 
 static CURLcode ftp_state_stor_prequote(struct Curl_easy *data)
 {
-  /* We've sent the TYPE, now we must send the list of prequote strings */
+  /* We have sent the TYPE, now we must send the list of prequote strings */
   return ftp_state_quote(data, TRUE, FTP_STOR_PREQUOTE);
 }
 
@@ -1608,7 +1607,7 @@ static CURLcode ftp_state_type(struct Curl_easy *data)
   struct ftp_conn *ftpc = &conn->proto.ftpc;
 
   /* If we have selected NOBODY and HEADER, it means that we only want file
-     information. Which in FTP can't be much more than the file size and
+     information. Which in FTP cannot be much more than the file size and
      date. */
   if(data->req.no_body && ftpc->file &&
      ftp_need_type(conn, data->state.prefer_ascii)) {
@@ -1668,13 +1667,13 @@ static CURLcode ftp_state_ul_setup(struct Curl_easy *data,
 
   if((data->state.resume_from && !sizechecked) ||
      ((data->state.resume_from > 0) && sizechecked)) {
-    /* we're about to continue the uploading of a file */
+    /* we are about to continue the uploading of a file */
     /* 1. get already existing file's size. We use the SIZE command for this
        which may not exist in the server!  The SIZE command is not in
        RFC959. */
 
     /* 2. This used to set REST. But since we can do append, we
-       don't another ftp command. We just skip the source file
+       do not another ftp command. We just skip the source file
        offset and then we APPEND the rest on the file instead */
 
     /* 3. pass file-size number of bytes in the source file */
@@ -1707,7 +1706,7 @@ static CURLcode ftp_state_ul_setup(struct Curl_easy *data,
         failf(data, "Could not seek stream");
         return CURLE_FTP_COULDNT_USE_REST;
       }
-      /* seekerr == CURL_SEEKFUNC_CANTSEEK (can't seek to offset) */
+      /* seekerr == CURL_SEEKFUNC_CANTSEEK (cannot seek to offset) */
       do {
         char scratch[4*1024];
         size_t readthisamountnow =
@@ -1736,17 +1735,17 @@ static CURLcode ftp_state_ul_setup(struct Curl_easy *data,
         infof(data, "File already completely uploaded");
 
         /* no data to transfer */
-        Curl_xfer_setup(data, -1, -1, FALSE, -1);
+        Curl_xfer_setup_nop(data);
 
-        /* Set ->transfer so that we won't get any error in
-         * ftp_done() because we didn't transfer anything! */
+        /* Set ->transfer so that we will not get any error in
+         * ftp_done() because we did not transfer anything! */
         ftp->transfer = PPTRANSFER_NONE;
 
         ftp_state(data, FTP_STOP);
         return CURLE_OK;
       }
     }
-    /* we've passed, proceed as normal */
+    /* we have passed, proceed as normal */
   } /* resume_from */
 
   result = Curl_pp_sendf(data, &ftpc->pp, append?"APPE %s":"STOR %s",
@@ -1835,16 +1834,16 @@ static CURLcode ftp_state_quote(struct Curl_easy *data,
         }
         else {
           if(data->set.ignorecl || data->state.prefer_ascii) {
-            /* 'ignorecl' is used to support download of growing files.  It
+            /* 'ignorecl' is used to support download of growing files. It
                prevents the state machine from requesting the file size from
-               the server.  With an unknown file size the download continues
+               the server. With an unknown file size the download continues
                until the server terminates it, otherwise the client stops if
-               the received byte count exceeds the reported file size.  Set
+               the received byte count exceeds the reported file size. Set
                option CURLOPT_IGNORE_CONTENT_LENGTH to 1 to enable this
                behavior.
 
                In addition: asking for the size for 'TYPE A' transfers is not
-               constructive since servers don't report the converted size. So
+               constructive since servers do not report the converted size. So
                skip it.
             */
             result = Curl_pp_sendf(data, &ftpc->pp, "RETR %s", ftpc->file);
@@ -1882,7 +1881,7 @@ static CURLcode ftp_epsv_disable(struct Curl_easy *data,
      && !(conn->bits.tunnel_proxy || conn->bits.socksproxy)
 #endif
     ) {
-    /* We can't disable EPSV when doing IPv6, so this is instead a fail */
+    /* We cannot disable EPSV when doing IPv6, so this is instead a fail */
     failf(data, "Failed EPSV attempt, exiting");
     return CURLE_WEIRD_SERVER_REPLY;
   }
@@ -1907,7 +1906,7 @@ static CURLcode ftp_epsv_disable(struct Curl_easy *data,
 static char *control_address(struct connectdata *conn)
 {
   /* Returns the control connection IP address.
-     If a proxy tunnel is used, returns the original host name instead, because
+     If a proxy tunnel is used, returns the original hostname instead, because
      the effective control connection address is the proxy address,
      not the ftp host. */
 #ifndef CURL_DISABLE_PROXY
@@ -2046,7 +2045,7 @@ static CURLcode ftp_state_pasv_resp(struct Curl_easy *data,
   if(conn->bits.proxy) {
     /*
      * This connection uses a proxy and we need to connect to the proxy again
-     * here. We don't want to rely on a former host lookup that might've
+     * here. We do not want to rely on a former host lookup that might've
      * expired now, instead we remake the lookup here and now!
      */
     const char * const host_name = conn->bits.socksproxy ?
@@ -2061,7 +2060,7 @@ static CURLcode ftp_state_pasv_resp(struct Curl_easy *data,
     connectport = (unsigned short)conn->primary.remote_port;
 
     if(!addr) {
-      failf(data, "Can't resolve proxy host %s:%hu", host_name, connectport);
+      failf(data, "cannot resolve proxy host %s:%hu", host_name, connectport);
       return CURLE_COULDNT_RESOLVE_PROXY;
     }
   }
@@ -2088,7 +2087,8 @@ static CURLcode ftp_state_pasv_resp(struct Curl_easy *data,
     connectport = ftpc->newport; /* we connect to the remote port */
 
     if(!addr) {
-      failf(data, "Can't resolve new host %s:%hu", ftpc->newhost, connectport);
+      failf(data, "cannot resolve new host %s:%hu",
+            ftpc->newhost, connectport);
       return CURLE_FTP_CANT_GET_HOST;
     }
   }
@@ -2098,7 +2098,7 @@ static CURLcode ftp_state_pasv_resp(struct Curl_easy *data,
                            CURL_CF_SSL_ENABLE : CURL_CF_SSL_DISABLE);
 
   if(result) {
-    Curl_resolv_unlock(data, addr); /* we're done using this address */
+    Curl_resolv_unlock(data, addr); /* we are done using this address */
     if(ftpc->count1 == 0 && ftpcode == 229)
       return ftp_epsv_disable(data, conn);
 
@@ -2116,7 +2116,7 @@ static CURLcode ftp_state_pasv_resp(struct Curl_easy *data,
     /* this just dumps information about this second connection */
     ftp_pasv_verbose(data, addr->addr, ftpc->newhost, connectport);
 
-  Curl_resolv_unlock(data, addr); /* we're done using this address */
+  Curl_resolv_unlock(data, addr); /* we are done using this address */
 
   Curl_safefree(conn->secondaryhostname);
   conn->secondary_port = ftpc->newport;
@@ -2204,7 +2204,7 @@ static CURLcode client_write_header(struct Curl_easy *data,
    * call to Curl_client_write() so it does the right thing.
    *
    * Notice that we cannot enable this flag for FTP in general,
-   * as an FTP transfer might involve a HTTP proxy connection and
+   * as an FTP transfer might involve an HTTP proxy connection and
    * headers from CONNECT should not automatically be part of the
    * output. */
   CURLcode result;
@@ -2371,17 +2371,17 @@ static CURLcode ftp_state_retr(struct Curl_easy *data,
     /* We always (attempt to) get the size of downloads, so it is done before
        this even when not doing resumes. */
     if(filesize == -1) {
-      infof(data, "ftp server doesn't support SIZE");
-      /* We couldn't get the size and therefore we can't know if there really
+      infof(data, "ftp server does not support SIZE");
+      /* We could not get the size and therefore we cannot know if there really
          is a part of the file left to get, although the server will just
-         close the connection when we start the connection so it won't cause
+         close the connection when we start the connection so it will not cause
          us any harm, just not make us exit as nicely. */
     }
     else {
       /* We got a file size report, so we check that there actually is a
          part of the file left to get, or else we go home.  */
       if(data->state.resume_from< 0) {
-        /* We're supposed to download the last abs(from) bytes */
+        /* We are supposed to download the last abs(from) bytes */
         if(filesize < -data->state.resume_from) {
           failf(data, "Offset (%" CURL_FORMAT_CURL_OFF_T
                 ") was beyond file size (%" CURL_FORMAT_CURL_OFF_T ")",
@@ -2407,11 +2407,11 @@ static CURLcode ftp_state_retr(struct Curl_easy *data,
 
     if(ftp->downloadsize == 0) {
       /* no data to transfer */
-      Curl_xfer_setup(data, -1, -1, FALSE, -1);
+      Curl_xfer_setup_nop(data);
       infof(data, "File already completely downloaded");
 
-      /* Set ->transfer so that we won't get any error in ftp_done()
-       * because we didn't transfer the any file */
+      /* Set ->transfer so that we will not get any error in ftp_done()
+       * because we did not transfer the any file */
       ftp->transfer = PPTRANSFER_NONE;
       ftp_state(data, FTP_STOP);
       return CURLE_OK;
@@ -2619,7 +2619,7 @@ static CURLcode ftp_state_get_resp(struct Curl_easy *data,
        !data->set.ignorecl &&
        (ftp->downloadsize < 1)) {
       /*
-       * It seems directory listings either don't show the size or very
+       * It seems directory listings either do not show the size or very
        * often uses size 0 anyway. ASCII transfers may very well turn out
        * that the transferred amount of data is not the same as this line
        * tells, why using this number in those cases only confuses us.
@@ -2690,7 +2690,7 @@ static CURLcode ftp_state_get_resp(struct Curl_easy *data,
   else {
     if((instate == FTP_LIST) && (ftpcode == 450)) {
       /* simply no matching files in the dir listing */
-      ftp->transfer = PPTRANSFER_NONE; /* don't download anything */
+      ftp->transfer = PPTRANSFER_NONE; /* do not download anything */
       ftp_state(data, FTP_STOP); /* this phase is over */
     }
     else {
@@ -2777,7 +2777,7 @@ static CURLcode ftp_state_user_resp(struct Curl_easy *data,
 
     if(data->set.str[STRING_FTP_ALTERNATIVE_TO_USER] &&
        !ftpc->ftp_trying_alternative) {
-      /* Ok, USER failed.  Let's try the supplied command. */
+      /* Ok, USER failed. Let's try the supplied command. */
       result =
         Curl_pp_sendf(data, &ftpc->pp, "%s",
                       data->set.str[STRING_FTP_ALTERNATIVE_TO_USER]);
@@ -2863,7 +2863,7 @@ static CURLcode ftp_statemachine(struct Curl_easy *data,
 #endif
 
       if(data->set.use_ssl && !conn->bits.ftp_use_control_ssl) {
-        /* We don't have a SSL/TLS control connection yet, but FTPS is
+        /* We do not have a SSL/TLS control connection yet, but FTPS is
            requested. Try a FTPS connection now */
 
         ftpc->count3 = 0;
@@ -2880,7 +2880,7 @@ static CURLcode ftp_statemachine(struct Curl_easy *data,
         default:
           failf(data, "unsupported parameter to CURLOPT_FTPSSLAUTH: %d",
                 (int)data->set.ftpsslauth);
-          return CURLE_UNKNOWN_OPTION; /* we don't know what to do */
+          return CURLE_UNKNOWN_OPTION; /* we do not know what to do */
         }
         result = Curl_pp_sendf(data, &ftpc->pp, "AUTH %s",
                                ftpauth[ftpc->count1]);
@@ -2980,7 +2980,13 @@ static CURLcode ftp_statemachine(struct Curl_easy *data,
     case FTP_CCC:
       if(ftpcode < 500) {
         /* First shut down the SSL layer (note: this call will block) */
-        result = Curl_ssl_cfilter_remove(data, FIRSTSOCKET);
+        /* This has only been tested on the proftpd server, and the mod_tls
+         * code sends a close notify alert without waiting for a close notify
+         * alert in response. Thus we wait for a close notify alert from the
+         * server, but we do not send one. Let's hope other servers do
+         * the same... */
+        result = Curl_ssl_cfilter_remove(data, FIRSTSOCKET,
+          (data->set.ftp_ccc == CURLFTPSSL_CCC_ACTIVE));
 
         if(result)
           failf(data, "Failed to clear the command channel (CCC)");
@@ -3069,7 +3075,7 @@ static CURLcode ftp_statemachine(struct Curl_easy *data,
           data->state.most_recent_ftp_entrypath = ftpc->entrypath;
         }
         else {
-          /* couldn't get the path */
+          /* could not get the path */
           Curl_dyn_free(&out);
           infof(data, "Failed to figure out path");
         }
@@ -3168,7 +3174,7 @@ static CURLcode ftp_statemachine(struct Curl_easy *data,
         else {
           /* return failure */
           failf(data, "Server denied you to change to the given directory");
-          ftpc->cwdfail = TRUE; /* don't remember this path as we failed
+          ftpc->cwdfail = TRUE; /* do not remember this path as we failed
                                    to enter it */
           result = CURLE_REMOTE_ACCESS_DENIED;
         }
@@ -3373,7 +3379,7 @@ static CURLcode ftp_done(struct Curl_easy *data, CURLcode status,
   case CURLE_REMOTE_FILE_NOT_FOUND:
   case CURLE_WRITE_ERROR:
     /* the connection stays alive fine even though this happened */
-  case CURLE_OK: /* doesn't affect the control connection's status */
+  case CURLE_OK: /* does not affect the control connection's status */
     if(!premature)
       break;
 
@@ -3439,7 +3445,7 @@ static CURLcode ftp_done(struct Curl_easy *data, CURLcode status,
   /* free the dir tree and file parts */
   freedirs(ftpc);
 
-  /* shut down the socket to inform the server we're done */
+  /* shut down the socket to inform the server we are done */
 
 #ifdef _WIN32_WCE
   shutdown(conn->sock[SECONDARYSOCKET], 2);  /* SD_BOTH */
@@ -3457,7 +3463,7 @@ static CURLcode ftp_done(struct Curl_easy *data, CURLcode status,
       }
     }
 
-    close_secondarysocket(data, conn);
+    close_secondarysocket(data);
   }
 
   if(!result && (ftp->transfer == PPTRANSFER_BODY) && ftpc->ctl_valid &&
@@ -3533,9 +3539,9 @@ static CURLcode ftp_done(struct Curl_easy *data, CURLcode status,
     if((-1 != data->req.size) &&
        (data->req.size != data->req.bytecount) &&
 #ifdef CURL_DO_LINEEND_CONV
-       /* Most FTP servers don't adjust their file SIZE response for CRLFs, so
-        * we'll check to see if the discrepancy can be explained by the number
-        * of CRLFs we've changed to LFs.
+       /* Most FTP servers do not adjust their file SIZE response for CRLFs,
+        * so we will check to see if the discrepancy can be explained by the
+        * number of CRLFs we have changed to LFs.
         */
        ((data->req.size + data->state.crlf_conversions) !=
         data->req.bytecount) &&
@@ -3670,7 +3676,7 @@ static CURLcode ftp_nb_type(struct Curl_easy *data,
  * ftp_pasv_verbose()
  *
  * This function only outputs some informationals about this second connection
- * when we've issued a PASV command before and thus we have connected to a
+ * when we have issued a PASV command before and thus we have connected to a
  * possibly new IP address.
  *
  */
@@ -3711,7 +3717,7 @@ static CURLcode ftp_do_more(struct Curl_easy *data, int *completep)
    * complete */
   struct FTP *ftp = NULL;
 
-  /* if the second connection isn't done yet, wait for it to have
+  /* if the second connection is not done yet, wait for it to have
    * connected to the remote host. When using proxy tunneling, this
    * means the tunnel needs to have been establish. However, we
    * can not expect the remote host to talk to us in any way yet.
@@ -3739,20 +3745,20 @@ static CURLcode ftp_do_more(struct Curl_easy *data, int *completep)
 
     *completep = (int)complete;
 
-    /* if we got an error or if we don't wait for a data connection return
+    /* if we got an error or if we do not wait for a data connection return
        immediately */
     if(result || !ftpc->wait_data_conn)
       return result;
 
     /* if we reach the end of the FTP state machine here, *complete will be
        TRUE but so is ftpc->wait_data_conn, which says we need to wait for the
-       data connection and therefore we're not actually complete */
+       data connection and therefore we are not actually complete */
     *completep = 0;
   }
 
   if(ftp->transfer <= PPTRANSFER_INFO) {
-    /* a transfer is about to take place, or if not a file name was given
-       so we'll do a SIZE on it later and then we need the right TYPE first */
+    /* a transfer is about to take place, or if not a filename was given so we
+       will do a SIZE on it later and then we need the right TYPE first */
 
     if(ftpc->wait_data_conn) {
       bool serv_conned;
@@ -3791,7 +3797,7 @@ static CURLcode ftp_do_more(struct Curl_easy *data, int *completep)
       result = Curl_range(data);
 
       if(result == CURLE_OK && data->req.maxdownload >= 0) {
-        /* Don't check for successful transfer */
+        /* Do not check for successful transfer */
         ftpc->dont_check = TRUE;
       }
 
@@ -3824,7 +3830,7 @@ static CURLcode ftp_do_more(struct Curl_easy *data, int *completep)
   }
 
   /* no data to transfer */
-  Curl_xfer_setup(data, -1, -1, FALSE, -1);
+  Curl_xfer_setup_nop(data);
 
   if(!ftpc->wait_data_conn) {
     /* no waiting for the data connection so this is now complete */
@@ -3955,7 +3961,7 @@ static CURLcode init_wc_data(struct Curl_easy *data)
   if(data->set.ftp_filemethod == FTPFILE_NOCWD)
     data->set.ftp_filemethod = FTPFILE_MULTICWD;
 
-  /* try to parse ftp url */
+  /* try to parse ftp URL */
   result = ftp_parse_url_path(data);
   if(result) {
     goto fail;
@@ -4073,7 +4079,7 @@ static CURLcode wc_statemach(struct Curl_easy *data)
       if(result)
         return result;
 
-      /* we don't need the Curl_fileinfo of first file anymore */
+      /* we do not need the Curl_fileinfo of first file anymore */
       Curl_llist_remove(&wildcard->filelist, wildcard->filelist.head, NULL);
 
       if(wildcard->filelist.size == 0) { /* remains only one file to down. */
@@ -4228,7 +4234,7 @@ static CURLcode ftp_disconnect(struct Curl_easy *data,
      bad in any way, sending quit and waiting around here will make the
      disconnect wait in vain and cause more problems than we need to.
 
-     ftp_quit() will check the state of ftp->ctl_valid. If it's ok it
+     ftp_quit() will check the state of ftp->ctl_valid. If it is ok it
      will try to send the QUIT command, otherwise it will just return.
   */
   if(dead_connection)
@@ -4323,10 +4329,10 @@ CURLcode ftp_parse_url_path(struct Curl_easy *data)
         }
 
         ftpc->dirdepth = 1; /* we consider it to be a single dir */
-        fileName = slashPos + 1; /* rest is file name */
+        fileName = slashPos + 1; /* rest is filename */
       }
       else
-        fileName = rawPath; /* file name only (or empty) */
+        fileName = rawPath; /* filename only (or empty) */
       break;
 
     default: /* allow pretty much anything */
@@ -4357,7 +4363,7 @@ CURLcode ftp_parse_url_path(struct Curl_easy *data)
             ++compLen;
 
           /* we skip empty path components, like "x//y" since the FTP command
-             CWD requires a parameter and a non-existent parameter a) doesn't
+             CWD requires a parameter and a non-existent parameter a) does not
              work on many servers and b) has no effect on the others. */
           if(compLen > 0) {
             char *comp = Curl_memdup0(curPos, compLen);
@@ -4371,7 +4377,7 @@ CURLcode ftp_parse_url_path(struct Curl_easy *data)
         }
       }
       DEBUGASSERT((size_t)ftpc->dirdepth <= dirAlloc);
-      fileName = curPos; /* the rest is the file name (or empty) */
+      fileName = curPos; /* the rest is the filename (or empty) */
     }
     break;
   } /* switch */
@@ -4383,8 +4389,8 @@ CURLcode ftp_parse_url_path(struct Curl_easy *data)
                             we make it a NULL pointer */
 
   if(data->state.upload && !ftpc->file && (ftp->transfer == PPTRANSFER_BODY)) {
-    /* We need a file name when uploading. Return error! */
-    failf(data, "Uploading to a URL without a file name");
+    /* We need a filename when uploading. Return error! */
+    failf(data, "Uploading to a URL without a filename");
     free(rawPath);
     return CURLE_URL_MALFORMAT;
   }
@@ -4425,16 +4431,16 @@ static CURLcode ftp_dophase_done(struct Curl_easy *data, bool connected)
     CURLcode result = ftp_do_more(data, &completed);
 
     if(result) {
-      close_secondarysocket(data, conn);
+      close_secondarysocket(data);
       return result;
     }
   }
 
   if(ftp->transfer != PPTRANSFER_BODY)
     /* no data to transfer */
-    Curl_xfer_setup(data, -1, -1, FALSE, -1);
+    Curl_xfer_setup_nop(data);
   else if(!connected)
-    /* since we didn't connect now, we want do_more to get called */
+    /* since we did not connect now, we want do_more to get called */
     conn->bits.do_more = TRUE;
 
   ftpc->ctl_valid = TRUE; /* seems good */
@@ -4539,10 +4545,10 @@ static CURLcode ftp_setup_connection(struct Curl_easy *data,
   }
   data->req.p.ftp = ftp;
 
-  ftp->path = &data->state.up.path[1]; /* don't include the initial slash */
+  ftp->path = &data->state.up.path[1]; /* do not include the initial slash */
 
   /* FTP URLs support an extension like ";type=<typecode>" that
-   * we'll try to get now! */
+   * we will try to get now! */
   type = strstr(ftp->path, ";type=");
 
   if(!type)
diff --git a/lib/ftp.h b/lib/ftp.h
index 977fc883b..3d0af0158 100644
--- a/lib/ftp.h
+++ b/lib/ftp.h
@@ -61,7 +61,7 @@ enum {
   FTP_STOR_PREQUOTE,
   FTP_POSTQUOTE,
   FTP_CWD,  /* change dir */
-  FTP_MKD,  /* if the dir didn't exist */
+  FTP_MKD,  /* if the dir did not exist */
   FTP_MDTM, /* to figure out the datestamp */
   FTP_TYPE, /* to set type when doing a head-like request */
   FTP_LIST_TYPE, /* set type when about to do a dir list */
@@ -123,7 +123,7 @@ struct ftp_conn {
   char *account;
   char *alternative_to_user;
   char *entrypath; /* the PWD reply when we logged on */
-  char *file;    /* url-decoded file name (or path) */
+  char *file;    /* url-decoded filename (or path) */
   char **dirs;   /* realloc()ed array for path components */
   char *newhost;
   char *prevpath;   /* url-decoded conn->path from the previous transfer */
@@ -139,7 +139,7 @@ struct ftp_conn {
   int count1; /* general purpose counter for the state machine */
   int count2; /* general purpose counter for the state machine */
   int count3; /* general purpose counter for the state machine */
-  /* newhost is the (allocated) IP addr or host name to connect the data
+  /* newhost is the (allocated) IP addr or hostname to connect the data
      connection to */
   unsigned short newport;
   ftpstate state; /* always use ftp.c:state() to change state! */
diff --git a/lib/getenv.c b/lib/getenv.c
index 48ee97228..49a2e50fa 100644
--- a/lib/getenv.c
+++ b/lib/getenv.c
@@ -37,7 +37,7 @@ static char *GetEnv(const char *variable)
   return NULL;
 #elif defined(_WIN32)
   /* This uses Windows API instead of C runtime getenv() to get the environment
-     variable since some changes aren't always visible to the latter. #4774 */
+     variable since some changes are not always visible to the latter. #4774 */
   char *buf = NULL;
   char *tmp;
   DWORD bufsize;
@@ -54,8 +54,8 @@ static char *GetEnv(const char *variable)
     buf = tmp;
     bufsize = rc;
 
-    /* It's possible for rc to be 0 if the variable was found but empty.
-       Since getenv doesn't make that distinction we ignore it as well. */
+    /* it is possible for rc to be 0 if the variable was found but empty.
+       Since getenv does not make that distinction we ignore it as well. */
     rc = GetEnvironmentVariableA(variable, buf, bufsize);
     if(!rc || rc == bufsize || rc > max) {
       free(buf);
diff --git a/lib/getinfo.c b/lib/getinfo.c
index e423f0b29..9ca02889c 100644
--- a/lib/getinfo.c
+++ b/lib/getinfo.c
@@ -204,7 +204,7 @@ static CURLcode getinfo_long(struct Curl_easy *data, CURLINFO info,
 #ifdef DEBUGBUILD
   char *timestr = getenv("CURL_TIME");
   if(timestr) {
-    unsigned long val = strtol(timestr, NULL, 10);
+    unsigned long val = strtoul(timestr, NULL, 10);
     switch(info) {
     case CURLINFO_LOCAL_PORT:
       *param_longp = (long)val;
@@ -216,7 +216,7 @@ static CURLcode getinfo_long(struct Curl_easy *data, CURLINFO info,
   /* use another variable for this to allow different values */
   timestr = getenv("CURL_DEBUG_SIZE");
   if(timestr) {
-    unsigned long val = strtol(timestr, NULL, 10);
+    unsigned long val = strtoul(timestr, NULL, 10);
     switch(info) {
     case CURLINFO_HEADER_SIZE:
     case CURLINFO_REQUEST_SIZE:
@@ -277,8 +277,8 @@ static CURLcode getinfo_long(struct Curl_easy *data, CURLINFO info,
   case CURLINFO_LASTSOCKET:
     sockfd = Curl_getconnectinfo(data, NULL);
 
-    /* note: this is not a good conversion for systems with 64 bit sockets and
-       32 bit longs */
+    /* note: this is not a good conversion for systems with 64-bit sockets and
+       32-bit longs */
     if(sockfd != CURL_SOCKET_BAD)
       *param_longp = (long)sockfd;
     else
@@ -335,7 +335,7 @@ static CURLcode getinfo_long(struct Curl_easy *data, CURLINFO info,
     }
     break;
   case CURLINFO_PROTOCOL:
-    *param_longp = data->info.conn_protocol;
+    *param_longp = (long)data->info.conn_protocol;
     break;
   case CURLINFO_USED_PROXY:
     *param_longp =
@@ -361,7 +361,7 @@ static CURLcode getinfo_offt(struct Curl_easy *data, CURLINFO info,
 #ifdef DEBUGBUILD
   char *timestr = getenv("CURL_TIME");
   if(timestr) {
-    unsigned long val = strtol(timestr, NULL, 10);
+    unsigned long val = strtoul(timestr, NULL, 10);
     switch(info) {
     case CURLINFO_TOTAL_TIME_T:
     case CURLINFO_NAMELOOKUP_TIME_T:
@@ -450,7 +450,7 @@ static CURLcode getinfo_double(struct Curl_easy *data, CURLINFO info,
 #ifdef DEBUGBUILD
   char *timestr = getenv("CURL_TIME");
   if(timestr) {
-    unsigned long val = strtol(timestr, NULL, 10);
+    unsigned long val = strtoul(timestr, NULL, 10);
     switch(info) {
     case CURLINFO_TOTAL_TIME:
     case CURLINFO_NAMELOOKUP_TIME:
diff --git a/lib/gopher.c b/lib/gopher.c
index 311bd3798..ecea32633 100644
--- a/lib/gopher.c
+++ b/lib/gopher.c
@@ -209,9 +209,9 @@ static CURLcode gopher_do(struct Curl_easy *data, bool *done)
     if(!timeout_ms)
       timeout_ms = TIMEDIFF_T_MAX;
 
-    /* Don't busyloop. The entire loop thing is a work-around as it causes a
+    /* Do not busyloop. The entire loop thing is a work-around as it causes a
        BLOCKING behavior which is a NO-NO. This function should rather be
-       split up in a do and a doing piece where the pieces that aren't
+       split up in a do and a doing piece where the pieces that are not
        possible to send now will be sent in the doing function repeatedly
        until the entire request is sent.
     */
@@ -238,7 +238,7 @@ static CURLcode gopher_do(struct Curl_easy *data, bool *done)
   if(result)
     return result;
 
-  Curl_xfer_setup(data, FIRSTSOCKET, -1, FALSE, -1);
+  Curl_xfer_setup1(data, CURL_XFER_RECV, -1, FALSE);
   return CURLE_OK;
 }
 #endif /* CURL_DISABLE_GOPHER */
diff --git a/lib/hash.c b/lib/hash.c
index ddbae4d3e..df8e2abff 100644
--- a/lib/hash.c
+++ b/lib/hash.c
@@ -40,7 +40,10 @@ hash_element_dtor(void *user, void *element)
   struct Curl_hash_element *e = (struct Curl_hash_element *) element;
 
   if(e->ptr) {
-    h->dtor(e->ptr);
+    if(e->dtor)
+      e->dtor(e->key, e->key_len, e->ptr);
+    else
+      h->dtor(e->ptr);
     e->ptr = NULL;
   }
 
@@ -77,7 +80,8 @@ Curl_hash_init(struct Curl_hash *h,
 }
 
 static struct Curl_hash_element *
-mk_hash_element(const void *key, size_t key_len, const void *p)
+mk_hash_element(const void *key, size_t key_len, const void *p,
+                Curl_hash_elem_dtor dtor)
 {
   /* allocate the struct plus memory after it to store the key */
   struct Curl_hash_element *he = malloc(sizeof(struct Curl_hash_element) +
@@ -87,22 +91,15 @@ mk_hash_element(const void *key, size_t key_len, const void *p)
     memcpy(he->key, key, key_len);
     he->key_len = key_len;
     he->ptr = (void *) p;
+    he->dtor = dtor;
   }
   return he;
 }
 
 #define FETCH_LIST(x,y,z) &x->table[x->hash_func(y, z, x->slots)]
 
-/* Insert the data in the hash. If there already was a match in the hash, that
- * data is replaced. This function also "lazily" allocates the table if
- * needed, as it isn't done in the _init function (anymore).
- *
- * @unittest: 1305
- * @unittest: 1602
- * @unittest: 1603
- */
-void *
-Curl_hash_add(struct Curl_hash *h, void *key, size_t key_len, void *p)
+void *Curl_hash_add2(struct Curl_hash *h, void *key, size_t key_len, void *p,
+                     Curl_hash_elem_dtor dtor)
 {
   struct Curl_hash_element  *he;
   struct Curl_llist_element *le;
@@ -130,7 +127,7 @@ Curl_hash_add(struct Curl_hash *h, void *key, size_t key_len, void *p)
     }
   }
 
-  he = mk_hash_element(key, key_len, p);
+  he = mk_hash_element(key, key_len, p, dtor);
   if(he) {
     Curl_llist_append(l, he, &he->list);
     ++h->size;
@@ -140,6 +137,20 @@ Curl_hash_add(struct Curl_hash *h, void *key, size_t key_len, void *p)
   return NULL; /* failure */
 }
 
+/* Insert the data in the hash. If there already was a match in the hash, that
+ * data is replaced. This function also "lazily" allocates the table if
+ * needed, as it is not done in the _init function (anymore).
+ *
+ * @unittest: 1305
+ * @unittest: 1602
+ * @unittest: 1603
+ */
+void *
+Curl_hash_add(struct Curl_hash *h, void *key, size_t key_len, void *p)
+{
+  return Curl_hash_add2(h, key, key_len, p, NULL);
+}
+
 /* Remove the identified hash entry.
  * Returns non-zero on failure.
  *
@@ -259,8 +270,9 @@ size_t Curl_hash_str(void *key, size_t key_length, size_t slots_num)
   size_t h = 5381;
 
   while(key_str < end) {
+    size_t j = (size_t)*key_str++;
     h += h << 5;
-    h ^= *key_str++;
+    h ^= j;
   }
 
   return (h % slots_num);
diff --git a/lib/hash.h b/lib/hash.h
index 2bdc24717..1cf787525 100644
--- a/lib/hash.h
+++ b/lib/hash.h
@@ -58,9 +58,12 @@ struct Curl_hash {
   size_t size;
 };
 
+typedef void (*Curl_hash_elem_dtor)(void *key, size_t key_len, void *p);
+
 struct Curl_hash_element {
   struct Curl_llist_element list;
   void   *ptr;
+  Curl_hash_elem_dtor dtor;
   size_t key_len;
   char   key[1]; /* allocated memory following the struct */
 };
@@ -78,6 +81,8 @@ void Curl_hash_init(struct Curl_hash *h,
                     Curl_hash_dtor dtor);
 
 void *Curl_hash_add(struct Curl_hash *h, void *key, size_t key_len, void *p);
+void *Curl_hash_add2(struct Curl_hash *h, void *key, size_t key_len, void *p,
+                     Curl_hash_elem_dtor dtor);
 int Curl_hash_delete(struct Curl_hash *h, void *key, size_t key_len);
 void *Curl_hash_pick(struct Curl_hash *, void *key, size_t key_len);
 #define Curl_hash_count(h) ((h)->size)
diff --git a/lib/headers.c b/lib/headers.c
index 9a5692e54..59ac42225 100644
--- a/lib/headers.c
+++ b/lib/headers.c
@@ -54,7 +54,7 @@ static void copy_header_external(struct Curl_header_store *hs,
      impossible for applications to do == comparisons, as that would otherwise
      be very tempting and then lead to the reserved bits not being reserved
      anymore. */
-  h->origin = hs->type | (1<<27);
+  h->origin = (unsigned int)(hs->type | (1<<27));
   h->anchor = e;
 }
 
@@ -114,7 +114,7 @@ CURLHcode curl_easy_header(CURL *easy,
         break;
       }
     }
-    if(!e) /* this shouldn't happen */
+    if(!e) /* this should not happen */
       return CURLHE_MISSING;
   }
   /* this is the name we want */
@@ -302,7 +302,7 @@ CURLcode Curl_headers_push(struct Curl_easy *data, const char *header,
       /* line folding, append value to the previous header's value */
       return unfold_value(data, header, hlen);
     else {
-      /* Can't unfold without a previous header. Instead of erroring, just
+      /* cannot unfold without a previous header. Instead of erroring, just
          pass the leading blanks. */
       while(hlen && ISBLANK(*header)) {
         header++;
diff --git a/lib/hmac.c b/lib/hmac.c
index 4019b67f8..90f37f0bf 100644
--- a/lib/hmac.c
+++ b/lib/hmac.c
@@ -42,7 +42,7 @@
  * Generic HMAC algorithm.
  *
  *   This module computes HMAC digests based on any hash function. Parameters
- * and computing procedures are set-up dynamically at HMAC computation context
+ * and computing procedures are setup dynamically at HMAC computation context
  * initialization.
  */
 
diff --git a/lib/hostip.c b/lib/hostip.c
index 93c36e031..2c1f08e74 100644
--- a/lib/hostip.c
+++ b/lib/hostip.c
@@ -84,8 +84,8 @@
  * source file are these:
  *
  * CURLRES_IPV6 - this host has getaddrinfo() and family, and thus we use
- * that. The host may not be able to resolve IPv6, but we don't really have to
- * take that into account. Hosts that aren't IPv6-enabled have CURLRES_IPV4
+ * that. The host may not be able to resolve IPv6, but we do not really have to
+ * take that into account. Hosts that are not IPv6-enabled have CURLRES_IPV4
  * defined.
  *
  * CURLRES_ARES - is defined if libcurl is built to use c-ares for
@@ -238,7 +238,7 @@ void Curl_hostcache_prune(struct Curl_easy *data)
   int timeout = data->set.dns_cache_timeout;
 
   if(!data->dns.hostcache)
-    /* NULL hostcache means we can't do it */
+    /* NULL hostcache means we cannot do it */
     return;
 
   if(data->share)
@@ -283,14 +283,14 @@ static struct Curl_dns_entry *fetch_addr(struct Curl_easy *data,
   size_t entry_len = create_hostcache_id(hostname, 0, port,
                                          entry_id, sizeof(entry_id));
 
-  /* See if it's already in our dns cache */
+  /* See if it is already in our dns cache */
   dns = Curl_hash_pick(data->dns.hostcache, entry_id, entry_len + 1);
 
   /* No entry found in cache, check if we might have a wildcard entry */
   if(!dns && data->state.wildcard_resolve) {
     entry_len = create_hostcache_id("*", 1, port, entry_id, sizeof(entry_id));
 
-    /* See if it's already in our dns cache */
+    /* See if it is already in our dns cache */
     dns = Curl_hash_pick(data->dns.hostcache, entry_id, entry_len + 1);
   }
 
@@ -329,7 +329,7 @@ static struct Curl_dns_entry *fetch_addr(struct Curl_easy *data,
     }
 
     if(!found) {
-      infof(data, "Hostname in DNS cache doesn't have needed family, zapped");
+      infof(data, "Hostname in DNS cache does not have needed family, zapped");
       dns = NULL; /* the memory deallocation is being handled by the hash */
       Curl_hash_delete(data->dns.hostcache, entry_id, entry_len + 1);
     }
@@ -349,7 +349,7 @@ static struct Curl_dns_entry *fetch_addr(struct Curl_easy *data,
  * Returns the Curl_dns_entry entry pointer or NULL if not in the cache.
  *
  * The returned data *MUST* be "unlocked" with Curl_resolv_unlock() after
- * use, or we'll leak memory!
+ * use, or we will leak memory!
  */
 struct Curl_dns_entry *
 Curl_fetch_addr(struct Curl_easy *data,
@@ -428,8 +428,8 @@ UNITTEST CURLcode Curl_shuffle_addr(struct Curl_easy *data,
         if(Curl_rand(data, (unsigned char *)rnd, rnd_size) == CURLE_OK) {
           struct Curl_addrinfo *swap_tmp;
           for(i = num_addrs - 1; i > 0; i--) {
-            swap_tmp = nodes[rnd[i] % (i + 1)];
-            nodes[rnd[i] % (i + 1)] = nodes[i];
+            swap_tmp = nodes[rnd[i] % (unsigned int)(i + 1)];
+            nodes[rnd[i] % (unsigned int)(i + 1)] = nodes[i];
             nodes[i] = swap_tmp;
           }
 
@@ -536,8 +536,8 @@ static struct Curl_addrinfo *get_localhost6(int port, const char *name)
   sa6.sin6_port = htons(port16);
   sa6.sin6_flowinfo = 0;
   sa6.sin6_scope_id = 0;
-  if(Curl_inet_pton(AF_INET6, "::1", ipv6) < 1)
-    return NULL;
+
+  (void)Curl_inet_pton(AF_INET6, "::1", ipv6);
   memcpy(&sa6.sin6_addr, ipv6, sizeof(ipv6));
 
   ca->ai_flags     = 0;
@@ -602,7 +602,7 @@ static struct Curl_addrinfo *get_localhost(int port, const char *name)
 bool Curl_ipv6works(struct Curl_easy *data)
 {
   if(data) {
-    /* the nature of most system is that IPv6 status doesn't come and go
+    /* the nature of most system is that IPv6 status does not come and go
        during a program's lifetime so we only probe the first time and then we
        have the info kept for fast reuse */
     DEBUGASSERT(data);
@@ -618,7 +618,7 @@ bool Curl_ipv6works(struct Curl_easy *data)
     /* probe to see if we have a working IPv6 stack */
     curl_socket_t s = socket(PF_INET6, SOCK_DGRAM, 0);
     if(s == CURL_SOCKET_BAD)
-      /* an IPv6 address was requested but we can't get/use one */
+      /* an IPv6 address was requested but we cannot get/use one */
       ipv6_works = 0;
     else {
       ipv6_works = 1;
@@ -662,11 +662,11 @@ static bool tailmatch(const char *full, const char *part)
 /*
  * Curl_resolv() is the main name resolve function within libcurl. It resolves
  * a name and returns a pointer to the entry in the 'entry' argument (if one
- * is provided). This function might return immediately if we're using asynch
+ * is provided). This function might return immediately if we are using asynch
  * resolves. See the return codes.
  *
  * The cache entry we return will get its 'inuse' counter increased when this
- * function is used. You MUST call Curl_resolv_unlock() later (when you're
+ * function is used. You MUST call Curl_resolv_unlock() later (when you are
  * done using this struct) to decrease the counter again.
  *
  * Return codes:
@@ -813,7 +813,7 @@ enum resolve_t Curl_resolv(struct Curl_easy *data,
       if(respwait) {
         /* the response to our resolve call will come asynchronously at
            a later time, good or bad */
-        /* First, check that we haven't received the info by now */
+        /* First, check that we have not received the info by now */
         result = Curl_resolv_check(data, &dns);
         if(result) /* error detected */
           return CURLRESOLV_ERROR;
@@ -851,7 +851,7 @@ enum resolve_t Curl_resolv(struct Curl_easy *data,
 #ifdef USE_ALARM_TIMEOUT
 /*
  * This signal handler jumps back into the main libcurl code and continues
- * execution.  This effectively causes the remainder of the application to run
+ * execution. This effectively causes the remainder of the application to run
  * within a signal handler which is nonportable and could lead to problems.
  */
 CURL_NORETURN static
@@ -864,11 +864,11 @@ void alarmfunc(int sig)
 
 /*
  * Curl_resolv_timeout() is the same as Curl_resolv() but specifies a
- * timeout.  This function might return immediately if we're using asynch
+ * timeout. This function might return immediately if we are using asynch
  * resolves. See the return codes.
  *
  * The cache entry we return will get its 'inuse' counter increased when this
- * function is used. You MUST call Curl_resolv_unlock() later (when you're
+ * function is used. You MUST call Curl_resolv_unlock() later (when you are
  * done using this struct) to decrease the counter again.
  *
  * If built with a synchronous resolver and use of signals is not
@@ -934,7 +934,7 @@ enum resolve_t Curl_resolv_timeout(struct Curl_easy *data,
      will generate a signal and we will siglongjmp() from that here.
      This technique has problems (see alarmfunc).
      This should be the last thing we do before calling Curl_resolv(),
-     as otherwise we'd have to worry about variables that get modified
+     as otherwise we would have to worry about variables that get modified
      before we invoke Curl_resolv() (and thus use "volatile"). */
   curl_simple_lock_lock(&curl_jmpenv_lock);
 
@@ -955,7 +955,7 @@ enum resolve_t Curl_resolv_timeout(struct Curl_easy *data,
     keep_copysig = TRUE; /* yes, we have a copy */
     sigact.sa_handler = alarmfunc;
 #ifdef SA_RESTART
-    /* HPUX doesn't have SA_RESTART but defaults to that behavior! */
+    /* HPUX does not have SA_RESTART but defaults to that behavior! */
     sigact.sa_flags &= ~SA_RESTART;
 #endif
     /* now set the new struct */
@@ -1022,7 +1022,7 @@ clean_up:
        ((alarm_set >= 0x80000000) && (prev_alarm < 0x80000000)) ) {
       /* if the alarm time-left reached zero or turned "negative" (counted
          with unsigned values), we should fire off a SIGALRM here, but we
-         won't, and zero would be to switch it off so we never set it to
+         will not, and zero would be to switch it off so we never set it to
          less than 1! */
       alarm(1);
       rc = CURLRESOLV_TIMEDOUT;
@@ -1150,7 +1150,7 @@ CURLcode Curl_loadhostpairs(struct Curl_easy *data)
       if(data->share)
         Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);
 
-      /* delete entry, ignore if it didn't exist */
+      /* delete entry, ignore if it did not exist */
       Curl_hash_delete(data->dns.hostcache, entry_id, entry_len + 1);
 
       if(data->share)
@@ -1264,7 +1264,7 @@ err:
       if(data->share)
         Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);
 
-      /* See if it's already in our dns cache */
+      /* See if it is already in our dns cache */
       dns = Curl_hash_pick(data->dns.hostcache, entry_id, entry_len + 1);
 
       if(dns) {
@@ -1362,7 +1362,7 @@ static void show_resolve_info(struct Curl_easy *data,
       if(!result)
         result = Curl_dyn_add(d, buf);
       if(result) {
-        infof(data, "too many IP, can't show");
+        infof(data, "too many IP, cannot show");
         goto fail;
       }
     }
diff --git a/lib/hostip.h b/lib/hostip.h
index bf4e94d2f..c85a688db 100644
--- a/lib/hostip.h
+++ b/lib/hostip.h
@@ -80,7 +80,7 @@ struct Curl_https_rrinfo {
   char *alpns; /* keytag = 1 */
   bool no_def_alpn; /* keytag = 2 */
   /*
-   * we don't support ports (keytag = 3) as we don't support
+   * we do not support ports (keytag = 3) as we do not support
    * port-switching yet
    */
   unsigned char *ipv4hints; /* keytag = 4 */
@@ -97,7 +97,7 @@ struct Curl_dns_entry {
 #ifdef USE_HTTPSRR
   struct Curl_https_rrinfo *hinfo;
 #endif
-  /* timestamp == 0 -- permanent CURLOPT_RESOLVE entry (doesn't time out) */
+  /* timestamp == 0 -- permanent CURLOPT_RESOLVE entry (does not time out) */
   time_t timestamp;
   /* use-counter, use Curl_resolv_unlock to release reference */
   long inuse;
@@ -114,7 +114,7 @@ bool Curl_host_is_ipnum(const char *hostname);
  * and port.
  *
  * The returned data *MUST* be "unlocked" with Curl_resolv_unlock() after
- * use, or we'll leak memory!
+ * use, or we will leak memory!
  */
 /* return codes */
 enum resolve_t {
@@ -200,7 +200,7 @@ void Curl_printable_address(const struct Curl_addrinfo *ip,
  * Returns the Curl_dns_entry entry pointer or NULL if not in the cache.
  *
  * The returned data *MUST* be "unlocked" with Curl_resolv_unlock() after
- * use, or we'll leak memory!
+ * use, or we will leak memory!
  */
 struct Curl_dns_entry *
 Curl_fetch_addr(struct Curl_easy *data,
diff --git a/lib/hostip4.c b/lib/hostip4.c
index 9140180ff..8da809db6 100644
--- a/lib/hostip4.c
+++ b/lib/hostip4.c
@@ -62,7 +62,7 @@ bool Curl_ipvalid(struct Curl_easy *data, struct connectdata *conn)
 {
   (void)data;
   if(conn->ip_version == CURL_IPRESOLVE_V6)
-    /* An IPv6 address was requested and we can't get/use one */
+    /* An IPv6 address was requested and we cannot get/use one */
     return FALSE;
 
   return TRUE; /* OK, proceed */
@@ -193,8 +193,8 @@ struct Curl_addrinfo *Curl_ipv4_resolve_r(const char *hostname,
    * small. Previous versions are known to return ERANGE for the same
    * problem.
    *
-   * This wouldn't be such a big problem if older versions wouldn't
-   * sometimes return EAGAIN on a common failure case. Alas, we can't
+   * This would not be such a big problem if older versions would not
+   * sometimes return EAGAIN on a common failure case. Alas, we cannot
    * assume that EAGAIN *or* ERANGE means ERANGE for any given version of
    * glibc.
    *
@@ -210,9 +210,9 @@ struct Curl_addrinfo *Curl_ipv4_resolve_r(const char *hostname,
    * gethostbyname_r() in glibc:
    *
    * In glibc 2.2.5 the interface is different (this has also been
-   * discovered in glibc 2.1.1-6 as shipped by Redhat 6). What I can't
+   * discovered in glibc 2.1.1-6 as shipped by Redhat 6). What I cannot
    * explain, is that tests performed on glibc 2.2.4-34 and 2.2.4-32
-   * (shipped/upgraded by Redhat 7.2) don't show this behavior!
+   * (shipped/upgraded by Redhat 7.2) do not show this behavior!
    *
    * In this "buggy" version, the return code is -1 on error and 'errno'
    * is set to the ERANGE or EAGAIN code. Note that 'errno' is not a
@@ -223,7 +223,7 @@ struct Curl_addrinfo *Curl_ipv4_resolve_r(const char *hostname,
 #elif defined(HAVE_GETHOSTBYNAME_R_3)
   /* AIX, Digital Unix/Tru64, HPUX 10, more? */
 
-  /* For AIX 4.3 or later, we don't use gethostbyname_r() at all, because of
+  /* For AIX 4.3 or later, we do not use gethostbyname_r() at all, because of
    * the plain fact that it does not return unique full buffers on each
    * call, but instead several of the pointers in the hostent structs will
    * point to the same actual data! This have the unfortunate down-side that
@@ -237,7 +237,7 @@ struct Curl_addrinfo *Curl_ipv4_resolve_r(const char *hostname,
    *
    * Troels Walsted Hansen helped us work this out on March 3rd, 2003.
    *
-   * [*] = much later we've found out that it isn't at all "completely
+   * [*] = much later we have found out that it is not at all "completely
    * thread-safe", but at least the gethostbyname() function is.
    */
 
@@ -253,7 +253,7 @@ struct Curl_addrinfo *Curl_ipv4_resolve_r(const char *hostname,
                           (struct hostent *)buf,
                           (struct hostent_data *)((char *)buf +
                                                   sizeof(struct hostent)));
-    h_errnop = SOCKERRNO; /* we don't deal with this, but set it anyway */
+    h_errnop = SOCKERRNO; /* we do not deal with this, but set it anyway */
   }
   else
     res = -1; /* failure, too smallish buffer size */
@@ -263,8 +263,8 @@ struct Curl_addrinfo *Curl_ipv4_resolve_r(const char *hostname,
     h = buf; /* result expected in h */
 
     /* This is the worst kind of the different gethostbyname_r() interfaces.
-     * Since we don't know how big buffer this particular lookup required,
-     * we can't realloc down the huge alloc without doing closer analysis of
+     * Since we do not know how big buffer this particular lookup required,
+     * we cannot realloc down the huge alloc without doing closer analysis of
      * the returned data. Thus, we always use CURL_HOSTENT_SIZE for every
      * name lookup. Fixing this would require an extra malloc() and then
      * calling Curl_addrinfo_copy() that subsequent realloc()s down the new
@@ -280,7 +280,7 @@ struct Curl_addrinfo *Curl_ipv4_resolve_r(const char *hostname,
 #else /* (HAVE_GETADDRINFO && HAVE_GETADDRINFO_THREADSAFE) ||
           HAVE_GETHOSTBYNAME_R */
   /*
-   * Here is code for platforms that don't have a thread safe
+   * Here is code for platforms that do not have a thread safe
    * getaddrinfo() nor gethostbyname_r() function or for which
    * gethostbyname() is the preferred one.
    */
diff --git a/lib/hsts.c b/lib/hsts.c
index a5e767613..8cd77ae3c 100644
--- a/lib/hsts.c
+++ b/lib/hsts.c
@@ -54,7 +54,7 @@
 #define MAX_HSTS_DATELENSTR "64"
 #define UNLIMITED "unlimited"
 
-#ifdef DEBUGBUILD
+#if defined(DEBUGBUILD) || defined(UNITTESTS)
 /* to play well with debug builds, we can *set* a fixed time this will
    return */
 time_t deltatime; /* allow for "adjustments" for unit test purposes */
@@ -241,7 +241,7 @@ CURLcode Curl_hsts_parse(struct hsts *h, const char *hostname,
 }
 
 /*
- * Return TRUE if the given host name is currently an HSTS one.
+ * Return TRUE if the given hostname is currently an HSTS one.
  *
  * The 'subdomain' argument tells the function if subdomain matching should be
  * attempted.
@@ -368,7 +368,7 @@ CURLcode Curl_hsts_save(struct Curl_easy *data, struct hsts *h,
     file = h->filename;
 
   if((h->flags & CURLHSTS_READONLYFILE) || !file || !file[0])
-    /* marked as read-only, no file or zero length file name */
+    /* marked as read-only, no file or zero length filename */
     goto skipsave;
 
   result = Curl_fopen(data, file, &out, &tempstore);
@@ -393,7 +393,7 @@ CURLcode Curl_hsts_save(struct Curl_easy *data, struct hsts *h,
   free(tempstore);
 skipsave:
   if(data->set.hsts_write) {
-    /* if there's a write callback */
+    /* if there is a write callback */
     struct curl_index i; /* count */
     i.total = h->list.size;
     i.index = 0;
@@ -440,7 +440,7 @@ static CURLcode hsts_add(struct hsts *h, char *line)
     if(!e)
       result = hsts_create(h, p, subdomain, expires);
     else {
-      /* the same host name, use the largest expire time */
+      /* the same hostname, use the largest expire time */
       if(expires > e->expires)
         e->expires = expires;
     }
@@ -508,7 +508,7 @@ static CURLcode hsts_load(struct hsts *h, const char *file)
   CURLcode result = CURLE_OK;
   FILE *fp;
 
-  /* we need a private copy of the file name so that the hsts cache file
+  /* we need a private copy of the filename so that the hsts cache file
      name survives an easy handle reset */
   free(h->filename);
   h->filename = strdup(file);
diff --git a/lib/hsts.h b/lib/hsts.h
index d3431a5d7..21e53a342 100644
--- a/lib/hsts.h
+++ b/lib/hsts.h
@@ -29,7 +29,7 @@
 #include <curl/curl.h>
 #include "llist.h"
 
-#ifdef DEBUGBUILD
+#if defined(DEBUGBUILD) || defined(UNITTESTS)
 extern time_t deltatime;
 #endif
 
@@ -40,7 +40,7 @@ struct stsentry {
   curl_off_t expires; /* the timestamp of this entry's expiry */
 };
 
-/* The HSTS cache. Needs to be able to tailmatch host names. */
+/* The HSTS cache. Needs to be able to tailmatch hostnames. */
 struct hsts {
   struct Curl_llist list;
   char *filename;
diff --git a/lib/http.c b/lib/http.c
index 2a41f8078..cb379e7f9 100644
--- a/lib/http.c
+++ b/lib/http.c
@@ -169,14 +169,6 @@ CURLcode Curl_http_setup_conn(struct Curl_easy *data,
 {
   /* allocate the HTTP-specific struct for the Curl_easy, only to survive
      during this request */
-  struct HTTP *http;
-  DEBUGASSERT(data->req.p.http == NULL);
-
-  http = calloc(1, sizeof(struct HTTP));
-  if(!http)
-    return CURLE_OUT_OF_MEMORY;
-
-  data->req.p.http = http;
   connkeep(conn, "HTTP default");
 
   if(data->state.httpwant == CURL_HTTP_VERSION_3ONLY) {
@@ -418,9 +410,9 @@ static CURLcode http_perhapsrewind(struct Curl_easy *data,
   curl_off_t upload_remain = (expectsend >= 0)? (expectsend - bytessent) : -1;
   bool little_upload_remains = (upload_remain >= 0 && upload_remain < 2000);
   bool needs_rewind = Curl_creader_needs_rewind(data);
-  /* By default, we'd like to abort the transfer when little or
-   * unknown amount remains. But this may be overridden by authentications
-   * further below! */
+  /* By default, we would like to abort the transfer when little or unknown
+   * amount remains. This may be overridden by authentications further
+   * below! */
   bool abort_upload = (!data->req.upload_done && !little_upload_remains);
   const char *ongoing_auth = NULL;
 
@@ -483,7 +475,7 @@ static CURLcode http_perhapsrewind(struct Curl_easy *data,
     /* We decided to abort the ongoing transfer */
     streamclose(conn, "Mid-auth HTTP and much data left to send");
     /* FIXME: questionable manipulation here, can we do this differently? */
-    data->req.size = 0; /* don't download any more than 0 bytes */
+    data->req.size = 0; /* do not download any more than 0 bytes */
   }
   return CURLE_OK;
 }
@@ -556,7 +548,7 @@ CURLcode Curl_http_auth_act(struct Curl_easy *data)
     /* no (known) authentication available,
        authentication is not "done" yet and
        no authentication seems to be required and
-       we didn't try HEAD or GET */
+       we did not try HEAD or GET */
     if((data->state.httpreq != HTTPREQ_GET) &&
        (data->state.httpreq != HTTPREQ_HEAD)) {
       data->req.newurl = strdup(data->state.url); /* clone URL */
@@ -746,13 +738,13 @@ Curl_http_output_auth(struct Curl_easy *data,
   if(authhost->want && !authhost->picked)
     /* The app has selected one or more methods, but none has been picked
        so far by a server round-trip. Then we set the picked one to the
-       want one, and if this is one single bit it'll be used instantly. */
+       want one, and if this is one single bit it will be used instantly. */
     authhost->picked = authhost->want;
 
   if(authproxy->want && !authproxy->picked)
     /* The app has selected one or more methods, but none has been picked so
        far by a proxy round-trip. Then we set the picked one to the want one,
-       and if this is one single bit it'll be used instantly. */
+       and if this is one single bit it will be used instantly. */
     authproxy->picked = authproxy->want;
 
 #ifndef CURL_DISABLE_PROXY
@@ -767,7 +759,7 @@ Curl_http_output_auth(struct Curl_easy *data,
 #else
   (void)proxytunnel;
 #endif /* CURL_DISABLE_PROXY */
-    /* we have no proxy so let's pretend we're done authenticating
+    /* we have no proxy so let's pretend we are done authenticating
        with it */
     authproxy->done = TRUE;
 
@@ -941,7 +933,7 @@ CURLcode Curl_http_input_auth(struct Curl_easy *data, bool proxy,
             authp->avail |= CURLAUTH_DIGEST;
 
             /* We call this function on input Digest headers even if Digest
-             * authentication isn't activated yet, as we need to store the
+             * authentication is not activated yet, as we need to store the
              * incoming data from this header in case we are going to use
              * Digest */
             result = Curl_input_digest(data, proxy, auth);
@@ -960,7 +952,7 @@ CURLcode Curl_http_input_auth(struct Curl_easy *data, bool proxy,
             authp->avail |= CURLAUTH_BASIC;
             if(authp->picked == CURLAUTH_BASIC) {
               /* We asked for Basic authentication but got a 40X back
-                 anyway, which basically means our name+password isn't
+                 anyway, which basically means our name+password is not
                  valid. */
               authp->avail = CURLAUTH_NONE;
               infof(data, "Authentication problem. Ignoring this.");
@@ -976,7 +968,7 @@ CURLcode Curl_http_input_auth(struct Curl_easy *data, bool proxy,
               authp->avail |= CURLAUTH_BEARER;
               if(authp->picked == CURLAUTH_BEARER) {
                 /* We asked for Bearer authentication but got a 40X back
-                  anyway, which basically means our token isn't valid. */
+                  anyway, which basically means our token is not valid. */
                 authp->avail = CURLAUTH_NONE;
                 infof(data, "Authentication problem. Ignoring this.");
                 data->state.authproblem = TRUE;
@@ -996,7 +988,7 @@ CURLcode Curl_http_input_auth(struct Curl_easy *data, bool proxy,
     /* there may be multiple methods on one line, so keep reading */
     while(*auth && *auth != ',') /* read up to the next comma */
       auth++;
-    if(*auth == ',') /* if we're on a comma, skip it */
+    if(*auth == ',') /* if we are on a comma, skip it */
       auth++;
     while(*auth && ISSPACE(*auth))
       auth++;
@@ -1019,8 +1011,8 @@ static bool http_should_fail(struct Curl_easy *data, int httpcode)
   DEBUGASSERT(data->conn);
 
   /*
-  ** If we haven't been asked to fail on error,
-  ** don't fail.
+  ** If we have not been asked to fail on error,
+  ** do not fail.
   */
   if(!data->set.http_fail_on_error)
     return FALSE;
@@ -1040,7 +1032,7 @@ static bool http_should_fail(struct Curl_easy *data, int httpcode)
     return FALSE;
 
   /*
-  ** Any code >= 400 that's not 401 or 407 is always
+  ** Any code >= 400 that is not 401 or 407 is always
   ** a terminal error
   */
   if((httpcode != 401) && (httpcode != 407))
@@ -1052,22 +1044,19 @@ static bool http_should_fail(struct Curl_easy *data, int httpcode)
   DEBUGASSERT((httpcode == 401) || (httpcode == 407));
 
   /*
-  ** Examine the current authentication state to see if this
-  ** is an error.  The idea is for this function to get
-  ** called after processing all the headers in a response
-  ** message.  So, if we've been to asked to authenticate a
-  ** particular stage, and we've done it, we're OK.  But, if
-  ** we're already completely authenticated, it's not OK to
-  ** get another 401 or 407.
+  ** Examine the current authentication state to see if this is an error. The
+  ** idea is for this function to get called after processing all the headers
+  ** in a response message. So, if we have been to asked to authenticate a
+  ** particular stage, and we have done it, we are OK. If we are already
+  ** completely authenticated, it is not OK to get another 401 or 407.
   **
-  ** It is possible for authentication to go stale such that
-  ** the client needs to reauthenticate.  Once that info is
-  ** available, use it here.
+  ** It is possible for authentication to go stale such that the client needs
+  ** to reauthenticate. Once that info is available, use it here.
   */
 
   /*
-  ** Either we're not authenticating, or we're supposed to
-  ** be authenticating something else.  This is an error.
+  ** Either we are not authenticating, or we are supposed to be authenticating
+  ** something else. This is an error.
   */
   if((httpcode == 401) && !data->state.aptr.user)
     return TRUE;
@@ -1106,7 +1095,7 @@ Curl_compareheader(const char *headerline, /* line to check */
   DEBUGASSERT(content);
 
   if(!strncasecompare(headerline, header, hlen))
-    return FALSE; /* doesn't start with header */
+    return FALSE; /* does not start with header */
 
   /* pass the header */
   start = &headerline[hlen];
@@ -1118,11 +1107,11 @@ Curl_compareheader(const char *headerline, /* line to check */
   /* find the end of the header line */
   end = strchr(start, '\r'); /* lines end with CRLF */
   if(!end) {
-    /* in case there's a non-standard compliant line here */
+    /* in case there is a non-standard compliant line here */
     end = strchr(start, '\n');
 
     if(!end)
-      /* hm, there's no line ending here, use the zero byte! */
+      /* hm, there is no line ending here, use the zero byte! */
       end = strchr(start, '\0');
   }
 
@@ -1153,7 +1142,7 @@ CURLcode Curl_http_connect(struct Curl_easy *data, bool *done)
 }
 
 /* this returns the socket to wait for in the DO and DOING state for the multi
-   interface and then we're always _sending_ a request and thus we wait for
+   interface and then we are always _sending_ a request and thus we wait for
    the single socket to become writable only */
 int Curl_http_getsock_do(struct Curl_easy *data,
                          struct connectdata *conn,
@@ -1174,16 +1163,12 @@ CURLcode Curl_http_done(struct Curl_easy *data,
                         CURLcode status, bool premature)
 {
   struct connectdata *conn = data->conn;
-  struct HTTP *http = data->req.p.http;
 
-  /* Clear multipass flag. If authentication isn't done yet, then it will get
+  /* Clear multipass flag. If authentication is not done yet, then it will get
    * a chance to be set back to true when we output the next auth header */
   data->state.authhost.multipass = FALSE;
   data->state.authproxy.multipass = FALSE;
 
-  if(!http)
-    return CURLE_OK;
-
   Curl_dyn_reset(&data->state.headerb);
   Curl_hyper_done(data);
 
@@ -1197,8 +1182,8 @@ CURLcode Curl_http_done(struct Curl_easy *data,
      (data->req.bytecount +
       data->req.headerbytecount -
       data->req.deductheadercount) <= 0) {
-    /* If this connection isn't simply closed to be retried, AND nothing was
-       read from the HTTP server (that counts), this can't be right so we
+    /* If this connection is not simply closed to be retried, AND nothing was
+       read from the HTTP server (that counts), this cannot be right so we
        return an error here */
     failf(data, "Empty reply from server");
     /* Mark it as closed to avoid the "left intact" message */
@@ -1357,7 +1342,7 @@ CURLcode Curl_dynhds_add_custom(struct Curl_easy *data,
 
       DEBUGASSERT(name && value);
       if(data->state.aptr.host &&
-         /* a Host: header was sent already, don't pass on any custom Host:
+         /* a Host: header was sent already, do not pass on any custom Host:
             header as that will produce *two* in the same request! */
          hd_name_eq(name, namelen, STRCONST("Host:")))
         ;
@@ -1370,18 +1355,18 @@ CURLcode Curl_dynhds_add_custom(struct Curl_easy *data,
               hd_name_eq(name, namelen, STRCONST("Content-Type:")))
         ;
       else if(data->req.authneg &&
-              /* while doing auth neg, don't allow the custom length since
+              /* while doing auth neg, do not allow the custom length since
                  we will force length zero then */
               hd_name_eq(name, namelen, STRCONST("Content-Length:")))
         ;
       else if(data->state.aptr.te &&
-              /* when asking for Transfer-Encoding, don't pass on a custom
+              /* when asking for Transfer-Encoding, do not pass on a custom
                  Connection: */
               hd_name_eq(name, namelen, STRCONST("Connection:")))
         ;
       else if((conn->httpversion >= 20) &&
               hd_name_eq(name, namelen, STRCONST("Transfer-Encoding:")))
-        /* HTTP/2 doesn't support chunked requests */
+        /* HTTP/2 does not support chunked requests */
         ;
       else if((hd_name_eq(name, namelen, STRCONST("Authorization:")) ||
                hd_name_eq(name, namelen, STRCONST("Cookie:"))) &&
@@ -1503,8 +1488,9 @@ CURLcode Curl_add_custom_headers(struct Curl_easy *data,
           char *compare = semicolonp ? semicolonp : headers->data;
 
           if(data->state.aptr.host &&
-             /* a Host: header was sent already, don't pass on any custom Host:
-                header as that will produce *two* in the same request! */
+             /* a Host: header was sent already, do not pass on any custom
+                Host: header as that will produce *two* in the same
+                request! */
              checkprefix("Host:", compare))
             ;
           else if(data->state.httpreq == HTTPREQ_POST_FORM &&
@@ -1516,18 +1502,18 @@ CURLcode Curl_add_custom_headers(struct Curl_easy *data,
                   checkprefix("Content-Type:", compare))
             ;
           else if(data->req.authneg &&
-                  /* while doing auth neg, don't allow the custom length since
+                  /* while doing auth neg, do not allow the custom length since
                      we will force length zero then */
                   checkprefix("Content-Length:", compare))
             ;
           else if(data->state.aptr.te &&
-                  /* when asking for Transfer-Encoding, don't pass on a custom
+                  /* when asking for Transfer-Encoding, do not pass on a custom
                      Connection: */
                   checkprefix("Connection:", compare))
             ;
           else if((conn->httpversion >= 20) &&
                   checkprefix("Transfer-Encoding:", compare))
-            /* HTTP/2 doesn't support chunked requests */
+            /* HTTP/2 does not support chunked requests */
             ;
           else if((checkprefix("Authorization:", compare) ||
                    checkprefix("Cookie:", compare)) &&
@@ -1719,10 +1705,10 @@ CURLcode Curl_http_host(struct Curl_easy *data, struct connectdata *conn)
   if(ptr && (!data->state.this_is_a_follow ||
              strcasecompare(data->state.first_host, conn->host.name))) {
 #if !defined(CURL_DISABLE_COOKIES)
-    /* If we have a given custom Host: header, we extract the host name in
+    /* If we have a given custom Host: header, we extract the hostname in
        order to possibly use it for cookie reasons later on. We only allow the
        custom Host: header if this is NOT a redirect, as setting Host: in the
-       redirected request is being out on thin ice. Except if the host name
+       redirected request is being out on thin ice. Except if the hostname
        is the same as the first one! */
     char *cookiehost = Curl_copy_header_value(ptr);
     if(!cookiehost)
@@ -1760,15 +1746,15 @@ CURLcode Curl_http_host(struct Curl_easy *data, struct connectdata *conn)
     }
   }
   else {
-    /* When building Host: headers, we must put the host name within
-       [brackets] if the host name is a plain IPv6-address. RFC2732-style. */
+    /* When building Host: headers, we must put the hostname within
+       [brackets] if the hostname is a plain IPv6-address. RFC2732-style. */
     const char *host = conn->host.name;
 
     if(((conn->given->protocol&(CURLPROTO_HTTPS|CURLPROTO_WSS)) &&
         (conn->remote_port == PORT_HTTPS)) ||
        ((conn->given->protocol&(CURLPROTO_HTTP|CURLPROTO_WS)) &&
         (conn->remote_port == PORT_HTTP)) )
-      /* if(HTTPS on port 443) OR (HTTP on port 80) then don't include
+      /* if(HTTPS on port 443) OR (HTTP on port 80) then do not include
          the port number in the host string */
       aptr->host = aprintf("Host: %s%s%s\r\n", conn->bits.ipv6_ip?"[":"",
                            host, conn->bits.ipv6_ip?"]":"");
@@ -1778,7 +1764,7 @@ CURLcode Curl_http_host(struct Curl_easy *data, struct connectdata *conn)
                            conn->remote_port);
 
     if(!aptr->host)
-      /* without Host: we can't make a nice request */
+      /* without Host: we cannot make a nice request */
       return CURLE_OUT_OF_MEMORY;
   }
   return CURLE_OK;
@@ -1806,7 +1792,7 @@ CURLcode Curl_http_target(struct Curl_easy *data,
 
     /* The path sent to the proxy is in fact the entire URL. But if the remote
        host is a IDN-name, we must make sure that the request we produce only
-       uses the encoded host name! */
+       uses the encoded hostname! */
 
     /* and no fragment part */
     CURLUcode uc;
@@ -1829,7 +1815,7 @@ CURLcode Curl_http_target(struct Curl_easy *data,
     }
 
     if(strcasecompare("http", data->state.up.scheme)) {
-      /* when getting HTTP, we don't want the userinfo the URL */
+      /* when getting HTTP, we do not want the userinfo the URL */
       uc = curl_url_set(h, CURLUPART_USER, NULL, 0);
       if(uc) {
         curl_url_cleanup(h);
@@ -1850,7 +1836,7 @@ CURLcode Curl_http_target(struct Curl_easy *data,
 
     curl_url_cleanup(h);
 
-    /* target or url */
+    /* target or URL */
     result = Curl_dyn_add(r, data->set.str[STRING_TARGET]?
       data->set.str[STRING_TARGET]:url);
     free(url);
@@ -2053,7 +2039,7 @@ static CURLcode http_resume(struct Curl_easy *data, Curl_HttpReq httpreq)
     if(data->state.resume_from < 0) {
       /*
        * This is meant to get the size of the present remote-file by itself.
-       * We don't support this now. Bail out!
+       * We do not support this now. Bail out!
        */
       data->state.resume_from = 0;
     }
@@ -2138,7 +2124,7 @@ static CURLcode addexpect(struct Curl_easy *data, struct dynbuf *r,
   if(data->req.upgr101 != UPGR101_INIT)
     return CURLE_OK;
 
-  /* For really small puts we don't use Expect: headers at all, and for
+  /* For really small puts we do not use Expect: headers at all, and for
      the somewhat bigger ones we allow the app to disable it. Just make
      sure that the expect100header is always set to the preferred value
      here. */
@@ -2190,7 +2176,7 @@ CURLcode Curl_http_req_complete(struct Curl_easy *data,
   case HTTPREQ_POST_MIME:
 #endif
     /* We only set Content-Length and allow a custom Content-Length if
-       we don't upload data chunked, as RFC2616 forbids us to set both
+       we do not upload data chunked, as RFC2616 forbids us to set both
        kinds of headers (Transfer-Encoding: chunked and Content-Length).
        We do not override a custom "Content-Length" header, but during
        authentication negotiation that header is suppressed.
@@ -2199,7 +2185,7 @@ CURLcode Curl_http_req_complete(struct Curl_easy *data,
        (data->req.authneg ||
         !Curl_checkheaders(data, STRCONST("Content-Length")))) {
       /* we allow replacing this header if not during auth negotiation,
-         although it isn't very wise to actually set your own */
+         although it is not very wise to actually set your own */
       result = Curl_dyn_addf(r,
                              "Content-Length: %" CURL_FORMAT_CURL_OFF_T
                              "\r\n", req_clen);
@@ -2247,7 +2233,7 @@ CURLcode Curl_http_req_complete(struct Curl_easy *data,
 out:
   if(!result) {
     /* setup variables for the upcoming transfer */
-    Curl_xfer_setup(data, FIRSTSOCKET, -1, TRUE, FIRSTSOCKET);
+    Curl_xfer_setup1(data, CURL_XFER_SENDRECV, -1, TRUE);
   }
   return result;
 }
@@ -2335,7 +2321,7 @@ CURLcode Curl_http_range(struct Curl_easy *data,
 {
   if(data->state.use_range) {
     /*
-     * A range is selected. We use different headers whether we're downloading
+     * A range is selected. We use different headers whether we are downloading
      * or uploading and we always let customized headers override our internal
      * ones if any such are specified.
      */
@@ -2353,7 +2339,7 @@ CURLcode Curl_http_range(struct Curl_easy *data,
       free(data->state.aptr.rangeline);
 
       if(data->set.set_resume_from < 0) {
-        /* Upload resume was asked for, but we don't know the size of the
+        /* Upload resume was asked for, but we do not know the size of the
            remote part so we tell the server (and act accordingly) that we
            upload the whole file (again) */
         data->state.aptr.rangeline =
@@ -2397,12 +2383,12 @@ CURLcode Curl_http_firstwrite(struct Curl_easy *data)
   if(data->req.newurl) {
     if(conn->bits.close) {
       /* Abort after the headers if "follow Location" is set
-         and we're set to close anyway. */
+         and we are set to close anyway. */
       k->keepon &= ~KEEP_RECV;
       k->done = TRUE;
       return CURLE_OK;
     }
-    /* We have a new url to load, but since we want to be able to reuse this
+    /* We have a new URL to load, but since we want to be able to reuse this
        connection properly, we read the full response in "ignore more" */
     k->ignorebody = TRUE;
     infof(data, "Ignoring the response-body");
@@ -2413,7 +2399,7 @@ CURLcode Curl_http_firstwrite(struct Curl_easy *data)
 
     if(k->size == data->state.resume_from) {
       /* The resume point is at the end of file, consider this fine even if it
-         doesn't allow resume from here. */
+         does not allow resume from here. */
       infof(data, "The entire document is already downloaded");
       streamclose(conn, "already downloaded");
       /* Abort download */
@@ -2422,10 +2408,10 @@ CURLcode Curl_http_firstwrite(struct Curl_easy *data)
       return CURLE_OK;
     }
 
-    /* we wanted to resume a download, although the server doesn't seem to
-     * support this and we did this with a GET (if it wasn't a GET we did a
+    /* we wanted to resume a download, although the server does not seem to
+     * support this and we did this with a GET (if it was not a GET we did a
      * POST or PUT resume) */
-    failf(data, "HTTP server doesn't seem to support "
+    failf(data, "HTTP server does not seem to support "
           "byte ranges. Cannot resume.");
     return CURLE_RANGE_ERROR;
   }
@@ -2437,7 +2423,7 @@ CURLcode Curl_http_firstwrite(struct Curl_easy *data)
 
     if(!Curl_meets_timecondition(data, k->timeofdoc)) {
       k->done = TRUE;
-      /* We're simulating an HTTP 304 from server so we return
+      /* We are simulating an HTTP 304 from server so we return
          what should have been returned from the server */
       data->info.httpcode = 304;
       infof(data, "Simulate an HTTP 304 response");
@@ -2459,7 +2445,7 @@ CURLcode Curl_transferencode(struct Curl_easy *data)
     /* When we are to insert a TE: header in the request, we must also insert
        TE in a Connection: header, so we need to merge the custom provided
        Connection: header and prevent the original to get sent. Note that if
-       the user has inserted his/her own TE: header we don't do this magic
+       the user has inserted his/her own TE: header we do not do this magic
        but then assume that the user will handle it all! */
     char *cptr = Curl_checkheaders(data, STRCONST("Connection"));
 #define TE_HEADER "TE: gzip\r\n"
@@ -2705,7 +2691,7 @@ CURLcode Curl_http(struct Curl_easy *data, bool *done)
   if(!(conn->handler->flags&PROTOPT_SSL) &&
      conn->httpversion < 20 &&
      (data->state.httpwant == CURL_HTTP_VERSION_2)) {
-    /* append HTTP2 upgrade magic stuff to the HTTP request if it isn't done
+    /* append HTTP2 upgrade magic stuff to the HTTP request if it is not done
        over SSL */
     result = Curl_http2_request_upgrade(&req, data);
     if(result) {
@@ -2849,7 +2835,7 @@ CURLcode Curl_http_header(struct Curl_easy *data,
 #ifndef CURL_DISABLE_ALTSVC
     v = (data->asi &&
          ((data->conn->handler->flags & PROTOPT_SSL) ||
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
           /* allow debug builds to circumvent the HTTPS restriction */
           getenv("CURL_ALTSVC_HTTP")
 #else
@@ -2901,7 +2887,7 @@ CURLcode Curl_http_header(struct Curl_easy *data,
        * Process Content-Encoding. Look for the values: identity,
        * gzip, deflate, compress, x-gzip and x-compress. x-gzip and
        * x-compress are the same as gzip and compress. (Sec 3.5 RFC
-       * 2616). zlib cannot handle compress.  However, errors are
+       * 2616). zlib cannot handle compress. However, errors are
        * handled further down when the response body is processed
        */
       return Curl_build_unencoding_stack(data, v, FALSE);
@@ -2936,7 +2922,7 @@ CURLcode Curl_http_header(struct Curl_easy *data,
       /*
        * An HTTP/1.0 reply with the 'Connection: keep-alive' line
        * tells us the connection will be kept alive for our
-       * pleasure.  Default action for 1.0 is to close.
+       * pleasure. Default action for 1.0 is to close.
        *
        * [RFC2068, section 19.7.1] */
       connkeep(conn, "Connection keep-alive");
@@ -3029,13 +3015,13 @@ CURLcode Curl_http_header(struct Curl_easy *data,
          * connection will be kept alive for our pleasure.
          * Default action for 1.0 is to close.
          */
-        connkeep(conn, "Proxy-Connection keep-alive"); /* don't close */
+        connkeep(conn, "Proxy-Connection keep-alive"); /* do not close */
         infof(data, "HTTP/1.0 proxy connection set to keep alive");
       }
       else if((conn->httpversion == 11) && conn->bits.httpproxy &&
               HD_IS_AND_SAYS(hd, hdlen, "Proxy-Connection:", "close")) {
         /*
-         * We get an HTTP/1.1 response from a proxy and it says it'll
+         * We get an HTTP/1.1 response from a proxy and it says it will
          * close down after this transfer.
          */
         connclose(conn, "Proxy-Connection: asked to close after done");
@@ -3095,7 +3081,7 @@ CURLcode Curl_http_header(struct Curl_easy *data,
         HD_VAL(hd, hdlen, "Set-Cookie:") : NULL;
     if(v) {
       /* If there is a custom-set Host: name, use it here, or else use
-       * real peer host name. */
+       * real peer hostname. */
       const char *host = data->state.aptr.cookiehost?
         data->state.aptr.cookiehost:conn->host.name;
       const bool secure_context =
@@ -3116,7 +3102,7 @@ CURLcode Curl_http_header(struct Curl_easy *data,
     /* If enabled, the header is incoming and this is over HTTPS */
     v = (data->hsts &&
          ((conn->handler->flags & PROTOPT_SSL) ||
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
            /* allow debug builds to circumvent the HTTPS restriction */
            getenv("CURL_HSTS_HTTP")
 #else
@@ -3160,7 +3146,7 @@ CURLcode Curl_http_header(struct Curl_easy *data,
       if(result)
         return result;
       if(!k->chunk && data->set.http_transfer_encoding) {
-        /* if this isn't chunked, only close can signal the end of this
+        /* if this is not chunked, only close can signal the end of this
          * transfer as Content-Length is said not to be trusted for
          * transfer-encoding! */
         connclose(conn, "HTTP/1.1 transfer-encoding without chunks");
@@ -3231,11 +3217,11 @@ CURLcode Curl_http_statusline(struct Curl_easy *data,
     data->state.httpversion = (unsigned char)k->httpversion;
 
   /*
-   * This code executes as part of processing the header.  As a
-   * result, it's not totally clear how to interpret the
+   * This code executes as part of processing the header. As a
+   * result, it is not totally clear how to interpret the
    * response code yet as that depends on what other headers may
-   * be present.  401 and 407 may be errors, but may be OK
-   * depending on how authentication is working.  Other codes
+   * be present. 401 and 407 may be errors, but may be OK
+   * depending on how authentication is working. Other codes
    * are definitely errors, so give up here.
    */
   if(data->state.resume_from && data->state.httpreq == HTTPREQ_GET &&
@@ -3287,7 +3273,7 @@ CURLcode Curl_http_statusline(struct Curl_easy *data,
 }
 
 /* Content-Length must be ignored if any Transfer-Encoding is present in the
-   response. Refer to RFC 7230 section 3.3.3 and RFC2616 section 4.4.  This is
+   response. Refer to RFC 7230 section 3.3.3 and RFC2616 section 4.4. This is
    figured out here after all headers have been received but before the final
    call to the user's header callback, so that a valid content length can be
    retrieved by the user in the final call. */
@@ -3323,7 +3309,7 @@ static CURLcode verify_header(struct Curl_easy *data,
     /* the first "header" is the status-line and it has no colon */
     return CURLE_OK;
   if(((hd[0] == ' ') || (hd[0] == '\t')) && k->headerline > 2)
-    /* line folding, can't happen on line 2 */
+    /* line folding, cannot happen on line 2 */
     ;
   else {
     ptr = memchr(hd, ':', hdlen);
@@ -3363,8 +3349,35 @@ CURLcode Curl_bump_headersize(struct Curl_easy *data,
   return CURLE_OK;
 }
 
+static CURLcode http_write_header(struct Curl_easy *data,
+                                  const char *hd, size_t hdlen)
+{
+  CURLcode result;
+  int writetype;
+
+  /* now, only output this if the header AND body are requested:
+   */
+  Curl_debug(data, CURLINFO_HEADER_IN, (char *)hd, hdlen);
+
+  writetype = CLIENTWRITE_HEADER |
+    ((data->req.httpcode/100 == 1) ? CLIENTWRITE_1XX : 0);
+
+  result = Curl_client_write(data, writetype, hd, hdlen);
+  if(result)
+    return result;
+
+  result = Curl_bump_headersize(data, hdlen, FALSE);
+  if(result)
+    return result;
+
+  data->req.deductheadercount = (100 <= data->req.httpcode &&
+                                 199 >= data->req.httpcode)?
+                                data->req.headerbytecount:0;
+  return result;
+}
 
 static CURLcode http_on_response(struct Curl_easy *data,
+                                 const char *last_hd, size_t last_hd_len,
                                  const char *buf, size_t blen,
                                  size_t *pconsumed)
 {
@@ -3384,9 +3397,20 @@ static CURLcode http_on_response(struct Curl_easy *data,
     conn->bundle->multiuse = BUNDLE_NO_MULTIUSE;
   }
 
+  if(k->httpcode < 200 && last_hd) {
+    /* Intermediate responses might trigger processing of more
+     * responses, write the last header to the client before
+     * proceeding. */
+    result = http_write_header(data, last_hd, last_hd_len);
+    last_hd = NULL; /* handled it */
+    if(result)
+      goto out;
+  }
+
   if(k->httpcode < 100) {
     failf(data, "Unsupported response code in HTTP response");
-    return CURLE_UNSUPPORTED_PROTOCOL;
+    result = CURLE_UNSUPPORTED_PROTOCOL;
+    goto out;
   }
   else if(k->httpcode < 200) {
     /* "A user agent MAY ignore unexpected 1xx status responses."
@@ -3405,10 +3429,12 @@ static CURLcode http_on_response(struct Curl_easy *data,
       break;
     case 101:
       /* Switching Protocols only allowed from HTTP/1.1 */
+
       if(conn->httpversion != 11) {
         /* invalid for other HTTP versions */
         failf(data, "unexpected 101 response code");
-        return CURLE_WEIRD_SERVER_REPLY;
+        result = CURLE_WEIRD_SERVER_REPLY;
+        goto out;
       }
       if(k->upgr101 == UPGR101_H2) {
         /* Switching to HTTP/2, where we will get more responses */
@@ -3421,7 +3447,7 @@ static CURLcode http_on_response(struct Curl_easy *data,
          * be processed. */
         result = Curl_http2_upgrade(data, conn, FIRSTSOCKET, buf, blen);
         if(result)
-          return result;
+          goto out;
         *pconsumed += blen;
       }
 #ifdef USE_WEBSOCKETS
@@ -3430,7 +3456,7 @@ static CURLcode http_on_response(struct Curl_easy *data,
          * WebSockets format and taken in by the protocol handler. */
         result = Curl_ws_accept(data, buf, blen);
         if(result)
-          return result;
+          goto out;
         *pconsumed += blen; /* ws accept handled the data */
         k->header = FALSE; /* we will not get more responses */
         if(data->set.connect_only)
@@ -3451,7 +3477,7 @@ static CURLcode http_on_response(struct Curl_easy *data,
        * to receive a final response eventually. */
       break;
     }
-    return result;
+    goto out;
   }
 
   /* k->httpcode >= 200, final response */
@@ -3512,7 +3538,8 @@ static CURLcode http_on_response(struct Curl_easy *data,
   /* All >=200 HTTP status codes are errors when wanting websockets */
   if(data->req.upgr101 == UPGR101_WS) {
     failf(data, "Refused WebSockets upgrade: %d", k->httpcode);
-    return CURLE_HTTP_RETURNED_ERROR;
+    result = CURLE_HTTP_RETURNED_ERROR;
+    goto out;
   }
 #endif
 
@@ -3520,7 +3547,8 @@ static CURLcode http_on_response(struct Curl_easy *data,
   if(http_should_fail(data, data->req.httpcode)) {
     failf(data, "The requested URL returned error: %d",
           k->httpcode);
-    return CURLE_HTTP_RETURNED_ERROR;
+    result = CURLE_HTTP_RETURNED_ERROR;
+    goto out;
   }
 
   /* Curl_http_auth_act() checks what authentication methods
@@ -3528,7 +3556,7 @@ static CURLcode http_on_response(struct Curl_easy *data,
    * use. It will set 'newurl' if an auth method was picked. */
   result = Curl_http_auth_act(data);
   if(result)
-    return result;
+    goto out;
 
   if(k->httpcode >= 300) {
     if((!data->req.authneg) && !conn->bits.close &&
@@ -3551,7 +3579,7 @@ static CURLcode http_on_response(struct Curl_easy *data,
       case HTTPREQ_POST_MIME:
         /* We got an error response. If this happened before the whole
          * request body has been sent we stop sending and mark the
-         * connection for closure after we've read the entire response.
+         * connection for closure after we have read the entire response.
          */
         if(!Curl_req_done_sending(data)) {
           if((k->httpcode == 417) && Curl_http_exp100_is_selected(data)) {
@@ -3566,7 +3594,7 @@ static CURLcode http_on_response(struct Curl_easy *data,
                           "Stop sending data before everything sent");
               result = http_perhapsrewind(data, conn);
               if(result)
-                return result;
+                goto out;
             }
             data->state.disableexpect = TRUE;
             DEBUGASSERT(!data->req.newurl);
@@ -3582,7 +3610,7 @@ static CURLcode http_on_response(struct Curl_easy *data,
             streamclose(conn, "Stop sending data before everything sent");
             result = Curl_req_abort_sending(data);
             if(result)
-              return result;
+              goto out;
           }
         }
         break;
@@ -3605,7 +3633,7 @@ static CURLcode http_on_response(struct Curl_easy *data,
    */
   result = Curl_http_size(data);
   if(result)
-    return result;
+    goto out;
 
   /* If we requested a "no body", this is a good time to get
    * out and return home.
@@ -3614,9 +3642,9 @@ static CURLcode http_on_response(struct Curl_easy *data,
     k->download_done = TRUE;
 
   /* If max download size is *zero* (nothing) we already have
-     nothing and can safely return ok now!  But for HTTP/2, we'd
+     nothing and can safely return ok now!  But for HTTP/2, we would
      like to call http2_handle_stream_close to properly close a
-     stream.  In order to do this, we keep reading until we
+     stream. In order to do this, we keep reading until we
      close the stream. */
   if(0 == k->maxdownload
      && !Curl_conn_is_http2(data, conn, FIRSTSOCKET)
@@ -3624,7 +3652,16 @@ static CURLcode http_on_response(struct Curl_easy *data,
     k->download_done = TRUE;
 
   /* final response without error, prepare to receive the body */
-  return Curl_http_firstwrite(data);
+  result = Curl_http_firstwrite(data);
+
+out:
+  if(last_hd) {
+    /* if not written yet, write it now */
+    CURLcode r2 = http_write_header(data, last_hd, last_hd_len);
+    if(!result)
+      result = r2;
+  }
+  return result;
 }
 
 static CURLcode http_rw_hd(struct Curl_easy *data,
@@ -3639,36 +3676,25 @@ static CURLcode http_rw_hd(struct Curl_easy *data,
   *pconsumed = 0;
   if((0x0a == *hd) || (0x0d == *hd)) {
     /* Empty header line means end of headers! */
+    struct dynbuf last_header;
     size_t consumed;
 
-    /* now, only output this if the header AND body are requested:
-     */
-    Curl_debug(data, CURLINFO_HEADER_IN, (char *)hd, hdlen);
-
-    writetype = CLIENTWRITE_HEADER |
-      ((k->httpcode/100 == 1) ? CLIENTWRITE_1XX : 0);
-
-    result = Curl_client_write(data, writetype, hd, hdlen);
+    Curl_dyn_init(&last_header, hdlen + 1);
+    result = Curl_dyn_addn(&last_header, hd, hdlen);
     if(result)
       return result;
 
-    result = Curl_bump_headersize(data, hdlen, FALSE);
-    if(result)
-      return result;
-
-    data->req.deductheadercount =
-      (100 <= k->httpcode && 199 >= k->httpcode)?data->req.headerbytecount:0;
-
     /* analyze the response to find out what to do. */
     /* Caveat: we clear anything in the header brigade, because a
      * response might switch HTTP version which may call use recursively.
      * Not nice, but that is currently the way of things. */
     Curl_dyn_reset(&data->state.headerb);
-    result = http_on_response(data, buf_remain, blen, &consumed);
-    if(result)
-      return result;
+    result = http_on_response(data, Curl_dyn_ptr(&last_header),
+                              Curl_dyn_len(&last_header),
+                              buf_remain, blen, &consumed);
     *pconsumed += consumed;
-    return CURLE_OK;
+    Curl_dyn_free(&last_header);
+    return result;
   }
 
   /*
@@ -3681,14 +3707,14 @@ static CURLcode http_rw_hd(struct Curl_easy *data,
        or else we consider this to be the body right away! */
     bool fine_statusline = FALSE;
 
-    k->httpversion = 0; /* Don't know yet */
+    k->httpversion = 0; /* Do not know yet */
     if(data->conn->handler->protocol & PROTO_FAMILY_HTTP) {
       /*
        * https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2
        *
        * The response code is always a three-digit number in HTTP as the spec
        * says. We allow any three-digit number here, but we cannot make
-       * guarantees on future behaviors since it isn't within the protocol.
+       * guarantees on future behaviors since it is not within the protocol.
        */
       const char *p = hd;
 
@@ -4431,7 +4457,7 @@ static CURLcode cr_exp100_read(struct Curl_easy *data,
       *eos = FALSE;
       return CURLE_OK;
     }
-    /* we've waited long enough, continue anyway */
+    /* we have waited long enough, continue anyway */
     http_exp100_continue(data, reader);
     infof(data, "Done waiting for 100-continue");
     FALLTHROUGH();
@@ -4460,6 +4486,7 @@ static const struct Curl_crtype cr_exp100 = {
   Curl_creader_def_resume_from,
   Curl_creader_def_rewind,
   Curl_creader_def_unpause,
+  Curl_creader_def_is_paused,
   cr_exp100_done,
   sizeof(struct cr_exp100_ctx)
 };
diff --git a/lib/http.h b/lib/http.h
index b0c4f5fd2..bb5974d94 100644
--- a/lib/http.h
+++ b/lib/http.h
@@ -73,7 +73,6 @@ char *Curl_checkProxyheaders(struct Curl_easy *data,
                              const struct connectdata *conn,
                              const char *thisheader,
                              const size_t thislen);
-struct HTTP; /* see below */
 
 CURLcode Curl_add_timecondition(struct Curl_easy *data,
 #ifndef USE_HYPER
@@ -147,7 +146,7 @@ CURLcode Curl_http_auth_act(struct Curl_easy *data);
    selected to use no auth at all. Ie, we actively select no auth, as opposed
    to not having one selected. The other CURLAUTH_* defines are present in the
    public curl/curl.h header. */
-#define CURLAUTH_PICKNONE (1<<30) /* don't use auth */
+#define CURLAUTH_PICKNONE (1<<30) /* do not use auth */
 
 /* MAX_INITIAL_POST_SIZE indicates the number of bytes that will make the POST
    data get included in the initial data chunk sent to the server. If the
@@ -187,10 +186,6 @@ void Curl_http_exp100_got100(struct Curl_easy *data);
 /****************************************************************************
  * HTTP unique setup
  ***************************************************************************/
-struct HTTP {
-  /* TODO: no longer used, we should remove it from SingleRequest */
-  char unused;
-};
 
 CURLcode Curl_http_size(struct Curl_easy *data);
 
@@ -240,7 +235,7 @@ struct httpreq {
 };
 
 /**
- * Create a HTTP request struct.
+ * Create an HTTP request struct.
  */
 CURLcode Curl_http_req_make(struct httpreq **preq,
                             const char *method, size_t m_len,
@@ -290,7 +285,7 @@ struct http_resp {
 };
 
 /**
- * Create a HTTP response struct.
+ * Create an HTTP response struct.
  */
 CURLcode Curl_http_resp_make(struct http_resp **presp,
                              int status,
diff --git a/lib/http1.c b/lib/http1.c
index 182234ca9..d7e21fdce 100644
--- a/lib/http1.c
+++ b/lib/http1.c
@@ -217,7 +217,7 @@ static CURLcode start_req(struct h1_req_parser *parser,
     tmp[target_len] = '\0';
     /* See if treating TARGET as an absolute URL makes sense */
     if(Curl_is_absolute_url(tmp, NULL, 0, FALSE)) {
-      int url_options;
+      unsigned int url_options;
 
       url = curl_url();
       if(!url) {
diff --git a/lib/http2.c b/lib/http2.c
index f0f7b566e..6a979c136 100644
--- a/lib/http2.c
+++ b/lib/http2.c
@@ -83,18 +83,17 @@
 /* spare chunks we keep for a full window */
 #define H2_STREAM_POOL_SPARES   (H2_STREAM_WINDOW_SIZE / H2_CHUNK_SIZE)
 
-/* We need to accommodate the max number of streams with their window
- * sizes on the overall connection. Streams might become PAUSED which
- * will block their received QUOTA in the connection window. And if we
- * run out of space, the server is blocked from sending us any data.
- * See #10988 for an issue with this. */
+/* We need to accommodate the max number of streams with their window sizes on
+ * the overall connection. Streams might become PAUSED which will block their
+ * received QUOTA in the connection window. If we run out of space, the server
+ * is blocked from sending us any data. See #10988 for an issue with this. */
 #define HTTP2_HUGE_WINDOW_SIZE (100 * H2_STREAM_WINDOW_SIZE)
 
 #define H2_SETTINGS_IV_LEN  3
 #define H2_BINSETTINGS_LEN 80
 
-static int populate_settings(nghttp2_settings_entry *iv,
-                             struct Curl_easy *data)
+static size_t populate_settings(nghttp2_settings_entry *iv,
+                                struct Curl_easy *data)
 {
   iv[0].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;
   iv[0].value = Curl_multi_max_concurrent_streams(data->multi);
@@ -112,7 +111,7 @@ static ssize_t populate_binsettings(uint8_t *binsettings,
                                     struct Curl_easy *data)
 {
   nghttp2_settings_entry iv[H2_SETTINGS_IV_LEN];
-  int ivlen;
+  size_t ivlen;
 
   ivlen = populate_settings(iv, data);
   /* this returns number of bytes it wrote or a negative number on error. */
@@ -133,10 +132,12 @@ struct cf_h2_ctx {
   struct Curl_hash streams; /* hash of `data->id` to `h2_stream_ctx` */
   size_t drain_total; /* sum of all stream's UrlState drain */
   uint32_t max_concurrent_streams;
-  int32_t goaway_error;
-  int32_t last_stream_id;
+  uint32_t goaway_error;        /* goaway error code from server */
+  int32_t remote_max_sid;       /* max id processed by server */
+  int32_t local_max_sid;        /* max id processed by us */
   BIT(conn_closed);
-  BIT(goaway);
+  BIT(rcvd_goaway);
+  BIT(sent_goaway);
   BIT(enable_push);
   BIT(nw_out_blocked);
 };
@@ -289,10 +290,6 @@ static CURLcode http2_data_setup(struct Curl_cfilter *cf,
 
   (void)cf;
   DEBUGASSERT(data);
-  if(!data->req.p.http) {
-    failf(data, "initialization failure, transfer not http initialized");
-    return CURLE_FAILED_INIT;
-  }
   stream = H2_STREAM_CTX(ctx, data);
   if(stream) {
     *pstream = stream;
@@ -437,7 +434,7 @@ static CURLcode cf_h2_ctx_init(struct Curl_cfilter *cf,
   Curl_bufq_initp(&ctx->outbufq, &ctx->stream_bufcp, H2_NW_SEND_CHUNKS, 0);
   Curl_dyn_init(&ctx->scratch, CURL_MAX_HTTP_HEADER);
   Curl_hash_offt_init(&ctx->streams, 63, h2_stream_hash_free);
-  ctx->last_stream_id = 2147483647;
+  ctx->remote_max_sid = 2147483647;
 
   rc = nghttp2_session_callbacks_new(&cbs);
   if(rc) {
@@ -486,7 +483,7 @@ static CURLcode cf_h2_ctx_init(struct Curl_cfilter *cf,
     DEBUGASSERT(stream);
     stream->id = 1;
     /* queue SETTINGS frame (again) */
-    rc = nghttp2_session_upgrade2(ctx->h2, binsettings, binlen,
+    rc = nghttp2_session_upgrade2(ctx->h2, binsettings, (size_t)binlen,
                                   data->state.httpreq == HTTPREQ_HEAD,
                                   NULL);
     if(rc) {
@@ -507,7 +504,7 @@ static CURLcode cf_h2_ctx_init(struct Curl_cfilter *cf,
   }
   else {
     nghttp2_settings_entry iv[H2_SETTINGS_IV_LEN];
-    int ivlen;
+    size_t ivlen;
 
     ivlen = populate_settings(iv, data);
     rc = nghttp2_submit_settings(ctx->h2, NGHTTP2_FLAG_NONE,
@@ -612,8 +609,8 @@ static bool http2_connisalive(struct Curl_cfilter *cf, struct Curl_easy *data,
     return FALSE;
 
   if(*input_pending) {
-    /* This happens before we've sent off a request and the connection is
-       not in use by any other transfer, there shouldn't be any data here,
+    /* This happens before we have sent off a request and the connection is
+       not in use by any other transfer, there should not be any data here,
        only "protocol frames" */
     CURLcode result;
     ssize_t nread = -1;
@@ -794,18 +791,9 @@ static struct Curl_easy *h2_duphandle(struct Curl_cfilter *cf,
 {
   struct Curl_easy *second = curl_easy_duphandle(data);
   if(second) {
-    /* setup the request struct */
-    struct HTTP *http = calloc(1, sizeof(struct HTTP));
-    if(!http) {
-      (void)Curl_close(&second);
-    }
-    else {
-      struct h2_stream_ctx *second_stream;
-
-      second->req.p.http = http;
-      http2_data_setup(cf, second, &second_stream);
-      second->state.priority.weight = data->state.priority.weight;
-    }
+    struct h2_stream_ctx *second_stream;
+    http2_data_setup(cf, second, &second_stream);
+    second->state.priority.weight = data->state.priority.weight;
   }
   return second;
 }
@@ -867,9 +855,7 @@ fail:
 static void discard_newhandle(struct Curl_cfilter *cf,
                               struct Curl_easy *newhandle)
 {
-  if(newhandle->req.p.http) {
-    http2_data_done(cf, newhandle);
-  }
+  http2_data_done(cf, newhandle);
   (void)Curl_close(&newhandle);
 }
 
@@ -967,6 +953,10 @@ static int push_promise(struct Curl_cfilter *cf,
       rv = CURL_PUSH_DENY;
       goto fail;
     }
+
+    /* success, remember max stream id processed */
+    if(newstream->id > ctx->local_max_sid)
+      ctx->local_max_sid = newstream->id;
   }
   else {
     CURL_TRC_CF(data, cf, "Got PUSH_PROMISE, ignore it");
@@ -1007,7 +997,7 @@ static void h2_xfer_write_resp(struct Curl_cfilter *cf,
                 "RST-ing stream",
                 stream->id, stream->xfer_result, blen);
     nghttp2_submit_rst_stream(ctx->h2, 0, stream->id,
-                              NGHTTP2_ERR_CALLBACK_FAILURE);
+                              (uint32_t)NGHTTP2_ERR_CALLBACK_FAILURE);
   }
 }
 
@@ -1048,7 +1038,7 @@ static CURLcode on_stream_frame(struct Curl_cfilter *cf,
     break;
   case NGHTTP2_HEADERS:
     if(stream->bodystarted) {
-      /* Only valid HEADERS after body started is trailer HEADERS.  We
+      /* Only valid HEADERS after body started is trailer HEADERS. We
          buffer them in on_header callback. */
       break;
     }
@@ -1252,12 +1242,12 @@ static int on_frame_recv(nghttp2_session *session, const nghttp2_frame *frame,
       break;
     }
     case NGHTTP2_GOAWAY:
-      ctx->goaway = TRUE;
+      ctx->rcvd_goaway = TRUE;
       ctx->goaway_error = frame->goaway.error_code;
-      ctx->last_stream_id = frame->goaway.last_stream_id;
+      ctx->remote_max_sid = frame->goaway.last_stream_id;
       if(data) {
-        infof(data, "received GOAWAY, error=%d, last_stream=%u",
-                    ctx->goaway_error, ctx->last_stream_id);
+        infof(data, "received GOAWAY, error=%u, last_stream=%u",
+                    ctx->goaway_error, ctx->remote_max_sid);
         Curl_multi_connchanged(data->multi);
       }
       break;
@@ -1654,7 +1644,7 @@ CURLcode Curl_http2_request_upgrade(struct dynbuf *req,
     return CURLE_FAILED_INIT;
   }
 
-  result = Curl_base64url_encode((const char *)binsettings, binlen,
+  result = Curl_base64url_encode((const char *)binsettings, (size_t)binlen,
                                  &base64, &blen);
   if(result) {
     Curl_dyn_free(req);
@@ -1710,7 +1700,7 @@ static ssize_t http2_handle_stream_close(struct Curl_cfilter *cf,
   if(stream->error == NGHTTP2_REFUSED_STREAM) {
     CURL_TRC_CF(data, cf, "[%d] REFUSED_STREAM, try again on a new "
                 "connection", stream->id);
-    connclose(cf->conn, "REFUSED_STREAM"); /* don't use this anymore */
+    connclose(cf->conn, "REFUSED_STREAM"); /* do not use this anymore */
     data->state.refused_stream = TRUE;
     *err = CURLE_RECV_ERROR; /* trigger Curl_retry_request() later */
     return -1;
@@ -1817,7 +1807,7 @@ static void h2_pri_spec(struct cf_h2_ctx *ctx,
 }
 
 /*
- * Check if there's been an update in the priority /
+ * Check if there is been an update in the priority /
  * dependency settings and if so it submits a PRIORITY frame with the updated
  * info.
  * Flush any out data pending in the network buffer.
@@ -1878,7 +1868,7 @@ static ssize_t stream_recv(struct Curl_cfilter *cf, struct Curl_easy *data,
   }
   else if(stream->reset ||
           (ctx->conn_closed && Curl_bufq_is_empty(&ctx->inbufq)) ||
-          (ctx->goaway && ctx->last_stream_id < stream->id)) {
+          (ctx->rcvd_goaway && ctx->remote_max_sid < stream->id)) {
     CURL_TRC_CF(data, cf, "[%d] returning ERR", stream->id);
     *err = data->req.bytecount? CURLE_PARTIAL_FILE : CURLE_HTTP2;
     nread = -1;
@@ -2015,7 +2005,7 @@ static ssize_t cf_h2_recv(struct Curl_cfilter *cf, struct Curl_easy *data,
 out:
   result = h2_progress_egress(cf, data);
   if(result == CURLE_AGAIN) {
-    /* pending data to send, need to be called again. Ideally, we'd
+    /* pending data to send, need to be called again. Ideally, we would
      * monitor the socket for POLLOUT, but we might not be in SENDING
      * transfer state any longer and are unable to make this happen.
      */
@@ -2292,8 +2282,8 @@ static ssize_t cf_h2_send(struct Curl_cfilter *cf, struct Curl_easy *data,
     /* Unable to send all data, due to connection blocked or H2 window
      * exhaustion. Data is left in our stream buffer, or nghttp2's internal
      * frame buffer or our network out buffer. */
-    size_t rwin = nghttp2_session_get_stream_remote_window_size(ctx->h2,
-                                                                stream->id);
+    size_t rwin = (size_t)nghttp2_session_get_stream_remote_window_size(
+                    ctx->h2, stream->id);
     /* At the start of a stream, we are called with request headers
      * and, possibly, parts of the body. Later, only body data.
      * If we cannot send pure body data, we EAGAIN. If there had been
@@ -2358,6 +2348,7 @@ static void cf_h2_adjust_pollset(struct Curl_cfilter *cf,
                                  struct easy_pollset *ps)
 {
   struct cf_h2_ctx *ctx = cf->ctx;
+  struct cf_call_data save;
   curl_socket_t sock;
   bool want_recv, want_send;
 
@@ -2368,7 +2359,6 @@ static void cf_h2_adjust_pollset(struct Curl_cfilter *cf,
   Curl_pollset_check(data, ps, sock, &want_recv, &want_send);
   if(want_recv || want_send) {
     struct h2_stream_ctx *stream = H2_STREAM_CTX(ctx, data);
-    struct cf_call_data save;
     bool c_exhaust, s_exhaust;
 
     CF_DATA_SAVE(save, cf, data);
@@ -2383,6 +2373,14 @@ static void cf_h2_adjust_pollset(struct Curl_cfilter *cf,
     Curl_pollset_set(data, ps, sock, want_recv, want_send);
     CF_DATA_RESTORE(cf, save);
   }
+  else if(ctx->sent_goaway && !cf->shutdown) {
+    /* shutdown in progress */
+    CF_DATA_SAVE(save, cf, data);
+    want_send = nghttp2_session_want_write(ctx->h2);
+    want_recv = nghttp2_session_want_read(ctx->h2);
+    Curl_pollset_set(data, ps, sock, want_recv, want_send);
+    CF_DATA_RESTORE(cf, save);
+  }
 }
 
 static CURLcode cf_h2_connect(struct Curl_cfilter *cf,
@@ -2446,6 +2444,7 @@ static void cf_h2_close(struct Curl_cfilter *cf, struct Curl_easy *data)
     CF_DATA_SAVE(save, cf, data);
     cf_h2_ctx_clear(ctx);
     CF_DATA_RESTORE(cf, save);
+    cf->connected = FALSE;
   }
   if(cf->next)
     cf->next->cft->do_close(cf->next, data);
@@ -2462,6 +2461,50 @@ static void cf_h2_destroy(struct Curl_cfilter *cf, struct Curl_easy *data)
   }
 }
 
+static CURLcode cf_h2_shutdown(struct Curl_cfilter *cf,
+                               struct Curl_easy *data, bool *done)
+{
+  struct cf_h2_ctx *ctx = cf->ctx;
+  struct cf_call_data save;
+  CURLcode result;
+  int rv;
+
+  if(!cf->connected || !ctx->h2 || cf->shutdown || ctx->conn_closed) {
+    *done = TRUE;
+    return CURLE_OK;
+  }
+
+  CF_DATA_SAVE(save, cf, data);
+
+  if(!ctx->sent_goaway) {
+    rv = nghttp2_submit_goaway(ctx->h2, NGHTTP2_FLAG_NONE,
+                               ctx->local_max_sid, 0,
+                               (const uint8_t *)"shutown", sizeof("shutown"));
+    if(rv) {
+      failf(data, "nghttp2_submit_goaway() failed: %s(%d)",
+            nghttp2_strerror(rv), rv);
+      result = CURLE_SEND_ERROR;
+      goto out;
+    }
+    ctx->sent_goaway = TRUE;
+  }
+  /* GOAWAY submitted, process egress and ingress until nghttp2 is done. */
+  result = CURLE_OK;
+  if(nghttp2_session_want_write(ctx->h2))
+    result = h2_progress_egress(cf, data);
+  if(!result && nghttp2_session_want_read(ctx->h2))
+    result = h2_progress_ingress(cf, data, 0);
+
+  *done = (ctx->conn_closed ||
+           (!result && !nghttp2_session_want_write(ctx->h2) &&
+            !nghttp2_session_want_read(ctx->h2)));
+
+out:
+  CF_DATA_RESTORE(cf, save);
+  cf->shutdown = (result || *done);
+  return result;
+}
+
 static CURLcode http2_data_pause(struct Curl_cfilter *cf,
                                  struct Curl_easy *data,
                                  bool pause)
@@ -2474,10 +2517,10 @@ static CURLcode http2_data_pause(struct Curl_cfilter *cf,
   if(ctx && ctx->h2 && stream) {
     uint32_t window = pause? 0 : stream->local_window_size;
 
-    int rv = nghttp2_session_set_local_window_size(ctx->h2,
-                                                   NGHTTP2_FLAG_NONE,
-                                                   stream->id,
-                                                   window);
+    int rv = (int)nghttp2_session_set_local_window_size(ctx->h2,
+                                                        NGHTTP2_FLAG_NONE,
+                                                        stream->id,
+                                                        (int32_t)window);
     if(rv) {
       failf(data, "nghttp2_session_set_local_window_size() failed: %s(%d)",
             nghttp2_strerror(rv), rv);
@@ -2505,7 +2548,7 @@ static CURLcode http2_data_pause(struct Curl_cfilter *cf,
 #ifdef DEBUGBUILD
     {
       /* read out the stream local window again */
-      uint32_t window2 =
+      uint32_t window2 = (uint32_t)
         nghttp2_session_get_stream_local_window_size(ctx->h2,
                                                      stream->id);
       DEBUGF(infof(data, "HTTP/2 window size is now %u for stream %u",
@@ -2632,6 +2675,7 @@ struct Curl_cftype Curl_cft_nghttp2 = {
   cf_h2_destroy,
   cf_h2_connect,
   cf_h2_close,
+  cf_h2_shutdown,
   Curl_cf_def_get_host,
   cf_h2_adjust_pollset,
   cf_h2_data_pending,
@@ -2729,7 +2773,7 @@ bool Curl_http2_may_switch(struct Curl_easy *data,
      data->state.httpwant == CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE) {
 #ifndef CURL_DISABLE_PROXY
     if(conn->bits.httpproxy && !conn->bits.tunnel_proxy) {
-      /* We don't support HTTP/2 proxies yet. Also it's debatable
+      /* We do not support HTTP/2 proxies yet. Also it is debatable
          whether or not this setting should apply to HTTP/2 proxies. */
       infof(data, "Ignoring HTTP/2 prior knowledge due to proxy");
       return FALSE;
@@ -2753,7 +2797,7 @@ CURLcode Curl_http2_switch(struct Curl_easy *data,
   if(result)
     return result;
 
-  conn->httpversion = 20; /* we know we're on HTTP/2 now */
+  conn->httpversion = 20; /* we know we are on HTTP/2 now */
   conn->bits.multiplex = TRUE; /* at least potentially multiplexed */
   conn->bundle->multiuse = BUNDLE_MULTIPLEX;
   Curl_multi_connchanged(data->multi);
@@ -2777,7 +2821,7 @@ CURLcode Curl_http2_switch_at(struct Curl_cfilter *cf, struct Curl_easy *data)
     return result;
 
   cf_h2 = cf->next;
-  cf->conn->httpversion = 20; /* we know we're on HTTP/2 now */
+  cf->conn->httpversion = 20; /* we know we are on HTTP/2 now */
   cf->conn->bits.multiplex = TRUE; /* at least potentially multiplexed */
   cf->conn->bundle->multiuse = BUNDLE_MULTIPLEX;
   Curl_multi_connchanged(data->multi);
@@ -2830,7 +2874,7 @@ CURLcode Curl_http2_upgrade(struct Curl_easy *data,
           " after upgrade: len=%zu", nread);
   }
 
-  conn->httpversion = 20; /* we know we're on HTTP/2 now */
+  conn->httpversion = 20; /* we know we are on HTTP/2 now */
   conn->bits.multiplex = TRUE; /* at least potentially multiplexed */
   conn->bundle->multiuse = BUNDLE_MULTIPLEX;
   Curl_multi_connchanged(data->multi);
diff --git a/lib/http_aws_sigv4.c b/lib/http_aws_sigv4.c
index 98cc033a0..9e4f72016 100644
--- a/lib/http_aws_sigv4.c
+++ b/lib/http_aws_sigv4.c
@@ -423,6 +423,76 @@ static int compare_func(const void *a, const void *b)
 
 #define MAX_QUERYPAIRS 64
 
+/**
+ * found_equals have a double meaning,
+ * detect if an equal have been found when called from canon_query,
+ * and mark that this function is called to compute the path,
+ * if found_equals is NULL.
+ */
+static CURLcode canon_string(const char *q, size_t len,
+                             struct dynbuf *dq, bool *found_equals)
+{
+  CURLcode result = CURLE_OK;
+
+  for(; len && !result; q++, len--) {
+    if(ISALNUM(*q))
+      result = Curl_dyn_addn(dq, q, 1);
+    else {
+      switch(*q) {
+      case '-':
+      case '.':
+      case '_':
+      case '~':
+        /* allowed as-is */
+        result = Curl_dyn_addn(dq, q, 1);
+        break;
+      case '%':
+        /* uppercase the following if hexadecimal */
+        if(ISXDIGIT(q[1]) && ISXDIGIT(q[2])) {
+          char tmp[3]="%";
+          tmp[1] = Curl_raw_toupper(q[1]);
+          tmp[2] = Curl_raw_toupper(q[2]);
+          result = Curl_dyn_addn(dq, tmp, 3);
+          q += 2;
+          len -= 2;
+        }
+        else
+          /* '%' without a following two-digit hex, encode it */
+          result = Curl_dyn_addn(dq, "%25", 3);
+        break;
+      default: {
+        const char hex[] = "0123456789ABCDEF";
+        char out[3]={'%'};
+
+        if(!found_equals) {
+          /* if found_equals is NULL assuming, been in path */
+          if(*q == '/') {
+            /* allowed as if */
+            result = Curl_dyn_addn(dq, q, 1);
+            break;
+          }
+        }
+        else {
+          /* allowed as-is */
+          if(*q == '=') {
+            result = Curl_dyn_addn(dq, q, 1);
+            *found_equals = true;
+            break;
+          }
+        }
+        /* URL encode */
+        out[1] = hex[((unsigned char)*q)>>4];
+        out[2] = hex[*q & 0xf];
+        result = Curl_dyn_addn(dq, out, 3);
+        break;
+      }
+      }
+    }
+  }
+  return result;
+}
+
+
 static CURLcode canon_query(struct Curl_easy *data,
                             const char *query, struct dynbuf *dq)
 {
@@ -460,54 +530,11 @@ static CURLcode canon_query(struct Curl_easy *data,
 
   ap = &array[0];
   for(i = 0; !result && (i < entry); i++, ap++) {
-    size_t len;
     const char *q = ap->p;
     bool found_equals = false;
     if(!ap->len)
       continue;
-    for(len = ap->len; len && !result; q++, len--) {
-      if(ISALNUM(*q))
-        result = Curl_dyn_addn(dq, q, 1);
-      else {
-        switch(*q) {
-        case '-':
-        case '.':
-        case '_':
-        case '~':
-          /* allowed as-is */
-          result = Curl_dyn_addn(dq, q, 1);
-          break;
-        case '=':
-          /* allowed as-is */
-          result = Curl_dyn_addn(dq, q, 1);
-          found_equals = true;
-          break;
-        case '%':
-          /* uppercase the following if hexadecimal */
-          if(ISXDIGIT(q[1]) && ISXDIGIT(q[2])) {
-            char tmp[3]="%";
-            tmp[1] = Curl_raw_toupper(q[1]);
-            tmp[2] = Curl_raw_toupper(q[2]);
-            result = Curl_dyn_addn(dq, tmp, 3);
-            q += 2;
-            len -= 2;
-          }
-          else
-            /* '%' without a following two-digit hex, encode it */
-            result = Curl_dyn_addn(dq, "%25", 3);
-          break;
-        default: {
-          /* URL encode */
-          const char hex[] = "0123456789ABCDEF";
-          char out[3]={'%'};
-          out[1] = hex[((unsigned char)*q)>>4];
-          out[2] = hex[*q & 0xf];
-          result = Curl_dyn_addn(dq, out, 3);
-          break;
-        }
-        }
-      }
-    }
+    result = canon_string(q, ap->len, dq, &found_equals);
     if(!result && !found_equals) {
       /* queries without value still need an equals */
       result = Curl_dyn_addn(dq, "=", 1);
@@ -540,6 +567,7 @@ CURLcode Curl_output_aws_sigv4(struct Curl_easy *data, bool proxy)
   struct dynbuf canonical_headers;
   struct dynbuf signed_headers;
   struct dynbuf canonical_query;
+  struct dynbuf canonical_path;
   char *date_header = NULL;
   Curl_HttpReq httpreq;
   const char *method = NULL;
@@ -570,6 +598,7 @@ CURLcode Curl_output_aws_sigv4(struct Curl_easy *data, bool proxy)
   Curl_dyn_init(&canonical_headers, CURL_MAX_HTTP_HEADER);
   Curl_dyn_init(&canonical_query, CURL_MAX_HTTP_HEADER);
   Curl_dyn_init(&signed_headers, CURL_MAX_HTTP_HEADER);
+  Curl_dyn_init(&canonical_path, CURL_MAX_HTTP_HEADER);
 
   /*
    * Parameters parsing
@@ -591,7 +620,7 @@ CURLcode Curl_output_aws_sigv4(struct Curl_easy *data, bool proxy)
                ":%" MAX_SIGV4_LEN_TXT "s",
                provider0, provider1, region, service);
   if(!provider0[0]) {
-    failf(data, "first aws-sigv4 provider can't be empty");
+    failf(data, "first aws-sigv4 provider cannot be empty");
     result = CURLE_BAD_FUNCTION_ARGUMENT;
     goto fail;
   }
@@ -665,10 +694,10 @@ CURLcode Curl_output_aws_sigv4(struct Curl_easy *data, bool proxy)
     if(force_timestamp)
       clock = 0;
     else
-      time(&clock);
+      clock = time(NULL);
   }
 #else
-  time(&clock);
+  clock = time(NULL);
 #endif
   result = Curl_gmtime(clock, &tm);
   if(result) {
@@ -698,6 +727,11 @@ CURLcode Curl_output_aws_sigv4(struct Curl_easy *data, bool proxy)
   result = canon_query(data, data->state.up.query, &canonical_query);
   if(result)
     goto fail;
+
+  result = canon_string(data->state.up.path, strlen(data->state.up.path),
+                        &canonical_path, NULL);
+  if(result)
+    goto fail;
   result = CURLE_OUT_OF_MEMORY;
 
   canonical_request =
@@ -708,7 +742,7 @@ CURLcode Curl_output_aws_sigv4(struct Curl_easy *data, bool proxy)
                   "%s\n" /* SignedHeaders */
                   "%.*s",  /* HashedRequestPayload in hex */
                   method,
-                  data->state.up.path,
+                  Curl_dyn_ptr(&canonical_path),
                   Curl_dyn_ptr(&canonical_query) ?
                   Curl_dyn_ptr(&canonical_query) : "",
                   Curl_dyn_ptr(&canonical_headers),
@@ -776,7 +810,7 @@ CURLcode Curl_output_aws_sigv4(struct Curl_easy *data, bool proxy)
                                "SignedHeaders=%s, "
                                "Signature=%s\r\n"
                                /*
-                                * date_header is added here, only if it wasn't
+                                * date_header is added here, only if it was not
                                 * user-specified (using CURLOPT_HTTPHEADER).
                                 * date_header includes \r\n
                                 */
@@ -800,6 +834,7 @@ CURLcode Curl_output_aws_sigv4(struct Curl_easy *data, bool proxy)
 
 fail:
   Curl_dyn_free(&canonical_query);
+  Curl_dyn_free(&canonical_path);
   Curl_dyn_free(&canonical_headers);
   Curl_dyn_free(&signed_headers);
   free(canonical_request);
diff --git a/lib/http_chunks.c b/lib/http_chunks.c
index 48e7e462b..001185da9 100644
--- a/lib/http_chunks.c
+++ b/lib/http_chunks.c
@@ -182,7 +182,7 @@ static CURLcode httpchunk_readwrite(struct Curl_easy *data,
     case CHUNK_LF:
       /* waiting for the LF after a chunk size */
       if(*buf == 0x0a) {
-        /* we're now expecting data to come, unless size was zero! */
+        /* we are now expecting data to come, unless size was zero! */
         if(0 == ch->datasize) {
           ch->state = CHUNK_TRAILER; /* now check for trailers */
         }
@@ -289,9 +289,9 @@ static CURLcode httpchunk_readwrite(struct Curl_easy *data,
             break;
         }
         else {
-          /* no trailer, we're on the final CRLF pair */
+          /* no trailer, we are on the final CRLF pair */
           ch->state = CHUNK_TRAILER_POSTCR;
-          break; /* don't advance the pointer */
+          break; /* do not advance the pointer */
         }
       }
       else {
@@ -344,7 +344,7 @@ static CURLcode httpchunk_readwrite(struct Curl_easy *data,
         blen--;
         (*pconsumed)++;
         /* Record the length of any data left in the end of the buffer
-           even if there's no more chunks to read */
+           even if there is no more chunks to read */
         ch->datasize = blen;
         ch->state = CHUNK_DONE;
         CURL_TRC_WRITE(data, "http_chunk, response complete");
@@ -470,7 +470,7 @@ const struct Curl_cwtype Curl_httpchunk_unencoder = {
   sizeof(struct chunked_writer)
 };
 
-/* max length of a HTTP chunk that we want to generate */
+/* max length of an HTTP chunk that we want to generate */
 #define CURL_CHUNKED_MINLEN   (1024)
 #define CURL_CHUNKED_MAXLEN   (64 * 1024)
 
@@ -659,6 +659,7 @@ const struct Curl_crtype Curl_httpchunk_encoder = {
   Curl_creader_def_resume_from,
   Curl_creader_def_rewind,
   Curl_creader_def_unpause,
+  Curl_creader_def_is_paused,
   Curl_creader_def_done,
   sizeof(struct chunked_reader)
 };
diff --git a/lib/http_chunks.h b/lib/http_chunks.h
index d3ecc36c7..34951ea0f 100644
--- a/lib/http_chunks.h
+++ b/lib/http_chunks.h
@@ -33,12 +33,12 @@ struct connectdata;
 /*
  * The longest possible hexadecimal number we support in a chunked transfer.
  * Neither RFC2616 nor the later HTTP specs define a maximum chunk size.
- * For 64 bit curl_off_t we support 16 digits. For 32 bit, 8 digits.
+ * For 64-bit curl_off_t we support 16 digits. For 32-bit, 8 digits.
  */
 #define CHUNK_MAXNUM_LEN (SIZEOF_CURL_OFF_T * 2)
 
 typedef enum {
-  /* await and buffer all hexadecimal digits until we get one that isn't a
+  /* await and buffer all hexadecimal digits until we get one that is not a
      hexadecimal digit. When done, we go CHUNK_LF */
   CHUNK_HEX,
 
@@ -54,9 +54,9 @@ typedef enum {
      big deal. */
   CHUNK_POSTLF,
 
-  /* Used to mark that we're out of the game.  NOTE: that there's a 'datasize'
-     field in the struct that will tell how many bytes that were not passed to
-     the client in the end of the last buffer! */
+  /* Used to mark that we are out of the game. NOTE: that there is a
+     'datasize' field in the struct that will tell how many bytes that were
+     not passed to the client in the end of the last buffer! */
   CHUNK_STOP,
 
   /* At this point optional trailer headers can be found, unless the next line
diff --git a/lib/http_negotiate.c b/lib/http_negotiate.c
index 4cbe2df42..629de834f 100644
--- a/lib/http_negotiate.c
+++ b/lib/http_negotiate.c
@@ -95,7 +95,7 @@ CURLcode Curl_input_negotiate(struct Curl_easy *data, struct connectdata *conn,
       Curl_http_auth_cleanup_negotiate(conn);
     }
     else if(state != GSS_AUTHNONE) {
-      /* The server rejected our authentication and hasn't supplied any more
+      /* The server rejected our authentication and has not supplied any more
       negotiation mechanisms */
       Curl_http_auth_cleanup_negotiate(conn);
       return CURLE_LOGIN_DENIED;
@@ -218,7 +218,7 @@ CURLcode Curl_output_negotiate(struct Curl_easy *data,
 
   if(*state == GSS_AUTHDONE || *state == GSS_AUTHSUCC) {
     /* connection is already authenticated,
-     * don't send a header in future requests */
+     * do not send a header in future requests */
     authp->done = TRUE;
   }
 
diff --git a/lib/http_ntlm.c b/lib/http_ntlm.c
index 3dccb5cb7..95c138d4f 100644
--- a/lib/http_ntlm.c
+++ b/lib/http_ntlm.c
@@ -200,7 +200,7 @@ CURLcode Curl_output_ntlm(struct Curl_easy *data, bool proxy)
 
   Curl_bufref_init(&ntlmmsg);
 
-  /* connection is already authenticated, don't send a header in future
+  /* connection is already authenticated, do not send a header in future
    * requests so go directly to NTLMSTATE_LAST */
   if(*state == NTLMSTATE_TYPE3)
     *state = NTLMSTATE_LAST;
diff --git a/lib/http_proxy.c b/lib/http_proxy.c
index 7c035d4b6..a5f27f5ce 100644
--- a/lib/http_proxy.c
+++ b/lib/http_proxy.c
@@ -298,6 +298,7 @@ struct Curl_cftype Curl_cft_http_proxy = {
   http_proxy_cf_destroy,
   http_proxy_cf_connect,
   http_proxy_cf_close,
+  Curl_cf_def_shutdown,
   Curl_cf_http_proxy_get_host,
   Curl_cf_def_adjust_pollset,
   Curl_cf_def_data_pending,
diff --git a/lib/idn.c b/lib/idn.c
index c79567254..ef55ddfec 100644
--- a/lib/idn.c
+++ b/lib/idn.c
@@ -54,56 +54,56 @@
 #if defined(USE_APPLE_IDN)
 #include <unicode/uidna.h>
 
+#define MAX_HOST_LENGTH 512
+
 static CURLcode mac_idn_to_ascii(const char *in, char **out)
 {
-  UErrorCode err = U_ZERO_ERROR;
-  UIDNA* idna = uidna_openUTS46(UIDNA_CHECK_BIDI, &err);
-  if(U_FAILURE(err)) {
-    return CURLE_OUT_OF_MEMORY;
-  }
-  else {
-    UIDNAInfo info = UIDNA_INFO_INITIALIZER;
-    char buffer[256] = {0};
-    (void)uidna_nameToASCII_UTF8(idna, in, -1, buffer,
-      sizeof(buffer), &info, &err);
-    uidna_close(idna);
-    if(U_FAILURE(err)) {
-      return CURLE_URL_MALFORMAT;
-    }
-    else {
-      *out = strdup(buffer);
-      if(*out)
-        return CURLE_OK;
-      else
-        return CURLE_OUT_OF_MEMORY;
+  size_t inlen = strlen(in);
+  if(inlen < MAX_HOST_LENGTH) {
+    UErrorCode err = U_ZERO_ERROR;
+    UIDNA* idna = uidna_openUTS46(
+      UIDNA_CHECK_BIDI|UIDNA_NONTRANSITIONAL_TO_ASCII, &err);
+    if(!U_FAILURE(err)) {
+      UIDNAInfo info = UIDNA_INFO_INITIALIZER;
+      char buffer[MAX_HOST_LENGTH] = {0};
+      (void)uidna_nameToASCII_UTF8(idna, in, -1, buffer,
+                                   sizeof(buffer) - 1, &info, &err);
+      uidna_close(idna);
+      if(!U_FAILURE(err)) {
+        *out = strdup(buffer);
+        if(*out)
+          return CURLE_OK;
+        else
+          return CURLE_OUT_OF_MEMORY;
+      }
     }
   }
+  return CURLE_URL_MALFORMAT;
 }
 
 static CURLcode mac_ascii_to_idn(const char *in, char **out)
 {
-  UErrorCode err = U_ZERO_ERROR;
-  UIDNA* idna = uidna_openUTS46(UIDNA_CHECK_BIDI, &err);
-  if(U_FAILURE(err)) {
-    return CURLE_OUT_OF_MEMORY;
-  }
-  else {
-    UIDNAInfo info = UIDNA_INFO_INITIALIZER;
-    char buffer[256] = {0};
-    (void)uidna_nameToUnicodeUTF8(idna, in, -1, buffer,
-      sizeof(buffer), &info, &err);
-    uidna_close(idna);
-    if(U_FAILURE(err)) {
-      return CURLE_URL_MALFORMAT;
-    }
-    else {
-      *out = strdup(buffer);
-      if(*out)
-        return CURLE_OK;
-      else
-        return CURLE_OUT_OF_MEMORY;
+  size_t inlen = strlen(in);
+  if(inlen < MAX_HOST_LENGTH) {
+    UErrorCode err = U_ZERO_ERROR;
+    UIDNA* idna = uidna_openUTS46(
+      UIDNA_CHECK_BIDI|UIDNA_NONTRANSITIONAL_TO_UNICODE, &err);
+    if(!U_FAILURE(err)) {
+      UIDNAInfo info = UIDNA_INFO_INITIALIZER;
+      char buffer[MAX_HOST_LENGTH] = {0};
+      (void)uidna_nameToUnicodeUTF8(idna, in, -1, buffer,
+                                    sizeof(buffer) - 1, &info, &err);
+      uidna_close(idna);
+      if(!U_FAILURE(err)) {
+        *out = strdup(buffer);
+        if(*out)
+          return CURLE_OK;
+        else
+          return CURLE_OUT_OF_MEMORY;
+      }
     }
   }
+  return CURLE_URL_MALFORMAT;
 }
 #endif
 
@@ -207,7 +207,7 @@ bool Curl_is_ASCII_name(const char *hostname)
  * Curl_idn_decode() returns an allocated IDN decoded string if it was
  * possible. NULL on error.
  *
- * CURLE_URL_MALFORMAT - the host name could not be converted
+ * CURLE_URL_MALFORMAT - the hostname could not be converted
  * CURLE_OUT_OF_MEMORY - memory problem
  *
  */
@@ -319,7 +319,7 @@ void Curl_free_idnconverted_hostname(struct hostname *host)
  */
 CURLcode Curl_idnconvert_hostname(struct hostname *host)
 {
-  /* set the name we use to display the host name */
+  /* set the name we use to display the hostname */
   host->dispname = host->name;
 
 #ifdef USE_IDN
diff --git a/lib/imap.c b/lib/imap.c
index f6e98bd81..efe91b14b 100644
--- a/lib/imap.c
+++ b/lib/imap.c
@@ -512,7 +512,7 @@ static CURLcode imap_perform_login(struct Curl_easy *data,
   char *passwd;
 
   /* Check we have a username and password to authenticate with and end the
-     connect phase if we don't */
+     connect phase if we do not */
   if(!data->state.aptr.user) {
     imap_state(data, IMAP_STOP);
 
@@ -612,7 +612,7 @@ static CURLcode imap_perform_authentication(struct Curl_easy *data,
   saslprogress progress;
 
   /* Check if already authenticated OR if there is enough data to authenticate
-     with and end the connect phase if we don't */
+     with and end the connect phase if we do not */
   if(imapc->preauth ||
      !Curl_sasl_can_authenticate(&imapc->sasl, data)) {
     imap_state(data, IMAP_STOP);
@@ -776,7 +776,7 @@ static CURLcode imap_perform_append(struct Curl_easy *data)
   /* Prepare the mime data if some. */
   if(data->set.mimepost.kind != MIMEKIND_NONE) {
     /* Use the whole structure as data. */
-    data->set.mimepost.flags &= ~MIME_BODY_ONLY;
+    data->set.mimepost.flags &= ~(unsigned int)MIME_BODY_ONLY;
 
     /* Add external headers and mime version. */
     curl_mime_headers(&data->set.mimepost, data->set.headers, 0);
@@ -1187,7 +1187,7 @@ static CURLcode imap_state_fetch_resp(struct Curl_easy *data,
         chunk = (size_t)size;
 
       if(!chunk) {
-        /* no size, we're done with the data */
+        /* no size, we are done with the data */
         imap_state(data, IMAP_STOP);
         return CURLE_OK;
       }
@@ -1214,18 +1214,18 @@ static CURLcode imap_state_fetch_resp(struct Curl_easy *data,
 
     if(data->req.bytecount == size)
       /* The entire data is already transferred! */
-      Curl_xfer_setup(data, -1, -1, FALSE, -1);
+      Curl_xfer_setup_nop(data);
     else {
       /* IMAP download */
       data->req.maxdownload = size;
       /* force a recv/send check of this connection, as the data might've been
        read off the socket already */
       data->state.select_bits = CURL_CSELECT_IN;
-      Curl_xfer_setup(data, FIRSTSOCKET, size, FALSE, -1);
+      Curl_xfer_setup1(data, CURL_XFER_RECV, size, FALSE);
     }
   }
   else {
-    /* We don't know how to parse this line */
+    /* We do not know how to parse this line */
     failf(data, "Failed to parse FETCH response.");
     result = CURLE_WEIRD_SERVER_REPLY;
   }
@@ -1269,7 +1269,7 @@ static CURLcode imap_state_append_resp(struct Curl_easy *data, int imapcode,
     Curl_pgrsSetUploadSize(data, data->state.infilesize);
 
     /* IMAP upload */
-    Curl_xfer_setup(data, -1, -1, FALSE, FIRSTSOCKET);
+    Curl_xfer_setup1(data, CURL_XFER_SEND, -1, FALSE);
 
     /* End of DO phase */
     imap_state(data, IMAP_STOP);
@@ -1694,7 +1694,7 @@ static CURLcode imap_dophase_done(struct Curl_easy *data, bool connected)
 
   if(imap->transfer != PPTRANSFER_BODY)
     /* no data to transfer */
-    Curl_xfer_setup(data, -1, -1, FALSE, -1);
+    Curl_xfer_setup_nop(data);
 
   return CURLE_OK;
 }
diff --git a/lib/inet_ntop.c b/lib/inet_ntop.c
index 4520b8715..3a81eef6e 100644
--- a/lib/inet_ntop.c
+++ b/lib/inet_ntop.c
@@ -58,7 +58,7 @@
  *  - uses no statics
  *  - takes a unsigned char* not an in_addr as input
  */
-static char *inet_ntop4 (const unsigned char *src, char *dst, size_t size)
+static char *inet_ntop4(const unsigned char *src, char *dst, size_t size)
 {
   char tmp[sizeof("255.255.255.255")];
   size_t len;
@@ -84,14 +84,14 @@ static char *inet_ntop4 (const unsigned char *src, char *dst, size_t size)
 /*
  * Convert IPv6 binary address into presentation (printable) format.
  */
-static char *inet_ntop6 (const unsigned char *src, char *dst, size_t size)
+static char *inet_ntop6(const unsigned char *src, char *dst, size_t size)
 {
   /*
    * Note that int32_t and int16_t need only be "at least" large enough
-   * to contain a value of the specified size.  On some systems, like
+   * to contain a value of the specified size. On some systems, like
    * Crays, there is no such thing as an integer variable with 16 bits.
    * Keep this in mind if you think this function should have been coded
-   * to use pointer overlays.  All the world's not a VAX.
+   * to use pointer overlays. All the world's not a VAX.
    */
   char tmp[sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")];
   char *tp;
@@ -168,7 +168,7 @@ static char *inet_ntop6 (const unsigned char *src, char *dst, size_t size)
     *tp++ = ':';
   *tp++ = '\0';
 
-  /* Check for overflow, copy, and we're done.
+  /* Check for overflow, copy, and we are done.
    */
   if((size_t)(tp - tmp) > size) {
     errno = ENOSPC;
@@ -185,10 +185,9 @@ static char *inet_ntop6 (const unsigned char *src, char *dst, size_t size)
  * Returns NULL on error and errno set with the specific
  * error, EAFNOSUPPORT or ENOSPC.
  *
- * On Windows we store the error in the thread errno, not
- * in the winsock error code. This is to avoid losing the
- * actual last winsock error. So when this function returns
- * NULL, check errno not SOCKERRNO.
+ * On Windows we store the error in the thread errno, not in the winsock error
+ * code. This is to avoid losing the actual last winsock error. When this
+ * function returns NULL, check errno not SOCKERRNO.
  */
 char *Curl_inet_ntop(int af, const void *src, char *buf, size_t size)
 {
diff --git a/lib/inet_ntop.h b/lib/inet_ntop.h
index 7c3ead434..f592f2525 100644
--- a/lib/inet_ntop.h
+++ b/lib/inet_ntop.h
@@ -32,8 +32,13 @@ char *Curl_inet_ntop(int af, const void *addr, char *buf, size_t size);
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
+#ifdef _WIN32
 #define Curl_inet_ntop(af,addr,buf,size) \
-        inet_ntop(af, addr, buf, (curl_socklen_t)size)
+        inet_ntop(af, addr, buf, size)
+#else
+#define Curl_inet_ntop(af,addr,buf,size) \
+        inet_ntop(af, addr, buf, (curl_socklen_t)(size))
+#endif
 #endif
 
 #endif /* HEADER_CURL_INET_NTOP_H */
diff --git a/lib/inet_pton.c b/lib/inet_pton.c
index 9cfcec1c9..49b923f18 100644
--- a/lib/inet_pton.c
+++ b/lib/inet_pton.c
@@ -48,8 +48,8 @@
 #endif
 
 /*
- * WARNING: Don't even consider trying to compile this on a system where
- * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
+ * WARNING: Do not even consider trying to compile this on a system where
+ * sizeof(int) < 4. sizeof(int) > 4 is fine; all the world's not a VAX.
  */
 
 static int      inet_pton4(const char *src, unsigned char *dst);
@@ -61,12 +61,12 @@ static int      inet_pton6(const char *src, unsigned char *dst);
  *      to network format (which is usually some kind of binary format).
  * return:
  *      1 if the address was valid for the specified address family
- *      0 if the address wasn't valid (`dst' is untouched in this case)
+ *      0 if the address was not valid (`dst' is untouched in this case)
  *      -1 if some other error occurred (`dst' is untouched in this case, too)
  * notice:
  *      On Windows we store the error in the thread errno, not
  *      in the winsock error code. This is to avoid losing the
- *      actual last winsock error. So when this function returns
+ *      actual last winsock error. When this function returns
  *      -1, check errno not SOCKERRNO.
  * author:
  *      Paul Vixie, 1996.
@@ -92,7 +92,7 @@ Curl_inet_pton(int af, const char *src, void *dst)
  * return:
  *      1 if `src' is a valid dotted quad, else 0.
  * notice:
- *      does not touch `dst' unless it's returning 1.
+ *      does not touch `dst' unless it is returning 1.
  * author:
  *      Paul Vixie, 1996.
  */
@@ -147,7 +147,7 @@ inet_pton4(const char *src, unsigned char *dst)
  * return:
  *      1 if `src' is a valid [RFC1884 2.2] address, else 0.
  * notice:
- *      (1) does not touch `dst' unless it's returning 1.
+ *      (1) does not touch `dst' unless it is returning 1.
  *      (2) :: in a full address is silently ignored.
  * credit:
  *      inspired by Mark Andrews.
@@ -221,7 +221,7 @@ inet_pton6(const char *src, unsigned char *dst)
   if(colonp) {
     /*
      * Since some memmove()'s erroneously fail to handle
-     * overlapping regions, we'll do the shift by hand.
+     * overlapping regions, we will do the shift by hand.
      */
     const ssize_t n = tp - colonp;
     ssize_t i;
diff --git a/lib/krb5.c b/lib/krb5.c
index d355665b8..45944cefc 100644
--- a/lib/krb5.c
+++ b/lib/krb5.c
@@ -25,7 +25,7 @@
  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
@@ -169,7 +169,7 @@ krb5_encode(void *app_data, const void *from, int length, int level, void **to)
    * libraries modify the input buffer in gss_wrap()
    */
   dec.value = (void *)from;
-  dec.length = length;
+  dec.length = (size_t)length;
   maj = gss_wrap(&min, *context,
                  level == PROT_PRIVATE,
                  GSS_C_QOP_DEFAULT,
@@ -178,7 +178,7 @@ krb5_encode(void *app_data, const void *from, int length, int level, void **to)
   if(maj != GSS_S_COMPLETE)
     return -1;
 
-  /* malloc a new buffer, in case gss_release_buffer doesn't work as
+  /* malloc a new buffer, in case gss_release_buffer does not work as
      expected */
   *to = malloc(enc.length);
   if(!*to)
@@ -227,7 +227,7 @@ krb5_auth(void *app_data, struct Curl_easy *data, struct connectdata *conn)
 
   /* this loop will execute twice (once for service, once for host) */
   for(;;) {
-    /* this really shouldn't be repeated here, but can't help it */
+    /* this really should not be repeated here, but cannot help it */
     if(service == srv_host) {
       result = ftpsend(data, conn, "AUTH GSSAPI");
       if(result)
@@ -329,7 +329,7 @@ krb5_auth(void *app_data, struct Curl_easy *data, struct connectdata *conn)
           size_t len = Curl_dyn_len(&pp->recvbuf);
           p = Curl_dyn_ptr(&pp->recvbuf);
           if((len < 4) || (p[0] != '2' && p[0] != '3')) {
-            infof(data, "Server didn't accept auth data");
+            infof(data, "Server did not accept auth data");
             ret = AUTH_ERROR;
             break;
           }
@@ -524,7 +524,7 @@ static CURLcode read_data(struct Curl_easy *data, int sockindex,
     return result;
 
   if(len) {
-    len = ntohl(len);
+    len = (int)ntohl((uint32_t)len);
     if(len > CURL_MAX_INPUT_LENGTH)
       return CURLE_TOO_LARGE;
 
@@ -536,7 +536,7 @@ static CURLcode read_data(struct Curl_easy *data, int sockindex,
   do {
     char buffer[1024];
     nread = CURLMIN(len, (int)sizeof(buffer));
-    result = socket_read(data, sockindex, buffer, nread);
+    result = socket_read(data, sockindex, buffer, (size_t)nread);
     if(result)
       return result;
     result = Curl_dyn_addn(&buf->buf, buffer, nread);
@@ -630,7 +630,7 @@ static void do_sec_send(struct Curl_easy *data, struct connectdata *conn,
     else
       prot_level = conn->command_prot;
   }
-  bytes = conn->mech->encode(conn->app_data, from, length, prot_level,
+  bytes = conn->mech->encode(conn->app_data, from, length, (int)prot_level,
                              (void **)&buffer);
   if(!buffer || bytes <= 0)
     return; /* error */
@@ -658,7 +658,7 @@ static void do_sec_send(struct Curl_easy *data, struct connectdata *conn,
     }
   }
   else {
-    htonl_bytes = htonl(bytes);
+    htonl_bytes = (int)htonl((OM_uint32)bytes);
     socket_write(data, fd, &htonl_bytes, sizeof(htonl_bytes));
     socket_write(data, fd, buffer, curlx_sitouz(bytes));
   }
@@ -724,7 +724,7 @@ int Curl_sec_read_msg(struct Curl_easy *data, struct connectdata *conn,
   decoded_len = curlx_uztosi(decoded_sz);
 
   decoded_len = conn->mech->decode(conn->app_data, buf, decoded_len,
-                                   level, conn);
+                                   (int)level, conn);
   if(decoded_len <= 0) {
     free(buf);
     return -1;
@@ -789,7 +789,7 @@ static int sec_set_protection_level(struct Curl_easy *data)
     if(pbsz) {
       /* stick to default value if the check fails */
       if(ISDIGIT(pbsz[5]))
-        buffer_size = atoi(&pbsz[5]);
+        buffer_size = (unsigned int)atoi(&pbsz[5]);
       if(buffer_size < conn->buffer_size)
         conn->buffer_size = buffer_size;
     }
@@ -878,7 +878,7 @@ static CURLcode choose_mech(struct Curl_easy *data, struct connectdata *conn)
 
   if(ret != AUTH_CONTINUE) {
     if(ret != AUTH_OK) {
-      /* Mechanism has dumped the error to stderr, don't error here. */
+      /* Mechanism has dumped the error to stderr, do not error here. */
       return CURLE_USE_SSL_FAILED;
     }
     DEBUGASSERT(ret == AUTH_OK);
diff --git a/lib/ldap.c b/lib/ldap.c
index 678b4d5af..addb9b353 100644
--- a/lib/ldap.c
+++ b/lib/ldap.c
@@ -252,16 +252,17 @@ static int ldap_win_bind_auth(LDAP *server, const char *user,
   }
 
   if(method && user && passwd) {
-    rc = Curl_create_sspi_identity(user, passwd, &cred);
+    CURLcode res = Curl_create_sspi_identity(user, passwd, &cred);
+    rc = (int)res;
     if(!rc) {
-      rc = ldap_bind_s(server, NULL, (TCHAR *)&cred, method);
+      rc = (int)ldap_bind_s(server, NULL, (TCHAR *)&cred, method);
       Curl_sspi_free_identity(&cred);
     }
   }
   else {
     /* proceed with current user credentials */
     method = LDAP_AUTH_NEGOTIATE;
-    rc = ldap_bind_s(server, NULL, NULL, method);
+    rc = (int)ldap_bind_s(server, NULL, NULL, method);
   }
   return rc;
 }
@@ -279,14 +280,14 @@ static int ldap_win_bind(struct Curl_easy *data, LDAP *server,
     inuser = curlx_convert_UTF8_to_tchar((char *) user);
     inpass = curlx_convert_UTF8_to_tchar((char *) passwd);
 
-    rc = ldap_simple_bind_s(server, inuser, inpass);
+    rc = (int)ldap_simple_bind_s(server, inuser, inpass);
 
     curlx_unicodefree(inuser);
     curlx_unicodefree(inpass);
   }
 #if defined(USE_WINDOWS_SSPI)
   else {
-    rc = ldap_win_bind_auth(server, user, passwd, data->set.httpauth);
+    rc = (int)ldap_win_bind_auth(server, user, passwd, data->set.httpauth);
   }
 #endif
 
@@ -296,8 +297,10 @@ static int ldap_win_bind(struct Curl_easy *data, LDAP *server,
 
 #if defined(USE_WIN32_LDAP)
 #define FREE_ON_WINLDAP(x) curlx_unicodefree(x)
+#define curl_ldap_num_t ULONG
 #else
 #define FREE_ON_WINLDAP(x)
+#define curl_ldap_num_t int
 #endif
 
 
@@ -337,7 +340,7 @@ static CURLcode ldap_do(struct Curl_easy *data, bool *done)
   rc = _ldap_url_parse(data, conn, &ludp);
 #endif
   if(rc) {
-    failf(data, "Bad LDAP URL: %s", ldap_err2string(rc));
+    failf(data, "Bad LDAP URL: %s", ldap_err2string((curl_ldap_num_t)rc));
     result = CURLE_URL_MALFORMAT;
     goto quit;
   }
@@ -372,8 +375,8 @@ static CURLcode ldap_do(struct Curl_easy *data, bool *done)
   if(ldap_ssl) {
 #ifdef HAVE_LDAP_SSL
 #ifdef USE_WIN32_LDAP
-    /* Win32 LDAP SDK doesn't support insecure mode without CA! */
-    server = ldap_sslinit(host, conn->primary.remote_port, 1);
+    /* Win32 LDAP SDK does not support insecure mode without CA! */
+    server = ldap_sslinit(host, (curl_ldap_num_t)conn->primary.remote_port, 1);
     ldap_set_option(server, LDAP_OPT_SSL, LDAP_OPT_ON);
 #else
     int ldap_option;
@@ -503,7 +506,7 @@ static CURLcode ldap_do(struct Curl_easy *data, bool *done)
     goto quit;
   }
   else {
-    server = ldap_init(host, conn->primary.remote_port);
+    server = ldap_init(host, (curl_ldap_num_t)conn->primary.remote_port);
     if(!server) {
       failf(data, "LDAP local: Cannot connect to %s:%u",
             conn->host.dispname, conn->primary.remote_port);
@@ -529,7 +532,7 @@ static CURLcode ldap_do(struct Curl_easy *data, bool *done)
   if(rc) {
 #ifdef USE_WIN32_LDAP
     failf(data, "LDAP local: bind via ldap_win_bind %s",
-          ldap_err2string(rc));
+          ldap_err2string((ULONG)rc));
 #else
     failf(data, "LDAP local: bind via ldap_simple_bind_s %s",
           ldap_err2string(rc));
@@ -539,11 +542,12 @@ static CURLcode ldap_do(struct Curl_easy *data, bool *done)
   }
 
   Curl_pgrsSetDownloadCounter(data, 0);
-  rc = ldap_search_s(server, ludp->lud_dn, ludp->lud_scope,
-                     ludp->lud_filter, ludp->lud_attrs, 0, &ldapmsg);
+  rc = (int)ldap_search_s(server, ludp->lud_dn,
+                          (curl_ldap_num_t)ludp->lud_scope,
+                          ludp->lud_filter, ludp->lud_attrs, 0, &ldapmsg);
 
   if(rc && rc != LDAP_SIZELIMIT_EXCEEDED) {
-    failf(data, "LDAP remote: %s", ldap_err2string(rc));
+    failf(data, "LDAP remote: %s", ldap_err2string((curl_ldap_num_t)rc));
     result = CURLE_LDAP_SEARCH_FAILED;
     goto quit;
   }
@@ -754,7 +758,7 @@ quit:
   FREE_ON_WINLDAP(host);
 
   /* no data to transfer */
-  Curl_xfer_setup(data, -1, -1, FALSE, -1);
+  Curl_xfer_setup_nop(data);
   connclose(conn, "LDAP connection always disable reuse");
 
   return result;
diff --git a/lib/libcurl.rc b/lib/libcurl.rc
index daa2d62d8..1ceb4691f 100644
--- a/lib/libcurl.rc
+++ b/lib/libcurl.rc
@@ -32,7 +32,7 @@ VS_VERSION_INFO VERSIONINFO
   FILEVERSION     RC_VERSION
   PRODUCTVERSION  RC_VERSION
   FILEFLAGSMASK   VS_FFI_FILEFLAGSMASK
-#if defined(DEBUGBUILD) || defined(_DEBUG)
+#if defined(DEBUGBUILD) || defined(UNITTESTS) || defined(CURLDEBUG) || defined(_DEBUG)
   FILEFLAGS VS_FF_DEBUG
 #else
   FILEFLAGS 0L
diff --git a/lib/macos.c b/lib/macos.c
index 9e8e76e86..205d30db3 100644
--- a/lib/macos.c
+++ b/lib/macos.c
@@ -38,8 +38,8 @@ CURLcode Curl_macos_init(void)
     /*
      * The automagic conversion from IPv4 literals to IPv6 literals only
      * works if the SCDynamicStoreCopyProxies system function gets called
-     * first. As Curl currently doesn't support system-wide HTTP proxies, we
-     * therefore don't use any value this function might return.
+     * first. As Curl currently does not support system-wide HTTP proxies, we
+     * therefore do not use any value this function might return.
      *
      * This function is only available on macOS and is not needed for
      * IPv4-only builds, hence the conditions for defining
diff --git a/lib/md4.c b/lib/md4.c
index db0028135..f006bdcf0 100644
--- a/lib/md4.c
+++ b/lib/md4.c
@@ -37,6 +37,9 @@
 #if (OPENSSL_VERSION_NUMBER >= 0x30000000L) && !defined(USE_AMISSL)
 /* OpenSSL 3.0.0 marks the MD4 functions as deprecated */
 #define OPENSSL_NO_MD4
+#else
+/* Cover also OPENSSL_NO_MD4 configured in openssl */
+#include <openssl/opensslconf.h>
 #endif
 #endif /* USE_OPENSSL */
 
@@ -217,7 +220,7 @@ static void MD4_Final(unsigned char *result, MD4_CTX *ctx)
 }
 
 #else
-/* When no other crypto library is available, or the crypto library doesn't
+/* When no other crypto library is available, or the crypto library does not
  * support MD4, we use this code segment this implementation of it
  *
  * This is an OpenSSL-compatible implementation of the RSA Data Security, Inc.
@@ -229,8 +232,8 @@ static void MD4_Final(unsigned char *result, MD4_CTX *ctx)
  * Author:
  * Alexander Peslyak, better known as Solar Designer <solar at openwall.com>
  *
- * This software was written by Alexander Peslyak in 2001.  No copyright is
- * claimed, and the software is hereby placed in the public domain.  In case
+ * This software was written by Alexander Peslyak in 2001. No copyright is
+ * claimed, and the software is hereby placed in the public domain. In case
  * this attempt to disclaim copyright and place the software in the public
  * domain is deemed null and void, then the software is Copyright (c) 2001
  * Alexander Peslyak and it is hereby released to the general public under the
@@ -239,19 +242,19 @@ static void MD4_Final(unsigned char *result, MD4_CTX *ctx)
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted.
  *
- * There's ABSOLUTELY NO WARRANTY, express or implied.
+ * There is ABSOLUTELY NO WARRANTY, express or implied.
  *
  * (This is a heavily cut-down "BSD license".)
  *
  * This differs from Colin Plumb's older public domain implementation in that
  * no exactly 32-bit integer data type is required (any 32-bit or wider
- * unsigned integer data type will do), there's no compile-time endianness
- * configuration, and the function prototypes match OpenSSL's.  No code from
+ * unsigned integer data type will do), there is no compile-time endianness
+ * configuration, and the function prototypes match OpenSSL's. No code from
  * Colin Plumb's implementation has been reused; this comment merely compares
  * the properties of the two independent implementations.
  *
  * The primary goals of this implementation are portability and ease of use.
- * It is meant to be fast, but not as fast as possible.  Some known
+ * It is meant to be fast, but not as fast as possible. Some known
  * optimizations are not included to reduce source code size and avoid
  * compile-time configuration.
  */
@@ -277,14 +280,14 @@ static void MD4_Final(unsigned char *result, MD4_CTX *ctx);
  * F and G are optimized compared to their RFC 1320 definitions, with the
  * optimization for F borrowed from Colin Plumb's MD5 implementation.
  */
-#define F(x, y, z)                      ((z) ^ ((x) & ((y) ^ (z))))
-#define G(x, y, z)                      (((x) & ((y) | (z))) | ((y) & (z)))
-#define H(x, y, z)                      ((x) ^ (y) ^ (z))
+#define MD4_F(x, y, z)                  ((z) ^ ((x) & ((y) ^ (z))))
+#define MD4_G(x, y, z)                  (((x) & ((y) | (z))) | ((y) & (z)))
+#define MD4_H(x, y, z)                  ((x) ^ (y) ^ (z))
 
 /*
  * The MD4 transformation for all three rounds.
  */
-#define STEP(f, a, b, c, d, x, s) \
+#define MD4_STEP(f, a, b, c, d, x, s) \
         (a) += f((b), (c), (d)) + (x); \
         (a) = (((a) << (s)) | (((a) & 0xffffffff) >> (32 - (s))));
 
@@ -293,30 +296,31 @@ static void MD4_Final(unsigned char *result, MD4_CTX *ctx);
  * in a properly aligned word in host byte order.
  *
  * The check for little-endian architectures that tolerate unaligned
- * memory accesses is just an optimization.  Nothing will break if it
- * doesn't work.
+ * memory accesses is just an optimization. Nothing will break if it
+ * does not work.
  */
 #if defined(__i386__) || defined(__x86_64__) || defined(__vax__)
-#define SET(n) \
+#define MD4_SET(n) \
         (*(MD4_u32plus *)(void *)&ptr[(n) * 4])
-#define GET(n) \
-        SET(n)
+#define MD4_GET(n) \
+        MD4_SET(n)
 #else
-#define SET(n) \
+#define MD4_SET(n) \
         (ctx->block[(n)] = \
         (MD4_u32plus)ptr[(n) * 4] | \
         ((MD4_u32plus)ptr[(n) * 4 + 1] << 8) | \
         ((MD4_u32plus)ptr[(n) * 4 + 2] << 16) | \
         ((MD4_u32plus)ptr[(n) * 4 + 3] << 24))
-#define GET(n) \
+#define MD4_GET(n) \
         (ctx->block[(n)])
 #endif
 
 /*
  * This processes one or more 64-byte data blocks, but does NOT update
- * the bit counters.  There are no alignment requirements.
+ * the bit counters. There are no alignment requirements.
  */
-static const void *body(MD4_CTX *ctx, const void *data, unsigned long size)
+static const void *my_md4_body(MD4_CTX *ctx,
+                               const void *data, unsigned long size)
 {
   const unsigned char *ptr;
   MD4_u32plus a, b, c, d;
@@ -337,58 +341,58 @@ static const void *body(MD4_CTX *ctx, const void *data, unsigned long size)
     saved_d = d;
 
 /* Round 1 */
-    STEP(F, a, b, c, d, SET(0), 3)
-    STEP(F, d, a, b, c, SET(1), 7)
-    STEP(F, c, d, a, b, SET(2), 11)
-    STEP(F, b, c, d, a, SET(3), 19)
-    STEP(F, a, b, c, d, SET(4), 3)
-    STEP(F, d, a, b, c, SET(5), 7)
-    STEP(F, c, d, a, b, SET(6), 11)
-    STEP(F, b, c, d, a, SET(7), 19)
-    STEP(F, a, b, c, d, SET(8), 3)
-    STEP(F, d, a, b, c, SET(9), 7)
-    STEP(F, c, d, a, b, SET(10), 11)
-    STEP(F, b, c, d, a, SET(11), 19)
-    STEP(F, a, b, c, d, SET(12), 3)
-    STEP(F, d, a, b, c, SET(13), 7)
-    STEP(F, c, d, a, b, SET(14), 11)
-    STEP(F, b, c, d, a, SET(15), 19)
+    MD4_STEP(MD4_F, a, b, c, d, MD4_SET(0), 3)
+    MD4_STEP(MD4_F, d, a, b, c, MD4_SET(1), 7)
+    MD4_STEP(MD4_F, c, d, a, b, MD4_SET(2), 11)
+    MD4_STEP(MD4_F, b, c, d, a, MD4_SET(3), 19)
+    MD4_STEP(MD4_F, a, b, c, d, MD4_SET(4), 3)
+    MD4_STEP(MD4_F, d, a, b, c, MD4_SET(5), 7)
+    MD4_STEP(MD4_F, c, d, a, b, MD4_SET(6), 11)
+    MD4_STEP(MD4_F, b, c, d, a, MD4_SET(7), 19)
+    MD4_STEP(MD4_F, a, b, c, d, MD4_SET(8), 3)
+    MD4_STEP(MD4_F, d, a, b, c, MD4_SET(9), 7)
+    MD4_STEP(MD4_F, c, d, a, b, MD4_SET(10), 11)
+    MD4_STEP(MD4_F, b, c, d, a, MD4_SET(11), 19)
+    MD4_STEP(MD4_F, a, b, c, d, MD4_SET(12), 3)
+    MD4_STEP(MD4_F, d, a, b, c, MD4_SET(13), 7)
+    MD4_STEP(MD4_F, c, d, a, b, MD4_SET(14), 11)
+    MD4_STEP(MD4_F, b, c, d, a, MD4_SET(15), 19)
 
 /* Round 2 */
-    STEP(G, a, b, c, d, GET(0) + 0x5a827999, 3)
-    STEP(G, d, a, b, c, GET(4) + 0x5a827999, 5)
-    STEP(G, c, d, a, b, GET(8) + 0x5a827999, 9)
-    STEP(G, b, c, d, a, GET(12) + 0x5a827999, 13)
-    STEP(G, a, b, c, d, GET(1) + 0x5a827999, 3)
-    STEP(G, d, a, b, c, GET(5) + 0x5a827999, 5)
-    STEP(G, c, d, a, b, GET(9) + 0x5a827999, 9)
-    STEP(G, b, c, d, a, GET(13) + 0x5a827999, 13)
-    STEP(G, a, b, c, d, GET(2) + 0x5a827999, 3)
-    STEP(G, d, a, b, c, GET(6) + 0x5a827999, 5)
-    STEP(G, c, d, a, b, GET(10) + 0x5a827999, 9)
-    STEP(G, b, c, d, a, GET(14) + 0x5a827999, 13)
-    STEP(G, a, b, c, d, GET(3) + 0x5a827999, 3)
-    STEP(G, d, a, b, c, GET(7) + 0x5a827999, 5)
-    STEP(G, c, d, a, b, GET(11) + 0x5a827999, 9)
-    STEP(G, b, c, d, a, GET(15) + 0x5a827999, 13)
+    MD4_STEP(MD4_G, a, b, c, d, MD4_GET(0) + 0x5a827999, 3)
+    MD4_STEP(MD4_G, d, a, b, c, MD4_GET(4) + 0x5a827999, 5)
+    MD4_STEP(MD4_G, c, d, a, b, MD4_GET(8) + 0x5a827999, 9)
+    MD4_STEP(MD4_G, b, c, d, a, MD4_GET(12) + 0x5a827999, 13)
+    MD4_STEP(MD4_G, a, b, c, d, MD4_GET(1) + 0x5a827999, 3)
+    MD4_STEP(MD4_G, d, a, b, c, MD4_GET(5) + 0x5a827999, 5)
+    MD4_STEP(MD4_G, c, d, a, b, MD4_GET(9) + 0x5a827999, 9)
+    MD4_STEP(MD4_G, b, c, d, a, MD4_GET(13) + 0x5a827999, 13)
+    MD4_STEP(MD4_G, a, b, c, d, MD4_GET(2) + 0x5a827999, 3)
+    MD4_STEP(MD4_G, d, a, b, c, MD4_GET(6) + 0x5a827999, 5)
+    MD4_STEP(MD4_G, c, d, a, b, MD4_GET(10) + 0x5a827999, 9)
+    MD4_STEP(MD4_G, b, c, d, a, MD4_GET(14) + 0x5a827999, 13)
+    MD4_STEP(MD4_G, a, b, c, d, MD4_GET(3) + 0x5a827999, 3)
+    MD4_STEP(MD4_G, d, a, b, c, MD4_GET(7) + 0x5a827999, 5)
+    MD4_STEP(MD4_G, c, d, a, b, MD4_GET(11) + 0x5a827999, 9)
+    MD4_STEP(MD4_G, b, c, d, a, MD4_GET(15) + 0x5a827999, 13)
 
 /* Round 3 */
-    STEP(H, a, b, c, d, GET(0) + 0x6ed9eba1, 3)
-    STEP(H, d, a, b, c, GET(8) + 0x6ed9eba1, 9)
-    STEP(H, c, d, a, b, GET(4) + 0x6ed9eba1, 11)
-    STEP(H, b, c, d, a, GET(12) + 0x6ed9eba1, 15)
-    STEP(H, a, b, c, d, GET(2) + 0x6ed9eba1, 3)
-    STEP(H, d, a, b, c, GET(10) + 0x6ed9eba1, 9)
-    STEP(H, c, d, a, b, GET(6) + 0x6ed9eba1, 11)
-    STEP(H, b, c, d, a, GET(14) + 0x6ed9eba1, 15)
-    STEP(H, a, b, c, d, GET(1) + 0x6ed9eba1, 3)
-    STEP(H, d, a, b, c, GET(9) + 0x6ed9eba1, 9)
-    STEP(H, c, d, a, b, GET(5) + 0x6ed9eba1, 11)
-    STEP(H, b, c, d, a, GET(13) + 0x6ed9eba1, 15)
-    STEP(H, a, b, c, d, GET(3) + 0x6ed9eba1, 3)
-    STEP(H, d, a, b, c, GET(11) + 0x6ed9eba1, 9)
-    STEP(H, c, d, a, b, GET(7) + 0x6ed9eba1, 11)
-    STEP(H, b, c, d, a, GET(15) + 0x6ed9eba1, 15)
+    MD4_STEP(MD4_H, a, b, c, d, MD4_GET(0) + 0x6ed9eba1, 3)
+    MD4_STEP(MD4_H, d, a, b, c, MD4_GET(8) + 0x6ed9eba1, 9)
+    MD4_STEP(MD4_H, c, d, a, b, MD4_GET(4) + 0x6ed9eba1, 11)
+    MD4_STEP(MD4_H, b, c, d, a, MD4_GET(12) + 0x6ed9eba1, 15)
+    MD4_STEP(MD4_H, a, b, c, d, MD4_GET(2) + 0x6ed9eba1, 3)
+    MD4_STEP(MD4_H, d, a, b, c, MD4_GET(10) + 0x6ed9eba1, 9)
+    MD4_STEP(MD4_H, c, d, a, b, MD4_GET(6) + 0x6ed9eba1, 11)
+    MD4_STEP(MD4_H, b, c, d, a, MD4_GET(14) + 0x6ed9eba1, 15)
+    MD4_STEP(MD4_H, a, b, c, d, MD4_GET(1) + 0x6ed9eba1, 3)
+    MD4_STEP(MD4_H, d, a, b, c, MD4_GET(9) + 0x6ed9eba1, 9)
+    MD4_STEP(MD4_H, c, d, a, b, MD4_GET(5) + 0x6ed9eba1, 11)
+    MD4_STEP(MD4_H, b, c, d, a, MD4_GET(13) + 0x6ed9eba1, 15)
+    MD4_STEP(MD4_H, a, b, c, d, MD4_GET(3) + 0x6ed9eba1, 3)
+    MD4_STEP(MD4_H, d, a, b, c, MD4_GET(11) + 0x6ed9eba1, 9)
+    MD4_STEP(MD4_H, c, d, a, b, MD4_GET(7) + 0x6ed9eba1, 11)
+    MD4_STEP(MD4_H, b, c, d, a, MD4_GET(15) + 0x6ed9eba1, 15)
 
     a += saved_a;
     b += saved_b;
@@ -442,11 +446,11 @@ static void MD4_Update(MD4_CTX *ctx, const void *data, unsigned long size)
     memcpy(&ctx->buffer[used], data, available);
     data = (const unsigned char *)data + available;
     size -= available;
-    body(ctx, ctx->buffer, 64);
+    my_md4_body(ctx, ctx->buffer, 64);
   }
 
   if(size >= 64) {
-    data = body(ctx, data, size & ~(unsigned long)0x3f);
+    data = my_md4_body(ctx, data, size & ~(unsigned long)0x3f);
     size &= 0x3f;
   }
 
@@ -465,7 +469,7 @@ static void MD4_Final(unsigned char *result, MD4_CTX *ctx)
 
   if(available < 8) {
     memset(&ctx->buffer[used], 0, available);
-    body(ctx, ctx->buffer, 64);
+    my_md4_body(ctx, ctx->buffer, 64);
     used = 0;
     available = 64;
   }
@@ -482,7 +486,7 @@ static void MD4_Final(unsigned char *result, MD4_CTX *ctx)
   ctx->buffer[62] = curlx_ultouc((ctx->hi >> 16)&0xff);
   ctx->buffer[63] = curlx_ultouc(ctx->hi >> 24);
 
-  body(ctx, ctx->buffer, 64);
+  my_md4_body(ctx, ctx->buffer, 64);
 
   result[0] = curlx_ultouc((ctx->a)&0xff);
   result[1] = curlx_ultouc((ctx->a >> 8)&0xff);
diff --git a/lib/md5.c b/lib/md5.c
index 01415af91..7b51429b4 100644
--- a/lib/md5.c
+++ b/lib/md5.c
@@ -172,7 +172,7 @@ static void my_md5_final(unsigned char *digest, my_md5_ctx *ctx)
 
 /* For Apple operating systems: CommonCrypto has the functions we need.
    These functions are available on Tiger and later, as well as iOS 2.0
-   and later. If you're building for an older cat, well, sorry.
+   and later. If you are building for an older cat, well, sorry.
 
    Declaring the functions as static like this seems to be a bit more
    reliable than defining COMMON_DIGEST_FOR_OPENSSL on older cats. */
@@ -254,7 +254,7 @@ static void my_md5_final(unsigned char *digest, my_md5_ctx *ctx)
  * Author:
  * Alexander Peslyak, better known as Solar Designer <solar at openwall.com>
  *
- * This software was written by Alexander Peslyak in 2001.  No copyright is
+ * This software was written by Alexander Peslyak in 2001. No copyright is
  * claimed, and the software is hereby placed in the public domain.
  * In case this attempt to disclaim copyright and place the software in the
  * public domain is deemed null and void, then the software is
@@ -264,19 +264,19 @@ static void my_md5_final(unsigned char *digest, my_md5_ctx *ctx)
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted.
  *
- * There's ABSOLUTELY NO WARRANTY, express or implied.
+ * There is ABSOLUTELY NO WARRANTY, express or implied.
  *
  * (This is a heavily cut-down "BSD license".)
  *
  * This differs from Colin Plumb's older public domain implementation in that
  * no exactly 32-bit integer data type is required (any 32-bit or wider
- * unsigned integer data type will do), there's no compile-time endianness
- * configuration, and the function prototypes match OpenSSL's.  No code from
+ * unsigned integer data type will do), there is no compile-time endianness
+ * configuration, and the function prototypes match OpenSSL's. No code from
  * Colin Plumb's implementation has been reused; this comment merely compares
  * the properties of the two independent implementations.
  *
  * The primary goals of this implementation are portability and ease of use.
- * It is meant to be fast, but not as fast as possible.  Some known
+ * It is meant to be fast, but not as fast as possible. Some known
  * optimizations are not included to reduce source code size and avoid
  * compile-time configuration.
  */
@@ -304,16 +304,16 @@ static void my_md5_final(unsigned char *result, my_md5_ctx *ctx);
  * architectures that lack an AND-NOT instruction, just like in Colin Plumb's
  * implementation.
  */
-#define F(x, y, z)                      ((z) ^ ((x) & ((y) ^ (z))))
-#define G(x, y, z)                      ((y) ^ ((z) & ((x) ^ (y))))
-#define H(x, y, z)                      (((x) ^ (y)) ^ (z))
-#define H2(x, y, z)                     ((x) ^ ((y) ^ (z)))
-#define I(x, y, z)                      ((y) ^ ((x) | ~(z)))
+#define MD5_F(x, y, z)                  ((z) ^ ((x) & ((y) ^ (z))))
+#define MD5_G(x, y, z)                  ((y) ^ ((z) & ((x) ^ (y))))
+#define MD5_H(x, y, z)                  (((x) ^ (y)) ^ (z))
+#define MD5_H2(x, y, z)                 ((x) ^ ((y) ^ (z)))
+#define MD5_I(x, y, z)                  ((y) ^ ((x) | ~(z)))
 
 /*
  * The MD5 transformation for all four rounds.
  */
-#define STEP(f, a, b, c, d, x, t, s) \
+#define MD5_STEP(f, a, b, c, d, x, t, s) \
         (a) += f((b), (c), (d)) + (x) + (t); \
         (a) = (((a) << (s)) | (((a) & 0xffffffff) >> (32 - (s)))); \
         (a) += (b);
@@ -323,30 +323,31 @@ static void my_md5_final(unsigned char *result, my_md5_ctx *ctx);
  * in a properly aligned word in host byte order.
  *
  * The check for little-endian architectures that tolerate unaligned
- * memory accesses is just an optimization.  Nothing will break if it
- * doesn't work.
+ * memory accesses is just an optimization. Nothing will break if it
+ * does not work.
  */
 #if defined(__i386__) || defined(__x86_64__) || defined(__vax__)
-#define SET(n) \
+#define MD5_SET(n) \
         (*(MD5_u32plus *)(void *)&ptr[(n) * 4])
-#define GET(n) \
-        SET(n)
+#define MD5_GET(n) \
+        MD5_SET(n)
 #else
-#define SET(n) \
+#define MD5_SET(n) \
         (ctx->block[(n)] = \
         (MD5_u32plus)ptr[(n) * 4] | \
         ((MD5_u32plus)ptr[(n) * 4 + 1] << 8) | \
         ((MD5_u32plus)ptr[(n) * 4 + 2] << 16) | \
         ((MD5_u32plus)ptr[(n) * 4 + 3] << 24))
-#define GET(n) \
+#define MD5_GET(n) \
         (ctx->block[(n)])
 #endif
 
 /*
  * This processes one or more 64-byte data blocks, but does NOT update
- * the bit counters.  There are no alignment requirements.
+ * the bit counters. There are no alignment requirements.
  */
-static const void *body(my_md5_ctx *ctx, const void *data, unsigned long size)
+static const void *my_md5_body(my_md5_ctx *ctx,
+                               const void *data, unsigned long size)
 {
   const unsigned char *ptr;
   MD5_u32plus a, b, c, d;
@@ -367,76 +368,76 @@ static const void *body(my_md5_ctx *ctx, const void *data, unsigned long size)
     saved_d = d;
 
 /* Round 1 */
-    STEP(F, a, b, c, d, SET(0), 0xd76aa478, 7)
-    STEP(F, d, a, b, c, SET(1), 0xe8c7b756, 12)
-    STEP(F, c, d, a, b, SET(2), 0x242070db, 17)
-    STEP(F, b, c, d, a, SET(3), 0xc1bdceee, 22)
-    STEP(F, a, b, c, d, SET(4), 0xf57c0faf, 7)
-    STEP(F, d, a, b, c, SET(5), 0x4787c62a, 12)
-    STEP(F, c, d, a, b, SET(6), 0xa8304613, 17)
-    STEP(F, b, c, d, a, SET(7), 0xfd469501, 22)
-    STEP(F, a, b, c, d, SET(8), 0x698098d8, 7)
-    STEP(F, d, a, b, c, SET(9), 0x8b44f7af, 12)
-    STEP(F, c, d, a, b, SET(10), 0xffff5bb1, 17)
-    STEP(F, b, c, d, a, SET(11), 0x895cd7be, 22)
-    STEP(F, a, b, c, d, SET(12), 0x6b901122, 7)
-    STEP(F, d, a, b, c, SET(13), 0xfd987193, 12)
-    STEP(F, c, d, a, b, SET(14), 0xa679438e, 17)
-    STEP(F, b, c, d, a, SET(15), 0x49b40821, 22)
+    MD5_STEP(MD5_F, a, b, c, d, MD5_SET(0), 0xd76aa478, 7)
+    MD5_STEP(MD5_F, d, a, b, c, MD5_SET(1), 0xe8c7b756, 12)
+    MD5_STEP(MD5_F, c, d, a, b, MD5_SET(2), 0x242070db, 17)
+    MD5_STEP(MD5_F, b, c, d, a, MD5_SET(3), 0xc1bdceee, 22)
+    MD5_STEP(MD5_F, a, b, c, d, MD5_SET(4), 0xf57c0faf, 7)
+    MD5_STEP(MD5_F, d, a, b, c, MD5_SET(5), 0x4787c62a, 12)
+    MD5_STEP(MD5_F, c, d, a, b, MD5_SET(6), 0xa8304613, 17)
+    MD5_STEP(MD5_F, b, c, d, a, MD5_SET(7), 0xfd469501, 22)
+    MD5_STEP(MD5_F, a, b, c, d, MD5_SET(8), 0x698098d8, 7)
+    MD5_STEP(MD5_F, d, a, b, c, MD5_SET(9), 0x8b44f7af, 12)
+    MD5_STEP(MD5_F, c, d, a, b, MD5_SET(10), 0xffff5bb1, 17)
+    MD5_STEP(MD5_F, b, c, d, a, MD5_SET(11), 0x895cd7be, 22)
+    MD5_STEP(MD5_F, a, b, c, d, MD5_SET(12), 0x6b901122, 7)
+    MD5_STEP(MD5_F, d, a, b, c, MD5_SET(13), 0xfd987193, 12)
+    MD5_STEP(MD5_F, c, d, a, b, MD5_SET(14), 0xa679438e, 17)
+    MD5_STEP(MD5_F, b, c, d, a, MD5_SET(15), 0x49b40821, 22)
 
 /* Round 2 */
-    STEP(G, a, b, c, d, GET(1), 0xf61e2562, 5)
-    STEP(G, d, a, b, c, GET(6), 0xc040b340, 9)
-    STEP(G, c, d, a, b, GET(11), 0x265e5a51, 14)
-    STEP(G, b, c, d, a, GET(0), 0xe9b6c7aa, 20)
-    STEP(G, a, b, c, d, GET(5), 0xd62f105d, 5)
-    STEP(G, d, a, b, c, GET(10), 0x02441453, 9)
-    STEP(G, c, d, a, b, GET(15), 0xd8a1e681, 14)
-    STEP(G, b, c, d, a, GET(4), 0xe7d3fbc8, 20)
-    STEP(G, a, b, c, d, GET(9), 0x21e1cde6, 5)
-    STEP(G, d, a, b, c, GET(14), 0xc33707d6, 9)
-    STEP(G, c, d, a, b, GET(3), 0xf4d50d87, 14)
-    STEP(G, b, c, d, a, GET(8), 0x455a14ed, 20)
-    STEP(G, a, b, c, d, GET(13), 0xa9e3e905, 5)
-    STEP(G, d, a, b, c, GET(2), 0xfcefa3f8, 9)
-    STEP(G, c, d, a, b, GET(7), 0x676f02d9, 14)
-    STEP(G, b, c, d, a, GET(12), 0x8d2a4c8a, 20)
+    MD5_STEP(MD5_G, a, b, c, d, MD5_GET(1), 0xf61e2562, 5)
+    MD5_STEP(MD5_G, d, a, b, c, MD5_GET(6), 0xc040b340, 9)
+    MD5_STEP(MD5_G, c, d, a, b, MD5_GET(11), 0x265e5a51, 14)
+    MD5_STEP(MD5_G, b, c, d, a, MD5_GET(0), 0xe9b6c7aa, 20)
+    MD5_STEP(MD5_G, a, b, c, d, MD5_GET(5), 0xd62f105d, 5)
+    MD5_STEP(MD5_G, d, a, b, c, MD5_GET(10), 0x02441453, 9)
+    MD5_STEP(MD5_G, c, d, a, b, MD5_GET(15), 0xd8a1e681, 14)
+    MD5_STEP(MD5_G, b, c, d, a, MD5_GET(4), 0xe7d3fbc8, 20)
+    MD5_STEP(MD5_G, a, b, c, d, MD5_GET(9), 0x21e1cde6, 5)
+    MD5_STEP(MD5_G, d, a, b, c, MD5_GET(14), 0xc33707d6, 9)
+    MD5_STEP(MD5_G, c, d, a, b, MD5_GET(3), 0xf4d50d87, 14)
+    MD5_STEP(MD5_G, b, c, d, a, MD5_GET(8), 0x455a14ed, 20)
+    MD5_STEP(MD5_G, a, b, c, d, MD5_GET(13), 0xa9e3e905, 5)
+    MD5_STEP(MD5_G, d, a, b, c, MD5_GET(2), 0xfcefa3f8, 9)
+    MD5_STEP(MD5_G, c, d, a, b, MD5_GET(7), 0x676f02d9, 14)
+    MD5_STEP(MD5_G, b, c, d, a, MD5_GET(12), 0x8d2a4c8a, 20)
 
 /* Round 3 */
-    STEP(H, a, b, c, d, GET(5), 0xfffa3942, 4)
-    STEP(H2, d, a, b, c, GET(8), 0x8771f681, 11)
-    STEP(H, c, d, a, b, GET(11), 0x6d9d6122, 16)
-    STEP(H2, b, c, d, a, GET(14), 0xfde5380c, 23)
-    STEP(H, a, b, c, d, GET(1), 0xa4beea44, 4)
-    STEP(H2, d, a, b, c, GET(4), 0x4bdecfa9, 11)
-    STEP(H, c, d, a, b, GET(7), 0xf6bb4b60, 16)
-    STEP(H2, b, c, d, a, GET(10), 0xbebfbc70, 23)
-    STEP(H, a, b, c, d, GET(13), 0x289b7ec6, 4)
-    STEP(H2, d, a, b, c, GET(0), 0xeaa127fa, 11)
-    STEP(H, c, d, a, b, GET(3), 0xd4ef3085, 16)
-    STEP(H2, b, c, d, a, GET(6), 0x04881d05, 23)
-    STEP(H, a, b, c, d, GET(9), 0xd9d4d039, 4)
-    STEP(H2, d, a, b, c, GET(12), 0xe6db99e5, 11)
-    STEP(H, c, d, a, b, GET(15), 0x1fa27cf8, 16)
-    STEP(H2, b, c, d, a, GET(2), 0xc4ac5665, 23)
+    MD5_STEP(MD5_H, a, b, c, d, MD5_GET(5), 0xfffa3942, 4)
+    MD5_STEP(MD5_H2, d, a, b, c, MD5_GET(8), 0x8771f681, 11)
+    MD5_STEP(MD5_H, c, d, a, b, MD5_GET(11), 0x6d9d6122, 16)
+    MD5_STEP(MD5_H2, b, c, d, a, MD5_GET(14), 0xfde5380c, 23)
+    MD5_STEP(MD5_H, a, b, c, d, MD5_GET(1), 0xa4beea44, 4)
+    MD5_STEP(MD5_H2, d, a, b, c, MD5_GET(4), 0x4bdecfa9, 11)
+    MD5_STEP(MD5_H, c, d, a, b, MD5_GET(7), 0xf6bb4b60, 16)
+    MD5_STEP(MD5_H2, b, c, d, a, MD5_GET(10), 0xbebfbc70, 23)
+    MD5_STEP(MD5_H, a, b, c, d, MD5_GET(13), 0x289b7ec6, 4)
+    MD5_STEP(MD5_H2, d, a, b, c, MD5_GET(0), 0xeaa127fa, 11)
+    MD5_STEP(MD5_H, c, d, a, b, MD5_GET(3), 0xd4ef3085, 16)
+    MD5_STEP(MD5_H2, b, c, d, a, MD5_GET(6), 0x04881d05, 23)
+    MD5_STEP(MD5_H, a, b, c, d, MD5_GET(9), 0xd9d4d039, 4)
+    MD5_STEP(MD5_H2, d, a, b, c, MD5_GET(12), 0xe6db99e5, 11)
+    MD5_STEP(MD5_H, c, d, a, b, MD5_GET(15), 0x1fa27cf8, 16)
+    MD5_STEP(MD5_H2, b, c, d, a, MD5_GET(2), 0xc4ac5665, 23)
 
 /* Round 4 */
-    STEP(I, a, b, c, d, GET(0), 0xf4292244, 6)
-    STEP(I, d, a, b, c, GET(7), 0x432aff97, 10)
-    STEP(I, c, d, a, b, GET(14), 0xab9423a7, 15)
-    STEP(I, b, c, d, a, GET(5), 0xfc93a039, 21)
-    STEP(I, a, b, c, d, GET(12), 0x655b59c3, 6)
-    STEP(I, d, a, b, c, GET(3), 0x8f0ccc92, 10)
-    STEP(I, c, d, a, b, GET(10), 0xffeff47d, 15)
-    STEP(I, b, c, d, a, GET(1), 0x85845dd1, 21)
-    STEP(I, a, b, c, d, GET(8), 0x6fa87e4f, 6)
-    STEP(I, d, a, b, c, GET(15), 0xfe2ce6e0, 10)
-    STEP(I, c, d, a, b, GET(6), 0xa3014314, 15)
-    STEP(I, b, c, d, a, GET(13), 0x4e0811a1, 21)
-    STEP(I, a, b, c, d, GET(4), 0xf7537e82, 6)
-    STEP(I, d, a, b, c, GET(11), 0xbd3af235, 10)
-    STEP(I, c, d, a, b, GET(2), 0x2ad7d2bb, 15)
-    STEP(I, b, c, d, a, GET(9), 0xeb86d391, 21)
+    MD5_STEP(MD5_I, a, b, c, d, MD5_GET(0), 0xf4292244, 6)
+    MD5_STEP(MD5_I, d, a, b, c, MD5_GET(7), 0x432aff97, 10)
+    MD5_STEP(MD5_I, c, d, a, b, MD5_GET(14), 0xab9423a7, 15)
+    MD5_STEP(MD5_I, b, c, d, a, MD5_GET(5), 0xfc93a039, 21)
+    MD5_STEP(MD5_I, a, b, c, d, MD5_GET(12), 0x655b59c3, 6)
+    MD5_STEP(MD5_I, d, a, b, c, MD5_GET(3), 0x8f0ccc92, 10)
+    MD5_STEP(MD5_I, c, d, a, b, MD5_GET(10), 0xffeff47d, 15)
+    MD5_STEP(MD5_I, b, c, d, a, MD5_GET(1), 0x85845dd1, 21)
+    MD5_STEP(MD5_I, a, b, c, d, MD5_GET(8), 0x6fa87e4f, 6)
+    MD5_STEP(MD5_I, d, a, b, c, MD5_GET(15), 0xfe2ce6e0, 10)
+    MD5_STEP(MD5_I, c, d, a, b, MD5_GET(6), 0xa3014314, 15)
+    MD5_STEP(MD5_I, b, c, d, a, MD5_GET(13), 0x4e0811a1, 21)
+    MD5_STEP(MD5_I, a, b, c, d, MD5_GET(4), 0xf7537e82, 6)
+    MD5_STEP(MD5_I, d, a, b, c, MD5_GET(11), 0xbd3af235, 10)
+    MD5_STEP(MD5_I, c, d, a, b, MD5_GET(2), 0x2ad7d2bb, 15)
+    MD5_STEP(MD5_I, b, c, d, a, MD5_GET(9), 0xeb86d391, 21)
 
     a += saved_a;
     b += saved_b;
@@ -492,11 +493,11 @@ static void my_md5_update(my_md5_ctx *ctx, const void *data,
     memcpy(&ctx->buffer[used], data, available);
     data = (const unsigned char *)data + available;
     size -= available;
-    body(ctx, ctx->buffer, 64);
+    my_md5_body(ctx, ctx->buffer, 64);
   }
 
   if(size >= 64) {
-    data = body(ctx, data, size & ~(unsigned long)0x3f);
+    data = my_md5_body(ctx, data, size & ~(unsigned long)0x3f);
     size &= 0x3f;
   }
 
@@ -515,7 +516,7 @@ static void my_md5_final(unsigned char *result, my_md5_ctx *ctx)
 
   if(available < 8) {
     memset(&ctx->buffer[used], 0, available);
-    body(ctx, ctx->buffer, 64);
+    my_md5_body(ctx, ctx->buffer, 64);
     used = 0;
     available = 64;
   }
@@ -532,7 +533,7 @@ static void my_md5_final(unsigned char *result, my_md5_ctx *ctx)
   ctx->buffer[62] = curlx_ultouc((ctx->hi >> 16)&0xff);
   ctx->buffer[63] = curlx_ultouc(ctx->hi >> 24);
 
-  body(ctx, ctx->buffer, 64);
+  my_md5_body(ctx, ctx->buffer, 64);
 
   result[0] = curlx_ultouc((ctx->a)&0xff);
   result[1] = curlx_ultouc((ctx->a >> 8)&0xff);
diff --git a/lib/memdebug.c b/lib/memdebug.c
index fce933a32..57fe591ed 100644
--- a/lib/memdebug.c
+++ b/lib/memdebug.c
@@ -30,7 +30,7 @@
 
 #include "urldata.h"
 
-#define MEMDEBUG_NODEFINES /* don't redefine the standard functions */
+#define MEMDEBUG_NODEFINES /* do not redefine the standard functions */
 
 /* The last 3 #include files should be in this order */
 #include "curl_printf.h"
@@ -44,8 +44,8 @@ struct memdebug {
     double d;
     void *p;
   } mem[1];
-  /* I'm hoping this is the thing with the strictest alignment
-   * requirements.  That also means we waste some space :-( */
+  /* I am hoping this is the thing with the strictest alignment
+   * requirements. That also means we waste some space :-( */
 };
 
 /*
@@ -53,7 +53,7 @@ struct memdebug {
  * remain so. For advanced analysis, record a log file and write perl scripts
  * to analyze them!
  *
- * Don't use these with multithreaded test programs!
+ * Do not use these with multithreaded test programs!
  */
 
 FILE *curl_dbg_logfile = NULL;
@@ -75,7 +75,7 @@ static void curl_dbg_cleanup(void)
   curl_dbg_logfile = NULL;
 }
 
-/* this sets the log file name */
+/* this sets the log filename */
 void curl_dbg_memdebug(const char *logname)
 {
   if(!curl_dbg_logfile) {
@@ -84,7 +84,7 @@ void curl_dbg_memdebug(const char *logname)
     else
       curl_dbg_logfile = stderr;
 #ifdef MEMDEBUG_LOG_SYNC
-    /* Flush the log file after every line so the log isn't lost in a crash */
+    /* Flush the log file after every line so the log is not lost in a crash */
     if(curl_dbg_logfile)
       setbuf(curl_dbg_logfile, (char *)NULL);
 #endif
@@ -103,7 +103,7 @@ void curl_dbg_memlimit(long limit)
   }
 }
 
-/* returns TRUE if this isn't allowed! */
+/* returns TRUE if this is not allowed! */
 static bool countcheck(const char *func, int line, const char *source)
 {
   /* if source is NULL, then the call is made internally and this check
diff --git a/lib/memdebug.h b/lib/memdebug.h
index 51147cdcb..fd5cc2c94 100644
--- a/lib/memdebug.h
+++ b/lib/memdebug.h
@@ -137,13 +137,14 @@ CURL_EXTERN int curl_dbg_fclose(FILE *file, int line, const char *source);
 
 #undef socket
 #define socket(domain,type,protocol)\
- curl_dbg_socket(domain, type, protocol, __LINE__, __FILE__)
+ curl_dbg_socket((int)domain, type, protocol, __LINE__, __FILE__)
 #undef accept /* for those with accept as a macro */
 #define accept(sock,addr,len)\
  curl_dbg_accept(sock, addr, len, __LINE__, __FILE__)
 #ifdef HAVE_SOCKETPAIR
 #define socketpair(domain,type,protocol,socket_vector)\
- curl_dbg_socketpair(domain, type, protocol, socket_vector, __LINE__, __FILE__)
+ curl_dbg_socketpair((int)domain, type, protocol, socket_vector, \
+                     __LINE__, __FILE__)
 #endif
 
 #ifdef HAVE_GETADDRINFO
diff --git a/lib/mime.c b/lib/mime.c
index a2356c473..e9eeb1bf7 100644
--- a/lib/mime.c
+++ b/lib/mime.c
@@ -1137,7 +1137,7 @@ static void cleanup_part_content(curl_mimepart *part)
   part->datasize = (curl_off_t) 0;    /* No size yet. */
   cleanup_encoder_state(&part->encstate);
   part->kind = MIMEKIND_NONE;
-  part->flags &= ~MIME_FAST_READ;
+  part->flags &= ~(unsigned int)MIME_FAST_READ;
   part->lastreadstatus = 1; /* Successful read status. */
   part->state.state = MIMESTATE_BEGIN;
 }
@@ -1147,7 +1147,7 @@ static void mime_subparts_free(void *ptr)
   curl_mime *mime = (curl_mime *) ptr;
 
   if(mime && mime->parent) {
-    mime->parent->freefunc = NULL;  /* Be sure we won't be called again. */
+    mime->parent->freefunc = NULL;  /* Be sure we will not be called again. */
     cleanup_part_content(mime->parent);  /* Avoid dangling pointer in part. */
   }
   curl_mime_free(mime);
@@ -1159,7 +1159,7 @@ static void mime_subparts_unbind(void *ptr)
   curl_mime *mime = (curl_mime *) ptr;
 
   if(mime && mime->parent) {
-    mime->parent->freefunc = NULL;  /* Be sure we won't be called again. */
+    mime->parent->freefunc = NULL;  /* Be sure we will not be called again. */
     cleanup_part_content(mime->parent);  /* Avoid dangling pointer in part. */
     mime->parent = NULL;
   }
@@ -1186,7 +1186,7 @@ void curl_mime_free(curl_mime *mime)
   curl_mimepart *part;
 
   if(mime) {
-    mime_subparts_unbind(mime);  /* Be sure it's not referenced anymore. */
+    mime_subparts_unbind(mime);  /* Be sure it is not referenced anymore. */
     while(mime->firstpart) {
       part = mime->firstpart;
       mime->firstpart = part->nextpart;
@@ -1354,7 +1354,7 @@ CURLcode curl_mime_name(curl_mimepart *part, const char *name)
   return CURLE_OK;
 }
 
-/* Set mime part remote file name. */
+/* Set mime part remote filename. */
 CURLcode curl_mime_filename(curl_mimepart *part, const char *filename)
 {
   if(!part)
@@ -1497,7 +1497,7 @@ CURLcode curl_mime_headers(curl_mimepart *part,
   if(part->flags & MIME_USERHEADERS_OWNER) {
     if(part->userheaders != headers)  /* Allow setting twice the same list. */
       curl_slist_free_all(part->userheaders);
-    part->flags &= ~MIME_USERHEADERS_OWNER;
+    part->flags &= ~(unsigned int)MIME_USERHEADERS_OWNER;
   }
   part->userheaders = headers;
   if(headers && take_ownership)
@@ -1554,7 +1554,7 @@ CURLcode Curl_mime_set_subparts(curl_mimepart *part,
       while(root->parent && root->parent->parent)
         root = root->parent->parent;
       if(subparts == root) {
-        /* Can't add as a subpart of itself. */
+        /* cannot add as a subpart of itself. */
         return CURLE_BAD_FUNCTION_ARGUMENT;
       }
     }
@@ -1662,7 +1662,8 @@ static curl_off_t mime_size(curl_mimepart *part)
   if(size >= 0 && !(part->flags & MIME_BODY_ONLY)) {
     /* Compute total part size. */
     size += slist_size(part->curlheaders, 2, NULL, 0);
-    size += slist_size(part->userheaders, 2, STRCONST("Content-Type"));
+    size += slist_size(part->userheaders, 2,
+                       STRCONST("Content-Type"));
     size += 2;    /* CRLF after headers. */
   }
   return size;
@@ -1770,7 +1771,7 @@ CURLcode Curl_mime_prepare_headers(struct Curl_easy *data,
   curl_slist_free_all(part->curlheaders);
   part->curlheaders = NULL;
 
-  /* Be sure we won't access old headers later. */
+  /* Be sure we will not access old headers later. */
   if(part->state.state == MIMESTATE_CURLHEADERS)
     mimesetstate(&part->state, MIMESTATE_CURLHEADERS, NULL);
 
@@ -2071,7 +2072,7 @@ static CURLcode cr_mime_resume_from(struct Curl_easy *data,
         return CURLE_PARTIAL_FILE;
       }
     }
-    /* we've passed, proceed as normal */
+    /* we have passed, proceed as normal */
   }
   return CURLE_OK;
 }
@@ -2095,6 +2096,14 @@ static CURLcode cr_mime_unpause(struct Curl_easy *data,
   return CURLE_OK;
 }
 
+static bool cr_mime_is_paused(struct Curl_easy *data,
+                              struct Curl_creader *reader)
+{
+  struct cr_mime_ctx *ctx = reader->ctx;
+  (void)data;
+  return (ctx->part && ctx->part->lastreadstatus == CURL_READFUNC_PAUSE);
+}
+
 static const struct Curl_crtype cr_mime = {
   "cr-mime",
   cr_mime_init,
@@ -2105,6 +2114,7 @@ static const struct Curl_crtype cr_mime = {
   cr_mime_resume_from,
   cr_mime_rewind,
   cr_mime_unpause,
+  cr_mime_is_paused,
   Curl_creader_def_done,
   sizeof(struct cr_mime_ctx)
 };
diff --git a/lib/mime.h b/lib/mime.h
index 954b3ccf3..5073a38f7 100644
--- a/lib/mime.h
+++ b/lib/mime.h
@@ -112,7 +112,7 @@ struct curl_mimepart {
   curl_mimepart *nextpart;         /* Forward linked list. */
   enum mimekind kind;              /* The part kind. */
   unsigned int flags;              /* Flags. */
-  char *data;                      /* Memory data or file name. */
+  char *data;                      /* Memory data or filename. */
   curl_read_callback readfunc;     /* Read function. */
   curl_seek_callback seekfunc;     /* Seek function. */
   curl_free_callback freefunc;     /* Argument free function. */
@@ -121,7 +121,7 @@ struct curl_mimepart {
   struct curl_slist *curlheaders;  /* Part headers. */
   struct curl_slist *userheaders;  /* Part headers. */
   char *mimetype;                  /* Part mime type. */
-  char *filename;                  /* Remote file name. */
+  char *filename;                  /* Remote filename. */
   char *name;                      /* Data name. */
   curl_off_t datasize;             /* Expected data size. */
   struct mime_state state;         /* Current readback state. */
diff --git a/lib/mprintf.c b/lib/mprintf.c
index 1829abc73..89cbb87ce 100644
--- a/lib/mprintf.c
+++ b/lib/mprintf.c
@@ -863,7 +863,7 @@ number:
 
       str = (char *)iptr->val.str;
       if(!str) {
-        /* Write null string if there's space.  */
+        /* Write null string if there is space.  */
         if(prec == -1 || prec >= (int) sizeof(nilstr) - 1) {
           str = nilstr;
           len = sizeof(nilstr) - 1;
@@ -1040,7 +1040,7 @@ static int addbyter(unsigned char outc, void *f)
 {
   struct nsprintf *infop = f;
   if(infop->length < infop->max) {
-    /* only do this if we haven't reached max length yet */
+    /* only do this if we have not reached max length yet */
     *infop->buffer++ = (char)outc; /* store */
     infop->length++; /* we are now one byte larger */
     return 0;     /* fputc() returns like this on success */
@@ -1062,10 +1062,10 @@ int curl_mvsnprintf(char *buffer, size_t maxlength, const char *format,
   if(info.max) {
     /* we terminate this with a zero byte */
     if(info.max == info.length) {
-      /* we're at maximum, scrap the last letter */
+      /* we are at maximum, scrap the last letter */
       info.buffer[-1] = 0;
       DEBUGASSERT(retcode);
-      retcode--; /* don't count the nul byte */
+      retcode--; /* do not count the nul byte */
     }
     else
       info.buffer[0] = 0;
diff --git a/lib/mqtt.c b/lib/mqtt.c
index 4ca24eb41..8c461e163 100644
--- a/lib/mqtt.c
+++ b/lib/mqtt.c
@@ -154,15 +154,15 @@ static int mqtt_getsock(struct Curl_easy *data,
 
 static int mqtt_encode_len(char *buf, size_t len)
 {
-  unsigned char encoded;
   int i;
 
   for(i = 0; (len > 0) && (i<4); i++) {
+    unsigned char encoded;
     encoded = len % 0x80;
     len /= 0x80;
     if(len)
       encoded |= 0x80;
-    buf[i] = encoded;
+    buf[i] = (char)encoded;
   }
 
   return i;
@@ -312,7 +312,7 @@ static CURLcode mqtt_connect(struct Curl_easy *data)
   start_user = pos + 3 + MQTT_CLIENTID_LEN;
   /* position where starts the password payload */
   start_pwd = start_user + ulen;
-  /* if user name was provided, add it to the packet */
+  /* if username was provided, add it to the packet */
   if(ulen) {
     start_pwd += 2;
 
@@ -585,7 +585,7 @@ static size_t mqtt_decode_len(unsigned char *buf,
   return len;
 }
 
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
 static const char *statenames[]={
   "MQTT_FIRST",
   "MQTT_REMAINING_LENGTH",
@@ -606,7 +606,7 @@ static void mqstate(struct Curl_easy *data,
 {
   struct connectdata *conn = data->conn;
   struct mqtt_conn *mqtt = &conn->proto.mqtt;
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
   infof(data, "%s (from %s) (next is %s)",
         statenames[state],
         statenames[mqtt->state],
@@ -743,7 +743,7 @@ static CURLcode mqtt_doing(struct Curl_easy *data, bool *done)
   struct mqtt_conn *mqtt = &conn->proto.mqtt;
   struct MQTT *mq = data->req.p.mqtt;
   ssize_t nread;
-  unsigned char byte;
+  unsigned char recvbyte;
 
   *done = FALSE;
 
@@ -776,13 +776,13 @@ static CURLcode mqtt_doing(struct Curl_easy *data, bool *done)
     FALLTHROUGH();
   case MQTT_REMAINING_LENGTH:
     do {
-      result = Curl_xfer_recv(data, (char *)&byte, 1, &nread);
+      result = Curl_xfer_recv(data, (char *)&recvbyte, 1, &nread);
       if(result || !nread)
         break;
-      Curl_debug(data, CURLINFO_HEADER_IN, (char *)&byte, 1);
-      mq->pkt_hd[mq->npacket++] = byte;
-    } while((byte & 0x80) && (mq->npacket < 4));
-    if(!result && nread && (byte & 0x80))
+      Curl_debug(data, CURLINFO_HEADER_IN, (char *)&recvbyte, 1);
+      mq->pkt_hd[mq->npacket++] = recvbyte;
+    } while((recvbyte & 0x80) && (mq->npacket < 4));
+    if(!result && nread && (recvbyte & 0x80))
       /* MQTT supports up to 127 * 128^0 + 127 * 128^1 + 127 * 128^2 +
          127 * 128^3 bytes. server tried to send more */
       result = CURLE_WEIRD_SERVER_REPLY;
diff --git a/lib/multi.c b/lib/multi.c
index 6bbdfe267..896f73049 100644
--- a/lib/multi.c
+++ b/lib/multi.c
@@ -57,7 +57,7 @@
 
 /*
   CURL_SOCKET_HASH_TABLE_SIZE should be a prime number. Increasing it from 97
-  to 911 takes on a 32-bit machine 4 x 804 = 3211 more bytes.  Still, every
+  to 911 takes on a 32-bit machine 4 x 804 = 3211 more bytes. Still, every
   CURL handle takes 45-50 K memory, therefore this 3K are not significant.
 */
 #ifndef CURL_SOCKET_HASH_TABLE_SIZE
@@ -135,7 +135,7 @@ static void init_completed(struct Curl_easy *data)
 {
   /* this is a completed transfer */
 
-  /* Important: reset the conn pointer so that we don't point to memory
+  /* Important: reset the conn pointer so that we do not point to memory
      that could be freed anytime */
   Curl_detach_connection(data);
   Curl_expire_clear(data); /* stop all timers */
@@ -175,7 +175,7 @@ static void mstate(struct Curl_easy *data, CURLMstate state
 #endif
 
   if(oldstate == state)
-    /* don't bother when the new state is the same as the old state */
+    /* do not bother when the new state is the same as the old state */
     return;
 
   data->mstate = state;
@@ -191,7 +191,7 @@ static void mstate(struct Curl_easy *data, CURLMstate state
 #endif
 
   if(state == MSTATE_COMPLETED) {
-    /* changing to COMPLETED means there's one less easy handle 'alive' */
+    /* changing to COMPLETED means there is one less easy handle 'alive' */
     DEBUGASSERT(data->multi->num_alive > 0);
     data->multi->num_alive--;
     if(!data->multi->num_alive) {
@@ -343,7 +343,7 @@ static size_t hash_fd(void *key, size_t key_length, size_t slots_num)
   curl_socket_t fd = *((curl_socket_t *) key);
   (void) key_length;
 
-  return (fd % slots_num);
+  return (fd % (curl_socket_t)slots_num);
 }
 
 /*
@@ -354,12 +354,12 @@ static size_t hash_fd(void *key, size_t key_length, size_t slots_num)
  * "Some tests at 7000 and 9000 connections showed that the socket hash lookup
  * is somewhat of a bottle neck. Its current implementation may be a bit too
  * limiting. It simply has a fixed-size array, and on each entry in the array
- * it has a linked list with entries. So the hash only checks which list to
- * scan through. The code I had used so for used a list with merely 7 slots
- * (as that is what the DNS hash uses) but with 7000 connections that would
- * make an average of 1000 nodes in each list to run through. I upped that to
- * 97 slots (I believe a prime is suitable) and noticed a significant speed
- * increase.  I need to reconsider the hash implementation or use a rather
+ * it has a linked list with entries. The hash only checks which list to scan
+ * through. The code I had used so for used a list with merely 7 slots (as
+ * that is what the DNS hash uses) but with 7000 connections that would make
+ * an average of 1000 nodes in each list to run through. I upped that to 97
+ * slots (I believe a prime is suitable) and noticed a significant speed
+ * increase. I need to reconsider the hash implementation or use a rather
  * large default value like this. At 9000 connections I was still below 10us
  * per call."
  *
@@ -370,6 +370,17 @@ static void sh_init(struct Curl_hash *hash, size_t hashsize)
                  sh_freeentry);
 }
 
+/* multi->proto_hash destructor. Should never be called as elements
+ * MUST be added with their own destructor */
+static void ph_freeentry(void *p)
+{
+  (void)p;
+  /* Will always be FALSE. Cannot use a 0 assert here since compilers
+   * are not in agreement if they then want a NORETURN attribute or
+   * not. *sigh* */
+  DEBUGASSERT(p == NULL);
+}
+
 /*
  * multi_addmsg()
  *
@@ -396,7 +407,10 @@ struct Curl_multi *Curl_multi_handle(size_t hashsize, /* socket hash */
 
   sh_init(&multi->sockhash, hashsize);
 
-  if(Curl_conncache_init(&multi->conn_cache, chashsize))
+  Curl_hash_init(&multi->proto_hash, 23,
+                 Curl_hash_str, Curl_str_key_compare, ph_freeentry);
+
+  if(Curl_conncache_init(&multi->conn_cache, multi, chashsize))
     goto error;
 
   Curl_llist_init(&multi->msglist, NULL);
@@ -412,14 +426,7 @@ struct Curl_multi *Curl_multi_handle(size_t hashsize, /* socket hash */
     goto error;
 #else
 #ifdef ENABLE_WAKEUP
-  if(wakeup_create(multi->wakeup_pair) < 0) {
-    multi->wakeup_pair[0] = CURL_SOCKET_BAD;
-    multi->wakeup_pair[1] = CURL_SOCKET_BAD;
-  }
-  else if(curlx_nonblock(multi->wakeup_pair[0], TRUE) < 0 ||
-          curlx_nonblock(multi->wakeup_pair[1], TRUE) < 0) {
-    wakeup_close(multi->wakeup_pair[0]);
-    wakeup_close(multi->wakeup_pair[1]);
+  if(wakeup_create(multi->wakeup_pair, TRUE) < 0) {
     multi->wakeup_pair[0] = CURL_SOCKET_BAD;
     multi->wakeup_pair[1] = CURL_SOCKET_BAD;
   }
@@ -431,6 +438,7 @@ struct Curl_multi *Curl_multi_handle(size_t hashsize, /* socket hash */
 error:
 
   sockhash_destroy(&multi->sockhash);
+  Curl_hash_destroy(&multi->proto_hash);
   Curl_hash_destroy(&multi->hostcache);
   Curl_conncache_destroy(&multi->conn_cache);
   free(multi);
@@ -544,10 +552,10 @@ CURLMcode curl_multi_add_handle(struct Curl_multi *multi,
   Curl_llist_init(&data->state.timeoutlist, NULL);
 
   /*
-   * No failure allowed in this function beyond this point. And no
-   * modification of easy nor multi handle allowed before this except for
-   * potential multi's connection cache growing which won't be undone in this
-   * function no matter what.
+   * No failure allowed in this function beyond this point. No modification of
+   * easy nor multi handle allowed before this except for potential multi's
+   * connection cache growing which will not be undone in this function no
+   * matter what.
    */
   if(data->set.errorbuffer)
     data->set.errorbuffer[0] = 0;
@@ -684,8 +692,8 @@ static CURLcode multi_done(struct Curl_easy *data,
   case CURLE_ABORTED_BY_CALLBACK:
   case CURLE_READ_ERROR:
   case CURLE_WRITE_ERROR:
-    /* When we're aborted due to a callback return code it basically have to
-       be counted as premature as there is trouble ahead if we don't. We have
+    /* When we are aborted due to a callback return code it basically have to
+       be counted as premature as there is trouble ahead if we do not. We have
        many callbacks and protocols work differently, we could potentially do
        this more fine-grained in the future. */
     premature = TRUE;
@@ -749,8 +757,8 @@ static CURLcode multi_done(struct Curl_easy *data,
      restrictions in our or the server's end
 
      if premature is TRUE, it means this connection was said to be DONE before
-     the entire request operation is complete and thus we can't know in what
-     state it is for reusing, so we're forced to close it. In a perfect world
+     the entire request operation is complete and thus we cannot know in what
+     state it is for reusing, so we are forced to close it. In a perfect world
      we can add code that keep track of if we really must close it here or not,
      but currently we have no such detail knowledge.
   */
@@ -863,7 +871,7 @@ CURLMcode curl_multi_remove_handle(struct Curl_multi *multi,
   if(data->conn &&
      data->mstate > MSTATE_DO &&
      data->mstate < MSTATE_COMPLETED) {
-    /* Set connection owner so that the DONE function closes it.  We can
+    /* Set connection owner so that the DONE function closes it. We can
        safely do this here since connection is killed. */
     streamclose(data->conn, "Removed with partial response");
   }
@@ -872,7 +880,7 @@ CURLMcode curl_multi_remove_handle(struct Curl_multi *multi,
     /* multi_done() clears the association between the easy handle and the
        connection.
 
-       Note that this ignores the return code simply because there's
+       Note that this ignores the return code simply because there is
        nothing really useful to do with it anyway! */
     (void)multi_done(data, data->result, premature);
   }
@@ -906,7 +914,7 @@ CURLMcode curl_multi_remove_handle(struct Curl_multi *multi,
      what we want */
   data->mstate = MSTATE_COMPLETED;
 
-  /* This ignores the return code even in case of problems because there's
+  /* This ignores the return code even in case of problems because there is
      nothing more to do about that, here */
   (void)singlesocket(multi, easy); /* to let the application know what sockets
                                       that vanish with this handle */
@@ -918,7 +926,7 @@ CURLMcode curl_multi_remove_handle(struct Curl_multi *multi,
     /* This removes a handle that was part the multi interface that used
        CONNECT_ONLY, that connection is now left alive but since this handle
        has bits.close set nothing can use that transfer anymore and it is
-       forbidden from reuse. And this easy handle cannot find the connection
+       forbidden from reuse. This easy handle cannot find the connection
        anymore once removed from the multi handle
 
        Better close the connection here, at once.
@@ -945,12 +953,12 @@ CURLMcode curl_multi_remove_handle(struct Curl_multi *multi,
 #endif
 
   /* as this was using a shared connection cache we clear the pointer to that
-     since we're not part of that multi handle anymore */
+     since we are not part of that multi handle anymore */
   data->state.conn_cache = NULL;
 
   data->multi = NULL; /* clear the association to this multi handle */
 
-  /* make sure there's no pending message in the queue sent from this easy
+  /* make sure there is no pending message in the queue sent from this easy
      handle */
   for(e = multi->msglist.head; e; e = e->next) {
     struct Curl_message *msg = e->ptr;
@@ -1002,8 +1010,9 @@ void Curl_detach_connection(struct Curl_easy *data)
  * This is the only function that should assign data->conn
  */
 void Curl_attach_connection(struct Curl_easy *data,
-                             struct connectdata *conn)
+                            struct connectdata *conn)
 {
+  DEBUGASSERT(data);
   DEBUGASSERT(!data->conn);
   DEBUGASSERT(conn);
   data->conn = conn;
@@ -1016,12 +1025,14 @@ void Curl_attach_connection(struct Curl_easy *data,
 static int connecting_getsock(struct Curl_easy *data, curl_socket_t *socks)
 {
   struct connectdata *conn = data->conn;
-  (void)socks;
-  /* Not using `conn->sockfd` as `Curl_xfer_setup()` initializes
-   * that *after* the connect. */
-  if(conn && conn->sock[FIRSTSOCKET] != CURL_SOCKET_BAD) {
+  curl_socket_t sockfd;
+
+  if(!conn)
+    return GETSOCK_BLANK;
+  sockfd = Curl_conn_get_socket(data, FIRSTSOCKET);
+  if(sockfd != CURL_SOCKET_BAD) {
     /* Default is to wait to something from the server */
-    socks[0] = conn->sock[FIRSTSOCKET];
+    socks[0] = sockfd;
     return GETSOCK_READSOCK(0);
   }
   return GETSOCK_BLANK;
@@ -1030,11 +1041,16 @@ static int connecting_getsock(struct Curl_easy *data, curl_socket_t *socks)
 static int protocol_getsock(struct Curl_easy *data, curl_socket_t *socks)
 {
   struct connectdata *conn = data->conn;
-  if(conn && conn->handler->proto_getsock)
+  curl_socket_t sockfd;
+
+  if(!conn)
+    return GETSOCK_BLANK;
+  if(conn->handler->proto_getsock)
     return conn->handler->proto_getsock(data, conn, socks);
-  else if(conn && conn->sockfd != CURL_SOCKET_BAD) {
+  sockfd = Curl_conn_get_socket(data, FIRSTSOCKET);
+  if(sockfd != CURL_SOCKET_BAD) {
     /* Default is to wait to something from the server */
-    socks[0] = conn->sockfd;
+    socks[0] = sockfd;
     return GETSOCK_READSOCK(0);
   }
   return GETSOCK_BLANK;
@@ -1043,9 +1059,11 @@ static int protocol_getsock(struct Curl_easy *data, curl_socket_t *socks)
 static int domore_getsock(struct Curl_easy *data, curl_socket_t *socks)
 {
   struct connectdata *conn = data->conn;
-  if(conn && conn->handler->domore_getsock)
+  if(!conn)
+    return GETSOCK_BLANK;
+  if(conn->handler->domore_getsock)
     return conn->handler->domore_getsock(data, conn, socks);
-  else if(conn && conn->sockfd != CURL_SOCKET_BAD) {
+  else if(conn->sockfd != CURL_SOCKET_BAD) {
     /* Default is that we want to send something to the server */
     socks[0] = conn->sockfd;
     return GETSOCK_WRITESOCK(0);
@@ -1056,9 +1074,11 @@ static int domore_getsock(struct Curl_easy *data, curl_socket_t *socks)
 static int doing_getsock(struct Curl_easy *data, curl_socket_t *socks)
 {
   struct connectdata *conn = data->conn;
-  if(conn && conn->handler->doing_getsock)
+  if(!conn)
+    return GETSOCK_BLANK;
+  if(conn->handler->doing_getsock)
     return conn->handler->doing_getsock(data, conn, socks);
-  else if(conn && conn->sockfd != CURL_SOCKET_BAD) {
+  else if(conn->sockfd != CURL_SOCKET_BAD) {
     /* Default is that we want to send something to the server */
     socks[0] = conn->sockfd;
     return GETSOCK_WRITESOCK(0);
@@ -1069,7 +1089,6 @@ static int doing_getsock(struct Curl_easy *data, curl_socket_t *socks)
 static int perform_getsock(struct Curl_easy *data, curl_socket_t *sock)
 {
   struct connectdata *conn = data->conn;
-
   if(!conn)
     return GETSOCK_BLANK;
   else if(conn->handler->perform_getsock)
@@ -1106,6 +1125,7 @@ static int perform_getsock(struct Curl_easy *data, curl_socket_t *sock)
 static void multi_getsock(struct Curl_easy *data,
                           struct easy_pollset *ps)
 {
+  bool expect_sockets = TRUE;
   /* The no connection case can happen when this is called from
      curl_multi_remove_handle() => singlesocket() => multi_getsock().
   */
@@ -1119,11 +1139,14 @@ static void multi_getsock(struct Curl_easy *data,
   case MSTATE_SETUP:
   case MSTATE_CONNECT:
     /* nothing to poll for yet */
+    expect_sockets = FALSE;
     break;
 
   case MSTATE_RESOLVING:
     Curl_pollset_add_socks(data, ps, Curl_resolv_getsock);
-    /* connection filters are not involved in this phase */
+    /* connection filters are not involved in this phase. It's ok if we get no
+     * sockets to wait for. Resolving can wake up from other sources. */
+    expect_sockets = FALSE;
     break;
 
   case MSTATE_CONNECTING:
@@ -1157,19 +1180,29 @@ static void multi_getsock(struct Curl_easy *data,
 
   case MSTATE_RATELIMITING:
     /* we need to let time pass, ignore socket(s) */
+    expect_sockets = FALSE;
     break;
 
   case MSTATE_DONE:
   case MSTATE_COMPLETED:
   case MSTATE_MSGSENT:
     /* nothing more to poll for */
+    expect_sockets = FALSE;
     break;
 
   default:
     failf(data, "multi_getsock: unexpected multi state %d", data->mstate);
     DEBUGASSERT(0);
+    expect_sockets = FALSE;
     break;
   }
+
+  if(expect_sockets && !ps->num &&
+     !(data->req.keepon & (KEEP_RECV_PAUSE|KEEP_SEND_PAUSE)) &&
+     Curl_conn_is_ip_connected(data, FIRSTSOCKET)) {
+    infof(data, "WARNING: no socket in pollset, transfer may stall!");
+    DEBUGASSERT(0);
+  }
 }
 
 CURLMcode curl_multi_fdset(struct Curl_multi *multi,
@@ -1197,7 +1230,7 @@ CURLMcode curl_multi_fdset(struct Curl_multi *multi,
 
     for(i = 0; i < ps.num; i++) {
       if(!FDSET_SOCK(ps.sockets[i]))
-        /* pretend it doesn't exist */
+        /* pretend it does not exist */
         continue;
       if(ps.actions[i] & CURL_POLL_IN)
         FD_SET(ps.sockets[i], read_fd_set);
@@ -1219,12 +1252,9 @@ CURLMcode curl_multi_waitfds(struct Curl_multi *multi,
                              unsigned int *fd_count)
 {
   struct Curl_easy *data;
-  unsigned int nfds = 0;
+  struct curl_waitfds cwfds;
   struct easy_pollset ps;
-  unsigned int i;
   CURLMcode result = CURLM_OK;
-  struct curl_waitfd *ufd;
-  unsigned int j;
 
   if(!ufds)
     return CURLM_BAD_FUNCTION_ARGUMENT;
@@ -1235,48 +1265,29 @@ CURLMcode curl_multi_waitfds(struct Curl_multi *multi,
   if(multi->in_callback)
     return CURLM_RECURSIVE_API_CALL;
 
+  Curl_waitfds_init(&cwfds, ufds, size);
   memset(&ps, 0, sizeof(ps));
   for(data = multi->easyp; data; data = data->next) {
     multi_getsock(data, &ps);
-
-    for(i = 0; i < ps.num; i++) {
-      if(nfds < size) {
-        curl_socket_t fd = ps.sockets[i];
-        int fd_idx = -1;
-
-        /* Simple linear search to skip an already added descriptor */
-        for(j = 0; j < nfds; j++) {
-          if(ufds[j].fd == fd) {
-            fd_idx = (int)j;
-            break;
-          }
-        }
-
-        if(fd_idx < 0) {
-          ufd = &ufds[nfds++];
-          ufd->fd = ps.sockets[i];
-          ufd->events = 0;
-        }
-        else
-          ufd = &ufds[fd_idx];
-
-        if(ps.actions[i] & CURL_POLL_IN)
-          ufd->events |= CURL_WAIT_POLLIN;
-        if(ps.actions[i] & CURL_POLL_OUT)
-          ufd->events |= CURL_WAIT_POLLOUT;
-      }
-      else
-        return CURLM_OUT_OF_MEMORY;
+    if(Curl_waitfds_add_ps(&cwfds, &ps)) {
+      result = CURLM_OUT_OF_MEMORY;
+      goto out;
     }
   }
 
+  if(Curl_conncache_add_waitfds(&multi->conn_cache, &cwfds)) {
+    result = CURLM_OUT_OF_MEMORY;
+    goto out;
+  }
+
+out:
   if(fd_count)
-    *fd_count = nfds;
+    *fd_count = cwfds.n;
   return result;
 }
 
 #ifdef USE_WINSOCK
-/* Reset FD_WRITE for TCP sockets. Nothing is actually sent. UDP sockets can't
+/* Reset FD_WRITE for TCP sockets. Nothing is actually sent. UDP sockets cannot
  * be reset this way because an empty datagram would be sent. #9203
  *
  * "On Windows the internal state of FD_WRITE as returned from
@@ -1291,29 +1302,6 @@ static void reset_socket_fdwrite(curl_socket_t s)
 }
 #endif
 
-static CURLMcode ufds_increase(struct pollfd **pfds, unsigned int *pfds_len,
-                               unsigned int inc, bool *is_malloced)
-{
-  struct pollfd *new_fds, *old_fds = *pfds;
-  unsigned int new_len = *pfds_len + inc;
-
-  new_fds = calloc(new_len, sizeof(struct pollfd));
-  if(!new_fds) {
-    if(*is_malloced)
-      free(old_fds);
-    *pfds = NULL;
-    *pfds_len = 0;
-    return CURLM_OUT_OF_MEMORY;
-  }
-  memcpy(new_fds, old_fds, (*pfds_len) * sizeof(struct pollfd));
-  if(*is_malloced)
-    free(old_fds);
-  *pfds = new_fds;
-  *pfds_len = new_len;
-  *is_malloced = TRUE;
-  return CURLM_OK;
-}
-
 #define NUM_POLLS_ON_STACK 10
 
 static CURLMcode multi_wait(struct Curl_multi *multi,
@@ -1330,10 +1318,9 @@ static CURLMcode multi_wait(struct Curl_multi *multi,
   long timeout_internal;
   int retcode = 0;
   struct pollfd a_few_on_stack[NUM_POLLS_ON_STACK];
-  struct pollfd *ufds = &a_few_on_stack[0];
-  unsigned int ufds_len = NUM_POLLS_ON_STACK;
-  unsigned int nfds = 0, curl_nfds = 0; /* how many ufds are in use */
-  bool ufds_malloc = FALSE;
+  struct curl_pollfds cpfds;
+  unsigned int curl_nfds = 0; /* how many pfds are for curl transfers */
+  CURLMcode result = CURLM_OK;
 #ifdef USE_WINSOCK
   WSANETWORKEVENTS wsa_events;
   DEBUGASSERT(multi->wsa_event != WSA_INVALID_EVENT);
@@ -1351,139 +1338,105 @@ static CURLMcode multi_wait(struct Curl_multi *multi,
   if(timeout_ms < 0)
     return CURLM_BAD_FUNCTION_ARGUMENT;
 
-  /* If the internally desired timeout is actually shorter than requested from
-     the outside, then use the shorter time! But only if the internal timer
-     is actually larger than -1! */
-  (void)multi_timeout(multi, &timeout_internal);
-  if((timeout_internal >= 0) && (timeout_internal < (long)timeout_ms))
-    timeout_ms = (int)timeout_internal;
-
-  memset(ufds, 0, ufds_len * sizeof(struct pollfd));
+  Curl_pollfds_init(&cpfds, a_few_on_stack, NUM_POLLS_ON_STACK);
   memset(&ps, 0, sizeof(ps));
 
   /* Add the curl handles to our pollfds first */
   for(data = multi->easyp; data; data = data->next) {
     multi_getsock(data, &ps);
-
-    for(i = 0; i < ps.num; i++) {
-      short events = 0;
-#ifdef USE_WINSOCK
-      long mask = 0;
-#endif
-      if(ps.actions[i] & CURL_POLL_IN) {
-#ifdef USE_WINSOCK
-        mask |= FD_READ|FD_ACCEPT|FD_CLOSE;
-#endif
-        events |= POLLIN;
-      }
-      if(ps.actions[i] & CURL_POLL_OUT) {
-#ifdef USE_WINSOCK
-        mask |= FD_WRITE|FD_CONNECT|FD_CLOSE;
-        reset_socket_fdwrite(ps.sockets[i]);
-#endif
-        events |= POLLOUT;
-      }
-      if(events) {
-        if(nfds && ps.sockets[i] == ufds[nfds-1].fd) {
-          ufds[nfds-1].events |= events;
-        }
-        else {
-          if(nfds >= ufds_len) {
-            if(ufds_increase(&ufds, &ufds_len, 100, &ufds_malloc))
-              return CURLM_OUT_OF_MEMORY;
-          }
-          DEBUGASSERT(nfds < ufds_len);
-          ufds[nfds].fd = ps.sockets[i];
-          ufds[nfds].events = events;
-          ++nfds;
-        }
-      }
-#ifdef USE_WINSOCK
-      if(mask) {
-        if(WSAEventSelect(ps.sockets[i], multi->wsa_event, mask) != 0) {
-          if(ufds_malloc)
-            free(ufds);
-          return CURLM_INTERNAL_ERROR;
-        }
-      }
-#endif
+    if(Curl_pollfds_add_ps(&cpfds, &ps)) {
+      result = CURLM_OUT_OF_MEMORY;
+      goto out;
     }
   }
 
-  curl_nfds = nfds; /* what curl internally used in ufds */
+  if(Curl_conncache_add_pollfds(&multi->conn_cache, &cpfds)) {
+    result = CURLM_OUT_OF_MEMORY;
+    goto out;
+  }
 
+  curl_nfds = cpfds.n; /* what curl internally uses in cpfds */
   /* Add external file descriptions from poll-like struct curl_waitfd */
   for(i = 0; i < extra_nfds; i++) {
+    unsigned short events = 0;
+    if(extra_fds[i].events & CURL_WAIT_POLLIN)
+      events |= POLLIN;
+    if(extra_fds[i].events & CURL_WAIT_POLLPRI)
+      events |= POLLPRI;
+    if(extra_fds[i].events & CURL_WAIT_POLLOUT)
+      events |= POLLOUT;
+    if(Curl_pollfds_add_sock(&cpfds, extra_fds[i].fd, events)) {
+      result = CURLM_OUT_OF_MEMORY;
+      goto out;
+    }
+  }
+
 #ifdef USE_WINSOCK
+  /* Set the WSA events based on the collected pollds */
+  for(i = 0; i < cpfds.n; i++) {
     long mask = 0;
-    if(extra_fds[i].events & CURL_WAIT_POLLIN)
+    if(cpfds.pfds[i].events & POLLIN)
       mask |= FD_READ|FD_ACCEPT|FD_CLOSE;
-    if(extra_fds[i].events & CURL_WAIT_POLLPRI)
+    if(cpfds.pfds[i].events & POLLPRI)
       mask |= FD_OOB;
-    if(extra_fds[i].events & CURL_WAIT_POLLOUT) {
+    if(cpfds.pfds[i].events & POLLOUT) {
       mask |= FD_WRITE|FD_CONNECT|FD_CLOSE;
-      reset_socket_fdwrite(extra_fds[i].fd);
-    }
-    if(WSAEventSelect(extra_fds[i].fd, multi->wsa_event, mask) != 0) {
-      if(ufds_malloc)
-        free(ufds);
-      return CURLM_INTERNAL_ERROR;
+      reset_socket_fdwrite(cpfds.pfds[i].fd);
     }
-#endif
-    if(nfds >= ufds_len) {
-      if(ufds_increase(&ufds, &ufds_len, 100, &ufds_malloc))
-        return CURLM_OUT_OF_MEMORY;
+    if(mask) {
+      if(WSAEventSelect(cpfds.pfds[i].fd, multi->wsa_event, mask) != 0) {
+        result = CURLM_OUT_OF_MEMORY;
+        goto out;
+      }
     }
-    DEBUGASSERT(nfds < ufds_len);
-    ufds[nfds].fd = extra_fds[i].fd;
-    ufds[nfds].events = 0;
-    if(extra_fds[i].events & CURL_WAIT_POLLIN)
-      ufds[nfds].events |= POLLIN;
-    if(extra_fds[i].events & CURL_WAIT_POLLPRI)
-      ufds[nfds].events |= POLLPRI;
-    if(extra_fds[i].events & CURL_WAIT_POLLOUT)
-      ufds[nfds].events |= POLLOUT;
-    ++nfds;
   }
+#endif
 
 #ifdef ENABLE_WAKEUP
 #ifndef USE_WINSOCK
   if(use_wakeup && multi->wakeup_pair[0] != CURL_SOCKET_BAD) {
-    if(nfds >= ufds_len) {
-      if(ufds_increase(&ufds, &ufds_len, 100, &ufds_malloc))
-        return CURLM_OUT_OF_MEMORY;
+    if(Curl_pollfds_add_sock(&cpfds, multi->wakeup_pair[0], POLLIN)) {
+      result = CURLM_OUT_OF_MEMORY;
+      goto out;
     }
-    DEBUGASSERT(nfds < ufds_len);
-    ufds[nfds].fd = multi->wakeup_pair[0];
-    ufds[nfds].events = POLLIN;
-    ++nfds;
   }
 #endif
 #endif
 
+  /* We check the internal timeout *AFTER* we collected all sockets to
+   * poll. Collecting the sockets may install new timers by protocols
+   * and connection filters.
+   * Use the shorter one of the internal and the caller requested timeout. */
+  (void)multi_timeout(multi, &timeout_internal);
+  if((timeout_internal >= 0) && (timeout_internal < (long)timeout_ms))
+    timeout_ms = (int)timeout_internal;
+
 #if defined(ENABLE_WAKEUP) && defined(USE_WINSOCK)
-  if(nfds || use_wakeup) {
+  if(cpfds.n || use_wakeup) {
 #else
-  if(nfds) {
+  if(cpfds.n) {
 #endif
     int pollrc;
 #ifdef USE_WINSOCK
-    if(nfds)
-      pollrc = Curl_poll(ufds, nfds, 0); /* just pre-check with WinSock */
+    if(cpfds.n)         /* just pre-check with WinSock */
+      pollrc = Curl_poll(cpfds.pfds, cpfds.n, 0);
     else
       pollrc = 0;
 #else
-    pollrc = Curl_poll(ufds, nfds, timeout_ms); /* wait... */
+    pollrc = Curl_poll(cpfds.pfds, cpfds.n, timeout_ms); /* wait... */
 #endif
-    if(pollrc < 0)
-      return CURLM_UNRECOVERABLE_POLL;
+    if(pollrc < 0) {
+      result = CURLM_UNRECOVERABLE_POLL;
+      goto out;
+    }
 
     if(pollrc > 0) {
       retcode = pollrc;
 #ifdef USE_WINSOCK
     }
     else { /* now wait... if not ready during the pre-check (pollrc == 0) */
-      WSAWaitForMultipleEvents(1, &multi->wsa_event, FALSE, timeout_ms, FALSE);
+      WSAWaitForMultipleEvents(1, &multi->wsa_event, FALSE, (DWORD)timeout_ms,
+                               FALSE);
     }
     /* With WinSock, we have to run the following section unconditionally
        to call WSAEventSelect(fd, event, 0) on all the sockets */
@@ -1493,7 +1446,7 @@ static CURLMcode multi_wait(struct Curl_multi *multi,
          struct, the bit values of the actual underlying poll() implementation
          may not be the same as the ones in the public libcurl API! */
       for(i = 0; i < extra_nfds; i++) {
-        unsigned r = ufds[curl_nfds + i].revents;
+        unsigned r = (unsigned)cpfds.pfds[curl_nfds + i].revents;
         unsigned short mask = 0;
 #ifdef USE_WINSOCK
         curl_socket_t s = extra_fds[i].fd;
@@ -1510,7 +1463,7 @@ static CURLMcode multi_wait(struct Curl_multi *multi,
         }
         WSAEventSelect(s, multi->wsa_event, 0);
         if(!pollrc) {
-          extra_fds[i].revents = mask;
+          extra_fds[i].revents = (short)mask;
           continue;
         }
 #endif
@@ -1520,7 +1473,7 @@ static CURLMcode multi_wait(struct Curl_multi *multi,
           mask |= CURL_WAIT_POLLOUT;
         if(r & POLLPRI)
           mask |= CURL_WAIT_POLLPRI;
-        extra_fds[i].revents = mask;
+        extra_fds[i].revents = (short)mask;
       }
 
 #ifdef USE_WINSOCK
@@ -1547,7 +1500,7 @@ static CURLMcode multi_wait(struct Curl_multi *multi,
 #else
 #ifdef ENABLE_WAKEUP
       if(use_wakeup && multi->wakeup_pair[0] != CURL_SOCKET_BAD) {
-        if(ufds[curl_nfds + extra_nfds].revents & POLLIN) {
+        if(cpfds.pfds[curl_nfds + extra_nfds].revents & POLLIN) {
           char buf[64];
           ssize_t nread;
           while(1) {
@@ -1571,18 +1524,16 @@ static CURLMcode multi_wait(struct Curl_multi *multi,
     }
   }
 
-  if(ufds_malloc)
-    free(ufds);
   if(ret)
     *ret = retcode;
 #if defined(ENABLE_WAKEUP) && defined(USE_WINSOCK)
-  if(extrawait && !nfds && !use_wakeup) {
+  if(extrawait && !cpfds.n && !use_wakeup) {
 #else
-  if(extrawait && !nfds) {
+  if(extrawait && !cpfds.n) {
 #endif
     long sleep_ms = 0;
 
-    /* Avoid busy-looping when there's nothing particular to wait for */
+    /* Avoid busy-looping when there is nothing particular to wait for */
     if(!curl_multi_timeout(multi, &sleep_ms) && sleep_ms) {
       if(sleep_ms > timeout_ms)
         sleep_ms = timeout_ms;
@@ -1594,7 +1545,9 @@ static CURLMcode multi_wait(struct Curl_multi *multi,
     }
   }
 
-  return CURLM_OK;
+out:
+  Curl_pollfds_cleanup(&cpfds);
+  return result;
 }
 
 CURLMcode curl_multi_wait(struct Curl_multi *multi,
@@ -1623,6 +1576,15 @@ CURLMcode curl_multi_wakeup(struct Curl_multi *multi)
      it has to be careful only to access parts of the
      Curl_multi struct that are constant */
 
+#if defined(ENABLE_WAKEUP) && !defined(USE_WINSOCK)
+#ifdef USE_EVENTFD
+  const void *buf;
+  const uint64_t val = 1;
+#else
+  char buf[1];
+#endif
+#endif
+
   /* GOOD_MULTI_HANDLE can be safely called */
   if(!GOOD_MULTI_HANDLE(multi))
     return CURLM_BAD_HANDLE;
@@ -1636,8 +1598,11 @@ CURLMcode curl_multi_wakeup(struct Curl_multi *multi)
      making it safe to access from another thread after the init part
      and before cleanup */
   if(multi->wakeup_pair[1] != CURL_SOCKET_BAD) {
-    char buf[1];
+#ifdef USE_EVENTFD
+    buf = &val;
+#else
     buf[0] = 1;
+#endif
     while(1) {
       /* swrite() is not thread-safe in general, because concurrent calls
          can have their messages interleaved, but in this case the content
@@ -1646,7 +1611,7 @@ CURLMcode curl_multi_wakeup(struct Curl_multi *multi)
          The write socket is set to non-blocking, this way this function
          cannot block, making it safe to call even from the same thread
          that will call curl_multi_wait(). If swrite() returns that it
-         would block, it's considered successful because it means that
+         would block, it is considered successful because it means that
          previous calls to this function will wake up the poll(). */
       if(wakeup_write(multi->wakeup_pair[1], buf, sizeof(buf)) < 0) {
         int err = SOCKERRNO;
@@ -1710,7 +1675,7 @@ CURLMcode Curl_multi_add_perform(struct Curl_multi *multi,
   if(!rc) {
     struct SingleRequest *k = &data->req;
 
-    /* pass in NULL for 'conn' here since we don't want to init the
+    /* pass in NULL for 'conn' here since we do not want to init the
        connection, only this transfer */
     Curl_init_do(data, NULL);
 
@@ -1742,7 +1707,7 @@ static CURLcode multi_do(struct Curl_easy *data, bool *done)
  * second connection.
  *
  * 'complete' can return 0 for incomplete, 1 for done and -1 for go back to
- * DOING state there's more work to do!
+ * DOING state there is more work to do!
  */
 
 static CURLcode multi_do_more(struct Curl_easy *data, int *complete)
@@ -1870,10 +1835,10 @@ static CURLcode protocol_connect(struct Curl_easy *data,
      && conn->bits.protoconnstart) {
     /* We already are connected, get back. This may happen when the connect
        worked fine in the first call, like when we connect to a local server
-       or proxy. Note that we don't know if the protocol is actually done.
+       or proxy. Note that we do not know if the protocol is actually done.
 
-       Unless this protocol doesn't have any protocol-connect callback, as
-       then we know we're done. */
+       Unless this protocol does not have any protocol-connect callback, as
+       then we know we are done. */
     if(!conn->handler->connecting)
       *protocol_done = TRUE;
 
@@ -1890,7 +1855,7 @@ static CURLcode protocol_connect(struct Curl_easy *data,
     else
       *protocol_done = TRUE;
 
-    /* it has started, possibly even completed but that knowledge isn't stored
+    /* it has started, possibly even completed but that knowledge is not stored
        in this bit! */
     if(!result)
       conn->bits.protoconnstart = TRUE;
@@ -1904,6 +1869,20 @@ static void set_in_callback(struct Curl_multi *multi, bool value)
   multi->in_callback = value;
 }
 
+/*
+ * posttransfer() is called immediately after a transfer ends
+ */
+static void multi_posttransfer(struct Curl_easy *data)
+{
+#if defined(HAVE_SIGNAL) && defined(SIGPIPE) && !defined(HAVE_MSG_NOSIGNAL)
+  /* restore the signal handler for SIGPIPE before we get back */
+  if(!data->set.no_signal)
+    signal(SIGPIPE, data->state.prev_signal);
+#else
+  (void)data; /* unused parameter */
+#endif
+}
+
 static CURLMcode multi_runsingle(struct Curl_multi *multi,
                                  struct curltime *nowp,
                                  struct Curl_easy *data)
@@ -1926,7 +1905,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
     /* a multi-level callback returned error before, meaning every individual
      transfer now has failed */
     result = CURLE_ABORTED_BY_CALLBACK;
-    Curl_posttransfer(data);
+    multi_posttransfer(data);
     multi_done(data, result, FALSE);
     multistate(data, MSTATE_COMPLETED);
   }
@@ -2009,7 +1988,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       if(!result) {
         *nowp = Curl_pgrsTime(data, TIMER_POSTQUEUE);
         if(async)
-          /* We're now waiting for an asynchronous name lookup */
+          /* We are now waiting for an asynchronous name lookup */
           multistate(data, MSTATE_RESOLVING);
         else {
           /* after the connect has been sent off, go WAITCONNECT unless the
@@ -2062,7 +2041,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       /* Update sockets here, because the socket(s) may have been
          closed and the application thus needs to be told, even if it
          is likely that the same socket(s) will again be used further
-         down.  If the name has not yet been resolved, it is likely
+         down. If the name has not yet been resolved, it is likely
          that new sockets have been opened in an attempt to contact
          another resolver. */
       rc = singlesocket(multi, data);
@@ -2132,7 +2111,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       }
       else if(result) {
         /* failure detected */
-        Curl_posttransfer(data);
+        multi_posttransfer(data);
         multi_done(data, result, TRUE);
         stream_error = TRUE;
         break;
@@ -2162,7 +2141,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       }
       else {
         /* failure detected */
-        Curl_posttransfer(data);
+        multi_posttransfer(data);
         multi_done(data, result, TRUE);
         stream_error = TRUE;
       }
@@ -2178,7 +2157,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       }
       else if(result) {
         /* failure detected */
-        Curl_posttransfer(data);
+        multi_posttransfer(data);
         multi_done(data, result, TRUE);
         stream_error = TRUE;
       }
@@ -2198,9 +2177,10 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
         Curl_set_in_callback(data, false);
         if(prereq_rc != CURL_PREREQFUNC_OK) {
           failf(data, "operation aborted by pre-request callback");
-          /* failure in pre-request callback - don't do any other processing */
+          /* failure in pre-request callback - do not do any other
+             processing */
           result = CURLE_ABORTED_BY_CALLBACK;
-          Curl_posttransfer(data);
+          multi_posttransfer(data);
           multi_done(data, result, FALSE);
           stream_error = TRUE;
           break;
@@ -2230,7 +2210,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
                 /* skip some states if it is important */
                 multi_done(data, CURLE_OK, FALSE);
 
-                /* if there's no connection left, skip the DONE state */
+                /* if there is no connection left, skip the DONE state */
                 multistate(data, data->conn ?
                            MSTATE_DONE : MSTATE_COMPLETED);
                 rc = CURLM_CALL_MULTI_PERFORM;
@@ -2246,13 +2226,13 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
 
           /* after DO, go DO_DONE... or DO_MORE */
           else if(data->conn->bits.do_more) {
-            /* we're supposed to do more, but we need to sit down, relax
+            /* we are supposed to do more, but we need to sit down, relax
                and wait a little while first */
             multistate(data, MSTATE_DOING_MORE);
             rc = CURLM_CALL_MULTI_PERFORM;
           }
           else {
-            /* we're done with the DO, now DID */
+            /* we are done with the DO, now DID */
             multistate(data, MSTATE_DID);
             rc = CURLM_CALL_MULTI_PERFORM;
           }
@@ -2261,7 +2241,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
                 data->conn->bits.reuse) {
           /*
            * In this situation, a connection that we were trying to use
-           * may have unexpectedly died.  If possible, send the connection
+           * may have unexpectedly died. If possible, send the connection
            * back to the CONNECT phase so we can try again.
            */
           char *newurl = NULL;
@@ -2275,7 +2255,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
             stream_error = TRUE;
           }
 
-          Curl_posttransfer(data);
+          multi_posttransfer(data);
           drc = multi_done(data, result, FALSE);
 
           /* When set to retry the connection, we must go back to the CONNECT
@@ -2295,19 +2275,19 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
               }
             }
             else {
-              /* done didn't return OK or SEND_ERROR */
+              /* done did not return OK or SEND_ERROR */
               result = drc;
             }
           }
           else {
-            /* Have error handler disconnect conn if we can't retry */
+            /* Have error handler disconnect conn if we cannot retry */
             stream_error = TRUE;
           }
           free(newurl);
         }
         else {
           /* failure detected */
-          Curl_posttransfer(data);
+          multi_posttransfer(data);
           if(data->conn)
             multi_done(data, result, FALSE);
           stream_error = TRUE;
@@ -2329,7 +2309,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       }
       else {
         /* failure detected */
-        Curl_posttransfer(data);
+        multi_posttransfer(data);
         multi_done(data, result, FALSE);
         stream_error = TRUE;
       }
@@ -2355,7 +2335,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       }
       else {
         /* failure detected */
-        Curl_posttransfer(data);
+        multi_posttransfer(data);
         multi_done(data, result, FALSE);
         stream_error = TRUE;
       }
@@ -2367,7 +2347,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
         /* Check if we can move pending requests to send pipe */
         process_pending_handles(multi); /*  multiplexed */
 
-      /* Only perform the transfer if there's a good socket to work with.
+      /* Only perform the transfer if there is a good socket to work with.
          Having both BAD is a signal to skip immediately to DONE */
       if((data->conn->sockfd != CURL_SOCKET_BAD) ||
          (data->conn->writesockfd != CURL_SOCKET_BAD))
@@ -2397,7 +2377,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
            result != CURLE_HTTP2_STREAM)
           streamclose(data->conn, "Transfer returned error");
 
-        Curl_posttransfer(data);
+        multi_posttransfer(data);
         multi_done(data, result, TRUE);
       }
       else {
@@ -2509,8 +2489,8 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       if(result) {
         /*
          * The transfer phase returned error, we mark the connection to get
-         * closed to prevent being reused. This is because we can't possibly
-         * know if the connection is in a good shape or not now.  Unless it is
+         * closed to prevent being reused. This is because we cannot possibly
+         * know if the connection is in a good shape or not now. Unless it is
          * a protocol which uses two "channels" like FTP, as then the error
          * happened in the data connection.
          */
@@ -2519,13 +2499,13 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
            result != CURLE_HTTP2_STREAM)
           streamclose(data->conn, "Transfer returned error");
 
-        Curl_posttransfer(data);
+        multi_posttransfer(data);
         multi_done(data, result, TRUE);
       }
       else if(data->req.done && !Curl_cwriter_is_paused(data)) {
 
         /* call this even if the readwrite function returned error */
-        Curl_posttransfer(data);
+        multi_posttransfer(data);
 
         /* When we follow redirects or is set to retry the connection, we must
            to go back to the CONNECT state */
@@ -2552,8 +2532,8 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
         else {
           /* after the transfer is done, go DONE */
 
-          /* but first check to see if we got a location info even though we're
-             not following redirects */
+          /* but first check to see if we got a location info even though we
+             are not following redirects */
           if(data->req.location) {
             free(newurl);
             newurl = data->req.location;
@@ -2571,10 +2551,10 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
           }
         }
       }
-      else if(data->state.select_bits) {
+      else if(data->state.select_bits && !Curl_xfer_is_blocked(data)) {
         /* This avoids CURLM_CALL_MULTI_PERFORM so that a very fast transfer
-           won't get stuck on this transfer at the expense of other concurrent
-           transfers */
+           will not get stuck on this transfer at the expense of other
+           concurrent transfers */
         Curl_expire(data, 0, EXPIRE_RUN_NOW);
       }
       free(newurl);
@@ -2610,8 +2590,8 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
         }
       }
 #endif
-      /* after we have DONE what we're supposed to do, go COMPLETED, and
-         it doesn't matter what the multi_done() returned! */
+      /* after we have DONE what we are supposed to do, go COMPLETED, and
+         it does not matter what the multi_done() returned! */
       multistate(data, MSTATE_COMPLETED);
       break;
 
@@ -2646,7 +2626,7 @@ statemachine_end:
     if(data->mstate < MSTATE_COMPLETED) {
       if(result) {
         /*
-         * If an error was returned, and we aren't in completed state now,
+         * If an error was returned, and we are not in completed state now,
          * then we go to completed and consider this transfer aborted.
          */
 
@@ -2658,12 +2638,12 @@ statemachine_end:
 
         if(data->conn) {
           if(stream_error) {
-            /* Don't attempt to send data over a connection that timed out */
+            /* Do not attempt to send data over a connection that timed out */
             bool dead_connection = result == CURLE_OPERATION_TIMEDOUT;
             struct connectdata *conn = data->conn;
 
             /* This is where we make sure that the conn pointer is reset.
-               We don't have to do this in every case block above where a
+               We do not have to do this in every case block above where a
                failure is detected */
             Curl_detach_connection(data);
 
@@ -2676,13 +2656,14 @@ statemachine_end:
         }
         else if(data->mstate == MSTATE_CONNECT) {
           /* Curl_connect() failed */
-          (void)Curl_posttransfer(data);
+          multi_posttransfer(data);
+          Curl_pgrsUpdate_nometer(data);
         }
 
         multistate(data, MSTATE_COMPLETED);
         rc = CURLM_CALL_MULTI_PERFORM;
       }
-      /* if there's still a connection to use, call the progress function */
+      /* if there is still a connection to use, call the progress function */
       else if(data->conn && Curl_pgrsUpdate(data)) {
         /* aborted due to progress callback return code must close the
            connection */
@@ -2733,6 +2714,7 @@ CURLMcode curl_multi_perform(struct Curl_multi *multi, int *running_handles)
   CURLMcode returncode = CURLM_OK;
   struct Curl_tree *t;
   struct curltime now = Curl_now();
+  SIGPIPE_VARIABLE(pipe_st);
 
   if(!GOOD_MULTI_HANDLE(multi))
     return CURLM_BAD_HANDLE;
@@ -2740,31 +2722,34 @@ CURLMcode curl_multi_perform(struct Curl_multi *multi, int *running_handles)
   if(multi->in_callback)
     return CURLM_RECURSIVE_API_CALL;
 
+  sigpipe_init(&pipe_st);
   data = multi->easyp;
   if(data) {
     CURLMcode result;
-    bool nosig = data->set.no_signal;
-    SIGPIPE_VARIABLE(pipe_st);
-    sigpipe_ignore(data, &pipe_st);
     /* Do the loop and only alter the signal ignore state if the next handle
        has a different NO_SIGNAL state than the previous */
     do {
       /* the current node might be unlinked in multi_runsingle(), get the next
          pointer now */
       struct Curl_easy *datanext = data->next;
-      if(data->set.no_signal != nosig) {
-        sigpipe_restore(&pipe_st);
-        sigpipe_ignore(data, &pipe_st);
-        nosig = data->set.no_signal;
+
+    if(data != multi->conn_cache.closure_handle) {
+        /* connection cache handle is processed below */
+        sigpipe_apply(data, &pipe_st);
+        result = multi_runsingle(multi, &now, data);
+        if(result)
+          returncode = result;
       }
-      result = multi_runsingle(multi, &now, data);
-      if(result)
-        returncode = result;
+
       data = datanext; /* operate on next handle */
     } while(data);
-    sigpipe_restore(&pipe_st);
   }
 
+  sigpipe_apply(multi->conn_cache.closure_handle, &pipe_st);
+  Curl_conncache_multi_perform(multi);
+
+  sigpipe_restore(&pipe_st);
+
   /*
    * Simply remove all expired timers from the splay since handles are dealt
    * with unconditionally by this function and curl_multi_timeout() requires
@@ -2793,7 +2778,8 @@ CURLMcode curl_multi_perform(struct Curl_multi *multi, int *running_handles)
     }
   } while(t);
 
-  *running_handles = multi->num_alive;
+  if(running_handles)
+    *running_handles = (int)multi->num_alive;
 
   if(CURLM_OK >= returncode)
     returncode = Curl_update_timer(multi);
@@ -2829,6 +2815,9 @@ CURLMcode curl_multi_cleanup(struct Curl_multi *multi)
     /* First remove all remaining easy handles */
     data = multi->easyp;
     while(data) {
+      if(!GOOD_EASY_HANDLE(data))
+        return CURLM_BAD_HANDLE;
+
       nextdata = data->next;
       if(!data->state.done && data->conn)
         /* if DONE was never called for this handle */
@@ -2853,9 +2842,10 @@ CURLMcode curl_multi_cleanup(struct Curl_multi *multi)
     }
 
     /* Close all the connections in the connection cache */
-    Curl_conncache_close_all_connections(&multi->conn_cache);
+    Curl_conncache_multi_close_all(multi);
 
     sockhash_destroy(&multi->sockhash);
+    Curl_hash_destroy(&multi->proto_hash);
     Curl_conncache_destroy(&multi->conn_cache);
     Curl_hash_destroy(&multi->hostcache);
     Curl_psl_destroy(&multi->psl);
@@ -2865,12 +2855,10 @@ CURLMcode curl_multi_cleanup(struct Curl_multi *multi)
 #else
 #ifdef ENABLE_WAKEUP
     wakeup_close(multi->wakeup_pair[0]);
+#ifndef USE_EVENTFD
     wakeup_close(multi->wakeup_pair[1]);
 #endif
 #endif
-
-#ifdef USE_SSL
-    Curl_free_multi_ssl_backend_data(multi->ssl_backend_data);
 #endif
 
     multi_xfer_bufs_free(multi);
@@ -2927,41 +2915,54 @@ static CURLMcode singlesocket(struct Curl_multi *multi,
                               struct Curl_easy *data)
 {
   struct easy_pollset cur_poll;
-  unsigned int i;
-  struct Curl_sh_entry *entry;
-  curl_socket_t s;
-  int rc;
+  CURLMcode mresult;
 
   /* Fill in the 'current' struct with the state as it is now: what sockets to
      supervise and for what actions */
   multi_getsock(data, &cur_poll);
+  mresult = Curl_multi_pollset_ev(multi, data, &cur_poll, &data->last_poll);
+
+  if(!mresult) /* Remember for next time */
+    memcpy(&data->last_poll, &cur_poll, sizeof(cur_poll));
+  return mresult;
+}
+
+CURLMcode Curl_multi_pollset_ev(struct Curl_multi *multi,
+                                struct Curl_easy *data,
+                                struct easy_pollset *ps,
+                                struct easy_pollset *last_ps)
+{
+  unsigned int i;
+  struct Curl_sh_entry *entry;
+  curl_socket_t s;
+  int rc;
 
   /* We have 0 .. N sockets already and we get to know about the 0 .. M
      sockets we should have from now on. Detect the differences, remove no
      longer supervised ones and add new ones */
 
   /* walk over the sockets we got right now */
-  for(i = 0; i < cur_poll.num; i++) {
-    unsigned char cur_action = cur_poll.actions[i];
+  for(i = 0; i < ps->num; i++) {
+    unsigned char cur_action = ps->actions[i];
     unsigned char last_action = 0;
     int comboaction;
 
-    s = cur_poll.sockets[i];
+    s = ps->sockets[i];
 
     /* get it from the hash */
     entry = sh_getentry(&multi->sockhash, s);
     if(entry) {
       /* check if new for this transfer */
       unsigned int j;
-      for(j = 0; j< data->last_poll.num; j++) {
-        if(s == data->last_poll.sockets[j]) {
-          last_action = data->last_poll.actions[j];
+      for(j = 0; j< last_ps->num; j++) {
+        if(s == last_ps->sockets[j]) {
+          last_action = last_ps->actions[j];
           break;
         }
       }
     }
     else {
-      /* this is a socket we didn't have before, add it to the hash! */
+      /* this is a socket we did not have before, add it to the hash! */
       entry = sh_addentry(&multi->sockhash, s);
       if(!entry)
         /* fatal */
@@ -2978,14 +2979,15 @@ static CURLMcode singlesocket(struct Curl_multi *multi,
       if(cur_action & CURL_POLL_OUT)
         entry->writers++;
     }
-    else if(!last_action) {
+    else if(!last_action &&
+            !Curl_hash_pick(&entry->transfers, (char *)&data, /* hash key */
+                            sizeof(struct Curl_easy *))) {
       /* a new transfer using this socket */
       entry->users++;
       if(cur_action & CURL_POLL_IN)
         entry->readers++;
       if(cur_action & CURL_POLL_OUT)
         entry->writers++;
-
       /* add 'data' to the transfer hash on this socket! */
       if(!Curl_hash_add(&entry->transfers, (char *)&data, /* hash key */
                         sizeof(struct Curl_easy *), data)) {
@@ -3014,18 +3016,19 @@ static CURLMcode singlesocket(struct Curl_multi *multi,
       }
     }
 
-    entry->action = comboaction; /* store the current action state */
+    /* store the current action state */
+    entry->action = (unsigned int)comboaction;
   }
 
-  /* Check for last_poll.sockets that no longer appear in cur_poll.sockets.
+  /* Check for last_poll.sockets that no longer appear in ps->sockets.
    * Need to remove the easy handle from the multi->sockhash->transfers and
    * remove multi->sockhash entry when this was the last transfer */
-  for(i = 0; i< data->last_poll.num; i++) {
+  for(i = 0; i < last_ps->num; i++) {
     unsigned int j;
     bool stillused = FALSE;
-    s = data->last_poll.sockets[i];
-    for(j = 0; j < cur_poll.num; j++) {
-      if(s == cur_poll.sockets[j]) {
+    s = last_ps->sockets[i];
+    for(j = 0; j < ps->num; j++) {
+      if(s == ps->sockets[j]) {
         /* this is still supervised */
         stillused = TRUE;
         break;
@@ -3038,7 +3041,7 @@ static CURLMcode singlesocket(struct Curl_multi *multi,
     /* if this is NULL here, the socket has been closed and notified so
        already by Curl_multi_closed() */
     if(entry) {
-      unsigned char oldactions = data->last_poll.actions[i];
+      unsigned char oldactions = last_ps->actions[i];
       /* this socket has been removed. Decrease user count */
       entry->users--;
       if(oldactions & CURL_POLL_OUT)
@@ -3068,8 +3071,6 @@ static CURLMcode singlesocket(struct Curl_multi *multi,
     }
   } /* for loop over num */
 
-  /* Remember for next time */
-  memcpy(&data->last_poll, &cur_poll, sizeof(data->last_poll));
   return CURLM_OK;
 }
 
@@ -3085,7 +3086,7 @@ CURLcode Curl_updatesocket(struct Curl_easy *data)
  * Curl_multi_closed()
  *
  * Used by the connect code to tell the multi_socket code that one of the
- * sockets we were using is about to be closed.  This function will then
+ * sockets we were using is about to be closed. This function will then
  * remove it from the sockethash for this handle to make the multi_socket API
  * behave properly, especially for the case when libcurl will create another
  * socket again and it gets the same file descriptor number.
@@ -3094,7 +3095,7 @@ CURLcode Curl_updatesocket(struct Curl_easy *data)
 void Curl_multi_closed(struct Curl_easy *data, curl_socket_t s)
 {
   if(data) {
-    /* if there's still an easy handle associated with this connection */
+    /* if there is still an easy handle associated with this connection */
     struct Curl_multi *multi = data->multi;
     if(multi) {
       /* this is set if this connection is part of a handle that is added to
@@ -3170,7 +3171,7 @@ static CURLMcode add_next_timeout(struct curltime now,
     /* copy the first entry to 'tv' */
     memcpy(tv, &node->time, sizeof(*tv));
 
-    /* Insert this node again into the splay.  Keep the timer in the list in
+    /* Insert this node again into the splay. Keep the timer in the list in
        case we need to recompute future timers. */
     multi->timetree = Curl_splayinsert(*tv, multi->timetree,
                                        &d->state.timenode);
@@ -3188,8 +3189,7 @@ static CURLMcode multi_socket(struct Curl_multi *multi,
   struct Curl_easy *data = NULL;
   struct Curl_tree *t;
   struct curltime now = Curl_now();
-  bool first = FALSE;
-  bool nosig = FALSE;
+  bool run_conn_cache = FALSE;
   SIGPIPE_VARIABLE(pipe_st);
 
   if(checkall) {
@@ -3212,13 +3212,16 @@ static CURLMcode multi_socket(struct Curl_multi *multi,
   if(s != CURL_SOCKET_TIMEOUT) {
     struct Curl_sh_entry *entry = sh_getentry(&multi->sockhash, s);
 
-    if(!entry)
-      /* Unmatched socket, we can't act on it but we ignore this fact.  In
+    if(!entry) {
+      /* Unmatched socket, we cannot act on it but we ignore this fact. In
          real-world tests it has been proved that libevent can in fact give
          the application actions even though the socket was just previously
          asked to get removed, so thus we better survive stray socket actions
          and just move on. */
-      ;
+      /* The socket might come from a connection that is being shut down
+       * by the multi's conncache. */
+      Curl_conncache_multi_socket(multi, s, ev_bitmask);
+    }
     else {
       struct Curl_hash_iterator iter;
       struct Curl_hash_element *he;
@@ -3231,19 +3234,23 @@ static CURLMcode multi_socket(struct Curl_multi *multi,
         DEBUGASSERT(data);
         DEBUGASSERT(data->magic == CURLEASY_MAGIC_NUMBER);
 
-        if(data->conn && !(data->conn->handler->flags & PROTOPT_DIRLOCK))
-          /* set socket event bitmask if they're not locked */
-          data->state.select_bits |= (unsigned char)ev_bitmask;
+        if(data == multi->conn_cache.closure_handle)
+          run_conn_cache = TRUE;
+        else {
+          if(data->conn && !(data->conn->handler->flags & PROTOPT_DIRLOCK))
+            /* set socket event bitmask if they are not locked */
+            data->state.select_bits |= (unsigned char)ev_bitmask;
 
-        Curl_expire(data, 0, EXPIRE_RUN_NOW);
+          Curl_expire(data, 0, EXPIRE_RUN_NOW);
+        }
       }
 
-      /* Now we fall-through and do the timer-based stuff, since we don't want
+      /* Now we fall-through and do the timer-based stuff, since we do not want
          to force the user to have to deal with timeouts as long as at least
          one connection in fact has traffic. */
 
       data = NULL; /* set data to NULL again to avoid calling
-                      multi_runsingle() in case there's no need to */
+                      multi_runsingle() in case there is no need to */
       now = Curl_now(); /* get a newer time since the multi_runsingle() loop
                            may have taken some time */
     }
@@ -3262,19 +3269,13 @@ static CURLMcode multi_socket(struct Curl_multi *multi,
    * to process in the splay and 'data' will be re-assigned for every expired
    * handle we deal with.
    */
+  sigpipe_init(&pipe_st);
   do {
+    if(data == multi->conn_cache.closure_handle)
+      run_conn_cache = TRUE;
     /* the first loop lap 'data' can be NULL */
-    if(data) {
-      if(!first) {
-        first = TRUE;
-        nosig = data->set.no_signal; /* initial state */
-        sigpipe_ignore(data, &pipe_st);
-      }
-      else if(data->set.no_signal != nosig) {
-        sigpipe_restore(&pipe_st);
-        sigpipe_ignore(data, &pipe_st);
-        nosig = data->set.no_signal; /* remember new state */
-      }
+    else if(data) {
+      sigpipe_apply(data, &pipe_st);
       result = multi_runsingle(multi, &now, data);
 
       if(CURLM_OK >= result) {
@@ -3286,7 +3287,7 @@ static CURLMcode multi_socket(struct Curl_multi *multi,
       }
     }
 
-    /* Check if there's one (more) expired timer to deal with! This function
+    /* Check if there is one (more) expired timer to deal with! This function
        extracts a matching node if there is one */
 
     multi->timetree = Curl_splaygetbest(now, multi->timetree, &t);
@@ -3296,10 +3297,16 @@ static CURLMcode multi_socket(struct Curl_multi *multi,
     }
 
   } while(t);
-  if(first)
-    sigpipe_restore(&pipe_st);
 
-  *running_handles = multi->num_alive;
+  if(run_conn_cache) {
+    sigpipe_apply(multi->conn_cache.closure_handle, &pipe_st);
+    Curl_conncache_multi_perform(multi);
+  }
+
+  sigpipe_restore(&pipe_st);
+
+  if(running_handles)
+    *running_handles = (int)multi->num_alive;
   return result;
 }
 
@@ -3351,6 +3358,9 @@ CURLMcode curl_multi_setopt(struct Curl_multi *multi,
     break;
   case CURLMOPT_MAX_TOTAL_CONNECTIONS:
     multi->max_total_connections = va_arg(param, long);
+    /* for now, let this also decide the max number of connections
+     * in shutdown handling */
+    multi->max_shutdown_connections = va_arg(param, long);
     break;
     /* options formerly used for pipelining */
   case CURLMOPT_MAX_PIPELINE_LENGTH:
@@ -3437,7 +3447,7 @@ static CURLMcode multi_timeout(struct Curl_multi *multi,
     if(Curl_splaycomparekeys(multi->timetree->key, now) > 0) {
       /* some time left before expiration */
       timediff_t diff = Curl_timediff_ceil(multi->timetree->key, now);
-      /* this should be safe even on 32 bit archs, as we don't use that
+      /* this should be safe even on 32-bit archs, as we do not use that
          overly long timeouts */
       *timeout_ms = (long)diff;
     }
@@ -3482,7 +3492,7 @@ CURLMcode Curl_update_timer(struct Curl_multi *multi)
     static const struct curltime none = {0, 0};
     if(Curl_splaycomparekeys(none, multi->timer_lastcall)) {
       multi->timer_lastcall = none;
-      /* there's no timeout now but there was one previously, tell the app to
+      /* there is no timeout now but there was one previously, tell the app to
          disable it */
       set_in_callback(multi, TRUE);
       rc = multi->timer_cb(multi, -1, multi->timer_userp);
@@ -3603,8 +3613,8 @@ void Curl_expire(struct Curl_easy *data, timediff_t milli, expire_id id)
   DEBUGASSERT(id < EXPIRE_LAST);
 
   set = Curl_now();
-  set.tv_sec += (time_t)(milli/1000); /* might be a 64 to 32 bit conversion */
-  set.tv_usec += (unsigned int)(milli%1000)*1000;
+  set.tv_sec += (time_t)(milli/1000); /* might be a 64 to 32 bits conversion */
+  set.tv_usec += (int)(milli%1000)*1000;
 
   if(set.tv_usec >= 1000000) {
     set.tv_sec++;
@@ -3614,7 +3624,7 @@ void Curl_expire(struct Curl_easy *data, timediff_t milli, expire_id id)
   /* Remove any timer with the same id just in case. */
   multi_deltimeout(data, id);
 
-  /* Add it to the timer list.  It must stay in the list until it has expired
+  /* Add it to the timer list. It must stay in the list until it has expired
      in case we need to recompute the minimum timer later. */
   multi_addtimeout(data, &set, id);
 
@@ -3627,7 +3637,7 @@ void Curl_expire(struct Curl_easy *data, timediff_t milli, expire_id id)
 
     if(diff > 0) {
       /* The current splay tree entry is sooner than this new expiry time.
-         We don't need to update our splay tree entry. */
+         We do not need to update our splay tree entry. */
       return;
     }
 
@@ -3718,12 +3728,12 @@ CURLMcode curl_multi_assign(struct Curl_multi *multi, curl_socket_t s,
 
 size_t Curl_multi_max_host_connections(struct Curl_multi *multi)
 {
-  return multi ? multi->max_host_connections : 0;
+  return multi ? (size_t)multi->max_host_connections : 0;
 }
 
 size_t Curl_multi_max_total_connections(struct Curl_multi *multi)
 {
-  return multi ? multi->max_total_connections : 0;
+  return multi ? (size_t)multi->max_total_connections : 0;
 }
 
 /*
diff --git a/lib/multihandle.h b/lib/multihandle.h
index add9a0518..9b80beab9 100644
--- a/lib/multihandle.h
+++ b/lib/multihandle.h
@@ -80,10 +80,6 @@ typedef enum {
 /* value for MAXIMUM CONCURRENT STREAMS upper limit */
 #define INITIAL_MAX_CONCURRENT_STREAMS ((1U << 31) - 1)
 
-/* Curl_multi SSL backend-specific data; declared differently by each SSL
-   backend */
-struct multi_ssl_backend_data;
-
 /* This is the struct known as CURLM on the outside */
 struct Curl_multi {
   /* First a simple identifier to easier detect if a user mix up
@@ -132,14 +128,17 @@ struct Curl_multi {
   char *xfer_ulbuf; /* the actual buffer */
   size_t xfer_ulbuf_len;      /* the allocated length */
 
-#if defined(USE_SSL)
-  struct multi_ssl_backend_data *ssl_backend_data;
-#endif
-
   /* 'sockhash' is the lookup hash for socket descriptor => easy handles (note
      the pluralis form, there can be more than one easy handle waiting on the
      same actual socket) */
   struct Curl_hash sockhash;
+  /* `proto_hash` is a general key-value store for protocol implementations
+   * with the lifetime of the multi handle. The number of elements kept here
+   * should be in the order of supported protocols (and sub-protocols like
+   * TLS), *not* in the order of connections or current transfers!
+   * Elements need to be added with their own destructor to be invoked when
+   * the multi handle is cleaned up (see Curl_hash_add2()).*/
+  struct Curl_hash proto_hash;
 
   /* Shared connection cache (bundles)*/
   struct conncache conn_cache;
@@ -149,6 +148,8 @@ struct Curl_multi {
 
   long max_total_connections; /* if >0, a fixed limit of the maximum number
                                  of connections in total */
+  long max_shutdown_connections; /* if >0, a fixed limit of the maximum number
+                                 of connections in shutdown handling */
 
   /* timer callback and user data pointer for the *socket() API */
   curl_multi_timer_callback timer_cb;
@@ -159,13 +160,14 @@ struct Curl_multi {
   WSAEVENT wsa_event; /* winsock event used for waits */
 #else
 #ifdef ENABLE_WAKEUP
-  curl_socket_t wakeup_pair[2]; /* pipe()/socketpair() used for wakeup
-                                   0 is used for read, 1 is used for write */
+  curl_socket_t wakeup_pair[2]; /* eventfd()/pipe()/socketpair() used for
+                                   wakeup 0 is used for read, 1 is used
+                                   for write */
 #endif
 #endif
   unsigned int max_concurrent_streams;
   unsigned int maxconnects; /* if >0, a fixed limit of the maximum number of
-                               entries we're allowed to grow the connection
+                               entries we are allowed to grow the connection
                                cache to */
 #define IPV6_UNKNOWN 0
 #define IPV6_DEAD    1
diff --git a/lib/multiif.h b/lib/multiif.h
index 59a30646c..d3c12baee 100644
--- a/lib/multiif.h
+++ b/lib/multiif.h
@@ -76,7 +76,7 @@ void Curl_multiuse_state(struct Curl_easy *data,
  * Curl_multi_closed()
  *
  * Used by the connect code to tell the multi_socket code that one of the
- * sockets we were using is about to be closed.  This function will then
+ * sockets we were using is about to be closed. This function will then
  * remove it from the sockethash for this handle to make the multi_socket API
  * behave properly, especially for the case when libcurl will create another
  * socket again and it gets the same file descriptor number.
@@ -84,6 +84,15 @@ void Curl_multiuse_state(struct Curl_easy *data,
 
 void Curl_multi_closed(struct Curl_easy *data, curl_socket_t s);
 
+/* Compare the two pollsets to notify the multi_socket API of changes
+ * in socket polling, e.g calling multi->socket_cb() with the changes if
+ * differences are seen.
+ */
+CURLMcode Curl_multi_pollset_ev(struct Curl_multi *multi,
+                                struct Curl_easy *data,
+                                struct easy_pollset *ps,
+                                struct easy_pollset *last_ps);
+
 /*
  * Add a handle and move it into PERFORM state at once. For pushed streams.
  */
diff --git a/lib/netrc.c b/lib/netrc.c
index cd2a2844e..571fc7359 100644
--- a/lib/netrc.c
+++ b/lib/netrc.c
@@ -237,7 +237,7 @@ static int parsenetrc(const char *host,
           else if(strcasecompare("password", tok))
             state_password = 1;
           else if(strcasecompare("machine", tok)) {
-            /* ok, there's machine here go => */
+            /* ok, there is machine here go => */
             state = HOSTFOUND;
             state_our_login = FALSE;
           }
@@ -277,7 +277,7 @@ out:
 /*
  * @unittest: 1304
  *
- * *loginp and *passwordp MUST be allocated if they aren't NULL when passed
+ * *loginp and *passwordp MUST be allocated if they are not NULL when passed
  * in.
  */
 int Curl_parsenetrc(const char *host, char **loginp, char **passwordp,
diff --git a/lib/netrc.h b/lib/netrc.h
index 9f2815f3b..37c95db5e 100644
--- a/lib/netrc.h
+++ b/lib/netrc.h
@@ -27,7 +27,7 @@
 #include "curl_setup.h"
 #ifndef CURL_DISABLE_NETRC
 
-/* returns -1 on failure, 0 if the host is found, 1 is the host isn't found */
+/* returns -1 on failure, 0 if the host is found, 1 is the host is not found */
 int Curl_parsenetrc(const char *host, char **loginp,
                     char **passwordp, char *filename);
   /* Assume: (*passwordp)[0]=0, host[0] != 0.
diff --git a/lib/nonblock.c b/lib/nonblock.c
index f4eb65612..9ee93db2e 100644
--- a/lib/nonblock.c
+++ b/lib/nonblock.c
@@ -50,9 +50,18 @@ int curlx_nonblock(curl_socket_t sockfd,    /* operate on this */
   /* most recent unix versions */
   int flags;
   flags = sfcntl(sockfd, F_GETFL, 0);
+  if(flags < 0)
+    return -1;
+  /* Check if the current file status flags have already satisfied
+   * the request, if so, it is no need to call fcntl() to replicate it.
+   */
+  if(!!(flags & O_NONBLOCK) == !!nonblock)
+    return 0;
   if(nonblock)
-    return sfcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
-  return sfcntl(sockfd, F_SETFL, flags & (~O_NONBLOCK));
+    flags |= O_NONBLOCK;
+  else
+    flags &= ~O_NONBLOCK;
+  return sfcntl(sockfd, F_SETFL, flags);
 
 #elif defined(HAVE_IOCTL_FIONBIO)
 
@@ -64,7 +73,7 @@ int curlx_nonblock(curl_socket_t sockfd,    /* operate on this */
 
   /* Windows */
   unsigned long flags = nonblock ? 1UL : 0UL;
-  return ioctlsocket(sockfd, FIONBIO, &flags);
+  return ioctlsocket(sockfd, (long)FIONBIO, &flags);
 
 #elif defined(HAVE_IOCTLSOCKET_CAMEL_FIONBIO)
 
diff --git a/lib/noproxy.c b/lib/noproxy.c
index 62299e28f..dbfafc93e 100644
--- a/lib/noproxy.c
+++ b/lib/noproxy.c
@@ -79,22 +79,22 @@ UNITTEST bool Curl_cidr6_match(const char *ipv6,
                                unsigned int bits)
 {
 #ifdef USE_IPV6
-  int bytes;
-  int rest;
+  unsigned int bytes;
+  unsigned int rest;
   unsigned char address[16];
   unsigned char check[16];
 
   if(!bits)
     bits = 128;
 
-  bytes = bits/8;
+  bytes = bits / 8;
   rest = bits & 0x07;
+  if((bytes > 16) || ((bytes == 16) && rest))
+    return FALSE;
   if(1 != Curl_inet_pton(AF_INET6, ipv6, address))
     return FALSE;
   if(1 != Curl_inet_pton(AF_INET6, network, check))
     return FALSE;
-  if((bytes > 16) || ((bytes == 16) && rest))
-    return FALSE;
   if(bytes && memcmp(address, check, bytes))
     return FALSE;
   if(rest && !((address[bytes] ^ check[bytes]) & (0xff << (8 - rest))))
@@ -119,13 +119,12 @@ enum nametype {
 * Checks if the host is in the noproxy list. returns TRUE if it matches and
 * therefore the proxy should NOT be used.
 ****************************************************************/
-bool Curl_check_noproxy(const char *name, const char *no_proxy,
-                        bool *spacesep)
+bool Curl_check_noproxy(const char *name, const char *no_proxy)
 {
   char hostip[128];
-  *spacesep = FALSE;
+
   /*
-   * If we don't have a hostname at all, like for example with a FILE
+   * If we do not have a hostname at all, like for example with a FILE
    * transfer, we have nothing to interrogate the noproxy list with.
    */
   if(!name || name[0] == '\0')
@@ -143,7 +142,7 @@ bool Curl_check_noproxy(const char *name, const char *no_proxy,
     if(!strcmp("*", no_proxy))
       return TRUE;
 
-    /* NO_PROXY was specified and it wasn't just an asterisk */
+    /* NO_PROXY was specified and it was not just an asterisk */
 
     if(name[0] == '[') {
       char *endptr;
@@ -166,7 +165,7 @@ bool Curl_check_noproxy(const char *name, const char *no_proxy,
       if(1 == Curl_inet_pton(AF_INET, name, &address))
         type = TYPE_IPV4;
       else {
-        /* ignore trailing dots in the host name */
+        /* ignore trailing dots in the hostname */
         if(name[namelen - 1] == '.')
           namelen--;
       }
@@ -232,7 +231,9 @@ bool Curl_check_noproxy(const char *name, const char *no_proxy,
           slash = strchr(check, '/');
           /* if the slash is part of this token, use it */
           if(slash) {
-            bits = atoi(slash + 1);
+            /* if the bits variable gets a crazy value here, that is fine as
+               the value will then be rejected in the cidr function */
+            bits = (unsigned int)atoi(slash + 1);
             *slash = 0; /* null terminate there */
           }
           if(type == TYPE_IPV6)
@@ -248,16 +249,14 @@ bool Curl_check_noproxy(const char *name, const char *no_proxy,
       /* pass blanks after pattern */
       while(ISBLANK(*p))
         p++;
-      /* if not a comma! */
-      if(*p && (*p != ',')) {
-        *spacesep = TRUE;
-        continue;
-      }
+      /* if not a comma, this ends the loop */
+      if(*p != ',')
+        break;
       /* pass any number of commas */
       while(*p == ',')
         p++;
     } /* while(*p) */
-  } /* NO_PROXY was specified and it wasn't just an asterisk */
+  } /* NO_PROXY was specified and it was not just an asterisk */
 
   return FALSE;
 }
diff --git a/lib/noproxy.h b/lib/noproxy.h
index a3a680772..71ae7eaaf 100644
--- a/lib/noproxy.h
+++ b/lib/noproxy.h
@@ -27,7 +27,7 @@
 
 #ifndef CURL_DISABLE_PROXY
 
-#ifdef DEBUGBUILD
+#ifdef UNITTESTS
 
 UNITTEST bool Curl_cidr4_match(const char *ipv4,    /* 1.2.3.4 address */
                                const char *network, /* 1.2.3.4 address */
@@ -37,9 +37,7 @@ UNITTEST bool Curl_cidr6_match(const char *ipv6,
                                unsigned int bits);
 #endif
 
-bool Curl_check_noproxy(const char *name, const char *no_proxy,
-                        bool *spacesep);
-
+bool Curl_check_noproxy(const char *name, const char *no_proxy);
 #endif
 
 #endif /* HEADER_CURL_NOPROXY_H */
diff --git a/lib/openldap.c b/lib/openldap.c
index 0348ef5ba..1b35ba0d7 100644
--- a/lib/openldap.c
+++ b/lib/openldap.c
@@ -921,7 +921,7 @@ static CURLcode oldap_do(struct Curl_easy *data, bool *done)
       else {
         lr->msgid = msgid;
         data->req.p.ldap = lr;
-        Curl_xfer_setup(data, FIRSTSOCKET, -1, FALSE, -1);
+        Curl_xfer_setup1(data, CURL_XFER_RECV, -1, FALSE);
         *done = TRUE;
       }
     }
@@ -1152,7 +1152,7 @@ ldapsb_tls_remove(Sockbuf_IO_Desc *sbiod)
   return 0;
 }
 
-/* We don't need to do anything because libcurl does it already */
+/* We do not need to do anything because libcurl does it already */
 static int
 ldapsb_tls_close(Sockbuf_IO_Desc *sbiod)
 {
diff --git a/lib/parsedate.c b/lib/parsedate.c
index 1a7195b16..d35b58b0d 100644
--- a/lib/parsedate.c
+++ b/lib/parsedate.c
@@ -244,7 +244,7 @@ static int checkmonth(const char *check, size_t len)
 }
 
 /* return the time zone offset between GMT and the input one, in number
-   of seconds or -1 if the timezone wasn't found/legal */
+   of seconds or -1 if the timezone was not found/legal */
 
 static int checktz(const char *check, size_t len)
 {
@@ -265,7 +265,7 @@ static int checktz(const char *check, size_t len)
 
 static void skip(const char **date)
 {
-  /* skip everything that aren't letters or digits */
+  /* skip everything that are not letters or digits */
   while(**date && !ISALNUM(**date))
     (*date)++;
 }
@@ -277,7 +277,7 @@ enum assume {
 };
 
 /*
- * time2epoch: time stamp to seconds since epoch in GMT time zone.  Similar to
+ * time2epoch: time stamp to seconds since epoch in GMT time zone. Similar to
  * mktime but for GMT only.
  */
 static time_t time2epoch(int sec, int min, int hour,
@@ -445,7 +445,7 @@ static int parsedate(const char *date, time_t *output)
            ((date[-1] == '+' || date[-1] == '-'))) {
           /* four digits and a value less than or equal to 1400 (to take into
              account all sorts of funny time zone diffs) and it is preceded
-             with a plus or minus. This is a time zone indication.  1400 is
+             with a plus or minus. This is a time zone indication. 1400 is
              picked since +1300 is frequently used and +1400 is mentioned as
              an edge number in the document "ISO C 200X Proposal: Timezone
              Functions" at http://david.tribble.com/text/c0xtimezone.html If
@@ -521,13 +521,13 @@ static int parsedate(const char *date, time_t *output)
 #if (SIZEOF_TIME_T < 5)
 
 #ifdef HAVE_TIME_T_UNSIGNED
-  /* an unsigned 32 bit time_t can only hold dates to 2106 */
+  /* an unsigned 32-bit time_t can only hold dates to 2106 */
   if(yearnum > 2105) {
     *output = TIME_T_MAX;
     return PARSEDATE_LATER;
   }
 #else
-  /* a signed 32 bit time_t can only hold dates to the beginning of 2038 */
+  /* a signed 32-bit time_t can only hold dates to the beginning of 2038 */
   if(yearnum > 2037) {
     *output = TIME_T_MAX;
     return PARSEDATE_LATER;
@@ -549,7 +549,7 @@ static int parsedate(const char *date, time_t *output)
     return PARSEDATE_FAIL; /* clearly an illegal date */
 
   /* time2epoch() returns a time_t. time_t is often 32 bits, sometimes even on
-     architectures that feature 64 bit 'long' but ultimately time_t is the
+     architectures that feature a 64 bits 'long' but ultimately time_t is the
      correct data type to use.
   */
   t = time2epoch(secnum, minnum, hournum, mdaynum, monnum, yearnum);
diff --git a/lib/pingpong.c b/lib/pingpong.c
index 81576c08c..7ce81e8af 100644
--- a/lib/pingpong.c
+++ b/lib/pingpong.c
@@ -119,7 +119,7 @@ CURLcode Curl_pp_statemach(struct Curl_easy *data,
                            interval_ms);
 
   if(block) {
-    /* if we didn't wait, we don't have to spend time on this now */
+    /* if we did not wait, we do not have to spend time on this now */
     if(Curl_pgrsUpdate(data))
       result = CURLE_ABORTED_BY_CALLBACK;
     else
@@ -179,7 +179,7 @@ CURLcode Curl_pp_vsendf(struct Curl_easy *data,
   DEBUGASSERT(pp->sendthis == NULL);
 
   if(!conn)
-    /* can't send without a connection! */
+    /* cannot send without a connection! */
     return CURLE_SEND_ERROR;
 
   Curl_dyn_reset(&pp->sendbuf);
@@ -329,7 +329,7 @@ CURLcode Curl_pp_readresp(struct Curl_easy *data,
     char *nl = memchr(line, '\n', Curl_dyn_len(&pp->recvbuf));
     if(nl) {
       /* a newline is CRLF in pp-talk, so the CR is ignored as
-         the line isn't really terminated until the LF comes */
+         the line is not really terminated until the LF comes */
       size_t length = nl - line + 1;
 
       /* output debug output if that is requested */
@@ -372,7 +372,7 @@ CURLcode Curl_pp_readresp(struct Curl_easy *data,
       break;
     }
 
-  } while(1); /* while there's buffer left to scan */
+  } while(1); /* while there is buffer left to scan */
 
   pp->pending_resp = FALSE;
 
diff --git a/lib/pingpong.h b/lib/pingpong.h
index 28172c728..62f2467fc 100644
--- a/lib/pingpong.h
+++ b/lib/pingpong.h
@@ -37,7 +37,7 @@ struct connectdata;
 typedef enum {
   PPTRANSFER_BODY, /* yes do transfer a body */
   PPTRANSFER_INFO, /* do still go through to get info/headers */
-  PPTRANSFER_NONE  /* don't get anything and don't get info */
+  PPTRANSFER_NONE  /* do not get anything and do not get info */
 } curl_pp_transfer;
 
 /*
@@ -83,7 +83,7 @@ struct pingpong {
  * Curl_pp_statemach()
  *
  * called repeatedly until done. Set 'wait' to make it wait a while on the
- * socket if there's no traffic.
+ * socket if there is no traffic.
  */
 CURLcode Curl_pp_statemach(struct Curl_easy *data, struct pingpong *pp,
                            bool block, bool disconnecting);
diff --git a/lib/pop3.c b/lib/pop3.c
index 9a3033152..4cf1782ac 100644
--- a/lib/pop3.c
+++ b/lib/pop3.c
@@ -406,7 +406,7 @@ static CURLcode pop3_perform_user(struct Curl_easy *data,
   CURLcode result = CURLE_OK;
 
   /* Check we have a username and password to authenticate with and end the
-     connect phase if we don't */
+     connect phase if we do not */
   if(!data->state.aptr.user) {
     pop3_state(data, POP3_STOP);
 
@@ -440,7 +440,7 @@ static CURLcode pop3_perform_apop(struct Curl_easy *data,
   char secret[2 * MD5_DIGEST_LEN + 1];
 
   /* Check we have a username and password to authenticate with and end the
-     connect phase if we don't */
+     connect phase if we do not */
   if(!data->state.aptr.user) {
     pop3_state(data, POP3_STOP);
 
@@ -550,7 +550,7 @@ static CURLcode pop3_perform_authentication(struct Curl_easy *data,
   saslprogress progress = SASL_IDLE;
 
   /* Check we have enough data to authenticate with and end the
-     connect phase if we don't */
+     connect phase if we do not */
   if(!Curl_sasl_can_authenticate(&pop3c->sasl, data)) {
     pop3_state(data, POP3_STOP);
     return result;
@@ -758,7 +758,7 @@ static CURLcode pop3_state_capa_resp(struct Curl_easy *data, int pop3code,
     }
   }
   else {
-    /* Clear text is supported when CAPA isn't recognised */
+    /* Clear text is supported when CAPA is not recognised */
     if(pop3code != '+')
       pop3c->authtypes |= POP3_TYPE_CLEARTEXT;
 
@@ -931,12 +931,12 @@ static CURLcode pop3_state_command_resp(struct Curl_easy *data,
   pop3c->eob = 2;
 
   /* But since this initial CR LF pair is not part of the actual body, we set
-     the strip counter here so that these bytes won't be delivered. */
+     the strip counter here so that these bytes will not be delivered. */
   pop3c->strip = 2;
 
   if(pop3->transfer == PPTRANSFER_BODY) {
     /* POP3 download */
-    Curl_xfer_setup(data, FIRSTSOCKET, -1, FALSE, -1);
+    Curl_xfer_setup1(data, CURL_XFER_RECV, -1, FALSE);
 
     if(pp->overflow) {
       /* The recv buffer contains data that is actually body content so send
@@ -1477,7 +1477,7 @@ CURLcode Curl_pop3_write(struct Curl_easy *data, const char *str, size_t nread)
         pop3c->eob++;
 
         if(i) {
-          /* Write out the body part that didn't match */
+          /* Write out the body part that did not match */
           result = Curl_client_write(data, CLIENTWRITE_BODY, &str[last],
                                      i - last);
 
@@ -1490,7 +1490,7 @@ CURLcode Curl_pop3_write(struct Curl_easy *data, const char *str, size_t nread)
       else if(pop3c->eob == 3)
         pop3c->eob++;
       else
-        /* If the character match wasn't at position 0 or 3 then restart the
+        /* If the character match was not at position 0 or 3 then restart the
            pattern matching */
         pop3c->eob = 1;
       break;
@@ -1499,7 +1499,7 @@ CURLcode Curl_pop3_write(struct Curl_easy *data, const char *str, size_t nread)
       if(pop3c->eob == 1 || pop3c->eob == 4)
         pop3c->eob++;
       else
-        /* If the character match wasn't at position 1 or 4 then start the
+        /* If the character match was not at position 1 or 4 then start the
            search again */
         pop3c->eob = 0;
       break;
@@ -1513,7 +1513,7 @@ CURLcode Curl_pop3_write(struct Curl_easy *data, const char *str, size_t nread)
         pop3c->eob = 0;
       }
       else
-        /* If the character match wasn't at position 2 then start the search
+        /* If the character match was not at position 2 then start the search
            again */
         pop3c->eob = 0;
       break;
diff --git a/lib/progress.c b/lib/progress.c
index d05fcc3eb..34c29a270 100644
--- a/lib/progress.c
+++ b/lib/progress.c
@@ -82,13 +82,13 @@ static char *max5data(curl_off_t bytes, char *max5)
     msnprintf(max5, 6, "%4" CURL_FORMAT_CURL_OFF_T "k", bytes/ONE_KILOBYTE);
 
   else if(bytes < CURL_OFF_T_C(100) * ONE_MEGABYTE)
-    /* 'XX.XM' is good as long as we're less than 100 megs */
+    /* 'XX.XM' is good as long as we are less than 100 megs */
     msnprintf(max5, 6, "%2" CURL_FORMAT_CURL_OFF_T ".%0"
               CURL_FORMAT_CURL_OFF_T "M", bytes/ONE_MEGABYTE,
               (bytes%ONE_MEGABYTE) / (ONE_MEGABYTE/CURL_OFF_T_C(10)) );
 
   else if(bytes < CURL_OFF_T_C(10000) * ONE_MEGABYTE)
-    /* 'XXXXM' is good until we're at 10000MB or above */
+    /* 'XXXXM' is good until we are at 10000MB or above */
     msnprintf(max5, 6, "%4" CURL_FORMAT_CURL_OFF_T "M", bytes/ONE_MEGABYTE);
 
   else if(bytes < CURL_OFF_T_C(100) * ONE_GIGABYTE)
@@ -109,7 +109,7 @@ static char *max5data(curl_off_t bytes, char *max5)
     /* up to 10000PB, display without decimal: XXXXP */
     msnprintf(max5, 6, "%4" CURL_FORMAT_CURL_OFF_T "P", bytes/ONE_PETABYTE);
 
-  /* 16384 petabytes (16 exabytes) is the maximum a 64 bit unsigned number can
+  /* 16384 petabytes (16 exabytes) is the maximum a 64-bit unsigned number can
      hold, but our data type is signed so 8192PB will be the maximum. */
 
   return max5;
@@ -140,7 +140,7 @@ int Curl_pgrsDone(struct Curl_easy *data)
 
   if(!(data->progress.flags & PGRS_HIDE) &&
      !data->progress.callback)
-    /* only output if we don't use a progress callback and we're not
+    /* only output if we do not use a progress callback and we are not
      * hidden */
     fprintf(data->set.err, "\n");
 
@@ -204,7 +204,7 @@ void Curl_pgrsTimeWas(struct Curl_easy *data, timerid timer,
   case TIMER_STARTTRANSFER:
     delta = &data->progress.t_starttransfer;
     /* prevent updating t_starttransfer unless:
-     *   1) this is the first time we're setting t_starttransfer
+     *   1) this is the first time we are setting t_starttransfer
      *   2) a redirect has occurred since the last time t_starttransfer was set
      * This prevents repeated invocations of the function from incorrectly
      * changing the t_starttransfer time.
@@ -265,11 +265,11 @@ void Curl_pgrsStartNow(struct Curl_easy *data)
 
 /*
  * This is used to handle speed limits, calculating how many milliseconds to
- * wait until we're back under the speed limit, if needed.
+ * wait until we are back under the speed limit, if needed.
  *
  * The way it works is by having a "starting point" (time & amount of data
  * transferred by then) used in the speed computation, to be used instead of
- * the start of the transfer.  This starting point is regularly moved as
+ * the start of the transfer. This starting point is regularly moved as
  * transfer goes on, to keep getting accurate values (instead of average over
  * the entire transfer).
  *
@@ -336,7 +336,7 @@ CURLcode Curl_pgrsSetDownloadCounter(struct Curl_easy *data, curl_off_t size)
  */
 void Curl_ratelimit(struct Curl_easy *data, struct curltime now)
 {
-  /* don't set a new stamp unless the time since last update is long enough */
+  /* do not set a new stamp unless the time since last update is long enough */
   if(data->set.max_recv_speed) {
     if(Curl_timediff(now, data->progress.dl_limit_start) >=
        MIN_RATE_LIMIT_PERIOD) {
@@ -399,7 +399,7 @@ static curl_off_t trspeed(curl_off_t size, /* number of bytes */
     return CURL_OFF_T_MAX;
 }
 
-/* returns TRUE if it's time to show the progress meter */
+/* returns TRUE if it is time to show the progress meter */
 static bool progress_calc(struct Curl_easy *data, struct curltime now)
 {
   bool timetoshow = FALSE;
@@ -431,10 +431,10 @@ static bool progress_calc(struct Curl_easy *data, struct curltime now)
     /* figure out how many index entries of data we have stored in our speeder
        array. With N_ENTRIES filled in, we have about N_ENTRIES-1 seconds of
        transfer. Imagine, after one second we have filled in two entries,
-       after two seconds we've filled in three entries etc. */
+       after two seconds we have filled in three entries etc. */
     countindex = ((p->speeder_c >= CURR_TIME)? CURR_TIME:p->speeder_c) - 1;
 
-    /* first of all, we don't do this if there's no counted seconds yet */
+    /* first of all, we do not do this if there is no counted seconds yet */
     if(countindex) {
       int checkindex;
       timediff_t span_ms;
@@ -587,14 +587,12 @@ static void progress_meter(struct Curl_easy *data)
  * Curl_pgrsUpdate() returns 0 for success or the value returned by the
  * progress callback!
  */
-int Curl_pgrsUpdate(struct Curl_easy *data)
+static int pgrsupdate(struct Curl_easy *data, bool showprogress)
 {
-  struct curltime now = Curl_now(); /* what time is it */
-  bool showprogress = progress_calc(data, now);
   if(!(data->progress.flags & PGRS_HIDE)) {
     if(data->set.fxferinfo) {
       int result;
-      /* There's a callback set, call that */
+      /* There is a callback set, call that */
       Curl_set_in_callback(data, true);
       result = data->set.fxferinfo(data->set.progress_client,
                                    data->progress.size_dl,
@@ -631,3 +629,19 @@ int Curl_pgrsUpdate(struct Curl_easy *data)
 
   return 0;
 }
+
+int Curl_pgrsUpdate(struct Curl_easy *data)
+{
+  struct curltime now = Curl_now(); /* what time is it */
+  bool showprogress = progress_calc(data, now);
+  return pgrsupdate(data, showprogress);
+}
+
+/*
+ * Update all progress, do not do progress meter/callbacks.
+ */
+void Curl_pgrsUpdate_nometer(struct Curl_easy *data)
+{
+  struct curltime now = Curl_now(); /* what time is it */
+  (void)progress_calc(data, now);
+}
diff --git a/lib/progress.h b/lib/progress.h
index 73749419a..860257425 100644
--- a/lib/progress.h
+++ b/lib/progress.h
@@ -54,6 +54,8 @@ CURLcode Curl_pgrsSetDownloadCounter(struct Curl_easy *data, curl_off_t size);
 void Curl_pgrsSetUploadCounter(struct Curl_easy *data, curl_off_t size);
 void Curl_ratelimit(struct Curl_easy *data, struct curltime now);
 int Curl_pgrsUpdate(struct Curl_easy *data);
+void Curl_pgrsUpdate_nometer(struct Curl_easy *data);
+
 void Curl_pgrsResetTransferSizes(struct Curl_easy *data);
 struct curltime Curl_pgrsTime(struct Curl_easy *data, timerid timer);
 timediff_t Curl_pgrsLimitWaitTime(curl_off_t cursize,
diff --git a/lib/rand.c b/lib/rand.c
index c62b1a403..4ee96fbb6 100644
--- a/lib/rand.c
+++ b/lib/rand.c
@@ -48,7 +48,8 @@
 
 #ifdef _WIN32
 
-#if defined(_WIN32_WINNT) && _WIN32_WINNT >= 0x600
+#if defined(_WIN32_WINNT) && _WIN32_WINNT >= 0x600 && \
+  !defined(CURL_WINDOWS_APP)
 #  define HAVE_WIN_BCRYPTGENRANDOM
 #  include <bcrypt.h>
 #  ifdef _MSC_VER
@@ -105,7 +106,7 @@ static CURLcode randit(struct Curl_easy *data, unsigned int *rnd)
   static unsigned int randseed;
   static bool seeded = FALSE;
 
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
   char *force_entropy = getenv("CURL_ENTROPY");
   if(force_entropy) {
     if(!seeded) {
@@ -150,7 +151,7 @@ static CURLcode randit(struct Curl_easy *data, unsigned int *rnd)
 
 #if defined(RANDOM_FILE) && !defined(_WIN32)
   if(!seeded) {
-    /* if there's a random file to read a seed from, use it */
+    /* if there is a random file to read a seed from, use it */
     int fd = open(RANDOM_FILE, O_RDONLY);
     if(fd > -1) {
       /* read random data into the randseed variable */
@@ -269,7 +270,7 @@ CURLcode Curl_rand_alnum(struct Curl_easy *data, unsigned char *rnd,
                          size_t num)
 {
   CURLcode result = CURLE_OK;
-  const int alnumspace = sizeof(alnum) - 1;
+  const unsigned int alnumspace = sizeof(alnum) - 1;
   unsigned int r;
   DEBUGASSERT(num > 1);
 
@@ -282,7 +283,7 @@ CURLcode Curl_rand_alnum(struct Curl_easy *data, unsigned char *rnd,
         return result;
     } while(r >= (UINT_MAX - UINT_MAX % alnumspace));
 
-    *rnd++ = alnum[r % alnumspace];
+    *rnd++ = (unsigned char)alnum[r % alnumspace];
     num--;
   }
   *rnd = 0;
diff --git a/lib/rename.c b/lib/rename.c
index 4c8869806..8715a4306 100644
--- a/lib/rename.c
+++ b/lib/rename.c
@@ -41,7 +41,7 @@
 int Curl_rename(const char *oldpath, const char *newpath)
 {
 #ifdef _WIN32
-  /* rename() on Windows doesn't overwrite, so we can't use it here.
+  /* rename() on Windows does not overwrite, so we cannot use it here.
      MoveFileEx() will overwrite and is usually atomic, however it fails
      when there are open handles to the file. */
   const int max_wait_ms = 1000;
diff --git a/lib/request.c b/lib/request.c
index 26741fa6c..5c8d52f69 100644
--- a/lib/request.c
+++ b/lib/request.c
@@ -54,6 +54,7 @@ CURLcode Curl_req_soft_reset(struct SingleRequest *req,
   req->upload_done = FALSE;
   req->download_done = FALSE;
   req->ignorebody = FALSE;
+  req->shutdown = FALSE;
   req->bytecount = 0;
   req->writebytecount = 0;
   req->header = TRUE; /* assume header */
@@ -108,17 +109,14 @@ void Curl_req_hard_reset(struct SingleRequest *req, struct Curl_easy *data)
 
   /* This is a bit ugly. `req->p` is a union and we assume we can
    * free this safely without leaks. */
-  Curl_safefree(req->p.http);
+  Curl_safefree(req->p.ftp);
   Curl_safefree(req->newurl);
   Curl_client_reset(data);
   if(req->sendbuf_init)
     Curl_bufq_reset(&req->sendbuf);
 
 #ifndef CURL_DISABLE_DOH
-  if(req->doh) {
-    Curl_close(&req->doh->probe[0].easy);
-    Curl_close(&req->doh->probe[1].easy);
-  }
+  Curl_doh_close(data);
 #endif
   /* Can no longer memset() this struct as we need to keep some state */
   req->size = -1;
@@ -135,7 +133,6 @@ void Curl_req_hard_reset(struct SingleRequest *req, struct Curl_easy *data)
   req->keepon = 0;
   req->upgr101 = UPGR101_INIT;
   req->timeofdoc = 0;
-  req->bodywrites = 0;
   req->location = NULL;
   req->newurl = NULL;
 #ifndef CURL_DISABLE_COOKIES
@@ -156,27 +153,24 @@ void Curl_req_hard_reset(struct SingleRequest *req, struct Curl_easy *data)
   req->getheader = FALSE;
   req->no_body = data->set.opt_no_body;
   req->authneg = FALSE;
+  req->shutdown = FALSE;
+#ifdef USE_HYPER
+  req->bodywritten = FALSE;
+#endif
 }
 
 void Curl_req_free(struct SingleRequest *req, struct Curl_easy *data)
 {
   /* This is a bit ugly. `req->p` is a union and we assume we can
    * free this safely without leaks. */
-  Curl_safefree(req->p.http);
+  Curl_safefree(req->p.ftp);
   Curl_safefree(req->newurl);
   if(req->sendbuf_init)
     Curl_bufq_free(&req->sendbuf);
   Curl_client_cleanup(data);
 
 #ifndef CURL_DISABLE_DOH
-  if(req->doh) {
-    Curl_close(&req->doh->probe[0].easy);
-    Curl_close(&req->doh->probe[1].easy);
-    Curl_dyn_free(&req->doh->probe[0].serverdoh);
-    Curl_dyn_free(&req->doh->probe[1].serverdoh);
-    curl_slist_free_all(req->doh->headers);
-    Curl_safefree(req->doh);
-  }
+  Curl_doh_cleanup(data);
 #endif
 }
 
@@ -187,7 +181,7 @@ static CURLcode xfer_send(struct Curl_easy *data,
   CURLcode result = CURLE_OK;
 
   *pnwritten = 0;
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
   {
     /* Allow debug builds to override this logic to force short initial
        sends
@@ -200,7 +194,7 @@ static CURLcode xfer_send(struct Curl_easy *data,
     }
   }
 #endif
-  /* Make sure this doesn't send more body bytes than what the max send
+  /* Make sure this does not send more body bytes than what the max send
      speed says. The headers do not count to the max speed. */
   if(data->set.max_send_speed) {
     size_t body_bytes = blen - hds_len;
@@ -251,7 +245,7 @@ static CURLcode req_set_upload_done(struct Curl_easy *data)
 {
   DEBUGASSERT(!data->req.upload_done);
   data->req.upload_done = TRUE;
-  data->req.keepon &= ~(KEEP_SEND|KEEP_SEND_TIMED); /* we're done sending */
+  data->req.keepon &= ~(KEEP_SEND|KEEP_SEND_TIMED); /* we are done sending */
 
   Curl_creader_done(data, data->req.upload_aborted);
 
@@ -291,6 +285,14 @@ static CURLcode req_flush(struct Curl_easy *data)
 
   if(!data->req.upload_done && data->req.eos_read &&
      Curl_bufq_is_empty(&data->req.sendbuf)) {
+    if(data->req.shutdown) {
+      bool done;
+      result = Curl_xfer_send_shutdown(data, &done);
+      if(result)
+        return result;
+      if(!done)
+        return CURLE_AGAIN;
+    }
     return req_set_upload_done(data);
   }
   return CURLE_OK;
diff --git a/lib/request.h b/lib/request.h
index f9be6f299..413dacaa4 100644
--- a/lib/request.h
+++ b/lib/request.h
@@ -51,10 +51,10 @@ enum upgrade101 {
 
 
 /*
- * Request specific data in the easy handle (Curl_easy).  Previously,
+ * Request specific data in the easy handle (Curl_easy). Previously,
  * these members were on the connectdata struct but since a conn struct may
  * now be shared between different Curl_easys, we store connection-specific
- * data here. This struct only keeps stuff that's interesting for *this*
+ * data here. This struct only keeps stuff that is interesting for *this*
  * request, as it will be cleared between multiple ones
  */
 struct SingleRequest {
@@ -68,7 +68,7 @@ struct SingleRequest {
   unsigned int headerbytecount;  /* received server headers (not CONNECT
                                     headers) */
   unsigned int allheadercount;   /* all received headers (server + CONNECT) */
-  unsigned int deductheadercount; /* this amount of bytes doesn't count when
+  unsigned int deductheadercount; /* this amount of bytes does not count when
                                      we check if anything has been transferred
                                      at the end of a connection. We use this
                                      counter to make only a 100 reply (without
@@ -93,7 +93,6 @@ struct SingleRequest {
   struct bufq sendbuf; /* data which needs to be send to the server */
   size_t sendbuf_hds_len; /* amount of header bytes in sendbuf */
   time_t timeofdoc;
-  long bodywrites;
   char *location;   /* This points to an allocated version of the Location:
                        header data */
   char *newurl;     /* Set to the new URL to use when a redirect or a retry is
@@ -104,7 +103,6 @@ struct SingleRequest {
   union {
     struct FILEPROTO *file;
     struct FTP *ftp;
-    struct HTTP *http;
     struct IMAP *imap;
     struct ldapreqinfo *ldap;
     struct MQTT *mqtt;
@@ -147,6 +145,10 @@ struct SingleRequest {
                         but it is not the final request in the auth
                         negotiation. */
   BIT(sendbuf_init); /* sendbuf is initialized */
+  BIT(shutdown);     /* request end will shutdown connection */
+#ifdef USE_HYPER
+  BIT(bodywritten);
+#endif
 };
 
 /**
diff --git a/lib/rtsp.c b/lib/rtsp.c
index 1f162daa0..a9050806d 100644
--- a/lib/rtsp.c
+++ b/lib/rtsp.c
@@ -79,7 +79,7 @@ static unsigned int rtsp_conncheck(struct Curl_easy *data,
                                    unsigned int checks_to_perform);
 
 /* this returns the socket to wait for in the DO and DOING state for the multi
-   interface and then we're always _sending_ a request and thus we wait for
+   interface and then we are always _sending_ a request and thus we wait for
    the single socket to become writable only */
 static int rtsp_getsock_do(struct Curl_easy *data, struct connectdata *conn,
                            curl_socket_t *socks)
@@ -261,7 +261,7 @@ static CURLcode rtsp_do(struct Curl_easy *data, bool *done)
    * Since all RTSP requests are included here, there is no need to
    * support custom requests like HTTP.
    **/
-  data->req.no_body = TRUE; /* most requests don't contain a body */
+  data->req.no_body = TRUE; /* most requests do not contain a body */
   switch(rtspreq) {
   default:
     failf(data, "Got invalid RTSP request");
@@ -310,13 +310,15 @@ static CURLcode rtsp_do(struct Curl_easy *data, bool *done)
   }
 
   if(rtspreq == RTSPREQ_RECEIVE) {
-    Curl_xfer_setup(data, FIRSTSOCKET, -1, TRUE, -1);
+    Curl_xfer_setup1(data, CURL_XFER_RECV, -1, TRUE);
     goto out;
   }
 
   p_session_id = data->set.str[STRING_RTSP_SESSION_ID];
   if(!p_session_id &&
-     (rtspreq & ~(RTSPREQ_OPTIONS | RTSPREQ_DESCRIBE | RTSPREQ_SETUP))) {
+     (rtspreq & ~(Curl_RtspReq)(RTSPREQ_OPTIONS |
+                                RTSPREQ_DESCRIBE |
+                                RTSPREQ_SETUP))) {
     failf(data, "Refusing to issue an RTSP request [%s] without a session ID.",
           p_request);
     result = CURLE_BAD_FUNCTION_ARGUMENT;
@@ -576,7 +578,7 @@ static CURLcode rtsp_do(struct Curl_easy *data, bool *done)
   if(result)
     goto out;
 
-  Curl_xfer_setup(data, FIRSTSOCKET, -1, TRUE, FIRSTSOCKET);
+  Curl_xfer_setup1(data, CURL_XFER_SENDRECV, -1, TRUE);
 
   /* issue the request */
   result = Curl_req_send(data, &req_buffer);
@@ -950,7 +952,7 @@ CURLcode Curl_rtsp_parseheader(struct Curl_easy *data, const char *header)
     /* Find the end of Session ID
      *
      * Allow any non whitespace content, up to the field separator or end of
-     * line. RFC 2326 isn't 100% clear on the session ID and for example
+     * line. RFC 2326 is not 100% clear on the session ID and for example
      * gstreamer does url-encoded session ID's not covered by the standard.
      */
     end = start;
diff --git a/lib/rtsp.h b/lib/rtsp.h
index b1ffa5c7e..41b09503f 100644
--- a/lib/rtsp.h
+++ b/lib/rtsp.h
@@ -62,16 +62,6 @@ struct rtsp_conn {
  * RTSP unique setup
  ***************************************************************************/
 struct RTSP {
-  /*
-   * http_wrapper MUST be the first element of this structure for the wrap
-   * logic to work. In this way, we get a cheap polymorphism because
-   * &(data->state.proto.rtsp) == &(data->state.proto.http) per the C spec
-   *
-   * HTTP functions can safely treat this as an HTTP struct, but RTSP aware
-   * functions can also index into the later elements.
-   */
-  struct HTTP http_wrapper; /* wrap HTTP to do the heavy lifting */
-
   long CSeq_sent; /* CSeq of this request */
   long CSeq_recv; /* CSeq received */
 };
diff --git a/lib/select.c b/lib/select.c
index d92e745a7..96b0632ff 100644
--- a/lib/select.c
+++ b/lib/select.c
@@ -33,7 +33,7 @@
 #endif
 
 #if !defined(HAVE_SELECT) && !defined(HAVE_POLL_FINE)
-#error "We can't compile without select() or poll() support."
+#error "We cannot compile without select() or poll() support."
 #endif
 
 #ifdef MSDOS
@@ -47,6 +47,10 @@
 #include "select.h"
 #include "timediff.h"
 #include "warnless.h"
+/* The last 3 #include files should be in this order */
+#include "curl_printf.h"
+#include "curl_memory.h"
+#include "memdebug.h"
 
 /*
  * Internal function used for waiting a specific amount of ms
@@ -81,7 +85,7 @@ int Curl_wait_ms(timediff_t timeout_ms)
 #if TIMEDIFF_T_MAX >= ULONG_MAX
   if(timeout_ms >= ULONG_MAX)
     timeout_ms = ULONG_MAX-1;
-    /* don't use ULONG_MAX, because that is equal to INFINITE */
+    /* do not use ULONG_MAX, because that is equal to INFINITE */
 #endif
   Sleep((ULONG)timeout_ms);
 #else
@@ -131,7 +135,7 @@ static int our_select(curl_socket_t maxfd,   /* highest socket number */
   struct timeval *ptimeout;
 
 #ifdef USE_WINSOCK
-  /* WinSock select() can't handle zero events.  See the comment below. */
+  /* WinSock select() cannot handle zero events. See the comment below. */
   if((!fds_read || fds_read->fd_count == 0) &&
      (!fds_write || fds_write->fd_count == 0) &&
      (!fds_err || fds_err->fd_count == 0)) {
@@ -144,14 +148,14 @@ static int our_select(curl_socket_t maxfd,   /* highest socket number */
 
 #ifdef USE_WINSOCK
   /* WinSock select() must not be called with an fd_set that contains zero
-    fd flags, or it will return WSAEINVAL.  But, it also can't be called
+    fd flags, or it will return WSAEINVAL. But, it also cannot be called
     with no fd_sets at all!  From the documentation:
 
     Any two of the parameters, readfds, writefds, or exceptfds, can be
     given as null. At least one must be non-null, and any non-null
     descriptor set must contain at least one handle to a socket.
 
-    It is unclear why WinSock doesn't just handle this for us instead of
+    It is unclear why WinSock does not just handle this for us instead of
     calling this an error. Luckily, with WinSock, we can _also_ ask how
     many bits are set on an fd_set. So, let's just check it beforehand.
   */
@@ -169,7 +173,7 @@ static int our_select(curl_socket_t maxfd,   /* highest socket number */
 /*
  * Wait for read or write events on a set of file descriptors. It uses poll()
  * when a fine poll() is available, in order to avoid limits with FD_SETSIZE,
- * otherwise select() is used.  An error is returned if select() is being used
+ * otherwise select() is used. An error is returned if select() is being used
  * and a file descriptor is too large for FD_SETSIZE.
  *
  * A negative timeout value makes this function wait indefinitely,
@@ -226,7 +230,7 @@ int Curl_socket_check(curl_socket_t readfd0, /* two sockets to read from */
     num++;
   }
 
-  r = Curl_poll(pfd, num, timeout_ms);
+  r = Curl_poll(pfd, (unsigned int)num, timeout_ms);
   if(r <= 0)
     return r;
 
@@ -257,8 +261,8 @@ int Curl_socket_check(curl_socket_t readfd0, /* two sockets to read from */
 }
 
 /*
- * This is a wrapper around poll().  If poll() does not exist, then
- * select() is used instead.  An error is returned if select() is
+ * This is a wrapper around poll(). If poll() does not exist, then
+ * select() is used instead. An error is returned if select() is
  * being used and a file descriptor is too large for FD_SETSIZE.
  * A negative timeout value makes this function wait indefinitely,
  * unless no valid file descriptor is given, when this happens the
@@ -357,7 +361,7 @@ int Curl_poll(struct pollfd ufds[], unsigned int nfds, timediff_t timeout_ms)
   }
 
   /*
-     Note also that WinSock ignores the first argument, so we don't worry
+     Note also that WinSock ignores the first argument, so we do not worry
      about the fact that maxfd is computed incorrectly with WinSock (since
      curl_socket_t is unsigned in such cases and thus -1 is the largest
      value).
@@ -401,3 +405,147 @@ int Curl_poll(struct pollfd ufds[], unsigned int nfds, timediff_t timeout_ms)
 
   return r;
 }
+
+void Curl_pollfds_init(struct curl_pollfds *cpfds,
+                       struct pollfd *static_pfds,
+                       unsigned int static_count)
+{
+  DEBUGASSERT(cpfds);
+  memset(cpfds, 0, sizeof(*cpfds));
+  if(static_pfds && static_count) {
+    cpfds->pfds = static_pfds;
+    cpfds->count = static_count;
+  }
+}
+
+void Curl_pollfds_cleanup(struct curl_pollfds *cpfds)
+{
+  DEBUGASSERT(cpfds);
+  if(cpfds->allocated_pfds) {
+    free(cpfds->pfds);
+  }
+  memset(cpfds, 0, sizeof(*cpfds));
+}
+
+static CURLcode cpfds_increase(struct curl_pollfds *cpfds, unsigned int inc)
+{
+  struct pollfd *new_fds;
+  unsigned int new_count = cpfds->count + inc;
+
+  new_fds = calloc(new_count, sizeof(struct pollfd));
+  if(!new_fds)
+    return CURLE_OUT_OF_MEMORY;
+
+  memcpy(new_fds, cpfds->pfds, cpfds->count * sizeof(struct pollfd));
+  if(cpfds->allocated_pfds)
+    free(cpfds->pfds);
+  cpfds->pfds = new_fds;
+  cpfds->count = new_count;
+  cpfds->allocated_pfds = TRUE;
+  return CURLE_OK;
+}
+
+static CURLcode cpfds_add_sock(struct curl_pollfds *cpfds,
+                               curl_socket_t sock, short events, bool fold)
+{
+  int i;
+
+  if(fold && cpfds->n <= INT_MAX) {
+    for(i = (int)cpfds->n - 1; i >= 0; --i) {
+      if(sock == cpfds->pfds[i].fd) {
+        cpfds->pfds[i].events |= events;
+        return CURLE_OK;
+      }
+    }
+  }
+  /* not folded, add new entry */
+  if(cpfds->n >= cpfds->count) {
+    if(cpfds_increase(cpfds, 100))
+      return CURLE_OUT_OF_MEMORY;
+  }
+  cpfds->pfds[cpfds->n].fd = sock;
+  cpfds->pfds[cpfds->n].events = events;
+  ++cpfds->n;
+  return CURLE_OK;
+}
+
+CURLcode Curl_pollfds_add_sock(struct curl_pollfds *cpfds,
+                               curl_socket_t sock, short events)
+{
+  return cpfds_add_sock(cpfds, sock, events, FALSE);
+}
+
+CURLcode Curl_pollfds_add_ps(struct curl_pollfds *cpfds,
+                             struct easy_pollset *ps)
+{
+  size_t i;
+
+  DEBUGASSERT(cpfds);
+  DEBUGASSERT(ps);
+  for(i = 0; i < ps->num; i++) {
+    short events = 0;
+    if(ps->actions[i] & CURL_POLL_IN)
+      events |= POLLIN;
+    if(ps->actions[i] & CURL_POLL_OUT)
+      events |= POLLOUT;
+    if(events) {
+      if(cpfds_add_sock(cpfds, ps->sockets[i], events, TRUE))
+        return CURLE_OUT_OF_MEMORY;
+    }
+  }
+  return CURLE_OK;
+}
+
+void Curl_waitfds_init(struct curl_waitfds *cwfds,
+                       struct curl_waitfd *static_wfds,
+                       unsigned int static_count)
+{
+  DEBUGASSERT(cwfds);
+  DEBUGASSERT(static_wfds);
+  memset(cwfds, 0, sizeof(*cwfds));
+  cwfds->wfds = static_wfds;
+  cwfds->count = static_count;
+}
+
+static CURLcode cwfds_add_sock(struct curl_waitfds *cwfds,
+                               curl_socket_t sock, short events)
+{
+  int i;
+
+  if(cwfds->n <= INT_MAX) {
+    for(i = (int)cwfds->n - 1; i >= 0; --i) {
+      if(sock == cwfds->wfds[i].fd) {
+        cwfds->wfds[i].events |= events;
+        return CURLE_OK;
+      }
+    }
+  }
+  /* not folded, add new entry */
+  if(cwfds->n >= cwfds->count)
+    return CURLE_OUT_OF_MEMORY;
+  cwfds->wfds[cwfds->n].fd = sock;
+  cwfds->wfds[cwfds->n].events = events;
+  ++cwfds->n;
+  return CURLE_OK;
+}
+
+CURLcode Curl_waitfds_add_ps(struct curl_waitfds *cwfds,
+                             struct easy_pollset *ps)
+{
+  size_t i;
+
+  DEBUGASSERT(cwfds);
+  DEBUGASSERT(ps);
+  for(i = 0; i < ps->num; i++) {
+    short events = 0;
+    if(ps->actions[i] & CURL_POLL_IN)
+      events |= CURL_WAIT_POLLIN;
+    if(ps->actions[i] & CURL_POLL_OUT)
+      events |= CURL_WAIT_POLLOUT;
+    if(events) {
+      if(cwfds_add_sock(cwfds, ps->sockets[i], events))
+        return CURLE_OUT_OF_MEMORY;
+    }
+  }
+  return CURLE_OK;
+}
diff --git a/lib/select.h b/lib/select.h
index 5b1ca23eb..f01acbdef 100644
--- a/lib/select.h
+++ b/lib/select.h
@@ -111,4 +111,37 @@ int Curl_wait_ms(timediff_t timeout_ms);
   } while(0)
 #endif
 
+struct curl_pollfds {
+  struct pollfd *pfds;
+  unsigned int n;
+  unsigned int count;
+  BIT(allocated_pfds);
+};
+
+void Curl_pollfds_init(struct curl_pollfds *cpfds,
+                       struct pollfd *static_pfds,
+                       unsigned int static_count);
+
+void Curl_pollfds_cleanup(struct curl_pollfds *cpfds);
+
+CURLcode Curl_pollfds_add_ps(struct curl_pollfds *cpfds,
+                             struct easy_pollset *ps);
+
+CURLcode Curl_pollfds_add_sock(struct curl_pollfds *cpfds,
+                               curl_socket_t sock, short events);
+
+struct curl_waitfds {
+  struct curl_waitfd *wfds;
+  unsigned int n;
+  unsigned int count;
+};
+
+void Curl_waitfds_init(struct curl_waitfds *cwfds,
+                       struct curl_waitfd *static_wfds,
+                       unsigned int static_count);
+
+CURLcode Curl_waitfds_add_ps(struct curl_waitfds *cwfds,
+                             struct easy_pollset *ps);
+
+
 #endif /* HEADER_CURL_SELECT_H */
diff --git a/lib/sendf.c b/lib/sendf.c
index 68a8bf3b6..24b90d2ad 100644
--- a/lib/sendf.c
+++ b/lib/sendf.c
@@ -289,6 +289,13 @@ static CURLcode cw_download_write(struct Curl_easy *data,
     if(nwrite == wmax) {
       data->req.download_done = TRUE;
     }
+
+    if((type & CLIENTWRITE_EOS) && !data->req.no_body &&
+       (data->req.maxdownload > data->req.bytecount)) {
+      failf(data, "end of response with %" CURL_FORMAT_CURL_OFF_T
+            " bytes missing", data->req.maxdownload - data->req.bytecount);
+      return CURLE_PARTIAL_FILE;
+    }
   }
 
   /* Error on too large filesize is handled below, after writing
@@ -309,7 +316,9 @@ static CURLcode cw_download_write(struct Curl_easy *data,
   }
   /* Update stats, write and report progress */
   data->req.bytecount += nwrite;
-  ++data->req.bodywrites;
+#ifdef USE_HYPER
+  data->req.bodywritten = TRUE;
+#endif
   result = Curl_pgrsSetDownloadCounter(data, data->req.bytecount);
   if(result)
     return result;
@@ -597,6 +606,14 @@ CURLcode Curl_creader_def_unpause(struct Curl_easy *data,
   return CURLE_OK;
 }
 
+bool Curl_creader_def_is_paused(struct Curl_easy *data,
+                                struct Curl_creader *reader)
+{
+  (void)data;
+  (void)reader;
+  return FALSE;
+}
+
 void Curl_creader_def_done(struct Curl_easy *data,
                            struct Curl_creader *reader, int premature)
 {
@@ -615,6 +632,7 @@ struct cr_in_ctx {
   BIT(seen_eos);
   BIT(errored);
   BIT(has_used_cb);
+  BIT(is_paused);
 };
 
 static CURLcode cr_in_init(struct Curl_easy *data, struct Curl_creader *reader)
@@ -637,6 +655,8 @@ static CURLcode cr_in_read(struct Curl_easy *data,
   struct cr_in_ctx *ctx = reader->ctx;
   size_t nread;
 
+  ctx->is_paused = FALSE;
+
   /* Once we have errored, we will return the same error forever */
   if(ctx->errored) {
     *pnread = 0;
@@ -688,12 +708,14 @@ static CURLcode cr_in_read(struct Curl_easy *data,
   case CURL_READFUNC_PAUSE:
     if(data->conn->handler->flags & PROTOPT_NONETWORK) {
       /* protocols that work without network cannot be paused. This is
-         actually only FILE:// just now, and it can't pause since the transfer
-         isn't done using the "normal" procedure. */
+         actually only FILE:// just now, and it cannot pause since the transfer
+         is not done using the "normal" procedure. */
       failf(data, "Read callback asked for PAUSE when not supported");
       return CURLE_READ_ERROR;
     }
     /* CURL_READFUNC_PAUSE pauses read callbacks that feed socket writes */
+    CURL_TRC_READ(data, "cr_in_read, callback returned CURL_READFUNC_PAUSE");
+    ctx->is_paused = TRUE;
     data->req.keepon |= KEEP_SEND_PAUSE; /* mark socket send as paused */
     *pnread = 0;
     *peos = FALSE;
@@ -764,7 +786,7 @@ static CURLcode cr_in_resume_from(struct Curl_easy *data,
       failf(data, "Could not seek stream");
       return CURLE_READ_ERROR;
     }
-    /* when seekerr == CURL_SEEKFUNC_CANTSEEK (can't seek to offset) */
+    /* when seekerr == CURL_SEEKFUNC_CANTSEEK (cannot seek to offset) */
     do {
       char scratch[4*1024];
       size_t readthisamountnow =
@@ -798,7 +820,7 @@ static CURLcode cr_in_resume_from(struct Curl_easy *data,
       return CURLE_PARTIAL_FILE;
     }
   }
-  /* we've passed, proceed as normal */
+  /* we have passed, proceed as normal */
   return CURLE_OK;
 }
 
@@ -850,12 +872,28 @@ static CURLcode cr_in_rewind(struct Curl_easy *data,
     }
 
     /* no callback set or failure above, makes us fail at once */
-    failf(data, "necessary data rewind wasn't possible");
+    failf(data, "necessary data rewind was not possible");
     return CURLE_SEND_FAIL_REWIND;
   }
   return CURLE_OK;
 }
 
+static CURLcode cr_in_unpause(struct Curl_easy *data,
+                              struct Curl_creader *reader)
+{
+  struct cr_in_ctx *ctx = reader->ctx;
+  (void)data;
+  ctx->is_paused = FALSE;
+  return CURLE_OK;
+}
+
+static bool cr_in_is_paused(struct Curl_easy *data,
+                            struct Curl_creader *reader)
+{
+  struct cr_in_ctx *ctx = reader->ctx;
+  (void)data;
+  return ctx->is_paused;
+}
 
 static const struct Curl_crtype cr_in = {
   "cr-in",
@@ -866,7 +904,8 @@ static const struct Curl_crtype cr_in = {
   cr_in_total_length,
   cr_in_resume_from,
   cr_in_rewind,
-  Curl_creader_def_unpause,
+  cr_in_unpause,
+  cr_in_is_paused,
   Curl_creader_def_done,
   sizeof(struct cr_in_ctx)
 };
@@ -979,13 +1018,19 @@ static CURLcode cr_lc_read(struct Curl_easy *data,
         return result;
       start = i + 1;
       if(!data->set.crlf && (data->state.infilesize != -1)) {
-        /* we're here only because FTP is in ASCII mode...
+        /* we are here only because FTP is in ASCII mode...
            bump infilesize for the LF we just added */
         data->state.infilesize++;
         /* comment: this might work for FTP, but in HTTP we could not change
          * the content length after having started the request... */
       }
     }
+
+    if(start < i) { /* leftover */
+      result = Curl_bufq_cwrite(&ctx->buf, buf + start, i - start, &n);
+      if(result)
+        return result;
+    }
   }
 
   DEBUGASSERT(!Curl_bufq_is_empty(&ctx->buf));
@@ -1022,6 +1067,7 @@ static const struct Curl_crtype cr_lc = {
   Curl_creader_def_resume_from,
   Curl_creader_def_rewind,
   Curl_creader_def_unpause,
+  Curl_creader_def_is_paused,
   Curl_creader_def_done,
   sizeof(struct cr_lc_ctx)
 };
@@ -1195,6 +1241,7 @@ static const struct Curl_crtype cr_null = {
   Curl_creader_def_resume_from,
   Curl_creader_def_rewind,
   Curl_creader_def_unpause,
+  Curl_creader_def_is_paused,
   Curl_creader_def_done,
   sizeof(struct Curl_creader)
 };
@@ -1294,6 +1341,7 @@ static const struct Curl_crtype cr_buf = {
   cr_buf_resume_from,
   Curl_creader_def_rewind,
   Curl_creader_def_unpause,
+  Curl_creader_def_is_paused,
   Curl_creader_def_done,
   sizeof(struct cr_buf_ctx)
 };
@@ -1356,6 +1404,18 @@ CURLcode Curl_creader_unpause(struct Curl_easy *data)
   return result;
 }
 
+bool Curl_creader_is_paused(struct Curl_easy *data)
+{
+  struct Curl_creader *reader = data->req.reader_stack;
+
+  while(reader) {
+    if(reader->crt->is_paused(data, reader))
+      return TRUE;
+    reader = reader->next;
+  }
+  return FALSE;
+}
+
 void Curl_creader_done(struct Curl_easy *data, int premature)
 {
   struct Curl_creader *reader = data->req.reader_stack;
diff --git a/lib/sendf.h b/lib/sendf.h
index 82a290257..dc1b82edf 100644
--- a/lib/sendf.h
+++ b/lib/sendf.h
@@ -218,6 +218,7 @@ struct Curl_crtype {
                           struct Curl_creader *reader, curl_off_t offset);
   CURLcode (*rewind)(struct Curl_easy *data, struct Curl_creader *reader);
   CURLcode (*unpause)(struct Curl_easy *data, struct Curl_creader *reader);
+  bool (*is_paused)(struct Curl_easy *data, struct Curl_creader *reader);
   void (*done)(struct Curl_easy *data,
                struct Curl_creader *reader, int premature);
   size_t creader_size;  /* sizeof() allocated struct Curl_creader */
@@ -268,6 +269,8 @@ CURLcode Curl_creader_def_rewind(struct Curl_easy *data,
                                  struct Curl_creader *reader);
 CURLcode Curl_creader_def_unpause(struct Curl_easy *data,
                                   struct Curl_creader *reader);
+bool Curl_creader_def_is_paused(struct Curl_easy *data,
+                                struct Curl_creader *reader);
 void Curl_creader_def_done(struct Curl_easy *data,
                            struct Curl_creader *reader, int premature);
 
@@ -375,6 +378,11 @@ CURLcode Curl_creader_resume_from(struct Curl_easy *data, curl_off_t offset);
  */
 CURLcode Curl_creader_unpause(struct Curl_easy *data);
 
+/**
+ * Return TRUE iff any of the installed readers is paused.
+ */
+bool Curl_creader_is_paused(struct Curl_easy *data);
+
 /**
  * Tell all client readers that they are done.
  */
diff --git a/lib/setopt.c b/lib/setopt.c
index e8b25454b..7d35651d1 100644
--- a/lib/setopt.c
+++ b/lib/setopt.c
@@ -139,8 +139,44 @@ static CURLcode setstropt_userpwd(char *option, char **userp, char **passwdp)
   return CURLE_OK;
 }
 
+static CURLcode setstropt_interface(
+  char *option, char **devp, char **ifacep, char **hostp)
+{
+  char *dev = NULL;
+  char *iface = NULL;
+  char *host = NULL;
+  size_t len;
+  CURLcode result;
+
+  DEBUGASSERT(devp);
+  DEBUGASSERT(ifacep);
+  DEBUGASSERT(hostp);
+
+  /* Parse the interface details */
+  if(!option || !*option)
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+  len = strlen(option);
+  if(len > 255)
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+
+  result = Curl_parse_interface(option, len, &dev, &iface, &host);
+  if(result)
+    return result;
+
+  free(*devp);
+  *devp = dev;
+
+  free(*ifacep);
+  *ifacep = iface;
+
+  free(*hostp);
+  *hostp = host;
+
+  return CURLE_OK;
+}
+
 #define C_SSLVERSION_VALUE(x) (x & 0xffff)
-#define C_SSLVERSION_MAX_VALUE(x) (x & 0xffff0000)
+#define C_SSLVERSION_MAX_VALUE(x) ((unsigned long)x & 0xffff0000)
 
 static CURLcode protocol2num(const char *str, curl_prot_t *val)
 {
@@ -203,13 +239,17 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
     data->set.dns_cache_timeout = (int)arg;
     break;
   case CURLOPT_CA_CACHE_TIMEOUT:
-    arg = va_arg(param, long);
-    if(arg < -1)
-      return CURLE_BAD_FUNCTION_ARGUMENT;
-    else if(arg > INT_MAX)
-      arg = INT_MAX;
+    if(Curl_ssl_supports(data, SSLSUPP_CA_CACHE)) {
+      arg = va_arg(param, long);
+      if(arg < -1)
+        return CURLE_BAD_FUNCTION_ARGUMENT;
+      else if(arg > INT_MAX)
+        arg = INT_MAX;
 
-    data->set.general_ssl.ca_cache_timeout = (int)arg;
+      data->set.general_ssl.ca_cache_timeout = (int)arg;
+    }
+    else
+      return CURLE_NOT_BUILT_IN;
     break;
   case CURLOPT_DNS_USE_GLOBAL_CACHE:
     /* deprecated */
@@ -312,7 +352,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
     break;
   case CURLOPT_FAILONERROR:
     /*
-     * Don't output the >=400 error code HTML-page, but instead only
+     * Do not output the >=400 error code HTML-page, but instead only
      * return error.
      */
     data->set.http_fail_on_error = (0 != va_arg(param, long));
@@ -461,7 +501,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
       arg = va_arg(param, long);
 
       version = C_SSLVERSION_VALUE(arg);
-      version_max = C_SSLVERSION_MAX_VALUE(arg);
+      version_max = (long)C_SSLVERSION_MAX_VALUE(arg);
 
       if(version < CURL_SSLVERSION_DEFAULT ||
          version == CURL_SSLVERSION_SSLv2 ||
@@ -582,7 +622,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
      *
      * If the encoding is set to "" we use an Accept-Encoding header that
      * encompasses all the encodings we support.
-     * If the encoding is set to NULL we don't send an Accept-Encoding header
+     * If the encoding is set to NULL we do not send an Accept-Encoding header
      * and ignore an received Content-Encoding header.
      *
      */
@@ -646,7 +686,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
 
   case CURLOPT_POST:
     /* Does this option serve a purpose anymore? Yes it does, when
-       CURLOPT_POSTFIELDS isn't used and the POST data is read off the
+       CURLOPT_POSTFIELDS is not used and the POST data is read off the
        callback! */
     if(va_arg(param, long)) {
       data->set.method = HTTPREQ_POST;
@@ -749,7 +789,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
       /* general protection against mistakes and abuse */
       if(strlen(argptr) > CURL_MAX_INPUT_LENGTH)
         return CURLE_BAD_FUNCTION_ARGUMENT;
-      /* append the cookie file name to the list of file names, and deal with
+      /* append the cookie filename to the list of filenames, and deal with
          them later */
       cl = curl_slist_append(data->state.cookielist, argptr);
       if(!cl) {
@@ -765,7 +805,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
       data->state.cookielist = NULL;
 
       if(!data->share || !data->share->cookies) {
-        /* throw away all existing cookies if this isn't a shared cookie
+        /* throw away all existing cookies if this is not a shared cookie
            container */
         Curl_cookie_clearall(data->cookies);
         Curl_cookie_cleanup(data->cookies);
@@ -777,7 +817,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
 
   case CURLOPT_COOKIEJAR:
     /*
-     * Set cookie file name to dump all cookies to when we're done.
+     * Set cookie filename to dump all cookies to when we are done.
      */
     result = Curl_setstropt(&data->set.str[STRING_COOKIEJAR],
                             va_arg(param, char *));
@@ -928,7 +968,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
     break;
 
   case CURLOPT_HTTP09_ALLOWED:
-    arg = va_arg(param, unsigned long);
+    arg = (long)va_arg(param, unsigned long);
     if(arg > 1L)
       return CURLE_BAD_FUNCTION_ARGUMENT;
 #ifdef USE_HYPER
@@ -1007,7 +1047,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
       auth &= ~CURLAUTH_DIGEST_IE; /* unset ie digest bit */
     }
 
-    /* switch off bits we can't support */
+    /* switch off bits we cannot support */
 #ifndef USE_NTLM
     auth &= ~CURLAUTH_NTLM;    /* no NTLM support */
 #endif
@@ -1039,7 +1079,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
     result = Curl_setstropt(&data->set.str[STRING_CUSTOMREQUEST],
                             va_arg(param, char *));
 
-    /* we don't set
+    /* we do not set
        data->set.method = HTTPREQ_CUSTOM;
        here, we continue as if we were using the already set type
        and this just changes the actual request keyword */
@@ -1085,7 +1125,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
       auth |= CURLAUTH_DIGEST; /* set standard digest bit */
       auth &= ~CURLAUTH_DIGEST_IE; /* unset ie digest bit */
     }
-    /* switch off bits we can't support */
+    /* switch off bits we cannot support */
 #ifndef USE_NTLM
     auth &= ~CURLAUTH_NTLM;    /* no NTLM support */
 #endif
@@ -1115,7 +1155,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
      * Set proxy server:port to use as proxy.
      *
      * If the proxy is set to "" (and CURLOPT_SOCKS_PROXY is set to "" or NULL)
-     * we explicitly say that we don't want to use a proxy
+     * we explicitly say that we do not want to use a proxy
      * (even though there might be environment variables saying so).
      *
      * Setting it to NULL, means no proxy but allows the environment variables
@@ -1129,7 +1169,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
     /*
      * Set proxy server:port to use as SOCKS proxy.
      *
-     * If the proxy is set to "" or NULL we explicitly say that we don't want
+     * If the proxy is set to "" or NULL we explicitly say that we do not want
      * to use the socks proxy.
      */
     result = Curl_setstropt(&data->set.str[STRING_PRE_PROXY],
@@ -1500,7 +1540,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
 
   case CURLOPT_USERNAME:
     /*
-     * authentication user name to use in the operation
+     * authentication username to use in the operation
      */
     result = Curl_setstropt(&data->set.str[STRING_USERNAME],
                             va_arg(param, char *));
@@ -1541,7 +1581,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
      * Prefix the HOST with dash (-) to _remove_ the entry from the cache.
      *
      * This API can remove any entry from the DNS cache, but only entries
-     * that aren't actually in use right now will be pruned immediately.
+     * that are not actually in use right now will be pruned immediately.
      */
     data->set.resolve = va_arg(param, struct curl_slist *);
     data->state.resolve = data->set.resolve;
@@ -1598,7 +1638,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
     break;
   case CURLOPT_PROXYUSERNAME:
     /*
-     * authentication user name to use in the operation
+     * authentication username to use in the operation
      */
     result = Curl_setstropt(&data->set.str[STRING_PROXYUSERNAME],
                             va_arg(param, char *));
@@ -1650,7 +1690,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
      */
     data->set.fdebug = va_arg(param, curl_debug_callback);
     /*
-     * if the callback provided is NULL, it'll use the default callback
+     * if the callback provided is NULL, it will use the default callback
      */
     break;
   case CURLOPT_DEBUGDATA:
@@ -1723,7 +1763,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
     break;
   case CURLOPT_SSLCERT:
     /*
-     * String that holds file name of the SSL certificate to use
+     * String that holds filename of the SSL certificate to use
      */
     result = Curl_setstropt(&data->set.str[STRING_CERT],
                             va_arg(param, char *));
@@ -1738,7 +1778,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
 #ifndef CURL_DISABLE_PROXY
   case CURLOPT_PROXY_SSLCERT:
     /*
-     * String that holds file name of the SSL certificate to use for proxy
+     * String that holds filename of the SSL certificate to use for proxy
      */
     result = Curl_setstropt(&data->set.str[STRING_CERT_PROXY],
                             va_arg(param, char *));
@@ -1769,7 +1809,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
 #endif
   case CURLOPT_SSLKEY:
     /*
-     * String that holds file name of the SSL key to use
+     * String that holds filename of the SSL key to use
      */
     result = Curl_setstropt(&data->set.str[STRING_KEY],
                             va_arg(param, char *));
@@ -1784,7 +1824,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
 #ifndef CURL_DISABLE_PROXY
   case CURLOPT_PROXY_SSLKEY:
     /*
-     * String that holds file name of the SSL key to use for proxy
+     * String that holds filename of the SSL key to use for proxy
      */
     result = Curl_setstropt(&data->set.str[STRING_KEY_PROXY],
                             va_arg(param, char *));
@@ -1877,8 +1917,10 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
      * Set what interface or address/hostname to bind the socket to when
      * performing an operation and thus what from-IP your connection will use.
      */
-    result = Curl_setstropt(&data->set.str[STRING_DEVICE],
-                            va_arg(param, char *));
+    result = setstropt_interface(va_arg(param, char *),
+                                 &data->set.str[STRING_DEVICE],
+                                 &data->set.str[STRING_INTERFACE],
+                                 &data->set.str[STRING_BINDHOST]);
     break;
 #ifndef CURL_DISABLE_BINDLOCAL
   case CURLOPT_LOCALPORT:
@@ -1939,12 +1981,12 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
 #endif
   case CURLOPT_SSL_VERIFYHOST:
     /*
-     * Enable verification of the host name in the peer certificate
+     * Enable verification of the hostname in the peer certificate
      */
     arg = va_arg(param, long);
 
     /* Obviously people are not reading documentation and too many thought
-       this argument took a boolean when it wasn't and misused it.
+       this argument took a boolean when it was not and misused it.
        Treat 1 and 2 the same */
     data->set.ssl.primary.verifyhost = !!(arg & 3);
 
@@ -1954,7 +1996,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
 #ifndef CURL_DISABLE_DOH
   case CURLOPT_DOH_SSL_VERIFYHOST:
     /*
-     * Enable verification of the host name in the peer certificate for DoH
+     * Enable verification of the hostname in the peer certificate for DoH
      */
     arg = va_arg(param, long);
 
@@ -1965,7 +2007,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
 #ifndef CURL_DISABLE_PROXY
   case CURLOPT_PROXY_SSL_VERIFYHOST:
     /*
-     * Enable verification of the host name in the peer certificate for proxy
+     * Enable verification of the hostname in the peer certificate for proxy
      */
     arg = va_arg(param, long);
 
@@ -2046,7 +2088,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
   case CURLOPT_PINNEDPUBLICKEY:
     /*
      * Set pinned public key for SSL connection.
-     * Specify file name of the public key in DER format.
+     * Specify filename of the public key in DER format.
      */
 #ifdef USE_SSL
     if(Curl_ssl_supports(data, SSLSUPP_PINNEDPUBKEY))
@@ -2060,7 +2102,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
   case CURLOPT_PROXY_PINNEDPUBLICKEY:
     /*
      * Set pinned public key for SSL connection.
-     * Specify file name of the public key in DER format.
+     * Specify filename of the public key in DER format.
      */
 #ifdef USE_SSL
     if(Curl_ssl_supports(data, SSLSUPP_PINNEDPUBKEY))
@@ -2073,7 +2115,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
 #endif
   case CURLOPT_CAINFO:
     /*
-     * Set CA info for SSL connection. Specify file name of the CA certificate
+     * Set CA info for SSL connection. Specify filename of the CA certificate
      */
     result = Curl_setstropt(&data->set.str[STRING_SSL_CAFILE],
                             va_arg(param, char *));
@@ -2095,7 +2137,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
 #ifndef CURL_DISABLE_PROXY
   case CURLOPT_PROXY_CAINFO:
     /*
-     * Set CA info SSL connection for proxy. Specify file name of the
+     * Set CA info SSL connection for proxy. Specify filename of the
      * CA certificate
      */
     result = Curl_setstropt(&data->set.str[STRING_SSL_CAFILE_PROXY],
@@ -2148,7 +2190,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
 #endif
   case CURLOPT_CRLFILE:
     /*
-     * Set CRL file info for SSL connection. Specify file name of the CRL
+     * Set CRL file info for SSL connection. Specify filename of the CRL
      * to check certificates revocation
      */
     result = Curl_setstropt(&data->set.str[STRING_SSL_CRLFILE],
@@ -2157,7 +2199,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
 #ifndef CURL_DISABLE_PROXY
   case CURLOPT_PROXY_CRLFILE:
     /*
-     * Set CRL file info for SSL connection for proxy. Specify file name of the
+     * Set CRL file info for SSL connection for proxy. Specify filename of the
      * CRL to check certificates revocation
      */
     result = Curl_setstropt(&data->set.str[STRING_SSL_CRLFILE_PROXY],
@@ -2207,7 +2249,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
   case CURLOPT_BUFFERSIZE:
     /*
      * The application kindly asks for a differently sized receive buffer.
-     * If it seems reasonable, we'll use it.
+     * If it seems reasonable, we will use it.
      */
     arg = va_arg(param, long);
 
@@ -2495,16 +2537,17 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
     break;
 
   case CURLOPT_SSL_SESSIONID_CACHE:
-    data->set.ssl.primary.sessionid = (0 != va_arg(param, long));
+    data->set.ssl.primary.cache_session = (0 != va_arg(param, long));
 #ifndef CURL_DISABLE_PROXY
-    data->set.proxy_ssl.primary.sessionid = data->set.ssl.primary.sessionid;
+    data->set.proxy_ssl.primary.cache_session =
+      data->set.ssl.primary.cache_session;
 #endif
     break;
 
 #ifdef USE_SSH
     /* we only include SSH options if explicitly built to support SSH */
   case CURLOPT_SSH_AUTH_TYPES:
-    data->set.ssh_auth_types = (unsigned int)va_arg(param, long);
+    data->set.ssh_auth_types = (int)va_arg(param, long);
     break;
 
   case CURLOPT_SSH_PUBLIC_KEYFILE:
@@ -2533,7 +2576,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
 
   case CURLOPT_SSH_KNOWNHOSTS:
     /*
-     * Store the file name to read known hosts from.
+     * Store the filename to read known hosts from.
      */
     result = Curl_setstropt(&data->set.str[STRING_SSH_KNOWNHOSTS],
                             va_arg(param, char *));
@@ -2587,7 +2630,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
     data->set.http_te_skip = (0 == va_arg(param, long));
     break;
 #else
-    return CURLE_NOT_BUILT_IN; /* hyper doesn't support */
+    return CURLE_NOT_BUILT_IN; /* hyper does not support */
 #endif
 
   case CURLOPT_HTTP_CONTENT_DECODING:
@@ -2625,7 +2668,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
     /*
      * Use this scope id when using IPv6
      * We always get longs when passed plain numericals so we should check
-     * that the value fits into an unsigned 32 bit integer.
+     * that the value fits into an unsigned 32-bit integer.
      */
     uarg = va_arg(param, unsigned long);
 #if SIZEOF_LONG > 4
@@ -2668,7 +2711,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
   }
 
   case CURLOPT_DEFAULT_PROTOCOL:
-    /* Set the protocol to use when the URL doesn't include any protocol */
+    /* Set the protocol to use when the URL does not include any protocol */
     result = Curl_setstropt(&data->set.str[STRING_DEFAULT_PROTOCOL],
                             va_arg(param, char *));
     break;
@@ -2918,6 +2961,14 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
       arg = INT_MAX;
     data->set.tcp_keepintvl = (int)arg;
     break;
+  case CURLOPT_TCP_KEEPCNT:
+    arg = va_arg(param, long);
+    if(arg < 0)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    else if(arg > INT_MAX)
+      arg = INT_MAX;
+    data->set.tcp_keepcnt = (int)arg;
+    break;
   case CURLOPT_TCP_FASTOPEN:
 #if defined(CONNECT_DATA_IDEMPOTENT) || defined(MSG_FASTOPEN) || \
    defined(TCP_FASTOPEN_CONNECT)
@@ -3049,7 +3100,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
       result = Curl_setstropt(&data->set.str[STRING_HSTS], argptr);
       if(result)
         return result;
-      /* this needs to build a list of file names to read from, so that it can
+      /* this needs to build a list of filenames to read from, so that it can
          read them later, as we might get a shared HSTS handle to load them
          into */
       h = curl_slist_append(data->state.hstslist, argptr);
diff --git a/lib/setup-os400.h b/lib/setup-os400.h
index 53e91777e..ef7baca67 100644
--- a/lib/setup-os400.h
+++ b/lib/setup-os400.h
@@ -38,6 +38,15 @@ typedef unsigned long   u_int32_t;
 #define isatty(fd)      0
 
 
+/* Workaround bug in IBM QADRT runtime library:
+ * function puts() does not output the implicit trailing newline.
+ */
+
+#include <stdio.h>      /* Be sure it is loaded. */
+#undef puts
+#define puts(s) (fputs((s), stdout) == EOF? EOF: putchar('\n'))
+
+
 /* System API wrapper prototypes & definitions to support ASCII parameters. */
 
 #include <sys/socket.h>
@@ -46,6 +55,8 @@ typedef unsigned long   u_int32_t;
 #include <qsoasync.h>
 #include <gssapi.h>
 
+#ifdef BUILDING_LIBCURL
+
 extern int Curl_getaddrinfo_a(const char *nodename,
                               const char *servname,
                               const struct addrinfo *hints,
@@ -141,4 +152,6 @@ extern int Curl_os400_getsockname(int sd, struct sockaddr *addr, int *addrlen);
 #define inflateEnd              Curl_os400_inflateEnd
 #endif
 
+#endif /* BUILDING_LIBCURL */
+
 #endif /* HEADER_CURL_SETUP_OS400_H */
diff --git a/lib/setup-vms.h b/lib/setup-vms.h
index ea3936c70..fc2156028 100644
--- a/lib/setup-vms.h
+++ b/lib/setup-vms.h
@@ -144,7 +144,7 @@ static struct passwd *vms_getpwuid(uid_t uid)
 {
   struct passwd *my_passwd;
 
-/* Hack needed to support 64 bit builds, decc_getpwnam is 32 bit only */
+/* Hack needed to support 64-bit builds, decc_getpwnam is 32-bit only */
 #ifdef __DECC
 #   if __INITIAL_POINTER_SIZE
   __char_ptr32 unix_path;
diff --git a/lib/setup-win32.h b/lib/setup-win32.h
index d7e2e6be1..80efc25f1 100644
--- a/lib/setup-win32.h
+++ b/lib/setup-win32.h
@@ -65,7 +65,7 @@
  * Include header files for windows builds before redefining anything.
  * Use this preprocessor block only to include or exclude windows.h,
  * winsock2.h or ws2tcpip.h. Any other windows thing belongs
- * to any other further and independent block.  Under Cygwin things work
+ * to any other further and independent block. Under Cygwin things work
  * just as under linux (e.g. <sys/socket.h>) and the winsock headers should
  * never be included when __CYGWIN__ is defined.
  */
@@ -78,7 +78,7 @@
 #    error "_UNICODE is defined but UNICODE is not defined"
 #  endif
 /*
- * Don't include unneeded stuff in Windows headers to avoid compiler
+ * Do not include unneeded stuff in Windows headers to avoid compiler
  * warnings and macro clashes.
  * Make sure to define this macro before including any Windows headers.
  */
diff --git a/lib/sha256.c b/lib/sha256.c
index 4a02045d2..6ff66f741 100644
--- a/lib/sha256.c
+++ b/lib/sha256.c
@@ -334,14 +334,14 @@ static const unsigned long K[64] = {
 #define RORc(x, y) \
 (((((unsigned long)(x) & 0xFFFFFFFFUL) >> (unsigned long)((y) & 31)) | \
    ((unsigned long)(x) << (unsigned long)(32 - ((y) & 31)))) & 0xFFFFFFFFUL)
-#define Ch(x,y,z)   (z ^ (x & (y ^ z)))
-#define Maj(x,y,z)  (((x | y) & z) | (x & y))
-#define S(x, n)     RORc((x), (n))
-#define R(x, n)     (((x)&0xFFFFFFFFUL)>>(n))
-#define Sigma0(x)   (S(x, 2) ^ S(x, 13) ^ S(x, 22))
-#define Sigma1(x)   (S(x, 6) ^ S(x, 11) ^ S(x, 25))
-#define Gamma0(x)   (S(x, 7) ^ S(x, 18) ^ R(x, 3))
-#define Gamma1(x)   (S(x, 17) ^ S(x, 19) ^ R(x, 10))
+#define Sha256_Ch(x,y,z)  (z ^ (x & (y ^ z)))
+#define Sha256_Maj(x,y,z) (((x | y) & z) | (x & y))
+#define Sha256_S(x, n)    RORc((x), (n))
+#define Sha256_R(x, n)    (((x)&0xFFFFFFFFUL)>>(n))
+#define Sigma0(x)         (Sha256_S(x, 2) ^ Sha256_S(x, 13) ^ Sha256_S(x, 22))
+#define Sigma1(x)         (Sha256_S(x, 6) ^ Sha256_S(x, 11) ^ Sha256_S(x, 25))
+#define Gamma0(x)         (Sha256_S(x, 7) ^ Sha256_S(x, 18) ^ Sha256_R(x, 3))
+#define Gamma1(x)         (Sha256_S(x, 17) ^ Sha256_S(x, 19) ^ Sha256_R(x, 10))
 
 /* Compress 512-bits */
 static int sha256_compress(struct sha256_state *md,
@@ -364,12 +364,12 @@ static int sha256_compress(struct sha256_state *md,
   }
 
   /* Compress */
-#define RND(a,b,c,d,e,f,g,h,i)                                          \
-  do {                                                                  \
-    unsigned long t0 = h + Sigma1(e) + Ch(e, f, g) + K[i] + W[i];       \
-    unsigned long t1 = Sigma0(a) + Maj(a, b, c);                        \
-    d += t0;                                                            \
-    h = t0 + t1;                                                        \
+#define RND(a,b,c,d,e,f,g,h,i)                                           \
+  do {                                                                   \
+    unsigned long t0 = h + Sigma1(e) + Sha256_Ch(e, f, g) + K[i] + W[i]; \
+    unsigned long t1 = Sigma0(a) + Sha256_Maj(a, b, c);                  \
+    d += t0;                                                             \
+    h = t0 + t1;                                                         \
   } while(0)
 
   for(i = 0; i < 64; ++i) {
@@ -467,7 +467,7 @@ static int my_sha256_final(unsigned char *out,
   md->buf[md->curlen++] = (unsigned char)0x80;
 
   /* If the length is currently above 56 bytes we append zeros
-   * then compress.  Then we can fall back to padding zeros and length
+   * then compress. Then we can fall back to padding zeros and length
    * encoding like normal.
    */
   if(md->curlen > 56) {
@@ -542,4 +542,4 @@ const struct HMAC_params Curl_HMAC_SHA256[] = {
 };
 
 
-#endif /* AWS, DIGEST, or libSSH2 */
+#endif /* AWS, DIGEST, or libssh2 */
diff --git a/lib/share.c b/lib/share.c
index 8fa5cda00..164aceb87 100644
--- a/lib/share.c
+++ b/lib/share.c
@@ -26,6 +26,7 @@
 
 #include <curl/curl.h>
 #include "urldata.h"
+#include "connect.h"
 #include "share.h"
 #include "psl.h"
 #include "vtls/vtls.h"
@@ -64,7 +65,7 @@ curl_share_setopt(struct Curl_share *share, CURLSHoption option, ...)
     return CURLSHE_INVALID;
 
   if(share->dirty)
-    /* don't allow setting options while one or more handles are already
+    /* do not allow setting options while one or more handles are already
        using this share */
     return CURLSHE_IN_USE;
 
@@ -119,7 +120,7 @@ curl_share_setopt(struct Curl_share *share, CURLSHoption option, ...)
       break;
 
     case CURL_LOCK_DATA_CONNECT:
-      if(Curl_conncache_init(&share->conn_cache, 103))
+      if(Curl_conncache_init(&share->conn_cache, NULL, 103))
         res = CURLSHE_NOMEM;
       break;
 
@@ -268,7 +269,7 @@ Curl_share_lock(struct Curl_easy *data, curl_lock_data type,
     if(share->lockfunc) /* only call this if set! */
       share->lockfunc(data, type, accesstype, share->clientdata);
   }
-  /* else if we don't share this, pretend successful lock */
+  /* else if we do not share this, pretend successful lock */
 
   return CURLSHE_OK;
 }
diff --git a/lib/share.h b/lib/share.h
index 632d9198f..f63a6f8fe 100644
--- a/lib/share.h
+++ b/lib/share.h
@@ -34,7 +34,7 @@
 #define CURL_GOOD_SHARE 0x7e117a1e
 #define GOOD_SHARE_HANDLE(x) ((x) && (x)->magic == CURL_GOOD_SHARE)
 
-/* this struct is libcurl-private, don't export details */
+/* this struct is libcurl-private, do not export details */
 struct Curl_share {
   unsigned int magic; /* CURL_GOOD_SHARE */
   unsigned int specifier;
diff --git a/lib/sigpipe.h b/lib/sigpipe.h
index 9b29403c2..b91a2f513 100644
--- a/lib/sigpipe.h
+++ b/lib/sigpipe.h
@@ -36,6 +36,11 @@ struct sigpipe_ignore {
 
 #define SIGPIPE_VARIABLE(x) struct sigpipe_ignore x
 
+static void sigpipe_init(struct sigpipe_ignore *ig)
+{
+  memset(ig, 0, sizeof(*ig));
+}
+
 /*
  * sigpipe_ignore() makes sure we ignore SIGPIPE while running libcurl
  * internals, and then sigpipe_restore() will restore the situation when we
@@ -70,9 +75,20 @@ static void sigpipe_restore(struct sigpipe_ignore *ig)
     sigaction(SIGPIPE, &ig->old_pipe_act, NULL);
 }
 
+static void sigpipe_apply(struct Curl_easy *data,
+                          struct sigpipe_ignore *ig)
+{
+  if(data->set.no_signal != ig->no_signal) {
+    sigpipe_restore(ig);
+    sigpipe_ignore(data, ig);
+  }
+}
+
 #else
 /* for systems without sigaction */
 #define sigpipe_ignore(x,y) Curl_nop_stmt
+#define sigpipe_apply(x,y) Curl_nop_stmt
+#define sigpipe_init(x)  Curl_nop_stmt
 #define sigpipe_restore(x)  Curl_nop_stmt
 #define SIGPIPE_VARIABLE(x)
 #endif
diff --git a/lib/smb.c b/lib/smb.c
index cab1e757f..102662ace 100644
--- a/lib/smb.c
+++ b/lib/smb.c
@@ -559,7 +559,7 @@ static void smb_format_message(struct Curl_easy *data, struct smb_header *h,
   h->flags2 = smb_swap16(SMB_FLAGS2_IS_LONG_NAME | SMB_FLAGS2_KNOWS_LONG_NAME);
   h->uid = smb_swap16(smbc->uid);
   h->tid = smb_swap16(req->tid);
-  pid = getpid();
+  pid = (unsigned int)getpid();
   h->pid_high = smb_swap16((unsigned short)(pid >> 16));
   h->pid = smb_swap16((unsigned short) pid);
 }
@@ -1071,7 +1071,7 @@ static CURLcode smb_request_state(struct Curl_easy *data, bool *done)
     break;
 
   case SMB_CLOSE:
-    /* We don't care if the close failed, proceed to tree disconnect anyway */
+    /* We do not care if the close failed, proceed to tree disconnect anyway */
     next_state = SMB_TREE_DISCONNECT;
     break;
 
diff --git a/lib/smtp.c b/lib/smtp.c
index dd231a521..5ee1b5ea3 100644
--- a/lib/smtp.c
+++ b/lib/smtp.c
@@ -534,16 +534,16 @@ static CURLcode smtp_perform_command(struct Curl_easy *data)
   if(smtp->rcpt) {
     /* We notify the server we are sending UTF-8 data if a) it supports the
        SMTPUTF8 extension and b) The mailbox contains UTF-8 characters, in
-       either the local address or host name parts. This is regardless of
-       whether the host name is encoded using IDN ACE */
+       either the local address or hostname parts. This is regardless of
+       whether the hostname is encoded using IDN ACE */
     bool utf8 = FALSE;
 
     if((!smtp->custom) || (!smtp->custom[0])) {
       char *address = NULL;
       struct hostname host = { NULL, NULL, NULL, NULL };
 
-      /* Parse the mailbox to verify into the local address and host name
-         parts, converting the host name to an IDN A-label if necessary */
+      /* Parse the mailbox to verify into the local address and hostname
+         parts, converting the hostname to an IDN A-label if necessary */
       result = smtp_parse_address(smtp->rcpt->data,
                                   &address, &host);
       if(result)
@@ -555,7 +555,7 @@ static CURLcode smtp_perform_command(struct Curl_easy *data)
              ((host.encalloc) || (!Curl_is_ASCII_name(address)) ||
               (!Curl_is_ASCII_name(host.name)));
 
-      /* Send the VRFY command (Note: The host name part may be absent when the
+      /* Send the VRFY command (Note: The hostname part may be absent when the
          host is a local system) */
       result = Curl_pp_sendf(data, &conn->proto.smtpc.pp, "VRFY %s%s%s%s",
                              address,
@@ -607,8 +607,8 @@ static CURLcode smtp_perform_mail(struct Curl_easy *data)
 
   /* We notify the server we are sending UTF-8 data if a) it supports the
      SMTPUTF8 extension and b) The mailbox contains UTF-8 characters, in
-     either the local address or host name parts. This is regardless of
-     whether the host name is encoded using IDN ACE */
+     either the local address or hostname parts. This is regardless of
+     whether the hostname is encoded using IDN ACE */
   bool utf8 = FALSE;
 
   /* Calculate the FROM parameter */
@@ -616,8 +616,8 @@ static CURLcode smtp_perform_mail(struct Curl_easy *data)
     char *address = NULL;
     struct hostname host = { NULL, NULL, NULL, NULL };
 
-    /* Parse the FROM mailbox into the local address and host name parts,
-       converting the host name to an IDN A-label if necessary */
+    /* Parse the FROM mailbox into the local address and hostname parts,
+       converting the hostname to an IDN A-label if necessary */
     result = smtp_parse_address(data->set.str[STRING_MAIL_FROM],
                                 &address, &host);
     if(result)
@@ -635,8 +635,8 @@ static CURLcode smtp_perform_mail(struct Curl_easy *data)
       Curl_free_idnconverted_hostname(&host);
     }
     else
-      /* An invalid mailbox was provided but we'll simply let the server worry
-         about that and reply with a 501 error */
+      /* An invalid mailbox was provided but we will simply let the server
+         worry about that and reply with a 501 error */
       from = aprintf("<%s>", address);
 
     free(address);
@@ -656,8 +656,8 @@ static CURLcode smtp_perform_mail(struct Curl_easy *data)
       char *address = NULL;
       struct hostname host = { NULL, NULL, NULL, NULL };
 
-      /* Parse the AUTH mailbox into the local address and host name parts,
-         converting the host name to an IDN A-label if necessary */
+      /* Parse the AUTH mailbox into the local address and hostname parts,
+         converting the hostname to an IDN A-label if necessary */
       result = smtp_parse_address(data->set.str[STRING_MAIL_AUTH],
                                   &address, &host);
       if(result)
@@ -676,7 +676,7 @@ static CURLcode smtp_perform_mail(struct Curl_easy *data)
         Curl_free_idnconverted_hostname(&host);
       }
       else
-        /* An invalid mailbox was provided but we'll simply let the server
+        /* An invalid mailbox was provided but we will simply let the server
            worry about it */
         auth = aprintf("<%s>", address);
       free(address);
@@ -695,7 +695,7 @@ static CURLcode smtp_perform_mail(struct Curl_easy *data)
   /* Prepare the mime data if some. */
   if(data->set.mimepost.kind != MIMEKIND_NONE) {
     /* Use the whole structure as data. */
-    data->set.mimepost.flags &= ~MIME_BODY_ONLY;
+    data->set.mimepost.flags &= ~(unsigned int)MIME_BODY_ONLY;
 
     /* Add external headers and mime version. */
     curl_mime_headers(&data->set.mimepost, data->set.headers, 0);
@@ -731,7 +731,7 @@ static CURLcode smtp_perform_mail(struct Curl_easy *data)
     }
   }
 
-  /* If the mailboxes in the FROM and AUTH parameters don't include a UTF-8
+  /* If the mailboxes in the FROM and AUTH parameters do not include a UTF-8
      based address then quickly scan through the recipient list and check if
      any there do, as we need to correctly identify our support for SMTPUTF8
      in the envelope, as per RFC-6531 sect. 3.4 */
@@ -740,7 +740,7 @@ static CURLcode smtp_perform_mail(struct Curl_easy *data)
     struct curl_slist *rcpt = smtp->rcpt;
 
     while(rcpt && !utf8) {
-      /* Does the host name contain non-ASCII characters? */
+      /* Does the hostname contain non-ASCII characters? */
       if(!Curl_is_ASCII_name(rcpt->data))
         utf8 = TRUE;
 
@@ -790,8 +790,8 @@ static CURLcode smtp_perform_rcpt_to(struct Curl_easy *data)
   char *address = NULL;
   struct hostname host = { NULL, NULL, NULL, NULL };
 
-  /* Parse the recipient mailbox into the local address and host name parts,
-     converting the host name to an IDN A-label if necessary */
+  /* Parse the recipient mailbox into the local address and hostname parts,
+     converting the hostname to an IDN A-label if necessary */
   result = smtp_parse_address(smtp->rcpt->data,
                               &address, &host);
   if(result)
@@ -802,7 +802,7 @@ static CURLcode smtp_perform_rcpt_to(struct Curl_easy *data)
     result = Curl_pp_sendf(data, &conn->proto.smtpc.pp, "RCPT TO:<%s@%s>",
                            address, host.name);
   else
-    /* An invalid mailbox was provided but we'll simply let the server worry
+    /* An invalid mailbox was provided but we will simply let the server worry
        about that and reply with a 501 error */
     result = Curl_pp_sendf(data, &conn->proto.smtpc.pp, "RCPT TO:<%s>",
                            address);
@@ -958,7 +958,7 @@ static CURLcode smtp_state_ehlo_resp(struct Curl_easy *data,
 
     if(smtpcode != 1) {
       if(data->set.use_ssl && !Curl_conn_is_ssl(conn, FIRSTSOCKET)) {
-        /* We don't have a SSL/TLS connection yet, but SSL is requested */
+        /* We do not have a SSL/TLS connection yet, but SSL is requested */
         if(smtpc->tls_supported)
           /* Switch to TLS connection now */
           result = smtp_perform_starttls(data, conn);
@@ -1102,7 +1102,7 @@ static CURLcode smtp_state_rcpt_resp(struct Curl_easy *data,
 
   is_smtp_err = (smtpcode/100 != 2) ? TRUE : FALSE;
 
-  /* If there's multiple RCPT TO to be issued, it's possible to ignore errors
+  /* If there is multiple RCPT TO to be issued, it is possible to ignore errors
      and proceed with only the valid addresses. */
   is_smtp_blocking_err =
     (is_smtp_err && !data->set.mail_rcpt_allowfails) ? TRUE : FALSE;
@@ -1129,7 +1129,7 @@ static CURLcode smtp_state_rcpt_resp(struct Curl_easy *data,
       /* Send the next RCPT TO command */
       result = smtp_perform_rcpt_to(data);
     else {
-      /* We weren't able to issue a successful RCPT TO command while going
+      /* We were not able to issue a successful RCPT TO command while going
          over recipients (potentially multiple). Sending back last error. */
       if(!smtp->rcpt_had_ok) {
         failf(data, "RCPT failed: %d (last error)", smtp->rcpt_last_error);
@@ -1164,7 +1164,7 @@ static CURLcode smtp_state_data_resp(struct Curl_easy *data, int smtpcode,
     Curl_pgrsSetUploadSize(data, data->state.infilesize);
 
     /* SMTP upload */
-    Curl_xfer_setup(data, -1, -1, FALSE, FIRSTSOCKET);
+    Curl_xfer_setup1(data, CURL_XFER_SEND, -1, FALSE);
 
     /* End of DO phase */
     smtp_state(data, SMTP_STOP);
@@ -1202,6 +1202,7 @@ static CURLcode smtp_statemachine(struct Curl_easy *data,
   size_t nread = 0;
 
   /* Busy upgrading the connection; right now all I/O is SSL/TLS, not SMTP */
+upgrade_tls:
   if(smtpc->state == SMTP_UPGRADETLS)
     return smtp_perform_upgrade_tls(data);
 
@@ -1238,6 +1239,10 @@ static CURLcode smtp_statemachine(struct Curl_easy *data,
 
     case SMTP_STARTTLS:
       result = smtp_state_starttls_resp(data, smtpcode, smtpc->state);
+      /* During UPGRADETLS, leave the read loop as we need to connect
+       * (e.g. TLS handshake) before we continue sending/receiving. */
+      if(!result && (smtpc->state == SMTP_UPGRADETLS))
+        goto upgrade_tls;
       break;
 
     case SMTP_AUTH:
@@ -1447,10 +1452,10 @@ static CURLcode smtp_perform(struct Curl_easy *data, bool *connected,
   /* Store the first recipient (or NULL if not specified) */
   smtp->rcpt = data->set.mail_rcpt;
 
-  /* Track of whether we've successfully sent at least one RCPT TO command */
+  /* Track of whether we have successfully sent at least one RCPT TO command */
   smtp->rcpt_had_ok = FALSE;
 
-  /* Track of the last error we've received by sending RCPT TO command */
+  /* Track of the last error we have received by sending RCPT TO command */
   smtp->rcpt_last_error = 0;
 
   /* Initial data character is the first character in line: it is implicitly
@@ -1550,7 +1555,7 @@ static CURLcode smtp_dophase_done(struct Curl_easy *data, bool connected)
 
   if(smtp->transfer != PPTRANSFER_BODY)
     /* no data to transfer */
-    Curl_xfer_setup(data, -1, -1, FALSE, -1);
+    Curl_xfer_setup_nop(data);
 
   return CURLE_OK;
 }
@@ -1708,7 +1713,7 @@ static CURLcode smtp_parse_custom_request(struct Curl_easy *data)
  * smtp_parse_address()
  *
  * Parse the fully qualified mailbox address into a local address part and the
- * host name, converting the host name to an IDN A-label, as per RFC-5890, if
+ * hostname, converting the hostname to an IDN A-label, as per RFC-5890, if
  * necessary.
  *
  * Parameters:
@@ -1719,8 +1724,8 @@ static CURLcode smtp_parse_custom_request(struct Curl_easy *data)
  * address        [in/out] - A new allocated buffer which holds the local
  *                           address part of the mailbox. This buffer must be
  *                           free'ed by the caller.
- * host           [in/out] - The host name structure that holds the original,
- *                           and optionally encoded, host name.
+ * host           [in/out] - The hostname structure that holds the original,
+ *                           and optionally encoded, hostname.
  *                           Curl_free_idnconverted_hostname() must be called
  *                           once the caller has finished with the structure.
  *
@@ -1728,14 +1733,14 @@ static CURLcode smtp_parse_custom_request(struct Curl_easy *data)
  *
  * Notes:
  *
- * Should a UTF-8 host name require conversion to IDN ACE and we cannot honor
+ * Should a UTF-8 hostname require conversion to IDN ACE and we cannot honor
  * that conversion then we shall return success. This allow the caller to send
  * the data to the server as a U-label (as per RFC-6531 sect. 3.2).
  *
  * If an mailbox '@' separator cannot be located then the mailbox is considered
  * to be either a local mailbox or an invalid mailbox (depending on what the
  * calling function deems it to be) then the input will simply be returned in
- * the address part with the host name being NULL.
+ * the address part with the hostname being NULL.
  */
 static CURLcode smtp_parse_address(const char *fqma, char **address,
                                    struct hostname *host)
@@ -1744,7 +1749,7 @@ static CURLcode smtp_parse_address(const char *fqma, char **address,
   size_t length;
 
   /* Duplicate the fully qualified email address so we can manipulate it,
-     ensuring it doesn't contain the delimiters if specified */
+     ensuring it does not contain the delimiters if specified */
   char *dup = strdup(fqma[0] == '<' ? fqma + 1  : fqma);
   if(!dup)
     return CURLE_OUT_OF_MEMORY;
@@ -1755,17 +1760,17 @@ static CURLcode smtp_parse_address(const char *fqma, char **address,
       dup[length - 1] = '\0';
   }
 
-  /* Extract the host name from the address (if we can) */
+  /* Extract the hostname from the address (if we can) */
   host->name = strpbrk(dup, "@");
   if(host->name) {
     *host->name = '\0';
     host->name = host->name + 1;
 
-    /* Attempt to convert the host name to IDN ACE */
+    /* Attempt to convert the hostname to IDN ACE */
     (void) Curl_idnconvert_hostname(host);
 
     /* If Curl_idnconvert_hostname() fails then we shall attempt to continue
-       and send the host name using UTF-8 rather than as 7-bit ACE (which is
+       and send the hostname using UTF-8 rather than as 7-bit ACE (which is
        our preference) */
   }
 
@@ -1925,6 +1930,7 @@ static const struct Curl_crtype cr_eob = {
   Curl_creader_def_resume_from,
   Curl_creader_def_rewind,
   Curl_creader_def_unpause,
+  Curl_creader_def_is_paused,
   Curl_creader_def_done,
   sizeof(struct cr_eob_ctx)
 };
diff --git a/lib/socketpair.c b/lib/socketpair.c
index d7e3afd88..b14f5a5f1 100644
--- a/lib/socketpair.c
+++ b/lib/socketpair.c
@@ -27,14 +27,31 @@
 #include "urldata.h"
 #include "rand.h"
 
-#if defined(HAVE_PIPE) && defined(HAVE_FCNTL)
+#if defined(USE_EVENTFD)
+#ifdef HAVE_SYS_EVENTFD_H
+#include <sys/eventfd.h>
+#endif
+
+int Curl_eventfd(curl_socket_t socks[2], bool nonblocking)
+{
+  int efd = eventfd(0, nonblocking ? EFD_CLOEXEC | EFD_NONBLOCK : EFD_CLOEXEC);
+  if(efd == -1) {
+    socks[0] = socks[1] = CURL_SOCKET_BAD;
+    return -1;
+  }
+  socks[0] = socks[1] = efd;
+  return 0;
+}
+#elif defined(HAVE_PIPE)
+#ifdef HAVE_FCNTL
 #include <fcntl.h>
+#endif
 
-int Curl_pipe(curl_socket_t socks[2])
+int Curl_pipe(curl_socket_t socks[2], bool nonblocking)
 {
   if(pipe(socks))
     return -1;
-
+#ifdef HAVE_FCNTL
   if(fcntl(socks[0], F_SETFD, FD_CLOEXEC) ||
      fcntl(socks[1], F_SETFD, FD_CLOEXEC) ) {
     close(socks[0]);
@@ -42,13 +59,45 @@ int Curl_pipe(curl_socket_t socks[2])
     socks[0] = socks[1] = CURL_SOCKET_BAD;
     return -1;
   }
+#endif
+  if(nonblocking) {
+    if(curlx_nonblock(socks[0], TRUE) < 0 ||
+       curlx_nonblock(socks[1], TRUE) < 0) {
+      close(socks[0]);
+      close(socks[1]);
+      socks[0] = socks[1] = CURL_SOCKET_BAD;
+      return -1;
+    }
+  }
 
   return 0;
 }
 #endif
 
 
-#if !defined(HAVE_SOCKETPAIR) && !defined(CURL_DISABLE_SOCKETPAIR)
+#ifndef CURL_DISABLE_SOCKETPAIR
+#ifdef HAVE_SOCKETPAIR
+int Curl_socketpair(int domain, int type, int protocol,
+                    curl_socket_t socks[2], bool nonblocking)
+{
+#ifdef SOCK_NONBLOCK
+  type = nonblocking ? type | SOCK_NONBLOCK : type;
+#endif
+  if(socketpair(domain, type, protocol, socks))
+    return -1;
+#ifndef SOCK_NONBLOCK
+  if(nonblocking) {
+    if(curlx_nonblock(socks[0], TRUE) < 0 ||
+       curlx_nonblock(socks[1], TRUE) < 0) {
+      close(socks[0]);
+      close(socks[1]);
+      return -1;
+    }
+  }
+#endif
+  return 0;
+}
+#else /* !HAVE_SOCKETPAIR */
 #ifdef _WIN32
 /*
  * This is a socketpair() implementation for Windows.
@@ -80,7 +129,7 @@ int Curl_pipe(curl_socket_t socks[2])
 #include "memdebug.h"
 
 int Curl_socketpair(int domain, int type, int protocol,
-                    curl_socket_t socks[2])
+                    curl_socket_t socks[2], bool nonblocking)
 {
   union {
     struct sockaddr_in inaddr;
@@ -106,7 +155,7 @@ int Curl_socketpair(int domain, int type, int protocol,
   socks[0] = socks[1] = CURL_SOCKET_BAD;
 
 #if defined(_WIN32) || defined(__CYGWIN__)
-  /* don't set SO_REUSEADDR on Windows */
+  /* do not set SO_REUSEADDR on Windows */
   (void)reuse;
 #ifdef SO_EXCLUSIVEADDRUSE
   {
@@ -134,7 +183,7 @@ int Curl_socketpair(int domain, int type, int protocol,
   if(connect(socks[0], &a.addr, sizeof(a.inaddr)) == -1)
     goto error;
 
-  /* use non-blocking accept to make sure we don't block forever */
+  /* use non-blocking accept to make sure we do not block forever */
   if(curlx_nonblock(listener, TRUE) < 0)
     goto error;
   pfd[0].fd = listener;
@@ -168,7 +217,7 @@ int Curl_socketpair(int domain, int type, int protocol,
       nread = sread(socks[1], p, s);
       if(nread == -1) {
         int sockerr = SOCKERRNO;
-        /* Don't block forever */
+        /* Do not block forever */
         if(Curl_timediff(Curl_now(), start) > (60 * 1000))
           goto error;
         if(
@@ -198,6 +247,10 @@ int Curl_socketpair(int domain, int type, int protocol,
     } while(1);
   }
 
+  if(nonblocking)
+    if(curlx_nonblock(socks[0], TRUE) < 0 ||
+       curlx_nonblock(socks[1], TRUE) < 0)
+      goto error;
   sclose(listener);
   return 0;
 
@@ -207,5 +260,5 @@ error:
   sclose(socks[1]);
   return -1;
 }
-
-#endif /* ! HAVE_SOCKETPAIR */
+#endif
+#endif /* !CURL_DISABLE_SOCKETPAIR */
diff --git a/lib/socketpair.h b/lib/socketpair.h
index ddd44374a..42f4034fc 100644
--- a/lib/socketpair.h
+++ b/lib/socketpair.h
@@ -26,21 +26,44 @@
 
 #include "curl_setup.h"
 
-#ifdef HAVE_PIPE
+#if defined(HAVE_EVENTFD) && \
+    defined(__x86_64__) && \
+    defined(__aarch64__) && \
+    defined(__ia64__) && \
+    defined(__ppc64__) && \
+    defined(__mips64) && \
+    defined(__sparc64__) && \
+    defined(__riscv_64e) && \
+    defined(__s390x__)
+
+/* Use eventfd only with 64-bit CPU architectures because eventfd has a
+ * stringent rule of requiring the 8-byte buffer when calling read(2) and
+ * write(2) on it. In some rare cases, the C standard library implementation
+ * on a 32-bit system might choose to define uint64_t as a 32-bit type for
+ * various reasons (memory limitations, compatibility with older code),
+ * which makes eventfd broken.
+ */
+#define USE_EVENTFD 1
 
 #define wakeup_write  write
 #define wakeup_read   read
 #define wakeup_close  close
-#define wakeup_create(p) Curl_pipe(p)
+#define wakeup_create(p,nb) Curl_eventfd(p,nb)
 
-#ifdef HAVE_FCNTL
 #include <curl/curl.h>
-int Curl_pipe(curl_socket_t socks[2]);
-#else
-#define Curl_pipe(p) pipe(p)
-#endif
+int Curl_eventfd(curl_socket_t socks[2], bool nonblocking);
+
+#elif defined(HAVE_PIPE)
+
+#define wakeup_write  write
+#define wakeup_read   read
+#define wakeup_close  close
+#define wakeup_create(p,nb) Curl_pipe(p,nb)
+
+#include <curl/curl.h>
+int Curl_pipe(curl_socket_t socks[2], bool nonblocking);
 
-#else /* HAVE_PIPE */
+#else /* !USE_EVENTFD && !HAVE_PIPE */
 
 #define wakeup_write     swrite
 #define wakeup_read      sread
@@ -60,19 +83,16 @@ int Curl_pipe(curl_socket_t socks[2]);
 #define SOCKETPAIR_TYPE SOCK_STREAM
 #endif
 
-#define wakeup_create(p)\
-Curl_socketpair(SOCKETPAIR_FAMILY, SOCKETPAIR_TYPE, 0, p)
-
-#endif /* HAVE_PIPE */
+#define wakeup_create(p,nb)\
+Curl_socketpair(SOCKETPAIR_FAMILY, SOCKETPAIR_TYPE, 0, p, nb)
 
+#endif /* USE_EVENTFD */
 
-#ifndef HAVE_SOCKETPAIR
+#ifndef CURL_DISABLE_SOCKETPAIR
 #include <curl/curl.h>
 
 int Curl_socketpair(int domain, int type, int protocol,
-                    curl_socket_t socks[2]);
-#else
-#define Curl_socketpair(a,b,c,d) socketpair(a,b,c,d)
+                    curl_socket_t socks[2], bool nonblocking);
 #endif
 
 #endif /* HEADER_CURL_SOCKETPAIR_H */
diff --git a/lib/socks.c b/lib/socks.c
index 4ade4eb02..094ff42cd 100644
--- a/lib/socks.c
+++ b/lib/socks.c
@@ -125,7 +125,7 @@ int Curl_blockread_all(struct Curl_cfilter *cf,
     }
     nread = Curl_conn_cf_recv(cf->next, data, buf, buffersize, &err);
     if(nread <= 0) {
-      result = err;
+      result = (int)err;
       if(CURLE_AGAIN == err)
         continue;
       if(err) {
@@ -194,7 +194,7 @@ static void socksstate(struct socks_state *sx, struct Curl_easy *data,
 
   (void)data;
   if(oldstate == state)
-    /* don't bother when the new state is the same as the old state */
+    /* do not bother when the new state is the same as the old state */
     return;
 
   sx->state = state;
@@ -335,7 +335,7 @@ static CURLproxycode do_SOCKS4(struct Curl_cfilter *cf,
       goto CONNECT_RESOLVED;
     }
 
-    /* socks4a doesn't resolve anything locally */
+    /* socks4a does not resolve anything locally */
     sxstate(sx, data, CONNECT_REQ_INIT);
     goto CONNECT_REQ_INIT;
 
@@ -365,7 +365,7 @@ CONNECT_RESOLVED:
   {
     struct Curl_addrinfo *hp = NULL;
     /*
-     * We cannot use 'hostent' as a struct that Curl_resolv() returns.  It
+     * We cannot use 'hostent' as a struct that Curl_resolv() returns. It
      * returns a Curl_addrinfo pointer that may not always look the same.
      */
     if(dns) {
@@ -413,7 +413,7 @@ CONNECT_REQ_INIT:
         /* there is no real size limit to this field in the protocol, but
            SOCKS5 limits the proxy user field to 255 bytes and it seems likely
            that a longer field is either a mistake or malicious input */
-        failf(data, "Too long SOCKS proxy user name");
+        failf(data, "Too long SOCKS proxy username");
         return CURLPX_LONG_USER;
       }
       /* copy the proxy name WITH trailing zero */
@@ -440,7 +440,7 @@ CONNECT_REQ_INIT:
            (packetsize + hostnamelen < sizeof(sx->buffer)))
           strcpy((char *)socksreq + packetsize, sx->hostname);
         else {
-          failf(data, "SOCKS4: too long host name");
+          failf(data, "SOCKS4: too long hostname");
           return CURLPX_LONG_HOSTNAME;
         }
         packetsize += hostnamelen;
@@ -516,7 +516,7 @@ CONNECT_REQ_INIT:
     break;
   case 91:
     failf(data,
-          "Can't complete SOCKS4 connection to %d.%d.%d.%d:%d. (%d)"
+          "cannot complete SOCKS4 connection to %d.%d.%d.%d:%d. (%d)"
           ", request rejected or failed.",
           socksreq[4], socksreq[5], socksreq[6], socksreq[7],
           (((unsigned char)socksreq[2] << 8) | (unsigned char)socksreq[3]),
@@ -524,7 +524,7 @@ CONNECT_REQ_INIT:
     return CURLPX_REQUEST_FAILED;
   case 92:
     failf(data,
-          "Can't complete SOCKS4 connection to %d.%d.%d.%d:%d. (%d)"
+          "cannot complete SOCKS4 connection to %d.%d.%d.%d:%d. (%d)"
           ", request rejected because SOCKS server cannot connect to "
           "identd on the client.",
           socksreq[4], socksreq[5], socksreq[6], socksreq[7],
@@ -533,7 +533,7 @@ CONNECT_REQ_INIT:
     return CURLPX_IDENTD;
   case 93:
     failf(data,
-          "Can't complete SOCKS4 connection to %d.%d.%d.%d:%d. (%d)"
+          "cannot complete SOCKS4 connection to %d.%d.%d.%d:%d. (%d)"
           ", request rejected because the client program and identd "
           "report different user-ids.",
           socksreq[4], socksreq[5], socksreq[6], socksreq[7],
@@ -542,7 +542,7 @@ CONNECT_REQ_INIT:
     return CURLPX_IDENTD_DIFFER;
   default:
     failf(data,
-          "Can't complete SOCKS4 connection to %d.%d.%d.%d:%d. (%d)"
+          "cannot complete SOCKS4 connection to %d.%d.%d.%d:%d. (%d)"
           ", Unknown.",
           socksreq[4], socksreq[5], socksreq[6], socksreq[7],
           (((unsigned char)socksreq[2] << 8) | (unsigned char)socksreq[3]),
@@ -562,7 +562,7 @@ static CURLproxycode do_SOCKS5(struct Curl_cfilter *cf,
                                struct Curl_easy *data)
 {
   /*
-    According to the RFC1928, section "6.  Replies". This is what a SOCK5
+    According to the RFC1928, section "6. Replies". This is what a SOCK5
     replies:
 
         +----+-----+-------+------+----------+----------+
@@ -714,7 +714,7 @@ CONNECT_SOCKS_READ_INIT:
 
 CONNECT_AUTH_INIT:
   case CONNECT_AUTH_INIT: {
-    /* Needs user name and password */
+    /* Needs username and password */
     size_t proxy_user_len, proxy_password_len;
     if(sx->proxy_user && sx->proxy_password) {
       proxy_user_len = strlen(sx->proxy_user);
@@ -738,7 +738,7 @@ CONNECT_AUTH_INIT:
     if(sx->proxy_user && proxy_user_len) {
       /* the length must fit in a single byte */
       if(proxy_user_len > 255) {
-        failf(data, "Excessive user name length for proxy auth");
+        failf(data, "Excessive username length for proxy auth");
         return CURLPX_LONG_USER;
       }
       memcpy(socksreq + len, sx->proxy_user, proxy_user_len);
@@ -990,7 +990,7 @@ CONNECT_REQ_SEND:
     else if(socksreq[1]) { /* Anything besides 0 is an error */
       CURLproxycode rc = CURLPX_REPLY_UNASSIGNED;
       int code = socksreq[1];
-      failf(data, "Can't complete SOCKS5 connection to %s. (%d)",
+      failf(data, "cannot complete SOCKS5 connection to %s. (%d)",
             sx->hostname, (unsigned char)socksreq[1]);
       if(code < 9) {
         /* RFC 1928 section 6 lists: */
@@ -1120,7 +1120,7 @@ static void socks_proxy_cf_free(struct Curl_cfilter *cf)
 }
 
 /* After a TCP connection to the proxy has been verified, this function does
-   the next magic steps. If 'done' isn't set TRUE, it is not done yet and
+   the next magic steps. If 'done' is not set TRUE, it is not done yet and
    must be called again.
 
    Note: this function's sub-functions call failf()
@@ -1249,6 +1249,7 @@ struct Curl_cftype Curl_cft_socks_proxy = {
   socks_proxy_cf_destroy,
   socks_proxy_cf_connect,
   socks_proxy_cf_close,
+  Curl_cf_def_shutdown,
   socks_cf_get_host,
   socks_cf_adjust_pollset,
   Curl_cf_def_data_pending,
diff --git a/lib/socks_gssapi.c b/lib/socks_gssapi.c
index c0b42b871..edcc68326 100644
--- a/lib/socks_gssapi.c
+++ b/lib/socks_gssapi.c
@@ -172,7 +172,7 @@ CURLcode Curl_SOCKS5_gssapi_negotiate(struct Curl_cfilter *cf,
 
   (void)curlx_nonblock(sock, FALSE);
 
-  /* As long as we need to keep sending some context info, and there's no  */
+  /* As long as we need to keep sending some context info, and there is no  */
   /* errors, keep sending it...                                            */
   for(;;) {
     gss_major_status = Curl_gss_init_sec_context(data,
@@ -201,7 +201,7 @@ CURLcode Curl_SOCKS5_gssapi_negotiate(struct Curl_cfilter *cf,
     if(gss_send_token.length) {
       socksreq[0] = 1;    /* GSS-API subnegotiation version */
       socksreq[1] = 1;    /* authentication message type */
-      us_length = htons((short)gss_send_token.length);
+      us_length = htons((unsigned short)gss_send_token.length);
       memcpy(socksreq + 2, &us_length, sizeof(short));
 
       nwritten = Curl_conn_cf_send(cf->next, data, (char *)socksreq, 4, &code);
@@ -306,7 +306,7 @@ CURLcode Curl_SOCKS5_gssapi_negotiate(struct Curl_cfilter *cf,
                    gss_minor_status, "gss_inquire_context")) {
     gss_delete_sec_context(&gss_status, &gss_context, NULL);
     gss_release_name(&gss_status, &gss_client_name);
-    failf(data, "Failed to determine user name.");
+    failf(data, "Failed to determine username.");
     return CURLE_COULDNT_CONNECT;
   }
   gss_major_status = gss_display_name(&gss_minor_status, gss_client_name,
@@ -316,7 +316,7 @@ CURLcode Curl_SOCKS5_gssapi_negotiate(struct Curl_cfilter *cf,
     gss_delete_sec_context(&gss_status, &gss_context, NULL);
     gss_release_name(&gss_status, &gss_client_name);
     gss_release_buffer(&gss_status, &gss_send_token);
-    failf(data, "Failed to determine user name.");
+    failf(data, "Failed to determine username.");
     return CURLE_COULDNT_CONNECT;
   }
   user = malloc(gss_send_token.length + 1);
@@ -377,7 +377,7 @@ CURLcode Curl_SOCKS5_gssapi_negotiate(struct Curl_cfilter *cf,
    *
    * The token is produced by encapsulating an octet containing the
    * required protection level using gss_seal()/gss_wrap() with conf_req
-   * set to FALSE.  The token is verified using gss_unseal()/
+   * set to FALSE. The token is verified using gss_unseal()/
    * gss_unwrap().
    *
    */
@@ -406,7 +406,7 @@ CURLcode Curl_SOCKS5_gssapi_negotiate(struct Curl_cfilter *cf,
     }
     gss_release_buffer(&gss_status, &gss_send_token);
 
-    us_length = htons((short)gss_w_token.length);
+    us_length = htons((unsigned short)gss_w_token.length);
     memcpy(socksreq + 2, &us_length, sizeof(short));
   }
 
diff --git a/lib/socks_sspi.c b/lib/socks_sspi.c
index 2baae2c2b..a83288dd0 100644
--- a/lib/socks_sspi.c
+++ b/lib/socks_sspi.c
@@ -158,7 +158,7 @@ CURLcode Curl_SOCKS5_gssapi_negotiate(struct Curl_cfilter *cf,
 
   (void)curlx_nonblock(sock, FALSE);
 
-  /* As long as we need to keep sending some context info, and there's no  */
+  /* As long as we need to keep sending some context info, and there is no  */
   /* errors, keep sending it...                                            */
   for(;;) {
     TCHAR *sname;
@@ -204,7 +204,7 @@ CURLcode Curl_SOCKS5_gssapi_negotiate(struct Curl_cfilter *cf,
     if(sspi_send_token.cbBuffer) {
       socksreq[0] = 1;    /* GSS-API subnegotiation version */
       socksreq[1] = 1;    /* authentication message type */
-      us_length = htons((short)sspi_send_token.cbBuffer);
+      us_length = htons((unsigned short)sspi_send_token.cbBuffer);
       memcpy(socksreq + 2, &us_length, sizeof(short));
 
       written = Curl_conn_cf_send(cf->next, data, (char *)socksreq, 4, &code);
@@ -328,7 +328,7 @@ CURLcode Curl_SOCKS5_gssapi_negotiate(struct Curl_cfilter *cf,
   if(check_sspi_err(data, status, "QueryCredentialAttributes")) {
     s_pSecFn->DeleteSecurityContext(&sspi_context);
     s_pSecFn->FreeContextBuffer(names.sUserName);
-    failf(data, "Failed to determine user name.");
+    failf(data, "Failed to determine username.");
     return CURLE_COULDNT_CONNECT;
   }
   else {
@@ -383,13 +383,13 @@ CURLcode Curl_SOCKS5_gssapi_negotiate(struct Curl_cfilter *cf,
    *
    * The token is produced by encapsulating an octet containing the
    * required protection level using gss_seal()/gss_wrap() with conf_req
-   * set to FALSE.  The token is verified using gss_unseal()/
+   * set to FALSE. The token is verified using gss_unseal()/
    * gss_unwrap().
    *
    */
 
   if(data->set.socks5_gssapi_nec) {
-    us_length = htons((short)1);
+    us_length = htons((unsigned short)1);
     memcpy(socksreq + 2, &us_length, sizeof(short));
   }
   else {
@@ -472,7 +472,7 @@ CURLcode Curl_SOCKS5_gssapi_negotiate(struct Curl_cfilter *cf,
     sspi_w_token[2].pvBuffer = NULL;
     sspi_w_token[2].cbBuffer = 0;
 
-    us_length = htons((short)sspi_send_token.cbBuffer);
+    us_length = htons((unsigned short)sspi_send_token.cbBuffer);
     memcpy(socksreq + 2, &us_length, sizeof(short));
   }
 
diff --git a/lib/splay.c b/lib/splay.c
index 48e079b32..99bb14997 100644
--- a/lib/splay.c
+++ b/lib/splay.c
@@ -93,7 +93,7 @@ struct Curl_tree *Curl_splay(struct curltime i,
   return t;
 }
 
-/* Insert key i into the tree t.  Return a pointer to the resulting tree or
+/* Insert key i into the tree t. Return a pointer to the resulting tree or
  * NULL if something went wrong.
  *
  * @unittest: 1309
@@ -150,7 +150,7 @@ struct Curl_tree *Curl_splayinsert(struct curltime i,
 }
 
 /* Finds and deletes the best-fit node from the tree. Return a pointer to the
-   resulting tree.  best-fit means the smallest node if it is not larger than
+   resulting tree. best-fit means the smallest node if it is not larger than
    the key */
 struct Curl_tree *Curl_splaygetbest(struct curltime i,
                                     struct Curl_tree *t,
@@ -197,13 +197,13 @@ struct Curl_tree *Curl_splaygetbest(struct curltime i,
 }
 
 
-/* Deletes the very node we point out from the tree if it's there. Stores a
+/* Deletes the very node we point out from the tree if it is there. Stores a
  * pointer to the new resulting tree in 'newroot'.
  *
  * Returns zero on success and non-zero on errors!
  * When returning error, it does not touch the 'newroot' pointer.
  *
- * NOTE: when the last node of the tree is removed, there's no tree left so
+ * NOTE: when the last node of the tree is removed, there is no tree left so
  * 'newroot' will be made to point to NULL.
  *
  * @unittest: 1309
@@ -241,7 +241,7 @@ int Curl_splayremove(struct Curl_tree *t,
 
   /* First make sure that we got the same root node as the one we want
      to remove, as otherwise we might be trying to remove a node that
-     isn't actually in the tree.
+     is not actually in the tree.
 
      We cannot just compare the keys here as a double remove in quick
      succession of a node with key != KEY_NOTUSED && same != NULL
@@ -249,7 +249,7 @@ int Curl_splayremove(struct Curl_tree *t,
   if(t != removenode)
     return 2;
 
-  /* Check if there is a list with identical sizes, as then we're trying to
+  /* Check if there is a list with identical sizes, as then we are trying to
      remove the root node of a list of nodes with identical keys. */
   x = t->samen;
   if(x != t) {
diff --git a/lib/splay.h b/lib/splay.h
index dd1d07ac2..20b2bb69a 100644
--- a/lib/splay.h
+++ b/lib/splay.h
@@ -32,7 +32,7 @@ struct Curl_tree {
   struct Curl_tree *samen;   /* points to the next node with identical key */
   struct Curl_tree *samep;   /* points to the prev node with identical key */
   struct curltime key;        /* this node's "sort" key */
-  void *payload;             /* data the splay code doesn't care about */
+  void *payload;             /* data the splay code does not care about */
 };
 
 struct Curl_tree *Curl_splay(struct curltime i,
diff --git a/lib/strcase.c b/lib/strcase.c
index 14d76f785..b22dd31fc 100644
--- a/lib/strcase.c
+++ b/lib/strcase.c
@@ -93,12 +93,12 @@ static int casecompare(const char *first, const char *second)
 {
   while(*first && *second) {
     if(Curl_raw_toupper(*first) != Curl_raw_toupper(*second))
-      /* get out of the loop as soon as they don't match */
+      /* get out of the loop as soon as they do not match */
       return 0;
     first++;
     second++;
   }
-  /* If we're here either the strings are the same or the length is different.
+  /* If we are here either the strings are the same or the length is different.
      We can just test if the "current" character is non-zero for one and zero
      for the other. Note that the characters may not be exactly the same even
      if they match, we only want to compare zero-ness. */
@@ -141,8 +141,8 @@ int curl_strnequal(const char *first, const char *second, size_t max)
   /* if both pointers are NULL then treat them as equal if max is non-zero */
   return (NULL == first && NULL == second && max);
 }
-/* Copy an upper case version of the string from src to dest.  The
- * strings may overlap.  No more than n characters of the string are copied
+/* Copy an upper case version of the string from src to dest. The
+ * strings may overlap. No more than n characters of the string are copied
  * (including any NUL) and the destination string will NOT be
  * NUL-terminated if that limit is reached.
  */
@@ -156,8 +156,8 @@ void Curl_strntoupper(char *dest, const char *src, size_t n)
   } while(*src++ && --n);
 }
 
-/* Copy a lower case version of the string from src to dest.  The
- * strings may overlap.  No more than n characters of the string are copied
+/* Copy a lower case version of the string from src to dest. The
+ * strings may overlap. No more than n characters of the string are copied
  * (including any NUL) and the destination string will NOT be
  * NUL-terminated if that limit is reached.
  */
diff --git a/lib/strerror.c b/lib/strerror.c
index f142cf181..76a8ba2d7 100644
--- a/lib/strerror.c
+++ b/lib/strerror.c
@@ -74,13 +74,13 @@ curl_easy_strerror(CURLcode error)
       " this libcurl due to a build-time decision.";
 
   case CURLE_COULDNT_RESOLVE_PROXY:
-    return "Couldn't resolve proxy name";
+    return "Could not resolve proxy name";
 
   case CURLE_COULDNT_RESOLVE_HOST:
-    return "Couldn't resolve host name";
+    return "Could not resolve hostname";
 
   case CURLE_COULDNT_CONNECT:
-    return "Couldn't connect to server";
+    return "Could not connect to server";
 
   case CURLE_WEIRD_SERVER_REPLY:
     return "Weird server reply";
@@ -107,19 +107,19 @@ curl_easy_strerror(CURLcode error)
     return "FTP: unknown 227 response format";
 
   case CURLE_FTP_CANT_GET_HOST:
-    return "FTP: can't figure out the host in the PASV response";
+    return "FTP: cannot figure out the host in the PASV response";
 
   case CURLE_HTTP2:
     return "Error in the HTTP2 framing layer";
 
   case CURLE_FTP_COULDNT_SET_TYPE:
-    return "FTP: couldn't set file type";
+    return "FTP: could not set file type";
 
   case CURLE_PARTIAL_FILE:
     return "Transferred a partial file";
 
   case CURLE_FTP_COULDNT_RETR_FILE:
-    return "FTP: couldn't retrieve (RETR failed) the specified file";
+    return "FTP: could not retrieve (RETR failed) the specified file";
 
   case CURLE_QUOTE_ERROR:
     return "Quote command returned error";
@@ -158,10 +158,10 @@ curl_easy_strerror(CURLcode error)
     return "SSL connect error";
 
   case CURLE_BAD_DOWNLOAD_RESUME:
-    return "Couldn't resume download";
+    return "Could not resume download";
 
   case CURLE_FILE_COULDNT_READ_FILE:
-    return "Couldn't read a file:// file";
+    return "Could not read a file:// file";
 
   case CURLE_LDAP_CANNOT_BIND:
     return "LDAP: cannot bind";
@@ -212,7 +212,7 @@ curl_easy_strerror(CURLcode error)
     return "Problem with the local SSL certificate";
 
   case CURLE_SSL_CIPHER:
-    return "Couldn't use specified SSL cipher";
+    return "Could not use specified SSL cipher";
 
   case CURLE_PEER_FAILED_VERIFICATION:
     return "SSL peer certificate or SSH remote key was not OK";
@@ -345,16 +345,15 @@ curl_easy_strerror(CURLcode error)
   /*
    * By using a switch, gcc -Wall will complain about enum values
    * which do not appear, helping keep this function up-to-date.
-   * By using gcc -Wall -Werror, you can't forget.
+   * By using gcc -Wall -Werror, you cannot forget.
    *
-   * A table would not have the same benefit.  Most compilers will
-   * generate code very similar to a table in any case, so there
-   * is little performance gain from a table.  And something is broken
-   * for the user's application, anyways, so does it matter how fast
-   * it _doesn't_ work?
+   * A table would not have the same benefit. Most compilers will generate
+   * code very similar to a table in any case, so there is little performance
+   * gain from a table. Something is broken for the user's application,
+   * anyways, so does it matter how fast it _does not_ work?
    *
-   * The line number for the error will be near this comment, which
-   * is why it is here, and not at the start of the switch.
+   * The line number for the error will be near this comment, which is why it
+   * is here, and not at the start of the switch.
    */
   return "Unknown error";
 #else
@@ -795,7 +794,7 @@ get_winapi_error(int err, char *buf, size_t buflen)
      expect the local codepage (eg fprintf, failf, infof).
      FormatMessageW -> wcstombs is used for Windows CE compatibility. */
   if(FormatMessageW((FORMAT_MESSAGE_FROM_SYSTEM |
-                     FORMAT_MESSAGE_IGNORE_INSERTS), NULL, err,
+                     FORMAT_MESSAGE_IGNORE_INSERTS), NULL, (DWORD)err,
                     LANG_NEUTRAL, wbuf, sizeof(wbuf)/sizeof(wchar_t), NULL)) {
     size_t written = wcstombs(buf, wbuf, buflen - 1);
     if(written != (size_t)-1)
@@ -823,9 +822,9 @@ get_winapi_error(int err, char *buf, size_t buflen)
  * The 'err' argument passed in to this function MUST be a true errno number
  * as reported on this system. We do no range checking on the number before
  * we pass it to the "number-to-message" conversion function and there might
- * be systems that don't do proper range checking in there themselves.
+ * be systems that do not do proper range checking in there themselves.
  *
- * We don't do range checking (on systems other than Windows) since there is
+ * We do not do range checking (on systems other than Windows) since there is
  * no good reliable and portable way to do it.
  *
  * On Windows different types of error codes overlap. This function has an
@@ -865,7 +864,7 @@ const char *Curl_strerror(int err, char *buf, size_t buflen)
 #ifdef USE_WINSOCK
        !get_winsock_error(err, buf, buflen) &&
 #endif
-       !get_winapi_error((DWORD)err, buf, buflen))
+       !get_winapi_error(err, buf, buflen))
       msnprintf(buf, buflen, "Unknown error %d (%#x)", err, err);
   }
 #else /* not Windows coming up */
@@ -944,7 +943,7 @@ const char *Curl_winapi_strerror(DWORD err, char *buf, size_t buflen)
   *buf = '\0';
 
 #ifndef CURL_DISABLE_VERBOSE_STRINGS
-  if(!get_winapi_error(err, buf, buflen)) {
+  if(!get_winapi_error((int)err, buf, buflen)) {
     msnprintf(buf, buflen, "Unknown error %lu (0x%08lX)", err, err);
   }
 #else
diff --git a/lib/strtok.c b/lib/strtok.c
index d8e1e8183..d2cc71c47 100644
--- a/lib/strtok.c
+++ b/lib/strtok.c
@@ -65,4 +65,4 @@ Curl_strtok_r(char *ptr, const char *sep, char **end)
   return NULL;
 }
 
-#endif /* this was only compiled if strtok_r wasn't present */
+#endif /* this was only compiled if strtok_r was not present */
diff --git a/lib/strtoofft.c b/lib/strtoofft.c
index 580fd23bf..8fac230f2 100644
--- a/lib/strtoofft.c
+++ b/lib/strtoofft.c
@@ -31,7 +31,7 @@
  * NOTE:
  *
  * In the ISO C standard (IEEE Std 1003.1), there is a strtoimax() function we
- * could use in case strtoll() doesn't exist...  See
+ * could use in case strtoll() does not exist... See
  * https://www.opengroup.org/onlinepubs/009695399/functions/strtoimax.html
  */
 
@@ -73,7 +73,7 @@ static const char valchars[] =
 static int get_char(char c, int base);
 
 /**
- * Custom version of the strtooff function.  This extracts a curl_off_t
+ * Custom version of the strtooff function. This extracts a curl_off_t
  * value from the given input string and returns it.
  */
 static curl_off_t strtooff(const char *nptr, char **endptr, int base)
@@ -120,8 +120,8 @@ static curl_off_t strtooff(const char *nptr, char **endptr, int base)
     }
   }
 
-  /* Matching strtol, if the base is 0 and it doesn't look like
-   * the number is octal or hex, we assume it's base 10.
+  /* Matching strtol, if the base is 0 and it does not look like
+   * the number is octal or hex, we assume it is base 10.
    */
   if(base == 0) {
     base = 10;
@@ -168,7 +168,7 @@ static curl_off_t strtooff(const char *nptr, char **endptr, int base)
  * @param c     the character to interpret according to base
  * @param base  the base in which to interpret c
  *
- * @return  the value of c in base, or -1 if c isn't in range
+ * @return  the value of c in base, or -1 if c is not in range
  */
 static int get_char(char c, int base)
 {
@@ -204,10 +204,10 @@ static int get_char(char c, int base)
 
   return value;
 }
-#endif  /* Only present if we need strtoll, but don't have it. */
+#endif  /* Only present if we need strtoll, but do not have it. */
 
 /*
- * Parse a *positive* up to 64 bit number written in ascii.
+ * Parse a *positive* up to 64-bit number written in ascii.
  */
 CURLofft curlx_strtoofft(const char *str, char **endp, int base,
                          curl_off_t *num)
@@ -222,7 +222,7 @@ CURLofft curlx_strtoofft(const char *str, char **endp, int base,
     str++;
   if(('-' == *str) || (ISSPACE(*str))) {
     if(endp)
-      *endp = (char *)str; /* didn't actually move */
+      *endp = (char *)str; /* did not actually move */
     return CURL_OFFT_INVAL; /* nothing parsed */
   }
   number = strtooff(str, &end, base);
diff --git a/lib/strtoofft.h b/lib/strtoofft.h
index 34d293ba3..71808b719 100644
--- a/lib/strtoofft.h
+++ b/lib/strtoofft.h
@@ -30,7 +30,7 @@
  * Determine which string to integral data type conversion function we use
  * to implement string conversion to our curl_off_t integral data type.
  *
- * Notice that curl_off_t might be 64 or 32 bit wide, and that it might use
+ * Notice that curl_off_t might be 64 or 32 bits wide, and that it might use
  * an underlying data type which might be 'long', 'int64_t', 'long long' or
  * '__int64' and more remotely other data types.
  *
diff --git a/lib/system_win32.c b/lib/system_win32.c
index d2862de92..4af86699e 100644
--- a/lib/system_win32.c
+++ b/lib/system_win32.c
@@ -68,7 +68,7 @@ CURLcode Curl_win32_init(long flags)
     res = WSAStartup(wVersionRequested, &wsaData);
 
     if(res)
-      /* Tell the user that we couldn't find a usable */
+      /* Tell the user that we could not find a usable */
       /* winsock.dll.     */
       return CURLE_FAILED_INIT;
 
@@ -80,7 +80,7 @@ CURLcode Curl_win32_init(long flags)
 
     if(LOBYTE(wsaData.wVersion) != LOBYTE(wVersionRequested) ||
        HIBYTE(wsaData.wVersion) != HIBYTE(wVersionRequested) ) {
-      /* Tell the user that we couldn't find a usable */
+      /* Tell the user that we could not find a usable */
 
       /* winsock.dll. */
       WSACleanup();
@@ -112,7 +112,11 @@ CURLcode Curl_win32_init(long flags)
   }
 
 #ifdef USE_WINSOCK
+#ifdef CURL_WINDOWS_APP
+  ws2_32Dll = Curl_load_library(TEXT("ws2_32.dll"));
+#else
   ws2_32Dll = GetModuleHandleA("ws2_32");
+#endif
   if(ws2_32Dll) {
     Curl_FreeAddrInfoExW = CURLX_FUNCTION_CAST(FREEADDRINFOEXW_FN,
       GetProcAddress(ws2_32Dll, "FreeAddrInfoExW"));
@@ -208,7 +212,7 @@ HMODULE Curl_load_library(LPCTSTR filename)
   HMODULE hModule = NULL;
   LOADLIBRARYEX_FN pLoadLibraryEx = NULL;
 
-  /* Get a handle to kernel32 so we can access it's functions at runtime */
+  /* Get a handle to kernel32 so we can access it is functions at runtime */
   HMODULE hKernel32 = GetModuleHandle(TEXT("kernel32"));
   if(!hKernel32)
     return NULL;
@@ -219,7 +223,7 @@ HMODULE Curl_load_library(LPCTSTR filename)
     CURLX_FUNCTION_CAST(LOADLIBRARYEX_FN,
                         (GetProcAddress(hKernel32, LOADLIBARYEX)));
 
-  /* Detect if there's already a path in the filename and load the library if
+  /* Detect if there is already a path in the filename and load the library if
      there is. Note: Both back slashes and forward slashes have been supported
      since the earlier days of DOS at an API level although they are not
      supported by command prompt */
@@ -261,10 +265,22 @@ HMODULE Curl_load_library(LPCTSTR filename)
   }
   return hModule;
 #else
-  /* the Universal Windows Platform (UWP) can't do this */
+  /* the Universal Windows Platform (UWP) cannot do this */
   (void)filename;
   return NULL;
 #endif
 }
 
+bool Curl_win32_impersonating(void)
+{
+#ifndef CURL_WINDOWS_APP
+  HANDLE token = NULL;
+  if(OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &token)) {
+    CloseHandle(token);
+    return TRUE;
+  }
+#endif
+  return FALSE;
+}
+
 #endif /* _WIN32 */
diff --git a/lib/system_win32.h b/lib/system_win32.h
index bd490cabc..534a5e498 100644
--- a/lib/system_win32.h
+++ b/lib/system_win32.h
@@ -28,6 +28,8 @@
 
 #ifdef _WIN32
 
+#include <curl/curl.h>
+
 extern LARGE_INTEGER Curl_freq;
 extern bool Curl_isVistaOrGreater;
 extern bool Curl_isWindows8OrGreater;
@@ -68,6 +70,8 @@ extern FREEADDRINFOEXW_FN Curl_FreeAddrInfoExW;
 extern GETADDRINFOEXCANCEL_FN Curl_GetAddrInfoExCancel;
 extern GETADDRINFOEXW_FN Curl_GetAddrInfoExW;
 
+bool Curl_win32_impersonating(void);
+
 /* This is used to dynamically load DLLs */
 HMODULE Curl_load_library(LPCTSTR filename);
 #else  /* _WIN32 */
diff --git a/lib/telnet.c b/lib/telnet.c
index 227a166f2..91fa10ada 100644
--- a/lib/telnet.c
+++ b/lib/telnet.c
@@ -798,12 +798,12 @@ static CURLcode check_telnet_options(struct Curl_easy *data)
   struct TELNET *tn = data->req.p.telnet;
   CURLcode result = CURLE_OK;
 
-  /* Add the user name as an environment variable if it
+  /* Add the username as an environment variable if it
      was given on the command line */
   if(data->state.aptr.user) {
     char buffer[256];
     if(str_is_nonascii(data->conn->user)) {
-      DEBUGF(infof(data, "set a non ASCII user name in telnet"));
+      DEBUGF(infof(data, "set a non ASCII username in telnet"));
       return CURLE_BAD_FUNCTION_ARGUMENT;
     }
     msnprintf(buffer, sizeof(buffer), "USER,%s", data->conn->user);
@@ -1191,12 +1191,12 @@ process_iac:
         if(c != CURL_SE) {
           if(c != CURL_IAC) {
             /*
-             * This is an error.  We only expect to get "IAC IAC" or "IAC SE".
-             * Several things may have happened.  An IAC was not doubled, the
+             * This is an error. We only expect to get "IAC IAC" or "IAC SE".
+             * Several things may have happened. An IAC was not doubled, the
              * IAC SE was left off, or another option got inserted into the
-             * suboption are all possibilities.  If we assume that the IAC was
+             * suboption are all possibilities. If we assume that the IAC was
              * not doubled, and really the IAC SE was left off, we could get
-             * into an infinite loop here.  So, instead, we terminate the
+             * into an infinite loop here. So, instead, we terminate the
              * suboption, and process the partial suboption if we can.
              */
             CURL_SB_ACCUM(tn, CURL_IAC);
@@ -1370,7 +1370,7 @@ static CURLcode telnet_do(struct Curl_easy *data, bool *done)
      else use the old WaitForMultipleObjects() way */
   if(GetFileType(stdin_handle) == FILE_TYPE_PIPE ||
      data->set.is_fread_set) {
-    /* Don't wait for stdin_handle, just wait for event_handle */
+    /* Do not wait for stdin_handle, just wait for event_handle */
     obj_count = 1;
     /* Check stdin_handle per 100 milliseconds */
     wait_timeout = 100;
@@ -1470,7 +1470,7 @@ static CURLcode telnet_do(struct Curl_easy *data, bool *done)
       if(events.lNetworkEvents & FD_READ) {
         /* read data from network */
         result = Curl_xfer_recv(data, buffer, sizeof(buffer), &nread);
-        /* read would've blocked. Loop again */
+        /* read would have blocked. Loop again */
         if(result == CURLE_AGAIN)
           break;
         /* returned not-zero, this an error */
@@ -1492,7 +1492,7 @@ static CURLcode telnet_do(struct Curl_easy *data, bool *done)
         }
 
         /* Negotiate if the peer has started negotiating,
-           otherwise don't. We don't want to speak telnet with
+           otherwise do not. We do not want to speak telnet with
            non-telnet servers, like POP or SMTP. */
         if(tn->please_negotiate && !tn->already_negotiated) {
           negotiate(data);
@@ -1544,7 +1544,7 @@ static CURLcode telnet_do(struct Curl_easy *data, bool *done)
 
   while(keepon) {
     DEBUGF(infof(data, "telnet_do, poll %d fds", poll_cnt));
-    switch(Curl_poll(pfd, poll_cnt, interval_ms)) {
+    switch(Curl_poll(pfd, (unsigned int)poll_cnt, interval_ms)) {
     case -1:                    /* error, stop reading */
       keepon = FALSE;
       continue;
@@ -1556,7 +1556,7 @@ static CURLcode telnet_do(struct Curl_easy *data, bool *done)
       if(pfd[0].revents & POLLIN) {
         /* read data from network */
         result = Curl_xfer_recv(data, buffer, sizeof(buffer), &nread);
-        /* read would've blocked. Loop again */
+        /* read would have blocked. Loop again */
         if(result == CURLE_AGAIN)
           break;
         /* returned not-zero, this an error */
@@ -1588,7 +1588,7 @@ static CURLcode telnet_do(struct Curl_easy *data, bool *done)
         }
 
         /* Negotiate if the peer has started negotiating,
-           otherwise don't. We don't want to speak telnet with
+           otherwise do not. We do not want to speak telnet with
            non-telnet servers, like POP or SMTP. */
         if(tn->please_negotiate && !tn->already_negotiated) {
           negotiate(data);
@@ -1645,7 +1645,7 @@ static CURLcode telnet_do(struct Curl_easy *data, bool *done)
   }
 #endif
   /* mark this as "no further transfer wanted" */
-  Curl_xfer_setup(data, -1, -1, FALSE, -1);
+  Curl_xfer_setup_nop(data);
 
   return result;
 }
diff --git a/lib/tftp.c b/lib/tftp.c
index 310a0faba..c4cc8049d 100644
--- a/lib/tftp.c
+++ b/lib/tftp.c
@@ -245,7 +245,7 @@ static CURLcode tftp_set_timeouts(struct tftp_state_data *state)
         (int)state->state, timeout_ms, state->retry_time, state->retry_max);
 
   /* init RX time */
-  time(&state->rx_time);
+  state->rx_time = time(NULL);
 
   return CURLE_OK;
 }
@@ -315,7 +315,7 @@ static CURLcode tftp_parse_option_ack(struct tftp_state_data *state,
   const char *tmp = ptr;
   struct Curl_easy *data = state->data;
 
-  /* if OACK doesn't contain blksize option, the default (512) must be used */
+  /* if OACK does not contain blksize option, the default (512) must be used */
   state->blksize = TFTP_BLKSIZE_DEFAULT;
 
   while(tmp < ptr + len) {
@@ -349,7 +349,7 @@ static CURLcode tftp_parse_option_ack(struct tftp_state_data *state,
         return CURLE_TFTP_ILLEGAL;
       }
       else if(blksize > state->requested_blksize) {
-        /* could realloc pkt buffers here, but the spec doesn't call out
+        /* could realloc pkt buffers here, but the spec does not call out
          * support for the server requesting a bigger blksize than the client
          * requests */
         failf(data, "%s (%ld)",
@@ -461,7 +461,7 @@ static CURLcode tftp_send_first(struct tftp_state_data *state,
       setpacketevent(&state->spacket, TFTP_EVENT_RRQ);
     }
     /* As RFC3617 describes the separator slash is not actually part of the
-       file name so we skip the always-present first letter of the path
+       filename so we skip the always-present first letter of the path
        string. */
     result = Curl_urldecode(&state->data->state.up.path[1], 0,
                             &filename, NULL, REJECT_ZERO);
@@ -469,9 +469,9 @@ static CURLcode tftp_send_first(struct tftp_state_data *state,
       return result;
 
     if(strlen(filename) > (state->blksize - strlen(mode) - 4)) {
-      failf(data, "TFTP file name too long");
+      failf(data, "TFTP filename too long");
       free(filename);
-      return CURLE_TFTP_ILLEGAL; /* too long file name field */
+      return CURLE_TFTP_ILLEGAL; /* too long filename field */
     }
 
     msnprintf((char *)state->spacket.data + 2,
@@ -528,7 +528,7 @@ static CURLcode tftp_send_first(struct tftp_state_data *state,
     senddata = sendto(state->sockfd, (void *)state->spacket.data,
                       (SEND_TYPE_ARG3)sbytes, 0,
                       &data->conn->remote_addr->sa_addr,
-                      data->conn->remote_addr->addrlen);
+                      (curl_socklen_t)data->conn->remote_addr->addrlen);
     if(senddata != (ssize_t)sbytes) {
       char buffer[STRERROR_LEN];
       failf(data, "%s", Curl_strerror(SOCKERRNO, buffer, sizeof(buffer)));
@@ -590,7 +590,7 @@ static CURLcode tftp_rx(struct tftp_state_data *state,
     /* Is this the block we expect? */
     rblock = getrpacketblock(&state->rpacket);
     if(NEXT_BLOCKNUM(state->block) == rblock) {
-      /* This is the expected block.  Reset counters and ACK it. */
+      /* This is the expected block. Reset counters and ACK it. */
       state->retries = 0;
     }
     else if(state->block == rblock) {
@@ -626,7 +626,7 @@ static CURLcode tftp_rx(struct tftp_state_data *state,
     else {
       state->state = TFTP_STATE_RX;
     }
-    time(&state->rx_time);
+    state->rx_time = time(NULL);
     break;
 
   case TFTP_EVENT_OACK:
@@ -644,16 +644,16 @@ static CURLcode tftp_rx(struct tftp_state_data *state,
       return CURLE_SEND_ERROR;
     }
 
-    /* we're ready to RX data */
+    /* we are ready to RX data */
     state->state = TFTP_STATE_RX;
-    time(&state->rx_time);
+    state->rx_time = time(NULL);
     break;
 
   case TFTP_EVENT_TIMEOUT:
     /* Increment the retry count and fail if over the limit */
     state->retries++;
     infof(data,
-          "Timeout waiting for block %d ACK.  Retries = %d",
+          "Timeout waiting for block %d ACK. Retries = %d",
           NEXT_BLOCKNUM(state->block), state->retries);
     if(state->retries > state->retry_max) {
       state->error = TFTP_ERR_TIMEOUT;
@@ -679,8 +679,8 @@ static CURLcode tftp_rx(struct tftp_state_data *state,
                  4, SEND_4TH_ARG,
                  (struct sockaddr *)&state->remote_addr,
                  state->remote_addrlen);
-    /* don't bother with the return code, but if the socket is still up we
-     * should be a good TFTP client and let the server know we're done */
+    /* do not bother with the return code, but if the socket is still up we
+     * should be a good TFTP client and let the server know we are done */
     state->state = TFTP_STATE_FIN;
     break;
 
@@ -719,13 +719,13 @@ static CURLcode tftp_tx(struct tftp_state_data *state, tftp_event_t event)
       int rblock = getrpacketblock(&state->rpacket);
 
       if(rblock != state->block &&
-         /* There's a bug in tftpd-hpa that causes it to send us an ack for
-          * 65535 when the block number wraps to 0. So when we're expecting
+         /* There is a bug in tftpd-hpa that causes it to send us an ack for
+          * 65535 when the block number wraps to 0. So when we are expecting
           * 0, also accept 65535. See
           * https://www.syslinux.org/archives/2010-September/015612.html
           * */
          !(state->block == 0 && rblock == 65535)) {
-        /* This isn't the expected block.  Log it and up the retry counter */
+        /* This is not the expected block. Log it and up the retry counter */
         infof(data, "Received ACK for block %d, expecting %d",
               rblock, state->block);
         state->retries++;
@@ -738,7 +738,7 @@ static CURLcode tftp_tx(struct tftp_state_data *state, tftp_event_t event)
         else {
           /* Re-send the data packet */
           sbytes = sendto(state->sockfd, (void *)state->spacket.data,
-                          4 + state->sbytes, SEND_4TH_ARG,
+                          4 + (SEND_TYPE_ARG3)state->sbytes, SEND_4TH_ARG,
                           (struct sockaddr *)&state->remote_addr,
                           state->remote_addrlen);
           /* Check all sbytes were sent */
@@ -751,9 +751,9 @@ static CURLcode tftp_tx(struct tftp_state_data *state, tftp_event_t event)
 
         return result;
       }
-      /* This is the expected packet.  Reset the counters and send the next
+      /* This is the expected packet. Reset the counters and send the next
          block */
-      time(&state->rx_time);
+      state->rx_time = time(NULL);
       state->block++;
     }
     else
@@ -783,7 +783,7 @@ static CURLcode tftp_tx(struct tftp_state_data *state, tftp_event_t event)
     } while(state->sbytes < state->blksize && cb);
 
     sbytes = sendto(state->sockfd, (void *) state->spacket.data,
-                    4 + state->sbytes, SEND_4TH_ARG,
+                    4 + (SEND_TYPE_ARG3)state->sbytes, SEND_4TH_ARG,
                     (struct sockaddr *)&state->remote_addr,
                     state->remote_addrlen);
     /* Check all sbytes were sent */
@@ -801,7 +801,7 @@ static CURLcode tftp_tx(struct tftp_state_data *state, tftp_event_t event)
     state->retries++;
     infof(data, "Timeout waiting for block %d ACK. "
           " Retries = %d", NEXT_BLOCKNUM(state->block), state->retries);
-    /* Decide if we've had enough */
+    /* Decide if we have had enough */
     if(state->retries > state->retry_max) {
       state->error = TFTP_ERR_TIMEOUT;
       state->state = TFTP_STATE_FIN;
@@ -809,7 +809,7 @@ static CURLcode tftp_tx(struct tftp_state_data *state, tftp_event_t event)
     else {
       /* Re-send the data packet */
       sbytes = sendto(state->sockfd, (void *)state->spacket.data,
-                      4 + state->sbytes, SEND_4TH_ARG,
+                      4 + (SEND_TYPE_ARG3)state->sbytes, SEND_4TH_ARG,
                       (struct sockaddr *)&state->remote_addr,
                       state->remote_addrlen);
       /* Check all sbytes were sent */
@@ -829,8 +829,8 @@ static CURLcode tftp_tx(struct tftp_state_data *state, tftp_event_t event)
     (void)sendto(state->sockfd, (void *)state->spacket.data, 4, SEND_4TH_ARG,
                  (struct sockaddr *)&state->remote_addr,
                  state->remote_addrlen);
-    /* don't bother with the return code, but if the socket is still up we
-     * should be a good TFTP client and let the server know we're done */
+    /* do not bother with the return code, but if the socket is still up we
+     * should be a good TFTP client and let the server know we are done */
     state->state = TFTP_STATE_FIN;
     break;
 
@@ -1001,7 +1001,7 @@ static CURLcode tftp_connect(struct Curl_easy *data, bool *done)
       return CURLE_OUT_OF_MEMORY;
   }
 
-  /* we don't keep TFTP connections up basically because there's none or very
+  /* we do not keep TFTP connections up basically because there is none or very
    * little gain for UDP */
   connclose(conn, "TFTP");
 
@@ -1032,7 +1032,7 @@ static CURLcode tftp_connect(struct Curl_easy *data, bool *done)
      * IPv4 and IPv6...
      */
     int rc = bind(state->sockfd, (struct sockaddr *)&state->local_addr,
-                  conn->remote_addr->addrlen);
+                  (curl_socklen_t)conn->remote_addr->addrlen);
     if(rc) {
       char buffer[STRERROR_LEN];
       failf(data, "bind() failed; %s",
@@ -1110,7 +1110,7 @@ static CURLcode tftp_receive_packet(struct Curl_easy *data)
   fromlen = sizeof(fromaddr);
   state->rbytes = (int)recvfrom(state->sockfd,
                                 (void *)state->rpacket.data,
-                                state->blksize + 4,
+                                (RECV_TYPE_ARG3)state->blksize + 4,
                                 0,
                                 (struct sockaddr *)&fromaddr,
                                 &fromlen);
@@ -1132,7 +1132,7 @@ static CURLcode tftp_receive_packet(struct Curl_easy *data)
 
     switch(state->event) {
     case TFTP_EVENT_DATA:
-      /* Don't pass to the client empty or retransmitted packets */
+      /* Do not pass to the client empty or retransmitted packets */
       if(state->rbytes > 4 &&
          (NEXT_BLOCKNUM(state->block) == getrpacketblock(&state->rpacket))) {
         result = Curl_client_write(data, CLIENTWRITE_BODY,
@@ -1208,7 +1208,7 @@ static timediff_t tftp_state_timeout(struct Curl_easy *data,
   if(current > state->rx_time + state->retry_time) {
     if(event)
       *event = TFTP_EVENT_TIMEOUT;
-    time(&state->rx_time); /* update even though we received nothing */
+    state->rx_time = time(NULL); /* update even though we received nothing */
   }
 
   return timeout_ms;
@@ -1241,8 +1241,8 @@ static CURLcode tftp_multi_statemach(struct Curl_easy *data, bool *done)
       return result;
     *done = (state->state == TFTP_STATE_FIN) ? TRUE : FALSE;
     if(*done)
-      /* Tell curl we're done */
-      Curl_xfer_setup(data, -1, -1, FALSE, -1);
+      /* Tell curl we are done */
+      Curl_xfer_setup_nop(data);
   }
   else {
     /* no timeouts to handle, check our socket */
@@ -1264,8 +1264,8 @@ static CURLcode tftp_multi_statemach(struct Curl_easy *data, bool *done)
         return result;
       *done = (state->state == TFTP_STATE_FIN) ? TRUE : FALSE;
       if(*done)
-        /* Tell curl we're done */
-        Curl_xfer_setup(data, -1, -1, FALSE, -1);
+        /* Tell curl we are done */
+        Curl_xfer_setup_nop(data);
     }
     /* if rc == 0, then select() timed out */
   }
@@ -1289,7 +1289,7 @@ static CURLcode tftp_doing(struct Curl_easy *data, bool *dophase_done)
     DEBUGF(infof(data, "DO phase is complete"));
   }
   else if(!result) {
-    /* The multi code doesn't have this logic for the DOING state so we
+    /* The multi code does not have this logic for the DOING state so we
        provide it for TFTP since it may do the entire transfer in this
        state. */
     if(Curl_pgrsUpdate(data))
@@ -1376,7 +1376,7 @@ static CURLcode tftp_setup_connection(struct Curl_easy *data,
   conn->transport = TRNSPRT_UDP;
 
   /* TFTP URLs support an extension like ";mode=<typecode>" that
-   * we'll try to get now! */
+   * we will try to get now! */
   type = strstr(data->state.up.path, ";mode=");
 
   if(!type)
diff --git a/lib/timediff.h b/lib/timediff.h
index fb318d4f2..1ffa59e77 100644
--- a/lib/timediff.h
+++ b/lib/timediff.h
@@ -26,7 +26,7 @@
 
 #include "curl_setup.h"
 
-/* Use a larger type even for 32 bit time_t systems so that we can keep
+/* Use a larger type even for 32-bit time_t systems so that we can keep
    microsecond accuracy in it */
 typedef curl_off_t timediff_t;
 #define CURL_FORMAT_TIMEDIFF_T CURL_FORMAT_CURL_OFF_T
diff --git a/lib/timeval.c b/lib/timeval.c
index 5a6727cbc..10dbaf02c 100644
--- a/lib/timeval.c
+++ b/lib/timeval.c
@@ -51,8 +51,8 @@ struct curltime Curl_now(void)
 #pragma warning(pop)
 #endif
 
-    now.tv_sec = milliseconds / 1000;
-    now.tv_usec = (milliseconds % 1000) * 1000;
+    now.tv_sec = (time_t)(milliseconds / 1000);
+    now.tv_usec = (int)((milliseconds % 1000) * 1000);
   }
   return now;
 }
@@ -77,7 +77,7 @@ struct curltime Curl_now(void)
 
   /*
   ** clock_gettime() may be defined by Apple's SDK as weak symbol thus
-  ** code compiles but fails during run-time if clock_gettime() is
+  ** code compiles but fails during runtime if clock_gettime() is
   ** called on unsupported OS version.
   */
 #if defined(__APPLE__) && defined(HAVE_BUILTIN_AVAILABLE) && \
@@ -95,7 +95,7 @@ struct curltime Curl_now(void)
 #endif
     (0 == clock_gettime(CLOCK_MONOTONIC_RAW, &tsnow))) {
     cnow.tv_sec = tsnow.tv_sec;
-    cnow.tv_usec = (unsigned int)(tsnow.tv_nsec / 1000);
+    cnow.tv_usec = (int)(tsnow.tv_nsec / 1000);
   }
   else
 #endif
@@ -107,18 +107,18 @@ struct curltime Curl_now(void)
 #endif
     (0 == clock_gettime(CLOCK_MONOTONIC, &tsnow))) {
     cnow.tv_sec = tsnow.tv_sec;
-    cnow.tv_usec = (unsigned int)(tsnow.tv_nsec / 1000);
+    cnow.tv_usec = (int)(tsnow.tv_nsec / 1000);
   }
   /*
   ** Even when the configure process has truly detected monotonic clock
   ** availability, it might happen that it is not actually available at
-  ** run-time. When this occurs simply fallback to other time source.
+  ** runtime. When this occurs simply fallback to other time source.
   */
 #ifdef HAVE_GETTIMEOFDAY
   else {
     (void)gettimeofday(&now, NULL);
     cnow.tv_sec = now.tv_sec;
-    cnow.tv_usec = (unsigned int)now.tv_usec;
+    cnow.tv_usec = (int)now.tv_usec;
   }
 #else
   else {
diff --git a/lib/transfer.c b/lib/transfer.c
index 744227eb3..6c95a4719 100644
--- a/lib/transfer.c
+++ b/lib/transfer.c
@@ -53,7 +53,7 @@
 #endif
 
 #ifndef HAVE_SOCKET
-#error "We can't compile without socket() support!"
+#error "We cannot compile without socket() support!"
 #endif
 
 #include "urldata.h"
@@ -160,6 +160,30 @@ bool Curl_meets_timecondition(struct Curl_easy *data, time_t timeofdoc)
   return TRUE;
 }
 
+static CURLcode xfer_recv_shutdown(struct Curl_easy *data, bool *done)
+{
+  int sockindex;
+
+  if(!data || !data->conn)
+    return CURLE_FAILED_INIT;
+  if(data->conn->sockfd == CURL_SOCKET_BAD)
+    return CURLE_FAILED_INIT;
+  sockindex = (data->conn->sockfd == data->conn->sock[SECONDARYSOCKET]);
+  return Curl_conn_shutdown(data, sockindex, done);
+}
+
+static bool xfer_recv_shutdown_started(struct Curl_easy *data)
+{
+  int sockindex;
+
+  if(!data || !data->conn)
+    return CURLE_FAILED_INIT;
+  if(data->conn->sockfd == CURL_SOCKET_BAD)
+    return CURLE_FAILED_INIT;
+  sockindex = (data->conn->sockfd == data->conn->sock[SECONDARYSOCKET]);
+  return Curl_shutdown_started(data, sockindex);
+}
+
 /**
  * Receive raw response data for the transfer.
  * @param data         the transfer
@@ -186,17 +210,35 @@ static ssize_t Curl_xfer_recv_resp(struct Curl_easy *data,
     else if(totalleft < (curl_off_t)blen)
       blen = (size_t)totalleft;
   }
+  else if(xfer_recv_shutdown_started(data)) {
+    /* we already reveived everything. Do not try more. */
+    blen = 0;
+  }
 
   if(!blen) {
-    /* want nothing - continue as if read nothing. */
-    DEBUGF(infof(data, "readwrite_data: we're done"));
+    /* want nothing more */
     *err = CURLE_OK;
-    return 0;
+    nread = 0;
+  }
+  else {
+    *err = Curl_xfer_recv(data, buf, blen, &nread);
   }
 
-  *err = Curl_xfer_recv(data, buf, blen, &nread);
   if(*err)
     return -1;
+  if(nread == 0) {
+    if(data->req.shutdown) {
+      bool done;
+      *err = xfer_recv_shutdown(data, &done);
+      if(*err)
+        return -1;
+      if(!done) {
+        *err = CURLE_AGAIN;
+        return -1;
+      }
+    }
+    DEBUGF(infof(data, "readwrite_data: we are done"));
+  }
   DEBUGASSERT(nread >= 0);
   return nread;
 }
@@ -239,13 +281,13 @@ static CURLcode readwrite_data(struct Curl_easy *data,
     buf = xfer_buf;
     bytestoread = xfer_blen;
 
-    if(bytestoread && data->set.max_recv_speed) {
+    if(bytestoread && data->set.max_recv_speed > 0) {
       /* In case of speed limit on receiving: if this loop already got
        * data, break out. If not, limit the amount of bytes to receive.
        * The overall, timed, speed limiting is done in multi.c */
       if(total_received)
         break;
-      if((size_t)data->set.max_recv_speed < bytestoread)
+      if(data->set.max_recv_speed < (curl_off_t)bytestoread)
         bytestoread = (size_t)data->set.max_recv_speed;
     }
 
@@ -271,7 +313,10 @@ static CURLcode readwrite_data(struct Curl_easy *data,
         DEBUGF(infof(data, "nread == 0, stream closed, bailing"));
       else
         DEBUGF(infof(data, "nread <= 0, server closed connection, bailing"));
-      k->keepon &= ~(KEEP_RECV|KEEP_SEND); /* stop sending as well */
+      /* stop receiving and ALL sending as well, including PAUSE and HOLD.
+       * We might still be paused on receive client writes though, so
+       * keep those bits around. */
+      k->keepon &= ~(KEEP_RECV|KEEP_SENDBITS);
       if(k->eos_written) /* already did write this to client, leave */
         break;
     }
@@ -291,10 +336,11 @@ static CURLcode readwrite_data(struct Curl_easy *data,
     if((k->keepon & KEEP_RECV_PAUSE) || !(k->keepon & KEEP_RECV))
       break;
 
-  } while(maxloops-- && data_pending(data));
+  } while(maxloops--);
 
-  if(maxloops <= 0) {
-    /* did not read until EAGAIN, mark read-again-please */
+  if((maxloops <= 0) || data_pending(data)) {
+    /* did not read until EAGAIN or there is still pending data, mark as
+       read-again-please */
     data->state.select_bits = CURL_CSELECT_IN;
     if((k->keepon & KEEP_SENDBITS) == KEEP_SEND)
       data->state.select_bits |= CURL_CSELECT_OUT;
@@ -302,8 +348,8 @@ static CURLcode readwrite_data(struct Curl_easy *data,
 
   if(((k->keepon & (KEEP_RECV|KEEP_SEND)) == KEEP_SEND) &&
      (conn->bits.close || is_multiplex)) {
-    /* When we've read the entire thing and the close bit is set, the server
-       may now close the connection. If there's now any kind of sending going
+    /* When we have read the entire thing and the close bit is set, the server
+       may now close the connection. If there is now any kind of sending going
        on from our side, we need to stop that immediately. */
     infof(data, "we are done reading and this is set to close, stop send");
     k->keepon &= ~KEEP_SEND; /* no writing anymore either */
@@ -317,37 +363,11 @@ out:
   return result;
 }
 
-#if defined(_WIN32) && defined(USE_WINSOCK)
-#ifndef SIO_IDEAL_SEND_BACKLOG_QUERY
-#define SIO_IDEAL_SEND_BACKLOG_QUERY 0x4004747B
-#endif
-
-static void win_update_buffer_size(curl_socket_t sockfd)
-{
-  int result;
-  ULONG ideal;
-  DWORD ideallen;
-  result = WSAIoctl(sockfd, SIO_IDEAL_SEND_BACKLOG_QUERY, 0, 0,
-                    &ideal, sizeof(ideal), &ideallen, 0, 0);
-  if(result == 0) {
-    setsockopt(sockfd, SOL_SOCKET, SO_SNDBUF,
-               (const char *)&ideal, sizeof(ideal));
-  }
-}
-#else
-#define win_update_buffer_size(x)
-#endif
-
-#define curl_upload_refill_watermark(data) \
-        ((size_t)((data)->set.upload_buffer_size >> 5))
-
 /*
  * Send data to upload to the server, when the socket is writable.
  */
 static CURLcode readwrite_upload(struct Curl_easy *data, int *didwhat)
 {
-  CURLcode result = CURLE_OK;
-
   if((data->req.keepon & KEEP_SEND_PAUSE))
     return CURLE_OK;
 
@@ -358,23 +378,9 @@ static CURLcode readwrite_upload(struct Curl_easy *data, int *didwhat)
 
   if(!Curl_req_done_sending(data)) {
     *didwhat |= KEEP_SEND;
-    result = Curl_req_send_more(data);
-    if(result)
-      return result;
-
-#if defined(_WIN32) && defined(USE_WINSOCK)
-    /* FIXME: this looks like it would fit better into cf-socket.c
-     * but then I do not know enough Windows to say... */
-    {
-      struct curltime n = Curl_now();
-      if(Curl_timediff(n, data->conn->last_sndbuf_update) > 1000) {
-        win_update_buffer_size(data->conn->writesockfd);
-        data->conn->last_sndbuf_update = n;
-      }
-    }
-#endif
+    return Curl_req_send_more(data);
   }
-  return result;
+  return CURLE_OK;
 }
 
 static int select_bits_paused(struct Curl_easy *data, int select_bits)
@@ -408,14 +414,6 @@ CURLcode Curl_readwrite(struct Curl_easy *data)
   int didwhat = 0;
   int select_bits;
 
-  /* Check if client writes had been paused and can resume now. */
-  if(!(k->keepon & KEEP_RECV_PAUSE) && Curl_cwriter_is_paused(data)) {
-    Curl_conn_ev_data_pause(data, FALSE);
-    result = Curl_cwriter_unpause(data);
-    if(result)
-      goto out;
-  }
-
   if(data->state.select_bits) {
     if(select_bits_paused(data, data->state.select_bits)) {
       /* leave the bits unchanged, so they'll tell us what to do when
@@ -522,9 +520,9 @@ CURLcode Curl_readwrite(struct Curl_easy *data)
     if(!(data->req.no_body) && (k->size != -1) &&
        (k->bytecount != k->size) &&
 #ifdef CURL_DO_LINEEND_CONV
-       /* Most FTP servers don't adjust their file SIZE response for CRLFs,
-          so we'll check to see if the discrepancy can be explained
-          by the number of CRLFs we've changed to LFs.
+       /* Most FTP servers do not adjust their file SIZE response for CRLFs,
+          so we will check to see if the discrepancy can be explained
+          by the number of CRLFs we have changed to LFs.
        */
        (k->bytecount != (k->size + data->state.crlf_conversions)) &&
 #endif /* CURL_DO_LINEEND_CONV */
@@ -569,7 +567,7 @@ CURLcode Curl_pretransfer(struct Curl_easy *data)
   CURLcode result;
 
   if(!data->state.url && !data->set.uh) {
-    /* we can't do anything without URL */
+    /* we cannot do anything without URL */
     failf(data, "No URL set");
     return CURLE_URL_MALFORMAT;
   }
@@ -593,7 +591,7 @@ CURLcode Curl_pretransfer(struct Curl_easy *data)
   }
 
   if(data->set.postfields && data->set.set_resume_from) {
-    /* we can't */
+    /* we cannot */
     failf(data, "cannot mix POSTFIELDS with RESUME_FROM");
     return CURLE_BAD_FUNCTION_ARGUMENT;
   }
@@ -695,7 +693,7 @@ CURLcode Curl_pretransfer(struct Curl_easy *data)
 
   /*
    * Set user-agent. Used for HTTP, but since we can attempt to tunnel
-   * basically anything through an HTTP proxy we can't limit this based on
+   * basically anything through an HTTP proxy we cannot limit this based on
    * protocol.
    */
   if(data->set.str[STRING_USERAGENT]) {
@@ -726,22 +724,6 @@ CURLcode Curl_pretransfer(struct Curl_easy *data)
   return result;
 }
 
-/*
- * Curl_posttransfer() is called immediately after a transfer ends
- */
-CURLcode Curl_posttransfer(struct Curl_easy *data)
-{
-#if defined(HAVE_SIGNAL) && defined(SIGPIPE) && !defined(HAVE_MSG_NOSIGNAL)
-  /* restore the signal handler for SIGPIPE before we get back */
-  if(!data->set.no_signal)
-    signal(SIGPIPE, data->state.prev_signal);
-#else
-  (void)data; /* unused parameter */
-#endif
-
-  return CURLE_OK;
-}
-
 /*
  * Curl_follow() handles the URL redirect magic. Pass in the 'newurl' string
  * as given by the remote server and set up the new URL to request.
@@ -823,16 +805,16 @@ CURLcode Curl_follow(struct Curl_easy *data,
      (data->req.httpcode != 401) && (data->req.httpcode != 407) &&
      Curl_is_absolute_url(newurl, NULL, 0, FALSE)) {
     /* If this is not redirect due to a 401 or 407 response and an absolute
-       URL: don't allow a custom port number */
+       URL: do not allow a custom port number */
     disallowport = TRUE;
   }
 
   DEBUGASSERT(data->state.uh);
-  uc = curl_url_set(data->state.uh, CURLUPART_URL, newurl,
-                    (type == FOLLOW_FAKE) ? CURLU_NON_SUPPORT_SCHEME :
-                    ((type == FOLLOW_REDIR) ? CURLU_URLENCODE : 0) |
-                    CURLU_ALLOW_SPACE |
-                    (data->set.path_as_is ? CURLU_PATH_AS_IS : 0));
+  uc = curl_url_set(data->state.uh, CURLUPART_URL, newurl, (unsigned int)
+                    ((type == FOLLOW_FAKE) ? CURLU_NON_SUPPORT_SCHEME :
+                     ((type == FOLLOW_REDIR) ? CURLU_URLENCODE : 0) |
+                     CURLU_ALLOW_SPACE |
+                     (data->set.path_as_is ? CURLU_PATH_AS_IS : 0)));
   if(uc) {
     if(type != FOLLOW_FAKE) {
       failf(data, "The redirect target URL could not be parsed: %s",
@@ -901,8 +883,8 @@ CURLcode Curl_follow(struct Curl_easy *data,
   }
 
   if(type == FOLLOW_FAKE) {
-    /* we're only figuring out the new url if we would've followed locations
-       but now we're done so we can get out! */
+    /* we are only figuring out the new URL if we would have followed locations
+       but now we are done so we can get out! */
     data->info.wouldredirect = newurl;
 
     if(reachedmax) {
@@ -939,15 +921,15 @@ CURLcode Curl_follow(struct Curl_easy *data,
     /* 306 - Not used */
     /* 307 - Temporary Redirect */
   default:  /* for all above (and the unknown ones) */
-    /* Some codes are explicitly mentioned since I've checked RFC2616 and they
-     * seem to be OK to POST to.
+    /* Some codes are explicitly mentioned since I have checked RFC2616 and
+     * they seem to be OK to POST to.
      */
     break;
   case 301: /* Moved Permanently */
     /* (quote from RFC7231, section 6.4.2)
      *
      * Note: For historical reasons, a user agent MAY change the request
-     * method from POST to GET for the subsequent request.  If this
+     * method from POST to GET for the subsequent request. If this
      * behavior is undesired, the 307 (Temporary Redirect) status code
      * can be used instead.
      *
@@ -973,7 +955,7 @@ CURLcode Curl_follow(struct Curl_easy *data,
     /* (quote from RFC7231, section 6.4.3)
      *
      * Note: For historical reasons, a user agent MAY change the request
-     * method from POST to GET for the subsequent request.  If this
+     * method from POST to GET for the subsequent request. If this
      * behavior is undesired, the 307 (Temporary Redirect) status code
      * can be used instead.
      *
@@ -1014,14 +996,14 @@ CURLcode Curl_follow(struct Curl_easy *data,
     break;
   case 304: /* Not Modified */
     /* 304 means we did a conditional request and it was "Not modified".
-     * We shouldn't get any Location: header in this response!
+     * We should not get any Location: header in this response!
      */
     break;
   case 305: /* Use Proxy */
     /* (quote from RFC2616, section 10.3.6):
      * "The requested resource MUST be accessed through the proxy given
      * by the Location field. The Location field gives the URI of the
-     * proxy.  The recipient is expected to repeat this single request
+     * proxy. The recipient is expected to repeat this single request
      * via the proxy. 305 responses MUST only be generated by origin
      * servers."
      */
@@ -1043,8 +1025,9 @@ CURLcode Curl_retry_request(struct Curl_easy *data, char **url)
   bool retry = FALSE;
   *url = NULL;
 
-  /* if we're talking upload, we can't do the checks below, unless the protocol
-     is HTTP as when uploading over HTTP we will still get a response */
+  /* if we are talking upload, we cannot do the checks below, unless the
+     protocol is HTTP as when uploading over HTTP we will still get a
+     response */
   if(data->state.upload &&
      !(conn->handler->protocol&(PROTO_FAMILY_HTTP|CURLPROTO_RTSP)))
     return CURLE_OK;
@@ -1090,7 +1073,7 @@ CURLcode Curl_retry_request(struct Curl_easy *data, char **url)
       return CURLE_OUT_OF_MEMORY;
 
     connclose(conn, "retry"); /* close this connection */
-    conn->bits.retry = TRUE; /* mark this as a connection we're about
+    conn->bits.retry = TRUE; /* mark this as a connection we are about
                                 to retry. Marking it this way should
                                 prevent i.e HTTP transfers to return
                                 error just because nothing has been
@@ -1101,16 +1084,17 @@ CURLcode Curl_retry_request(struct Curl_easy *data, char **url)
 }
 
 /*
- * Curl_xfer_setup() is called to setup some basic properties for the
- * upcoming transfer.
+ * xfer_setup() is called to setup basic properties for the transfer.
  */
-void Curl_xfer_setup(
+static void xfer_setup(
   struct Curl_easy *data,   /* transfer */
   int sockindex,            /* socket index to read from or -1 */
   curl_off_t size,          /* -1 if unknown at this point */
   bool getheader,           /* TRUE if header parsing is wanted */
-  int writesockindex        /* socket index to write to, it may very well be
+  int writesockindex,       /* socket index to write to, it may very well be
                                the same we read from. -1 disables */
+  bool shutdown             /* shutdown connection at transfer end. Only
+                             * supported when sending OR receiving. */
   )
 {
   struct SingleRequest *k = &data->req;
@@ -1120,6 +1104,7 @@ void Curl_xfer_setup(
   DEBUGASSERT(conn != NULL);
   DEBUGASSERT((sockindex <= 1) && (sockindex >= -1));
   DEBUGASSERT((writesockindex <= 1) && (writesockindex >= -1));
+  DEBUGASSERT(!shutdown || (sockindex == -1) || (writesockindex == -1));
 
   if(conn->bits.multiplex || conn->httpversion >= 20 || want_send) {
     /* when multiplexing, the read/write sockets need to be the same! */
@@ -1137,9 +1122,10 @@ void Curl_xfer_setup(
     conn->writesockfd = writesockindex == -1 ?
       CURL_SOCKET_BAD:conn->sock[writesockindex];
   }
-  k->getheader = getheader;
 
+  k->getheader = getheader;
   k->size = size;
+  k->shutdown = shutdown;
 
   /* The code sequence below is placed in this function just because all
      necessary input is not always known in do_complete() as this function may
@@ -1150,7 +1136,7 @@ void Curl_xfer_setup(
     if(size > 0)
       Curl_pgrsSetDownloadSize(data, size);
   }
-  /* we want header and/or body, if neither then don't do this! */
+  /* we want header and/or body, if neither then do not do this! */
   if(k->getheader || !data->req.no_body) {
 
     if(sockindex != -1)
@@ -1162,6 +1148,33 @@ void Curl_xfer_setup(
 
 }
 
+void Curl_xfer_setup_nop(struct Curl_easy *data)
+{
+  xfer_setup(data, -1, -1, FALSE, -1, FALSE);
+}
+
+void Curl_xfer_setup1(struct Curl_easy *data,
+                      int send_recv,
+                      curl_off_t recv_size,
+                      bool getheader)
+{
+  int recv_index = (send_recv & CURL_XFER_RECV)? FIRSTSOCKET : -1;
+  int send_index = (send_recv & CURL_XFER_SEND)? FIRSTSOCKET : -1;
+  DEBUGASSERT((recv_index >= 0) || (recv_size == -1));
+  xfer_setup(data, recv_index, recv_size, getheader, send_index, FALSE);
+}
+
+void Curl_xfer_setup2(struct Curl_easy *data,
+                      int send_recv,
+                      curl_off_t recv_size,
+                      bool shutdown)
+{
+  int recv_index = (send_recv & CURL_XFER_RECV)? SECONDARYSOCKET : -1;
+  int send_index = (send_recv & CURL_XFER_SEND)? SECONDARYSOCKET : -1;
+  DEBUGASSERT((recv_index >= 0) || (recv_size == -1));
+  xfer_setup(data, recv_index, recv_size, FALSE, send_index, shutdown);
+}
+
 CURLcode Curl_xfer_write_resp(struct Curl_easy *data,
                               const char *buf, size_t blen,
                               bool is_eos)
@@ -1276,3 +1289,27 @@ CURLcode Curl_xfer_send_close(struct Curl_easy *data)
   Curl_conn_ev_data_done_send(data);
   return CURLE_OK;
 }
+
+CURLcode Curl_xfer_send_shutdown(struct Curl_easy *data, bool *done)
+{
+  int sockindex;
+
+  if(!data || !data->conn)
+    return CURLE_FAILED_INIT;
+  if(data->conn->writesockfd == CURL_SOCKET_BAD)
+    return CURLE_FAILED_INIT;
+  sockindex = (data->conn->writesockfd == data->conn->sock[SECONDARYSOCKET]);
+  return Curl_conn_shutdown(data, sockindex, done);
+}
+
+bool Curl_xfer_is_blocked(struct Curl_easy *data)
+{
+  bool want_send = ((data)->req.keepon & KEEP_SEND);
+  bool want_recv = ((data)->req.keepon & KEEP_RECV);
+  if(!want_send)
+    return (want_recv && Curl_cwriter_is_paused(data));
+  else if(!want_recv)
+    return (want_send && Curl_creader_is_paused(data));
+  else
+    return Curl_creader_is_paused(data) && Curl_cwriter_is_paused(data);
+}
diff --git a/lib/transfer.h b/lib/transfer.h
index ad0f3a20c..21ad25962 100644
--- a/lib/transfer.h
+++ b/lib/transfer.h
@@ -32,7 +32,6 @@ char *Curl_checkheaders(const struct Curl_easy *data,
 void Curl_init_CONNECT(struct Curl_easy *data);
 
 CURLcode Curl_pretransfer(struct Curl_easy *data);
-CURLcode Curl_posttransfer(struct Curl_easy *data);
 
 typedef enum {
   FOLLOW_NONE,  /* not used within the function, just a placeholder to
@@ -76,15 +75,37 @@ CURLcode Curl_xfer_write_resp(struct Curl_easy *data,
 CURLcode Curl_xfer_write_resp_hd(struct Curl_easy *data,
                                  const char *hd0, size_t hdlen, bool is_eos);
 
-/* This sets up a forthcoming transfer */
-void Curl_xfer_setup(struct Curl_easy *data,
-                     int sockindex,     /* socket index to read from or -1 */
-                     curl_off_t size,   /* -1 if unknown at this point */
-                     bool getheader,    /* TRUE if header parsing is wanted */
-                     int writesockindex /* socket index to write to. May be
-                                           the same we read from. -1
-                                           disables */
-  );
+#define CURL_XFER_NOP     (0)
+#define CURL_XFER_RECV    (1<<(0))
+#define CURL_XFER_SEND    (1<<(1))
+#define CURL_XFER_SENDRECV (CURL_XFER_RECV|CURL_XFER_SEND)
+
+/**
+ * The transfer is neither receiving nor sending now.
+ */
+void Curl_xfer_setup_nop(struct Curl_easy *data);
+
+/**
+ * The transfer will use socket 1 to send/recv. `recv_size` is
+ * the amount to receive or -1 if unknown. `getheader` indicates
+ * response header processing is expected.
+ */
+void Curl_xfer_setup1(struct Curl_easy *data,
+                      int send_recv,
+                      curl_off_t recv_size,
+                      bool getheader);
+
+/**
+ * The transfer will use socket 2 to send/recv. `recv_size` is
+ * the amount to receive or -1 if unknown. With `shutdown` being
+ * set, the transfer is only allowed to either send OR receive
+ * and the socket 2 connection will be shutdown at the end of
+ * the transfer. An unclean shutdown will fail the transfer.
+ */
+void Curl_xfer_setup2(struct Curl_easy *data,
+                      int send_recv,
+                      curl_off_t recv_size,
+                      bool shutdown);
 
 /**
  * Multi has set transfer to DONE. Last chance to trigger
@@ -111,5 +132,13 @@ CURLcode Curl_xfer_recv(struct Curl_easy *data,
                         ssize_t *pnrcvd);
 
 CURLcode Curl_xfer_send_close(struct Curl_easy *data);
+CURLcode Curl_xfer_send_shutdown(struct Curl_easy *data, bool *done);
+
+/**
+ * Return TRUE iff the transfer is not done, but further progress
+ * is blocked. For example when it is only receiving and its writer
+ * is PAUSED.
+ */
+bool Curl_xfer_is_blocked(struct Curl_easy *data);
 
 #endif /* HEADER_CURL_TRANSFER_H */
diff --git a/lib/url.c b/lib/url.c
index 2814d31ad..914b5b653 100644
--- a/lib/url.c
+++ b/lib/url.c
@@ -56,7 +56,7 @@
 #endif
 
 #ifndef HAVE_SOCKET
-#error "We can't compile without socket() support!"
+#error "We cannot compile without socket() support!"
 #endif
 
 #include <limits.h>
@@ -136,7 +136,7 @@ static void data_priority_cleanup(struct Curl_easy *data);
 #endif
 
 /* Some parts of the code (e.g. chunked encoding) assume this buffer has at
- * more than just a few bytes to play with. Don't let it become too small or
+ * more than just a few bytes to play with. Do not let it become too small or
  * bad things will happen.
  */
 #if READBUFFER_SIZE < READBUFFER_MIN
@@ -260,7 +260,7 @@ CURLcode Curl_close(struct Curl_easy **datap)
   if(data->state.rangestringalloc)
     free(data->state.range);
 
-  /* freed here just in case DONE wasn't called */
+  /* freed here just in case DONE was not called */
   Curl_req_free(&data->req, data);
 
   /* Close down all open SSL info and sessions */
@@ -365,7 +365,7 @@ CURLcode Curl_init_userdefined(struct Curl_easy *data)
 
   set->seek_client = ZERO_NULL;
 
-  set->filesize = -1;        /* we don't know the size */
+  set->filesize = -1;        /* we do not know the size */
   set->postfieldsize = -1;   /* unknown size */
   set->maxredirs = 30;       /* sensible default */
 
@@ -467,6 +467,7 @@ CURLcode Curl_init_userdefined(struct Curl_easy *data)
   set->tcp_keepalive = FALSE;
   set->tcp_keepintvl = 60;
   set->tcp_keepidle = 60;
+  set->tcp_keepcnt = 9;
   set->tcp_fastopen = FALSE;
   set->tcp_nodelay = TRUE;
   set->ssl_enable_alpn = TRUE;
@@ -555,19 +556,7 @@ CURLcode Curl_open(struct Curl_easy **curl)
   return result;
 }
 
-static void conn_shutdown(struct Curl_easy *data)
-{
-  DEBUGASSERT(data);
-  infof(data, "Closing connection");
-
-  /* possible left-overs from the async name resolvers */
-  Curl_resolver_cancel(data);
-
-  Curl_conn_close(data, SECONDARYSOCKET);
-  Curl_conn_close(data, FIRSTSOCKET);
-}
-
-static void conn_free(struct Curl_easy *data, struct connectdata *conn)
+void Curl_conn_free(struct Curl_easy *data, struct connectdata *conn)
 {
   size_t i;
 
@@ -594,8 +583,8 @@ static void conn_free(struct Curl_easy *data, struct connectdata *conn)
   Curl_safefree(conn->sasl_authzid);
   Curl_safefree(conn->options);
   Curl_safefree(conn->oauth_bearer);
-  Curl_safefree(conn->host.rawalloc); /* host name buffer */
-  Curl_safefree(conn->conn_to_host.rawalloc); /* host name buffer */
+  Curl_safefree(conn->host.rawalloc); /* hostname buffer */
+  Curl_safefree(conn->conn_to_host.rawalloc); /* hostname buffer */
   Curl_safefree(conn->hostname_resolve);
   Curl_safefree(conn->secondaryhostname);
   Curl_safefree(conn->localdev);
@@ -618,12 +607,10 @@ static void conn_free(struct Curl_easy *data, struct connectdata *conn)
  * disassociated from an easy handle.
  *
  * This function MUST NOT reset state in the Curl_easy struct if that
- * isn't strictly bound to the life-time of *this* particular connection.
- *
+ * is not strictly bound to the life-time of *this* particular connection.
  */
-
 void Curl_disconnect(struct Curl_easy *data,
-                     struct connectdata *conn, bool dead_connection)
+                     struct connectdata *conn, bool aborted)
 {
   /* there must be a connection to close */
   DEBUGASSERT(conn);
@@ -638,13 +625,14 @@ void Curl_disconnect(struct Curl_easy *data,
   DEBUGASSERT(!data->conn);
 
   DEBUGF(infof(data, "Curl_disconnect(conn #%"
-         CURL_FORMAT_CURL_OFF_T ", dead=%d)",
-         conn->connection_id, dead_connection));
+         CURL_FORMAT_CURL_OFF_T ", aborted=%d)",
+         conn->connection_id, aborted));
+
   /*
-   * If this connection isn't marked to force-close, leave it open if there
+   * If this connection is not marked to force-close, leave it open if there
    * are other users of it
    */
-  if(CONN_INUSE(conn) && !dead_connection) {
+  if(CONN_INUSE(conn) && !aborted) {
     DEBUGF(infof(data, "Curl_disconnect when inuse: %zu", CONN_INUSE(conn)));
     return;
   }
@@ -661,23 +649,10 @@ void Curl_disconnect(struct Curl_easy *data,
   Curl_http_auth_cleanup_negotiate(conn);
 
   if(conn->connect_only)
-    /* treat the connection as dead in CONNECT_ONLY situations */
-    dead_connection = TRUE;
-
-  /* temporarily attach the connection to this transfer handle for the
-     disconnect and shutdown */
-  Curl_attach_connection(data, conn);
-
-  if(conn->handler && conn->handler->disconnect)
-    /* This is set if protocol-specific cleanups should be made */
-    conn->handler->disconnect(data, conn, dead_connection);
+    /* treat the connection as aborted in CONNECT_ONLY situations */
+    aborted = TRUE;
 
-  conn_shutdown(data);
-
-  /* detach it again */
-  Curl_detach_connection(data);
-
-  conn_free(data, conn);
+  Curl_conncache_disconnect(data, conn, aborted);
 }
 
 /*
@@ -735,7 +710,7 @@ socks_proxy_info_matches(const struct proxy_info *data,
   return TRUE;
 }
 #else
-/* disabled, won't get called */
+/* disabled, will not get called */
 #define proxy_info_matches(x,y) FALSE
 #define socks_proxy_info_matches(x,y) FALSE
 #endif
@@ -786,7 +761,7 @@ static bool prune_if_dead(struct connectdata *conn,
                           struct Curl_easy *data)
 {
   if(!CONN_INUSE(conn)) {
-    /* The check for a dead socket makes sense only if the connection isn't in
+    /* The check for a dead socket makes sense only if the connection is not in
        use */
     bool dead;
     struct curltime now = Curl_now();
@@ -823,6 +798,7 @@ static bool prune_if_dead(struct connectdata *conn,
          * any time (HTTP/2 PING for example), the protocol handler needs
          * to install its own `connection_check` callback.
          */
+        DEBUGF(infof(data, "connection has input pending, not reusable"));
         dead = TRUE;
       }
       Curl_detach_connection(data);
@@ -880,8 +856,8 @@ static void prune_dead_connections(struct Curl_easy *data)
 
       /* connection previously removed from cache in prune_if_dead() */
 
-      /* disconnect it */
-      Curl_disconnect(data, pruned, TRUE);
+      /* disconnect it, do not treat as aborted */
+      Curl_disconnect(data, pruned, FALSE);
     }
     CONNCACHE_LOCK(data);
     data->state.conn_cache->last_cleanup = now;
@@ -961,12 +937,12 @@ ConnectionExists(struct Curl_easy *data,
   if(IsMultiplexingPossible(data, needle)) {
     if(bundle->multiuse == BUNDLE_UNKNOWN) {
       if(data->set.pipewait) {
-        infof(data, "Server doesn't support multiplex yet, wait");
+        infof(data, "Server does not support multiplex yet, wait");
         *waitpipe = TRUE;
         CONNCACHE_UNLOCK(data);
         return FALSE; /* no reuse */
       }
-      infof(data, "Server doesn't support multiplex (yet)");
+      infof(data, "Server does not support multiplex (yet)");
     }
     else if(bundle->multiuse == BUNDLE_MULTIPLEX) {
       if(Curl_multiplex_wanted(data->multi))
@@ -1001,15 +977,15 @@ ConnectionExists(struct Curl_easy *data,
 
     if(!canmultiplex) {
       if(Curl_resolver_asynch() &&
-         /* remote_ip[0] is NUL only if the resolving of the name hasn't
-            completed yet and until then we don't reuse this connection */
+         /* remote_ip[0] is NUL only if the resolving of the name has not
+            completed yet and until then we do not reuse this connection */
          !check->primary.remote_ip[0])
         continue;
     }
 
     if(CONN_INUSE(check)) {
       if(!canmultiplex) {
-        /* transfer can't be multiplexed and check is in use */
+        /* transfer cannot be multiplexed and check is in use */
         continue;
       }
       else {
@@ -1023,9 +999,9 @@ ConnectionExists(struct Curl_easy *data,
 
     if(!Curl_conn_is_connected(check, FIRSTSOCKET)) {
       foundPendingCandidate = TRUE;
-      /* Don't pick a connection that hasn't connected yet */
+      /* Do not pick a connection that has not connected yet */
       infof(data, "Connection #%" CURL_FORMAT_CURL_OFF_T
-            " isn't open enough, can't reuse", check->connection_id);
+            " is not open enough, cannot reuse", check->connection_id);
       continue;
     }
 
@@ -1050,20 +1026,20 @@ ConnectionExists(struct Curl_easy *data,
 
     if((needle->handler->flags&PROTOPT_SSL) !=
        (check->handler->flags&PROTOPT_SSL))
-      /* don't do mixed SSL and non-SSL connections */
+      /* do not do mixed SSL and non-SSL connections */
       if(get_protocol_family(check->handler) !=
          needle->handler->protocol || !check->bits.tls_upgraded)
         /* except protocols that have been upgraded via TLS */
         continue;
 
     if(needle->bits.conn_to_host != check->bits.conn_to_host)
-      /* don't mix connections that use the "connect to host" feature and
-       * connections that don't use this feature */
+      /* do not mix connections that use the "connect to host" feature and
+       * connections that do not use this feature */
       continue;
 
     if(needle->bits.conn_to_port != check->bits.conn_to_port)
-      /* don't mix connections that use the "connect to port" feature and
-       * connections that don't use this feature */
+      /* do not mix connections that use the "connect to port" feature and
+       * connections that do not use this feature */
       continue;
 
 #ifndef CURL_DISABLE_PROXY
@@ -1091,7 +1067,7 @@ ConnectionExists(struct Curl_easy *data,
         if(!Curl_ssl_conn_config_match(data, check, TRUE)) {
           DEBUGF(infof(data,
             "Connection #%" CURL_FORMAT_CURL_OFF_T
-            " has different SSL proxy parameters, can't reuse",
+            " has different SSL proxy parameters, cannot reuse",
             check->connection_id));
           continue;
         }
@@ -1103,18 +1079,18 @@ ConnectionExists(struct Curl_easy *data,
 
     if(h2upgrade && !check->httpversion && canmultiplex) {
       if(data->set.pipewait) {
-        infof(data, "Server upgrade doesn't support multiplex yet, wait");
+        infof(data, "Server upgrade does not support multiplex yet, wait");
         *waitpipe = TRUE;
         CONNCACHE_UNLOCK(data);
         return FALSE; /* no reuse */
       }
       infof(data, "Server upgrade cannot be used");
-      continue; /* can't be used atm */
+      continue; /* cannot be used atm */
     }
 
     if(needle->localdev || needle->localport) {
       /* If we are bound to a specific local end (IP+port), we must not
-         reuse a random other one, although if we didn't ask for a
+         reuse a random other one, although if we did not ask for a
          particular one we can reuse one that was bound.
 
          This comparison is a bit rough and too strict. Since the input
@@ -1122,7 +1098,7 @@ ConnectionExists(struct Curl_easy *data,
          same it would take a lot of processing to make it really accurate.
          Instead, this matching will assume that reuses of bound connections
          will most likely also reuse the exact same binding parameters and
-         missing out a few edge cases shouldn't hurt anyone very much.
+         missing out a few edge cases should not hurt anyone very much.
       */
       if((check->localport != needle->localport) ||
          (check->localportrange != needle->localportrange) ||
@@ -1133,7 +1109,7 @@ ConnectionExists(struct Curl_easy *data,
 
     if(!(needle->handler->flags & PROTOPT_CREDSPERREQUEST)) {
       /* This protocol requires credentials per connection,
-         so verify that we're using the same name and password as well */
+         so verify that we are using the same name and password as well */
       if(Curl_timestrcmp(needle->user, check->user) ||
          Curl_timestrcmp(needle->passwd, check->passwd) ||
          Curl_timestrcmp(needle->sasl_authzid, check->sasl_authzid) ||
@@ -1176,7 +1152,7 @@ ConnectionExists(struct Curl_easy *data,
 #endif
 
     /* Additional match requirements if talking TLS OR
-     * not talking to a HTTP proxy OR using a tunnel through a proxy */
+     * not talking to an HTTP proxy OR using a tunnel through a proxy */
     if((needle->handler->flags&PROTOPT_SSL)
 #ifndef CURL_DISABLE_PROXY
        || !needle->bits.httpproxy || needle->bits.tunnel_proxy
@@ -1206,7 +1182,7 @@ ConnectionExists(struct Curl_easy *data,
          !Curl_ssl_conn_config_match(data, check, FALSE)) {
         DEBUGF(infof(data,
                      "Connection #%" CURL_FORMAT_CURL_OFF_T
-                     " has different SSL parameters, can't reuse",
+                     " has different SSL parameters, cannot reuse",
                      check->connection_id));
         continue;
       }
@@ -1230,7 +1206,7 @@ ConnectionExists(struct Curl_easy *data,
       }
     }
     else if(check->http_ntlm_state != NTLMSTATE_NONE) {
-      /* Connection is using NTLM auth but we don't want NTLM */
+      /* Connection is using NTLM auth but we do not want NTLM */
       continue;
     }
 
@@ -1249,7 +1225,7 @@ ConnectionExists(struct Curl_easy *data,
         continue;
     }
     else if(check->proxy_ntlm_state != NTLMSTATE_NONE) {
-      /* Proxy connection is using NTLM auth but we don't want NTLM */
+      /* Proxy connection is using NTLM auth but we do not want NTLM */
       continue;
     }
 #endif
@@ -1276,7 +1252,7 @@ ConnectionExists(struct Curl_easy *data,
     if(CONN_INUSE(check)) {
       DEBUGASSERT(canmultiplex);
       DEBUGASSERT(check->bits.multiplex);
-      /* If multiplexed, make sure we don't go over concurrency limit */
+      /* If multiplexed, make sure we do not go over concurrency limit */
       if(CONN_INUSE(check) >=
               Curl_multi_max_concurrent_streams(data->multi)) {
         infof(data, "client side MAX_CONCURRENT_STREAMS reached"
@@ -1293,8 +1269,8 @@ ConnectionExists(struct Curl_easy *data,
       infof(data, "Multiplexed connection found");
     }
     else if(prune_if_dead(check, data)) {
-      /* disconnect it */
-      Curl_disconnect(data, check, TRUE);
+      /* disconnect it, do not treat as aborted */
+      Curl_disconnect(data, check, FALSE);
       continue;
     }
 
@@ -1357,7 +1333,7 @@ static struct connectdata *allocate_conn(struct Curl_easy *data)
   conn->primary.remote_port = -1; /* unknown at this point */
   conn->remote_port = -1; /* unknown at this point */
 
-  /* Default protocol-independent behavior doesn't support persistent
+  /* Default protocol-independent behavior does not support persistent
      connections, so we set this to force-close. Protocols that support
      this need to set this to FALSE in their "curl_do" functions. */
   connclose(conn, "Default to force-close");
@@ -1643,7 +1619,7 @@ const struct Curl_handler *Curl_getn_scheme_handler(const char *scheme,
     unsigned int c = 978;
     while(l) {
       c <<= 5;
-      c += Curl_raw_tolower(*s);
+      c += (unsigned int)Curl_raw_tolower(*s);
       s++;
       l--;
     }
@@ -1678,7 +1654,7 @@ static CURLcode findprotocol(struct Curl_easy *data,
     }
   }
 
-  /* The protocol was not found in the table, but we don't have to assign it
+  /* The protocol was not found in the table, but we do not have to assign it
      to anything since it is already assigned to a dummy-struct in the
      create_conn() function when the connectdata struct is allocated. */
   failf(data, "Protocol \"%s\" %s%s", protostr,
@@ -1796,12 +1772,12 @@ static CURLcode parseurlandfillconn(struct Curl_easy *data,
 
   if(!use_set_uh) {
     char *newurl;
-    uc = curl_url_set(uh, CURLUPART_URL, data->state.url,
-                      CURLU_GUESS_SCHEME |
-                      CURLU_NON_SUPPORT_SCHEME |
-                      (data->set.disallow_username_in_url ?
-                       CURLU_DISALLOW_USER : 0) |
-                      (data->set.path_as_is ? CURLU_PATH_AS_IS : 0));
+    uc = curl_url_set(uh, CURLUPART_URL, data->state.url, (unsigned int)
+                      (CURLU_GUESS_SCHEME |
+                       CURLU_NON_SUPPORT_SCHEME |
+                       (data->set.disallow_username_in_url ?
+                        CURLU_DISALLOW_USER : 0) |
+                       (data->set.path_as_is ? CURLU_PATH_AS_IS : 0)));
     if(uc) {
       failf(data, "URL rejected: %s", curl_url_strerror(uc));
       return Curl_uc_to_curlcode(uc);
@@ -1827,7 +1803,7 @@ static CURLcode parseurlandfillconn(struct Curl_easy *data,
       return CURLE_OUT_OF_MEMORY;
   }
   else if(strlen(data->state.up.hostname) > MAX_URL_LEN) {
-    failf(data, "Too long host name (maximum is %d)", MAX_URL_LEN);
+    failf(data, "Too long hostname (maximum is %d)", MAX_URL_LEN);
     return CURLE_URL_MALFORMAT;
   }
   hostname = data->state.up.hostname;
@@ -1845,7 +1821,7 @@ static CURLcode parseurlandfillconn(struct Curl_easy *data,
     zonefrom_url(uh, data, conn);
   }
 
-  /* make sure the connect struct gets its own copy of the host name */
+  /* make sure the connect struct gets its own copy of the hostname */
   conn->host.rawalloc = strdup(hostname ? hostname : "");
   if(!conn->host.rawalloc)
     return CURLE_OUT_OF_MEMORY;
@@ -1892,7 +1868,7 @@ static CURLcode parseurlandfillconn(struct Curl_easy *data,
     return result;
 
   /*
-   * User name and password set with their own options override the
+   * username and password set with their own options override the
    * credentials possibly set in the URL.
    */
   if(!data->set.str[STRING_PASSWORD]) {
@@ -1914,7 +1890,7 @@ static CURLcode parseurlandfillconn(struct Curl_easy *data,
   }
 
   if(!data->set.str[STRING_USERNAME]) {
-    /* we don't use the URL API's URL decoder option here since it rejects
+    /* we do not use the URL API's URL decoder option here since it rejects
        control codes and we want to allow them for some schemes in the user
        and password fields */
     uc = curl_url_get(uh, CURLUPART_USER, &data->state.up.user, 0);
@@ -1979,7 +1955,7 @@ static CURLcode parseurlandfillconn(struct Curl_easy *data,
 
 
 /*
- * If we're doing a resumed transfer, we need to setup our stuff
+ * If we are doing a resumed transfer, we need to setup our stuff
  * properly.
  */
 static CURLcode setup_range(struct Curl_easy *data)
@@ -2074,7 +2050,7 @@ static char *detect_proxy(struct Curl_easy *data,
    *   the first to check for.)
    *
    * For compatibility, the all-uppercase versions of these variables are
-   * checked if the lowercase versions don't exist.
+   * checked if the lowercase versions do not exist.
    */
   char proxy_env[20];
   char *envp = proxy_env;
@@ -2088,7 +2064,7 @@ static char *detect_proxy(struct Curl_easy *data,
   proxy = curl_getenv(proxy_env);
 
   /*
-   * We don't try the uppercase version of HTTP_PROXY because of
+   * We do not try the uppercase version of HTTP_PROXY because of
    * security reasons:
    *
    * When curl is used in a webserver application
@@ -2137,7 +2113,7 @@ static char *detect_proxy(struct Curl_easy *data,
 
 /*
  * If this is supposed to use a proxy, we need to figure out the proxy
- * host name, so that we can reuse an existing connection
+ * hostname, so that we can reuse an existing connection
  * that may exist registered to the same proxy host.
  */
 static CURLcode parse_proxy(struct Curl_easy *data,
@@ -2284,7 +2260,7 @@ static CURLcode parse_proxy(struct Curl_easy *data,
       conn->primary.remote_port = port;
   }
 
-  /* now, clone the proxy host name */
+  /* now, clone the proxy hostname */
   uc = curl_url_get(uhp, CURLUPART_HOST, &host, CURLU_URLDECODE);
   if(uc) {
     result = CURLE_OUT_OF_MEMORY;
@@ -2374,7 +2350,6 @@ static CURLcode create_conn_helper_init_proxy(struct Curl_easy *data,
   char *socksproxy = NULL;
   char *no_proxy = NULL;
   CURLcode result = CURLE_OK;
-  bool spacesep = FALSE;
 
   /*************************************************************
    * Extract the user and password from the authentication string
@@ -2421,8 +2396,7 @@ static CURLcode create_conn_helper_init_proxy(struct Curl_easy *data,
   }
 
   if(Curl_check_noproxy(conn->host.name, data->set.str[STRING_NOPROXY] ?
-                        data->set.str[STRING_NOPROXY] : no_proxy,
-                        &spacesep)) {
+                        data->set.str[STRING_NOPROXY] : no_proxy)) {
     Curl_safefree(proxy);
     Curl_safefree(socksproxy);
   }
@@ -2431,9 +2405,6 @@ static CURLcode create_conn_helper_init_proxy(struct Curl_easy *data,
     /* if the host is not in the noproxy list, detect proxy. */
     proxy = detect_proxy(data, conn);
 #endif /* CURL_DISABLE_HTTP */
-  if(spacesep)
-    infof(data, "space-separated NOPROXY patterns are deprecated");
-
   Curl_safefree(no_proxy);
 
 #ifdef USE_UNIX_SOCKETS
@@ -2445,14 +2416,14 @@ static CURLcode create_conn_helper_init_proxy(struct Curl_easy *data,
 #endif
 
   if(proxy && (!*proxy || (conn->handler->flags & PROTOPT_NONETWORK))) {
-    free(proxy);  /* Don't bother with an empty proxy string or if the
-                     protocol doesn't work with network */
+    free(proxy);  /* Do not bother with an empty proxy string or if the
+                     protocol does not work with network */
     proxy = NULL;
   }
   if(socksproxy && (!*socksproxy ||
                     (conn->handler->flags & PROTOPT_NONETWORK))) {
-    free(socksproxy);  /* Don't bother with an empty socks proxy string or if
-                          the protocol doesn't work with network */
+    free(socksproxy);  /* Do not bother with an empty socks proxy string or if
+                          the protocol does not work with network */
     socksproxy = NULL;
   }
 
@@ -2524,7 +2495,7 @@ static CURLcode create_conn_helper_init_proxy(struct Curl_easy *data,
   conn->bits.proxy = conn->bits.httpproxy || conn->bits.socksproxy;
 
   if(!conn->bits.proxy) {
-    /* we aren't using the proxy after all... */
+    /* we are not using the proxy after all... */
     conn->bits.proxy = FALSE;
     conn->bits.httpproxy = FALSE;
     conn->bits.socksproxy = FALSE;
@@ -2546,7 +2517,7 @@ out:
 /*
  * Curl_parse_login_details()
  *
- * This is used to parse a login string for user name, password and options in
+ * This is used to parse a login string for username, password and options in
  * the following formats:
  *
  *   user
@@ -2693,7 +2664,7 @@ static CURLcode override_login(struct Curl_easy *data,
     bool url_provided = FALSE;
 
     if(data->state.aptr.user) {
-      /* there was a user name in the URL. Use the URL decoded version */
+      /* there was a username in the URL. Use the URL decoded version */
       userp = &data->state.aptr.user;
       url_provided = TRUE;
     }
@@ -2774,7 +2745,7 @@ static CURLcode override_login(struct Curl_easy *data,
 }
 
 /*
- * Set the login details so they're available in the connection
+ * Set the login details so they are available in the connection
  */
 static CURLcode set_login(struct Curl_easy *data,
                           struct connectdata *conn)
@@ -2865,8 +2836,8 @@ static CURLcode parse_connect_to_host_port(struct Curl_easy *data,
     else
       infof(data, "Invalid IPv6 address format");
     portptr = ptr;
-    /* Note that if this didn't end with a bracket, we still advanced the
-     * hostptr first, but I can't see anything wrong with that as no host
+    /* Note that if this did not end with a bracket, we still advanced the
+     * hostptr first, but I cannot see anything wrong with that as no host
      * name nor a numeric can legally start with a bracket.
      */
 #else
@@ -2880,7 +2851,7 @@ static CURLcode parse_connect_to_host_port(struct Curl_easy *data,
   host_portno = strchr(portptr, ':');
   if(host_portno) {
     char *endp = NULL;
-    *host_portno = '\0'; /* cut off number from host name */
+    *host_portno = '\0'; /* cut off number from hostname */
     host_portno++;
     if(*host_portno) {
       long portparse = strtol(host_portno, &endp, 10);
@@ -2895,7 +2866,7 @@ static CURLcode parse_connect_to_host_port(struct Curl_easy *data,
     }
   }
 
-  /* now, clone the cleaned host name */
+  /* now, clone the cleaned hostname */
   DEBUGASSERT(hostptr);
   *hostname_result = strdup(hostptr);
   if(!*hostname_result) {
@@ -3028,7 +2999,7 @@ static CURLcode parse_connect_to_slist(struct Curl_easy *data,
 #ifndef CURL_DISABLE_ALTSVC
   if(data->asi && !host && (port == -1) &&
      ((conn->handler->protocol == CURLPROTO_HTTPS) ||
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
       /* allow debug builds to circumvent the HTTPS restriction */
       getenv("CURL_ALTSVC_HTTP")
 #else
@@ -3091,7 +3062,7 @@ static CURLcode parse_connect_to_slist(struct Curl_easy *data,
           conn->transport = TRNSPRT_QUIC;
           conn->httpversion = 30;
           break;
-        default: /* shouldn't be possible */
+        default: /* should not be possible */
           break;
         }
       }
@@ -3254,7 +3225,7 @@ static CURLcode resolve_server(struct Curl_easy *data,
 
   /* Resolve the name of the server or proxy */
   if(conn->bits.reuse) {
-    /* We're reusing the connection - no need to resolve anything, and
+    /* We are reusing the connection - no need to resolve anything, and
        idnconvert_hostname() was called already in create_conn() for the reuse
        case. */
     *async = FALSE;
@@ -3266,7 +3237,7 @@ static CURLcode resolve_server(struct Curl_easy *data,
 
 /*
  * Cleanup the connection `temp`, just allocated for `data`, before using the
- * previously `existing` one for `data`.  All relevant info is copied over
+ * previously `existing` one for `data`. All relevant info is copied over
  * and `temp` is freed.
  */
 static void reuse_conn(struct Curl_easy *data,
@@ -3276,7 +3247,7 @@ static void reuse_conn(struct Curl_easy *data,
   /* get the user+password information from the temp struct since it may
    * be new for this request even when we reuse an existing connection */
   if(temp->user) {
-    /* use the new user name and password though */
+    /* use the new username and password though */
     Curl_safefree(existing->user);
     Curl_safefree(existing->passwd);
     existing->user = temp->user;
@@ -3288,7 +3259,7 @@ static void reuse_conn(struct Curl_easy *data,
 #ifndef CURL_DISABLE_PROXY
   existing->bits.proxy_user_passwd = temp->bits.proxy_user_passwd;
   if(existing->bits.proxy_user_passwd) {
-    /* use the new proxy user name and proxy password though */
+    /* use the new proxy username and proxy password though */
     Curl_safefree(existing->http_proxy.user);
     Curl_safefree(existing->socks_proxy.user);
     Curl_safefree(existing->http_proxy.passwd);
@@ -3335,14 +3306,14 @@ static void reuse_conn(struct Curl_easy *data,
   temp->hostname_resolve = NULL;
 
   /* reuse init */
-  existing->bits.reuse = TRUE; /* yes, we're reusing here */
+  existing->bits.reuse = TRUE; /* yes, we are reusing here */
 
-  conn_free(data, temp);
+  Curl_conn_free(data, temp);
 }
 
 /**
  * create_conn() sets up a new connectdata struct, or reuses an already
- * existing one, and resolves host name.
+ * existing one, and resolves hostname.
  *
  * if this function returns CURLE_OK and *async is set to TRUE, the resolve
  * response will be coming asynchronously. If *async is FALSE, the name is
@@ -3524,7 +3495,7 @@ static CURLcode create_conn(struct Curl_easy *data,
     goto out;
 
   /***********************************************************************
-   * file: is a special case in that it doesn't need a network connection
+   * file: is a special case in that it does not need a network connection
    ***********************************************************************/
 #ifndef CURL_DISABLE_FILE
   if(conn->handler->flags & PROTOPT_NONETWORK) {
@@ -3535,7 +3506,7 @@ static CURLcode create_conn(struct Curl_easy *data,
     Curl_persistconninfo(data, conn, NULL);
     result = conn->handler->connect_it(data, &done);
 
-    /* Setup a "faked" transfer that'll do nothing */
+    /* Setup a "faked" transfer that will do nothing */
     if(!result) {
       Curl_attach_connection(data, conn);
       result = Curl_conncache_add_conn(data);
@@ -3552,7 +3523,7 @@ static CURLcode create_conn(struct Curl_easy *data,
         (void)conn->handler->done(data, result, FALSE);
         goto out;
       }
-      Curl_xfer_setup(data, -1, -1, FALSE, -1);
+      Curl_xfer_setup_nop(data);
     }
 
     /* since we skip do_init() */
@@ -3667,16 +3638,22 @@ static CURLcode create_conn(struct Curl_easy *data,
       conn_candidate = Curl_conncache_extract_oldest(data);
       if(conn_candidate)
         Curl_disconnect(data, conn_candidate, FALSE);
-      else {
-        infof(data, "No connections available in cache");
-        connections_available = FALSE;
-      }
+      else
+#ifndef CURL_DISABLE_DOH
+        if(data->set.dohfor)
+          infof(data, "Allowing DoH to override max connection limit");
+        else
+#endif
+        {
+          infof(data, "No connections available in cache");
+          connections_available = FALSE;
+        }
     }
 
     if(!connections_available) {
       infof(data, "No connections available.");
 
-      conn_free(data, conn);
+      Curl_conn_free(data, conn);
       *in_connect = NULL;
 
       result = CURLE_NO_CONNECTION_AVAILABLE;
@@ -3700,7 +3677,7 @@ static CURLcode create_conn(struct Curl_easy *data,
     }
 
 #if defined(USE_NTLM)
-    /* If NTLM is requested in a part of this connection, make sure we don't
+    /* If NTLM is requested in a part of this connection, make sure we do not
        assume the state is fine as this is a fresh connection and NTLM is
        connection based. */
     if((data->state.authhost.picked & CURLAUTH_NTLM) &&
@@ -3769,7 +3746,7 @@ CURLcode Curl_setup_conn(struct Curl_easy *data,
 #ifndef CURL_DISABLE_PROXY
   /* set proxy_connect_closed to false unconditionally already here since it
      is used strictly to provide extra information to a parent function in the
-     case of proxy CONNECT failures and we must make sure we don't have it
+     case of proxy CONNECT failures and we must make sure we do not have it
      lingering set from a previous invoke */
   conn->bits.proxy_connect_closed = FALSE;
 #endif
@@ -3812,7 +3789,7 @@ CURLcode Curl_connect(struct Curl_easy *data,
       /* multiplexed */
       *protocol_done = TRUE;
     else if(!*asyncp) {
-      /* DNS resolution is done: that's either because this is a reused
+      /* DNS resolution is done: that is either because this is a reused
          connection, in which case DNS was unnecessary, or because DNS
          really did finish already (synch resolver/fast async resolve) */
       result = Curl_setup_conn(data, protocol_done);
@@ -3823,7 +3800,7 @@ CURLcode Curl_connect(struct Curl_easy *data,
     return result;
   }
   else if(result && conn) {
-    /* We're not allowed to return failure with memory left allocated in the
+    /* We are not allowed to return failure with memory left allocated in the
        connectdata struct, free those here */
     Curl_detach_connection(data);
     Curl_conncache_remove_conn(data, conn, TRUE);
@@ -3849,9 +3826,9 @@ CURLcode Curl_init_do(struct Curl_easy *data, struct connectdata *conn)
   CURLcode result;
 
   if(conn) {
-    conn->bits.do_more = FALSE; /* by default there's no curl_do_more() to
+    conn->bits.do_more = FALSE; /* by default there is no curl_do_more() to
                                    use */
-    /* if the protocol used doesn't support wildcards, switch it off */
+    /* if the protocol used does not support wildcards, switch it off */
     if(data->state.wildcardmatch &&
        !(conn->handler->flags & PROTOPT_WILDCARD))
       data->state.wildcardmatch = FALSE;
diff --git a/lib/url.h b/lib/url.h
index 198a00ad1..55f9b1585 100644
--- a/lib/url.h
+++ b/lib/url.h
@@ -38,9 +38,10 @@ CURLcode Curl_uc_to_curlcode(CURLUcode uc);
 CURLcode Curl_close(struct Curl_easy **datap); /* opposite of curl_open() */
 CURLcode Curl_connect(struct Curl_easy *, bool *async, bool *protocol_connect);
 void Curl_disconnect(struct Curl_easy *data,
-                     struct connectdata *, bool dead_connection);
+                     struct connectdata *, bool aborted);
 CURLcode Curl_setup_conn(struct Curl_easy *data,
                          bool *protocol_done);
+void Curl_conn_free(struct Curl_easy *data, struct connectdata *conn);
 CURLcode Curl_parse_login_details(const char *login, const size_t len,
                                   char **userptr, char **passwdptr,
                                   char **optionsptr);
diff --git a/lib/urlapi-int.h b/lib/urlapi-int.h
index c40281a89..fcffab2e9 100644
--- a/lib/urlapi-int.h
+++ b/lib/urlapi-int.h
@@ -30,9 +30,9 @@ size_t Curl_is_absolute_url(const char *url, char *buf, size_t buflen,
 
 CURLUcode Curl_url_set_authority(CURLU *u, const char *authority);
 
-#ifdef DEBUGBUILD
-CURLUcode Curl_parse_port(struct Curl_URL *u, struct dynbuf *host,
-                          bool has_scheme);
+#ifdef UNITTESTS
+UNITTEST CURLUcode Curl_parse_port(struct Curl_URL *u, struct dynbuf *host,
+                                   bool has_scheme);
 #endif
 
 #endif /* HEADER_CURL_URLAPI_INT_H */
diff --git a/lib/urlapi.c b/lib/urlapi.c
index eb0396687..b71be3847 100644
--- a/lib/urlapi.c
+++ b/lib/urlapi.c
@@ -82,6 +82,7 @@ struct Curl_URL {
   unsigned short portnum; /* the numerical version (if 'port' is set) */
   BIT(query_present);    /* to support blank */
   BIT(fragment_present); /* to support blank */
+  BIT(guessed_scheme);   /* when a URL without scheme is parsed */
 };
 
 #define DEFAULT_SCHEME "https"
@@ -101,7 +102,7 @@ static void free_urlhandle(struct Curl_URL *u)
 }
 
 /*
- * Find the separator at the end of the host name, or the '?' in cases like
+ * Find the separator at the end of the hostname, or the '?' in cases like
  * http://www.example.com?id=2380
  */
 static const char *find_host_sep(const char *url)
@@ -140,7 +141,7 @@ static const char hexdigits[] = "0123456789abcdef";
 /* urlencode_str() writes data into an output dynbuf and URL-encodes the
  * spaces in the source URL accordingly.
  *
- * URL encoding should be skipped for host names, otherwise IDN resolution
+ * URL encoding should be skipped for hostnames, otherwise IDN resolution
  * will fail.
  */
 static CURLUcode urlencode_str(struct dynbuf *o, const char *url,
@@ -205,7 +206,7 @@ static CURLUcode urlencode_str(struct dynbuf *o, const char *url,
 size_t Curl_is_absolute_url(const char *url, char *buf, size_t buflen,
                             bool guess_scheme)
 {
-  int i = 0;
+  size_t i = 0;
   DEBUGASSERT(!buf || (buflen > MAX_SCHEME_LEN));
   (void)buflen; /* only used in debug-builds */
   if(buf)
@@ -229,7 +230,7 @@ size_t Curl_is_absolute_url(const char *url, char *buf, size_t buflen,
   if(i && (url[i] == ':') && ((url[i + 1] == '/') || !guess_scheme)) {
     /* If this does not guess scheme, the scheme always ends with the colon so
        that this also detects data: URLs etc. In guessing mode, data: could
-       be the host name "data" with a specified port number. */
+       be the hostname "data" with a specified port number. */
 
     /* the length of the scheme is the name part only */
     size_t len = i;
@@ -267,7 +268,7 @@ static CURLcode concat_url(char *base, const char *relurl, char **newurl)
   bool skip_slash = FALSE;
   *newurl = NULL;
 
-  /* protsep points to the start of the host name */
+  /* protsep points to the start of the hostname */
   protsep = strstr(base, "//");
   if(!protsep)
     protsep = base;
@@ -277,13 +278,13 @@ static CURLcode concat_url(char *base, const char *relurl, char **newurl)
   if('/' != relurl[0]) {
     int level = 0;
 
-    /* First we need to find out if there's a ?-letter in the URL,
+    /* First we need to find out if there is a ?-letter in the URL,
        and cut it and the right-side of that off */
     pathsep = strchr(protsep, '?');
     if(pathsep)
       *pathsep = 0;
 
-    /* we have a relative path to append to the last slash if there's one
+    /* we have a relative path to append to the last slash if there is one
        available, or the new URL is just a query string (starts with a '?') or
        a fragment (starts with '#') we append the new one at the end of the
        current URL */
@@ -292,7 +293,7 @@ static CURLcode concat_url(char *base, const char *relurl, char **newurl)
       if(pathsep)
         *pathsep = 0;
 
-      /* Check if there's any slash after the host name, and if so, remember
+      /* Check if there is any slash after the hostname, and if so, remember
          that position instead */
       pathsep = strchr(protsep, '/');
       if(pathsep)
@@ -347,7 +348,7 @@ static CURLcode concat_url(char *base, const char *relurl, char **newurl)
       if(pathsep) {
         /* When people use badly formatted URLs, such as
            "http://www.example.com?dir=/home/daniel" we must not use the first
-           slash, if there's a ?-letter before it! */
+           slash, if there is a ?-letter before it! */
         char *sep = strchr(protsep, '?');
         if(sep && (sep < pathsep))
           pathsep = sep;
@@ -355,8 +356,8 @@ static CURLcode concat_url(char *base, const char *relurl, char **newurl)
       }
       else {
         /* There was no slash. Now, since we might be operating on a badly
-           formatted URL, such as "http://www.example.com?id=2380" which
-           doesn't use a slash separator as it is supposed to, we need to check
+           formatted URL, such as "http://www.example.com?id=2380" which does
+           not use a slash separator as it is supposed to, we need to check
            for a ?-letter as well! */
         pathsep = strchr(protsep, '?');
         if(pathsep)
@@ -367,7 +368,7 @@ static CURLcode concat_url(char *base, const char *relurl, char **newurl)
 
   Curl_dyn_init(&newest, CURL_MAX_INPUT_LENGTH);
 
-  /* copy over the root url part */
+  /* copy over the root URL part */
   result = Curl_dyn_add(&newest, base);
   if(result)
     return result;
@@ -420,15 +421,15 @@ static CURLUcode junkscan(const char *url, size_t *urllen, unsigned int flags)
 /*
  * parse_hostname_login()
  *
- * Parse the login details (user name, password and options) from the URL and
- * strip them out of the host name
+ * Parse the login details (username, password and options) from the URL and
+ * strip them out of the hostname
  *
  */
 static CURLUcode parse_hostname_login(struct Curl_URL *u,
                                       const char *login,
                                       size_t len,
                                       unsigned int flags,
-                                      size_t *offset) /* to the host name */
+                                      size_t *offset) /* to the hostname */
 {
   CURLUcode result = CURLUE_OK;
   CURLcode ccode;
@@ -475,7 +476,7 @@ static CURLUcode parse_hostname_login(struct Curl_URL *u,
 
   if(userp) {
     if(flags & CURLU_DISALLOW_USER) {
-      /* Option DISALLOW_USER is set and url contains username. */
+      /* Option DISALLOW_USER is set and URL contains username. */
       result = CURLUE_USER_NOT_ALLOWED;
       goto out;
     }
@@ -493,7 +494,7 @@ static CURLUcode parse_hostname_login(struct Curl_URL *u,
     u->options = optionsp;
   }
 
-  /* the host name starts at this offset */
+  /* the hostname starts at this offset */
   *offset = ptr - login;
   return CURLUE_OK;
 
@@ -538,11 +539,11 @@ UNITTEST CURLUcode Curl_parse_port(struct Curl_URL *u, struct dynbuf *host,
     unsigned long port;
     size_t keep = portptr - hostname;
 
-    /* Browser behavior adaptation. If there's a colon with no digits after,
+    /* Browser behavior adaptation. If there is a colon with no digits after,
        just cut off the name there which makes us ignore the colon and just
        use the default port. Firefox, Chrome and Safari all do that.
 
-       Don't do it if the URL has no scheme, to make something that looks like
+       Do not do it if the URL has no scheme, to make something that looks like
        a scheme not work!
     */
     Curl_dyn_setlen(host, keep);
@@ -591,7 +592,7 @@ static CURLUcode ipv6_parse(struct Curl_URL *u, char *hostname,
       char zoneid[16];
       int i = 0;
       char *h = &hostname[len + 1];
-      /* pass '25' if present and is a url encoded percent sign */
+      /* pass '25' if present and is a URL encoded percent sign */
       if(!strncmp(h, "25", 2) && h[2] && (h[2] != ']'))
         h += 2;
       while(*h && (*h != ']') && (i < 15))
@@ -664,7 +665,6 @@ static CURLUcode hostname_check(struct Curl_URL *u, char *hostname,
  */
 
 #define HOST_ERROR   -1 /* out of memory */
-#define HOST_BAD     -2 /* bad IPv4 address */
 
 #define HOST_NAME    1
 #define HOST_IPV4    2
@@ -686,7 +686,7 @@ static int ipv4_normalize(struct dynbuf *host)
     char *endp = NULL;
     unsigned long l;
     if(!ISDIGIT(*c))
-      /* most importantly this doesn't allow a leading plus or minus */
+      /* most importantly this does not allow a leading plus or minus */
       return HOST_NAME;
     l = strtoul(c, &endp, 0);
     if(errno)
@@ -802,7 +802,7 @@ static CURLUcode parse_authority(struct Curl_URL *u,
   CURLcode result;
 
   /*
-   * Parse the login details and strip them out of the host name.
+   * Parse the login details and strip them out of the hostname.
    */
   uc = parse_hostname_login(u, auth, authlen, flags, &offset);
   if(uc)
@@ -835,7 +835,6 @@ static CURLUcode parse_authority(struct Curl_URL *u,
   case HOST_ERROR:
     uc = CURLUE_OUT_OF_MEMORY;
     break;
-  case HOST_BAD:
   default:
     uc = CURLUE_BAD_HOSTNAME; /* Bad IPv4 address even */
     break;
@@ -907,7 +906,7 @@ UNITTEST int dedotdotify(const char *input, size_t clen, char **outp)
   do {
     bool dotdot = TRUE;
     if(*input == '.') {
-      /*  A.  If the input buffer begins with a prefix of "../" or "./", then
+      /*  A. If the input buffer begins with a prefix of "../" or "./", then
           remove that prefix from the input buffer; otherwise, */
 
       if(!strncmp("./", input, 2)) {
@@ -918,7 +917,7 @@ UNITTEST int dedotdotify(const char *input, size_t clen, char **outp)
         input += 3;
         clen -= 3;
       }
-      /*  D.  if the input buffer consists only of "." or "..", then remove
+      /*  D. if the input buffer consists only of "." or "..", then remove
           that from the input buffer; otherwise, */
 
       else if(!strcmp(".", input) || !strcmp("..", input) ||
@@ -930,7 +929,7 @@ UNITTEST int dedotdotify(const char *input, size_t clen, char **outp)
         dotdot = FALSE;
     }
     else if(*input == '/') {
-      /*  B.  if the input buffer begins with a prefix of "/./" or "/.", where
+      /*  B. if the input buffer begins with a prefix of "/./" or "/.", where
           "."  is a complete path segment, then replace that prefix with "/" in
           the input buffer; otherwise, */
       if(!strncmp("/./", input, 3)) {
@@ -943,7 +942,7 @@ UNITTEST int dedotdotify(const char *input, size_t clen, char **outp)
         break;
       }
 
-      /*  C.  if the input buffer begins with a prefix of "/../" or "/..",
+      /*  C. if the input buffer begins with a prefix of "/../" or "/..",
           where ".." is a complete path segment, then replace that prefix with
           "/" in the input buffer and remove the last segment and its
           preceding "/" (if any) from the output buffer; otherwise, */
@@ -977,7 +976,7 @@ UNITTEST int dedotdotify(const char *input, size_t clen, char **outp)
       dotdot = FALSE;
 
     if(!dotdot) {
-      /*  E.  move the first path segment in the input buffer to the end of
+      /*  E. move the first path segment in the input buffer to the end of
           the output buffer, including the initial "/" character (if any) and
           any subsequent characters up to, but not including, the next "/"
           character or the end of the input buffer. */
@@ -1070,7 +1069,7 @@ static CURLUcode parseurl(const char *url, CURLU *u, unsigned int flags)
        * Appendix E, but believe me, it was meant to be there. --MK)
        */
       if(ptr[0] != '/' && !STARTS_WITH_URL_DRIVE_PREFIX(ptr)) {
-        /* the URL includes a host name, it must match "localhost" or
+        /* the URL includes a hostname, it must match "localhost" or
            "127.0.0.1" to be valid */
         if(checkprefix("localhost/", ptr) ||
            checkprefix("127.0.0.1/", ptr)) {
@@ -1080,9 +1079,9 @@ static CURLUcode parseurl(const char *url, CURLU *u, unsigned int flags)
 #if defined(_WIN32)
           size_t len;
 
-          /* the host name, NetBIOS computer name, can not contain disallowed
+          /* the hostname, NetBIOS computer name, can not contain disallowed
              chars, and the delimiting slash character must be appended to the
-             host name */
+             hostname */
           path = strpbrk(ptr, "/\\:*?\"<>|");
           if(!path || *path != '/') {
             result = CURLUE_BAD_FILE_URL;
@@ -1118,7 +1117,7 @@ static CURLUcode parseurl(const char *url, CURLU *u, unsigned int flags)
       Curl_dyn_reset(&host);
 
 #if !defined(_WIN32) && !defined(MSDOS) && !defined(__CYGWIN__)
-    /* Don't allow Windows drive letters when not in Windows.
+    /* Do not allow Windows drive letters when not in Windows.
      * This catches both "file:/c:" and "file:c:" */
     if(('/' == path[0] && STARTS_WITH_URL_DRIVE_PREFIX(&path[1])) ||
        STARTS_WITH_URL_DRIVE_PREFIX(path)) {
@@ -1162,7 +1161,7 @@ static CURLUcode parseurl(const char *url, CURLU *u, unsigned int flags)
         result = CURLUE_BAD_SLASHES;
         goto fail;
       }
-      hostp = p; /* host name starts here */
+      hostp = p; /* hostname starts here */
     }
     else {
       /* no scheme! */
@@ -1188,7 +1187,7 @@ static CURLUcode parseurl(const char *url, CURLU *u, unsigned int flags)
       }
     }
 
-    /* find the end of the host name + port number */
+    /* find the end of the hostname + port number */
     hostlen = strcspn(hostp, "/?#");
     path = &hostp[hostlen];
 
@@ -1202,7 +1201,7 @@ static CURLUcode parseurl(const char *url, CURLU *u, unsigned int flags)
 
       if((flags & CURLU_GUESS_SCHEME) && !schemep) {
         const char *hostname = Curl_dyn_ptr(&host);
-        /* legacy curl-style guess based on host name */
+        /* legacy curl-style guess based on hostname */
         if(checkprefix("ftp.", hostname))
           schemep = "ftp";
         else if(checkprefix("dict.", hostname))
@@ -1223,6 +1222,7 @@ static CURLUcode parseurl(const char *url, CURLU *u, unsigned int flags)
           result = CURLUE_OUT_OF_MEMORY;
           goto fail;
         }
+        u->guessed_scheme = TRUE;
       }
     }
     else if(flags & CURLU_NO_AUTHORITY) {
@@ -1437,6 +1437,8 @@ CURLUcode curl_url_get(const CURLU *u, CURLUPart what,
     ptr = u->scheme;
     ifmissing = CURLUE_NO_SCHEME;
     urldecode = FALSE; /* never for schemes */
+    if((flags & CURLU_NO_GUESS_SCHEME) && u->guessed_scheme)
+      return CURLUE_NO_SCHEME;
     break;
   case CURLUPART_USER:
     ptr = u->user;
@@ -1465,7 +1467,7 @@ CURLUcode curl_url_get(const CURLU *u, CURLUPart what,
     ifmissing = CURLUE_NO_PORT;
     urldecode = FALSE; /* never for port */
     if(!ptr && (flags & CURLU_DEFAULT_PORT) && u->scheme) {
-      /* there's no stored port number, but asked to deliver
+      /* there is no stored port number, but asked to deliver
          a default one for the scheme */
       const struct Curl_handler *h = Curl_get_scheme_handler(u->scheme);
       if(h) {
@@ -1525,6 +1527,7 @@ CURLUcode curl_url_get(const CURLU *u, CURLUPart what,
       return CURLUE_NO_HOST;
     else {
       const struct Curl_handler *h = NULL;
+      char schemebuf[MAX_SCHEME_LEN + 5];
       if(u->scheme)
         scheme = u->scheme;
       else if(flags & CURLU_DEFAULT_SCHEME)
@@ -1534,7 +1537,7 @@ CURLUcode curl_url_get(const CURLU *u, CURLUPart what,
 
       h = Curl_get_scheme_handler(scheme);
       if(!port && (flags & CURLU_DEFAULT_PORT)) {
-        /* there's no stored port number, but asked to deliver
+        /* there is no stored port number, but asked to deliver
            a default one for the scheme */
         if(h) {
           msnprintf(portbuf, sizeof(portbuf), "%u", h->defport);
@@ -1595,8 +1598,13 @@ CURLUcode curl_url_get(const CURLU *u, CURLUPart what,
         }
       }
 
-      url = aprintf("%s://%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
-                    scheme,
+      if(!(flags & CURLU_NO_GUESS_SCHEME) || !u->guessed_scheme)
+        msnprintf(schemebuf, sizeof(schemebuf), "%s://", scheme);
+      else
+        schemebuf[0] = 0;
+
+      url = aprintf("%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
+                    schemebuf,
                     u->user ? u->user : "",
                     u->password ? ":": "",
                     u->password ? u->password : "",
@@ -1718,6 +1726,7 @@ CURLUcode curl_url_set(CURLU *u, CURLUPart what,
       break;
     case CURLUPART_SCHEME:
       storep = &u->scheme;
+      u->guessed_scheme = FALSE;
       break;
     case CURLUPART_USER:
       storep = &u->user;
@@ -1790,6 +1799,7 @@ CURLUcode curl_url_set(CURLU *u, CURLUPart what,
     }
     else
       return CURLUE_BAD_SCHEME;
+    u->guessed_scheme = FALSE;
     break;
   }
   case CURLUPART_USER:
@@ -1862,7 +1872,7 @@ CURLUcode curl_url_set(CURLU *u, CURLUPart what,
       return CURLUE_MALFORMED_INPUT;
 
     /* if the new thing is absolute or the old one is not
-     * (we could not get an absolute url in 'oldurl'),
+     * (we could not get an absolute URL in 'oldurl'),
      * then replace the existing with the new. */
     if(Curl_is_absolute_url(part, NULL, 0,
                             flags & (CURLU_GUESS_SCHEME|
@@ -1978,7 +1988,7 @@ nomem:
     else if(what == CURLUPART_HOST) {
       size_t n = Curl_dyn_len(&enc);
       if(!n && (flags & CURLU_NO_AUTHORITY)) {
-        /* Skip hostname check, it's allowed to be empty. */
+        /* Skip hostname check, it is allowed to be empty. */
       }
       else {
         if(!n || hostname_check(u, (char *)newp, n)) {
diff --git a/lib/urldata.h b/lib/urldata.h
index 8b1bd65d6..f34aa591c 100644
--- a/lib/urldata.h
+++ b/lib/urldata.h
@@ -67,7 +67,7 @@ struct curl_trc_featt;
 #ifdef USE_WEBSOCKETS
 /* CURLPROTO_GOPHERS (29) is the highest publicly used protocol bit number,
  * the rest are internal information. If we use higher bits we only do this on
- * platforms that have a >= 64 bit type and then we use such a type for the
+ * platforms that have a >= 64-bit type and then we use such a type for the
  * protocol fields in the protocol handler.
  */
 #define CURLPROTO_WS     (1<<30)
@@ -257,22 +257,6 @@ enum protection_level {
 };
 #endif
 
-/* enum for the nonblocking SSL connection state machine */
-typedef enum {
-  ssl_connect_1,
-  ssl_connect_2,
-  ssl_connect_2_reading,
-  ssl_connect_2_writing,
-  ssl_connect_3,
-  ssl_connect_done
-} ssl_connect_state;
-
-typedef enum {
-  ssl_connection_none,
-  ssl_connection_negotiating,
-  ssl_connection_complete
-} ssl_connection_state;
-
 /* SSL backend-specific data; declared differently by each SSL backend */
 struct ssl_backend_data;
 
@@ -292,7 +276,7 @@ struct ssl_peer {
 };
 
 struct ssl_primary_config {
-  char *CApath;          /* certificate dir (doesn't work on windows) */
+  char *CApath;          /* certificate dir (does not work on windows) */
   char *CAfile;          /* certificate to verify peer against */
   char *issuercert;      /* optional issuer certificate filename */
   char *clientcert;
@@ -314,7 +298,7 @@ struct ssl_primary_config {
   BIT(verifypeer);       /* set TRUE if this is desired */
   BIT(verifyhost);       /* set TRUE if CN/SAN must match hostname */
   BIT(verifystatus);     /* set TRUE if certificate status must be checked */
-  BIT(sessionid);        /* cache session IDs or not */
+  BIT(cache_session);    /* cache session or not */
 };
 
 struct ssl_config_data {
@@ -323,7 +307,7 @@ struct ssl_config_data {
   curl_ssl_ctx_callback fsslctx; /* function to initialize ssl ctx */
   void *fsslctxp;        /* parameter for call back */
   char *cert_type; /* format for certificate (default: PEM)*/
-  char *key; /* private key file name */
+  char *key; /* private key filename */
   struct curl_blob *key_blob;
   char *key_type; /* format for private key (default: PEM) */
   char *key_passwd; /* plain text private key password */
@@ -331,7 +315,7 @@ struct ssl_config_data {
   BIT(falsestart);
   BIT(enable_beast); /* allow this flaw for interoperability's sake */
   BIT(no_revoke);    /* disable SSL certificate revocation checks */
-  BIT(no_partialchain); /* don't accept partial certificate chains */
+  BIT(no_partialchain); /* do not accept partial certificate chains */
   BIT(revoke_best_effort); /* ignore SSL revocation offline/missing revocation
                               list errors */
   BIT(native_ca_store); /* use the native ca store of operating system */
@@ -348,8 +332,8 @@ typedef void Curl_ssl_sessionid_dtor(void *sessionid, size_t idsize);
 
 /* information stored about one single SSL session */
 struct Curl_ssl_session {
-  char *name;       /* host name for which this ID was used */
-  char *conn_to_host; /* host name for the connection (may be NULL) */
+  char *name;       /* hostname for which this ID was used */
+  char *conn_to_host; /* hostname for the connection (may be NULL) */
   const char *scheme; /* protocol scheme used */
   void *sessionid;  /* as returned from the SSL layer */
   size_t idsize;    /* if known, otherwise 0 */
@@ -535,10 +519,10 @@ struct ConnectBits {
                          re-attempted at another connection. */
 #ifndef CURL_DISABLE_FTP
   BIT(ftp_use_epsv);  /* As set with CURLOPT_FTP_USE_EPSV, but if we find out
-                         EPSV doesn't work we disable it for the forthcoming
+                         EPSV does not work we disable it for the forthcoming
                          requests */
   BIT(ftp_use_eprt);  /* As set with CURLOPT_FTP_USE_EPRT, but if we find out
-                         EPRT doesn't work we disable it for the forthcoming
+                         EPRT does not work we disable it for the forthcoming
                          requests */
   BIT(ftp_use_data_ssl); /* Enabled SSL for the data connection */
   BIT(ftp_use_control_ssl); /* Enabled SSL for the control connection */
@@ -562,6 +546,9 @@ struct ConnectBits {
                          accept() */
   BIT(parallel_connect); /* set TRUE when a parallel connect attempt has
                             started (happy eyeballs) */
+  BIT(aborted); /* connection was aborted, e.g. in unclean state */
+  BIT(shutdown_handler); /* connection shutdown: handler shut down */
+  BIT(shutdown_filters); /* connection shutdown: filters shut down */
 };
 
 struct hostname {
@@ -676,7 +663,7 @@ struct Curl_handler {
   /* This function *MAY* be set to a protocol-dependent function that is run
    * after the connect() and everything is done, as a step in the connection.
    * The 'done' pointer points to a bool that should be set to TRUE if the
-   * function completes before return. If it doesn't complete, the caller
+   * function completes before return. If it does not complete, the caller
    * should call the ->connecting() function until it is.
    */
   CURLcode (*connect_it)(struct Curl_easy *data, bool *done);
@@ -707,7 +694,7 @@ struct Curl_handler {
                          struct connectdata *conn, curl_socket_t *socks);
 
   /* This function *MAY* be set to a protocol-dependent function that is run
-   * by the curl_disconnect(), as a step in the disconnection.  If the handler
+   * by the curl_disconnect(), as a step in the disconnection. If the handler
    * is called because the connection has been considered dead,
    * dead_connection is set to TRUE. The connection is (again) associated with
    * the transfer here.
@@ -755,11 +742,11 @@ struct Curl_handler {
    the send function might need to be called while uploading, or vice versa.
 */
 #define PROTOPT_DIRLOCK (1<<3)
-#define PROTOPT_NONETWORK (1<<4)   /* protocol doesn't use the network! */
+#define PROTOPT_NONETWORK (1<<4)   /* protocol does not use the network! */
 #define PROTOPT_NEEDSPWD (1<<5)    /* needs a password, and if none is set it
                                       gets a default */
-#define PROTOPT_NOURLQUERY (1<<6)   /* protocol can't handle
-                                        url query strings (?foo=bar) ! */
+#define PROTOPT_NOURLQUERY (1<<6)   /* protocol cannot handle
+                                       URL query strings (?foo=bar) ! */
 #define PROTOPT_CREDSPERREQUEST (1<<7) /* requires login credentials per
                                           request instead of per connection */
 #define PROTOPT_ALPN (1<<8) /* set ALPN for this */
@@ -771,8 +758,8 @@ struct Curl_handler {
                                          this protocol and act as a gateway */
 #define PROTOPT_WILDCARD (1<<12) /* protocol supports wildcard matching */
 #define PROTOPT_USERPWDCTRL (1<<13) /* Allow "control bytes" (< 32 ascii) in
-                                       user name and password */
-#define PROTOPT_NOTCPPROXY (1<<14) /* this protocol can't proxy over TCP */
+                                       username and password */
+#define PROTOPT_NOTCPPROXY (1<<14) /* this protocol cannot proxy over TCP */
 
 #define CONNCHECK_NONE 0                 /* No checks */
 #define CONNCHECK_ISDEAD (1<<0)          /* Check if the connection is dead. */
@@ -793,7 +780,7 @@ struct proxy_info {
   int port;
   unsigned char proxytype; /* curl_proxytype: what kind of proxy that is in
                               use */
-  char *user;    /* proxy user name string, allocated */
+  char *user;    /* proxy username string, allocated */
   char *passwd;  /* proxy password string, allocated */
 };
 
@@ -835,8 +822,8 @@ struct connectdata {
   const struct Curl_sockaddr_ex *remote_addr;
 
   struct hostname host;
-  char *hostname_resolve; /* host name to resolve to address, allocated */
-  char *secondaryhostname; /* secondary socket host name (ftp) */
+  char *hostname_resolve; /* hostname to resolve to address, allocated */
+  char *secondaryhostname; /* secondary socket hostname (ftp) */
   struct hostname conn_to_host; /* the host to connect to. valid only if
                                    bits.conn_to_host is set */
 #ifndef CURL_DISABLE_PROXY
@@ -850,7 +837,7 @@ struct connectdata {
      these are updated with data which comes directly from the socket. */
   struct ip_quadruple primary;
   struct ip_quadruple secondary;
-  char *user;    /* user name string, allocated */
+  char *user;    /* username string, allocated */
   char *passwd;  /* password string, allocated */
   char *options; /* options string, allocated */
   char *sasl_authzid;     /* authorization identity string, allocated */
@@ -863,6 +850,13 @@ struct connectdata {
   Curl_recv *recv[2];
   Curl_send *send[2];
   struct Curl_cfilter *cfilter[2]; /* connection filters */
+  struct {
+    struct curltime start[2]; /* when filter shutdown started */
+    unsigned int timeout_ms; /* 0 means no timeout */
+  } shutdown;
+  /* Last pollset used in connection shutdown. Used to detect changes
+   * for multi_socket API. */
+  struct easy_pollset shutdown_poll;
 
   struct ssl_primary_config ssl_config;
 #ifndef CURL_DISABLE_PROXY
@@ -908,11 +902,6 @@ struct connectdata {
   CtxtHandle *sslContext;
 #endif
 
-#if defined(_WIN32) && defined(USE_WINSOCK)
-  struct curltime last_sndbuf_update;  /* last time readwrite_upload called
-                                          win_update_buffer_size */
-#endif
-
 #ifdef USE_GSASL
   struct gsasldata gsasl;
 #endif
@@ -986,7 +975,7 @@ struct connectdata {
   /* When this connection is created, store the conditions for the local end
      bind. This is stored before the actual bind and before any connection is
      made and will serve the purpose of being used for comparison reasons so
-     that subsequent bound-requested connections aren't accidentally reusing
+     that subsequent bound-requested connections are not accidentally reusing
      wrong connections. */
   char *localdev;
   unsigned short localportrange;
@@ -1045,7 +1034,7 @@ struct PureInfo {
   unsigned long httpauthavail;  /* what host auth types were announced */
   long numconnects; /* how many new connection did libcurl created */
   char *contenttype; /* the content type of the object */
-  char *wouldredirect; /* URL this would've been redirected to if asked to */
+  char *wouldredirect; /* URL this would have been redirected to if asked to */
   curl_off_t retry_after; /* info from Retry-After: header */
   unsigned int header_size;  /* size of read header(s) in bytes */
 
@@ -1064,7 +1053,7 @@ struct PureInfo {
   struct curl_certinfo certs; /* info about the certs. Asked for with
                                  CURLOPT_CERTINFO / CURLINFO_CERTINFO */
   CURLproxycode pxcode;
-  BIT(timecond);  /* set to TRUE if the time condition didn't match, which
+  BIT(timecond);  /* set to TRUE if the time condition did not match, which
                      thus made the document NOT get fetched */
   BIT(used_proxy); /* the transfer used a proxy */
 };
@@ -1237,8 +1226,8 @@ struct UrlState {
   curl_off_t current_speed;  /* the ProgressShow() function sets this,
                                 bytes / second */
 
-  /* host name, port number and protocol of the first (not followed) request.
-     if set, this should be the host name that we will sent authorization to,
+  /* hostname, port number and protocol of the first (not followed) request.
+     if set, this should be the hostname that we will sent authorization to,
      no else. Used to make Location: following not keep sending user+password.
      This is strdup()ed data. */
   char *first_host;
@@ -1375,7 +1364,7 @@ struct UrlState {
   unsigned char select_bits; /* != 0 -> bitmask of socket events for this
                                  transfer overriding anything the socket may
                                  report */
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
   BIT(conncache_lock);
 #endif
   /* when curl_easy_perform() is called, the multi handle is "owned" by
@@ -1390,7 +1379,7 @@ struct UrlState {
                     called. */
   BIT(allow_port); /* Is set.use_port allowed to take effect or not. This
                       is always set TRUE when curl_easy_perform() is called. */
-  BIT(authproblem); /* TRUE if there's some problem authenticating */
+  BIT(authproblem); /* TRUE if there is some problem authenticating */
   /* set after initial USER failure, to prevent an authentication loop */
   BIT(wildcardmatch); /* enable wildcard matching */
   BIT(disableexpect);    /* TRUE if Expect: is disabled due to a previous
@@ -1428,12 +1417,12 @@ struct UrlState {
 struct Curl_multi;    /* declared in multihandle.c */
 
 enum dupstring {
-  STRING_CERT,            /* client certificate file name */
+  STRING_CERT,            /* client certificate filename */
   STRING_CERT_TYPE,       /* format for certificate (default: PEM)*/
-  STRING_KEY,             /* private key file name */
+  STRING_KEY,             /* private key filename */
   STRING_KEY_PASSWD,      /* plain text private key password */
   STRING_KEY_TYPE,        /* format for private key (default: PEM) */
-  STRING_SSL_CAPATH,      /* CA directory name (doesn't work on windows) */
+  STRING_SSL_CAPATH,      /* CA directory name (does not work on windows) */
   STRING_SSL_CAFILE,      /* certificate file to verify peer against */
   STRING_SSL_PINNEDPUBLICKEY, /* public key file to verify peer against */
   STRING_SSL_CIPHER_LIST, /* list of ciphers to use */
@@ -1442,12 +1431,12 @@ enum dupstring {
   STRING_SSL_ISSUERCERT, /* issuer cert file to check certificate */
   STRING_SERVICE_NAME,    /* Service name */
 #ifndef CURL_DISABLE_PROXY
-  STRING_CERT_PROXY,      /* client certificate file name */
+  STRING_CERT_PROXY,      /* client certificate filename */
   STRING_CERT_TYPE_PROXY, /* format for certificate (default: PEM)*/
-  STRING_KEY_PROXY,       /* private key file name */
+  STRING_KEY_PROXY,       /* private key filename */
   STRING_KEY_PASSWD_PROXY, /* plain text private key password */
   STRING_KEY_TYPE_PROXY,  /* format for private key (default: PEM) */
-  STRING_SSL_CAPATH_PROXY, /* CA directory name (doesn't work on windows) */
+  STRING_SSL_CAPATH_PROXY, /* CA directory name (does not work on windows) */
   STRING_SSL_CAFILE_PROXY, /* certificate file to verify peer against */
   STRING_SSL_PINNEDPUBLICKEY_PROXY, /* public key file to verify proxy */
   STRING_SSL_CIPHER_LIST_PROXY, /* list of ciphers to use */
@@ -1461,8 +1450,10 @@ enum dupstring {
   STRING_COOKIEJAR,       /* dump all cookies to this file */
 #endif
   STRING_CUSTOMREQUEST,   /* HTTP/FTP/RTSP request/method to use */
-  STRING_DEFAULT_PROTOCOL, /* Protocol to use when the URL doesn't specify */
+  STRING_DEFAULT_PROTOCOL, /* Protocol to use when the URL does not specify */
   STRING_DEVICE,          /* local network interface/address to use */
+  STRING_INTERFACE,       /* local network interface to use */
+  STRING_BINDHOST,        /* local address to use */
   STRING_ENCODING,        /* Accept-Encoding string */
 #ifndef CURL_DISABLE_FTP
   STRING_FTP_ACCOUNT,     /* ftp account data */
@@ -1504,7 +1495,7 @@ enum dupstring {
   STRING_SSH_PUBLIC_KEY,  /* path to the public key file for auth */
   STRING_SSH_HOST_PUBLIC_KEY_MD5, /* md5 of host public key in ascii hex */
   STRING_SSH_HOST_PUBLIC_KEY_SHA256, /* sha256 of host public key in base64 */
-  STRING_SSH_KNOWNHOSTS,  /* file name of knownhosts file */
+  STRING_SSH_KNOWNHOSTS,  /* filename of knownhosts file */
 #endif
 #ifndef CURL_DISABLE_SMTP
   STRING_MAIL_FROM,
@@ -1575,7 +1566,7 @@ enum dupblob {
 };
 
 /* callback that gets called when this easy handle is completed within a multi
-   handle.  Only used for internally created transfers, like for example
+   handle. Only used for internally created transfers, like for example
    DoH. */
 typedef int (*multidone_func)(struct Curl_easy *easy, CURLcode result);
 
@@ -1600,7 +1591,7 @@ struct UserDefined {
 #ifndef CURL_DISABLE_BINDLOCAL
   unsigned short localport; /* local port number to bind to */
   unsigned short localportrange; /* number of additional port numbers to test
-                                    in case the 'localport' one can't be
+                                    in case the 'localport' one cannot be
                                     bind()ed */
 #endif
   curl_write_callback fwrite_func;   /* function that stores the output */
@@ -1633,9 +1624,10 @@ struct UserDefined {
   void *progress_client; /* pointer to pass to the progress callback */
   void *ioctl_client;   /* pointer to pass to the ioctl callback */
   unsigned int timeout;        /* ms, 0 means no timeout */
-  unsigned int connecttimeout; /* ms, 0 means no timeout */
+  unsigned int connecttimeout; /* ms, 0 means default timeout */
   unsigned int happy_eyeballs_timeout; /* ms, 0 is a valid value */
   unsigned int server_response_timeout; /* ms, 0 means no timeout */
+  unsigned int shutdowntimeout; /* ms, 0 means default timeout */
   long maxage_conn;     /* in seconds, max idle time to allow a connection that
                            is to be reused */
   long maxlifetime_conn; /* in seconds, max time since creation to allow a
@@ -1700,7 +1692,7 @@ struct UserDefined {
   struct curl_slist *postquote; /* after the transfer */
   struct curl_slist *prequote; /* before the transfer, after type */
   /* Despite the name, ftp_create_missing_dirs is for FTP(S) and SFTP
-     1 - create directories that don't exist
+     1 - create directories that do not exist
      2 - the same but also allow MKD to fail once
   */
   unsigned char ftp_create_missing_dirs;
@@ -1747,6 +1739,7 @@ struct UserDefined {
 
   int tcp_keepidle;     /* seconds in idle before sending keepalive probe */
   int tcp_keepintvl;    /* seconds between TCP keepalive probes */
+  int tcp_keepcnt;      /* maximum number of keepalive probes */
 
   long expect_100_timeout; /* in milliseconds */
 #if defined(USE_HTTP2) || defined(USE_HTTP3)
@@ -1795,10 +1788,10 @@ struct UserDefined {
 
 /* Here follows boolean settings that define how to behave during
    this session. They are STATIC, set by libcurl users or at least initially
-   and they don't change during operations. */
+   and they do not change during operations. */
   BIT(quick_exit);       /* set 1L when it is okay to leak things (like
-                            threads), as we're about to exit() anyway and
-                            don't want lengthy cleanups to delay termination,
+                            threads), as we are about to exit() anyway and
+                            do not want lengthy cleanups to delay termination,
                             e.g. after a DNS timeout */
   BIT(get_filetime);     /* get the time and get of the remote file */
 #ifndef CURL_DISABLE_PROXY
@@ -1818,7 +1811,7 @@ struct UserDefined {
                             us */
   BIT(wildcard_enabled); /* enable wildcard matching */
 #endif
-  BIT(hide_progress);    /* don't use the progress meter */
+  BIT(hide_progress);    /* do not use the progress meter */
   BIT(http_fail_on_error);  /* fail on HTTP error codes >= 400 */
   BIT(http_keep_sending_on_error); /* for HTTP status codes >= 300 */
   BIT(http_follow_location); /* follow HTTP redirects */
@@ -1864,7 +1857,7 @@ struct UserDefined {
 #ifdef USE_UNIX_SOCKETS
   BIT(abstract_unix_socket);
 #endif
-  BIT(disallow_username_in_url); /* disallow username in url */
+  BIT(disallow_username_in_url); /* disallow username in URL */
 #ifndef CURL_DISABLE_DOH
   BIT(doh); /* DNS-over-HTTPS enabled */
   BIT(doh_verifypeer);     /* DoH certificate peer verification */
diff --git a/lib/vauth/cleartext.c b/lib/vauth/cleartext.c
index 29389c2c7..cf8108ac5 100644
--- a/lib/vauth/cleartext.c
+++ b/lib/vauth/cleartext.c
@@ -100,11 +100,11 @@ CURLcode Curl_auth_create_plain_message(const char *authzid,
  * Curl_auth_create_login_message()
  *
  * This is used to generate an already encoded LOGIN message containing the
- * user name or password ready for sending to the recipient.
+ * username or password ready for sending to the recipient.
  *
  * Parameters:
  *
- * valuep  [in]     - The user name or user's password.
+ * valuep  [in]     - The username or user's password.
  * out     [out]    - The result storage.
  *
  * Returns void.
@@ -118,11 +118,11 @@ void Curl_auth_create_login_message(const char *valuep, struct bufref *out)
  * Curl_auth_create_external_message()
  *
  * This is used to generate an already encoded EXTERNAL message containing
- * the user name ready for sending to the recipient.
+ * the username ready for sending to the recipient.
  *
  * Parameters:
  *
- * user    [in]     - The user name.
+ * user    [in]     - The username.
  * out     [out]    - The result storage.
  *
  * Returns void.
diff --git a/lib/vauth/cram.c b/lib/vauth/cram.c
index 91fb261c5..f8bdd5458 100644
--- a/lib/vauth/cram.c
+++ b/lib/vauth/cram.c
@@ -51,7 +51,7 @@
  * Parameters:
  *
  * chlg    [in]     - The challenge.
- * userp   [in]     - The user name.
+ * userp   [in]     - The username.
  * passwdp [in]     - The user's password.
  * out     [out]    - The result storage.
  *
diff --git a/lib/vauth/digest.c b/lib/vauth/digest.c
index a742cce26..f00e6651f 100644
--- a/lib/vauth/digest.c
+++ b/lib/vauth/digest.c
@@ -103,7 +103,7 @@ bool Curl_auth_digest_get_pair(const char *str, char *value, char *content,
 
       case ',':
         if(!starts_with_quote) {
-          /* This signals the end of the content if we didn't get a starting
+          /* This signals the end of the content if we did not get a starting
              quote and then we do "sloppy" parsing */
           c = 0; /* the end */
           continue;
@@ -326,7 +326,7 @@ bool Curl_auth_is_digest_supported(void)
  *
  * data    [in]     - The session handle.
  * chlg    [in]     - The challenge message.
- * userp   [in]     - The user name.
+ * userp   [in]     - The username.
  * passwdp [in]     - The user's password.
  * service [in]     - The service type such as http, smtp, pop or imap.
  * out     [out]    - The result storage.
@@ -629,7 +629,7 @@ CURLcode Curl_auth_decode_digest_http_message(const char *chlg,
       }
     }
     else
-      break; /* We're done here */
+      break; /* We are done here */
 
     /* Pass all additional spaces here */
     while(*chlg && ISBLANK(*chlg))
@@ -646,7 +646,7 @@ CURLcode Curl_auth_decode_digest_http_message(const char *chlg,
   if(before && !digest->stale)
     return CURLE_BAD_CONTENT_ENCODING;
 
-  /* We got this header without a nonce, that's a bad Digest line! */
+  /* We got this header without a nonce, that is a bad Digest line! */
   if(!digest->nonce)
     return CURLE_BAD_CONTENT_ENCODING;
 
@@ -666,7 +666,7 @@ CURLcode Curl_auth_decode_digest_http_message(const char *chlg,
  * Parameters:
  *
  * data    [in]     - The session handle.
- * userp   [in]     - The user name.
+ * userp   [in]     - The username.
  * passwdp [in]     - The user's password.
  * request [in]     - The HTTP request.
  * uripath [in]     - The path of the HTTP uri.
@@ -788,7 +788,7 @@ static CURLcode auth_create_digest_http_message(
     return CURLE_OUT_OF_MEMORY;
 
   if(digest->qop && strcasecompare(digest->qop, "auth-int")) {
-    /* We don't support auth-int for PUT or POST */
+    /* We do not support auth-int for PUT or POST */
     char hashed[65];
     char *hashthis2;
 
@@ -835,12 +835,12 @@ static CURLcode auth_create_digest_http_message(
      Authorization: Digest username="testuser", realm="testrealm", \
      nonce="1053604145", uri="/64", response="c55f7f30d83d774a3d2dcacf725abaca"
 
-     Digest parameters are all quoted strings.  Username which is provided by
+     Digest parameters are all quoted strings. Username which is provided by
      the user will need double quotes and backslashes within it escaped.
      realm, nonce, and opaque will need backslashes as well as they were
-     de-escaped when copied from request header.  cnonce is generated with
-     web-safe characters.  uri is already percent encoded.  nc is 8 hex
-     characters.  algorithm and qop with standard values only contain web-safe
+     de-escaped when copied from request header. cnonce is generated with
+     web-safe characters. uri is already percent encoded. nc is 8 hex
+     characters. algorithm and qop with standard values only contain web-safe
      characters.
   */
   userp_quoted = auth_digest_string_quoted(digest->userhash ? userh : userp);
@@ -957,7 +957,7 @@ static CURLcode auth_create_digest_http_message(
  * Parameters:
  *
  * data    [in]     - The session handle.
- * userp   [in]     - The user name.
+ * userp   [in]     - The username.
  * passwdp [in]     - The user's password.
  * request [in]     - The HTTP request.
  * uripath [in]     - The path of the HTTP uri.
diff --git a/lib/vauth/digest_sspi.c b/lib/vauth/digest_sspi.c
index 4696f29ad..181356671 100644
--- a/lib/vauth/digest_sspi.c
+++ b/lib/vauth/digest_sspi.c
@@ -81,7 +81,7 @@ bool Curl_auth_is_digest_supported(void)
  *
  * data    [in]     - The session handle.
  * chlg    [in]     - The challenge message.
- * userp   [in]     - The user name in the format User or Domain\User.
+ * userp   [in]     - The username in the format User or Domain\User.
  * passwdp [in]     - The user's password.
  * service [in]     - The service type such as http, smtp, pop or imap.
  * out     [out]    - The result storage.
@@ -122,7 +122,7 @@ CURLcode Curl_auth_create_digest_md5_message(struct Curl_easy *data,
   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_DIGEST),
                                               &SecurityPackage);
   if(status != SEC_E_OK) {
-    failf(data, "SSPI: couldn't get auth info");
+    failf(data, "SSPI: could not get auth info");
     return CURLE_AUTH_ERROR;
   }
 
@@ -291,7 +291,7 @@ CURLcode Curl_override_sspi_http_realm(const char *chlg,
         }
       }
       else
-        break; /* We're done here */
+        break; /* We are done here */
 
       /* Pass all additional spaces here */
       while(*chlg && ISBLANK(*chlg))
@@ -324,8 +324,8 @@ CURLcode Curl_auth_decode_digest_http_message(const char *chlg,
 {
   size_t chlglen = strlen(chlg);
 
-  /* We had an input token before so if there's another one now that means we
-     provided bad credentials in the previous request or it's stale. */
+  /* We had an input token before so if there is another one now that means we
+     provided bad credentials in the previous request or it is stale. */
   if(digest->input_token) {
     bool stale = false;
     const char *p = chlg;
@@ -379,7 +379,7 @@ CURLcode Curl_auth_decode_digest_http_message(const char *chlg,
  * Parameters:
  *
  * data    [in]     - The session handle.
- * userp   [in]     - The user name in the format User or Domain\User.
+ * userp   [in]     - The username in the format User or Domain\User.
  * passwdp [in]     - The user's password.
  * request [in]     - The HTTP request.
  * uripath [in]     - The path of the HTTP uri.
@@ -413,7 +413,7 @@ CURLcode Curl_auth_create_digest_http_message(struct Curl_easy *data,
   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_DIGEST),
                                               &SecurityPackage);
   if(status != SEC_E_OK) {
-    failf(data, "SSPI: couldn't get auth info");
+    failf(data, "SSPI: could not get auth info");
     return CURLE_AUTH_ERROR;
   }
 
diff --git a/lib/vauth/krb5_gssapi.c b/lib/vauth/krb5_gssapi.c
index 16b6e4037..748cdf93a 100644
--- a/lib/vauth/krb5_gssapi.c
+++ b/lib/vauth/krb5_gssapi.c
@@ -65,10 +65,10 @@ bool Curl_auth_is_gssapi_supported(void)
  * Parameters:
  *
  * data        [in]     - The session handle.
- * userp       [in]     - The user name.
+ * userp       [in]     - The username.
  * passwdp     [in]     - The user's password.
  * service     [in]     - The service type such as http, smtp, pop or imap.
- * host        [in[     - The host name.
+ * host        [in[     - The hostname.
  * mutual_auth [in]     - Flag specifying whether or not mutual authentication
  *                        is enabled.
  * chlg        [in]     - Optional challenge message.
@@ -243,7 +243,7 @@ CURLcode Curl_auth_create_gssapi_security_message(struct Curl_easy *data,
   /* Process the maximum message size the server can receive */
   if(max_size > 0) {
     /* The server has told us it supports a maximum receive buffer, however, as
-       we don't require one unless we are encrypting data, we tell the server
+       we do not require one unless we are encrypting data, we tell the server
        our receive buffer is zero. */
     max_size = 0;
   }
diff --git a/lib/vauth/krb5_sspi.c b/lib/vauth/krb5_sspi.c
index 17a517a97..430eb3ef0 100644
--- a/lib/vauth/krb5_sspi.c
+++ b/lib/vauth/krb5_sspi.c
@@ -76,10 +76,10 @@ bool Curl_auth_is_gssapi_supported(void)
  * Parameters:
  *
  * data        [in]     - The session handle.
- * userp       [in]     - The user name in the format User or Domain\User.
+ * userp       [in]     - The username in the format User or Domain\User.
  * passwdp     [in]     - The user's password.
  * service     [in]     - The service type such as http, smtp, pop or imap.
- * host        [in]     - The host name.
+ * host        [in]     - The hostname.
  * mutual_auth [in]     - Flag specifying whether or not mutual authentication
  *                        is enabled.
  * chlg        [in]     - Optional challenge message.
@@ -122,7 +122,7 @@ CURLcode Curl_auth_create_gssapi_user_message(struct Curl_easy *data,
                                                 TEXT(SP_NAME_KERBEROS),
                                                 &SecurityPackage);
     if(status != SEC_E_OK) {
-      failf(data, "SSPI: couldn't get auth info");
+      failf(data, "SSPI: could not get auth info");
       return CURLE_AUTH_ERROR;
     }
 
@@ -335,7 +335,7 @@ CURLcode Curl_auth_create_gssapi_security_message(struct Curl_easy *data,
   /* Process the maximum message size the server can receive */
   if(max_size > 0) {
     /* The server has told us it supports a maximum receive buffer, however, as
-       we don't require one unless we are encrypting data, we tell the server
+       we do not require one unless we are encrypting data, we tell the server
        our receive buffer is zero. */
     max_size = 0;
   }
diff --git a/lib/vauth/ntlm.c b/lib/vauth/ntlm.c
index 018e6a67e..abebdeda7 100644
--- a/lib/vauth/ntlm.c
+++ b/lib/vauth/ntlm.c
@@ -59,7 +59,7 @@
 /* "NTLMSSP" signature is always in ASCII regardless of the platform */
 #define NTLMSSP_SIGNATURE "\x4e\x54\x4c\x4d\x53\x53\x50"
 
-/* The fixed host name we provide, in order to not leak our real local host
+/* The fixed hostname we provide, in order to not leak our real local host
    name. Copy the name used by Firefox. */
 #define NTLM_HOSTNAME "WORKSTATION"
 
@@ -325,10 +325,10 @@ static void unicodecpy(unsigned char *dest, const char *src, size_t length)
  * Parameters:
  *
  * data    [in]     - The session handle.
- * userp   [in]     - The user name in the format User or Domain\User.
+ * userp   [in]     - The username in the format User or Domain\User.
  * passwdp [in]     - The user's password.
  * service [in]     - The service type such as http, smtp, pop or imap.
- * host    [in]     - The host name.
+ * host    [in]     - The hostname.
  * ntlm    [in/out] - The NTLM data struct being used and modified.
  * out     [out]    - The result storage.
  *
@@ -384,9 +384,9 @@ CURLcode Curl_auth_create_ntlm_type1_message(struct Curl_easy *data,
                     "%c%c"       /* 2 zeroes */
                     "%c%c"       /* host length */
                     "%c%c"       /* host allocated space */
-                    "%c%c"       /* host name offset */
+                    "%c%c"       /* hostname offset */
                     "%c%c"       /* 2 zeroes */
-                    "%s"         /* host name */
+                    "%s"         /* hostname */
                     "%s",        /* domain string */
                     0,           /* trailing zero */
                     0, 0, 0,     /* part of type-1 long */
@@ -448,7 +448,7 @@ CURLcode Curl_auth_create_ntlm_type1_message(struct Curl_easy *data,
  * Parameters:
  *
  * data    [in]     - The session handle.
- * userp   [in]     - The user name in the format User or Domain\User.
+ * userp   [in]     - The username in the format User or Domain\User.
  * passwdp [in]     - The user's password.
  * ntlm    [in/out] - The NTLM data struct being used and modified.
  * out     [out]    - The result storage.
@@ -470,7 +470,7 @@ CURLcode Curl_auth_create_ntlm_type3_message(struct Curl_easy *data,
            12    LM/LMv2 Response       security buffer
            20    NTLM/NTLMv2 Response   security buffer
            28    Target Name            security buffer
-           36    User Name              security buffer
+           36    username              security buffer
            44    Workstation Name       security buffer
           (52)   Session Key            security buffer (*)
           (60)   Flags                  long (*)
@@ -482,9 +482,9 @@ CURLcode Curl_auth_create_ntlm_type3_message(struct Curl_easy *data,
   CURLcode result = CURLE_OK;
   size_t size;
   unsigned char ntlmbuf[NTLM_BUFSIZE];
-  int lmrespoff;
+  unsigned int lmrespoff;
   unsigned char lmresp[24]; /* fixed-size */
-  int ntrespoff;
+  unsigned int ntrespoff;
   unsigned int ntresplen = 24;
   unsigned char ntresp[24]; /* fixed-size */
   unsigned char *ptr_ntresp = &ntresp[0];
@@ -517,7 +517,7 @@ CURLcode Curl_auth_create_ntlm_type3_message(struct Curl_easy *data,
   userlen = strlen(user);
 
 #ifndef NTLM_HOSTNAME
-  /* Get the machine's un-qualified host name as NTLM doesn't like the fully
+  /* Get the machine's un-qualified hostname as NTLM does not like the fully
      qualified domain name */
   if(Curl_gethostname(host, sizeof(host))) {
     infof(data, "gethostname() failed, continuing without");
@@ -585,7 +585,7 @@ CURLcode Curl_auth_create_ntlm_type3_message(struct Curl_easy *data,
       return result;
 
     Curl_ntlm_core_lm_resp(lmbuffer, &ntlm->nonce[0], lmresp);
-    ntlm->flags &= ~NTLMFLAG_NEGOTIATE_NTLM2_KEY;
+    ntlm->flags &= ~(unsigned int)NTLMFLAG_NEGOTIATE_NTLM2_KEY;
 
     /* A safer but less compatible alternative is:
      *   Curl_ntlm_core_lm_resp(ntbuffer, &ntlm->nonce[0], lmresp);
@@ -722,7 +722,7 @@ CURLcode Curl_auth_create_ntlm_type3_message(struct Curl_easy *data,
   /* Make sure that the domain, user and host strings fit in the
      buffer before we copy them there. */
   if(size + userlen + domlen + hostlen >= NTLM_BUFSIZE) {
-    failf(data, "user + domain + host name too big");
+    failf(data, "user + domain + hostname too big");
     return CURLE_OUT_OF_MEMORY;
   }
 
diff --git a/lib/vauth/ntlm_sspi.c b/lib/vauth/ntlm_sspi.c
index 92054316d..7d1d04e00 100644
--- a/lib/vauth/ntlm_sspi.c
+++ b/lib/vauth/ntlm_sspi.c
@@ -75,10 +75,10 @@ bool Curl_auth_is_ntlm_supported(void)
  * Parameters:
  *
  * data    [in]     - The session handle.
- * userp   [in]     - The user name in the format User or Domain\User.
+ * userp   [in]     - The username in the format User or Domain\User.
  * passwdp [in]     - The user's password.
  * service [in]     - The service type such as http, smtp, pop or imap.
- * host    [in]     - The host name.
+ * host    [in]     - The hostname.
  * ntlm    [in/out] - The NTLM data struct being used and modified.
  * out     [out]    - The result storage.
  *
@@ -106,7 +106,7 @@ CURLcode Curl_auth_create_ntlm_type1_message(struct Curl_easy *data,
   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_NTLM),
                                               &SecurityPackage);
   if(status != SEC_E_OK) {
-    failf(data, "SSPI: couldn't get auth info");
+    failf(data, "SSPI: could not get auth info");
     return CURLE_AUTH_ERROR;
   }
 
@@ -233,7 +233,7 @@ CURLcode Curl_auth_decode_ntlm_type2_message(struct Curl_easy *data,
  * Parameters:
  *
  * data    [in]     - The session handle.
- * userp   [in]     - The user name in the format User or Domain\User.
+ * userp   [in]     - The username in the format User or Domain\User.
  * passwdp [in]     - The user's password.
  * ntlm    [in/out] - The NTLM data struct being used and modified.
  * out     [out]    - The result storage.
diff --git a/lib/vauth/oauth2.c b/lib/vauth/oauth2.c
index a4adbdcf1..dc94afa36 100644
--- a/lib/vauth/oauth2.c
+++ b/lib/vauth/oauth2.c
@@ -49,8 +49,8 @@
  *
  * Parameters:
  *
- * user[in]         - The user name.
- * host[in]         - The host name.
+ * user[in]         - The username.
+ * host[in]         - The hostname.
  * port[in]         - The port(when not Port 80).
  * bearer[in]       - The bearer token.
  * out[out]         - The result storage.
@@ -87,7 +87,7 @@ CURLcode Curl_auth_create_oauth_bearer_message(const char *user,
  *
  * Parameters:
  *
- * user[in]         - The user name.
+ * user[in]         - The username.
  * bearer[in]       - The bearer token.
  * out[out]         - The result storage.
  *
diff --git a/lib/vauth/spnego_gssapi.c b/lib/vauth/spnego_gssapi.c
index e1d52b755..23822838b 100644
--- a/lib/vauth/spnego_gssapi.c
+++ b/lib/vauth/spnego_gssapi.c
@@ -65,10 +65,10 @@ bool Curl_auth_is_spnego_supported(void)
  * Parameters:
  *
  * data        [in]     - The session handle.
- * userp       [in]     - The user name in the format User or Domain\User.
+ * userp       [in]     - The username in the format User or Domain\User.
  * passwdp     [in]     - The user's password.
  * service     [in]     - The service type such as http, smtp, pop or imap.
- * host        [in]     - The host name.
+ * host        [in]     - The hostname.
  * chlg64      [in]     - The optional base64 encoded challenge message.
  * nego        [in/out] - The Negotiate data struct being used and modified.
  *
@@ -97,8 +97,8 @@ CURLcode Curl_auth_decode_spnego_message(struct Curl_easy *data,
 
   if(nego->context && nego->status == GSS_S_COMPLETE) {
     /* We finished successfully our part of authentication, but server
-     * rejected it (since we're again here). Exit with an error since we
-     * can't invent anything better */
+     * rejected it (since we are again here). Exit with an error since we
+     * cannot invent anything better */
     Curl_auth_cleanup_spnego(nego);
     return CURLE_LOGIN_DENIED;
   }
diff --git a/lib/vauth/spnego_sspi.c b/lib/vauth/spnego_sspi.c
index d3245d0b1..a2c7072c5 100644
--- a/lib/vauth/spnego_sspi.c
+++ b/lib/vauth/spnego_sspi.c
@@ -79,10 +79,10 @@ bool Curl_auth_is_spnego_supported(void)
  * Parameters:
  *
  * data        [in]     - The session handle.
- * user        [in]     - The user name in the format User or Domain\User.
+ * user        [in]     - The username in the format User or Domain\User.
  * password    [in]     - The user's password.
  * service     [in]     - The service type such as http, smtp, pop or imap.
- * host        [in]     - The host name.
+ * host        [in]     - The hostname.
  * chlg64      [in]     - The optional base64 encoded challenge message.
  * nego        [in/out] - The Negotiate data struct being used and modified.
  *
@@ -113,8 +113,8 @@ CURLcode Curl_auth_decode_spnego_message(struct Curl_easy *data,
 
   if(nego->context && nego->status == SEC_E_OK) {
     /* We finished successfully our part of authentication, but server
-     * rejected it (since we're again here). Exit with an error since we
-     * can't invent anything better */
+     * rejected it (since we are again here). Exit with an error since we
+     * cannot invent anything better */
     Curl_auth_cleanup_spnego(nego);
     return CURLE_LOGIN_DENIED;
   }
@@ -128,11 +128,11 @@ CURLcode Curl_auth_decode_spnego_message(struct Curl_easy *data,
 
   if(!nego->output_token) {
     /* Query the security package for Negotiate */
-    nego->status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *)
-                                                      TEXT(SP_NAME_NEGOTIATE),
-                                                      &SecurityPackage);
+    nego->status = (DWORD)s_pSecFn->QuerySecurityPackageInfo((TCHAR *)
+                                                       TEXT(SP_NAME_NEGOTIATE),
+                                                       &SecurityPackage);
     if(nego->status != SEC_E_OK) {
-      failf(data, "SSPI: couldn't get auth info");
+      failf(data, "SSPI: could not get auth info");
       return CURLE_AUTH_ERROR;
     }
 
@@ -168,7 +168,7 @@ CURLcode Curl_auth_decode_spnego_message(struct Curl_easy *data,
       return CURLE_OUT_OF_MEMORY;
 
     /* Acquire our credentials handle */
-    nego->status =
+    nego->status = (DWORD)
       s_pSecFn->AcquireCredentialsHandle(NULL,
                                          (TCHAR *)TEXT(SP_NAME_NEGOTIATE),
                                          SECPKG_CRED_OUTBOUND, NULL,
@@ -218,7 +218,7 @@ CURLcode Curl_auth_decode_spnego_message(struct Curl_easy *data,
       SEC_CHANNEL_BINDINGS channelBindings;
       SecPkgContext_Bindings pkgBindings;
       pkgBindings.Bindings = &channelBindings;
-      nego->status = s_pSecFn->QueryContextAttributes(
+      nego->status = (DWORD)s_pSecFn->QueryContextAttributes(
           nego->sslContext,
           SECPKG_ATTR_ENDPOINT_BINDINGS,
           &pkgBindings
@@ -242,7 +242,7 @@ CURLcode Curl_auth_decode_spnego_message(struct Curl_easy *data,
   resp_buf.cbBuffer   = curlx_uztoul(nego->token_max);
 
   /* Generate our challenge-response message */
-  nego->status = s_pSecFn->InitializeSecurityContext(nego->credentials,
+  nego->status = (DWORD)s_pSecFn->InitializeSecurityContext(nego->credentials,
                                                      chlg ? nego->context :
                                                             NULL,
                                                      nego->spn,
@@ -259,7 +259,7 @@ CURLcode Curl_auth_decode_spnego_message(struct Curl_easy *data,
   if(GSS_ERROR(nego->status)) {
     char buffer[STRERROR_LEN];
     failf(data, "InitializeSecurityContext failed: %s",
-          Curl_sspi_strerror(nego->status, buffer, sizeof(buffer)));
+          Curl_sspi_strerror((int)nego->status, buffer, sizeof(buffer)));
 
     if(nego->status == (DWORD)SEC_E_INSUFFICIENT_MEMORY)
       return CURLE_OUT_OF_MEMORY;
@@ -269,11 +269,12 @@ CURLcode Curl_auth_decode_spnego_message(struct Curl_easy *data,
 
   if(nego->status == SEC_I_COMPLETE_NEEDED ||
      nego->status == SEC_I_COMPLETE_AND_CONTINUE) {
-    nego->status = s_pSecFn->CompleteAuthToken(nego->context, &resp_desc);
+    nego->status = (DWORD)s_pSecFn->CompleteAuthToken(nego->context,
+                                                      &resp_desc);
     if(GSS_ERROR(nego->status)) {
       char buffer[STRERROR_LEN];
       failf(data, "CompleteAuthToken failed: %s",
-            Curl_sspi_strerror(nego->status, buffer, sizeof(buffer)));
+            Curl_sspi_strerror((int)nego->status, buffer, sizeof(buffer)));
 
       if(nego->status == (DWORD)SEC_E_INSUFFICIENT_MEMORY)
         return CURLE_OUT_OF_MEMORY;
diff --git a/lib/vauth/vauth.c b/lib/vauth/vauth.c
index 62fc7c40f..ace43c47d 100644
--- a/lib/vauth/vauth.c
+++ b/lib/vauth/vauth.c
@@ -48,7 +48,7 @@
  * Parameters:
  *
  * service  [in] - The service type such as http, smtp, pop or imap.
- * host     [in] - The host name.
+ * host     [in] - The hostname.
  * realm    [in] - The realm.
  *
  * Returns a pointer to the newly allocated SPN.
@@ -93,7 +93,7 @@ TCHAR *Curl_auth_build_spn(const char *service, const char *host,
     return NULL;
 
   /* Allocate and return a TCHAR based SPN. Since curlx_convert_UTF8_to_tchar
-     must be freed by curlx_unicodefree we'll dupe the result so that the
+     must be freed by curlx_unicodefree we will dupe the result so that the
      pointer this function returns can be normally free'd. */
   tchar_spn = curlx_convert_UTF8_to_tchar(utf8_spn);
   free(utf8_spn);
@@ -115,14 +115,14 @@ TCHAR *Curl_auth_build_spn(const char *service, const char *host,
  * Domain/User (curl Down-level format - for compatibility with existing code)
  * User@Domain (User Principal Name)
  *
- * Note: The user name may be empty when using a GSS-API library or Windows
+ * Note: The username may be empty when using a GSS-API library or Windows
  * SSPI as the user and domain are either obtained from the credentials cache
  * when using GSS-API or via the currently logged in user's credentials when
  * using Windows SSPI.
  *
  * Parameters:
  *
- * user  [in] - The user name.
+ * user  [in] - The username.
  *
  * Returns TRUE on success; otherwise FALSE.
  */
diff --git a/lib/version.c b/lib/version.c
index a5c8c4e61..c0d822dc8 100644
--- a/lib/version.c
+++ b/lib/version.c
@@ -258,10 +258,11 @@ char *curl_version(void)
     api.ldapai_info_version = LDAP_API_INFO_VERSION;
 
     if(ldap_get_option(NULL, LDAP_OPT_API_INFO, &api) == LDAP_OPT_SUCCESS) {
-      unsigned int patch = api.ldapai_vendor_version % 100;
-      unsigned int major = api.ldapai_vendor_version / 10000;
+      unsigned int patch = (unsigned int)(api.ldapai_vendor_version % 100);
+      unsigned int major = (unsigned int)(api.ldapai_vendor_version / 10000);
       unsigned int minor =
-        ((api.ldapai_vendor_version - major * 10000) - patch) / 100;
+        (((unsigned int)api.ldapai_vendor_version - major * 10000)
+          - patch) / 100;
       msnprintf(ldap_buf, sizeof(ldap_buf), "%s/%u.%u.%u",
                 api.ldapai_vendor_name, major, minor, patch);
       src[i++] = ldap_buf;
@@ -394,7 +395,7 @@ static const char * const supported_protocols[] = {
 };
 
 /*
- * Feature presence run-time check functions.
+ * Feature presence runtime check functions.
  *
  * Warning: the value returned by these should not change between
  * curl_global_init() and curl_global_cleanup() calls.
@@ -540,7 +541,7 @@ static curl_version_info_data version_info = {
   LIBCURL_VERSION,
   LIBCURL_VERSION_NUM,
   OS,   /* as found by configure or set by hand at build-time */
-  0,    /* features bitmask is built at run-time */
+  0,    /* features bitmask is built at runtime */
   NULL, /* ssl_version */
   0,    /* ssl_version_num, this is kept at zero */
   NULL, /* zlib_version */
@@ -596,7 +597,7 @@ curl_version_info_data *curl_version_info(CURLversion stamp)
   static char zstd_buffer[80];
 #endif
 
-  (void)stamp; /* avoid compiler warnings, we don't use this */
+  (void)stamp; /* avoid compiler warnings, we do not use this */
 
 #ifdef USE_SSL
   Curl_ssl_version(ssl_buffer, sizeof(ssl_buffer));
@@ -640,7 +641,7 @@ curl_version_info_data *curl_version_info(CURLversion stamp)
 #ifdef USE_NGHTTP2
   {
     nghttp2_info *h2 = nghttp2_version(0);
-    version_info.nghttp2_ver_num = h2->version_num;
+    version_info.nghttp2_ver_num = (unsigned int)h2->version_num;
     version_info.nghttp2_version = h2->version_str;
   }
 #endif
diff --git a/lib/version_win32.c b/lib/version_win32.c
index e0f239e15..10fd0b1f1 100644
--- a/lib/version_win32.c
+++ b/lib/version_win32.c
@@ -30,8 +30,10 @@
 #include "version_win32.h"
 #include "warnless.h"
 
-/* The last #include files should be: */
+/* The last 2 #include files should be in this order */
+#ifdef BUILDING_LIBCURL
 #include "curl_memory.h"
+#endif
 #include "memdebug.h"
 
 /* This Unicode version struct works for VerifyVersionInfoW (OSVERSIONINFOEXW)
@@ -63,7 +65,7 @@ struct OUR_OSVERSIONINFOEXW {
  *                     ignored.
  * platform     [in] - The optional platform identifier.
  * condition    [in] - The test condition used to specifier whether we are
- *                     checking a version less then, equal to or greater than
+ *                     checking a version less than, equal to or greater than
  *                     what is specified in the major and minor version
  *                     numbers.
  *
@@ -78,13 +80,13 @@ bool curlx_verify_windows_version(const unsigned int majorVersion,
   bool matched = FALSE;
 
 #if defined(CURL_WINDOWS_APP)
-  (void)buildVersion;
-
   /* We have no way to determine the Windows version from Windows apps,
-     so let's assume we're running on the target Windows version. */
+     so let's assume we are running on the target Windows version. */
   const WORD fullVersion = MAKEWORD(minorVersion, majorVersion);
   const WORD targetVersion = (WORD)_WIN32_WINNT;
 
+  (void)buildVersion;
+
   switch(condition) {
   case VERSION_LESS_THAN:
     matched = targetVersion < fullVersion;
@@ -108,7 +110,7 @@ bool curlx_verify_windows_version(const unsigned int majorVersion,
   }
 
   if(matched && (platform == PLATFORM_WINDOWS)) {
-    /* we're always running on PLATFORM_WINNT */
+    /* we are always running on PLATFORM_WINNT */
     matched = FALSE;
   }
 #elif !defined(_WIN32_WINNT) || !defined(_WIN32_WINNT_WIN2K) || \
diff --git a/lib/vquic/curl_msh3.c b/lib/vquic/curl_msh3.c
index d49af6ea4..b707a6ebe 100644
--- a/lib/vquic/curl_msh3.c
+++ b/lib/vquic/curl_msh3.c
@@ -293,7 +293,7 @@ static const MSH3_REQUEST_IF msh3_request_if = {
   msh3_data_sent
 };
 
-/* Decode HTTP status code.  Returns -1 if no valid status code was
+/* Decode HTTP status code. Returns -1 if no valid status code was
    decoded. (duplicate from http2.c) */
 static int decode_status_code(const char *value, size_t len)
 {
@@ -689,7 +689,7 @@ static ssize_t cf_msh3_send(struct Curl_cfilter *cf, struct Curl_easy *data,
     }
 
     /* TODO - msh3/msquic will hold onto this memory until the send complete
-       event. How do we make sure curl doesn't free it until then? */
+       event. How do we make sure curl does not free it until then? */
     *err = CURLE_OK;
     nwritten = len;
   }
@@ -840,7 +840,7 @@ static CURLcode cf_connect_start(struct Curl_cfilter *cf,
 
   ctx->api = MsH3ApiOpen();
   if(!ctx->api) {
-    failf(data, "can't create msh3 api");
+    failf(data, "cannot create msh3 api");
     return CURLE_FAILED_INIT;
   }
 
@@ -851,7 +851,7 @@ static CURLcode cf_connect_start(struct Curl_cfilter *cf,
                                   &addr,
                                   !verify);
   if(!ctx->qconn) {
-    failf(data, "can't create msh3 connection");
+    failf(data, "cannot create msh3 connection");
     if(ctx->api) {
       MsH3ApiClose(ctx->api);
       ctx->api = NULL;
@@ -883,7 +883,7 @@ static CURLcode cf_msh3_connect(struct Curl_cfilter *cf,
   CF_DATA_SAVE(save, cf, data);
 
   if(ctx->sock[SP_LOCAL] == CURL_SOCKET_BAD) {
-    if(Curl_socketpair(AF_UNIX, SOCK_STREAM, 0, &ctx->sock[0]) < 0) {
+    if(Curl_socketpair(AF_UNIX, SOCK_STREAM, 0, &ctx->sock[0], FALSE) < 0) {
       ctx->sock[SP_LOCAL] = CURL_SOCKET_BAD;
       ctx->sock[SP_REMOTE] = CURL_SOCKET_BAD;
       return CURLE_COULDNT_CONNECT;
@@ -1038,6 +1038,7 @@ struct Curl_cftype Curl_cft_http3 = {
   cf_msh3_destroy,
   cf_msh3_connect,
   cf_msh3_close,
+  Curl_cf_def_shutdown,
   Curl_cf_def_get_host,
   cf_msh3_adjust_pollset,
   cf_msh3_data_pending,
diff --git a/lib/vquic/curl_ngtcp2.c b/lib/vquic/curl_ngtcp2.c
index 0d9d87f34..1f67f2362 100644
--- a/lib/vquic/curl_ngtcp2.c
+++ b/lib/vquic/curl_ngtcp2.c
@@ -88,7 +88,7 @@
 /* The pool keeps spares around and half of a full stream windows
  * seems good. More does not seem to improve performance.
  * The benefit of the pool is that stream buffer to not keep
- * spares. So memory consumption goes down when streams run empty,
+ * spares. Memory consumption goes down when streams run empty,
  * have a large upload done, etc. */
 #define H3_STREAM_POOL_SPARES \
           (H3_STREAM_WINDOW_SIZE / H3_STREAM_CHUNK_SIZE ) / 2
@@ -138,7 +138,7 @@ struct cf_ngtcp2_ctx {
   uint64_t used_bidi_streams;        /* bidi streams we have opened */
   uint64_t max_bidi_streams;         /* max bidi streams we can open */
   int qlogfd;
-  BIT(conn_closed);                  /* connection is closed */
+  BIT(shutdown_started);             /* queued shutdown packets */
 };
 
 /* How to access `call_data` from a cf_ngtcp2 filter */
@@ -162,7 +162,6 @@ struct h3_stream_ctx {
   struct bufq sendbuf;   /* h3 request body */
   struct h1_req_parser h1; /* h1 request parsing */
   size_t sendbuf_len_in_flight; /* sendbuf amount "in flight" */
-  size_t upload_blocked_len; /* the amount written last and EGAINed */
   curl_uint64_t error3; /* HTTP/3 stream error code */
   curl_off_t upload_left; /* number of request bytes left to upload */
   int status_code; /* HTTP status code */
@@ -198,7 +197,7 @@ static CURLcode h3_data_setup(struct Curl_cfilter *cf,
   struct cf_ngtcp2_ctx *ctx = cf->ctx;
   struct h3_stream_ctx *stream = H3_STREAM_CTX(ctx, data);
 
-  if(!data || !data->req.p.http) {
+  if(!data) {
     failf(data, "initialization failure, transfer not http initialized");
     return CURLE_FAILED_INIT;
   }
@@ -326,8 +325,8 @@ static void pktx_update_time(struct pkt_io_ctx *pktx,
   struct cf_ngtcp2_ctx *ctx = cf->ctx;
 
   vquic_ctx_update_time(&ctx->q);
-  pktx->ts = ctx->q.last_op.tv_sec * NGTCP2_SECONDS +
-             ctx->q.last_op.tv_usec * NGTCP2_MICROSECONDS;
+  pktx->ts = (ngtcp2_tstamp)ctx->q.last_op.tv_sec * NGTCP2_SECONDS +
+             (ngtcp2_tstamp)ctx->q.last_op.tv_usec * NGTCP2_MICROSECONDS;
 }
 
 static void pktx_init(struct pkt_io_ctx *pktx,
@@ -417,7 +416,7 @@ static void quic_settings(struct cf_ngtcp2_ctx *ctx,
   }
 }
 
-static int init_ngh3_conn(struct Curl_cfilter *cf);
+static CURLcode init_ngh3_conn(struct Curl_cfilter *cf);
 
 static int cb_handshake_completed(ngtcp2_conn *tconn, void *user_data)
 {
@@ -506,8 +505,8 @@ static int cb_recv_stream_data(ngtcp2_conn *tconn, uint32_t flags,
   /* number of bytes inside buflen which consists of framing overhead
    * including QPACK HEADERS. In other words, it does not consume payload of
    * DATA frame. */
-  ngtcp2_conn_extend_max_stream_offset(tconn, stream_id, nconsumed);
-  ngtcp2_conn_extend_max_offset(tconn, nconsumed);
+  ngtcp2_conn_extend_max_stream_offset(tconn, stream_id, (uint64_t)nconsumed);
+  ngtcp2_conn_extend_max_offset(tconn, (uint64_t)nconsumed);
 
   return 0;
 }
@@ -663,7 +662,7 @@ static void cb_rand(uint8_t *dest, size_t destlen,
 
   result = Curl_rand(NULL, dest, destlen);
   if(result) {
-    /* cb_rand is only used for non-cryptographic context.  If Curl_rand
+    /* cb_rand is only used for non-cryptographic context. If Curl_rand
        failed, just fill 0 and call it *random*. */
     memset(dest, 0, destlen);
   }
@@ -798,7 +797,8 @@ static CURLcode check_and_set_expiry(struct Curl_cfilter *cf,
       if(timeout % NGTCP2_MILLISECONDS) {
         timeout += NGTCP2_MILLISECONDS;
       }
-      Curl_expire(data, timeout / NGTCP2_MILLISECONDS, EXPIRE_QUIC);
+      Curl_expire(data, (timediff_t)(timeout / NGTCP2_MILLISECONDS),
+                  EXPIRE_QUIC);
     }
   }
   return CURLE_OK;
@@ -815,6 +815,9 @@ static void cf_ngtcp2_adjust_pollset(struct Curl_cfilter *cf,
     return;
 
   Curl_pollset_check(data, ps, ctx->q.sockfd, &want_recv, &want_send);
+  if(!want_send && !Curl_bufq_is_empty(&ctx->q.sendbuf))
+    want_send = TRUE;
+
   if(want_recv || want_send) {
     struct h3_stream_ctx *stream = H3_STREAM_CTX(ctx, data);
     struct cf_call_data save;
@@ -954,7 +957,7 @@ static int cb_h3_end_headers(nghttp3_conn *conn, int64_t sid,
 
   if(!stream)
     return 0;
-  /* add a CRLF only if we've received some headers */
+  /* add a CRLF only if we have received some headers */
   h3_xfer_write_resp_hd(cf, data, stream, STRCONST("\r\n"), stream->closed);
 
   CURL_TRC_CF(data, cf, "[%" CURL_PRId64 "] end_headers, status=%d",
@@ -1091,7 +1094,7 @@ static nghttp3_callbacks ngh3_callbacks = {
   NULL /* recv_settings */
 };
 
-static int init_ngh3_conn(struct Curl_cfilter *cf)
+static CURLcode init_ngh3_conn(struct Curl_cfilter *cf)
 {
   struct cf_ngtcp2_ctx *ctx = cf->ctx;
   CURLcode result;
@@ -1202,7 +1205,7 @@ static ssize_t cf_ngtcp2_recv(struct Curl_cfilter *cf, struct Curl_easy *data,
 
   pktx_init(&pktx, cf, data);
 
-  if(!stream || ctx->conn_closed) {
+  if(!stream || ctx->shutdown_started) {
     *err = CURLE_RECV_ERROR;
     goto out;
   }
@@ -1268,8 +1271,8 @@ static int cb_h3_acked_req_body(nghttp3_conn *conn, int64_t stream_id,
   Curl_bufq_skip(&stream->sendbuf, skiplen);
   stream->sendbuf_len_in_flight -= skiplen;
 
-  /* Everything ACKed, we resume upload processing */
-  if(!stream->sendbuf_len_in_flight) {
+  /* Resume upload processing if we have more data to send */
+  if(stream->sendbuf_len_in_flight < Curl_bufq_len(&stream->sendbuf)) {
     int rv = nghttp3_conn_resume_stream(conn, stream_id);
     if(rv && rv != NGHTTP3_ERR_STREAM_NOT_FOUND) {
       return NGTCP2_ERR_CALLBACK_FAILURE;
@@ -1504,7 +1507,7 @@ static ssize_t cf_ngtcp2_send(struct Curl_cfilter *cf, struct Curl_easy *data,
   }
 
   if(!stream || stream->id < 0) {
-    if(ctx->conn_closed) {
+    if(ctx->shutdown_started) {
       CURL_TRC_CF(data, cf, "cannot open stream on closed connection");
       *err = CURLE_SEND_ERROR;
       sent = -1;
@@ -1524,21 +1527,6 @@ static ssize_t cf_ngtcp2_send(struct Curl_cfilter *cf, struct Curl_easy *data,
     sent = -1;
     goto out;
   }
-  else if(stream->upload_blocked_len) {
-    /* the data in `buf` has already been submitted or added to the
-     * buffers, but have been EAGAINed on the last invocation. */
-    DEBUGASSERT(len >= stream->upload_blocked_len);
-    if(len < stream->upload_blocked_len) {
-      /* Did we get called again with a smaller `len`? This should not
-       * happen. We are not prepared to handle that. */
-      failf(data, "HTTP/3 send again with decreased length");
-      *err = CURLE_HTTP3;
-      sent = -1;
-      goto out;
-    }
-    sent = (ssize_t)stream->upload_blocked_len;
-    stream->upload_blocked_len = 0;
-  }
   else if(stream->closed) {
     if(stream->resp_hds_complete) {
       /* Server decided to close the stream after having sent us a final
@@ -1558,7 +1546,7 @@ static ssize_t cf_ngtcp2_send(struct Curl_cfilter *cf, struct Curl_easy *data,
     sent = -1;
     goto out;
   }
-  else if(ctx->conn_closed) {
+  else if(ctx->shutdown_started) {
     CURL_TRC_CF(data, cf, "cannot send on closed connection");
     *err = CURLE_SEND_ERROR;
     sent = -1;
@@ -1582,18 +1570,6 @@ static ssize_t cf_ngtcp2_send(struct Curl_cfilter *cf, struct Curl_easy *data,
     sent = -1;
   }
 
-  if(stream && sent > 0 && stream->sendbuf_len_in_flight) {
-    /* We have unacknowledged DATA and cannot report success to our
-     * caller. Instead we EAGAIN and remember how much we have already
-     * "written" into our various internal connection buffers. */
-    stream->upload_blocked_len = sent;
-    CURL_TRC_CF(data, cf, "[%" CURL_PRId64 "] cf_send(len=%zu), "
-                "%zu bytes in flight -> EGAIN", stream->id, len,
-                stream->sendbuf_len_in_flight);
-    *err = CURLE_AGAIN;
-    sent = -1;
-  }
-
 out:
   result = check_and_set_expiry(cf, data, &pktx);
   if(result) {
@@ -1631,7 +1607,7 @@ static CURLcode recv_pkt(const unsigned char *pkt, size_t pktlen,
 
   ++pktx->pkt_count;
   ngtcp2_addr_init(&path.local, (struct sockaddr *)&ctx->q.local_addr,
-                   ctx->q.local_addrlen);
+                   (socklen_t)ctx->q.local_addrlen);
   ngtcp2_addr_init(&path.remote, (struct sockaddr *)remote_addr,
                    remote_addrlen);
   pi.ecn = (uint8_t)ecn;
@@ -1867,7 +1843,7 @@ static CURLcode cf_progress_egress(struct Curl_cfilter *cf,
     DEBUGASSERT(nread > 0);
     if(pktcnt == 0) {
       /* first packet in buffer. This is either of a known, "good"
-       * payload size or it is a PMTUD. We'll see. */
+       * payload size or it is a PMTUD. We will see. */
       gsolen = (size_t)nread;
     }
     else if((size_t)nread > gsolen ||
@@ -1961,7 +1937,8 @@ static CURLcode cf_ngtcp2_data_event(struct Curl_cfilter *cf,
     struct h3_stream_ctx *stream = H3_STREAM_CTX(ctx, data);
     if(stream && !stream->send_closed) {
       stream->send_closed = TRUE;
-      stream->upload_left = Curl_bufq_len(&stream->sendbuf);
+      stream->upload_left = Curl_bufq_len(&stream->sendbuf) -
+        stream->sendbuf_len_in_flight;
       (void)nghttp3_conn_resume_stream(ctx->h3conn, stream->id);
     }
     break;
@@ -2007,29 +1984,97 @@ static void cf_ngtcp2_ctx_clear(struct cf_ngtcp2_ctx *ctx)
   ctx->call_data = save;
 }
 
-static void cf_ngtcp2_conn_close(struct Curl_cfilter *cf,
-                                 struct Curl_easy *data)
+static CURLcode cf_ngtcp2_shutdown(struct Curl_cfilter *cf,
+                                   struct Curl_easy *data, bool *done)
 {
   struct cf_ngtcp2_ctx *ctx = cf->ctx;
-  if(ctx && ctx->qconn && !ctx->conn_closed) {
+  struct cf_call_data save;
+  struct pkt_io_ctx pktx;
+  CURLcode result = CURLE_OK;
+
+  if(cf->shutdown || !ctx->qconn) {
+    *done = TRUE;
+    return CURLE_OK;
+  }
+
+  CF_DATA_SAVE(save, cf, data);
+  *done = FALSE;
+  pktx_init(&pktx, cf, data);
+
+  if(!ctx->shutdown_started) {
     char buffer[NGTCP2_MAX_UDP_PAYLOAD_SIZE];
-    struct pkt_io_ctx pktx;
-    ngtcp2_ssize rc;
-
-    ctx->conn_closed = TRUE;
-    pktx_init(&pktx, cf, data);
-    rc = ngtcp2_conn_write_connection_close(ctx->qconn, NULL, /* path */
-                                            NULL, /* pkt_info */
-                                            (uint8_t *)buffer, sizeof(buffer),
-                                            &ctx->last_error, pktx.ts);
-    CURL_TRC_CF(data, cf, "closing connection(err_type=%d, err_code=%"
+    ngtcp2_ssize nwritten;
+
+    if(!Curl_bufq_is_empty(&ctx->q.sendbuf)) {
+      CURL_TRC_CF(data, cf, "shutdown, flushing sendbuf");
+      result = cf_progress_egress(cf, data, &pktx);
+      if(!Curl_bufq_is_empty(&ctx->q.sendbuf)) {
+        CURL_TRC_CF(data, cf, "sending shutdown packets blocked");
+        result = CURLE_OK;
+        goto out;
+      }
+      else if(result) {
+        CURL_TRC_CF(data, cf, "shutdown, error %d flushing sendbuf", result);
+        *done = TRUE;
+        goto out;
+      }
+    }
+
+    ctx->shutdown_started = TRUE;
+    nwritten = ngtcp2_conn_write_connection_close(
+      ctx->qconn, NULL, /* path */
+      NULL, /* pkt_info */
+      (uint8_t *)buffer, sizeof(buffer),
+      &ctx->last_error, pktx.ts);
+    CURL_TRC_CF(data, cf, "start shutdown(err_type=%d, err_code=%"
                 CURL_PRIu64 ") -> %d", ctx->last_error.type,
-                (curl_uint64_t)ctx->last_error.error_code, (int)rc);
-    if(rc > 0) {
-      while((send(ctx->q.sockfd, buffer, (SEND_TYPE_ARG3)rc, 0) == -1) &&
-            SOCKERRNO == EINTR);
+                (curl_uint64_t)ctx->last_error.error_code, (int)nwritten);
+    if(nwritten > 0) {
+      Curl_bufq_write(&ctx->q.sendbuf, (const unsigned char *)buffer,
+                      (size_t)nwritten, &result);
+      if(result) {
+        CURL_TRC_CF(data, cf, "error %d adding shutdown packets to sendbuf, "
+                    "aborting shutdown", result);
+        goto out;
+      }
+      ctx->q.no_gso = TRUE;
+      ctx->q.gsolen = (size_t)nwritten;
+      ctx->q.split_len = 0;
     }
   }
+
+  if(!Curl_bufq_is_empty(&ctx->q.sendbuf)) {
+    CURL_TRC_CF(data, cf, "shutdown, flushing egress");
+    result = vquic_flush(cf, data, &ctx->q);
+    if(result == CURLE_AGAIN) {
+      CURL_TRC_CF(data, cf, "sending shutdown packets blocked");
+      result = CURLE_OK;
+      goto out;
+    }
+    else if(result) {
+      CURL_TRC_CF(data, cf, "shutdown, error %d flushing sendbuf", result);
+      *done = TRUE;
+      goto out;
+    }
+  }
+
+  if(Curl_bufq_is_empty(&ctx->q.sendbuf)) {
+    /* Sent everything off. ngtcp2 seems to have no support for graceful
+     * shutdowns. So, we are done. */
+    CURL_TRC_CF(data, cf, "shutdown completely sent off, done");
+    *done = TRUE;
+    result = CURLE_OK;
+  }
+out:
+  CF_DATA_RESTORE(cf, save);
+  return result;
+}
+
+static void cf_ngtcp2_conn_close(struct Curl_cfilter *cf,
+                                 struct Curl_easy *data)
+{
+  bool done;
+  cf_ngtcp2_shutdown(cf, data, &done);
 }
 
 static void cf_ngtcp2_close(struct Curl_cfilter *cf, struct Curl_easy *data)
@@ -2105,7 +2150,7 @@ static CURLcode tls_ctx_setup(struct Curl_cfilter *cf,
     return CURLE_FAILED_INIT;
   }
 #endif /* !OPENSSL_IS_BORINGSSL && !OPENSSL_IS_AWSLC */
-  /* Enable the session cache because it's a prerequisite for the
+  /* Enable the session cache because it is a prerequisite for the
    * "new session" callback. Use the "external storage" mode to prevent
    * OpenSSL from creating an internal session cache.
    */
@@ -2120,7 +2165,7 @@ static CURLcode tls_ctx_setup(struct Curl_cfilter *cf,
     return CURLE_FAILED_INIT;
   }
 #elif defined(USE_WOLFSSL)
-  if(ngtcp2_crypto_wolfssl_configure_client_context(ctx->ssl_ctx) != 0) {
+  if(ngtcp2_crypto_wolfssl_configure_client_context(ctx->wssl.ctx) != 0) {
     failf(data, "ngtcp2_crypto_wolfssl_configure_client_context failed");
     return CURLE_FAILED_INIT;
   }
@@ -2196,7 +2241,7 @@ static CURLcode cf_connect_start(struct Curl_cfilter *cf,
                    (struct sockaddr *)&ctx->q.local_addr,
                    ctx->q.local_addrlen);
   ngtcp2_addr_init(&ctx->connected_path.remote,
-                   &sockaddr->sa_addr, sockaddr->addrlen);
+                   &sockaddr->sa_addr, (socklen_t)sockaddr->addrlen);
 
   rc = ngtcp2_conn_client_new(&ctx->qconn, &ctx->dcid, &ctx->scid,
                               &ctx->connected_path,
@@ -2211,7 +2256,7 @@ static CURLcode cf_connect_start(struct Curl_cfilter *cf,
 #elif defined(USE_GNUTLS)
   ngtcp2_conn_set_tls_native_handle(ctx->qconn, ctx->tls.gtls.session);
 #else
-  ngtcp2_conn_set_tls_native_handle(ctx->qconn, ctx->tls.ssl);
+  ngtcp2_conn_set_tls_native_handle(ctx->qconn, ctx->tls.wssl.handle);
 #endif
 
   ngtcp2_ccerr_default(&ctx->last_error);
@@ -2331,7 +2376,7 @@ static CURLcode cf_ngtcp2_query(struct Curl_cfilter *cf,
      * by callback. QUIC counts the number over the lifetime of the
      * connection, ever increasing.
      * We count the *open* transfers plus the budget for new ones. */
-    if(!ctx->qconn || ctx->conn_closed) {
+    if(!ctx->qconn || ctx->shutdown_started) {
       *pres1 = 0;
     }
     else if(ctx->max_bidi_streams) {
@@ -2343,7 +2388,7 @@ static CURLcode cf_ngtcp2_query(struct Curl_cfilter *cf,
       *pres1 = (max_streams > INT_MAX)? INT_MAX : (int)max_streams;
     }
     else  /* transport params not arrived yet? take our default. */
-      *pres1 = Curl_multi_max_concurrent_streams(data->multi);
+      *pres1 = (int)Curl_multi_max_concurrent_streams(data->multi);
     CURL_TRC_CF(data, cf, "query conn[%" CURL_FORMAT_CURL_OFF_T "]: "
                 "MAX_CONCURRENT -> %d (%zu in use)",
                 cf->conn->connection_id, *pres1, CONN_INUSE(cf->conn));
@@ -2389,7 +2434,7 @@ static bool cf_ngtcp2_conn_is_alive(struct Curl_cfilter *cf,
 
   CF_DATA_SAVE(save, cf, data);
   *input_pending = FALSE;
-  if(!ctx->qconn || ctx->conn_closed)
+  if(!ctx->qconn || ctx->shutdown_started)
     goto out;
 
   /* Both sides of the QUIC connection announce they max idle times in
@@ -2416,8 +2461,8 @@ static bool cf_ngtcp2_conn_is_alive(struct Curl_cfilter *cf,
   alive = TRUE;
   if(*input_pending) {
     CURLcode result;
-    /* This happens before we've sent off a request and the connection is
-       not in use by any other transfer, there shouldn't be any data here,
+    /* This happens before we have sent off a request and the connection is
+       not in use by any other transfer, there should not be any data here,
        only "protocol frames" */
     *input_pending = FALSE;
     result = cf_progress_ingress(cf, data, NULL);
@@ -2437,6 +2482,7 @@ struct Curl_cftype Curl_cft_http3 = {
   cf_ngtcp2_destroy,
   cf_ngtcp2_connect,
   cf_ngtcp2_close,
+  cf_ngtcp2_shutdown,
   Curl_cf_def_get_host,
   cf_ngtcp2_adjust_pollset,
   cf_ngtcp2_data_pending,
diff --git a/lib/vquic/curl_osslq.c b/lib/vquic/curl_osslq.c
index 8b9e889d7..dafde44f2 100644
--- a/lib/vquic/curl_osslq.c
+++ b/lib/vquic/curl_osslq.c
@@ -71,7 +71,7 @@
 /* The pool keeps spares around and half of a full stream window
  * seems good. More does not seem to improve performance.
  * The benefit of the pool is that stream buffer to not keep
- * spares. So memory consumption goes down when streams run empty,
+ * spares. Memory consumption goes down when streams run empty,
  * have a large upload done, etc. */
 #define H3_STREAM_POOL_SPARES \
           (H3_STREAM_WINDOW_SIZE / H3_STREAM_CHUNK_SIZE ) / 2
@@ -232,7 +232,7 @@ static CURLcode cf_osslq_stream_open(struct cf_osslq_stream *s,
   if(!s->ssl) {
     return CURLE_FAILED_INIT;
   }
-  s->id = SSL_get_stream_id(s->ssl);
+  s->id = (curl_int64_t)SSL_get_stream_id(s->ssl);
   SSL_set_app_data(s->ssl, user_data);
   return CURLE_OK;
 }
@@ -294,10 +294,10 @@ struct cf_osslq_ctx {
   size_t max_stream_window;          /* max flow window for one stream */
   uint64_t max_idle_ms;              /* max idle time for QUIC connection */
   BIT(got_first_byte);               /* if first byte was received */
-#ifdef USE_OPENSSL
   BIT(x509_store_setup);             /* if x509 store has been set up */
   BIT(protocol_shutdown);            /* QUIC connection is shut down */
-#endif
+  BIT(need_recv);                    /* QUIC connection needs to receive */
+  BIT(need_send);                    /* QUIC connection needs to send */
 };
 
 static void cf_osslq_ctx_clear(struct cf_osslq_ctx *ctx)
@@ -316,6 +316,77 @@ static void cf_osslq_ctx_clear(struct cf_osslq_ctx *ctx)
   ctx->call_data = save;
 }
 
+static CURLcode cf_osslq_shutdown(struct Curl_cfilter *cf,
+                                  struct Curl_easy *data, bool *done)
+{
+  struct cf_osslq_ctx *ctx = cf->ctx;
+  struct cf_call_data save;
+  CURLcode result = CURLE_OK;
+  int rc;
+
+  CF_DATA_SAVE(save, cf, data);
+
+  if(cf->shutdown || ctx->protocol_shutdown) {
+    *done = TRUE;
+    return CURLE_OK;
+  }
+
+  CF_DATA_SAVE(save, cf, data);
+  *done = FALSE;
+  ctx->need_send = FALSE;
+  ctx->need_recv = FALSE;
+
+  rc = SSL_shutdown_ex(ctx->tls.ossl.ssl,
+                       SSL_SHUTDOWN_FLAG_NO_BLOCK, NULL, 0);
+  if(rc == 0) {  /* ongoing */
+    CURL_TRC_CF(data, cf, "shutdown ongoing");
+    ctx->need_recv = TRUE;
+    goto out;
+  }
+  else if(rc == 1) {  /* done */
+    CURL_TRC_CF(data, cf, "shutdown finished");
+    *done = TRUE;
+    goto out;
+  }
+  else {
+    long sslerr;
+    char err_buffer[256];
+    int err = SSL_get_error(ctx->tls.ossl.ssl, rc);
+
+    switch(err) {
+    case SSL_ERROR_NONE:
+    case SSL_ERROR_ZERO_RETURN:
+      CURL_TRC_CF(data, cf, "shutdown not received, but closed");
+      *done = TRUE;
+      goto out;
+    case SSL_ERROR_WANT_READ:
+      /* SSL has send its notify and now wants to read the reply
+       * from the server. We are not really interested in that. */
+      CURL_TRC_CF(data, cf, "shutdown sent, want receive");
+      ctx->need_recv = TRUE;
+      goto out;
+    case SSL_ERROR_WANT_WRITE:
+      CURL_TRC_CF(data, cf, "shutdown send blocked");
+      ctx->need_send = TRUE;
+      goto out;
+    default:
+      /* We give up on this. */
+      sslerr = ERR_get_error();
+      CURL_TRC_CF(data, cf, "shutdown, ignore recv error: '%s', errno %d",
+                  (sslerr ?
+                   osslq_strerror(sslerr, err_buffer, sizeof(err_buffer)) :
+                   osslq_SSL_ERROR_to_str(err)),
+                  SOCKERRNO);
+      *done = TRUE;
+      result = CURLE_OK;
+      goto out;
+    }
+  }
+out:
+  CF_DATA_RESTORE(cf, save);
+  return result;
+}
+
 static void cf_osslq_close(struct Curl_cfilter *cf, struct Curl_easy *data)
 {
   struct cf_osslq_ctx *ctx = cf->ctx;
@@ -323,8 +394,13 @@ static void cf_osslq_close(struct Curl_cfilter *cf, struct Curl_easy *data)
 
   CF_DATA_SAVE(save, cf, data);
   if(ctx && ctx->tls.ossl.ssl) {
-    /* TODO: send connection close */
     CURL_TRC_CF(data, cf, "cf_osslq_close()");
+    if(!cf->shutdown && !ctx->protocol_shutdown) {
+      /* last best effort, which OpenSSL calls a "rapid" shutdown. */
+      SSL_shutdown_ex(ctx->tls.ossl.ssl,
+                      (SSL_SHUTDOWN_FLAG_NO_BLOCK | SSL_SHUTDOWN_FLAG_RAPID),
+                      NULL, 0);
+    }
     cf_osslq_ctx_clear(ctx);
   }
 
@@ -355,12 +431,12 @@ static CURLcode cf_osslq_h3conn_add_stream(struct cf_osslq_h3conn *h3,
                                            struct Curl_easy *data)
 {
   struct cf_osslq_ctx *ctx = cf->ctx;
-  int64_t stream_id = SSL_get_stream_id(stream_ssl);
+  curl_int64_t stream_id = (curl_int64_t)SSL_get_stream_id(stream_ssl);
 
   if(h3->remote_ctrl_n >= ARRAYSIZE(h3->remote_ctrl)) {
     /* rejected, we are full */
     CURL_TRC_CF(data, cf, "[%" CURL_PRId64 "] rejecting remote stream",
-                (curl_int64_t)stream_id);
+                stream_id);
     SSL_free(stream_ssl);
     return CURLE_FAILED_INIT;
   }
@@ -371,12 +447,12 @@ static CURLcode cf_osslq_h3conn_add_stream(struct cf_osslq_h3conn *h3,
       nstream->ssl = stream_ssl;
       Curl_bufq_initp(&nstream->recvbuf, &ctx->stream_bufcp, 1, BUFQ_OPT_NONE);
       CURL_TRC_CF(data, cf, "[%" CURL_PRId64 "] accepted remote uni stream",
-                  (curl_int64_t)stream_id);
+                  stream_id);
       break;
     }
     default:
       CURL_TRC_CF(data, cf, "[%" CURL_PRId64 "] reject remote non-uni-read"
-                  " stream", (curl_int64_t)stream_id);
+                  " stream", stream_id);
       SSL_free(stream_ssl);
       return CURLE_FAILED_INIT;
   }
@@ -440,7 +516,7 @@ static CURLcode cf_osslq_ssl_err(struct Curl_cfilter *cf,
 
   /* detail is already set to the SSL error above */
 
-  /* If we e.g. use SSLv2 request-method and the server doesn't like us
+  /* If we e.g. use SSLv2 request-method and the server does not like us
    * (RST connection, etc.), OpenSSL gives no explanation whatsoever and
    * the SO_ERROR is also lost.
    */
@@ -484,7 +560,6 @@ struct h3_stream_ctx {
   struct bufq recvbuf;   /* h3 response body */
   struct h1_req_parser h1; /* h1 request parsing */
   size_t sendbuf_len_in_flight; /* sendbuf amount "in flight" */
-  size_t upload_blocked_len; /* the amount written last and EGAINed */
   size_t recv_buf_nonflow; /* buffered bytes, not counting for flow control */
   curl_uint64_t error3; /* HTTP/3 stream error code */
   curl_off_t upload_left; /* number of request bytes left to upload */
@@ -521,7 +596,7 @@ static CURLcode h3_data_setup(struct Curl_cfilter *cf,
   struct cf_osslq_ctx *ctx = cf->ctx;
   struct h3_stream_ctx *stream = H3_STREAM_CTX(ctx, data);
 
-  if(!data || !data->req.p.http) {
+  if(!data) {
     failf(data, "initialization failure, transfer not http initialized");
     return CURLE_FAILED_INIT;
   }
@@ -829,7 +904,7 @@ static int cb_h3_end_headers(nghttp3_conn *conn, int64_t sid,
 
   if(!stream)
     return 0;
-  /* add a CRLF only if we've received some headers */
+  /* add a CRLF only if we have received some headers */
   result = write_resp_raw(cf, data, "\r\n", 2, FALSE);
   if(result) {
     return -1;
@@ -977,8 +1052,8 @@ static int cb_h3_acked_stream_data(nghttp3_conn *conn, int64_t stream_id,
   Curl_bufq_skip(&stream->sendbuf, skiplen);
   stream->sendbuf_len_in_flight -= skiplen;
 
-  /* Everything ACKed, we resume upload processing */
-  if(!stream->sendbuf_len_in_flight) {
+  /* Resume upload processing if we have more data to send */
+  if(stream->sendbuf_len_in_flight < Curl_bufq_len(&stream->sendbuf)) {
     int rv = nghttp3_conn_resume_stream(conn, stream_id);
     if(rv && rv != NGHTTP3_ERR_STREAM_NOT_FOUND) {
       return NGHTTP3_ERR_CALLBACK_FAILURE;
@@ -1442,19 +1517,12 @@ static CURLcode h3_send_streams(struct Curl_cfilter *cf,
     for(i = 0; (i < n) && !blocked; ++i) {
       /* Without stream->s.ssl, we closed that already, so
        * pretend the write did succeed. */
-#ifdef SSL_WRITE_FLAG_CONCLUDE
-      /* Since OpenSSL v3.3.x, on last chunk set EOS if needed  */
       uint64_t flags = (eos && ((i + 1) == n))? SSL_WRITE_FLAG_CONCLUDE : 0;
       written = vec[i].len;
       ok = !s->ssl || SSL_write_ex2(s->ssl, vec[i].base, vec[i].len, flags,
                                    &written);
       if(ok && flags & SSL_WRITE_FLAG_CONCLUDE)
         eos_written = TRUE;
-#else
-      written = vec[i].len;
-      ok = !s->ssl || SSL_write_ex(s->ssl, vec[i].base, vec[i].len,
-                                   &written);
-#endif
       if(ok) {
         /* As OpenSSL buffers the data, we count this as acknowledged
          * from nghttp3's point of view */
@@ -1766,7 +1834,7 @@ static ssize_t h3_stream_open(struct Curl_cfilter *cf,
   *err = cf_osslq_stream_open(&stream->s, ctx->tls.ossl.ssl, 0,
                               &ctx->stream_bufcp, data);
   if(*err) {
-    failf(data, "can't get bidi streams");
+    failf(data, "cannot get bidi streams");
     *err = CURLE_SEND_ERROR;
     goto out;
   }
@@ -1867,21 +1935,6 @@ static ssize_t cf_osslq_send(struct Curl_cfilter *cf, struct Curl_easy *data,
     }
     stream = H3_STREAM_CTX(ctx, data);
   }
-  else if(stream->upload_blocked_len) {
-    /* the data in `buf` has already been submitted or added to the
-     * buffers, but have been EAGAINed on the last invocation. */
-    DEBUGASSERT(len >= stream->upload_blocked_len);
-    if(len < stream->upload_blocked_len) {
-      /* Did we get called again with a smaller `len`? This should not
-       * happen. We are not prepared to handle that. */
-      failf(data, "HTTP/3 send again with decreased length");
-      *err = CURLE_HTTP3;
-      nwritten = -1;
-      goto out;
-    }
-    nwritten = (ssize_t)stream->upload_blocked_len;
-    stream->upload_blocked_len = 0;
-  }
   else if(stream->closed) {
     if(stream->resp_hds_complete) {
       /* Server decided to close the stream after having sent us a final
@@ -1919,18 +1972,6 @@ static ssize_t cf_osslq_send(struct Curl_cfilter *cf, struct Curl_easy *data,
     nwritten = -1;
   }
 
-  if(stream && nwritten > 0 && stream->sendbuf_len_in_flight) {
-    /* We have unacknowledged DATA and cannot report success to our
-     * caller. Instead we EAGAIN and remember how much we have already
-     * "written" into our various internal connection buffers. */
-    stream->upload_blocked_len = nwritten;
-    CURL_TRC_CF(data, cf, "[%" CURL_PRId64 "] cf_send(len=%zu), "
-                "%zu bytes in flight -> EGAIN", stream->s.id, len,
-                stream->sendbuf_len_in_flight);
-    *err = CURLE_AGAIN;
-    nwritten = -1;
-  }
-
 out:
   result = check_and_set_expiry(cf, data);
   CURL_TRC_CF(data, cf, "[%" CURL_PRId64 "] cf_send(len=%zu) -> %zd, %d",
@@ -2090,7 +2131,8 @@ static CURLcode cf_osslq_data_event(struct Curl_cfilter *cf,
     struct h3_stream_ctx *stream = H3_STREAM_CTX(ctx, data);
     if(stream && !stream->send_closed) {
       stream->send_closed = TRUE;
-      stream->upload_left = Curl_bufq_len(&stream->sendbuf);
+      stream->upload_left = Curl_bufq_len(&stream->sendbuf) -
+        stream->sendbuf_len_in_flight;
       (void)nghttp3_conn_resume_stream(ctx->h3.conn, stream->s.id);
     }
     break;
@@ -2149,8 +2191,8 @@ static bool cf_osslq_conn_is_alive(struct Curl_cfilter *cf,
   alive = TRUE;
   if(*input_pending) {
     CURLcode result;
-    /* This happens before we've sent off a request and the connection is
-       not in use by any other transfer, there shouldn't be any data here,
+    /* This happens before we have sent off a request and the connection is
+       not in use by any other transfer, there should not be any data here,
        only "protocol frames" */
     *input_pending = FALSE;
     result = cf_progress_ingress(cf, data);
@@ -2189,6 +2231,10 @@ static void cf_osslq_adjust_pollset(struct Curl_cfilter *cf,
                        SSL_net_read_desired(ctx->tls.ossl.ssl),
                        SSL_net_write_desired(ctx->tls.ossl.ssl));
     }
+    else if(ctx->need_recv || ctx->need_send) {
+      Curl_pollset_set(data, ps, ctx->q.sockfd,
+                       ctx->need_recv, ctx->need_send);
+    }
   }
 }
 
@@ -2252,6 +2298,7 @@ struct Curl_cftype Curl_cft_http3 = {
   cf_osslq_destroy,
   cf_osslq_connect,
   cf_osslq_close,
+  cf_osslq_shutdown,
   Curl_cf_def_get_host,
   cf_osslq_adjust_pollset,
   cf_osslq_data_pending,
diff --git a/lib/vquic/curl_quiche.c b/lib/vquic/curl_quiche.c
index a68fc6430..6f01c19aa 100644
--- a/lib/vquic/curl_quiche.c
+++ b/lib/vquic/curl_quiche.c
@@ -64,11 +64,10 @@
 
 #define H3_STREAM_WINDOW_SIZE  (128 * 1024)
 #define H3_STREAM_CHUNK_SIZE    (16 * 1024)
-/* The pool keeps spares around and half of a full stream windows
- * seems good. More does not seem to improve performance.
- * The benefit of the pool is that stream buffer to not keep
- * spares. So memory consumption goes down when streams run empty,
- * have a large upload done, etc. */
+/* The pool keeps spares around and half of a full stream windows seems good.
+ * More does not seem to improve performance. The benefit of the pool is that
+ * stream buffer to not keep spares. Memory consumption goes down when streams
+ * run empty, have a large upload done, etc. */
 #define H3_STREAM_POOL_SPARES \
           (H3_STREAM_WINDOW_SIZE / H3_STREAM_CHUNK_SIZE ) / 2
 /* Receive and Send max number of chunks just follows from the
@@ -103,6 +102,7 @@ struct cf_quiche_ctx {
   curl_off_t data_recvd;
   BIT(goaway);                       /* got GOAWAY from server */
   BIT(x509_store_setup);             /* if x509 store has been set up */
+  BIT(shutdown_started);             /* queued shutdown packets */
 };
 
 #ifdef DEBUG_QUICHE
@@ -1120,7 +1120,7 @@ out:
     nwritten = -1;
   }
   CURL_TRC_CF(data, cf, "[%" CURL_PRIu64 "] cf_send(len=%zu) -> %zd, %d",
-              stream? stream->id : -1, len, nwritten, *err);
+              stream? stream->id : (uint64_t)~0, len, nwritten, *err);
   return nwritten;
 }
 
@@ -1271,7 +1271,7 @@ static CURLcode cf_connect_start(struct Curl_cfilter *cf,
 
   ctx->cfg = quiche_config_new(QUICHE_PROTOCOL_VERSION);
   if(!ctx->cfg) {
-    failf(data, "can't create quiche config");
+    failf(data, "cannot create quiche config");
     return CURLE_FAILED_INIT;
   }
   quiche_config_enable_pacing(ctx->cfg, false);
@@ -1322,7 +1322,7 @@ static CURLcode cf_connect_start(struct Curl_cfilter *cf,
                                       &sockaddr->sa_addr, sockaddr->addrlen,
                                       ctx->cfg, ctx->tls.ossl.ssl, false);
   if(!ctx->qconn) {
-    failf(data, "can't create quiche connection");
+    failf(data, "cannot create quiche connection");
     return CURLE_OUT_OF_MEMORY;
   }
 
@@ -1464,18 +1464,60 @@ out:
   return result;
 }
 
+static CURLcode cf_quiche_shutdown(struct Curl_cfilter *cf,
+                                   struct Curl_easy *data, bool *done)
+{
+  struct cf_quiche_ctx *ctx = cf->ctx;
+  CURLcode result = CURLE_OK;
+
+  if(cf->shutdown || !ctx || !ctx->qconn) {
+    *done = TRUE;
+    return CURLE_OK;
+  }
+
+  *done = FALSE;
+  if(!ctx->shutdown_started) {
+    int err;
+
+    ctx->shutdown_started = TRUE;
+    vquic_ctx_update_time(&ctx->q);
+    err = quiche_conn_close(ctx->qconn, TRUE, 0, NULL, 0);
+    if(err) {
+      CURL_TRC_CF(data, cf, "error %d adding shutdown packet, "
+                  "aborting shutdown", err);
+      result = CURLE_SEND_ERROR;
+      goto out;
+    }
+  }
+
+  if(!Curl_bufq_is_empty(&ctx->q.sendbuf)) {
+    CURL_TRC_CF(data, cf, "shutdown, flushing sendbuf");
+    result = cf_flush_egress(cf, data);
+    if(result)
+      goto out;
+  }
+
+  if(Curl_bufq_is_empty(&ctx->q.sendbuf)) {
+    /* sent everything, quiche does not seem to support a graceful
+     * shutdown waiting for a reply, so ware done. */
+    CURL_TRC_CF(data, cf, "shutdown completely sent off, done");
+    *done = TRUE;
+  }
+  else {
+    CURL_TRC_CF(data, cf, "shutdown sending blocked");
+  }
+
+out:
+  return result;
+}
+
 static void cf_quiche_close(struct Curl_cfilter *cf, struct Curl_easy *data)
 {
   struct cf_quiche_ctx *ctx = cf->ctx;
 
   if(ctx) {
-    if(ctx->qconn) {
-      vquic_ctx_update_time(&ctx->q);
-      (void)quiche_conn_close(ctx->qconn, TRUE, 0, NULL, 0);
-      /* flushing the egress is not a failsafe way to deliver all the
-         outstanding packets, but we also don't want to get stuck here... */
-      (void)cf_flush_egress(cf, data);
-    }
+    bool done;
+    (void)cf_quiche_shutdown(cf, data, &done);
     cf_quiche_ctx_clear(ctx);
   }
 }
@@ -1559,8 +1601,8 @@ static bool cf_quiche_conn_is_alive(struct Curl_cfilter *cf,
     return FALSE;
 
   if(*input_pending) {
-    /* This happens before we've sent off a request and the connection is
-       not in use by any other transfer, there shouldn't be any data here,
+    /* This happens before we have sent off a request and the connection is
+       not in use by any other transfer, there should not be any data here,
        only "protocol frames" */
     *input_pending = FALSE;
     if(cf_process_ingress(cf, data))
@@ -1580,6 +1622,7 @@ struct Curl_cftype Curl_cft_http3 = {
   cf_quiche_destroy,
   cf_quiche_connect,
   cf_quiche_close,
+  cf_quiche_shutdown,
   Curl_cf_def_get_host,
   cf_quiche_adjust_pollset,
   cf_quiche_data_pending,
diff --git a/lib/vquic/vquic-tls.c b/lib/vquic/vquic-tls.c
index aca18b457..6aa6613af 100644
--- a/lib/vquic/vquic-tls.c
+++ b/lib/vquic/vquic-tls.c
@@ -76,7 +76,7 @@ static void keylog_callback(const WOLFSSL *ssl, const char *line)
 }
 #endif
 
-static CURLcode curl_wssl_init_ctx(struct curl_tls_ctx *ctx,
+static CURLcode Curl_wssl_init_ctx(struct curl_tls_ctx *ctx,
                                    struct Curl_cfilter *cf,
                                    struct Curl_easy *data,
                                    Curl_vquic_tls_ctx_setup *cb_setup,
@@ -91,8 +91,8 @@ static CURLcode curl_wssl_init_ctx(struct curl_tls_ctx *ctx,
     goto out;
   }
 
-  ctx->ssl_ctx = wolfSSL_CTX_new(wolfTLSv1_3_client_method());
-  if(!ctx->ssl_ctx) {
+  ctx->wssl.ctx = wolfSSL_CTX_new(wolfTLSv1_3_client_method());
+  if(!ctx->wssl.ctx) {
     result = CURLE_OUT_OF_MEMORY;
     goto out;
   }
@@ -103,9 +103,9 @@ static CURLcode curl_wssl_init_ctx(struct curl_tls_ctx *ctx,
       goto out;
   }
 
-  wolfSSL_CTX_set_default_verify_paths(ctx->ssl_ctx);
+  wolfSSL_CTX_set_default_verify_paths(ctx->wssl.ctx);
 
-  if(wolfSSL_CTX_set_cipher_list(ctx->ssl_ctx, conn_config->cipher_list13 ?
+  if(wolfSSL_CTX_set_cipher_list(ctx->wssl.ctx, conn_config->cipher_list13 ?
                                  conn_config->cipher_list13 :
                                  QUIC_CIPHERS) != 1) {
     char error_buffer[256];
@@ -115,7 +115,7 @@ static CURLcode curl_wssl_init_ctx(struct curl_tls_ctx *ctx,
     goto out;
   }
 
-  if(wolfSSL_CTX_set1_groups_list(ctx->ssl_ctx, conn_config->curves ?
+  if(wolfSSL_CTX_set1_groups_list(ctx->wssl.ctx, conn_config->curves ?
                                   conn_config->curves :
                                   (char *)QUIC_GROUPS) != 1) {
     failf(data, "wolfSSL failed to set curves");
@@ -127,7 +127,7 @@ static CURLcode curl_wssl_init_ctx(struct curl_tls_ctx *ctx,
   Curl_tls_keylog_open();
   if(Curl_tls_keylog_enabled()) {
 #if defined(HAVE_SECRET_CALLBACK)
-    wolfSSL_CTX_set_keylog_callback(ctx->ssl_ctx, keylog_callback);
+    wolfSSL_CTX_set_keylog_callback(ctx->wssl.ctx, keylog_callback);
 #else
     failf(data, "wolfSSL was built without keylog callback");
     result = CURLE_NOT_BUILT_IN;
@@ -139,12 +139,12 @@ static CURLcode curl_wssl_init_ctx(struct curl_tls_ctx *ctx,
     const char * const ssl_cafile = conn_config->CAfile;
     const char * const ssl_capath = conn_config->CApath;
 
-    wolfSSL_CTX_set_verify(ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);
+    wolfSSL_CTX_set_verify(ctx->wssl.ctx, SSL_VERIFY_PEER, NULL);
     if(ssl_cafile || ssl_capath) {
       /* tell wolfSSL where to find CA certificates that are used to verify
          the server's certificate. */
       int rc =
-        wolfSSL_CTX_load_verify_locations_ex(ctx->ssl_ctx, ssl_cafile,
+        wolfSSL_CTX_load_verify_locations_ex(ctx->wssl.ctx, ssl_cafile,
                                              ssl_capath,
                                              WOLFSSL_LOAD_FLAG_IGNORE_ERR);
       if(SSL_SUCCESS != rc) {
@@ -161,20 +161,20 @@ static CURLcode curl_wssl_init_ctx(struct curl_tls_ctx *ctx,
     }
 #ifdef CURL_CA_FALLBACK
     else {
-      /* verifying the peer without any CA certificates won't work so
+      /* verifying the peer without any CA certificates will not work so
          use wolfssl's built-in default as fallback */
-      wolfSSL_CTX_set_default_verify_paths(ctx->ssl_ctx);
+      wolfSSL_CTX_set_default_verify_paths(ctx->wssl.ctx);
     }
 #endif
   }
   else {
-    wolfSSL_CTX_set_verify(ctx->ssl_ctx, SSL_VERIFY_NONE, NULL);
+    wolfSSL_CTX_set_verify(ctx->wssl.ctx, SSL_VERIFY_NONE, NULL);
   }
 
   /* give application a chance to interfere with SSL set up. */
   if(data->set.ssl.fsslctx) {
     Curl_set_in_callback(data, true);
-    result = (*data->set.ssl.fsslctx)(data, ctx->ssl_ctx,
+    result = (*data->set.ssl.fsslctx)(data, ctx->wssl.ctx,
                                       data->set.ssl.fsslctxp);
     Curl_set_in_callback(data, false);
     if(result) {
@@ -185,36 +185,36 @@ static CURLcode curl_wssl_init_ctx(struct curl_tls_ctx *ctx,
   result = CURLE_OK;
 
 out:
-  if(result && ctx->ssl_ctx) {
-    SSL_CTX_free(ctx->ssl_ctx);
-    ctx->ssl_ctx = NULL;
+  if(result && ctx->wssl.ctx) {
+    SSL_CTX_free(ctx->wssl.ctx);
+    ctx->wssl.ctx = NULL;
   }
   return result;
 }
 
 /** SSL callbacks ***/
 
-static CURLcode curl_wssl_init_ssl(struct curl_tls_ctx *ctx,
+static CURLcode Curl_wssl_init_ssl(struct curl_tls_ctx *ctx,
                                    struct Curl_easy *data,
                                    struct ssl_peer *peer,
                                    const char *alpn, size_t alpn_len,
                                    void *user_data)
 {
   (void)data;
-  DEBUGASSERT(!ctx->ssl);
-  DEBUGASSERT(ctx->ssl_ctx);
-  ctx->ssl = wolfSSL_new(ctx->ssl_ctx);
+  DEBUGASSERT(!ctx->wssl.handle);
+  DEBUGASSERT(ctx->wssl.ctx);
+  ctx->wssl.handle = wolfSSL_new(ctx->wssl.ctx);
 
-  wolfSSL_set_app_data(ctx->ssl, user_data);
-  wolfSSL_set_connect_state(ctx->ssl);
-  wolfSSL_set_quic_use_legacy_codepoint(ctx->ssl, 0);
+  wolfSSL_set_app_data(ctx->wssl.handle, user_data);
+  wolfSSL_set_connect_state(ctx->wssl.handle);
+  wolfSSL_set_quic_use_legacy_codepoint(ctx->wssl.handle, 0);
 
   if(alpn)
-    wolfSSL_set_alpn_protos(ctx->ssl, (const unsigned char *)alpn,
-                            (int)alpn_len);
+    wolfSSL_set_alpn_protos(ctx->wssl.handle, (const unsigned char *)alpn,
+                            (unsigned int)alpn_len);
 
   if(peer->sni) {
-    wolfSSL_UseSNI(ctx->ssl, WOLFSSL_SNI_HOST_NAME,
+    wolfSSL_UseSNI(ctx->wssl.handle, WOLFSSL_SNI_HOST_NAME,
                    peer->sni, (unsigned short)strlen(peer->sni));
   }
 
@@ -243,11 +243,11 @@ CURLcode Curl_vquic_tls_init(struct curl_tls_ctx *ctx,
                             (const unsigned char *)alpn, alpn_len,
                             cb_setup, cb_user_data, ssl_user_data);
 #elif defined(USE_WOLFSSL)
-  result = curl_wssl_init_ctx(ctx, cf, data, cb_setup, cb_user_data);
+  result = Curl_wssl_init_ctx(ctx, cf, data, cb_setup, cb_user_data);
   if(result)
     return result;
 
-  return curl_wssl_init_ssl(ctx, data, peer, alpn, alpn_len, ssl_user_data);
+  return Curl_wssl_init_ssl(ctx, data, peer, alpn, alpn_len, ssl_user_data);
 #else
 #error "no TLS lib in used, should not happen"
   return CURLE_FAILED_INIT;
@@ -262,15 +262,14 @@ void Curl_vquic_tls_cleanup(struct curl_tls_ctx *ctx)
   if(ctx->ossl.ssl_ctx)
     SSL_CTX_free(ctx->ossl.ssl_ctx);
 #elif defined(USE_GNUTLS)
-  if(ctx->gtls.cred)
-    gnutls_certificate_free_credentials(ctx->gtls.cred);
   if(ctx->gtls.session)
     gnutls_deinit(ctx->gtls.session);
+  Curl_gtls_shared_creds_free(&ctx->gtls.shared_creds);
 #elif defined(USE_WOLFSSL)
-  if(ctx->ssl)
-    wolfSSL_free(ctx->ssl);
-  if(ctx->ssl_ctx)
-    wolfSSL_CTX_free(ctx->ssl_ctx);
+  if(ctx->wssl.handle)
+    wolfSSL_free(ctx->wssl.handle);
+  if(ctx->wssl.ctx)
+    wolfSSL_CTX_free(ctx->wssl.ctx);
 #endif
   memset(ctx, 0, sizeof(*ctx));
 }
@@ -286,8 +285,14 @@ CURLcode Curl_vquic_tls_before_recv(struct curl_tls_ctx *ctx,
       return result;
     ctx->ossl.x509_store_setup = TRUE;
   }
+#elif defined(USE_WOLFSSL)
+  if(!ctx->wssl.x509_store_setup) {
+    CURLcode result = Curl_wssl_setup_x509_store(cf, data, &ctx->wssl);
+    if(result)
+      return result;
+  }
 #elif defined(USE_GNUTLS)
-  if(!ctx->gtls.trust_setup) {
+  if(!ctx->gtls.shared_creds->trust_setup) {
     CURLcode result = Curl_gtls_client_trust_setup(cf, data, &ctx->gtls);
     if(result)
       return result;
@@ -325,7 +330,7 @@ CURLcode Curl_vquic_tls_verify_peer(struct curl_tls_ctx *ctx,
   (void)data;
   if(conn_config->verifyhost) {
     if(peer->sni) {
-      WOLFSSL_X509* cert = wolfSSL_get_peer_certificate(ctx->ssl);
+      WOLFSSL_X509* cert = wolfSSL_get_peer_certificate(ctx->wssl.handle);
       if(wolfSSL_X509_check_host(cert, peer->sni, strlen(peer->sni), 0, NULL)
             == WOLFSSL_FAILURE) {
         result = CURLE_PEER_FAILED_VERIFICATION;
diff --git a/lib/vquic/vquic-tls.h b/lib/vquic/vquic-tls.h
index 1d35fd0e6..0ec74bfba 100644
--- a/lib/vquic/vquic-tls.h
+++ b/lib/vquic/vquic-tls.h
@@ -31,14 +31,15 @@
 #if defined(USE_HTTP3) && \
   (defined(USE_OPENSSL) || defined(USE_GNUTLS) || defined(USE_WOLFSSL))
 
+#include "vtls/wolfssl.h"
+
 struct curl_tls_ctx {
 #ifdef USE_OPENSSL
   struct ossl_ctx ossl;
 #elif defined(USE_GNUTLS)
   struct gtls_ctx gtls;
 #elif defined(USE_WOLFSSL)
-  WOLFSSL_CTX *ssl_ctx;
-  WOLFSSL *ssl;
+  struct wolfssl_ctx wssl;
 #endif
 };
 
diff --git a/lib/vquic/vquic.c b/lib/vquic/vquic.c
index 9ce1e4626..2bb06d463 100644
--- a/lib/vquic/vquic.c
+++ b/lib/vquic/vquic.c
@@ -36,6 +36,9 @@
 
 #include "curl_setup.h"
 
+#ifdef HAVE_NETINET_UDP_H
+#include <netinet/udp.h>
+#endif
 #ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
@@ -329,6 +332,36 @@ CURLcode vquic_send_tail_split(struct Curl_cfilter *cf, struct Curl_easy *data,
   return vquic_flush(cf, data, qctx);
 }
 
+#if defined(HAVE_SENDMMSG) || defined(HAVE_SENDMSG)
+static size_t msghdr_get_udp_gro(struct msghdr *msg)
+{
+  int gso_size = 0;
+#if defined(__linux__) && defined(UDP_GRO)
+  struct cmsghdr *cmsg;
+
+  /* Workaround musl CMSG_NXTHDR issue */
+#ifndef __GLIBC__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wsign-compare"
+#pragma clang diagnostic ignored "-Wcast-align"
+#endif
+  for(cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {
+#ifndef __GLIBC__
+#pragma clang diagnostic pop
+#endif
+    if(cmsg->cmsg_level == SOL_UDP && cmsg->cmsg_type == UDP_GRO) {
+      memcpy(&gso_size, CMSG_DATA(cmsg), sizeof(gso_size));
+
+      break;
+    }
+  }
+#endif
+  (void)msg;
+
+  return (size_t)gso_size;
+}
+#endif
+
 #ifdef HAVE_SENDMMSG
 static CURLcode recvmmsg_packets(struct Curl_cfilter *cf,
                                  struct Curl_easy *data,
@@ -339,12 +372,16 @@ static CURLcode recvmmsg_packets(struct Curl_cfilter *cf,
 #define MMSG_NUM  64
   struct iovec msg_iov[MMSG_NUM];
   struct mmsghdr mmsg[MMSG_NUM];
+  uint8_t msg_ctrl[MMSG_NUM * CMSG_SPACE(sizeof(uint16_t))];
   uint8_t bufs[MMSG_NUM][2*1024];
   struct sockaddr_storage remote_addr[MMSG_NUM];
   size_t total_nread, pkts;
   int mcount, i, n;
   char errstr[STRERROR_LEN];
   CURLcode result = CURLE_OK;
+  size_t gso_size;
+  size_t pktlen;
+  size_t offset, to;
 
   DEBUGASSERT(max_pkts > 0);
   pkts = 0;
@@ -359,6 +396,8 @@ static CURLcode recvmmsg_packets(struct Curl_cfilter *cf,
       mmsg[i].msg_hdr.msg_iovlen = 1;
       mmsg[i].msg_hdr.msg_name = &remote_addr[i];
       mmsg[i].msg_hdr.msg_namelen = sizeof(remote_addr[i]);
+      mmsg[i].msg_hdr.msg_control = &msg_ctrl[i];
+      mmsg[i].msg_hdr.msg_controllen = CMSG_SPACE(sizeof(uint16_t));
     }
 
     while((mcount = recvmmsg(qctx->sockfd, mmsg, n, 0, NULL)) == -1 &&
@@ -385,14 +424,30 @@ static CURLcode recvmmsg_packets(struct Curl_cfilter *cf,
     }
 
     CURL_TRC_CF(data, cf, "recvmmsg() -> %d packets", mcount);
-    pkts += mcount;
     for(i = 0; i < mcount; ++i) {
       total_nread += mmsg[i].msg_len;
-      result = recv_cb(bufs[i], mmsg[i].msg_len,
-                       mmsg[i].msg_hdr.msg_name, mmsg[i].msg_hdr.msg_namelen,
-                       0, userp);
-      if(result)
-        goto out;
+
+      gso_size = msghdr_get_udp_gro(&mmsg[i].msg_hdr);
+      if(gso_size == 0) {
+        gso_size = mmsg[i].msg_len;
+      }
+
+      for(offset = 0; offset < mmsg[i].msg_len; offset = to) {
+        ++pkts;
+
+        to = offset + gso_size;
+        if(to > mmsg[i].msg_len) {
+          pktlen = mmsg[i].msg_len - offset;
+        }
+        else {
+          pktlen = gso_size;
+        }
+
+        result = recv_cb(bufs[i] + offset, pktlen, mmsg[i].msg_hdr.msg_name,
+                         mmsg[i].msg_hdr.msg_namelen, 0, userp);
+        if(result)
+          goto out;
+      }
     }
   }
 
@@ -418,6 +473,10 @@ static CURLcode recvmsg_packets(struct Curl_cfilter *cf,
   ssize_t nread;
   char errstr[STRERROR_LEN];
   CURLcode result = CURLE_OK;
+  uint8_t msg_ctrl[CMSG_SPACE(sizeof(uint16_t))];
+  size_t gso_size;
+  size_t pktlen;
+  size_t offset, to;
 
   msg_iov.iov_base = buf;
   msg_iov.iov_len = (int)sizeof(buf);
@@ -425,11 +484,13 @@ static CURLcode recvmsg_packets(struct Curl_cfilter *cf,
   memset(&msg, 0, sizeof(msg));
   msg.msg_iov = &msg_iov;
   msg.msg_iovlen = 1;
+  msg.msg_control = msg_ctrl;
 
   DEBUGASSERT(max_pkts > 0);
   for(pkts = 0, total_nread = 0; pkts < max_pkts;) {
     msg.msg_name = &remote_addr;
     msg.msg_namelen = sizeof(remote_addr);
+    msg.msg_controllen = sizeof(msg_ctrl);
     while((nread = recvmsg(qctx->sockfd, &msg, 0)) == -1 &&
           SOCKERRNO == EINTR)
       ;
@@ -452,12 +513,29 @@ static CURLcode recvmsg_packets(struct Curl_cfilter *cf,
       goto out;
     }
 
-    ++pkts;
     total_nread += (size_t)nread;
-    result = recv_cb(buf, (size_t)nread, msg.msg_name, msg.msg_namelen,
-                     0, userp);
-    if(result)
-      goto out;
+
+    gso_size = msghdr_get_udp_gro(&msg);
+    if(gso_size == 0) {
+      gso_size = (size_t)nread;
+    }
+
+    for(offset = 0; offset < (size_t)nread; offset = to) {
+      ++pkts;
+
+      to = offset + gso_size;
+      if(to > (size_t)nread) {
+        pktlen = (size_t)nread - offset;
+      }
+      else {
+        pktlen = gso_size;
+      }
+
+      result =
+        recv_cb(buf + offset, pktlen, msg.msg_name, msg.msg_namelen, 0, userp);
+      if(result)
+        goto out;
+    }
   }
 
 out:
@@ -655,7 +733,7 @@ CURLcode Curl_conn_may_http3(struct Curl_easy *data,
     return CURLE_URL_MALFORMAT;
   }
   if(conn->bits.httpproxy && conn->bits.tunnel_proxy) {
-    failf(data, "HTTP/3 is not supported over a HTTP proxy");
+    failf(data, "HTTP/3 is not supported over an HTTP proxy");
     return CURLE_URL_MALFORMAT;
   }
 #endif
diff --git a/lib/vssh/libssh.c b/lib/vssh/libssh.c
index d6ba987f1..20a05636d 100644
--- a/lib/vssh/libssh.c
+++ b/lib/vssh/libssh.c
@@ -388,28 +388,25 @@ static int myssh_is_known(struct Curl_easy *data)
     goto cleanup;
   }
 
-  if(data->set.ssl.primary.verifyhost != TRUE) {
-    rc = SSH_OK;
-    goto cleanup;
-  }
+  if(data->set.str[STRING_SSH_KNOWNHOSTS]) {
 
 #if LIBSSH_VERSION_INT >= SSH_VERSION_INT(0,9,0)
-  /* Get the known_key from the known hosts file */
-  vstate = ssh_session_get_known_hosts_entry(sshc->ssh_session,
-                                             &knownhostsentry);
-
-  /* Case an entry was found in a known hosts file */
-  if(knownhostsentry) {
-    if(knownhostsentry->publickey) {
-      rc = ssh_pki_export_pubkey_base64(knownhostsentry->publickey,
-                                        &known_base64);
-      if(rc != SSH_OK) {
-        goto cleanup;
-      }
-      knownkey.key = known_base64;
-      knownkey.len = strlen(known_base64);
+    /* Get the known_key from the known hosts file */
+    vstate = ssh_session_get_known_hosts_entry(sshc->ssh_session,
+                                               &knownhostsentry);
+
+    /* Case an entry was found in a known hosts file */
+    if(knownhostsentry) {
+      if(knownhostsentry->publickey) {
+        rc = ssh_pki_export_pubkey_base64(knownhostsentry->publickey,
+                                          &known_base64);
+        if(rc != SSH_OK) {
+          goto cleanup;
+        }
+        knownkey.key = known_base64;
+        knownkey.len = strlen(known_base64);
 
-      switch(ssh_key_type(knownhostsentry->publickey)) {
+        switch(ssh_key_type(knownhostsentry->publickey)) {
         case SSH_KEYTYPE_RSA:
           knownkey.keytype = CURLKHTYPE_RSA;
           break;
@@ -431,12 +428,12 @@ static int myssh_is_known(struct Curl_easy *data)
         default:
           rc = SSH_ERROR;
           goto cleanup;
+        }
+        knownkeyp = &knownkey;
       }
-      knownkeyp = &knownkey;
     }
-  }
 
-  switch(vstate) {
+    switch(vstate) {
     case SSH_KNOWN_HOSTS_OK:
       keymatch = CURLKHMATCH_OK;
       break;
@@ -446,14 +443,14 @@ static int myssh_is_known(struct Curl_easy *data)
     case SSH_KNOWN_HOSTS_ERROR:
       keymatch = CURLKHMATCH_MISSING;
       break;
-  default:
+    default:
       keymatch = CURLKHMATCH_MISMATCH;
       break;
-  }
+    }
 
 #else
-  vstate = ssh_is_server_known(sshc->ssh_session);
-  switch(vstate) {
+    vstate = ssh_is_server_known(sshc->ssh_session);
+    switch(vstate) {
     case SSH_SERVER_KNOWN_OK:
       keymatch = CURLKHMATCH_OK;
       break;
@@ -461,21 +458,21 @@ static int myssh_is_known(struct Curl_easy *data)
     case SSH_SERVER_NOT_KNOWN:
       keymatch = CURLKHMATCH_MISSING;
       break;
-  default:
+    default:
       keymatch = CURLKHMATCH_MISMATCH;
       break;
-  }
+    }
 #endif
 
-  if(func) { /* use callback to determine action */
-    rc = ssh_pki_export_pubkey_base64(pubkey, &found_base64);
-    if(rc != SSH_OK)
-      goto cleanup;
+    if(func) { /* use callback to determine action */
+      rc = ssh_pki_export_pubkey_base64(pubkey, &found_base64);
+      if(rc != SSH_OK)
+        goto cleanup;
 
-    foundkey.key = found_base64;
-    foundkey.len = strlen(found_base64);
+      foundkey.key = found_base64;
+      foundkey.len = strlen(found_base64);
 
-    switch(ssh_key_type(pubkey)) {
+      switch(ssh_key_type(pubkey)) {
       case SSH_KEYTYPE_RSA:
         foundkey.keytype = CURLKHTYPE_RSA;
         break;
@@ -501,15 +498,15 @@ static int myssh_is_known(struct Curl_easy *data)
       default:
         rc = SSH_ERROR;
         goto cleanup;
-    }
+      }
 
-    Curl_set_in_callback(data, true);
-    rc = func(data, knownkeyp, /* from the knownhosts file */
-              &foundkey, /* from the remote host */
-              keymatch, data->set.ssh_keyfunc_userp);
-    Curl_set_in_callback(data, false);
+      Curl_set_in_callback(data, true);
+      rc = func(data, knownkeyp, /* from the knownhosts file */
+                &foundkey, /* from the remote host */
+                keymatch, data->set.ssh_keyfunc_userp);
+      Curl_set_in_callback(data, false);
 
-    switch(rc) {
+      switch(rc) {
       case CURLKHSTAT_FINE_ADD_TO_FILE:
 #if LIBSSH_VERSION_INT >= SSH_VERSION_INT(0,8,0)
         rc = ssh_session_update_known_hosts(sshc->ssh_session);
@@ -525,12 +522,13 @@ static int myssh_is_known(struct Curl_easy *data)
       default: /* REJECT/DEFER */
         rc = SSH_ERROR;
         goto cleanup;
+      }
     }
-  }
-  else {
-    if(keymatch != CURLKHMATCH_OK) {
-      rc = SSH_ERROR;
-      goto cleanup;
+    else {
+      if(keymatch != CURLKHMATCH_OK) {
+        rc = SSH_ERROR;
+        goto cleanup;
+      }
     }
   }
   rc = SSH_OK;
@@ -663,7 +661,7 @@ restart:
 
 /*
  * ssh_statemach_act() runs the SSH state machine as far as it can without
- * blocking and without reaching the end.  The data the pointer 'block' points
+ * blocking and without reaching the end. The data the pointer 'block' points
  * to will be set to TRUE if the libssh function returns SSH_AGAIN
  * meaning it wants to be called again when the socket is ready
  */
@@ -677,7 +675,7 @@ static CURLcode myssh_statemach_act(struct Curl_easy *data, bool *block)
   int rc = SSH_NO_ERROR, err;
   int seekerr = CURL_SEEKFUNC_OK;
   const char *err_msg;
-  *block = 0;                   /* we're not blocking by default */
+  *block = 0;                   /* we are not blocking by default */
 
   do {
 
@@ -742,7 +740,8 @@ static CURLcode myssh_statemach_act(struct Curl_easy *data, bool *block)
           break;
         }
 
-        sshc->auth_methods = ssh_userauth_list(sshc->ssh_session, NULL);
+        sshc->auth_methods =
+          (unsigned int)ssh_userauth_list(sshc->ssh_session, NULL);
         if(sshc->auth_methods)
           infof(data, "SSH authentication methods available: %s%s%s%s",
                 sshc->auth_methods & SSH_AUTH_METHOD_PUBLICKEY ?
@@ -1308,7 +1307,7 @@ static CURLcode myssh_statemach_act(struct Curl_easy *data, bool *block)
             failf(data, "Could not seek stream");
             return CURLE_FTP_COULDNT_USE_REST;
           }
-          /* seekerr == CURL_SEEKFUNC_CANTSEEK (can't seek to offset) */
+          /* seekerr == CURL_SEEKFUNC_CANTSEEK (cannot seek to offset) */
           do {
             char scratch[4*1024];
             size_t readthisamountnow =
@@ -1351,12 +1350,12 @@ static CURLcode myssh_statemach_act(struct Curl_easy *data, bool *block)
         Curl_pgrsSetUploadSize(data, data->state.infilesize);
       }
       /* upload data */
-      Curl_xfer_setup(data, -1, -1, FALSE, FIRSTSOCKET);
+      Curl_xfer_setup1(data, CURL_XFER_SEND, -1, FALSE);
 
       /* not set by Curl_xfer_setup to preserve keepon bits */
       conn->sockfd = conn->writesockfd;
 
-      /* store this original bitmask setup to use later on if we can't
+      /* store this original bitmask setup to use later on if we cannot
          figure out a "real" bitmask */
       sshc->orig_waitfor = data->req.keepon;
 
@@ -1365,7 +1364,7 @@ static CURLcode myssh_statemach_act(struct Curl_easy *data, bool *block)
          with both accordingly */
       data->state.select_bits = CURL_CSELECT_OUT;
 
-      /* since we don't really wait for anything at this point, we want the
+      /* since we do not really wait for anything at this point, we want the
          state machine to move on as soon as possible so we set a very short
          timeout here */
       Curl_expire(data, 0, EXPIRE_RUN_NOW);
@@ -1404,7 +1403,7 @@ static CURLcode myssh_statemach_act(struct Curl_easy *data, bool *block)
       ++sshc->slash_pos;
       if(rc < 0) {
         /*
-         * Abort if failure wasn't that the dir already exists or the
+         * Abort if failure was not that the dir already exists or the
          * permission was denied (creation might succeed further down the
          * path) - retry on unspecific FAILURE also
          */
@@ -1577,7 +1576,7 @@ static CURLcode myssh_statemach_act(struct Curl_easy *data, bool *block)
       sshc->sftp_dir = NULL;
 
       /* no data to transfer */
-      Curl_xfer_setup(data, -1, -1, FALSE, -1);
+      Curl_xfer_setup_nop(data);
       state(data, SSH_STOP);
       break;
 
@@ -1611,9 +1610,9 @@ static CURLcode myssh_statemach_act(struct Curl_easy *data, bool *block)
               !(attrs->flags & SSH_FILEXFER_ATTR_SIZE) ||
               (attrs->size == 0)) {
         /*
-         * sftp_fstat didn't return an error, so maybe the server
-         * just doesn't support stat()
-         * OR the server doesn't return a file size with a stat()
+         * sftp_fstat did not return an error, so maybe the server
+         * just does not support stat()
+         * OR the server does not return a file size with a stat()
          * OR file size is 0
          */
         data->req.size = -1;
@@ -1686,7 +1685,7 @@ static CURLcode myssh_statemach_act(struct Curl_easy *data, bool *block)
       /* We can resume if we can seek to the resume position */
       if(data->state.resume_from) {
         if(data->state.resume_from < 0) {
-          /* We're supposed to download the last abs(from) bytes */
+          /* We are supposed to download the last abs(from) bytes */
           if((curl_off_t)size < -data->state.resume_from) {
             failf(data, "Offset (%"
                   CURL_FORMAT_CURL_OFF_T ") was beyond file size (%"
@@ -1722,12 +1721,12 @@ static CURLcode myssh_statemach_act(struct Curl_easy *data, bool *block)
     /* Setup the actual download */
     if(data->req.size == 0) {
       /* no data to transfer */
-      Curl_xfer_setup(data, -1, -1, FALSE, -1);
+      Curl_xfer_setup_nop(data);
       infof(data, "File already completely downloaded");
       state(data, SSH_STOP);
       break;
     }
-    Curl_xfer_setup(data, FIRSTSOCKET, data->req.size, FALSE, -1);
+    Curl_xfer_setup1(data, CURL_XFER_RECV, data->req.size, FALSE);
 
     /* not set by Curl_xfer_setup to preserve keepon bits */
     conn->writesockfd = conn->sockfd;
@@ -1851,12 +1850,12 @@ static CURLcode myssh_statemach_act(struct Curl_easy *data, bool *block)
       }
 
       /* upload data */
-      Curl_xfer_setup(data, -1, data->req.size, FALSE, FIRSTSOCKET);
+      Curl_xfer_setup1(data, CURL_XFER_SEND, -1, FALSE);
 
       /* not set by Curl_xfer_setup to preserve keepon bits */
       conn->sockfd = conn->writesockfd;
 
-      /* store this original bitmask setup to use later on if we can't
+      /* store this original bitmask setup to use later on if we cannot
          figure out a "real" bitmask */
       sshc->orig_waitfor = data->req.keepon;
 
@@ -1895,7 +1894,7 @@ static CURLcode myssh_statemach_act(struct Curl_easy *data, bool *block)
         /* download data */
         bytecount = ssh_scp_request_get_size(sshc->scp_session);
         data->req.maxdownload = (curl_off_t) bytecount;
-        Curl_xfer_setup(data, FIRSTSOCKET, bytecount, FALSE, -1);
+        Curl_xfer_setup1(data, CURL_XFER_RECV, bytecount, FALSE);
 
         /* not set by Curl_xfer_setup to preserve keepon bits */
         conn->writesockfd = conn->sockfd;
@@ -1946,7 +1945,7 @@ static CURLcode myssh_statemach_act(struct Curl_easy *data, bool *block)
       FALLTHROUGH();
 
     case SSH_SESSION_DISCONNECT:
-      /* during weird times when we've been prematurely aborted, the channel
+      /* during weird times when we have been prematurely aborted, the channel
          is still alive when we reach this state and we MUST kill the channel
          properly first */
       if(sshc->scp_session) {
@@ -2063,7 +2062,7 @@ static void myssh_block2waitfor(struct connectdata *conn, bool block)
 {
   struct ssh_conn *sshc = &conn->proto.sshc;
 
-  /* If it didn't block, or nothing was returned by ssh_get_poll_flags
+  /* If it did not block, or nothing was returned by ssh_get_poll_flags
    * have the original set */
   conn->waitfor = sshc->orig_waitfor;
 
@@ -2358,7 +2357,7 @@ static CURLcode scp_disconnect(struct Curl_easy *data,
   (void) dead_connection;
 
   if(ssh->ssh_session) {
-    /* only if there's a session still around to use! */
+    /* only if there is a session still around to use! */
 
     state(data, SSH_SESSION_DISCONNECT);
 
@@ -2523,7 +2522,7 @@ static CURLcode sftp_disconnect(struct Curl_easy *data,
   DEBUGF(infof(data, "SSH DISCONNECT starts now"));
 
   if(conn->proto.sshc.ssh_session) {
-    /* only if there's a session still around to use! */
+    /* only if there is a session still around to use! */
     state(data, SSH_SFTP_SHUTDOWN);
     result = myssh_block_statemach(data, TRUE);
   }
@@ -2613,7 +2612,7 @@ static ssize_t sftp_recv(struct Curl_easy *data, int sockindex,
 
       nread = sftp_async_read(conn->proto.sshc.sftp_file,
                               mem, (uint32_t)len,
-                              conn->proto.sshc.sftp_file_index);
+                              (uint32_t)conn->proto.sshc.sftp_file_index);
 
       myssh_block2waitfor(conn, (nread == SSH_AGAIN)?TRUE:FALSE);
 
@@ -2717,7 +2716,7 @@ static void sftp_quote(struct Curl_easy *data)
   }
 
   /*
-   * SFTP is a binary protocol, so we don't send text commands
+   * SFTP is a binary protocol, so we do not send text commands
    * to the server. Instead, we scan for commands used by
    * OpenSSH's sftp program and call the appropriate libssh
    * functions.
diff --git a/lib/vssh/libssh2.c b/lib/vssh/libssh2.c
index abdf42e55..1b566d1ab 100644
--- a/lib/vssh/libssh2.c
+++ b/lib/vssh/libssh2.c
@@ -405,8 +405,8 @@ static int sshkeycallback(struct Curl_easy *easy,
 #endif
 
 /*
- * Earlier libssh2 versions didn't have the ability to seek to 64bit positions
- * with 32bit size_t.
+ * Earlier libssh2 versions did not have the ability to seek to 64-bit
+ * positions with 32-bit size_t.
  */
 #ifdef HAVE_LIBSSH2_SFTP_SEEK64
 #define SFTP_SEEK(x,y) libssh2_sftp_seek64(x, (libssh2_uint64_t)y)
@@ -415,27 +415,27 @@ static int sshkeycallback(struct Curl_easy *easy,
 #endif
 
 /*
- * Earlier libssh2 versions didn't do SCP properly beyond 32bit sizes on 32bit
- * architectures so we check of the necessary function is present.
+ * Earlier libssh2 versions did not do SCP properly beyond 32-bit sizes on
+ * 32-bit architectures so we check of the necessary function is present.
  */
 #ifndef HAVE_LIBSSH2_SCP_SEND64
 #define SCP_SEND(a,b,c,d) libssh2_scp_send_ex(a, b, (int)(c), (size_t)d, 0, 0)
 #else
 #define SCP_SEND(a,b,c,d) libssh2_scp_send64(a, b, (int)(c),            \
-                                             (libssh2_uint64_t)d, 0, 0)
+                                             (libssh2_int64_t)d, 0, 0)
 #endif
 
 /*
- * libssh2 1.2.8 fixed the problem with 32bit ints used for sockets on win64.
+ * libssh2 1.2.8 fixed the problem with 32-bit ints used for sockets on win64.
  */
 #ifdef HAVE_LIBSSH2_SESSION_HANDSHAKE
 #define session_startup(x,y) libssh2_session_handshake(x, y)
 #else
 #define session_startup(x,y) libssh2_session_startup(x, (int)y)
 #endif
-static int convert_ssh2_keytype(int sshkeytype)
+static enum curl_khtype convert_ssh2_keytype(int sshkeytype)
 {
-  int keytype = CURLKHTYPE_UNKNOWN;
+  enum curl_khtype keytype = CURLKHTYPE_UNKNOWN;
   switch(sshkeytype) {
   case LIBSSH2_HOSTKEY_TYPE_RSA:
     keytype = CURLKHTYPE_RSA;
@@ -476,7 +476,7 @@ static CURLcode ssh_knownhost(struct Curl_easy *data)
 
 #ifdef HAVE_LIBSSH2_KNOWNHOST_API
   if(data->set.str[STRING_SSH_KNOWNHOSTS]) {
-    /* we're asked to verify the host against a file */
+    /* we are asked to verify the host against a file */
     struct connectdata *conn = data->conn;
     struct ssh_conn *sshc = &conn->proto.sshc;
     struct libssh2_knownhost *host = NULL;
@@ -487,8 +487,8 @@ static CURLcode ssh_knownhost(struct Curl_easy *data)
 
     if(remotekey) {
       /*
-       * A subject to figure out is what host name we need to pass in here.
-       * What host name does OpenSSH store in its file if an IDN name is
+       * A subject to figure out is what hostname we need to pass in here.
+       * What hostname does OpenSSH store in its file if an IDN name is
        * used?
        */
       enum curl_khmatch keymatch;
@@ -526,7 +526,7 @@ static CURLcode ssh_knownhost(struct Curl_easy *data)
         break;
 #endif
       default:
-        infof(data, "unsupported key type, can't check knownhosts");
+        infof(data, "unsupported key type, cannot check knownhosts");
         keybit = 0;
         break;
       }
@@ -600,7 +600,7 @@ static CURLcode ssh_knownhost(struct Curl_easy *data)
       result = sshc->actualcode = CURLE_PEER_FAILED_VERIFICATION;
       break;
     case CURLKHSTAT_FINE_REPLACE:
-      /* remove old host+key that doesn't match */
+      /* remove old host+key that does not match */
       if(host)
         libssh2_knownhost_del(sshc->kh, host);
       FALLTHROUGH();
@@ -608,7 +608,7 @@ static CURLcode ssh_knownhost(struct Curl_easy *data)
     case CURLKHSTAT_FINE_ADD_TO_FILE:
       /* proceed */
       if(keycheck != LIBSSH2_KNOWNHOST_CHECK_MATCH) {
-        /* the found host+key didn't match but has been told to be fine
+        /* the found host+key did not match but has been told to be fine
            anyway so we add it in memory */
         int addrc = libssh2_knownhost_add(sshc->kh,
                                           conn->host.name, NULL,
@@ -662,7 +662,7 @@ static CURLcode ssh_check_fingerprint(struct Curl_easy *data)
     size_t b64_pos = 0;
 
 #ifdef LIBSSH2_HOSTKEY_HASH_SHA256
-    /* The fingerprint points to static storage (!), don't free() it. */
+    /* The fingerprint points to static storage (!), do not free() it. */
     fingerprint = libssh2_hostkey_hash(sshc->ssh_session,
                                        LIBSSH2_HOSTKEY_HASH_SHA256);
 #else
@@ -742,7 +742,7 @@ static CURLcode ssh_check_fingerprint(struct Curl_easy *data)
                                        LIBSSH2_HOSTKEY_HASH_MD5);
 
     if(fingerprint) {
-      /* The fingerprint points to static storage (!), don't free() it. */
+      /* The fingerprint points to static storage (!), do not free() it. */
       int i;
       for(i = 0; i < 16; i++) {
         msnprintf(&md5buffer[i*2], 3, "%02x", (unsigned char) fingerprint[i]);
@@ -780,10 +780,10 @@ static CURLcode ssh_check_fingerprint(struct Curl_easy *data)
       const char *remotekey = libssh2_session_hostkey(sshc->ssh_session,
                                                       &keylen, &sshkeytype);
       if(remotekey) {
-        int keytype = convert_ssh2_keytype(sshkeytype);
+        enum curl_khtype keytype = convert_ssh2_keytype(sshkeytype);
         Curl_set_in_callback(data, true);
         rc = data->set.ssh_hostkeyfunc(data->set.ssh_hostkeyfunc_userp,
-                                       keytype, remotekey, keylen);
+                                       (int)keytype, remotekey, keylen);
         Curl_set_in_callback(data, false);
         if(rc!= CURLKHMATCH_OK) {
           state(data, SSH_SESSION_FREE);
@@ -960,7 +960,7 @@ static CURLcode ssh_force_knownhost_key_type(struct Curl_easy *data)
 
 /*
  * ssh_statemach_act() runs the SSH state machine as far as it can without
- * blocking and without reaching the end.  The data the pointer 'block' points
+ * blocking and without reaching the end. The data the pointer 'block' points
  * to will be set to TRUE if the libssh2 function returns LIBSSH2_ERROR_EAGAIN
  * meaning it wants to be called again when the socket is ready
  */
@@ -977,7 +977,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
   unsigned long sftperr;
   int seekerr = CURL_SEEKFUNC_OK;
   size_t readdir_len;
-  *block = 0; /* we're not blocking by default */
+  *block = 0; /* we are not blocking by default */
 
   do {
     switch(sshc->state) {
@@ -1037,7 +1037,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
        * must never change it later. Thus, always specify the correct username
        * here, even though the libssh2 docs kind of indicate that it should be
        * possible to get a 'generic' list (not user-specific) of authentication
-       * methods, presumably with a blank username. That won't work in my
+       * methods, presumably with a blank username. That will not work in my
        * experience.
        * So always specify it here.
        */
@@ -1440,7 +1440,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
         if(sftperr)
           result = sftp_libssh2_error_to_CURLE(sftperr);
         else
-          /* in this case, the error wasn't in the SFTP level but for example
+          /* in this case, the error was not in the SFTP level but for example
              a time-out or similar */
           result = CURLE_SSH;
         sshc->actualcode = result;
@@ -1571,7 +1571,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
       }
 
       /*
-       * SFTP is a binary protocol, so we don't send text commands
+       * SFTP is a binary protocol, so we do not send text commands
        * to the server. Instead, we scan for commands used by
        * OpenSSH's sftp program and call the appropriate libssh2
        * functions.
@@ -1709,7 +1709,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
       if(!strncasecompare(cmd, "chmod", 5)) {
         /* Since chown and chgrp only set owner OR group but libssh2 wants to
          * set them both at once, we need to obtain the current ownership
-         * first.  This takes an extra protocol round trip.
+         * first. This takes an extra protocol round trip.
          */
         rc = libssh2_sftp_stat_ex(sshc->sftp_session, sshc->quote_path2,
                                   curlx_uztoui(strlen(sshc->quote_path2)),
@@ -1786,7 +1786,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
         }
 #if SIZEOF_TIME_T > SIZEOF_LONG
         if(date > 0xffffffff) {
-          /* if 'long' can't old >32bit, this date cannot be sent */
+          /* if 'long' cannot old >32bit, this date cannot be sent */
           failf(data, "date overflow");
           fail = TRUE;
         }
@@ -1860,7 +1860,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
     case SSH_SFTP_QUOTE_MKDIR:
       rc = libssh2_sftp_mkdir_ex(sshc->sftp_session, sshc->quote_path1,
                                  curlx_uztoui(strlen(sshc->quote_path1)),
-                                 data->set.new_directory_perms);
+                                 (long)data->set.new_directory_perms);
       if(rc == LIBSSH2_ERROR_EAGAIN) {
         break;
       }
@@ -2026,7 +2026,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
         break;
       }
       if(rc == 0) {
-        data->info.filetime = attrs.mtime;
+        data->info.filetime = (time_t)attrs.mtime;
       }
 
       state(data, SSH_SFTP_TRANS_INIT);
@@ -2090,7 +2090,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
       sshc->sftp_handle =
         libssh2_sftp_open_ex(sshc->sftp_session, sshp->path,
                              curlx_uztoui(strlen(sshp->path)),
-                             flags, data->set.new_file_perms,
+                             flags, (long)data->set.new_file_perms,
                              LIBSSH2_SFTP_OPENFILE);
 
       if(!sshc->sftp_handle) {
@@ -2160,7 +2160,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
             failf(data, "Could not seek stream");
             return CURLE_FTP_COULDNT_USE_REST;
           }
-          /* seekerr == CURL_SEEKFUNC_CANTSEEK (can't seek to offset) */
+          /* seekerr == CURL_SEEKFUNC_CANTSEEK (cannot seek to offset) */
           do {
             char scratch[4*1024];
             size_t readthisamountnow =
@@ -2199,7 +2199,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
         Curl_pgrsSetUploadSize(data, data->state.infilesize);
       }
       /* upload data */
-      Curl_xfer_setup(data, -1, -1, FALSE, FIRSTSOCKET);
+      Curl_xfer_setup1(data, CURL_XFER_SEND, -1, FALSE);
 
       /* not set by Curl_xfer_setup to preserve keepon bits */
       conn->sockfd = conn->writesockfd;
@@ -2209,7 +2209,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
         sshc->actualcode = result;
       }
       else {
-        /* store this original bitmask setup to use later on if we can't
+        /* store this original bitmask setup to use later on if we cannot
            figure out a "real" bitmask */
         sshc->orig_waitfor = data->req.keepon;
 
@@ -2218,7 +2218,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
            with both accordingly */
         data->state.select_bits = CURL_CSELECT_OUT;
 
-        /* since we don't really wait for anything at this point, we want the
+        /* since we do not really wait for anything at this point, we want the
            state machine to move on as soon as possible so we set a very short
            timeout here */
         Curl_expire(data, 0, EXPIRE_RUN_NOW);
@@ -2254,7 +2254,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
       /* 'mode' - parameter is preliminary - default to 0644 */
       rc = libssh2_sftp_mkdir_ex(sshc->sftp_session, sshp->path,
                                  curlx_uztoui(strlen(sshp->path)),
-                                 data->set.new_directory_perms);
+                                 (long)data->set.new_directory_perms);
       if(rc == LIBSSH2_ERROR_EAGAIN) {
         break;
       }
@@ -2262,7 +2262,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
       ++sshc->slash_pos;
       if(rc < 0) {
         /*
-         * Abort if failure wasn't that the dir already exists or the
+         * Abort if failure was not that the dir already exists or the
          * permission was denied (creation might succeed further down the
          * path) - retry on unspecific FAILURE also
          */
@@ -2402,7 +2402,8 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
       rc =
         libssh2_sftp_symlink_ex(sshc->sftp_session,
                                 Curl_dyn_ptr(&sshp->readdir_link),
-                                (int)Curl_dyn_len(&sshp->readdir_link),
+                                (unsigned int)
+                                  Curl_dyn_len(&sshp->readdir_link),
                                 sshp->readdir_filename,
                                 PATH_MAX, LIBSSH2_SFTP_READLINK);
       if(rc == LIBSSH2_ERROR_EAGAIN) {
@@ -2452,7 +2453,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
       Curl_safefree(sshp->readdir_longentry);
 
       /* no data to transfer */
-      Curl_xfer_setup(data, -1, -1, FALSE, -1);
+      Curl_xfer_setup_nop(data);
       state(data, SSH_STOP);
       break;
 
@@ -2463,7 +2464,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
       sshc->sftp_handle =
         libssh2_sftp_open_ex(sshc->sftp_session, sshp->path,
                              curlx_uztoui(strlen(sshp->path)),
-                             LIBSSH2_FXF_READ, data->set.new_file_perms,
+                             LIBSSH2_FXF_READ, (long)data->set.new_file_perms,
                              LIBSSH2_SFTP_OPENFILE);
       if(!sshc->sftp_handle) {
         if(libssh2_session_last_errno(sshc->ssh_session) ==
@@ -2496,9 +2497,9 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
          !(attrs.flags & LIBSSH2_SFTP_ATTR_SIZE) ||
          (attrs.filesize == 0)) {
         /*
-         * libssh2_sftp_open() didn't return an error, so maybe the server
-         * just doesn't support stat()
-         * OR the server doesn't return a file size with a stat()
+         * libssh2_sftp_open() did not return an error, so maybe the server
+         * just does not support stat()
+         * OR the server does not return a file size with a stat()
          * OR file size is 0
          */
         data->req.size = -1;
@@ -2563,7 +2564,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
       /* We can resume if we can seek to the resume position */
       if(data->state.resume_from) {
         if(data->state.resume_from < 0) {
-          /* We're supposed to download the last abs(from) bytes */
+          /* We are supposed to download the last abs(from) bytes */
           if((curl_off_t)attrs.filesize < -data->state.resume_from) {
             failf(data, "Offset (%"
                   CURL_FORMAT_CURL_OFF_T ") was beyond file size (%"
@@ -2594,12 +2595,12 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
     /* Setup the actual download */
     if(data->req.size == 0) {
       /* no data to transfer */
-      Curl_xfer_setup(data, -1, -1, FALSE, -1);
+      Curl_xfer_setup_nop(data);
       infof(data, "File already completely downloaded");
       state(data, SSH_STOP);
       break;
     }
-    Curl_xfer_setup(data, FIRSTSOCKET, data->req.size, FALSE, -1);
+    Curl_xfer_setup1(data, CURL_XFER_RECV, data->req.size, FALSE);
 
     /* not set by Curl_xfer_setup to preserve keepon bits */
     conn->writesockfd = conn->sockfd;
@@ -2713,7 +2714,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
     case SSH_SCP_UPLOAD_INIT:
       /*
        * libssh2 requires that the destination path is a full path that
-       * includes the destination file and name OR ends in a "/" .  If this is
+       * includes the destination file and name OR ends in a "/" . If this is
        * not done the destination file will be named the same name as the last
        * directory in the path.
        */
@@ -2745,7 +2746,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
       /* upload data */
       data->req.size = data->state.infilesize;
       Curl_pgrsSetUploadSize(data, data->state.infilesize);
-      Curl_xfer_setup(data, -1, -1, FALSE, FIRSTSOCKET);
+      Curl_xfer_setup1(data, CURL_XFER_SEND, -1, FALSE);
 
       /* not set by Curl_xfer_setup to preserve keepon bits */
       conn->sockfd = conn->writesockfd;
@@ -2755,7 +2756,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
         sshc->actualcode = result;
       }
       else {
-        /* store this original bitmask setup to use later on if we can't
+        /* store this original bitmask setup to use later on if we cannot
            figure out a "real" bitmask */
         sshc->orig_waitfor = data->req.keepon;
 
@@ -2816,7 +2817,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
       /* download data */
       bytecount = (curl_off_t)sb.st_size;
       data->req.maxdownload = (curl_off_t)sb.st_size;
-      Curl_xfer_setup(data, FIRSTSOCKET, bytecount, FALSE, -1);
+      Curl_xfer_setup1(data, CURL_XFER_RECV, bytecount, FALSE);
 
       /* not set by Curl_xfer_setup to preserve keepon bits */
       conn->writesockfd = conn->sockfd;
@@ -2915,7 +2916,7 @@ static CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)
       break;
 
     case SSH_SESSION_DISCONNECT:
-      /* during weird times when we've been prematurely aborted, the channel
+      /* during weird times when we have been prematurely aborted, the channel
          is still alive when we reach this state and we MUST kill the channel
          properly first */
       if(sshc->ssh_channel) {
@@ -3071,7 +3072,7 @@ static int ssh_getsock(struct Curl_easy *data,
  * When one of the libssh2 functions has returned LIBSSH2_ERROR_EAGAIN this
  * function is used to figure out in what direction and stores this info so
  * that the multi interface can take advantage of it. Make sure to call this
- * function in all cases so that when it _doesn't_ return EAGAIN we can
+ * function in all cases so that when it _does not_ return EAGAIN we can
  * restore the default wait bits.
  */
 static void ssh_block2waitfor(struct Curl_easy *data, bool block)
@@ -3088,7 +3089,7 @@ static void ssh_block2waitfor(struct Curl_easy *data, bool block)
     }
   }
   if(!dir)
-    /* It didn't block or libssh2 didn't reveal in which direction, put back
+    /* It did not block or libssh2 did not reveal in which direction, put back
        the original set */
     conn->waitfor = sshc->orig_waitfor;
 }
@@ -3104,7 +3105,7 @@ static CURLcode ssh_multi_statemach(struct Curl_easy *data, bool *done)
   do {
     result = ssh_statemach_act(data, &block);
     *done = (sshc->state == SSH_STOP) ? TRUE : FALSE;
-    /* if there's no error, it isn't done and it didn't EWOULDBLOCK, then
+    /* if there is no error, it is not done and it did not EWOULDBLOCK, then
        try again */
   } while(!result && !*done && !block);
   ssh_block2waitfor(data, block);
@@ -3290,7 +3291,7 @@ static CURLcode ssh_connect(struct Curl_easy *data, bool *done)
 #if LIBSSH2_VERSION_NUM >= 0x010B00
   if(data->set.server_response_timeout > 0) {
     libssh2_session_set_read_timeout(sshc->ssh_session,
-                                     data->set.server_response_timeout / 1000);
+                             (long)(data->set.server_response_timeout / 1000));
   }
 #endif
 
@@ -3491,7 +3492,7 @@ static CURLcode scp_disconnect(struct Curl_easy *data,
   (void) dead_connection;
 
   if(sshc->ssh_session) {
-    /* only if there's a session still around to use! */
+    /* only if there is a session still around to use! */
     state(data, SSH_SESSION_DISCONNECT);
     result = ssh_block_statemach(data, conn, TRUE);
   }
@@ -3647,7 +3648,7 @@ static CURLcode sftp_disconnect(struct Curl_easy *data,
   DEBUGF(infof(data, "SSH DISCONNECT starts now"));
 
   if(sshc->ssh_session) {
-    /* only if there's a session still around to use! */
+    /* only if there is a session still around to use! */
     state(data, SSH_SFTP_SHUTDOWN);
     result = ssh_block_statemach(data, conn, TRUE);
   }
diff --git a/lib/vssh/ssh.h b/lib/vssh/ssh.h
index ca0533aa5..64ef33298 100644
--- a/lib/vssh/ssh.h
+++ b/lib/vssh/ssh.h
@@ -163,7 +163,7 @@ struct ssh_conn {
   unsigned kbd_state; /* 0 or 1 */
   ssh_key privkey;
   ssh_key pubkey;
-  int auth_methods;
+  unsigned int auth_methods;
   ssh_session ssh_session;
   ssh_scp scp_session;
   sftp_session sftp_session;
@@ -243,10 +243,10 @@ struct ssh_conn {
 #endif
 
 #ifdef HAVE_LIBSSH2_VERSION
-/* get it run-time if possible */
+/* get it runtime if possible */
 #define CURL_LIBSSH2_VERSION libssh2_version(0)
 #else
-/* use build-time if run-time not possible */
+/* use build-time if runtime not possible */
 #define CURL_LIBSSH2_VERSION LIBSSH2_VERSION
 #endif
 
diff --git a/lib/vssh/wolfssh.c b/lib/vssh/wolfssh.c
index 6a5aed88f..1ed24fe4e 100644
--- a/lib/vssh/wolfssh.c
+++ b/lib/vssh/wolfssh.c
@@ -400,7 +400,7 @@ static CURLcode wssh_connect(struct Curl_easy *data, bool *done)
 
   rc = wolfSSH_SetUsername(sshc->ssh_session, conn->user);
   if(rc != WS_SUCCESS) {
-    failf(data, "wolfSSH failed to set user name");
+    failf(data, "wolfSSH failed to set username");
     goto error;
   }
 
@@ -433,7 +433,7 @@ error:
 
 /*
  * wssh_statemach_act() runs the SSH state machine as far as it can without
- * blocking and without reaching the end.  The data the pointer 'block' points
+ * blocking and without reaching the end. The data the pointer 'block' points
  * to will be set to TRUE if the wolfssh function returns EAGAIN meaning it
  * wants to be called again when the socket is ready
  */
@@ -446,7 +446,7 @@ static CURLcode wssh_statemach_act(struct Curl_easy *data, bool *block)
   struct SSHPROTO *sftp_scp = data->req.p.ssh;
   WS_SFTPNAME *name;
   int rc = 0;
-  *block = FALSE; /* we're not blocking by default */
+  *block = FALSE; /* we are not blocking by default */
 
   do {
     switch(sshc->state) {
@@ -641,7 +641,7 @@ static CURLcode wssh_statemach_act(struct Curl_easy *data, bool *block)
             failf(data, "Could not seek stream");
             return CURLE_FTP_COULDNT_USE_REST;
           }
-          /* seekerr == CURL_SEEKFUNC_CANTSEEK (can't seek to offset) */
+          /* seekerr == CURL_SEEKFUNC_CANTSEEK (cannot seek to offset) */
           do {
             char scratch[4*1024];
             size_t readthisamountnow =
@@ -680,7 +680,7 @@ static CURLcode wssh_statemach_act(struct Curl_easy *data, bool *block)
         Curl_pgrsSetUploadSize(data, data->state.infilesize);
       }
       /* upload data */
-      Curl_xfer_setup(data, -1, -1, FALSE, FIRSTSOCKET);
+      Curl_xfer_setup1(data, CURL_XFER_SEND, -1, FALSE);
 
       /* not set by Curl_xfer_setup to preserve keepon bits */
       conn->sockfd = conn->writesockfd;
@@ -690,7 +690,7 @@ static CURLcode wssh_statemach_act(struct Curl_easy *data, bool *block)
         sshc->actualcode = result;
       }
       else {
-        /* store this original bitmask setup to use later on if we can't
+        /* store this original bitmask setup to use later on if we cannot
            figure out a "real" bitmask */
         sshc->orig_waitfor = data->req.keepon;
 
@@ -699,7 +699,7 @@ static CURLcode wssh_statemach_act(struct Curl_easy *data, bool *block)
            with both accordingly */
         data->state.select_bits = CURL_CSELECT_OUT;
 
-        /* since we don't really wait for anything at this point, we want the
+        /* since we do not really wait for anything at this point, we want the
            state machine to move on as soon as possible so we set a very short
            timeout here */
         Curl_expire(data, 0, EXPIRE_RUN_NOW);
@@ -780,12 +780,12 @@ static CURLcode wssh_statemach_act(struct Curl_easy *data, bool *block)
       /* Setup the actual download */
       if(data->req.size == 0) {
         /* no data to transfer */
-        Curl_xfer_setup(data, -1, -1, FALSE, -1);
+        Curl_xfer_setup_nop(data);
         infof(data, "File already completely downloaded");
         state(data, SSH_STOP);
         break;
       }
-      Curl_xfer_setup(data, FIRSTSOCKET, data->req.size, FALSE, -1);
+      Curl_xfer_setup1(data, CURL_XFER_RECV, data->req.size, FALSE);
 
       /* not set by Curl_xfer_setup to preserve keepon bits */
       conn->writesockfd = conn->sockfd;
@@ -908,7 +908,7 @@ static CURLcode wssh_multi_statemach(struct Curl_easy *data, bool *done)
   do {
     result = wssh_statemach_act(data, &block);
     *done = (sshc->state == SSH_STOP) ? TRUE : FALSE;
-    /* if there's no error, it isn't done and it didn't EWOULDBLOCK, then
+    /* if there is no error, it is not done and it did not EWOULDBLOCK, then
        try again */
     if(*done) {
       DEBUGF(infof(data, "wssh_statemach_act says DONE"));
@@ -1121,7 +1121,7 @@ static CURLcode wsftp_disconnect(struct Curl_easy *data,
   DEBUGF(infof(data, "SSH DISCONNECT starts now"));
 
   if(conn->proto.sshc.ssh_session) {
-    /* only if there's a session still around to use! */
+    /* only if there is a session still around to use! */
     state(data, SSH_SFTP_SHUTDOWN);
     result = wssh_block_statemach(data, TRUE);
   }
diff --git a/lib/vtls/bearssl.c b/lib/vtls/bearssl.c
index a595f54a9..47c5528c2 100644
--- a/lib/vtls/bearssl.c
+++ b/lib/vtls/bearssl.c
@@ -63,6 +63,7 @@ struct bearssl_ssl_backend_data {
   bool active;
   /* size of pending write, yet to be flushed */
   size_t pending_write;
+  BIT(sent_shutdown);
 };
 
 struct cafile_parser {
@@ -327,7 +328,7 @@ static unsigned x509_end_chain(const br_x509_class **ctx)
   struct x509_context *x509 = (struct x509_context *)ctx;
 
   if(!x509->verifypeer) {
-    return br_x509_decoder_last_error(&x509->decoder);
+    return (unsigned)br_x509_decoder_last_error(&x509->decoder);
   }
 
   return x509->minimal.vtable->end_chain(&x509->minimal.vtable);
@@ -583,7 +584,7 @@ static CURLcode bearssl_connect_step1(struct Curl_cfilter *cf,
   backend->x509.verifyhost = verifyhost;
   br_ssl_engine_set_x509(&backend->ctx.eng, &backend->x509.vtable);
 
-  if(ssl_config->primary.sessionid) {
+  if(ssl_config->primary.cache_session) {
     void *session;
 
     CURL_TRC_CF(data, cf, "connect_step1, check session cache");
@@ -722,6 +723,8 @@ static CURLcode bearssl_run_until(struct Curl_cfilter *cf,
       ret = Curl_conn_cf_send(cf->next, data, (char *)buf, len, &result);
       CURL_TRC_CF(data, cf, "ssl_send(len=%zu) -> %zd, %d", len, ret, result);
       if(ret <= 0) {
+        if(result == CURLE_AGAIN)
+          connssl->io_need |= CURL_SSL_IO_NEED_SEND;
         return result;
       }
       br_ssl_engine_sendrec_ack(&backend->ctx.eng, ret);
@@ -735,6 +738,8 @@ static CURLcode bearssl_run_until(struct Curl_cfilter *cf,
         return CURLE_RECV_ERROR;
       }
       if(ret <= 0) {
+        if(result == CURLE_AGAIN)
+          connssl->io_need |= CURL_SSL_IO_NEED_RECV;
         return result;
       }
       br_ssl_engine_recvrec_ack(&backend->ctx.eng, ret);
@@ -813,9 +818,7 @@ static CURLcode bearssl_connect_step3(struct Curl_cfilter *cf,
                              proto? strlen(proto) : 0);
   }
 
-  if(ssl_config->primary.sessionid) {
-    bool incache;
-    void *oldsession;
+  if(ssl_config->primary.cache_session) {
     br_ssl_session_parameters *session;
 
     session = malloc(sizeof(*session));
@@ -823,13 +826,8 @@ static CURLcode bearssl_connect_step3(struct Curl_cfilter *cf,
       return CURLE_OUT_OF_MEMORY;
     br_ssl_engine_get_session_parameters(&backend->ctx.eng, session);
     Curl_ssl_sessionid_lock(data);
-    incache = !(Curl_ssl_getsessionid(cf, data, &connssl->peer,
-                                      &oldsession, NULL));
-    if(incache)
-      Curl_ssl_delsessionid(data, oldsession);
-
-    ret = Curl_ssl_addsessionid(cf, data, &connssl->peer, session, 0,
-                                bearssl_session_free);
+    ret = Curl_ssl_set_sessionid(cf, data, &connssl->peer, session, 0,
+                                 bearssl_session_free);
     Curl_ssl_sessionid_unlock(data);
     if(ret)
       return ret;
@@ -925,9 +923,7 @@ static CURLcode bearssl_connect_common(struct Curl_cfilter *cf,
       return ret;
   }
 
-  while(ssl_connect_2 == connssl->connecting_state ||
-        ssl_connect_2_reading == connssl->connecting_state ||
-        ssl_connect_2_writing == connssl->connecting_state) {
+  while(ssl_connect_2 == connssl->connecting_state) {
     /* check allowed time left */
     timeout_ms = Curl_timeleft(data, NULL, TRUE);
 
@@ -937,14 +933,13 @@ static CURLcode bearssl_connect_common(struct Curl_cfilter *cf,
       return CURLE_OPERATION_TIMEDOUT;
     }
 
-    /* if ssl is expecting something, check if it's available. */
-    if(ssl_connect_2_reading == connssl->connecting_state ||
-       ssl_connect_2_writing == connssl->connecting_state) {
+    /* if ssl is expecting something, check if it is available. */
+    if(connssl->io_need) {
 
-      curl_socket_t writefd = ssl_connect_2_writing ==
-        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;
-      curl_socket_t readfd = ssl_connect_2_reading ==
-        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;
+      curl_socket_t writefd = (connssl->io_need & CURL_SSL_IO_NEED_SEND)?
+                              sockfd:CURL_SOCKET_BAD;
+      curl_socket_t readfd = (connssl->io_need & CURL_SSL_IO_NEED_RECV)?
+                             sockfd:CURL_SOCKET_BAD;
 
       CURL_TRC_CF(data, cf, "connect_common, check socket");
       what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,
@@ -975,11 +970,9 @@ static CURLcode bearssl_connect_common(struct Curl_cfilter *cf,
      * before step2 has completed while ensuring that a client using select()
      * or epoll() will always have a valid fdset to wait on.
      */
+    connssl->io_need = CURL_SSL_IO_NEED_NONE;
     ret = bearssl_connect_step2(cf, data);
-    if(ret || (nonblocking &&
-               (ssl_connect_2 == connssl->connecting_state ||
-                ssl_connect_2_reading == connssl->connecting_state ||
-                ssl_connect_2_writing == connssl->connecting_state)))
+    if(ret || (nonblocking && (ssl_connect_2 == connssl->connecting_state)))
       return ret;
   }
 
@@ -1070,20 +1063,52 @@ static void *bearssl_get_internals(struct ssl_connect_data *connssl,
   return &backend->ctx;
 }
 
-static void bearssl_close(struct Curl_cfilter *cf, struct Curl_easy *data)
+static CURLcode bearssl_shutdown(struct Curl_cfilter *cf,
+                                 struct Curl_easy *data,
+                                 bool send_shutdown, bool *done)
 {
   struct ssl_connect_data *connssl = cf->ctx;
   struct bearssl_ssl_backend_data *backend =
     (struct bearssl_ssl_backend_data *)connssl->backend;
-  size_t i;
+  CURLcode result;
 
   DEBUGASSERT(backend);
+  if(!backend->active || cf->shutdown) {
+    *done = TRUE;
+    return CURLE_OK;
+  }
 
-  if(backend->active) {
-    backend->active = FALSE;
+  *done = FALSE;
+  if(!backend->sent_shutdown) {
+    (void)send_shutdown; /* unknown how to suppress our close notify */
     br_ssl_engine_close(&backend->ctx.eng);
-    (void)bearssl_run_until(cf, data, BR_SSL_CLOSED);
+    backend->sent_shutdown = TRUE;
+  }
+
+  result = bearssl_run_until(cf, data, BR_SSL_CLOSED);
+  if(result == CURLE_OK) {
+    *done = TRUE;
   }
+  else if(result == CURLE_AGAIN)
+    result = CURLE_OK;
+  else
+    CURL_TRC_CF(data, cf, "shutdown error: %d", result);
+
+  cf->shutdown = (result || *done);
+  return result;
+}
+
+static void bearssl_close(struct Curl_cfilter *cf, struct Curl_easy *data)
+{
+  struct ssl_connect_data *connssl = cf->ctx;
+  struct bearssl_ssl_backend_data *backend =
+    (struct bearssl_ssl_backend_data *)connssl->backend;
+  size_t i;
+
+  (void)data;
+  DEBUGASSERT(backend);
+
+  backend->active = FALSE;
   if(backend->anchors) {
     for(i = 0; i < backend->anchors_len; ++i)
       free(backend->anchors[i].dn.data);
@@ -1113,7 +1138,7 @@ const struct Curl_ssl Curl_ssl_bearssl = {
   Curl_none_cleanup,               /* cleanup */
   bearssl_version,                 /* version */
   Curl_none_check_cxn,             /* check_cxn */
-  Curl_none_shutdown,              /* shutdown */
+  bearssl_shutdown,                /* shutdown */
   bearssl_data_pending,            /* data_pending */
   bearssl_random,                  /* random */
   Curl_none_cert_status_request,   /* cert_status_request */
@@ -1130,7 +1155,6 @@ const struct Curl_ssl Curl_ssl_bearssl = {
   bearssl_sha256sum,               /* sha256sum */
   NULL,                            /* associate_connection */
   NULL,                            /* disassociate_connection */
-  NULL,                            /* free_multi_ssl_backend_data */
   bearssl_recv,                    /* recv decrypted data */
   bearssl_send,                    /* send data to encrypt */
 };
diff --git a/lib/vtls/cipher_suite.c b/lib/vtls/cipher_suite.c
index a78838d19..83ac5ddfa 100644
--- a/lib/vtls/cipher_suite.c
+++ b/lib/vtls/cipher_suite.c
@@ -23,7 +23,7 @@
  ***************************************************************************/
 #include "curl_setup.h"
 
-#if defined(USE_MBEDTLS) || defined(USE_BEARSSL)
+#if defined(USE_SECTRANSP) || defined(USE_MBEDTLS) || defined(USE_BEARSSL)
 #include "cipher_suite.h"
 #include "curl_printf.h"
 #include "strcase.h"
@@ -33,7 +33,7 @@
  * To support the CURLOPT_SSL_CIPHER_LIST option on SSL backends
  * that do not support it natively, but do support setting a list of
  * IANA ids, we need a list of all supported cipher suite names
- * (openssl and IANA) to be able to look up the IANA ids.
+ * (OpenSSL and IANA) to be able to look up the IANA ids.
  *
  * To keep the binary size of this list down we compress each entry
  * down to 2 + 6 bytes using the C preprocessor.
@@ -42,7 +42,7 @@
 /*
  * mbedTLS NOTE: mbedTLS has mbedtls_ssl_get_ciphersuite_id() to
  * convert a string representation to an IANA id, we do not use that
- * because it does not support "standard" openssl cipher suite
+ * because it does not support "standard" OpenSSL cipher suite
  * names, nor IANA names.
  */
 
@@ -89,6 +89,21 @@ static const char *cs_txt =
   "CAMELLIA128" "\0"
   "CAMELLIA256" "\0"
 #endif
+#if defined(USE_SECTRANSP)
+  "40" "\0"
+  "ADH" "\0"
+  "AECDH" "\0"
+  "anon" "\0"
+  "DES40" "\0"
+  "DH" "\0"
+  "DSS" "\0"
+  "EDH" "\0"
+  "EXP" "\0"
+  "EXPORT" "\0"
+  "IDEA" "\0"
+  "RC2" "\0"
+  "RC4" "\0"
+#endif
 ;
 /* Indexes of above cs_txt */
 enum {
@@ -129,6 +144,21 @@ enum {
   CS_TXT_IDX_CAMELLIA,
   CS_TXT_IDX_CAMELLIA128,
   CS_TXT_IDX_CAMELLIA256,
+#endif
+#if defined(USE_SECTRANSP)
+  CS_TXT_IDX_40,
+  CS_TXT_IDX_ADH,
+  CS_TXT_IDX_AECDH,
+  CS_TXT_IDX_anon,
+  CS_TXT_IDX_DES40,
+  CS_TXT_IDX_DH,
+  CS_TXT_IDX_DSS,
+  CS_TXT_IDX_EDH,
+  CS_TXT_IDX_EXP,
+  CS_TXT_IDX_EXPORT,
+  CS_TXT_IDX_IDEA,
+  CS_TXT_IDX_RC2,
+  CS_TXT_IDX_RC4,
 #endif
   CS_TXT_LEN,
 };
@@ -224,7 +254,7 @@ static const struct cs_entry cs_list [] = {
   CS_ENTRY(0xCCA8, ECDHE,RSA,CHACHA20,POLY1305,,,,),
   CS_ENTRY(0xCCA9, TLS,ECDHE,ECDSA,WITH,CHACHA20,POLY1305,SHA256,),
   CS_ENTRY(0xCCA9, ECDHE,ECDSA,CHACHA20,POLY1305,,,,),
-#if defined(USE_MBEDTLS)
+#if defined(USE_SECTRANSP) || defined(USE_MBEDTLS)
   CS_ENTRY(0x0001, TLS,RSA,WITH,NULL,MD5,,,),
   CS_ENTRY(0x0001, NULL,MD5,,,,,,),
   CS_ENTRY(0x0002, TLS,RSA,WITH,NULL,SHA,,,),
@@ -317,7 +347,7 @@ static const struct cs_entry cs_list [] = {
   CS_ENTRY(0xCCAB, TLS,PSK,WITH,CHACHA20,POLY1305,SHA256,,),
   CS_ENTRY(0xCCAB, PSK,CHACHA20,POLY1305,,,,,),
 #endif
-#if defined(USE_BEARSSL)
+#if defined(USE_SECTRANSP) || defined(USE_BEARSSL)
   CS_ENTRY(0x000A, TLS,RSA,WITH,3DES,EDE,CBC,SHA,),
   CS_ENTRY(0x000A, DES,CBC3,SHA,,,,,),
   CS_ENTRY(0xC003, TLS,ECDH,ECDSA,WITH,3DES,EDE,CBC,SHA),
@@ -329,6 +359,7 @@ static const struct cs_entry cs_list [] = {
   CS_ENTRY(0xC012, TLS,ECDHE,RSA,WITH,3DES,EDE,CBC,SHA),
   CS_ENTRY(0xC012, ECDHE,RSA,DES,CBC3,SHA,,,),
 #endif
+#if defined(USE_MBEDTLS) || defined(USE_BEARSSL)
   CS_ENTRY(0xC09C, TLS,RSA,WITH,AES,128,CCM,,),
   CS_ENTRY(0xC09C, AES128,CCM,,,,,,),
   CS_ENTRY(0xC09D, TLS,RSA,WITH,AES,256,CCM,,),
@@ -345,8 +376,144 @@ static const struct cs_entry cs_list [] = {
   CS_ENTRY(0xC0AE, ECDHE,ECDSA,AES128,CCM8,,,,),
   CS_ENTRY(0xC0AF, TLS,ECDHE,ECDSA,WITH,AES,256,CCM,8),
   CS_ENTRY(0xC0AF, ECDHE,ECDSA,AES256,CCM8,,,,),
+#endif
+#if defined(USE_SECTRANSP)
+  /* entries marked bc are backward compatible aliases for old OpenSSL names */
+  CS_ENTRY(0x0003, TLS,RSA,EXPORT,WITH,RC4,40,MD5,),
+  CS_ENTRY(0x0003, EXP,RC4,MD5,,,,,),
+  CS_ENTRY(0x0004, TLS,RSA,WITH,RC4,128,MD5,,),
+  CS_ENTRY(0x0004, RC4,MD5,,,,,,),
+  CS_ENTRY(0x0005, TLS,RSA,WITH,RC4,128,SHA,,),
+  CS_ENTRY(0x0005, RC4,SHA,,,,,,),
+  CS_ENTRY(0x0006, TLS,RSA,EXPORT,WITH,RC2,CBC,40,MD5),
+  CS_ENTRY(0x0006, EXP,RC2,CBC,MD5,,,,),
+  CS_ENTRY(0x0007, TLS,RSA,WITH,IDEA,CBC,SHA,,),
+  CS_ENTRY(0x0007, IDEA,CBC,SHA,,,,,),
+  CS_ENTRY(0x0008, TLS,RSA,EXPORT,WITH,DES40,CBC,SHA,),
+  CS_ENTRY(0x0008, EXP,DES,CBC,SHA,,,,),
+  CS_ENTRY(0x0009, TLS,RSA,WITH,DES,CBC,SHA,,),
+  CS_ENTRY(0x0009, DES,CBC,SHA,,,,,),
+  CS_ENTRY(0x000B, TLS,DH,DSS,EXPORT,WITH,DES40,CBC,SHA),
+  CS_ENTRY(0x000B, EXP,DH,DSS,DES,CBC,SHA,,),
+  CS_ENTRY(0x000C, TLS,DH,DSS,WITH,DES,CBC,SHA,),
+  CS_ENTRY(0x000C, DH,DSS,DES,CBC,SHA,,,),
+  CS_ENTRY(0x000D, TLS,DH,DSS,WITH,3DES,EDE,CBC,SHA),
+  CS_ENTRY(0x000D, DH,DSS,DES,CBC3,SHA,,,),
+  CS_ENTRY(0x000E, TLS,DH,RSA,EXPORT,WITH,DES40,CBC,SHA),
+  CS_ENTRY(0x000E, EXP,DH,RSA,DES,CBC,SHA,,),
+  CS_ENTRY(0x000F, TLS,DH,RSA,WITH,DES,CBC,SHA,),
+  CS_ENTRY(0x000F, DH,RSA,DES,CBC,SHA,,,),
+  CS_ENTRY(0x0010, TLS,DH,RSA,WITH,3DES,EDE,CBC,SHA),
+  CS_ENTRY(0x0010, DH,RSA,DES,CBC3,SHA,,,),
+  CS_ENTRY(0x0011, TLS,DHE,DSS,EXPORT,WITH,DES40,CBC,SHA),
+  CS_ENTRY(0x0011, EXP,DHE,DSS,DES,CBC,SHA,,),
+  CS_ENTRY(0x0011, EXP,EDH,DSS,DES,CBC,SHA,,), /* bc */
+  CS_ENTRY(0x0012, TLS,DHE,DSS,WITH,DES,CBC,SHA,),
+  CS_ENTRY(0x0012, DHE,DSS,DES,CBC,SHA,,,),
+  CS_ENTRY(0x0012, EDH,DSS,DES,CBC,SHA,,,), /* bc */
+  CS_ENTRY(0x0013, TLS,DHE,DSS,WITH,3DES,EDE,CBC,SHA),
+  CS_ENTRY(0x0013, DHE,DSS,DES,CBC3,SHA,,,),
+  CS_ENTRY(0x0013, EDH,DSS,DES,CBC3,SHA,,,), /* bc */
+  CS_ENTRY(0x0014, TLS,DHE,RSA,EXPORT,WITH,DES40,CBC,SHA),
+  CS_ENTRY(0x0014, EXP,DHE,RSA,DES,CBC,SHA,,),
+  CS_ENTRY(0x0014, EXP,EDH,RSA,DES,CBC,SHA,,), /* bc */
+  CS_ENTRY(0x0015, TLS,DHE,RSA,WITH,DES,CBC,SHA,),
+  CS_ENTRY(0x0015, DHE,RSA,DES,CBC,SHA,,,),
+  CS_ENTRY(0x0015, EDH,RSA,DES,CBC,SHA,,,), /* bc */
+  CS_ENTRY(0x0016, TLS,DHE,RSA,WITH,3DES,EDE,CBC,SHA),
+  CS_ENTRY(0x0016, DHE,RSA,DES,CBC3,SHA,,,),
+  CS_ENTRY(0x0016, EDH,RSA,DES,CBC3,SHA,,,), /* bc */
+  CS_ENTRY(0x0017, TLS,DH,anon,EXPORT,WITH,RC4,40,MD5),
+  CS_ENTRY(0x0017, EXP,ADH,RC4,MD5,,,,),
+  CS_ENTRY(0x0018, TLS,DH,anon,WITH,RC4,128,MD5,),
+  CS_ENTRY(0x0018, ADH,RC4,MD5,,,,,),
+  CS_ENTRY(0x0019, TLS,DH,anon,EXPORT,WITH,DES40,CBC,SHA),
+  CS_ENTRY(0x0019, EXP,ADH,DES,CBC,SHA,,,),
+  CS_ENTRY(0x001A, TLS,DH,anon,WITH,DES,CBC,SHA,),
+  CS_ENTRY(0x001A, ADH,DES,CBC,SHA,,,,),
+  CS_ENTRY(0x001B, TLS,DH,anon,WITH,3DES,EDE,CBC,SHA),
+  CS_ENTRY(0x001B, ADH,DES,CBC3,SHA,,,,),
+  CS_ENTRY(0x0030, TLS,DH,DSS,WITH,AES,128,CBC,SHA),
+  CS_ENTRY(0x0030, DH,DSS,AES128,SHA,,,,),
+  CS_ENTRY(0x0031, TLS,DH,RSA,WITH,AES,128,CBC,SHA),
+  CS_ENTRY(0x0031, DH,RSA,AES128,SHA,,,,),
+  CS_ENTRY(0x0032, TLS,DHE,DSS,WITH,AES,128,CBC,SHA),
+  CS_ENTRY(0x0032, DHE,DSS,AES128,SHA,,,,),
+  CS_ENTRY(0x0034, TLS,DH,anon,WITH,AES,128,CBC,SHA),
+  CS_ENTRY(0x0034, ADH,AES128,SHA,,,,,),
+  CS_ENTRY(0x0036, TLS,DH,DSS,WITH,AES,256,CBC,SHA),
+  CS_ENTRY(0x0036, DH,DSS,AES256,SHA,,,,),
+  CS_ENTRY(0x0037, TLS,DH,RSA,WITH,AES,256,CBC,SHA),
+  CS_ENTRY(0x0037, DH,RSA,AES256,SHA,,,,),
+  CS_ENTRY(0x0038, TLS,DHE,DSS,WITH,AES,256,CBC,SHA),
+  CS_ENTRY(0x0038, DHE,DSS,AES256,SHA,,,,),
+  CS_ENTRY(0x003A, TLS,DH,anon,WITH,AES,256,CBC,SHA),
+  CS_ENTRY(0x003A, ADH,AES256,SHA,,,,,),
+  CS_ENTRY(0x003E, TLS,DH,DSS,WITH,AES,128,CBC,SHA256),
+  CS_ENTRY(0x003E, DH,DSS,AES128,SHA256,,,,),
+  CS_ENTRY(0x003F, TLS,DH,RSA,WITH,AES,128,CBC,SHA256),
+  CS_ENTRY(0x003F, DH,RSA,AES128,SHA256,,,,),
+  CS_ENTRY(0x0040, TLS,DHE,DSS,WITH,AES,128,CBC,SHA256),
+  CS_ENTRY(0x0040, DHE,DSS,AES128,SHA256,,,,),
+  CS_ENTRY(0x0068, TLS,DH,DSS,WITH,AES,256,CBC,SHA256),
+  CS_ENTRY(0x0068, DH,DSS,AES256,SHA256,,,,),
+  CS_ENTRY(0x0069, TLS,DH,RSA,WITH,AES,256,CBC,SHA256),
+  CS_ENTRY(0x0069, DH,RSA,AES256,SHA256,,,,),
+  CS_ENTRY(0x006A, TLS,DHE,DSS,WITH,AES,256,CBC,SHA256),
+  CS_ENTRY(0x006A, DHE,DSS,AES256,SHA256,,,,),
+  CS_ENTRY(0x006C, TLS,DH,anon,WITH,AES,128,CBC,SHA256),
+  CS_ENTRY(0x006C, ADH,AES128,SHA256,,,,,),
+  CS_ENTRY(0x006D, TLS,DH,anon,WITH,AES,256,CBC,SHA256),
+  CS_ENTRY(0x006D, ADH,AES256,SHA256,,,,,),
+  CS_ENTRY(0x008A, TLS,PSK,WITH,RC4,128,SHA,,),
+  CS_ENTRY(0x008A, PSK,RC4,SHA,,,,,),
+  CS_ENTRY(0x008B, TLS,PSK,WITH,3DES,EDE,CBC,SHA,),
+  CS_ENTRY(0x008B, PSK,3DES,EDE,CBC,SHA,,,),
+  CS_ENTRY(0x008E, TLS,DHE,PSK,WITH,RC4,128,SHA,),
+  CS_ENTRY(0x008E, DHE,PSK,RC4,SHA,,,,),
+  CS_ENTRY(0x008F, TLS,DHE,PSK,WITH,3DES,EDE,CBC,SHA),
+  CS_ENTRY(0x008F, DHE,PSK,3DES,EDE,CBC,SHA,,),
+  CS_ENTRY(0x0092, TLS,RSA,PSK,WITH,RC4,128,SHA,),
+  CS_ENTRY(0x0092, RSA,PSK,RC4,SHA,,,,),
+  CS_ENTRY(0x0093, TLS,RSA,PSK,WITH,3DES,EDE,CBC,SHA),
+  CS_ENTRY(0x0093, RSA,PSK,3DES,EDE,CBC,SHA,,),
+  CS_ENTRY(0x00A0, TLS,DH,RSA,WITH,AES,128,GCM,SHA256),
+  CS_ENTRY(0x00A0, DH,RSA,AES128,GCM,SHA256,,,),
+  CS_ENTRY(0x00A1, TLS,DH,RSA,WITH,AES,256,GCM,SHA384),
+  CS_ENTRY(0x00A1, DH,RSA,AES256,GCM,SHA384,,,),
+  CS_ENTRY(0x00A2, TLS,DHE,DSS,WITH,AES,128,GCM,SHA256),
+  CS_ENTRY(0x00A2, DHE,DSS,AES128,GCM,SHA256,,,),
+  CS_ENTRY(0x00A3, TLS,DHE,DSS,WITH,AES,256,GCM,SHA384),
+  CS_ENTRY(0x00A3, DHE,DSS,AES256,GCM,SHA384,,,),
+  CS_ENTRY(0x00A4, TLS,DH,DSS,WITH,AES,128,GCM,SHA256),
+  CS_ENTRY(0x00A4, DH,DSS,AES128,GCM,SHA256,,,),
+  CS_ENTRY(0x00A5, TLS,DH,DSS,WITH,AES,256,GCM,SHA384),
+  CS_ENTRY(0x00A5, DH,DSS,AES256,GCM,SHA384,,,),
+  CS_ENTRY(0x00A6, TLS,DH,anon,WITH,AES,128,GCM,SHA256),
+  CS_ENTRY(0x00A6, ADH,AES128,GCM,SHA256,,,,),
+  CS_ENTRY(0x00A7, TLS,DH,anon,WITH,AES,256,GCM,SHA384),
+  CS_ENTRY(0x00A7, ADH,AES256,GCM,SHA384,,,,),
+  CS_ENTRY(0xC002, TLS,ECDH,ECDSA,WITH,RC4,128,SHA,),
+  CS_ENTRY(0xC002, ECDH,ECDSA,RC4,SHA,,,,),
+  CS_ENTRY(0xC007, TLS,ECDHE,ECDSA,WITH,RC4,128,SHA,),
+  CS_ENTRY(0xC007, ECDHE,ECDSA,RC4,SHA,,,,),
+  CS_ENTRY(0xC00C, TLS,ECDH,RSA,WITH,RC4,128,SHA,),
+  CS_ENTRY(0xC00C, ECDH,RSA,RC4,SHA,,,,),
+  CS_ENTRY(0xC011, TLS,ECDHE,RSA,WITH,RC4,128,SHA,),
+  CS_ENTRY(0xC011, ECDHE,RSA,RC4,SHA,,,,),
+  CS_ENTRY(0xC015, TLS,ECDH,anon,WITH,NULL,SHA,,),
+  CS_ENTRY(0xC015, AECDH,NULL,SHA,,,,,),
+  CS_ENTRY(0xC016, TLS,ECDH,anon,WITH,RC4,128,SHA,),
+  CS_ENTRY(0xC016, AECDH,RC4,SHA,,,,,),
+  CS_ENTRY(0xC017, TLS,ECDH,anon,WITH,3DES,EDE,CBC,SHA),
+  CS_ENTRY(0xC017, AECDH,DES,CBC3,SHA,,,,),
+  CS_ENTRY(0xC018, TLS,ECDH,anon,WITH,AES,128,CBC,SHA),
+  CS_ENTRY(0xC018, AECDH,AES128,SHA,,,,,),
+  CS_ENTRY(0xC019, TLS,ECDH,anon,WITH,AES,256,CBC,SHA),
+  CS_ENTRY(0xC019, AECDH,AES256,SHA,,,,,),
+#endif
 #if defined(USE_MBEDTLS)
-  /* entries marked ns are "non-standard", they are not in openssl */
+  /* entries marked ns are "non-standard", they are not in OpenSSL */
   CS_ENTRY(0x0041, TLS,RSA,WITH,CAMELLIA,128,CBC,SHA,),
   CS_ENTRY(0x0041, CAMELLIA128,SHA,,,,,,),
   CS_ENTRY(0x0045, TLS,DHE,RSA,WITH,CAMELLIA,128,CBC,SHA),
@@ -713,4 +880,5 @@ int Curl_cipher_suite_get_str(uint16_t id, char *buf, size_t buf_size,
   return r;
 }
 
-#endif /* defined(USE_MBEDTLS) || defined(USE_BEARSSL) */
+#endif /* defined(USE_SECTRANSP) || defined(USE_MBEDTLS) || \
+          defined(USE_BEARSSL) */
diff --git a/lib/vtls/cipher_suite.h b/lib/vtls/cipher_suite.h
index c1399794f..1dd4d7b40 100644
--- a/lib/vtls/cipher_suite.h
+++ b/lib/vtls/cipher_suite.h
@@ -26,7 +26,7 @@
 
 #include "curl_setup.h"
 
-#if defined(USE_MBEDTLS) || defined(USE_BEARSSL)
+#if defined(USE_SECTRANSP) || defined(USE_MBEDTLS) || defined(USE_BEARSSL)
 #include <stdint.h>
 
 /* Lookup IANA id for cipher suite string, returns 0 if not recognized */
@@ -42,5 +42,6 @@ uint16_t Curl_cipher_suite_walk_str(const char **str, const char **end);
 int Curl_cipher_suite_get_str(uint16_t id, char *buf, size_t buf_size,
                               bool prefer_rfc);
 
-#endif /* defined(USE_MBEDTLS) || defined(USE_BEARSSL) */
+#endif /* defined(USE_SECTRANSP) || defined(USE_MBEDTLS) || \
+          defined(USE_BEARSSL) */
 #endif /* HEADER_CURL_CIPHER_SUITE_H */
diff --git a/lib/vtls/gtls.c b/lib/vtls/gtls.c
index 5cf3bf952..39c22c200 100644
--- a/lib/vtls/gtls.c
+++ b/lib/vtls/gtls.c
@@ -26,7 +26,7 @@
  * Source file for all GnuTLS-specific code for the TLS/SSL layer. No code
  * but vtls.c should ever call or use these functions.
  *
- * Note: don't use the GnuTLS' *_t variable type names in this source code,
+ * Note: do not use the GnuTLS' *_t variable type names in this source code,
  * since they were not present in 1.0.X.
  */
 
@@ -125,7 +125,7 @@ static ssize_t gtls_pull(void *s, void *buf, size_t blen)
   CURLcode result;
 
   DEBUGASSERT(data);
-  if(!backend->gtls.trust_setup) {
+  if(!backend->gtls.shared_creds->trust_setup) {
     result = Curl_gtls_client_trust_setup(cf, data, &backend->gtls);
     if(result) {
       gnutls_transport_set_errno(backend->gtls.session, EINVAL);
@@ -251,6 +251,7 @@ static CURLcode handshake(struct Curl_cfilter *cf,
 
   DEBUGASSERT(backend);
   session = backend->gtls.session;
+  connssl->connecting_state = ssl_connect_2;
 
   for(;;) {
     timediff_t timeout_ms;
@@ -265,14 +266,13 @@ static CURLcode handshake(struct Curl_cfilter *cf,
       return CURLE_OPERATION_TIMEDOUT;
     }
 
-    /* if ssl is expecting something, check if it's available. */
-    if(connssl->connecting_state == ssl_connect_2_reading
-       || connssl->connecting_state == ssl_connect_2_writing) {
+    /* if ssl is expecting something, check if it is available. */
+    if(connssl->io_need) {
       int what;
-      curl_socket_t writefd = ssl_connect_2_writing ==
-        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;
-      curl_socket_t readfd = ssl_connect_2_reading ==
-        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;
+      curl_socket_t writefd = (connssl->io_need & CURL_SSL_IO_NEED_SEND)?
+                              sockfd:CURL_SOCKET_BAD;
+      curl_socket_t readfd = (connssl->io_need & CURL_SSL_IO_NEED_RECV)?
+                             sockfd:CURL_SOCKET_BAD;
 
       what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,
                                nonblocking?0:
@@ -294,10 +294,11 @@ static CURLcode handshake(struct Curl_cfilter *cf,
       /* socket is readable or writable */
     }
 
+    connssl->io_need = CURL_SSL_IO_NEED_NONE;
     backend->gtls.io_result = CURLE_OK;
     rc = gnutls_handshake(session);
 
-    if(!backend->gtls.trust_setup) {
+    if(!backend->gtls.shared_creds->trust_setup) {
       /* After having send off the ClientHello, we prepare the trust
        * store to verify the coming certificate from the server */
       CURLcode result = Curl_gtls_client_trust_setup(cf, data, &backend->gtls);
@@ -306,16 +307,16 @@ static CURLcode handshake(struct Curl_cfilter *cf,
     }
 
     if((rc == GNUTLS_E_AGAIN) || (rc == GNUTLS_E_INTERRUPTED)) {
-      connssl->connecting_state =
+      connssl->io_need =
         gnutls_record_get_direction(session)?
-        ssl_connect_2_writing:ssl_connect_2_reading;
+        CURL_SSL_IO_NEED_SEND:CURL_SSL_IO_NEED_RECV;
       continue;
     }
     else if((rc < 0) && !gnutls_error_is_fatal(rc)) {
       const char *strerr = NULL;
 
       if(rc == GNUTLS_E_WARNING_ALERT_RECEIVED) {
-        int alert = gnutls_alert_get(session);
+        gnutls_alert_description_t alert = gnutls_alert_get(session);
         strerr = gnutls_alert_get_name(alert);
       }
 
@@ -332,7 +333,7 @@ static CURLcode handshake(struct Curl_cfilter *cf,
       const char *strerr = NULL;
 
       if(rc == GNUTLS_E_FATAL_ALERT_RECEIVED) {
-        int alert = gnutls_alert_get(session);
+        gnutls_alert_description_t alert = gnutls_alert_get(session);
         strerr = gnutls_alert_get_name(alert);
       }
 
@@ -376,9 +377,15 @@ set_ssl_version_min_max(struct Curl_easy *data,
   long ssl_version = conn_config->version;
   long ssl_version_max = conn_config->version_max;
 
+  if((ssl_version == CURL_SSLVERSION_DEFAULT) ||
+     (ssl_version == CURL_SSLVERSION_TLSv1))
+    ssl_version = CURL_SSLVERSION_TLSv1_0;
+  if(ssl_version_max == CURL_SSLVERSION_MAX_NONE)
+    ssl_version_max = CURL_SSLVERSION_MAX_DEFAULT;
+
   if(peer->transport == TRNSPRT_QUIC) {
-    if((ssl_version != CURL_SSLVERSION_DEFAULT) &&
-       (ssl_version < CURL_SSLVERSION_TLSv1_3)) {
+    if((ssl_version_max != CURL_SSLVERSION_MAX_DEFAULT) &&
+       (ssl_version_max < CURL_SSLVERSION_MAX_TLSv1_3)) {
       failf(data, "QUIC needs at least TLS version 1.3");
       return CURLE_SSL_CONNECT_ERROR;
      }
@@ -386,13 +393,8 @@ set_ssl_version_min_max(struct Curl_easy *data,
     return CURLE_OK;
   }
 
-  if((ssl_version == CURL_SSLVERSION_DEFAULT) ||
-     (ssl_version == CURL_SSLVERSION_TLSv1))
-    ssl_version = CURL_SSLVERSION_TLSv1_0;
-  if(ssl_version_max == CURL_SSLVERSION_MAX_NONE)
-    ssl_version_max = CURL_SSLVERSION_MAX_DEFAULT;
   if(!tls13support) {
-    /* If the running GnuTLS doesn't support TLS 1.3, we must not specify a
+    /* If the running GnuTLS does not support TLS 1.3, we must not specify a
        prioritylist involving that since it will make GnuTLS return an en
        error back at us */
     if((ssl_version_max == CURL_SSLVERSION_MAX_TLSv1_3) ||
@@ -450,20 +452,67 @@ set_ssl_version_min_max(struct Curl_easy *data,
   return CURLE_SSL_CONNECT_ERROR;
 }
 
-CURLcode Curl_gtls_client_trust_setup(struct Curl_cfilter *cf,
-                                      struct Curl_easy *data,
-                                      struct gtls_ctx *gtls)
+CURLcode Curl_gtls_shared_creds_create(struct Curl_easy *data,
+                                       struct gtls_shared_creds **pcreds)
+{
+  struct gtls_shared_creds *shared;
+  int rc;
+
+  *pcreds = NULL;
+  shared = calloc(1, sizeof(*shared));
+  if(!shared)
+    return CURLE_OUT_OF_MEMORY;
+
+  rc = gnutls_certificate_allocate_credentials(&shared->creds);
+  if(rc != GNUTLS_E_SUCCESS) {
+    failf(data, "gnutls_cert_all_cred() failed: %s", gnutls_strerror(rc));
+    free(shared);
+    return CURLE_SSL_CONNECT_ERROR;
+  }
+
+  shared->refcount = 1;
+  shared->time = Curl_now();
+  *pcreds = shared;
+  return CURLE_OK;
+}
+
+CURLcode Curl_gtls_shared_creds_up_ref(struct gtls_shared_creds *creds)
+{
+  DEBUGASSERT(creds);
+  if(creds->refcount < SIZE_T_MAX) {
+    ++creds->refcount;
+    return CURLE_OK;
+  }
+  return CURLE_BAD_FUNCTION_ARGUMENT;
+}
+
+void Curl_gtls_shared_creds_free(struct gtls_shared_creds **pcreds)
+{
+  struct gtls_shared_creds *shared = *pcreds;
+  *pcreds = NULL;
+  if(shared) {
+    --shared->refcount;
+    if(!shared->refcount) {
+      gnutls_certificate_free_credentials(shared->creds);
+      free(shared->CAfile);
+      free(shared);
+    }
+  }
+}
+
+static CURLcode gtls_populate_creds(struct Curl_cfilter *cf,
+                                    struct Curl_easy *data,
+                                    gnutls_certificate_credentials_t creds)
 {
   struct ssl_primary_config *config = Curl_ssl_cf_get_primary_config(cf);
   struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);
   int rc;
 
-  CURL_TRC_CF(data, cf, "setup trust anchors and CRLs");
   if(config->verifypeer) {
     bool imported_native_ca = false;
 
     if(ssl_config->native_ca_store) {
-      rc = gnutls_certificate_set_x509_system_trust(gtls->cred);
+      rc = gnutls_certificate_set_x509_system_trust(creds);
       if(rc < 0)
         infof(data, "error reading native ca store (%s), continuing anyway",
               gnutls_strerror(rc));
@@ -476,10 +525,10 @@ CURLcode Curl_gtls_client_trust_setup(struct Curl_cfilter *cf,
 
     if(config->CAfile) {
       /* set the trusted CA cert bundle file */
-      gnutls_certificate_set_verify_flags(gtls->cred,
+      gnutls_certificate_set_verify_flags(creds,
                                           GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT);
 
-      rc = gnutls_certificate_set_x509_trust_file(gtls->cred,
+      rc = gnutls_certificate_set_x509_trust_file(creds,
                                                   config->CAfile,
                                                   GNUTLS_X509_FMT_PEM);
       if(rc < 0) {
@@ -497,8 +546,7 @@ CURLcode Curl_gtls_client_trust_setup(struct Curl_cfilter *cf,
 
     if(config->CApath) {
       /* set the trusted CA cert directory */
-      rc = gnutls_certificate_set_x509_trust_dir(gtls->cred,
-                                                 config->CApath,
+      rc = gnutls_certificate_set_x509_trust_dir(creds, config->CApath,
                                                  GNUTLS_X509_FMT_PEM);
       if(rc < 0) {
         infof(data, "error reading ca cert file %s (%s)%s",
@@ -516,8 +564,7 @@ CURLcode Curl_gtls_client_trust_setup(struct Curl_cfilter *cf,
 
   if(config->CRLfile) {
     /* set the CRL list file */
-    rc = gnutls_certificate_set_x509_crl_file(gtls->cred,
-                                              config->CRLfile,
+    rc = gnutls_certificate_set_x509_crl_file(creds, config->CRLfile,
                                               GNUTLS_X509_FMT_PEM);
     if(rc < 0) {
       failf(data, "error reading crl file %s (%s)",
@@ -528,7 +575,141 @@ CURLcode Curl_gtls_client_trust_setup(struct Curl_cfilter *cf,
       infof(data, "found %d CRL in %s", rc, config->CRLfile);
   }
 
-  gtls->trust_setup = TRUE;
+  return CURLE_OK;
+}
+
+/* key to use at `multi->proto_hash` */
+#define MPROTO_GTLS_X509_KEY   "tls:gtls:x509:share"
+
+static bool gtls_shared_creds_expired(const struct Curl_easy *data,
+                                      const struct gtls_shared_creds *sc)
+{
+  const struct ssl_general_config *cfg = &data->set.general_ssl;
+  struct curltime now = Curl_now();
+  timediff_t elapsed_ms = Curl_timediff(now, sc->time);
+  timediff_t timeout_ms = cfg->ca_cache_timeout * (timediff_t)1000;
+
+  if(timeout_ms < 0)
+    return false;
+
+  return elapsed_ms >= timeout_ms;
+}
+
+static bool gtls_shared_creds_different(struct Curl_cfilter *cf,
+                                        const struct gtls_shared_creds *sc)
+{
+  struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
+  if(!sc->CAfile || !conn_config->CAfile)
+    return sc->CAfile != conn_config->CAfile;
+
+  return strcmp(sc->CAfile, conn_config->CAfile);
+}
+
+static struct gtls_shared_creds*
+gtls_get_cached_creds(struct Curl_cfilter *cf, struct Curl_easy *data)
+{
+  struct gtls_shared_creds *shared_creds;
+
+  if(data->multi) {
+    shared_creds = Curl_hash_pick(&data->multi->proto_hash,
+                                  (void *)MPROTO_GTLS_X509_KEY,
+                                  sizeof(MPROTO_GTLS_X509_KEY)-1);
+     if(shared_creds && shared_creds->creds &&
+        !gtls_shared_creds_expired(data, shared_creds) &&
+        !gtls_shared_creds_different(cf, shared_creds)) {
+       return shared_creds;
+     }
+  }
+  return NULL;
+}
+
+static void gtls_shared_creds_hash_free(void *key, size_t key_len, void *p)
+{
+  struct gtls_shared_creds *sc = p;
+  DEBUGASSERT(key_len == (sizeof(MPROTO_GTLS_X509_KEY)-1));
+  DEBUGASSERT(!memcmp(MPROTO_GTLS_X509_KEY, key, key_len));
+  (void)key;
+  (void)key_len;
+  Curl_gtls_shared_creds_free(&sc); /* down reference */
+}
+
+static void gtls_set_cached_creds(struct Curl_cfilter *cf,
+                                  struct Curl_easy *data,
+                                  struct gtls_shared_creds *sc)
+{
+  struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
+
+  DEBUGASSERT(sc);
+  DEBUGASSERT(sc->creds);
+  DEBUGASSERT(!sc->CAfile);
+  DEBUGASSERT(sc->refcount == 1);
+  if(!data->multi)
+    return;
+
+  if(conn_config->CAfile) {
+    sc->CAfile = strdup(conn_config->CAfile);
+    if(!sc->CAfile)
+      return;
+  }
+
+  if(Curl_gtls_shared_creds_up_ref(sc))
+    return;
+
+  if(!Curl_hash_add2(&data->multi->proto_hash,
+                    (void *)MPROTO_GTLS_X509_KEY,
+                    sizeof(MPROTO_GTLS_X509_KEY)-1,
+                    sc, gtls_shared_creds_hash_free)) {
+    Curl_gtls_shared_creds_free(&sc); /* down reference again */
+    return;
+  }
+}
+
+CURLcode Curl_gtls_client_trust_setup(struct Curl_cfilter *cf,
+                                      struct Curl_easy *data,
+                                      struct gtls_ctx *gtls)
+{
+  struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
+  struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);
+  struct gtls_shared_creds *cached_creds = NULL;
+  bool cache_criteria_met;
+  CURLcode result;
+  int rc;
+
+
+  /* Consider the X509 store cacheable if it comes exclusively from a CAfile,
+     or no source is provided and we are falling back to OpenSSL's built-in
+     default. */
+  cache_criteria_met = (data->set.general_ssl.ca_cache_timeout != 0) &&
+    conn_config->verifypeer &&
+    !conn_config->CApath &&
+    !conn_config->ca_info_blob &&
+    !ssl_config->primary.CRLfile &&
+    !ssl_config->native_ca_store &&
+    !conn_config->clientcert; /* GnuTLS adds client cert to its credentials! */
+
+  if(cache_criteria_met)
+    cached_creds = gtls_get_cached_creds(cf, data);
+
+  if(cached_creds && !Curl_gtls_shared_creds_up_ref(cached_creds)) {
+    CURL_TRC_CF(data, cf, "using shared trust anchors and CRLs");
+    Curl_gtls_shared_creds_free(&gtls->shared_creds);
+    gtls->shared_creds = cached_creds;
+    rc = gnutls_credentials_set(gtls->session, GNUTLS_CRD_CERTIFICATE,
+                                gtls->shared_creds->creds);
+    if(rc != GNUTLS_E_SUCCESS) {
+      failf(data, "gnutls_credentials_set() failed: %s", gnutls_strerror(rc));
+      return CURLE_SSL_CONNECT_ERROR;
+    }
+  }
+  else {
+    CURL_TRC_CF(data, cf, "loading trust anchors and CRLs");
+    result = gtls_populate_creds(cf, data, gtls->shared_creds->creds);
+    if(result)
+      return result;
+    gtls->shared_creds->trust_setup = TRUE;
+    if(cache_criteria_met)
+      gtls_set_cached_creds(cf, data, gtls->shared_creds);
+  }
   return CURLE_OK;
 }
 
@@ -546,7 +727,7 @@ static CURLcode gtls_update_session_id(struct Curl_cfilter *cf,
   struct ssl_connect_data *connssl = cf->ctx;
   CURLcode result = CURLE_OK;
 
-  if(ssl_config->primary.sessionid) {
+  if(ssl_config->primary.cache_session) {
     /* we always unconditionally get the session id here, as even if we
        already got it from the cache and asked to use it in the connection, it
        might've been rejected and then a new one is in use now and we need to
@@ -561,27 +742,16 @@ static CURLcode gtls_update_session_id(struct Curl_cfilter *cf,
       return CURLE_OUT_OF_MEMORY;
     }
     else {
-      bool incache;
-      void *ssl_sessionid;
-
       /* extract session ID to the allocated buffer */
       gnutls_session_get_data(session, connect_sessionid, &connect_idsize);
 
-      DEBUGF(infof(data, "get session id (len=%zu) and store in cache",
-                   connect_idsize));
+      CURL_TRC_CF(data, cf, "get session id (len=%zu) and store in cache",
+                  connect_idsize);
       Curl_ssl_sessionid_lock(data);
-      incache = !(Curl_ssl_getsessionid(cf, data, &connssl->peer,
-                                        &ssl_sessionid, NULL));
-      if(incache) {
-        /* there was one before in the cache, so instead of risking that the
-           previous one was rejected, we just kill that and store the new */
-        Curl_ssl_delsessionid(data, ssl_sessionid);
-      }
-
       /* store this session id, takes ownership */
-      result = Curl_ssl_addsessionid(cf, data, &connssl->peer,
-                                     connect_sessionid, connect_idsize,
-                                     gtls_sessionid_free);
+      result = Curl_ssl_set_sessionid(cf, data, &connssl->peer,
+                                      connect_sessionid, connect_idsize,
+                                      gtls_sessionid_free);
       Curl_ssl_sessionid_unlock(data);
     }
   }
@@ -599,8 +769,8 @@ static int gtls_handshake_cb(gnutls_session_t session, unsigned int htype,
   if(when) { /* after message has been processed */
     struct Curl_easy *data = CF_DATA_CURRENT(cf);
     if(data) {
-      DEBUGF(infof(data, "handshake: %s message type %d",
-             incoming? "incoming" : "outgoing", htype));
+      CURL_TRC_CF(data, cf, "handshake: %s message type %d",
+                  incoming? "incoming" : "outgoing", htype);
       switch(htype) {
       case GNUTLS_HANDSHAKE_NEW_SESSION_TICKET: {
         gtls_update_session_id(cf, data, session);
@@ -639,12 +809,10 @@ static CURLcode gtls_client_init(struct Curl_cfilter *cf,
   else if(config->version == CURL_SSLVERSION_SSLv3)
     sni = FALSE; /* SSLv3 has no SNI */
 
-  /* allocate a cred struct */
-  rc = gnutls_certificate_allocate_credentials(&gtls->cred);
-  if(rc != GNUTLS_E_SUCCESS) {
-    failf(data, "gnutls_cert_all_cred() failed: %s", gnutls_strerror(rc));
-    return CURLE_SSL_CONNECT_ERROR;
-  }
+  /* allocate a shared creds struct */
+  result = Curl_gtls_shared_creds_create(data, &gtls->shared_creds);
+  if(result)
+    return result;
 
 #ifdef USE_GNUTLS_SRP
   if(config->username && Curl_auth_allowed_to_host(data)) {
@@ -705,7 +873,7 @@ static CURLcode gtls_client_init(struct Curl_cfilter *cf,
   tls13support = gnutls_check_version("3.6.5");
 
   /* Ensure +SRP comes at the *end* of all relevant strings so that it can be
-   * removed if a run-time error indicates that SRP is not supported by this
+   * removed if a runtime error indicates that SRP is not supported by this
    * GnuTLS version */
 
   if(config->version == CURL_SSLVERSION_SSLv2 ||
@@ -756,7 +924,7 @@ static CURLcode gtls_client_init(struct Curl_cfilter *cf,
   }
 
   if(config->clientcert) {
-    if(!gtls->trust_setup) {
+    if(!gtls->shared_creds->trust_setup) {
       result = Curl_gtls_client_trust_setup(cf, data, gtls);
       if(result)
         return result;
@@ -768,7 +936,7 @@ static CURLcode gtls_client_init(struct Curl_cfilter *cf,
         GNUTLS_PKCS_USE_PBES2_AES_128 | GNUTLS_PKCS_USE_PBES2_AES_192 |
         GNUTLS_PKCS_USE_PBES2_AES_256;
       rc = gnutls_certificate_set_x509_key_file2(
-           gtls->cred,
+           gtls->shared_creds->creds,
            config->clientcert,
            ssl_config->key ? ssl_config->key : config->clientcert,
            do_file_type(ssl_config->cert_type),
@@ -783,7 +951,7 @@ static CURLcode gtls_client_init(struct Curl_cfilter *cf,
     }
     else {
       if(gnutls_certificate_set_x509_key_file(
-           gtls->cred,
+           gtls->shared_creds->creds,
            config->clientcert,
            ssl_config->key ? ssl_config->key : config->clientcert,
            do_file_type(ssl_config->cert_type) ) !=
@@ -808,7 +976,7 @@ static CURLcode gtls_client_init(struct Curl_cfilter *cf,
 #endif
   {
     rc = gnutls_credentials_set(gtls->session, GNUTLS_CRD_CERTIFICATE,
-                                gtls->cred);
+                                gtls->shared_creds->creds);
     if(rc != GNUTLS_E_SUCCESS) {
       failf(data, "gnutls_credentials_set() failed: %s", gnutls_strerror(rc));
       return CURLE_SSL_CONNECT_ERROR;
@@ -903,7 +1071,7 @@ CURLcode Curl_gtls_ctx_init(struct gtls_ctx *gctx,
 
   /* This might be a reconnect, so we check for a session ID in the cache
      to speed up things */
-  if(conn_config->sessionid) {
+  if(conn_config->cache_session) {
     void *ssl_sessionid;
     size_t ssl_idsize;
 
@@ -979,7 +1147,7 @@ static CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data,
   /* Result is returned to caller */
   CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;
 
-  /* if a path wasn't specified, don't pin */
+  /* if a path was not specified, do not pin */
   if(!pinnedpubkey)
     return CURLE_OK;
 
@@ -1045,7 +1213,7 @@ Curl_gtls_verifyserver(struct Curl_easy *data,
   CURLcode result = CURLE_OK;
 #ifndef CURL_DISABLE_VERBOSE_STRINGS
   const char *ptr;
-  unsigned int algo;
+  int algo;
   unsigned int bits;
   gnutls_protocol_t version = gnutls_protocol_get_version(session);
 #endif
@@ -1087,13 +1255,13 @@ Curl_gtls_verifyserver(struct Curl_easy *data,
       }
 #endif
     }
-    infof(data, " common name: WARNING couldn't obtain");
+    infof(data, " common name: WARNING could not obtain");
   }
 
   if(data->set.ssl.certinfo && chainp) {
     unsigned int i;
 
-    result = Curl_ssl_init_certinfo(data, cert_list_size);
+    result = Curl_ssl_init_certinfo(data, (int)cert_list_size);
     if(result)
       return result;
 
@@ -1101,7 +1269,7 @@ Curl_gtls_verifyserver(struct Curl_easy *data,
       const char *beg = (const char *) chainp[i].data;
       const char *end = beg + chainp[i].size;
 
-      result = Curl_extract_certinfo(data, i, beg, end);
+      result = Curl_extract_certinfo(data, (int)i, beg, end);
       if(result)
         return result;
     }
@@ -1258,7 +1426,7 @@ Curl_gtls_verifyserver(struct Curl_easy *data,
     gnutls_x509_crt_init(&x509_issuer);
     issuerp = load_file(config->issuercert);
     gnutls_x509_crt_import(x509_issuer, &issuerp, GNUTLS_X509_FMT_PEM);
-    rc = gnutls_x509_crt_check_issuer(x509_cert, x509_issuer);
+    rc = (int)gnutls_x509_crt_check_issuer(x509_cert, x509_issuer);
     gnutls_x509_crt_deinit(x509_issuer);
     unload_file(issuerp);
     if(rc <= 0) {
@@ -1287,9 +1455,15 @@ Curl_gtls_verifyserver(struct Curl_easy *data,
      in RFC2818 (HTTPS), which takes into account wildcards, and the subject
      alternative name PKIX extension. Returns non zero on success, and zero on
      failure. */
-  rc = gnutls_x509_crt_check_hostname(x509_cert, peer->hostname);
+
+  /* This function does not handle trailing dots, so if we have an SNI name
+     use that and fallback to the hostname only if there is no SNI (like for
+     IP addresses) */
+  rc = (int)gnutls_x509_crt_check_hostname(x509_cert,
+                                           peer->sni ? peer->sni :
+                                           peer->hostname);
 #if GNUTLS_VERSION_NUMBER < 0x030306
-  /* Before 3.3.6, gnutls_x509_crt_check_hostname() didn't check IP
+  /* Before 3.3.6, gnutls_x509_crt_check_hostname() did not check IP
      addresses. */
   if(!rc) {
 #ifdef USE_IPV6
@@ -1315,7 +1489,7 @@ Curl_gtls_verifyserver(struct Curl_easy *data,
         size_t certaddrlen = sizeof(certaddr);
         int ret = gnutls_x509_crt_get_subject_alt_name(x509_cert, i, certaddr,
                                                        &certaddrlen, NULL);
-        /* If this happens, it wasn't an IP address. */
+        /* If this happens, it was not an IP address. */
         if(ret == GNUTLS_E_SHORT_MEMORY_BUFFER)
           continue;
         if(ret < 0)
@@ -1333,7 +1507,7 @@ Curl_gtls_verifyserver(struct Curl_easy *data,
   if(!rc) {
     if(config->verifyhost) {
       failf(data, "SSL: certificate subject name (%s) does not match "
-            "target host name '%s'", certname, peer->dispname);
+            "target hostname '%s'", certname, peer->dispname);
       gnutls_x509_crt_deinit(x509_cert);
       return CURLE_PEER_FAILED_VERIFICATION;
     }
@@ -1422,7 +1596,7 @@ Curl_gtls_verifyserver(struct Curl_easy *data,
   /* public key algorithm's parameters */
   algo = gnutls_x509_crt_get_pk_algorithm(x509_cert, &bits);
   infof(data, "  certificate public key: %s",
-        gnutls_pk_algorithm_get_name(algo));
+        gnutls_pk_algorithm_get_name((gnutls_pk_algorithm_t)algo));
 
   /* version of the X.509 certificate. */
   infof(data, "  certificate version: #%d",
@@ -1506,8 +1680,8 @@ out:
  */
 /* We use connssl->connecting_state to keep track of the connection status;
    there are three states: 'ssl_connect_1' (not started yet or complete),
-   'ssl_connect_2_reading' (waiting for data from server), and
-   'ssl_connect_2_writing' (waiting to be able to write).
+   'ssl_connect_2' (doing handshake with the server), and
+   'ssl_connect_3' (verifying and getting stats).
  */
 static CURLcode
 gtls_connect_common(struct Curl_cfilter *cf,
@@ -1516,7 +1690,7 @@ gtls_connect_common(struct Curl_cfilter *cf,
                     bool *done)
 {
   struct ssl_connect_data *connssl = cf->ctx;
-  int rc;
+  CURLcode rc;
   CURLcode result = CURLE_OK;
 
   /* Initiate the connection, if not already done */
@@ -1620,118 +1794,104 @@ static ssize_t gtls_send(struct Curl_cfilter *cf,
   return rc;
 }
 
-static void gtls_close(struct Curl_cfilter *cf,
-                       struct Curl_easy *data)
+/*
+ * This function is called to shut down the SSL layer but keep the
+ * socket open (CCC - Clear Command Channel)
+ */
+static CURLcode gtls_shutdown(struct Curl_cfilter *cf,
+                              struct Curl_easy *data,
+                              bool send_shutdown, bool *done)
 {
   struct ssl_connect_data *connssl = cf->ctx;
   struct gtls_ssl_backend_data *backend =
     (struct gtls_ssl_backend_data *)connssl->backend;
+  char buf[1024];
+  CURLcode result = CURLE_OK;
+  ssize_t nread;
+  size_t i;
 
-  (void) data;
   DEBUGASSERT(backend);
+  if(!backend->gtls.session || cf->shutdown) {
+    *done = TRUE;
+    goto out;
+  }
 
-  if(backend->gtls.session) {
-    char buf[32];
-    /* Maybe the server has already sent a close notify alert.
-       Read it to avoid an RST on the TCP connection. */
-    (void)gnutls_record_recv(backend->gtls.session, buf, sizeof(buf));
-    gnutls_bye(backend->gtls.session, GNUTLS_SHUT_WR);
-    gnutls_deinit(backend->gtls.session);
-    backend->gtls.session = NULL;
+  connssl->io_need = CURL_SSL_IO_NEED_NONE;
+  *done = FALSE;
+
+  if(!backend->gtls.sent_shutdown) {
+    /* do this only once */
+    backend->gtls.sent_shutdown = TRUE;
+    if(send_shutdown) {
+      int ret = gnutls_bye(backend->gtls.session, GNUTLS_SHUT_RDWR);
+      if((ret == GNUTLS_E_AGAIN) || (ret == GNUTLS_E_INTERRUPTED)) {
+        CURL_TRC_CF(data, cf, "SSL shutdown, gnutls_bye EAGAIN");
+        connssl->io_need = gnutls_record_get_direction(backend->gtls.session)?
+          CURL_SSL_IO_NEED_SEND : CURL_SSL_IO_NEED_RECV;
+        result = CURLE_OK;
+        goto out;
+      }
+      if(ret != GNUTLS_E_SUCCESS) {
+        CURL_TRC_CF(data, cf, "SSL shutdown, gnutls_bye error: '%s'(%d)",
+                    gnutls_strerror((int)ret), (int)ret);
+        result = CURLE_RECV_ERROR;
+        goto out;
+      }
+    }
   }
-  if(backend->gtls.cred) {
-    gnutls_certificate_free_credentials(backend->gtls.cred);
-    backend->gtls.cred = NULL;
+
+  /* SSL should now have started the shutdown from our side. Since it
+   * was not complete, we are lacking the close notify from the server. */
+  for(i = 0; i < 10; ++i) {
+    nread = gnutls_record_recv(backend->gtls.session, buf, sizeof(buf));
+    if(nread <= 0)
+      break;
   }
-#ifdef USE_GNUTLS_SRP
-  if(backend->gtls.srp_client_cred) {
-    gnutls_srp_free_client_credentials(backend->gtls.srp_client_cred);
-    backend->gtls.srp_client_cred = NULL;
+  if(nread > 0) {
+    /* still data coming in? */
   }
-#endif
+  else if(nread == 0) {
+    /* We got the close notify alert and are done. */
+    *done = TRUE;
+  }
+  else if((nread == GNUTLS_E_AGAIN) || (nread == GNUTLS_E_INTERRUPTED)) {
+    connssl->io_need = gnutls_record_get_direction(backend->gtls.session)?
+      CURL_SSL_IO_NEED_SEND : CURL_SSL_IO_NEED_RECV;
+  }
+  else {
+    CURL_TRC_CF(data, cf, "SSL shutdown, error: '%s'(%d)",
+                gnutls_strerror((int)nread), (int)nread);
+    result = CURLE_RECV_ERROR;
+  }
+
+out:
+  cf->shutdown = (result || *done);
+  return result;
 }
 
-/*
- * This function is called to shut down the SSL layer but keep the
- * socket open (CCC - Clear Command Channel)
- */
-static int gtls_shutdown(struct Curl_cfilter *cf,
-                         struct Curl_easy *data)
+static void gtls_close(struct Curl_cfilter *cf,
+                       struct Curl_easy *data)
 {
   struct ssl_connect_data *connssl = cf->ctx;
   struct gtls_ssl_backend_data *backend =
     (struct gtls_ssl_backend_data *)connssl->backend;
-  int retval = 0;
 
+  (void) data;
   DEBUGASSERT(backend);
-
-#ifndef CURL_DISABLE_FTP
-  /* This has only been tested on the proftpd server, and the mod_tls code
-     sends a close notify alert without waiting for a close notify alert in
-     response. Thus we wait for a close notify alert from the server, but
-     we do not send one. Let's hope other servers do the same... */
-
-  if(data->set.ftp_ccc == CURLFTPSSL_CCC_ACTIVE)
-    gnutls_bye(backend->gtls.session, GNUTLS_SHUT_WR);
-#endif
-
+  CURL_TRC_CF(data, cf, "close");
   if(backend->gtls.session) {
-    ssize_t result;
-    bool done = FALSE;
-    char buf[120];
-
-    while(!done && !connssl->peer_closed) {
-      int what = SOCKET_READABLE(Curl_conn_cf_get_socket(cf, data),
-                                 SSL_SHUTDOWN_TIMEOUT);
-      if(what > 0) {
-        /* Something to read, let's do it and hope that it is the close
-           notify alert from the server */
-        result = gnutls_record_recv(backend->gtls.session,
-                                    buf, sizeof(buf));
-        switch(result) {
-        case 0:
-          /* This is the expected response. There was no data but only
-             the close notify alert */
-          done = TRUE;
-          break;
-        case GNUTLS_E_AGAIN:
-        case GNUTLS_E_INTERRUPTED:
-          infof(data, "GNUTLS_E_AGAIN || GNUTLS_E_INTERRUPTED");
-          break;
-        default:
-          retval = -1;
-          done = TRUE;
-          break;
-        }
-      }
-      else if(0 == what) {
-        /* timeout */
-        failf(data, "SSL shutdown timeout");
-        done = TRUE;
-      }
-      else {
-        /* anything that gets here is fatally bad */
-        failf(data, "select/poll on SSL socket, errno: %d", SOCKERRNO);
-        retval = -1;
-        done = TRUE;
-      }
-    }
     gnutls_deinit(backend->gtls.session);
+    backend->gtls.session = NULL;
+  }
+  if(backend->gtls.shared_creds) {
+    Curl_gtls_shared_creds_free(&backend->gtls.shared_creds);
   }
-  gnutls_certificate_free_credentials(backend->gtls.cred);
-
 #ifdef USE_GNUTLS_SRP
-  {
-    struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);
-    if(ssl_config->primary.username)
-      gnutls_srp_free_client_credentials(backend->gtls.srp_client_cred);
+  if(backend->gtls.srp_client_cred) {
+    gnutls_srp_free_client_credentials(backend->gtls.srp_client_cred);
+    backend->gtls.srp_client_cred = NULL;
   }
 #endif
-
-  backend->gtls.cred = NULL;
-  backend->gtls.session = NULL;
-
-  return retval;
 }
 
 static ssize_t gtls_recv(struct Curl_cfilter *cf,
@@ -1831,7 +1991,8 @@ const struct Curl_ssl Curl_ssl_gnutls = {
   SSLSUPP_CA_PATH  |
   SSLSUPP_CERTINFO |
   SSLSUPP_PINNEDPUBKEY |
-  SSLSUPP_HTTPS_PROXY,
+  SSLSUPP_HTTPS_PROXY |
+  SSLSUPP_CA_CACHE,
 
   sizeof(struct gtls_ssl_backend_data),
 
@@ -1856,7 +2017,6 @@ const struct Curl_ssl Curl_ssl_gnutls = {
   gtls_sha256sum,                /* sha256sum */
   NULL,                          /* associate_connection */
   NULL,                          /* disassociate_connection */
-  NULL,                          /* free_multi_ssl_backend_data */
   gtls_recv,                     /* recv decrypted data */
   gtls_send,                     /* send data to encrypt */
 };
diff --git a/lib/vtls/gtls.h b/lib/vtls/gtls.h
index f8388b37b..b0ca55bfb 100644
--- a/lib/vtls/gtls.h
+++ b/lib/vtls/gtls.h
@@ -30,6 +30,7 @@
 #ifdef USE_GNUTLS
 
 #include <gnutls/gnutls.h>
+#include "timeval.h"
 
 #ifdef HAVE_GNUTLS_SRP
 /* the function exists */
@@ -45,14 +46,27 @@ struct ssl_primary_config;
 struct ssl_config_data;
 struct ssl_peer;
 
+struct gtls_shared_creds {
+  gnutls_certificate_credentials_t creds;
+  char *CAfile; /* CAfile path used to generate X509 store */
+  struct curltime time; /* when the shared creds was created */
+  size_t refcount;
+  BIT(trust_setup); /* x509 anchors + CRLs have been set up */
+};
+
+CURLcode Curl_gtls_shared_creds_create(struct Curl_easy *data,
+                                       struct gtls_shared_creds **pcreds);
+CURLcode Curl_gtls_shared_creds_up_ref(struct gtls_shared_creds *creds);
+void Curl_gtls_shared_creds_free(struct gtls_shared_creds **pcreds);
+
 struct gtls_ctx {
   gnutls_session_t session;
-  gnutls_certificate_credentials_t cred;
+  struct gtls_shared_creds *shared_creds;
 #ifdef USE_GNUTLS_SRP
   gnutls_srp_client_credentials_t srp_client_cred;
 #endif
   CURLcode io_result; /* result of last IO cfilter operation */
-  BIT(trust_setup); /* x509 anchors + CRLs have been set up */
+  BIT(sent_shutdown);
 };
 
 typedef CURLcode Curl_gtls_ctx_setup_cb(struct Curl_cfilter *cf,
diff --git a/lib/vtls/hostcheck.c b/lib/vtls/hostcheck.c
index 2726dca7f..e46439a5e 100644
--- a/lib/vtls/hostcheck.c
+++ b/lib/vtls/hostcheck.c
@@ -62,7 +62,7 @@ static bool pmatch(const char *hostname, size_t hostlen,
  * We use the matching rule described in RFC6125, section 6.4.3.
  * https://datatracker.ietf.org/doc/html/rfc6125#section-6.4.3
  *
- * In addition: ignore trailing dots in the host names and wildcards, so that
+ * In addition: ignore trailing dots in the hostnames and wildcards, so that
  * the names are used normalized. This is what the browsers do.
  *
  * Do not allow wildcard matching on IP numbers. There are apparently
diff --git a/lib/vtls/hostcheck.h b/lib/vtls/hostcheck.h
index 22a1ac2e5..6b4e37964 100644
--- a/lib/vtls/hostcheck.h
+++ b/lib/vtls/hostcheck.h
@@ -26,7 +26,7 @@
 
 #include <curl/curl.h>
 
-/* returns TRUE if there's a match */
+/* returns TRUE if there is a match */
 bool Curl_cert_hostcheck(const char *match_pattern, size_t matchlen,
                          const char *hostname, size_t hostlen);
 
diff --git a/lib/vtls/mbedtls.c b/lib/vtls/mbedtls.c
index ec0b10dd9..2b6042df3 100644
--- a/lib/vtls/mbedtls.c
+++ b/lib/vtls/mbedtls.c
@@ -75,6 +75,7 @@
 #include "mbedtls.h"
 #include "vtls.h"
 #include "vtls_int.h"
+#include "x509asn1.h"
 #include "parsedate.h"
 #include "connect.h" /* for the connect timeout */
 #include "select.h"
@@ -110,6 +111,8 @@ struct mbed_ssl_backend_data {
   const char *protocols[3];
 #endif
   int *ciphersuites;
+  BIT(initialized); /* mbedtls_ssl_context is initialized */
+  BIT(sent_shutdown);
 };
 
 /* apply threading? */
@@ -246,8 +249,8 @@ static const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_fr =
   1024,      /* RSA min key len */
 };
 
-/* See https://tls.mbed.org/discussions/generic/
-   howto-determine-exact-buffer-len-for-mbedtls_pk_write_pubkey_der
+/* See https://web.archive.org/web/20200921194007/tls.mbed.org/discussions/
+   generic/howto-determine-exact-buffer-len-for-mbedtls_pk_write_pubkey_der
 */
 #define RSA_PUB_DER_MAX_BYTES   (38 + 2 * MBEDTLS_MPI_MAX_SIZE)
 #define ECP_PUB_DER_MAX_BYTES   (30 + 2 * MBEDTLS_ECP_MAX_BYTES)
@@ -482,6 +485,20 @@ mbed_set_selected_ciphers(struct Curl_easy *data,
   return CURLE_OK;
 }
 
+#ifdef TLS13_SUPPORT
+static int mbed_no_verify(void *udata, mbedtls_x509_crt *crt,
+                          int depth, uint32_t *flags)
+{
+  (void)udata;
+  (void)crt;
+  (void)depth;
+  /* we clear any faults the mbedtls' own verification found.
+   * See <https://github.com/Mbed-TLS/mbedtls/issues/9210> */
+  *flags = 0;
+  return 0;
+}
+#endif
+
 static CURLcode
 mbed_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
 {
@@ -504,6 +521,7 @@ mbed_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
   char errorbuf[128];
 
   DEBUGASSERT(backend);
+  DEBUGASSERT(!backend->initialized);
 
   if((conn_config->version == CURL_SSLVERSION_SSLv2) ||
      (conn_config->version == CURL_SSLVERSION_SSLv3)) {
@@ -636,7 +654,7 @@ mbed_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
 
     if(ret) {
       mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));
-      failf(data, "Error reading private key %s - mbedTLS: (-0x%04X) %s",
+      failf(data, "Error reading client cert data %s - mbedTLS: (-0x%04X) %s",
             ssl_config->key, -ret, errorbuf);
       return CURLE_SSL_CERTPROBLEM;
     }
@@ -737,8 +755,19 @@ mbed_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
     failf(data, "mbedTLS: ssl_config failed");
     return CURLE_SSL_CONNECT_ERROR;
   }
+#ifdef TLS13_SUPPORT
+  if(!verifypeer) {
+    /* Default verify behaviour changed in mbedtls v3.6.0 with TLS v1.3.
+     * On 1.3 connections, the handshake fails by default without trust
+     * anchors. We override this questionable change by installing our
+     * own verify callback that clears all errors. */
+    mbedtls_ssl_conf_verify(&backend->config, mbed_no_verify, cf);
+  }
+#endif
+
 
   mbedtls_ssl_init(&backend->ssl);
+  backend->initialized = TRUE;
 
   /* new profile with RSA min key len = 1024 ... */
   mbedtls_ssl_conf_cert_profile(&backend->config,
@@ -785,10 +814,11 @@ mbed_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
                       NULL /*  rev_timeout() */);
 
   if(conn_config->cipher_list) {
-    ret = mbed_set_selected_ciphers(data, backend, conn_config->cipher_list);
-    if(ret) {
+    CURLcode result = mbed_set_selected_ciphers(data, backend,
+                                                conn_config->cipher_list);
+    if(result != CURLE_OK) {
       failf(data, "mbedTLS: failed to set cipher suites");
-      return ret;
+      return result;
     }
   }
   else {
@@ -807,8 +837,8 @@ mbed_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
                                    MBEDTLS_SSL_SESSION_TICKETS_DISABLED);
 #endif
 
-  /* Check if there's a cached ID we can/should use here! */
-  if(ssl_config->primary.sessionid) {
+  /* Check if there is a cached ID we can/should use here! */
+  if(ssl_config->primary.cache_session) {
     void *old_session = NULL;
 
     Curl_ssl_sessionid_lock(data);
@@ -854,7 +884,7 @@ mbed_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
     for(i = 0; i < connssl->alpn->count; ++i) {
       backend->protocols[i] = connssl->alpn->entries[i];
     }
-    /* this function doesn't clone the protocols array, which is why we need
+    /* this function does not clone the protocols array, which is why we need
        to keep it around */
     if(mbedtls_ssl_conf_alpn_protocols(&backend->config,
                                        &backend->protocols[0])) {
@@ -880,11 +910,11 @@ mbed_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
 
   /* give application a chance to interfere with mbedTLS set up. */
   if(data->set.ssl.fsslctx) {
-    ret = (*data->set.ssl.fsslctx)(data, &backend->config,
-                                   data->set.ssl.fsslctxp);
-    if(ret) {
+    CURLcode result = (*data->set.ssl.fsslctx)(data, &backend->config,
+                                               data->set.ssl.fsslctxp);
+    if(result != CURLE_OK) {
       failf(data, "error signaled by ssl ctx callback");
-      return ret;
+      return result;
     }
   }
 
@@ -893,6 +923,60 @@ mbed_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
   return CURLE_OK;
 }
 
+static int count_server_cert(const mbedtls_x509_crt *peercert)
+{
+  int count = 1;
+
+  DEBUGASSERT(peercert);
+
+  while(peercert->next) {
+    ++count;
+    peercert = peercert->next;
+  }
+  return count;
+}
+
+static CURLcode collect_server_cert_single(struct Curl_easy *data,
+                                           const mbedtls_x509_crt *server_cert,
+                                           int idx)
+{
+  const char *beg, *end;
+
+  DEBUGASSERT(server_cert);
+
+  beg = (const char *)server_cert->raw.p;
+  end = beg + server_cert->raw.len;
+  return Curl_extract_certinfo(data, idx, beg, end);
+}
+
+static CURLcode collect_server_cert(struct Curl_cfilter *cf,
+                                    struct Curl_easy *data,
+                                    const struct mbedtls_x509_crt *peercert)
+{
+#ifndef CURL_DISABLE_VERBOSE_STRINGS
+  const bool show_verbose_server_cert = data->set.verbose;
+#else
+  const bool show_verbose_server_cert = false;
+#endif
+  struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);
+  CURLcode result = CURLE_PEER_FAILED_VERIFICATION;
+  int i, count;
+
+  if(!show_verbose_server_cert && !ssl_config->certinfo)
+    return CURLE_OK;
+
+  if(!peercert)
+    return result;
+
+  count = count_server_cert(peercert);
+  result = Curl_ssl_init_certinfo(data, count);
+  for(i = 0 ; !result && peercert ; i++) {
+    result = collect_server_cert_single(data, peercert, i);
+    peercert = peercert->next;
+  }
+  return result;
+}
+
 static CURLcode
 mbed_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)
 {
@@ -902,8 +986,6 @@ mbed_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)
     (struct mbed_ssl_backend_data *)connssl->backend;
   struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
   const mbedtls_x509_crt *peercert;
-  char cipher_str[64];
-  uint16_t cipher_id;
 #ifndef CURL_DISABLE_PROXY
   const char * const pinnedpubkey = Curl_ssl_cf_is_proxy(cf)?
     data->set.str[STRING_SSL_PINNEDPUBLICKEY_PROXY]:
@@ -917,26 +999,41 @@ mbed_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)
   ret = mbedtls_ssl_handshake(&backend->ssl);
 
   if(ret == MBEDTLS_ERR_SSL_WANT_READ) {
-    connssl->connecting_state = ssl_connect_2_reading;
+    connssl->io_need = CURL_SSL_IO_NEED_RECV;
     return CURLE_OK;
   }
   else if(ret == MBEDTLS_ERR_SSL_WANT_WRITE) {
-    connssl->connecting_state = ssl_connect_2_writing;
+    connssl->io_need = CURL_SSL_IO_NEED_SEND;
     return CURLE_OK;
   }
+  else if(ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED) {
+    failf(data, "peer certificate could not be verified");
+    return CURLE_PEER_FAILED_VERIFICATION;
+  }
   else if(ret) {
     char errorbuf[128];
+#if MBEDTLS_VERSION_NUMBER >= 0x03020000
+    CURL_TRC_CF(data, cf, "TLS version %04X",
+                mbedtls_ssl_get_version_number(&backend->ssl));
+#endif
     mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));
-    failf(data, "ssl_handshake returned - mbedTLS: (-0x%04X) %s",
+    failf(data, "ssl_handshake returned: (-0x%04X) %s",
           -ret, errorbuf);
     return CURLE_SSL_CONNECT_ERROR;
   }
 
-  cipher_id = (uint16_t)
-              mbedtls_ssl_get_ciphersuite_id_from_ssl(&backend->ssl);
-  mbed_cipher_suite_get_str(cipher_id, cipher_str, sizeof(cipher_str), true);
-  infof(data, "mbedTLS: Handshake complete, cipher is %s", cipher_str);
-
+#if MBEDTLS_VERSION_NUMBER >= 0x03020000
+  {
+    char cipher_str[64];
+    uint16_t cipher_id;
+    cipher_id = (uint16_t)
+                mbedtls_ssl_get_ciphersuite_id_from_ssl(&backend->ssl);
+    mbed_cipher_suite_get_str(cipher_id, cipher_str, sizeof(cipher_str), true);
+    infof(data, "mbedTLS: Handshake complete, cipher is %s", cipher_str);
+  }
+#else
+  infof(data, "mbedTLS: Handshake complete");
+#endif
   ret = mbedtls_ssl_get_verify_result(&backend->ssl);
 
   if(!conn_config->verifyhost)
@@ -964,6 +1061,12 @@ mbed_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)
 
   peercert = mbedtls_ssl_get_peer_cert(&backend->ssl);
 
+  if(peercert) {
+    const CURLcode result = collect_server_cert(cf, data, peercert);
+    if(result)
+      return result;
+  }
+
   if(peercert && data->set.verbose) {
 #ifndef MBEDTLS_X509_REMOVE_INFO
     const size_t bufsize = 16384;
@@ -1088,10 +1191,9 @@ mbed_connect_step3(struct Curl_cfilter *cf, struct Curl_easy *data)
   DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);
   DEBUGASSERT(backend);
 
-  if(ssl_config->primary.sessionid) {
+  if(ssl_config->primary.cache_session) {
     int ret;
     mbedtls_ssl_session *our_ssl_sessionid;
-    void *old_ssl_sessionid = NULL;
 
     our_ssl_sessionid = malloc(sizeof(mbedtls_ssl_session));
     if(!our_ssl_sessionid)
@@ -1108,15 +1210,11 @@ mbed_connect_step3(struct Curl_cfilter *cf, struct Curl_easy *data)
       return CURLE_SSL_CONNECT_ERROR;
     }
 
-    /* If there's already a matching session in the cache, delete it */
+    /* If there is already a matching session in the cache, delete it */
     Curl_ssl_sessionid_lock(data);
-    if(!Curl_ssl_getsessionid(cf, data, &connssl->peer,
-                              &old_ssl_sessionid, NULL))
-      Curl_ssl_delsessionid(data, old_ssl_sessionid);
-
-    retcode = Curl_ssl_addsessionid(cf, data, &connssl->peer,
-                                    our_ssl_sessionid, 0,
-                                    mbedtls_session_free);
+    retcode = Curl_ssl_set_sessionid(cf, data, &connssl->peer,
+                                     our_ssl_sessionid, 0,
+                                     mbedtls_session_free);
     Curl_ssl_sessionid_unlock(data);
     if(retcode)
       return retcode;
@@ -1141,8 +1239,13 @@ static ssize_t mbed_send(struct Curl_cfilter *cf, struct Curl_easy *data,
   ret = mbedtls_ssl_write(&backend->ssl, (unsigned char *)mem, len);
 
   if(ret < 0) {
-    *curlcode = (ret == MBEDTLS_ERR_SSL_WANT_WRITE) ?
-      CURLE_AGAIN : CURLE_SEND_ERROR;
+    CURL_TRC_CF(data, cf, "mbedtls_ssl_write(len=%zu) -> -0x%04X",
+                len, -ret);
+    *curlcode = ((ret == MBEDTLS_ERR_SSL_WANT_WRITE)
+#ifdef TLS13_SUPPORT
+      || (ret == MBEDTLS_ERR_SSL_RECEIVED_NEW_SESSION_TICKET)
+#endif
+      )? CURLE_AGAIN : CURLE_SEND_ERROR;
     ret = -1;
   }
 
@@ -1154,33 +1257,120 @@ static void mbedtls_close_all(struct Curl_easy *data)
   (void)data;
 }
 
-static void mbedtls_close(struct Curl_cfilter *cf, struct Curl_easy *data)
+static CURLcode mbedtls_shutdown(struct Curl_cfilter *cf,
+                                 struct Curl_easy *data,
+                                 bool send_shutdown, bool *done)
 {
   struct ssl_connect_data *connssl = cf->ctx;
   struct mbed_ssl_backend_data *backend =
     (struct mbed_ssl_backend_data *)connssl->backend;
-  char buf[32];
+  unsigned char buf[1024];
+  CURLcode result = CURLE_OK;
+  int ret;
+  size_t i;
 
-  (void)data;
   DEBUGASSERT(backend);
 
-  /* Maybe the server has already sent a close notify alert.
-     Read it to avoid an RST on the TCP connection. */
-  (void)mbedtls_ssl_read(&backend->ssl, (unsigned char *)buf, sizeof(buf));
+  if(!backend->initialized || cf->shutdown) {
+    *done = TRUE;
+    return CURLE_OK;
+  }
+
+  connssl->io_need = CURL_SSL_IO_NEED_NONE;
+  *done = FALSE;
+
+  if(!backend->sent_shutdown) {
+    /* do this only once */
+    backend->sent_shutdown = TRUE;
+    if(send_shutdown) {
+      ret = mbedtls_ssl_close_notify(&backend->ssl);
+      switch(ret) {
+      case 0: /* we sent it, receive from the server */
+        break;
+      case MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY: /* server also closed */
+        *done = TRUE;
+        goto out;
+      case MBEDTLS_ERR_SSL_WANT_READ:
+        connssl->io_need = CURL_SSL_IO_NEED_RECV;
+        goto out;
+      case MBEDTLS_ERR_SSL_WANT_WRITE:
+        connssl->io_need = CURL_SSL_IO_NEED_SEND;
+        goto out;
+      default:
+        CURL_TRC_CF(data, cf, "mbedtls_shutdown error -0x%04X", -ret);
+        result = CURLE_RECV_ERROR;
+        goto out;
+      }
+    }
+  }
+
+  /* SSL should now have started the shutdown from our side. Since it
+   * was not complete, we are lacking the close notify from the server. */
+  for(i = 0; i < 10; ++i) {
+    ret = mbedtls_ssl_read(&backend->ssl, buf, sizeof(buf));
+    /* This seems to be a bug in mbedTLS TLSv1.3 where it reports
+     * WANT_READ, but has not encountered an EAGAIN. */
+    if(ret == MBEDTLS_ERR_SSL_WANT_READ)
+      ret = mbedtls_ssl_read(&backend->ssl, buf, sizeof(buf));
+#ifdef TLS13_SUPPORT
+    if(ret == MBEDTLS_ERR_SSL_RECEIVED_NEW_SESSION_TICKET)
+      continue;
+#endif
+    if(ret <= 0)
+      break;
+  }
 
-  mbedtls_pk_free(&backend->pk);
-  mbedtls_x509_crt_free(&backend->clicert);
-  mbedtls_x509_crt_free(&backend->cacert);
+  if(ret > 0) {
+    /* still data coming in? */
+    CURL_TRC_CF(data, cf, "mbedtls_shutdown, still getting data");
+  }
+  else if(ret == 0 || (ret == MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY)) {
+    /* We got the close notify alert and are done. */
+    CURL_TRC_CF(data, cf, "mbedtls_shutdown done");
+    *done = TRUE;
+  }
+  else if(ret == MBEDTLS_ERR_SSL_WANT_READ) {
+    CURL_TRC_CF(data, cf, "mbedtls_shutdown, need RECV");
+    connssl->io_need = CURL_SSL_IO_NEED_RECV;
+  }
+  else if(ret == MBEDTLS_ERR_SSL_WANT_WRITE) {
+    CURL_TRC_CF(data, cf, "mbedtls_shutdown, need SEND");
+    connssl->io_need = CURL_SSL_IO_NEED_SEND;
+  }
+  else {
+    CURL_TRC_CF(data, cf, "mbedtls_shutdown error -0x%04X", -ret);
+    result = CURLE_RECV_ERROR;
+  }
+
+out:
+  cf->shutdown = (result || *done);
+  return result;
+}
+
+static void mbedtls_close(struct Curl_cfilter *cf, struct Curl_easy *data)
+{
+  struct ssl_connect_data *connssl = cf->ctx;
+  struct mbed_ssl_backend_data *backend =
+    (struct mbed_ssl_backend_data *)connssl->backend;
+
+  (void)data;
+  DEBUGASSERT(backend);
+  if(backend->initialized) {
+    mbedtls_pk_free(&backend->pk);
+    mbedtls_x509_crt_free(&backend->clicert);
+    mbedtls_x509_crt_free(&backend->cacert);
 #ifdef MBEDTLS_X509_CRL_PARSE_C
-  mbedtls_x509_crl_free(&backend->crl);
+    mbedtls_x509_crl_free(&backend->crl);
 #endif
-  Curl_safefree(backend->ciphersuites);
-  mbedtls_ssl_config_free(&backend->config);
-  mbedtls_ssl_free(&backend->ssl);
-  mbedtls_ctr_drbg_free(&backend->ctr_drbg);
+    Curl_safefree(backend->ciphersuites);
+    mbedtls_ssl_config_free(&backend->config);
+    mbedtls_ssl_free(&backend->ssl);
+    mbedtls_ctr_drbg_free(&backend->ctr_drbg);
 #ifndef THREADING_SUPPORT
-  mbedtls_entropy_free(&backend->entropy);
+    mbedtls_entropy_free(&backend->entropy);
 #endif /* THREADING_SUPPORT */
+    backend->initialized = FALSE;
+  }
 }
 
 static ssize_t mbed_recv(struct Curl_cfilter *cf, struct Curl_easy *data,
@@ -1198,16 +1388,21 @@ static ssize_t mbed_recv(struct Curl_cfilter *cf, struct Curl_easy *data,
 
   ret = mbedtls_ssl_read(&backend->ssl, (unsigned char *)buf,
                          buffersize);
-
   if(ret <= 0) {
+    CURL_TRC_CF(data, cf, "mbedtls_ssl_read(len=%zu) -> -0x%04X",
+                buffersize, -ret);
     if(ret == MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY)
       return 0;
-
     *curlcode = ((ret == MBEDTLS_ERR_SSL_WANT_READ)
 #ifdef TLS13_SUPPORT
               || (ret == MBEDTLS_ERR_SSL_RECEIVED_NEW_SESSION_TICKET)
 #endif
     ) ? CURLE_AGAIN : CURLE_RECV_ERROR;
+    if(*curlcode != CURLE_AGAIN) {
+      char errorbuf[128];
+      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));
+      failf(data, "ssl_read returned: (-0x%04X) %s", -ret, errorbuf);
+    }
     return -1;
   }
 
@@ -1290,7 +1485,7 @@ mbed_connect_common(struct Curl_cfilter *cf, struct Curl_easy *data,
   }
 
   if(ssl_connect_1 == connssl->connecting_state) {
-    /* Find out how much more time we're allowed */
+    /* Find out how much more time we are allowed */
     timeout_ms = Curl_timeleft(data, NULL, TRUE);
 
     if(timeout_ms < 0) {
@@ -1303,9 +1498,7 @@ mbed_connect_common(struct Curl_cfilter *cf, struct Curl_easy *data,
       return retcode;
   }
 
-  while(ssl_connect_2 == connssl->connecting_state ||
-        ssl_connect_2_reading == connssl->connecting_state ||
-        ssl_connect_2_writing == connssl->connecting_state) {
+  while(ssl_connect_2 == connssl->connecting_state) {
 
     /* check allowed time left */
     timeout_ms = Curl_timeleft(data, NULL, TRUE);
@@ -1316,14 +1509,13 @@ mbed_connect_common(struct Curl_cfilter *cf, struct Curl_easy *data,
       return CURLE_OPERATION_TIMEDOUT;
     }
 
-    /* if ssl is expecting something, check if it's available. */
-    if(connssl->connecting_state == ssl_connect_2_reading
-       || connssl->connecting_state == ssl_connect_2_writing) {
+    /* if ssl is expecting something, check if it is available. */
+    if(connssl->io_need) {
 
-      curl_socket_t writefd = ssl_connect_2_writing ==
-        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;
-      curl_socket_t readfd = ssl_connect_2_reading ==
-        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;
+      curl_socket_t writefd = (connssl->io_need & CURL_SSL_IO_NEED_SEND)?
+                              sockfd:CURL_SOCKET_BAD;
+      curl_socket_t readfd = (connssl->io_need & CURL_SSL_IO_NEED_RECV)?
+                             sockfd:CURL_SOCKET_BAD;
 
       what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,
                                nonblocking ? 0 : timeout_ms);
@@ -1353,11 +1545,10 @@ mbed_connect_common(struct Curl_cfilter *cf, struct Curl_easy *data,
      * ensuring that a client using select() or epoll() will always
      * have a valid fdset to wait on.
      */
+    connssl->io_need = CURL_SSL_IO_NEED_NONE;
     retcode = mbed_connect_step2(cf, data);
-    if(retcode || (nonblocking &&
-                   (ssl_connect_2 == connssl->connecting_state ||
-                    ssl_connect_2_reading == connssl->connecting_state ||
-                    ssl_connect_2_writing == connssl->connecting_state)))
+    if(retcode ||
+       (nonblocking && (ssl_connect_2 == connssl->connecting_state)))
       return retcode;
 
   } /* repeat step2 until all transactions are done. */
@@ -1474,6 +1665,7 @@ const struct Curl_ssl Curl_ssl_mbedtls = {
 
   SSLSUPP_CA_PATH |
   SSLSUPP_CAINFO_BLOB |
+  SSLSUPP_CERTINFO |
   SSLSUPP_PINNEDPUBKEY |
   SSLSUPP_SSL_CTX |
   SSLSUPP_HTTPS_PROXY,
@@ -1484,7 +1676,7 @@ const struct Curl_ssl Curl_ssl_mbedtls = {
   mbedtls_cleanup,                  /* cleanup */
   mbedtls_version,                  /* version */
   Curl_none_check_cxn,              /* check_cxn */
-  Curl_none_shutdown,               /* shutdown */
+  mbedtls_shutdown,                 /* shutdown */
   mbedtls_data_pending,             /* data_pending */
   mbedtls_random,                   /* random */
   Curl_none_cert_status_request,    /* cert_status_request */
@@ -1501,7 +1693,6 @@ const struct Curl_ssl Curl_ssl_mbedtls = {
   mbedtls_sha256sum,                /* sha256sum */
   NULL,                             /* associate_connection */
   NULL,                             /* disassociate_connection */
-  NULL,                             /* free_multi_ssl_backend_data */
   mbed_recv,                        /* recv decrypted data */
   mbed_send,                        /* send data to encrypt */
 };
diff --git a/lib/vtls/openssl.c b/lib/vtls/openssl.c
index 298a488a0..8a65491b2 100644
--- a/lib/vtls/openssl.c
+++ b/lib/vtls/openssl.c
@@ -231,7 +231,7 @@
 /*
  * Whether SSL_CTX_set1_curves_list is available.
  * OpenSSL: supported since 1.0.2, see
- *   https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set1_groups.html
+ *   https://docs.openssl.org/master/man3/SSL_CTX_set1_curves/
  * BoringSSL: supported since 5fd1807d95f7 (committed 2016-09-30)
  * LibreSSL: since 2.5.3 (April 12, 2017)
  */
@@ -254,13 +254,20 @@
 #endif
 #endif
 
+#if defined(OPENSSL_IS_BORINGSSL) || defined(OPENSSL_IS_AWSLC)
+typedef size_t numcert_t;
+#else
+typedef int numcert_t;
+#endif
+#define ossl_valsize_t numcert_t
+
 #if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
 /* up2date versions of OpenSSL maintain reasonably secure defaults without
  * breaking compatibility, so it is better not to override the defaults in curl
  */
 #define DEFAULT_CIPHER_SELECTION NULL
 #else
-/* ... but it is not the case with old versions of OpenSSL */
+/* not the case with old versions of OpenSSL */
 #define DEFAULT_CIPHER_SELECTION \
   "ALL:!EXPORT:!EXPORT40:!EXPORT56:!aNULL:!LOW:!RC4:@STRENGTH"
 #endif
@@ -307,14 +314,6 @@ typedef unsigned long sslerr_t;
 #define USE_PRE_1_1_API (OPENSSL_VERSION_NUMBER < 0x10100000L)
 #endif /* !LIBRESSL_VERSION_NUMBER */
 
-#if defined(HAVE_SSL_X509_STORE_SHARE)
-struct multi_ssl_backend_data {
-  char *CAfile;         /* CAfile path used to generate X509 store */
-  X509_STORE *store;    /* cached X509 store or NULL if none */
-  struct curltime time; /* when the cached store was created */
-};
-#endif /* HAVE_SSL_X509_STORE_SHARE */
-
 #define push_certinfo(_label, _num)             \
 do {                              \
   long info_len = BIO_get_mem_data(mem, &ptr); \
@@ -381,7 +380,7 @@ static void X509V3_ext(struct Curl_easy *data,
 
   for(i = 0; i < (int)sk_X509_EXTENSION_num(exts); i++) {
     ASN1_OBJECT *obj;
-    X509_EXTENSION *ext = sk_X509_EXTENSION_value(exts, i);
+    X509_EXTENSION *ext = sk_X509_EXTENSION_value(exts, (ossl_valsize_t)i);
     BUF_MEM *biomem;
     char namebuf[128];
     BIO *bio_out = BIO_new(BIO_s_mem());
@@ -403,12 +402,6 @@ static void X509V3_ext(struct Curl_easy *data,
   }
 }
 
-#if defined(OPENSSL_IS_BORINGSSL) || defined(OPENSSL_IS_AWSLC)
-typedef size_t numcert_t;
-#else
-typedef int numcert_t;
-#endif
-
 CURLcode Curl_ossl_certchain(struct Curl_easy *data, SSL *ssl)
 {
   CURLcode result;
@@ -438,7 +431,7 @@ CURLcode Curl_ossl_certchain(struct Curl_easy *data, SSL *ssl)
 
   for(i = 0; i < (int)numcerts; i++) {
     ASN1_INTEGER *num;
-    X509 *x = sk_X509_value(sk, i);
+    X509 *x = sk_X509_value(sk, (ossl_valsize_t)i);
     EVP_PKEY *pubkey = NULL;
     int j;
     char *ptr;
@@ -727,7 +720,10 @@ static int ossl_bio_cf_out_write(BIO *bio, const char *buf, int blen)
   CURLcode result = CURLE_SEND_ERROR;
 
   DEBUGASSERT(data);
-  nwritten = Curl_conn_cf_send(cf->next, data, buf, blen, &result);
+  if(blen < 0)
+    return 0;
+
+  nwritten = Curl_conn_cf_send(cf->next, data, buf, (size_t)blen, &result);
   CURL_TRC_CF(data, cf, "ossl_bio_cf_out_write(len=%d) -> %d, err=%d",
               blen, (int)nwritten, result);
   BIO_clear_retry_flags(bio);
@@ -752,8 +748,10 @@ static int ossl_bio_cf_in_read(BIO *bio, char *buf, int blen)
   /* OpenSSL catches this case, so should we. */
   if(!buf)
     return 0;
+  if(blen < 0)
+    return 0;
 
-  nread = Curl_conn_cf_recv(cf->next, data, buf, blen, &result);
+  nread = Curl_conn_cf_recv(cf->next, data, buf, (size_t)blen, &result);
   CURL_TRC_CF(data, cf, "ossl_bio_cf_in_read(len=%d) -> %d, err=%d",
               blen, (int)nread, result);
   BIO_clear_retry_flags(bio);
@@ -844,7 +842,7 @@ static void ossl_keylog_callback(const SSL *ssl, const char *line)
 #else
 /*
  * ossl_log_tls12_secret is called by libcurl to make the CLIENT_RANDOMs if the
- * OpenSSL being used doesn't have native support for doing that.
+ * OpenSSL being used does not have native support for doing that.
  */
 static void
 ossl_log_tls12_secret(const SSL *ssl, bool *keylog_done)
@@ -860,7 +858,7 @@ ossl_log_tls12_secret(const SSL *ssl, bool *keylog_done)
 #if OPENSSL_VERSION_NUMBER >= 0x10100000L &&    \
   !(defined(LIBRESSL_VERSION_NUMBER) &&         \
     LIBRESSL_VERSION_NUMBER < 0x20700000L)
-  /* ssl->s3 is not checked in openssl 1.1.0-pre6, but let's assume that
+  /* ssl->s3 is not checked in OpenSSL 1.1.0-pre6, but let's assume that
    * we have a valid SSL context if we have a non-NULL session. */
   SSL_get_client_random(ssl, client_random, SSL3_RANDOM_SIZE);
   master_key_length = (int)
@@ -963,7 +961,7 @@ static int passwd_callback(char *buf, int num, int encrypting,
 {
   DEBUGASSERT(0 == encrypting);
 
-  if(!encrypting) {
+  if(!encrypting && num >= 0) {
     int klen = curlx_uztosi(strlen((char *)global_passwd));
     if(num > klen) {
       memcpy(buf, global_passwd, klen + 1);
@@ -1014,13 +1012,12 @@ static CURLcode ossl_seed(struct Curl_easy *data)
     for(i = 0, i_max = len / sizeof(struct curltime); i < i_max; ++i) {
       struct curltime tv = Curl_now();
       Curl_wait_ms(1);
-      tv.tv_sec *= i + 1;
-      tv.tv_usec *= (unsigned int)i + 2;
-      tv.tv_sec ^= ((Curl_now().tv_sec + Curl_now().tv_usec) *
-                    (i + 3)) << 8;
-      tv.tv_usec ^= (unsigned int) ((Curl_now().tv_sec +
-                                     Curl_now().tv_usec) *
-                                    (i + 4)) << 16;
+      tv.tv_sec *= (time_t)i + 1;
+      tv.tv_usec *= (int)i + 2;
+      tv.tv_sec ^= ((Curl_now().tv_sec + (time_t)Curl_now().tv_usec) *
+                    (time_t)(i + 3)) << 8;
+      tv.tv_usec ^= (int) ((Curl_now().tv_sec + (time_t)Curl_now().tv_usec) *
+                           (time_t)(i + 4)) << 16;
       memcpy(&randb[i * sizeof(struct curltime)], &tv,
              sizeof(struct curltime));
     }
@@ -1033,7 +1030,7 @@ static CURLcode ossl_seed(struct Curl_easy *data)
     fname[0] = 0; /* blank it first */
     RAND_file_name(fname, sizeof(fname));
     if(fname[0]) {
-      /* we got a file name to try */
+      /* we got a filename to try */
       RAND_load_file(fname, RAND_LOAD_LENGTH);
       if(rand_enough())
         return CURLE_OK;
@@ -1369,7 +1366,7 @@ int cert_stuff(struct Curl_easy *data,
         }
 
         if(!params.cert) {
-          failf(data, "ssl engine didn't initialized the certificate "
+          failf(data, "ssl engine did not initialized the certificate "
                 "properly.");
           return 0;
         }
@@ -1380,10 +1377,10 @@ int cert_stuff(struct Curl_easy *data,
                               sizeof(error_buffer)));
           return 0;
         }
-        X509_free(params.cert); /* we don't need the handle any more... */
+        X509_free(params.cert); /* we do not need the handle any more... */
       }
       else {
-        failf(data, "crypto engine not set, can't load certificate");
+        failf(data, "crypto engine not set, cannot load certificate");
         return 0;
       }
     }
@@ -1479,7 +1476,7 @@ int cert_stuff(struct Curl_easy *data,
            * Note that sk_X509_pop() is used below to make sure the cert is
            * removed from the stack properly before getting passed to
            * SSL_CTX_add_extra_chain_cert(), which takes ownership. Previously
-           * we used sk_X509_value() instead, but then we'd clean it in the
+           * we used sk_X509_value() instead, but then we would clean it in the
            * subsequent sk_X509_pop_free() call.
            */
           X509 *x = sk_X509_pop(ca);
@@ -1572,10 +1569,10 @@ fail:
           EVP_PKEY_free(priv_key);
           return 0;
         }
-        EVP_PKEY_free(priv_key);  /* we don't need the handle any more... */
+        EVP_PKEY_free(priv_key);  /* we do not need the handle any more... */
       }
       else {
-        failf(data, "crypto engine not set, can't load private key");
+        failf(data, "crypto engine not set, cannot load private key");
         return 0;
       }
     }
@@ -1614,8 +1611,8 @@ fail:
 #if !defined(OPENSSL_NO_RSA) && !defined(OPENSSL_IS_BORINGSSL) &&       \
   !defined(OPENSSL_NO_DEPRECATED_3_0)
     {
-      /* If RSA is used, don't check the private key if its flags indicate
-       * it doesn't support it. */
+      /* If RSA is used, do not check the private key if its flags indicate
+       * it does not support it. */
       EVP_PKEY *priv_key = SSL_get_privatekey(ssl);
       int pktype;
 #ifdef HAVE_OPAQUE_EVP_PKEY
@@ -1681,7 +1678,7 @@ static int x509_name_oneline(X509_NAME *a, char *buf, size_t size)
   if((size_t)biomem->length < size)
     size = biomem->length;
   else
-    size--; /* don't overwrite the buffer end */
+    size--; /* do not overwrite the buffer end */
 
   memcpy(buf, biomem->data, size);
   buf[size] = 0;
@@ -1873,203 +1870,133 @@ static struct curl_slist *ossl_engines_list(struct Curl_easy *data)
   return list;
 }
 
-static void ossl_close(struct Curl_cfilter *cf, struct Curl_easy *data)
+static CURLcode ossl_shutdown(struct Curl_cfilter *cf,
+                              struct Curl_easy *data,
+                              bool send_shutdown, bool *done)
 {
   struct ssl_connect_data *connssl = cf->ctx;
   struct ossl_ctx *octx = (struct ossl_ctx *)connssl->backend;
+  CURLcode result = CURLE_OK;
+  char buf[1024];
+  int nread, err;
+  unsigned long sslerr;
+  size_t i;
 
-  (void)data;
   DEBUGASSERT(octx);
+  if(!octx->ssl || cf->shutdown) {
+    *done = TRUE;
+    goto out;
+  }
 
-  if(octx->ssl) {
-    /* Send the TLS shutdown if we are still connected *and* if
-     * the peer did not already close the connection. */
-    if(cf->next && cf->next->connected && !connssl->peer_closed) {
-      char buf[1024];
-      int nread, err;
-      long sslerr;
-
-      /* Maybe the server has already sent a close notify alert.
-         Read it to avoid an RST on the TCP connection. */
-      ERR_clear_error();
+  connssl->io_need = CURL_SSL_IO_NEED_NONE;
+  *done = FALSE;
+  if(!(SSL_get_shutdown(octx->ssl) & SSL_SENT_SHUTDOWN)) {
+    /* We have not started the shutdown from our side yet. Check
+     * if the server already sent us one. */
+    ERR_clear_error();
+    for(i = 0; i < 10; ++i) {
       nread = SSL_read(octx->ssl, buf, (int)sizeof(buf));
-      err = SSL_get_error(octx->ssl, nread);
-      if(!nread && err == SSL_ERROR_ZERO_RETURN) {
-        CURLcode result;
-        ssize_t n;
-        size_t blen = sizeof(buf);
-        CURL_TRC_CF(data, cf, "peer has shutdown TLS");
-        /* SSL_read() will not longer touch the socket, let's receive
-         * directly from the next filter to see if the underlying
-         * connection has also been closed. */
-        n = Curl_conn_cf_recv(cf->next, data, buf, blen, &result);
-        if(!n) {
-          connssl->peer_closed = TRUE;
-          CURL_TRC_CF(data, cf, "peer closed connection");
-        }
-      }
-      ERR_clear_error();
-      if(connssl->peer_closed) {
-        /* As the peer closed, we do not expect it to read anything more we
-         * may send. It may be harmful, leading to TCP RST and delaying
-         * a lingering close. Just leave. */
-        CURL_TRC_CF(data, cf, "not from sending TLS shutdown on "
-                    "connection closed by peer");
-      }
-      else if(SSL_shutdown(octx->ssl) == 1) {
-        CURL_TRC_CF(data, cf, "SSL shutdown finished");
+      CURL_TRC_CF(data, cf, "SSL shutdown not sent, read -> %d", nread);
+      if(nread <= 0)
+        break;
+    }
+    err = SSL_get_error(octx->ssl, nread);
+    if(!nread && err == SSL_ERROR_ZERO_RETURN) {
+      bool input_pending;
+      /* Yes, it did. */
+      if(!send_shutdown) {
+        CURL_TRC_CF(data, cf, "SSL shutdown received, not sending");
+        *done = TRUE;
+        goto out;
       }
-      else {
-        nread = SSL_read(octx->ssl, buf, (int)sizeof(buf));
-        err = SSL_get_error(octx->ssl, nread);
-        switch(err) {
-        case SSL_ERROR_NONE: /* this is not an error */
-        case SSL_ERROR_ZERO_RETURN: /* no more data */
-          CURL_TRC_CF(data, cf, "SSL shutdown, EOF from server");
-          break;
-        case SSL_ERROR_WANT_READ:
-          /* SSL has send its notify and now wants to read the reply
-           * from the server. We are not really interested in that. */
-          CURL_TRC_CF(data, cf, "SSL shutdown sent");
-          break;
-        case SSL_ERROR_WANT_WRITE:
-          CURL_TRC_CF(data, cf, "SSL shutdown send blocked");
-          break;
-        default:
-          sslerr = ERR_get_error();
-          CURL_TRC_CF(data, cf, "SSL shutdown, error: '%s', errno %d",
-                      (sslerr ?
-                       ossl_strerror(sslerr, buf, sizeof(buf)) :
-                       SSL_ERROR_to_str(err)),
-                      SOCKERRNO);
-          break;
-        }
+      else if(!cf->next->cft->is_alive(cf->next, data, &input_pending)) {
+        /* Server closed the connection after its closy notify. It
+         * seems not interested to see our close notify, so do not
+         * send it. We are done. */
+        connssl->peer_closed = TRUE;
+        CURL_TRC_CF(data, cf, "peer closed connection");
+        *done = TRUE;
+        goto out;
       }
-
-      ERR_clear_error();
-      SSL_set_connect_state(octx->ssl);
     }
+    if(send_shutdown && SSL_shutdown(octx->ssl) == 1) {
+      CURL_TRC_CF(data, cf, "SSL shutdown finished");
+      *done = TRUE;
+      goto out;
+    }
+  }
 
-    SSL_free(octx->ssl);
-    octx->ssl = NULL;
+  /* SSL should now have started the shutdown from our side. Since it
+   * was not complete, we are lacking the close notify from the server. */
+  for(i = 0; i < 10; ++i) {
+    ERR_clear_error();
+    nread = SSL_read(octx->ssl, buf, (int)sizeof(buf));
+    CURL_TRC_CF(data, cf, "SSL shutdown read -> %d", nread);
+    if(nread <= 0)
+      break;
   }
-  if(octx->ssl_ctx) {
-    SSL_CTX_free(octx->ssl_ctx);
-    octx->ssl_ctx = NULL;
-    octx->x509_store_setup = FALSE;
+  if(SSL_get_shutdown(octx->ssl) & SSL_RECEIVED_SHUTDOWN) {
+    CURL_TRC_CF(data, cf, "SSL shutdown received, finished");
+    *done = TRUE;
+    goto out;
   }
-  if(octx->bio_method) {
-    ossl_bio_cf_method_free(octx->bio_method);
-    octx->bio_method = NULL;
+  err = SSL_get_error(octx->ssl, nread);
+  switch(err) {
+  case SSL_ERROR_ZERO_RETURN: /* no more data */
+    CURL_TRC_CF(data, cf, "SSL shutdown not received, but closed");
+    *done = TRUE;
+    break;
+  case SSL_ERROR_NONE: /* just did not get anything */
+  case SSL_ERROR_WANT_READ:
+    /* SSL has send its notify and now wants to read the reply
+     * from the server. We are not really interested in that. */
+    CURL_TRC_CF(data, cf, "SSL shutdown sent, want receive");
+    connssl->io_need = CURL_SSL_IO_NEED_RECV;
+    break;
+  case SSL_ERROR_WANT_WRITE:
+    CURL_TRC_CF(data, cf, "SSL shutdown send blocked");
+    connssl->io_need = CURL_SSL_IO_NEED_SEND;
+    break;
+  default:
+    /* Server seems to have closed the connection without sending us
+     * a close notify. */
+    sslerr = ERR_get_error();
+    CURL_TRC_CF(data, cf, "SSL shutdown, ignore recv error: '%s', errno %d",
+                (sslerr ?
+                 ossl_strerror(sslerr, buf, sizeof(buf)) :
+                 SSL_ERROR_to_str(err)),
+                SOCKERRNO);
+    *done = TRUE;
+    result = CURLE_OK;
+    break;
   }
+
+out:
+  cf->shutdown = (result || *done);
+  return result;
 }
 
-/*
- * This function is called to shut down the SSL layer but keep the
- * socket open (CCC - Clear Command Channel)
- */
-static int ossl_shutdown(struct Curl_cfilter *cf,
-                         struct Curl_easy *data)
+static void ossl_close(struct Curl_cfilter *cf, struct Curl_easy *data)
 {
-  int retval = 0;
   struct ssl_connect_data *connssl = cf->ctx;
-  char buf[256]; /* We will use this for the OpenSSL error buffer, so it has
-                    to be at least 256 bytes long. */
-  unsigned long sslerror;
-  int nread;
-  int buffsize;
-  int err;
-  bool done = FALSE;
   struct ossl_ctx *octx = (struct ossl_ctx *)connssl->backend;
-  int loop = 10;
 
+  (void)data;
   DEBUGASSERT(octx);
 
-#ifndef CURL_DISABLE_FTP
-  /* This has only been tested on the proftpd server, and the mod_tls code
-     sends a close notify alert without waiting for a close notify alert in
-     response. Thus we wait for a close notify alert from the server, but
-     we do not send one. Let's hope other servers do the same... */
-
-  if(data->set.ftp_ccc == CURLFTPSSL_CCC_ACTIVE)
-    (void)SSL_shutdown(octx->ssl);
-#endif
-
   if(octx->ssl) {
-    buffsize = (int)sizeof(buf);
-    while(!done && loop--) {
-      int what = SOCKET_READABLE(Curl_conn_cf_get_socket(cf, data),
-                                 SSL_SHUTDOWN_TIMEOUT);
-      if(what > 0) {
-        ERR_clear_error();
-
-        /* Something to read, let's do it and hope that it is the close
-           notify alert from the server */
-        nread = SSL_read(octx->ssl, buf, buffsize);
-        err = SSL_get_error(octx->ssl, nread);
-
-        switch(err) {
-        case SSL_ERROR_NONE: /* this is not an error */
-        case SSL_ERROR_ZERO_RETURN: /* no more data */
-          /* This is the expected response. There was no data but only
-             the close notify alert */
-          done = TRUE;
-          break;
-        case SSL_ERROR_WANT_READ:
-          /* there's data pending, re-invoke SSL_read() */
-          infof(data, "SSL_ERROR_WANT_READ");
-          break;
-        case SSL_ERROR_WANT_WRITE:
-          /* SSL wants a write. Really odd. Let's bail out. */
-          infof(data, "SSL_ERROR_WANT_WRITE");
-          done = TRUE;
-          break;
-        default:
-          /* openssl/ssl.h says "look at error stack/return value/errno" */
-          sslerror = ERR_get_error();
-          failf(data, OSSL_PACKAGE " SSL_read on shutdown: %s, errno %d",
-                (sslerror ?
-                 ossl_strerror(sslerror, buf, sizeof(buf)) :
-                 SSL_ERROR_to_str(err)),
-                SOCKERRNO);
-          done = TRUE;
-          break;
-        }
-      }
-      else if(0 == what) {
-        /* timeout */
-        failf(data, "SSL shutdown timeout");
-        done = TRUE;
-      }
-      else {
-        /* anything that gets here is fatally bad */
-        failf(data, "select/poll on SSL socket, errno: %d", SOCKERRNO);
-        retval = -1;
-        done = TRUE;
-      }
-    } /* while()-loop for the select() */
-
-    if(data->set.verbose) {
-#ifdef HAVE_SSL_GET_SHUTDOWN
-      switch(SSL_get_shutdown(octx->ssl)) {
-      case SSL_SENT_SHUTDOWN:
-        infof(data, "SSL_get_shutdown() returned SSL_SENT_SHUTDOWN");
-        break;
-      case SSL_RECEIVED_SHUTDOWN:
-        infof(data, "SSL_get_shutdown() returned SSL_RECEIVED_SHUTDOWN");
-        break;
-      case SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN:
-        infof(data, "SSL_get_shutdown() returned SSL_SENT_SHUTDOWN|"
-              "SSL_RECEIVED__SHUTDOWN");
-        break;
-      }
-#endif
-    }
-
     SSL_free(octx->ssl);
     octx->ssl = NULL;
   }
-  return retval;
+  if(octx->ssl_ctx) {
+    SSL_CTX_free(octx->ssl_ctx);
+    octx->ssl_ctx = NULL;
+    octx->x509_store_setup = FALSE;
+  }
+  if(octx->bio_method) {
+    ossl_bio_cf_method_free(octx->bio_method);
+    octx->bio_method = NULL;
+  }
 }
 
 static void ossl_session_free(void *sessionid, size_t idsize)
@@ -2107,7 +2034,7 @@ static void ossl_close_all(struct Curl_easy *data)
 /* ====================================================== */
 
 /*
- * Match subjectAltName against the host name.
+ * Match subjectAltName against the hostname.
  */
 static bool subj_alt_hostcheck(struct Curl_easy *data,
                                const char *match_pattern,
@@ -2137,7 +2064,7 @@ static bool subj_alt_hostcheck(struct Curl_easy *data,
    Certification Authorities are encouraged to use the dNSName instead.
 
    Matching is performed using the matching rules specified by
-   [RFC2459].  If more than one identity of a given type is present in
+   [RFC2459]. If more than one identity of a given type is present in
    the certificate (e.g., more than one dNSName name, a match in any one
    of the set is considered acceptable.) Names may contain the wildcard
    character * which is considered to match any single domain name
@@ -2208,7 +2135,7 @@ CURLcode Curl_ossl_verifyhost(struct Curl_easy *data, struct connectdata *conn,
     bool ipmatched = FALSE;
 
     /* get amount of alternatives, RFC2459 claims there MUST be at least
-       one, but we don't depend on it... */
+       one, but we do not depend on it... */
     numalts = sk_GENERAL_NAME_num(altnames);
 
     /* loop through all alternatives - until a dnsmatch */
@@ -2229,7 +2156,7 @@ CURLcode Curl_ossl_verifyhost(struct Curl_easy *data, struct connectdata *conn,
 
         switch(target) {
         case GEN_DNS: /* name/pattern comparison */
-          /* The OpenSSL man page explicitly says: "In general it cannot be
+          /* The OpenSSL manpage explicitly says: "In general it cannot be
              assumed that the data returned by ASN1_STRING_data() is null
              terminated or does not contain embedded nulls." But also that
              "The actual format of the data will depend on the actual string
@@ -2239,7 +2166,7 @@ CURLcode Curl_ossl_verifyhost(struct Curl_easy *data, struct connectdata *conn,
              is always null-terminated.
           */
           if((altlen == strlen(altptr)) &&
-             /* if this isn't true, there was an embedded zero in the name
+             /* if this is not true, there was an embedded zero in the name
                 string and we cannot match it. */
              subj_alt_hostcheck(data, altptr, altlen,
                                 peer->hostname, hostlen,
@@ -2271,7 +2198,7 @@ CURLcode Curl_ossl_verifyhost(struct Curl_easy *data, struct connectdata *conn,
     /* an alternative name matched */
     ;
   else if(dNSName || iPAddress) {
-    const char *tname = (peer->type == CURL_SSL_PEER_DNS) ? "host name" :
+    const char *tname = (peer->type == CURL_SSL_PEER_DNS) ? "hostname" :
                         (peer->type == CURL_SSL_PEER_IPV4) ?
                         "ipv4 address" : "ipv6 address";
     infof(data, " subjectAltName does not match %s %s", tname, peer->dispname);
@@ -2342,7 +2269,7 @@ CURLcode Curl_ossl_verifyhost(struct Curl_easy *data, struct connectdata *conn,
     else if(!Curl_cert_hostcheck((const char *)peer_CN,
                                  peerlen, peer->hostname, hostlen)) {
       failf(data, "SSL: certificate subject name '%s' does not match "
-            "target host name '%s'", peer_CN, peer->dispname);
+            "target hostname '%s'", peer_CN, peer->dispname);
       result = CURLE_PEER_FAILED_VERIFICATION;
     }
     else {
@@ -2358,9 +2285,9 @@ CURLcode Curl_ossl_verifyhost(struct Curl_easy *data, struct connectdata *conn,
 #if (OPENSSL_VERSION_NUMBER >= 0x0090808fL) && !defined(OPENSSL_NO_TLSEXT) && \
   !defined(OPENSSL_NO_OCSP)
 static CURLcode verifystatus(struct Curl_cfilter *cf,
-                             struct Curl_easy *data)
+                             struct Curl_easy *data,
+                             struct ossl_ctx *octx)
 {
-  struct ssl_connect_data *connssl = cf->ctx;
   int i, ocsp_status;
 #if defined(OPENSSL_IS_AWSLC)
   const uint8_t *status;
@@ -2373,7 +2300,6 @@ static CURLcode verifystatus(struct Curl_cfilter *cf,
   OCSP_BASICRESP *br = NULL;
   X509_STORE     *st = NULL;
   STACK_OF(X509) *ch = NULL;
-  struct ossl_ctx *octx = (struct ossl_ctx *)connssl->backend;
   X509 *cert;
   OCSP_CERTID *id = NULL;
   int cert_status, crl_reason;
@@ -2381,9 +2307,10 @@ static CURLcode verifystatus(struct Curl_cfilter *cf,
   int ret;
   long len;
 
+  (void)cf;
   DEBUGASSERT(octx);
 
-  len = SSL_get_tlsext_status_ocsp_resp(octx->ssl, &status);
+  len = (long)SSL_get_tlsext_status_ocsp_resp(octx->ssl, &status);
 
   if(!status) {
     failf(data, "No OCSP response received");
@@ -2425,8 +2352,8 @@ static CURLcode verifystatus(struct Curl_cfilter *cf,
      (defined(LIBRESSL_VERSION_NUMBER) &&                               \
       LIBRESSL_VERSION_NUMBER <= 0x2040200fL))
   /* The authorized responder cert in the OCSP response MUST be signed by the
-     peer cert's issuer (see RFC6960 section 4.2.2.2). If that's a root cert,
-     no problem, but if it's an intermediate cert OpenSSL has a bug where it
+     peer cert's issuer (see RFC6960 section 4.2.2.2). If that is a root cert,
+     no problem, but if it is an intermediate cert OpenSSL has a bug where it
      expects this issuer to be present in the chain embedded in the OCSP
      response. So we add it if necessary. */
 
@@ -2464,7 +2391,7 @@ static CURLcode verifystatus(struct Curl_cfilter *cf,
   }
 
   for(i = 0; i < (int)sk_X509_num(ch); i++) {
-    X509 *issuer = sk_X509_value(ch, i);
+    X509 *issuer = sk_X509_value(ch, (ossl_valsize_t)i);
     if(X509_check_issued(issuer, cert) == X509_V_OK) {
       id = OCSP_cert_to_id(EVP_sha1(), cert, issuer);
       break;
@@ -2525,7 +2452,7 @@ end:
 
 #endif /* USE_OPENSSL */
 
-/* The SSL_CTRL_SET_MSG_CALLBACK doesn't exist in ancient OpenSSL versions
+/* The SSL_CTRL_SET_MSG_CALLBACK does not exist in ancient OpenSSL versions
    and thus this cannot be done there. */
 #ifdef SSL_CTRL_SET_MSG_CALLBACK
 
@@ -2710,7 +2637,7 @@ static void ossl_trace(int direction, int ssl_ver, int content_type,
 
     ssl_ver >>= 8; /* check the upper 8 bits only below */
 
-    /* SSLv2 doesn't seem to have TLS record-type headers, so OpenSSL
+    /* SSLv2 does not seem to have TLS record-type headers, so OpenSSL
      * always pass-up content-type as 0. But the interesting message-type
      * is at 'buf[0]'.
      */
@@ -2797,7 +2724,7 @@ ossl_set_ssl_version_min_max(struct Curl_cfilter *cf, SSL_CTX *ctx)
   }
 
   /* CURL_SSLVERSION_DEFAULT means that no option was selected.
-     We don't want to pass 0 to SSL_CTX_set_min_proto_version as
+     We do not want to pass 0 to SSL_CTX_set_min_proto_version as
      it would enable all versions down to the lowest supported by
      the library.
      So we skip this, and stay with the library default
@@ -2809,7 +2736,7 @@ ossl_set_ssl_version_min_max(struct Curl_cfilter *cf, SSL_CTX *ctx)
   }
 
   /* ... then, TLS max version */
-  curl_ssl_version_max = conn_config->version_max;
+  curl_ssl_version_max = (long)conn_config->version_max;
 
   /* convert curl max SSL version option to OpenSSL constant */
   switch(curl_ssl_version_max) {
@@ -2850,6 +2777,9 @@ ossl_set_ssl_version_min_max(struct Curl_cfilter *cf, SSL_CTX *ctx)
 typedef uint32_t ctx_option_t;
 #elif OPENSSL_VERSION_NUMBER >= 0x30000000L
 typedef uint64_t ctx_option_t;
+#elif OPENSSL_VERSION_NUMBER >= 0x10100000L && \
+  !defined(LIBRESSL_VERSION_NUMBER)
+typedef unsigned long ctx_option_t;
 #else
 typedef long ctx_option_t;
 #endif
@@ -2857,14 +2787,14 @@ typedef long ctx_option_t;
 #if (OPENSSL_VERSION_NUMBER < 0x10100000L) /* 1.1.0 */
 static CURLcode
 ossl_set_ssl_version_min_max_legacy(ctx_option_t *ctx_options,
-                                       struct Curl_cfilter *cf,
-                                       struct Curl_easy *data)
+                                    struct Curl_cfilter *cf,
+                                    struct Curl_easy *data)
 {
   struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
   long ssl_version = conn_config->version;
   long ssl_version_max = conn_config->version_max;
 
-  (void) data; /* In case it's unused. */
+  (void) data; /* In case it is unused. */
 
   switch(ssl_version) {
   case CURL_SSLVERSION_TLSv1_3:
@@ -2937,42 +2867,25 @@ CURLcode Curl_ossl_add_session(struct Curl_cfilter *cf,
                                SSL_SESSION *session)
 {
   const struct ssl_config_data *config;
-  bool isproxy;
-  bool added = FALSE;
+  CURLcode result = CURLE_OK;
 
   if(!cf || !data)
     goto out;
 
-  isproxy = Curl_ssl_cf_is_proxy(cf);
-
   config = Curl_ssl_cf_get_config(cf, data);
-  if(config->primary.sessionid) {
-    bool incache;
-    void *old_session = NULL;
+  if(config->primary.cache_session) {
 
     Curl_ssl_sessionid_lock(data);
-    if(isproxy)
-      incache = FALSE;
-    else
-      incache = !(Curl_ssl_getsessionid(cf, data, peer,
-                                        &old_session, NULL));
-    if(incache && (old_session != session)) {
-      infof(data, "old SSL session ID is stale, removing");
-      Curl_ssl_delsessionid(data, old_session);
-      incache = FALSE;
-    }
-
-    if(!incache) {
-      added = TRUE;
-      Curl_ssl_addsessionid(cf, data, peer, session, 0, ossl_session_free);
-    }
+    result = Curl_ssl_set_sessionid(cf, data, peer, session, 0,
+                                    ossl_session_free);
+    session = NULL; /* call has taken ownership */
     Curl_ssl_sessionid_unlock(data);
   }
 
 out:
-  if(!added)
+  if(session)
     ossl_session_free(session, 0);
-  return CURLE_OK;
+  return result;
 }
 
 /* The "new session" callback must return zero if the session can be removed
@@ -3017,7 +2930,7 @@ static CURLcode load_cacert_from_memory(X509_STORE *store,
 
   /* add each entry from PEM file to x509_store */
   for(i = 0; i < (int)sk_X509_INFO_num(inf); ++i) {
-    itmp = sk_X509_INFO_value(inf, i);
+    itmp = sk_X509_INFO_value(inf, (ossl_valsize_t)i);
     if(itmp->x509) {
       if(X509_STORE_add_cert(store, itmp->x509)) {
         ++count;
@@ -3043,7 +2956,7 @@ static CURLcode load_cacert_from_memory(X509_STORE *store,
   sk_X509_INFO_pop_free(inf, X509_INFO_free);
   BIO_free(cbio);
 
-  /* if we didn't end up importing anything, treat that as an error */
+  /* if we did not end up importing anything, treat that as an error */
   return (count > 0) ? CURLE_OK : CURLE_SSL_CACERT_BADFILE;
 }
 
@@ -3164,7 +3077,7 @@ static CURLcode import_windows_cert_store(struct Curl_easy *data,
       else
         continue;
 
-      x509 = d2i_X509(NULL, &encoded_cert, pContext->cbCertEncoded);
+      x509 = d2i_X509(NULL, &encoded_cert, (long)pContext->cbCertEncoded);
       if(!x509)
         continue;
 
@@ -3302,8 +3215,8 @@ static CURLcode populate_x509_store(struct Curl_cfilter *cf,
 #ifdef CURL_CA_FALLBACK
     if(!ssl_cafile && !ssl_capath &&
        !imported_native_ca && !imported_ca_info_blob) {
-      /* verifying the peer without any CA certificates won't
-         work so use openssl's built-in default as fallback */
+      /* verifying the peer without any CA certificates will not
+         work so use OpenSSL's built-in default as fallback */
       X509_STORE_set_default_paths(store);
     }
 #endif
@@ -3328,10 +3241,11 @@ static CURLcode populate_x509_store(struct Curl_cfilter *cf,
 
   if(verifypeer) {
     /* Try building a chain using issuers in the trusted store first to avoid
-       problems with server-sent legacy intermediates.  Newer versions of
+       problems with server-sent legacy intermediates. Newer versions of
        OpenSSL do alternate chain checking by default but we do not know how to
        determine that in a reliable manner.
-       https://rt.openssl.org/Ticket/Display.html?id=3621&user=guest&pass=guest
+       https://web.archive.org/web/20190422050538/
+       rt.openssl.org/Ticket/Display.html?id=3621
     */
 #if defined(X509_V_FLAG_TRUSTED_FIRST)
     X509_STORE_set_flags(store, X509_V_FLAG_TRUSTED_FIRST);
@@ -3355,23 +3269,49 @@ static CURLcode populate_x509_store(struct Curl_cfilter *cf,
 }
 
 #if defined(HAVE_SSL_X509_STORE_SHARE)
-static bool cached_x509_store_expired(const struct Curl_easy *data,
-                                      const struct multi_ssl_backend_data *mb)
+
+/* key to use at `multi->proto_hash` */
+#define MPROTO_OSSL_X509_KEY   "tls:ossl:x509:share"
+
+struct ossl_x509_share {
+  char *CAfile;         /* CAfile path used to generate X509 store */
+  X509_STORE *store;    /* cached X509 store or NULL if none */
+  struct curltime time; /* when the cached store was created */
+};
+
+static void oss_x509_share_free(void *key, size_t key_len, void *p)
 {
-  const struct ssl_general_config *cfg = &data->set.general_ssl;
-  struct curltime now = Curl_now();
-  timediff_t elapsed_ms = Curl_timediff(now, mb->time);
-  timediff_t timeout_ms = cfg->ca_cache_timeout * (timediff_t)1000;
+  struct ossl_x509_share *share = p;
+  DEBUGASSERT(key_len == (sizeof(MPROTO_OSSL_X509_KEY)-1));
+  DEBUGASSERT(!memcmp(MPROTO_OSSL_X509_KEY, key, key_len));
+  (void)key;
+  (void)key_len;
+  if(share->store) {
+    X509_STORE_free(share->store);
+  }
+  free(share->CAfile);
+  free(share);
+}
 
-  if(timeout_ms < 0)
-    return false;
+static bool
+cached_x509_store_expired(const struct Curl_easy *data,
+                          const struct ossl_x509_share *mb)
+{
+  const struct ssl_general_config *cfg = &data->set.general_ssl;
+  if(cfg->ca_cache_timeout < 0)
+    return FALSE;
+  else {
+    struct curltime now = Curl_now();
+    timediff_t elapsed_ms = Curl_timediff(now, mb->time);
+    timediff_t timeout_ms = cfg->ca_cache_timeout * (timediff_t)1000;
 
-  return elapsed_ms >= timeout_ms;
+    return elapsed_ms >= timeout_ms;
+  }
 }
 
-static bool cached_x509_store_different(
-  struct Curl_cfilter *cf,
-  const struct multi_ssl_backend_data *mb)
+static bool
+cached_x509_store_different(struct Curl_cfilter *cf,
+                            const struct ossl_x509_share *mb)
 {
   struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
   if(!mb->CAfile || !conn_config->CAfile)
@@ -3384,15 +3324,17 @@ static X509_STORE *get_cached_x509_store(struct Curl_cfilter *cf,
                                          const struct Curl_easy *data)
 {
   struct Curl_multi *multi = data->multi;
+  struct ossl_x509_share *share;
   X509_STORE *store = NULL;
 
   DEBUGASSERT(multi);
-  if(multi &&
-     multi->ssl_backend_data &&
-     multi->ssl_backend_data->store &&
-     !cached_x509_store_expired(data, multi->ssl_backend_data) &&
-     !cached_x509_store_different(cf, multi->ssl_backend_data)) {
-    store = multi->ssl_backend_data->store;
+  share = multi? Curl_hash_pick(&multi->proto_hash,
+                                (void *)MPROTO_OSSL_X509_KEY,
+                                sizeof(MPROTO_OSSL_X509_KEY)-1) : NULL;
+  if(share && share->store &&
+     !cached_x509_store_expired(data, share) &&
+     !cached_x509_store_different(cf, share)) {
+    store = share->store;
   }
 
   return store;
@@ -3404,20 +3346,28 @@ static void set_cached_x509_store(struct Curl_cfilter *cf,
 {
   struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
   struct Curl_multi *multi = data->multi;
-  struct multi_ssl_backend_data *mbackend;
+  struct ossl_x509_share *share;
 
   DEBUGASSERT(multi);
   if(!multi)
     return;
+  share = Curl_hash_pick(&multi->proto_hash,
+                         (void *)MPROTO_OSSL_X509_KEY,
+                         sizeof(MPROTO_OSSL_X509_KEY)-1);
 
-  if(!multi->ssl_backend_data) {
-    multi->ssl_backend_data = calloc(1, sizeof(struct multi_ssl_backend_data));
-    if(!multi->ssl_backend_data)
+  if(!share) {
+    share = calloc(1, sizeof(*share));
+    if(!share)
       return;
+    if(!Curl_hash_add2(&multi->proto_hash,
+                       (void *)MPROTO_OSSL_X509_KEY,
+                       sizeof(MPROTO_OSSL_X509_KEY)-1,
+                       share, oss_x509_share_free)) {
+      free(share);
+      return;
+    }
   }
 
-  mbackend = multi->ssl_backend_data;
-
   if(X509_STORE_up_ref(store)) {
     char *CAfile = NULL;
 
@@ -3429,14 +3379,14 @@ static void set_cached_x509_store(struct Curl_cfilter *cf,
       }
     }
 
-    if(mbackend->store) {
-      X509_STORE_free(mbackend->store);
-      free(mbackend->CAfile);
+    if(share->store) {
+      X509_STORE_free(share->store);
+      free(share->CAfile);
     }
 
-    mbackend->time = Curl_now();
-    mbackend->store = store;
-    mbackend->CAfile = CAfile;
+    share->time = Curl_now();
+    share->store = store;
+    share->CAfile = CAfile;
   }
 }
 
@@ -3451,7 +3401,7 @@ CURLcode Curl_ssl_setup_x509_store(struct Curl_cfilter *cf,
   bool cache_criteria_met;
 
   /* Consider the X509 store cacheable if it comes exclusively from a CAfile,
-     or no source is provided and we are falling back to openssl's built-in
+     or no source is provided and we are falling back to OpenSSL's built-in
      default. */
   cache_criteria_met = (data->set.general_ssl.ca_cache_timeout != 0) &&
     conn_config->verifypeer &&
@@ -3504,15 +3454,12 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
   void *ssl_sessionid = NULL;
   struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
   struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);
-  const long int ssl_version = conn_config->version;
+  const long int ssl_version_min = conn_config->version;
   char * const ssl_cert = ssl_config->primary.clientcert;
   const struct curl_blob *ssl_cert_blob = ssl_config->primary.cert_blob;
   const char * const ssl_cert_type = ssl_config->cert_type;
   const bool verifypeer = conn_config->verifypeer;
   char error_buffer[256];
-#ifdef USE_ECH
-  struct ssl_connect_data *connssl = cf->ctx;
-#endif
 
   /* Make funny stuff to get random input */
   result = ossl_seed(data);
@@ -3523,8 +3470,8 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
 
   switch(transport) {
   case TRNSPRT_TCP:
-    /* check to see if we've been told to use an explicit SSL/TLS version */
-    switch(ssl_version) {
+    /* check to see if we have been told to use an explicit SSL/TLS version */
+    switch(ssl_version_min) {
     case CURL_SSLVERSION_DEFAULT:
     case CURL_SSLVERSION_TLSv1:
     case CURL_SSLVERSION_TLSv1_0:
@@ -3550,11 +3497,12 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
     }
     break;
   case TRNSPRT_QUIC:
-    if((ssl_version != CURL_SSLVERSION_DEFAULT) &&
-       (ssl_version < CURL_SSLVERSION_TLSv1_3)) {
+    if(conn_config->version_max &&
+       (conn_config->version_max != CURL_SSLVERSION_MAX_TLSv1_3)) {
       failf(data, "QUIC needs at least TLS version 1.3");
       return CURLE_SSL_CONNECT_ERROR;
-     }
+    }
+
 #ifdef USE_OPENSSL_QUIC
     req_method = OSSL_QUIC_client_method();
 #elif (OPENSSL_VERSION_NUMBER >= 0x10100000L)
@@ -3573,7 +3521,7 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
   octx->ssl_ctx = SSL_CTX_new(req_method);
 
   if(!octx->ssl_ctx) {
-    failf(data, "SSL: couldn't create a context: %s",
+    failf(data, "SSL: could not create a context: %s",
           ossl_strerror(ERR_peek_error(), error_buffer, sizeof(error_buffer)));
     return CURLE_OUT_OF_MEMORY;
   }
@@ -3594,12 +3542,12 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
 
   /* OpenSSL contains code to work around lots of bugs and flaws in various
      SSL-implementations. SSL_CTX_set_options() is used to enabled those
-     work-arounds. The man page for this option states that SSL_OP_ALL enables
+     work-arounds. The manpage for this option states that SSL_OP_ALL enables
      all the work-arounds and that "It is usually safe to use SSL_OP_ALL to
      enable the bug workaround options if compatibility with somewhat broken
      implementations is desired."
 
-     The "-no_ticket" option was introduced in OpenSSL 0.9.8j. It's a flag to
+     The "-no_ticket" option was introduced in OpenSSL 0.9.8j. it is a flag to
      disable "rfc4507bis session ticket support". rfc4507bis was later turned
      into the proper RFC5077: https://datatracker.ietf.org/doc/html/rfc5077
 
@@ -3620,12 +3568,12 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
      CVE-2010-4180 when using previous OpenSSL versions we no longer enable
      this option regardless of OpenSSL version and SSL_OP_ALL definition.
 
-     OpenSSL added a work-around for a SSL 3.0/TLS 1.0 CBC vulnerability
-     (https://www.openssl.org/~bodo/tls-cbc.txt). In 0.9.6e they added a bit to
-     SSL_OP_ALL that _disables_ that work-around despite the fact that
-     SSL_OP_ALL is documented to do "rather harmless" workarounds. In order to
-     keep the secure work-around, the SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS bit
-     must not be set.
+     OpenSSL added a work-around for a SSL 3.0/TLS 1.0 CBC vulnerability:
+     https://web.archive.org/web/20240114184648/openssl.org/~bodo/tls-cbc.txt.
+     In 0.9.6e they added a bit to SSL_OP_ALL that _disables_ that work-around
+     despite the fact that SSL_OP_ALL is documented to do "rather harmless"
+     workarounds. In order to keep the secure work-around, the
+     SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS bit must not be set.
   */
 
   ctx_options = SSL_OP_ALL;
@@ -3640,17 +3588,17 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
 
 #ifdef SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
   /* mitigate CVE-2010-4180 */
-  ctx_options &= ~SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;
+  ctx_options &= ~(ctx_option_t)SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;
 #endif
 
 #ifdef SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
   /* unless the user explicitly asks to allow the protocol vulnerability we
      use the work-around */
   if(!ssl_config->enable_beast)
-    ctx_options &= ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;
+    ctx_options &= ~(ctx_option_t)SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;
 #endif
 
-  switch(ssl_version) {
+  switch(ssl_version_min) {
   case CURL_SSLVERSION_SSLv2:
   case CURL_SSLVERSION_SSLv3:
     return CURLE_NOT_BUILT_IN;
@@ -3752,7 +3700,7 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
     infof(data, "Using TLS-SRP username: %s", ssl_username);
 
     if(!SSL_CTX_set_srp_username(octx->ssl_ctx, ssl_username)) {
-      failf(data, "Unable to set SRP user name");
+      failf(data, "Unable to set SRP username");
       return CURLE_BAD_FUNCTION_ARGUMENT;
     }
     if(!SSL_CTX_set_srp_password(octx->ssl_ctx, ssl_password)) {
@@ -3785,7 +3733,7 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
 #endif
 
   if(cb_new_session) {
-    /* Enable the session cache because it's a prerequisite for the
+    /* Enable the session cache because it is a prerequisite for the
      * "new session" callback. Use the "external storage" mode to prevent
      * OpenSSL from creating an internal session cache.
      */
@@ -3821,7 +3769,7 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
     SSL_free(octx->ssl);
   octx->ssl = SSL_new(octx->ssl_ctx);
   if(!octx->ssl) {
-    failf(data, "SSL: couldn't create a context (handle)");
+    failf(data, "SSL: could not create a context (handle)");
     return CURLE_OUT_OF_MEMORY;
   }
 
@@ -3876,7 +3824,7 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
       ech_config_len = 2 * strlen(b64);
       result = Curl_base64_decode(b64, &ech_config, &ech_config_len);
       if(result || !ech_config) {
-        infof(data, "ECH: can't base64 decode ECHConfig from command line");
+        infof(data, "ECH: cannot base64 decode ECHConfig from command line");
         if(data->set.tls_ech & CURLECH_HARD)
           return result;
       }
@@ -3910,7 +3858,8 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
     else {
       struct Curl_dns_entry *dns = NULL;
 
-      dns = Curl_fetch_addr(data, connssl->peer.hostname, connssl->peer.port);
+      if(peer->hostname)
+        dns = Curl_fetch_addr(data, peer->hostname, peer->port);
       if(!dns) {
         infof(data, "ECH: requested but no DNS info available");
         if(data->set.tls_ech & CURLECH_HARD)
@@ -3940,7 +3889,7 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
 # endif
           else {
             trying_ech_now = 1;
-            infof(data, "ECH: imported ECHConfigList of length %ld", elen);
+            infof(data, "ECH: imported ECHConfigList of length %zu", elen);
           }
         }
         else {
@@ -3953,15 +3902,15 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
     }
 # ifdef OPENSSL_IS_BORINGSSL
     if(trying_ech_now && outername) {
-      infof(data, "ECH: setting public_name not supported with boringssl");
+      infof(data, "ECH: setting public_name not supported with BoringSSL");
       return CURLE_SSL_CONNECT_ERROR;
     }
 # else
     if(trying_ech_now && outername) {
       infof(data, "ECH: inner: '%s', outer: '%s'",
-            connssl->peer.hostname, outername);
+            peer->hostname ? peer->hostname : "NULL", outername);
       result = SSL_ech_set_server_names(octx->ssl,
-                                        connssl->peer.hostname, outername,
+                                        peer->hostname, outername,
                                         0 /* do send outer */);
       if(result != 1) {
         infof(data, "ECH: rv failed to set server name(s) %d [ERROR]", result);
@@ -3971,7 +3920,7 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
 # endif  /* not BORING */
     if(trying_ech_now
        && SSL_set_min_proto_version(octx->ssl, TLS1_3_VERSION) != 1) {
-      infof(data, "ECH: Can't force TLSv1.3 [ERROR]");
+      infof(data, "ECH: cannot force TLSv1.3 [ERROR]");
       return CURLE_SSL_CONNECT_ERROR;
     }
   }
@@ -3980,7 +3929,7 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
 #endif
 
   octx->reused_session = FALSE;
-  if(ssl_config->primary.sessionid && transport == TRNSPRT_TCP) {
+  if(ssl_config->primary.cache_session && transport == TRNSPRT_TCP) {
     Curl_ssl_sessionid_lock(data);
     if(!Curl_ssl_getsessionid(cf, data, peer, &ssl_sessionid, NULL)) {
       /* we got a session id, use it! */
@@ -4041,7 +3990,7 @@ static CURLcode ossl_connect_step1(struct Curl_cfilter *cf,
   /* with OpenSSL v1.1.1 we get an alternative to SSL_set_bio() that works
    * without backward compat quirks. Every call takes one reference, so we
    * up it and pass. SSL* then owns it and will free.
-   * We check on the function in configure, since libressl and friends
+   * We check on the function in configure, since LibreSSL and friends
    * each have their own versions to add support for this. */
   BIO_up_ref(bio);
   SSL_set0_rbio(octx->ssl, bio);
@@ -4131,11 +4080,10 @@ static CURLcode ossl_connect_step2(struct Curl_cfilter *cf,
   struct ssl_connect_data *connssl = cf->ctx;
   struct ossl_ctx *octx = (struct ossl_ctx *)connssl->backend;
   struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);
-  DEBUGASSERT(ssl_connect_2 == connssl->connecting_state
-              || ssl_connect_2_reading == connssl->connecting_state
-              || ssl_connect_2_writing == connssl->connecting_state);
+  DEBUGASSERT(ssl_connect_2 == connssl->connecting_state);
   DEBUGASSERT(octx);
 
+  connssl->io_need = CURL_SSL_IO_NEED_NONE;
   ERR_clear_error();
 
   err = SSL_connect(octx->ssl);
@@ -4150,14 +4098,11 @@ static CURLcode ossl_connect_step2(struct Curl_cfilter *cf,
   }
 
 #ifndef HAVE_KEYLOG_CALLBACK
-  if(Curl_tls_keylog_enabled()) {
-    /* If key logging is enabled, wait for the handshake to complete and then
-     * proceed with logging secrets (for TLS 1.2 or older).
-     */
-    bool done = FALSE;
-    ossl_log_tls12_secret(octx->ssl, &done);
-    octx->keylog_done = done;
-  }
+  /* If key logging is enabled, wait for the handshake to complete and then
+   * proceed with logging secrets (for TLS 1.2 or older).
+   */
+  if(Curl_tls_keylog_enabled() && !octx->keylog_done)
+    ossl_log_tls12_secret(octx->ssl, &octx->keylog_done);
 #endif
 
   /* 1  is fine
@@ -4167,11 +4112,11 @@ static CURLcode ossl_connect_step2(struct Curl_cfilter *cf,
     int detail = SSL_get_error(octx->ssl, err);
 
     if(SSL_ERROR_WANT_READ == detail) {
-      connssl->connecting_state = ssl_connect_2_reading;
+      connssl->io_need = CURL_SSL_IO_NEED_RECV;
       return CURLE_OK;
     }
     if(SSL_ERROR_WANT_WRITE == detail) {
-      connssl->connecting_state = ssl_connect_2_writing;
+      connssl->io_need = CURL_SSL_IO_NEED_SEND;
       return CURLE_OK;
     }
 #ifdef SSL_ERROR_WANT_ASYNC
@@ -4198,7 +4143,7 @@ static CURLcode ossl_connect_step2(struct Curl_cfilter *cf,
       int lib;
       int reason;
 
-      /* the connection failed, we're not waiting for anything else. */
+      /* the connection failed, we are not waiting for anything else. */
       connssl->connecting_state = ssl_connect_2;
 
       /* Get the earliest error code from the thread's error queue and remove
@@ -4259,7 +4204,7 @@ static CURLcode ossl_connect_step2(struct Curl_cfilter *cf,
 
       /* detail is already set to the SSL error above */
 
-      /* If we e.g. use SSLv2 request-method and the server doesn't like us
+      /* If we e.g. use SSLv2 request-method and the server does not like us
        * (RST connection, etc.), OpenSSL gives no explanation whatsoever and
        * the SO_ERROR is also lost.
        */
@@ -4285,7 +4230,7 @@ static CURLcode ossl_connect_step2(struct Curl_cfilter *cf,
     int psigtype_nid = NID_undef;
     const char *negotiated_group_name = NULL;
 
-    /* we connected fine, we're not waiting for anything else. */
+    /* we connected fine, we are not waiting for anything else. */
     connssl->connecting_state = ssl_connect_3;
 
 #if (OPENSSL_VERSION_NUMBER >= 0x30000000L)
@@ -4398,7 +4343,7 @@ static CURLcode ossl_pkp_pin_peer_pubkey(struct Curl_easy *data, X509* cert,
   /* Result is returned to caller */
   CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;
 
-  /* if a path wasn't specified, don't pin */
+  /* if a path was not specified, do not pin */
   if(!pinnedpubkey)
     return CURLE_OK;
 
@@ -4419,12 +4364,12 @@ static CURLcode ossl_pkp_pin_peer_pubkey(struct Curl_easy *data, X509* cert,
     if(!buff1)
       break; /* failed */
 
-    /* https://www.openssl.org/docs/crypto/d2i_X509.html */
+    /* https://docs.openssl.org/master/man3/d2i_X509/ */
     len2 = i2d_X509_PUBKEY(X509_get_X509_PUBKEY(cert), &temp);
 
     /*
      * These checks are verifying we got back the same values as when we
-     * sized the buffer. It's pretty weak since they should always be the
+     * sized the buffer. it is pretty weak since they should always be the
      * same. But it gives us something to test.
      */
     if((len1 != len2) || !temp || ((temp - buff1) != len1))
@@ -4551,7 +4496,7 @@ CURLcode Curl_oss_check_peer_cert(struct Curl_cfilter *cf,
     if(!strict)
       return CURLE_OK;
 
-    failf(data, "SSL: couldn't get peer certificate");
+    failf(data, "SSL: could not get peer certificate");
     return CURLE_PEER_FAILED_VERIFICATION;
   }
 
@@ -4592,7 +4537,7 @@ CURLcode Curl_oss_check_peer_cert(struct Curl_cfilter *cf,
                          buffer, sizeof(buffer));
   if(rc) {
     if(strict)
-      failf(data, "SSL: couldn't get X509-issuer name");
+      failf(data, "SSL: could not get X509-issuer name");
     result = CURLE_PEER_FAILED_VERIFICATION;
   }
   else {
@@ -4695,8 +4640,8 @@ CURLcode Curl_oss_check_peer_cert(struct Curl_cfilter *cf,
 #if (OPENSSL_VERSION_NUMBER >= 0x0090808fL) && !defined(OPENSSL_NO_TLSEXT) && \
   !defined(OPENSSL_NO_OCSP)
   if(conn_config->verifystatus && !octx->reused_session) {
-    /* don't do this after Session ID reuse */
-    result = verifystatus(cf, data);
+    /* do not do this after Session ID reuse */
+    result = verifystatus(cf, data, octx);
     if(result) {
       /* when verifystatus failed, remove the session id from the cache again
          if present */
@@ -4721,7 +4666,7 @@ CURLcode Curl_oss_check_peer_cert(struct Curl_cfilter *cf,
 #endif
 
   if(!strict)
-    /* when not strict, we don't bother about the verify cert problems */
+    /* when not strict, we do not bother about the verify cert problems */
     result = CURLE_OK;
 
 #ifndef CURL_DISABLE_PROXY
@@ -4754,7 +4699,7 @@ static CURLcode ossl_connect_step3(struct Curl_cfilter *cf,
 
   /*
    * We check certificates to authenticate the server; otherwise we risk
-   * man-in-the-middle attack; NEVERTHELESS, if we're told explicitly not to
+   * man-in-the-middle attack; NEVERTHELESS, if we are told explicitly not to
    * verify the peer, ignore faults and failures from the server cert
    * operations.
    */
@@ -4783,7 +4728,7 @@ static CURLcode ossl_connect_common(struct Curl_cfilter *cf,
   }
 
   if(ssl_connect_1 == connssl->connecting_state) {
-    /* Find out how much more time we're allowed */
+    /* Find out how much more time we are allowed */
     const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);
 
     if(timeout_ms < 0) {
@@ -4797,9 +4742,7 @@ static CURLcode ossl_connect_common(struct Curl_cfilter *cf,
       goto out;
   }
 
-  while(ssl_connect_2 == connssl->connecting_state ||
-        ssl_connect_2_reading == connssl->connecting_state ||
-        ssl_connect_2_writing == connssl->connecting_state) {
+  while(ssl_connect_2 == connssl->connecting_state) {
 
     /* check allowed time left */
     const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);
@@ -4811,15 +4754,13 @@ static CURLcode ossl_connect_common(struct Curl_cfilter *cf,
       goto out;
     }
 
-    /* if ssl is expecting something, check if it's available. */
-    if(!nonblocking &&
-       (connssl->connecting_state == ssl_connect_2_reading ||
-        connssl->connecting_state == ssl_connect_2_writing)) {
+    /* if ssl is expecting something, check if it is available. */
+    if(!nonblocking && connssl->io_need) {
 
-      curl_socket_t writefd = ssl_connect_2_writing ==
-        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;
-      curl_socket_t readfd = ssl_connect_2_reading ==
-        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;
+      curl_socket_t writefd = (connssl->io_need & CURL_SSL_IO_NEED_SEND)?
+                              sockfd:CURL_SOCKET_BAD;
+      curl_socket_t readfd = (connssl->io_need & CURL_SSL_IO_NEED_RECV)?
+                             sockfd:CURL_SOCKET_BAD;
 
       what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,
                                timeout_ms);
@@ -4845,10 +4786,7 @@ static CURLcode ossl_connect_common(struct Curl_cfilter *cf,
      * or epoll() will always have a valid fdset to wait on.
      */
     result = ossl_connect_step2(cf, data);
-    if(result || (nonblocking &&
-                  (ssl_connect_2 == connssl->connecting_state ||
-                   ssl_connect_2_reading == connssl->connecting_state ||
-                   ssl_connect_2_writing == connssl->connecting_state)))
+    if(result || (nonblocking && (ssl_connect_2 == connssl->connecting_state)))
       goto out;
 
   } /* repeat step2 until all transactions are done. */
@@ -5031,14 +4969,14 @@ static ssize_t ossl_recv(struct Curl_cfilter *cf,
       break;
     case SSL_ERROR_WANT_READ:
     case SSL_ERROR_WANT_WRITE:
-      /* there's data pending, re-invoke SSL_read() */
+      /* there is data pending, re-invoke SSL_read() */
       *curlcode = CURLE_AGAIN;
       nread = -1;
       goto out;
     default:
       /* openssl/ssl.h for SSL_ERROR_SYSCALL says "look at error stack/return
          value/errno" */
-      /* https://www.openssl.org/docs/crypto/ERR_get_error.html */
+      /* https://docs.openssl.org/master/man3/ERR_get_error/ */
       if(octx->io_result == CURLE_AGAIN) {
         *curlcode = CURLE_AGAIN;
         nread = -1;
@@ -5065,7 +5003,7 @@ static ssize_t ossl_recv(struct Curl_cfilter *cf,
       /* For debug builds be a little stricter and error on any
          SSL_ERROR_SYSCALL. For example a server may have closed the connection
          abruptly without a close_notify alert. For compatibility with older
-         peers we don't do this by default. #4624
+         peers we do not do this by default. #4624
 
          We can use this to gauge how many users may be affected, and
          if it goes ok eventually transition to allow in dev and release with
@@ -5099,7 +5037,7 @@ static size_t ossl_version(char *buffer, size_t size)
 #ifdef LIBRESSL_VERSION_NUMBER
 #ifdef HAVE_OPENSSL_VERSION
   char *p;
-  int count;
+  size_t count;
   const char *ver = OpenSSL_version(OPENSSL_VERSION);
   const char expected[] = OSSL_PACKAGE " "; /* ie "LibreSSL " */
   if(strncasecompare(ver, expected, sizeof(expected) - 1)) {
@@ -5181,14 +5119,14 @@ static CURLcode ossl_random(struct Curl_easy *data,
   int rc;
   if(data) {
     if(ossl_seed(data)) /* Initiate the seed if not already done */
-      return CURLE_FAILED_INIT; /* couldn't seed for some reason */
+      return CURLE_FAILED_INIT; /* could not seed for some reason */
   }
   else {
     if(!rand_enough())
       return CURLE_FAILED_INIT;
   }
   /* RAND_bytes() returns 1 on success, 0 otherwise.  */
-  rc = RAND_bytes(entropy, curlx_uztosi(length));
+  rc = RAND_bytes(entropy, (ossl_valsize_t)curlx_uztosi(length));
   return (rc == 1 ? CURLE_OK : CURLE_FAILED_INIT);
 }
 
@@ -5236,20 +5174,6 @@ static void *ossl_get_internals(struct ssl_connect_data *connssl,
     (void *)octx->ssl_ctx : (void *)octx->ssl;
 }
 
-static void ossl_free_multi_ssl_backend_data(
-  struct multi_ssl_backend_data *mbackend)
-{
-#if defined(HAVE_SSL_X509_STORE_SHARE)
-  if(mbackend->store) {
-    X509_STORE_free(mbackend->store);
-  }
-  free(mbackend->CAfile);
-  free(mbackend);
-#else /* HAVE_SSL_X509_STORE_SHARE */
-  (void)mbackend;
-#endif /* HAVE_SSL_X509_STORE_SHARE */
-}
-
 const struct Curl_ssl Curl_ssl_openssl = {
   { CURLSSLBACKEND_OPENSSL, "openssl" }, /* info */
 
@@ -5264,6 +5188,7 @@ const struct Curl_ssl Curl_ssl_openssl = {
 #ifdef USE_ECH
   SSLSUPP_ECH |
 #endif
+  SSLSUPP_CA_CACHE |
   SSLSUPP_HTTPS_PROXY,
 
   sizeof(struct ossl_ctx),
@@ -5293,7 +5218,6 @@ const struct Curl_ssl Curl_ssl_openssl = {
 #endif
   NULL,                     /* use of data in this connection */
   NULL,                     /* remote of data from this connection */
-  ossl_free_multi_ssl_backend_data, /* free_multi_ssl_backend_data */
   ossl_recv,                /* recv decrypted data */
   ossl_send,                /* send data to encrypt */
 };
diff --git a/lib/vtls/openssl.h b/lib/vtls/openssl.h
index 55e06bda4..b0d78478a 100644
--- a/lib/vtls/openssl.h
+++ b/lib/vtls/openssl.h
@@ -45,8 +45,9 @@ struct ossl_ctx {
   BIO_METHOD *bio_method;
   CURLcode io_result;       /* result of last BIO cfilter operation */
 #ifndef HAVE_KEYLOG_CALLBACK
-  /* Set to true once a valid keylog entry has been created to avoid dupes. */
-  BIT(keylog_done);
+  /* Set to true once a valid keylog entry has been created to avoid dupes.
+     This is a bool and not a bitfield because it is passed by address. */
+  bool keylog_done;
 #endif
   BIT(x509_store_setup);            /* x509 store has been set up */
   BIT(reused_session);              /* session-ID was reused for this */
diff --git a/lib/vtls/rustls.c b/lib/vtls/rustls.c
index 8b6588a37..bdcd08ab9 100644
--- a/lib/vtls/rustls.c
+++ b/lib/vtls/rustls.c
@@ -48,6 +48,7 @@ struct rustls_ssl_backend_data
   struct rustls_connection *conn;
   size_t plain_out_buffered;
   BIT(data_in_pending);
+  BIT(sent_shutdown);
 };
 
 /* For a given rustls_result error code, return the best-matching CURLcode. */
@@ -101,7 +102,7 @@ read_cb(void *userdata, uint8_t *buf, uintptr_t len, uintptr_t *out_n)
   }
   else if(nread == 0)
     connssl->peer_closed = TRUE;
-  *out_n = (int)nread;
+  *out_n = (uintptr_t)nread;
   CURL_TRC_CF(io_ctx->data, io_ctx->cf, "cf->next recv(len=%zu) -> %zd, %d",
               len, nread, result);
   return ret;
@@ -122,7 +123,7 @@ write_cb(void *userdata, const uint8_t *buf, uintptr_t len, uintptr_t *out_n)
     else
       ret = EINVAL;
   }
-  *out_n = (int)nwritten;
+  *out_n = (uintptr_t)nwritten;
   CURL_TRC_CF(io_ctx->data, io_ctx->cf, "cf->next send(len=%zu) -> %zd, %d",
               len, nwritten, result);
   return ret;
@@ -178,10 +179,10 @@ static ssize_t tls_recv_more(struct Curl_cfilter *cf,
  *  - Read out as many plaintext bytes from rustls as possible, until hitting
  *    error, EOF, or EAGAIN/EWOULDBLOCK, or plainbuf/plainlen is filled up.
  *
- * It's okay to call this function with plainbuf == NULL and plainlen == 0.
- * In that case, it will copy bytes from the socket into rustls' TLS input
- * buffer, and process packets, but won't consume bytes from rustls' plaintext
- * output buffer.
+ * it is okay to call this function with plainbuf == NULL and plainlen == 0. In
+ * that case, it will copy bytes from the socket into rustls' TLS input
+ * buffer, and process packets, but will not consume bytes from rustls'
+ * plaintext output buffer.
  */
 static ssize_t
 cr_recv(struct Curl_cfilter *cf, struct Curl_easy *data,
@@ -226,7 +227,7 @@ cr_recv(struct Curl_cfilter *cf, struct Curl_easy *data,
       goto out;
     }
     else if(rresult != RUSTLS_RESULT_OK) {
-      /* n always equals 0 in this case, don't need to check it */
+      /* n always equals 0 in this case, do not need to check it */
       char errorbuf[255];
       size_t errorlen;
       rustls_error(rresult, errorbuf, sizeof(errorbuf), &errorlen);
@@ -308,8 +309,8 @@ static CURLcode cr_flush_out(struct Curl_cfilter *cf, struct Curl_easy *data,
  *  - Fully drain rustls' plaintext output buffer into the socket until
  *    we get either an error or EAGAIN/EWOULDBLOCK.
  *
- * It's okay to call this function with plainbuf == NULL and plainlen == 0.
- * In that case, it won't read anything into rustls' plaintext input buffer.
+ * it is okay to call this function with plainbuf == NULL and plainlen == 0.
+ * In that case, it will not read anything into rustls' plaintext input buffer.
  * It will only drain rustls' plaintext output buffer into the socket.
  */
 static ssize_t
@@ -438,7 +439,7 @@ cr_init_backend(struct Curl_cfilter *cf, struct Curl_easy *data,
   const char *hostname = connssl->peer.hostname;
   char errorbuf[256];
   size_t errorlen;
-  int result;
+  rustls_result result;
 
   DEBUGASSERT(backend);
   rconn = backend->conn;
@@ -461,7 +462,7 @@ cr_init_backend(struct Curl_cfilter *cf, struct Curl_easy *data,
   if(!verifypeer) {
     rustls_client_config_builder_dangerous_set_certificate_verifier(
       config_builder, cr_verify_none);
-    /* rustls doesn't support IP addresses (as of 0.19.0), and will reject
+    /* rustls does not support IP addresses (as of 0.19.0), and will reject
      * connections created with an IP address, even when certificate
      * verification is turned off. Set a placeholder hostname and disable
      * SNI. */
@@ -474,7 +475,7 @@ cr_init_backend(struct Curl_cfilter *cf, struct Curl_easy *data,
     roots_builder = rustls_root_cert_store_builder_new();
 
     if(ca_info_blob) {
-      /* Enable strict parsing only if verification isn't disabled. */
+      /* Enable strict parsing only if verification is not disabled. */
       result = rustls_root_cert_store_builder_add_pem(roots_builder,
                                                       ca_info_blob->data,
                                                       ca_info_blob->len,
@@ -488,7 +489,7 @@ cr_init_backend(struct Curl_cfilter *cf, struct Curl_easy *data,
       }
     }
     else if(ssl_cafile) {
-      /* Enable strict parsing only if verification isn't disabled. */
+      /* Enable strict parsing only if verification is not disabled. */
       result = rustls_root_cert_store_builder_load_roots_from_file(
         roots_builder, ssl_cafile, verifypeer);
       if(result != RUSTLS_RESULT_OK) {
@@ -604,6 +605,7 @@ cr_connect_common(struct Curl_cfilter *cf,
     * Connection has been established according to rustls. Set send/recv
     * handlers, and update the state machine.
     */
+    connssl->io_need = CURL_SSL_IO_NEED_NONE;
     if(!rustls_connection_is_handshaking(rconn)) {
       infof(data, "Done handshaking");
       /* rustls claims it is no longer handshaking *before* it has
@@ -613,7 +615,7 @@ cr_connect_common(struct Curl_cfilter *cf,
       cr_set_negotiated_alpn(cf, data, rconn);
       cr_send(cf, data, NULL, 0, &tmperr);
       if(tmperr == CURLE_AGAIN) {
-        connssl->connecting_state = ssl_connect_2_writing;
+        connssl->io_need = CURL_SSL_IO_NEED_SEND;
         return CURLE_OK;
       }
       else if(tmperr != CURLE_OK) {
@@ -625,6 +627,7 @@ cr_connect_common(struct Curl_cfilter *cf,
       return CURLE_OK;
     }
 
+    connssl->connecting_state = ssl_connect_2;
     wants_read = rustls_connection_wants_read(rconn);
     wants_write = rustls_connection_wants_write(rconn) ||
                   backend->plain_out_buffered;
@@ -632,8 +635,6 @@ cr_connect_common(struct Curl_cfilter *cf,
     writefd = wants_write?sockfd:CURL_SOCKET_BAD;
     readfd = wants_read?sockfd:CURL_SOCKET_BAD;
 
-    connssl->connecting_state = wants_write?
-      ssl_connect_2_writing : ssl_connect_2_reading;
     /* check allowed time left */
     timeout_ms = Curl_timeleft(data, NULL, TRUE);
 
@@ -661,6 +662,10 @@ cr_connect_common(struct Curl_cfilter *cf,
       CURL_TRC_CF(data, cf, "Curl_socket_check: %s would block",
             wants_read&&wants_write ? "writing and reading" :
             wants_write ? "writing" : "reading");
+      if(wants_write)
+        connssl->io_need |= CURL_SSL_IO_NEED_SEND;
+      if(wants_read)
+        connssl->io_need |= CURL_SSL_IO_NEED_RECV;
       return CURLE_OK;
     }
     /* socket is readable or writable */
@@ -695,7 +700,7 @@ cr_connect_common(struct Curl_cfilter *cf,
   }
 
   /* We should never fall through the loop. We should return either because
-     the handshake is done or because we can't read/write without blocking. */
+     the handshake is done or because we cannot read/write without blocking. */
   DEBUGASSERT(false);
 }
 
@@ -723,24 +728,85 @@ cr_get_internals(struct ssl_connect_data *connssl,
   return &backend->conn;
 }
 
-static void
-cr_close(struct Curl_cfilter *cf, struct Curl_easy *data)
+static CURLcode
+cr_shutdown(struct Curl_cfilter *cf,
+            struct Curl_easy *data,
+            bool send_shutdown, bool *done)
 {
   struct ssl_connect_data *connssl = cf->ctx;
   struct rustls_ssl_backend_data *backend =
     (struct rustls_ssl_backend_data *)connssl->backend;
-  CURLcode tmperr = CURLE_OK;
-  ssize_t n = 0;
+  CURLcode result = CURLE_OK;
+  ssize_t nwritten, nread;
+  char buf[1024];
+  size_t i;
 
   DEBUGASSERT(backend);
-  if(backend->conn && !connssl->peer_closed) {
-    CURL_TRC_CF(data, cf, "closing connection, send notify");
-    rustls_connection_send_close_notify(backend->conn);
-    n = cr_send(cf, data, NULL, 0, &tmperr);
-    if(n < 0) {
-      failf(data, "rustls: error sending close_notify: %d", tmperr);
+  if(!backend->conn || cf->shutdown) {
+    *done = TRUE;
+    goto out;
+  }
+
+  connssl->io_need = CURL_SSL_IO_NEED_NONE;
+  *done = FALSE;
+
+  if(!backend->sent_shutdown) {
+    /* do this only once */
+    backend->sent_shutdown = TRUE;
+    if(send_shutdown) {
+      rustls_connection_send_close_notify(backend->conn);
     }
+  }
+
+  nwritten = cr_send(cf, data, NULL, 0, &result);
+  if(nwritten < 0) {
+    if(result == CURLE_AGAIN) {
+      connssl->io_need = CURL_SSL_IO_NEED_SEND;
+      result = CURLE_OK;
+      goto out;
+    }
+    DEBUGASSERT(result);
+    CURL_TRC_CF(data, cf, "shutdown send failed: %d", result);
+    goto out;
+  }
+
+  for(i = 0; i < 10; ++i) {
+    nread = cr_recv(cf, data, buf, (int)sizeof(buf), &result);
+    if(nread <= 0)
+      break;
+  }
 
+  if(nread > 0) {
+    /* still data coming in? */
+  }
+  else if(nread == 0) {
+    /* We got the close notify alert and are done. */
+    *done = TRUE;
+  }
+  else if(result == CURLE_AGAIN) {
+    connssl->io_need = CURL_SSL_IO_NEED_RECV;
+    result = CURLE_OK;
+  }
+  else {
+    DEBUGASSERT(result);
+    CURL_TRC_CF(data, cf, "shutdown, error: %d", result);
+  }
+
+out:
+  cf->shutdown = (result || *done);
+  return result;
+}
+
+static void
+cr_close(struct Curl_cfilter *cf, struct Curl_easy *data)
+{
+  struct ssl_connect_data *connssl = cf->ctx;
+  struct rustls_ssl_backend_data *backend =
+    (struct rustls_ssl_backend_data *)connssl->backend;
+
+  (void)data;
+  DEBUGASSERT(backend);
+  if(backend->conn) {
     rustls_connection_free(backend->conn);
     backend->conn = NULL;
   }
@@ -766,7 +832,7 @@ const struct Curl_ssl Curl_ssl_rustls = {
   Curl_none_cleanup,               /* cleanup */
   cr_version,                      /* version */
   Curl_none_check_cxn,             /* check_cxn */
-  Curl_none_shutdown,              /* shutdown */
+  cr_shutdown,                     /* shutdown */
   cr_data_pending,                 /* data_pending */
   Curl_none_random,                /* random */
   Curl_none_cert_status_request,   /* cert_status_request */
@@ -783,7 +849,6 @@ const struct Curl_ssl Curl_ssl_rustls = {
   NULL,                            /* sha256sum */
   NULL,                            /* associate_connection */
   NULL,                            /* disassociate_connection */
-  NULL,                            /* free_multi_ssl_backend_data */
   cr_recv,                         /* recv decrypted data */
   cr_send,                         /* send data to encrypt */
 };
diff --git a/lib/vtls/schannel.c b/lib/vtls/schannel.c
index 19cdc4b20..f9bb2f824 100644
--- a/lib/vtls/schannel.c
+++ b/lib/vtls/schannel.c
@@ -34,7 +34,7 @@
 #ifdef USE_SCHANNEL
 
 #ifndef USE_WINDOWS_SSPI
-#  error "Can't compile SCHANNEL support without SSPI."
+#  error "cannot compile SCHANNEL support without SSPI."
 #endif
 
 #include "schannel.h"
@@ -171,7 +171,7 @@ schannel_set_ssl_version_min_max(DWORD *enabled_protocols,
 {
   struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
   long ssl_version = conn_config->version;
-  long ssl_version_max = conn_config->version_max;
+  long ssl_version_max = (long)conn_config->version_max;
   long i = ssl_version;
 
   switch(ssl_version_max) {
@@ -364,7 +364,7 @@ set_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,
     if(!alg)
       alg = get_alg_id_by_name(startCur);
     if(alg)
-      algIds[algCount++] = alg;
+      algIds[algCount++] = (ALG_ID)alg;
     else if(!strncmp(startCur, "USE_STRONG_CRYPTO",
                      sizeof("USE_STRONG_CRYPTO") - 1) ||
             !strncmp(startCur, "SCH_USE_STRONG_CRYPTO",
@@ -377,7 +377,7 @@ set_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,
       startCur++;
   }
   schannel_cred->palgSupportedAlgs = algIds;
-  schannel_cred->cSupportedAlgs = algCount;
+  schannel_cred->cSupportedAlgs = (DWORD)algCount;
   return CURLE_OK;
 }
 
@@ -513,7 +513,7 @@ schannel_acquire_credential_handle(struct Curl_cfilter *cf,
   }
 
   if(!ssl_config->auto_client_cert) {
-    flags &= ~SCH_CRED_USE_DEFAULT_CREDS;
+    flags &= ~(DWORD)SCH_CRED_USE_DEFAULT_CREDS;
     flags |= SCH_CRED_NO_DEFAULT_CREDS;
     infof(data, "schannel: disabled automatic use of client certificate");
   }
@@ -950,7 +950,7 @@ schannel_acquire_credential_handle(struct Curl_cfilter *cf,
     tls_parameters.pDisabledCrypto = crypto_settings;
 
     /* The number of blocked suites */
-    tls_parameters.cDisabledCrypto = crypto_settings_idx;
+    tls_parameters.cDisabledCrypto = (DWORD)crypto_settings_idx;
     credentials.pTlsParameters = &tls_parameters;
     credentials.cTlsParameters = 1;
 
@@ -976,7 +976,7 @@ schannel_acquire_credential_handle(struct Curl_cfilter *cf,
   }
   else {
     /* Pre-Windows 10 1809 or the user set a legacy algorithm list. Although MS
-       doesn't document it, currently Schannel will not negotiate TLS 1.3 when
+       does not document it, currently Schannel will not negotiate TLS 1.3 when
        SCHANNEL_CRED is used. */
     ALG_ID algIds[NUM_CIPHERS];
     char *ciphers = conn_config->cipher_list;
@@ -1083,7 +1083,7 @@ schannel_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
 
 #ifdef HAS_ALPN
   /* ALPN is only supported on Windows 8.1 / Server 2012 R2 and above.
-     Also it doesn't seem to be supported for Wine, see curl bug #983. */
+     Also it does not seem to be supported for Wine, see curl bug #983. */
   backend->use_alpn = connssl->alpn &&
     !GetProcAddress(GetModuleHandle(TEXT("ntdll")),
                     "wine_get_version") &&
@@ -1095,7 +1095,7 @@ schannel_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
 
 #ifdef _WIN32_WCE
 #ifdef HAS_MANUAL_VERIFY_API
-  /* certificate validation on CE doesn't seem to work right; we'll
+  /* certificate validation on CE does not seem to work right; we will
    * do it following a more manual process. */
   backend->use_manual_cred_validation = true;
 #else
@@ -1127,7 +1127,7 @@ schannel_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
   backend->cred = NULL;
 
   /* check for an existing reusable credential handle */
-  if(ssl_config->primary.sessionid) {
+  if(ssl_config->primary.cache_session) {
     Curl_ssl_sessionid_lock(data);
     if(!Curl_ssl_getsessionid(cf, data, &connssl->peer,
                               (void **)&old_cred, NULL)) {
@@ -1241,7 +1241,7 @@ schannel_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
   /* Schannel InitializeSecurityContext:
      https://msdn.microsoft.com/en-us/library/windows/desktop/aa375924.aspx
 
-     At the moment we don't pass inbuf unless we're using ALPN since we only
+     At the moment we do not pass inbuf unless we are using ALPN since we only
      use it for that, and Wine (for which we currently disable ALPN) is giving
      us problems with inbuf regardless. https://github.com/curl/curl/issues/983
   */
@@ -1332,7 +1332,8 @@ schannel_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)
 
   DEBUGASSERT(backend);
 
-  doread = (connssl->connecting_state != ssl_connect_2_writing) ? TRUE : FALSE;
+  doread = (connssl->io_need & CURL_SSL_IO_NEED_SEND)? FALSE : TRUE;
+  connssl->io_need = CURL_SSL_IO_NEED_NONE;
 
   DEBUGF(infof(data,
                "schannel: SSL/TLS connection with %s port %d (step 2/3)",
@@ -1393,8 +1394,7 @@ schannel_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)
                                backend->encdata_offset,
                                &result);
       if(result == CURLE_AGAIN) {
-        if(connssl->connecting_state != ssl_connect_2_writing)
-          connssl->connecting_state = ssl_connect_2_reading;
+        connssl->io_need = CURL_SSL_IO_NEED_RECV;
         DEBUGF(infof(data, "schannel: failed to receive handshake, "
                      "need more data"));
         return CURLE_OK;
@@ -1448,7 +1448,7 @@ schannel_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)
     /* check if the handshake was incomplete */
     if(sspi_status == SEC_E_INCOMPLETE_MESSAGE) {
       backend->encdata_is_incomplete = true;
-      connssl->connecting_state = ssl_connect_2_reading;
+      connssl->io_need = CURL_SSL_IO_NEED_RECV;
       DEBUGF(infof(data,
                    "schannel: received incomplete message, need more data"));
       return CURLE_OK;
@@ -1460,7 +1460,7 @@ schannel_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)
     if(sspi_status == SEC_I_INCOMPLETE_CREDENTIALS &&
        !(backend->req_flags & ISC_REQ_USE_SUPPLIED_CREDS)) {
       backend->req_flags |= ISC_REQ_USE_SUPPLIED_CREDS;
-      connssl->connecting_state = ssl_connect_2_writing;
+      connssl->io_need = CURL_SSL_IO_NEED_SEND;
       DEBUGF(infof(data,
                    "schannel: a client certificate has been requested"));
       return CURLE_OK;
@@ -1531,7 +1531,7 @@ schannel_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)
                    inbuf[1].cbBuffer));
       /*
         There are two cases where we could be getting extra data here:
-        1) If we're renegotiating a connection and the handshake is already
+        1) If we are renegotiating a connection and the handshake is already
         complete (from the server perspective), it can encrypted app data
         (not handshake data) in an extra buffer at this point.
         2) (sspi_status == SEC_I_CONTINUE_NEEDED) We are negotiating a
@@ -1560,7 +1560,7 @@ schannel_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)
 
   /* check if the handshake needs to be continued */
   if(sspi_status == SEC_I_CONTINUE_NEEDED) {
-    connssl->connecting_state = ssl_connect_2_reading;
+    connssl->io_need = CURL_SSL_IO_NEED_RECV;
     return CURLE_OK;
   }
 
@@ -1593,7 +1593,7 @@ schannel_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)
 #endif
 
   /* Verify the hostname manually when certificate verification is disabled,
-     because in that case Schannel won't verify it. */
+     because in that case Schannel will not verify it. */
   if(!conn_config->verifypeer && conn_config->verifyhost)
     return Curl_verify_host(cf, data);
 
@@ -1772,34 +1772,16 @@ schannel_connect_step3(struct Curl_cfilter *cf, struct Curl_easy *data)
 #endif
 
   /* save the current session data for possible reuse */
-  if(ssl_config->primary.sessionid) {
-    bool incache;
-    struct Curl_schannel_cred *old_cred = NULL;
-
+  if(ssl_config->primary.cache_session) {
     Curl_ssl_sessionid_lock(data);
-    incache = !(Curl_ssl_getsessionid(cf, data, &connssl->peer,
-                                      (void **)&old_cred, NULL));
-    if(incache) {
-      if(old_cred != backend->cred) {
-        DEBUGF(infof(data,
-                     "schannel: old credential handle is stale, removing"));
-        /* we're not taking old_cred ownership here, no refcount++ is needed */
-        Curl_ssl_delsessionid(data, (void *)old_cred);
-        incache = FALSE;
-      }
-    }
-    if(!incache) {
-      /* Up ref count since call takes ownership */
-      backend->cred->refcount++;
-      result = Curl_ssl_addsessionid(cf, data, &connssl->peer, backend->cred,
-                                     sizeof(struct Curl_schannel_cred),
-                                     schannel_session_free);
-      if(result) {
-        Curl_ssl_sessionid_unlock(data);
-        return result;
-      }
-    }
+    /* Up ref count since call takes ownership */
+    backend->cred->refcount++;
+    result = Curl_ssl_set_sessionid(cf, data, &connssl->peer, backend->cred,
+                                    sizeof(struct Curl_schannel_cred),
+                                    schannel_session_free);
     Curl_ssl_sessionid_unlock(data);
+    if(result)
+      return result;
   }
 
   if(data->set.ssl.certinfo) {
@@ -1853,7 +1835,7 @@ schannel_connect_common(struct Curl_cfilter *cf,
   }
 
   if(ssl_connect_1 == connssl->connecting_state) {
-    /* check out how much more time we're allowed */
+    /* check out how much more time we are allowed */
     timeout_ms = Curl_timeleft(data, NULL, TRUE);
 
     if(timeout_ms < 0) {
@@ -1867,11 +1849,9 @@ schannel_connect_common(struct Curl_cfilter *cf,
       return result;
   }
 
-  while(ssl_connect_2 == connssl->connecting_state ||
-        ssl_connect_2_reading == connssl->connecting_state ||
-        ssl_connect_2_writing == connssl->connecting_state) {
+  while(ssl_connect_2 == connssl->connecting_state) {
 
-    /* check out how much more time we're allowed */
+    /* check out how much more time we are allowed */
     timeout_ms = Curl_timeleft(data, NULL, TRUE);
 
     if(timeout_ms < 0) {
@@ -1880,14 +1860,13 @@ schannel_connect_common(struct Curl_cfilter *cf,
       return CURLE_OPERATION_TIMEDOUT;
     }
 
-    /* if ssl is expecting something, check if it's available. */
-    if(connssl->connecting_state == ssl_connect_2_reading
-       || connssl->connecting_state == ssl_connect_2_writing) {
+    /* if ssl is expecting something, check if it is available. */
+    if(connssl->io_need) {
 
-      curl_socket_t writefd = ssl_connect_2_writing ==
-        connssl->connecting_state ? sockfd : CURL_SOCKET_BAD;
-      curl_socket_t readfd = ssl_connect_2_reading ==
-        connssl->connecting_state ? sockfd : CURL_SOCKET_BAD;
+      curl_socket_t writefd = (connssl->io_need & CURL_SSL_IO_NEED_SEND)?
+                              sockfd : CURL_SOCKET_BAD;
+      curl_socket_t readfd = (connssl->io_need & CURL_SSL_IO_NEED_RECV)?
+                             sockfd : CURL_SOCKET_BAD;
 
       what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,
                                nonblocking ? 0 : timeout_ms);
@@ -1918,10 +1897,7 @@ schannel_connect_common(struct Curl_cfilter *cf,
      * have a valid fdset to wait on.
      */
     result = schannel_connect_step2(cf, data);
-    if(result || (nonblocking &&
-                  (ssl_connect_2 == connssl->connecting_state ||
-                   ssl_connect_2_reading == connssl->connecting_state ||
-                   ssl_connect_2_writing == connssl->connecting_state)))
+    if(result || (nonblocking && (ssl_connect_2 == connssl->connecting_state)))
       return result;
 
   } /* repeat step2 until all transactions are done. */
@@ -2029,10 +2005,10 @@ schannel_send(struct Curl_cfilter *cf, struct Curl_easy *data,
     len = outbuf[0].cbBuffer + outbuf[1].cbBuffer + outbuf[2].cbBuffer;
 
     /*
-      It's important to send the full message which includes the header,
-      encrypted payload, and trailer.  Until the client receives all the
+      it is important to send the full message which includes the header,
+      encrypted payload, and trailer. Until the client receives all the
       data a coherent message has not been delivered and the client
-      can't read any of it.
+      cannot read any of it.
 
       If we wanted to buffer the unwritten encrypted bytes, we would
       tell the client that all data it has requested to be sent has been
@@ -2129,8 +2105,9 @@ schannel_recv(struct Curl_cfilter *cf, struct Curl_easy *data,
   DEBUGASSERT(backend);
 
   /****************************************************************************
-   * Don't return or set backend->recv_unrecoverable_err unless in the cleanup.
-   * The pattern for return error is set *err, optional infof, goto cleanup.
+   * Do not return or set backend->recv_unrecoverable_err unless in the
+   * cleanup. The pattern for return error is set *err, optional infof, goto
+   * cleanup.
    *
    * Our priority is to always return as much decrypted data to the caller as
    * possible, even if an error occurs. The state of the decrypted buffer must
@@ -2155,7 +2132,7 @@ schannel_recv(struct Curl_cfilter *cf, struct Curl_easy *data,
     infof(data, "schannel: server indicated shutdown in a prior call");
     goto cleanup;
   }
-  /* It's debatable what to return when !len. Regardless we can't return
+  /* it is debatable what to return when !len. Regardless we cannot return
      immediately because there may be data to decrypt (in the case we want to
      decrypt all encrypted cached data) so handle !len later in cleanup.
   */
@@ -2313,14 +2290,15 @@ schannel_recv(struct Curl_cfilter *cf, struct Curl_easy *data,
       if(sspi_status == SEC_I_RENEGOTIATE) {
         infof(data, "schannel: remote party requests renegotiation");
         if(*err && *err != CURLE_AGAIN) {
-          infof(data, "schannel: can't renegotiate, an error is pending");
+          infof(data, "schannel: cannot renegotiate, an error is pending");
           goto cleanup;
         }
 
         /* begin renegotiation */
         infof(data, "schannel: renegotiating SSL/TLS connection");
         connssl->state = ssl_connection_negotiating;
-        connssl->connecting_state = ssl_connect_2_writing;
+        connssl->connecting_state = ssl_connect_2;
+        connssl->io_need = CURL_SSL_IO_NEED_SEND;
         backend->recv_renegotiating = true;
         *err = schannel_connect_common(cf, data, FALSE, &done);
         backend->recv_renegotiating = false;
@@ -2377,13 +2355,13 @@ cleanup:
 
   /* Error if the connection has closed without a close_notify.
 
-     The behavior here is a matter of debate. We don't want to be vulnerable
-     to a truncation attack however there's some browser precedent for
+     The behavior here is a matter of debate. We do not want to be vulnerable
+     to a truncation attack however there is some browser precedent for
      ignoring the close_notify for compatibility reasons.
 
      Additionally, Windows 2000 (v5.0) is a special case since it seems it
-     doesn't return close_notify. In that case if the connection was closed we
-     assume it was graceful (close_notify) since there doesn't seem to be a
+     does not return close_notify. In that case if the connection was closed we
+     assume it was graceful (close_notify) since there does not seem to be a
      way to tell.
   */
   if(len && !backend->decdata_offset && backend->recv_connection_closed &&
@@ -2420,7 +2398,7 @@ cleanup:
   if(!*err && !backend->recv_connection_closed)
     *err = CURLE_AGAIN;
 
-  /* It's debatable what to return when !len. We could return whatever error
+  /* it is debatable what to return when !len. We could return whatever error
      we got from decryption but instead we override here so the return is
      consistent.
   */
@@ -2475,8 +2453,9 @@ static bool schannel_data_pending(struct Curl_cfilter *cf,
 /* shut down the SSL connection and clean up related memory.
    this function can be called multiple times on the same connection including
    if the SSL connection failed (eg connection made but failed handshake). */
-static int schannel_shutdown(struct Curl_cfilter *cf,
-                             struct Curl_easy *data)
+static CURLcode schannel_shutdown(struct Curl_cfilter *cf,
+                                  struct Curl_easy *data,
+                                  bool send_shutdown, bool *done)
 {
   /* See https://msdn.microsoft.com/en-us/library/windows/desktop/aa380138.aspx
    * Shutting Down an Schannel Connection
@@ -2484,22 +2463,36 @@ static int schannel_shutdown(struct Curl_cfilter *cf,
   struct ssl_connect_data *connssl = cf->ctx;
   struct schannel_ssl_backend_data *backend =
     (struct schannel_ssl_backend_data *)connssl->backend;
+  CURLcode result = CURLE_OK;
+
+  if(cf->shutdown) {
+    *done = TRUE;
+    return CURLE_OK;
+  }
 
   DEBUGASSERT(data);
   DEBUGASSERT(backend);
 
+  /* Not supported in schannel */
+  (void)send_shutdown;
+
+  *done = FALSE;
   if(backend->ctxt) {
     infof(data, "schannel: shutting down SSL/TLS connection with %s port %d",
           connssl->peer.hostname, connssl->peer.port);
   }
 
-  if(backend->cred && backend->ctxt) {
+  if(!backend->ctxt || cf->shutdown) {
+    *done = TRUE;
+    goto out;
+  }
+
+  if(backend->cred && backend->ctxt && !backend->sent_shutdown) {
     SecBufferDesc BuffDesc;
     SecBuffer Buffer;
     SECURITY_STATUS sspi_status;
     SecBuffer outbuf;
     SecBufferDesc outbuf_desc;
-    CURLcode result;
     DWORD dwshut = SCHANNEL_SHUTDOWN;
 
     InitSecBuffer(&Buffer, SECBUFFER_TOKEN, &dwshut, sizeof(dwshut));
@@ -2512,6 +2505,8 @@ static int schannel_shutdown(struct Curl_cfilter *cf,
       char buffer[STRERROR_LEN];
       failf(data, "schannel: ApplyControlToken failure: %s",
             Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));
+      result = CURLE_SEND_ERROR;
+      goto out;
     }
 
     /* setup output buffer */
@@ -2538,13 +2533,75 @@ static int schannel_shutdown(struct Curl_cfilter *cf,
                                           outbuf.pvBuffer, outbuf.cbBuffer,
                                           &result);
       s_pSecFn->FreeContextBuffer(outbuf.pvBuffer);
-      if((result != CURLE_OK) || (outbuf.cbBuffer != (size_t) written)) {
-        infof(data, "schannel: failed to send close msg: %s"
-              " (bytes written: %zd)", curl_easy_strerror(result), written);
+      if(!result) {
+        if(written < (ssize_t)outbuf.cbBuffer) {
+          /* TODO: handle partial sends */
+          infof(data, "schannel: failed to send close msg: %s"
+                " (bytes written: %zd)", curl_easy_strerror(result), written);
+          result = CURLE_SEND_ERROR;
+          goto out;
+        }
+        backend->sent_shutdown = TRUE;
+        *done = TRUE;
+      }
+      else if(result == CURLE_AGAIN) {
+        connssl->io_need = CURL_SSL_IO_NEED_SEND;
+        result = CURLE_OK;
+        goto out;
+      }
+      else {
+        if(!backend->recv_connection_closed) {
+          infof(data, "schannel: error sending close msg: %d", result);
+          result = CURLE_SEND_ERROR;
+          goto out;
+        }
+        /* Looks like server already closed the connection.
+         * An error to send our close notify is not a failure. */
+        *done = TRUE;
+        result = CURLE_OK;
       }
     }
   }
 
+  /* If the connection seems open and we have not seen the close notify
+   * from the server yet, try to receive it. */
+  if(backend->cred && backend->ctxt &&
+     !backend->recv_sspi_close_notify && !backend->recv_connection_closed) {
+    char buffer[1024];
+    ssize_t nread;
+
+    nread = schannel_recv(cf, data, buffer, sizeof(buffer), &result);
+    if(nread > 0) {
+      /* still data coming in? */
+    }
+    else if(nread == 0) {
+      /* We got the close notify alert and are done. */
+      backend->recv_connection_closed = TRUE;
+      *done = TRUE;
+    }
+    else if(nread < 0 && result == CURLE_AGAIN) {
+      connssl->io_need = CURL_SSL_IO_NEED_RECV;
+    }
+    else {
+      CURL_TRC_CF(data, cf, "SSL shutdown, error %d", result);
+      result = CURLE_RECV_ERROR;
+    }
+  }
+
+out:
+  cf->shutdown = (result || *done);
+  return result;
+}
+
+static void schannel_close(struct Curl_cfilter *cf, struct Curl_easy *data)
+{
+  struct ssl_connect_data *connssl = cf->ctx;
+  struct schannel_ssl_backend_data *backend =
+    (struct schannel_ssl_backend_data *)connssl->backend;
+
+  DEBUGASSERT(data);
+  DEBUGASSERT(backend);
+
   /* free SSPI Schannel API security context handle */
   if(backend->ctxt) {
     DEBUGF(infof(data, "schannel: clear security context handle"));
@@ -2574,13 +2631,6 @@ static int schannel_shutdown(struct Curl_cfilter *cf,
     backend->decdata_length = 0;
     backend->decdata_offset = 0;
   }
-
-  return CURLE_OK;
-}
-
-static void schannel_close(struct Curl_cfilter *cf, struct Curl_easy *data)
-{
-  schannel_shutdown(cf, data);
 }
 
 static int schannel_init(void)
@@ -2595,9 +2645,7 @@ static void schannel_cleanup(void)
 
 static size_t schannel_version(char *buffer, size_t size)
 {
-  size = msnprintf(buffer, size, "Schannel");
-
-  return size;
+  return msnprintf(buffer, size, "Schannel");
 }
 
 static CURLcode schannel_random(struct Curl_easy *data UNUSED_PARAM,
@@ -2622,7 +2670,7 @@ static CURLcode schannel_pkp_pin_peer_pubkey(struct Curl_cfilter *cf,
 
   DEBUGASSERT(backend);
 
-  /* if a path wasn't specified, don't pin */
+  /* if a path was not specified, do not pin */
   if(!pinnedpubkey)
     return CURLE_OK;
 
@@ -2684,6 +2732,13 @@ static void schannel_checksum(const unsigned char *input,
                               DWORD provType,
                               const unsigned int algId)
 {
+#ifdef CURL_WINDOWS_APP
+  (void)input;
+  (void)inputlen;
+  (void)provType;
+  (void)algId;
+  memset(checksum, 0, checksumlen);
+#else
   HCRYPTPROV hProv = 0;
   HCRYPTHASH hHash = 0;
   DWORD cbHashSize = 0;
@@ -2724,6 +2779,7 @@ static void schannel_checksum(const unsigned char *input,
 
   if(hProv)
     CryptReleaseContext(hProv, 0);
+#endif
 }
 
 static CURLcode schannel_sha256sum(const unsigned char *input,
@@ -2752,7 +2808,7 @@ HCERTSTORE Curl_schannel_get_cached_cert_store(struct Curl_cfilter *cf,
   struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
   struct Curl_multi *multi = data->multi;
   const struct curl_blob *ca_info_blob = conn_config->ca_info_blob;
-  struct schannel_multi_ssl_backend_data *mbackend;
+  struct schannel_cert_share *share;
   const struct ssl_general_config *cfg = &data->set.general_ssl;
   timediff_t timeout_ms;
   timediff_t elapsed_ms;
@@ -2761,12 +2817,14 @@ HCERTSTORE Curl_schannel_get_cached_cert_store(struct Curl_cfilter *cf,
 
   DEBUGASSERT(multi);
 
-  if(!multi || !multi->ssl_backend_data) {
+  if(!multi) {
     return NULL;
   }
 
-  mbackend = (struct schannel_multi_ssl_backend_data *)multi->ssl_backend_data;
-  if(!mbackend->cert_store) {
+  share = Curl_hash_pick(&multi->proto_hash,
+                         (void *)MPROTO_SCHANNEL_CERT_SHARE_KEY,
+                         sizeof(MPROTO_SCHANNEL_CERT_SHARE_KEY)-1);
+  if(!share || !share->cert_store) {
     return NULL;
   }
 
@@ -2781,37 +2839,52 @@ HCERTSTORE Curl_schannel_get_cached_cert_store(struct Curl_cfilter *cf,
   timeout_ms = cfg->ca_cache_timeout * (timediff_t)1000;
   if(timeout_ms >= 0) {
     now = Curl_now();
-    elapsed_ms = Curl_timediff(now, mbackend->time);
+    elapsed_ms = Curl_timediff(now, share->time);
     if(elapsed_ms >= timeout_ms) {
       return NULL;
     }
   }
 
   if(ca_info_blob) {
-    if(!mbackend->CAinfo_blob_digest) {
+    if(!share->CAinfo_blob_digest) {
       return NULL;
     }
-    if(mbackend->CAinfo_blob_size != ca_info_blob->len) {
+    if(share->CAinfo_blob_size != ca_info_blob->len) {
       return NULL;
     }
     schannel_sha256sum((const unsigned char *)ca_info_blob->data,
                        ca_info_blob->len,
                        info_blob_digest,
                        CURL_SHA256_DIGEST_LENGTH);
-    if(memcmp(mbackend->CAinfo_blob_digest,
+    if(memcmp(share->CAinfo_blob_digest,
               info_blob_digest,
               CURL_SHA256_DIGEST_LENGTH)) {
         return NULL;
     }
   }
   else {
-    if(!conn_config->CAfile || !mbackend->CAfile ||
-       strcmp(mbackend->CAfile, conn_config->CAfile)) {
+    if(!conn_config->CAfile || !share->CAfile ||
+       strcmp(share->CAfile, conn_config->CAfile)) {
       return NULL;
     }
   }
 
-  return mbackend->cert_store;
+  return share->cert_store;
+}
+
+static void schannel_cert_share_free(void *key, size_t key_len, void *p)
+{
+  struct schannel_cert_share *share = p;
+  DEBUGASSERT(key_len == (sizeof(MPROTO_SCHANNEL_CERT_SHARE_KEY)-1));
+  DEBUGASSERT(!memcmp(MPROTO_SCHANNEL_CERT_SHARE_KEY, key, key_len));
+  (void)key;
+  (void)key_len;
+  if(share->cert_store) {
+    CertCloseStore(share->cert_store, 0);
+  }
+  free(share->CAinfo_blob_digest);
+  free(share->CAfile);
+  free(share);
 }
 
 bool Curl_schannel_set_cached_cert_store(struct Curl_cfilter *cf,
@@ -2821,7 +2894,7 @@ bool Curl_schannel_set_cached_cert_store(struct Curl_cfilter *cf,
   struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
   struct Curl_multi *multi = data->multi;
   const struct curl_blob *ca_info_blob = conn_config->ca_info_blob;
-  struct schannel_multi_ssl_backend_data *mbackend;
+  struct schannel_cert_share *share;
   unsigned char *CAinfo_blob_digest = NULL;
   size_t CAinfo_blob_size = 0;
   char *CAfile = NULL;
@@ -2832,17 +2905,23 @@ bool Curl_schannel_set_cached_cert_store(struct Curl_cfilter *cf,
     return false;
   }
 
-  if(!multi->ssl_backend_data) {
-    multi->ssl_backend_data =
-      calloc(1, sizeof(struct schannel_multi_ssl_backend_data));
-    if(!multi->ssl_backend_data) {
+  share = Curl_hash_pick(&multi->proto_hash,
+                         (void *)MPROTO_SCHANNEL_CERT_SHARE_KEY,
+                         sizeof(MPROTO_SCHANNEL_CERT_SHARE_KEY)-1);
+  if(!share) {
+    share = calloc(1, sizeof(*share));
+    if(!share) {
+      return false;
+    }
+    if(!Curl_hash_add2(&multi->proto_hash,
+                       (void *)MPROTO_SCHANNEL_CERT_SHARE_KEY,
+                       sizeof(MPROTO_SCHANNEL_CERT_SHARE_KEY)-1,
+                       share, schannel_cert_share_free)) {
+      free(share);
       return false;
     }
   }
 
-  mbackend = (struct schannel_multi_ssl_backend_data *)multi->ssl_backend_data;
-
-
   if(ca_info_blob) {
     CAinfo_blob_digest = malloc(CURL_SHA256_DIGEST_LENGTH);
     if(!CAinfo_blob_digest) {
@@ -2864,33 +2943,20 @@ bool Curl_schannel_set_cached_cert_store(struct Curl_cfilter *cf,
   }
 
   /* free old cache data */
-  if(mbackend->cert_store) {
-    CertCloseStore(mbackend->cert_store, 0);
+  if(share->cert_store) {
+    CertCloseStore(share->cert_store, 0);
   }
-  free(mbackend->CAinfo_blob_digest);
-  free(mbackend->CAfile);
+  free(share->CAinfo_blob_digest);
+  free(share->CAfile);
 
-  mbackend->time = Curl_now();
-  mbackend->cert_store = cert_store;
-  mbackend->CAinfo_blob_digest = CAinfo_blob_digest;
-  mbackend->CAinfo_blob_size = CAinfo_blob_size;
-  mbackend->CAfile = CAfile;
+  share->time = Curl_now();
+  share->cert_store = cert_store;
+  share->CAinfo_blob_digest = CAinfo_blob_digest;
+  share->CAinfo_blob_size = CAinfo_blob_size;
+  share->CAfile = CAfile;
   return true;
 }
 
-static void schannel_free_multi_ssl_backend_data(
-  struct multi_ssl_backend_data *msbd)
-{
-  struct schannel_multi_ssl_backend_data *mbackend =
-    (struct schannel_multi_ssl_backend_data*)msbd;
-  if(mbackend->cert_store) {
-    CertCloseStore(mbackend->cert_store, 0);
-  }
-  free(mbackend->CAinfo_blob_digest);
-  free(mbackend->CAfile);
-  free(mbackend);
-}
-
 const struct Curl_ssl Curl_ssl_schannel = {
   { CURLSSLBACKEND_SCHANNEL, "schannel" }, /* info */
 
@@ -2898,8 +2964,11 @@ const struct Curl_ssl Curl_ssl_schannel = {
 #ifdef HAS_MANUAL_VERIFY_API
   SSLSUPP_CAINFO_BLOB |
 #endif
+#ifndef CURL_WINDOWS_APP
   SSLSUPP_PINNEDPUBKEY |
+#endif
   SSLSUPP_TLS13_CIPHERSUITES |
+  SSLSUPP_CA_CACHE |
   SSLSUPP_HTTPS_PROXY,
 
   sizeof(struct schannel_ssl_backend_data),
@@ -2925,7 +2994,6 @@ const struct Curl_ssl Curl_ssl_schannel = {
   schannel_sha256sum,                /* sha256sum */
   NULL,                              /* associate_connection */
   NULL,                              /* disassociate_connection */
-  schannel_free_multi_ssl_backend_data, /* free_multi_ssl_backend_data */
   schannel_recv,                     /* recv decrypted data */
   schannel_send,                     /* send data to encrypt */
 };
diff --git a/lib/vtls/schannel_int.h b/lib/vtls/schannel_int.h
index 5e233a9d0..b04f1804b 100644
--- a/lib/vtls/schannel_int.h
+++ b/lib/vtls/schannel_int.h
@@ -28,7 +28,8 @@
 
 #ifdef USE_SCHANNEL
 
-#if defined(__MINGW32__) || defined(CERT_CHAIN_REVOCATION_CHECK_CHAIN)
+#if (defined(__MINGW32__) || defined(CERT_CHAIN_REVOCATION_CHECK_CHAIN)) \
+  && !defined(CURL_WINDOWS_APP)
 #define HAS_MANUAL_VERIFY_API
 #endif
 
@@ -144,7 +145,7 @@ struct schannel_ssl_backend_data {
   size_t encdata_offset, decdata_offset;
   unsigned char *encdata_buffer, *decdata_buffer;
   /* encdata_is_incomplete: if encdata contains only a partial record that
-     can't be decrypted without another recv() (that is, status is
+     cannot be decrypted without another recv() (that is, status is
      SEC_E_INCOMPLETE_MESSAGE) then set this true. after an recv() adds
      more bytes into encdata then set this back to false. */
   bool encdata_is_incomplete;
@@ -157,9 +158,13 @@ struct schannel_ssl_backend_data {
 #ifdef HAS_MANUAL_VERIFY_API
   bool use_manual_cred_validation; /* true if manual cred validation is used */
 #endif
+  BIT(sent_shutdown);
 };
 
-struct schannel_multi_ssl_backend_data {
+/* key to use at `multi->proto_hash` */
+#define MPROTO_SCHANNEL_CERT_SHARE_KEY   "tls:schannel:cert:share"
+
+struct schannel_cert_share {
   unsigned char *CAinfo_blob_digest; /* CA info blob digest */
   size_t CAinfo_blob_size;           /* CA info blob size */
   char *CAfile;                      /* CAfile path used to generate
diff --git a/lib/vtls/schannel_verify.c b/lib/vtls/schannel_verify.c
index 24146d0bd..96ad0e517 100644
--- a/lib/vtls/schannel_verify.c
+++ b/lib/vtls/schannel_verify.c
@@ -33,7 +33,7 @@
 
 #ifdef USE_SCHANNEL
 #ifndef USE_WINDOWS_SSPI
-#  error "Can't compile SCHANNEL support without SSPI."
+#  error "cannot compile SCHANNEL support without SSPI."
 #endif
 
 #include "schannel.h"
@@ -82,7 +82,7 @@ static int is_cr_or_lf(char c)
 }
 
 /* Search the substring needle,needlelen into string haystack,haystacklen
- * Strings don't need to be terminated by a '\0'.
+ * Strings do not need to be terminated by a '\0'.
  * Similar of OSX/Linux memmem (not available on Visual Studio).
  * Return position of beginning of first occurrence or NULL if not found
  */
@@ -335,7 +335,7 @@ cleanup:
 
 /*
  * Returns the number of characters necessary to populate all the host_names.
- * If host_names is not NULL, populate it with all the host names. Each string
+ * If host_names is not NULL, populate it with all the hostnames. Each string
  * in the host_names is null-terminated and the last string is double
  * null-terminated. If no DNS names are found, a single null-terminated empty
  * string is returned.
@@ -346,6 +346,12 @@ static DWORD cert_get_name_string(struct Curl_easy *data,
                                   DWORD length)
 {
   DWORD actual_length = 0;
+#if defined(CURL_WINDOWS_APP)
+  (void)data;
+  (void)cert_context;
+  (void)host_names;
+  (void)length;
+#else
   BOOL compute_content = FALSE;
   CERT_INFO *cert_info = NULL;
   CERT_EXTENSION *extension = NULL;
@@ -441,14 +447,14 @@ static DWORD cert_get_name_string(struct Curl_easy *data,
     }
     /* Sanity check to prevent buffer overrun. */
     if((actual_length + current_length) > length) {
-      failf(data, "schannel: Not enough memory to list all host names.");
+      failf(data, "schannel: Not enough memory to list all hostnames.");
       break;
     }
     dns_w = entry->pwszDNSName;
-    /* pwszDNSName is in ia5 string format and hence doesn't contain any
+    /* pwszDNSName is in ia5 string format and hence does not contain any
      * non-ascii characters. */
     while(*dns_w != '\0') {
-      *current_pos++ = (char)(*dns_w++);
+      *current_pos++ = (TCHAR)(*dns_w++);
     }
     *current_pos++ = '\0';
     actual_length += (DWORD)current_length;
@@ -457,6 +463,7 @@ static DWORD cert_get_name_string(struct Curl_easy *data,
     /* Last string has double null-terminator. */
     *current_pos = '\0';
   }
+#endif
   return actual_length;
 }
 
diff --git a/lib/vtls/sectransp.c b/lib/vtls/sectransp.c
index f49db6481..c2803e8bf 100644
--- a/lib/vtls/sectransp.c
+++ b/lib/vtls/sectransp.c
@@ -30,6 +30,8 @@
 
 #include "curl_setup.h"
 
+#ifdef USE_SECTRANSP
+
 #include "urldata.h" /* for the Curl_easy definition */
 #include "curl_base64.h"
 #include "strtok.h"
@@ -37,19 +39,16 @@
 #include "strcase.h"
 #include "x509asn1.h"
 #include "strerror.h"
-
-#ifdef USE_SECTRANSP
+#include "cipher_suite.h"
 
 #ifdef __clang__
 #pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wtautological-pointer-compare"
+#pragma clang diagnostic ignored "-Wunreachable-code"
 #endif /* __clang__ */
 
 #ifdef __GNUC__
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Waddress"
-#pragma GCC diagnostic ignored "-Wundef"
-#pragma GCC diagnostic ignored "-Wunreachable-code"
 #endif
 
 #include <limits.h>
@@ -72,7 +71,7 @@
 #if (TARGET_OS_MAC && !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE))
 
 #if MAC_OS_X_VERSION_MAX_ALLOWED < 1050
-#error "The Secure Transport back-end requires Leopard or later."
+#error "The Secure Transport backend requires Leopard or later."
 #endif /* MAC_OS_X_VERSION_MAX_ALLOWED < 1050 */
 
 #define CURL_BUILD_IOS 0
@@ -122,7 +121,7 @@
 #define CURL_SUPPORT_MAC_10_9 0
 
 #else
-#error "The Secure Transport back-end requires iOS or macOS."
+#error "The Secure Transport backend requires iOS or macOS."
 #endif /* (TARGET_OS_MAC && !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) */
 
 #if CURL_BUILD_MAC
@@ -144,7 +143,8 @@
 #include "memdebug.h"
 
 
-/* From MacTypes.h (which we can't include because it isn't present in iOS: */
+/* From MacTypes.h (which we cannot include because it is not present in
+   iOS: */
 #define ioErr -36
 #define paramErr -50
 
@@ -152,636 +152,60 @@ struct st_ssl_backend_data {
   SSLContextRef ssl_ctx;
   bool ssl_direction; /* true if writing, false if reading */
   size_t ssl_write_buffered_length;
+  BIT(sent_shutdown);
 };
 
-struct st_cipher {
-  const char *name; /* Cipher suite IANA name. It starts with "TLS_" prefix */
-  const char *alias_name; /* Alias name is the same as OpenSSL cipher name */
-  SSLCipherSuite num; /* Cipher suite code/number defined in IANA registry */
-  bool weak; /* Flag to mark cipher as weak based on previous implementation
-                of Secure Transport back-end by CURL */
-};
-
-/* Macro to initialize st_cipher data structure: stringify id to name, cipher
-   number/id, 'weak' suite flag
- */
-#define CIPHER_DEF(num, alias, weak) \
-  { #num, alias, num, weak }
-
-/*
- Macro to initialize st_cipher data structure with name, code (IANA cipher
- number/id value), and 'weak' suite flag. The first 28 cipher suite numbers
- have the same IANA code for both SSL and TLS standards: numbers 0x0000 to
- 0x001B. They have different names though. The first 4 letters of the cipher
- suite name are the protocol name: "SSL_" or "TLS_", rest of the IANA name is
- the same for both SSL and TLS cipher suite name.
- The second part of the problem is that macOS/iOS SDKs don't define all TLS
- codes but only 12 of them. The SDK defines all SSL codes though, i.e. SSL_NUM
- constant is always defined for those 28 ciphers while TLS_NUM is defined only
- for 12 of the first 28 ciphers. Those 12 TLS cipher codes match to
- corresponding SSL enum value and represent the same cipher suite. Therefore
- we'll use the SSL enum value for those cipher suites because it is defined
- for all 28 of them.
- We make internal data consistent and based on TLS names, i.e. all st_cipher
- item names start with the "TLS_" prefix.
- Summarizing all the above, those 28 first ciphers are presented in our table
- with both TLS and SSL names. Their cipher numbers are assigned based on the
- SDK enum value for the SSL cipher, which matches to IANA TLS number.
+/* Create the list of default ciphers to use by making an intersection of the
+ * ciphers supported by Secure Transport and the list below, using the order
+ * of the former.
+ * This list is based on TLS recommendations by Mozilla, balancing between
+ * security and wide compatibility: "Most ciphers that are not clearly broken
+ * and dangerous to use are supported"
  */
-#define CIPHER_DEF_SSLTLS(num_wo_prefix, alias, weak) \
-  { "TLS_" #num_wo_prefix, alias, SSL_##num_wo_prefix, weak }
-
-/*
- Cipher suites were marked as weak based on the following:
- RC4 encryption - rfc7465, the document contains a list of deprecated ciphers.
-     Marked in the code below as weak.
- RC2 encryption - many mentions, was found vulnerable to a relatively easy
-     attack https://link.springer.com/chapter/10.1007%2F3-540-69710-1_14
-     Marked in the code below as weak.
- DES and IDEA encryption - rfc5469, has a list of deprecated ciphers.
-     Marked in the code below as weak.
- Anonymous Diffie-Hellman authentication and anonymous elliptic curve
-     Diffie-Hellman - vulnerable to a man-in-the-middle attack. Deprecated by
-     RFC 4346 aka TLS 1.1 (section A.5, page 60)
- Null bulk encryption suites - not encrypted communication
- Export ciphers, i.e. ciphers with restrictions to be used outside the US for
-     software exported to some countries, they were excluded from TLS 1.1
-     version. More precisely, they were noted as ciphers which MUST NOT be
-     negotiated in RFC 4346 aka TLS 1.1 (section A.5, pages 60 and 61).
-     All of those filters were considered weak because they contain a weak
-     algorithm like DES, RC2 or RC4, and already considered weak by other
-     criteria.
- 3DES - NIST deprecated it and is going to retire it by 2023
- https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA
-     OpenSSL https://www.openssl.org/blog/blog/2016/08/24/sweet32/ also
-     deprecated those ciphers. Some other libraries also consider it
-     vulnerable or at least not strong enough.
-
- CBC ciphers are vulnerable with SSL3.0 and TLS1.0:
- https://www.cisco.com/c/en/us/support/docs/security/email-security-appliance
- /118518-technote-esa-00.html
-     We don't take care of this issue because it is resolved by later TLS
-     versions and for us, it requires more complicated checks, we need to
-     check a protocol version also. Vulnerability doesn't look very critical
-     and we do not filter out those cipher suites.
- */
-
-#define CIPHER_WEAK_NOT_ENCRYPTED   TRUE
-#define CIPHER_WEAK_RC_ENCRYPTION   TRUE
-#define CIPHER_WEAK_DES_ENCRYPTION  TRUE
-#define CIPHER_WEAK_IDEA_ENCRYPTION TRUE
-#define CIPHER_WEAK_ANON_AUTH       TRUE
-#define CIPHER_WEAK_3DES_ENCRYPTION TRUE
-#define CIPHER_STRONG_ENOUGH        FALSE
-
-/* Please do not change the order of the first ciphers available for SSL.
-   Do not insert and do not delete any of them. Code below
-   depends on their order and continuity.
-   If you add a new cipher, please maintain order by number, i.e.
-   insert in between existing items to appropriate place based on
-   cipher suite IANA number
-*/
-static const struct st_cipher ciphertable[] = {
-  /* SSL version 3.0 and initial TLS 1.0 cipher suites.
-     Defined since SDK 10.2.8 */
-  CIPHER_DEF_SSLTLS(NULL_WITH_NULL_NULL,                           /* 0x0000 */
-                    NULL,
-                    CIPHER_WEAK_NOT_ENCRYPTED),
-  CIPHER_DEF_SSLTLS(RSA_WITH_NULL_MD5,                             /* 0x0001 */
-                    "NULL-MD5",
-                    CIPHER_WEAK_NOT_ENCRYPTED),
-  CIPHER_DEF_SSLTLS(RSA_WITH_NULL_SHA,                             /* 0x0002 */
-                    "NULL-SHA",
-                    CIPHER_WEAK_NOT_ENCRYPTED),
-  CIPHER_DEF_SSLTLS(RSA_EXPORT_WITH_RC4_40_MD5,                    /* 0x0003 */
-                    "EXP-RC4-MD5",
-                    CIPHER_WEAK_RC_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(RSA_WITH_RC4_128_MD5,                          /* 0x0004 */
-                    "RC4-MD5",
-                    CIPHER_WEAK_RC_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(RSA_WITH_RC4_128_SHA,                          /* 0x0005 */
-                    "RC4-SHA",
-                    CIPHER_WEAK_RC_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(RSA_EXPORT_WITH_RC2_CBC_40_MD5,                /* 0x0006 */
-                    "EXP-RC2-CBC-MD5",
-                    CIPHER_WEAK_RC_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(RSA_WITH_IDEA_CBC_SHA,                         /* 0x0007 */
-                    "IDEA-CBC-SHA",
-                    CIPHER_WEAK_IDEA_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(RSA_EXPORT_WITH_DES40_CBC_SHA,                 /* 0x0008 */
-                    "EXP-DES-CBC-SHA",
-                    CIPHER_WEAK_DES_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(RSA_WITH_DES_CBC_SHA,                          /* 0x0009 */
-                    "DES-CBC-SHA",
-                    CIPHER_WEAK_DES_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(RSA_WITH_3DES_EDE_CBC_SHA,                     /* 0x000A */
-                    "DES-CBC3-SHA",
-                    CIPHER_WEAK_3DES_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(DH_DSS_EXPORT_WITH_DES40_CBC_SHA,              /* 0x000B */
-                    "EXP-DH-DSS-DES-CBC-SHA",
-                    CIPHER_WEAK_DES_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(DH_DSS_WITH_DES_CBC_SHA,                       /* 0x000C */
-                    "DH-DSS-DES-CBC-SHA",
-                    CIPHER_WEAK_DES_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(DH_DSS_WITH_3DES_EDE_CBC_SHA,                  /* 0x000D */
-                    "DH-DSS-DES-CBC3-SHA",
-                    CIPHER_WEAK_3DES_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(DH_RSA_EXPORT_WITH_DES40_CBC_SHA,              /* 0x000E */
-                    "EXP-DH-RSA-DES-CBC-SHA",
-                    CIPHER_WEAK_DES_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(DH_RSA_WITH_DES_CBC_SHA,                       /* 0x000F */
-                    "DH-RSA-DES-CBC-SHA",
-                    CIPHER_WEAK_DES_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(DH_RSA_WITH_3DES_EDE_CBC_SHA,                  /* 0x0010 */
-                    "DH-RSA-DES-CBC3-SHA",
-                    CIPHER_WEAK_3DES_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(DHE_DSS_EXPORT_WITH_DES40_CBC_SHA,             /* 0x0011 */
-                    "EXP-EDH-DSS-DES-CBC-SHA",
-                    CIPHER_WEAK_DES_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(DHE_DSS_WITH_DES_CBC_SHA,                      /* 0x0012 */
-                    "EDH-DSS-CBC-SHA",
-                    CIPHER_WEAK_DES_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(DHE_DSS_WITH_3DES_EDE_CBC_SHA,                 /* 0x0013 */
-                    "DHE-DSS-DES-CBC3-SHA",
-                    CIPHER_WEAK_3DES_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(DHE_RSA_EXPORT_WITH_DES40_CBC_SHA,             /* 0x0014 */
-                    "EXP-EDH-RSA-DES-CBC-SHA",
-                    CIPHER_WEAK_DES_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(DHE_RSA_WITH_DES_CBC_SHA,                      /* 0x0015 */
-                    "EDH-RSA-DES-CBC-SHA",
-                    CIPHER_WEAK_DES_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(DHE_RSA_WITH_3DES_EDE_CBC_SHA,                 /* 0x0016 */
-                    "DHE-RSA-DES-CBC3-SHA",
-                    CIPHER_WEAK_3DES_ENCRYPTION),
-  CIPHER_DEF_SSLTLS(DH_anon_EXPORT_WITH_RC4_40_MD5,                /* 0x0017 */
-                    "EXP-ADH-RC4-MD5",
-                    CIPHER_WEAK_ANON_AUTH),
-  CIPHER_DEF_SSLTLS(DH_anon_WITH_RC4_128_MD5,                      /* 0x0018 */
-                    "ADH-RC4-MD5",
-                    CIPHER_WEAK_ANON_AUTH),
-  CIPHER_DEF_SSLTLS(DH_anon_EXPORT_WITH_DES40_CBC_SHA,             /* 0x0019 */
-                    "EXP-ADH-DES-CBC-SHA",
-                    CIPHER_WEAK_ANON_AUTH),
-  CIPHER_DEF_SSLTLS(DH_anon_WITH_DES_CBC_SHA,                      /* 0x001A */
-                    "ADH-DES-CBC-SHA",
-                    CIPHER_WEAK_ANON_AUTH),
-  CIPHER_DEF_SSLTLS(DH_anon_WITH_3DES_EDE_CBC_SHA,                 /* 0x001B */
-                    "ADH-DES-CBC3-SHA",
-                    CIPHER_WEAK_3DES_ENCRYPTION),
-  CIPHER_DEF(SSL_FORTEZZA_DMS_WITH_NULL_SHA,                       /* 0x001C */
-             NULL,
-             CIPHER_WEAK_NOT_ENCRYPTED),
-  CIPHER_DEF(SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA,               /* 0x001D */
-             NULL,
-             CIPHER_STRONG_ENOUGH),
-
-#if CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7
-  /* RFC 4785 - Pre-Shared Key (PSK) Ciphersuites with NULL Encryption */
-  CIPHER_DEF(TLS_PSK_WITH_NULL_SHA,                                /* 0x002C */
-             "PSK-NULL-SHA",
-             CIPHER_WEAK_NOT_ENCRYPTED),
-  CIPHER_DEF(TLS_DHE_PSK_WITH_NULL_SHA,                            /* 0x002D */
-             "DHE-PSK-NULL-SHA",
-             CIPHER_WEAK_NOT_ENCRYPTED),
-  CIPHER_DEF(TLS_RSA_PSK_WITH_NULL_SHA,                            /* 0x002E */
-             "RSA-PSK-NULL-SHA",
-             CIPHER_WEAK_NOT_ENCRYPTED),
-#endif /* CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7 */
-
-  /* TLS addenda using AES, per RFC 3268. Defined since SDK 10.4u */
-  CIPHER_DEF(TLS_RSA_WITH_AES_128_CBC_SHA,                         /* 0x002F */
-             "AES128-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DH_DSS_WITH_AES_128_CBC_SHA,                      /* 0x0030 */
-             "DH-DSS-AES128-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DH_RSA_WITH_AES_128_CBC_SHA,                      /* 0x0031 */
-             "DH-RSA-AES128-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_128_CBC_SHA,                     /* 0x0032 */
-             "DHE-DSS-AES128-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_128_CBC_SHA,                     /* 0x0033 */
-             "DHE-RSA-AES128-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DH_anon_WITH_AES_128_CBC_SHA,                     /* 0x0034 */
-             "ADH-AES128-SHA",
-             CIPHER_WEAK_ANON_AUTH),
-  CIPHER_DEF(TLS_RSA_WITH_AES_256_CBC_SHA,                         /* 0x0035 */
-             "AES256-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DH_DSS_WITH_AES_256_CBC_SHA,                      /* 0x0036 */
-             "DH-DSS-AES256-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DH_RSA_WITH_AES_256_CBC_SHA,                      /* 0x0037 */
-             "DH-RSA-AES256-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_256_CBC_SHA,                     /* 0x0038 */
-             "DHE-DSS-AES256-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_256_CBC_SHA,                     /* 0x0039 */
-             "DHE-RSA-AES256-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DH_anon_WITH_AES_256_CBC_SHA,                     /* 0x003A */
-             "ADH-AES256-SHA",
-             CIPHER_WEAK_ANON_AUTH),
-
-#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS
-  /* TLS 1.2 addenda, RFC 5246 */
-  /* Server provided RSA certificate for key exchange. */
-  CIPHER_DEF(TLS_RSA_WITH_NULL_SHA256,                             /* 0x003B */
-             "NULL-SHA256",
-             CIPHER_WEAK_NOT_ENCRYPTED),
-  CIPHER_DEF(TLS_RSA_WITH_AES_128_CBC_SHA256,                      /* 0x003C */
-             "AES128-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_RSA_WITH_AES_256_CBC_SHA256,                      /* 0x003D */
-             "AES256-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  /* Server-authenticated (and optionally client-authenticated)
-     Diffie-Hellman. */
-  CIPHER_DEF(TLS_DH_DSS_WITH_AES_128_CBC_SHA256,                   /* 0x003E */
-             "DH-DSS-AES128-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DH_RSA_WITH_AES_128_CBC_SHA256,                   /* 0x003F */
-             "DH-RSA-AES128-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_128_CBC_SHA256,                  /* 0x0040 */
-             "DHE-DSS-AES128-SHA256",
-             CIPHER_STRONG_ENOUGH),
-
-  /* TLS 1.2 addenda, RFC 5246 */
-  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,                  /* 0x0067 */
-             "DHE-RSA-AES128-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DH_DSS_WITH_AES_256_CBC_SHA256,                   /* 0x0068 */
-             "DH-DSS-AES256-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DH_RSA_WITH_AES_256_CBC_SHA256,                   /* 0x0069 */
-             "DH-RSA-AES256-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_256_CBC_SHA256,                  /* 0x006A */
-             "DHE-DSS-AES256-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,                  /* 0x006B */
-             "DHE-RSA-AES256-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DH_anon_WITH_AES_128_CBC_SHA256,                  /* 0x006C */
-             "ADH-AES128-SHA256",
-             CIPHER_WEAK_ANON_AUTH),
-  CIPHER_DEF(TLS_DH_anon_WITH_AES_256_CBC_SHA256,                  /* 0x006D */
-             "ADH-AES256-SHA256",
-             CIPHER_WEAK_ANON_AUTH),
-#endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */
-
-#if CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7
-  /* Addendum from RFC 4279, TLS PSK */
-  CIPHER_DEF(TLS_PSK_WITH_RC4_128_SHA,                             /* 0x008A */
-             "PSK-RC4-SHA",
-             CIPHER_WEAK_RC_ENCRYPTION),
-  CIPHER_DEF(TLS_PSK_WITH_3DES_EDE_CBC_SHA,                        /* 0x008B */
-             "PSK-3DES-EDE-CBC-SHA",
-             CIPHER_WEAK_3DES_ENCRYPTION),
-  CIPHER_DEF(TLS_PSK_WITH_AES_128_CBC_SHA,                         /* 0x008C */
-             "PSK-AES128-CBC-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_PSK_WITH_AES_256_CBC_SHA,                         /* 0x008D */
-             "PSK-AES256-CBC-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DHE_PSK_WITH_RC4_128_SHA,                         /* 0x008E */
-             "DHE-PSK-RC4-SHA",
-             CIPHER_WEAK_RC_ENCRYPTION),
-  CIPHER_DEF(TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA,                    /* 0x008F */
-             "DHE-PSK-3DES-EDE-CBC-SHA",
-             CIPHER_WEAK_3DES_ENCRYPTION),
-  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_128_CBC_SHA,                     /* 0x0090 */
-             "DHE-PSK-AES128-CBC-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_256_CBC_SHA,                     /* 0x0091 */
-             "DHE-PSK-AES256-CBC-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_RSA_PSK_WITH_RC4_128_SHA,                         /* 0x0092 */
-             "RSA-PSK-RC4-SHA",
-             CIPHER_WEAK_RC_ENCRYPTION),
-  CIPHER_DEF(TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA,                    /* 0x0093 */
-             "RSA-PSK-3DES-EDE-CBC-SHA",
-             CIPHER_WEAK_3DES_ENCRYPTION),
-  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_128_CBC_SHA,                     /* 0x0094 */
-             "RSA-PSK-AES128-CBC-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_256_CBC_SHA,                     /* 0x0095 */
-             "RSA-PSK-AES256-CBC-SHA",
-             CIPHER_STRONG_ENOUGH),
-#endif /* CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7 */
-
-#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS
-  /* Addenda from rfc 5288 AES Galois Counter Mode (GCM) Cipher Suites
-     for TLS. */
-  CIPHER_DEF(TLS_RSA_WITH_AES_128_GCM_SHA256,                      /* 0x009C */
-             "AES128-GCM-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_RSA_WITH_AES_256_GCM_SHA384,                      /* 0x009D */
-             "AES256-GCM-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,                  /* 0x009E */
-             "DHE-RSA-AES128-GCM-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_256_GCM_SHA384,                  /* 0x009F */
-             "DHE-RSA-AES256-GCM-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DH_RSA_WITH_AES_128_GCM_SHA256,                   /* 0x00A0 */
-             "DH-RSA-AES128-GCM-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DH_RSA_WITH_AES_256_GCM_SHA384,                   /* 0x00A1 */
-             "DH-RSA-AES256-GCM-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_128_GCM_SHA256,                  /* 0x00A2 */
-             "DHE-DSS-AES128-GCM-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_256_GCM_SHA384,                  /* 0x00A3 */
-             "DHE-DSS-AES256-GCM-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DH_DSS_WITH_AES_128_GCM_SHA256,                   /* 0x00A4 */
-             "DH-DSS-AES128-GCM-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DH_DSS_WITH_AES_256_GCM_SHA384,                   /* 0x00A5 */
-             "DH-DSS-AES256-GCM-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DH_anon_WITH_AES_128_GCM_SHA256,                  /* 0x00A6 */
-             "ADH-AES128-GCM-SHA256",
-             CIPHER_WEAK_ANON_AUTH),
-  CIPHER_DEF(TLS_DH_anon_WITH_AES_256_GCM_SHA384,                  /* 0x00A7 */
-             "ADH-AES256-GCM-SHA384",
-             CIPHER_WEAK_ANON_AUTH),
-#endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */
-
-#if CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7
-  /* RFC 5487 - PSK with SHA-256/384 and AES GCM */
-  CIPHER_DEF(TLS_PSK_WITH_AES_128_GCM_SHA256,                      /* 0x00A8 */
-             "PSK-AES128-GCM-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_PSK_WITH_AES_256_GCM_SHA384,                      /* 0x00A9 */
-             "PSK-AES256-GCM-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_128_GCM_SHA256,                  /* 0x00AA */
-             "DHE-PSK-AES128-GCM-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_256_GCM_SHA384,                  /* 0x00AB */
-             "DHE-PSK-AES256-GCM-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_128_GCM_SHA256,                  /* 0x00AC */
-             "RSA-PSK-AES128-GCM-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_256_GCM_SHA384,                  /* 0x00AD */
-             "RSA-PSK-AES256-GCM-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_PSK_WITH_AES_128_CBC_SHA256,                      /* 0x00AE */
-             "PSK-AES128-CBC-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_PSK_WITH_AES_256_CBC_SHA384,                      /* 0x00AF */
-             "PSK-AES256-CBC-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_PSK_WITH_NULL_SHA256,                             /* 0x00B0 */
-             "PSK-NULL-SHA256",
-             CIPHER_WEAK_NOT_ENCRYPTED),
-  CIPHER_DEF(TLS_PSK_WITH_NULL_SHA384,                             /* 0x00B1 */
-             "PSK-NULL-SHA384",
-             CIPHER_WEAK_NOT_ENCRYPTED),
-  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_128_CBC_SHA256,                  /* 0x00B2 */
-             "DHE-PSK-AES128-CBC-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_256_CBC_SHA384,                  /* 0x00B3 */
-             "DHE-PSK-AES256-CBC-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_DHE_PSK_WITH_NULL_SHA256,                         /* 0x00B4 */
-             "DHE-PSK-NULL-SHA256",
-             CIPHER_WEAK_NOT_ENCRYPTED),
-  CIPHER_DEF(TLS_DHE_PSK_WITH_NULL_SHA384,                         /* 0x00B5 */
-             "DHE-PSK-NULL-SHA384",
-             CIPHER_WEAK_NOT_ENCRYPTED),
-  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_128_CBC_SHA256,                  /* 0x00B6 */
-             "RSA-PSK-AES128-CBC-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_256_CBC_SHA384,                  /* 0x00B7 */
-             "RSA-PSK-AES256-CBC-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_RSA_PSK_WITH_NULL_SHA256,                         /* 0x00B8 */
-             "RSA-PSK-NULL-SHA256",
-             CIPHER_WEAK_NOT_ENCRYPTED),
-  CIPHER_DEF(TLS_RSA_PSK_WITH_NULL_SHA384,                         /* 0x00B9 */
-             "RSA-PSK-NULL-SHA384",
-             CIPHER_WEAK_NOT_ENCRYPTED),
-#endif /* CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7 */
-
-  /* RFC 5746 - Secure Renegotiation. This is not a real suite,
-     it is a response to initiate negotiation again */
-  CIPHER_DEF(TLS_EMPTY_RENEGOTIATION_INFO_SCSV,                    /* 0x00FF */
-             NULL,
-             CIPHER_STRONG_ENOUGH),
-
-#if CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11
-  /* TLS 1.3 standard cipher suites for ChaCha20+Poly1305.
-     Note: TLS 1.3 ciphersuites do not specify the key exchange
-     algorithm -- they only specify the symmetric ciphers.
-     Cipher alias name matches to OpenSSL cipher name, and for
-     TLS 1.3 ciphers */
-  CIPHER_DEF(TLS_AES_128_GCM_SHA256,                               /* 0x1301 */
-             NULL,  /* The OpenSSL cipher name matches to the IANA name */
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_AES_256_GCM_SHA384,                               /* 0x1302 */
-             NULL,  /* The OpenSSL cipher name matches to the IANA name */
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_CHACHA20_POLY1305_SHA256,                         /* 0x1303 */
-             NULL,  /* The OpenSSL cipher name matches to the IANA name */
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_AES_128_CCM_SHA256,                               /* 0x1304 */
-             NULL,  /* The OpenSSL cipher name matches to the IANA name */
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_AES_128_CCM_8_SHA256,                             /* 0x1305 */
-             NULL,  /* The OpenSSL cipher name matches to the IANA name */
-             CIPHER_STRONG_ENOUGH),
-#endif /* CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11 */
+static const uint16_t default_ciphers[] = {
+  TLS_RSA_WITH_3DES_EDE_CBC_SHA,                    /* 0x000A */
+  TLS_RSA_WITH_AES_128_CBC_SHA,                     /* 0x002F */
+  TLS_RSA_WITH_AES_256_CBC_SHA,                     /* 0x0035 */
 
 #if CURL_BUILD_MAC_10_6 || CURL_BUILD_IOS
-  /* ECDSA addenda, RFC 4492 */
-  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_NULL_SHA,                         /* 0xC001 */
-             "ECDH-ECDSA-NULL-SHA",
-             CIPHER_WEAK_NOT_ENCRYPTED),
-  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_RC4_128_SHA,                      /* 0xC002 */
-             "ECDH-ECDSA-RC4-SHA",
-             CIPHER_WEAK_RC_ENCRYPTION),
-  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA,                 /* 0xC003 */
-             "ECDH-ECDSA-DES-CBC3-SHA",
-             CIPHER_WEAK_3DES_ENCRYPTION),
-  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA,                  /* 0xC004 */
-             "ECDH-ECDSA-AES128-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA,                  /* 0xC005 */
-             "ECDH-ECDSA-AES256-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_NULL_SHA,                        /* 0xC006 */
-             "ECDHE-ECDSA-NULL-SHA",
-             CIPHER_WEAK_NOT_ENCRYPTED),
-  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,                     /* 0xC007 */
-             "ECDHE-ECDSA-RC4-SHA",
-             CIPHER_WEAK_RC_ENCRYPTION),
-  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,                /* 0xC008 */
-             "ECDHE-ECDSA-DES-CBC3-SHA",
-             CIPHER_WEAK_3DES_ENCRYPTION),
-  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,                 /* 0xC009 */
-             "ECDHE-ECDSA-AES128-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,                 /* 0xC00A */
-             "ECDHE-ECDSA-AES256-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDH_RSA_WITH_NULL_SHA,                           /* 0xC00B */
-             "ECDH-RSA-NULL-SHA",
-             CIPHER_WEAK_NOT_ENCRYPTED),
-  CIPHER_DEF(TLS_ECDH_RSA_WITH_RC4_128_SHA,                        /* 0xC00C */
-             "ECDH-RSA-RC4-SHA",
-             CIPHER_WEAK_RC_ENCRYPTION),
-  CIPHER_DEF(TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA,                   /* 0xC00D */
-             "ECDH-RSA-DES-CBC3-SHA",
-             CIPHER_WEAK_3DES_ENCRYPTION),
-  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_128_CBC_SHA,                    /* 0xC00E */
-             "ECDH-RSA-AES128-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_256_CBC_SHA,                    /* 0xC00F */
-             "ECDH-RSA-AES256-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDHE_RSA_WITH_NULL_SHA,                          /* 0xC010 */
-             "ECDHE-RSA-NULL-SHA",
-             CIPHER_WEAK_NOT_ENCRYPTED),
-  CIPHER_DEF(TLS_ECDHE_RSA_WITH_RC4_128_SHA,                       /* 0xC011 */
-             "ECDHE-RSA-RC4-SHA",
-             CIPHER_WEAK_RC_ENCRYPTION),
-  CIPHER_DEF(TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,                  /* 0xC012 */
-             "ECDHE-RSA-DES-CBC3-SHA",
-             CIPHER_WEAK_3DES_ENCRYPTION),
-  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,                   /* 0xC013 */
-             "ECDHE-RSA-AES128-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,                   /* 0xC014 */
-             "ECDHE-RSA-AES256-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDH_anon_WITH_NULL_SHA,                          /* 0xC015 */
-             "AECDH-NULL-SHA",
-             CIPHER_WEAK_ANON_AUTH),
-  CIPHER_DEF(TLS_ECDH_anon_WITH_RC4_128_SHA,                       /* 0xC016 */
-             "AECDH-RC4-SHA",
-             CIPHER_WEAK_ANON_AUTH),
-  CIPHER_DEF(TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA,                  /* 0xC017 */
-             "AECDH-DES-CBC3-SHA",
-             CIPHER_WEAK_3DES_ENCRYPTION),
-  CIPHER_DEF(TLS_ECDH_anon_WITH_AES_128_CBC_SHA,                   /* 0xC018 */
-             "AECDH-AES128-SHA",
-             CIPHER_WEAK_ANON_AUTH),
-  CIPHER_DEF(TLS_ECDH_anon_WITH_AES_256_CBC_SHA,                   /* 0xC019 */
-             "AECDH-AES256-SHA",
-             CIPHER_WEAK_ANON_AUTH),
+  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,             /* 0xC009 */
+  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,             /* 0xC00A */
+  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,               /* 0xC013 */
+  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,               /* 0xC014 */
 #endif /* CURL_BUILD_MAC_10_6 || CURL_BUILD_IOS */
 
 #if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS
-  /* Addenda from rfc 5289  Elliptic Curve Cipher Suites with
-     HMAC SHA-256/384. */
-  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,              /* 0xC023 */
-             "ECDHE-ECDSA-AES128-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,              /* 0xC024 */
-             "ECDHE-ECDSA-AES256-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256,               /* 0xC025 */
-             "ECDH-ECDSA-AES128-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384,               /* 0xC026 */
-             "ECDH-ECDSA-AES256-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,                /* 0xC027 */
-             "ECDHE-RSA-AES128-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,                /* 0xC028 */
-             "ECDHE-RSA-AES256-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256,                 /* 0xC029 */
-             "ECDH-RSA-AES128-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384,                 /* 0xC02A */
-             "ECDH-RSA-AES256-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  /* Addenda from rfc 5289  Elliptic Curve Cipher Suites with
-     SHA-256/384 and AES Galois Counter Mode (GCM) */
-  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,              /* 0xC02B */
-             "ECDHE-ECDSA-AES128-GCM-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,              /* 0xC02C */
-             "ECDHE-ECDSA-AES256-GCM-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256,               /* 0xC02D */
-             "ECDH-ECDSA-AES128-GCM-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384,               /* 0xC02E */
-             "ECDH-ECDSA-AES256-GCM-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,                /* 0xC02F */
-             "ECDHE-RSA-AES128-GCM-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,                /* 0xC030 */
-             "ECDHE-RSA-AES256-GCM-SHA384",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256,                 /* 0xC031 */
-             "ECDH-RSA-AES128-GCM-SHA256",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384,                 /* 0xC032 */
-             "ECDH-RSA-AES256-GCM-SHA384",
-             CIPHER_STRONG_ENOUGH),
+  TLS_RSA_WITH_AES_128_CBC_SHA256,                  /* 0x003C */
+  TLS_RSA_WITH_AES_256_CBC_SHA256,                  /* 0x003D */
+  TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,              /* 0x0067 */
+  TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,              /* 0x006B */
+  TLS_RSA_WITH_AES_128_GCM_SHA256,                  /* 0x009C */
+  TLS_RSA_WITH_AES_256_GCM_SHA384,                  /* 0x009D */
+  TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,              /* 0x009E */
+  TLS_DHE_RSA_WITH_AES_256_GCM_SHA384,              /* 0x009F */
+  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,          /* 0xC023 */
+  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,          /* 0xC024 */
+  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,            /* 0xC027 */
+  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,            /* 0xC028 */
+  TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,          /* 0xC02B */
+  TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,          /* 0xC02C */
+  TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,            /* 0xC02F */
+  TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,            /* 0xC030 */
 #endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */
 
-#if CURL_BUILD_MAC_10_15 || CURL_BUILD_IOS_13
-  /* ECDHE_PSK Cipher Suites for Transport Layer Security (TLS), RFC 5489 */
-  CIPHER_DEF(TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA,                   /* 0xC035 */
-             "ECDHE-PSK-AES128-CBC-SHA",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA,                   /* 0xC036 */
-             "ECDHE-PSK-AES256-CBC-SHA",
-             CIPHER_STRONG_ENOUGH),
-#endif /* CURL_BUILD_MAC_10_15 || CURL_BUILD_IOS_13 */
-
 #if CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11
-  /* Addenda from rfc 7905  ChaCha20-Poly1305 Cipher Suites for
-     Transport Layer Security (TLS). */
-  CIPHER_DEF(TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,          /* 0xCCA8 */
-             "ECDHE-RSA-CHACHA20-POLY1305",
-             CIPHER_STRONG_ENOUGH),
-  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,        /* 0xCCA9 */
-             "ECDHE-ECDSA-CHACHA20-POLY1305",
-             CIPHER_STRONG_ENOUGH),
+  TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,      /* 0xCCA8 */
+  TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,    /* 0xCCA9 */
+
+  /* TLSv1.3 is not supported by sectransp, but there is also other
+   * code referencing TLSv1.3, like: kTLSProtocol13 ? */
+  TLS_AES_128_GCM_SHA256,                           /* 0x1301 */
+  TLS_AES_256_GCM_SHA384,                           /* 0x1302 */
+  TLS_CHACHA20_POLY1305_SHA256,                     /* 0x1303 */
 #endif /* CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11 */
-
-#if CURL_BUILD_MAC_10_15 || CURL_BUILD_IOS_13
-  /* ChaCha20-Poly1305 Cipher Suites for Transport Layer Security (TLS),
-     RFC 7905 */
-  CIPHER_DEF(TLS_PSK_WITH_CHACHA20_POLY1305_SHA256,                /* 0xCCAB */
-             "PSK-CHACHA20-POLY1305",
-             CIPHER_STRONG_ENOUGH),
-#endif /* CURL_BUILD_MAC_10_15 || CURL_BUILD_IOS_13 */
-
-  /* Tags for SSL 2 cipher kinds which are not specified for SSL 3.
-     Defined since SDK 10.2.8 */
-  CIPHER_DEF(SSL_RSA_WITH_RC2_CBC_MD5,                             /* 0xFF80 */
-             NULL,
-             CIPHER_WEAK_RC_ENCRYPTION),
-  CIPHER_DEF(SSL_RSA_WITH_IDEA_CBC_MD5,                            /* 0xFF81 */
-             NULL,
-             CIPHER_WEAK_IDEA_ENCRYPTION),
-  CIPHER_DEF(SSL_RSA_WITH_DES_CBC_MD5,                             /* 0xFF82 */
-             NULL,
-             CIPHER_WEAK_DES_ENCRYPTION),
-  CIPHER_DEF(SSL_RSA_WITH_3DES_EDE_CBC_MD5,                        /* 0xFF83 */
-             NULL,
-             CIPHER_WEAK_3DES_ENCRYPTION),
 };
 
-#define NUM_OF_CIPHERS sizeof(ciphertable)/sizeof(ciphertable[0])
+#define DEFAULT_CIPHERS_LEN sizeof(default_ciphers)/sizeof(default_ciphers[0])
 
 
 /* pinned public key support tests */
@@ -816,7 +240,7 @@ static const unsigned char rsa2048SpkiHeader[] = {
                                        0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05,
                                        0x00, 0x03, 0x82, 0x01, 0x0f, 0x00};
 #ifdef SECTRANSP_PINNEDPUBKEY_V1
-/* the *new* version doesn't return DER encoded ecdsa certs like the old... */
+/* the *new* version does not return DER encoded ecdsa certs like the old... */
 static const unsigned char ecDsaSecp256r1SpkiHeader[] = {
                                        0x30, 0x59, 0x30, 0x13, 0x06, 0x07,
                                        0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02,
@@ -906,25 +330,6 @@ static OSStatus sectransp_bio_cf_out_write(SSLConnectionRef connection,
   return rtn;
 }
 
-CF_INLINE const char *TLSCipherNameForNumber(SSLCipherSuite cipher)
-{
-  /* The first ciphers in the ciphertable are continuous. Here we do small
-     optimization and instead of loop directly get SSL name by cipher number.
-  */
-  size_t i;
-  if(cipher <= SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA) {
-    return ciphertable[cipher].name;
-  }
-  /* Iterate through the rest of the ciphers */
-  for(i = SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA + 1; i < NUM_OF_CIPHERS;
-      ++i) {
-    if(ciphertable[i].num == cipher) {
-      return ciphertable[i].name;
-    }
-  }
-  return ciphertable[SSL_NULL_WITH_NULL_NULL].name;
-}
-
 #if CURL_BUILD_MAC
 CF_INLINE void GetDarwinVersionNumber(int *major, int *minor)
 {
@@ -957,27 +362,27 @@ CF_INLINE void GetDarwinVersionNumber(int *major, int *minor)
 #endif /* CURL_BUILD_MAC */
 
 /* Apple provides a myriad of ways of getting information about a certificate
-   into a string. Some aren't available under iOS or newer cats. So here's
-   a unified function for getting a string describing the certificate that
-   ought to work in all cats starting with Leopard. */
+   into a string. Some are not available under iOS or newer cats. Here's a
+   unified function for getting a string describing the certificate that ought
+   to work in all cats starting with Leopard. */
 CF_INLINE CFStringRef getsubject(SecCertificateRef cert)
 {
   CFStringRef server_cert_summary = CFSTR("(null)");
 
 #if CURL_BUILD_IOS
-  /* iOS: There's only one way to do this. */
+  /* iOS: There is only one way to do this. */
   server_cert_summary = SecCertificateCopySubjectSummary(cert);
 #else
 #if CURL_BUILD_MAC_10_7
   /* Lion & later: Get the long description if we can. */
-  if(SecCertificateCopyLongDescription)
+  if(&SecCertificateCopyLongDescription)
     server_cert_summary =
       SecCertificateCopyLongDescription(NULL, cert, NULL);
   else
 #endif /* CURL_BUILD_MAC_10_7 */
 #if CURL_BUILD_MAC_10_6
   /* Snow Leopard: Get the certificate summary. */
-  if(SecCertificateCopySubjectSummary)
+  if(&SecCertificateCopySubjectSummary)
     server_cert_summary = SecCertificateCopySubjectSummary(cert);
   else
 #endif /* CURL_BUILD_MAC_10_6 */
@@ -1015,7 +420,7 @@ static CURLcode CopyCertSubject(struct Curl_easy *data,
     size_t cbuf_size = ((size_t)CFStringGetLength(c) * 4) + 1;
     cbuf = calloc(1, cbuf_size);
     if(cbuf) {
-      if(!CFStringGetCString(c, cbuf, cbuf_size,
+      if(!CFStringGetCString(c, cbuf, (CFIndex)cbuf_size,
                              kCFStringEncodingUTF8)) {
         failf(data, "SSL: invalid CA certificate subject");
         result = CURLE_PEER_FAILED_VERIFICATION;
@@ -1025,7 +430,7 @@ static CURLcode CopyCertSubject(struct Curl_easy *data,
         *certp = cbuf;
     }
     else {
-      failf(data, "SSL: couldn't allocate %zu bytes of memory", cbuf_size);
+      failf(data, "SSL: could not allocate %zu bytes of memory", cbuf_size);
       result = CURLE_OUT_OF_MEMORY;
     }
   }
@@ -1037,7 +442,7 @@ static CURLcode CopyCertSubject(struct Curl_easy *data,
 
 #if CURL_SUPPORT_MAC_10_6
 /* The SecKeychainSearch API was deprecated in Lion, and using it will raise
-   deprecation warnings, so let's not compile this unless it's necessary: */
+   deprecation warnings, so let's not compile this unless it is necessary: */
 static OSStatus CopyIdentityWithLabelOldSchool(char *label,
                                                SecIdentityRef *out_c_a_k)
 {
@@ -1090,7 +495,7 @@ static OSStatus CopyIdentityWithLabel(char *label,
   /* SecItemCopyMatching() was introduced in iOS and Snow Leopard.
      kSecClassIdentity was introduced in Lion. If both exist, let's use them
      to find the certificate. */
-  if(SecItemCopyMatching && kSecClassIdentity) {
+  if(&SecItemCopyMatching && kSecClassIdentity) {
     CFTypeRef keys[5];
     CFTypeRef values[5];
     CFDictionaryRef query_dict;
@@ -1108,7 +513,7 @@ static OSStatus CopyIdentityWithLabel(char *label,
     /* identity searches need a SecPolicyRef in order to work */
     values[3] = SecPolicyCreateSSL(false, NULL);
     keys[3] = kSecMatchPolicy;
-    /* match the name of the certificate (doesn't work in macOS 10.12.1) */
+    /* match the name of the certificate (does not work in macOS 10.12.1) */
     values[4] = label_cf;
     keys[4] = kSecAttrLabel;
     query_dict = CFDictionaryCreate(NULL, (const void **)keys,
@@ -1120,7 +525,7 @@ static OSStatus CopyIdentityWithLabel(char *label,
     /* Do we have a match? */
     status = SecItemCopyMatching(query_dict, (CFTypeRef *) &keys_list);
 
-    /* Because kSecAttrLabel matching doesn't work with kSecClassIdentity,
+    /* Because kSecAttrLabel matching does not work with kSecClassIdentity,
      * we need to find the correct identity ourselves */
     if(status == noErr) {
       keys_list_count = CFArrayGetCount(keys_list);
@@ -1194,7 +599,8 @@ static OSStatus CopyIdentityFromPKCS12File(const char *cPath,
 
   if(blob) {
     pkcs_data = CFDataCreate(kCFAllocatorDefault,
-                             (const unsigned char *)blob->data, blob->len);
+                             (const unsigned char *)blob->data,
+                             (CFIndex)blob->len);
     status = (pkcs_data != NULL) ? errSecSuccess : errSecAllocate;
     resource_imported = (pkcs_data != NULL);
   }
@@ -1202,7 +608,7 @@ static OSStatus CopyIdentityFromPKCS12File(const char *cPath,
     pkcs_url =
       CFURLCreateFromFileSystemRepresentation(NULL,
                                               (const UInt8 *)cPath,
-                                              strlen(cPath), false);
+                                              (CFIndex)strlen(cPath), false);
     resource_imported =
       CFURLCreateDataAndPropertiesFromResource(NULL,
                                                pkcs_url, &pkcs_data,
@@ -1231,7 +637,7 @@ static OSStatus CopyIdentityFromPKCS12File(const char *cPath,
   /* On macOS SecPKCS12Import will always add the client certificate to
    * the Keychain.
    *
-   * As this doesn't match iOS, and apps may not want to see their client
+   * As this does not match iOS, and apps may not want to see their client
    * certificate saved in the user's keychain, we use SecItemImport
    * with a NULL keychain to avoid importing it.
    *
@@ -1327,13 +733,14 @@ static CURLcode sectransp_version_from_curl(SSLProtocol *darwinver,
       return CURLE_OK;
     case CURL_SSLVERSION_TLSv1_3:
       /* TLS 1.3 support first appeared in iOS 11 and macOS 10.13 */
-#if (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && HAVE_BUILTIN_AVAILABLE == 1
+#if (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && \
+    defined(HAVE_BUILTIN_AVAILABLE)
       if(__builtin_available(macOS 10.13, iOS 11.0, *)) {
         *darwinver = kTLSProtocol13;
         return CURLE_OK;
       }
 #endif /* (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) &&
-          HAVE_BUILTIN_AVAILABLE == 1 */
+          defined(HAVE_BUILTIN_AVAILABLE) */
       break;
   }
   return CURLE_SSL_CONNECT_ERROR;
@@ -1356,7 +763,8 @@ static CURLcode set_ssl_version_min_max(struct Curl_cfilter *cf,
   /* macOS 10.5-10.7 supported TLS 1.0 only.
      macOS 10.8 and later, and iOS 5 and later, added TLS 1.1 and 1.2.
      macOS 10.13 and later, and iOS 11 and later, added TLS 1.3. */
-#if (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && HAVE_BUILTIN_AVAILABLE == 1
+#if (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && \
+    defined(HAVE_BUILTIN_AVAILABLE)
   if(__builtin_available(macOS 10.13, iOS 11.0, *)) {
     max_supported_version_by_os = CURL_SSLVERSION_MAX_TLSv1_3;
   }
@@ -1366,7 +774,7 @@ static CURLcode set_ssl_version_min_max(struct Curl_cfilter *cf,
 #else
   max_supported_version_by_os = CURL_SSLVERSION_MAX_TLSv1_2;
 #endif /* (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) &&
-          HAVE_BUILTIN_AVAILABLE == 1 */
+          defined(HAVE_BUILTIN_AVAILABLE) */
 
   switch(ssl_version) {
     case CURL_SSLVERSION_DEFAULT:
@@ -1383,7 +791,7 @@ static CURLcode set_ssl_version_min_max(struct Curl_cfilter *cf,
   }
 
 #if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS
-  if(SSLSetProtocolVersionMax) {
+  if(&SSLSetProtocolVersionMax) {
     SSLProtocol darwin_ver_min = kTLSProtocol1;
     SSLProtocol darwin_ver_max = kTLSProtocol1;
     CURLcode result = sectransp_version_from_curl(&darwin_ver_min,
@@ -1439,208 +847,223 @@ static CURLcode set_ssl_version_min_max(struct Curl_cfilter *cf,
   return CURLE_SSL_CONNECT_ERROR;
 }
 
-static bool is_cipher_suite_strong(SSLCipherSuite suite_num)
+static int sectransp_cipher_suite_get_str(uint16_t id, char *buf,
+                                          size_t buf_size, bool prefer_rfc)
 {
-  size_t i;
-  for(i = 0; i < NUM_OF_CIPHERS; ++i) {
-    if(ciphertable[i].num == suite_num) {
-      return !ciphertable[i].weak;
-    }
-  }
-  /* If the cipher is not in our list, assume it is a new one
-     and therefore strong. Previous implementation was the same,
-     if cipher suite is not in the list, it was considered strong enough */
-  return true;
+  /* are these fortezza suites even supported ? */
+  if(id == SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA)
+    msnprintf(buf, buf_size, "%s", "SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA");
+  else if(id == SSL_FORTEZZA_DMS_WITH_NULL_SHA)
+    msnprintf(buf, buf_size, "%s", "SSL_FORTEZZA_DMS_WITH_NULL_SHA");
+  /* can TLS_EMPTY_RENEGOTIATION_INFO_SCSV even be set ? */
+  else if(id == TLS_EMPTY_RENEGOTIATION_INFO_SCSV)
+    msnprintf(buf, buf_size, "%s", "TLS_EMPTY_RENEGOTIATION_INFO_SCSV");
+  /* do we still need to support these SSL2-only ciphers ? */
+  else if(id == SSL_RSA_WITH_RC2_CBC_MD5)
+    msnprintf(buf, buf_size, "%s", "SSL_RSA_WITH_RC2_CBC_MD5");
+  else if(id == SSL_RSA_WITH_IDEA_CBC_MD5)
+    msnprintf(buf, buf_size, "%s", "SSL_RSA_WITH_IDEA_CBC_MD5");
+  else if(id == SSL_RSA_WITH_DES_CBC_MD5)
+    msnprintf(buf, buf_size, "%s", "SSL_RSA_WITH_DES_CBC_MD5");
+  else if(id == SSL_RSA_WITH_3DES_EDE_CBC_MD5)
+    msnprintf(buf, buf_size, "%s", "SSL_RSA_WITH_3DES_EDE_CBC_MD5");
+  else
+    return Curl_cipher_suite_get_str(id, buf, buf_size, prefer_rfc);
+  return 0;
 }
 
-static bool sectransp_is_separator(char c)
+static uint16_t sectransp_cipher_suite_walk_str(const char **str,
+                                                const char **end)
 {
-  /* Return whether character is a cipher list separator. */
-  switch(c) {
-  case ' ':
-  case '\t':
-  case ':':
-  case ',':
-  case ';':
-    return true;
-  }
-  return false;
+  uint16_t id = Curl_cipher_suite_walk_str(str, end);
+  size_t len = *end - *str;
+
+  if(!id) {
+    /* are these fortezza suites even supported ? */
+    if(strncasecompare("SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA", *str, len))
+      id = SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA;
+    else if(strncasecompare("SSL_FORTEZZA_DMS_WITH_NULL_SHA", *str, len))
+      id = SSL_FORTEZZA_DMS_WITH_NULL_SHA;
+    /* can TLS_EMPTY_RENEGOTIATION_INFO_SCSV even be set ? */
+    else if(strncasecompare("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", *str, len))
+      id = TLS_EMPTY_RENEGOTIATION_INFO_SCSV;
+    /* do we still need to support these SSL2-only ciphers ? */
+    else if(strncasecompare("SSL_RSA_WITH_RC2_CBC_MD5", *str, len))
+      id = SSL_RSA_WITH_RC2_CBC_MD5;
+    else if(strncasecompare("SSL_RSA_WITH_IDEA_CBC_MD5", *str, len))
+      id = SSL_RSA_WITH_IDEA_CBC_MD5;
+    else if(strncasecompare("SSL_RSA_WITH_DES_CBC_MD5", *str, len))
+      id = SSL_RSA_WITH_DES_CBC_MD5;
+    else if(strncasecompare("SSL_RSA_WITH_3DES_EDE_CBC_MD5", *str, len))
+      id = SSL_RSA_WITH_3DES_EDE_CBC_MD5;
+  }
+  return id;
 }
 
-static CURLcode sectransp_set_default_ciphers(struct Curl_easy *data,
-                                              SSLContextRef ssl_ctx)
+/* allocated memory must be freed */
+static SSLCipherSuite * sectransp_get_supported_ciphers(SSLContextRef ssl_ctx,
+                                                        size_t *len)
 {
-  size_t all_ciphers_count = 0UL, allowed_ciphers_count = 0UL, i;
-  SSLCipherSuite *all_ciphers = NULL, *allowed_ciphers = NULL;
+  SSLCipherSuite *ciphers = NULL;
   OSStatus err = noErr;
+  *len = 0;
 
-#if CURL_BUILD_MAC
-  int darwinver_maj = 0, darwinver_min = 0;
+  err = SSLGetNumberSupportedCiphers(ssl_ctx, len);
+  if(err != noErr)
+    goto failed;
 
-  GetDarwinVersionNumber(&darwinver_maj, &darwinver_min);
-#endif /* CURL_BUILD_MAC */
+  ciphers = malloc(*len * sizeof(SSLCipherSuite));
+  if(!ciphers)
+    goto failed;
+
+  err = SSLGetSupportedCiphers(ssl_ctx, ciphers, len);
+  if(err != noErr)
+    goto failed;
 
-  /* Disable cipher suites that ST supports but are not safe. These ciphers
-     are unlikely to be used in any case since ST gives other ciphers a much
-     higher priority, but it's probably better that we not connect at all than
-     to give the user a false sense of security if the server only supports
-     insecure ciphers. (Note: We don't care about SSLv2-only ciphers.) */
-  err = SSLGetNumberSupportedCiphers(ssl_ctx, &all_ciphers_count);
-  if(err != noErr) {
-    failf(data, "SSL: SSLGetNumberSupportedCiphers() failed: OSStatus %d",
-          err);
-    return CURLE_SSL_CIPHER;
-  }
-  all_ciphers = malloc(all_ciphers_count*sizeof(SSLCipherSuite));
-  if(!all_ciphers) {
-    failf(data, "SSL: Failed to allocate memory for all ciphers");
-    return CURLE_OUT_OF_MEMORY;
-  }
-  allowed_ciphers = malloc(all_ciphers_count*sizeof(SSLCipherSuite));
-  if(!allowed_ciphers) {
-    Curl_safefree(all_ciphers);
-    failf(data, "SSL: Failed to allocate memory for allowed ciphers");
-    return CURLE_OUT_OF_MEMORY;
-  }
-  err = SSLGetSupportedCiphers(ssl_ctx, all_ciphers,
-                               &all_ciphers_count);
-  if(err != noErr) {
-    Curl_safefree(all_ciphers);
-    Curl_safefree(allowed_ciphers);
-    return CURLE_SSL_CIPHER;
-  }
-  for(i = 0UL ; i < all_ciphers_count ; i++) {
 #if CURL_BUILD_MAC
-   /* There's a known bug in early versions of Mountain Lion where ST's ECC
-      ciphers (cipher suite 0xC001 through 0xC032) simply do not work.
-      Work around the problem here by disabling those ciphers if we are
-      running in an affected version of OS X. */
-    if(darwinver_maj == 12 && darwinver_min <= 3 &&
-       all_ciphers[i] >= 0xC001 && all_ciphers[i] <= 0xC032) {
-      continue;
+  {
+    int maj = 0, min = 0;
+    GetDarwinVersionNumber(&maj, &min);
+    /* There is a known bug in early versions of Mountain Lion where ST's ECC
+       ciphers (cipher suite 0xC001 through 0xC032) simply do not work.
+       Work around the problem here by disabling those ciphers if we are
+       running in an affected version of OS X. */
+    if(maj == 12 && min <= 3) {
+      size_t i = 0, j = 0;
+      for(; i < *len; i++) {
+        if(ciphers[i] >= 0xC001 && ciphers[i] <= 0xC032)
+          continue;
+        ciphers[j++] = ciphers[i];
+      }
+      *len = j;
     }
-#endif /* CURL_BUILD_MAC */
-    if(is_cipher_suite_strong(all_ciphers[i])) {
-      allowed_ciphers[allowed_ciphers_count++] = all_ciphers[i];
+  }
+#endif
+
+  return ciphers;
+failed:
+  *len = 0;
+  Curl_safefree(ciphers);
+  return NULL;
+}
+
+static CURLcode sectransp_set_default_ciphers(struct Curl_easy *data,
+                                              SSLContextRef ssl_ctx)
+{
+  CURLcode ret = CURLE_SSL_CIPHER;
+  size_t count = 0, i, j;
+  OSStatus err;
+  size_t supported_len;
+  SSLCipherSuite *ciphers = NULL;
+
+  ciphers = sectransp_get_supported_ciphers(ssl_ctx, &supported_len);
+  if(!ciphers) {
+    failf(data, "SSL: Failed to get supported ciphers");
+    goto failed;
+  }
+
+  /* Intersect the ciphers supported by Secure Transport with the default
+   * ciphers, using the order of the former. */
+  for(i = 0; i < supported_len; i++) {
+    for(j = 0; j < DEFAULT_CIPHERS_LEN; j++) {
+      if(default_ciphers[j] == ciphers[i]) {
+        ciphers[count++] = ciphers[i];
+        break;
+      }
     }
   }
-  err = SSLSetEnabledCiphers(ssl_ctx, allowed_ciphers,
-                             allowed_ciphers_count);
-  Curl_safefree(all_ciphers);
-  Curl_safefree(allowed_ciphers);
+
+  if(count == 0) {
+    failf(data, "SSL: no supported default ciphers");
+    goto failed;
+  }
+
+  err = SSLSetEnabledCiphers(ssl_ctx, ciphers, count);
   if(err != noErr) {
     failf(data, "SSL: SSLSetEnabledCiphers() failed: OSStatus %d", err);
-    return CURLE_SSL_CIPHER;
+    goto failed;
   }
-  return CURLE_OK;
+
+  ret = CURLE_OK;
+failed:
+  Curl_safefree(ciphers);
+  return ret;
 }
 
 static CURLcode sectransp_set_selected_ciphers(struct Curl_easy *data,
                                                SSLContextRef ssl_ctx,
                                                const char *ciphers)
 {
-  size_t ciphers_count = 0;
-  const char *cipher_start = ciphers;
-  OSStatus err = noErr;
-  SSLCipherSuite selected_ciphers[NUM_OF_CIPHERS];
+  CURLcode ret = CURLE_SSL_CIPHER;
+  size_t count = 0, i;
+  const char *ptr, *end;
+  OSStatus err;
+  size_t supported_len;
+  SSLCipherSuite *supported = NULL;
+  SSLCipherSuite *selected = NULL;
 
-  if(!ciphers)
-    return CURLE_OK;
+  supported = sectransp_get_supported_ciphers(ssl_ctx, &supported_len);
+  if(!supported) {
+    failf(data, "SSL: Failed to get supported ciphers");
+    goto failed;
+  }
 
-  while(sectransp_is_separator(*ciphers))  /* Skip initial separators. */
-    ciphers++;
-  if(!*ciphers)
-    return CURLE_OK;
+  selected = malloc(supported_len * sizeof(SSLCipherSuite));
+  if(!selected) {
+    failf(data, "SSL: Failed to allocate memory");
+    goto failed;
+  }
 
-  cipher_start = ciphers;
-  while(*cipher_start && ciphers_count < NUM_OF_CIPHERS) {
-    bool cipher_found = FALSE;
-    size_t cipher_len = 0;
-    const char *cipher_end = NULL;
-    bool tls_name = FALSE;
-    size_t i;
-
-    /* Skip separators */
-    while(sectransp_is_separator(*cipher_start))
-      cipher_start++;
-    if(*cipher_start == '\0') {
-      break;
-    }
-    /* Find last position of a cipher in the ciphers string */
-    cipher_end = cipher_start;
-    while(*cipher_end != '\0' && !sectransp_is_separator(*cipher_end)) {
-      ++cipher_end;
-    }
+  for(ptr = ciphers; ptr[0] != '\0' && count < supported_len; ptr = end) {
+    uint16_t id = sectransp_cipher_suite_walk_str(&ptr, &end);
 
-    /* IANA cipher names start with the TLS_ or SSL_ prefix.
-       If the 4th symbol of the cipher is '_' we look for a cipher in the
-       table by its (TLS) name.
-       Otherwise, we try to match cipher by an alias. */
-    if(cipher_start[3] == '_') {
-      tls_name = TRUE;
+    /* Check if cipher is supported */
+    if(id) {
+      for(i = 0; i < supported_len && supported[i] != id; i++);
+      if(i == supported_len)
+        id = 0;
     }
-    /* Iterate through the cipher table and look for the cipher, starting
-       the cipher number 0x01 because the 0x00 is not the real cipher */
-    cipher_len = cipher_end - cipher_start;
-    for(i = 1; i < NUM_OF_CIPHERS; ++i) {
-      const char *table_cipher_name = NULL;
-      if(tls_name) {
-        table_cipher_name = ciphertable[i].name;
-      }
-      else if(ciphertable[i].alias_name) {
-        table_cipher_name = ciphertable[i].alias_name;
-      }
-      else {
-        continue;
-      }
-      /* Compare a part of the string between separators with a cipher name
-         in the table and make sure we matched the whole cipher name */
-      if(strncmp(cipher_start, table_cipher_name, cipher_len) == 0
-          && table_cipher_name[cipher_len] == '\0') {
-        selected_ciphers[ciphers_count] = ciphertable[i].num;
-        ++ciphers_count;
-        cipher_found = TRUE;
-        break;
-      }
-    }
-    if(!cipher_found) {
-      /* It would be more human-readable if we print the wrong cipher name
-         but we don't want to allocate any additional memory and copy the name
-         into it, then add it into logs.
-         Also, we do not modify an original cipher list string. We just point
-         to positions where cipher starts and ends in the cipher list string.
-         The message is a bit cryptic and longer than necessary but can be
-         understood by humans. */
-      failf(data, "SSL: cipher string \"%s\" contains unsupported cipher name"
-            " starting position %zd and ending position %zd",
-            ciphers,
-            cipher_start - ciphers,
-            cipher_end - ciphers);
-      return CURLE_SSL_CIPHER;
-    }
-    if(*cipher_end) {
-      cipher_start = cipher_end + 1;
+    if(!id) {
+      if(ptr[0] != '\0')
+        infof(data, "SSL: unknown cipher in list: \"%.*s\"", (int) (end - ptr),
+              ptr);
+      continue;
     }
-    else {
-      break;
+
+    /* No duplicates allowed (so selected cannot overflow) */
+    for(i = 0; i < count && selected[i] != id; i++);
+    if(i < count) {
+      infof(data, "SSL: duplicate cipher in list: \"%.*s\"", (int) (end - ptr),
+            ptr);
+      continue;
     }
+
+    selected[count++] = id;
+  }
+
+  if(count == 0) {
+    failf(data, "SSL: no supported cipher in list");
+    goto failed;
   }
-  /* All cipher suites in the list are found. Report to logs as-is */
-  infof(data, "SSL: Setting cipher suites list \"%s\"", ciphers);
 
-  err = SSLSetEnabledCiphers(ssl_ctx, selected_ciphers, ciphers_count);
+  err = SSLSetEnabledCiphers(ssl_ctx, selected, count);
   if(err != noErr) {
     failf(data, "SSL: SSLSetEnabledCiphers() failed: OSStatus %d", err);
-    return CURLE_SSL_CIPHER;
+    goto failed;
   }
-  return CURLE_OK;
+
+  ret = CURLE_OK;
+failed:
+  Curl_safefree(supported);
+  Curl_safefree(selected);
+  return ret;
 }
 
 static void sectransp_session_free(void *sessionid, size_t idsize)
 {
   /* ST, as of iOS 5 and Mountain Lion, has no public method of deleting a
      cached session ID inside the Security framework. There is a private
-     function that does this, but I don't want to have to explain to you why I
+     function that does this, but I do not want to have to explain to you why I
      got your application rejected from the App Store due to the use of a
      private API, so the best we can do is free up our own char array that we
      created way back in sectransp_connect_step1... */
@@ -1665,6 +1088,7 @@ static CURLcode sectransp_connect_step1(struct Curl_cfilter *cf,
   const struct curl_blob *ssl_cert_blob = ssl_config->primary.cert_blob;
   char *ciphers;
   OSStatus err = noErr;
+  CURLcode result;
 #if CURL_BUILD_MAC
   int darwinver_maj = 0, darwinver_min = 0;
 
@@ -1675,23 +1099,23 @@ static CURLcode sectransp_connect_step1(struct Curl_cfilter *cf,
 #endif /* CURL_BUILD_MAC */
 
 #if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS
-  if(SSLCreateContext) {  /* use the newer API if available */
+  if(&SSLCreateContext) {  /* use the newer API if available */
     if(backend->ssl_ctx)
       CFRelease(backend->ssl_ctx);
     backend->ssl_ctx = SSLCreateContext(NULL, kSSLClientSide, kSSLStreamType);
     if(!backend->ssl_ctx) {
-      failf(data, "SSL: couldn't create a context");
+      failf(data, "SSL: could not create a context");
       return CURLE_OUT_OF_MEMORY;
     }
   }
   else {
-  /* The old ST API does not exist under iOS, so don't compile it: */
+  /* The old ST API does not exist under iOS, so do not compile it: */
 #if CURL_SUPPORT_MAC_10_8
     if(backend->ssl_ctx)
       (void)SSLDisposeContext(backend->ssl_ctx);
     err = SSLNewContext(false, &(backend->ssl_ctx));
     if(err != noErr) {
-      failf(data, "SSL: couldn't create a context: OSStatus %d", err);
+      failf(data, "SSL: could not create a context: OSStatus %d", err);
       return CURLE_OUT_OF_MEMORY;
     }
 #endif /* CURL_SUPPORT_MAC_10_8 */
@@ -1701,19 +1125,20 @@ static CURLcode sectransp_connect_step1(struct Curl_cfilter *cf,
     (void)SSLDisposeContext(backend->ssl_ctx);
   err = SSLNewContext(false, &(backend->ssl_ctx));
   if(err != noErr) {
-    failf(data, "SSL: couldn't create a context: OSStatus %d", err);
+    failf(data, "SSL: could not create a context: OSStatus %d", err);
     return CURLE_OUT_OF_MEMORY;
   }
 #endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */
   backend->ssl_write_buffered_length = 0UL; /* reset buffered write length */
 
-  /* check to see if we've been told to use an explicit SSL/TLS version */
+  /* check to see if we have been told to use an explicit SSL/TLS version */
 #if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS
-  if(SSLSetProtocolVersionMax) {
+  if(&SSLSetProtocolVersionMax) {
     switch(conn_config->version) {
     case CURL_SSLVERSION_TLSv1:
       (void)SSLSetProtocolVersionMin(backend->ssl_ctx, kTLSProtocol1);
-#if (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && HAVE_BUILTIN_AVAILABLE == 1
+#if (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && \
+    defined(HAVE_BUILTIN_AVAILABLE)
       if(__builtin_available(macOS 10.13, iOS 11.0, *)) {
         (void)SSLSetProtocolVersionMax(backend->ssl_ctx, kTLSProtocol13);
       }
@@ -1723,19 +1148,17 @@ static CURLcode sectransp_connect_step1(struct Curl_cfilter *cf,
 #else
       (void)SSLSetProtocolVersionMax(backend->ssl_ctx, kTLSProtocol12);
 #endif /* (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) &&
-          HAVE_BUILTIN_AVAILABLE == 1 */
+          defined(HAVE_BUILTIN_AVAILABLE) */
       break;
     case CURL_SSLVERSION_DEFAULT:
     case CURL_SSLVERSION_TLSv1_0:
     case CURL_SSLVERSION_TLSv1_1:
     case CURL_SSLVERSION_TLSv1_2:
     case CURL_SSLVERSION_TLSv1_3:
-      {
-        CURLcode result = set_ssl_version_min_max(cf, data);
-        if(result != CURLE_OK)
-          return result;
-        break;
-      }
+      result = set_ssl_version_min_max(cf, data);
+      if(result != CURLE_OK)
+        return result;
+      break;
     case CURL_SSLVERSION_SSLv3:
     case CURL_SSLVERSION_SSLv2:
       failf(data, "SSL versions not supported");
@@ -1767,12 +1190,10 @@ static CURLcode sectransp_connect_step1(struct Curl_cfilter *cf,
     case CURL_SSLVERSION_TLSv1_1:
     case CURL_SSLVERSION_TLSv1_2:
     case CURL_SSLVERSION_TLSv1_3:
-      {
-        CURLcode result = set_ssl_version_min_max(cf, data);
-        if(result != CURLE_OK)
-          return result;
-        break;
-      }
+      result = set_ssl_version_min_max(cf, data);
+      if(result != CURLE_OK)
+        return result;
+      break;
     case CURL_SSLVERSION_SSLv3:
     case CURL_SSLVERSION_SSLv2:
       failf(data, "SSL versions not supported");
@@ -1817,7 +1238,8 @@ static CURLcode sectransp_connect_step1(struct Curl_cfilter *cf,
   }
 #endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */
 
-#if (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && HAVE_BUILTIN_AVAILABLE == 1
+#if (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && \
+    defined(HAVE_BUILTIN_AVAILABLE)
   if(connssl->alpn) {
     if(__builtin_available(macOS 10.13.4, iOS 11, tvOS 11, *)) {
       struct alpn_proto_buf proto;
@@ -1886,7 +1308,7 @@ static CURLcode sectransp_connect_step1(struct Curl_cfilter *cf,
       err = SecIdentityCopyCertificate(cert_and_key, &cert);
       if(err == noErr) {
         char *certp;
-        CURLcode result = CopyCertSubject(data, cert, &certp);
+        result = CopyCertSubject(data, cert, &certp);
         if(!result) {
           infof(data, "Client certificate: %s", certp);
           free(certp);
@@ -1929,11 +1351,11 @@ static CURLcode sectransp_connect_step1(struct Curl_cfilter *cf,
                     cert_showfilename_error);
         break;
       case errSecItemNotFound:
-        failf(data, "SSL: Can't find the certificate \"%s\" and its private "
+        failf(data, "SSL: cannot find the certificate \"%s\" and its private "
                     "key in the Keychain.", cert_showfilename_error);
         break;
       default:
-        failf(data, "SSL: Can't load the certificate \"%s\" and its private "
+        failf(data, "SSL: cannot load the certificate \"%s\" and its private "
                     "key: OSStatus %d", cert_showfilename_error, err);
         break;
       }
@@ -1948,7 +1370,7 @@ static CURLcode sectransp_connect_step1(struct Curl_cfilter *cf,
 #if CURL_BUILD_MAC_10_6 || CURL_BUILD_IOS
   /* Snow Leopard introduced the SSLSetSessionOption() function, but due to
      a library bug with the way the kSSLSessionOptionBreakOnServerAuth flag
-     works, it doesn't work as expected under Snow Leopard, Lion or
+     works, it does not work as expected under Snow Leopard, Lion or
      Mountain Lion.
      So we need to call SSLSetEnableCertVerify() on those older cats in order
      to disable certificate validation if the user turned that off.
@@ -1962,9 +1384,9 @@ static CURLcode sectransp_connect_step1(struct Curl_cfilter *cf,
   Darwin 15.x.x is El Capitan (10.11)
   */
 #if CURL_BUILD_MAC
-  if(SSLSetSessionOption && darwinver_maj >= 13) {
+  if(&SSLSetSessionOption && darwinver_maj >= 13) {
 #else
-  if(SSLSetSessionOption) {
+  if(&SSLSetSessionOption) {
 #endif /* CURL_BUILD_MAC */
     bool break_on_auth = !conn_config->verifypeer ||
       ssl_cafile || ssl_cablob;
@@ -2000,7 +1422,7 @@ static CURLcode sectransp_connect_step1(struct Curl_cfilter *cf,
     bool is_cert_file = (!is_cert_data) && is_file(ssl_cafile);
 
     if(!(is_cert_file || is_cert_data)) {
-      failf(data, "SSL: can't load CA certificate file %s",
+      failf(data, "SSL: cannot load CA certificate file %s",
             ssl_cafile ? ssl_cafile : "(blob memory)");
       return CURLE_SSL_CACERT_BADFILE;
     }
@@ -2031,21 +1453,21 @@ static CURLcode sectransp_connect_step1(struct Curl_cfilter *cf,
 
   ciphers = conn_config->cipher_list;
   if(ciphers) {
-    err = sectransp_set_selected_ciphers(data, backend->ssl_ctx, ciphers);
+    result = sectransp_set_selected_ciphers(data, backend->ssl_ctx, ciphers);
   }
   else {
-    err = sectransp_set_default_ciphers(data, backend->ssl_ctx);
+    result = sectransp_set_default_ciphers(data, backend->ssl_ctx);
   }
-  if(err != noErr) {
+  if(result != CURLE_OK) {
     failf(data, "SSL: Unable to set ciphers for SSL/TLS handshake. "
-          "Error code: %d", err);
+          "Error code: %d", (int)result);
     return CURLE_SSL_CIPHER;
   }
 
 #if CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7
   /* We want to enable 1/n-1 when using a CBC cipher unless the user
-     specifically doesn't want us doing that: */
-  if(SSLSetSessionOption) {
+     specifically does not want us doing that: */
+  if(&SSLSetSessionOption) {
     SSLSetSessionOption(backend->ssl_ctx, kSSLSessionOptionSendOneByteRecord,
                         !ssl_config->enable_beast);
     SSLSetSessionOption(backend->ssl_ctx, kSSLSessionOptionFalseStart,
@@ -2053,8 +1475,8 @@ static CURLcode sectransp_connect_step1(struct Curl_cfilter *cf,
   }
 #endif /* CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7 */
 
-  /* Check if there's a cached ID we can/should use here! */
-  if(ssl_config->primary.sessionid) {
+  /* Check if there is a cached ID we can/should use here! */
+  if(ssl_config->primary.cache_session) {
     char *ssl_sessionid;
     size_t ssl_sessionid_len;
 
@@ -2071,10 +1493,9 @@ static CURLcode sectransp_connect_step1(struct Curl_cfilter *cf,
       /* Informational message */
       infof(data, "SSL reusing session ID");
     }
-    /* If there isn't one, then let's make one up! This has to be done prior
+    /* If there is not one, then let's make one up! This has to be done prior
        to starting the handshake. */
     else {
-      CURLcode result;
       ssl_sessionid =
         aprintf("%s:%d:%d:%s:%d",
                 ssl_cafile ? ssl_cafile : "(blob memory)",
@@ -2089,9 +1510,9 @@ static CURLcode sectransp_connect_step1(struct Curl_cfilter *cf,
         return CURLE_SSL_CONNECT_ERROR;
       }
 
-      result = Curl_ssl_addsessionid(cf, data, &connssl->peer, ssl_sessionid,
-                                     ssl_sessionid_len,
-                                     sectransp_session_free);
+      result = Curl_ssl_set_sessionid(cf, data, &connssl->peer, ssl_sessionid,
+                                      ssl_sessionid_len,
+                                      sectransp_session_free);
       Curl_ssl_sessionid_unlock(data);
       if(result)
         return result;
@@ -2121,7 +1542,7 @@ static long pem_to_der(const char *in, unsigned char **out, size_t *outlen)
   char *sep_start, *sep_end, *cert_start, *cert_end;
   size_t i, j, err;
   size_t len;
-  unsigned char *b64;
+  char *b64;
 
   /* Jump through the separators at the beginning of the certificate. */
   sep_start = strstr(in, "-----");
@@ -2202,16 +1623,16 @@ static int read_cert(const char *file, unsigned char **out, size_t *outlen)
   return 0;
 }
 
-static int append_cert_to_array(struct Curl_easy *data,
-                                const unsigned char *buf, size_t buflen,
-                                CFMutableArrayRef array)
+static CURLcode append_cert_to_array(struct Curl_easy *data,
+                                     const unsigned char *buf, size_t buflen,
+                                     CFMutableArrayRef array)
 {
     char *certp;
     CURLcode result;
     SecCertificateRef cacert;
     CFDataRef certdata;
 
-    certdata = CFDataCreate(kCFAllocatorDefault, buf, buflen);
+    certdata = CFDataCreate(kCFAllocatorDefault, buf, (CFIndex)buflen);
     if(!certdata) {
       failf(data, "SSL: failed to allocate array for CA certificate");
       return CURLE_OUT_OF_MEMORY;
@@ -2248,7 +1669,8 @@ static CURLcode verify_cert_buf(struct Curl_cfilter *cf,
                                 const unsigned char *certbuf, size_t buflen,
                                 SSLContextRef ctx)
 {
-  int n = 0, rc;
+  int n = 0;
+  CURLcode rc;
   long res;
   unsigned char *der;
   size_t derlen, offset = 0;
@@ -2419,7 +1841,7 @@ static CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data,
   /* Result is returned to caller */
   CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;
 
-  /* if a path wasn't specified, don't pin */
+  /* if a path was not specified, do not pin */
   if(!pinnedpubkey)
     return CURLE_OK;
 
@@ -2451,17 +1873,17 @@ static CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data,
 #elif SECTRANSP_PINNEDPUBKEY_V2
 
     {
-        OSStatus success;
-        success = SecItemExport(keyRef, kSecFormatOpenSSL, 0, NULL,
-                                &publicKeyBits);
-        CFRelease(keyRef);
-        if(success != errSecSuccess || !publicKeyBits)
-          break;
+      OSStatus success;
+      success = SecItemExport(keyRef, kSecFormatOpenSSL, 0, NULL,
+                              &publicKeyBits);
+      CFRelease(keyRef);
+      if(success != errSecSuccess || !publicKeyBits)
+        break;
     }
 
 #endif /* SECTRANSP_PINNEDPUBKEY_V2 */
 
-    pubkeylen = CFDataGetLength(publicKeyBits);
+    pubkeylen = (size_t)CFDataGetLength(publicKeyBits);
     pubkey = (unsigned char *)CFDataGetBytePtr(publicKeyBits);
 
     switch(pubkeylen) {
@@ -2530,24 +1952,23 @@ static CURLcode sectransp_connect_step2(struct Curl_cfilter *cf,
   SSLCipherSuite cipher;
   SSLProtocol protocol = 0;
 
-  DEBUGASSERT(ssl_connect_2 == connssl->connecting_state
-              || ssl_connect_2_reading == connssl->connecting_state
-              || ssl_connect_2_writing == connssl->connecting_state);
+  DEBUGASSERT(ssl_connect_2 == connssl->connecting_state);
   DEBUGASSERT(backend);
   CURL_TRC_CF(data, cf, "connect_step2");
 
   /* Here goes nothing: */
 check_handshake:
+  connssl->io_need = CURL_SSL_IO_NEED_NONE;
   err = SSLHandshake(backend->ssl_ctx);
 
   if(err != noErr) {
     switch(err) {
-      case errSSLWouldBlock:  /* they're not done with us yet */
-        connssl->connecting_state = backend->ssl_direction ?
-            ssl_connect_2_writing : ssl_connect_2_reading;
+      case errSSLWouldBlock:  /* they are not done with us yet */
+        connssl->io_need = backend->ssl_direction ?
+            CURL_SSL_IO_NEED_SEND : CURL_SSL_IO_NEED_RECV;
         return CURLE_OK;
 
-      /* The below is errSSLServerAuthCompleted; it's not defined in
+      /* The below is errSSLServerAuthCompleted; it is not defined in
         Leopard's headers */
       case -9841:
         if((conn_config->CAfile || conn_config->ca_info_blob) &&
@@ -2657,8 +2078,8 @@ check_handshake:
               "authority");
         break;
 
-      /* This error is raised if the server's cert didn't match the server's
-         host name: */
+      /* This error is raised if the server's cert did not match the server's
+         hostname: */
       case errSSLHostNameMismatch:
         failf(data, "SSL certificate peer verification failed, the "
               "certificate did not match \"%s\"\n", connssl->peer.dispname);
@@ -2759,7 +2180,8 @@ check_handshake:
     return CURLE_SSL_CONNECT_ERROR;
   }
   else {
-    /* we have been connected fine, we're not waiting for anything else. */
+    char cipher_str[64];
+    /* we have been connected fine, we are not waiting for anything else. */
     connssl->connecting_state = ssl_connect_3;
 
 #ifdef SECTRANSP_PINNEDPUBKEY
@@ -2777,33 +2199,30 @@ check_handshake:
     /* Informational message */
     (void)SSLGetNegotiatedCipher(backend->ssl_ctx, &cipher);
     (void)SSLGetNegotiatedProtocolVersion(backend->ssl_ctx, &protocol);
+
+    sectransp_cipher_suite_get_str((uint16_t) cipher, cipher_str,
+                                   sizeof(cipher_str), true);
     switch(protocol) {
       case kSSLProtocol2:
-        infof(data, "SSL 2.0 connection using %s",
-              TLSCipherNameForNumber(cipher));
+        infof(data, "SSL 2.0 connection using %s", cipher_str);
         break;
       case kSSLProtocol3:
-        infof(data, "SSL 3.0 connection using %s",
-              TLSCipherNameForNumber(cipher));
+        infof(data, "SSL 3.0 connection using %s", cipher_str);
         break;
       case kTLSProtocol1:
-        infof(data, "TLS 1.0 connection using %s",
-              TLSCipherNameForNumber(cipher));
+        infof(data, "TLS 1.0 connection using %s", cipher_str);
         break;
 #if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS
       case kTLSProtocol11:
-        infof(data, "TLS 1.1 connection using %s",
-              TLSCipherNameForNumber(cipher));
+        infof(data, "TLS 1.1 connection using %s", cipher_str);
         break;
       case kTLSProtocol12:
-        infof(data, "TLS 1.2 connection using %s",
-              TLSCipherNameForNumber(cipher));
+        infof(data, "TLS 1.2 connection using %s", cipher_str);
         break;
 #endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */
 #if CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11
       case kTLSProtocol13:
-        infof(data, "TLS 1.3 connection using %s",
-              TLSCipherNameForNumber(cipher));
+        infof(data, "TLS 1.3 connection using %s", cipher_str);
         break;
 #endif /* CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11 */
       default:
@@ -2811,7 +2230,8 @@ check_handshake:
         break;
     }
 
-#if(CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && HAVE_BUILTIN_AVAILABLE == 1
+#if (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && \
+    defined(HAVE_BUILTIN_AVAILABLE)
     if(connssl->alpn) {
       if(__builtin_available(macOS 10.13.4, iOS 11, tvOS 11, *)) {
         CFArrayRef alpnArr = NULL;
@@ -2839,7 +2259,7 @@ check_handshake:
                             BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);
 
         /* chosenProtocol is a reference to the string within alpnArr
-           and doesn't need to be freed separately */
+           and does not need to be freed separately */
         if(alpnArr)
           CFRelease(alpnArr);
       }
@@ -2941,10 +2361,10 @@ static CURLcode collect_server_cert(struct Curl_cfilter *cf,
   /* SSLCopyPeerCertificates() is deprecated as of Mountain Lion.
      The function SecTrustGetCertificateAtIndex() is officially present
      in Lion, but it is unfortunately also present in Snow Leopard as
-     private API and doesn't work as expected. So we have to look for
+     private API and does not work as expected. So we have to look for
      a different symbol to make sure this code is only executed under
      Lion or later. */
-  if(SecTrustCopyPublicKey) {
+  if(&SecTrustCopyPublicKey) {
 #pragma unused(server_certs)
     err = SSLCopyPeerTrust(backend->ssl_ctx, &trust);
     /* For some reason, SSLCopyPeerTrust() can return noErr and yet return
@@ -3030,7 +2450,7 @@ sectransp_connect_common(struct Curl_cfilter *cf, struct Curl_easy *data,
   }
 
   if(ssl_connect_1 == connssl->connecting_state) {
-    /* Find out how much more time we're allowed */
+    /* Find out how much more time we are allowed */
     const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);
 
     if(timeout_ms < 0) {
@@ -3044,9 +2464,7 @@ sectransp_connect_common(struct Curl_cfilter *cf, struct Curl_easy *data,
       return result;
   }
 
-  while(ssl_connect_2 == connssl->connecting_state ||
-        ssl_connect_2_reading == connssl->connecting_state ||
-        ssl_connect_2_writing == connssl->connecting_state) {
+  while(ssl_connect_2 == connssl->connecting_state) {
 
     /* check allowed time left */
     const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);
@@ -3057,14 +2475,13 @@ sectransp_connect_common(struct Curl_cfilter *cf, struct Curl_easy *data,
       return CURLE_OPERATION_TIMEDOUT;
     }
 
-    /* if ssl is expecting something, check if it's available. */
-    if(connssl->connecting_state == ssl_connect_2_reading ||
-       connssl->connecting_state == ssl_connect_2_writing) {
+    /* if ssl is expecting something, check if it is available. */
+    if(connssl->io_need) {
 
-      curl_socket_t writefd = ssl_connect_2_writing ==
-      connssl->connecting_state?sockfd:CURL_SOCKET_BAD;
-      curl_socket_t readfd = ssl_connect_2_reading ==
-      connssl->connecting_state?sockfd:CURL_SOCKET_BAD;
+      curl_socket_t writefd = (connssl->io_need & CURL_SSL_IO_NEED_SEND)?
+                              sockfd:CURL_SOCKET_BAD;
+      curl_socket_t readfd = (connssl->io_need & CURL_SSL_IO_NEED_RECV)?
+                             sockfd:CURL_SOCKET_BAD;
 
       what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,
                                nonblocking ? 0 : timeout_ms);
@@ -3094,10 +2511,7 @@ sectransp_connect_common(struct Curl_cfilter *cf, struct Curl_easy *data,
      * or epoll() will always have a valid fdset to wait on.
      */
     result = sectransp_connect_step2(cf, data);
-    if(result || (nonblocking &&
-                  (ssl_connect_2 == connssl->connecting_state ||
-                   ssl_connect_2_reading == connssl->connecting_state ||
-                   ssl_connect_2_writing == connssl->connecting_state)))
+    if(result || (nonblocking && (ssl_connect_2 == connssl->connecting_state)))
       return result;
 
   } /* repeat step2 until all transactions are done. */
@@ -3146,6 +2560,92 @@ static CURLcode sectransp_connect(struct Curl_cfilter *cf,
   return CURLE_OK;
 }
 
+static ssize_t sectransp_recv(struct Curl_cfilter *cf,
+                              struct Curl_easy *data,
+                              char *buf,
+                              size_t buffersize,
+                              CURLcode *curlcode);
+
+static CURLcode sectransp_shutdown(struct Curl_cfilter *cf,
+                                   struct Curl_easy *data,
+                                   bool send_shutdown, bool *done)
+{
+  struct ssl_connect_data *connssl = cf->ctx;
+  struct st_ssl_backend_data *backend =
+    (struct st_ssl_backend_data *)connssl->backend;
+  CURLcode result = CURLE_OK;
+  ssize_t nread;
+  char buf[1024];
+  size_t i;
+
+  DEBUGASSERT(backend);
+  if(!backend->ssl_ctx || cf->shutdown) {
+    *done = TRUE;
+    goto out;
+  }
+
+  connssl->io_need = CURL_SSL_IO_NEED_NONE;
+  *done = FALSE;
+
+  if(send_shutdown && !backend->sent_shutdown) {
+    OSStatus err;
+
+    CURL_TRC_CF(data, cf, "shutdown, send close notify");
+    err = SSLClose(backend->ssl_ctx);
+    switch(err) {
+      case noErr:
+        backend->sent_shutdown = TRUE;
+        break;
+      case errSSLWouldBlock:
+        connssl->io_need = CURL_SSL_IO_NEED_SEND;
+        result = CURLE_OK;
+        goto out;
+      default:
+        CURL_TRC_CF(data, cf, "shutdown, error: %d", (int)err);
+        result = CURLE_SEND_ERROR;
+        goto out;
+    }
+  }
+
+  for(i = 0; i < 10; ++i) {
+    if(!backend->sent_shutdown) {
+      nread = sectransp_recv(cf, data, buf, (int)sizeof(buf), &result);
+    }
+    else {
+      /* We would like to read the close notify from the server using
+       * secure transport, however SSLRead() no longer works after we
+       * sent the notify from our side. So, we just read from the
+       * underlying filter and hope it will end. */
+      nread = Curl_conn_cf_recv(cf->next, data, buf, sizeof(buf), &result);
+    }
+    CURL_TRC_CF(data, cf, "shutdown read -> %zd, %d", nread, result);
+    if(nread <= 0)
+      break;
+  }
+
+  if(nread > 0) {
+    /* still data coming in? */
+    connssl->io_need = CURL_SSL_IO_NEED_RECV;
+  }
+  else if(nread == 0) {
+    /* We got the close notify alert and are done. */
+    CURL_TRC_CF(data, cf, "shutdown done");
+    *done = TRUE;
+  }
+  else if(result == CURLE_AGAIN) {
+    connssl->io_need = CURL_SSL_IO_NEED_RECV;
+    result = CURLE_OK;
+  }
+  else {
+    DEBUGASSERT(result);
+    CURL_TRC_CF(data, cf, "shutdown, error: %d", result);
+  }
+
+out:
+  cf->shutdown = (result || *done);
+  return result;
+}
+
 static void sectransp_close(struct Curl_cfilter *cf, struct Curl_easy *data)
 {
   struct ssl_connect_data *connssl = cf->ctx;
@@ -3158,9 +2658,8 @@ static void sectransp_close(struct Curl_cfilter *cf, struct Curl_easy *data)
 
   if(backend->ssl_ctx) {
     CURL_TRC_CF(data, cf, "close");
-    (void)SSLClose(backend->ssl_ctx);
 #if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS
-    if(SSLCreateContext)
+    if(&SSLCreateContext)
       CFRelease(backend->ssl_ctx);
 #if CURL_SUPPORT_MAC_10_8
     else
@@ -3173,69 +2672,6 @@ static void sectransp_close(struct Curl_cfilter *cf, struct Curl_easy *data)
   }
 }
 
-static int sectransp_shutdown(struct Curl_cfilter *cf,
-                              struct Curl_easy *data)
-{
-  struct ssl_connect_data *connssl = cf->ctx;
-  struct st_ssl_backend_data *backend =
-    (struct st_ssl_backend_data *)connssl->backend;
-  ssize_t nread;
-  int what;
-  int rc;
-  char buf[120];
-  int loop = 10; /* avoid getting stuck */
-  CURLcode result;
-
-  DEBUGASSERT(backend);
-
-  if(!backend->ssl_ctx)
-    return 0;
-
-#ifndef CURL_DISABLE_FTP
-  if(data->set.ftp_ccc != CURLFTPSSL_CCC_ACTIVE)
-    return 0;
-#endif
-
-  sectransp_close(cf, data);
-
-  rc = 0;
-
-  what = SOCKET_READABLE(Curl_conn_cf_get_socket(cf, data),
-                         SSL_SHUTDOWN_TIMEOUT);
-
-  CURL_TRC_CF(data, cf, "shutdown");
-  while(loop--) {
-    if(what < 0) {
-      /* anything that gets here is fatally bad */
-      failf(data, "select/poll on SSL socket, errno: %d", SOCKERRNO);
-      rc = -1;
-      break;
-    }
-
-    if(!what) {                                /* timeout */
-      failf(data, "SSL shutdown timeout");
-      break;
-    }
-
-    /* Something to read, let's do it and hope that it is the close
-     notify alert from the server. No way to SSL_Read now, so use read(). */
-
-    nread = Curl_conn_cf_recv(cf->next, data, buf, sizeof(buf), &result);
-
-    if(nread < 0) {
-      failf(data, "read: %s", curl_easy_strerror(result));
-      rc = -1;
-    }
-
-    if(nread <= 0)
-      break;
-
-    what = SOCKET_READABLE(Curl_conn_cf_get_socket(cf, data), 0);
-  }
-
-  return rc;
-}
-
 static size_t sectransp_version(char *buffer, size_t size)
 {
   return msnprintf(buffer, size, "SecureTransport");
@@ -3267,7 +2703,7 @@ static bool sectransp_data_pending(struct Curl_cfilter *cf,
 static CURLcode sectransp_random(struct Curl_easy *data UNUSED_PARAM,
                                  unsigned char *entropy, size_t length)
 {
-  /* arc4random_buf() isn't available on cats older than Lion, so let's
+  /* arc4random_buf() is not available on cats older than Lion, so let's
      do this manually for the benefit of the older cats. */
   size_t i;
   u_int32_t random_number = 0;
@@ -3298,7 +2734,7 @@ static CURLcode sectransp_sha256sum(const unsigned char *tmp, /* input */
 static bool sectransp_false_start(void)
 {
 #if CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7
-  if(SSLSetSessionOption)
+  if(&SSLSetSessionOption)
     return TRUE;
 #endif
   return FALSE;
@@ -3325,7 +2761,7 @@ static ssize_t sectransp_send(struct Curl_cfilter *cf,
 
      Now, one could interpret that as "written to the socket," but actually,
      it returns the amount of data that was written to a buffer internal to
-     the SSLContextRef instead. So it's possible for SSLWrite() to return
+     the SSLContextRef instead. So it is possible for SSLWrite() to return
      errSSLWouldBlock and a number of bytes "written" because those bytes were
      encrypted and written to a buffer, not to the socket.
 
@@ -3338,7 +2774,7 @@ static ssize_t sectransp_send(struct Curl_cfilter *cf,
     err = SSLWrite(backend->ssl_ctx, NULL, 0UL, &processed);
     switch(err) {
       case noErr:
-        /* processed is always going to be 0 because we didn't write to
+        /* processed is always going to be 0 because we did not write to
            the buffer, so return how much was written to the socket */
         processed = backend->ssl_write_buffered_length;
         backend->ssl_write_buffered_length = 0UL;
@@ -3353,7 +2789,7 @@ static ssize_t sectransp_send(struct Curl_cfilter *cf,
     }
   }
   else {
-    /* We've got new data to write: */
+    /* We have got new data to write: */
     err = SSLWrite(backend->ssl_ctx, mem, len, &processed);
     if(err != noErr) {
       switch(err) {
@@ -3410,7 +2846,7 @@ again:
         *curlcode = CURLE_OK;
         return 0;
 
-        /* The below is errSSLPeerAuthCompleted; it's not defined in
+        /* The below is errSSLPeerAuthCompleted; it is not defined in
            Leopard's headers */
       case -9841:
         if((conn_config->CAfile || conn_config->ca_info_blob) &&
@@ -3476,7 +2912,6 @@ const struct Curl_ssl Curl_ssl_sectransp = {
   sectransp_sha256sum,                /* sha256sum */
   NULL,                               /* associate_connection */
   NULL,                               /* disassociate_connection */
-  NULL,                               /* free_multi_ssl_backend_data */
   sectransp_recv,                     /* recv decrypted data */
   sectransp_send,                     /* send data to encrypt */
 };
diff --git a/lib/vtls/vtls.c b/lib/vtls/vtls.c
index 570a10d5a..e601f4b16 100644
--- a/lib/vtls/vtls.c
+++ b/lib/vtls/vtls.c
@@ -68,6 +68,8 @@
 #include "curl_base64.h"
 #include "curl_printf.h"
 #include "inet_pton.h"
+#include "connect.h"
+#include "select.h"
 #include "strdup.h"
 
 /* The last #include files should be: */
@@ -103,7 +105,7 @@ static CURLcode blobdup(struct curl_blob **dest,
   DEBUGASSERT(dest);
   DEBUGASSERT(!*dest);
   if(src) {
-    /* only if there's data to dupe! */
+    /* only if there is data to dupe! */
     struct curl_blob *d;
     d = malloc(sizeof(struct curl_blob) + src->len);
     if(!d)
@@ -152,7 +154,7 @@ static const struct alpn_spec *alpn_get_spec(int httpwant, bool use_alpn)
   (void)httpwant;
 #endif
   /* Use the ALPN protocol "http/1.1" for HTTP/1.x.
-     Avoid "http/1.0" because some servers don't support it. */
+     Avoid "http/1.0" because some servers do not support it. */
   return &ALPN_SPEC_H11;
 }
 #endif /* USE_SSL */
@@ -166,7 +168,7 @@ void Curl_ssl_easy_config_init(struct Curl_easy *data)
    */
   data->set.ssl.primary.verifypeer = TRUE;
   data->set.ssl.primary.verifyhost = TRUE;
-  data->set.ssl.primary.sessionid = TRUE; /* session ID caching by default */
+  data->set.ssl.primary.cache_session = TRUE; /* caching by default */
 #ifndef CURL_DISABLE_PROXY
   data->set.proxy_ssl = data->set.ssl;
 #endif
@@ -228,7 +230,7 @@ static bool clone_ssl_primary_config(struct ssl_primary_config *source,
   dest->verifypeer = source->verifypeer;
   dest->verifyhost = source->verifyhost;
   dest->verifystatus = source->verifystatus;
-  dest->sessionid = source->sessionid;
+  dest->cache_session = source->cache_session;
   dest->ssl_options = source->ssl_options;
 
   CLONE_BLOB(cert_blob);
@@ -411,23 +413,6 @@ int Curl_ssl_init(void)
   return Curl_ssl->init();
 }
 
-#if defined(CURL_WITH_MULTI_SSL)
-static const struct Curl_ssl Curl_ssl_multi;
-#endif
-
-/* Global cleanup */
-void Curl_ssl_cleanup(void)
-{
-  if(init_ssl) {
-    /* only cleanup if we did a previous init */
-    Curl_ssl->cleanup();
-#if defined(CURL_WITH_MULTI_SSL)
-    Curl_ssl = &Curl_ssl_multi;
-#endif
-    init_ssl = FALSE;
-  }
-}
-
 static bool ssl_prefs_check(struct Curl_easy *data)
 {
   /* check for CURLOPT_SSLVERSION invalid parameter value */
@@ -453,7 +438,7 @@ static bool ssl_prefs_check(struct Curl_easy *data)
 }
 
 static struct ssl_connect_data *cf_ctx_new(struct Curl_easy *data,
-                                     const struct alpn_spec *alpn)
+                                           const struct alpn_spec *alpn)
 {
   struct ssl_connect_data *ctx;
 
@@ -529,8 +514,8 @@ void Curl_ssl_sessionid_unlock(struct Curl_easy *data)
 }
 
 /*
- * Check if there's a session ID for the given connection in the cache, and if
- * there's one suitable, it is provided. Returns TRUE when no entry matched.
+ * Check if there is a session ID for the given connection in the cache, and if
+ * there is one suitable, it is provided. Returns TRUE when no entry matched.
  */
 bool Curl_ssl_getsessionid(struct Curl_cfilter *cf,
                            struct Curl_easy *data,
@@ -549,9 +534,9 @@ bool Curl_ssl_getsessionid(struct Curl_cfilter *cf,
   if(!ssl_config)
     return TRUE;
 
-  DEBUGASSERT(ssl_config->primary.sessionid);
+  DEBUGASSERT(ssl_config->primary.cache_session);
 
-  if(!ssl_config->primary.sessionid || !data->state.session)
+  if(!ssl_config->primary.cache_session || !data->state.session)
     /* session ID reuse is disabled or the session cache has not been
        setup */
     return TRUE;
@@ -590,7 +575,7 @@ bool Curl_ssl_getsessionid(struct Curl_cfilter *cf,
   }
 
   DEBUGF(infof(data, "%s Session ID in cache for %s %s://%s:%d",
-               no_match? "Didn't find": "Found",
+               no_match? "Did not find": "Found",
                Curl_ssl_cf_is_proxy(cf) ? "proxy" : "host",
                cf->conn->handler->scheme, peer->hostname, peer->port));
   return no_match;
@@ -635,18 +620,12 @@ void Curl_ssl_delsessionid(struct Curl_easy *data, void *ssl_sessionid)
   }
 }
 
-/*
- * Store session id in the session cache. The ID passed on to this function
- * must already have been extracted and allocated the proper way for the SSL
- * layer. Curl_XXXX_session_free() will be called to free/kill the session ID
- * later on.
- */
-CURLcode Curl_ssl_addsessionid(struct Curl_cfilter *cf,
-                               struct Curl_easy *data,
-                               const struct ssl_peer *peer,
-                               void *ssl_sessionid,
-                               size_t idsize,
-                               Curl_ssl_sessionid_dtor *sessionid_free_cb)
+CURLcode Curl_ssl_set_sessionid(struct Curl_cfilter *cf,
+                                struct Curl_easy *data,
+                                const struct ssl_peer *peer,
+                                void *ssl_sessionid,
+                                size_t idsize,
+                                Curl_ssl_sessionid_dtor *sessionid_free_cb)
 {
   struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);
   struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
@@ -657,6 +636,8 @@ CURLcode Curl_ssl_addsessionid(struct Curl_cfilter *cf,
   char *clone_conn_to_host = NULL;
   int conn_to_port;
   long *general_age;
+  void *old_sessionid;
+  size_t old_size;
   CURLcode result = CURLE_OUT_OF_MEMORY;
 
   DEBUGASSERT(ssl_sessionid);
@@ -667,9 +648,20 @@ CURLcode Curl_ssl_addsessionid(struct Curl_cfilter *cf,
     return CURLE_OK;
   }
 
+  if(!Curl_ssl_getsessionid(cf, data, peer, &old_sessionid, &old_size)) {
+    if((old_size == idsize) &&
+       ((old_sessionid == ssl_sessionid) ||
+        (idsize && !memcmp(old_sessionid, ssl_sessionid, idsize)))) {
+      /* the very same */
+      sessionid_free_cb(ssl_sessionid, idsize);
+      return CURLE_OK;
+    }
+    Curl_ssl_delsessionid(data, old_sessionid);
+  }
+
   store = &data->state.session[0];
   oldest_age = data->state.session[0].age; /* zero if unused */
-  DEBUGASSERT(ssl_config->primary.sessionid);
+  DEBUGASSERT(ssl_config->primary.cache_session);
   (void)ssl_config;
 
   clone_host = strdup(peer->hostname);
@@ -687,7 +679,7 @@ CURLcode Curl_ssl_addsessionid(struct Curl_cfilter *cf,
   else
     conn_to_port = -1;
 
-  /* Now we should add the session ID and the host name to the cache, (remove
+  /* Now we should add the session ID and the hostname to the cache, (remove
      the oldest if necessary) */
 
   /* If using shared SSL session, lock! */
@@ -722,12 +714,12 @@ CURLcode Curl_ssl_addsessionid(struct Curl_cfilter *cf,
   store->idsize = idsize;
   store->sessionid_free = sessionid_free_cb;
   store->age = *general_age;    /* set current age */
-  /* free it if there's one already present */
+  /* free it if there is one already present */
   free(store->name);
   free(store->conn_to_host);
-  store->name = clone_host;               /* clone host name */
+  store->name = clone_host;               /* clone hostname */
   clone_host = NULL;
-  store->conn_to_host = clone_conn_to_host; /* clone connect to host name */
+  store->conn_to_host = clone_conn_to_host; /* clone connect to hostname */
   clone_conn_to_host = NULL;
   store->conn_to_port = conn_to_port; /* connect to port number */
   /* port number */
@@ -753,12 +745,6 @@ out:
   return CURLE_OK;
 }
 
-void Curl_free_multi_ssl_backend_data(struct multi_ssl_backend_data *mbackend)
-{
-  if(Curl_ssl->free_multi_ssl_backend_data && mbackend)
-    Curl_ssl->free_multi_ssl_backend_data(mbackend);
-}
-
 void Curl_ssl_close_all(struct Curl_easy *data)
 {
   /* kill the session ID cache if not shared */
@@ -778,11 +764,12 @@ void Curl_ssl_close_all(struct Curl_easy *data)
 void Curl_ssl_adjust_pollset(struct Curl_cfilter *cf, struct Curl_easy *data,
                               struct easy_pollset *ps)
 {
-  if(!cf->connected) {
-    struct ssl_connect_data *connssl = cf->ctx;
+  struct ssl_connect_data *connssl = cf->ctx;
+
+  if(connssl->io_need) {
     curl_socket_t sock = Curl_conn_cf_get_socket(cf->next, data);
     if(sock != CURL_SOCKET_BAD) {
-      if(connssl->connecting_state == ssl_connect_2_writing) {
+      if(connssl->io_need & CURL_SSL_IO_NEED_SEND) {
         Curl_pollset_set_out_only(data, ps, sock);
         CURL_TRC_CF(data, cf, "adjust_pollset, POLLOUT fd=%"
                     CURL_FORMAT_SOCKET_T, sock);
@@ -1000,7 +987,7 @@ CURLcode Curl_pin_peer_pubkey(struct Curl_easy *data,
   (void)data;
 #endif
 
-  /* if a path wasn't specified, don't pin */
+  /* if a path was not specified, do not pin */
   if(!pinnedpubkey)
     return CURLE_OK;
   if(!pubkey || !pubkeylen)
@@ -1048,7 +1035,7 @@ CURLcode Curl_pin_peer_pubkey(struct Curl_easy *data,
       end_pos = strstr(begin_pos, ";sha256//");
       /*
        * if there is an end_pos, null terminate,
-       * otherwise it'll go to the end of the original string
+       * otherwise it will go to the end of the original string
        */
       if(end_pos)
         end_pos[0] = '\0';
@@ -1094,7 +1081,7 @@ CURLcode Curl_pin_peer_pubkey(struct Curl_easy *data,
 
     /*
      * if the size of our certificate is bigger than the file
-     * size then it can't match
+     * size then it cannot match
      */
     size = curlx_sotouz((curl_off_t) filesize);
     if(pubkeylen > size)
@@ -1112,7 +1099,7 @@ CURLcode Curl_pin_peer_pubkey(struct Curl_easy *data,
     if((int) fread(buf, size, 1, fp) != 1)
       break;
 
-    /* If the sizes are the same, it can't be base64 encoded, must be der */
+    /* If the sizes are the same, it cannot be base64 encoded, must be der */
     if(pubkeylen == size) {
       if(!memcmp(pubkey, buf, pubkeylen))
         result = CURLE_OK;
@@ -1120,18 +1107,18 @@ CURLcode Curl_pin_peer_pubkey(struct Curl_easy *data,
     }
 
     /*
-     * Otherwise we will assume it's PEM and try to decode it
+     * Otherwise we will assume it is PEM and try to decode it
      * after placing null terminator
      */
     buf[size] = '\0';
     pem_read = pubkey_pem_to_der((const char *)buf, &pem_ptr, &pem_len);
-    /* if it wasn't read successfully, exit */
+    /* if it was not read successfully, exit */
     if(pem_read)
       break;
 
     /*
-     * if the size of our certificate doesn't match the size of
-     * the decoded file, they can't be the same, otherwise compare
+     * if the size of our certificate does not match the size of
+     * the decoded file, they cannot be the same, otherwise compare
      */
     if(pubkeylen == pem_len && !memcmp(pubkey, pem_ptr, pubkeylen))
       result = CURLE_OK;
@@ -1173,12 +1160,18 @@ int Curl_none_init(void)
 void Curl_none_cleanup(void)
 { }
 
-int Curl_none_shutdown(struct Curl_cfilter *cf UNUSED_PARAM,
-                       struct Curl_easy *data UNUSED_PARAM)
+CURLcode Curl_none_shutdown(struct Curl_cfilter *cf UNUSED_PARAM,
+                            struct Curl_easy *data UNUSED_PARAM,
+                            bool send_shutdown UNUSED_PARAM,
+                            bool *done)
 {
   (void)data;
   (void)cf;
-  return 0;
+  (void)send_shutdown;
+  /* Every SSL backend should have a shutdown implementation. Until we
+   * have implemented that, we put this fake in place. */
+  *done = TRUE;
+  return CURLE_OK;
 }
 
 int Curl_none_check_cxn(struct Curl_cfilter *cf, struct Curl_easy *data)
@@ -1339,7 +1332,6 @@ static const struct Curl_ssl Curl_ssl_multi = {
   NULL,                              /* sha256sum */
   NULL,                              /* associate_connection */
   NULL,                              /* disassociate_connection */
-  NULL,                              /* free_multi_ssl_backend_data */
   multissl_recv_plain,               /* recv decrypted data */
   multissl_send_plain,               /* send data to encrypt */
 };
@@ -1349,8 +1341,6 @@ const struct Curl_ssl *Curl_ssl =
   &Curl_ssl_multi;
 #elif defined(USE_WOLFSSL)
   &Curl_ssl_wolfssl;
-#elif defined(USE_SECTRANSP)
-  &Curl_ssl_sectransp;
 #elif defined(USE_GNUTLS)
   &Curl_ssl_gnutls;
 #elif defined(USE_MBEDTLS)
@@ -1359,6 +1349,8 @@ const struct Curl_ssl *Curl_ssl =
   &Curl_ssl_rustls;
 #elif defined(USE_OPENSSL)
   &Curl_ssl_openssl;
+#elif defined(USE_SECTRANSP)
+  &Curl_ssl_sectransp;
 #elif defined(USE_SCHANNEL)
   &Curl_ssl_schannel;
 #elif defined(USE_BEARSSL)
@@ -1371,9 +1363,6 @@ static const struct Curl_ssl *available_backends[] = {
 #if defined(USE_WOLFSSL)
   &Curl_ssl_wolfssl,
 #endif
-#if defined(USE_SECTRANSP)
-  &Curl_ssl_sectransp,
-#endif
 #if defined(USE_GNUTLS)
   &Curl_ssl_gnutls,
 #endif
@@ -1383,6 +1372,9 @@ static const struct Curl_ssl *available_backends[] = {
 #if defined(USE_OPENSSL)
   &Curl_ssl_openssl,
 #endif
+#if defined(USE_SECTRANSP)
+  &Curl_ssl_sectransp,
+#endif
 #if defined(USE_SCHANNEL)
   &Curl_ssl_schannel,
 #endif
@@ -1395,6 +1387,19 @@ static const struct Curl_ssl *available_backends[] = {
   NULL
 };
 
+/* Global cleanup */
+void Curl_ssl_cleanup(void)
+{
+  if(init_ssl) {
+    /* only cleanup if we did a previous init */
+    Curl_ssl->cleanup();
+#if defined(CURL_WITH_MULTI_SSL)
+    Curl_ssl = &Curl_ssl_multi;
+#endif
+    init_ssl = FALSE;
+  }
+}
+
 static size_t multissl_version(char *buffer, size_t size)
 {
   static const struct Curl_ssl *selected;
@@ -1564,10 +1569,10 @@ CURLcode Curl_ssl_peer_init(struct ssl_peer *peer, struct Curl_cfilter *cf,
   const char *ehostname, *edispname;
   int eport;
 
-  /* We need the hostname for SNI negotiation. Once handshaked, this
-   * remains the SNI hostname for the TLS connection. But when the
-   * connection is reused, the settings in cf->conn might change.
-   * So we keep a copy of the hostname we use for SNI.
+  /* We need the hostname for SNI negotiation. Once handshaked, this remains
+   * the SNI hostname for the TLS connection. When the connection is reused,
+   * the settings in cf->conn might change. We keep a copy of the hostname we
+   * use for SNI.
    */
 #ifndef CURL_DISABLE_PROXY
   if(Curl_ssl_cf_is_proxy(cf)) {
@@ -1751,17 +1756,34 @@ static ssize_t ssl_cf_recv(struct Curl_cfilter *cf,
   return nread;
 }
 
-static void ssl_cf_adjust_pollset(struct Curl_cfilter *cf,
-                                   struct Curl_easy *data,
-                                   struct easy_pollset *ps)
+static CURLcode ssl_cf_shutdown(struct Curl_cfilter *cf,
+                                struct Curl_easy *data,
+                                bool *done)
 {
-  struct cf_call_data save;
+  CURLcode result = CURLE_OK;
+
+  *done = TRUE;
+  if(!cf->shutdown) {
+    struct cf_call_data save;
 
-  if(!cf->connected) {
     CF_DATA_SAVE(save, cf, data);
-    Curl_ssl->adjust_pollset(cf, data, ps);
+    result = Curl_ssl->shut_down(cf, data, TRUE, done);
+    CURL_TRC_CF(data, cf, "cf_shutdown -> %d, done=%d", result, *done);
     CF_DATA_RESTORE(cf, save);
+    cf->shutdown = (result || *done);
   }
+  return result;
+}
+
+static void ssl_cf_adjust_pollset(struct Curl_cfilter *cf,
+                                  struct Curl_easy *data,
+                                  struct easy_pollset *ps)
+{
+  struct cf_call_data save;
+
+  CF_DATA_SAVE(save, cf, data);
+  Curl_ssl->adjust_pollset(cf, data, ps);
+  CF_DATA_RESTORE(cf, save);
 }
 
 static CURLcode ssl_cf_cntrl(struct Curl_cfilter *cf,
@@ -1851,6 +1873,7 @@ struct Curl_cftype Curl_cft_ssl = {
   ssl_cf_destroy,
   ssl_cf_connect,
   ssl_cf_close,
+  ssl_cf_shutdown,
   Curl_cf_def_get_host,
   ssl_cf_adjust_pollset,
   ssl_cf_data_pending,
@@ -1871,6 +1894,7 @@ struct Curl_cftype Curl_cft_ssl_proxy = {
   ssl_cf_destroy,
   ssl_cf_connect,
   ssl_cf_close,
+  ssl_cf_shutdown,
   Curl_cf_def_get_host,
   ssl_cf_adjust_pollset,
   ssl_cf_data_pending,
@@ -1982,10 +2006,10 @@ CURLcode Curl_cf_ssl_proxy_insert_after(struct Curl_cfilter *cf_at,
 
 #endif /* !CURL_DISABLE_PROXY */
 
-bool Curl_ssl_supports(struct Curl_easy *data, int option)
+bool Curl_ssl_supports(struct Curl_easy *data, unsigned int ssl_option)
 {
   (void)data;
-  return (Curl_ssl->supports & option)? TRUE : FALSE;
+  return (Curl_ssl->supports & ssl_option)? TRUE : FALSE;
 }
 
 static struct Curl_cfilter *get_ssl_filter(struct Curl_cfilter *cf)
@@ -2021,19 +2045,77 @@ void *Curl_ssl_get_internals(struct Curl_easy *data, int sockindex,
   return result;
 }
 
+static CURLcode vtls_shutdown_blocking(struct Curl_cfilter *cf,
+                                       struct Curl_easy *data,
+                                       bool send_shutdown, bool *done)
+{
+  struct ssl_connect_data *connssl = cf->ctx;
+  struct cf_call_data save;
+  CURLcode result = CURLE_OK;
+  timediff_t timeout_ms;
+  int what, loop = 10;
+
+  if(cf->shutdown) {
+    *done = TRUE;
+    return CURLE_OK;
+  }
+  CF_DATA_SAVE(save, cf, data);
+
+  *done = FALSE;
+  while(!result && !*done && loop--) {
+    timeout_ms = Curl_shutdown_timeleft(cf->conn, cf->sockindex, NULL);
+
+    if(timeout_ms < 0) {
+      /* no need to continue if time is already up */
+      failf(data, "SSL shutdown timeout");
+      return CURLE_OPERATION_TIMEDOUT;
+    }
+
+    result = Curl_ssl->shut_down(cf, data, send_shutdown, done);
+    if(result ||*done)
+      goto out;
+
+    if(connssl->io_need) {
+      what = Curl_conn_cf_poll(cf, data, timeout_ms);
+      if(what < 0) {
+        /* fatal error */
+        failf(data, "select/poll on SSL socket, errno: %d", SOCKERRNO);
+        result = CURLE_RECV_ERROR;
+        goto out;
+      }
+      else if(0 == what) {
+        /* timeout */
+        failf(data, "SSL shutdown timeout");
+        result = CURLE_OPERATION_TIMEDOUT;
+        goto out;
+      }
+      /* socket is readable or writable */
+    }
+  }
+out:
+  CF_DATA_RESTORE(cf, save);
+  cf->shutdown = (result || *done);
+  return result;
+}
+
 CURLcode Curl_ssl_cfilter_remove(struct Curl_easy *data,
-                                 int sockindex)
+                                 int sockindex, bool send_shutdown)
 {
   struct Curl_cfilter *cf, *head;
   CURLcode result = CURLE_OK;
 
-  (void)data;
   head = data->conn? data->conn->cfilter[sockindex] : NULL;
   for(cf = head; cf; cf = cf->next) {
     if(cf->cft == &Curl_cft_ssl) {
-      if(Curl_ssl->shut_down(cf, data))
+      bool done;
+      CURL_TRC_CF(data, cf, "shutdown and remove SSL, start");
+      Curl_shutdown_start(data, sockindex, NULL);
+      result = vtls_shutdown_blocking(cf, data, send_shutdown, &done);
+      Curl_shutdown_clear(data, sockindex);
+      if(!result && !done) /* blocking failed? */
         result = CURLE_SSL_SHUTDOWN_FAILED;
       Curl_conn_cf_discard_sub(head, cf, data, FALSE);
+      CURL_TRC_CF(data, cf, "shutdown and remove SSL, done -> %d", result);
       break;
     }
   }
diff --git a/lib/vtls/vtls.h b/lib/vtls/vtls.h
index c40ff2620..8fe2bc7ce 100644
--- a/lib/vtls/vtls.h
+++ b/lib/vtls/vtls.h
@@ -38,6 +38,7 @@ struct Curl_ssl_session;
 #define SSLSUPP_TLS13_CIPHERSUITES (1<<5) /* supports TLS 1.3 ciphersuites */
 #define SSLSUPP_CAINFO_BLOB  (1<<6)
 #define SSLSUPP_ECH          (1<<7)
+#define SSLSUPP_CA_CACHE     (1<<8)
 
 #define ALPN_ACCEPTED "ALPN: server accepted "
 
@@ -52,7 +53,6 @@ struct Curl_ssl_session;
 
 /* Curl_multi SSL backend-specific data; declared differently by each SSL
    backend */
-struct multi_ssl_backend_data;
 struct Curl_cfilter;
 
 CURLsslset Curl_init_sslset_nolock(curl_sslbackend id, const char *name,
@@ -181,8 +181,6 @@ bool Curl_ssl_cert_status_request(void);
 
 bool Curl_ssl_false_start(struct Curl_easy *data);
 
-void Curl_free_multi_ssl_backend_data(struct multi_ssl_backend_data *mbackend);
-
 #define SSL_SHUTDOWN_TIMEOUT 10000 /* ms */
 
 CURLcode Curl_ssl_cfilter_add(struct Curl_easy *data,
@@ -193,7 +191,7 @@ CURLcode Curl_cf_ssl_insert_after(struct Curl_cfilter *cf_at,
                                   struct Curl_easy *data);
 
 CURLcode Curl_ssl_cfilter_remove(struct Curl_easy *data,
-                                 int sockindex);
+                                 int sockindex, bool send_shutdown);
 
 #ifndef CURL_DISABLE_PROXY
 CURLcode Curl_cf_ssl_proxy_insert_after(struct Curl_cfilter *cf_at,
@@ -205,7 +203,7 @@ CURLcode Curl_cf_ssl_proxy_insert_after(struct Curl_cfilter *cf_at,
  * Option is one of the defined SSLSUPP_* values.
  * `data` maybe NULL for the features of the default implementation.
  */
-bool Curl_ssl_supports(struct Curl_easy *data, int ssl_option);
+bool Curl_ssl_supports(struct Curl_easy *data, unsigned int ssl_option);
 
 /**
  * Get the internal ssl instance (like OpenSSL's SSL*) from the filter
@@ -252,7 +250,7 @@ extern struct Curl_cftype Curl_cft_ssl_proxy;
 #define Curl_ssl_get_internals(a,b,c,d) NULL
 #define Curl_ssl_supports(a,b) FALSE
 #define Curl_ssl_cfilter_add(a,b,c) CURLE_NOT_BUILT_IN
-#define Curl_ssl_cfilter_remove(a,b) CURLE_OK
+#define Curl_ssl_cfilter_remove(a,b,c) CURLE_OK
 #define Curl_ssl_cf_get_config(a,b) NULL
 #define Curl_ssl_cf_get_primary_config(a) NULL
 #endif
diff --git a/lib/vtls/vtls_int.h b/lib/vtls/vtls_int.h
index 5259babb2..1472a0ca5 100644
--- a/lib/vtls/vtls_int.h
+++ b/lib/vtls/vtls_int.h
@@ -64,15 +64,34 @@ CURLcode Curl_alpn_set_negotiated(struct Curl_cfilter *cf,
                                   const unsigned char *proto,
                                   size_t proto_len);
 
+/* enum for the nonblocking SSL connection state machine */
+typedef enum {
+  ssl_connect_1,
+  ssl_connect_2,
+  ssl_connect_3,
+  ssl_connect_done
+} ssl_connect_state;
+
+typedef enum {
+  ssl_connection_none,
+  ssl_connection_negotiating,
+  ssl_connection_complete
+} ssl_connection_state;
+
+#define CURL_SSL_IO_NEED_NONE   (0)
+#define CURL_SSL_IO_NEED_RECV   (1<<0)
+#define CURL_SSL_IO_NEED_SEND   (1<<1)
+
 /* Information in each SSL cfilter context: cf->ctx */
 struct ssl_connect_data {
-  ssl_connection_state state;
-  ssl_connect_state connecting_state;
   struct ssl_peer peer;
   const struct alpn_spec *alpn;     /* ALPN to use or NULL for none */
   void *backend;                    /* vtls backend specific props */
   struct cf_call_data call_data;    /* data handle used in current call */
   struct curltime handshake_done;   /* time when handshake finished */
+  ssl_connection_state state;
+  ssl_connect_state connecting_state;
+  int io_need;                      /* TLS signals special SEND/RECV needs */
   BIT(use_alpn);                    /* if ALPN shall be used in handshake */
   BIT(peer_closed);                 /* peer has closed connection */
 };
@@ -99,8 +118,8 @@ struct Curl_ssl {
 
   size_t (*version)(char *buffer, size_t size);
   int (*check_cxn)(struct Curl_cfilter *cf, struct Curl_easy *data);
-  int (*shut_down)(struct Curl_cfilter *cf,
-                   struct Curl_easy *data);
+  CURLcode (*shut_down)(struct Curl_cfilter *cf, struct Curl_easy *data,
+                        bool send_shutdown, bool *done);
   bool (*data_pending)(struct Curl_cfilter *cf,
                        const struct Curl_easy *data);
 
@@ -115,9 +134,8 @@ struct Curl_ssl {
                                   struct Curl_easy *data,
                                   bool *done);
 
-  /* During handshake, adjust the pollset to include the socket
-   * for POLLOUT or POLLIN as needed.
-   * Mandatory. */
+  /* During handshake/shutdown, adjust the pollset to include the socket
+   * for POLLOUT or POLLIN as needed. Mandatory. */
   void (*adjust_pollset)(struct Curl_cfilter *cf, struct Curl_easy *data,
                           struct easy_pollset *ps);
   void *(*get_internals)(struct ssl_connect_data *connssl, CURLINFO info);
@@ -135,8 +153,6 @@ struct Curl_ssl {
   bool (*attach_data)(struct Curl_cfilter *cf, struct Curl_easy *data);
   void (*detach_data)(struct Curl_cfilter *cf, struct Curl_easy *data);
 
-  void (*free_multi_ssl_backend_data)(struct multi_ssl_backend_data *mbackend);
-
   ssize_t (*recv_plain)(struct Curl_cfilter *cf, struct Curl_easy *data,
                         char *buf, size_t len, CURLcode *code);
   ssize_t (*send_plain)(struct Curl_cfilter *cf, struct Curl_easy *data,
@@ -149,7 +165,8 @@ extern const struct Curl_ssl *Curl_ssl;
 
 int Curl_none_init(void);
 void Curl_none_cleanup(void);
-int Curl_none_shutdown(struct Curl_cfilter *cf, struct Curl_easy *data);
+CURLcode Curl_none_shutdown(struct Curl_cfilter *cf, struct Curl_easy *data,
+                            bool send_shutdown, bool *done);
 int Curl_none_check_cxn(struct Curl_cfilter *cf, struct Curl_easy *data);
 CURLcode Curl_none_random(struct Curl_easy *data, unsigned char *entropy,
                           size_t length);
@@ -181,19 +198,22 @@ bool Curl_ssl_getsessionid(struct Curl_cfilter *cf,
                            const struct ssl_peer *peer,
                            void **ssl_sessionid,
                            size_t *idsize); /* set 0 if unknown */
-/* add a new session ID
+
+/* Set a TLS session ID for `peer`. Replaces an existing session ID if
+ * not already the very same.
  * Sessionid mutex must be locked (see Curl_ssl_sessionid_lock).
+ * Call takes ownership of `ssl_sessionid`, using `sessionid_free_cb`
+ * to deallocate it. Is called in all outcomes, either right away or
+ * later when the session cache is cleaned up.
  * Caller must ensure that it has properly shared ownership of this sessionid
  * object with cache (e.g. incrementing refcount on success)
- * Call takes ownership of `ssl_sessionid`, using `sessionid_free_cb`
- * to destroy it in case of failure or later removal.
  */
-CURLcode Curl_ssl_addsessionid(struct Curl_cfilter *cf,
-                               struct Curl_easy *data,
-                               const struct ssl_peer *peer,
-                               void *ssl_sessionid,
-                               size_t idsize,
-                               Curl_ssl_sessionid_dtor *sessionid_free_cb);
+CURLcode Curl_ssl_set_sessionid(struct Curl_cfilter *cf,
+                                struct Curl_easy *data,
+                                const struct ssl_peer *peer,
+                                void *sessionid,
+                                size_t sessionid_size,
+                                Curl_ssl_sessionid_dtor *sessionid_free_cb);
 
 #include "openssl.h"        /* OpenSSL versions */
 #include "gtls.h"           /* GnuTLS versions */
diff --git a/lib/vtls/wolfssl.c b/lib/vtls/wolfssl.c
index 2c92f56ea..2b467c935 100644
--- a/lib/vtls/wolfssl.c
+++ b/lib/vtls/wolfssl.c
@@ -99,17 +99,11 @@
 #undef USE_BIO_CHAIN
 #endif
 
-struct wolfssl_ssl_backend_data {
-  WOLFSSL_CTX *ctx;
-  WOLFSSL     *handle;
-  CURLcode    io_result;   /* result of last BIO cfilter operation */
-};
-
 #ifdef OPENSSL_EXTRA
 /*
  * Availability note:
  * The TLS 1.3 secret callback (wolfSSL_set_tls13_secret_cb) was added in
- * WolfSSL 4.4.0, but requires the -DHAVE_SECRET_CALLBACK build option. If that
+ * wolfSSL 4.4.0, but requires the -DHAVE_SECRET_CALLBACK build option. If that
  * option is not set, then TLS 1.3 will not be logged.
  * For TLS 1.2 and before, we use wolfSSL_get_keys().
  * SSL_get_client_random and wolfSSL_get_keys require OPENSSL_EXTRA
@@ -218,7 +212,7 @@ static int do_file_type(const char *type)
   return -1;
 }
 
-#ifdef HAVE_LIBOQS
+#ifdef WOLFSSL_HAVE_KYBER
 struct group_name_map {
   const word16 group;
   const char   *name;
@@ -290,8 +284,8 @@ static int wolfssl_bio_cf_out_write(WOLFSSL_BIO *bio,
 {
   struct Curl_cfilter *cf = wolfSSL_BIO_get_data(bio);
   struct ssl_connect_data *connssl = cf->ctx;
-  struct wolfssl_ssl_backend_data *backend =
-    (struct wolfssl_ssl_backend_data *)connssl->backend;
+  struct wolfssl_ctx *backend =
+    (struct wolfssl_ctx *)connssl->backend;
   struct Curl_easy *data = CF_DATA_CURRENT(cf);
   ssize_t nwritten;
   CURLcode result = CURLE_OK;
@@ -311,8 +305,8 @@ static int wolfssl_bio_cf_in_read(WOLFSSL_BIO *bio, char *buf, int blen)
 {
   struct Curl_cfilter *cf = wolfSSL_BIO_get_data(bio);
   struct ssl_connect_data *connssl = cf->ctx;
-  struct wolfssl_ssl_backend_data *backend =
-    (struct wolfssl_ssl_backend_data *)connssl->backend;
+  struct wolfssl_ctx *backend =
+    (struct wolfssl_ctx *)connssl->backend;
   struct Curl_easy *data = CF_DATA_CURRENT(cf);
   ssize_t nread;
   CURLcode result = CURLE_OK;
@@ -357,6 +351,263 @@ static void wolfssl_bio_cf_free_methods(void)
 
 #endif /* !USE_BIO_CHAIN */
 
+static CURLcode populate_x509_store(struct Curl_cfilter *cf,
+                                    struct Curl_easy *data,
+                                    X509_STORE *store,
+                                    struct wolfssl_ctx *wssl)
+{
+  struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
+  const struct curl_blob *ca_info_blob = conn_config->ca_info_blob;
+  const char * const ssl_cafile =
+    /* CURLOPT_CAINFO_BLOB overrides CURLOPT_CAINFO */
+    (ca_info_blob ? NULL : conn_config->CAfile);
+  const char * const ssl_capath = conn_config->CApath;
+  struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);
+  bool imported_native_ca = false;
+
+#if !defined(NO_FILESYSTEM) && defined(WOLFSSL_SYS_CA_CERTS)
+  /* load native CA certificates */
+  if(ssl_config->native_ca_store) {
+    if(wolfSSL_CTX_load_system_CA_certs(wssl->ctx) != WOLFSSL_SUCCESS) {
+      infof(data, "error importing native CA store, continuing anyway");
+    }
+    else {
+      imported_native_ca = true;
+      infof(data, "successfully imported native CA store");
+      wssl->x509_store_setup = TRUE;
+    }
+  }
+#endif /* !NO_FILESYSTEM */
+
+  /* load certificate blob */
+  if(ca_info_blob) {
+    if(wolfSSL_CTX_load_verify_buffer(wssl->ctx, ca_info_blob->data,
+                                      (long)ca_info_blob->len,
+                                      SSL_FILETYPE_PEM) != SSL_SUCCESS) {
+      if(imported_native_ca) {
+        infof(data, "error importing CA certificate blob, continuing anyway");
+      }
+      else {
+        failf(data, "error importing CA certificate blob");
+        return CURLE_SSL_CACERT_BADFILE;
+      }
+    }
+    else {
+      infof(data, "successfully imported CA certificate blob");
+      wssl->x509_store_setup = TRUE;
+    }
+  }
+
+#ifndef NO_FILESYSTEM
+  /* load trusted cacert from file if not blob */
+
+  CURL_TRC_CF(data, cf, "populate_x509_store, path=%s, blob=%d",
+              ssl_cafile? ssl_cafile : "none", !!ca_info_blob);
+  if(!store)
+    return CURLE_OUT_OF_MEMORY;
+
+  if((ssl_cafile || ssl_capath) && (!wssl->x509_store_setup)) {
+    int rc =
+      wolfSSL_CTX_load_verify_locations_ex(wssl->ctx,
+                                           ssl_cafile,
+                                           ssl_capath,
+                                           WOLFSSL_LOAD_FLAG_IGNORE_ERR);
+    if(SSL_SUCCESS != rc) {
+      if(conn_config->verifypeer) {
+        /* Fail if we insist on successfully verifying the server. */
+        failf(data, "error setting certificate verify locations:"
+              " CAfile: %s CApath: %s",
+              ssl_cafile ? ssl_cafile : "none",
+              ssl_capath ? ssl_capath : "none");
+        return CURLE_SSL_CACERT_BADFILE;
+      }
+      else {
+        /* Just continue with a warning if no strict certificate
+           verification is required. */
+        infof(data, "error setting certificate verify locations,"
+              " continuing anyway:");
+      }
+    }
+    else {
+      /* Everything is fine. */
+      infof(data, "successfully set certificate verify locations:");
+    }
+    infof(data, " CAfile: %s", ssl_cafile ? ssl_cafile : "none");
+    infof(data, " CApath: %s", ssl_capath ? ssl_capath : "none");
+  }
+#endif
+  (void)store;
+  wssl->x509_store_setup = TRUE;
+  return CURLE_OK;
+}
+
+/* key to use at `multi->proto_hash` */
+#define MPROTO_WSSL_X509_KEY   "tls:wssl:x509:share"
+
+struct wssl_x509_share {
+  char *CAfile;         /* CAfile path used to generate X509 store */
+  WOLFSSL_X509_STORE *store; /* cached X509 store or NULL if none */
+  struct curltime time; /* when the cached store was created */
+};
+
+static void wssl_x509_share_free(void *key, size_t key_len, void *p)
+{
+  struct wssl_x509_share *share = p;
+  DEBUGASSERT(key_len == (sizeof(MPROTO_WSSL_X509_KEY)-1));
+  DEBUGASSERT(!memcmp(MPROTO_WSSL_X509_KEY, key, key_len));
+  (void)key;
+  (void)key_len;
+  if(share->store) {
+    wolfSSL_X509_STORE_free(share->store);
+  }
+  free(share->CAfile);
+  free(share);
+}
+
+static bool
+cached_x509_store_expired(const struct Curl_easy *data,
+                          const struct wssl_x509_share *mb)
+{
+  const struct ssl_general_config *cfg = &data->set.general_ssl;
+  struct curltime now = Curl_now();
+  timediff_t elapsed_ms = Curl_timediff(now, mb->time);
+  timediff_t timeout_ms = cfg->ca_cache_timeout * (timediff_t)1000;
+
+  if(timeout_ms < 0)
+    return false;
+
+  return elapsed_ms >= timeout_ms;
+}
+
+static bool
+cached_x509_store_different(struct Curl_cfilter *cf,
+                            const struct wssl_x509_share *mb)
+{
+  struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
+  if(!mb->CAfile || !conn_config->CAfile)
+    return mb->CAfile != conn_config->CAfile;
+
+  return strcmp(mb->CAfile, conn_config->CAfile);
+}
+
+static X509_STORE *get_cached_x509_store(struct Curl_cfilter *cf,
+                                         const struct Curl_easy *data)
+{
+  struct Curl_multi *multi = data->multi;
+  struct wssl_x509_share *share;
+  WOLFSSL_X509_STORE *store = NULL;
+
+  DEBUGASSERT(multi);
+  share = multi? Curl_hash_pick(&multi->proto_hash,
+                                (void *)MPROTO_WSSL_X509_KEY,
+                                sizeof(MPROTO_WSSL_X509_KEY)-1) : NULL;
+  if(share && share->store &&
+     !cached_x509_store_expired(data, share) &&
+     !cached_x509_store_different(cf, share)) {
+    store = share->store;
+  }
+
+  return store;
+}
+
+static void set_cached_x509_store(struct Curl_cfilter *cf,
+                                  const struct Curl_easy *data,
+                                  X509_STORE *store)
+{
+  struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
+  struct Curl_multi *multi = data->multi;
+  struct wssl_x509_share *share;
+
+  DEBUGASSERT(multi);
+  if(!multi)
+    return;
+  share = Curl_hash_pick(&multi->proto_hash,
+                         (void *)MPROTO_WSSL_X509_KEY,
+                         sizeof(MPROTO_WSSL_X509_KEY)-1);
+
+  if(!share) {
+    share = calloc(1, sizeof(*share));
+    if(!share)
+      return;
+    if(!Curl_hash_add2(&multi->proto_hash,
+                       (void *)MPROTO_WSSL_X509_KEY,
+                       sizeof(MPROTO_WSSL_X509_KEY)-1,
+                       share, wssl_x509_share_free)) {
+      free(share);
+      return;
+    }
+  }
+
+  if(wolfSSL_X509_STORE_up_ref(store)) {
+    char *CAfile = NULL;
+
+    if(conn_config->CAfile) {
+      CAfile = strdup(conn_config->CAfile);
+      if(!CAfile) {
+        X509_STORE_free(store);
+        return;
+      }
+    }
+
+    if(share->store) {
+      X509_STORE_free(share->store);
+      free(share->CAfile);
+    }
+
+    share->time = Curl_now();
+    share->store = store;
+    share->CAfile = CAfile;
+  }
+}
+
+CURLcode Curl_wssl_setup_x509_store(struct Curl_cfilter *cf,
+                                    struct Curl_easy *data,
+                                    struct wolfssl_ctx *wssl)
+{
+  struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
+  struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);
+  CURLcode result = CURLE_OK;
+  WOLFSSL_X509_STORE *cached_store;
+  bool cache_criteria_met;
+
+  /* Consider the X509 store cacheable if it comes exclusively from a CAfile,
+     or no source is provided and we are falling back to wolfSSL's built-in
+     default. */
+  cache_criteria_met = (data->set.general_ssl.ca_cache_timeout != 0) &&
+    conn_config->verifypeer &&
+    !conn_config->CApath &&
+    !conn_config->ca_info_blob &&
+    !ssl_config->primary.CRLfile &&
+    !ssl_config->native_ca_store;
+
+  cached_store = cache_criteria_met ? get_cached_x509_store(cf, data) : NULL;
+  if(cached_store && wolfSSL_X509_STORE_up_ref(cached_store)) {
+    wolfSSL_CTX_set_cert_store(wssl->ctx, cached_store);
+  }
+  else if(cache_criteria_met) {
+    /* wolfSSL's initial store in CTX is not shareable by default.
+     * Make a new one, suitable for adding to the cache. See #14278 */
+    X509_STORE *store = wolfSSL_X509_STORE_new();
+    if(!store) {
+      failf(data, "SSL: could not create a X509 store");
+      return CURLE_OUT_OF_MEMORY;
+    }
+    wolfSSL_CTX_set_cert_store(wssl->ctx, store);
+
+    result = populate_x509_store(cf, data, store, wssl);
+    if(!result) {
+      set_cached_x509_store(cf, data, store);
+    }
+  }
+  else {
+   /* We never share the CTX's store, use it. */
+   X509_STORE *store = wolfSSL_CTX_get_cert_store(wssl->ctx);
+   result = populate_x509_store(cf, data, store, wssl);
+  }
+
+  return result;
+}
+
 /*
  * This function loads all the client/CA certificates and CRLs. Setup the TLS
  * layer and do all necessary magic.
@@ -366,18 +617,13 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
 {
   char *ciphers, *curves;
   struct ssl_connect_data *connssl = cf->ctx;
-  struct wolfssl_ssl_backend_data *backend =
-    (struct wolfssl_ssl_backend_data *)connssl->backend;
+  struct wolfssl_ctx *backend =
+    (struct wolfssl_ctx *)connssl->backend;
   struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
-  const struct curl_blob *ca_info_blob = conn_config->ca_info_blob;
   const struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);
-  const char * const ssl_cafile =
-    /* CURLOPT_CAINFO_BLOB overrides CURLOPT_CAINFO */
-    (ca_info_blob ? NULL : conn_config->CAfile);
-  const char * const ssl_capath = conn_config->CApath;
   WOLFSSL_METHOD* req_method = NULL;
-#ifdef HAVE_LIBOQS
-  word16 oqsAlg = 0;
+#ifdef WOLFSSL_HAVE_KYBER
+  word16 pqkem = 0;
   size_t idx = 0;
 #endif
 #ifdef HAVE_SNI
@@ -386,8 +632,6 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
 #else
 #define use_sni(x)  Curl_nop_stmt
 #endif
-  bool imported_native_ca = false;
-  bool imported_ca_info_blob = false;
 
   DEBUGASSERT(backend);
 
@@ -399,7 +643,7 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
     return CURLE_SSL_CONNECT_ERROR;
   }
 
-  /* check to see if we've been told to use an explicit SSL/TLS version */
+  /* check to see if we have been told to use an explicit SSL/TLS version */
   switch(conn_config->version) {
   case CURL_SSLVERSION_DEFAULT:
   case CURL_SSLVERSION_TLSv1:
@@ -426,11 +670,11 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
 #ifndef NO_OLD_TLS
     req_method = TLSv1_1_client_method();
     use_sni(TRUE);
+    break;
 #else
     failf(data, "wolfSSL does not support TLS 1.1");
     return CURLE_NOT_BUILT_IN;
 #endif
-    break;
   case CURL_SSLVERSION_TLSv1_2:
 #ifndef WOLFSSL_NO_TLS12
     req_method = TLSv1_2_client_method();
@@ -455,7 +699,7 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
   }
 
   if(!req_method) {
-    failf(data, "SSL: couldn't create a method");
+    failf(data, "SSL: could not create a method");
     return CURLE_OUT_OF_MEMORY;
   }
 
@@ -464,7 +708,7 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
   backend->ctx = wolfSSL_CTX_new(req_method);
 
   if(!backend->ctx) {
-    failf(data, "SSL: couldn't create a context");
+    failf(data, "SSL: could not create a context");
     return CURLE_OUT_OF_MEMORY;
   }
 
@@ -485,7 +729,7 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
        && (wolfSSL_CTX_SetMinVersion(backend->ctx, WOLFSSL_TLSV1_3) != 1)
 #endif
       ) {
-      failf(data, "SSL: couldn't set the minimum protocol version");
+      failf(data, "SSL: could not set the minimum protocol version");
       return CURLE_SSL_CONNECT_ERROR;
     }
 #endif
@@ -506,15 +750,15 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
   curves = conn_config->curves;
   if(curves) {
 
-#ifdef HAVE_LIBOQS
+#ifdef WOLFSSL_HAVE_KYBER
     for(idx = 0; gnm[idx].name != NULL; idx++) {
       if(strncmp(curves, gnm[idx].name, strlen(gnm[idx].name)) == 0) {
-        oqsAlg = gnm[idx].group;
+        pqkem = gnm[idx].group;
         break;
       }
     }
 
-    if(oqsAlg == 0)
+    if(pqkem == 0)
 #endif
     {
       if(!SSL_CTX_set1_curves_list(backend->ctx, curves)) {
@@ -524,73 +768,10 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
     }
   }
 
-#if !defined(NO_FILESYSTEM) && defined(WOLFSSL_SYS_CA_CERTS)
-  /* load native CA certificates */
-  if(ssl_config->native_ca_store) {
-    if(wolfSSL_CTX_load_system_CA_certs(backend->ctx) != WOLFSSL_SUCCESS) {
-      infof(data, "error importing native CA store, continuing anyway");
-    }
-    else {
-      imported_native_ca = true;
-      infof(data, "successfully imported native CA store");
-    }
-  }
-#endif /* !NO_FILESYSTEM */
-
-  /* load certificate blob */
-  if(ca_info_blob) {
-    if(wolfSSL_CTX_load_verify_buffer(backend->ctx, ca_info_blob->data,
-                                      ca_info_blob->len,
-                                      SSL_FILETYPE_PEM) != SSL_SUCCESS) {
-      if(imported_native_ca) {
-        infof(data, "error importing CA certificate blob, continuing anyway");
-      }
-      else {
-        failf(data, "error importing CA certificate blob");
-        return CURLE_SSL_CACERT_BADFILE;
-      }
-    }
-    else {
-      imported_ca_info_blob = true;
-      infof(data, "successfully imported CA certificate blob");
-    }
-  }
-
 #ifndef NO_FILESYSTEM
-  /* load trusted cacert from file if not blob */
-  if(ssl_cafile || ssl_capath) {
-    int rc =
-      wolfSSL_CTX_load_verify_locations_ex(backend->ctx,
-                                           ssl_cafile,
-                                           ssl_capath,
-                                           WOLFSSL_LOAD_FLAG_IGNORE_ERR);
-    if(SSL_SUCCESS != rc) {
-      if(conn_config->verifypeer && !imported_ca_info_blob &&
-         !imported_native_ca) {
-        /* Fail if we insist on successfully verifying the server. */
-        failf(data, "error setting certificate verify locations:"
-              " CAfile: %s CApath: %s",
-              ssl_cafile ? ssl_cafile : "none",
-              ssl_capath ? ssl_capath : "none");
-        return CURLE_SSL_CACERT_BADFILE;
-      }
-      else {
-        /* Just continue with a warning if no strict certificate
-           verification is required. */
-        infof(data, "error setting certificate verify locations,"
-              " continuing anyway:");
-      }
-    }
-    else {
-      /* Everything is fine. */
-      infof(data, "successfully set certificate verify locations:");
-    }
-    infof(data, " CAfile: %s", ssl_cafile ? ssl_cafile : "none");
-    infof(data, " CApath: %s", ssl_capath ? ssl_capath : "none");
-  }
-
   /* Load the client certificate, and private key */
-  if(ssl_config->primary.clientcert && ssl_config->key) {
+  if(ssl_config->primary.clientcert) {
+    char *key_file = ssl_config->key;
     int file_type = do_file_type(ssl_config->cert_type);
 
     if(file_type == WOLFSSL_FILETYPE_PEM) {
@@ -614,8 +795,12 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
       return CURLE_BAD_FUNCTION_ARGUMENT;
     }
 
-    file_type = do_file_type(ssl_config->key_type);
-    if(wolfSSL_CTX_use_PrivateKey_file(backend->ctx, ssl_config->key,
+    if(!key_file)
+      key_file = ssl_config->primary.clientcert;
+    else
+      file_type = do_file_type(ssl_config->key_type);
+
+    if(wolfSSL_CTX_use_PrivateKey_file(backend->ctx, key_file,
                                        file_type) != 1) {
       failf(data, "unable to set private key");
       return CURLE_SSL_CONNECT_ERROR;
@@ -647,8 +832,14 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
 
   /* give application a chance to interfere with SSL set up. */
   if(data->set.ssl.fsslctx) {
-    CURLcode result = (*data->set.ssl.fsslctx)(data, backend->ctx,
-                                               data->set.ssl.fsslctxp);
+    CURLcode result;
+    if(!backend->x509_store_setup) {
+      result = Curl_wssl_setup_x509_store(cf, data, backend);
+      if(result)
+        return result;
+    }
+    result = (*data->set.ssl.fsslctx)(data, backend->ctx,
+                                      data->set.ssl.fsslctxp);
     if(result) {
       failf(data, "error signaled by ssl ctx callback");
       return result;
@@ -656,7 +847,7 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
   }
 #ifdef NO_FILESYSTEM
   else if(conn_config->verifypeer) {
-    failf(data, "SSL: Certificates can't be loaded because wolfSSL was built"
+    failf(data, "SSL: Certificates cannot be loaded because wolfSSL was built"
           " with \"no filesystem\". Either disable peer verification"
           " (insecure) or if you are building an application with libcurl you"
           " can load certificates via CURLOPT_SSL_CTX_FUNCTION.");
@@ -669,14 +860,14 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
     wolfSSL_free(backend->handle);
   backend->handle = wolfSSL_new(backend->ctx);
   if(!backend->handle) {
-    failf(data, "SSL: couldn't create a handle");
+    failf(data, "SSL: could not create a handle");
     return CURLE_OUT_OF_MEMORY;
   }
 
-#ifdef HAVE_LIBOQS
-  if(oqsAlg) {
-    if(wolfSSL_UseKeyShare(backend->handle, oqsAlg) != WOLFSSL_SUCCESS) {
-      failf(data, "unable to use oqs KEM");
+#ifdef WOLFSSL_HAVE_KYBER
+  if(pqkem) {
+    if(wolfSSL_UseKeyShare(backend->handle, pqkem) != WOLFSSL_SUCCESS) {
+      failf(data, "unable to use PQ KEM");
     }
   }
 #endif
@@ -688,7 +879,8 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
 
     result = Curl_alpn_to_proto_str(&proto, connssl->alpn);
     if(result ||
-       wolfSSL_UseALPN(backend->handle, (char *)proto.data, proto.len,
+       wolfSSL_UseALPN(backend->handle,
+                       (char *)proto.data, (unsigned int)proto.len,
                        WOLFSSL_ALPN_CONTINUE_ON_MISMATCH) != SSL_SUCCESS) {
       failf(data, "SSL: failed setting ALPN protocols");
       return CURLE_SSL_CONNECT_ERROR;
@@ -715,8 +907,8 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
   }
 #endif /* HAVE_SECURE_RENEGOTIATION */
 
-  /* Check if there's a cached ID we can/should use here! */
-  if(ssl_config->primary.sessionid) {
+  /* Check if there is a cached ID we can/should use here! */
+  if(ssl_config->primary.cache_session) {
     void *ssl_sessionid = NULL;
 
     Curl_ssl_sessionid_lock(data);
@@ -725,7 +917,7 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
       /* we got a session id, use it! */
       if(!SSL_set_session(backend->handle, ssl_sessionid)) {
         Curl_ssl_delsessionid(data, ssl_sessionid);
-        infof(data, "Can't use session ID, going on without");
+        infof(data, "cannot use session ID, going on without");
       }
       else
         infof(data, "SSL reusing session ID");
@@ -738,7 +930,7 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
     int trying_ech_now = 0;
 
     if(data->set.str[STRING_ECH_PUBLIC]) {
-      infof(data, "ECH: outername not (yet) supported with WolfSSL");
+      infof(data, "ECH: outername not (yet) supported with wolfSSL");
       return CURLE_SSL_CONNECT_ERROR;
     }
     if(data->set.tls_ech == CURLECH_GREASE) {
@@ -802,7 +994,7 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
 
     if(trying_ech_now
        && SSL_set_min_proto_version(backend->handle, TLS1_3_VERSION) != 1) {
-      infof(data, "ECH: Can't force TLSv1.3 [ERROR]");
+      infof(data, "ECH: cannot force TLSv1.3 [ERROR]");
       return CURLE_SSL_CONNECT_ERROR;
     }
 
@@ -834,13 +1026,31 @@ wolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)
 }
 
 
+static char *wolfssl_strerror(unsigned long error, char *buf,
+                              unsigned long size)
+{
+  DEBUGASSERT(size);
+  *buf = '\0';
+
+  wolfSSL_ERR_error_string_n(error, buf, size);
+
+  if(!*buf) {
+    const char *msg = error ? "Unknown error" : "No error";
+    strncpy(buf, msg, size - 1);
+    buf[size - 1] = '\0';
+  }
+
+  return buf;
+}
+
+
 static CURLcode
 wolfssl_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)
 {
   int ret = -1;
   struct ssl_connect_data *connssl = cf->ctx;
-  struct wolfssl_ssl_backend_data *backend =
-    (struct wolfssl_ssl_backend_data *)connssl->backend;
+  struct wolfssl_ctx *backend =
+    (struct wolfssl_ctx *)connssl->backend;
   struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);
 #ifndef CURL_DISABLE_PROXY
   const char * const pinnedpubkey = Curl_ssl_cf_is_proxy(cf)?
@@ -862,6 +1072,16 @@ wolfssl_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)
       return CURLE_SSL_CONNECT_ERROR;
   }
 
+  if(!backend->x509_store_setup) {
+    /* After having send off the ClientHello, we prepare the x509
+     * store to verify the coming certificate from the server */
+    CURLcode result;
+    result = Curl_wssl_setup_x509_store(cf, data, backend);
+    if(result)
+      return result;
+  }
+
+  connssl->io_need = CURL_SSL_IO_NEED_NONE;
   ret = wolfSSL_connect(backend->handle);
 
 #ifdef OPENSSL_EXTRA
@@ -889,15 +1109,14 @@ wolfssl_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)
 #endif  /* OPENSSL_EXTRA */
 
   if(ret != 1) {
-    char error_buffer[WOLFSSL_MAX_ERROR_SZ];
-    int  detail = wolfSSL_get_error(backend->handle, ret);
+    int detail = wolfSSL_get_error(backend->handle, ret);
 
     if(SSL_ERROR_WANT_READ == detail) {
-      connssl->connecting_state = ssl_connect_2_reading;
+      connssl->io_need = CURL_SSL_IO_NEED_RECV;
       return CURLE_OK;
     }
     else if(SSL_ERROR_WANT_WRITE == detail) {
-      connssl->connecting_state = ssl_connect_2_writing;
+      connssl->io_need = CURL_SSL_IO_NEED_SEND;
       return CURLE_OK;
     }
     /* There is no easy way to override only the CN matching.
@@ -950,7 +1169,7 @@ wolfssl_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)
       word32 echConfigsLen = 1000;
       int rv = 0;
 
-      /* this currently doesn't produce the retry_configs */
+      /* this currently does not produce the retry_configs */
       rv = wolfSSL_GetEchConfigs(backend->handle, echConfigs,
                                  &echConfigsLen);
       if(rv != WOLFSSL_SUCCESS) {
@@ -972,8 +1191,10 @@ wolfssl_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)
       return CURLE_OK;
     }
     else {
+      char error_buffer[256];
       failf(data, "SSL_connect failed with error %d: %s", detail,
-            wolfSSL_ERR_error_string(detail, error_buffer));
+            wolfssl_strerror((unsigned long)detail, error_buffer,
+                             sizeof(error_buffer)));
       return CURLE_SSL_CONNECT_ERROR;
     }
   }
@@ -1070,31 +1291,23 @@ wolfssl_connect_step3(struct Curl_cfilter *cf, struct Curl_easy *data)
 {
   CURLcode result = CURLE_OK;
   struct ssl_connect_data *connssl = cf->ctx;
-  struct wolfssl_ssl_backend_data *backend =
-    (struct wolfssl_ssl_backend_data *)connssl->backend;
+  struct wolfssl_ctx *backend =
+    (struct wolfssl_ctx *)connssl->backend;
   const struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);
 
   DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);
   DEBUGASSERT(backend);
 
-  if(ssl_config->primary.sessionid) {
+  if(ssl_config->primary.cache_session) {
     /* wolfSSL_get1_session allocates memory that has to be freed. */
     WOLFSSL_SESSION *our_ssl_sessionid = wolfSSL_get1_session(backend->handle);
 
     if(our_ssl_sessionid) {
-      void *old_ssl_sessionid = NULL;
-      bool incache;
       Curl_ssl_sessionid_lock(data);
-      incache = !(Curl_ssl_getsessionid(cf, data, &connssl->peer,
-                                        &old_ssl_sessionid, NULL));
-      if(incache) {
-        Curl_ssl_delsessionid(data, old_ssl_sessionid);
-      }
-
       /* call takes ownership of `our_ssl_sessionid` */
-      result = Curl_ssl_addsessionid(cf, data, &connssl->peer,
-                                     our_ssl_sessionid, 0,
-                                     wolfssl_session_free);
+      result = Curl_ssl_set_sessionid(cf, data, &connssl->peer,
+                                      our_ssl_sessionid, 0,
+                                      wolfssl_session_free);
       Curl_ssl_sessionid_unlock(data);
       if(result) {
         failf(data, "failed to store ssl session");
@@ -1116,9 +1329,8 @@ static ssize_t wolfssl_send(struct Curl_cfilter *cf,
                             CURLcode *curlcode)
 {
   struct ssl_connect_data *connssl = cf->ctx;
-  struct wolfssl_ssl_backend_data *backend =
-    (struct wolfssl_ssl_backend_data *)connssl->backend;
-  char error_buffer[WOLFSSL_MAX_ERROR_SZ];
+  struct wolfssl_ctx *backend =
+    (struct wolfssl_ctx *)connssl->backend;
   int memlen = (len > (size_t)INT_MAX) ? INT_MAX : (int)len;
   int rc;
 
@@ -1133,7 +1345,7 @@ static ssize_t wolfssl_send(struct Curl_cfilter *cf,
     switch(err) {
     case SSL_ERROR_WANT_READ:
     case SSL_ERROR_WANT_WRITE:
-      /* there's data pending, re-invoke SSL_write() */
+      /* there is data pending, re-invoke SSL_write() */
       CURL_TRC_CF(data, cf, "wolfssl_send(len=%zu) -> AGAIN", len);
       *curlcode = CURLE_AGAIN;
       return -1;
@@ -1144,9 +1356,13 @@ static ssize_t wolfssl_send(struct Curl_cfilter *cf,
         return -1;
       }
       CURL_TRC_CF(data, cf, "wolfssl_send(len=%zu) -> %d, %d", len, rc, err);
-      failf(data, "SSL write: %s, errno %d",
-            wolfSSL_ERR_error_string(err, error_buffer),
-            SOCKERRNO);
+      {
+        char error_buffer[256];
+        failf(data, "SSL write: %s, errno %d",
+              wolfssl_strerror((unsigned long)err, error_buffer,
+                               sizeof(error_buffer)),
+              SOCKERRNO);
+      }
       *curlcode = CURLE_SEND_ERROR;
       return -1;
     }
@@ -1155,23 +1371,111 @@ static ssize_t wolfssl_send(struct Curl_cfilter *cf,
   return rc;
 }
 
+static CURLcode wolfssl_shutdown(struct Curl_cfilter *cf,
+                                 struct Curl_easy *data,
+                                 bool send_shutdown, bool *done)
+{
+  struct ssl_connect_data *connssl = cf->ctx;
+  struct wolfssl_ctx *wctx = (struct wolfssl_ctx *)connssl->backend;
+  CURLcode result = CURLE_OK;
+  char buf[1024];
+  int nread, err;
+
+  DEBUGASSERT(wctx);
+  if(!wctx->handle || cf->shutdown) {
+    *done = TRUE;
+    goto out;
+  }
+
+  connssl->io_need = CURL_SSL_IO_NEED_NONE;
+  *done = FALSE;
+  if(!(wolfSSL_get_shutdown(wctx->handle) & SSL_SENT_SHUTDOWN)) {
+    /* We have not started the shutdown from our side yet. Check
+     * if the server already sent us one. */
+    ERR_clear_error();
+    nread = wolfSSL_read(wctx->handle, buf, (int)sizeof(buf));
+    err = wolfSSL_get_error(wctx->handle, nread);
+    if(!nread && err == SSL_ERROR_ZERO_RETURN) {
+      bool input_pending;
+      /* Yes, it did. */
+      if(!send_shutdown) {
+        CURL_TRC_CF(data, cf, "SSL shutdown received, not sending");
+        *done = TRUE;
+        goto out;
+      }
+      else if(!cf->next->cft->is_alive(cf->next, data, &input_pending)) {
+        /* Server closed the connection after its closy notify. It
+         * seems not interested to see our close notify, so do not
+         * send it. We are done. */
+        CURL_TRC_CF(data, cf, "peer closed connection");
+        connssl->peer_closed = TRUE;
+        *done = TRUE;
+        goto out;
+      }
+    }
+  }
+
+  if(send_shutdown && wolfSSL_shutdown(wctx->handle) == 1) {
+    CURL_TRC_CF(data, cf, "SSL shutdown finished");
+    *done = TRUE;
+    goto out;
+  }
+  else {
+    size_t i;
+    /* SSL should now have started the shutdown from our side. Since it
+     * was not complete, we are lacking the close notify from the server. */
+    for(i = 0; i < 10; ++i) {
+      ERR_clear_error();
+      nread = wolfSSL_read(wctx->handle, buf, (int)sizeof(buf));
+      if(nread <= 0)
+        break;
+    }
+    err = wolfSSL_get_error(wctx->handle, nread);
+    switch(err) {
+    case SSL_ERROR_ZERO_RETURN: /* no more data */
+      CURL_TRC_CF(data, cf, "SSL shutdown received");
+      *done = TRUE;
+      break;
+    case SSL_ERROR_NONE: /* just did not get anything */
+    case SSL_ERROR_WANT_READ:
+      /* SSL has send its notify and now wants to read the reply
+       * from the server. We are not really interested in that. */
+      CURL_TRC_CF(data, cf, "SSL shutdown sent, want receive");
+      connssl->io_need = CURL_SSL_IO_NEED_RECV;
+      break;
+    case SSL_ERROR_WANT_WRITE:
+      CURL_TRC_CF(data, cf, "SSL shutdown send blocked");
+      connssl->io_need = CURL_SSL_IO_NEED_SEND;
+      break;
+    default: {
+      char error_buffer[256];
+      int detail = wolfSSL_get_error(wctx->handle, err);
+      CURL_TRC_CF(data, cf, "SSL shutdown, error: '%s'(%d)",
+                  wolfssl_strerror((unsigned long)err, error_buffer,
+                                   sizeof(error_buffer)),
+                  detail);
+      result = CURLE_RECV_ERROR;
+      break;
+    }
+    }
+  }
+
+out:
+  cf->shutdown = (result || *done);
+  return result;
+}
+
 static void wolfssl_close(struct Curl_cfilter *cf, struct Curl_easy *data)
 {
   struct ssl_connect_data *connssl = cf->ctx;
-  struct wolfssl_ssl_backend_data *backend =
-    (struct wolfssl_ssl_backend_data *)connssl->backend;
+  struct wolfssl_ctx *backend =
+    (struct wolfssl_ctx *)connssl->backend;
 
   (void) data;
 
   DEBUGASSERT(backend);
 
   if(backend->handle) {
-    char buf[32];
-    /* Maybe the server has already sent a close notify alert.
-       Read it to avoid an RST on the TCP connection. */
-    (void)wolfSSL_read(backend->handle, buf, (int)sizeof(buf));
-    if(!connssl->peer_closed)
-      (void)wolfSSL_shutdown(backend->handle);
     wolfSSL_free(backend->handle);
     backend->handle = NULL;
   }
@@ -1187,9 +1491,8 @@ static ssize_t wolfssl_recv(struct Curl_cfilter *cf,
                             CURLcode *curlcode)
 {
   struct ssl_connect_data *connssl = cf->ctx;
-  struct wolfssl_ssl_backend_data *backend =
-    (struct wolfssl_ssl_backend_data *)connssl->backend;
-  char error_buffer[WOLFSSL_MAX_ERROR_SZ];
+  struct wolfssl_ctx *backend =
+    (struct wolfssl_ctx *)connssl->backend;
   int buffsize = (blen > (size_t)INT_MAX) ? INT_MAX : (int)blen;
   int nread;
 
@@ -1211,7 +1514,7 @@ static ssize_t wolfssl_recv(struct Curl_cfilter *cf,
     case SSL_ERROR_NONE:
     case SSL_ERROR_WANT_READ:
     case SSL_ERROR_WANT_WRITE:
-      /* there's data pending, re-invoke wolfSSL_read() */
+      /* there is data pending, re-invoke wolfSSL_read() */
       CURL_TRC_CF(data, cf, "wolfssl_recv(len=%zu) -> AGAIN", blen);
       *curlcode = CURLE_AGAIN;
       return -1;
@@ -1221,8 +1524,13 @@ static ssize_t wolfssl_recv(struct Curl_cfilter *cf,
         *curlcode = CURLE_AGAIN;
         return -1;
       }
-      failf(data, "SSL read: %s, errno %d",
-            wolfSSL_ERR_error_string(err, error_buffer), SOCKERRNO);
+      {
+        char error_buffer[256];
+        failf(data, "SSL read: %s, errno %d",
+              wolfssl_strerror((unsigned long)err, error_buffer,
+                               sizeof(error_buffer)),
+              SOCKERRNO);
+      }
       *curlcode = CURLE_RECV_ERROR;
       return -1;
     }
@@ -1269,43 +1577,18 @@ static bool wolfssl_data_pending(struct Curl_cfilter *cf,
                                  const struct Curl_easy *data)
 {
   struct ssl_connect_data *ctx = cf->ctx;
-  struct wolfssl_ssl_backend_data *backend;
+  struct wolfssl_ctx *backend;
 
   (void)data;
   DEBUGASSERT(ctx && ctx->backend);
 
-  backend = (struct wolfssl_ssl_backend_data *)ctx->backend;
+  backend = (struct wolfssl_ctx *)ctx->backend;
   if(backend->handle)   /* SSL is in use */
     return (0 != wolfSSL_pending(backend->handle)) ? TRUE : FALSE;
   else
     return FALSE;
 }
 
-
-/*
- * This function is called to shut down the SSL layer but keep the
- * socket open (CCC - Clear Command Channel)
- */
-static int wolfssl_shutdown(struct Curl_cfilter *cf,
-                            struct Curl_easy *data)
-{
-  struct ssl_connect_data *ctx = cf->ctx;
-  struct wolfssl_ssl_backend_data *backend;
-  int retval = 0;
-
-  (void)data;
-  DEBUGASSERT(ctx && ctx->backend);
-
-  backend = (struct wolfssl_ssl_backend_data *)ctx->backend;
-  if(backend->handle) {
-    wolfSSL_ERR_clear_error();
-    wolfSSL_free(backend->handle);
-    backend->handle = NULL;
-  }
-  return retval;
-}
-
-
 static CURLcode
 wolfssl_connect_common(struct Curl_cfilter *cf,
                        struct Curl_easy *data,
@@ -1324,7 +1607,7 @@ wolfssl_connect_common(struct Curl_cfilter *cf,
   }
 
   if(ssl_connect_1 == connssl->connecting_state) {
-    /* Find out how much more time we're allowed */
+    /* Find out how much more time we are allowed */
     const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);
 
     if(timeout_ms < 0) {
@@ -1338,9 +1621,7 @@ wolfssl_connect_common(struct Curl_cfilter *cf,
       return result;
   }
 
-  while(ssl_connect_2 == connssl->connecting_state ||
-        ssl_connect_2_reading == connssl->connecting_state ||
-        ssl_connect_2_writing == connssl->connecting_state) {
+  while(ssl_connect_2 == connssl->connecting_state) {
 
     /* check allowed time left */
     const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);
@@ -1351,14 +1632,13 @@ wolfssl_connect_common(struct Curl_cfilter *cf,
       return CURLE_OPERATION_TIMEDOUT;
     }
 
-    /* if ssl is expecting something, check if it's available. */
-    if(connssl->connecting_state == ssl_connect_2_reading
-       || connssl->connecting_state == ssl_connect_2_writing) {
+    /* if ssl is expecting something, check if it is available. */
+    if(connssl->io_need) {
 
-      curl_socket_t writefd = ssl_connect_2_writing ==
-        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;
-      curl_socket_t readfd = ssl_connect_2_reading ==
-        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;
+      curl_socket_t writefd = (connssl->io_need & CURL_SSL_IO_NEED_SEND)?
+                              sockfd:CURL_SOCKET_BAD;
+      curl_socket_t readfd = (connssl->io_need & CURL_SSL_IO_NEED_RECV)?
+                             sockfd:CURL_SOCKET_BAD;
 
       what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,
                                nonblocking?0:timeout_ms);
@@ -1389,10 +1669,7 @@ wolfssl_connect_common(struct Curl_cfilter *cf,
      * have a valid fdset to wait on.
      */
     result = wolfssl_connect_step2(cf, data);
-    if(result || (nonblocking &&
-                  (ssl_connect_2 == connssl->connecting_state ||
-                   ssl_connect_2_reading == connssl->connecting_state ||
-                   ssl_connect_2_writing == connssl->connecting_state)))
+    if(result || (nonblocking && (ssl_connect_2 == connssl->connecting_state)))
       return result;
   } /* repeat step2 until all transactions are done. */
 
@@ -1472,15 +1749,15 @@ static CURLcode wolfssl_sha256sum(const unsigned char *tmp, /* input */
 static void *wolfssl_get_internals(struct ssl_connect_data *connssl,
                                    CURLINFO info UNUSED_PARAM)
 {
-  struct wolfssl_ssl_backend_data *backend =
-    (struct wolfssl_ssl_backend_data *)connssl->backend;
+  struct wolfssl_ctx *backend =
+    (struct wolfssl_ctx *)connssl->backend;
   (void)info;
   DEBUGASSERT(backend);
   return backend->handle;
 }
 
 const struct Curl_ssl Curl_ssl_wolfssl = {
-  { CURLSSLBACKEND_WOLFSSL, "WolfSSL" }, /* info */
+  { CURLSSLBACKEND_WOLFSSL, "wolfssl" }, /* info */
 
 #ifdef KEEP_PEER_CERT
   SSLSUPP_PINNEDPUBKEY |
@@ -1493,9 +1770,10 @@ const struct Curl_ssl Curl_ssl_wolfssl = {
 #ifdef USE_ECH
   SSLSUPP_ECH |
 #endif
-  SSLSUPP_SSL_CTX,
+  SSLSUPP_SSL_CTX |
+  SSLSUPP_CA_CACHE,
 
-  sizeof(struct wolfssl_ssl_backend_data),
+  sizeof(struct wolfssl_ctx),
 
   wolfssl_init,                    /* init */
   wolfssl_cleanup,                 /* cleanup */
@@ -1518,7 +1796,6 @@ const struct Curl_ssl Curl_ssl_wolfssl = {
   wolfssl_sha256sum,               /* sha256sum */
   NULL,                            /* associate_connection */
   NULL,                            /* disassociate_connection */
-  NULL,                            /* free_multi_ssl_backend_data */
   wolfssl_recv,                    /* recv decrypted data */
   wolfssl_send,                    /* send data to encrypt */
 };
diff --git a/lib/vtls/wolfssl.h b/lib/vtls/wolfssl.h
index a5ed84809..d75bdaa1e 100644
--- a/lib/vtls/wolfssl.h
+++ b/lib/vtls/wolfssl.h
@@ -26,8 +26,25 @@
 #include "curl_setup.h"
 
 #ifdef USE_WOLFSSL
+#include <wolfssl/version.h>
+#include <wolfssl/options.h>
+#include <wolfssl/ssl.h>
+#include <wolfssl/error-ssl.h>
+
+#include "urldata.h"
 
 extern const struct Curl_ssl Curl_ssl_wolfssl;
 
+struct wolfssl_ctx {
+  WOLFSSL_CTX *ctx;
+  WOLFSSL     *handle;
+  CURLcode    io_result;   /* result of last BIO cfilter operation */
+  BIT(x509_store_setup);   /* x509 store has been set up */
+};
+
+CURLcode Curl_wssl_setup_x509_store(struct Curl_cfilter *cf,
+                                    struct Curl_easy *data,
+                                    struct wolfssl_ctx *wssl);
+
 #endif /* USE_WOLFSSL */
 #endif /* HEADER_CURL_WOLFSSL_H */
diff --git a/lib/vtls/x509asn1.c b/lib/vtls/x509asn1.c
index 4564ea958..7f04af3b9 100644
--- a/lib/vtls/x509asn1.c
+++ b/lib/vtls/x509asn1.c
@@ -25,13 +25,15 @@
 #include "curl_setup.h"
 
 #if defined(USE_GNUTLS) || defined(USE_WOLFSSL) ||      \
-  defined(USE_SCHANNEL) || defined(USE_SECTRANSP)
+  defined(USE_SCHANNEL) || defined(USE_SECTRANSP) ||    \
+  defined(USE_MBEDTLS)
 
 #if defined(USE_WOLFSSL) || defined(USE_SCHANNEL)
 #define WANT_PARSEX509 /* uses Curl_parseX509() */
 #endif
 
-#if defined(USE_GNUTLS) || defined(USE_SCHANNEL) || defined(USE_SECTRANSP)
+#if defined(USE_GNUTLS) || defined(USE_SCHANNEL) || defined(USE_SECTRANSP) || \
+  defined(USE_MBEDTLS)
 #define WANT_EXTRACT_CERTINFO /* uses Curl_extract_certinfo() */
 #define WANT_PARSEX509 /* ... uses Curl_parseX509() */
 #endif
@@ -110,15 +112,16 @@ struct Curl_OID {
 };
 
 /* ASN.1 OIDs. */
-static const char       cnOID[] = "2.5.4.3";    /* Common name. */
-static const char       sanOID[] = "2.5.29.17"; /* Subject alternative name. */
-
 static const struct Curl_OID OIDtable[] = {
   { "1.2.840.10040.4.1",        "dsa" },
   { "1.2.840.10040.4.3",        "dsa-with-sha1" },
   { "1.2.840.10045.2.1",        "ecPublicKey" },
   { "1.2.840.10045.3.0.1",      "c2pnb163v1" },
   { "1.2.840.10045.4.1",        "ecdsa-with-SHA1" },
+  { "1.2.840.10045.4.3.1",      "ecdsa-with-SHA224" },
+  { "1.2.840.10045.4.3.2",      "ecdsa-with-SHA256" },
+  { "1.2.840.10045.4.3.3",      "ecdsa-with-SHA384" },
+  { "1.2.840.10045.4.3.4",      "ecdsa-with-SHA512" },
   { "1.2.840.10046.2.1",        "dhpublicnumber" },
   { "1.2.840.113549.1.1.1",     "rsaEncryption" },
   { "1.2.840.113549.1.1.2",     "md2WithRSAEncryption" },
@@ -132,7 +135,7 @@ static const struct Curl_OID OIDtable[] = {
   { "1.2.840.113549.2.2",       "md2" },
   { "1.2.840.113549.2.5",       "md5" },
   { "1.3.14.3.2.26",            "sha1" },
-  { cnOID,                      "CN" },
+  { "2.5.4.3",                  "CN" },
   { "2.5.4.4",                  "SN" },
   { "2.5.4.5",                  "serialNumber" },
   { "2.5.4.6",                  "C" },
@@ -153,7 +156,7 @@ static const struct Curl_OID OIDtable[] = {
   { "2.5.4.65",                 "pseudonym" },
   { "1.2.840.113549.1.9.1",     "emailAddress" },
   { "2.5.4.72",                 "role" },
-  { sanOID,                     "subjectAltName" },
+  { "2.5.29.17",                "subjectAltName" },
   { "2.5.29.18",                "issuerAltName" },
   { "2.5.29.19",                "basicConstraints" },
   { "2.16.840.1.101.3.4.2.4",   "sha224" },
@@ -372,7 +375,7 @@ utf8asn1str(struct dynbuf *to, int type, const char *from, const char *end)
   else {
     while(!result && (from < end)) {
       char buf[4]; /* decode buffer */
-      int charsize = 1;
+      size_t charsize = 1;
       unsigned int wc = 0;
 
       switch(size) {
@@ -390,7 +393,6 @@ utf8asn1str(struct dynbuf *to, int type, const char *from, const char *end)
         if(wc >= 0x00000800) {
           if(wc >= 0x00010000) {
             if(wc >= 0x00200000) {
-              free(buf);
               /* Invalid char. size for target encoding. */
               return CURLE_WEIRD_SERVER_REPLY;
             }
@@ -469,7 +471,7 @@ static CURLcode OID2str(struct dynbuf *store,
         if(op)
           result = Curl_dyn_add(store, op->textoid);
         else
-          result = CURLE_BAD_FUNCTION_ARGUMENT;
+          result = Curl_dyn_add(store, Curl_dyn_ptr(&buf));
         Curl_dyn_free(&buf);
       }
     }
@@ -492,7 +494,7 @@ static CURLcode GTime2str(struct dynbuf *store,
   /* Convert an ASN.1 Generalized time to a printable string.
      Return the dynamically allocated string, or NULL if an error occurs. */
 
-  for(fracp = beg; fracp < end && *fracp >= '0' && *fracp <= '9'; fracp++)
+  for(fracp = beg; fracp < end && ISDIGIT(*fracp); fracp++)
     ;
 
   /* Get seconds digits. */
@@ -511,32 +513,44 @@ static CURLcode GTime2str(struct dynbuf *store,
     return CURLE_BAD_FUNCTION_ARGUMENT;
   }
 
-  /* Scan for timezone, measure fractional seconds. */
+  /* timezone follows optional fractional seconds. */
   tzp = fracp;
-  fracl = 0;
+  fracl = 0; /* no fractional seconds detected so far */
   if(fracp < end && (*fracp == '.' || *fracp == ',')) {
-    fracp++;
-    do
+    /* Have fractional seconds, e.g. "[.,]\d+". How many? */
+    fracp++; /* should be a digit char or BAD ARGUMENT */
+    tzp = fracp;
+    while(tzp < end && ISDIGIT(*tzp))
       tzp++;
-    while(tzp < end && *tzp >= '0' && *tzp <= '9');
-    /* Strip leading zeroes in fractional seconds. */
-    for(fracl = tzp - fracp - 1; fracl && fracp[fracl - 1] == '0'; fracl--)
-      ;
+    if(tzp == fracp) /* never looped, no digit after [.,] */
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    fracl = tzp - fracp; /* number of fractional sec digits */
+    DEBUGASSERT(fracl > 0);
+    /* Strip trailing zeroes in fractional seconds.
+     * May reduce fracl to 0 if only '0's are present. */
+    while(fracl && fracp[fracl - 1] == '0')
+      fracl--;
   }
 
   /* Process timezone. */
-  if(tzp >= end)
-    ;           /* Nothing to do. */
+  if(tzp >= end) {
+    tzp = "";
+    tzl = 0;
+  }
   else if(*tzp == 'Z') {
-    tzp = " GMT";
-    end = tzp + 4;
+    sep = " ";
+    tzp = "GMT";
+    tzl = 3;
+  }
+  else if((*tzp == '+') || (*tzp == '-')) {
+    sep = " UTC";
+    tzl = end - tzp;
   }
   else {
     sep = " ";
-    tzp++;
+    tzl = end - tzp;
   }
 
-  tzl = end - tzp;
   return Curl_dyn_addf(store,
                        "%.4s-%.2s-%.2s %.2s:%.2s:%c%c%s%.*s%s%.*s",
                        beg, beg + 4, beg + 6,
@@ -545,6 +559,15 @@ static CURLcode GTime2str(struct dynbuf *store,
                        sep, (int)tzl, tzp);
 }
 
+#ifdef UNITTESTS
+/* used by unit1656.c */
+CURLcode Curl_x509_GTime2str(struct dynbuf *store,
+                             const char *beg, const char *end)
+{
+  return GTime2str(store, beg, end);
+}
+#endif
+
 /*
  * Convert an ASN.1 UTC time to a printable string.
  *
@@ -598,7 +621,7 @@ static CURLcode ASN1tostr(struct dynbuf *store,
 {
   CURLcode result = CURLE_BAD_FUNCTION_ARGUMENT;
   if(elem->constructed)
-    return CURLE_OK; /* No conversion of structured elements. */
+    return result; /* No conversion of structured elements. */
 
   if(!type)
     type = elem->tag;   /* Type not forced: use element tag as type. */
@@ -692,6 +715,11 @@ static CURLcode encodeDN(struct dynbuf *store, struct Curl_asn1Element *dn)
 
       str = Curl_dyn_ptr(&temp);
 
+      if(!str) {
+        result = CURLE_BAD_FUNCTION_ARGUMENT;
+        goto error;
+      }
+
       /* Encode delimiter.
          If attribute has a short uppercase name, delimiter is ", ". */
       for(p3 = str; ISUPPER(*p3); p3++)
@@ -959,7 +987,8 @@ static int do_pubkey(struct Curl_easy *data, int certnum,
       if(ssl_push_certinfo(data, certnum, "ECC Public Key", q))
         return 1;
     }
-    return do_pubkey_field(data, certnum, "ecPublicKey", pubkey);
+    return do_pubkey_field(data, certnum, "ecPublicKey", pubkey) == CURLE_OK
+      ? 0 : 1;
   }
 
   /* Get the public key (single element). */
@@ -1223,6 +1252,8 @@ CURLcode Curl_extract_certinfo(struct Curl_easy *data,
       result = ssl_push_certinfo_dyn(data, certnum, "Cert", &out);
 
 done:
+  if(result)
+    failf(data, "Failed extracting certificate chain");
   Curl_dyn_free(&out);
   return result;
 }
diff --git a/lib/vtls/x509asn1.h b/lib/vtls/x509asn1.h
index 23a67b828..5b48596c7 100644
--- a/lib/vtls/x509asn1.h
+++ b/lib/vtls/x509asn1.h
@@ -28,7 +28,8 @@
 #include "curl_setup.h"
 
 #if defined(USE_GNUTLS) || defined(USE_WOLFSSL) || \
-  defined(USE_SCHANNEL) || defined(USE_SECTRANSP)
+  defined(USE_SCHANNEL) || defined(USE_SECTRANSP) || \
+  defined(USE_MBEDTLS)
 
 #include "cfilters.h"
 #include "urldata.h"
@@ -76,5 +77,16 @@ CURLcode Curl_extract_certinfo(struct Curl_easy *data, int certnum,
                                const char *beg, const char *end);
 CURLcode Curl_verifyhost(struct Curl_cfilter *cf, struct Curl_easy *data,
                          const char *beg, const char *end);
+
+#ifdef UNITTESTS
+#if defined(USE_GNUTLS) || defined(USE_SCHANNEL) || defined(USE_SECTRANSP) || \
+  defined(USE_MBEDTLS)
+
+/* used by unit1656.c */
+CURLcode Curl_x509_GTime2str(struct dynbuf *store,
+                             const char *beg, const char *end);
+#endif
+#endif
+
 #endif /* USE_GNUTLS or USE_WOLFSSL or USE_SCHANNEL or USE_SECTRANSP */
 #endif /* HEADER_CURL_X509ASN1_H */
diff --git a/lib/ws.c b/lib/ws.c
index 6ccf9e65f..3c2d94950 100644
--- a/lib/ws.c
+++ b/lib/ws.c
@@ -102,7 +102,7 @@ static unsigned char ws_frame_flags2op(int flags)
   size_t i;
   for(i = 0; i < sizeof(WS_FRAMES)/sizeof(WS_FRAMES[0]); ++i) {
     if(WS_FRAMES[i].flags & flags)
-      return WS_FRAMES[i].proto_opcode;
+      return (unsigned char)WS_FRAMES[i].proto_opcode;
   }
   return 0;
 }
@@ -171,7 +171,7 @@ static CURLcode ws_dec_read_head(struct ws_decoder *dec,
       dec->head[0] = *inbuf;
       Curl_bufq_skip(inraw, 1);
 
-      dec->frame_flags  = ws_frame_op2flags(dec->head[0]);
+      dec->frame_flags = ws_frame_op2flags(dec->head[0]);
       if(!dec->frame_flags) {
         failf(data, "WS: unknown opcode: %x", dec->head[0]);
         ws_dec_reset(dec);
@@ -560,7 +560,7 @@ static ssize_t ws_enc_write_head(struct Curl_easy *data,
     return -1;
   }
 
-  opcode = ws_frame_flags2op(flags);
+  opcode = ws_frame_flags2op((int)flags);
   if(!opcode) {
     failf(data, "WS: provided flags not recognized '%x'", flags);
     *err = CURLE_SEND_ERROR;
@@ -579,7 +579,7 @@ static ssize_t ws_enc_write_head(struct Curl_easy *data,
     enc->contfragment = FALSE;
   }
   else if(enc->contfragment) {
-    /* the previous fragment was not a final one and this isn't either, keep a
+    /* the previous fragment was not a final one and this is not either, keep a
        CONT opcode and no FIN bit */
     firstbyte |= WSBIT_OPCODE_CONT;
   }
diff --git a/lib/ws.h b/lib/ws.h
index baa77b442..398900cc3 100644
--- a/lib/ws.h
+++ b/lib/ws.h
@@ -57,7 +57,7 @@ struct ws_encoder {
   curl_off_t payload_len;  /* payload length of current frame */
   curl_off_t payload_remain;  /* remaining payload of current */
   unsigned int xori; /* xor index */
-  unsigned char mask[4]; /* 32 bit mask for this connection */
+  unsigned char mask[4]; /* 32-bit mask for this connection */
   unsigned char firstbyte; /* first byte of frame we encode */
   bool contfragment; /* set TRUE if the previous fragment sent was not final */
 };
diff --git a/libcurl.pc.in b/libcurl.pc.in
index 9db6b0f89..0eb180485 100644
--- a/libcurl.pc.in
+++ b/libcurl.pc.in
@@ -22,9 +22,6 @@
 #
 ###########################################################################
 
-# This should most probably benefit from getting a "Requires:" field added
-# dynamically by configure.
-#
 prefix=@prefix@
 exec_prefix=@exec_prefix@
 libdir=@libdir@
@@ -36,6 +33,8 @@ Name: libcurl
 URL: https://curl.se/
 Description: Library to transfer files with ftp, http, etc.
 Version: @CURLVERSION@
+Requires: @LIBCURL_PC_REQUIRES@
+Requires.private: @LIBCURL_PC_REQUIRES_PRIVATE@
 Libs: -L${libdir} -lcurl @LIBCURL_NO_SHARED@
 Libs.private: @LIBCURL_LIBS@
 Cflags: -I${includedir} @CPPFLAG_CURL_STATICLIB@
diff --git a/m4/curl-compilers.m4 b/m4/curl-compilers.m4
index 06e335d8f..001e5f4aa 100644
--- a/m4/curl-compilers.m4
+++ b/m4/curl-compilers.m4
@@ -519,6 +519,7 @@ AC_DEFUN([CURL_SET_COMPILER_BASIC_OPTS], [
         dnl warn about compile-time arguments used during link-time, like
         dnl -O and -g and -pedantic.
         tmp_CFLAGS="$tmp_CFLAGS -Qunused-arguments"
+        tmp_CFLAGS="$tmp_CFLAGS -Werror-implicit-function-declaration"
         ;;
         #
       DEC_C)
@@ -897,10 +898,6 @@ AC_DEFUN([CURL_SET_COMPILER_WARNING_OPTS], [
             tmp_CFLAGS="$tmp_CFLAGS -Wimplicit-fallthrough"  # we have silencing markup for clang 10.0 and above only
           fi
         fi
-        dnl Disable pointer to bool conversion warnings since they cause
-        dnl lib/securetransp.c cause several warnings for checks we want.
-        dnl This option should be placed after -Wconversion.
-        tmp_CFLAGS="$tmp_CFLAGS -Wno-pointer-bool-conversion"
         ;;
         #
       DEC_C)
@@ -1248,52 +1245,6 @@ squeeze() {
 ])
 
 
-dnl CURL_CHECK_CURLDEBUG
-dnl -------------------------------------------------
-dnl Settings which depend on configure's curldebug given
-dnl option, and other additional configure pre-requisites.
-dnl Actually the curl debug memory tracking feature can
-dnl only be used/enabled when libcurl is built as a static
-dnl library or as a shared one on those systems on which
-dnl shared libraries support undefined symbols.
-
-AC_DEFUN([CURL_CHECK_CURLDEBUG], [
-  AC_REQUIRE([XC_LIBTOOL])dnl
-  AC_REQUIRE([CURL_SHFUNC_SQUEEZE])dnl
-  supports_curldebug="unknown"
-  if test "$want_curldebug" = "yes"; then
-    if test "x$enable_shared" != "xno" &&
-      test "x$enable_shared" != "xyes"; then
-      AC_MSG_WARN([unknown enable_shared setting.])
-      supports_curldebug="no"
-    fi
-    if test "x$enable_static" != "xno" &&
-      test "x$enable_static" != "xyes"; then
-      AC_MSG_WARN([unknown enable_static setting.])
-      supports_curldebug="no"
-    fi
-    if test "$supports_curldebug" != "no"; then
-      if test "$enable_shared" = "yes" &&
-        test "x$xc_lt_shlib_use_no_undefined" = 'xyes'; then
-        supports_curldebug="no"
-        AC_MSG_WARN([shared library does not support undefined symbols.])
-      fi
-    fi
-  fi
-  #
-  if test "$want_curldebug" = "yes"; then
-    AC_MSG_CHECKING([if curl debug memory tracking can be enabled])
-    test "$supports_curldebug" = "no" || supports_curldebug="yes"
-    AC_MSG_RESULT([$supports_curldebug])
-    if test "$supports_curldebug" = "no"; then
-      AC_MSG_WARN([cannot enable curl debug memory tracking.])
-      want_curldebug="no"
-    fi
-  fi
-])
-
-
-
 dnl CURL_CHECK_COMPILER_HALT_ON_ERROR
 dnl -------------------------------------------------
 dnl Verifies if the compiler actually halts after the
diff --git a/m4/curl-confopts.m4 b/m4/curl-confopts.m4
index 5c307fc81..5ee1632c6 100644
--- a/m4/curl-confopts.m4
+++ b/m4/curl-confopts.m4
@@ -563,6 +563,7 @@ AC_DEFUN([CURL_CHECK_LIB_ARES], [
       AC_DEFINE(USE_ARES, 1, [Define to enable c-ares support])
       AC_DEFINE(CARES_NO_DEPRECATED, 1, [Ignore c-ares deprecation warnings])
       AC_SUBST([USE_ARES], [1])
+      LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE libcares"
       curl_res_msg="c-ares"
     fi
   fi
@@ -661,7 +662,6 @@ AS_HELP_STRING([--disable-httpsrr],[Disable HTTPSRR support]),
       dnl --enable-httpsrr option used
       want_httpsrr="yes"
       curl_httpsrr_msg="enabled (--disable-httpsrr)"
-      experimental="httpsrr"
       AC_MSG_RESULT([yes])
       ;;
   esac
@@ -697,7 +697,6 @@ AS_HELP_STRING([--disable-ech],[Disable ECH support]),
       dnl --enable-ech option used
       want_ech="yes"
       curl_ech_msg="enabled (--disable-ech)"
-      experimental="ech"
       AC_MSG_RESULT([yes])
       ;;
   esac
diff --git a/m4/curl-functions.m4 b/m4/curl-functions.m4
index f0860ddbb..c65120271 100644
--- a/m4/curl-functions.m4
+++ b/m4/curl-functions.m4
@@ -1563,7 +1563,7 @@ AC_DEFUN([CURL_CHECK_FUNC_GETADDRINFO], [
 #elif defined(_XOPEN_SOURCE) && (_XOPEN_SOURCE >= 700)
           return 0;
 #else
-          force compilation error
+          #error force compilation error
 #endif
         ]])
       ],[
@@ -5004,7 +5004,7 @@ $2
   fi
   AC_MSG_RESULT($r)
   dnl lowercase and underscore instead of space
-  tname=$(echo "ac_cv_sizeof_$1" | tr A-Z a-z | tr " " "_")
+  tname=`echo "ac_cv_sizeof_$1" | tr A-Z a-z | tr " " "_"`
   eval "$tname=$r"
 
   AC_DEFINE_UNQUOTED(TYPE, [$r], [Size of $1 in number of bytes])
diff --git a/m4/curl-gnutls.m4 b/m4/curl-gnutls.m4
index d4f553d69..6a297f684 100644
--- a/m4/curl-gnutls.m4
+++ b/m4/curl-gnutls.m4
@@ -126,6 +126,7 @@ if test "x$OPT_GNUTLS" != xno; then
             AC_MSG_NOTICE([Added $gtlslib to CURL_LIBRARY_PATH])
           fi
         fi
+        LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE gnutls nettle"
       fi
 
     fi
diff --git a/m4/curl-mbedtls.m4 b/m4/curl-mbedtls.m4
index 64116e758..8504015da 100644
--- a/m4/curl-mbedtls.m4
+++ b/m4/curl-mbedtls.m4
@@ -101,6 +101,7 @@ if test "x$OPT_MBEDTLS" != xno; then
           AC_MSG_NOTICE([Added $mbedtlslib to CURL_LIBRARY_PATH])
         fi
       fi
+      LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE mbedtls"
     fi
 
   fi dnl mbedTLS not disabled
diff --git a/m4/curl-openssl.m4 b/m4/curl-openssl.m4
index 2fb2abecc..76107c21a 100644
--- a/m4/curl-openssl.m4
+++ b/m4/curl-openssl.m4
@@ -293,7 +293,7 @@ if test "x$OPT_OPENSSL" != xno; then
         AC_MSG_RESULT([no])
     ])
 
-    AC_MSG_CHECKING([for libressl])
+    AC_MSG_CHECKING([for LibreSSL])
     AC_COMPILE_IFELSE([
       AC_LANG_PROGRAM([[
 #include <openssl/opensslv.h>
@@ -303,8 +303,8 @@ if test "x$OPT_OPENSSL" != xno; then
     ],[
       AC_MSG_RESULT([yes])
       AC_DEFINE_UNQUOTED(HAVE_LIBRESSL, 1,
-        [Define to 1 if using libressl.])
-      ssl_msg="libressl"
+        [Define to 1 if using LibreSSL.])
+      ssl_msg="LibreSSL"
     ],[
       AC_MSG_RESULT([no])
     ])
@@ -351,6 +351,7 @@ if test "x$OPT_OPENSSL" != xno; then
        fi
     fi
     check_for_ca_bundle=1
+    LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE openssl"
   fi
 
   test -z "$ssl_msg" || ssl_backends="${ssl_backends:+$ssl_backends, }$ssl_msg"
@@ -428,11 +429,14 @@ dnl ---
 dnl We may use OpenSSL QUIC.
 dnl ---
 if test "$OPENSSL_ENABLED" = "1"; then
-  AC_MSG_CHECKING([for QUIC support in OpenSSL])
+  AC_MSG_CHECKING([for QUIC support and OpenSSL >= 3.3])
   AC_LINK_IFELSE([
     AC_LANG_PROGRAM([[
 #include <openssl/ssl.h>
     ]],[[
+      #if (OPENSSL_VERSION_NUMBER < 0x30300000L)
+      #error need at least version 3.3.0
+      #endif
       OSSL_QUIC_client_method();
     ]])
   ],[
diff --git a/m4/curl-reentrant.m4 b/m4/curl-reentrant.m4
index c1f333982..256f53c7d 100644
--- a/m4/curl-reentrant.m4
+++ b/m4/curl-reentrant.m4
@@ -58,7 +58,7 @@ AC_DEFUN([CURL_CHECK_NEED_REENTRANT_ERRNO], [
 #ifdef errno
         int dummy=1;
 #else
-        force compilation error
+        #error force compilation error
 #endif
       ]])
     ],[
@@ -72,7 +72,7 @@ AC_DEFUN([CURL_CHECK_NEED_REENTRANT_ERRNO], [
 #ifdef errno
           int dummy=1;
 #else
-          force compilation error
+          #error force compilation error
 #endif
         ]])
       ],[
@@ -413,7 +413,7 @@ AC_DEFUN([CURL_CONFIGURE_REENTRANT], [
 #ifdef _REENTRANT
       int dummy=1;
 #else
-      force compilation error
+      #error force compilation error
 #endif
     ]])
   ],[
@@ -473,7 +473,7 @@ AC_DEFUN([CURL_CONFIGURE_THREAD_SAFE], [
 #ifdef _THREAD_SAFE
       int dummy=1;
 #else
-      force compilation error
+      #error force compilation error
 #endif
     ]])
   ],[
diff --git a/m4/curl-rustls.m4 b/m4/curl-rustls.m4
index ef8d7dd4b..c9f9caedd 100644
--- a/m4/curl-rustls.m4
+++ b/m4/curl-rustls.m4
@@ -172,6 +172,7 @@ if test "x$OPT_RUSTLS" != xno; then
         AC_MSG_NOTICE([Added $LIB_RUSTLS to CURL_LIBRARY_PATH])
       fi
     fi
+    LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE rustls"
   fi
 
   test -z "$ssl_msg" || ssl_backends="${ssl_backends:+$ssl_backends, }$ssl_msg"
diff --git a/m4/curl-sysconfig.m4 b/m4/curl-sysconfig.m4
index 9b287bc76..f92fc1899 100644
--- a/m4/curl-sysconfig.m4
+++ b/m4/curl-sysconfig.m4
@@ -28,6 +28,7 @@ case $host_os in
   darwin*)
     AC_COMPILE_IFELSE([
       AC_LANG_PROGRAM([[
+#include <sys/types.h>
 #include <TargetConditionals.h>
       ]],[[
 #if TARGET_OS_MAC && !(defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE)
diff --git a/m4/curl-wolfssl.m4 b/m4/curl-wolfssl.m4
index 1da47a91e..cb3dc2902 100644
--- a/m4/curl-wolfssl.m4
+++ b/m4/curl-wolfssl.m4
@@ -91,7 +91,7 @@ if test "x$OPT_WOLFSSL" != xno; then
       AC_MSG_CHECKING([for wolfSSL_Init in -lwolfssl])
       AC_LINK_IFELSE([
         AC_LANG_PROGRAM([[
-/* These aren't needed for detection and confuse WolfSSL.
+/* These are not needed for detection and confuse wolfSSL.
    They are set up properly later if it is detected.  */
 #undef SIZEOF_LONG
 #undef SIZEOF_LONG_LONG
@@ -106,7 +106,7 @@ if test "x$OPT_WOLFSSL" != xno; then
          AC_SUBST(USE_WOLFSSL, [1])
          WOLFSSL_ENABLED=1
          USE_WOLFSSL="yes"
-         ssl_msg="WolfSSL"
+         ssl_msg="wolfSSL"
          QUIC_ENABLED=yes
          test wolfssl != "$DEFAULT_SSL_BACKEND" || VALID_DEFAULT_SSL_BACKEND=yes
        ],
@@ -128,7 +128,7 @@ if test "x$OPT_WOLFSSL" != xno; then
 
       LIBS="$addlib -lm $LIBS"
 
-      dnl WolfSSL needs configure --enable-opensslextra to have *get_peer*
+      dnl wolfSSL needs configure --enable-opensslextra to have *get_peer*
       dnl DES* is needed for NTLM support and lives in the OpenSSL compatibility
       dnl layer
       AC_CHECK_FUNCS(wolfSSL_get_peer_certificate \
@@ -164,6 +164,7 @@ if test "x$OPT_WOLFSSL" != xno; then
           AC_MSG_NOTICE([Added $wolfssllibpath to CURL_LIBRARY_PATH])
         fi
       fi
+      LIBCURL_PC_REQUIRES_PRIVATE="$LIBCURL_PC_REQUIRES_PRIVATE wolfssl"
     else
         AC_MSG_ERROR([--with-wolfssl but wolfSSL was not found or doesn't work])
     fi
diff --git a/m4/xc-am-iface.m4 b/m4/xc-am-iface.m4
index c035f58c5..e85e6d424 100644
--- a/m4/xc-am-iface.m4
+++ b/m4/xc-am-iface.m4
@@ -2,7 +2,7 @@
 #
 # xc-am-iface.m4
 #
-# Copyright (C) Daniel Stenberg <daniel@haxx.se>
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>
 #
 # Permission to use, copy, modify, and distribute this software for any
 # purpose with or without fee is hereby granted, provided that the above
diff --git a/m4/xc-cc-check.m4 b/m4/xc-cc-check.m4
index a6cfb07eb..5cf2af7be 100644
--- a/m4/xc-cc-check.m4
+++ b/m4/xc-cc-check.m4
@@ -2,7 +2,7 @@
 #
 # xc-cc-check.m4
 #
-# Copyright (C), Daniel Stenberg <daniel@haxx.se>
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>
 #
 # Permission to use, copy, modify, and distribute this software for any
 # purpose with or without fee is hereby granted, provided that the above
diff --git a/m4/xc-lt-iface.m4 b/m4/xc-lt-iface.m4
index d5e437ffd..f3ac0dede 100644
--- a/m4/xc-lt-iface.m4
+++ b/m4/xc-lt-iface.m4
@@ -2,7 +2,7 @@
 #
 # xc-lt-iface.m4
 #
-# Copyright (C), Daniel Stenberg <daniel@haxx.se>
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>
 #
 # Permission to use, copy, modify, and distribute this software for any
 # purpose with or without fee is hereby granted, provided that the above
diff --git a/m4/xc-translit.m4 b/m4/xc-translit.m4
index 6d6677197..0d898f511 100644
--- a/m4/xc-translit.m4
+++ b/m4/xc-translit.m4
@@ -2,7 +2,7 @@
 #
 # xc-translit.m4
 #
-# Copyright (C), Daniel Stenberg <daniel@haxx.se>
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>
 #
 # Permission to use, copy, modify, and distribute this software for any
 # purpose with or without fee is hereby granted, provided that the above
diff --git a/m4/xc-val-flgs.m4 b/m4/xc-val-flgs.m4
index c8f779651..af7a3d2d8 100644
--- a/m4/xc-val-flgs.m4
+++ b/m4/xc-val-flgs.m4
@@ -2,7 +2,7 @@
 #
 # xc-val-flgs.m4
 #
-# Copyright (C), Daniel Stenberg <daniel@haxx.se>
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>
 #
 # Permission to use, copy, modify, and distribute this software for any
 # purpose with or without fee is hereby granted, provided that the above
diff --git a/m4/zz40-xc-ovr.m4 b/m4/zz40-xc-ovr.m4
index fa457876f..6faa94e43 100644
--- a/m4/zz40-xc-ovr.m4
+++ b/m4/zz40-xc-ovr.m4
@@ -2,7 +2,7 @@
 #
 # zz40-xc-ovr.m4
 #
-# Copyright (C) Daniel Stenberg <daniel@haxx.se>
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>
 #
 # Permission to use, copy, modify, and distribute this software for any
 # purpose with or without fee is hereby granted, provided that the above
diff --git a/m4/zz50-xc-ovr.m4 b/m4/zz50-xc-ovr.m4
index 18c1f0aba..735df2f59 100644
--- a/m4/zz50-xc-ovr.m4
+++ b/m4/zz50-xc-ovr.m4
@@ -2,7 +2,7 @@
 #
 # zz50-xc-ovr.m4
 #
-# Copyright (C), Daniel Stenberg <daniel@haxx.se>
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>
 #
 # Permission to use, copy, modify, and distribute this software for any
 # purpose with or without fee is hereby granted, provided that the above
diff --git a/m4/zz60-xc-ovr.m4 b/m4/zz60-xc-ovr.m4
index 531668672..d1d3a2fd5 100644
--- a/m4/zz60-xc-ovr.m4
+++ b/m4/zz60-xc-ovr.m4
@@ -2,7 +2,7 @@
 #
 # zz60-xc-ovr.m4
 #
-# Copyright (C), Daniel Stenberg <daniel@haxx.se>
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>
 #
 # Permission to use, copy, modify, and distribute this software for any
 # purpose with or without fee is hereby granted, provided that the above
diff --git a/packages/Makefile.am b/packages/Makefile.am
index b7bf1e591..96f52bdb4 100644
--- a/packages/Makefile.am
+++ b/packages/Makefile.am
@@ -33,6 +33,7 @@ EXTRA_DIST = README.md \
   OS400/curl.inc.in \
   OS400/initscript.sh \
   OS400/config400.default \
+  OS400/make-docs.sh \
   OS400/make-include.sh \
   OS400/make-lib.sh \
   OS400/make-src.sh \
diff --git a/packages/OS400/.gitattributes b/packages/OS400/.gitattributes
deleted file mode 100644
index e9b8201b5..000000000
--- a/packages/OS400/.gitattributes
+++ /dev/null
@@ -1,6 +0,0 @@
-# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
-#
-# SPDX-License-Identifier: curl
-
-# OS400 .cmd files are not windows scripts.
-*.cmd text eol=auto
diff --git a/packages/OS400/README.OS400 b/packages/OS400/README.OS400
index 38b2c7f06..1bc4132f6 100644
--- a/packages/OS400/README.OS400
+++ b/packages/OS400/README.OS400
@@ -226,8 +226,7 @@ in fact, very few common utilities are available. As a consequence, the
 config-os400.h has been coded manually and the compilation scripts are
 a set of shell scripts stored in subdirectory packages/OS400.
 
-  The "curl" command and the test environment are currently not supported on
-OS/400.
+  The test environment is currently not supported on OS/400.
 
 
 Protocols currently implemented on OS/400:
diff --git a/packages/OS400/config400.default b/packages/OS400/config400.default
index 91a82771f..4e7ddbac5 100644
--- a/packages/OS400/config400.default
+++ b/packages/OS400/config400.default
@@ -39,6 +39,7 @@ setenv OUTPUT           '*NONE'                 # Compilation output option.
 setenv TGTRLS           '*CURRENT'              # Target OS release.
 setenv IFSDIR           '/curl'                 # Installation IFS directory.
 setenv QADRTDIR         '/QIBM/ProdData/qadrt'  # QADRT IFS directory.
+setenv PASEPERL         '/QOpenSys/pkgs/bin/perl'       # PASE Perl interpreter.
 
 #       Define ZLIB availability and locations.
 
diff --git a/packages/OS400/curl.inc.in b/packages/OS400/curl.inc.in
index 915ece6e6..81ba82c35 100644
--- a/packages/OS400/curl.inc.in
+++ b/packages/OS400/curl.inc.in
@@ -443,8 +443,12 @@
      d                 c                   X'00000400'
      d CURLU_ALLOW_SPACE...
      d                 c                   X'00000800'
-     d CURLU_PUNYCODE...
-     d                 c                   X'00001000'
+     d CURLU_PUNYCODE  c                   X'00001000'
+     d CURLU_PUNY2IDN  c                   X'00002000'
+     d CURLU_GET_EMPTY...
+     d                 c                   X'00004000'
+     d CURLU_NO_GUESS_SCHEME...
+     d                 c                   X'00008000'
       *
      d CURLOT_FLAG_ALIAS...
      d                 c                   X'00000001'
@@ -1666,6 +1670,8 @@
      d  CURLOPT_SERVER_RESPONSE_TIMEOUT_MS...
      d                 c                   00324
      d  CURLOPT_ECH    c                   10325
+     d  CURLOPT_TCP_KEEPCNT...
+     d                 c                   00326
       *
       /if not defined(CURL_NO_OLDIES)
      d  CURLOPT_FILE   c                   10001
diff --git a/packages/OS400/initscript.sh b/packages/OS400/initscript.sh
index cdb8fab3c..2f6d78c24 100755
--- a/packages/OS400/initscript.sh
+++ b/packages/OS400/initscript.sh
@@ -69,6 +69,9 @@ if [ -f "${SCRIPTDIR}/config400.override" ]
 then    . "${SCRIPTDIR}/config400.override"
 fi
 
+#       Check if perl available.
+{ [ -n "${PASEPERL}" ] && [ -x "${PASEPERL}" ]; } || PASEPERL=
+
 #       Need to get the version definitions.
 
 LIBCURL_VERSION=$(grep '^#define  *LIBCURL_VERSION '                    \
diff --git a/packages/OS400/make-docs.sh b/packages/OS400/make-docs.sh
new file mode 100755
index 000000000..b79b19e92
--- /dev/null
+++ b/packages/OS400/make-docs.sh
@@ -0,0 +1,65 @@
+#!/bin/sh
+#***************************************************************************
+#                                  _   _ ____  _
+#  Project                     ___| | | |  _ \| |
+#                             / __| | | | |_) | |
+#                            | (__| |_| |  _ <| |___
+#                             \___|\___/|_| \_\_____|
+#
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+#
+# This software is licensed as described in the file COPYING, which
+# you should have received as part of this distribution. The terms
+# are also available at https://curl.se/docs/copyright.html.
+#
+# You may opt to use, copy, modify, merge, publish, distribute and/or sell
+# copies of the Software, and permit persons to whom the Software is
+# furnished to do so, under the terms of the COPYING file.
+#
+# This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+# KIND, either express or implied.
+#
+# SPDX-License-Identifier: curl
+#
+###########################################################################
+#
+#       Documentation build script for the OS/400.
+#
+
+
+SCRIPTDIR=$(dirname "${0}")
+. "${SCRIPTDIR}/initscript.sh"
+
+[ -n "${PASEPERL}" ] || exit 0  # Perl needed for doc build.
+cd "${TOPDIR}/docs" || exit 1
+[ -d "${IFSDIR}/docs" ] || mkdir "${IFSDIR}/docs"
+
+
+#       Command line options.
+
+(
+        cd cmdline-opts || exit 1
+        MANPAGE=curl.1
+        TEXTPAGE=curl.txt
+        get_make_vars Makefile.inc
+        rm -f "${IFSDIR}/docs/${MANPAGE}" "${IFSDIR}/docs/${TEXTPAGE}"
+
+        #       Prepare online manual.
+        # shellcheck disable=SC2086
+        ${PASEPERL} "${TOPDIR}/scripts/managen" -c 75                   \
+                listhelp ${DPAGES} > "${TOPDIR}/src/tool_listhelp.c"
+
+        #       Generate text manual and copy it to DB2.
+        # shellcheck disable=SC2086
+        ${PASEPERL} "${TOPDIR}/scripts/managen" -I "${TOPDIR}/include"  \
+               -c 75 ascii ${DPAGES} > "${IFSDIR}/docs/${TEXTPAGE}"
+        MEMBER="${LIBIFSNAME}/DOCS.FILE/MANUAL.MBR"
+        CMD="CPY OBJ('${IFSDIR}/docs/${TEXTPAGE}') TOOBJ('${MEMBER}')"
+        CMD="${CMD} TOCCSID(${TGTCCSID}) DTAFMT(*TEXT) REPLACE(*YES)"
+        CLcommand "${CMD}"
+
+#       Man page is useless as OS/400 has no man command.
+#       # shellcheck disable=SC2086
+#       ${PASEPERL} "${TOPDIR}/scripts/managen" -I "${TOPDIR}/include"  \
+#               mainpage ${DPAGES} > "${IFSDIR}/docs/${MANPAGE}"
+)
diff --git a/packages/OS400/make-src.sh b/packages/OS400/make-src.sh
index 6775f98bd..21fd0015b 100755
--- a/packages/OS400/make-src.sh
+++ b/packages/OS400/make-src.sh
@@ -30,6 +30,15 @@ SCRIPTDIR=$(dirname "${0}")
 cd "${TOPDIR}/src" || exit 1
 
 
+#       Check if built-in manual can be generated.
+
+USE_MANUAL=
+if [ -f "${IFSDIR}/docs/curl.txt" ] && [ -n "${PASEPERL}" ]
+then    "${PASEPERL}" ./mkhelp.pl < "${IFSDIR}/docs/curl.txt" > tool_hugehelp.c
+        USE_MANUAL="'USE_MANUAL'"
+fi
+
+
 #       Get source lists.
 #       CURL_CFILES are in the current directory.
 #       CURLX_CFILES are in the lib directory and need to be recompiled because
@@ -49,12 +58,12 @@ INCLUDES="'${TOPDIR}/lib'"
 for SRC in ${CURLX_CFILES}
 do      MODULE=$(db2_name "${SRC}")
         MODULE=$(db2_name "X${MODULE}")
-        make_module "${MODULE}" "${SRC}"
+        make_module "${MODULE}" "${SRC}" "${USE_MANUAL}"
 done
 
 for SRC in ${CURL_CFILES}
 do      MODULE=$(db2_name "${SRC}")
-        make_module "${MODULE}" "${SRC}"
+        make_module "${MODULE}" "${SRC}" "${USE_MANUAL}"
 done
 
 
diff --git a/packages/OS400/makefile.sh b/packages/OS400/makefile.sh
index e58b835e1..fb1f14671 100755
--- a/packages/OS400/makefile.sh
+++ b/packages/OS400/makefile.sh
@@ -33,6 +33,18 @@ SCRIPTDIR=$(dirname "${0}")
 cd "${TOPDIR}" || exit 1
 
 
+#       Make sure all files are UTF8-encoded.
+
+# shellcheck disable=SC2038
+find "${TOPDIR}" -type f -print | xargs ls -S | while read -r CCSID FILE
+do      if [ "${CCSID}" != 1208 ]
+        then    CMD="CPY OBJ('${FILE}') TOOBJ('${FILE}') FROMCCSID(*OBJ)"
+                CMD="${CMD} TOCCSID(1208) DTAFMT(*TEXT) REPLACE(*YES)"
+                (CLcommand "${CMD}")
+        fi
+done
+
+
 #       Create the OS/400 library if it does not exist.
 
 if action_needed "${LIBIFSNAME}"
@@ -117,7 +129,7 @@ fi
 
 #       Build in each directory.
 
-# for SUBDIR in include lib src tests
-for SUBDIR in include lib src
+# for SUBDIR in include lib docs src tests
+for SUBDIR in include lib docs src
 do      "${SCRIPTDIR}/make-${SUBDIR}.sh"
 done
diff --git a/packages/vms/compare_curl_source.com b/packages/vms/compare_curl_source.com
index 3f7542de0..13ff4667f 100644
--- a/packages/vms/compare_curl_source.com
+++ b/packages/vms/compare_curl_source.com
@@ -17,9 +17,9 @@ $!
 $! First the files in the original source directory which is assumed to be
 $! under source code control are compared with the copy directory.
 $!
-$! Then the files are are only in the copy directory are listed.
+$! Only files present in the copy directory are listed.
 $!
-$! The result will five diagnostics about of files:
+$! Diagnostics are displayed about the files:
 $!    1. Files that are not generation 1.
 $!    2. Files missing in the copy directory.
 $!    3. Files in the copy directory not in the source directory.
diff --git a/packages/vms/config_h.com b/packages/vms/config_h.com
index 44cb06707..b54a1a0f9 100644
--- a/packages/vms/config_h.com
+++ b/packages/vms/config_h.com
@@ -113,19 +113,19 @@ $else
 $   cfile = f$search("sys$disk:[]config.h.in")
 $   if cfile .eqs. ""
 $   then
-$	cfile = f$search("sys$disk:[]config.h_in")
-$	if cfile .eqs. ""
-$	then
-$	    cfile = f$search("sys$disk:[]configh.in")
-$	    if cfile .eqs. ""
-$	    then
-$		cfile = f$search("sys$disk:[]config__2eh.in")
-$		if cfile .eqs. ""
-$		then
-$		    cfile = f$search("sys$disk:[]config.h__2ein")
-$		endif
-$	    endif
-$	endif
+$       cfile = f$search("sys$disk:[]config.h_in")
+$       if cfile .eqs. ""
+$       then
+$           cfile = f$search("sys$disk:[]configh.in")
+$           if cfile .eqs. ""
+$           then
+$               cfile = f$search("sys$disk:[]config__2eh.in")
+$               if cfile .eqs. ""
+$               then
+$                   cfile = f$search("sys$disk:[]config.h__2ein")
+$               endif
+$           endif
+$       endif
 $   endif
 $endif
 $if f$trnlnm("PRJ_INCLUDE") .nes. ""
@@ -133,19 +133,19 @@ $then
 $   cfile = f$search("PRJ_INCLUDE:config.h.in")
 $   if cfile .eqs. ""
 $   then
-$	cfile = f$search("PRJ_INCLUDE:config.h_in")
-$	if cfile .eqs. ""
-$	then
-$	    cfile = f$search("PRJ_INCLUDE:config__2eh.in")
-$	    if cfile .eqs. ""
-$	    then
-$		cfile = f$search("PRJ_INCLUDE:config__2eh.in")
-$		if cfile .eqs. ""
-$		then
-$		    cfile = f$search("PRJ_INCLUDE:config.h__2ein")
-$		endif
-$	    endif
-$	endif
+$       cfile = f$search("PRJ_INCLUDE:config.h_in")
+$       if cfile .eqs. ""
+$       then
+$           cfile = f$search("PRJ_INCLUDE:config__2eh.in")
+$           if cfile .eqs. ""
+$           then
+$               cfile = f$search("PRJ_INCLUDE:config__2eh.in")
+$               if cfile .eqs. ""
+$               then
+$                   cfile = f$search("PRJ_INCLUDE:config.h__2ein")
+$               endif
+$           endif
+$       endif
 $    endif
 $endif
 $if cfile .eqs. ""
@@ -156,23 +156,23 @@ $   line_out = line_out + "config__2eh.in, config.h__2ein"
 $   write/symbol sys$output line_out
 $   if f$trnlnm("PRJ_INCLUDE") .nes. ""
 $   then
-$	write sys$output "Also looked in PRJ_INCLUDE: for these files."
+$       write sys$output "Also looked in PRJ_INCLUDE: for these files."
 $   endif
 $!
 $   write tf ""
 $   write tf -
-	"   /* Could not find sys$disk:config.h.in                           */"
+        "   /* Could not find sys$disk:config.h.in                           */"
 $   write tf -
-	"  /*  Looked also for config.h_in, configh.in, config__2eh.in,     */"
+        "  /*  Looked also for config.h_in, configh.in, config__2eh.in,     */"
 $   write tf -
-	" /*   config.h__2ein						   */"
+        " /*   config.h__2ein                                              */"
 $   if f$trnlnm("PRJ_INCLUDE") .nes. ""
 $   then
-$	write tf -
-	" /* Also looked in PRJ_INCLUDE: for these files.		  */"
+$       write tf -
+        " /* Also looked in PRJ_INCLUDE: for these files.                 */"
 $   endif
 $   write tf -
-	"/*--------------------------------------------------------------*/
+        "/*--------------------------------------------------------------*/
 $   write tf ""
 $   goto write_tail
 $endif
@@ -244,8 +244,8 @@ $!  Blank line handling
 $!---------------------
 $   if xline .eqs. ""
 $   then
-$	write tf ""
-$	goto cfgh_in_loop1
+$       write tf ""
+$       goto cfgh_in_loop1
 $   endif
 $   xlen = f$length(xline)
 $   key = f$extract(0,2,xline)
@@ -254,11 +254,11 @@ $!  deal with comments by copying exactly
 $!-----------------------------------------
 $   if (do_comment .eq. 1) .or. (key .eqs. "/*")
 $   then
-$	do_comment = 1
-$	write tf line_in
-$	key = f$extract(xlen - 2, 2, xline)
-$	if key .eqs. "*/" then do_comment = 0
-$	goto cfgh_in_loop1
+$       do_comment = 1
+$       write tf line_in
+$       key = f$extract(xlen - 2, 2, xline)
+$       if key .eqs. "*/" then do_comment = 0
+$       goto cfgh_in_loop1
 $   endif
 $!
 $!  Some quick parsing
@@ -281,33 +281,33 @@ $!  Comment out this section of the ifblock
 $!-----------------------------------------
 $   if if_block .ge. 3
 $   then
-$	write tf "/* ", xline, " */"
-$	if keyif .eqs. "#en" then if_block = 0
-$	goto cfgh_in_loop1
+$       write tf "/* ", xline, " */"
+$       if keyif .eqs. "#en" then if_block = 0
+$       goto cfgh_in_loop1
 $   endif
 $!
 $!  Handle the end of an ifblock
 $!-------------------------------
 $   if keyif .eqs. "#en"
 $   then
-$	write tf xline
-$	if_block = 0
-$	goto cfgh_in_loop1
+$       write tf xline
+$       if_block = 0
+$       goto cfgh_in_loop1
 $   endif
 $!
 $   if key1 .eqs. "#ifndef"
 $   then
-$!	Manual check for _ALL_SOURCE on AIX error
+$!      Manual check for _ALL_SOURCE on AIX error
 $!-----------------------------------------------
-$	if key2 .eqs. "_ALL_SOURCE"
-$	then
-$	   write tf "/* ", xline, " */"
+$       if key2 .eqs. "_ALL_SOURCE"
+$       then
+$          write tf "/* ", xline, " */"
 $!
-$!	   Ignore the rest of the block
+$!         Ignore the rest of the block
 $!--------------------------------------
-$	   if_block = 3
-$	   goto cfgh_in_loop1
-$	endif
+$          if_block = 3
+$          goto cfgh_in_loop1
+$       endif
 $   endif
 $!
 $!
@@ -315,9 +315,9 @@ $!  Default action for an #if/#else/#endif
 $!------------------------------------------
 $   if keyif .eqs. "#if" .or. keyif .eqs. "#el"
 $   then
-$	if_block = 1
-$	write tf xline
-$	goto cfgh_in_loop1
+$       if_block = 1
+$       write tf xline
+$       goto cfgh_in_loop1
 $   endif
 $!
 $!
@@ -325,1514 +325,1514 @@ $!  Process "normal?" stuff
 $!---------------------------
 $   if key1 .eqs. "#undef"
 $   then
-$	key2c = f$element(2, "_", key2)
-$	if (key2c .eqs. "_") .or. (key2c .eqs. "H") then key2c = ""
-$	key2d = f$element(3, "_", key2)
-$	if (key2d .eqs. "_") .or. (key2d .eqs. "H") then key2d = ""
-$	key2e = f$element(4, "_", key2)
-$	if (key2e .eqs. "_") .or. (key2e .eqs. "H") then key2e = ""
-$	if key2d .eqs. "T"
-$	then
-$	    if key2e .eqs. "TYPE"
-$	    then
-$		key2_h = "_T"
-$		key2d = ""
-$	    endif
-$	endif
-$!
-$	double_under = 0
-$!
-$!	Process FCNTL directives
+$       key2c = f$element(2, "_", key2)
+$       if (key2c .eqs. "_") .or. (key2c .eqs. "H") then key2c = ""
+$       key2d = f$element(3, "_", key2)
+$       if (key2d .eqs. "_") .or. (key2d .eqs. "H") then key2d = ""
+$       key2e = f$element(4, "_", key2)
+$       if (key2e .eqs. "_") .or. (key2e .eqs. "H") then key2e = ""
+$       if key2d .eqs. "T"
+$       then
+$           if key2e .eqs. "TYPE"
+$           then
+$               key2_h = "_T"
+$               key2d = ""
+$           endif
+$       endif
+$!
+$       double_under = 0
+$!
+$!      Process FCNTL directives
 $!-------------------------------------
-$	if (key2b .eqs. "FCNTL") .and. (key2c .eqs. "O") .and. -
-	   (key2d .eqs. "NONBLOCK")
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$!	Process GETADDRINFO directives
+$       if (key2b .eqs. "FCNTL") .and. (key2c .eqs. "O") .and. -
+           (key2d .eqs. "NONBLOCK")
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$!      Process GETADDRINFO directives
 $!-------------------------------------
-$	if key2 .eqs. "GETADDRINFO_THREADSAFE"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$!	Process IOCTL directives
+$       if key2 .eqs. "GETADDRINFO_THREADSAFE"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$!      Process IOCTL directives
 $!-------------------------------------
-$	if (key2b .eqs. "IOCTL") .and. (key2c .nes. "")
-$	then
-$	    if (key2c .eqs. "FIONBIO") .or. (key2c .eqs. "SIOCGIFADDR")
-$	    then
-$		write tf "#ifndef ''key2'"
-$		write tf "#define ''key2' 1"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	endif
-$!
-$!
-$!	Manual check for LL on
+$       if (key2b .eqs. "IOCTL") .and. (key2c .nes. "")
+$       then
+$           if (key2c .eqs. "FIONBIO") .or. (key2c .eqs. "SIOCGIFADDR")
+$           then
+$               write tf "#ifndef ''key2'"
+$               write tf "#define ''key2' 1"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$       endif
+$!
+$!
+$!      Manual check for LL on
 $!-----------------------------------------------
-$	if key2 .eqs. "LL"
-$	then
-$	   write tf "#ifndef __VAX
-$	   write tf "#define HAVE_''key2' 1"
-$	   write tf "#endif"
-$	   goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "bool_t"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' short"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "bits16_t"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' short"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "u_bits16_t"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' unsigned short"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "bits32_t"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' int"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "u_bits32_t"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' unsigned int"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "intmax_t"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#ifdef __VAX"
-$	    write tf "#define ''key2' long"
-$	    write tf "#else"
-$	    write tf "#define ''key2' long long"
-$	    write tf "#endif"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "uintmax_t"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#ifdef __VAX"
-$	    write tf "#define ''key2' unsigned long"
-$	    write tf "#else"
-$	    write tf "#define ''key2' unsigned long long"
-$	    write tf "#endif"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "socklen_t"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' int"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "GETGROUPS_T"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' gid_t"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_DECL_SYS_SIGLIST"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 0"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_SYS_ERRLIST"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_STRUCT_DIRENT_D_INO"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_STRUCT_TIMEVAL"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$!	! The header files have this information, however
+$       if key2 .eqs. "LL"
+$       then
+$          write tf "#ifndef __VAX
+$          write tf "#define HAVE_''key2' 1"
+$          write tf "#endif"
+$          goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "bool_t"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' short"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "bits16_t"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' short"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "u_bits16_t"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' unsigned short"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "bits32_t"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' int"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "u_bits32_t"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' unsigned int"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "intmax_t"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#ifdef __VAX"
+$           write tf "#define ''key2' long"
+$           write tf "#else"
+$           write tf "#define ''key2' long long"
+$           write tf "#endif"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "uintmax_t"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#ifdef __VAX"
+$           write tf "#define ''key2' unsigned long"
+$           write tf "#else"
+$           write tf "#define ''key2' unsigned long long"
+$           write tf "#endif"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "socklen_t"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' int"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "GETGROUPS_T"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' gid_t"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_DECL_SYS_SIGLIST"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 0"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_SYS_ERRLIST"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_STRUCT_DIRENT_D_INO"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_STRUCT_TIMEVAL"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$!      ! The header files have this information, however
 $!      ! The ioctl() call only works on sockets.
-$!	if key2 .eqs. "FIONREAD_IN_SYS_IOCTL"
-$!	then
-$!	    write tf "#ifndef ''key2'"
-$!	    write tf "#define ''key2' 1"
-$!	    write tf "#endif"
-$!	    goto cfgh_in_loop1
-$!	endif
-$!
-$!	! The header files have this information, however
+$!      if key2 .eqs. "FIONREAD_IN_SYS_IOCTL"
+$!      then
+$!          write tf "#ifndef ''key2'"
+$!          write tf "#define ''key2' 1"
+$!          write tf "#endif"
+$!          goto cfgh_in_loop1
+$!      endif
+$!
+$!      ! The header files have this information, however
 $!      ! The ioctl() call only works on sockets.
-$!	if key2 .eqs. "GWINSZ_IN_SYS_IOCTL"
-$!	then
-$!	    write tf "#ifndef ''key2'"
-$!	    write tf "#define ''key2' 1"
-$!	    write tf "#endif"
-$!	    goto cfgh_in_loop1
-$!	endif
-$!
-$!	! The header files have this information, however
+$!      if key2 .eqs. "GWINSZ_IN_SYS_IOCTL"
+$!      then
+$!          write tf "#ifndef ''key2'"
+$!          write tf "#define ''key2' 1"
+$!          write tf "#endif"
+$!          goto cfgh_in_loop1
+$!      endif
+$!
+$!      ! The header files have this information, however
 $!      ! The ioctl() call only works on sockets.
-$!	if key2 .eqs. "STRUCT_WINSIZE_IN_SYS_IOCTL"
-$!	then
-$!	    write tf "#ifndef ''key2'"
-$!	    write tf "#define ''key2' 0"
-$!	    write tf "#endif"
-$!	    goto cfgh_in_loop1
-$!	endif
-$!
-$	if key2 .eqs. "HAVE_STRUCT_TM_TM_ZONE"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_TM_ZONE"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_TIMEVAL"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "WEXITSTATUS_OFFSET"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 2"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_GETPW_DECLS"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_DECL_CONFSTR"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_DECL_PRINTF"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_DECL_SBRK"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_DECL_STRSIGNAL"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 0"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2a .eqs. "HAVE_DECL_STRTOLD"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 0"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_DECL_STRTOIMAX"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 0"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_DECL_STRTOL"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_DECL_STRTOLL"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_DECL_STRTOUL"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_DECL_STRTOULL"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_DECL_STRTOUMAX"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 0"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "GETPGRP_VOID"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "NAMED_PIPES_MISSING"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "OPENDIR_NOT_ROBUST"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "PGRP_PIPE"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "CAN_REDEFINE_GETENV"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_PRINTF_A_FORMAT"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "CTYPE_NON_ASCII"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_LANGINFO_CODESET"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 0"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
+$!      if key2 .eqs. "STRUCT_WINSIZE_IN_SYS_IOCTL"
+$!      then
+$!          write tf "#ifndef ''key2'"
+$!          write tf "#define ''key2' 0"
+$!          write tf "#endif"
+$!          goto cfgh_in_loop1
+$!      endif
+$!
+$       if key2 .eqs. "HAVE_STRUCT_TM_TM_ZONE"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_TM_ZONE"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_TIMEVAL"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "WEXITSTATUS_OFFSET"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 2"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_GETPW_DECLS"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_DECL_CONFSTR"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_DECL_PRINTF"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_DECL_SBRK"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_DECL_STRSIGNAL"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 0"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2a .eqs. "HAVE_DECL_STRTOLD"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 0"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_DECL_STRTOIMAX"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 0"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_DECL_STRTOL"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_DECL_STRTOLL"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_DECL_STRTOUL"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_DECL_STRTOULL"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_DECL_STRTOUMAX"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 0"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "GETPGRP_VOID"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "NAMED_PIPES_MISSING"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "OPENDIR_NOT_ROBUST"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "PGRP_PIPE"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "CAN_REDEFINE_GETENV"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_PRINTF_A_FORMAT"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "CTYPE_NON_ASCII"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_LANGINFO_CODESET"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 0"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
 $!
 $!      This wants execve() to do this automagically to pass.
-$!	if key2 .eqs. "HAVE_HASH_BANG_EXEC"
-$!	then
-$!	    write tf "#ifndef ''key2'"
-$!	    write tf "#define ''key2' 1"
-$!	    write tf "#endif"
-$!	    goto cfgh_in_loop1
-$!	endif
-$!
-$	if key2 .eqs. "ICONV_CONST"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2'"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "VOID_SIGHANDLER"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_POSIX_SIGNALS"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "UNUSABLE_RT_SIGNALS"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2a .eqs. "HAVE_DECL_FPURGE"
-$	then
-$	    write tf "#ifndef ''key2a'"
-$	    write tf "#define ''key2a' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_DECL_SETREGID"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "HAVE_POSIX_SIGSETJMP"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2b .eqs. "RAND" .and. key2c .nes. "" .and. key2d .eqs. ""
-$	then
-$	    if (key2c .eqs. "EGD") .or. -
-	       (key2c .eqs. "STATUS") .or. -
-	       (key2c .eqs. "SCREEN")
-$	    then
-$		if f$search("''ssl_header_dir'rand.h") .nes. ""
-$		then
-$		    write tf "#ifndef ''key2'"
-$		    write tf "#define ''key2' 1"
-$		    write tf "#endif"
-$		else
-$		    write tf "/* #undef ''key2' */"
-$		endif
-$	    endif
-$	endif
-$!
-$	if key2 .eqs. "STRCOLL_BROKEN"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$	if key2 .eqs. "DUP_BROKEN"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#define ''key2' 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$!	This is for a test that getcwd(0,0) works.
-$!	It does not on VMS.
+$!      if key2 .eqs. "HAVE_HASH_BANG_EXEC"
+$!      then
+$!          write tf "#ifndef ''key2'"
+$!          write tf "#define ''key2' 1"
+$!          write tf "#endif"
+$!          goto cfgh_in_loop1
+$!      endif
+$!
+$       if key2 .eqs. "ICONV_CONST"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2'"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "VOID_SIGHANDLER"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_POSIX_SIGNALS"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "UNUSABLE_RT_SIGNALS"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2a .eqs. "HAVE_DECL_FPURGE"
+$       then
+$           write tf "#ifndef ''key2a'"
+$           write tf "#define ''key2a' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_DECL_SETREGID"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "HAVE_POSIX_SIGSETJMP"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2b .eqs. "RAND" .and. key2c .nes. "" .and. key2d .eqs. ""
+$       then
+$           if (key2c .eqs. "EGD") .or. -
+               (key2c .eqs. "STATUS") .or. -
+               (key2c .eqs. "SCREEN")
+$           then
+$               if f$search("''ssl_header_dir'rand.h") .nes. ""
+$               then
+$                   write tf "#ifndef ''key2'"
+$                   write tf "#define ''key2' 1"
+$                   write tf "#endif"
+$               else
+$                   write tf "/* #undef ''key2' */"
+$               endif
+$           endif
+$       endif
+$!
+$       if key2 .eqs. "STRCOLL_BROKEN"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$       if key2 .eqs. "DUP_BROKEN"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#define ''key2' 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$!      This is for a test that getcwd(0,0) works.
+$!      It does not on VMS.
 $!--------------------------
-$	if key2 .eqs. "GETCWD_BROKEN"
-$	then
-$	    write sys$output ""
-$	    write sys$output -
+$       if key2 .eqs. "GETCWD_BROKEN"
+$       then
+$           write sys$output ""
+$           write sys$output -
   "%CONFIG_H-I-NONPORT, ''key2' being tested for!"
-$		   write sys$output -
+$                  write sys$output -
  "-CONFIG_H-I-GETCWD, GETCWD(0,0) does not work on VMS."
-$		   write sys$output -
+$                  write sys$output -
  "-CONFIG_H-I-GETCWD2, Work around hack probably required."
-$		   write sys$output -
+$                  write sys$output -
  "-CONFIG_H-I-REVIEW, Manual Code review required!"
-$		    if update_config_vms
-$		    then
-$			open/append tfcv sys$disk:[]config_vms.h
-$			write tfcv ""
-$			write tfcv -
-		"/* Check config.h for use of ''key2' settings */"
-$			write tfcv ""
-$			close tfcv
-$		    endif
+$                   if update_config_vms
+$                   then
+$                       open/append tfcv sys$disk:[]config_vms.h
+$                       write tfcv ""
+$                       write tfcv -
+                "/* Check config.h for use of ''key2' settings */"
+$                       write tfcv ""
+$                       close tfcv
+$                   endif
 $
-$	    goto cfgh_in_loop1
-$	endif
+$           goto cfgh_in_loop1
+$       endif
 $!
-$	if (key2a .eqs. "HAVE") .or. (key2a .eqs. "STAT") .or. -
-	   (key2 .eqs. "USE_IPV6") .or. (key2b .eqs. "LDAP")
-$	then
+$       if (key2a .eqs. "HAVE") .or. (key2a .eqs. "STAT") .or. -
+           (key2 .eqs. "USE_IPV6") .or. (key2b .eqs. "LDAP")
+$       then
 $!
-$!	    Process extra underscores
+$!          Process extra underscores
 $!------------------------------------
-$	    if f$locate("HAVE___", key2) .lt. key2_len
-$	    then
-$		key2b = "__" + key2d
-$		key2d = ""
-$		double_under = 1
-$	    else
-$		if f$locate("HAVE__", key2) .lt. key2_len
-$		then
-$		    key2b = "_" + key2c
-$		    key2c = ""
-$		    double_under = 1
-$		endif
-$	    endif
-$!
-$	    if (key2_h .eqs. "_H") .or. (key2 .eqs. "USE_IPV6") .or. -
-	       (key2b .eqs. "LDAP")
-$	    then
-$!
-$!		Looking for a header file
+$           if f$locate("HAVE___", key2) .lt. key2_len
+$           then
+$               key2b = "__" + key2d
+$               key2d = ""
+$               double_under = 1
+$           else
+$               if f$locate("HAVE__", key2) .lt. key2_len
+$               then
+$                   key2b = "_" + key2c
+$                   key2c = ""
+$                   double_under = 1
+$               endif
+$           endif
+$!
+$           if (key2_h .eqs. "_H") .or. (key2 .eqs. "USE_IPV6") .or. -
+               (key2b .eqs. "LDAP")
+$           then
+$!
+$!              Looking for a header file
 $!---------------------------------------
-$		headf = key2b
-$		if key2c .nes. "" then headf = headf + "_" + key2c
-$		if key2d .nes. "" then headf = headf + "_" + key2d
+$               headf = key2b
+$               if key2c .nes. "" then headf = headf + "_" + key2c
+$               if key2d .nes. "" then headf = headf + "_" + key2d
 $!
-$!		   (key2b .eqs. "READLINE")
+$!                 (key2b .eqs. "READLINE")
 $!
-$!		Some special parsing
+$!              Some special parsing
 $!------------------------------------------
-$		if (key2b .eqs. "SYS") .or. (key2b .eqs. "ARPA") .or. -
-		   (key2b .eqs. "NET") .or. (key2b .eqs. "NETINET")
-$		then
-$		    if key2c .nes. ""
-$		    then
-$			headf = key2c
-$			if key2d .nes. "" then headf = key2c + "_" + key2d
-$		    endif
-$		endif
-$!
-$!		And of course what's life with out some special cases
+$               if (key2b .eqs. "SYS") .or. (key2b .eqs. "ARPA") .or. -
+                   (key2b .eqs. "NET") .or. (key2b .eqs. "NETINET")
+$               then
+$                   if key2c .nes. ""
+$                   then
+$                       headf = key2c
+$                       if key2d .nes. "" then headf = key2c + "_" + key2d
+$                   endif
+$               endif
+$!
+$!              And of course what's life with out some special cases
 $!--------------------------------------------------------------------
-$		if key2 .eqs. "USE_IPV6"
-$		then
-$		    headf = "in6"
-$		endif
-$!
-$		if key2b .eqs. "LDAP"
-$		then
-$		    if (key2 .eqs. "HAVE_LDAP_SSL") .or. -
-		       (key2 .eqs. "HAVE_LDAP_URL_PARSE")
-$		    then
-$			headf = "ldap"
-$		    endif
-$		endif
-$!
-$!
-$		if key2b .eqs. "FILE"
-$		then
-$		   write sys$output ""
-$		   write sys$output -
+$               if key2 .eqs. "USE_IPV6"
+$               then
+$                   headf = "in6"
+$               endif
+$!
+$               if key2b .eqs. "LDAP"
+$               then
+$                   if (key2 .eqs. "HAVE_LDAP_SSL") .or. -
+                       (key2 .eqs. "HAVE_LDAP_URL_PARSE")
+$                   then
+$                       headf = "ldap"
+$                   endif
+$               endif
+$!
+$!
+$               if key2b .eqs. "FILE"
+$               then
+$                  write sys$output ""
+$                  write sys$output -
   "%CONFIG_H-I-NONPORT, ''key2' being asked for!"
-$		   write sys$output -
+$                  write sys$output -
  "-CONFIG_H-I-FILE_OLD, file.h will not be configured as is obsolete!"
-$		   write sys$output -
+$                  write sys$output -
  "-CONFIG_H_I-FCNTL_NEW, "Expecting fcntl.h to be configured instead!"
-$		   write sys$output -
+$                  write sys$output -
  "-CONFIG_H_I-FCNTL_CHK, "Unable to verify at this time!"
-$		   write sys$output -
+$                  write sys$output -
  "-CONFIG_H-I-REVIEW, Manual Code review required!"
 $!
-$		    if update_config_vms
-$		    then
-$			open/append tfcv sys$disk:[]config_vms.h
-$			write tfcv ""
-$			write tfcv -
-		"/* Check config.h for use of fcntl.h instead of file.h */"
-$			write tfcv ""
-$			close tfcv
-$		    endif
-$		endif
-$!
-$!		Now look it up in the DEC C RTL
+$                   if update_config_vms
+$                   then
+$                       open/append tfcv sys$disk:[]config_vms.h
+$                       write tfcv ""
+$                       write tfcv -
+                "/* Check config.h for use of fcntl.h instead of file.h */"
+$                       write tfcv ""
+$                       close tfcv
+$                   endif
+$               endif
+$!
+$!              Now look it up in the DEC C RTL
 $!---------------------------------------------
-$		define/user sys$output nl:
-$		define/user sys$error nl:
-$		search/output=nl: 'dchfile' |'headf'|/exact
-$		if '$severity' .eq. 1
-$		then
-$		    if key64 then write tf "#ifndef __VAX"
-$		    write tf "#ifndef ''key2'"
-$		    write tf "#define ''key2' 1"
+$               define/user sys$output nl:
+$               define/user sys$error nl:
+$               search/output=nl: 'dchfile' |'headf'|/exact
+$               if '$severity' .eq. 1
+$               then
+$                   if key64 then write tf "#ifndef __VAX"
+$                   write tf "#ifndef ''key2'"
+$                   write tf "#define ''key2' 1"
 $if p2 .nes. "" then write sys$output "''dchfile' - #define ''key2' 1"
-$		    write tf "#endif"
-$		    if key64 then write tf "#endif"
+$                   write tf "#endif"
+$                   if key64 then write tf "#endif"
 $set nover
-$		    goto cfgh_in_loop1
-$		endif
+$                   goto cfgh_in_loop1
+$               endif
 $!
 $!
-$!		Now look it up in the DEC C STARLET_C
+$!              Now look it up in the DEC C STARLET_C
 $!---------------------------------------------
-$		define/user sys$output nl:
-$		define/user sys$error nl:
-$		search/output=nl: 'starhfile' |'headf'|/exact
-$		if '$severity' .eq. 1
-$		then
-$		    if key64 then write tf "#ifndef __VAX"
-$		    write tf "#ifndef ''key2'"
-$		    write tf "#define ''key2' 1"
+$               define/user sys$output nl:
+$               define/user sys$error nl:
+$               search/output=nl: 'starhfile' |'headf'|/exact
+$               if '$severity' .eq. 1
+$               then
+$                   if key64 then write tf "#ifndef __VAX"
+$                   write tf "#ifndef ''key2'"
+$                   write tf "#define ''key2' 1"
 $if p2 .nes. "" then write sys$output "''starfile' - #define ''key2' 1"
-$		    write tf "#endif"
-$		    if key64 then write tf "#endif"
+$                   write tf "#endif"
+$                   if key64 then write tf "#endif"
 $set nover
-$		    goto cfgh_in_loop1
-$		endif
+$                   goto cfgh_in_loop1
+$               endif
 $!
-$!		Now look for OPENSSL headers
+$!              Now look for OPENSSL headers
 $!---------------------------------------------------------
-$		if key2b .eqs. "OPENSSL"
-$		then
-$		    headf = headf - "OPENSSL_"
-$		    header = f$search("''ssl_header_dir'''headf'.h")
-$		    if header .nes. ""
-$		    then
-$			write tf "#ifndef ''key2'"
-$			write tf "#define ''key2' 1"
-$			write tf "#endif"
+$               if key2b .eqs. "OPENSSL"
+$               then
+$                   headf = headf - "OPENSSL_"
+$                   header = f$search("''ssl_header_dir'''headf'.h")
+$                   if header .nes. ""
+$                   then
+$                       write tf "#ifndef ''key2'"
+$                       write tf "#define ''key2' 1"
+$                       write tf "#endif"
 $set nover
-$			goto cfgh_in_loop1
-$		    endif
-$		endif
+$                       goto cfgh_in_loop1
+$                   endif
+$               endif
 $!
-$!		Now look for Kerberos
+$!              Now look for Kerberos
 $!------------------------------------------------------------
-$		if key2b .eqs. "GSSAPI"
-$		then
-$		    header_dir = "sys$sysroot:[kerberos.include]"
-$		    headf = headf - "GSSAPI_"
-$		    header = f$search("''header_dir'''headf'.h")
-$		    if header .nes. ""
-$		    then
-$			write tf "#ifndef ''key2'"
-$			write tf "#define ''key2' 1"
-$			write tf "#endif"
+$               if key2b .eqs. "GSSAPI"
+$               then
+$                   header_dir = "sys$sysroot:[kerberos.include]"
+$                   headf = headf - "GSSAPI_"
+$                   header = f$search("''header_dir'''headf'.h")
+$                   if header .nes. ""
+$                   then
+$                       write tf "#ifndef ''key2'"
+$                       write tf "#define ''key2' 1"
+$                       write tf "#endif"
 $set nover
-$			goto cfgh_in_loop1
-$		    endif
-$		endif
+$                       goto cfgh_in_loop1
+$                   endif
+$               endif
 $!
 $set nover
-$	    else
+$           else
 $!
-$!		Looking for a routine or a symbol
+$!              Looking for a routine or a symbol
 $!------------------------------------------------
-$		if key2c .eqs. "MACRO"
-$		then
-$		    if (key2b .eqs. "FILE") .or. (key2b .eqs. "DATE") -
-			.or. (key2b .eqs. "LINE") .or. (key2b .eqs. "TIME")
-$		    then
-$			write tf "#ifndef HAVE_''key2b'"
-$			write tf "#define HAVE_''key2b' 1"
-$			write tf "#endif"
-$		    endif
-$		    goto cfgh_in_loop1
-$		endif
-$!
-$!		Special false tests
+$               if key2c .eqs. "MACRO"
+$               then
+$                   if (key2b .eqs. "FILE") .or. (key2b .eqs. "DATE") -
+                        .or. (key2b .eqs. "LINE") .or. (key2b .eqs. "TIME")
+$                   then
+$                       write tf "#ifndef HAVE_''key2b'"
+$                       write tf "#define HAVE_''key2b' 1"
+$                       write tf "#endif"
+$                   endif
+$                   goto cfgh_in_loop1
+$               endif
+$!
+$!              Special false tests
 $!-------------------------------------
-$		if double_under
-$		then
-$		    if key2b .eqs. "_FCNTL" .or. key2b .eqs. "__FCNTL"
-$		    then
-$			write tf "/* #undef HAVE_''key2b' */"
-$			goto cfgh_in_loop1
-$		    endif
-$!
-$		    if key2b .eqs. "_STAT" .or. key2b .eqs. "__STAT"
-$		    then
-$			write tf "/* #undef HAVE_''key2b' */"
-$			goto cfgh_in_loop1
-$		    endif
-$!
-$		    if key2b .eqs. "_READ" .or. key2b .eqs. "__READ"
-$		    then
-$			write tf "/* #undef HAVE_''key2b' */"
-$			goto cfgh_in_loop1
-$		    endif
-$		endif
-$!
-$		keysym = key2b
-$		if key2c .nes. "" then keysym = keysym + "_" + key2c
-$		if key2d .nes. "" then keysym = keysym + "_" + key2d
-$		if key2e .nes. "" then keysym = keysym + "_" + key2e
-$!
-$!
-$!		Stat structure members
+$               if double_under
+$               then
+$                   if key2b .eqs. "_FCNTL" .or. key2b .eqs. "__FCNTL"
+$                   then
+$                       write tf "/* #undef HAVE_''key2b' */"
+$                       goto cfgh_in_loop1
+$                   endif
+$!
+$                   if key2b .eqs. "_STAT" .or. key2b .eqs. "__STAT"
+$                   then
+$                       write tf "/* #undef HAVE_''key2b' */"
+$                       goto cfgh_in_loop1
+$                   endif
+$!
+$                   if key2b .eqs. "_READ" .or. key2b .eqs. "__READ"
+$                   then
+$                       write tf "/* #undef HAVE_''key2b' */"
+$                       goto cfgh_in_loop1
+$                   endif
+$               endif
+$!
+$               keysym = key2b
+$               if key2c .nes. "" then keysym = keysym + "_" + key2c
+$               if key2d .nes. "" then keysym = keysym + "_" + key2d
+$               if key2e .nes. "" then keysym = keysym + "_" + key2e
+$!
+$!
+$!              Stat structure members
 $!-------------------------------------
-$		if key2b .eqs. "STRUCT"
-$		then
-$		    if key2c .eqs. "STAT" .and (key2d .nes. "")
-$		    then
-$			key2b = key2b + "_" + key2c + "_" + key2d
-$			key2c = key2e
-$			key2d = ""
-$			key2e = ""
-$		    endif
-$		endif
-$		if (key2b .eqs. "ST") .or. (key2b .eqs. "STRUCT_STAT_ST")
-$		then
-$		    keysym = "ST" + "_" + key2c
-$		    keysym = f$edit(keysym,"LOWERCASE")
-$		endif
-$		if key2a .eqs. "STAT"
-$		then
-$		    if (f$locate("STATVFS", key2b) .eq. 0) .and. key2c .eqs. ""
-$		    then
-$			keysym = f$edit(key2b, "LOWERCASE")
-$		    endif
-$!$		    if (key2b .eqs. "STATVFS" .or. key2b .eqs. "STATFS2" -
-$!			.or. key2b .eqs. "STATFS3") .and. key2c .nes. ""
-$!
-$		    if (key2b .eqs. "STATVFS") .and. key2c .nes. ""
-$		    then
-$!			Should really verify that the structure
-$!			named by key2b actually exists first.
+$               if key2b .eqs. "STRUCT"
+$               then
+$                   if key2c .eqs. "STAT" .and (key2d .nes. "")
+$                   then
+$                       key2b = key2b + "_" + key2c + "_" + key2d
+$                       key2c = key2e
+$                       key2d = ""
+$                       key2e = ""
+$                   endif
+$               endif
+$               if (key2b .eqs. "ST") .or. (key2b .eqs. "STRUCT_STAT_ST")
+$               then
+$                   keysym = "ST" + "_" + key2c
+$                   keysym = f$edit(keysym,"LOWERCASE")
+$               endif
+$               if key2a .eqs. "STAT"
+$               then
+$                   if (f$locate("STATVFS", key2b) .eq. 0) .and. key2c .eqs. ""
+$                   then
+$                       keysym = f$edit(key2b, "LOWERCASE")
+$                   endif
+$!$                 if (key2b .eqs. "STATVFS" .or. key2b .eqs. "STATFS2" -
+$!                      .or. key2b .eqs. "STATFS3") .and. key2c .nes. ""
+$!
+$                   if (key2b .eqs. "STATVFS") .and. key2c .nes. ""
+$                   then
+$!                      Should really verify that the structure
+$!                      named by key2b actually exists first.
 $!------------------------------------------------------------
 $!
-$!			Statvfs structure members
+$!                      Statvfs structure members
 $!-------------------------------------------------
-$			keysym = "f_" + f$edit(key2c,"LOWERCASE")
-$		    endif
-$		endif
+$                       keysym = "f_" + f$edit(key2c,"LOWERCASE")
+$                   endif
+$               endif
 $!
-$!		UTMPX structure members
+$!              UTMPX structure members
 $!--------------------------------------
-$		if key2b .eqs. "UT" .and. key2c .eqs. "UT"
-$		then
-$		    keysym = "ut_" + f$edit(key2d,"LOWERCASE")
-$		endif
-$!
-$		if f$locate("MMAP",key2) .lt. key2_len
-$		then
-$		   write sys$output ""
-$		   write sys$output -
+$               if key2b .eqs. "UT" .and. key2c .eqs. "UT"
+$               then
+$                   keysym = "ut_" + f$edit(key2d,"LOWERCASE")
+$               endif
+$!
+$               if f$locate("MMAP",key2) .lt. key2_len
+$               then
+$                  write sys$output ""
+$                  write sys$output -
   "%CONFIG_H-I-NONPORT, ''key2' being asked for!"
-$		   write sys$output -
+$                  write sys$output -
  "-CONFIG_H-I-MMAP, MMAP operations only work on STREAM and BINARY files!"
-$		   write sys$output -
+$                  write sys$output -
  "-CONFIG_H-I-REVIEW, Manual Code review required!"
-$		    if update_config_vms
-$		    then
-$			open/append tfcv sys$disk:[]config_vms.h
-$			write tfcv ""
-$			write tfcv -
-		"/* Check config.h for use of ''key2' settings */"
-$			write tfcv ""
-$			close tfcv
-$		    endif
-$		endif
-$!
-$!
-$		if keysym .eqs. "CRYPT"
-$		then
-$		   write sys$output ""
-$		   write sys$output -
+$                   if update_config_vms
+$                   then
+$                       open/append tfcv sys$disk:[]config_vms.h
+$                       write tfcv ""
+$                       write tfcv -
+                "/* Check config.h for use of ''key2' settings */"
+$                       write tfcv ""
+$                       close tfcv
+$                   endif
+$               endif
+$!
+$!
+$               if keysym .eqs. "CRYPT"
+$               then
+$                  write sys$output ""
+$                  write sys$output -
   "%CONFIG_H-I-NONPORT, ''key2' being asked for!"
-$		   write sys$output -
+$                  write sys$output -
  "-CONFIG_H-I-CRYPT, CRYPT operations on the VMS SYSUAF may not work!"
-$		   write sys$output -
+$                  write sys$output -
  "-CONFIG_H-I-REVIEW, Manual Code review required!"
-$		    if update_config_vms
-$		    then
-$			open/append tfcv sys$disk:[]config_vms.h
-$			write tfcv ""
-$			write tfcv -
-		"/* Check config.h for use of ''keysym' */"
-$			write tfcv ""
-$			close tfcv
-$		    endif
-$		endif
-$!
-$!
-$		if keysym .eqs. "EXECL"
-$		then
-$		   write sys$output ""
-$		   write sys$output -
+$                   if update_config_vms
+$                   then
+$                       open/append tfcv sys$disk:[]config_vms.h
+$                       write tfcv ""
+$                       write tfcv -
+                "/* Check config.h for use of ''keysym' */"
+$                       write tfcv ""
+$                       close tfcv
+$                   endif
+$               endif
+$!
+$!
+$               if keysym .eqs. "EXECL"
+$               then
+$                  write sys$output ""
+$                  write sys$output -
   "%CONFIG_H-I-NONPORT, ''key2' being asked for!"
-$		   write sys$output -
+$                  write sys$output -
  "-CONFIG_H-I-EXCEL, EXECL configured, Will probably not work."
-$		   write sys$output -
+$                  write sys$output -
  "-CONFIG_H-I-REVIEW, Manual Code review required!"
-$		    if update_config_vms
-$		    then
-$			open/append tfcv sys$disk:[]config_vms.h
-$			write tfcv ""
-$			write tfcv -
-		"/* Check config.h for use of ''keysym' */"
-$			write tfcv ""
-$			close tfcv
-$		    endif
-$		endif
-$!
-$!
-$!		Process if cpp supports ANSI-C stringizing '#' operator
+$                   if update_config_vms
+$                   then
+$                       open/append tfcv sys$disk:[]config_vms.h
+$                       write tfcv ""
+$                       write tfcv -
+                "/* Check config.h for use of ''keysym' */"
+$                       write tfcv ""
+$                       close tfcv
+$                   endif
+$               endif
+$!
+$!
+$!              Process if cpp supports ANSI-C stringizing '#' operator
 $!-----------------------------------------------------------------------
-$		if keysym .eqs. "STRINGIZE"
-$		then
-$		    write tf "#ifndef HAVE_STRINGIZE"
-$		    write tf "#define HAVE_STRINGSIZE 1"
-$		    write tf "#endif"
-$		    goto cfgh_in_loop1
-$		endif
-$!
-$		if keysym .eqs. "VOLATILE"
-$		then
-$		    write tf "#ifndef HAVE_VOLATILE"
-$		    write tf "#define HAVE_VOLATILE 1"
-$		    write tf "#endif"
-$		    goto cfgh_in_loop1
-$		endif
-$!
-$		if keysym .eqs. "ALLOCA"
-$		then
-$		    write tf "#ifndef HAVE_ALLOCA"
-$		    write tf "#define HAVE_ALLOCA 1"
-$		    write tf "#endif"
-$		    goto cfgh_in_loop1
-$		endif
-$!
-$		if keysym .eqs. "ERRNO_DECL"
-$		then
-$		    write tf "#ifndef HAVE_ERRNO_DECL"
-$		    write tf "#define HAVE_ERRNO_DECL 1"
-$		    write tf "#endif"
-$		    goto cfgh_in_loop1
-$		endif
-$!
-$		if keysym .eqs. "LONGLONG"
-$		then
-$		    write tf "#ifndef __VAX"
-$		    write tf "#pragma message disable longlongtype"
-$		    write tf "#ifndef HAVE_LONGLONG"
-$		    write tf "#define HAVE_LONGLONG 1"
-$		    write tf "#endif"
-$		    write tf "#endif"
-$		    goto cfgh_in_loop1
-$		endif
-$!
-$!		May need to test compiler version
+$               if keysym .eqs. "STRINGIZE"
+$               then
+$                   write tf "#ifndef HAVE_STRINGIZE"
+$                   write tf "#define HAVE_STRINGSIZE 1"
+$                   write tf "#endif"
+$                   goto cfgh_in_loop1
+$               endif
+$!
+$               if keysym .eqs. "VOLATILE"
+$               then
+$                   write tf "#ifndef HAVE_VOLATILE"
+$                   write tf "#define HAVE_VOLATILE 1"
+$                   write tf "#endif"
+$                   goto cfgh_in_loop1
+$               endif
+$!
+$               if keysym .eqs. "ALLOCA"
+$               then
+$                   write tf "#ifndef HAVE_ALLOCA"
+$                   write tf "#define HAVE_ALLOCA 1"
+$                   write tf "#endif"
+$                   goto cfgh_in_loop1
+$               endif
+$!
+$               if keysym .eqs. "ERRNO_DECL"
+$               then
+$                   write tf "#ifndef HAVE_ERRNO_DECL"
+$                   write tf "#define HAVE_ERRNO_DECL 1"
+$                   write tf "#endif"
+$                   goto cfgh_in_loop1
+$               endif
+$!
+$               if keysym .eqs. "LONGLONG"
+$               then
+$                   write tf "#ifndef __VAX"
+$                   write tf "#pragma message disable longlongtype"
+$                   write tf "#ifndef HAVE_LONGLONG"
+$                   write tf "#define HAVE_LONGLONG 1"
+$                   write tf "#endif"
+$                   write tf "#endif"
+$                   goto cfgh_in_loop1
+$               endif
+$!
+$!              May need to test compiler version
 $!-----------------------------------------------
-$		if keysym .eqs. "LONG_LONG"
-$		then
-$		    write tf "#ifndef __VAX"
-$		    write tf "#pragma message disable longlongtype"
-$		    write tf "#ifndef HAVE_LONG_LONG"
-$		    write tf "#define HAVE_LONG_LONG 1"
-$		    write tf "#endif"
-$		    write tf "#endif"
-$		    goto cfgh_in_loop1
-$		endif
-$!
-$!		May need to test compiler version
+$               if keysym .eqs. "LONG_LONG"
+$               then
+$                   write tf "#ifndef __VAX"
+$                   write tf "#pragma message disable longlongtype"
+$                   write tf "#ifndef HAVE_LONG_LONG"
+$                   write tf "#define HAVE_LONG_LONG 1"
+$                   write tf "#endif"
+$                   write tf "#endif"
+$                   goto cfgh_in_loop1
+$               endif
+$!
+$!              May need to test compiler version
 $!-----------------------------------------------
-$		if keysym .eqs. "UNSIGNED_LONG_LONG"
-$		then
-$		    write tf "#ifndef __VAX"
-$		    write tf "#pragma message disable longlongtype"
-$		    write tf "#ifndef HAVE_UNSIGNED_LONG_LONG"
-$		    write tf "#define HAVE_UNSIGNED_LONG_LONG 1"
-$		    write tf "#endif"
-$		    write tf "#endif"
-$		    goto cfgh_in_loop1
-$		endif
-$!
-$!		May need to test compiler version
+$               if keysym .eqs. "UNSIGNED_LONG_LONG"
+$               then
+$                   write tf "#ifndef __VAX"
+$                   write tf "#pragma message disable longlongtype"
+$                   write tf "#ifndef HAVE_UNSIGNED_LONG_LONG"
+$                   write tf "#define HAVE_UNSIGNED_LONG_LONG 1"
+$                   write tf "#endif"
+$                   write tf "#endif"
+$                   goto cfgh_in_loop1
+$               endif
+$!
+$!              May need to test compiler version
 $!-----------------------------------------------
-$		if keysym .eqs. "UNSIGNED_LONG_LONG_INT"
-$		then
-$		    write tf "#ifndef __VAX"
-$		    write tf "#pragma message disable longlongtype"
-$		    write tf "#ifndef HAVE_UNSIGNED_LONG_LONG_INT"
-$		    write tf "#define HAVE_UNSIGNED_LONG_LONG_INT 1"
-$		    write tf "#endif"
-$		    write tf "#endif"
-$		    goto cfgh_in_loop1
-$		endif
-$!
-$!		May need to test compiler version
+$               if keysym .eqs. "UNSIGNED_LONG_LONG_INT"
+$               then
+$                   write tf "#ifndef __VAX"
+$                   write tf "#pragma message disable longlongtype"
+$                   write tf "#ifndef HAVE_UNSIGNED_LONG_LONG_INT"
+$                   write tf "#define HAVE_UNSIGNED_LONG_LONG_INT 1"
+$                   write tf "#endif"
+$                   write tf "#endif"
+$                   goto cfgh_in_loop1
+$               endif
+$!
+$!              May need to test compiler version
 $!-----------------------------------------------
-$		if keysym .eqs. "LONG_DOUBLE"
-$		then
-$		    write tf "#ifndef __VAX"
-$		    write tf "#pragma message disable longlongtype"
-$		    write tf "#ifndef HAVE_LONG_DOUBLE"
-$		    write tf "#define HAVE_LONG_DOUBLE 1"
-$		    write tf "#endif"
-$		    write tf "#endif"
-$		    goto cfgh_in_loop1
-$		endif
-$!
-$		if keysym .eqs. "FCNTL_LOCK"
-$		then
-$		    write sys$output -
+$               if keysym .eqs. "LONG_DOUBLE"
+$               then
+$                   write tf "#ifndef __VAX"
+$                   write tf "#pragma message disable longlongtype"
+$                   write tf "#ifndef HAVE_LONG_DOUBLE"
+$                   write tf "#define HAVE_LONG_DOUBLE 1"
+$                   write tf "#endif"
+$                   write tf "#endif"
+$                   goto cfgh_in_loop1
+$               endif
+$!
+$               if keysym .eqs. "FCNTL_LOCK"
+$               then
+$                   write sys$output -
   "%CONFIG_H-I-NONPORT, ''key2' being asked for!
-$		   write sys$output -
+$                  write sys$output -
  "-CONFIG_H-I-REVIEW, Manual Code review required!"
-$		    goto cfgh_in_loop1
-$		endif
+$                   goto cfgh_in_loop1
+$               endif
 $!
 $!
-$!		These libraries are provided by the DEC C RTL
+$!              These libraries are provided by the DEC C RTL
 $!-------------------------------------------------------------
-$		if keysym .eqs. "LIBINET" .or. keysym .eqs. "LIBSOCKET"
-$		then
-$		    write tf "#ifndef HAVE_''keysym'"
-$		    write tf "#define HAVE_''keysym' 1"
+$               if keysym .eqs. "LIBINET" .or. keysym .eqs. "LIBSOCKET"
+$               then
+$                   write tf "#ifndef HAVE_''keysym'"
+$                   write tf "#define HAVE_''keysym' 1"
 $if p2 .nes. "" then write sys$output "''decc_shr' #define ''keysym' 1"
-$		    write tf "#endif
-$		    goto cfgh_in_loop1
-$		endif
-$!
-$		if keysym .eqs. "HERRNO" then keysym = "h_errno"
-$		if keysym .eqs. "UTIMBUF" then keysym = "utimbuf"
-$		if key2c .eqs. "STRUCT"
-$		then
-$		    keysym = f$edit(key2d,"LOWERCASE")
-$		else
-$		    if key2_h .eqs. "_T"
-$		    then
-$			if key2_t .eqs. "_TYPE"
-$			then
-$			    keysym = f$extract(0, key2_len - 5, key2) - "HAVE_"
-$			endif
-$			keysym = f$edit(keysym,"LOWERCASE")
-$		    endif
-$		endif
-$!
-$!		Check the DEC C RTL shared image first
+$                   write tf "#endif
+$                   goto cfgh_in_loop1
+$               endif
+$!
+$               if keysym .eqs. "HERRNO" then keysym = "h_errno"
+$               if keysym .eqs. "UTIMBUF" then keysym = "utimbuf"
+$               if key2c .eqs. "STRUCT"
+$               then
+$                   keysym = f$edit(key2d,"LOWERCASE")
+$               else
+$                   if key2_h .eqs. "_T"
+$                   then
+$                       if key2_t .eqs. "_TYPE"
+$                       then
+$                           keysym = f$extract(0, key2_len - 5, key2) - "HAVE_"
+$                       endif
+$                       keysym = f$edit(keysym,"LOWERCASE")
+$                   endif
+$               endif
+$!
+$!              Check the DEC C RTL shared image first
 $!------------------------------------------------------
-$		if f$search(tfile1) .nes. "" then delete 'tfile1';*
-$		define/user sys$output nl:
-$		define/user sys$error nl:
-$		search/format=nonull/out='tfile1' 'decc_shr' 'keysym'
-$		if '$severity' .eq. 1
-$		then
-$!
-$!		    Not documented, but from observation
+$               if f$search(tfile1) .nes. "" then delete 'tfile1';*
+$               define/user sys$output nl:
+$               define/user sys$error nl:
+$               search/format=nonull/out='tfile1' 'decc_shr' 'keysym'
+$               if '$severity' .eq. 1
+$               then
+$!
+$!                  Not documented, but from observation
 $!------------------------------------------------------
-$		    define/user sys$output nl:
-$		    define/user sys$error nl:
-$		    if arch_type .eq. 3
-$		    then
-$			keyterm = "''keysym'<SOH>"
-$		    else
-$			if arch_type .eq. 2
-$			then
-$			    keyterm = "''keysym'<BS>"
-$			else
-$			    keyterm = "''keysym'<STX>"
-$			endif
-$		    endif
-$		    search/out=nl: 'tfile1' -
+$                   define/user sys$output nl:
+$                   define/user sys$error nl:
+$                   if arch_type .eq. 3
+$                   then
+$                       keyterm = "''keysym'<SOH>"
+$                   else
+$                       if arch_type .eq. 2
+$                       then
+$                           keyterm = "''keysym'<BS>"
+$                       else
+$                           keyterm = "''keysym'<STX>"
+$                       endif
+$                   endif
+$                   search/out=nl: 'tfile1' -
    "$''keyterm'","$g''keyterm'","$__utc_''keyterm'",-
    "$__utctz_''keyterm'","$__bsd44_''keyterm'","$bsd_''keyterm'",-
    "$''keysym'decc$","$G''keysym'decc$","$GX''keyterm'"
-$		    severity = '$severity'
+$                   severity = '$severity'
 $!
 $!
-$!		    Of course the 64 bit stuff is different
+$!                  Of course the 64 bit stuff is different
 $!---------------------------------------------------------
-$		    if severity .ne. 1 .and. key64
-$		    then
-$			define/user sys$output nl:
-$		        define/user sys$error nl:
-$			search/out=nl: 'tfile1' "$_''keyterm'"
-$!			search/out 'tfile1' "$_''keyterm'"
-$			severity = '$severity'
-$		    endif
-$!
-$!		    Unix compatibility routines
+$                   if severity .ne. 1 .and. key64
+$                   then
+$                       define/user sys$output nl:
+$                       define/user sys$error nl:
+$                       search/out=nl: 'tfile1' "$_''keyterm'"
+$!                      search/out 'tfile1' "$_''keyterm'"
+$                       severity = '$severity'
+$                   endif
+$!
+$!                  Unix compatibility routines
 $!---------------------------------------------
-$		    if severity .ne. 1
-$		    then
-$			define/user sys$output nl:
-$			define/user sys$error nl:
-$			search/out=nl: 'tfile1' -
+$                   if severity .ne. 1
+$                   then
+$                       define/user sys$output nl:
+$                       define/user sys$error nl:
+$                       search/out=nl: 'tfile1' -
     "$__unix_''keyterm'","$__vms_''keyterm'","$_posix_''keyterm'"
-$			severity = '$severity'
-$		    endif
+$                       severity = '$severity'
+$                   endif
 $!
-$!		    Show the result of the search
+$!                  Show the result of the search
 $!------------------------------------------------
-$		    if 'severity' .eq. 1
-$		    then
-$			if key64 then write tf "#ifndef __VAX"
-$			write tf "#ifndef ''key2'"
-$			write tf "#define ''key2' 1"
+$                   if 'severity' .eq. 1
+$                   then
+$                       if key64 then write tf "#ifndef __VAX"
+$                       write tf "#ifndef ''key2'"
+$                       write tf "#define ''key2' 1"
 $if p2 .nes. "" then write sys$output "''decc_shr' #define ''key2' 1"
-$			write tf "#endif"
-$			if key64 then write tf "#endif"
-$			goto cfgh_in_loop1
-$		    endif
-$		endif
-$		if f$search(tfile1) .nes. "" then delete 'tfile1';*
-$!
-$!		Check the DECC Header files next
+$                       write tf "#endif"
+$                       if key64 then write tf "#endif"
+$                       goto cfgh_in_loop1
+$                   endif
+$               endif
+$               if f$search(tfile1) .nes. "" then delete 'tfile1';*
+$!
+$!              Check the DECC Header files next
 $!----------------------------------------------
-$		define/user sys$output nl:
-$		define/user sys$error nl:
-$		search/out=nl: 'decc_rtldef' -
-		    "''keysym';", "''keysym'[", "struct ''keysym'"/exact
-$		severity = '$severity'
-$		if severity .eq. 1
-$		then
-$		    if key64 then write tf "#ifndef __VAX"
-$		    write tf "#ifndef ''key2'"
-$		    write tf "#define ''key2' 1"
+$               define/user sys$output nl:
+$               define/user sys$error nl:
+$               search/out=nl: 'decc_rtldef' -
+                    "''keysym';", "''keysym'[", "struct ''keysym'"/exact
+$               severity = '$severity'
+$               if severity .eq. 1
+$               then
+$                   if key64 then write tf "#ifndef __VAX"
+$                   write tf "#ifndef ''key2'"
+$                   write tf "#define ''key2' 1"
 $if p2 .nes. "" then write sys$output "''decc_rtldef' #define ''key2' 1"
-$		    write tf "#endif"
-$		    if key64 then write tf "#endif"
-$		    goto cfgh_in_loop1
-$		endif
+$                   write tf "#endif"
+$                   if key64 then write tf "#endif"
+$                   goto cfgh_in_loop1
+$               endif
 $!
-$!		Check kerberos
+$!              Check kerberos
 $!--------------------------------------------
-$		if f$search("SYS$SYSROOT:[kerberos]include.dir") .nes. ""
-$		then
-$		    test_mit = "SYS$SYSROOT:[kerberos.include]gssapi_krb5.h"
-$		    if (key2 .eqs. "HAVE_GSSAPI")
-$		    then
-$			write tf "#ifndef ''key2'"
-$			write tf "#define ''key2' 1"
-$			write tf "#endif"
-$			goto cfgh_in_loop1
-$		    endif
-$		endif
-$!
-$	    endif
-$	    write tf "/* ", xline, " */"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$!
-$!	Process SIZEOF directives found in SAMBA and others
+$               if f$search("SYS$SYSROOT:[kerberos]include.dir") .nes. ""
+$               then
+$                   test_mit = "SYS$SYSROOT:[kerberos.include]gssapi_krb5.h"
+$                   if (key2 .eqs. "HAVE_GSSAPI")
+$                   then
+$                       write tf "#ifndef ''key2'"
+$                       write tf "#define ''key2' 1"
+$                       write tf "#endif"
+$                       goto cfgh_in_loop1
+$                   endif
+$               endif
+$!
+$           endif
+$           write tf "/* ", xline, " */"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$!
+$!      Process SIZEOF directives found in SAMBA and others
 $!----------------------------------------------------------
-$	if key2a .eqs. "SIZEOF"
-$	then
-$	    if key2b .eqs. "INO" .and. key2_h .eqs. "_T"
-$	    then
-$		write tf "#ifndef SIZEOF_INO_T"
-$		write tf "#if !__USING_STD_STAT
-$		write tf "#define SIZEOF_INO_T 6"
-$		write tf "#else
-$		write tf "#define SIZEOF_INO_T 8"
-$		write tf "#endif
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2b .eqs. "INTMAX" .and. key2_h .eqs. "_T"
-$	    then
-$		write tf "#ifndef SIZEOF_INTMAX_T"
-$		write tf "#ifdef __VAX"
-$		write tf "#define SIZEOF_INTMAX_T 4"
-$		write tf "#else"
-$		write tf "#define SIZEOF_INTMAX_T 8"
-$		write tf "#endif"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2b .eqs. "OFF" .and. key2_h .eqs. "_T"
-$	    then
-$		write tf "#ifndef SIZEOF_OFF_T"
-$		write tf "#if __USE_OFF64_T"
-$		write tf "#define SIZEOF_OFF_T 8"
-$		write tf "#else"
-$		write tf "#define SIZEOF_OFF_T 4"
-$		write tf "#endif"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2b .eqs. "CHAR" .and. key2_h .eqs. "_P"
-$	    then
-$		write tf "#ifndef SIZEOF_CHAR_P"
-$		write tf "#if __INITIAL_POINTER_SIZE == 64"
-$		write tf "#define SIZEOF_CHAR_P 8"
-$		write tf "#else"
-$		write tf "#define SIZEOF_CHAR_P 4"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2b .eqs. "VOIDP"
-$	    then
-$		write tf "#ifndef SIZEOF_VOIDP"
-$		write tf "#if __INITIAL_POINTER_SIZE == 64"
-$		write tf "#define SIZEOF_VOIDP 8"
-$		write tf "#else"
-$		write tf "#define SIZEOF_VOIDP 4"
-$		write tf "#endif"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2b .eqs. "INT"
-$	    then
-$		write tf "#ifndef SIZEOF_INT"
-$		write tf "#define SIZEOF_INT 4"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2b .eqs. "SIZE" .and. key2_h .eqs. "_T"
-$	    then
-$		write tf "#ifndef SIZEOF_SIZE_T"
-$		write tf "#define SIZEOF_SIZE_T 4"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2b .eqs. "TIME" .and. key2_h .eqs. "_T"
-$	    then
-$		write tf "#ifndef SIZEOF_TIME_T"
-$		write tf "#define SIZEOF_TIME_T 4"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2b .eqs. "DOUBLE"
-$	    then
-$		write tf "#ifndef SIZEOF_DOUBLE"
-$		write tf "#define SIZEOF_DOUBLE 8"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2b .eqs. "LONG"
-$	    then
-$		if key2c .eqs. ""
-$		then
-$		    write tf "#ifndef SIZEOF_LONG"
-$		    write tf "#define SIZEOF_LONG 4"
-$		    write tf "#endif"
-$		else
-$		    write tf "#ifndef SIZEOF_LONG_LONG"
-$		    write tf "#ifndef __VAX"
-$		    write tf "#define SIZEOF_LONG_LONG 8"
-$		    write tf "#endif"
-$		    write tf "#endif"
-$		endif
-$		goto cfgh_in_loop1
-$	    endif
-$	    write tf "/* ", xline, " */"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$!	Process NEED directives
+$       if key2a .eqs. "SIZEOF"
+$       then
+$           if key2b .eqs. "INO" .and. key2_h .eqs. "_T"
+$           then
+$               write tf "#ifndef SIZEOF_INO_T"
+$               write tf "#if !__USING_STD_STAT
+$               write tf "#define SIZEOF_INO_T 6"
+$               write tf "#else
+$               write tf "#define SIZEOF_INO_T 8"
+$               write tf "#endif
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2b .eqs. "INTMAX" .and. key2_h .eqs. "_T"
+$           then
+$               write tf "#ifndef SIZEOF_INTMAX_T"
+$               write tf "#ifdef __VAX"
+$               write tf "#define SIZEOF_INTMAX_T 4"
+$               write tf "#else"
+$               write tf "#define SIZEOF_INTMAX_T 8"
+$               write tf "#endif"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2b .eqs. "OFF" .and. key2_h .eqs. "_T"
+$           then
+$               write tf "#ifndef SIZEOF_OFF_T"
+$               write tf "#if __USE_OFF64_T"
+$               write tf "#define SIZEOF_OFF_T 8"
+$               write tf "#else"
+$               write tf "#define SIZEOF_OFF_T 4"
+$               write tf "#endif"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2b .eqs. "CHAR" .and. key2_h .eqs. "_P"
+$           then
+$               write tf "#ifndef SIZEOF_CHAR_P"
+$               write tf "#if __INITIAL_POINTER_SIZE == 64"
+$               write tf "#define SIZEOF_CHAR_P 8"
+$               write tf "#else"
+$               write tf "#define SIZEOF_CHAR_P 4"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2b .eqs. "VOIDP"
+$           then
+$               write tf "#ifndef SIZEOF_VOIDP"
+$               write tf "#if __INITIAL_POINTER_SIZE == 64"
+$               write tf "#define SIZEOF_VOIDP 8"
+$               write tf "#else"
+$               write tf "#define SIZEOF_VOIDP 4"
+$               write tf "#endif"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2b .eqs. "INT"
+$           then
+$               write tf "#ifndef SIZEOF_INT"
+$               write tf "#define SIZEOF_INT 4"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2b .eqs. "SIZE" .and. key2_h .eqs. "_T"
+$           then
+$               write tf "#ifndef SIZEOF_SIZE_T"
+$               write tf "#define SIZEOF_SIZE_T 4"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2b .eqs. "TIME" .and. key2_h .eqs. "_T"
+$           then
+$               write tf "#ifndef SIZEOF_TIME_T"
+$               write tf "#define SIZEOF_TIME_T 4"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2b .eqs. "DOUBLE"
+$           then
+$               write tf "#ifndef SIZEOF_DOUBLE"
+$               write tf "#define SIZEOF_DOUBLE 8"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2b .eqs. "LONG"
+$           then
+$               if key2c .eqs. ""
+$               then
+$                   write tf "#ifndef SIZEOF_LONG"
+$                   write tf "#define SIZEOF_LONG 4"
+$                   write tf "#endif"
+$               else
+$                   write tf "#ifndef SIZEOF_LONG_LONG"
+$                   write tf "#ifndef __VAX"
+$                   write tf "#define SIZEOF_LONG_LONG 8"
+$                   write tf "#endif"
+$                   write tf "#endif"
+$               endif
+$               goto cfgh_in_loop1
+$           endif
+$           write tf "/* ", xline, " */"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$!      Process NEED directives
 $!-------------------------------
-$	if key2a .eqs. "NEED"
-$	then
-$	    if key2b .eqs. "STRINGS" .and. key2_h .eqs. "_H"
-$	    then
-$		write tf "#ifndef NEED_STRINGS_H"
-$		write tf "#define NEED_STRINGS_H 1"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    write tf "/* ", xline, " */"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$!	Process GETHOSTNAME directives
+$       if key2a .eqs. "NEED"
+$       then
+$           if key2b .eqs. "STRINGS" .and. key2_h .eqs. "_H"
+$           then
+$               write tf "#ifndef NEED_STRINGS_H"
+$               write tf "#define NEED_STRINGS_H 1"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           write tf "/* ", xline, " */"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$!      Process GETHOSTNAME directives
 $!-------------------------------------
-$	if key2 .eqs. "GETHOSTNAME_TYPE_ARG2"
-$	then
-$	    write tf "#ifndef ''key2'"
-$	    write tf "#ifdef _DECC_V4_SOURCE"
-$	    write tf "#define ''key2' int"
-$	    write tf "#else"
-$	    write tf "#define ''key2' size_t"
-$	    write tf "#endif"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$!	Process GETNAMEINFO directives
+$       if key2 .eqs. "GETHOSTNAME_TYPE_ARG2"
+$       then
+$           write tf "#ifndef ''key2'"
+$           write tf "#ifdef _DECC_V4_SOURCE"
+$           write tf "#define ''key2' int"
+$           write tf "#else"
+$           write tf "#define ''key2' size_t"
+$           write tf "#endif"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$!      Process GETNAMEINFO directives
 $!-------------------------------------
-$	if key2a .eqs. "GETNAMEINFO"
-$	then
-$	    if key2 .eqs. "GETNAMEINFO_QUAL_ARG1"
-$	    then
-$		write tf "#ifndef ''key2'"
-$		write tf "#define ''key2' const"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2 .eqs. "GETNAMEINFO_TYPE_ARG1"
-$	    then
-$		write tf "#ifndef ''key2'"
-$		write tf "#define ''key2' struct sockaddr *"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2 .eqs. "GETNAMEINFO_TYPE_ARG2"
-$	    then
-$		write tf "#ifndef ''key2'"
-$		write tf "#define ''key2' size_t"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2 .eqs. "GETNAMEINFO_TYPE_ARG46"
-$	    then
-$		write tf "#ifndef ''key2'"
-$		write tf "#define ''key2' size_t"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2 .eqs. "GETNAMEINFO_TYPE_ARG7"
-$	    then
-$		write tf "#ifndef ''key2'"
-$		write tf "#define ''key2' int"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	endif
-$!
-$!	Process RECV directives
+$       if key2a .eqs. "GETNAMEINFO"
+$       then
+$           if key2 .eqs. "GETNAMEINFO_QUAL_ARG1"
+$           then
+$               write tf "#ifndef ''key2'"
+$               write tf "#define ''key2' const"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2 .eqs. "GETNAMEINFO_TYPE_ARG1"
+$           then
+$               write tf "#ifndef ''key2'"
+$               write tf "#define ''key2' struct sockaddr *"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2 .eqs. "GETNAMEINFO_TYPE_ARG2"
+$           then
+$               write tf "#ifndef ''key2'"
+$               write tf "#define ''key2' size_t"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2 .eqs. "GETNAMEINFO_TYPE_ARG46"
+$           then
+$               write tf "#ifndef ''key2'"
+$               write tf "#define ''key2' size_t"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2 .eqs. "GETNAMEINFO_TYPE_ARG7"
+$           then
+$               write tf "#ifndef ''key2'"
+$               write tf "#define ''key2' int"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$       endif
+$!
+$!      Process RECV directives
 $!-------------------------------------
-$	if key2a .eqs. "RECV"
-$	then
-$	    if key2 .eqs. "RECV_TYPE_ARG1"
-$	    then
-$		write tf "#ifndef ''key2'"
-$		write tf "#define ''key2' int"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2 .eqs. "RECV_TYPE_ARG2"
-$	    then
-$		write tf "#ifndef ''key2'"
-$		write tf "#define ''key2' void *"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2 .eqs. "RECV_TYPE_ARG3"
-$	    then
-$		write tf "#ifndef ''key2'"
-$		write tf "#define ''key2' size_t"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2 .eqs. "RECV_TYPE_ARG4"
-$	    then
-$		write tf "#ifndef ''key2'"
-$		write tf "#define ''key2' int"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2 .eqs. "RECV_TYPE_RETV"
-$	    then
-$		write tf "#ifndef ''key2'"
-$		write tf "#define ''key2' int"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	endif
-$!
-$!	Process SEND directives
+$       if key2a .eqs. "RECV"
+$       then
+$           if key2 .eqs. "RECV_TYPE_ARG1"
+$           then
+$               write tf "#ifndef ''key2'"
+$               write tf "#define ''key2' int"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2 .eqs. "RECV_TYPE_ARG2"
+$           then
+$               write tf "#ifndef ''key2'"
+$               write tf "#define ''key2' void *"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2 .eqs. "RECV_TYPE_ARG3"
+$           then
+$               write tf "#ifndef ''key2'"
+$               write tf "#define ''key2' size_t"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2 .eqs. "RECV_TYPE_ARG4"
+$           then
+$               write tf "#ifndef ''key2'"
+$               write tf "#define ''key2' int"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2 .eqs. "RECV_TYPE_RETV"
+$           then
+$               write tf "#ifndef ''key2'"
+$               write tf "#define ''key2' int"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$       endif
+$!
+$!      Process SEND directives
 $!-------------------------------------
-$	if key2a .eqs. "SEND"
-$	then
-$	    if key2 .eqs. "SEND_QUAL_ARG2"
-$	    then
-$		write tf "#ifndef ''key2'"
-$		write tf "#define ''key2' const"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2 .eqs. "SEND_TYPE_ARG1"
-$	    then
-$		write tf "#ifndef ''key2'"
-$		write tf "#define ''key2' int"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2 .eqs. "SEND_TYPE_ARG2"
-$	    then
-$		write tf "#ifndef ''key2'"
-$		write tf "#define ''key2' void *"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2 .eqs. "SEND_TYPE_ARG3"
-$	    then
-$		write tf "#ifndef ''key2'"
-$		write tf "#define ''key2' size_t"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2 .eqs. "SEND_TYPE_ARG4"
-$	    then
-$		write tf "#ifndef ''key2'"
-$		write tf "#define ''key2' int"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	    if key2 .eqs. "SEND_TYPE_RETV"
-$	    then
-$		write tf "#ifndef ''key2'"
-$		write tf "#define ''key2' int"
-$		write tf "#endif"
-$		goto cfgh_in_loop1
-$	    endif
-$	endif
-$!
-$!
-$!	Process STATFS directives
+$       if key2a .eqs. "SEND"
+$       then
+$           if key2 .eqs. "SEND_QUAL_ARG2"
+$           then
+$               write tf "#ifndef ''key2'"
+$               write tf "#define ''key2' const"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2 .eqs. "SEND_TYPE_ARG1"
+$           then
+$               write tf "#ifndef ''key2'"
+$               write tf "#define ''key2' int"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2 .eqs. "SEND_TYPE_ARG2"
+$           then
+$               write tf "#ifndef ''key2'"
+$               write tf "#define ''key2' void *"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2 .eqs. "SEND_TYPE_ARG3"
+$           then
+$               write tf "#ifndef ''key2'"
+$               write tf "#define ''key2' size_t"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2 .eqs. "SEND_TYPE_ARG4"
+$           then
+$               write tf "#ifndef ''key2'"
+$               write tf "#define ''key2' int"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$           if key2 .eqs. "SEND_TYPE_RETV"
+$           then
+$               write tf "#ifndef ''key2'"
+$               write tf "#define ''key2' int"
+$               write tf "#endif"
+$               goto cfgh_in_loop1
+$           endif
+$       endif
+$!
+$!
+$!      Process STATFS directives
 $!-------------------------------
-$!	if key2a .eqs. "STATFS"
-$!	then
-$!	    write tf "/* ", xline, " */"
-$!	    goto cfgh_in_loop1
-$!	endif
+$!      if key2a .eqs. "STATFS"
+$!      then
+$!          write tf "/* ", xline, " */"
+$!          goto cfgh_in_loop1
+$!      endif
 $!
-$!	Process inline directive
+$!      Process inline directive
 $!------------------------------
-$	if key2 .eqs. "inline"
-$	then
-$	    write tf "#ifndef inline"
-$	    write tf "#define inline __inline"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$!	Process restrict directive
+$       if key2 .eqs. "inline"
+$       then
+$           write tf "#ifndef inline"
+$           write tf "#define inline __inline"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$!      Process restrict directive
 $!--------------------------------
-$	if key2 .eqs. "restrict"
-$	then
-$	    write tf "#ifndef restrict"
-$	    write tf "#define restrict __restrict"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$!	Process STDC_HEADERS (SAMBA!)
+$       if key2 .eqs. "restrict"
+$       then
+$           write tf "#ifndef restrict"
+$           write tf "#define restrict __restrict"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$!      Process STDC_HEADERS (SAMBA!)
 $!---------------------------
-$	if key2 .eqs. "STDC_HEADERS"
-$	then
-$	    write tf "#ifndef STDC_HEADERS"
-$	    write tf "#define STDC_HEADERS 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$!	Process PROTOTYPES directive
+$       if key2 .eqs. "STDC_HEADERS"
+$       then
+$           write tf "#ifndef STDC_HEADERS"
+$           write tf "#define STDC_HEADERS 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$!      Process PROTOTYPES directive
 $!-------------------------------------
-$	if key2 .eqs. "PROTOTYPES"
-$	then
-$	    write tf "#ifndef PROTOTYPES"
-$	    write tf "#define PROTOTYPES 1"
-$	    write tf "#endif"
-$	    goto cfgh_in_loop1
-$	endif
-$!
-$!	Special for SEEKDIR_RETURNS_VOID
+$       if key2 .eqs. "PROTOTYPES"
+$       then
+$           write tf "#ifndef PROTOTYPES"
+$           write tf "#define PROTOTYPES 1"
+$           write tf "#endif"
+$           goto cfgh_in_loop1
+$       endif
+$!
+$!      Special for SEEKDIR_RETURNS_VOID
 $!---------------------------------------
-$	if key2 .eqs. "SEEKDIR_RETURNS_VOID"
-$	then
-$	    write tf "#ifndef SEEKDIR_RETURNS_VOID"
-$	    write tf "#define SEEKDIR_RETURNS_VOID 1"
-$	    write tf "#endif"
-$	endif
-$!
-$!	Unknown - See if CONFIGURE can give a clue for this
+$       if key2 .eqs. "SEEKDIR_RETURNS_VOID"
+$       then
+$           write tf "#ifndef SEEKDIR_RETURNS_VOID"
+$           write tf "#define SEEKDIR_RETURNS_VOID 1"
+$           write tf "#endif"
+$       endif
+$!
+$!      Unknown - See if CONFIGURE can give a clue for this
 $!----------------------------------------------------------
-$	pflag = 0
-$	set_flag = 0
-$!	gproj_name = proj_name - "_VMS" - "-VMS"
-$	if f$search(tfile1) .nes. "" then delete 'tfile1';*
-$	define/user sys$output nl:
-$	define/user sys$error nl:
-$!	if f$locate("FILE", key2) .lt. key2_len then pflag = 1
-$!	if f$locate("DIR", key2) .eq. key2_len - 3 then pflag = 1
-$!	if f$locate("PATH", key2) .eq. key2_len - 4 then pflag = 1
-$!
-$	search/out='tfile1' 'configure_script' "''key2'="/exact
-$	search_sev = '$severity'
-$	if 'search_sev' .eq. 1
-$	then
-$	    open/read/err=unknown_cf_rd_error sf 'tfile1'
+$       pflag = 0
+$       set_flag = 0
+$!      gproj_name = proj_name - "_VMS" - "-VMS"
+$       if f$search(tfile1) .nes. "" then delete 'tfile1';*
+$       define/user sys$output nl:
+$       define/user sys$error nl:
+$!      if f$locate("FILE", key2) .lt. key2_len then pflag = 1
+$!      if f$locate("DIR", key2) .eq. key2_len - 3 then pflag = 1
+$!      if f$locate("PATH", key2) .eq. key2_len - 4 then pflag = 1
+$!
+$       search/out='tfile1' 'configure_script' "''key2'="/exact
+$       search_sev = '$severity'
+$       if 'search_sev' .eq. 1
+$       then
+$           open/read/err=unknown_cf_rd_error sf 'tfile1'
 $search_file_rd_loop:
-$	    read/end=unknown_cf_rd_err sf line_in
-$	    line_in = f$edit(line_in, "TRIM")
-$	    skey1 = f$element(0,"=",line_in)
-$	    if skey1 .eqs. key2
-$	    then
-$		skey2 = f$element(1,"=",line_in)
-$		skey2a = f$extract(0,2,skey2)
+$           read/end=unknown_cf_rd_err sf line_in
+$           line_in = f$edit(line_in, "TRIM")
+$           skey1 = f$element(0,"=",line_in)
+$           if skey1 .eqs. key2
+$           then
+$               skey2 = f$element(1,"=",line_in)
+$               skey2a = f$extract(0,2,skey2)
 $!
 $!
-$!		We can not handle assignment to shell symbols.
-$!		For now skip them.
+$!              We can not handle assignment to shell symbols.
+$!              For now skip them.
 $!------------------------------------------------------------
-$		if f$locate("$", skey2) .lt. f$length(skey2)
-$		then
-$		    write tf "/* ", xline, " */"
-$		    set_flag = 1
-$		    goto found_in_configure
-$		endif
-$!
-$!		Keep these two cases separate to make it easier to add
-$!		more future intelligence to this routine
+$               if f$locate("$", skey2) .lt. f$length(skey2)
+$               then
+$                   write tf "/* ", xline, " */"
+$                   set_flag = 1
+$                   goto found_in_configure
+$               endif
+$!
+$!              Keep these two cases separate to make it easier to add
+$!              more future intelligence to this routine
 $!----------------------------------------------------------------------
-$		if skey2a .eqs. """`"
-$		then
-$!		    if pflag .eq. 1
-$!		    then
-$!			write tf "#ifndef ''key2'"
-$!			write tf "#define ",key2," """,gproj_name,"_",key2,""""
-$!			write tf "#endif"
-$!		    else
-$!			Ignore this for now
+$               if skey2a .eqs. """`"
+$               then
+$!                  if pflag .eq. 1
+$!                  then
+$!                      write tf "#ifndef ''key2'"
+$!                      write tf "#define ",key2," """,gproj_name,"_",key2,""""
+$!                      write tf "#endif"
+$!                  else
+$!                      Ignore this for now
 $!------------------------------------------
-$			write tf "/* ", xline, " */"
-$!		    endif
-$		    set_flag = 1
-$		    goto found_in_configure
-$		endif
-$		if skey2a .eqs. """$"
-$		then
-$!		    if pflag .eq. 1
-$!		    then
-$!			write tf "#ifndef ''key2'"
-$!			write tf "#define ",key2," """,gproj_name,"_",key2,""""
-$!			write tf "#endif"
-$!		    else
-$!			Ignore this for now
+$                       write tf "/* ", xline, " */"
+$!                  endif
+$                   set_flag = 1
+$                   goto found_in_configure
+$               endif
+$               if skey2a .eqs. """$"
+$               then
+$!                  if pflag .eq. 1
+$!                  then
+$!                      write tf "#ifndef ''key2'"
+$!                      write tf "#define ",key2," """,gproj_name,"_",key2,""""
+$!                      write tf "#endif"
+$!                  else
+$!                      Ignore this for now
 $!-------------------------------------------
-$			write tf "/* ", xline, " */"
-$!		    endif
-$		    set_flag = 1
-$		    goto found_in_configure
-$		endif
+$                       write tf "/* ", xline, " */"
+$!                  endif
+$                   set_flag = 1
+$                   goto found_in_configure
+$               endif
 $!
-$!		Remove multiple layers of quotes if present
+$!              Remove multiple layers of quotes if present
 $!----------------------------------------------------------
-$		if f$extract(0, 1, skey2) .eqs. "'"
-$		then
-$		    skey2 = skey2 - "'" - "'" - "'" - "'"
-$		endif
-$		if f$extract(0, 1, skey2) .eqs. """"
-$		then
-$		    skey2 = skey2 - """" - """" - """" - """"
-$		endif
-$		write tf "#ifndef ''key2'"
-$		if skey2 .eqs. ""
-$		then
-$		    write tf "#define ",key2
-$		else
-$!		    Only quote non-numbers
+$               if f$extract(0, 1, skey2) .eqs. "'"
+$               then
+$                   skey2 = skey2 - "'" - "'" - "'" - "'"
+$               endif
+$               if f$extract(0, 1, skey2) .eqs. """"
+$               then
+$                   skey2 = skey2 - """" - """" - """" - """"
+$               endif
+$               write tf "#ifndef ''key2'"
+$               if skey2 .eqs. ""
+$               then
+$                   write tf "#define ",key2
+$               else
+$!                  Only quote non-numbers
 $!----------------------------------------
-$		    if f$string(skey2+0) .eqs. skey2
-$		    then
-$			write tf "#define ",key2," ",skey2
-$		    else
-$			write tf "#define ",key2," """,skey2,""""
-$		    endif
-$		endif
-$		write tf "#endif"
-$		set_flag = 1
-$	    else
-$		goto search_file_rd_loop
-$!		if pflag .eq. 1
-$!		then
-$!		    write tf "#ifndef ''key2'"
-$!		    write tf "#define ",key2," """,gproj_name,"_",key2,""""
-$!		    write tf "#endif"
-$!		    set_flag = 1
-$!		endif
-$	    endif
+$                   if f$string(skey2+0) .eqs. skey2
+$                   then
+$                       write tf "#define ",key2," ",skey2
+$                   else
+$                       write tf "#define ",key2," """,skey2,""""
+$                   endif
+$               endif
+$               write tf "#endif"
+$               set_flag = 1
+$           else
+$               goto search_file_rd_loop
+$!              if pflag .eq. 1
+$!              then
+$!                  write tf "#ifndef ''key2'"
+$!                  write tf "#define ",key2," """,gproj_name,"_",key2,""""
+$!                  write tf "#endif"
+$!                  set_flag = 1
+$!              endif
+$           endif
 $found_in_configure:
 $unknown_cf_rd_err:
-$	    if f$trnlnm("sf","lnm$process",,"SUPERVISOR") .nes. ""
-$	    then
-$		close sf
-$	    endif
-$	    if f$search(tfile1) .nes. "" then delete 'tfile1';*
-$	    if set_flag .eq. 1 then goto cfgh_in_loop1
-$	endif
+$           if f$trnlnm("sf","lnm$process",,"SUPERVISOR") .nes. ""
+$           then
+$               close sf
+$           endif
+$           if f$search(tfile1) .nes. "" then delete 'tfile1';*
+$           if set_flag .eq. 1 then goto cfgh_in_loop1
+$       endif
 $   endif
 $!
 $!
diff --git a/packages/vms/curlmsg.msg b/packages/vms/curlmsg.msg
index ac2d508e3..8d428e88b 100644
--- a/packages/vms/curlmsg.msg
+++ b/packages/vms/curlmsg.msg
@@ -39,96 +39,96 @@
 !
 ! If you update this file also update curlmsg_vms.h so that they are in sync
 !
-.TITLE		CURLMSG Message files
-.FACILITY	CURL,1793	/PREFIX=CURL_
-.BASE		1
-.SEVERITY	SUCCESS
-OK		<normal successful completion>
+.TITLE          CURLMSG Message files
+.FACILITY       CURL,1793       /PREFIX=CURL_
+.BASE           1
+.SEVERITY       SUCCESS
+OK              <normal successful completion>
 
-.SEVERITY	ERROR
-UNSUPPORTED_PROTOCOL	<unsupported protocol>
-FAILED_INIT		<failed init>
-URL_MALFORMAT		<URL malformat>
-OBSOLETE4		<obsolete error code>
-COULDNT_RESOLVE_PROXY	<could not resolve proxy>
-COULDNT_RESOLVE_HOST	<could not resolve host>
-COULDNT_CONNECT		<could not connect>
-WEIRD_SERVER_REPLY	<weird server reply>
-FTP_ACCESS_DENIED	<FTP access denied>
-OBSOLETE10		<obsolete error code>
-FTP_WEIRD_PASS_REPLY	<FTP weird PASS reply>
-OBSOLETE12		<obsolete error code>
-FTP_WEIRD_PASV_REPLY	<FTP weird PASV reply>
-FTP_WEIRD_227_FORMAT	<FTP weird 227 format>
-FTP_CANT_GET_HOST	<FTP can not get host>
-OBSOLETE16		<obsolete error code>
-FTP_COULDNT_SET_TYPE	<FTP could not set type>
-PARTIAL_FILE		<partial file>
-FTP_COULDNT_RETR_FILE	<FTP could not RETR file>
-OBSOLETE20		<obsolete error code>
-QUOTE_ERROR		<quote command error>
-HTTP_RETURNED_ERROR	<HTTP returned error>
-WRITE_ERROR		<write error>
-OBSOLETE24    		<obsolete error code>
-UPLOAD_FAILED		<failed upload command>
-READ_ERROR		<read error, could not open/read file>
-OUT_OF_MEMORY		<out of memory>
-OPERATION_TIMEOUTED	<operation timed out, timeout time was reached>
-OBSOLETE29		<obsolete error code>
-FTP_PORT_FAILED		<FTP PORT operation failed>
-FTP_COULDNT_USE_REST	<FTP REST command failed>
-OBSOLETE32		<obsolete error code>
-RANGE_ERROR		<RANGE command error>
-HTTP_POST_ERROR		<HTTP POST error>
-SSL_CONNECT_ERROR	<SSL connect error>
-BAD_DOWNLOAD_RESUME	<bad download resume>
-FILE_COULDNT_READ_FILE	<FILE could not read file>
-LDAP_CANNOT_BIND	<LDAP cannot bind>
-LDAP_SEARCH_FAILED	<LDAP search failed>
-OBSOLETE40		<obsolete error code>
-FUNCTION_NOT_FOUND	<function not found>
-ABORTED_BY_CALLBACK	<aborted by callback>
-BAD_FUNCTION_ARGUMENT	<bad function argument>
-OBSOLETE44		<obsolete error code>
-INTERFACE_FAILED	<CURLOPT_INTERFACE failed>
-OBSOLETE46		<obsolete error code>
-TOO_MANY_REDIRECTS	<too many redirects>
-UNKNOWN_TELNET_OPTION	<unknown TELNET option>
-TELNET_OPTION_SYNTAX	<malformed TELNET option syntax>
-OBSOLETE50		<obsolete error code>
-PEER_FAILED_VERIF	<peer certificate or fingerprint failed>
-GOT_NOTHING		<got nothing>
-SSL_ENGINE_NOTFOUND	<SSL crypto engine not found>
-SSL_ENGINE_SETFAILED	<SSL can not set SSL crypto engine as default>
-SEND_ERROR		<SEND error, failure sending network data>
-RECV_ERROR		<RECV error, failure receiving network data>
-OBSOLETE57  		<obsolete error code>
-SSL_CERTPROBLEM		<SSL problem with the local certificate>
+.SEVERITY       ERROR
+UNSUPPORTED_PROTOCOL    <unsupported protocol>
+FAILED_INIT             <failed init>
+URL_MALFORMAT           <URL malformat>
+OBSOLETE4               <obsolete error code>
+COULDNT_RESOLVE_PROXY   <could not resolve proxy>
+COULDNT_RESOLVE_HOST    <could not resolve host>
+COULDNT_CONNECT         <could not connect>
+WEIRD_SERVER_REPLY      <weird server reply>
+FTP_ACCESS_DENIED       <FTP access denied>
+OBSOLETE10              <obsolete error code>
+FTP_WEIRD_PASS_REPLY    <FTP weird PASS reply>
+OBSOLETE12              <obsolete error code>
+FTP_WEIRD_PASV_REPLY    <FTP weird PASV reply>
+FTP_WEIRD_227_FORMAT    <FTP weird 227 format>
+FTP_CANT_GET_HOST       <FTP can not get host>
+OBSOLETE16              <obsolete error code>
+FTP_COULDNT_SET_TYPE    <FTP could not set type>
+PARTIAL_FILE            <partial file>
+FTP_COULDNT_RETR_FILE   <FTP could not RETR file>
+OBSOLETE20              <obsolete error code>
+QUOTE_ERROR             <quote command error>
+HTTP_RETURNED_ERROR     <HTTP returned error>
+WRITE_ERROR             <write error>
+OBSOLETE24              <obsolete error code>
+UPLOAD_FAILED           <failed upload command>
+READ_ERROR              <read error, could not open/read file>
+OUT_OF_MEMORY           <out of memory>
+OPERATION_TIMEOUTED     <operation timed out, timeout time was reached>
+OBSOLETE29              <obsolete error code>
+FTP_PORT_FAILED         <FTP PORT operation failed>
+FTP_COULDNT_USE_REST    <FTP REST command failed>
+OBSOLETE32              <obsolete error code>
+RANGE_ERROR             <RANGE command error>
+HTTP_POST_ERROR         <HTTP POST error>
+SSL_CONNECT_ERROR       <SSL connect error>
+BAD_DOWNLOAD_RESUME     <bad download resume>
+FILE_COULDNT_READ_FILE  <FILE could not read file>
+LDAP_CANNOT_BIND        <LDAP cannot bind>
+LDAP_SEARCH_FAILED      <LDAP search failed>
+OBSOLETE40              <obsolete error code>
+FUNCTION_NOT_FOUND      <function not found>
+ABORTED_BY_CALLBACK     <aborted by callback>
+BAD_FUNCTION_ARGUMENT   <bad function argument>
+OBSOLETE44              <obsolete error code>
+INTERFACE_FAILED        <CURLOPT_INTERFACE failed>
+OBSOLETE46              <obsolete error code>
+TOO_MANY_REDIRECTS      <too many redirects>
+UNKNOWN_TELNET_OPTION   <unknown TELNET option>
+TELNET_OPTION_SYNTAX    <malformed TELNET option syntax>
+OBSOLETE50              <obsolete error code>
+PEER_FAILED_VERIF       <peer certificate or fingerprint failed>
+GOT_NOTHING             <got nothing>
+SSL_ENGINE_NOTFOUND     <SSL crypto engine not found>
+SSL_ENGINE_SETFAILED    <SSL can not set SSL crypto engine as default>
+SEND_ERROR              <SEND error, failure sending network data>
+RECV_ERROR              <RECV error, failure receiving network data>
+OBSOLETE57              <obsolete error code>
+SSL_CERTPROBLEM         <SSL problem with the local certificate>
 SSL_CIPHER              <SSL CIPHER, could not use specified cipher>
-SSL_CACERT		<SSL CACERT, problem with the CA cert (path?)>
-BAD_CONTENT_ENCODING	<unrecognized transfer encoding>
-LDAP_INVALID_URL	<LDAP invalid url>
-FILESIZE_EXCEEDED	<maximum file size exceeded>
-USE_SSL_FAILED		<requested FTP SSL level failed>
-SEND_FAIL_REWIND	<sending data requires a rewind that failed>
-SSL_ENGINE_INITFAILED	<failed to initialise ENGINE>
-LOGIN_DENIED		<user or password not accepted. failed to login>
-TFTP_NOTFOUND		<file not found on server>
-TFTP_PERM		<permission problem on server>
-REMOTE_DISK_FULL	<out of disk space on server>
-TFTP_ILLEGAL		<illegal TFTP operation>
-TFTP_UNKNOWNID		<unknown transfer ID>
-REMOTE_FILE_EXISTS	<file already exists>
-TFTP_NOSUCHUSER		<no such user>
-CONV_FAILED		<conversion failed>
-CONV_REQD		<caller must register conversion callbacks>
-SSL_CACERT_BADFILE	<could not load CACERT file>
-REMOTE_FILE_NOT_FOUND	<remote file not found>
-SSH			<unspecified error from the SSH layer>
-SSL_SHUTDOWN_FAILED	<failed to shut down the SSL connection>
-AGAIN			<socket not ready, wait and try again>
-SSL_CRL_BADFILE		<could not load CRL file, missing or wrong format>
-SSL_ISSUER_ERROR	<issuer check failed>
-CURL_LAST		<CURLMSG.MSG is out of sync with the source code>
+SSL_CACERT              <SSL CACERT, problem with the CA cert (path?)>
+BAD_CONTENT_ENCODING    <unrecognized transfer encoding>
+LDAP_INVALID_URL        <LDAP invalid url>
+FILESIZE_EXCEEDED       <maximum file size exceeded>
+USE_SSL_FAILED          <requested FTP SSL level failed>
+SEND_FAIL_REWIND        <sending data requires a rewind that failed>
+SSL_ENGINE_INITFAILED   <failed to initialise ENGINE>
+LOGIN_DENIED            <user or password not accepted. failed to login>
+TFTP_NOTFOUND           <file not found on server>
+TFTP_PERM               <permission problem on server>
+REMOTE_DISK_FULL        <out of disk space on server>
+TFTP_ILLEGAL            <illegal TFTP operation>
+TFTP_UNKNOWNID          <unknown transfer ID>
+REMOTE_FILE_EXISTS      <file already exists>
+TFTP_NOSUCHUSER         <no such user>
+CONV_FAILED             <conversion failed>
+CONV_REQD               <caller must register conversion callbacks>
+SSL_CACERT_BADFILE      <could not load CACERT file>
+REMOTE_FILE_NOT_FOUND   <remote file not found>
+SSH                     <unspecified error from the SSH layer>
+SSL_SHUTDOWN_FAILED     <failed to shut down the SSL connection>
+AGAIN                   <socket not ready, wait and try again>
+SSL_CRL_BADFILE         <could not load CRL file, missing or wrong format>
+SSL_ISSUER_ERROR        <issuer check failed>
+CURL_LAST               <CURLMSG.MSG is out of sync with the source code>
 
 .END
diff --git a/packages/vms/curlmsg_vms.h b/packages/vms/curlmsg_vms.h
index bb6470221..29a38db49 100644
--- a/packages/vms/curlmsg_vms.h
+++ b/packages/vms/curlmsg_vms.h
@@ -52,92 +52,92 @@
 */
 
 static const long vms_cond[] =
-	{
-	CURL_OK,
-	CURL_UNSUPPORTED_PROTOCOL,
-	CURL_FAILED_INIT,
-	CURL_URL_MALFORMAT,
-	CURL_OBSOLETE4,
-	CURL_COULDNT_RESOLVE_PROXY,
-	CURL_COULDNT_RESOLVE_HOST,
-	CURL_COULDNT_CONNECT,
-	CURL_WEIRD_SERVER_REPLY,
-	CURL_FTP_ACCESS_DENIED,
-	CURL_OBSOLETE10,
-	CURL_FTP_WEIRD_PASS_REPLY,
-	CURL_OBSOLETE12,
-	CURL_FTP_WEIRD_PASV_REPLY,
-	CURL_FTP_WEIRD_227_FORMAT,
-	CURL_FTP_CANT_GET_HOST,
-	CURL_OBSOLETE16,
-	CURL_FTP_COULDNT_SET_TYPE,
-	CURL_PARTIAL_FILE,
-	CURL_FTP_COULDNT_RETR_FILE,
-	CURL_OBSOLETE20,
-	CURL_QUOTE_ERROR,
-	CURL_HTTP_RETURNED_ERROR,
-	CURL_WRITE_ERROR,
-	CURL_OBSOLETE24,
-	CURL_UPLOAD_FAILED,
-	CURL_READ_ERROR,
-	CURL_OUT_OF_MEMORY,
-	CURL_OPERATION_TIMEOUTED,
-	CURL_OBSOLETE29,
-	CURL_FTP_PORT_FAILED,
-	CURL_FTP_COULDNT_USE_REST,
-	CURL_OBSOLETE32,
-	CURL_RANGE_ERROR,
-	CURL_HTTP_POST_ERROR,
-	CURL_SSL_CONNECT_ERROR,
-	CURL_BAD_DOWNLOAD_RESUME,
-	CURL_FILE_COULDNT_READ_FILE,
-	CURL_LDAP_CANNOT_BIND,
-	CURL_LDAP_SEARCH_FAILED,
-	CURL_OBSOLETE40,
-	CURL_FUNCTION_NOT_FOUND,
-	CURL_ABORTED_BY_CALLBACK,
-	CURL_BAD_FUNCTION_ARGUMENT,
-	CURL_OBSOLETE44,
-	CURL_INTERFACE_FAILED,
-	CURL_OBSOLETE46,
-	CURL_TOO_MANY_REDIRECTS,
-	CURL_UNKNOWN_TELNET_OPTION,
-	CURL_TELNET_OPTION_SYNTAX,
-	CURL_OBSOLETE50,
-	CURL_PEER_FAILED_VERIF,
-	CURL_GOT_NOTHING,
-	CURL_SSL_ENGINE_NOTFOUND,
-	CURL_SSL_ENGINE_SETFAILED,
-	CURL_SEND_ERROR,
-	CURL_RECV_ERROR,
-	CURL_OBSOLETE57,
-	CURL_SSL_CERTPROBLEM,
-	CURL_SSL_CIPHER,
-	CURL_SSL_CACERT,
-	CURL_BAD_CONTENT_ENCODING,
-	CURL_LDAP_INVALID_URL,
-	CURL_FILESIZE_EXCEEDED,
-	CURL_USE_SSL_FAILED,
-	CURL_SEND_FAIL_REWIND,
-	CURL_SSL_ENGINE_INITFAILED,
-	CURL_LOGIN_DENIED,
-	CURL_TFTP_NOTFOUND,
-	CURL_TFTP_PERM,
-	CURL_REMOTE_DISK_FULL,
-	CURL_TFTP_ILLEGAL,
-	CURL_TFTP_UNKNOWNID,
-	CURL_REMOTE_FILE_EXISTS,
-	CURL_TFTP_NOSUCHUSER,
-	CURL_CONV_FAILED,
-	CURL_CONV_REQD,
-	CURL_SSL_CACERT_BADFILE,
-	CURL_REMOTE_FILE_NOT_FOUND,
-	CURL_SSH,
-	CURL_SSL_SHUTDOWN_FAILED,
-	CURL_AGAIN,
-	CURLE_SSL_CRL_BADFILE,
-	CURLE_SSL_ISSUER_ERROR,
-	CURL_CURL_LAST
-	};
+{
+  CURL_OK,
+  CURL_UNSUPPORTED_PROTOCOL,
+  CURL_FAILED_INIT,
+  CURL_URL_MALFORMAT,
+  CURL_OBSOLETE4,
+  CURL_COULDNT_RESOLVE_PROXY,
+  CURL_COULDNT_RESOLVE_HOST,
+  CURL_COULDNT_CONNECT,
+  CURL_WEIRD_SERVER_REPLY,
+  CURL_FTP_ACCESS_DENIED,
+  CURL_OBSOLETE10,
+  CURL_FTP_WEIRD_PASS_REPLY,
+  CURL_OBSOLETE12,
+  CURL_FTP_WEIRD_PASV_REPLY,
+  CURL_FTP_WEIRD_227_FORMAT,
+  CURL_FTP_CANT_GET_HOST,
+  CURL_OBSOLETE16,
+  CURL_FTP_COULDNT_SET_TYPE,
+  CURL_PARTIAL_FILE,
+  CURL_FTP_COULDNT_RETR_FILE,
+  CURL_OBSOLETE20,
+  CURL_QUOTE_ERROR,
+  CURL_HTTP_RETURNED_ERROR,
+  CURL_WRITE_ERROR,
+  CURL_OBSOLETE24,
+  CURL_UPLOAD_FAILED,
+  CURL_READ_ERROR,
+  CURL_OUT_OF_MEMORY,
+  CURL_OPERATION_TIMEOUTED,
+  CURL_OBSOLETE29,
+  CURL_FTP_PORT_FAILED,
+  CURL_FTP_COULDNT_USE_REST,
+  CURL_OBSOLETE32,
+  CURL_RANGE_ERROR,
+  CURL_HTTP_POST_ERROR,
+  CURL_SSL_CONNECT_ERROR,
+  CURL_BAD_DOWNLOAD_RESUME,
+  CURL_FILE_COULDNT_READ_FILE,
+  CURL_LDAP_CANNOT_BIND,
+  CURL_LDAP_SEARCH_FAILED,
+  CURL_OBSOLETE40,
+  CURL_FUNCTION_NOT_FOUND,
+  CURL_ABORTED_BY_CALLBACK,
+  CURL_BAD_FUNCTION_ARGUMENT,
+  CURL_OBSOLETE44,
+  CURL_INTERFACE_FAILED,
+  CURL_OBSOLETE46,
+  CURL_TOO_MANY_REDIRECTS,
+  CURL_UNKNOWN_TELNET_OPTION,
+  CURL_TELNET_OPTION_SYNTAX,
+  CURL_OBSOLETE50,
+  CURL_PEER_FAILED_VERIF,
+  CURL_GOT_NOTHING,
+  CURL_SSL_ENGINE_NOTFOUND,
+  CURL_SSL_ENGINE_SETFAILED,
+  CURL_SEND_ERROR,
+  CURL_RECV_ERROR,
+  CURL_OBSOLETE57,
+  CURL_SSL_CERTPROBLEM,
+  CURL_SSL_CIPHER,
+  CURL_SSL_CACERT,
+  CURL_BAD_CONTENT_ENCODING,
+  CURL_LDAP_INVALID_URL,
+  CURL_FILESIZE_EXCEEDED,
+  CURL_USE_SSL_FAILED,
+  CURL_SEND_FAIL_REWIND,
+  CURL_SSL_ENGINE_INITFAILED,
+  CURL_LOGIN_DENIED,
+  CURL_TFTP_NOTFOUND,
+  CURL_TFTP_PERM,
+  CURL_REMOTE_DISK_FULL,
+  CURL_TFTP_ILLEGAL,
+  CURL_TFTP_UNKNOWNID,
+  CURL_REMOTE_FILE_EXISTS,
+  CURL_TFTP_NOSUCHUSER,
+  CURL_CONV_FAILED,
+  CURL_CONV_REQD,
+  CURL_SSL_CACERT_BADFILE,
+  CURL_REMOTE_FILE_NOT_FOUND,
+  CURL_SSH,
+  CURL_SSL_SHUTDOWN_FAILED,
+  CURL_AGAIN,
+  CURLE_SSL_CRL_BADFILE,
+  CURLE_SSL_ISSUER_ERROR,
+  CURL_CURL_LAST
+};
 
 #endif /* HEADER_CURLMSG_VMS_H */
diff --git a/packages/vms/generate_config_vms_h_curl.com b/packages/vms/generate_config_vms_h_curl.com
index 99a39c844..623cd5fe7 100644
--- a/packages/vms/generate_config_vms_h_curl.com
+++ b/packages/vms/generate_config_vms_h_curl.com
@@ -71,8 +71,8 @@ $!  ssl$* logicals means HP ssl is present
 $!----------------------------------------
 $   if f$trnlnm("ssl$root") .nes. ""
 $   then
-$	nohpssl = 0
-$	hpssl = 1
+$       nohpssl = 0
+$       hpssl = 1
 $   endif
 $!
 $!  HP defines OPENSSL as SSL$INCLUDE as a convenience for linking.
@@ -83,25 +83,25 @@ $!------------------------------------
 $   openssl_lnm = f$trnlnm("OPENSSL")
 $   if (openssl_lnm .nes. "SYS$INCLUDE")
 $   then
-$!	Non HP SSL is installed, default to use it.
-$	nohpssl = 1
-$	hpssl = 0
+$!      Non HP SSL is installed, default to use it.
+$       nohpssl = 1
+$       hpssl = 0
 $   endif
 $!
 $!  Now check to see if hpssl has been specifically disabled
 $!----------------------------------------------------------
 $   if f$locate(",nohpssl,", args_lower) .lt. args_len
 $   then
-$	nohpssl = 1
-$	hpssl = 0
+$       nohpssl = 1
+$       hpssl = 0
 $   endif
 $!
 $!  Finally check to see if hp ssl has been specifically included.
 $!----------------------------------------------------------------
 $   if f$locate(",nohpssl,", args_lower) .lt. args_len
 $   then
-$	nohpssl = 1
-$	hpssl = 0
+$       nohpssl = 1
+$       hpssl = 0
 $   endif
 $endif
 $!
@@ -113,14 +113,14 @@ $   write sys$output "NOTICE:  A LIBIDN port has been detected."
 $   write sys$output " This port of curl for VMS has not been tested with it."
 $   if f$locate(",libidn,", args_lower) .lt. args_len
 $   then
-$	libidn = 1
+$       libidn = 1
 $   endif
 $   if .not. libidn
 $   then
-$	write sys$output " LIBIDN support is not enabled."
-$	write sys$output "Run with the ""libidn"" parameter to attempt to use."
+$       write sys$output " LIBIDN support is not enabled."
+$       write sys$output "Run with the ""libidn"" parameter to attempt to use."
 $   else
-$	write sys$output " Untested LIBIDN support requested."
+$       write sys$output " Untested LIBIDN support requested."
 $   endif
 $endif
 $!
@@ -132,14 +132,14 @@ $   write sys$output "NOTICE:  A LIBSSH2 port has been detected."
 $   write sys$output " This port of curl for VMS has not been tested with it."
 $   if f$locate(",libssh2,", args_lower) .lt. args_len
 $   then
-$	libssh2 = 1
+$       libssh2 = 1
 $   endif
 $   if .not. libssh2
 $   then
-$	write sys$output " LIBSSH2 support is not enabled."
-$	write sys$output "Run with the ""libssh2"" parameter to attempt to use."
+$       write sys$output " LIBSSH2 support is not enabled."
+$       write sys$output "Run with the ""libssh2"" parameter to attempt to use."
 $   else
-$	write sys$output " Untested LIBSSH2 support requested."
+$       write sys$output " Untested LIBSSH2 support requested."
 $   endif
 $endif
 $!
@@ -159,7 +159,7 @@ $then
 $!  If kerberos is installed: sys$share:gss$rtl.exe exists.
 $   if f$search("sys$shsare:gss$rtl.exe") .eqs. ""
 $   then
-$	nokerberos = 1
+$       nokerberos = 1
 $   endif
 $endif
 $!
@@ -170,13 +170,13 @@ $if f$trnlnm("GNV$LIBZSHR") .nes. ""
 $then
 $   if f$locate(",nozlib,", args_lower) .lt. args_len
 $   then
-$	nozlib = 1
+$       nozlib = 1
 $   endif
 $!   if .not. nozlib
 $!   then
-$!	write sys$output " GNV$LIBZSHR support is enabled."
+$!      write sys$output " GNV$LIBZSHR support is enabled."
 $!   else
-$!	write sys$output " GNV$LIBZSHR support is disabled by nozlib."
+$!      write sys$output " GNV$LIBZSHR support is disabled by nozlib."
 $!   endif
 $else
 $   nozlib = 1
@@ -262,9 +262,9 @@ $   write cvh "#undef CURL_DISABLE_LDAP"
 $   write cvh "#endif"
 $   if .not. nossl
 $   then
-$	write cvh "#ifdef CURL_DISABLE_LDAPS"
-$	write cvh "#undef CURL_DISABLE_LDAPS"
-$	write cvh "#endif"
+$       write cvh "#ifdef CURL_DISABLE_LDAPS"
+$       write cvh "#undef CURL_DISABLE_LDAPS"
+$       write cvh "#endif"
 $   endif
 $endif
 $write cvh "#ifdef CURL_DISABLE_LIBCURL_OPTION"
@@ -394,7 +394,7 @@ $   endif
 $endif
 $!
 $!
-$! LibIDN not ported to VMS at this time.
+$! libidn not ported to VMS at this time.
 $! This is for international domain name support.
 $! Allow explicit experimentation.
 $if libidn
@@ -410,7 +410,7 @@ $   write cvh "#endif"
 $endif
 $!
 $!
-$! LibSSH2 not ported to VMS at this time.
+$! libssh2 not ported to VMS at this time.
 $! Allow explicit experimentation.
 $if libssh2
 $then
diff --git a/packages/vms/gnv_link_curl.com b/packages/vms/gnv_link_curl.com
index 247987ae8..552d7d45d 100644
--- a/packages/vms/gnv_link_curl.com
+++ b/packages/vms/gnv_link_curl.com
@@ -400,6 +400,7 @@ $       link'ldebug'/exe=[.src]curl.exe/dsf=[.src]curl.dsf -
            [.src]curl-tool_bname.o, [.src]curl-tool_cb_dbg.o, -
            [.src]curl-tool_cb_hdr.o, [.src]curl-tool_cb_prg.o, -
            [.src]curl-tool_cb_rea.o, [.src]curl-tool_cb_see.o, -
+           [.src]curl-tool_cb_soc.o, -
            [.src]curl-tool_cb_wrt.o, [.src]curl-tool_cfgable.o, -
            [.src]curl-tool_convert.o, [.src]curl-tool_dirhie.o, -
            [.src]curl-tool_doswin.o, [.src]curl-tool_easysrc.o, -
diff --git a/packages/vms/readme b/packages/vms/readme
index 0bb61663c..eaf23e942 100644
--- a/packages/vms/readme
+++ b/packages/vms/readme
@@ -138,7 +138,7 @@ pcsi_product_gnv_curl.com
 readme.                 This file.
 
 report_openssl_version.c
-                        Program to check that the openssl version is new
+                        Program to check that the OpenSSL version is new
                         enough for building a shared libcurl image.
 
 setup_gnv_curl_build.com
diff --git a/packages/vms/report_openssl_version.c b/packages/vms/report_openssl_version.c
index 64e1ee052..158303011 100644
--- a/packages/vms/report_openssl_version.c
+++ b/packages/vms/report_openssl_version.c
@@ -1,6 +1,6 @@
 /* File: report_openssl_version.c
  *
- * This file dynamically loads the openssl shared image to report the
+ * This file dynamically loads the OpenSSL shared image to report the
  * version string.
  *
  * It will optionally place that version string in a DCL symbol.
diff --git a/post_update.sh b/post_update.sh
index 9c33161ce..756f8a697 100755
--- a/post_update.sh
+++ b/post_update.sh
@@ -1,10 +1,105 @@
 #!/bin/bash
 
-# $1 Path to the new version.
-# $2 Path to the old version.
+set -e
 
-rm $1/packages/Android/Android.mk
-cp -a -n $2/androidconfigure $1/
-cp -a -n $2/local-configure.patch $1/
+if [[ "${TARGET_PRODUCT}" != "aosp_arm" ]]; then
+  # Some of the include paths below assume that this is an arm 32bit configure
+  # run.
+  echo "Run 'lunch aosp_arm-trunk_staging-eng'." >&2
+  exit 1
+fi
 
-echo "Please run androidconfigure to update curl_config.h."
+m ndk
+
+T="${ANDROID_BUILD_TOP}"
+cd $(dirname "$0")
+
+# Build all the dependencies we'll need, so we can find them under
+# /system/lib in the out directory.
+mm
+
+HOST="arm-linux-androideabi"
+CLANG_VERSION="$(exec ${T}/build/soong/scripts/get_clang_version.py)"
+export CC="${T}/prebuilts/clang/host/linux-x86/${CLANG_VERSION}/bin/clang"
+export LD="${T}/prebuilts/clang/host/linux-x86/${CLANG_VERSION}/bin/lld"
+
+CFLAGS=(
+  # We don't have an NDK sysroot prebuilt in AOSP, so we'll have use
+  # soong's.
+  "--sysroot ${T}/out/soong/ndk/sysroot/"
+  # We also need zlib. (We don't have to do anything for boringssl here,
+  # because we provide that path directly on the configure command line.)
+  "-I${T}/external/zlib/"
+  # We don't have target-specific clang binaries like the NDK, so provide
+  # a target. The "34" here is arbitrary.
+  "--target=armv7a-linux-androideabi34"
+)
+CFLAGS="${CFLAGS[@]}"
+
+LDFLAGS=(
+  # We need the device zlib and openssl/boringssl libraries, so tell ld
+  # where they are.
+  "-L${ANDROID_PRODUCT_OUT}/system/lib/"
+)
+LDFLAGS="${LDFLAGS[@]}"
+
+CONFIGURE_ARGS=(
+  --host="${HOST}"
+  CFLAGS="${CFLAGS}"
+  CPPFLAGS="${CFLAGS}"
+  LDFLAGS="${LDFLAGS}"
+
+  # Disable NTLM delegation to winbind's ntlm_auth.
+  --disable-ntlm-wb
+
+  ### Disable many protocols unused in Android systems:
+  --disable-telnet
+  --disable-tftp
+  --disable-smb
+  --disable-gopher
+
+  # Disable FTP and FTPS support.
+  --disable-ftp
+
+  # Disable LDAP and LDAPS support.
+  --disable-ldap
+  --disable-ldaps
+
+  # Disable mail protocols (IMAP, POP3).
+  --disable-pop3
+  --disable-imap
+  --disable-smtp
+
+  # Disable RTSP support (RFC 2326 / 7826).
+  --disable-rtsp
+
+  # Disable DICT support (RFC 2229).
+  --disable-dict
+
+  ### Enable HTTP and FILE explicitly. These are enabled by default but
+  # listed here as documentation.
+  --enable-http
+  --enable-file
+  --enable-proxy
+
+  # Enabled IPv6.
+  --enable-ipv6
+
+  --with-ssl="${T}/external/boringssl"
+  --with-zlib
+  --with-ca-path="/system/etc/security/cacerts"
+  #Configure script skips the /dev/urandom detection when cross-compiling.
+  --with-random="/dev/urandom"
+
+  #While bionic has this, the host libcs don't.
+  ac_cv_header_netinet_in6_h=no
+)
+
+# Show the commands on the terminal.
+set -x
+
+./buildconf
+./configure "${CONFIGURE_ARGS[@]}"
+
+# Apply local changes to the default configure output.
+patch -p1 --no-backup-if-mismatch < local-configure.patch
diff --git a/projects/README.md b/projects/README.md
index 4c4ea6ec6..0e77f50ef 100644
--- a/projects/README.md
+++ b/projects/README.md
@@ -97,40 +97,40 @@ use `VC10\curl-all.sln` to build curl and libcurl.
 ## Running DLL based configurations
 
 If you are a developer and plan to run the curl tool from Visual Studio with
-any third-party libraries (such as OpenSSL, wolfSSL or LibSSH2) then you will
+any third-party libraries (such as OpenSSL, wolfSSL or libssh2) then you will
 need to add the search path of these DLLs to the configuration's PATH
 environment. To do that:
 
  1. Open the 'curl-all.sln' or 'curl.sln' solutions
  2. Right-click on the 'curl' project and select Properties
  3. Navigate to 'Configuration Properties > Debugging > Environment'
- 4. Add `PATH='Path to DLL';C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem`
+ 4. Add `PATH='Path to DLL';C:\Windows\System32;C:\Windows;C:\Windows\System32\Wbem`
 
 ... where 'Path to DLL` is the configuration specific path. For example the
 following configurations in Visual Studio 2010 might be:
 
 DLL Debug - DLL OpenSSL (Win32):
 
-    PATH=..\..\..\..\..\openssl\build\Win32\VC10\DLL Debug;C:\Windows\system32;
+    PATH=..\..\..\..\..\openssl\build\Win32\VC10\DLL Debug;C:\Windows\System32;
     C:\Windows;C:\Windows\System32\Wbem
 
 DLL Debug - DLL OpenSSL (x64):
 
-    PATH=..\..\..\..\..\openssl\build\Win64\VC10\DLL Debug;C:\Windows\system32;
+    PATH=..\..\..\..\..\openssl\build\Win64\VC10\DLL Debug;C:\Windows\System32;
     C:\Windows;C:\Windows\System32\Wbem
 
 DLL Debug - DLL wolfSSL (Win32):
 
-    PATH=..\..\..\..\..\wolfssl\build\Win32\VC10\DLL Debug;C:\Windows\system32;
+    PATH=..\..\..\..\..\wolfssl\build\Win32\VC10\DLL Debug;C:\Windows\System32;
     C:\Windows;C:\Windows\System32\Wbem
 
 DLL Debug - DLL wolfSSL (x64):
 
-    PATH=..\..\..\..\..\wolfssl\build\Win64\VC10\DLL Debug;C:\Windows\system32;
+    PATH=..\..\..\..\..\wolfssl\build\Win64\VC10\DLL Debug;C:\Windows\System32;
     C:\Windows;C:\Windows\System32\Wbem
 
 If you are using a configuration that uses multiple third-party library DLLs
-(such as DLL Debug - DLL OpenSSL - DLL LibSSH2) then 'Path to DLL' will need
+(such as DLL Debug - DLL OpenSSL - DLL libssh2) then 'Path to DLL' will need
 to contain the path to both of these.
 
 ## Notes
diff --git a/projects/Windows/VC10/lib/libcurl.sln b/projects/Windows/VC10/lib/libcurl.sln
index 15461ef9a..a8c8a56cd 100644
--- a/projects/Windows/VC10/lib/libcurl.sln
+++ b/projects/Windows/VC10/lib/libcurl.sln
@@ -4,8 +4,8 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libcurl", "libcurl.vcxproj"
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32 = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		DLL Debug - DLL OpenSSL - DLL LibSSH2|x64 = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
+		DLL Debug - DLL OpenSSL - DLL libssh2|Win32 = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		DLL Debug - DLL OpenSSL - DLL libssh2|x64 = DLL Debug - DLL OpenSSL - DLL libssh2|x64
 		DLL Debug - DLL OpenSSL|Win32 = DLL Debug - DLL OpenSSL|Win32
 		DLL Debug - DLL OpenSSL|x64 = DLL Debug - DLL OpenSSL|x64
 		DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32 = DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32
@@ -16,8 +16,8 @@ Global
 		DLL Debug - DLL wolfSSL|x64 = DLL Debug - DLL wolfSSL|x64
 		DLL Debug|Win32 = DLL Debug|Win32
 		DLL Debug|x64 = DLL Debug|x64
-		DLL Release - DLL OpenSSL - DLL LibSSH2|Win32 = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		DLL Release - DLL OpenSSL - DLL LibSSH2|x64 = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
+		DLL Release - DLL OpenSSL - DLL libssh2|Win32 = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		DLL Release - DLL OpenSSL - DLL libssh2|x64 = DLL Release - DLL OpenSSL - DLL libssh2|x64
 		DLL Release - DLL OpenSSL|Win32 = DLL Release - DLL OpenSSL|Win32
 		DLL Release - DLL OpenSSL|x64 = DLL Release - DLL OpenSSL|x64
 		DLL Release - DLL Windows SSPI - DLL WinIDN|Win32 = DLL Release - DLL Windows SSPI - DLL WinIDN|Win32
@@ -28,32 +28,32 @@ Global
 		DLL Release - DLL wolfSSL|x64 = DLL Release - DLL wolfSSL|x64
 		DLL Release|Win32 = DLL Release|Win32
 		DLL Release|x64 = DLL Release|x64
-		LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32 = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		LIB Debug - DLL OpenSSL - DLL LibSSH2|x64 = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
+		LIB Debug - DLL OpenSSL - DLL libssh2|Win32 = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		LIB Debug - DLL OpenSSL - DLL libssh2|x64 = LIB Debug - DLL OpenSSL - DLL libssh2|x64
 		LIB Debug - DLL OpenSSL|Win32 = LIB Debug - DLL OpenSSL|Win32
 		LIB Debug - DLL OpenSSL|x64 = LIB Debug - DLL OpenSSL|x64
 		LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32 = LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32
 		LIB Debug - DLL Windows SSPI - DLL WinIDN|x64 = LIB Debug - DLL Windows SSPI - DLL WinIDN|x64
 		LIB Debug - DLL Windows SSPI|Win32 = LIB Debug - DLL Windows SSPI|Win32
 		LIB Debug - DLL Windows SSPI|x64 = LIB Debug - DLL Windows SSPI|x64
-		LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32 = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		LIB Debug - LIB OpenSSL - LIB LibSSH2|x64 = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
+		LIB Debug - LIB OpenSSL - LIB libssh2|Win32 = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		LIB Debug - LIB OpenSSL - LIB libssh2|x64 = LIB Debug - LIB OpenSSL - LIB libssh2|x64
 		LIB Debug - LIB OpenSSL|Win32 = LIB Debug - LIB OpenSSL|Win32
 		LIB Debug - LIB OpenSSL|x64 = LIB Debug - LIB OpenSSL|x64
 		LIB Debug - LIB wolfSSL|Win32 = LIB Debug - LIB wolfSSL|Win32
 		LIB Debug - LIB wolfSSL|x64 = LIB Debug - LIB wolfSSL|x64
 		LIB Debug|Win32 = LIB Debug|Win32
 		LIB Debug|x64 = LIB Debug|x64
-		LIB Release - DLL OpenSSL - DLL LibSSH2|Win32 = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		LIB Release - DLL OpenSSL - DLL LibSSH2|x64 = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
+		LIB Release - DLL OpenSSL - DLL libssh2|Win32 = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		LIB Release - DLL OpenSSL - DLL libssh2|x64 = LIB Release - DLL OpenSSL - DLL libssh2|x64
 		LIB Release - DLL OpenSSL|Win32 = LIB Release - DLL OpenSSL|Win32
 		LIB Release - DLL OpenSSL|x64 = LIB Release - DLL OpenSSL|x64
 		LIB Release - DLL Windows SSPI - DLL WinIDN|Win32 = LIB Release - DLL Windows SSPI - DLL WinIDN|Win32
 		LIB Release - DLL Windows SSPI - DLL WinIDN|x64 = LIB Release - DLL Windows SSPI - DLL WinIDN|x64
 		LIB Release - DLL Windows SSPI|Win32 = LIB Release - DLL Windows SSPI|Win32
 		LIB Release - DLL Windows SSPI|x64 = LIB Release - DLL Windows SSPI|x64
-		LIB Release - LIB OpenSSL - LIB LibSSH2|Win32 = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		LIB Release - LIB OpenSSL - LIB LibSSH2|x64 = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
+		LIB Release - LIB OpenSSL - LIB libssh2|Win32 = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		LIB Release - LIB OpenSSL - LIB libssh2|x64 = LIB Release - LIB OpenSSL - LIB libssh2|x64
 		LIB Release - LIB OpenSSL|Win32 = LIB Release - LIB OpenSSL|Win32
 		LIB Release - LIB OpenSSL|x64 = LIB Release - LIB OpenSSL|x64
 		LIB Release - LIB wolfSSL|Win32 = LIB Release - LIB wolfSSL|Win32
@@ -62,10 +62,10 @@ Global
 		LIB Release|x64 = LIB Release|x64
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL libssh2|Win32.Build.0 = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = DLL Debug - DLL OpenSSL - DLL libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL libssh2|x64.Build.0 = DLL Debug - DLL OpenSSL - DLL libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL|Win32.ActiveCfg = DLL Debug - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL|Win32.Build.0 = DLL Debug - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL|x64.ActiveCfg = DLL Debug - DLL OpenSSL|x64
@@ -86,10 +86,10 @@ Global
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug|Win32.Build.0 = DLL Debug|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug|x64.ActiveCfg = DLL Debug|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug|x64.Build.0 = DLL Debug|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL libssh2|Win32.Build.0 = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = DLL Release - DLL OpenSSL - DLL libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL libssh2|x64.Build.0 = DLL Release - DLL OpenSSL - DLL libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL|Win32.ActiveCfg = DLL Release - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL|Win32.Build.0 = DLL Release - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL|x64.ActiveCfg = DLL Release - DLL OpenSSL|x64
@@ -110,10 +110,10 @@ Global
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release|Win32.Build.0 = DLL Release|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release|x64.ActiveCfg = DLL Release|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release|x64.Build.0 = DLL Release|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL libssh2|Win32.Build.0 = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = LIB Debug - DLL OpenSSL - DLL libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL libssh2|x64.Build.0 = LIB Debug - DLL OpenSSL - DLL libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL|Win32.ActiveCfg = LIB Debug - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL|Win32.Build.0 = LIB Debug - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL|x64.ActiveCfg = LIB Debug - DLL OpenSSL|x64
@@ -126,10 +126,10 @@ Global
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL Windows SSPI|Win32.Build.0 = LIB Debug - DLL Windows SSPI|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL Windows SSPI|x64.ActiveCfg = LIB Debug - DLL Windows SSPI|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL Windows SSPI|x64.Build.0 = LIB Debug - DLL Windows SSPI|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32.ActiveCfg = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32.Build.0 = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB LibSSH2|x64.ActiveCfg = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB LibSSH2|x64.Build.0 = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB libssh2|Win32.ActiveCfg = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB libssh2|Win32.Build.0 = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB libssh2|x64.ActiveCfg = LIB Debug - LIB OpenSSL - LIB libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB libssh2|x64.Build.0 = LIB Debug - LIB OpenSSL - LIB libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL|Win32.ActiveCfg = LIB Debug - LIB OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL|Win32.Build.0 = LIB Debug - LIB OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL|x64.ActiveCfg = LIB Debug - LIB OpenSSL|x64
@@ -142,10 +142,10 @@ Global
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug|Win32.Build.0 = LIB Debug|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug|x64.ActiveCfg = LIB Debug|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug|x64.Build.0 = LIB Debug|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL libssh2|Win32.Build.0 = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = LIB Release - DLL OpenSSL - DLL libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL libssh2|x64.Build.0 = LIB Release - DLL OpenSSL - DLL libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL|Win32.ActiveCfg = LIB Release - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL|Win32.Build.0 = LIB Release - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL|x64.ActiveCfg = LIB Release - DLL OpenSSL|x64
@@ -158,10 +158,10 @@ Global
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL Windows SSPI|Win32.Build.0 = LIB Release - DLL Windows SSPI|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL Windows SSPI|x64.ActiveCfg = LIB Release - DLL Windows SSPI|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL Windows SSPI|x64.Build.0 = LIB Release - DLL Windows SSPI|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB LibSSH2|Win32.ActiveCfg = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB LibSSH2|Win32.Build.0 = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB LibSSH2|x64.ActiveCfg = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB LibSSH2|x64.Build.0 = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB libssh2|Win32.ActiveCfg = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB libssh2|Win32.Build.0 = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB libssh2|x64.ActiveCfg = LIB Release - LIB OpenSSL - LIB libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB libssh2|x64.Build.0 = LIB Release - LIB OpenSSL - LIB libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL|Win32.ActiveCfg = LIB Release - LIB OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL|Win32.Build.0 = LIB Release - LIB OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL|x64.ActiveCfg = LIB Release - LIB OpenSSL|x64
diff --git a/projects/Windows/VC10/lib/libcurl.tmpl b/projects/Windows/VC10/lib/libcurl.tmpl
index 7a37c270f..1cc2453f2 100644
--- a/projects/Windows/VC10/lib/libcurl.tmpl
+++ b/projects/Windows/VC10/lib/libcurl.tmpl
@@ -9,12 +9,12 @@
       <Configuration>DLL Debug - DLL wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>DLL Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>DLL Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>DLL Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>DLL Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="DLL Debug - DLL OpenSSL|Win32">
@@ -57,12 +57,12 @@
       <Configuration>DLL Release - DLL wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>DLL Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>DLL Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>DLL Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>DLL Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="DLL Release - DLL OpenSSL|Win32">
@@ -97,12 +97,12 @@
       <Configuration>DLL Release</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>LIB Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>LIB Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>LIB Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>LIB Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Debug - DLL OpenSSL|Win32">
@@ -137,12 +137,12 @@
       <Configuration>LIB Debug - LIB wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32">
-      <Configuration>LIB Debug - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB libssh2|Win32">
+      <Configuration>LIB Debug - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB LibSSH2|x64">
-      <Configuration>LIB Debug - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB libssh2|x64">
+      <Configuration>LIB Debug - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Debug - LIB OpenSSL|Win32">
@@ -161,12 +161,12 @@
       <Configuration>LIB Debug</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>LIB Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>LIB Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>LIB Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>LIB Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Release - DLL OpenSSL|Win32">
@@ -201,12 +201,12 @@
       <Configuration>LIB Release - LIB wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB LibSSH2|Win32">
-      <Configuration>LIB Release - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB libssh2|Win32">
+      <Configuration>LIB Release - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB LibSSH2|x64">
-      <Configuration>LIB Release - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB libssh2|x64">
+      <Configuration>LIB Release - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Release - LIB OpenSSL|Win32">
@@ -231,7 +231,7 @@
     <RootNamespace>libcurl</RootNamespace>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -251,7 +251,7 @@
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -261,7 +261,7 @@
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -281,7 +281,7 @@
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -291,12 +291,12 @@
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -371,7 +371,7 @@
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -391,7 +391,7 @@
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -401,7 +401,7 @@
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -421,7 +421,7 @@
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -431,12 +431,12 @@
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -514,7 +514,7 @@
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|Win32'" Label="PropertySheets">
@@ -526,13 +526,13 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI - DLL WinIDN|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'" Label="PropertySheets">
@@ -544,16 +544,16 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|Win32'" Label="PropertySheets">
@@ -598,7 +598,7 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL wolfSSL|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'" Label="PropertySheets">
@@ -610,13 +610,13 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI - DLL WinIDN|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'" Label="PropertySheets">
@@ -628,16 +628,16 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|x64'" Label="PropertySheets">
@@ -761,26 +761,26 @@
     <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|x64'">$(OutDir)lib\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|x64'">false</LinkIncremental>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)lib\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)lib\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)lib\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)lib\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">$(OutDir)lib\</IntDir>
@@ -793,18 +793,18 @@
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|Win32'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI - DLL WinIDN|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI|Win32'">$(OutDir)lib\</IntDir>
@@ -817,18 +817,18 @@
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|Win32'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">$(OutDir)lib\</IntDir>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL wolfSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL wolfSSL|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI|x64'">$(ProjectName)d</TargetName>
@@ -839,16 +839,16 @@
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB wolfSSL|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">$(ProjectName)d</TargetName>
   </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug|Win32'">
     <Midl>
@@ -1684,7 +1684,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <MkTypLibCompatible>true</MkTypLibCompatible>
@@ -1718,7 +1718,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <MkTypLibCompatible>true</MkTypLibCompatible>
@@ -1751,7 +1751,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <MkTypLibCompatible>true</MkTypLibCompatible>
@@ -1783,7 +1783,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <MkTypLibCompatible>true</MkTypLibCompatible>
@@ -1857,7 +1857,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">
     <ClCompile>
       <Optimization>Disabled</Optimization>
       <AdditionalIncludeDirectories>..\..\..\..\include;..\..\..\..\lib;..\..\..\..\..\openssl\include\..\build\Win32\VC10\DLL Debug\include;..\..\..\..\..\openssl\include;..\..\..\..\..\libssh2\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
@@ -1877,7 +1877,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
     </Midl>
@@ -2029,7 +2029,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">
     <ClCompile>
       <Optimization>Disabled</Optimization>
       <AdditionalIncludeDirectories>..\..\..\..\include;..\..\..\..\lib;..\..\..\..\..\openssl\include\..\build\Win32\VC10\LIB Debug\include;..\..\..\..\..\openssl\include;..\..\..\..\..\libssh2\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
@@ -2049,7 +2049,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
     </Midl>
@@ -2115,7 +2115,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">
     <ClCompile>
       <Optimization>MaxSpeed</Optimization>
       <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
@@ -2135,7 +2135,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
     </Midl>
@@ -2287,7 +2287,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">
     <ClCompile>
       <Optimization>MaxSpeed</Optimization>
       <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
@@ -2307,7 +2307,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
     </Midl>
@@ -2350,4 +2350,4 @@ CURL_LIB_RC_FILES
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
   </ImportGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/projects/Windows/VC10/lib/libcurl.vcxproj.filters b/projects/Windows/VC10/lib/libcurl.vcxproj.filters
index 4d6341d74..d2b9907aa 100644
--- a/projects/Windows/VC10/lib/libcurl.vcxproj.filters
+++ b/projects/Windows/VC10/lib/libcurl.vcxproj.filters
@@ -14,4 +14,4 @@
       <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
     </Filter>
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/projects/Windows/VC10/src/curl.sln b/projects/Windows/VC10/src/curl.sln
index 131f27b7a..9b8f96a25 100644
--- a/projects/Windows/VC10/src/curl.sln
+++ b/projects/Windows/VC10/src/curl.sln
@@ -4,8 +4,8 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "curl", "curl.vcxproj", "{52
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32 = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		DLL Debug - DLL OpenSSL - DLL LibSSH2|x64 = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
+		DLL Debug - DLL OpenSSL - DLL libssh2|Win32 = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		DLL Debug - DLL OpenSSL - DLL libssh2|x64 = DLL Debug - DLL OpenSSL - DLL libssh2|x64
 		DLL Debug - DLL OpenSSL|Win32 = DLL Debug - DLL OpenSSL|Win32
 		DLL Debug - DLL OpenSSL|x64 = DLL Debug - DLL OpenSSL|x64
 		DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32 = DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32
@@ -16,8 +16,8 @@ Global
 		DLL Debug - DLL wolfSSL|x64 = DLL Debug - DLL wolfSSL|x64
 		DLL Debug|Win32 = DLL Debug|Win32
 		DLL Debug|x64 = DLL Debug|x64
-		DLL Release - DLL OpenSSL - DLL LibSSH2|Win32 = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		DLL Release - DLL OpenSSL - DLL LibSSH2|x64 = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
+		DLL Release - DLL OpenSSL - DLL libssh2|Win32 = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		DLL Release - DLL OpenSSL - DLL libssh2|x64 = DLL Release - DLL OpenSSL - DLL libssh2|x64
 		DLL Release - DLL OpenSSL|Win32 = DLL Release - DLL OpenSSL|Win32
 		DLL Release - DLL OpenSSL|x64 = DLL Release - DLL OpenSSL|x64
 		DLL Release - DLL Windows SSPI - DLL WinIDN|Win32 = DLL Release - DLL Windows SSPI - DLL WinIDN|Win32
@@ -28,32 +28,32 @@ Global
 		DLL Release - DLL wolfSSL|x64 = DLL Release - DLL wolfSSL|x64
 		DLL Release|Win32 = DLL Release|Win32
 		DLL Release|x64 = DLL Release|x64
-		LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32 = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		LIB Debug - DLL OpenSSL - DLL LibSSH2|x64 = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
+		LIB Debug - DLL OpenSSL - DLL libssh2|Win32 = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		LIB Debug - DLL OpenSSL - DLL libssh2|x64 = LIB Debug - DLL OpenSSL - DLL libssh2|x64
 		LIB Debug - DLL OpenSSL|Win32 = LIB Debug - DLL OpenSSL|Win32
 		LIB Debug - DLL OpenSSL|x64 = LIB Debug - DLL OpenSSL|x64
 		LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32 = LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32
 		LIB Debug - DLL Windows SSPI - DLL WinIDN|x64 = LIB Debug - DLL Windows SSPI - DLL WinIDN|x64
 		LIB Debug - DLL Windows SSPI|Win32 = LIB Debug - DLL Windows SSPI|Win32
 		LIB Debug - DLL Windows SSPI|x64 = LIB Debug - DLL Windows SSPI|x64
-		LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32 = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		LIB Debug - LIB OpenSSL - LIB LibSSH2|x64 = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
+		LIB Debug - LIB OpenSSL - LIB libssh2|Win32 = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		LIB Debug - LIB OpenSSL - LIB libssh2|x64 = LIB Debug - LIB OpenSSL - LIB libssh2|x64
 		LIB Debug - LIB OpenSSL|Win32 = LIB Debug - LIB OpenSSL|Win32
 		LIB Debug - LIB OpenSSL|x64 = LIB Debug - LIB OpenSSL|x64
 		LIB Debug - LIB wolfSSL|Win32 = LIB Debug - LIB wolfSSL|Win32
 		LIB Debug - LIB wolfSSL|x64 = LIB Debug - LIB wolfSSL|x64
 		LIB Debug|Win32 = LIB Debug|Win32
 		LIB Debug|x64 = LIB Debug|x64
-		LIB Release - DLL OpenSSL - DLL LibSSH2|Win32 = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		LIB Release - DLL OpenSSL - DLL LibSSH2|x64 = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
+		LIB Release - DLL OpenSSL - DLL libssh2|Win32 = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		LIB Release - DLL OpenSSL - DLL libssh2|x64 = LIB Release - DLL OpenSSL - DLL libssh2|x64
 		LIB Release - DLL OpenSSL|Win32 = LIB Release - DLL OpenSSL|Win32
 		LIB Release - DLL OpenSSL|x64 = LIB Release - DLL OpenSSL|x64
 		LIB Release - DLL Windows SSPI - DLL WinIDN|Win32 = LIB Release - DLL Windows SSPI - DLL WinIDN|Win32
 		LIB Release - DLL Windows SSPI - DLL WinIDN|x64 = LIB Release - DLL Windows SSPI - DLL WinIDN|x64
 		LIB Release - DLL Windows SSPI|Win32 = LIB Release - DLL Windows SSPI|Win32
 		LIB Release - DLL Windows SSPI|x64 = LIB Release - DLL Windows SSPI|x64
-		LIB Release - LIB OpenSSL - LIB LibSSH2|Win32 = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		LIB Release - LIB OpenSSL - LIB LibSSH2|x64 = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
+		LIB Release - LIB OpenSSL - LIB libssh2|Win32 = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		LIB Release - LIB OpenSSL - LIB libssh2|x64 = LIB Release - LIB OpenSSL - LIB libssh2|x64
 		LIB Release - LIB OpenSSL|Win32 = LIB Release - LIB OpenSSL|Win32
 		LIB Release - LIB OpenSSL|x64 = LIB Release - LIB OpenSSL|x64
 		LIB Release - LIB wolfSSL|Win32 = LIB Release - LIB wolfSSL|Win32
@@ -62,10 +62,10 @@ Global
 		LIB Release|x64 = LIB Release|x64
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL libssh2|Win32.Build.0 = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = DLL Debug - DLL OpenSSL - DLL libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL libssh2|x64.Build.0 = DLL Debug - DLL OpenSSL - DLL libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL|Win32.ActiveCfg = DLL Debug - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL|Win32.Build.0 = DLL Debug - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL|x64.ActiveCfg = DLL Debug - DLL OpenSSL|x64
@@ -86,10 +86,10 @@ Global
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug|Win32.Build.0 = DLL Debug|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug|x64.ActiveCfg = DLL Debug|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug|x64.Build.0 = DLL Debug|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL libssh2|Win32.Build.0 = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = DLL Release - DLL OpenSSL - DLL libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL libssh2|x64.Build.0 = DLL Release - DLL OpenSSL - DLL libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL|Win32.ActiveCfg = DLL Release - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL|Win32.Build.0 = DLL Release - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL|x64.ActiveCfg = DLL Release - DLL OpenSSL|x64
@@ -110,10 +110,10 @@ Global
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release|Win32.Build.0 = DLL Release|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release|x64.ActiveCfg = DLL Release|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release|x64.Build.0 = DLL Release|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL libssh2|Win32.Build.0 = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = LIB Debug - DLL OpenSSL - DLL libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL libssh2|x64.Build.0 = LIB Debug - DLL OpenSSL - DLL libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL|Win32.ActiveCfg = LIB Debug - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL|Win32.Build.0 = LIB Debug - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL|x64.ActiveCfg = LIB Debug - DLL OpenSSL|x64
@@ -126,10 +126,10 @@ Global
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL Windows SSPI|Win32.Build.0 = LIB Debug - DLL Windows SSPI|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL Windows SSPI|x64.ActiveCfg = LIB Debug - DLL Windows SSPI|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL Windows SSPI|x64.Build.0 = LIB Debug - DLL Windows SSPI|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32.ActiveCfg = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32.Build.0 = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB LibSSH2|x64.ActiveCfg = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB LibSSH2|x64.Build.0 = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB libssh2|Win32.ActiveCfg = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB libssh2|Win32.Build.0 = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB libssh2|x64.ActiveCfg = LIB Debug - LIB OpenSSL - LIB libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB libssh2|x64.Build.0 = LIB Debug - LIB OpenSSL - LIB libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL|Win32.ActiveCfg = LIB Debug - LIB OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL|Win32.Build.0 = LIB Debug - LIB OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL|x64.ActiveCfg = LIB Debug - LIB OpenSSL|x64
@@ -142,10 +142,10 @@ Global
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug|Win32.Build.0 = LIB Debug|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug|x64.ActiveCfg = LIB Debug|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug|x64.Build.0 = LIB Debug|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL libssh2|Win32.Build.0 = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = LIB Release - DLL OpenSSL - DLL libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL libssh2|x64.Build.0 = LIB Release - DLL OpenSSL - DLL libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL|Win32.ActiveCfg = LIB Release - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL|Win32.Build.0 = LIB Release - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL|x64.ActiveCfg = LIB Release - DLL OpenSSL|x64
@@ -158,10 +158,10 @@ Global
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL Windows SSPI|Win32.Build.0 = LIB Release - DLL Windows SSPI|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL Windows SSPI|x64.ActiveCfg = LIB Release - DLL Windows SSPI|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL Windows SSPI|x64.Build.0 = LIB Release - DLL Windows SSPI|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB LibSSH2|Win32.ActiveCfg = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB LibSSH2|Win32.Build.0 = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB LibSSH2|x64.ActiveCfg = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB LibSSH2|x64.Build.0 = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB libssh2|Win32.ActiveCfg = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB libssh2|Win32.Build.0 = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB libssh2|x64.ActiveCfg = LIB Release - LIB OpenSSL - LIB libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB libssh2|x64.Build.0 = LIB Release - LIB OpenSSL - LIB libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL|Win32.ActiveCfg = LIB Release - LIB OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL|Win32.Build.0 = LIB Release - LIB OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL|x64.ActiveCfg = LIB Release - LIB OpenSSL|x64
diff --git a/projects/Windows/VC10/src/curl.tmpl b/projects/Windows/VC10/src/curl.tmpl
index 5e24977a4..074ea2431 100644
--- a/projects/Windows/VC10/src/curl.tmpl
+++ b/projects/Windows/VC10/src/curl.tmpl
@@ -9,12 +9,12 @@
       <Configuration>DLL Debug - DLL wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>DLL Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>DLL Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>DLL Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>DLL Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="DLL Debug - DLL OpenSSL|Win32">
@@ -57,12 +57,12 @@
       <Configuration>DLL Release - DLL wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>DLL Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>DLL Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>DLL Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>DLL Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="DLL Release - DLL OpenSSL|Win32">
@@ -97,12 +97,12 @@
       <Configuration>DLL Release</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>LIB Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>LIB Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>LIB Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>LIB Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Debug - DLL OpenSSL|Win32">
@@ -137,12 +137,12 @@
       <Configuration>LIB Debug - LIB wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32">
-      <Configuration>LIB Debug - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB libssh2|Win32">
+      <Configuration>LIB Debug - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB LibSSH2|x64">
-      <Configuration>LIB Debug - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB libssh2|x64">
+      <Configuration>LIB Debug - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Debug - LIB OpenSSL|Win32">
@@ -161,12 +161,12 @@
       <Configuration>LIB Debug</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>LIB Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>LIB Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>LIB Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>LIB Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Release - DLL OpenSSL|Win32">
@@ -201,12 +201,12 @@
       <Configuration>LIB Release - LIB wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB LibSSH2|Win32">
-      <Configuration>LIB Release - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB libssh2|Win32">
+      <Configuration>LIB Release - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB LibSSH2|x64">
-      <Configuration>LIB Release - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB libssh2|x64">
+      <Configuration>LIB Release - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Release - LIB OpenSSL|Win32">
@@ -251,12 +251,12 @@
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -271,12 +271,12 @@
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -291,12 +291,12 @@
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -391,12 +391,12 @@
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -411,12 +411,12 @@
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -431,12 +431,12 @@
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -526,10 +526,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|Win32'" Label="PropertySheets">
@@ -538,10 +538,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|Win32'" Label="PropertySheets">
@@ -550,10 +550,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|Win32'" Label="PropertySheets">
@@ -610,10 +610,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'" Label="PropertySheets">
@@ -622,10 +622,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'" Label="PropertySheets">
@@ -634,10 +634,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|x64'" Label="PropertySheets">
@@ -769,18 +769,18 @@
     <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|x64'">$(OutDir)src\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|x64'">false</LinkIncremental>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">$(OutDir)src\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">false</LinkIncremental>
@@ -793,18 +793,18 @@
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">$(OutDir)src\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">false</LinkIncremental>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">$(OutDir)src\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">false</LinkIncremental>
@@ -817,18 +817,18 @@
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">$(OutDir)src\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC10\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'">..\..\..\..\build\Win32\VC10\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">$(OutDir)src\</IntDir>
@@ -859,8 +859,8 @@
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL wolfSSL|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI|x64'">$(ProjectName)d</TargetName>
@@ -871,41 +871,41 @@
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB wolfSSL|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL wolfSSL|Win32'">$(ProjectName)</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB wolfSSL|Win32'">$(ProjectName)</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL wolfSSL|x64'">$(ProjectName)</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI - DLL WinIDN|x64'">$(ProjectName)</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB wolfSSL|x64'">$(ProjectName)</TargetName>
@@ -1772,7 +1772,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -1803,7 +1803,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -1835,7 +1835,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -1864,7 +1864,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -2016,7 +2016,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -2047,7 +2047,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -2079,7 +2079,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -2108,7 +2108,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -2260,7 +2260,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -2291,7 +2291,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -2323,7 +2323,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -2352,7 +2352,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -2640,4 +2640,4 @@ CURL_SRC_RC_FILES
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
   </ImportGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/projects/Windows/VC10/src/curl.vcxproj.filters b/projects/Windows/VC10/src/curl.vcxproj.filters
index 4d6341d74..d2b9907aa 100644
--- a/projects/Windows/VC10/src/curl.vcxproj.filters
+++ b/projects/Windows/VC10/src/curl.vcxproj.filters
@@ -14,4 +14,4 @@
       <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
     </Filter>
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/projects/Windows/VC11/lib/libcurl.sln b/projects/Windows/VC11/lib/libcurl.sln
index 780dc91a2..e17c4cb86 100644
--- a/projects/Windows/VC11/lib/libcurl.sln
+++ b/projects/Windows/VC11/lib/libcurl.sln
@@ -4,8 +4,8 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libcurl", "libcurl.vcxproj"
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32 = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		DLL Debug - DLL OpenSSL - DLL LibSSH2|x64 = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
+		DLL Debug - DLL OpenSSL - DLL libssh2|Win32 = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		DLL Debug - DLL OpenSSL - DLL libssh2|x64 = DLL Debug - DLL OpenSSL - DLL libssh2|x64
 		DLL Debug - DLL OpenSSL|Win32 = DLL Debug - DLL OpenSSL|Win32
 		DLL Debug - DLL OpenSSL|x64 = DLL Debug - DLL OpenSSL|x64
 		DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32 = DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32
@@ -16,8 +16,8 @@ Global
 		DLL Debug - DLL wolfSSL|x64 = DLL Debug - DLL wolfSSL|x64
 		DLL Debug|Win32 = DLL Debug|Win32
 		DLL Debug|x64 = DLL Debug|x64
-		DLL Release - DLL OpenSSL - DLL LibSSH2|Win32 = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		DLL Release - DLL OpenSSL - DLL LibSSH2|x64 = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
+		DLL Release - DLL OpenSSL - DLL libssh2|Win32 = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		DLL Release - DLL OpenSSL - DLL libssh2|x64 = DLL Release - DLL OpenSSL - DLL libssh2|x64
 		DLL Release - DLL OpenSSL|Win32 = DLL Release - DLL OpenSSL|Win32
 		DLL Release - DLL OpenSSL|x64 = DLL Release - DLL OpenSSL|x64
 		DLL Release - DLL Windows SSPI - DLL WinIDN|Win32 = DLL Release - DLL Windows SSPI - DLL WinIDN|Win32
@@ -28,32 +28,32 @@ Global
 		DLL Release - DLL wolfSSL|x64 = DLL Release - DLL wolfSSL|x64
 		DLL Release|Win32 = DLL Release|Win32
 		DLL Release|x64 = DLL Release|x64
-		LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32 = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		LIB Debug - DLL OpenSSL - DLL LibSSH2|x64 = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
+		LIB Debug - DLL OpenSSL - DLL libssh2|Win32 = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		LIB Debug - DLL OpenSSL - DLL libssh2|x64 = LIB Debug - DLL OpenSSL - DLL libssh2|x64
 		LIB Debug - DLL OpenSSL|Win32 = LIB Debug - DLL OpenSSL|Win32
 		LIB Debug - DLL OpenSSL|x64 = LIB Debug - DLL OpenSSL|x64
 		LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32 = LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32
 		LIB Debug - DLL Windows SSPI - DLL WinIDN|x64 = LIB Debug - DLL Windows SSPI - DLL WinIDN|x64
 		LIB Debug - DLL Windows SSPI|Win32 = LIB Debug - DLL Windows SSPI|Win32
 		LIB Debug - DLL Windows SSPI|x64 = LIB Debug - DLL Windows SSPI|x64
-		LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32 = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		LIB Debug - LIB OpenSSL - LIB LibSSH2|x64 = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
+		LIB Debug - LIB OpenSSL - LIB libssh2|Win32 = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		LIB Debug - LIB OpenSSL - LIB libssh2|x64 = LIB Debug - LIB OpenSSL - LIB libssh2|x64
 		LIB Debug - LIB OpenSSL|Win32 = LIB Debug - LIB OpenSSL|Win32
 		LIB Debug - LIB OpenSSL|x64 = LIB Debug - LIB OpenSSL|x64
 		LIB Debug - LIB wolfSSL|Win32 = LIB Debug - LIB wolfSSL|Win32
 		LIB Debug - LIB wolfSSL|x64 = LIB Debug - LIB wolfSSL|x64
 		LIB Debug|Win32 = LIB Debug|Win32
 		LIB Debug|x64 = LIB Debug|x64
-		LIB Release - DLL OpenSSL - DLL LibSSH2|Win32 = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		LIB Release - DLL OpenSSL - DLL LibSSH2|x64 = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
+		LIB Release - DLL OpenSSL - DLL libssh2|Win32 = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		LIB Release - DLL OpenSSL - DLL libssh2|x64 = LIB Release - DLL OpenSSL - DLL libssh2|x64
 		LIB Release - DLL OpenSSL|Win32 = LIB Release - DLL OpenSSL|Win32
 		LIB Release - DLL OpenSSL|x64 = LIB Release - DLL OpenSSL|x64
 		LIB Release - DLL Windows SSPI - DLL WinIDN|Win32 = LIB Release - DLL Windows SSPI - DLL WinIDN|Win32
 		LIB Release - DLL Windows SSPI - DLL WinIDN|x64 = LIB Release - DLL Windows SSPI - DLL WinIDN|x64
 		LIB Release - DLL Windows SSPI|Win32 = LIB Release - DLL Windows SSPI|Win32
 		LIB Release - DLL Windows SSPI|x64 = LIB Release - DLL Windows SSPI|x64
-		LIB Release - LIB OpenSSL - LIB LibSSH2|Win32 = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		LIB Release - LIB OpenSSL - LIB LibSSH2|x64 = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
+		LIB Release - LIB OpenSSL - LIB libssh2|Win32 = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		LIB Release - LIB OpenSSL - LIB libssh2|x64 = LIB Release - LIB OpenSSL - LIB libssh2|x64
 		LIB Release - LIB OpenSSL|Win32 = LIB Release - LIB OpenSSL|Win32
 		LIB Release - LIB OpenSSL|x64 = LIB Release - LIB OpenSSL|x64
 		LIB Release - LIB wolfSSL|Win32 = LIB Release - LIB wolfSSL|Win32
@@ -62,10 +62,10 @@ Global
 		LIB Release|x64 = LIB Release|x64
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL libssh2|Win32.Build.0 = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = DLL Debug - DLL OpenSSL - DLL libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL libssh2|x64.Build.0 = DLL Debug - DLL OpenSSL - DLL libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL|Win32.ActiveCfg = DLL Debug - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL|Win32.Build.0 = DLL Debug - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL|x64.ActiveCfg = DLL Debug - DLL OpenSSL|x64
@@ -86,10 +86,10 @@ Global
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug|Win32.Build.0 = DLL Debug|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug|x64.ActiveCfg = DLL Debug|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug|x64.Build.0 = DLL Debug|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL libssh2|Win32.Build.0 = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = DLL Release - DLL OpenSSL - DLL libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL libssh2|x64.Build.0 = DLL Release - DLL OpenSSL - DLL libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL|Win32.ActiveCfg = DLL Release - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL|Win32.Build.0 = DLL Release - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL|x64.ActiveCfg = DLL Release - DLL OpenSSL|x64
@@ -110,10 +110,10 @@ Global
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release|Win32.Build.0 = DLL Release|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release|x64.ActiveCfg = DLL Release|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release|x64.Build.0 = DLL Release|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL libssh2|Win32.Build.0 = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = LIB Debug - DLL OpenSSL - DLL libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL libssh2|x64.Build.0 = LIB Debug - DLL OpenSSL - DLL libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL|Win32.ActiveCfg = LIB Debug - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL|Win32.Build.0 = LIB Debug - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL|x64.ActiveCfg = LIB Debug - DLL OpenSSL|x64
@@ -126,10 +126,10 @@ Global
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL Windows SSPI|Win32.Build.0 = LIB Debug - DLL Windows SSPI|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL Windows SSPI|x64.ActiveCfg = LIB Debug - DLL Windows SSPI|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL Windows SSPI|x64.Build.0 = LIB Debug - DLL Windows SSPI|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32.ActiveCfg = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32.Build.0 = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB LibSSH2|x64.ActiveCfg = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB LibSSH2|x64.Build.0 = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB libssh2|Win32.ActiveCfg = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB libssh2|Win32.Build.0 = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB libssh2|x64.ActiveCfg = LIB Debug - LIB OpenSSL - LIB libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB libssh2|x64.Build.0 = LIB Debug - LIB OpenSSL - LIB libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL|Win32.ActiveCfg = LIB Debug - LIB OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL|Win32.Build.0 = LIB Debug - LIB OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL|x64.ActiveCfg = LIB Debug - LIB OpenSSL|x64
@@ -142,10 +142,10 @@ Global
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug|Win32.Build.0 = LIB Debug|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug|x64.ActiveCfg = LIB Debug|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug|x64.Build.0 = LIB Debug|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL libssh2|Win32.Build.0 = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = LIB Release - DLL OpenSSL - DLL libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL libssh2|x64.Build.0 = LIB Release - DLL OpenSSL - DLL libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL|Win32.ActiveCfg = LIB Release - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL|Win32.Build.0 = LIB Release - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL|x64.ActiveCfg = LIB Release - DLL OpenSSL|x64
@@ -158,10 +158,10 @@ Global
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL Windows SSPI|Win32.Build.0 = LIB Release - DLL Windows SSPI|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL Windows SSPI|x64.ActiveCfg = LIB Release - DLL Windows SSPI|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL Windows SSPI|x64.Build.0 = LIB Release - DLL Windows SSPI|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB LibSSH2|Win32.ActiveCfg = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB LibSSH2|Win32.Build.0 = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB LibSSH2|x64.ActiveCfg = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB LibSSH2|x64.Build.0 = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB libssh2|Win32.ActiveCfg = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB libssh2|Win32.Build.0 = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB libssh2|x64.ActiveCfg = LIB Release - LIB OpenSSL - LIB libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB libssh2|x64.Build.0 = LIB Release - LIB OpenSSL - LIB libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL|Win32.ActiveCfg = LIB Release - LIB OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL|Win32.Build.0 = LIB Release - LIB OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL|x64.ActiveCfg = LIB Release - LIB OpenSSL|x64
diff --git a/projects/Windows/VC11/lib/libcurl.tmpl b/projects/Windows/VC11/lib/libcurl.tmpl
index 95cc9f6ca..477310f87 100644
--- a/projects/Windows/VC11/lib/libcurl.tmpl
+++ b/projects/Windows/VC11/lib/libcurl.tmpl
@@ -9,12 +9,12 @@
       <Configuration>DLL Debug - DLL wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>DLL Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>DLL Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>DLL Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>DLL Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="DLL Debug - DLL OpenSSL|Win32">
@@ -57,12 +57,12 @@
       <Configuration>DLL Release - DLL wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>DLL Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>DLL Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>DLL Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>DLL Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="DLL Release - DLL OpenSSL|Win32">
@@ -97,12 +97,12 @@
       <Configuration>DLL Release</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>LIB Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>LIB Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>LIB Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>LIB Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Debug - DLL OpenSSL|Win32">
@@ -137,12 +137,12 @@
       <Configuration>LIB Debug - LIB wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32">
-      <Configuration>LIB Debug - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB libssh2|Win32">
+      <Configuration>LIB Debug - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB LibSSH2|x64">
-      <Configuration>LIB Debug - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB libssh2|x64">
+      <Configuration>LIB Debug - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Debug - LIB OpenSSL|Win32">
@@ -161,12 +161,12 @@
       <Configuration>LIB Debug</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>LIB Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>LIB Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>LIB Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>LIB Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Release - DLL OpenSSL|Win32">
@@ -201,12 +201,12 @@
       <Configuration>LIB Release - LIB wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB LibSSH2|Win32">
-      <Configuration>LIB Release - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB libssh2|Win32">
+      <Configuration>LIB Release - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB LibSSH2|x64">
-      <Configuration>LIB Release - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB libssh2|x64">
+      <Configuration>LIB Release - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Release - LIB OpenSSL|Win32">
@@ -231,7 +231,7 @@
     <RootNamespace>libcurl</RootNamespace>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -255,7 +255,7 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -267,7 +267,7 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -291,7 +291,7 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -303,13 +303,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -399,7 +399,7 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -423,7 +423,7 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -435,7 +435,7 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -459,7 +459,7 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -471,13 +471,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -570,7 +570,7 @@
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|Win32'" Label="PropertySheets">
@@ -582,13 +582,13 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI - DLL WinIDN|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'" Label="PropertySheets">
@@ -600,16 +600,16 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|Win32'" Label="PropertySheets">
@@ -654,7 +654,7 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL wolfSSL|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'" Label="PropertySheets">
@@ -666,13 +666,13 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI - DLL WinIDN|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'" Label="PropertySheets">
@@ -684,16 +684,16 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|x64'" Label="PropertySheets">
@@ -817,26 +817,26 @@
     <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|x64'">$(OutDir)lib\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|x64'">false</LinkIncremental>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)lib\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)lib\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)lib\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)lib\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">$(OutDir)lib\</IntDir>
@@ -849,18 +849,18 @@
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|Win32'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI - DLL WinIDN|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI|Win32'">$(OutDir)lib\</IntDir>
@@ -873,18 +873,18 @@
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|Win32'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">$(OutDir)lib\</IntDir>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL wolfSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL wolfSSL|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI|x64'">$(ProjectName)d</TargetName>
@@ -895,16 +895,16 @@
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB wolfSSL|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">$(ProjectName)d</TargetName>
   </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug|Win32'">
     <Midl>
@@ -1740,7 +1740,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <MkTypLibCompatible>true</MkTypLibCompatible>
@@ -1774,7 +1774,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <MkTypLibCompatible>true</MkTypLibCompatible>
@@ -1807,7 +1807,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <MkTypLibCompatible>true</MkTypLibCompatible>
@@ -1839,7 +1839,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <MkTypLibCompatible>true</MkTypLibCompatible>
@@ -1913,7 +1913,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">
     <ClCompile>
       <Optimization>Disabled</Optimization>
       <AdditionalIncludeDirectories>..\..\..\..\include;..\..\..\..\lib;..\..\..\..\..\openssl\include\..\build\Win32\VC11\DLL Debug\include;..\..\..\..\..\openssl\include;..\..\..\..\..\libssh2\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
@@ -1933,7 +1933,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
     </Midl>
@@ -2085,7 +2085,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">
     <ClCompile>
       <Optimization>Disabled</Optimization>
       <AdditionalIncludeDirectories>..\..\..\..\include;..\..\..\..\lib;..\..\..\..\..\openssl\include\..\build\Win32\VC11\LIB Debug\include;..\..\..\..\..\openssl\include;..\..\..\..\..\libssh2\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
@@ -2105,7 +2105,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
     </Midl>
@@ -2171,7 +2171,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">
     <ClCompile>
       <Optimization>MaxSpeed</Optimization>
       <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
@@ -2191,7 +2191,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
     </Midl>
@@ -2343,7 +2343,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">
     <ClCompile>
       <Optimization>MaxSpeed</Optimization>
       <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
@@ -2363,7 +2363,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
     </Midl>
@@ -2406,4 +2406,4 @@ CURL_LIB_RC_FILES
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
   </ImportGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/projects/Windows/VC11/lib/libcurl.vcxproj.filters b/projects/Windows/VC11/lib/libcurl.vcxproj.filters
index 4d6341d74..d2b9907aa 100644
--- a/projects/Windows/VC11/lib/libcurl.vcxproj.filters
+++ b/projects/Windows/VC11/lib/libcurl.vcxproj.filters
@@ -14,4 +14,4 @@
       <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
     </Filter>
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/projects/Windows/VC11/src/curl.sln b/projects/Windows/VC11/src/curl.sln
index e12253e9b..7996f2da2 100644
--- a/projects/Windows/VC11/src/curl.sln
+++ b/projects/Windows/VC11/src/curl.sln
@@ -4,8 +4,8 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "curl", "curl.vcxproj", "{52
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32 = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		DLL Debug - DLL OpenSSL - DLL LibSSH2|x64 = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
+		DLL Debug - DLL OpenSSL - DLL libssh2|Win32 = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		DLL Debug - DLL OpenSSL - DLL libssh2|x64 = DLL Debug - DLL OpenSSL - DLL libssh2|x64
 		DLL Debug - DLL OpenSSL|Win32 = DLL Debug - DLL OpenSSL|Win32
 		DLL Debug - DLL OpenSSL|x64 = DLL Debug - DLL OpenSSL|x64
 		DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32 = DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32
@@ -16,8 +16,8 @@ Global
 		DLL Debug - DLL wolfSSL|x64 = DLL Debug - DLL wolfSSL|x64
 		DLL Debug|Win32 = DLL Debug|Win32
 		DLL Debug|x64 = DLL Debug|x64
-		DLL Release - DLL OpenSSL - DLL LibSSH2|Win32 = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		DLL Release - DLL OpenSSL - DLL LibSSH2|x64 = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
+		DLL Release - DLL OpenSSL - DLL libssh2|Win32 = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		DLL Release - DLL OpenSSL - DLL libssh2|x64 = DLL Release - DLL OpenSSL - DLL libssh2|x64
 		DLL Release - DLL OpenSSL|Win32 = DLL Release - DLL OpenSSL|Win32
 		DLL Release - DLL OpenSSL|x64 = DLL Release - DLL OpenSSL|x64
 		DLL Release - DLL Windows SSPI - DLL WinIDN|Win32 = DLL Release - DLL Windows SSPI - DLL WinIDN|Win32
@@ -28,32 +28,32 @@ Global
 		DLL Release - DLL wolfSSL|x64 = DLL Release - DLL wolfSSL|x64
 		DLL Release|Win32 = DLL Release|Win32
 		DLL Release|x64 = DLL Release|x64
-		LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32 = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		LIB Debug - DLL OpenSSL - DLL LibSSH2|x64 = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
+		LIB Debug - DLL OpenSSL - DLL libssh2|Win32 = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		LIB Debug - DLL OpenSSL - DLL libssh2|x64 = LIB Debug - DLL OpenSSL - DLL libssh2|x64
 		LIB Debug - DLL OpenSSL|Win32 = LIB Debug - DLL OpenSSL|Win32
 		LIB Debug - DLL OpenSSL|x64 = LIB Debug - DLL OpenSSL|x64
 		LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32 = LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32
 		LIB Debug - DLL Windows SSPI - DLL WinIDN|x64 = LIB Debug - DLL Windows SSPI - DLL WinIDN|x64
 		LIB Debug - DLL Windows SSPI|Win32 = LIB Debug - DLL Windows SSPI|Win32
 		LIB Debug - DLL Windows SSPI|x64 = LIB Debug - DLL Windows SSPI|x64
-		LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32 = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		LIB Debug - LIB OpenSSL - LIB LibSSH2|x64 = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
+		LIB Debug - LIB OpenSSL - LIB libssh2|Win32 = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		LIB Debug - LIB OpenSSL - LIB libssh2|x64 = LIB Debug - LIB OpenSSL - LIB libssh2|x64
 		LIB Debug - LIB OpenSSL|Win32 = LIB Debug - LIB OpenSSL|Win32
 		LIB Debug - LIB OpenSSL|x64 = LIB Debug - LIB OpenSSL|x64
 		LIB Debug - LIB wolfSSL|Win32 = LIB Debug - LIB wolfSSL|Win32
 		LIB Debug - LIB wolfSSL|x64 = LIB Debug - LIB wolfSSL|x64
 		LIB Debug|Win32 = LIB Debug|Win32
 		LIB Debug|x64 = LIB Debug|x64
-		LIB Release - DLL OpenSSL - DLL LibSSH2|Win32 = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		LIB Release - DLL OpenSSL - DLL LibSSH2|x64 = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
+		LIB Release - DLL OpenSSL - DLL libssh2|Win32 = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		LIB Release - DLL OpenSSL - DLL libssh2|x64 = LIB Release - DLL OpenSSL - DLL libssh2|x64
 		LIB Release - DLL OpenSSL|Win32 = LIB Release - DLL OpenSSL|Win32
 		LIB Release - DLL OpenSSL|x64 = LIB Release - DLL OpenSSL|x64
 		LIB Release - DLL Windows SSPI - DLL WinIDN|Win32 = LIB Release - DLL Windows SSPI - DLL WinIDN|Win32
 		LIB Release - DLL Windows SSPI - DLL WinIDN|x64 = LIB Release - DLL Windows SSPI - DLL WinIDN|x64
 		LIB Release - DLL Windows SSPI|Win32 = LIB Release - DLL Windows SSPI|Win32
 		LIB Release - DLL Windows SSPI|x64 = LIB Release - DLL Windows SSPI|x64
-		LIB Release - LIB OpenSSL - LIB LibSSH2|Win32 = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		LIB Release - LIB OpenSSL - LIB LibSSH2|x64 = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
+		LIB Release - LIB OpenSSL - LIB libssh2|Win32 = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		LIB Release - LIB OpenSSL - LIB libssh2|x64 = LIB Release - LIB OpenSSL - LIB libssh2|x64
 		LIB Release - LIB OpenSSL|Win32 = LIB Release - LIB OpenSSL|Win32
 		LIB Release - LIB OpenSSL|x64 = LIB Release - LIB OpenSSL|x64
 		LIB Release - LIB wolfSSL|Win32 = LIB Release - LIB wolfSSL|Win32
@@ -62,10 +62,10 @@ Global
 		LIB Release|x64 = LIB Release|x64
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL libssh2|Win32.Build.0 = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = DLL Debug - DLL OpenSSL - DLL libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL libssh2|x64.Build.0 = DLL Debug - DLL OpenSSL - DLL libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL|Win32.ActiveCfg = DLL Debug - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL|Win32.Build.0 = DLL Debug - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL|x64.ActiveCfg = DLL Debug - DLL OpenSSL|x64
@@ -86,10 +86,10 @@ Global
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug|Win32.Build.0 = DLL Debug|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug|x64.ActiveCfg = DLL Debug|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug|x64.Build.0 = DLL Debug|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL libssh2|Win32.Build.0 = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = DLL Release - DLL OpenSSL - DLL libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL libssh2|x64.Build.0 = DLL Release - DLL OpenSSL - DLL libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL|Win32.ActiveCfg = DLL Release - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL|Win32.Build.0 = DLL Release - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL|x64.ActiveCfg = DLL Release - DLL OpenSSL|x64
@@ -110,10 +110,10 @@ Global
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release|Win32.Build.0 = DLL Release|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release|x64.ActiveCfg = DLL Release|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release|x64.Build.0 = DLL Release|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL libssh2|Win32.Build.0 = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = LIB Debug - DLL OpenSSL - DLL libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL libssh2|x64.Build.0 = LIB Debug - DLL OpenSSL - DLL libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL|Win32.ActiveCfg = LIB Debug - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL|Win32.Build.0 = LIB Debug - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL|x64.ActiveCfg = LIB Debug - DLL OpenSSL|x64
@@ -126,10 +126,10 @@ Global
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL Windows SSPI|Win32.Build.0 = LIB Debug - DLL Windows SSPI|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL Windows SSPI|x64.ActiveCfg = LIB Debug - DLL Windows SSPI|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL Windows SSPI|x64.Build.0 = LIB Debug - DLL Windows SSPI|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32.ActiveCfg = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32.Build.0 = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB LibSSH2|x64.ActiveCfg = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB LibSSH2|x64.Build.0 = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB libssh2|Win32.ActiveCfg = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB libssh2|Win32.Build.0 = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB libssh2|x64.ActiveCfg = LIB Debug - LIB OpenSSL - LIB libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB libssh2|x64.Build.0 = LIB Debug - LIB OpenSSL - LIB libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL|Win32.ActiveCfg = LIB Debug - LIB OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL|Win32.Build.0 = LIB Debug - LIB OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL|x64.ActiveCfg = LIB Debug - LIB OpenSSL|x64
@@ -142,10 +142,10 @@ Global
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug|Win32.Build.0 = LIB Debug|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug|x64.ActiveCfg = LIB Debug|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug|x64.Build.0 = LIB Debug|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL libssh2|Win32.Build.0 = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = LIB Release - DLL OpenSSL - DLL libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL libssh2|x64.Build.0 = LIB Release - DLL OpenSSL - DLL libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL|Win32.ActiveCfg = LIB Release - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL|Win32.Build.0 = LIB Release - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL|x64.ActiveCfg = LIB Release - DLL OpenSSL|x64
@@ -158,10 +158,10 @@ Global
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL Windows SSPI|Win32.Build.0 = LIB Release - DLL Windows SSPI|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL Windows SSPI|x64.ActiveCfg = LIB Release - DLL Windows SSPI|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL Windows SSPI|x64.Build.0 = LIB Release - DLL Windows SSPI|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB LibSSH2|Win32.ActiveCfg = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB LibSSH2|Win32.Build.0 = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB LibSSH2|x64.ActiveCfg = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB LibSSH2|x64.Build.0 = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB libssh2|Win32.ActiveCfg = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB libssh2|Win32.Build.0 = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB libssh2|x64.ActiveCfg = LIB Release - LIB OpenSSL - LIB libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB libssh2|x64.Build.0 = LIB Release - LIB OpenSSL - LIB libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL|Win32.ActiveCfg = LIB Release - LIB OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL|Win32.Build.0 = LIB Release - LIB OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL|x64.ActiveCfg = LIB Release - LIB OpenSSL|x64
diff --git a/projects/Windows/VC11/src/curl.tmpl b/projects/Windows/VC11/src/curl.tmpl
index 31df7d640..4405a4694 100644
--- a/projects/Windows/VC11/src/curl.tmpl
+++ b/projects/Windows/VC11/src/curl.tmpl
@@ -9,12 +9,12 @@
       <Configuration>DLL Debug - DLL wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>DLL Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>DLL Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>DLL Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>DLL Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="DLL Debug - DLL OpenSSL|Win32">
@@ -57,12 +57,12 @@
       <Configuration>DLL Release - DLL wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>DLL Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>DLL Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>DLL Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>DLL Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="DLL Release - DLL OpenSSL|Win32">
@@ -97,12 +97,12 @@
       <Configuration>DLL Release</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>LIB Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>LIB Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>LIB Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>LIB Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Debug - DLL OpenSSL|Win32">
@@ -137,12 +137,12 @@
       <Configuration>LIB Debug - LIB wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32">
-      <Configuration>LIB Debug - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB libssh2|Win32">
+      <Configuration>LIB Debug - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB LibSSH2|x64">
-      <Configuration>LIB Debug - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB libssh2|x64">
+      <Configuration>LIB Debug - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Debug - LIB OpenSSL|Win32">
@@ -161,12 +161,12 @@
       <Configuration>LIB Debug</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>LIB Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>LIB Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>LIB Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>LIB Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Release - DLL OpenSSL|Win32">
@@ -201,12 +201,12 @@
       <Configuration>LIB Release - LIB wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB LibSSH2|Win32">
-      <Configuration>LIB Release - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB libssh2|Win32">
+      <Configuration>LIB Release - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB LibSSH2|x64">
-      <Configuration>LIB Release - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB libssh2|x64">
+      <Configuration>LIB Release - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Release - LIB OpenSSL|Win32">
@@ -255,13 +255,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -279,13 +279,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -303,13 +303,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -423,13 +423,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -447,13 +447,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -471,13 +471,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -582,10 +582,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|Win32'" Label="PropertySheets">
@@ -594,10 +594,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|Win32'" Label="PropertySheets">
@@ -606,10 +606,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|Win32'" Label="PropertySheets">
@@ -666,10 +666,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'" Label="PropertySheets">
@@ -678,10 +678,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'" Label="PropertySheets">
@@ -690,10 +690,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|x64'" Label="PropertySheets">
@@ -825,18 +825,18 @@
     <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|x64'">$(OutDir)src\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|x64'">false</LinkIncremental>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">$(OutDir)src\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">false</LinkIncremental>
@@ -849,18 +849,18 @@
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">$(OutDir)src\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">false</LinkIncremental>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">$(OutDir)src\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">false</LinkIncremental>
@@ -873,18 +873,18 @@
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">$(OutDir)src\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC11\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'">..\..\..\..\build\Win32\VC11\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">$(OutDir)src\</IntDir>
@@ -915,8 +915,8 @@
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL wolfSSL|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI|x64'">$(ProjectName)d</TargetName>
@@ -927,41 +927,41 @@
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB wolfSSL|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL wolfSSL|Win32'">$(ProjectName)</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB wolfSSL|Win32'">$(ProjectName)</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL wolfSSL|x64'">$(ProjectName)</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI - DLL WinIDN|x64'">$(ProjectName)</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB wolfSSL|x64'">$(ProjectName)</TargetName>
@@ -1828,7 +1828,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -1859,7 +1859,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -1891,7 +1891,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -1920,7 +1920,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -2072,7 +2072,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -2103,7 +2103,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -2135,7 +2135,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -2164,7 +2164,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -2316,7 +2316,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -2347,7 +2347,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -2379,7 +2379,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -2408,7 +2408,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -2696,4 +2696,4 @@ CURL_SRC_RC_FILES
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
   </ImportGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/projects/Windows/VC11/src/curl.vcxproj.filters b/projects/Windows/VC11/src/curl.vcxproj.filters
index 4d6341d74..d2b9907aa 100644
--- a/projects/Windows/VC11/src/curl.vcxproj.filters
+++ b/projects/Windows/VC11/src/curl.vcxproj.filters
@@ -14,4 +14,4 @@
       <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
     </Filter>
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/projects/Windows/VC12/lib/libcurl.sln b/projects/Windows/VC12/lib/libcurl.sln
index 860a06028..0487ef820 100644
--- a/projects/Windows/VC12/lib/libcurl.sln
+++ b/projects/Windows/VC12/lib/libcurl.sln
@@ -4,8 +4,8 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libcurl", "libcurl.vcxproj"
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32 = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		DLL Debug - DLL OpenSSL - DLL LibSSH2|x64 = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
+		DLL Debug - DLL OpenSSL - DLL libssh2|Win32 = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		DLL Debug - DLL OpenSSL - DLL libssh2|x64 = DLL Debug - DLL OpenSSL - DLL libssh2|x64
 		DLL Debug - DLL OpenSSL|Win32 = DLL Debug - DLL OpenSSL|Win32
 		DLL Debug - DLL OpenSSL|x64 = DLL Debug - DLL OpenSSL|x64
 		DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32 = DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32
@@ -16,8 +16,8 @@ Global
 		DLL Debug - DLL wolfSSL|x64 = DLL Debug - DLL wolfSSL|x64
 		DLL Debug|Win32 = DLL Debug|Win32
 		DLL Debug|x64 = DLL Debug|x64
-		DLL Release - DLL OpenSSL - DLL LibSSH2|Win32 = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		DLL Release - DLL OpenSSL - DLL LibSSH2|x64 = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
+		DLL Release - DLL OpenSSL - DLL libssh2|Win32 = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		DLL Release - DLL OpenSSL - DLL libssh2|x64 = DLL Release - DLL OpenSSL - DLL libssh2|x64
 		DLL Release - DLL OpenSSL|Win32 = DLL Release - DLL OpenSSL|Win32
 		DLL Release - DLL OpenSSL|x64 = DLL Release - DLL OpenSSL|x64
 		DLL Release - DLL Windows SSPI - DLL WinIDN|Win32 = DLL Release - DLL Windows SSPI - DLL WinIDN|Win32
@@ -28,32 +28,32 @@ Global
 		DLL Release - DLL wolfSSL|x64 = DLL Release - DLL wolfSSL|x64
 		DLL Release|Win32 = DLL Release|Win32
 		DLL Release|x64 = DLL Release|x64
-		LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32 = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		LIB Debug - DLL OpenSSL - DLL LibSSH2|x64 = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
+		LIB Debug - DLL OpenSSL - DLL libssh2|Win32 = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		LIB Debug - DLL OpenSSL - DLL libssh2|x64 = LIB Debug - DLL OpenSSL - DLL libssh2|x64
 		LIB Debug - DLL OpenSSL|Win32 = LIB Debug - DLL OpenSSL|Win32
 		LIB Debug - DLL OpenSSL|x64 = LIB Debug - DLL OpenSSL|x64
 		LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32 = LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32
 		LIB Debug - DLL Windows SSPI - DLL WinIDN|x64 = LIB Debug - DLL Windows SSPI - DLL WinIDN|x64
 		LIB Debug - DLL Windows SSPI|Win32 = LIB Debug - DLL Windows SSPI|Win32
 		LIB Debug - DLL Windows SSPI|x64 = LIB Debug - DLL Windows SSPI|x64
-		LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32 = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		LIB Debug - LIB OpenSSL - LIB LibSSH2|x64 = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
+		LIB Debug - LIB OpenSSL - LIB libssh2|Win32 = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		LIB Debug - LIB OpenSSL - LIB libssh2|x64 = LIB Debug - LIB OpenSSL - LIB libssh2|x64
 		LIB Debug - LIB OpenSSL|Win32 = LIB Debug - LIB OpenSSL|Win32
 		LIB Debug - LIB OpenSSL|x64 = LIB Debug - LIB OpenSSL|x64
 		LIB Debug - LIB wolfSSL|Win32 = LIB Debug - LIB wolfSSL|Win32
 		LIB Debug - LIB wolfSSL|x64 = LIB Debug - LIB wolfSSL|x64
 		LIB Debug|Win32 = LIB Debug|Win32
 		LIB Debug|x64 = LIB Debug|x64
-		LIB Release - DLL OpenSSL - DLL LibSSH2|Win32 = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		LIB Release - DLL OpenSSL - DLL LibSSH2|x64 = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
+		LIB Release - DLL OpenSSL - DLL libssh2|Win32 = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		LIB Release - DLL OpenSSL - DLL libssh2|x64 = LIB Release - DLL OpenSSL - DLL libssh2|x64
 		LIB Release - DLL OpenSSL|Win32 = LIB Release - DLL OpenSSL|Win32
 		LIB Release - DLL OpenSSL|x64 = LIB Release - DLL OpenSSL|x64
 		LIB Release - DLL Windows SSPI - DLL WinIDN|Win32 = LIB Release - DLL Windows SSPI - DLL WinIDN|Win32
 		LIB Release - DLL Windows SSPI - DLL WinIDN|x64 = LIB Release - DLL Windows SSPI - DLL WinIDN|x64
 		LIB Release - DLL Windows SSPI|Win32 = LIB Release - DLL Windows SSPI|Win32
 		LIB Release - DLL Windows SSPI|x64 = LIB Release - DLL Windows SSPI|x64
-		LIB Release - LIB OpenSSL - LIB LibSSH2|Win32 = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		LIB Release - LIB OpenSSL - LIB LibSSH2|x64 = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
+		LIB Release - LIB OpenSSL - LIB libssh2|Win32 = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		LIB Release - LIB OpenSSL - LIB libssh2|x64 = LIB Release - LIB OpenSSL - LIB libssh2|x64
 		LIB Release - LIB OpenSSL|Win32 = LIB Release - LIB OpenSSL|Win32
 		LIB Release - LIB OpenSSL|x64 = LIB Release - LIB OpenSSL|x64
 		LIB Release - LIB wolfSSL|Win32 = LIB Release - LIB wolfSSL|Win32
@@ -62,10 +62,10 @@ Global
 		LIB Release|x64 = LIB Release|x64
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL libssh2|Win32.Build.0 = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = DLL Debug - DLL OpenSSL - DLL libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL - DLL libssh2|x64.Build.0 = DLL Debug - DLL OpenSSL - DLL libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL|Win32.ActiveCfg = DLL Debug - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL|Win32.Build.0 = DLL Debug - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug - DLL OpenSSL|x64.ActiveCfg = DLL Debug - DLL OpenSSL|x64
@@ -86,10 +86,10 @@ Global
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug|Win32.Build.0 = DLL Debug|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug|x64.ActiveCfg = DLL Debug|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Debug|x64.Build.0 = DLL Debug|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL libssh2|Win32.Build.0 = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = DLL Release - DLL OpenSSL - DLL libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL - DLL libssh2|x64.Build.0 = DLL Release - DLL OpenSSL - DLL libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL|Win32.ActiveCfg = DLL Release - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL|Win32.Build.0 = DLL Release - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release - DLL OpenSSL|x64.ActiveCfg = DLL Release - DLL OpenSSL|x64
@@ -110,10 +110,10 @@ Global
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release|Win32.Build.0 = DLL Release|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release|x64.ActiveCfg = DLL Release|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.DLL Release|x64.Build.0 = DLL Release|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL libssh2|Win32.Build.0 = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = LIB Debug - DLL OpenSSL - DLL libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL - DLL libssh2|x64.Build.0 = LIB Debug - DLL OpenSSL - DLL libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL|Win32.ActiveCfg = LIB Debug - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL|Win32.Build.0 = LIB Debug - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL OpenSSL|x64.ActiveCfg = LIB Debug - DLL OpenSSL|x64
@@ -126,10 +126,10 @@ Global
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL Windows SSPI|Win32.Build.0 = LIB Debug - DLL Windows SSPI|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL Windows SSPI|x64.ActiveCfg = LIB Debug - DLL Windows SSPI|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - DLL Windows SSPI|x64.Build.0 = LIB Debug - DLL Windows SSPI|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32.ActiveCfg = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32.Build.0 = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB LibSSH2|x64.ActiveCfg = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB LibSSH2|x64.Build.0 = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB libssh2|Win32.ActiveCfg = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB libssh2|Win32.Build.0 = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB libssh2|x64.ActiveCfg = LIB Debug - LIB OpenSSL - LIB libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL - LIB libssh2|x64.Build.0 = LIB Debug - LIB OpenSSL - LIB libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL|Win32.ActiveCfg = LIB Debug - LIB OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL|Win32.Build.0 = LIB Debug - LIB OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug - LIB OpenSSL|x64.ActiveCfg = LIB Debug - LIB OpenSSL|x64
@@ -142,10 +142,10 @@ Global
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug|Win32.Build.0 = LIB Debug|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug|x64.ActiveCfg = LIB Debug|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Debug|x64.Build.0 = LIB Debug|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL libssh2|Win32.Build.0 = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = LIB Release - DLL OpenSSL - DLL libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL - DLL libssh2|x64.Build.0 = LIB Release - DLL OpenSSL - DLL libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL|Win32.ActiveCfg = LIB Release - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL|Win32.Build.0 = LIB Release - DLL OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL OpenSSL|x64.ActiveCfg = LIB Release - DLL OpenSSL|x64
@@ -158,10 +158,10 @@ Global
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL Windows SSPI|Win32.Build.0 = LIB Release - DLL Windows SSPI|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL Windows SSPI|x64.ActiveCfg = LIB Release - DLL Windows SSPI|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - DLL Windows SSPI|x64.Build.0 = LIB Release - DLL Windows SSPI|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB LibSSH2|Win32.ActiveCfg = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB LibSSH2|Win32.Build.0 = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB LibSSH2|x64.ActiveCfg = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
-		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB LibSSH2|x64.Build.0 = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB libssh2|Win32.ActiveCfg = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB libssh2|Win32.Build.0 = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB libssh2|x64.ActiveCfg = LIB Release - LIB OpenSSL - LIB libssh2|x64
+		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL - LIB libssh2|x64.Build.0 = LIB Release - LIB OpenSSL - LIB libssh2|x64
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL|Win32.ActiveCfg = LIB Release - LIB OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL|Win32.Build.0 = LIB Release - LIB OpenSSL|Win32
 		{DA6F56B4-06A4-441D-AD70-AC5A7D51FADB}.LIB Release - LIB OpenSSL|x64.ActiveCfg = LIB Release - LIB OpenSSL|x64
diff --git a/projects/Windows/VC12/lib/libcurl.tmpl b/projects/Windows/VC12/lib/libcurl.tmpl
index a2d666c25..2b1db48ee 100644
--- a/projects/Windows/VC12/lib/libcurl.tmpl
+++ b/projects/Windows/VC12/lib/libcurl.tmpl
@@ -9,12 +9,12 @@
       <Configuration>DLL Debug - DLL wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>DLL Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>DLL Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>DLL Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>DLL Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="DLL Debug - DLL OpenSSL|Win32">
@@ -57,12 +57,12 @@
       <Configuration>DLL Release - DLL wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>DLL Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>DLL Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>DLL Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>DLL Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="DLL Release - DLL OpenSSL|Win32">
@@ -97,12 +97,12 @@
       <Configuration>DLL Release</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>LIB Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>LIB Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>LIB Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>LIB Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Debug - DLL OpenSSL|Win32">
@@ -137,12 +137,12 @@
       <Configuration>LIB Debug - LIB wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32">
-      <Configuration>LIB Debug - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB libssh2|Win32">
+      <Configuration>LIB Debug - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB LibSSH2|x64">
-      <Configuration>LIB Debug - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB libssh2|x64">
+      <Configuration>LIB Debug - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Debug - LIB OpenSSL|Win32">
@@ -161,12 +161,12 @@
       <Configuration>LIB Debug</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>LIB Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>LIB Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>LIB Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>LIB Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Release - DLL OpenSSL|Win32">
@@ -201,12 +201,12 @@
       <Configuration>LIB Release - LIB wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB LibSSH2|Win32">
-      <Configuration>LIB Release - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB libssh2|Win32">
+      <Configuration>LIB Release - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB LibSSH2|x64">
-      <Configuration>LIB Release - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB libssh2|x64">
+      <Configuration>LIB Release - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Release - LIB OpenSSL|Win32">
@@ -231,7 +231,7 @@
     <RootNamespace>libcurl</RootNamespace>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -255,7 +255,7 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -267,7 +267,7 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -291,7 +291,7 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -303,13 +303,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -399,7 +399,7 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -423,7 +423,7 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -435,7 +435,7 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -459,7 +459,7 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -471,13 +471,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -570,7 +570,7 @@
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|Win32'" Label="PropertySheets">
@@ -582,13 +582,13 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI - DLL WinIDN|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'" Label="PropertySheets">
@@ -600,16 +600,16 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|Win32'" Label="PropertySheets">
@@ -654,7 +654,7 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL wolfSSL|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'" Label="PropertySheets">
@@ -666,13 +666,13 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI - DLL WinIDN|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'" Label="PropertySheets">
@@ -684,16 +684,16 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|x64'" Label="PropertySheets">
@@ -817,26 +817,26 @@
     <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|x64'">$(OutDir)lib\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|x64'">false</LinkIncremental>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)lib\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)lib\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)lib\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)lib\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">$(OutDir)lib\</IntDir>
@@ -849,18 +849,18 @@
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|Win32'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI - DLL WinIDN|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI|Win32'">$(OutDir)lib\</IntDir>
@@ -873,18 +873,18 @@
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|Win32'">$(OutDir)lib\</IntDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">$(OutDir)lib\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">$(OutDir)lib\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">$(OutDir)lib\</IntDir>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL wolfSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL wolfSSL|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI|x64'">$(ProjectName)d</TargetName>
@@ -895,16 +895,16 @@
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB wolfSSL|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">$(ProjectName)d</TargetName>
   </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug|Win32'">
     <Midl>
@@ -1740,7 +1740,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <MkTypLibCompatible>true</MkTypLibCompatible>
@@ -1774,7 +1774,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <MkTypLibCompatible>true</MkTypLibCompatible>
@@ -1807,7 +1807,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <MkTypLibCompatible>true</MkTypLibCompatible>
@@ -1839,7 +1839,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <MkTypLibCompatible>true</MkTypLibCompatible>
@@ -1913,7 +1913,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">
     <ClCompile>
       <Optimization>Disabled</Optimization>
       <AdditionalIncludeDirectories>..\..\..\..\include;..\..\..\..\lib;..\..\..\..\..\openssl\include\..\build\Win32\VC12\DLL Debug\include;..\..\..\..\..\openssl\include;..\..\..\..\..\libssh2\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
@@ -1933,7 +1933,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
     </Midl>
@@ -2085,7 +2085,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">
     <ClCompile>
       <Optimization>Disabled</Optimization>
       <AdditionalIncludeDirectories>..\..\..\..\include;..\..\..\..\lib;..\..\..\..\..\openssl\include\..\build\Win32\VC12\LIB Debug\include;..\..\..\..\..\openssl\include;..\..\..\..\..\libssh2\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
@@ -2105,7 +2105,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
     </Midl>
@@ -2171,7 +2171,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">
     <ClCompile>
       <Optimization>MaxSpeed</Optimization>
       <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
@@ -2191,7 +2191,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
     </Midl>
@@ -2343,7 +2343,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">
     <ClCompile>
       <Optimization>MaxSpeed</Optimization>
       <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
@@ -2363,7 +2363,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Lib>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
     </Midl>
@@ -2406,4 +2406,4 @@ CURL_LIB_RC_FILES
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
   </ImportGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/projects/Windows/VC12/lib/libcurl.vcxproj.filters b/projects/Windows/VC12/lib/libcurl.vcxproj.filters
index 4d6341d74..d2b9907aa 100644
--- a/projects/Windows/VC12/lib/libcurl.vcxproj.filters
+++ b/projects/Windows/VC12/lib/libcurl.vcxproj.filters
@@ -14,4 +14,4 @@
       <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
     </Filter>
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/projects/Windows/VC12/src/curl.sln b/projects/Windows/VC12/src/curl.sln
index 7b5244c1f..bbee81f05 100644
--- a/projects/Windows/VC12/src/curl.sln
+++ b/projects/Windows/VC12/src/curl.sln
@@ -4,8 +4,8 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "curl", "curl.vcxproj", "{52
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32 = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		DLL Debug - DLL OpenSSL - DLL LibSSH2|x64 = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
+		DLL Debug - DLL OpenSSL - DLL libssh2|Win32 = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		DLL Debug - DLL OpenSSL - DLL libssh2|x64 = DLL Debug - DLL OpenSSL - DLL libssh2|x64
 		DLL Debug - DLL OpenSSL|Win32 = DLL Debug - DLL OpenSSL|Win32
 		DLL Debug - DLL OpenSSL|x64 = DLL Debug - DLL OpenSSL|x64
 		DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32 = DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32
@@ -16,8 +16,8 @@ Global
 		DLL Debug - DLL wolfSSL|x64 = DLL Debug - DLL wolfSSL|x64
 		DLL Debug|Win32 = DLL Debug|Win32
 		DLL Debug|x64 = DLL Debug|x64
-		DLL Release - DLL OpenSSL - DLL LibSSH2|Win32 = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		DLL Release - DLL OpenSSL - DLL LibSSH2|x64 = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
+		DLL Release - DLL OpenSSL - DLL libssh2|Win32 = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		DLL Release - DLL OpenSSL - DLL libssh2|x64 = DLL Release - DLL OpenSSL - DLL libssh2|x64
 		DLL Release - DLL OpenSSL|Win32 = DLL Release - DLL OpenSSL|Win32
 		DLL Release - DLL OpenSSL|x64 = DLL Release - DLL OpenSSL|x64
 		DLL Release - DLL Windows SSPI - DLL WinIDN|Win32 = DLL Release - DLL Windows SSPI - DLL WinIDN|Win32
@@ -28,32 +28,32 @@ Global
 		DLL Release - DLL wolfSSL|x64 = DLL Release - DLL wolfSSL|x64
 		DLL Release|Win32 = DLL Release|Win32
 		DLL Release|x64 = DLL Release|x64
-		LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32 = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		LIB Debug - DLL OpenSSL - DLL LibSSH2|x64 = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
+		LIB Debug - DLL OpenSSL - DLL libssh2|Win32 = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		LIB Debug - DLL OpenSSL - DLL libssh2|x64 = LIB Debug - DLL OpenSSL - DLL libssh2|x64
 		LIB Debug - DLL OpenSSL|Win32 = LIB Debug - DLL OpenSSL|Win32
 		LIB Debug - DLL OpenSSL|x64 = LIB Debug - DLL OpenSSL|x64
 		LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32 = LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32
 		LIB Debug - DLL Windows SSPI - DLL WinIDN|x64 = LIB Debug - DLL Windows SSPI - DLL WinIDN|x64
 		LIB Debug - DLL Windows SSPI|Win32 = LIB Debug - DLL Windows SSPI|Win32
 		LIB Debug - DLL Windows SSPI|x64 = LIB Debug - DLL Windows SSPI|x64
-		LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32 = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		LIB Debug - LIB OpenSSL - LIB LibSSH2|x64 = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
+		LIB Debug - LIB OpenSSL - LIB libssh2|Win32 = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		LIB Debug - LIB OpenSSL - LIB libssh2|x64 = LIB Debug - LIB OpenSSL - LIB libssh2|x64
 		LIB Debug - LIB OpenSSL|Win32 = LIB Debug - LIB OpenSSL|Win32
 		LIB Debug - LIB OpenSSL|x64 = LIB Debug - LIB OpenSSL|x64
 		LIB Debug - LIB wolfSSL|Win32 = LIB Debug - LIB wolfSSL|Win32
 		LIB Debug - LIB wolfSSL|x64 = LIB Debug - LIB wolfSSL|x64
 		LIB Debug|Win32 = LIB Debug|Win32
 		LIB Debug|x64 = LIB Debug|x64
-		LIB Release - DLL OpenSSL - DLL LibSSH2|Win32 = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		LIB Release - DLL OpenSSL - DLL LibSSH2|x64 = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
+		LIB Release - DLL OpenSSL - DLL libssh2|Win32 = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		LIB Release - DLL OpenSSL - DLL libssh2|x64 = LIB Release - DLL OpenSSL - DLL libssh2|x64
 		LIB Release - DLL OpenSSL|Win32 = LIB Release - DLL OpenSSL|Win32
 		LIB Release - DLL OpenSSL|x64 = LIB Release - DLL OpenSSL|x64
 		LIB Release - DLL Windows SSPI - DLL WinIDN|Win32 = LIB Release - DLL Windows SSPI - DLL WinIDN|Win32
 		LIB Release - DLL Windows SSPI - DLL WinIDN|x64 = LIB Release - DLL Windows SSPI - DLL WinIDN|x64
 		LIB Release - DLL Windows SSPI|Win32 = LIB Release - DLL Windows SSPI|Win32
 		LIB Release - DLL Windows SSPI|x64 = LIB Release - DLL Windows SSPI|x64
-		LIB Release - LIB OpenSSL - LIB LibSSH2|Win32 = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		LIB Release - LIB OpenSSL - LIB LibSSH2|x64 = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
+		LIB Release - LIB OpenSSL - LIB libssh2|Win32 = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		LIB Release - LIB OpenSSL - LIB libssh2|x64 = LIB Release - LIB OpenSSL - LIB libssh2|x64
 		LIB Release - LIB OpenSSL|Win32 = LIB Release - LIB OpenSSL|Win32
 		LIB Release - LIB OpenSSL|x64 = LIB Release - LIB OpenSSL|x64
 		LIB Release - LIB wolfSSL|Win32 = LIB Release - LIB wolfSSL|Win32
@@ -62,10 +62,10 @@ Global
 		LIB Release|x64 = LIB Release|x64
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = DLL Debug - DLL OpenSSL - DLL LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL libssh2|Win32.Build.0 = DLL Debug - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = DLL Debug - DLL OpenSSL - DLL libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL - DLL libssh2|x64.Build.0 = DLL Debug - DLL OpenSSL - DLL libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL|Win32.ActiveCfg = DLL Debug - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL|Win32.Build.0 = DLL Debug - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug - DLL OpenSSL|x64.ActiveCfg = DLL Debug - DLL OpenSSL|x64
@@ -86,10 +86,10 @@ Global
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug|Win32.Build.0 = DLL Debug|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug|x64.ActiveCfg = DLL Debug|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Debug|x64.Build.0 = DLL Debug|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = DLL Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = DLL Release - DLL OpenSSL - DLL LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL libssh2|Win32.Build.0 = DLL Release - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = DLL Release - DLL OpenSSL - DLL libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL - DLL libssh2|x64.Build.0 = DLL Release - DLL OpenSSL - DLL libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL|Win32.ActiveCfg = DLL Release - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL|Win32.Build.0 = DLL Release - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release - DLL OpenSSL|x64.ActiveCfg = DLL Release - DLL OpenSSL|x64
@@ -110,10 +110,10 @@ Global
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release|Win32.Build.0 = DLL Release|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release|x64.ActiveCfg = DLL Release|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.DLL Release|x64.Build.0 = DLL Release|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = LIB Debug - DLL OpenSSL - DLL LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL libssh2|Win32.Build.0 = LIB Debug - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = LIB Debug - DLL OpenSSL - DLL libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL - DLL libssh2|x64.Build.0 = LIB Debug - DLL OpenSSL - DLL libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL|Win32.ActiveCfg = LIB Debug - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL|Win32.Build.0 = LIB Debug - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL OpenSSL|x64.ActiveCfg = LIB Debug - DLL OpenSSL|x64
@@ -126,10 +126,10 @@ Global
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL Windows SSPI|Win32.Build.0 = LIB Debug - DLL Windows SSPI|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL Windows SSPI|x64.ActiveCfg = LIB Debug - DLL Windows SSPI|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - DLL Windows SSPI|x64.Build.0 = LIB Debug - DLL Windows SSPI|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32.ActiveCfg = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32.Build.0 = LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB LibSSH2|x64.ActiveCfg = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB LibSSH2|x64.Build.0 = LIB Debug - LIB OpenSSL - LIB LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB libssh2|Win32.ActiveCfg = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB libssh2|Win32.Build.0 = LIB Debug - LIB OpenSSL - LIB libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB libssh2|x64.ActiveCfg = LIB Debug - LIB OpenSSL - LIB libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL - LIB libssh2|x64.Build.0 = LIB Debug - LIB OpenSSL - LIB libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL|Win32.ActiveCfg = LIB Debug - LIB OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL|Win32.Build.0 = LIB Debug - LIB OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug - LIB OpenSSL|x64.ActiveCfg = LIB Debug - LIB OpenSSL|x64
@@ -142,10 +142,10 @@ Global
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug|Win32.Build.0 = LIB Debug|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug|x64.ActiveCfg = LIB Debug|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Debug|x64.Build.0 = LIB Debug|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL LibSSH2|Win32.ActiveCfg = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL LibSSH2|Win32.Build.0 = LIB Release - DLL OpenSSL - DLL LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL LibSSH2|x64.ActiveCfg = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL LibSSH2|x64.Build.0 = LIB Release - DLL OpenSSL - DLL LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL libssh2|Win32.ActiveCfg = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL libssh2|Win32.Build.0 = LIB Release - DLL OpenSSL - DLL libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL libssh2|x64.ActiveCfg = LIB Release - DLL OpenSSL - DLL libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL - DLL libssh2|x64.Build.0 = LIB Release - DLL OpenSSL - DLL libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL|Win32.ActiveCfg = LIB Release - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL|Win32.Build.0 = LIB Release - DLL OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL OpenSSL|x64.ActiveCfg = LIB Release - DLL OpenSSL|x64
@@ -158,10 +158,10 @@ Global
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL Windows SSPI|Win32.Build.0 = LIB Release - DLL Windows SSPI|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL Windows SSPI|x64.ActiveCfg = LIB Release - DLL Windows SSPI|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - DLL Windows SSPI|x64.Build.0 = LIB Release - DLL Windows SSPI|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB LibSSH2|Win32.ActiveCfg = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB LibSSH2|Win32.Build.0 = LIB Release - LIB OpenSSL - LIB LibSSH2|Win32
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB LibSSH2|x64.ActiveCfg = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
-		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB LibSSH2|x64.Build.0 = LIB Release - LIB OpenSSL - LIB LibSSH2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB libssh2|Win32.ActiveCfg = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB libssh2|Win32.Build.0 = LIB Release - LIB OpenSSL - LIB libssh2|Win32
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB libssh2|x64.ActiveCfg = LIB Release - LIB OpenSSL - LIB libssh2|x64
+		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL - LIB libssh2|x64.Build.0 = LIB Release - LIB OpenSSL - LIB libssh2|x64
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL|Win32.ActiveCfg = LIB Release - LIB OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL|Win32.Build.0 = LIB Release - LIB OpenSSL|Win32
 		{5228E9CE-A216-422F-A5E6-58E95E2DD71D}.LIB Release - LIB OpenSSL|x64.ActiveCfg = LIB Release - LIB OpenSSL|x64
diff --git a/projects/Windows/VC12/src/curl.tmpl b/projects/Windows/VC12/src/curl.tmpl
index 77c244e40..2e9438dd8 100644
--- a/projects/Windows/VC12/src/curl.tmpl
+++ b/projects/Windows/VC12/src/curl.tmpl
@@ -9,12 +9,12 @@
       <Configuration>DLL Debug - DLL wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>DLL Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>DLL Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>DLL Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Debug - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>DLL Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="DLL Debug - DLL OpenSSL|Win32">
@@ -57,12 +57,12 @@
       <Configuration>DLL Release - DLL wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>DLL Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>DLL Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>DLL Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="DLL Release - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>DLL Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="DLL Release - DLL OpenSSL|Win32">
@@ -97,12 +97,12 @@
       <Configuration>DLL Release</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>LIB Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>LIB Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>LIB Debug - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>LIB Debug - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Debug - DLL OpenSSL|Win32">
@@ -137,12 +137,12 @@
       <Configuration>LIB Debug - LIB wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32">
-      <Configuration>LIB Debug - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB libssh2|Win32">
+      <Configuration>LIB Debug - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB LibSSH2|x64">
-      <Configuration>LIB Debug - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Debug - LIB OpenSSL - LIB libssh2|x64">
+      <Configuration>LIB Debug - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Debug - LIB OpenSSL|Win32">
@@ -161,12 +161,12 @@
       <Configuration>LIB Debug</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL LibSSH2|Win32">
-      <Configuration>LIB Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL libssh2|Win32">
+      <Configuration>LIB Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL LibSSH2|x64">
-      <Configuration>LIB Release - DLL OpenSSL - DLL LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - DLL OpenSSL - DLL libssh2|x64">
+      <Configuration>LIB Release - DLL OpenSSL - DLL libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Release - DLL OpenSSL|Win32">
@@ -201,12 +201,12 @@
       <Configuration>LIB Release - LIB wolfSSL</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB LibSSH2|Win32">
-      <Configuration>LIB Release - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB libssh2|Win32">
+      <Configuration>LIB Release - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB LibSSH2|x64">
-      <Configuration>LIB Release - LIB OpenSSL - LIB LibSSH2</Configuration>
+    <ProjectConfiguration Include="LIB Release - LIB OpenSSL - LIB libssh2|x64">
+      <Configuration>LIB Release - LIB OpenSSL - LIB libssh2</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="LIB Release - LIB OpenSSL|Win32">
@@ -255,13 +255,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -279,13 +279,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -303,13 +303,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -423,13 +423,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -447,13 +447,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -471,13 +471,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v120</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="Configuration">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>Unicode</CharacterSet>
@@ -582,10 +582,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|Win32'" Label="PropertySheets">
@@ -594,10 +594,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|Win32'" Label="PropertySheets">
@@ -606,10 +606,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|Win32'" Label="PropertySheets">
@@ -666,10 +666,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'" Label="PropertySheets">
@@ -678,10 +678,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'" Label="PropertySheets">
@@ -690,10 +690,10 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|x64'" Label="PropertySheets">
@@ -825,18 +825,18 @@
     <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|x64'">$(OutDir)src\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|x64'">false</LinkIncremental>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">$(OutDir)src\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">false</LinkIncremental>
@@ -849,18 +849,18 @@
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">$(OutDir)src\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">false</LinkIncremental>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">$(OutDir)src\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">false</LinkIncremental>
@@ -873,18 +873,18 @@
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">$(OutDir)src\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">$(OutDir)src\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">..\..\..\..\build\Win64\VC12\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">$(OutDir)src\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">false</LinkIncremental>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'">..\..\..\..\build\Win32\VC12\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">$(OutDir)src\</IntDir>
@@ -915,8 +915,8 @@
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL wolfSSL|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL Windows SSPI|x64'">$(ProjectName)d</TargetName>
@@ -927,41 +927,41 @@
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB wolfSSL|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL Windows SSPI - DLL WinIDN|x64'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|Win32'">$(ProjectName)d</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">$(ProjectName)d</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">$(ProjectName)d</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL wolfSSL|Win32'">$(ProjectName)</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI - DLL WinIDN|Win32'">$(ProjectName)</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release|Win32'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB wolfSSL|Win32'">$(ProjectName)</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL Windows SSPI - DLL WinIDN|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL wolfSSL|x64'">$(ProjectName)</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL Windows SSPI - DLL WinIDN|x64'">$(ProjectName)</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">$(ProjectName)</TargetName>
+    <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release|x64'">$(ProjectName)</TargetName>
     <TargetName Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB wolfSSL|x64'">$(ProjectName)</TargetName>
@@ -1828,7 +1828,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -1859,7 +1859,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Debug - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -1891,7 +1891,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -1920,7 +1920,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DLL Release - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -2072,7 +2072,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -2103,7 +2103,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - LIB OpenSSL - LIB libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -2135,7 +2135,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -2164,7 +2164,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - LIB OpenSSL - LIB libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -2316,7 +2316,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -2347,7 +2347,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Debug - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -2379,7 +2379,7 @@
       <TargetMachine>MachineX64</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|Win32'">
     <Midl>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
       <HeaderFileName>
@@ -2408,7 +2408,7 @@
       <TargetMachine>MachineX86</TargetMachine>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL LibSSH2|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='LIB Release - DLL OpenSSL - DLL libssh2|x64'">
     <Midl>
       <TargetEnvironment>X64</TargetEnvironment>
       <TypeLibraryName>$(TargetDir)$(TargetName).tlb</TypeLibraryName>
@@ -2696,4 +2696,4 @@ CURL_SRC_RC_FILES
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
   </ImportGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/projects/Windows/VC12/src/curl.vcxproj.filters b/projects/Windows/VC12/src/curl.vcxproj.filters
index 4d6341d74..d2b9907aa 100644
--- a/projects/Windows/VC12/src/curl.vcxproj.filters
+++ b/projects/Windows/VC12/src/curl.vcxproj.filters
@@ -14,4 +14,4 @@
       <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
     </Filter>
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/projects/build-openssl.bat b/projects/build-openssl.bat
index b64538341..f1ebbddbd 100644
--- a/projects/build-openssl.bat
+++ b/projects/build-openssl.bat
@@ -241,7 +241,7 @@ rem ***************************************************************************
   echo.
 
   cd /d "%START_DIR%" || (echo Error: Failed cd start & exit /B 1)
-  rem Save the full path of the openssl source dir
+  rem Save the full path of the OpenSSL source dir
   set "SOURCE_PATH=%CD%"
 
   rem Set temporary paths for building and installing OpenSSL. If a temporary
diff --git a/renovate.json b/renovate.json
index da5ee6d49..85a742423 100644
--- a/renovate.json
+++ b/renovate.json
@@ -72,7 +72,7 @@
       "customType": "regex",
       "fileMatch": [
         "^.github/workflows/linux.yml$",
-        "^.github/workflows/osslq-linux.yml$"
+        "^.github/workflows/http3-linux.yml$"
       ],
       "matchStrings": [
         "openssl3-version: (?<currentValue>.*)\\s"
diff --git a/scripts/cd2nroff b/scripts/cd2nroff
index 647a28969..00b2cc05e 100755
--- a/scripts/cd2nroff
+++ b/scripts/cd2nroff
@@ -25,7 +25,7 @@
 
 =begin comment
 
-Converts a curldown file to nroff (man page).
+Converts a curldown file to nroff (manpage).
 
 =end comment
 =cut
@@ -103,15 +103,25 @@ sub outprotocols {
     push @o, ".SH PROTOCOLS\n";
 
     if($p[0] eq "TLS") {
-        push @o, "All TLS based protocols: HTTPS, FTPS, IMAPS, POP3S, SMTPS etc.";
+        push @o, "This functionality affects all TLS based protocols: HTTPS, FTPS, IMAPS, POP3S, SMTPS etc.";
     }
     else {
         my @s = sort @p;
+        push @o, "This functionality affects ";
         for my $e (sort @s) {
-            push @o, sprintf "%s$e",
-                $comma ? (($e eq $s[-1]) ? " and " : ", "): "";
+            push @o, sprintf "%s%s",
+                $comma ? (($e eq $s[-1]) ? " and " : ", "): "",
+                lc($e);
             $comma = 1;
         }
+        if($#s == 0) {
+            if($s[0] eq "All") {
+                push @o, " supported protocols";
+            }
+            else {
+                push @o, " only";
+            }
+        }
     }
     push @o, "\n";
     return @o;
@@ -197,6 +207,7 @@ sub single {
     my $tlslist;
     my $section;
     my $source;
+    my $addedin;
     my $spdx;
     my $start = 0;
     my $title;
@@ -247,6 +258,14 @@ sub single {
         elsif(/^TLS-backend:/i) {
             $list = 3; # 3 for TLS backend
         }
+        elsif(/^Added-in: *(.*)/i) {
+            $addedin=$1;
+            if(($addedin !~ /^[0-9.]+[0-9]\z/) &&
+               ($addedin ne "n/a")) {
+                print STDERR "$f:$line:1:ERROR: invalid version number in Added-in line: $addedin\n";
+                return 2;
+            }
+        }
         elsif(/^ +- (.*)/i) {
             # the only lists we support are see-also and protocol
             if($list == 1) {
@@ -274,11 +293,19 @@ sub single {
         elsif(/^---/) {
             # end of the header section
             if(!$title) {
-                print STDERR "ERROR: no 'Title:' in $f\n";
+                print STDERR "$f:$line:1:ERROR: no 'Title:' in $f\n";
                 return 1;
             }
             if(!$section) {
-                print STDERR "ERROR: no 'Section:' in $f\n";
+                print STDERR "$f:$line:1:ERROR: no 'Section:' in $f\n";
+                return 2;
+            }
+            if(!$source) {
+                print STDERR "$f:$line:1:ERROR: no 'Source:' in $f\n";
+                return 2;
+            }
+            if(!$addedin) {
+                print STDERR "$f:$line:1:ERROR: no 'Added-in:' in $f\n";
                 return 2;
             }
             if(!$seealso[0]) {
@@ -326,7 +353,8 @@ sub single {
         }
         else {
             chomp;
-            print STDERR "WARN: unrecognized line in $f, ignoring:\n:'$_';"
+            print STDERR "$f:$line:1:ERROR: unrecognized header keyword: '$_'\n";
+            $errors++;
         }
     }
 
@@ -387,12 +415,13 @@ sub single {
         $d =~ s/\*(\S.*?)\*/\\fI$1\\fP/g;
 
         if($d =~ /[^\\][\<\>]/) {
-            print STDERR "$f:$line:1:WARN: un-escaped < or > used\n";
+            print STDERR "$f:$line:1:ERROR: un-escaped < or > used\n";
+            $errors++;
         }
         # convert backslash-'<' or '> to just the second character
         $d =~ s/\\([<>])/$1/g;
 
-        # mentions of curl symbols with man pages use italics by default
+        # mentions of curl symbols with manpages use italics by default
         $d =~ s/((lib|)curl([^ ]*\(3\)))/\\fI$1\\fP/gi;
 
         # backticked becomes italics
@@ -412,6 +441,11 @@ sub single {
             }
             $header = 1;
         }
+        elsif(/^##/) {
+            # end of IP sequence
+            push @desc, ".PP\n";
+            $header = 1;
+        }
         elsif(/^# (.*)/) {
             my $word = $1;
             # if there are enclosing quotes, remove them first
@@ -420,13 +454,27 @@ sub single {
             if($word eq "PROTOCOLS") {
                 print STDERR "$f:$line:1:WARN: PROTOCOLS section in source file\n";
             }
-            elsif($word eq "EXAMPLE") {
-                # insert the generated PROTOCOLS section before EXAMPLE
+            elsif($word eq "AVAILABILITY") {
+                print STDERR "$f:$line:1:WARN: AVAILABILITY section in source file\n";
+            }
+            elsif($word eq "%PROTOCOLS%") {
+                # insert the generated PROTOCOLS section
                 push @desc, outprotocols(@proto);
 
                 if($proto[0] eq "TLS") {
                     push @desc, outtls(@tls);
                 }
+                $header = 1;
+                next;
+            }
+            elsif($word eq "%AVAILABILITY%") {
+                if($addedin ne "n/a") {
+                    # insert the generated AVAILABILITY section
+                    push @desc, ".SH AVAILABILITY\n";
+                    push @desc, "Added in curl $addedin\n";
+                }
+                $header = 1;
+                next;
             }
             push @desc, ".SH $word\n";
             $header = 1;
diff --git a/scripts/ciconfig.pl b/scripts/ciconfig.pl
index e232e3e5e..93358def2 100755
--- a/scripts/ciconfig.pl
+++ b/scripts/ciconfig.pl
@@ -1,4 +1,4 @@
-#!/usr/bin/perl
+#!/usr/bin/env perl
 #***************************************************************************
 #                                  _   _ ____  _
 #  Project                     ___| | | |  _ \| |
diff --git a/scripts/cijobs.pl b/scripts/cijobs.pl
index 150e2cb8f..7d0a2dec7 100755
--- a/scripts/cijobs.pl
+++ b/scripts/cijobs.pl
@@ -1,4 +1,4 @@
-#!/usr/bin/perl
+#!/usr/bin/env perl
 #***************************************************************************
 #                                  _   _ ____  _
 #  Project                     ___| | | |  _ \| |
diff --git a/scripts/cmp-config.pl b/scripts/cmp-config.pl
index ebd7c2fb2..b50d76959 100755
--- a/scripts/cmp-config.pl
+++ b/scripts/cmp-config.pl
@@ -47,6 +47,8 @@ my %remove = (
     '#define HAVE_IOCTL 1' => 1,
     '#define HAVE_LDAP_SSL 1' => 1,
     '#define HAVE_LIBBROTLIDEC 1' => 1,
+    '#define HAVE_LIBSOCKET 1' => 1,
+    '#define HAVE_LIBSSH2 1' => 1,
     '#define HAVE_LIBSSL 1' => 1,
     '#define HAVE_LIBZSTD 1' => 1,
     '#define HAVE_OPENSSL3 1' => 1,
diff --git a/scripts/contrithanks.sh b/scripts/contrithanks.sh
index f60961762..2afc30c24 100755
--- a/scripts/contrithanks.sh
+++ b/scripts/contrithanks.sh
@@ -70,4 +70,4 @@ cat ./docs/THANKS
 } | \
 sed -f ./docs/THANKS-filter | \
 sort -fu | \
-grep -aixvf ./docs/THANKS
+grep -aixvFf ./docs/THANKS
diff --git a/scripts/copyright.pl b/scripts/copyright.pl
deleted file mode 100755
index 376f023e7..000000000
--- a/scripts/copyright.pl
+++ /dev/null
@@ -1,233 +0,0 @@
-#!/usr/bin/env perl
-#***************************************************************************
-#                                  _   _ ____  _
-#  Project                     ___| | | |  _ \| |
-#                             / __| | | | |_) | |
-#                            | (__| |_| |  _ <| |___
-#                             \___|\___/|_| \_\_____|
-#
-# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
-#
-# This software is licensed as described in the file COPYING, which
-# you should have received as part of this distribution. The terms
-# are also available at https://curl.se/docs/copyright.html.
-#
-# You may opt to use, copy, modify, merge, publish, distribute and/or sell
-# copies of the Software, and permit persons to whom the Software is
-# furnished to do so, under the terms of the COPYING file.
-#
-# This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
-# KIND, either express or implied.
-#
-# SPDX-License-Identifier: curl
-#
-###########################################################################
-#
-# Invoke script in the root of the git checkout. Scans all files in git unless
-# given a specific single file.
-#
-# Usage: copyright.pl [file]
-#
-
-my %skips;
-
-# file names
-my %skiplist = (
-    # REUSE-specific file
-    ".reuse/dep5" => "<built-in>",
-
-    # License texts
-    "LICENSES/BSD-3-Clause.txt" => "<built-in>",
-    "LICENSES/BSD-4-Clause-UC.txt" => "<built-in>",
-    "LICENSES/ISC.txt" => "<built-in>",
-    "LICENSES/curl.txt" => "<built-in>",
-    "COPYING" => "<built-in>",
-
-    );
-
-sub scanfile {
-    my ($f) = @_;
-    my $line=1;
-    my $found = 0;
-    open(F, "<$f") || return -1;
-    while (<F>) {
-        chomp;
-        my $l = $_;
-        # check for a copyright statement and save the years
-        if($l =~ /.* ?copyright .* (\d\d\d\d|)/i) {
-            my $count = 0;
-            while($l =~ /([\d]{4})/g) {
-                push @copyright, {
-                  year => $1,
-                  line => $line,
-                  col => index($l, $1),
-                  code => $l
-                };
-                $count++;
-            }
-            if(!$count) {
-                # year-less
-                push @copyright, {
-                    year => -1,
-                    line => $line,
-                    col => index($l, $1),
-                    code => $l
-                };
-                $count++;
-            }
-            $found = $count;
-        }
-        if($l =~ /SPDX-License-Identifier:/) {
-            $spdx = 1;
-        }
-        # allow within the first 100 lines
-        if(++$line > 100) {
-            last;
-        }
-    }
-    close(F);
-    return $found;
-}
-
-sub checkfile {
-    my ($file, $skipped, $pattern) = @_;
-    $spdx = 0;
-    my $found = scanfile($file);
-
-    if($found < 1) {
-        if($skipped) {
-            # just move on
-            $skips{$pattern}++;
-            return 0;
-        }
-        if(!$found) {
-            print "$file:1: missing copyright range\n";
-            return 2;
-        }
-        # this means the file couldn't open - it might not exist, consider
-        # that fine
-        return 1;
-    }
-    if(!$spdx) {
-        if($skipped) {
-            # move on
-            $skips{$pattern}++;
-            return 0;
-        }
-        print "$file:1: missing SPDX-License-Identifier\n";
-        return 2;
-    }
-
-    if($skipped) {
-        print "$file:1: ignored superfluously by $pattern\n" if($verbose);
-        $superf{$pattern}++;
-    }
-
-    return 1;
-}
-
-sub dep5 {
-    my ($file) = @_;
-    my @files;
-    my $copy;
-    open(F, "<$file") || die "can't open $file";
-    my $line = 0;
-    while(<F>) {
-        $line++;
-        if(/^Files: (.*)/i) {
-            my @all = `git ls-files $1`;
-            if(!$all[0]) {
-                print STDERR "$1 matches no files\n";
-            }
-            else {
-                push @files, @all;
-            }
-        }
-        elsif(/^Copyright: (.*)/i) {
-            $copy = $1;
-        }
-        elsif(/^License: (.*)/i) {
-            my $license = $1;
-            for my $f (@files) {
-                chomp $f;
-                if($f =~ /\.gitignore\z/) {
-                    # ignore .gitignore
-                }
-                else {
-                    if($skiplist{$f}) {
-                        print STDERR "$f already skipped at $skiplist{$f}\n";
-                    }
-                    $skiplist{$f} = "dep5:$line";
-                }
-            }
-            undef @files;
-        }
-    }
-    close(F);
-}
-
-dep5(".reuse/dep5");
-
-my $checkall = 0;
-my @all;
-my $verbose;
-if($ARGV[0] eq "-v") {
-    $verbose = 1;
-    shift @ARGV;
-}
-if($ARGV[0]) {
-    push @all, @ARGV;
-}
-else {
-    @all = `git ls-files`;
-    $checkall = 1;
-}
-
-for my $f (@all) {
-    chomp $f;
-    my $skipped = 0;
-    my $miss;
-    my $wro;
-    my $pattern;
-    if($skiplist{$f}) {
-        $pattern = $skip;
-        $skiplisted++;
-        $skipped = 1;
-        $skip{$f}++;
-    }
-
-    my $r = checkfile($f, $skipped, $pattern);
-    $mis=1 if($r == 2);
-    $wro=1 if(!$r);
-
-    if(!$skipped) {
-        $missing += $mis;
-        $wrong += $wro;
-    }
-}
-
-if($verbose) {
-    print STDERR "$missing files have no copyright\n" if($missing);
-    print STDERR "$wrong files have wrong copyright year\n" if ($wrong);
-    print STDERR "$skiplisted files are skipped\n" if ($skiplisted);
-
-    for my $s (@skiplist) {
-        if(!$skips{$s}) {
-            printf ("Never skipped pattern: %s\n", $s);
-        }
-        if($superf{$s}) {
-            printf ("%s was skipped superfluously %u times and legitimately %u times\n",
-                    $s, $superf{$s}, $skips{$s});
-        }
-    }
-}
-
-if($checkall) {
-    for(keys %skiplist) {
-        if(!$skip{$_}) {
-            printf STDERR "$_ is marked for SKIP but is missing!\n";
-        }
-    }
-}
-
-exit 1 if($missing || $wrong);
diff --git a/scripts/managen b/scripts/managen
index 8f1678398..7cdb65817 100755
--- a/scripts/managen
+++ b/scripts/managen
@@ -59,7 +59,9 @@ my $year = strftime "%Y", @ts;
 my $version = "unknown";
 my $globals;
 
-# get the long name version, return the man page string
+my $indent = 4;
+
+# get the long name version, return the manpage string
 sub manpageify {
     my ($k)=@_;
     my $l;
@@ -85,13 +87,19 @@ sub manpageify {
 }
 
 
-my $colwidth=78; # max number of columns
+my $colwidth=79; # max number of columns
+
+sub prefixline {
+    my ($num) = @_;
+    print "\t" x ($num/8);
+    print ' ' x ($num%8);
+}
 
 sub justline {
     my ($lvl, @line) = @_;
     my $w = -1;
     my $spaces = -1;
-    my $width = $colwidth - ($lvl * 4);
+    my $width = $colwidth - ($lvl * $indent);
     for(@line) {
         $w += length($_);
         $w++;
@@ -103,7 +111,7 @@ sub justline {
         $ratio = $inject / $spaces;
     }
     my $spare = 0;
-    print ' ' x ($lvl * 4);
+    prefixline($lvl * $indent);
     my $prev;
     for(@line) {
         while($spare >= 0.90) {
@@ -119,7 +127,7 @@ sub justline {
 
 sub lastline {
     my ($lvl, @line) = @_;
-    print ' ' x ($lvl * 4);
+    prefixline($lvl * $indent);
     my $prev = 0;
     for(@line) {
         printf "%s%s", $prev?" ":"", $_;
@@ -134,7 +142,7 @@ sub outputpara {
 
     my $w = 0;
     my @words = split(/  */, $f);
-    my $width = $colwidth - ($lvl * 4);
+    my $width = $colwidth - ($lvl * $indent);
 
     my @line;
     for my $e (@words) {
@@ -237,8 +245,8 @@ sub too_old {
     elsif($version =~ /^(\d+)\.(\d+)/) {
         $a = $1 * 1000 + $2 * 10;
     }
-    if($a < 7500) {
-        # we consider everything before 7.50.0 to be too old to mention
+    if($a < 7600) {
+        # we consider everything before 7.60.0 to be too old to mention
         # specific changes for
         return 1;
     }
@@ -268,11 +276,13 @@ sub render {
     my $top = ($line == 1);
     my $quote;
     my $level;
+    my $finalblank;
     $start = 0;
 
     while(<$fh>) {
         my $d = $_;
         $line++;
+        $finalblank = ($d eq "\n");
         if($d =~ /^\.(SH|BR|IP|B)/) {
             print STDERR "$f:$line:1:ERROR: nroff instruction in input: \".$1\"\n";
             return 4;
@@ -307,9 +317,9 @@ sub render {
             $word =~ s/[\"\'](.*)[\"\']\z/$1/;
 
             # remove backticks from headers
-            $words =~ s/\`//g;
+            $word =~ s/\`//g;
 
-            # if there is a space, it needs quotes for man page
+            # if there is a space, it needs quotes for manpage
             if(($word =~ / /) && $manpage) {
                 $word = "\"$word\"";
             }
@@ -338,7 +348,7 @@ sub render {
             }
             if($tablemode) {
                 # end of table
-                push @desc, ".RE\n.IP\n";
+                push @desc, ".RE\n.IP\n" if($manpage);
                 $tablemode = 0;
             }
             $header = 1;
@@ -375,10 +385,19 @@ sub render {
         # convert backticks to double quotes
         $d =~ s/\`/\"/g;
 
+        if($d =~ /\(added in(.*)/i) {
+            if(length($1) < 2) {
+                print STDERR "$f:$line:1:ERROR: broken up added-in line:\n";
+                print STDERR "$f:$line:1:ERROR: $d";
+                return 3;
+            }
+        }
+      again:
         if($d =~ /\(Added in ([0-9.]+)\)/i) {
             my $ver = $1;
             if(too_old($ver)) {
                 $d =~ s/ *\(Added in $ver\)//gi;
+                goto again;
             }
         }
 
@@ -431,6 +450,14 @@ sub render {
         $header = 0;
 
     }
+    if($finalblank) {
+        print STDERR "$f:$line:1:ERROR: trailing blank line\n";
+        exit 3;
+    }
+    if($quote) {
+        # don't leave the quote "hanging"
+        push @desc, ".fi\n" if($manpage);
+    }
     if($tablemode) {
         # end of table
         push @desc, ".RE\n.IP\n" if($manpage);
@@ -640,6 +667,10 @@ sub single {
     my $pre = $manpage ? "\n": "[1]";
 
     if($scope) {
+        if($category !~ /global/) {
+            print STDERR "$f:$line:1:ERROR: global scope option does not have global category\n";
+            return 2;
+        }
         if($scope eq "global") {
             push @desc, "\n" if(!$manpage);
             push @desc, "${pre}This option is global and does not need to be specified for each use of --next.\n";
@@ -650,9 +681,6 @@ sub single {
         }
     }
 
-    printdesc($manpage, 2, (@leading, @desc));
-    undef @desc;
-
     my @extra;
     if($multi eq "single") {
         push @extra, "${pre}If --$long is provided several times, the last set ".
@@ -681,12 +709,18 @@ sub single {
     elsif($multi eq "custom") {
         ; # left for the text to describe
     }
+    elsif($multi eq "per-URL") {
+        push @extra,
+            "${pre}--$long is associated with a single URL. Use it once per URL ".
+            "when you use several URLs in a command line.\n";
+    }
     else {
         print STDERR "$f:$line:1:ERROR: unrecognized Multi: '$multi'\n";
         return 2;
     }
 
-    printdesc($manpage, 2, @extra);
+    printdesc($manpage, 2, (@leading, @desc, @extra));
+    undef @desc;
 
     my @foot;
 
@@ -710,25 +744,31 @@ sub single {
         $mstr .= sprintf "%s$l", $mstr?"$sep ":"";
         $i++;
     }
-    push @foot, seealso($standalone, $mstr);
 
     if($requires) {
         my $l = $manpage ? manpageify($long) : "--$long";
-        push @foot, "$l requires that the underlying libcurl".
-            " was built to support $requires. ";
+        push @foot, "$l requires that libcurl".
+            " is built to support $requires.\n";
     }
     if($mutexed) {
         my @m=split(/ /, $mutexed);
         my $mstr;
+        my $num = scalar(@m);
+        my $count;
         for my $k (@m) {
             if(!$helplong{$k}) {
                 print STDERR "WARN: $f mutexes a non-existing option: $k\n";
             }
             my $l = $manpage ? manpageify($k) : "--$k";
-            $mstr .= sprintf "%s$l", $mstr?" and ":"";
+            my $sep = ", ";
+            if($count == ($num -1)) {
+                $sep = " and ";
+            }
+            $mstr .= sprintf "%s$l", $mstr?$sep:"";
+            $count++;
         }
         push @foot, overrides($standalone,
-                              "This option is mutually exclusive to $mstr. ");
+                              "This option is mutually exclusive with $mstr.\n");
     }
     if($examples[0]) {
         my $s ="";
@@ -757,16 +797,16 @@ sub single {
     if($added) {
         push @foot, added($standalone, $added);
     }
-    if($foot[0]) {
-        print "\n";
-        my $f = join("", @foot);
-        if($manpage) {
-            $f =~ s/ +\z//; # remove trailing space
-            print "$f\n";
-        }
-        else {
-            printdesc($manpage, 2, "[1]$f");
-        }
+    push @foot, seealso($standalone, $mstr);
+
+    print "\n";
+    my $f = join("", @foot);
+    if($manpage) {
+        $f =~ s/ +\z//; # remove trailing space
+        print "$f\n";
+    }
+    else {
+        printdesc($manpage, 2, "[1]$f");
     }
     return 0;
 }
@@ -783,7 +823,9 @@ sub getshortlong {
     my $protocols;
     my $category;
     my $start = 0;
+    my $line = 0;
     while(<F>) {
+        $line++;
         if(!$start) {
             if(/^---/) {
                 $start = 1;
@@ -798,6 +840,11 @@ sub getshortlong {
         }
         elsif(/^Help: (.*)/i) {
             $help=$1;
+            my $len = length($help);
+            if($len >= 49) {
+                printf STDERR "$f:$line:1:WARN: oversized help text: %d characters\n",
+                    $len;
+            }
         }
         elsif(/^Arg: (.*)/i) {
             $arg=$1;
@@ -842,7 +889,25 @@ sub header {
     printdesc($manpage, 0, @d);
 }
 
+
+sub sourcecategories {
+    my ($dir) = @_;
+    my %cats;
+    open(H, "<$dir/../../src/tool_help.h") ||
+        die "can't find the header file";
+    while(<H>) {
+        if(/^\#define CURLHELP_([A-Z0-9]*)/) {
+            $cats{lc($1)}++;
+        }
+    }
+    close(H);
+    return %cats;
+}
+
 sub listhelp {
+    my ($dir) = @_;
+    my %cats = sourcecategories($dir);
+
     print <<HEAD
 /***************************************************************************
  *                                  _   _ ____  _
@@ -895,6 +960,12 @@ HEAD
             $opt = "    --$long";
         }
         for my $i (0 .. $#categories) {
+            if(!$cats{ $categories[$i] }) {
+                printf STDERR "$f.md:ERROR: Unknown category '%s'\n",
+                    $categories[$i];
+                exit 3;
+            }
+
             $bitmask .= 'CURLHELP_' . uc $categories[$i];
             # If not last element, append |
             if($i < $#categories) {
@@ -920,7 +991,7 @@ HEAD
         print $line;
     }
     print <<FOOT
-  { NULL, NULL, CURLHELP_HIDDEN }
+  { NULL, NULL, 0 }
 };
 FOOT
         ;
@@ -939,9 +1010,9 @@ sub listcats {
         push @categories, $key;
     }
     @categories = sort @categories;
-    unshift @categories, 'hidden';
     for my $i (0..$#categories) {
-        print '#define ' . 'CURLHELP_' . uc($categories[$i]) . ' ' . "1u << " . $i . "u\n";
+        printf("#define CURLHELP_%-10s (%s)\n",
+               uc($categories[$i]), "1u << ${i}u");
     }
 }
 
@@ -1025,7 +1096,7 @@ sub mainpage {
 .\\" *
 .\\" **************************************************************************
 .\\"
-.\\" DO NOT EDIT. Generated by the curl project managen man page generator.
+.\\" DO NOT EDIT. Generated by the curl project managen manpage generator.
 .\\"
 .TH curl 1 "$date" "curl $version" "curl Manual"
 HEADER
@@ -1086,7 +1157,7 @@ sub getargs {
         return;
     }
     elsif($f eq "listhelp") {
-        listhelp();
+        listhelp($dir);
         return;
     }
     elsif($f eq "single") {
@@ -1125,6 +1196,12 @@ elsif($cmd eq "-I") {
     $cmd = shift @ARGV;
     goto check;
 }
+elsif($cmd eq "-c") {
+    # Column width
+    $colwidth = 0 + shift @ARGV;
+    $cmd = shift @ARGV;
+    goto check;
+}
 
 my @files = @ARGV; # the rest are the files
 
diff --git a/scripts/mk-ca-bundle.pl b/scripts/mk-ca-bundle.pl
index 83027a489..097171059 100755
--- a/scripts/mk-ca-bundle.pl
+++ b/scripts/mk-ca-bundle.pl
@@ -136,8 +136,6 @@ else {
   $url = $opt_d;
 }
 
-my $curl = `curl -V`;
-
 if ($opt_i) {
   print ("=" x 78 . "\n");
   print "Script Version                   : $version\n";
@@ -314,6 +312,7 @@ if(!$opt_n) {
 
   # If we have an HTTPS URL then use curl
   if($url =~ /^https:\/\//i) {
+    my $curl = `curl -V`;
     if($curl) {
       if($curl =~ /^Protocols:.* https( |$)/m) {
         report "Get certdata with curl!";
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index cd1e9be44..4f3019c7b 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -81,7 +81,7 @@ add_executable(
   )
 
 add_library(
-  curltool # special libcurltool library just for unittests
+  curltool  # special libcurltool library just for unittests
   STATIC
   EXCLUDE_FROM_ALL
   ${CURL_CFILES} ${CURLTOOL_LIBCURL_CFILES} ${CURL_HFILES}
@@ -104,23 +104,23 @@ source_group("curl source files" FILES ${CURL_CFILES})
 source_group("curl header files" FILES ${CURL_HFILES})
 
 include_directories(
-  ${CURL_SOURCE_DIR}/lib        # To be able to reach "curl_setup_once.h"
-  ${CURL_BINARY_DIR}/lib        # To be able to reach "curl_config.h"
-  ${CURL_BINARY_DIR}/include    # To be able to reach "curl/curl.h"
+  ${CURL_SOURCE_DIR}/lib      # for "curl_setup_once.h"
+  ${CURL_BINARY_DIR}/lib      # for "curl_config.h"
+  ${CURL_BINARY_DIR}/include  # for "curl/curl.h"
   # This is needed as tool_hugehelp.c is generated in the binary dir
-  ${CURL_SOURCE_DIR}/src        # To be able to reach "tool_hugehelp.h"
+  ${CURL_SOURCE_DIR}/src      # for "tool_hugehelp.h"
   )
 
-#Build curl executable
+# Build curl executable
 target_link_libraries(${EXE_NAME} ${LIB_SELECTED_FOR_EXE} ${CURL_LIBS})
 
 ################################################################################
 
-#SET_TARGET_PROPERTIES(${EXE_NAME} ARCHIVE_OUTPUT_DIRECTORY "blah blah blah")
-#SET_TARGET_PROPERTIES(${EXE_NAME} RUNTIME_OUTPUT_DIRECTORY "blah blah blah")
-#SET_TARGET_PROPERTIES(${EXE_NAME} LIBRARY_OUTPUT_DIRECTORY "blah blah blah")
+#set_target_properties(${EXE_NAME} ARCHIVE_OUTPUT_DIRECTORY "blah blah blah")
+#set_target_properties(${EXE_NAME} RUNTIME_OUTPUT_DIRECTORY "blah blah blah")
+#set_target_properties(${EXE_NAME} LIBRARY_OUTPUT_DIRECTORY "blah blah blah")
 
-#INCLUDE(ModuleInstall OPTIONAL)
+#include(ModuleInstall OPTIONAL)
 
 install(TARGETS ${EXE_NAME} EXPORT ${TARGETS_EXPORT_NAME} DESTINATION ${CMAKE_INSTALL_BINDIR})
 export(TARGETS ${EXE_NAME}
diff --git a/src/Makefile.am b/src/Makefile.am
index 3bf57d36c..4ce83c923 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -45,10 +45,6 @@ AM_CPPFLAGS = -I$(top_srcdir)/include        \
 
 bin_PROGRAMS = curl
 
-if BUILD_DOCS
-SUBDIRS = ../docs
-endif
-
 if USE_CPPFLAG_CURL_STATICLIB
 AM_CPPFLAGS += -DCURL_STATICLIB
 endif
@@ -145,7 +141,7 @@ checksrc:
 	$(CHECKSRC)(@PERL@ $(top_srcdir)/scripts/checksrc.pl -D$(srcdir) \
 	-W$(srcdir)/tool_hugehelp.c $(srcdir)/*.[ch])
 
-if CURLDEBUG
+if DEBUGBUILD
 # for debug builds, we scan the sources on all regular make invokes
 all-local: checksrc
 endif
diff --git a/src/Makefile.inc b/src/Makefile.inc
index c1d202a06..93bef122c 100644
--- a/src/Makefile.inc
+++ b/src/Makefile.inc
@@ -34,7 +34,7 @@ CURLTOOL_LIBCURL_CFILES = \
   ../lib/base64.c \
   ../lib/dynbuf.c
 
-# libcurl has sources that provide functions named curlx_* that aren't part of
+# libcurl has sources that provide functions named curlx_* that are not part of
 # the official API, but we reuse the code here to avoid duplication.
 CURLX_CFILES = \
   ../lib/base64.c \
@@ -59,6 +59,7 @@ CURLX_HFILES = \
 
 CURL_CFILES = \
   slist_wc.c \
+  terminal.c \
   tool_binmode.c \
   tool_bname.c \
   tool_cb_dbg.c \
@@ -66,6 +67,7 @@ CURL_CFILES = \
   tool_cb_prg.c \
   tool_cb_rea.c \
   tool_cb_see.c \
+  tool_cb_soc.c \
   tool_cb_wrt.c \
   tool_cfgable.c \
   tool_dirhie.c \
@@ -103,6 +105,7 @@ CURL_CFILES = \
 
 CURL_HFILES = \
   slist_wc.h \
+  terminal.h \
   tool_binmode.h \
   tool_bname.h \
   tool_cb_dbg.h \
@@ -110,6 +113,7 @@ CURL_HFILES = \
   tool_cb_prg.h \
   tool_cb_rea.h \
   tool_cb_see.h \
+  tool_cb_soc.h \
   tool_cb_wrt.h \
   tool_cfgable.h \
   tool_dirhie.h \
diff --git a/src/curl.rc b/src/curl.rc
index 6fcaf353e..475dfbe89 100644
--- a/src/curl.rc
+++ b/src/curl.rc
@@ -32,7 +32,7 @@ VS_VERSION_INFO VERSIONINFO
   FILEVERSION     RC_VERSION
   PRODUCTVERSION  RC_VERSION
   FILEFLAGSMASK   VS_FFI_FILEFLAGSMASK
-#if defined(DEBUGBUILD) || defined(_DEBUG)
+#if defined(DEBUGBUILD) || defined(UNITTESTS) || defined(CURLDEBUG) || defined(_DEBUG)
   FILEFLAGS VS_FF_DEBUG
 #else
   FILEFLAGS 0L
diff --git a/src/mkhelp.pl b/src/mkhelp.pl
index 52b6e13e3..96c2b4192 100755
--- a/src/mkhelp.pl
+++ b/src/mkhelp.pl
@@ -167,6 +167,7 @@ for my $n (@out) {
     chomp $n;
     $n =~ s/\\/\\\\/g;
     $n =~ s/\"/\\\"/g;
+    $n =~ s/\t/\\t/g;
 
     if(!$n) {
         $blank++;
diff --git a/src/terminal.c b/src/terminal.c
new file mode 100644
index 000000000..7ba991d3e
--- /dev/null
+++ b/src/terminal.c
@@ -0,0 +1,91 @@
+/***************************************************************************
+ *                                  _   _ ____  _
+ *  Project                     ___| | | |  _ \| |
+ *                             / __| | | | |_) | |
+ *                            | (__| |_| |  _ <| |___
+ *                             \___|\___/|_| \_\_____|
+ *
+ * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+ *
+ * This software is licensed as described in the file COPYING, which
+ * you should have received as part of this distribution. The terms
+ * are also available at https://curl.se/docs/copyright.html.
+ *
+ * You may opt to use, copy, modify, merge, publish, distribute and/or sell
+ * copies of the Software, and permit persons to whom the Software is
+ * furnished to do so, under the terms of the COPYING file.
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+ * KIND, either express or implied.
+ *
+ * SPDX-License-Identifier: curl
+ *
+ ***************************************************************************/
+#include "tool_setup.h"
+
+#ifdef HAVE_SYS_IOCTL_H
+#include <sys/ioctl.h>
+#endif
+
+#include "terminal.h"
+
+#include "memdebug.h" /* keep this as LAST include */
+
+#ifdef HAVE_TERMIOS_H
+#  include <termios.h>
+#elif defined(HAVE_TERMIO_H)
+#  include <termio.h>
+#endif
+
+/*
+ * get_terminal_columns() returns the number of columns in the current
+ * terminal. It will return 79 on failure. Also, the number can be very big.
+ */
+
+unsigned int get_terminal_columns(void)
+{
+  unsigned int width = 0;
+  char *colp = curl_getenv("COLUMNS");
+  if(colp) {
+    char *endptr;
+    long num = strtol(colp, &endptr, 10);
+    if((endptr != colp) && (endptr == colp + strlen(colp)) && (num > 20) &&
+       (num < 10000))
+      width = (unsigned int)num;
+    curl_free(colp);
+  }
+
+  if(!width) {
+    int cols = 0;
+
+#ifdef TIOCGSIZE
+    struct ttysize ts;
+    if(!ioctl(STDIN_FILENO, TIOCGSIZE, &ts))
+      cols = ts.ts_cols;
+#elif defined(TIOCGWINSZ)
+    struct winsize ts;
+    if(!ioctl(STDIN_FILENO, TIOCGWINSZ, &ts))
+      cols = (int)ts.ws_col;
+#elif defined(_WIN32) && !defined(CURL_WINDOWS_APP)
+    {
+      HANDLE  stderr_hnd = GetStdHandle(STD_ERROR_HANDLE);
+      CONSOLE_SCREEN_BUFFER_INFO console_info;
+
+      if((stderr_hnd != INVALID_HANDLE_VALUE) &&
+         GetConsoleScreenBufferInfo(stderr_hnd, &console_info)) {
+        /*
+         * Do not use +1 to get the true screen-width since writing a
+         * character at the right edge will cause a line wrap.
+         */
+        cols = (int)
+          (console_info.srWindow.Right - console_info.srWindow.Left);
+      }
+    }
+#endif /* TIOCGSIZE */
+    if(cols >= 0 && cols < 10000)
+      width = (unsigned int)cols;
+  }
+  if(!width)
+    width = 79;
+  return width; /* 79 for unknown, might also be very small or very big */
+}
diff --git a/src/terminal.h b/src/terminal.h
new file mode 100644
index 000000000..dbd4abe28
--- /dev/null
+++ b/src/terminal.h
@@ -0,0 +1,30 @@
+#ifndef HEADER_CURL_TERMINAL_H
+#define HEADER_CURL_TERMINAL_H
+/***************************************************************************
+ *                                  _   _ ____  _
+ *  Project                     ___| | | |  _ \| |
+ *                             / __| | | | |_) | |
+ *                            | (__| |_| |  _ <| |___
+ *                             \___|\___/|_| \_\_____|
+ *
+ * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+ *
+ * This software is licensed as described in the file COPYING, which
+ * you should have received as part of this distribution. The terms
+ * are also available at https://curl.se/docs/copyright.html.
+ *
+ * You may opt to use, copy, modify, merge, publish, distribute and/or sell
+ * copies of the Software, and permit persons to whom the Software is
+ * furnished to do so, under the terms of the COPYING file.
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+ * KIND, either express or implied.
+ *
+ * SPDX-License-Identifier: curl
+ *
+ ***************************************************************************/
+#include "tool_setup.h"
+
+unsigned int get_terminal_columns(void);
+
+#endif /* HEADER_CURL_TERMINAL_H */
diff --git a/src/tool_cb_dbg.c b/src/tool_cb_dbg.c
index cbf57f057..dd2a124ad 100644
--- a/src/tool_cb_dbg.c
+++ b/src/tool_cb_dbg.c
@@ -59,7 +59,7 @@ static const char *hms_for_sec(time_t tv_sec)
     }
     secs = epoch_offset + tv_sec;
     /* !checksrc! disable BANNEDFUNC 1 */
-    now = localtime(&secs);  /* not thread safe but we don't care */
+    now = localtime(&secs);  /* not thread safe but we do not care */
     msnprintf(hms_buf, sizeof(hms_buf), "%02d:%02d:%02d",
               now->tm_hour, now->tm_min, now->tm_sec);
     cached_tv_sec = tv_sec;
@@ -99,7 +99,7 @@ int tool_debug_cb(CURL *handle, curl_infotype type,
   const char *text;
   struct timeval tv;
   char timebuf[20];
-  /* largest signed 64bit is: 9,223,372,036,854,775,807
+  /* largest signed 64-bit is: 9,223,372,036,854,775,807
    * max length in decimal: 1 + (6*3) = 19
    * formatted via TRC_IDS_FORMAT_IDS_2 this becomes 2 + 19 + 1 + 19 + 2 = 43
    * negative xfer-id are not printed, negative conn-ids use TRC_IDS_FORMAT_1
@@ -191,8 +191,8 @@ int tool_debug_cb(CURL *handle, curl_infotype type,
     case CURLINFO_SSL_DATA_IN:
     case CURLINFO_SSL_DATA_OUT:
       if(!traced_data) {
-        /* if the data is output to a tty and we're sending this debug trace
-           to stderr or stdout, we don't display the alert about the data not
+        /* if the data is output to a tty and we are sending this debug trace
+           to stderr or stdout, we do not display the alert about the data not
            being shown as the data _is_ shown then just not via this
            function */
         if(!config->isatty ||
@@ -286,7 +286,7 @@ static void dump(const char *timebuf, const char *idsbuf, const char *text,
       (void)infotype;
       fprintf(stream, "%c", ((ptr[i + c] >= 0x20) && (ptr[i + c] < 0x7F)) ?
               ptr[i + c] : UNPRINTABLE_CHAR);
-      /* check again for 0D0A, to avoid an extra \n if it's at width */
+      /* check again for 0D0A, to avoid an extra \n if it is at width */
       if((tracetype == TRACE_ASCII) &&
          (i + c + 2 < size) && (ptr[i + c + 1] == 0x0D) &&
          (ptr[i + c + 2] == 0x0A)) {
diff --git a/src/tool_cb_hdr.c b/src/tool_cb_hdr.c
index dab4bb01c..96b6fabb7 100644
--- a/src/tool_cb_hdr.c
+++ b/src/tool_cb_hdr.c
@@ -50,7 +50,7 @@ static char *parse_filename(const char *ptr, size_t len);
 #else
 #define BOLD "\x1b[1m"
 /* Switch off bold by setting "all attributes off" since the explicit
-   bold-off code (21) isn't supported everywhere - like in the mac
+   bold-off code (21) is not supported everywhere - like in the mac
    Terminal. */
 #define BOLDOFF "\x1b[0m"
 /* OSC 8 hyperlink escape sequence */
@@ -105,7 +105,11 @@ size_t tool_header_cb(char *ptr, size_t size, size_t nmemb, void *userdata)
     if(rc != cb)
       return rc;
     /* flush the stream to send off what we got earlier */
-    (void)fflush(heads->stream);
+    if(fflush(heads->stream)) {
+      errorf(per->config->global, "Failed writing headers to %s",
+             per->config->headerfile);
+      return CURL_WRITEFUNC_ERROR;
+    }
   }
 
   curl_easy_getinfo(per->curl, CURLINFO_SCHEME, &scheme);
@@ -114,8 +118,9 @@ size_t tool_header_cb(char *ptr, size_t size, size_t nmemb, void *userdata)
     long response = 0;
     curl_easy_getinfo(per->curl, CURLINFO_RESPONSE_CODE, &response);
 
-    if(response/100 != 2)
-      /* only care about these headers in 2xx responses */
+    if((response/100 != 2) && (response/100 != 3))
+      /* only care about etag and content-disposition headers in 2xx and 3xx
+         responses */
       ;
     /*
      * Write etag to file when --etag-save option is given.
@@ -268,7 +273,7 @@ size_t tool_header_cb(char *ptr, size_t size, size_t nmemb, void *userdata)
 }
 
 /*
- * Copies a file name part and returns an ALLOCATED data buffer.
+ * Copies a filename part and returns an ALLOCATED data buffer.
  */
 static char *parse_filename(const char *ptr, size_t len)
 {
@@ -309,7 +314,7 @@ static char *parse_filename(const char *ptr, size_t len)
   }
 
   /* If the filename contains a backslash, only use filename portion. The idea
-     is that even systems that don't handle backslashes as path separators
+     is that even systems that do not handle backslashes as path separators
      probably want the path removed for convenience. */
   q = strrchr(p, '\\');
   if(q) {
@@ -320,7 +325,7 @@ static char *parse_filename(const char *ptr, size_t len)
     }
   }
 
-  /* make sure the file name doesn't end in \r or \n */
+  /* make sure the filename does not end in \r or \n */
   q = strchr(p, '\r');
   if(q)
     *q = '\0';
@@ -344,7 +349,7 @@ static char *parse_filename(const char *ptr, size_t len)
 #endif /* _WIN32 || MSDOS */
 
   /* in case we built debug enabled, we allow an environment variable
-   * named CURL_TESTDIR to prefix the given file name to put it into a
+   * named CURL_TESTDIR to prefix the given filename to put it into a
    * specific directory
    */
 #ifdef DEBUGBUILD
@@ -354,7 +359,7 @@ static char *parse_filename(const char *ptr, size_t len)
       char buffer[512]; /* suitably large */
       msnprintf(buffer, sizeof(buffer), "%s/%s", tdir, copy);
       Curl_safefree(copy);
-      copy = strdup(buffer); /* clone the buffer, we don't use the libcurl
+      copy = strdup(buffer); /* clone the buffer, we do not use the libcurl
                                 aprintf() or similar since we want to use the
                                 same memory code as the "real" parse_filename
                                 function */
@@ -371,9 +376,9 @@ static char *parse_filename(const char *ptr, size_t len)
  * Treat the Location: header specially, by writing a special escape
  * sequence that adds a hyperlink to the displayed text. This makes
  * the absolute URL of the redirect clickable in supported terminals,
- * which couldn't happen otherwise for relative URLs. The Location:
+ * which could not happen otherwise for relative URLs. The Location:
  * header is supposed to always be absolute so this theoretically
- * shouldn't be needed but the real world returns plenty of relative
+ * should not be needed but the real world returns plenty of relative
  * URLs here.
  */
 static
@@ -445,7 +450,7 @@ void write_linked_location(CURL *curl, const char *location, size_t loclen,
     goto locdone;
   }
 
-  /* Not a "safe" URL: don't linkify it */
+  /* Not a "safe" URL: do not linkify it */
 
 locout:
   /* Write the normal output in case of error or unsafe */
diff --git a/src/tool_cb_prg.c b/src/tool_cb_prg.c
index 8e50908dd..4c3d3cdb5 100644
--- a/src/tool_cb_prg.c
+++ b/src/tool_cb_prg.c
@@ -23,10 +23,6 @@
  ***************************************************************************/
 #include "tool_setup.h"
 
-#ifdef HAVE_SYS_IOCTL_H
-#include <sys/ioctl.h>
-#endif
-
 #define ENABLE_CURLX_PRINTF
 /* use our own printf() functions */
 #include "curlx.h"
@@ -35,17 +31,12 @@
 #include "tool_cb_prg.h"
 #include "tool_util.h"
 #include "tool_operate.h"
+#include "terminal.h"
 
 #include "memdebug.h" /* keep this as LAST include */
 
 #define MAX_BARLENGTH 256
 
-#ifdef HAVE_TERMIOS_H
-#  include <termios.h>
-#elif defined(HAVE_TERMIO_H)
-#  include <termio.h>
-#endif
-
 /* 200 values generated by this perl code:
 
    my $pi = 3.1415;
@@ -86,19 +77,19 @@ static void fly(struct ProgressData *bar, bool moved)
 
   /* bar->width is range checked when assigned */
   DEBUGASSERT(bar->width <= MAX_BARLENGTH);
-  memset(buf, ' ', bar->width);
-  buf[bar->width] = '\r';
+  buf[0] = '\r';
+  memset(&buf[1], ' ', bar->width);
   buf[bar->width + 1] = '\0';
 
-  memcpy(&buf[bar->bar], "-=O=-", 5);
+  memcpy(&buf[bar->bar + 1], "-=O=-", 5);
 
-  pos = sinus[bar->tick%200] / (1000000 / check);
+  pos = sinus[bar->tick%200] / (1000000 / check) + 1;
   buf[pos] = '#';
-  pos = sinus[(bar->tick + 5)%200] / (1000000 / check);
+  pos = sinus[(bar->tick + 5)%200] / (1000000 / check) + 1;
   buf[pos] = '#';
-  pos = sinus[(bar->tick + 10)%200] / (1000000 / check);
+  pos = sinus[(bar->tick + 10)%200] / (1000000 / check) + 1;
   buf[pos] = '#';
-  pos = sinus[(bar->tick + 15)%200] / (1000000 / check);
+  pos = sinus[(bar->tick + 15)%200] / (1000000 / check) + 1;
   buf[pos] = '#';
 
   fputs(buf, bar->out);
@@ -170,10 +161,10 @@ int tool_progress_cb(void *clientp,
     if(total) {
       /* we know the total data to get... */
       if(bar->prev == point)
-        /* progress didn't change since last invoke */
+        /* progress did not change since last invoke */
         return 0;
       else if((tvdiff(now, bar->prevtime) < 100L) && point < total)
-        /* limit progress-bar updating to 10 Hz except when we're at 100% */
+        /* limit progress-bar updating to 10 Hz except when we are at 100% */
         return 0;
     }
     else {
@@ -229,59 +220,6 @@ int tool_progress_cb(void *clientp,
   return 0;
 }
 
-/*
- * get_terminal_columns() returns the number of columns in the current
- * terminal. It will return 79 on failure. Also, the number can be very big.
- */
-
-unsigned int get_terminal_columns(void)
-{
-  unsigned int width = 0;
-  char *colp = curl_getenv("COLUMNS");
-  if(colp) {
-    char *endptr;
-    long num = strtol(colp, &endptr, 10);
-    if((endptr != colp) && (endptr == colp + strlen(colp)) && (num > 20) &&
-       (num < 10000))
-      width = (unsigned int)num;
-    curl_free(colp);
-  }
-
-  if(!width) {
-    int cols = 0;
-
-#ifdef TIOCGSIZE
-    struct ttysize ts;
-    if(!ioctl(STDIN_FILENO, TIOCGSIZE, &ts))
-      cols = ts.ts_cols;
-#elif defined(TIOCGWINSZ)
-    struct winsize ts;
-    if(!ioctl(STDIN_FILENO, TIOCGWINSZ, &ts))
-      cols = (int)ts.ws_col;
-#elif defined(_WIN32)
-    {
-      HANDLE  stderr_hnd = GetStdHandle(STD_ERROR_HANDLE);
-      CONSOLE_SCREEN_BUFFER_INFO console_info;
-
-      if((stderr_hnd != INVALID_HANDLE_VALUE) &&
-         GetConsoleScreenBufferInfo(stderr_hnd, &console_info)) {
-        /*
-         * Do not use +1 to get the true screen-width since writing a
-         * character at the right edge will cause a line wrap.
-         */
-        cols = (int)
-          (console_info.srWindow.Right - console_info.srWindow.Left);
-      }
-    }
-#endif /* TIOCGSIZE */
-    if(cols >= 0 && cols < 10000)
-      width = (unsigned int)cols;
-  }
-  if(!width)
-    width = 79;
-  return width; /* 79 for unknown, might also be very small or very big */
-}
-
 void progressbarinit(struct ProgressData *bar,
                      struct OperationConfig *config)
 {
@@ -289,7 +227,7 @@ void progressbarinit(struct ProgressData *bar,
   memset(bar, 0, sizeof(struct ProgressData));
 
   /* pass the resume from value through to the progress function so it can
-   * display progress towards total file not just the part that's left. */
+   * display progress towards total file not just the part that is left. */
   if(config->use_resume)
     bar->initial_size = config->resume_from;
 
diff --git a/src/tool_cb_prg.h b/src/tool_cb_prg.h
index b012457df..dc10f2a5c 100644
--- a/src/tool_cb_prg.h
+++ b/src/tool_cb_prg.h
@@ -45,8 +45,6 @@ struct OperationConfig;
 void progressbarinit(struct ProgressData *bar,
                      struct OperationConfig *config);
 
-unsigned int get_terminal_columns(void);
-
 /*
 ** callback for CURLOPT_PROGRESSFUNCTION
 */
diff --git a/src/tool_cb_rea.c b/src/tool_cb_rea.c
index 961dd113b..1e23895ca 100644
--- a/src/tool_cb_rea.c
+++ b/src/tool_cb_rea.c
@@ -90,7 +90,7 @@ size_t tool_read_cb(char *buffer, size_t sz, size_t nmemb, void *userdata)
       config->readbusy = TRUE;
       return CURL_READFUNC_PAUSE;
     }
-    /* since size_t is unsigned we can't return negative values fine */
+    /* since size_t is unsigned we cannot return negative values fine */
     rc = 0;
   }
   if((per->uploadfilesize != -1) &&
diff --git a/src/tool_cb_see.c b/src/tool_cb_see.c
index 643a38cd9..7ce678aab 100644
--- a/src/tool_cb_see.c
+++ b/src/tool_cb_see.c
@@ -64,17 +64,17 @@ int tool_seek_cb(void *userdata, curl_off_t offset, int whence)
     curl_off_t left = offset;
 
     if(whence != SEEK_SET)
-      /* this code path doesn't support other types */
+      /* this code path does not support other types */
       return CURL_SEEKFUNC_FAIL;
 
     if(LSEEK_ERROR == lseek(per->infd, 0, SEEK_SET))
-      /* couldn't rewind to beginning */
+      /* could not rewind to beginning */
       return CURL_SEEKFUNC_FAIL;
 
     while(left) {
       long step = (left > OUR_MAX_SEEK_O) ? OUR_MAX_SEEK_L : (long)left;
       if(LSEEK_ERROR == lseek(per->infd, step, SEEK_CUR))
-        /* couldn't seek forwards the desired amount */
+        /* could not seek forwards the desired amount */
         return CURL_SEEKFUNC_FAIL;
       left -= step;
     }
@@ -83,8 +83,8 @@ int tool_seek_cb(void *userdata, curl_off_t offset, int whence)
 #endif
 
   if(LSEEK_ERROR == lseek(per->infd, offset, whence))
-    /* couldn't rewind, the reason is in errno but errno is just not portable
-       enough and we don't actually care that much why we failed. We'll let
+    /* could not rewind, the reason is in errno but errno is just not portable
+       enough and we do not actually care that much why we failed. We will let
        libcurl know that it may try other means if it wants to. */
     return CURL_SEEKFUNC_CANTSEEK;
 
diff --git a/src/tool_cb_soc.c b/src/tool_cb_soc.c
new file mode 100644
index 000000000..22048ee6b
--- /dev/null
+++ b/src/tool_cb_soc.c
@@ -0,0 +1,58 @@
+/***************************************************************************
+ *                                  _   _ ____  _
+ *  Project                     ___| | | |  _ \| |
+ *                             / __| | | | |_) | |
+ *                            | (__| |_| |  _ <| |___
+ *                             \___|\___/|_| \_\_____|
+ *
+ * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+ *
+ * This software is licensed as described in the file COPYING, which
+ * you should have received as part of this distribution. The terms
+ * are also available at https://curl.se/docs/copyright.html.
+ *
+ * You may opt to use, copy, modify, merge, publish, distribute and/or sell
+ * copies of the Software, and permit persons to whom the Software is
+ * furnished to do so, under the terms of the COPYING file.
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+ * KIND, either express or implied.
+ *
+ * SPDX-License-Identifier: curl
+ *
+ ***************************************************************************/
+#include "tool_setup.h"
+
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h> /* IPPROTO_TCP */
+#endif
+
+#include "tool_cb_soc.h"
+
+/*
+** callback for CURLOPT_OPENSOCKETFUNCTION
+**
+** Notice that only Linux is supported for the moment.
+*/
+
+curl_socket_t tool_socket_open_mptcp_cb(void *clientp,
+                                        curlsocktype purpose,
+                                        struct curl_sockaddr *addr)
+{
+  int protocol = addr->protocol;
+
+  (void)clientp;
+  (void)purpose;
+
+  if(protocol == IPPROTO_TCP)
+#if defined(__linux__)
+#  ifndef IPPROTO_MPTCP
+#  define IPPROTO_MPTCP 262
+#  endif
+    protocol = IPPROTO_MPTCP;
+#else
+    return CURL_SOCKET_BAD;
+#endif
+
+  return socket(addr->family, addr->socktype, protocol);
+}
diff --git a/src/tool_cb_soc.h b/src/tool_cb_soc.h
new file mode 100644
index 000000000..f02150aa8
--- /dev/null
+++ b/src/tool_cb_soc.h
@@ -0,0 +1,36 @@
+#ifndef HEADER_CURL_TOOL_CB_SOC_H
+#define HEADER_CURL_TOOL_CB_SOC_H
+/***************************************************************************
+ *                                  _   _ ____  _
+ *  Project                     ___| | | |  _ \| |
+ *                             / __| | | | |_) | |
+ *                            | (__| |_| |  _ <| |___
+ *                             \___|\___/|_| \_\_____|
+ *
+ * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+ *
+ * This software is licensed as described in the file COPYING, which
+ * you should have received as part of this distribution. The terms
+ * are also available at https://curl.se/docs/copyright.html.
+ *
+ * You may opt to use, copy, modify, merge, publish, distribute and/or sell
+ * copies of the Software, and permit persons to whom the Software is
+ * furnished to do so, under the terms of the COPYING file.
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+ * KIND, either express or implied.
+ *
+ * SPDX-License-Identifier: curl
+ *
+ ***************************************************************************/
+#include "tool_setup.h"
+
+/*
+** callback for CURLOPT_OPENSOCKETFUNCTION
+*/
+
+curl_socket_t tool_socket_open_mptcp_cb(void *clientp,
+                                        curlsocktype purpose,
+                                        struct curl_sockaddr *addr);
+
+#endif /* HEADER_CURL_TOOL_CB_SOC_H */
diff --git a/src/tool_cb_wrt.c b/src/tool_cb_wrt.c
index e01658fd8..ccc010917 100644
--- a/src/tool_cb_wrt.c
+++ b/src/tool_cb_wrt.c
@@ -75,7 +75,7 @@ bool tool_create_output_file(struct OutStruct *outs,
     int fd;
     do {
       fd = open(fname, O_CREAT | O_WRONLY | O_EXCL | O_BINARY, OPENMODE);
-      /* Keep retrying in the hope that it isn't interrupted sometime */
+      /* Keep retrying in the hope that it is not interrupted sometime */
     } while(fd == -1 && errno == EINTR);
     if(config->file_clobber_mode == CLOBBER_NEVER && fd == -1) {
       int next_num = 1;
@@ -94,15 +94,15 @@ bool tool_create_output_file(struct OutStruct *outs,
       }
       memcpy(newname, fname, len);
       newname[len] = '.';
-      while(fd == -1 && /* haven't successfully opened a file */
+      while(fd == -1 && /* have not successfully opened a file */
             (errno == EEXIST || errno == EISDIR) &&
             /* because we keep having files that already exist */
-            next_num < 100 /* and we haven't reached the retry limit */ ) {
+            next_num < 100 /* and we have not reached the retry limit */ ) {
         curlx_msnprintf(newname + len + 1, 12, "%d", next_num);
         next_num++;
         do {
           fd = open(newname, O_CREAT | O_WRONLY | O_EXCL | O_BINARY, OPENMODE);
-          /* Keep retrying in the hope that it isn't interrupted sometime */
+          /* Keep retrying in the hope that it is not interrupted sometime */
         } while(fd == -1 && errno == EINTR);
       }
       outs->filename = newname; /* remember the new one */
diff --git a/src/tool_cfgable.h b/src/tool_cfgable.h
index 74d0c45f2..a887881da 100644
--- a/src/tool_cfgable.h
+++ b/src/tool_cfgable.h
@@ -50,8 +50,8 @@ struct OperationConfig {
   struct curl_slist *cookies;  /* cookies to serialize into a single line */
   char *cookiejar;          /* write to this file */
   struct curl_slist *cookiefiles;  /* file(s) to load cookies from */
-  char *altsvc;             /* alt-svc cache file name */
-  char *hsts;               /* HSTS cache file name */
+  char *altsvc;             /* alt-svc cache filename */
+  char *hsts;               /* HSTS cache filename */
   bool cookiesession;       /* new session? */
   bool encoding;            /* Accept-Encoding please */
   bool tr_encoding;         /* Transfer-Encoding please */
@@ -85,6 +85,8 @@ struct OperationConfig {
   char *range;
   long low_speed_limit;
   long low_speed_time;
+  long ip_tos;         /* IP Type of Service */
+  long vlan_priority;  /* VLAN priority */
   char *dns_servers;   /* dot notation: 1.1.1.1;2.2.2.2 */
   char *dns_interface; /* interface name */
   char *dns_ipv4_addr; /* dot notation */
@@ -114,7 +116,7 @@ struct OperationConfig {
   bool failonerror;         /* fail on (HTTP) errors */
   bool failwithbody;        /* fail on (HTTP) errors but still store body */
   bool show_headers;        /* show headers to data output */
-  bool no_body;             /* don't get the body */
+  bool no_body;             /* do not get the body */
   bool dirlistonly;         /* only get the FTP dir list */
   bool followlocation;      /* follow http redirects */
   bool unrestricted_auth;   /* Continue to send authentication (user+password)
@@ -247,7 +249,8 @@ struct OperationConfig {
   bool post302;
   bool post303;
   bool nokeepalive;         /* for keepalive needs */
-  long alivetime;
+  long alivetime;           /* keepalive-time */
+  long alivecnt;            /* keepalive-cnt */
   bool content_disposition; /* use Content-disposition filename */
 
   int default_node_flags;   /* default flags to search for each 'node', which
@@ -292,6 +295,7 @@ struct OperationConfig {
     CLOBBER_NEVER, /* If the file exists, always fail */
     CLOBBER_ALWAYS /* If the file exists, always overwrite it */
   } file_clobber_mode;
+  bool mptcp;                     /* enable MPTCP support */
   struct GlobalConfig *global;
   struct OperationConfig *prev;
   struct OperationConfig *next;   /* Always last in the struct */
@@ -308,8 +312,8 @@ struct OperationConfig {
 
 struct GlobalConfig {
   bool showerror;                 /* show errors when silent */
-  bool silent;                    /* don't show messages, --silent given */
-  bool noprogress;                /* don't show progress bar */
+  bool silent;                    /* do not show messages, --silent given */
+  bool noprogress;                /* do not show progress bar */
   bool isatty;                    /* Updated internally if output is a tty */
   char *trace_dump;               /* file to dump the network trace to */
   FILE *trace_stream;
@@ -318,12 +322,12 @@ struct GlobalConfig {
   bool tracetime;                 /* include timestamp? */
   bool traceids;                  /* include xfer-/conn-id? */
   int progressmode;               /* CURL_PROGRESS_BAR / CURL_PROGRESS_STATS */
-  char *libcurl;                  /* Output libcurl code to this file name */
+  char *libcurl;                  /* Output libcurl code to this filename */
   bool fail_early;                /* exit on first transfer error */
   bool styled_output;             /* enable fancy output style detection */
   long ms_per_transfer;           /* start next transfer after (at least) this
                                      many milliseconds */
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
   bool test_event_based;
 #endif
   bool parallel;
diff --git a/src/tool_dirhie.c b/src/tool_dirhie.c
index 1cadbd0be..0efdc398c 100644
--- a/src/tool_dirhie.c
+++ b/src/tool_dirhie.c
@@ -50,7 +50,7 @@ static void show_dir_errno(struct GlobalConfig *global, const char *name)
   switch(errno) {
 #ifdef EACCES
   case EACCES:
-    errorf(global, "You don't have permission to create %s", name);
+    errorf(global, "You do not have permission to create %s", name);
     break;
 #endif
 #ifdef ENAMETOOLONG
@@ -117,7 +117,7 @@ CURLcode create_dir_hierarchy(const char *outfile, struct GlobalConfig *global)
   }
   dirbuildup[0] = '\0';
 
-  /* Allow strtok() here since this isn't used threaded */
+  /* Allow strtok() here since this is not used threaded */
   /* !checksrc! disable BANNEDFUNC 2 */
   tempdir = strtok(outdup, PATH_DELIMITERS);
 
@@ -137,13 +137,13 @@ CURLcode create_dir_hierarchy(const char *outfile, struct GlobalConfig *global)
              It may seem as though that would harmlessly fail but it could be
              a corner case if X: did not exist, since we would be creating it
              erroneously.
-             eg if outfile is X:\foo\bar\filename then don't mkdir X:
+             eg if outfile is X:\foo\bar\filename then do not mkdir X:
              This logic takes into account unsupported drives !:, 1:, etc. */
           char *p = strchr(tempdir, ':');
           if(p && !p[1])
             skip = true;
 #endif
-          /* the output string doesn't start with a separator */
+          /* the output string does not start with a separator */
           strcpy(dirbuildup, tempdir);
         }
         else
diff --git a/src/tool_doswin.c b/src/tool_doswin.c
index db2b8b78a..38ef0a01e 100644
--- a/src/tool_doswin.c
+++ b/src/tool_doswin.c
@@ -56,9 +56,9 @@
 #endif
 
 #ifdef _WIN32
-#  define _use_lfn(f) (1)   /* long file names always available */
+#  define _use_lfn(f) (1)   /* long filenames always available */
 #elif !defined(__DJGPP__) || (__DJGPP__ < 2)  /* DJGPP 2.0 has _use_lfn() */
-#  define _use_lfn(f) (0)  /* long file names never available */
+#  define _use_lfn(f) (0)  /* long filenames never available */
 #elif defined(__DJGPP__)
 #  include <fcntl.h>                /* _use_lfn(f) prototype */
 #endif
@@ -98,8 +98,8 @@ SANITIZE_ALLOW_PATH:       Allow path separators and colons.
 Without this flag path separators and colons are sanitized.
 
 SANITIZE_ALLOW_RESERVED:   Allow reserved device names.
-Without this flag a reserved device name is renamed (COM1 => _COM1) unless it's
-in a UNC prefixed path.
+Without this flag a reserved device name is renamed (COM1 => _COM1) unless it
+is in a UNC prefixed path.
 
 SANITIZE_ALLOW_TRUNCATE:   Allow truncating a long filename.
 Without this flag if the sanitized filename or path will be too long an error
@@ -136,9 +136,9 @@ SANITIZEcode sanitize_file_name(char **const sanitized, const char *file_name,
       max_sanitized_len = PATH_MAX-1;
   }
   else
-    /* The maximum length of a filename.
-       FILENAME_MAX is often the same as PATH_MAX, in other words it is 260 and
-       does not discount the path information therefore we shouldn't use it. */
+    /* The maximum length of a filename. FILENAME_MAX is often the same as
+       PATH_MAX, in other words it is 260 and does not discount the path
+       information therefore we should not use it. */
     max_sanitized_len = (PATH_MAX-1 > 255) ? 255 : PATH_MAX-1;
 
   len = strlen(file_name);
@@ -237,7 +237,7 @@ SANITIZEcode sanitize_file_name(char **const sanitized, const char *file_name,
 
 /*
 Test if truncating a path to a file will leave at least a single character in
-the filename. Filenames suffixed by an alternate data stream can't be
+the filename. Filenames suffixed by an alternate data stream cannot be
 truncated. This performs a dry run, nothing is modified.
 
 Good truncate_pos 9:    C:\foo\bar  =>  C:\foo\ba
@@ -253,7 +253,7 @@ Error truncate_pos 7:   C:\foo      =>  (pos out of range)
 Bad truncate_pos 1:     C:\foo\     =>  C
 
 * C:foo is ambiguous, C could end up being a drive or file therefore something
-  like C:superlongfilename can't be truncated.
+  like C:superlongfilename cannot be truncated.
 
 Returns
 SANITIZE_ERR_OK: Good -- 'path' can be truncated
@@ -278,7 +278,7 @@ SANITIZEcode truncate_dryrun(const char *path, const size_t truncate_pos)
   if(strpbrk(&path[truncate_pos - 1], "\\/:"))
     return SANITIZE_ERR_INVALID_PATH;
 
-  /* C:\foo can be truncated but C:\foo:ads can't */
+  /* C:\foo can be truncated but C:\foo:ads cannot */
   if(truncate_pos > 1) {
     const char *p = &path[truncate_pos - 1];
     do {
@@ -357,8 +357,8 @@ SANITIZEcode msdosify(char **const sanitized, const char *file_name,
         *d = ':';
       else if((flags & SANITIZE_ALLOW_PATH) && (*s == '/' || *s == '\\'))
         *d = *s;
-      /* Dots are special: DOS doesn't allow them as the leading character,
-         and a file name cannot have more than a single dot.  We leave the
+      /* Dots are special: DOS does not allow them as the leading character,
+         and a filename cannot have more than a single dot. We leave the
          first non-leading dot alone, unless it comes too close to the
          beginning of the name: we want sh.lex.c to become sh_lex.c, not
          sh.lex-c.  */
@@ -445,7 +445,7 @@ SANITIZEcode msdosify(char **const sanitized, const char *file_name,
 #endif /* MSDOS || UNITTESTS */
 
 /*
-Rename file_name if it's a reserved dos device name.
+Rename file_name if it is a reserved dos device name.
 
 This is a supporting function for sanitize_file_name.
 
@@ -461,8 +461,8 @@ SANITIZEcode rename_if_reserved_dos_device_name(char **const sanitized,
                                                 const char *file_name,
                                                 int flags)
 {
-  /* We could have a file whose name is a device on MS-DOS.  Trying to
-   * retrieve such a file would fail at best and wedge us at worst.  We need
+  /* We could have a file whose name is a device on MS-DOS. Trying to
+   * retrieve such a file would fail at best and wedge us at worst. We need
    * to rename such files. */
   char *p, *base;
   char fname[PATH_MAX];
@@ -560,9 +560,10 @@ SANITIZEcode rename_if_reserved_dos_device_name(char **const sanitized,
   /* This is the legacy portion from rename_if_dos_device_name that checks for
      reserved device names. It only works on MSDOS. On Windows XP the stat
      check errors with EINVAL if the device name is reserved. On Windows
-     Vista/7/8 it sets mode S_IFREG (regular file or device). According to MSDN
-     stat doc the latter behavior is correct, but that doesn't help us identify
-     whether it's a reserved device name and not a regular file name. */
+     Vista/7/8 it sets mode S_IFREG (regular file or device). According to
+     MSDN stat doc the latter behavior is correct, but that does not help us
+     identify whether it is a reserved device name and not a regular
+     filename. */
 #ifdef MSDOS
   if(base && ((stat(base, &st_buf)) == 0) && (S_ISCHR(st_buf.st_mode))) {
     /* Prepend a '_' */
@@ -606,8 +607,8 @@ char **__crt0_glob_function(char *arg)
  * The order of the directories it searches is:
  *  1. application's directory
  *  2. current working directory
- *  3. Windows System directory (e.g. C:\windows\system32)
- *  4. Windows Directory (e.g. C:\windows)
+ *  3. Windows System directory (e.g. C:\Windows\System32)
+ *  4. Windows Directory (e.g. C:\Windows)
  *  5. all directories along %PATH%
  *
  * For WinXP and later search order actually depends on registry value:
@@ -620,6 +621,11 @@ CURLcode FindWin32CACert(struct OperationConfig *config,
 {
   CURLcode result = CURLE_OK;
 
+#ifdef CURL_WINDOWS_APP
+  (void)config;
+  (void)backend;
+  (void)bundle_file;
+#else
   /* Search and set cert file only if libcurl supports SSL.
    *
    * If Schannel is the selected SSL backend then these locations are
@@ -645,6 +651,7 @@ CURLcode FindWin32CACert(struct OperationConfig *config,
         result = CURLE_OUT_OF_MEMORY;
     }
   }
+#endif
 
   return result;
 }
@@ -677,7 +684,7 @@ struct curl_slist *GetLoadedModulePaths(void)
 
 #ifdef UNICODE
     /* sizeof(mod.szExePath) is the max total bytes of wchars. the max total
-       bytes of multibyte chars won't be more than twice that. */
+       bytes of multibyte chars will not be more than twice that. */
     char buffer[sizeof(mod.szExePath) * 2];
     if(!WideCharToMultiByte(CP_ACP, 0, mod.szExePath, -1,
                             buffer, sizeof(buffer), NULL, NULL))
@@ -703,6 +710,9 @@ cleanup:
   return slist;
 }
 
+bool tool_term_has_bold;
+
+#ifndef CURL_WINDOWS_APP
 /* The terminal settings to restore on exit */
 static struct TerminalSettings {
   HANDLE hStdOut;
@@ -714,8 +724,6 @@ static struct TerminalSettings {
 #define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
 #endif
 
-bool tool_term_has_bold;
-
 static void restore_terminal(void)
 {
   if(InterlockedExchange(&TerminalSettings.valid, (LONG)FALSE))
@@ -770,6 +778,7 @@ static void init_terminal(void)
     }
   }
 }
+#endif
 
 LARGE_INTEGER tool_freq;
 bool tool_isVistaOrGreater;
@@ -786,7 +795,9 @@ CURLcode win32_init(void)
 
   QueryPerformanceFrequency(&tool_freq);
 
+#ifndef CURL_WINDOWS_APP
   init_terminal();
+#endif
 
   return CURLE_OK;
 }
diff --git a/src/tool_filetime.c b/src/tool_filetime.c
index 13113886e..549b8bea5 100644
--- a/src/tool_filetime.c
+++ b/src/tool_filetime.c
@@ -39,9 +39,9 @@ int getfiletime(const char *filename, struct GlobalConfig *global,
   int rc = 1;
 
 /* Windows stat() may attempt to adjust the unix GMT file time by a daylight
-   saving time offset and since it's GMT that is bad behavior. When we have
+   saving time offset and since it is GMT that is bad behavior. When we have
    access to a 64-bit type we can bypass stat and get the times directly. */
-#if defined(_WIN32)
+#if defined(_WIN32) && !defined(CURL_WINDOWS_APP)
   HANDLE hfile;
   TCHAR *tchar_filename = curlx_convert_UTF8_to_tchar((char *)filename);
 
@@ -93,9 +93,9 @@ void setfiletime(curl_off_t filetime, const char *filename,
 {
   if(filetime >= 0) {
 /* Windows utime() may attempt to adjust the unix GMT file time by a daylight
-   saving time offset and since it's GMT that is bad behavior. When we have
+   saving time offset and since it is GMT that is bad behavior. When we have
    access to a 64-bit type we can bypass utime and set the times directly. */
-#if defined(_WIN32)
+#if defined(_WIN32) && !defined(CURL_WINDOWS_APP)
     HANDLE hfile;
     TCHAR *tchar_filename = curlx_convert_UTF8_to_tchar((char *)filename);
 
diff --git a/src/tool_formparse.c b/src/tool_formparse.c
index 875ce78d6..61f88396c 100644
--- a/src/tool_formparse.c
+++ b/src/tool_formparse.c
@@ -637,7 +637,7 @@ static int get_param_part(struct OperationConfig *config, char endchar,
     *pfilename = filename;
   else if(filename)
     warnf(config->global,
-          "Field file name not allowed here: %s", filename);
+          "Field filename not allowed here: %s", filename);
 
   if(pencoder)
     *pencoder = encoder;
@@ -693,7 +693,7 @@ static int get_param_part(struct OperationConfig *config, char endchar,
  * 'name=foo;headers=@headerfile' or why not
  * 'name=@filemame;headers=@headerfile'
  *
- * To upload a file, but to fake the file name that will be included in the
+ * To upload a file, but to fake the filename that will be included in the
  * formpost, do like this:
  *
  * 'name=@filename;filename=/dev/null' or quote the faked filename like:
@@ -720,7 +720,7 @@ int formparse(struct OperationConfig *config,
               struct tool_mime **mimecurrent,
               bool literal_value)
 {
-  /* input MUST be a string in the format 'name=contents' and we'll
+  /* input MUST be a string in the format 'name=contents' and we will
      build a linked list with the info */
   char *name = NULL;
   char *contents = NULL;
@@ -779,7 +779,7 @@ int formparse(struct OperationConfig *config,
     }
     else if('@' == contp[0] && !literal_value) {
 
-      /* we use the @-letter to indicate file name(s) */
+      /* we use the @-letter to indicate filename(s) */
 
       struct tool_mime *subparts = NULL;
 
@@ -831,7 +831,7 @@ int formparse(struct OperationConfig *config,
         SET_TOOL_MIME_PTR(part, encoder);
 
         /* *contp could be '\0', so we just check with the delimiter */
-      } while(sep); /* loop if there's another file name */
+      } while(sep); /* loop if there is another filename */
       part = (*mimecurrent)->subparts;  /* Set name on group. */
     }
     else {
diff --git a/src/tool_getparam.c b/src/tool_getparam.c
index 508e56797..4c9392cc6 100644
--- a/src/tool_getparam.c
+++ b/src/tool_getparam.c
@@ -179,6 +179,7 @@ typedef enum {
   C_JSON,
   C_JUNK_SESSION_COOKIES,
   C_KEEPALIVE,
+  C_KEEPALIVE_CNT,
   C_KEEPALIVE_TIME,
   C_KEY,
   C_KEY_TYPE,
@@ -200,6 +201,7 @@ typedef enum {
   C_MAX_REDIRS,
   C_MAX_TIME,
   C_METALINK,
+  C_MPTCP,
   C_NEGOTIATE,
   C_NETRC,
   C_NETRC_FILE,
@@ -328,6 +330,7 @@ typedef enum {
   C_TRACE_CONFIG,
   C_TRACE_IDS,
   C_TRACE_TIME,
+  C_IP_TOS,
   C_UNIX_SOCKET,
   C_UPLOAD_FILE,
   C_URL,
@@ -338,6 +341,7 @@ typedef enum {
   C_VARIABLE,
   C_VERBOSE,
   C_VERSION,
+  C_VLAN_PRIORITY,
   C_WDEBUG,
   C_WRITE_OUT,
   C_XATTR
@@ -349,7 +353,7 @@ struct LongShort {
     ARG_NONE, /* stand-alone but not a boolean */
     ARG_BOOL, /* accepts a --no-[name] prefix */
     ARG_STRG, /* requires an argument */
-    ARG_FILE  /* requires an argument, usually a file name */
+    ARG_FILE  /* requires an argument, usually a filename */
   } desc;
   char letter;  /* short name option or ' ' */
   cmdline_t cmd;
@@ -455,12 +459,14 @@ static const struct LongShort aliases[]= {
   {"include",                    ARG_BOOL, 'i', C_INCLUDE},
   {"insecure",                   ARG_BOOL, 'k', C_INSECURE},
   {"interface",                  ARG_STRG, ' ', C_INTERFACE},
+  {"ip-tos",                     ARG_STRG, ' ', C_IP_TOS},
   {"ipfs-gateway",               ARG_STRG, ' ', C_IPFS_GATEWAY},
   {"ipv4",                       ARG_NONE, '4', C_IPV4},
   {"ipv6",                       ARG_NONE, '6', C_IPV6},
   {"json",                       ARG_STRG, ' ', C_JSON},
   {"junk-session-cookies",       ARG_BOOL, 'j', C_JUNK_SESSION_COOKIES},
   {"keepalive",                  ARG_BOOL, ' ', C_KEEPALIVE},
+  {"keepalive-cnt",              ARG_STRG, ' ', C_KEEPALIVE_CNT},
   {"keepalive-time",             ARG_STRG, ' ', C_KEEPALIVE_TIME},
   {"key",                        ARG_FILE, ' ', C_KEY},
   {"key-type",                   ARG_STRG, ' ', C_KEY_TYPE},
@@ -482,6 +488,7 @@ static const struct LongShort aliases[]= {
   {"max-redirs",                 ARG_STRG, ' ', C_MAX_REDIRS},
   {"max-time",                   ARG_STRG, 'm', C_MAX_TIME},
   {"metalink",                   ARG_BOOL, ' ', C_METALINK},
+  {"mptcp",                      ARG_BOOL, ' ', C_MPTCP},
   {"negotiate",                  ARG_BOOL, ' ', C_NEGOTIATE},
   {"netrc",                      ARG_BOOL, 'n', C_NETRC},
   {"netrc-file",                 ARG_FILE, ' ', C_NETRC_FILE},
@@ -620,6 +627,7 @@ static const struct LongShort aliases[]= {
   {"variable",                   ARG_STRG, ' ', C_VARIABLE},
   {"verbose",                    ARG_BOOL, 'v', C_VERBOSE},
   {"version",                    ARG_BOOL, 'V', C_VERSION},
+  {"vlan-priority",              ARG_STRG, ' ', C_VLAN_PRIORITY},
 #ifdef USE_WATT32
   {"wdebug",                     ARG_BOOL, ' ', C_WDEBUG},
 #endif
@@ -629,7 +637,7 @@ static const struct LongShort aliases[]= {
 
 /* Split the argument of -E to 'certname' and 'passphrase' separated by colon.
  * We allow ':' and '\' to be escaped by '\' so that we can use certificate
- * nicknames containing ':'.  See <https://sourceforge.net/p/curl/bugs/1196/>
+ * nicknames containing ':'. See <https://sourceforge.net/p/curl/bugs/1196/>
  * for details. */
 #ifndef UNITTESTS
 static
@@ -670,7 +678,7 @@ void parse_cert_parameter(const char *cert_parameter,
     strncpy(certname_place, param_place, span);
     param_place += span;
     certname_place += span;
-    /* we just ate all the non-special chars. now we're on either a special
+    /* we just ate all the non-special chars. now we are on either a special
      * char or the end of the string. */
     switch(*param_place) {
     case '\0':
@@ -700,7 +708,7 @@ void parse_cert_parameter(const char *cert_parameter,
       /* Since we live in a world of weirdness and confusion, the win32
          dudes can use : when using drive letters and thus c:\file:password
          needs to work. In order not to break compatibility, we still use : as
-         separator, but we try to detect when it is used for a file name! On
+         separator, but we try to detect when it is used for a filename! On
          windows. */
 #ifdef _WIN32
       if((param_place == &cert_parameter[1]) &&
@@ -716,7 +724,7 @@ void parse_cert_parameter(const char *cert_parameter,
       }
 #endif
       /* escaped colons and Windows drive letter colons were handled
-       * above; if we're still here, this is a separating colon */
+       * above; if we are still here, this is a separating colon */
       param_place++;
       if(*param_place) {
         *passphrase = strdup(param_place);
@@ -827,7 +835,7 @@ static ParameterError GetSizeParameter(struct GlobalConfig *global,
 static void cleanarg(argv_item_t str)
 {
   /* now that getstr has copied the contents of nextarg, wipe the next
-   * argument out so that the username:password isn't displayed in the
+   * argument out so that the username:password is not displayed in the
    * system process list */
   if(str) {
     size_t len = strlen(str);
@@ -845,7 +853,7 @@ static ParameterError data_urlencode(struct GlobalConfig *global,
                                      size_t *lenp)
 {
   /* [name]=[content], we encode the content part only
-   * [name]@[file name]
+   * [name]@[filename]
    *
    * Case 2: we first load the file using that name and then encode
    * the content.
@@ -864,14 +872,14 @@ static ParameterError data_urlencode(struct GlobalConfig *global,
     is_file = *p++; /* pass the separator */
   }
   else {
-    /* neither @ nor =, so no name and it isn't a file */
+    /* neither @ nor =, so no name and it is not a file */
     nlen = 0;
     is_file = 0;
     p = nextarg;
   }
   if('@' == is_file) {
     FILE *file;
-    /* a '@' letter, it means that a file name or - (stdin) follows */
+    /* a '@' letter, it means that a filename or - (stdin) follows */
     if(!strcmp("-", p)) {
       file = stdin;
       set_binmode(stdin);
@@ -956,7 +964,7 @@ static CURLcode set_trace_config(struct GlobalConfig *global,
   if(!tmp)
     return CURLE_OUT_OF_MEMORY;
 
-  /* Allow strtok() here since this isn't used threaded */
+  /* Allow strtok() here since this is not used threaded */
   /* !checksrc! disable BANNEDFUNC 2 */
   token = strtok(tmp, ", ");
   while(token) {
@@ -1027,6 +1035,52 @@ static const struct LongShort *single(char letter)
   return singles[letter - ' '];
 }
 
+struct TOSEntry {
+  const char *name;
+  unsigned char value;
+};
+
+static const struct TOSEntry tos_entries[] = {
+  {"AF11", 0x28},
+  {"AF12", 0x30},
+  {"AF13", 0x38},
+  {"AF21", 0x48},
+  {"AF22", 0x50},
+  {"AF23", 0x58},
+  {"AF31", 0x68},
+  {"AF32", 0x70},
+  {"AF33", 0x78},
+  {"AF41", 0x88},
+  {"AF42", 0x90},
+  {"AF43", 0x98},
+  {"CE",   0x03},
+  {"CS0",  0x00},
+  {"CS1",  0x20},
+  {"CS2",  0x40},
+  {"CS3",  0x60},
+  {"CS4",  0x80},
+  {"CS5",  0xa0},
+  {"CS6",  0xc0},
+  {"CS7",  0xe0},
+  {"ECT0", 0x02},
+  {"ECT1", 0x01},
+  {"EF",   0xb8},
+  {"LE",   0x04},
+  {"LOWCOST",     0x02},
+  {"LOWDELAY",    0x10},
+  {"MINCOST",     0x02},
+  {"RELIABILITY", 0x04},
+  {"THROUGHPUT",  0x08},
+  {"VOICE-ADMIT", 0xb0}
+};
+
+static int find_tos(const void *a, const void *b)
+{
+  const struct TOSEntry *aa = a;
+  const struct TOSEntry *bb = b;
+  return strcmp(aa->name, bb->name);
+}
+
 #define MAX_QUERY_LEN 100000 /* larger is not likely to ever work */
 static ParameterError url_query(char *nextarg,
                                 struct GlobalConfig *global,
@@ -1080,7 +1134,7 @@ static ParameterError set_data(cmdline_t cmd,
       return err;
   }
   else if('@' == *nextarg && (cmd != C_DATA_RAW)) {
-    /* the data begins with a '@' letter, it means that a file name
+    /* the data begins with a '@' letter, it means that a filename
        or - (stdin) follows */
     nextarg++; /* pass the @ */
 
@@ -1239,7 +1293,7 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
   (void)cleararg;
 #endif
 
-  *usedarg = FALSE; /* default is that we don't use the arg */
+  *usedarg = FALSE; /* default is that we do not use the arg */
 
   if(('-' != flag[0]) || ('-' == flag[1])) {
     /* this should be a long name */
@@ -1271,7 +1325,7 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
       goto error;
     }
     if(noflagged && (a->desc != ARG_BOOL)) {
-      /* --no- prefixed an option that isn't boolean! */
+      /* --no- prefixed an option that is not boolean! */
       err = PARAM_NO_NOT_BOOLEAN;
       goto error;
     }
@@ -1281,7 +1335,7 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
 
       if((a->desc != ARG_STRG) &&
          (a->desc != ARG_FILE)) {
-        /* --expand on an option that isn't a string or a filename */
+        /* --expand on an option that is not a string or a filename */
         err = PARAM_EXPAND_ERROR;
         goto error;
       }
@@ -1319,7 +1373,7 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
       /* this option requires an extra parameter */
       if(!longopt && parse[1]) {
         nextarg = (char *)&parse[1]; /* this is the actual extra parameter */
-        singleopt = TRUE;   /* don't loop anymore after this */
+        singleopt = TRUE;   /* do not loop anymore after this */
       }
       else if(!nextarg) {
         err = PARAM_REQUIRES_PARAMETER;
@@ -1334,8 +1388,8 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
 
       if((a->desc == ARG_FILE) &&
          (nextarg[0] == '-') && nextarg[1]) {
-        /* if the file name looks like a command line option */
-        warnf(global, "The file name argument '%s' looks like a flag.",
+        /* if the filename looks like a command line option */
+        warnf(global, "The filename argument '%s' looks like a flag.",
               nextarg);
       }
       else if(!strncmp("\xe2\x80\x9c", nextarg, 3)) {
@@ -1492,7 +1546,7 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
     case C_ANYAUTH: /* --anyauth */
       if(toggle)
         config->authtype = CURLAUTH_ANY;
-      /* --no-anyauth simply doesn't touch it */
+      /* --no-anyauth simply does not touch it */
       break;
 #ifdef USE_WATT32
     case C_WDEBUG: /* --wdebug */
@@ -1571,7 +1625,7 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
         config->url_get = config->url_list;
 
       if(config->url_get) {
-        /* there's a node here, if it already is filled-in continue to find
+        /* there is a node here, if it already is filled-in continue to find
            an "empty" node */
         while(config->url_get && (config->url_get->flags & GETOUT_URL))
           config->url_get = config->url_get->next;
@@ -1630,6 +1684,22 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
     case C_TCP_NODELAY: /* --tcp-nodelay */
       config->tcp_nodelay = toggle;
       break;
+    case C_IP_TOS: { /* --ip-tos */
+      struct TOSEntry find;
+      const struct TOSEntry *entry;
+      find.name = nextarg;
+      entry = bsearch(&find, tos_entries,
+                      sizeof(tos_entries)/sizeof(*tos_entries),
+                      sizeof(*tos_entries), find_tos);
+      if(entry)
+        config->ip_tos = entry->value;
+      else /* numeric tos value */
+        err = str2unummax(&config->ip_tos, nextarg, 0xFF);
+      break;
+    }
+    case C_VLAN_PRIORITY: /* --vlan-priority */
+      err = str2unummax(&config->vlan_priority, nextarg, 7);
+      break;
     case C_PROXY_DIGEST: /* --proxy-digest */
       config->proxydigest = toggle;
       break;
@@ -1688,7 +1758,7 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
       while(ISDIGIT(*p))
         p++;
       if(*p) {
-        /* if there's anything more than a plain decimal number */
+        /* if there is anything more than a plain decimal number */
         rc = sscanf(p, " - %6s", lrange);
         *p = 0; /* null-terminate to make str2unum() work below */
       }
@@ -1761,6 +1831,9 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
     case C_KEEPALIVE_TIME: /* --keepalive-time */
       err = str2unum(&config->alivetime, nextarg);
       break;
+    case C_KEEPALIVE_CNT: /* --keepalive-cnt */
+      err = str2unum(&config->alivecnt, nextarg);
+      break;
     case C_POST301: /* --post301 */
       config->post301 = toggle;
       break;
@@ -1825,7 +1898,7 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
       config->sasl_ir = toggle;
       break;
     case C_TEST_EVENT: /* --test-event */
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
       global->test_event_based = toggle;
 #else
       warnf(global, "--test-event is ignored unless a debug build");
@@ -1888,7 +1961,7 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
     case C_PROGRESS_BAR: /* --progress-bar */
       global->progressmode = toggle ? CURL_PROGRESS_BAR : CURL_PROGRESS_STATS;
       break;
-    case C_VARIABLE: /* --Variable */
+    case C_VARIABLE: /* --variable */
       err = setvariable(global, nextarg);
       break;
     case C_NEXT: /* --next */
@@ -2378,7 +2451,7 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
         else {
           err = file2memory(&string, &len, file);
           if(!err && string) {
-            /* Allow strtok() here since this isn't used threaded */
+            /* Allow strtok() here since this is not used threaded */
             /* !checksrc! disable BANNEDFUNC 2 */
             char *h = strtok(string, "\r\n");
             while(h) {
@@ -2488,7 +2561,7 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
       if(!config->url_out)
         config->url_out = config->url_list;
       if(config->url_out) {
-        /* there's a node here, if it already is filled-in continue to find
+        /* there is a node here, if it already is filled-in continue to find
            an "empty" node */
         while(config->url_out && (config->url_out->flags & GETOUT_OUTFILE))
           config->url_out = config->url_out->next;
@@ -2539,7 +2612,7 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
       break;
 
     case C_DISABLE: /* --disable */
-      /* if used first, already taken care of, we do it like this so we don't
+      /* if used first, already taken care of, we do it like this so we do not
          cause an error! */
       break;
     case C_QUOTE: /* --quote */
@@ -2562,9 +2635,9 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
       break;
     case C_RANGE: /* --range */
       /* Specifying a range WITHOUT A DASH will create an illegal HTTP range
-         (and won't actually be range by definition). The man page previously
-         claimed that to be a good way, why this code is added to work-around
-         it. */
+         (and will not actually be range by definition). The manpage
+         previously claimed that to be a good way, why this code is added to
+         work-around it. */
       if(ISDIGIT(*nextarg) && !strchr(nextarg, '-')) {
         char buffer[32];
         if(curlx_strtoofft(nextarg, NULL, 10, &value)) {
@@ -2618,7 +2691,7 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
       if(!config->url_ul)
         config->url_ul = config->url_list;
       if(config->url_ul) {
-        /* there's a node here, if it already is filled-in continue to find
+        /* there is a node here, if it already is filled-in continue to find
            an "empty" node */
         while(config->url_ul && (config->url_ul->flags & GETOUT_UPLOAD))
           config->url_ul = config->url_ul->next;
@@ -2681,7 +2754,7 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
     case C_WRITE_OUT: /* --write-out */
       /* get the output string */
       if('@' == *nextarg) {
-        /* the data begins with a '@' letter, it means that a file name
+        /* the data begins with a '@' letter, it means that a filename
            or - (stdin) follows */
         FILE *file;
         const char *fname;
@@ -2778,7 +2851,7 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
       now = time(NULL);
       config->condtime = (curl_off_t)curl_getdate(nextarg, &now);
       if(-1 == config->condtime) {
-        /* now let's see if it is a file name to get the time from instead! */
+        /* now let's see if it is a filename to get the time from instead! */
         rc = getfiletime(nextarg, global, &value);
         if(!rc)
           /* pull the time out from the file */
@@ -2788,11 +2861,14 @@ ParameterError getparameter(const char *flag, /* f or -long-flag */
           config->timecond = CURL_TIMECOND_NONE;
           warnf(global,
                 "Illegal date format for -z, --time-cond (and not "
-                "a file name). Disabling time condition. "
+                "a filename). Disabling time condition. "
                 "See curl_getdate(3) for valid date syntax.");
         }
       }
       break;
+    case C_MPTCP: /* --mptcp */
+      config->mptcp = TRUE;
+      break;
     default: /* unknown flag */
       err = PARAM_OPTION_UNKNOWN;
       break;
@@ -2874,7 +2950,7 @@ ParameterError parse_args(struct GlobalConfig *global, int argc,
           }
         }
         else if(!result && passarg)
-          i++; /* we're supposed to skip this */
+          i++; /* we are supposed to skip this */
       }
     }
     else {
diff --git a/src/tool_getpass.c b/src/tool_getpass.c
index a7d426053..412c50a11 100644
--- a/src/tool_getpass.c
+++ b/src/tool_getpass.c
@@ -64,8 +64,8 @@ char *getpass_r(const char *prompt, char *buffer, size_t buflen)
   long sts;
   short chan;
 
-  /* MSK, 23-JAN-2004, iosbdef.h wasn't in VAX V7.2 or CC 6.4  */
-  /* distribution so I created this.  May revert back later to */
+  /* MSK, 23-JAN-2004, iosbdef.h was not in VAX V7.2 or CC 6.4  */
+  /* distribution so I created this. May revert back later to */
   /* struct _iosb iosb;                                        */
   struct _iosb
      {
@@ -115,7 +115,7 @@ char *getpass_r(const char *prompt, char *buffer, size_t buflen)
   }
   /* since echo is disabled, print a newline */
   fputs("\n", tool_stderr);
-  /* if user didn't hit ENTER, terminate buffer */
+  /* if user did not hit ENTER, terminate buffer */
   if(i == buflen)
     buffer[buflen-1] = '\0';
 
@@ -154,7 +154,7 @@ static bool ttyecho(bool enable, int fd)
     noecho.c_lflag &= ~(tcflag_t)ECHO;
     ioctl(fd, TCSETA, &noecho);
 #else
-    /* neither HAVE_TERMIO_H nor HAVE_TERMIOS_H, we can't disable echo! */
+    /* neither HAVE_TERMIO_H nor HAVE_TERMIOS_H, we cannot disable echo! */
     (void)fd;
     return FALSE; /* not disabled */
 #endif
@@ -180,7 +180,7 @@ char *getpass_r(const char *prompt, /* prompt to display */
   bool disabled;
   int fd = open("/dev/tty", O_RDONLY);
   if(-1 == fd)
-    fd = STDIN_FILENO; /* use stdin if the tty couldn't be used */
+    fd = STDIN_FILENO; /* use stdin if the tty could not be used */
 
   disabled = ttyecho(FALSE, fd); /* disable terminal echo */
 
diff --git a/src/tool_getpass.h b/src/tool_getpass.h
index b93585d94..0a4d6d5a8 100644
--- a/src/tool_getpass.h
+++ b/src/tool_getpass.h
@@ -26,7 +26,7 @@
 #include "tool_setup.h"
 
 #ifndef HAVE_GETPASS_R
-/* If there's a system-provided function named like this, we trust it is
+/* If there is a system-provided function named like this, we trust it is
    also found in one of the standard headers. */
 
 /*
diff --git a/src/tool_help.c b/src/tool_help.c
index f74033d0a..a12626eff 100644
--- a/src/tool_help.c
+++ b/src/tool_help.c
@@ -31,6 +31,7 @@
 #include "tool_util.h"
 #include "tool_version.h"
 #include "tool_cb_prg.h"
+#include "terminal.h"
 
 #include "memdebug.h" /* keep this as LAST include */
 
@@ -38,44 +39,46 @@
 #  define USE_WATT32
 #endif
 
+#ifndef ARRAYSIZE
+#define ARRAYSIZE(A) (sizeof(A)/sizeof((A)[0]))
+#endif
+
 struct category_descriptors {
   const char *opt;
   const char *desc;
-  curlhelp_t category;
+  unsigned int category;
 };
 
 static const struct category_descriptors categories[] = {
-  {"auth", "Different types of authentication methods", CURLHELP_AUTH},
-  {"connection", "Low level networking operations",
-   CURLHELP_CONNECTION},
-  {"curl", "The command line tool itself", CURLHELP_CURL},
-  {"dns", "General DNS options", CURLHELP_DNS},
-  {"file", "FILE protocol options", CURLHELP_FILE},
-  {"ftp", "FTP protocol options", CURLHELP_FTP},
-  {"http", "HTTP and HTTPS protocol options", CURLHELP_HTTP},
-  {"imap", "IMAP protocol options", CURLHELP_IMAP},
   /* important is left out because it is the default help page */
-  {"misc", "Options that don't fit into any other category", CURLHELP_MISC},
+  {"auth", "Authentication methods", CURLHELP_AUTH},
+  {"connection", "Manage connections", CURLHELP_CONNECTION},
+  {"curl", "The command line tool itself", CURLHELP_CURL},
+  {"deprecated", "Legacy", CURLHELP_DEPRECATED},
+  {"dns", "Names and resolving", CURLHELP_DNS},
+  {"file", "FILE protocol", CURLHELP_FILE},
+  {"ftp", "FTP protocol", CURLHELP_FTP},
+  {"global", "Global options", CURLHELP_GLOBAL},
+  {"http", "HTTP and HTTPS protocol", CURLHELP_HTTP},
+  {"imap", "IMAP protocol", CURLHELP_IMAP},
+  {"ldap", "LDAP protocol", CURLHELP_LDAP},
   {"output", "Filesystem output", CURLHELP_OUTPUT},
-  {"pop3", "POP3 protocol options", CURLHELP_POP3},
-  {"post", "HTTP Post specific options", CURLHELP_POST},
-  {"proxy", "All options related to proxies", CURLHELP_PROXY},
-  {"scp", "SCP protocol options", CURLHELP_SCP},
-  {"sftp", "SFTP protocol options", CURLHELP_SFTP},
-  {"smtp", "SMTP protocol options", CURLHELP_SMTP},
-  {"ssh", "SSH protocol options", CURLHELP_SSH},
-  {"telnet", "TELNET protocol options", CURLHELP_TELNET},
-  {"tftp", "TFTP protocol options", CURLHELP_TFTP},
-  {"tls", "All TLS/SSL related options", CURLHELP_TLS},
-  {"ech", "All Encrypted Client Hello (ECH) options", CURLHELP_ECH},
-  {"upload", "All options for uploads",
-   CURLHELP_UPLOAD},
-  {"verbose", "Options related to any kind of command line output of curl",
-   CURLHELP_VERBOSE},
-  {NULL, NULL, CURLHELP_HIDDEN}
+  {"pop3", "POP3 protocol", CURLHELP_POP3},
+  {"post", "HTTP POST specific", CURLHELP_POST},
+  {"proxy", "Options for proxies", CURLHELP_PROXY},
+  {"scp", "SCP protocol", CURLHELP_SCP},
+  {"sftp", "SFTP protocol", CURLHELP_SFTP},
+  {"smtp", "SMTP protocol", CURLHELP_SMTP},
+  {"ssh", "SSH protocol", CURLHELP_SSH},
+  {"telnet", "TELNET protocol", CURLHELP_TELNET},
+  {"tftp", "TFTP protocol", CURLHELP_TFTP},
+  {"timeout", "Timeouts and delays", CURLHELP_TIMEOUT},
+  {"tls", "TLS/SSL related", CURLHELP_TLS},
+  {"upload", "Upload, sending data", CURLHELP_UPLOAD},
+  {"verbose", "Tracing, logging etc", CURLHELP_VERBOSE}
 };
 
-static void print_category(curlhelp_t category, unsigned int cols)
+static void print_category(unsigned int category, unsigned int cols)
 {
   unsigned int i;
   size_t longopt = 5;
@@ -113,7 +116,7 @@ static void print_category(curlhelp_t category, unsigned int cols)
 static int get_category_content(const char *category, unsigned int cols)
 {
   unsigned int i;
-  for(i = 0; categories[i].opt; ++i)
+  for(i = 0; i < ARRAYSIZE(categories); ++i)
     if(curl_strequal(categories[i].opt, category)) {
       printf("%s: %s\n", categories[i].opt, categories[i].desc);
       print_category(categories[i].category, cols);
@@ -126,10 +129,37 @@ static int get_category_content(const char *category, unsigned int cols)
 static void get_categories(void)
 {
   unsigned int i;
-  for(i = 0; categories[i].opt; ++i)
+  for(i = 0; i < ARRAYSIZE(categories); ++i)
     printf(" %-11s %s\n", categories[i].opt, categories[i].desc);
 }
 
+/* Prints all categories as a comma-separated list of given width */
+static void get_categories_list(unsigned int width)
+{
+  unsigned int i;
+  size_t col = 0;
+  for(i = 0; i < ARRAYSIZE(categories); ++i) {
+    size_t len = strlen(categories[i].opt);
+    if(i == ARRAYSIZE(categories) - 1) {
+      /* final category */
+      if(col + len + 1 < width)
+        printf("%s.\n", categories[i].opt);
+      else
+        /* start a new line first */
+        printf("\n%s.\n", categories[i].opt);
+    }
+    else if(col + len + 2 < width) {
+      printf("%s, ", categories[i].opt);
+      col += len + 2;
+    }
+    else {
+      /* start a new line first */
+      printf("\n%s, ", categories[i].opt);
+      col = len + 2;
+    }
+  }
+}
+
 
 void tool_help(char *category)
 {
@@ -137,23 +167,26 @@ void tool_help(char *category)
   puts("Usage: curl [options...] <url>");
   /* If no category was provided */
   if(!category) {
-    const char *category_note = "\nThis is not the full help, this "
-      "menu is stripped into categories.\nUse \"--help category\" to get "
-      "an overview of all categories.\nFor all options use the manual"
+    const char *category_note = "\nThis is not the full help; this "
+      "menu is split into categories.\nUse \"--help category\" to get "
+      "an overview of all categories, which are:";
+    const char *category_note2 = "For all options use the manual"
       " or \"--help all\".";
     print_category(CURLHELP_IMPORTANT, cols);
     puts(category_note);
+    get_categories_list(cols);
+    puts(category_note2);
   }
   /* Lets print everything if "all" was provided */
   else if(curl_strequal(category, "all"))
-    /* Print everything except hidden */
-    print_category(~(CURLHELP_HIDDEN), cols);
+    /* Print everything */
+    print_category(CURLHELP_ALL, cols);
   /* Lets handle the string "category" differently to not print an errormsg */
   else if(curl_strequal(category, "category"))
     get_categories();
   /* Otherwise print category and handle the case if the cat was not found */
   else if(get_category_content(category, cols)) {
-    puts("Invalid category provided, here is a list of all categories:\n");
+    puts("Unknown category provided, here is a list of all categories:\n");
     get_categories();
   }
   free(category);
diff --git a/src/tool_help.h b/src/tool_help.h
index 894e39f85..299da1db8 100644
--- a/src/tool_help.h
+++ b/src/tool_help.h
@@ -29,12 +29,10 @@ void tool_help(char *category);
 void tool_list_engines(void);
 void tool_version_info(void);
 
-typedef unsigned int curlhelp_t;
-
 struct helptxt {
   const char *opt;
   const char *desc;
-  curlhelp_t categories;
+  unsigned int categories;
 };
 
 /*
@@ -43,32 +41,34 @@ struct helptxt {
   make -C docs/cmdline-opts listcats
  */
 
-#define CURLHELP_HIDDEN 1u << 0u
-#define CURLHELP_AUTH 1u << 1u
-#define CURLHELP_CONNECTION 1u << 2u
-#define CURLHELP_CURL 1u << 3u
-#define CURLHELP_DNS 1u << 4u
-#define CURLHELP_FILE 1u << 5u
-#define CURLHELP_FTP 1u << 6u
-#define CURLHELP_HTTP 1u << 7u
-#define CURLHELP_IMAP 1u << 8u
-#define CURLHELP_IMPORTANT 1u << 9u
-#define CURLHELP_IPFS 1u << 10u
-#define CURLHELP_MISC 1u << 11u
-#define CURLHELP_OUTPUT 1u << 12u
-#define CURLHELP_POP3 1u << 13u
-#define CURLHELP_POST 1u << 14u
-#define CURLHELP_PROXY 1u << 15u
-#define CURLHELP_SCP 1u << 16u
-#define CURLHELP_SFTP 1u << 17u
-#define CURLHELP_SMTP 1u << 18u
-#define CURLHELP_SSH 1u << 19u
-#define CURLHELP_TELNET 1u << 20u
-#define CURLHELP_TFTP 1u << 21u
-#define CURLHELP_TLS 1u << 22u
-#define CURLHELP_UPLOAD 1u << 23u
-#define CURLHELP_VERBOSE 1u << 24u
-#define CURLHELP_ECH 1u << 25u
+#define CURLHELP_AUTH       (1u << 0u)
+#define CURLHELP_CONNECTION (1u << 1u)
+#define CURLHELP_CURL       (1u << 2u)
+#define CURLHELP_DEPRECATED (1u << 3u)
+#define CURLHELP_DNS        (1u << 4u)
+#define CURLHELP_FILE       (1u << 5u)
+#define CURLHELP_FTP        (1u << 6u)
+#define CURLHELP_GLOBAL     (1u << 7u)
+#define CURLHELP_HTTP       (1u << 8u)
+#define CURLHELP_IMAP       (1u << 9u)
+#define CURLHELP_IMPORTANT  (1u << 10u)
+#define CURLHELP_LDAP       (1u << 11u)
+#define CURLHELP_OUTPUT     (1u << 12u)
+#define CURLHELP_POP3       (1u << 13u)
+#define CURLHELP_POST       (1u << 14u)
+#define CURLHELP_PROXY      (1u << 15u)
+#define CURLHELP_SCP        (1u << 16u)
+#define CURLHELP_SFTP       (1u << 17u)
+#define CURLHELP_SMTP       (1u << 18u)
+#define CURLHELP_SSH        (1u << 19u)
+#define CURLHELP_TELNET     (1u << 20u)
+#define CURLHELP_TFTP       (1u << 21u)
+#define CURLHELP_TIMEOUT    (1u << 22u)
+#define CURLHELP_TLS        (1u << 23u)
+#define CURLHELP_UPLOAD     (1u << 24u)
+#define CURLHELP_VERBOSE    (1u << 25u)
+
+#define CURLHELP_ALL        (0xfffffffu)
 
 extern const struct helptxt helptext[];
 
diff --git a/src/tool_helpers.c b/src/tool_helpers.c
index 8d7a0387a..0f9ac45a8 100644
--- a/src/tool_helpers.c
+++ b/src/tool_helpers.c
@@ -58,17 +58,17 @@ const char *param2text(ParameterError error)
   case PARAM_NEGATIVE_NUMERIC:
     return "expected a positive numerical parameter";
   case PARAM_LIBCURL_DOESNT_SUPPORT:
-    return "the installed libcurl version doesn't support this";
+    return "the installed libcurl version does not support this";
   case PARAM_LIBCURL_UNSUPPORTED_PROTOCOL:
     return "a specified protocol is unsupported by libcurl";
   case PARAM_NO_MEM:
     return "out of memory";
   case PARAM_NO_PREFIX:
-    return "the given option can't be reversed with a --no- prefix";
+    return "the given option cannot be reversed with a --no- prefix";
   case PARAM_NUMBER_TOO_LARGE:
     return "too large number";
   case PARAM_NO_NOT_BOOLEAN:
-    return "used '--no-' for option that isn't a boolean";
+    return "used '--no-' for option that is not a boolean";
   case PARAM_CONTDISP_SHOW_HEADER:
     return "showing headers and --remote-header-name cannot be combined";
   case PARAM_CONTDISP_RESUME_FROM:
diff --git a/src/tool_ipfs.c b/src/tool_ipfs.c
index 8e4f3b7ea..62ef9f604 100644
--- a/src/tool_ipfs.c
+++ b/src/tool_ipfs.c
@@ -81,7 +81,7 @@ static char *ipfs_gateway(void)
     char *home = getenv("HOME");
     if(home && *home)
       ipfs_path = aprintf("%s/.ipfs/", home);
-    /* fallback to "~/.ipfs", as that's the default location. */
+    /* fallback to "~/.ipfs", as that is the default location. */
   }
 
   if(!ipfs_path || ensure_trailing_slash(&ipfs_path))
@@ -132,7 +132,7 @@ fail:
 }
 
 /*
- * Rewrite ipfs://<cid> and ipns://<cid> to a HTTP(S)
+ * Rewrite ipfs://<cid> and ipns://<cid> to an HTTP(S)
  * URL that can be handled by an IPFS gateway.
  */
 CURLcode ipfs_url_rewrite(CURLU *uh, const char *protocol, char **url,
@@ -162,7 +162,7 @@ CURLcode ipfs_url_rewrite(CURLU *uh, const char *protocol, char **url,
     goto clean;
 
   /* We might have a --ipfs-gateway argument. Check it first and use it. Error
-   * if we do have something but if it's an invalid url.
+   * if we do have something but if it is an invalid url.
    */
   if(config->ipfs_gateway) {
     /* ensure the gateway ends in a trailing / */
diff --git a/src/tool_libinfo.c b/src/tool_libinfo.c
index 0bf3a90bf..2b74e4e5e 100644
--- a/src/tool_libinfo.c
+++ b/src/tool_libinfo.c
@@ -33,7 +33,7 @@
 
 #include "memdebug.h" /* keep this as LAST include */
 
-/* global variable definitions, for libcurl run-time info */
+/* global variable definitions, for libcurl runtime info */
 
 static const char *no_protos = NULL;
 
@@ -126,8 +126,8 @@ static const char *fnames[sizeof(maybe_feature) / sizeof(maybe_feature[0])];
 const char * const *feature_names = fnames;
 
 /*
- * libcurl_info_init: retrieves run-time information about libcurl,
- * setting a global pointer 'curlinfo' to libcurl's run-time info
+ * libcurl_info_init: retrieves runtime information about libcurl,
+ * setting a global pointer 'curlinfo' to libcurl's runtime info
  * struct, count protocols and flag those we are interested in.
  * Global pointer feature_names is set to the feature names array. If
  * the latter is not returned by curl_version_info(), it is built from
@@ -139,7 +139,7 @@ CURLcode get_libcurl_info(void)
   CURLcode result = CURLE_OK;
   const char *const *builtin;
 
-  /* Pointer to libcurl's run-time version information */
+  /* Pointer to libcurl's runtime version information */
   curlinfo = curl_version_info(CURLVERSION_NOW);
   if(!curlinfo)
     return CURLE_FAILED_INIT;
diff --git a/src/tool_libinfo.h b/src/tool_libinfo.h
index 46063ad1b..e69f35829 100644
--- a/src/tool_libinfo.h
+++ b/src/tool_libinfo.h
@@ -25,7 +25,7 @@
  ***************************************************************************/
 #include "tool_setup.h"
 
-/* global variable declarations, for libcurl run-time info */
+/* global variable declarations, for libcurl runtime info */
 
 
 extern curl_version_info_data *curlinfo;
diff --git a/src/tool_listhelp.c b/src/tool_listhelp.c
index 842932204..a825a0315 100644
--- a/src/tool_listhelp.c
+++ b/src/tool_listhelp.c
@@ -83,10 +83,10 @@ const struct helptxt helptext[] = {
    CURLHELP_CURL},
   {"    --connect-timeout <seconds>",
    "Maximum time allowed to connect",
-   CURLHELP_CONNECTION},
+   CURLHELP_CONNECTION | CURLHELP_TIMEOUT},
   {"    --connect-to <HOST1:PORT1:HOST2:PORT2>",
-   "Connect to host",
-   CURLHELP_CONNECTION},
+   "Connect to host2 instead of host1",
+   CURLHELP_CONNECTION | CURLHELP_DNS},
   {"-C, --continue-at <offset>",
    "Resumed transfer offset",
    CURLHELP_CONNECTION},
@@ -98,7 +98,7 @@ const struct helptxt helptext[] = {
    CURLHELP_HTTP},
   {"    --create-dirs",
    "Create necessary local directory hierarchy",
-   CURLHELP_CURL},
+   CURLHELP_OUTPUT},
   {"    --create-file-mode <mode>",
    "File mode for created files",
    CURLHELP_SFTP | CURLHELP_SCP | CURLHELP_FILE | CURLHELP_UPLOAD},
@@ -169,11 +169,11 @@ const struct helptxt helptext[] = {
    "Write the received headers to <filename>",
    CURLHELP_HTTP | CURLHELP_FTP},
   {"    --ech <config>",
-   "Configure Encrypted Client Hello (ECH) for use with the TLS session",
-   CURLHELP_TLS | CURLHELP_ECH},
+   "Configure ECH",
+   CURLHELP_TLS},
   {"    --egd-file <file>",
    "EGD socket path for random data",
-   CURLHELP_TLS},
+   CURLHELP_DEPRECATED},
   {"    --engine <name>",
    "Crypto engine to use",
    CURLHELP_TLS},
@@ -185,13 +185,13 @@ const struct helptxt helptext[] = {
    CURLHELP_HTTP},
   {"    --expect100-timeout <seconds>",
    "How long to wait for 100-continue",
-   CURLHELP_HTTP},
+   CURLHELP_HTTP | CURLHELP_TIMEOUT},
   {"-f, --fail",
    "Fail fast with no output on HTTP errors",
    CURLHELP_IMPORTANT | CURLHELP_HTTP},
   {"    --fail-early",
    "Fail on first transfer error",
-   CURLHELP_CURL},
+   CURLHELP_CURL | CURLHELP_GLOBAL},
   {"    --fail-with-body",
    "Fail on HTTP errors but save the body",
    CURLHELP_HTTP | CURLHELP_OUTPUT},
@@ -200,13 +200,15 @@ const struct helptxt helptext[] = {
    CURLHELP_TLS},
   {"-F, --form <name=content>",
    "Specify multipart MIME data",
-   CURLHELP_HTTP | CURLHELP_UPLOAD},
+   CURLHELP_HTTP | CURLHELP_UPLOAD | CURLHELP_POST | CURLHELP_IMAP |
+   CURLHELP_SMTP},
   {"    --form-escape",
    "Escape form fields using backslash",
-   CURLHELP_HTTP | CURLHELP_UPLOAD},
+   CURLHELP_HTTP | CURLHELP_UPLOAD | CURLHELP_POST},
   {"    --form-string <name=string>",
    "Specify multipart MIME data",
-   CURLHELP_HTTP | CURLHELP_UPLOAD},
+   CURLHELP_HTTP | CURLHELP_UPLOAD | CURLHELP_POST | CURLHELP_SMTP |
+   CURLHELP_IMAP},
   {"    --ftp-account <data>",
    "Account data string",
    CURLHELP_FTP | CURLHELP_AUTH},
@@ -215,7 +217,7 @@ const struct helptxt helptext[] = {
    CURLHELP_FTP},
   {"    --ftp-create-dirs",
    "Create the remote dirs if not present",
-   CURLHELP_FTP | CURLHELP_SFTP | CURLHELP_CURL},
+   CURLHELP_FTP | CURLHELP_SFTP},
   {"    --ftp-method <method>",
    "Control CWD usage",
    CURLHELP_FTP},
@@ -242,13 +244,13 @@ const struct helptxt helptext[] = {
    CURLHELP_FTP | CURLHELP_TLS},
   {"-G, --get",
    "Put the post data in the URL and use GET",
-   CURLHELP_HTTP | CURLHELP_UPLOAD},
+   CURLHELP_HTTP},
   {"-g, --globoff",
    "Disable URL globbing with {} and []",
    CURLHELP_CURL},
   {"    --happy-eyeballs-timeout-ms <ms>",
    "Time for IPv6 before IPv4",
-   CURLHELP_CONNECTION},
+   CURLHELP_CONNECTION | CURLHELP_TIMEOUT},
   {"    --haproxy-clientip <ip>",
    "Set address in HAProxy PROXY",
    CURLHELP_HTTP | CURLHELP_PROXY},
@@ -266,10 +268,10 @@ const struct helptxt helptext[] = {
    CURLHELP_IMPORTANT | CURLHELP_CURL},
   {"    --hostpubmd5 <md5>",
    "Acceptable MD5 hash of host public key",
-   CURLHELP_SFTP | CURLHELP_SCP},
+   CURLHELP_SFTP | CURLHELP_SCP | CURLHELP_SSH},
   {"    --hostpubsha256 <sha256>",
    "Acceptable SHA256 hash of host public key",
-   CURLHELP_SFTP | CURLHELP_SCP},
+   CURLHELP_SFTP | CURLHELP_SCP | CURLHELP_SSH},
   {"    --hsts <filename>",
    "Enable HSTS with this cache file",
    CURLHELP_HTTP},
@@ -302,13 +304,16 @@ const struct helptxt helptext[] = {
    CURLHELP_IMPORTANT | CURLHELP_VERBOSE},
   {"-k, --insecure",
    "Allow insecure server connections",
-   CURLHELP_TLS | CURLHELP_SFTP | CURLHELP_SCP},
+   CURLHELP_TLS | CURLHELP_SFTP | CURLHELP_SCP | CURLHELP_SSH},
   {"    --interface <name>",
-   "Use network INTERFACE (or address)",
+   "Use network interface",
+   CURLHELP_CONNECTION},
+  {"    --ip-tos <string>",
+   "Set IP Type of Service or Traffic Class",
    CURLHELP_CONNECTION},
   {"    --ipfs-gateway <URL>",
    "Gateway for IPFS",
-   CURLHELP_IPFS},
+   CURLHELP_CURL},
   {"-4, --ipv4",
    "Resolve names to IPv4 addresses",
    CURLHELP_CONNECTION | CURLHELP_DNS},
@@ -321,9 +326,12 @@ const struct helptxt helptext[] = {
   {"-j, --junk-session-cookies",
    "Ignore session cookies read from file",
    CURLHELP_HTTP},
+  {"    --keepalive-cnt <integer>",
+   "Maximum number of keepalive probes",
+   CURLHELP_CONNECTION},
   {"    --keepalive-time <seconds>",
    "Interval time for keepalive probes",
-   CURLHELP_CONNECTION},
+   CURLHELP_CONNECTION | CURLHELP_TIMEOUT},
   {"    --key <key>",
    "Private key filename",
    CURLHELP_TLS | CURLHELP_SSH},
@@ -335,7 +343,7 @@ const struct helptxt helptext[] = {
    CURLHELP_FTP},
   {"    --libcurl <file>",
    "Generate libcurl code for this command line",
-   CURLHELP_CURL},
+   CURLHELP_CURL | CURLHELP_GLOBAL},
   {"    --limit-rate <speed>",
    "Limit transfer speed to RATE",
    CURLHELP_CONNECTION},
@@ -349,11 +357,12 @@ const struct helptxt helptext[] = {
    "Follow redirects",
    CURLHELP_HTTP},
   {"    --location-trusted",
-   "Like --location, but send auth to other hosts",
+   "As --location, but send auth to other hosts",
    CURLHELP_HTTP | CURLHELP_AUTH},
   {"    --login-options <options>",
    "Server login options",
-   CURLHELP_IMAP | CURLHELP_POP3 | CURLHELP_SMTP | CURLHELP_AUTH},
+   CURLHELP_IMAP | CURLHELP_POP3 | CURLHELP_SMTP | CURLHELP_AUTH |
+   CURLHELP_LDAP},
   {"    --mail-auth <address>",
    "Originator address of the original email",
    CURLHELP_SMTP},
@@ -377,40 +386,43 @@ const struct helptxt helptext[] = {
    CURLHELP_HTTP},
   {"-m, --max-time <seconds>",
    "Maximum time allowed for transfer",
-   CURLHELP_CONNECTION},
+   CURLHELP_CONNECTION | CURLHELP_TIMEOUT},
   {"    --metalink",
    "Process given URLs as metalink XML file",
-   CURLHELP_MISC},
+   CURLHELP_DEPRECATED},
+  {"    --mptcp",
+   "Enable Multipath TCP",
+   CURLHELP_CONNECTION},
   {"    --negotiate",
    "Use HTTP Negotiate (SPNEGO) authentication",
    CURLHELP_AUTH | CURLHELP_HTTP},
   {"-n, --netrc",
    "Must read .netrc for username and password",
-   CURLHELP_CURL},
+   CURLHELP_AUTH},
   {"    --netrc-file <filename>",
    "Specify FILE for netrc",
-   CURLHELP_CURL},
+   CURLHELP_AUTH},
   {"    --netrc-optional",
    "Use either .netrc or URL",
-   CURLHELP_CURL},
+   CURLHELP_AUTH},
   {"-:, --next",
-   "Make next URL use its separate set of options",
+   "Make next URL use separate options",
    CURLHELP_CURL},
   {"    --no-alpn",
    "Disable the ALPN TLS extension",
    CURLHELP_TLS | CURLHELP_HTTP},
   {"-N, --no-buffer",
    "Disable buffering of the output stream",
-   CURLHELP_CURL},
+   CURLHELP_OUTPUT},
   {"    --no-clobber",
    "Do not overwrite files that already exist",
-   CURLHELP_CURL | CURLHELP_OUTPUT},
+   CURLHELP_OUTPUT},
   {"    --no-keepalive",
    "Disable TCP keepalive on the connection",
    CURLHELP_CONNECTION},
   {"    --no-npn",
    "Disable the NPN TLS extension",
-   CURLHELP_TLS | CURLHELP_HTTP},
+   CURLHELP_DEPRECATED},
   {"    --no-progress-meter",
    "Do not show the progress meter",
    CURLHELP_VERBOSE},
@@ -425,33 +437,34 @@ const struct helptxt helptext[] = {
    CURLHELP_AUTH | CURLHELP_HTTP},
   {"    --ntlm-wb",
    "HTTP NTLM authentication with winbind",
-   CURLHELP_AUTH | CURLHELP_HTTP},
+   CURLHELP_DEPRECATED},
   {"    --oauth2-bearer <token>",
    "OAuth 2 Bearer Token",
-   CURLHELP_AUTH},
+   CURLHELP_AUTH | CURLHELP_IMAP | CURLHELP_POP3 | CURLHELP_SMTP |
+   CURLHELP_LDAP},
   {"-o, --output <file>",
    "Write to file instead of stdout",
-   CURLHELP_IMPORTANT | CURLHELP_CURL},
+   CURLHELP_IMPORTANT | CURLHELP_OUTPUT},
   {"    --output-dir <dir>",
    "Directory to save files in",
-   CURLHELP_CURL},
+   CURLHELP_OUTPUT},
   {"-Z, --parallel",
    "Perform transfers in parallel",
-   CURLHELP_CONNECTION | CURLHELP_CURL},
+   CURLHELP_CONNECTION | CURLHELP_CURL | CURLHELP_GLOBAL},
   {"    --parallel-immediate",
-   "Do not wait for multiplexing (with --parallel)",
-   CURLHELP_CONNECTION | CURLHELP_CURL},
+   "Do not wait for multiplexing",
+   CURLHELP_CONNECTION | CURLHELP_CURL | CURLHELP_GLOBAL},
   {"    --parallel-max <num>",
    "Maximum concurrency for parallel transfers",
-   CURLHELP_CONNECTION | CURLHELP_CURL},
+   CURLHELP_CONNECTION | CURLHELP_CURL | CURLHELP_GLOBAL},
   {"    --pass <phrase>",
-   "Pass phrase for the private key",
+   "Passphrase for the private key",
    CURLHELP_SSH | CURLHELP_TLS | CURLHELP_AUTH},
   {"    --path-as-is",
    "Do not squash .. sequences in URL path",
    CURLHELP_CURL},
   {"    --pinnedpubkey <hashes>",
-   "FILE/HASHES Public key to verify peer against",
+   "Public key to verify peer against",
    CURLHELP_TLS},
   {"    --post301",
    "Do not switch to GET after a 301 redirect",
@@ -467,7 +480,7 @@ const struct helptxt helptext[] = {
    CURLHELP_PROXY},
   {"-#, --progress-bar",
    "Display transfer progress as a bar",
-   CURLHELP_VERBOSE},
+   CURLHELP_VERBOSE | CURLHELP_GLOBAL},
   {"    --proto <protocols>",
    "Enable/disable PROTOCOLS",
    CURLHELP_CONNECTION | CURLHELP_CURL},
@@ -532,7 +545,7 @@ const struct helptxt helptext[] = {
    "NTLM authentication with the proxy",
    CURLHELP_PROXY | CURLHELP_AUTH},
   {"    --proxy-pass <phrase>",
-   "Pass phrase for the private key for HTTPS proxy",
+   "Passphrase for private key for HTTPS proxy",
    CURLHELP_PROXY | CURLHELP_TLS | CURLHELP_AUTH},
   {"    --proxy-pinnedpubkey <hashes>",
    "FILE/HASHES public key to verify proxy with",
@@ -541,7 +554,7 @@ const struct helptxt helptext[] = {
    "SPNEGO proxy service name",
    CURLHELP_PROXY | CURLHELP_TLS},
   {"    --proxy-ssl-allow-beast",
-   "Allow security flaw for interop for HTTPS proxy",
+   "Allow this security flaw for HTTPS proxy",
    CURLHELP_PROXY | CURLHELP_TLS},
   {"    --proxy-ssl-auto-client-cert",
    "Auto client certificate for proxy",
@@ -572,19 +585,19 @@ const struct helptxt helptext[] = {
    CURLHELP_PROXY},
   {"    --pubkey <key>",
    "SSH Public key filename",
-   CURLHELP_SFTP | CURLHELP_SCP | CURLHELP_AUTH},
+   CURLHELP_SFTP | CURLHELP_SCP | CURLHELP_SSH | CURLHELP_AUTH},
   {"-Q, --quote <command>",
    "Send command(s) to server before transfer",
    CURLHELP_FTP | CURLHELP_SFTP},
   {"    --random-file <file>",
    "File for reading random data from",
-   CURLHELP_MISC},
+   CURLHELP_DEPRECATED},
   {"-r, --range <range>",
    "Retrieve only the bytes within RANGE",
    CURLHELP_HTTP | CURLHELP_FTP | CURLHELP_SFTP | CURLHELP_FILE},
   {"    --rate <max request rate>",
    "Request rate for serial transfers",
-   CURLHELP_CONNECTION},
+   CURLHELP_CONNECTION | CURLHELP_GLOBAL},
   {"    --raw",
    "Do HTTP raw; no transfer decoding",
    CURLHELP_HTTP},
@@ -605,10 +618,11 @@ const struct helptxt helptext[] = {
    CURLHELP_OUTPUT},
   {"    --remove-on-error",
    "Remove output file on errors",
-   CURLHELP_CURL},
+   CURLHELP_OUTPUT},
   {"-X, --request <method>",
    "Specify request method to use",
-   CURLHELP_CONNECTION},
+   CURLHELP_CONNECTION | CURLHELP_POP3 | CURLHELP_FTP | CURLHELP_IMAP |
+   CURLHELP_SMTP},
   {"    --request-target <path>",
    "Specify the target for this request",
    CURLHELP_HTTP},
@@ -626,10 +640,10 @@ const struct helptxt helptext[] = {
    CURLHELP_CURL},
   {"    --retry-delay <seconds>",
    "Wait time between retries",
-   CURLHELP_CURL},
+   CURLHELP_CURL | CURLHELP_TIMEOUT},
   {"    --retry-max-time <seconds>",
    "Retry only within this period",
-   CURLHELP_CURL},
+   CURLHELP_CURL | CURLHELP_TIMEOUT},
   {"    --sasl-authzid <identity>",
    "Identity for SASL PLAIN authentication",
    CURLHELP_AUTH},
@@ -638,10 +652,10 @@ const struct helptxt helptext[] = {
    CURLHELP_AUTH},
   {"    --service-name <name>",
    "SPNEGO service name",
-   CURLHELP_MISC},
+   CURLHELP_AUTH},
   {"-S, --show-error",
    "Show error even when -s is used",
-   CURLHELP_CURL},
+   CURLHELP_CURL | CURLHELP_GLOBAL},
   {"-s, --silent",
    "Silent mode",
    CURLHELP_IMPORTANT | CURLHELP_VERBOSE},
@@ -674,10 +688,11 @@ const struct helptxt helptext[] = {
    CURLHELP_CONNECTION},
   {"-y, --speed-time <seconds>",
    "Trigger 'speed-limit' abort after this time",
-   CURLHELP_CONNECTION},
+   CURLHELP_CONNECTION | CURLHELP_TIMEOUT},
   {"    --ssl",
    "Try enabling TLS",
-   CURLHELP_TLS},
+   CURLHELP_TLS | CURLHELP_IMAP | CURLHELP_POP3 | CURLHELP_SMTP |
+   CURLHELP_LDAP},
   {"    --ssl-allow-beast",
    "Allow security flaw to improve interop",
    CURLHELP_TLS},
@@ -689,22 +704,23 @@ const struct helptxt helptext[] = {
    CURLHELP_TLS},
   {"    --ssl-reqd",
    "Require SSL/TLS",
-   CURLHELP_TLS},
+   CURLHELP_TLS | CURLHELP_IMAP | CURLHELP_POP3 | CURLHELP_SMTP |
+   CURLHELP_LDAP},
   {"    --ssl-revoke-best-effort",
    "Ignore missing cert CRL dist points",
    CURLHELP_TLS},
   {"-2, --sslv2",
    "SSLv2",
-   CURLHELP_TLS},
+   CURLHELP_DEPRECATED},
   {"-3, --sslv3",
    "SSLv3",
-   CURLHELP_TLS},
+   CURLHELP_DEPRECATED},
   {"    --stderr <file>",
    "Where to redirect stderr",
-   CURLHELP_VERBOSE},
+   CURLHELP_VERBOSE | CURLHELP_GLOBAL},
   {"    --styled-output",
    "Enable styled output for HTTP headers",
-   CURLHELP_VERBOSE},
+   CURLHELP_VERBOSE | CURLHELP_GLOBAL},
   {"    --suppress-connect-headers",
    "Suppress proxy CONNECT response headers",
    CURLHELP_PROXY},
@@ -761,19 +777,19 @@ const struct helptxt helptext[] = {
    CURLHELP_HTTP},
   {"    --trace <file>",
    "Write a debug trace to FILE",
-   CURLHELP_VERBOSE},
+   CURLHELP_VERBOSE | CURLHELP_GLOBAL},
   {"    --trace-ascii <file>",
    "Like --trace, but without hex output",
-   CURLHELP_VERBOSE},
+   CURLHELP_VERBOSE | CURLHELP_GLOBAL},
   {"    --trace-config <string>",
    "Details to log in trace/verbose output",
-   CURLHELP_VERBOSE},
+   CURLHELP_VERBOSE | CURLHELP_GLOBAL},
   {"    --trace-ids",
    "Transfer + connection ids in verbose output",
-   CURLHELP_VERBOSE},
+   CURLHELP_VERBOSE | CURLHELP_GLOBAL},
   {"    --trace-time",
    "Add time stamps to trace/verbose output",
-   CURLHELP_VERBOSE},
+   CURLHELP_VERBOSE | CURLHELP_GLOBAL},
   {"    --unix-socket <path>",
    "Connect through this Unix domain socket",
    CURLHELP_CONNECTION},
@@ -788,7 +804,7 @@ const struct helptxt helptext[] = {
    CURLHELP_HTTP | CURLHELP_POST | CURLHELP_UPLOAD},
   {"-B, --use-ascii",
    "Use ASCII/text transfer",
-   CURLHELP_MISC},
+   CURLHELP_FTP | CURLHELP_OUTPUT | CURLHELP_LDAP},
   {"-u, --user <user:password>",
    "Server user and password",
    CURLHELP_IMPORTANT | CURLHELP_AUTH},
@@ -800,15 +816,18 @@ const struct helptxt helptext[] = {
    CURLHELP_CURL},
   {"-v, --verbose",
    "Make the operation more talkative",
-   CURLHELP_IMPORTANT | CURLHELP_VERBOSE},
+   CURLHELP_IMPORTANT | CURLHELP_VERBOSE | CURLHELP_GLOBAL},
   {"-V, --version",
    "Show version number and quit",
    CURLHELP_IMPORTANT | CURLHELP_CURL},
+  {"    --vlan-priority <priority>",
+   "Set VLAN priority",
+   CURLHELP_CONNECTION},
   {"-w, --write-out <format>",
    "Output FORMAT after completion",
    CURLHELP_VERBOSE},
   {"    --xattr",
    "Store metadata in extended file attributes",
-   CURLHELP_MISC},
-  { NULL, NULL, CURLHELP_HIDDEN }
+   CURLHELP_OUTPUT},
+  { NULL, NULL, 0 }
 };
diff --git a/src/tool_main.c b/src/tool_main.c
index d0f033369..9d7d1991a 100644
--- a/src/tool_main.c
+++ b/src/tool_main.c
@@ -81,7 +81,7 @@ int _CRT_glob = 0;
 #if defined(HAVE_PIPE) && defined(HAVE_FCNTL)
 /*
  * Ensure that file descriptors 0, 1 and 2 (stdin, stdout, stderr) are
- * open before starting to run.  Otherwise, the first three network
+ * open before starting to run. Otherwise, the first three network
  * sockets opened by curl could be used for input sources, downloaded data
  * or error logs as they will effectively be stdin, stdout and/or stderr.
  *
@@ -110,7 +110,7 @@ static void memory_tracking_init(void)
   /* if CURL_MEMDEBUG is set, this starts memory tracking message logging */
   env = curl_getenv("CURL_MEMDEBUG");
   if(env) {
-    /* use the value as file name */
+    /* use the value as filename */
     char fname[CURL_MT_LOGFNAME_BUFSIZE];
     if(strlen(env) >= CURL_MT_LOGFNAME_BUFSIZE)
       env[CURL_MT_LOGFNAME_BUFSIZE-1] = '\0';
@@ -219,7 +219,7 @@ static void main_free(struct GlobalConfig *config)
 */
 #ifdef _UNICODE
 #if defined(__GNUC__)
-/* GCC doesn't know about wmain() */
+/* GCC does not know about wmain() */
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wmissing-prototypes"
 #pragma GCC diagnostic ignored "-Wmissing-declarations"
diff --git a/src/tool_msgs.c b/src/tool_msgs.c
index 09c9310a5..47e625c1e 100644
--- a/src/tool_msgs.c
+++ b/src/tool_msgs.c
@@ -29,6 +29,8 @@
 
 #include "tool_cfgable.h"
 #include "tool_msgs.h"
+#include "tool_cb_prg.h"
+#include "terminal.h"
 
 #include "memdebug.h" /* keep this as LAST include */
 
@@ -46,7 +48,7 @@ static void voutf(struct GlobalConfig *config,
                   const char *fmt,
                   va_list ap)
 {
-  size_t width = (79 - strlen(prefix));
+  size_t width = (get_terminal_columns() - strlen(prefix));
   DEBUGASSERT(!strchr(fmt, '\n'));
   if(!config->silent) {
     size_t len;
diff --git a/src/tool_operate.c b/src/tool_operate.c
index d81d59f28..f6ae64dd3 100644
--- a/src/tool_operate.c
+++ b/src/tool_operate.c
@@ -45,6 +45,10 @@
 #  include <proto/dos.h>
 #endif
 
+#ifdef HAVE_NETINET_IN_H
+#  include <netinet/in.h>
+#endif
+
 #define ENABLE_CURLX_PRINTF
 /* use our own printf() functions */
 #include "curlx.h"
@@ -56,6 +60,7 @@
 #include "tool_cb_prg.h"
 #include "tool_cb_rea.h"
 #include "tool_cb_see.h"
+#include "tool_cb_soc.h"
 #include "tool_cb_wrt.h"
 #include "tool_dirhie.h"
 #include "tool_doswin.h"
@@ -83,25 +88,27 @@
 #include "tool_progress.h"
 #include "tool_ipfs.h"
 #include "dynbuf.h"
+#ifdef DEBUGBUILD
+#include "easyif.h"  /* for libcurl's debug-only curl_easy_perform_ev() */
+#endif
 
 #include "memdebug.h" /* keep this as LAST include */
 
-#ifdef CURLDEBUG
-/* libcurl's debug builds provide an extra function */
-CURLcode curl_easy_perform_ev(CURL *easy);
-#endif
-
 #ifndef O_BINARY
 /* since O_BINARY as used in bitmasks, setting it to zero makes it usable in
-   source code but yet it doesn't ruin anything */
+   source code but yet it does not ruin anything */
 #  define O_BINARY 0
 #endif
 
-#define CURL_CA_CERT_ERRORMSG                                               \
-  "More details here: https://curl.se/docs/sslcerts.html\n\n"          \
-  "curl failed to verify the legitimacy of the server and therefore "       \
-  "could not\nestablish a secure connection to it. To learn more about "    \
-  "this situation and\nhow to fix it, please visit the web page mentioned " \
+#ifndef SOL_IP
+#  define SOL_IP IPPROTO_IP
+#endif
+
+#define CURL_CA_CERT_ERRORMSG                                              \
+  "More details here: https://curl.se/docs/sslcerts.html\n\n"              \
+  "curl failed to verify the legitimacy of the server and therefore "      \
+  "could not\nestablish a secure connection to it. To learn more about "   \
+  "this situation and\nhow to fix it, please visit the webpage mentioned " \
   "above.\n"
 
 static CURLcode single_transfer(struct GlobalConfig *global,
@@ -144,6 +151,67 @@ static bool is_pkcs11_uri(const char *string)
   }
 }
 
+#ifdef IP_TOS
+static int get_address_family(curl_socket_t sockfd)
+{
+  struct sockaddr addr;
+  curl_socklen_t addrlen = sizeof(addr);
+  if(getsockname(sockfd, (struct sockaddr *)&addr, &addrlen) == 0)
+    return addr.sa_family;
+  return AF_UNSPEC;
+}
+#endif
+
+#if defined(IP_TOS) || defined(IPV6_TCLASS) || defined(SO_PRIORITY)
+static int sockopt_callback(void *clientp, curl_socket_t curlfd,
+                            curlsocktype purpose)
+{
+  struct OperationConfig *config = (struct OperationConfig *)clientp;
+  if(purpose != CURLSOCKTYPE_IPCXN)
+    return CURL_SOCKOPT_OK;
+  (void)config;
+  (void)curlfd;
+#if defined(IP_TOS) || defined(IPV6_TCLASS)
+  if(config->ip_tos > 0) {
+    int tos = (int)config->ip_tos;
+    int result = 0;
+    switch(get_address_family(curlfd)) {
+    case AF_INET:
+#ifdef IP_TOS
+      result = setsockopt(curlfd, SOL_IP, IP_TOS, (void *)&tos, sizeof(tos));
+#endif
+      break;
+#if defined(IPV6_TCLASS) && defined(AF_INET6)
+    case AF_INET6:
+      result = setsockopt(curlfd, IPPROTO_IPV6, IPV6_TCLASS,
+                          (void *)&tos, sizeof(tos));
+      break;
+#endif
+    }
+    if(result < 0) {
+      int error = errno;
+      warnf(config->global,
+            "Setting type of service to %d failed with errno %d: %s;\n",
+            tos, error, strerror(error));
+    }
+  }
+#endif
+#ifdef SO_PRIORITY
+  if(config->vlan_priority > 0) {
+    int priority = (int)config->vlan_priority;
+    if(setsockopt(curlfd, SOL_SOCKET, SO_PRIORITY,
+      (void *)&priority, sizeof(priority)) != 0) {
+      int error = errno;
+      warnf(config->global, "VLAN priority %d failed with errno %d: %s;\n",
+            priority, error, strerror(error));
+    }
+  }
+#endif
+  return CURL_SOCKOPT_OK;
+}
+#endif
+
+
 #ifdef __VMS
 /*
  * get_vms_file_size does what it takes to get the real size of the file
@@ -271,7 +339,7 @@ static CURLcode pre_transfer(struct GlobalConfig *global,
   if(per->uploadfile && !stdin_upload(per->uploadfile)) {
     /* VMS Note:
      *
-     * Reading binary from files can be a problem...  Only FIXED, VAR
+     * Reading binary from files can be a problem... Only FIXED, VAR
      * etc WITHOUT implied CC will work. Others need a \n appended to
      * a line
      *
@@ -305,7 +373,7 @@ static CURLcode pre_transfer(struct GlobalConfig *global,
     if((per->infd == -1) || fstat(per->infd, &fileinfo))
 #endif
     {
-      helpf(tool_stderr, "Can't open '%s'", per->uploadfile);
+      helpf(tool_stderr, "cannot open '%s'", per->uploadfile);
       if(per->infd != -1) {
         close(per->infd);
         per->infd = STDIN_FILENO;
@@ -452,9 +520,9 @@ static CURLcode post_per_transfer(struct GlobalConfig *global,
     memset(outs->utf8seq, 0, sizeof(outs->utf8seq));
 #endif
 
-  /* if retry-max-time is non-zero, make sure we haven't exceeded the
+  /* if retry-max-time is non-zero, make sure we have not exceeded the
      time */
-  if(per->retry_numretries &&
+  if(per->retry_remaining &&
      (!config->retry_maxtime ||
       (tvdiff(tvnow(), per->retrystart) <
        config->retry_maxtime*1000L)) ) {
@@ -526,7 +594,7 @@ static CURLcode post_per_transfer(struct GlobalConfig *global,
       if((scheme == proto_ftp || scheme == proto_ftps) && response / 100 == 4)
         /*
          * This is typically when the FTP server only allows a certain
-         * amount of users and we are not one of them.  All 4xx codes
+         * amount of users and we are not one of them. All 4xx codes
          * are transient.
          */
         retry = RETRY_FTP;
@@ -551,7 +619,7 @@ static CURLcode post_per_transfer(struct GlobalConfig *global,
       if(RETRY_HTTP == retry) {
         curl_easy_getinfo(curl, CURLINFO_RETRY_AFTER, &retry_after);
         if(retry_after) {
-          /* store in a 'long', make sure it doesn't overflow */
+          /* store in a 'long', make sure it does not overflow */
           if(retry_after > LONG_MAX/1000)
             sleeptime = LONG_MAX;
           else if((retry_after * 1000) > sleeptime)
@@ -576,9 +644,9 @@ static CURLcode post_per_transfer(struct GlobalConfig *global,
       warnf(config->global, "Problem %s. "
             "Will retry in %ld seconds. "
             "%ld retries left.",
-            m[retry], sleeptime/1000L, per->retry_numretries);
+            m[retry], sleeptime/1000L, per->retry_remaining);
 
-      per->retry_numretries--;
+      per->retry_remaining--;
       if(!config->retry_delay) {
         per->retry_sleep *= 2;
         if(per->retry_sleep > RETRY_SLEEP_MAX)
@@ -594,7 +662,7 @@ static CURLcode post_per_transfer(struct GlobalConfig *global,
         /* truncate file at the position where we started appending */
 #ifdef HAVE_FTRUNCATE
         if(ftruncate(fileno(outs->stream), outs->init)) {
-          /* when truncate fails, we can't just append as then we'll
+          /* when truncate fails, we cannot just append as then we will
              create something strange, bail out */
           errorf(config->global, "Failed to truncate file");
           return CURLE_WRITE_ERROR;
@@ -604,7 +672,7 @@ static CURLcode post_per_transfer(struct GlobalConfig *global,
         rc = fseek(outs->stream, 0, SEEK_END);
 #else
         /* ftruncate is not available, so just reposition the file
-           to the location we would have truncated it. This won't
+           to the location we would have truncated it. This will not
            work properly with large files on 32-bit systems, but
            most of those will have ftruncate. */
         rc = fseek(outs->stream, (long)outs->init, SEEK_SET);
@@ -616,10 +684,11 @@ static CURLcode post_per_transfer(struct GlobalConfig *global,
         outs->bytes = 0; /* clear for next round */
       }
       *retryp = TRUE;
+      per->num_retries++;
       *delay = sleeptime;
       return CURLE_OK;
     }
-  } /* if retry_numretries */
+  } /* if retry_remaining */
 noretry:
 
   if((global->progressmode == CURL_PROGRESS_BAR) &&
@@ -711,7 +780,7 @@ static CURLcode url_proto(char **url,
         if(curl_strequal(schemep, proto_ipfs) ||
            curl_strequal(schemep, proto_ipns)) {
           result = ipfs_url_rewrite(uh, schemep, url, config);
-          /* short-circuit proto_token, we know it's ipfs or ipns */
+          /* short-circuit proto_token, we know it is ipfs or ipns */
           if(curl_strequal(schemep, proto_ipfs))
             proto = proto_ipfs;
           else if(curl_strequal(schemep, proto_ipns))
@@ -1061,20 +1130,20 @@ static CURLcode single_transfer(struct GlobalConfig *global,
             (per->outfile && strcmp("-", per->outfile)))) {
 
           /*
-           * We have specified a file name to store the result in, or we have
-           * decided we want to use the remote file name.
+           * We have specified a filename to store the result in, or we have
+           * decided we want to use the remote filename.
            */
 
           if(!per->outfile) {
-            /* extract the file name from the URL */
+            /* extract the filename from the URL */
             result = get_url_file_name(&per->outfile, per->this_url);
             if(result) {
-              errorf(global, "Failed to extract a sensible file name"
+              errorf(global, "Failed to extract a sensible filename"
                      " from the URL to use for storage");
               break;
             }
             if(!*per->outfile && !config->content_disposition) {
-              errorf(global, "Remote file name has no length");
+              errorf(global, "Remote filename has no length");
               result = CURLE_WRITE_ERROR;
               break;
             }
@@ -1122,7 +1191,7 @@ static CURLcode single_transfer(struct GlobalConfig *global,
           }
 
           if(config->resume_from_current) {
-            /* We're told to continue from where we are now. Get the size
+            /* We are told to continue from where we are now. Get the size
                of the file as it is now and open it for append instead */
             struct_stat fileinfo;
             /* VMS -- Danger, the filesize is only valid for stream files */
@@ -1145,7 +1214,7 @@ static CURLcode single_transfer(struct GlobalConfig *global,
             FILE *file = fopen(per->outfile, "ab");
 #endif
             if(!file) {
-              errorf(global, "Can't open '%s'", per->outfile);
+              errorf(global, "cannot open '%s'", per->outfile);
               result = CURLE_WRITE_ERROR;
               break;
             }
@@ -1162,7 +1231,7 @@ static CURLcode single_transfer(struct GlobalConfig *global,
 
         if(per->uploadfile && !stdin_upload(per->uploadfile)) {
           /*
-           * We have specified a file to upload and it isn't "-".
+           * We have specified a file to upload and it is not "-".
            */
           result = add_file_name_to_url(per->curl, &per->this_url,
                                         per->uploadfile);
@@ -1178,7 +1247,7 @@ static CURLcode single_transfer(struct GlobalConfig *global,
             if(config->authtype & (1UL << bitcheck++)) {
               authbits++;
               if(authbits > 1) {
-                /* more than one, we're done! */
+                /* more than one, we are done! */
                 break;
               }
             }
@@ -1269,14 +1338,13 @@ static CURLcode single_transfer(struct GlobalConfig *global,
         if(result)
           break;
 
-        /* result is only used when for ipfs and ipns, ignored otherwise */
         result = url_proto(&per->this_url, config, &use_proto);
-        if(result && (use_proto == proto_ipfs || use_proto == proto_ipns))
+        if(result)
           break;
 
 #ifndef DEBUGBUILD
         /* On most modern OSes, exiting works thoroughly,
-           we'll clean everything up via exit(), so don't bother with
+           we will clean everything up via exit(), so do not bother with
            slow cleanups. Crappy ones might need to skip this.
            Note: avoid having this setopt added to the --libcurl source
            output. */
@@ -1291,6 +1359,10 @@ static CURLcode single_transfer(struct GlobalConfig *global,
         if(config->tcp_fastopen)
           my_setopt(curl, CURLOPT_TCP_FASTOPEN, 1L);
 
+        if(config->mptcp)
+          my_setopt(curl, CURLOPT_OPENSOCKETFUNCTION,
+                    tool_socket_open_mptcp_cb);
+
         /* where to store */
         my_setopt(curl, CURLOPT_WRITEDATA, per);
         my_setopt(curl, CURLOPT_INTERLEAVEDATA, per);
@@ -1315,7 +1387,7 @@ static CURLcode single_transfer(struct GlobalConfig *global,
         my_setopt(curl, CURLOPT_SEEKFUNCTION, tool_seek_cb);
 
         {
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
           char *env = getenv("CURL_BUFFERSIZE");
           if(env) {
             long size = strtol(env, NULL, 10);
@@ -1647,7 +1719,7 @@ static CURLcode single_transfer(struct GlobalConfig *global,
            *  must do the same thing as classic:
            *    --cert <filename>:<password> --cert-type p12
            *  but is designed to test blob */
-#if defined(CURLDEBUG) || defined(DEBUGBUILD)
+#ifdef DEBUGBUILD
           if(config->cert && (strlen(config->cert) > 8) &&
              (memcmp(config->cert, "loadmem=",8) == 0)) {
             FILE *fInCert = fopen(config->cert + 8, "rb");
@@ -1675,7 +1747,7 @@ static CURLcode single_transfer(struct GlobalConfig *global,
               structblob.len = (size_t)filesize;
               structblob.flags = CURL_BLOB_COPY;
               my_setopt_str(curl, CURLOPT_SSLCERT_BLOB, &structblob);
-              /* if test run well, we are sure we don't reuse
+              /* if test run well, we are sure we do not reuse
                * original mem pointer */
               memset(certdata, 0, (size_t)filesize);
             }
@@ -1690,7 +1762,7 @@ static CURLcode single_transfer(struct GlobalConfig *global,
                         config->proxy_cert_type);
 
 
-#if defined(CURLDEBUG) || defined(DEBUGBUILD)
+#ifdef DEBUGBUILD
           if(config->key && (strlen(config->key) > 8) &&
              (memcmp(config->key, "loadmem=",8) == 0)) {
             FILE *fInCert = fopen(config->key + 8, "rb");
@@ -1718,7 +1790,7 @@ static CURLcode single_transfer(struct GlobalConfig *global,
               structblob.len = (size_t)filesize;
               structblob.flags = CURL_BLOB_COPY;
               my_setopt_str(curl, CURLOPT_SSLKEY_BLOB, &structblob);
-              /* if test run well, we are sure we don't reuse
+              /* if test run well, we are sure we do not reuse
                * original mem pointer */
               memset(certdata, 0, (size_t)filesize);
             }
@@ -1731,15 +1803,12 @@ static CURLcode single_transfer(struct GlobalConfig *global,
           my_setopt_str(curl, CURLOPT_SSLKEYTYPE, config->key_type);
           my_setopt_str(curl, CURLOPT_PROXY_SSLKEYTYPE,
                         config->proxy_key_type);
+
+          /* libcurl default is strict verifyhost -> 1L, verifypeer -> 1L */
           if(config->insecure_ok) {
             my_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
             my_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
           }
-          else {
-            my_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
-            /* libcurl default is strict verifyhost -> 2L   */
-            /* my_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L); */
-          }
 
           if(config->doh_insecure_ok) {
             my_setopt(curl, CURLOPT_DOH_SSL_VERIFYPEER, 0L);
@@ -1750,9 +1819,6 @@ static CURLcode single_transfer(struct GlobalConfig *global,
             my_setopt(curl, CURLOPT_PROXY_SSL_VERIFYPEER, 0L);
             my_setopt(curl, CURLOPT_PROXY_SSL_VERIFYHOST, 0L);
           }
-          else {
-            my_setopt(curl, CURLOPT_PROXY_SSL_VERIFYPEER, 1L);
-          }
 
           if(config->verifystatus)
             my_setopt(curl, CURLOPT_SSL_VERIFYSTATUS, 1L);
@@ -2043,6 +2109,8 @@ static CURLcode single_transfer(struct GlobalConfig *global,
             my_setopt(curl, CURLOPT_TCP_KEEPIDLE, config->alivetime);
             my_setopt(curl, CURLOPT_TCP_KEEPINTVL, config->alivetime);
           }
+          if(config->alivecnt)
+            my_setopt(curl, CURLOPT_TCP_KEEPCNT, config->alivecnt);
         }
         else
           my_setopt(curl, CURLOPT_TCP_KEEPALIVE, 0L);
@@ -2197,10 +2265,29 @@ static CURLcode single_transfer(struct GlobalConfig *global,
           my_setopt_str(curl, CURLOPT_ECH, config->ech_config);
 #endif
 
+        /* new in 8.9.0 */
+        if(config->ip_tos > 0 || config->vlan_priority > 0) {
+#if defined(IP_TOS) || defined(IPV6_TCLASS) || defined(SO_PRIORITY)
+          my_setopt(curl, CURLOPT_SOCKOPTFUNCTION, sockopt_callback);
+          my_setopt(curl, CURLOPT_SOCKOPTDATA, config);
+#else
+          if(config->ip_tos > 0) {
+            errorf(config->global,
+                  "Type of service is not supported in this build.");
+            result = CURLE_NOT_BUILT_IN;
+          }
+          if(config->vlan_priority > 0) {
+            errorf(config->global,
+                  "VLAN priority is not supported in this build.");
+            result = CURLE_NOT_BUILT_IN;
+          }
+#endif
+        }
+
         /* initialize retry vars for loop below */
         per->retry_sleep_default = (config->retry_delay) ?
           config->retry_delay*1000L : RETRY_SLEEP_DEFAULT; /* ms */
-        per->retry_numretries = config->req_retry;
+        per->retry_remaining = config->req_retry;
         per->retry_sleep = per->retry_sleep_default; /* ms */
         per->retrystart = tvnow();
 
@@ -2294,7 +2381,7 @@ static CURLcode add_parallel_transfers(struct GlobalConfig *global,
     if(!errorbuf)
       return CURLE_OUT_OF_MEMORY;
 
-    /* parallel connect means that we don't set PIPEWAIT since pipewait
+    /* parallel connect means that we do not set PIPEWAIT since pipewait
        will make libcurl prefer multiplexing */
     (void)curl_easy_setopt(per->curl, CURLOPT_PIPEWAIT,
                            global->parallel_connect ? 0L : 1L);
@@ -2437,7 +2524,7 @@ static CURLcode parallel_transfers(struct GlobalConfig *global,
         if(tres)
           result = tres;
         if(added_transfers)
-          /* we added new ones, make sure the loop doesn't exit yet */
+          /* we added new ones, make sure the loop does not exit yet */
           still_running = 1;
       }
       if(is_fatal_error(result) || (result && global->fail_early))
@@ -2490,7 +2577,10 @@ static CURLcode serial_transfers(struct GlobalConfig *global,
         break;
     }
     start = tvnow();
-#ifdef CURLDEBUG
+#ifdef DEBUGBUILD
+    if(getenv("CURL_FORBID_REUSE"))
+      (void)curl_easy_setopt(per->curl, CURLOPT_FORBID_REUSE, 1L);
+
     if(global->test_event_based)
       result = curl_easy_perform_ev(per->curl);
     else
@@ -2558,10 +2648,10 @@ static CURLcode transfer_per_config(struct GlobalConfig *global,
     return CURLE_FAILED_INIT;
   }
 
-  /* On WIN32 we can't set the path to curl-ca-bundle.crt
-   * at compile time. So we look here for the file in two ways:
+  /* On WIN32 we cannot set the path to curl-ca-bundle.crt at compile time. We
+   * look for the file in two ways:
    * 1: look at the environment variable CURL_CA_BUNDLE for a path
-   * 2: if #1 isn't found, use the windows API function SearchPath()
+   * 2: if #1 is not found, use the windows API function SearchPath()
    *    to find it along the app's path (includes app's dir and CWD)
    *
    * We support the environment variable thing for non-Windows platforms
@@ -2691,7 +2781,7 @@ static CURLcode run_all_transfers(struct GlobalConfig *global,
     long delay;
     CURLcode result2 = post_per_transfer(global, per, result, &retry, &delay);
     if(!result)
-      /* don't overwrite the original error */
+      /* do not overwrite the original error */
       result = result2;
 
     /* Free list of given URLs */
@@ -2722,7 +2812,7 @@ CURLcode operate(struct GlobalConfig *global, int argc, argv_item_t argv[])
   /* Parse .curlrc if necessary */
   if((argc == 1) ||
      (first_arg && strncmp(first_arg, "-q", 2) &&
-      !curl_strequal(first_arg, "--disable"))) {
+      strcmp(first_arg, "--disable"))) {
     parseconfig(NULL, global); /* ignore possible failure */
 
     /* If we had no arguments then make sure a url was specified in .curlrc */
diff --git a/src/tool_operate.h b/src/tool_operate.h
index 4993b1c96..820ac1395 100644
--- a/src/tool_operate.h
+++ b/src/tool_operate.h
@@ -35,9 +35,10 @@ struct per_transfer {
   struct OperationConfig *config; /* for this transfer */
   struct curl_certinfo *certinfo;
   CURL *curl;
-  long retry_numretries;
+  long retry_remaining;
   long retry_sleep_default;
   long retry_sleep;
+  long num_retries; /* counts the performed retries */
   struct timeval start; /* start of this transfer */
   struct timeval retrystart;
   char *this_url;
diff --git a/src/tool_operhlp.c b/src/tool_operhlp.c
index ddc40701d..e2e2d4c3c 100644
--- a/src/tool_operhlp.c
+++ b/src/tool_operhlp.c
@@ -86,7 +86,7 @@ CURLcode urlerr_cvt(CURLUcode ucode)
 }
 
 /*
- * Adds the file name to the URL if it doesn't already have one.
+ * Adds the filename to the URL if it does not already have one.
  * url will be freed before return if the returned pointer is different
  */
 CURLcode add_file_name_to_url(CURL *curl, char **inurlp, const char *filename)
@@ -118,7 +118,7 @@ CURLcode add_file_name_to_url(CURL *curl, char **inurlp, const char *filename)
     }
     ptr = strrchr(path, '/');
     if(!ptr || !*++ptr) {
-      /* The URL path has no file name part, add the local file name. In order
+      /* The URL path has no filename part, add the local filename. In order
          to be able to do so, we have to create a new URL in another buffer.*/
 
       /* We only want the part of the local path that is on the right
@@ -134,7 +134,7 @@ CURLcode add_file_name_to_url(CURL *curl, char **inurlp, const char *filename)
       else
         filep = filename;
 
-      /* URL encode the file name */
+      /* URL encode the filename */
       encfile = curl_easy_escape(curl, filep, 0 /* use strlen */);
       if(encfile) {
         char *newpath;
@@ -230,7 +230,7 @@ CURLcode get_url_file_name(char **filename, const char *url)
 #endif /* _WIN32 || MSDOS */
 
       /* in case we built debug enabled, we allow an environment variable
-       * named CURL_TESTDIR to prefix the given file name to put it into a
+       * named CURL_TESTDIR to prefix the given filename to put it into a
        * specific directory
        */
 #ifdef DEBUGBUILD
diff --git a/src/tool_paramhlp.c b/src/tool_paramhlp.c
index c5128e364..82c0041d4 100644
--- a/src/tool_paramhlp.c
+++ b/src/tool_paramhlp.c
@@ -399,7 +399,7 @@ ParameterError proto2num(struct OperationConfig *config,
       protoset_set(protoset, p);
   }
 
-  /* Allow strtok() here since this isn't used threaded */
+  /* Allow strtok() here since this is not used threaded */
   /* !checksrc! disable BANNEDFUNC 2 */
   for(token = strtok(buffer, sep);
       token;
@@ -508,7 +508,7 @@ ParameterError str2offset(curl_off_t *val, const char *str)
 {
   char *endptr;
   if(str[0] == '-')
-    /* offsets aren't negative, this indicates weird input */
+    /* offsets are not negative, this indicates weird input */
     return PARAM_NEGATIVE_NUMERIC;
 
 #if(SIZEOF_CURL_OFF_T > SIZEOF_LONG)
diff --git a/src/tool_parsecfg.c b/src/tool_parsecfg.c
index 130a3933d..d0a3159f5 100644
--- a/src/tool_parsecfg.c
+++ b/src/tool_parsecfg.c
@@ -51,7 +51,7 @@ static FILE *execpath(const char *filename, char **pathp)
 {
   static char filebuffer[512];
   /* Get the filename of our executable. GetModuleFileName is already declared
-   * via inclusions done in setup header file.  We assume that we are using
+   * via inclusions done in setup header file. We assume that we are using
    * the ASCII version here.
    */
   unsigned long len = GetModuleFileNameA(0, filebuffer, sizeof(filebuffer));
@@ -196,7 +196,7 @@ int parseconfig(const char *filename, struct GlobalConfig *global)
         if(*line) {
           *line = '\0'; /* null-terminate */
 
-          /* to detect mistakes better, see if there's data following */
+          /* to detect mistakes better, see if there is data following */
           line++;
           /* pass all spaces */
           while(*line && ISSPACE(*line))
@@ -217,7 +217,7 @@ int parseconfig(const char *filename, struct GlobalConfig *global)
         }
         if(!*param)
           /* do this so getparameter can check for required parameters.
-             Otherwise it always thinks there's a parameter. */
+             Otherwise it always thinks there is a parameter. */
           param = NULL;
       }
 
@@ -228,7 +228,7 @@ int parseconfig(const char *filename, struct GlobalConfig *global)
       operation = global->last;
 
       if(!res && param && *param && !usedarg)
-        /* we passed in a parameter that wasn't used! */
+        /* we passed in a parameter that was not used! */
         res = PARAM_GOT_EXTRA_PARAMETER;
 
       if(res == PARAM_NEXT_OPERATION) {
@@ -255,7 +255,7 @@ int parseconfig(const char *filename, struct GlobalConfig *global)
       }
 
       if(res != PARAM_OK && res != PARAM_NEXT_OPERATION) {
-        /* the help request isn't really an error */
+        /* the help request is not really an error */
         if(!strcmp(filename, "-")) {
           filename = "<stdin>";
         }
@@ -282,7 +282,7 @@ int parseconfig(const char *filename, struct GlobalConfig *global)
       rc = 1;
   }
   else
-    rc = 1; /* couldn't open the file */
+    rc = 1; /* could not open the file */
 
   free(pathalloc);
   return rc;
@@ -293,7 +293,7 @@ int parseconfig(const char *filename, struct GlobalConfig *global)
  * backslash-quoted characters and NUL-terminating the output string.
  * Stops at the first non-backslash-quoted double quote character or the
  * end of the input string. param must be at least as long as the input
- * string.  Returns the pointer after the last handled input character.
+ * string. Returns the pointer after the last handled input character.
  */
 static const char *unslashquote(const char *line, char *param)
 {
@@ -341,7 +341,7 @@ static bool my_get_line(FILE *fp, struct curlx_dynbuf *db,
     /* fgets() returns s on success, and NULL on error or when end of file
        occurs while no characters have been read. */
     if(!fgets(buf, sizeof(buf), fp))
-      /* only if there's data in the line, return TRUE */
+      /* only if there is data in the line, return TRUE */
       return curlx_dyn_len(db) ? TRUE : FALSE;
     if(curlx_dyn_add(db, buf)) {
       *error = TRUE; /* error */
diff --git a/src/tool_progress.c b/src/tool_progress.c
index db8679deb..cf3e4c2f6 100644
--- a/src/tool_progress.c
+++ b/src/tool_progress.c
@@ -48,13 +48,13 @@ static char *max5data(curl_off_t bytes, char *max5)
     msnprintf(max5, 6, "%4" CURL_FORMAT_CURL_OFF_T "k", bytes/ONE_KILOBYTE);
 
   else if(bytes < CURL_OFF_T_C(100) * ONE_MEGABYTE)
-    /* 'XX.XM' is good as long as we're less than 100 megs */
+    /* 'XX.XM' is good as long as we are less than 100 megs */
     msnprintf(max5, 6, "%2" CURL_FORMAT_CURL_OFF_T ".%0"
               CURL_FORMAT_CURL_OFF_T "M", bytes/ONE_MEGABYTE,
               (bytes%ONE_MEGABYTE) / (ONE_MEGABYTE/CURL_OFF_T_C(10)) );
 
   else if(bytes < CURL_OFF_T_C(10000) * ONE_MEGABYTE)
-    /* 'XXXXM' is good until we're at 10000MB or above */
+    /* 'XXXXM' is good until we are at 10000MB or above */
     msnprintf(max5, 6, "%4" CURL_FORMAT_CURL_OFF_T "M", bytes/ONE_MEGABYTE);
 
   else if(bytes < CURL_OFF_T_C(100) * ONE_GIGABYTE)
@@ -75,7 +75,7 @@ static char *max5data(curl_off_t bytes, char *max5)
     /* up to 10000PB, display without decimal: XXXXP */
     msnprintf(max5, 6, "%4" CURL_FORMAT_CURL_OFF_T "P", bytes/ONE_PETABYTE);
 
-  /* 16384 petabytes (16 exabytes) is the maximum a 64 bit unsigned number can
+  /* 16384 petabytes (16 exabytes) is the maximum a 64-bit unsigned number can
      hold, but our data type is signed so 8192PB will be the maximum. */
   return max5;
 }
diff --git a/src/tool_sdecls.h b/src/tool_sdecls.h
index b93c32462..2d83adb8f 100644
--- a/src/tool_sdecls.h
+++ b/src/tool_sdecls.h
@@ -29,7 +29,7 @@
  * OutStruct variables keep track of information relative to curl's
  * output writing, which may take place to a standard stream or a file.
  *
- * 'filename' member is either a pointer to a file name string or NULL
+ * 'filename' member is either a pointer to a filename string or NULL
  * when dealing with a standard stream.
  *
  * 'alloc_filename' member is TRUE when string pointed by 'filename' has been
@@ -40,7 +40,7 @@
  *
  * 's_isreg' member is TRUE when output goes to a regular file, this also
  * implies that output is 'seekable' and 'appendable' and also that member
- * 'filename' points to file name's string. For any standard stream member
+ * 'filename' points to filename's string. For any standard stream member
  * 's_isreg' will be FALSE.
  *
  * 'fopened' member is TRUE when output goes to a regular file and it
@@ -93,7 +93,7 @@ struct getout {
 
 #define GETOUT_OUTFILE    (1<<0)  /* set when outfile is deemed done */
 #define GETOUT_URL        (1<<1)  /* set when URL is deemed done */
-#define GETOUT_USEREMOTE  (1<<2)  /* use remote file name locally */
+#define GETOUT_USEREMOTE  (1<<2)  /* use remote filename locally */
 #define GETOUT_UPLOAD     (1<<3)  /* if set, -T has been used */
 #define GETOUT_NOUPLOAD   (1<<4)  /* if set, -T "" has been used */
 
diff --git a/src/tool_setopt.c b/src/tool_setopt.c
index c6c203a5c..4ec101657 100644
--- a/src/tool_setopt.c
+++ b/src/tool_setopt.c
@@ -207,7 +207,7 @@ static const struct NameValue setopt_nv_CURLNONZERODEFAULTS[] = {
 #define REM1(f,a) ADDF((&easysrc_toohard, f,a))
 #define REM3(f,a,b,c) ADDF((&easysrc_toohard, f,a,b,c))
 
-/* Escape string to C string syntax.  Return NULL if out of memory.
+/* Escape string to C string syntax. Return NULL if out of memory.
  * Is this correct for those wacky EBCDIC guys? */
 
 #define MAX_STRING_LENGTH_OUTPUT 2000
diff --git a/src/tool_urlglob.c b/src/tool_urlglob.c
index 8ae28a3a6..7c43b26c3 100644
--- a/src/tool_urlglob.c
+++ b/src/tool_urlglob.c
@@ -80,7 +80,7 @@ static int multiply(curl_off_t *amount, curl_off_t with)
 #else
     sum = *amount * with;
     if(sum/with != *amount)
-      return 1; /* didn't fit, bail out */
+      return 1; /* did not fit, bail out */
 #endif
   }
   *amount = sum;
@@ -123,7 +123,7 @@ static CURLcode glob_set(struct URLGlob *glob, char **patternp,
         return GLOBERROR("empty string within braces", *posp,
                          CURLE_URL_MALFORMAT);
 
-      /* add 1 to size since it'll be incremented below */
+      /* add 1 to size since it will be incremented below */
       if(multiply(amount, pat->content.Set.size + 1))
         return GLOBERROR("range overflow", 0, CURLE_URL_MALFORMAT);
 
diff --git a/src/tool_util.c b/src/tool_util.c
index b5a6b40d1..e612bec03 100644
--- a/src/tool_util.c
+++ b/src/tool_util.c
@@ -81,7 +81,7 @@ struct timeval tvnow(void)
   /*
   ** Even when the configure process has truly detected monotonic clock
   ** availability, it might happen that it is not actually available at
-  ** run-time. When this occurs simply fallback to other time source.
+  ** runtime. When this occurs simply fallback to other time source.
   */
 #ifdef HAVE_GETTIMEOFDAY
   else
@@ -126,7 +126,7 @@ struct timeval tvnow(void)
 
 /*
  * Make sure that the first argument is the more recent time, as otherwise
- * we'll get a weird negative time-diff back...
+ * we will get a weird negative time-diff back...
  *
  * Returns: the time difference in number of milliseconds.
  */
diff --git a/src/tool_vms.c b/src/tool_vms.c
index 940257420..7fc23e77e 100644
--- a/src/tool_vms.c
+++ b/src/tool_vms.c
@@ -74,7 +74,7 @@ int is_vms_shell(void)
 }
 
 /*
- * VMS has two exit() routines.  When running under a Unix style shell, then
+ * VMS has two exit() routines. When running under a Unix style shell, then
  * Unix style and the __posix_exit() routine is used.
  *
  * When running under the DCL shell, then the VMS encoded codes and decc$exit()
@@ -133,9 +133,9 @@ struct decc_feat_t {
 static const struct decc_feat_t decc_feat_array[] = {
   /* Preserve command-line case with SET PROCESS/PARSE_STYLE=EXTENDED */
   { "DECC$ARGV_PARSE_STYLE", 1 },
-  /* Preserve case for file names on ODS5 disks. */
+  /* Preserve case for filenames on ODS5 disks. */
   { "DECC$EFS_CASE_PRESERVE", 1 },
-  /* Enable multiple dots (and most characters) in ODS5 file names,
+  /* Enable multiple dots (and most characters) in ODS5 filenames,
      while preserving VMS-ness of ";version". */
   { "DECC$EFS_CHARSET", 1 },
   /* List terminator. */
@@ -165,14 +165,14 @@ static void decc_init(void)
     feat_index = decc$feature_get_index(decc_feat_array[i].name);
 
     if(feat_index >= 0) {
-      /* Valid item.  Collect its properties. */
+      /* Valid item. Collect its properties. */
       feat_value = decc$feature_get_value(feat_index, 1);
       feat_value_min = decc$feature_get_value(feat_index, 2);
       feat_value_max = decc$feature_get_value(feat_index, 3);
 
       if((decc_feat_array[i].value >= feat_value_min) &&
          (decc_feat_array[i].value <= feat_value_max)) {
-        /* Valid value.  Set it if necessary. */
+        /* Valid value. Set it if necessary. */
         if(feat_value != decc_feat_array[i].value) {
           sts = decc$feature_set_value(feat_index, 1,
                                        decc_feat_array[i].value);
@@ -198,7 +198,7 @@ static void decc_init(void)
 #pragma nostandard
 
 /* Establish the LIB$INITIALIZE PSECTs, with proper alignment and
-   other attributes.  Note that "nopic" is significant only on VAX. */
+   other attributes. Note that "nopic" is significant only on VAX. */
 #pragma extern_model save
 #pragma extern_model strict_refdef "LIB$INITIALIZ" 2, nopic, nowrt
 const int spare[8] = {0};
diff --git a/src/tool_writeout.c b/src/tool_writeout.c
index ca8424a3c..20945cf48 100644
--- a/src/tool_writeout.c
+++ b/src/tool_writeout.c
@@ -70,12 +70,12 @@ static const struct httpmap http_version[] = {
    Yes: "http_version": "1.1"
    No:  "http_version": 1.1
 
-   Variable names should be in alphabetical order.
+   Variable names MUST be in alphabetical order.
    */
 static const struct writeoutvar variables[] = {
   {"certs", VAR_CERT, CURLINFO_NONE, writeString},
-  {"content_type", VAR_CONTENT_TYPE, CURLINFO_CONTENT_TYPE, writeString},
   {"conn_id", VAR_CONN_ID, CURLINFO_CONN_ID, writeOffset},
+  {"content_type", VAR_CONTENT_TYPE, CURLINFO_CONTENT_TYPE, writeString},
   {"errormsg", VAR_ERRORMSG, CURLINFO_NONE, writeString},
   {"exitcode", VAR_EXITCODE, CURLINFO_NONE, writeLong},
   {"filename_effective", VAR_EFFECTIVE_FILENAME, CURLINFO_NONE, writeString},
@@ -92,6 +92,7 @@ static const struct writeoutvar variables[] = {
   {"num_connects", VAR_NUM_CONNECTS, CURLINFO_NUM_CONNECTS, writeLong},
   {"num_headers", VAR_NUM_HEADERS, CURLINFO_NONE, writeLong},
   {"num_redirects", VAR_REDIRECT_COUNT, CURLINFO_REDIRECT_COUNT, writeLong},
+  {"num_retries", VAR_NUM_RETRY, CURLINFO_NONE, writeLong},
   {"onerror", VAR_ONERROR, CURLINFO_NONE, NULL},
   {"proxy_ssl_verify_result", VAR_PROXY_SSL_VERIFY_RESULT,
    CURLINFO_PROXY_SSL_VERIFYRESULT, writeLong},
@@ -125,30 +126,29 @@ static const struct writeoutvar variables[] = {
    writeTime},
   {"time_total", VAR_TOTAL_TIME, CURLINFO_TOTAL_TIME_T, writeTime},
   {"url", VAR_INPUT_URL, CURLINFO_NONE, writeString},
-  {"url.scheme", VAR_INPUT_URLSCHEME, CURLINFO_NONE, writeString},
-  {"url.user", VAR_INPUT_URLUSER, CURLINFO_NONE, writeString},
-  {"url.password", VAR_INPUT_URLPASSWORD, CURLINFO_NONE, writeString},
-  {"url.options", VAR_INPUT_URLOPTIONS, CURLINFO_NONE, writeString},
+  {"url.fragment", VAR_INPUT_URLFRAGMENT, CURLINFO_NONE, writeString},
   {"url.host", VAR_INPUT_URLHOST, CURLINFO_NONE, writeString},
-  {"url.port", VAR_INPUT_URLPORT, CURLINFO_NONE, writeString},
+  {"url.options", VAR_INPUT_URLOPTIONS, CURLINFO_NONE, writeString},
+  {"url.password", VAR_INPUT_URLPASSWORD, CURLINFO_NONE, writeString},
   {"url.path", VAR_INPUT_URLPATH, CURLINFO_NONE, writeString},
+  {"url.port", VAR_INPUT_URLPORT, CURLINFO_NONE, writeString},
   {"url.query", VAR_INPUT_URLQUERY, CURLINFO_NONE, writeString},
-  {"url.fragment", VAR_INPUT_URLFRAGMENT, CURLINFO_NONE, writeString},
+  {"url.scheme", VAR_INPUT_URLSCHEME, CURLINFO_NONE, writeString},
+  {"url.user", VAR_INPUT_URLUSER, CURLINFO_NONE, writeString},
   {"url.zoneid", VAR_INPUT_URLZONEID, CURLINFO_NONE, writeString},
-  {"urle.scheme", VAR_INPUT_URLESCHEME, CURLINFO_NONE, writeString},
-  {"urle.user", VAR_INPUT_URLEUSER, CURLINFO_NONE, writeString},
-  {"urle.password", VAR_INPUT_URLEPASSWORD, CURLINFO_NONE, writeString},
-  {"urle.options", VAR_INPUT_URLEOPTIONS, CURLINFO_NONE, writeString},
+  {"url_effective", VAR_EFFECTIVE_URL, CURLINFO_EFFECTIVE_URL, writeString},
+  {"urle.fragment", VAR_INPUT_URLEFRAGMENT, CURLINFO_NONE, writeString},
   {"urle.host", VAR_INPUT_URLEHOST, CURLINFO_NONE, writeString},
-  {"urle.port", VAR_INPUT_URLEPORT, CURLINFO_NONE, writeString},
+  {"urle.options", VAR_INPUT_URLEOPTIONS, CURLINFO_NONE, writeString},
+  {"urle.password", VAR_INPUT_URLEPASSWORD, CURLINFO_NONE, writeString},
   {"urle.path", VAR_INPUT_URLEPATH, CURLINFO_NONE, writeString},
+  {"urle.port", VAR_INPUT_URLEPORT, CURLINFO_NONE, writeString},
   {"urle.query", VAR_INPUT_URLEQUERY, CURLINFO_NONE, writeString},
-  {"urle.fragment", VAR_INPUT_URLEFRAGMENT, CURLINFO_NONE, writeString},
+  {"urle.scheme", VAR_INPUT_URLESCHEME, CURLINFO_NONE, writeString},
+  {"urle.user", VAR_INPUT_URLEUSER, CURLINFO_NONE, writeString},
   {"urle.zoneid", VAR_INPUT_URLEZONEID, CURLINFO_NONE, writeString},
-  {"url_effective", VAR_EFFECTIVE_URL, CURLINFO_EFFECTIVE_URL, writeString},
   {"urlnum", VAR_URLNUM, CURLINFO_NONE, writeLong},
-  {"xfer_id", VAR_EASY_ID, CURLINFO_XFER_ID, writeOffset},
-  {NULL, VAR_NONE, CURLINFO_NONE, NULL}
+  {"xfer_id", VAR_EASY_ID, CURLINFO_XFER_ID, writeOffset}
 };
 
 static int writeTime(FILE *stream, const struct writeoutvar *wovar,
@@ -269,6 +269,15 @@ static int urlpart(struct per_transfer *per, writeoutid vid,
   return rc;
 }
 
+static void certinfo(struct per_transfer *per)
+{
+  if(!per->certinfo) {
+    struct curl_certinfo *certinfo;
+    CURLcode res = curl_easy_getinfo(per->curl, CURLINFO_CERTINFO, &certinfo);
+    per->certinfo = (!res && certinfo) ? certinfo : NULL;
+  }
+}
+
 static int writeString(FILE *stream, const struct writeoutvar *wovar,
                        struct per_transfer *per, CURLcode per_result,
                        bool use_json)
@@ -304,6 +313,7 @@ static int writeString(FILE *stream, const struct writeoutvar *wovar,
   else {
     switch(wovar->id) {
     case VAR_CERT:
+      certinfo(per);
       if(per->certinfo) {
         int i;
         bool error = FALSE;
@@ -434,7 +444,12 @@ static int writeLong(FILE *stream, const struct writeoutvar *wovar,
   }
   else {
     switch(wovar->id) {
+    case VAR_NUM_RETRY:
+      longinfo = per->num_retries;
+      valid = true;
+      break;
     case VAR_NUM_CERTS:
+      certinfo(per);
       longinfo = per->certinfo ? per->certinfo->num_of_certs : 0;
       valid = true;
       break;
@@ -509,6 +524,17 @@ static int writeOffset(FILE *stream, const struct writeoutvar *wovar,
   return 1; /* return 1 if anything was written */
 }
 
+static int
+matchvar(const void *m1, const void *m2)
+{
+  const struct writeoutvar *v1 = m1;
+  const struct writeoutvar *v2 = m2;
+
+  return strcmp(v1->name, v2->name);
+}
+
+#define MAX_WRITEOUT_NAME_LENGTH 24
+
 void ourWriteOut(struct OperationConfig *config, struct per_transfer *per,
                  CURLcode per_result)
 {
@@ -516,16 +542,13 @@ void ourWriteOut(struct OperationConfig *config, struct per_transfer *per,
   const char *writeinfo = config->writeout;
   const char *ptr = writeinfo;
   bool done = FALSE;
-  struct curl_certinfo *certinfo;
-  CURLcode res = curl_easy_getinfo(per->curl, CURLINFO_CERTINFO, &certinfo);
   bool fclose_stream = FALSE;
+  struct dynbuf name;
 
   if(!writeinfo)
     return;
 
-  if(!res && certinfo)
-    per->certinfo = certinfo;
-
+  curlx_dyn_init(&name, MAX_WRITEOUT_NAME_LENGTH);
   while(ptr && *ptr && !done) {
     if('%' == *ptr && ptr[1]) {
       if('%' == ptr[1]) {
@@ -538,8 +561,8 @@ void ourWriteOut(struct OperationConfig *config, struct per_transfer *per,
         char *end;
         size_t vlen;
         if('{' == ptr[1]) {
-          int i;
-          bool match = FALSE;
+          struct writeoutvar *wv = NULL;
+          struct writeoutvar find = { 0 };
           end = strchr(ptr, '}');
           ptr += 2; /* pass the % and the { */
           if(!end) {
@@ -547,43 +570,47 @@ void ourWriteOut(struct OperationConfig *config, struct per_transfer *per,
             continue;
           }
           vlen = end - ptr;
-          for(i = 0; variables[i].name; i++) {
-            if((strlen(variables[i].name) == vlen) &&
-               curl_strnequal(ptr, variables[i].name, vlen)) {
-              match = TRUE;
-              switch(variables[i].id) {
-              case VAR_ONERROR:
-                if(per_result == CURLE_OK)
-                  /* this isn't error so skip the rest */
-                  done = TRUE;
-                break;
-              case VAR_STDOUT:
-                if(fclose_stream)
-                  fclose(stream);
-                fclose_stream = FALSE;
-                stream = stdout;
-                break;
-              case VAR_STDERR:
-                if(fclose_stream)
-                  fclose(stream);
-                fclose_stream = FALSE;
-                stream = tool_stderr;
-                break;
-              case VAR_JSON:
-                ourWriteOutJSON(stream, variables, per, per_result);
-                break;
-              case VAR_HEADER_JSON:
-                headerJSON(stream, per);
-                break;
-              default:
-                (void)variables[i].writefunc(stream, &variables[i],
-                                             per, per_result, false);
-                break;
-              }
+
+          curlx_dyn_reset(&name);
+          if(!curlx_dyn_addn(&name, ptr, vlen)) {
+            find.name = curlx_dyn_ptr(&name);
+            wv = bsearch(&find,
+                         variables, sizeof(variables)/sizeof(variables[0]),
+                         sizeof(variables[0]), matchvar);
+          }
+          if(wv) {
+            switch(wv->id) {
+            case VAR_ONERROR:
+              if(per_result == CURLE_OK)
+                /* this is not error so skip the rest */
+                done = TRUE;
+              break;
+            case VAR_STDOUT:
+              if(fclose_stream)
+                fclose(stream);
+              fclose_stream = FALSE;
+              stream = stdout;
+              break;
+            case VAR_STDERR:
+              if(fclose_stream)
+                fclose(stream);
+              fclose_stream = FALSE;
+              stream = tool_stderr;
+              break;
+            case VAR_JSON:
+              ourWriteOutJSON(stream, variables,
+                              sizeof(variables)/sizeof(variables[0]),
+                              per, per_result);
+              break;
+            case VAR_HEADER_JSON:
+              headerJSON(stream, per);
+              break;
+            default:
+              (void)wv->writefunc(stream, wv, per, per_result, false);
               break;
             }
           }
-          if(!match) {
+          else {
             fprintf(tool_stderr,
                     "curl: unknown --write-out variable: '%.*s'\n",
                     (int)vlen, ptr);
@@ -618,7 +645,7 @@ void ourWriteOut(struct OperationConfig *config, struct per_transfer *per,
           }
           end = strchr(ptr, '}');
           if(end) {
-            char fname[512]; /* holds the longest file name */
+            char fname[512]; /* holds the longest filename */
             size_t flen = end - ptr;
             if(flen < sizeof(fname)) {
               FILE *stream2;
@@ -673,4 +700,5 @@ void ourWriteOut(struct OperationConfig *config, struct per_transfer *per,
   }
   if(fclose_stream)
     fclose(stream);
+  curlx_dyn_free(&name);
 }
diff --git a/src/tool_writeout.h b/src/tool_writeout.h
index 0b9e3cbb1..36b218cc4 100644
--- a/src/tool_writeout.h
+++ b/src/tool_writeout.h
@@ -74,6 +74,7 @@ typedef enum {
   VAR_NUM_CERTS,
   VAR_NUM_CONNECTS,
   VAR_NUM_HEADERS,
+  VAR_NUM_RETRY,
   VAR_ONERROR,
   VAR_PRETRANSFER_TIME,
   VAR_PRIMARY_IP,
diff --git a/src/tool_writeout_json.c b/src/tool_writeout_json.c
index 1a7c1bc11..feb791da9 100644
--- a/src/tool_writeout_json.c
+++ b/src/tool_writeout_json.c
@@ -74,7 +74,7 @@ int jsonquoted(const char *in, size_t len,
       else {
         char o = (char)*i;
         if(lowercase && (o >= 'A' && o <= 'Z'))
-          /* do not use tolower() since that's locale specific */
+          /* do not use tolower() since that is locale specific */
           o |= ('a' - 'A');
         result = curlx_dyn_addn(out, &o, 1);
       }
@@ -101,13 +101,14 @@ void jsonWriteString(FILE *stream, const char *in, bool lowercase)
 }
 
 void ourWriteOutJSON(FILE *stream, const struct writeoutvar mappings[],
+                     size_t nentries,
                      struct per_transfer *per, CURLcode per_result)
 {
-  int i;
+  size_t i;
 
   fputs("{", stream);
 
-  for(i = 0; mappings[i].name != NULL; i++) {
+  for(i = 0; i < nentries; i++) {
     if(mappings[i].writefunc &&
        mappings[i].writefunc(stream, &mappings[i], per, per_result, true))
       fputs(",", stream);
diff --git a/src/tool_writeout_json.h b/src/tool_writeout_json.h
index 49a28194f..91f5d93dc 100644
--- a/src/tool_writeout_json.h
+++ b/src/tool_writeout_json.h
@@ -30,6 +30,7 @@ int jsonquoted(const char *in, size_t len,
                struct curlx_dynbuf *out, bool lowercase);
 
 void ourWriteOutJSON(FILE *stream, const struct writeoutvar mappings[],
+                     size_t nentries,
                      struct per_transfer *per, CURLcode per_result);
 void headerJSON(FILE *stream, struct per_transfer *per);
 void jsonWriteString(FILE *stream, const char *in, bool lowercase);
diff --git a/src/var.c b/src/var.c
index 4dad09989..fb028667d 100644
--- a/src/var.c
+++ b/src/var.c
@@ -110,7 +110,7 @@ static ParameterError varfunc(struct GlobalConfig *global,
     if(*f == '}')
       /* end of functions */
       break;
-    /* On entry, this is known to be a colon already.  In subsequent laps, it
+    /* On entry, this is known to be a colon already. In subsequent laps, it
        is also known to be a colon since that is part of the FUNCMATCH()
        checks */
     f++;
diff --git a/tests/CI.md b/tests/CI.md
index 0d3d1108e..1f60682f6 100644
--- a/tests/CI.md
+++ b/tests/CI.md
@@ -107,11 +107,4 @@ admins/group members can be added on request.
 
 ### Cirrus CI
 
-Cirrus CI runs a basic test suite on FreeBSD and Windows. This is configured in
-`.cirrus.yml`.
-
-You can [view the full list of CI jobs on Cirrus CI's
-website](https://cirrus-ci.com/github/curl/curl).
-
-`@bagder` has access to edit the "Project Settings" on that page. Additional
-admins/group members can be added on request.
+Not used anymore.
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index 82c651167..53e39e01b 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -45,6 +45,45 @@ function(add_runtests targetname test_flags)
   )
 endfunction()
 
+# Create configurehelp.pm, used by tests needing to run the C preprocessor.
+if(MSVC OR CMAKE_COMPILER_IS_GNUCC OR CMAKE_C_COMPILER_ID MATCHES "Clang")
+  set(_cpp_cmd "\"${CMAKE_C_COMPILER}\" -E")
+  if(APPLE AND NOT CMAKE_OSX_SYSROOT STREQUAL "")
+    set(_cpp_cmd "${_cpp_cmd} -isysroot ${CMAKE_OSX_SYSROOT}")
+  endif()
+  # Add header directories, like autotools builds do.
+  get_property(_include_dirs TARGET ${LIB_SELECTED} PROPERTY INCLUDE_DIRECTORIES)
+  foreach(_include_dir IN LISTS _include_dirs)
+    set(_cpp_cmd "${_cpp_cmd} -I${_include_dir}")
+  endforeach()
+else()
+  set(_cpp_cmd "cpp")
+endif()
+file(WRITE "${CMAKE_CURRENT_BINARY_DIR}/configurehelp.pm" "# This is a generated file.  Do not edit.
+
+package configurehelp;
+
+use strict;
+use warnings;
+use Exporter;
+
+use vars qw(
+    @ISA
+    @EXPORT_OK
+    \$Cpreprocessor
+    );
+
+@ISA = qw(Exporter);
+
+@EXPORT_OK = qw(
+    \$Cpreprocessor
+    );
+
+\$Cpreprocessor = '${_cpp_cmd}';
+
+1;
+")
+
 add_runtests(test-quiet     "-a -s")
 add_runtests(test-am        "-a -am")
 add_runtests(test-full      "-a -p -r")
diff --git a/tests/FILEFORMAT.md b/tests/FILEFORMAT.md
index d4dd85b5e..2c36a91cd 100644
--- a/tests/FILEFORMAT.md
+++ b/tests/FILEFORMAT.md
@@ -124,6 +124,7 @@ Available substitute variables include:
 - `%CLIENT6IP` - IPv6 address of the client running curl
 - `%CLIENTIP` - IPv4 address of the client running curl
 - `%CURL` - Path to the curl executable
+- `%DATE` - current YYYY-MM-DD date
 - `%FILE_PWD` - Current directory, on Windows prefixed with a slash
 - `%FTP6PORT` - IPv6 port number of the FTP server
 - `%FTPPORT` - Port number of the FTP server
@@ -136,20 +137,18 @@ Available substitute variables include:
 - `%GOPHERSPORT` - Port number of the Gophers server
 - `%HOST6IP` - IPv6 address of the host running this test
 - `%HOSTIP` - IPv4 address of the host running this test
+- `%HTTP2PORT` - Port number of the HTTP/2 server
 - `%HTTP6PORT` - IPv6 port number of the HTTP server
 - `%HTTPPORT` - Port number of the HTTP server
-- `%HTTP2PORT` - Port number of the HTTP/2 server
 - `%HTTPSPORT` - Port number of the HTTPS server
 - `%HTTPSPROXYPORT` - Port number of the HTTPS-proxy
 - `%HTTPTLS6PORT` - IPv6 port number of the HTTP TLS server
 - `%HTTPTLSPORT` - Port number of the HTTP TLS server
 - `%HTTPUNIXPATH` - Path to the Unix socket of the HTTP server
-- `%SOCKSUNIXPATH` - Path to the Unix socket of the SOCKS server
 - `%IMAP6PORT` - IPv6 port number of the IMAP server
 - `%IMAPPORT` - Port number of the IMAP server
 - `%LOGDIR` - Log directory relative to %PWD
 - `%MQTTPORT` - Port number of the MQTT server
-- `%TELNETPORT` - Port number of the telnet server
 - `%NOLISTENPORT` - Port number where no service is listening
 - `%POP36PORT` - IPv6 port number of the POP3 server
 - `%POP3PORT` - Port number of the POP3 server
@@ -163,15 +162,18 @@ Available substitute variables include:
 - `%SMTP6PORT` - IPv6 port number of the SMTP server
 - `%SMTPPORT` - Port number of the SMTP server
 - `%SOCKSPORT` - Port number of the SOCKS4/5 server
+- `%SOCKSUNIXPATH` - Path to the Unix socket of the SOCKS server
 - `%SRCDIR` - Full path to the source dir
+- `%SSH_PWD` - Current directory friendly for the SSH server
 - `%SSHPORT` - Port number of the SCP/SFTP server
 - `%SSHSRVMD5` - MD5 of SSH server's public key
 - `%SSHSRVSHA256` - SHA256 of SSH server's public key
-- `%SSH_PWD` - Current directory friendly for the SSH server
+- `%TELNETPORT` - Port number of the telnet server
 - `%TESTNUMBER` - Number of the test case
 - `%TFTP6PORT` - IPv6 port number of the TFTP server
 - `%TFTPPORT` - Port number of the TFTP server
 - `%USER` - Login ID of the user running the test
+- `%VERNUM` - the version number of the tested curl (without -DEV)
 - `%VERSION` - the full version number of the tested curl
 
 # `<testcase>`
@@ -430,7 +432,7 @@ Features testable here are:
 - `CharConv`
 - `cookies`
 - `crypto`
-- `debug`
+- `Debug`
 - `DoH`
 - `getrlimit`
 - `GnuTLS`
@@ -441,12 +443,12 @@ Features testable here are:
 - `HTTP-auth`
 - `http/2`
 - `http/3`
-- `https-proxy`
+- `HTTPS-proxy`
 - `hyper`
-- `idn`
-- `ipv6`
+- `IDN`
+- `IPv6`
 - `Kerberos`
-- `large_file`
+- `Largefile`
 - `large-time` (time_t is larger than 32 bit)
 - `ld_preload`
 - `libssh2`
@@ -481,7 +483,7 @@ Features testable here are:
 - `threadsafe`
 - `Unicode`
 - `unittest`
-- `unix-sockets`
+- `UnixSockets`
 - `verbose-strings`
 - `wakeup`
 - `win32`
@@ -589,6 +591,15 @@ which is useful if the test case needs a file to act on.
 If `nonewline="yes"` is used, the created file will have the final newline
 stripped off.
 
+### `<file1>`
+1 to 4 can be appended to 'file' to create more files.
+
+### `<file2>`
+
+### `<file3>`
+
+### `<file4>`
+
 ### `<stdin [nonewline="yes"]>`
 Pass this given data on stdin to the tool.
 
@@ -627,12 +638,15 @@ server is used), if `nonewline` is set, we will cut off the trailing newline
 of this given data before comparing with the one actually sent by the client
 The `<strip>` and `<strippart>` rules are applied before comparisons are made.
 
-### `<stderr [mode="text"] [nonewline="yes"]>`
+### `<stderr [mode="text"] [nonewline="yes"] [crlf="yes"]>`
 This verifies that this data was passed to stderr.
 
 Use the mode="text" attribute if the output is in text mode on platforms that
 have a text/binary difference.
 
+`crlf=yes` forces the newlines to become CRLF even if not written so in the
+test.
+
 If `nonewline` is set, we will cut off the trailing newline of this given data
 before comparing with the one actually received by the client
 
diff --git a/tests/Makefile.am b/tests/Makefile.am
index 7e6697f97..f3e0f87e3 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -40,6 +40,8 @@ TESTSCRIPTS = \
  test1275.pl  \
  test1276.pl  \
  test1477.pl  \
+ test1486.pl  \
+ test1488.pl  \
  test1544.pl  \
  test971.pl
 
@@ -125,7 +127,7 @@ TEST_E = -a -e
 TEST_NF = -a -p ~flaky ~timing-dependent
 
 # special CI target derived from nonflaky with CI-specific flags
-TEST_CI = $(TEST_NF) -rm
+TEST_CI = $(TEST_NF) -r -rm
 endif
 
 # make sure that PERL is pointing to an executable
@@ -162,7 +164,7 @@ checksrc:
 	(cd server && $(MAKE) checksrc)
 	(cd http && $(MAKE) checksrc)
 
-if CURLDEBUG
+if DEBUGBUILD
 # for debug builds, we scan the sources on all regular make invokes
 all-local: checksrc
 endif
diff --git a/tests/certs/EdelCurlRoot-ca.prm b/tests/certs/EdelCurlRoot-ca.prm
index c8e248b3e..cf1b30d23 100644
--- a/tests/certs/EdelCurlRoot-ca.prm
+++ b/tests/certs/EdelCurlRoot-ca.prm
@@ -1,20 +1,9 @@
 extensions = x509v3
-[ req ]
-default_bits                    = 2048
-distinguished_name              = req_DN
-default_md			= sha256
-string_mask			= utf8only
-[ req_DN ]
-countryName                     = "Country Name"
-countryName_value            = NN
-organizationName              = "Organization Name"
-organizationName_value     = Edel Curl Arctic Illudium Research Cloud
-commonName                      = "Common Name"
-commonName_value              = Northern Nowhere Trust Anchor
+
 [ x509v3 ]
-basicConstraints = critical,CA:true
-keyUsage        = critical,keyCertSign,cRLSign
-subjectKeyIdentifier = hash
+basicConstraints        = critical,CA:true
+keyUsage                = critical,keyCertSign,cRLSign
+subjectKeyIdentifier    = hash
 authorityKeyIdentifier  = keyid:always
 authorityInfoAccess     = @issuer_info
 crlDistributionPoints   = @crl_info
@@ -27,4 +16,18 @@ authorityInfoAccess     = @issuer_info
 caIssuers;URI.0         = http://test.curl.se/ca/EdelCurlRoot.cer
 
 [ crl_info ]
-URI.0                   = http://test.curl.se/ca/EdelCurlRoot.crl
\ No newline at end of file
+URI.0                   = http://test.curl.se/ca/EdelCurlRoot.crl
+
+[ req ]
+default_bits            = 2048
+distinguished_name      = req_DN
+default_md              = sha256
+string_mask             = utf8only
+
+[ req_DN ]
+countryName             = "Country Name"
+countryName_value       = NN
+organizationName        = "Organization Name"
+organizationName_value  = Edel Curl Arctic Illudium Research Cloud
+commonName              = "Common Name"
+commonName_value        = Northern Nowhere Trust Anchor
diff --git a/tests/certs/Server-localhost-firstSAN-sv.pem b/tests/certs/Server-localhost-firstSAN-sv.pem
index 3751e7b60..e06863227 100644
--- a/tests/certs/Server-localhost-firstSAN-sv.pem
+++ b/tests/certs/Server-localhost-firstSAN-sv.pem
@@ -1,11 +1,12 @@
 extensions = x509v3
+
 [ x509v3 ]
-subjectAltName = DNS:localhost,DNS:localhost1,DNS:localhost2
-keyUsage	= keyEncipherment,digitalSignature,keyAgreement
-extendedKeyUsage = serverAuth
-subjectKeyIdentifier = hash
-authorityKeyIdentifier = keyid
-basicConstraints = CA:false
+subjectAltName          = DNS:localhost,DNS:localhost1,DNS:localhost2
+keyUsage                = keyEncipherment,digitalSignature,keyAgreement
+extendedKeyUsage        = serverAuth
+subjectKeyIdentifier    = hash
+authorityKeyIdentifier  = keyid
+basicConstraints        = CA:false
 authorityInfoAccess     = @issuer_info
 crlDistributionPoints   = @crl_info
 
@@ -20,23 +21,18 @@ caIssuers;URI.0         = http://test.curl.se/ca/EdelCurlRoot.cer
 URI.0                   = http://test.curl.se/ca/EdelCurlRoot.crl
 
 [ req ]
-default_bits                    = 1024
-distinguished_name              = req_DN
-default_md			= sha256
-string_mask			= utf8only
+default_bits            = 1024
+distinguished_name      = req_DN
+default_md              = sha256
+string_mask             = utf8only
 
 [ req_DN ]
-countryName                     = "Country Name is Northern Nowhere"
-countryName_value            = NN
-organizationName              = "Organization Name"
-organizationName_value     = Edel Curl Arctic Illudium Research Cloud
-commonName                      = "Common Name"
-commonName_value              = localhost.nn
-
-[something]
-# The key
-# the certificate
-# some dhparam
+countryName             = "Country Name is Northern Nowhere"
+countryName_value       = NN
+organizationName        = "Organization Name"
+organizationName_value  = Edel Curl Arctic Illudium Research Cloud
+commonName              = "Common Name"
+commonName_value        = localhost.nn
 -----BEGIN PRIVATE KEY-----
 MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCqFG49ghwozY+A
 r1DtF5dt5qhhPqyorBPOmespLElz+RJANcR5hA2esCjEn2TjwW0tcRFdSxRhIEsY
diff --git a/tests/certs/Server-localhost-firstSAN-sv.prm b/tests/certs/Server-localhost-firstSAN-sv.prm
index 911f4ce54..1a3889935 100644
--- a/tests/certs/Server-localhost-firstSAN-sv.prm
+++ b/tests/certs/Server-localhost-firstSAN-sv.prm
@@ -1,11 +1,12 @@
 extensions = x509v3
+
 [ x509v3 ]
-subjectAltName = DNS:localhost,DNS:localhost1,DNS:localhost2
-keyUsage	= keyEncipherment,digitalSignature,keyAgreement
-extendedKeyUsage = serverAuth
-subjectKeyIdentifier = hash
-authorityKeyIdentifier = keyid
-basicConstraints = CA:false
+subjectAltName          = DNS:localhost,DNS:localhost1,DNS:localhost2
+keyUsage                = keyEncipherment,digitalSignature,keyAgreement
+extendedKeyUsage        = serverAuth
+subjectKeyIdentifier    = hash
+authorityKeyIdentifier  = keyid
+basicConstraints        = CA:false
 authorityInfoAccess     = @issuer_info
 crlDistributionPoints   = @crl_info
 
@@ -20,20 +21,15 @@ caIssuers;URI.0         = http://test.curl.se/ca/EdelCurlRoot.cer
 URI.0                   = http://test.curl.se/ca/EdelCurlRoot.crl
 
 [ req ]
-default_bits                    = 1024
-distinguished_name              = req_DN
-default_md			= sha256
-string_mask			= utf8only
+default_bits            = 1024
+distinguished_name      = req_DN
+default_md              = sha256
+string_mask             = utf8only
 
 [ req_DN ]
-countryName                     = "Country Name is Northern Nowhere"
-countryName_value            = NN
-organizationName              = "Organization Name"
-organizationName_value     = Edel Curl Arctic Illudium Research Cloud
-commonName                      = "Common Name"
-commonName_value              = localhost.nn
-
-[something]
-# The key
-# the certificate
-# some dhparam
+countryName             = "Country Name is Northern Nowhere"
+countryName_value       = NN
+organizationName        = "Organization Name"
+organizationName_value  = Edel Curl Arctic Illudium Research Cloud
+commonName              = "Common Name"
+commonName_value        = localhost.nn
diff --git a/tests/certs/Server-localhost-lastSAN-sv.pem b/tests/certs/Server-localhost-lastSAN-sv.pem
index b1cbd4b6b..c3124ff1c 100644
--- a/tests/certs/Server-localhost-lastSAN-sv.pem
+++ b/tests/certs/Server-localhost-lastSAN-sv.pem
@@ -1,11 +1,12 @@
 extensions = x509v3
+
 [ x509v3 ]
-subjectAltName = DNS:localhost1,DNS:localhost2,DNS:localhost
-keyUsage	= keyEncipherment,digitalSignature,keyAgreement
-extendedKeyUsage = serverAuth
-subjectKeyIdentifier = hash
-authorityKeyIdentifier = keyid
-basicConstraints = CA:false
+subjectAltName          = DNS:localhost1,DNS:localhost2,DNS:localhost
+keyUsage                = keyEncipherment,digitalSignature,keyAgreement
+extendedKeyUsage        = serverAuth
+subjectKeyIdentifier    = hash
+authorityKeyIdentifier  = keyid
+basicConstraints        = CA:false
 authorityInfoAccess     = @issuer_info
 crlDistributionPoints   = @crl_info
 
@@ -20,22 +21,18 @@ caIssuers;URI.0         = http://test.curl.se/ca/EdelCurlRoot.cer
 URI.0                   = http://test.curl.se/ca/EdelCurlRoot.crl
 
 [ req ]
-default_bits                    = 1024
-distinguished_name              = req_DN
-default_md			= sha256
-string_mask			= utf8only
-[ req_DN ]
-countryName                     = "Country Name is Northern Nowhere"
-countryName_value            = NN
-organizationName              = "Organization Name"
-organizationName_value     = Edel Curl Arctic Illudium Research Cloud
-commonName                      = "Common Name"
-commonName_value              = localhost.nn
+default_bits            = 1024
+distinguished_name      = req_DN
+default_md              = sha256
+string_mask             = utf8only
 
-[something]
-# The key
-# the certificate
-# some dhparam
+[ req_DN ]
+countryName             = "Country Name is Northern Nowhere"
+countryName_value       = NN
+organizationName        = "Organization Name"
+organizationName_value  = Edel Curl Arctic Illudium Research Cloud
+commonName              = "Common Name"
+commonName_value        = localhost.nn
 -----BEGIN PRIVATE KEY-----
 MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDIhP5pZDPD3LV0
 iseyu9lp4qmVbV+3JeaCACv1UyHnKK5mtjj9FbGRiFIxKbtz4uCZYpVENVHXVMjS
diff --git a/tests/certs/Server-localhost-lastSAN-sv.prm b/tests/certs/Server-localhost-lastSAN-sv.prm
index c5e72f454..fd2507323 100644
--- a/tests/certs/Server-localhost-lastSAN-sv.prm
+++ b/tests/certs/Server-localhost-lastSAN-sv.prm
@@ -1,11 +1,12 @@
 extensions = x509v3
+
 [ x509v3 ]
-subjectAltName = DNS:localhost1,DNS:localhost2,DNS:localhost
-keyUsage	= keyEncipherment,digitalSignature,keyAgreement
-extendedKeyUsage = serverAuth
-subjectKeyIdentifier = hash
-authorityKeyIdentifier = keyid
-basicConstraints = CA:false
+subjectAltName          = DNS:localhost1,DNS:localhost2,DNS:localhost
+keyUsage                = keyEncipherment,digitalSignature,keyAgreement
+extendedKeyUsage        = serverAuth
+subjectKeyIdentifier    = hash
+authorityKeyIdentifier  = keyid
+basicConstraints        = CA:false
 authorityInfoAccess     = @issuer_info
 crlDistributionPoints   = @crl_info
 
@@ -20,19 +21,15 @@ caIssuers;URI.0         = http://test.curl.se/ca/EdelCurlRoot.cer
 URI.0                   = http://test.curl.se/ca/EdelCurlRoot.crl
 
 [ req ]
-default_bits                    = 1024
-distinguished_name              = req_DN
-default_md			= sha256
-string_mask			= utf8only
-[ req_DN ]
-countryName                     = "Country Name is Northern Nowhere"
-countryName_value            = NN
-organizationName              = "Organization Name"
-organizationName_value     = Edel Curl Arctic Illudium Research Cloud
-commonName                      = "Common Name"
-commonName_value              = localhost.nn
+default_bits            = 1024
+distinguished_name      = req_DN
+default_md              = sha256
+string_mask             = utf8only
 
-[something]
-# The key
-# the certificate
-# some dhparam
+[ req_DN ]
+countryName             = "Country Name is Northern Nowhere"
+countryName_value       = NN
+organizationName        = "Organization Name"
+organizationName_value  = Edel Curl Arctic Illudium Research Cloud
+commonName              = "Common Name"
+commonName_value        = localhost.nn
diff --git a/tests/certs/Server-localhost-sv.pem b/tests/certs/Server-localhost-sv.pem
index 583831f8f..2761de438 100644
--- a/tests/certs/Server-localhost-sv.pem
+++ b/tests/certs/Server-localhost-sv.pem
@@ -1,11 +1,12 @@
 extensions = x509v3
+
 [ x509v3 ]
-subjectAltName = DNS:localhost
-keyUsage	= keyEncipherment,digitalSignature,keyAgreement
-extendedKeyUsage = serverAuth
-subjectKeyIdentifier = hash
-authorityKeyIdentifier = keyid
-basicConstraints = CA:false
+subjectAltName          = DNS:localhost
+keyUsage                = keyEncipherment,digitalSignature,keyAgreement
+extendedKeyUsage        = serverAuth
+subjectKeyIdentifier    = hash
+authorityKeyIdentifier  = keyid
+basicConstraints        = CA:false
 authorityInfoAccess     = @issuer_info
 crlDistributionPoints   = @crl_info
 
@@ -20,22 +21,18 @@ caIssuers;URI.0         = http://test.curl.se/ca/EdelCurlRoot.cer
 URI.0                   = http://test.curl.se/ca/EdelCurlRoot.crl
 
 [ req ]
-default_bits                    = 1024
-distinguished_name              = req_DN
-default_md			= sha256
-string_mask			= utf8only
-[ req_DN ]
-countryName                     = "Country Name is Northern Nowhere"
-countryName_value            = NN
-organizationName              = "Organization Name"
-organizationName_value     = Edel Curl Arctic Illudium Research Cloud
-commonName                      = "Common Name"
-commonName_value              = localhost 
+default_bits            = 1024
+distinguished_name      = req_DN
+default_md              = sha256
+string_mask             = utf8only
 
-[something]
-# The key
-# the certificate
-# some dhparam
+[ req_DN ]
+countryName             = "Country Name is Northern Nowhere"
+countryName_value       = NN
+organizationName        = "Organization Name"
+organizationName_value  = Edel Curl Arctic Illudium Research Cloud
+commonName              = "Common Name"
+commonName_value        = localhost
 -----BEGIN PRIVATE KEY-----
 MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDGuAQ91voxoNf3
 6YhLWl5vb9v0yUt+bCrPNHsquhpxrX94bPceygfQKQNJ5GOGTPZnP70yacu4FecO
diff --git a/tests/certs/Server-localhost-sv.prm b/tests/certs/Server-localhost-sv.prm
index f58710406..54a07e3f3 100644
--- a/tests/certs/Server-localhost-sv.prm
+++ b/tests/certs/Server-localhost-sv.prm
@@ -1,11 +1,12 @@
 extensions = x509v3
+
 [ x509v3 ]
-subjectAltName = DNS:localhost
-keyUsage	= keyEncipherment,digitalSignature,keyAgreement
-extendedKeyUsage = serverAuth
-subjectKeyIdentifier = hash
-authorityKeyIdentifier = keyid
-basicConstraints = CA:false
+subjectAltName          = DNS:localhost
+keyUsage                = keyEncipherment,digitalSignature,keyAgreement
+extendedKeyUsage        = serverAuth
+subjectKeyIdentifier    = hash
+authorityKeyIdentifier  = keyid
+basicConstraints        = CA:false
 authorityInfoAccess     = @issuer_info
 crlDistributionPoints   = @crl_info
 
@@ -20,19 +21,15 @@ caIssuers;URI.0         = http://test.curl.se/ca/EdelCurlRoot.cer
 URI.0                   = http://test.curl.se/ca/EdelCurlRoot.crl
 
 [ req ]
-default_bits                    = 1024
-distinguished_name              = req_DN
-default_md			= sha256
-string_mask			= utf8only
-[ req_DN ]
-countryName                     = "Country Name is Northern Nowhere"
-countryName_value            = NN
-organizationName              = "Organization Name"
-organizationName_value     = Edel Curl Arctic Illudium Research Cloud
-commonName                      = "Common Name"
-commonName_value              = localhost 
+default_bits            = 1024
+distinguished_name      = req_DN
+default_md              = sha256
+string_mask             = utf8only
 
-[something]
-# The key
-# the certificate
-# some dhparam
+[ req_DN ]
+countryName             = "Country Name is Northern Nowhere"
+countryName_value       = NN
+organizationName        = "Organization Name"
+organizationName_value  = Edel Curl Arctic Illudium Research Cloud
+commonName              = "Common Name"
+commonName_value        = localhost
diff --git a/tests/certs/Server-localhost.nn-sv.pem b/tests/certs/Server-localhost.nn-sv.pem
index 29dc52ce0..4ce5c1e6b 100644
--- a/tests/certs/Server-localhost.nn-sv.pem
+++ b/tests/certs/Server-localhost.nn-sv.pem
@@ -1,11 +1,12 @@
 extensions = x509v3
+
 [ x509v3 ]
-subjectAltName = DNS:localhost.nn
-keyUsage	= keyEncipherment,digitalSignature,keyAgreement
-extendedKeyUsage = serverAuth
-subjectKeyIdentifier = hash
-authorityKeyIdentifier = keyid
-basicConstraints = CA:false
+subjectAltName          = DNS:localhost.nn
+keyUsage                = keyEncipherment,digitalSignature,keyAgreement
+extendedKeyUsage        = serverAuth
+subjectKeyIdentifier    = hash
+authorityKeyIdentifier  = keyid
+basicConstraints        = CA:false
 authorityInfoAccess     = @issuer_info
 crlDistributionPoints   = @crl_info
 
@@ -20,22 +21,18 @@ caIssuers;URI.0         = http://test.curl.se/ca/EdelCurlRoot.cer
 URI.0                   = http://test.curl.se/ca/EdelCurlRoot.crl
 
 [ req ]
-default_bits                    = 1024
-distinguished_name              = req_DN
-default_md			= sha256
-string_mask			= utf8only
-[ req_DN ]
-countryName                     = "Country Name is Northern Nowhere"
-countryName_value            = NN
-organizationName              = "Organization Name"
-organizationName_value     = Edel Curl Arctic Illudium Research Cloud
-commonName                      = "Common Name"
-commonName_value              = localhost.nn 
+default_bits            = 1024
+distinguished_name      = req_DN
+default_md              = sha256
+string_mask             = utf8only
 
-[something]
-# The key
-# the certificate
-# some dhparam
+[ req_DN ]
+countryName             = "Country Name is Northern Nowhere"
+countryName_value       = NN
+organizationName        = "Organization Name"
+organizationName_value  = Edel Curl Arctic Illudium Research Cloud
+commonName              = "Common Name"
+commonName_value        = localhost.nn
 -----BEGIN PRIVATE KEY-----
 MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCjmuQP4L2TqVqn
 Xq2FXtbgmLTpIuBikMPZVzcWXVc9aMrizy9GZxoMrw6JhgEG39bJgBUKQ4VAP9ru
diff --git a/tests/certs/Server-localhost.nn-sv.prm b/tests/certs/Server-localhost.nn-sv.prm
index 5e93bf8b7..376fc3a11 100644
--- a/tests/certs/Server-localhost.nn-sv.prm
+++ b/tests/certs/Server-localhost.nn-sv.prm
@@ -1,11 +1,12 @@
 extensions = x509v3
+
 [ x509v3 ]
-subjectAltName = DNS:localhost.nn
-keyUsage	= keyEncipherment,digitalSignature,keyAgreement
-extendedKeyUsage = serverAuth
-subjectKeyIdentifier = hash
-authorityKeyIdentifier = keyid
-basicConstraints = CA:false
+subjectAltName          = DNS:localhost.nn
+keyUsage                = keyEncipherment,digitalSignature,keyAgreement
+extendedKeyUsage        = serverAuth
+subjectKeyIdentifier    = hash
+authorityKeyIdentifier  = keyid
+basicConstraints        = CA:false
 authorityInfoAccess     = @issuer_info
 crlDistributionPoints   = @crl_info
 
@@ -20,19 +21,15 @@ caIssuers;URI.0         = http://test.curl.se/ca/EdelCurlRoot.cer
 URI.0                   = http://test.curl.se/ca/EdelCurlRoot.crl
 
 [ req ]
-default_bits                    = 1024
-distinguished_name              = req_DN
-default_md			= sha256
-string_mask			= utf8only
-[ req_DN ]
-countryName                     = "Country Name is Northern Nowhere"
-countryName_value            = NN
-organizationName              = "Organization Name"
-organizationName_value     = Edel Curl Arctic Illudium Research Cloud
-commonName                      = "Common Name"
-commonName_value              = localhost.nn 
+default_bits            = 1024
+distinguished_name      = req_DN
+default_md              = sha256
+string_mask             = utf8only
 
-[something]
-# The key
-# the certificate
-# some dhparam
+[ req_DN ]
+countryName             = "Country Name is Northern Nowhere"
+countryName_value       = NN
+organizationName        = "Organization Name"
+organizationName_value  = Edel Curl Arctic Illudium Research Cloud
+commonName              = "Common Name"
+commonName_value        = localhost.nn
diff --git a/tests/certs/Server-localhost0h-sv.pem b/tests/certs/Server-localhost0h-sv.pem
index 72f326dfb..9c4c9632a 100644
--- a/tests/certs/Server-localhost0h-sv.pem
+++ b/tests/certs/Server-localhost0h-sv.pem
@@ -1,12 +1,13 @@
 extensions = x509v3
+
 [ x509v3 ]
-#subjectAltName = DNS:localhost\0h
-subjectAltName = DER:30:0d:82:0b:6c:6f:63:61:6c:68:6f:73:74:00:68
-keyUsage	= keyEncipherment,digitalSignature,keyAgreement
-extendedKeyUsage = serverAuth
-subjectKeyIdentifier = hash
-authorityKeyIdentifier = keyid
-basicConstraints = CA:false
+#subjectAltName         = DNS:localhost\0h
+subjectAltName          = DER:30:0d:82:0b:6c:6f:63:61:6c:68:6f:73:74:00:68
+keyUsage                = keyEncipherment,digitalSignature,keyAgreement
+extendedKeyUsage        = serverAuth
+subjectKeyIdentifier    = hash
+authorityKeyIdentifier  = keyid
+basicConstraints        = CA:false
 authorityInfoAccess     = @issuer_info
 crlDistributionPoints   = @crl_info
 
@@ -21,22 +22,18 @@ caIssuers;URI.0         = http://test.curl.se/ca/EdelCurlRoot.cer
 URI.0                   = http://test.curl.se/ca/EdelCurlRoot.crl
 
 [ req ]
-default_bits                    = 1024
-distinguished_name              = req_DN
-default_md			= sha256
-string_mask			= utf8only
-[ req_DN ]
-countryName                     = "Country Name is Northern Nowhere"
-countryName_value            = NN
-organizationName              = "Organization Name"
-organizationName_value     = Edel Curl Arctic Illudium Research Cloud
-commonName                      = "Common Name"
-commonName_value              = localhost 
+default_bits            = 1024
+distinguished_name      = req_DN
+default_md              = sha256
+string_mask             = utf8only
 
-[something]
-# The key
-# the certificate
-# some dhparam
+[ req_DN ]
+countryName             = "Country Name is Northern Nowhere"
+countryName_value       = NN
+organizationName        = "Organization Name"
+organizationName_value  = Edel Curl Arctic Illudium Research Cloud
+commonName              = "Common Name"
+commonName_value        = localhost
 -----BEGIN PRIVATE KEY-----
 MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDfKZNYgh2iuAcq
 so+TDt8VSXIGkxlKLcW9VpJa2vTTmgEc7kdXDp7Y1w3Ezkui8PwH7JHplQj06V3y
diff --git a/tests/certs/Server-localhost0h-sv.prm b/tests/certs/Server-localhost0h-sv.prm
index 439aefb9e..428534176 100644
--- a/tests/certs/Server-localhost0h-sv.prm
+++ b/tests/certs/Server-localhost0h-sv.prm
@@ -1,12 +1,13 @@
 extensions = x509v3
+
 [ x509v3 ]
-#subjectAltName = DNS:localhost\0h
-subjectAltName = DER:30:0d:82:0b:6c:6f:63:61:6c:68:6f:73:74:00:68
-keyUsage	= keyEncipherment,digitalSignature,keyAgreement
-extendedKeyUsage = serverAuth
-subjectKeyIdentifier = hash
-authorityKeyIdentifier = keyid
-basicConstraints = CA:false
+#subjectAltName         = DNS:localhost\0h
+subjectAltName          = DER:30:0d:82:0b:6c:6f:63:61:6c:68:6f:73:74:00:68
+keyUsage                = keyEncipherment,digitalSignature,keyAgreement
+extendedKeyUsage        = serverAuth
+subjectKeyIdentifier    = hash
+authorityKeyIdentifier  = keyid
+basicConstraints        = CA:false
 authorityInfoAccess     = @issuer_info
 crlDistributionPoints   = @crl_info
 
@@ -21,19 +22,15 @@ caIssuers;URI.0         = http://test.curl.se/ca/EdelCurlRoot.cer
 URI.0                   = http://test.curl.se/ca/EdelCurlRoot.crl
 
 [ req ]
-default_bits                    = 1024
-distinguished_name              = req_DN
-default_md			= sha256
-string_mask			= utf8only
-[ req_DN ]
-countryName                     = "Country Name is Northern Nowhere"
-countryName_value            = NN
-organizationName              = "Organization Name"
-organizationName_value     = Edel Curl Arctic Illudium Research Cloud
-commonName                      = "Common Name"
-commonName_value              = localhost 
+default_bits            = 1024
+distinguished_name      = req_DN
+default_md              = sha256
+string_mask             = utf8only
 
-[something]
-# The key
-# the certificate
-# some dhparam
+[ req_DN ]
+countryName             = "Country Name is Northern Nowhere"
+countryName_value       = NN
+organizationName        = "Organization Name"
+organizationName_value  = Edel Curl Arctic Illudium Research Cloud
+commonName              = "Common Name"
+commonName_value        = localhost
diff --git a/tests/certs/stunnel-sv.pem b/tests/certs/stunnel-sv.pem
index b7dd1e879..b273ff761 100644
--- a/tests/certs/stunnel-sv.pem
+++ b/tests/certs/stunnel-sv.pem
@@ -1,11 +1,12 @@
 extensions = x509v3
+
 [ x509v3 ]
-subjectAltName = DNS:localhost
-keyUsage	= keyEncipherment,digitalSignature,keyAgreement
-extendedKeyUsage = serverAuth
-subjectKeyIdentifier = hash
-authorityKeyIdentifier = keyid
-basicConstraints = CA:false
+subjectAltName          = DNS:localhost
+keyUsage                = keyEncipherment,digitalSignature,keyAgreement
+extendedKeyUsage        = serverAuth
+subjectKeyIdentifier    = hash
+authorityKeyIdentifier  = keyid
+basicConstraints        = CA:false
 authorityInfoAccess     = @issuer_info
 crlDistributionPoints   = @crl_info
 
@@ -20,22 +21,18 @@ caIssuers;URI.0         = http://test.curl.se/ca/EdelCurlRoot.cer
 URI.0                   = http://test.curl.se/ca/EdelCurlRoot.crl
 
 [ req ]
-default_bits                    = 12048
-distinguished_name              = req_DN
-default_md			= sha256
-string_mask			= utf8only
-[ req_DN ]
-countryName                     = "Country Name is Northern Nowhere"
-countryName_value            = NN
-organizationName              = "Organization Name"
-organizationName_value     = Edel Curl Arctic Illudium Research Cloud
-commonName                      = "Common Name"
-commonName_value              = localhost
+default_bits            = 12048
+distinguished_name      = req_DN
+default_md              = sha256
+string_mask             = utf8only
 
-[something]
-# The key
-# the certificate
-# some dhparam
+[ req_DN ]
+countryName             = "Country Name is Northern Nowhere"
+countryName_value       = NN
+organizationName        = "Organization Name"
+organizationName_value  = Edel Curl Arctic Illudium Research Cloud
+commonName              = "Common Name"
+commonName_value        = localhost
 -----BEGIN PRIVATE KEY-----
 MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCrCrAD0Hb+Xs4V
 3mHV45FvfNa7yiaOeL4mNdGmWfHVPFU+CSzsoNSvDjxaorWweFGVYoCAcchOn1lZ
diff --git a/tests/certs/stunnel-sv.prm b/tests/certs/stunnel-sv.prm
index 3803da375..8fd080bd8 100644
--- a/tests/certs/stunnel-sv.prm
+++ b/tests/certs/stunnel-sv.prm
@@ -1,11 +1,12 @@
 extensions = x509v3
+
 [ x509v3 ]
-subjectAltName = DNS:localhost
-keyUsage	= keyEncipherment,digitalSignature,keyAgreement
-extendedKeyUsage = serverAuth
-subjectKeyIdentifier = hash
-authorityKeyIdentifier = keyid
-basicConstraints = CA:false
+subjectAltName          = DNS:localhost
+keyUsage                = keyEncipherment,digitalSignature,keyAgreement
+extendedKeyUsage        = serverAuth
+subjectKeyIdentifier    = hash
+authorityKeyIdentifier  = keyid
+basicConstraints        = CA:false
 authorityInfoAccess     = @issuer_info
 crlDistributionPoints   = @crl_info
 
@@ -20,19 +21,15 @@ caIssuers;URI.0         = http://test.curl.se/ca/EdelCurlRoot.cer
 URI.0                   = http://test.curl.se/ca/EdelCurlRoot.crl
 
 [ req ]
-default_bits                    = 12048
-distinguished_name              = req_DN
-default_md			= sha256
-string_mask			= utf8only
-[ req_DN ]
-countryName                     = "Country Name is Northern Nowhere"
-countryName_value            = NN
-organizationName              = "Organization Name"
-organizationName_value     = Edel Curl Arctic Illudium Research Cloud
-commonName                      = "Common Name"
-commonName_value              = localhost
+default_bits            = 12048
+distinguished_name      = req_DN
+default_md              = sha256
+string_mask             = utf8only
 
-[something]
-# The key
-# the certificate
-# some dhparam
+[ req_DN ]
+countryName             = "Country Name is Northern Nowhere"
+countryName_value       = NN
+organizationName        = "Organization Name"
+organizationName_value  = Edel Curl Arctic Illudium Research Cloud
+commonName              = "Common Name"
+commonName_value        = localhost
diff --git a/tests/conftest.py b/tests/conftest.py
index f1e066256..b22a70d35 100644
--- a/tests/conftest.py
+++ b/tests/conftest.py
@@ -5,7 +5,7 @@
 #                            | (__| |_| |  _ <| |___
 #                             \___|\___/|_| \_\_____|
 #
-# Copyright (C) 2008 - 2022, Daniel Stenberg, <daniel@haxx.se>, et al.
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 #
 # This software is licensed as described in the file COPYING, which
 # you should have received as part of this distribution. The terms
@@ -47,7 +47,7 @@ def pytest_report_header(config):
         ])
     if env.has_vsftpd():
         report.extend([
-            f'  VsFTPD: {env.vsftpd_version()}, ftp:{env.ftp_port}'
+            f'  VsFTPD: {env.vsftpd_version()}, ftp:{env.ftp_port}, ftps:{env.ftps_port}'
         ])
     return '\n'.join(report)
 
diff --git a/tests/data/Makefile.inc b/tests/data/Makefile.inc
index ffb0b8e36..792cb16ee 100644
--- a/tests/data/Makefile.inc
+++ b/tests/data/Makefile.inc
@@ -73,7 +73,7 @@ test426 test427 test428 test429 test430 test431 test432 test433 test434 \
 test435 test436 test437 test438 test439 test440 test441 test442 test443 \
 test444 test445 test446 test447 test448 test449 test450 test451 test452 \
 test453 test454 test455 test456 test457 test458 test459 test460 test461 \
-test462 test463 test467 test468 test469 test470 test471 \
+test462 test463 test467 test468 test469 test470 test471 test472 test473 \
 \
 test490 test491 test492 test493 test494 test495 test496 test497 test498 \
 test499 test500 test501 test502 test503 test504 test505 test506 test507 \
@@ -126,7 +126,7 @@ test952 test953 test954 test955 test956 test957 test958 test959 test960 \
 test961 test962 test963 test964 test965 test966 test967 test968 test969 \
 test970 test971 test972 test973 test974 test975 test976 test977 test978 \
 test979 test980 test981 test982 test983 test984 test985 test986 test987 \
-test988 test989 test990 test991 test992 \
+test988 test989 test990 test991 test992 test993 \
 \
 test1000 test1001 test1002 test1003 test1004 test1005 test1006 test1007 \
 test1008 test1009 test1010 test1011 test1012 test1013 test1014 test1015 \
@@ -188,14 +188,15 @@ test1447 test1448 test1449 test1450 test1451 test1452 test1453 test1454 \
 test1455 test1456 test1457 test1458 test1459 test1460 test1461 test1462 \
 test1463 test1464 test1465 test1466 test1467 test1468 test1469 test1470 \
 test1471 test1472 test1473 test1474 test1475 test1476 test1477 test1478 \
-test1479 test1480 test1481 test1482 test1483 \
+test1479 test1480 test1481 test1482 test1483 test1484 test1485 test1486 \
+test1487 test1488 \
 \
 test1500 test1501 test1502 test1503 test1504 test1505 test1506 test1507 \
 test1508 test1509 test1510 test1511 test1512 test1513 test1514 test1515 \
 test1516 test1517 test1518 test1519 test1520 test1521 test1522 test1523 \
 test1524 test1525 test1526 test1527 test1528 test1529 test1530 test1531 \
 test1532 test1533 test1534 test1535 test1536 test1537 test1538 test1539 \
-test1540 test1541 test1542 test1543 test1544 test1545 \
+test1540 test1541 test1542 test1543 test1544 test1545 test1546 \
 \
 test1550 test1551 test1552 test1553 test1554 test1555 test1556 test1557 \
 test1558 test1559 test1560 test1561 test1562 test1563 test1564 test1565 \
@@ -210,14 +211,14 @@ test1620 test1621 \
 \
 test1630 test1631 test1632 test1633 test1634 test1635 \
 \
-test1650 test1651 test1652 test1653 test1654 test1655 \
-test1660 test1661 test1662 \
+test1650 test1651 test1652 test1653 test1654 test1655 test1656 \
+test1660 test1661 test1662 test1663 \
 \
 test1670 test1671 \
 \
 test1680 test1681 test1682 test1683 \
 \
-test1700 test1701 test1702 test1703 test1704 \
+test1700 test1701 test1702 test1703 test1704 test1705 test1706 \
 \
 test1800 test1801 \
 \
diff --git a/tests/data/test100 b/tests/data/test100
index de6a82bda..b7554383e 100644
--- a/tests/data/test100
+++ b/tests/data/test100
@@ -9,8 +9,6 @@ LIST
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
 <data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
diff --git a/tests/data/test101 b/tests/data/test101
index 26824c741..3febc5e72 100644
--- a/tests/data/test101
+++ b/tests/data/test101
@@ -8,9 +8,7 @@ LIST
 </info>
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -22,7 +20,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 # Client-side
diff --git a/tests/data/test1010 b/tests/data/test1010
index d1eee918a..d45efdc8a 100644
--- a/tests/data/test1010
+++ b/tests/data/test1010
@@ -9,9 +9,8 @@ LIST
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -19,11 +18,11 @@ drwxr-xr-x   2 98       98           512 May  2  1996 .NeXT
 -r--r--r--   1 0        1             35 Jul 16  1996 README
 lrwxrwxrwx   1 0        1              7 Dec  9  1999 bin -> usr/bin
 dr-xr-xr-x   2 0        1            512 Oct  1  1997 dev
-drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
+drwxrwxrwx   2 98       98           512 May 29 16:04 downthis.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test1034 b/tests/data/test1034
index 2a8170487..09a4dd5f3 100644
--- a/tests/data/test1034
+++ b/tests/data/test1034
@@ -23,7 +23,7 @@ config file
 none
 </server>
 <features>
-idn
+IDN
 http
 proxy
 </features>
diff --git a/tests/data/test1035 b/tests/data/test1035
index 1ace9428d..0bbaabf9c 100644
--- a/tests/data/test1035
+++ b/tests/data/test1035
@@ -21,7 +21,7 @@ FAILURE
 none
 </server>
 <features>
-idn
+IDN
 http
 proxy
 </features>
diff --git a/tests/data/test1044 b/tests/data/test1044
index 96a4f48c2..471f099a3 100644
--- a/tests/data/test1044
+++ b/tests/data/test1044
@@ -23,7 +23,7 @@ Largefile
 # Client-side
 <client>
 <features>
-large_file
+Largefile
 </features>
 <server>
 ftp
diff --git a/tests/data/test1046 b/tests/data/test1046
index c6bdcbb24..865fe1293 100644
--- a/tests/data/test1046
+++ b/tests/data/test1046
@@ -27,7 +27,7 @@ Content-Type: text/plain
 # Client-side
 <client>
 <features>
-ipv6
+IPv6
 </features>
 <server>
 http-ipv6
diff --git a/tests/data/test1047 b/tests/data/test1047
index d54a8494d..b863bd006 100644
--- a/tests/data/test1047
+++ b/tests/data/test1047
@@ -11,9 +11,7 @@ LIST
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -25,7 +23,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test1048 b/tests/data/test1048
index 56f19c4af..600e11faf 100644
--- a/tests/data/test1048
+++ b/tests/data/test1048
@@ -13,9 +13,7 @@ LIST
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -27,14 +25,14 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
 # Client-side
 <client>
 <features>
-ipv6
+IPv6
 </features>
 <server>
 ftp-ipv6
diff --git a/tests/data/test1050 b/tests/data/test1050
index ff179c637..e6dd82a32 100644
--- a/tests/data/test1050
+++ b/tests/data/test1050
@@ -10,9 +10,7 @@ EPRT
 
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -24,13 +22,13 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 # Client-side
 <client>
 <features>
-ipv6
+IPv6
 </features>
 <server>
 ftp-ipv6
diff --git a/tests/data/test1056 b/tests/data/test1056
index 40879662a..033c31f9f 100644
--- a/tests/data/test1056
+++ b/tests/data/test1056
@@ -48,7 +48,7 @@ body
 # test there. This feature doesn't work on msys or Cygwin, so use a precheck
 # to skip those.
 <features>
-ipv6
+IPv6
 !win32
 </features>
 <server>
diff --git a/tests/data/test1063 b/tests/data/test1063
index fcbc4b883..449263ef6 100644
--- a/tests/data/test1063
+++ b/tests/data/test1063
@@ -20,7 +20,7 @@ none
 </server>
 <features>
 file
-large_file
+Largefile
 </features>
 <name>
 Invalid large X- range on a file://
diff --git a/tests/data/test1083 b/tests/data/test1083
index 8728d6183..6757920f4 100644
--- a/tests/data/test1083
+++ b/tests/data/test1083
@@ -27,7 +27,7 @@ Content-Type: text/plain
 # Client-side
 <client>
 <features>
-ipv6
+IPv6
 </features>
 <server>
 http-ipv6
diff --git a/tests/data/test1085 b/tests/data/test1085
index b63b0f033..55eb00e06 100644
--- a/tests/data/test1085
+++ b/tests/data/test1085
@@ -20,7 +20,7 @@ non-existing host
 <client>
 <features>
 http
-ipv6
+IPv6
 </features>
 <server>
 none
diff --git a/tests/data/test1100 b/tests/data/test1100
index 1148a79f7..268f367f2 100644
--- a/tests/data/test1100
+++ b/tests/data/test1100
@@ -65,7 +65,7 @@ This is the final page !
 NTLM
 SSL
 !SSPI
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1149 b/tests/data/test1149
index 7686ef10b..d4e97d540 100644
--- a/tests/data/test1149
+++ b/tests/data/test1149
@@ -10,9 +10,7 @@ LIST
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -24,7 +22,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test1152 b/tests/data/test1152
index 490fde3b7..1823bab4a 100644
--- a/tests/data/test1152
+++ b/tests/data/test1152
@@ -13,8 +13,6 @@ LIST
 REPLY PWD 257 "just one
 </servercmd>
 
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
 <data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
diff --git a/tests/data/test1153 b/tests/data/test1153
index 36c76693a..a74b1838c 100644
--- a/tests/data/test1153
+++ b/tests/data/test1153
@@ -13,8 +13,6 @@ LIST
 REPLY PWD 257 "/""hello"""
 </servercmd>
 
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
 <data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
diff --git a/tests/data/test116 b/tests/data/test116
index 37aed2ceb..0ab00aae9 100644
--- a/tests/data/test116
+++ b/tests/data/test116
@@ -23,7 +23,7 @@ ftp
 </server>
 # EPRT is only sent when IPv6 is enabled
 <features>
-ipv6
+IPv6
 </features>
 <name>
 FTP download, failed PORT
diff --git a/tests/data/test1173 b/tests/data/test1173
index ff786c44b..89b0cb5a7 100644
--- a/tests/data/test1173
+++ b/tests/data/test1173
@@ -15,7 +15,7 @@ none
 </server>
 
 <name>
-Man page syntax checks
+Manpage syntax checks
 </name>
 
 <command type="perl">
diff --git a/tests/data/test1203 b/tests/data/test1203
index b4c70e9cb..267fc15cb 100644
--- a/tests/data/test1203
+++ b/tests/data/test1203
@@ -20,7 +20,7 @@ iMenu results		error.host	1
 # Client-side
 <client>
 <features>
-ipv6
+IPv6
 </features>
 <server>
 gopher-ipv6
diff --git a/tests/data/test1210 b/tests/data/test1210
index 4a07147f9..c8a3555cc 100644
--- a/tests/data/test1210
+++ b/tests/data/test1210
@@ -27,7 +27,7 @@ Content-Type: text/html
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1230 b/tests/data/test1230
index 5cdf1643f..fbcff6039 100644
--- a/tests/data/test1230
+++ b/tests/data/test1230
@@ -42,7 +42,7 @@ mooooooo
 # Client-side
 <client>
 <features>
-ipv6
+IPv6
 proxy
 </features>
 <server>
diff --git a/tests/data/test1268 b/tests/data/test1268
index 05fe9d8e7..15b15b56e 100644
--- a/tests/data/test1268
+++ b/tests/data/test1268
@@ -17,10 +17,10 @@ warning
 none
 </server>
 <features>
-unix-sockets
+UnixSockets
 </features>
 <name>
-file name argument looks like a flag
+filename argument looks like a flag
 </name>
 <command>
 --stderr %LOGDIR/moo%TESTNUMBER --unix-socket -k hej://moo
@@ -29,7 +29,7 @@ file name argument looks like a flag
 
 <verify>
 <file name="%LOGDIR/moo%TESTNUMBER" mode="text">
-Warning: The file name argument '-k' looks like a flag.
+Warning: The filename argument '-k' looks like a flag.
 curl: (1) Protocol "hej" not supported
 </file>
 
diff --git a/tests/data/test1294 b/tests/data/test1294
index 396f8a173..b16ecb142 100644
--- a/tests/data/test1294
+++ b/tests/data/test1294
@@ -30,7 +30,7 @@ Funny-head: yesyes
 <client>
 # hyper doesn't support the added crazy header
 <features>
-debug
+Debug
 !hyper
 </features>
 <server>
diff --git a/tests/data/test1295 b/tests/data/test1295
index e3692f5d6..5c963cae4 100644
--- a/tests/data/test1295
+++ b/tests/data/test1295
@@ -29,7 +29,7 @@ Funny-head: yesyes
 # Client-side
 <client>
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1296 b/tests/data/test1296
index 20dc26570..65fbdb2db 100644
--- a/tests/data/test1296
+++ b/tests/data/test1296
@@ -51,4 +51,3 @@ Accept: */*
 </protocol>
 </verify>
 </testcase>
-
diff --git a/tests/data/test130 b/tests/data/test130
index d6fed3367..2c4dfe85e 100644
--- a/tests/data/test130
+++ b/tests/data/test130
@@ -10,9 +10,8 @@ netrc
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -24,7 +23,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test131 b/tests/data/test131
index c48931175..4a73de285 100644
--- a/tests/data/test131
+++ b/tests/data/test131
@@ -10,10 +10,7 @@ netrc
 #
 # Server-side
 <reply>
-#
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -25,7 +22,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test1310 b/tests/data/test1310
index 12fdbb158..f3c1cfa3d 100644
--- a/tests/data/test1310
+++ b/tests/data/test1310
@@ -56,7 +56,7 @@ Finally, this is the real page!
 <client>
 <features>
 NTLM_WB
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1311 b/tests/data/test1311
index 8e48794a0..cc53489aa 100644
--- a/tests/data/test1311
+++ b/tests/data/test1311
@@ -28,7 +28,7 @@ Content-Disposition: filename=name%TESTNUMBER; charset=funny; option=strange
 # this relies on the debug feature to allow us to set directory to store the
 # -J output in
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1312 b/tests/data/test1312
index c8170a8af..6dfee1be5 100644
--- a/tests/data/test1312
+++ b/tests/data/test1312
@@ -28,7 +28,7 @@ Content-Disposition: inline; filename="name%TESTNUMBER;weird"
 # this relies on the debug feature to allow us to set directory to store the
 # -J output in
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1313 b/tests/data/test1313
index 8a2859744..ef7b17f45 100644
--- a/tests/data/test1313
+++ b/tests/data/test1313
@@ -28,7 +28,7 @@ Content-Disposition: inline; filename='name%TESTNUMBER
 # this relies on the debug feature to allow us to set directory to store the
 # -J output in
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1316 b/tests/data/test1316
index b6b8a1896..2218b6e14 100644
--- a/tests/data/test1316
+++ b/tests/data/test1316
@@ -19,15 +19,7 @@ Magic: sure you can FTP me
 
 </connect>
 
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
-HTTP/1.1 200 Mighty fine indeed
-Magic: sure you can FTP me
-
-HTTP/1.1 200 Mighty fine indeed
-Magic: sure you can FTP me
-
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -39,7 +31,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test132 b/tests/data/test132
index 8aa2f7906..77d47c8fd 100644
--- a/tests/data/test132
+++ b/tests/data/test132
@@ -10,9 +10,7 @@ netrc
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -24,7 +22,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test133 b/tests/data/test133
index c8d2f9039..4a2c46cde 100644
--- a/tests/data/test133
+++ b/tests/data/test133
@@ -10,9 +10,7 @@ netrc
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -24,7 +22,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test1334 b/tests/data/test1334
index 88a41d8b2..4c6d15b8c 100644
--- a/tests/data/test1334
+++ b/tests/data/test1334
@@ -26,7 +26,7 @@ Content-Type: text/html
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1335 b/tests/data/test1335
index 4d64ea877..6ae23eeab 100644
--- a/tests/data/test1335
+++ b/tests/data/test1335
@@ -26,7 +26,7 @@ Content-Type: text/html
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1336 b/tests/data/test1336
index 993d8c6f8..98579bf30 100644
--- a/tests/data/test1336
+++ b/tests/data/test1336
@@ -27,7 +27,7 @@ Content-Disposition: filename=name%TESTNUMBER; charset=funny; option=strange
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1337 b/tests/data/test1337
index 4b954d063..149fb2471 100644
--- a/tests/data/test1337
+++ b/tests/data/test1337
@@ -27,7 +27,7 @@ Content-Disposition: filename=name%TESTNUMBER; charset=funny; option=strange
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1338 b/tests/data/test1338
index c1c271a95..9241ca0bd 100644
--- a/tests/data/test1338
+++ b/tests/data/test1338
@@ -27,7 +27,7 @@ Content-Type: text/html
 # this relies on the debug feature to allow us to set directory to store the
 # -O and -J output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1339 b/tests/data/test1339
index a46934d3a..aed9307b5 100644
--- a/tests/data/test1339
+++ b/tests/data/test1339
@@ -27,7 +27,7 @@ Content-Type: text/html
 # this relies on the debug feature to allow us to set directory to store the
 # -O and -J output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test134 b/tests/data/test134
index d0716c3d1..207e4f5d4 100644
--- a/tests/data/test134
+++ b/tests/data/test134
@@ -10,9 +10,7 @@ netrc
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -24,7 +22,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test1340 b/tests/data/test1340
index ebec701a6..d2ac8f7a3 100644
--- a/tests/data/test1340
+++ b/tests/data/test1340
@@ -28,7 +28,7 @@ Content-Disposition: filename=name%TESTNUMBER; charset=funny; option=strange
 # this relies on the debug feature to allow us to set directory to store the
 # -O and -J output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1341 b/tests/data/test1341
index 75d9daae7..8e6feafde 100644
--- a/tests/data/test1341
+++ b/tests/data/test1341
@@ -28,7 +28,7 @@ Content-Disposition: filename=name%TESTNUMBER; charset=funny; option=strange
 # this relies on the debug feature to allow us to set directory to store the
 # -O and -J output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1342 b/tests/data/test1342
index 39dbfab57..3da479f05 100644
--- a/tests/data/test1342
+++ b/tests/data/test1342
@@ -26,7 +26,7 @@ Content-Type: text/html
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1343 b/tests/data/test1343
index 6a9eb7dc8..83a199874 100644
--- a/tests/data/test1343
+++ b/tests/data/test1343
@@ -26,7 +26,7 @@ Content-Type: text/html
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1344 b/tests/data/test1344
index ba4b38976..b0e9f960a 100644
--- a/tests/data/test1344
+++ b/tests/data/test1344
@@ -27,7 +27,7 @@ Content-Disposition: filename=name%TESTNUMBER; charset=funny; option=strange
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1345 b/tests/data/test1345
index a9298e4e2..456ec4970 100644
--- a/tests/data/test1345
+++ b/tests/data/test1345
@@ -27,7 +27,7 @@ Content-Disposition: filename=name%TESTNUMBER; charset=funny; option=strange
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1346 b/tests/data/test1346
index bab67cb63..13df57164 100644
--- a/tests/data/test1346
+++ b/tests/data/test1346
@@ -26,7 +26,7 @@ Content-Type: text/html
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1347 b/tests/data/test1347
index 868e2611c..0b7ec8266 100644
--- a/tests/data/test1347
+++ b/tests/data/test1347
@@ -27,7 +27,7 @@ Content-Disposition: filename=name%TESTNUMBER; charset=funny; option=strange
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1348 b/tests/data/test1348
index 3de0b4a93..73cb473d9 100644
--- a/tests/data/test1348
+++ b/tests/data/test1348
@@ -19,7 +19,7 @@ mooo
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 ftp
diff --git a/tests/data/test1349 b/tests/data/test1349
index d2565496c..4451dc37e 100644
--- a/tests/data/test1349
+++ b/tests/data/test1349
@@ -19,7 +19,7 @@ mooo
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 ftp
diff --git a/tests/data/test1350 b/tests/data/test1350
index b5568f536..7f4b5a60f 100644
--- a/tests/data/test1350
+++ b/tests/data/test1350
@@ -19,7 +19,7 @@ mooo
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 ftp
diff --git a/tests/data/test1351 b/tests/data/test1351
index 93232d55c..b876bbd35 100644
--- a/tests/data/test1351
+++ b/tests/data/test1351
@@ -20,7 +20,7 @@ mooo
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 ftp
diff --git a/tests/data/test1352 b/tests/data/test1352
index 0649289b6..53689b6a7 100644
--- a/tests/data/test1352
+++ b/tests/data/test1352
@@ -20,7 +20,7 @@ mooo
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 ftp
diff --git a/tests/data/test1353 b/tests/data/test1353
index 8e0ad50e4..be501618c 100644
--- a/tests/data/test1353
+++ b/tests/data/test1353
@@ -19,7 +19,7 @@ mooo
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 ftp
diff --git a/tests/data/test1354 b/tests/data/test1354
index 506ec90e4..ba5cba780 100644
--- a/tests/data/test1354
+++ b/tests/data/test1354
@@ -19,7 +19,7 @@ mooo
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 ftp
diff --git a/tests/data/test1355 b/tests/data/test1355
index fa19fabc4..32c9d8baf 100644
--- a/tests/data/test1355
+++ b/tests/data/test1355
@@ -19,7 +19,7 @@ mooo
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 ftp
diff --git a/tests/data/test1356 b/tests/data/test1356
index 0c326f48c..2a156628d 100644
--- a/tests/data/test1356
+++ b/tests/data/test1356
@@ -27,7 +27,7 @@ MOOOO
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 ftp
diff --git a/tests/data/test1357 b/tests/data/test1357
index 9d395a875..371d8c619 100644
--- a/tests/data/test1357
+++ b/tests/data/test1357
@@ -27,7 +27,7 @@ MOOOO
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 ftp
diff --git a/tests/data/test1358 b/tests/data/test1358
index 973ef7cf4..bd0b382a8 100644
--- a/tests/data/test1358
+++ b/tests/data/test1358
@@ -27,7 +27,7 @@ MOOOO
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 ftp
diff --git a/tests/data/test1359 b/tests/data/test1359
index fc1eb3728..bc29dd8c8 100644
--- a/tests/data/test1359
+++ b/tests/data/test1359
@@ -28,7 +28,7 @@ MOOOO
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 ftp
diff --git a/tests/data/test1360 b/tests/data/test1360
index 1fb80eecd..70e8053ba 100644
--- a/tests/data/test1360
+++ b/tests/data/test1360
@@ -28,7 +28,7 @@ MOOOO
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 ftp
diff --git a/tests/data/test1361 b/tests/data/test1361
index 6b9af1ad8..6b9c566a7 100644
--- a/tests/data/test1361
+++ b/tests/data/test1361
@@ -27,7 +27,7 @@ MOOOO
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 ftp
diff --git a/tests/data/test1362 b/tests/data/test1362
index 03d99047b..41f7b4dfa 100644
--- a/tests/data/test1362
+++ b/tests/data/test1362
@@ -27,7 +27,7 @@ MOOOO
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 ftp
diff --git a/tests/data/test1363 b/tests/data/test1363
index 009f68cae..e5344f045 100644
--- a/tests/data/test1363
+++ b/tests/data/test1363
@@ -27,7 +27,7 @@ MOOOO
 # this relies on the debug feature to allow us to set directory to store the
 # -O output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 </features>
 <server>
 ftp
diff --git a/tests/data/test1408 b/tests/data/test1408
index 925be875b..5c7f6493d 100644
--- a/tests/data/test1408
+++ b/tests/data/test1408
@@ -40,7 +40,7 @@ Set-Cookie: time=2
 <client>
 <features>
 cookies
-ipv6
+IPv6
 </features>
 <server>
 http-ipv6
diff --git a/tests/data/test1422 b/tests/data/test1422
index c62c2cbda..a865b5e53 100644
--- a/tests/data/test1422
+++ b/tests/data/test1422
@@ -27,7 +27,7 @@ Content-Disposition: filename=name%TESTNUMBER; charset=funny; option=str//nge
 # this relies on the debug feature to allow us to set directory to store the
 # -O and -J output in, using the CURL_TESTDIR variable
 <features>
-debug
+Debug
 file
 </features>
 <server>
diff --git a/tests/data/test1425 b/tests/data/test1425
index f51483dd0..4e13dbef8 100644
Binary files a/tests/data/test1425 and b/tests/data/test1425 differ
diff --git a/tests/data/test1426 b/tests/data/test1426
index d53138afa..792cc4bab 100644
Binary files a/tests/data/test1426 and b/tests/data/test1426 differ
diff --git a/tests/data/test1435 b/tests/data/test1435
index 0e1e34f55..321ea4c02 100644
--- a/tests/data/test1435
+++ b/tests/data/test1435
@@ -3,7 +3,7 @@
 <keywords>
 HTTP
 HTTP GET
-unix sockets
+UnixSockets
 </keywords>
 </info>
 
@@ -19,7 +19,7 @@ Based on test300
 
 <client>
 <features>
-unix-sockets
+UnixSockets
 </features>
 <server>
 http-unix
diff --git a/tests/data/test1436 b/tests/data/test1436
index 352ef34e0..f82384e58 100644
--- a/tests/data/test1436
+++ b/tests/data/test1436
@@ -3,7 +3,7 @@
 <keywords>
 HTTP
 HTTP GET
-unix sockets
+UnixSockets
 </keywords>
 </info>
 
@@ -33,7 +33,7 @@ Third
 
 <client>
 <features>
-unix-sockets
+UnixSockets
 </features>
 <server>
 http-unix
diff --git a/tests/data/test1443 b/tests/data/test1443
index bbfaf7f1b..aaeb448e1 100644
--- a/tests/data/test1443
+++ b/tests/data/test1443
@@ -28,7 +28,7 @@ Connection: close
 # This relies on the debug feature to allow us to set a directory
 # in which to store the -O output
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1448 b/tests/data/test1448
index 6a9ba5212..1544d3936 100644
--- a/tests/data/test1448
+++ b/tests/data/test1448
@@ -39,7 +39,7 @@ OK
 http
 </server>
 <features>
-idn
+IDN
 </features>
 <setenv>
 LC_ALL=en_US.UTF-8
diff --git a/tests/data/test1454 b/tests/data/test1454
index 4908a178d..dff914b11 100644
--- a/tests/data/test1454
+++ b/tests/data/test1454
@@ -14,7 +14,7 @@
 # Client-side
 <client>
 <features>
-!ipv6
+!IPv6
 </features>
 <server>
 http
diff --git a/tests/data/test1456 b/tests/data/test1456
index 3f3a74783..d846b41eb 100644
--- a/tests/data/test1456
+++ b/tests/data/test1456
@@ -31,7 +31,7 @@ These data aren't actually sent to the client
 # Client-side
 <client>
 <features>
-ipv6
+IPv6
 </features>
 <server>
 http-ipv6
diff --git a/tests/data/test1459 b/tests/data/test1459
index c05da3cb5..6aab50003 100644
--- a/tests/data/test1459
+++ b/tests/data/test1459
@@ -45,4 +45,3 @@ disable
 </valgrind>
 </verify>
 </testcase>
-
diff --git a/tests/data/test1460 b/tests/data/test1460
index c3180ff92..4e85082e3 100644
--- a/tests/data/test1460
+++ b/tests/data/test1460
@@ -25,7 +25,7 @@ Content-Disposition: filename=name%TESTNUMBER; charset=funny; option=strange
 # this relies on the debug feature to allow us to set directory to store the
 # -J output in
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1461 b/tests/data/test1461
index 424af943f..669e5fbf4 100644
--- a/tests/data/test1461
+++ b/tests/data/test1461
@@ -45,8 +45,11 @@ Usage: curl [options...] <url>
  -v, --verbose               Make the operation more talkative
  -V, --version               Show version number and quit
 
-This is not the full help, this menu is stripped into categories.
-Use "--help category" to get an overview of all categories.
+This is not the full help; this menu is split into categories.
+Use "--help category" to get an overview of all categories, which are:
+auth, connection, curl, deprecated, dns, file, ftp, global, http, imap, ldap, 
+output, pop3, post, proxy, scp, sftp, smtp, ssh, telnet, tftp, timeout, tls, 
+upload, verbose.
 For all options use the manual or "--help all".
 </stdout>
 </verify>
diff --git a/tests/data/test1462 b/tests/data/test1462
index a914f305a..572b1dd4b 100644
--- a/tests/data/test1462
+++ b/tests/data/test1462
@@ -32,31 +32,33 @@ curl invalid category --help
 </errorcode>
 <stdout mode="text">
 Usage: curl [options...] <url>
-Invalid category provided, here is a list of all categories:
+Unknown category provided, here is a list of all categories:
 
- auth        Different types of authentication methods
- connection  Low level networking operations
+ auth        Authentication methods
+ connection  Manage connections
  curl        The command line tool itself
- dns         General DNS options
- file        FILE protocol options
- ftp         FTP protocol options
- http        HTTP and HTTPS protocol options
- imap        IMAP protocol options
- misc        Options that don't fit into any other category
+ deprecated  Legacy
+ dns         Names and resolving
+ file        FILE protocol
+ ftp         FTP protocol
+ global      Global options
+ http        HTTP and HTTPS protocol
+ imap        IMAP protocol
+ ldap        LDAP protocol
  output      Filesystem output
- pop3        POP3 protocol options
- post        HTTP Post specific options
- proxy       All options related to proxies
- scp         SCP protocol options
- sftp        SFTP protocol options
- smtp        SMTP protocol options
- ssh         SSH protocol options
- telnet      TELNET protocol options
- tftp        TFTP protocol options
- tls         All TLS/SSL related options
- ech         All Encrypted Client Hello (ECH) options
- upload      All options for uploads
- verbose     Options related to any kind of command line output of curl
+ pop3        POP3 protocol
+ post        HTTP POST specific
+ proxy       Options for proxies
+ scp         SCP protocol
+ sftp        SFTP protocol
+ smtp        SMTP protocol
+ ssh         SSH protocol
+ telnet      TELNET protocol
+ tftp        TFTP protocol
+ timeout     Timeouts and delays
+ tls         TLS/SSL related
+ upload      Upload, sending data
+ verbose     Tracing, logging etc
 </stdout>
 </verify>
 </testcase>
diff --git a/tests/data/test1463 b/tests/data/test1463
index 68b3e4fb0..a916cb4df 100644
--- a/tests/data/test1463
+++ b/tests/data/test1463
@@ -36,7 +36,7 @@ curl file category --help
 </errorcode>
 <stdout mode="text">
 Usage: curl [options...] <url>
-file: FILE protocol options
+file: FILE protocol
      --create-file-mode <mode>  File mode for created files
  -I, --head                     Show document info only
  -l, --list-only                List only mode
diff --git a/tests/data/test1464 b/tests/data/test1464
index 186c6ee02..ccdb56d1a 100644
--- a/tests/data/test1464
+++ b/tests/data/test1464
@@ -36,7 +36,7 @@ curl file category --help with lower/upper mix
 </errorcode>
 <stdout mode="text">
 Usage: curl [options...] <url>
-file: FILE protocol options
+file: FILE protocol
      --create-file-mode <mode>  File mode for created files
  -I, --head                     Show document info only
  -l, --list-only                List only mode
diff --git a/tests/data/test1467 b/tests/data/test1467
index bf6ed8f38..e160a1625 100644
--- a/tests/data/test1467
+++ b/tests/data/test1467
@@ -4,7 +4,7 @@
 HTTP
 HTTP GET
 SOCKS5
-unix sockets
+UnixSockets
 </keywords>
 </info>
 
@@ -32,7 +32,7 @@ Funny-head: yesyes
 <client>
 <features>
 proxy
-unix-sockets
+UnixSockets
 </features>
 <server>
 http
diff --git a/tests/data/test1468 b/tests/data/test1468
index dad25df12..49748d119 100644
--- a/tests/data/test1468
+++ b/tests/data/test1468
@@ -5,7 +5,7 @@ HTTP
 HTTP GET
 SOCKS5
 SOCKS5h
-unix sockets
+UnixSockets
 </keywords>
 </info>
 
@@ -33,7 +33,7 @@ Funny-head: yesyes
 <client>
 <features>
 proxy
-unix-sockets
+UnixSockets
 </features>
 <server>
 http
diff --git a/tests/data/test1470 b/tests/data/test1470
index ad4fb711a..c5d74ae65 100644
--- a/tests/data/test1470
+++ b/tests/data/test1470
@@ -6,7 +6,7 @@ HTTP
 HTTP GET
 SOCKS5
 SOCKS5h
-unix sockets
+UnixSockets
 </keywords>
 </info>
 
@@ -34,7 +34,7 @@ Funny-head: yesyes
 <client>
 <features>
 proxy
-unix-sockets
+UnixSockets
 </features>
 <server>
 https
diff --git a/tests/data/test1484 b/tests/data/test1484
new file mode 100644
index 000000000..52de029a0
--- /dev/null
+++ b/tests/data/test1484
@@ -0,0 +1,53 @@
+<testcase>
+<info>
+<keywords>
+HTTP
+HTTP HEAD
+</keywords>
+</info>
+
+#
+# Server-side
+<reply>
+<data>
+HTTP/1.1 200 OK
+Date: Tue, 09 Nov 2010 14:49:00 GMT
+Transfer-Encoding: chunked
+
+HEAD response with content
+</data>
+# make sure no data is written
+<datacheck>
+HTTP/1.1 200 OK
+Date: Tue, 09 Nov 2010 14:49:00 GMT
+Transfer-Encoding: chunked
+
+</datacheck>
+</reply>
+
+#
+# Client-side
+<client>
+<server>
+http
+</server>
+<name>
+HTTP HEAD with response body to ignore
+</name>
+<command>
+-I http://%HOSTIP:%HTTPPORT/%TESTNUMBER --http1.1
+</command>
+</client>
+
+#
+# Verify data after the test has been "shot"
+<verify>
+<protocol>
+HEAD /%TESTNUMBER HTTP/1.1
+Host: %HOSTIP:%HTTPPORT
+User-Agent: curl/%VERSION
+Accept: */*
+
+</protocol>
+</verify>
+</testcase>
diff --git a/tests/data/test1485 b/tests/data/test1485
new file mode 100644
index 000000000..d89362f46
--- /dev/null
+++ b/tests/data/test1485
@@ -0,0 +1,51 @@
+<testcase>
+<info>
+<keywords>
+HTTP
+HTTP GET
+</keywords>
+</info>
+
+# Server-side
+<reply>
+<data>
+HTTP/1.1 200 OK
+Server: Someone
+Content-Length: 7
+
+123456
+</data>
+<datacheck>
+HTTP/1.1 200 OK
+Server: Someone
+Content-Length: 7
+
+123456
+</datacheck>
+</reply>
+# Client-side
+<client>
+<server>
+http
+</server>
+<tool>
+lib%TESTNUMBER
+</tool>
+<name>
+get curlinfo on last header in callback
+</name>
+<command>
+http://%HOSTIP:%HTTPPORT/%TESTNUMBER
+</command>
+</client>
+
+# Verify data after the test has been "shot"
+<verify>
+<protocol>
+GET /%TESTNUMBER HTTP/1.1
+Host: %HOSTIP:%HTTPPORT
+Accept: */*
+
+</protocol>
+</verify>
+</testcase>
diff --git a/tests/data/test1486 b/tests/data/test1486
new file mode 100644
index 000000000..e974b99e0
--- /dev/null
+++ b/tests/data/test1486
@@ -0,0 +1,32 @@
+<testcase>
+<info>
+<keywords>
+source analysis
+docs
+--write-out
+</keywords>
+</info>
+
+#
+# Client-side
+<client>
+<server>
+none
+</server>
+
+<name>
+Verify that write-out.md and tool_writeout.c are in sync
+</name>
+
+<command type="perl">
+%SRCDIR/test1486.pl %SRCDIR
+</command>
+</client>
+
+<verify>
+<stdout>
+OK
+</stdout>
+</verify>
+
+</testcase>
diff --git a/tests/data/test1487 b/tests/data/test1487
new file mode 100644
index 000000000..33a92b614
--- /dev/null
+++ b/tests/data/test1487
@@ -0,0 +1,62 @@
+<testcase>
+<info>
+<keywords>
+HTTP
+HTTP GET
+-J
+</keywords>
+</info>
+
+#
+<reply>
+<data nocheck="yes">
+HTTP/1.1 301 OK
+Date: Tue, 09 Nov 2010 14:49:00 GMT
+Server: test-server/fake
+Content-Length: 6
+Connection: close
+Content-Type: text/html
+Content-Disposition: filename=name%TESTNUMBER; charset=funny; option=strange
+
+12345
+</data>
+</reply>
+
+#
+# Client-side
+<client>
+# this relies on the debug feature to allow us to set directory to store the
+# -J output in
+<features>
+Debug
+</features>
+<server>
+http
+</server>
+<name>
+HTTP GET with -J and Content-Disposition on 301
+</name>
+<setenv>
+CURL_TESTDIR=%LOGDIR
+</setenv>
+<command option="no-output,no-include">
+http://%HOSTIP:%HTTPPORT/%TESTNUMBER -J -O
+</command>
+</client>
+
+#
+# Verify data after the test has been "shot"
+<verify>
+<protocol>
+GET /%TESTNUMBER HTTP/1.1
+Host: %HOSTIP:%HTTPPORT
+User-Agent: curl/%VERSION
+Accept: */*
+
+</protocol>
+<file name="%LOGDIR/name%TESTNUMBER">
+12345
+</file>
+
+</verify>
+</testcase>
diff --git a/tests/data/test1488 b/tests/data/test1488
new file mode 100644
index 000000000..f987e151d
--- /dev/null
+++ b/tests/data/test1488
@@ -0,0 +1,31 @@
+<testcase>
+<info>
+<keywords>
+documentation
+symbols-in-versions
+manpages
+</keywords>
+</info>
+
+#
+# Client-side
+<client>
+<server>
+none
+</server>
+
+<name>
+symbols-in-versions and manpages agree on added-in versions
+</name>
+
+<command type="perl">
+%SRCDIR/test1488.pl %SRCDIR/.. ../include/curl
+</command>
+</client>
+
+<verify>
+<stdout>
+OK
+</stdout>
+</verify>
+</testcase>
diff --git a/tests/data/test1538 b/tests/data/test1538
index 7abbc555b..111f2d8da 100644
--- a/tests/data/test1538
+++ b/tests/data/test1538
@@ -37,9 +37,9 @@ e1: Unsupported protocol
 e2: Failed initialization
 e3: URL using bad/illegal format or missing URL
 e4: A requested feature, protocol or option was not found built-in in this libcurl due to a build-time decision.
-e5: Couldn't resolve proxy name
-e6: Couldn't resolve host name
-e7: Couldn't connect to server
+e5: Could not resolve proxy name
+e6: Could not resolve hostname
+e7: Could not connect to server
 e8: Weird server reply
 e9: Access denied to remote resource
 e10: FTP: The server failed to connect to data port
@@ -47,11 +47,11 @@ e11: FTP: unknown PASS reply
 e12: FTP: Accepting server connect has timed out
 e13: FTP: unknown PASV reply
 e14: FTP: unknown 227 response format
-e15: FTP: can't figure out the host in the PASV response
+e15: FTP: cannot figure out the host in the PASV response
 e16: Error in the HTTP2 framing layer
-e17: FTP: couldn't set file type
+e17: FTP: could not set file type
 e18: Transferred a partial file
-e19: FTP: couldn't retrieve (RETR failed) the specified file
+e19: FTP: could not retrieve (RETR failed) the specified file
 e20: Unknown error
 e21: Quote command returned error
 e22: HTTP response code said error
@@ -68,8 +68,8 @@ e32: Unknown error
 e33: Requested range was not delivered by the server
 e34: Internal problem setting up the POST
 e35: SSL connect error
-e36: Couldn't resume download
-e37: Couldn't read a file:// file
+e36: Could not resume download
+e37: Could not read a file:// file
 e38: LDAP: cannot bind
 e39: LDAP: search failed
 e40: Unknown error
@@ -91,7 +91,7 @@ e55: Failed sending data to the peer
 e56: Failure when receiving data from the peer
 e57: Unknown error
 e58: Problem with the local SSL certificate
-e59: Couldn't use specified SSL cipher
+e59: Could not use specified SSL cipher
 e60: SSL peer certificate or SSH remote key was not OK
 e61: Unrecognized or bad HTTP Content or Transfer-Encoding
 e62: Unknown error
diff --git a/tests/data/test1542 b/tests/data/test1542
index f9806cda8..0454d76dd 100644
--- a/tests/data/test1542
+++ b/tests/data/test1542
@@ -58,11 +58,11 @@ Accept: */*
 == Info: Connection #0 to host %HOSTIP left intact
 == Info: Connection #0 to host %HOSTIP left intact
 == Info: Connection #0 to host %HOSTIP left intact
-== Info: Closing connection
+== Info: shutting down connection #0
 == Info: Connection #1 to host %HOSTIP left intact
 </file>
 <stripfile>
-$_ = '' if (($_ !~ /left intact/) && ($_ !~ /Closing connection/))
+$_ = '' if (($_ !~ /left intact/) && ($_ !~ /(closing|shutting down) connection #\d+/))
 </stripfile>
 </verify>
 </testcase>
diff --git a/tests/data/test1546 b/tests/data/test1546
new file mode 100644
index 000000000..0ec7093f7
--- /dev/null
+++ b/tests/data/test1546
@@ -0,0 +1,63 @@
+<testcase>
+<info>
+<keywords>
+HTTP
+HTTP GET
+Transfer-Encoding
+</keywords>
+</info>
+#
+# Server-side
+<reply>
+<data>
+HTTP/1.1 200 OK
+Date: Mon, 29 Nov 2004 21:56:53 GMT
+Server: Apache
+Transfer-Encoding: chunked, gzip
+
+0
+
+</data>
+
+<datacheck>
+HTTP/1.1 200 OK
+Date: Mon, 29 Nov 2004 21:56:53 GMT
+Server: Apache
+</datacheck>
+
+</reply>
+
+#
+# Client-side
+<client>
+<features>
+libz
+</features>
+<server>
+http
+</server>
+<name>
+HTTP transfer-encoding wrong order
+</name>
+<command>
+http://%HOSTIP:%HTTPPORT/%TESTNUMBER --tr-encoding
+</command>
+</client>
+
+#
+# Verify data after the test has been "shot"
+<verify>
+<protocol>
+GET /%TESTNUMBER HTTP/1.1
+Host: %HOSTIP:%HTTPPORT
+User-Agent: curl/%VERSION
+Accept: */*
+Connection: TE
+TE: gzip
+
+</protocol>
+<errorcode>
+61
+</errorcode>
+</verify>
+</testcase>
diff --git a/tests/data/test159 b/tests/data/test159
index fabcb4f98..887c4795f 100644
--- a/tests/data/test159
+++ b/tests/data/test159
@@ -45,7 +45,7 @@ This is not the real page either!
 NTLM
 SSL
 !SSPI
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test165 b/tests/data/test165
index d0353946a..e9237d89c 100644
--- a/tests/data/test165
+++ b/tests/data/test165
@@ -28,7 +28,7 @@ Funny-head: yesyes
 http
 </server>
 <features>
-idn
+IDN
 proxy
 </features>
 <setenv>
diff --git a/tests/data/test1656 b/tests/data/test1656
new file mode 100644
index 000000000..2fab21be6
--- /dev/null
+++ b/tests/data/test1656
@@ -0,0 +1,22 @@
+<testcase>
+<info>
+<keywords>
+unittest
+Curl_x509_GTime2str
+</keywords>
+</info>
+
+#
+# Client-side
+<client>
+<server>
+none
+</server>
+<features>
+unittest
+</features>
+<name>
+Curl_x509_GTime2str unit tests
+</name>
+</client>
+</testcase>
diff --git a/tests/data/test1662 b/tests/data/test1662
index b2fbcce8b..7e72add94 100644
--- a/tests/data/test1662
+++ b/tests/data/test1662
@@ -38,7 +38,7 @@ Funny-head: nono
 <client>
 <features>
 Mime
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test1663 b/tests/data/test1663
new file mode 100644
index 000000000..160bfde3f
--- /dev/null
+++ b/tests/data/test1663
@@ -0,0 +1,23 @@
+<testcase>
+<info>
+<keywords>
+unittest
+interface
+bind
+</keywords>
+</info>
+
+#
+# Client-side
+<client>
+<server>
+none
+</server>
+<features>
+unittest
+</features>
+<name>
+unit tests for interface option parsing
+</name>
+</client>
+</testcase>
diff --git a/tests/data/test1705 b/tests/data/test1705
new file mode 100644
index 000000000..af2263da3
--- /dev/null
+++ b/tests/data/test1705
@@ -0,0 +1,302 @@
+<testcase>
+<info>
+<keywords>
+script
+documentation
+managen
+</keywords>
+</info>
+
+#
+# Client-side
+<client>
+<server>
+none
+</server>
+
+<name>
+managen makes manpage
+</name>
+
+<file name="%LOGDIR/mainpage.idx">
+_header.md
+%options
+_footer.md
+</file>
+
+<file1 name="%LOGDIR/_header.md">
+<!-- Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al. -->
+<!-- SPDX-License-Identifier: curl -->
+# DESCRIPTION
+
+**curl** is a tool for transferring data from or to a server using URLs. It
+supports these protocols: DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS,
+IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP,
+SMB, SMBS, SMTP, SMTPS, TELNET, TFTP, WS and WSS.
+
+curl is powered by libcurl for all transfer-related features. See
+*libcurl(3)* for details.
+</file1>
+<file2 name="%LOGDIR/option1.md">
+---
+c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+SPDX-License-Identifier: curl
+Short: v
+Long: fakeitreal
+Mutexed: trace trace-ascii
+Help: Make the operation more talkative
+Category: important verbose global
+Added: 4.0
+Multi: boolean
+Scope: global
+See-also:
+  - include
+  - silent
+  - trace
+  - trace-ascii
+Example:
+  - --verbose $URL
+---
+
+# `--verbose`
+
+Makes curl verbose during the operation. Useful for debugging and seeing
+what's going on under the hood. A line starting with \> means header data sent
+by curl, \< means header data received by curl that is hidden in normal cases,
+and a line starting with * means additional info provided by curl.
+
+If you only want HTTP headers in the output, --include or --dump-header might
+be more suitable options.
+
+If you think this option still does not give you enough details, consider using
+--trace or --trace-ascii instead.
+
+Note that verbose output of curl activities and network traffic might contain
+sensitive data, including usernames, credentials or secret data content. Be
+aware and be careful when sharing trace logs with others.
+
+End with a quote
+
+    hello
+</file2>
+<file3 name="%LOGDIR/option2.md">
+---
+c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+SPDX-License-Identifier: curl
+Long: proto
+Arg: <protocols>
+Help: Enable/disable PROTOCOLS
+Added: 7.20.2
+Category: connection curl
+Multi: single
+See-also:
+  - fakeitreal
+  - proto-default
+Example:
+  - --proto =http,https,sftp $URL
+---
+
+# `--proto`
+
+Limit what protocols to allow for transfers. Protocols are evaluated left to
+right, are comma separated, and are each a protocol name or 'all', optionally
+prefixed by zero or more modifiers. Available modifiers are:
+
+## +
+Permit this protocol in addition to protocols already permitted (this is
+the default if no modifier is used).
+
+## -
+Deny this protocol, removing it from the list of protocols already permitted.
+
+## =
+Permit only this protocol (ignoring the list already permitted), though
+subject to later modification by subsequent entries in the comma separated
+list.
+
+##
+
+For example: --proto -ftps uses the default protocols, but disables ftps
+
+--proto -all,https,+http only enables http and https
+
+--proto =http,https also only enables http and https
+
+Unknown and disabled protocols produce a warning. This allows scripts to
+safely rely on being able to disable potentially dangerous protocols, without
+relying upon support for that protocol being built into curl to avoid an error.
+
+This option can be used multiple times, in which case the effect is the same
+as concatenating the protocols into one instance of the option.
+</file3>
+<file4 name="%LOGDIR/_footer.md">
+<!-- Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al. -->
+<!-- SPDX-License-Identifier: curl -->
+# PROXY PROTOCOL PREFIXES
+The proxy string may be specified with a protocol:// prefix to specify
+alternative proxy protocols. (Added in 7.21.7)
+
+If no protocol is specified in the proxy string or if the string does not
+match a supported one, the proxy is treated as an HTTP proxy.
+
+The supported proxy protocol prefixes are as follows:
+## http://
+Makes it use it as an HTTP proxy. The default if no scheme prefix is used.
+## https://
+Makes it treated as an **HTTPS** proxy.
+## socks4://
+Makes it the equivalent of --socks4
+## socks4a://
+Makes it the equivalent of --socks4a
+## socks5://
+Makes it the equivalent of --socks5
+## socks5h://
+Makes it the equivalent of --socks5-hostname
+</file4>
+
+<command type="perl">
+%SRCDIR/../scripts/managen -d %LOGDIR -I %SRCDIR/../include mainpage option1.md option2.md
+</command>
+</client>
+
+<verify>
+<stderr>
+option1.md:19:1:WARN: see-also a non-existing option: include
+option1.md:19:1:WARN: see-also a non-existing option: silent
+option1.md:19:1:WARN: see-also a non-existing option: trace
+option1.md:19:1:WARN: see-also a non-existing option: trace-ascii
+WARN: option1.md mutexes a non-existing option: trace
+WARN: option1.md mutexes a non-existing option: trace-ascii
+option2.md:15:1:WARN: see-also a non-existing option: proto-default
+</stderr>
+<stdout>
+.\" **************************************************************************
+.\" *                                  _   _ ____  _
+.\" *  Project                     ___| | | |  _ \| |
+.\" *                             / __| | | | |_) | |
+.\" *                            | (__| |_| |  _ <| |___
+.\" *                             \___|\___/|_| \_\_____|
+.\" *
+.\" * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+.\" *
+.\" * This software is licensed as described in the file COPYING, which
+.\" * you should have received as part of this distribution. The terms
+.\" * are also available at https://curl.se/docs/copyright.html.
+.\" *
+.\" * You may opt to use, copy, modify, merge, publish, distribute and/or sell
+.\" * copies of the Software, and permit persons to whom the Software is
+.\" * furnished to do so, under the terms of the COPYING file.
+.\" *
+.\" * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+.\" * KIND, either express or implied.
+.\" *
+.\" * SPDX-License-Identifier: curl
+.\" *
+.\" **************************************************************************
+.\"
+.\" DO NOT EDIT. Generated by the curl project managen manpage generator.
+.\"
+.TH curl 1 "%DATE" "curl %VERNUM" "curl Manual"
+.SH DESCRIPTION
+\fBcurl\fP is a tool for transferring data from or to a server using URLs. It
+supports these protocols: DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS,
+IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP,
+SMB, SMBS, SMTP, SMTPS, TELNET, TFTP, WS and WSS.
+
+curl is powered by libcurl for all transfer\-related features. See
+\fIlibcurl(3)\fP for details.
+.IP "\-v, \-\-fakeitreal"
+Makes curl verbose during the operation. Useful for debugging and seeing
+what\(aqs going on under the hood. A line starting with > means header data sent
+by curl, < means header data received by curl that is hidden in normal cases,
+and a line starting with * means additional info provided by curl.
+
+If you only want HTTP headers in the output, \fI\-\-include\fP or \fI\-\-dump\-header\fP might
+be more suitable options.
+
+If you think this option still does not give you enough details, consider using
+\fI\-\-trace\fP or \fI\-\-trace\-ascii\fP instead.
+
+Note that verbose output of curl activities and network traffic might contain
+sensitive data, including usernames, credentials or secret data content. Be
+aware and be careful when sharing trace logs with others.
+
+End with a quote
+.nf
+
+hello
+.fi
+
+This option is global and does not need to be specified for each use of --next.
+
+Providing --fakeitreal multiple times has no extra effect.
+Disable it again with \-\-no-fakeitreal.
+
+Example:
+.nf
+ curl --verbose https://example.com
+.fi
+
+This option is mutually exclusive with \fI\-\-trace\fP and \fI\-\-trace\-ascii\fP.
+See also \fI\-\-include\fP, \fI\-\-silent\fP, \fI\-\-trace\fP and \fI\-\-trace\-ascii\fP.
+.IP "\-\-proto <protocols>"
+Limit what protocols to allow for transfers. Protocols are evaluated left to
+right, are comma separated, and are each a protocol name or \(aqall\(aq, optionally
+prefixed by zero or more modifiers. Available modifiers are:
+.RS
+.IP +
+Permit this protocol in addition to protocols already permitted (this is
+the default if no modifier is used).
+.IP -
+Deny this protocol, removing it from the list of protocols already permitted.
+.IP =
+Permit only this protocol (ignoring the list already permitted), though
+subject to later modification by subsequent entries in the comma separated
+list.
+.RE
+.IP
+For example: \fI\-\-proto\fP \-ftps uses the default protocols, but disables ftps
+
+\fI\-\-proto\fP \-all,https,+http only enables http and https
+
+\fI\-\-proto\fP =http,https also only enables http and https
+
+Unknown and disabled protocols produce a warning. This allows scripts to
+safely rely on being able to disable potentially dangerous protocols, without
+relying upon support for that protocol being built into curl to avoid an error.
+
+This option can be used multiple times, in which case the effect is the same
+as concatenating the protocols into one instance of the option.
+
+If --proto is provided several times, the last set value is used.
+
+Example:
+.nf
+ curl --proto =http,https,sftp https://example.com
+.fi
+
+See also \fI-v, \-\-fakeitreal\fP and \fI\-\-proto\-default\fP.
+.SH PROXY PROTOCOL PREFIXES
+The proxy string may be specified with a protocol:// prefix to specify
+alternative proxy protocols.
+
+If no protocol is specified in the proxy string or if the string does not
+match a supported one, the proxy is treated as an HTTP proxy.
+
+The supported proxy protocol prefixes are as follows:
+.IP http://
+Makes it use it as an HTTP proxy. The default if no scheme prefix is used.
+.IP https://
+Makes it treated as an \fBHTTPS\fP proxy.
+.IP socks4://
+Makes it the equivalent of \fI\-\-socks4\fP
+.IP socks4a://
+Makes it the equivalent of \fI\-\-socks4a\fP
+.IP socks5://
+Makes it the equivalent of \fI\-\-socks5\fP
+.IP socks5h://
+Makes it the equivalent of \fI\-\-socks5\-hostname\fP
+</stdout>
+</verify>
+
+</testcase>
diff --git a/tests/data/test1706 b/tests/data/test1706
new file mode 100644
index 000000000..7752ecf31
--- /dev/null
+++ b/tests/data/test1706
@@ -0,0 +1,288 @@
+<testcase>
+<info>
+<keywords>
+script
+documentation
+managen
+</keywords>
+</info>
+
+#
+# Client-side
+<client>
+<server>
+none
+</server>
+
+<name>
+managen makes ASCII page
+</name>
+
+<file name="%LOGDIR/mainpage.idx">
+_header.md
+%options
+_footer.md
+</file>
+
+<file1 name="%LOGDIR/_header.md">
+<!-- Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al. -->
+<!-- SPDX-License-Identifier: curl -->
+# DESCRIPTION
+
+**curl** is a tool for transferring data from or to a server using URLs. It
+supports these protocols: DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS,
+IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP,
+SMB, SMBS, SMTP, SMTPS, TELNET, TFTP, WS and WSS.
+
+curl is powered by libcurl for all transfer-related features. See
+*libcurl(3)* for details.
+</file1>
+<file2 name="%LOGDIR/option1.md">
+---
+c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+SPDX-License-Identifier: curl
+Short: v
+Long: fakeitreal
+Mutexed: trace trace-ascii
+Help: Make the operation more talkative
+Category: important verbose global
+Added: 4.0
+Multi: boolean
+Scope: global
+See-also:
+  - include
+  - silent
+  - trace
+  - trace-ascii
+Example:
+  - --verbose $URL
+---
+
+# `--verbose`
+
+Makes curl verbose during the operation. Useful for debugging and seeing
+what's going on under the hood. A line starting with \> means header data sent
+by curl, \< means header data received by curl that is hidden in normal cases,
+and a line starting with * means additional info provided by curl.
+
+If you only want HTTP headers in the output, --include or --dump-header might
+be more suitable options.
+
+If you think this option still does not give you enough details, consider using
+--trace or --trace-ascii instead.
+
+Note that verbose output of curl activities and network traffic might contain
+sensitive data, including usernames, credentials or secret data content. Be
+aware and be careful when sharing trace logs with others.
+</file2>
+<file3 name="%LOGDIR/option2.md">
+---
+c: Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+SPDX-License-Identifier: curl
+Long: proto
+Arg: <protocols>
+Help: Enable/disable PROTOCOLS
+Added: 7.20.2
+Category: connection curl
+Multi: single
+See-also:
+  - fakeitreal
+  - proto-default
+Example:
+  - --proto =http,https,sftp $URL
+---
+
+# `--proto`
+
+Limit what protocols to allow for transfers. Protocols are evaluated left to
+right, are comma separated, and are each a protocol name or 'all', optionally
+prefixed by zero or more modifiers. Available modifiers are:
+
+## +
+Permit this protocol in addition to protocols already permitted (this is
+the default if no modifier is used).
+
+## -
+Deny this protocol, removing it from the list of protocols already permitted.
+
+## =
+Permit only this protocol (ignoring the list already permitted), though
+subject to later modification by subsequent entries in the comma separated
+list.
+
+##
+
+For example: --proto -ftps uses the default protocols, but disables ftps
+
+--proto -all,https,+http only enables http and https
+
+--proto =http,https also only enables http and https
+
+Unknown and disabled protocols produce a warning. This allows scripts to
+safely rely on being able to disable potentially dangerous protocols, without
+relying upon support for that protocol being built into curl to avoid an error.
+
+This option can be used multiple times, in which case the effect is the same
+as concatenating the protocols into one instance of the option.
+</file3>
+<file4 name="%LOGDIR/_footer.md">
+<!-- Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al. -->
+<!-- SPDX-License-Identifier: curl -->
+# PROXY PROTOCOL PREFIXES
+The proxy string may be specified with a protocol:// prefix to specify
+alternative proxy protocols. (Added in 7.21.7)
+
+If no protocol is specified in the proxy string or if the string does not
+match a supported one, the proxy is treated as an HTTP proxy.
+
+The supported proxy protocol prefixes are as follows:
+## http://
+Makes it use it as an HTTP proxy. The default if no scheme prefix is used.
+## https://
+Makes it treated as an **HTTPS** proxy.
+## socks4://
+Makes it the equivalent of --socks4
+## socks4a://
+Makes it the equivalent of --socks4a
+## socks5://
+Makes it the equivalent of --socks5
+## socks5h://
+Makes it the equivalent of --socks5-hostname
+</file4>
+
+<command type="perl">
+%SRCDIR/../scripts/managen -d %LOGDIR ascii option1.md option2.md
+</command>
+</client>
+
+<verify>
+<stderr>
+option1.md:19:1:WARN: see-also a non-existing option: include
+option1.md:19:1:WARN: see-also a non-existing option: silent
+option1.md:19:1:WARN: see-also a non-existing option: trace
+option1.md:19:1:WARN: see-also a non-existing option: trace-ascii
+WARN: option1.md mutexes a non-existing option: trace
+WARN: option1.md mutexes a non-existing option: trace-ascii
+option2.md:15:1:WARN: see-also a non-existing option: proto-default
+</stderr>
+<stdout>
+DESCRIPTION
+
+    curl is a tool  for transferring data  from or to a  server using URLs.  It
+    supports these protocols:  DICT, FILE,  FTP, FTPS,  GOPHER, GOPHERS,  HTTP,
+    HTTPS, IMAP,  IMAPS, LDAP,  LDAPS, MQTT,  POP3, POP3S,  RTMP, RTMPS,  RTSP,
+    SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET, TFTP, WS and WSS.
+
+    curl  is  powered  by  libcurl  for  all  transfer-related  features.   See
+    libcurl(3) for details.
+
+    -v, --fakeitreal
+	    Makes curl verbose during the  operation. Useful for debugging  and
+	    seeing what's  going on  under the  hood. A  line  starting with  >
+	    means header data  sent by curl,  < means  header data received  by
+	    curl that is  hidden in normal  cases, and a  line starting with  *
+	    means additional info provided by curl.
+
+	    If  you  only  want  HTTP  headers  in  the  output,  --include  or
+	    --dump-header might be more suitable options.
+
+	    If you think this  option still does  not give you enough  details,
+	    consider using --trace or --trace-ascii instead.
+
+	    Note that verbose  output of  curl activities  and network  traffic
+	    might contain sensitive data,  including usernames, credentials  or
+	    secret data content.  Be aware  and be careful  when sharing  trace
+	    logs with others.
+
+	    This option is global  and does not need  to be specified for  each
+	    use of --next. Providing --fakeitreal  multiple times has no  extra
+	    effect. Disable it again with --no-fakeitreal.
+
+	    Example:
+	     curl --verbose https://example.com
+
+	    This option is mutually  exclusive with --trace and  --trace-ascii.
+	    See also --include, --silent, --trace and --trace-ascii.
+
+    --proto <protocols>
+	    Limit  what  protocols  to  allow  for  transfers.  Protocols   are
+	    evaluated left  to  right, are  comma  separated, and  are  each  a
+	    protocol name  or  'all',  optionally  prefixed  by  zero  or  more
+	    modifiers. Available modifiers are:
+
+	    +
+
+		Permit  this  protocol   in  addition   to  protocols   already
+		permitted (this is the default if no modifier is used).
+
+	    -
+
+		Deny this  protocol, removing  it from  the list  of  protocols
+		already permitted.
+
+	    =
+
+		Permit  only   this  protocol   (ignoring  the   list   already
+		permitted), though subject to later modification by  subsequent
+		entries in  the  comma  separated list.  For  example:  --proto
+		-ftps uses the default protocols, but disables ftps
+
+		--proto -all,https,+http only enables http and https
+
+		--proto =http,https also only enables http and https
+
+		Unknown and disabled protocols  produce a warning. This  allows
+		scripts to safely  rely on  being able  to disable  potentially
+		dangerous protocols,  without  relying upon  support  for  that
+		protocol being built into curl to avoid an error.
+
+		This option  can be  used  multiple times,  in which  case  the
+		effect is  the same  as concatenating  the protocols  into  one
+		instance of the option.
+
+	    If --proto is provided several times, the last set value is used.
+
+	    Example:
+	     curl --proto =http,https,sftp https://example.com
+
+	    See also --fakeitreal and --proto-default.
+
+PROXY PROTOCOL PREFIXES
+
+    The proxy  string may be  specified with  a protocol://  prefix to  specify
+    alternative proxy protocols.
+
+    If no protocol is specified in the  proxy string or if the string does  not
+    match a supported one, the proxy is treated as an HTTP proxy.
+
+    The supported proxy protocol prefixes are as follows:
+
+    http://
+
+	Makes it use it as  an HTTP proxy. The  default if no scheme prefix  is
+	used.
+
+    https://
+
+	Makes it treated as an HTTPS proxy.
+
+    socks4://
+
+	Makes it the equivalent of --socks4
+
+    socks4a://
+
+	Makes it the equivalent of --socks4a
+
+    socks5://
+
+	Makes it the equivalent of --socks5
+
+    socks5h://
+
+	Makes it the equivalent of --socks5-hostname
+
+</stdout>
+</verify>
+
+</testcase>
diff --git a/tests/data/test1908 b/tests/data/test1908
index 4ec55ed23..e4ec639cd 100644
--- a/tests/data/test1908
+++ b/tests/data/test1908
@@ -37,7 +37,7 @@ http
 # require debug so that alt-svc can work over plain old HTTP
 <features>
 alt-svc
-debug
+Debug
 </features>
 <name>
 alt-svc cache save after resetting the handle
diff --git a/tests/data/test1933 b/tests/data/test1933
index 3f3e8ac2c..456c8cfa0 100644
--- a/tests/data/test1933
+++ b/tests/data/test1933
@@ -35,7 +35,7 @@ http
 # this relies on the debug feature which allow to set the time
 <features>
 SSL
-debug
+Debug
 crypto
 </features>
 
diff --git a/tests/data/test1934 b/tests/data/test1934
index a131df49e..f0235a7d3 100644
--- a/tests/data/test1934
+++ b/tests/data/test1934
@@ -35,7 +35,7 @@ http
 # this relies on the debug feature which allow to set the time
 <features>
 SSL
-debug
+Debug
 crypto
 </features>
 
diff --git a/tests/data/test1935 b/tests/data/test1935
index d39a86471..b36e1fade 100644
--- a/tests/data/test1935
+++ b/tests/data/test1935
@@ -35,7 +35,7 @@ http
 # this relies on the debug feature which allow to set the time
 <features>
 SSL
-debug
+Debug
 crypto
 </features>
 
diff --git a/tests/data/test1936 b/tests/data/test1936
index a0d38403b..e937235d4 100644
--- a/tests/data/test1936
+++ b/tests/data/test1936
@@ -35,7 +35,7 @@ http
 # this relies on the debug feature which allow to set the time
 <features>
 SSL
-debug
+Debug
 crypto
 </features>
 
diff --git a/tests/data/test1937 b/tests/data/test1937
index ca1214b83..fc2d48c58 100644
--- a/tests/data/test1937
+++ b/tests/data/test1937
@@ -36,7 +36,7 @@ http
 # this relies on the debug feature which allow to set the time
 <features>
 SSL
-debug
+Debug
 crypto
 </features>
 
diff --git a/tests/data/test1938 b/tests/data/test1938
index 565a54ffe..ed24261b2 100644
Binary files a/tests/data/test1938 and b/tests/data/test1938 differ
diff --git a/tests/data/test1955 b/tests/data/test1955
index 27bb466c7..61b5100bd 100644
--- a/tests/data/test1955
+++ b/tests/data/test1955
@@ -35,7 +35,7 @@ http
 # this relies on the debug feature which allow to set the time
 <features>
 SSL
-debug
+Debug
 crypto
 </features>
 <setenv>
diff --git a/tests/data/test1956 b/tests/data/test1956
index 76aaa93ab..fbde6d718 100644
--- a/tests/data/test1956
+++ b/tests/data/test1956
@@ -35,7 +35,7 @@ http
 # this relies on the debug feature which allow to set the time
 <features>
 SSL
-debug
+Debug
 crypto
 </features>
 <setenv>
diff --git a/tests/data/test1957 b/tests/data/test1957
index add27db0f..39f11ac8b 100644
--- a/tests/data/test1957
+++ b/tests/data/test1957
@@ -35,7 +35,7 @@ http
 # this relies on the debug feature which allow to set the time
 <features>
 SSL
-debug
+Debug
 crypto
 </features>
 <setenv>
diff --git a/tests/data/test1958 b/tests/data/test1958
index c54b17962..99989097e 100644
--- a/tests/data/test1958
+++ b/tests/data/test1958
@@ -35,7 +35,7 @@ http
 # this relies on the debug feature which allow to set the time
 <features>
 SSL
-debug
+Debug
 crypto
 </features>
 <setenv>
diff --git a/tests/data/test1959 b/tests/data/test1959
index 2be813b08..e3d080509 100644
--- a/tests/data/test1959
+++ b/tests/data/test1959
@@ -35,7 +35,7 @@ http
 # this relies on the debug feature which allow to set the time
 <features>
 SSL
-debug
+Debug
 crypto
 </features>
 <setenv>
diff --git a/tests/data/test196 b/tests/data/test196
index b1a684f10..c72cbebf4 100644
--- a/tests/data/test196
+++ b/tests/data/test196
@@ -22,7 +22,7 @@ ftp
 FTP transient error, retry request once
 </name>
 <command>
-ftp://%HOSTIP:%FTPPORT/%TESTNUMBER --retry 1
+ftp://%HOSTIP:%FTPPORT/%TESTNUMBER --retry 1 -w '%{num_retries}\n'
 </command>
 </client>
 
@@ -38,5 +38,8 @@ PASS ftp@example.com
 USER anonymous
 PASS ftp@example.com
 </protocol>
+<stdout>
+1
+</stdout>
 </verify>
 </testcase>
diff --git a/tests/data/test1970 b/tests/data/test1970
index 1fbe60b45..9ed1a1e64 100644
--- a/tests/data/test1970
+++ b/tests/data/test1970
@@ -35,7 +35,7 @@ http
 # this relies on the debug feature which allow to set the time
 <features>
 SSL
-debug
+Debug
 crypto
 </features>
 <setenv>
diff --git a/tests/data/test1971 b/tests/data/test1971
index c311d176f..a0b20c4d7 100644
--- a/tests/data/test1971
+++ b/tests/data/test1971
@@ -28,7 +28,7 @@ http
 # this relies on the debug feature which allow to set the time
 <features>
 SSL
-debug
+Debug
 crypto
 </features>
 <setenv>
diff --git a/tests/data/test1972 b/tests/data/test1972
index 39e574747..901aae29e 100644
--- a/tests/data/test1972
+++ b/tests/data/test1972
@@ -35,7 +35,7 @@ http
 # this relies on the debug feature which allow to set the time
 <features>
 SSL
-debug
+Debug
 crypto
 </features>
 <setenv>
diff --git a/tests/data/test1973 b/tests/data/test1973
index 559fd5fc7..af64b90e0 100644
--- a/tests/data/test1973
+++ b/tests/data/test1973
@@ -35,7 +35,7 @@ http
 # this relies on the debug feature which allow to set the time
 <features>
 SSL
-debug
+Debug
 crypto
 </features>
 <setenv>
diff --git a/tests/data/test1974 b/tests/data/test1974
index 9b5bb8475..ee88bec74 100644
--- a/tests/data/test1974
+++ b/tests/data/test1974
@@ -35,7 +35,7 @@ http
 # this relies on the debug feature which allow to set the time
 <features>
 SSL
-debug
+Debug
 crypto
 </features>
 <setenv>
diff --git a/tests/data/test1975 b/tests/data/test1975
index 09256de04..277e35edd 100644
--- a/tests/data/test1975
+++ b/tests/data/test1975
@@ -28,7 +28,7 @@ http
 # this relies on the debug feature which allow to set the time
 <features>
 SSL
-debug
+Debug
 crypto
 </features>
 <setenv>
diff --git a/tests/data/test2039 b/tests/data/test2039
index fdb61ed02..7cab984ce 100644
--- a/tests/data/test2039
+++ b/tests/data/test2039
@@ -10,9 +10,7 @@ netrc
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -24,7 +22,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test2046 b/tests/data/test2046
index fc5ddca84..3aefd25c9 100644
--- a/tests/data/test2046
+++ b/tests/data/test2046
@@ -39,7 +39,7 @@ OK
 http
 </server>
 <features>
-idn
+IDN
 </features>
 <setenv>
 LC_ALL=en_US.UTF-8
diff --git a/tests/data/test2047 b/tests/data/test2047
index 76bed3cc9..82e9a14aa 100644
--- a/tests/data/test2047
+++ b/tests/data/test2047
@@ -39,7 +39,7 @@ OK
 http
 </server>
 <features>
-idn
+IDN
 proxy
 </features>
 <setenv>
diff --git a/tests/data/test2056 b/tests/data/test2056
index 008f137df..80e592025 100644
--- a/tests/data/test2056
+++ b/tests/data/test2056
@@ -40,7 +40,7 @@ HTTP Negotiate authentication (stub krb5)
 <features>
 GSS-API
 ld_preload
-!debug
+!Debug
 </features>
 <setenv>
 LD_PRELOAD=%PWD/libtest/.libs/libstubgss.so
diff --git a/tests/data/test2057 b/tests/data/test2057
index dfc7798f6..1e7568c6e 100644
--- a/tests/data/test2057
+++ b/tests/data/test2057
@@ -56,7 +56,7 @@ HTTP Negotiate authentication (stub ntlm)
 <features>
 GSS-API
 ld_preload
-!debug
+!Debug
 </features>
 <setenv>
 LD_PRELOAD=%PWD/libtest/.libs/libstubgss.so
diff --git a/tests/data/test2100 b/tests/data/test2100
index 120a6af7a..3f5f5d923 100644
--- a/tests/data/test2100
+++ b/tests/data/test2100
@@ -47,9 +47,9 @@ http
 # requires IPv6 so that we can assume and compare both DoH requests
 
 <features>
-debug
+Debug
 DoH
-ipv6
+IPv6
 </features>
 <name>
 HTTP GET using DoH
diff --git a/tests/data/test212 b/tests/data/test212
index db0201e15..045ad3769 100644
--- a/tests/data/test212
+++ b/tests/data/test212
@@ -23,7 +23,7 @@ ftp
 </server>
 # EPRT is only sent when IPv6 is enabled
 <features>
-ipv6
+IPv6
 </features>
 <name>
 Get two FTP files with no remote EPRT support
diff --git a/tests/data/test215 b/tests/data/test215
index cead9c742..058639f27 100644
--- a/tests/data/test215
+++ b/tests/data/test215
@@ -7,9 +7,7 @@ FTP
 
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -21,7 +19,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 
 </reply>
 
diff --git a/tests/data/test2300 b/tests/data/test2300
index fa620a1b1..e8a145929 100644
--- a/tests/data/test2300
+++ b/tests/data/test2300
@@ -27,7 +27,7 @@ upgrade
 <client>
 # for the forced CURL_ENTROPY
 <features>
-debug
+Debug
 ws
 </features>
 <server>
diff --git a/tests/data/test2301 b/tests/data/test2301
index 1f8ed662b..cc728d89a 100644
--- a/tests/data/test2301
+++ b/tests/data/test2301
@@ -29,7 +29,7 @@ upgrade
 <client>
 # require debug for the forced CURL_ENTROPY
 <features>
-debug
+Debug
 ws
 </features>
 <server>
diff --git a/tests/data/test2302 b/tests/data/test2302
index 013c324e8..9ade6a1e5 100644
--- a/tests/data/test2302
+++ b/tests/data/test2302
@@ -29,7 +29,7 @@ upgrade
 <client>
 # require debug for the forced CURL_ENTROPY
 <features>
-debug
+Debug
 ws
 </features>
 <server>
diff --git a/tests/data/test2303 b/tests/data/test2303
index dbd1115c8..79cb4c2ad 100644
--- a/tests/data/test2303
+++ b/tests/data/test2303
@@ -22,7 +22,7 @@ hello
 <client>
 # require debug for the forced CURL_ENTROPY
 <features>
-debug
+Debug
 ws
 </features>
 <server>
diff --git a/tests/data/test2304 b/tests/data/test2304
index 895518fb4..8ade3e771 100644
--- a/tests/data/test2304
+++ b/tests/data/test2304
@@ -29,7 +29,7 @@ upgrade
 <client>
 # require debug for the forced CURL_ENTROPY
 <features>
-debug
+Debug
 ws
 </features>
 <server>
diff --git a/tests/data/test2305 b/tests/data/test2305
index b7f218800..773b5df3a 100644
--- a/tests/data/test2305
+++ b/tests/data/test2305
@@ -31,7 +31,7 @@ upgrade
 <client>
 # require debug for the forced CURL_ENTROPY
 <features>
-debug
+Debug
 ws
 </features>
 <server>
diff --git a/tests/data/test2307 b/tests/data/test2307
index ce260ac1c..7c9f625b0 100644
--- a/tests/data/test2307
+++ b/tests/data/test2307
@@ -29,7 +29,7 @@ upgrade
 <client>
 # require debug for the forced CURL_ENTROPY
 <features>
-debug
+Debug
 ws
 !hyper
 </features>
diff --git a/tests/data/test240 b/tests/data/test240
index d033ae35c..75bd4bb3d 100644
--- a/tests/data/test240
+++ b/tests/data/test240
@@ -29,7 +29,7 @@ Funny-head: yesyes
 # Client-side
 <client>
 <features>
-ipv6
+IPv6
 </features>
 <server>
 http-ipv6
diff --git a/tests/data/test2400 b/tests/data/test2400
index e920f4f16..12395211e 100644
--- a/tests/data/test2400
+++ b/tests/data/test2400
@@ -27,7 +27,7 @@ Funny-head: yesyes
 # Client-side
 <client>
 <features>
-debug
+Debug
 h2c
 SSL
 </features>
diff --git a/tests/data/test2401 b/tests/data/test2401
index ef5fbb181..1db7dbedd 100644
--- a/tests/data/test2401
+++ b/tests/data/test2401
@@ -25,7 +25,7 @@ Funny-head: yesyes
 # Client-side
 <client>
 <features>
-debug
+Debug
 h2c
 SSL
 </features>
diff --git a/tests/data/test2406 b/tests/data/test2406
index 7055feed3..7a1620f2b 100644
--- a/tests/data/test2406
+++ b/tests/data/test2406
@@ -27,7 +27,7 @@ Funny-head: yesyes
 # Client-side
 <client>
 <features>
-debug
+Debug
 h2c
 SSL
 </features>
diff --git a/tests/data/test241 b/tests/data/test241
index 92a431420..38dea3fd5 100644
--- a/tests/data/test241
+++ b/tests/data/test241
@@ -24,7 +24,7 @@ hello
 # Client-side
 <client>
 <features>
-ipv6
+IPv6
 </features>
 <server>
 http-ipv6
diff --git a/tests/data/test242 b/tests/data/test242
index a498ab29b..91aeb381d 100644
--- a/tests/data/test242
+++ b/tests/data/test242
@@ -24,7 +24,7 @@ hello
 # Client-side
 <client>
 <features>
-ipv6
+IPv6
 </features>
 <server>
 http-ipv6
diff --git a/tests/data/test250 b/tests/data/test250
index 455d9ea1a..4f01ea79a 100644
--- a/tests/data/test250
+++ b/tests/data/test250
@@ -11,7 +11,7 @@ SLOWDOWN
 <reply>
 # When doing LIST, we get the default list output hard-coded in the test
 # FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -23,7 +23,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 <servercmd>
 SLOWDOWN
 </servercmd>
diff --git a/tests/data/test2501 b/tests/data/test2501
index 4db52ecf6..8b49127ff 100644
--- a/tests/data/test2501
+++ b/tests/data/test2501
@@ -25,7 +25,7 @@ Funny-head: yesyes
 # Client-side
 <client>
 <features>
-debug
+Debug
 http
 http/3
 </features>
diff --git a/tests/data/test251 b/tests/data/test251
index 46124bfec..9ed8c9488 100644
--- a/tests/data/test251
+++ b/tests/data/test251
@@ -8,9 +8,7 @@ SLOWDOWN
 
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -22,7 +20,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 <servercmd>
 SLOWDOWN
 </servercmd>
diff --git a/tests/data/test252 b/tests/data/test252
index 220cda189..1480ee1ec 100644
--- a/tests/data/test252
+++ b/tests/data/test252
@@ -10,9 +10,7 @@ EPSV
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -24,14 +22,14 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
 # Client-side
 <client>
 <features>
-ipv6
+IPv6
 </features>
 <server>
 ftp-ipv6
diff --git a/tests/data/test253 b/tests/data/test253
index 2c1008d7e..01ec416ac 100644
--- a/tests/data/test253
+++ b/tests/data/test253
@@ -10,9 +10,7 @@ EPRT
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -21,17 +19,17 @@ drwxr-xr-x   2 98       98           512 May  2  1996 .NeXT
 lrwxrwxrwx   1 0        1              7 Dec  9  1999 bin -> usr/bin
 dr-xr-xr-x   2 0        1            512 Oct  1  1997 dev
 drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
-dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
+dr-xr-xr-x   2 0        1            512 Nov 30  1995 moo
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
 # Client-side
 <client>
 <features>
-ipv6
+IPv6
 </features>
 <server>
 ftp-ipv6
diff --git a/tests/data/test254 b/tests/data/test254
index 30978758f..90b58a0b3 100644
--- a/tests/data/test254
+++ b/tests/data/test254
@@ -11,9 +11,7 @@ EPSV
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -25,14 +23,14 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
 # Client-side
 <client>
 <features>
-ipv6
+IPv6
 </features>
 <server>
 ftp-ipv6
diff --git a/tests/data/test255 b/tests/data/test255
index 37b9da2ac..1a1526a10 100644
--- a/tests/data/test255
+++ b/tests/data/test255
@@ -11,9 +11,7 @@ EPRT
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -25,14 +23,14 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
 # Client-side
 <client>
 <features>
-ipv6
+IPv6
 </features>
 <server>
 ftp-ipv6
diff --git a/tests/data/test2600 b/tests/data/test2600
index 5b88aedb7..0b4ee8b2f 100644
--- a/tests/data/test2600
+++ b/tests/data/test2600
@@ -15,8 +15,9 @@ none
 </server>
 <features>
 unittest
-debug
+Debug
 http
+!win32
 </features>
 <name>
 connection filter connect/destroy unit tests
diff --git a/tests/data/test263 b/tests/data/test263
index 93e98a197..648702529 100644
--- a/tests/data/test263
+++ b/tests/data/test263
@@ -24,7 +24,7 @@ hello
 # Client-side
 <client>
 <features>
-ipv6
+IPv6
 proxy
 </features>
 <server>
diff --git a/tests/data/test280 b/tests/data/test280
index 1ed41e652..1aee4b517 100644
--- a/tests/data/test280
+++ b/tests/data/test280
@@ -10,9 +10,7 @@ LIST
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -23,8 +21,8 @@ dr-xr-xr-x   2 0        1            512 Oct  1  1997 dev
 drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
-dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+dr-xr-xr-x   5 0        1            512 Oct  1  1997 fine
+</data>
 <servercmd>
 REPLY USER 530 We don't like USER commands
 COUNT USER 1
diff --git a/tests/data/test294 b/tests/data/test294
index b840b8c70..67108aedb 100644
--- a/tests/data/test294
+++ b/tests/data/test294
@@ -11,9 +11,7 @@ ACCT
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -25,7 +23,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 <servercmd>
 REPLY PASS 332 Give me an ACCT now
 REPLY ACCT 230 Thank-you for the ACCT
diff --git a/tests/data/test3029 b/tests/data/test3029
index 2e51bbeaf..143660209 100644
--- a/tests/data/test3029
+++ b/tests/data/test3029
@@ -36,4 +36,4 @@ Content-Length: 6
 </file>
 </verify>
 
-</testcase>
\ No newline at end of file
+</testcase>
diff --git a/tests/data/test3030 b/tests/data/test3030
index 7e169cf43..56da81c7c 100644
--- a/tests/data/test3030
+++ b/tests/data/test3030
@@ -40,4 +40,4 @@ Content-Length: 6
 </file>
 </verify>
 
-</testcase>
\ No newline at end of file
+</testcase>
diff --git a/tests/data/test3102 b/tests/data/test3102
index 4df7ba9c1..7635e6543 100644
--- a/tests/data/test3102
+++ b/tests/data/test3102
@@ -20,7 +20,6 @@ HTTP GET
 <features>
 SSL
 !bearssl
-!mbedtls
 !rustls
 !wolfssl
 </features>
diff --git a/tests/data/test3202 b/tests/data/test3202
index 25ec6073b..48a74e132 100644
--- a/tests/data/test3202
+++ b/tests/data/test3202
@@ -31,7 +31,7 @@ These data aren't actually sent to the client
 # Client-side
 <client>
 <features>
-ipv6
+IPv6
 </features>
 <server>
 http-ipv6
diff --git a/tests/data/test350 b/tests/data/test350
index 6830d704d..3eb8b80aa 100644
--- a/tests/data/test350
+++ b/tests/data/test350
@@ -9,9 +9,7 @@ LIST
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -23,7 +21,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test351 b/tests/data/test351
index ef21364ad..ffa93e3e2 100644
--- a/tests/data/test351
+++ b/tests/data/test351
@@ -9,9 +9,7 @@ LIST
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -23,7 +21,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test352 b/tests/data/test352
index cfcdc1f10..0cc4d69fd 100644
--- a/tests/data/test352
+++ b/tests/data/test352
@@ -9,9 +9,7 @@ LIST
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -23,7 +21,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test353 b/tests/data/test353
index 26115d675..a94828bd6 100644
--- a/tests/data/test353
+++ b/tests/data/test353
@@ -9,9 +9,7 @@ LIST
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -23,7 +21,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test356 b/tests/data/test356
index 3fb001c58..1d441d7e7 100644
--- a/tests/data/test356
+++ b/tests/data/test356
@@ -29,7 +29,7 @@ Alt-Svc: h1="nowhere.foo:70000"
 # Client-side
 <client>
 <features>
-debug
+Debug
 alt-svc
 </features>
 <server>
diff --git a/tests/data/test358 b/tests/data/test358
index 5df596de0..9db8b66f1 100644
--- a/tests/data/test358
+++ b/tests/data/test358
@@ -29,7 +29,7 @@ Alt-Svc: h2=":%HTTP2PORT", ma=315360000; persist=0
 <client>
 <features>
 alt-svc
-debug
+Debug
 h2c
 </features>
 <server>
diff --git a/tests/data/test359 b/tests/data/test359
index 117b4defe..2b7e52ce8 100644
--- a/tests/data/test359
+++ b/tests/data/test359
@@ -29,7 +29,7 @@ Alt-Svc: h2=":%HTTP2PORT", ma=315360000; persist=0
 <client>
 <features>
 alt-svc
-debug
+Debug
 h2c
 </features>
 <server>
diff --git a/tests/data/test363 b/tests/data/test363
index 7cc7dad99..d2d9661f7 100644
--- a/tests/data/test363
+++ b/tests/data/test363
@@ -43,7 +43,7 @@ contents
 # Client-side
 <client>
 <features>
-debug
+Debug
 proxy
 </features>
 <server>
diff --git a/tests/data/test380 b/tests/data/test380
index bd0c69765..f9ccafdab 100644
--- a/tests/data/test380
+++ b/tests/data/test380
@@ -10,9 +10,7 @@ netrc
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -24,7 +22,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test381 b/tests/data/test381
index 902cc91d1..41b9eb779 100644
--- a/tests/data/test381
+++ b/tests/data/test381
@@ -10,9 +10,7 @@ netrc
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -24,7 +22,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test400 b/tests/data/test400
index db774bf12..e20774a4d 100644
--- a/tests/data/test400
+++ b/tests/data/test400
@@ -10,9 +10,7 @@ LIST
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTPS server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -24,7 +22,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test403 b/tests/data/test403
index 7c2904afb..7c08d5ca8 100644
--- a/tests/data/test403
+++ b/tests/data/test403
@@ -12,9 +12,7 @@ FAILURE
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTPS server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -26,7 +24,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test406 b/tests/data/test406
index eca49d0d3..db497bf6c 100644
--- a/tests/data/test406
+++ b/tests/data/test406
@@ -10,9 +10,7 @@ LIST
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTPS server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -24,7 +22,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test412 b/tests/data/test412
index de607baa2..5923054fc 100644
--- a/tests/data/test412
+++ b/tests/data/test412
@@ -28,7 +28,7 @@ Funny-head: yesyes
 <client>
 <features>
 alt-svc
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test413 b/tests/data/test413
index 8639306e0..e0aec1eaa 100644
--- a/tests/data/test413
+++ b/tests/data/test413
@@ -28,7 +28,7 @@ Funny-head: yesyes
 <client>
 <features>
 alt-svc
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test437 b/tests/data/test437
index f12052d24..4098b4c64 100644
--- a/tests/data/test437
+++ b/tests/data/test437
@@ -26,7 +26,7 @@ Alt-Svc: h1="[ffff::1]:8181"
 # Client-side
 <client>
 <features>
-debug
+Debug
 alt-svc
 </features>
 <server>
diff --git a/tests/data/test438 b/tests/data/test438
index 4dd3b82c8..aad056aee 100644
--- a/tests/data/test438
+++ b/tests/data/test438
@@ -29,8 +29,8 @@ Alt-Svc: h1="%HOST6IP:%HTTP6PORT", ma=315360000; persist=0
 <client>
 <features>
 alt-svc
-debug
-ipv6
+Debug
+IPv6
 </features>
 <server>
 http
diff --git a/tests/data/test439 b/tests/data/test439
index c997a397a..43b56ea78 100644
--- a/tests/data/test439
+++ b/tests/data/test439
@@ -32,7 +32,7 @@ Funny-head: yesyes
 http
 </server>
 <features>
-debug
+Debug
 </features>
 <name>
 aws-sigv4 with query
diff --git a/tests/data/test446 b/tests/data/test446
index b8e719dd7..7f9891256 100644
--- a/tests/data/test446
+++ b/tests/data/test446
@@ -41,7 +41,7 @@ http-proxy
 HSTS
 proxy
 https
-debug
+Debug
 </features>
 <setenv>
 CURL_HSTS_HTTP=yes
diff --git a/tests/data/test447 b/tests/data/test447
index f514a130e..2783b750b 100644
--- a/tests/data/test447
+++ b/tests/data/test447
@@ -30,7 +30,7 @@ Funny-head: yesyes
 # Client-side
 <client>
 <features>
-debug
+Debug
 </features>
 <server>
 http
diff --git a/tests/data/test472 b/tests/data/test472
new file mode 100644
index 000000000..88cc78f93
--- /dev/null
+++ b/tests/data/test472
@@ -0,0 +1,59 @@
+<testcase>
+<info>
+<keywords>
+HTTP
+aws-sigv4
+</keywords>
+</info>
+
+#
+# Server-side
+<reply>
+<data crlf="yes">
+HTTP/1.1 200 OK
+Date: Tue, 09 Nov 2010 14:49:00 GMT
+Server: test-server/fake
+Last-Modified: Tue, 13 Jun 2000 12:10:00 GMT
+ETag: "21025-dc7-39462498"
+Accept-Ranges: bytes
+Content-Length: 6
+Connection: close
+Content-Type: text/html
+Funny-head: yesyes
+
+-foo-
+</data>
+</reply>
+
+#
+# Client-side
+<client>
+<server>
+http
+</server>
+<features>
+Debug
+Unicode
+</features>
+<name>
+aws-sigv4 with query
+</name>
+<command>
+"http://fake.fake.fake:8000/%TESTNUMBER/a=ã‚" -u user:secret --aws-sigv4 "aws:amz:us-east-2:es" --connect-to fake.fake.fake:8000:%HOSTIP:%HTTPPORT
+</command>
+</client>
+
+#
+# Verify data after the test has been "shot"
+<verify>
+<protocol crlf="yes">
+GET /472/a=%e3%81%82 HTTP/1.1
+Host: fake.fake.fake:8000
+Authorization: AWS4-HMAC-SHA256 Credential=user/19700101/us-east-2/es/aws4_request, SignedHeaders=host;x-amz-date, Signature=c63315c199922f7ee00141869a250389405d19e205057249fb74726d940b1fc3
+X-Amz-Date: 19700101T000000Z
+User-Agent: curl/%VERSION
+Accept: */*
+
+</protocol>
+</verify>
+</testcase>
diff --git a/tests/data/test473 b/tests/data/test473
new file mode 100644
index 000000000..874813c4e
--- /dev/null
+++ b/tests/data/test473
@@ -0,0 +1,62 @@
+<testcase>
+<info>
+<keywords>
+HTTP
+HTTP GET
+</keywords>
+</info>
+#
+# Server-side
+<reply>
+<data nocheck="yes">
+HTTP/1.1 301 funky chunky!
+Server: fakeit/0.9 fakeitbad/1.0
+Location: /redirected
+Transfer-Encoding: chunked
+Trailer: chunky-trailer
+Connection: mooo
+ETag: W/"asdf"
+
+40
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+30
+bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
+21;heresatest=moooo
+cccccccccccccccccccccccccccccccc
+
+0
+chunky-trailer: header data
+
+</data>
+</reply>
+
+#
+# Client-side
+<client>
+<server>
+http
+</server>
+<name>
+Check if --etag-save saved correct etag to a file on 301
+</name>
+<command>
+http://%HOSTIP:%HTTPPORT/%TESTNUMBER --etag-save %LOGDIR/etag%TESTNUMBER
+</command>
+</client>
+
+#
+# Verify data after the test has been "shot"
+<verify>
+<protocol>
+GET /%TESTNUMBER HTTP/1.1
+Host: %HOSTIP:%HTTPPORT
+User-Agent: curl/%VERSION
+Accept: */*
+
+</protocol>
+<file name="%LOGDIR/etag%TESTNUMBER">
+W/"asdf"
+</file>
+</verify>
+
+</testcase>
diff --git a/tests/data/test508 b/tests/data/test508
index 06cdba75f..cc1932a35 100644
--- a/tests/data/test508
+++ b/tests/data/test508
@@ -41,10 +41,6 @@ http://%HOSTIP:%HTTPPORT/%TESTNUMBER
 #
 # Verify data after the test has been "shot"
 <verify>
-<strippart>
-# remove CR that CURLOPT_TRANSFERTEXT added, when CharConv enabled:
-s/^(this is what we post to the silly web server)\r\n/$1\n/ if($has_charconv)
-</strippart>
 <protocol>
 POST /%TESTNUMBER HTTP/1.1
 Host: %HOSTIP:%HTTPPORT
diff --git a/tests/data/test521 b/tests/data/test521
index 1eec1bb2c..90473b33a 100644
--- a/tests/data/test521
+++ b/tests/data/test521
@@ -9,9 +9,7 @@ CURLOPT_PORT
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -23,7 +21,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test539 b/tests/data/test539
index 1fb4e1255..7985a5234 100644
--- a/tests/data/test539
+++ b/tests/data/test539
@@ -12,22 +12,14 @@ FTP
 file contents
 </data>
 
+<data1>
+contents for file number two
+</data1>
+
 <datacheck>
 file contents
+contents for file number two
 </datacheck>
-<datacheck1 mode="text">
-total 20
-drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
-drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
-drwxr-xr-x   2 98       98           512 May  2  1996 .NeXT
--r--r--r--   1 0        1             35 Jul 16  1996 README
-lrwxrwxrwx   1 0        1              7 Dec  9  1999 bin -> usr/bin
-dr-xr-xr-x   2 0        1            512 Oct  1  1997 dev
-drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
-dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
-drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
-dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck1>
 </reply>
 
 # Client-side
@@ -44,7 +36,7 @@ lib%TESTNUMBER
 Two FTP fetches using different CURLOPT_FTP_FILEMETHOD
 </name>
 <command>
-ftp://%HOSTIP:%FTPPORT/path/to/the/file/%TESTNUMBER
+ftp://%HOSTIP:%FTPPORT/path/to/the/file/%TESTNUMBER ftp://%HOSTIP:%FTPPORT/path/to/the/file/%TESTNUMBER0001
 </command>
 </client>
 
@@ -63,8 +55,8 @@ RETR %TESTNUMBER
 SYST
 CWD /
 EPSV
-TYPE A
-LIST path/to/the/file/%TESTNUMBER.
+SIZE path/to/the/file/%TESTNUMBER0001
+RETR path/to/the/file/%TESTNUMBER0001
 QUIT
 </protocol>
 </verify>
diff --git a/tests/data/test558 b/tests/data/test558
index 06b772816..47605de0b 100644
--- a/tests/data/test558
+++ b/tests/data/test558
@@ -17,7 +17,7 @@ none
 </server>
 <features>
 TrackMemory
-ipv6
+IPv6
 </features>
 # tool is what to use instead of 'curl'
 <tool>
diff --git a/tests/data/test574 b/tests/data/test574
index 436e1828b..3c151286c 100644
--- a/tests/data/test574
+++ b/tests/data/test574
@@ -11,10 +11,8 @@ ftplistparser
 
 #
 # Server-side
-<reply>
-<data mode="text">
-</data>
-</reply>
+#
+# Data is generated by the ftp server itself
 
 # Client-side
 <client>
diff --git a/tests/data/test644 b/tests/data/test644
index fc670756c..2db24f907 100644
--- a/tests/data/test644
+++ b/tests/data/test644
@@ -47,7 +47,7 @@ Funny-head: yesyes
 http
 </server>
 <features>
-debug
+Debug
 xattr
 </features>
 # simulate the xattr operations
diff --git a/tests/data/test687 b/tests/data/test687
index 500a1dfb2..6384a5e49 100644
--- a/tests/data/test687
+++ b/tests/data/test687
@@ -29,7 +29,7 @@ Content-Type: fake/data
 http
 </server>
 <features>
-debug
+Debug
 xattr
 </features>
 # simulate the xattr operations
diff --git a/tests/data/test688 b/tests/data/test688
index c545c4704..4ade6edbc 100644
--- a/tests/data/test688
+++ b/tests/data/test688
@@ -29,7 +29,7 @@ Content-Type: fake/data
 http
 </server>
 <features>
-debug
+Debug
 xattr
 </features>
 # simulate the xattr operations
diff --git a/tests/data/test706 b/tests/data/test706
index 656b3dd8b..faafd9038 100644
--- a/tests/data/test706
+++ b/tests/data/test706
@@ -11,9 +11,7 @@ SOCKS4
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -25,7 +23,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test707 b/tests/data/test707
index 3ed89ec62..2c41dfea7 100644
--- a/tests/data/test707
+++ b/tests/data/test707
@@ -11,9 +11,7 @@ SOCKS5
 #
 # Server-side
 <reply>
-# When doing LIST, we get the default list output hard-coded in the test
-# FTP server
-<datacheck mode="text">
+<data mode="text">
 total 20
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 .
 drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..
@@ -25,7 +23,7 @@ drwxrwxrwx   2 98       98           512 May 29 16:04 download.html
 dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc
 drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub
 dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test719 b/tests/data/test719
index 63cb88886..454460983 100644
--- a/tests/data/test719
+++ b/tests/data/test719
@@ -31,7 +31,7 @@ Funny-head: yesyes
 # Client-side
 <client>
 <features>
-ipv6
+IPv6
 proxy
 </features>
 <server>
diff --git a/tests/data/test823 b/tests/data/test823
index 18ed5fa67..a3736a6fd 100644
--- a/tests/data/test823
+++ b/tests/data/test823
@@ -36,7 +36,7 @@ imap
 </server>
 <features>
 !SSPI
-debug
+Debug
 crypto
 </features>
 <name>
diff --git a/tests/data/test832 b/tests/data/test832
index 6001c1d45..bbbc0ac73 100644
--- a/tests/data/test832
+++ b/tests/data/test832
@@ -28,7 +28,7 @@ imap
 </server>
 <features>
 !SSPI
-debug
+Debug
 crypto
 </features>
 <name>
diff --git a/tests/data/test835 b/tests/data/test835
index ee6ed31d1..17c8675eb 100644
--- a/tests/data/test835
+++ b/tests/data/test835
@@ -39,7 +39,7 @@ imap
 </server>
 <features>
 !SSPI
-debug
+Debug
 crypto
 </features>
 <name>
diff --git a/tests/data/test853 b/tests/data/test853
index de5236420..3b57e7d08 100644
--- a/tests/data/test853
+++ b/tests/data/test853
@@ -18,11 +18,11 @@ SLOWDOWN
 </servercmd>
 # When doing LIST, we get the default list output hard-coded in the test
 # POP3 server
-<datacheck>
+<data>
 1 100
 2 4294967400
 3 200
-</datacheck>
+</data>
 </reply>
 
 #
diff --git a/tests/data/test869 b/tests/data/test869
index 59900df08..56873e038 100644
--- a/tests/data/test869
+++ b/tests/data/test869
@@ -38,7 +38,7 @@ pop3
 </server>
 <features>
 !SSPI
-debug
+Debug
 crypto
 </features>
 <name>
diff --git a/tests/data/test878 b/tests/data/test878
index 58c2e3007..657dc71c7 100644
--- a/tests/data/test878
+++ b/tests/data/test878
@@ -29,7 +29,7 @@ pop3
 </server>
 <features>
 !SSPI
-debug
+Debug
 crypto
 </features>
 <name>
diff --git a/tests/data/test881 b/tests/data/test881
index 7cbdf64ba..20e352788 100644
--- a/tests/data/test881
+++ b/tests/data/test881
@@ -41,7 +41,7 @@ pop3
 </server>
 <features>
 !SSPI
-debug
+Debug
 crypto
 </features>
 <name>
diff --git a/tests/data/test907 b/tests/data/test907
index 12d6e8289..8c24b68c4 100644
--- a/tests/data/test907
+++ b/tests/data/test907
@@ -28,7 +28,7 @@ smtp
 </server>
 <features>
 !SSPI
-debug
+Debug
 crypto
 </features>
 <name>
diff --git a/tests/data/test934 b/tests/data/test934
index 8fd444e91..5ebf67fec 100644
--- a/tests/data/test934
+++ b/tests/data/test934
@@ -28,7 +28,7 @@ smtp
 </server>
 <features>
 !SSPI
-debug
+Debug
 crypto
 </features>
 <name>
diff --git a/tests/data/test937 b/tests/data/test937
index 6c361b738..bb761f854 100644
--- a/tests/data/test937
+++ b/tests/data/test937
@@ -31,7 +31,7 @@ smtp
 </server>
 <features>
 !SSPI
-debug
+Debug
 crypto
 </features>
 <name>
diff --git a/tests/data/test941 b/tests/data/test941
index 7c87f5028..79f88a674 100644
--- a/tests/data/test941
+++ b/tests/data/test941
@@ -32,6 +32,7 @@ converted
 with
 the
 --crlf option
+%repeat[650 x 0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789%0a]%
 </file>
 <command>
 smtp://%HOSTIP:%SMTPPORT/%TESTNUMBER --mail-rcpt recipient@example.com --mail-from sender@example.com -T %LOGDIR/upload%TESTNUMBER --crlf
@@ -60,6 +61,7 @@ converted
 with
 the
 --crlf option
+%repeat[650 x 0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789%0a]%
 .
 </upload>
 </verify>
diff --git a/tests/data/test959 b/tests/data/test959
index 143708df8..421d6ba98 100644
--- a/tests/data/test959
+++ b/tests/data/test959
@@ -20,7 +20,7 @@ REPLY MAIL 501 not fine enough
 smtp
 </server>
 <features>
-!idn
+!IDN
 !win32
 </features>
 <setenv>
diff --git a/tests/data/test960 b/tests/data/test960
index bcb9bf44c..9f33fdc79 100644
--- a/tests/data/test960
+++ b/tests/data/test960
@@ -17,7 +17,7 @@ SMTP
 smtp
 </server>
 <features>
-!idn
+!IDN
 !win32
 </features>
 <setenv>
diff --git a/tests/data/test961 b/tests/data/test961
index 750943ab4..c416b9761 100644
--- a/tests/data/test961
+++ b/tests/data/test961
@@ -18,7 +18,7 @@ VRFY
 smtp
 </server>
 <features>
-!idn
+!IDN
 !win32
 </features>
 <setenv>
diff --git a/tests/data/test962 b/tests/data/test962
index 503761b46..09bfb5100 100644
--- a/tests/data/test962
+++ b/tests/data/test962
@@ -18,7 +18,7 @@ IDN
 smtp
 </server>
 <features>
-idn
+IDN
 !win32
 </features>
 <setenv>
diff --git a/tests/data/test963 b/tests/data/test963
index 1b977f007..02fc0b851 100644
--- a/tests/data/test963
+++ b/tests/data/test963
@@ -18,7 +18,7 @@ IDN
 smtp
 </server>
 <features>
-idn
+IDN
 !win32
 </features>
 <setenv>
diff --git a/tests/data/test964 b/tests/data/test964
index e2d69881a..e03dc333e 100644
--- a/tests/data/test964
+++ b/tests/data/test964
@@ -19,7 +19,7 @@ IDN
 smtp
 </server>
 <features>
-idn
+IDN
 !win32
 </features>
 <setenv>
diff --git a/tests/data/test965 b/tests/data/test965
index 71adef8f6..f8adbdefe 100644
--- a/tests/data/test965
+++ b/tests/data/test965
@@ -21,7 +21,7 @@ CAPA SMTPUTF8
 smtp
 </server>
 <features>
-idn
+IDN
 !win32
 </features>
 <setenv>
diff --git a/tests/data/test966 b/tests/data/test966
index acc248a57..e43f860ec 100644
--- a/tests/data/test966
+++ b/tests/data/test966
@@ -21,7 +21,7 @@ CAPA SMTPUTF8
 smtp
 </server>
 <features>
-idn
+IDN
 !win32
 </features>
 <setenv>
diff --git a/tests/data/test967 b/tests/data/test967
index 95fb153bd..898fbb106 100644
--- a/tests/data/test967
+++ b/tests/data/test967
@@ -25,7 +25,7 @@ CAPA SMTPUTF8
 smtp
 </server>
 <features>
-idn
+IDN
 !win32
 </features>
 <setenv>
diff --git a/tests/data/test968 b/tests/data/test968
index 099f6fd29..c27a3675f 100644
--- a/tests/data/test968
+++ b/tests/data/test968
@@ -22,7 +22,7 @@ CAPA SMTPUTF8
 smtp
 </server>
 <features>
-idn
+IDN
 !win32
 </features>
 <setenv>
diff --git a/tests/data/test969 b/tests/data/test969
index bb4cc316e..c7bffb9b8 100644
--- a/tests/data/test969
+++ b/tests/data/test969
@@ -28,7 +28,7 @@ CAPA SMTPUTF8
 smtp
 </server>
 <features>
-idn
+IDN
 !win32
 </features>
 <name>
diff --git a/tests/data/test970 b/tests/data/test970
index c87a296fa..bf1235da5 100644
--- a/tests/data/test970
+++ b/tests/data/test970
@@ -32,7 +32,7 @@ Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor i
 http
 </server>
 <features>
-debug
+Debug
 proxy
 </features>
 <setenv>
@@ -59,7 +59,7 @@ Accept: */*
 
 </protocol>
 <stdout nonewline="yes">
-{"certs":"","content_type":"text/html","conn_id":0,"errormsg":null,"exitcode":0,"filename_effective":"%LOGDIR/out%TESTNUMBER","ftp_entry_path":null,"http_code":200,"http_connect":0,"http_version":"1.1","local_ip":"127.0.0.1","local_port":13,"method":"GET","num_certs":0,"num_connects":1,"num_headers":9,"num_redirects":0,"proxy_ssl_verify_result":0,"proxy_used":0,"redirect_url":null,"referer":null,"remote_ip":"%HOSTIP","remote_port":%HTTPPORT,"response_code":200,"scheme":"http","size_download":445,"size_header":4019,"size_request":4019,"size_upload":0,"speed_download":13,"speed_upload":13,"ssl_verify_result":0,"time_appconnect":0.000013,"time_connect":0.000013,"time_namelookup":0.000013,"time_pretransfer":0.000013,"time_redirect":0.000013,"time_starttransfer":0.000013,"time_total":0.000013,"url":"http://%HOSTIP:%HTTPPORT/%TESTNUMBER","url.scheme":"http","url.user":null,"url.password":null,"url.options":null,"url.host":"%HOSTIP","url.port":"%HTTPPORT","url.path":"/%TESTNUMBER","url.query":null,"url.fragment":null,"url.zoneid":null,"urle.scheme":"http","urle.user":null,"urle.password":null,"urle.options":null,"urle.host":"%HOSTIP","urle.port":"%HTTPPORT","urle.path":"/%TESTNUMBER","urle.query":null,"urle.fragment":null,"urle.zoneid":null,"url_effective":"http://%HOSTIP:%HTTPPORT/%TESTNUMBER","urlnum":0,"xfer_id":0,"curl_version":"curl-unit-test-fake-version"}
+{"certs":"","conn_id":0,"content_type":"text/html","errormsg":null,"exitcode":0,"filename_effective":"%LOGDIR/out%TESTNUMBER","ftp_entry_path":null,"http_code":200,"http_connect":0,"http_version":"1.1","local_ip":"127.0.0.1","local_port":13,"method":"GET","num_certs":0,"num_connects":1,"num_headers":9,"num_redirects":0,"num_retries":0,"proxy_ssl_verify_result":0,"proxy_used":0,"redirect_url":null,"referer":null,"remote_ip":"%HOSTIP","remote_port":%HTTPPORT,"response_code":200,"scheme":"http","size_download":445,"size_header":4019,"size_request":4019,"size_upload":0,"speed_download":13,"speed_upload":13,"ssl_verify_result":0,"time_appconnect":0.000013,"time_connect":0.000013,"time_namelookup":0.000013,"time_pretransfer":0.000013,"time_redirect":0.000013,"time_starttransfer":0.000013,"time_total":0.000013,"url":"http://%HOSTIP:%HTTPPORT/%TESTNUMBER","url.fragment":null,"url.host":"127.0.0.1","url.options":null,"url.password":null,"url.path":"/%TESTNUMBER","url.port":"%HTTPPORT","url.query":null,"url.scheme":"http","url.user":null,"url.zoneid":null,"url_effective":"http://%HOSTIP:%HTTPPORT/%TESTNUMBER","urle.fragment":null,"urle.host":"127.0.0.1","urle.options":null,"urle.password":null,"urle.path":"/%TESTNUMBER","urle.port":"%HTTPPORT","urle.query":null,"urle.scheme":"http","urle.user":null,"urle.zoneid":null,"urlnum":0,"xfer_id":0,"curl_version":"curl-unit-test-fake-version"}
 </stdout>
 </verify>
 </testcase>
diff --git a/tests/data/test972 b/tests/data/test972
index ebaf4a346..c6def2986 100644
--- a/tests/data/test972
+++ b/tests/data/test972
@@ -33,7 +33,7 @@ Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor i
 http
 </server>
 <features>
-debug
+Debug
 proxy
 </features>
 <setenv>
@@ -60,7 +60,7 @@ Accept: */*
 
 </protocol>
 <stdout mode="text">
-{"certs":"","content_type":"text/html","conn_id":0,"errormsg":null,"exitcode":0,"filename_effective":"%LOGDIR/out972","ftp_entry_path":null,"http_code":200,"http_connect":0,"http_version":"1.1","local_ip":"%HOSTIP","local_port":13,"method":"GET","num_certs":0,"num_connects":1,"num_headers":9,"num_redirects":0,"proxy_ssl_verify_result":0,"proxy_used":0,"redirect_url":null,"referer":null,"remote_ip":"%HOSTIP","remote_port":%HTTPPORT,"response_code":200,"scheme":"http","size_download":445,"size_header":4019,"size_request":4019,"size_upload":0,"speed_download":13,"speed_upload":13,"ssl_verify_result":0,"time_appconnect":0.000013,"time_connect":0.000013,"time_namelookup":0.000013,"time_pretransfer":0.000013,"time_redirect":0.000013,"time_starttransfer":0.000013,"time_total":0.000013,"url":"http://%HOSTIP:%HTTPPORT/%TESTNUMBER","url.scheme":"http","url.user":null,"url.password":null,"url.options":null,"url.host":"%HOSTIP","url.port":"%HTTPPORT","url.path":"/%TESTNUMBER","url.query":null,"url.fragment":null,"url.zoneid":null,"urle.scheme":"http","urle.user":null,"urle.password":null,"urle.options":null,"urle.host":"%HOSTIP","urle.port":"%HTTPPORT","urle.path":"/%TESTNUMBER","urle.query":null,"urle.fragment":null,"urle.zoneid":null,"url_effective":"http://%HOSTIP:%HTTPPORT/%TESTNUMBER","urlnum":0,"xfer_id":0,"curl_version":"curl-unit-test-fake-version"}
+{"certs":"","conn_id":0,"content_type":"text/html","errormsg":null,"exitcode":0,"filename_effective":"%LOGDIR/out%TESTNUMBER","ftp_entry_path":null,"http_code":200,"http_connect":0,"http_version":"1.1","local_ip":"127.0.0.1","local_port":13,"method":"GET","num_certs":0,"num_connects":1,"num_headers":9,"num_redirects":0,"num_retries":0,"proxy_ssl_verify_result":0,"proxy_used":0,"redirect_url":null,"referer":null,"remote_ip":"%HOSTIP","remote_port":%HTTPPORT,"response_code":200,"scheme":"http","size_download":445,"size_header":4019,"size_request":4019,"size_upload":0,"speed_download":13,"speed_upload":13,"ssl_verify_result":0,"time_appconnect":0.000013,"time_connect":0.000013,"time_namelookup":0.000013,"time_pretransfer":0.000013,"time_redirect":0.000013,"time_starttransfer":0.000013,"time_total":0.000013,"url":"http://%HOSTIP:%HTTPPORT/%TESTNUMBER","url.fragment":null,"url.host":"127.0.0.1","url.options":null,"url.password":null,"url.path":"/%TESTNUMBER","url.port":"%HTTPPORT","url.query":null,"url.scheme":"http","url.user":null,"url.zoneid":null,"url_effective":"http://%HOSTIP:%HTTPPORT/%TESTNUMBER","urle.fragment":null,"urle.host":"127.0.0.1","urle.options":null,"urle.password":null,"urle.path":"/%TESTNUMBER","urle.port":"%HTTPPORT","urle.query":null,"urle.scheme":"http","urle.user":null,"urle.zoneid":null,"urlnum":0,"xfer_id":0,"curl_version":"curl-unit-test-fake-version"}
 </stdout>
 </verify>
 </testcase>
diff --git a/tests/data/test99 b/tests/data/test99
index db11a059b..b0e769a7e 100644
--- a/tests/data/test99
+++ b/tests/data/test99
@@ -35,7 +35,7 @@ Funny-head: yesyes
 # Client-side
 <client>
 <features>
-large_file
+Largefile
 </features>
 <server>
 http
diff --git a/tests/data/test993 b/tests/data/test993
new file mode 100644
index 000000000..01248de33
--- /dev/null
+++ b/tests/data/test993
@@ -0,0 +1,42 @@
+<testcase>
+<info>
+<keywords>
+POP3
+Clear Text
+LIST
+</keywords>
+</info>
+
+#
+# Server-side
+<reply>
+<data>
+%repeat[1000 x 95 328485%0d%0a]%</data>
+</reply>
+
+#
+# Client-side
+<client>
+<server>
+pop3
+</server>
+<name>
+POP3 LIST 1000 messages
+</name>
+<command>
+pop3://%HOSTIP:%POP3PORT/ -u user:secret
+</command>
+</client>
+
+#
+# Verify data after the test has been "shot"
+<verify>
+<protocol>
+CAPA
+USER user
+PASS secret
+LIST
+QUIT
+</protocol>
+</verify>
+</testcase>
diff --git a/tests/ech_tests.sh b/tests/ech_tests.sh
index 3862d2b21..615323b48 100755
--- a/tests/ech_tests.sh
+++ b/tests/ech_tests.sh
@@ -68,7 +68,8 @@ declare -A ech_targets=(
     [draft-13.esni.defo.ie:12414]=""
     [crypto.cloudflare.com]="cdn-cgi/trace"
     [tls-ech.dev]=""
-    [epochbelt.com]=""
+    # this one's gone away for now (possibly temporarily)
+    # [epochbelt.com]=""
 )
 
 # Targets we expect not to be ECH-enabled servers
@@ -102,12 +103,12 @@ declare -A neither_targets=(
 : "${tout:=10s}"
 
 # Where we find OpenSSL .so's
-: "${OSSL:=$HOME/code/openssl}"
+: "${OSSL:=$HOME/code/openssl-local-inst}"
 
-# Where we find WolfSSL .so's
+# Where we find wolfSSL .so's
 : "${WSSL:=$HOME/code/wolfssl/inst/lib}"
 
-# Where we find boringssl .so's
+# Where we find BoringSSL .so's
 : "${BSSL:=$HOME/code/boringssl/inst/lib}"
 
 # Where we send DoH queries when using kdig or curl
@@ -412,6 +413,11 @@ then
             echo "Skipping $targ as ports != 443 seem blocked"
             continue
         fi
+        if [[ "$host" == "crypto.cloudflare.com" ]]
+        then
+            echo "Skipping $host as they've blocked PN override"
+            continue
+        fi
         path=${ech_targets[$targ]}
         turl="https://$host:$port/$path"
         echo "PN override check for $turl"
@@ -533,7 +539,7 @@ fi
 fi # skip
 
 # Check combinations of command line options, if we're good so far
-# Most of this only works for openssl, which is ok, as we're checking
+# Most of this only works for OpenSSL, which is ok, as we're checking
 # the argument handling here, not the ECH protocol
 if [[ "$using_ossl" == "yes" && "$allgood" == "yes" ]]
 then
diff --git a/tests/ftpserver.pl b/tests/ftpserver.pl
index 10abe418c..0b552e074 100755
--- a/tests/ftpserver.pl
+++ b/tests/ftpserver.pl
@@ -670,7 +670,7 @@ sub protocolsetup {
     }
 }
 
-# Perform the disconnecgt handshake with sockfilt on the secondary connection
+# Perform the disconnect handshake with sockfilt on the secondary connection
 # (the only connection we actively disconnect).
 # This involves waiting for the disconnect acknowledgment after the DISC
 # command, while throwing away anything else that might come in before
@@ -690,9 +690,8 @@ sub disc_handshake {
                 $size = hex($1);
             }
 
-            read_datasockf(\$line, $size);
-
             logmsg "> Throwing away $size bytes on closed connection\n";
+            read_datasockf(\$line, $size);
         }
         elsif($line eq "DISC\n") {
             logmsg "Fancy that; client wants to DISC, too\n";
@@ -1863,12 +1862,7 @@ sub RETR_pop3 {
 }
 
 sub LIST_pop3 {
-    # This is a built-in fake-message list
-    my @data = (
-        "1 100\r\n",
-        "2 4294967400\r\n",  # > 4 GB
-        "3 200\r\n",
-    );
+    my @data = getpart("reply", "data");
 
     logmsg "retrieve a message list\n";
 
@@ -2077,7 +2071,8 @@ sub CWD_ftp {
   my ($folder, $fullcommand) = $_[0];
   switch_directory($folder);
   if($ftptargetdir =~ /^\/fully_simulated/) {
-    $ftplistparserstate = "enabled";
+      $ftplistparserstate = "enabled";
+      logmsg "enabled FTP list parser mode\n";
   }
   else {
     undef $ftplistparserstate;
@@ -2097,19 +2092,6 @@ sub PWD_ftp {
 sub LIST_ftp {
     #  print "150 ASCII data connection for /bin/ls (193.15.23.1,59196) (0 bytes)\r\n";
 
-# this is a built-in fake-dir ;-)
-my @ftpdir=("total 20\r\n",
-"drwxr-xr-x   8 98       98           512 Oct 22 13:06 .\r\n",
-"drwxr-xr-x   8 98       98           512 Oct 22 13:06 ..\r\n",
-"drwxr-xr-x   2 98       98           512 May  2  1996 .NeXT\r\n",
-"-r--r--r--   1 0        1             35 Jul 16  1996 README\r\n",
-"lrwxrwxrwx   1 0        1              7 Dec  9  1999 bin -> usr/bin\r\n",
-"dr-xr-xr-x   2 0        1            512 Oct  1  1997 dev\r\n",
-"drwxrwxrwx   2 98       98           512 May 29 16:04 download.html\r\n",
-"dr-xr-xr-x   2 0        1            512 Nov 30  1995 etc\r\n",
-"drwxrwxrwx   2 98       1            512 Oct 30 14:33 pub\r\n",
-"dr-xr-xr-x   5 0        1            512 Oct  1  1997 usr\r\n");
-
     if($datasockf_conn eq 'no') {
         if($nodataconn425) {
             sendcontrol "150 Opening data connection\r\n";
@@ -2129,15 +2111,17 @@ my @ftpdir=("total 20\r\n",
         return 0;
     }
 
-    if($ftplistparserstate) {
-      @ftpdir = ftp_contentlist($ftptargetdir);
-    }
-
     logmsg "pass LIST data on data connection\n";
 
-    if($cwd_testno) {
-        loadtest("$logdir/test$cwd_testno");
-
+    if($ftplistparserstate) {
+        # provide a synthetic response
+        my @ftpdir = ftp_contentlist($ftptargetdir);
+        # old hard-coded style
+        for(@ftpdir) {
+            senddata $_;
+        }
+    }
+    else {
         my @data = getpart("reply", "data");
         for(@data) {
             my $send = $_;
@@ -2147,13 +2131,6 @@ my @ftpdir=("total 20\r\n",
             logmsg "send $send as data\n";
             senddata $send;
         }
-        $cwd_testno = 0; # forget it again
-    }
-    else {
-        # old hard-coded style
-        for(@ftpdir) {
-            senddata $_;
-        }
     }
     close_dataconn(0);
     sendcontrol "226 ASCII transfer complete\r\n";
@@ -2220,6 +2197,7 @@ sub MDTM_ftp {
 
 sub SIZE_ftp {
     my $testno = $_[0];
+
     if($ftplistparserstate) {
         my $size = wildcard_filesize($ftptargetdir, $testno);
         if($size == -1) {
@@ -2380,7 +2358,7 @@ sub RETR_ftp {
                 $sz = "($retrsize bytes)";
             }
 
-            sendcontrol "150 Binary data connection for $testno () $sz.\r\n";
+            sendcontrol "150 Binary data connection for $testno ($testpart) $sz.\r\n";
 
             for(@data) {
                 my $send = $_;
diff --git a/tests/globalconfig.pm b/tests/globalconfig.pm
index 5aad483eb..ca78f5dbe 100644
--- a/tests/globalconfig.pm
+++ b/tests/globalconfig.pm
@@ -38,6 +38,8 @@ BEGIN {
         $automakestyle
         $CURL
         $CURLVERSION
+        $CURLVERNUM
+        $DATE
         $has_shared
         $LIBDIR
         $listonly
@@ -82,12 +84,13 @@ our $run_event_based; # run curl with --test-event to test the event API
 our $automakestyle;   # use automake-like test status output format
 our $anyway;          # continue anyway, even if a test fail
 our $CURLVERSION="";  # curl's reported version number
+our $CURLVERNUM="";   # curl's reported version number (without -DEV)
 our $randseed = 0;    # random number seed
 
 # paths
 our $pwd = getcwd();  # current working directory
 our $srcdir = $ENV{'srcdir'} || '.';  # root of the test source code
-our $perl="perl -I$srcdir"; # invoke perl like this
+our $perl="perl -I. -I$srcdir"; # invoke perl like this
 our $LOGDIR="log";  # root of the log directory; this will be different for
                     # each runner in multiprocess mode
 our $LIBDIR="./libtest";
diff --git a/tests/http/Makefile.am b/tests/http/Makefile.am
index d3a219d7a..d9ab29686 100644
--- a/tests/http/Makefile.am
+++ b/tests/http/Makefile.am
@@ -35,6 +35,7 @@ testenv/httpd.py                      \
 testenv/mod_curltest/mod_curltest.c   \
 testenv/nghttpx.py                    \
 testenv/ports.py                      \
+testenv/vsftpd.py                     \
 testenv/ws_echo_server.py
 
 EXTRA_DIST =           \
diff --git a/tests/http/clients/h2-download.c b/tests/http/clients/h2-download.c
index 74aac6a8e..719839889 100644
--- a/tests/http/clients/h2-download.c
+++ b/tests/http/clients/h2-download.c
@@ -159,6 +159,7 @@ struct transfer {
 
 static size_t transfer_count = 1;
 static struct transfer *transfers;
+static int forbid_reuse = 0;
 
 static struct transfer *get_transfer_for_easy(CURL *easy)
 {
@@ -239,6 +240,8 @@ static int setup(CURL *hnd, const char *url, struct transfer *t,
   curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 0L);
   curl_easy_setopt(hnd, CURLOPT_XFERINFOFUNCTION, my_progress_cb);
   curl_easy_setopt(hnd, CURLOPT_XFERINFODATA, t);
+  if(forbid_reuse)
+    curl_easy_setopt(hnd, CURLOPT_FORBID_REUSE, 1L);
 
   /* please be verbose */
   if(verbose) {
@@ -288,7 +291,7 @@ int main(int argc, char *argv[])
   int http_version = CURL_HTTP_VERSION_2_0;
   int ch;
 
-  while((ch = getopt(argc, argv, "ahm:n:A:F:P:V:")) != -1) {
+  while((ch = getopt(argc, argv, "afhm:n:A:F:P:V:")) != -1) {
     switch(ch) {
     case 'h':
       usage(NULL);
@@ -296,6 +299,9 @@ int main(int argc, char *argv[])
     case 'a':
       abort_paused = 1;
       break;
+    case 'f':
+      forbid_reuse = 1;
+      break;
     case 'm':
       max_parallel = (size_t)strtol(optarg, NULL, 10);
       break;
diff --git a/tests/http/clients/upload-pausing.c b/tests/http/clients/upload-pausing.c
index 871fdd382..f5b1b4014 100644
--- a/tests/http/clients/upload-pausing.c
+++ b/tests/http/clients/upload-pausing.c
@@ -133,7 +133,7 @@ static int debug_cb(CURL *handle, curl_infotype type,
   return 0;
 }
 
-#define PAUSE_READ_AFTER  10
+#define PAUSE_READ_AFTER  1
 static size_t total_read = 0;
 
 static size_t read_callback(char *ptr, size_t size, size_t nmemb,
@@ -143,11 +143,13 @@ static size_t read_callback(char *ptr, size_t size, size_t nmemb,
   (void)nmemb;
   (void)userdata;
   if(total_read >= PAUSE_READ_AFTER) {
+    fprintf(stderr, "read_callback, return PAUSE\n");
     return CURL_READFUNC_PAUSE;
   }
   else {
     ptr[0] = '\n';
     ++total_read;
+    fprintf(stderr, "read_callback, return 1 byte\n");
     return 1;
   }
 }
@@ -158,13 +160,19 @@ static int progress_callback(void *clientp,
                              double ultotal,
                              double ulnow)
 {
-  CURL *curl;
   (void)dltotal;
   (void)dlnow;
   (void)ultotal;
   (void)ulnow;
-  curl = (CURL *)clientp;
-  curl_easy_pause(curl, CURLPAUSE_CONT);
+  (void)clientp;
+#if 0
+  /* Used to unpause on progress, but keeping for now. */
+  {
+    CURL *curl = (CURL *)clientp;
+    curl_easy_pause(curl, CURLPAUSE_CONT);
+    /* curl_easy_pause(curl, CURLPAUSE_RECV_CONT); */
+  }
+#endif
   return 0;
 }
 
@@ -233,6 +241,7 @@ int main(int argc, char *argv[])
   curl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, 1L);
   curl_easy_setopt(curl, CURLOPT_TCP_KEEPIDLE, 1L);
   curl_easy_setopt(curl, CURLOPT_TCP_KEEPINTVL, 1L);
+  curl_easy_setopt(curl, CURLOPT_TCP_KEEPCNT, 1L);
 
   /* Enable uploading. */
   curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "POST");
diff --git a/tests/http/scorecard.py b/tests/http/scorecard.py
index d4e19c101..4e4c2c8cb 100644
--- a/tests/http/scorecard.py
+++ b/tests/http/scorecard.py
@@ -106,7 +106,7 @@ class ScoreCard:
             while flen < fsize:
                 fd.write(data1k)
                 flen += len(data1k)
-        return flen
+        return fpath
 
     def _check_downloads(self, r: ExecResult, count: int):
         error = ''
@@ -261,6 +261,163 @@ class ScoreCard:
                 scores[via][label] = results
         return scores
 
+    def _check_uploads(self, r: ExecResult, count: int):
+        error = ''
+        if r.exit_code != 0:
+            error += f'exit={r.exit_code} '
+        if r.exit_code != 0 or len(r.stats) != count:
+            error += f'stats={len(r.stats)}/{count} '
+        fails = [s for s in r.stats if s['response_code'] != 200]
+        if len(fails) > 0:
+            error += f'{len(fails)} failed'
+        for f in fails:
+            error += f'[{f["response_code"]}]'
+        return error if len(error) > 0 else None
+
+    def upload_single(self, url: str, proto: str, fpath: str, count: int):
+        sample_size = count
+        count = 1
+        samples = []
+        errors = []
+        profiles = []
+        self.info(f'single...')
+        for i in range(sample_size):
+            curl = CurlClient(env=self.env, silent=self._silent_curl)
+            r = curl.http_put(urls=[url], fdata=fpath, alpn_proto=proto,
+                              with_headers=False, with_profile=True)
+            err = self._check_uploads(r, count)
+            if err:
+                errors.append(err)
+            else:
+                total_size = sum([s['size_upload'] for s in r.stats])
+                samples.append(total_size / r.duration.total_seconds())
+                profiles.append(r.profile)
+        return {
+            'count': count,
+            'samples': sample_size,
+            'max-parallel': 1,
+            'speed': mean(samples) if len(samples) else -1,
+            'errors': errors,
+            'stats': RunProfile.AverageStats(profiles) if len(profiles) else {},
+        }
+
+    def upload_serial(self, url: str, proto: str, fpath: str, count: int):
+        sample_size = 1
+        samples = []
+        errors = []
+        profiles = []
+        url = f'{url}?id=[0-{count - 1}]'
+        self.info(f'serial...')
+        for i in range(sample_size):
+            curl = CurlClient(env=self.env, silent=self._silent_curl)
+            r = curl.http_put(urls=[url], fdata=fpath, alpn_proto=proto,
+                              with_headers=False, with_profile=True)
+            err = self._check_uploads(r, count)
+            if err:
+                errors.append(err)
+            else:
+                total_size = sum([s['size_upload'] for s in r.stats])
+                samples.append(total_size / r.duration.total_seconds())
+                profiles.append(r.profile)
+        return {
+            'count': count,
+            'samples': sample_size,
+            'max-parallel': 1,
+            'speed': mean(samples) if len(samples) else -1,
+            'errors': errors,
+            'stats': RunProfile.AverageStats(profiles) if len(profiles) else {},
+        }
+
+    def upload_parallel(self, url: str, proto: str, fpath: str, count: int):
+        sample_size = 1
+        samples = []
+        errors = []
+        profiles = []
+        max_parallel = count
+        url = f'{url}?id=[0-{count - 1}]'
+        self.info(f'parallel...')
+        for i in range(sample_size):
+            curl = CurlClient(env=self.env, silent=self._silent_curl)
+            r = curl.http_put(urls=[url], fdata=fpath, alpn_proto=proto,
+                              with_headers=False, with_profile=True,
+                              extra_args=[
+                                   '--parallel',
+                                    '--parallel-max', str(max_parallel)
+                              ])
+            err = self._check_uploads(r, count)
+            if err:
+                errors.append(err)
+            else:
+                total_size = sum([s['size_upload'] for s in r.stats])
+                samples.append(total_size / r.duration.total_seconds())
+                profiles.append(r.profile)
+        return {
+            'count': count,
+            'samples': sample_size,
+            'max-parallel': max_parallel,
+            'speed': mean(samples) if len(samples) else -1,
+            'errors': errors,
+            'stats': RunProfile.AverageStats(profiles) if len(profiles) else {},
+        }
+
+    def upload_url(self, label: str, url: str, fpath: str, proto: str, count: int):
+        self.info(f'  {count}x{label}: ')
+        props = {
+            'single': self.upload_single(url=url, proto=proto, fpath=fpath,
+                                         count=10),
+        }
+        if count > 1:
+            props['serial'] = self.upload_serial(url=url, proto=proto,
+                                                 fpath=fpath, count=count)
+            props['parallel'] = self.upload_parallel(url=url, proto=proto,
+                                                     fpath=fpath, count=count)
+        self.info(f'ok.\n')
+        return props
+
+    def uploads(self, proto: str, count: int,
+                  fsizes: List[int]) -> Dict[str, Any]:
+        scores = {}
+        if self.httpd:
+            if proto == 'h3':
+                port = self.env.h3_port
+                via = 'nghttpx'
+                descr = f'port {port}, proxying httpd'
+            else:
+                port = self.env.https_port
+                via = 'httpd'
+                descr = f'port {port}'
+            self.info(f'{via} uploads\n')
+            scores[via] = {
+                'description': descr,
+            }
+            for fsize in fsizes:
+                label = self.fmt_size(fsize)
+                fname = f'upload{label}.data'
+                fpath = self._make_docs_file(docs_dir=self.env.gen_dir,
+                                             fname=fname, fsize=fsize)
+                url = f'https://{self.env.domain1}:{port}/curltest/put'
+                results = self.upload_url(label=label, url=url, fpath=fpath,
+                                          proto=proto, count=count)
+                scores[via][label] = results
+        if self.caddy:
+            port = self.caddy.port
+            via = 'caddy'
+            descr = f'port {port}'
+            self.info('caddy uploads\n')
+            scores[via] = {
+                'description': descr,
+            }
+            for fsize in fsizes:
+                label = self.fmt_size(fsize)
+                fname = f'upload{label}.data'
+                fpath = self._make_docs_file(docs_dir=self.env.gen_dir,
+                                             fname=fname, fsize=fsize)
+                url = f'https://{self.env.domain2}:{port}/curltest/put'
+                results = self.upload_url(label=label, url=url, fpath=fpath,
+                                          proto=proto, count=count)
+                scores[via][label] = results
+        return scores
+
     def do_requests(self, url: str, proto: str, count: int,
                     max_parallel: int = 1):
         sample_size = 1
@@ -346,6 +503,8 @@ class ScoreCard:
                     handshakes: bool = True,
                     downloads: Optional[List[int]] = None,
                     download_count: int = 50,
+                    uploads: Optional[List[int]] = None,
+                    upload_count: int = 50,
                     req_count=5000,
                     requests: bool = True):
         self.info(f"scoring {proto}\n")
@@ -389,6 +548,10 @@ class ScoreCard:
             score['downloads'] = self.downloads(proto=proto,
                                                 count=download_count,
                                                 fsizes=downloads)
+        if uploads and len(uploads) > 0:
+            score['uploads'] = self.uploads(proto=proto,
+                                                count=upload_count,
+                                                fsizes=uploads)
         if requests:
             score['requests'] = self.requests(proto=proto, req_count=req_count)
         self.info("\n")
@@ -470,6 +633,53 @@ class ScoreCard:
                     else:
                         print(f' {"-":^20}')
 
+        if 'uploads' in score:
+            # get the key names of all sizes and measurements made
+            sizes = []
+            measures = []
+            m_names = {}
+            mcol_width = 12
+            mcol_sw = 17
+            for server, server_score in score['uploads'].items():
+                for sskey, ssval in server_score.items():
+                    if isinstance(ssval, str):
+                        continue
+                    if sskey not in sizes:
+                        sizes.append(sskey)
+                    for mkey, mval in server_score[sskey].items():
+                        if mkey not in measures:
+                            measures.append(mkey)
+                            m_names[mkey] = f'{mkey}({mval["count"]}x{mval["max-parallel"]})'
+
+            print('Uploads')
+            print(f'  {"Server":<8} {"Size":>8}', end='')
+            for m in measures: print(f' {m_names[m]:>{mcol_width}} {"[cpu/rss]":<{mcol_sw}}', end='')
+            print(f' {"Errors":^20}')
+
+            for server in score['uploads']:
+                for size in sizes:
+                    size_score = score['uploads'][server][size]
+                    print(f'  {server:<8} {size:>8}', end='')
+                    errors = []
+                    for key, val in size_score.items():
+                        if 'errors' in val:
+                            errors.extend(val['errors'])
+                    for m in measures:
+                        if m in size_score:
+                            print(f' {self.fmt_mbs(size_score[m]["speed"]):>{mcol_width}}', end='')
+                            stats = size_score[m]["stats"]
+                            if 'cpu' in stats:
+                                s = f'[{stats["cpu"]:>.1f}%/{self.fmt_size(stats["rss"])}]'
+                            else:
+                                s = '[???/???]'
+                            print(f' {s:<{mcol_sw}}', end='')
+                        else:
+                            print(' '*mcol_width, end='')
+                    if len(errors):
+                        print(f' {"/".join(errors):<20}')
+                    else:
+                        print(f' {"-":^20}')
+
         if 'requests' in score:
             sizes = []
             measures = []
@@ -551,6 +761,12 @@ def main():
                         default=50, help="perform that many downloads")
     parser.add_argument("--download-parallel", action='store', type=int,
                         default=0, help="perform that many downloads in parallel (default all)")
+    parser.add_argument("-u", "--uploads", action='store_true',
+                        default=False, help="evaluate uploads")
+    parser.add_argument("--upload", action='append', type=str,
+                        default=None, help="evaluate upload size")
+    parser.add_argument("--upload-count", action='store', type=int,
+                        default=50, help="perform that many uploads")
     parser.add_argument("-r", "--requests", action='store_true',
                         default=False, help="evaluate requests")
     parser.add_argument("--request-count", action='store', type=int,
@@ -578,11 +794,20 @@ def main():
         downloads = []
         for x in args.download:
             downloads.extend([parse_size(s) for s in x.split(',')])
+
+    uploads = [1024 * 1024, 10 * 1024 * 1024, 100 * 1024 * 1024]
+    if args.upload is not None:
+        uploads = []
+        for x in args.upload:
+            uploads.extend([parse_size(s) for s in x.split(',')])
+
     requests = True
-    if args.downloads or args.requests or args.handshakes:
+    if args.downloads or args.uploads or args.requests or args.handshakes:
         handshakes = args.handshakes
         if not args.downloads:
             downloads = None
+        if not args.uploads:
+            uploads = None
         requests = args.requests
 
     test_httpd = protocol != 'h3'
@@ -599,28 +824,33 @@ def main():
     nghttpx = None
     caddy = None
     try:
-        if test_httpd:
+        if test_httpd or (test_caddy and uploads):
+            print(f'httpd: {env.httpd_version()}, http:{env.http_port} https:{env.https_port}')
             httpd = Httpd(env=env)
             assert httpd.exists(), \
                 f'httpd not found: {env.httpd}'
             httpd.clear_logs()
             assert httpd.start()
-            if 'h3' == protocol:
+            if test_httpd and 'h3' == protocol:
                 nghttpx = NghttpxQuic(env=env)
                 nghttpx.clear_logs()
                 assert nghttpx.start()
         if test_caddy and env.caddy:
+            print(f'Caddy: {env.caddy_version()}, http:{env.caddy_http_port} https:{env.caddy_https_port}')
             caddy = Caddy(env=env)
             caddy.clear_logs()
             assert caddy.start()
 
-        card = ScoreCard(env=env, httpd=httpd, nghttpx=nghttpx, caddy=caddy,
+        card = ScoreCard(env=env, httpd=httpd if test_httpd else None,
+                         nghttpx=nghttpx, caddy=caddy if test_caddy else None,
                          verbose=args.verbose, curl_verbose=args.curl_verbose,
                          download_parallel=args.download_parallel)
         score = card.score_proto(proto=protocol,
                                  handshakes=handshakes,
                                  downloads=downloads,
                                  download_count=args.download_count,
+                                 uploads=uploads,
+                                 upload_count=args.upload_count,
                                  req_count=args.request_count,
                                  requests=requests)
         if args.json:
diff --git a/tests/http/test_07_upload.py b/tests/http/test_07_upload.py
index 1aa51d071..95703d352 100644
--- a/tests/http/test_07_upload.py
+++ b/tests/http/test_07_upload.py
@@ -464,10 +464,10 @@ class TestUpload:
                                                     n=1))
                 assert False, f'download {dfile} differs:\n{diff}'
 
-    # upload large data, let connection die while doing it
+    # upload data, pause, let connection die with an incomplete response
     # issues #11769 #13260
     @pytest.mark.parametrize("proto", ['http/1.1', 'h2', 'h3'])
-    def test_07_42_upload_disconnect(self, env: Env, httpd, nghttpx, repeat, proto):
+    def test_07_42a_upload_disconnect(self, env: Env, httpd, nghttpx, repeat, proto):
         if proto == 'h3' and not env.have_h3():
             pytest.skip("h3 not supported")
         if proto == 'h3' and env.curl_uses_lib('msh3'):
@@ -475,10 +475,38 @@ class TestUpload:
         client = LocalClient(name='upload-pausing', env=env, timeout=60)
         if not client.exists():
             pytest.skip(f'example client not built: {client.name}')
-        url = f'http://{env.domain1}:{env.http_port}/curltest/echo?id=[0-0]&die_after=10'
+        url = f'http://{env.domain1}:{env.http_port}/curltest/echo?id=[0-0]&die_after=0'
         r = client.run([url])
         r.check_exit_code(18)  # PARTIAL_FILE
 
+    # upload data, pause, let connection die without any response at all
+    @pytest.mark.parametrize("proto", ['http/1.1', 'h2', 'h3'])
+    def test_07_42b_upload_disconnect(self, env: Env, httpd, nghttpx, repeat, proto):
+        if proto == 'h3' and not env.have_h3():
+            pytest.skip("h3 not supported")
+        if proto == 'h3' and env.curl_uses_lib('msh3'):
+            pytest.skip("msh3 fails here")
+        client = LocalClient(name='upload-pausing', env=env, timeout=60)
+        if not client.exists():
+            pytest.skip(f'example client not built: {client.name}')
+        url = f'http://{env.domain1}:{env.http_port}/curltest/echo?id=[0-0]&just_die=1'
+        r = client.run([url])
+        r.check_exit_code(52)  # GOT_NOTHING
+
+    # upload data, pause, let connection die after 100 continue
+    @pytest.mark.parametrize("proto", ['http/1.1', 'h2', 'h3'])
+    def test_07_42c_upload_disconnect(self, env: Env, httpd, nghttpx, repeat, proto):
+        if proto == 'h3' and not env.have_h3():
+            pytest.skip("h3 not supported")
+        if proto == 'h3' and env.curl_uses_lib('msh3'):
+            pytest.skip("msh3 fails here")
+        client = LocalClient(name='upload-pausing', env=env, timeout=60)
+        if not client.exists():
+            pytest.skip(f'example client not built: {client.name}')
+        url = f'http://{env.domain1}:{env.http_port}/curltest/echo?id=[0-0]&die_after_100=1'
+        r = client.run([url])
+        r.check_exit_code(52)  # GOT_NOTHING
+
     # speed limited on put handler
     @pytest.mark.parametrize("proto", ['http/1.1', 'h2', 'h3'])
     def test_07_50_put_speed_limit(self, env: Env, httpd, nghttpx, proto, repeat):
diff --git a/tests/http/test_08_caddy.py b/tests/http/test_08_caddy.py
index 6b8fce8fe..1e0766412 100644
--- a/tests/http/test_08_caddy.py
+++ b/tests/http/test_08_caddy.py
@@ -61,6 +61,7 @@ class TestCaddy:
         self._make_docs_file(docs_dir=caddy.docs_dir, fname='data5.data', fsize=5*1024*1024)
         self._make_docs_file(docs_dir=caddy.docs_dir, fname='data10.data', fsize=10*1024*1024)
         self._make_docs_file(docs_dir=caddy.docs_dir, fname='data100.data', fsize=100*1024*1024)
+        env.make_data_file(indir=env.gen_dir, fname="data-10m", fsize=10*1024*1024)
 
     # download 1 file
     @pytest.mark.parametrize("proto", ['http/1.1', 'h2', 'h3'])
@@ -151,6 +152,9 @@ class TestCaddy:
             pytest.skip("h3 not supported in curl")
         if proto == 'h3' and env.curl_uses_lib('msh3'):
             pytest.skip("msh3 itself crashes")
+        if proto == 'http/1.1' and env.curl_uses_lib('mbedtls'):
+            pytest.skip("mbedtls 3.6.0 fails on 50 connections with: "\
+                "ssl_handshake returned: (-0x7F00) SSL - Memory allocation failed")
         count = 50
         curl = CurlClient(env=env)
         urln = f'https://{env.domain1}:{caddy.port}/data10.data?[0-{count-1}]'
@@ -164,10 +168,9 @@ class TestCaddy:
         else:
             assert r.total_connects == 1, r.dump_logs()
 
-    # upload data parallel, check that they were echoed
-    @pytest.mark.skipif(condition=Env().ci_run, reason="not suitable for CI runs")
-    @pytest.mark.parametrize("proto", ['h2', 'h3'])
-    def test_08_06_upload_parallel(self, env: Env, caddy, repeat, proto):
+    # post data parallel, check that they were echoed
+    @pytest.mark.parametrize("proto", ['http/1.1', 'h2', 'h3'])
+    def test_08_06_post_parallel(self, env: Env, httpd, caddy, repeat, proto):
         if proto == 'h3' and not env.have_h3():
             pytest.skip("h3 not supported")
         if proto == 'h3' and env.curl_uses_lib('msh3'):
@@ -176,8 +179,29 @@ class TestCaddy:
         count = 20
         data = '0123456789'
         curl = CurlClient(env=env)
-        url = f'https://{env.domain1}:{caddy.port}/data10.data?[0-{count-1}]'
+        url = f'https://{env.domain2}:{caddy.port}/curltest/echo?id=[0-{count-1}]'
         r = curl.http_upload(urls=[url], data=data, alpn_proto=proto,
                              extra_args=['--parallel'])
-        exp_status = 405 if env.caddy_is_at_least('2.7.0') else 200
-        r.check_stats(count=count, http_status=exp_status, exitcode=0)
+        r.check_stats(count=count, http_status=200, exitcode=0)
+        for i in range(0,count):
+            respdata = open(curl.response_file(i)).readlines()
+            assert respdata == [data]
+
+    # put large file, check that they length were echoed
+    @pytest.mark.parametrize("proto", ['http/1.1', 'h2', 'h3'])
+    def test_08_07_put_large(self, env: Env, httpd, caddy, repeat, proto):
+        if proto == 'h3' and not env.have_h3():
+            pytest.skip("h3 not supported")
+        if proto == 'h3' and env.curl_uses_lib('msh3'):
+            pytest.skip("msh3 stalls here")
+        # limit since we use a separate connection in h1<
+        count = 1
+        fdata = os.path.join(env.gen_dir, 'data-10m')
+        curl = CurlClient(env=env)
+        url = f'https://{env.domain2}:{caddy.port}/curltest/put?id=[0-{count-1}]'
+        r = curl.http_put(urls=[url], fdata=fdata, alpn_proto=proto)
+        exp_data = [f'{os.path.getsize(fdata)}']
+        r.check_response(count=count, http_status=200)
+        for i in range(count):
+            respdata = open(curl.response_file(i)).readlines()
+            assert respdata == exp_data
diff --git a/tests/http/test_17_ssl_use.py b/tests/http/test_17_ssl_use.py
index ca8c4c868..813bcffd4 100644
--- a/tests/http/test_17_ssl_use.py
+++ b/tests/http/test_17_ssl_use.py
@@ -65,21 +65,20 @@ class TestSSLUse:
         xargs = ['--sessionid', '--tls-max', tls_max, f'--tlsv{tls_max}']
         if env.curl_uses_lib('gnutls'):
             if tls_max == '1.3':
-                exp_resumed = 'Initial'  # 1.2 works in gnutls, but 1.3 does not, TODO
+                exp_resumed = 'Initial'  # 1.2 works in GnuTLS, but 1.3 does not, TODO
         if env.curl_uses_lib('libressl'):
             if tls_max == '1.3':
-                exp_resumed = 'Initial'  # 1.2 works in libressl, but 1.3 does not, TODO
+                exp_resumed = 'Initial'  # 1.2 works in LibreSSL, but 1.3 does not, TODO
         if env.curl_uses_lib('wolfssl'):
             xargs = ['--sessionid', f'--tlsv{tls_max}']
             if tls_max == '1.3':
-                exp_resumed = 'Initial'  # 1.2 works in wolfssl, but 1.3 does not, TODO
+                exp_resumed = 'Initial'  # 1.2 works in wolfSSL, but 1.3 does not, TODO
         if env.curl_uses_lib('rustls-ffi'):
             exp_resumed = 'Initial'  # rustls does not support sessions, TODO
         if env.curl_uses_lib('bearssl') and tls_max == '1.3':
             pytest.skip('BearSSL does not support TLSv1.3')
-        if env.curl_uses_lib('mbedtls') and tls_max == '1.3' and \
-                not env.curl_lib_version_at_least('mbedtls', '3.6.0'):
-            pytest.skip('mbedtls does not support TLSv1.3')
+        if env.curl_uses_lib('mbedtls') and tls_max == '1.3':
+            pytest.skip('mbedtls TLSv1.3 session resume not working in 3.6.0')
 
         curl = CurlClient(env=env)
         # tell the server to close the connection after each request
@@ -105,8 +104,6 @@ class TestSSLUse:
     # use host name with trailing dot, verify handshake
     @pytest.mark.parametrize("proto", ['http/1.1', 'h2', 'h3'])
     def test_17_03_trailing_dot(self, env: Env, httpd, nghttpx, repeat, proto):
-        if env.curl_uses_lib('gnutls'):
-            pytest.skip("gnutls does not match hostnames with trailing dot")
         if proto == 'h3' and not env.have_h3():
             pytest.skip("h3 not supported")
         curl = CurlClient(env=env)
@@ -139,7 +136,7 @@ class TestSSLUse:
                 assert r.json['SSL_TLS_SNI'] == env.domain1, f'{r.json}'
             assert False, f'should not have succeeded: {r.json}'
         # 7 - rustls rejects a servername with .. during setup
-        # 35 - libressl rejects setting an SNI name with trailing dot
+        # 35 - LibreSSL rejects setting an SNI name with trailing dot
         # 60 - peer name matching failed against certificate
         assert r.exit_code in [7, 35, 60], f'{r}'
 
@@ -147,9 +144,9 @@ class TestSSLUse:
     @pytest.mark.parametrize("proto", ['http/1.1', 'h2', 'h3'])
     def test_17_05_ip_addr(self, env: Env, httpd, nghttpx, repeat, proto):
         if env.curl_uses_lib('bearssl'):
-            pytest.skip("bearssl does not support cert verification with IP addresses")
+            pytest.skip("BearSSL does not support cert verification with IP addresses")
         if env.curl_uses_lib('mbedtls'):
-            pytest.skip("mbedtls does not support cert verification with IP addresses")
+            pytest.skip("mbedTLS does not support cert verification with IP addresses")
         if proto == 'h3' and not env.have_h3():
             pytest.skip("h3 not supported")
         curl = CurlClient(env=env)
@@ -175,3 +172,88 @@ class TestSSLUse:
         assert r.json, f'{r}'
         if proto != 'h3':  # we proxy h3
             assert r.json['SSL_TLS_SNI'] == domain, f'{r.json}'
+
+    # test setting cipher suites, the AES 256 ciphers are disabled in the test server
+    @pytest.mark.parametrize("ciphers, succeed", [
+        [[0x1301], True],
+        [[0x1302], False],
+        [[0x1303], True],
+        [[0x1302, 0x1303], True],
+        [[0xC02B, 0xC02F], True],
+        [[0xC02C, 0xC030], False],
+        [[0xCCA9, 0xCCA8], True],
+        [[0xC02C, 0xC030, 0xCCA9, 0xCCA8], True],
+    ])
+    def test_17_07_ssl_ciphers(self, env: Env, httpd, nghttpx, ciphers, succeed, repeat):
+        cipher_table = {
+           0x1301: 'TLS_AES_128_GCM_SHA256',
+           0x1302: 'TLS_AES_256_GCM_SHA384',
+           0x1303: 'TLS_CHACHA20_POLY1305_SHA256',
+           0xC02B: 'ECDHE-ECDSA-AES128-GCM-SHA256',
+           0xC02F: 'ECDHE-RSA-AES128-GCM-SHA256',
+           0xC02C: 'ECDHE-ECDSA-AES256-GCM-SHA384',
+           0xC030: 'ECDHE-RSA-AES256-GCM-SHA384',
+           0xCCA9: 'ECDHE-ECDSA-CHACHA20-POLY1305',
+           0xCCA8: 'ECDHE-RSA-CHACHA20-POLY1305',
+        }
+        cipher_names = list(map(cipher_table.get, ciphers))
+        proto = 'http/1.1'
+        curl = CurlClient(env=env)
+        url = f'https://{env.authority_for(env.domain1, proto)}/curltest/sslinfo'
+        extra_args = []
+        if env.curl_uses_lib('gnutls'):
+            pytest.skip('GnuTLS does not support setting ciphers by name')
+        if env.curl_uses_lib('rustls-ffi'):
+            pytest.skip('rustls-ffi does not support setting ciphers')
+        if ciphers[0] & 0xFF00 == 0x1300:
+            # test setting TLSv1.3 ciphers
+            if env.curl_uses_lib('bearssl'):
+                pytest.skip('BearSSL does not support TLSv1.3')
+            elif env.curl_uses_lib('sectransp'):
+                pytest.skip('SecureTransport does not support TLSv1.3')
+            elif env.curl_uses_lib('boringssl'):
+                pytest.skip('BoringSSL does not support setting TLSv1.3 ciphers')
+            elif env.curl_uses_lib('mbedtls'):
+                if not env.curl_lib_version_at_least('mbedtls', '3.6.0'):
+                    pytest.skip('mbedTLS TLSv1.3 support requires at least 3.6.0')
+                extra_args = ['--ciphers', ':'.join(cipher_names)]
+            elif env.curl_uses_lib('wolfssl'):
+                extra_args = ['--ciphers', ':'.join(cipher_names)]
+            else:
+                extra_args = ['--tls13-ciphers', ':'.join(cipher_names)]
+        else:
+            # test setting TLSv1.2 ciphers
+            if env.curl_uses_lib('schannel'):
+                pytest.skip('Schannel does not support setting TLSv1.2 ciphers by name')
+            elif env.curl_uses_lib('wolfssl'):
+                # setting tls version is botched with wolfssl: setting max (--tls-max)
+                # is not supported, setting min (--tlsv1.*) actually also sets max
+                extra_args = ['--tlsv1.2', '--ciphers', ':'.join(cipher_names)]
+            else:
+                # the server supports TLSv1.3, so to test TLSv1.2 ciphers we set tls-max
+                extra_args = ['--tls-max', '1.2', '--ciphers', ':'.join(cipher_names)]
+        r = curl.http_get(url=url, alpn_proto=proto, extra_args=extra_args)
+        if succeed:
+            assert r.exit_code == 0, f'{r}'
+            assert r.json['HTTPS'] == 'on', f'{r.json}'
+            assert 'SSL_CIPHER' in r.json, f'{r.json}'
+            assert r.json['SSL_CIPHER'] in cipher_names, f'{r.json}'
+        else:
+            assert r.exit_code != 0, f'{r}'
+
+    @pytest.mark.parametrize("proto", ['http/1.1', 'h2', 'h3'])
+    def test_17_08_cert_status(self, env: Env, httpd, nghttpx, repeat, proto):
+        if proto == 'h3' and not env.have_h3():
+            pytest.skip("h3 not supported")
+        if not env.curl_uses_lib('openssl') and \
+            not env.curl_uses_lib('gnutls') and \
+            not env.curl_uses_lib('quictls'):
+            pytest.skip("TLS library does not support --cert-status")
+        curl = CurlClient(env=env)
+        domain = f'localhost'
+        url = f'https://{env.authority_for(domain, proto)}/'
+        r = curl.http_get(url=url, alpn_proto=proto, extra_args=[
+            '--cert-status'
+        ])
+        # CURLE_SSL_INVALIDCERTSTATUS, our certs have no OCSP info
+        assert r.exit_code == 91, f'{r}'
diff --git a/tests/http/test_18_methods.py b/tests/http/test_18_methods.py
index fca3ee2d8..e959f19aa 100644
--- a/tests/http/test_18_methods.py
+++ b/tests/http/test_18_methods.py
@@ -76,4 +76,3 @@ class TestMethods:
                 '&chunks=1&chunk_size=0&chunk_delay=10ms'
         r = curl.http_delete(urls=[url], alpn_proto=proto)
         r.check_stats(count=count, http_status=204, exitcode=0)
-
diff --git a/tests/http/test_19_shutdown.py b/tests/http/test_19_shutdown.py
new file mode 100644
index 000000000..21ddc1ad2
--- /dev/null
+++ b/tests/http/test_19_shutdown.py
@@ -0,0 +1,174 @@
+#!/usr/bin/env python3
+# -*- coding: utf-8 -*-
+#***************************************************************************
+#                                  _   _ ____  _
+#  Project                     ___| | | |  _ \| |
+#                             / __| | | | |_) | |
+#                            | (__| |_| |  _ <| |___
+#                             \___|\___/|_| \_\_____|
+#
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+#
+# This software is licensed as described in the file COPYING, which
+# you should have received as part of this distribution. The terms
+# are also available at https://curl.se/docs/copyright.html.
+#
+# You may opt to use, copy, modify, merge, publish, distribute and/or sell
+# copies of the Software, and permit persons to whom the Software is
+# furnished to do so, under the terms of the COPYING file.
+#
+# This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+# KIND, either express or implied.
+#
+# SPDX-License-Identifier: curl
+#
+###########################################################################
+#
+import difflib
+import filecmp
+import logging
+import os
+import re
+from datetime import timedelta
+import pytest
+
+from testenv import Env, CurlClient, LocalClient
+
+
+log = logging.getLogger(__name__)
+
+
+class TestShutdown:
+
+    @pytest.fixture(autouse=True, scope='class')
+    def _class_scope(self, env, httpd, nghttpx):
+        if env.have_h3():
+            nghttpx.start_if_needed()
+        httpd.clear_extra_configs()
+        httpd.reload()
+
+    @pytest.fixture(autouse=True, scope='class')
+    def _class_scope(self, env, httpd):
+        indir = httpd.docs_dir
+        env.make_data_file(indir=indir, fname="data-10k", fsize=10*1024)
+        env.make_data_file(indir=indir, fname="data-100k", fsize=100*1024)
+        env.make_data_file(indir=indir, fname="data-1m", fsize=1024*1024)
+
+    # check with `tcpdump` that we see curl TCP RST packets
+    @pytest.mark.skipif(condition=not Env.tcpdump(), reason="tcpdump not available")
+    @pytest.mark.parametrize("proto", ['http/1.1'])
+    def test_19_01_check_tcp_rst(self, env: Env, httpd, repeat, proto):
+        if env.ci_run:
+            pytest.skip("seems not to work in CI")
+        curl = CurlClient(env=env)
+        url = f'https://{env.authority_for(env.domain1, proto)}/data.json?[0-1]'
+        r = curl.http_download(urls=[url], alpn_proto=proto, with_tcpdump=True, extra_args=[
+            '--parallel'
+        ])
+        r.check_response(http_status=200, count=2)
+        assert r.tcpdump
+        assert len(r.tcpdump.stats) != 0, f'Expected TCP RSTs packets: {r.tcpdump.stderr}'
+
+    # check with `tcpdump` that we do NOT see TCP RST when CURL_GRACEFUL_SHUTDOWN set
+    @pytest.mark.skipif(condition=not Env.tcpdump(), reason="tcpdump not available")
+    @pytest.mark.parametrize("proto", ['http/1.1', 'h2'])
+    def test_19_02_check_shutdown(self, env: Env, httpd, repeat, proto):
+        if not env.curl_is_debug():
+            pytest.skip('only works for curl debug builds')
+        curl = CurlClient(env=env, run_env={
+            'CURL_GRACEFUL_SHUTDOWN': '2000',
+            'CURL_DEBUG': 'ssl'
+        })
+        url = f'https://{env.authority_for(env.domain1, proto)}/data.json?[0-1]'
+        r = curl.http_download(urls=[url], alpn_proto=proto, with_tcpdump=True, extra_args=[
+            '--parallel'
+        ])
+        r.check_response(http_status=200, count=2)
+        assert r.tcpdump
+        assert len(r.tcpdump.stats) == 0, f'Unexpected TCP RSTs packets'
+
+    # run downloads where the server closes the connection after each request
+    @pytest.mark.parametrize("proto", ['http/1.1'])
+    def test_19_03_shutdown_by_server(self, env: Env, httpd, repeat, proto):
+        if not env.curl_is_debug():
+            pytest.skip('only works for curl debug builds')
+        count = 10
+        curl = CurlClient(env=env, run_env={
+            'CURL_GRACEFUL_SHUTDOWN': '2000',
+            'CURL_DEBUG': 'ssl'
+        })
+        url = f'https://{env.authority_for(env.domain1, proto)}/curltest/tweak/?'\
+            f'id=[0-{count-1}]&with_cl&close'
+        r = curl.http_download(urls=[url], alpn_proto=proto)
+        r.check_response(http_status=200, count=count)
+        shutdowns = [l for l in r.trace_lines if re.match(r'.*CCACHE\] shutdown #\d+, done=1', l)]
+        assert len(shutdowns) == count, f'{shutdowns}'
+
+    # run downloads with CURLOPT_FORBID_REUSE set, meaning *we* close
+    # the connection after each request
+    @pytest.mark.parametrize("proto", ['http/1.1'])
+    def test_19_04_shutdown_by_curl(self, env: Env, httpd, proto, repeat):
+        if not env.curl_is_debug():
+            pytest.skip('only works for curl debug builds')
+        count = 10
+        docname = 'data.json'
+        url = f'https://localhost:{env.https_port}/{docname}'
+        client = LocalClient(name='h2-download', env=env, run_env={
+            'CURL_GRACEFUL_SHUTDOWN': '2000',
+            'CURL_DEBUG': 'ssl'
+        })
+        if not client.exists():
+            pytest.skip(f'example client not built: {client.name}')
+        r = client.run(args=[
+             '-n', f'{count}', '-f', '-V', proto, url
+        ])
+        r.check_exit_code(0)
+        shutdowns = [l for l in r.trace_lines if re.match(r'.*CCACHE\] shutdown #\d+, done=1', l)]
+        assert len(shutdowns) == count, f'{shutdowns}'
+
+    # run event-based downloads with CURLOPT_FORBID_REUSE set, meaning *we* close
+    # the connection after each request
+    @pytest.mark.parametrize("proto", ['http/1.1'])
+    def test_19_05_event_shutdown_by_server(self, env: Env, httpd, proto, repeat):
+        if not env.curl_is_debug():
+            pytest.skip('only works for curl debug builds')
+        count = 10
+        curl = CurlClient(env=env, run_env={
+            # forbid connection reuse to trigger shutdowns after transfer
+            'CURL_FORBID_REUSE': '1',
+            # make socket receives block 50% of the time to delay shutdown
+            'CURL_DBG_SOCK_RBLOCK': '50',
+            'CURL_DEBUG': 'ssl'
+        })
+        url = f'https://{env.authority_for(env.domain1, proto)}/curltest/tweak/?'\
+            f'id=[0-{count-1}]&with_cl&'
+        r = curl.http_download(urls=[url], alpn_proto=proto, extra_args=[
+            '--test-event'
+        ])
+        r.check_response(http_status=200, count=count)
+        # check that we closed all connections
+        closings = [l for l in r.trace_lines if re.match(r'.*CCACHE\] closing #\d+', l)]
+        assert len(closings) == count, f'{closings}'
+        # check that all connection sockets were removed from event
+        removes = [l for l in r.trace_lines if re.match(r'.*socket cb: socket \d+ REMOVED', l)]
+        assert len(removes) == count, f'{removes}'
+
+    # check graceful shutdown on multiplexed http
+    @pytest.mark.parametrize("proto", ['h2', 'h3'])
+    def test_19_06_check_shutdown(self, env: Env, httpd, nghttpx, repeat, proto):
+        if proto == 'h3' and not env.have_h3():
+            pytest.skip("h3 not supported")
+        if not env.curl_is_debug():
+            pytest.skip('only works for curl debug builds')
+        curl = CurlClient(env=env, run_env={
+            'CURL_GRACEFUL_SHUTDOWN': '2000',
+            'CURL_DEBUG': 'all'
+        })
+        url = f'https://{env.authority_for(env.domain1, proto)}/data.json?[0-1]'
+        r = curl.http_download(urls=[url], alpn_proto=proto, with_tcpdump=True, extra_args=[
+            '--parallel'
+        ])
+        r.check_response(http_status=200, count=2)
+        # check connection cache closings
+        shutdowns = [l for l in r.trace_lines if re.match(r'.*CCACHE\] shutdown #\d+, done=1', l)]
+        assert len(shutdowns) == 1, f'{shutdowns}'
diff --git a/tests/http/test_30_vsftpd.py b/tests/http/test_30_vsftpd.py
index af52e10f8..477b27aff 100644
--- a/tests/http/test_30_vsftpd.py
+++ b/tests/http/test_30_vsftpd.py
@@ -67,6 +67,9 @@ class TestVsFTPD:
         self._make_docs_file(docs_dir=vsftpd.docs_dir, fname='data-10k', fsize=10*1024)
         self._make_docs_file(docs_dir=vsftpd.docs_dir, fname='data-1m', fsize=1024*1024)
         self._make_docs_file(docs_dir=vsftpd.docs_dir, fname='data-10m', fsize=10*1024*1024)
+        env.make_data_file(indir=env.gen_dir, fname="upload-1k", fsize=1024)
+        env.make_data_file(indir=env.gen_dir, fname="upload-100k", fsize=100*1024)
+        env.make_data_file(indir=env.gen_dir, fname="upload-1m", fsize=1024*1024)
 
     def test_30_01_list_dir(self, env: Env, vsftpd: VsFTPD, repeat):
         curl = CurlClient(env=env)
@@ -115,6 +118,51 @@ class TestVsFTPD:
         r.check_stats(count=count, http_status=226)
         self.check_downloads(curl, srcfile, count)
 
+    @pytest.mark.parametrize("docname", [
+        'upload-1k', 'upload-100k', 'upload-1m'
+    ])
+    def test_30_05_upload_1(self, env: Env, vsftpd: VsFTPD, docname, repeat):
+        curl = CurlClient(env=env)
+        srcfile = os.path.join(env.gen_dir, docname)
+        dstfile = os.path.join(vsftpd.docs_dir, docname)
+        self._rmf(dstfile)
+        count = 1
+        url = f'ftp://{env.ftp_domain}:{vsftpd.port}/'
+        r = curl.ftp_upload(urls=[url], fupload=f'{srcfile}', with_stats=True)
+        r.check_stats(count=count, http_status=226)
+        self.check_upload(env, vsftpd, docname=docname)
+
+    def _rmf(self, path):
+        if os.path.exists(path):
+            return os.remove(path)
+
+    # check with `tcpdump` if curl causes any TCP RST packets
+    @pytest.mark.skipif(condition=not Env.tcpdump(), reason="tcpdump not available")
+    def test_30_06_shutdownh_download(self, env: Env, vsftpd: VsFTPD, repeat):
+        docname = 'data-1k'
+        curl = CurlClient(env=env)
+        count = 1
+        url = f'ftp://{env.ftp_domain}:{vsftpd.port}/{docname}?[0-{count-1}]'
+        r = curl.ftp_get(urls=[url], with_stats=True, with_tcpdump=True)
+        r.check_stats(count=count, http_status=226)
+        assert r.tcpdump
+        assert len(r.tcpdump.stats) == 0, f'Unexpected TCP RSTs packets'
+
+    # check with `tcpdump` if curl causes any TCP RST packets
+    @pytest.mark.skipif(condition=not Env.tcpdump(), reason="tcpdump not available")
+    def test_30_07_shutdownh_upload(self, env: Env, vsftpd: VsFTPD, repeat):
+        docname = 'upload-1k'
+        curl = CurlClient(env=env)
+        srcfile = os.path.join(env.gen_dir, docname)
+        dstfile = os.path.join(vsftpd.docs_dir, docname)
+        self._rmf(dstfile)
+        count = 1
+        url = f'ftp://{env.ftp_domain}:{vsftpd.port}/'
+        r = curl.ftp_upload(urls=[url], fupload=f'{srcfile}', with_stats=True, with_tcpdump=True)
+        r.check_stats(count=count, http_status=226)
+        assert r.tcpdump
+        assert len(r.tcpdump.stats) == 0, f'Unexpected TCP RSTs packets'
+
     def check_downloads(self, client, srcfile: str, count: int,
                         complete: bool = True):
         for i in range(count):
@@ -128,5 +176,15 @@ class TestVsFTPD:
                                                     n=1))
                 assert False, f'download {dfile} differs:\n{diff}'
 
-
-
+    def check_upload(self, env, vsftpd: VsFTPD, docname):
+        srcfile = os.path.join(env.gen_dir, docname)
+        dstfile = os.path.join(vsftpd.docs_dir, docname)
+        assert os.path.exists(srcfile)
+        assert os.path.exists(dstfile)
+        if not filecmp.cmp(srcfile, dstfile, shallow=False):
+            diff = "".join(difflib.unified_diff(a=open(srcfile).readlines(),
+                                                b=open(dstfile).readlines(),
+                                                fromfile=srcfile,
+                                                tofile=dstfile,
+                                                n=1))
+            assert False, f'upload {dstfile} differs:\n{diff}'
diff --git a/tests/http/test_31_vsftpds.py b/tests/http/test_31_vsftpds.py
index 7dd4b3f81..2434677c0 100644
--- a/tests/http/test_31_vsftpds.py
+++ b/tests/http/test_31_vsftpds.py
@@ -38,9 +38,6 @@ log = logging.getLogger(__name__)
 
 
 @pytest.mark.skipif(condition=not Env.has_vsftpd(), reason=f"missing vsftpd")
-# rustsl: transfers sometimes fail with "received corrupt message of type InvalidContentType"
-# sporadic, never seen when filter tracing is on
-@pytest.mark.skipif(condition=Env.curl_uses_lib('rustls-ffi'), reason=f"rustls unreliable here")
 class TestVsFTPD:
 
     SUPPORTS_SSL = True
@@ -77,6 +74,9 @@ class TestVsFTPD:
         self._make_docs_file(docs_dir=vsftpds.docs_dir, fname='data-10k', fsize=10*1024)
         self._make_docs_file(docs_dir=vsftpds.docs_dir, fname='data-1m', fsize=1024*1024)
         self._make_docs_file(docs_dir=vsftpds.docs_dir, fname='data-10m', fsize=10*1024*1024)
+        env.make_data_file(indir=env.gen_dir, fname="upload-1k", fsize=1024)
+        env.make_data_file(indir=env.gen_dir, fname="upload-100k", fsize=100*1024)
+        env.make_data_file(indir=env.gen_dir, fname="upload-1m", fsize=1024*1024)
 
     def test_31_01_list_dir(self, env: Env, vsftpds: VsFTPD, repeat):
         curl = CurlClient(env=env)
@@ -125,6 +125,53 @@ class TestVsFTPD:
         r.check_stats(count=count, http_status=226)
         self.check_downloads(curl, srcfile, count)
 
+    @pytest.mark.parametrize("docname", [
+        'upload-1k', 'upload-100k', 'upload-1m'
+    ])
+    def test_31_05_upload_1(self, env: Env, vsftpds: VsFTPD, docname, repeat):
+        curl = CurlClient(env=env)
+        srcfile = os.path.join(env.gen_dir, docname)
+        dstfile = os.path.join(vsftpds.docs_dir, docname)
+        self._rmf(dstfile)
+        count = 1
+        url = f'ftp://{env.ftp_domain}:{vsftpds.port}/'
+        r = curl.ftp_ssl_upload(urls=[url], fupload=f'{srcfile}', with_stats=True)
+        r.check_stats(count=count, http_status=226)
+        self.check_upload(env, vsftpds, docname=docname)
+
+    def _rmf(self, path):
+        if os.path.exists(path):
+            return os.remove(path)
+
+    # check with `tcpdump` if curl causes any TCP RST packets
+    @pytest.mark.skipif(condition=not Env.tcpdump(), reason="tcpdump not available")
+    def test_31_06_shutdownh_download(self, env: Env, vsftpds: VsFTPD, repeat):
+        docname = 'data-1k'
+        curl = CurlClient(env=env)
+        count = 1
+        url = f'ftp://{env.ftp_domain}:{vsftpds.port}/{docname}?[0-{count-1}]'
+        r = curl.ftp_ssl_get(urls=[url], with_stats=True, with_tcpdump=True)
+        r.check_stats(count=count, http_status=226)
+        # vsftp closes control connection without niceties,
+        # disregard RST packets it sent from its port to curl
+        assert len(r.tcpdump.stats_excluding(src_port=env.ftps_port)) == 0, f'Unexpected TCP RSTs packets'
+
+    # check with `tcpdump` if curl causes any TCP RST packets
+    @pytest.mark.skipif(condition=not Env.tcpdump(), reason="tcpdump not available")
+    def test_31_07_shutdownh_upload(self, env: Env, vsftpds: VsFTPD, repeat):
+        docname = 'upload-1k'
+        curl = CurlClient(env=env)
+        srcfile = os.path.join(env.gen_dir, docname)
+        dstfile = os.path.join(vsftpds.docs_dir, docname)
+        self._rmf(dstfile)
+        count = 1
+        url = f'ftp://{env.ftp_domain}:{vsftpds.port}/'
+        r = curl.ftp_ssl_upload(urls=[url], fupload=f'{srcfile}', with_stats=True, with_tcpdump=True)
+        r.check_stats(count=count, http_status=226)
+        # vsftp closes control connection without niceties,
+        # disregard RST packets it sent from its port to curl
+        assert len(r.tcpdump.stats_excluding(src_port=env.ftps_port)) == 0, f'Unexpected TCP RSTs packets'
+
     def check_downloads(self, client, srcfile: str, count: int,
                         complete: bool = True):
         for i in range(count):
@@ -138,5 +185,15 @@ class TestVsFTPD:
                                                     n=1))
                 assert False, f'download {dfile} differs:\n{diff}'
 
-
-
+    def check_upload(self, env, vsftpd: VsFTPD, docname):
+        srcfile = os.path.join(env.gen_dir, docname)
+        dstfile = os.path.join(vsftpd.docs_dir, docname)
+        assert os.path.exists(srcfile)
+        assert os.path.exists(dstfile)
+        if not filecmp.cmp(srcfile, dstfile, shallow=False):
+            diff = "".join(difflib.unified_diff(a=open(srcfile).readlines(),
+                                                b=open(dstfile).readlines(),
+                                                fromfile=srcfile,
+                                                tofile=dstfile,
+                                                n=1))
+            assert False, f'upload {dstfile} differs:\n{diff}'
diff --git a/tests/http/testenv/caddy.py b/tests/http/testenv/caddy.py
index ea1343a95..12f38a75c 100644
--- a/tests/http/testenv/caddy.py
+++ b/tests/http/testenv/caddy.py
@@ -141,6 +141,8 @@ class Caddy:
     def _write_config(self):
         domain1 = self.env.domain1
         creds1 = self.env.get_credentials(domain1)
+        domain2 = self.env.domain2
+        creds2 = self.env.get_credentials(domain2)
         self._mkpath(self._docs_dir)
         self._mkpath(self._tmp_dir)
         with open(os.path.join(self._docs_dir, 'data.json'), 'w') as fd:
@@ -163,5 +165,10 @@ class Caddy:
                 f'  }}',
                 f'  tls {creds1.cert_file} {creds1.pkey_file}',
                 f'}}',
+                f'{domain2} {{',
+                f'  reverse_proxy /* http://localhost:{self.env.http_port} {{',
+                f'  }}',
+                f'  tls {creds2.cert_file} {creds2.pkey_file}',
+                f'}}',
             ]
             fd.write("\n".join(conf))
diff --git a/tests/http/testenv/curl.py b/tests/http/testenv/curl.py
index 23b70b293..f89b2c9a8 100644
--- a/tests/http/testenv/curl.py
+++ b/tests/http/testenv/curl.py
@@ -27,6 +27,10 @@
 import json
 import logging
 import os
+import sys
+import time
+from threading import Thread
+
 import psutil
 import re
 import shutil
@@ -103,6 +107,85 @@ class RunProfile:
                f'stats={self.stats}]'
 
 
+class RunTcpDump:
+
+    def __init__(self, env, run_dir):
+        self._env = env
+        self._run_dir = run_dir
+        self._proc = None
+        self._stdoutfile = os.path.join(self._run_dir, 'tcpdump.out')
+        self._stderrfile = os.path.join(self._run_dir, 'tcpdump.err')
+
+    @property
+    def stats(self) -> Optional[List[str]]:
+        if self._proc:
+            raise Exception('tcpdump still running')
+        lines = []
+        for l in open(self._stdoutfile).readlines():
+            if re.match(r'.* IP 127\.0\.0\.1\.\d+ [<>] 127\.0\.0\.1\.\d+:.*', l):
+                lines.append(l)
+        return lines
+
+    def stats_excluding(self, src_port) -> Optional[List[str]]:
+        if self._proc:
+            raise Exception('tcpdump still running')
+        lines = []
+        for l in self.stats:
+            if not re.match(r'.* IP 127\.0\.0\.1\.' + str(src_port) + ' >.*', l):
+                lines.append(l)
+        return lines
+
+    @property
+    def stderr(self) -> List[str]:
+        if self._proc:
+            raise Exception('tcpdump still running')
+        lines = []
+        return open(self._stderrfile).readlines()
+
+    def sample(self):
+        # not sure how to make that detection reliable for all platforms
+        local_if = 'lo0' if sys.platform.startswith('darwin') else 'lo'
+        try:
+            tcpdump = self._env.tcpdump()
+            if tcpdump is None:
+                raise Exception('tcpdump not available')
+            # look with tcpdump for TCP RST packets which indicate
+            # we did not shut down connections cleanly
+            args = []
+            # at least on Linux, we need root permissions to run tcpdump
+            if sys.platform.startswith('linux'):
+                args.append('sudo')
+            args.extend([
+                tcpdump, '-i', local_if, '-n', 'tcp[tcpflags] & (tcp-rst)!=0'
+            ])
+            with open(self._stdoutfile, 'w') as cout:
+                with open(self._stderrfile, 'w') as cerr:
+                    self._proc = subprocess.Popen(args, stdout=cout, stderr=cerr,
+                                                  text=True, cwd=self._run_dir,
+                                                  shell=False)
+                    assert self._proc
+                    assert self._proc.returncode is None
+                    while self._proc:
+                        try:
+                            self._proc.wait(timeout=1)
+                        except subprocess.TimeoutExpired:
+                            pass
+        except Exception as e:
+            log.error(f'Tcpdump: {e}')
+
+    def start(self):
+        def do_sample():
+            self.sample()
+        t = Thread(target=do_sample)
+        t.start()
+
+    def finish(self):
+        if self._proc:
+            time.sleep(1)
+            self._proc.terminate()
+            self._proc = None
+
+
 class ExecResult:
 
     def __init__(self, args: List[str], exit_code: int,
@@ -110,13 +193,15 @@ class ExecResult:
                  duration: Optional[timedelta] = None,
                  with_stats: bool = False,
                  exception: Optional[str] = None,
-                 profile: Optional[RunProfile] = None):
+                 profile: Optional[RunProfile] = None,
+                 tcpdump: Optional[RunTcpDump] = None):
         self._args = args
         self._exit_code = exit_code
         self._exception = exception
         self._stdout = stdout
         self._stderr = stderr
         self._profile = profile
+        self._tcpdump = tcpdump
         self._duration = duration if duration is not None else timedelta()
         self._response = None
         self._responses = []
@@ -185,6 +270,10 @@ class ExecResult:
     def profile(self) -> Optional[RunProfile]:
         return self._profile
 
+    @property
+    def tcpdump(self) -> Optional[RunTcpDump]:
+        return self._tcpdump
+
     @property
     def response(self) -> Optional[Dict]:
         return self._response
@@ -359,8 +448,11 @@ class CurlClient:
         'h3': '--http3-only',
     }
 
-    def __init__(self, env: Env, run_dir: Optional[str] = None,
-                 timeout: Optional[float] = None, silent: bool = False):
+    def __init__(self, env: Env,
+                 run_dir: Optional[str] = None,
+                 timeout: Optional[float] = None,
+                 silent: bool = False,
+                 run_env: Optional[Dict[str, str]] = None):
         self.env = env
         self._timeout = timeout if timeout else env.test_timeout
         self._curl = os.environ['CURL'] if 'CURL' in os.environ else env.curl
@@ -370,6 +462,7 @@ class CurlClient:
         self._headerfile = f'{self._run_dir}/curl.headers'
         self._log_path = f'{self._run_dir}/curl.log'
         self._silent = silent
+        self._run_env = run_env
         self._rmrf(self._run_dir)
         self._mkpath(self._run_dir)
 
@@ -418,18 +511,21 @@ class CurlClient:
                  alpn_proto: Optional[str] = None,
                  def_tracing: bool = True,
                  with_stats: bool = False,
-                 with_profile: bool = False):
+                 with_profile: bool = False,
+                 with_tcpdump: bool = False):
         return self._raw(url, options=extra_args,
                          with_stats=with_stats,
                          alpn_proto=alpn_proto,
                          def_tracing=def_tracing,
-                         with_profile=with_profile)
+                         with_profile=with_profile,
+                         with_tcpdump=with_tcpdump)
 
     def http_download(self, urls: List[str],
                       alpn_proto: Optional[str] = None,
                       with_stats: bool = True,
                       with_headers: bool = False,
                       with_profile: bool = False,
+                      with_tcpdump: bool = False,
                       no_save: bool = False,
                       extra_args: List[str] = None):
         if extra_args is None:
@@ -452,13 +548,15 @@ class CurlClient:
         return self._raw(urls, alpn_proto=alpn_proto, options=extra_args,
                          with_stats=with_stats,
                          with_headers=with_headers,
-                         with_profile=with_profile)
+                         with_profile=with_profile,
+                         with_tcpdump=with_tcpdump)
 
     def http_upload(self, urls: List[str], data: str,
                     alpn_proto: Optional[str] = None,
                     with_stats: bool = True,
                     with_headers: bool = False,
                     with_profile: bool = False,
+                    with_tcpdump: bool = False,
                     extra_args: Optional[List[str]] = None):
         if extra_args is None:
             extra_args = []
@@ -472,7 +570,8 @@ class CurlClient:
         return self._raw(urls, alpn_proto=alpn_proto, options=extra_args,
                          with_stats=with_stats,
                          with_headers=with_headers,
-                         with_profile=with_profile)
+                         with_profile=with_profile,
+                         with_tcpdump=with_tcpdump)
 
     def http_delete(self, urls: List[str],
                     alpn_proto: Optional[str] = None,
@@ -541,6 +640,7 @@ class CurlClient:
     def ftp_get(self, urls: List[str],
                       with_stats: bool = True,
                       with_profile: bool = False,
+                      with_tcpdump: bool = False,
                       no_save: bool = False,
                       extra_args: List[str] = None):
         if extra_args is None:
@@ -563,11 +663,13 @@ class CurlClient:
         return self._raw(urls, options=extra_args,
                          with_stats=with_stats,
                          with_headers=False,
-                         with_profile=with_profile)
+                         with_profile=with_profile,
+                         with_tcpdump=with_tcpdump)
 
     def ftp_ssl_get(self, urls: List[str],
                       with_stats: bool = True,
                       with_profile: bool = False,
+                      with_tcpdump: bool = False,
                       no_save: bool = False,
                       extra_args: List[str] = None):
         if extra_args is None:
@@ -577,8 +679,44 @@ class CurlClient:
         ])
         return self.ftp_get(urls=urls, with_stats=with_stats,
                             with_profile=with_profile, no_save=no_save,
+                            with_tcpdump=with_tcpdump,
                             extra_args=extra_args)
 
+    def ftp_upload(self, urls: List[str], fupload,
+                   with_stats: bool = True,
+                   with_profile: bool = False,
+                   with_tcpdump: bool = False,
+                   extra_args: List[str] = None):
+        if extra_args is None:
+            extra_args = []
+        extra_args.extend([
+            '--upload-file', fupload
+        ])
+        if with_stats:
+            extra_args.extend([
+                '-w', '%{json}\\n'
+            ])
+        return self._raw(urls, options=extra_args,
+                         with_stats=with_stats,
+                         with_headers=False,
+                         with_profile=with_profile,
+                         with_tcpdump=with_tcpdump)
+
+    def ftp_ssl_upload(self, urls: List[str], fupload,
+                       with_stats: bool = True,
+                       with_profile: bool = False,
+                       with_tcpdump: bool = False,
+                       extra_args: List[str] = None):
+        if extra_args is None:
+            extra_args = []
+        extra_args.extend([
+            '--ssl-reqd',
+        ])
+        return self.ftp_upload(urls=urls, fupload=fupload,
+                               with_stats=with_stats, with_profile=with_profile,
+                               with_tcpdump=with_tcpdump,
+                               extra_args=extra_args)
+
     def response_file(self, idx: int):
         return os.path.join(self._run_dir, f'download_{idx}.data')
 
@@ -594,14 +732,18 @@ class CurlClient:
         my_args.extend(args)
         return self._run(args=my_args, with_stats=with_stats, with_profile=with_profile)
 
-    def _run(self, args, intext='', with_stats: bool = False, with_profile: bool = True):
+    def _run(self, args, intext='', with_stats: bool = False,
+             with_profile: bool = True, with_tcpdump: bool = False):
         self._rmf(self._stdoutfile)
         self._rmf(self._stderrfile)
         self._rmf(self._headerfile)
-        started_at = datetime.now()
         exception = None
         profile = None
+        tcpdump = None
         started_at = datetime.now()
+        if with_tcpdump:
+            tcpdump = RunTcpDump(self.env, self._run_dir)
+            tcpdump.start()
         try:
             with open(self._stdoutfile, 'w') as cout:
                 with open(self._stderrfile, 'w') as cerr:
@@ -610,7 +752,8 @@ class CurlClient:
                             if self._timeout else None
                         log.info(f'starting: {args}')
                         p = subprocess.Popen(args, stderr=cerr, stdout=cout,
-                                             cwd=self._run_dir, shell=False)
+                                             cwd=self._run_dir, shell=False,
+                                             env=self._run_env)
                         profile = RunProfile(p.pid, started_at, self._run_dir)
                         if intext is not None and False:
                             p.communicate(input=intext.encode(), timeout=1)
@@ -632,7 +775,8 @@ class CurlClient:
                         p = subprocess.run(args, stderr=cerr, stdout=cout,
                                            cwd=self._run_dir, shell=False,
                                            input=intext.encode() if intext else None,
-                                           timeout=self._timeout)
+                                           timeout=self._timeout,
+                                           env=self._run_env)
                         exitcode = p.returncode
         except subprocess.TimeoutExpired:
             now = datetime.now()
@@ -641,13 +785,15 @@ class CurlClient:
                         f'(configured {self._timeout}s): {args}')
             exitcode = -1
             exception = 'TimeoutExpired'
+        if tcpdump:
+            tcpdump.finish()
         coutput = open(self._stdoutfile).readlines()
         cerrput = open(self._stderrfile).readlines()
         return ExecResult(args=args, exit_code=exitcode, exception=exception,
                           stdout=coutput, stderr=cerrput,
                           duration=datetime.now() - started_at,
                           with_stats=with_stats,
-                          profile=profile)
+                          profile=profile, tcpdump=tcpdump)
 
     def _raw(self, urls, intext='', timeout=None, options=None, insecure=False,
              alpn_proto: Optional[str] = None,
@@ -655,13 +801,14 @@ class CurlClient:
              with_stats=False,
              with_headers=True,
              def_tracing=True,
-             with_profile=False):
+             with_profile=False,
+             with_tcpdump=False):
         args = self._complete_args(
             urls=urls, timeout=timeout, options=options, insecure=insecure,
             alpn_proto=alpn_proto, force_resolve=force_resolve,
             with_headers=with_headers, def_tracing=def_tracing)
         r = self._run(args, intext=intext, with_stats=with_stats,
-                      with_profile=with_profile)
+                      with_profile=with_profile, with_tcpdump=with_tcpdump)
         if r.exit_code == 0 and with_headers:
             self._parse_headerfile(self._headerfile, r=r)
             if r.json:
diff --git a/tests/http/testenv/env.py b/tests/http/testenv/env.py
index 067fe4f3e..2cd643236 100644
--- a/tests/http/testenv/env.py
+++ b/tests/http/testenv/env.py
@@ -27,6 +27,7 @@
 import logging
 import os
 import re
+import shutil
 import socket
 import subprocess
 import sys
@@ -203,6 +204,8 @@ class EnvConfig:
             except Exception as e:
                 self.vsftpd = None
 
+        self._tcpdump = shutil.which('tcpdump')
+
     @property
     def httpd_version(self):
         if self._httpd_version is None and self.apxs is not None:
@@ -264,6 +267,10 @@ class EnvConfig:
     def vsftpd_version(self):
         return self._vsftpd_version
 
+    @property
+    def tcpdmp(self) -> Optional[str]:
+        return self._tcpdump
+
 
 class Env:
 
@@ -383,6 +390,10 @@ class Env:
     def vsftpd_version() -> str:
         return Env.CONFIG.vsftpd_version
 
+    @staticmethod
+    def tcpdump() -> Optional[str]:
+        return Env.CONFIG.tcpdmp
+
     def __init__(self, pytestconfig=None):
         self._verbose = pytestconfig.option.verbose \
             if pytestconfig is not None else 0
diff --git a/tests/http/testenv/httpd.py b/tests/http/testenv/httpd.py
index 5580c8427..4771ea360 100644
--- a/tests/http/testenv/httpd.py
+++ b/tests/http/testenv/httpd.py
@@ -1,4 +1,5 @@
 #!/usr/bin/env python3
+#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 #***************************************************************************
 #                                  _   _ ____  _
@@ -246,6 +247,7 @@ class Httpd:
                 f'ErrorLog {self._error_log}',
                 f'LogLevel {self._get_log_level()}',
                 f'StartServers 4',
+                f'ReadBufferSize 16000',
                 f'H2MinWorkers 16',
                 f'H2MaxWorkers 256',
                 f'H2Direct on',
@@ -255,6 +257,13 @@ class Httpd:
                 f'Listen {self.env.proxys_port}',
                 f'TypesConfig "{self._conf_dir}/mime.types',
                 f'SSLSessionCache "shmcb:ssl_gcache_data(32000)"',
+                (f'SSLCipherSuite SSL'
+                 f' ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256'
+                 f':ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305'
+                ),
+                (f'SSLCipherSuite TLSv1.3'
+                 f' TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256'
+                ),
             ]
             if 'base' in self._extra_configs:
                 conf.extend(self._extra_configs['base'])
@@ -305,6 +314,18 @@ class Httpd:
                 f'</VirtualHost>',
                 f'',
             ])
+            conf.extend([  # plain http host for domain2
+                f'<VirtualHost *:{self.env.http_port}>',
+                f'    ServerName {domain2}',
+                f'    ServerAlias localhost',
+                f'    DocumentRoot "{self._docs_dir}"',
+                f'    Protocols h2c http/1.1',
+            ])
+            conf.extend(self._curltest_conf(domain2))
+            conf.extend([
+                f'</VirtualHost>',
+                f'',
+            ])
             conf.extend([  # https host for domain2, no h2
                 f'<VirtualHost *:{self.env.https_port}>',
                 f'    ServerName {domain2}',
diff --git a/tests/http/testenv/mod_curltest/mod_curltest.c b/tests/http/testenv/mod_curltest/mod_curltest.c
index abe97a3c0..58b952563 100644
--- a/tests/http/testenv/mod_curltest/mod_curltest.c
+++ b/tests/http/testenv/mod_curltest/mod_curltest.c
@@ -186,6 +186,7 @@ static int curltest_echo_handler(request_rec *r)
   char buffer[8192];
   const char *ct;
   apr_off_t die_after_len = -1, total_read_len = 0;
+  int just_die = 0, die_after_100 = 0;
   long l;
 
   if(strcmp(r->handler, "curltest-echo")) {
@@ -208,16 +209,35 @@ static int curltest_echo_handler(request_rec *r)
         val = s + 1;
         if(!strcmp("die_after", arg)) {
           die_after_len = (apr_off_t)apr_atoi64(val);
+          continue;
+        }
+        else if(!strcmp("just_die", arg)) {
+          just_die = 1;
+          continue;
+        }
+        else if(!strcmp("die_after_100", arg)) {
+          die_after_100 = 1;
+          continue;
         }
       }
     }
   }
 
+  if(just_die) {
+    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+                  "echo_handler: dying right away");
+    /* Generate no HTTP response at all. */
+    ap_remove_output_filter_byhandle(r->output_filters, "HTTP_HEADER");
+    r->connection->keepalive = AP_CONN_CLOSE;
+    return AP_FILTER_ERROR;
+  }
+
   r->status = 200;
   if(die_after_len >= 0) {
     r->clength = die_after_len + 1;
     r->chunked = 0;
-    apr_table_set(r->headers_out, "Content-Length", apr_ltoa(r->pool, (long)r->clength));
+    apr_table_set(r->headers_out, "Content-Length",
+                  apr_ltoa(r->pool, (long)r->clength));
   }
   else {
     r->clength = -1;
@@ -235,6 +255,14 @@ static int curltest_echo_handler(request_rec *r)
   bb = apr_brigade_create(r->pool, c->bucket_alloc);
   /* copy any request body into the response */
   if((rv = ap_setup_client_block(r, REQUEST_CHUNKED_DECHUNK))) goto cleanup;
+  if(die_after_100) {
+    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+                  "echo_handler: dying after 100-continue");
+    /* Generate no HTTP response at all. */
+    ap_remove_output_filter_byhandle(r->output_filters, "HTTP_HEADER");
+    r->connection->keepalive = AP_CONN_CLOSE;
+    return AP_FILTER_ERROR;
+  }
   if(ap_should_client_block(r)) {
     while(0 < (l = ap_get_client_block(r, &buffer[0], sizeof(buffer)))) {
       total_read_len += l;
@@ -242,6 +270,8 @@ static int curltest_echo_handler(request_rec *r)
         ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
                       "echo_handler: dying after %ld bytes as requested",
                       (long)total_read_len);
+        ap_pass_brigade(r->output_filters, bb);
+        ap_remove_output_filter_byhandle(r->output_filters, "HTTP_HEADER");
         r->connection->keepalive = AP_CONN_CLOSE;
         return DONE;
       }
@@ -294,10 +324,11 @@ static int curltest_tweak_handler(request_rec *r)
   int i, chunks = 3, error_bucket = 1;
   size_t chunk_size = sizeof(buffer);
   const char *request_id = "none";
-  apr_time_t delay = 0, chunk_delay = 0;
+  apr_time_t delay = 0, chunk_delay = 0, close_delay = 0;
   apr_array_header_t *args = NULL;
   int http_status = 200;
   apr_status_t error = APR_SUCCESS, body_error = APR_SUCCESS;
+  int close_conn = 0, with_cl = 0;
 
   if(strcmp(r->handler, "curltest-tweak")) {
     return DECLINED;
@@ -375,6 +406,21 @@ static int curltest_tweak_handler(request_rec *r)
             continue;
           }
         }
+        else if(!strcmp("close_delay", arg)) {
+          rv = duration_parse(&close_delay, val, "s");
+          if(APR_SUCCESS == rv) {
+            continue;
+          }
+        }
+      }
+      else if(!strcmp("close", arg)) {
+        /* we are asked to close the connection */
+        close_conn = 1;
+        continue;
+      }
+      else if(!strcmp("with_cl", arg)) {
+        with_cl = 1;
+        continue;
       }
       ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "query parameter not "
                     "understood: '%s' in %s",
@@ -387,10 +433,15 @@ static int curltest_tweak_handler(request_rec *r)
   ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, "error_handler: processing "
                 "request, %s", r->args? r->args : "(no args)");
   r->status = http_status;
-  r->clength = -1;
-  r->chunked = (r->proto_num >= HTTP_VERSION(1,1));
+  r->clength = with_cl? (chunks * chunk_size) : -1;
+  r->chunked = (r->proto_num >= HTTP_VERSION(1,1)) && !with_cl;
   apr_table_setn(r->headers_out, "request-id", request_id);
-  apr_table_unset(r->headers_out, "Content-Length");
+  if(r->clength >= 0) {
+    apr_table_set(r->headers_out, "Content-Length",
+                  apr_ltoa(r->pool, (long)r->clength));
+  }
+  else
+    apr_table_unset(r->headers_out, "Content-Length");
   /* Discourage content-encodings */
   apr_table_unset(r->headers_out, "Content-Encoding");
   apr_table_setn(r->subprocess_env, "no-brotli", "1");
@@ -437,9 +488,19 @@ static int curltest_tweak_handler(request_rec *r)
                 "error_handler: response passed");
 
 cleanup:
+  if(close_conn) {
+    if(close_delay) {
+      b = apr_bucket_flush_create(c->bucket_alloc);
+      APR_BRIGADE_INSERT_TAIL(bb, b);
+      rv = ap_pass_brigade(r->output_filters, bb);
+      apr_brigade_cleanup(bb);
+      apr_sleep(close_delay);
+    }
+    r->connection->keepalive = AP_CONN_CLOSE;
+  }
   ap_log_rerror(APLOG_MARK, APLOG_TRACE1, rv, r,
-                "error_handler: request cleanup, r->status=%d, aborted=%d",
-                r->status, c->aborted);
+                "error_handler: request cleanup, r->status=%d, aborted=%d, "
+                "close=%d", r->status, c->aborted, close_conn);
   if(rv == APR_SUCCESS) {
     return OK;
   }
@@ -461,7 +522,7 @@ static int curltest_put_handler(request_rec *r)
   apr_bucket_brigade *bb;
   apr_bucket *b;
   apr_status_t rv;
-  char buffer[16*1024];
+  char buffer[128*1024];
   const char *ct;
   apr_off_t rbody_len = 0;
   const char *s_rbody_len;
diff --git a/tests/http/testenv/vsftpd.py b/tests/http/testenv/vsftpd.py
index 4ba0132e6..8daa7b0f6 100644
--- a/tests/http/testenv/vsftpd.py
+++ b/tests/http/testenv/vsftpd.py
@@ -190,16 +190,19 @@ class VsFTPD:
             f'anonymous_enable=YES',
             f'anon_root={self._docs_dir}',
             f'dirmessage_enable=YES',
+            f'write_enable=YES',
+            f'anon_upload_enable=YES',
             f'log_ftp_protocol=YES',
             f'xferlog_enable=YES',
-            f'xferlog_std_format=YES',
-            f'xferlog_file={self._error_log}',
+            f'xferlog_std_format=NO',
+            f'vsftpd_log_file={self._error_log}',
             f'\n',
         ]
         if self._with_ssl:
             creds = self.env.get_credentials(self.domain)
             conf.extend([
                 f'ssl_enable=YES',
+                f'debug_ssl=YES',
                 f'allow_anon_ssl=YES',
                 f'rsa_cert_file={creds.cert_file}',
                 f'rsa_private_key_file={creds.pkey_file}',
diff --git a/tests/http2-server.pl b/tests/http2-server.pl
index 52c5284c0..d4367da63 100755
--- a/tests/http2-server.pl
+++ b/tests/http2-server.pl
@@ -116,4 +116,4 @@ my $cmdline="$nghttpx --backend=$connect ".
     "--errorlog-file=$logfile ".
     "$keyfile $certfile";
 print "RUN: $cmdline\n" if($verbose);
-system("$cmdline 2>/dev/null");
+exec("exec $cmdline 2>/dev/null");
diff --git a/tests/http3-server.pl b/tests/http3-server.pl
index bc9e98ad1..97e6998be 100755
--- a/tests/http3-server.pl
+++ b/tests/http3-server.pl
@@ -116,4 +116,4 @@ my $cmdline="$nghttpx --http2-proxy --backend=$connect ".
     "--conf=$conf ".
     "$keyfile $certfile";
 print "RUN: $cmdline\n" if($verbose);
-system("$cmdline 2>/dev/null");
+exec("exec $cmdline 2>/dev/null");
diff --git a/tests/libtest/CMakeLists.txt b/tests/libtest/CMakeLists.txt
index b6450ff3a..b2a352046 100644
--- a/tests/libtest/CMakeLists.txt
+++ b/tests/libtest/CMakeLists.txt
@@ -23,7 +23,7 @@
 ###########################################################################
 set(TARGET_LABEL_PREFIX "Test ")
 
-function(setup_test TEST_NAME)          # ARGN are the files in the test
+function(setup_test TEST_NAME)  # ARGN are the files in the test
 
   if(LIB_SELECTED STREQUAL LIB_STATIC)
     # These are part of the libcurl static lib. Do not compile/link them again.
@@ -35,10 +35,10 @@ function(setup_test TEST_NAME)          # ARGN are the files in the test
   string(TOUPPER ${TEST_NAME} UPPER_TEST_NAME)
 
   include_directories(
-    ${CURL_SOURCE_DIR}/lib          # To be able to reach "curl_setup_once.h"
-    ${CURL_BINARY_DIR}/lib          # To be able to reach "curl_config.h"
-    ${CURL_BINARY_DIR}/include      # To be able to reach "curl/curl.h"
-    ${CURL_SOURCE_DIR}/tests/libtest # To be able to build generated tests
+    ${CURL_SOURCE_DIR}/lib            # for "curl_setup_once.h"
+    ${CURL_BINARY_DIR}/lib            # for "curl_config.h"
+    ${CURL_BINARY_DIR}/include        # for "curl/curl.h"
+    ${CURL_SOURCE_DIR}/tests/libtest  # to be able to build generated tests
     )
   if(USE_ARES)
     include_directories(${CARES_INCLUDE_DIR})
@@ -72,7 +72,7 @@ if(NOT WIN32)
   # Output to .libs for compatibility with autotools, the test data expects a
   # library at (tests)/libtest/.libs/libhostname.so
   set_target_properties(hostname PROPERTIES
-      LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/.libs)
+    LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/.libs)
   if(HIDES_CURL_PRIVATE_SYMBOLS)
     set_property(TARGET hostname APPEND PROPERTY COMPILE_DEFINITIONS "CURL_HIDDEN_SYMBOLS")
     set_property(TARGET hostname APPEND PROPERTY COMPILE_FLAGS ${CURL_CFLAG_SYMBOLS_HIDE})
diff --git a/tests/libtest/Makefile.am b/tests/libtest/Makefile.am
index 8ae972a24..eed916eeb 100644
--- a/tests/libtest/Makefile.am
+++ b/tests/libtest/Makefile.am
@@ -134,7 +134,7 @@ CS_ = $(CS_0)
 checksrc:
 	$(CHECKSRC)@PERL@ $(top_srcdir)/scripts/checksrc.pl -D$(srcdir) $(srcdir)/*.[ch]
 
-if CURLDEBUG
+if DEBUGBUILD
 # for debug builds, we scan the sources on all regular make invokes
 all-local: checksrc
 endif
diff --git a/tests/libtest/Makefile.inc b/tests/libtest/Makefile.inc
index 1a11895e7..371f26656 100644
--- a/tests/libtest/Makefile.inc
+++ b/tests/libtest/Makefile.inc
@@ -54,6 +54,7 @@ noinst_PROGRAMS = chkhostname libauthretry libntlmconnect libprereq      \
  lib670 lib671 lib672 lib673 lib674 lib676 lib677 lib678 \
  lib1156 \
  lib1301 \
+ lib1485 \
  lib1500 lib1501 lib1502 lib1503 lib1504 lib1505 lib1506 lib1507 lib1508 \
  lib1509 lib1510 lib1511 lib1512 lib1513 lib1514 lib1515         lib1517 \
  lib1518         lib1520 lib1521 lib1522 lib1523 \
@@ -346,6 +347,9 @@ lib678_LDADD = $(TESTUTIL_LIBS)
 lib1301_SOURCES = lib1301.c $(SUPPORTFILES) $(TESTUTIL)
 lib1301_LDADD = $(TESTUTIL_LIBS)
 
+lib1485_SOURCES = lib1485.c $(SUPPORTFILES) $(TESTUTIL) $(WARNLESS)
+lib1485_LDADD = $(TESTUTIL_LIBS)
+
 lib1500_SOURCES = lib1500.c $(SUPPORTFILES) $(TESTUTIL)
 lib1500_LDADD = $(TESTUTIL_LIBS)
 
@@ -483,7 +487,7 @@ lib1551_SOURCES = lib1551.c $(SUPPORTFILES)
 lib1552_SOURCES = lib1552.c $(SUPPORTFILES) $(TESTUTIL)
 lib1552_LDADD = $(TESTUTIL_LIBS)
 
-lib1553_SOURCES = lib1553.c $(SUPPORTFILES) $(TESTUTIL)
+lib1553_SOURCES = lib1553.c $(SUPPORTFILES) $(TSTTRACE) $(TESTUTIL)
 lib1553_LDADD = $(TESTUTIL_LIBS)
 
 lib1554_SOURCES = lib1554.c $(SUPPORTFILES)
diff --git a/tests/libtest/lib1485.c b/tests/libtest/lib1485.c
new file mode 100644
index 000000000..e1710ee2f
--- /dev/null
+++ b/tests/libtest/lib1485.c
@@ -0,0 +1,120 @@
+/***************************************************************************
+ *                                  _   _ ____  _
+ *  Project                     ___| | | |  _ \| |
+ *                             / __| | | | |_) | |
+ *                            | (__| |_| |  _ <| |___
+ *                             \___|\___/|_| \_\_____|
+ *
+ * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+ *
+ * This software is licensed as described in the file COPYING, which
+ * you should have received as part of this distribution. The terms
+ * are also available at https://curl.se/docs/copyright.html.
+ *
+ * You may opt to use, copy, modify, merge, publish, distribute and/or sell
+ * copies of the Software, and permit persons to whom the Software is
+ * furnished to do so, under the terms of the COPYING file.
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+ * KIND, either express or implied.
+ *
+ * SPDX-License-Identifier: curl
+ *
+ ***************************************************************************/
+#include "test.h"
+
+#include "testutil.h"
+#include "warnless.h"
+#include "memdebug.h"
+
+struct transfer_status {
+  CURL *easy;
+  curl_off_t out_len;
+  size_t hd_line;
+  CURLcode result;
+  int http_status;
+};
+
+static size_t header_callback(void *ptr, size_t size, size_t nmemb,
+                              void *userp)
+{
+  struct transfer_status *st = (struct transfer_status *)userp;
+  const char *hd = ptr;
+  size_t len = size * nmemb;
+  CURLcode result;
+
+  (void)fwrite(ptr, size, nmemb, stdout);
+  ++st->hd_line;
+  if(len == 2 && hd[0] == '\r' && hd[1] == '\n') {
+    curl_off_t clen;
+    long httpcode = 0;
+    /* end of a response */
+    result = curl_easy_getinfo(st->easy, CURLINFO_RESPONSE_CODE, &httpcode);
+    fprintf(stderr, "header_callback, get status: %ld, %d\n",
+            httpcode, result);
+    if(httpcode < 100 || httpcode >= 1000) {
+      fprintf(stderr, "header_callback, invalid status: %ld, %d\n",
+              httpcode, result);
+      return CURLE_WRITE_ERROR;
+    }
+    st->http_status = (int)httpcode;
+    if(st->http_status >= 200 && st->http_status < 300) {
+      result = curl_easy_getinfo(st->easy, CURLINFO_CONTENT_LENGTH_DOWNLOAD_T,
+                                 &clen);
+      fprintf(stderr, "header_callback, info Content-Length: %ld, %d\n",
+              (long)clen, result);
+      if(result) {
+        st->result = result;
+        return CURLE_WRITE_ERROR;
+      }
+      if(clen < 0) {
+        fprintf(stderr, "header_callback, expected known Content-Length, "
+                "got: %ld\n", (long)clen);
+        return CURLE_WRITE_ERROR;
+      }
+    }
+  }
+  return len;
+}
+
+static size_t write_callback(void *ptr, size_t size, size_t nmemb, void *userp)
+{
+  struct transfer_status *st = (struct transfer_status *)userp;
+  size_t len = size * nmemb;
+  fwrite(ptr, size, nmemb, stdout);
+  st->out_len += (curl_off_t)len;
+  return len;
+}
+
+CURLcode test(char *URL)
+{
+  CURL *curls = NULL;
+  CURLcode res = CURLE_OK;
+  struct transfer_status st;
+
+  start_test_timing();
+
+  memset(&st, 0, sizeof(st));
+
+  global_init(CURL_GLOBAL_ALL);
+
+  easy_init(curls);
+  st.easy = curls; /* to allow callbacks access */
+
+  easy_setopt(curls, CURLOPT_URL, URL);
+  easy_setopt(curls, CURLOPT_WRITEFUNCTION, write_callback);
+  easy_setopt(curls, CURLOPT_WRITEDATA, &st);
+  easy_setopt(curls, CURLOPT_HEADERFUNCTION, header_callback);
+  easy_setopt(curls, CURLOPT_HEADERDATA, &st);
+
+  easy_setopt(curls, CURLOPT_NOPROGRESS, 1L);
+
+  res = curl_easy_perform(curls);
+
+test_cleanup:
+
+  curl_easy_cleanup(curls);
+  curl_global_cleanup();
+
+  return res; /* return the final return code */
+}
diff --git a/tests/libtest/lib1553.c b/tests/libtest/lib1553.c
index 97053991a..998c0762a 100644
--- a/tests/libtest/lib1553.c
+++ b/tests/libtest/lib1553.c
@@ -24,6 +24,7 @@
 #include "test.h"
 
 #include "testutil.h"
+#include "testtrace.h"
 #include "warnless.h"
 #include "memdebug.h"
 
@@ -74,6 +75,12 @@ CURLcode test(char *URL)
   easy_setopt(curls, CURLOPT_XFERINFOFUNCTION, xferinfo);
   easy_setopt(curls, CURLOPT_NOPROGRESS, 1L);
 
+  libtest_debug_config.nohex = 1;
+  libtest_debug_config.tracetime = 1;
+  test_setopt(curls, CURLOPT_DEBUGDATA, &libtest_debug_config);
+  easy_setopt(curls, CURLOPT_DEBUGFUNCTION, libtest_debug_cb);
+  easy_setopt(curls, CURLOPT_VERBOSE, 1L);
+
   multi_add_handle(multi, curls);
 
   multi_perform(multi, &still_running);
diff --git a/tests/libtest/lib1560.c b/tests/libtest/lib1560.c
index 934fc78fd..0109d6edd 100644
--- a/tests/libtest/lib1560.c
+++ b/tests/libtest/lib1560.c
@@ -151,6 +151,9 @@ struct clearurlcase {
 };
 
 static const struct testcase get_parts_list[] ={
+  {"curl.se",
+   "[10] | [11] | [12] | [13] | curl.se | [15] | / | [16] | [17]",
+   CURLU_GUESS_SCHEME, CURLU_NO_GUESS_SCHEME, CURLUE_OK},
   {"https://curl.se:0/#",
    "https | [11] | [12] | [13] | curl.se | 0 | / | [16] | ",
    0, CURLU_GET_EMPTY, CURLUE_OK},
@@ -526,6 +529,9 @@ static const struct testcase get_parts_list[] ={
 };
 
 static const struct urltestcase get_url_list[] = {
+  {"example.com",
+   "example.com/",
+   CURLU_GUESS_SCHEME, CURLU_NO_GUESS_SCHEME, CURLUE_OK},
   {"http://user@example.com?#",
    "http://user@example.com/?#",
    0, CURLU_GET_EMPTY, CURLUE_OK},
diff --git a/tests/libtest/lib1970.c b/tests/libtest/lib1970.c
index c7013ae1d..f0b9d517b 100644
--- a/tests/libtest/lib1970.c
+++ b/tests/libtest/lib1970.c
@@ -5,7 +5,7 @@
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2022, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
diff --git a/tests/libtest/lib1971.c b/tests/libtest/lib1971.c
index 91d016500..8f4be08b2 100644
--- a/tests/libtest/lib1971.c
+++ b/tests/libtest/lib1971.c
@@ -5,7 +5,7 @@
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2022, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
diff --git a/tests/libtest/lib1972.c b/tests/libtest/lib1972.c
index 2872218bb..a51c45018 100644
--- a/tests/libtest/lib1972.c
+++ b/tests/libtest/lib1972.c
@@ -5,7 +5,7 @@
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2022, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
diff --git a/tests/libtest/lib1973.c b/tests/libtest/lib1973.c
index 96974115a..4b2ba95c6 100644
--- a/tests/libtest/lib1973.c
+++ b/tests/libtest/lib1973.c
@@ -5,7 +5,7 @@
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2022, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
diff --git a/tests/libtest/lib1974.c b/tests/libtest/lib1974.c
index 9f1a40023..41922fa60 100644
--- a/tests/libtest/lib1974.c
+++ b/tests/libtest/lib1974.c
@@ -5,7 +5,7 @@
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2022, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
diff --git a/tests/libtest/lib1975.c b/tests/libtest/lib1975.c
index 49bd7201d..0cd9be24b 100644
--- a/tests/libtest/lib1975.c
+++ b/tests/libtest/lib1975.c
@@ -5,7 +5,7 @@
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2022, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
diff --git a/tests/libtest/lib3026.c b/tests/libtest/lib3026.c
index 7e914010e..74e1c32b8 100644
--- a/tests/libtest/lib3026.c
+++ b/tests/libtest/lib3026.c
@@ -29,7 +29,7 @@
 #define NUM_THREADS 100
 
 #ifdef _WIN32
-#ifdef _WIN32_WCE
+#if defined(_WIN32_WCE) || defined(CURL_WINDOWS_APP)
 static DWORD WINAPI run_thread(LPVOID ptr)
 #else
 #include <process.h>
@@ -47,7 +47,7 @@ static unsigned int WINAPI run_thread(void *ptr)
 
 CURLcode test(char *URL)
 {
-#ifdef _WIN32_WCE
+#if defined(_WIN32_WCE) || defined(CURL_WINDOWS_APP)
   typedef HANDLE curl_win_thread_handle_t;
 #else
   typedef uintptr_t curl_win_thread_handle_t;
@@ -78,7 +78,7 @@ CURLcode test(char *URL)
   for(i = 0; i < tid_count; i++) {
     curl_win_thread_handle_t th;
     results[i] = CURL_LAST; /* initialize with invalid value */
-#ifdef _WIN32_WCE
+#if defined(_WIN32_WCE) || defined(CURL_WINDOWS_APP)
     th = CreateThread(NULL, 0, run_thread, &results[i], 0, NULL);
 #else
     th = _beginthreadex(NULL, 0, run_thread, &results[i], 0, NULL);
diff --git a/tests/libtest/lib539.c b/tests/libtest/lib539.c
index ebd6af120..2e079fae3 100644
--- a/tests/libtest/lib539.c
+++ b/tests/libtest/lib539.c
@@ -55,18 +55,11 @@ CURLcode test(char *URL)
 
    /*
     * Change the FTP_FILEMETHOD option to use full paths rather than a CWD
-    * command.  Alter the URL's path a bit, appending a "./".  Use an innocuous
-    * QUOTE command, after which curl will CWD to ftp_conn->entrypath and then
-    * (on the next call to ftp_statemach_act) find a non-zero ftpconn->dirdepth
-    * even though no directories are stored in the ftpconn->dirs array (after a
-    * call to freedirs).
+    * command. Use an innocuous QUOTE command, after which curl will CWD to
+    * ftp_conn->entrypath and then (on the next call to ftp_statemach_act)
+    * find a non-zero ftpconn->dirdepth even though no directories are stored
+    * in the ftpconn->dirs array (after a call to freedirs).
     */
-   newURL = aprintf("%s./", URL);
-   if(!newURL) {
-     curl_easy_cleanup(curl);
-     curl_global_cleanup();
-     return TEST_ERR_MAJOR_BAD;
-   }
 
    slist = curl_slist_append(NULL, "SYST");
    if(!slist) {
@@ -76,7 +69,7 @@ CURLcode test(char *URL)
      return TEST_ERR_MAJOR_BAD;
    }
 
-   test_setopt(curl, CURLOPT_URL, newURL);
+   test_setopt(curl, CURLOPT_URL, libtest_arg2);
    test_setopt(curl, CURLOPT_FTP_FILEMETHOD, (long) CURLFTPMETHOD_NOCWD);
    test_setopt(curl, CURLOPT_QUOTE, slist);
 
diff --git a/tests/libtest/lib574.c b/tests/libtest/lib574.c
index 3d7ecfc8b..0d107ef11 100644
--- a/tests/libtest/lib574.c
+++ b/tests/libtest/lib574.c
@@ -31,8 +31,8 @@ static int new_fnmatch(void *ptr,
                        const char *pattern, const char *string)
 {
   (void)ptr;
-  (void)pattern;
-  (void)string;
+  fprintf(stderr, "lib574: match string '%s' against pattern '%s'\n",
+          string, pattern);
   return CURL_FNMATCHFUNC_MATCH;
 }
 
diff --git a/tests/libtest/test1013.pl b/tests/libtest/test1013.pl
index aec7fb902..9ae7723a2 100755
--- a/tests/libtest/test1013.pl
+++ b/tests/libtest/test1013.pl
@@ -44,9 +44,6 @@ close CURL;
 $curl_protocols =~ s/\r//;
 $curl_protocols =~ /\w+: (.*)$/;
 @curl = split / /,$1;
-
-# These features are not supported by curl-config
-@curl = grep(!/^(Debug|TrackMemory|CharConv)$/i, @curl);
 @curl = sort @curl;
 
 # Read the output of curl-config
diff --git a/tests/libtest/testutil.c b/tests/libtest/testutil.c
index efbbf9019..2d334e979 100644
--- a/tests/libtest/testutil.c
+++ b/tests/libtest/testutil.c
@@ -133,6 +133,10 @@ double tutil_tvdiff_secs(struct timeval newer, struct timeval older)
 #ifdef _WIN32
 HMODULE win32_load_system_library(const TCHAR *filename)
 {
+#ifdef CURL_WINDOWS_APP
+  (void)filename;
+  return NULL;
+#else
   size_t filenamelen = _tcslen(filename);
   size_t systemdirlen = GetSystemDirectory(NULL, 0);
   size_t written;
@@ -158,5 +162,6 @@ HMODULE win32_load_system_library(const TCHAR *filename)
   _tcscpy(path + written, filename);
 
   return LoadLibrary(path);
+#endif
 }
 #endif
diff --git a/tests/runner.pm b/tests/runner.pm
index a6a26c9d0..22ca0c7fd 100644
--- a/tests/runner.pm
+++ b/tests/runner.pm
@@ -662,7 +662,7 @@ sub singletest_setenv {
                         logmsg "Skipping LD_PRELOAD due to lack of OS support\n" if($verbose);
                         next;
                     }
-                    if($feature{"debug"} || !$has_shared) {
+                    if($feature{"Debug"} || !$has_shared) {
                         logmsg "Skipping LD_PRELOAD due to no release shared build\n" if($verbose);
                         next;
                     }
@@ -857,6 +857,7 @@ sub singletest_run {
         else {
             $cmdargs .= "--trace-ascii $LOGDIR/trace$testnum ";
         }
+        $cmdargs .= "--trace-config all ";
         $cmdargs .= "--trace-time ";
         if($run_event_based) {
             $cmdargs .= "--test-event ";
diff --git a/tests/runtests.pl b/tests/runtests.pl
index ddfab20e8..e5d8e3da0 100755
--- a/tests/runtests.pl
+++ b/tests/runtests.pl
@@ -60,6 +60,7 @@ use strict;
 # Promote all warnings to fatal
 use warnings FATAL => 'all';
 use 5.006;
+use POSIX qw(strftime);
 
 # These should be the only variables that might be needed to get edited:
 
@@ -447,6 +448,13 @@ sub compare {
     return $result;
 }
 
+#######################################################################
+# Numeric-sort words in a string
+sub numsortwords {
+    my ($string)=@_;
+    return join(' ', sort { $a <=> $b } split(' ', $string));
+}
+
 #######################################################################
 # Parse and store the protocols in curl's Protocols: line
 sub parseprotocols {
@@ -492,6 +500,10 @@ sub checksystemfeatures {
     $versretval = runclient($versioncmd);
     $versnoexec = $!;
 
+    my $current_time = int(time());
+    $ENV{'SOURCE_DATE_EPOCH'} = $current_time;
+    $DATE = strftime "%Y-%m-%d", gmtime($current_time);
+
     open(my $versout, "<", "$curlverout");
     @version = <$versout>;
     close($versout);
@@ -512,6 +524,8 @@ sub checksystemfeatures {
         if($_ =~ /^curl ([^ ]*)/) {
             $curl = $_;
             $CURLVERSION = $1;
+            $CURLVERNUM = $CURLVERSION;
+            $CURLVERNUM =~ s/^([0-9.]+)(.*)/$1/; # leading dots and numbers
             $curl =~ s/^(.*)(libcurl.*)/$1/g || die "Failure determining curl binary version";
 
             $libcurl = $2;
@@ -606,19 +620,19 @@ sub checksystemfeatures {
             # built with memory tracking support (--enable-curldebug); may be disabled later
             $feature{"TrackMemory"} = $feat =~ /TrackMemory/i;
             # curl was built with --enable-debug
-            $feature{"debug"} = $feat =~ /debug/i;
+            $feature{"Debug"} = $feat =~ /Debug/i;
             # ssl enabled
             $feature{"SSL"} = $feat =~ /SSL/i;
             # multiple ssl backends available.
             $feature{"MultiSSL"} = $feat =~ /MultiSSL/i;
             # large file support
-            $feature{"large_file"} = $feat =~ /Largefile/i;
+            $feature{"Largefile"} = $feat =~ /Largefile/i;
             # IDN support
-            $feature{"idn"} = $feat =~ /IDN/i;
+            $feature{"IDN"} = $feat =~ /IDN/i;
             # IPv6 support
-            $feature{"ipv6"} = $feat =~ /IPv6/i;
+            $feature{"IPv6"} = $feat =~ /IPv6/i;
             # Unix sockets support
-            $feature{"unix-sockets"} = $feat =~ /UnixSockets/i;
+            $feature{"UnixSockets"} = $feat =~ /UnixSockets/i;
             # libz compression
             $feature{"libz"} = $feat =~ /libz/i;
             # Brotli compression
@@ -637,8 +651,6 @@ sub checksystemfeatures {
             $feature{"Kerberos"} = $feat =~ /Kerberos/i;
             # SPNEGO enabled
             $feature{"SPNEGO"} = $feat =~ /SPNEGO/i;
-            # CharConv enabled
-            $feature{"CharConv"} = $feat =~ /CharConv/i;
             # TLS-SRP enabled
             $feature{"TLS-SRP"} = $feat =~ /TLS-SRP/i;
             # PSL enabled
@@ -665,8 +677,8 @@ sub checksystemfeatures {
                 push @protocols, 'http/3';
             }
             # https proxy support
-            $feature{"https-proxy"} = $feat =~ /HTTPS-proxy/;
-            if($feature{"https-proxy"}) {
+            $feature{"HTTPS-proxy"} = $feat =~ /HTTPS-proxy/;
+            if($feature{"HTTPS-proxy"}) {
                 # 'https-proxy' is used as "server" so consider it a protocol
                 push @protocols, 'https-proxy';
             }
@@ -732,9 +744,9 @@ sub checksystemfeatures {
     }
 
     # allow this feature only if debug mode is disabled
-    $feature{"ld_preload"} = $feature{"ld_preload"} && !$feature{"debug"};
+    $feature{"ld_preload"} = $feature{"ld_preload"} && !$feature{"Debug"};
 
-    if($feature{"ipv6"}) {
+    if($feature{"IPv6"}) {
         # client has IPv6 support
 
         # check if the HTTP server has it!
@@ -754,7 +766,7 @@ sub checksystemfeatures {
         }
     }
 
-    if($feature{"unix-sockets"}) {
+    if($feature{"UnixSockets"}) {
         # client has Unix sockets support, check whether the HTTP server has it
         my $cmd = "server/sws".exe_ext('SRV')." --version";
         my @sws = `$cmd`;
@@ -772,7 +784,7 @@ sub checksystemfeatures {
     }
     close($manh);
 
-    $feature{"unittest"} = $feature{"debug"};
+    $feature{"unittest"} = $feature{"Debug"};
     $feature{"nghttpx"} = !!$ENV{'NGHTTPX'};
     $feature{"nghttpx-h3"} = !!$nghttpx_h3;
 
@@ -1304,6 +1316,10 @@ sub singletest_check {
             chomp($validstderr[-1]);
         }
 
+        if($hash{'crlf'}) {
+            subnewlines(0, \$_) for @validstderr;
+        }
+
         $res = compare($runnerid, $testnum, $testname, "stderr", \@actual, \@validstderr);
         if($res) {
             return -1;
@@ -1446,6 +1462,9 @@ sub singletest_check {
             # cut off the final newline from the final line of the upload data
             chomp($upload[-1]);
         }
+        for my $line (@upload) {
+            subbase64(\$line);
+        }
 
         # verify uploaded data
         my @out = loadarray("$logdir/upload.$testnum");
@@ -1964,6 +1983,8 @@ sub runtimestats {
 
     return if(not $timestats);
 
+    logmsg "::group::Run Time Stats\n";
+
     logmsg "\nTest suite total running time breakdown per task...\n\n";
 
     my @timesrvr;
@@ -2090,6 +2111,8 @@ sub runtimestats {
     }
 
     logmsg "\n";
+
+    logmsg "::endgroup::\n";
 }
 
 #######################################################################
@@ -3020,15 +3043,40 @@ if(%skipped && !$short) {
     }
 }
 
+sub testnumdetails {
+    my ($desc, $numlist) = @_;
+    foreach my $testnum (split(' ', $numlist)) {
+        if(!loadtest("${TESTDIR}/test${testnum}")) {
+            my @info_keywords = getpart("info", "keywords");
+            my $testname = (getpart("client", "name"))[0];
+            chomp $testname;
+            logmsg "$desc $testnum: '$testname'";
+            my $first = 1;
+            for my $k (@info_keywords) {
+                chomp $k;
+                my $sep = ($first == 1) ? " " : ", ";
+                logmsg "$sep$k";
+                $first = 0;
+            }
+            logmsg "\n";
+        }
+    }
+}
+
 if($total) {
     if($failedign) {
-        logmsg "IGNORED: failed tests: $failedign\n";
+        my $failedignsorted = numsortwords($failedign);
+        testnumdetails("FAIL-IGNORED", $failedignsorted);
+        logmsg "IGNORED: failed tests: $failedignsorted\n";
     }
     logmsg sprintf("TESTDONE: $ok tests out of $total reported OK: %d%%\n",
                    $ok/$total*100);
 
     if($failed && ($ok != $total)) {
-        logmsg "\nTESTFAIL: These test cases failed: $failed\n\n";
+        my $failedsorted = numsortwords($failed);
+        logmsg "\n";
+        testnumdetails("FAIL", $failedsorted);
+        logmsg "\nTESTFAIL: These test cases failed: $failedsorted\n\n";
     }
 }
 else {
diff --git a/tests/server/CMakeLists.txt b/tests/server/CMakeLists.txt
index 46c943a8b..b84a0498a 100644
--- a/tests/server/CMakeLists.txt
+++ b/tests/server/CMakeLists.txt
@@ -27,16 +27,16 @@ if(MSVC)
   set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /wd4306")
 endif()
 
-function(SETUP_EXECUTABLE TEST_NAME)    # ARGN are the files in the test
+function(SETUP_EXECUTABLE TEST_NAME)  # ARGN are the files in the test
   add_executable(${TEST_NAME} EXCLUDE_FROM_ALL ${ARGN})
   add_dependencies(testdeps ${TEST_NAME})
   string(TOUPPER ${TEST_NAME} UPPER_TEST_NAME)
 
   include_directories(
-    ${CURL_SOURCE_DIR}/lib      # To be able to reach "curl_setup_once.h"
-    ${CURL_BINARY_DIR}/lib      # To be able to reach "curl_config.h"
-    ${CURL_BINARY_DIR}/include  # To be able to reach "curl/curl.h"
-    ${CURL_SOURCE_DIR}/src      # To be able to reach "tool_xattr.h"
+    ${CURL_SOURCE_DIR}/lib      # for "curl_setup_once.h"
+    ${CURL_BINARY_DIR}/lib      # for "curl_config.h"
+    ${CURL_BINARY_DIR}/include  # for "curl/curl.h"
+    ${CURL_SOURCE_DIR}/src      # for "tool_xattr.h"
     )
   if(USE_ARES)
     include_directories(${CARES_INCLUDE_DIR})
@@ -51,7 +51,7 @@ function(SETUP_EXECUTABLE TEST_NAME)    # ARGN are the files in the test
   # files on Win32 targets it is necessary to build the test servers
   # with CURL_STATICLIB defined, independently of how libcurl is built.
   set_target_properties(${TEST_NAME} PROPERTIES
-    COMPILE_DEFINITIONS CURL_STATICLIB)       # ${UPPER_TEST_NAME}
+    COMPILE_DEFINITIONS CURL_STATICLIB)  # ${UPPER_TEST_NAME}
   set_target_properties(${TEST_NAME} PROPERTIES
     PROJECT_LABEL "${TARGET_LABEL_PREFIX}${TEST_NAME}")
 endfunction()
@@ -66,17 +66,17 @@ foreach(EXECUTABLE_NAME ${noinst_PROGRAMS})
 endforeach()
 
 
-# SET(useful
-# getpart.c getpart.h
-# ${CURL_SOURCE_DIR}/lib/strequal.c
-# ${CURL_SOURCE_DIR}/lib/base64.c
-# ${CURL_SOURCE_DIR}/lib/mprintf.c
-# ${CURL_SOURCE_DIR}/lib/memdebug.c
-# ${CURL_SOURCE_DIR}/lib/timeval.c
+# set(useful
+#   getpart.c getpart.h
+#   ${CURL_SOURCE_DIR}/lib/strequal.c
+#   ${CURL_SOURCE_DIR}/lib/base64.c
+#   ${CURL_SOURCE_DIR}/lib/mprintf.c
+#   ${CURL_SOURCE_DIR}/lib/memdebug.c
+#   ${CURL_SOURCE_DIR}/lib/timeval.c
 # )
 
-# SETUP_EXECUTABLE(sws sws.c util.c util.h ${useful})
-# SETUP_EXECUTABLE(resolve resolve.c util.c util.h ${useful})
-# SETUP_EXECUTABLE(sockfilt sockfilt.c util.c util.h ${useful} ${CURL_SOURCE_DIR}/lib/inet_pton.c)
-# SETUP_EXECUTABLE(getpart testpart.c ${useful})
-# SETUP_EXECUTABLE(tftpd tftpd.c util.c util.h ${useful} tftp.h)
+# setup_executable(sws sws.c util.c util.h ${useful})
+# setup_executable(resolve resolve.c util.c util.h ${useful})
+# setup_executable(sockfilt sockfilt.c util.c util.h ${useful} ${CURL_SOURCE_DIR}/lib/inet_pton.c)
+# setup_executable(getpart testpart.c ${useful})
+# setup_executable(tftpd tftpd.c util.c util.h ${useful} tftp.h)
diff --git a/tests/server/Makefile.am b/tests/server/Makefile.am
index b08942263..dda121377 100644
--- a/tests/server/Makefile.am
+++ b/tests/server/Makefile.am
@@ -59,7 +59,7 @@ CS_ = $(CS_0)
 checksrc:
 	$(CHECKSRC)@PERL@ $(top_srcdir)/scripts/checksrc.pl $(srcdir)/*.[ch]
 
-if CURLDEBUG
+if DEBUGBUILD
 # for debug builds, we scan the sources on all regular make invokes
 all-local: checksrc
 endif
diff --git a/tests/server/sockfilt.c b/tests/server/sockfilt.c
index 8d9d13b4f..4e5cb7e4b 100644
--- a/tests/server/sockfilt.c
+++ b/tests/server/sockfilt.c
@@ -152,7 +152,7 @@ enum sockmode {
   ACTIVE_DISCONNECT  /* as a client, disconnected from server */
 };
 
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(CURL_WINDOWS_APP)
 /*
  * read-wrapper to support reading from stdin on Windows.
  */
@@ -420,7 +420,7 @@ static bool read_data_block(unsigned char *buffer, ssize_t maxlen,
 }
 
 
-#ifdef USE_WINSOCK
+#if defined(USE_WINSOCK) && !defined(CURL_WINDOWS_APP)
 /*
  * WinSock select() does not support standard file descriptors,
  * it can only check SOCKETs. The following function is an attempt
@@ -921,11 +921,10 @@ static bool disc_handshake(void)
       }
       else if(!memcmp("DATA", buffer, 4)) {
         /* We must read more data to stay in sync */
+        logmsg("Throwing away data bytes");
         if(!read_data_block(buffer, sizeof(buffer), &buffer_len))
           return FALSE;
 
-        logmsg("Throwing again %zd data bytes", buffer_len);
-
       }
       else if(!memcmp("QUIT", buffer, 4)) {
         /* just die */
diff --git a/tests/server/util.c b/tests/server/util.c
index a1355f9c0..eed305d15 100644
--- a/tests/server/util.c
+++ b/tests/server/util.c
@@ -366,7 +366,7 @@ void clear_advisor_read_lock(const char *filename)
 }
 
 
-#if defined(_WIN32) && !defined(MSDOS)
+#if defined(_WIN32)
 
 static struct timeval tvnow(void)
 {
@@ -493,7 +493,7 @@ static SIGHANDLER_T old_sigterm_handler = SIG_ERR;
 static SIGHANDLER_T old_sigbreak_handler = SIG_ERR;
 #endif
 
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(CURL_WINDOWS_APP)
 #ifdef _WIN32_WCE
 static DWORD thread_main_id = 0;
 #else
@@ -574,6 +574,9 @@ static BOOL WINAPI ctrl_event_handler(DWORD dwCtrlType)
   }
   return TRUE;
 }
+#endif
+
+#if defined(_WIN32) && !defined(CURL_WINDOWS_APP)
 /* Window message handler for Windows applications to add support
  * for graceful process termination via taskkill (without /f) which
  * sends WM_CLOSE to all Windows of a process (even hidden ones).
@@ -687,12 +690,6 @@ static SIGHANDLER_T set_signal(int signum, SIGHANDLER_T handler,
 void install_signal_handlers(bool keep_sigalrm)
 {
 #ifdef _WIN32
-#ifdef _WIN32_WCE
-  typedef HANDLE curl_win_thread_handle_t;
-#else
-  typedef uintptr_t curl_win_thread_handle_t;
-#endif
-  curl_win_thread_handle_t thread;
   /* setup windows exit event before any signal can trigger */
   exit_event = CreateEvent(NULL, TRUE, FALSE, NULL);
   if(!exit_event)
@@ -741,16 +738,27 @@ void install_signal_handlers(bool keep_sigalrm)
 #ifdef _WIN32
   if(!SetConsoleCtrlHandler(ctrl_event_handler, TRUE))
     logmsg("cannot install CTRL event handler");
+
+#ifndef CURL_WINDOWS_APP
+  {
 #ifdef _WIN32_WCE
-  thread = CreateThread(NULL, 0, &main_window_loop,
-                        (LPVOID)GetModuleHandle(NULL), 0, &thread_main_id);
+    typedef HANDLE curl_win_thread_handle_t;
 #else
-  thread = _beginthreadex(NULL, 0, &main_window_loop,
-                          (void *)GetModuleHandle(NULL), 0, &thread_main_id);
+    typedef uintptr_t curl_win_thread_handle_t;
+#endif
+    curl_win_thread_handle_t thread;
+#ifdef _WIN32_WCE
+    thread = CreateThread(NULL, 0, &main_window_loop,
+                          (LPVOID)GetModuleHandle(NULL), 0, &thread_main_id);
+#else
+    thread = _beginthreadex(NULL, 0, &main_window_loop,
+                            (void *)GetModuleHandle(NULL), 0, &thread_main_id);
+#endif
+    thread_main_window = (HANDLE)thread;
+    if(!thread_main_window || !thread_main_id)
+      logmsg("cannot start main window loop");
+  }
 #endif
-  thread_main_window = (HANDLE)thread;
-  if(!thread_main_window || !thread_main_id)
-    logmsg("cannot start main window loop");
 #endif
 }
 
@@ -786,6 +794,7 @@ void restore_signal_handlers(bool keep_sigalrm)
 #endif
 #ifdef _WIN32
   (void)SetConsoleCtrlHandler(ctrl_event_handler, FALSE);
+#ifndef CURL_WINDOWS_APP
   if(thread_main_window && thread_main_id) {
     if(PostThreadMessage(thread_main_id, WM_APP, 0, 0)) {
       if(WaitForSingleObjectEx(thread_main_window, INFINITE, TRUE)) {
@@ -802,6 +811,7 @@ void restore_signal_handlers(bool keep_sigalrm)
     }
   }
 #endif
+#endif
 }
 
 #ifdef USE_UNIX_SOCKETS
diff --git a/tests/servers.pm b/tests/servers.pm
index d4472d509..d2c60aa6c 100644
--- a/tests/servers.pm
+++ b/tests/servers.pm
@@ -2970,6 +2970,8 @@ sub subvariables {
     $$thing =~ s/${prefix}PWD/$pwd/g;
     $$thing =~ s/${prefix}POSIX_PWD/$posix_pwd/g;
     $$thing =~ s/${prefix}VERSION/$CURLVERSION/g;
+    $$thing =~ s/${prefix}VERNUM/$CURLVERNUM/g;
+    $$thing =~ s/${prefix}DATE/$DATE/g;
     $$thing =~ s/${prefix}TESTNUMBER/$testnum/g;
 
     my $file_pwd = $pwd;
diff --git a/tests/sshserver.pl b/tests/sshserver.pl
index cba8a88ef..20939f0da 100755
--- a/tests/sshserver.pl
+++ b/tests/sshserver.pl
@@ -847,8 +847,8 @@ if ($sshdid =~ /OpenSSH-Windows/) {
 }
 elsif (pathhelp::os_is_win()) {
     # Ensure to use MinGW/Cygwin paths
-    $identity_config = pathhelp::build_sys_abs_path($identity_config);
-    $knownhosts_config = pathhelp::build_sys_abs_path($knownhosts_config);
+    $identity_config = pathhelp::build_sys_abs_path($identity);
+    $knownhosts_config = pathhelp::build_sys_abs_path($knownhosts);
 }
 else {
     $identity_config = abs_path(pp($identity));
diff --git a/tests/stunnel.pem b/tests/stunnel.pem
index b7dd1e879..b273ff761 100644
--- a/tests/stunnel.pem
+++ b/tests/stunnel.pem
@@ -1,11 +1,12 @@
 extensions = x509v3
+
 [ x509v3 ]
-subjectAltName = DNS:localhost
-keyUsage	= keyEncipherment,digitalSignature,keyAgreement
-extendedKeyUsage = serverAuth
-subjectKeyIdentifier = hash
-authorityKeyIdentifier = keyid
-basicConstraints = CA:false
+subjectAltName          = DNS:localhost
+keyUsage                = keyEncipherment,digitalSignature,keyAgreement
+extendedKeyUsage        = serverAuth
+subjectKeyIdentifier    = hash
+authorityKeyIdentifier  = keyid
+basicConstraints        = CA:false
 authorityInfoAccess     = @issuer_info
 crlDistributionPoints   = @crl_info
 
@@ -20,22 +21,18 @@ caIssuers;URI.0         = http://test.curl.se/ca/EdelCurlRoot.cer
 URI.0                   = http://test.curl.se/ca/EdelCurlRoot.crl
 
 [ req ]
-default_bits                    = 12048
-distinguished_name              = req_DN
-default_md			= sha256
-string_mask			= utf8only
-[ req_DN ]
-countryName                     = "Country Name is Northern Nowhere"
-countryName_value            = NN
-organizationName              = "Organization Name"
-organizationName_value     = Edel Curl Arctic Illudium Research Cloud
-commonName                      = "Common Name"
-commonName_value              = localhost
+default_bits            = 12048
+distinguished_name      = req_DN
+default_md              = sha256
+string_mask             = utf8only
 
-[something]
-# The key
-# the certificate
-# some dhparam
+[ req_DN ]
+countryName             = "Country Name is Northern Nowhere"
+countryName_value       = NN
+organizationName        = "Organization Name"
+organizationName_value  = Edel Curl Arctic Illudium Research Cloud
+commonName              = "Common Name"
+commonName_value        = localhost
 -----BEGIN PRIVATE KEY-----
 MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCrCrAD0Hb+Xs4V
 3mHV45FvfNa7yiaOeL4mNdGmWfHVPFU+CSzsoNSvDjxaorWweFGVYoCAcchOn1lZ
diff --git a/tests/test1119.pl b/tests/test1119.pl
index 2b9ac3759..89a93cab5 100755
--- a/tests/test1119.pl
+++ b/tests/test1119.pl
@@ -109,7 +109,7 @@ sub checkmanpage {
     my $line = 1;
     while(<$mh>) {
         # strip off formatting
-        $_ =~ s/\\f[BPRI]//;
+        $_ =~ s/(^|[^A-Z0-9])[*_]+/ /;
         # detect global-looking 'CURL[BLABLA]_*' symbols
         while(s/\W(CURL(AUTH|E|H|MOPT|OPT|SHOPT|UE|M|SSH|SSLBACKEND|HEADER|FORM|FTP|PIPE|MIMEOPT|GSSAPI|ALTSVC|PROTO|PROXY|UPART|USESSL|_READFUNC|_WRITEFUNC|_CSELECT|_FORMADD|_IPRESOLVE|_REDIR|_RTSPREQ|_TIMECOND|_VERSION)_[a-zA-Z0-9_]+)//) {
             my $s = $1;
@@ -123,11 +123,11 @@ sub checkmanpage {
     close($mh);
 }
 
-sub scanman3dir {
+sub scanman_md_dir {
     my ($d) = @_;
     opendir(my $dh, $d) ||
         die "Can't opendir: $!";
-    my @mans = grep { /.3\z/ } readdir($dh);
+    my @mans = grep { /.md\z/ } readdir($dh);
     closedir $dh;
     for my $m (@mans) {
         checkmanpage("$d/$m");
@@ -136,8 +136,8 @@ sub scanman3dir {
 
 
 scanallheaders();
-scanman3dir("$root/docs/libcurl");
-scanman3dir("$root/docs/libcurl/opts");
+scanman_md_dir("$root/docs/libcurl");
+scanman_md_dir("$root/docs/libcurl/opts");
 
 open my $s, "<", "$root/docs/libcurl/symbols-in-versions";
 while(<$s>) {
diff --git a/tests/test1139.pl b/tests/test1139.pl
index 2c56c3a72..421af70b8 100755
--- a/tests/test1139.pl
+++ b/tests/test1139.pl
@@ -24,12 +24,12 @@
 ###########################################################################
 #
 # Scan symbols-in-version (which is verified to be correct by test 1119), then
-# verify that each option mention in there that should have its own man page
+# verify that each option mention in there that should have its own manpage
 # actually does.
 #
 # In addition, make sure that every current option to curl_easy_setopt,
 # curl_easy_getinfo and curl_multi_setopt are also mentioned in their
-# corresponding main (index) man page.
+# corresponding main (index) manpage.
 #
 # src/tool_getparam.c lists all options curl can parse
 # docs/curl.1 documents all command line options
@@ -64,14 +64,14 @@ my %alias = (
     'CURLINFO_TEXT' => 'none'
     );
 
-sub scanmanpage {
+sub scanmdpage {
     my ($file, @words) = @_;
 
     open(my $mh, "<", "$file") ||
         die "could not open $file";
     my @m;
     while(<$mh>) {
-        if($_ =~ /^\.IP (.*)/) {
+        if($_ =~ /^## (.*)/) {
             my $w = $1;
             # "unquote" minuses
             $w =~ s/\\-/-/g;
@@ -80,6 +80,15 @@ sub scanmanpage {
     }
     close($mh);
 
+    my @ms = sort @m;
+    for my $i (0 .. $#m) {
+        if($ms[$i] ne $m[$i]) {
+            print STDERR "$file:1:ERROR: $m[$i] is not alphabetical (expected $ms[$i])\n";
+            $errors++;
+            # no point in reporting many
+            last;
+        }
+    }
     foreach my $m (@words) {
         my @g = grep(/$m/, @m);
         if(!$g[0]) {
@@ -129,8 +138,8 @@ while(<$r>) {
             elsif($type eq "MOPT") {
                 push @curlmopt, $opt,
             }
-            if(! -f "$buildroot/docs/libcurl/opts/$opt.3") {
-                print STDERR "Missing $opt.3\n";
+            if(! -f "$root/docs/libcurl/opts/$opt.md") {
+                print STDERR "Missing $opt.md\n";
                 $errors++;
             }
         }
@@ -138,9 +147,9 @@ while(<$r>) {
 }
 close($r);
 
-scanmanpage("$buildroot/docs/libcurl/curl_easy_setopt.3", @curlopt);
-scanmanpage("$buildroot/docs/libcurl/curl_easy_getinfo.3", @curlinfo);
-scanmanpage("$buildroot/docs/libcurl/curl_multi_setopt.3", @curlmopt);
+scanmdpage("$root/docs/libcurl/curl_easy_setopt.md", @curlopt);
+scanmdpage("$root/docs/libcurl/curl_easy_getinfo.md", @curlinfo);
+scanmdpage("$root/docs/libcurl/curl_multi_setopt.md", @curlmopt);
 
 # using this hash array, we can skip specific options
 my %opts = (
@@ -218,8 +227,8 @@ while(<$r>) {
 close($r);
 
 #########################################################################
-# parse the curl.1 man page, extract all documented command line options
-# The man page may or may not be rebuilt, so check both possible locations
+# parse the curl.1 manpage, extract all documented command line options
+# The manpage may or may not be rebuilt, so check both possible locations
 open($r, "<", "$buildroot/docs/cmdline-opts/curl.1") || open($r, "<", "$root/docs/cmdline-opts/curl.1") ||
     die "failed getting curl.1";
 my @manpage; # store all parsed parameters
diff --git a/tests/test1140.pl b/tests/test1140.pl
index 8e1f12298..ac06c4af3 100755
--- a/tests/test1140.pl
+++ b/tests/test1140.pl
@@ -24,7 +24,7 @@
 ###########################################################################
 #
 # scan manpages to find basic syntactic problems such as unbalanced \f
-# codes or references to non-existing curl man pages.
+# codes or references to non-existing curl manpages.
 
 my $docsroot = $ARGV[0];
 
@@ -76,7 +76,7 @@ sub file {
                 my $man = "$1.3";
                 $man =~ s/\\//g; # cut off backslashes
                 if(!manpresent($man)) {
-                    print "error: $f:$line: referring to non-existing man page $man\n";
+                    print "error: $f:$line: referring to non-existing manpage $man\n";
                     $errors++;
                 }
                 if($pre ne "I") {
@@ -95,7 +95,7 @@ sub file {
                 my $man = "$1.3";
                 $man =~ s/\\//g; # cut off backslashes
                 if(!manpresent($man)) {
-                    print "error: $f:$line: referring to non-existing man page $man\n";
+                    print "error: $f:$line: referring to non-existing manpage $man\n";
                     $errors++;
                 }
             }
diff --git a/tests/test1173.pl b/tests/test1173.pl
index c09490ef9..584c2f101 100755
--- a/tests/test1173.pl
+++ b/tests/test1173.pl
@@ -23,7 +23,7 @@
 #
 ###########################################################################
 #
-# Scan man page(s) and detect some simple and yet common formatting mistakes.
+# Scan manpage(s) and detect some simple and yet common formatting mistakes.
 #
 # Output all deviances to stderr.
 
@@ -137,7 +137,7 @@ sub scanmanpage {
     open(my $m, "<", "$file") ||
         die "test1173.pl could not open $file";
     if($file =~ /[\/\\](CURL|curl_)([^\/\\]*).3/) {
-        # This is a man page for libcurl. It requires an example unless it's
+        # This is a manpage for libcurl. It requires an example unless it's
         # considered deprecated.
         $reqex = 1 unless defined $deprecated{'CURL'.$2};
         if($1 eq "CURL") {
@@ -148,12 +148,12 @@ sub scanmanpage {
     while(<$m>) {
         chomp;
         if($_ =~ /^.so /) {
-            # this man page is just a referral
+            # this manpage is just a referral
             close($m);
             return;
         }
         if(($_ =~ /^\.SH SYNOPSIS/i) && ($reqex)) {
-            # this is for libcurl man page SYNOPSIS checks
+            # this is for libcurl manpage SYNOPSIS checks
             $insynop = 1;
             $inex = 0;
         }
@@ -254,7 +254,7 @@ sub scanmanpage {
 
         if($optpage && $SH && ($SH !~ /^(SYNOPSIS|EXAMPLE|NAME|SEE ALSO)/i) &&
            ($_ =~ /(.*)(CURL(OPT_|MOPT_|INFO_|SHOPT_)[A-Z0-9_]*)/)) {
-            # an option with its own man page, check that it is tagged
+            # an option with its own manpage, check that it is tagged
             # for linking
             my ($pref, $symbol) = ($1, $2);
             if($deprecated{$symbol}) {
@@ -303,7 +303,7 @@ sub scanmanpage {
         }
 
         if($shcount < 3) {
-            print STDERR "$file:$line too few man page sections!\n";
+            print STDERR "$file:$line too few manpage sections!\n";
             $errors++;
             return;
         }
diff --git a/tests/test1175.pl b/tests/test1175.pl
index 8147ef6d0..2bf863fc7 100755
--- a/tests/test1175.pl
+++ b/tests/test1175.pl
@@ -35,9 +35,9 @@ my %error; # from the include file
 my %docs; # from libcurl-errors.3
 
 sub getdocserrors {
-    open(my $f, "<", "$root/docs/libcurl/libcurl-errors.3");
+    open(my $f, "<", "$root/docs/libcurl/libcurl-errors.md");
     while(<$f>) {
-        if($_ =~ /^.IP \"(CURL[EM]_[^ \t\"]*)/) {
+        if($_ =~ /^## (CURL[EM]_[^ ]*)/) {
             my ($symbol) = ($1);
             if($symbol =~ /OBSOLETE/) {
                 ;
@@ -71,7 +71,7 @@ getdocserrors();
 
 for(sort keys %error) {
     if($error{$_} && !$docs{$_}) {
-        print "$_ is not in libcurl-errors.3\n";
+        print "$_ is not in libcurl-errors.md\n";
     }
 }
 
diff --git a/tests/test1222.pl b/tests/test1222.pl
index b26aea872..8f98aa740 100755
--- a/tests/test1222.pl
+++ b/tests/test1222.pl
@@ -25,7 +25,7 @@
 ###########################################################################
 #
 # Check that the deprecated statuses of functions and enum values in header
-# files, man pages and symbols-in-versions are in sync.
+# files, manpages and symbols-in-versions are in sync.
 
 use strict;
 use warnings;
@@ -45,8 +45,8 @@ my $errcode = 0;
 #     x.yy.z  Deprecated in version x.yy.z
 my %syminver;       # Symbols-in-versions deprecations.
 my %hdr;            # Public header files deprecations.
-my %funcman;        # Function man pages deprecations.
-my %optman;         # Option man pages deprecations.
+my %funcman;        # Function manpages deprecations.
+my %optman;         # Option manpages deprecations.
 
 
 # Scan header file for public function and enum values. Flag them with
@@ -141,7 +141,7 @@ sub scan_header {
     close $h;
 }
 
-# Scan function man page for options.
+# Scan function manpage for options.
 # Each option has to be declared as ".IP <option>" where <option> starts with
 # the prefix. Flag each option with its deprecation version, if some.
 sub scan_man_for_opts {
@@ -180,7 +180,7 @@ sub scan_man_for_opts {
     close $m;
 }
 
-# Scan man page for deprecation in DESCRIPTION and/or AVAILABILITY sections.
+# Scan manpage for deprecation in DESCRIPTION and/or AVAILABILITY sections.
 sub scan_man_page {
     my ($path, $sym, $table)=@_;
     my $version = "X";
@@ -191,7 +191,7 @@ sub scan_man_page {
 
       while(<$fh>) {
         if($_ =~ /\.so\s+man3\/(.*\.3\b)/) {
-          # Handle man page inclusion.
+          # Handle manpage inclusion.
           scan_man_page(dirname($path) . "/$1", $sym, $table);
           $version = exists($$table{$sym})? $$table{$sym}: $version;
         }
@@ -208,12 +208,12 @@ sub scan_man_page {
             s/\s+/ /g;
             s/\\f.//g;      # Remove font formatting.
             s/\s+/ /g;      # One line with single space only.
-            if($sh =~ /DESCRIPTION|AVAILABILITY/) {
+            if($sh =~ /DESCRIPTION|DEPRECATED/) {
               while($_ =~ /(?:deprecated|obsoleted?)\b\s*(?:in\b|since\b)?\s*(?:version\b|curl\b|libcurl\b)?\s*(\d[0-9.]*\d)?\b\s*(.*)$/i) {
                 # Flag deprecation status.
                 if($version ne "X" && $version ne "?") {
                   if($1 && $1 ne $version) {
-                    print "error: $sym man page lists unmatching deprecation versions $version and $1\n";
+                    print "error: $sym manpage lists unmatching deprecation versions $version and $1\n";
                     $errcode++;
                   }
                 }
@@ -261,18 +261,18 @@ for(@hfiles) {
   scan_header("$incdir/$_");
 }
 
-# Get function statuses from man pages.
+# Get function statuses from manpages.
 foreach my $sym (keys %hdr) {
   if($sym =~/^(?:curl|curlx)_\w/) {
     scan_man_page("$libdocdir/$sym.3", $sym, \%funcman);
   }
 }
 
-# Get options from function man pages.
+# Get options from function manpages.
 scan_man_for_opts("$libdocdir/curl_easy_setopt.3", "CURLOPT");
 scan_man_for_opts("$libdocdir/curl_easy_getinfo.3", "CURLINFO");
 
-# Get deprecation status from option man pages.
+# Get deprecation status from option manpages.
 foreach my $sym (keys %syminver) {
   if($sym =~ /^(?:CURLOPT|CURLINFO)_\w+$/) {
     scan_man_page("$libdocdir/opts/$sym.3", $sym, \%optman);
diff --git a/tests/test1275.pl b/tests/test1275.pl
index 47ce79957..353391d2f 100755
--- a/tests/test1275.pl
+++ b/tests/test1275.pl
@@ -32,6 +32,7 @@ my $errors;
 my %accepted=('curl' => 1,
               'libcurl' => 1,
               'macOS' => 1,
+              'mbedTLS' => 1,
               'c-ares' => 1);
 
 sub checkfile {
diff --git a/tests/test1477.pl b/tests/test1477.pl
index ad564b26d..2529ebc48 100755
--- a/tests/test1477.pl
+++ b/tests/test1477.pl
@@ -89,7 +89,7 @@ scanmanpage($manpge);
 print "Result\n";
 for my $h (sort @hnames) {
     if(!$manfrom{$h}) {
-        printf "$h from %s, not in man page\n", $wherefrom{$h};
+        printf "$h from %s, not in manpage\n", $wherefrom{$h};
     }
 }
 
diff --git a/tests/test1486.pl b/tests/test1486.pl
new file mode 100755
index 000000000..eb70d02d7
--- /dev/null
+++ b/tests/test1486.pl
@@ -0,0 +1,102 @@
+#!/usr/bin/env perl
+#***************************************************************************
+#                                  _   _ ____  _
+#  Project                     ___| | | |  _ \| |
+#                             / __| | | | |_) | |
+#                            | (__| |_| |  _ <| |___
+#                             \___|\___/|_| \_\_____|
+#
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+#
+# This software is licensed as described in the file COPYING, which
+# you should have received as part of this distribution. The terms
+# are also available at https://curl.se/docs/copyright.html.
+#
+# You may opt to use, copy, modify, merge, publish, distribute and/or sell
+# copies of the Software, and permit persons to whom the Software is
+# furnished to do so, under the terms of the COPYING file.
+#
+# This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+# KIND, either express or implied.
+#
+# SPDX-License-Identifier: curl
+#
+###########################################################################
+#
+#
+
+use strict;
+use warnings;
+
+# we may get the dir root pointed out
+my $root=$ARGV[0] || ".";
+
+my %insrc; # variable set in source
+my %indocs; # variable described in docs
+
+my $srccount = 1;
+sub getsrcvars {
+    open(my $f, "<", "$root/../src/tool_writeout.c");
+    my $mode = 0;
+    while(<$f>) {
+        if(!$mode &&
+           ($_ =~ /^static const struct writeoutvar/)) {
+            $mode = 1;
+        }
+        if($mode) {
+            if($_ =~ /^}/) {
+                last;
+            }
+            if($_ =~ /^  \{\"([^\"]*)/) {
+                my $var = $1;
+                $insrc{$var} = $srccount++;
+            }
+        }
+    }
+    close($f);
+}
+
+sub getdocsvars {
+    open(my $f, "<", "$root/../docs/cmdline-opts/write-out.md");
+    while(<$f>) {
+        if($_ =~ /^\#\# \`([^\`]*)\`/) {
+            $indocs{$1} = 1;
+        }
+    }
+    close($f);
+}
+
+getsrcvars();
+getdocsvars();
+
+my $error = 0;
+
+if((scalar(keys %indocs) < 10) || (scalar(keys %insrc) < 10)) {
+    print "problems to extract variables\n";
+    $error++;
+}
+
+# also verify that the source code lists them alphabetically
+my $check = 1;
+for(sort keys %insrc) {
+    if($insrc{$_} && !$indocs{$_}) {
+        print "$_ is not mentioned in write.out.md\n";
+        $error++;
+    }
+    if($insrc{$_} ne $check) {
+        print "$_ is not in alphabetical order\n";
+        $error++;
+    }
+    $check++;
+}
+
+for(sort keys %indocs) {
+    if($indocs{$_} && !$insrc{$_}) {
+        print "$_ documented, but not used in source code\n";
+        $error++;
+    }
+}
+
+print "OK\n" if(!$error);
+
+exit $error;
diff --git a/tests/test1488.pl b/tests/test1488.pl
new file mode 100755
index 000000000..43dd24d10
--- /dev/null
+++ b/tests/test1488.pl
@@ -0,0 +1,128 @@
+#!/usr/bin/env perl
+#***************************************************************************
+#                                  _   _ ____  _
+#  Project                     ___| | | |  _ \| |
+#                             / __| | | | |_) | |
+#                            | (__| |_| |  _ <| |___
+#                             \___|\___/|_| \_\_____|
+#
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+#
+# This software is licensed as described in the file COPYING, which
+# you should have received as part of this distribution. The terms
+# are also available at https://curl.se/docs/copyright.html.
+#
+# You may opt to use, copy, modify, merge, publish, distribute and/or sell
+# copies of the Software, and permit persons to whom the Software is
+# furnished to do so, under the terms of the COPYING file.
+#
+# This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+# KIND, either express or implied.
+#
+# SPDX-License-Identifier: curl
+#
+###########################################################################
+#
+# This script grew out of help from Przemyslaw Iskra and Balint Szilakszi
+# a late evening in the #curl IRC channel.
+#
+
+use strict;
+use warnings;
+use vars qw($Cpreprocessor);
+
+#
+# configurehelp perl module is generated by configure script
+#
+my $rc = eval {
+    require configurehelp;
+    configurehelp->import(qw(
+        $Cpreprocessor
+    ));
+    1;
+};
+# Set default values if configure has not generated a configurehelp.pm file.
+# This is the case with cmake.
+if (!$rc) {
+    $Cpreprocessor = 'cpp';
+}
+
+# we may get the dir root pointed out
+my $root=$ARGV[0] || ".";
+
+# need an include directory when building out-of-tree
+my $i = ($ARGV[1]) ? "-I$ARGV[1] " : '';
+my $error;
+
+
+my @syms;
+my %manpage;
+my %symadded;
+
+sub checkmanpage {
+    my ($m) = @_;
+
+    open(my $mh, "<", "$m");
+    my $line = 1;
+    my $title;
+    my $addedin;
+    while(<$mh>) {
+        if(/^Title: (.*)/i) {
+            $title = $1;
+        }
+        elsif(/^Added-in: (.*)/i) {
+            $addedin = $1;
+        }
+        if($addedin && $title) {
+            if($manpage{$title}) {
+                print "$title is a duplicate symbol in file $m\n";
+                $error++;
+            }
+            $manpage{$title} = $addedin;
+            last;
+        }
+        $line++;
+    }
+    close($mh);
+}
+
+sub scanman_md_dir {
+    my ($d) = @_;
+    opendir(my $dh, $d) ||
+        die "Can't opendir: $!";
+    my @mans = grep { /.md\z/ } readdir($dh);
+    closedir $dh;
+    for my $m (@mans) {
+        checkmanpage("$d/$m");
+    }
+}
+
+scanman_md_dir("$root/docs/libcurl");
+scanman_md_dir("$root/docs/libcurl/opts");
+
+open my $s, "<", "$root/docs/libcurl/symbols-in-versions";
+while(<$s>) {
+    if(/(^[^ \n]+) +(.*)/) {
+        my ($sym, $rest)=($1, $2);
+        my @a=split(/ +/, $rest);
+        push @syms, $sym;
+
+        $symadded{$sym}=$a[0];
+    }
+}
+close $s;
+
+my $ignored=0;
+for my $e (sort @syms) {
+    if( $manpage{$e} ) {
+
+        if( $manpage{$e} ne $symadded{$e} ) {
+            printf "%s.md says version %s, but SIV says %s\n",
+                $e, $manpage{$e}, $symadded{$e};
+            $error++;
+        }
+
+    }
+}
+print "OK\n" if(!$error);
+exit $error;
diff --git a/tests/testutil.pm b/tests/testutil.pm
index 1a44083e1..36bbe513c 100644
--- a/tests/testutil.pm
+++ b/tests/testutil.pm
@@ -127,6 +127,7 @@ sub subbase64 {
         # decode %NN characters
         my ($d, $n) = ($2, $1);
         $d =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
+        $n =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
         my $all = $d x $n;
         $$thing =~ s/%%REPEAT%%/$all/;
     }
diff --git a/tests/unit/CMakeLists.txt b/tests/unit/CMakeLists.txt
index 74967500f..07421220a 100644
--- a/tests/unit/CMakeLists.txt
+++ b/tests/unit/CMakeLists.txt
@@ -26,17 +26,15 @@ transform_makefile_inc("Makefile.inc" "${CMAKE_CURRENT_BINARY_DIR}/Makefile.inc.
 include(${CMAKE_CURRENT_BINARY_DIR}/Makefile.inc.cmake)
 
 include_directories(
-  ${CURL_SOURCE_DIR}/lib          # To be able to reach "curl_setup_once.h"
+  ${CURL_SOURCE_DIR}/lib          # for "curl_setup_once.h"
   ${CURL_SOURCE_DIR}/tests/libtest
   ${CURL_SOURCE_DIR}/src
-  ${CURL_BINARY_DIR}/lib          # To be able to reach "curl_config.h"
-  ${CURL_BINARY_DIR}/include      # To be able to reach "curl/curl.h"
+  ${CURL_BINARY_DIR}/lib          # for "curl_config.h"
+  ${CURL_BINARY_DIR}/include      # for "curl/curl.h"
 )
 
-if(ENABLE_CURLDEBUG)  # running unittests require curl to compiled with CURLDEBUG
-  foreach(_testfile ${UNITPROGS})
-    add_executable(${_testfile} EXCLUDE_FROM_ALL ${_testfile}.c ${UNITFILES})
-    add_dependencies(testdeps ${_testfile})
-    target_link_libraries(${_testfile} curltool curlu)
-  endforeach()
-endif()
+foreach(_testfile ${UNITPROGS})
+  add_executable(${_testfile} EXCLUDE_FROM_ALL ${_testfile}.c ${UNITFILES})
+  add_dependencies(testdeps ${_testfile})
+  target_link_libraries(${_testfile} curltool curlu)
+endforeach()
diff --git a/tests/unit/Makefile.inc b/tests/unit/Makefile.inc
index 1e48aadf9..5b23c2559 100644
--- a/tests/unit/Makefile.inc
+++ b/tests/unit/Makefile.inc
@@ -36,8 +36,8 @@ UNITPROGS = unit1300          unit1302 unit1303 unit1304 unit1305 unit1307 \
  unit1600 unit1601 unit1602 unit1603 unit1604 unit1605 unit1606 unit1607 \
  unit1608 unit1609 unit1610 unit1611 unit1612 unit1614 unit1615 unit1616 \
  unit1620 unit1621 \
- unit1650 unit1651 unit1652 unit1653 unit1654 unit1655 \
- unit1660 unit1661 \
+ unit1650 unit1651 unit1652 unit1653 unit1654 unit1655 unit1656 \
+ unit1660 unit1661 unit1663 \
  unit2600 unit2601 unit2602 unit2603 unit2604 \
  unit3200 \
  unit3205
@@ -122,10 +122,14 @@ unit1654_SOURCES = unit1654.c $(UNITFILES)
 
 unit1655_SOURCES = unit1655.c $(UNITFILES)
 
+unit1656_SOURCES = unit1656.c $(UNITFILES)
+
 unit1660_SOURCES = unit1660.c $(UNITFILES)
 
 unit1661_SOURCES = unit1661.c $(UNITFILES)
 
+unit1663_SOURCES = unit1663.c $(UNITFILES)
+
 unit2600_SOURCES = unit2600.c $(UNITFILES)
 
 unit2601_SOURCES = unit2601.c $(UNITFILES)
diff --git a/tests/unit/unit1603.c b/tests/unit/unit1603.c
index 850ad8569..44f9b880a 100644
--- a/tests/unit/unit1603.c
+++ b/tests/unit/unit1603.c
@@ -39,6 +39,16 @@ static void mydtor(void *p)
  (void)p; /* unused */
 }
 
+static size_t elem_dtor_calls;
+
+static void my_elem_dtor(void *key, size_t key_len, void *p)
+{
+  (void)p; /* unused */
+  (void)key; /* unused */
+  (void)key_len; /* unused */
+  ++elem_dtor_calls;
+}
+
 static CURLcode unit_setup(void)
 {
   Curl_hash_init(&hash_static, slots, Curl_hash_str,
@@ -147,6 +157,22 @@ UNITTEST_START
   nodep = Curl_hash_pick(&hash_static, &key3, strlen(key3));
   fail_unless(nodep == key3, "hash retrieval failed");
 
+  /* Add element with own destructor */
+  nodep = Curl_hash_add2(&hash_static, &key1, strlen(key1), &key1,
+                         my_elem_dtor);
+  fail_unless(nodep, "add2 insertion into hash failed");
+  fail_unless(elem_dtor_calls == 0, "element destructor count should be 0");
+  /* Add it again, should invoke destructor on first */
+  nodep = Curl_hash_add2(&hash_static, &key1, strlen(key1), &key1,
+                         my_elem_dtor);
+  fail_unless(nodep, "add2 again, insertion into hash failed");
+  fail_unless(elem_dtor_calls == 1, "element destructor count should be 1");
+  /* remove, should invoke destructor */
+  rc = Curl_hash_delete(&hash_static, &key1, strlen(key1));
+  fail_unless(rc == 0, "hash delete failed");
+  fail_unless(elem_dtor_calls == 2, "element destructor count should be 1");
+
+
   /* Clean up */
   Curl_hash_clean(&hash_static);
 
diff --git a/tests/unit/unit1614.c b/tests/unit/unit1614.c
index ef03e3b4c..fd6f5849c 100644
--- a/tests/unit/unit1614.c
+++ b/tests/unit/unit1614.c
@@ -46,7 +46,6 @@ struct noproxy {
   const char *a;
   const char *n;
   bool match;
-  bool space; /* space separated */
 };
 
 UNITTEST_START
@@ -78,52 +77,55 @@ UNITTEST_START
     { NULL, NULL, 0, FALSE} /* end marker */
   };
   struct noproxy list[]= {
-    { "www.example.com", "localhost .example.com .example.de", TRUE, TRUE},
-    { "www.example.com", "localhost,.example.com,.example.de", TRUE, FALSE},
-    { "www.example.com.", "localhost,.example.com,.example.de", TRUE, FALSE},
-    { "example.com", "localhost,.example.com,.example.de", TRUE, FALSE},
-    { "example.com.", "localhost,.example.com,.example.de", TRUE, FALSE},
-    { "www.example.com", "localhost,.example.com.,.example.de", TRUE, FALSE},
-    { "www.example.com", "localhost,www.example.com.,.example.de",
-      TRUE, FALSE},
-    { "example.com", "localhost,example.com,.example.de", TRUE, FALSE},
-    { "example.com.", "localhost,example.com,.example.de", TRUE, FALSE},
-    { "nexample.com", "localhost,example.com,.example.de", FALSE, FALSE},
-    { "www.example.com", "localhost,example.com,.example.de", TRUE, FALSE},
-    { "127.0.0.1", "127.0.0.1,localhost", TRUE, FALSE},
-    { "127.0.0.1", "127.0.0.1,localhost,", TRUE, FALSE},
-    { "127.0.0.1", "127.0.0.1/8,localhost,", TRUE, FALSE},
-    { "127.0.0.1", "127.0.0.1/28,localhost,", TRUE, FALSE},
-    { "127.0.0.1", "127.0.0.1/31,localhost,", TRUE, FALSE},
-    { "127.0.0.1", "localhost,127.0.0.1", TRUE, FALSE},
+    { "www.example.com", "localhost .example.com .example.de", FALSE},
+    { "www.example.com", "localhost,.example.com,.example.de", TRUE},
+    { "www.example.com.", "localhost,.example.com,.example.de", TRUE},
+    { "example.com", "localhost,.example.com,.example.de", TRUE},
+    { "example.com.", "localhost,.example.com,.example.de", TRUE},
+    { "www.example.com", "localhost,.example.com.,.example.de", TRUE},
+    { "www.example.com", "localhost,www.example.com.,.example.de", TRUE},
+    { "example.com", "localhost,example.com,.example.de", TRUE},
+    { "example.com.", "localhost,example.com,.example.de", TRUE},
+    { "nexample.com", "localhost,example.com,.example.de", FALSE},
+    { "www.example.com", "localhost,example.com,.example.de", TRUE},
+    { "127.0.0.1", "127.0.0.1,localhost", TRUE},
+    { "127.0.0.1", "127.0.0.1,localhost,", TRUE},
+    { "127.0.0.1", "127.0.0.1/8,localhost,", TRUE},
+    { "127.0.0.1", "127.0.0.1/28,localhost,", TRUE},
+    { "127.0.0.1", "127.0.0.1/31,localhost,", TRUE},
+    { "127.0.0.1", "localhost,127.0.0.1", TRUE},
     { "127.0.0.1", "localhost,127.0.0.1.127.0.0.1.127.0.0.1.127.0.0.1."
       "127.0.0.1.127.0.0.1.127.0.0.1.127.0.0.1.127.0.0.1.127.0.0.1.127."
-      "0.0.1.127.0.0.1.127.0.0." /* 128 bytes "address" */, FALSE, FALSE},
+      "0.0.1.127.0.0.1.127.0.0." /* 128 bytes "address" */, FALSE},
     { "127.0.0.1", "localhost,127.0.0.1.127.0.0.1.127.0.0.1.127.0.0.1."
       "127.0.0.1.127.0.0.1.127.0.0.1.127.0.0.1.127.0.0.1.127.0.0.1.127."
-      "0.0.1.127.0.0.1.127.0.0" /* 127 bytes "address" */, FALSE, FALSE},
-    { "localhost", "localhost,127.0.0.1", TRUE, FALSE},
-    { "localhost", "127.0.0.1,localhost", TRUE, FALSE},
-    { "foobar", "barfoo", FALSE, FALSE},
-    { "foobar", "foobar", TRUE, FALSE},
-    { "192.168.0.1", "foobar", FALSE, FALSE},
-    { "192.168.0.1", "192.168.0.0/16", TRUE, FALSE},
-    { "192.168.0.1", "192.168.0.0/24", TRUE, FALSE},
-    { "192.168.0.1", "192.168.0.0/32", FALSE, FALSE},
-    { "192.168.0.1", "192.168.0.0", FALSE, FALSE},
-    { "192.168.1.1", "192.168.0.0/24", FALSE, FALSE},
-    { "192.168.1.1", "foo, bar, 192.168.0.0/24", FALSE, FALSE},
-    { "192.168.1.1", "foo, bar, 192.168.0.0/16", TRUE, FALSE},
-    { "[::1]", "foo, bar, 192.168.0.0/16", FALSE, FALSE},
-    { "[::1]", "foo, bar, ::1/64", TRUE, FALSE},
-    { "bar", "foo, bar, ::1/64", TRUE, FALSE},
-    { "BAr", "foo, bar, ::1/64", TRUE, FALSE},
-    { "BAr", "foo,,,,,              bar, ::1/64", TRUE, FALSE},
-    { "www.example.com", "foo, .example.com", TRUE, FALSE},
-    { "www.example.com", "www2.example.com, .example.net", FALSE, FALSE},
-    { "example.com", ".example.com, .example.net", TRUE, FALSE},
-    { "nonexample.com", ".example.com, .example.net", FALSE, FALSE},
-    { NULL, NULL, FALSE, FALSE}
+      "0.0.1.127.0.0.1.127.0.0" /* 127 bytes "address" */, FALSE},
+    { "localhost", "localhost,127.0.0.1", TRUE},
+    { "localhost", "127.0.0.1,localhost", TRUE},
+    { "foobar", "barfoo", FALSE},
+    { "foobar", "foobar", TRUE},
+    { "192.168.0.1", "foobar", FALSE},
+    { "192.168.0.1", "192.168.0.0/16", TRUE},
+    { "192.168.0.1", "192.168.0.0/24", TRUE},
+    { "192.168.0.1", "192.168.0.0/32", FALSE},
+    { "192.168.0.1", "192.168.0.0", FALSE},
+    { "192.168.1.1", "192.168.0.0/24", FALSE},
+    { "192.168.1.1", "192.168.0.0/33", FALSE},
+    { "192.168.1.1", "foo, bar, 192.168.0.0/24", FALSE},
+    { "192.168.1.1", "foo, bar, 192.168.0.0/16", TRUE},
+    { "[::1]", "foo, bar, 192.168.0.0/16", FALSE},
+    { "[::1]", "foo, bar, ::1/64", TRUE},
+    { "[::1]", "::1/64", TRUE},
+    { "[::1]", "::1/96", TRUE},
+    { "[::1]", "::1/129", FALSE},
+    { "bar", "foo, bar, ::1/64", TRUE},
+    { "BAr", "foo, bar, ::1/64", TRUE},
+    { "BAr", "foo,,,,,              bar, ::1/64", TRUE},
+    { "www.example.com", "foo, .example.com", TRUE},
+    { "www.example.com", "www2.example.com, .example.net", FALSE},
+    { "example.com", ".example.com, .example.net", TRUE},
+    { "nonexample.com", ".example.com, .example.net", FALSE},
+    { NULL, NULL, FALSE}
   };
   for(i = 0; list4[i].a; i++) {
     bool match = Curl_cidr4_match(list4[i].a, list4[i].n, list4[i].bits);
@@ -144,19 +146,13 @@ UNITTEST_START
     }
   }
   for(i = 0; list[i].a; i++) {
-    bool spacesep = FALSE;
-    bool match = Curl_check_noproxy(list[i].a, list[i].n, &spacesep);
+    bool match = Curl_check_noproxy(list[i].a, list[i].n);
     if(match != list[i].match) {
       fprintf(stderr, "%s in %s should %smatch\n",
               list[i].a, list[i].n,
               list[i].match ? "": "not ");
       err++;
     }
-    if(spacesep != list[i].space) {
-      fprintf(stderr, "%s is claimed to be %sspace separated\n",
-              list[i].n, list[i].space?"":"NOT ");
-      err++;
-    }
   }
   fail_if(err, "errors");
 }
diff --git a/tests/unit/unit1620.c b/tests/unit/unit1620.c
index 4a457ff0e..5830d7836 100644
--- a/tests/unit/unit1620.c
+++ b/tests/unit/unit1620.c
@@ -40,14 +40,42 @@ static void unit_stop(void)
   curl_global_cleanup();
 }
 
+static void test_parse(
+  const char *input,
+  const char *exp_username,
+  const char *exp_password,
+  const char *exp_options)
+{
+  char *userstr = NULL;
+  char *passwdstr = NULL;
+  char *options = NULL;
+  CURLcode rc = Curl_parse_login_details(input, strlen(input),
+                                &userstr, &passwdstr, &options);
+  fail_unless(rc == CURLE_OK, "Curl_parse_login_details() failed");
+
+  fail_unless(!!exp_username == !!userstr, "username expectation failed");
+  fail_unless(!!exp_password == !!passwdstr, "password expectation failed");
+  fail_unless(!!exp_options == !!options, "options expectation failed");
+
+  if(!unitfail) {
+    fail_unless(!exp_username || strcmp(userstr, exp_username) == 0,
+                "userstr should be equal to exp_username");
+    fail_unless(!exp_password || strcmp(passwdstr, exp_password) == 0,
+                "passwdstr should be equal to exp_password");
+    fail_unless(!exp_options || strcmp(options, exp_options) == 0,
+                "options should be equal to exp_options");
+  }
+
+  free(userstr);
+  free(passwdstr);
+  free(options);
+}
+
 UNITTEST_START
 {
   CURLcode rc;
   struct Curl_easy *empty;
-  const char *hostname = "hostname";
   enum dupstring i;
-  char *userstr = NULL;
-  char *passwdstr = NULL;
 
   bool async = FALSE;
   bool protocol_connect = FALSE;
@@ -75,12 +103,20 @@ UNITTEST_START
   rc = Curl_init_do(empty, empty->conn);
   fail_unless(rc == CURLE_OK, "Curl_init_do() failed");
 
-  rc = Curl_parse_login_details(hostname, strlen(hostname),
-                                &userstr, &passwdstr, NULL);
-  fail_unless(rc == CURLE_OK,
-              "Curl_parse_login_details() failed");
-  free(userstr);
-  free(passwdstr);
+  test_parse("hostname", "hostname", NULL, NULL);
+  test_parse("user:password", "user", "password", NULL);
+  test_parse("user:password;options", "user", "password", "options");
+  test_parse("user:password;options;more", "user", "password", "options;more");
+  test_parse("", "", NULL, NULL);
+  test_parse(":", "", "", NULL);
+  test_parse(":;", "", "", NULL);
+  test_parse(":password", "", "password", NULL);
+  test_parse(":password;", "", "password", NULL);
+  test_parse(";options", "", NULL, "options");
+  test_parse("user;options", "user", NULL, "options");
+  test_parse("user:;options", "user", "", "options");
+  test_parse("user;options:password", "user", "password", "options");
+  test_parse("user;options:", "user", "", "options");
 
   Curl_freeset(empty);
   for(i = (enum dupstring)0; i < STRING_LAST; i++) {
diff --git a/tests/unit/unit1656.c b/tests/unit/unit1656.c
new file mode 100644
index 000000000..644e72fc7
--- /dev/null
+++ b/tests/unit/unit1656.c
@@ -0,0 +1,133 @@
+/***************************************************************************
+ *                                  _   _ ____  _
+ *  Project                     ___| | | |  _ \| |
+ *                             / __| | | | |_) | |
+ *                            | (__| |_| |  _ <| |___
+ *                             \___|\___/|_| \_\_____|
+ *
+ * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+ *
+ * This software is licensed as described in the file COPYING, which
+ * you should have received as part of this distribution. The terms
+ * are also available at https://curl.se/docs/copyright.html.
+ *
+ * You may opt to use, copy, modify, merge, publish, distribute and/or sell
+ * copies of the Software, and permit persons to whom the Software is
+ * furnished to do so, under the terms of the COPYING file.
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+ * KIND, either express or implied.
+ *
+ * SPDX-License-Identifier: curl
+ *
+ ***************************************************************************/
+#include "curlcheck.h"
+
+#include "vtls/x509asn1.h"
+
+static CURLcode unit_setup(void)
+{
+  return CURLE_OK;
+}
+
+static void unit_stop(void)
+{
+
+}
+
+#if defined(USE_GNUTLS) || defined(USE_SCHANNEL) || defined(USE_SECTRANSP) || \
+  defined(USE_MBEDTLS)
+
+#ifndef ARRAYSIZE
+#define ARRAYSIZE(A) (sizeof(A)/sizeof((A)[0]))
+#endif
+
+struct test_spec {
+  const char *input;
+  const char *exp_output;
+  CURLcode exp_result;
+};
+
+static struct test_spec test_specs[] = {
+  { "190321134340", "1903-21-13 43:40:00", CURLE_OK },
+  { "", NULL, CURLE_BAD_FUNCTION_ARGUMENT },
+  { "WTF", NULL, CURLE_BAD_FUNCTION_ARGUMENT },
+  { "0WTF", NULL, CURLE_BAD_FUNCTION_ARGUMENT },
+  { "19032113434", NULL, CURLE_BAD_FUNCTION_ARGUMENT },
+  { "19032113434WTF", NULL, CURLE_BAD_FUNCTION_ARGUMENT },
+  { "190321134340.", NULL, CURLE_BAD_FUNCTION_ARGUMENT },
+  { "190321134340.1", "1903-21-13 43:40:00.1", CURLE_OK },
+  { "19032113434017.0", "1903-21-13 43:40:17", CURLE_OK },
+  { "19032113434017.01", "1903-21-13 43:40:17.01", CURLE_OK },
+  { "19032113434003.001", "1903-21-13 43:40:03.001", CURLE_OK },
+  { "19032113434003.090", "1903-21-13 43:40:03.09", CURLE_OK },
+  { "190321134340Z", "1903-21-13 43:40:00 GMT", CURLE_OK },
+  { "19032113434017.0Z", "1903-21-13 43:40:17 GMT", CURLE_OK },
+  { "19032113434017.01Z", "1903-21-13 43:40:17.01 GMT", CURLE_OK },
+  { "19032113434003.001Z", "1903-21-13 43:40:03.001 GMT", CURLE_OK },
+  { "19032113434003.090Z", "1903-21-13 43:40:03.09 GMT", CURLE_OK },
+  { "190321134340CET", "1903-21-13 43:40:00 CET", CURLE_OK },
+  { "19032113434017.0CET", "1903-21-13 43:40:17 CET", CURLE_OK },
+  { "19032113434017.01CET", "1903-21-13 43:40:17.01 CET", CURLE_OK },
+  { "190321134340+02:30", "1903-21-13 43:40:00 UTC+02:30", CURLE_OK },
+  { "19032113434017.0+02:30", "1903-21-13 43:40:17 UTC+02:30", CURLE_OK },
+  { "19032113434017.01+02:30", "1903-21-13 43:40:17.01 UTC+02:30", CURLE_OK },
+  { "190321134340-3", "1903-21-13 43:40:00 UTC-3", CURLE_OK },
+  { "19032113434017.0-04", "1903-21-13 43:40:17 UTC-04", CURLE_OK },
+  { "19032113434017.01-01:10", "1903-21-13 43:40:17.01 UTC-01:10", CURLE_OK },
+};
+
+static bool do_test(struct test_spec *spec, size_t i, struct dynbuf *dbuf)
+{
+  CURLcode result;
+  const char *in = spec->input;
+
+  Curl_dyn_reset(dbuf);
+  result = Curl_x509_GTime2str(dbuf, in, in + strlen(in));
+  if(result != spec->exp_result) {
+    fprintf(stderr, "test %zu: expect result %d, got %d\n",
+            i, spec->exp_result, result);
+    return FALSE;
+  }
+  else if(!result && strcmp(spec->exp_output, Curl_dyn_ptr(dbuf))) {
+    fprintf(stderr, "test %zu: input '%s', expected output '%s', got '%s'\n",
+            i, in, spec->exp_output, Curl_dyn_ptr(dbuf));
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+UNITTEST_START
+{
+  size_t i;
+  struct dynbuf dbuf;
+  bool all_ok = TRUE;
+
+  Curl_dyn_init(&dbuf, 32*1024);
+
+  if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
+    fprintf(stderr, "curl_global_init() failed\n");
+    return TEST_ERR_MAJOR_BAD;
+  }
+
+  for(i = 0; i < ARRAYSIZE(test_specs); ++i) {
+    if(!do_test(&test_specs[i], i, &dbuf))
+      all_ok = FALSE;
+  }
+  fail_unless(all_ok, "some tests of Curl_x509_GTime2str() fails");
+
+  Curl_dyn_free(&dbuf);
+  curl_global_cleanup();
+}
+UNITTEST_STOP
+
+#else
+
+UNITTEST_START
+{
+  puts("not tested since Curl_x509_GTime2str() is not built-in");
+}
+UNITTEST_STOP
+
+#endif
diff --git a/tests/unit/unit1663.c b/tests/unit/unit1663.c
new file mode 100644
index 000000000..f4801fe5c
--- /dev/null
+++ b/tests/unit/unit1663.c
@@ -0,0 +1,98 @@
+/***************************************************************************
+ *                                  _   _ ____  _
+ *  Project                     ___| | | |  _ \| |
+ *                             / __| | | | |_) | |
+ *                            | (__| |_| |  _ <| |___
+ *                             \___|\___/|_| \_\_____|
+ *
+ * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+ *
+ * This software is licensed as described in the file COPYING, which
+ * you should have received as part of this distribution. The terms
+ * are also available at https://curl.se/docs/copyright.html.
+ *
+ * You may opt to use, copy, modify, merge, publish, distribute and/or sell
+ * copies of the Software, and permit persons to whom the Software is
+ * furnished to do so, under the terms of the COPYING file.
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+ * KIND, either express or implied.
+ *
+ * SPDX-License-Identifier: curl
+ *
+ ***************************************************************************/
+#include "curlcheck.h"
+
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_IN6_H
+#include <netinet/in6.h>
+#endif
+
+#include <curl/curl.h>
+
+#include "cf-socket.h"
+
+#include "memdebug.h" /* LAST include file */
+
+static CURLcode unit_setup(void)
+{
+  CURLcode res = CURLE_OK;
+  global_init(CURL_GLOBAL_ALL);
+  return res;
+}
+
+static void unit_stop(void)
+{
+  curl_global_cleanup();
+}
+
+static void test_parse(
+  const char *input,
+  const char *exp_dev,
+  const char *exp_iface,
+  const char *exp_host,
+  CURLcode exp_rc)
+{
+  char *dev = NULL;
+  char *iface = NULL;
+  char *host = NULL;
+  CURLcode rc = Curl_parse_interface(
+    input, strlen(input), &dev, &iface, &host);
+  fail_unless(rc == exp_rc, "Curl_parse_interface() failed");
+
+  fail_unless(!!exp_dev == !!dev, "dev expectation failed.");
+  fail_unless(!!exp_iface == !!iface, "iface expectation failed");
+  fail_unless(!!exp_host == !!host, "host expectation failed");
+
+  if(!unitfail) {
+    fail_unless(!exp_dev || strcmp(dev, exp_dev) == 0,
+                "dev should be equal to exp_dev");
+    fail_unless(!exp_iface || strcmp(iface, exp_iface) == 0,
+                "iface should be equal to exp_iface");
+    fail_unless(!exp_host || strcmp(host, exp_host) == 0,
+                "host should be equal to exp_host");
+  }
+
+  free(dev);
+  free(iface);
+  free(host);
+}
+
+UNITTEST_START
+{
+  test_parse("dev", "dev", NULL, NULL, CURLE_OK);
+  test_parse("if!eth0", NULL, "eth0", NULL, CURLE_OK);
+  test_parse("host!myname", NULL, NULL, "myname", CURLE_OK);
+  test_parse("ifhost!eth0!myname", NULL, "eth0", "myname", CURLE_OK);
+  test_parse("", NULL, NULL, NULL, CURLE_BAD_FUNCTION_ARGUMENT);
+  test_parse("!", "!", NULL, NULL, CURLE_OK);
+  test_parse("if!", NULL, NULL, NULL, CURLE_BAD_FUNCTION_ARGUMENT);
+  test_parse("if!eth0!blubb", NULL, "eth0!blubb", NULL, CURLE_OK);
+  test_parse("host!", NULL, NULL, NULL, CURLE_BAD_FUNCTION_ARGUMENT);
+  test_parse("ifhost!", NULL, NULL, NULL, CURLE_BAD_FUNCTION_ARGUMENT);
+  test_parse("ifhost!eth0", NULL, NULL, NULL, CURLE_BAD_FUNCTION_ARGUMENT);
+  test_parse("ifhost!eth0!", NULL, NULL, NULL, CURLE_BAD_FUNCTION_ARGUMENT);
+}
+UNITTEST_STOP
diff --git a/tests/unit/unit2600.c b/tests/unit/unit2600.c
index 1cbb9ef28..5a3def407 100644
--- a/tests/unit/unit2600.c
+++ b/tests/unit/unit2600.c
@@ -47,6 +47,7 @@
 #include "connect.h"
 #include "cfilters.h"
 #include "multiif.h"
+#include "select.h"
 #include "curl_trc.h"
 
 
@@ -62,6 +63,7 @@ static CURLcode unit_setup(void)
     curl_global_cleanup();
     return CURLE_OUT_OF_MEMORY;
   }
+  curl_global_trace("all");
   curl_easy_setopt(easy, CURLOPT_VERBOSE, 1L);
   return res;
 }
@@ -72,8 +74,6 @@ static void unit_stop(void)
   curl_global_cleanup();
 }
 
-#ifdef DEBUGBUILD
-
 struct test_case {
   int id;
   const char *url;
@@ -148,12 +148,23 @@ static CURLcode cf_test_connect(struct Curl_cfilter *cf,
           (int)duration_ms, ctx->id);
     return CURLE_COULDNT_CONNECT;
   }
-  if(duration_ms)
+  if(duration_ms) {
     infof(data, "%04dms: cf[%s] continuing", (int)duration_ms, ctx->id);
+    Curl_wait_ms(10);
+  }
   Curl_expire(data, ctx->fail_delay_ms - duration_ms, EXPIRE_RUN_NOW);
   return CURLE_OK;
 }
 
+static void cf_test_adjust_pollset(struct Curl_cfilter *cf,
+                                   struct Curl_easy *data,
+                                   struct easy_pollset *ps)
+{
+  /* just for testing, give one socket with events back */
+  (void)cf;
+  Curl_pollset_set(data, ps, 1, TRUE, TRUE);
+}
+
 static struct Curl_cftype cft_test = {
   "TEST",
   CF_TYPE_IP_CONNECT,
@@ -161,8 +172,9 @@ static struct Curl_cftype cft_test = {
   cf_test_destroy,
   cf_test_connect,
   Curl_cf_def_close,
+  Curl_cf_def_shutdown,
   Curl_cf_def_get_host,
-  Curl_cf_def_adjust_pollset,
+  cf_test_adjust_pollset,
   Curl_cf_def_data_pending,
   Curl_cf_def_send,
   Curl_cf_def_recv,
@@ -329,8 +341,6 @@ static void test_connect(struct test_case *tc)
   check_result(tc, &tr);
 }
 
-#endif /* DEBUGBUILD */
-
 /*
  * How these test cases work:
  * - replace the creation of the TCP socket filter with our test filter
@@ -385,15 +395,10 @@ static struct test_case TEST_CASES[] = {
 
 UNITTEST_START
 
-#if defined(DEBUGBUILD)
   size_t i;
 
   for(i = 0; i < sizeof(TEST_CASES)/sizeof(TEST_CASES[0]); ++i) {
     test_connect(&TEST_CASES[i]);
   }
-#else
-  (void)TEST_CASES;
-  (void)test_connect;
-#endif
 
 UNITTEST_STOP
diff --git a/tests/unit/unit2604.c b/tests/unit/unit2604.c
index 82b7e5636..734827b0e 100644
--- a/tests/unit/unit2604.c
+++ b/tests/unit/unit2604.c
@@ -50,7 +50,6 @@ UNITTEST_START
 /* 540 a's */
 #define SA540 SA60 SA60 SA60 SA60 SA60 SA60 SA60 SA60 SA60
   int i;
-  int error = 0;
   size_t too_long = 90720;
   struct set list[] = {
     { "-too-long-", "", "", "", CURLE_TOO_LARGE},
@@ -85,18 +84,18 @@ UNITTEST_START
            list[i].cp, list[i].home, list[i].result);
     if(result != list[i].result) {
       printf("... returned %d\n", result);
-      error++;
+      unitfail++;
     }
     if(!result) {
       if(cp && strcmp(cp, list[i].next)) {
         printf("... cp points to '%s', not '%s' as expected \n",
                cp, list[i].next);
-        error++;
+        unitfail++;
       }
       if(path && strcmp(path, list[i].expect)) {
         printf("... gave '%s', not '%s' as expected \n",
                path, list[i].expect);
-        error++;
+        unitfail++;
       }
       curl_free(path);
 
@@ -104,7 +103,6 @@ UNITTEST_START
   }
 
   free((void *)list[0].cp);
-  return error == 0 ? CURLE_OK : TEST_ERR_FAILURE;
 }
 #endif
 
diff --git a/tests/unit/unit3205.c b/tests/unit/unit3205.c
index 19c82ef34..6b75c2856 100644
--- a/tests/unit/unit3205.c
+++ b/tests/unit/unit3205.c
@@ -34,7 +34,7 @@ static void unit_stop(void)
 {
 }
 
-#if defined(USE_MBEDTLS) || defined(USE_BEARSSL)
+#if defined(USE_SECTRANSP) || defined(USE_MBEDTLS) || defined(USE_BEARSSL)
 
 struct test_cs_entry {
   uint16_t id;
@@ -106,7 +106,7 @@ static const struct test_cs_entry test_cs_list[] = {
             "ECDHE-RSA-CHACHA20-POLY1305" },
   { 0xCCA9, "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
             "ECDHE-ECDSA-CHACHA20-POLY1305" },
-#if defined(USE_MBEDTLS)
+#if defined(USE_SECTRANSP) || defined(USE_MBEDTLS)
   { 0x0001, "TLS_RSA_WITH_NULL_MD5",
             "NULL-MD5" },
   { 0x0002, "TLS_RSA_WITH_NULL_SHA",
@@ -204,7 +204,7 @@ static const struct test_cs_entry test_cs_list[] = {
   { 0xCCAB, "TLS_PSK_WITH_CHACHA20_POLY1305_SHA256",
             "PSK-CHACHA20-POLY1305" },
 #endif
-#if defined(USE_BEARSSL)
+#if defined(USE_SECTRANSP)  || defined(USE_BEARSSL)
   { 0x000A, "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
             "DES-CBC3-SHA" },
   { 0xC003, "TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA",
@@ -216,6 +216,7 @@ static const struct test_cs_entry test_cs_list[] = {
   { 0xC012, "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
             "ECDHE-RSA-DES-CBC3-SHA" },
 #endif
+#if defined(USE_MBEDTLS) || defined(USE_BEARSSL)
   { 0xC09C, "TLS_RSA_WITH_AES_128_CCM",
             "AES128-CCM" },
   { 0xC09D, "TLS_RSA_WITH_AES_256_CCM",
@@ -232,8 +233,150 @@ static const struct test_cs_entry test_cs_list[] = {
             "ECDHE-ECDSA-AES128-CCM8" },
   { 0xC0AF, "TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8",
             "ECDHE-ECDSA-AES256-CCM8" },
+#endif
+#if defined(USE_SECTRANSP)
+  { 0x0003, "TLS_RSA_EXPORT_WITH_RC4_40_MD5",
+            "EXP-RC4-MD5" },
+  { 0x0004, "TLS_RSA_WITH_RC4_128_MD5",
+            "RC4-MD5" },
+  { 0x0005, "TLS_RSA_WITH_RC4_128_SHA",
+            "RC4-SHA" },
+  { 0x0006, "TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5",
+            "EXP-RC2-CBC-MD5" },
+  { 0x0007, "TLS_RSA_WITH_IDEA_CBC_SHA",
+            "IDEA-CBC-SHA" },
+  { 0x0008, "TLS_RSA_EXPORT_WITH_DES40_CBC_SHA",
+            "EXP-DES-CBC-SHA" },
+  { 0x0009, "TLS_RSA_WITH_DES_CBC_SHA",
+            "DES-CBC-SHA" },
+  { 0x000B, "TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA",
+            "EXP-DH-DSS-DES-CBC-SHA" },
+  { 0x000C, "TLS_DH_DSS_WITH_DES_CBC_SHA",
+            "DH-DSS-DES-CBC-SHA" },
+  { 0x000D, "TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA",
+            "DH-DSS-DES-CBC3-SHA" },
+  { 0x000E, "TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA",
+            "EXP-DH-RSA-DES-CBC-SHA" },
+  { 0x000F, "TLS_DH_RSA_WITH_DES_CBC_SHA",
+            "DH-RSA-DES-CBC-SHA" },
+  { 0x0010, "TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA",
+            "DH-RSA-DES-CBC3-SHA" },
+  { 0x0011, "TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA",
+            "EXP-DHE-DSS-DES-CBC-SHA" },
+  { 0x0012, "TLS_DHE_DSS_WITH_DES_CBC_SHA",
+            "DHE-DSS-DES-CBC-SHA" },
+  { 0x0013, "TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA",
+            "DHE-DSS-DES-CBC3-SHA" },
+  { 0x0014, "TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA",
+            "EXP-DHE-RSA-DES-CBC-SHA" },
+  { 0x0015, "TLS_DHE_RSA_WITH_DES_CBC_SHA",
+            "DHE-RSA-DES-CBC-SHA" },
+  { 0x0016, "TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA",
+            "DHE-RSA-DES-CBC3-SHA" },
+  { 0x0017, "TLS_DH_anon_EXPORT_WITH_RC4_40_MD5",
+            "EXP-ADH-RC4-MD5" },
+  { 0x0018, "TLS_DH_anon_WITH_RC4_128_MD5",
+            "ADH-RC4-MD5" },
+  { 0x0019, "TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA",
+            "EXP-ADH-DES-CBC-SHA" },
+  { 0x001A, "TLS_DH_anon_WITH_DES_CBC_SHA",
+            "ADH-DES-CBC-SHA" },
+  { 0x001B, "TLS_DH_anon_WITH_3DES_EDE_CBC_SHA",
+            "ADH-DES-CBC3-SHA" },
+  { 0x0030, "TLS_DH_DSS_WITH_AES_128_CBC_SHA",
+            "DH-DSS-AES128-SHA" },
+  { 0x0031, "TLS_DH_RSA_WITH_AES_128_CBC_SHA",
+            "DH-RSA-AES128-SHA" },
+  { 0x0032, "TLS_DHE_DSS_WITH_AES_128_CBC_SHA",
+            "DHE-DSS-AES128-SHA" },
+  { 0x0034, "TLS_DH_anon_WITH_AES_128_CBC_SHA",
+            "ADH-AES128-SHA" },
+  { 0x0036, "TLS_DH_DSS_WITH_AES_256_CBC_SHA",
+            "DH-DSS-AES256-SHA" },
+  { 0x0037, "TLS_DH_RSA_WITH_AES_256_CBC_SHA",
+            "DH-RSA-AES256-SHA" },
+  { 0x0038, "TLS_DHE_DSS_WITH_AES_256_CBC_SHA",
+            "DHE-DSS-AES256-SHA" },
+  { 0x003A, "TLS_DH_anon_WITH_AES_256_CBC_SHA",
+            "ADH-AES256-SHA" },
+  { 0x003E, "TLS_DH_DSS_WITH_AES_128_CBC_SHA256",
+            "DH-DSS-AES128-SHA256" },
+  { 0x003F, "TLS_DH_RSA_WITH_AES_128_CBC_SHA256",
+            "DH-RSA-AES128-SHA256" },
+  { 0x0040, "TLS_DHE_DSS_WITH_AES_128_CBC_SHA256",
+            "DHE-DSS-AES128-SHA256" },
+  { 0x0068, "TLS_DH_DSS_WITH_AES_256_CBC_SHA256",
+            "DH-DSS-AES256-SHA256" },
+  { 0x0069, "TLS_DH_RSA_WITH_AES_256_CBC_SHA256",
+            "DH-RSA-AES256-SHA256" },
+  { 0x006A, "TLS_DHE_DSS_WITH_AES_256_CBC_SHA256",
+            "DHE-DSS-AES256-SHA256" },
+  { 0x006C, "TLS_DH_anon_WITH_AES_128_CBC_SHA256",
+            "ADH-AES128-SHA256" },
+  { 0x006D, "TLS_DH_anon_WITH_AES_256_CBC_SHA256",
+            "ADH-AES256-SHA256" },
+  { 0x008A, "TLS_PSK_WITH_RC4_128_SHA",
+            "PSK-RC4-SHA" },
+  { 0x008B, "TLS_PSK_WITH_3DES_EDE_CBC_SHA",
+            "PSK-3DES-EDE-CBC-SHA" },
+  { 0x008E, "TLS_DHE_PSK_WITH_RC4_128_SHA",
+            "DHE-PSK-RC4-SHA" },
+  { 0x008F, "TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA",
+            "DHE-PSK-3DES-EDE-CBC-SHA" },
+  { 0x0092, "TLS_RSA_PSK_WITH_RC4_128_SHA",
+            "RSA-PSK-RC4-SHA" },
+  { 0x0093, "TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA",
+            "RSA-PSK-3DES-EDE-CBC-SHA" },
+  { 0x00A0, "TLS_DH_RSA_WITH_AES_128_GCM_SHA256",
+            "DH-RSA-AES128-GCM-SHA256" },
+  { 0x00A1, "TLS_DH_RSA_WITH_AES_256_GCM_SHA384",
+            "DH-RSA-AES256-GCM-SHA384" },
+  { 0x00A2, "TLS_DHE_DSS_WITH_AES_128_GCM_SHA256",
+            "DHE-DSS-AES128-GCM-SHA256" },
+  { 0x00A3, "TLS_DHE_DSS_WITH_AES_256_GCM_SHA384",
+            "DHE-DSS-AES256-GCM-SHA384" },
+  { 0x00A4, "TLS_DH_DSS_WITH_AES_128_GCM_SHA256",
+            "DH-DSS-AES128-GCM-SHA256" },
+  { 0x00A5, "TLS_DH_DSS_WITH_AES_256_GCM_SHA384",
+            "DH-DSS-AES256-GCM-SHA384" },
+  { 0x00A6, "TLS_DH_anon_WITH_AES_128_GCM_SHA256",
+            "ADH-AES128-GCM-SHA256" },
+  { 0x00A7, "TLS_DH_anon_WITH_AES_256_GCM_SHA384",
+            "ADH-AES256-GCM-SHA384" },
+  { 0xC002, "TLS_ECDH_ECDSA_WITH_RC4_128_SHA",
+            "ECDH-ECDSA-RC4-SHA" },
+  { 0xC007, "TLS_ECDHE_ECDSA_WITH_RC4_128_SHA",
+            "ECDHE-ECDSA-RC4-SHA" },
+  { 0xC00C, "TLS_ECDH_RSA_WITH_RC4_128_SHA",
+            "ECDH-RSA-RC4-SHA" },
+  { 0xC011, "TLS_ECDHE_RSA_WITH_RC4_128_SHA",
+            "ECDHE-RSA-RC4-SHA" },
+  { 0xC015, "TLS_ECDH_anon_WITH_NULL_SHA",
+            "AECDH-NULL-SHA" },
+  { 0xC016, "TLS_ECDH_anon_WITH_RC4_128_SHA",
+            "AECDH-RC4-SHA" },
+  { 0xC017, "TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA",
+            "AECDH-DES-CBC3-SHA" },
+  { 0xC018, "TLS_ECDH_anon_WITH_AES_128_CBC_SHA",
+            "AECDH-AES128-SHA" },
+  { 0xC019, "TLS_ECDH_anon_WITH_AES_256_CBC_SHA",
+            "AECDH-AES256-SHA" },
+  /* Backward compatible aliases (EDH vs DHE) */
+  { 0x0011, "TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA",
+            "EXP-EDH-DSS-DES-CBC-SHA" },
+  { 0x0012, "TLS_DHE_DSS_WITH_DES_CBC_SHA",
+            "EDH-DSS-DES-CBC-SHA" },
+  { 0x0013, "TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA",
+            "EDH-DSS-DES-CBC3-SHA" },
+  { 0x0014, "TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA",
+            "EXP-EDH-RSA-DES-CBC-SHA" },
+  { 0x0015, "TLS_DHE_RSA_WITH_DES_CBC_SHA",
+            "EDH-RSA-DES-CBC-SHA" },
+  { 0x0016, "TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA",
+            "EDH-RSA-DES-CBC3-SHA" },
+#endif
 #if defined(USE_MBEDTLS)
-  /* entries marked ns are non-"standard", they are not in openssl */
+  /* entries marked ns are non-"standard", they are not in OpenSSL */
   { 0x0041, "TLS_RSA_WITH_CAMELLIA_128_CBC_SHA",
             "CAMELLIA128-SHA" },
   { 0x0045, "TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA",
@@ -461,7 +604,7 @@ struct test_str_entry {
   const char *str;
 };
 static const struct test_str_entry test_str_list[] = {
-#if defined(USE_MBEDTLS)
+#if defined(USE_SECTRANSP) || defined(USE_MBEDTLS)
   { 0x1301, "TLS_AES_128_GCM_SHA256"},
   { 0x1302, "TLS_AES_256_GCM_SHA384"},
   { 0x1303, "TLS_CHACHA20_POLY1305_SHA256"},
@@ -476,13 +619,16 @@ static const struct test_str_entry test_str_list[] = {
   { 0xC030, "ECDHE-RSA-AES256-GCM-SHA384"},
   { 0xCCA9, "ECDHE-ECDSA-CHACHA20-POLY1305"},
   { 0xCCA8, "ECDHE-RSA-CHACHA20-POLY1305"},
-#if defined(USE_MBEDTLS)
+#if defined(USE_SECTRANSP) || defined(USE_MBEDTLS)
   { 0x009E, "DHE-RSA-AES128-GCM-SHA256"},
   { 0x009F, "DHE-RSA-AES256-GCM-SHA384"},
-  { 0xCCAA, "DHE-RSA-CHACHA20-POLY1305"},
 #else
   { 0x0000, "DHE-RSA-AES128-GCM-SHA256"},
   { 0x0000, "DHE-RSA-AES256-GCM-SHA384"},
+#endif
+#if defined(USE_MBEDTLS)
+  { 0xCCAA, "DHE-RSA-CHACHA20-POLY1305"},
+#else
   { 0x0000, "DHE-RSA-CHACHA20-POLY1305"},
 #endif
   { 0xC023, "ECDHE-ECDSA-AES128-SHA256" },
@@ -493,7 +639,7 @@ static const struct test_str_entry test_str_list[] = {
   { 0xC028, "ECDHE-RSA-AES256-SHA384" },
   { 0xC00A, "ECDHE-ECDSA-AES256-SHA" },
   { 0xC014, "ECDHE-RSA-AES256-SHA" },
-#if defined(USE_MBEDTLS)
+#if defined(USE_SECTRANSP) || defined(USE_MBEDTLS)
   { 0x0067, "DHE-RSA-AES128-SHA256" },
   { 0x006B, "DHE-RSA-AES256-SHA256" },
 #else
@@ -506,7 +652,7 @@ static const struct test_str_entry test_str_list[] = {
   { 0x003D, "AES256-SHA256" },
   { 0x002F, "AES128-SHA" },
   { 0x0035, "AES256-SHA" },
-#if defined(USE_BEARSSL)
+#if defined(USE_SECTRANSP) || defined(USE_BEARSSL)
   { 0x000A, "DES-CBC3-SHA" },
 #else
   { 0x0000, "DES-CBC3-SHA" },
@@ -522,6 +668,7 @@ UNITTEST_START
     const struct test_cs_entry *test = &test_cs_list[i];
     const char *expect;
     char buf[64] = "";
+    char alt[64] = "";
     uint16_t id;
 
     /* test Curl_cipher_suite_lookup_id() for rfc name */
@@ -535,7 +682,7 @@ UNITTEST_START
       }
     }
 
-    /* test Curl_cipher_suite_lookup_id() for openssl name */
+    /* test Curl_cipher_suite_lookup_id() for OpenSSL name */
     if(test->openssl) {
       id = Curl_cipher_suite_lookup_id(test->openssl, strlen(test->openssl));
       if(id != test->id) {
@@ -559,12 +706,20 @@ UNITTEST_START
       unitfail++;
     }
 
-    /* test Curl_cipher_suite_get_str() prefer openssl name */
+    /* test Curl_cipher_suite_get_str() prefer OpenSSL name */
     buf[0] = '\0';
     expect = test->openssl ? test->openssl : test->rfc;
 
     Curl_cipher_suite_get_str(test->id, buf, sizeof(buf), false);
 
+    /* suites matched by EDH alias will return the DHE name */
+    if(test->id >= 0x0011 && test->id < 0x0017) {
+      if(memcmp(expect, "EDH-", 4) == 0)
+        expect = (char *) memcpy(strcpy(alt, expect), "DHE-", 4);
+      if(memcmp(expect + 4, "EDH-", 4) == 0)
+        expect = (char *) memcpy(strcpy(alt, expect) + 4, "DHE-", 4) - 4;
+    }
+
     if(strcmp(buf, expect) != 0) {
       fprintf(stderr, "Curl_cipher_suite_get_str FAILED for 0x%04x, "
                       "result = \"%s\", expected = \"%s\"\n",
@@ -607,9 +762,11 @@ UNITTEST_START
 }
 UNITTEST_STOP
 
-#else /* defined(USE_MBEDTLS) || defined(USE_BEARSSL) */
+#else /* defined(USE_SECTRANSP) || defined(USE_MBEDTLS) || \
+          defined(USE_BEARSSL) */
 
 UNITTEST_START
 UNITTEST_STOP
 
-#endif /* defined(USE_MBEDTLS) || defined(USE_BEARSSL) */
+#endif /* defined(USE_SECTRANSP) || defined(USE_MBEDTLS) || \
+          defined(USE_BEARSSL) */
diff --git a/winbuild/MakefileBuild.vc b/winbuild/MakefileBuild.vc
index 474557bf5..38f77184b 100644
--- a/winbuild/MakefileBuild.vc
+++ b/winbuild/MakefileBuild.vc
@@ -1,714 +1,714 @@
-#***************************************************************************
-#                                  _   _ ____  _
-#  Project                     ___| | | |  _ \| |
-#                             / __| | | | |_) | |
-#                            | (__| |_| |  _ <| |___
-#                             \___|\___/|_| \_\_____|
-#
-# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
-#
-# This software is licensed as described in the file COPYING, which
-# you should have received as part of this distribution. The terms
-# are also available at https://curl.se/docs/copyright.html.
-#
-# You may opt to use, copy, modify, merge, publish, distribute and/or sell
-# copies of the Software, and permit persons to whom the Software is
-# furnished to do so, under the terms of the COPYING file.
-#
-# This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
-# KIND, either express or implied.
-#
-# SPDX-License-Identifier: curl
-#
-#***************************************************************************
-
-###########################################################################
-#
-# Makefile for building libcurl with MSVC
-#
-# Usage: see README.md
-#
-##############################################################
-
-CFGSET=FALSE
-WINBUILD_DIR=`cd`
-
-# Utilities.
-# If a path is required that contains characters such as space, quote the path.
-MT         = mt.exe
-RC         = rc.exe
-ZIP        = zip.exe
-
-# Allow changing C compiler via environment variable CC (default cl.exe)
-# This command macro is not set by default: https://msdn.microsoft.com/en-us/library/ms933742.aspx
-!If "$(CC)" == ""
-CC = cl.exe
-!Endif
-
-!IF "$(VC)"=="6"
-CC_NODEBUG  = $(CC) /O2 /DNDEBUG
-CC_DEBUG    = $(CC) /Od /Gm /Zi /D_DEBUG /GZ
-CFLAGS      = /I. /I../lib /I../include /nologo /W4 /GX /DWIN32 /YX /FD /c /DBUILDING_LIBCURL
-!ELSE
-CC_NODEBUG  = $(CC) /O2 /DNDEBUG
-CC_DEBUG    = $(CC) /Od /D_DEBUG /RTC1 /Z7 /LDd
-CFLAGS      = /I. /I ../lib /I../include /nologo /W4 /EHsc /DWIN32 /FD /c /DBUILDING_LIBCURL
-!ENDIF
-
-LFLAGS     = /nologo /machine:$(MACHINE)
-LNKDLL     = link.exe /DLL
-# Use lib.exe instead of link.exe as link.exe /lib has the following bad habits:
-# - optimizing options like /opt:ref raises warnings (at least in Visual Studio 2015)
-# - all (including Windows) dependencies are aggregated (as static parts)
-# - link.exe /lib is not documented (anymore) at MSDN
-# Instead of id: just create an archive, that contains all objects
-LNKLIB     = lib.exe
-
-CFLAGS_PDB = /Zi
-LFLAGS_PDB = /incremental:no /opt:ref,icf /DEBUG
-
-CFLAGS_LIBCURL_STATIC  = /DCURL_STATICLIB
-
-WIN_LIBS    = ws2_32.lib wldap32.lib advapi32.lib crypt32.lib
-
-BASE_NAME              = libcurl
-BASE_NAME_DEBUG        = $(BASE_NAME)_debug
-BASE_NAME_STATIC       = $(BASE_NAME)_a
-BASE_NAME_STATIC_DEBUG = $(BASE_NAME_STATIC)_debug
-
-LIB_NAME_STATIC        = $(BASE_NAME_STATIC).lib
-LIB_NAME_STATIC_DEBUG  = $(BASE_NAME_STATIC_DEBUG).lib
-LIB_NAME_DLL           = $(BASE_NAME).dll
-LIB_NAME_IMP           = $(BASE_NAME).lib
-LIB_NAME_DLL_DEBUG     = $(BASE_NAME_DEBUG).dll
-LIB_NAME_IMP_DEBUG     = $(BASE_NAME_DEBUG).lib
-
-PDB_NAME_STATIC        = $(BASE_NAME_STATIC).pdb
-PDB_NAME_STATIC_DEBUG  = $(BASE_NAME_STATIC_DEBUG).pdb
-PDB_NAME_DLL           = $(BASE_NAME).pdb
-PDB_NAME_DLL_DEBUG     = $(BASE_NAME_DEBUG).pdb
-
-# CURL Command section
-PROGRAM_NAME  = curl.exe
-CURL_CFLAGS   = /I../lib /I../include /nologo /W4 /EHsc /DWIN32 /FD /c
-CURL_LFLAGS   = /out:$(DIRDIST)\bin\$(PROGRAM_NAME) /subsystem:console $(LFLAGS)
-CURL_RESFLAGS = /i../include
-
-#############################################################
-## Nothing more to do below this line!
-LIBCURL_SRC_DIR = ..\lib
-CURL_SRC_DIR = ..\src
-
-!IFNDEF WITH_DEVEL
-WITH_DEVEL   = ../../deps
-!ENDIF
-DEVEL_INCLUDE= $(WITH_DEVEL)/include
-DEVEL_LIB    = $(WITH_DEVEL)/lib
-
-!IF EXISTS("$(DEVEL_INCLUDE)")
-CFLAGS       = $(CFLAGS) /I"$(DEVEL_INCLUDE)"
-!ENDIF
-!IF EXISTS("$(DEVEL_LIB)")
-LFLAGS       = $(LFLAGS) "/LIBPATH:$(DEVEL_LIB)"
-!ENDIF
-
-!IFDEF SSL_PATH
-SSL_INC_DIR  = $(SSL_PATH)\include
-SSL_LIB_DIR  = $(SSL_PATH)\lib
-SSL_LFLAGS   = $(SSL_LFLAGS) "/LIBPATH:$(SSL_LIB_DIR)"
-!ELSE
-SSL_INC_DIR=$(DEVEL_INCLUDE)\openssl
-SSL_LIB_DIR=$(DEVEL_LIB)
-!ENDIF
-
-!IF "$(WITH_SSL)"=="dll" || "$(WITH_SSL)"=="static"
-!IF EXISTS("$(SSL_LIB_DIR)\libssl.lib")
-SSL_LIBS     = libssl.lib libcrypto.lib
-!ELSE
-SSL_LIBS     = libeay32.lib ssleay32.lib
-!ENDIF
-USE_SSL      = true
-SSL          = $(WITH_SSL)
-!IF "$(WITH_SSL)"=="static"
-WIN_LIBS     = $(WIN_LIBS) gdi32.lib user32.lib crypt32.lib
-!ENDIF
-!ENDIF
-
-!IFDEF USE_SSL
-SSL_CFLAGS   = /DUSE_OPENSSL /I"$(SSL_INC_DIR)"
-!IF "$(ENABLE_OPENSSL_AUTO_LOAD_CONFIG)"=="false"
-SSL_CFLAGS   = $(SSL_CFLAGS) /DCURL_DISABLE_OPENSSL_AUTO_LOAD_CONFIG
-!ENDIF
-!ENDIF
-
-!IF "$(ENABLE_WEBSOCKETS)"=="true"
-CFLAGS  = $(CFLAGS) /DUSE_WEBSOCKETS=1
-!ENDIF
-
-!IFDEF NGHTTP2_PATH
-NGHTTP2_INC_DIR  = $(NGHTTP2_PATH)\include
-NGHTTP2_LIB_DIR  = $(NGHTTP2_PATH)\lib
-NGHTTP2_LFLAGS   = $(NGHTTP2_LFLAGS) "/LIBPATH:$(NGHTTP2_LIB_DIR)"
-!ELSE
-NGHTTP2_INC_DIR  = $(DEVEL_INCLUDE)
-NGHTTP2_LIB_DIR  = $(DEVEL_LIB)
-!ENDIF
-
-!IF "$(WITH_NGHTTP2)"=="dll"
-NGHTTP2_CFLAGS   = /DUSE_NGHTTP2 /I"$(NGHTTP2_INC_DIR)"
-NGHTTP2_LIBS     = nghttp2.lib
-!ELSEIF "$(WITH_NGHTTP2)"=="static"
-NGHTTP2_CFLAGS   = /DUSE_NGHTTP2 /DNGHTTP2_STATICLIB /I"$(NGHTTP2_INC_DIR)"
-!IF EXISTS("$(NGHTTP2_LIB_DIR)\nghttp2_static.lib")
-NGHTTP2_LIBS     = nghttp2_static.lib
-!ELSE
-NGHTTP2_LIBS     = nghttp2.lib
-!ENDIF
-!ENDIF
-
-!IFDEF MSH3_PATH
-MSH3_INC_DIR     = $(MSH3_PATH)\include
-MSH3_LIB_DIR     = $(MSH3_PATH)\lib
-MSH3_LFLAGS      = $(MSH3_LFLAGS) "/LIBPATH:$(MSH3_LIB_DIR)"
-!ELSE
-MSH3_INC_DIR     = $(DEVEL_INCLUDE)
-MSH3_LIB_DIR     = $(DEVEL_LIB)
-!ENDIF
-
-!IF "$(WITH_MSH3)"=="dll"
-MSH3_CFLAGS      = /DUSE_MSH3 /I"$(MSH3_INC_DIR)"
-MSH3_LIBS        = msh3.lib
-!ELSEIF "$(WITH_MSH3)"=="static"
-MSH3_CFLAGS      = /DUSE_MSH3 /DMSH3_STATICLIB /I"$(MSH3_INC_DIR)"
-!IF EXISTS("$(NGHTTP2_LIB_DIR)\msh3_static.lib")
-MSH3_LIBS        = msh3_static.lib
-!ELSE
-MSH3_LIBS        = msh3.lib
-!ENDIF
-!ENDIF
-
-!IFDEF MBEDTLS_PATH
-MBEDTLS_INC_DIR  = $(MBEDTLS_PATH)\include
-MBEDTLS_LIB_DIR  = $(MBEDTLS_PATH)\lib
-MBEDTLS_LFLAGS   = $(MBEDTLS_LFLAGS) "/LIBPATH:$(MBEDTLS_LIB_DIR)"
-!ELSE
-MBEDTLS_INC_DIR  = $(DEVEL_INCLUDE)
-MBEDTLS_LIB_DIR  = $(DEVEL_LIB)
-!ENDIF
-
-!IF "$(WITH_MBEDTLS)"=="dll" || "$(WITH_MBEDTLS)"=="static"
-USE_MBEDTLS    = true
-MBEDTLS        = $(WITH_MBEDTLS)
-MBEDTLS_CFLAGS = /DUSE_MBEDTLS /I"$(MBEDTLS_INC_DIR)"
-MBEDTLS_LIBS   = mbedtls.lib mbedcrypto.lib mbedx509.lib
-!ENDIF
-
-
-!IFDEF CARES_PATH
-CARES_INC_DIR  = $(CARES_PATH)\include
-CARES_LIB_DIR  = $(CARES_PATH)\lib
-CARES_LFLAGS   = $(CARES_LFLAGS) "/LIBPATH:$(CARES_LIB_DIR)"
-!ELSE
-CARES_INC_DIR  = $(DEVEL_INCLUDE)/cares
-CARES_LIB_DIR  = $(DEVEL_LIB)
-!ENDIF
-
-!IF "$(WITH_CARES)"=="dll"
-!IF "$(DEBUG)"=="yes"
-CARES_LIBS     = caresd.lib
-!ELSE
-CARES_LIBS     = cares.lib
-!ENDIF
-USE_CARES      = true
-CARES          = dll
-!ELSEIF "$(WITH_CARES)"=="static"
-!IF "$(DEBUG)"=="yes"
-CARES_LIBS     = libcaresd.lib
-!ELSE
-CARES_LIBS     = libcares.lib
-!ENDIF
-USE_CARES      = true
-CARES          = static
-!ENDIF
-
-!IFDEF USE_CARES
-CARES_CFLAGS   = /DUSE_ARES /I"$(CARES_INC_DIR)"
-!IF "$(CARES)"=="static"
-CARES_CFLAGS   = $(CARES_CFLAGS) /DCARES_STATICLIB
-!ENDIF
-!ENDIF
-
-
-!IFDEF ZLIB_PATH
-ZLIB_INC_DIR = $(ZLIB_PATH)\include
-ZLIB_LIB_DIR = $(ZLIB_PATH)\lib
-ZLIB_LFLAGS  = $(ZLIB_LFLAGS) "/LIBPATH:$(ZLIB_LIB_DIR)"
-!ELSE
-ZLIB_INC_DIR = $(DEVEL_INCLUDE)
-ZLIB_LIB_DIR = $(DEVEL_LIB)
-!ENDIF
-
-# Depending on how zlib is built the libraries have different names, we
-# try to handle them all.
-!IF "$(WITH_ZLIB)"=="dll"
-!IF EXISTS("$(ZLIB_LIB_DIR)\zlibwapi.lib")
-ZLIB_LIBS = zlibwapi.lib
-ADDITIONAL_ZLIB_CFLAGS = /DZLIB_WINAPI
-!ELSEIF EXISTS("$(ZLIB_LIB_DIR)\zdll.lib")
-ZLIB_LIBS   = zdll.lib
-!ELSE
-ZLIB_LIBS   = zlib.lib
-!ENDIF
-USE_ZLIB    = true
-ZLIB        = dll
-!ELSEIF "$(WITH_ZLIB)"=="static"
-!IF EXISTS("$(ZLIB_LIB_DIR)\zlibstat.lib")
-ZLIB_LIBS   = zlibstat.lib
-ADDITIONAL_ZLIB_CFLAGS = /DZLIB_WINAPI
-!ELSEIF EXISTS("$(ZLIB_LIB_DIR)\zlibstatic.lib")
-ZLIB_LIBS   = zlibstatic.lib
-!ELSEIF EXISTS("$(ZLIB_LIB_DIR)\zlib.lib")
-ZLIB_LIBS   = zlib.lib
-!ELSE
-ZLIB_LIBS   = zlib_a.lib
-!ENDIF
-USE_ZLIB    = true
-ZLIB        = static
-!ENDIF
-
-!IFDEF USE_ZLIB
-ZLIB_CFLAGS = /DHAVE_LIBZ $(ADDITIONAL_ZLIB_CFLAGS) /I"$(ZLIB_INC_DIR)"
-!ENDIF
-
-
-!IFDEF SSH2_PATH
-SSH2_INC_DIR= $(SSH2_PATH)\include
-SSH2_LIB_DIR= $(SSH2_PATH)\lib
-SSH2_LFLAGS = $(SSH2_LFLAGS) "/LIBPATH:$(SSH2_LIB_DIR)"
-!ELSE
-SSH2_LIB_DIR= $(DEVEL_LIB)
-SSH2_INC_DIR= $(DEVEL_INCLUDE)/libssh2
-!ENDIF
-
-!IF "$(WITH_SSH2)"=="dll"
-SSH2_LIBS   = libssh2.lib
-USE_SSH2    = true
-SSH2        = dll
-!ELSEIF "$(WITH_SSH2)"=="static"
-# libssh2 NMakefile on Windows at default creates a static library without _a suffix
-!IF EXISTS("$(SSH2_LIB_DIR)\libssh2.lib")
-SSH2_LIBS   = libssh2.lib
-!ELSE
-SSH2_LIBS   = libssh2_a.lib
-!ENDIF
-WIN_LIBS     = $(WIN_LIBS) user32.lib
-USE_SSH2    = true
-SSH2        = static
-!ENDIF
-
-!IFDEF USE_SSH2
-SSH2_CFLAGS = /DUSE_LIBSSH2
-SSH2_CFLAGS = $(SSH2_CFLAGS) /I"$(SSH2_INC_DIR)"
-!ENDIF
-
-
-!IFDEF SSH_PATH
-SSH_INC_DIR= $(SSH_PATH)\include
-SSH_LIB_DIR= $(SSH_PATH)\lib
-SSH_LFLAGS = $(SSH_LFLAGS) "/LIBPATH:$(SSH_LIB_DIR)"
-!ELSE
-SSH_LIB_DIR= $(DEVEL_LIB)
-SSH_INC_DIR= $(DEVEL_INCLUDE)
-!ENDIF
-
-!IF "$(WITH_SSH)"=="dll" || "$(WITH_SSH)"=="static"
-SSH_LIBS   = ssh.lib
-USE_SSH    = true
-SSH        = $(WITH_SSH)
-!ENDIF
-
-!IFDEF USE_SSH
-SSH_CFLAGS = /DUSE_LIBSSH
-SSH_CFLAGS = $(SSH_CFLAGS) /I"$(SSH_INC_DIR)"
-!ENDIF
-
-
-!IFNDEF USE_IDN
-USE_IDN   = true
-!ELSEIF "$(USE_IDN)"=="yes"
-USE_IDN   = true
-!ENDIF
-
-!IF "$(USE_IDN)"=="true"
-IDN_CFLAGS = $(IDN_CFLAGS) /DUSE_WIN32_IDN
-WIN_LIBS   = $(WIN_LIBS) Normaliz.lib
-!ENDIF
-
-
-!IFNDEF USE_IPV6
-USE_IPV6  = true
-!ELSEIF "$(USE_IPV6)"=="yes"
-USE_IPV6  = true
-!ENDIF
-
-!IF "$(USE_IPV6)"=="true"
-IPV6_CFLAGS = $(IPV6_CFLAGS) /DUSE_IPV6
-!ENDIF
-
-
-!IFNDEF USE_SSPI
-USE_SSPI  = true
-!ELSEIF "$(USE_SSPI)"=="yes"
-USE_SSPI  = true
-!ENDIF
-
-!IF "$(USE_SSPI)"=="true"
-SSPI_CFLAGS = $(SSPI_CFLAGS) /DUSE_WINDOWS_SSPI
-!ENDIF
-
-
-!IFNDEF USE_SCHANNEL
-!IF "$(USE_SSL)"=="true"
-USE_SCHANNEL  = false
-!ELSE
-USE_SCHANNEL  = $(USE_SSPI)
-!ENDIF
-!ELSEIF "$(USE_SCHANNEL)"=="yes"
-USE_SCHANNEL  = true
-!ENDIF
-
-
-!IF "$(USE_SCHANNEL)"=="true"
-!IF "$(USE_SSPI)"!="true"
-!ERROR cannot build with Schannel without SSPI
-!ENDIF
-SSPI_CFLAGS = $(SSPI_CFLAGS) /DUSE_SCHANNEL
-WIN_LIBS    = $(WIN_LIBS) Crypt32.lib
-!ENDIF
-
-
-!IF "$(GEN_PDB)"=="yes"
-GEN_PDB = true
-!ENDIF
-
-
-!IFDEF EMBED_MANIFEST
-MANIFESTTOOL = $(MT) -manifest $(DIRDIST)\bin\$(PROGRAM_NAME).manifest -outputresource:$(DIRDIST)\bin\$(PROGRAM_NAME);1
-!ELSE
-CURL_RC_FLAGS = $(CURL_RC_FLAGS) /dCURL_EMBED_MANIFEST
-!ENDIF
-
-# Runtime library configuration
-!IF "$(RTLIBCFG)"=="static"
-RTLIB = /MT
-RTLIB_DEBUG = /MTd
-!ELSE
-RTLIB = /MD
-RTLIB_DEBUG  = /MDd
-!ENDIF
-
-!IF "$(MODE)"=="static"
-TARGET = $(LIB_NAME_STATIC)
-CURL_LIBCURL_LIBNAME=$(LIB_NAME_STATIC)
-AS_DLL = false
-CFGSET = true
-!ELSEIF "$(MODE)"=="dll"
-TARGET = $(LIB_NAME_DLL)
-CURL_LIBCURL_LIBNAME=$(LIB_NAME_IMP)
-AS_DLL = true
-CFGSET = true
-!ENDIF
-
-!IF "$(CFGSET)" == "FALSE"
-!ERROR please choose a valid mode
-!ENDIF
-
-
-
-# CURL_XX macros are for the curl.exe command
-
-!IF "$(DEBUG)"=="yes"
-RC_FLAGS = /dDEBUGBUILD=1 /Fo $@ $(LIBCURL_SRC_DIR)\libcurl.rc
-CURL_CC       = $(CC_DEBUG) $(RTLIB_DEBUG)
-CURL_RC_FLAGS = $(CURL_RC_FLAGS) /i../include /dDEBUGBUILD=1 /Fo $@ $(CURL_SRC_DIR)\curl.rc
-!ELSE
-RC_FLAGS = /dDEBUGBUILD=0 /Fo $@ $(LIBCURL_SRC_DIR)\libcurl.rc
-CURL_CC       = $(CC_NODEBUG) $(RTLIB)
-CURL_RC_FLAGS = $(CURL_RC_FLAGS) /i../include /dDEBUGBUILD=0 /Fo $@ $(CURL_SRC_DIR)\curl.rc
-!ENDIF
-
-!IF "$(AS_DLL)" == "true"
-
-LNK       = $(LNKDLL) $(LFLAGS) $(WIN_LIBS) /out:$(LIB_DIROBJ)\$(TARGET)
-!IF "$(DEBUG)"=="yes"
-TARGET    = $(LIB_NAME_DLL_DEBUG)
-LNK       = $(LNK) /DEBUG /IMPLIB:$(LIB_DIROBJ)\$(LIB_NAME_IMP_DEBUG)
-PDB       = $(PDB_NAME_DLL_DEBUG)
-CURL_LIBS = /IMPLIB:$(LIB_DIROBJ)\$(LIB_NAME_IMP_DEBUG)
-!ELSE
-TARGET    = $(LIB_NAME_DLL)
-LNK       = $(LNK)  /IMPLIB:$(LIB_DIROBJ)\$(LIB_NAME_IMP)
-PDB       = $(PDB_NAME_DLL)
-CURL_LIBS = /IMPLIB:$(LIB_DIROBJ)\$(LIB_NAME_IMP)
-!ENDIF
-RESOURCE  = $(LIB_DIROBJ)\libcurl.res
-
-# AS_DLL
-!ELSE
-
-!IF "$(DEBUG)"=="yes"
-TARGET   = $(LIB_NAME_STATIC_DEBUG)
-PDB      = $(PDB_NAME_STATIC_DEBUG)
-!ELSE
-TARGET   = $(LIB_NAME_STATIC)
-PDB      = $(PDB_NAME_STATIC)
-!ENDIF
-LNK      = $(LNKLIB) /out:$(LIB_DIROBJ)\$(TARGET)
-CURL_CC  = $(CURL_CC) $(CFLAGS_LIBCURL_STATIC)
-
-# AS_DLL
-!ENDIF
-
-!IF "$(USE_SSL)"=="true"
-CFLAGS = $(CFLAGS) $(SSL_CFLAGS)
-LFLAGS = $(LFLAGS) $(SSL_LFLAGS) $(SSL_LIBS)
-!ENDIF
-
-!IF "$(USE_MBEDTLS)"=="true"
-CFLAGS = $(CFLAGS) $(MBEDTLS_CFLAGS)
-LFLAGS = $(LFLAGS) $(MBEDTLS_LFLAGS) $(MBEDTLS_LIBS)
-!ENDIF
-
-!IF "$(USE_CARES)"=="true"
-CFLAGS = $(CFLAGS) $(CARES_CFLAGS)
-LFLAGS = $(LFLAGS) $(CARES_LFLAGS) $(CARES_LIBS)
-!ENDIF
-
-!IF "$(USE_ZLIB)"=="true"
-CFLAGS = $(CFLAGS) $(ZLIB_CFLAGS)
-LFLAGS = $(LFLAGS) $(ZLIB_LFLAGS) $(ZLIB_LIBS)
-!ENDIF
-
-!IF "$(USE_SSH2)"=="true"
-CFLAGS = $(CFLAGS) $(SSH2_CFLAGS)
-LFLAGS = $(LFLAGS) $(SSH2_LFLAGS) $(SSH2_LIBS)
-!ENDIF
-
-!IF "$(USE_SSH)"=="true"
-CFLAGS = $(CFLAGS) $(SSH_CFLAGS)
-LFLAGS = $(LFLAGS) $(SSH_LFLAGS) $(SSH_LIBS)
-!ENDIF
-
-!IF "$(USE_IDN)"=="true"
-CFLAGS = $(CFLAGS) $(IDN_CFLAGS)
-!ENDIF
-
-!IF "$(USE_IPV6)"=="true"
-CFLAGS = $(CFLAGS) $(IPV6_CFLAGS)
-!ENDIF
-
-!IF "$(USE_SSPI)"=="true"
-CFLAGS = $(CFLAGS) $(SSPI_CFLAGS)
-!ENDIF
-
-!IF "$(USE_NGHTTP2)"=="true"
-CFLAGS = $(CFLAGS) $(NGHTTP2_CFLAGS)
-LFLAGS = $(LFLAGS) $(NGHTTP2_LFLAGS) $(NGHTTP2_LIBS)
-!ENDIF
-
-!IF "$(USE_MSH3)"=="true"
-CFLAGS = $(CFLAGS) $(MSH3_CFLAGS)
-LFLAGS = $(LFLAGS) $(MSH3_LFLAGS) $(MSH3_LIBS)
-!ENDIF
-
-!IF "$(GEN_PDB)"=="true"
-CFLAGS = $(CFLAGS) $(CFLAGS_PDB) /Fd"$(LIB_DIROBJ)\$(PDB)"
-LFLAGS = $(LFLAGS) $(LFLAGS_PDB)
-!ENDIF
-
-!IF ( "$(USE_SSL)"=="true" && "$(USE_SCHANNEL)"=="true" ) \
- || ( "$(USE_SSL)"=="true" && "$(USE_MBEDTLS)"=="true" ) \
- || ( "$(USE_MBEDTLS)"=="true" && "$(USE_SCHANNEL)"=="true" )
-CFLAGS = $(CFLAGS) /DCURL_WITH_MULTI_SSL
-!ENDIF
-
-!IF "$(USE_UNICODE)"=="true"
-CFLAGS = $(CFLAGS) /DUNICODE /D_UNICODE
-!ENDIF
-
-LIB_DIROBJ = ..\builds\$(CONFIG_NAME_LIB)-obj-lib
-CURL_DIROBJ = ..\builds\$(CONFIG_NAME_LIB)-obj-curl
-
-!IFDEF WITH_PREFIX
-DIRDIST = $(WITH_PREFIX)
-!ELSE
-DIRDIST = ..\builds\$(CONFIG_NAME_LIB)\
-!ENDIF
-
-#
-# curl.exe
-#
-CURL_LINK = link.exe /incremental:no /libpath:"$(DIRDIST)\lib"
-
-!IF "$(CFGSET)" != "FALSE"
-# A mode was provided, so the library can be built.
-#
-!include CURL_OBJS.inc
-!include LIBCURL_OBJS.inc
-
-!IF "$(AS_DLL)" == "true"
-LIB_OBJS = $(LIBCURL_OBJS) $(RESOURCE)
-!ELSE
-LIB_OBJS = $(LIBCURL_OBJS)
-!ENDIF
-
-EXE_OBJS = $(CURL_OBJS) $(CURL_DIROBJ)\curl.res
-
-all : $(TARGET) $(PROGRAM_NAME)
-
-package: $(TARGET)
-	@cd $(DIRDIST)
-	@-$(ZIP) -9 -q -r ..\$(CONFIG_NAME_LIB).zip .>nul 2<&1
-	@cd $(MAKEDIR)
-
-$(TARGET): $(LIB_OBJS) $(LIB_DIROBJ) $(DIRDIST)
-	@echo Using SSL: $(USE_SSL)
-	@echo Using NGHTTP2: $(USE_NGHTTP2)
-	@echo Using MSH3: $(USE_MSH3)
-	@echo Using c-ares: $(USE_CARES)
-	@echo Using SSH2: $(USE_SSH2)
-	@echo Using SSH: $(USE_SSH)
-	@echo Using ZLIB: $(USE_ZLIB)
-	@echo Using IDN:  $(USE_IDN)
-	@echo Using IPv6: $(USE_IPV6)
-	@echo Using SSPI: $(USE_SSPI)
-	@echo Using Schannel: $(USE_SCHANNEL)
-	@echo CFLAGS:     $(CFLAGS)
-	@echo LFLAGS:     $(LFLAGS)
-	@echo GenPDB:     $(GEN_PDB)
-	@echo Debug:      $(DEBUG)
-	@echo Machine:    $(MACHINE)
-	$(LNK) $(LIB_OBJS)
-	@echo Copying libs...
-	@if exist $(LIB_DIROBJ)\$(LIB_NAME_DLL) copy $(LIB_DIROBJ)\$(LIB_NAME_DLL)       $(DIRDIST)\bin\ /y >nul 2<&1
-	@if exist $(LIB_DIROBJ)\$(LIB_NAME_STATIC) copy $(LIB_DIROBJ)\$(LIB_NAME_STATIC)    $(DIRDIST)\lib\ /y >nul 2<&1
-	@if exist $(LIB_DIROBJ)\$(LIB_NAME_DLL_DEBUG) copy $(LIB_DIROBJ)\$(LIB_NAME_DLL_DEBUG) $(DIRDIST)\bin\ /y >nul 2<&1
-	@if exist $(LIB_DIROBJ)\$(LIB_NAME_STATIC_DEBUG) copy $(LIB_DIROBJ)\$(LIB_NAME_STATIC_DEBUG) $(DIRDIST)\lib\ /y >nul 2<&1
-	@if exist $(LIB_DIROBJ)\$(LIB_NAME_IMP) copy $(LIB_DIROBJ)\$(LIB_NAME_IMP)       $(DIRDIST)\lib\ /y >nul 2<&1
-	@if exist $(LIB_DIROBJ)\$(LIB_NAME_IMP_DEBUG) copy $(LIB_DIROBJ)\$(LIB_NAME_IMP_DEBUG) $(DIRDIST)\lib >nul 2<&1
-	@-copy $(LIB_DIROBJ)\*.exp                 $(DIRDIST)\lib /y >nul 2<&1
-	@-copy $(LIB_DIROBJ)\*.pdb                 $(DIRDIST)\lib /y >nul 2<&1
-	@-copy ..\include\curl\*.h   $(DIRDIST)\include\curl\ /y  >nul 2<&1
-
-$(LIB_OBJS): $(LIB_DIROBJ) $(DIRDIST)
-
-$(DIRDIST):
-	@if not exist "$(DIRDIST)\bin" mkdir $(DIRDIST)\bin
-	@if not exist "$(DIRDIST)\include" mkdir $(DIRDIST)\include
-	@if not exist "$(DIRDIST)\include\curl" mkdir $(DIRDIST)\include\curl
-	@if not exist "$(DIRDIST)\lib" mkdir $(DIRDIST)\lib
-
-$(LIB_DIROBJ):
-	@if not exist "$(LIB_DIROBJ)" mkdir $(LIB_DIROBJ)
-	@if not exist "$(LIB_DIROBJ)\vauth" mkdir $(LIB_DIROBJ)\vauth
-	@if not exist "$(LIB_DIROBJ)\vtls" mkdir $(LIB_DIROBJ)\vtls
-	@if not exist "$(LIB_DIROBJ)\vssh" mkdir $(LIB_DIROBJ)\vssh
-	@if not exist "$(LIB_DIROBJ)\vquic" mkdir $(LIB_DIROBJ)\vquic
-
-$(CURL_DIROBJ):
-	@if not exist "$(CURL_DIROBJ)" mkdir $(CURL_DIROBJ)
-# we need a lib dir for the portability functions from libcurl
-# we use the .c directly here
-	@if not exist "$(CURL_DIROBJ)" mkdir $(CURL_DIROBJ)\lib
-
-.SUFFIXES: .c .obj .res
-
-{$(LIBCURL_SRC_DIR)\}.c{$(LIB_DIROBJ)\}.obj::
-	$(CURL_CC) $(CFLAGS) /Fo"$(LIB_DIROBJ)\\"  $<
-
-{$(LIBCURL_SRC_DIR)\vauth\}.c{$(LIB_DIROBJ)\vauth\}.obj::
-	$(CURL_CC) $(CFLAGS) /Fo"$(LIB_DIROBJ)\vauth\\"  $<
-
-{$(LIBCURL_SRC_DIR)\vtls\}.c{$(LIB_DIROBJ)\vtls\}.obj::
-	$(CURL_CC) $(CFLAGS) /Fo"$(LIB_DIROBJ)\vtls\\"  $<
-
-{$(LIBCURL_SRC_DIR)\vssh\}.c{$(LIB_DIROBJ)\vssh\}.obj::
-	$(CURL_CC) $(CFLAGS) /Fo"$(LIB_DIROBJ)\vssh\\"  $<
-
-{$(LIBCURL_SRC_DIR)\vquic\}.c{$(LIB_DIROBJ)\vquic\}.obj::
-	$(CURL_CC) $(CFLAGS) /Fo"$(LIB_DIROBJ)\vquic\\"  $<
-
-$(LIB_DIROBJ)\libcurl.res: $(LIBCURL_SRC_DIR)\libcurl.rc
-	$(RC) $(RC_FLAGS)
-
-#
-# curl.exe
-#
-
-
-!IF "$(MODE)"=="static"
-!IF "$(DEBUG)"=="yes"
-CURL_LIBCURL_LIBNAME=$(LIB_NAME_STATIC_DEBUG)
-!ELSE
-CURL_LIBCURL_LIBNAME=$(LIB_NAME_STATIC)
-!ENDIF
-!ELSEIF "$(MODE)"=="dll"
-!IF "$(DEBUG)"=="yes"
-CURL_LIBCURL_LIBNAME=$(LIB_NAME_IMP_DEBUG)
-!ELSE
-CURL_LIBCURL_LIBNAME=$(LIB_NAME_IMP)
-!ENDIF
-!ENDIF
-
-CURL_FROM_LIBCURL=$(CURL_DIROBJ)\tool_hugehelp.obj \
- $(CURL_DIROBJ)\nonblock.obj \
- $(CURL_DIROBJ)\strtoofft.obj \
- $(CURL_DIROBJ)\warnless.obj \
- $(CURL_DIROBJ)\curl_multibyte.obj \
- $(CURL_DIROBJ)\version_win32.obj \
- $(CURL_DIROBJ)\dynbuf.obj \
- $(CURL_DIROBJ)\base64.obj
-
-$(PROGRAM_NAME): $(CURL_DIROBJ) $(CURL_FROM_LIBCURL) $(EXE_OBJS)
-	$(CURL_LINK) $(CURL_LFLAGS) $(CURL_LIBCURL_LIBNAME) $(WIN_LIBS) $(CURL_FROM_LIBCURL) $(EXE_OBJS)
-	$(MANIFESTTOOL)
-
-{$(CURL_SRC_DIR)\}.c{$(CURL_DIROBJ)\}.obj::
-	$(CURL_CC) $(CURL_CFLAGS) /Fo"$(CURL_DIROBJ)\\"  $<
-
-$(CURL_DIROBJ)\tool_hugehelp.obj: $(CURL_SRC_DIR)\tool_hugehelp.c
-	$(CURL_CC) $(CURL_CFLAGS) /Zm200 /Fo"$@" $(CURL_SRC_DIR)\tool_hugehelp.c
-$(CURL_DIROBJ)\nonblock.obj: ../lib/nonblock.c
-	$(CURL_CC) $(CURL_CFLAGS) /Fo"$@" ../lib/nonblock.c
-$(CURL_DIROBJ)\strtoofft.obj: ../lib/strtoofft.c
-	$(CURL_CC) $(CURL_CFLAGS) /Fo"$@" ../lib/strtoofft.c
-$(CURL_DIROBJ)\warnless.obj: ../lib/warnless.c
-	$(CURL_CC) $(CURL_CFLAGS) /Fo"$@" ../lib/warnless.c
-$(CURL_DIROBJ)\curl_multibyte.obj: ../lib/curl_multibyte.c
-	$(CURL_CC) $(CURL_CFLAGS) /Fo"$@" ../lib/curl_multibyte.c
-$(CURL_DIROBJ)\version_win32.obj: ../lib/version_win32.c
-	$(CURL_CC) $(CURL_CFLAGS) /Fo"$@" ../lib/version_win32.c
-$(CURL_DIROBJ)\dynbuf.obj: ../lib/dynbuf.c
-	$(CURL_CC) $(CURL_CFLAGS) /Fo"$@" ../lib/dynbuf.c
-$(CURL_DIROBJ)\base64.obj: ../lib/base64.c
-	$(CURL_CC) $(CURL_CFLAGS) /Fo"$@" ../lib/base64.c
-$(CURL_DIROBJ)\curl.res: $(CURL_SRC_DIR)\curl.rc
-	$(RC) $(CURL_RC_FLAGS)
-
-!ENDIF  # End of case where a config was provided.
-
-# Makefile.vc's clean removes (LIB)CURL_DIROBJ and DIRDIST dirs then calls
-# this clean. Note those are the original directories we control and not the
-# directories possibly modified by this makefile to point to user-specified
-# directories.
-# For example, don't remove DIRDIST here since it may contain user files if it
-# has been changed by WITH_PREFIX to a different output dir (eg C:\usr\local).
-clean:
-	@-erase /s *.dll 2> NUL
-	@-erase /s *.exp 2> NUL
-	@-erase /s *.idb 2> NUL
-	@-erase /s *.lib 2> NUL
-	@-erase /s *.obj 2> NUL
-	@-erase /s *.pch 2> NUL
-	@-erase /s *.pdb 2> NUL
-	@-erase /s *.res 2> NUL
+#***************************************************************************
+#                                  _   _ ____  _
+#  Project                     ___| | | |  _ \| |
+#                             / __| | | | |_) | |
+#                            | (__| |_| |  _ <| |___
+#                             \___|\___/|_| \_\_____|
+#
+# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
+#
+# This software is licensed as described in the file COPYING, which
+# you should have received as part of this distribution. The terms
+# are also available at https://curl.se/docs/copyright.html.
+#
+# You may opt to use, copy, modify, merge, publish, distribute and/or sell
+# copies of the Software, and permit persons to whom the Software is
+# furnished to do so, under the terms of the COPYING file.
+#
+# This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+# KIND, either express or implied.
+#
+# SPDX-License-Identifier: curl
+#
+#***************************************************************************
+
+###########################################################################
+#
+# Makefile for building libcurl with MSVC
+#
+# Usage: see README.md
+#
+##############################################################
+
+CFGSET=FALSE
+WINBUILD_DIR=`cd`
+
+# Utilities.
+# If a path is required that contains characters such as space, quote the path.
+MT         = mt.exe
+RC         = rc.exe
+ZIP        = zip.exe
+
+# Allow changing C compiler via environment variable CC (default cl.exe)
+# This command macro is not set by default: https://msdn.microsoft.com/en-us/library/ms933742.aspx
+!If "$(CC)" == ""
+CC = cl.exe
+!Endif
+
+!IF "$(VC)"=="6"
+CC_NODEBUG  = $(CC) /O2 /DNDEBUG
+CC_DEBUG    = $(CC) /Od /Gm /Zi /D_DEBUG /GZ
+CFLAGS      = /I. /I../lib /I../include /nologo /W4 /GX /YX /FD /c /DBUILDING_LIBCURL
+!ELSE
+CC_NODEBUG  = $(CC) /O2 /DNDEBUG
+CC_DEBUG    = $(CC) /Od /D_DEBUG /RTC1 /Z7 /LDd
+CFLAGS      = /I. /I ../lib /I../include /nologo /W4 /EHsc /FD /c /DBUILDING_LIBCURL
+!ENDIF
+
+LFLAGS     = /nologo /machine:$(MACHINE)
+LNKDLL     = link.exe /DLL
+# Use lib.exe instead of link.exe as link.exe /lib has the following bad habits:
+# - optimizing options like /opt:ref raises warnings (at least in Visual Studio 2015)
+# - all (including Windows) dependencies are aggregated (as static parts)
+# - link.exe /lib is not documented (anymore) at MSDN
+# Instead of id: just create an archive, that contains all objects
+LNKLIB     = lib.exe
+
+CFLAGS_PDB = /Zi
+LFLAGS_PDB = /incremental:no /opt:ref,icf /DEBUG
+
+CFLAGS_LIBCURL_STATIC  = /DCURL_STATICLIB
+
+WIN_LIBS    = ws2_32.lib wldap32.lib advapi32.lib crypt32.lib
+
+BASE_NAME              = libcurl
+BASE_NAME_DEBUG        = $(BASE_NAME)_debug
+BASE_NAME_STATIC       = $(BASE_NAME)_a
+BASE_NAME_STATIC_DEBUG = $(BASE_NAME_STATIC)_debug
+
+LIB_NAME_STATIC        = $(BASE_NAME_STATIC).lib
+LIB_NAME_STATIC_DEBUG  = $(BASE_NAME_STATIC_DEBUG).lib
+LIB_NAME_DLL           = $(BASE_NAME).dll
+LIB_NAME_IMP           = $(BASE_NAME).lib
+LIB_NAME_DLL_DEBUG     = $(BASE_NAME_DEBUG).dll
+LIB_NAME_IMP_DEBUG     = $(BASE_NAME_DEBUG).lib
+
+PDB_NAME_STATIC        = $(BASE_NAME_STATIC).pdb
+PDB_NAME_STATIC_DEBUG  = $(BASE_NAME_STATIC_DEBUG).pdb
+PDB_NAME_DLL           = $(BASE_NAME).pdb
+PDB_NAME_DLL_DEBUG     = $(BASE_NAME_DEBUG).pdb
+
+# CURL Command section
+PROGRAM_NAME  = curl.exe
+CURL_CFLAGS   = /I../lib /I../include /nologo /W4 /EHsc /FD /c
+CURL_LFLAGS   = /out:$(DIRDIST)\bin\$(PROGRAM_NAME) /subsystem:console $(LFLAGS)
+CURL_RESFLAGS = /i../include
+
+#############################################################
+## Nothing more to do below this line!
+LIBCURL_SRC_DIR = ..\lib
+CURL_SRC_DIR = ..\src
+
+!IFNDEF WITH_DEVEL
+WITH_DEVEL   = ../../deps
+!ENDIF
+DEVEL_INCLUDE= $(WITH_DEVEL)/include
+DEVEL_LIB    = $(WITH_DEVEL)/lib
+
+!IF EXISTS("$(DEVEL_INCLUDE)")
+CFLAGS       = $(CFLAGS) /I"$(DEVEL_INCLUDE)"
+!ENDIF
+!IF EXISTS("$(DEVEL_LIB)")
+LFLAGS       = $(LFLAGS) "/LIBPATH:$(DEVEL_LIB)"
+!ENDIF
+
+!IFDEF SSL_PATH
+SSL_INC_DIR  = $(SSL_PATH)\include
+SSL_LIB_DIR  = $(SSL_PATH)\lib
+SSL_LFLAGS   = $(SSL_LFLAGS) "/LIBPATH:$(SSL_LIB_DIR)"
+!ELSE
+SSL_INC_DIR=$(DEVEL_INCLUDE)\openssl
+SSL_LIB_DIR=$(DEVEL_LIB)
+!ENDIF
+
+!IF "$(WITH_SSL)"=="dll" || "$(WITH_SSL)"=="static"
+!IF EXISTS("$(SSL_LIB_DIR)\libssl.lib")
+SSL_LIBS     = libssl.lib libcrypto.lib
+!ELSE
+SSL_LIBS     = libeay32.lib ssleay32.lib
+!ENDIF
+USE_SSL      = true
+SSL          = $(WITH_SSL)
+!IF "$(WITH_SSL)"=="static"
+WIN_LIBS     = $(WIN_LIBS) gdi32.lib user32.lib crypt32.lib
+!ENDIF
+!ENDIF
+
+!IFDEF USE_SSL
+SSL_CFLAGS   = /DUSE_OPENSSL /I"$(SSL_INC_DIR)"
+!IF "$(ENABLE_OPENSSL_AUTO_LOAD_CONFIG)"=="false"
+SSL_CFLAGS   = $(SSL_CFLAGS) /DCURL_DISABLE_OPENSSL_AUTO_LOAD_CONFIG
+!ENDIF
+!ENDIF
+
+!IF "$(ENABLE_WEBSOCKETS)"=="true"
+CFLAGS  = $(CFLAGS) /DUSE_WEBSOCKETS=1
+!ENDIF
+
+!IFDEF NGHTTP2_PATH
+NGHTTP2_INC_DIR  = $(NGHTTP2_PATH)\include
+NGHTTP2_LIB_DIR  = $(NGHTTP2_PATH)\lib
+NGHTTP2_LFLAGS   = $(NGHTTP2_LFLAGS) "/LIBPATH:$(NGHTTP2_LIB_DIR)"
+!ELSE
+NGHTTP2_INC_DIR  = $(DEVEL_INCLUDE)
+NGHTTP2_LIB_DIR  = $(DEVEL_LIB)
+!ENDIF
+
+!IF "$(WITH_NGHTTP2)"=="dll"
+NGHTTP2_CFLAGS   = /DUSE_NGHTTP2 /I"$(NGHTTP2_INC_DIR)"
+NGHTTP2_LIBS     = nghttp2.lib
+!ELSEIF "$(WITH_NGHTTP2)"=="static"
+NGHTTP2_CFLAGS   = /DUSE_NGHTTP2 /DNGHTTP2_STATICLIB /I"$(NGHTTP2_INC_DIR)"
+!IF EXISTS("$(NGHTTP2_LIB_DIR)\nghttp2_static.lib")
+NGHTTP2_LIBS     = nghttp2_static.lib
+!ELSE
+NGHTTP2_LIBS     = nghttp2.lib
+!ENDIF
+!ENDIF
+
+!IFDEF MSH3_PATH
+MSH3_INC_DIR     = $(MSH3_PATH)\include
+MSH3_LIB_DIR     = $(MSH3_PATH)\lib
+MSH3_LFLAGS      = $(MSH3_LFLAGS) "/LIBPATH:$(MSH3_LIB_DIR)"
+!ELSE
+MSH3_INC_DIR     = $(DEVEL_INCLUDE)
+MSH3_LIB_DIR     = $(DEVEL_LIB)
+!ENDIF
+
+!IF "$(WITH_MSH3)"=="dll"
+MSH3_CFLAGS      = /DUSE_MSH3 /I"$(MSH3_INC_DIR)"
+MSH3_LIBS        = msh3.lib
+!ELSEIF "$(WITH_MSH3)"=="static"
+MSH3_CFLAGS      = /DUSE_MSH3 /DMSH3_STATICLIB /I"$(MSH3_INC_DIR)"
+!IF EXISTS("$(NGHTTP2_LIB_DIR)\msh3_static.lib")
+MSH3_LIBS        = msh3_static.lib
+!ELSE
+MSH3_LIBS        = msh3.lib
+!ENDIF
+!ENDIF
+
+!IFDEF MBEDTLS_PATH
+MBEDTLS_INC_DIR  = $(MBEDTLS_PATH)\include
+MBEDTLS_LIB_DIR  = $(MBEDTLS_PATH)\lib
+MBEDTLS_LFLAGS   = $(MBEDTLS_LFLAGS) "/LIBPATH:$(MBEDTLS_LIB_DIR)"
+!ELSE
+MBEDTLS_INC_DIR  = $(DEVEL_INCLUDE)
+MBEDTLS_LIB_DIR  = $(DEVEL_LIB)
+!ENDIF
+
+!IF "$(WITH_MBEDTLS)"=="dll" || "$(WITH_MBEDTLS)"=="static"
+USE_MBEDTLS    = true
+MBEDTLS        = $(WITH_MBEDTLS)
+MBEDTLS_CFLAGS = /DUSE_MBEDTLS /I"$(MBEDTLS_INC_DIR)"
+MBEDTLS_LIBS   = mbedtls.lib mbedcrypto.lib mbedx509.lib
+!ENDIF
+
+
+!IFDEF CARES_PATH
+CARES_INC_DIR  = $(CARES_PATH)\include
+CARES_LIB_DIR  = $(CARES_PATH)\lib
+CARES_LFLAGS   = $(CARES_LFLAGS) "/LIBPATH:$(CARES_LIB_DIR)"
+!ELSE
+CARES_INC_DIR  = $(DEVEL_INCLUDE)/cares
+CARES_LIB_DIR  = $(DEVEL_LIB)
+!ENDIF
+
+!IF "$(WITH_CARES)"=="dll"
+!IF "$(DEBUG)"=="yes"
+CARES_LIBS     = caresd.lib
+!ELSE
+CARES_LIBS     = cares.lib
+!ENDIF
+USE_CARES      = true
+CARES          = dll
+!ELSEIF "$(WITH_CARES)"=="static"
+!IF "$(DEBUG)"=="yes"
+CARES_LIBS     = libcaresd.lib
+!ELSE
+CARES_LIBS     = libcares.lib
+!ENDIF
+USE_CARES      = true
+CARES          = static
+!ENDIF
+
+!IFDEF USE_CARES
+CARES_CFLAGS   = /DUSE_ARES /I"$(CARES_INC_DIR)"
+!IF "$(CARES)"=="static"
+CARES_CFLAGS   = $(CARES_CFLAGS) /DCARES_STATICLIB
+!ENDIF
+!ENDIF
+
+
+!IFDEF ZLIB_PATH
+ZLIB_INC_DIR = $(ZLIB_PATH)\include
+ZLIB_LIB_DIR = $(ZLIB_PATH)\lib
+ZLIB_LFLAGS  = $(ZLIB_LFLAGS) "/LIBPATH:$(ZLIB_LIB_DIR)"
+!ELSE
+ZLIB_INC_DIR = $(DEVEL_INCLUDE)
+ZLIB_LIB_DIR = $(DEVEL_LIB)
+!ENDIF
+
+# Depending on how zlib is built the libraries have different names, we
+# try to handle them all.
+!IF "$(WITH_ZLIB)"=="dll"
+!IF EXISTS("$(ZLIB_LIB_DIR)\zlibwapi.lib")
+ZLIB_LIBS = zlibwapi.lib
+ADDITIONAL_ZLIB_CFLAGS = /DZLIB_WINAPI
+!ELSEIF EXISTS("$(ZLIB_LIB_DIR)\zdll.lib")
+ZLIB_LIBS   = zdll.lib
+!ELSE
+ZLIB_LIBS   = zlib.lib
+!ENDIF
+USE_ZLIB    = true
+ZLIB        = dll
+!ELSEIF "$(WITH_ZLIB)"=="static"
+!IF EXISTS("$(ZLIB_LIB_DIR)\zlibstat.lib")
+ZLIB_LIBS   = zlibstat.lib
+ADDITIONAL_ZLIB_CFLAGS = /DZLIB_WINAPI
+!ELSEIF EXISTS("$(ZLIB_LIB_DIR)\zlibstatic.lib")
+ZLIB_LIBS   = zlibstatic.lib
+!ELSEIF EXISTS("$(ZLIB_LIB_DIR)\zlib.lib")
+ZLIB_LIBS   = zlib.lib
+!ELSE
+ZLIB_LIBS   = zlib_a.lib
+!ENDIF
+USE_ZLIB    = true
+ZLIB        = static
+!ENDIF
+
+!IFDEF USE_ZLIB
+ZLIB_CFLAGS = /DHAVE_LIBZ $(ADDITIONAL_ZLIB_CFLAGS) /I"$(ZLIB_INC_DIR)"
+!ENDIF
+
+
+!IFDEF SSH2_PATH
+SSH2_INC_DIR= $(SSH2_PATH)\include
+SSH2_LIB_DIR= $(SSH2_PATH)\lib
+SSH2_LFLAGS = $(SSH2_LFLAGS) "/LIBPATH:$(SSH2_LIB_DIR)"
+!ELSE
+SSH2_LIB_DIR= $(DEVEL_LIB)
+SSH2_INC_DIR= $(DEVEL_INCLUDE)/libssh2
+!ENDIF
+
+!IF "$(WITH_SSH2)"=="dll"
+SSH2_LIBS   = libssh2.lib
+USE_SSH2    = true
+SSH2        = dll
+!ELSEIF "$(WITH_SSH2)"=="static"
+# libssh2 NMakefile on Windows at default creates a static library without _a suffix
+!IF EXISTS("$(SSH2_LIB_DIR)\libssh2.lib")
+SSH2_LIBS   = libssh2.lib
+!ELSE
+SSH2_LIBS   = libssh2_a.lib
+!ENDIF
+WIN_LIBS     = $(WIN_LIBS) user32.lib
+USE_SSH2    = true
+SSH2        = static
+!ENDIF
+
+!IFDEF USE_SSH2
+SSH2_CFLAGS = /DUSE_LIBSSH2
+SSH2_CFLAGS = $(SSH2_CFLAGS) /I"$(SSH2_INC_DIR)"
+!ENDIF
+
+
+!IFDEF SSH_PATH
+SSH_INC_DIR= $(SSH_PATH)\include
+SSH_LIB_DIR= $(SSH_PATH)\lib
+SSH_LFLAGS = $(SSH_LFLAGS) "/LIBPATH:$(SSH_LIB_DIR)"
+!ELSE
+SSH_LIB_DIR= $(DEVEL_LIB)
+SSH_INC_DIR= $(DEVEL_INCLUDE)
+!ENDIF
+
+!IF "$(WITH_SSH)"=="dll" || "$(WITH_SSH)"=="static"
+SSH_LIBS   = ssh.lib
+USE_SSH    = true
+SSH        = $(WITH_SSH)
+!ENDIF
+
+!IFDEF USE_SSH
+SSH_CFLAGS = /DUSE_LIBSSH
+SSH_CFLAGS = $(SSH_CFLAGS) /I"$(SSH_INC_DIR)"
+!ENDIF
+
+
+!IFNDEF USE_IDN
+USE_IDN   = true
+!ELSEIF "$(USE_IDN)"=="yes"
+USE_IDN   = true
+!ENDIF
+
+!IF "$(USE_IDN)"=="true"
+IDN_CFLAGS = $(IDN_CFLAGS) /DUSE_WIN32_IDN
+WIN_LIBS   = $(WIN_LIBS) Normaliz.lib
+!ENDIF
+
+
+!IFNDEF USE_IPV6
+USE_IPV6  = true
+!ELSEIF "$(USE_IPV6)"=="yes"
+USE_IPV6  = true
+!ENDIF
+
+!IF "$(USE_IPV6)"=="true"
+IPV6_CFLAGS = $(IPV6_CFLAGS) /DUSE_IPV6
+!ENDIF
+
+
+!IFNDEF USE_SSPI
+USE_SSPI  = true
+!ELSEIF "$(USE_SSPI)"=="yes"
+USE_SSPI  = true
+!ENDIF
+
+!IF "$(USE_SSPI)"=="true"
+SSPI_CFLAGS = $(SSPI_CFLAGS) /DUSE_WINDOWS_SSPI
+!ENDIF
+
+
+!IFNDEF USE_SCHANNEL
+!IF "$(USE_SSL)"=="true"
+USE_SCHANNEL  = false
+!ELSE
+USE_SCHANNEL  = $(USE_SSPI)
+!ENDIF
+!ELSEIF "$(USE_SCHANNEL)"=="yes"
+USE_SCHANNEL  = true
+!ENDIF
+
+
+!IF "$(USE_SCHANNEL)"=="true"
+!IF "$(USE_SSPI)"!="true"
+!ERROR cannot build with Schannel without SSPI
+!ENDIF
+SSPI_CFLAGS = $(SSPI_CFLAGS) /DUSE_SCHANNEL
+WIN_LIBS    = $(WIN_LIBS) Crypt32.lib
+!ENDIF
+
+
+!IF "$(GEN_PDB)"=="yes"
+GEN_PDB = true
+!ENDIF
+
+
+!IFDEF EMBED_MANIFEST
+MANIFESTTOOL = $(MT) -manifest $(DIRDIST)\bin\$(PROGRAM_NAME).manifest -outputresource:$(DIRDIST)\bin\$(PROGRAM_NAME);1
+!ELSE
+CURL_RC_FLAGS = $(CURL_RC_FLAGS) /dCURL_EMBED_MANIFEST
+!ENDIF
+
+# Runtime library configuration
+!IF "$(RTLIBCFG)"=="static"
+RTLIB = /MT
+RTLIB_DEBUG = /MTd
+!ELSE
+RTLIB = /MD
+RTLIB_DEBUG  = /MDd
+!ENDIF
+
+!IF "$(MODE)"=="static"
+TARGET = $(LIB_NAME_STATIC)
+CURL_LIBCURL_LIBNAME=$(LIB_NAME_STATIC)
+AS_DLL = false
+CFGSET = true
+!ELSEIF "$(MODE)"=="dll"
+TARGET = $(LIB_NAME_DLL)
+CURL_LIBCURL_LIBNAME=$(LIB_NAME_IMP)
+AS_DLL = true
+CFGSET = true
+!ENDIF
+
+!IF "$(CFGSET)" == "FALSE"
+!ERROR please choose a valid mode
+!ENDIF
+
+
+
+# CURL_XX macros are for the curl.exe command
+
+!IF "$(DEBUG)"=="yes"
+RC_FLAGS = /d_DEBUG /Fo $@ $(LIBCURL_SRC_DIR)\libcurl.rc
+CURL_CC       = $(CC_DEBUG) $(RTLIB_DEBUG)
+CURL_RC_FLAGS = $(CURL_RC_FLAGS) /i../include /d_DEBUG /Fo $@ $(CURL_SRC_DIR)\curl.rc
+!ELSE
+RC_FLAGS = /Fo $@ $(LIBCURL_SRC_DIR)\libcurl.rc
+CURL_CC       = $(CC_NODEBUG) $(RTLIB)
+CURL_RC_FLAGS = $(CURL_RC_FLAGS) /i../include /Fo $@ $(CURL_SRC_DIR)\curl.rc
+!ENDIF
+
+!IF "$(AS_DLL)" == "true"
+
+LNK       = $(LNKDLL) $(LFLAGS) $(WIN_LIBS) /out:$(LIB_DIROBJ)\$(TARGET)
+!IF "$(DEBUG)"=="yes"
+TARGET    = $(LIB_NAME_DLL_DEBUG)
+LNK       = $(LNK) /DEBUG /IMPLIB:$(LIB_DIROBJ)\$(LIB_NAME_IMP_DEBUG)
+PDB       = $(PDB_NAME_DLL_DEBUG)
+CURL_LIBS = /IMPLIB:$(LIB_DIROBJ)\$(LIB_NAME_IMP_DEBUG)
+!ELSE
+TARGET    = $(LIB_NAME_DLL)
+LNK       = $(LNK)  /IMPLIB:$(LIB_DIROBJ)\$(LIB_NAME_IMP)
+PDB       = $(PDB_NAME_DLL)
+CURL_LIBS = /IMPLIB:$(LIB_DIROBJ)\$(LIB_NAME_IMP)
+!ENDIF
+RESOURCE  = $(LIB_DIROBJ)\libcurl.res
+
+# AS_DLL
+!ELSE
+
+!IF "$(DEBUG)"=="yes"
+TARGET   = $(LIB_NAME_STATIC_DEBUG)
+PDB      = $(PDB_NAME_STATIC_DEBUG)
+!ELSE
+TARGET   = $(LIB_NAME_STATIC)
+PDB      = $(PDB_NAME_STATIC)
+!ENDIF
+LNK      = $(LNKLIB) /out:$(LIB_DIROBJ)\$(TARGET)
+CURL_CC  = $(CURL_CC) $(CFLAGS_LIBCURL_STATIC)
+
+# AS_DLL
+!ENDIF
+
+!IF "$(USE_SSL)"=="true"
+CFLAGS = $(CFLAGS) $(SSL_CFLAGS)
+LFLAGS = $(LFLAGS) $(SSL_LFLAGS) $(SSL_LIBS)
+!ENDIF
+
+!IF "$(USE_MBEDTLS)"=="true"
+CFLAGS = $(CFLAGS) $(MBEDTLS_CFLAGS)
+LFLAGS = $(LFLAGS) $(MBEDTLS_LFLAGS) $(MBEDTLS_LIBS)
+!ENDIF
+
+!IF "$(USE_CARES)"=="true"
+CFLAGS = $(CFLAGS) $(CARES_CFLAGS)
+LFLAGS = $(LFLAGS) $(CARES_LFLAGS) $(CARES_LIBS)
+!ENDIF
+
+!IF "$(USE_ZLIB)"=="true"
+CFLAGS = $(CFLAGS) $(ZLIB_CFLAGS)
+LFLAGS = $(LFLAGS) $(ZLIB_LFLAGS) $(ZLIB_LIBS)
+!ENDIF
+
+!IF "$(USE_SSH2)"=="true"
+CFLAGS = $(CFLAGS) $(SSH2_CFLAGS)
+LFLAGS = $(LFLAGS) $(SSH2_LFLAGS) $(SSH2_LIBS)
+!ENDIF
+
+!IF "$(USE_SSH)"=="true"
+CFLAGS = $(CFLAGS) $(SSH_CFLAGS)
+LFLAGS = $(LFLAGS) $(SSH_LFLAGS) $(SSH_LIBS)
+!ENDIF
+
+!IF "$(USE_IDN)"=="true"
+CFLAGS = $(CFLAGS) $(IDN_CFLAGS)
+!ENDIF
+
+!IF "$(USE_IPV6)"=="true"
+CFLAGS = $(CFLAGS) $(IPV6_CFLAGS)
+!ENDIF
+
+!IF "$(USE_SSPI)"=="true"
+CFLAGS = $(CFLAGS) $(SSPI_CFLAGS)
+!ENDIF
+
+!IF "$(USE_NGHTTP2)"=="true"
+CFLAGS = $(CFLAGS) $(NGHTTP2_CFLAGS)
+LFLAGS = $(LFLAGS) $(NGHTTP2_LFLAGS) $(NGHTTP2_LIBS)
+!ENDIF
+
+!IF "$(USE_MSH3)"=="true"
+CFLAGS = $(CFLAGS) $(MSH3_CFLAGS)
+LFLAGS = $(LFLAGS) $(MSH3_LFLAGS) $(MSH3_LIBS)
+!ENDIF
+
+!IF "$(GEN_PDB)"=="true"
+CFLAGS = $(CFLAGS) $(CFLAGS_PDB) /Fd"$(LIB_DIROBJ)\$(PDB)"
+LFLAGS = $(LFLAGS) $(LFLAGS_PDB)
+!ENDIF
+
+!IF ( "$(USE_SSL)"=="true" && "$(USE_SCHANNEL)"=="true" ) \
+ || ( "$(USE_SSL)"=="true" && "$(USE_MBEDTLS)"=="true" ) \
+ || ( "$(USE_MBEDTLS)"=="true" && "$(USE_SCHANNEL)"=="true" )
+CFLAGS = $(CFLAGS) /DCURL_WITH_MULTI_SSL
+!ENDIF
+
+!IF "$(USE_UNICODE)"=="true"
+CFLAGS = $(CFLAGS) /DUNICODE /D_UNICODE
+!ENDIF
+
+LIB_DIROBJ = ..\builds\$(CONFIG_NAME_LIB)-obj-lib
+CURL_DIROBJ = ..\builds\$(CONFIG_NAME_LIB)-obj-curl
+
+!IFDEF WITH_PREFIX
+DIRDIST = $(WITH_PREFIX)
+!ELSE
+DIRDIST = ..\builds\$(CONFIG_NAME_LIB)\
+!ENDIF
+
+#
+# curl.exe
+#
+CURL_LINK = link.exe /incremental:no /libpath:"$(DIRDIST)\lib"
+
+!IF "$(CFGSET)" != "FALSE"
+# A mode was provided, so the library can be built.
+#
+!include CURL_OBJS.inc
+!include LIBCURL_OBJS.inc
+
+!IF "$(AS_DLL)" == "true"
+LIB_OBJS = $(LIBCURL_OBJS) $(RESOURCE)
+!ELSE
+LIB_OBJS = $(LIBCURL_OBJS)
+!ENDIF
+
+EXE_OBJS = $(CURL_OBJS) $(CURL_DIROBJ)\curl.res
+
+all : $(TARGET) $(PROGRAM_NAME)
+
+package: $(TARGET)
+	@cd $(DIRDIST)
+	@-$(ZIP) -9 -q -r ..\$(CONFIG_NAME_LIB).zip .>nul 2<&1
+	@cd $(MAKEDIR)
+
+$(TARGET): $(LIB_OBJS) $(LIB_DIROBJ) $(DIRDIST)
+	@echo Using SSL: $(USE_SSL)
+	@echo Using NGHTTP2: $(USE_NGHTTP2)
+	@echo Using MSH3: $(USE_MSH3)
+	@echo Using c-ares: $(USE_CARES)
+	@echo Using SSH2: $(USE_SSH2)
+	@echo Using SSH: $(USE_SSH)
+	@echo Using ZLIB: $(USE_ZLIB)
+	@echo Using IDN:  $(USE_IDN)
+	@echo Using IPv6: $(USE_IPV6)
+	@echo Using SSPI: $(USE_SSPI)
+	@echo Using Schannel: $(USE_SCHANNEL)
+	@echo CFLAGS:     $(CFLAGS)
+	@echo LFLAGS:     $(LFLAGS)
+	@echo GenPDB:     $(GEN_PDB)
+	@echo Debug:      $(DEBUG)
+	@echo Machine:    $(MACHINE)
+	$(LNK) $(LIB_OBJS)
+	@echo Copying libs...
+	@if exist $(LIB_DIROBJ)\$(LIB_NAME_DLL) copy $(LIB_DIROBJ)\$(LIB_NAME_DLL)       $(DIRDIST)\bin\ /y >nul 2<&1
+	@if exist $(LIB_DIROBJ)\$(LIB_NAME_STATIC) copy $(LIB_DIROBJ)\$(LIB_NAME_STATIC)    $(DIRDIST)\lib\ /y >nul 2<&1
+	@if exist $(LIB_DIROBJ)\$(LIB_NAME_DLL_DEBUG) copy $(LIB_DIROBJ)\$(LIB_NAME_DLL_DEBUG) $(DIRDIST)\bin\ /y >nul 2<&1
+	@if exist $(LIB_DIROBJ)\$(LIB_NAME_STATIC_DEBUG) copy $(LIB_DIROBJ)\$(LIB_NAME_STATIC_DEBUG) $(DIRDIST)\lib\ /y >nul 2<&1
+	@if exist $(LIB_DIROBJ)\$(LIB_NAME_IMP) copy $(LIB_DIROBJ)\$(LIB_NAME_IMP)       $(DIRDIST)\lib\ /y >nul 2<&1
+	@if exist $(LIB_DIROBJ)\$(LIB_NAME_IMP_DEBUG) copy $(LIB_DIROBJ)\$(LIB_NAME_IMP_DEBUG) $(DIRDIST)\lib >nul 2<&1
+	@-copy $(LIB_DIROBJ)\*.exp                 $(DIRDIST)\lib /y >nul 2<&1
+	@-copy $(LIB_DIROBJ)\*.pdb                 $(DIRDIST)\lib /y >nul 2<&1
+	@-copy ..\include\curl\*.h   $(DIRDIST)\include\curl\ /y  >nul 2<&1
+
+$(LIB_OBJS): $(LIB_DIROBJ) $(DIRDIST)
+
+$(DIRDIST):
+	@if not exist "$(DIRDIST)\bin" mkdir $(DIRDIST)\bin
+	@if not exist "$(DIRDIST)\include" mkdir $(DIRDIST)\include
+	@if not exist "$(DIRDIST)\include\curl" mkdir $(DIRDIST)\include\curl
+	@if not exist "$(DIRDIST)\lib" mkdir $(DIRDIST)\lib
+
+$(LIB_DIROBJ):
+	@if not exist "$(LIB_DIROBJ)" mkdir $(LIB_DIROBJ)
+	@if not exist "$(LIB_DIROBJ)\vauth" mkdir $(LIB_DIROBJ)\vauth
+	@if not exist "$(LIB_DIROBJ)\vtls" mkdir $(LIB_DIROBJ)\vtls
+	@if not exist "$(LIB_DIROBJ)\vssh" mkdir $(LIB_DIROBJ)\vssh
+	@if not exist "$(LIB_DIROBJ)\vquic" mkdir $(LIB_DIROBJ)\vquic
+
+$(CURL_DIROBJ):
+	@if not exist "$(CURL_DIROBJ)" mkdir $(CURL_DIROBJ)
+# we need a lib dir for the portability functions from libcurl
+# we use the .c directly here
+	@if not exist "$(CURL_DIROBJ)" mkdir $(CURL_DIROBJ)\lib
+
+.SUFFIXES: .c .obj .res
+
+{$(LIBCURL_SRC_DIR)\}.c{$(LIB_DIROBJ)\}.obj::
+	$(CURL_CC) $(CFLAGS) /Fo"$(LIB_DIROBJ)\\"  $<
+
+{$(LIBCURL_SRC_DIR)\vauth\}.c{$(LIB_DIROBJ)\vauth\}.obj::
+	$(CURL_CC) $(CFLAGS) /Fo"$(LIB_DIROBJ)\vauth\\"  $<
+
+{$(LIBCURL_SRC_DIR)\vtls\}.c{$(LIB_DIROBJ)\vtls\}.obj::
+	$(CURL_CC) $(CFLAGS) /Fo"$(LIB_DIROBJ)\vtls\\"  $<
+
+{$(LIBCURL_SRC_DIR)\vssh\}.c{$(LIB_DIROBJ)\vssh\}.obj::
+	$(CURL_CC) $(CFLAGS) /Fo"$(LIB_DIROBJ)\vssh\\"  $<
+
+{$(LIBCURL_SRC_DIR)\vquic\}.c{$(LIB_DIROBJ)\vquic\}.obj::
+	$(CURL_CC) $(CFLAGS) /Fo"$(LIB_DIROBJ)\vquic\\"  $<
+
+$(LIB_DIROBJ)\libcurl.res: $(LIBCURL_SRC_DIR)\libcurl.rc
+	$(RC) $(RC_FLAGS)
+
+#
+# curl.exe
+#
+
+
+!IF "$(MODE)"=="static"
+!IF "$(DEBUG)"=="yes"
+CURL_LIBCURL_LIBNAME=$(LIB_NAME_STATIC_DEBUG)
+!ELSE
+CURL_LIBCURL_LIBNAME=$(LIB_NAME_STATIC)
+!ENDIF
+!ELSEIF "$(MODE)"=="dll"
+!IF "$(DEBUG)"=="yes"
+CURL_LIBCURL_LIBNAME=$(LIB_NAME_IMP_DEBUG)
+!ELSE
+CURL_LIBCURL_LIBNAME=$(LIB_NAME_IMP)
+!ENDIF
+!ENDIF
+
+CURL_FROM_LIBCURL=$(CURL_DIROBJ)\tool_hugehelp.obj \
+ $(CURL_DIROBJ)\nonblock.obj \
+ $(CURL_DIROBJ)\strtoofft.obj \
+ $(CURL_DIROBJ)\warnless.obj \
+ $(CURL_DIROBJ)\curl_multibyte.obj \
+ $(CURL_DIROBJ)\version_win32.obj \
+ $(CURL_DIROBJ)\dynbuf.obj \
+ $(CURL_DIROBJ)\base64.obj
+
+$(PROGRAM_NAME): $(CURL_DIROBJ) $(CURL_FROM_LIBCURL) $(EXE_OBJS)
+	$(CURL_LINK) $(CURL_LFLAGS) $(CURL_LIBCURL_LIBNAME) $(WIN_LIBS) $(CURL_FROM_LIBCURL) $(EXE_OBJS)
+	$(MANIFESTTOOL)
+
+{$(CURL_SRC_DIR)\}.c{$(CURL_DIROBJ)\}.obj::
+	$(CURL_CC) $(CURL_CFLAGS) /Fo"$(CURL_DIROBJ)\\"  $<
+
+$(CURL_DIROBJ)\tool_hugehelp.obj: $(CURL_SRC_DIR)\tool_hugehelp.c
+	$(CURL_CC) $(CURL_CFLAGS) /Zm200 /Fo"$@" $(CURL_SRC_DIR)\tool_hugehelp.c
+$(CURL_DIROBJ)\nonblock.obj: ../lib/nonblock.c
+	$(CURL_CC) $(CURL_CFLAGS) /Fo"$@" ../lib/nonblock.c
+$(CURL_DIROBJ)\strtoofft.obj: ../lib/strtoofft.c
+	$(CURL_CC) $(CURL_CFLAGS) /Fo"$@" ../lib/strtoofft.c
+$(CURL_DIROBJ)\warnless.obj: ../lib/warnless.c
+	$(CURL_CC) $(CURL_CFLAGS) /Fo"$@" ../lib/warnless.c
+$(CURL_DIROBJ)\curl_multibyte.obj: ../lib/curl_multibyte.c
+	$(CURL_CC) $(CURL_CFLAGS) /Fo"$@" ../lib/curl_multibyte.c
+$(CURL_DIROBJ)\version_win32.obj: ../lib/version_win32.c
+	$(CURL_CC) $(CURL_CFLAGS) /Fo"$@" ../lib/version_win32.c
+$(CURL_DIROBJ)\dynbuf.obj: ../lib/dynbuf.c
+	$(CURL_CC) $(CURL_CFLAGS) /Fo"$@" ../lib/dynbuf.c
+$(CURL_DIROBJ)\base64.obj: ../lib/base64.c
+	$(CURL_CC) $(CURL_CFLAGS) /Fo"$@" ../lib/base64.c
+$(CURL_DIROBJ)\curl.res: $(CURL_SRC_DIR)\curl.rc
+	$(RC) $(CURL_RC_FLAGS)
+
+!ENDIF  # End of case where a config was provided.
+
+# Makefile.vc's clean removes (LIB)CURL_DIROBJ and DIRDIST dirs then calls
+# this clean. Note those are the original directories we control and not the
+# directories possibly modified by this makefile to point to user-specified
+# directories.
+# For example, don't remove DIRDIST here since it may contain user files if it
+# has been changed by WITH_PREFIX to a different output dir (eg C:\usr\local).
+clean:
+	@-erase /s *.dll 2> NUL
+	@-erase /s *.exp 2> NUL
+	@-erase /s *.idb 2> NUL
+	@-erase /s *.lib 2> NUL
+	@-erase /s *.obj 2> NUL
+	@-erase /s *.pch 2> NUL
+	@-erase /s *.pdb 2> NUL
+	@-erase /s *.res 2> NUL
diff --git a/winbuild/README.md b/winbuild/README.md
index 2fe60a090..1ab5f5825 100644
--- a/winbuild/README.md
+++ b/winbuild/README.md
@@ -88,8 +88,8 @@ where `<options>` is one or many of:
  - `WITH_MBEDTLS=<dll/static>`   - Enable mbedTLS support, DLL or static
  - `WITH_CARES=<dll/static>`     - Enable c-ares support, DLL or static
  - `WITH_ZLIB=<dll/static>`      - Enable zlib support, DLL or static
- - `WITH_SSH=<dll/static>`       - Enable libSSH support, DLL or static
- - `WITH_SSH2=<dll/static>`      - Enable libSSH2 support, DLL or static
+ - `WITH_SSH=<dll/static>`       - Enable libssh support, DLL or static
+ - `WITH_SSH2=<dll/static>`      - Enable libssh2 support, DLL or static
  - `WITH_PREFIX=<dir>`           - Where to install the build
  - `ENABLE_SSPI=<yes/no>`        - Enable SSPI support, defaults to yes
  - `ENABLE_IPV6=<yes/no>`        - Enable IPv6, defaults to yes
@@ -110,7 +110,7 @@ where `<options>` is one or many of:
  - `MBEDTLS_PATH=<path>`         - Custom path for mbedTLS
  - `NGHTTP2_PATH=<path>`         - Custom path for nghttp2
  - `MSH3_PATH=<path>`            - Custom path for msh3
- - `SSH2_PATH=<path>`            - Custom path for libSSH2
+ - `SSH2_PATH=<path>`            - Custom path for libssh2
  - `SSL_PATH=<path>`             - Custom path for OpenSSL
  - `ZLIB_PATH=<path>`            - Custom path for zlib
 
diff --git a/winbuild/makedebug.cmd b/winbuild/makedebug.bat
similarity index 81%
rename from winbuild/makedebug.cmd
rename to winbuild/makedebug.bat
index 3f523c82f..e86e668ca 100644
--- a/winbuild/makedebug.cmd
+++ b/winbuild/makedebug.bat
@@ -25,12 +25,9 @@ rem ***************************************************************************
 
 where.exe nmake.exe >nul 2>&1
 
-IF %ERRORLEVEL% == 1 (
-  ECHO Error: Can't find `nmake.exe` - be sure to run this script from within a Developer Command-Prompt
-  ECHO.
-) ELSE (
-  nmake /f Makefile.vc mode=static DEBUG=yes GEN_PDB=yes
-  IF %ERRORLEVEL% NEQ 0 (
-    ECHO "Error: Build Failed"
-  )
+if %ERRORLEVEL% EQU 1 (
+  echo Error: Cannot find nmake.exe - be sure to run this script from within a Developer Command-Prompt
+) else (
+  nmake.exe /f Makefile.vc mode=static DEBUG=yes GEN_PDB=yes
+  if %ERRORLEVEL% NEQ 0 echo Error: Build Failed
 )
```

