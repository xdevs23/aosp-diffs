```diff
diff --git a/.editorconfig b/.editorconfig
new file mode 100644
index 00000000..2df38ac4
--- /dev/null
+++ b/.editorconfig
@@ -0,0 +1,10 @@
+root = true
+
+[*]
+indent_size = 2
+charset = utf-8
+trim_trailing_whitespace = true
+insert_final_newline = true
+
+[*.{kt,kts}]
+kotlin_imports_layout=ascii
diff --git a/.gitattributes b/.gitattributes
new file mode 100644
index 00000000..411c0777
--- /dev/null
+++ b/.gitattributes
@@ -0,0 +1,4 @@
+* text=auto eol=lf
+
+*.bat text eol=crlf
+*.jar binary
diff --git a/.github/CODE_OF_CONDUCT.md b/.github/CODE_OF_CONDUCT.md
new file mode 100644
index 00000000..173a1908
--- /dev/null
+++ b/.github/CODE_OF_CONDUCT.md
@@ -0,0 +1 @@
+See https://square.github.io/leakcanary/code_of_conduct
\ No newline at end of file
diff --git a/.github/CONTRIBUTING.md b/.github/CONTRIBUTING.md
new file mode 100644
index 00000000..db5c3fc2
--- /dev/null
+++ b/.github/CONTRIBUTING.md
@@ -0,0 +1 @@
+See https://square.github.io/leakcanary/how_to_help/
\ No newline at end of file
diff --git a/.github/ISSUE_TEMPLATE/1-leak.md b/.github/ISSUE_TEMPLATE/1-leak.md
new file mode 100644
index 00000000..0ba71a82
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/1-leak.md
@@ -0,0 +1,17 @@
+---
+name: "\U0001F424Leak in your app"
+about: Use Stack Overflow instead
+title: "\U0001F649 [This issue will be immediately closed]"
+labels: 'Close immediately'
+assignees: ''
+
+---
+
+ðŸ›‘ ð™Žð™ð™Šð™‹
+
+This issue tracker is not for help with memory leaks detected by LeakCanary in your own app.
+
+To fix a leak: 
+
+* First, learn the fundamentals: https://square.github.io/leakcanary/fundamentals/
+* Then, create a Stack Overflow question: https://stackoverflow.com/questions/tagged/leakcanary
diff --git a/.github/ISSUE_TEMPLATE/2-bug.md b/.github/ISSUE_TEMPLATE/2-bug.md
new file mode 100644
index 00000000..2a8301be
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/2-bug.md
@@ -0,0 +1,32 @@
+---
+name: "\U0001F41BBug report"
+about: 'Build errors, bugs and runtime crashes in version 2.0'
+title: ''
+labels: 'type: bug'
+assignees: ''
+
+---
+
+### Description
+
+[Description of the issue]
+
+### Steps to Reproduce
+
+[Provide a sample project, a .hprof file or a failing test]
+
+1. [First Step]
+2. [Second Step]
+3. [and so on...]
+
+**Expected behavior:** [What you expect to happen]
+
+### Version Information
+
+* LeakCanary version:
+* Android OS version:
+* Gradle version:
+
+### Additional Information
+
+Any additional information, configuration or data that might be necessary to reproduce the issue.
diff --git a/.github/ISSUE_TEMPLATE/3-feature.md b/.github/ISSUE_TEMPLATE/3-feature.md
new file mode 100644
index 00000000..9620f7cf
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/3-feature.md
@@ -0,0 +1,14 @@
+---
+name: "\U0001F64FFeature request"
+about: Suggest an idea for LeakCanary
+title: ''
+labels: 'type: enhancement'
+assignees: ''
+
+---
+
+### Problem description
+
+### Potential solutions
+
+### Additional information
diff --git a/.github/ISSUE_TEMPLATE/4-doc.md b/.github/ISSUE_TEMPLATE/4-doc.md
new file mode 100644
index 00000000..9f785213
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/4-doc.md
@@ -0,0 +1,10 @@
+---
+name: "\U0001F4DADocumentation request"
+about: Point out what's confusing or missing
+title: ''
+labels: 'type: documentation'
+assignees: ''
+
+---
+
+
diff --git a/.github/ISSUE_TEMPLATE/5-sdk.md b/.github/ISSUE_TEMPLATE/5-sdk.md
new file mode 100644
index 00000000..440bc1df
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/5-sdk.md
@@ -0,0 +1,16 @@
+---
+name: "\U0001F916Leak in Android SDK / support library"
+about: Help LeakCanary identify known leaks
+title: ''
+labels: 'type: leak'
+assignees: ''
+
+---
+
+Read this first: https://square.github.io/leakcanary/faq/#can-a-leak-be-caused-by-the-android-sdk
+
+### LeakTrace information
+
+```
+{REPLACE THIS LINE WITH THE OUTPUT FROM LEAKCANARY}
+```
diff --git a/.github/SUPPORT.md b/.github/SUPPORT.md
new file mode 100644
index 00000000..8872c01e
--- /dev/null
+++ b/.github/SUPPORT.md
@@ -0,0 +1 @@
+See https://square.github.io/leakcanary/support
\ No newline at end of file
diff --git a/.github/workflows-disabled/greetings.yml b/.github/workflows-disabled/greetings.yml
new file mode 100644
index 00000000..2af9d8f8
--- /dev/null
+++ b/.github/workflows-disabled/greetings.yml
@@ -0,0 +1,12 @@
+name: Greetings
+
+on: [pull_request, issues]
+
+jobs:
+  greeting:
+    runs-on: ubuntu-latest
+    steps:
+    - uses: actions/first-interaction@v1
+      with:
+        repo-token: ${{ secrets.GITHUB_TOKEN }}
+        issue-message: 'ðŸ™Thank you for opening an issue! LeakCanary is maintained by [volunteers](https://github.com/square/leakcanary/graphs/contributors) from the community. Please be kind and remember that LeakCanary isn''t anyone''s main job ðŸ˜˜.'
diff --git a/.github/workflows/main.yml b/.github/workflows/main.yml
new file mode 100644
index 00000000..a3fe532f
--- /dev/null
+++ b/.github/workflows/main.yml
@@ -0,0 +1,121 @@
+name: Main
+
+on:
+  pull_request:
+  push:
+    branches:
+      - main
+
+jobs:
+  validation:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - uses: gradle/wrapper-validation-action@v1
+
+  checks:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - uses: actions/setup-java@v3
+        with:
+          java-version: 8
+          distribution: 'zulu'
+      - uses: gradle/gradle-build-action@v2
+      - name: Build project
+        run: ./gradlew build --stacktrace
+
+  instrumentation-tests:
+    runs-on: macos-latest
+    timeout-minutes: 30
+    strategy:
+      # Allow tests to continue on other devices if they fail on one device.
+      fail-fast: false
+      matrix:
+        arch: [ x86_64 ]
+        target: [ google_apis ]
+        channel: [ stable ]
+        api-level:
+          - 21
+          - 23
+          - 26
+          # - 29 flaky
+        include:
+          - arch: x86
+            api-level: 16
+            target: google_apis
+            channel: stable
+          - arch: x86
+            api-level: 19
+            target: google_apis
+            channel: stable
+        # Failing (something about permissions maybe?
+        #  - arch: x86
+        #    api-level: 30
+        #    target: aosp_atd
+        #    channel: canary
+    steps:
+      - uses: actions/checkout@v3
+      - uses: actions/setup-java@v3
+        with:
+          java-version: 8
+          distribution: 'zulu'
+      - uses: gradle/gradle-build-action@v2
+      - name: AVD cache
+        uses: actions/cache@v3
+        id: avd-cache
+        with:
+          path: |
+            ~/.android/avd/*
+            ~/.android/adb*
+          key: avd-${{ matrix.api-level }}-${{ matrix.os }}-${{ matrix.target }}
+      - name: Create AVD and generate snapshot for caching
+        if: steps.avd-cache.outputs.cache-hit != 'true'
+        uses: reactivecircus/android-emulator-runner@v2
+        with:
+          api-level: ${{ matrix.api-level }}
+          target: ${{ matrix.target }}
+          arch: ${{ matrix.arch }}
+          force-avd-creation: false
+          emulator-options: -no-window -gpu swiftshader_indirect -noaudio -no-boot-anim -camera-back none
+          disable-animations: false
+          script: echo "Generated AVD snapshot for caching."
+      - name: Instrumentation Tests
+        uses: reactivecircus/android-emulator-runner@v2
+        with:
+          api-level: ${{ matrix.api-level }}
+          target: ${{ matrix.target }}
+          arch: ${{ matrix.arch }}
+          script: |
+            touch emulator.log                    # create log file
+            chmod 777 emulator.log                # allow writing to log file
+            adb logcat >> emulator.log &          # pipe all logcat messages into log file as a background process
+            ./gradlew leakcanary-android-core:connectedCheck leakcanary-android:connectedCheck leakcanary-android-instrumentation:connectedCheck --no-build-cache --no-daemon --stacktrace
+      - name: Upload results
+        if: ${{ always() }}
+        uses: actions/upload-artifact@v3
+        with:
+          name: ${{ matrix.api-level }}-${{ matrix.arch }}-instrumentation-test-results
+          path: |
+            emulator.log
+            ./**/build/reports/androidTests/connected/**
+
+  snapshot-deployment:
+    if: github.repository == 'square/leakcanary' && github.event_name == 'push'
+    needs: [ checks, instrumentation-tests ]
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - uses: actions/setup-java@v3
+        with:
+          java-version: 8
+          distribution: 'zulu'
+      - uses: gradle/gradle-build-action@v2
+      - name: Deploy snapshot
+        run: ./gradlew publish
+        env:
+          ORG_GRADLE_PROJECT_mavenCentralUsername: ${{ secrets.SONATYPE_NEXUS_USERNAME }}
+          ORG_GRADLE_PROJECT_mavenCentralPassword: ${{ secrets.SONATYPE_NEXUS_PASSWORD }}
+      - name: Cleanup secrets
+        if: always()
+        run: rm -rf ~/.gradle/gradle.properties
diff --git a/.github/workflows/stale.yaml b/.github/workflows/stale.yaml
new file mode 100644
index 00000000..6b0dd024
--- /dev/null
+++ b/.github/workflows/stale.yaml
@@ -0,0 +1,21 @@
+name: Mark stale issues
+on:
+  schedule:
+    - cron: "30 1 * * *"
+
+jobs:
+  stale:
+    runs-on: ubuntu-latest
+    permissions:
+      issues: write
+    steps:
+      - uses: actions/stale@v5
+        with:
+          repo-token: ${{ secrets.GITHUB_TOKEN }}
+          days-before-stale: 30
+          days-before-close: 7
+          stale-issue-message: 'This issue is not actionable without the required information. Please comment or this will be closed in 7 days.'
+          close-issue-message: 'This issue was closed because it did not provide enough information to make it actionable.'
+          stale-issue-label: stale
+          stale-pr-label: stale
+          any-of-labels: 'status: needs more info, status: needs heap dump'
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 00000000..db65023b
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,42 @@
+# Gradle
+.gradle
+gradlew.bat
+build
+local.properties
+reports
+
+# Maven
+target
+pom.xml.*
+release.properties
+gen-external-apklibs
+
+# Eclipse
+.classpath
+.project
+.settings
+eclipsebin
+
+# IntelliJ IDEA
+.idea
+*.iml
+*.ipl
+*.iws
+classes/
+idea-classes/
+coverage-error.log
+
+# Android
+gen
+bin
+project.properties
+out
+
+# Finder
+.DS_Store
+
+# Docs
+site
+
+# Generated dokka
+docs/api
\ No newline at end of file
diff --git a/Android.bp b/Android.bp
new file mode 100644
index 00000000..15a33ec0
--- /dev/null
+++ b/Android.bp
@@ -0,0 +1,45 @@
+package {
+    default_applicable_licenses: ["external_leakcanary_license"],
+}
+
+license {
+    name: "external_leakcanary_license",
+    visibility: ["//visibility:public"],
+    license_kinds: [
+        "SPDX-license-identifier-Apache-2.0",
+    ],
+    license_text: [
+        "LICENSE",
+    ],
+}
+
+license {
+    name: "license",
+    package_name: "leakcanary",
+}
+
+android_manifest_package_attribute = "\"com.squareup.leakcanary\""
+
+genrule {
+    name: "AddLeakCanaryPackageAttributeToAndroidManifest",
+    srcs: [
+        "leakcanary-android/src/main/AndroidManifest.xml",
+    ],
+    out: [
+        "leakcanary-android/src/main/AndroidManifestGen.xml",
+    ],
+    cmd: "sed -E 's/<manifest>/<manifest package=" +
+        android_manifest_package_attribute +
+        ">/g' $(in) > $(out)",
+}
+
+android_library {
+    name: "leakcanary",
+    srcs: [
+        "leakcanary-android/src/main/**/*.java",
+    ],
+    manifest: ":AddLeakCanaryPackageAttributeToAndroidManifest",
+    sdk_version: "34",
+    min_sdk_version: "14",
+    java_version: "1.8",
+}
diff --git a/LICENSE b/LICENSE
new file mode 120000
index 00000000..85de3d45
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1 @@
+LICENSE.txt
\ No newline at end of file
diff --git a/LICENSE.txt b/LICENSE.txt
new file mode 100644
index 00000000..7a4a3ea2
--- /dev/null
+++ b/LICENSE.txt
@@ -0,0 +1,202 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
\ No newline at end of file
diff --git a/METADATA b/METADATA
new file mode 100644
index 00000000..2bdcd860
--- /dev/null
+++ b/METADATA
@@ -0,0 +1,15 @@
+name: "leakcanary2"
+description:
+    "Memory leak detection library for Android."
+
+third_party {
+  identifier {
+    type: "Git"
+    value: "https://github.com/square/leakcanary"
+    primary_source: true
+    version: "2.13"
+  }
+  license_type: NOTICE
+  version: "2.13"
+  last_upgrade_date { year: 2024 month: 5 day: 20 }
+}
diff --git a/MODULE_LICENSE_APACHE2 b/MODULE_LICENSE_APACHE2
new file mode 100644
index 00000000..e69de29b
diff --git a/OWNERS b/OWNERS
new file mode 100644
index 00000000..2e8f086e
--- /dev/null
+++ b/OWNERS
@@ -0,0 +1 @@
+include platform/system/core:main:/janitors/OWNERS
diff --git a/README.md b/README.md
new file mode 100644
index 00000000..985a5096
--- /dev/null
+++ b/README.md
@@ -0,0 +1,23 @@
+# LeakCanary ðŸ¤
+
+A memory leak detection library for Android.
+
+### [square.github.io/leakcanary](https://square.github.io/leakcanary)
+
+ðŸ™ If you like LeakCanary you can show support by starring â­ this repository.
+
+## License
+
+    Copyright 2015 Square, Inc.
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 00000000..0d941957
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,169 @@
+import org.jetbrains.dokka.gradle.DokkaTask
+
+buildscript {
+  ext.versions = [
+    'minSdk'    : 14,
+    'compileSdk': 34,
+  ]
+  repositories {
+    google()
+    gradlePluginPortal()
+    mavenCentral()
+  }
+  dependencies {
+    classpath libs.gradlePlugin.android
+    classpath libs.gradlePlugin.kotlin
+    classpath libs.gradlePlugin.dokka
+    classpath libs.gradlePlugin.mavenPublish
+    classpath libs.gradlePlugin.detekt
+    classpath libs.gradlePlugin.binaryCompatibility
+    classpath libs.gradlePlugin.keeper
+  }
+}
+
+// We use JetBrain's Kotlin Binary Compatibility Validator to track changes to our public binary
+// APIs.
+// When making a change that results in a public ABI change, the apiCheck task will fail. When this
+// happens, run ./gradlew apiDump to generate updated *.api files, and add those to your commit.
+// See https://github.com/Kotlin/binary-compatibility-validator
+apply plugin: 'binary-compatibility-validator'
+
+apiValidation {
+  // Ignore projects that are not uploaded to Maven Central
+  ignoredProjects += ["leakcanary-android-sample", "shark-test", "shark-hprof-test", "shark-cli"]
+}
+
+// This plugin needs to be applied to the root projects for the dokkaGfmCollector task we use to
+// generate the documentation site.
+apply plugin: 'org.jetbrains.dokka'
+
+repositories {
+  // Needed for the Dokka plugin.
+  gradlePluginPortal()
+}
+
+subprojects {
+  // Note: to skip Dokka on some projects we could add it individually to projects we actually
+  // want.
+  apply plugin: 'org.jetbrains.dokka'
+  group = GROUP
+  version = VERSION_NAME
+
+  repositories {
+    google()
+    mavenCentral()
+    //    maven {
+    //      url 'https://oss.sonatype.org/content/repositories/snapshots/'
+    //    }
+    //    mavenLocal()
+    jcenter()
+  }
+
+  apply plugin: 'io.gitlab.arturbosch.detekt'
+
+  tasks.withType(DokkaTask.class).configureEach {
+    dokkaSourceSets.configureEach {
+      reportUndocumented.set(false)
+      displayName.set(null)
+      platform.set(org.jetbrains.dokka.Platform.jvm)
+
+      perPackageOption {
+        // will match all .internal packages and sub-packages
+        matchingRegex.set("(.*\\.internal.*)")
+        suppress.set(true)
+      }
+      perPackageOption {
+        // BuildConfig files
+        matchingRegex.set("com.squareup.leakcanary\\..*")
+        suppress.set(true)
+      }
+      perPackageOption {
+        // Example app
+        matchingRegex.set("com.example.leakcanary\\..*")
+        suppress.set(true)
+      }
+      skipDeprecated.set(true)
+      externalDocumentationLink {
+        url.set(new URL("https://square.github.io/okio/2.x/okio/"))
+      }
+      externalDocumentationLink {
+        url.set(new URL("https://square.github.io/moshi/1.x/moshi/"))
+      }
+    }
+  }
+
+  pluginManager.withPlugin("com.vanniktech.maven.publish") {
+    mavenPublish {
+      sonatypeHost = "S01"
+    }
+  }
+
+  tasks.withType(JavaCompile).configureEach {
+    options.compilerArgs += [
+        '-Xlint:all',
+        '-Xlint:-serial',
+        '-Xlint:-deprecation',
+        // espresso-core classes say they're compiled with 51.0 but contain 52.0 attributes.
+        // warning: [classfile] MethodParameters attribute introduced in version 52.0 class files is ignored in version 51.0 class files
+        // '-Werror'
+    ]
+  }
+
+  tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach {
+    kotlinOptions {
+      // Avoid warnings of using older stdlib version 1.3 than compiler version 1.4
+      apiVersion = "1.3"
+    }
+  }
+
+  tasks.withType(Test).configureEach {
+    testLogging {
+      exceptionFormat 'FULL'
+      showCauses true
+      showExceptions true
+      showStackTraces true
+    }
+  }
+
+  detekt {
+    config = rootProject.files('detekt-config.yml')
+    parallel = true
+    reports {
+      xml.enabled = false
+    }
+  }
+
+  pluginManager.withPlugin("java") {
+    tasks.named("check") { dependsOn("detekt") }
+    tasks.named("assemble") { dependsOn(rootProject.tasks.named("installGitHooks")) }
+    tasks.named("clean") { dependsOn(rootProject.tasks.named("installGitHooks")) }
+  }
+}
+
+//Copies git hooks from /hooks folder into .git; currently used to run Detekt during push
+//Git hook installation
+tasks.register("installGitHooks", Copy) {
+  from new File(rootProject.rootDir, 'hooks')
+  into { new File(rootProject.rootDir, '.git/hooks') }
+  fileMode 0777 //Make files executable
+}
+
+tasks.register("siteDokka", Copy) {
+  description = "Generate dokka Github-flavored Markdown for the documentation site."
+  group = "documentation"
+  dependsOn(":dokkaGfmCollector")
+
+  // Copy the files instead of configuring a different output directory on the dokka task itself
+  // since the default output directories disambiguate between different types of outputs, and our
+  // custom directory doesn't.
+  from(layout.buildDirectory.dir("dokka/gfmCollector/leakcanary"))
+  // For whatever reason Dokka doesn't want to ignore the packages we told it to ignore.
+  // Fine, we'll just ignore it here.
+  exclude '**/com.example.leakcanary/**'
+  into(rootProject.file("docs/api"))
+
+  filter { line ->
+    // Dokka adds [main]\ and [main]<br> everywhere, this just removes it.
+    line.replaceAll("\\[main\\]\\\\", "").replaceAll("\\[main\\]<br>", "")
+  }
+}
diff --git a/detekt-config.yml b/detekt-config.yml
new file mode 100644
index 00000000..14af4db9
--- /dev/null
+++ b/detekt-config.yml
@@ -0,0 +1,570 @@
+build:
+  maxIssues: 0
+  weights:
+    # complexity: 2
+    # LongParameterList: 1
+    # style: 1
+    # comments: 1
+
+processors:
+  active: true
+  exclude:
+  # - 'FunctionCountProcessor'
+  # - 'PropertyCountProcessor'
+  # - 'ClassCountProcessor'
+  # - 'PackageCountProcessor'
+  # - 'KtFileCountProcessor'
+
+console-reports:
+  active: true
+  exclude:
+  #  - 'ProjectStatisticsReport'
+  #  - 'ComplexityReport'
+  #  - 'NotificationReport'
+  #  - 'FindingsReport'
+  #  - 'BuildFailureReport'
+
+comments:
+  active: true
+  excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+  CommentOverPrivateFunction:
+    active: false
+  CommentOverPrivateProperty:
+    active: false
+  EndOfSentenceFormat:
+    active: false
+    endOfSentenceFormat: ([.?!][ \t\n\r\f<])|([.?!:]$)
+  UndocumentedPublicClass:
+    active: false
+    searchInNestedClass: true
+    searchInInnerClass: true
+    searchInInnerObject: true
+    searchInInnerInterface: true
+  UndocumentedPublicFunction:
+    active: false
+
+complexity:
+  active: true
+  ComplexCondition:
+    active: true
+    threshold: 4
+  ComplexInterface:
+    active: false
+    threshold: 10
+    includeStaticDeclarations: false
+  ComplexMethod:
+    #LeakCanary - increased allowed complexity from 10 to 30; enabled ignores
+    active: true
+    threshold: 30
+    ignoreSingleWhenExpression: true
+    ignoreSimpleWhenEntries: true
+  LabeledExpression:
+    active: false
+    ignoredLabels: ""
+  LargeClass:
+    active: true
+    threshold: 600
+  LongMethod:
+    #LeakCanary - increased from 60 to 90
+    active: true
+    threshold: 90
+  LongParameterList:
+    #LeakCanary - enabled ignore
+    active: true
+    threshold: 6
+    ignoreDefaultParameters: true
+  MethodOverloading:
+    active: false
+    threshold: 6
+  NestedBlockDepth:
+    #LeakCanary - increased from 4 to 7
+    active: true
+    threshold: 7
+  StringLiteralDuplication:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    threshold: 3
+    ignoreAnnotation: true
+    excludeStringsWithLessThan5Characters: true
+    ignoreStringsRegex: '$^'
+  TooManyFunctions:
+    #LeakCanary - increased from 11 to 12
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    thresholdInFiles: 50
+    thresholdInClasses: 50
+    thresholdInInterfaces: 11
+    thresholdInObjects: 50
+    thresholdInEnums: 12
+    ignoreDeprecated: false
+    ignorePrivate: false
+    ignoreOverridden: false
+
+coroutines:
+  active: true
+  GlobalCoroutineUsage:
+    active: true
+  RedundantSuspendModifier:
+    active: true
+
+empty-blocks:
+  active: true
+  EmptyCatchBlock:
+    active: true
+    allowedExceptionNameRegex: "^(_|(ignore|expected).*)"
+  EmptyClassBlock:
+    active: true
+  EmptyDefaultConstructor:
+    active: true
+  EmptyDoWhileBlock:
+    active: true
+  EmptyElseBlock:
+    active: true
+  EmptyFinallyBlock:
+    active: true
+  EmptyForBlock:
+    active: true
+  EmptyFunctionBlock:
+    #LeakCanary - allow empty overridden functions
+    active: true
+    ignoreOverridden: true
+  EmptyIfBlock:
+    active: true
+  EmptyInitBlock:
+    active: true
+  EmptyKtFile:
+    active: true
+  EmptySecondaryConstructor:
+    active: true
+  EmptyWhenBlock:
+    active: true
+  EmptyWhileBlock:
+    active: true
+
+exceptions:
+  active: true
+  ExceptionRaisedInUnexpectedLocation:
+    active: false
+    methodNames: 'toString,hashCode,equals,finalize'
+  InstanceOfCheckForException:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+  NotImplementedDeclaration:
+    active: false
+  PrintStackTrace:
+    active: false
+  RethrowCaughtException:
+    active: false
+  ReturnFromFinally:
+    active: false
+  SwallowedException:
+    active: false
+    ignoredExceptionTypes: 'InterruptedException,NumberFormatException,ParseException,MalformedURLException'
+  ThrowingExceptionFromFinally:
+    active: false
+  ThrowingExceptionInMain:
+    active: false
+  ThrowingExceptionsWithoutMessageOrCause:
+    active: false
+    exceptions: 'IllegalArgumentException,IllegalStateException,IOException'
+  ThrowingNewInstanceOfSameException:
+    active: false
+  TooGenericExceptionCaught:
+    #LeakCanary - disabled
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    exceptionNames:
+     - ArrayIndexOutOfBoundsException
+     - Error
+     - Exception
+     - IllegalMonitorStateException
+     - NullPointerException
+     - IndexOutOfBoundsException
+     - RuntimeException
+     - Throwable
+    allowedExceptionNameRegex: "^(_|(ignore|expected).*)"
+  TooGenericExceptionThrown:
+    #LeakCanary - disabled
+    active: false
+    exceptionNames:
+     - Error
+     - Exception
+     - Throwable
+     - RuntimeException
+
+formatting:
+  active: true
+  android: false
+  autoCorrect: true
+  AnnotationOnSeparateLine:
+    active: false
+  ChainWrapping:
+    active: true
+    autoCorrect: true
+  CommentSpacing:
+    active: true
+    autoCorrect: true
+  Filename:
+    active: true
+  FinalNewline:
+    active: true
+    autoCorrect: true
+  ImportOrdering:
+    active: false
+  Indentation:
+    active: false
+    indentSize: 4
+    continuationIndentSize: 4
+  MaximumLineLength:
+    active: true
+    maxLineLength: 120
+  ModifierOrdering:
+    active: true
+    autoCorrect: true
+  MultiLineIfElse:
+    active: true
+    autoCorrect: true
+  NoBlankLineBeforeRbrace:
+    active: true
+    autoCorrect: true
+  NoConsecutiveBlankLines:
+    active: true
+    autoCorrect: true
+  NoEmptyClassBody:
+    active: true
+    autoCorrect: true
+  NoLineBreakAfterElse:
+    active: true
+    autoCorrect: true
+  NoLineBreakBeforeAssignment:
+    active: true
+    autoCorrect: true
+  NoMultipleSpaces:
+    active: true
+    autoCorrect: true
+  NoSemicolons:
+    active: true
+    autoCorrect: true
+  NoTrailingSpaces:
+    active: true
+    autoCorrect: true
+  NoUnitReturn:
+    active: true
+    autoCorrect: true
+  NoUnusedImports:
+    active: true
+    autoCorrect: true
+  NoWildcardImports:
+    active: true
+    autoCorrect: true
+  PackageName:
+    active: true
+    autoCorrect: true
+  ParameterListWrapping:
+    active: true
+    autoCorrect: true
+    indentSize: 4
+  SpacingAroundColon:
+    active: true
+    autoCorrect: true
+  SpacingAroundComma:
+    active: true
+    autoCorrect: true
+  SpacingAroundCurly:
+    active: true
+    autoCorrect: true
+  SpacingAroundDot:
+    active: true
+    autoCorrect: true
+  SpacingAroundKeyword:
+    active: true
+    autoCorrect: true
+  SpacingAroundOperators:
+    active: true
+    autoCorrect: true
+  SpacingAroundParens:
+    active: true
+    autoCorrect: true
+  SpacingAroundRangeOperator:
+    active: true
+    autoCorrect: true
+  StringTemplate:
+    active: true
+    autoCorrect: true
+
+naming:
+  active: true
+  ClassNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    classPattern: '[A-Z$][a-zA-Z0-9$]*'
+  ConstructorParameterNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    parameterPattern: '[a-z][A-Za-z0-9]*'
+    privateParameterPattern: '[a-z][A-Za-z0-9]*'
+    excludeClassPattern: '$^'
+  EnumNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    enumEntryPattern: '^[A-Z][_a-zA-Z0-9]*'
+  ForbiddenClassName:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    forbiddenName: ''
+  FunctionMaxLength:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    maximumFunctionNameLength: 30
+  FunctionMinLength:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    minimumFunctionNameLength: 3
+  FunctionNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    functionPattern: '^([a-z$][a-zA-Z$0-9]*)|(`.*`)$'
+    excludeClassPattern: '$^'
+    ignoreOverridden: true
+  FunctionParameterNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    parameterPattern: '[a-z][A-Za-z0-9]*'
+    excludeClassPattern: '$^'
+    ignoreOverridden: true
+  InvalidPackageDeclaration:
+    active: false
+    rootPackage: ''
+  MatchingDeclarationName:
+    active: true
+  MemberNameEqualsClassName:
+    active: false
+    ignoreOverridden: true
+  ObjectPropertyNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    constantPattern: '[A-Za-z][_A-Za-z0-9]*'
+    propertyPattern: '[A-Za-z][_A-Za-z0-9]*'
+    privatePropertyPattern: '(_)?[A-Za-z][_A-Za-z0-9]*'
+  PackageNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    packagePattern: '^[a-z]+(\.[a-z][A-Za-z0-9]*)*$'
+  TopLevelPropertyNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    constantPattern: '[A-Z][_A-Z0-9]*'
+    propertyPattern: '[A-Za-z][_A-Za-z0-9]*'
+    privatePropertyPattern: '_?[A-Za-z][_A-Za-z0-9]*'
+  VariableMaxLength:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    maximumVariableNameLength: 64
+  VariableMinLength:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    minimumVariableNameLength: 1
+  VariableNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    variablePattern: '[a-z][A-Za-z0-9]*'
+    privateVariablePattern: '(_)?[a-z][A-Za-z0-9]*'
+    excludeClassPattern: '$^'
+    ignoreOverridden: true
+
+performance:
+  active: true
+  ArrayPrimitive:
+    active: false
+  ForEachOnRange:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+  SpreadOperator:
+    #LeakCanary - disabled
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+  UnnecessaryTemporaryInstantiation:
+    active: true
+
+potential-bugs:
+  active: true
+  DuplicateCaseInWhenExpression:
+    active: true
+  EqualsAlwaysReturnsTrueOrFalse:
+    active: false
+  EqualsWithHashCodeExist:
+    active: true
+  ExplicitGarbageCollectionCall:
+    #LeakCanary - we want to trigger GC manually
+    active: false
+  InvalidRange:
+    active: false
+  IteratorHasNextCallsNextMethod:
+    active: false
+  IteratorNotThrowingNoSuchElementException:
+    active: false
+  LateinitUsage:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    excludeAnnotatedProperties: ""
+    ignoreOnClassesPattern: ""
+  MissingWhenCase:
+    active: false
+  RedundantElseInWhen:
+    active: false
+  UnconditionalJumpStatementInLoop:
+    active: false
+  UnreachableCode:
+    active: true
+  UnsafeCallOnNullableType:
+    active: false
+  UnsafeCast:
+    active: false
+  UselessPostfixExpression:
+    active: false
+  WrongEqualsTypeParameter:
+    active: false
+
+style:
+  active: true
+  CollapsibleIfStatements:
+    active: false
+  DataClassContainsFunctions:
+    active: false
+    conversionFunctionPrefix: 'to'
+  DataClassShouldBeImmutable:
+    active: false
+  EqualsNullCall:
+    #LeakCanary - enabled
+    active: true
+  EqualsOnSignatureLine:
+    #LeakCanary - enabled
+    active: true
+  ExplicitItLambdaParameter:
+    #LeakCanary - enabled
+    active: true
+  ExpressionBodySyntax:
+    active: false
+    includeLineWrapping: false
+  ForbiddenComment:
+    active: true
+    values: 'TODO:,FIXME:,STOPSHIP:'
+  ForbiddenImport:
+    active: false
+    imports: ''
+  ForbiddenVoid:
+    #LeakCanary - enabled
+    active: true
+    ignoreOverridden: false
+  FunctionOnlyReturningConstant:
+    active: false
+    ignoreOverridableFunction: true
+    excludedFunctions: 'describeContents'
+  LibraryCodeMustSpecifyReturnType:
+    active: false
+  LoopWithTooManyJumpStatements:
+    active: false
+    maxJumpCount: 1
+  MagicNumber:
+    #LeakCanary - disabled
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    ignoreNumbers: '-1,0,1,2'
+    ignoreHashCodeFunction: true
+    ignorePropertyDeclaration: false
+    ignoreConstantDeclaration: true
+    ignoreCompanionObjectPropertyDeclaration: true
+    ignoreAnnotation: false
+    ignoreNamedArgument: true
+    ignoreEnums: false
+    ignoreRanges: false
+  MandatoryBracesIfStatements:
+    #LeakCanary - enabled
+    active: true
+  MaxLineLength:
+    #LeakCanary - increased from 120 to 150
+    active: true
+    maxLineLength: 150
+    excludePackageStatements: true
+    excludeImportStatements: true
+    excludeCommentStatements: false
+  MayBeConst:
+    active: false
+  ModifierOrder:
+    active: true
+  NestedClassesVisibility:
+    active: false
+  NewLineAtEndOfFile:
+    #LeakCanary - disabled
+    active: false
+  NoTabs:
+    active: false
+  OptionalAbstractKeyword:
+    active: true
+  OptionalUnit:
+    active: false
+  OptionalWhenBraces:
+    active: false
+  PreferToOverPairSyntax:
+    active: false
+  ProtectedMemberInFinalClass:
+    active: false
+  RedundantVisibilityModifierRule:
+    active: false
+  ReturnCount:
+    active: false
+    max: 4
+    excludedFunctions: "equals"
+    excludeLabeled: false
+    excludeReturnFromLambda: true
+  SafeCast:
+    active: true
+  SerialVersionUIDInSerializableClass:
+    active: false
+  SpacingBetweenPackageAndImports:
+    active: false
+  ThrowsCount:
+    active: true
+    max: 2
+  TrailingWhitespace:
+    active: false
+  UnderscoresInNumericLiterals:
+    active: false
+    acceptableDecimalLength: 5
+  UnnecessaryAbstractClass:
+    active: false
+    excludeAnnotatedClasses: "dagger.Module"
+  UnnecessaryApply:
+    active: false
+  UnnecessaryInheritance:
+    active: false
+  UnnecessaryLet:
+    active: false
+  UnnecessaryParentheses:
+    active: false
+  UntilInsteadOfRangeTo:
+    active: false
+  UnusedImports:
+    active: false
+  UnusedPrivateClass:
+    active: false
+  UnusedPrivateMember:
+    active: false
+    allowedNames: "(_|ignored|expected|serialVersionUID)"
+  UseCheckOrError:
+    active: false
+  UseDataClass:
+    active: false
+    excludeAnnotatedClasses: ""
+  UseRequire:
+    active: false
+  UselessCallOnNotNull:
+    active: false
+  UtilityClassWithPublicConstructor:
+    active: false
+  VarCouldBeVal:
+    active: false
+  WildcardImport:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    excludeImports: 'java.util.*,kotlinx.android.synthetic.*'
diff --git a/docs/assets/adaptative_icon.sketch b/docs/assets/adaptative_icon.sketch
new file mode 100644
index 00000000..7978b281
Binary files /dev/null and b/docs/assets/adaptative_icon.sketch differ
diff --git a/docs/assets/icon_1024.png b/docs/assets/icon_1024.png
new file mode 100644
index 00000000..f15c7586
Binary files /dev/null and b/docs/assets/icon_1024.png differ
diff --git a/docs/assets/icon_512.png b/docs/assets/icon_512.png
new file mode 100644
index 00000000..0ca6bedf
Binary files /dev/null and b/docs/assets/icon_512.png differ
diff --git a/docs/assets/kanary-200px.png b/docs/assets/kanary-200px.png
new file mode 100644
index 00000000..ce9c9eb3
Binary files /dev/null and b/docs/assets/kanary-200px.png differ
diff --git a/docs/assets/kanary-large.png b/docs/assets/kanary-large.png
new file mode 100644
index 00000000..6bb4975c
Binary files /dev/null and b/docs/assets/kanary-large.png differ
diff --git a/docs/assets/leakcanary_shirt.psd b/docs/assets/leakcanary_shirt.psd
new file mode 100644
index 00000000..2273b193
Binary files /dev/null and b/docs/assets/leakcanary_shirt.psd differ
diff --git a/docs/assets/repository-open-graph.png b/docs/assets/repository-open-graph.png
new file mode 100644
index 00000000..86269e91
Binary files /dev/null and b/docs/assets/repository-open-graph.png differ
diff --git a/docs/assets/screenshot.png b/docs/assets/screenshot.png
new file mode 100644
index 00000000..0211a7fd
Binary files /dev/null and b/docs/assets/screenshot.png differ
diff --git a/docs/assets/shark.psd b/docs/assets/shark.psd
new file mode 100644
index 00000000..b9209a65
Binary files /dev/null and b/docs/assets/shark.psd differ
diff --git a/docs/assets/source_icon.png b/docs/assets/source_icon.png
new file mode 100644
index 00000000..d04aace6
Binary files /dev/null and b/docs/assets/source_icon.png differ
diff --git a/docs/assets/sticker.png b/docs/assets/sticker.png
new file mode 100644
index 00000000..4b08925a
Binary files /dev/null and b/docs/assets/sticker.png differ
diff --git a/docs/assets/vector_falling_canary.svg b/docs/assets/vector_falling_canary.svg
new file mode 100644
index 00000000..480d0847
--- /dev/null
+++ b/docs/assets/vector_falling_canary.svg
@@ -0,0 +1,16 @@
+<svg width="185" height="185" viewBox="0 0 185 185" fill="none" xmlns="http://www.w3.org/2000/svg">
+<g clip-path="url(#clip0)">
+<path d="M55.8327 80.944L68.1676 83.3835M59.6321 89.5079L62.4202 75.4109" stroke="#151C1F" stroke-width="4.257" stroke-linecap="round"/>
+<path fill-rule="evenodd" clip-rule="evenodd" d="M33.0396 88.6436L148.284 41.1702C148.308 41.1931 148.333 41.216 148.357 41.2389C147.773 76.5754 125.2 119.136 72.6948 132.558C66.2444 121.606 47.4716 97.5578 32.6694 89.9372C32.799 89.5158 32.9224 89.0844 33.0396 88.6436Z" fill="#F5BD14"/>
+<path d="M81.4818 31.7162L72.8251 55.9266L71.7247 54.5065C66.7399 48.0734 60.8251 42.4184 54.1748 37.7274L69.4736 20.6696L68.6881 39.2884L81.4818 31.7162Z" fill="#F86932"/>
+<circle cx="45.3062" cy="70.8628" r="35.1642" transform="rotate(-33.8126 45.3062 70.8628)" fill="#FFCC32"/>
+<path d="M44.2972 58.986L56.2444 55.066M51.8067 64.5881L47.3268 50.9342" stroke="#151C1F" stroke-width="4.257" stroke-linecap="round"/>
+<path fill-rule="evenodd" clip-rule="evenodd" d="M10.1416 71.2627C10.4815 113.278 38.6085 151.594 81.1309 162.988C113.627 171.695 146.704 162.582 170.003 141.637C159.823 142.304 149.364 141.343 138.964 138.556C113.428 131.714 93.0844 115.164 80.8316 93.9338L10.1416 71.2627Z" fill="#FFCC32"/>
+<path fill-rule="evenodd" clip-rule="evenodd" d="M175.463 56.9136L57.9672 97.0664C57.8158 97.5113 57.6587 97.9458 57.4956 98.3692C71.736 106.994 88.8027 132.282 94.4811 143.653C105.725 141.594 115.73 138.149 124.547 133.665C121.291 132.305 118.248 130.405 115.554 128.011L114.859 127.392C114.033 126.658 113.959 125.394 114.693 124.569C115.427 123.743 116.691 123.669 117.516 124.403L118.212 125.021C121.434 127.886 125.228 129.941 129.286 131.091C130.47 130.405 131.632 129.699 132.769 128.975C130.868 128.149 129.036 127.135 127.302 125.938L126.535 125.409C125.626 124.782 125.398 123.537 126.025 122.627C126.653 121.718 127.898 121.49 128.807 122.117L129.573 122.646C131.83 124.203 134.276 125.407 136.83 126.243C137.942 125.453 139.03 124.644 140.093 123.818C139.482 123.453 138.88 123.067 138.29 122.66L137.524 122.131C136.615 121.504 136.387 120.259 137.014 119.349C137.641 118.44 138.887 118.212 139.796 118.839L140.562 119.368C141.487 120.006 142.444 120.585 143.428 121.104C163.878 103.673 174.394 79.6305 176.271 57.779C176.004 57.4894 175.735 57.2009 175.463 56.9136Z" fill="#FFCC32"/>
+</g>
+<defs>
+<clipPath id="clip0">
+<rect width="185" height="185" fill="white"/>
+</clipPath>
+</defs>
+</svg>
diff --git a/docs/assets/vector_icon.afdesign b/docs/assets/vector_icon.afdesign
new file mode 100644
index 00000000..a30fcf97
Binary files /dev/null and b/docs/assets/vector_icon.afdesign differ
diff --git a/docs/assets/vector_icon.svg b/docs/assets/vector_icon.svg
new file mode 100644
index 00000000..9a17f0dc
--- /dev/null
+++ b/docs/assets/vector_icon.svg
@@ -0,0 +1,6 @@
+<?xml version="1.0" standalone="no"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;">
+    <image id="Container" x="33" y="44" width="443px" height="441px" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbsAAAG5CAYAAAAXoZoVAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAcMklEQVR4nO3dT4gkZ/nA8Wd6Zmc3mw1ZXEmCfxJCfgZJMDEHwaiRmEsQEolBAkET0Jw96CEXQQRFDyKePOXgIRhFBFFEzCFBEzRIFj0kIaJBCQZB8mezJG522Z3q38Gttqamqrq6u7q76u3PB4bu6Z3p6V525rvPW2/1bI3H4wCAlO2s+wF0YazYAEu1tbW1te7HsIitvnZi1oD19XkADF3bzvU5iL2KXVPg+vQ4Afivur71LXxrjd08cZv1dgDm0xCymT9v3fFbS+zqIld1c/E2oQNYraZGFf+sbRjXFb2Vxq4cuVnill+f9jkAdKdmSqv98/z9utsL7680eiuJ3bTINUWtTfAEEGBxbaazadfrLuu+xqqit9TYtY1c02Xx+iuvvBJ///vf44033ojXX39939upU6fi/PnzS3suAJvm6NGj8a53vStOnDhx4O2GG26Iyy67bF/UpgVvykS41OgtLXbF0LWJXPn6eDyOLMvixRdfjD/84Q/xzDPPxCuvvLKUxwrAbLa3t+PGG2+MW2+9NT7+8Y/HVVddVRu+ttFbZvCWEru60E2LW/7+yZMn46mnnoo//vGPcerUqc4fHwDduvbaa+NjH/tY3HHHHfH+97//QOzaRm9Zwes8dk2hqwpc8e2FF16IRx55JF588cVOHxMAqzEajeLOO++MBx54IE6cOHEgdnVTX/5+4Xqn0es0dnnoZo3cyy+/HD/84Q/jmWee6eyxALA+hw8fjnvvvTfuu+++OHr0aG30Wmxo6SR6ncWuKXTF4GVZNnn/9ddfj0cffTQef/zxyLKsk8cBQH9cfvnlcf/998fdd98dOzs7MRqN1jLldRK7cuiaJrk8di+88EJ885vfjDfffHPhrw9Av910003xta99LS6//PLK4LU4prdQ8BaOXVXoyteL01yWZfH444/HD37wA6cKAGyQq666Kr7xjW/ENddcsy94xesR1Ts4L16fO3gLxa4pdOXAjcfjuHDhQjzyyCPxi1/8Yu6vCcBwXXLJJfHwww/HRz/60QOhy9+P6D54c8euLnRVy5ZZlsXbb78d3/nOd+JPf/rTXF8PgDSMRqN48MEH47777psErjzpRXQbvLli1yZ0eeTG43GcPXs2Hn744fjb3/4289cCIE33339/fOELX5jEboZjeTPHbjTrJ0wLXR65/G1vby++//3vCx0A+/zkJz+Jp59+el8zql5opGLz48xT2kyxaxO6cvB++tOfxlNPPTXr4wIgcePxeDIMlQelvCX5x5WDN6vWsWuz67IYur29vXjmmWfi0UcfneuBAZC+c+fOxbe+9a14/fXXY29v78B0V3cO9qzT3czLmGVV01yWZfGPf/wjvve9781dYQA2w2uvvRbf/va349y5c5PglaO36HJmq9i13XmZR+/8+fPx3e9+N86ePTvjUwZgE/3lL3+Jxx57rHI5s4vgzbKMObms25Syt7cXe3t78cQTT8Q///nPmZ8sAJvrV7/6Vbz66qv7pru6jSuzmhq7umpWLV1mWRZnz56Nxx57bK4HA8DmOnfuXPz4xz9unOwiKl+acmoBG2NXt3xZdQAxn+x++ctfxhtvvLHI8wVgQz355JPx8ssvVwYvovp3oLZRG7um43TF94uhO336dPz85z9f4GkCsMmyLItHH320cikzD1+VadPdPCeVVz6ALMviZz/7WZw5c2bWuwSAiZMnT8YLL7xQu5xZNe1N03Y3Zu3GlPzy3Llz8cQTTyz2DAEgIn7zm9/UblKJ2H+ud65pupt2zO7A+3U7MZ977rl455135n5iAJD785//HOfOnTvwiirTNqvUqYxdsY5NU13x7dlnn+3sSQKw2c6cORPPP//8zKcf1E13TRtUDrxftwPzwoULcfLkyXmfEwAc8Oyzzx54RZWmE82bHIhduYrTjtVlWRYvvfRSnDp1qsOnCMCmO3ny5NRXVClqOu+u1TE7S5gArNqpU6fipZdeqvxtCAtNduVz66quF79I/sWff/75zp4cAOSee+65A92JmP3k8rkmu/JS5muvvdbFcwKAfV577bXaya5K3e1TN6hM24l54cKFePvttzt4SgCw36lTpxo3pjQcv9t3Q9UGlcovWBe9U6dO1f5yPQBYxOnTpw9siqwLXdNS5iR2bXZhVk13dmECsCz5QDXvKQe5upPKay/L46TYAbAsp0+frvzt5RHVQ1l+e1mb32d34LI42fl1PgAsS/4bdeZZuiyuWJZPPaj7hNr10rfeemumURIA2sjbknemKXjT4je6+IeVx+uK18vn2816jgMAzKrq/O7OjtkVv0j5/brz7QCgK3UDVvH9qo+r0+qYXdOOTABYhmLQyptT8tvbrjI2nlRe9UnlOy4Gz4QHQNfqdl+2+Zxcq5PKpx0QBIBlatpL0mZH5kynHtSdhgAAy9IUtrYNmhq7ui8qdACsUlN7Fj6pvOmLAsCyNZ0C19bUUw+6GB8BoAvzrio2vjZm1W2WLwFYpabuzH3MziuiANB3bU8mzxV/xU/ndw4AXVnkUNpcG1SEDoB1mLc/c+/GXOSLAsAsFu1NqxeCFjUA1qWLMwFaT3ZVr54CAKuySHcWWsYEgCEQOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTO4ABGI/H634IgyZ2AAMwHo8jy7J1P4zBEjuAARG8+YgdwMAI3uzEDqDnqo7XCd5sxA5goASvPbED6LmmnZiC147YAQyc4E0ndgA91vb8OsFrJnYAiRC8emIHkJAsy7zaSgWxA+ixecI1Ho8Fr0TsABIkePuJHUBPLRorwfsfsQNImOD9l9gB9FRXkRI8sQPYCJsePLED2BCbHDyxA+ihZUVpU4MndgAbZhODJ3YAPbTsGG1a8MQOYENtUvDEDqBnVhmgTQme2AFsuE0IntgB9Mw6wpN68MQOgIhIO3hiB8BEqsETO4Ae6UNoUgye2AFwQGrBEzsAKo3H48iybN0PoxNiB9AjfZymUgie2AEw1dCDJ3YAPdHHqa5oyMETOwBaG2rwxA6AmQwxeGIH0BN9X8YsGlrwxA6AuQwpeGIHwNyGEjyxA+iBIS1hlg0heGIHwML6HjyxA+iBIU92uT4HT+wA6Exfgyd2AHQqy7LeTapiB7BmfQtDF/r2K4LEDoCl6FPwxA6ApelL8MQOYM36EINl6kPwxA6ApVt38MQOYI3WPfGs0jqDJ3YArMy6gid2AKzUOoIndgBrtEnLmEWrDp7YAbAWqwye2AGwNqsKntgBrMmmLmGWrSJ4YgfA2i07eGIHsCYmu/2WGbydpdwrAMxB7ADYCMsInmVMgDWwhNms6yVNkx0AvZTHrovomewA6K3xeBx7e3sL34/YAayBZczVEjsAkid2ACRP7ABWzBLm6okdAMkTOwCSJ3YAK2YZc/XEDoDkiR3ACpnq1kPsAEie2AGQPLEDWCHLmOshdgAkT+wASJ7YAayIJcz1ETsAkid2ACRP7ABWxDLm+ogdAMkTO4AVMNWtl9gBkDyxAyB5YgewApYx10vsAEie2AGQPLEDWDJLmOsndgAkT+wASJ7YASyZZcz1EzsAkid2ACRP7ACWyBJmP4gdAMkTO4AlMtn1g9gBkDyxAyB5YgewJJYw+0PsAEie2AGQPLEDWBLLmP0hdgAkT+wASJ7YASyBJcx+ETsAkid2AEtgsusXsQMgeWIH0DFTXf+IHQDJEzsAkid2AB2zjNk/YgdA8sQOoEOmun4SOwCSJ3YAJE/sADpkGbOfxA6A5IkdQEdMdf0ldgAkT+wASJ7YAXTEMmZ/iR0AyRM7gA6Y6vpN7ABIntgBkDyxA+iAZcx+EzsAkid2AAsy1fWf2AGQPLEDWJDJrv/EDoDkiR3AAkx1wyB2ACRP7AAWYLIbBrEDIHliBzAnU91wiB0AyRM7gDmZ7IZD7ABIntgBzMFUNyxiB0DyxA5gDia7YRE7AJIndgAkT+wAZmQJc3jEDoDkiR3AjEx2wyN2ACRP7ABmYKobJrEDIHliBzADk90wiR0AyRM7gJZMdcMldgAtid1wiR0AyRM7gBZMdcMmdgAkT+wAWjDZDZvYAUwhdMMndgAkT+wApjDZDZ/YATQQujSIHQDJEzuABia7NIgdAMkTO4Aaprp0iB1ADbFLh9gBkDyxA6hgqkuL2AGQPLEDqGCyS4vYAZQIXXrEDoDkiR1AickuPWIHUCB0aRI7AJIndgAFJrs0iR3ARUKXLrEDuEjs0iV2ACRP7ADCVJc6sQMIsUud2AEbT+jSJ3YAJE/sgI1nskuf2AEbTeg2g9gBG03sNoPYARtL6DaH2AGQPLEDNpbJbnOIHbCRhG6ziB2wkcRus4gdsHGEbvOIHbBxxG7ziB2wUYRuM4kdsFHEbjOJHbAxhG5ziR2wMcRuc4kdsBGEbrOJHbARxG6ziR2QPKFD7ABIntgByTPZIXZA0oSOCLEDEid2RIgdkLAsy9b9EOgJsQOSZKKjSOyAJIkdRWIHJEfoKBM7IDliR5nYAUkROqqIHZCM8XgsdlQSOyAZQkcdsQOSIHQ0ETsgCWJHE7EDBs8rpTCN2AGDZqKjDbEDBk3saEPsgMGyfElbYgcMkomOWYgdMEhixyzEDhgcy5fMSuyAQTHRMQ+xAwbDa18yL7EDBkPomJfYAYPgOB2LEDug94SORYkd0GuWLumC2AG9ZUMKXRE7oJeEji6JHdBLQkeXxA7oHRtS6JrYAb0idCyD2AG9IXQsi9gBvSB0LJPYAWsndCyb2AFrJXSsgtgBayN0rMrOuh8AsHmcMM6qmeyAlRI61kHsgJUROtbFMiawEo7PsU4mO2DphI51M9kBS2PZkr4w2QFLIXT0ickO6JTI0UcmO6AzQkdfmeyAhYkcfSd2wELstGQIxA6Yi2mOIRE7YCYixxCJHdCKyDFkYgc0EjlSIHasXJZlsbW1FRExuaR/RI6UiB0rNxqNJjv48h+m4tcfIkeKxI612Nra2vcDNb9ejJ/wrY7AkTqxYy3ykNX9gC3+8DX1LUf5PxiQMrFjbaYFL1c19ZXvg/ZMcWwisWOt2gavqGr5UwDrmeBA7OiBeYJXJoD/I25wkNjRC10Er2xaAKveH5qq5wgcJHb0xjKCV1a+7/L7fYzhtMcMTCd29Er5lIRVaxuWZUZQzKB7YkfvFE867ytBgmHxm8rppdHIP02gO36i0FuCB3TFTxN6TfCALvhJQu/1YUckMGxiR+95UWhgUWLHIAgesAixYzAED5iX2DEoggfMQ+wYHMEDZiV2DJLYAbMQOwbLOXhAW35aMGiCB7ThJwWDJ3jANH5KkATBgzR19RtGOvkJMR6P/coT1k7wgDoL/3QQOfrELk1ITxedETuS4hw8SEfely6+p2f+TeX5F80vd3d3DwTPDxvWKf/35z9iMEzlQ2NHjx5d+D4bJ7titOoCdvz48YUfBHTNhAdpGI/HnXSm1TJm0w+N48eP26BCLwkeDN9oNIqdnf8uQi7y/bzQMbutra1J7CIsG9E/ggfDlA9R29vbB76H5/menil25eN1Ef9bxiwGT/ToE7GD4Sg2ZDwex+7ubkQs/n0892SXf+FDhw7FkSNHRI5ecw4eDEfek/F4HIcPH+7kPg/8BKia3qY5duxYZFkmePSa4EH/Fae6LMv27cRc5LDE5Lu/audl8Y7z6+UvtrW1FVdfffXkgRWLDH0jeNBfeTeyLJv05IMf/GDtx88Svrl3Yxajd8stt+yLnNDRZ4IH/VXuyJ133lk7jJVvazLzd33VtHfjjTfGzs7OvhoLHn1m0wr0S3lgyrIsLrvssrjkkksioj5ubb+Xp8auakmzfPvu7m584AMfOPBgBY++ckoC9E+5HzfccMOBASs36/fwzMuYdcfxbr755kmNTXcMgeBBP5Qnurwhd9111+Rj6vaNlP88v14208uFFd8fjUb73r/lllsiIg7ETvDoM8GDfijH7vDhw3HixInGwEV0sIzZtD5anuxGo1EcO3Ysrr/++skDNd0xFIIH61McjPb29ib9+NCHPhQRBye6qgmvaQPL1sUrtefZVX3itLd77rknIv473eUPWvAYAsGD9SlOdFmWxWg0igcffHCygjjtFLj8z5qMLn5Q5Ue1CV3xwVx99dVx880373vQgsdQCB6sVnnpMn+7/fbbY2dnp7Y1uaYJr2zfZFd3MnnVHRe/8Gg0mrz/2c9+Nkaj0b7pLg8e9J3YwWqUQ5f34vDhw3HvvfdWtqZpKXOa1rsxq0JXFbwTJ07ErbfeeuAJmO4YCiedw/IVY1fsxF133XVgiKoL3iym7sactpRZfkCj0SjuuuuuOHLkyIHgmfAYCsGD5akKXZZlcezYsbj99ttbha7NZpWi4mtjbhWuR/F6U+TKoct3Zt5zzz2T3TX5m+AxJIIH3SsvXeZvEREPPfTQvpZU9WWWwBW71njqQd0xvKoHUH679dZb47bbbjvwhCxpMiSCB92pCl3ehM985jNx3XXX1TalzUTXFL+ppx7s++DSMbppwbvnnnvi+uuvPzDhFZ8g9J1NK7C4uokuy7L48Ic/HJ/61Kcae1IVvogOTyov17NqU8r29nZsb2/vu769vR07OzvxxS9+Md797ndXPkHBYwickgDzq9p1WezAlVdeGQ888EBlT+qO3eUrLrMEr3zqwVbp/amnGxTfqh7kJZdcEg899NBkw8re3l5cuHBB9BgUwYPZTQvdkSNH4itf+cq+IanclLrJru6E81y5Z5WTXdU3dfmYXV3sytPdaDSKK664Ir70pS/FpZdeOnmiefAuXLjgtTQZBMGD9so7Li9cuDB5y0P31a9+NXZ3d/c1o9yPcgSrljDLmyqrtHoh6KolzDbLmMW3a6+9Nr785S/HVVdddWDCK056gkefCR40K09yxcjlP+OvuOKK+PrXvx4nTpyobUbdcmbVSmPE9KXMrXJYxhdvyG+vezmX4oSWv50/f37fW/G2/Pq5c+fiRz/6Ubz44osHgrnoAUhYFf8pg/9p04v89ptuuik+//nPx87OTuzs7MShQ4cml8W34m07OzuTfSBVS5s1097+w3JV37DF4FX9nqHiiYDF2FXFrer63t5ePP744/G73/0uxuNx662mxScC6yZ4bLJi4PLL/JBU3YuJfPrTn45PfvKTk9CVg1YVu/zjyhNf1QnnEZPVlwOh2Jn2hOpOMB+NRvtCtb29HVmWxfb29r44lq/n7rzzznjPe94Tv/71r+PNN9+cfEzTQUjRo2/KsVvVv0uRZV2qIlc1zRV//h87dizuv//+uO666/aFrhixqqDVDUER1b8Boen7r3Kyu/gExuUn07SzpmrCq7osr9+eP38+fv/738fTTz8dZ86cqTwmWF6jLT4p0WPdsiw7cNss/y6FiyGoi1x5oitGbnd3N+6444647bbb9gWtagmzPMnVLV/WTXVNOzEjpsSu6olVjal1wSsvX1a95Z979uzZePLJJ+PZZ5+N8+fP5w+41XQnfKxbVfBg6MqBy69PexuNRvGRj3wk7r777srzr8tBqwpeOY7FvR1NG1SqQhfRInZ1T65us0rTlNcUu/x+Tp8+Hb/97W/jr3/9a5w+fbr2pWBm2XIKq2BCY+hq9nBMvcyv7+7uxv/93//F5z73uX2nFIxGowNTXTl2VaErLm222c9RF7qIhthdfBKV013T7sxi7PLrdbErfnz5tdKyLIt//etf8dxzz8VLL70Ur776aozH48a4iR3rZsIjReXJLre1tRWXXnppXHfddfGJT3wirrzyysoXGilPdfn1cuzKf15cuqyLXf44Ll7WRqBxg8rW1tbWeDweb21tVYam+CK5xSBub2/vu738ufnnFx9slmWT9/PYve9974v3vve9kWVZvPnmm/H888/Hv//97/jPf/4Tb7/9dpw5cybeeeedyStmQx+Y8PzHMzWHDh2Ko0ePxtGjR+PYsWNx2WWXxTXXXBM33HBDHDp0qPbFRupiV/fWZnPKvJsVGye7iNmWM8sTXtWUV/V+eSmz/Mv8ipcR//vfc/7Q3nrrrTh9+vTkXI6K59DqLwO6UPXvcJYf/rMszYsKXakaSI4cORLHjx+P3d3dykNJxWNnTS8fWXUMrs2uzGmxm7YppWjqqQfT/kKK013bzys/2PyJ7O3t7bssb2HNL/OvmQf3+PHjcfnll0/uX9wAFtO0EXBa7KpeVaspeMWPaTPRVYR56v/62pxnt5VPd1XLmfn7VUuadX9xTX9J+bl2VedrlF9Dc9qBUwBmV7cBsOqt/HO8OJHl8aqb3KpCV/U6mFN247da3mg12TUFLw9T/mfTJr3yX9CisWsKnegBtFe3hF6MTP4zvnwKQNMSZjl4dUuW5dAVL2seb+t1/NbLmMXglZUjVfXAmv5XUPwL2tvbm1xWnYnfdrorEj2AZlXdqDtOV/czfNpSZtUUV7fjsuo8ulk3pRTNdMyubndmfhwtD115a+rW1lbs7e21Cl1+P/nLj9UFL/+65ejltxeJHUCzqg0q+WXT8bq6ya4ueOX4lT+nvPJXt3w5q5k3qBT/IuqCF1G9caX8wIuvhZmHLo9c+UVEy8ErT3WWMQEWN+/xuvyyKmDTLquWLqeFbpYlzIj5dmNuRfz3lIS2wav7i8oDVjxel7+VJ7umY3Y2qAB0p2ITyIHrdfsuqia8umXKNrsuuwhdxAKTXfEvpSp4VRGqi13dppSqJcy6pczi15nyqjCLPmWAQZvWirbTXdMmlbZvVeEsfr2KxzHXOubUk8qnqXpJsfyyHKaqKa0pblWhm2eDSuGxLvRcAVIxa/CmLWVWxW7abVX3Ufxa5cc5b+giOpjsCg+i8mXBImIy6eVPKP+44kuEFSe7cgyrohlxcKqzMQVgfk2bVPLLWSa8utvaHpvrKnQR3Sxj7juGd/H6gfG3ahorhq94vK9qils0dMIHUK0ucsXrs054VZfFZcqmaa7iMSz8unidTXZFVcfxqp5EHqliDIvBKx77swuTFJT/bXbwPQxLUTdl1U1jVZNa06aTVYYuooNjdmXjwh2WA1QVqbpz5preive9yPKlKAKbpm07Zpnuqm6bthu/+Gd1j62r0EUsIXYR9cHL36+bzOomt2nTXNVzEDKA+bQ5dpdfNgWv7rbi7VVfs8vITe5zWVEYV9xx06RXvK3NRDht96XYAcynqjU1m0Yqp7Sm61X3Ubi+tHX9pcUuV45e06TX9v3y/diMAtCtWTetlC+bPr7mPpd6AHvpscu1mfTa3NZ0e9X9AjC7pumu6s/nCVzhtqXv1FpZ7HJtJr26P2vz523+DICD2jRnWvCabq+4r5VtR1557HLTJr2m29s8ZrEDmM0s7ZkWtKb7WmXkJl9z3VGoil7hz5o+b9r9zv+gADbQtAbNOvkVblv7CaVrj13ZvPEDYHVahm/tkcv1LnZlTfEDoD/6FLey3seujggCrFafYzbNYGMHAG39P8QjHPIeCPK8AAAAAElFTkSuQmCC"/>
+    <path id="Canary Badge" d="M112.189,145.49L254.837,81.3501L396.288,145.49C396.288,145.49 396.862,207.984 396.288,231.803C400.997,350.37 312.745,416.946 254.837,430.897C196.973,416.761 109.794,350.592 112.189,231.803C112.756,203.667 112.189,145.49 112.189,145.49ZM175.089,342.14C175.089,342.14 184.466,327.557 200.474,320.28C204.922,315.034 207.831,307.409 215.292,300.115C219.468,296.033 226.552,291.174 233.166,288.656C239.785,286.137 247.648,284.843 255,285C262.352,285.157 268.152,286.319 277.281,289.599C300.356,298.133 328.246,333.945 334.028,349.404C315.038,361.253 296.986,374.343 277.281,397.842C273.2,395.993 262.831,392.31 245.929,394.232C225.332,398.578 205.605,369.407 206.507,353.455C194.408,348.947 175.089,342.14 175.089,342.14ZM239.502,332.155C236.224,332.127 234.144,330.44 233.732,328.884C233.319,327.329 235.679,323.517 237.026,322.821C244.051,319.192 251.916,319.735 251.916,319.735C251.916,319.735 254.299,332.28 239.502,332.155ZM238.929,221.803L270.281,221.803L270.281,254.418L238.929,254.418L238.929,221.803ZM238.929,136.356L270.281,136.356L270.281,205.834L238.929,205.834L238.929,136.356Z" style="fill:rgb(253,237,0);"/>
+</svg>
diff --git a/docs/blog-articles.md b/docs/blog-articles.md
new file mode 100644
index 00000000..8a2ce3f4
--- /dev/null
+++ b/docs/blog-articles.md
@@ -0,0 +1,8 @@
+* [Memory Leaks in Android](https://www.raywenderlich.com/4690472-memory-leaks-in-android)
+* [Detect memory leaks in your instrumentation tests using LeakCanary](https://proandroiddev.com/detecting-memory-leaks-in-your-instrumentation-tests-using-leakcanary-1268e911d5ce)
+* [9 ways to avoid memory leaks in Android](https://android.jlelse.eu/9-ways-to-avoid-memory-leaks-in-android-b6d81648e35e)
+* [LeakCanary - Deobfuscation Feature Explained](https://www.polidea.com/blog/leakcanary-deobfuscation-feature-explained/)
+* [LeakCanary - An in-depth example of Android memory-leaks in MVP architecture](https://github.com/tricknology/MVPMemoryLeak/wiki)
+* [Detecting memory leaks in Android applications](https://dropbox.tech/mobile/detecting-memory-leaks-in-android-applications)
+
+Your article should be here, please update this list! Any technical level welcome.
diff --git a/docs/changelog.md b/docs/changelog.md
new file mode 100644
index 00000000..8c76d0cf
--- /dev/null
+++ b/docs/changelog.md
@@ -0,0 +1,1568 @@
+
+# Change Log
+
+Please thank our [contributors](https://github.com/square/leakcanary/graphs/contributors) ðŸ™ ðŸ™ ðŸ™.
+
+I've started working on LeakCanary 3.0 so new 2.x releases only contain bug fixes and new known leak patterns.
+
+## Version 2.13 (2024-01-01)
+
+* ðŸ› [#2565](https://github.com/square/leakcanary/issues/2565) Fix AndroidX Fragments incorrectly marked as leaking if detached but not destroyed.
+* ðŸ’¥ [#2568](https://github.com/square/leakcanary/issues/2568) Fixed missing `RECEIVER_EXPORTED` flag when calling `registerReceiver()` on API 34+.
+* ðŸ”¨ [#2555](https://github.com/square/leakcanary/issues/2555) Binder stubs are now called out in leak traces.
+* ðŸ¤ [#2601](https://github.com/square/leakcanary/pull/2601) Added several known manufacturer & framework leaks.
+
+## Version 2.12 (2023-06-29)
+
+* ðŸ’¥ [#2527](https://github.com/square/leakcanary/issues/2527) `LifecycleRegistry` in `androidx.lifecycle:lifecycle-runtime` was migrated to kotlin and its `mState` field name changed to `state` which broke LeakCanary expectations.
+* ðŸ¤ [#2545](https://github.com/square/leakcanary/pull/2545) Added several known manufacturer & framework leaks.
+
+
+## Version 2.11 (2023-05-17)
+
+* ðŸ› [#1764](https://github.com/square/leakcanary/issues/1764) Ignore phantom classes that were unloaded than reloaded (long time LeakCanary bug).
+* ðŸ› [#2471](https://github.com/square/leakcanary/issues/2471) Fix LeakCanary introducing a weird leak in Google's CI infra.
+* ðŸ› [#2496](https://github.com/square/leakcanary/issues/2496) Fix broken ViewModel leak detection
+
+## Version 2.10 (2022-11-10)
+
+### Experimental Neo4j heap dump exploration
+
+`shark-cli` has a new experiment `neo4j` command that will convert a heap dump into an embedded Neo4j database and then open Neo4j Browser to explore the heap dump.
+
+```
+brew install leakcanary-shark
+
+shark-cli --process com.example.app.debug neo4j
+```
+
+![Neo4J heap dump](https://user-images.githubusercontent.com/557033/200693468-aa783bb4-9a5a-4a41-8b92-582d44b31b92.png)
+
+### Other bug fixes and improvements ðŸ›ðŸ”¨
+
+* ðŸ¤ [#2440](https://github.com/square/leakcanary/pull/2440) Add Android 13 `POST_NOTICICATIONS` permission as well as a new `LeakCanary.Config.showNotifications` config to disable notifications entirely.
+* ðŸ¤ [#2416](https://github.com/square/leakcanary/pull/2416) Add Android 13 monochrome icon.
+* ðŸ’¥ [#2371](https://github.com/square/leakcanary/issues/2371) Fix db crash when navigating heap dump screen.
+* ðŸ› [#2393](https://github.com/square/leakcanary/issues/2393) Allow LeakCanary to be defined as an AndroidX Startup dependency.
+* ðŸ’¥ [#2430](https://github.com/square/leakcanary/issues/2430) Fix ShortcutManager crash on Android TV.
+* ðŸ’¥ [#2382](https://github.com/square/leakcanary/issues/2382) Fix heap dump close crash.
+
+This list reflects only a subset of all changes. For more details, see the [2.10 Milestone](https://github.com/square/leakcanary/milestone/25) and the [full diff](https://github.com/square/leakcanary/compare/v2.9.1...v2.10).
+
+## Version 2.9.1 (2022-04-20)
+
+### Preface
+
+What are some things you'd like to see in a future LeakCanary 3 version? Tell me [on Twitter](https://twitter.com/Piwai)!
+
+Some ideas I'm playing with:
+
+* Moving heap analysis leak visualisation to a separate single app (written with Compose!) available on the PlayStore.
+* Bumping Okio to 3.0
+* Multiplatform heap analysis? Analyze a JVM heap dump in your browser?!
+* Visualize the heap dominators / retained size as a treemap.
+* A backend for LeakCanary?
+
+Anyway, that's still very much the future, let's talk about what's in `2.9.1` now!
+
+### New metrics in heap analysis metadata
+
+I built LeakCanary to help fix leaks, but in doing so I accidentally wrote a fairly flexible heap dump parser. Since we're parsing the heap to find leaks anyway, we might as well report additional interesting metrics. Here's what you'll now see in the heap dump metadata:
+
+* Class count: count of loaded classes
+* Instance count
+* Primitive array count
+* Object array count
+* Thread count
+* Heap total bytes
+* Bitmap count
+* Bitmap total bytes
+* Large bitmap count (bitmaps with more pixels than 1.1x the pixels on screen)
+* Large bitmap total bytes
+* SQLiteDatabase in memory (open or closed, as well as their file path)
+
+This is just a first pass, feedback and ideas welcome!
+
+### Performance improvements
+
+The heap analysis now traverses the heap dump using `RandomAccessFile` instead of `FileChannel.transferTo()` and is now 40% faster on API 23 and 20% faster on newer APIs.
+Also, sticky class GC roots are now deduplicated, which great reduces the memory footprint of LeakCanary on API 23 ([#2324](https://github.com/square/leakcanary/pull/2324)). You can read about the related investigation [on py.hashnode.dev](https://py.hashnode.dev/of-sharks-and-heaps-of-sticky-marshmallows).
+
+### Breaking change:  FailTestOnLeakRunListener deleted
+
+`FailTestOnLeakRunListener`, `FailTestOnLeak` and `FailAnnotatedTestOnLeakRunListener` were deprecated in LeakCanary 2.8 as they rely on hacking the Android Test library internals which have since changed, and have been replaced by `LeakAssertions.assertNoLeak()` and the `DetectLeaksAfterTestSuccess` test rule. I was initially planning of keep these around, but as I tried to increase API level coverage in LeakCanary I needed to upgrade the Android Test library to a more recent version, and the hacks now had compilation errors. So they're gone: [#2282](https://github.com/square/leakcanary/commit/7152d6e2f8bea866e3bd5397b882d5098bed7d8b). If you can't use the test rules just yet, you're welcome to copy paste the listener implementations in your own codebase.
+
+### Other bug fixes and improvements ðŸ›ðŸ”¨
+
+* ðŸ’¥ [#2367](https://github.com/square/leakcanary/pull/2367) Fixed `AndroidLeakFixes.FLUSH_HANDLER_THREADS` (`HandlerThread` can have a null `Looper`).
+* ðŸ’¥ [#2286](https://github.com/square/leakcanary/issues/2286) Update Curtains to include Proguard rules and prevent `WindowCallbackWrapper` crashes.
+* ðŸ’¥ [#2294](https://github.com/square/leakcanary/issues/2294) Fixed `WindowDelegateCallback.onMenuOpened()` crash.
+* ðŸ¤ [#2328](https://github.com/square/leakcanary/pull/2328) Fixed ToastEventListener leak. Sorry ðŸ˜¬!
+* ðŸ’¥ [#2310](https://github.com/square/leakcanary/issues/2310) Fixed crash when using WorkManager < 2.1.0.
+* ðŸ’¥ [#2342](https://github.com/square/leakcanary/issues/2342) Fixed crash when `HashSet.map` is null (which isn't supposed to happen, oh well, Android ðŸ¤·â€â™‚ï¸).
+* ðŸ› [#2117](https://github.com/square/leakcanary/issues/2117) Fixed StrictMode disk read violations.
+* ðŸ’¥ [#2351](https://github.com/square/leakcanary/pull/2351) Fixed a race causing a startup crash.
+* ðŸ’¥ [#2315](https://github.com/square/leakcanary/issues/2315) Fixed crash when using Okio 1.14.
+* ðŸ› [#2182](https://github.com/square/leakcanary/issues/2182) Fixed multi rescheduling of `BackgroundListener$checkAppInBackground`.
+* ðŸ’¥ [#2360](https://github.com/square/leakcanary/issues/2360) Fixed SQLiteOpenHelper concurrent creation crash.
+
+This list reflects only a subset of all changes. For more details, see the [2.9 Milestone](https://github.com/square/leakcanary/milestone/23) and the [full diff](https://github.com/square/leakcanary/compare/v2.8.1...v2.9.1).
+
+
+## Version 2.8.1 (2022-01-06)
+
+This is a bugfix release, a quick follow up to `2.8` which had a few major issues ðŸ˜…. If you haven't yet, you should definitely read the `2.8` changelog.
+
+### Thanks
+
+Please thank
+[@dicosta](https://github.com/dicosta),
+[@Goooler](https://github.com/Goooler),
+[@plnice](https://github.com/plnice),
+[@preetha1326](https://github.com/preetha1326)
+for their contributions, bug reports and feature requests ðŸ™ ðŸ™ ðŸ™.
+
+### Crash fixes ðŸ’¥ðŸ’¥ðŸ’¥
+
+This patch release fixes not 1, not 2, but 3 crashes!
+
+* ðŸ’¥ [#2268](https://github.com/square/leakcanary/pull/2268) WorkManager expedited request crashes before API 31.
+* ðŸ’¥ [#2270](https://github.com/square/leakcanary/issues/2270) Updating `LeakCanary.config` crashes when `AppWatcher` is not installed.
+* ðŸ’¥ [#2271](https://github.com/square/leakcanary/issues/2271) Analysis failure on API 25 because `HashMap$Entry` became `HashMap$HashMapEntry` (on API 25) before it finally changed to `HashMap$Node`.
+
+For more details, see the [2.8.1 Milestone](https://github.com/square/leakcanary/milestone/24) and the [full diff](https://github.com/square/leakcanary/compare/v2.8...v2.8.1).
+
+## Version 2.8 (2022-01-04)
+
+Note: please update to `2.8.1` instead.
+
+### Preface
+
+The last release was 9 months ago. What happened?! Well, soon after releasing LeakCanary 2.7, I had my 2nd baby, a wonderful daughter ðŸ˜. Having 2 young kids leaves a lot less time available for Open Source work... but it's worth it!
+
+â€• [P.Y.](https://twitter.com/Piwai)
+
+### Thanks
+
+Please thank
+[@aaronweihe](https://github.com/aaronweihe),
+[@alhah](https://github.com/alhah),
+[@Andre-max](https://github.com/Andre-max),
+[@AoraMD](https://github.com/AoraMD),
+[@BraisGabin](https://github.com/BraisGabin),
+[@breezenan](https://github.com/breezenan),
+[@Goooler](https://github.com/Goooler),
+[@iliaskomp](https://github.com/iliaskomp)
+[@Jeff11](https://github.com/Jeff11),
+[@jmnwong](https://github.com/jmnwong),
+[@IdioticMadman](https://github.com/IdioticMadman),
+[@keyur1sst](https://github.com/keyur1sst),
+[@lchen8](https://github.com/lchen8),
+[@leinardi](https://github.com/leinardi),
+[@Maragues](https://github.com/Maragues),
+[@mars885](https://github.com/mars885),
+[@mateuszkwiecinski](https://github.com/mateuszkwiecinski),
+[@matiash](https://github.com/matiash),
+[@maxxx](https://github.com/maxxx),
+[@preetha1326](https://github.com/preetha1326),
+[@SimonMarquis](https://github.com/SimonMarquis),
+[@slavonnet](https://github.com/slavonnet),
+[@Sonphil](https://github.com/Sonphil),
+[@summerlyr](https://github.com/summerlyr),
+[@SUPERCILEX](https://github.com/SUPERCILEX),
+[@utwyko](https://github.com/utwyko),
+[@ZacSweers](https://github.com/ZacSweers),
+[@ziranshang](https://github.com/ziranshang),
+[@zoltish](https://github.com/zoltish)
+for their contributions, bug reports and feature requests ðŸ™ ðŸ™ ðŸ™.
+
+### Improved support for data structure internals
+
+ðŸ¤“ Inspired [by Android Studio](https://twitter.com/RalucaSauciuc/status/1343800565352996871), LeakCanary's node discovery during heap graph traversal is now abstracted away. This allows overlaying logical structure over common data structure internals.
+
+ðŸ˜… WHAT?!
+
+ðŸ‘‰ This means we can make known data structures look more like their APIs than their internals. For example, developers tend to think of setting a `HashMap` entry as `map["key"] = value` rather than `map.table[hash("key")].next.next.next = Node(value)`, which is what LeakCanary would previously show in its leak traces.
+
+Let's look at a `HashMap` example:
+
+```kotlin
+class CheckoutController {
+
+  val tabs = HashMap<String, Tab>()
+
+  fun addItemsTab(tab: Tab) {
+    tabs["ItemsTab"] = tab
+  }
+}
+```
+
+If the `Tab` instance holds on to a view, we might see a leak trace that would look like this:
+
+```
+â”‚ ...
+â”œâ”€ com.example.CheckoutController instance
+â”‚    â†“ CheckoutController.tabs
+â”œâ”€ java.util.HashMap instance
+â”‚    â†“ HashMap.table
+â”œâ”€ java.util.HashMap$Node[] array
+â”‚    â†“ HashMap$Node[42]
+â”œâ”€ java.util.HashMap$Node instance
+â”‚    â†“ HashMap$Node.next
+â”œâ”€ java.util.HashMap$Node instance
+â”‚    â†“ HashMap$Node.value
+â”œâ”€ com.example.Tab instance
+â”‚ ...
+```
+
+With the improved data structure support, the leak trace is much clearer (also note how the `ItemsTab` string key is now surfaced):
+
+```
+â”‚ ...
+â”œâ”€ com.example.CheckoutController instance
+â”‚    â†“ CheckoutController.tabs
+â”œâ”€ java.util.HashMap instance
+â”‚    â†“ HashMap[ItemsTab]
+â”œâ”€ com.example.Tab instance
+â”‚ ...
+```
+
+Another benefit of this change is that leak signatures become less dependent of the runtime, and therefore are more consistent. This is especially true for any data structure that relies on a linked list (`HashMap`, `LinkedList`, `MessageQueue`, ...). Currently LeakCanary supports a limited set of common data structures from Apache Harmony, Open JDK, and the Android SDK. Let me know what else you need!
+
+### ObjectAnimator leaks
+
+LeakCanary will now detect leaks that trigger when forgetting to cancel `ObjectAnimator`. This new feature is enabled by the node discovery changes described above!
+
+Let's say you accidentally start an infinite `ObjectAnimator` and never cancel it, like so:
+
+```kotlin
+class ExampleActivity : Activity() {
+
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+    setContentView(R.layout.main_activity)
+    findViewById<Button>(R.id.button).setOnClickListener { view ->
+      ObjectAnimator.ofFloat(view, View.ALPHA, 0.1f, 0.2f).apply {
+        duration = 100
+        repeatMode = ValueAnimator.REVERSE
+        repeatCount = ValueAnimator.INFINITE
+        start()
+      }
+    }
+  }
+}
+```
+
+In previous releases, LeakCanary would detect that the animated view is leaking but it wouldn't be able to find the leak and instead would report it as an unreachable object: _An unreachable object is still in memory but LeakCanary could not find a strong reference path from GC roots._
+
+LeakCanary now reports the leak and adds animator state information, helping detect and fix any infinite `ObjectAnimator`.
+
+```
+â”¬â”€â”€â”€
+â”‚ GC Root: Thread object
+â”‚
+â”œâ”€ java.lang.Thread instance
+â”‚    Leaking: NO (the main thread always runs)
+â”‚    Thread name: 'main'
+â”‚    â†“ Thread.threadLocals
+â”‚             ~~~~~~~~~~~~
+...
+â”œâ”€ android.animation.ObjectAnimator instance
+â”‚    Leaking: UNKNOWN
+â”‚    mListeners = null
+â”‚    mPropertyName = null
+â”‚    mProperty.mName = alpha
+â”‚    mProperty.mType = java.lang.Float
+â”‚    mInitialized = true
+â”‚    mStarted = true
+â”‚    mRunning = true
+â”‚    mAnimationEndRequested = false
+â”‚    mDuration = 100
+â”‚    mStartDelay = 0
+â”‚    mRepeatCount = INFINITE (-1)
+â”‚    mRepeatMode = REVERSE (2)
+â”‚    â†“ ObjectAnimator.mTarget
+â”‚                     ~~~~~~~
+â•°â†’ android.widget.Button instance
+     Leaking: YES (View.mContext references a destroyed activity)
+```
+
+To learn more, see this AOSP issue: [ObjectAnimator.mTarget weak ref creates memory leaks on infinite animators](https://issuetracker.google.com/issues/212993949).
+
+### Leak detection in tests
+
+Previous releases of `leakcanary-android-instrumentation` introduced a `FailTestOnLeakRunListener` which could run leak detection after each UI tests. Unfortunately `FailTestOnLeakRunListener` relied on a hack around `androidx.test` internals to report failures. The internals keep changing with every `androidx.test` release and breaking `FailTestOnLeakRunListener` ðŸ˜­.
+
+`FailTestOnLeakRunListener` is now deprecated (ðŸ‘‹) and replaced by the `DetectLeaksAfterTestSuccess` test rule, which you can add to your test like any normal test rule.
+
+Additionally, you can call `LeakAssertions.assertNoLeak()` from anywhere in your instrumentation tests. You can also annotate tests with `@SkipLeakDetection` (for that to work you'll also need to set up the `TestDescriptionHolder` test rule).
+
+```kotlin
+class CartTest {
+  @get:Rule
+  val rules = RuleChain.outerRule(TestDescriptionHolder)
+    .around(DetectLeaksAfterTestSuccess())
+    .around(ActivityScenarioRule(CartActivity::class.java))
+
+  @Test
+  fun addItemToCart() {
+    // ...
+  }
+
+  @SkipLeakDetection("See #1234")
+  @Test
+  fun removeItemFromCart() {
+    // ...
+  }
+}
+```
+
+### Android 12
+
+Hopefully this time we fixed everything that Android 12 broke: missing `exported:true` tags, missing pending intent flags, and `ForegroundServiceStartNotAllowedException` crashes. If not, let us know! Can't wait for Android 13 to break everything again ðŸ¤¬.
+
+### WorkManager
+
+Running an Android Service without crashing (`ForegroundServiceStartNotAllowedException`...) is becoming harder with every release of Android, so I got rid of the LeakCanary heap analyzer service! Instead, LeakCanary leverages WorkManager if you already have it as a dependency. If you don't use WorkManager, then LeakCanary will fall back to using a simple thread.
+
+Note: I recommend using at least [WorkManager 2.7.0](https://developer.android.com/jetpack/androidx/releases/work#2.7.0) as it adds the `WorkRequest.Builder.setExpedited()` API which LeakCanary leverages if available.
+
+### Multi process
+
+Switching to WorkManager also impacts the LeakCanary multi process approach, which now leverages WorkManager remote jobs. Blog on how I got this working: [WorkManager multi-process for libraries](https://py.hashnode.dev/workmanager-multi-process-for-libraries).
+
+Multi process is harder to get right so you should only use this if LeakCanary frequently runs out of memory while performing the heap analysis. Here are the updated set up steps:
+
+1) Add the `leakcanary-android-process` dependency and **keep the `leakcanary-android` dependency**.
+
+```groovy
+dependencies {
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.8'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android-process:2.8'
+}
+```
+
+2) Skip the initialization code in the `Application` class
+
+```kotlin
+class ExampleApplication : Application() {
+
+  override fun onCreate() {
+    if (LeakCanaryProcess.isInAnalyzerProcess(this)) {
+      return
+    }
+    super.onCreate()
+    // normal init goes here, skipped in :leakcanary process.
+  }
+}
+```
+
+That's it! Note that event listeners (see below) related to the analysis will fire in the remote process.
+
+### AndroidX App Startup
+
+LeakCanary now optionally supports the [AndroidX App Startup library](https://developer.android.com/topic/libraries/app-startup). All you need to do is replace the `leakcanary-android` dependency with `leakcanary-android-startup`:
+
+```groovy
+dependencies {
+  // Remove the normal leakcanary-android dependency
+  // debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.8'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android-startup:2.8'
+}
+```
+
+Note 1: `leakcanary-android` adds the code for automatic installl to `leakcanary-android-core`. If you're calling `AppWatcher.manualInstall()`, you can depend directly on `leakcanary-android-core` instead of `leakcanary-android`, and you won't need the disable any automatic install.
+
+Note 2: the same principle applies to `leakcanary-object-watcher-android`: it depends on `leakcanary-object-watcher-android-core` and adds automatic install, while `leakcanary-object-watcher-android-startup` leverages the App Startup library. Same for `plumber-android`, `plumber-android-core` and  `plumber-android-startup`.
+
+### Event listeners
+
+`LeakCanary.Config` has a new `eventListeners` field allowing you to react to LeakCanary's lifecycle. If you want to customize this, you most likely should be keeping the default list of listeners and add or remove from it.
+
+For example, if you want to disable the LeakCanary toast:
+
+```kotlin
+LeakCanary.config = LeakCanary.config.run {
+  copy(
+    eventListeners = eventListeners.filter {
+      it !is ToastEventListener
+    }
+  )
+}
+```
+
+If you want to upload heap analysis results:
+
+```kotlin
+LeakCanary.config = LeakCanary.config.run {
+  copy(
+    eventListeners = eventListeners + EventListener { event ->
+      if (event is HeapAnalysisSucceeded) {
+        // Upload event.heapAnalysis
+      }
+    }
+  )
+}
+```
+
+Note: `Leakcanary.Config.onHeapAnalyzedListener` still works but is now deprecated.
+
+Feedback welcome on this new API!
+
+### Other bug fixes and improvements ðŸ›ðŸ”¨
+
+* [#2096](https://github.com/square/leakcanary/issues/2096) Opening / sharing heap dump files now supports LeakCanary as an option.
+* [#2210](https://github.com/square/leakcanary/issues/2210) First Compose dedicated object inspectors!
+* [#2121](https://github.com/square/leakcanary/pull/2121) Support for customizing the heap dumper.
+
+This list reflects only a subset of all changes. For more details, see the [2.8 Milestone](https://github.com/square/leakcanary/milestone/22) and the [full diff](https://github.com/square/leakcanary/compare/v2.7...v2.8).
+
+
+## Version 2.7 (2021-03-26)
+
+Please thank
+[@chao2zhang](https://github.com/chao2zhang),
+[@ihrupin](https://github.com/ihrupin),
+[@jzbrooks](https://github.com/jzbrooks),
+[@msfjarvis](https://github.com/msfjarvis),
+[@reneargento](https://github.com/reneargento),
+[@Unpublished](https://github.com/Unpublished)
+for their contributions, bug reports and feature requests ðŸ™ ðŸ™ ðŸ™.
+
+### Finer grained root view watching
+
+In version 2.6, LeakCanary added detection of root views retained after  `View.onDetachedFromWindow()`. This helps find more leaks, but unfortunately some Android widgets keep a detached root view around to reattach it later (e.g. spinner). App developers also sometimes do the same with dialogs, keeping a single instance around and calling `show()` and `hide()` as needed. As a result, LeakCanary would report leaks that were actually not leaks.
+
+In version 2.7, the default behavior changed: LeakCanary will continue to detect leaks of toasts, but will ignore root views created by a PopupWindow (which is what Android widgets use). It will also ignore root views created by a dialog by default, and you can turn this back on by setting the `leak_canary_watcher_watch_dismissed_dialogs` resource boolean to true:
+
+
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <bool name="leak_canary_watcher_watch_dismissed_dialogs">true</bool>
+</resources>
+```
+
+This is implemented using a new Square library: [Curtains](https://github.com/square/curtains).
+
+### Targeting Android 12
+
+We fixed two issues for apps that want to target Android 12:
+
+* [#2074](https://github.com/square/leakcanary/pull/2074) Activities that use intent filters must declare the `android:exported` attribute.
+* [#2079](https://github.com/square/leakcanary/issues/2079) PendingIntent requires the `FLAG_IMMUTABLE` flag.
+
+### Bug fixes and improvements ðŸ›ðŸ”¨
+
+* [#2075](https://github.com/square/leakcanary/issues/2075) Fixed crash when sharing heap dumps.
+* [#2067](https://github.com/square/leakcanary/issues/2067) Fixed crash when opening leaks from older versions (before 2.6) of LeakCanary.
+* [#2049](https://github.com/square/leakcanary/issues/2049) Fixed Plumber crash due to R8 shaking AndroidLeakFixes.
+* [#2084](https://github.com/square/leakcanary/issues/2084) Fixed Shark crash when used from multiple threads.
+* [#2054](https://github.com/square/leakcanary/issues/2054) ðŸ™ˆðŸ™‰ðŸ™Š Blocked Monkeys from deleting leaks.
+* [#2069](https://github.com/square/leakcanary/issues/2069) Added X button to the root leak activity (for custom devices with no back button)
+* [#2091](https://github.com/square/leakcanary/issues/2091) Added receiver details if LoadedApk shows up in the leaktrace.
+* [#2083](https://github.com/square/leakcanary/issues/2083) Added service status details (created or not) to leaktrace.
+* [#2099](https://github.com/square/leakcanary/pull/2099) Retry button if analysis fails.
+* [#2066](https://github.com/square/leakcanary/pull/2066) When heap analysis in UI tests is skipped and NoAnalysis is returned, NoAnalysis now includes a reason to help debug why it didn't run.
+* [#2000](https://github.com/square/leakcanary/issues/2000) The LeakCanary CI now leverages GitHub actions instead of Travis.
+
+For more details, see the [2.7 Milestone](https://github.com/square/leakcanary/milestone/21) and the [full diff](https://github.com/square/leakcanary/compare/v2.6...v2.7).
+
+##  Version 2.6 - Christmas Release ðŸŽ„ (2020-12-24)
+
+Please thank
+[@chao2zhang](https://github.com/chao2zhang),
+[@ChaosLeung](https://github.com/ChaosLeung),
+[@LitterSun](https://github.com/LitterSun),
+[@mickverm](https://github.com/mickverm),
+[@opatry](https://github.com/opatry),
+[@Thomas-Vos](https://github.com/Thomas-Vos),
+[@tricknology](https://github.com/tricknology),
+[@rahul-a](https://github.com/rahul-a),
+[@samoylenkodmitry](https://github.com/samoylenkodmitry),
+[@sing0055](https://github.com/sing0055),
+[@ubiratansoares](https://github.com/ubiratansoares)
+for their contributions, bug reports and feature requests ðŸ™ ðŸ™ ðŸ™.
+
+This Christmas Release includes several external contributions and a bunch of cool new features! ðŸŽðŸŽ
+
+###  Detecting root views retained after `View.onDetachedFromWindow()`
+
+On Android, every displayed view hierarchy is attached to a window, whether it be the view hierarchy of an activity, a dialog, a toast or [a chat head](http://www.piwai.info/chatheads-basics). After a view hierarchy is detached from its window, it should be garbage collected.
+
+LeakCanary already detects leaks of activity view hierarchies because retained detached views reference their activity context and LeakCanary detects activities retained after `Activity.onDestroy()`. In this new release, LeakCanary will now detect the leak of a dialog view hierarchy as soon as that dialog is dismissed, or any other view that is passed to [WindowManager.removeView()](https://developer.android.com/reference/android/view/ViewManager#removeView(android.view.View)).
+
+###  Detecting services retained after `Service.onDestroy()`
+
+After an Android [service](https://developer.android.com/reference/android/app/Service) is destroyed, it should be garbage collected. Unfortunately, the Android SDK does not provide any generic API to observe the service lifecycle. We worked around that using reflection on greylist APIs (details in [#2014](https://github.com/square/leakcanary/pull/2014)). Let's hope this motivates the Android team to [build the APIs developers need](https://twitter.com/Piwai/status/1342029560116891648).
+
+### Configuring retained object detection
+
+With the detection of 2 new types of retained objects, we're also adding APIs to configure which _watchers_ should be installed as well as adding filtering capabilities.
+
+First, disable the automatic install:
+
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <bool name="leak_canary_watcher_auto_install">false</bool>
+</resources>
+```
+
+Then you can install LeakCanary manually. LeakCanary 2.6 comes with 4 watchers installed by default: `ActivityWatcher`, `FragmentAndViewModelWatcher`, `RootViewWatcher`, `ServiceWatcher`. Here's an example to get all the default watchers except `ServiceWatcher`:
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+
+    val watchersToInstall = AppWatcher.appDefaultWatchers(application)
+      .filter { it !is ServiceWatcher }
+
+    AppWatcher.manualInstall(
+      application = application,
+      watchersToInstall = watchersToInstall
+    )
+  }
+}
+```
+
+LeakCanary introduces a new functional (SAM) interface implemented by `ObjectWatcher`: `ReachabilityWatcher`, with a `ReachabilityWatcher.expectWeaklyReachable()` method that replaces the now deprecated `ObjectWatcher.watch()` method. You can create the default watcher instances with a custom `ReachabilityWatcher` that delegates to `AppWatcher.objectWatcher` but filters out specific instances (e.g. `BadSdkLeakingFragment`):
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+
+    val delegate = ReachabilityWatcher { watchedObject, description ->
+      if (watchedObject !is BadSdkLeakingFragment) {
+        AppWatcher.objectWatcher.expectWeaklyReachable(watchedObject, description)
+      }
+    }
+
+    val watchersToInstall = AppWatcher.appDefaultWatchers(application, delegate)
+
+    AppWatcher.manualInstall(
+      application = application,
+      watchersToInstall = watchersToInstall
+    )
+  }
+}
+```
+
+With these new configuration options, `AppWatcher.config` is now deprecated and a no-op.
+
+### Dumping the heap on screen off
+
+The default threshold to dump the heap is **5 retained objects** when the app is **visible**, and **1 retained object** when the app is **not visible**. Up until now, visible meant "the app has at least one activity in **started** state". In LeakCanary 2.6, the app will now be considered **not visible** if the device screen is **off**, lowering the threshold to trigger heap dumps when you turn off the device screen.
+
+### LeakCanary for releases
+
+LeakCanary 2.6 introduces a new artifact: `leakcanary-android-release`. This artifact exposes APIs to run a heap analysis in release builds, in production.
+
+!!! danger
+    Everything about this is experimental. Running a heap analysis in production is not a very common thing to do, and we're still learning and experimenting with this. Also, both the artifact name and the APIs may change.
+
+```groovy
+dependencies {
+  // debugImplementation because LeakCanary should only run in debug builds.
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.6'
+
+  // NEW: LeakCanary for releases!
+  releaseImplementation 'com.squareup.leakcanary:leakcanary-android-release:2.6'
+  // Optional: detect retained objects. This helps but is not required.
+  releaseImplementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:2.6'
+}
+```
+
+Here's a code example that runs a heap analysis when the screen is turned off or the app enters background, checking first if a [Firebase Remote Config](https://firebase.google.com/products/remote-config) flag is turned on, and uploading the result to Bugsnag:
+
+
+```kotlin
+class ReleaseExampleApplication : ExampleApplication() {
+
+  // Cancels heap analysis if "heap_analysis_flag" is false.
+  private val flagInterceptor by lazy {
+    object : HeapAnalysisInterceptor {
+
+      val remoteConfig: FirebaseRemoteConfig = TODO()
+
+      override fun intercept(chain: Chain): HeapAnalysisJob.Result {
+        if (remoteConfig.getBoolean("heap_analysis_flag")) {
+          chain.job.cancel("heap_analysis_flag false")
+        }
+        return chain.proceed()
+      }
+    }
+  }
+
+  private val analysisClient by lazy {
+    HeapAnalysisClient(
+      // Use private app storage. cacheDir is never backed up which is important.
+      heapDumpDirectoryProvider = { cacheDir },
+      // stripHeapDump: remove all user data from hprof before analysis.
+      config = HeapAnalysisConfig(stripHeapDump = true),
+      // Default interceptors may cancel analysis for several other reasons.
+      interceptors = listOf(flagInterceptor) + HeapAnalysisClient.defaultInterceptors(this)
+    )
+  }
+
+  private val analysisExecutor by lazy {
+    Executors.newSingleThreadExecutor {
+      thread(start = false, name = "Heap analysis executor") {
+        android.os.Process.setThreadPriority(THREAD_PRIORITY_BACKGROUND)
+        it.run()
+      }
+    }
+  }
+
+  private val analysisCallback: (Result) -> Unit by lazy {
+    val uploader = BugsnagHeapAnalysisUploader(this@ReleaseExampleApplication)
+    { result ->
+      if (result is Done) {
+        uploader.upload(result.analysis)
+	  }
+    }
+  }
+
+  override fun onCreate() {
+    super.onCreate()
+
+    // Delete any remaining heap dump (if we crashed)
+    analysisExecutor.execute {
+      analysisClient.deleteHeapDumpFiles()
+    }
+
+    // Starts heap analysis on background importance
+    BackgroundTrigger(
+      application = this,
+      analysisClient = analysisClient,
+      analysisExecutor = analysisExecutor,
+      analysisCallback = analysisCallback
+    ).start()
+
+    // Starts heap analysis when screen off
+    ScreenOffTrigger(
+      application = this,
+      analysisClient = analysisClient,
+      analysisExecutor = analysisExecutor,
+      analysisCallback = analysisCallback
+    ).start()
+  }
+
+  /**
+   * Call this to trigger heap analysis manually, e.g. from
+   * a help button.
+   *
+   * This method returns a `HeapAnalysisJob` on which you can
+   * call `HeapAnalysisJob.cancel()` at any time.
+   */
+  fun triggerHeapAnalysisNow(): HeapAnalysisJob {
+    val job = analysisClient.newJob()
+    analysisExecutor.execute {
+      val result = job.execute()
+      analysisCallback(result)
+    }
+    return job
+  }
+}
+```
+
+The Bugsnag uploader:
+
+```kotlin
+class BugsnagHeapAnalysisUploader(applicationContext: Application) {
+
+  private val bugsnagClient: Client
+
+  init {
+    bugsnagClient = Client(
+      applicationContext,
+      BUGSNAG_API_KEY,
+      DO_NOT_ENABLE_EXCEPTION_HANDLER
+    )
+    bugsnagClient.setSendThreads(false)
+  }
+
+  fun upload(heapAnalysis: HeapAnalysis) {
+    when (heapAnalysis) {
+      is HeapAnalysisSuccess -> {
+        val exception = HeapAnalysisReport()
+        bugsnagClient.notify(exception) { report ->
+          val metaData = report.error.metaData
+          metaData.addToTab("Heap Analysis", "result", heapAnalysis.toString())
+        }
+      }
+      is HeapAnalysisFailure -> {
+        // Please file any reported failure to
+        // https://github.com/square/leakcanary/issues
+        bugsnagClient.notify(heapAnalysis.exception)
+      }
+    }
+  }
+
+  // Exception with fake unique stacktrace to send all reports to the same error entry.
+  class HeapAnalysisReport : Exception("Check the HEAP ANALYSIS tab") {
+    override fun fillInStackTrace(): Throwable {
+      stackTrace = arrayOf(
+        StackTraceElement(
+          "HeapAnalysisReport",
+          "analyzeHeap",
+          "HeapAnalysisReport.kt",
+          1
+        )
+      )
+      return this
+    }
+  }
+
+  companion object {
+    private const val BUGSNAG_API_KEY = YOUR_BUGSNAG_API_KEY
+    private const val DO_NOT_ENABLE_EXCEPTION_HANDLER = false
+  }
+}
+```
+
+### More leak fixes in Plumber
+
+We added 3 new automatic fixes for known AOSP leaks in `plumber-android` (details: [#1993](https://github.com/square/leakcanary/issues/1993)). As a reminder, `plumber-android` is automatically included when you add `leakcanary-android`, and you can add it manually for build types that don't include LeakCanary:
+
+```gradle
+dependencies {
+  // leakcanary-android adds plumber-android to debug builds
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.6'
+
+  // This adds plumber-android to all build types
+  implementation 'com.squareup.leakcanary:plumber-android:2.6'
+}
+```
+
+### Bug fixes and improvements ðŸ›ðŸ”¨
+
+* [#1948](https://github.com/square/leakcanary/pull/1948) Leakcanary is now compiled against Kotlin 1.4 (while staying 1.3 compatible) to support [Functional (SAM) interfaces](https://kotlinlang.org/docs/reference/fun-interfaces.html).
+* [#1956](https://github.com/square/leakcanary/issues/1956) The retained object size is displayed as a human readable output (KB, MB, ...).
+* [#1976](https://github.com/square/leakcanary/issues/1976) Improved default object inspectors and leak finders for `View` and `Context`.
+* [#1972](https://github.com/square/leakcanary/issues/1972) Fields are printed with the parent class name that holds the field in leak traces.
+* [#1981](https://github.com/square/leakcanary/issues/1981) Fixed StrictMode policy violation (main thread read from disk).
+* [#1977](https://github.com/square/leakcanary/issues/1977) Report objects that are not strongly reachable.
+* [#2018](https://github.com/square/leakcanary/pull/2018) & [#2019](https://github.com/square/leakcanary/pull/2019) Fixed crashes in LeakCanary UI (discovered by Monkey tests).
+* [#2015](https://github.com/square/leakcanary/issues/2015) Fixed crash on Android < 16.
+* [#2023](https://github.com/square/leakcanary/issues/2023) Fixed crash in plugin projects.
+
+For more details, see the [2.6 Milestone](https://github.com/square/leakcanary/milestone/20) and the [full diff](https://github.com/square/leakcanary/compare/v2.5...v2.6).
+
+## Version 2.5 (2020-10-01)
+
+Please thank
+[@Amokrane](https://github.com/Amokrane),
+[@Armaxis](https://github.com/Armaxis),
+[@askont](https://github.com/askont),
+[@chao2zhang](https://github.com/chao2zhang),
+[@daniil-shevtsov](https://github.com/daniil-shevtsov),
+[@eygraber](https://github.com/eygraber),
+[@msfjarvis](https://github.com/msfjarvis),
+[@mzgreen](https://github.com/mzgreen),
+[@lchen8](https://github.com/lchen8),
+[@rpattabi](https://github.com/rpattabi),
+[@sahil2441](https://github.com/sahil2441),
+[@SylvainGirod](https://github.com/SylvainGirod),
+[@vhow](https://github.com/vhow)
+for their contributions, bug reports and feature requests ðŸ™ ðŸ™ ðŸ™.
+
+### Heap analysis is twice as fast ðŸ¤ðŸ’¨
+
+No one asked, so we delivered! We rewrote several core components in Shark (LeakCanary's heap analyzer) to dramatically reduce IO reads and allocations while keeping memory constant. More details on Twitter: [thread by @ArtemChubaryan](https://twitter.com/ArtemChubaryan/status/1311078061895553030) and [thread by @Piwai](https://twitter.com/Piwai/status/1311085280753926144).
+
+### Compute retained size within the leak trace
+
+Previously, LeakCanary computed the retained size for the leaking object (the last object in the leak trace). However, the bad reference causing objects to leak is often higher up in the leak trace and everything that it holds onto is actually leaking. So LeakCanary now computes the retained size for [all the objects in the leaktrace that have a LEAKING or UNKNOWN status](https://github.com/square/leakcanary/issues/1880):
+
+```
+â”¬â”€â”€â”€
+â”‚ GC Root: System class
+â”‚
+â”œâ”€ com.example.MySingleton class
+â”‚    Leaking: NO (a class is never leaking)
+â”‚    â†“ static MySingleton.leakedView
+â”‚                         ~~~~~~~~~~
+â”œâ”€ android.widget.TextView instance
+â”‚    Leaking: YES (View.mContext references a destroyed activity)
+â”‚    Retaining 46326 bytes in 942 objects
+â”‚    â†“ TextView.mContext
+â•°â†’ com.example.MainActivity instance
+â€‹     Leaking: YES (Activity#mDestroyed is true)
+â€‹     Retaining 1432 bytes in 36 objects
+```
+
+### Disable LeakCanary from the UI
+
+New toggle to disable [heap dumping](https://github.com/square/leakcanary/issues/1886), which can be useful for QA, or when doing a product demo. LeakCanary will still show a notification when an object is retained.
+
+![disable heap dumping](images/disable_dumping.png)
+
+### Deobfuscating hprof files
+
+The [Shark CLI](shark.md#shark-cli) can now [deobfuscate heap dumps](https://github.com/square/leakcanary/issues/1698):
+
+```
+brew install leakcanary-shark
+
+shark-cli --hprof heapdump.hprof -m mapping.txt deobfuscate-hprof
+```
+
+### Bug fixes and improvements ðŸ›ðŸ”¨
+
+* Heap analysis text results now [wrap to a max width](https://github.com/square/leakcanary/issues/1811) when sharing them from the LeakCanary activity or printing to logcat. This will make it harder to miss details that are lost at the end of long lines of text.
+* The `leak_canary_watcher_auto_install`, `leak_canary_allow_in_non_debuggable_build` and `leak_canary_plumber_auto_install` resource booleans were [meant to be public](https://github.com/square/leakcanary/issues/1863).
+* We sprinkled a few `@JvmStatic` to [help Java consummers](https://github.com/square/leakcanary/issues/1870).
+* Fixed [crash when no browser installed](https://github.com/square/leakcanary/pull/1893).
+* Use distinct [group for LeakCanary notifications](https://github.com/square/leakcanary/issues/1845).
+* The heap analysis result now includes the [heap dump duration](https://github.com/square/leakcanary/pull/1931) because it looks like Android 11 heap dumps are [sometimes super slow](https://issuetracker.google.com/issues/168634429). We also added more [perf related metrics](https://github.com/square/leakcanary/issues/1929).
+* [Disable logging](https://github.com/square/leakcanary/issues/1910) when AppWatcher runs in release builds.
+* Highlight library leak patterns [directly within the leak traces](https://github.com/square/leakcanary/issues/1916).
+* Improved inspections for [Context, View](https://github.com/square/leakcanary/issues/1912) and [ContextImpl](https://github.com/square/leakcanary/pull/1884).
+
+
+For more details, see the [2.5 Milestone](https://github.com/square/leakcanary/milestone/19) and the [full diff](https://github.com/square/leakcanary/compare/v2.4...v2.5).
+
+
+## Version 2.4 (2020-06-10)
+
+Please thank
+[@0x109](https://github.com/0x109),
+[@andersu](https://github.com/andersu),
+[@antoniomerlin](https://github.com/antoniomerlin),
+[@bishiboosh](https://github.com/bishiboosh),
+[@ckesc](https://github.com/ckesc),
+[@jrodbx](https://github.com/jrodbx),
+[@LouisCAD](https://github.com/LouisCAD),
+[@marcardar](https://github.com/marcardar),
+[@OlivierGenez](https://github.com/OlivierGenez),
+[@pyricau](https://github.com/pyricau),
+[@runningcode](https://github.com/runningcode),
+[@seljad](https://github.com/seljad),
+[@worldsnas](https://github.com/worldsnas)
+for their contributions, bug reports and feature requests.
+
+### `plumber-android` is a new artifact that fixes known Android leaks ðŸš½ðŸ”§
+
+LeakCanary reports all leaks, including leaks caused by a known bug in 3rd party code that you do not have control over (reported as [Library leaks](fundamentals-how-leakcanary-works.md#4-categorizing-leaks)). That can be annoying! LeakCanary now ships with a new dependency, `plumber-android`, which performs hacks at runtime to fix some of these known leaks. This releases has fixes for **11 known leaks**, but this is just the beginning. Contributions welcome! ðŸ™
+
+Note that since the `leakcanary-android` dependency is usually added as a `debugImplementation` dependency, the `plumber-android` is transitively added only in debug builds, so it will not fix leaks in your release builds. You can add the dependency directly as `implementation` to get these fixes in release builds as well:
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:plumber-android:2.4'
+}
+```
+
+!!! warning
+    While several of these fixes already ship in release builds of Square apps, this is the first official release of `plumber-android`, so you should consider it **experimental**.
+
+### Analyzing leaks from the CLI is easier than ever ðŸº
+
+The [Shark CLI](shark.md#shark-cli) can now be installed via [Homebrew](https://brew.sh/)
+
+```
+brew install leakcanary-shark
+```
+
+You can then look for leaks in apps on any connected device, for example:
+
+```
+$ shark-cli --device emulator-5554 --process com.example.app.debug analyze
+```
+
+### Support for Android Test Orchestrator ðŸŽ¼
+
+If you set up LeakCanary to report test failures when detecting leaks in instrumentation tests, it [now works](https://github.com/square/leakcanary/issues/1046) with Android Test Orchestrator as well. No change required, LeakCanary will automatically detect thatAndroid Test Orchestrator is running and hook into it.
+
+### No more `master` branch
+
+The branch name `master` comes from the *master / slave* terminology. We renamed the default branch to `main`, a small step towards making the LeakCanary community a safer space. Here's a good [thread on this topic](https://twitter.com/mislav/status/1270388510684598272).
+
+### Bug fixes and improvements ðŸ›ðŸ”¨
+
+* URLs in *Library Leak* descriptions are [now clickable](https://github.com/square/leakcanary/issues/1844)
+* Fixed [ordering issues](https://github.com/square/leakcanary/issues/1832) causing improper config with manual setup. A related change is that `AppWatcher.Config.enabled` is now deprecated.
+* Fixed possible [OutOfMemoryError failure](https://github.com/square/leakcanary/issues/1798) when computing retained size: we were loading to memory large arrays from the heap dump just to get their size.
+
+For more details, see the [2.4 Milestone](https://github.com/square/leakcanary/milestone/18) and the [full diff](https://github.com/square/leakcanary/compare/v2.3...v2.4).
+
+## Version 2.3 (2020-04-08)
+
+This is a minor release on the feature front, but a large release on the documentation front!
+
+Many thanks to
+[@adamfit](https://github.com/adamfit),
+[@Amokrane](https://github.com/Amokrane),
+[@Armaxis](https://github.com/Armaxis),
+[@artnc](https://github.com/artnc),
+[@burakeregar](https://github.com/burakeregar),
+[@ClaasJG](https://github.com/ClaasJG),
+[@clementcontet](https://github.com/clementcontet),
+[@ckesc](https://github.com/ckesc),
+[@cketti](https://github.com/cketti),
+[@fbenbassat](https://github.com/fbenbassat),
+[@Guneetgstar](https://github.com/Guneetgstar),
+[@Igorxp5](https://github.com/Igorxp5),
+[@JLLeitschuh](https://github.com/JLLeitschuh),
+[@KidAndroid](https://github.com/KidAndroid),
+[@ligi](https://github.com/ligi),
+[@mzgreen](https://github.com/mzgreen),
+[@pyricau](https://github.com/pyricau),
+[@sprintuu](https://github.com/sprintuu),
+[@tevjef](https://github.com/tevjef),
+[@thrlr123](https://github.com/thrlr123)
+for the contributions, bug reports and feature requests.
+
+We [asked for help](https://twitter.com/Piwai/status/1253454280758980609) and immediately started seeing more contributions. Thanks all! Check out the [How to help](how_to_help.md) page.
+
+### LeakCanary will now crash in release builds
+
+Despite the documentation insisting on using `debugImplementation`, we've seen apps [ship LeakCanary](https://twitter.com/Piwai/status/1245524534712602624) in **release builds**. Mistakes happen, so we've made that mistake [harder to miss](https://github.com/square/leakcanary/issues/1804) by making LeakCanary **crash when included in release builds**.
+
+Learn More: [LeakCanary in release builds](recipes.md#leakcanary-in-release-builds).
+
+### Doc site ðŸ›€ðŸ’¥
+
+The doc site content has changed quite a bit! We applied advice from [Google's tech writing guide](https://developers.google.com/tech-writing/). If you've been confused by *Library Leaks* before, check out see the new [Categorizing leaks](fundamentals-how-leakcanary-works.md#4-categorizing-leaks) section. Take a look around, let us know what you think.
+
+### Bug fixes and improvements ðŸ˜‰
+
+* The new [deobfuscation Gradle plugin](recipes.md#using-leakcanary-with-obfuscated-apps) wasn't working [with Gradle 3.6](https://github.com/square/leakcanary/issues/1761), this is now fixed. Also removed the requirement for the plugin to be [applied after AGP](https://github.com/square/leakcanary/pull/1816).
+* Fixed 2 crashes ([#1768](https://github.com/square/leakcanary/issues/1768) & [#1769](https://github.com/square/leakcanary/issues/1769)) in the LeakCanary UI found by a sneaky monkey runner ðŸ™ˆ.
+* The LeakCanary UI updates [immediately](https://github.com/square/leakcanary/issues/1742) when a heap analysis is added or deleted.
+* Fixed a crash when [updating from LeakCanary 2.0](https://github.com/square/leakcanary/pull/1800).
+* The *About* section of the LeakCanary now surfaces whether heap dumping is [currently enabled](https://github.com/square/leakcanary/issues/1803).
+* Fixed process [not exiting](https://github.com/square/leakcanary/issues/1711) in SharkCLI on Windows.
+* Improved [error message](https://github.com/square/leakcanary/pull/1823) when obfuscation mappings appear to be missing.
+
+For more details, see the [2.3 Milestone](https://github.com/square/leakcanary/milestone/17) and the [full diff](https://github.com/square/leakcanary/compare/v2.2...v2.3).
+
+## Version 2.2 (2020-02-05)
+
+We've got some good stuff for the first release of the decade!
+
+Many thanks to
+[@AndroidInternal](https://github.com/AndroidInternal),
+[@Armaxis](https://github.com/Armaxis),
+[@lic2050](https://github.com/lic2050),
+[@mzgreen](https://github.com/mzgreen),
+[@orenktaboola](https://github.com/orenktaboola),
+[@personshelldon](https://github.com/personshelldon),
+[@Plastix](https://github.com/Plastix),
+[@pyricau](https://github.com/pyricau)
+for the contributions, bug reports and feature requests.
+
+### ViewModel leak detection
+
+[Android ViewModels](https://developer.android.com/topic/libraries/architecture/viewmodel) are really cool! Their lifecycle is much nicer than fragments or activities, but sometimes mistakes happen. LeakCanary will now automatically detect ViewModel leaks and report any ViewModel instance retained after its `onCleared()` method was called.
+
+### Android TV
+
+![tv ui](images/android-tv-leaks.png)
+
+LeakCanary is finally coming to big screens near you! Best part - no additional setup is required, just enable it like you would for a [mobile device](getting_started.md). Now whenever there's a leak - you will see a helpful Toast appear with all the details. Make sure to check out our new [Android TV](recipes.md#android-tv) section and chill!
+
+### Java-friendly Config builders
+
+[It was brought to our attention](https://github.com/square/leakcanary/issues/1714) that configuring `LeakCanary` and `AppWatcher` was a miserable experience from Java code. Well, not anymore!
+
+Now you can use `LeakCanary.Config.Builder` and `AppWatcher.Config.Builder` to have idiomatic Java when updating the configurations. For example:
+
+```
+LeakCanary.Config config = LeakCanary.getConfig().newBuilder()
+  .retainedVisibleThreshold(3)
+  .computeRetainedHeapSize(false)
+  .build();
+LeakCanary.setConfig(config);
+```
+
+If you notice any other problems when using LeakCanary from Java, please [file an issue](https://github.com/square/leakcanary/issues/new?assignees=&labels=type%3A+enhancement&template=3-feature.md&title=)! We take Java-interop seriously and will be happy to improve LeakCanary's API!
+
+For more details, see the [2.2 Milestone](https://github.com/square/leakcanary/milestone/16) and the [full diff](https://github.com/square/leakcanary/compare/v2.1...v2.2).
+
+## Version 2.1 (2019-12-31)
+
+A special New Year's Eve release ðŸ¥³, the next release will be in another decade ðŸ˜Ž!
+
+Many thanks to
+[@adamfit](https://github.com/adamfit),
+[@alexander-smityuk](https://github.com/alexander-smityuk),
+[@Armaxis](https://github.com/Armaxis),
+[@BraisGabin](https://github.com/BraisGabin),
+[@devism](https://github.com/devism),
+[@ditclear](https://github.com/ditclear),
+[@jrodbx](https://github.com/jrodbx),
+[@jstefanowski](https://github.com/jstefanowski),
+[@Maragues](https://github.com/Maragues),
+[@mzgreen](https://github.com/mzgreen),
+[@pyricau](https://github.com/pyricau)
+for the contributions, bug reports and feature requests.
+
+### A Gradle plugin for obfuscated apps
+
+It's fairly common for teams to have a QA build that is tested before making the release build. Usually that build will be obfuscated (via Proguard or R8), but also add LeakCanary to detect leaks during QA. This leads to obfuscated leak traces, which are hard to understand ðŸ¤¯. Check out our new [Gradle deobfuscation plugin](recipes.md#using-leakcanary-with-obfuscated-apps) and rejoice!
+
+### UI <strike>twix</strike> tweaks
+
+In 2.0 we changed the LeakCanary UI and UX, and built a foundation on which 2.1 extends.
+
+![ui](images/screenshot-2.0.png)
+
+* Since 2.0, Leaks are grouped by their distinct signature. In 2.1 there's a `New` tag that will show until you open up a leak. There's also a `Library Leak` tag for leaks that are known to be caused by a bug in the Android Framework or Google libraries, and the library leak description now shows up in the UI.
+* The type of the Java objects (class, instance, array) is now displayed in the LeakTrace, e.g. see `FontsContract class` and `ExampleApplication instance` above.
+* The type of the GC root now shows up at the root of the leak trace. Makes sense!
+* The leak result notification has an importance now set to MAX so that it'll show up right in your face. If you turn it off, the canary will haunt you in your dreams ðŸ¤ðŸ‘». To save your sanity and your device battery, automatic heap dumps now won't happen more often than once per minute.
+* The resource id name for `View` instances is now displayed in the leak trace. You shouldn't look at the [implementation](https://github.com/square/leakcanary/pull/1663).
+
+```
+â”œâ”€ android.widget.TextView instance
+â”‚    View.mID = R.id.helper_text
+```
+
+### Documentation goodies
+
+* The [Fundamentals](fundamentals.md) page was entirely rewritten, split into 3 pages and moved to its own tab. Please read it and provide feedback!
+* At Square, we have been uploading leaks to Bugsnag for 3 years now, so that no leak ever gets missed. Follow [this recipe](uploading.md)!
+* Did you know you can [run LeakCanary in a JVM](recipes.md#detecting-leaks-in-jvm-applications)?
+
+### API <strike>breaking</strike> bettering changes
+
+* The APIs of the `Leak` and `LeakTrace` classes have significantly changed, e.g. all `LeakTrace` instances with an identical signature are grouped under the same Leak object. Despite these breaking changes, this release version is a minor update. Oh noes, what about semantic versioning ðŸ˜±? Ask Don Quixote.
+* You can now customize the way LeakCanary finds the leaking objects in the heap dump. For example, here's the configuration SharkCli uses to find leaks in heap dumps of apps that don't even have the LeakCanary dependency:
+
+```kotlin
+LeakCanary.config = LeakCanary.config.copy(
+    leakingObjectFinder = FilteringLeakingObjectFinder(
+        AndroidObjectInspectors.appLeakingObjectFilters
+    )
+)
+```
+
+* LeakCanary automatically disables itself in tests by detecting that the `org.junit.Test` is in the classpath. Unfortunately, some apps ship Junit in their app debug classpath (e.g. when using OkHttp MockWebServer). You can now customize which class is used to detect tests:
+
+```xml
+<resources>
+  <string name="leak_canary_test_class_name">assertk.Assert</string>
+</resources>
+```
+
+### Interactive CLI
+
+[Shark CLI](https://github.com/square/leakcanary/releases/download/v2.1/shark-cli-2.1.zip) was rewritten on top of [Clikt](https://github.com/ajalt/clikt):
+
+```bash
+$ shark-cli
+Usage: shark-cli [OPTIONS] COMMAND [ARGS]...
+
+                 ^`.                 .=""=.
+ ^_              \  \               / _  _ \
+ \ \             {   \             |  d  b  |
+ {  \           /     `~~~--__     \   /\   /
+ {   \___----~~'              `~~-_/'-=\/=-'\,
+  \                         /// a  `~.      \ \
+  / /~~~~-, ,__.    ,      ///  __,,,,)      \ |
+  \/      \/    `~~~;   ,---~~-_`/ \        / \/
+                   /   /            '.    .'
+                  '._.'             _|`~~`|_
+                                    /|\  /|\
+
+Options:
+  -p, --process NAME              Full or partial name of a process, e.g.
+                                  "example" would match "com.example.app"
+  -d, --device ID                 device/emulator id
+  -m, --obfuscation-mapping PATH  path to obfuscation mapping file
+  --verbose / --no-verbose        provide additional details as to what
+                                  shark-cli is doing
+  -h, --hprof FILE                path to a .hprof file
+  --help                          Show this message and exit
+
+Commands:
+  interactive   Explore a heap dump.
+  analyze       Analyze a heap dump.
+  dump-process  Dump the heap and pull the hprof file.
+  strip-hprof   Replace all primitive arrays from the provided heap dump with
+                arrays of zeroes and generate a new "-stripped.hprof" file.
+```
+
+There's a new `interactive` command which enables exploring the heap dump from the command line:
+
+```bash
+$ shark-cli -h heapdump.hprof interactive
+Enter command [help]:
+help
+
+Available commands:
+  analyze                   Analyze the heap dump.
+  class NAME@ID             Show class with a matching NAME and Object ID.
+  instance CLASS_NAME@ID    Show instance with a matching CLASS_NAME and Object
+ID.
+  array CLASS_NAME@ID       Show array instance with a matching CLASS_NAME and
+Object ID.
+  ->instance CLASS_NAME@ID  Show path from GC Roots to instance.
+  ~>instance CLASS_NAME@ID  Show path from GC Roots to instance, highlighting
+suspect references.
+  help                      Show this message.
+  exit                      Exit this interactive prompt.
+```
+
+We're currently exploring the idea of adding [support for SQL queries](https://twitter.com/Piwai/status/1211795647273160704), feedback welcome!
+
+For more details, see the [2.1 Milestone](https://github.com/square/leakcanary/milestone/15) and the [full diff](https://github.com/square/leakcanary/compare/v2.0...v2.1).
+
+## Version 2.0 (2019-11-27)
+
+In the past 7 months, LeakCanary went through 3 alphas and 5 betas, encompassing 23 contributors over 493 commits, 35826 insertions and 10156 deletions.
+
+### Should I upgrade?
+
+**YES!** LeakCanary 2 is so much better, it might make you excited when you see a new memory leak. Follow the [upgrade guide](upgrading-to-leakcanary-2.0.md), you won't regret it!
+
+### So, what's changed since 1.6.3?
+
+**Everything.** The LeakCanary codebase went from **~6000** lines of Java to **~16000** lines of Kotlin, excluding comments & blanks.
+
+!!! question "Isn't Kotlin supposed to drastically reduce the amount of boilerplate code?"
+    Absolutely! And it did. But then, we wrote more code.
+    LeakCanary used to depend on [HAHA](https://github.com/square/haha), a repackaging of [perflib](https://android.googlesource.com/platform/tools/base/+/2f03004c181baf9d291a9bf992e1b444e83cd82d/perflib/), the heap dump parser used by Android Studio. Unfortunately perflib was slow and used too much memory, so LeakCanary now includes its own heap dump parser: [Shark](shark.md). The extra code comes from Shark, but also from having a lot more automated tests, and an improved UI layer.
+
+One major difference: when the app is in foreground, LeakCanary 2 will not trigger on every retained instance. Instead it will wait until the app goes in background or to reach a threashold of 5 retained instances in foreground. The analysis will then find all the leaks at once, and group identical leaks in the results UI. Please read the [Fundamentals](fundamentals.md) section to learn more!
+
+### Random facts
+
+* You can customize the Leaks launcher icon and label: [learn more here](recipes.md#icon-and-label).
+* If you ` press on your main activity launcher icon, you should see a LeakCanary dynamic shortcut. You can then long press that to drop it on your home screen, and the launcher shows that it's the leaks launcher for your app.
+* Out of the box, LeakCanary tracks all fragments flavors: AOSP, Support Library and Android X.
+* From within the leak screen, you can share a leak to stack overflow. You can also share a heap dump, or import and analyze a heap dump from another device.
+* You can run LeakCanary from your computer command line, on any debuggable app even if that app doesn't have LeakCanary: [learn more here](shark.md##shark-cli).
+* The new documentation is fully searchable and includes the API documentation. Try the search bar â¤´.
+* A large 160Mb heap dump uses 2Gb memory when opening it in Android Studio, but only 40Mb with Shark.
+
+### Changes since 2.0 Beta 5
+
+* Shark CLI supports multiple connected devices [#1642](https://github.com/square/leakcanary/issues/1642)
+* Fixed missing sources from Maven Central [#1643](https://github.com/square/leakcanary/issues/1643)
+* Updated notification icon to avoid confusion with Twitter DM notifications, and added icons to bottom navigation bar [#1648](https://github.com/square/leakcanary/pull/1648)
+* Automatic leak detection for support library fragments [#1611](https://github.com/square/leakcanary/pull/1611)
+
+Many thanks to
+[@AndreasBoehm](https://github.com/AndreasBoehm),
+[@jrodbx](https://github.com/jrodbx),
+[@pyricau](https://github.com/pyricau)
+for the contributions, bug reports and feature requests.
+
+For more details, see the [2.0 Milestone](https://github.com/square/leakcanary/milestone/14) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-beta-5...v2.0).
+
+## Version 2.0 Beta 5 (2019-11-25)
+
+* Major bugfix: native gc roots were accidentally ignored in Beta 4, as a result some leaks were not found [#1634](https://github.com/square/leakcanary/issues/1634)
+* Fixed Lint warning (`leak_canary_about_message` string triggered *multiple substitutions* warning) [#1630](https://github.com/square/leakcanary/issues/1630)
+
+Many thanks to
+[@DanEdgarTarget](https://github.com/DanEdgarTarget),
+[@msfjarvis](https://github.com/msfjarvis),
+[@PaulWoitaschek](https://github.com/pyricau),
+[@pyricau](https://github.com/pyricau),
+[@ZacSweers](https://github.com/ZacSweers)
+for the contributions, bug reports and feature requests.
+
+For more details, see the [2.0-beta-5 Milestone](https://github.com/square/leakcanary/milestone/13) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-beta-4...v2.0-beta-5).
+
+## Version 2.0 Beta 4 (2019-11-18)
+
+* Improved string rendering for heap analysis results
+* UX redesign [#1445](https://github.com/square/leakcanary/issues/1445)
+* Support for pattern matching of native reference leaks [#1562](https://github.com/square/leakcanary/issues/1562)
+* Added support for deobfuscation using Proguard mapping files in Shark [#1499](https://github.com/square/leakcanary/issues/1499). This isn't directly supported in LeakCanary yet.
+* Added support for extracting metadata from the heap dump (see the [recipe](recipes.md#extracting-metadata-from-the-heap-dump)) [#1519](https://github.com/square/leakcanary/issues/1519)
+* Improved auto disabling of LeakCanary in Unit and UI tests [#1552](https://github.com/square/leakcanary/issues/1552)
+* Several performance improvements when parsing heap dumps
+* Fixed several bugs and crashes
+* Added new known leak patterns
+
+Many thanks to
+[@Armaxis](https://github.com/Armaxis),
+[@BraisGabin](https://github.com/BraisGabin),
+[@bric3](https://github.com/bric3),
+[@elihart](https://github.com/elihart),
+[@fernandospr](https://github.com/fernandospr),
+[@flickator](https://github.com/flickator),
+[@gabrysgab](https://github.com/gabrysgab),
+[@JorgeDLS](https://github.com/JorgeDLS),
+[@lannyf77](https://github.com/lannyf77),
+[@msfjarvis](https://github.com/msfjarvis),
+[@mzgreen](https://github.com/mzgreen),
+[@ozmium](https://github.com/ozmium),
+[@PaulWoitaschek](https://github.com/pyricau),
+[@pyricau](https://github.com/pyricau),
+[@shelpy](https://github.com/shelpy),
+[@vRallev](https://github.com/vRallev),
+[@ZacSweers](https://github.com/ZacSweers)
+for the contributions, bug reports and feature requests.
+
+For more details, see the [2.0-beta-4 Milestone](https://github.com/square/leakcanary/milestone/12) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-beta-3...v2.0-beta-4).
+
+## Version 2.0 Beta 3 (2019-08-22)
+
+* Baseline memory usage for large hprofs divided by 3 and removed memory spikes [#1543](https://github.com/square/leakcanary/pull/1543)
+* Fixed crash when LeakCanary is initialized from another process [#1529](https://github.com/square/leakcanary/issues/1529)
+* Java local references are deprioritized to look for longer alternative paths [#1525](https://github.com/square/leakcanary/pull/1525)
+* Fixed `JavaLocalPattern` not matching on Lollipop [#1524](https://github.com/square/leakcanary/pull/1524)
+
+Many thanks to
+[@Armaxis](https://github.com/Armaxis),
+[@elihart](https://github.com/elihart),
+[@emartynov](https://github.com/emartynov),
+[@hmcgreevy-instil](https://github.com/hmcgreevy-instil),
+[@pyricau](https://github.com/pyricau)
+for the contributions, bug reports and feature requests.
+
+For more details, see the [2.0-beta-3 Milestone](https://github.com/square/leakcanary/milestone/11) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-beta-2...v2.0-beta-3).
+
+## Version 2.0 Beta 2 (2019-08-02)
+
+* Fixed *Leak analysis failed: Object id not found in heap dump.* [#1516](https://github.com/square/leakcanary/issues/1516)
+* 10x speed increase of hprof indexing on large heap dumps [#1520](https://github.com/square/leakcanary/pull/1520)
+
+Many thanks to
+[@kolphi](https://github.com/kolphi),
+[@pyricau](https://github.com/pyricau),
+[@ZacSweers](https://github.com/ZacSweers)
+for the contributions, bug reports and feature requests.
+
+For more details, see the [2.0-beta-2 Milestone](https://github.com/square/leakcanary/milestone/10) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-beta-1...v2.0-beta-2).
+
+## Version 2.0 Beta 1 (2019-07-30)
+
+* New standalone library! [Shark](shark.md) is the heap analyzer that powers LeakCanary 2, and it can run in any Java VM. It comes with a [CLI](shark.md#shark-cli): you can now run `shark-cli analyze-process com.example.myapp` from your computer.
+* New Heap Explorer directly on device! Open a Heap Analysis in LeakCanary, tap the options menu and select "Heap Explorer". This is still experimental and not very user friendly, contributions welcome!
+* **Large API rewrite** to improve usability. If you used the alpha with a customized configuration, there are breaking changes. Of note: LeakSentry became [AppWatcher](/leakcanary/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/), RefWatcher became [ObjectWatcher](/leakcanary/api/leakcanary-object-watcher/leakcanary/-object-watcher/), AndroidExcludedRefs became [AndroidReferenceMatchers](/leakcanary/api/shark-android/shark/-android-reference-matchers/), AnalysisResultListener became [OnHeapAnalyzedListener](/leakcanary/api/leakcanary-android-core/leakcanary/-on-heap-analyzed-listener/), AndroidLeakTraceInspectors became [AndroidObjectInspectors](/leakcanary/api/shark-android/shark/-android-object-inspectors/).
+* The entire API surface is now documented and the documentation is available on this website: see the **LeakCanary API** tab at the top.
+* Removed the **dependency on Android X**. No more configuration issues! [#1462](https://github.com/square/leakcanary/issues/1462)
+* Added **Proguard rules** for LeakCanary and ObjectWatcher. [#1500](https://github.com/square/leakcanary/pull/1500)
+* Display LeakCanary version in the About screen. [#1448](https://github.com/square/leakcanary/issues/1448)
+* Bug fixes, new reference matchers and object inspectors
+
+Many thanks to
+[@arctouch-carlosottoboni](https://github.com/arctouch-carlosottoboni),
+[@jemaystermind](https://github.com/jemaystermind),
+[@kushagrakumar27](https://github.com/kushagrakumar27),
+[@pyricau](https://github.com/pyricau),
+[@snkashis](https://github.com/snkashis)
+for the contributions, bug reports and feature requests.
+
+For more details, see the [2.0-beta-1 Milestone](https://github.com/square/leakcanary/milestone/9) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-alpha-3...v2.0-beta-1).
+
+## Version 2.0 Alpha 3 (2019-07-04)
+
+* [#1401](https://github.com/square/leakcanary/pull/1401) LeakCanary can now import all hprof files created from prior LeakCanary versions.
+* [#1414](https://github.com/square/leakcanary/pull/1414) New API: `RefWatcher.retainedInstances` which returns the instances that are currently considered retained.
+* [#1419](https://github.com/square/leakcanary/pull/1419) New APIs: `LeakCanary.Config.maxStoredHeapDumps` (default 7) and `LeakCanary.Config.requestWriteExternalStoragePermission` (default false). LeakCanary won't ask for the external storage permission anymore by default.
+* [#1338](https://github.com/square/leakcanary/issues/1338) API change: `LeakCanary.Config.exclusionsFactory` replaced with `LeakCanary.Config.knownReferences` (simpler use), `LeakCanary.Config.leakInspectors` and `LeakCanary.Config.labelers` merged into `LeakCanary.Config.leakTraceInspectors` which provides access to the entire leak trace as well as a new graph oriented API that replaces the low level hprof parser API.
+* [#1382](https://github.com/square/leakcanary/issues/1382) LeakCanary now disables automatic heap dumping when running in AndroidX UI tests.
+* [#1424](https://github.com/square/leakcanary/pull/1424) API rename: `RefWatcher.hasRetainedReferences` => `RefWatcher.hasRetainedInstances`, `RefWatcher.retainedReferenceCount` => `RefWatcher.retainedInstanceCount`, `RefWatcher.hasWatchedReferences` => `RefWatcher.hasWatchedInstances`, `RefWatcher.removeKeysRetainedBeforeHeapDump` => `RefWatcher.removeInstancesRetainedBeforeHeapDump`, `RefWatcher.clearWatchedReferences` => `RefWatcher.clearWatchedInstances`.
+* [#1432](https://github.com/square/leakcanary/pull/1432) [#1438](https://github.com/square/leakcanary/pull/1438) [#1440](https://github.com/square/leakcanary/pull/1440) New "won't fix" leaks and leak trace inspectors
+* [#1374](https://github.com/square/leakcanary/issues/1374) [#1364](https://github.com/square/leakcanary/issues/1364) [#1366](https://github.com/square/leakcanary/issues/1366) [#1417](https://github.com/square/leakcanary/issues/1417) [#1399](https://github.com/square/leakcanary/issues/#1399) [#1416](https://github.com/square/leakcanary/issues/1416) [#1407](https://github.com/square/leakcanary/issues/1407) [#1427](https://github.com/square/leakcanary/issues/1427) [#1385](https://github.com/square/leakcanary/issues/1385) Bug and crash fixes
+
+Many thanks to
+[@1step2hell](https://github.com/1step2hell),
+[@afollestad](https://github.com/afollestad),
+[@ansman](https://github.com/ansman),
+[@bjdodson](https://github.com/bjdodson),
+[@BraisGabin](https://github.com/BraisGabin),
+[@EBfVince](https://github.com/EBfVince),
+[@jaredsburrows](https://github.com/jaredsburrows),
+[@pforhan](https://github.com/pforhan),
+[@pyricau](https://github.com/pyricau),
+[@tellypresence](https://github.com/tellypresence),
+[@wiyarmir](https://github.com/wiyarmir)
+for the contributions, bug reports and feature requests.
+
+For more details, see the [2.0-alpha-3 Milestone](https://github.com/square/leakcanary/milestone/8) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-alpha-2...v2.0-alpha-3).
+
+## Version 2.0 Alpha 2 (2019-05-21)
+
+* [#1040](https://github.com/square/leakcanary/pull/1040) Import and analyze hprof files from other devices
+* [#1344](https://github.com/square/leakcanary/pull/1344) Computing retained size
+* [#1325](https://github.com/square/leakcanary/pull/1325) New notification showing current count of retained instances
+* [#1079](https://github.com/square/leakcanary/pull/1079) "Excluded" leaks have been renamed to "Won't fix" leaks to clarify meaning.
+* [#1328](https://github.com/square/leakcanary/pull/1328) New leaks are called out in the UI.
+* [#1327](https://github.com/square/leakcanary/pull/1327) LeakSentry can be enabled / disabled and is automatically disabled in non debuggable builds.
+* [#1173](https://github.com/square/leakcanary/pull/1173) Experimental: now reporting leaks that only go through weak references (previously reported as "no path to instance")
+* [#1339](https://github.com/square/leakcanary/pull/1339) Readded support for Thread name based exclusions
+* [#1312](https://github.com/square/leakcanary/pull/1312) Fixed bug causing LeakCanary to stop detecting leaks after the app is killed.
+* [#1310](https://github.com/square/leakcanary/pull/1310) [#1313](https://github.com/square/leakcanary/pull/1313) [#1314](https://github.com/square/leakcanary/pull/1314) [#1340](https://github.com/square/leakcanary/pull/1340) [#1337](https://github.com/square/leakcanary/pull/1337) Many API changes
+* [#1296](https://github.com/square/leakcanary/pull/1296) [#1293](https://github.com/square/leakcanary/pull/1293) [#1306](https://github.com/square/leakcanary/pull/1306) [#1336](https://github.com/square/leakcanary/pull/1336) Fixed several crashes.
+
+Many thanks to
+[@forrestbice](https://github.com/forrestbice),
+[@Foso](https://github.com/Foso),
+[@Goddchen](https://github.com/Goddchen),
+[@marcosholgado](https://github.com/marcosholgado),
+[@orionlee](https://github.com/orionlee),
+[@pyricau](https://github.com/pyricau),
+[@satoshun](https://github.com/satoshun),
+[@ZacSweers](https://github.com/ZacSweers)
+for the contributions!
+
+For more details, see the [2.0-alpha-2 Milestone](https://github.com/square/leakcanary/milestone/7) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-alpha-1...v2.0-alpha-2).
+
+## Version 2.0 Alpha 1 (2019-04-23)
+
+![logo](images/logo-2.0-200px.png)
+
+* New [logo](https://github.com/square/leakcanary/wiki/FAQ#who-made-the-logo), thanks [@flickator](https://github.com/flickator)!
+* Entirely rewritten to **100% Kotlin**
+* Multiple leaks detected in one analysis
+    * The heap is dumped when the app goes in the background, or when a minimum of 5 leaks is reached in the foreground.
+* Leak grouping
+    * Leaks that share similar causes are grouped in the UI.
+    * New screens to see the list of groups and each group.
+    * Improved leaktrace strings to highlight leak causes.
+    * Leaks can be shared to Stack Overflow
+* New library: **LeakSentry**.
+    * Detects when objects are leaking and triggers LeakCanary
+    * Can be used independently in production, for instance to report the number of leaking instances on an OutOfMemoryError crash.
+* New heap parser
+    * Uses **90% less memory and 6 times** faster than the prior heap parser.
+    * Runs in the same process as the app on a low priority thread.
+    * No more dependency on Perflib and TroveJ. New dependency on Okio.
+    * The old parser is still available as `leakcanary-android-perflib` but will be removed after alpha.
+* Labelers can add any string content to leak elements
+* 0 code setup, just add the one debug dependency.
+* Simpler configuration options
+* Updated from support library to Android X
+
+Many thanks to
+[@BraisGabin](https://github.com/BraisGabin),
+[@colinmarsch](https://github.com/colinmarsch),
+[@jrodbx](https://github.com/jrodbx),
+[@flickator](https://github.com/flickator),
+[@JakeWharton](https://github.com/JakeWharton),
+[@pyricau](https://github.com/pyricau),
+[@WhatsEmo](https://github.com/WhatsEmo)
+for the contributions!
+
+For more details, see the [2.0-alpha-1 Milestone](https://github.com/square/leakcanary/milestone/6) and the [full diff](https://github.com/square/leakcanary/compare/v1.6.3...v2.0-alpha-1).
+
+## Version 1.6.3 (2019-01-10)
+
+* [#1163](https://github.com/square/leakcanary/issues/1163) Fixed leaks being incorrectly classified as "no leak" due to missed GC Roots.
+* [#1153](https://github.com/square/leakcanary/issues/1153) `LeakCanary.isInAnalyzerProcess` now correctly returns true in the analyzer process prior to any first leak (could be triggered by starting the leak result activity).
+* [#1158](https://github.com/square/leakcanary/issues/1158) Stopped enabling DisplayLeakActivity when not using DisplayLeakService.
+* [#1135](https://github.com/square/leakcanary/issues/1135) Fixed IndexOutOfBoundsException for leak traces of size 1.
+* [#1163](https://github.com/square/leakcanary/issues/1163) Keep "no leak" heap dumps.
+
+Many thanks to
+[@KMaragh](https://github.com/KMaragh),
+[@pyricau](https://github.com/pyricau),
+[@SebRut](https://github.com/SebRut)
+for the code contributions!
+
+For more details, see the [1.6.3 Milestone](https://github.com/square/leakcanary/milestone/5) and the [full diff](https://github.com/square/leakcanary/compare/v1.6.2...v1.6.3).
+
+
+## Version 1.6.2 (2018-10-16)
+
+* [#1067](https://github.com/square/leakcanary/issues/1067) Fixed TransactionTooLargeException crash (leak analysis would never complete).
+* [#1061](https://github.com/square/leakcanary/pull/1061) Detection of Fragment view leaks after Fragment#onDestroyView().
+* [#1076](https://github.com/square/leakcanary/pull/1076) Added the FOREGROUND_SERVICE permission for Android P.
+* [#1062](https://github.com/square/leakcanary/issues/1062) The LeakCanary toast now always shows correctly. It doesn't show if there is no activity in foreground.
+* [#1115](https://github.com/square/leakcanary/issues/1115) Reenabled the DisplayLeakActivity icon on fresh installs.
+* [#1100](https://github.com/square/leakcanary/pull/1100) Added nullability annotations to improve Kotlin support.
+* Updates to excluded leaks ([commits](https://github.com/square/leakcanary/commits/v1.6.2/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java)).
+* Updates to reachability inspectors ([commits](https://github.com/square/leakcanary/commits/v1.6.2/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java)).
+
+Many thanks to
+[@fractalwrench](https://github.com/fractalwrench),
+[@ZacSweers](https://github.com/ZacSweers),
+[@Goddchen](https://github.com/Goddchen),
+[@igokoro](https://github.com/igokoro),
+[@IlyaGulya](https://github.com/IlyaGulya),
+[@JakeWharton](https://github.com/JakeWharton),
+[@javmarina](https://github.com/javmarina),
+[@jokermonn](https://github.com/jokermonn),
+[@jrodbx](https://github.com/jrodbx),
+[@Parseus](https://github.com/Parseus),
+[@pyricau](https://github.com/pyricau),
+[@scottkennedy](https://github.com/scottkennedy)
+for the code contributions!
+
+### Public API changes
+
+* Subclasses of `AbstractAnalysisResultService` should now override `onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap)` instead of `onHeapAnalyzed(@NonNull HeapDump heapDump, @NonNull AnalysisResult result)`
+
+For more details, see the [1.6.2 Milestone](https://github.com/square/leakcanary/milestone/4) and the [full diff](https://github.com/square/leakcanary/compare/v1.6.1...v1.6.2).
+
+## Version 1.6.1 (2018-06-21)
+
+* [#727](https://github.com/square/leakcanary/issues/727) Improved leak analysis: LeakCanary now identifies and highlights the potential causes of the leak.
+* [#1011](https://github.com/square/leakcanary/issues/1011) We noticed that computing the retained heap size could take a long time, so it's now optional and off by default.
+* [#633](https://github.com/square/leakcanary/pull/633) Support for detecting leaks in instrumentation tests ([see the wiki](https://github.com/square/leakcanary/wiki/Customizing-LeakCanary#running-leakcanary-in-instrumentation-tests)).
+* [#985](https://github.com/square/leakcanary/pull/985) Ability to convert leak traces into stack traces for easy remote reporting ([see the wiki](uploading.md)).
+* [#983](https://github.com/square/leakcanary/issues/983) Support for watching destroyed Fragments.
+* [#846](https://github.com/square/leakcanary/issues/846) LeakCanary now uses foreground services and displays a notification when the analysis is in progress. This also fixes crashes when analyzing in background on O+.
+* The LeakCanary icon (to start to DisplayLeakActivity) is now hidden by default, and only enabled after the first leak is found.
+* [#775](https://github.com/square/leakcanary/issues/775) Fixed crash when sharing heap dumps on O+ and added a dependency to the support-core-utils library.
+* [#930](https://github.com/square/leakcanary/pull/930) DisplayLeakActivity has a responsive icon.
+* [#685](https://github.com/square/leakcanary/issues/685) Stopped doing IO on main thread in DisplayLeakActivity (fixes StrictMode errors).
+* [#999](https://github.com/square/leakcanary/pull/999) Updated HAHA to 2.0.4, which uses Trove4j as an external dependency (from jcenter) instead of rebundling it. This is to clarify licences (Apache v2 vs LGPL 2.1).
+* Several bug and crash fixes.
+
+Many thanks to [@AdityaAnand1](https://github.com/AdityaAnand1), [@alhah](https://github.com/alhah), [@christxph](https://github.com/christxph), [@csoon03](https://github.com/csoon03), [@daqi](https://github.com/daqi), [@JakeWharton](https://github.com/JakeWharton), [@jankovd](https://github.com/jankovd), [@jrodbx](https://github.com/jrodbx), [@kurtisnelson](https://github.com/kurtisnelson), [@NightlyNexus](https://github.com/NightlyNexus), [@pyricau](https://github.com/pyricau), [@SalvatoreT](https://github.com/SalvatoreT), [@shmuelr](https://github.com/shmuelr), [@tokou](https://github.com/tokou), [@xueqiushi](https://github.com/xueqiushi)
+ for the code contributions!
+
+Note: we made a 1.6 release but quickly followed up with 1.6.1 due to [#1058](https://github.com/square/leakcanary/issues/1058).
+
+### Public API changes
+
+* The installed ref watcher singleton is now available via `LeakCanary.installedRefWatcher()`
+* `AnalysisResult.leakTraceAsFakeException()` returns an exception that can be used to report and group leak traces to a tool like Bugsnag or Crashlytics.
+* New `InstrumentationLeakDetector` and `FailTestOnLeakRunListener` APIs for detecting leaks in instrumentation tests.
+* New `Reachability.Inspector` and `RefWatcherBuilder.stethoscopeClasses()` API to establish reachability and help identify leak causes.
+* Watching activities can be disabled with `AndroidRefWatcherBuilder.watchActivities(false)`, watching fragments can be disabled with `AndroidRefWatcherBuilder.watchFragments(false)`
+* `LeakCanary.setDisplayLeakActivityDirectoryProvider()` is deprecated and replaced with `LeakCanary.setLeakDirectoryProvider()`
+* New `RefWatcherBuilder.computeRetainedHeapSize()` API to enable the computing of the retained heap size (off by default).
+
+For more details, see the [1.6.1 Milestone](https://github.com/square/leakcanary/milestone/3) and the [full diff](https://github.com/square/leakcanary/compare/v1.5.4...v1.6.1).
+
+## Version 1.5.4 *(2017-09-22)*
+
+* Restore Java 7 compatibility in leakcanary-watcher
+
+## Version 1.5.3 *(2017-09-17)*
+
+* Fix broken 1.5.2 [build](https://github.com/square/leakcanary/issues/815)
+* Convert leakcanary-watcher from Android library to Java library
+* Disable finish animations in RequestStoragePermissionActivity
+* Corrected README sample for Robolectric tests
+
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.5.2...v1.5.3).
+
+## Version 1.5.2 *(2017-08-09)*
+
+* New excluded leaks
+* Move Leakcanary UI into leak analyzer process
+* Ignore computing retained sizes for bitmaps on O+
+* Add notification channel for persistent messages on O+
+* Exclude permission activity from recents menu
+* Updated README and sample for handling Robolectric tests
+
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.5.1...v1.5.2).
+
+## Version 1.5.1 *(2017-04-25)*
+
+* New excluded leaks
+* Fix java.util.MissingFormatArgumentException in DisplayLeakService
+* Separate task affinities for different apps
+* Bump minSdk to 14
+* Fix HahaHelper for O Preview
+
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.5...v1.5.1).
+
+## Version 1.5 *(2016-09-28)*
+
+* New excluded leaks
+* Added `LeakCanary.isInAnalyzerProcess()` to the no-op jar
+* Fixed several file access issues:
+    * No more cleanup on startup, we rotate the heap dump files on every new heap dump.
+    * LeakCanary now falls back to the app directory until it can write to the external storage.
+* Leak notifications now each use a distinct notification instead of erasing each other.
+* If LeakCanary can't perform a heap dump for any reason (e.g. analysis in progress, debugger attached), it retries later with an exponential backoff.
+* Added confirmation dialog when user deletes all leaks.
+* Replace the two LeakCanary configuration methods with a builder that provides more flexibility, see `LeakCanary.refWatcher()`.
+
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.4...v1.5).
+
+### Public API changes
+
+* New `HeapAnalyzer.findTrackedReferences()` method for headless analysis when you have no context on what leaked.
+* Added `LeakCanary.isInAnalyzerProcess()` to the no-op jar
+* Added `LeakCanary.refWatcher()` which returns an `AndroidRefWatcherBuilder` that extends `RefWatcherBuilder` and lets you fully customize the `RefWatcher` instance.
+* Removed `LeakCanary.install(Application, Class)` and `LeakCanary.androidWatcher(Context, HeapDump.Listener, ExcludedRefs)`.
+* Removed `R.integer.leak_canary_max_stored_leaks` and `R.integer.leak_canary_watch_delay_millis`, those can now be set via `LeakCanary.refWatcher()`.
+* Updated the `LeakDirectoryProvider` API to centralize all file related responsibilities.
+* `RefWatcher` is now constructed with a `WatchExecutor` which executes a `Retryable`, instead of an `Executor` that executes a `Runnable`.
+* `HeapDumper.NO_DUMP` was renamed `HeapDumper.RETRY_LATER`
+
+## Version 1.4 *(2016-09-11)*
+
+* Fix false negative where GC root is of type android.os.Binder [#482](https://github.com/square/leakcanary/issues/482)
+* Update HAHA to 2.0.3; clear compiler warnings [#563](https://github.com/square/leakcanary/issues/563)
+* Correct some mistakes in German translation [#516](https://github.com/square/leakcanary/pull/516)
+* Don't loop when storage permission denied [#422](https://github.com/square/leakcanary/issues/422)
+* Remove old references to "__" prefixed resources [#477](https://github.com/square/leakcanary/pull/477)
+* Fix permission crash for DisplayLeakActivity on M [#382](https://github.com/square/leakcanary/issues/382)
+* Fix NPE when thread name not found in heap dump [#417](https://github.com/square/leakcanary/issues/417)
+* Add version info to stacktrace [#473](https://github.com/square/leakcanary/issues/473)
+
+## Version 1.4-beta2 *(2016-03-23)*
+
+* Add reason for ignoring to analysis result [#365](https://github.com/square/leakcanary/issues/365).
+* Lower memory usage when parsing heap dumps on M [#223](https://github.com/square/leakcanary/issues/223).
+* Fix NPE in LeakCanaryInternals.isInServiceProcess() [#449](https://github.com/square/leakcanary/issues/449).
+* New ignored Android SDK leaks [#297](https://github.com/square/leakcanary/issues/297),[#322](https://github.com/square/leakcanary/issues/322).
+* Use leakcanary-android-no-op in test builds [#143](https://github.com/square/leakcanary/issues/143).
+* Fixes to allow LeakCanary to work with ProGuard [#398](https://github.com/square/leakcanary/pull/398).
+* Optimize png assets [#406](https://github.com/square/leakcanary/pull/406).
+* Fix delete button not working on error views [#408](https://github.com/square/leakcanary/pull/408).
+* Add German translation [#437](https://github.com/square/leakcanary/pull/437).
+
+## Version 1.4-beta1 *(2016-01-08)*
+
+* Switched to [HAHA 2.0.2](https://github.com/square/haha/blob/master/CHANGELOG.md#version-202-2015-07-20) with uses Perflib instead of MAT under the hood [#219](https://github.com/square/leakcanary/pull/219). This fixes crashes and improves speed a lot.
+* We can now parse Android M heap dumps [#267](https://github.com/square/leakcanary/issues/267), although there are still memory issues (see [#223](https://github.com/square/leakcanary/issues/223)).
+* Excluded leaks are now reported as well and available in the display leak activity.
+* Added ProGuard configuration for [#132](https://github.com/square/leakcanary/issues/132).
+* Many new ignored Android SDK leaks.
+* Added excluded leaks to text report [#119](https://github.com/square/leakcanary/issues/119).
+* Added LeakCanary SHA to text report [#120](https://github.com/square/leakcanary/issues/120).
+* Added CanaryLog API to replace the logger: [#201](https://github.com/square/leakcanary/issues/201).
+* Renamed all resources to begin with `leak_canary_` instead of `__leak_canary`[#161](https://github.com/square/leakcanary/pull/161)
+* No crash when heap dump fails [#226](https://github.com/square/leakcanary/issues/226).
+* Add retained size to leak reports [#162](https://github.com/square/leakcanary/issues/162).
+
+### Public API changes
+
+* AnalysisResult.failure is now a `Throwable` instead of an `Exception`. Main goal is to catch and correctly report OOMs while parsing.
+* Added ARRAY_ENTRY to LeakTraceElement.Type for references through array entries.
+* Renamed `ExcludedRefs` fields.
+* Each `ExcludedRef` entry can now be ignored entirely or "kept only if no other path".
+* Added support for ignoring all fields (static and non static) for a given class.
+
+## Version 1.3.1 *(2015-05-16)*
+
+* Heap dumps and analysis results are now saved on the sd card: [#21](https://github.com/square/leakcanary/issues/21).
+* `ExcludedRef` and `AndroidExcludedRefs` are customizable: [#12](https://github.com/square/leakcanary/issues/12) [#73](https://github.com/square/leakcanary/issues/73).
+* 7 new ignored Android SDK leaks: [#1](https://github.com/square/leakcanary/issues/1) [#4](https://github.com/square/leakcanary/issues/4) [#32](https://github.com/square/leakcanary/issues/32) [#89](https://github.com/square/leakcanary/pull/89) [#82](https://github.com/square/leakcanary/pull/82) [#97](https://github.com/square/leakcanary/pull/97).
+* Fixed 3 crashes in LeakCanary: [#37](https://github.com/square/leakcanary/issues/37) [#46](https://github.com/square/leakcanary/issues/46) [#66](https://github.com/square/leakcanary/issues/66).
+* Fixed StrictMode thread policy violations: [#15](https://github.com/square/leakcanary/issues/15).
+* Updated `minSdkVersion` from `9` to `8`: [#57](https://github.com/square/leakcanary/issues/57).
+* Added LeakCanary version name to `LeakCanary.leakInfo()`: [#49](https://github.com/square/leakcanary/issues/49).
+* `leakcanary-android-no-op` is lighter, it does not depend on `leakcanary-watcher` anymore, only 2 classes now: [#74](https://github.com/square/leakcanary/issues/74).
+* Adding field state details to the text leak trace.
+* A Toast is displayed while the heap dump is in progress to warn that the UI will freeze: [#20](https://github.com/square/leakcanary/issues/49). You can customize the toast by providing your own layout named `__leak_canary_heap_dump_toast.xml` (e.g. you could make it an empty layout).
+* If the analysis fails, the result and heap dump are kept so that it can be reported to LeakCanary: [#102](https://github.com/square/leakcanary/issues/102).
+* Update to HAHA 1.3 to fix a 2 crashes [#3](https://github.com/square/leakcanary/issues/3) [46](https://github.com/square/leakcanary/issues/46)
+
+### Public API changes
+
+* When upgrading from 1.3 to 1.3.1, previously saved heap dumps will not be readable any more, but they won't be removed from the app directory. You should probably uninstall your app.
+* Added `android.permission.WRITE_EXTERNAL_STORAGE` to `leakcanary-android` artifact.
+* `LeakCanary.androidWatcher()` parameter types have changed (+ExcludedRefs).
+* `LeakCanary.leakInfo()` parameter types have changed (+boolean)
+* `ExcludedRef` is now serializable and immutable, instances can be created using `ExcludedRef.Builder`.
+* `ExcludedRef` is available in `HeapDump`
+* `AndroidExcludedRefs` is an enum, you can now pick the leaks you want to ignore in `AndroidExcludedRefs` by creating an `EnumSet` and calling `AndroidExcludedRefs.createBuilder()`.
+* `AndroidExcludedRefs.createAppDefaults()` & `AndroidExcludedRefs.createAndroidDefaults()` return a `ExcludedRef.Builder`.
+* `ExcludedRef` moved from `leakcanary-analyzer` to `leakcanary-watcher`
+
+## Version 1.3 *(2015-05-08)*
+
+Initial release.
+
+### Dependencies
diff --git a/docs/code_of_conduct.md b/docs/code_of_conduct.md
new file mode 100644
index 00000000..6a97690c
--- /dev/null
+++ b/docs/code_of_conduct.md
@@ -0,0 +1,102 @@
+Open Source Code of Conduct
+===========================
+
+At Square, we are committed to contributing to the open source community and simplifying the process
+of releasing and managing open source software. Weâ€™ve seen incredible support and enthusiasm from
+thousands of people who have already contributed to our projectsâ€Šâ€”â€Šand we want to ensure our community
+continues to be truly open for everyone.
+
+This code of conduct outlines our expectations for participants, as well as steps to reporting
+unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and
+expect our code of conduct to be honored.
+
+Squareâ€™s open source community strives to:
+
+ * **Be open**: We invite anyone to participate in any aspect of our projects. Our community is
+   open, and any responsibility can be carried by a contributor who demonstrates the required
+   capacity and competence.
+
+ * **Be considerate**: People use our work, and we depend on the work of others. Consider users and
+   colleagues before taking action. For example, changes to code, infrastructure, policy, and
+   documentation may negatively impact others.
+
+ * **Be respectful**: We expect people to work together to resolve conflict, assume good intentions,
+   and act with empathy. Do not turn disagreements into personal attacks.
+
+ * **Be collaborative**: Collaboration reduces redundancy and improves the quality of our work. We
+   strive for transparency within our open source community, and we work closely with upstream
+   developers and others in the free software community to coordinate our efforts.
+
+ * **Be pragmatic**: Questions are encouraged and should be asked early in the process to avoid
+   problems later. Be thoughtful and considerate when seeking out the appropriate forum for your
+   questions. Those who are asked should be responsive and helpful.
+
+ * **Step down considerately**: Members of every project come and go. When somebody leaves or
+   disengages from the project, they should make it known and take the proper steps to ensure that
+   others can pick up where they left off.
+
+This code is not exhaustive or complete. It serves to distill our common understanding of a
+collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in
+the letter.
+
+Diversity Statement
+-------------------
+
+We encourage everyone to participate and are committed to building a community for all. Although we
+may not be able to satisfy everyone, we all agree that everyone is equal.
+
+Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone
+has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do
+our best to right the wrong.
+
+Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity,
+gender identity or expression, language, national origin, political beliefs, profession, race,
+religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate
+discrimination based on any of the protected characteristics above, including participants with
+disabilities.
+
+Reporting Issues
+----------------
+
+If you experience or witness unacceptable behaviorâ€Šâ€”â€Šor have any other concernsâ€Šâ€”â€Šplease report it by
+emailing [codeofconduct@squareup.com][codeofconduct_at]. For more details, please see our Reporting
+Guidelines below.
+
+Thanks
+------
+
+Some of the ideas and wording for the statements and guidelines above were based on work by the
+[Twitter][twitter_coc], [Ubuntu][ubuntu_coc], [GDC][gdc_coc], and [Django][django_coc] communities.
+We are thankful for their work.
+
+Reporting Guide
+---------------
+
+If you experience or witness unacceptable behaviorâ€Šâ€”â€Šor have any other concernsâ€Šâ€”â€Šplease report it by
+emailing [codeofconduct@squareup.com][codeofconduct_at]. All reports will be handled with
+discretion.
+
+In your report please include:
+
+ * Your contact information.
+ * Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional
+   witnesses, please include them as well.
+ * Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly
+   available record (e.g. a mailing list archive or a public IRC logger), please include a link.
+ * Any additional information that may be helpful.
+
+After filing a report, a representative from the Square Code of Conduct committee will contact you
+personally. The committee will then review the incident, follow up with any additional questions,
+and make a decision as to how to respond.
+
+Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual
+engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem
+appropriate, up to and including a permanent ban from all of Square spaces without warning.
+
+
+[codeofconduct_at]: mailto:codeofconduct@squareup.com
+[twitter_coc]: https://github.com/twitter/code-of-conduct/blob/master/code-of-conduct.md
+[ubuntu_coc]: https://ubuntu.com/community/code-of-conduct
+[gdc_coc]: https://www.gdconf.com/code-of-conduct
+[django_coc]: https://www.djangoproject.com/conduct/reporting/
+
diff --git a/docs/dev-env.md b/docs/dev-env.md
new file mode 100644
index 00000000..b4d4afa8
--- /dev/null
+++ b/docs/dev-env.md
@@ -0,0 +1,49 @@
+# Dev Environment for LeakCanary contributors
+
+## Setup
+* Download [Android Studio](https://developer.android.com/studio).
+* We use two spaces code indentation, use `SquareAndroid` code style settings from https://github.com/square/java-code-styles.
+* Build with `./gradlew build`.
+* Running the failing UI tests to confirm leak detection correctly fails UI tests: `./gradlew leakcanary-android-sample:connectedCheck`.
+* Normal UI tests: `./gradlew leakcanary-android-core:connectedCheck`.
+
+## Static Code Analysis 
+* LeakCanary [uses](https://github.com/square/leakcanary/pull/1535) [Detekt](https://arturbosch.github.io/detekt/) for static Code analysis.
+* Analyze the entire project with `./gradlew check` or particular modules with `./gradlew :module-name:check`. Detekt will fail the build if any ruleset violations are found. **You should fix all issues before pushing the branch to remote**.
+  * There's also a **git pre-push** hook that will run analysis automatically before pushing a branch to the remote. If there are any violations - it will prevent the push. Fix the issues!
+  * You can bypass the git hook though; Travis CI will still run checks and will fail if any violations are found. 
+* Detekt report will be printed in the console and saved to `/moduleDir/build/reports/`.
+
+## Deploying locally
+
+To deploy LeakCanary to your local maven repository, run the following command, changing the path to the path of your local repository:
+
+```
+./gradlew uploadArchives -PSNAPSHOT_REPOSITORY_URL=file:///Users/py/.m2/repository
+```
+
+Then add the SNAPSHOT dependency and `mavenLocal()` repository to your project:
+
+```gradle
+dependencies {
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:{{ leak_canary.next_release }}-SNAPSHOT'
+}
+
+repositories {
+  mavenLocal()
+}
+```
+
+## Deploying the docs locally
+
+Installing or updating the docs dependencies:
+
+```
+pip install --requirement docs/requirements.txt
+```
+
+Deploying locally
+
+```
+mkdocs serve
+```
diff --git a/docs/faq.md b/docs/faq.md
new file mode 100644
index 00000000..5615723a
--- /dev/null
+++ b/docs/faq.md
@@ -0,0 +1,104 @@
+# FAQ
+
+## Can a leak be caused by the Android SDK?
+
+Yes. There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to recognize, called Library Leaks (see [Categorizing leaks](fundamentals-how-leakcanary-works.md#4-categorizing-leaks)).
+
+If you find a new one, please [create an issue](https://github.com/square/leakcanary/issues/new/choose) (choose **ðŸ¤–Leak in Android SDK / support library**) and follow these steps:
+
+1. Provide the entire leak trace information (including metadata), and use backticks (`) for formatting.
+2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions by switching branches on the GitHub mirror: [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
+3. Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed.
+4. If it's still happening, build a simple repro case.
+5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case. Please remember to follow up the issue when there are new responses. [b/176886060](https://issuetracker.google.com/issues/176886060) is a good example of effective and respectful communication.
+6. Create a PR in LeakCanary to update [AndroidReferenceMatchers](/leakcanary/api/shark-android/shark/-android-reference-matchers/). Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
+
+## How do I know if LeakCanary is running?
+
+You can confirm that LeakCanary starts correctly by filtering on the LeakCanary tag in Logcat:
+
+```
+$ adb logcat | grep LeakCanary
+
+D/LeakCanary: Installing AppWatcher
+```
+
+If you do not see `Installing AppWatcher` in the logs, check your dependencies (`./gradlew app:dependencies`) and make sure LeakCanary is there.
+
+Note that LeakCanary is automatically disabled in tests (see [LeakCanary test environment detection](recipes.md#leakcanary-test-environment-detection)):
+
+```
+$ adb logcat | grep LeakCanary
+
+D/LeakCanary: Installing AppWatcher
+D/LeakCanary: JUnit detected in classpath, app is running tests => disabling heap dumping & analysis
+D/LeakCanary: Updated LeakCanary.config: Config(dumpHeap=false)
+```
+
+## Where does LeakCanary store heap dumps?
+
+The default behavior is to store heap dumps in a `leakcanary` folder under the app directory. If the app has been granted the `android.permission.WRITE_EXTERNAL_STORAGE` permission, then heap dumps will be stored
+in a `leakcanary-com.example` folder (where `com.example` is your app package name) under the `Download` folder of the external storage. If the app has not been granted the `android.permission.WRITE_EXTERNAL_STORAGE` permission but that permission is listed in `AndroidManifest.xml` then LeakCanary will show a notification that can be tapped to grant permission.
+
+## How can I dig beyond the leak trace?
+
+Sometimes the leak trace isn't enough and you need to dig into a heap dump with [MAT](http://eclipse.org/mat/) or [YourKit](https://www.yourkit.com/).
+
+* Go to a heap analysis screen, click the overflow menu and select *Share Heap Dump*.
+
+Here's how you can find the leaking instance in the heap dump:
+
+1. Look for all instances of `leakcanary.KeyedWeakReference`.
+2. For each of these, look at the `key` field.
+3. Find the `KeyedWeakReference` that has a `key` field equal to the reference key reported by LeakCanary.
+4. The `referent` field of that `KeyedWeakReference` is your leaking object.
+5. From then on, the matter is in your hands. A good start is to look at the shortest path to GC Roots (excluding weak references).
+
+## How does LeakCanary get installed by only adding a dependency?
+
+On Android, content providers are created after the Application instance is created but before Application.onCreate() is called. The `leakcanary-object-watcher-android` artifact has a non exported ContentProvider defined in its `AndroidManifest.xml` file. When that ContentProvider is installed, it adds activity and fragment lifecycle listeners to the application.
+
+## How many methods does LeakCanary add?
+
+**0**. LeakCanary is a debug only library.
+
+## How do I use the SNAPSHOT version?
+
+Update your dependencies to the latest SNAPSHOT (see [build.gradle](https://github.com/square/leakcanary/blob/main/build.gradle)):
+
+```gradle
+dependencies {
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:{{ leak_canary.next_release }}-SNAPSHOT'
+}
+```
+
+Add Sonatype's `snapshots` repository:
+
+```gradle
+repositories {
+  mavenCentral()
+  maven {
+    url 'https://s01.oss.sonatype.org/content/repositories/snapshots/'
+  }
+}
+```
+
+Status of the snapshot build: [![Build Status](https://travis-ci.org/square/leakcanary.svg?branch=main)](https://travis-ci.org/square/leakcanary)
+
+## Who's behind LeakCanary?
+
+LeakCanary was created and open sourced by [@pyricau](https://github.com/pyricau), with [many contributions](https://github.com/square/leakcanary/graphs/contributors) from the community.
+
+## Why is it called LeakCanary?
+
+The name **LeakCanary** is a reference to the expression [canary in a coal mine](http://en.wiktionary.org/wiki/canary_in_a_coal_mine), because LeakCanary is a sentinel used to detect risks by providing advance warning of a danger. Props to [@edenman](https://github.com/edenman) for suggesting it!
+
+## Who made the logo?
+
+* [@pyricau](https://github.com/pyricau) quickly made the [first version](https://github.com/square/leakcanary/blob/f0cc04dfbf3cca92a669f0d250034d410eb05816/assets/icon_512.png) of the logo. It was based on cliparts from [Android Asset Studio](http://romannurik.github.io/AndroidAssetStudio/icons-generic.html), mixed with the selection from a photo of a Canary. The exclamation mark means danger, the shield stands for protection, and the bird, well, is a canary.
+* [@romainguy](https://github.com/romainguy) turned the ugly logo into [a nice vector asset](https://github.com/square/leakcanary/pull/36).
+* [@flickator](https://github.com/flickator) designed [a much nicer logo](https://github.com/square/leakcanary/pull/1269) for LeakCanary 2.0!
+
+<p align="center">
+<img src="../images/logo-2.0.png" />
+</p>
diff --git a/docs/fundamentals-fixing-a-memory-leak.md b/docs/fundamentals-fixing-a-memory-leak.md
new file mode 100644
index 00000000..67ed4645
--- /dev/null
+++ b/docs/fundamentals-fixing-a-memory-leak.md
@@ -0,0 +1,250 @@
+A memory leak is a programming error that causes an application to keep a reference to an object that is no longer needed. Somewhere in the code, there's a reference that should have been cleared and wasn't.
+
+Follow these 4 steps to fix memory leaks:
+
+1. Find the leak trace.
+2. Narrow down the suspect references.
+3. Find the reference causing the leak.
+4. Fix the leak.
+
+LeakCanary helps you with the first two steps. The last two steps are up to you!
+
+## 1. Find the leak trace
+
+A **leak trace** is a shorter name for the *best strong reference path from garbage collection roots to the retained object*, ie the path of references that is holding an object in memory, therefore preventing it from being garbage collected.
+
+For example, let's store a helper singleton in a static field:
+
+```java
+class Helper {
+}
+
+class Utils {
+  public static Helper helper = new Helper();
+}
+```
+
+Let's tell LeakCanary that the singleton instance is expected to be garbage collected:
+
+```
+AppWatcher.objectWatcher.watch(Utils.helper)
+```
+
+The leak trace for that singleton looks like this:
+
+```
+â”¬â”€â”€â”€
+â”‚ GC Root: Local variable in native code
+â”‚
+â”œâ”€ dalvik.system.PathClassLoader instance
+â”‚    â†“ PathClassLoader.runtimeInternalObjects
+â”œâ”€ java.lang.Object[] array
+â”‚    â†“ Object[].[43]
+â”œâ”€ com.example.Utils class
+â”‚    â†“ static Utils.helper
+â•°â†’ java.example.Helper
+```
+
+Let's break it down! At the top, a `PathClassLoader` instance is held by a **garbage collection (GC) root**, more specifically a local variable in native code. GC roots are special objects that are always reachable, ie they cannot be garbage collected. There are 4 main types of GC root:
+
+* **Local variables**, which belong to the stack of a thread.
+* Instances of **active Java threads**.
+* **System Classes**, which never unload.
+* **Native references**, which are controlled by native code.
+
+```
+â”¬â”€â”€â”€
+â”‚ GC Root: Local variable in native code
+â”‚
+â”œâ”€ dalvik.system.PathClassLoader instance
+```
+
+A line starting with `â”œâ”€ ` represents a Java object (either a class, an object array or an instance), and a line starting with `â”‚    â†“ ` represents a reference to the Java object on the next line.
+
+`PathClassLoader` has a `runtimeInternalObjects` field that is a reference to an array of `Object`:
+
+```
+â”œâ”€ dalvik.system.PathClassLoader instance
+â”‚    â†“ PathClassLoader.runtimeInternalObjects
+â”œâ”€ java.lang.Object[] array
+```
+
+The element at position 43 in that array of `Object` is a reference to the `Utils` class.
+
+```
+â”œâ”€ java.lang.Object[] array
+â”‚    â†“ Object[].[43]
+â”œâ”€ com.example.Utils class
+```
+
+A line starting with `â•°â†’ ` represents the leaking object, ie the object that is passed to [AppWatcher.objectWatcher.watch()](/leakcanary/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/object-watcher/).
+
+The `Utils` class has a static `helper` field which is a reference to the leaking object, which is the Helper singleton instance:
+
+```
+â”œâ”€ com.example.Utils class
+â”‚    â†“ static Utils.helper
+â•°â†’ java.example.Helper instance
+```
+
+## 2. Narrow down the suspect references
+
+A leak trace is a path of references. Initially, all references in that path are suspected of causing the leak, but LeakCanary can automatically narrow down the suspect references. To understand what that means, let's go through that process manually.
+
+Here's an example of bad Android code:
+
+```kotlin
+class ExampleApplication : Application() {
+  val leakedViews = mutableListOf<View>()
+}
+
+class MainActivity : Activity() {
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+    setContentView(R.layout.main_activity)
+
+	val textView = findViewById<View>(R.id.helper_text)
+
+    val app = application as ExampleApplication
+	// This creates a leak, What a Terrible Failure!
+	app.leakedViews.add(textView)
+  }
+}
+```
+
+LeakCanary produces a leak trace that looks like this:
+
+```
+â”¬â”€â”€â”€
+â”‚ GC Root: System class
+â”‚
+â”œâ”€ android.provider.FontsContract class
+â”‚    â†“ static FontsContract.sContext
+â”œâ”€ com.example.leakcanary.ExampleApplication instance
+â”‚    â†“ ExampleApplication.leakedViews
+â”œâ”€ java.util.ArrayList instance
+â”‚    â†“ ArrayList.elementData
+â”œâ”€ java.lang.Object[] array
+â”‚    â†“ Object[].[0]
+â”œâ”€ android.widget.TextView instance
+â”‚    â†“ TextView.mContext
+â•°â†’ com.example.leakcanary.MainActivity instance
+```
+
+Here's how to read that leak trace:
+
+> The `FontsContract` class is a system class (see `GC Root: System class`) and has an `sContext` static field which references an `ExampleApplication` instance which has a `leakedViews` field which references an `ArrayList` instance which references an array (the array backing the array list implementation) which has an element that references a `TextView` which has an `mContext` field which references a destroyed instance of `MainActivity`.
+
+LeakCanary highlights all references suspected of causing this leak using ~~~ underlines. Initially, all references are suspect:
+
+```
+â”¬â”€â”€â”€
+â”‚ GC Root: System class
+â”‚
+â”œâ”€ android.provider.FontsContract class
+â”‚    â†“ static FontsContract.sContext
+â”‚                           ~~~~~~~~
+â”œâ”€ com.example.leakcanary.ExampleApplication instance
+â”‚    Leaking: NO (Application is a singleton)
+â”‚    â†“ ExampleApplication.leakedViews
+â”‚                         ~~~~~~~~~~~
+â”œâ”€ java.util.ArrayList instance
+â”‚    â†“ ArrayList.elementData
+â”‚                ~~~~~~~~~~~
+â”œâ”€ java.lang.Object[] array
+â”‚    â†“ Object[].[0]
+â”‚               ~~~
+â”œâ”€ android.widget.TextView instance
+â”‚    â†“ TextView.mContext
+â”‚               ~~~~~~~~
+â•°â†’ com.example.leakcanary.MainActivity instance
+```
+
+Then, LeakCanary makes deductions about the **state** and the **lifecycle** of the objects in the leak trace. In an Android app the `Application` instance is a singleton that is never garbage collected, so it's never leaking (`Leaking: NO (Application is a singleton)`). From that, LeakCanary concludes that the leak is not caused by `FontsContract.sContext` (removal of corresponding `~~~`). Here's the updated leak trace:
+
+```
+â”¬â”€â”€â”€
+â”‚ GC Root: System class
+â”‚
+â”œâ”€ android.provider.FontsContract class
+â”‚    â†“ static FontsContract.sContext
+â”œâ”€ com.example.leakcanary.ExampleApplication instance
+â”‚    Leaking: NO (Application is a singleton)
+â”‚    â†“ ExampleApplication.leakedViews
+â”‚                         ~~~~~~~~~~~
+â”œâ”€ java.util.ArrayList instance
+â”‚    â†“ ArrayList.elementData
+â”‚                ~~~~~~~~~~~
+â”œâ”€ java.lang.Object[] array
+â”‚    â†“ Object[].[0]
+â”‚               ~~~
+â”œâ”€ android.widget.TextView instance
+â”‚    â†“ TextView.mContext
+â”‚               ~~~~~~~~
+â•°â†’ com.example.leakcanary.MainActivity instance
+```
+
+The `TextView` instance references the destroyed `MainActivity` instance via it's `mContext` field. Views should not survive the lifecycle of their context, so LeakCanary knows that this `TextView` instance is leaking (`Leaking: YES (View.mContext references a destroyed activity)`), and therefore that the leak is not caused by `TextView.mContext` (removal of corresponding `~~~`). Here's the updated leak trace:
+
+```
+â”¬â”€â”€â”€
+â”‚ GC Root: System class
+â”‚
+â”œâ”€ android.provider.FontsContract class
+â”‚    â†“ static FontsContract.sContext
+â”œâ”€ com.example.leakcanary.ExampleApplication instance
+â”‚    Leaking: NO (Application is a singleton)
+â”‚    â†“ ExampleApplication.leakedViews
+â”‚                         ~~~~~~~~~~~
+â”œâ”€ java.util.ArrayList instance
+â”‚    â†“ ArrayList.elementData
+â”‚                ~~~~~~~~~~~
+â”œâ”€ java.lang.Object[] array
+â”‚    â†“ Object[].[0]
+â”‚               ~~~
+â”œâ”€ android.widget.TextView instance
+â”‚    Leaking: YES (View.mContext references a destroyed activity)
+â”‚    â†“ TextView.mContext
+â•°â†’ com.example.leakcanary.MainActivity instance
+```
+
+To summarize, LeakCanary inspects the state of objects in the leak trace to figure out if these objects are leaking (`Leaking: YES` vs `Leaking: NO`), and leverages that information to narrow down the suspect references. You can provide custom `ObjectInspector` implementations to improve how LeakCanary works in your codebase (see [Identifying leaking objects and labeling objects](recipes.md#identifying-leaking-objects-and-labeling-objects)).
+
+## 3. Find the reference causing the leak
+
+In the previous example, LeakCanary narrowed down the suspect references to `ExampleApplication.leakedViews`, `ArrayList.elementData` and `Object[].[0]`:
+
+```
+â”¬â”€â”€â”€
+â”‚ GC Root: System class
+â”‚
+â”œâ”€ android.provider.FontsContract class
+â”‚    â†“ static FontsContract.sContext
+â”œâ”€ com.example.leakcanary.ExampleApplication instance
+â”‚    Leaking: NO (Application is a singleton)
+â”‚    â†“ ExampleApplication.leakedViews
+â”‚                         ~~~~~~~~~~~
+â”œâ”€ java.util.ArrayList instance
+â”‚    â†“ ArrayList.elementData
+â”‚                ~~~~~~~~~~~
+â”œâ”€ java.lang.Object[] array
+â”‚    â†“ Object[].[0]
+â”‚               ~~~
+â”œâ”€ android.widget.TextView instance
+â”‚    Leaking: YES (View.mContext references a destroyed activity)
+â”‚    â†“ TextView.mContext
+â•°â†’ com.example.leakcanary.MainActivity instance
+```
+
+`ArrayList.elementData` and `Object[].[0]` are implementation details of `ArrayList`, and it's unlikely that there's a bug in the `ArrayList` implementation, so the reference causing the leak is the only remaining reference: `ExampleApplication.leakedViews`.
+
+## 4. Fix the leak
+
+Once you find the reference causing the leak, you need to figure out what that reference is about, when it should have been cleared and why it hasn't been. Sometimes it's obvious, like in the previous example. Sometimes you need more information to figure it out. You can [add labels](recipes.md#identifying-leaking-objects-and-labeling-objects), or explore the hprof directly (see [How can I dig beyond the leak trace?](faq.md#how-can-i-dig-beyond-the-leak-trace)).
+
+
+!!! warning
+    Memory leaks cannot be fixed by replacing strong references with weak references. It's a common solution when attempting to quickly address memory issues, however it never works. The bugs that were causing references to be kept longer than necessary are still there. On top of that, it creates more bugs as some objects will now be garbage collected sooner than they should. It also makes the code much harder to maintain.
+
+
+What's next? Customize LeakCanary to your needs with [code recipes](recipes.md)!
diff --git a/docs/fundamentals-how-leakcanary-works.md b/docs/fundamentals-how-leakcanary-works.md
new file mode 100644
index 00000000..842c16b8
--- /dev/null
+++ b/docs/fundamentals-how-leakcanary-works.md
@@ -0,0 +1,195 @@
+Once LeakCanary is installed, it automatically detects and report memory leaks, in 4 steps:
+
+1. Detecting retained objects.
+2. Dumping the heap.
+3. Analyzing the heap.
+4. Categorizing leaks.
+
+## 1. Detecting retained objects
+
+LeakCanary hooks into the Android lifecycle to automatically detect when activities and fragments are destroyed and should be garbage collected. These destroyed objects are passed to an `ObjectWatcher`, which holds [weak references](https://en.wikipedia.org/wiki/Weak_reference) to them. LeakCanary automatically detects leaks for the following objects:
+
+* destroyed `Activity` instances
+* destroyed `Fragment` instances
+* destroyed fragment `View` instances
+* cleared `ViewModel` instances
+
+You can watch any objects that is no longer needed, for example a detached view or a destroyed presenter:
+
+```kotlin
+AppWatcher.objectWatcher.watch(myDetachedView, "View was detached")
+```
+
+If the weak reference held by `ObjectWatcher` isn't cleared after **waiting 5 seconds** and running garbage collection, the watched object is considered **retained**, and potentially leaking. LeakCanary logs this to Logcat:
+
+```
+D LeakCanary: Watching instance of com.example.leakcanary.MainActivity
+  (Activity received Activity#onDestroy() callback) 
+
+... 5 seconds later ...
+
+D LeakCanary: Scheduling check for retained objects because found new object
+  retained
+```
+
+LeakCanary waits for the count of retained objects to reach a threshold before dumping the heap, and displays a notification with the latest count.
+
+![notification](images/retained-notification.png)
+**Figure 1.** LeakCanary found 4 retained objects.
+
+```
+D LeakCanary: Rescheduling check for retained objects in 2000ms because found
+  only 4 retained objects (< 5 while app visible)
+```
+
+!!! info
+    The default threshold is **5 retained objects** when the app is **visible**, and **1 retained object** when the app is **not visible**. If you see the retained objects notification and then put the app in background (for example by pressing the Home button), then the threshold changes from 5 to 1 and LeakCanary dumps the heap within 5 seconds. Tapping the notification forces LeakCanary to dump the heap immediately.
+
+## 2. Dumping the heap
+
+When the count of retained objects reaches a threshold, LeakCanary dumps the Java heap into a `.hprof` file (a **heap dump**) stored onto the Android file system (see [Where does LeakCanary store heap dumps?](faq.md#where-does-leakcanary-store-heap-dumps)). Dumping the heap freezes the app for a short amount of time, during which LeakCanary displays the following toast:
+
+![toast](images/dumping-toast.png)
+**Figure 2.** LeakCanary shows a [toast](https://developer.android.com/guide/topics/ui/notifiers/toasts) while dumping the heap.
+
+## 3. Analyzing the heap
+
+LeakCanary parses the `.hprof` file using [Shark](shark.md) and locates the retained objects in that heap dump.
+
+![done](images/finding-retained-notification.png)
+**Figure 3.** LeakCanary finds retained objects in the heap dump.
+
+For each retained object, LeakCanary finds the path of references that prevents that retained object from being garbage collected: its **leak trace**. You will learn to analyze a leak trace in the next section: [Fixing a memory leak](fundamentals-fixing-a-memory-leak.md).
+
+![done](images/building-leak-traces-notification.png)
+**Figure 4.** LeakCanary computes the leak trace for each retained object.
+
+When the analysis is done, LeakCanary displays a **notification** with a summary, and also prints the result in **Logcat**. Notice below how the **4 retained objects** are grouped as **2 distinct leaks**. LeakCanary creates a **signature for each leak trace**, and groups together leaks that have the same signature, ie leaks that are caused by the same bug.
+
+![done](images/analysis-done.png)
+**Figure 5.** The 4 leak traces turned into 2 distinct leak signatures.
+
+
+```
+====================================
+HEAP ANALYSIS RESULT
+====================================
+2 APPLICATION LEAKS
+
+Displaying only 1 leak trace out of 2 with the same signature
+Signature: ce9dee3a1feb859fd3b3a9ff51e3ddfd8efbc6
+â”¬â”€â”€â”€
+â”‚ GC Root: Local variable in native code
+â”‚
+...
+```
+
+Tapping the notification starts an activity that provides more details. Come back to it again later by tapping the LeakCanary launcher icon:
+
+![toast](images/launcher.png)
+**Figure 6.** LeakCanary adds a launcher icon for each app it's installed in.
+
+Each row corresponds to a **group of leaks with the same signature**. LeakCanary  marks a row as <span style="border-radius: 20px; background: #ffd24c; padding-left: 8px; padding-right: 8px; padding-top: 2px; padding-bottom: 2px; color: #141c1f;">New</span> the first time the app triggers a leak with that signature.
+
+![toast](images/heap-dump.png)
+**Figure 7.** The 4 leaks grouped into 2 rows, one for each distinct leak signature.
+
+Tap on a leak to open up a screen with the leak trace. You can toggle between retained objects and their leak trace via a drop down.
+
+![toast](images/leak-screen.png)
+**Figure 8.** A screen showing 3 leaks grouped by their common leak signature.
+
+The **leak signature** is the **hash of the concatenation of each <span style="color: #9976a8;">reference</span> suspected to cause the leak**, ie each reference **<span style="text-decoration: underline; text-decoration-color: red; text-decoration-style: wavy; color: #9976a8;">displayed with a red underline</span>**:
+
+![toast](images/signature.png)
+**Figure 9.** A leak trace with 3 suspect references.
+
+These same suspicious references are underlined with `~~~` when the leak trace is shared as text:
+
+```
+...
+â”‚  
+â”œâ”€ com.example.leakcanary.LeakingSingleton class
+â”‚    Leaking: NO (a class is never leaking)
+â”‚    â†“ static LeakingSingleton.leakedViews
+â”‚                              ~~~~~~~~~~~
+â”œâ”€ java.util.ArrayList instance
+â”‚    Leaking: UNKNOWN
+â”‚    â†“ ArrayList.elementData
+â”‚                ~~~~~~~~~~~
+â”œâ”€ java.lang.Object[] array
+â”‚    Leaking: UNKNOWN
+â”‚    â†“ Object[].[0]
+â”‚               ~~~
+â”œâ”€ android.widget.TextView instance
+â”‚    Leaking: YES (View.mContext references a destroyed activity)
+...
+```
+
+In the example above, the signature of the leak would be computed as:
+
+```kotlin
+val leakSignature = sha1Hash(
+    "com.example.leakcanary.LeakingSingleton.leakedView" +
+    "java.util.ArrayList.elementData" +
+    "java.lang.Object[].[x]"
+)
+println(leakSignature)
+// dbfa277d7e5624792e8b60bc950cd164190a11aa
+```
+
+## 4. Categorizing leaks
+
+LeakCanary separates the leaks it finds in your app into two categories: **Application Leaks** and **Library Leaks**. A **Library Leak** is a leak caused by a known bug in 3rd party code that you do not have control over. This leak is impacting your application, but unfortunately fixing it may not be in your control so LeakCanary separates it out.
+
+The two categories are separated in the result printed in **Logcat**:
+
+```
+====================================
+HEAP ANALYSIS RESULT
+====================================
+0 APPLICATION LEAKS
+
+====================================
+1 LIBRARY LEAK
+
+...
+â”¬â”€â”€â”€
+â”‚ GC Root: Local variable in native code
+â”‚
+...
+```
+
+LeakCanary marks a row as a <span style="border-radius: 20px; background: #4e462f; padding-left: 8px; padding-right: 8px; padding-top: 2px; padding-bottom: 2px; color: #ffcc32;">Library Leak</span> in its list of leaks:
+
+![Library Leak](images/library-leak.png)
+**Figure 10.** LeakCanary found a Library Leak.
+
+LeakCanary ships with a database of known leaks, which it recognizes by pattern matching on reference names. For example:
+
+```
+Leak pattern: instance field android.app.Activity$1#this$0
+Description: Android Q added a new IRequestFinishCallback$Stub class [...]
+â”¬â”€â”€â”€
+â”‚ GC Root: Global variable in native code
+â”‚
+â”œâ”€ android.app.Activity$1 instance
+â”‚    Leaking: UNKNOWN
+â”‚    Anonymous subclass of android.app.IRequestFinishCallback$Stub
+â”‚    â†“ Activity$1.this$0
+â”‚                 ~~~~~~
+â•°â†’ com.example.MainActivity instance
+```
+
+!!! quote "What did I do to cause this leak?"
+    Nothing wrong! You used an API the way it was intended but the implementation has a bug that is causing this leak.
+
+!!! quote "Is there anything I can do to prevent it?"
+    Maybe! Some Library Leaks can be fixed using reflection, others by exercising a code path that makes the leak go away. This type of fix tends to be hacky, so beware! Your best option might be to find the bug report or file one, and insist that the bug gets fixed.
+
+!!! quote "Since I can't do much about this leak, is there a way I can ask LeakCanary to ignore it?"
+	There's no way for LeakCanary to know whether a leak is a Library Leak prior to dumping the heap and analyzing it. If LeakCanary didn't show the result notification when a Library Leak is found then you'd start wondering what happened to the LeakCanary analysis after the dumping toast.
+
+You can see the full list of known leaks in the [AndroidReferenceMatchers](https://github.com/square/leakcanary/blob/main/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt#L49) class. If you find an Android SDK leak that isn't recognized, please [report it](faq.md#can-a-leak-be-caused-by-the-android-sdk). You can also [customize the list of known Library Leaks](recipes.md#matching-known-library-leaks).
+
+What's next? Learn how to [fix a memory leak](fundamentals-fixing-a-memory-leak.md)!
diff --git a/docs/fundamentals.md b/docs/fundamentals.md
new file mode 100644
index 00000000..63bafea3
--- /dev/null
+++ b/docs/fundamentals.md
@@ -0,0 +1,24 @@
+The fundamentals describe how LeakCanary works and how to use it to detect and fix memory leaks. This documentation is designed to help developers of all levels, so please don't hesitate to report any confusing section.
+
+## What is a memory leak?
+
+In a Java based runtime, a memory leak is a programming error that causes an application to keep a reference to an object that is no longer needed. As a result, the memory allocated for that object cannot be reclaimed, eventually leading to an **OutOfMemoryError (OOM)** crash.
+
+For example, an Android `Activity` instance is no longer needed after its `onDestroy()` method is called, and storing a reference to that instance in a static field prevents it from being garbage collected.
+
+## Common causes for memory leaks
+
+Most memory leaks are caused by bugs related to the lifecycle of objects. Here are a few common Android mistakes:
+
+* Adding a `Fragment` instance to the backstack without clearing that Fragment's view fields in `Fragment.onDestroyView()` (more details in [this StackOverflow answer](https://stackoverflow.com/a/59504797/703646)).
+* Storing an `Activity` instance as a `Context` field in an object that survives activity recreation due to configuration changes.
+* Registering a listener, broadcast receiver or RxJava subscription which references an object with lifecycle, and forgetting to unregister when the lifecycle reaches its end.
+
+## Why should I use LeakCanary?
+
+Memory leaks are very common in Android apps and the accumulation of small memory leaks causes apps to run out of memory and crash with an OOM. LeakCanary will help you find and fix these memory leaks during development. When Square engineers first enabled LeakCanary in the Square Point Of Sale app, they were able to fix several leaks and reduced the OOM crash rate by **94%**.
+
+!!! info
+    **Your crash reporting tool might not correctly report OOMs**. When memory is low because of memory leak accumulation, an OOM can be thrown from anywhere in the app code, which means that every OOM has a different stacktrace. So instead of one crash entry with a 1000 crashes, OOMs get reported as 1000 distinct crashes and hide in the long tail of low occurring crashes.
+
+What's next? Learn [how LeakCanary works](fundamentals-how-leakcanary-works.md)!
\ No newline at end of file
diff --git a/docs/getting_started.md b/docs/getting_started.md
new file mode 100644
index 00000000..31b268b6
--- /dev/null
+++ b/docs/getting_started.md
@@ -0,0 +1,29 @@
+# Getting started
+
+To use LeakCanary, add the `leakcanary-android` dependency to your app's `build.gradle` file:
+
+```groovy
+dependencies {
+  // debugImplementation because LeakCanary should only run in debug builds.
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:{{ leak_canary.release }}'
+}
+```
+
+**That's it, there is no code change needed!**
+
+Confirm that LeakCanary is running on startup by filtering on the `LeakCanary` tag in [Logcat](https://developer.android.com/studio/command-line/logcat):
+
+```
+D LeakCanary: LeakCanary is running and ready to detect leaks
+```
+
+!!! info
+    LeakCanary automatically detects leaks of the following objects:
+    
+    * destroyed `Activity` instances
+    * destroyed `Fragment` instances
+    * destroyed fragment `View` instances
+    * cleared `ViewModel` instances
+    * destroyed `Service` instance
+
+What's next? Learn the [Fundamentals](fundamentals.md)!
diff --git a/docs/how_to_help.md b/docs/how_to_help.md
new file mode 100644
index 00000000..c69cebb9
--- /dev/null
+++ b/docs/how_to_help.md
@@ -0,0 +1,12 @@
+# How to help
+
+ðŸ™ðŸ™ðŸ™
+
+LeakCanary is maintained by volunteers. Your help is welcome and will benefit the entire Android community!
+
+Here's how you can help:
+
+* Contribute to [Help Wanted](https://github.com/square/leakcanary/issues?q=is%3Aissue+is%3Aopen+label%3A%22status%3A+help+wanted%22) issues.
+* Answer [StackOverflow questions](http://stackoverflow.com/questions/tagged/leakcanary?sort=active).
+* Provide feedback on [pull requests](https://github.com/square/leakcanary/pulls).
+* Contribute code by forking the repository on GitHub and sending a pull request. Please read [Dev Environment for LeakCanary contributors](dev-env.md). When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible.
diff --git a/docs/images/analysis-done.png b/docs/images/analysis-done.png
new file mode 100644
index 00000000..8995a2e5
Binary files /dev/null and b/docs/images/analysis-done.png differ
diff --git a/docs/images/android-tv-leaks.png b/docs/images/android-tv-leaks.png
new file mode 100644
index 00000000..73168ded
Binary files /dev/null and b/docs/images/android-tv-leaks.png differ
diff --git a/docs/images/bugsnag-leak.png b/docs/images/bugsnag-leak.png
new file mode 100644
index 00000000..2b0a4b4e
Binary files /dev/null and b/docs/images/bugsnag-leak.png differ
diff --git a/docs/images/bugsnag-list.png b/docs/images/bugsnag-list.png
new file mode 100644
index 00000000..64638754
Binary files /dev/null and b/docs/images/bugsnag-list.png differ
diff --git a/docs/images/building-leak-traces-notification.png b/docs/images/building-leak-traces-notification.png
new file mode 100644
index 00000000..5ab95a24
Binary files /dev/null and b/docs/images/building-leak-traces-notification.png differ
diff --git a/docs/images/disable_dumping.png b/docs/images/disable_dumping.png
new file mode 100644
index 00000000..57d90880
Binary files /dev/null and b/docs/images/disable_dumping.png differ
diff --git a/docs/images/dumping-toast.png b/docs/images/dumping-toast.png
new file mode 100644
index 00000000..777ee5a3
Binary files /dev/null and b/docs/images/dumping-toast.png differ
diff --git a/docs/images/finding-retained-notification.png b/docs/images/finding-retained-notification.png
new file mode 100644
index 00000000..89c1066e
Binary files /dev/null and b/docs/images/finding-retained-notification.png differ
diff --git a/docs/images/heap-dump.png b/docs/images/heap-dump.png
new file mode 100644
index 00000000..19a94732
Binary files /dev/null and b/docs/images/heap-dump.png differ
diff --git a/docs/images/launcher.png b/docs/images/launcher.png
new file mode 100644
index 00000000..a496ab30
Binary files /dev/null and b/docs/images/launcher.png differ
diff --git a/docs/images/leak-screen.png b/docs/images/leak-screen.png
new file mode 100644
index 00000000..64feffde
Binary files /dev/null and b/docs/images/leak-screen.png differ
diff --git a/docs/images/library-leak.png b/docs/images/library-leak.png
new file mode 100644
index 00000000..70cba7b4
Binary files /dev/null and b/docs/images/library-leak.png differ
diff --git a/docs/images/logo-2.0-200px.png b/docs/images/logo-2.0-200px.png
new file mode 100644
index 00000000..005fd285
Binary files /dev/null and b/docs/images/logo-2.0-200px.png differ
diff --git a/docs/images/logo-2.0.png b/docs/images/logo-2.0.png
new file mode 100644
index 00000000..e1b3e927
Binary files /dev/null and b/docs/images/logo-2.0.png differ
diff --git a/docs/images/logo.png b/docs/images/logo.png
new file mode 100644
index 00000000..1c33a1de
Binary files /dev/null and b/docs/images/logo.png differ
diff --git a/docs/images/retained-notification.png b/docs/images/retained-notification.png
new file mode 100644
index 00000000..98a7a1e8
Binary files /dev/null and b/docs/images/retained-notification.png differ
diff --git a/docs/images/screenshot-2.0.png b/docs/images/screenshot-2.0.png
new file mode 100644
index 00000000..d10b1e18
Binary files /dev/null and b/docs/images/screenshot-2.0.png differ
diff --git a/docs/images/shark.png b/docs/images/shark.png
new file mode 100644
index 00000000..4afe96f3
Binary files /dev/null and b/docs/images/shark.png differ
diff --git a/docs/images/signature.png b/docs/images/signature.png
new file mode 100644
index 00000000..05780be8
Binary files /dev/null and b/docs/images/signature.png differ
diff --git a/docs/index.md b/docs/index.md
new file mode 100644
index 00000000..a5622f22
--- /dev/null
+++ b/docs/index.md
@@ -0,0 +1,17 @@
+# LeakCanary ðŸ¤
+
+LeakCanary is a memory leak detection library for Android.
+
+<p align="center">
+<img src="images/screenshot-2.0.png" />
+</p>
+
+LeakCanary's knowledge of the internals of the Android Framework gives it a unique ability to narrow
+down the cause of each leak, helping developers dramatically reduce `Application Not Responding`
+freezes and `OutOfMemoryError` crashes.
+
+[Get started!](getting_started.md)
+
+!!! quote
+    *â€œA small leak will sink a great ship.â€* - Benjamin Franklin
+
diff --git a/docs/leakcanary-for-releases.md b/docs/leakcanary-for-releases.md
new file mode 100644
index 00000000..0f92591f
--- /dev/null
+++ b/docs/leakcanary-for-releases.md
@@ -0,0 +1,134 @@
+### LeakCanary for releases
+
+Fixing leaks found in debug builds helps reduce `Application Not Responding` freezes and
+`OutfOfMemoryError` error crashes, but only scratches the surface of all the leaks that can happen.
+For the leaks that are found in debug builds, it's hard to determine which leaks to fix first.
+
+This situation is very similar to debug crashes, where we are
+often unable to make an accurate assessment of their future impact in a production environment nor
+find all crashes that will happen in production. For crashes, apps typically monitor a crash rate by
+having a release crash reporting pipeline, with counts to prioritize fixes.
+
+LeakCanary for releases exposes APIs to run a heap analysis in release builds, in production.
+
+!!! danger
+    Everything about this is experimental. Running a heap analysis in production is not a very
+    common thing to do, and we're still learning and experimenting with this. Also, both the
+    artifact name and the APIs may change.
+
+## Getting started
+
+LeakCanary provides an artifact dedicated to detecting leaks in release builds:
+
+```groovy
+dependencies {
+  // LeakCanary for releases
+  releaseImplementation 'com.squareup.leakcanary:leakcanary-android-release:{{ leak_canary.release }}'
+  // Optional: detect retained objects. This helps but is not required.
+  releaseImplementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:{{ leak_canary.release }}'
+}
+```
+
+Here's a code example that runs a heap analysis when the screen is turned off or the app enters background, checking first if a [Firebase Remote Config](https://firebase.google.com/products/remote-config) flag is turned on, and uploading the result to Bugsnag:
+
+```kotlin
+import android.os.Process.THREAD_PRIORITY_BACKGROUND
+import java.util.concurrent.Executors
+import kotlin.concurrent.thread
+import leakcanary.BackgroundTrigger
+import leakcanary.HeapAnalysisClient
+import leakcanary.HeapAnalysisConfig
+import leakcanary.HeapAnalysisInterceptor
+import leakcanary.HeapAnalysisInterceptor.Chain
+import leakcanary.HeapAnalysisJob
+import leakcanary.HeapAnalysisJob.Result.Done
+import leakcanary.ScreenOffTrigger
+
+class ReleaseExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+
+    // Delete any remaining heap dump (if we crashed)
+    analysisExecutor.execute {
+      analysisClient.deleteHeapDumpFiles()
+    }
+
+    // Starts heap analysis on background importance
+    BackgroundTrigger(
+      application = this,
+      analysisClient = analysisClient,
+      analysisExecutor = analysisExecutor,
+      analysisCallback = analysisCallback
+    ).start()
+
+    // Starts heap analysis when screen off
+    ScreenOffTrigger(
+      application = this,
+      analysisClient = analysisClient,
+      analysisExecutor = analysisExecutor,
+      analysisCallback = analysisCallback
+    ).start()
+  }
+
+  /**
+   * Call this to trigger heap analysis manually, e.g. from
+   * a help button.
+   *
+   * This method returns a `HeapAnalysisJob` on which you can
+   * call `HeapAnalysisJob.cancel()` at any time.
+   */
+  fun triggerHeapAnalysisNow(): HeapAnalysisJob {
+    val job = analysisClient.newJob()
+    analysisExecutor.execute {
+      val result = job.execute()
+      analysisCallback(result)
+    }
+    return job
+  }
+
+  private val analysisClient by lazy {
+    HeapAnalysisClient(
+      // Use private app storage. cacheDir is never backed up which is important.
+      heapDumpDirectoryProvider = { cacheDir },
+      // stripHeapDump: remove all user data from hprof before analysis.
+      config = HeapAnalysisConfig(stripHeapDump = true),
+      // Default interceptors may cancel analysis for several other reasons.
+      interceptors = listOf(flagInterceptor) + HeapAnalysisClient.defaultInterceptors(this)
+    )
+  }
+
+  // Cancels heap analysis if "heap_analysis_flag" is false.
+  private val flagInterceptor = object : HeapAnalysisInterceptor {
+    val remoteConfig by lazy { FirebaseRemoteConfig.getInstance() }
+
+    override fun intercept(chain: Chain): HeapAnalysisJob.Result {
+      if (remoteConfig.getBoolean("heap_analysis_flag")) {
+        chain.job.cancel("heap_analysis_flag false")
+      }
+      return chain.proceed()
+    }
+  }
+
+  private val analysisExecutor = Executors.newSingleThreadExecutor {
+    thread(start = false, name = "Heap analysis executor") {
+      android.os.Process.setThreadPriority(THREAD_PRIORITY_BACKGROUND)
+      it.run()
+    }
+  }
+
+  private val analysisCallback: (HeapAnalysisJob.Result) -> Unit = { result ->
+    if (result is Done) {
+      uploader.upload(result.analysis)
+    }
+  }
+
+  private val uploader by lazy {
+    BugsnagLeakUploader(this@ReleaseExampleApplication)
+  }
+}
+```
+
+Here's the `BugsnagLeakUploader`:
+
+--8<-- "docs/snippets/bugsnag-uploader.md"
diff --git a/docs/recipes.md b/docs/recipes.md
new file mode 100644
index 00000000..eb958628
--- /dev/null
+++ b/docs/recipes.md
@@ -0,0 +1,480 @@
+# Code Recipes
+
+This page contains code recipes to customize LeakCanary to your needs. Read through the section titles and cook your own meal! Also don't forget to check out the [FAQ](faq.md).
+
+!!! bug
+    If you think a recipe might be missing or you're not sure that what you're trying to achieve is possible with the current APIs, please [file an issue](https://github.com/square/leakcanary/issues/new/choose). Your feedback helps us make LeakCanary better for the entire community.
+
+## Watching objects with a lifecycle
+
+The default configuration of LeakCanary will automatically watch Activity, Fragment, Fragment View and ViewModel instances.
+
+In your application, you may have other objects with a lifecycle, such as services, Dagger components, etc. Use [AppWatcher.objectWatcher](/leakcanary/api/leakcanary/-app-watcher/object-watcher/) to watch instances that should be garbage collected:
+
+```kotlin
+class MyService : Service {
+
+  // ...
+
+  override fun onDestroy() {
+    super.onDestroy()
+    AppWatcher.objectWatcher.watch(
+      watchedObject = this,
+      description = "MyService received Service#onDestroy() callback"
+    )
+  }
+}
+```
+
+## Configuration
+
+LeakCanary has a default configuration that works well for most apps. You can also customize it to your needs. The LeakCanary configuration is held by two singleton objects (`AppWatcher` and `LeakCanary`) and can be updated at any time. Most developers configure LeakCanary in their **debug** [Application](https://developer.android.com/reference/android/app/Application) class:
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    AppWatcher.config = AppWatcher.config.copy(watchFragmentViews = false)
+  }
+}
+```
+
+!!! info
+    Create a debug application class in your `src/debug/java` folder. Don't forget to also register it in `src/debug/AndroidManifest.xml`.
+
+To customize the detection of retained objects at runtime, specify the watchers you wish to install via [AppWatcher.manualInstall()](/leakcanary/api/leakcanary/-app-watcher/manual-install/):
+
+```kotlin
+val watchersToInstall = AppWatcher.appDefaultWatchers(this)
+  .filter { it !is FragmentAndViewModelWatcher }
+AppWatcher.manualInstall(
+  application = this,
+  watchersToInstall = watchersToInstall
+)
+```
+
+To customize the heap dumping & analysis, update [LeakCanary.config](/leakcanary/api/leakcanary/-leak-canary/config/):
+
+```kotlin
+LeakCanary.config = LeakCanary.config.copy(retainedVisibleThreshold = 3)
+```
+
+!!! info "Java"
+    In Java, use [LeakCanary.Config.Builder](/leakcanary/api/leakcanary/-leak-canary/-config/-builder/) instead:
+
+    ```java
+    LeakCanary.Config config = LeakCanary.getConfig().newBuilder()
+       .retainedVisibleThreshold(3)
+       .build();
+    LeakCanary.setConfig(config);
+    ```
+
+Configure the LeakCanary UI by overriding the following resources:
+
+* `mipmap/leak_canary_icon` see [Icon and label](#icon-and-label)
+* `string/leak_canary_display_activity_label` see [Icon and label](#icon-and-label)
+* `bool/leak_canary_add_dynamic_shortcut` see [Disabling LeakCanary](#disabling-leakcanary)
+* `bool/leak_canary_add_launcher_icon` see [Disabling LeakCanary](#disabling-leakcanary)
+* `layout/leak_canary_heap_dump_toast` the layout for the toast shown when the heap is dumped
+
+## Disabling LeakCanary
+
+Sometimes it's necessary to disable LeakCanary temporarily, for example for a product demo or when running performance tests. You have different options, depending on what you're trying to achieve:
+
+* Create a build variant that does not include the LeakCanary dependencies, see [Setting up LeakCanary for different product flavors](#setting-up-leakcanary-for-different-product-flavors).
+* Disable the heap dumping & analysis: `LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)`.
+* Hide the leak display activity launcher icon: override `R.bool.leak_canary_add_launcher_icon` or call `LeakCanary.showLeakDisplayActivityLauncherIcon(false)`
+
+!!! info
+    When you set `LeakCanary.Config.dumpHeap` to `false`, `AppWatcher.objectWatcher` will still keep track of retained objects, and LeakCanary will look for these objects when you change `LeakCanary.Config.dumpHeap` back to `true`.
+
+## LeakCanary test environment detection
+
+By default, LeakCanary will look for the `org.junit.Test` class in your classpath and if found, will disable itself to avoid running in tests. However, some apps may ship JUnit in their debug classpaths (for example, when using OkHttp's MockWebServer) so we offer a way to customise the class that is used to determine that the app is running in a test environment.
+
+```xml
+<resources>
+  <string name="leak_canary_test_class_name">assertk.Assert</string>
+</resources>
+```
+
+## Counting retained instances in release builds
+
+The `com.squareup.leakcanary:leakcanary-android` dependency should only be used in debug builds. It depends on `com.squareup.leakcanary:leakcanary-object-watcher-android` which you can use in release builds to track and count retained instances.
+
+In your `build.gradle`:
+
+```gradle
+dependencies {
+  implementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:{{ leak_canary.release }}'
+}
+```
+
+In your leak reporting code:
+```kotlin
+val retainedInstanceCount = AppWatcher.objectWatcher.retainedObjectCount
+```
+
+## LeakCanary in release builds
+
+We **do not recommend** including LeakCanary in release builds, as it could negatively impact the experience of your customers. To avoid accidentally including the `com.squareup.leakcanary:leakcanary-android` dependency in a release build, LeakCanary crashes during initialization if the APK is not debuggable. You may have a good reason to create a non debuggable build that includes LeakCanary, for example for a QA build. If necessary, the crashing check can be disabled by overriding the `bool/leak_canary_allow_in_non_debuggable_build` resource, e.g. by creating a file under `res/values` with the following contents:
+
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <bool name="leak_canary_allow_in_non_debuggable_build">true</bool>
+</resources>
+```
+
+## Android TV
+
+LeakCanary works on Android TV devices (FireTV, Nexus player, Nvidia Shield, MiBox, etc.) without any additional setup. However, there are couple things you need to be aware of:
+
+-   Android TV doesn't have notifications. LeakCanary will display Toast messages when objects become retained and when leak analysis completes. You can also check Logcat for more details.
+-   Due to lack of notifications, the only way to **manually** trigger a heap dump is to background the app.
+-   There's a [bug on API 26+ devices](https://issuetracker.google.com/issues/141429184) that prevents the activity that displays leaks from appearing in apps list. As a workaround, LeakCanary prints an `adb shell` command in Logcat after heap dump analysis that launches leak list activity:
+    ```
+    adb shell am start -n "com.your.package.name/leakcanary.internal.activity.LeakLauncherActivity"
+    ```
+-   Some Android TV devices have very little memory available per app process and this might impact LeakCanary. [Running the LeakCanary analysis in a separate process](#running-the-leakcanary-analysis-in-a-separate-process) might help in such cases.
+
+## Icon and label
+
+The activity that displays leaks comes with a default icon and label, which you can change by providing `R.mipmap.leak_canary_icon` and `R.string.leak_canary_display_activity_label` in your app:
+
+```
+res/
+  mipmap-hdpi/
+    leak_canary_icon.png
+  mipmap-mdpi/
+    leak_canary_icon.png
+  mipmap-xhdpi/
+    leak_canary_icon.png
+  mipmap-xxhdpi/
+    leak_canary_icon.png
+  mipmap-xxxhdpi/
+    leak_canary_icon.png
+   mipmap-anydpi-v26/
+     leak_canary_icon.xml
+```
+
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <string name="leak_canary_display_activity_label">MyLeaks</string>
+</resources>
+```
+
+## Matching known library leaks
+
+Set [LeakCanary.Config.referenceMatchers](/leakcanary/api/leakcanary/-leak-canary/-config/reference-matchers/) to a list that builds on top of [AndroidReferenceMatchers.appDefaults](/leakcanary/api/shark/-android-reference-matchers/-companion/app-defaults/):
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakCanary.config = LeakCanary.config.copy(
+        referenceMatchers = AndroidReferenceMatchers.appDefaults +
+            AndroidReferenceMatchers.staticFieldLeak(
+                className = "com.samsing.SomeSingleton",
+                fieldName = "sContext",
+                description = "SomeSingleton has a static field leaking a context.",
+                patternApplies = {
+                  manufacturer == "Samsing" && sdkInt == 26
+                }
+            )
+    )
+  }
+}
+```
+
+## Ignoring specific activities or fragment classes
+
+Sometimes a 3rd party library provides its own activities or fragments which contain a number of bugs leading to leaks of those specific 3rd party activities and fragments. You should push hard on that library to fix their memory leaks as it's directly impacting your application. That being said, until those are fixed, you have two options:
+
+1. Add the specific leaks as known library leaks (see [Matching known library leaks](#matching-known-library-leaks)). LeakCanary will run when those leaks are detected and then report them as known library leaks.
+2. Disable LeakCanary automatic activity or fragment watching (e.g. `AppWatcher.config = AppWatcher.config.copy(watchActivities = false)`) and then manually pass objects to `AppWatcher.objectWatcher.watch`.
+
+## Identifying leaking objects and labeling objects
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    val addEntityIdLabel = ObjectInspector { reporter ->
+      reporter.whenInstanceOf("com.example.DbEntity") { instance ->
+		val databaseIdField = instance["com.example.DbEntity", "databaseId"]!!
+		val databaseId = databaseIdField.value.asInt!!
+        labels += "DbEntity.databaseId = $databaseId"
+      }
+    }
+
+    val singletonsInspector =
+      AppSingletonInspector("com.example.MySingleton", "com.example.OtherSingleton")
+
+    val mmvmInspector = ObjectInspector { reporter ->
+      reporter.whenInstanceOf("com.mmvm.SomeViewModel") { instance ->
+        val destroyedField = instance["com.mmvm.SomeViewModel", "destroyed"]!!
+        if (destroyedField.value.asBoolean!!) {
+          leakingReasons += "SomeViewModel.destroyed is true"
+        } else {
+          notLeakingReasons += "SomeViewModel.destroyed is false"
+        }
+      }
+    }
+
+    LeakCanary.config = LeakCanary.config.copy(
+        objectInspectors = AndroidObjectInspectors.appDefaults +
+            listOf(addObjectIdLabel, singletonsInspector, mmvmInspector)
+    )
+  }
+}
+```
+
+## Running the LeakCanary analysis in a separate process
+
+LeakCanary runs in your main app process. LeakCanary 2 is optimized to keep memory usage low while analysing and runs in a background thread with priority `Process.THREAD_PRIORITY_BACKGROUND`. If you find that LeakCanary is still using too much memory or impacting the app process performance, you can configure it to run the analysis in a separate process.
+
+All you have to do is replace the `leakcanary-android` dependency with `leakcanary-android-process`:
+
+```groovy
+dependencies {
+  // debugImplementation 'com.squareup.leakcanary:leakcanary-android:${version}'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android-process:${version}'
+}
+```
+
+You can call [LeakCanaryProcess.isInAnalyzerProcess](/leakcanary/api/leakcanary/-leak-canary-process/is-in-analyzer-process/) to check if your Application class is being created in the LeakCanary process. This is useful when configuring libraries like Firebase that may crash when running in an unexpected process.
+
+## Setting up LeakCanary for different product flavors
+
+You can setup LeakCanary to run in a specific product flavors of your app. For example, create:
+
+```
+android {
+  flavorDimensions "default"
+  productFlavors {
+    prod {
+      // ...
+    }
+    qa {
+      // ...
+    }
+    dev {
+      // ...
+    }
+  }
+}
+```
+
+Then, define a custom configuration for the flavor for which you want to enable LeakCanary:
+
+```
+android {
+  // ...
+}
+configurations {
+    devDebugImplementation {}
+}
+```
+
+You can now add the LeakCanary dependency for that configuration:
+
+```
+dependencies {
+  devDebugImplementation "com.squareup.leakcanary:leakcanary-android:${version}"
+}
+```
+
+## Extracting metadata from the heap dump
+
+[LeakCanary.Config.metadataExtractor](/leakcanary/api/leakcanary/-leak-canary/-config/metadata-extractor/) extracts metadata from a heap dump. The metadata is then available in `HeapAnalysisSuccess.metadata`. `LeakCanary.Config.metadataExtractor` defaults to `AndroidMetadataExtractor` but you can replace it to extract additional metadata from the hprof.
+
+For example, if you want to include the app version name in your heap analysis reports, you need to first store it in memory (e.g. in a static field) and then you can retrieve it in `MetadataExtractor`.
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  companion object {
+    @JvmStatic
+    lateinit var savedVersionName: String
+  }
+
+  override fun onCreate() {
+    super.onCreate()
+
+    val packageInfo = packageManager.getPackageInfo(packageName, 0)
+    savedVersionName = packageInfo.versionName
+
+    LeakCanary.config = LeakCanary.config.copy(
+        metadataExtractor = MetadataExtractor { graph ->
+          val companionClass =
+            graph.findClassByName("com.example.DebugExampleApplication")!!
+
+          val versionNameField = companionClass["savedVersionName"]!!
+          val versionName = versionNameField.valueAsInstance!!.readAsJavaString()!!
+
+          val defaultMetadata = AndroidMetadataExtractor.extractMetadata(graph)
+
+          mapOf("App Version Name" to versionName) + defaultMetadata
+        })
+  }
+}
+```
+
+## Using LeakCanary with obfuscated apps
+
+If obfuscation is turned on then leak traces will be obfuscated. It's possible to automatically deobfuscate leak traces by using a deobfuscation gradle plugin provided by LeakCanary.
+
+You have to add a plugin dependency in your root `build.gradle` file:
+
+```groovy
+buildscript {
+  dependencies {
+    classpath 'com.squareup.leakcanary:leakcanary-deobfuscation-gradle-plugin:${version}'
+  }
+}
+```
+
+And then you need to apply and configure the plugin in your app (or library) specific `build.gradle` file:
+
+```groovy
+apply plugin: 'com.android.application'
+apply plugin: 'com.squareup.leakcanary.deobfuscation'
+
+leakCanary {
+  // LeakCanary needs to know which variants have obfuscation turned on
+  filterObfuscatedVariants { variant ->
+    variant.name == "debug"
+  }
+}
+```
+
+Now you can run LeakCanary on an obfuscated app and leak traces will be automatically deobfuscated.
+
+**Important:** never use this plugin on a release variant. This plugin copies obfuscation mapping file and puts it inside the .apk, so if you use it on release build then the obfuscation becomes pointless because the code can be easily deobfuscated using mapping file.
+
+**Warning:** R8 (Google Proguard replacement) can now understand Kotlin language constructs but the side effect is that mapping files can get very large (a couple dozen megabytes). It means that the size of .apk containing copied mapping file will increase as well. This is another reason for not using this plugin on a release variant.
+
+## Detecting leaks in JVM applications
+
+While LeakCanary was designed to work out of the box on Android, it can run on any JVM with a bit of configuration.
+
+Add the ObjectWatcher and Shark dependencies to your build file:
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:leakcanary-object-watcher:{{ leak_canary.release }}'
+  implementation 'com.squareup.leakcanary:shark:{{ leak_canary.release }}'
+}
+```
+
+Define a `HotSpotHeapDumper` to dump the heap:
+
+```kotlin
+import com.sun.management.HotSpotDiagnosticMXBean
+import java.lang.management.ManagementFactory
+
+object HotSpotHeapDumper {
+  private val mBean: HotSpotDiagnosticMXBean by lazy {
+    val server = ManagementFactory.getPlatformMBeanServer()
+    ManagementFactory.newPlatformMXBeanProxy(
+        server,
+        "com.sun.management:type=HotSpotDiagnostic",
+        HotSpotDiagnosticMXBean::class.java
+    )
+  }
+
+  fun dumpHeap(fileName: String) {
+    mBean.dumpHeap(fileName, LIVE)
+  }
+
+  private const val LIVE = true
+}
+```
+
+Define a `JvmHeapAnalyzer` to analyze the heap when objects are retained and print the result to the console:
+
+```kotlin
+import leakcanary.GcTrigger
+import leakcanary.ObjectWatcher
+import leakcanary.OnObjectRetainedListener
+import java.io.File
+import java.text.SimpleDateFormat
+import java.util.Date
+import java.util.Locale.US
+
+class JvmHeapAnalyzer(private val objectWatcher: ObjectWatcher) :
+    OnObjectRetainedListener {
+
+  private val fileNameFormat = SimpleDateFormat(DATE_PATTERN, US)
+
+  override fun onObjectRetained() {
+    GcTrigger.Default.runGc()
+    if (objectWatcher.retainedObjectCount == 0) {
+      return
+    }
+    val fileName = fileNameFormat.format(Date())
+    val hprofFile = File(fileName)
+
+    println("Dumping the heap to ${hprofFile.absolutePath}")
+    HotSpotHeapDumper.dumpHeap(hprofFile.absolutePath)
+
+    val analyzer = HeapAnalyzer(
+        OnAnalysisProgressListener { step ->
+          println("Analysis in progress, working on: ${step.name}")
+        })
+
+    val heapDumpAnalysis = analyzer.analyze(
+        heapDumpFile = hprofFile,
+        leakingObjectFinder = KeyedWeakReferenceFinder,
+        computeRetainedHeapSize = true,
+        objectInspectors = ObjectInspectors.jdkDefaults
+    )
+    println(heapDumpAnalysis)
+  }
+  companion object {
+    private const val DATE_PATTERN = "yyyy-MM-dd_HH-mm-ss_SSS'.hprof'"
+  }
+}
+```
+
+Create an `ObjectWatcher` instance and configure it to watch objects for 5 seconds before notifying a `JvmHeapAnalyzer` instance:
+
+```kotlin
+val scheduledExecutor = Executors.newSingleThreadScheduledExecutor()
+val objectWatcher = ObjectWatcher(
+    clock = Clock {
+      System.currentTimeMillis()
+    },
+    checkRetainedExecutor = Executor { command ->
+      scheduledExecutor.schedule(command, 5, SECONDS)
+    }
+)
+
+val heapAnalyzer = JvmHeapAnalyzer(objectWatcher)
+objectWatcher.addOnObjectRetainedListener(heapAnalyzer)
+```
+
+Pass objects that you expect to be garbage collected (e.g. closed resources) to the `ObjectWatcher` instance:
+
+```kotlin
+objectWatcher.watch(
+    watchedObject = closedResource,
+    description = "$closedResource is closed and should be garbage collected"
+)
+```
+
+If you end up using LeakCanary on a JVM, the community will definitely benefit from your experience, so don't hesitate to [let us know](https://github.com/square/leakcanary/issues/)!
+
+## PackageManager.getLaunchIntentForPackage() returns LeakLauncherActivity
+
+LeakCanary adds a main activity that has a [Intent#CATEGORY_LAUNCHER](https://developer.android.com/reference/android/content/Intent#CATEGORY_LAUNCHER) category. <a href="https://developer.android.com/reference/android/content/pm/PackageManager#getLaunchIntentForPackage(java.lang.String)">PackageManager.getLaunchIntentForPackage()</a> looks for a main activity in the category `Intent#CATEGORY_INFO`, and next for a main activity in the category `Intent#CATEGORY_LAUNCHER`. `PackageManager.getLaunchIntentForPackage()` returns the first activity that matches in the merged manifest of your app. If your app relies on `PackageManager.getLaunchIntentForPackage()`, you have two options:
+
+* Add `Intent#CATEGORY_INFO` to your main activity intent filter, so that it gets picked up first. This is what the Android documentation recommends.
+* Disable the leakcanary launcher activity by setting the `leak_canary_add_launcher_icon` resource boolean to false.
+
+
diff --git a/docs/recorded-presentations.md b/docs/recorded-presentations.md
new file mode 100644
index 00000000..c2bfa010
--- /dev/null
+++ b/docs/recorded-presentations.md
@@ -0,0 +1,10 @@
+* [Live leak investigations](https://www.youtube.com/watch?v=Sx0k4ipqwBs), investigating leaks on Stack Overflow and fixes for AOSP leaks
+* [Fixing leaks in Firefox](https://www.youtube.com/watch?v=kHHOhPPRytc)
+* [Shark: Diving into the guts of LeakCanary's Hprof parser](https://www.droidcon.com/media-detail?video=362742252)
+* [LeakCanary 2: Leaner, Better, Faster, Kotliner!](https://www.youtube.com/watch?v=LEX8dn4BLUw)
+* [LeakCanary, then what? Nuking Nasty Memory Leaks](https://www.youtube.com/watch?v=fhE--eTEW84)
+* [Memory Leak Hunt](https://www.youtube.com/watch?v=KwArTJHLq5g), a live investigation.
+* [Installing LeakCanary](https://caster.io/lessons/installing-leakcanary) (LeakCanary 1.5)
+* [How to use LeakCanary](https://www.youtube.com/watch?v=qtrZVPGdDkU)
+
+Your presentation should be here, please update this list! Any technical level welcome.
diff --git a/docs/releasing.md b/docs/releasing.md
new file mode 100644
index 00000000..afe3d892
--- /dev/null
+++ b/docs/releasing.md
@@ -0,0 +1,178 @@
+# Releasing LeakCanary
+
+## Preparing the release environment
+
+### Set up your Sonatype OSSRH account
+
+* Create a [Sonatype OSSRH JIRA account](https://issues.sonatype.org/secure/Signup!default.jspa).
+* Create a ticket to request access to the `com.squareup.leakcanary` project. Here's an example: [OSSRH-54959](https://issues.sonatype.org/browse/OSSRH-54959).
+* Then ask someone with deployer role from the LeakCanary team to confirm access.
+
+### Set up your signing key
+
+```bash
+# Create a new key
+gpg --gen-key
+# List local keys. Key id is last 8 characters
+gpg -K
+cd ~/.gnupg
+# Export key locally
+gpg --export-secret-keys -o secring.gpg
+# Upload key to Ubuntu servers
+gpg --send-keys --keyserver keyserver.ubuntu.com <KEY ID>
+# Confirm the key can now be found
+gpg --recv-keys --keyserver keyserver.ubuntu.com <KEY ID>
+```
+
+### Set up your home gradle.properties
+
+Add this to your `~/.gradle/gradle.properties`:
+
+```
+signing.keyId=<KEY ID>
+signing.password=<KEY PASSWORD>
+signing.secretKeyRingFile=/Users/YOUR_USERNAME_/.gnupg/secring.gpg
+SONATYPE_NEXUS_USERNAME=<SONATYPE_USERNAME>
+SONATYPE_NEXUS_PASSWORD=<SONATYPE_PASSWORD>
+```
+
+### Set up the Google Analytics docs key 
+
+Add this to your `~/.bashrc`:
+
+```bash
+export LEAKCANARY_GOOGLE_ANALYTICS_KEY="UA-142834539-1"
+```
+
+### Set up GitHub CLI
+
+Install GitHub CLI
+
+```bash
+brew install gh
+```
+
+Install jq, a CLI Json processor
+
+```bash
+brew install jq
+```
+
+Set up aliases for milestone management:
+
+```bash
+gh alias set listOpenMilestones "api graphql -F owner=':owner' -F name=':repo' -f query='
+    query ListOpenMilestones(\$name: String\!, \$owner: String\!) {
+        repository(owner: \$owner, name: \$name) {
+            milestones(first: 100, states: OPEN) {
+                nodes {
+                    title
+                    number
+                    description
+                    dueOn
+                    url
+                    state
+                    closed
+                    closedAt
+                    updatedAt
+                }
+            }
+        }
+    }
+'"
+
+gh alias set --shell createMilestone "gh api --method POST repos/:owner/:repo/milestones --input - | jq '{ html_url: .html_url, state: .state, created_at: .created_at }'"
+
+gh alias set --shell closeMilestone "echo '{\"state\": \"closed\"}' | gh api --method PATCH repos/:owner/:repo/milestones/\$1 --input - | jq '{ html_url: .html_url, state: .state, closed_at: .closed_at }'"
+```
+
+### Install or update the doc generation dependencies
+
+```bash
+pip3 install --requirement docs/requirements.txt
+```
+
+## Releasing
+
+* Create a local release branch from `main`
+```bash
+git checkout main && \
+git pull && \
+git checkout -b release_{{ leak_canary.next_release }}
+```
+
+* Update `VERSION_NAME` in `gradle.properties` (remove `-SNAPSHOT`)
+```gradle
+sed -i '' 's/VERSION_NAME={{ leak_canary.next_release }}-SNAPSHOT/VERSION_NAME={{ leak_canary.next_release }}/' gradle.properties
+```
+
+* Update the current version and next version in `mkdocs.yml`
+```bash
+sed -i '' 's/{{ leak_canary.next_release }}/NEXT/' mkdocs.yml
+sed -i '' 's/{{ leak_canary.release }}/{{ leak_canary.next_release }}/' mkdocs.yml
+```
+
+* Create the release
+```bash
+git commit -am "Prepare {{ leak_canary.next_release }} release" && \
+./gradlew clean && \
+./gradlew build && \
+git tag v{{ leak_canary.next_release }} && \
+git push origin v{{ leak_canary.next_release }} && \
+./gradlew publish --no-daemon --no-parallel && \
+./gradlew closeAndReleaseRepository && \
+./gradlew shark-cli:distZip
+```
+
+Note: if anything goes wrong, you can manually drop the release at https://s01.oss.sonatype.org/
+
+* Merge back to main
+```bash
+git checkout main && \
+git pull && \
+git merge --no-ff release_{{ leak_canary.next_release }}
+```
+* Update `VERSION_NAME` in `gradle.properties` (increase version and add `-SNAPSHOT`)
+```gradle
+sed -i '' 's/VERSION_NAME={{ leak_canary.next_release }}/VERSION_NAME=NEXT-SNAPSHOT/' gradle.properties
+```
+
+* Generate the Dokka docs
+```bash
+rm -rf docs/api && ./gradlew siteDokka
+```
+
+* Update the changelog ([commit list](https://github.com/square/leakcanary/compare/v{{ leak_canary.release }}...main))
+```
+mate docs/changelog.md
+```	
+
+* Deploy the docs locally then [open the changelog](http://127.0.0.1:8000/leakcanary/changelog/) and check everything looks good
+```bash
+mkdocs serve
+```
+
+* Finish up the release
+
+```bash
+git commit -am "Prepare for next development iteration" && \
+git push && \
+gh listOpenMilestones | jq '.data.repository.milestones.nodes[0].number' | xargs gh closeMilestone && \
+echo '{
+  "title": "REPLACE_WITH_NEXT_VERSION_NUMBER",
+  "state": "open",
+  "description": ""
+}' | gh createMilestone && \
+mkdocs gh-deploy
+gh release create v{{ leak_canary.next_release }} ./shark-cli/build/distributions/shark-cli-{{ leak_canary.next_release }}.zip --title v{{ leak_canary.next_release }} --notes 'See [Change Log](https://square.github.io/leakcanary/changelog)'
+```
+
+* Open the [v{{ leak_canary.next_release }} release](https://github.com/square/leakcanary/releases/tag/v{{ leak_canary.next_release }}) to confirm everything looks good.
+
+* Upload shark-cli to [brew](https://brew.sh/):
+```bash
+brew bump-formula-pr --url https://github.com/square/leakcanary/releases/download/v{{ leak_canary.next_release }}/shark-cli-{{ leak_canary.next_release }}.zip leakcanary-shark
+```
+
+* Wait for the release to be available [on Maven Central](https://repo1.maven.org/maven2/com/squareup/leakcanary/leakcanary-android/).
+* Tell your friends, update all of your apps, and tweet the new release. As a nice extra touch, mention external contributions.
diff --git a/docs/requirements.txt b/docs/requirements.txt
new file mode 100644
index 00000000..92bf18be
--- /dev/null
+++ b/docs/requirements.txt
@@ -0,0 +1,3 @@
+mkdocs==1.4.2
+mkdocs-material==9.1.3
+mkdocs-markdownextradata-plugin==0.2.5
diff --git a/docs/shark.md b/docs/shark.md
new file mode 100644
index 00000000..6e6d8714
--- /dev/null
+++ b/docs/shark.md
@@ -0,0 +1,187 @@
+# Shark ðŸ¦ˆ
+
+<!-- Made with http://patorjk.com/text-color-fader/ -->
+**Shark**: **<span style="color:#c757bc;">S</span><span style="color:#c858b7;">m</span><span style="color:#ca5ab2;">a</span><span style="color:#cb5bad;">r</span><span style="color:#cc5ca9;">t</span><span style="color:#ce5ea4;"> </span><span style="color:#cf5f9f;">H</span><span style="color:#d0609a;">e</span><span style="color:#d26295;">a</span><span style="color:#d36390;">p</span><span style="color:#d4658c;"> </span><span style="color:#d66687;">A</span><span style="color:#d76782;">n</span><span style="color:#d8697d;">a</span><span style="color:#da6a78;">l</span><span style="color:#db6b73;">y</span><span style="color:#dc6d6f;">s</span><span style="color:#de6e6a;">i</span><span style="color:#df6f65;">s</span><span style="color:#e07160;"> </span><span style="color:#e1725b;">R</span><span style="color:#e37356;">e</span><span style="color:#e47552;">p</span><span style="color:#e5764d;">o</span><span style="color:#e77748;">r</span><span style="color:#e87943;">t</span><span style="color:#e97a3e;">s</span><span style="color:#eb7b39;"> </span><span style="color:#ec7d35;">f</span><span style="color:#ed7e30;">o</span><span style="color:#ef802b;">r</span><span style="color:#f08126;"> </span><span style="color:#f18221;">K</span><span style="color:#f3841c;">o</span><span style="color:#f48518;">t</span><span style="color:#f58613;">l</span><span style="color:#f7880e;">i</span><span style="color:#f88909;">n</span>**
+
+<p align="center">
+<img src="../images/shark.png" />
+</p>
+
+Shark is the heap analyzer that powers LeakCanary 2. It's a Kotlin standalone heap analysis library that runs at **high speed** with a **low memory footprint**.
+
+Shark is released in layers:
+
+1. **Shark Hprof**: Read and write records in hprof files.
+2. **Shark Graph**: Navigate the heap object graph.
+3. **Shark**: Generate heap analysis reports.
+4. **Shark Android**: Android heuristics to generate tailored heap analysis reports.
+5. **Shark CLI**: Analyze the heap of debuggable apps installed on an Android device connected to your desktop. The output is similar to the output of LeakCanary, except you don't have to add the LeakCanary dependency to your app.
+6. **LeakCanary**: Builds on top. It automatically watches destroyed activities and fragments, triggers a heap dump, runs Shark Android and then displays the result.
+
+A few more things:
+
+* Shark is built on top of Okio. Okio makes it easy to parse heap dumps efficiently.
+* Shark is a 100% Kotlin library, and Kotlin is essential to its design, because Shark relies heavily on sealed classes and sequences to save memory.
+* Shark has the unique ability to help narrow down the cause of memory leaks through platform specific [heuristics](fundamentals-fixing-a-memory-leak.md#2-narrow-down-the-suspect-references).
+* Shark is heavily tested (80% test coverage).
+* Shark can run in both Java and Android VMs, with no other dependency than Okio and Kotlin.
+* Shark can analyze both Java and Android VM hprof files.
+* Shark can deobfuscate hprof records if it has access to obfuscation mapping file.
+
+## Shark CLI
+
+The Shark Command Line Interface (CLI) enables you to analyze heaps directly from your computer. It can dump the heap of an app installed on a connected Android device, analyze it, and even strip a heap dump of any sensitive data (e.g. PII, passwords or encryption keys) which is useful when sharing a heap dump.
+
+Install it via [Homebrew](https://brew.sh/):
+
+```bash
+brew install leakcanary-shark
+```
+
+You can also download it [here](https://github.com/square/leakcanary/releases/download/v{{ leak_canary.release }}/shark-cli-{{ leak_canary.release }}.zip).
+
+You can then look for leaks in apps on any connected device, for example: 
+
+```
+$ shark-cli --device emulator-5554 --process com.example.app.debug analyze
+```
+
+!!! info
+    `shark-cli` works with all debuggable apps, even if they don't include the `leakcanary-android` dependency.
+
+Run `shark-cli` to see usage instructions:
+
+```
+$ shark-cli
+
+Usage: shark-cli [OPTIONS] COMMAND [ARGS]...
+
+                   ^`.                 .=""=.
+   ^_              \  \               / _  _ \
+   \ \             {   \             |  d  b  |
+   {  \           /     `~~~--__     \   /\   /
+   {   \___----~~'              `~~-_/'-=\/=-'\,
+    \                         /// a  `~.      \ \
+    / /~~~~-, ,__.    ,      ///  __,,,,)      \ |
+    \/      \/    `~~~;   ,---~~-_`/ \        / \/
+                     /   /            '.    .'
+                    '._.'             _|`~~`|_
+                                      /|\  /|\
+
+Options:
+  -p, --process TEXT              Full or partial name of a process, e.g.
+                                  "example" would match "com.example.app"
+  -d, --device ID                 device/emulator id
+  -m, --obfuscation-mapping PATH  path to obfuscation mapping file
+  --verbose / --no-verbose        provide additional details as to what
+                                  shark-cli is doing
+  -h, --hprof FILE                path to a .hprof file
+  --help                          Show this message and exit
+
+Commands:
+  interactive   Explore a heap dump.
+  analyze       Analyze a heap dump.
+  dump-process  Dump the heap and pull the hprof file.
+  strip-hprof   Replace all primitive arrays from the provided heap dump with
+                arrays of zeroes and generate a new "-stripped.hprof" file.
+```
+
+
+## Shark code examples
+
+### Reading records in a hprof file
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:shark-hprof:$sharkVersion'
+}
+```
+
+```kotlin
+// Prints all class and field names
+Hprof.open(heapDumpFile)
+    .use { hprof ->
+      hprof.reader.readHprofRecords(
+          recordTypes = setOf(StringRecord::class),
+          listener = OnHprofRecordListener { position, record ->
+            println((record as StringRecord).string)
+          })
+    }
+```
+
+### Navigating the heap object graph
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:shark-graph:$sharkVersion'
+}
+```
+
+```kotlin
+// Prints all thread names
+Hprof.open(heapDumpFile)
+    .use { hprof ->
+      val heapGraph = HprofHeapGraph.indexHprof(hprof)
+      val threadClass = heapGraph.findClassByName("java.lang.Thread")!!
+      val threadNames: Sequence<String> = threadClass.instances.map { instance ->
+        val nameField = instance["java.lang.Thread", "name"]!!
+        nameField.value.readAsJavaString()!!
+      }
+      threadNames.forEach { println(it) }
+    }
+```
+
+### Generating a heap analysis report
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:shark:$sharkVersion'
+}
+```
+
+```kotlin
+// Marks any instance of com.example.ThingWithLifecycle with
+// ThingWithLifecycle.destroyed=true as leaking
+val leakingObjectFilter = object : LeakingObjectFilter {
+  override fun isLeakingObject(heapObject: HeapObject): Boolean {
+    return if (heapObject instanceOf "com.example.ThingWithLifecycle") {
+      val instance = heapObject as HeapInstance
+      val destroyedField = instance["com.example.ThingWithLifecycle", "destroyed"]!!
+      destroyedField.value.asBoolean!!
+    } else false
+  }
+}
+
+val leakingObjectFinder = FilteringLeakingObjectFinder(listOf(leakingObjectFilter))
+
+val heapAnalysis = Hprof.open(heapDumpFile)
+    .use { hprof ->
+      val heapGraph = HprofHeapGraph.indexHprof(hprof)
+      val heapAnalyzer = HeapAnalyzer(AnalyzerProgressListener.NONE)
+      heapAnalyzer.analyze(
+          heapDumpFile = heapDumpFile,
+          graph = heapGraph,
+          leakingObjectFinder = leakingObjectFinder,
+      )
+    }
+println(analysis)
+```
+
+### Generating an Android heap analysis report
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:shark-android:$sharkVersion'
+}
+```
+
+
+```kotlin
+val heapAnalyzer = HeapAnalyzer(AnalyzerProgressListener.NONE)
+val analysis = heapAnalyzer.checkForLeaks(
+    heapDumpFile = heapDumpFile,
+    referenceMatchers = AndroidReferenceMatchers.appDefaults,
+    objectInspectors = AndroidObjectInspectors.appDefaults
+)
+println(analysis)
+```
diff --git a/docs/snippets/bugsnag-uploader.md b/docs/snippets/bugsnag-uploader.md
new file mode 100644
index 00000000..76e43162
--- /dev/null
+++ b/docs/snippets/bugsnag-uploader.md
@@ -0,0 +1,108 @@
+```kotlin
+import android.app.Application
+import com.bugsnag.android.Bugsnag
+import com.bugsnag.android.Configuration
+import com.bugsnag.android.ErrorTypes
+import com.bugsnag.android.Event
+import com.bugsnag.android.ThreadSendPolicy
+import shark.HeapAnalysis
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.Leak
+import shark.LeakTrace
+import shark.LeakTraceReference
+import shark.LibraryLeak
+
+class BugsnagLeakUploader(applicationContext: Application) {
+
+  private val bugsnagClient = Bugsnag.start(
+    applicationContext,
+    Configuration("YOUR_BUGSNAG_API_KEY").apply {
+      enabledErrorTypes = ErrorTypes(
+        anrs = false,
+        ndkCrashes = false,
+        unhandledExceptions = false,
+        unhandledRejections = false
+      )
+      sendThreads = ThreadSendPolicy.NEVER
+    }
+  )
+
+  fun upload(heapAnalysis: HeapAnalysis) {
+    when (heapAnalysis) {
+      is HeapAnalysisSuccess -> {
+        val allLeakTraces = heapAnalysis
+          .allLeaks
+          .toList()
+          .flatMap { leak ->
+            leak.leakTraces.map { leakTrace -> leak to leakTrace }
+          }
+        if (allLeakTraces.isEmpty()) {
+          // Track how often we perform a heap analysis that yields no result.
+          bugsnagClient.notify(NoLeakException()) { event ->
+            event.addHeapAnalysis(heapAnalysis)
+            true
+          }
+        } else {
+          allLeakTraces.forEach { (leak, leakTrace) ->
+            val message = "Memory leak: ${leak.shortDescription}. See LEAK tab."
+            val exception = leakTrace.asFakeException(message)
+            bugsnagClient.notify(exception) { event ->
+              event.addHeapAnalysis(heapAnalysis)
+              event.addLeak(leak)
+              event.addLeakTrace(leakTrace)
+              event.groupingHash = leak.signature
+              true
+            }
+          }
+        }
+      }
+      is HeapAnalysisFailure -> {
+        // Please file any reported failure to
+        // https://github.com/square/leakcanary/issues
+        bugsnagClient.notify(heapAnalysis.exception)
+      }
+    }
+  }
+
+  class NoLeakException : RuntimeException()
+
+  private fun Event.addHeapAnalysis(heapAnalysis: HeapAnalysisSuccess) {
+    addMetadata("Leak", "heapDumpPath", heapAnalysis.heapDumpFile.absolutePath)
+    heapAnalysis.metadata.forEach { (key, value) ->
+      addMetadata("Leak", key, value)
+    }
+    addMetadata("Leak", "analysisDurationMs", heapAnalysis.analysisDurationMillis)
+  }
+
+  private fun Event.addLeak(leak: Leak) {
+    addMetadata("Leak", "libraryLeak", leak is LibraryLeak)
+    if (leak is LibraryLeak) {
+      addMetadata("Leak", "libraryLeakPattern", leak.pattern.toString())
+      addMetadata("Leak", "libraryLeakDescription", leak.description)
+    }
+  }
+
+  private fun Event.addLeakTrace(leakTrace: LeakTrace) {
+    addMetadata("Leak", "retainedHeapByteSize", leakTrace.retainedHeapByteSize)
+    addMetadata("Leak", "signature", leakTrace.signature)
+    addMetadata("Leak", "leakTrace", leakTrace.toString())
+  }
+
+  private fun LeakTrace.asFakeException(message: String): RuntimeException {
+    val exception = RuntimeException(message)
+    val stackTrace = mutableListOf<StackTraceElement>()
+    stackTrace.add(StackTraceElement("GcRoot", gcRootType.name, "GcRoot.kt", 42))
+    for (cause in referencePath) {
+      stackTrace.add(buildStackTraceElement(cause))
+    }
+    exception.stackTrace = stackTrace.toTypedArray()
+    return exception
+  }
+
+  private fun buildStackTraceElement(reference: LeakTraceReference): StackTraceElement {
+    val file = reference.owningClassName.substringAfterLast(".") + ".kt"
+    return StackTraceElement(reference.owningClassName, reference.referenceDisplayName, file, 42)
+  }
+}
+```
diff --git a/docs/support.md b/docs/support.md
new file mode 100644
index 00000000..13a92c9a
--- /dev/null
+++ b/docs/support.md
@@ -0,0 +1,12 @@
+# LeakCanary Support
+
+If you're looking for help with LeakCanary:
+
+* Learn the [Fundamentals](fundamentals.md)
+* Try the [code recipes](recipes.md)
+* Read the [FAQ](https://square.github.io/leakcanary/faq/)
+* Watch [recorded presentations](recorded-presentations.md)
+* Read [blog articles](blog-articles.md)
+* Ask a question [on StackOverflow](http://stackoverflow.com/questions/tagged/leakcanary?sort=active)
+
+
diff --git a/docs/theme/main.html b/docs/theme/main.html
new file mode 100644
index 00000000..cf487283
--- /dev/null
+++ b/docs/theme/main.html
@@ -0,0 +1,31 @@
+{% extends "base.html" %}
+
+{% block announce %} 
+   Upgrade to <a href="{{ base_url }}/changelog/">LeakCanary <strong>{{config.extra.leak_canary.release}}</strong></a> ðŸ¤ Want to help?  <a href="{{ base_url }}/how_to_help/">Here's how you can contribute<a> ðŸ™
+{% endblock %}
+
+{% block content %}
+  {% if page.edit_url %}
+    {% if "/api/" in page.edit_url %}
+  <span style="float: right">ðŸ¤” Documentation issue? <a href="https://github.com/square/leakcanary/issues/new?assignees=&labels=type%3A+documentation&template=4-doc.md&title=Doc%20issue%20with%20{{ page.url }}%20page">Report it</a></span>
+    {% else %}
+  <span style="float: right">ðŸ¤” Documentation issue? <a href="https://github.com/square/leakcanary/issues/new?assignees=&labels=type%3A+documentation&template=4-doc.md&title=Doc%20issue%20with%20{{ page.url }}%20page">Report</a> or <a href="{{ page.edit_url }}">edit</a></span>
+    {% endif %}
+  {% endif %}
+  {% block source %}
+    {% if page and page.meta and page.meta.source %}
+      {% include "partials/source-link.html" %}
+    {% endif %}
+  {% endblock %}
+  {% if not "\x3ch1" in page.content %}
+    <h1>{{ page.title | default(config.site_name, true)}}</h1>
+  {% endif %}
+  {{ page.content }}
+  {% if page and page.meta %}
+    {% if page.meta.git_revision_date_localized or
+          page.meta.revision_date
+    %}
+      {% include "partials/source-date.html" %}
+    {% endif %}
+  {% endif %}
+{% endblock %}
\ No newline at end of file
diff --git a/docs/ui-tests.md b/docs/ui-tests.md
new file mode 100644
index 00000000..f8b53c55
--- /dev/null
+++ b/docs/ui-tests.md
@@ -0,0 +1,254 @@
+# Leak detection in UI tests
+
+Running leak detection in UI tests means you can detect memory leaks automatically in Continuous
+Integration prior to new leaks being merged into the codebase.
+
+!!! info "Test environment detection"
+    In debug builds, LeakCanary looks for retained instances continuously, freezes the VM to take
+    a heap dump after a watched object has been retained for 5 seconds, then performs the analysis
+    in a background thread and reports the result using notifications. That behavior isn't well suited
+    for UI tests, so LeakCanary is automatically disabled when JUnit is on the runtime classpath
+    (see [test environment detection](recipes.md#leakcanary-test-environment-detection)).
+
+## Getting started
+
+LeakCanary provides an artifact dedicated to detecting leaks in UI tests:
+
+```
+androidTestImplementation "com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}"
+```
+
+You can then call `LeakAssertions.assertNoLeak()` at any point in your tests to check for leaks:
+
+ ```kotlin
+ class CartTest {
+
+   @Test
+   fun addItemToCart() {
+     // ...
+     LeakAssertions.assertNoLeak()
+   }
+ }
+ ```
+
+If retained instances are detected, LeakCanary will dump and analyze the heap. If application leaks
+are found, `LeakAssertions.assertNoLeak()` will throw a `NoLeakAssertionFailedError`.
+
+```
+leakcanary.NoLeakAssertionFailedError: Application memory leaks were detected:
+====================================
+HEAP ANALYSIS RESULT
+====================================
+1 APPLICATION LEAKS
+
+â”¬â”€â”€â”€
+â”‚ GC Root: System class
+â”‚
+â”œâ”€ com.example.MySingleton class
+â”‚    Leaking: NO (a class is never leaking)
+â”‚    â†“ static MySingleton.leakedView
+â”‚                         ~~~~~~~~~~
+â”œâ”€ android.widget.TextView instance
+â”‚    Leaking: YES (View.mContext references a destroyed activity)
+â”‚    â†“ TextView.mContext
+â•°â†’ com.example.MainActivity instance
+     Leaking: YES (Activity#mDestroyed is true)
+====================================
+  at leakcanary.AndroidDetectLeaksAssert.assertNoLeaks(AndroidDetectLeaksAssert.kt:34)
+  at leakcanary.LeakAssertions.assertNoLeaks(LeakAssertions.kt:21)
+  at com.example.CartTest.addItemToCart(TuPeuxPasTest.kt:41)
+```
+
+!!! bug "Obfuscated instrumentation tests"
+    When running instrumentation tests against obfuscated release builds, the LeakCanary classes end
+    up spread over the test APK and the main APK. Unfortunately there is a
+    [bug](https://issuetracker.google.com/issues/126429384) in the Android Gradle Plugin that leads
+    to runtime crashes when running tests, because code from the main APK is changed without the
+    using code in the test APK being updated accordingly. If you run into this issue, setting up the
+    [Keeper plugin](https://slackhq.github.io/keeper/) should fix it.
+
+
+## Test rule
+
+ You can use the `DetectLeaksAfterTestSuccess` test rule to automatically call
+ `LeakAssertions.assertNoLeak()` at the end of a test:
+
+ ```kotlin
+ class CartTest {
+   @get:Rule
+   val rule = DetectLeaksAfterTestSuccess()
+
+   @Test
+   fun addItemToCart() {
+     // ...
+   }
+ }
+ ```
+
+ You can call also `LeakAssertions.assertNoLeak()` as many times as you want in a single test:
+
+ ```kotlin
+ class CartTest {
+   @get:Rule
+   val rule = DetectLeaksAfterTestSuccess()
+
+   // This test has 3 leak assertions (2 in the test + 1 from the rule).
+   @Test
+   fun addItemToCart() {
+     // ...
+     LeakAssertions.assertNoLeak()
+     // ...
+     LeakAssertions.assertNoLeak()
+     // ...
+   }
+ }
+ ```
+
+## Skipping leak detection
+
+Use `@SkipLeakDetection` to disable `LeakAssertions.assertNoLeak()` calls:
+
+ ```kotlin
+ class CartTest {
+   @get:Rule
+   val rule = DetectLeaksAfterTestSuccess()
+
+   // This test will not perform any leak assertion.
+   @SkipLeakDetection("See issue #1234")
+   @Test
+   fun addItemToCart() {
+     // ...
+     LeakAssertions.assertNoLeak()
+     // ...
+     LeakAssertions.assertNoLeak()
+     // ...
+   }
+ }
+ ```
+
+You can use **tags** to identify each `LeakAssertions.assertNoLeak()` call and disable only a subset of these calls:
+
+ ```kotlin
+ class CartTest {
+   @get:Rule
+   val rule = DetectLeaksAfterTestSuccess(tag = "EndOfTest")
+
+   // This test will only perform the second leak assertion.
+   @SkipLeakDetection("See issue #1234", "First Assertion", "EndOfTest")
+   @Test
+   fun addItemToCart() {
+     // ...
+     LeakAssertions.assertNoLeak(tag = "First Assertion")
+     // ...
+     LeakAssertions.assertNoLeak(tag = "Second Assertion")
+     // ...
+   }
+ }
+ ```
+
+Tags can be retrieved by calling `HeapAnalysisSuccess.assertionTag` and are also reported in the
+heap analysis result metadata:
+
+```
+====================================
+METADATA
+
+Please include this in bug reports and Stack Overflow questions.
+
+Build.VERSION.SDK_INT: 23
+...
+assertionTag: Second Assertion
+```
+
+## Test rule chains
+
+```kotlin
+// Example test rule chain
+@get:Rule
+val rule = RuleChain.outerRule(LoginRule())
+  .around(ActivityScenarioRule(CartActivity::class.java))
+  .around(LoadingScreenRule())
+
+```
+
+If you use a test rule chain, the position of the `DetectLeaksAfterTestSuccess` rule in that chain
+could be significant. For example, if you use an `ActivityScenarioRule` that automatically
+finishes the activity at the end of a test, having `DetectLeaksAfterTestSuccess` around
+`ActivityScenarioRule` will detect leaks after the activity is destroyed and therefore detect any
+activity leak. But then  `DetectLeaksAfterTestSuccess` will not detect fragment leaks that go away
+when the activity is destroyed.
+
+```kotlin
+@get:Rule
+val rule = RuleChain.outerRule(LoginRule())
+  // Detect leaks AFTER activity is destroyed
+  .around(DetectLeaksAfterTestSuccess(tag = "AfterActivityDestroyed"))
+  .around(ActivityScenarioRule())
+  .around(LoadingScreenRule())
+```
+
+If instead you set up `ActivityScenarioRule` around `DetectLeaksAfterTestSuccess`, destroyed
+activity leaks will not be detected as the activity will still be created when the leak assertion
+rule runs, but more fragment leaks might be detected.
+
+```kotlin
+@get:Rule
+val rule = RuleChain.outerRule(LoginRule())
+  .around(ActivityScenarioRule(CartActivity::class.java))
+  // Detect leaks BEFORE activity is destroyed
+  .around(DetectLeaksAfterTestSuccess(tag = "BeforeActivityDestroyed"))
+  .around(LoadingScreenRule())
+```
+
+To detect all leaks, the best option is to
+set up the `DetectLeaksAfterTestSuccess` rule twice, before and after the `ActivityScenarioRule`
+rule.
+
+```kotlin
+// Detect leaks BEFORE and AFTER activity is destroyed
+@get:Rule
+val rule = RuleChain.outerRule(LoginRule())
+  .around(DetectLeaksAfterTestSuccess(tag = "AfterActivityDestroyed"))
+  .around(ActivityScenarioRule(CartActivity::class.java))
+  .around(DetectLeaksAfterTestSuccess(tag = "BeforeActivityDestroyed"))
+  .around(LoadingScreenRule())
+```
+
+`RuleChain.detectLeaksAfterTestSuccessWrapping()` is a helper for doing just that:
+
+```kotlin
+// Detect leaks BEFORE and AFTER activity is destroyed
+@get:Rule
+val rule = RuleChain.outerRule(LoginRule())
+  // The tag will be suffixed with "Before" and "After".
+  .detectLeaksAfterTestSuccessWrapping(tag = "ActivitiesDestroyed") {
+    around(ActivityScenarioRule(CartActivity::class.java))
+  }
+  .around(LoadingScreenRule())
+```
+
+## Customizing `assertNoLeak()`
+
+`LeakAssertions.assertNoLeak()` delegates calls to a global `DetectLeaksAssert` implementation,
+which by default is an instance of `AndroidDetectLeaksAssert`. You can change the
+`DetectLeaksAssert` implementation by calling `DetectLeaksAssert.update(customLeaksAssert)`.
+
+The `AndroidDetectLeaksAssert` implementation performs a heap dump when retained instances are
+detected, analyzes the heap, then passes the result to a `HeapAnalysisReporter`. The default
+`HeapAnalysisReporter` is `NoLeakAssertionFailedError.throwOnApplicationLeaks()` which throws a
+`NoLeakAssertionFailedError` if an application leak is detected.
+
+You could provide a custom implementation to also upload heap analysis results to a central place
+before failing the test:
+```kotlin
+val throwingReporter = NoLeakAssertionFailedError.throwOnApplicationLeaks()
+
+DetectLeaksAssert.update(AndroidDetectLeaksAssert(
+  heapAnalysisReporter = { heapAnalysis ->
+    // Upload the heap analysis result
+    heapAnalysisUploader.upload(heapAnalysis)
+    // Fail the test if there are application leaks
+    throwingReporter.reportHeapAnalysis(heapAnalysis)
+  }
+))
+```
diff --git a/docs/upgrading-to-leakcanary-2.0.md b/docs/upgrading-to-leakcanary-2.0.md
new file mode 100644
index 00000000..4a473558
--- /dev/null
+++ b/docs/upgrading-to-leakcanary-2.0.md
@@ -0,0 +1,289 @@
+LeakCanary 2 is a major rewrite. High level changes:
+
+* New heap analyzer, reimplemented from scratch to use 10 times less memory ([see Shark](shark.md)).
+* APIs updated to simplify configuration and provide access to the new heap analyzer.
+* Internals rewritten to 100% Kotlin.
+* Multiple leaks detected in one analysis, grouped per leak type
+
+## Dependencies
+
+### Before
+
+```groovy
+dependencies {
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.3'
+  releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.3'
+  // Optional, if you use support library fragments:
+  debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.3'
+}
+```
+
+### Now
+
+```groovy
+dependencies {
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:{{ leak_canary.release }}'
+}
+```
+
+### Worth noting
+
+* The `leakcanary-android-no-op` artifact is gone. If you have compile errors, see below.
+  * **Question**: if there's no no-op anymore, how do I ensure none of this runs during release builds?
+  * **Answer**: as long as you add `leakcanary-android` as `debugImplementation`, there won't be any code referencing LeakCanary in your release builds.
+* LeakCanary does not depend on the support library anymore, and it doesn't depend on AndroidX either.
+* Detection of AndroidX fragments is automatic if you have the AndroidX fragments dependency.
+
+## Default setup code
+
+### Before
+
+```java
+public class ExampleApplication extends Application {
+
+  @Override public void onCreate() {
+    super.onCreate();
+    if (LeakCanary.isInAnalyzerProcess(this)) {
+      // This process is dedicated to LeakCanary for heap analysis.
+      // You should not init your app in this process.
+      return;
+    }
+    LeakCanary.install(this);
+    // Normal app init code...
+  }
+}
+```
+
+### Now
+
+There is no more code for default setup.
+
+### Worth noting
+
+* LeakCanary auto installs itself
+* LeakCanary analysis now runs in the main process so there is no need to call `LeakCanary.isInAnalyzerProcess()`.
+
+## Retrieve the RefWatcher
+
+### Before
+
+```kotlin
+val refWatcher: RefWatcher = LeakCanary.installedRefWatcher()
+```
+
+### Now
+
+```kotlin
+val objectWatcher: ObjectWatcher = AppWatcher.objectWatcher
+```
+
+## Compile errors because RefWatcher is used in release code
+
+If you were using `RefWatcher` in non debug code, you now get a compile error because the no-op artifact is gone. [ObjectWatcher](/leakcanary/api/leakcanary-object-watcher/leakcanary/-object-watcher/) now lives in the `object-watcher` artifact, which is suitable for release builds. You have two options:
+
+### Option 1: Add `object-watcher-android` to release builds.
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:{{ leak_canary.release }}'
+}
+```
+
+* It will automatically keep weak references to destroyed activities, fragments, and any instance you pass to [AppWatcher.objectWatcher](/leakcanary/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/object-watcher/).
+* It will not trigger heap dumps or anything else that LeakCanary does.
+* It's very little code and should have a no impact on your release app.
+* You can use it to count how many objects are retained, for example to add metadata to OutOfMemoryError crashes:
+
+```kotlin
+val retainedObjectCount = AppWatcher.objectWatcher.retainedObjectCount
+```
+
+### Option 2: Make your own `ObjectWatcher` interface
+
+```kotlin
+// In shared code
+interface MaybeObjectWatcher {
+  fun watch(watchedObject: Any, description: String)
+
+  object None : MaybeObjectWatcher {
+    override fun watch(watchedObject: Any, description: String) {
+    }
+  }
+}
+
+// In debug code
+class RealObjectWatcher : MaybeObjectWatcher {
+  override fun watch(watchedObject: Any, description: String) {
+    AppWatcher.objectWatcher.watch(watchedObject, description)
+  }
+}
+```
+
+Use `MaybeObjectWatcher.None` in release code and `RealObjectWatcher` in debug code.
+
+## Configuring LeakCanary
+
+### Before
+
+```java
+public class DebugExampleApplication extends ExampleApplication {
+
+  @Override protected void installLeakCanary() {
+    RefWatcher refWatcher = LeakCanary.refWatcher(this)
+      .watchActivities(false)
+      .buildAndInstall();
+  }
+}
+```
+
+### Now
+
+AppWatcher is in charge of detecting retained objects. Its configuration can be updated at any time by replacing [AppWatcher.config](/leakcanary/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/config/):
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    AppWatcher.config = AppWatcher.config.copy(watchFragmentViews = false)
+  }
+}
+```
+
+LeakCanary is in charge of taking heap dumps and analyzing them. Its configuration can be updated at any time by replacing [LeakCanary.config](/leakcanary/api/leakcanary-android-core/leakcanary/-leak-canary/config/):
+
+```kotlin
+disableLeakCanaryButton.setOnClickListener {
+  LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
+}
+```
+
+## Running LeakCanary in instrumentation tests
+
+### Before
+
+In your `build.gradle` file:
+
+```groovy
+dependencies {
+  androidTestImplementation "com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}"
+}
+
+android {
+  defaultConfig {
+    // ...
+
+    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    testInstrumentationRunnerArgument "listener", "com.squareup.leakcanary.FailTestOnLeakRunListener"
+  }
+}
+```
+
+In your test `Application` class:
+
+```java
+public class InstrumentationTestExampleApplication extends DebugExampleApplication {
+  @Override protected void installLeakCanary() {
+    InstrumentationLeakDetector.instrumentationRefWatcher(this)
+      .buildAndInstall();
+  }
+}
+```
+
+### Now
+
+Remove all the previous test related leak detection code then follow
+[Leak detection in UI tests](ui-tests.md).
+
+## Analysis listener / uploading to a server
+
+### Before
+
+
+```java
+public class LeakUploadService extends DisplayLeakService {
+  @Override protected void afterDefaultHandling(HeapDump heapDump, AnalysisResult result, String leakInfo) {
+    // TODO Upload result to server
+  }
+}
+```
+
+```java
+RefWatcher refWatcher = LeakCanary.refWatcher(this)
+  .listenerServiceClass(LeakUploadService.class)
+  .buildAndInstall();
+```
+
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android">
+  <application android:name="com.example.DebugExampleApplication">
+    <service android:name="com.example.LeakUploadService" />
+  </application>
+</manifest>
+```
+
+### Now
+
+```Kotlin
+class LeakUploader : OnHeapAnalyzedListener {
+
+  val defaultListener = DefaultOnHeapAnalyzedListener.create()
+
+  override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {
+    TODO("Upload heap analysis to server")
+
+    // Delegate to default behavior (notification and saving result)
+    defaultListener.onHeapAnalyzed(heapAnalysis)
+  }
+}
+
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakCanary.config = LeakCanary.config.copy(
+        onHeapAnalyzedListener = LeakUploader()
+    )
+  }
+}
+```
+
+### Matching known library leaks
+
+### Before
+
+```java
+ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults()
+    .staticField("com.samsing.SomeSingleton", "sContext")
+    .build();
+RefWatcher refWatcher = LeakCanary.refWatcher(this)
+  .excludedRefs(excludedRefs)
+  .buildAndInstall();
+}
+```
+
+### Now
+
+```kotlin
+LeakCanary.config = LeakCanary.config.copy(
+    referenceMatchers = AndroidReferenceMatchers.appDefaults +
+        AndroidReferenceMatchers.staticFieldLeak(
+            "com.samsing.SomeSingleton",
+            "sContext"
+        )
+)
+```
+
+!!! info
+    There is no equivalent API to `ExcludedRefs.Builder.clazz()` because it led to abuses. Instead see [Ignoring specific activities or fragment classes](recipes.md#ignoring-specific-activities-or-fragment-classes).
+
+## Public API packages
+
+### Before
+
+All public APIs were in `com.squareup.leakcanary.*`
+
+### Now
+
+All public APIs are in `leakcanary.*`
diff --git a/docs/uploading.md b/docs/uploading.md
new file mode 100644
index 00000000..683df71e
--- /dev/null
+++ b/docs/uploading.md
@@ -0,0 +1,76 @@
+# Uploading analysis results
+
+You can add an `EventListener` to upload the analysis result to a server of your choosing:
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    val analysisUploadListener = EventListener { event ->
+      if (event is HeapAnalysisSucceeded) {
+        val heapAnalysis = event.heapAnalysis
+        TODO("Upload heap analysis to server")
+      }
+    }
+
+    LeakCanary.config = LeakCanary.config.run {
+      copy(eventListeners = eventListeners + analysisUploadListener)
+    }
+  }
+}
+```
+
+## Uploading to Bugsnag
+
+A leak trace has a lot in common with a stack trace, so if you lack the engineering resources to
+build a backend for LeakCanary, you can instead upload leak traces to a crash reporting backend.
+The client needs to support grouping via custom client-side hashing as well as custom metadata with
+support for newlines.
+
+!!! info
+    As of this writing, the only known library suitable for uploading leaks is the Bugsnag client.
+    If you managed to make it work with another library, please [file an issue](https://github.com/square/leakcanary/issues/new/choose).
+
+Create a [Bugsnag account](https://app.bugsnag.com/user/new/), create a new project for leak
+reporting and grab an **API key**. Make sure the app has the `android.permission.INTERNET`
+permission then add the [latest version](https://docs.bugsnag.com/platforms/android/) of the
+Bugsnag Android client library to `build.gradle`:
+
+```groovy
+dependencies {
+  // debugImplementation because LeakCanary should only run in debug builds.
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:{{ leak_canary.release }}'
+  debugImplementation "com.bugsnag:bugsnag-android:$bugsnagVersion"
+}
+```
+
+!!! info
+    If you're only using Bugsnag for uploading leaks, then you do not need to set up the Bugsnag
+    Gradle plugin or to configure the API key in your app manifest.
+
+Create a new `BugsnagLeakUploader`:
+
+--8<-- "docs/snippets/bugsnag-uploader.md"
+
+Then add an `EventListener` to upload the analysis result to Bugsnag:
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakCanary.config = LeakCanary.config.copy(
+        onHeapAnalyzedListener = BugsnagLeakUploader(applicationContext = this)
+    )
+  }
+}
+```
+
+You should start seeing leaks reported into Bugsnag, grouped by their leak signature:
+
+![list](images/bugsnag-list.png)
+
+The `LEAK` tab contains the leak trace:
+
+![leak](images/bugsnag-leak.png)
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 00000000..f55484e6
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,25 @@
+GROUP=com.squareup.leakcanary
+VERSION_NAME=2.13
+
+POM_DESCRIPTION=LeakCanary
+POM_INCEPTION_YEAR=2015
+POM_URL=https://github.com/square/leakcanary/
+POM_SCM_URL=https://github.com/square/leakcanary/
+POM_SCM_CONNECTION=scm:git:https://github.com/square/leakcanary.git
+POM_SCM_DEV_CONNECTION=scm:git:git@github.com:square/leakcanary.git
+
+POM_LICENSE_NAME=The Apache Software License, Version 2.0
+POM_LICENSE_URL=https://www.apache.org/licenses/LICENSE-2.0.txt
+POM_LICENSE_DIST=repo
+
+POM_DEVELOPER_ID=square
+POM_DEVELOPER_NAME=Square, Inc.
+POM_DEVELOPER_URL=https://github.com/square/
+SONATYPE_STAGING_PROFILE=com.squareup
+
+android.useAndroidX=true
+#Gradle properties: https://docs.gradle.org/current/userguide/build_environment.html
+org.gradle.caching=true
+org.gradle.configureondemand=true
+org.gradle.jvmargs=-XX:+UseParallelGC -Dfile.encoding=UTF-8
+org.gradle.parallel=true
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
new file mode 100644
index 00000000..1eaf9a49
--- /dev/null
+++ b/gradle/libs.versions.toml
@@ -0,0 +1,66 @@
+# Copyright (C) 2021 Square, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+[versions]
+# We would like to use Kotlin 1.4 language features but keep Kotlin 1.3 library APIs
+# The benefit is that depending clients do not have to upgrade to Kotlin 1.4
+kotlinCompiler = "1.4.21"
+kotlinLib = "1.3.72"
+androidXTest = "1.1.0"
+androidXJunit = "1.1.3"
+workManager = "2.7.0"
+
+[libraries]
+gradlePlugin-android = { module = "com.android.tools.build:gradle", version = "4.2.2" }
+gradlePlugin-kotlin = { module = "org.jetbrains.kotlin:kotlin-gradle-plugin", version.ref = "kotlinCompiler" }
+gradlePlugin-dokka = { module = "org.jetbrains.dokka:dokka-gradle-plugin", version = "1.6.20" }
+gradlePlugin-binaryCompatibility = { module = "org.jetbrains.kotlinx:binary-compatibility-validator", version = "0.8.0" }
+gradlePlugin-mavenPublish = { module = "com.vanniktech:gradle-maven-publish-plugin", version = "0.18.0" }
+gradlePlugin-detekt = { module = "io.gitlab.arturbosch.detekt:detekt-gradle-plugin", version = "1.6.0" }
+gradlePlugin-keeper = { module = "com.slack.keeper:keeper", version = "0.7.0" }
+
+kotlin-stdlib = { module = "org.jetbrains.kotlin:kotlin-stdlib", version.ref = "kotlinLib" }
+kotlin-reflect = { module = "org.jetbrains.kotlin:kotlin-reflect", version.ref = "kotlinLib" }
+
+# We don't need the latest version of AndroidX (there are no bugs that impact what LeakCanary
+# relies on), we're sticking a bit older because most apps will be using a more recent version
+# and they'll automatically resolve to higher version without having to necessarily resort to a
+# resolution strategy.
+androidX-fragment = { module = "androidx.fragment:fragment", version = "1.0.0" }
+# Exposed transitively, avoid increasing
+androidX-startup = { module = "androidx.startup:startup-runtime", version = "1.0.0" }
+androidX-test-core = { module = "androidx.test:core", version = "1.4.0" }
+androidX-test-rules = { module = "androidx.test:rules", version.ref = "androidXTest" }
+# Exposed transitively, avoid increasing
+androidX-test-runner = { module = "androidx.test:runner", version = "1.4.0" }
+androidX-test-orchestrator = { module = "androidx.test:orchestrator", version = "1.4.1" }
+androidX-test-espresso = { module = "androidx.test.espresso:espresso-core", version = "3.4.0" }
+androidX-test-junit = { module = "androidx.test.ext:junit", version.ref = "androidXJunit" }
+androidX-test-junitKtx = { module = "androidx.test.ext:junit-ktx", version.ref = "androidXJunit" }
+androidX-work-runtime = { module = "androidx.work:work-runtime", version.ref = "workManager" }
+androidX-work-multiprocess = { module = "androidx.work:work-multiprocess", version.ref = "workManager" }
+
+androidSupport = { module = "com.android.support:support-v4", version = "28.0.0" }
+assertjCore = { module = "org.assertj:assertj-core", version = "3.9.1" }
+clikt = { module = "com.github.ajalt:clikt", version = "2.3.0" }
+neo4j = { module = "org.neo4j:neo4j", version = "4.4.6" }
+curtains = { module = "com.squareup.curtains:curtains", version = "1.2.4" }
+jline = { module = "jline:jline", version = "2.14.6" }
+junit = { module = "junit:junit", version = "4.12" }
+kotlinStatistics = { module = "org.nield:kotlin-statistics", version = "1.2.1" }
+mockito = { module = "org.mockito:mockito-core", version = "3.5.10" }
+mockitoKotlin = { module = "com.nhaarman.mockitokotlin2:mockito-kotlin", version = "2.2.0" }
+robolectric = { module = "org.robolectric:robolectric", version = "4.0-alpha-3" }
+okio2 = { module = "com.squareup.okio:okio", version = "2.2.2" }
+okio1 = { module = "com.squareup.okio:okio", version = "1.14.0" }
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 00000000..41d9927a
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 00000000..aa991fce
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,5 @@
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-7.4.2-bin.zip
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
diff --git a/gradlew b/gradlew
new file mode 100755
index 00000000..1b6c7873
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,234 @@
+#!/bin/sh
+
+#
+# Copyright Â© 2015-2021 the original authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+##############################################################################
+#
+#   Gradle start up script for POSIX generated by Gradle.
+#
+#   Important for running:
+#
+#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
+#       noncompliant, but you have some other compliant shell such as ksh or
+#       bash, then to run this script, type that shell name before the whole
+#       command line, like:
+#
+#           ksh Gradle
+#
+#       Busybox and similar reduced shells will NOT work, because this script
+#       requires all of these POSIX shell features:
+#         * functions;
+#         * expansions Â«$varÂ», Â«${var}Â», Â«${var:-default}Â», Â«${var+SET}Â»,
+#           Â«${var#prefix}Â», Â«${var%suffix}Â», and Â«$( cmd )Â»;
+#         * compound commands having a testable exit status, especially Â«caseÂ»;
+#         * various built-in commands including Â«commandÂ», Â«setÂ», and Â«ulimitÂ».
+#
+#   Important for patching:
+#
+#   (2) This script targets any POSIX shell, so it avoids extensions provided
+#       by Bash, Ksh, etc; in particular arrays are avoided.
+#
+#       The "traditional" practice of packing multiple parameters into a
+#       space-separated string is a well documented source of bugs and security
+#       problems, so this is (mostly) avoided, by progressively accumulating
+#       options in "$@", and eventually passing that to Java.
+#
+#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
+#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
+#       see the in-line comments for details.
+#
+#       There are tweaks for specific operating systems such as AIX, CygWin,
+#       Darwin, MinGW, and NonStop.
+#
+#   (3) This script is generated from the Groovy template
+#       https://github.com/gradle/gradle/blob/master/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
+#       within the Gradle project.
+#
+#       You can find Gradle at https://github.com/gradle/gradle/.
+#
+##############################################################################
+
+# Attempt to set APP_HOME
+
+# Resolve links: $0 may be a link
+app_path=$0
+
+# Need this for daisy-chained symlinks.
+while
+    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
+    [ -h "$app_path" ]
+do
+    ls=$( ls -ld "$app_path" )
+    link=${ls#*' -> '}
+    case $link in             #(
+      /*)   app_path=$link ;; #(
+      *)    app_path=$APP_HOME$link ;;
+    esac
+done
+
+APP_HOME=$( cd "${APP_HOME:-./}" && pwd -P ) || exit
+
+APP_NAME="Gradle"
+APP_BASE_NAME=${0##*/}
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD=maximum
+
+warn () {
+    echo "$*"
+} >&2
+
+die () {
+    echo
+    echo "$*"
+    echo
+    exit 1
+} >&2
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "$( uname )" in                #(
+  CYGWIN* )         cygwin=true  ;; #(
+  Darwin* )         darwin=true  ;; #(
+  MSYS* | MINGW* )  msys=true    ;; #(
+  NONSTOP* )        nonstop=true ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD=$JAVA_HOME/jre/sh/java
+    else
+        JAVACMD=$JAVA_HOME/bin/java
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD=java
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
+    case $MAX_FD in #(
+      max*)
+        MAX_FD=$( ulimit -H -n ) ||
+            warn "Could not query maximum file descriptor limit"
+    esac
+    case $MAX_FD in  #(
+      '' | soft) :;; #(
+      *)
+        ulimit -n "$MAX_FD" ||
+            warn "Could not set maximum file descriptor limit to $MAX_FD"
+    esac
+fi
+
+# Collect all arguments for the java command, stacking in reverse order:
+#   * args from the command line
+#   * the main class name
+#   * -classpath
+#   * -D...appname settings
+#   * --module-path (only if needed)
+#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.
+
+# For Cygwin or MSYS, switch paths to Windows format before running java
+if "$cygwin" || "$msys" ; then
+    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
+    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )
+
+    JAVACMD=$( cygpath --unix "$JAVACMD" )
+
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    for arg do
+        if
+            case $arg in                                #(
+              -*)   false ;;                            # don't mess with options #(
+              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
+                    [ -e "$t" ] ;;                      #(
+              *)    false ;;
+            esac
+        then
+            arg=$( cygpath --path --ignore --mixed "$arg" )
+        fi
+        # Roll the args list around exactly as many times as the number of
+        # args, so each arg winds up back in the position where it started, but
+        # possibly modified.
+        #
+        # NB: a `for` loop captures its iteration list before it begins, so
+        # changing the positional parameters here affects neither the number of
+        # iterations, nor the values presented in `arg`.
+        shift                   # remove old arg
+        set -- "$@" "$arg"      # push replacement arg
+    done
+fi
+
+# Collect all arguments for the java command;
+#   * $DEFAULT_JVM_OPTS, $JAVA_OPTS, and $GRADLE_OPTS can contain fragments of
+#     shell script including quotes and variable substitutions, so put them in
+#     double quotes to make sure that they get re-expanded; and
+#   * put everything else in single quotes, so that it's not re-expanded.
+
+set -- \
+        "-Dorg.gradle.appname=$APP_BASE_NAME" \
+        -classpath "$CLASSPATH" \
+        org.gradle.wrapper.GradleWrapperMain \
+        "$@"
+
+# Use "xargs" to parse quoted args.
+#
+# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
+#
+# In Bash we could simply go:
+#
+#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
+#   set -- "${ARGS[@]}" "$@"
+#
+# but POSIX shell has neither arrays nor command substitution, so instead we
+# post-process each arg (as a line of input to sed) to backslash-escape any
+# character that might be a shell metacharacter, then use eval to reverse
+# that process (while maintaining the separation between arguments), and wrap
+# the whole thing up as a single "set" statement.
+#
+# This will of course break if any of these variables contains a newline or
+# an unmatched quote.
+#
+
+eval "set -- $(
+        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
+        xargs -n1 |
+        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
+        tr '\n' ' '
+    )" '"$@"'
+
+exec "$JAVACMD" "$@"
diff --git a/hooks/pre-push b/hooks/pre-push
new file mode 100644
index 00000000..3c0d5fc1
--- /dev/null
+++ b/hooks/pre-push
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+echo "Running static analysis..."
+
+# Run static analysis tools
+./gradlew detekt
+
+status=$?
+
+if [ "$status" = 0 ] ; then
+    echo "Static analysis found no problems."
+    exit 0
+else
+    echo 1>&2 "Static analysis found violations! Fix them before pushing your code!"
+    echo "See generated reports above or in /<project_dir>/build/reports folder"
+    exit 1
+fi
diff --git a/leakcanary-android-core/api/leakcanary-android-core.api b/leakcanary-android-core/api/leakcanary-android-core.api
new file mode 100644
index 00000000..f205c242
--- /dev/null
+++ b/leakcanary-android-core/api/leakcanary-android-core.api
@@ -0,0 +1,194 @@
+public final class com/squareup/leakcanary/core/BuildConfig {
+	public static final field BUILD_TYPE Ljava/lang/String;
+	public static final field DEBUG Z
+	public static final field GIT_SHA Ljava/lang/String;
+	public static final field LIBRARY_PACKAGE_NAME Ljava/lang/String;
+	public static final field LIBRARY_VERSION Ljava/lang/String;
+	public fun <init> ()V
+}
+
+public final class leakcanary/AndroidDebugHeapDumper : leakcanary/HeapDumper {
+	public static final field INSTANCE Lleakcanary/AndroidDebugHeapDumper;
+	public fun dumpHeap (Ljava/io/File;)V
+}
+
+public final class leakcanary/BackgroundThreadHeapAnalyzer : leakcanary/EventListener {
+	public static final field INSTANCE Lleakcanary/BackgroundThreadHeapAnalyzer;
+	public fun onEvent (Lleakcanary/EventListener$Event;)V
+}
+
+public final class leakcanary/DefaultOnHeapAnalyzedListener : leakcanary/OnHeapAnalyzedListener {
+	public static final field Companion Lleakcanary/DefaultOnHeapAnalyzedListener$Companion;
+	public fun <init> (Landroid/app/Application;)V
+	public fun onHeapAnalyzed (Lshark/HeapAnalysis;)V
+}
+
+public final class leakcanary/DefaultOnHeapAnalyzedListener$Companion {
+	public final fun create ()Lleakcanary/OnHeapAnalyzedListener;
+}
+
+public abstract interface class leakcanary/EventListener {
+	public abstract fun onEvent (Lleakcanary/EventListener$Event;)V
+}
+
+public abstract class leakcanary/EventListener$Event : java/io/Serializable {
+	public synthetic fun <init> (Ljava/lang/String;Lkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun getUniqueId ()Ljava/lang/String;
+}
+
+public final class leakcanary/EventListener$Event$DumpingHeap : leakcanary/EventListener$Event {
+	public fun <init> (Ljava/lang/String;)V
+}
+
+public abstract class leakcanary/EventListener$Event$HeapAnalysisDone : leakcanary/EventListener$Event {
+	public synthetic fun <init> (Ljava/lang/String;Lshark/HeapAnalysis;Landroid/content/Intent;Lkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun getHeapAnalysis ()Lshark/HeapAnalysis;
+	public final fun getShowIntent ()Landroid/content/Intent;
+}
+
+public final class leakcanary/EventListener$Event$HeapAnalysisDone$HeapAnalysisFailed : leakcanary/EventListener$Event$HeapAnalysisDone {
+	public fun <init> (Ljava/lang/String;Lshark/HeapAnalysisFailure;Landroid/content/Intent;)V
+}
+
+public final class leakcanary/EventListener$Event$HeapAnalysisDone$HeapAnalysisSucceeded : leakcanary/EventListener$Event$HeapAnalysisDone {
+	public fun <init> (Ljava/lang/String;Lshark/HeapAnalysisSuccess;Ljava/util/Set;Landroid/content/Intent;)V
+	public final fun getUnreadLeakSignatures ()Ljava/util/Set;
+}
+
+public final class leakcanary/EventListener$Event$HeapAnalysisProgress : leakcanary/EventListener$Event {
+	public fun <init> (Ljava/lang/String;Lshark/OnAnalysisProgressListener$Step;D)V
+	public final fun getProgressPercent ()D
+	public final fun getStep ()Lshark/OnAnalysisProgressListener$Step;
+}
+
+public final class leakcanary/EventListener$Event$HeapDump : leakcanary/EventListener$Event {
+	public fun <init> (Ljava/lang/String;Ljava/io/File;JLjava/lang/String;)V
+	public final fun getDurationMillis ()J
+	public final fun getFile ()Ljava/io/File;
+	public final fun getReason ()Ljava/lang/String;
+}
+
+public final class leakcanary/EventListener$Event$HeapDumpFailed : leakcanary/EventListener$Event {
+	public fun <init> (Ljava/lang/String;Ljava/lang/Throwable;Z)V
+	public final fun getException ()Ljava/lang/Throwable;
+	public final fun getWillRetryLater ()Z
+}
+
+public abstract interface class leakcanary/HeapDumper {
+	public abstract fun dumpHeap (Ljava/io/File;)V
+}
+
+public final class leakcanary/LazyForwardingEventListener : leakcanary/EventListener {
+	public fun <init> (Lkotlin/jvm/functions/Function0;)V
+	public fun onEvent (Lleakcanary/EventListener$Event;)V
+}
+
+public final class leakcanary/LeakCanary {
+	public static final field INSTANCE Lleakcanary/LeakCanary;
+	public final fun dumpHeap ()V
+	public static final fun getConfig ()Lleakcanary/LeakCanary$Config;
+	public final fun newLeakDisplayActivityIntent ()Landroid/content/Intent;
+	public static final fun setConfig (Lleakcanary/LeakCanary$Config;)V
+	public final fun showLeakDisplayActivityLauncherIcon (Z)V
+}
+
+public final class leakcanary/LeakCanary$Config {
+	public fun <init> ()V
+	public fun <init> (ZZILjava/util/List;Ljava/util/List;Lleakcanary/OnHeapAnalyzedListener;Lshark/MetadataExtractor;ZIZLshark/LeakingObjectFinder;Lleakcanary/HeapDumper;Ljava/util/List;ZZ)V
+	public synthetic fun <init> (ZZILjava/util/List;Ljava/util/List;Lleakcanary/OnHeapAnalyzedListener;Lshark/MetadataExtractor;ZIZLshark/LeakingObjectFinder;Lleakcanary/HeapDumper;Ljava/util/List;ZZILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun component1 ()Z
+	public final fun component10 ()Z
+	public final fun component11 ()Lshark/LeakingObjectFinder;
+	public final fun component12 ()Lleakcanary/HeapDumper;
+	public final fun component13 ()Ljava/util/List;
+	public final fun component14 ()Z
+	public final fun component15 ()Z
+	public final fun component2 ()Z
+	public final fun component3 ()I
+	public final fun component4 ()Ljava/util/List;
+	public final fun component5 ()Ljava/util/List;
+	public final fun component6 ()Lleakcanary/OnHeapAnalyzedListener;
+	public final fun component7 ()Lshark/MetadataExtractor;
+	public final fun component8 ()Z
+	public final fun component9 ()I
+	public final fun copy (ZZILjava/util/List;Ljava/util/List;Lleakcanary/OnHeapAnalyzedListener;Lshark/MetadataExtractor;ZIZLshark/LeakingObjectFinder;Lleakcanary/HeapDumper;Ljava/util/List;ZZ)Lleakcanary/LeakCanary$Config;
+	public static synthetic fun copy$default (Lleakcanary/LeakCanary$Config;ZZILjava/util/List;Ljava/util/List;Lleakcanary/OnHeapAnalyzedListener;Lshark/MetadataExtractor;ZIZLshark/LeakingObjectFinder;Lleakcanary/HeapDumper;Ljava/util/List;ZZILjava/lang/Object;)Lleakcanary/LeakCanary$Config;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getComputeRetainedHeapSize ()Z
+	public final fun getDumpHeap ()Z
+	public final fun getDumpHeapWhenDebugging ()Z
+	public final fun getEventListeners ()Ljava/util/List;
+	public final fun getHeapDumper ()Lleakcanary/HeapDumper;
+	public final fun getLeakingObjectFinder ()Lshark/LeakingObjectFinder;
+	public final fun getMaxStoredHeapDumps ()I
+	public final fun getMetadataExtractor ()Lshark/MetadataExtractor;
+	public final fun getObjectInspectors ()Ljava/util/List;
+	public final fun getOnHeapAnalyzedListener ()Lleakcanary/OnHeapAnalyzedListener;
+	public final fun getReferenceMatchers ()Ljava/util/List;
+	public final fun getRequestWriteExternalStoragePermission ()Z
+	public final fun getRetainedVisibleThreshold ()I
+	public final fun getShowNotifications ()Z
+	public final fun getUseExperimentalLeakFinders ()Z
+	public fun hashCode ()I
+	public final fun newBuilder ()Lleakcanary/LeakCanary$Config$Builder;
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class leakcanary/LeakCanary$Config$Builder {
+	public final fun build ()Lleakcanary/LeakCanary$Config;
+	public final fun computeRetainedHeapSize (Z)Lleakcanary/LeakCanary$Config$Builder;
+	public final fun dumpHeap (Z)Lleakcanary/LeakCanary$Config$Builder;
+	public final fun dumpHeapWhenDebugging (Z)Lleakcanary/LeakCanary$Config$Builder;
+	public final fun eventListeners (Ljava/util/List;)Lleakcanary/LeakCanary$Config$Builder;
+	public final fun heapDumper (Lleakcanary/HeapDumper;)Lleakcanary/LeakCanary$Config$Builder;
+	public final fun leakingObjectFinder (Lshark/LeakingObjectFinder;)Lleakcanary/LeakCanary$Config$Builder;
+	public final fun maxStoredHeapDumps (I)Lleakcanary/LeakCanary$Config$Builder;
+	public final fun metadataExtractor (Lshark/MetadataExtractor;)Lleakcanary/LeakCanary$Config$Builder;
+	public final fun objectInspectors (Ljava/util/List;)Lleakcanary/LeakCanary$Config$Builder;
+	public final fun onHeapAnalyzedListener (Lleakcanary/OnHeapAnalyzedListener;)Lleakcanary/LeakCanary$Config$Builder;
+	public final fun referenceMatchers (Ljava/util/List;)Lleakcanary/LeakCanary$Config$Builder;
+	public final fun requestWriteExternalStoragePermission (Z)Lleakcanary/LeakCanary$Config$Builder;
+	public final fun retainedVisibleThreshold (I)Lleakcanary/LeakCanary$Config$Builder;
+	public final fun showNotifications (Z)Lleakcanary/LeakCanary$Config$Builder;
+	public final fun useExperimentalLeakFinders (Z)Lleakcanary/LeakCanary$Config$Builder;
+}
+
+public final class leakcanary/LogcatEventListener : leakcanary/EventListener {
+	public static final field INSTANCE Lleakcanary/LogcatEventListener;
+	public fun onEvent (Lleakcanary/EventListener$Event;)V
+}
+
+public final class leakcanary/NotificationEventListener : leakcanary/EventListener {
+	public static final field INSTANCE Lleakcanary/NotificationEventListener;
+	public fun onEvent (Lleakcanary/EventListener$Event;)V
+}
+
+public abstract interface class leakcanary/OnHeapAnalyzedListener {
+	public static final field Companion Lleakcanary/OnHeapAnalyzedListener$Companion;
+	public abstract fun onHeapAnalyzed (Lshark/HeapAnalysis;)V
+}
+
+public final class leakcanary/OnHeapAnalyzedListener$Companion {
+	public final fun invoke (Lkotlin/jvm/functions/Function1;)Lleakcanary/OnHeapAnalyzedListener;
+}
+
+public final class leakcanary/RemoteWorkManagerHeapAnalyzer : leakcanary/EventListener {
+	public static final field INSTANCE Lleakcanary/RemoteWorkManagerHeapAnalyzer;
+	public fun onEvent (Lleakcanary/EventListener$Event;)V
+}
+
+public final class leakcanary/ToastEventListener : leakcanary/EventListener {
+	public static final field INSTANCE Lleakcanary/ToastEventListener;
+	public fun onEvent (Lleakcanary/EventListener$Event;)V
+}
+
+public final class leakcanary/TvEventListener : leakcanary/EventListener {
+	public static final field INSTANCE Lleakcanary/TvEventListener;
+	public fun onEvent (Lleakcanary/EventListener$Event;)V
+}
+
+public final class leakcanary/WorkManagerHeapAnalyzer : leakcanary/EventListener {
+	public static final field INSTANCE Lleakcanary/WorkManagerHeapAnalyzer;
+	public fun onEvent (Lleakcanary/EventListener$Event;)V
+}
+
diff --git a/leakcanary-android-core/build.gradle b/leakcanary-android-core/build.gradle
new file mode 100644
index 00000000..b13a607a
--- /dev/null
+++ b/leakcanary-android-core/build.gradle
@@ -0,0 +1,57 @@
+plugins {
+  id("com.android.library")
+  id("org.jetbrains.kotlin.android")
+  id("com.vanniktech.maven.publish")
+}
+
+dependencies {
+  api projects.sharkAndroid
+  api projects.leakcanaryObjectWatcherAndroidCore
+  api projects.leakcanaryObjectWatcherAndroidAndroidx
+  api projects.leakcanaryObjectWatcherAndroidSupportFragments
+  implementation libs.kotlin.stdlib
+
+  // Optional dependency
+  compileOnly libs.androidX.work.runtime
+  compileOnly libs.androidX.work.multiprocess
+
+  testImplementation libs.assertjCore
+  testImplementation libs.junit
+  testImplementation libs.kotlin.reflect
+  testImplementation libs.mockito
+  testImplementation libs.mockitoKotlin
+  androidTestImplementation libs.androidX.test.espresso
+  androidTestImplementation libs.androidX.test.rules
+  androidTestImplementation libs.androidX.test.runner
+  androidTestImplementation libs.assertjCore
+  androidTestImplementation projects.sharkHprofTest
+  androidTestUtil libs.androidX.test.orchestrator
+}
+
+def gitSha() {
+  return 'git rev-parse --short HEAD'.execute().text.trim()
+}
+
+android {
+  resourcePrefix 'leak_canary_'
+  compileSdk versions.compileSdk
+  defaultConfig {
+    minSdk versions.minSdk
+    // Avoid DeprecatedTargetSdkVersionDialog during UI tests
+    targetSdk versions.compileSdk
+    buildConfigField "String", "LIBRARY_VERSION", "\"${rootProject.ext.VERSION_NAME}\""
+    buildConfigField "String", "GIT_SHA", "\"${gitSha()}\""
+    consumerProguardFiles 'consumer-proguard-rules.pro'
+    testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+
+    testInstrumentationRunnerArguments clearPackageData: 'true'
+    testOptions {
+      execution 'ANDROIDX_TEST_ORCHESTRATOR'
+    }
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
+    checkOnly 'Interoperability'
+  }
+}
diff --git a/leakcanary-android-core/consumer-proguard-rules.pro b/leakcanary-android-core/consumer-proguard-rules.pro
new file mode 100644
index 00000000..ff9fbc46
--- /dev/null
+++ b/leakcanary-android-core/consumer-proguard-rules.pro
@@ -0,0 +1,4 @@
+# Loaded via reflection & referenced by shark.AndroidReferenceMatchers.LEAK_CANARY_INTERNAL and shark.AndroidReferenceMatchers.LEAK_CANARY_HEAP_DUMPER
+-keep class leakcanary.internal.InternalLeakCanary { *; }
+# Marshmallow removed Notification.setLatestEventInfo()
+-dontwarn android.app.Notification
diff --git a/leakcanary-android-core/gradle.properties b/leakcanary-android-core/gradle.properties
new file mode 100644
index 00000000..f11d5355
--- /dev/null
+++ b/leakcanary-android-core/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-android-core
+POM_NAME=LeakCanary for Android - Core
+POM_PACKAGING=aar
diff --git a/leakcanary-android-core/lint.xml b/leakcanary-android-core/lint.xml
new file mode 100644
index 00000000..73841df8
--- /dev/null
+++ b/leakcanary-android-core/lint.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+  <issue id="SetTextI18n" severity="ignore" />
+</lint>
diff --git a/leakcanary-android-core/src/androidTest/AndroidManifest.xml b/leakcanary-android-core/src/androidTest/AndroidManifest.xml
new file mode 100644
index 00000000..ce6a3055
--- /dev/null
+++ b/leakcanary-android-core/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2019 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest package="com.squareup.leakcanary.core.test" />
diff --git a/leakcanary-android-core/src/androidTest/assets/leaks-v24.db b/leakcanary-android-core/src/androidTest/assets/leaks-v24.db
new file mode 100644
index 00000000..c4c20ce6
Binary files /dev/null and b/leakcanary-android-core/src/androidTest/assets/leaks-v24.db differ
diff --git a/leakcanary-android-core/src/androidTest/java/leakcanary/AndroidExtensionsTest.kt b/leakcanary-android-core/src/androidTest/java/leakcanary/AndroidExtensionsTest.kt
new file mode 100644
index 00000000..3a600dd1
--- /dev/null
+++ b/leakcanary-android-core/src/androidTest/java/leakcanary/AndroidExtensionsTest.kt
@@ -0,0 +1,36 @@
+package leakcanary
+
+import android.os.Build.VERSION.SDK_INT
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Assume.assumeTrue
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.hexIdentityHashCode
+
+class AndroidExtensionsTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+
+  @Test fun identityHashCode() {
+    assumeTrue("SDK_INT is $SDK_INT, shadow\$_monitor_ was introduced in 21", SDK_INT >= 24)
+
+    // leakcanary.AndroidExtensionsTest@c559955
+    val thisToString = toString()
+
+    val heapDumpFile = testFolder.newFile()
+    AndroidDebugHeapDumper.dumpHeap(heapDumpFile)
+
+    val testClassName = this::class.java.name
+
+    val identityHashCodeFromDump = heapDumpFile.openHeapGraph().use { graph ->
+      val testClass = graph.findClassByName(testClassName)!!
+      val testInstance = testClass.instances.single()
+      testInstance.hexIdentityHashCode
+    }
+
+    assertThat("$testClassName@$identityHashCodeFromDump").isEqualTo(thisToString)
+  }
+}
diff --git a/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseMigrationTest.kt b/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseMigrationTest.kt
new file mode 100644
index 00000000..cfe2c82b
--- /dev/null
+++ b/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseMigrationTest.kt
@@ -0,0 +1,123 @@
+package leakcanary
+
+import android.database.sqlite.SQLiteDatabase
+import androidx.test.platform.app.InstrumentationRegistry
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.LeakTable
+import leakcanary.internal.activity.db.LeaksDbHelper
+import leakcanary.internal.activity.db.ScopedLeaksDb
+import org.junit.Test
+import shark.HeapAnalysis
+import shark.HeapAnalysisSuccess
+import shark.LeakTrace.GcRootType.JAVA_FRAME
+import shark.LeakTrace.GcRootType.STICKY_CLASS
+
+class DatabaseMigrationTest {
+
+  @Test fun v24_upgraded_to_latest() {
+    DB_V24 upgrade {
+      version assertEquals LeaksDbHelper.VERSION
+    }
+  }
+
+  @Test fun v24_has_1_heap_dumps() {
+    DB_V24 upgrade {
+      HeapAnalysisTable.retrieveAll(this).size assertEquals 1
+    }
+  }
+
+  @Test fun v24_heap_dumps_can_be_deserialized() {
+    DB_V24 upgrade {
+      HeapAnalysisTable.retrieveAll(this)
+        .forEach { projection ->
+          val heapAnalysis = HeapAnalysisTable.retrieve<HeapAnalysis>(this, projection.id)!!
+          heapAnalysis assertIs HeapAnalysisSuccess::class.java
+        }
+    }
+  }
+
+  @Test fun v24_has_8_leak_traces() {
+    DB_V24 upgrade {
+      val allLeakTraces = HeapAnalysisTable.retrieveAll(this)
+        .map { HeapAnalysisTable.retrieve<HeapAnalysisSuccess>(this, it.id)!! }
+        .flatMap { analysis ->
+          analysis.allLeaks.toList()
+        }
+        .flatMap { leak ->
+          leak.leakTraces
+        }
+
+      allLeakTraces.size assertEquals 8
+    }
+  }
+
+  @Test fun v24_has_3_leak_types() {
+    DB_V24 upgrade {
+      LeakTable.retrieveAllLeaks(this).size assertEquals 3
+    }
+  }
+
+  @Test fun v24_leaks_are_new() {
+    DB_V24 upgrade {
+      LeakTable.retrieveAllLeaks(this)
+        .forEach { leak ->
+          leak.isNew assertEquals true
+        }
+    }
+  }
+
+  @Test fun v24_has_5_sticky_class_and_3_java_frame_gc_roots() {
+    DB_V24 upgrade {
+      val allLeakTraces = HeapAnalysisTable.retrieveAll(this)
+        .map { HeapAnalysisTable.retrieve<HeapAnalysisSuccess>(this, it.id)!! }
+        .flatMap { analysis ->
+          analysis.allLeaks.toList()
+        }
+        .flatMap { leak ->
+          leak.leakTraces
+        }
+      val gcRootCounts = allLeakTraces.groupingBy { it.gcRootType }
+        .eachCount()
+
+      gcRootCounts.getValue(STICKY_CLASS) assertEquals 2
+      gcRootCounts.getValue(JAVA_FRAME) assertEquals 3
+    }
+  }
+
+  private infix fun String.upgrade(
+    block: SQLiteDatabase.() -> Unit
+  ) {
+    val instrumentation = InstrumentationRegistry.getInstrumentation()
+    val context = instrumentation.targetContext
+
+    context.assets.open(this)
+      .use { input ->
+        val databaseFile = context.getDatabasePath(LeaksDbHelper.DATABASE_NAME)
+        databaseFile.parentFile!!.mkdirs()
+        databaseFile.outputStream().use { output ->
+          input.copyTo(output)
+        }
+      }
+    ScopedLeaksDb.readableDatabase(context) { db ->
+      db.block()
+    }
+  }
+
+  private infix fun Any.assertEquals(otherValue: Any) {
+    if (this != otherValue) {
+      throw AssertionError("Expecting <$this> to be equal to <$otherValue> but was not.")
+    }
+  }
+
+  private infix fun Any.assertIs(javaClass: Class<out Any>) {
+    if (!javaClass.isInstance(this)) {
+      throw AssertionError(
+        "Expecting <$this> to be an instance of <${javaClass.name}> but was <${this.javaClass.name}>."
+      )
+    }
+  }
+
+  companion object {
+    const val DB_V24 = "leaks-v24.db"
+  }
+}
diff --git a/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseRule.kt b/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseRule.kt
new file mode 100644
index 00000000..5049cafd
--- /dev/null
+++ b/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseRule.kt
@@ -0,0 +1,27 @@
+package leakcanary
+
+import android.database.sqlite.SQLiteDatabase
+import androidx.test.platform.app.InstrumentationRegistry
+import leakcanary.internal.activity.db.LeaksDbHelper
+import leakcanary.internal.activity.db.ScopedLeaksDb
+import org.junit.rules.TestRule
+import org.junit.runner.Description
+import org.junit.runners.model.Statement
+
+class DatabaseRule(private val updateDb: (SQLiteDatabase) -> Unit = {}) : TestRule {
+  override fun apply(
+    base: Statement,
+    description: Description
+  ): Statement {
+    return object : Statement() {
+      override fun evaluate() {
+        val instrumentation = InstrumentationRegistry.getInstrumentation()
+        val context = instrumentation.targetContext
+        context.deleteDatabase(LeaksDbHelper.DATABASE_NAME)
+        ScopedLeaksDb.writableDatabase(context, updateDb)
+        base.evaluate()
+        context.deleteDatabase(LeaksDbHelper.DATABASE_NAME)
+      }
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/androidTest/java/leakcanary/LeakActivityTest.kt b/leakcanary-android-core/src/androidTest/java/leakcanary/LeakActivityTest.kt
new file mode 100644
index 00000000..d2791980
--- /dev/null
+++ b/leakcanary-android-core/src/androidTest/java/leakcanary/LeakActivityTest.kt
@@ -0,0 +1,151 @@
+package leakcanary
+
+import androidx.test.espresso.Espresso.onData
+import androidx.test.espresso.Espresso.onView
+import androidx.test.espresso.action.ViewActions.click
+import androidx.test.espresso.assertion.ViewAssertions.matches
+import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
+import androidx.test.espresso.matcher.ViewMatchers.withId
+import androidx.test.espresso.matcher.ViewMatchers.withText
+import androidx.test.platform.app.InstrumentationRegistry
+import androidx.test.rule.ActivityTestRule
+import com.squareup.leakcanary.core.R
+import java.io.File
+import leakcanary.internal.activity.LeakActivity
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.LeakTable.AllLeaksProjection
+import leakcanary.internal.activity.db.ScopedLeaksDb
+import org.hamcrest.Description
+import org.hamcrest.Matcher
+import org.hamcrest.TypeSafeMatcher
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.RuleChain
+import org.junit.rules.TemporaryFolder
+import shark.GcRoot.JniGlobal
+import shark.HeapAnalyzer
+import shark.HprofWriterHelper
+import shark.LeakTraceObject
+import shark.OnAnalysisProgressListener
+import shark.ValueHolder.IntHolder
+import shark.dump
+
+internal class LeakActivityTest {
+
+  private val activityTestRule = ActivityTestRule(LeakActivity::class.java, false, false)
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+
+  @get:Rule
+  var rules: RuleChain = RuleChain.outerRule(DatabaseRule())
+    .around(activityTestRule)
+
+  @Test
+  fun noLeakOnHome() {
+    activityTestRule.launchActivity(null)
+    onView(withText("0 Distinct Leaks")).check(matches(isDisplayed()))
+  }
+
+  @Test
+  fun oneLeakOnHome() {
+    insertHeapDump {
+      "Holder" clazz {
+        staticField["leak"] = "com.example.Leaking" watchedInstance {}
+      }
+    }
+    activityTestRule.launchActivity(null)
+    onView(withText("1 Distinct Leak")).check(matches(isDisplayed()))
+  }
+
+  @Test
+  fun seeLeakOnLeakScreen() {
+    insertHeapDump {
+      "Holder" clazz {
+        staticField["leak"] = "com.example.Leaking" watchedInstance {}
+      }
+    }
+    activityTestRule.launchActivity(null)
+
+    onData(withItem<AllLeaksProjection> { it.shortDescription == "Holder.leak" })
+      .perform(click())
+    onData(withItem<LeakTraceObject> { it.className == "com.example.Leaking" })
+      .inAdapterView(withId(R.id.leak_canary_list))
+      .check(matches(isDisplayed()))
+  }
+
+  @Test
+  fun leakWithEmptyReferencePath() {
+    insertHeapDump {
+      val leakingInstance = "com.example.Leaking" watchedInstance {}
+      gcRoot(JniGlobal(id = leakingInstance.value, jniGlobalRefId = 42))
+    }
+    activityTestRule.launchActivity(null)
+
+    onData(withItem<AllLeaksProjection> { it.shortDescription == "com.example.Leaking" })
+      .perform(click())
+    onData(withItem<LeakTraceObject> { it.className == "com.example.Leaking" })
+      .inAdapterView(withId(R.id.leak_canary_list))
+      .check(matches(isDisplayed()))
+  }
+
+  private fun writeHeapDump(block: HprofWriterHelper.() -> Unit): File {
+    val hprofFile = testFolder.newFile("temp.hprof")
+    hprofFile.dump {
+      "android.os.Build" clazz {
+        staticField["MANUFACTURER"] = string("Samsing")
+        staticField["ID"] = string("M4-rc20")
+      }
+      "android.os.Build\$VERSION" clazz {
+        staticField["SDK_INT"] = IntHolder(47)
+      }
+      block()
+    }
+    return hprofFile
+  }
+
+  private fun insertHeapDump(block: HprofWriterHelper.() -> Unit) {
+    val hprofFile = writeHeapDump(block)
+    val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+    val result = heapAnalyzer.analyze(
+      heapDumpFile = hprofFile,
+      leakingObjectFinder = LeakCanary.config.leakingObjectFinder,
+      referenceMatchers = LeakCanary.config.referenceMatchers,
+      computeRetainedHeapSize = LeakCanary.config.computeRetainedHeapSize,
+      objectInspectors = LeakCanary.config.objectInspectors,
+      metadataExtractor = LeakCanary.config.metadataExtractor,
+      proguardMapping = null
+    )
+    val instrumentation = InstrumentationRegistry.getInstrumentation()
+    val context = instrumentation.targetContext
+    ScopedLeaksDb.writableDatabase(context) { db ->
+      HeapAnalysisTable.insert(db, result)
+    }
+  }
+
+  inline fun <reified T : Any> withItem(
+    filterDescription: String? = null,
+    crossinline filter: (T) -> Boolean
+  ): Matcher<T> {
+    return object : TypeSafeMatcher<T>(T::class.java) {
+      override fun describeTo(description: Description) {
+        if (filterDescription != null) {
+          description.appendText("is $filterDescription")
+        }
+      }
+
+      override fun matchesSafely(item: T): Boolean {
+        return filter(item)
+      }
+    }
+  }
+}
+
+fun tryAndRestoreConfig(block: () -> Unit) {
+  val original = LeakCanary.config
+  try {
+    block()
+  } finally {
+    LeakCanary.config = original
+  }
+}
diff --git a/leakcanary-android-core/src/androidTest/java/leakcanary/ManualInstallTest.kt b/leakcanary-android-core/src/androidTest/java/leakcanary/ManualInstallTest.kt
new file mode 100644
index 00000000..10f92b9d
--- /dev/null
+++ b/leakcanary-android-core/src/androidTest/java/leakcanary/ManualInstallTest.kt
@@ -0,0 +1,88 @@
+package leakcanary
+
+import android.app.Application
+import android.os.StrictMode
+import android.os.StrictMode.ThreadPolicy
+import androidx.test.platform.app.InstrumentationRegistry
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+
+class ManualInstallTest {
+
+  private val application: Application
+    get() = InstrumentationRegistry.getInstrumentation().targetContext.applicationContext as Application
+
+  @Test fun appWatcher_is_not_installed() {
+    assertThat(AppWatcher.isInstalled).isFalse()
+  }
+
+  @Test fun can_update_LeakCanary_config_without_installing() = tryAndRestoreConfig {
+    LeakCanary.config = LeakCanary.config.copy(dumpHeap = LeakCanary.config.dumpHeap)
+  }
+
+  @Test fun no_thread_policy_violations_on_install() {
+    runOnMainSyncRethrowing {
+      throwOnAnyThreadPolicyViolation {
+        AppWatcher.manualInstall(application)
+      }
+    }
+  }
+
+  @Test fun no_thread_policy_violations_on_config_update() {
+    runOnMainSyncRethrowing {
+      throwOnAnyThreadPolicyViolation {
+        LeakCanary.config = LeakCanary.config.copy(dumpHeap = LeakCanary.config.dumpHeap)
+      }
+    }
+  }
+
+  @Test fun no_thread_policy_violations_on_install_then_config_update() {
+    runOnMainSyncRethrowing {
+      throwOnAnyThreadPolicyViolation {
+        AppWatcher.manualInstall(application)
+        LeakCanary.config = LeakCanary.config.copy(dumpHeap = LeakCanary.config.dumpHeap)
+      }
+    }
+  }
+
+  @Test fun no_thread_policy_violations_on_config_update_then_install() {
+    runOnMainSyncRethrowing {
+      throwOnAnyThreadPolicyViolation {
+        LeakCanary.config = LeakCanary.config.copy(dumpHeap = LeakCanary.config.dumpHeap)
+        AppWatcher.manualInstall(application)
+      }
+    }
+  }
+
+  private fun throwOnAnyThreadPolicyViolation(block: () -> Unit) {
+    val previousThreadPolicy = StrictMode.getThreadPolicy()
+    try {
+      StrictMode.setThreadPolicy(
+        ThreadPolicy.Builder()
+          .detectAll()
+          .penaltyDeath()
+          .build()
+      )
+      block()
+    } finally {
+      StrictMode.setThreadPolicy(previousThreadPolicy)
+    }
+  }
+
+  private fun runOnMainSyncRethrowing(block: () -> Unit) {
+    var mainThreadThrowable: Throwable? = null
+    val instrumentation = InstrumentationRegistry.getInstrumentation()
+    instrumentation.runOnMainSync {
+      try {
+        block()
+      } catch (throwable: Throwable) {
+        mainThreadThrowable = throwable
+      }
+    }
+    mainThreadThrowable?.let { cause ->
+      throw cause
+    }
+  }
+}
+
+
diff --git a/leakcanary-android-core/src/main/AndroidManifest.xml b/leakcanary-android-core/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..5e0b6d04
--- /dev/null
+++ b/leakcanary-android-core/src/main/AndroidManifest.xml
@@ -0,0 +1,107 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary.core"
+    >
+
+  <!-- To store the heap dumps and leak analysis results. -->
+  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+
+  <!-- To allow posting notifications on Android 13 -->
+  <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
+
+  <application>
+    <provider
+        android:name="leakcanary.internal.LeakCanaryFileProvider"
+        android:authorities="com.squareup.leakcanary.fileprovider.${applicationId}"
+        android:exported="false"
+        android:grantUriPermissions="true"
+        >
+      <meta-data
+          android:name="android.support.FILE_PROVIDER_PATHS"
+          android:resource="@xml/leak_canary_file_paths"/>
+    </provider>
+
+    <activity
+        android:name="leakcanary.internal.activity.LeakActivity"
+        android:icon="@mipmap/leak_canary_icon"
+        android:exported="true"
+        android:label="@string/leak_canary_display_activity_label"
+        android:taskAffinity="com.squareup.leakcanary.${applicationId}"
+        android:theme="@style/leak_canary_LeakCanary.Base"
+        >
+      <intent-filter android:label="@string/leak_canary_import_hprof_file">
+        <action android:name="android.intent.action.VIEW"/>
+
+        <category android:name="android.intent.category.DEFAULT"/>
+        <category android:name="android.intent.category.BROWSABLE"/>
+
+        <data android:scheme="file"/>
+        <data android:scheme="content"/>
+        <data android:mimeType="*/*"/>
+        <data android:host="*"/>
+
+        <data android:pathPattern=".*\\.hprof"/>
+        <data android:pathPattern=".*\\..*\\.hprof"/>
+        <data android:pathPattern=".*\\..*\\..*\\.hprof"/>
+        <data android:pathPattern=".*\\..*\\..*\\..*\\.hprof"/>
+        <data android:pathPattern=".*\\..*\\..*\\..*\\..*\\.hprof"/>
+        <data android:pathPattern=".*\\..*\\..*\\..*\\..*\\..*\\.hprof"/>
+        <data android:pathPattern=".*\\..*\\..*\\..*\\..*\\..*\\..*\\.hprof"/>
+        <!--
+            Since hprof isn't a standard MIME type, we have to declare such patterns.
+            Most file providers will generate URIs including their own package name,
+            which contains `.` characters that must be explicitly escaped in pathPattern.
+            @see https://stackoverflow.com/a/31028507/703646
+        -->
+      </intent-filter>
+    </activity>
+
+    <activity-alias
+        android:name="leakcanary.internal.activity.LeakLauncherActivity"
+        android:enabled="@bool/leak_canary_add_launcher_icon"
+        android:icon="@mipmap/leak_canary_icon"
+        android:banner="@drawable/leak_canary_tv_icon"
+        android:label="@string/leak_canary_display_activity_label"
+        android:targetActivity="leakcanary.internal.activity.LeakActivity"
+        android:taskAffinity="com.squareup.leakcanary.${applicationId}"
+        android:theme="@style/leak_canary_LeakCanary.Base"
+        android:exported="true"
+        >
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+        <!-- Android TV launcher intent -->
+        <category android:name="android.intent.category.LEANBACK_LAUNCHER"/>
+      </intent-filter>
+    </activity-alias>
+
+    <activity
+        android:name="leakcanary.internal.RequestPermissionActivity"
+        android:excludeFromRecents="true"
+        android:icon="@mipmap/leak_canary_icon"
+        android:label="@string/leak_canary_storage_permission_activity_label"
+        android:taskAffinity="com.squareup.leakcanary.${applicationId}"
+        android:theme="@style/leak_canary_Theme.Transparent"
+        />
+
+    <receiver android:name="leakcanary.internal.NotificationReceiver" />
+
+  </application>
+</manifest>
diff --git a/leakcanary-android-core/src/main/ic_launcher-web.png b/leakcanary-android-core/src/main/ic_launcher-web.png
new file mode 100644
index 00000000..15b9d890
Binary files /dev/null and b/leakcanary-android-core/src/main/ic_launcher-web.png differ
diff --git a/leakcanary-android-core/src/main/java/leakcanary/AndroidDebugHeapDumper.kt b/leakcanary-android-core/src/main/java/leakcanary/AndroidDebugHeapDumper.kt
new file mode 100644
index 00000000..2325116c
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/AndroidDebugHeapDumper.kt
@@ -0,0 +1,16 @@
+package leakcanary
+
+import android.os.Debug
+import java.io.File
+
+/**
+ * Dumps the Android heap using [Debug.dumpHprofData].
+ *
+ * Note: despite being part of the Debug class, [Debug.dumpHprofData] can be called from non
+ * debuggable non profileable builds.
+ */
+object AndroidDebugHeapDumper : HeapDumper {
+  override fun dumpHeap(heapDumpFile: File) {
+    Debug.dumpHprofData(heapDumpFile.absolutePath)
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/BackgroundThreadHeapAnalyzer.kt b/leakcanary-android-core/src/main/java/leakcanary/BackgroundThreadHeapAnalyzer.kt
new file mode 100644
index 00000000..629b3673
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/BackgroundThreadHeapAnalyzer.kt
@@ -0,0 +1,31 @@
+package leakcanary
+
+import android.os.Handler
+import android.os.HandlerThread
+import leakcanary.EventListener.Event
+import leakcanary.EventListener.Event.HeapDump
+import leakcanary.internal.AndroidDebugHeapAnalyzer
+import leakcanary.internal.InternalLeakCanary
+
+/**
+ * Starts heap analysis on a background [HandlerThread] when receiving a [HeapDump] event.
+ */
+object BackgroundThreadHeapAnalyzer : EventListener {
+
+  internal val heapAnalyzerThreadHandler by lazy {
+    val handlerThread = HandlerThread("HeapAnalyzer")
+    handlerThread.start()
+    Handler(handlerThread.looper)
+  }
+
+  override fun onEvent(event: Event) {
+    if (event is HeapDump) {
+      heapAnalyzerThreadHandler.post {
+        val doneEvent = AndroidDebugHeapAnalyzer.runAnalysisBlocking(event) { event ->
+          InternalLeakCanary.sendEvent(event)
+        }
+        InternalLeakCanary.sendEvent(doneEvent)
+      }
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
new file mode 100644
index 00000000..57b32c50
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
@@ -0,0 +1,26 @@
+package leakcanary
+
+import android.app.Application
+import shark.HeapAnalysis
+
+/**
+ * Deprecated, this is now a no-op. Add to LeakCanary.config.eventListeners instead.
+ *
+ * Default [OnHeapAnalyzedListener] implementation, which will store the analysis to disk and
+ * show a notification summarizing the result.
+ */
+@Deprecated(message = "Add to LeakCanary.config.eventListeners instead")
+class DefaultOnHeapAnalyzedListener private constructor() :
+  OnHeapAnalyzedListener {
+
+  // Kept this constructor for backward compatibility of public API.
+  @Deprecated(message = "Add to LeakCanary.config.eventListeners instead")
+  constructor(application: Application) : this()
+
+  override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {
+  }
+
+  companion object {
+    fun create(): OnHeapAnalyzedListener = DefaultOnHeapAnalyzedListener()
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/EventListener.kt b/leakcanary-android-core/src/main/java/leakcanary/EventListener.kt
new file mode 100644
index 00000000..d814a1ed
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/EventListener.kt
@@ -0,0 +1,97 @@
+package leakcanary
+
+import android.content.Intent
+import java.io.File
+import java.io.Serializable
+import leakcanary.internal.SerializableIntent
+import shark.HeapAnalysis
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.OnAnalysisProgressListener.Step
+
+fun interface EventListener {
+
+  /**
+   * Note: [Event] is [Serializable] for convenience but we currently make no guarantee
+   * that the Serialization is backward / forward compatible across LeakCanary versions, so plan
+   * accordingly. This is convenient for passing events around processes, and shouldn't be used
+   * to store them.
+   */
+  sealed class Event(
+    /**
+     * Unique identifier for a related chain of event. The identifier for the events that run
+     * before [HeapDump] gets reset right before [HeapDump] is sent.
+     */
+    val uniqueId: String
+  ) : Serializable {
+    /**
+     * Sent from the "LeakCanary-Heap-Dump" HandlerThread.
+     */
+    class DumpingHeap(uniqueId: String) : Event(uniqueId)
+
+    /**
+     * Sent from the "LeakCanary-Heap-Dump" HandlerThread.
+     */
+    class HeapDump(
+      uniqueId: String,
+      val file: File,
+      val durationMillis: Long,
+      val reason: String
+    ) : Event(uniqueId)
+
+    /**
+     * Sent from the "LeakCanary-Heap-Dump" HandlerThread.
+     */
+    class HeapDumpFailed(
+      uniqueId: String,
+      val exception: Throwable,
+      val willRetryLater: Boolean
+    ) : Event(uniqueId)
+
+    /**
+     * [progressPercent] is a value between [0..1]
+     *
+     * Sent from the thread performing the analysis.
+     */
+    class HeapAnalysisProgress(
+      uniqueId: String,
+      val step: Step,
+      val progressPercent: Double
+    ) : Event(uniqueId)
+
+    /**
+     * Sent from the thread performing the analysis.
+     */
+    sealed class HeapAnalysisDone<T : HeapAnalysis>(
+      uniqueId: String,
+      val heapAnalysis: T,
+      showIntent: Intent
+    ) : Event(uniqueId) {
+
+      private val serializableShowIntent = SerializableIntent(showIntent)
+
+      val showIntent: Intent
+        get() = serializableShowIntent.intent
+
+      class HeapAnalysisSucceeded(
+        uniqueId: String,
+        heapAnalysis: HeapAnalysisSuccess,
+        val unreadLeakSignatures: Set<String>,
+        showIntent: Intent
+      ) : HeapAnalysisDone<HeapAnalysisSuccess>(uniqueId, heapAnalysis, showIntent)
+
+      class HeapAnalysisFailed(
+        uniqueId: String,
+        heapAnalysis: HeapAnalysisFailure,
+        showIntent: Intent
+      ) : HeapAnalysisDone<HeapAnalysisFailure>(uniqueId, heapAnalysis, showIntent)
+    }
+  }
+
+  /**
+   * [onEvent] is always called from the thread the events are emitted from, which is documented
+   * for each event. This enables you to potentially block a chain of events, waiting for some
+   * pre work to be done.
+   */
+  fun onEvent(event: Event)
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/HeapDumper.kt b/leakcanary-android-core/src/main/java/leakcanary/HeapDumper.kt
new file mode 100644
index 00000000..0e25899e
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/HeapDumper.kt
@@ -0,0 +1,14 @@
+package leakcanary
+
+import java.io.File
+
+fun interface HeapDumper {
+
+  /**
+   * Dumps the heap. The implementation is expected to be blocking until the heap is dumped
+   * or heap dumping failed.
+   *
+   * Implementations can throw a runtime exception if heap dumping failed.
+   */
+  fun dumpHeap(heapDumpFile: File)
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LazyForwardingEventListener.kt b/leakcanary-android-core/src/main/java/leakcanary/LazyForwardingEventListener.kt
new file mode 100644
index 00000000..95426a42
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/LazyForwardingEventListener.kt
@@ -0,0 +1,18 @@
+package leakcanary
+
+import leakcanary.EventListener.Event
+
+/**
+ * Forwards events to the [EventListener] provided by lazyEventListener which
+ * is evaluated lazily, when the first comes in.
+ */
+class LazyForwardingEventListener(
+  lazyEventListener: () -> EventListener
+) : EventListener {
+
+  private val eventListenerDelegate by lazy(lazyEventListener)
+
+  override fun onEvent(event: Event) {
+    eventListenerDelegate.onEvent(event)
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
new file mode 100644
index 00000000..96a27ef6
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -0,0 +1,428 @@
+package leakcanary
+
+import android.content.Intent
+import leakcanary.LeakCanary.config
+import leakcanary.internal.HeapDumpControl
+import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.InternalLeakCanary.FormFactor.TV
+import leakcanary.internal.activity.LeakActivity
+import shark.AndroidMetadataExtractor
+import shark.AndroidObjectInspectors
+import shark.AndroidReferenceMatchers
+import shark.FilteringLeakingObjectFinder
+import shark.HeapAnalysisSuccess
+import shark.IgnoredReferenceMatcher
+import shark.KeyedWeakReferenceFinder
+import shark.LeakingObjectFinder
+import shark.LibraryLeakReferenceMatcher
+import shark.MetadataExtractor
+import shark.ObjectInspector
+import shark.ReferenceMatcher
+import shark.SharkLog
+
+/**
+ * The entry point API for LeakCanary. LeakCanary builds on top of [AppWatcher]. AppWatcher
+ * notifies LeakCanary of retained instances, which in turns dumps the heap, analyses it and
+ * publishes the results.
+ *
+ * LeakCanary can be configured by updating [config].
+ */
+object LeakCanary {
+
+  /**
+   * LeakCanary configuration data class. Properties can be updated via [copy].
+   *
+   * @see [config]
+   */
+  data class Config(
+    /**
+     * Whether LeakCanary should dump the heap when enough retained instances are found. This needs
+     * to be true for LeakCanary to work, but sometimes you may want to temporarily disable
+     * LeakCanary (e.g. for a product demo).
+     *
+     * Defaults to true.
+     */
+    val dumpHeap: Boolean = true,
+    /**
+     * If [dumpHeapWhenDebugging] is false then LeakCanary will not dump the heap
+     * when the debugger is attached. The debugger can create temporary memory leaks (for instance
+     * if a thread is blocked on a breakpoint).
+     *
+     * Defaults to false.
+     */
+    val dumpHeapWhenDebugging: Boolean = false,
+    /**
+     * When the app is visible, LeakCanary will wait for at least
+     * [retainedVisibleThreshold] retained instances before dumping the heap. Dumping the heap
+     * freezes the UI and can be frustrating for developers who are trying to work. This is
+     * especially frustrating as the Android Framework has a number of leaks that cannot easily
+     * be fixed.
+     *
+     * When the app becomes invisible, LeakCanary dumps the heap after
+     * [AppWatcher.retainedDelayMillis] ms.
+     *
+     * The app is considered visible if it has at least one activity in started state.
+     *
+     * A higher threshold means LeakCanary will dump the heap less often, therefore it won't be
+     * bothering developers as much but it could miss some leaks.
+     *
+     * Defaults to 5.
+     */
+    val retainedVisibleThreshold: Int = 5,
+
+    /**
+     * Known patterns of references in the heap, added here either to ignore them
+     * ([IgnoredReferenceMatcher]) or to mark them as library leaks ([LibraryLeakReferenceMatcher]).
+     *
+     * When adding your own custom [LibraryLeakReferenceMatcher] instances, you'll most
+     * likely want to set [LibraryLeakReferenceMatcher.patternApplies] with a filter that checks
+     * for the Android OS version and manufacturer. The build information can be obtained by calling
+     * [shark.AndroidBuildMirror.fromHeapGraph].
+     *
+     * Defaults to [AndroidReferenceMatchers.appDefaults]
+     */
+    val referenceMatchers: List<ReferenceMatcher> = AndroidReferenceMatchers.appDefaults,
+
+    /**
+     * List of [ObjectInspector] that provide LeakCanary with insights about objects found in the
+     * heap. You can create your own [ObjectInspector] implementations, and also add
+     * a [shark.AppSingletonInspector] instance created with the list of internal singletons.
+     *
+     * Defaults to [AndroidObjectInspectors.appDefaults]
+     */
+    val objectInspectors: List<ObjectInspector> = AndroidObjectInspectors.appDefaults,
+
+    /**
+     * Deprecated, add to LeakCanary.config.eventListeners instead.
+     * Called on a background thread when the heap analysis is complete.
+     * If you want leaks to be added to the activity that lists leaks, make sure to delegate
+     * calls to a [DefaultOnHeapAnalyzedListener].
+     *
+     * Defaults to [DefaultOnHeapAnalyzedListener]
+     */
+    @Deprecated(message = "Add to LeakCanary.config.eventListeners instead")
+    val onHeapAnalyzedListener: OnHeapAnalyzedListener = DefaultOnHeapAnalyzedListener.create(),
+
+    /**
+     * Extracts metadata from a hprof to be reported in [HeapAnalysisSuccess.metadata].
+     * Called on a background thread during heap analysis.
+     *
+     * Defaults to [AndroidMetadataExtractor]
+     */
+    val metadataExtractor: MetadataExtractor = AndroidMetadataExtractor,
+
+    /**
+     * Whether to compute the retained heap size, which is the total number of bytes in memory that
+     * would be reclaimed if the detected leaks didn't happen. This includes native memory
+     * associated to Java objects (e.g. Android bitmaps).
+     *
+     * Computing the retained heap size can slow down the analysis because it requires navigating
+     * from GC roots through the entire object graph, whereas [shark.HeapAnalyzer] would otherwise
+     * stop as soon as all leaking instances are found.
+     *
+     * Defaults to true.
+     */
+    val computeRetainedHeapSize: Boolean = true,
+
+    /**
+     * How many heap dumps are kept on the Android device for this app package. When this threshold
+     * is reached LeakCanary deletes the older heap dumps. As several heap dumps may be enqueued
+     * you should avoid going down to 1 or 2.
+     *
+     * Defaults to 7.
+     */
+    val maxStoredHeapDumps: Int = 7,
+
+    /**
+     * LeakCanary always attempts to store heap dumps on the external storage if the
+     * WRITE_EXTERNAL_STORAGE is already granted, and otherwise uses the app storage.
+     * If the WRITE_EXTERNAL_STORAGE permission is not granted and
+     * [requestWriteExternalStoragePermission] is true, then LeakCanary will display a notification
+     * to ask for that permission.
+     *
+     * Defaults to false because that permission notification can be annoying.
+     */
+    val requestWriteExternalStoragePermission: Boolean = false,
+
+    /**
+     * Finds the objects that are leaking, for which LeakCanary will compute leak traces.
+     *
+     * Defaults to [KeyedWeakReferenceFinder] which finds all objects tracked by a
+     * [KeyedWeakReference], ie all objects that were passed to
+     * [ObjectWatcher.expectWeaklyReachable].
+     *
+     * You could instead replace it with a [FilteringLeakingObjectFinder], which scans all objects
+     * in the heap dump and delegates the decision to a list of
+     * [FilteringLeakingObjectFinder.LeakingObjectFilter]. This can lead to finding more leaks
+     * than the default and shorter leak traces. This also means that every analysis during a
+     * given process life will bring up the same leaking objects over and over again, unlike
+     * when using [KeyedWeakReferenceFinder] (because [KeyedWeakReference] instances are cleared
+     * after each heap dump).
+     *
+     * The list of filters can be built from [AndroidObjectInspectors]:
+     *
+     * ```kotlin
+     * LeakCanary.config = LeakCanary.config.copy(
+     *     leakingObjectFinder = FilteringLeakingObjectFinder(
+     *         AndroidObjectInspectors.appLeakingObjectFilters
+     *     )
+     * )
+     * ```
+     */
+    val leakingObjectFinder: LeakingObjectFinder = KeyedWeakReferenceFinder,
+
+    /**
+     * Dumps the Java heap. You may replace this with your own implementation if you wish to
+     * change the core heap dumping implementation.
+     */
+    val heapDumper: HeapDumper = AndroidDebugHeapDumper,
+
+    /**
+     * Listeners for LeakCanary events. See [EventListener.Event] for the list of events and
+     * which thread they're sent from. You most likely want to keep this list and add to it, or
+     * remove a few entries but not all entries. Each listener is independent and provides
+     * additional behavior which you can disable by not excluding it:
+     *
+     * ```kotlin
+     * // No cute canary toast (very sad!)
+     * LeakCanary.config = LeakCanary.config.run {
+     *   copy(
+     *     eventListeners = eventListeners.filter {
+     *       it !is ToastEventListener
+     *     }
+     *   )
+     * }
+     * ```
+     */
+    val eventListeners: List<EventListener> = listOf(
+      LogcatEventListener,
+      ToastEventListener,
+      LazyForwardingEventListener {
+        if (InternalLeakCanary.formFactor == TV) TvEventListener else NotificationEventListener
+      },
+      when {
+          RemoteWorkManagerHeapAnalyzer.remoteLeakCanaryServiceInClasspath ->
+            RemoteWorkManagerHeapAnalyzer
+          WorkManagerHeapAnalyzer.validWorkManagerInClasspath -> WorkManagerHeapAnalyzer
+          else -> BackgroundThreadHeapAnalyzer
+      }
+    ),
+
+    /**
+     * Whether to show LeakCanary notifications. When [showNotifications] is true, LeakCanary
+     * will only display notifications if the app is in foreground and is not an instant, TV or
+     * Wear app.
+     *
+     * Defaults to true.
+     */
+    val showNotifications: Boolean = true,
+
+    /**
+     * Deprecated: This is a no-op, set a custom [leakingObjectFinder] instead.
+     */
+    @Deprecated("This is a no-op, set a custom leakingObjectFinder instead")
+    val useExperimentalLeakFinders: Boolean = false
+  ) {
+
+    /**
+     * Construct a new Config via [LeakCanary.Config.Builder].
+     * Note: this method is intended to be used from Java code only. For idiomatic Kotlin use
+     * `copy()` to modify [LeakCanary.config].
+     */
+    @Suppress("NEWER_VERSION_IN_SINCE_KOTLIN")
+    @SinceKotlin("999.9") // Hide from Kotlin code, this method is only for Java code
+    fun newBuilder() = Builder(this)
+
+    /**
+     * Builder for [LeakCanary.Config] intended to be used only from Java code.
+     *
+     * Usage:
+     * ```java
+     * LeakCanary.Config config = LeakCanary.getConfig().newBuilder()
+     *    .retainedVisibleThreshold(3)
+     *    .build();
+     * LeakCanary.setConfig(config);
+     * ```
+     *
+     * For idiomatic Kotlin use `copy()` method instead:
+     * ```kotlin
+     * LeakCanary.config = LeakCanary.config.copy(retainedVisibleThreshold = 3)
+     * ```
+     */
+    class Builder internal constructor(config: Config) {
+      private var dumpHeap = config.dumpHeap
+      private var dumpHeapWhenDebugging = config.dumpHeapWhenDebugging
+      private var retainedVisibleThreshold = config.retainedVisibleThreshold
+      private var referenceMatchers = config.referenceMatchers
+      private var objectInspectors = config.objectInspectors
+      private var onHeapAnalyzedListener = config.onHeapAnalyzedListener
+      private var metadataExtractor = config.metadataExtractor
+      private var computeRetainedHeapSize = config.computeRetainedHeapSize
+      private var maxStoredHeapDumps = config.maxStoredHeapDumps
+      private var requestWriteExternalStoragePermission =
+        config.requestWriteExternalStoragePermission
+      private var leakingObjectFinder = config.leakingObjectFinder
+      private var heapDumper = config.heapDumper
+      private var eventListeners = config.eventListeners
+      private var useExperimentalLeakFinders = config.useExperimentalLeakFinders
+      private var showNotifications = config.showNotifications
+
+      /** @see [LeakCanary.Config.dumpHeap] */
+      fun dumpHeap(dumpHeap: Boolean) =
+        apply { this.dumpHeap = dumpHeap }
+
+      /** @see [LeakCanary.Config.dumpHeapWhenDebugging] */
+      fun dumpHeapWhenDebugging(dumpHeapWhenDebugging: Boolean) =
+        apply { this.dumpHeapWhenDebugging = dumpHeapWhenDebugging }
+
+      /** @see [LeakCanary.Config.retainedVisibleThreshold] */
+      fun retainedVisibleThreshold(retainedVisibleThreshold: Int) =
+        apply { this.retainedVisibleThreshold = retainedVisibleThreshold }
+
+      /** @see [LeakCanary.Config.referenceMatchers] */
+      fun referenceMatchers(referenceMatchers: List<ReferenceMatcher>) =
+        apply { this.referenceMatchers = referenceMatchers }
+
+      /** @see [LeakCanary.Config.objectInspectors] */
+      fun objectInspectors(objectInspectors: List<ObjectInspector>) =
+        apply { this.objectInspectors = objectInspectors }
+
+      /** @see [LeakCanary.Config.onHeapAnalyzedListener] */
+      @Deprecated(message = "Add to LeakCanary.config.eventListeners instead")
+      fun onHeapAnalyzedListener(onHeapAnalyzedListener: OnHeapAnalyzedListener) =
+        apply { this.onHeapAnalyzedListener = onHeapAnalyzedListener }
+
+      /** @see [LeakCanary.Config.metadataExtractor] */
+      fun metadataExtractor(metadataExtractor: MetadataExtractor) =
+        apply { this.metadataExtractor = metadataExtractor }
+
+      /** @see [LeakCanary.Config.computeRetainedHeapSize] */
+      fun computeRetainedHeapSize(computeRetainedHeapSize: Boolean) =
+        apply { this.computeRetainedHeapSize = computeRetainedHeapSize }
+
+      /** @see [LeakCanary.Config.maxStoredHeapDumps] */
+      fun maxStoredHeapDumps(maxStoredHeapDumps: Int) =
+        apply { this.maxStoredHeapDumps = maxStoredHeapDumps }
+
+      /** @see [LeakCanary.Config.requestWriteExternalStoragePermission] */
+      fun requestWriteExternalStoragePermission(requestWriteExternalStoragePermission: Boolean) =
+        apply { this.requestWriteExternalStoragePermission = requestWriteExternalStoragePermission }
+
+      /** @see [LeakCanary.Config.leakingObjectFinder] */
+      fun leakingObjectFinder(leakingObjectFinder: LeakingObjectFinder) =
+        apply { this.leakingObjectFinder = leakingObjectFinder }
+
+      /** @see [LeakCanary.Config.heapDumper] */
+      fun heapDumper(heapDumper: HeapDumper) =
+        apply { this.heapDumper = heapDumper }
+
+      /** @see [LeakCanary.Config.eventListeners] */
+      fun eventListeners(eventListeners: List<EventListener>) =
+        apply { this.eventListeners = eventListeners }
+
+      /** @see [LeakCanary.Config.useExperimentalLeakFinders] */
+      @Deprecated("Set a custom leakingObjectFinder instead")
+      fun useExperimentalLeakFinders(useExperimentalLeakFinders: Boolean) =
+        apply { this.useExperimentalLeakFinders = useExperimentalLeakFinders }
+
+      /** @see [LeakCanary.Config.showNotifications] */
+      fun showNotifications(showNotifications: Boolean) =
+        apply { this.showNotifications = showNotifications }
+
+
+      fun build() = config.copy(
+        dumpHeap = dumpHeap,
+        dumpHeapWhenDebugging = dumpHeapWhenDebugging,
+        retainedVisibleThreshold = retainedVisibleThreshold,
+        referenceMatchers = referenceMatchers,
+        objectInspectors = objectInspectors,
+        onHeapAnalyzedListener = onHeapAnalyzedListener,
+        metadataExtractor = metadataExtractor,
+        computeRetainedHeapSize = computeRetainedHeapSize,
+        maxStoredHeapDumps = maxStoredHeapDumps,
+        requestWriteExternalStoragePermission = requestWriteExternalStoragePermission,
+        leakingObjectFinder = leakingObjectFinder,
+        heapDumper = heapDumper,
+        eventListeners = eventListeners,
+        useExperimentalLeakFinders = useExperimentalLeakFinders,
+        showNotifications = showNotifications,
+      )
+    }
+  }
+
+  /**
+   * The current LeakCanary configuration. Can be updated at any time, usually by replacing it with
+   * a mutated copy, e.g.:
+   *
+   * ```kotlin
+   * LeakCanary.config = LeakCanary.config.copy(retainedVisibleThreshold = 3)
+   * ```
+   *
+   * In Java, use [LeakCanary.Config.Builder] instead:
+   * ```java
+   * LeakCanary.Config config = LeakCanary.getConfig().newBuilder()
+   *    .retainedVisibleThreshold(3)
+   *    .build();
+   * LeakCanary.setConfig(config);
+   * ```
+   */
+  @JvmStatic @Volatile
+  var config: Config = Config()
+    set(newConfig) {
+      val previousConfig = field
+      field = newConfig
+      logConfigChange(previousConfig, newConfig)
+      HeapDumpControl.updateICanHasHeapInBackground()
+    }
+
+  private fun logConfigChange(
+    previousConfig: Config,
+    newConfig: Config
+  ) {
+    SharkLog.d {
+      val changedFields = mutableListOf<String>()
+      Config::class.java.declaredFields.forEach { field ->
+        field.isAccessible = true
+        val previousValue = field[previousConfig]
+        val newValue = field[newConfig]
+        if (previousValue != newValue) {
+          changedFields += "${field.name}=$newValue"
+        }
+      }
+      val changesInConfig =
+        if (changedFields.isNotEmpty()) changedFields.joinToString(", ") else "no changes"
+
+      "Updated LeakCanary.config: Config($changesInConfig)"
+    }
+  }
+
+  /**
+   * Returns a new [Intent] that can be used to programmatically launch the leak display activity.
+   */
+  fun newLeakDisplayActivityIntent() = LeakActivity.createHomeIntent(InternalLeakCanary.application)
+
+  /**
+   * Dynamically shows / hides the launcher icon for the leak display activity.
+   * Note: you can change the default value by overriding the `leak_canary_add_launcher_icon`
+   * boolean resource:
+   *
+   * ```xml
+   * <?xml version="1.0" encoding="utf-8"?>
+   * <resources>
+   *   <bool name="leak_canary_add_launcher_icon">false</bool>
+   * </resources>
+   * ```
+   */
+  fun showLeakDisplayActivityLauncherIcon(showLauncherIcon: Boolean) {
+    InternalLeakCanary.setEnabledBlocking(
+      "leakcanary.internal.activity.LeakLauncherActivity", showLauncherIcon
+    )
+  }
+
+  /**
+   * Immediately triggers a heap dump and analysis, if there is at least one retained instance
+   * tracked by [AppWatcher.objectWatcher]. If there are no retained instances then the heap will not
+   * be dumped and a notification will be shown instead.
+   */
+  fun dumpHeap() = InternalLeakCanary.onDumpHeapReceived(forceDump = true)
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LogcatEventListener.kt b/leakcanary-android-core/src/main/java/leakcanary/LogcatEventListener.kt
new file mode 100644
index 00000000..745c0834
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/LogcatEventListener.kt
@@ -0,0 +1,31 @@
+package leakcanary
+
+import leakcanary.EventListener.Event
+import leakcanary.EventListener.Event.HeapAnalysisDone
+import leakcanary.EventListener.Event.HeapAnalysisProgress
+import leakcanary.EventListener.Event.HeapDumpFailed
+import leakcanary.internal.HeapDumpTrigger
+import leakcanary.internal.activity.screen.LeakTraceWrapper
+import shark.SharkLog
+
+object LogcatEventListener : EventListener {
+
+  override fun onEvent(event: Event) {
+    when(event) {
+      is HeapDumpFailed -> {
+        if (event.willRetryLater) {
+          SharkLog.d(event.exception) { "Failed to dump heap, will retry in ${HeapDumpTrigger.WAIT_AFTER_DUMP_FAILED_MILLIS} ms" }
+        } else {
+          SharkLog.d(event.exception) { "Failed to dump heap, will not automatically retry" }
+        }
+      }
+      is HeapAnalysisProgress -> {
+        val percent =  (event.progressPercent * 100).toInt()
+        SharkLog.d { "Analysis in progress, $percent% done, working on ${event.step.humanReadableName}" }
+      }
+      is HeapAnalysisDone<*> ->  {
+        SharkLog.d { "\u200B\n${LeakTraceWrapper.wrap(event.heapAnalysis.toString(), 120)}" }
+      }
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/NotificationEventListener.kt b/leakcanary-android-core/src/main/java/leakcanary/NotificationEventListener.kt
new file mode 100644
index 00000000..c13213d0
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/NotificationEventListener.kt
@@ -0,0 +1,89 @@
+package leakcanary
+
+import android.app.Notification
+import android.app.NotificationManager
+import android.app.PendingIntent
+import android.content.Context
+import android.os.Build
+import com.squareup.leakcanary.core.R
+import leakcanary.EventListener.Event
+import leakcanary.EventListener.Event.DumpingHeap
+import leakcanary.EventListener.Event.HeapAnalysisDone
+import leakcanary.EventListener.Event.HeapAnalysisDone.HeapAnalysisSucceeded
+import leakcanary.EventListener.Event.HeapAnalysisProgress
+import leakcanary.EventListener.Event.HeapDumpFailed
+import leakcanary.EventListener.Event.HeapDump
+import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.NotificationType.LEAKCANARY_LOW
+import leakcanary.internal.NotificationType.LEAKCANARY_MAX
+import leakcanary.internal.Notifications
+
+object NotificationEventListener : EventListener {
+
+  private val appContext = InternalLeakCanary.application
+  private val notificationManager =
+    appContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+
+  override fun onEvent(event: Event) {
+    // TODO Unify Notifications.buildNotification vs Notifications.showNotification
+    // We need to bring in the retained count notifications first though.
+    if (!Notifications.canShowNotification) {
+      return
+    }
+    when (event) {
+      is DumpingHeap -> {
+        val dumpingHeap = appContext.getString(R.string.leak_canary_notification_dumping)
+        val builder = Notification.Builder(appContext)
+          .setContentTitle(dumpingHeap)
+        val notification = Notifications.buildNotification(appContext, builder, LEAKCANARY_LOW)
+        notificationManager.notify(R.id.leak_canary_notification_dumping_heap, notification)
+      }
+      is HeapDumpFailed, is HeapDump -> {
+        notificationManager.cancel(R.id.leak_canary_notification_dumping_heap)
+      }
+      is HeapAnalysisProgress -> {
+        val progress = (event.progressPercent * 100).toInt()
+        val builder = Notification.Builder(appContext)
+          .setContentTitle(appContext.getString(R.string.leak_canary_notification_analysing))
+          .setContentText(event.step.humanReadableName)
+          .setProgress(100, progress, false)
+        val notification =
+          Notifications.buildNotification(appContext, builder, LEAKCANARY_LOW)
+        notificationManager.notify(R.id.leak_canary_notification_analyzing_heap, notification)
+      }
+      is HeapAnalysisDone<*> -> {
+        notificationManager.cancel(R.id.leak_canary_notification_analyzing_heap)
+        val contentTitle = if (event is HeapAnalysisSucceeded) {
+          val heapAnalysis = event.heapAnalysis
+          val retainedObjectCount = heapAnalysis.allLeaks.sumBy { it.leakTraces.size }
+          val leakTypeCount = heapAnalysis.applicationLeaks.size + heapAnalysis.libraryLeaks.size
+          val unreadLeakCount = event.unreadLeakSignatures.size
+          appContext.getString(
+            R.string.leak_canary_analysis_success_notification,
+            retainedObjectCount,
+            leakTypeCount,
+            unreadLeakCount
+          )
+        } else {
+          appContext.getString(R.string.leak_canary_analysis_failed)
+        }
+        val flags = if (Build.VERSION.SDK_INT >= 23) {
+          PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
+        } else {
+          PendingIntent.FLAG_UPDATE_CURRENT
+        }
+        val pendingIntent = PendingIntent.getActivity(appContext, 1,  event.showIntent, flags)
+        showHeapAnalysisResultNotification(contentTitle,pendingIntent)
+      }
+    }
+  }
+
+  private fun showHeapAnalysisResultNotification(contentTitle: String, showIntent: PendingIntent) {
+    val contentText = appContext.getString(R.string.leak_canary_notification_message)
+    Notifications.showNotification(
+      appContext, contentTitle, contentText, showIntent,
+      R.id.leak_canary_notification_analysis_result,
+      LEAKCANARY_MAX
+    )
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/OnHeapAnalyzedListener.kt b/leakcanary-android-core/src/main/java/leakcanary/OnHeapAnalyzedListener.kt
new file mode 100644
index 00000000..3cfa0955
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/OnHeapAnalyzedListener.kt
@@ -0,0 +1,33 @@
+package leakcanary
+
+import shark.HeapAnalysis
+
+/**
+ * Deprecated, add to LeakCanary.config.eventListeners instead.
+ * Called after [leakcanary.EventListener.Event.HeapAnalysisDone].
+ */
+@Deprecated(message = "Add to LeakCanary.config.eventListeners instead")
+fun interface OnHeapAnalyzedListener {
+
+  /**
+   * @see OnHeapAnalyzedListener
+   */
+  fun onHeapAnalyzed(heapAnalysis: HeapAnalysis)
+
+  companion object {
+    /**
+     * Utility function to create a [OnHeapAnalyzedListener] from the passed in [block] lambda
+     * instead of using the anonymous `object : OnHeapAnalyzedListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val listener = OnHeapAnalyzedListener {
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (HeapAnalysis) -> Unit): OnHeapAnalyzedListener =
+      OnHeapAnalyzedListener { heapAnalysis -> block(heapAnalysis) }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/RemoteWorkManagerHeapAnalyzer.kt b/leakcanary-android-core/src/main/java/leakcanary/RemoteWorkManagerHeapAnalyzer.kt
new file mode 100644
index 00000000..50f534fa
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/RemoteWorkManagerHeapAnalyzer.kt
@@ -0,0 +1,50 @@
+package leakcanary
+
+import androidx.work.Data
+import androidx.work.OneTimeWorkRequest
+import androidx.work.WorkManager
+import androidx.work.multiprocess.RemoteListenableWorker.ARGUMENT_CLASS_NAME
+import androidx.work.multiprocess.RemoteListenableWorker.ARGUMENT_PACKAGE_NAME
+import leakcanary.EventListener.Event
+import leakcanary.EventListener.Event.HeapDump
+import leakcanary.internal.HeapAnalyzerWorker.Companion.asWorkerInputData
+import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.RemoteHeapAnalyzerWorker
+import shark.SharkLog
+
+/**
+ * When receiving a [HeapDump] event, starts a WorkManager worker that performs heap analysis in
+ * a dedicated :leakcanary process
+ */
+object RemoteWorkManagerHeapAnalyzer : EventListener {
+
+  private const val REMOTE_SERVICE_CLASS_NAME = "leakcanary.internal.RemoteLeakCanaryWorkerService"
+
+  internal val remoteLeakCanaryServiceInClasspath by lazy {
+    try {
+      Class.forName(REMOTE_SERVICE_CLASS_NAME)
+      true
+    } catch (ignored: Throwable) {
+      false
+    }
+  }
+
+  override fun onEvent(event: Event) {
+    if (event is HeapDump) {
+      val application = InternalLeakCanary.application
+      val heapAnalysisRequest =
+        OneTimeWorkRequest.Builder(RemoteHeapAnalyzerWorker::class.java).apply {
+          val dataBuilder = Data.Builder()
+            .putString(ARGUMENT_PACKAGE_NAME, application.packageName)
+            .putString(ARGUMENT_CLASS_NAME, REMOTE_SERVICE_CLASS_NAME)
+          setInputData(event.asWorkerInputData(dataBuilder))
+          with(WorkManagerHeapAnalyzer) {
+            addExpeditedFlag()
+          }
+        }.build()
+      SharkLog.d { "Enqueuing heap analysis for ${event.file} on WorkManager remote worker" }
+      val workManager = WorkManager.getInstance(application)
+      workManager.enqueue(heapAnalysisRequest)
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/ToastEventListener.kt b/leakcanary-android-core/src/main/java/leakcanary/ToastEventListener.kt
new file mode 100644
index 00000000..e05356c2
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/ToastEventListener.kt
@@ -0,0 +1,75 @@
+package leakcanary
+
+import android.animation.Animator
+import android.animation.AnimatorListenerAdapter
+import android.view.Gravity
+import android.view.LayoutInflater
+import android.view.View
+import android.widget.Toast
+import com.squareup.leakcanary.core.R
+import java.util.concurrent.CountDownLatch
+import java.util.concurrent.TimeUnit.SECONDS
+import leakcanary.EventListener.Event
+import leakcanary.EventListener.Event.DumpingHeap
+import leakcanary.EventListener.Event.HeapDumpFailed
+import leakcanary.EventListener.Event.HeapDump
+import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.friendly.mainHandler
+
+object ToastEventListener : EventListener {
+
+  // Only accessed from the main thread
+  private var toastCurrentlyShown: Toast? = null
+
+  override fun onEvent(event: Event) {
+    when (event) {
+      is DumpingHeap -> {
+        showToastBlocking()
+      }
+      is HeapDump, is HeapDumpFailed -> {
+        mainHandler.post {
+          toastCurrentlyShown?.cancel()
+          toastCurrentlyShown = null
+        }
+      }
+    }
+  }
+
+  @Suppress("DEPRECATION")
+  private fun showToastBlocking() {
+    val appContext = InternalLeakCanary.application
+    val waitingForToast = CountDownLatch(1)
+    mainHandler.post(Runnable {
+      val resumedActivity = InternalLeakCanary.resumedActivity
+      if (resumedActivity == null || toastCurrentlyShown != null) {
+        waitingForToast.countDown()
+        return@Runnable
+      }
+      val toast = Toast(resumedActivity)
+      // Resources from application context: https://github.com/square/leakcanary/issues/2023
+      val iconSize = appContext.resources.getDimensionPixelSize(
+        R.dimen.leak_canary_toast_icon_size
+      )
+      toast.setGravity(Gravity.CENTER_VERTICAL, 0, -iconSize)
+      toast.duration = Toast.LENGTH_LONG
+      // Need an activity context because StrictMode added new stupid checks:
+      // https://github.com/square/leakcanary/issues/2153
+      val inflater = LayoutInflater.from(resumedActivity)
+      toast.view = inflater.inflate(R.layout.leak_canary_heap_dump_toast, null)
+      toast.show()
+
+      val toastIcon = toast.view!!.findViewById<View>(R.id.leak_canary_toast_icon)
+      toastIcon.translationY = -iconSize.toFloat()
+      toastIcon
+        .animate()
+        .translationY(0f)
+        .setListener(object : AnimatorListenerAdapter() {
+          override fun onAnimationEnd(animation: Animator) {
+            toastCurrentlyShown = toast
+            waitingForToast.countDown()
+          }
+        })
+    })
+    waitingForToast.await(5, SECONDS)
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/TvEventListener.kt b/leakcanary-android-core/src/main/java/leakcanary/TvEventListener.kt
new file mode 100644
index 00000000..01460517
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/TvEventListener.kt
@@ -0,0 +1,68 @@
+package leakcanary
+
+import com.squareup.leakcanary.core.R
+import leakcanary.EventListener.Event
+import leakcanary.EventListener.Event.HeapAnalysisDone
+import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.activity.LeakActivity
+import leakcanary.internal.friendly.mainHandler
+import leakcanary.internal.tv.TvToast
+import shark.HeapAnalysis
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.SharkLog
+
+object TvEventListener : EventListener {
+
+  private val appContext = InternalLeakCanary.application
+
+  override fun onEvent(event: Event) {
+    when (event) {
+      is HeapAnalysisDone<*> -> {
+        showToast(event.heapAnalysis)
+        printIntentInfo()
+      }
+    }
+  }
+
+  /**
+   * Android TV devices do not have notifications, therefore the only easy and non-invasive way
+   * to communicate with user is via Toast messages. These are used just to grab user attention and
+   * to direct them to Logcat where a much more detailed report will be printed.
+   */
+  private fun showToast(heapAnalysis: HeapAnalysis) {
+    mainHandler.post {
+      val resumedActivity = InternalLeakCanary.resumedActivity ?: return@post
+      val message: String = when (heapAnalysis) {
+        is HeapAnalysisSuccess -> {
+          appContext.getString(
+            R.string.leak_canary_tv_analysis_success,
+            heapAnalysis.applicationLeaks.size,
+            heapAnalysis.libraryLeaks.size
+          )
+        }
+        is HeapAnalysisFailure -> appContext.getString(R.string.leak_canary_tv_analysis_failure)
+      }
+      TvToast.makeText(resumedActivity, message)
+        .show()
+    }
+  }
+
+  /**
+   * Android TV with API 26+ has a bug where the launcher icon doesn't appear, so users won't know how
+   * to launch LeakCanary Activity.
+   * This method prints an adb command that launched LeakCanary into the logcat
+   */
+  private fun printIntentInfo() {
+    val leakClass = LeakActivity::class.java
+    SharkLog.d {"""
+      ====================================
+      ANDROID TV LAUNCH INTENT
+      ====================================
+      Run the following adb command to display the list of leaks:
+
+      adb shell am start -n "${appContext.packageName}/${leakClass.`package`?.name}.LeakLauncherActivity"
+      ====================================""".trimIndent()
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/WorkManagerHeapAnalyzer.kt b/leakcanary-android-core/src/main/java/leakcanary/WorkManagerHeapAnalyzer.kt
new file mode 100644
index 00000000..73a8503e
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/WorkManagerHeapAnalyzer.kt
@@ -0,0 +1,61 @@
+package leakcanary
+
+import androidx.work.OneTimeWorkRequest
+import androidx.work.OutOfQuotaPolicy
+import androidx.work.WorkManager
+import leakcanary.EventListener.Event
+import leakcanary.EventListener.Event.HeapDump
+import leakcanary.internal.HeapAnalyzerWorker
+import leakcanary.internal.HeapAnalyzerWorker.Companion.asWorkerInputData
+import leakcanary.internal.InternalLeakCanary
+import shark.SharkLog
+
+/**
+ * When receiving a [HeapDump] event, starts a WorkManager worker that performs heap analysis.
+ */
+object WorkManagerHeapAnalyzer : EventListener {
+
+  internal val validWorkManagerInClasspath by lazy {
+    try {
+      Class.forName("androidx.work.WorkManager")
+      // We need Data.Builder.putByteArray which was introduced in WorkManager 2.1.0.
+      // https://github.com/square/leakcanary/issues/2310
+      val dataBuilderClass = Class.forName("androidx.work.Data\$Builder")
+      dataBuilderClass.declaredMethods.any { it.name == "putByteArray" }.apply {
+        if (!this) {
+          SharkLog.d { "Could not find androidx.work.Data\$Builder.putByteArray, WorkManager should be at least 2.1.0." }
+        }
+      }
+    } catch (ignored: Throwable) {
+      false
+    }
+  }
+
+  // setExpedited() requires WorkManager 2.7.0+
+  private val workManagerSupportsExpeditedRequests by lazy {
+    try {
+      Class.forName("androidx.work.OutOfQuotaPolicy")
+      true
+    } catch (ignored: Throwable) {
+      false
+    }
+  }
+
+  internal fun OneTimeWorkRequest.Builder.addExpeditedFlag() = apply {
+    if (workManagerSupportsExpeditedRequests) {
+      setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)
+    }
+  }
+
+  override fun onEvent(event: Event) {
+    if (event is HeapDump) {
+      val heapAnalysisRequest = OneTimeWorkRequest.Builder(HeapAnalyzerWorker::class.java).apply {
+        setInputData(event.asWorkerInputData())
+        addExpeditedFlag()
+      }.build()
+      SharkLog.d { "Enqueuing heap analysis for ${event.file} on WorkManager remote worker" }
+      val application = InternalLeakCanary.application
+      WorkManager.getInstance(application).enqueue(heapAnalysisRequest)
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidDebugHeapAnalyzer.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidDebugHeapAnalyzer.kt
new file mode 100644
index 00000000..4c9769c8
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidDebugHeapAnalyzer.kt
@@ -0,0 +1,195 @@
+package leakcanary.internal
+
+import java.io.File
+import java.io.IOException
+import leakcanary.EventListener
+import leakcanary.EventListener.Event.HeapAnalysisDone
+import leakcanary.EventListener.Event.HeapAnalysisDone.HeapAnalysisFailed
+import leakcanary.EventListener.Event.HeapAnalysisDone.HeapAnalysisSucceeded
+import leakcanary.EventListener.Event.HeapAnalysisProgress
+import leakcanary.EventListener.Event.HeapDump
+import leakcanary.LeakCanary
+import leakcanary.internal.activity.LeakActivity
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.LeakTable
+import leakcanary.internal.activity.db.ScopedLeaksDb
+import shark.ConstantMemoryMetricsDualSourceProvider
+import shark.HeapAnalysis
+import shark.HeapAnalysisException
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.HeapAnalyzer
+import shark.HprofHeapGraph
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.OnAnalysisProgressListener
+import shark.OnAnalysisProgressListener.Step.PARSING_HEAP_DUMP
+import shark.OnAnalysisProgressListener.Step.REPORTING_HEAP_ANALYSIS
+import shark.ProguardMappingReader
+import shark.ThrowingCancelableFileSourceProvider
+
+/**
+ * This should likely turn into a public API but probably better to do once it's
+ * coroutine based to supports cleaner cancellation + publishing progress.
+ */
+internal object AndroidDebugHeapAnalyzer {
+
+  private const val PROGUARD_MAPPING_FILE_NAME = "leakCanaryObfuscationMapping.txt"
+
+  private val application = InternalLeakCanary.application
+
+  /**
+   * Runs the heap analysis on the current thread and then sends a
+   * [EventListener.Event.HeapAnalysisDone] event with the result (from the current thread as well).
+   */
+  fun runAnalysisBlocking(
+    heapDumped: HeapDump,
+    isCanceled: () -> Boolean = { false },
+    progressEventListener: (HeapAnalysisProgress) -> Unit
+  ): HeapAnalysisDone<*> {
+    val progressListener = OnAnalysisProgressListener { step ->
+      val percent = (step.ordinal * 1.0) / OnAnalysisProgressListener.Step.values().size
+      progressEventListener(HeapAnalysisProgress(heapDumped.uniqueId, step, percent))
+    }
+
+    val heapDumpFile = heapDumped.file
+    val heapDumpDurationMillis = heapDumped.durationMillis
+    val heapDumpReason = heapDumped.reason
+
+    val heapAnalysis = if (heapDumpFile.exists()) {
+      analyzeHeap(heapDumpFile, progressListener, isCanceled)
+    } else {
+      missingFileFailure(heapDumpFile)
+    }
+
+    val fullHeapAnalysis = when (heapAnalysis) {
+      is HeapAnalysisSuccess -> heapAnalysis.copy(
+        dumpDurationMillis = heapDumpDurationMillis,
+        metadata = heapAnalysis.metadata + ("Heap dump reason" to heapDumpReason)
+      )
+      is HeapAnalysisFailure -> {
+        val failureCause = heapAnalysis.exception.cause!!
+        if (failureCause is OutOfMemoryError) {
+          heapAnalysis.copy(
+            dumpDurationMillis = heapDumpDurationMillis,
+            exception = HeapAnalysisException(
+              RuntimeException(
+                """
+              Not enough memory to analyze heap. You can:
+              - Kill the app then restart the analysis from the LeakCanary activity.
+              - Increase the memory available to your debug app with largeHeap=true: https://developer.android.com/guide/topics/manifest/application-element#largeHeap
+              - Set up LeakCanary to run in a separate process: https://square.github.io/leakcanary/recipes/#running-the-leakcanary-analysis-in-a-separate-process
+              - Download the heap dump from the LeakCanary activity then run the analysis from your computer with shark-cli: https://square.github.io/leakcanary/shark/#shark-cli
+            """.trimIndent(), failureCause
+              )
+            )
+          )
+        } else {
+          heapAnalysis.copy(dumpDurationMillis = heapDumpDurationMillis)
+        }
+      }
+    }
+    progressListener.onAnalysisProgress(REPORTING_HEAP_ANALYSIS)
+
+    val analysisDoneEvent = ScopedLeaksDb.writableDatabase(application) { db ->
+      val id = HeapAnalysisTable.insert(db, heapAnalysis)
+      when (fullHeapAnalysis) {
+        is HeapAnalysisSuccess -> {
+          val showIntent = LeakActivity.createSuccessIntent(application, id)
+          val leakSignatures = fullHeapAnalysis.allLeaks.map { it.signature }.toSet()
+          val leakSignatureStatuses = LeakTable.retrieveLeakReadStatuses(db, leakSignatures)
+          val unreadLeakSignatures = leakSignatureStatuses.filter { (_, read) ->
+            !read
+          }.keys
+            // keys returns LinkedHashMap$LinkedKeySet which isn't Serializable
+            .toSet()
+          HeapAnalysisSucceeded(
+            heapDumped.uniqueId,
+            fullHeapAnalysis,
+            unreadLeakSignatures,
+            showIntent
+          )
+        }
+        is HeapAnalysisFailure -> {
+          val showIntent = LeakActivity.createFailureIntent(application, id)
+          HeapAnalysisFailed(heapDumped.uniqueId, fullHeapAnalysis, showIntent)
+        }
+      }
+    }
+    LeakCanary.config.onHeapAnalyzedListener.onHeapAnalyzed(fullHeapAnalysis)
+    return analysisDoneEvent
+  }
+
+  private fun analyzeHeap(
+    heapDumpFile: File,
+    progressListener: OnAnalysisProgressListener,
+    isCanceled: () -> Boolean
+  ): HeapAnalysis {
+    val config = LeakCanary.config
+    val heapAnalyzer = HeapAnalyzer(progressListener)
+    val proguardMappingReader = try {
+      ProguardMappingReader(application.assets.open(PROGUARD_MAPPING_FILE_NAME))
+    } catch (e: IOException) {
+      null
+    }
+
+    progressListener.onAnalysisProgress(PARSING_HEAP_DUMP)
+
+    val sourceProvider =
+      ConstantMemoryMetricsDualSourceProvider(ThrowingCancelableFileSourceProvider(heapDumpFile) {
+        if (isCanceled()) {
+          throw RuntimeException("Analysis canceled")
+        }
+      })
+
+    val closeableGraph = try {
+      sourceProvider.openHeapGraph(proguardMapping = proguardMappingReader?.readProguardMapping())
+    } catch (throwable: Throwable) {
+      return HeapAnalysisFailure(
+        heapDumpFile = heapDumpFile,
+        createdAtTimeMillis = System.currentTimeMillis(),
+        analysisDurationMillis = 0,
+        exception = HeapAnalysisException(throwable)
+      )
+    }
+    return closeableGraph
+      .use { graph ->
+        val result = heapAnalyzer.analyze(
+          heapDumpFile = heapDumpFile,
+          graph = graph,
+          leakingObjectFinder = config.leakingObjectFinder,
+          referenceMatchers = config.referenceMatchers,
+          computeRetainedHeapSize = config.computeRetainedHeapSize,
+          objectInspectors = config.objectInspectors,
+          metadataExtractor = config.metadataExtractor
+        )
+        if (result is HeapAnalysisSuccess) {
+          val lruCacheStats = (graph as HprofHeapGraph).lruCacheStats()
+          val randomAccessStats =
+            "RandomAccess[" +
+              "bytes=${sourceProvider.randomAccessByteReads}," +
+              "reads=${sourceProvider.randomAccessReadCount}," +
+              "travel=${sourceProvider.randomAccessByteTravel}," +
+              "range=${sourceProvider.byteTravelRange}," +
+              "size=${heapDumpFile.length()}" +
+              "]"
+          val stats = "$lruCacheStats $randomAccessStats"
+          result.copy(metadata = result.metadata + ("Stats" to stats))
+        } else result
+      }
+  }
+
+  private fun missingFileFailure(
+    heapDumpFile: File
+  ): HeapAnalysisFailure {
+    val deletedReason = LeakDirectoryProvider.hprofDeleteReason(heapDumpFile)
+    val exception = IllegalStateException(
+      "Hprof file $heapDumpFile missing, deleted because: $deletedReason"
+    )
+    return HeapAnalysisFailure(
+      heapDumpFile = heapDumpFile,
+      createdAtTimeMillis = System.currentTimeMillis(),
+      analysisDurationMillis = 0,
+      exception = HeapAnalysisException(exception)
+    )
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DebuggerControl.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DebuggerControl.kt
new file mode 100644
index 00000000..512f6fb8
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DebuggerControl.kt
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.os.Debug
+
+/**
+ * Gives the opportunity to skip checking if a reference is gone when the debugger is connected.
+ * An attached debugger might retain references and create false positives.
+ */
+internal object DebuggerControl {
+
+  val isDebuggerAttached: Boolean
+    get() = Debug.isDebuggerConnected()
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
new file mode 100644
index 00000000..377b8567
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
@@ -0,0 +1,298 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.content.Context
+import android.text.Html
+import android.text.SpannableStringBuilder
+import android.text.method.LinkMovementMethod
+import android.view.View
+import android.view.ViewGroup
+import android.widget.BaseAdapter
+import android.widget.TextView
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.DisplayLeakConnectorView.Type
+import leakcanary.internal.DisplayLeakConnectorView.Type.END
+import leakcanary.internal.DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.GC_ROOT
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_FIRST_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_LAST_REACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_REACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNKNOWN
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.START
+import leakcanary.internal.DisplayLeakConnectorView.Type.START_LAST_REACHABLE
+import leakcanary.internal.navigation.getColorCompat
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.utils.humanReadableByteCount
+import shark.LeakTrace
+import shark.LeakTrace.GcRootType.JAVA_FRAME
+import shark.LeakTraceObject
+import shark.LeakTraceObject.LeakingStatus.LEAKING
+import shark.LeakTraceObject.LeakingStatus.NOT_LEAKING
+import shark.LeakTraceObject.LeakingStatus.UNKNOWN
+import shark.LeakTraceReference
+import shark.LeakTraceReference.ReferenceType.INSTANCE_FIELD
+import shark.LeakTraceReference.ReferenceType.STATIC_FIELD
+
+@Suppress("DEPRECATION")
+internal class DisplayLeakAdapter constructor(
+  context: Context,
+  private val leakTrace: LeakTrace,
+  private val header: CharSequence
+) : BaseAdapter() {
+
+  private val highlightColorHexString: String =
+    hexStringColor(context, R.color.leak_canary_class_name)
+  private val leakColorHexString: String = hexStringColor(context, R.color.leak_canary_leak)
+  private val referenceColorHexString: String =
+    hexStringColor(context, R.color.leak_canary_reference)
+  private val extraColorHexString: String = hexStringColor(context, R.color.leak_canary_extra)
+  private val helpColorHexString: String = hexStringColor(context, R.color.leak_canary_help)
+
+  override fun getView(
+    position: Int,
+    convertView: View?,
+    parent: ViewGroup
+  ): View {
+    return when (getItemViewType(position)) {
+      HEADER_ROW -> {
+        val view = convertView ?: parent.inflate(R.layout.leak_canary_leak_header)
+        bindHeaderRow(view)
+        view
+      }
+      CONNECTOR_ROW -> {
+        val view = convertView ?: parent.inflate(R.layout.leak_canary_ref_row)
+        bindConnectorRow(view, position)
+        view
+      }
+      else -> {
+        throw IllegalStateException("Unexpected type ${getItemViewType(position)}")
+      }
+    }
+  }
+
+  private fun bindHeaderRow(
+    view: View
+  ) {
+    view.findViewById<TextView>(R.id.leak_canary_header_text)
+      .apply {
+        movementMethod = LinkMovementMethod.getInstance()
+        text = header
+      }
+  }
+
+  private fun bindConnectorRow(
+    view: View,
+    position: Int
+  ) {
+    val titleView = view.findViewById<TextView>(R.id.leak_canary_row_title)
+    val connector = view.findViewById<DisplayLeakConnectorView>(R.id.leak_canary_row_connector)
+
+    connector.setType(getConnectorType(position))
+
+    titleView.text = when {
+      position == 1 -> {
+        "GC Root: ${leakTrace.gcRootType.description}"
+      }
+      position < count - 1 -> {
+        val referencePathIndex = elementIndex(position)
+        val referencePath = leakTrace.referencePath[referencePathIndex]
+        val isSuspect = leakTrace.referencePathElementIsSuspect(referencePathIndex)
+
+        val leakTraceObject = referencePath.originObject
+
+        val typeName =
+          if (position == 2 && leakTrace.gcRootType == JAVA_FRAME) "thread" else leakTraceObject.typeName
+
+        var referenceName = referencePath.referenceDisplayName
+
+        referenceName = referenceName.replace("<".toRegex(), "&lt;")
+          .replace(">".toRegex(), "&gt;")
+
+        referenceName = if (isSuspect) {
+          "<u><font color='$leakColorHexString'>$referenceName</font></u>"
+        } else {
+          "<font color='$referenceColorHexString'>$referenceName</font>"
+        }
+
+        if (referencePath.referenceType == STATIC_FIELD) {
+          referenceName = "<i>$referenceName</i>"
+        }
+
+        if (isSuspect) {
+          referenceName = "<b>$referenceName</b>"
+        }
+
+        val staticPrefix = if (referencePath.referenceType == STATIC_FIELD) "static " else ""
+
+        val htmlString = leakTraceObject.asHtmlString(typeName) +
+          "$INDENTATION$staticPrefix${referencePath.styledOwningClassSimpleName()}${
+            when (referencePath.referenceType) {
+              STATIC_FIELD, INSTANCE_FIELD -> "."
+              else -> ""
+            }
+          }$referenceName"
+
+        val builder = Html.fromHtml(htmlString) as SpannableStringBuilder
+        if (isSuspect) {
+          SquigglySpan.replaceUnderlineSpans(builder, view.context)
+        }
+        builder
+      }
+      else -> {
+        Html.fromHtml(leakTrace.leakingObject.asHtmlString(leakTrace.leakingObject.typeName))
+      }
+    }
+  }
+
+  private fun LeakTraceObject.asHtmlString(typeName: String): String {
+    val packageEnd = className.lastIndexOf('.')
+
+    val extra: (String) -> String = { "<font color='$extraColorHexString'>$it</font>" }
+
+    val styledClassName = styledClassSimpleName()
+    var htmlString =
+      if (packageEnd != -1) "${
+        extra(
+          className.substring(
+            0, packageEnd
+          )
+        )
+      }.$styledClassName" else styledClassName
+    htmlString += " ${extra(typeName)}<br>"
+
+    val reachabilityString = when (leakingStatus) {
+      UNKNOWN -> extra("UNKNOWN")
+      NOT_LEAKING -> "NO" + extra(" (${leakingStatusReason})")
+      LEAKING -> "YES" + extra(" (${leakingStatusReason})")
+    }
+
+    htmlString += "$INDENTATION${extra("Leaking: ")}$reachabilityString<br>"
+
+    retainedHeapByteSize?.let {
+      val humanReadableRetainedHeapSize = humanReadableByteCount(it.toLong(), si = true)
+      htmlString += "${INDENTATION}${extra("Retaining ")}$humanReadableRetainedHeapSize${
+        extra(
+          " in "
+        )
+      }$retainedObjectCount${extra(" objects")}<br>"
+    }
+
+    labels.forEach { label ->
+      htmlString += "$INDENTATION${extra(label)}<br>"
+    }
+    return htmlString
+  }
+
+  private fun LeakTraceObject.styledClassSimpleName(): String {
+    val simpleName = classSimpleName.replace("[]", "[ ]")
+    return "<font color='$highlightColorHexString'>$simpleName</font>"
+  }
+
+  private fun LeakTraceReference.styledOwningClassSimpleName(): String {
+    val simpleName = owningClassSimpleName.removeSuffix("[]")
+    return "<font color='$highlightColorHexString'>$simpleName</font>"
+  }
+
+  @Suppress("ReturnCount")
+  private fun getConnectorType(position: Int): Type {
+    if (position == 1) {
+      return GC_ROOT
+    } else if (position == 2) {
+      return when (leakTrace.referencePath.size) {
+        0 -> END_FIRST_UNREACHABLE
+        1 -> START_LAST_REACHABLE
+        else -> {
+          val nextReachability = leakTrace.referencePath[1].originObject
+          if (nextReachability.leakingStatus != NOT_LEAKING) {
+            START_LAST_REACHABLE
+          } else START
+        }
+      }
+    } else {
+      val isLeakingInstance = position == count - 1
+      if (isLeakingInstance) {
+        val previousReachability = leakTrace.referencePath.last()
+          .originObject
+        return if (previousReachability.leakingStatus != LEAKING) {
+          END_FIRST_UNREACHABLE
+        } else END
+      } else {
+        val reachability = leakTrace.referencePath[elementIndex(position)].originObject
+        when (reachability.leakingStatus) {
+          UNKNOWN -> return NODE_UNKNOWN
+          NOT_LEAKING -> {
+            val nextReachability =
+              if (position + 1 == count - 1) leakTrace.leakingObject else leakTrace.referencePath[elementIndex(
+                position + 1
+              )].originObject
+            return if (nextReachability.leakingStatus != NOT_LEAKING) {
+              NODE_LAST_REACHABLE
+            } else {
+              NODE_REACHABLE
+            }
+          }
+          LEAKING -> {
+            val previousReachability =
+              leakTrace.referencePath[elementIndex(position - 1)].originObject
+            return if (previousReachability.leakingStatus != LEAKING) {
+              NODE_FIRST_UNREACHABLE
+            } else {
+              NODE_UNREACHABLE
+            }
+          }
+          else -> throw IllegalStateException(
+            "Unknown value: " + reachability.leakingStatus
+          )
+        }
+      }
+    }
+  }
+
+  override fun isEnabled(position: Int) = false
+
+  override fun getCount() = leakTrace.referencePath.size + 3
+
+  override fun getItem(position: Int) = when (position) {
+      0, 1 -> null
+      count - 1 -> leakTrace.leakingObject
+      else -> leakTrace.referencePath[elementIndex(position)]
+  }
+
+  private fun elementIndex(position: Int) = position - 2
+
+  override fun getViewTypeCount() = 2
+
+  override fun getItemViewType(position: Int) = if (position == 0) HEADER_ROW else CONNECTOR_ROW
+
+  override fun getItemId(position: Int) = position.toLong()
+
+  companion object {
+
+    const val HEADER_ROW = 0
+    const val CONNECTOR_ROW = 1
+    val INDENTATION = "&nbsp;".repeat(4)
+
+    // https://stackoverflow.com/a/6540378/703646
+    private fun hexStringColor(
+      context: Context,
+      colorResId: Int
+    ): String {
+      return String.format("#%06X", 0xFFFFFF and context.getColorCompat(colorResId))
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
new file mode 100644
index 00000000..4219bb8b
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
@@ -0,0 +1,241 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.content.Context
+import android.graphics.Bitmap
+import android.graphics.Bitmap.Config.ARGB_8888
+import android.graphics.Canvas
+import android.graphics.Color
+import android.graphics.DashPathEffect
+import android.graphics.Paint
+import android.graphics.PorterDuff.Mode.CLEAR
+import android.graphics.PorterDuffXfermode
+import android.util.AttributeSet
+import android.view.View
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.DisplayLeakConnectorView.Type.END
+import leakcanary.internal.DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.GC_ROOT
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_FIRST_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_LAST_REACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_REACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNKNOWN
+import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNREACHABLE
+import leakcanary.internal.DisplayLeakConnectorView.Type.START
+import leakcanary.internal.DisplayLeakConnectorView.Type.START_LAST_REACHABLE
+import leakcanary.internal.navigation.getColorCompat
+import kotlin.math.sqrt
+
+internal class DisplayLeakConnectorView(
+  context: Context,
+  attrs: AttributeSet
+) : View(context, attrs) {
+
+  private val classNamePaint: Paint
+  private val leakPaint: Paint
+  private val clearPaint: Paint
+  private val referencePaint: Paint
+  private val strokeSize: Float
+  private val circleY: Float
+
+  private var type: Type? = null
+  private var cache: Bitmap? = null
+
+  enum class Type {
+    GC_ROOT,
+    START,
+    START_LAST_REACHABLE,
+    NODE_UNKNOWN,
+    NODE_FIRST_UNREACHABLE,
+    NODE_UNREACHABLE,
+    NODE_REACHABLE,
+    NODE_LAST_REACHABLE,
+    END,
+    END_FIRST_UNREACHABLE
+  }
+
+  init {
+
+    val resources = resources
+
+    type = NODE_UNKNOWN
+    circleY = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_center_y)
+      .toFloat()
+    strokeSize = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_stroke_size)
+      .toFloat()
+
+    classNamePaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    classNamePaint.color = context.getColorCompat(R.color.leak_canary_class_name)
+    classNamePaint.strokeWidth = strokeSize
+
+
+    leakPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    leakPaint.color = context.getColorCompat(R.color.leak_canary_leak)
+    leakPaint.style = Paint.Style.STROKE
+    leakPaint.strokeWidth = strokeSize
+
+    val pathLines = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_leak_dash_line)
+      .toFloat()
+
+    val pathGaps = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_leak_dash_gap)
+      .toFloat()
+    leakPaint.pathEffect = DashPathEffect(floatArrayOf(pathLines, pathGaps), 0f)
+
+    clearPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    clearPaint.color = Color.TRANSPARENT
+    clearPaint.xfermode = CLEAR_XFER_MODE
+
+    referencePaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    referencePaint.color = context.getColorCompat(R.color.leak_canary_reference)
+    referencePaint.strokeWidth = strokeSize
+  }
+
+  override fun onDraw(canvas: Canvas) {
+    val width = measuredWidth
+    val height = measuredHeight
+
+    if (cache != null && (cache!!.width != width || cache!!.height != height)) {
+      cache!!.recycle()
+      cache = null
+    }
+
+    if (cache == null) {
+      cache = Bitmap.createBitmap(width, height, ARGB_8888)
+
+      val cacheCanvas = Canvas(cache!!)
+
+      when (type) {
+        NODE_UNKNOWN -> drawItems(cacheCanvas, leakPaint, leakPaint)
+        NODE_UNREACHABLE, NODE_REACHABLE -> drawItems(
+          cacheCanvas, referencePaint, referencePaint
+        )
+        NODE_FIRST_UNREACHABLE -> drawItems(
+          cacheCanvas, leakPaint, referencePaint
+        )
+        NODE_LAST_REACHABLE -> drawItems(
+          cacheCanvas, referencePaint, leakPaint
+        )
+        START -> {
+          drawStartLine(cacheCanvas)
+          drawItems(cacheCanvas, null, referencePaint)
+        }
+        START_LAST_REACHABLE -> {
+          drawStartLine(cacheCanvas)
+          drawItems(cacheCanvas, null, leakPaint)
+        }
+        END -> drawItems(cacheCanvas, referencePaint, null)
+        END_FIRST_UNREACHABLE -> drawItems(
+          cacheCanvas, leakPaint, null
+        )
+        GC_ROOT -> drawGcRoot(cacheCanvas)
+        else -> throw UnsupportedOperationException("Unknown type " + type!!)
+      }
+    }
+    canvas.drawBitmap(cache!!, 0f, 0f, null)
+  }
+
+  private fun drawStartLine(cacheCanvas: Canvas) {
+    val width = measuredWidth
+    val halfWidth = width / 2f
+    cacheCanvas.drawLine(halfWidth, 0f, halfWidth, circleY, classNamePaint)
+  }
+
+  private fun drawGcRoot(
+    cacheCanvas: Canvas
+  ) {
+    val width = measuredWidth
+    val height = measuredHeight
+    val halfWidth = width / 2f
+    cacheCanvas.drawLine(halfWidth, 0f, halfWidth, height.toFloat(), classNamePaint)
+  }
+
+  private fun drawItems(
+    cacheCanvas: Canvas,
+    arrowHeadPaint: Paint?,
+    nextArrowPaint: Paint?
+  ) {
+    if (arrowHeadPaint != null) {
+      drawArrowHead(cacheCanvas, arrowHeadPaint)
+    }
+    if (nextArrowPaint != null) {
+      drawNextArrowLine(cacheCanvas, nextArrowPaint)
+    }
+    drawInstanceCircle(cacheCanvas)
+  }
+
+  private fun drawArrowHead(
+    cacheCanvas: Canvas,
+    paint: Paint
+  ) {
+    // Circle center is at half height
+    val width = measuredWidth
+    val halfWidth = width / 2f
+    val circleRadius = width / 3f
+// Splitting the arrow head in two makes an isosceles right triangle.
+    // It's hypotenuse is side * sqrt(2)
+    val arrowHeight = halfWidth / 2 * SQRT_TWO
+    val halfStrokeSize = strokeSize / 2
+    val translateY = circleY - arrowHeight - circleRadius * 2 - strokeSize
+
+    val lineYEnd = circleY - circleRadius - strokeSize / 2
+    cacheCanvas.drawLine(halfWidth, 0f, halfWidth, lineYEnd, paint)
+    cacheCanvas.translate(halfWidth, translateY)
+    cacheCanvas.rotate(45f)
+    cacheCanvas.drawLine(
+      0f, halfWidth, halfWidth + halfStrokeSize, halfWidth,
+      paint
+    )
+    cacheCanvas.drawLine(halfWidth, 0f, halfWidth, halfWidth, paint)
+    cacheCanvas.rotate(-45f)
+    cacheCanvas.translate(-halfWidth, -translateY)
+  }
+
+  private fun drawNextArrowLine(
+    cacheCanvas: Canvas,
+    paint: Paint
+  ) {
+    val height = measuredHeight
+    val width = measuredWidth
+    val centerX = width / 2f
+    cacheCanvas.drawLine(centerX, circleY, centerX, height.toFloat(), paint)
+  }
+
+  private fun drawInstanceCircle(cacheCanvas: Canvas) {
+    val width = measuredWidth
+    val circleX = width / 2f
+    val circleRadius = width / 3f
+    cacheCanvas.drawCircle(circleX, circleY, circleRadius, classNamePaint)
+  }
+
+  fun setType(type: Type) {
+    if (type != this.type) {
+      this.type = type
+      if (cache != null) {
+        cache!!.recycle()
+        cache = null
+      }
+      invalidate()
+    }
+  }
+
+  companion object {
+
+    private val SQRT_TWO = sqrt(2.0)
+      .toFloat()
+    private val CLEAR_XFER_MODE = PorterDuffXfermode(CLEAR)
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerWorker.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerWorker.kt
new file mode 100644
index 00000000..f2186c40
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerWorker.kt
@@ -0,0 +1,56 @@
+package leakcanary.internal
+
+import android.app.Notification
+import android.content.Context
+import androidx.work.Data
+import androidx.work.ForegroundInfo
+import androidx.work.Worker
+import androidx.work.WorkerParameters
+import androidx.work.impl.utils.futures.SettableFuture
+import com.google.common.util.concurrent.ListenableFuture
+import com.squareup.leakcanary.core.R
+import leakcanary.EventListener.Event
+
+internal class HeapAnalyzerWorker(appContext: Context, workerParams: WorkerParameters) :
+  Worker(appContext, workerParams) {
+  override fun doWork(): Result {
+    val doneEvent =
+      AndroidDebugHeapAnalyzer.runAnalysisBlocking(inputData.asEvent()) { event ->
+        InternalLeakCanary.sendEvent(event)
+      }
+    InternalLeakCanary.sendEvent(doneEvent)
+    return Result.success()
+  }
+
+  override fun getForegroundInfoAsync(): ListenableFuture<ForegroundInfo> {
+    return applicationContext.heapAnalysisForegroundInfoAsync()
+  }
+
+  companion object {
+    private const val EVENT_BYTES = "EVENT_BYTES"
+
+    fun Event.asWorkerInputData(dataBuilder: Data.Builder = Data.Builder()) = dataBuilder
+      .putByteArray(EVENT_BYTES, toByteArray())
+      .build()
+
+    inline fun <reified T> Data.asEvent(): T =
+      Serializables.fromByteArray<T>(getByteArray(EVENT_BYTES)!!)!!
+
+    fun Context.heapAnalysisForegroundInfoAsync(): ListenableFuture<ForegroundInfo> {
+      val infoFuture = SettableFuture.create<ForegroundInfo>()
+      val builder = Notification.Builder(this)
+        .setContentTitle(getString(R.string.leak_canary_notification_analysing))
+        .setContentText("LeakCanary is working.")
+        .setProgress(100, 0, true)
+      val notification =
+        Notifications.buildNotification(this, builder, NotificationType.LEAKCANARY_LOW)
+      infoFuture.set(
+        ForegroundInfo(
+          R.id.leak_canary_notification_analyzing_heap,
+          notification
+        )
+      )
+      return infoFuture
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpControl.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpControl.kt
new file mode 100644
index 00000000..2e0461d9
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpControl.kt
@@ -0,0 +1,107 @@
+package leakcanary.internal
+
+import android.app.Application
+import android.os.Handler
+import android.os.HandlerThread
+import com.squareup.leakcanary.core.R
+import leakcanary.AppWatcher
+import leakcanary.LeakCanary
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.Nope
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.NotifyingNope
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.SilentNope
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.Yup
+
+internal object HeapDumpControl {
+
+  sealed class ICanHazHeap {
+    object Yup : ICanHazHeap()
+    abstract class Nope(val reason: () -> String) : ICanHazHeap()
+    class SilentNope(reason: () -> String) : Nope(reason)
+
+    /**
+     * Allows manual dumping via a notification
+     */
+    class NotifyingNope(reason: () -> String) : Nope(reason)
+  }
+
+  @Volatile
+  private lateinit var latest: ICanHazHeap
+
+  private val app: Application
+    get() = InternalLeakCanary.application
+
+  private val testClassName by lazy {
+    InternalLeakCanary.application.getString(R.string.leak_canary_test_class_name)
+  }
+
+  private val hasTestClass by lazy {
+    try {
+      Class.forName(testClassName)
+      true
+    } catch (e: Exception) {
+      false
+    }
+  }
+
+  private val backgroundUpdateHandler by lazy {
+    val handlerThread = HandlerThread("LeakCanary-Background-iCanHasHeap-Updater")
+    handlerThread.start()
+    Handler(handlerThread.looper)
+  }
+
+  private const val leakAssertionsClassName = "leakcanary.LeakAssertions"
+
+  private val hasLeakAssertionsClass by lazy {
+    try {
+      Class.forName(leakAssertionsClassName)
+      true
+    } catch (e: Exception) {
+      false
+    }
+  }
+
+  fun updateICanHasHeapInBackground() {
+    backgroundUpdateHandler.post {
+      iCanHasHeap()
+    }
+  }
+
+  fun iCanHasHeap(): ICanHazHeap {
+    val config = LeakCanary.config
+    val dumpHeap = if (!AppWatcher.isInstalled) {
+      // Can't use a resource, we don't have an Application instance when not installed
+      SilentNope { "AppWatcher is not installed." }
+    } else if (!InternalLeakCanary.dumpEnabledInAboutScreen) {
+      NotifyingNope {
+        app.getString(R.string.leak_canary_heap_dump_disabled_from_ui)
+      }
+    } else if (!config.dumpHeap) {
+      SilentNope { app.getString(R.string.leak_canary_heap_dump_disabled_by_app) }
+    } else if (hasTestClass) {
+      SilentNope {
+        app.getString(R.string.leak_canary_heap_dump_disabled_running_tests, testClassName)
+      }
+    } else if (hasLeakAssertionsClass) {
+      SilentNope {
+        app.getString(
+          R.string.leak_canary_heap_dump_disabled_running_tests,
+          leakAssertionsClassName
+        )
+      }
+    } else if (!config.dumpHeapWhenDebugging && DebuggerControl.isDebuggerAttached) {
+      backgroundUpdateHandler.postDelayed({
+        iCanHasHeap()
+      }, 20_000L)
+      NotifyingNope { app.getString(R.string.leak_canary_notification_retained_debugger_attached) }
+    } else Yup
+
+    synchronized(this) {
+      if (::latest.isInitialized && dumpHeap is Yup && latest is Nope) {
+        InternalLeakCanary.scheduleRetainedObjectCheck()
+      }
+      latest = dumpHeap
+    }
+
+    return dumpHeap
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
new file mode 100644
index 00000000..fdd98c17
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -0,0 +1,422 @@
+package leakcanary.internal
+
+import android.app.Application
+import android.app.Notification
+import android.app.NotificationManager
+import android.content.Context
+import android.content.res.Resources.NotFoundException
+import android.os.Handler
+import android.os.SystemClock
+import com.squareup.leakcanary.core.R
+import java.util.UUID
+import leakcanary.AppWatcher
+import leakcanary.EventListener.Event.DumpingHeap
+import leakcanary.EventListener.Event.HeapDump
+import leakcanary.EventListener.Event.HeapDumpFailed
+import leakcanary.GcTrigger
+import leakcanary.KeyedWeakReference
+import leakcanary.LeakCanary.Config
+import leakcanary.ObjectWatcher
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.Nope
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.NotifyingNope
+import leakcanary.internal.InternalLeakCanary.onRetainInstanceListener
+import leakcanary.internal.NotificationReceiver.Action.CANCEL_NOTIFICATION
+import leakcanary.internal.NotificationReceiver.Action.DUMP_HEAP
+import leakcanary.internal.NotificationType.LEAKCANARY_LOW
+import leakcanary.internal.RetainInstanceEvent.CountChanged.BelowThreshold
+import leakcanary.internal.RetainInstanceEvent.CountChanged.DumpHappenedRecently
+import leakcanary.internal.RetainInstanceEvent.CountChanged.DumpingDisabled
+import leakcanary.internal.RetainInstanceEvent.NoMoreObjects
+import leakcanary.internal.friendly.measureDurationMillis
+import shark.AndroidResourceIdNames
+import shark.SharkLog
+
+internal class HeapDumpTrigger(
+  private val application: Application,
+  private val backgroundHandler: Handler,
+  private val objectWatcher: ObjectWatcher,
+  private val gcTrigger: GcTrigger,
+  private val configProvider: () -> Config
+) {
+
+  private val notificationManager
+    get() =
+      application.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+
+  private val applicationVisible
+    get() = applicationInvisibleAt == -1L
+
+  @Volatile
+  private var checkScheduledAt: Long = 0L
+
+  private var lastDisplayedRetainedObjectCount = 0
+
+  private var lastHeapDumpUptimeMillis = 0L
+
+  private val scheduleDismissRetainedCountNotification = {
+    dismissRetainedCountNotification()
+  }
+
+  private val scheduleDismissNoRetainedOnTapNotification = {
+    dismissNoRetainedOnTapNotification()
+  }
+
+  /**
+   * When the app becomes invisible, we don't dump the heap immediately. Instead we wait in case
+   * the app came back to the foreground, but also to wait for new leaks that typically occur on
+   * back press (activity destroy).
+   */
+  private val applicationInvisibleLessThanWatchPeriod: Boolean
+    get() {
+      val applicationInvisibleAt = applicationInvisibleAt
+      return applicationInvisibleAt != -1L && SystemClock.uptimeMillis() - applicationInvisibleAt < AppWatcher.retainedDelayMillis
+    }
+
+  @Volatile
+  private var applicationInvisibleAt = -1L
+
+  // Needs to be lazy because on Android 16, UUID.randomUUID().toString() will trigger a disk read
+  // violation by calling RandomBitsSupplier.getUnixDeviceRandom()
+  // Can't be lazy because this is a var.
+  private var currentEventUniqueId: String? = null
+
+  fun onApplicationVisibilityChanged(applicationVisible: Boolean) {
+    if (applicationVisible) {
+      applicationInvisibleAt = -1L
+    } else {
+      applicationInvisibleAt = SystemClock.uptimeMillis()
+      // Scheduling for after watchDuration so that any destroyed activity has time to become
+      // watch and be part of this analysis.
+      scheduleRetainedObjectCheck(
+        delayMillis = AppWatcher.retainedDelayMillis
+      )
+    }
+  }
+
+  private fun checkRetainedObjects() {
+    val iCanHasHeap = HeapDumpControl.iCanHasHeap()
+
+    val config = configProvider()
+
+    if (iCanHasHeap is Nope) {
+      if (iCanHasHeap is NotifyingNope) {
+        // Before notifying that we can't dump heap, let's check if we still have retained object.
+        var retainedReferenceCount = objectWatcher.retainedObjectCount
+
+        if (retainedReferenceCount > 0) {
+          gcTrigger.runGc()
+          retainedReferenceCount = objectWatcher.retainedObjectCount
+        }
+
+        val nopeReason = iCanHasHeap.reason()
+        val wouldDump = !checkRetainedCount(
+          retainedReferenceCount, config.retainedVisibleThreshold, nopeReason
+        )
+
+        if (wouldDump) {
+          val uppercaseReason = nopeReason[0].toUpperCase() + nopeReason.substring(1)
+          onRetainInstanceListener.onEvent(DumpingDisabled(uppercaseReason))
+          showRetainedCountNotification(
+            objectCount = retainedReferenceCount,
+            contentText = uppercaseReason
+          )
+        }
+      } else {
+        SharkLog.d {
+          application.getString(
+            R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()
+          )
+        }
+      }
+      return
+    }
+
+    var retainedReferenceCount = objectWatcher.retainedObjectCount
+
+    if (retainedReferenceCount > 0) {
+      gcTrigger.runGc()
+      retainedReferenceCount = objectWatcher.retainedObjectCount
+    }
+
+    if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return
+
+    val now = SystemClock.uptimeMillis()
+    val elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis
+    if (elapsedSinceLastDumpMillis < WAIT_BETWEEN_HEAP_DUMPS_MILLIS) {
+      onRetainInstanceListener.onEvent(DumpHappenedRecently)
+      showRetainedCountNotification(
+        objectCount = retainedReferenceCount,
+        contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)
+      )
+      scheduleRetainedObjectCheck(
+        delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis
+      )
+      return
+    }
+
+    dismissRetainedCountNotification()
+    val visibility = if (applicationVisible) "visible" else "not visible"
+    dumpHeap(
+      retainedReferenceCount = retainedReferenceCount,
+      retry = true,
+      reason = "$retainedReferenceCount retained objects, app is $visibility"
+    )
+  }
+
+  private fun dumpHeap(
+    retainedReferenceCount: Int,
+    retry: Boolean,
+    reason: String
+  ) {
+    val directoryProvider =
+      InternalLeakCanary.createLeakDirectoryProvider(InternalLeakCanary.application)
+    val heapDumpFile = directoryProvider.newHeapDumpFile()
+
+    val durationMillis: Long
+    if (currentEventUniqueId == null) {
+      currentEventUniqueId = UUID.randomUUID().toString()
+    }
+    try {
+      InternalLeakCanary.sendEvent(DumpingHeap(currentEventUniqueId!!))
+      if (heapDumpFile == null) {
+        throw RuntimeException("Could not create heap dump file")
+      }
+      saveResourceIdNamesToMemory()
+      val heapDumpUptimeMillis = SystemClock.uptimeMillis()
+      KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis
+      durationMillis = measureDurationMillis {
+        configProvider().heapDumper.dumpHeap(heapDumpFile)
+      }
+      if (heapDumpFile.length() == 0L) {
+        throw RuntimeException("Dumped heap file is 0 byte length")
+      }
+      lastDisplayedRetainedObjectCount = 0
+      lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()
+      objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
+      currentEventUniqueId = UUID.randomUUID().toString()
+      InternalLeakCanary.sendEvent(HeapDump(currentEventUniqueId!!, heapDumpFile, durationMillis, reason))
+    } catch (throwable: Throwable) {
+      InternalLeakCanary.sendEvent(HeapDumpFailed(currentEventUniqueId!!, throwable, retry))
+      if (retry) {
+        scheduleRetainedObjectCheck(
+          delayMillis = WAIT_AFTER_DUMP_FAILED_MILLIS
+        )
+      }
+      showRetainedCountNotification(
+        objectCount = retainedReferenceCount,
+        contentText = application.getString(
+          R.string.leak_canary_notification_retained_dump_failed
+        )
+      )
+      return
+    }
+  }
+
+  /**
+   * Stores in memory the mapping of resource id ints to their corresponding name, so that the heap
+   * analysis can label views with their resource id names.
+   */
+  private fun saveResourceIdNamesToMemory() {
+    val resources = application.resources
+    AndroidResourceIdNames.saveToMemory(
+      getResourceTypeName = { id ->
+        try {
+          resources.getResourceTypeName(id)
+        } catch (e: NotFoundException) {
+          null
+        }
+      },
+      getResourceEntryName = { id ->
+        try {
+          resources.getResourceEntryName(id)
+        } catch (e: NotFoundException) {
+          null
+        }
+      })
+  }
+
+  fun onDumpHeapReceived(forceDump: Boolean) {
+    backgroundHandler.post {
+      dismissNoRetainedOnTapNotification()
+      gcTrigger.runGc()
+      val retainedReferenceCount = objectWatcher.retainedObjectCount
+      if (!forceDump && retainedReferenceCount == 0) {
+        SharkLog.d { "Ignoring user request to dump heap: no retained objects remaining after GC" }
+        @Suppress("DEPRECATION")
+        val builder = Notification.Builder(application)
+          .setContentTitle(
+            application.getString(R.string.leak_canary_notification_no_retained_object_title)
+          )
+          .setContentText(
+            application.getString(
+              R.string.leak_canary_notification_no_retained_object_content
+            )
+          )
+          .setAutoCancel(true)
+          .setContentIntent(NotificationReceiver.pendingIntent(application, CANCEL_NOTIFICATION))
+        val notification =
+          Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
+        notificationManager.notify(
+          R.id.leak_canary_notification_no_retained_object_on_tap, notification
+        )
+        backgroundHandler.postDelayed(
+          scheduleDismissNoRetainedOnTapNotification,
+          DISMISS_NO_RETAINED_OBJECT_NOTIFICATION_MILLIS
+        )
+        lastDisplayedRetainedObjectCount = 0
+        return@post
+      }
+
+      SharkLog.d { "Dumping the heap because user requested it" }
+      dumpHeap(retainedReferenceCount, retry = false, "user request")
+    }
+  }
+
+  private fun checkRetainedCount(
+    retainedKeysCount: Int,
+    retainedVisibleThreshold: Int,
+    nopeReason: String? = null
+  ): Boolean {
+    val countChanged = lastDisplayedRetainedObjectCount != retainedKeysCount
+    lastDisplayedRetainedObjectCount = retainedKeysCount
+    if (retainedKeysCount == 0) {
+      if (countChanged) {
+        SharkLog.d { "All retained objects have been garbage collected" }
+        onRetainInstanceListener.onEvent(NoMoreObjects)
+        showNoMoreRetainedObjectNotification()
+      }
+      return true
+    }
+
+    val applicationVisible = applicationVisible
+    val applicationInvisibleLessThanWatchPeriod = applicationInvisibleLessThanWatchPeriod
+
+    if (countChanged) {
+      val whatsNext = if (applicationVisible) {
+        if (retainedKeysCount < retainedVisibleThreshold) {
+          "not dumping heap yet (app is visible & < $retainedVisibleThreshold threshold)"
+        } else {
+          if (nopeReason != null) {
+            "would dump heap now (app is visible & >=$retainedVisibleThreshold threshold) but $nopeReason"
+          } else {
+            "dumping heap now (app is visible & >=$retainedVisibleThreshold threshold)"
+          }
+        }
+      } else if (applicationInvisibleLessThanWatchPeriod) {
+        val wait =
+          AppWatcher.retainedDelayMillis - (SystemClock.uptimeMillis() - applicationInvisibleAt)
+        if (nopeReason != null) {
+          "would dump heap in $wait ms (app just became invisible) but $nopeReason"
+        } else {
+          "dumping heap in $wait ms (app just became invisible)"
+        }
+      } else {
+        if (nopeReason != null) {
+          "would dump heap now (app is invisible) but $nopeReason"
+        } else {
+          "dumping heap now (app is invisible)"
+        }
+      }
+
+      SharkLog.d {
+        val s = if (retainedKeysCount > 1) "s" else ""
+        "Found $retainedKeysCount object$s retained, $whatsNext"
+      }
+    }
+
+    if (retainedKeysCount < retainedVisibleThreshold) {
+      if (applicationVisible || applicationInvisibleLessThanWatchPeriod) {
+        if (countChanged) {
+          onRetainInstanceListener.onEvent(BelowThreshold(retainedKeysCount))
+        }
+        showRetainedCountNotification(
+          objectCount = retainedKeysCount,
+          contentText = application.getString(
+            R.string.leak_canary_notification_retained_visible, retainedVisibleThreshold
+          )
+        )
+        scheduleRetainedObjectCheck(
+          delayMillis = WAIT_FOR_OBJECT_THRESHOLD_MILLIS
+        )
+        return true
+      }
+    }
+    return false
+  }
+
+  fun scheduleRetainedObjectCheck(
+    delayMillis: Long = 0L
+  ) {
+    val checkCurrentlyScheduledAt = checkScheduledAt
+    if (checkCurrentlyScheduledAt > 0) {
+      return
+    }
+    checkScheduledAt = SystemClock.uptimeMillis() + delayMillis
+    backgroundHandler.postDelayed({
+      checkScheduledAt = 0
+      checkRetainedObjects()
+    }, delayMillis)
+  }
+
+  private fun showNoMoreRetainedObjectNotification() {
+    backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
+    if (!Notifications.canShowNotification) {
+      return
+    }
+    val builder = Notification.Builder(application)
+      .setContentTitle(
+        application.getString(R.string.leak_canary_notification_no_retained_object_title)
+      )
+      .setContentText(
+        application.getString(
+          R.string.leak_canary_notification_no_retained_object_content
+        )
+      )
+      .setAutoCancel(true)
+      .setContentIntent(NotificationReceiver.pendingIntent(application, CANCEL_NOTIFICATION))
+    val notification =
+      Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
+    notificationManager.notify(R.id.leak_canary_notification_retained_objects, notification)
+    backgroundHandler.postDelayed(
+      scheduleDismissRetainedCountNotification, DISMISS_NO_RETAINED_OBJECT_NOTIFICATION_MILLIS
+    )
+  }
+
+  private fun showRetainedCountNotification(
+    objectCount: Int,
+    contentText: String
+  ) {
+    backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
+    if (!Notifications.canShowNotification) {
+      return
+    }
+    @Suppress("DEPRECATION")
+    val builder = Notification.Builder(application)
+      .setContentTitle(
+        application.getString(R.string.leak_canary_notification_retained_title, objectCount)
+      )
+      .setContentText(contentText)
+      .setAutoCancel(true)
+      .setContentIntent(NotificationReceiver.pendingIntent(application, DUMP_HEAP))
+    val notification =
+      Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
+    notificationManager.notify(R.id.leak_canary_notification_retained_objects, notification)
+  }
+
+  private fun dismissRetainedCountNotification() {
+    backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
+    notificationManager.cancel(R.id.leak_canary_notification_retained_objects)
+  }
+
+  private fun dismissNoRetainedOnTapNotification() {
+    backgroundHandler.removeCallbacks(scheduleDismissNoRetainedOnTapNotification)
+    notificationManager.cancel(R.id.leak_canary_notification_no_retained_object_on_tap)
+  }
+
+  companion object {
+    internal const val WAIT_AFTER_DUMP_FAILED_MILLIS = 5_000L
+    private const val WAIT_FOR_OBJECT_THRESHOLD_MILLIS = 2_000L
+    private const val DISMISS_NO_RETAINED_OBJECT_NOTIFICATION_MILLIS = 30_000L
+    private const val WAIT_BETWEEN_HEAP_DUMPS_MILLIS = 60_000L
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
new file mode 100644
index 00000000..a3dbb55d
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -0,0 +1,342 @@
+package leakcanary.internal
+
+import android.app.Activity
+import android.app.Application
+import android.app.Application.ActivityLifecycleCallbacks
+import android.app.UiModeManager
+import android.content.ComponentName
+import android.content.Context
+import android.content.Context.UI_MODE_SERVICE
+import android.content.Intent
+import android.content.pm.ApplicationInfo
+import android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED
+import android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED
+import android.content.pm.PackageManager.DONT_KILL_APP
+import android.content.pm.ShortcutInfo.Builder
+import android.content.pm.ShortcutManager
+import android.content.res.Configuration
+import android.graphics.drawable.Icon
+import android.os.Build.VERSION
+import android.os.Build.VERSION_CODES
+import android.os.Handler
+import android.os.HandlerThread
+import com.squareup.leakcanary.core.BuildConfig
+import com.squareup.leakcanary.core.R
+import leakcanary.AppWatcher
+import leakcanary.EventListener.Event
+import leakcanary.GcTrigger
+import leakcanary.LeakCanary
+import leakcanary.OnObjectRetainedListener
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.Nope
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.Yup
+import leakcanary.internal.InternalLeakCanary.FormFactor.MOBILE
+import leakcanary.internal.InternalLeakCanary.FormFactor.TV
+import leakcanary.internal.InternalLeakCanary.FormFactor.WATCH
+import leakcanary.internal.friendly.mainHandler
+import leakcanary.internal.friendly.noOpDelegate
+import leakcanary.internal.tv.TvOnRetainInstanceListener
+import shark.SharkLog
+
+internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedListener {
+
+  private const val DYNAMIC_SHORTCUT_ID = "com.squareup.leakcanary.dynamic_shortcut"
+
+  private lateinit var heapDumpTrigger: HeapDumpTrigger
+
+  // You're wrong https://discuss.kotlinlang.org/t/object-or-top-level-property-name-warning/6621/7
+  @Suppress("ObjectPropertyName")
+  private var _application: Application? = null
+
+  val application: Application
+    get() {
+      check(_application != null) {
+        "LeakCanary not installed, see AppWatcher.manualInstall()"
+      }
+      return _application!!
+    }
+
+  // BuildConfig.LIBRARY_VERSION is stripped so this static var is how we keep it around to find
+  // it later when parsing the heap dump.
+  @Suppress("unused")
+  @JvmStatic
+  private var version = BuildConfig.LIBRARY_VERSION
+
+  @Volatile
+  var applicationVisible = false
+    private set
+
+  private val isDebuggableBuild by lazy {
+    (application.applicationInfo.flags and ApplicationInfo.FLAG_DEBUGGABLE) != 0
+  }
+
+  fun createLeakDirectoryProvider(context: Context): LeakDirectoryProvider {
+    val appContext = context.applicationContext
+    return LeakDirectoryProvider(appContext, {
+      LeakCanary.config.maxStoredHeapDumps
+    }, {
+      LeakCanary.config.requestWriteExternalStoragePermission
+    })
+  }
+
+  internal enum class FormFactor {
+    MOBILE,
+    TV,
+    WATCH,
+  }
+
+  val formFactor by lazy {
+    return@lazy when ((application.getSystemService(UI_MODE_SERVICE) as UiModeManager).currentModeType) {
+      Configuration.UI_MODE_TYPE_TELEVISION -> TV
+      Configuration.UI_MODE_TYPE_WATCH -> WATCH
+      else -> MOBILE
+    }
+  }
+
+  val isInstantApp by lazy {
+    VERSION.SDK_INT >= VERSION_CODES.O && application.packageManager.isInstantApp
+  }
+
+  val onRetainInstanceListener by lazy {
+    when (formFactor) {
+      TV -> TvOnRetainInstanceListener(application)
+      else -> DefaultOnRetainInstanceListener()
+    }
+  }
+
+  var resumedActivity: Activity? = null
+
+  private val heapDumpPrefs by lazy {
+    application.getSharedPreferences("LeakCanaryHeapDumpPrefs", Context.MODE_PRIVATE)
+  }
+
+  internal var dumpEnabledInAboutScreen: Boolean
+    get() {
+      return heapDumpPrefs
+        .getBoolean("AboutScreenDumpEnabled", true)
+    }
+    set(value) {
+      heapDumpPrefs
+        .edit()
+        .putBoolean("AboutScreenDumpEnabled", value)
+        .apply()
+    }
+
+  override fun invoke(application: Application) {
+    _application = application
+
+    checkRunningInDebuggableBuild()
+
+    AppWatcher.objectWatcher.addOnObjectRetainedListener(this)
+
+    val gcTrigger = GcTrigger.Default
+
+    val configProvider = { LeakCanary.config }
+
+    val handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)
+    handlerThread.start()
+    val backgroundHandler = Handler(handlerThread.looper)
+
+    heapDumpTrigger = HeapDumpTrigger(
+      application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger,
+      configProvider
+    )
+    application.registerVisibilityListener { applicationVisible ->
+      this.applicationVisible = applicationVisible
+      heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)
+    }
+    registerResumedActivityListener(application)
+    addDynamicShortcut(application)
+
+    // We post so that the log happens after Application.onCreate()
+    mainHandler.post {
+      // https://github.com/square/leakcanary/issues/1981
+      // We post to a background handler because HeapDumpControl.iCanHasHeap() checks a shared pref
+      // which blocks until loaded and that creates a StrictMode violation.
+      backgroundHandler.post {
+        SharkLog.d {
+          when (val iCanHasHeap = HeapDumpControl.iCanHasHeap()) {
+            is Yup -> application.getString(R.string.leak_canary_heap_dump_enabled_text)
+            is Nope -> application.getString(
+              R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()
+            )
+          }
+        }
+      }
+    }
+  }
+
+  private fun checkRunningInDebuggableBuild() {
+    if (isDebuggableBuild) {
+      return
+    }
+
+    if (!application.resources.getBoolean(R.bool.leak_canary_allow_in_non_debuggable_build)) {
+      throw Error(
+        """
+        LeakCanary in non-debuggable build
+
+        LeakCanary should only be used in debug builds, but this APK is not debuggable.
+        Please follow the instructions on the "Getting started" page to only include LeakCanary in
+        debug builds: https://square.github.io/leakcanary/getting_started/
+
+        If you're sure you want to include LeakCanary in a non-debuggable build, follow the
+        instructions here: https://square.github.io/leakcanary/recipes/#leakcanary-in-release-builds
+      """.trimIndent()
+      )
+    }
+  }
+
+  private fun registerResumedActivityListener(application: Application) {
+    application.registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacks by noOpDelegate() {
+      override fun onActivityResumed(activity: Activity) {
+        resumedActivity = activity
+      }
+
+      override fun onActivityPaused(activity: Activity) {
+        if (resumedActivity === activity) {
+          resumedActivity = null
+        }
+      }
+    })
+  }
+
+  @Suppress("ReturnCount")
+  private fun addDynamicShortcut(application: Application) {
+    if (VERSION.SDK_INT < VERSION_CODES.N_MR1) {
+      return
+    }
+    if (!application.resources.getBoolean(R.bool.leak_canary_add_dynamic_shortcut)) {
+      return
+    }
+    if (isInstantApp) {
+      // Instant Apps don't have access to ShortcutManager
+      return
+    }
+    val shortcutManager = application.getSystemService(ShortcutManager::class.java)
+    if (shortcutManager == null) {
+      // https://github.com/square/leakcanary/issues/2430
+      // ShortcutManager null on Android TV
+      return
+    }
+    val dynamicShortcuts = shortcutManager.dynamicShortcuts
+
+    val shortcutInstalled =
+      dynamicShortcuts.any { shortcut -> shortcut.id == DYNAMIC_SHORTCUT_ID }
+
+    if (shortcutInstalled) {
+      return
+    }
+
+    val mainIntent = Intent(Intent.ACTION_MAIN, null)
+    mainIntent.addCategory(Intent.CATEGORY_LAUNCHER)
+    mainIntent.setPackage(application.packageName)
+    val activities = application.packageManager.queryIntentActivities(mainIntent, 0)
+      .filter {
+        it.activityInfo.name != "leakcanary.internal.activity.LeakLauncherActivity"
+      }
+
+    if (activities.isEmpty()) {
+      return
+    }
+
+    val firstMainActivity = activities.first()
+      .activityInfo
+
+    // Displayed on long tap on app icon
+    val longLabel: String
+    // Label when dropping shortcut to launcher
+    val shortLabel: String
+
+    val leakActivityLabel = application.getString(R.string.leak_canary_shortcut_label)
+
+    if (activities.isEmpty()) {
+      longLabel = leakActivityLabel
+      shortLabel = leakActivityLabel
+    } else {
+      val firstLauncherActivityLabel = if (firstMainActivity.labelRes != 0) {
+        application.getString(firstMainActivity.labelRes)
+      } else {
+        application.packageManager.getApplicationLabel(application.applicationInfo)
+      }
+      val fullLengthLabel = "$firstLauncherActivityLabel $leakActivityLabel"
+      // short label should be under 10 and long label under 25
+      if (fullLengthLabel.length > 10) {
+        if (fullLengthLabel.length <= 25) {
+          longLabel = fullLengthLabel
+          shortLabel = leakActivityLabel
+        } else {
+          longLabel = leakActivityLabel
+          shortLabel = leakActivityLabel
+        }
+      } else {
+        longLabel = fullLengthLabel
+        shortLabel = fullLengthLabel
+      }
+    }
+
+    val componentName = ComponentName(firstMainActivity.packageName, firstMainActivity.name)
+
+    val shortcutCount = dynamicShortcuts.count { shortcutInfo ->
+      shortcutInfo.activity == componentName
+    } + shortcutManager.manifestShortcuts.count { shortcutInfo ->
+      shortcutInfo.activity == componentName
+    }
+
+    if (shortcutCount >= shortcutManager.maxShortcutCountPerActivity) {
+      return
+    }
+
+    val intent = LeakCanary.newLeakDisplayActivityIntent()
+    intent.action = "Dummy Action because Android is stupid"
+    val shortcut = Builder(application, DYNAMIC_SHORTCUT_ID)
+      .setLongLabel(longLabel)
+      .setShortLabel(shortLabel)
+      .setActivity(componentName)
+      .setIcon(Icon.createWithResource(application, R.mipmap.leak_canary_icon))
+      .setIntent(intent)
+      .build()
+
+    try {
+      shortcutManager.addDynamicShortcuts(listOf(shortcut))
+    } catch (ignored: Throwable) {
+      SharkLog.d(ignored) {
+        "Could not add dynamic shortcut. " +
+          "shortcutCount=$shortcutCount, " +
+          "maxShortcutCountPerActivity=${shortcutManager.maxShortcutCountPerActivity}"
+      }
+    }
+  }
+
+  override fun onObjectRetained() = scheduleRetainedObjectCheck()
+
+  fun scheduleRetainedObjectCheck() {
+    if (this::heapDumpTrigger.isInitialized) {
+      heapDumpTrigger.scheduleRetainedObjectCheck()
+    }
+  }
+
+  fun onDumpHeapReceived(forceDump: Boolean) {
+    if (this::heapDumpTrigger.isInitialized) {
+      heapDumpTrigger.onDumpHeapReceived(forceDump)
+    }
+  }
+
+  fun setEnabledBlocking(
+    componentClassName: String,
+    enabled: Boolean
+  ) {
+    val component = ComponentName(application, componentClassName)
+    val newState =
+      if (enabled) COMPONENT_ENABLED_STATE_ENABLED else COMPONENT_ENABLED_STATE_DISABLED
+    // Blocks on IPC.
+    application.packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP)
+  }
+
+  fun sendEvent(event: Event) {
+    for(listener in LeakCanary.config.eventListeners) {
+      listener.onEvent(event)
+    }
+  }
+
+  private const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt
new file mode 100644
index 00000000..346f096d
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt
@@ -0,0 +1,590 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.content.ContentProvider
+import android.content.ContentValues
+import android.content.Context
+import android.content.Intent
+import android.content.pm.PackageManager
+import android.content.pm.ProviderInfo
+import android.database.Cursor
+import android.database.MatrixCursor
+import android.net.Uri
+import android.os.Build
+import android.os.Environment
+import android.os.ParcelFileDescriptor
+import android.os.StrictMode
+import android.provider.OpenableColumns
+import android.text.TextUtils
+import android.webkit.MimeTypeMap
+import java.io.File
+import java.io.FileNotFoundException
+import java.io.IOException
+import org.xmlpull.v1.XmlPullParser.END_DOCUMENT
+import org.xmlpull.v1.XmlPullParser.START_TAG
+import org.xmlpull.v1.XmlPullParserException
+
+/**
+ * Copy of androidx.core.content.FileProvider, converted to Kotlin.
+ */
+internal class LeakCanaryFileProvider : ContentProvider() {
+
+  private lateinit var mStrategy: PathStrategy
+
+  /**
+   * The default FileProvider implementation does not need to be initialized. If you want to
+   * override this method, you must provide your own subclass of FileProvider.
+   */
+  override fun onCreate(): Boolean = true
+
+  /**
+   * After the FileProvider is instantiated, this method is called to provide the system with
+   * information about the provider.
+   *
+   * @param context A [Context] for the current component.
+   * @param info A [ProviderInfo] for the new provider.
+   */
+  override fun attachInfo(
+    context: Context,
+    info: ProviderInfo
+  ) {
+    super.attachInfo(context, info)
+
+    // Sanity check our security
+    if (info.exported) {
+      throw SecurityException("Provider must not be exported")
+    }
+    if (!info.grantUriPermissions) {
+      throw SecurityException("Provider must grant uri permissions")
+    }
+
+    mStrategy = getPathStrategy(context, info.authority)!!
+  }
+
+  /**
+   * Use a content URI returned by
+   * [getUriForFile()][.getUriForFile] to get information about a file
+   * managed by the FileProvider.
+   * FileProvider reports the column names defined in [android.provider.OpenableColumns]:
+   *
+   *  * [android.provider.OpenableColumns.DISPLAY_NAME]
+   *  * [android.provider.OpenableColumns.SIZE]
+   *
+   * For more information, see
+   * [ ContentProvider.query()][ContentProvider.query].
+   *
+   * @param uri A content URI returned by [.getUriForFile].
+   * @param projectionArg The list of columns to put into the [Cursor]. If null all columns are
+   * included.
+   * @param selection Selection criteria to apply. If null then all data that matches the content
+   * URI is returned.
+   * @param selectionArgs An array of [java.lang.String], containing arguments to bind to
+   * the *selection* parameter. The *query* method scans *selection* from left to
+   * right and iterates through *selectionArgs*, replacing the current "?" character in
+   * *selection* with the value at the current position in *selectionArgs*. The
+   * values are bound to *selection* as [java.lang.String] values.
+   * @param sortOrder A [java.lang.String] containing the column name(s) on which to sort
+   * the resulting [Cursor].
+   * @return A [Cursor] containing the results of the query.
+   */
+  override fun query(
+    uri: Uri,
+    projectionArg: Array<String>?,
+    selection: String?,
+    selectionArgs: Array<String>?,
+    sortOrder: String?
+  ): Cursor {
+    val projection = projectionArg ?: COLUMNS
+    // ContentProvider has already checked granted permissions
+    val file = mStrategy.getFileForUri(uri)
+
+    var cols = arrayOfNulls<String>(projection.size)
+    var values = arrayOfNulls<Any>(projection.size)
+    var i = 0
+    for (col in projection) {
+      if (OpenableColumns.DISPLAY_NAME == col) {
+        cols[i] = OpenableColumns.DISPLAY_NAME
+        values[i++] = file.name
+      } else if (OpenableColumns.SIZE == col) {
+        cols[i] = OpenableColumns.SIZE
+        values[i++] = file.length()
+      }
+    }
+
+    cols = copyOfStringArray(cols, i)
+    values = copyOfAnyArray(values, i)
+
+    val cursor = MatrixCursor(cols, 1)
+    cursor.addRow(values)
+    return cursor
+  }
+
+  /**
+   * Returns the MIME type of a content URI returned by
+   * [getUriForFile()][.getUriForFile].
+   *
+   * @param uri A content URI returned by
+   * [getUriForFile()][.getUriForFile].
+   * @return If the associated file has an extension, the MIME type associated with that
+   * extension; otherwise `application/octet-stream`.
+   */
+  override fun getType(uri: Uri): String {
+    // ContentProvider has already checked granted permissions
+    val file = mStrategy.getFileForUri(uri)
+
+    val lastDot = file.name.lastIndexOf('.')
+    if (lastDot >= 0) {
+      val extension = file.name.substring(lastDot + 1)
+      val mime = MimeTypeMap.getSingleton()
+        .getMimeTypeFromExtension(extension)
+      if (mime != null) {
+        return mime
+      }
+    }
+
+    return "application/octet-stream"
+  }
+
+  /**
+   * By default, this method throws an [java.lang.UnsupportedOperationException]. You must
+   * subclass FileProvider if you want to provide different functionality.
+   */
+  override fun insert(
+    uri: Uri,
+    values: ContentValues?
+  ): Uri? {
+    throw UnsupportedOperationException("No external inserts")
+  }
+
+  /**
+   * By default, this method throws an [java.lang.UnsupportedOperationException]. You must
+   * subclass FileProvider if you want to provide different functionality.
+   */
+  override fun update(
+    uri: Uri,
+    values: ContentValues?,
+    selection: String?,
+    selectionArgs: Array<String>?
+  ): Int {
+    throw UnsupportedOperationException("No external updates")
+  }
+
+  /**
+   * Deletes the file associated with the specified content URI, as
+   * returned by [getUriForFile()][.getUriForFile]. Notice that this
+   * method does **not** throw an [java.io.IOException]; you must check its return value.
+   *
+   * @param uri A content URI for a file, as returned by
+   * [getUriForFile()][.getUriForFile].
+   * @param selection Ignored. Set to `null`.
+   * @param selectionArgs Ignored. Set to `null`.
+   * @return 1 if the delete succeeds; otherwise, 0.
+   */
+  override fun delete(
+    uri: Uri,
+    selection: String?,
+    selectionArgs: Array<String>?
+  ): Int {
+    // ContentProvider has already checked granted permissions
+    val file = mStrategy.getFileForUri(uri)
+    return if (file.delete()) 1 else 0
+  }
+
+  /**
+   * By default, FileProvider automatically returns the
+   * [ParcelFileDescriptor] for a file associated with a `content://`
+   * [Uri]. To get the [ParcelFileDescriptor], call
+   * [ ContentResolver.openFileDescriptor][android.content.ContentResolver.openFileDescriptor].
+   *
+   * To override this method, you must provide your own subclass of FileProvider.
+   *
+   * @param uri A content URI associated with a file, as returned by
+   * [getUriForFile()][.getUriForFile].
+   * @param mode Access mode for the file. May be "r" for read-only access, "rw" for read and
+   * write access, or "rwt" for read and write access that truncates any existing file.
+   * @return A new [ParcelFileDescriptor] with which you can access the file.
+   */
+  @Throws(FileNotFoundException::class)
+  override fun openFile(
+    uri: Uri,
+    mode: String
+  ): ParcelFileDescriptor? {
+    // ContentProvider has already checked granted permissions
+    val file = mStrategy.getFileForUri(uri)
+    val fileMode = modeToMode(mode)
+    return ParcelFileDescriptor.open(file, fileMode)
+  }
+
+  /**
+   * Strategy for mapping between [File] and [Uri].
+   *
+   *
+   * Strategies must be symmetric so that mapping a [File] to a
+   * [Uri] and then back to a [File] points at the original
+   * target.
+   *
+   *
+   * Strategies must remain consistent across app launches, and not rely on
+   * dynamic state. This ensures that any generated [Uri] can still be
+   * resolved if your process is killed and later restarted.
+   *
+   * @see SimplePathStrategy
+   */
+  internal interface PathStrategy {
+    /**
+     * Return a [Uri] that represents the given [File].
+     */
+    fun getUriForFile(file: File): Uri
+
+    /**
+     * Return a [File] that represents the given [Uri].
+     */
+    fun getFileForUri(uri: Uri): File
+  }
+
+  /**
+   * Strategy that provides access to files living under a narrow allowlist of
+   * filesystem roots. It will throw [SecurityException] if callers try
+   * accessing files outside the configured roots.
+   *
+   *
+   * For example, if configured with
+   * `addRoot("myfiles", context.getFilesDir())`, then
+   * `context.getFileStreamPath("foo.txt")` would map to
+   * `content://myauthority/myfiles/foo.txt`.
+   */
+  internal class SimplePathStrategy(private val mAuthority: String) : PathStrategy {
+    private val mRoots = HashMap<String, File>()
+
+    /**
+     * Add a mapping from a name to a filesystem root. The provider only offers
+     * access to files that live under configured roots.
+     */
+    fun addRoot(
+      name: String,
+      root: File
+    ) {
+
+      if (TextUtils.isEmpty(name)) {
+        throw IllegalArgumentException("Name must not be empty")
+      }
+
+      mRoots[name] = try {
+        // Resolve to canonical path to keep path checking fast
+        root.canonicalFile
+      } catch (e: IOException) {
+        throw IllegalArgumentException(
+          "Failed to resolve canonical path for $root", e
+        )
+      }
+    }
+
+    override fun getUriForFile(file: File): Uri {
+      var path: String
+      try {
+        path = file.canonicalPath
+      } catch (e: IOException) {
+        throw IllegalArgumentException("Failed to resolve canonical path for $file")
+      }
+
+      // Find the most-specific root path
+      var mostSpecific: MutableMap.MutableEntry<String, File>? = null
+      for (root in mRoots.entries) {
+        val rootPath = root.value.path
+        if (path.startsWith(
+            rootPath
+          ) && (mostSpecific == null || rootPath.length > mostSpecific.value.path.length)
+        ) {
+          mostSpecific = root
+        }
+      }
+
+      if (mostSpecific == null) {
+        throw IllegalArgumentException(
+          "Failed to find configured root that contains $path"
+        )
+      }
+
+      // Start at first char of path under root
+      val rootPath = mostSpecific.value.path
+      val startIndex = if (rootPath.endsWith("/")) rootPath.length else rootPath.length + 1
+      path = path.substring(startIndex)
+
+      // Encode the tag and path separately
+      path = Uri.encode(mostSpecific.key) + '/'.toString() + Uri.encode(path, "/")
+      return Uri.Builder()
+        .scheme("content")
+        .authority(mAuthority)
+        .encodedPath(path)
+        .build()
+    }
+
+    override fun getFileForUri(uri: Uri): File {
+      var path = uri.encodedPath!!
+
+      val splitIndex = path.indexOf('/', 1)
+      val tag = Uri.decode(path.substring(1, splitIndex))
+      path = Uri.decode(path.substring(splitIndex + 1))
+
+      val root = mRoots[tag]
+        ?: throw IllegalArgumentException("Unable to find configured root for $uri")
+
+      var file = File(root, path)
+      try {
+        file = file.canonicalFile
+      } catch (e: IOException) {
+        throw IllegalArgumentException("Failed to resolve canonical path for $file")
+      }
+
+      if (!file.path.startsWith(root.path)) {
+        throw SecurityException("Resolved path jumped beyond configured root")
+      }
+
+      return file
+    }
+  }
+
+  companion object {
+    private val COLUMNS = arrayOf(OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE)
+
+    private const val META_DATA_FILE_PROVIDER_PATHS = "android.support.FILE_PROVIDER_PATHS"
+
+    private const val TAG_ROOT_PATH = "root-path"
+    private const val TAG_FILES_PATH = "files-path"
+    private const val TAG_CACHE_PATH = "cache-path"
+    private const val TAG_EXTERNAL = "external-path"
+    private const val TAG_EXTERNAL_FILES = "external-files-path"
+    private const val TAG_EXTERNAL_CACHE = "external-cache-path"
+    private const val TAG_EXTERNAL_MEDIA = "external-media-path"
+
+    private const val ATTR_NAME = "name"
+    private const val ATTR_PATH = "path"
+
+    private val DEVICE_ROOT = File("/")
+
+    private val sCache = HashMap<String, PathStrategy>()
+
+    /**
+     * Return a content URI for a given [File]. Specific temporary
+     * permissions for the content URI can be set with
+     * [Context.grantUriPermission], or added
+     * to an [Intent] by calling [setData()][Intent.setData] and then
+     * [setFlags()][Intent.setFlags]; in both cases, the applicable flags are
+     * [Intent.FLAG_GRANT_READ_URI_PERMISSION] and
+     * [Intent.FLAG_GRANT_WRITE_URI_PERMISSION]. A FileProvider can only return a
+     * `content` [Uri] for file paths defined in their `<paths>`
+     * meta-data element. See the Class Overview for more information.
+     *
+     * @param context A [Context] for the current component.
+     * @param authority The authority of a [FileProvider] defined in a
+     * `<provider>` element in your app's manifest.
+     * @param file A [File] pointing to the filename for which you want a
+     * `content` [Uri].
+     * @return A content URI for the file.
+     * @throws IllegalArgumentException When the given [File] is outside
+     * the paths supported by the provider.
+     */
+    fun getUriForFile(
+      context: Context,
+      authority: String,
+      file: File
+    ): Uri {
+      val strategy = getPathStrategy(context, authority)
+      return strategy!!.getUriForFile(file)
+    }
+
+    /**
+     * Return [PathStrategy] for given authority, either by parsing or
+     * returning from cache.
+     */
+    private fun getPathStrategy(
+      context: Context,
+      authority: String
+    ): PathStrategy? {
+      var strat: PathStrategy?
+      synchronized(sCache) {
+        strat = sCache[authority]
+        if (strat == null) {
+          // Minimal "fix" for https://github.com/square/leakcanary/issues/2202
+          try {
+            val previousPolicy = StrictMode.getThreadPolicy()
+            try {
+              StrictMode.setThreadPolicy(StrictMode.ThreadPolicy.Builder().build())
+              strat = parsePathStrategy(context, authority)
+            } finally {
+              StrictMode.setThreadPolicy(previousPolicy)
+            }
+          } catch (e: IOException) {
+            throw IllegalArgumentException(
+              "Failed to parse $META_DATA_FILE_PROVIDER_PATHS meta-data", e
+            )
+          } catch (e: XmlPullParserException) {
+            throw IllegalArgumentException(
+              "Failed to parse $META_DATA_FILE_PROVIDER_PATHS meta-data", e
+            )
+          }
+          sCache[authority] = strat!!
+        }
+      }
+      return strat
+    }
+
+    /**
+     * Parse and return [PathStrategy] for given authority as defined in
+     * [.META_DATA_FILE_PROVIDER_PATHS] `<meta-data>`.
+     *
+     * @see .getPathStrategy
+     */
+    @Throws(IOException::class, XmlPullParserException::class)
+    private fun parsePathStrategy(
+      context: Context,
+      authority: String
+    ): PathStrategy {
+      val strat = SimplePathStrategy(authority)
+
+      val info = context.packageManager
+        .resolveContentProvider(authority, PackageManager.GET_META_DATA)
+        ?: throw IllegalArgumentException(
+          "Couldn't find meta-data for provider with authority $authority"
+        )
+      val resourceParser = info.loadXmlMetaData(
+        context.packageManager, META_DATA_FILE_PROVIDER_PATHS
+      ) ?: throw IllegalArgumentException(
+        "Missing $META_DATA_FILE_PROVIDER_PATHS meta-data"
+      )
+
+      var type: Int
+      while (run {
+          type = resourceParser.next()
+          (type)
+        } != END_DOCUMENT) {
+        if (type == START_TAG) {
+          val tag = resourceParser.name
+
+          val name = resourceParser.getAttributeValue(null, ATTR_NAME)
+          val path = resourceParser.getAttributeValue(null, ATTR_PATH)
+
+          var target: File? = null
+          if (TAG_ROOT_PATH == tag) {
+            target = DEVICE_ROOT
+          } else if (TAG_FILES_PATH == tag) {
+            target = context.filesDir
+          } else if (TAG_CACHE_PATH == tag) {
+            target = context.cacheDir
+          } else if (TAG_EXTERNAL == tag) {
+            target = Environment.getExternalStorageDirectory()
+          } else if (TAG_EXTERNAL_FILES == tag) {
+            val externalFilesDirs = getExternalFilesDirs(context, null)
+            if (externalFilesDirs.isNotEmpty()) {
+              target = externalFilesDirs[0]
+            }
+          } else if (TAG_EXTERNAL_CACHE == tag) {
+            val externalCacheDirs = getExternalCacheDirs(context)
+            if (externalCacheDirs.isNotEmpty()) {
+              target = externalCacheDirs[0]
+            }
+          } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP && TAG_EXTERNAL_MEDIA == tag) {
+            val externalMediaDirs = context.externalMediaDirs
+            if (externalMediaDirs.isNotEmpty()) {
+              target = externalMediaDirs[0]
+            }
+          }
+
+          if (target != null) {
+            strat.addRoot(name, buildPath(target, path))
+          }
+        }
+      }
+
+      return strat
+    }
+
+    private fun getExternalFilesDirs(
+      context: Context,
+      type: String?
+    ): Array<File> {
+      return if (Build.VERSION.SDK_INT >= 19) {
+        context.getExternalFilesDirs(type)
+      } else {
+        arrayOf(context.getExternalFilesDir(type)!!)
+      }
+    }
+
+    private fun getExternalCacheDirs(context: Context): Array<File> {
+      return if (Build.VERSION.SDK_INT >= 19) {
+        context.externalCacheDirs
+      } else {
+        arrayOf(context.externalCacheDir!!)
+      }
+    }
+
+    /**
+     * Copied from ContentResolver.java
+     */
+    private fun modeToMode(mode: String): Int {
+      return when (mode) {
+        "r" -> ParcelFileDescriptor.MODE_READ_ONLY
+        "w", "wt" -> (
+          ParcelFileDescriptor.MODE_WRITE_ONLY
+            or ParcelFileDescriptor.MODE_CREATE
+            or ParcelFileDescriptor.MODE_TRUNCATE
+          )
+        "wa" -> (
+          ParcelFileDescriptor.MODE_WRITE_ONLY
+            or ParcelFileDescriptor.MODE_CREATE
+            or ParcelFileDescriptor.MODE_APPEND
+          )
+        "rw" -> ParcelFileDescriptor.MODE_READ_WRITE or ParcelFileDescriptor.MODE_CREATE
+        "rwt" -> (
+          ParcelFileDescriptor.MODE_READ_WRITE
+            or ParcelFileDescriptor.MODE_CREATE
+            or ParcelFileDescriptor.MODE_TRUNCATE
+          )
+        else -> throw IllegalArgumentException("Invalid mode: $mode")
+      }
+    }
+
+    private fun buildPath(
+      base: File,
+      vararg segments: String
+    ): File {
+      var cur = base
+      for (segment in segments) {
+        cur = File(cur, segment)
+      }
+      return cur
+    }
+
+    private fun copyOfStringArray(
+      original: Array<String?>,
+      newLength: Int
+    ): Array<String?> {
+      val result = arrayOfNulls<String>(newLength)
+      System.arraycopy(original, 0, result, 0, newLength)
+      return result
+    }
+
+    private fun copyOfAnyArray(
+      original: Array<Any?>,
+      newLength: Int
+    ): Array<Any?> {
+      val result = arrayOfNulls<Any>(newLength)
+      System.arraycopy(original, 0, result, 0, newLength)
+      return result
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanarySingleThreadFactory.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanarySingleThreadFactory.kt
new file mode 100644
index 00000000..a3c30910
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanarySingleThreadFactory.kt
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import java.util.concurrent.ThreadFactory
+
+/**
+ * This is intended to only be used with a single thread executor.
+ */
+internal class LeakCanarySingleThreadFactory(threadName: String) : ThreadFactory {
+
+  private val threadName: String = "LeakCanary-$threadName"
+
+  override fun newThread(runnable: Runnable): Thread {
+    return Thread(runnable, threadName)
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
new file mode 100644
index 00000000..057d0116
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.Manifest.permission.WRITE_EXTERNAL_STORAGE
+import android.annotation.TargetApi
+import android.content.Context
+import android.content.pm.PackageManager.PERMISSION_GRANTED
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.M
+import android.os.Environment
+import android.os.Environment.DIRECTORY_DOWNLOADS
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.NotificationType.LEAKCANARY_LOW
+import shark.SharkLog
+import java.io.File
+import java.io.FilenameFilter
+import java.text.SimpleDateFormat
+import java.util.ArrayList
+import java.util.Date
+import java.util.Locale
+
+/**
+ * Provides access to where heap dumps and analysis results will be stored.
+ */
+internal class LeakDirectoryProvider constructor(
+  context: Context,
+  private val maxStoredHeapDumps: () -> Int,
+  private val requestExternalStoragePermission: () -> Boolean
+) {
+  private val context: Context = context.applicationContext
+
+  fun newHeapDumpFile(): File? {
+    cleanupOldHeapDumps()
+
+    var storageDirectory = externalStorageDirectory()
+    if (!directoryWritableAfterMkdirs(storageDirectory)) {
+      if (!hasStoragePermission()) {
+        if (requestExternalStoragePermission()) {
+          SharkLog.d { "WRITE_EXTERNAL_STORAGE permission not granted, requesting" }
+          requestWritePermissionNotification()
+        } else {
+          SharkLog.d { "WRITE_EXTERNAL_STORAGE permission not granted, ignoring" }
+        }
+      } else {
+        val state = Environment.getExternalStorageState()
+        if (Environment.MEDIA_MOUNTED != state) {
+          SharkLog.d { "External storage not mounted, state: $state" }
+        } else {
+          SharkLog.d {
+            "Could not create heap dump directory in external storage: [${storageDirectory.absolutePath}]"
+          }
+        }
+      }
+      // Fallback to app storage.
+      storageDirectory = appStorageDirectory()
+      if (!directoryWritableAfterMkdirs(storageDirectory)) {
+        SharkLog.d {
+          "Could not create heap dump directory in app storage: [${storageDirectory.absolutePath}]"
+        }
+        return null
+      }
+    }
+
+    val fileName = SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US).format(Date())
+    return File(storageDirectory, fileName)
+  }
+
+  @TargetApi(M) fun hasStoragePermission(): Boolean {
+    if (SDK_INT < M) {
+      return true
+    }
+    // Once true, this won't change for the life of the process so we can cache it.
+    if (writeExternalStorageGranted) {
+      return true
+    }
+    writeExternalStorageGranted =
+      context.checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED
+    return writeExternalStorageGranted
+  }
+
+  fun requestWritePermissionNotification() {
+    if (permissionNotificationDisplayed || !Notifications.canShowNotification) {
+      return
+    }
+    permissionNotificationDisplayed = true
+
+    val pendingIntent =
+      RequestPermissionActivity.createPendingIntent(context, WRITE_EXTERNAL_STORAGE)
+    val contentTitle = context.getString(
+      R.string.leak_canary_permission_notification_title
+    )
+    val packageName = context.packageName
+    val contentText =
+      context.getString(R.string.leak_canary_permission_notification_text, packageName)
+
+    Notifications.showNotification(
+      context, contentTitle, contentText, pendingIntent,
+      R.id.leak_canary_notification_write_permission, LEAKCANARY_LOW
+    )
+  }
+
+  @Suppress("DEPRECATION")
+  private fun externalStorageDirectory(): File {
+    val downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)
+    return File(downloadsDirectory, "leakcanary-" + context.packageName)
+  }
+
+  private fun appStorageDirectory(): File {
+    val appFilesDirectory = context.cacheDir
+    return File(appFilesDirectory, "leakcanary")
+  }
+
+  private fun directoryWritableAfterMkdirs(directory: File): Boolean {
+    val success = directory.mkdirs()
+    return (success || directory.exists()) && directory.canWrite()
+  }
+
+  private fun cleanupOldHeapDumps() {
+    val hprofFiles = listWritableFiles { _, name ->
+      name.endsWith(
+        HPROF_SUFFIX
+      )
+    }
+    val maxStoredHeapDumps = maxStoredHeapDumps()
+    if (maxStoredHeapDumps < 1) {
+      throw IllegalArgumentException("maxStoredHeapDumps must be at least 1")
+    }
+
+    val filesToRemove = hprofFiles.size - maxStoredHeapDumps
+    if (filesToRemove > 0) {
+      SharkLog.d { "Removing $filesToRemove heap dumps" }
+      // Sort with oldest modified first.
+      hprofFiles.sortWith { lhs, rhs ->
+        java.lang.Long.valueOf(lhs.lastModified())
+          .compareTo(rhs.lastModified())
+      }
+      for (i in 0 until filesToRemove) {
+        val path = hprofFiles[i].absolutePath
+        val deleted = hprofFiles[i].delete()
+        if (deleted) {
+          filesDeletedTooOld += path
+        } else {
+          SharkLog.d { "Could not delete old hprof file ${hprofFiles[i].path}" }
+        }
+      }
+    }
+  }
+
+  private fun listWritableFiles(filter: FilenameFilter): MutableList<File> {
+    val files = ArrayList<File>()
+
+    val externalStorageDirectory = externalStorageDirectory()
+    if (externalStorageDirectory.exists() && externalStorageDirectory.canWrite()) {
+      val externalFiles = externalStorageDirectory.listFiles(filter)
+      if (externalFiles != null) {
+        files.addAll(externalFiles)
+      }
+    }
+
+    val appFiles = appStorageDirectory().listFiles(filter)
+    if (appFiles != null) {
+      files.addAll(appFiles)
+    }
+    return files
+  }
+
+  companion object {
+    @Volatile private var writeExternalStorageGranted: Boolean = false
+    @Volatile private var permissionNotificationDisplayed: Boolean = false
+
+    private val filesDeletedTooOld = mutableListOf<String>()
+    val filesDeletedRemoveLeak = mutableListOf<String>()
+
+    private const val HPROF_SUFFIX = ".hprof"
+
+    fun hprofDeleteReason(file: File): String {
+      val path = file.absolutePath
+      return when {
+        filesDeletedTooOld.contains(path) -> "older than all other hprof files"
+        filesDeletedRemoveLeak.contains(path) -> "leak manually removed"
+        else -> "unknown"
+      }
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationReceiver.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationReceiver.kt
new file mode 100644
index 00000000..d853d54b
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationReceiver.kt
@@ -0,0 +1,51 @@
+package leakcanary.internal
+
+import android.app.PendingIntent
+import android.content.BroadcastReceiver
+import android.content.Context
+import android.content.Intent
+import android.os.Build
+import leakcanary.internal.NotificationReceiver.Action.CANCEL_NOTIFICATION
+import leakcanary.internal.NotificationReceiver.Action.DUMP_HEAP
+import shark.SharkLog
+
+internal class NotificationReceiver : BroadcastReceiver() {
+
+  enum class Action {
+    DUMP_HEAP,
+    CANCEL_NOTIFICATION
+  }
+
+  override fun onReceive(
+    context: Context,
+    intent: Intent
+  ) {
+    when (intent.action) {
+      DUMP_HEAP.name -> {
+        InternalLeakCanary.onDumpHeapReceived(forceDump = false)
+      }
+      CANCEL_NOTIFICATION.name -> {
+        // Do nothing, the notification has auto cancel true.
+      }
+      else -> {
+        SharkLog.d { "NotificationReceiver received unknown intent action for $intent" }
+      }
+    }
+  }
+
+  companion object {
+    fun pendingIntent(
+      context: Context,
+      action: Action
+    ): PendingIntent {
+      val broadcastIntent = Intent(context, NotificationReceiver::class.java)
+      broadcastIntent.action = action.name
+      val flags = if (Build.VERSION.SDK_INT >= 23) {
+        PendingIntent.FLAG_IMMUTABLE
+      } else {
+        0
+      }
+      return PendingIntent.getBroadcast(context, 0, broadcastIntent, flags)
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
new file mode 100644
index 00000000..149e8822
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
@@ -0,0 +1,18 @@
+package leakcanary.internal
+
+import com.squareup.leakcanary.core.R
+
+internal enum class NotificationType(
+  val nameResId: Int,
+  val importance: Int
+) {
+  LEAKCANARY_LOW(
+    R.string.leak_canary_notification_channel_low, IMPORTANCE_LOW
+  ),
+  LEAKCANARY_MAX(
+    R.string.leak_canary_notification_channel_result, IMPORTANCE_MAX
+  );
+}
+
+private const val IMPORTANCE_LOW = 2
+private const val IMPORTANCE_MAX = 5
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
new file mode 100644
index 00000000..5a41a418
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.Manifest.permission.POST_NOTIFICATIONS
+import android.app.Notification
+import android.app.NotificationChannel
+import android.app.NotificationManager
+import android.app.PendingIntent
+import android.content.Context
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.JELLY_BEAN
+import android.os.Build.VERSION_CODES.O
+import com.squareup.leakcanary.core.R
+import leakcanary.LeakCanary
+import leakcanary.internal.InternalLeakCanary.FormFactor.MOBILE
+import shark.SharkLog
+
+internal object Notifications {
+
+  private var notificationPermissionRequested = false
+
+  // Instant apps cannot show background notifications
+  // See https://github.com/square/leakcanary/issues/1197
+  // TV devices can't show notifications.
+  // Watch devices: not sure, but probably not a good idea anyway?
+  val canShowNotification: Boolean
+    get() {
+      if (InternalLeakCanary.formFactor != MOBILE) {
+        return false
+      }
+      if (InternalLeakCanary.isInstantApp || !InternalLeakCanary.applicationVisible) {
+        return false
+      }
+      if (!LeakCanary.config.showNotifications) {
+        return false
+      }
+      if (SDK_INT >= 33) {
+        val application = InternalLeakCanary.application
+        if (application.applicationInfo.targetSdkVersion >= 33) {
+          val notificationManager =
+            application.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+          if (!notificationManager.areNotificationsEnabled()) {
+            if (notificationPermissionRequested) {
+              SharkLog.d { "Not showing notification: already requested missing POST_NOTIFICATIONS permission." }
+            } else {
+              SharkLog.d { "Not showing notification: requesting missing POST_NOTIFICATIONS permission." }
+              application.startActivity(
+                RequestPermissionActivity.createIntent(
+                  application,
+                  POST_NOTIFICATIONS
+                )
+              )
+              notificationPermissionRequested = true
+            }
+            return false
+          }
+          if (notificationManager.areNotificationsPaused()) {
+            SharkLog.d { "Not showing notification, notifications are paused." }
+            return false
+          }
+        }
+      }
+      return true
+    }
+
+  @Suppress("LongParameterList")
+  fun showNotification(
+    context: Context,
+    contentTitle: CharSequence,
+    contentText: CharSequence,
+    pendingIntent: PendingIntent?,
+    notificationId: Int,
+    type: NotificationType
+  ) {
+    if (!canShowNotification) {
+      return
+    }
+
+    val builder = if (SDK_INT >= O) {
+      Notification.Builder(context, type.name)
+    } else Notification.Builder(context)
+
+    builder
+      .setContentText(contentText)
+      .setContentTitle(contentTitle)
+      .setAutoCancel(true)
+      .setContentIntent(pendingIntent)
+
+    val notification =
+      buildNotification(context, builder, type)
+    val notificationManager =
+      context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+    notificationManager.notify(notificationId, notification)
+  }
+
+  fun buildNotification(
+    context: Context,
+    builder: Notification.Builder,
+    type: NotificationType
+  ): Notification {
+    builder.setSmallIcon(R.drawable.leak_canary_leak)
+      .setWhen(System.currentTimeMillis())
+
+    if (SDK_INT >= O) {
+      val notificationManager =
+        context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+      var notificationChannel: NotificationChannel? =
+        notificationManager.getNotificationChannel(type.name)
+      if (notificationChannel == null) {
+        val channelName = context.getString(type.nameResId)
+        notificationChannel =
+          NotificationChannel(type.name, channelName, type.importance)
+        notificationManager.createNotificationChannel(notificationChannel)
+      }
+      builder.setChannelId(type.name)
+      builder.setGroup(type.name)
+    }
+
+    return if (SDK_INT < JELLY_BEAN) {
+      @Suppress("DEPRECATION")
+      builder.notification
+    } else {
+      builder.build()
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/OnRetainInstanceListener.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/OnRetainInstanceListener.kt
new file mode 100644
index 00000000..f75e523e
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/OnRetainInstanceListener.kt
@@ -0,0 +1,27 @@
+package leakcanary.internal
+
+internal sealed class RetainInstanceEvent {
+  object NoMoreObjects : RetainInstanceEvent()
+  sealed class CountChanged : RetainInstanceEvent() {
+    class BelowThreshold(val retainedCount: Int) : RetainInstanceEvent()
+    class DumpingDisabled(val reason: String) : RetainInstanceEvent()
+    object DumpHappenedRecently : RetainInstanceEvent()
+  }
+}
+
+/**
+ * Called by LeakCanary when the number of retained instances updates .
+ */
+internal fun interface OnRetainInstanceListener {
+
+  /**
+   * Called when there's a change to the Retained Instances. See [RetainInstanceEvent] for
+   * possible events.
+   */
+  fun onEvent(event: RetainInstanceEvent)
+}
+
+internal class DefaultOnRetainInstanceListener : OnRetainInstanceListener {
+
+  override fun onEvent(event: RetainInstanceEvent) {}
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/RemoteHeapAnalyzerWorker.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/RemoteHeapAnalyzerWorker.kt
new file mode 100644
index 00000000..31223ccf
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/RemoteHeapAnalyzerWorker.kt
@@ -0,0 +1,42 @@
+package leakcanary.internal
+
+import android.content.Context
+import androidx.work.ForegroundInfo
+import androidx.work.WorkerParameters
+import androidx.work.impl.utils.futures.SettableFuture
+import androidx.work.multiprocess.RemoteListenableWorker
+import com.google.common.util.concurrent.ListenableFuture
+import leakcanary.BackgroundThreadHeapAnalyzer.heapAnalyzerThreadHandler
+import leakcanary.EventListener.Event.HeapDump
+import leakcanary.internal.HeapAnalyzerWorker.Companion.asEvent
+import leakcanary.internal.HeapAnalyzerWorker.Companion.heapAnalysisForegroundInfoAsync
+import shark.SharkLog
+
+internal class RemoteHeapAnalyzerWorker(appContext: Context, workerParams: WorkerParameters) :
+  RemoteListenableWorker(appContext, workerParams) {
+
+  override fun startRemoteWork(): ListenableFuture<Result> {
+    val heapDump = inputData.asEvent<HeapDump>()
+    val result = SettableFuture.create<Result>()
+    heapAnalyzerThreadHandler.post {
+      val doneEvent = AndroidDebugHeapAnalyzer.runAnalysisBlocking(heapDump, isCanceled = {
+        result.isCancelled
+      }) { progressEvent ->
+        if (!result.isCancelled) {
+          InternalLeakCanary.sendEvent(progressEvent)
+        }
+      }
+      if (result.isCancelled) {
+        SharkLog.d { "Remote heap analysis for ${heapDump.file} was canceled" }
+      } else {
+        InternalLeakCanary.sendEvent(doneEvent)
+        result.set(Result.success())
+      }
+    }
+    return result
+  }
+
+  override fun getForegroundInfoAsync(): ListenableFuture<ForegroundInfo> {
+    return applicationContext.heapAnalysisForegroundInfoAsync()
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/RequestPermissionActivity.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/RequestPermissionActivity.kt
new file mode 100644
index 00000000..74b47eef
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/RequestPermissionActivity.kt
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.annotation.TargetApi
+import android.app.Activity
+import android.app.PendingIntent
+import android.app.PendingIntent.FLAG_UPDATE_CURRENT
+import android.app.PendingIntent.FLAG_IMMUTABLE
+import android.content.Context
+import android.content.Intent
+import android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP
+import android.content.Intent.FLAG_ACTIVITY_NEW_TASK
+import android.content.pm.PackageManager.PERMISSION_GRANTED
+import android.os.Bundle
+import android.os.Build
+import android.widget.Toast
+import android.widget.Toast.LENGTH_LONG
+import com.squareup.leakcanary.core.R
+
+@TargetApi(Build.VERSION_CODES.M) //
+internal class RequestPermissionActivity : Activity() {
+
+  private val targetPermission: String
+    get() = intent.getStringExtra(TARGET_PERMISSION_EXTRA)!!
+
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+
+    if (savedInstanceState == null) {
+      if (hasTargetPermission()) {
+        finish()
+        return
+      }
+      val permissions = arrayOf(targetPermission)
+      requestPermissions(permissions, 42)
+    }
+  }
+
+  override fun onRequestPermissionsResult(
+    requestCode: Int,
+    permissions: Array<String>,
+    grantResults: IntArray
+  ) {
+    if (!hasTargetPermission()) {
+      Toast.makeText(application, R.string.leak_canary_permission_not_granted, LENGTH_LONG)
+        .show()
+    }
+    finish()
+  }
+
+  override fun finish() {
+    // Reset the animation to avoid flickering.
+    overridePendingTransition(0, 0)
+    super.finish()
+  }
+
+  private fun hasTargetPermission(): Boolean {
+    return checkSelfPermission(targetPermission) == PERMISSION_GRANTED
+  }
+
+  companion object {
+    private const val TARGET_PERMISSION_EXTRA = "targetPermission"
+
+    fun createIntent(context: Context, permission: String): Intent {
+      return Intent(context, RequestPermissionActivity::class.java).apply {
+        flags = FLAG_ACTIVITY_NEW_TASK or FLAG_ACTIVITY_CLEAR_TOP
+        putExtra(TARGET_PERMISSION_EXTRA, permission)
+      }
+    }
+
+    fun createPendingIntent(context: Context, permission: String): PendingIntent {
+      val intent = createIntent(context, permission)
+      val flags = if (Build.VERSION.SDK_INT >= 23) {
+        FLAG_UPDATE_CURRENT or FLAG_IMMUTABLE
+      } else {
+        FLAG_UPDATE_CURRENT
+      }
+      return PendingIntent.getActivity(context, 1, intent, flags)
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/RowElementLayout.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/RowElementLayout.kt
new file mode 100644
index 00000000..78eebe58
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/RowElementLayout.kt
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.content.Context
+import android.util.AttributeSet
+import android.view.View
+import android.view.ViewGroup
+import com.squareup.leakcanary.core.R
+import kotlin.math.max
+
+internal class RowElementLayout(
+  context: Context,
+  attrs: AttributeSet
+) : ViewGroup(context, attrs) {
+
+  private val connectorWidth: Int
+  private val rowMargins: Int
+  private val moreSize: Int
+  private val minHeight: Int
+  private val titleMarginTop: Int
+  private val moreMarginTop: Int
+
+  private var connector: View? = null
+  private var title: View? = null
+
+  init {
+    val resources = resources
+    connectorWidth = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_width)
+    rowMargins = resources.getDimensionPixelSize(R.dimen.leak_canary_row_margins)
+    moreSize = resources.getDimensionPixelSize(R.dimen.leak_canary_more_size)
+    minHeight = resources.getDimensionPixelSize(R.dimen.leak_canary_row_min)
+    titleMarginTop = resources.getDimensionPixelSize(R.dimen.leak_canary_row_title_margin_top)
+    moreMarginTop = resources.getDimensionPixelSize(R.dimen.leak_canary_more_margin_top)
+  }
+
+  override fun onFinishInflate() {
+    super.onFinishInflate()
+    connector = findViewById(R.id.leak_canary_row_connector)
+    title = findViewById(R.id.leak_canary_row_title)
+  }
+
+  override fun onMeasure(
+    widthMeasureSpec: Int,
+    heightMeasureSpec: Int
+  ) {
+    val availableWidth = MeasureSpec.getSize(widthMeasureSpec)
+    val titleWidth = availableWidth - connectorWidth - moreSize - 4 * rowMargins
+    val titleWidthSpec = MeasureSpec.makeMeasureSpec(titleWidth, MeasureSpec.AT_MOST)
+    val titleHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED)
+    title!!.measure(titleWidthSpec, titleHeightSpec)
+
+    var totalHeight = titleMarginTop + title!!.measuredHeight
+    totalHeight = max(totalHeight, minHeight)
+
+    val connectorWidthSpec =
+      MeasureSpec.makeMeasureSpec(connectorWidth, MeasureSpec.EXACTLY)
+    val connectorHeightSpec =
+      MeasureSpec.makeMeasureSpec(totalHeight, MeasureSpec.EXACTLY)
+
+    connector!!.measure(connectorWidthSpec, connectorHeightSpec)
+    setMeasuredDimension(availableWidth, totalHeight)
+  }
+
+  override fun onLayout(
+    changed: Boolean,
+    l: Int,
+    t: Int,
+    r: Int,
+    b: Int
+  ) {
+    val connectorRight = rowMargins + connector!!.measuredWidth
+    connector!!.layout(rowMargins, 0, connectorRight, connector!!.measuredHeight)
+
+    val titleLeft = connectorRight + rowMargins
+    val titleBottom = titleMarginTop + title!!.measuredHeight
+    title!!.layout(titleLeft, titleMarginTop, titleLeft + title!!.measuredWidth, titleBottom)
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/SerializableIntent.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/SerializableIntent.kt
new file mode 100644
index 00000000..7e6ee8d9
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/SerializableIntent.kt
@@ -0,0 +1,22 @@
+package leakcanary.internal
+
+import android.content.Intent
+import java.io.Serializable
+
+/**
+ * Wraps an Intent to serialize it as its URI string.
+ */
+internal class SerializableIntent(intent: Intent) : Serializable {
+
+  private val uri = intent.toUri(0)
+
+  // Intent is not Serializable
+  @Transient
+  private var _intent: Intent? = intent
+
+  val intent: Intent
+    get() = _intent.run {
+      this ?: Intent.parseUri(uri, 0)
+        .apply { _intent = this }
+    }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/Serializables.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/Serializables.kt
new file mode 100644
index 00000000..ca7dc667
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/Serializables.kt
@@ -0,0 +1,27 @@
+package leakcanary.internal
+
+import shark.SharkLog
+import java.io.ByteArrayInputStream
+import java.io.ByteArrayOutputStream
+import java.io.ObjectInputStream
+import java.io.ObjectOutputStream
+import java.io.Serializable
+
+internal fun Serializable.toByteArray(): ByteArray {
+  val outputStream = ByteArrayOutputStream()
+  ObjectOutputStream(outputStream).writeObject(this)
+  return outputStream.toByteArray()
+}
+
+internal object Serializables {
+
+  inline fun <reified T> fromByteArray(byteArray: ByteArray): T? {
+    val inputStream = ByteArrayInputStream(byteArray)
+    return try {
+      ObjectInputStream(inputStream).readObject() as? T
+    } catch (ignored: Throwable) {
+      SharkLog.d(ignored) { "Could not deserialize bytes, ignoring" }
+      null
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
new file mode 100644
index 00000000..aecf5272
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.content.Context
+import android.graphics.Canvas
+import android.graphics.Paint
+import android.graphics.Path
+import android.text.SpannableStringBuilder
+import android.text.style.ReplacementSpan
+import android.text.style.UnderlineSpan
+import com.squareup.leakcanary.core.R
+import kotlin.math.sin
+import leakcanary.internal.navigation.getColorCompat
+
+/**
+ * Inspired from https://github.com/flavienlaurent/spans and
+ * https://github.com/andyxialm/WavyLineView
+ */
+internal class SquigglySpan(context: Context) : ReplacementSpan() {
+
+  private val squigglyPaint: Paint = Paint(Paint.ANTI_ALIAS_FLAG)
+  private val path: Path
+  private val referenceColor: Int
+  private val halfStrokeWidth: Float
+  private val amplitude: Float
+  private val halfWaveHeight: Float
+  private val periodDegrees: Float
+
+  private var width: Int = 0
+
+  init {
+    val resources = context.resources
+    squigglyPaint.style = Paint.Style.STROKE
+    squigglyPaint.color = context.getColorCompat(R.color.leak_canary_leak)
+    val strokeWidth =
+      resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_stroke_width)
+        .toFloat()
+    squigglyPaint.strokeWidth = strokeWidth
+
+    halfStrokeWidth = strokeWidth / 2
+    amplitude = resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_amplitude)
+      .toFloat()
+    periodDegrees =
+      resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_period_degrees)
+        .toFloat()
+    path = Path()
+    val waveHeight = 2 * amplitude + strokeWidth
+    halfWaveHeight = waveHeight / 2
+    referenceColor = context.getColorCompat(R.color.leak_canary_reference)
+  }
+
+  override fun getSize(
+    paint: Paint,
+    text: CharSequence,
+    start: Int,
+    end: Int,
+    fm: Paint.FontMetricsInt?
+  ): Int {
+    width = paint.measureText(text, start, end)
+      .toInt()
+    return width
+  }
+
+  override fun draw(
+    canvas: Canvas,
+    text: CharSequence,
+    start: Int,
+    end: Int,
+    x: Float,
+    top: Int,
+    y: Int,
+    bottom: Int,
+    paint: Paint
+  ) {
+    squigglyHorizontalPath(
+      path,
+      x + halfStrokeWidth,
+      x + width - halfStrokeWidth,
+      bottom - halfWaveHeight,
+      amplitude, periodDegrees
+    )
+    canvas.drawPath(path, squigglyPaint)
+
+    paint.color = referenceColor
+    canvas.drawText(text, start, end, x, y.toFloat(), paint)
+  }
+
+  companion object {
+
+    fun replaceUnderlineSpans(
+      builder: SpannableStringBuilder,
+      context: Context
+    ) {
+      val underlineSpans = builder.getSpans(0, builder.length, UnderlineSpan::class.java)
+      for (span in underlineSpans) {
+        val start = builder.getSpanStart(span)
+        val end = builder.getSpanEnd(span)
+        builder.removeSpan(span)
+        builder.setSpan(SquigglySpan(context), start, end, 0)
+      }
+    }
+
+    @Suppress("LongParameterList")
+    private fun squigglyHorizontalPath(
+      path: Path,
+      left: Float,
+      right: Float,
+      centerY: Float,
+      amplitude: Float,
+      periodDegrees: Float
+    ) {
+      path.reset()
+
+      var y: Float
+      path.moveTo(left, centerY)
+      val period = (2 * Math.PI / periodDegrees).toFloat()
+
+      var x = 0f
+      while (x <= right - left) {
+        y = (amplitude * sin((40 + period * x).toDouble()) + centerY).toFloat()
+        path.lineTo(left + x, y)
+        x += 1f
+      }
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
new file mode 100644
index 00000000..d2d9e032
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
@@ -0,0 +1,86 @@
+package leakcanary.internal
+
+import android.app.Activity
+import android.app.Application
+import android.content.BroadcastReceiver
+import android.content.Context
+import android.content.Intent
+import android.content.Intent.ACTION_SCREEN_OFF
+import android.content.Intent.ACTION_SCREEN_ON
+import android.content.IntentFilter
+import android.os.Build
+import leakcanary.internal.friendly.noOpDelegate
+
+internal class VisibilityTracker(
+  private val listener: (Boolean) -> Unit
+) : Application.ActivityLifecycleCallbacks by noOpDelegate(), BroadcastReceiver() {
+
+  private var startedActivityCount = 0
+
+  /**
+   * Visible activities are any activity started but not stopped yet. An activity can be paused
+   * yet visible: this will happen when another activity shows on top with a transparent background
+   * and the activity behind won't get touch inputs but still need to render / animate.
+   */
+  private var hasVisibleActivities: Boolean = false
+
+  /**
+   * Assuming screen on by default.
+   */
+  private var screenOn: Boolean = true
+
+  private var lastUpdate: Boolean = false
+
+  override fun onActivityStarted(activity: Activity) {
+    startedActivityCount++
+    if (!hasVisibleActivities && startedActivityCount == 1) {
+      hasVisibleActivities = true
+      updateVisible()
+    }
+  }
+
+  override fun onActivityStopped(activity: Activity) {
+    // This could happen if the callbacks were registered after some activities were already
+    // started. In that case we effectively considers those past activities as not visible.
+    if (startedActivityCount > 0) {
+      startedActivityCount--
+    }
+    if (hasVisibleActivities && startedActivityCount == 0 && !activity.isChangingConfigurations) {
+      hasVisibleActivities = false
+      updateVisible()
+    }
+  }
+
+  override fun onReceive(
+    context: Context,
+    intent: Intent
+  ) {
+    screenOn = intent.action != ACTION_SCREEN_OFF
+    updateVisible()
+  }
+
+  private fun updateVisible() {
+    val visible = screenOn && hasVisibleActivities
+    if (visible != lastUpdate) {
+      lastUpdate = visible
+      listener.invoke(visible)
+    }
+  }
+}
+
+internal fun Application.registerVisibilityListener(listener: (Boolean) -> Unit) {
+  val visibilityTracker = VisibilityTracker(listener)
+  registerActivityLifecycleCallbacks(visibilityTracker)
+
+  val intentFilter = IntentFilter().apply {
+    addAction(ACTION_SCREEN_ON)
+    addAction(ACTION_SCREEN_OFF)
+  }
+
+  if (Build.VERSION.SDK_INT >= 33) {
+    val flags = Context.RECEIVER_EXPORTED
+    registerReceiver(visibilityTracker, intentFilter, flags)
+  } else {
+    registerReceiver(visibilityTracker, intentFilter)
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
new file mode 100644
index 00000000..34ef2afb
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
@@ -0,0 +1,232 @@
+package leakcanary.internal.activity
+
+import android.content.Context
+import android.content.Intent
+import android.net.Uri
+import android.os.AsyncTask
+import android.os.Bundle
+import android.view.View
+import android.widget.Toast
+import com.squareup.leakcanary.core.R
+import java.io.FileInputStream
+import java.io.IOException
+import java.util.UUID
+import leakcanary.EventListener.Event.HeapDump
+import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.activity.db.Db
+import leakcanary.internal.activity.screen.AboutScreen
+import leakcanary.internal.activity.screen.HeapAnalysisFailureScreen
+import leakcanary.internal.activity.screen.HeapDumpScreen
+import leakcanary.internal.activity.screen.HeapDumpsScreen
+import leakcanary.internal.activity.screen.LeaksScreen
+import leakcanary.internal.navigation.NavigatingActivity
+import leakcanary.internal.navigation.Screen
+import shark.SharkLog
+
+internal class LeakActivity : NavigatingActivity() {
+
+  private val leaksButton by lazy {
+    findViewById<View>(R.id.leak_canary_navigation_button_leaks)
+  }
+
+  private val leaksButtonIconView by lazy {
+    findViewById<View>(R.id.leak_canary_navigation_button_leaks_icon)
+  }
+
+  private val heapDumpsButton by lazy {
+    findViewById<View>(R.id.leak_canary_navigation_button_heap_dumps)
+  }
+
+  private val heapDumpsButtonIconView by lazy {
+    findViewById<View>(R.id.leak_canary_navigation_button_heap_dumps_icon)
+  }
+
+  private val aboutButton by lazy {
+    findViewById<View>(R.id.leak_canary_navigation_button_about)
+  }
+
+  private val aboutButtonIconView by lazy {
+    findViewById<View>(R.id.leak_canary_navigation_button_about_icon)
+  }
+
+  private val bottomNavigationBar by lazy {
+    findViewById<View>(R.id.leak_canary_bottom_navigation_bar)
+  }
+
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+    setContentView(R.layout.leak_canary_leak_activity)
+
+    installNavigation(savedInstanceState, findViewById(R.id.leak_canary_main_container))
+
+    leaksButton.setOnClickListener { resetTo(LeaksScreen()) }
+    heapDumpsButton.setOnClickListener { resetTo(HeapDumpsScreen()) }
+    aboutButton.setOnClickListener { resetTo(AboutScreen()) }
+
+    handleViewHprof(intent)
+  }
+
+  private fun handleViewHprof(intent: Intent?) {
+    if (intent?.action != Intent.ACTION_VIEW) return
+    val uri = intent.data ?: return
+    if (uri.lastPathSegment?.endsWith(".hprof") != true) {
+      Toast.makeText(this, getString(R.string.leak_canary_import_unsupported_file_extension, uri.lastPathSegment), Toast.LENGTH_LONG).show()
+      return
+    }
+    resetTo(HeapDumpsScreen())
+    AsyncTask.THREAD_POOL_EXECUTOR.execute {
+      importHprof(uri)
+    }
+  }
+
+  override fun onNewScreen(screen: Screen) {
+    when (screen) {
+      is LeaksScreen -> {
+        bottomNavigationBar.visibility = View.VISIBLE
+        leaksButton.isSelected = true
+        leaksButtonIconView.alpha = 1.0f
+        heapDumpsButton.isSelected = false
+        heapDumpsButtonIconView.alpha = 0.4f
+        aboutButton.isSelected = false
+        aboutButtonIconView.alpha = 0.4f
+      }
+      is HeapDumpsScreen -> {
+        bottomNavigationBar.visibility = View.VISIBLE
+        leaksButton.isSelected = false
+        leaksButtonIconView.alpha = 0.4f
+        heapDumpsButton.isSelected = true
+        heapDumpsButtonIconView.alpha = 1.0f
+        aboutButton.isSelected = false
+        aboutButtonIconView.alpha = 0.4f
+      }
+      is AboutScreen -> {
+        bottomNavigationBar.visibility = View.VISIBLE
+        leaksButton.isSelected = false
+        leaksButtonIconView.alpha = 0.4f
+        heapDumpsButton.isSelected = false
+        heapDumpsButtonIconView.alpha = 0.4f
+        aboutButton.isSelected = true
+        aboutButtonIconView.alpha = 1.0f
+      }
+      else -> {
+        bottomNavigationBar.visibility = View.GONE
+      }
+    }
+  }
+
+  override fun getLauncherScreen(): Screen {
+    return LeaksScreen()
+  }
+
+  fun requestImportHprof() {
+    val requestFileIntent = Intent(Intent.ACTION_GET_CONTENT).apply {
+      type = "*/*"
+      addCategory(Intent.CATEGORY_OPENABLE)
+    }
+
+    val chooserIntent = Intent.createChooser(
+      requestFileIntent, resources.getString(R.string.leak_canary_import_from_title)
+    )
+    startActivityForResult(chooserIntent, FILE_REQUEST_CODE)
+  }
+
+  override fun onActivityResult(
+    requestCode: Int,
+    resultCode: Int,
+    returnIntent: Intent?
+  ) {
+    SharkLog.d {
+      "Got activity result with requestCode=$requestCode resultCode=$resultCode returnIntent=$returnIntent"
+    }
+    if (requestCode == FILE_REQUEST_CODE && resultCode == RESULT_OK && returnIntent != null) {
+      returnIntent.data?.let { fileUri ->
+        AsyncTask.THREAD_POOL_EXECUTOR.execute {
+          importHprof(fileUri)
+        }
+      }
+    }
+  }
+
+  private fun importHprof(fileUri: Uri) {
+    try {
+      contentResolver.openFileDescriptor(fileUri, "r")
+        ?.fileDescriptor?.let { fileDescriptor ->
+          val inputStream = FileInputStream(fileDescriptor)
+          InternalLeakCanary.createLeakDirectoryProvider(this)
+            .newHeapDumpFile()
+            ?.let { target ->
+              inputStream.use { input ->
+                target.outputStream()
+                  .use { output ->
+                    input.copyTo(output, DEFAULT_BUFFER_SIZE)
+                  }
+              }
+              InternalLeakCanary.sendEvent(
+                HeapDump(
+                  uniqueId = UUID.randomUUID().toString(),
+                  file = target,
+                  durationMillis = -1,
+                  reason = "Imported by user"
+                )
+              )
+            }
+        }
+    } catch (e: IOException) {
+      SharkLog.d(e) { "Could not import Hprof file" }
+    }
+  }
+
+  override fun onDestroy() {
+    super.onDestroy()
+    if (!isChangingConfigurations) {
+      Db.closeDatabase()
+    }
+  }
+
+  override fun setTheme(resid: Int) {
+    // We don't want this to be called with an incompatible theme.
+    // This could happen if you implement runtime switching of themes
+    // using ActivityLifecycleCallbacks.
+    if (resid != R.style.leak_canary_LeakCanary_Base) {
+      return
+    }
+    super.setTheme(resid)
+  }
+
+  override fun parseIntentScreens(intent: Intent): List<Screen> {
+    val heapAnalysisId = intent.getLongExtra("heapAnalysisId", -1L)
+    if (heapAnalysisId == -1L) {
+      return emptyList()
+    }
+    val success = intent.getBooleanExtra("success", false)
+    return if (success) {
+      arrayListOf(HeapDumpsScreen(), HeapDumpScreen(heapAnalysisId))
+    } else {
+      arrayListOf(HeapDumpsScreen(), HeapAnalysisFailureScreen(heapAnalysisId))
+    }
+  }
+
+  companion object {
+    private const val FILE_REQUEST_CODE = 0
+
+    fun createHomeIntent(context: Context): Intent {
+      val intent = Intent(context, LeakActivity::class.java)
+      intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
+      return intent
+    }
+
+    fun createSuccessIntent(context: Context, heapAnalysisId: Long): Intent {
+      val intent = createHomeIntent(context)
+      intent.putExtra("heapAnalysisId", heapAnalysisId)
+      intent.putExtra("success", true)
+      return intent
+    }
+
+    fun createFailureIntent(context: Context, heapAnalysisId: Long): Intent {
+      val intent = createHomeIntent(context)
+      intent.putExtra("heapAnalysisId", heapAnalysisId)
+      intent.putExtra("success", false)
+      return intent
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
new file mode 100644
index 00000000..7479ae48
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
@@ -0,0 +1,111 @@
+package leakcanary.internal.activity
+
+import android.annotation.SuppressLint
+import android.content.ActivityNotFoundException
+import android.content.ClipData
+import android.content.ClipboardManager
+import android.content.Context
+import android.content.Intent
+import android.net.Uri
+import android.os.AsyncTask
+import android.os.Build
+import android.view.View
+import android.widget.Toast
+import com.squareup.leakcanary.core.BuildConfig
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.LeakCanaryFileProvider
+import leakcanary.internal.navigation.activity
+import shark.HeapAnalysisFailure
+import java.io.File
+
+internal fun View.share(content: String) {
+  val intent = Intent(Intent.ACTION_SEND)
+  intent.type = "text/plain"
+  intent.putExtra(Intent.EXTRA_TEXT, content)
+  activity.startActivity(
+    Intent.createChooser(intent, resources.getString(R.string.leak_canary_share_with))
+  )
+}
+
+@SuppressLint("SetWorldReadable")
+internal fun View.shareHeapDump(heapDumpFile: File) {
+  AsyncTask.SERIAL_EXECUTOR.execute {
+    heapDumpFile.setReadable(true, false)
+    val heapDumpUri = LeakCanaryFileProvider.getUriForFile(
+      activity,
+      "com.squareup.leakcanary.fileprovider." + activity.packageName,
+      heapDumpFile
+    )
+    activity.runOnUiThread { startShareIntentChooser(heapDumpUri) }
+  }
+}
+
+private fun View.startShareIntentChooser(uri: Uri) {
+  val intent = Intent(Intent.ACTION_SEND)
+  intent.type = "application/octet-stream"
+  intent.putExtra(Intent.EXTRA_STREAM, uri)
+  activity.startActivity(
+    Intent.createChooser(intent, resources.getString(R.string.leak_canary_share_with))
+  )
+}
+
+internal fun View.shareToStackOverflow(content: String) {
+  val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
+  // AsyncTask was needed here due to setPrimaryClip making a disk write which
+  // violated StrictMode if on the main thread
+  AsyncTask.execute {
+    clipboard.setPrimaryClip(
+      ClipData.newPlainText(
+        context.getString(R.string.leak_canary_leak_clipdata_label),
+        "```\n$content```"
+      )
+    )
+  }
+  Toast.makeText(context, R.string.leak_canary_leak_copied, Toast.LENGTH_LONG)
+    .show()
+  val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(STACKOVERFLOW_QUESTION_URL))
+  try {
+    activity.startActivity(browserIntent)
+  } catch (e: ActivityNotFoundException) {
+    Toast.makeText(context, R.string.leak_canary_leak_missing_browser_error, Toast.LENGTH_LONG)
+      .show()
+  }
+}
+
+internal fun View.shareToGitHubIssue(failure: HeapAnalysisFailure) {
+  val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
+  // AsyncTask was needed here due to setPrimaryClip making a disk write which
+  // violated StrictMode if on the main thread
+  AsyncTask.execute {
+    clipboard.setPrimaryClip(
+      ClipData.newPlainText(
+        context.getString(R.string.leak_canary_failure_clipdata_label),
+        """```
+          |${failure.exception}
+          |Build.VERSION.SDK_INT: ${Build.VERSION.SDK_INT}
+          |Build.MANUFACTURER: ${Build.MANUFACTURER}
+          |LeakCanary version: ${BuildConfig.LIBRARY_VERSION}
+          |Analysis duration: ${failure.analysisDurationMillis} ms
+          |Heap dump file path: ${failure.heapDumpFile.absolutePath}
+          |Heap dump timestamp: ${failure.createdAtTimeMillis}
+          |```
+        """.trimMargin()
+      )
+    )
+  }
+  Toast.makeText(context, R.string.leak_canary_failure_copied, Toast.LENGTH_LONG)
+    .show()
+  val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(NEW_ISSUE_URL))
+  try {
+    activity.startActivity(browserIntent)
+  } catch (e: ActivityNotFoundException) {
+    Toast.makeText(context, R.string.leak_canary_leak_missing_browser_error, Toast.LENGTH_LONG)
+      .show()
+  }
+}
+
+private const val STACKOVERFLOW_QUESTION_URL =
+  "http://stackoverflow.com/questions/ask?guided=false&tags=leakcanary"
+
+private const val NEW_ISSUE_URL =
+  "https://github.com/square/leakcanary/issues/new?labels=type%3A+bug&template=2-bug.md"
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Cursors.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Cursors.kt
new file mode 100644
index 00000000..6cb1e274
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Cursors.kt
@@ -0,0 +1,45 @@
+package leakcanary.internal.activity.db
+
+import android.database.Cursor
+import android.database.sqlite.SQLiteDatabase
+import kotlin.concurrent.getOrSet
+
+/**
+ * Similar to the more generic use() for Closable.
+ * Cursor started implementing Closable in API 16.
+ */
+internal inline fun <R> Cursor.use(block: (Cursor) -> R): R {
+  var exception: Throwable? = null
+  try {
+    return block(this)
+  } catch (e: Throwable) {
+    exception = e
+    throw e
+  } finally {
+    when (exception) {
+      null -> close()
+      else -> try {
+        close()
+      } catch (_: Throwable) {
+      }
+    }
+  }
+}
+
+private val inTransaction = ThreadLocal<Boolean>()
+
+internal inline fun <T> SQLiteDatabase.inTransaction(block: SQLiteDatabase.() -> T): T {
+  if (inTransaction.getOrSet { false }) {
+    return block()
+  }
+  try {
+    inTransaction.set(true)
+    beginTransaction()
+    val result = block()
+    setTransactionSuccessful()
+    return result
+  } finally {
+    endTransaction()
+    inTransaction.set(false)
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Db.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Db.kt
new file mode 100644
index 00000000..392fa657
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Db.kt
@@ -0,0 +1,55 @@
+package leakcanary.internal.activity.db
+
+import android.database.sqlite.SQLiteDatabase
+import android.view.View
+import leakcanary.internal.activity.db.Db.OnDb
+import leakcanary.internal.activity.db.Io.OnIo
+import leakcanary.internal.activity.db.ScopedLeaksDb.DbOpener
+
+internal object Db {
+
+  // Accessed on the IO thread only.
+  private var dbHelper: DbOpener? = null
+
+  interface OnDb : OnIo {
+    val db: SQLiteDatabase
+  }
+
+  private class DbContext(override val db: SQLiteDatabase) : OnDb {
+    var updateUi: (View.() -> Unit)? = null
+
+    override fun updateUi(updateUi: View.() -> Unit) {
+      this.updateUi = updateUi
+    }
+  }
+
+  fun execute(
+    view: View,
+    block: OnDb.() -> Unit
+  ) {
+    val appContext = view.context.applicationContext
+    Io.execute(view) {
+      if (dbHelper == null) {
+        dbHelper = ScopedLeaksDb.open(appContext)
+      }
+      val dbBlock = DbContext(dbHelper!!.writableDatabase)
+      block(dbBlock)
+      val updateUi = dbBlock.updateUi
+      if (updateUi != null) {
+        updateUi(updateUi)
+      }
+    }
+  }
+
+  fun closeDatabase() {
+    // Closing on the serial IO thread to ensure we don't close while using the db.
+    Io.execute {
+      dbHelper?.close()
+      dbHelper = null
+    }
+  }
+}
+
+internal fun View.executeOnDb(block: OnDb.() -> Unit) {
+  Db.execute(this, block)
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
new file mode 100644
index 00000000..96b81dcc
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
@@ -0,0 +1,204 @@
+package leakcanary.internal.activity.db
+
+import android.content.ContentValues
+import android.database.sqlite.SQLiteDatabase
+import android.os.AsyncTask
+import leakcanary.internal.LeakDirectoryProvider
+import leakcanary.internal.Serializables
+import leakcanary.internal.toByteArray
+import leakcanary.internal.friendly.checkNotMainThread
+import leakcanary.internal.friendly.mainHandler
+import org.intellij.lang.annotations.Language
+import shark.HeapAnalysis
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.SharkLog
+import java.io.File
+import java.util.concurrent.CopyOnWriteArrayList
+
+internal object HeapAnalysisTable {
+
+  /**
+   * CopyOnWriteArrayList because registered listeners can remove themselves from this list while
+   * iterating and invoking them, which would trigger a ConcurrentModificationException (see #2019).
+   */
+  private val updateListeners = CopyOnWriteArrayList<() -> Unit>()
+
+  @Language("RoomSql")
+  const val create = """CREATE TABLE heap_analysis
+        (
+        id INTEGER PRIMARY KEY AUTOINCREMENT,
+        created_at_time_millis INTEGER,
+        dump_duration_millis INTEGER DEFAULT -1,
+        leak_count INTEGER DEFAULT 0,
+        exception_summary TEXT DEFAULT NULL,
+        object BLOB
+        )"""
+
+  @Language("RoomSql")
+  const val drop = "DROP TABLE IF EXISTS heap_analysis"
+
+  fun onUpdate(block: () -> Unit): () -> Unit {
+    updateListeners.add(block)
+    return {
+      updateListeners.remove(block)
+    }
+  }
+
+  fun insert(
+    db: SQLiteDatabase,
+    heapAnalysis: HeapAnalysis
+  ): Long {
+    val values = ContentValues()
+    values.put("created_at_time_millis", heapAnalysis.createdAtTimeMillis)
+    values.put("dump_duration_millis", heapAnalysis.dumpDurationMillis)
+    values.put("object", heapAnalysis.toByteArray())
+    when (heapAnalysis) {
+      is HeapAnalysisSuccess -> {
+        val leakCount = heapAnalysis.applicationLeaks.size + heapAnalysis.libraryLeaks.size
+        values.put("leak_count", leakCount)
+      }
+      is HeapAnalysisFailure -> {
+        val cause = heapAnalysis.exception.cause!!
+        val exceptionSummary = "${cause.javaClass.simpleName} ${cause.message}"
+        values.put("exception_summary", exceptionSummary)
+      }
+    }
+
+    return db.inTransaction {
+      val heapAnalysisId = db.insertOrThrow("heap_analysis", null, values)
+      if (heapAnalysis is HeapAnalysisSuccess) {
+        heapAnalysis.allLeaks
+          .forEach { leakingInstance ->
+            LeakTable.insert(
+              db, heapAnalysisId, leakingInstance
+            )
+          }
+      }
+      heapAnalysisId
+    }.apply { notifyUpdateOnMainThread() }
+  }
+
+  private fun notifyUpdateOnMainThread() {
+    checkNotMainThread()
+    mainHandler.post {
+      updateListeners.forEach { it() }
+    }
+  }
+
+  inline fun <reified T : HeapAnalysis> retrieve(
+    db: SQLiteDatabase,
+    id: Long
+  ): T? {
+    return db.rawQuery(
+      """
+              SELECT
+              object
+              FROM heap_analysis
+              WHERE id=$id
+              """, null
+    )
+      .use { cursor ->
+        if (cursor.moveToNext()) {
+          val analysis = Serializables.fromByteArray<T>(cursor.getBlob(0))
+          if (analysis == null) {
+            delete(db, id, null)
+          }
+          analysis
+        } else {
+          null
+        }
+      }
+  }
+
+  fun retrieveAll(db: SQLiteDatabase): List<Projection> {
+    return db.rawQuery(
+      """
+          SELECT
+          id
+          , created_at_time_millis
+          , leak_count
+          , exception_summary
+          FROM heap_analysis
+          ORDER BY created_at_time_millis DESC
+          """, null
+    )
+      .use { cursor ->
+        val all = mutableListOf<Projection>()
+        while (cursor.moveToNext()) {
+          val summary = Projection(
+            id = cursor.getLong(0),
+            createdAtTimeMillis = cursor.getLong(1),
+            leakCount = cursor.getInt(2),
+            exceptionSummary = cursor.getString(3)
+          )
+          all.add(summary)
+        }
+        all
+      }
+  }
+
+  fun delete(
+    db: SQLiteDatabase,
+    heapAnalysisId: Long,
+    heapDumpFile: File?
+  ) {
+    if (heapDumpFile != null) {
+      AsyncTask.SERIAL_EXECUTOR.execute {
+        val path = heapDumpFile.absolutePath
+        val heapDumpDeleted = heapDumpFile.delete()
+        if (heapDumpDeleted) {
+          LeakDirectoryProvider.filesDeletedRemoveLeak += path
+        } else {
+          SharkLog.d { "Could not delete heap dump file ${heapDumpFile.path}" }
+        }
+      }
+    }
+
+    db.inTransaction {
+      db.delete("heap_analysis", "id=$heapAnalysisId", null)
+      LeakTable.deleteByHeapAnalysisId(db, heapAnalysisId)
+    }
+    notifyUpdateOnMainThread()
+  }
+
+  fun deleteAll(db: SQLiteDatabase) {
+    db.inTransaction {
+      rawQuery(
+        """
+              SELECT
+              id,
+              object
+              FROM heap_analysis
+              """, null
+      )
+        .use { cursor ->
+          val all = mutableListOf<Pair<Long, HeapAnalysis>>()
+          while (cursor.moveToNext()) {
+            val id = cursor.getLong(0)
+            val analysis = Serializables.fromByteArray<HeapAnalysis>(cursor.getBlob(1))
+            if (analysis != null) {
+              all += id to analysis
+            }
+          }
+          all.forEach { (id, _) ->
+            db.delete("heap_analysis", "id=$id", null)
+            LeakTable.deleteByHeapAnalysisId(db, id)
+          }
+          AsyncTask.SERIAL_EXECUTOR.execute {
+            all.forEach { (_, analysis) ->
+              analysis.heapDumpFile.delete()
+            }
+          }
+        }
+    }
+    notifyUpdateOnMainThread()
+  }
+
+  class Projection(
+    val id: Long,
+    val createdAtTimeMillis: Long,
+    val leakCount: Int,
+    val exceptionSummary: String?
+  )
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Io.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Io.kt
new file mode 100644
index 00000000..257f1111
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Io.kt
@@ -0,0 +1,67 @@
+package leakcanary.internal.activity.db
+
+import android.view.View
+import leakcanary.internal.activity.db.Io.OnIo
+import leakcanary.internal.navigation.onScreenExiting
+import leakcanary.internal.friendly.checkMainThread
+import leakcanary.internal.friendly.mainHandler
+import java.util.concurrent.Executors
+
+internal object Io {
+
+  private val serialExecutor =
+    Executors.newSingleThreadExecutor { runnable -> Thread(runnable, "LeakCanary-Activity-DB") }
+
+  fun interface OnIo {
+    fun updateUi(updateUi: View.() -> Unit)
+  }
+
+  private class IoContext : OnIo {
+    var updateUi: (View.() -> Unit)? = null
+
+    override fun updateUi(updateUi: View.() -> Unit) {
+      this.updateUi = updateUi
+    }
+  }
+
+  fun execute(block: () -> Unit) {
+    serialExecutor.execute(block)
+  }
+
+  fun execute(
+    view: View,
+    block: OnIo.() -> Unit
+  ) {
+    checkMainThread()
+    val viewWrapper: VolatileObjectRef<View> = VolatileObjectRef(view)
+    view.onScreenExiting {
+      viewWrapper.element = null
+    }
+    serialExecutor.execute backgroundExecute@{
+      if (viewWrapper.element == null) {
+        return@backgroundExecute
+      }
+      val context = IoContext()
+      block(context)
+      val updateUi = context.updateUi
+      if (viewWrapper.element != null && updateUi != null) {
+        mainHandler.post mainThreadPost@{
+          val attachedView = viewWrapper.element ?: return@mainThreadPost
+          updateUi(attachedView)
+        }
+      }
+    }
+  }
+
+  /**
+   * Similar to kotlin.jvm.internal.Ref.ObjectRef but volatile
+   */
+  private class VolatileObjectRef<T>(
+    @Volatile
+    var element: T? = null
+  )
+}
+
+internal fun View.executeOnIo(block: OnIo.() -> Unit) {
+  Io.execute(this, block)
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakTable.kt
new file mode 100644
index 00000000..878e8d89
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakTable.kt
@@ -0,0 +1,219 @@
+package leakcanary.internal.activity.db
+
+import android.content.ContentValues
+import android.database.sqlite.SQLiteDatabase
+import org.intellij.lang.annotations.Language
+import shark.Leak
+import shark.LibraryLeak
+
+internal object LeakTable {
+
+  @Language("RoomSql")
+  const val create = """
+        CREATE TABLE leak
+        (
+        id INTEGER PRIMARY KEY,
+        signature TEXT UNIQUE,
+        short_description TEXT,
+        is_library_leak INTEGER,
+        is_read INTEGER
+        )"""
+
+  @Language("RoomSql")
+  const val createSignatureIndex = """
+        CREATE INDEX leak_signature
+        on leak (signature)
+    """
+
+  @Language("RoomSql")
+  const val drop = "DROP TABLE IF EXISTS leak"
+
+  fun insert(
+    db: SQLiteDatabase,
+    heapAnalysisId: Long,
+    leak: Leak
+  ): Long {
+    val values = ContentValues()
+    values.put("signature", leak.signature)
+    values.put("short_description", leak.shortDescription)
+    values.put("is_library_leak", if (leak is LibraryLeak) 1 else 0)
+    values.put("is_read", 0)
+
+    db.insertWithOnConflict("leak", null, values, SQLiteDatabase.CONFLICT_IGNORE)
+
+    val leakId =
+      db.rawQuery("SELECT id from leak WHERE signature = '${leak.signature}' LIMIT 1", null)
+        .use { cursor ->
+          if (cursor.moveToFirst()) cursor.getLong(0) else throw IllegalStateException(
+            "No id found for leak with signature '${leak.signature}'"
+          )
+        }
+
+    leak.leakTraces.forEachIndexed { index, leakTrace ->
+      LeakTraceTable.insert(
+        db = db,
+        leakId = leakId,
+        heapAnalysisId = heapAnalysisId,
+        leakTraceIndex = index,
+        leakingObjectClassSimpleName = leakTrace.leakingObject.classSimpleName
+      )
+    }
+
+    return leakId
+  }
+
+  fun retrieveLeakReadStatuses(
+    db: SQLiteDatabase,
+    signatures: Set<String>
+  ): Map<String, Boolean> {
+    return db.rawQuery(
+      """
+      SELECT
+      signature
+      , is_read
+      FROM leak
+      WHERE signature IN (${signatures.joinToString { "'$it'" }})
+    """, null
+    )
+      .use { cursor ->
+        val leakReadStatuses = mutableMapOf<String, Boolean>()
+        while (cursor.moveToNext()) {
+          val signature = cursor.getString(0)
+          val isRead = cursor.getInt(1) == 1
+          leakReadStatuses[signature] = isRead
+        }
+        leakReadStatuses
+      }
+  }
+
+  class AllLeaksProjection(
+    val signature: String,
+    val shortDescription: String,
+    val createdAtTimeMillis: Long,
+    val leakTraceCount: Int,
+    val isLibraryLeak: Boolean,
+    val isNew: Boolean
+  )
+
+  fun retrieveAllLeaks(
+    db: SQLiteDatabase
+  ): List<AllLeaksProjection> {
+    return db.rawQuery(
+      """
+          SELECT
+          l.signature
+          , MIN(l.short_description)
+          , MAX(h.created_at_time_millis) as created_at_time_millis
+          , COUNT(*) as leak_trace_count
+          , MIN(l.is_library_leak) as is_library_leak
+          , MAX(l.is_read) as is_read
+          FROM leak_trace lt
+          LEFT JOIN leak l on lt.leak_id = l.id
+          LEFT JOIN heap_analysis h ON lt.heap_analysis_id = h.id
+          GROUP BY 1
+          ORDER BY leak_trace_count DESC, created_at_time_millis DESC
+          """, null
+    )
+      .use { cursor ->
+        val all = mutableListOf<AllLeaksProjection>()
+        while (cursor.moveToNext()) {
+          val group = AllLeaksProjection(
+            signature = cursor.getString(0),
+            shortDescription = cursor.getString(1),
+            createdAtTimeMillis = cursor.getLong(2),
+            leakTraceCount = cursor.getInt(3),
+            isLibraryLeak = cursor.getInt(4) == 1,
+            isNew = cursor.getInt(5) == 0
+          )
+          all.add(group)
+        }
+        all
+      }
+  }
+
+  fun markAsRead(
+    db: SQLiteDatabase,
+    signature: String
+  ) {
+    val values = ContentValues().apply { put("is_read", 1) }
+    db.update("leak", values, "signature = ?", arrayOf(signature))
+  }
+
+  class LeakProjection(
+    val shortDescription: String,
+    val isNew: Boolean,
+    val isLibraryLeak: Boolean,
+    val leakTraces: List<LeakTraceProjection>
+  )
+
+  class LeakTraceProjection(
+    val leakTraceIndex: Int,
+    val heapAnalysisId: Long,
+    val classSimpleName: String,
+    val createdAtTimeMillis: Long
+  )
+
+  fun retrieveLeakBySignature(
+    db: SQLiteDatabase,
+    signature: String
+  ): LeakProjection? {
+    return db.rawQuery(
+      """
+          SELECT
+          lt.leak_trace_index
+          , lt.heap_analysis_id
+          , lt.class_simple_name
+          , h.created_at_time_millis
+          , l.short_description
+          , l.is_read
+          , l.is_library_leak
+          FROM leak_trace lt
+          LEFT JOIN leak l on lt.leak_id = l.id
+          LEFT JOIN heap_analysis h ON lt.heap_analysis_id = h.id
+          WHERE l.signature = ?
+          ORDER BY h.created_at_time_millis DESC
+          """, arrayOf(signature)
+    )
+      .use { cursor ->
+        return if (cursor.moveToFirst()) {
+          val leakTraces = mutableListOf<LeakTraceProjection>()
+          val leakProjection = LeakProjection(
+            shortDescription = cursor.getString(4),
+            isNew = cursor.getInt(5) == 0,
+            isLibraryLeak = cursor.getInt(6) == 1,
+            leakTraces = leakTraces
+          )
+          leakTraces.addAll(generateSequence(cursor) {
+            if (cursor.moveToNext()) cursor else null
+          }.map {
+            LeakTraceProjection(
+              leakTraceIndex = cursor.getInt(0),
+              heapAnalysisId = cursor.getLong(1),
+              classSimpleName = cursor.getString(2),
+              createdAtTimeMillis = cursor.getLong(3)
+            )
+          })
+          leakProjection
+        } else {
+          null
+        }
+      }
+  }
+
+  fun deleteByHeapAnalysisId(
+    db: SQLiteDatabase,
+    heapAnalysisId: Long
+  ) {
+    LeakTraceTable.deleteByHeapAnalysisId(db, heapAnalysisId)
+    db.execSQL(
+      """
+      DELETE
+      FROM leak
+      WHERE NOT EXISTS (
+      SELECT *
+      FROM leak_trace lt
+      WHERE leak.id = lt.leak_id)
+    """
+    )
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakTraceTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakTraceTable.kt
new file mode 100644
index 00000000..2e0d57b2
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakTraceTable.kt
@@ -0,0 +1,44 @@
+package leakcanary.internal.activity.db
+
+import android.content.ContentValues
+import android.database.sqlite.SQLiteDatabase
+import org.intellij.lang.annotations.Language
+
+internal object LeakTraceTable {
+
+  @Language("RoomSql")
+  const val create = """
+        CREATE TABLE leak_trace
+        (
+        id INTEGER PRIMARY KEY,
+        heap_analysis_id REFERENCES heap_analysis(id),
+        leak_id REFERENCES leak(id),
+        class_simple_name TEXT,
+        leak_trace_index INTEGER
+        )"""
+
+  @Language("RoomSql")
+  const val drop = "DROP TABLE IF EXISTS leak_trace"
+
+  fun insert(
+    db: SQLiteDatabase,
+    leakId: Long,
+    heapAnalysisId: Long,
+    leakTraceIndex: Int,
+    leakingObjectClassSimpleName: String
+  ): Long {
+    val values = ContentValues()
+    values.put("heap_analysis_id", heapAnalysisId)
+    values.put("leak_id", leakId)
+    values.put("class_simple_name", leakingObjectClassSimpleName)
+    values.put("leak_trace_index", leakTraceIndex)
+    return db.insertOrThrow("leak_trace", null, values)
+  }
+
+  fun deleteByHeapAnalysisId(
+    db: SQLiteDatabase,
+    heapAnalysisId: Long
+  ) {
+    db.delete("leak_trace", "heap_analysis_id=$heapAnalysisId", null)
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
new file mode 100644
index 00000000..0aaff9e9
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
@@ -0,0 +1,122 @@
+package leakcanary.internal.activity.db
+
+import android.content.ContentValues
+import android.content.Context
+import android.database.sqlite.SQLiteDatabase
+import android.database.sqlite.SQLiteOpenHelper
+import leakcanary.internal.Serializables
+import leakcanary.internal.toByteArray
+import shark.HeapAnalysis
+import shark.HeapAnalysisSuccess
+import shark.LeakTrace
+
+internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
+  context, DATABASE_NAME, null, VERSION
+) {
+
+  override fun onCreate(db: SQLiteDatabase) {
+    db.execSQL(HeapAnalysisTable.create)
+    db.execSQL(LeakTable.create)
+    db.execSQL(LeakTable.createSignatureIndex)
+    db.execSQL(LeakTraceTable.create)
+  }
+
+  override fun onUpgrade(
+    db: SQLiteDatabase,
+    oldVersion: Int,
+    newVersion: Int
+  ) {
+    if (oldVersion < 23) {
+      recreateDb(db)
+      return
+    }
+    if (oldVersion < 24) {
+      db.execSQL("ALTER TABLE heap_analysis ADD COLUMN dump_duration_millis INTEGER DEFAULT -1")
+    }
+    if (oldVersion < 25) {
+      // Fix owningClassName=null in the serialized heap analysis.
+      // https://github.com/square/leakcanary/issues/2067
+      val idToAnalysis = db.rawQuery("SELECT id, object FROM heap_analysis", null)
+        .use { cursor ->
+          generateSequence {
+            if (cursor.moveToNext()) {
+              val id = cursor.getLong(0)
+              val analysis = Serializables.fromByteArray<HeapAnalysis>(cursor.getBlob(1))
+              id to analysis
+            } else {
+              null
+            }
+          }
+            .filter {
+              it.second is HeapAnalysisSuccess
+            }
+            .map { pair ->
+              val analysis = pair.second as HeapAnalysisSuccess
+
+              val unreachableObjects = try {
+                analysis.unreachableObjects
+              } catch (ignored: NullPointerException) {
+                // This currently doesn't trigger but the Kotlin compiler might change one day.
+                emptyList()
+              } ?: emptyList() // Compiler doesn't know it but runtime can have null.
+              pair.first to analysis.copy(
+                unreachableObjects = unreachableObjects,
+                applicationLeaks = analysis.applicationLeaks.map { leak ->
+                  leak.copy(leak.leakTraces.fixNullReferenceOwningClassName())
+                },
+                libraryLeaks = analysis.libraryLeaks.map { leak ->
+                  leak.copy(leak.leakTraces.fixNullReferenceOwningClassName())
+                }
+              )
+            }.toList()
+        }
+      db.inTransaction {
+        idToAnalysis.forEach { (id, heapAnalysis) ->
+          val values = ContentValues()
+          values.put("object", heapAnalysis.toByteArray())
+          db.update("heap_analysis", values, "id=$id", null)
+        }
+      }
+    }
+  }
+
+  private fun List<LeakTrace>.fixNullReferenceOwningClassName(): List<LeakTrace> {
+    return map { leakTrace ->
+      leakTrace.copy(
+        referencePath = leakTrace.referencePath.map { reference ->
+          val owningClassName = try {
+            // This can return null at runtime from previous serialized version without the field.
+            reference.owningClassName
+          } catch (ignored: NullPointerException) {
+            // This currently doesn't trigger but the Kotlin compiler might change one day.
+            null
+          }
+          if (owningClassName == null) {
+            reference.copy(owningClassName = reference.originObject.classSimpleName)
+          } else {
+            reference
+          }
+        })
+    }
+  }
+
+  override fun onDowngrade(
+    db: SQLiteDatabase,
+    oldVersion: Int,
+    newVersion: Int
+  ) {
+    recreateDb(db)
+  }
+
+  private fun recreateDb(db: SQLiteDatabase) {
+    db.execSQL(HeapAnalysisTable.drop)
+    db.execSQL(LeakTable.drop)
+    db.execSQL(LeakTraceTable.drop)
+    onCreate(db)
+  }
+
+  companion object {
+    internal const val VERSION = 25
+    internal const val DATABASE_NAME = "leaks.db"
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/ScopedLeaksDb.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/ScopedLeaksDb.kt
new file mode 100644
index 00000000..c8272741
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/ScopedLeaksDb.kt
@@ -0,0 +1,74 @@
+package leakcanary.internal.activity.db
+
+import android.content.Context
+import android.database.sqlite.SQLiteDatabase
+import java.io.Closeable
+
+internal object ScopedLeaksDb {
+
+  @Volatile
+  private lateinit var leaksDbHelper: LeaksDbHelper
+
+  private val lock = Any()
+
+  @Volatile
+  private var openCount: Int = 0
+
+  fun <T> readableDatabase(context: Context, block: (SQLiteDatabase) -> T): T {
+    return open(context).use {
+      block(it.readableDatabase)
+    }
+  }
+
+  fun <T> writableDatabase(context: Context, block: (SQLiteDatabase) -> T): T {
+    return open(context).use {
+      block(it.writableDatabase)
+    }
+  }
+
+  fun open(context: Context): DbOpener {
+    synchronized(lock) {
+      if (!::leaksDbHelper.isInitialized) {
+        leaksDbHelper = LeaksDbHelper(context.applicationContext)
+      }
+      openCount++
+      return DbOpener()
+    }
+  }
+
+  class DbOpener : Closeable {
+
+    private var closed = false
+
+    val readableDatabase: SQLiteDatabase
+      get() {
+        checkClosed()
+        return leaksDbHelper.readableDatabase
+      }
+
+    val writableDatabase: SQLiteDatabase
+      get() {
+        checkClosed()
+        return leaksDbHelper.writableDatabase
+      }
+
+    override fun close() {
+      synchronized(lock) {
+        checkClosed()
+        closed = true
+        openCount--
+        if (openCount == 0) {
+          // No one else needs this right now, let's close the database (will reopen on
+          // next use)
+          leaksDbHelper.close()
+        }
+      }
+    }
+
+    private fun checkClosed() {
+      check(!closed) {
+        "Already closed"
+      }
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/AboutScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/AboutScreen.kt
new file mode 100644
index 00000000..5d6540e4
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/AboutScreen.kt
@@ -0,0 +1,58 @@
+package leakcanary.internal.activity.screen
+
+import android.text.Html
+import android.text.method.LinkMovementMethod
+import android.view.ViewGroup
+import android.widget.Switch
+import android.widget.TextView
+import com.squareup.leakcanary.core.BuildConfig
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.HeapDumpControl
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.Nope
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.Yup
+import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.inflate
+
+internal class AboutScreen : Screen() {
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_about_screen)
+      .apply {
+        activity.title =
+          resources.getString(R.string.leak_canary_about_title, BuildConfig.LIBRARY_VERSION)
+        val aboutTextView = findViewById<TextView>(R.id.leak_canary_about_text)
+        aboutTextView.movementMethod = LinkMovementMethod.getInstance()
+        val application = activity.application
+        val appName = application.packageManager.getApplicationLabel(application.applicationInfo)
+        val appPackageName = context.packageName
+
+        aboutTextView.text = Html.fromHtml(
+          String.format(
+            resources.getString(R.string.leak_canary_about_message), appName, appPackageName
+          )
+        )
+
+        val heapDumpTextView = findViewById<TextView>(R.id.leak_canary_about_heap_dump_text)
+        updateHeapDumpTextView(heapDumpTextView)
+        val heapDumpSwitchView =
+          findViewById<Switch>(R.id.leak_canary_about_heap_dump_switch_button)
+        heapDumpSwitchView.isChecked = InternalLeakCanary.dumpEnabledInAboutScreen
+        heapDumpSwitchView.setOnCheckedChangeListener { _, checked ->
+          // Updating the value wouldn't normally immediately trigger a heap dump, however
+          // by updating the view we also have a side effect of querying which will notify
+          // the heap dumper if the value has become positive.
+          InternalLeakCanary.dumpEnabledInAboutScreen = checked
+          updateHeapDumpTextView(heapDumpTextView)
+        }
+      }
+
+  private fun updateHeapDumpTextView(view: TextView) {
+    view.text = when (val iCanHasHeap = HeapDumpControl.iCanHasHeap()) {
+      is Yup -> view.resources.getString(R.string.leak_canary_heap_dump_enabled_text)
+      is Nope -> view.resources.getString(
+        R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()
+      )
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt
new file mode 100644
index 00000000..abf60c7e
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt
@@ -0,0 +1,118 @@
+package leakcanary.internal.activity.screen
+
+import android.app.ActivityManager
+import android.text.Html
+import android.text.SpannableStringBuilder
+import android.text.method.LinkMovementMethod
+import android.view.View
+import android.view.ViewGroup
+import android.widget.TextView
+import com.squareup.leakcanary.core.R
+import java.util.UUID
+import leakcanary.EventListener.Event.HeapDump
+import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.executeOnDb
+import leakcanary.internal.activity.shareHeapDump
+import leakcanary.internal.activity.shareToGitHubIssue
+import leakcanary.internal.activity.ui.UiUtils
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.goBack
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.navigation.onCreateOptionsMenu
+import shark.HeapAnalysisFailure
+
+internal class HeapAnalysisFailureScreen(
+  private val analysisId: Long
+) : Screen() {
+
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_heap_analysis_failure_screen).apply {
+      activity.title = resources.getString(R.string.leak_canary_loading_title)
+      executeOnDb {
+        val heapAnalysis = HeapAnalysisTable.retrieve<HeapAnalysisFailure>(db, analysisId)
+        if (heapAnalysis == null) {
+          updateUi {
+            activity.title = resources.getString(R.string.leak_canary_analysis_deleted_title)
+          }
+        } else {
+          val heapDumpFileExist = heapAnalysis.heapDumpFile.exists()
+          updateUi { onFailureRetrieved(heapAnalysis, heapDumpFileExist) }
+        }
+      }
+    }
+
+  private fun View.onFailureRetrieved(
+    heapAnalysis: HeapAnalysisFailure,
+    heapDumpFileExist: Boolean
+  ) {
+    activity.title = resources.getString(R.string.leak_canary_analysis_failed)
+
+    val failureText =
+      if (heapDumpFileExist) {
+        "You can <a href=\"try_again\">run the analysis again</a>.<br><br>"
+      } else {
+        ""
+      } + """
+      Please <a href="file_issue">click here</a> to file a bug report.
+      The stacktrace details will be copied into the clipboard and you just need to paste into the
+      GitHub issue description.""" + (if (heapDumpFileExist) {
+        """
+        <br><br>To help reproduce the issue, please share the
+        <a href="share_hprof">Heap Dump file</a> and upload it to the GitHub issue.
+      """
+      } else "")
+
+    val failure = Html.fromHtml(failureText) as SpannableStringBuilder
+
+    UiUtils.replaceUrlSpanWithAction(failure) { urlSpan ->
+      when (urlSpan) {
+        "file_issue" -> {
+          {
+            shareToGitHubIssue(heapAnalysis)
+          }
+        }
+        "share_hprof" -> {
+          {
+            shareHeapDump(heapAnalysis.heapDumpFile)
+          }
+        }
+        "try_again" -> {
+          {
+            InternalLeakCanary.sendEvent(
+              HeapDump(
+                uniqueId = UUID.randomUUID().toString(),
+                file = heapAnalysis.heapDumpFile,
+                durationMillis = heapAnalysis.dumpDurationMillis,
+                reason = "Retrying heap analysis after failure."
+              )
+            )
+          }
+        }
+        else -> null
+      }
+    }
+    findViewById<TextView>(R.id.leak_canary_header_text).apply {
+      movementMethod = LinkMovementMethod.getInstance()
+      text = failure
+    }
+
+    findViewById<TextView>(R.id.leak_canary_stacktrace).text = heapAnalysis.exception.toString()
+
+    onCreateOptionsMenu { menu ->
+      if (!ActivityManager.isUserAMonkey()) {
+        menu.add(R.string.leak_canary_delete)
+          .setOnMenuItemClickListener {
+            executeOnDb {
+              HeapAnalysisTable.delete(db, analysisId, heapAnalysis.heapDumpFile)
+              updateUi {
+                goBack()
+              }
+            }
+            true
+          }
+      }
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
new file mode 100644
index 00000000..efb900bf
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
@@ -0,0 +1,280 @@
+package leakcanary.internal.activity.screen
+
+import android.content.Context
+import android.content.res.Resources
+import android.graphics.Bitmap
+import android.graphics.Bitmap.Config.ARGB_8888
+import android.graphics.Canvas
+import android.graphics.Color
+import android.graphics.Paint
+import android.graphics.Paint.Style.FILL
+import android.graphics.Paint.Style.STROKE
+import android.graphics.Rect
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.navigation.getColorCompat
+import shark.HprofRecord
+import shark.HprofRecord.HeapDumpEndRecord
+import shark.HprofRecord.HeapDumpRecord.GcRootRecord
+import shark.HprofRecord.HeapDumpRecord.HeapDumpInfoRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StackTraceRecord
+import shark.HprofRecord.StringRecord
+import shark.StreamingHprofReader
+import shark.StreamingRecordReaderAdapter.Companion.asStreamingRecordReader
+import java.io.File
+import kotlin.math.ceil
+import kotlin.math.max
+
+internal object HeapDumpRenderer {
+
+  private class HasDensity(resources: Resources) {
+    val density = resources.displayMetrics.density
+
+    val Int.dp
+      get() = this * density
+
+    val Float.dp
+      get() = this * density
+  }
+
+  @Suppress("LongMethod")
+  fun render(
+    context: Context,
+    heapDumpFile: File,
+    sourceWidth: Int,
+    sourceHeight: Int,
+    /**
+     * If [sourceBytesPerPixel] > 0 then [sourceHeight] will be ignored.
+     */
+    sourceBytesPerPixel: Int
+  ): Bitmap = with(HasDensity(context.resources)) {
+    val recordPositions = mutableListOf<Pair<Int, Long>>()
+    var currentRecord: HprofRecord? = null
+
+    val otherColor = context.getColorCompat(R.color.leak_canary_heap_other)
+    val stackTraceColor = context.getColorCompat(R.color.leak_canary_heap_stack_trace)
+    val hprofStringColor = context.getColorCompat(R.color.leak_canary_heap_hprof_string)
+    val loadClassColor = context.getColorCompat(R.color.leak_canary_heap_load_class)
+    val classDumpColor = context.getColorCompat(R.color.leak_canary_heap_class_dump)
+    val instanceColor = context.getColorCompat(R.color.leak_canary_heap_instance)
+    val objectArrayColor = context.getColorCompat(R.color.leak_canary_heap_object_array)
+    val booleanArrayColor = context.getColorCompat(R.color.leak_canary_heap_boolean_array)
+    val charArrayColor = context.getColorCompat(R.color.leak_canary_heap_char_array)
+    val floatArrayColor = context.getColorCompat(R.color.leak_canary_heap_float_array)
+    val doubleArrayColor = context.getColorCompat(R.color.leak_canary_heap_double_array)
+    val byteArrayColor = context.getColorCompat(R.color.leak_canary_heap_byte_array)
+    val shortArrayColor = context.getColorCompat(R.color.leak_canary_heap_short_array)
+    val intArrayColor = context.getColorCompat(R.color.leak_canary_heap_int_array)
+    val longArrayColor = context.getColorCompat(R.color.leak_canary_heap_long_array)
+    val colors = mapOf(
+      StringRecord::class to hprofStringColor,
+      LoadClassRecord::class to loadClassColor,
+      ClassDumpRecord::class to classDumpColor,
+      InstanceDumpRecord::class to instanceColor,
+      ObjectArrayDumpRecord::class to objectArrayColor,
+      BooleanArrayDump::class to booleanArrayColor,
+      CharArrayDump::class to charArrayColor,
+      FloatArrayDump::class to floatArrayColor,
+      DoubleArrayDump::class to doubleArrayColor,
+      ByteArrayDump::class to byteArrayColor,
+      ShortArrayDump::class to shortArrayColor,
+      IntArrayDump::class to intArrayColor,
+      LongArrayDump::class to longArrayColor,
+      StackTraceRecord::class to stackTraceColor,
+      HeapDumpEndRecord::class to otherColor,
+      GcRootRecord::class to otherColor
+    )
+
+    val appHeapColor = context.getColorCompat(R.color.leak_canary_heap_app)
+    val imageHeapColor = context.getColorCompat(R.color.leak_canary_heap_image)
+    val zygoteHeapColor = context.getColorCompat(R.color.leak_canary_heap_zygote)
+    val stringColor = context.getColorCompat(R.color.leak_canary_heap_instance_string)
+
+    var lastPosition = 0L
+
+    val reader = StreamingHprofReader.readerFor(heapDumpFile).asStreamingRecordReader()
+    val hprofStringCache = mutableMapOf<Long, String>()
+    val classNames = mutableMapOf<Long, Long>()
+    reader.readRecords(
+      setOf(HprofRecord::class)
+    ) { position, record ->
+      lastPosition = position
+      when (record) {
+        is StringRecord -> {
+          hprofStringCache[record.id] = record.string
+        }
+        is LoadClassRecord -> {
+          classNames[record.id] = record.classNameStringId
+        }
+      }
+      val localCurrentRecord = currentRecord
+      when {
+        localCurrentRecord is HeapDumpInfoRecord -> {
+          val colorForHeapInfo =
+            when (hprofStringCache[localCurrentRecord.heapNameStringId]) {
+              // The primary heap on which your app allocates memory.
+              "app" -> appHeapColor
+              // The system boot image, containing classes that are preloaded during boot time.
+              // Allocations here are guaranteed to never move or go away.
+              "image" -> imageHeapColor
+              // The copy-on-write heap where an app process is forked from in the Android system.
+              "zygote" -> zygoteHeapColor
+              // JNI heap: The heap that shows where Java Native Interface (JNI) references are allocated and released.
+              // default heap: When no heap is specified by the system
+              else -> otherColor
+            }
+          recordPositions.add(colorForHeapInfo to position)
+          currentRecord = record
+        }
+        localCurrentRecord is InstanceDumpRecord
+          && hprofStringCache[classNames[localCurrentRecord.classId]] == "java.lang.String"
+          && (record !is InstanceDumpRecord || hprofStringCache[classNames[record.classId]]
+          != "java.lang.String")
+        -> {
+          recordPositions.add(stringColor to position)
+          currentRecord = record
+        }
+        currentRecord == null -> {
+          recordPositions.add(otherColor to position)
+          currentRecord = record
+        }
+        currentRecord!!::class != record::class -> {
+          recordPositions.add(colors.getValue(currentRecord!!::class) to position)
+          currentRecord = record
+        }
+      }
+    }
+    val heapLength = lastPosition
+
+    var height: Int
+    val bytesPerPixel: Double
+
+    if (sourceBytesPerPixel > 0) {
+      bytesPerPixel = sourceBytesPerPixel.toDouble()
+      height = ceil((heapLength / bytesPerPixel) / sourceWidth)
+        .toInt()
+    } else {
+      height = sourceHeight
+      bytesPerPixel = heapLength * 1.0 / (sourceWidth * height)
+    }
+
+    val bitmap: Bitmap =
+      Bitmap.createBitmap(sourceWidth, height, ARGB_8888)
+
+    val canvas = Canvas(bitmap)
+
+    val legend = mapOf(
+      "Hprof string" to hprofStringColor,
+      "Class name" to loadClassColor,
+      "App heap" to appHeapColor,
+      "Image heap" to imageHeapColor,
+      "Zygote heap" to zygoteHeapColor,
+      "Other heap" to otherColor,
+      "Class content" to classDumpColor,
+      "Instance" to instanceColor,
+      "String" to stringColor,
+      "Object array" to objectArrayColor,
+      "Boolean array" to booleanArrayColor,
+      "Char array" to charArrayColor,
+      "Float array" to floatArrayColor,
+      "Double array" to doubleArrayColor,
+      "Byte array" to byteArrayColor,
+      "Short array" to shortArrayColor,
+      "Int array" to intArrayColor,
+      "Long array" to longArrayColor,
+      "Stack trace" to stackTraceColor,
+      "Heap End" to otherColor
+    )
+
+    val legendTextPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+
+    legendTextPaint.color = Color.WHITE
+    legendTextPaint.style = FILL
+    canvas.drawPaint(legendTextPaint)
+
+    val legendSquareFillPaint = Paint()
+    legendSquareFillPaint.style = FILL
+    val legendSquareStrokePaint = Paint()
+    legendSquareStrokePaint.style = STROKE
+    legendSquareStrokePaint.strokeWidth = 0.8f.dp
+    legendSquareStrokePaint.color = Color.BLACK
+
+    legendTextPaint.color = Color.BLACK
+    legendTextPaint.textSize = 16.dp
+
+    val metrics = legendTextPaint.fontMetrics
+    val textHeight = metrics.descent - metrics.ascent
+
+    val xBounds = Rect()
+    legendTextPaint.getTextBounds("x", 0, 1, xBounds)
+    val squareSize = xBounds.height()
+    val squarePaddingTop = (textHeight - squareSize) / 2
+    val squareToTextPadding = 4.dp
+    val blockToBlockPadding = 8.dp
+
+    var maxTextWidth = 0f
+    for (name in legend.keys) {
+      maxTextWidth = max(maxTextWidth, legendTextPaint.measureText(name))
+    }
+
+    val padding = 8.dp
+    var blockLeft = padding
+    var blockTop = padding
+    val legendWidth = sourceWidth - 2 * padding
+    for ((name, color) in legend) {
+      if (blockLeft + squareSize + squareToTextPadding + maxTextWidth > legendWidth) {
+        blockLeft = padding
+        blockTop += textHeight
+      }
+
+      legendSquareFillPaint.color = color
+      canvas.drawRect(
+        blockLeft, blockTop + squarePaddingTop, blockLeft + squareSize,
+        blockTop + squarePaddingTop + squareSize,
+        legendSquareFillPaint
+      )
+      canvas.drawRect(
+        blockLeft, blockTop + squarePaddingTop, blockLeft + squareSize,
+        blockTop + squarePaddingTop + squareSize,
+        legendSquareStrokePaint
+      )
+      blockLeft += squareSize + squareToTextPadding
+      canvas.drawText(name, blockLeft, blockTop - metrics.ascent, legendTextPaint)
+      blockLeft += maxTextWidth
+      blockLeft += blockToBlockPadding
+    }
+    val legendHeight = blockTop + textHeight + padding
+    val source = Rect(0, 0, sourceWidth, legendHeight.toInt())
+    val destination = Rect(0, (height - legendHeight).toInt(), sourceWidth, height)
+    canvas.drawBitmap(bitmap, source, destination, null)
+    height -= legendHeight.toInt()
+
+    val pixelPaint = Paint(Paint.ANTI_ALIAS_FLAG.inv())
+    pixelPaint.style = FILL
+
+    var recordIndex = 0
+    for (y in 0 until height) {
+      for (x in 0 until sourceWidth) {
+        val bitmapPosition = y * sourceWidth + x
+        val heapPosition = (bitmapPosition * bytesPerPixel).toInt()
+        while (heapPosition > recordPositions[recordIndex].second && recordIndex < recordPositions.lastIndex) {
+          recordIndex++
+        }
+        pixelPaint.color = recordPositions[recordIndex].first
+        canvas.drawPoint(x.toFloat(), y.toFloat(), pixelPaint)
+      }
+    }
+    return bitmap
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpScreen.kt
new file mode 100644
index 00000000..2a55acd7
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpScreen.kt
@@ -0,0 +1,246 @@
+package leakcanary.internal.activity.screen
+
+import android.R.drawable
+import android.R.string
+import android.app.ActivityManager
+import android.app.AlertDialog.Builder
+import android.text.Html
+import android.text.SpannableStringBuilder
+import android.text.method.LinkMovementMethod
+import android.view.View
+import android.view.View.GONE
+import android.view.View.VISIBLE
+import android.view.ViewGroup
+import android.widget.BaseAdapter
+import android.widget.ListView
+import android.widget.TextView
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.LeakTable
+import leakcanary.internal.activity.db.executeOnDb
+import leakcanary.internal.activity.share
+import leakcanary.internal.activity.shareHeapDump
+import leakcanary.internal.activity.ui.TimeFormatter
+import leakcanary.internal.activity.ui.UiUtils
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.goBack
+import leakcanary.internal.navigation.goTo
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.navigation.onCreateOptionsMenu
+import shark.HeapAnalysis
+import shark.HeapAnalysisSuccess
+import shark.LibraryLeak
+import shark.SharkLog
+
+internal class HeapDumpScreen(
+  private val analysisId: Long
+) : Screen() {
+
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_list).apply {
+      activity.title = resources.getString(R.string.leak_canary_loading_title)
+
+      executeOnDb {
+        val heapAnalysis = HeapAnalysisTable.retrieve<HeapAnalysisSuccess>(db, analysisId)
+        if (heapAnalysis == null) {
+          updateUi {
+            activity.title = resources.getString(R.string.leak_canary_analysis_deleted_title)
+          }
+        } else {
+          val signatures = heapAnalysis.allLeaks.map { it.signature }
+            .toSet()
+          val leakReadStatus = LeakTable.retrieveLeakReadStatuses(db, signatures)
+          val heapDumpFileExist = heapAnalysis.heapDumpFile.exists()
+          updateUi { onSuccessRetrieved(heapAnalysis, leakReadStatus, heapDumpFileExist) }
+        }
+      }
+    }
+
+  private fun View.onSuccessRetrieved(
+    heapAnalysis: HeapAnalysisSuccess,
+    leakReadStatus: Map<String, Boolean>,
+    heapDumpFileExist: Boolean
+  ) {
+
+    activity.title = TimeFormatter.formatTimestamp(context, heapAnalysis.createdAtTimeMillis)
+
+    onCreateOptionsMenu { menu ->
+      if (!ActivityManager.isUserAMonkey()) {
+        menu.add(R.string.leak_canary_delete)
+          .setOnMenuItemClickListener {
+            executeOnDb {
+              HeapAnalysisTable.delete(db, analysisId, heapAnalysis.heapDumpFile)
+              updateUi {
+                goBack()
+              }
+            }
+            true
+          }
+      }
+      if (heapDumpFileExist) {
+        menu.add(R.string.leak_canary_options_menu_render_heap_dump)
+          .setOnMenuItemClickListener {
+            goTo(RenderHeapDumpScreen(heapAnalysis.heapDumpFile))
+            true
+          }
+      }
+    }
+
+    val listView = findViewById<ListView>(R.id.leak_canary_list)
+
+    val leaks = heapAnalysis.allLeaks.sortedByDescending { it.leakTraces.size }
+      .toList()
+
+    listView.adapter = object : BaseAdapter() {
+      override fun getView(
+        position: Int,
+        convertView: View?,
+        parent: ViewGroup
+      ) = when (getItemViewType(position)) {
+        METADATA -> {
+          bindMetadataRow(convertView, parent, heapDumpFileExist, heapAnalysis)
+        }
+        LEAK_TITLE -> {
+          val view = convertView ?: parent.inflate(R.layout.leak_canary_heap_dump_leak_title)
+          val leaksTextView = view.findViewById<TextView>(R.id.leak_canary_heap_dump_leaks)
+          leaksTextView.text = resources.getQuantityString(
+            R.plurals.leak_canary_distinct_leaks,
+            leaks.size, leaks.size
+          )
+          view
+        }
+        LEAK_ROW -> {
+          val view = convertView ?: parent.inflate(R.layout.leak_canary_leak_row)
+          val countView = view.findViewById<TextView>(R.id.leak_canary_count_text)
+          val descriptionView = view.findViewById<TextView>(R.id.leak_canary_leak_text)
+          val timeView = view.findViewById<TextView>(R.id.leak_canary_time_text)
+          val newChipView = view.findViewById<TextView>(R.id.leak_canary_chip_new)
+          val libraryLeakChipView = view.findViewById<TextView>(R.id.leak_canary_chip_library_leak)
+
+          val leak = leaks[position - 2]
+
+          val isNew = !leakReadStatus.getValue(leak.signature)
+
+          countView.isEnabled = isNew
+          countView.text = leak.leakTraces.size.toString()
+          newChipView.visibility = if (isNew) VISIBLE else GONE
+          libraryLeakChipView.visibility = if (leak is LibraryLeak) VISIBLE else GONE
+          descriptionView.text = leak.shortDescription
+
+          val formattedDate =
+            TimeFormatter.formatTimestamp(view.context, heapAnalysis.createdAtTimeMillis)
+          timeView.text = formattedDate
+          view
+        }
+        else -> {
+          throw IllegalStateException("Unexpected type ${getItemViewType(position)}")
+        }
+      }
+
+      override fun getItem(position: Int) = this
+
+      override fun getItemId(position: Int) = position.toLong()
+
+      override fun getCount() = 2 + leaks.size
+
+      override fun getItemViewType(position: Int) = when (position) {
+        0 -> METADATA
+        1 -> LEAK_TITLE
+        else -> LEAK_ROW
+      }
+
+      override fun getViewTypeCount() = 3
+
+      override fun isEnabled(position: Int) = getItemViewType(position) == LEAK_ROW
+    }
+
+    listView.setOnItemClickListener { _, _, position, _ ->
+      if (position > LEAK_TITLE) {
+        goTo(LeakScreen(leaks[position - 2].signature, analysisId))
+      }
+    }
+  }
+
+  private fun View.bindMetadataRow(
+    convertView: View?,
+    parent: ViewGroup,
+    heapDumpFileExist: Boolean,
+    heapAnalysis: HeapAnalysisSuccess
+  ): View {
+    val view = convertView ?: parent.inflate(R.layout.leak_canary_leak_header)
+    val textView = view.findViewById<TextView>(R.id.leak_canary_header_text)
+    textView.movementMethod = LinkMovementMethod.getInstance()
+
+    val explore =
+      if (heapDumpFileExist) """Explore <a href="explore_hprof">Heap Dump</a><br><br>""" else ""
+    val shareAnalysis = """Share <a href="share">Heap Dump analysis</a><br><br>"""
+    val printAnalysis = """Print analysis <a href="print">to Logcat</a> (tag: LeakCanary)<br><br>"""
+    val shareFile =
+      if (heapDumpFileExist) """Share <a href="share_hprof">Heap Dump file</a><br><br>""" else ""
+
+    val seeMetadata = "See <a href=\"metadata\">Metadata</a>"
+
+    val dumpDurationMillis =
+      if (heapAnalysis.dumpDurationMillis != HeapAnalysis.DUMP_DURATION_UNKNOWN) {
+        "${heapAnalysis.dumpDurationMillis} ms"
+      } else {
+        "Unknown"
+      }
+    val metadata = (heapAnalysis.metadata + mapOf(
+      "Analysis duration" to "${heapAnalysis.analysisDurationMillis} ms",
+      "Heap dump file path" to heapAnalysis.heapDumpFile.absolutePath,
+      "Heap dump timestamp" to "${heapAnalysis.createdAtTimeMillis}",
+      "Heap dump duration" to dumpDurationMillis
+    ))
+      .map { "<b>${it.key}:</b> ${it.value}" }
+      .joinToString("<br>")
+    val titleText = explore + shareAnalysis + printAnalysis + shareFile + seeMetadata
+    val title = Html.fromHtml(titleText) as SpannableStringBuilder
+
+    UiUtils.replaceUrlSpanWithAction(title) { urlSpan ->
+      when (urlSpan) {
+        "explore_hprof" -> {
+          {
+            goTo(HprofExplorerScreen(heapAnalysis.heapDumpFile))
+          }
+        }
+        "share" -> {
+          {
+            share(LeakTraceWrapper.wrap(heapAnalysis.toString(), 80))
+          }
+        }
+        "print" -> {
+          {
+            SharkLog.d { "\u200B\n" + LeakTraceWrapper.wrap(heapAnalysis.toString(), 120) }
+          }
+        }
+        "share_hprof" -> {
+          {
+            shareHeapDump(heapAnalysis.heapDumpFile)
+          }
+        }
+        "metadata" -> {
+          {
+            Builder(context)
+              .setIcon(drawable.ic_dialog_info)
+              .setTitle("Metadata")
+              .setMessage(Html.fromHtml(metadata))
+              .setPositiveButton(string.ok, null)
+              .show()
+          }
+        }
+        else -> null
+      }
+    }
+
+    textView.text = title
+    return view
+  }
+
+  companion object {
+    const val METADATA = 0
+    const val LEAK_TITLE = 1
+    const val LEAK_ROW = 2
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpsScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpsScreen.kt
new file mode 100644
index 00000000..0d788192
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpsScreen.kt
@@ -0,0 +1,115 @@
+package leakcanary.internal.activity.screen
+
+import android.app.ActivityManager
+import android.app.AlertDialog
+import android.view.View
+import android.view.ViewGroup
+import android.widget.ListView
+import android.widget.TextView
+import com.squareup.leakcanary.core.R
+import leakcanary.LeakCanary
+import leakcanary.internal.activity.LeakActivity
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.HeapAnalysisTable.Projection
+import leakcanary.internal.activity.db.executeOnDb
+import leakcanary.internal.activity.ui.SimpleListAdapter
+import leakcanary.internal.activity.ui.TimeFormatter
+import leakcanary.internal.navigation.NavigatingActivity
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.goTo
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.navigation.onCreateOptionsMenu
+import leakcanary.internal.navigation.onScreenExiting
+
+internal class HeapDumpsScreen : Screen() {
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_heap_dumps_screen).apply {
+
+      val unsubscribeRefresh = HeapAnalysisTable.onUpdate {
+        activity<NavigatingActivity>().refreshCurrentScreen()
+      }
+
+      onScreenExiting { unsubscribeRefresh() }
+
+      onCreateOptionsMenu { menu ->
+        if (!ActivityManager.isUserAMonkey()) {
+          menu.add(R.string.leak_canary_delete_all)
+            .setOnMenuItemClickListener {
+              AlertDialog.Builder(context)
+                .setIcon(android.R.drawable.ic_dialog_alert)
+                .setTitle(R.string.leak_canary_delete_all)
+                .setMessage(R.string.leak_canary_delete_all_leaks_title)
+                .setPositiveButton(android.R.string.ok) { _, _ ->
+                  executeOnDb {
+                    HeapAnalysisTable.deleteAll(db)
+                    updateUi {
+                      val listView = findViewById<ListView>(R.id.leak_canary_list)
+                      listView.adapter =
+                        SimpleListAdapter(
+                          R.layout.leak_canary_simple_row, emptyList<Any>()
+                        ) { _, _ -> }
+                    }
+                  }
+                }
+                .setNegativeButton(android.R.string.cancel, null)
+                .show()
+              true
+            }
+        }
+      }
+
+      findViewById<View>(R.id.leak_canary_import_heap_dump).setOnClickListener {
+        activity<LeakActivity>().requestImportHprof()
+      }
+
+      findViewById<View>(R.id.leak_canary_dump_heap_now).setOnClickListener {
+        LeakCanary.dumpHeap()
+      }
+
+      executeOnDb {
+        val projections = HeapAnalysisTable.retrieveAll(db)
+        updateUi { onAnalysesRetrieved(projections) }
+      }
+
+    }
+
+  private fun View.onAnalysesRetrieved(projections: List<Projection>) {
+    activity.title = resources.getQuantityString(
+      R.plurals.leak_canary_heap_analysis_list_screen_title,
+      projections.size, projections.size
+    )
+
+    val listView = findViewById<ListView>(R.id.leak_canary_list)
+
+    listView.setOnItemClickListener { _, _, position, _ ->
+      val projection = projections[position]
+      val analysisScreen = if (projection.exceptionSummary != null) {
+        HeapAnalysisFailureScreen(projection.id)
+      } else {
+        HeapDumpScreen(projection.id)
+      }
+      goTo(analysisScreen)
+    }
+
+    listView.adapter =
+      SimpleListAdapter(R.layout.leak_canary_leak_row, projections) { view, position ->
+        val goneView = view.findViewById<TextView>(R.id.leak_canary_count_text)
+        goneView.visibility = View.GONE
+        val timeView = view.findViewById<TextView>(R.id.leak_canary_leak_text)
+        val countView = view.findViewById<TextView>(R.id.leak_canary_time_text)
+
+        val projection = getItem(position)
+        // Enable means "new"
+        countView.isEnabled = false
+
+        timeView.text = TimeFormatter.formatTimestamp(view.context, projection.createdAtTimeMillis)
+
+        val count = projection.exceptionSummary ?: resources.getQuantityString(
+          R.plurals.leak_canary_distinct_leaks,
+          projection.leakCount, projection.leakCount
+        )
+        countView.text = count
+      }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
new file mode 100644
index 00000000..2ec43eda
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
@@ -0,0 +1,311 @@
+package leakcanary.internal.activity.screen
+
+import android.app.AlertDialog
+import android.view.View
+import android.view.View.OnAttachStateChangeListener
+import android.view.View.VISIBLE
+import android.view.ViewGroup
+import android.widget.EditText
+import android.widget.ListView
+import android.widget.TextView
+import android.widget.Toast
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.activity.db.Io
+import leakcanary.internal.activity.db.executeOnIo
+import leakcanary.internal.activity.ui.SimpleListAdapter
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.inflate
+import shark.HeapField
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.HeapValue
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+import java.io.Closeable
+import java.io.File
+
+internal class HprofExplorerScreen(
+  private val heapDumpFile: File
+) : Screen() {
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_hprof_explorer).apply {
+      container.activity.title = resources.getString(R.string.leak_canary_loading_title)
+
+      var closeable: Closeable? = null
+
+      addOnAttachStateChangeListener(object : OnAttachStateChangeListener {
+        override fun onViewAttachedToWindow(view: View) {
+        }
+
+        override fun onViewDetachedFromWindow(view: View) {
+          Io.execute {
+            closeable?.close()
+          }
+        }
+      })
+
+      executeOnIo {
+        val graph = heapDumpFile.openHeapGraph()
+        closeable = graph
+        updateUi {
+          container.activity.title =
+            resources.getString(R.string.leak_canary_explore_heap_dump)
+          val titleView = findViewById<TextView>(R.id.leak_canary_explorer_title)
+          val searchView = findViewById<View>(R.id.leak_canary_search_button)
+          val listView = findViewById<ListView>(R.id.leak_canary_explorer_list)
+          titleView.visibility = VISIBLE
+          searchView.visibility = VISIBLE
+          listView.visibility = VISIBLE
+          searchView.setOnClickListener {
+            val input = EditText(context)
+            AlertDialog.Builder(context)
+              .setIcon(android.R.drawable.ic_dialog_alert)
+              .setTitle("Type a fully qualified class name")
+              .setView(input)
+              .setPositiveButton(android.R.string.ok) { _, _ ->
+                executeOnIo {
+                  val partialClassName = input.text.toString()
+                  val matchingClasses = graph.classes
+                    .filter { partialClassName in it.name }
+                    .toList()
+
+                  if (matchingClasses.isEmpty()) {
+                    updateUi {
+                      Toast.makeText(
+                        context, "No class matching [$partialClassName]", Toast.LENGTH_LONG
+                      )
+                        .show()
+                    }
+                  } else {
+                    updateUi {
+                      titleView.text =
+                        "${matchingClasses.size} classes matching [$partialClassName]"
+                      listView.adapter = SimpleListAdapter(
+                        R.layout.leak_canary_simple_row, matchingClasses
+                      ) { view, position ->
+                        val itemTitleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
+                        itemTitleView.text = matchingClasses[position].name
+                      }
+                      listView.setOnItemClickListener { _, _, position, _ ->
+                        val selectedClass = matchingClasses[position]
+                        showClass(titleView, listView, selectedClass)
+                      }
+                    }
+                  }
+                }
+              }
+              .setNegativeButton(android.R.string.cancel, null)
+              .show()
+          }
+        }
+      }
+    }
+
+  private fun View.showClass(
+    titleView: TextView,
+    listView: ListView,
+    selectedClass: HeapClass
+  ) {
+    executeOnIo {
+      val className = selectedClass.name
+      val instances = selectedClass.directInstances.toList()
+      val staticFields = selectedClass.readStaticFields()
+        .fieldsAsString()
+      updateUi {
+        titleView.text =
+          "Class $className (${instances.size} instances)"
+        listView.adapter = SimpleListAdapter(
+          R.layout.leak_canary_simple_row, staticFields + instances
+        ) { view, position ->
+          val itemTitleView =
+            view.findViewById<TextView>(R.id.leak_canary_row_text)
+          if (position < staticFields.size) {
+            itemTitleView.text = staticFields[position].second
+          } else {
+            itemTitleView.text = "@${instances[position - staticFields.size].objectId}"
+          }
+        }
+        listView.setOnItemClickListener { _, _, position, _ ->
+          if (position < staticFields.size) {
+            val staticField = staticFields[position].first
+            onHeapValueClicked(titleView, listView, staticField.value)
+          } else {
+            val instance = instances[position - staticFields.size]
+            showInstance(titleView, listView, instance)
+          }
+        }
+      }
+    }
+  }
+
+  private fun View.showInstance(
+    titleView: TextView,
+    listView: ListView,
+    instance: HeapInstance
+  ) {
+    executeOnIo {
+      val fields = instance.readFields()
+        .fieldsAsString()
+      val className = instance.instanceClassName
+      updateUi {
+        titleView.text = "Instance @${instance.objectId} of class $className"
+        listView.adapter = SimpleListAdapter(
+          R.layout.leak_canary_simple_row, fields
+        ) { view, position ->
+          val itemTitleView =
+            view.findViewById<TextView>(R.id.leak_canary_row_text)
+          itemTitleView.text = fields[position].second
+        }
+        listView.setOnItemClickListener { _, _, position, _ ->
+          val field = fields[position].first
+          onHeapValueClicked(titleView, listView, field.value)
+        }
+      }
+    }
+  }
+
+  private fun View.showObjectArray(
+    titleView: TextView,
+    listView: ListView,
+    instance: HeapObjectArray
+  ) {
+    executeOnIo {
+      val elements = instance.readElements()
+        .mapIndexed { index: Int, element: HeapValue ->
+          element to "[$index] = ${element.heapValueAsString()}"
+        }
+        .toList()
+      val arrayClassName = instance.arrayClassName
+      val className = arrayClassName.substring(0, arrayClassName.length - 2)
+      updateUi {
+        titleView.text = "Array $className[${elements.size}]"
+        listView.adapter = SimpleListAdapter(
+          R.layout.leak_canary_simple_row, elements
+        ) { view, position ->
+          val itemTitleView =
+            view.findViewById<TextView>(R.id.leak_canary_row_text)
+          itemTitleView.text = elements[position].second
+        }
+        listView.setOnItemClickListener { _, _, position, _ ->
+          val element = elements[position].first
+          onHeapValueClicked(titleView, listView, element)
+        }
+      }
+    }
+  }
+
+  private fun View.showPrimitiveArray(
+    titleView: TextView,
+    listView: ListView,
+    instance: HeapPrimitiveArray
+  ) {
+    executeOnIo {
+      val (type, values) = when (val record = instance.readRecord()) {
+        is BooleanArrayDump -> "boolean" to record.array.map { it.toString() }
+        is CharArrayDump -> "char" to record.array.map { "'$it'" }
+        is FloatArrayDump -> "float" to record.array.map { it.toString() }
+        is DoubleArrayDump -> "double" to record.array.map { it.toString() }
+        is ByteArrayDump -> "byte" to record.array.map { it.toString() }
+        is ShortArrayDump -> "short" to record.array.map { it.toString() }
+        is IntArrayDump -> "int" to record.array.map { it.toString() }
+        is LongArrayDump -> "long" to record.array.map { it.toString() }
+      }
+      updateUi {
+        titleView.text = "Array $type[${values.size}]"
+        listView.adapter = SimpleListAdapter(
+          R.layout.leak_canary_simple_row, values
+        ) { view, position ->
+          val itemTitleView =
+            view.findViewById<TextView>(R.id.leak_canary_row_text)
+          itemTitleView.text = "$type ${values[position]}"
+        }
+        listView.setOnItemClickListener { _, _, _, _ ->
+        }
+      }
+    }
+  }
+
+  private fun View.onHeapValueClicked(
+    titleView: TextView,
+    listView: ListView,
+    heapValue: HeapValue
+  ) {
+    if (heapValue.isNonNullReference) {
+      when (val objectRecord = heapValue.asObject!!) {
+        is HeapInstance -> {
+          showInstance(titleView, listView, objectRecord)
+        }
+        is HeapClass -> {
+          showClass(titleView, listView, objectRecord)
+        }
+        is HeapObjectArray -> {
+          showObjectArray(titleView, listView, objectRecord)
+        }
+        is HeapPrimitiveArray -> {
+          showPrimitiveArray(titleView, listView, objectRecord)
+        }
+      }
+    }
+  }
+
+  private fun Sequence<HeapField>.fieldsAsString(): List<Pair<HeapField, String>> {
+    return map { field ->
+      field to "${field.declaringClass.simpleName}.${field.name} = ${field.value.heapValueAsString()}"
+    }
+      .toList()
+  }
+
+  private fun HeapValue.heapValueAsString(): String {
+    return when (val heapValue = holder) {
+      is ReferenceHolder -> {
+        if (isNullReference) {
+          "null"
+        } else {
+          when (val objectRecord = asObject!!) {
+            is HeapInstance -> {
+              if (objectRecord instanceOf "java.lang.String") {
+                "${objectRecord.instanceClassName}@${heapValue.value} \"${objectRecord.readAsJavaString()!!}\""
+              } else {
+                "${objectRecord.instanceClassName}@${heapValue.value}"
+              }
+            }
+            is HeapClass -> {
+              "Class ${objectRecord.name}"
+            }
+            is HeapObjectArray -> {
+              objectRecord.arrayClassName
+            }
+            is HeapPrimitiveArray -> objectRecord.arrayClassName
+          }
+        }
+      }
+      is BooleanHolder -> "boolean ${heapValue.value}"
+      is CharHolder -> "char ${heapValue.value}"
+      is FloatHolder -> "float ${heapValue.value}"
+      is DoubleHolder -> "double ${heapValue.value}"
+      is ByteHolder -> "byte ${heapValue.value}"
+      is ShortHolder -> "short ${heapValue.value}"
+      is IntHolder -> "int ${heapValue.value}"
+      is LongHolder -> "long ${heapValue.value}"
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakScreen.kt
new file mode 100644
index 00000000..d8483006
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakScreen.kt
@@ -0,0 +1,270 @@
+package leakcanary.internal.activity.screen
+
+import android.text.Html
+import android.text.SpannableStringBuilder
+import android.util.Patterns
+import android.view.View
+import android.view.ViewGroup
+import android.widget.AdapterView
+import android.widget.AdapterView.OnItemSelectedListener
+import android.widget.ListView
+import android.widget.Spinner
+import android.widget.TextView
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.DisplayLeakAdapter
+import leakcanary.internal.SquigglySpan
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.LeakTable
+import leakcanary.internal.activity.db.LeakTable.LeakProjection
+import leakcanary.internal.activity.db.LeakTable.LeakTraceProjection
+import leakcanary.internal.activity.db.executeOnDb
+import leakcanary.internal.activity.share
+import leakcanary.internal.activity.shareHeapDump
+import leakcanary.internal.activity.shareToStackOverflow
+import leakcanary.internal.activity.ui.SimpleListAdapter
+import leakcanary.internal.activity.ui.TimeFormatter
+import leakcanary.internal.activity.ui.UiUtils.replaceUrlSpanWithAction
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.goTo
+import leakcanary.internal.navigation.inflate
+import shark.HeapAnalysisSuccess
+import shark.LeakTrace
+import shark.LibraryLeak
+import shark.SharkLog
+
+internal class LeakScreen(
+  private val leakSignature: String,
+  private val selectedHeapAnalysisId: Long? = null
+) : Screen() {
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_leak_screen)
+      .apply {
+        activity.title = resources.getString(R.string.leak_canary_loading_title)
+        executeOnDb {
+          val leak = LeakTable.retrieveLeakBySignature(db, leakSignature)
+
+          if (leak == null) {
+            updateUi {
+              activity.title = resources.getString(R.string.leak_canary_leak_not_found)
+            }
+          } else {
+            val selectedLeakIndex =
+              if (selectedHeapAnalysisId == null) 0 else leak.leakTraces.indexOfFirst { it.heapAnalysisId == selectedHeapAnalysisId }
+
+            if (selectedLeakIndex != -1) {
+              val heapAnalysisId = leak.leakTraces[selectedLeakIndex].heapAnalysisId
+              val selectedHeapAnalysis =
+                HeapAnalysisTable.retrieve<HeapAnalysisSuccess>(db, heapAnalysisId)!!
+
+              updateUi {
+                onLeaksRetrieved(leak, selectedLeakIndex, selectedHeapAnalysis)
+              }
+            } else {
+              // This can happen if a delete was enqueued and is slow and the user tapped on a leak
+              // row before the deletion is perform and the UI update that leaves the screen
+              // executes.
+              updateUi {
+                activity.title = "Selected heap analysis deleted"
+              }
+            }
+            LeakTable.markAsRead(db, leakSignature)
+          }
+        }
+      }
+
+  private fun View.onLeaksRetrieved(
+    leak: LeakProjection,
+    selectedLeakTraceIndex: Int,
+    selectedHeapAnalysis: HeapAnalysisSuccess
+  ) {
+    val isLibraryLeak = leak.isLibraryLeak
+    val isNew = leak.isNew
+    val newChipView = findViewById<TextView>(R.id.leak_canary_chip_new)
+    val libraryLeakChipView = findViewById<TextView>(R.id.leak_canary_chip_library_leak)
+    newChipView.visibility = if (isNew) View.VISIBLE else View.GONE
+    libraryLeakChipView.visibility = if (isLibraryLeak) View.VISIBLE else View.GONE
+
+    activity.title = String.format(
+      resources.getQuantityText(
+        R.plurals.leak_canary_group_screen_title, leak.leakTraces.size
+      )
+        .toString(), leak.leakTraces.size, leak.shortDescription
+    )
+
+    val singleLeakTraceRow = findViewById<View>(R.id.leak_canary_single_leak_trace_row)
+    val spinner = findViewById<Spinner>(R.id.leak_canary_spinner)
+
+    if (leak.leakTraces.size == 1) {
+      spinner.visibility = View.GONE
+
+      val leakTrace = leak.leakTraces.first()
+
+      bindSimpleRow(singleLeakTraceRow, leakTrace)
+      onLeakTraceSelected(selectedHeapAnalysis, leakTrace.heapAnalysisId, leakTrace.leakTraceIndex)
+    } else {
+      singleLeakTraceRow.visibility = View.GONE
+
+      spinner.adapter =
+        SimpleListAdapter(R.layout.leak_canary_simple_row, leak.leakTraces) { view, position ->
+          bindSimpleRow(view, leak.leakTraces[position])
+        }
+
+      var lastSelectedLeakTraceIndex = selectedLeakTraceIndex
+      var lastSelectedHeapAnalysis = selectedHeapAnalysis
+
+      spinner.onItemSelectedListener = object : OnItemSelectedListener {
+        override fun onNothingSelected(parent: AdapterView<*>?) {
+        }
+
+        override fun onItemSelected(
+          parent: AdapterView<*>?,
+          view: View?,
+          position: Int,
+          id: Long
+        ) {
+          val selectedLeakTrace = leak.leakTraces[position]
+
+          val selectedHeapAnalysisId = selectedLeakTrace.heapAnalysisId
+          val lastSelectedHeapAnalysisId =
+            leak.leakTraces[lastSelectedLeakTraceIndex].heapAnalysisId
+
+          if (selectedHeapAnalysisId != lastSelectedHeapAnalysisId) {
+            executeOnDb {
+              val newSelectedHeapAnalysis =
+                HeapAnalysisTable.retrieve<HeapAnalysisSuccess>(db, selectedHeapAnalysisId)!!
+              updateUi {
+                lastSelectedLeakTraceIndex = position
+                lastSelectedHeapAnalysis = newSelectedHeapAnalysis
+                onLeakTraceSelected(
+                  newSelectedHeapAnalysis, selectedHeapAnalysisId,
+                  selectedLeakTrace.leakTraceIndex
+                )
+              }
+            }
+          } else {
+            lastSelectedLeakTraceIndex = position
+            onLeakTraceSelected(
+              lastSelectedHeapAnalysis, selectedHeapAnalysisId, selectedLeakTrace.leakTraceIndex
+            )
+          }
+        }
+      }
+      spinner.setSelection(selectedLeakTraceIndex)
+    }
+  }
+
+  private fun bindSimpleRow(
+    view: View,
+    leakTrace: LeakTraceProjection
+  ) {
+    val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
+    val timeView = view.findViewById<TextView>(R.id.leak_canary_row_small_text)
+
+    titleView.text =
+      view.resources.getString(R.string.leak_canary_class_has_leaked, leakTrace.classSimpleName)
+    timeView.text = TimeFormatter.formatTimestamp(view.context, leakTrace.createdAtTimeMillis)
+  }
+
+  private fun parseLinks(str: String): String {
+    val words = str.split(" ")
+    var parsedString = ""
+    for (word in words) {
+      parsedString += if (Patterns.WEB_URL.matcher(word)
+          .matches()
+      ) {
+        "<a href=\"${word}\">${word}</a>"
+      } else {
+        word
+      }
+      if (words.indexOf(word) != words.size - 1) parsedString += " "
+    }
+    return parsedString
+  }
+
+  private fun View.onLeakTraceSelected(
+    analysis: HeapAnalysisSuccess,
+    heapAnalysisId: Long,
+    leakTraceIndex: Int
+  ) {
+    val selectedLeak = analysis.allLeaks.first { it.signature == leakSignature }
+    val leakTrace = selectedLeak.leakTraces[leakTraceIndex]
+
+    val listView = findViewById<ListView>(R.id.leak_canary_list)
+    listView.alpha = 0f
+    listView.animate()
+      .alpha(1f)
+
+    val titleText = """
+      Open <a href="open_analysis">Heap Dump</a><br><br>
+      Share leak trace <a href="share">as text</a> or on <a href="share_stack_overflow">Stack Overflow</a><br><br>
+      Print leak trace <a href="print">to Logcat</a> (tag: LeakCanary)<br><br>
+      Share <a href="share_hprof">Heap Dump file</a><br><br>
+      References <b><u>underlined</u></b> are the likely causes of the leak.
+      Learn more at <a href="https://squ.re/leaks">https://squ.re/leaks</a>
+    """.trimIndent() + if (selectedLeak is LibraryLeak) "<br><br>" +
+      "A <font color='#FFCC32'>Library Leak</font> is a leak caused by a known bug in 3rd party code that you do not have control over. " +
+      "(<a href=\"https://square.github.io/leakcanary/fundamentals-how-leakcanary-works/#4-categorizing-leaks\">Learn More</a>)<br><br>" +
+      "<b>Leak pattern</b>: ${selectedLeak.pattern}<br><br>" +
+      "<b>Description</b>: ${parseLinks(selectedLeak.description)}" else ""
+
+    val title = Html.fromHtml(titleText) as SpannableStringBuilder
+    SquigglySpan.replaceUnderlineSpans(title, context)
+
+    replaceUrlSpanWithAction(title) { urlSpan ->
+      when (urlSpan) {
+        "share" -> {
+          {
+            share(LeakTraceWrapper.wrap(leakToString(leakTrace, analysis), 80))
+          }
+        }
+        "share_stack_overflow" -> {
+          {
+            shareToStackOverflow(LeakTraceWrapper.wrap(leakToString(leakTrace, analysis), 80))
+          }
+        }
+        "print" -> {
+          {
+            SharkLog.d {
+              "\u200B\n" + LeakTraceWrapper.wrap(
+                leakToString(leakTrace, analysis), 120
+              )
+            }
+          }
+        }
+        "open_analysis" -> {
+          {
+            goTo(HeapDumpScreen(heapAnalysisId))
+          }
+        }
+        "share_hprof" -> {
+          {
+            shareHeapDump(analysis.heapDumpFile)
+          }
+        }
+        else -> null
+      }
+    }
+
+    val adapter = DisplayLeakAdapter(context, leakTrace, title)
+    listView.adapter = adapter
+  }
+
+  private fun leakToString(
+    leakTrace: LeakTrace,
+    analysis: HeapAnalysisSuccess
+  ) = """$leakTrace
+
+METADATA
+
+${
+    if (analysis.metadata.isNotEmpty()) {
+      analysis.metadata
+        .map { "${it.key}: ${it.value}" }
+        .joinToString("\n")
+    } else {
+      ""
+    }
+  }
+Analysis duration: ${analysis.analysisDurationMillis} ms"""
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakTraceWrapper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakTraceWrapper.kt
new file mode 100644
index 00000000..01feefd7
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakTraceWrapper.kt
@@ -0,0 +1,166 @@
+package leakcanary.internal.activity.screen
+
+/**
+ * Performs word wrapping of leak traces.
+ */
+internal object LeakTraceWrapper {
+  private const val SPACE = '\u0020'
+  private const val TILDE = '\u007E'
+  private const val PERIOD = '\u002E'
+  private const val ZERO_SPACE_WIDTH = '\u200B'
+
+  /**
+   * This implements a greedy wrapping algorithm.
+   *
+   * Each line that is longer than [maxWidth], is wrapped by taking the maximum amount of words that fit
+   * within the bounds delimited by [maxWidth]. This is done by walking back from the character at [maxWidth]
+   * position, until the first separator is found (a [SPACE] or [PERIOD]).
+   *
+   * Additionally, [Underline] characters are tracked and added when necessary.
+   *
+   * Finally, all lines start with an offset which includes a decorator character and some level of
+   * indentation.
+   */
+  fun wrap(
+    sourceMultilineString: String,
+    maxWidth: Int
+  ): String {
+    // Lines without terminating line separators
+    val linesNotWrapped = sourceMultilineString.lines()
+
+    val linesWrapped = mutableListOf<String>()
+
+    for (currentLineIndex in linesNotWrapped.indices) {
+      val currentLine = linesNotWrapped[currentLineIndex]
+
+      if (TILDE in currentLine) {
+        check(currentLineIndex > 0) {
+          "A $TILDE character cannot be placed on the first line of a leak trace"
+        }
+        continue
+      }
+
+      val nextLineWithUnderline = if (currentLineIndex < linesNotWrapped.lastIndex) {
+        linesNotWrapped[currentLineIndex + 1].run { if (TILDE in this) this else null }
+      } else null
+
+      val currentLineTrimmed = currentLine.trimEnd()
+      if (currentLineTrimmed.length <= maxWidth) {
+        linesWrapped += currentLineTrimmed
+        if (nextLineWithUnderline != null) {
+          linesWrapped += nextLineWithUnderline
+        }
+      } else {
+        linesWrapped += wrapLine(currentLineTrimmed, nextLineWithUnderline, maxWidth)
+      }
+    }
+    return linesWrapped.joinToString(separator = "\n") { it.trimEnd() }
+  }
+
+  private fun wrapLine(
+    currentLine: String,
+    nextLineWithUnderline: String?,
+    maxWidth: Int
+  ): List<String> {
+
+    val twoCharPrefixes = mapOf(
+      "â”œâ”€" to "â”‚ ",
+      "â”‚ " to "â”‚ ",
+      "â•°â†’" to "$ZERO_SPACE_WIDTH ",
+      "$ZERO_SPACE_WIDTH " to "$ZERO_SPACE_WIDTH "
+    )
+
+    val twoCharPrefix = currentLine.substring(0, 2)
+    val prefixPastFirstLine: String
+    val prefixFirstLine: String
+    if (twoCharPrefix in twoCharPrefixes) {
+      val indexOfFirstNonWhitespace =
+        2 + currentLine.substring(2).indexOfFirst { !it.isWhitespace() }
+      prefixFirstLine = currentLine.substring(0, indexOfFirstNonWhitespace)
+      prefixPastFirstLine =
+        twoCharPrefixes[twoCharPrefix] + currentLine.substring(2, indexOfFirstNonWhitespace)
+    } else {
+      prefixFirstLine = ""
+      prefixPastFirstLine = ""
+    }
+
+    var lineRemainingChars = currentLine.substring(prefixFirstLine.length)
+
+    val maxWidthWithoutOffset = maxWidth - prefixFirstLine.length
+
+    val lineWrapped = mutableListOf<String>()
+    var periodsFound = 0
+
+    var updatedUnderlineStart: Int
+    val underlineStart: Int
+
+    if (nextLineWithUnderline != null) {
+      underlineStart = nextLineWithUnderline.indexOf(TILDE)
+      updatedUnderlineStart = underlineStart - prefixFirstLine.length
+    } else {
+      underlineStart = -1
+      updatedUnderlineStart = -1
+    }
+
+    var underlinedLineIndex = -1
+    while (lineRemainingChars.isNotEmpty() && lineRemainingChars.length > maxWidthWithoutOffset) {
+      val stringBeforeLimit = lineRemainingChars.substring(0, maxWidthWithoutOffset)
+
+      val lastIndexOfSpace = stringBeforeLimit.lastIndexOf(SPACE)
+      val lastIndexOfPeriod = stringBeforeLimit.lastIndexOf(PERIOD)
+
+      val lastIndexOfCurrentLine = lastIndexOfSpace.coerceAtLeast(lastIndexOfPeriod).let {
+        if (it == -1) {
+          stringBeforeLimit.lastIndex
+        } else {
+          it
+        }
+      }
+
+      if (lastIndexOfCurrentLine == lastIndexOfPeriod) {
+        periodsFound++
+      }
+
+      val wrapIndex = lastIndexOfCurrentLine + 1
+
+      // remove spaces at the end if any
+      lineWrapped += stringBeforeLimit.substring(0, wrapIndex).trimEnd()
+
+      // This line has an underline and we haven't find its new position after wrapping yet.
+      if (nextLineWithUnderline != null && underlinedLineIndex == -1) {
+        if (lastIndexOfCurrentLine < updatedUnderlineStart) {
+          updatedUnderlineStart -= wrapIndex
+        } else {
+          underlinedLineIndex = lineWrapped.lastIndex
+        }
+      }
+
+      lineRemainingChars = lineRemainingChars.substring(wrapIndex, lineRemainingChars.length)
+    }
+
+    // there are still residual words to be added, if we exit the loop with a non-empty line
+    if (lineRemainingChars.isNotEmpty()) {
+      lineWrapped += lineRemainingChars
+    }
+
+    if (nextLineWithUnderline != null) {
+      if (underlinedLineIndex == -1) {
+        underlinedLineIndex = lineWrapped.lastIndex
+      }
+      val underlineEnd = nextLineWithUnderline.lastIndexOf(TILDE)
+      val underlineLength = underlineEnd - underlineStart + 1
+
+      val spacesBeforeTilde = "$SPACE".repeat(updatedUnderlineStart)
+      val underlineTildes = "$TILDE".repeat(underlineLength)
+      lineWrapped.add(underlinedLineIndex + 1, "$spacesBeforeTilde$underlineTildes")
+    }
+
+    return lineWrapped.mapIndexed { index: Int, line: String ->
+      (if (index == 0) {
+        prefixFirstLine
+      } else {
+        prefixPastFirstLine
+      } + line).trimEnd()
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeaksScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeaksScreen.kt
new file mode 100644
index 00000000..96299681
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeaksScreen.kt
@@ -0,0 +1,74 @@
+package leakcanary.internal.activity.screen
+
+import android.view.View
+import android.view.View.GONE
+import android.view.View.VISIBLE
+import android.view.ViewGroup
+import android.widget.ListView
+import android.widget.TextView
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.LeakTable
+import leakcanary.internal.activity.db.LeakTable.AllLeaksProjection
+import leakcanary.internal.activity.db.executeOnDb
+import leakcanary.internal.activity.ui.SimpleListAdapter
+import leakcanary.internal.activity.ui.TimeFormatter
+import leakcanary.internal.navigation.NavigatingActivity
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.goTo
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.navigation.onScreenExiting
+
+internal class LeaksScreen : Screen() {
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_list).apply {
+
+      val unsubscribeRefresh = HeapAnalysisTable.onUpdate {
+        activity<NavigatingActivity>().refreshCurrentScreen()
+      }
+
+      onScreenExiting { unsubscribeRefresh() }
+
+      executeOnDb {
+        val projections = LeakTable.retrieveAllLeaks(db)
+        updateUi { onGroupsRetrieved(projections) }
+      }
+    }
+
+  private fun View.onGroupsRetrieved(projections: List<AllLeaksProjection>) {
+    activity.title = resources.getQuantityString(
+      R.plurals.leak_canary_distinct_leaks,
+      projections.size, projections.size
+    )
+
+    val listView = findViewById<ListView>(R.id.leak_canary_list)
+
+    listView.adapter =
+      SimpleListAdapter(R.layout.leak_canary_leak_row, projections) { view, position ->
+        val countView = view.findViewById<TextView>(R.id.leak_canary_count_text)
+        val descriptionView = view.findViewById<TextView>(R.id.leak_canary_leak_text)
+        val timeView = view.findViewById<TextView>(R.id.leak_canary_time_text)
+        val newChipView = view.findViewById<TextView>(R.id.leak_canary_chip_new)
+        val libraryLeakChipView = view.findViewById<TextView>(R.id.leak_canary_chip_library_leak)
+
+        val projection = projections[position]
+        countView.isEnabled = projection.isNew
+
+        newChipView.visibility = if (projection.isNew) VISIBLE else GONE
+        libraryLeakChipView.visibility = if (projection.isLibraryLeak) VISIBLE else GONE
+
+        countView.text = projection.leakTraceCount.toString()
+        descriptionView.text = projection.shortDescription
+
+        val formattedDate =
+          TimeFormatter.formatTimestamp(view.context, projection.createdAtTimeMillis)
+        timeView.text =
+          resources.getString(R.string.leak_canary_group_list_time_label, formattedDate)
+      }
+
+    listView.setOnItemClickListener { _, _, position, _ ->
+      goTo(LeakScreen(projections[position].signature))
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
new file mode 100644
index 00000000..b5bc7d03
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
@@ -0,0 +1,149 @@
+package leakcanary.internal.activity.screen
+
+import android.content.Intent
+import android.graphics.Bitmap
+import android.os.Build.VERSION
+import android.os.Build.VERSION_CODES
+import android.os.Environment
+import android.os.Environment.DIRECTORY_DOWNLOADS
+import android.view.View
+import android.view.ViewGroup
+import android.view.ViewTreeObserver.OnGlobalLayoutListener
+import android.widget.ImageView
+import android.widget.Toast
+import com.squareup.leakcanary.core.R
+import java.io.File
+import java.io.FileOutputStream
+import java.io.IOException
+import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.LeakCanaryFileProvider
+import leakcanary.internal.activity.db.executeOnIo
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.inflate
+import leakcanary.internal.navigation.onCreateOptionsMenu
+import leakcanary.internal.utils.humanReadableByteCount
+import shark.SharkLog
+
+internal class RenderHeapDumpScreen(
+  private val heapDumpFile: File
+) : Screen() {
+
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_heap_render).apply {
+      container.activity.title = resources.getString(R.string.leak_canary_loading_title)
+
+      executeOnIo {
+        val byteCount = humanReadableByteCount(heapDumpFile.length(), si = true)
+        updateUi {
+          container.activity.title =
+            resources.getString(R.string.leak_canary_heap_dump_screen_title, byteCount)
+        }
+      }
+
+      val loadingView = findViewById<View>(R.id.leak_canary_loading)
+      val imageView = findViewById<ImageView>(R.id.leak_canary_heap_rendering)
+
+      viewTreeObserver.addOnGlobalLayoutListener(object : OnGlobalLayoutListener {
+        override fun onGlobalLayout() {
+
+          executeOnIo {
+            val bitmap = HeapDumpRenderer.render(
+              context, heapDumpFile, measuredWidth, measuredHeight, 0
+            )
+            updateUi {
+              imageView.setImageBitmap(bitmap)
+              loadingView.visibility = View.GONE
+              imageView.visibility = View.VISIBLE
+            }
+          }
+          if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN) {
+            viewTreeObserver.removeOnGlobalLayoutListener(this)
+          } else {
+            viewTreeObserver.removeGlobalOnLayoutListener(this)
+          }
+        }
+      })
+
+      onCreateOptionsMenu { menu ->
+        menu.add(R.string.leak_canary_options_menu_generate_hq_bitmap)
+          .setOnMenuItemClickListener {
+            val leakDirectoryProvider = InternalLeakCanary.createLeakDirectoryProvider(context)
+            if (!leakDirectoryProvider.hasStoragePermission()) {
+              Toast.makeText(
+                context,
+                R.string.leak_canary_options_menu_permission_toast,
+                Toast.LENGTH_LONG
+              )
+                .show()
+              leakDirectoryProvider.requestWritePermissionNotification()
+            } else {
+              Toast.makeText(
+                context,
+                R.string.leak_canary_generating_hq_bitmap_toast_notice,
+                Toast.LENGTH_LONG
+              )
+                .show()
+              executeOnIo {
+                val bitmap = HeapDumpRenderer.render(context, heapDumpFile, 2048, 0, 4)
+                @Suppress("DEPRECATION") val storageDir =
+                  Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)
+
+                val imageFile = File(storageDir, "${heapDumpFile.name}.png")
+                val saved = savePng(imageFile, bitmap)
+                if (saved) {
+                  SharkLog.d { "Png saved at $imageFile" }
+                  imageFile.setReadable(true, false)
+                  val imageUri = LeakCanaryFileProvider.getUriForFile(
+                    activity,
+                    "com.squareup.leakcanary.fileprovider." + activity.packageName,
+                    imageFile
+                  )
+
+                  updateUi {
+                    val intent = Intent(Intent.ACTION_SEND)
+                    intent.type = "image/png"
+                    intent.putExtra(Intent.EXTRA_STREAM, imageUri)
+                    activity.startActivity(
+                      Intent.createChooser(
+                        intent,
+                        resources.getString(
+                          R.string.leak_canary_share_heap_dump_bitmap_screen_title
+                        )
+                      )
+                    )
+                  }
+                } else {
+                  updateUi {
+                    Toast.makeText(
+                      context,
+                      R.string.leak_canary_generating_hq_bitmap_toast_failure_notice,
+                      Toast.LENGTH_LONG
+                    )
+                      .show()
+                  }
+                }
+              }
+            }
+            true
+          }
+      }
+    }
+
+  fun savePng(
+    imageFile: File,
+    source: Bitmap
+  ): Boolean {
+    var outStream: FileOutputStream? = null
+    return try {
+      outStream = imageFile.outputStream()
+      source.compress(Bitmap.CompressFormat.PNG, 100, outStream)
+      true
+    } catch (e: IOException) {
+      false
+    } finally {
+      outStream?.close()
+    }
+  }
+}
+
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
new file mode 100644
index 00000000..43ce0128
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
@@ -0,0 +1,28 @@
+package leakcanary.internal.activity.ui
+
+import android.view.View
+import android.view.ViewGroup
+import android.widget.BaseAdapter
+import leakcanary.internal.navigation.inflate
+
+internal class SimpleListAdapter<T>(
+  private val rowResId: Int,
+  private val items: List<T>,
+  private val bindView: SimpleListAdapter<T>.(View, Int) -> Unit
+) : BaseAdapter() {
+  override fun getView(
+    position: Int,
+    convertView: View?,
+    parent: ViewGroup
+  ): View {
+    val view = convertView ?: parent.inflate(rowResId)
+    bindView(view, position)
+    return view
+  }
+
+  override fun getItem(position: Int) = items[position]
+
+  override fun getItemId(position: Int) = position.toLong()
+
+  override fun getCount() = items.size
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/TimeFormatter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/TimeFormatter.kt
new file mode 100644
index 00000000..97fbe5e5
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/TimeFormatter.kt
@@ -0,0 +1,49 @@
+package leakcanary.internal.activity.ui
+
+import android.content.Context
+import android.text.format.DateUtils
+
+internal object TimeFormatter {
+
+  private const val MINUTE_MILLIS = 60 * 1000
+  private const val TWO_MINUTES_MILLIS = 2 * MINUTE_MILLIS
+  private const val FIFTY_MINUTES_MILLIS = 50 * MINUTE_MILLIS
+  private const val NINETY_MINUTES_MILLIS = 90 * MINUTE_MILLIS
+  private const val HOUR_MILLIS = 60 * MINUTE_MILLIS
+  private const val DAY_MILLIS = 24 * HOUR_MILLIS
+  private const val TWO_DAYS_MILLIS = 48 * HOUR_MILLIS
+
+  fun formatTimestamp(
+    context: Context,
+    timestampMillis: Long
+  ): String {
+    // Based on https://stackoverflow.com/a/13018647
+    val nowMillis = System.currentTimeMillis()
+    return when (val diff = nowMillis - timestampMillis) {
+      in 0..MINUTE_MILLIS -> {
+        "just now"
+      }
+      in MINUTE_MILLIS..TWO_MINUTES_MILLIS -> {
+        "a minute ago"
+      }
+      in TWO_MINUTES_MILLIS..FIFTY_MINUTES_MILLIS -> {
+        "${diff / MINUTE_MILLIS} minutes ago"
+      }
+      in FIFTY_MINUTES_MILLIS..NINETY_MINUTES_MILLIS -> {
+        "an hour ago"
+      }
+      in NINETY_MINUTES_MILLIS..DAY_MILLIS -> {
+        "${diff / HOUR_MILLIS} hours ago"
+      }
+      in DAY_MILLIS..TWO_DAYS_MILLIS -> {
+        "yesterday"
+      }
+      else -> {
+        DateUtils.formatDateTime(
+          context, timestampMillis,
+          DateUtils.FORMAT_SHOW_TIME or DateUtils.FORMAT_SHOW_DATE
+        )
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/UiUtils.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/UiUtils.kt
new file mode 100644
index 00000000..92728946
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/UiUtils.kt
@@ -0,0 +1,31 @@
+package leakcanary.internal.activity.ui
+
+import android.text.SpannableStringBuilder
+import android.text.style.ClickableSpan
+import android.text.style.URLSpan
+import android.view.View
+
+internal object UiUtils {
+
+  internal fun replaceUrlSpanWithAction(
+    title: SpannableStringBuilder,
+    urlAction: (String) -> (() -> Unit)?
+  ) {
+    val urlSpans = title.getSpans(0, title.length, URLSpan::class.java)
+    for (span in urlSpans) {
+      val action: (() -> Unit)? = urlAction(span.url)
+      if (action != null) {
+        val start = title.getSpanStart(span)
+        val end = title.getSpanEnd(span)
+        val flags = title.getSpanFlags(span)
+        title.removeSpan(span)
+        val newSpan = object : ClickableSpan() {
+          override fun onClick(widget: View) {
+            action()
+          }
+        }
+        title.setSpan(newSpan, start, end, flags)
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/friendly/Friendly.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/friendly/Friendly.kt
new file mode 100644
index 00000000..db1f83d7
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/friendly/Friendly.kt
@@ -0,0 +1,16 @@
+@file:Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER", "NOTHING_TO_INLINE")
+@file:JvmName("leakcanary-android-core_Friendly")
+
+package leakcanary.internal.friendly
+
+internal inline val mainHandler
+  get() = leakcanary.internal.mainHandler
+
+internal inline fun checkMainThread() = leakcanary.internal.checkMainThread()
+
+internal inline fun checkNotMainThread() = leakcanary.internal.checkNotMainThread()
+
+internal inline fun <reified T : Any> noOpDelegate(): T = leakcanary.internal.noOpDelegate()
+
+internal inline fun measureDurationMillis(block: () -> Unit) =
+  leakcanary.internal.measureDurationMillis(block)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/BackstackFrame.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/BackstackFrame.kt
new file mode 100644
index 00000000..a599172a
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/BackstackFrame.kt
@@ -0,0 +1,66 @@
+package leakcanary.internal.navigation
+
+import android.os.Parcel
+import android.os.Parcelable
+import android.util.SparseArray
+import android.view.View
+
+internal class BackstackFrame : Parcelable {
+
+  val screen: Screen
+  private val viewState: SparseArray<Parcelable>?
+
+  private constructor(
+    source: Parcel
+  ) {
+    this.screen = source.readSerializable() as Screen
+    @Suppress("UNCHECKED_CAST")
+    this.viewState = source.readSparseArray(javaClass.classLoader)
+  }
+
+  constructor(
+    screen: Screen
+  ) {
+    this.screen = screen
+    viewState = null
+  }
+
+  constructor(
+    screen: Screen,
+    view: View
+  ) {
+    this.screen = screen
+    viewState = SparseArray()
+    view.saveHierarchyState(viewState)
+  }
+
+  fun restore(view: View) {
+    if (viewState != null) {
+      view.restoreHierarchyState(viewState)
+    }
+  }
+
+  override fun describeContents() = 0
+
+  @Suppress("UNCHECKED_CAST")
+  override fun writeToParcel(
+    dest: Parcel,
+    flags: Int
+  ) {
+    dest.writeSerializable(screen)
+    dest.writeSparseArray(viewState as SparseArray<Any>?)
+  }
+
+  companion object {
+    @Suppress("UNCHECKED_CAST")
+    @JvmField val CREATOR = object : Parcelable.Creator<BackstackFrame> {
+      override fun createFromParcel(source: Parcel): BackstackFrame {
+        return BackstackFrame(source)
+      }
+
+      override fun newArray(size: Int): Array<BackstackFrame?> {
+        return arrayOfNulls(size)
+      }
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/NavigatingActivity.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/NavigatingActivity.kt
new file mode 100644
index 00000000..31e25c5d
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/NavigatingActivity.kt
@@ -0,0 +1,193 @@
+package leakcanary.internal.navigation
+
+import android.app.Activity
+import android.content.Intent
+import android.os.Build.VERSION.SDK_INT
+import android.os.Bundle
+import android.os.Parcelable
+import android.view.Menu
+import android.view.MenuItem
+import android.view.View
+import android.view.ViewGroup
+import android.view.animation.AnimationUtils.loadAnimation
+import com.squareup.leakcanary.core.R
+
+/**
+ * A simple backstack navigating activity
+ */
+internal abstract class NavigatingActivity : Activity() {
+
+  private lateinit var backstack: ArrayList<BackstackFrame>
+  private lateinit var currentScreen: Screen
+
+  private lateinit var container: ViewGroup
+  private lateinit var currentView: View
+
+  var onCreateOptionsMenu = NO_MENU
+
+  fun installNavigation(
+    savedInstanceState: Bundle?,
+    container: ViewGroup
+  ) {
+    this.container = container
+
+    if (savedInstanceState == null) {
+      backstack = ArrayList()
+      val screens = parseIntentScreens(intent)
+      currentScreen = if (screens.isNotEmpty()) {
+        screens.dropLast(1)
+          .forEach { screen ->
+            backstack.add(BackstackFrame(screen))
+          }
+        screens.last()
+      } else {
+        getLauncherScreen()
+      }
+    } else {
+      currentScreen = savedInstanceState.getSerializable("currentScreen") as Screen
+      @Suppress("UNCHECKED_CAST")
+      backstack = savedInstanceState.getParcelableArrayList<Parcelable>(
+        "backstack"
+      ) as ArrayList<BackstackFrame>
+    }
+    currentView = currentScreen.createView(container)
+    container.addView(currentView)
+
+    actionBar?.run {
+      setHomeButtonEnabled(true)
+      setDisplayHomeAsUpEnabled(true)
+    }
+    screenUpdated()
+  }
+
+  override fun onNewIntent(intent: Intent) {
+    val screens = parseIntentScreens(intent)
+    if (screens.isNotEmpty()) {
+      backstack.clear()
+      screens.dropLast(1)
+        .forEach { screen ->
+          backstack.add(BackstackFrame(screen))
+        }
+      goTo(screens.last())
+    }
+  }
+
+  abstract fun parseIntentScreens(intent: Intent): List<Screen>
+
+  open fun getLauncherScreen(): Screen {
+    TODO("Launcher activities should override getLauncherScreen()")
+  }
+
+  public override fun onSaveInstanceState(outState: Bundle) {
+    super.onSaveInstanceState(outState)
+    outState.putSerializable("currentScreen", currentScreen)
+    outState.putParcelableArrayList("backstack", backstack)
+  }
+
+  override fun onBackPressed() {
+    if (backstack.size > 0) {
+      goBack()
+      return
+    }
+    super.onBackPressed()
+  }
+
+  fun resetTo(screen: Screen) {
+    onCreateOptionsMenu = NO_MENU
+
+    currentView.startAnimation(loadAnimation(this, R.anim.leak_canary_exit_alpha))
+    container.removeView(currentView)
+    currentView.notifyScreenExiting()
+
+    backstack.clear()
+
+    currentScreen = screen
+    currentView = currentScreen.createView(container)
+    currentView.startAnimation(loadAnimation(this, R.anim.leak_canary_enter_alpha))
+    container.addView(currentView)
+
+    screenUpdated()
+  }
+
+  fun goTo(screen: Screen) {
+    onCreateOptionsMenu = NO_MENU
+
+    currentView.startAnimation(loadAnimation(this, R.anim.leak_canary_exit_forward))
+    container.removeView(currentView)
+    currentView.notifyScreenExiting()
+    val backstackFrame = BackstackFrame(currentScreen, currentView)
+    backstack.add(backstackFrame)
+
+    currentScreen = screen
+    currentView = currentScreen.createView(container)
+    currentView.startAnimation(loadAnimation(this, R.anim.leak_canary_enter_forward))
+    container.addView(currentView)
+
+    screenUpdated()
+  }
+
+  fun refreshCurrentScreen() {
+    onCreateOptionsMenu = NO_MENU
+    container.removeView(currentView)
+    currentView.notifyScreenExiting()
+    currentView = currentScreen.createView(container)
+    container.addView(currentView)
+
+    screenUpdated()
+  }
+
+  fun goBack() {
+    onCreateOptionsMenu = NO_MENU
+
+    currentView.startAnimation(loadAnimation(this, R.anim.leak_canary_exit_backward))
+    container.removeView(currentView)
+    currentView.notifyScreenExiting()
+
+    val latest = backstack.removeAt(backstack.size - 1)
+    currentScreen = latest.screen
+    currentView = currentScreen.createView(container)
+    currentView.startAnimation(loadAnimation(this, R.anim.leak_canary_enter_backward))
+    container.addView(currentView, 0)
+    latest.restore(currentView)
+
+    screenUpdated()
+  }
+
+  private fun screenUpdated() {
+    invalidateOptionsMenu()
+    if (SDK_INT >= 18) {
+      actionBar?.run {
+        val goBack = backstack.size > 0
+        val indicator = if (goBack) 0 else android.R.drawable.ic_menu_close_clear_cancel
+        setHomeAsUpIndicator(indicator)
+      }
+    }
+    onNewScreen(currentScreen)
+  }
+
+  protected open fun onNewScreen(screen: Screen) {
+  }
+
+  override fun onCreateOptionsMenu(menu: Menu): Boolean {
+    onCreateOptionsMenu.invoke(menu)
+    return true
+  }
+
+  override fun onOptionsItemSelected(item: MenuItem): Boolean =
+    when (item.itemId) {
+      android.R.id.home -> {
+        onBackPressed()
+        true
+      }
+      else -> super.onOptionsItemSelected(item)
+    }
+
+  override fun onDestroy() {
+    super.onDestroy()
+    currentView.notifyScreenExiting()
+  }
+
+  companion object {
+    val NO_MENU: ((Menu) -> Unit) = {}
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Screen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Screen.kt
new file mode 100644
index 00000000..85c4561f
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Screen.kt
@@ -0,0 +1,14 @@
+package leakcanary.internal.navigation
+
+import android.view.View
+import android.view.ViewGroup
+import java.io.Serializable
+
+/**
+ * Replaces Fragments, MVP, MVC, MVVM, MVMVMVM and everything else in just one tiny class.
+ * A screen is a location to go to, and it can build a view to display.
+ */
+internal abstract class Screen : Serializable {
+
+  abstract fun createView(container: ViewGroup): View
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
new file mode 100644
index 00000000..84a17653
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
@@ -0,0 +1,57 @@
+package leakcanary.internal.navigation
+
+import android.app.Activity
+import android.content.Context
+import android.os.Build.VERSION
+import android.view.LayoutInflater
+import android.view.Menu
+import android.view.View
+import android.view.ViewGroup
+import com.squareup.leakcanary.core.R
+
+internal fun ViewGroup.inflate(layoutResId: Int) = LayoutInflater.from(context)
+  .inflate(layoutResId, this, false)!!
+
+internal val View.activity
+  get() = context as Activity
+
+@Suppress("UNCHECKED_CAST")
+internal fun <T : Activity> View.activity() = context as T
+
+internal fun View.onCreateOptionsMenu(onCreateOptionsMenu: (Menu) -> Unit) {
+  activity<NavigatingActivity>().onCreateOptionsMenu = onCreateOptionsMenu
+  activity.invalidateOptionsMenu()
+}
+
+internal fun View.goTo(screen: Screen) {
+  activity<NavigatingActivity>().goTo(screen)
+}
+
+internal fun View.goBack() {
+  activity<NavigatingActivity>().goBack()
+}
+
+internal fun Context.getColorCompat(id: Int): Int {
+  return if (VERSION.SDK_INT >= 23) {
+    getColor(id)
+  } else {
+    resources.getColor(id)
+  }
+}
+
+internal fun View.onScreenExiting(block: () -> Unit) {
+  @Suppress("UNCHECKED_CAST")
+  var callbacks = getTag(R.id.leak_canary_notification_on_screen_exit) as MutableList<() -> Unit>?
+  if (callbacks == null) {
+    callbacks = mutableListOf()
+    setTag(R.id.leak_canary_notification_on_screen_exit, callbacks)
+  }
+  callbacks.add(block)
+}
+
+internal fun View.notifyScreenExiting() {
+  @Suppress("UNCHECKED_CAST")
+  val callbacks = getTag(R.id.leak_canary_notification_on_screen_exit)
+    as MutableList<() -> Unit>?
+  callbacks?.forEach { it.invoke() }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/tv/TvOnRetainInstanceListener.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/tv/TvOnRetainInstanceListener.kt
new file mode 100644
index 00000000..f05a197f
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/tv/TvOnRetainInstanceListener.kt
@@ -0,0 +1,53 @@
+package leakcanary.internal.tv
+
+import android.app.Application
+import com.squareup.leakcanary.core.R
+import leakcanary.LeakCanary
+import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.OnRetainInstanceListener
+import leakcanary.internal.RetainInstanceEvent
+import leakcanary.internal.RetainInstanceEvent.CountChanged.BelowThreshold
+import leakcanary.internal.RetainInstanceEvent.CountChanged.DumpHappenedRecently
+import leakcanary.internal.RetainInstanceEvent.CountChanged.DumpingDisabled
+import leakcanary.internal.RetainInstanceEvent.NoMoreObjects
+import leakcanary.internal.friendly.mainHandler
+import shark.SharkLog
+
+/**
+ * [OnRetainInstanceListener] implementation for Android TV devices which displays a helpful
+ * Toast message on current state of retained instances.
+ * It will notify user when heap dump is going to happen, so that users who set the
+ * [LeakCanary.Config.retainedVisibleThreshold] to any value other than 1 will be aware of retain
+ * instances changes. Additionally, it notifies about debugger being attached and whether heap dump
+ * happened recently.
+ */
+internal class TvOnRetainInstanceListener(private val application: Application) :
+  OnRetainInstanceListener {
+
+  override fun onEvent(event: RetainInstanceEvent) {
+    val message = when (event) {
+      NoMoreObjects -> {
+        application.getString(R.string.leak_canary_notification_no_retained_object_title)
+      }
+      is BelowThreshold -> {
+        application.getString(
+          R.string.leak_canary_tv_toast_retained_objects,
+          event.retainedCount,
+          LeakCanary.config.retainedVisibleThreshold
+        )
+      }
+      is DumpingDisabled -> {
+        event.reason
+      }
+      is DumpHappenedRecently -> {
+        application.getString(R.string.leak_canary_notification_retained_dump_wait)
+      }
+    }
+    SharkLog.d { message }
+
+    mainHandler.post {
+      val resumedActivity = InternalLeakCanary.resumedActivity ?: return@post
+      TvToast.makeText(resumedActivity, message).show()
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/tv/TvToast.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/tv/TvToast.kt
new file mode 100644
index 00000000..74d63e23
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/tv/TvToast.kt
@@ -0,0 +1,45 @@
+package leakcanary.internal.tv
+
+import android.annotation.SuppressLint
+import android.app.Activity
+import android.content.Context
+import android.view.Gravity
+import android.view.LayoutInflater
+import android.widget.TextView
+import android.widget.Toast
+import com.squareup.leakcanary.core.R
+
+/**
+ * Toast helper for Android TV preconfigured with LeakCanary icon.
+ *
+ * Shows toast with custom view layout, custom toast views are deprecated from API level 30 on (see
+ * [docs](https://developer.android.com/reference/android/widget/Toast#getView()))
+ */
+internal object TvToast {
+
+  /**
+   * Make an Android TV toast.
+   * Don't forget to call [Toast.show] to display the toast!
+   * @param activity Currently resumed [Activity] to display toast on. Note that it's not [Context]
+   *        to prevent passing application context that could lead to crashes on older platforms.
+   * @param text The text to show. Can be formatted text.
+   */
+  @SuppressLint("ShowToast")
+  fun makeText(
+    activity: Activity,
+    text: CharSequence
+  ): Toast {
+    val inflater = LayoutInflater.from(activity)
+    val toast = Toast(activity)
+
+    toast.apply {
+      setGravity(Gravity.CENTER_VERTICAL, 0, 0)
+      duration = Toast.LENGTH_LONG
+      view = inflater.inflate(R.layout.leak_canary_heap_dump_toast, null).also {
+        it.findViewById<TextView>(R.id.leak_canary_toast_text).text = text
+      }
+    }
+
+    return toast
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Size.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Size.kt
new file mode 100644
index 00000000..ac13774a
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Size.kt
@@ -0,0 +1,16 @@
+package leakcanary.internal.utils
+
+import kotlin.math.ln
+import kotlin.math.pow
+
+// https://stackoverflow.com/a/3758880
+internal fun humanReadableByteCount(
+  bytes: Long,
+  si: Boolean
+): String {
+  val unit = if (si) 1000 else 1024
+  if (bytes < unit) return "$bytes B"
+  val exp = (ln(bytes.toDouble()) / ln(unit.toDouble())).toInt()
+  val pre = (if (si) "kMGTPE" else "KMGTPE")[exp - 1] + if (si) "" else "i"
+  return String.format("%.1f %sB", bytes / unit.toDouble().pow(exp.toDouble()), pre)
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Tuples.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Tuples.kt
new file mode 100644
index 00000000..15dfaecb
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Tuples.kt
@@ -0,0 +1,3 @@
+package leakcanary.internal.utils
+
+internal infix fun <A, B, C> Pair<A, B>.to(that: C): Triple<A, B, C> = Triple(first, second, that)
diff --git a/leakcanary-android-core/src/main/res/anim/leak_canary_enter_alpha.xml b/leakcanary-android-core/src/main/res/anim/leak_canary_enter_alpha.xml
new file mode 100644
index 00000000..f0db1e88
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/anim/leak_canary_enter_alpha.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<alpha
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:fromAlpha="0"
+    android:toAlpha="1"
+    android:duration="@android:integer/config_mediumAnimTime"/>
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/res/anim/leak_canary_enter_backward.xml b/leakcanary-android-core/src/main/res/anim/leak_canary_enter_backward.xml
new file mode 100644
index 00000000..d2430eae
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/anim/leak_canary_enter_backward.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<translate
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:fromXDelta="-100%" android:toXDelta="0%"
+    android:fromYDelta="0%" android:toYDelta="0%"
+    android:duration="@android:integer/config_mediumAnimTime"/>
diff --git a/leakcanary-android-core/src/main/res/anim/leak_canary_enter_forward.xml b/leakcanary-android-core/src/main/res/anim/leak_canary_enter_forward.xml
new file mode 100644
index 00000000..1dc5cfc4
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/anim/leak_canary_enter_forward.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<translate
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:fromXDelta="100%" android:toXDelta="0%"
+    android:fromYDelta="0%" android:toYDelta="0%"
+    android:duration="@android:integer/config_mediumAnimTime"/>
diff --git a/leakcanary-android-core/src/main/res/anim/leak_canary_exit_alpha.xml b/leakcanary-android-core/src/main/res/anim/leak_canary_exit_alpha.xml
new file mode 100644
index 00000000..9f2bdb84
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/anim/leak_canary_exit_alpha.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<alpha
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:fromAlpha="1"
+    android:toAlpha="0"
+    android:duration="@android:integer/config_mediumAnimTime"/>
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/res/anim/leak_canary_exit_backward.xml b/leakcanary-android-core/src/main/res/anim/leak_canary_exit_backward.xml
new file mode 100644
index 00000000..7dea9fbf
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/anim/leak_canary_exit_backward.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<translate
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:fromXDelta="0%" android:toXDelta="100%"
+    android:fromYDelta="0%" android:toYDelta="0%"
+    android:duration="@android:integer/config_mediumAnimTime"/>
diff --git a/leakcanary-android-core/src/main/res/anim/leak_canary_exit_forward.xml b/leakcanary-android-core/src/main/res/anim/leak_canary_exit_forward.xml
new file mode 100644
index 00000000..b7292341
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/anim/leak_canary_exit_forward.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<translate
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:fromXDelta="0%" android:toXDelta="-100%"
+    android:fromYDelta="0%" android:toYDelta="0%"
+    android:duration="@android:integer/config_mediumAnimTime"/>
diff --git a/leakcanary-android-core/src/main/res/color/leak_canary_bottom_menu.xml b/leakcanary-android-core/src/main/res/color/leak_canary_bottom_menu.xml
new file mode 100644
index 00000000..65197a4e
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/color/leak_canary_bottom_menu.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+  <item android:state_selected="false" android:color="@color/leak_canary_gray_darkest_40p" />
+  <item android:state_selected="true"  android:color="@color/leak_canary_gray_darkest" />
+</selector>
diff --git a/leakcanary-android-core/src/main/res/color/leak_canary_count_text.xml b/leakcanary-android-core/src/main/res/color/leak_canary_count_text.xml
new file mode 100644
index 00000000..31fc8e29
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/color/leak_canary_count_text.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+  <item android:state_enabled="true" android:color="@color/leak_canary_gray_darkest" />
+  <item android:color="@color/leak_canary_yellow" />
+</selector>
diff --git a/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_gray_fill.xml b/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_gray_fill.xml
new file mode 100644
index 00000000..00d67ea3
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_gray_fill.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ripple xmlns:android="http://schemas.android.com/apk/res/android"
+    android:color="?android:attr/colorControlHighlight">
+    <item android:id="@android:id/mask">
+        <shape>
+            <solid android:color="@color/leak_canary_gray" />
+            <corners android:radius="20dp" />
+        </shape>
+    </item>
+    <item>
+        <shape>
+            <solid android:color="@color/leak_canary_gray" />
+            <corners android:radius="20dp" />
+        </shape>
+    </item>
+</ripple>
diff --git a/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_list_selector.xml b/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_list_selector.xml
new file mode 100644
index 00000000..4bbb9c54
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_list_selector.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_focused="true" android:state_pressed="false">
+        <color android:color="?android:attr/colorControlHighlight" />
+    </item>
+    <item>
+        <color android:color="@android:color/transparent" />
+    </item>
+</selector>
diff --git a/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_primary_button.xml b/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_primary_button.xml
new file mode 100644
index 00000000..67b9d2c6
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_primary_button.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ripple xmlns:android="http://schemas.android.com/apk/res/android"
+    android:color="@color/leak_canary_yellow_button_pressed">
+  <item>
+    <shape>
+      <solid android:color="@color/leak_canary_yellow_button" />
+      <corners android:radius="12dp" />
+    </shape>
+  </item>
+  <item android:id="@android:id/mask">
+    <shape>
+      <solid android:color="@color/leak_canary_yellow_button" />
+      <corners android:radius="12dp" />
+    </shape>
+  </item>
+</ripple>
+
diff --git a/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_secondary_button.xml b/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_secondary_button.xml
new file mode 100644
index 00000000..97cc859a
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_secondary_button.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ripple xmlns:android="http://schemas.android.com/apk/res/android"
+    android:color="@color/leak_canary_gray_6f">
+  <item>
+    <shape>
+      <solid android:color="@color/leak_canary_gray_3f" />
+      <corners android:radius="12dp" />
+    </shape>
+  </item>
+  <item android:id="@android:id/mask">
+    <shape>
+      <solid android:color="@color/leak_canary_gray_3f" />
+      <corners android:radius="12dp" />
+    </shape>
+  </item>
+</ripple>
+
diff --git a/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_tab_background.xml b/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_tab_background.xml
new file mode 100644
index 00000000..11b1bc19
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_tab_background.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+  <item android:drawable="@drawable/leak_canary_tab_selector_ripple" />
+</selector>
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_tab_selector_ripple.xml b/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_tab_selector_ripple.xml
new file mode 100644
index 00000000..3c872694
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable-v21/leak_canary_tab_selector_ripple.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ripple
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:color="@color/leak_canary_gray_darkest_25p"
+    />
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_count_background.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_count_background.xml
new file mode 100644
index 00000000..c78fc7ea
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_count_background.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+  <item android:state_enabled="true">
+    <shape>
+      <solid android:color="@color/leak_canary_count_new" />
+      <corners android:radius="20dp" />
+      <stroke android:width="2dp" android:color="@color/leak_canary_count_new_border" />
+    </shape>
+  </item>
+  <item>
+    <shape>
+      <solid android:color="@color/leak_canary_count_default" />
+      <corners android:radius="20dp" />
+    </shape>
+  </item>
+</selector>
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_dump.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_dump.xml
new file mode 100644
index 00000000..48897d5f
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_dump.xml
@@ -0,0 +1,22 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="23dp"
+    android:viewportWidth="24"
+    android:viewportHeight="23">
+  <path
+      android:pathData="M3.25,5H10.25"
+      android:strokeWidth="2.5"
+      android:fillColor="#00000000"
+      android:strokeColor="#000000"
+      android:strokeLineCap="round"/>
+  <path
+      android:pathData="M2.25,5.25h0.5v2.5h-0.5z"
+      android:strokeWidth="0.5"
+      android:fillColor="#000000"
+      android:strokeColor="#000000"/>
+  <path
+      android:pathData="M3,8C3,6.8954 3.8954,6 5,6H19C20.1046,6 21,6.8954 21,8V16C21,17.1046 20.1046,18 19,18H5C3.8954,18 3,17.1046 3,16V8Z"
+      android:strokeWidth="2"
+      android:fillColor="#00000000"
+      android:strokeColor="#000000"/>
+</vector>
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_gray_fill.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_gray_fill.xml
new file mode 100644
index 00000000..0685b99e
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_gray_fill.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_pressed="true">
+        <shape>
+            <solid android:color="@color/leak_canary_gray_3f" />
+            <corners android:radius="20dp" />
+        </shape>
+    </item>
+    <item>
+        <shape>
+            <solid android:color="@color/leak_canary_gray" />
+            <corners android:radius="20dp" />
+        </shape>
+    </item>
+</selector>
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_icon.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_icon.xml
new file mode 100644
index 00000000..aa225f7a
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_icon.xml
@@ -0,0 +1,17 @@
+<vector android:height="24dp" android:viewportHeight="185"
+    android:viewportWidth="185" android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
+    <group>
+        <clip-path android:pathData="M0,0h185v185h-185z M 0,0"/>
+        <path android:fillColor="#00000000"
+            android:pathData="M55.8327 80.944L68.1676 83.3835M59.6321 89.5079L62.4202 75.4109"
+            android:strokeColor="#151C1F" android:strokeLineCap="round" android:strokeWidth="4.257"/>
+        <path android:fillColor="#F5BD14" android:fillType="evenOdd" android:pathData="M33.0396 88.6436L148.284 41.1702C148.308 41.1931 148.333 41.216 148.357 41.2389C147.773 76.5754 125.2 119.136 72.6948 132.558C66.2444 121.606 47.4716 97.5578 32.6694 89.9372C32.799 89.5158 32.9224 89.0844 33.0396 88.6436Z"/>
+        <path android:fillColor="#F86932" android:pathData="M81.4818 31.7162L72.8251 55.9266L71.7247 54.5065C66.7399 48.0734 60.8251 42.4184 54.1748 37.7274L69.4736 20.6696L68.6881 39.2884L81.4818 31.7162Z"/>
+        <path android:fillColor="#FFCC32" android:pathData="M45.3062,70.8628m-35.1642,0.0a35.1642,35.1642,0,1,1,70.3284,0.0a35.1642,35.1642,0,1,1,-70.3284,0.0"/>
+        <path android:fillColor="#00000000"
+            android:pathData="M44.2972 58.986L56.2444 55.066M51.8067 64.5881L47.3268 50.9342"
+            android:strokeColor="#151C1F" android:strokeLineCap="round" android:strokeWidth="4.257"/>
+        <path android:fillColor="#FFCC32" android:fillType="evenOdd" android:pathData="M10.1416 71.2627C10.4815 113.278 38.6085 151.594 81.1309 162.988C113.627 171.695 146.704 162.582 170.003 141.637C159.823 142.304 149.364 141.343 138.964 138.556C113.428 131.714 93.0844 115.164 80.8316 93.9338L10.1416 71.2627Z"/>
+        <path android:fillColor="#FFCC32" android:fillType="evenOdd" android:pathData="M175.463 56.9136L57.9672 97.0664C57.8158 97.5113 57.6587 97.9458 57.4956 98.3692C71.736 106.994 88.8027 132.282 94.4811 143.653C105.725 141.594 115.73 138.149 124.547 133.665C121.291 132.305 118.248 130.405 115.554 128.011L114.859 127.392C114.033 126.658 113.959 125.394 114.693 124.569C115.427 123.743 116.691 123.669 117.516 124.403L118.212 125.021C121.434 127.886 125.228 129.941 129.286 131.091C130.47 130.405 131.632 129.699 132.769 128.975C130.868 128.149 129.036 127.135 127.302 125.938L126.535 125.409C125.626 124.782 125.398 123.537 126.025 122.627C126.653 121.718 127.898 121.49 128.807 122.117L129.573 122.646C131.83 124.203 134.276 125.407 136.83 126.243C137.942 125.453 139.03 124.644 140.093 123.818C139.482 123.453 138.88 123.067 138.29 122.66L137.524 122.131C136.615 121.504 136.387 120.259 137.014 119.349C137.641 118.44 138.887 118.212 139.796 118.839L140.562 119.368C141.487 120.006 142.444 120.585 143.428 121.104C163.878 103.673 174.394 79.6305 176.271 57.779C176.004 57.4894 175.735 57.2009 175.463 56.9136Z"/>
+    </group>
+</vector>
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_icon_foreground.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_icon_foreground.xml
new file mode 100644
index 00000000..49b7ea7e
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_icon_foreground.xml
@@ -0,0 +1,23 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="108dp"
+    android:height="108dp"
+    android:viewportWidth="336.36365"
+    android:viewportHeight="336.36365">
+  <group android:translateX="75.681816"
+      android:translateY="75.681816">
+      <group>
+          <clip-path android:pathData="M0,0h185v185h-185z M 0,0"/>
+          <path android:fillColor="#00000000"
+              android:pathData="M55.8327 80.944L68.1676 83.3835M59.6321 89.5079L62.4202 75.4109"
+              android:strokeColor="#151C1F" android:strokeLineCap="round" android:strokeWidth="4.257"/>
+          <path android:fillColor="#F5BD14" android:fillType="evenOdd" android:pathData="M33.0396 88.6436L148.284 41.1702C148.308 41.1931 148.333 41.216 148.357 41.2389C147.773 76.5754 125.2 119.136 72.6948 132.558C66.2444 121.606 47.4716 97.5578 32.6694 89.9372C32.799 89.5158 32.9224 89.0844 33.0396 88.6436Z"/>
+          <path android:fillColor="#F86932" android:pathData="M81.4818 31.7162L72.8251 55.9266L71.7247 54.5065C66.7399 48.0734 60.8251 42.4184 54.1748 37.7274L69.4736 20.6696L68.6881 39.2884L81.4818 31.7162Z"/>
+          <path android:fillColor="#FFCC32" android:pathData="M45.3062,70.8628m-35.1642,0.0a35.1642,35.1642,0,1,1,70.3284,0.0a35.1642,35.1642,0,1,1,-70.3284,0.0"/>
+          <path android:fillColor="#00000000"
+              android:pathData="M44.2972 58.986L56.2444 55.066M51.8067 64.5881L47.3268 50.9342"
+              android:strokeColor="#151C1F" android:strokeLineCap="round" android:strokeWidth="4.257"/>
+          <path android:fillColor="#FFCC32" android:fillType="evenOdd" android:pathData="M10.1416 71.2627C10.4815 113.278 38.6085 151.594 81.1309 162.988C113.627 171.695 146.704 162.582 170.003 141.637C159.823 142.304 149.364 141.343 138.964 138.556C113.428 131.714 93.0844 115.164 80.8316 93.9338L10.1416 71.2627Z"/>
+          <path android:fillColor="#FFCC32" android:fillType="evenOdd" android:pathData="M175.463 56.9136L57.9672 97.0664C57.8158 97.5113 57.6587 97.9458 57.4956 98.3692C71.736 106.994 88.8027 132.282 94.4811 143.653C105.725 141.594 115.73 138.149 124.547 133.665C121.291 132.305 118.248 130.405 115.554 128.011L114.859 127.392C114.033 126.658 113.959 125.394 114.693 124.569C115.427 123.743 116.691 123.669 117.516 124.403L118.212 125.021C121.434 127.886 125.228 129.941 129.286 131.091C130.47 130.405 131.632 129.699 132.769 128.975C130.868 128.149 129.036 127.135 127.302 125.938L126.535 125.409C125.626 124.782 125.398 123.537 126.025 122.627C126.653 121.718 127.898 121.49 128.807 122.117L129.573 122.646C131.83 124.203 134.276 125.407 136.83 126.243C137.942 125.453 139.03 124.644 140.093 123.818C139.482 123.453 138.88 123.067 138.29 122.66L137.524 122.131C136.615 121.504 136.387 120.259 137.014 119.349C137.641 118.44 138.887 118.212 139.796 118.839L140.562 119.368C141.487 120.006 142.444 120.585 143.428 121.104C163.878 103.673 174.394 79.6305 176.271 57.779C176.004 57.4894 175.735 57.2009 175.463 56.9136Z"/>
+      </group>
+  </group>
+</vector>
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_icon_monochrome.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_icon_monochrome.xml
new file mode 100644
index 00000000..256d8077
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_icon_monochrome.xml
@@ -0,0 +1,26 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+  android:width="108dp"
+  android:height="108dp"
+  android:viewportWidth="108"
+  android:viewportHeight="108">
+  <path
+    android:fillAlpha="0.9"
+    android:pathData="M34.7,52.5l37,-15.2c0,0 0,0 0,0c-0.2,11.3 -7.4,25 -24.3,29.3c-2.1,-3.5 -8.1,-11.2 -12.9,-13.7C34.6,52.7 34.6,52.6 34.7,52.5z"
+    android:fillColor="#F5BD14"
+    android:fillType="evenOdd"/>
+  <path
+    android:fillAlpha="0.9"
+    android:pathData="M50.2,34.2l-2.8,7.8l-0.4,-0.5c-1.6,-2.1 -3.5,-3.9 -5.6,-5.4l4.9,-5.5l-0.3,6L50.2,34.2z"
+    android:fillColor="#F86932"/>
+  <path
+    android:pathData="M38.6,35.4c-6.2,0 -11.3,5.1 -11.3,11.3c0,0 0,0 0,0C27.3,53 32.4,58 38.6,58c6.2,0 11.3,-5.1 11.3,-11.3c0,0 0,0 0,0C49.9,40.5 44.9,35.4 38.6,35.4zM42.3,42.3l-1.5,0.5l0.6,1.7c0.1,0.4 -0.1,0.7 -0.4,0.9c-0.1,0 -0.1,0 -0.2,0c-0.3,0 -0.6,-0.2 -0.6,-0.5l-0.6,-1.7l-1,0.3c-0.4,0.1 -0.7,-0.1 -0.9,-0.4c-0.1,-0.4 0.1,-0.7 0.4,-0.9l1,-0.3l-0.5,-1.4c-0.1,-0.4 0.1,-0.7 0.4,-0.9c0.4,-0.1 0.7,0.1 0.9,0.4l0.5,1.4l1.5,-0.5c0.4,-0.1 0.7,0.1 0.9,0.4C42.9,41.8 42.7,42.2 42.3,42.3z"
+    android:fillColor="#FFCC32"/>
+  <path
+    android:pathData="M27.3,46.9c0.1,13.5 9.1,25.8 22.8,29.5c10.4,2.8 21.1,-0.1 28.5,-6.9c-3.3,0.2 -6.6,-0.1 -10,-1C60.5,66.3 54,61 50,54.1L27.3,46.9z"
+    android:fillColor="#FFCC32"
+    android:fillType="evenOdd"/>
+  <path
+    android:pathData="M80.4,42.3L42.7,55.2c0,0.1 -0.1,0.3 -0.2,0.4c4.6,2.8 10.1,10.9 11.9,14.5c3.6,-0.7 6.8,-1.8 9.7,-3.2c-1,-0.4 -2,-1 -2.9,-1.8L61,64.9c-0.3,-0.2 -0.3,-0.6 -0.1,-0.9c0.2,-0.3 0.6,-0.3 0.9,-0.1l0.2,0.2c1,0.9 2.3,1.6 3.6,1.9c0.4,-0.2 0.8,-0.4 1.1,-0.7c-0.6,-0.3 -1.2,-0.6 -1.8,-1l-0.2,-0.2c-0.3,-0.2 -0.4,-0.6 -0.2,-0.9c0.2,-0.3 0.6,-0.4 0.9,-0.2l0.2,0.2c0.7,0.5 1.5,0.9 2.3,1.2c0.4,-0.3 0.7,-0.5 1,-0.8c-0.2,-0.1 -0.4,-0.2 -0.6,-0.4l-0.2,-0.2c-0.3,-0.2 -0.4,-0.6 -0.2,-0.9c0.2,-0.3 0.6,-0.4 0.9,-0.2l0.2,0.2c0.3,0.2 0.6,0.4 0.9,0.6c6.6,-5.6 9.9,-13.3 10.5,-20.3C80.6,42.4 80.5,42.4 80.4,42.3z"
+    android:fillColor="#FFCC32"
+    android:fillType="evenOdd"/>
+</vector>
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_info.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_info.xml
new file mode 100644
index 00000000..694aa9ab
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_info.xml
@@ -0,0 +1,5 @@
+<vector android:height="24dp" android:tint="#151C1F"
+    android:viewportHeight="24.0" android:viewportWidth="24.0"
+    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
+    <path android:fillColor="#FF000000" android:pathData="M11,17h2v-6h-2v6zM12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8zM11,9h2L13,7h-2v2z"/>
+</vector>
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_info_rectangle.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_info_rectangle.xml
new file mode 100644
index 00000000..e8a548ec
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_info_rectangle.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android">
+    <stroke android:width="2dp" android:color="@color/leak_canary_class_name" />
+    <corners android:radius="6dp" />
+</shape>
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_leak.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_leak.xml
new file mode 100644
index 00000000..9bf97331
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_leak.xml
@@ -0,0 +1,30 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="24"
+    android:viewportHeight="24">
+  <path
+      android:pathData="M14.5771,8.25L14.5771,21"
+      android:strokeWidth="2.5"
+      android:fillColor="#00000000"
+      android:strokeColor="#151C1F"
+      android:strokeLineCap="round"/>
+  <path
+      android:pathData="M9.7883,4L9.7883,10.5385"
+      android:strokeWidth="2.5"
+      android:fillColor="#00000000"
+      android:strokeColor="#151C1F"
+      android:strokeLineCap="round"/>
+  <path
+      android:pathData="M19.3652,8.25L19.3244,17.5957"
+      android:strokeWidth="2.5"
+      android:fillColor="#00000000"
+      android:strokeColor="#151C1F"
+      android:strokeLineCap="round"/>
+  <path
+      android:pathData="M5,7.2691V15.4422"
+      android:strokeWidth="2.5"
+      android:fillColor="#00000000"
+      android:strokeColor="#151C1F"
+      android:strokeLineCap="round"/>
+</vector>
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_list_selector.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_list_selector.xml
new file mode 100644
index 00000000..3f6a244a
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_list_selector.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_focused="true" android:state_pressed="false">
+        <color android:color="@color/leak_canary_gray_3f" />
+    </item>
+    <item>
+        <color android:color="@android:color/transparent" />
+    </item>
+</selector>
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_primary_button.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_primary_button.xml
new file mode 100644
index 00000000..5fe33ead
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_primary_button.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+  <item android:state_pressed="true">
+    <shape>
+      <solid android:color="@color/leak_canary_yellow_button_pressed" />
+      <corners android:radius="12dp" />
+    </shape>
+  </item>
+  <item>
+    <shape>
+      <solid android:color="@color/leak_canary_yellow_button" />
+      <corners android:radius="12dp" />
+    </shape>
+  </item>
+</selector>
+
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_secondary_button.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_secondary_button.xml
new file mode 100644
index 00000000..8987d5f6
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_secondary_button.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+<item android:state_pressed="true">
+    <shape>
+        <solid android:color="@color/leak_canary_gray_6f" />
+        <corners android:radius="12dp" />
+    </shape>
+</item>
+<item>
+    <shape>
+        <solid android:color="@color/leak_canary_gray_3f" />
+        <corners android:radius="12dp" />
+    </shape>
+</item>
+</selector>
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_tab_background.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_tab_background.xml
new file mode 100644
index 00000000..fb7b171f
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_tab_background.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+  <item android:state_pressed="false" android:drawable="@android:color/transparent" />
+  <item android:drawable="@color/leak_canary_gray_darkest_25p" />
+</selector>
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_toast_background.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_toast_background.xml
new file mode 100644
index 00000000..0bf11fb8
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_toast_background.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android">
+  <solid android:color="#cc000000"/>
+  <corners android:radius="16dp"/>
+</shape>
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_tv_icon.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_tv_icon.xml
new file mode 100644
index 00000000..ea0e0e20
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_tv_icon.xml
@@ -0,0 +1,44 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="18dp"
+    android:viewportWidth="320"
+    android:viewportHeight="180">
+  <group android:name="background">
+    <path
+        android:fillColor="#FFFFFF"
+        android:pathData="M0,0 L320,0 320,180 0,180z" />
+  </group>
+  <group android:translateX="70">
+    <clip-path android:pathData="M0,0h180v180h-180z M 0,0" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M55.8327 80.944L68.1676 83.3835M59.6321 89.5079L62.4202 75.4109"
+        android:strokeWidth="4.257"
+        android:strokeColor="#151C1F"
+        android:strokeLineCap="round" />
+    <path
+        android:fillColor="#F5BD14"
+        android:fillType="evenOdd"
+        android:pathData="M33.0396 88.6436L148.284 41.1702C148.308 41.1931 148.333 41.216 148.357 41.2389C147.773 76.5754 125.2 119.136 72.6948 132.558C66.2444 121.606 47.4716 97.5578 32.6694 89.9372C32.799 89.5158 32.9224 89.0844 33.0396 88.6436Z" />
+    <path
+        android:fillColor="#F86932"
+        android:pathData="M81.4818 31.7162L72.8251 55.9266L71.7247 54.5065C66.7399 48.0734 60.8251 42.4184 54.1748 37.7274L69.4736 20.6696L68.6881 39.2884L81.4818 31.7162Z" />
+    <path
+        android:fillColor="#FFCC32"
+        android:pathData="M45.3062,70.8628m-35.1642,0.0a35.1642,35.1642,0,1,1,70.3284,0.0a35.1642,35.1642,0,1,1,-70.3284,0.0" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M44.2972 58.986L56.2444 55.066M51.8067 64.5881L47.3268 50.9342"
+        android:strokeWidth="4.257"
+        android:strokeColor="#151C1F"
+        android:strokeLineCap="round" />
+    <path
+        android:fillColor="#FFCC32"
+        android:fillType="evenOdd"
+        android:pathData="M10.1416 71.2627C10.4815 113.278 38.6085 151.594 81.1309 162.988C113.627 171.695 146.704 162.582 170.003 141.637C159.823 142.304 149.364 141.343 138.964 138.556C113.428 131.714 93.0844 115.164 80.8316 93.9338L10.1416 71.2627Z" />
+    <path
+        android:fillColor="#FFCC32"
+        android:fillType="evenOdd"
+        android:pathData="M175.463 56.9136L57.9672 97.0664C57.8158 97.5113 57.6587 97.9458 57.4956 98.3692C71.736 106.994 88.8027 132.282 94.4811 143.653C105.725 141.594 115.73 138.149 124.547 133.665C121.291 132.305 118.248 130.405 115.554 128.011L114.859 127.392C114.033 126.658 113.959 125.394 114.693 124.569C115.427 123.743 116.691 123.669 117.516 124.403L118.212 125.021C121.434 127.886 125.228 129.941 129.286 131.091C130.47 130.405 131.632 129.699 132.769 128.975C130.868 128.149 129.036 127.135 127.302 125.938L126.535 125.409C125.626 124.782 125.398 123.537 126.025 122.627C126.653 121.718 127.898 121.49 128.807 122.117L129.573 122.646C131.83 124.203 134.276 125.407 136.83 126.243C137.942 125.453 139.03 124.644 140.093 123.818C139.482 123.453 138.88 123.067 138.29 122.66L137.524 122.131C136.615 121.504 136.387 120.259 137.014 119.349C137.641 118.44 138.887 118.212 139.796 118.839L140.562 119.368C141.487 120.006 142.444 120.585 143.428 121.104C163.878 103.673 174.394 79.6305 176.271 57.779C176.004 57.4894 175.735 57.2009 175.463 56.9136Z" />
+  </group>
+</vector>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_about_screen.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_about_screen.xml
new file mode 100644
index 00000000..424a13d6
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_about_screen.xml
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    >
+  <TextView
+      android:id="@+id/leak_canary_about_text"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:paddingBottom="16dp"
+      android:paddingLeft="16dp"
+      android:paddingRight="16dp"
+      />
+
+  <TextView
+      android:id="@+id/leak_canary_about_heap_dump_text"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:layout_above="@+id/leak_canary_about_heap_dump_switch_button"
+      android:paddingTop="16dp"
+      android:paddingLeft="16dp"
+      android:paddingRight="16dp"
+      android:textStyle="italic"
+      />
+
+  <Switch
+      android:id="@+id/leak_canary_about_heap_dump_switch_button"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:layout_alignParentBottom="true"
+      android:padding="16dp"
+      android:checked="true"
+      android:text="@string/leak_canary_about_enable_heap_dump"
+      android:textOn="@string/leak_canary_about_enable_heap_dump_textOn"
+      android:textOff="@string/leak_canary_about_enable_heap_dump_textOff"
+      />
+
+</RelativeLayout>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_heap_analysis_failure_screen.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_analysis_failure_screen.xml
new file mode 100644
index 00000000..f3ec55ee
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_analysis_failure_screen.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    >
+
+
+<LinearLayout
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:orientation="vertical"
+    >
+
+  <include layout="@layout/leak_canary_leak_header" />
+
+  <TextView
+      android:id="@+id/leak_canary_stacktrace"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:layout_margin="20dp"
+      android:textSize="12sp"
+      android:fontFamily="monospace"
+      />
+</LinearLayout>
+
+</ScrollView>
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_heap_dump_leak_title.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_dump_leak_title.xml
new file mode 100644
index 00000000..a1d4f9a4
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_dump_leak_title.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<TextView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/leak_canary_heap_dump_leaks"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:paddingLeft="20dp"
+    android:paddingTop="32dp"
+    android:paddingBottom="24dp"
+    android:textStyle="bold"
+    android:textSize="20sp"
+    android:textColor="@color/leak_canary_white"
+    />
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_heap_dump_toast.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_dump_toast.xml
new file mode 100644
index 00000000..c31f8b25
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_dump_toast.xml
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    >
+
+  <LinearLayout
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:background="@drawable/leak_canary_toast_background"
+      android:orientation="vertical"
+      android:layout_marginTop="48dp"
+      android:padding="16dp"
+      >
+  <!-- Holds the stop for the image on top-->
+  <View
+      android:layout_width="@dimen/leak_canary_toast_icon_size"
+      android:layout_height="@dimen/leak_canary_toast_icon_size"
+      android:layout_gravity="center_horizontal"
+      />
+
+  <TextView
+      android:id="@+id/leak_canary_toast_text"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_gravity="center_horizontal"
+      android:text="@string/leak_canary_toast_heap_dump"
+      android:textColor="#ffffff"
+      android:textSize="18sp"
+      />
+  </LinearLayout>
+
+  <ImageView
+      android:id="@+id/leak_canary_toast_icon"
+      android:layout_marginTop="@dimen/leak_canary_toast_icon_size"
+      android:layout_width="@dimen/leak_canary_toast_icon_size"
+      android:layout_height="@dimen/leak_canary_toast_icon_size"
+      android:layout_gravity="center_horizontal"
+      android:src="@drawable/leak_canary_icon"
+      />
+
+</FrameLayout>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_heap_dumps_screen.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_dumps_screen.xml
new file mode 100644
index 00000000..03a2b511
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_dumps_screen.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    >
+  <ListView
+      android:id="@+id/leak_canary_list"
+      android:layout_width="match_parent"
+      android:layout_height="0dp"
+      android:layout_weight="1"
+      android:listSelector="@drawable/leak_canary_list_selector"
+      android:divider="@null"
+      android:dividerHeight="0dp"
+      android:requiresFadingEdge="vertical"
+      />
+  <LinearLayout
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:orientation="horizontal"
+      android:layout_marginStart="20dp"
+      android:layout_marginEnd="20dp"
+      android:layout_marginTop="16dp"
+      android:layout_marginBottom="16dp"
+      >
+    <Button
+        android:id="@+id/leak_canary_import_heap_dump"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:layout_weight="1"
+        android:background="@drawable/leak_canary_primary_button"
+        android:textAllCaps="false"
+        android:layout_marginRight="16dp"
+        android:textColor="@color/leak_canary_gray_darkest"
+        android:text="@string/leak_canary_import_hprof_file"
+        />
+    <Button
+        android:id="@+id/leak_canary_dump_heap_now"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:layout_weight="1"
+        android:background="@drawable/leak_canary_secondary_button"
+        android:textAllCaps="false"
+        android:textColor="@color/leak_canary_gray_lightest"
+        android:text="@string/leak_canary_dump_heap"
+        />
+  </LinearLayout>
+</LinearLayout>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_heap_render.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_render.xml
new file mode 100644
index 00000000..a08b2fae
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_heap_render.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    >
+  <ProgressBar
+      android:id="@+id/leak_canary_loading"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_gravity="center"
+      android:indeterminate="true"
+      style="?android:attr/progressBarStyleLarge"
+      />
+  <ImageView
+      android:id="@+id/leak_canary_heap_rendering"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      />
+
+</FrameLayout>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_hprof_explorer.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_hprof_explorer.xml
new file mode 100644
index 00000000..20d9abbb
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_hprof_explorer.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    >
+  <Button
+      android:id="@+id/leak_canary_search_button"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:text="@string/leak_canary_explorer_search_classes"
+      android:visibility="invisible"
+      />
+  <TextView
+      android:id="@+id/leak_canary_explorer_title"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:visibility="invisible"
+      />
+  <ListView
+      android:id="@+id/leak_canary_explorer_list"
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"
+      android:divider="@null"
+      android:dividerHeight="0dp"
+      android:requiresFadingEdge="vertical"
+      android:visibility="invisible"
+      />
+</LinearLayout>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_leak_activity.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_activity.xml
new file mode 100644
index 00000000..eec7617c
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_activity.xml
@@ -0,0 +1,111 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    >
+  <FrameLayout
+      android:id="@+id/leak_canary_main_container"
+      android:layout_width="match_parent"
+      android:layout_height="0dp"
+      android:layout_weight="1"
+      />
+
+  <LinearLayout
+      android:id="@+id/leak_canary_bottom_navigation_bar"
+      android:layout_width="match_parent"
+      android:layout_height="68dp"
+      android:background="@color/leak_canary_yellow"
+      android:orientation="horizontal"
+      >
+
+    <LinearLayout
+        android:id="@+id/leak_canary_navigation_button_leaks"
+        android:layout_width="0dp"
+        android:layout_height="match_parent"
+        android:layout_weight="1"
+        android:focusable="true"
+        android:orientation="vertical"
+        android:background="@drawable/leak_canary_tab_background"
+        >
+      <ImageView
+          android:id="@+id/leak_canary_navigation_button_leaks_icon"
+          android:layout_width="24dp"
+          android:layout_height="24dp"
+          android:layout_gravity="center_horizontal"
+          android:layout_marginTop="14dp"
+          android:src="@drawable/leak_canary_leak"
+          android:scaleType="center"
+          />
+      <TextView
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_gravity="center_horizontal"
+          android:layout_marginTop="2dp"
+          android:text="Leaks"
+          android:textColor="@color/leak_canary_bottom_menu"
+          android:textSize="11sp"
+          />
+    </LinearLayout>
+
+
+    <LinearLayout
+        android:id="@+id/leak_canary_navigation_button_heap_dumps"
+        android:layout_width="0dp"
+        android:layout_height="match_parent"
+        android:layout_weight="1"
+        android:focusable="true"
+        android:orientation="vertical"
+        android:background="@drawable/leak_canary_tab_background"
+        >
+      <ImageView
+          android:id="@+id/leak_canary_navigation_button_heap_dumps_icon"
+          android:layout_width="24dp"
+          android:layout_height="24dp"
+          android:layout_gravity="center_horizontal"
+          android:layout_marginTop="14dp"
+          android:src="@drawable/leak_canary_dump"
+          android:scaleType="center"
+          />
+      <TextView
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_gravity="center_horizontal"
+          android:layout_marginTop="2dp"
+          android:text="Heap Dumps"
+          android:textColor="@color/leak_canary_bottom_menu"
+          android:textSize="11sp"
+          />
+    </LinearLayout>
+
+    <LinearLayout
+        android:id="@+id/leak_canary_navigation_button_about"
+        android:layout_width="0dp"
+        android:layout_height="match_parent"
+        android:layout_weight="1"
+        android:orientation="vertical"
+        android:focusable="true"
+        android:background="@drawable/leak_canary_tab_background"
+        >
+      <ImageView
+          android:id="@+id/leak_canary_navigation_button_about_icon"
+          android:layout_width="24dp"
+          android:layout_height="24dp"
+          android:layout_gravity="center_horizontal"
+          android:layout_marginTop="14dp"
+          android:src="@drawable/leak_canary_info"
+          android:scaleType="center"
+          />
+      <TextView
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_gravity="center_horizontal"
+          android:layout_marginTop="2dp"
+          android:text="About"
+          android:textColor="@color/leak_canary_bottom_menu"
+          android:textSize="11sp"
+          />
+    </LinearLayout>
+  </LinearLayout>
+
+</LinearLayout>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_leak_chips.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_chips.xml
new file mode 100644
index 00000000..80137fc0
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_chips.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:orientation="horizontal"
+    >
+
+  <TextView
+      android:id="@+id/leak_canary_chip_new"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_marginRight="8dp"
+      android:background="@drawable/leak_canary_count_background"
+      android:gravity="center_vertical"
+      android:paddingLeft="8dp"
+      android:paddingTop="2dp"
+      android:paddingRight="8dp"
+      android:paddingBottom="2dp"
+      android:text="New"
+      android:textColor="@color/leak_canary_count_text"
+      android:textSize="14sp"
+      android:visibility="gone"
+      />
+
+  <TextView
+      android:id="@+id/leak_canary_chip_library_leak"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:background="@drawable/leak_canary_count_background"
+      android:enabled="false"
+      android:gravity="center_vertical"
+      android:paddingLeft="8dp"
+      android:paddingTop="2dp"
+      android:paddingRight="8dp"
+      android:paddingBottom="2dp"
+      android:text="Library Leak"
+      android:textColor="@color/leak_canary_count_text"
+      android:textSize="14sp"
+      android:visibility="gone"
+      />
+</LinearLayout>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_leak_header.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_header.xml
new file mode 100644
index 00000000..44472458
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_header.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    >
+  <TextView
+      android:id="@+id/leak_canary_header_text"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:layout_marginStart="20dp"
+      android:layout_marginEnd="20dp"
+      android:background="@drawable/leak_canary_info_rectangle"
+      android:padding="16dp"
+      />
+</FrameLayout>
+
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_leak_row.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_row.xml
new file mode 100644
index 00000000..2dcddfcf
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_row.xml
@@ -0,0 +1,75 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    >
+
+  <RelativeLayout
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:layout_marginLeft="20dp"
+      android:layout_marginTop="4dp"
+      android:layout_marginRight="20dp"
+      android:layout_marginBottom="4dp"
+      android:background="@drawable/leak_canary_gray_fill"
+      android:orientation="horizontal"
+      android:paddingTop="20dp"
+      android:paddingRight="20dp"
+      android:paddingBottom="20dp"
+      >
+
+    <TextView
+        android:id="@+id/leak_canary_count_text"
+        android:layout_width="56dp"
+        android:layout_height="56dp"
+        android:layout_alignParentLeft="true"
+        android:layout_centerVertical="true"
+        android:layout_marginLeft="20dp"
+        android:background="@drawable/leak_canary_count_background"
+        android:gravity="center"
+        android:padding="16dp"
+        android:textColor="@color/leak_canary_count_text"
+        android:textSize="18sp"
+        android:textStyle="bold"
+        tools:text="1"
+        />
+
+    <TextView
+        android:id="@+id/leak_canary_leak_text"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_alignTop="@id/leak_canary_count_text"
+        android:layout_gravity="center_vertical"
+        android:layout_marginLeft="20dp"
+        android:layout_marginTop="3dp"
+        android:layout_toRightOf="@id/leak_canary_count_text"
+        android:ellipsize="end"
+        android:singleLine="true"
+        android:textColor="@color/leak_canary_white"
+        android:textSize="18sp"
+        tools:text="ExampleApplication.leakedViews"
+        />
+
+    <TextView
+        android:id="@+id/leak_canary_time_text"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_below="@id/leak_canary_leak_text"
+        android:layout_alignLeft="@id/leak_canary_leak_text"
+        android:textColor="@color/leak_canary_gray_light"
+        android:textSize="14sp"
+        tools:text="Last leaked April 26th, 4:20 PM"
+        />
+
+    <include
+        layout="@layout/leak_canary_leak_chips"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_below="@id/leak_canary_time_text"
+        android:layout_alignLeft="@id/leak_canary_leak_text"
+        android:layout_marginTop="8dp"
+        />
+
+  </RelativeLayout>
+</FrameLayout>
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_leak_screen.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_screen.xml
new file mode 100644
index 00000000..0ab3f758
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_screen.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    >
+
+  <Spinner
+      android:id="@+id/leak_canary_spinner"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      />
+
+  <include
+      android:id="@+id/leak_canary_single_leak_trace_row"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      layout="@layout/leak_canary_simple_row"
+      />
+
+  <include
+      layout="@layout/leak_canary_leak_chips"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_marginStart="16dp"
+      android:layout_marginEnd="16dp"
+      android:layout_marginBottom="16dp"
+      />
+
+  <ListView
+      android:id="@+id/leak_canary_list"
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"
+      android:listSelector="@drawable/leak_canary_list_selector"
+      android:divider="@null"
+      android:dividerHeight="0dp"
+      android:requiresFadingEdge="vertical"
+      />
+</LinearLayout>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_list.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_list.xml
new file mode 100644
index 00000000..fb17d5e8
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_list.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    >
+  <ListView
+      android:id="@+id/leak_canary_list"
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"
+      android:listSelector="@drawable/leak_canary_list_selector"
+      android:divider="@null"
+      android:dividerHeight="0dp"
+      android:requiresFadingEdge="vertical"
+      />
+</FrameLayout>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_ref_row.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_ref_row.xml
new file mode 100644
index 00000000..194e6f6a
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_ref_row.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<leakcanary.internal.RowElementLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:clipChildren="false"
+    >
+
+  <leakcanary.internal.DisplayLeakConnectorView
+      android:id="@+id/leak_canary_row_connector"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      />
+
+  <TextView
+      android:id="@+id/leak_canary_row_title"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      />
+</leakcanary.internal.RowElementLayout>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_simple_row.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_simple_row.xml
new file mode 100644
index 00000000..5e9c7fa0
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_simple_row.xml
@@ -0,0 +1,50 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:minHeight="48dp"
+    android:padding="16dp"
+    android:orientation="horizontal"
+    >
+
+  <TextView
+      android:id="@+id/leak_canary_row_text"
+      android:layout_width="0dp"
+      android:layout_weight="1"
+      android:layout_marginEnd="5dp"
+      android:layout_marginRight="5dp"
+      tools:text="5. ExampleApplication.leakedViews"
+      android:layout_height="wrap_content"
+      android:layout_gravity="center_vertical"
+      android:textSize="18sp"
+      />
+
+  <TextView
+      android:id="@+id/leak_canary_row_small_text"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:layout_marginLeft="5dp"
+      android:layout_marginStart="5dp"
+      tools:text="Latest: April 26th, 4:20 PM"
+      android:layout_gravity="center_vertical"
+      android:textColor="#919191"
+      android:textSize="14sp"
+      />
+
+</LinearLayout>
diff --git a/leakcanary-android-core/src/main/res/mipmap-anydpi-v26/leak_canary_icon.xml b/leakcanary-android-core/src/main/res/mipmap-anydpi-v26/leak_canary_icon.xml
new file mode 100644
index 00000000..f1548977
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/mipmap-anydpi-v26/leak_canary_icon.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
+  <background android:drawable="@color/leak_canary_white"/>
+  <foreground android:drawable="@drawable/leak_canary_icon_foreground"/>
+  <monochrome android:drawable="@drawable/leak_canary_icon_monochrome" />
+</adaptive-icon>
diff --git a/leakcanary-android-core/src/main/res/mipmap-hdpi/leak_canary_icon.png b/leakcanary-android-core/src/main/res/mipmap-hdpi/leak_canary_icon.png
new file mode 100644
index 00000000..9ad0073e
Binary files /dev/null and b/leakcanary-android-core/src/main/res/mipmap-hdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android-core/src/main/res/mipmap-mdpi/leak_canary_icon.png b/leakcanary-android-core/src/main/res/mipmap-mdpi/leak_canary_icon.png
new file mode 100644
index 00000000..2166d069
Binary files /dev/null and b/leakcanary-android-core/src/main/res/mipmap-mdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android-core/src/main/res/mipmap-xhdpi/leak_canary_icon.png b/leakcanary-android-core/src/main/res/mipmap-xhdpi/leak_canary_icon.png
new file mode 100644
index 00000000..6aee0412
Binary files /dev/null and b/leakcanary-android-core/src/main/res/mipmap-xhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android-core/src/main/res/mipmap-xxhdpi/leak_canary_icon.png b/leakcanary-android-core/src/main/res/mipmap-xxhdpi/leak_canary_icon.png
new file mode 100644
index 00000000..e35493b9
Binary files /dev/null and b/leakcanary-android-core/src/main/res/mipmap-xxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android-core/src/main/res/mipmap-xxxhdpi/leak_canary_icon.png b/leakcanary-android-core/src/main/res/mipmap-xxxhdpi/leak_canary_icon.png
new file mode 100644
index 00000000..a50f8e03
Binary files /dev/null and b/leakcanary-android-core/src/main/res/mipmap-xxxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android-core/src/main/res/values-v21/leak_canary_themes.xml b/leakcanary-android-core/src/main/res/values-v21/leak_canary_themes.xml
new file mode 100644
index 00000000..c18b9518
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values-v21/leak_canary_themes.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Material">
+    <item name="android:windowBackground">@color/leak_canary_background_color</item>
+    <item name="android:actionBarStyle">@style/leak_canary_Widget.ActionBar</item>
+  </style>
+
+  <style name="leak_canary_Widget.ActionBar" parent="android:Widget.Material.ActionBar">
+    <item name="android:background">@color/leak_canary_background_color</item>
+    <item name="android:elevation">0dp</item>
+  </style>
+
+</resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_attrs.xml b/leakcanary-android-core/src/main/res/values/leak_canary_attrs.xml
new file mode 100644
index 00000000..092508ba
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_attrs.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <declare-styleable name="leak_canary_MoreDetailsView">
+    <attr name="leak_canary_plus_color" format="color" />
+  </declare-styleable>
+</resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_bools.xml b/leakcanary-android-core/src/main/res/values/leak_canary_bools.xml
new file mode 100644
index 00000000..8da780ec
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_bools.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <bool name="leak_canary_add_dynamic_shortcut">true</bool>
+  <bool name="leak_canary_add_launcher_icon">true</bool>
+  <bool name="leak_canary_allow_in_non_debuggable_build">false</bool>
+</resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_colors.xml b/leakcanary-android-core/src/main/res/values/leak_canary_colors.xml
new file mode 100644
index 00000000..4d0534bf
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_colors.xml
@@ -0,0 +1,58 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <color name="leak_canary_class_name">#bababa</color>
+  <color name="leak_canary_leak">#be383f</color>
+  <color name="leak_canary_reference">#9976a8</color>
+  <color name="leak_canary_extra">#919191</color>
+  <color name="leak_canary_help">#6a98b9</color>
+  <color name="leak_canary_background_color">#242424</color>
+  <color name="leak_canary_count_new">#FFD34C</color>
+  <color name="leak_canary_count_new_border">@color/leak_canary_yellow</color>
+  <color name="leak_canary_count_default">#26FFCC32</color>
+  <color name="leak_canary_yellow">#FFCC32</color>
+  <color name="leak_canary_yellow_button">#FFE79F</color>
+  <color name="leak_canary_yellow_button_pressed">#c4b47f</color>
+  <color name="leak_canary_gray_3f">#3F3F3F</color>
+  <color name="leak_canary_gray_6f">#6f6f6f</color>
+  <color name="leak_canary_gray_lightest">#F2F4F5</color>
+  <color name="leak_canary_gray_light">#939CA3</color>
+  <color name="leak_canary_gray">#2F2F2F</color>
+  <color name="leak_canary_gray_darkest">#151C1F</color>
+  <color name="leak_canary_gray_darkest_40p">#66151C1F</color>
+  <color name="leak_canary_gray_darkest_25p">#40151C1F</color>
+  <color name="leak_canary_white">#ffffff</color>
+  <color name="leak_canary_heap_stack_trace">#ffd40b</color>
+  <color name="leak_canary_heap_app">#00ffff</color>
+  <color name="leak_canary_heap_image">#039dff</color>
+  <color name="leak_canary_heap_zygote">#000a8b</color>
+  <color name="leak_canary_heap_instance">#72547a</color>
+  <color name="leak_canary_heap_load_class">#12580f</color>
+  <color name="leak_canary_heap_class_dump">#689959</color>
+  <color name="leak_canary_heap_hprof_string">#900000</color>
+  <color name="leak_canary_heap_instance_string">#ff0000</color>
+  <color name="leak_canary_heap_char_array">#ffa500</color>
+  <color name="leak_canary_heap_boolean_array">#383838</color>
+  <color name="leak_canary_heap_float_array">#4d4d4d</color>
+  <color name="leak_canary_heap_double_array">#4d4d4d</color>
+  <color name="leak_canary_heap_short_array">#797979</color>
+  <color name="leak_canary_heap_int_array">#797979</color>
+  <color name="leak_canary_heap_long_array">#797979</color>
+  <color name="leak_canary_heap_byte_array">#e23ff7</color>
+  <color name="leak_canary_heap_object_array">#ffffff</color>
+  <color name="leak_canary_heap_other">#000000</color>
+</resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_dimens.xml b/leakcanary-android-core/src/main/res/values/leak_canary_dimens.xml
new file mode 100644
index 00000000..5f80b9b3
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_dimens.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <dimen name="leak_canary_squiggly_span_stroke_width">1dp</dimen>
+  <dimen name="leak_canary_squiggly_span_amplitude">1dp</dimen>
+  <!-- DP because the period increased with the density. -->
+  <dimen name="leak_canary_squiggly_span_period_degrees">4dp</dimen>
+  <dimen name="leak_canary_connector_center_y">24dp</dimen>
+  <dimen name="leak_canary_connector_stroke_size">2dp</dimen>
+  <dimen name="leak_canary_connector_leak_dash_line">5dp</dimen>
+  <dimen name="leak_canary_connector_leak_dash_gap">1dp</dimen>
+  <dimen name="leak_canary_more_stroke_width">2dp</dimen>
+  <dimen name="leak_canary_connector_width">16dp</dimen>
+  <dimen name="leak_canary_row_margins">20dp</dimen>
+  <dimen name="leak_canary_more_size">12dp</dimen>
+  <dimen name="leak_canary_more_margin_top">18dp</dimen>
+  <dimen name="leak_canary_row_min">48dp</dimen>
+  <dimen name="leak_canary_row_title_margin_top">14.5dp</dimen>
+  <dimen name="leak_canary_toast_icon_size">64dp</dimen>
+  <dimen name="leak_canary_toast_icon_tv_padding">10dp</dimen>
+
+</resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml b/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
new file mode 100644
index 00000000..d94af979
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <item type="id" name="leak_canary_notification_write_permission" />
+  <item type="id" name="leak_canary_notification_analysis_result" />
+  <item type="id" name="leak_canary_notification_dumping_heap" />
+  <item type="id" name="leak_canary_notification_analyzing_heap" />
+  <item type="id" name="leak_canary_notification_retained_objects" />
+  <item type="id" name="leak_canary_notification_no_retained_object_on_tap" />
+  <item type="id" name="leak_canary_notification_on_screen_exit" />
+</resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_public.xml b/leakcanary-android-core/src/main/res/values/leak_canary_public.xml
new file mode 100644
index 00000000..4db264cb
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_public.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+
+  <public name="leak_canary_add_dynamic_shortcut" type="bool"/>
+  <public name="leak_canary_add_launcher_icon" type="bool"/>
+  <public name="leak_canary_allow_in_non_debuggable_build" type="bool"/>
+  <public name="leak_canary_display_activity_label" type="string"/>
+  <public name="leak_canary_heap_dump_toast" type="layout"/>
+  <public name="leak_canary_icon" type="mipmap"/>
+  <public name="leak_canary_test_class_name" type="string"/>
+</resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
new file mode 100644
index 00000000..39f75a4c
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
@@ -0,0 +1,105 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources xmlns:tools="http://schemas.android.com/tools" tools:ignore="MissingTranslation">
+  <string name="leak_canary_about_menu">About LeakCanary</string>
+  <string name="leak_canary_about_title">About LeakCanary %s</string>
+  <string name="leak_canary_about_message"><![CDATA[This is a dev extension for
+  <b>%1$s</b> (<i>%2$s</i>), automatically added by the LeakCanary library.<br><br>
+  <a href="https://square.github.io/leakcanary/">LeakCanary</a> is a memory leak detection library for Android, created
+  and open sourced by <a href="https://twitter.com/Piwai">Pierre-Yves Ricau</a> at <a href="https://square.github.io">Square</a>.<br><br>
+  You can learn more about memory leaks at <a href="https://squ.re/leaks">https://squ.re/leaks</a>.<br><br>
+  We welcome contributions from the community - please do not hesitate to
+  <a href="https://github.com/square/leakcanary/issues">report an issue</a> or open a pull request!<br><br>
+]]></string>
+  <string name="leak_canary_about_enable_heap_dump">Dump heap automatically</string>
+  <string name="leak_canary_about_enable_heap_dump_textOn">Enable</string>
+  <string name="leak_canary_about_enable_heap_dump_textOff">Disable</string>
+  <string name="leak_canary_heap_dump_disabled_text">LeakCanary is currently disabled: <i>%s</i>.</string>
+  <string name="leak_canary_heap_dump_not_installed_text">AppWatcher is not installed</string>
+  <string name="leak_canary_heap_dump_enabled_text">LeakCanary is running and ready to detect memory leaks.</string>
+  <string name="leak_canary_heap_dump_disabled_by_app">LeakCanary.Config.dumpHeap is set to false</string>
+  <string name="leak_canary_heap_dump_disabled_from_ui">heap dumping disabled from LeakCanary About screen</string>
+  <string name="leak_canary_heap_dump_disabled_running_tests">test class "%s" was found in classpath</string>
+  <string name="leak_canary_analysis_failed">Heap analysis failed</string>
+  <string name="leak_canary_analysis_success_notification">Found %1$d retained objects grouped as %2$d distinct leaks (%3$d new)</string>
+  <string name="leak_canary_class_has_leaked">%1$s Leaked</string>
+  <string name="leak_canary_explorer_search_classes">Search classes</string>
+  <plurals name="leak_canary_distinct_leaks">
+    <item quantity="one">%d Distinct Leak</item>
+    <item quantity="other">%d Distinct Leaks</item>
+  </plurals>
+  <string name="leak_canary_explore_heap_dump">Explore Heap Dump</string>
+  <string name="leak_canary_loading_title">Loadingâ€¦</string>
+  <string name="leak_canary_notification_analysing">Analyzing Heap Dump</string>
+  <string name="leak_canary_notification_channel_low">LeakCanary Low Priority</string>
+  <string name="leak_canary_notification_channel_result">LeakCanary Result</string>
+  <string name="leak_canary_notification_dumping">Dumping Heap</string>
+  <string name="leak_canary_notification_message">Tap for more details</string>
+  <string name="leak_canary_notification_no_retained_object_title">All retained objects were garbage collected</string>
+  <string name="leak_canary_notification_no_retained_object_content">Tap to dismiss</string>
+  <string name="leak_canary_notification_retained_debugger_attached">Waiting for debugger to detach</string>
+  <string name="leak_canary_notification_retained_dump_failed">Failed to dump heap</string>
+  <string name="leak_canary_notification_retained_dump_wait">Last heap dump was less than a minute ago</string>
+  <string name="leak_canary_notification_retained_title">%d retained objects, tap to dump heap</string>
+  <string name="leak_canary_notification_retained_visible">App visible, waiting until %d retained objects</string>
+  <string name="leak_canary_share_with">Share withâ€¦</string>
+  <string name="leak_canary_display_activity_label">Leaks</string>
+  <string name="leak_canary_storage_permission_activity_label">Storage permission</string>
+  <string name="leak_canary_toast_heap_dump">LeakCanary is dumping memory to investigate leaks.</string>
+  <string name="leak_canary_delete">Delete</string>
+  <string name="leak_canary_delete_all">Delete all</string>
+  <string name="leak_canary_delete_all_leaks_title">Are you sure you want to delete all leaks?</string>
+  <string name="leak_canary_permission_not_granted">Please grant requested permission, otherwise memory leak detection may not work.</string>
+  <string name="leak_canary_permission_notification_title">Leak detected, need permission</string>
+  <string name="leak_canary_permission_notification_text">Click to enable storage permission for %s.</string>
+  <string name="leak_canary_shortcut_label">Leaks</string>
+  <string name="leak_canary_stackoverflow_share">Share Leak On Stack Overflow</string>
+  <string name="leak_canary_failure_copied">Stacktrace copied to clipboard</string>
+  <string name="leak_canary_leak_copied">Leak info copied to clipboard</string>
+  <string name="leak_canary_failure_clipdata_label">LeakCanary failure stacktrace</string>
+  <string name="leak_canary_leak_clipdata_label">LeakCanary Leak Trace</string>
+  <string name="leak_canary_leak_not_found">Leak not found</string>
+  <string name="leak_canary_options_menu_generate_hq_bitmap">Generate HQ Bitmap</string>
+  <string name="leak_canary_options_menu_permission_toast">Please grant the External Storage Permission first, see notificationâ€¦</string>
+  <string name="leak_canary_generating_hq_bitmap_toast_notice">Rendering HQ Bitmap, this may take a whileâ€¦</string>
+  <string name="leak_canary_generating_hq_bitmap_toast_failure_notice">Could not save HQ Bitmap</string>
+  <string name="leak_canary_share_heap_dump_bitmap_screen_title">Share Heap Dump Bitmap</string>
+  <string name="leak_canary_heap_dump_screen_title">Heap Dump %s</string>
+  <string name="leak_canary_analysis_deleted_title">Analysis Deleted</string>
+  <string name="leak_canary_go_to_heap_analysis">Go to Heap Analysis</string>
+  <string name="leak_canary_heap_analysis_success_screen_row_time_format">Latest: %s</string>
+  <plurals name="leak_canary_heap_analysis_list_screen_title">
+    <item quantity="one">%d Heap Dump</item>
+    <item quantity="other">%d Heap Dumps</item>
+  </plurals>
+  <plurals name="leak_canary_group_screen_title">
+    <item quantity="one">%1$d leak at %2$s</item>
+    <item quantity="other">%1$d leaks at %2$s</item>
+  </plurals>
+  <string name="leak_canary_group_list_time_label">Last leaked %s</string>
+  <string name="leak_canary_import_unsupported_file_extension">Could not import %s, this is not an hprof file.</string>
+  <string name="leak_canary_import_from_title">Import Fromâ€¦</string>
+  <string name="leak_canary_dump_heap">Dump Heap Now</string>
+  <string name="leak_canary_import_hprof_file">Import Heap Dump</string>
+  <string name="leak_canary_options_menu_render_heap_dump">Render Heap Dump</string>
+  <string name="leak_canary_help_title">Tap here to learn more</string>
+  <string name="leak_canary_test_class_name" translatable="false">org.junit.Test</string>
+  <string name="leak_canary_tv_analysis_success">Heap Analysis performed: %1$d application leaks, %2$d library leaks. See details in Logcat</string>
+  <string name="leak_canary_tv_analysis_failure">Heap Analysis failed, see details in Logcat</string>
+  <string name="leak_canary_tv_toast_retained_objects">%1$d retained objects. Heap dump threshold is %2$d.\nBackground the app to trigger heap dump immediately</string>
+  <string name="leak_canary_leak_missing_browser_error">No browser app installed</string>
+</resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_themes.xml b/leakcanary-android-core/src/main/res/values/leak_canary_themes.xml
new file mode 100644
index 00000000..bd8ddb82
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_themes.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Holo">
+    <item name="android:windowBackground">@color/leak_canary_background_color</item>
+    <item name="android:actionBarStyle">@style/leak_canary_Widget.ActionBar</item>
+  </style>
+
+  <style name="leak_canary_Widget.ActionBar" parent="android:Widget.Holo.ActionBar">
+    <item name="android:background">@color/leak_canary_background_color</item>
+    <item name="android:windowContentOverlay">@null</item>
+  </style>
+
+  <style name="leak_canary_Theme.Transparent" parent="android:Theme">
+    <item name="android:windowIsTranslucent">true</item>
+    <item name="android:windowBackground">@android:color/transparent</item>
+    <item name="android:windowContentOverlay">@null</item>
+    <item name="android:windowNoTitle">true</item>
+    <item name="android:backgroundDimEnabled">false</item>
+  </style>
+</resources>
diff --git a/leakcanary-android-core/src/main/res/xml/leak_canary_file_paths.xml b/leakcanary-android-core/src/main/res/xml/leak_canary_file_paths.xml
new file mode 100644
index 00000000..07a6ec60
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/xml/leak_canary_file_paths.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<paths>
+  <external-path name="downloads" path="Download/" />
+  <files-path name="leakcanary" path="leakcanary/" />
+  <cache-path name="leakcanary_cache" path="leakcanary/" />
+
+</paths>
diff --git a/leakcanary-android-core/src/test/java/leakcanary/LeakCanaryConfigTest.kt b/leakcanary-android-core/src/test/java/leakcanary/LeakCanaryConfigTest.kt
new file mode 100644
index 00000000..9e3ffbd1
--- /dev/null
+++ b/leakcanary-android-core/src/test/java/leakcanary/LeakCanaryConfigTest.kt
@@ -0,0 +1,25 @@
+package leakcanary
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import kotlin.reflect.full.memberFunctions
+import kotlin.reflect.full.memberProperties
+
+class LeakCanaryConfigTest {
+
+  /**
+   * Validates that each field in [LeakCanary.Config] has a matching builder function
+   * in [LeakCanary.Config.Builder]
+   */
+  @Test fun `LeakCanary Config Builder matches LeakCanary Config`() {
+    assertThat(configProperties())
+      .containsExactlyInAnyOrderElementsOf(configBuilderFunctions())
+  }
+
+  private fun configBuilderFunctions() = LeakCanary.Config.Builder::class.memberFunctions
+    .map { it.name }
+    .subtract(setOf("build", "equals", "hashCode", "toString"))
+
+  private fun configProperties() = LeakCanary.Config::class.memberProperties
+    .map { it.name }
+}
diff --git a/leakcanary-android-core/src/test/java/leakcanary/internal/activity/screen/LeakTraceWrapperTest.kt b/leakcanary-android-core/src/test/java/leakcanary/internal/activity/screen/LeakTraceWrapperTest.kt
new file mode 100644
index 00000000..7c7faad7
--- /dev/null
+++ b/leakcanary-android-core/src/test/java/leakcanary/internal/activity/screen/LeakTraceWrapperTest.kt
@@ -0,0 +1,284 @@
+package leakcanary.internal.activity.screen
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+
+class LeakTraceWrapperTest {
+
+  @Test fun `short string stays identical`() {
+    val string = "12\n"
+
+    val wrapped = LeakTraceWrapper.wrap(string, 4)
+
+    assertThat(wrapped).isEqualTo(string)
+  }
+
+  @Test fun `string at width stays identical`() {
+    val string = "1234\n"
+
+    val wrapped = LeakTraceWrapper.wrap(string, 4)
+
+    assertThat(wrapped).isEqualTo(string)
+  }
+
+  @Test fun `string at width no newline stays identical`() {
+    val string = "1234"
+
+    val wrapped = LeakTraceWrapper.wrap(string, 4)
+
+    assertThat(wrapped).isEqualTo(string)
+  }
+
+  @Test fun `string wrapped without newline stays has no trailing newline`() {
+    val string = "12 34"
+
+    val wrapped = LeakTraceWrapper.wrap(string, 4)
+
+    assertThat(wrapped).isEqualTo("12\n34")
+  }
+
+  @Test fun `wrap line at space removing space`() {
+    val string = "12 34\n"
+
+    val wrapped = LeakTraceWrapper.wrap(string, 4)
+
+    assertThat(wrapped).isEqualTo("12\n34\n")
+  }
+
+  @Test fun `wrap line at space keeps prefix`() {
+    val prefix = "â”‚   "
+    val string = "${prefix}12 34\n"
+
+    val wrapped = LeakTraceWrapper.wrap(string, prefix.length + 4)
+
+    assertThat(wrapped).isEqualTo("${prefix}12\n${prefix}34\n")
+  }
+
+  @Test fun `wrap line at space keeps non breaking space`() {
+    val string = "\u200B 12 34\n"
+    val wrapped = LeakTraceWrapper.wrap(string, 5)
+
+    assertThat(wrapped).isEqualTo("\u200B 12\n\u200B 34\n")
+  }
+
+  @Test fun `wrap line at period keeping period`() {
+    val string = "12.34\n"
+
+    val wrapped = LeakTraceWrapper.wrap(string, 4)
+
+    assertThat(wrapped).isEqualTo("12.\n34\n")
+  }
+
+  @Test fun `two periods wraps at last period`() {
+    val string = "1.2.34\n"
+
+    val wrapped = LeakTraceWrapper.wrap(string, 5)
+
+    assertThat(wrapped).isEqualTo("1.2.\n34\n")
+  }
+
+  @Test fun `no space or period is wrapped at max width`() {
+    val string = "1234\n"
+
+    val wrapped = LeakTraceWrapper.wrap(string, 2)
+
+    assertThat(wrapped).isEqualTo("12\n34\n")
+  }
+
+  @Test fun `two consecutive periods wraps at last period`() {
+    val string = "12..34\n"
+
+    val wrapped = LeakTraceWrapper.wrap(string, 5)
+
+    assertThat(wrapped).isEqualTo("12..\n34\n")
+  }
+
+  @Test fun `period and space wraps at last`() {
+    val string = "12. 34\n"
+
+    val wrapped = LeakTraceWrapper.wrap(string, 5)
+
+    assertThat(wrapped).isEqualTo("12.\n34\n")
+  }
+
+  @Test fun `space and period wraps at last`() {
+    val string = "12 .34\n"
+
+    val wrapped = LeakTraceWrapper.wrap(string, 5)
+
+    assertThat(wrapped).isEqualTo("12 .\n34\n")
+  }
+
+  @Test fun `period and separated space wraps at last`() {
+    val string = "1.2 34\n"
+
+    val wrapped = LeakTraceWrapper.wrap(string, 5)
+
+    assertThat(wrapped).isEqualTo("1.2\n34\n")
+  }
+
+  @Test fun `several spaces are all removed`() {
+    val string = "12  34\n"
+
+    val wrapped = LeakTraceWrapper.wrap(string, 5)
+
+    assertThat(wrapped).isEqualTo("12\n34\n")
+  }
+
+  @Test fun `several periods all keeping period`() {
+    val string = "12...34\n"
+    val wrapped = LeakTraceWrapper.wrap(string, 4)
+    assertThat(wrapped).isEqualTo("12..\n.34\n")
+  }
+
+  @Test fun `prefix applied to all lines`() {
+    val prefix = "â”‚  "
+    val part1 = "A word"
+    val part2 = "and a"
+    val part3 = "pk.g"
+    val string = "\n${prefix}$part1 $part2 $part3"
+    val wrappedString = LeakTraceWrapper.wrap(string, prefix.length + part1.length + 1)
+
+    assertThat(wrappedString).isEqualTo(
+      """
+${prefix}$part1
+${prefix}$part2
+${prefix}$part3"""
+    )
+  }
+
+  @Test fun `underline is positioned under a word on a line that will not be wrapped`() {
+    val string = """
+â”‚  A word and a pk.g
+â”‚         ~~~      
+        """
+    val wrappedString = LeakTraceWrapper.wrap(string, 10)
+
+    assertThat(wrappedString).isEqualTo(
+      """
+â”‚  A word
+â”‚  and a
+â”‚  ~~~
+â”‚  pk.g
+"""
+    )
+  }
+
+  @Test fun `underline is positioned under a word on last line`() {
+    val string = """
+â”‚  A word and a pk.g
+â”‚                  ~           
+        """
+    val wrappedString = LeakTraceWrapper.wrap(string, 10)
+
+    assertThat(wrappedString).isEqualTo(
+      """
+â”‚  A word
+â”‚  and a
+â”‚  pk.g
+â”‚     ~
+"""
+    )
+  }
+
+  @Test fun `underline within multiline string`() {
+    val string = """
+â”œâ”€ com.example.FooFooFooFooFooFooFoo instance
+â”‚    Leaking: UNKNOWN
+â”‚    â†“ FooFooFooFooFooFooFoo.barbarbarbarbarbarbarbar
+â”‚                            ~~~~~~~~~~~~~~~~~~~~~~~~
+"""
+
+    val wrappedString = LeakTraceWrapper.wrap(string, 30)
+
+    assertThat(wrappedString).isEqualTo(
+      """
+â”œâ”€ com.example.
+â”‚  FooFooFooFooFooFooFoo
+â”‚  instance
+â”‚    Leaking: UNKNOWN
+â”‚    â†“ FooFooFooFooFooFooFoo.
+â”‚    barbarbarbarbarbarbarbar
+â”‚    ~~~~~~~~~~~~~~~~~~~~~~~~
+"""
+    )
+  }
+
+  @Test fun `a real leak trace is correctly wrapped`() {
+    val string = """
+â”¬â”€â”€â”€
+â”‚ GC Root: System class
+â”‚
+â”œâ”€ leakcanary.internal.InternalAppWatcher class
+â”‚    Leaking: NO (ExampleApplicationâ†“ is not leaking and a class is never leaking)
+â”‚    â†“ static InternalAppWatcher.application
+â”œâ”€ com.example.leakcanary.ExampleApplication instance
+â”‚    Leaking: NO (Application is a singleton)
+â”‚    ExampleApplication does not wrap an activity context
+â”‚    â†“ ExampleApplication.leakedViews
+â”‚                         ~~~~~~~~~~~
+â”œâ”€ java.util.ArrayList instance
+â”‚    Leaking: UNKNOWN
+â”‚    â†“ ArrayList.array
+â”‚                ~~~~~
+â”œâ”€ java.lang.Object[] array
+â”‚    Leaking: UNKNOWN
+â”‚    â†“ Object[].[0]
+â”‚               ~~~
+â”œâ”€ android.widget.TextView instance
+â”‚    Leaking: YES (View.mContext references a destroyed activity)
+â”‚    mContext instance of com.example.leakcanary.MainActivity with mDestroyed = true
+â”‚    View#mParent is set
+â”‚    View#mAttachInfo is null (view detached)
+â”‚    View.mWindowAttachCount = 1
+â”‚    â†“ TextView.mContext
+â•°â†’ com.example.leakcanary.MainActivity instance
+â€‹     Leaking: YES (ObjectWatcher was watching this because com.example.leakcanary.MainActivity received Activity#onDestroy() callback and Activity#mDestroyed is true)
+â€‹     key = b3dd6589-560d-48dc-9fbb-ab8300e5752b
+â€‹     watchDurationMillis = 5117
+â€‹     retainedDurationMillis = 110
+"""
+
+    val wrappedString = LeakTraceWrapper.wrap(string, 80)
+
+    assertThat(wrappedString).isEqualTo(
+      """
+â”¬â”€â”€â”€
+â”‚ GC Root: System class
+â”‚
+â”œâ”€ leakcanary.internal.InternalAppWatcher class
+â”‚    Leaking: NO (ExampleApplicationâ†“ is not leaking and a class is never
+â”‚    leaking)
+â”‚    â†“ static InternalAppWatcher.application
+â”œâ”€ com.example.leakcanary.ExampleApplication instance
+â”‚    Leaking: NO (Application is a singleton)
+â”‚    ExampleApplication does not wrap an activity context
+â”‚    â†“ ExampleApplication.leakedViews
+â”‚                         ~~~~~~~~~~~
+â”œâ”€ java.util.ArrayList instance
+â”‚    Leaking: UNKNOWN
+â”‚    â†“ ArrayList.array
+â”‚                ~~~~~
+â”œâ”€ java.lang.Object[] array
+â”‚    Leaking: UNKNOWN
+â”‚    â†“ Object[].[0]
+â”‚               ~~~
+â”œâ”€ android.widget.TextView instance
+â”‚    Leaking: YES (View.mContext references a destroyed activity)
+â”‚    mContext instance of com.example.leakcanary.MainActivity with mDestroyed =
+â”‚    true
+â”‚    View#mParent is set
+â”‚    View#mAttachInfo is null (view detached)
+â”‚    View.mWindowAttachCount = 1
+â”‚    â†“ TextView.mContext
+â•°â†’ com.example.leakcanary.MainActivity instance
+â€‹     Leaking: YES (ObjectWatcher was watching this because com.example.
+â€‹     leakcanary.MainActivity received Activity#onDestroy() callback and
+â€‹     Activity#mDestroyed is true)
+â€‹     key = b3dd6589-560d-48dc-9fbb-ab8300e5752b
+â€‹     watchDurationMillis = 5117
+â€‹     retainedDurationMillis = 110
+"""
+    )
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-instrumentation/api/leakcanary-android-instrumentation.api b/leakcanary-android-instrumentation/api/leakcanary-android-instrumentation.api
new file mode 100644
index 00000000..83886cdf
--- /dev/null
+++ b/leakcanary-android-instrumentation/api/leakcanary-android-instrumentation.api
@@ -0,0 +1,121 @@
+public final class leakcanary/AndroidDetectLeaksAssert : leakcanary/DetectLeaksAssert {
+	public static final field Companion Lleakcanary/AndroidDetectLeaksAssert$Companion;
+	public fun <init> ()V
+	public fun <init> (Lleakcanary/DetectLeaksInterceptor;Lleakcanary/HeapAnalysisReporter;)V
+	public synthetic fun <init> (Lleakcanary/DetectLeaksInterceptor;Lleakcanary/HeapAnalysisReporter;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public fun assertNoLeaks (Ljava/lang/String;)V
+}
+
+public final class leakcanary/AndroidDetectLeaksAssert$Companion {
+	public final fun getAssertionTag (Lshark/HeapAnalysisSuccess;)Ljava/lang/String;
+	public final fun getTotalDurationMillis (Lshark/HeapAnalysisSuccess;)Ljava/lang/Integer;
+	public final fun getWaitForRetainedDurationMillis (Lshark/HeapAnalysisSuccess;)Ljava/lang/Integer;
+}
+
+public final class leakcanary/AndroidDetectLeaksInterceptor : leakcanary/DetectLeaksInterceptor {
+	public fun <init> ()V
+	public fun <init> (Landroid/app/Instrumentation;Lleakcanary/ObjectWatcher;J)V
+	public synthetic fun <init> (Landroid/app/Instrumentation;Lleakcanary/ObjectWatcher;JILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public fun waitUntilReadyForHeapAnalysis ()Lleakcanary/HeapAnalysisDecision;
+}
+
+public final class leakcanary/DetectLeaksAfterTestSuccess : org/junit/rules/TestRule {
+	public static final field Companion Lleakcanary/DetectLeaksAfterTestSuccess$Companion;
+	public fun <init> ()V
+	public fun <init> (Ljava/lang/String;)V
+	public synthetic fun <init> (Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public fun apply (Lorg/junit/runners/model/Statement;Lorg/junit/runner/Description;)Lorg/junit/runners/model/Statement;
+}
+
+public final class leakcanary/DetectLeaksAfterTestSuccess$Companion {
+	public final fun detectLeaksAfterTestSuccessWrapping (Lorg/junit/rules/RuleChain;Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lorg/junit/rules/RuleChain;
+}
+
+public abstract interface class leakcanary/DetectLeaksAssert {
+	public static final field Companion Lleakcanary/DetectLeaksAssert$Companion;
+	public abstract fun assertNoLeaks (Ljava/lang/String;)V
+}
+
+public final class leakcanary/DetectLeaksAssert$Companion {
+	public final fun update (Lleakcanary/DetectLeaksAssert;)V
+}
+
+public abstract interface class leakcanary/DetectLeaksInterceptor {
+	public abstract fun waitUntilReadyForHeapAnalysis ()Lleakcanary/HeapAnalysisDecision;
+}
+
+public abstract class leakcanary/HeapAnalysisDecision {
+}
+
+public final class leakcanary/HeapAnalysisDecision$AnalyzeHeap : leakcanary/HeapAnalysisDecision {
+	public static final field INSTANCE Lleakcanary/HeapAnalysisDecision$AnalyzeHeap;
+}
+
+public final class leakcanary/HeapAnalysisDecision$NoHeapAnalysis : leakcanary/HeapAnalysisDecision {
+	public fun <init> (Ljava/lang/String;)V
+	public final fun getReason ()Ljava/lang/String;
+}
+
+public abstract interface class leakcanary/HeapAnalysisReporter {
+	public abstract fun reportHeapAnalysis (Lshark/HeapAnalysis;)V
+}
+
+public final class leakcanary/InstrumentationLeakDetector {
+	public static final field Companion Lleakcanary/InstrumentationLeakDetector$Companion;
+	public fun <init> ()V
+	public final fun detectLeaks ()Lleakcanary/InstrumentationLeakDetector$Result;
+}
+
+public final class leakcanary/InstrumentationLeakDetector$Companion {
+	public final fun updateConfig ()V
+}
+
+public abstract class leakcanary/InstrumentationLeakDetector$Result {
+}
+
+public final class leakcanary/InstrumentationLeakDetector$Result$AnalysisPerformed : leakcanary/InstrumentationLeakDetector$Result {
+	public fun <init> (Lshark/HeapAnalysis;)V
+	public final fun getHeapAnalysis ()Lshark/HeapAnalysis;
+}
+
+public final class leakcanary/InstrumentationLeakDetector$Result$NoAnalysis : leakcanary/InstrumentationLeakDetector$Result {
+	public fun <init> (Ljava/lang/String;)V
+	public final fun getReason ()Ljava/lang/String;
+}
+
+public final class leakcanary/LeakAssertions {
+	public static final field INSTANCE Lleakcanary/LeakAssertions;
+	public static final field NO_TAG Ljava/lang/String;
+	public final fun assertNoLeaks (Ljava/lang/String;)V
+	public static synthetic fun assertNoLeaks$default (Lleakcanary/LeakAssertions;Ljava/lang/String;ILjava/lang/Object;)V
+}
+
+public final class leakcanary/NoLeakAssertionFailedError : java/lang/AssertionError {
+	public static final field Companion Lleakcanary/NoLeakAssertionFailedError$Companion;
+	public fun <init> (Lshark/HeapAnalysisSuccess;)V
+	public final fun getHeapAnalysis ()Lshark/HeapAnalysisSuccess;
+}
+
+public final class leakcanary/NoLeakAssertionFailedError$Companion {
+	public final fun throwOnApplicationLeaks ()Lleakcanary/HeapAnalysisReporter;
+}
+
+public abstract interface annotation class leakcanary/SkipLeakDetection : java/lang/annotation/Annotation {
+	public static final field Companion Lleakcanary/SkipLeakDetection$Companion;
+	public abstract fun assertionTags ()[Ljava/lang/String;
+	public abstract fun message ()Ljava/lang/String;
+}
+
+public final class leakcanary/SkipLeakDetection$Companion {
+	public final fun shouldSkipTest (Ljava/lang/String;Lleakcanary/SkipLeakDetection;Ljava/lang/String;)Z
+	public final fun shouldSkipTest (Lorg/junit/runner/Description;Ljava/lang/String;)Z
+}
+
+public final class leakcanary/TestDescriptionHolder : org/junit/rules/TestRule {
+	public static final field INSTANCE Lleakcanary/TestDescriptionHolder;
+	public fun apply (Lorg/junit/runners/model/Statement;Lorg/junit/runner/Description;)Lorg/junit/runners/model/Statement;
+	public final fun getTestDescription ()Lorg/junit/runner/Description;
+	public final fun isEvaluating ()Z
+	public final fun wrap (Lorg/junit/runners/model/Statement;Lorg/junit/runner/Description;)Lorg/junit/runners/model/Statement;
+}
+
diff --git a/leakcanary-android-instrumentation/build.gradle b/leakcanary-android-instrumentation/build.gradle
new file mode 100644
index 00000000..016f90d7
--- /dev/null
+++ b/leakcanary-android-instrumentation/build.gradle
@@ -0,0 +1,38 @@
+plugins {
+  id("com.android.library")
+  id("org.jetbrains.kotlin.android")
+  id("com.vanniktech.maven.publish")
+}
+
+dependencies {
+  api projects.leakcanaryAndroidCore
+
+  implementation libs.androidX.test.runner
+  implementation libs.kotlin.stdlib
+
+  // AppWatcher auto installer for running tests
+  androidTestImplementation projects.leakcanaryObjectWatcherAndroid
+  // Plumber auto installer for running tests
+  androidTestImplementation projects.plumberAndroid
+  androidTestImplementation libs.androidX.test.core
+  androidTestImplementation libs.androidX.test.espresso
+  androidTestImplementation libs.androidX.test.rules
+  androidTestImplementation libs.androidX.fragment
+  androidTestImplementation libs.assertjCore
+}
+
+android {
+  compileSdk versions.compileSdk
+  defaultConfig {
+    targetSdk versions.compileSdk
+    minSdk versions.minSdk
+    testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+  }
+  buildFeatures.buildConfig = false
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    // junit references java.lang.management
+    ignore 'InvalidPackage'
+    checkOnly 'Interoperability'
+  }
+}
diff --git a/leakcanary-android-instrumentation/gradle.properties b/leakcanary-android-instrumentation/gradle.properties
new file mode 100644
index 00000000..ab8ed750
--- /dev/null
+++ b/leakcanary-android-instrumentation/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-android-instrumentation
+POM_NAME=LeakCanary extension for Android instrumentation tests.
+POM_PACKAGING=aar
\ No newline at end of file
diff --git a/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
new file mode 100644
index 00000000..d6bf6bf8
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary.instrumentation.test">
+
+  <application>
+    <activity android:name="leakcanary.TestActivity"/>
+  </application>
+</manifest>
diff --git a/leakcanary-android-instrumentation/src/androidTest/assets/large-dump.hprof b/leakcanary-android-instrumentation/src/androidTest/assets/large-dump.hprof
new file mode 100644
index 00000000..5caeb42b
Binary files /dev/null and b/leakcanary-android-instrumentation/src/androidTest/assets/large-dump.hprof differ
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Benchmark.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Benchmark.kt
new file mode 100644
index 00000000..2dc2db00
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Benchmark.kt
@@ -0,0 +1,58 @@
+package leakcanary
+
+import android.os.SystemClock
+import leakcanary.Profiler.runWithMethodTracing
+import shark.SharkLog
+
+/**
+ * Set of tools for benchmarking and tracing blocks of code
+ */
+object Benchmark {
+
+  /**
+   * Executes the given function [block] twice (without and with method tracing to SD card) and
+   * returns the result of the function execution.
+   * First execution of [block] is done to warm up code and load any necessary libs. Second
+   * execution is measured with [runWithMethodTracing]
+   */
+  fun <T> benchmarkWithMethodTracing(block: () -> T): T {
+    SharkLog.d { "Dry run to warm up the code." }
+    block()
+    SharkLog.d { "Run with sampling" }
+    return runWithMethodTracing(block)
+  }
+
+  /**
+   * Executes the given function [block] multiple times measuring the average execution time and
+   * returns the result of the function execution.
+   * Number of executions is [times] + 1, where 1 execution is done for code warm up and other
+   * [times] executions are measured. Results of measurement will be outputted to LogCat at each
+   * iteration and in the end of measurement.
+   */
+  fun <T> benchmarkCode(
+    times: Int = 10,
+    block: () -> T
+  ): T {
+    // Warm-up run, no benchmarking
+    val result = block()
+    val measurements = mutableListOf<Long>()
+    repeat(times) {
+      val start = SystemClock.uptimeMillis()
+      block()
+      val end = SystemClock.uptimeMillis()
+      SharkLog.d { "BenchmarkCode, iteration ${it + 1}/$times, duration ${end - start}" }
+      measurements.add(end - start)
+    }
+    measurements.sort()
+    val median: Double = if (times % 2 == 0) {
+      (measurements[times / 2] + measurements[times / 2 - 1]).toDouble() / 2
+    } else {
+      measurements[times / 2].toDouble()
+    }
+    SharkLog.d {
+      "BenchmarkCode complete, $times iterations. Durations (ms): median $median, " +
+        "min ${measurements.first()}, max ${measurements.last()}"
+    }
+    return result
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/DetectLeaksAfterTestSuccessTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/DetectLeaksAfterTestSuccessTest.kt
new file mode 100644
index 00000000..e40ae8d7
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/DetectLeaksAfterTestSuccessTest.kt
@@ -0,0 +1,38 @@
+package leakcanary
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.RuleChain
+import org.junit.rules.TestRule
+import org.junit.runner.Description
+import org.junit.runners.model.Statement
+
+class DetectLeaksAfterTestSuccessTest {
+
+  object CheckAssertNoLeaksInvoked : TestRule {
+    override fun apply(base: Statement, description: Description): Statement {
+      return object : Statement() {
+        override fun evaluate() {
+          try {
+            var assertNoLeaksInvoked = false
+            DetectLeaksAssert.update { tag ->
+              assertNoLeaksInvoked = true
+            }
+            base.evaluate()
+            assertThat(assertNoLeaksInvoked).isTrue()
+          } finally {
+            DetectLeaksAssert.update(AndroidDetectLeaksAssert())
+          }
+        }
+      }
+    }
+  }
+
+  @get:Rule
+  val rule: RuleChain = RuleChain.outerRule(CheckAssertNoLeaksInvoked).around(DetectLeaksAfterTestSuccess())
+
+  @Test fun emptyTest() {
+    // This test triggers the rules.
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/IndexingTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/IndexingTest.kt
new file mode 100644
index 00000000..7b03ad3c
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/IndexingTest.kt
@@ -0,0 +1,30 @@
+package leakcanary
+
+import android.os.SystemClock
+import androidx.test.platform.app.InstrumentationRegistry
+import org.junit.Test
+import shark.Hprof
+import shark.HprofHeapGraph
+import shark.SharkLog
+import java.io.File
+import java.io.FileOutputStream
+
+class IndexingTest {
+
+  @Test fun indexHprof() {
+    val instrumentation = InstrumentationRegistry.getInstrumentation()
+    val context = instrumentation.targetContext
+
+    val heapDumpFile = File(context.filesDir, "AnalysisDurationTest.hprof")
+    context.assets.open("large-dump.hprof").copyTo(FileOutputStream(heapDumpFile))
+
+    Hprof.open(heapDumpFile).use { hprof ->
+      SharkLog.d { "Start indexing" }
+      val before = SystemClock.uptimeMillis()
+      HprofHeapGraph.indexHprof(hprof)
+      val durationMs = (SystemClock.uptimeMillis() - before)
+      SharkLog.d { "Indexing took $durationMs ms" }
+    }
+  }
+}
+
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
new file mode 100644
index 00000000..6e0e93cf
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
@@ -0,0 +1,35 @@
+package leakcanary
+
+import leakcanary.TestUtils.assertLeak
+import org.junit.After
+import org.junit.Before
+import org.junit.Test
+import java.util.Date
+
+/**
+ * Tests that the [InstrumentationLeakDetector] can detect leaks
+ * in instrumentation tests
+ */
+class InstrumentationLeakDetectorTest {
+
+  @Before fun setUp() {
+    AppWatcher.objectWatcher
+      .clearWatchedObjects()
+  }
+
+  @After fun tearDown() {
+    AppWatcher.objectWatcher
+      .clearWatchedObjects()
+  }
+
+  @Test fun detectsLeak() {
+    leaking = Date()
+    val objectWatcher = AppWatcher.objectWatcher
+    objectWatcher.expectWeaklyReachable(leaking, "This date should not live beyond the test")
+    assertLeak(Date::class.java)
+  }
+
+  companion object {
+    private lateinit var leaking: Any
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleLeaksTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleLeaksTest.kt
new file mode 100644
index 00000000..32e284c7
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleLeaksTest.kt
@@ -0,0 +1,187 @@
+package leakcanary
+
+import android.os.Bundle
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import androidx.fragment.app.Fragment
+import androidx.lifecycle.ViewModel
+import com.squareup.leakcanary.instrumentation.test.R
+import leakcanary.TestUtils.assertLeak
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import shark.LeakTraceObject.LeakingStatus
+
+class LifecycleLeaksTest : HasActivityTestRule<TestActivity> {
+
+  class TestViewModel : ViewModel()
+
+  class TestFragment : Fragment() {
+    override fun onCreateView(
+      inflater: LayoutInflater,
+      container: ViewGroup?,
+      savedInstanceState: Bundle?
+    ): View {
+      return View(context)
+    }
+  }
+
+  class FragmentHoldingLeaky : Fragment() {
+    val leaky = Any()
+  }
+
+  @get:Rule
+  override val activityRule = activityTestRule<TestActivity>(
+    initialTouchMode = false,
+    launchActivity = false
+  )
+
+  @Before fun setUp() {
+    AppWatcher.objectWatcher
+      .clearWatchedObjects()
+  }
+
+  @After fun tearDown() {
+    AppWatcher.objectWatcher
+      .clearWatchedObjects()
+  }
+
+  @Test fun activityLeakDetected() {
+    triggersOnActivityCreated {
+      activityRule.launchActivity(null)
+    }
+
+    activity retained {
+      triggersOnActivityDestroyed {
+        activityRule.finishActivity()
+      }
+      assertLeak(TestActivity::class.java)
+    }
+  }
+
+  @Test fun activityViewModelLeakDetected() {
+    triggersOnActivityCreated {
+      activityRule.launchActivity(null)
+    }
+
+    val viewModel = getOnMainSync {
+      activity.installViewModel(TestViewModel::class)
+    }
+
+    viewModel retained {
+      triggersOnActivityDestroyed {
+        activityRule.finishActivity()
+      }
+      assertLeak(TestViewModel::class.java)
+    }
+  }
+
+  @Test fun fragmentViewModelLeakDetected() {
+    triggersOnActivityCreated {
+      activityRule.launchActivity(null)
+    }
+
+    val viewModel = getOnMainSync {
+      val fragment = Fragment()
+      activity.addFragmentNow(fragment)
+      val viewModel = fragment.installViewModel(TestViewModel::class)
+      activity.removeFragmentNow(fragment)
+      viewModel
+    }
+
+    viewModel retained {
+      assertLeak(TestViewModel::class.java)
+    }
+  }
+
+  @Test
+  fun fragmentLeakDetected() {
+    triggersOnActivityCreated {
+      activityRule.launchActivity(null)
+    }
+
+    val fragment = getOnMainSync {
+      val fragment = Fragment()
+      activity.addFragmentNow(fragment)
+      activity.removeFragmentNow(fragment)
+      fragment
+    }
+
+    fragment retained {
+      val expectedLeakClass = Fragment::class.java
+      assertLeak { (heapAnalysis, leakTrace) ->
+        val className = leakTrace.leakingObject.className
+        assertThat(className)
+          .describedAs("$heapAnalysis")
+          .isEqualTo(expectedLeakClass.name)
+        assertThat(leakTrace.leakingObject.leakingStatusReason)
+          .describedAs("$heapAnalysis")
+          .contains("Fragment.mLifecycleRegistry.state is DESTROYED")
+      }
+    }
+  }
+
+  @Test
+  fun fragmentNotLeakingDetected() {
+    triggersOnActivityCreated {
+      activityRule.launchActivity(null)
+    }
+
+    getOnMainSync {
+      val fragment = FragmentHoldingLeaky()
+      activity.addFragmentNow(fragment)
+      AppWatcher.objectWatcher.expectWeaklyReachable(fragment.leaky, "leaky leaks")
+    }
+
+    assertLeak { (heapAnalysis, leakTrace) ->
+      val refToLeaky = leakTrace.referencePath.last()
+      assertThat(refToLeaky.referenceName)
+        .describedAs("$heapAnalysis")
+        .isEqualTo("leaky")
+      val fragment = refToLeaky.originObject
+      // AssertJ uses lambdas when comparing enum values, which fails on older Android versions.
+      if (fragment.leakingStatus != LeakingStatus.NOT_LEAKING) {
+        throw AssertionError(
+          "${fragment.leakingStatus} should be ${LeakingStatus.NOT_LEAKING}"
+        )
+      }
+      assertThat(fragment.leakingStatusReason).isEqualTo(
+        "Fragment.mLifecycleRegistry.state is RESUMED"
+      )
+    }
+  }
+
+  @Test
+  fun fragmentViewLeakDetected() {
+    triggersOnActivityCreated {
+      activityRule.launchActivity(null)
+    }
+
+    val fragment = triggersOnFragmentCreated {
+      getOnMainSync {
+        val fragment = TestFragment()
+        activity.replaceWithBackStack(fragment, R.id.fragments)
+        fragment
+      }
+    }
+
+    val fragmentView = getOnMainSync {
+      fragment.view!!
+    }
+
+    triggersOnFragmentViewDestroyed {
+      runOnMainSync {
+        // Add a new fragment again, which destroys the view of the previous fragment and puts
+        // the first fragment in the backstack.
+        activity.replaceWithBackStack(Fragment(), R.id.fragments)
+      }
+    }
+
+    fragmentView retained {
+      assertLeak(View::class.java)
+    }
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleTestUtils.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleTestUtils.kt
new file mode 100644
index 00000000..8af5c1c7
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleTestUtils.kt
@@ -0,0 +1,167 @@
+package leakcanary
+
+import android.app.Activity
+import android.app.Application
+import android.os.Bundle
+import android.os.Looper
+import androidx.annotation.IdRes
+import androidx.fragment.app.Fragment
+import androidx.fragment.app.FragmentActivity
+import androidx.fragment.app.FragmentManager
+import androidx.lifecycle.ViewModel
+import androidx.lifecycle.ViewModelProvider
+import androidx.lifecycle.ViewModelProvider.Factory
+import androidx.lifecycle.ViewModelStoreOwner
+import androidx.test.core.app.ApplicationProvider
+import androidx.test.platform.app.InstrumentationRegistry
+import androidx.test.rule.ActivityTestRule
+import java.util.concurrent.CountDownLatch
+import java.util.concurrent.atomic.AtomicReference
+import kotlin.reflect.KClass
+import leakcanary.internal.friendly.noOpDelegate
+
+interface HasActivityTestRule<T : Activity> {
+  val activityRule: ActivityTestRule<T>
+
+  val activity: T
+    get() = activityRule.activity!!
+}
+
+inline fun <reified T : Activity> activityTestRule(
+  initialTouchMode: Boolean = false,
+  launchActivity: Boolean = true
+): ActivityTestRule<T> = ActivityTestRule(
+  T::class.java, initialTouchMode, launchActivity
+)
+
+fun <R> triggersOnActivityCreated(block: () -> R): R {
+  return waitForTriggered(block) { triggered ->
+    val app = ApplicationProvider.getApplicationContext<Application>()
+    app.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
+      override fun onActivityCreated(
+        activity: Activity,
+        savedInstanceState: Bundle?
+      ) {
+        app.unregisterActivityLifecycleCallbacks(this)
+        triggered()
+      }
+    })
+  }
+}
+
+infix fun Any.retained(block: () -> Unit) {
+  block()
+  "" + this
+}
+
+fun <T : FragmentActivity, R> HasActivityTestRule<T>.triggersOnActivityDestroyed(block: () -> R): R {
+  return waitForTriggered(block) { triggered ->
+    val testActivity = activity
+    testActivity.application.registerActivityLifecycleCallbacks(
+      object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
+        override fun onActivityDestroyed(activity: Activity) {
+          if (activity == testActivity) {
+            activity.application.unregisterActivityLifecycleCallbacks(this)
+            Looper.myQueue()
+              .addIdleHandler {
+                triggered()
+                false
+              }
+          }
+        }
+      })
+  }
+}
+
+fun <T : FragmentActivity, R> HasActivityTestRule<T>.triggersOnFragmentCreated(block: () -> R): R {
+  return waitForTriggered(block) { triggered ->
+    val fragmentManager = activity.supportFragmentManager
+    fragmentManager.registerFragmentLifecycleCallbacks(
+      object : FragmentManager.FragmentLifecycleCallbacks() {
+        override fun onFragmentCreated(
+          fm: FragmentManager,
+          fragment: Fragment,
+          savedInstanceState: Bundle?
+        ) {
+          fragmentManager.unregisterFragmentLifecycleCallbacks(this)
+          triggered()
+        }
+      }, false
+    )
+  }
+}
+
+fun <T : FragmentActivity, R> HasActivityTestRule<T>.triggersOnFragmentViewDestroyed(block: () -> R): R {
+  return waitForTriggered(block) { triggered ->
+    val fragmentManager = activity.supportFragmentManager
+    fragmentManager.registerFragmentLifecycleCallbacks(
+      object : FragmentManager.FragmentLifecycleCallbacks() {
+        override fun onFragmentViewDestroyed(
+          fm: FragmentManager,
+          fragment: Fragment
+        ) {
+          fragmentManager.unregisterFragmentLifecycleCallbacks(this)
+          triggered()
+        }
+      }, false
+    )
+  }
+}
+
+fun <R> waitForTriggered(
+  trigger: () -> R,
+  triggerListener: (triggered: () -> Unit) -> Unit
+): R {
+  val latch = CountDownLatch(1)
+  triggerListener {
+    latch.countDown()
+  }
+  val result = trigger()
+  latch.await()
+  return result
+}
+
+fun <T> getOnMainSync(block: () -> T): T {
+  val resultHolder = AtomicReference<T>()
+  val latch = CountDownLatch(1)
+  InstrumentationRegistry.getInstrumentation()
+    .runOnMainSync {
+      resultHolder.set(block())
+      latch.countDown()
+    }
+  latch.await()
+  return resultHolder.get()
+}
+
+fun runOnMainSync(block: () -> Unit) = InstrumentationRegistry.getInstrumentation()
+  .runOnMainSync(block)
+
+fun <T : ViewModel> ViewModelStoreOwner.installViewModel(modelClass: KClass<T>): T =
+  ViewModelProvider(this, object : Factory {
+    override fun <T : ViewModel> create(modelClass: Class<T>): T = modelClass.newInstance()
+  }).get(modelClass.java)
+
+fun FragmentActivity.addFragmentNow(fragment: Fragment) {
+  supportFragmentManager
+    .beginTransaction()
+    .add(0, fragment)
+    .commitNow()
+}
+
+fun FragmentActivity.replaceWithBackStack(
+  fragment: Fragment,
+  @IdRes containerViewId: Int
+) {
+  supportFragmentManager
+    .beginTransaction()
+    .addToBackStack(null)
+    .replace(containerViewId, fragment)
+    .commit()
+}
+
+fun FragmentActivity.removeFragmentNow(fragment: Fragment) {
+  supportFragmentManager
+    .beginTransaction()
+    .remove(fragment)
+    .commitNow()
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ObjectInspectorTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ObjectInspectorTest.kt
new file mode 100644
index 00000000..abfff3c5
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ObjectInspectorTest.kt
@@ -0,0 +1,47 @@
+package leakcanary
+
+import androidx.lifecycle.LifecycleObserver
+import leakcanary.TestUtils.detectLeaks
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+class ObjectInspectorTest : HasActivityTestRule<TestActivity> {
+
+  @get:Rule
+  override val activityRule = activityTestRule<TestActivity>(launchActivity = false)
+
+  @Before fun setUp() {
+    AppWatcher.objectWatcher.clearWatchedObjects()
+  }
+
+  @After fun tearDown() {
+    AppWatcher.objectWatcher.clearWatchedObjects()
+  }
+
+  @Test fun LifecycleRegistry_LeakingStatus_Is_Reported() {
+    triggersOnActivityCreated {
+      activityRule.launchActivity(null)
+    }
+    activity.lifecycle retained {
+      runOnMainSync {
+        val observer = object : LifecycleObserver {}
+        activity.lifecycle.addObserver(observer)
+        AppWatcher.objectWatcher.expectWeaklyReachable(observer, "observer")
+      }
+      triggersOnActivityDestroyed {
+        activityRule.finishActivity()
+      }
+      Thread.sleep(AppWatcher.retainedDelayMillis)
+
+      val heapAnalysis = detectLeaks()
+
+      val leaktrace = heapAnalysis.allLeaks.single().leakTraces.single()
+      val ref = leaktrace.referencePath.single { it.owningClassSimpleName == "LifecycleRegistry" }
+      val lifecycleRegistry = ref.originObject
+      assertThat(lifecycleRegistry.labels.single()).isEqualTo("state = DESTROYED")
+    }
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt
new file mode 100644
index 00000000..c56a2057
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt
@@ -0,0 +1,43 @@
+package leakcanary
+
+import android.util.Log
+import androidx.test.platform.app.InstrumentationRegistry
+import java.io.File
+import leakcanary.Profiler.runWithProfilerSampling
+import org.junit.Ignore
+import org.junit.Test
+import shark.AndroidObjectInspectors
+import shark.AndroidReferenceMatchers
+import shark.HeapAnalyzer
+import shark.KeyedWeakReferenceFinder
+import shark.SharkLog
+
+class ProfiledTest {
+
+  @Ignore
+  @Test fun analyzeLargeDump() {
+    profileAnalysis("large-dump.hprof")
+  }
+
+  private fun profileAnalysis(fileName: String) {
+    val instrumentation = InstrumentationRegistry.getInstrumentation()
+    val context = instrumentation.targetContext
+
+    val heapDumpFile = File(context.filesDir, "ProfiledTest.hprof")
+    context.assets.open(fileName)
+      .copyTo(heapDumpFile.outputStream())
+
+    runWithProfilerSampling {
+      val analyzer = HeapAnalyzer { step -> Log.d("LeakCanary", step.name) }
+      val result = analyzer.analyze(
+        heapDumpFile = heapDumpFile,
+        leakingObjectFinder = KeyedWeakReferenceFinder,
+        referenceMatchers = AndroidReferenceMatchers.appDefaults,
+        objectInspectors = AndroidObjectInspectors.appDefaults,
+        computeRetainedHeapSize = true
+      )
+      SharkLog.d { result.toString() }
+    }
+  }
+}
+
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Profiler.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Profiler.kt
new file mode 100644
index 00000000..9d523d6e
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Profiler.kt
@@ -0,0 +1,104 @@
+package leakcanary
+
+import android.os.Debug
+import shark.SharkLog
+import java.text.SimpleDateFormat
+import java.util.Date
+import java.util.Locale
+
+/**
+ * Helper class for working with Android Studio's Profiler
+ */
+internal object Profiler {
+  private const val SLEEP_TIME_MILLIS = 1000L
+  private const val SAMPLING_THREAD_NAME = "Sampling Profiler"
+
+  /**
+   * Wait until Profiler is attached and CPU Sampling is started.
+   * Calling this on main thread can lead to ANR if you try to interact with UI while it's waiting for
+   * profiler.
+   * Note: only works with 'Sample Java Methods' profiling, won't work with 'Trace Java Methods'!
+   */
+  fun waitForSamplingStart() {
+    SharkLog.d { "Waiting for sampling to start. Go to Profiler -> CPU -> Record" }
+    sleepUntil { samplingThreadExists() }
+    Thread.sleep(SLEEP_TIME_MILLIS) //Wait a bit more to ensure profiler started sampling
+    SharkLog.d { "Sampling started! Proceeding..." }
+  }
+
+  /**
+   * Wait until CPU Sampling stops.
+   * Calling this on main thread can lead to ANR if you try to interact with UI while it's waiting for
+   * profiler.
+   */
+  fun waitForSamplingStop() {
+    SharkLog.d { "Waiting for sampling to stop. Go to Profiler -> CPU -> Stop recording" }
+    sleepUntil { !samplingThreadExists() }
+    SharkLog.d { "Sampling stopped! Proceeding..." }
+  }
+
+  /**
+   * Executes the given function [block] with CPU sampling via Profiler and returns the result of
+   * the function execution.
+   * First, it awaits for Profiler to be attached at start of sampling, then executes [block]
+   * and finally waits for sampling to stop. See [waitForSamplingStart] and [waitForSamplingStop]
+   * for more details.
+   */
+  fun <T> runWithProfilerSampling(block: () -> T): T {
+    waitForSamplingStart()
+    val result = block()
+    waitForSamplingStop()
+    return result
+  }
+
+  private const val TRACES_FOLDER = "/sdcard/traces/"
+  private const val TRACE_NAME_PATTERN = "yyyy-MM-dd_HH-mm-ss_SSS'.trace'"
+  private const val BUFFER_SIZE = 50 * 1024 * 1024
+  private const val TRACE_INTERVAL_US = 1000
+
+  /**
+   * Executes the given function [block] with method tracing to SD card and returns the result of
+   * the function execution.
+   * Tracing is performed with [Debug.startMethodTracingSampling] which uses sampling with
+   * [TRACE_INTERVAL_US] microseconds interval.
+   * Trace file will be stored in [TRACES_FOLDER] and can be pulled via `adb pull` command.
+   * See Logcat output for an exact command to retrieve trace file
+   */
+  fun <T> runWithMethodTracing(block: () -> T): T {
+    java.io.File(TRACES_FOLDER).mkdirs()
+    val fileName = SimpleDateFormat(TRACE_NAME_PATTERN, Locale.US).format(Date())
+    Debug.startMethodTracingSampling(
+      "$TRACES_FOLDER$fileName",
+      BUFFER_SIZE,
+      TRACE_INTERVAL_US
+    )
+    val result = block()
+    Debug.stopMethodTracing()
+    SharkLog.d { "Method tracing complete! Run the following command to retrieve the trace:" }
+    SharkLog.d { "adb pull $TRACES_FOLDER$fileName ~/Downloads/ " }
+    return result
+  }
+
+  private inline fun sleepUntil(condition: () -> Boolean) {
+    while (true) {
+      if (condition()) return else Thread.sleep(SLEEP_TIME_MILLIS)
+    }
+  }
+
+  private fun samplingThreadExists() = findThread(SAMPLING_THREAD_NAME) != null
+
+  /**
+   * Utility to get thread by its name; in case of multiple matches first one will be returned.
+   */
+  private fun findThread(threadName: String): Thread? {
+    // Based on https://stackoverflow.com/a/1323480
+    var rootGroup = Thread.currentThread().threadGroup
+    while (rootGroup.parent != null) rootGroup = rootGroup.parent
+
+    var threads = arrayOfNulls<Thread>(rootGroup.activeCount())
+    while (rootGroup.enumerate(threads, true) == threads.size) {
+      threads = arrayOfNulls(threads.size * 2)
+    }
+    return threads.firstOrNull { it?.name == threadName }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/SkipLeakDetectionTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/SkipLeakDetectionTest.kt
new file mode 100644
index 00000000..0f9e49cd
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/SkipLeakDetectionTest.kt
@@ -0,0 +1,42 @@
+package leakcanary
+
+import leakcanary.LeakAssertions.NO_TAG
+import leakcanary.SkipLeakDetection.Companion.shouldSkipTest
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Rule
+import org.junit.Test
+
+class SkipLeakDetectionTest {
+
+  @get:Rule
+  val rule = TestDescriptionHolder
+
+  @SkipLeakDetection("")
+  @Test fun testAnnotatedSkipsLeakDetection() {
+    assertThat(shouldSkipTest(TestDescriptionHolder.testDescription, NO_TAG)).isTrue()
+  }
+
+  @Test fun testNotAnnotatedDoesNotSkipLeakDetection() {
+    assertThat(shouldSkipTest(TestDescriptionHolder.testDescription, NO_TAG)).isFalse()
+  }
+
+  @SkipLeakDetection("")
+  @Test fun testAnnotatedSkipsLeakDetectionForTag() {
+    assertThat(shouldSkipTest(TestDescriptionHolder.testDescription, "tag")).isTrue()
+  }
+
+  @SkipLeakDetection("", "tag")
+  @Test fun testAnnotatedSkipsLeakDetectionForTargetTag() {
+    assertThat(shouldSkipTest(TestDescriptionHolder.testDescription, "tag")).isTrue()
+  }
+
+  @SkipLeakDetection("", "tag1", "tag2")
+  @Test fun testAnnotatedDoesNotSkipLeakDetectionForUnlistedTag() {
+    assertThat(shouldSkipTest(TestDescriptionHolder.testDescription, "tag")).isFalse()
+  }
+
+  @SkipLeakDetection("", "tag1", "tag2")
+  @Test fun testAnnotatedSkipsLeakDetectionForListedTag() {
+    assertThat(shouldSkipTest(TestDescriptionHolder.testDescription, "tag2")).isTrue()
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestActivity.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestActivity.kt
new file mode 100644
index 00000000..d9d7367d
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestActivity.kt
@@ -0,0 +1,12 @@
+package leakcanary
+
+import android.os.Bundle
+import androidx.fragment.app.FragmentActivity
+import com.squareup.leakcanary.instrumentation.test.R
+
+class TestActivity : FragmentActivity() {
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+    setContentView(R.layout.activity_test)
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestDescriptionHolderTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestDescriptionHolderTest.kt
new file mode 100644
index 00000000..8f51e944
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestDescriptionHolderTest.kt
@@ -0,0 +1,82 @@
+package leakcanary
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.BeforeClass
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.RuleChain
+import org.junit.rules.TestRule
+import org.junit.runner.Description
+import org.junit.runners.model.Statement
+
+class TestDescriptionHolderTest {
+
+  companion object {
+    var beforeClassThrowable: Throwable? = null
+
+    @BeforeClass @JvmStatic fun beforeClass() {
+      beforeClassThrowable = try {
+        TestDescriptionHolder.testDescription
+        null
+      } catch (throwable: Throwable) {
+        throwable
+      }
+    }
+  }
+
+  class AttemptsRetrievingTestDescription : TestRule {
+
+    var beforeEvaluateThrowable: Throwable? = null
+
+    override fun apply(base: Statement, description: Description): Statement {
+      return object : Statement() {
+        override fun evaluate() {
+          beforeEvaluateThrowable = try {
+            TestDescriptionHolder.testDescription
+            null
+          } catch (throwable: Throwable) {
+            throwable
+          }
+          base.evaluate()
+        }
+      }
+    }
+  }
+
+  private val outerRule = AttemptsRetrievingTestDescription()
+  private val innerRule = AttemptsRetrievingTestDescription()
+
+  @get:Rule
+  val rule = RuleChain.outerRule(outerRule).around(TestDescriptionHolder).around(innerRule)!!
+
+  @Test
+  fun retrievingTestDescriptionDoesNotThrowWhileTestEvaluating() {
+    TestDescriptionHolder.testDescription
+  }
+
+  @Test
+  fun currentTestDescriptionIsAccurate() {
+    val stackTop = RuntimeException().stackTrace.first()
+    val testDescription = TestDescriptionHolder.testDescription
+    assertThat(testDescription.className).isEqualTo(stackTop.className)
+    assertThat(testDescription.methodName).isEqualTo(stackTop.methodName)
+  }
+
+  @Test
+  fun testDescriptionThrowsBeforeClass() {
+    // On API 16, assertThat(Throwable) causes a TypeComparators class init failure.
+    assertThat(beforeClassThrowable == null).isFalse()
+  }
+
+  @Test
+  fun testDescriptionThrowsBeforeOuterEvaluate() {
+    // On API 16, assertThat(Throwable) causes a TypeComparators class init failure.
+    assertThat(outerRule.beforeEvaluateThrowable == null).isFalse()
+  }
+
+  @Test
+  fun testDescriptionDoesNotThrowBeforeInnerEvaluate() {
+    // On API 16, assertThat(Throwable) causes a TypeComparators class init failure.
+    assertThat(innerRule.beforeEvaluateThrowable == null).isTrue()
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
new file mode 100644
index 00000000..14a80b35
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
@@ -0,0 +1,56 @@
+package leakcanary
+
+import shark.HeapAnalysis
+import shark.HeapAnalysisSuccess
+import shark.LeakTrace
+
+object TestUtils {
+
+  fun assertLeak(expectedLeakClass: Class<*>) {
+    assertLeak { (heapAnalysis, leakTrace) ->
+      val className = leakTrace.leakingObject.className
+      if (className != expectedLeakClass.name) {
+        throw AssertionError(
+          "Expected a leak of $expectedLeakClass, not $className in $heapAnalysis"
+        )
+      }
+    }
+  }
+
+  fun assertLeak(inspectLeakTrace: (Pair<HeapAnalysisSuccess, LeakTrace>) -> Unit = {}) {
+    val heapAnalysis = detectLeaks()
+    val applicationLeaks = heapAnalysis.applicationLeaks
+    if (applicationLeaks.size != 1) {
+      throw AssertionError(
+        "Expected exactly one leak in $heapAnalysis"
+      )
+    }
+
+    val leak = applicationLeaks.first()
+
+    val leakTrace = leak.leakTraces.first()
+    inspectLeakTrace(heapAnalysis to leakTrace)
+  }
+
+  fun detectLeaks(): HeapAnalysisSuccess {
+    var heapAnalysisOrNull: HeapAnalysis? = null
+    AndroidDetectLeaksAssert { heapAnalysis ->
+      heapAnalysisOrNull = heapAnalysis
+    }.assertNoLeaks("")
+    if (heapAnalysisOrNull == null) {
+      throw AssertionError(
+        "Expected analysis to be performed but skipped"
+      )
+    }
+    val heapAnalysis = heapAnalysisOrNull
+
+    if (heapAnalysis !is HeapAnalysisSuccess) {
+      throw AssertionError(
+        "Expected analysis success not $heapAnalysis"
+      )
+    }
+    // Save disk space on emulator
+    heapAnalysis.heapDumpFile.delete()
+    return heapAnalysis
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/res/layout/activity_test.xml b/leakcanary-android-instrumentation/src/androidTest/res/layout/activity_test.xml
new file mode 100644
index 00000000..39664a73
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/res/layout/activity_test.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/fragments"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    />
diff --git a/leakcanary-android-instrumentation/src/main/AndroidManifest.xml b/leakcanary-android-instrumentation/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..72e8cd5f
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/AndroidManifest.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest package="com.squareup.leakcanary.instrumentation">
+</manifest>
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/AndroidDetectLeaksAssert.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/AndroidDetectLeaksAssert.kt
new file mode 100644
index 00000000..e2a4e63c
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/AndroidDetectLeaksAssert.kt
@@ -0,0 +1,113 @@
+package leakcanary
+
+import android.os.SystemClock
+import leakcanary.internal.InstrumentationHeapAnalyzer
+import leakcanary.internal.InstrumentationHeapDumpFileProvider
+import leakcanary.HeapAnalysisDecision.NoHeapAnalysis
+import leakcanary.internal.RetryingHeapAnalyzer
+import leakcanary.internal.friendly.checkNotMainThread
+import leakcanary.internal.friendly.measureDurationMillis
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.SharkLog
+
+/**
+ * Default [DetectLeaksAssert] implementation. Uses public helpers so you should be able to
+ * create our own implementation if needed.
+ *
+ * Leak detection can be skipped by annotating tests with [SkipLeakDetection] which requires the
+ * [TestDescriptionHolder] test rule be applied and evaluating when [assertNoLeaks]
+ * is called.
+ *
+ * For improved leak detection, you should consider updating [LeakCanary.Config.leakingObjectFinder]
+ * to `FilteringLeakingObjectFinder(AndroidObjectInspectors.appLeakingObjectFilters)` when running
+ * in instrumentation tests. This changes leak detection from being incremental (based on
+ * [AppWatcher] to also scanning for all objects of known types in the heap).
+ */
+class AndroidDetectLeaksAssert(
+  private val detectLeaksInterceptor: DetectLeaksInterceptor = AndroidDetectLeaksInterceptor(),
+  private val heapAnalysisReporter: HeapAnalysisReporter = NoLeakAssertionFailedError.throwOnApplicationLeaks()
+) : DetectLeaksAssert {
+  override fun assertNoLeaks(tag: String) {
+    val assertionStartUptimeMillis = SystemClock.uptimeMillis()
+    try {
+      runLeakChecks(tag, assertionStartUptimeMillis)
+    } finally {
+      val totalDurationMillis = SystemClock.uptimeMillis() - assertionStartUptimeMillis
+      totalVmDurationMillis += totalDurationMillis
+      SharkLog.d { "Spent $totalDurationMillis ms detecting leaks on $tag, VM total so far: $totalVmDurationMillis ms" }
+    }
+  }
+
+  private fun runLeakChecks(tag: String, assertionStartUptimeMillis: Long) {
+    if (TestDescriptionHolder.isEvaluating()) {
+      val testDescription = TestDescriptionHolder.testDescription
+      if (SkipLeakDetection.shouldSkipTest(testDescription, tag)) {
+        return
+      }
+    }
+    checkNotMainThread()
+
+    val waitForRetainedDurationMillis = measureDurationMillis {
+      val yesNo = detectLeaksInterceptor.waitUntilReadyForHeapAnalysis()
+      if (yesNo is NoHeapAnalysis) {
+        SharkLog.d { "Test can keep going: no heap dump performed (${yesNo.reason})" }
+        return
+      }
+    }
+
+    val heapDumpFile = InstrumentationHeapDumpFileProvider().newHeapDumpFile()
+
+    val config = LeakCanary.config
+
+    KeyedWeakReference.heapDumpUptimeMillis = SystemClock.uptimeMillis()
+    val heapDumpDurationMillis = measureDurationMillis {
+      config.heapDumper.dumpHeap(heapDumpFile)
+    }
+    val heapDumpUptimeMillis = KeyedWeakReference.heapDumpUptimeMillis
+    AppWatcher.objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
+
+    val heapAnalyzer = RetryingHeapAnalyzer(
+      InstrumentationHeapAnalyzer(
+        leakingObjectFinder = config.leakingObjectFinder,
+        referenceMatchers = config.referenceMatchers,
+        computeRetainedHeapSize = config.computeRetainedHeapSize,
+        metadataExtractor = config.metadataExtractor,
+        objectInspectors = config.objectInspectors,
+        proguardMapping = null
+      )
+    )
+    val analysisResult = heapAnalyzer.analyze(heapDumpFile)
+    val totalDurationMillis = SystemClock.uptimeMillis() - assertionStartUptimeMillis
+    val heapAnalysisWithExtraDetails = analysisResult.let {
+      when (it) {
+        is HeapAnalysisSuccess -> it.copy(
+          dumpDurationMillis = heapDumpDurationMillis,
+          metadata = it.metadata + mapOf(
+            ASSERTION_TAG to tag,
+            WAIT_FOR_RETAINED to waitForRetainedDurationMillis.toString(),
+            TOTAL_DURATION to totalDurationMillis.toString()
+          ),
+        )
+        is HeapAnalysisFailure -> it.copy(dumpDurationMillis = heapDumpDurationMillis)
+      }
+    }
+    heapAnalysisReporter.reportHeapAnalysis(heapAnalysisWithExtraDetails)
+  }
+
+  companion object {
+    private const val ASSERTION_TAG = "assertionTag"
+    private const val WAIT_FOR_RETAINED = "waitForRetainedDurationMillis"
+    private const val TOTAL_DURATION = "totalDurationMillis"
+    private var totalVmDurationMillis = 0L
+
+    val HeapAnalysisSuccess.assertionTag: String?
+      get() = metadata[ASSERTION_TAG]
+
+    val HeapAnalysisSuccess.waitForRetainedDurationMillis: Int?
+      get() = metadata[WAIT_FOR_RETAINED]?.toInt()
+
+    val HeapAnalysisSuccess.totalDurationMillis: Int?
+      get() = metadata[TOTAL_DURATION]?.toInt()
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/AndroidDetectLeaksInterceptor.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/AndroidDetectLeaksInterceptor.kt
new file mode 100644
index 00000000..34a91c04
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/AndroidDetectLeaksInterceptor.kt
@@ -0,0 +1,59 @@
+package leakcanary
+
+import android.app.Instrumentation
+import android.os.SystemClock
+import androidx.test.platform.app.InstrumentationRegistry
+import leakcanary.GcTrigger.Default
+import leakcanary.HeapAnalysisDecision.NoHeapAnalysis
+import leakcanary.HeapAnalysisDecision.AnalyzeHeap
+
+class AndroidDetectLeaksInterceptor(
+  private val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation(),
+  private val objectWatcher: ObjectWatcher = AppWatcher.objectWatcher,
+  private val retainedDelayMillis: Long = AppWatcher.retainedDelayMillis
+) : DetectLeaksInterceptor {
+
+  @Suppress("ReturnCount")
+  override fun waitUntilReadyForHeapAnalysis(): HeapAnalysisDecision {
+    val leakDetectionTime = SystemClock.uptimeMillis()
+
+    if (!objectWatcher.hasWatchedObjects) {
+      return NoHeapAnalysis("No watched objects.")
+    }
+
+    instrumentation.waitForIdleSync()
+    if (!objectWatcher.hasWatchedObjects) {
+      return NoHeapAnalysis("No watched objects after waiting for idle sync.")
+    }
+
+    Default.runGc()
+    if (!objectWatcher.hasWatchedObjects) {
+      return NoHeapAnalysis("No watched objects after triggering an explicit GC.")
+    }
+
+    // Waiting for any delayed UI post (e.g. scroll) to clear. This shouldn't be needed, but
+    // Android simply has way too many delayed posts that aren't canceled when views are detached.
+    SystemClock.sleep(2000)
+
+    if (!objectWatcher.hasWatchedObjects) {
+      return NoHeapAnalysis("No watched objects after delayed UI post is cleared.")
+    }
+
+    // Aaand we wait some more.
+    // 4 seconds (2+2) is greater than the 3 seconds delay for
+    // FINISH_TOKEN in android.widget.Filter
+    SystemClock.sleep(2000)
+
+    val endOfWatchDelay = retainedDelayMillis - (SystemClock.uptimeMillis() - leakDetectionTime)
+    if (endOfWatchDelay > 0) {
+      SystemClock.sleep(endOfWatchDelay)
+    }
+
+    Default.runGc()
+
+    if (!objectWatcher.hasRetainedObjects) {
+      return NoHeapAnalysis("No retained objects after waiting for retained delay.")
+    }
+    return AnalyzeHeap
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/DetectLeaksAfterTestSuccess.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/DetectLeaksAfterTestSuccess.kt
new file mode 100644
index 00000000..35bf8246
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/DetectLeaksAfterTestSuccess.kt
@@ -0,0 +1,62 @@
+package leakcanary
+
+import org.junit.rules.RuleChain
+import org.junit.rules.TestRule
+import org.junit.runner.Description
+import org.junit.runners.model.Statement
+
+/**
+ * [TestRule] that invokes [LeakAssertions.assertNoLeaks] after the test
+ * successfully evaluates. Pay attention to where you set up this rule in the
+ * rule chain as you might detect different leaks (e.g. around vs wrapped by the
+ * activity rule). It's also possible to use this rule several times in a rule
+ * chain.
+ *
+ * This rule automatically applies the [TestDescriptionHolder] rule.
+ */
+class DetectLeaksAfterTestSuccess(
+  private val tag: String = DetectLeaksAfterTestSuccess::class.java.simpleName
+) : TestRule {
+  override fun apply(base: Statement, description: Description): Statement {
+    return TestDescriptionHolder.wrap(object : Statement() {
+      override fun evaluate() {
+        try {
+          base.evaluate()
+          // If the test fails, evaluate() will throw and we won't run the analysis (which is good).
+          LeakAssertions.assertNoLeaks(tag)
+        } finally {
+          // Otherwise upstream test failures will be reported as leaks.
+          // https://github.com/square/leakcanary/issues/2297
+          AppWatcher.objectWatcher.clearWatchedObjects()
+        }
+      }
+    }, description)
+  }
+
+  companion object {
+    /**
+     * A helper function to trigger leak detection twice during test tear down, before and after
+     * the tear down of a set of wrapped rule chains. For example, this can be useful to detect
+     * leaks both right before and right after the activity under test is destroyed. Before means
+     * we can detect detached fragment leaks that go away when the activity is destroyed. After
+     * means we can detect activity leaks.
+     *
+     * ```kotlin
+     * RuleChain.outerRule(LoginRule())
+     *   .detectLeaksAfterTestSuccessWrapping("ActivitiesDestroyed") {
+     *     around(ActivityScenarioRule(MyActivity::class.java))
+     *   }
+     *   .around(LoadingScreenRule())
+     * ```
+     */
+    fun RuleChain.detectLeaksAfterTestSuccessWrapping(
+      tag: String,
+      wrapped: RuleChain.() -> RuleChain
+    ): RuleChain {
+      return around(DetectLeaksAfterTestSuccess("After$tag")).wrapped()
+        .around(DetectLeaksAfterTestSuccess("Before$tag"))
+    }
+  }
+}
+
+
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/DetectLeaksAssert.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/DetectLeaksAssert.kt
new file mode 100644
index 00000000..6873ef9f
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/DetectLeaksAssert.kt
@@ -0,0 +1,21 @@
+package leakcanary
+
+/**
+ * The interface for the implementation that [LeakAssertions.assertNoLeaks] delegates to.
+ * You can call [DetectLeaksAssert.update] to provide your own implementation.
+ *
+ * The default implementation is [AndroidDetectLeaksAssert].
+ */
+fun interface DetectLeaksAssert {
+
+  fun assertNoLeaks(tag: String)
+
+  companion object {
+    @Volatile
+    internal var delegate: DetectLeaksAssert = AndroidDetectLeaksAssert()
+
+    fun update(delegate: DetectLeaksAssert) {
+      DetectLeaksAssert.delegate = delegate
+    }
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/DetectLeaksInterceptor.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/DetectLeaksInterceptor.kt
new file mode 100644
index 00000000..f1e4418b
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/DetectLeaksInterceptor.kt
@@ -0,0 +1,10 @@
+package leakcanary
+
+/**
+ * Decides whether to dump & analyze the heap to look for leaks in instrumentation tests.
+ * The implementation might block for a while to allow temporary leaks to be flushed out, as those
+ * aren't that interesting to report and heap analysis increases test duration significantly.
+ */
+fun interface DetectLeaksInterceptor {
+  fun waitUntilReadyForHeapAnalysis(): HeapAnalysisDecision
+}
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/HeapAnalysisDecision.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/HeapAnalysisDecision.kt
new file mode 100644
index 00000000..44318203
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/HeapAnalysisDecision.kt
@@ -0,0 +1,6 @@
+package leakcanary
+
+sealed class HeapAnalysisDecision {
+  object AnalyzeHeap : HeapAnalysisDecision()
+  class NoHeapAnalysis(val reason: String) : HeapAnalysisDecision()
+}
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/HeapAnalysisReporter.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/HeapAnalysisReporter.kt
new file mode 100644
index 00000000..8ed90d4b
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/HeapAnalysisReporter.kt
@@ -0,0 +1,10 @@
+package leakcanary
+
+import shark.HeapAnalysis
+
+/**
+ * Reports the results of a heap analysis created by [AndroidDetectLeaksAssert].
+ */
+fun interface HeapAnalysisReporter {
+  fun reportHeapAnalysis(heapAnalysis: HeapAnalysis)
+}
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
new file mode 100644
index 00000000..76843ed6
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import android.os.SystemClock
+import leakcanary.InstrumentationLeakDetector.Result.AnalysisPerformed
+import leakcanary.InstrumentationLeakDetector.Result.NoAnalysis
+import leakcanary.HeapAnalysisDecision.NoHeapAnalysis
+import leakcanary.internal.InstrumentationHeapAnalyzer
+import leakcanary.internal.InstrumentationHeapDumpFileProvider
+import leakcanary.internal.RetryingHeapAnalyzer
+import leakcanary.internal.friendly.measureDurationMillis
+import org.junit.runner.notification.RunListener
+import shark.HeapAnalysis
+import shark.HeapAnalysisException
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.SharkLog
+
+/**
+ * Deprecated: Use LeakAssertions instead
+ *
+ * [InstrumentationLeakDetector] can be used to detect memory leaks in instrumentation tests.
+ *
+ * To use it, you need to add an instrumentation test listener (e.g. [FailTestOnLeakRunListener])
+ * that will invoke [detectLeaks].
+ *
+ * ### Add an instrumentation test listener
+ *
+ * LeakCanary provides [FailTestOnLeakRunListener], but you can also implement
+ * your own [RunListener] and call [detectLeaks] directly if you need a more custom
+ * behavior (for instance running it only once per test suite).
+ *
+ * All you need to do is add the following to the defaultConfig of your build.gradle:
+ *
+ * `testInstrumentationRunnerArgument "listener", "leakcanary.FailTestOnLeakRunListener"`
+ *
+ * Then you can run your instrumentation tests via Gradle as usually, and they will fail when
+ * a memory leak is detected:
+ *
+ * `./gradlew leakcanary-sample:connectedCheck`
+ *
+ * If instead you want to run UI tests via adb, add a *listener* execution argument to
+ * your command line for running the UI tests:
+ * `-e listener leakcanary.FailTestOnLeakRunListener`. The full command line
+ * should look something like this:
+ * ```shell
+ * adb shell am instrument \\
+ * -w com.android.foo/android.support.test.runner.AndroidJUnitRunner \\
+ * -e listener leakcanary.FailTestOnLeakRunListener
+ * ```
+ *
+ * ### Rationale
+ * Instead of using the [InstrumentationLeakDetector], one could simply enable LeakCanary in
+ * instrumentation tests.
+ *
+ * This approach would have two disadvantages:
+ *
+ *  - Heap dumps freeze the VM, and the leak analysis is IO and CPU heavy. This can slow down
+ * the test and introduce flakiness
+ *  - The leak analysis is asynchronous by default. This means the tests could finish and the
+ *  process dies before the analysis is finished.
+ *
+ * The approach taken here is to collect all objects to watch as you run the test, but not
+ * do any heap dump during the test. Then, at the end, if any of the watched objects is still in
+ * memory we dump the heap and perform a blocking analysis. There is only one heap dump performed,
+ * no matter the number of objects retained.
+ */
+@Deprecated("Use LeakAssertions instead")
+class InstrumentationLeakDetector {
+
+  /**
+   * The result of calling [detectLeaks], which is either [NoAnalysis] or [AnalysisPerformed].
+   */
+  sealed class Result {
+    class NoAnalysis(val reason: String) : Result()
+    class AnalysisPerformed(val heapAnalysis: HeapAnalysis) : Result()
+  }
+
+  /**
+   * Looks for retained objects, triggers a heap dump if needed and performs an analysis.
+   */
+  @Suppress("ReturnCount")
+  fun detectLeaks(): Result {
+    val retainedObjectsChecker = AndroidDetectLeaksInterceptor()
+    when(val yesNo = retainedObjectsChecker.waitUntilReadyForHeapAnalysis()) {
+      is NoHeapAnalysis -> {
+        return NoAnalysis(yesNo.reason)
+      }
+    }
+
+    val heapDumpFile = InstrumentationHeapDumpFileProvider().newHeapDumpFile()
+
+    val config = LeakCanary.config
+
+    KeyedWeakReference.heapDumpUptimeMillis = SystemClock.uptimeMillis()
+    val heapDumpDurationMillis = try {
+      measureDurationMillis {
+        config.heapDumper.dumpHeap(heapDumpFile)
+      }
+    } catch (exception: Exception) {
+      SharkLog.d(exception) { "Could not dump heap" }
+      return AnalysisPerformed(
+        HeapAnalysisFailure(
+          heapDumpFile = heapDumpFile,
+          createdAtTimeMillis = System.currentTimeMillis(),
+          dumpDurationMillis = 0,
+          analysisDurationMillis = 0,
+          exception = HeapAnalysisException(exception)
+        )
+      )
+    } finally {
+      val heapDumpUptimeMillis = KeyedWeakReference.heapDumpUptimeMillis
+      AppWatcher.objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
+    }
+
+    val heapAnalyzer = RetryingHeapAnalyzer(
+      InstrumentationHeapAnalyzer(
+        leakingObjectFinder = config.leakingObjectFinder,
+        referenceMatchers = config.referenceMatchers,
+        computeRetainedHeapSize = config.computeRetainedHeapSize,
+        metadataExtractor = config.metadataExtractor,
+        objectInspectors = config.objectInspectors,
+        proguardMapping = null
+      )
+    )
+
+    val heapAnalysis = heapAnalyzer.analyze(heapDumpFile).let {
+      when (it) {
+        is HeapAnalysisSuccess -> it.copy(dumpDurationMillis = heapDumpDurationMillis)
+        is HeapAnalysisFailure -> it.copy(dumpDurationMillis = heapDumpDurationMillis)
+      }
+    }
+
+    return AnalysisPerformed(heapAnalysis)
+  }
+
+  companion object {
+
+    @Deprecated(
+      "This is a no-op as LeakCanary automatically detects tests",
+      replaceWith = ReplaceWith("")
+    )
+    fun updateConfig() = Unit
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/LeakAssertions.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/LeakAssertions.kt
new file mode 100644
index 00000000..e48b4aed
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/LeakAssertions.kt
@@ -0,0 +1,30 @@
+package leakcanary
+
+object LeakAssertions {
+
+  /**
+   * Asserts that there are no leak in the heap at this point in time.
+   *
+   * This method should be called on the instrumentation thread.
+   *
+   * This method is may block the current thread for a significant amount of time,
+   * as it might need to dump the heap and analyze it.
+   *
+   * If leaks are found, this method is expected to throw an exception, which will fail the test.
+   *
+   * The specific details depend on what you configured in [DetectLeaksAssert.update].
+   *
+   * [tag] identifies the calling code, which can then be used for reporting purposes or to skip
+   * leak detection for specific tags in a subset of tests (see [SkipLeakDetection]).
+   */
+  fun assertNoLeaks(tag: String = NO_TAG) {
+    DetectLeaksAssert.delegate.assertNoLeaks(tag)
+  }
+
+  const val NO_TAG = ""
+}
+
+
+
+
+
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/NoLeakAssertionFailedError.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/NoLeakAssertionFailedError.kt
new file mode 100644
index 00000000..ba346bcd
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/NoLeakAssertionFailedError.kt
@@ -0,0 +1,49 @@
+package leakcanary
+
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.SharkLog
+
+/**
+ * Thrown when using the [NoLeakAssertionFailedError.throwOnApplicationLeaks] HeapAnalysisReporter
+ */
+class NoLeakAssertionFailedError(
+  val heapAnalysis: HeapAnalysisSuccess
+) : AssertionError(
+  "Application memory leaks were detected:\n$heapAnalysis"
+) {
+  companion object {
+    /**
+     * A [HeapAnalysisReporter] that throws a [NoLeakAssertionFailedError] when the heap analysis
+     * has application leaks.
+     */
+    fun throwOnApplicationLeaks(): HeapAnalysisReporter = HeapAnalysisReporter { heapAnalysis ->
+      when (heapAnalysis) {
+        is HeapAnalysisSuccess -> {
+          when {
+            heapAnalysis.applicationLeaks.isNotEmpty() -> {
+              throw NoLeakAssertionFailedError(heapAnalysis)
+            }
+            heapAnalysis.libraryLeaks.isNotEmpty() -> {
+              SharkLog.d {
+                "Test can keep going: heap analysis found 0 application leaks and ${heapAnalysis.libraryLeaks.size} library leaks:\n$heapAnalysis"
+              }
+            }
+            heapAnalysis.unreachableObjects.isNotEmpty() -> {
+              SharkLog.d {
+                "Test can keep going: heap analysis found 0 leaks and ${heapAnalysis.unreachableObjects.size} watched weakly reachable objects:\n" +
+                  heapAnalysis
+              }
+            }
+            else -> {
+              SharkLog.d { "Test can keep going: heap analysis found 0 leaks." }
+            }
+          }
+        }
+        is HeapAnalysisFailure -> {
+          throw heapAnalysis.exception
+        }
+      }
+    }
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/SkipLeakDetection.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/SkipLeakDetection.kt
new file mode 100644
index 00000000..321a75eb
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/SkipLeakDetection.kt
@@ -0,0 +1,60 @@
+package leakcanary
+
+import kotlin.annotation.AnnotationRetention.RUNTIME
+import kotlin.annotation.AnnotationTarget.CLASS
+import kotlin.annotation.AnnotationTarget.FUNCTION
+import leakcanary.SkipLeakDetection.Companion.shouldSkipTest
+import org.junit.runner.Description
+import shark.SharkLog
+
+/**
+ * Annotation for skipping leak detection in a UI test that calls
+ * [LeakAssertions.assertNoLeaks]. This annotation is useful to skip a leak detection in
+ * a test until the leaks are fixed.
+ *
+ * The check is performed by [shouldSkipTest] which is called by [AndroidDetectLeaksAssert],
+ * which requires that the [TestDescriptionHolder] rule be applied and
+ * evaluating when [LeakAssertions.assertNoLeaks] is called.
+ *
+ * [message] should contain an explanation of why leak detection is skipped, e.g. a reference to a
+ * filed issue.
+ *
+ * The optional [assertionTags] allows finer grained filtering based on the tag value passed to
+ * [LeakAssertions.assertNoLeaks]. If [assertionTags] is empty, then the test will
+ * skip leak detection entirely. If [assertionTags] is not empty, then the test will skip leak
+ * detection for any call to [LeakAssertions.assertNoLeaks] with a tag value contained in
+ * [assertionTags].
+ */
+@Retention(RUNTIME)
+@Target(CLASS, FUNCTION)
+annotation class SkipLeakDetection(val message: String, vararg val assertionTags: String) {
+  companion object {
+    fun shouldSkipTest(testDescription: Description, assertionTag: String): Boolean {
+      val skipAnnotation =
+        testDescription.getAnnotation(SkipLeakDetection::class.java)
+      return shouldSkipTest(testDescription.displayName, skipAnnotation, assertionTag)
+    }
+
+    fun shouldSkipTest(
+      testName: String,
+      skipAnnotation: SkipLeakDetection?,
+      assertionTag: String
+    ): Boolean {
+      if (skipAnnotation != null) {
+        val assertionTags = skipAnnotation.assertionTags
+        if (assertionTags.isEmpty()) {
+          SharkLog.d { "Skipping leak detection for $testName, message: ${skipAnnotation.message}" }
+          return true
+        } else if (assertionTag in assertionTags) {
+          SharkLog.d {
+            "Skipping [$assertionTag] leak detection for $testName, " +
+              "message: ${skipAnnotation.message}"
+          }
+          return true
+        }
+      }
+      return false
+    }
+  }
+}
+
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/TestDescriptionHolder.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/TestDescriptionHolder.kt
new file mode 100644
index 00000000..5c284e63
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/TestDescriptionHolder.kt
@@ -0,0 +1,55 @@
+package leakcanary
+
+import leakcanary.TestDescriptionHolder.testDescription
+import org.junit.rules.TestRule
+import org.junit.runner.Description
+import org.junit.runners.model.Statement
+import shark.SharkLog
+
+/**
+ * A [TestRule] that holds onto the test [Description] in a thread local while evaluating, making
+ * it possible to retrieve that test [Description] from the test thread via [testDescription].
+ *
+ * This rule is automatically applied by [DetectLeaksAfterTestSuccess].
+ */
+object TestDescriptionHolder : TestRule {
+
+  private val descriptionThreadLocal = ThreadLocal<Description>()
+
+  fun isEvaluating() = descriptionThreadLocal.get() != null
+
+  val testDescription: Description
+    get() {
+      return descriptionThreadLocal.get() ?: error(
+        "Test description is null, either you forgot to add the TestDescriptionHolder rule around" +
+          "the current code or you did not call testDescription from the test thread."
+      )
+    }
+
+  override fun apply(base: Statement, description: Description): Statement {
+    return wrap(base, description)
+  }
+
+  fun wrap(base: Statement, description: Description) = object : Statement() {
+    override fun evaluate() {
+      val previousDescription = descriptionThreadLocal.get()
+      val descriptionNotAlreadySet = previousDescription == null
+      if (descriptionNotAlreadySet) {
+        descriptionThreadLocal.set(description)
+      } else {
+        SharkLog.d { "Test description already set, you should remove the TestDescriptionHolder rule." }
+      }
+      try {
+        base.evaluate()
+      } finally {
+        if (descriptionNotAlreadySet) {
+          val currentDescription = descriptionThreadLocal.get()
+          check(currentDescription != null) {
+            "Test description should not be null after the rule evaluates."
+          }
+          descriptionThreadLocal.remove()
+        }
+      }
+    }
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/internal/InstrumentationHeapAnalyzer.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/internal/InstrumentationHeapAnalyzer.kt
new file mode 100644
index 00000000..bd26a27c
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/internal/InstrumentationHeapAnalyzer.kt
@@ -0,0 +1,87 @@
+package leakcanary.internal
+
+import android.os.SystemClock
+import java.io.File
+import shark.ConstantMemoryMetricsDualSourceProvider
+import shark.FileSourceProvider
+import shark.HeapAnalysis
+import shark.HeapAnalysisException
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.HeapAnalyzer
+import shark.HprofHeapGraph
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.LeakingObjectFinder
+import shark.MetadataExtractor
+import shark.ObjectInspector
+import shark.OnAnalysisProgressListener
+import shark.ProguardMapping
+import shark.ReferenceMatcher
+import shark.SharkLog
+
+/**
+ * Sets up [HeapAnalyzer] for instrumentation tests and delegates heap analysis.
+ */
+internal class InstrumentationHeapAnalyzer(
+  val leakingObjectFinder: LeakingObjectFinder,
+  val referenceMatchers: List<ReferenceMatcher>,
+  val computeRetainedHeapSize: Boolean,
+  val metadataExtractor: MetadataExtractor,
+  val objectInspectors: List<ObjectInspector>,
+  val proguardMapping: ProguardMapping?
+) {
+
+  fun analyze(heapDumpFile: File): HeapAnalysis {
+    var lastStepUptimeMs = -1L
+    val heapAnalyzer = HeapAnalyzer { newStep ->
+      val now = SystemClock.uptimeMillis()
+      val lastStepString = if (lastStepUptimeMs != -1L) {
+        val lastStepDurationMs = now - lastStepUptimeMs
+        val lastStep = OnAnalysisProgressListener.Step.values()[newStep.ordinal - 1]
+        "${lastStep.humanReadableName} took $lastStepDurationMs ms, now "
+      } else {
+        ""
+      }
+      SharkLog.d { "${lastStepString}working on ${newStep.humanReadableName}" }
+      lastStepUptimeMs = now
+    }
+
+    val sourceProvider = ConstantMemoryMetricsDualSourceProvider(FileSourceProvider(heapDumpFile))
+
+    val closeableGraph = try {
+      sourceProvider.openHeapGraph(proguardMapping)
+    } catch (throwable: Throwable) {
+      return HeapAnalysisFailure(
+        heapDumpFile = heapDumpFile,
+        createdAtTimeMillis = System.currentTimeMillis(),
+        analysisDurationMillis = 0,
+        exception = HeapAnalysisException(throwable)
+      )
+    }
+    return closeableGraph
+      .use { graph ->
+        val result = heapAnalyzer.analyze(
+          heapDumpFile = heapDumpFile,
+          graph = graph,
+          leakingObjectFinder = leakingObjectFinder,
+          referenceMatchers = referenceMatchers,
+          computeRetainedHeapSize = computeRetainedHeapSize,
+          objectInspectors = objectInspectors,
+          metadataExtractor = metadataExtractor
+        )
+        if (result is HeapAnalysisSuccess) {
+          val lruCacheStats = (graph as HprofHeapGraph).lruCacheStats()
+          val randomAccessStats =
+            "RandomAccess[" +
+              "bytes=${sourceProvider.randomAccessByteReads}," +
+              "reads=${sourceProvider.randomAccessReadCount}," +
+              "travel=${sourceProvider.randomAccessByteTravel}," +
+              "range=${sourceProvider.byteTravelRange}," +
+              "size=${heapDumpFile.length()}" +
+              "]"
+          val stats = "$lruCacheStats $randomAccessStats"
+          result.copy(metadata = result.metadata + ("Stats" to stats))
+        } else result
+      }
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/internal/InstrumentationHeapDumpFileProvider.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/internal/InstrumentationHeapDumpFileProvider.kt
new file mode 100644
index 00000000..b1a1f052
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/internal/InstrumentationHeapDumpFileProvider.kt
@@ -0,0 +1,26 @@
+package leakcanary.internal
+
+import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
+import java.io.File
+import java.text.SimpleDateFormat
+import java.util.Date
+import java.util.Locale
+
+/**
+ * Provides unique file names for each heap dump in instrumentation tests.
+ */
+internal class InstrumentationHeapDumpFileProvider(
+  private val heapDumpDirectory: File = getInstrumentation().targetContext.filesDir
+) {
+
+  /**
+   * Returns a file for where the heap should be dumped.
+   */
+  fun newHeapDumpFile(): File {
+    // File name is unique as analysis may run several times per test
+    val fileName =
+      SimpleDateFormat("'instrumentation_tests_'yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US)
+        .format(Date())
+    return File(heapDumpDirectory, fileName)
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/internal/RetryingHeapAnalyzer.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/internal/RetryingHeapAnalyzer.kt
new file mode 100644
index 00000000..807677ae
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/internal/RetryingHeapAnalyzer.kt
@@ -0,0 +1,52 @@
+package leakcanary.internal
+
+import android.os.SystemClock
+import android.util.Log
+import java.io.File
+import shark.HeapAnalysis
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.SharkLog
+
+/**
+ * Wraps [InstrumentationHeapAnalyzer] and retries the analysis once if it fails.
+ */
+internal class RetryingHeapAnalyzer(
+  private val heapAnalyzer: InstrumentationHeapAnalyzer
+) {
+
+  fun analyze(heapDumpFile: File): HeapAnalysis {
+    // A copy that will be used in case of failure followed by success, to see if the file has changed.
+    val heapDumpCopyFile = File(heapDumpFile.parent, "copy-${heapDumpFile.name}")
+    heapDumpFile.copyTo(heapDumpCopyFile)
+    // Giving an extra 2 seconds to flush the hprof to the file system. We've seen several cases
+    // of corrupted hprof files and assume this could be a timing issue.
+    SystemClock.sleep(2000)
+
+    val heapAnalysis = heapAnalyzer.analyze(heapDumpFile)
+
+    return if (heapAnalysis is HeapAnalysisFailure) {
+      // Experience has shown that trying again often just works. Not sure why.
+      SharkLog.d(heapAnalysis.exception) {
+        "Heap Analysis failed, retrying in 10s in case the heap dump was not fully baked yet. " +
+          "Copy of original heap dump available at ${heapDumpCopyFile.absolutePath}"
+      }
+      SystemClock.sleep(10000)
+      heapAnalyzer.analyze(heapDumpFile).let {
+        when (it) {
+          is HeapAnalysisSuccess -> it.copy(
+            metadata = it.metadata + mapOf(
+              "previousFailureHeapDumpCopy" to heapDumpCopyFile.absolutePath,
+              "previousFailureStacktrace" to Log.getStackTraceString(heapAnalysis.exception)
+            )
+          )
+          is HeapAnalysisFailure -> it
+        }
+      }
+    } else {
+      // We don't need the copy after all.
+      heapDumpCopyFile.delete()
+      heapAnalysis
+    }
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/internal/friendly/Friendly.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/internal/friendly/Friendly.kt
new file mode 100644
index 00000000..bc31b029
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/internal/friendly/Friendly.kt
@@ -0,0 +1,10 @@
+@file:Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER")
+@file:JvmName("leakcanary-android-instrumentation_Friendly")
+package leakcanary.internal.friendly
+
+internal inline fun <reified T : Any> noOpDelegate(): T = leakcanary.internal.noOpDelegate()
+
+internal inline fun checkNotMainThread() = leakcanary.internal.checkNotMainThread()
+
+internal inline fun measureDurationMillis(block: () -> Unit) =
+  leakcanary.internal.measureDurationMillis(block)
diff --git a/leakcanary-android-process/api/leakcanary-android-process.api b/leakcanary-android-process/api/leakcanary-android-process.api
new file mode 100644
index 00000000..2f1c292c
--- /dev/null
+++ b/leakcanary-android-process/api/leakcanary-android-process.api
@@ -0,0 +1,18 @@
+public final class leakcanary/LeakCanaryProcess {
+	public static final field INSTANCE Lleakcanary/LeakCanaryProcess;
+	public final fun isInAnalyzerProcess (Landroid/content/Context;)Z
+}
+
+public final class leakcanary/internal/RemoteLeakCanaryWorkerService : androidx/work/multiprocess/RemoteWorkerService {
+	public fun <init> ()V
+	public fun getApplicationContext ()Landroid/content/Context;
+	public fun onCreate ()V
+}
+
+public final class leakcanary/internal/RemoteLeakCanaryWorkerService$FakeAppContextConfigurationProvider : android/content/ContextWrapper, androidx/work/Configuration$Provider {
+	public fun <init> (Landroid/content/Context;)V
+	public synthetic fun getApplicationContext ()Landroid/content/Context;
+	public fun getApplicationContext ()Lleakcanary/internal/RemoteLeakCanaryWorkerService$FakeAppContextConfigurationProvider;
+	public fun getWorkManagerConfiguration ()Landroidx/work/Configuration;
+}
+
diff --git a/leakcanary-android-process/build.gradle b/leakcanary-android-process/build.gradle
new file mode 100644
index 00000000..c446c3d4
--- /dev/null
+++ b/leakcanary-android-process/build.gradle
@@ -0,0 +1,27 @@
+plugins {
+  id("com.android.library")
+  id("org.jetbrains.kotlin.android")
+  id("com.vanniktech.maven.publish")
+}
+
+dependencies {
+  api projects.sharkLog
+  api projects.leakcanaryObjectWatcherAndroidCore
+
+  implementation libs.kotlin.stdlib
+  implementation libs.androidX.work.multiprocess
+}
+
+android {
+  compileSdk versions.compileSdk
+  defaultConfig {
+    minSdk versions.minSdk
+  }
+  buildFeatures.buildConfig = false
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    // junit references java.lang.management
+    ignore 'InvalidPackage'
+    checkOnly 'Interoperability'
+  }
+}
diff --git a/leakcanary-android-process/consumer-proguard-rules.pro b/leakcanary-android-process/consumer-proguard-rules.pro
new file mode 100644
index 00000000..b9c89ddd
--- /dev/null
+++ b/leakcanary-android-process/consumer-proguard-rules.pro
@@ -0,0 +1,2 @@
+# A ContentProvider that gets created by Android on :leakcanary process startup
+-keep class leakcanary.internal.LeakCanaryProcessAppWatcherInstaller { <init>(); }
diff --git a/leakcanary-android-process/gradle.properties b/leakcanary-android-process/gradle.properties
new file mode 100644
index 00000000..6227cda1
--- /dev/null
+++ b/leakcanary-android-process/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-android-process
+POM_NAME=LeakCanary Android running in a separate process
+POM_PACKAGING=aar
diff --git a/leakcanary-android-process/src/main/AndroidManifest.xml b/leakcanary-android-process/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..92457763
--- /dev/null
+++ b/leakcanary-android-process/src/main/AndroidManifest.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary">
+
+  <application>
+    <service
+      android:name="leakcanary.internal.RemoteLeakCanaryWorkerService"
+      android:exported="false"
+      android:process=":leakcanary" />
+  </application>
+
+</manifest>
diff --git a/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt b/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
new file mode 100644
index 00000000..45a23c22
--- /dev/null
+++ b/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
@@ -0,0 +1,101 @@
+package leakcanary
+
+import android.app.ActivityManager
+import android.app.Service
+import android.content.ComponentName
+import android.content.Context
+import android.content.pm.PackageInfo
+import android.content.pm.PackageManager
+import android.content.pm.ServiceInfo
+import leakcanary.internal.RemoteLeakCanaryWorkerService
+import shark.SharkLog
+
+/**
+ * Used to determine whether the current process is the LeakCanary analyzer process. By depending
+ * on the `leakcanary-android-process` artifact instead of the `leakcanary-android`, LeakCanary
+ * will automatically run its analysis in a separate process.
+ *
+ * As such, you'll need to be careful to do any custom configuration of LeakCanary in both the main
+ * process and the analyzer process.
+ */
+object LeakCanaryProcess {
+
+  @Volatile private var isInAnalyzerProcess: Boolean? = null
+
+  /**
+   * Whether the current process is the process running the heap analyzer, which is
+   * a different process than the normal app process.
+   */
+  fun isInAnalyzerProcess(context: Context): Boolean {
+    var isInAnalyzerProcess: Boolean? = isInAnalyzerProcess
+    // This only needs to be computed once per process.
+    if (isInAnalyzerProcess == null) {
+      isInAnalyzerProcess = isInServiceProcess(context, RemoteLeakCanaryWorkerService::class.java)
+      this.isInAnalyzerProcess = isInAnalyzerProcess
+    }
+    return isInAnalyzerProcess
+  }
+
+  @Suppress("ReturnCount")
+  private fun isInServiceProcess(
+    context: Context,
+    serviceClass: Class<out Service>
+  ): Boolean {
+    val packageManager = context.packageManager
+    val packageInfo: PackageInfo
+    try {
+      packageInfo = packageManager.getPackageInfo(context.packageName, PackageManager.GET_SERVICES)
+    } catch (e: Exception) {
+      SharkLog.d(e) { "Could not get package info for ${context.packageName}" }
+      return false
+    }
+
+    val mainProcess = packageInfo.applicationInfo.processName
+
+    val component = ComponentName(context, serviceClass)
+    val serviceInfo: ServiceInfo
+    try {
+      serviceInfo =
+        packageManager.getServiceInfo(component, PackageManager.GET_DISABLED_COMPONENTS)
+    } catch (ignored: PackageManager.NameNotFoundException) {
+      // Service is disabled.
+      return false
+    }
+
+    if (serviceInfo.processName == null) {
+      SharkLog.d { "Did not expect service $serviceClass to have a null process name" }
+      return false
+    } else if (serviceInfo.processName == mainProcess) {
+      SharkLog.d { "Did not expect service $serviceClass to run in main process $mainProcess" }
+      // Technically we are in the service process, but we're not in the service dedicated process.
+      return false
+    }
+
+    val myPid = android.os.Process.myPid()
+    val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
+    var myProcess: ActivityManager.RunningAppProcessInfo? = null
+    val runningProcesses: List<ActivityManager.RunningAppProcessInfo>?
+    try {
+      runningProcesses = activityManager.runningAppProcesses
+    } catch (exception: SecurityException) {
+      // https://github.com/square/leakcanary/issues/948
+      SharkLog.d { "Could not get running app processes $exception" }
+      return false
+    }
+
+    if (runningProcesses != null) {
+      for (process in runningProcesses) {
+        if (process.pid == myPid) {
+          myProcess = process
+          break
+        }
+      }
+    }
+    if (myProcess == null) {
+      SharkLog.d { "Could not find running process for $myPid" }
+      return false
+    }
+
+    return myProcess.processName == serviceInfo.processName
+  }
+}
diff --git a/leakcanary-android-process/src/main/java/leakcanary/internal/RemoteLeakCanaryWorkerService.kt b/leakcanary-android-process/src/main/java/leakcanary/internal/RemoteLeakCanaryWorkerService.kt
new file mode 100644
index 00000000..2fb640e8
--- /dev/null
+++ b/leakcanary-android-process/src/main/java/leakcanary/internal/RemoteLeakCanaryWorkerService.kt
@@ -0,0 +1,65 @@
+package leakcanary.internal
+
+import android.app.Application
+import android.content.Context
+import android.content.ContextWrapper
+import androidx.work.Configuration
+import androidx.work.multiprocess.RemoteWorkerService
+import leakcanary.AppWatcher
+
+/**
+ * Using a custom class name instead of RemoteWorkerService so that
+ * hosting apps can use RemoteWorkerService without a naming conflict.
+ */
+class RemoteLeakCanaryWorkerService : RemoteWorkerService() {
+
+  /**
+   * RemoteLeakCanaryWorkerService is running in the :leakcanary process, and androidx startup only
+   * initializes WorkManager in the main process. In RemoteWorkerService.onCreate(),
+   * WorkManager has not been init, so it would crash. We can't blindly call init() as developers
+   * might be calling WorkManager.initialize() from Application.onCreate() for all processes, in
+   * which case a 2nd init would fail. So we want to init if nothing has init WorkManager before.
+   * But there's no isInit() API. However, WorkManager will automatically pull in the application
+   * context and if that context implements Configuration.Provider then it'll pull the
+   * configuration from it. So we cheat WorkManager by returning a fake app context that provides
+   * our own custom configuration.
+   */
+  class FakeAppContextConfigurationProvider(base: Context) : ContextWrapper(base),
+    Configuration.Provider {
+
+    // No real app context for you, sorry!
+    override fun getApplicationContext() = this
+
+    override fun getWorkManagerConfiguration() = Configuration.Builder()
+      // If the default package name is not set, WorkManager will cancel all runnables
+      // when initialized as it can't tell that it's not running in the main process.
+      // This would lead to an extra round trip where the canceling reaches the main process
+      // which then cancels the remote job and reschedules it and then only the work gets done.
+      .setDefaultProcessName(packageName)
+      .build()
+  }
+
+  private val fakeAppContext by lazy {
+    // We set the base context to the real app context so that getting resources etc still works.
+    FakeAppContextConfigurationProvider(super.getApplicationContext())
+  }
+
+  override fun getApplicationContext(): Context {
+    return fakeAppContext
+  }
+
+  override fun onCreate() {
+    // Ideally we wouldn't need to install AppWatcher at all here, however
+    // the installation triggers InternalsLeakCanary to store the application instance
+    // which is then used by the event listeners that respond to analysis progress.
+    if (!AppWatcher.isInstalled) {
+      val application = super.getApplicationContext() as Application
+      AppWatcher.manualInstall(
+        application,
+        // Nothing to watch in the :leakcanary process.
+        watchersToInstall = emptyList()
+      )
+    }
+    super.onCreate()
+  }
+}
diff --git a/leakcanary-android-release/api/leakcanary-android-release.api b/leakcanary-android-release/api/leakcanary-android-release.api
new file mode 100644
index 00000000..61db3202
--- /dev/null
+++ b/leakcanary-android-release/api/leakcanary-android-release.api
@@ -0,0 +1,192 @@
+public final class com/squareup/leakcanary/release/BuildConfig {
+	public static final field BUILD_TYPE Ljava/lang/String;
+	public static final field DEBUG Z
+	public static final field GIT_SHA Ljava/lang/String;
+	public static final field LIBRARY_PACKAGE_NAME Ljava/lang/String;
+	public static final field LIBRARY_VERSION Ljava/lang/String;
+	public fun <init> ()V
+}
+
+public final class leakcanary/BackgroundTrigger {
+	public fun <init> (Landroid/app/Application;Lleakcanary/HeapAnalysisClient;Ljava/util/concurrent/Executor;Lleakcanary/ProcessInfo;Lkotlin/jvm/functions/Function1;)V
+	public synthetic fun <init> (Landroid/app/Application;Lleakcanary/HeapAnalysisClient;Ljava/util/concurrent/Executor;Lleakcanary/ProcessInfo;Lkotlin/jvm/functions/Function1;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun start ()V
+	public final fun stop ()V
+}
+
+public final class leakcanary/ConditionalInterceptor : leakcanary/HeapAnalysisInterceptor {
+	public fun <init> (Lleakcanary/HeapAnalysisInterceptor;Lkotlin/jvm/functions/Function1;)V
+	public fun intercept (Lleakcanary/HeapAnalysisInterceptor$Chain;)Lleakcanary/HeapAnalysisJob$Result;
+}
+
+public final class leakcanary/GoodAndroidVersionInterceptor : leakcanary/HeapAnalysisInterceptor {
+	public fun <init> ()V
+	public fun intercept (Lleakcanary/HeapAnalysisInterceptor$Chain;)Lleakcanary/HeapAnalysisJob$Result;
+}
+
+public final class leakcanary/HeapAnalysisClient {
+	public static final field Companion Lleakcanary/HeapAnalysisClient$Companion;
+	public fun <init> (Lkotlin/jvm/functions/Function0;Lleakcanary/HeapAnalysisConfig;Ljava/util/List;)V
+	public final fun deleteHeapDumpFiles ()V
+	public final fun newJob (Lleakcanary/JobContext;)Lleakcanary/HeapAnalysisJob;
+	public static synthetic fun newJob$default (Lleakcanary/HeapAnalysisClient;Lleakcanary/JobContext;ILjava/lang/Object;)Lleakcanary/HeapAnalysisJob;
+}
+
+public final class leakcanary/HeapAnalysisClient$Companion {
+	public final fun defaultInterceptors (Landroid/app/Application;)Ljava/util/List;
+}
+
+public final class leakcanary/HeapAnalysisConfig {
+	public fun <init> ()V
+	public fun <init> (Ljava/util/List;Ljava/util/List;Lshark/MetadataExtractor;ZLshark/LeakingObjectFinder;Z)V
+	public synthetic fun <init> (Ljava/util/List;Ljava/util/List;Lshark/MetadataExtractor;ZLshark/LeakingObjectFinder;ZILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun component1 ()Ljava/util/List;
+	public final fun component2 ()Ljava/util/List;
+	public final fun component3 ()Lshark/MetadataExtractor;
+	public final fun component4 ()Z
+	public final fun component5 ()Lshark/LeakingObjectFinder;
+	public final fun component6 ()Z
+	public final fun copy (Ljava/util/List;Ljava/util/List;Lshark/MetadataExtractor;ZLshark/LeakingObjectFinder;Z)Lleakcanary/HeapAnalysisConfig;
+	public static synthetic fun copy$default (Lleakcanary/HeapAnalysisConfig;Ljava/util/List;Ljava/util/List;Lshark/MetadataExtractor;ZLshark/LeakingObjectFinder;ZILjava/lang/Object;)Lleakcanary/HeapAnalysisConfig;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getComputeRetainedHeapSize ()Z
+	public final fun getLeakingObjectFinder ()Lshark/LeakingObjectFinder;
+	public final fun getMetadataExtractor ()Lshark/MetadataExtractor;
+	public final fun getObjectInspectors ()Ljava/util/List;
+	public final fun getReferenceMatchers ()Ljava/util/List;
+	public final fun getStripHeapDump ()Z
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public abstract interface class leakcanary/HeapAnalysisInterceptor {
+	public abstract fun intercept (Lleakcanary/HeapAnalysisInterceptor$Chain;)Lleakcanary/HeapAnalysisJob$Result;
+}
+
+public abstract interface class leakcanary/HeapAnalysisInterceptor$Chain {
+	public abstract fun getJob ()Lleakcanary/HeapAnalysisJob;
+	public abstract fun proceed ()Lleakcanary/HeapAnalysisJob$Result;
+}
+
+public abstract interface class leakcanary/HeapAnalysisJob {
+	public abstract fun cancel (Ljava/lang/String;)V
+	public abstract fun execute ()Lleakcanary/HeapAnalysisJob$Result;
+	public abstract fun getCanceled ()Z
+	public abstract fun getContext ()Lleakcanary/JobContext;
+	public abstract fun getExecuted ()Z
+}
+
+public abstract class leakcanary/HeapAnalysisJob$Result {
+}
+
+public final class leakcanary/HeapAnalysisJob$Result$Canceled : leakcanary/HeapAnalysisJob$Result {
+	public fun <init> (Ljava/lang/String;)V
+	public final fun component1 ()Ljava/lang/String;
+	public final fun copy (Ljava/lang/String;)Lleakcanary/HeapAnalysisJob$Result$Canceled;
+	public static synthetic fun copy$default (Lleakcanary/HeapAnalysisJob$Result$Canceled;Ljava/lang/String;ILjava/lang/Object;)Lleakcanary/HeapAnalysisJob$Result$Canceled;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getCancelReason ()Ljava/lang/String;
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class leakcanary/HeapAnalysisJob$Result$Done : leakcanary/HeapAnalysisJob$Result {
+	public fun <init> (Lshark/HeapAnalysis;Ljava/lang/Long;)V
+	public synthetic fun <init> (Lshark/HeapAnalysis;Ljava/lang/Long;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun component1 ()Lshark/HeapAnalysis;
+	public final fun component2 ()Ljava/lang/Long;
+	public final fun copy (Lshark/HeapAnalysis;Ljava/lang/Long;)Lleakcanary/HeapAnalysisJob$Result$Done;
+	public static synthetic fun copy$default (Lleakcanary/HeapAnalysisJob$Result$Done;Lshark/HeapAnalysis;Ljava/lang/Long;ILjava/lang/Object;)Lleakcanary/HeapAnalysisJob$Result$Done;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getAnalysis ()Lshark/HeapAnalysis;
+	public final fun getStripHeapDumpDurationMillis ()Ljava/lang/Long;
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class leakcanary/JobContext {
+	public fun <init> ()V
+	public fun <init> (Ljava/lang/Class;)V
+	public synthetic fun <init> (Ljava/lang/Class;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public fun <init> (Lkotlin/reflect/KClass;)V
+	public final fun contains (Ljava/lang/String;)Z
+	public final fun get (Ljava/lang/String;)Ljava/lang/Object;
+	public final fun getOrPut (Ljava/lang/String;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
+	public final fun getStarter ()Ljava/lang/Class;
+	public final fun minusAssign (Ljava/lang/String;)V
+	public final fun set (Ljava/lang/String;Ljava/lang/Object;)V
+}
+
+public final class leakcanary/MinimumDiskSpaceInterceptor : leakcanary/HeapAnalysisInterceptor {
+	public fun <init> (Landroid/app/Application;JLleakcanary/ProcessInfo;)V
+	public synthetic fun <init> (Landroid/app/Application;JLleakcanary/ProcessInfo;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public fun intercept (Lleakcanary/HeapAnalysisInterceptor$Chain;)Lleakcanary/HeapAnalysisJob$Result;
+}
+
+public final class leakcanary/MinimumElapsedSinceStartInterceptor : leakcanary/HeapAnalysisInterceptor {
+	public fun <init> ()V
+	public fun <init> (JLleakcanary/ProcessInfo;)V
+	public synthetic fun <init> (JLleakcanary/ProcessInfo;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public fun intercept (Lleakcanary/HeapAnalysisInterceptor$Chain;)Lleakcanary/HeapAnalysisJob$Result;
+}
+
+public final class leakcanary/MinimumMemoryInterceptor : leakcanary/HeapAnalysisInterceptor {
+	public fun <init> (Landroid/app/Application;JLleakcanary/ProcessInfo;)V
+	public synthetic fun <init> (Landroid/app/Application;JLleakcanary/ProcessInfo;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public fun intercept (Lleakcanary/HeapAnalysisInterceptor$Chain;)Lleakcanary/HeapAnalysisJob$Result;
+}
+
+public final class leakcanary/OncePerPeriodInterceptor : leakcanary/HeapAnalysisInterceptor {
+	public static final field Companion Lleakcanary/OncePerPeriodInterceptor$Companion;
+	public fun <init> (Landroid/app/Application;J)V
+	public synthetic fun <init> (Landroid/app/Application;JILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun forget ()V
+	public fun intercept (Lleakcanary/HeapAnalysisInterceptor$Chain;)Lleakcanary/HeapAnalysisJob$Result;
+}
+
+public final class leakcanary/OncePerPeriodInterceptor$Companion {
+}
+
+public abstract interface class leakcanary/ProcessInfo {
+	public abstract fun availableDiskSpaceBytes (Ljava/io/File;)J
+	public abstract fun availableRam (Landroid/content/Context;)Lleakcanary/ProcessInfo$AvailableRam;
+	public abstract fun getElapsedMillisSinceStart ()J
+	public abstract fun isImportanceBackground ()Z
+}
+
+public abstract class leakcanary/ProcessInfo$AvailableRam {
+}
+
+public final class leakcanary/ProcessInfo$AvailableRam$BelowThreshold : leakcanary/ProcessInfo$AvailableRam {
+	public static final field INSTANCE Lleakcanary/ProcessInfo$AvailableRam$BelowThreshold;
+}
+
+public final class leakcanary/ProcessInfo$AvailableRam$LowRamDevice : leakcanary/ProcessInfo$AvailableRam {
+	public static final field INSTANCE Lleakcanary/ProcessInfo$AvailableRam$LowRamDevice;
+}
+
+public final class leakcanary/ProcessInfo$AvailableRam$Memory : leakcanary/ProcessInfo$AvailableRam {
+	public fun <init> (J)V
+	public final fun getBytes ()J
+}
+
+public final class leakcanary/ProcessInfo$Real : leakcanary/ProcessInfo {
+	public static final field INSTANCE Lleakcanary/ProcessInfo$Real;
+	public fun availableDiskSpaceBytes (Ljava/io/File;)J
+	public fun availableRam (Landroid/content/Context;)Lleakcanary/ProcessInfo$AvailableRam;
+	public fun getElapsedMillisSinceStart ()J
+	public fun isImportanceBackground ()Z
+}
+
+public final class leakcanary/SaveResourceIdsInterceptor : leakcanary/HeapAnalysisInterceptor {
+	public fun <init> (Landroid/content/res/Resources;)V
+	public fun intercept (Lleakcanary/HeapAnalysisInterceptor$Chain;)Lleakcanary/HeapAnalysisJob$Result;
+}
+
+public final class leakcanary/ScreenOffTrigger {
+	public fun <init> (Landroid/app/Application;Lleakcanary/HeapAnalysisClient;Ljava/util/concurrent/Executor;Lkotlin/jvm/functions/Function1;)V
+	public synthetic fun <init> (Landroid/app/Application;Lleakcanary/HeapAnalysisClient;Ljava/util/concurrent/Executor;Lkotlin/jvm/functions/Function1;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun start ()V
+	public final fun stop ()V
+}
+
diff --git a/leakcanary-android-release/build.gradle b/leakcanary-android-release/build.gradle
new file mode 100644
index 00000000..405dff18
--- /dev/null
+++ b/leakcanary-android-release/build.gradle
@@ -0,0 +1,33 @@
+plugins {
+  id("com.android.library")
+  id("org.jetbrains.kotlin.android")
+  id("com.vanniktech.maven.publish")
+}
+
+dependencies {
+  api projects.sharkAndroid
+  api projects.leakcanaryAndroidUtils
+
+  implementation libs.kotlin.stdlib
+  implementation libs.okio2
+}
+
+def gitSha() {
+  return 'git rev-parse --short HEAD'.execute().text.trim()
+}
+
+android {
+  resourcePrefix 'leak_canary_'
+  compileSdk versions.compileSdk
+  defaultConfig {
+    minSdk 16
+    buildConfigField "String", "LIBRARY_VERSION", "\"${rootProject.ext.VERSION_NAME}\""
+    buildConfigField "String", "GIT_SHA", "\"${gitSha()}\""
+    consumerProguardFiles 'consumer-proguard-rules.pro'
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
+    checkOnly 'Interoperability'
+  }
+}
diff --git a/leakcanary-android-release/consumer-proguard-rules.pro b/leakcanary-android-release/consumer-proguard-rules.pro
new file mode 100644
index 00000000..e69de29b
diff --git a/leakcanary-android-release/gradle.properties b/leakcanary-android-release/gradle.properties
new file mode 100644
index 00000000..f2237133
--- /dev/null
+++ b/leakcanary-android-release/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-android-release
+POM_NAME=LeakCanary for released Android apps
+POM_PACKAGING=aar
diff --git a/leakcanary-android-release/src/main/AndroidManifest.xml b/leakcanary-android-release/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..93ec04b5
--- /dev/null
+++ b/leakcanary-android-release/src/main/AndroidManifest.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="com.squareup.leakcanary.release" />
diff --git a/leakcanary-android-release/src/main/java/leakcanary/BackgroundTrigger.kt b/leakcanary-android-release/src/main/java/leakcanary/BackgroundTrigger.kt
new file mode 100644
index 00000000..9d410036
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/BackgroundTrigger.kt
@@ -0,0 +1,65 @@
+package leakcanary
+
+import android.app.Application
+import leakcanary.internal.BackgroundListener
+import leakcanary.internal.friendly.checkMainThread
+import shark.SharkLog
+import java.util.concurrent.Executor
+
+class BackgroundTrigger(
+  private val application: Application,
+  private val analysisClient: HeapAnalysisClient,
+  /**
+   * The executor on which the analysis is performed and on which [analysisCallback] is called.
+   * This should likely be a single thread executor with a background thread priority.
+   */
+  private val analysisExecutor: Executor,
+
+  processInfo: ProcessInfo = ProcessInfo.Real,
+
+  /**
+   * Called back with a [HeapAnalysisJob.Result] after the app has entered background and a
+   * heap analysis was attempted. This is called on the same thread that the analysis was
+   * performed on.
+   *
+   * Defaults to logging to [SharkLog] (don't forget to set [SharkLog.logger] if you do want to see
+   * logs).
+   */
+  private val analysisCallback: (HeapAnalysisJob.Result) -> Unit = { result ->
+    SharkLog.d { "$result" }
+  },
+) {
+
+  @Volatile
+  private var currentJob: HeapAnalysisJob? = null
+
+  private val backgroundListener = BackgroundListener(processInfo) { appInBackgroundNow ->
+    if (appInBackgroundNow) {
+      check(currentJob == null) {
+        "Current job set to null when leaving background"
+      }
+
+      val job =
+        analysisClient.newJob(JobContext(BackgroundTrigger::class))
+      currentJob = job
+      analysisExecutor.execute {
+        val result = job.execute()
+        currentJob = null
+        analysisCallback(result)
+      }
+    } else {
+      currentJob?.cancel("app left background")
+      currentJob = null
+    }
+  }
+
+  fun start() {
+    checkMainThread()
+    backgroundListener.install(application)
+  }
+
+  fun stop() {
+    checkMainThread()
+    backgroundListener.uninstall(application)
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-release/src/main/java/leakcanary/ConditionalInterceptor.kt b/leakcanary-android-release/src/main/java/leakcanary/ConditionalInterceptor.kt
new file mode 100644
index 00000000..884f82ed
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/ConditionalInterceptor.kt
@@ -0,0 +1,26 @@
+package leakcanary
+
+import leakcanary.HeapAnalysisInterceptor.Chain
+import leakcanary.HeapAnalysisJob.Result
+
+/**
+ * An interceptor that runs only when [evaluateCondition] returns true.
+ */
+class ConditionalInterceptor(
+  private val delegate: HeapAnalysisInterceptor,
+  private val evaluateCondition: (HeapAnalysisJob) -> Boolean
+) : HeapAnalysisInterceptor {
+  override fun intercept(chain: Chain): Result {
+    if (evaluateCondition(chain.job)) {
+      return delegate.intercept(object : Chain {
+        override val job = chain.job
+
+        override fun proceed(): Result {
+          return chain.proceed()
+        }
+      })
+    } else {
+      return chain.proceed()
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-release/src/main/java/leakcanary/GoodAndroidVersionInterceptor.kt b/leakcanary-android-release/src/main/java/leakcanary/GoodAndroidVersionInterceptor.kt
new file mode 100644
index 00000000..1d884ea1
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/GoodAndroidVersionInterceptor.kt
@@ -0,0 +1,29 @@
+package leakcanary
+
+import android.os.Build
+import leakcanary.HeapAnalysisInterceptor.Chain
+
+class GoodAndroidVersionInterceptor : HeapAnalysisInterceptor {
+  private val errorMessage: String? by lazy {
+    val sdkInt = Build.VERSION.SDK_INT
+    if (// findObjectById() sometimes failing. See #1759
+      sdkInt != 23 &&
+      // findObjectById() sometimes failing. See #1759
+      sdkInt != 25 &&
+      // Android 11 seem to sometimes have super slow heap dumps.
+      // See https://issuetracker.google.com/issues/168634429
+      sdkInt < 30
+    ) {
+      null
+    } else {
+      "Build.VERSION.SDK_INT $sdkInt not supported"
+    }
+  }
+
+  override fun intercept(chain: Chain): HeapAnalysisJob.Result {
+    errorMessage?.let {
+      chain.job.cancel(it)
+    }
+    return chain.proceed()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-release/src/main/java/leakcanary/HeapAnalysisClient.kt b/leakcanary-android-release/src/main/java/leakcanary/HeapAnalysisClient.kt
new file mode 100644
index 00000000..a188841e
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/HeapAnalysisClient.kt
@@ -0,0 +1,51 @@
+package leakcanary
+
+import android.app.Application
+import leakcanary.internal.RealHeapAnalysisJob
+import leakcanary.internal.RealHeapAnalysisJob.Companion.HPROF_PREFIX
+import leakcanary.internal.RealHeapAnalysisJob.Companion.HPROF_SUFFIX
+import java.io.File
+
+class HeapAnalysisClient(
+  /**
+   * Provides the directory where heap dumps should be stored.
+   * The passed in directory SHOULD be part of the app internal storage, and private to the
+   * app, to guarantee no other app can read the heap dumps.
+   *
+   * You should probably pass in [android.app.Application.getCacheDir] or a sub directory
+   * of the cache directory, as the cache directory will never be backed up and it will be
+   * cleared if the user needs space.
+   *
+   * This will be invoked on the thread used to execute analysis jobs. The main reason for
+   * the delayed invocation is because [android.app.Application.getCacheDir] might perform
+   * IO and trigger StrictMode violations.
+   */
+  private val heapDumpDirectoryProvider: () -> File,
+  private val config: HeapAnalysisConfig,
+  private val interceptors: List<HeapAnalysisInterceptor>
+) {
+
+  fun newJob(context: JobContext = JobContext()): HeapAnalysisJob {
+    return RealHeapAnalysisJob(heapDumpDirectoryProvider, config, interceptors, context)
+  }
+
+  fun deleteHeapDumpFiles() {
+    val heapDumpFiles = heapDumpDirectoryProvider().listFiles { _, name ->
+      name.startsWith(HPROF_PREFIX) && name.endsWith(HPROF_SUFFIX)
+    }
+    heapDumpFiles?.forEach { it.delete() }
+  }
+
+  companion object {
+    fun defaultInterceptors(application: Application): List<HeapAnalysisInterceptor> {
+      return listOf(
+        GoodAndroidVersionInterceptor(),
+        MinimumDiskSpaceInterceptor(application),
+        MinimumMemoryInterceptor(application),
+        MinimumElapsedSinceStartInterceptor(),
+        OncePerPeriodInterceptor(application),
+        SaveResourceIdsInterceptor(application.resources)
+      )
+    }
+  }
+}
diff --git a/leakcanary-android-release/src/main/java/leakcanary/HeapAnalysisConfig.kt b/leakcanary-android-release/src/main/java/leakcanary/HeapAnalysisConfig.kt
new file mode 100644
index 00000000..0df5accc
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/HeapAnalysisConfig.kt
@@ -0,0 +1,75 @@
+package leakcanary
+
+import shark.AndroidMetadataExtractor
+import shark.AndroidObjectInspectors
+import shark.AndroidReferenceMatchers
+import shark.FilteringLeakingObjectFinder
+import shark.LeakingObjectFinder
+import shark.MetadataExtractor
+import shark.ObjectInspector
+import shark.IgnoredReferenceMatcher
+import shark.ReferenceMatcher
+import shark.LibraryLeakReferenceMatcher
+
+data class HeapAnalysisConfig(
+
+  /**
+   * Known patterns of references in the heap, added here either to ignore them
+   * ([IgnoredReferenceMatcher]) or to mark them as library leaks ([LibraryLeakReferenceMatcher]).
+   *
+   * When adding your own custom [LibraryLeakReferenceMatcher] instances, you'll most
+   * likely want to set [LibraryLeakReferenceMatcher.patternApplies] with a filter that checks
+   * for the Android OS version and manufacturer. The build information can be obtained by calling
+   * [shark.AndroidBuildMirror.fromHeapGraph].
+   *
+   * Defaults to [AndroidReferenceMatchers.appDefaults]
+   */
+  val referenceMatchers: List<ReferenceMatcher> = AndroidReferenceMatchers.appDefaults,
+
+  /**
+   * List of [ObjectInspector] that provide LeakCanary with insights about objects found in the
+   * heap. You can create your own [ObjectInspector] implementations, and also add
+   * a [shark.AppSingletonInspector] instance created with the list of internal singletons.
+   *
+   * Defaults to [AndroidObjectInspectors.appDefaults]
+   */
+  val objectInspectors: List<ObjectInspector> = AndroidObjectInspectors.appDefaults,
+
+  /**
+   * Extracts metadata from a hprof to be reported in [shark.HeapAnalysisSuccess.metadata].
+   * Called on a background thread during heap analysis.
+   *
+   * Defaults to [AndroidMetadataExtractor]
+   */
+  val metadataExtractor: MetadataExtractor = AndroidMetadataExtractor,
+
+  /**
+   * Whether to compute the retained heap size, which is the total number of bytes in memory that
+   * would be reclaimed if the detected leaks didn't happen. This includes native memory
+   * associated to Java objects (e.g. Android bitmaps).
+   *
+   * Computing the retained heap size can slow down the analysis because it requires navigating
+   * from GC roots through the entire object graph, whereas [shark.HeapAnalyzer] would otherwise
+   * stop as soon as all leaking instances are found.
+   *
+   * Defaults to true.
+   */
+  val computeRetainedHeapSize: Boolean = true,
+
+  /**
+   * Finds the objects that are leaking, for which LeakCanary will compute leak traces.
+   *
+   * Defaults to a [FilteringLeakingObjectFinder] that scans all objects in the heap dump and
+   * delegates the decision to [AndroidObjectInspectors.appLeakingObjectFilters].
+   */
+  val leakingObjectFinder: LeakingObjectFinder = FilteringLeakingObjectFinder(
+    AndroidObjectInspectors.appLeakingObjectFilters
+  ),
+
+  /**
+   * Whether the first step after a heap dump should be to replace the content of all arrays with
+   * zeroes. This increases the overall processing time but limits the amount of time the heap
+   * dump exists on disk with potential PII.
+   */
+  val stripHeapDump: Boolean = false
+)
diff --git a/leakcanary-android-release/src/main/java/leakcanary/HeapAnalysisInterceptor.kt b/leakcanary-android-release/src/main/java/leakcanary/HeapAnalysisInterceptor.kt
new file mode 100644
index 00000000..d39aa346
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/HeapAnalysisInterceptor.kt
@@ -0,0 +1,12 @@
+package leakcanary
+
+fun interface HeapAnalysisInterceptor {
+
+  fun intercept(chain: Chain): HeapAnalysisJob.Result
+
+  interface Chain {
+    val job: HeapAnalysisJob
+
+    fun proceed(): HeapAnalysisJob.Result
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-release/src/main/java/leakcanary/HeapAnalysisJob.kt b/leakcanary-android-release/src/main/java/leakcanary/HeapAnalysisJob.kt
new file mode 100644
index 00000000..d123ac9b
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/HeapAnalysisJob.kt
@@ -0,0 +1,51 @@
+package leakcanary
+
+import shark.HeapAnalysis
+
+/**
+ * A [HeapAnalysisJob] represents a single prepared request to analyze the heap. It cannot be
+ * executed twice.
+ */
+interface HeapAnalysisJob {
+
+  /**
+   * In memory store, mutable and thread safe. This allows passing data to interceptors.
+   */
+  val context: JobContext
+
+  /**
+   * true if [execute] has been called. It is an
+   * error to call [execute] more than once.
+   */
+  val executed: Boolean
+
+  /**
+   * true of [cancel] has been called or if an [HeapAnalysisInterceptor] has returned
+   * [Result.Canceled] from [HeapAnalysisInterceptor.intercept].
+   */
+  val canceled: Boolean
+
+  /**
+   * Starts the analysis job immediately, and blocks until a result is available.
+   *
+   * @return Either [Result.Done] if the analysis was attempted or [Result.Canceled]
+   */
+  fun execute(): Result
+
+  /** Cancels the job, if possible. Jobs that are already complete cannot be canceled. */
+  fun cancel(cancelReason: String)
+
+  sealed class Result {
+
+    data class Done(
+      val analysis: HeapAnalysis,
+      /**
+       * The time spent stripping the hprof of any data if [HeapAnalysisConfig.stripHeapDump] is
+       * true, null otherwise.
+       */
+      val stripHeapDumpDurationMillis: Long? = null
+      ) : Result()
+
+    data class Canceled(val cancelReason: String) : Result()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-release/src/main/java/leakcanary/JobContext.kt b/leakcanary-android-release/src/main/java/leakcanary/JobContext.kt
new file mode 100644
index 00000000..e2baf51a
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/JobContext.kt
@@ -0,0 +1,60 @@
+package leakcanary
+
+import java.util.concurrent.ConcurrentHashMap
+import kotlin.reflect.KClass
+
+/**
+ * In memory store that can be used to store objects in a given [HeapAnalysisJob] instance.
+ * This is a simple [MutableMap] of [String] to [Any], but with unsafe generics access.
+ *
+ * By convention, [starter] should be the class that triggered the start of the job.
+ */
+class JobContext constructor(val starter: Class<*>? = null) {
+
+  constructor(starter: KClass<*>) : this(starter.java)
+
+  private val store = ConcurrentHashMap<String, Any?>()
+
+  operator fun <T> get(key: String): T? {
+    @Suppress("UNCHECKED_CAST")
+    return store[key] as T?
+  }
+
+  /**
+   * @see MutableMap.getOrPut
+   */
+  fun <T> getOrPut(
+    key: String,
+    defaultValue: () -> T
+  ): T {
+    @Suppress("UNCHECKED_CAST")
+    return store.getOrPut(key) {
+      defaultValue()
+    } as T
+  }
+
+  /**
+   * @see MutableMap.set
+   */
+  operator fun <T> set(
+    key: String,
+    value: T
+  ) {
+    store[key] = (value as Any?)
+  }
+
+  /**
+   * @see MutableMap.containsKey
+   */
+  operator fun contains(key: String): Boolean {
+    return store.containsKey(key)
+  }
+
+  /**
+   * @see MutableMap.remove
+   */
+  operator fun minusAssign(key: String) {
+    @Suppress("UNCHECKED_CAST")
+    store -= key
+  }
+}
diff --git a/leakcanary-android-release/src/main/java/leakcanary/MinimumDiskSpaceInterceptor.kt b/leakcanary-android-release/src/main/java/leakcanary/MinimumDiskSpaceInterceptor.kt
new file mode 100644
index 00000000..67aa1ffb
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/MinimumDiskSpaceInterceptor.kt
@@ -0,0 +1,20 @@
+package leakcanary
+
+import android.app.Application
+import leakcanary.HeapAnalysisInterceptor.Chain
+import leakcanary.HeapAnalysisJob.Result
+
+class MinimumDiskSpaceInterceptor(
+  private val application: Application,
+  private val minimumDiskSpaceBytes: Long = 200_000_000,
+  private val processInfo: ProcessInfo = ProcessInfo.Real
+) : HeapAnalysisInterceptor {
+
+  override fun intercept(chain: Chain): Result {
+    val availableDiskSpace = processInfo.availableDiskSpaceBytes(application.filesDir!!)
+    if (availableDiskSpace < minimumDiskSpaceBytes) {
+      chain.job.cancel("availableDiskSpace $availableDiskSpace < minimumDiskSpaceBytes $minimumDiskSpaceBytes")
+    }
+    return chain.proceed()
+  }
+}
diff --git a/leakcanary-android-release/src/main/java/leakcanary/MinimumElapsedSinceStartInterceptor.kt b/leakcanary-android-release/src/main/java/leakcanary/MinimumElapsedSinceStartInterceptor.kt
new file mode 100644
index 00000000..3c8aa952
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/MinimumElapsedSinceStartInterceptor.kt
@@ -0,0 +1,20 @@
+package leakcanary
+
+import android.annotation.SuppressLint
+import leakcanary.HeapAnalysisInterceptor.Chain
+import leakcanary.HeapAnalysisJob.Result
+import java.util.concurrent.TimeUnit
+
+@SuppressLint("NewApi")
+class MinimumElapsedSinceStartInterceptor(
+  private val minimumElapsedSinceStartMillis: Long = TimeUnit.SECONDS.toMillis(30),
+  private val processInfo: ProcessInfo = ProcessInfo.Real
+) : HeapAnalysisInterceptor {
+
+  override fun intercept(chain: Chain): Result {
+    if (processInfo.elapsedMillisSinceStart < minimumElapsedSinceStartMillis) {
+      chain.job.cancel("app started less than $minimumElapsedSinceStartMillis ms ago.")
+    }
+    return chain.proceed()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-release/src/main/java/leakcanary/MinimumMemoryInterceptor.kt b/leakcanary-android-release/src/main/java/leakcanary/MinimumMemoryInterceptor.kt
new file mode 100644
index 00000000..b92fcd47
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/MinimumMemoryInterceptor.kt
@@ -0,0 +1,34 @@
+package leakcanary
+
+import android.app.Application
+import leakcanary.HeapAnalysisInterceptor.Chain
+import leakcanary.ProcessInfo.AvailableRam.BelowThreshold
+import leakcanary.ProcessInfo.AvailableRam.LowRamDevice
+import leakcanary.ProcessInfo.AvailableRam.Memory
+
+class MinimumMemoryInterceptor(
+  private val application: Application,
+  private val minimumRequiredAvailableMemoryBytes: Long = 100_000_000,
+  private val processInfo: ProcessInfo = ProcessInfo.Real
+) : HeapAnalysisInterceptor {
+
+  override fun intercept(chain: Chain): HeapAnalysisJob.Result {
+    when (val memory = processInfo.availableRam(application)) {
+      LowRamDevice -> {
+        chain.job.cancel("low ram device")
+      }
+      BelowThreshold -> {
+        chain.job.cancel("low memory")
+      }
+      is Memory -> {
+        if (memory.bytes < minimumRequiredAvailableMemoryBytes) {
+          chain.job.cancel(
+            "not enough free memory: available ${memory.bytes} < min $minimumRequiredAvailableMemoryBytes"
+          )
+        }
+      }
+    }
+
+    return chain.proceed()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-release/src/main/java/leakcanary/OncePerPeriodInterceptor.kt b/leakcanary-android-release/src/main/java/leakcanary/OncePerPeriodInterceptor.kt
new file mode 100644
index 00000000..a3bdf5f4
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/OncePerPeriodInterceptor.kt
@@ -0,0 +1,46 @@
+package leakcanary
+
+import android.app.Application
+import android.content.Context
+import android.content.SharedPreferences
+import leakcanary.HeapAnalysisInterceptor.Chain
+import leakcanary.HeapAnalysisJob.Result
+import java.util.concurrent.TimeUnit
+
+/**
+ * Proceeds once per [period] (of time) and then cancels all follow up jobs until [period] has
+ * passed.
+ */
+class OncePerPeriodInterceptor(
+  application: Application,
+  private val periodMillis: Long = TimeUnit.DAYS.toMillis(1)
+) : HeapAnalysisInterceptor {
+
+  private val preference: SharedPreferences by lazy {
+    application.getSharedPreferences("OncePerPeriodInterceptor", Context.MODE_PRIVATE)!!
+  }
+
+  override fun intercept(chain: Chain): Result {
+    val lastStartTimestamp = preference.getLong(LAST_START_TIMESTAMP_KEY, 0)
+    val now = System.currentTimeMillis()
+    val elapsedMillis = now - lastStartTimestamp
+
+    if (elapsedMillis < periodMillis) {
+      chain.job.cancel("not enough time elapsed since last analysis: elapsed $elapsedMillis ms < period $periodMillis ms")
+    }
+
+    return chain.proceed().apply {
+      if (this is Result.Done) {
+        preference.edit().putLong(LAST_START_TIMESTAMP_KEY, now).apply()
+      }
+    }
+  }
+
+  fun forget() {
+    preference.edit().clear().apply()
+  }
+
+  companion object {
+    private const val LAST_START_TIMESTAMP_KEY = "last_start_timestamp"
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-release/src/main/java/leakcanary/ProcessInfo.kt b/leakcanary-android-release/src/main/java/leakcanary/ProcessInfo.kt
new file mode 100644
index 00000000..5f1eba7a
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/ProcessInfo.kt
@@ -0,0 +1,120 @@
+package leakcanary
+
+import android.annotation.SuppressLint
+import android.app.ActivityManager
+import android.app.ActivityManager.MemoryInfo
+import android.app.ActivityManager.RunningAppProcessInfo
+import android.content.Context
+import android.os.Build.VERSION.SDK_INT
+import android.os.Process
+import android.os.SystemClock
+import android.system.Os
+import android.system.OsConstants
+import java.io.File
+import java.io.FileReader
+import leakcanary.ProcessInfo.AvailableRam.BelowThreshold
+import leakcanary.ProcessInfo.AvailableRam.LowRamDevice
+import leakcanary.ProcessInfo.AvailableRam.Memory
+
+interface ProcessInfo {
+
+  val isImportanceBackground: Boolean
+
+  val elapsedMillisSinceStart: Long
+
+  fun availableDiskSpaceBytes(path: File): Long
+
+  sealed class AvailableRam {
+    object LowRamDevice : AvailableRam()
+    object BelowThreshold : AvailableRam()
+    class Memory(val bytes: Long) : AvailableRam()
+  }
+
+  fun availableRam(context: Context): AvailableRam
+
+  @SuppressLint("NewApi")
+  object Real : ProcessInfo {
+    private val memoryOutState = RunningAppProcessInfo()
+    private val memoryInfo = MemoryInfo()
+
+    private val processStartUptimeMillis by lazy {
+      Process.getStartUptimeMillis()
+    }
+
+    private val processForkRealtimeMillis by lazy {
+      readProcessForkRealtimeMillis()
+    }
+
+    override val isImportanceBackground: Boolean
+      get() {
+        ActivityManager.getMyMemoryState(memoryOutState)
+        return memoryOutState.importance >= RunningAppProcessInfo.IMPORTANCE_BACKGROUND
+      }
+
+    override val elapsedMillisSinceStart: Long
+      get() = if (SDK_INT >= 24) {
+        SystemClock.uptimeMillis() - processStartUptimeMillis
+      } else {
+        SystemClock.elapsedRealtime() - processForkRealtimeMillis
+      }
+
+    @SuppressLint("UsableSpace")
+    override fun availableDiskSpaceBytes(path: File) = path.usableSpace
+
+    override fun availableRam(context: Context): AvailableRam {
+      val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
+
+      if (SDK_INT >= 19 && activityManager.isLowRamDevice) {
+        return LowRamDevice
+      } else {
+        activityManager.getMemoryInfo(memoryInfo)
+
+        return if (memoryInfo.lowMemory || memoryInfo.availMem <= memoryInfo.threshold) {
+          BelowThreshold
+        } else {
+          val systemAvailableMemory = memoryInfo.availMem - memoryInfo.threshold
+
+          val runtime = Runtime.getRuntime()
+          val appUsedMemory = runtime.totalMemory() - runtime.freeMemory()
+          val appAvailableMemory = runtime.maxMemory() - appUsedMemory
+
+          val availableMemory = systemAvailableMemory.coerceAtMost(appAvailableMemory)
+          Memory(availableMemory)
+        }
+      }
+    }
+
+    /**
+     * See https://dev.to/pyricau/android-vitals-when-did-my-app-start-24p4#process-fork-time
+     */
+    private fun readProcessForkRealtimeMillis(): Long {
+      val myPid = Process.myPid()
+      val ticksAtProcessStart = readProcessStartTicks(myPid)
+
+      val ticksPerSecond = if (SDK_INT >= 21) {
+        Os.sysconf(OsConstants._SC_CLK_TCK)
+      } else {
+        val tckConstant = try {
+          Class.forName("android.system.OsConstants").getField("_SC_CLK_TCK").getInt(null)
+        } catch (e: ClassNotFoundException) {
+          Class.forName("libcore.io.OsConstants").getField("_SC_CLK_TCK").getInt(null)
+        }
+        val os = Class.forName("libcore.io.Libcore").getField("os").get(null)!!
+        os::class.java.getMethod("sysconf", Integer.TYPE).invoke(os, tckConstant) as Long
+      }
+      return ticksAtProcessStart * 1000 / ticksPerSecond
+    }
+
+    // Benchmarked (with Jetpack Benchmark) on Pixel 3 running
+    // Android 10. Median time: 0.13ms
+    private fun readProcessStartTicks(pid: Int): Long {
+      val path = "/proc/$pid/stat"
+      val stat = FileReader(path).buffered().use { reader ->
+        reader.readLine()
+      }
+      val fields = stat.substringAfter(") ")
+        .split(' ')
+      return fields[19].toLong()
+    }
+  }
+}
diff --git a/leakcanary-android-release/src/main/java/leakcanary/SaveResourceIdsInterceptor.kt b/leakcanary-android-release/src/main/java/leakcanary/SaveResourceIdsInterceptor.kt
new file mode 100644
index 00000000..251d2053
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/SaveResourceIdsInterceptor.kt
@@ -0,0 +1,36 @@
+package leakcanary
+
+import android.content.res.Resources
+import android.content.res.Resources.NotFoundException
+import leakcanary.HeapAnalysisInterceptor.Chain
+import leakcanary.HeapAnalysisJob.Result
+import shark.AndroidResourceIdNames
+
+/**
+ * Interceptor that saves the names of R.id.* entries and their associated int values to a static
+ * field that can then be read from the heap dump.
+ */
+class SaveResourceIdsInterceptor(private val resources: Resources) : HeapAnalysisInterceptor {
+  override fun intercept(chain: Chain): Result {
+    saveResourceIdNamesToMemory()
+    return chain.proceed()
+  }
+
+  private fun saveResourceIdNamesToMemory() {
+    AndroidResourceIdNames.saveToMemory(
+      getResourceTypeName = { id ->
+        try {
+          resources.getResourceTypeName(id)
+        } catch (e: NotFoundException) {
+          null
+        }
+      },
+      getResourceEntryName = { id ->
+        try {
+          resources.getResourceEntryName(id)
+        } catch (e: NotFoundException) {
+          null
+        }
+      })
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-release/src/main/java/leakcanary/ScreenOffTrigger.kt b/leakcanary-android-release/src/main/java/leakcanary/ScreenOffTrigger.kt
new file mode 100644
index 00000000..60f8136d
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/ScreenOffTrigger.kt
@@ -0,0 +1,81 @@
+package leakcanary
+
+import android.app.Application
+import android.content.BroadcastReceiver
+import android.content.Context
+import android.content.Intent
+import android.content.Intent.ACTION_SCREEN_OFF
+import android.content.Intent.ACTION_SCREEN_ON
+import android.content.IntentFilter
+import android.os.Build
+import java.util.concurrent.Executor
+import leakcanary.internal.friendly.checkMainThread
+import shark.SharkLog
+
+class ScreenOffTrigger(
+  private val application: Application,
+  private val analysisClient: HeapAnalysisClient,
+  /**
+   * The executor on which the analysis is performed and on which [analysisCallback] is called.
+   * This should likely be a single thread executor with a background thread priority.
+   */
+  private val analysisExecutor: Executor,
+
+  /**
+   * Called back with a [HeapAnalysisJob.Result] after the screen went off and a
+   * heap analysis was attempted. This is called on the same thread that the analysis was
+   * performed on.
+   *
+   * Defaults to logging to [SharkLog] (don't forget to set [SharkLog.logger] if you do want to see
+   * logs).
+   */
+  private val analysisCallback: (HeapAnalysisJob.Result) -> Unit = { result ->
+    SharkLog.d { "$result" }
+  },
+) {
+
+  @Volatile
+  private var currentJob: HeapAnalysisJob? = null
+
+  private val screenReceiver = object : BroadcastReceiver() {
+    override fun onReceive(
+      context: Context,
+      intent: Intent
+    ) {
+      if (intent.action == ACTION_SCREEN_OFF) {
+        if (currentJob == null) {
+          val job =
+            analysisClient.newJob(JobContext(ScreenOffTrigger::class))
+          currentJob = job
+          analysisExecutor.execute {
+            val result = job.execute()
+            currentJob = null
+            analysisCallback(result)
+          }
+        }
+      } else {
+        currentJob?.cancel("screen on again")
+        currentJob = null
+      }
+    }
+  }
+
+  fun start() {
+    checkMainThread()
+    val intentFilter = IntentFilter().apply {
+      addAction(ACTION_SCREEN_ON)
+      addAction(ACTION_SCREEN_OFF)
+    }
+    if (Build.VERSION.SDK_INT >= 33) {
+      val flags = Context.RECEIVER_EXPORTED
+      application.registerReceiver(screenReceiver, intentFilter, flags)
+    } else {
+      application.registerReceiver(screenReceiver, intentFilter)
+    }
+  }
+
+  fun stop() {
+    checkMainThread()
+    application.unregisterReceiver(screenReceiver)
+  }
+}
diff --git a/leakcanary-android-release/src/main/java/leakcanary/internal/BackgroundListener.kt b/leakcanary-android-release/src/main/java/leakcanary/internal/BackgroundListener.kt
new file mode 100644
index 00000000..76a5033e
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/internal/BackgroundListener.kt
@@ -0,0 +1,64 @@
+package leakcanary.internal
+
+import android.app.Activity
+import android.app.Application
+import android.app.Application.ActivityLifecycleCallbacks
+import leakcanary.ProcessInfo
+import leakcanary.internal.friendly.mainHandler
+import leakcanary.internal.friendly.noOpDelegate
+
+/**
+ * Tracks whether the app is in background, based on the app's importance.
+ */
+internal class BackgroundListener(
+  private val processInfo: ProcessInfo,
+  private val callback: (Boolean) -> Unit
+) : ActivityLifecycleCallbacks by noOpDelegate() {
+
+  private val checkAppInBackground: Runnable = object : Runnable {
+    override fun run() {
+      val appInBackgroundNow = processInfo.isImportanceBackground
+      updateBackgroundState(appInBackgroundNow)
+      if (!appInBackgroundNow) {
+        mainHandler.removeCallbacks(this)
+        mainHandler.postDelayed(this, BACKGROUND_REPEAT_DELAY_MS)
+      }
+    }
+  }
+
+  private fun updateBackgroundState(appInBackgroundNow: Boolean) {
+    if (appInBackground != appInBackgroundNow) {
+      appInBackground = appInBackgroundNow
+      callback.invoke(appInBackgroundNow)
+    }
+  }
+
+  private var appInBackground = false
+
+  fun install(application: Application) {
+    application.registerActivityLifecycleCallbacks(this)
+    updateBackgroundState(appInBackgroundNow = false)
+    checkAppInBackground.run()
+  }
+
+  fun uninstall(application: Application) {
+    application.unregisterActivityLifecycleCallbacks(this)
+    updateBackgroundState(appInBackgroundNow = false)
+    mainHandler.removeCallbacks(checkAppInBackground)
+  }
+
+  override fun onActivityPaused(activity: Activity) {
+    mainHandler.removeCallbacks(checkAppInBackground)
+    mainHandler.postDelayed(checkAppInBackground, BACKGROUND_DELAY_MS)
+  }
+
+  override fun onActivityResumed(activity: Activity) {
+    updateBackgroundState(appInBackgroundNow = false)
+    mainHandler.removeCallbacks(checkAppInBackground)
+  }
+
+  companion object {
+    private const val BACKGROUND_DELAY_MS = 1000L
+    private const val BACKGROUND_REPEAT_DELAY_MS = 5000L
+  }
+}
diff --git a/leakcanary-android-release/src/main/java/leakcanary/internal/RealHeapAnalysisJob.kt b/leakcanary-android-release/src/main/java/leakcanary/internal/RealHeapAnalysisJob.kt
new file mode 100644
index 00000000..ae4d4dd2
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/internal/RealHeapAnalysisJob.kt
@@ -0,0 +1,338 @@
+package leakcanary.internal
+
+import android.os.Debug
+import android.os.SystemClock
+import java.io.File
+import java.util.UUID
+import java.util.concurrent.atomic.AtomicBoolean
+import java.util.concurrent.atomic.AtomicReference
+import leakcanary.HeapAnalysisConfig
+import leakcanary.HeapAnalysisInterceptor
+import leakcanary.HeapAnalysisJob
+import leakcanary.HeapAnalysisJob.Result
+import leakcanary.HeapAnalysisJob.Result.Canceled
+import leakcanary.HeapAnalysisJob.Result.Done
+import leakcanary.JobContext
+import okio.buffer
+import okio.sink
+import shark.CloseableHeapGraph
+import shark.ConstantMemoryMetricsDualSourceProvider
+import shark.DualSourceProvider
+import shark.HeapAnalysis
+import shark.HeapAnalysisException
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.HeapAnalyzer
+import shark.HprofHeapGraph
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.HprofPrimitiveArrayStripper
+import shark.OnAnalysisProgressListener
+import shark.RandomAccessSource
+import shark.SharkLog
+import shark.StreamingSourceProvider
+import shark.ThrowingCancelableFileSourceProvider
+
+internal class RealHeapAnalysisJob(
+  private val heapDumpDirectoryProvider: () -> File,
+  private val config: HeapAnalysisConfig,
+  private val interceptors: List<HeapAnalysisInterceptor>,
+  override val context: JobContext
+) : HeapAnalysisJob, HeapAnalysisInterceptor.Chain {
+
+  private val heapDumpDirectory by lazy {
+    heapDumpDirectoryProvider()
+  }
+
+  private val _canceled = AtomicReference<Canceled?>()
+
+  private val _executed = AtomicBoolean(false)
+
+  private lateinit var executionThread: Thread
+
+  private var interceptorIndex = 0
+
+  private var analysisStep: OnAnalysisProgressListener.Step? = null
+
+  override val executed
+    get() = _executed.get()
+
+  override val canceled
+    get() = _canceled.get() != null
+
+  override val job: HeapAnalysisJob
+    get() = this
+
+  override fun execute(): Result {
+    check(_executed.compareAndSet(false, true)) { "HeapAnalysisJob can only be executed once" }
+    SharkLog.d { "Starting heap analysis job" }
+    executionThread = Thread.currentThread()
+    return proceed()
+  }
+
+  override fun cancel(cancelReason: String) {
+    // If cancel is called several times, we use the first cancel reason.
+    _canceled.compareAndSet(null, Canceled(cancelReason))
+  }
+
+  override fun proceed(): Result {
+    check(Thread.currentThread() == executionThread) {
+      "Interceptor.Chain.proceed() called from unexpected thread ${Thread.currentThread()} instead of $executionThread"
+    }
+    check(interceptorIndex <= interceptors.size) {
+      "Interceptor.Chain.proceed() should be called max once per interceptor"
+    }
+    _canceled.get()?.let {
+      interceptorIndex = interceptors.size + 1
+      return it
+    }
+    if (interceptorIndex < interceptors.size) {
+      val currentInterceptor = interceptors[interceptorIndex]
+      interceptorIndex++
+      return currentInterceptor.intercept(this)
+    } else {
+      interceptorIndex++
+      val result = dumpAndAnalyzeHeap()
+      val analysis = result.analysis
+      analysis.heapDumpFile.delete()
+      if (analysis is HeapAnalysisFailure) {
+        val cause = analysis.exception.cause
+        if (cause is StopAnalysis) {
+          return _canceled.get()!!.run {
+            copy(cancelReason = "$cancelReason (stopped at ${cause.step})")
+          }
+        }
+      }
+      return result
+    }
+  }
+
+  private fun dumpAndAnalyzeHeap(): Done {
+    val filesDir = heapDumpDirectory
+    filesDir.mkdirs()
+    val fileNameBase = "$HPROF_PREFIX${UUID.randomUUID()}"
+    val sensitiveHeapDumpFile = File(filesDir, "$fileNameBase$HPROF_SUFFIX").apply {
+      // Any call to System.exit(0) will run shutdown hooks that will attempt to remove this
+      // file. Note that this is best effort, and won't delete if the VM is killed by the system.
+      deleteOnExit()
+    }
+
+    val heapDumpStart = SystemClock.uptimeMillis()
+    saveHeapDumpTime(heapDumpStart)
+
+    var dumpDurationMillis = -1L
+    var analysisDurationMillis = -1L
+    var heapDumpFile = sensitiveHeapDumpFile
+
+    try {
+      runGc()
+      dumpHeap(sensitiveHeapDumpFile)
+      dumpDurationMillis = SystemClock.uptimeMillis() - heapDumpStart
+
+      val stripDurationMillis =
+        if (config.stripHeapDump) {
+          leakcanary.internal.friendly.measureDurationMillis {
+            val strippedHeapDumpFile = File(filesDir, "$fileNameBase-stripped$HPROF_SUFFIX").apply {
+              deleteOnExit()
+            }
+            heapDumpFile = strippedHeapDumpFile
+            try {
+              stripHeapDump(sensitiveHeapDumpFile, strippedHeapDumpFile)
+            } finally {
+              sensitiveHeapDumpFile.delete()
+            }
+          }
+        } else null
+
+      return analyzeHeapWithStats(heapDumpFile).let { (heapAnalysis, stats) ->
+        when (heapAnalysis) {
+          is HeapAnalysisSuccess -> {
+            val metadata = heapAnalysis.metadata.toMutableMap()
+            metadata["Stats"] = stats
+            if (config.stripHeapDump) {
+              metadata["Hprof stripping duration"] = "$stripDurationMillis ms"
+            }
+            Done(
+              heapAnalysis.copy(
+                dumpDurationMillis = dumpDurationMillis,
+                metadata = metadata
+              ), stripDurationMillis
+            )
+          }
+          is HeapAnalysisFailure -> Done(
+            heapAnalysis.copy(
+              dumpDurationMillis = dumpDurationMillis,
+              analysisDurationMillis = (SystemClock.uptimeMillis() - heapDumpStart) - dumpDurationMillis
+            ), stripDurationMillis
+          )
+        }
+      }
+    } catch (throwable: Throwable) {
+      if (dumpDurationMillis == -1L) {
+        dumpDurationMillis = SystemClock.uptimeMillis() - heapDumpStart
+      }
+      if (analysisDurationMillis == -1L) {
+        analysisDurationMillis = (SystemClock.uptimeMillis() - heapDumpStart) - dumpDurationMillis
+      }
+      return Done(
+        HeapAnalysisFailure(
+          heapDumpFile = heapDumpFile,
+          createdAtTimeMillis = System.currentTimeMillis(),
+          dumpDurationMillis = dumpDurationMillis,
+          analysisDurationMillis = analysisDurationMillis,
+          exception = HeapAnalysisException(throwable)
+        )
+      )
+    }
+  }
+
+  private fun runGc() {
+    // Code taken from AOSP FinalizationTest:
+    // https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
+    // java/lang/ref/FinalizationTester.java
+    // System.gc() does not garbage collect every time. Runtime.gc() is
+    // more likely to perform a gc.
+    Runtime.getRuntime()
+      .gc()
+    enqueueReferences()
+    System.runFinalization()
+  }
+
+  private fun enqueueReferences() {
+    // Hack. We don't have a programmatic way to wait for the reference queue daemon to move
+    // references to the appropriate queues.
+    try {
+      Thread.sleep(100)
+    } catch (e: InterruptedException) {
+      throw AssertionError()
+    }
+  }
+
+  private fun saveHeapDumpTime(heapDumpUptimeMillis: Long) {
+    try {
+      Class.forName("leakcanary.KeyedWeakReference")
+        .getDeclaredField("heapDumpUptimeMillis")
+        .apply { isAccessible = true }
+        .set(null, heapDumpUptimeMillis)
+    } catch (ignored: Throwable) {
+      SharkLog.d(ignored) { "KeyedWeakReference.heapDumpUptimeMillis not updated" }
+    }
+  }
+
+  private fun dumpHeap(heapDumpFile: File) {
+    Debug.dumpHprofData(heapDumpFile.absolutePath)
+
+    check(heapDumpFile.exists()) {
+      "File does not exist after dump"
+    }
+
+    check(heapDumpFile.length() > 0L) {
+      "File has length ${heapDumpFile.length()} after dump"
+    }
+  }
+
+  private fun stripHeapDump(
+    sourceHeapDumpFile: File,
+    strippedHeapDumpFile: File
+  ) {
+    val sensitiveSourceProvider =
+      ThrowingCancelableFileSourceProvider(sourceHeapDumpFile) {
+        checkStopAnalysis("stripping heap dump")
+      }
+
+    var openCalls = 0
+    val deletingFileSourceProvider = StreamingSourceProvider {
+      openCalls++
+      sensitiveSourceProvider.openStreamingSource().apply {
+        if (openCalls == 2) {
+          // Using the Unix trick of deleting the file as soon as all readers have opened it.
+          // No new readers/writers will be able to access the file, but all existing
+          // ones will still have access until the last one closes the file.
+          SharkLog.d { "Deleting $sourceHeapDumpFile eagerly" }
+          sourceHeapDumpFile.delete()
+        }
+      }
+    }
+
+    val strippedHprofSink = strippedHeapDumpFile.outputStream().sink().buffer()
+    val stripper = HprofPrimitiveArrayStripper()
+
+    stripper.stripPrimitiveArrays(deletingFileSourceProvider, strippedHprofSink)
+  }
+
+  private fun analyzeHeapWithStats(heapDumpFile: File): Pair<HeapAnalysis, String> {
+    val fileLength = heapDumpFile.length()
+    val analysisSourceProvider = ConstantMemoryMetricsDualSourceProvider(
+      ThrowingCancelableFileSourceProvider(heapDumpFile) {
+        checkStopAnalysis(analysisStep?.name ?: "Reading heap dump")
+      })
+
+    val deletingFileSourceProvider = object : DualSourceProvider {
+      override fun openStreamingSource() = analysisSourceProvider.openStreamingSource()
+
+      override fun openRandomAccessSource(): RandomAccessSource {
+        SharkLog.d { "Deleting $heapDumpFile eagerly" }
+        return analysisSourceProvider.openRandomAccessSource().apply {
+          // Using the Unix trick of deleting the file as soon as all readers have opened it.
+          // No new readers/writers will be able to access the file, but all existing
+          // ones will still have access until the last one closes the file.
+          heapDumpFile.delete()
+        }
+      }
+    }
+
+    return deletingFileSourceProvider.openHeapGraph().use { graph ->
+      val heapAnalysis = analyzeHeap(heapDumpFile, graph)
+      val lruCacheStats = (graph as HprofHeapGraph).lruCacheStats()
+      val randomAccessStats =
+        "RandomAccess[" +
+          "bytes=${analysisSourceProvider.randomAccessByteReads}," +
+          "reads=${analysisSourceProvider.randomAccessReadCount}," +
+          "travel=${analysisSourceProvider.randomAccessByteTravel}," +
+          "range=${analysisSourceProvider.byteTravelRange}," +
+          "size=$fileLength" +
+          "]"
+      val stats = "$lruCacheStats $randomAccessStats"
+      (heapAnalysis to stats)
+    }
+  }
+
+  private fun analyzeHeap(
+    analyzedHeapDumpFile: File,
+    graph: CloseableHeapGraph
+  ): HeapAnalysis {
+    val stepListener = OnAnalysisProgressListener { step ->
+      analysisStep = step
+      checkStopAnalysis(step.name)
+      SharkLog.d { "Analysis in progress, working on: ${step.name}" }
+    }
+
+    val heapAnalyzer = HeapAnalyzer(stepListener)
+    return heapAnalyzer.analyze(
+      heapDumpFile = analyzedHeapDumpFile,
+      graph = graph,
+      leakingObjectFinder = config.leakingObjectFinder,
+      referenceMatchers = config.referenceMatchers,
+      computeRetainedHeapSize = config.computeRetainedHeapSize,
+      objectInspectors = config.objectInspectors,
+      metadataExtractor = config.metadataExtractor
+    )
+  }
+
+  private fun checkStopAnalysis(step: String) {
+    if (_canceled.get() != null) {
+      throw StopAnalysis(step)
+    }
+  }
+
+  class StopAnalysis(val step: String) : Exception() {
+    override fun fillInStackTrace(): Throwable {
+      // Skip filling in stacktrace.
+      return this
+    }
+  }
+
+  companion object {
+    const val HPROF_PREFIX = "heap-"
+    const val HPROF_SUFFIX = ".hprof"
+  }
+}
diff --git a/leakcanary-android-release/src/main/java/leakcanary/internal/friendly/Friendly.kt b/leakcanary-android-release/src/main/java/leakcanary/internal/friendly/Friendly.kt
new file mode 100644
index 00000000..cf621fbf
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/internal/friendly/Friendly.kt
@@ -0,0 +1,14 @@
+@file:Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER", "NOTHING_TO_INLINE")
+@file:JvmName("leakcanary-android-release_Friendly")
+
+package leakcanary.internal.friendly
+
+internal inline val mainHandler
+  get() = leakcanary.internal.mainHandler
+
+internal inline fun checkMainThread() = leakcanary.internal.checkMainThread()
+
+internal inline fun <reified T : Any> noOpDelegate(): T = leakcanary.internal.noOpDelegate()
+
+internal inline fun measureDurationMillis(block: () -> Unit) =
+  leakcanary.internal.measureDurationMillis(block)
\ No newline at end of file
diff --git a/leakcanary-android-sample/build.gradle b/leakcanary-android-sample/build.gradle
new file mode 100644
index 00000000..55d09024
--- /dev/null
+++ b/leakcanary-android-sample/build.gradle
@@ -0,0 +1,96 @@
+plugins {
+  id("com.android.application")
+  id("org.jetbrains.kotlin.android")
+  // Required to run obfuscated instrumentation tests:
+  // ./gradlew leakcanary-android-sample:connectedCheck -Pminify
+  id("com.slack.keeper")
+}
+
+keeper {
+  variantFilter {
+    setIgnore(!project.hasProperty('minify'))
+  }
+}
+
+dependencies {
+  debugImplementation projects.leakcanaryAndroid
+  // debugImplementation projects.leakcanaryAndroidStartup
+
+  // Uncomment to use the :leakcanary process
+  // debugImplementation projects.leakcanaryAndroidProcess
+  releaseImplementation projects.leakcanaryAndroidRelease
+  // Optional
+  releaseImplementation projects.leakcanaryObjectWatcherAndroid
+
+  implementation libs.kotlin.stdlib
+  // Uncomment to use WorkManager
+  // implementation libs.androidX.work.runtime
+
+  testImplementation libs.junit
+  testImplementation libs.robolectric
+
+  androidTestImplementation projects.leakcanaryAndroidInstrumentation
+  androidTestImplementation libs.androidX.test.espresso
+  androidTestImplementation libs.androidX.test.rules
+  androidTestImplementation libs.androidX.test.runner
+  androidTestImplementation libs.androidX.test.junit
+  androidTestImplementation libs.androidX.test.junitKtx
+  androidTestUtil libs.androidX.test.orchestrator
+}
+
+android {
+  compileSdk versions.compileSdk
+
+  compileOptions {
+    sourceCompatibility JavaVersion.VERSION_1_8
+    targetCompatibility JavaVersion.VERSION_1_8
+  }
+
+  defaultConfig {
+    applicationId "com.example.leakcanary"
+    minSdk 16
+    targetSdk versions.compileSdk
+
+    versionCode 1
+    versionName "1.0"
+
+    testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+
+    // Run ./gradlew leakcanary-android-sample:connectedCheck -Porchestrator
+    if (project.hasProperty('orchestrator')) {
+      testInstrumentationRunnerArguments clearPackageData: 'true'
+      testOptions {
+        execution 'ANDROIDX_TEST_ORCHESTRATOR'
+      }
+    }
+  }
+
+  buildTypes {
+    // Build with ./gradlew leakcanary-android-sample:installDebug -Pminify
+    if (project.hasProperty('minify')) {
+      debug {
+        minifyEnabled true
+        proguardFiles getDefaultProguardFile('proguard-android-optimize.txt')
+      }
+    } else {
+      debug
+    }
+    release {
+      signingConfig signingConfigs.debug
+    }
+  }
+
+  dexOptions {
+    dexInProcess false
+  }
+
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+  }
+
+  testOptions {
+    unitTests {
+      includeAndroidResources = true
+    }
+  }
+}
diff --git a/leakcanary-android-sample/src/androidTest/AndroidManifest.xml b/leakcanary-android-sample/src/androidTest/AndroidManifest.xml
new file mode 100644
index 00000000..d23bb44d
--- /dev/null
+++ b/leakcanary-android-sample/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest
+    package="com.squareup.leakcanary.instrumentation.test">
+</manifest>
diff --git a/leakcanary-android-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt b/leakcanary-android-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
new file mode 100644
index 00000000..bcbd7962
--- /dev/null
+++ b/leakcanary-android-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
@@ -0,0 +1,43 @@
+package leakcanary.tests
+
+import androidx.test.ext.junit.rules.ActivityScenarioRule
+import com.example.leakcanary.MainActivity
+import leakcanary.DetectLeaksAfterTestSuccess
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.RuleChain
+
+/**
+ * This UI test looks like it should succeed, but it will actually fail because
+ * it triggers a leak.
+ *
+ * Run this test with:
+ *
+ * ./gradlew leakcanary-android-sample:connectedCheck
+ *
+ * Why is this class named "TuPeuxPasTest"?
+ *
+ * This test fails, intentionally. In French, "Tu peux pas test" could mean "you cannot test"
+ * written with poor grammar. Except, that's not what it means.
+ * If you're curious, interested in French and have time to waste:
+ * https://www.youtube.com/watch?v=DZZpbmAc-0A
+ * https://www.youtube.com/watch?v=nHeAA6X-XUQ
+ */
+class TuPeuxPasTest {
+
+  private val activityRule = ActivityScenarioRule(MainActivity::class.java)
+
+  @get:Rule
+  val rules = RuleChain.outerRule(DetectLeaksAfterTestSuccess()).around(activityRule)!!
+
+  @Test
+  fun activityLeakingAfterTest() {
+    activityRule.scenario.onActivity { activity ->
+      leakedObjects += activity
+    }
+  }
+
+  companion object {
+    val leakedObjects = mutableListOf<Any>()
+  }
+}
diff --git a/leakcanary-android-sample/src/main/AndroidManifest.xml b/leakcanary-android-sample/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..2bc6abad
--- /dev/null
+++ b/leakcanary-android-sample/src/main/AndroidManifest.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.example.leakcanary"
+    >
+
+  <!-- Features required to run on Android TV -->
+  <uses-feature android:name="android.hardware.touchscreen" android:required="false" />
+  <uses-feature android:name="android.software.leanback" android:required="false" />
+
+  <application
+      android:name=".ExampleApplication"
+      android:allowBackup="false"
+      android:icon="@mipmap/ic_launcher"
+      android:label="@string/app_name"
+      >
+    <activity
+        android:name=".MainActivity"
+        android:banner="@drawable/leak_canary_sample_icon"
+        android:exported="true">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+
+        <category android:name="android.intent.category.LAUNCHER"/>
+        <category android:name="android.intent.category.DEFAULT"/>
+        <category android:name="android.intent.category.LEANBACK_LAUNCHER"/>
+      </intent-filter>
+    </activity>
+    <service
+        android:name=".LeakingService"
+        android:exported="false"/>
+  </application>
+</manifest>
diff --git a/leakcanary-android-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt b/leakcanary-android-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
new file mode 100644
index 00000000..06799a80
--- /dev/null
+++ b/leakcanary-android-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.leakcanary
+
+import android.app.Application
+import android.app.Dialog
+import android.app.Service
+import android.os.StrictMode
+import android.view.View
+
+open class ExampleApplication : Application() {
+  val leakedViews = mutableListOf<View>()
+  val leakedDialogs = mutableListOf<Dialog>()
+  val leakedServices = mutableListOf<Service>()
+
+  override fun onCreate() {
+    super.onCreate()
+    enabledStrictMode()
+  }
+
+  private fun enabledStrictMode() {
+    StrictMode.setThreadPolicy(
+      StrictMode.ThreadPolicy.Builder()
+        .detectAll()
+        .penaltyLog()
+        .penaltyDeath()
+        .build()
+    )
+  }
+}
diff --git a/leakcanary-android-sample/src/main/java/com/example/leakcanary/LeakingService.kt b/leakcanary-android-sample/src/main/java/com/example/leakcanary/LeakingService.kt
new file mode 100644
index 00000000..96b827fc
--- /dev/null
+++ b/leakcanary-android-sample/src/main/java/com/example/leakcanary/LeakingService.kt
@@ -0,0 +1,18 @@
+package com.example.leakcanary
+
+import android.app.Service
+import android.content.Intent
+import android.os.IBinder
+
+class LeakingService : Service() {
+
+  override fun onCreate() {
+    super.onCreate()
+    (application as ExampleApplication).leakedServices += this
+    stopSelf()
+  }
+
+  override fun onBind(intent: Intent?): IBinder? {
+    return null
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-sample/src/main/java/com/example/leakcanary/LeakingSingleton.kt b/leakcanary-android-sample/src/main/java/com/example/leakcanary/LeakingSingleton.kt
new file mode 100644
index 00000000..9ebe1e19
--- /dev/null
+++ b/leakcanary-android-sample/src/main/java/com/example/leakcanary/LeakingSingleton.kt
@@ -0,0 +1,7 @@
+package com.example.leakcanary
+
+import android.view.View
+
+object LeakingSingleton {
+  val leakedViews = mutableListOf<View>()
+}
\ No newline at end of file
diff --git a/leakcanary-android-sample/src/main/java/com/example/leakcanary/LeakingThread.kt b/leakcanary-android-sample/src/main/java/com/example/leakcanary/LeakingThread.kt
new file mode 100644
index 00000000..24138036
--- /dev/null
+++ b/leakcanary-android-sample/src/main/java/com/example/leakcanary/LeakingThread.kt
@@ -0,0 +1,24 @@
+package com.example.leakcanary
+
+import android.view.View
+
+class LeakingThread : Thread() {
+
+  val leakedViews = mutableListOf<View>()
+
+  init {
+    name = "Leaking thread"
+    start()
+  }
+
+  override fun run() {
+    synchronized(obj) {
+      obj.wait()
+    }
+  }
+
+  companion object {
+    private val obj = Object()
+    val thread = LeakingThread()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-sample/src/main/java/com/example/leakcanary/MainActivity.kt b/leakcanary-android-sample/src/main/java/com/example/leakcanary/MainActivity.kt
new file mode 100644
index 00000000..1fe46052
--- /dev/null
+++ b/leakcanary-android-sample/src/main/java/com/example/leakcanary/MainActivity.kt
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.leakcanary
+
+import android.animation.ObjectAnimator
+import android.animation.ValueAnimator
+import android.app.Activity
+import android.app.AlertDialog
+import android.content.BroadcastReceiver
+import android.content.Context
+import android.content.Intent
+import android.content.IntentFilter
+import android.os.Build
+import android.os.Bundle
+import android.os.Handler
+import android.os.Looper
+import android.os.SystemClock
+import android.view.View
+import android.widget.Button
+import java.util.concurrent.atomic.AtomicReference
+import kotlin.concurrent.thread
+import kotlin.random.Random
+import leakcanary.AppWatcher
+
+class MainActivity : Activity() {
+
+  private var leakyReceiver = false
+
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+    setContentView(R.layout.main_activity)
+
+    val app = application as ExampleApplication
+    findViewById<Button>(R.id.recreate_activity_button).setOnClickListener { recreate() }
+    findViewById<Button>(R.id.leak_activity_button).setOnClickListener {
+      val leakedView = findViewById<View>(R.id.helper_text)
+      when (Random.nextInt(4)) {
+        // Leak from application class
+        0 -> app.leakedViews.add(leakedView)
+        // Leak from Kotlin object singleton
+        1 -> LeakingSingleton.leakedViews.add(leakedView)
+        2 -> {
+          // Leak from local variable on thread
+          val ref = AtomicReference(this)
+          thread(name = "Leaking local variables") {
+            val activity = ref.get()
+            ref.set(null)
+            while (true) {
+              print(activity)
+              SystemClock.sleep(1000)
+            }
+          }
+        }
+        // Leak from thread fields
+        else -> LeakingThread.thread.leakedViews.add(leakedView)
+      }
+    }
+    findViewById<Button>(R.id.show_dialog_button).setOnClickListener {
+      AlertDialog.Builder(this)
+        .setTitle("Leaky dialog")
+        .setPositiveButton("Dismiss and leak dialog") { dialog, _ ->
+          app.leakedDialogs += dialog as AlertDialog
+        }
+        .show()
+    }
+    findViewById<Button>(R.id.start_service_button).setOnClickListener {
+      startService(Intent(this, LeakingService::class.java))
+    }
+    findViewById<Button>(R.id.leak_receiver_button).setOnClickListener {
+      leakyReceiver = true
+      recreate()
+    }
+    findViewById<Button>(R.id.message_leak_button).setOnClickListener {
+      val leaky = Any()
+      AppWatcher.objectWatcher.expectWeaklyReachable(leaky, "Repeated Message")
+      @Suppress("unused")
+      class LeakyReschedulingRunnable(private val leaky: Any) : Runnable {
+        private val handler = Handler(Looper.getMainLooper())
+        override fun run() {
+          handler.postDelayed(this, 1000)
+        }
+      }
+      LeakyReschedulingRunnable(leaky).run()
+    }
+    findViewById<Button>(R.id.infinite_animator).setOnClickListener { view ->
+      ObjectAnimator.ofFloat(view, View.ALPHA, 0.1f, 0.2f).apply {
+        duration = 100
+        repeatMode = ValueAnimator.REVERSE
+        repeatCount = ValueAnimator.INFINITE
+        start()
+      }
+    }
+    findViewById<Button>(R.id.finish_activity).setOnClickListener { view ->
+      finish()
+    }
+  }
+
+  class NoOpBroadcastReceiver : BroadcastReceiver() {
+    override fun onReceive(
+      context: Context,
+      intent: Intent
+    ) = Unit
+  }
+
+  override fun onDestroy() {
+    super.onDestroy()
+    if (leakyReceiver) {
+      Handler().postDelayed({
+        if (Build.VERSION.SDK_INT >= 33) {
+          val flags = Context.RECEIVER_EXPORTED
+          application.registerReceiver(NoOpBroadcastReceiver(), IntentFilter(), flags)
+        } else {
+          application.registerReceiver(NoOpBroadcastReceiver(), IntentFilter())
+        }
+      }, 500)
+    }
+  }
+}
diff --git a/leakcanary-android-sample/src/main/res/drawable/leak_canary_sample_icon.png b/leakcanary-android-sample/src/main/res/drawable/leak_canary_sample_icon.png
new file mode 100644
index 00000000..da816d00
Binary files /dev/null and b/leakcanary-android-sample/src/main/res/drawable/leak_canary_sample_icon.png differ
diff --git a/leakcanary-android-sample/src/main/res/layout/main_activity.xml b/leakcanary-android-sample/src/main/res/layout/main_activity.xml
new file mode 100644
index 00000000..70c5dd2b
--- /dev/null
+++ b/leakcanary-android-sample/src/main/res/layout/main_activity.xml
@@ -0,0 +1,89 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:layout_margin="16dp"
+    >
+
+  <TextView
+      android:id="@+id/helper_text"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:layout_marginBottom="16dp"
+      android:text="@string/helper_text"
+      />
+  <Button
+      android:id="@+id/recreate_activity_button"
+      android:layout_width="wrap_content"
+      android:layout_gravity="center"
+      android:layout_height="wrap_content"
+      android:text="Recreate Activity"
+      />
+  <Button
+      android:id="@+id/leak_activity_button"
+      android:layout_width="wrap_content"
+      android:layout_gravity="center"
+      android:layout_height="wrap_content"
+      android:text="Leak Activity"
+      />
+  <Button
+      android:id="@+id/show_dialog_button"
+      android:layout_width="wrap_content"
+      android:layout_gravity="center"
+      android:layout_height="wrap_content"
+      android:text="Show dialog"
+      />
+  <Button
+      android:id="@+id/start_service_button"
+      android:layout_width="wrap_content"
+      android:layout_gravity="center"
+      android:layout_height="wrap_content"
+      android:text="@string/start_service_button_text"
+      />
+  <Button
+      android:id="@+id/leak_receiver_button"
+      android:layout_width="wrap_content"
+      android:layout_gravity="center"
+      android:layout_height="wrap_content"
+      android:text="Create &amp; leak Receiver"
+      />
+  <Button
+    android:id="@+id/message_leak_button"
+    android:layout_width="wrap_content"
+    android:layout_gravity="center"
+    android:layout_height="wrap_content"
+    android:text="Create Message leak"
+    />
+  <Button
+    android:id="@+id/infinite_animator"
+    android:layout_width="wrap_content"
+    android:layout_gravity="center"
+    android:layout_height="wrap_content"
+    android:text="Create animator leak"
+    />
+  <Button
+    android:id="@+id/finish_activity"
+    android:layout_width="wrap_content"
+    android:layout_gravity="center"
+    android:layout_height="wrap_content"
+    android:text="Finish"
+    />
+
+</LinearLayout>
diff --git a/leakcanary-android-sample/src/main/res/mipmap-hdpi/ic_launcher.png b/leakcanary-android-sample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 00000000..97aa0b79
Binary files /dev/null and b/leakcanary-android-sample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/leakcanary-android-sample/src/main/res/mipmap-mdpi/ic_launcher.png b/leakcanary-android-sample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 00000000..77a7ef0c
Binary files /dev/null and b/leakcanary-android-sample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/leakcanary-android-sample/src/main/res/mipmap-xhdpi/ic_launcher.png b/leakcanary-android-sample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 00000000..4f046561
Binary files /dev/null and b/leakcanary-android-sample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/leakcanary-android-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/leakcanary-android-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 00000000..f8c5988e
Binary files /dev/null and b/leakcanary-android-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/leakcanary-android-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/leakcanary-android-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 00000000..42beb64b
Binary files /dev/null and b/leakcanary-android-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/leakcanary-android-sample/src/main/res/values/strings.xml b/leakcanary-android-sample/src/main/res/values/strings.xml
new file mode 100644
index 00000000..740f2545
--- /dev/null
+++ b/leakcanary-android-sample/src/main/res/values/strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:ignore="MissingTranslation">
+  <string name="app_name">Example App</string>
+  <string name="helper_text">Press this button or rotate the screen to create leaks. Pressing back or creating 5 leaks will trigger a heap dump.</string>
+  <string name="start_service_button_text">Create &amp; Leak Service</string>
+</resources>
diff --git a/leakcanary-android-sample/src/release/AndroidManifest.xml b/leakcanary-android-sample/src/release/AndroidManifest.xml
new file mode 100644
index 00000000..367e832a
--- /dev/null
+++ b/leakcanary-android-sample/src/release/AndroidManifest.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.example.leakcanary">
+  <application
+      tools:replace="android:name"
+      android:name=".ReleaseExampleApplication" />
+</manifest>
diff --git a/leakcanary-android-sample/src/release/java/com/example/leakcanary/ReleaseExampleApplication.kt b/leakcanary-android-sample/src/release/java/com/example/leakcanary/ReleaseExampleApplication.kt
new file mode 100644
index 00000000..8e6ce6aa
--- /dev/null
+++ b/leakcanary-android-sample/src/release/java/com/example/leakcanary/ReleaseExampleApplication.kt
@@ -0,0 +1,56 @@
+package com.example.leakcanary
+
+import android.os.Process.THREAD_PRIORITY_BACKGROUND
+import android.util.Log
+import leakcanary.BackgroundTrigger
+import leakcanary.HeapAnalysisClient
+import leakcanary.HeapAnalysisConfig
+import leakcanary.HeapAnalysisJob.Result
+import leakcanary.LogcatSharkLog
+import leakcanary.LogcatSharkLog.Companion
+import leakcanary.ScreenOffTrigger
+import shark.SharkLog
+import shark.SharkLog.Logger
+import java.util.concurrent.Executors
+import kotlin.concurrent.thread
+
+class ReleaseExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    // Useful to debug in release builds. Don't use in real builds.
+    LogcatSharkLog.install()
+
+    val analysisClient = HeapAnalysisClient(
+      heapDumpDirectoryProvider = { cacheDir },
+      config = HeapAnalysisConfig(),
+      interceptors = HeapAnalysisClient.defaultInterceptors(this)
+    )
+
+    val analysisExecutor = Executors.newSingleThreadExecutor {
+      thread(start = false, name = "Heap analysis executor") {
+        android.os.Process.setThreadPriority(THREAD_PRIORITY_BACKGROUND)
+        it.run()
+      }
+    }
+    analysisExecutor.execute {
+      analysisClient.deleteHeapDumpFiles()
+    }
+    val analysisCallback: (Result) -> Unit = { result ->
+      SharkLog.d { "$result" }
+    }
+    BackgroundTrigger(
+      application = this,
+      analysisClient = analysisClient,
+      analysisExecutor = analysisExecutor,
+      analysisCallback = analysisCallback
+    ).start()
+
+    ScreenOffTrigger(
+      application = this,
+      analysisClient = analysisClient,
+      analysisExecutor = analysisExecutor,
+      analysisCallback = analysisCallback
+    ).start()
+  }
+}
diff --git a/leakcanary-android-startup/build.gradle b/leakcanary-android-startup/build.gradle
new file mode 100644
index 00000000..f4551d2e
--- /dev/null
+++ b/leakcanary-android-startup/build.gradle
@@ -0,0 +1,27 @@
+plugins {
+  id("com.android.library")
+  id("org.jetbrains.kotlin.android")
+  id("com.vanniktech.maven.publish")
+}
+
+dependencies {
+  api projects.leakcanaryAndroidCore
+  // AppWatcher AndroidX Startup installer
+  implementation projects.leakcanaryObjectWatcherAndroidStartup
+  // Plumber AndroidX Startup installer
+  implementation projects.plumberAndroidStartup
+}
+
+android {
+  compileSdk versions.compileSdk
+  defaultConfig {
+    minSdk versions.minSdk
+  }
+  buildFeatures.buildConfig = false
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    // junit references java.lang.management
+    ignore 'InvalidPackage'
+    checkOnly 'Interoperability'
+  }
+}
diff --git a/leakcanary-android-startup/gradle.properties b/leakcanary-android-startup/gradle.properties
new file mode 100644
index 00000000..217181ea
--- /dev/null
+++ b/leakcanary-android-startup/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-android-startup
+POM_NAME=AndroidX Startup config for LeakCanary Android
+POM_PACKAGING=aar
diff --git a/leakcanary-android-startup/src/main/AndroidManifest.xml b/leakcanary-android-startup/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..570d5e0c
--- /dev/null
+++ b/leakcanary-android-startup/src/main/AndroidManifest.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="com.squareup.leakcanary.startup" />
diff --git a/leakcanary-android-utils/api/leakcanary-android-utils.api b/leakcanary-android-utils/api/leakcanary-android-utils.api
new file mode 100644
index 00000000..f57810b4
--- /dev/null
+++ b/leakcanary-android-utils/api/leakcanary-android-utils.api
@@ -0,0 +1,11 @@
+public final class leakcanary/LogcatSharkLog : shark/SharkLog$Logger {
+	public static final field Companion Lleakcanary/LogcatSharkLog$Companion;
+	public fun <init> ()V
+	public fun d (Ljava/lang/String;)V
+	public fun d (Ljava/lang/Throwable;Ljava/lang/String;)V
+}
+
+public final class leakcanary/LogcatSharkLog$Companion {
+	public final fun install ()V
+}
+
diff --git a/leakcanary-android-utils/build.gradle b/leakcanary-android-utils/build.gradle
new file mode 100644
index 00000000..2ad961f3
--- /dev/null
+++ b/leakcanary-android-utils/build.gradle
@@ -0,0 +1,24 @@
+plugins {
+  id("com.android.library")
+  id("org.jetbrains.kotlin.android")
+  id("com.vanniktech.maven.publish")
+}
+
+dependencies {
+  api projects.sharkLog
+
+  implementation libs.kotlin.stdlib
+}
+
+android {
+  compileSdk versions.compileSdk
+  defaultConfig {
+    minSdk versions.minSdk
+  }
+  buildFeatures.buildConfig = false
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
+    checkOnly 'Interoperability'
+  }
+}
diff --git a/leakcanary-android-utils/gradle.properties b/leakcanary-android-utils/gradle.properties
new file mode 100644
index 00000000..77779b2f
--- /dev/null
+++ b/leakcanary-android-utils/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-android-utils
+POM_NAME=LeakCanary Android Utils
+POM_PACKAGING=aar
diff --git a/leakcanary-android-utils/src/main/AndroidManifest.xml b/leakcanary-android-utils/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..7699f1d2
--- /dev/null
+++ b/leakcanary-android-utils/src/main/AndroidManifest.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="com.squareup.leakcanary.utils" />
diff --git a/leakcanary-android-utils/src/main/java/leakcanary/LogcatSharkLog.kt b/leakcanary-android-utils/src/main/java/leakcanary/LogcatSharkLog.kt
new file mode 100644
index 00000000..cb76ce69
--- /dev/null
+++ b/leakcanary-android-utils/src/main/java/leakcanary/LogcatSharkLog.kt
@@ -0,0 +1,31 @@
+package leakcanary
+
+import android.util.Log
+import shark.SharkLog
+import shark.SharkLog.Logger
+
+class LogcatSharkLog : Logger {
+
+  override fun d(message: String) {
+    if (message.length < 4000) {
+      Log.d("LeakCanary", message)
+    } else {
+      message.lines().forEach { line ->
+        Log.d("LeakCanary", line)
+      }
+    }
+  }
+
+  override fun d(
+    throwable: Throwable,
+    message: String
+  ) {
+    d("$message\n${Log.getStackTraceString(throwable)}")
+  }
+
+  companion object {
+    fun install() {
+      SharkLog.logger = LogcatSharkLog()
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-utils/src/main/java/leakcanary/internal/Handlers.kt b/leakcanary-android-utils/src/main/java/leakcanary/internal/Handlers.kt
new file mode 100644
index 00000000..9e6b6a31
--- /dev/null
+++ b/leakcanary-android-utils/src/main/java/leakcanary/internal/Handlers.kt
@@ -0,0 +1,20 @@
+package leakcanary.internal
+
+import android.os.Handler
+import android.os.Looper
+
+internal val mainHandler by lazy { Handler(Looper.getMainLooper()) }
+
+internal val isMainThread: Boolean get() = Looper.getMainLooper().thread === Thread.currentThread()
+
+internal fun checkMainThread() {
+  check(isMainThread) {
+    "Should be called from the main thread, not ${Thread.currentThread()}"
+  }
+}
+
+internal fun checkNotMainThread() {
+  check(!isMainThread) {
+    "Should not be called from the main thread"
+  }
+}
diff --git a/leakcanary-android-utils/src/main/java/leakcanary/internal/Objects.kt b/leakcanary-android-utils/src/main/java/leakcanary/internal/Objects.kt
new file mode 100644
index 00000000..f7afa165
--- /dev/null
+++ b/leakcanary-android-utils/src/main/java/leakcanary/internal/Objects.kt
@@ -0,0 +1,15 @@
+package leakcanary.internal
+
+import java.lang.reflect.InvocationHandler
+import java.lang.reflect.Proxy
+
+internal inline fun <reified T : Any> noOpDelegate(): T {
+  val javaClass = T::class.java
+  return Proxy.newProxyInstance(
+    javaClass.classLoader, arrayOf(javaClass), NO_OP_HANDLER
+  ) as T
+}
+
+private val NO_OP_HANDLER = InvocationHandler { _, _, _ ->
+  // no op
+}
\ No newline at end of file
diff --git a/leakcanary-android-utils/src/main/java/leakcanary/internal/Timing.kt b/leakcanary-android-utils/src/main/java/leakcanary/internal/Timing.kt
new file mode 100644
index 00000000..ec693a3a
--- /dev/null
+++ b/leakcanary-android-utils/src/main/java/leakcanary/internal/Timing.kt
@@ -0,0 +1,12 @@
+package leakcanary.internal
+
+import android.os.SystemClock
+
+/**
+ * Executes the given [block] and returns elapsed time in milliseconds using [SystemClock.uptimeMillis]
+ */
+internal inline fun measureDurationMillis(block: () -> Unit): Long {
+  val start = SystemClock.uptimeMillis()
+  block()
+  return SystemClock.uptimeMillis() - start
+}
diff --git a/leakcanary-android/build.gradle b/leakcanary-android/build.gradle
new file mode 100644
index 00000000..bc238652
--- /dev/null
+++ b/leakcanary-android/build.gradle
@@ -0,0 +1,35 @@
+plugins {
+  id("com.android.library")
+  id("org.jetbrains.kotlin.android")
+  id("com.vanniktech.maven.publish")
+}
+
+dependencies {
+  api projects.leakcanaryAndroidCore
+  // AppWatcher auto installer
+  api projects.leakcanaryObjectWatcherAndroid
+  // Plumber auto installer
+  implementation projects.plumberAndroid
+  implementation libs.kotlin.stdlib
+
+  androidTestImplementation libs.androidX.test.espresso
+  androidTestImplementation libs.androidX.test.rules
+  androidTestImplementation libs.androidX.test.runner
+  androidTestImplementation libs.assertjCore
+  androidTestImplementation projects.sharkHprofTest
+}
+
+android {
+  compileSdk versions.compileSdk
+  defaultConfig {
+    minSdk versions.minSdk
+    testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+  }
+  buildFeatures.buildConfig = false
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    // junit references java.lang.management
+    ignore 'InvalidPackage'
+    checkOnly 'Interoperability'
+  }
+}
diff --git a/leakcanary-android/gradle.properties b/leakcanary-android/gradle.properties
new file mode 100644
index 00000000..e40174ac
--- /dev/null
+++ b/leakcanary-android/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-android
+POM_NAME=LeakCanary Android
+POM_PACKAGING=aar
diff --git a/leakcanary-android/src/androidTest/java/leakcanary/LeakActivityTest.kt b/leakcanary-android/src/androidTest/java/leakcanary/LeakActivityTest.kt
new file mode 100644
index 00000000..9d7505ee
--- /dev/null
+++ b/leakcanary-android/src/androidTest/java/leakcanary/LeakActivityTest.kt
@@ -0,0 +1,96 @@
+package leakcanary
+
+import android.app.Activity
+import android.content.Intent
+import android.net.Uri
+import androidx.test.espresso.Espresso.onView
+import androidx.test.espresso.action.ViewActions.click
+import androidx.test.espresso.assertion.ViewAssertions.matches
+import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
+import androidx.test.espresso.matcher.ViewMatchers.withText
+import androidx.test.rule.ActivityTestRule
+import java.io.File
+import java.util.concurrent.CountDownLatch
+import java.util.concurrent.TimeUnit.SECONDS
+import leakcanary.EventListener.Event.HeapAnalysisDone
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.HprofWriterHelper
+import shark.ValueHolder.IntHolder
+import shark.dumpToBytes
+
+internal class LeakActivityTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+
+  @Suppress("UNCHECKED_CAST")
+  // This class is internal but ActivityTestRule requires being passed in the real class.
+  private val leakActivityClass = Class.forName("leakcanary.internal.activity.LeakActivity")
+    as Class<Activity>
+
+  @get:Rule
+  val activityTestRule = object : ActivityTestRule<Activity>(leakActivityClass, false, false) {
+    override fun getActivityIntent(): Intent {
+      return LeakCanary.newLeakDisplayActivityIntent()
+    }
+  }
+
+  @Test
+  fun importHeapDumpFile() = tryAndRestoreConfig {
+    val latch = CountDownLatch(1)
+    LeakCanary.config = LeakCanary.config.run {
+      copy(eventListeners = eventListeners + EventListener { event ->
+        if (event is HeapAnalysisDone<*>) {
+          latch.countDown()
+        }
+      })
+    }
+    val hprof = writeHeapDump {
+      "Holder" clazz {
+        staticField["leak"] = "com.example.Leaking" watchedInstance {}
+      }
+    }
+    val intent = Intent(Intent.ACTION_VIEW, Uri.fromFile(hprof))
+    activityTestRule.launchActivity(intent)
+    require(latch.await(5, SECONDS)) {
+      "Heap analysis not done within 5 seconds of starting import"
+    }
+    onView(withText("1 Heap Dump")).check(matches(isDisplayed()))
+    onView(withText("1 Distinct Leak")).perform(click())
+    onView(withText("Holder.leak")).check(matches(isDisplayed()))
+  }
+
+  private fun writeHeapDump(block: HprofWriterHelper.() -> Unit): File {
+    val hprofBytes = dumpToBytes {
+      "android.os.Build" clazz {
+        staticField["MANUFACTURER"] = string("Samsing")
+        staticField["ID"] = string("M4-rc20")
+      }
+      "android.os.Build\$VERSION" clazz {
+        staticField["SDK_INT"] = IntHolder(47)
+      }
+      block()
+    }
+    return testFolder.newFile("temp.hprof").apply {
+      writeBytes(hprofBytes)
+      require(exists()) {
+        "$this does not exist"
+      }
+      require(length().toInt() == hprofBytes.size) {
+        "$this has size ${length()} instead of expected ${hprofBytes.size}"
+      }
+    }
+  }
+
+  private fun tryAndRestoreConfig(block: () -> Unit) {
+    val original = LeakCanary.config
+    try {
+      block()
+    } finally {
+      LeakCanary.config = original
+    }
+  }
+
+}
diff --git a/leakcanary-android/src/main/AndroidManifest.xml b/leakcanary-android/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..11070e76
--- /dev/null
+++ b/leakcanary-android/src/main/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest package="com.squareup.leakcanary" />
diff --git a/leakcanary-deobfuscation-gradle-plugin/api/leakcanary-deobfuscation-gradle-plugin.api b/leakcanary-deobfuscation-gradle-plugin/api/leakcanary-deobfuscation-gradle-plugin.api
new file mode 100644
index 00000000..8601f432
--- /dev/null
+++ b/leakcanary-deobfuscation-gradle-plugin/api/leakcanary-deobfuscation-gradle-plugin.api
@@ -0,0 +1,22 @@
+public abstract class com/squareup/leakcanary/deobfuscation/CopyObfuscationMappingFileTask : org/gradle/api/DefaultTask {
+	public fun <init> ()V
+	public final fun copyObfuscationMappingFile ()V
+	public final fun getLeakCanaryAssetsOutputFile ()Ljava/io/File;
+	public abstract fun getMappingFile ()Lorg/gradle/api/provider/Property;
+	public abstract fun getMergeAssetsDirectory ()Lorg/gradle/api/provider/Property;
+	public final fun getVariantName ()Ljava/lang/String;
+	public final fun setVariantName (Ljava/lang/String;)V
+}
+
+public class com/squareup/leakcanary/deobfuscation/LeakCanaryDeobfuscationExtension {
+	public fun <init> ()V
+	public final fun getFilterObfuscatedVariants ()Lkotlin/jvm/functions/Function1;
+	public final fun setFilterObfuscatedVariants (Lkotlin/jvm/functions/Function1;)V
+}
+
+public final class com/squareup/leakcanary/deobfuscation/LeakCanaryLeakDeobfuscationPlugin : org/gradle/api/Plugin {
+	public fun <init> ()V
+	public synthetic fun apply (Ljava/lang/Object;)V
+	public fun apply (Lorg/gradle/api/Project;)V
+}
+
diff --git a/leakcanary-deobfuscation-gradle-plugin/build.gradle b/leakcanary-deobfuscation-gradle-plugin/build.gradle
new file mode 100644
index 00000000..bcbcc7e5
--- /dev/null
+++ b/leakcanary-deobfuscation-gradle-plugin/build.gradle
@@ -0,0 +1,32 @@
+plugins {
+  id("org.jetbrains.kotlin.jvm")
+  id("java-gradle-plugin")
+  id("com.vanniktech.maven.publish")
+}
+
+gradlePlugin {
+  plugins {
+    leakCanary {
+      id = 'com.squareup.leakcanary.deobfuscation'
+      implementationClass =
+          'com.squareup.leakcanary.deobfuscation.LeakCanaryLeakDeobfuscationPlugin'
+    }
+  }
+
+  sourceSets {
+    test.java.srcDirs += 'src/test/test-project/src/main/java'
+  }
+}
+
+dependencies {
+  implementation libs.kotlin.stdlib
+  implementation libs.gradlePlugin.kotlin
+  implementation libs.gradlePlugin.android
+  compileOnly gradleApi()
+
+  testImplementation libs.assertjCore
+  testImplementation libs.junit
+}
+
+sourceCompatibility = JavaVersion.VERSION_1_8
+targetCompatibility = JavaVersion.VERSION_1_8
diff --git a/leakcanary-deobfuscation-gradle-plugin/gradle.properties b/leakcanary-deobfuscation-gradle-plugin/gradle.properties
new file mode 100644
index 00000000..8fdb046c
--- /dev/null
+++ b/leakcanary-deobfuscation-gradle-plugin/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-deobfuscation-gradle-plugin
+POM_NAME=LeakCanary Deobfuscation Plugin
+POM_PACKAGING=jar
\ No newline at end of file
diff --git a/leakcanary-deobfuscation-gradle-plugin/src/main/java/com/squareup/leakcanary/deobfuscation/CopyObfuscationMappingFileTask.kt b/leakcanary-deobfuscation-gradle-plugin/src/main/java/com/squareup/leakcanary/deobfuscation/CopyObfuscationMappingFileTask.kt
new file mode 100644
index 00000000..f90238e8
--- /dev/null
+++ b/leakcanary-deobfuscation-gradle-plugin/src/main/java/com/squareup/leakcanary/deobfuscation/CopyObfuscationMappingFileTask.kt
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.deobfuscation
+
+import java.io.File
+import org.gradle.api.DefaultTask
+import org.gradle.api.GradleException
+import org.gradle.api.provider.Property
+import org.gradle.api.tasks.CacheableTask
+import org.gradle.api.tasks.Input
+import org.gradle.api.tasks.InputDirectory
+import org.gradle.api.tasks.InputFile
+import org.gradle.api.tasks.OutputFile
+import org.gradle.api.tasks.PathSensitive
+import org.gradle.api.tasks.PathSensitivity
+import org.gradle.api.tasks.TaskAction
+
+@CacheableTask
+abstract class CopyObfuscationMappingFileTask : DefaultTask() {
+
+  @Input
+  var variantName: String = ""
+
+  @get:InputFile
+  @get:PathSensitive(PathSensitivity.RELATIVE)
+  abstract val mappingFile: Property<File?>
+
+  @get:InputDirectory
+  @get:PathSensitive(PathSensitivity.RELATIVE)
+  abstract val mergeAssetsDirectory: Property<File>
+
+  @get:OutputFile
+  val leakCanaryAssetsOutputFile: File
+    get() = File(mergeAssetsDirectory.orNull, "leakCanaryObfuscationMapping.txt")
+
+  init {
+    description = "Puts obfuscation mapping file in assets directory."
+  }
+
+  @TaskAction
+  fun copyObfuscationMappingFile() {
+    val mapping = validateMappingFile()
+    validateMergeAssetsDir()
+    mapping.copyTo(leakCanaryAssetsOutputFile, overwrite = true)
+  }
+
+  private fun validateMappingFile(): File {
+    val mapping = mappingFile.orNull
+    if (mapping == null || !mapping.exists()) {
+      throw GradleException(
+        """
+        The plugin was configured to be applied to a variant which doesn't define
+        an obfuscation mapping file: make sure that isMinified is true for variant: $variantName.
+        """
+      )
+    }
+    return mapping
+  }
+
+  private fun validateMergeAssetsDir() {
+    mergeAssetsDirectory.orNull?.let { mergeAssetsDir ->
+      if (!mergeAssetsDir.exists()) {
+        val mergeAssetsDirCreated = mergeAssetsDir.mkdirs()
+        if (!mergeAssetsDirCreated) {
+          throw GradleException(
+            "Obfuscation mapping destination dir doesn't exist and it's impossible to create it."
+          )
+        }
+      }
+    } ?: throw GradleException("Obfuscation mapping is null.")
+  }
+}
diff --git a/leakcanary-deobfuscation-gradle-plugin/src/main/java/com/squareup/leakcanary/deobfuscation/LeakCanaryDeobfuscationExtension.kt b/leakcanary-deobfuscation-gradle-plugin/src/main/java/com/squareup/leakcanary/deobfuscation/LeakCanaryDeobfuscationExtension.kt
new file mode 100644
index 00000000..e861a39a
--- /dev/null
+++ b/leakcanary-deobfuscation-gradle-plugin/src/main/java/com/squareup/leakcanary/deobfuscation/LeakCanaryDeobfuscationExtension.kt
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.deobfuscation
+
+import com.android.build.gradle.api.BaseVariant
+
+/**
+ * Extension for the gradle plugin. It allows the user to configure the plugin.
+ */
+open class LeakCanaryDeobfuscationExtension {
+
+  /**
+   * Variant filtering function. It should be overriden to tell LeakCanary for which obfuscated
+   * variants it should copy the mapping file into apk. For example this:
+   * ```kotlin
+   * filterObfuscatedVariants { variant ->
+   *   variant.name == "debug"
+   * }
+   * ```
+   * means that debug variant should be deobfuscated by LeakCanary when displaying leaks.
+   *
+   * Default value is *false* so no variant will have the obfuscation mapping file copied.
+   */
+  var filterObfuscatedVariants: (BaseVariant) -> Boolean = { false }
+}
diff --git a/leakcanary-deobfuscation-gradle-plugin/src/main/java/com/squareup/leakcanary/deobfuscation/LeakCanaryLeakDeobfuscationPlugin.kt b/leakcanary-deobfuscation-gradle-plugin/src/main/java/com/squareup/leakcanary/deobfuscation/LeakCanaryLeakDeobfuscationPlugin.kt
new file mode 100644
index 00000000..9492def4
--- /dev/null
+++ b/leakcanary-deobfuscation-gradle-plugin/src/main/java/com/squareup/leakcanary/deobfuscation/LeakCanaryLeakDeobfuscationPlugin.kt
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.deobfuscation
+
+import com.android.build.gradle.AppExtension
+import com.android.build.gradle.BaseExtension
+import com.android.build.gradle.LibraryExtension
+import com.android.build.gradle.api.ApplicationVariant
+import com.android.build.gradle.api.BaseVariant
+import com.android.build.gradle.api.LibraryVariant
+import org.gradle.api.Action
+import org.gradle.api.DefaultTask
+import org.gradle.api.DomainObjectSet
+import org.gradle.api.GradleException
+import org.gradle.api.Plugin
+import org.gradle.api.Project
+import org.gradle.api.Task
+import org.gradle.api.UnknownTaskException
+import org.gradle.api.plugins.AppliedPlugin
+import org.gradle.api.tasks.TaskProvider
+
+class LeakCanaryLeakDeobfuscationPlugin : Plugin<Project> {
+
+  override fun apply(project: Project) {
+    val leakCanaryPluginAction = Action<AppliedPlugin> {
+      val leakCanaryExtension = createLeakCanaryExtension(project)
+      val variants = findAndroidVariants(project)
+      variants.configureEach { variant ->
+        if (leakCanaryExtension.filterObfuscatedVariants(variant)) {
+          setupTasks(project, variant)
+        }
+      }
+    }
+
+    project.pluginManager.withPlugin("com.android.application", leakCanaryPluginAction)
+    project.pluginManager.withPlugin("com.android.library", leakCanaryPluginAction)
+  }
+
+  private fun findAndroidVariants(project: Project): DomainObjectSet<BaseVariant> {
+    return try {
+      when (val extension = project.extensions.getByType(BaseExtension::class.java)) {
+        is AppExtension -> extension.applicationVariants as DomainObjectSet<BaseVariant>
+        is LibraryExtension -> extension.libraryVariants as DomainObjectSet<BaseVariant>
+        else -> throwNoAndroidPluginException()
+      }
+    } catch (e: Exception) {
+      throwNoAndroidPluginException()
+    }
+  }
+
+  private fun createLeakCanaryExtension(project: Project): LeakCanaryDeobfuscationExtension {
+    return project.extensions.create("leakCanary", LeakCanaryDeobfuscationExtension::class.java)
+  }
+
+  private fun setupTasks(
+    project: Project,
+    variant: BaseVariant
+  ) {
+    val copyObfuscationMappingFileTaskProvider = project.tasks.register(
+      "leakCanaryCopyObfuscationMappingFor${variant.name.capitalize()}",
+      CopyObfuscationMappingFileTask::class.java
+    ) {
+      it.variantName = variant.name
+      it.mappingFile.set(variant.mappingFileProvider.map { files -> files.firstOrNull() })
+      it.mergeAssetsDirectory.set(variant.mergeAssetsProvider.map { folders -> folders.outputDir.get().asFile })
+
+      val mappingGeneratingTaskProvider =
+        findTaskProviderOrNull(
+          project,
+          "transformClassesAndResourcesWithR8For${variant.name.capitalize()}"
+        ) ?: findTaskProviderOrNull(
+          project,
+          "transformClassesAndResourcesWithProguardFor${variant.name.capitalize()}"
+        ) ?: findTaskProviderOrNull(
+          project,
+          "minify${variant.name.capitalize()}WithR8"
+        ) ?: findTaskProviderOrNull(
+          project,
+          "minify${variant.name.capitalize()}WithProguard"
+        ) ?: throwMissingMinifiedVariantException()
+
+      it.dependsOn(mappingGeneratingTaskProvider)
+      it.dependsOn(variant.mergeAssetsProvider)
+    }
+
+    // https://github.com/square/leakcanary/pull/2230#discussion_r772992666
+    findTaskProviderOrNull(
+      project,
+      "compress${variant.name.capitalize()}Assets"
+    )?.configure {
+      it.dependsOn(copyObfuscationMappingFileTaskProvider)
+    }
+
+    getPackageTaskProvider(variant).configure {
+      it.dependsOn(copyObfuscationMappingFileTaskProvider)
+    }
+  }
+
+  private fun findTaskProviderOrNull(
+    project: Project,
+    taskName: String
+  ): TaskProvider<Task>? {
+    return try {
+      project.tasks.named(taskName)
+    } catch (proguardTaskNotFoundException: UnknownTaskException) {
+      null
+    }
+  }
+
+  private fun getPackageTaskProvider(variant: BaseVariant): TaskProvider<out DefaultTask> {
+    return when (variant) {
+      is LibraryVariant -> variant.packageLibraryProvider
+      is ApplicationVariant -> variant.packageApplicationProvider
+      else -> throwNoAndroidPluginException()
+    }
+  }
+
+  private fun throwNoAndroidPluginException(): Nothing {
+    throw GradleException(
+      "LeakCanary deobfuscation plugin can be used only in Android application or library module."
+    )
+  }
+
+  private fun throwMissingMinifiedVariantException(): Nothing {
+    throw GradleException(
+      """
+        LeakCanary deobfuscation plugin couldn't find any variant with minification enabled.
+        Please make sure that there is at least 1 minified variant in your project.
+      """
+    )
+  }
+}
diff --git a/leakcanary-deobfuscation-gradle-plugin/src/test/java/com/squareup/leakcanary/deobfuscation/CopyObfuscationMappingFileTaskTest.kt b/leakcanary-deobfuscation-gradle-plugin/src/test/java/com/squareup/leakcanary/deobfuscation/CopyObfuscationMappingFileTaskTest.kt
new file mode 100644
index 00000000..c2229343
--- /dev/null
+++ b/leakcanary-deobfuscation-gradle-plugin/src/test/java/com/squareup/leakcanary/deobfuscation/CopyObfuscationMappingFileTaskTest.kt
@@ -0,0 +1,83 @@
+package com.squareup.leakcanary.deobfuscation
+
+import org.assertj.core.api.Assertions.assertThat
+import org.assertj.core.api.Assertions.assertThatExceptionOfType
+import org.gradle.api.GradleException
+import org.gradle.testfixtures.ProjectBuilder
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+
+class CopyObfuscationMappingFileTaskTest {
+
+  @get:Rule
+  val tempFolder = TemporaryFolder()
+
+  private val task =
+    ProjectBuilder
+      .builder()
+      .build()
+      .tasks
+      .create(
+        "testCopyObfuscationMappingFileTask",
+        CopyObfuscationMappingFileTask::class.java
+      )
+
+  @Test
+  fun `should throw if mapping file and merge assets dir are not specified`() {
+    assertThatExceptionOfType(GradleException::class.java)
+      .isThrownBy { task.copyObfuscationMappingFile() }
+  }
+
+  @Test
+  fun `should throw if mapping file is not specified`() {
+    task.mergeAssetsDirectory.set(tempFolder.newFolder("mergeAssetsDir"))
+
+    assertThatExceptionOfType(GradleException::class.java)
+      .isThrownBy { task.copyObfuscationMappingFile() }
+  }
+
+  @Test
+  fun `should throw if merge assets dir is not specified`() {
+    task.mappingFile.set(tempFolder.newFile("mapping.txt"))
+
+    assertThatExceptionOfType(GradleException::class.java)
+      .isThrownBy { task.copyObfuscationMappingFile() }
+  }
+
+  @Test
+  fun `existing mapping copied and merge assets dir generated if not exists`() {
+    task.mappingFile.set(tempFolder.newFile("mapping.txt"))
+    task.mergeAssetsDirectory.set(File(tempFolder.root, "mergeAssetsDir"))
+
+    assertThat(task.mergeAssetsDirectory.get().exists()).isFalse()
+
+    task.copyObfuscationMappingFile()
+
+    assertThat(task.mergeAssetsDirectory.get().exists()).isTrue()
+    assertThat(task.leakCanaryAssetsOutputFile.exists()).isTrue()
+  }
+
+  @Test
+  fun `previous mapping overwritten`() {
+    task.mergeAssetsDirectory.set(tempFolder.newFolder("mergeAssetsDir"))
+
+    // create first mapping file
+    task.mappingFile.set(tempFolder.newFile("firstMappingFile.txt")
+      .apply {
+        writeText("firstMappingFile")
+      })
+    task.copyObfuscationMappingFile()
+
+    // create second mapping file
+    task.mappingFile.set(tempFolder.newFile("secondMappingFile.txt")
+      .apply {
+        writeText("secondMappingFile")
+      })
+    task.copyObfuscationMappingFile()
+
+    assertThat(task.leakCanaryAssetsOutputFile.exists()).isTrue()
+    assertThat(task.leakCanaryAssetsOutputFile.readText()).isEqualTo("secondMappingFile")
+  }
+}
diff --git a/leakcanary-deobfuscation-gradle-plugin/src/test/java/com/squareup/leakcanary/deobfuscation/LeakCanaryLeakDeobfuscationPluginTest.kt b/leakcanary-deobfuscation-gradle-plugin/src/test/java/com/squareup/leakcanary/deobfuscation/LeakCanaryLeakDeobfuscationPluginTest.kt
new file mode 100644
index 00000000..7066926e
--- /dev/null
+++ b/leakcanary-deobfuscation-gradle-plugin/src/test/java/com/squareup/leakcanary/deobfuscation/LeakCanaryLeakDeobfuscationPluginTest.kt
@@ -0,0 +1,216 @@
+package com.squareup.leakcanary.deobfuscation
+
+import org.assertj.core.api.Assertions.assertThat
+import org.gradle.testkit.runner.GradleRunner
+import org.gradle.testkit.runner.TaskOutcome.SUCCESS
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+import java.util.zip.ZipFile
+
+class LeakCanaryLeakDeobfuscationPluginTest {
+
+  @get:Rule
+  val tempFolder = TemporaryFolder()
+
+  private lateinit var buildFile: File
+
+  @Before
+  fun setup() {
+    buildFile = tempFolder.newFile("build.gradle")
+
+    val localPropertiesFile = File("../local.properties")
+    if (localPropertiesFile.exists()) {
+      localPropertiesFile.copyTo(File(tempFolder.root, "local.properties"), overwrite = true)
+    } else {
+      System.getenv("ANDROID_HOME")?.let { androidHome ->
+        tempFolder.newFile("local.properties").apply {
+          writeText("sdk.dir=$androidHome")
+        }
+      }
+    }
+
+    File("src/test/test-project").copyRecursively(tempFolder.root)
+
+    val proguardRules = tempFolder.newFile("proguard-rules.pro")
+    proguardRules.writeText(
+      """
+      -keep class com.leakcanary.test.** {*;}
+    """.trimIndent()
+    )
+  }
+
+  @Test
+  fun `leakcanary deobfuscation plugin runs and copies mapping file into the apk assets dir`() {
+    buildFile.writeText(
+      """
+        plugins {
+          id 'com.android.application'
+          id 'com.squareup.leakcanary.deobfuscation'
+        }
+        
+        allprojects {
+          repositories {
+            google()
+            jcenter()
+          }
+        }
+        
+        android {
+          compileSdk 29
+  
+          defaultConfig {
+            minSdk 29
+          }
+  
+          buildTypes {
+            debug {
+              minifyEnabled true
+              proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+            }
+          }
+        }
+        
+        leakCanary {
+          filterObfuscatedVariants { variant ->
+            variant.name == "debug"
+          }
+        }
+      """.trimIndent()
+    )
+
+    val result = GradleRunner.create()
+      .withProjectDir(tempFolder.root)
+      .withArguments("clean", "assembleDebug")
+      .withPluginClasspath()
+      .build()
+
+    // task has been run
+    assertThat(
+      result.task(":leakCanaryCopyObfuscationMappingForDebug")?.outcome == SUCCESS
+    ).isTrue()
+
+    // apk has been built
+    val apkFile = File(tempFolder.root, "build/outputs/apk/debug")
+      .listFiles()
+      ?.firstOrNull { it.extension == "apk" }
+    assertThat(apkFile != null).isTrue()
+
+    // mapping file has been generated by proguard/r8
+    val mappingFile = File(tempFolder.root, "build/outputs/mapping/debug/mapping.txt")
+    assertThat(mappingFile.exists()).isTrue()
+
+    // apk contains obfuscation mapping file in assets dir
+    val obfuscationMappingEntry = ZipFile(apkFile).use { zipFile ->
+      zipFile.entries().toList().firstOrNull { entry ->
+        entry.name.contains("assets/leakCanaryObfuscationMapping.txt")
+      }
+    }
+    assertThat(obfuscationMappingEntry != null).isTrue()
+  }
+
+  @Test
+  fun `leakcanary deobfuscation plugin doesn't copy mapping file if it hasn't been configured`() {
+    buildFile.writeText(
+      """
+        plugins {
+          id 'com.squareup.leakcanary.deobfuscation'
+          id 'com.android.application'
+        }
+        
+        allprojects {
+          repositories {
+            google()
+            jcenter()
+          }
+        }
+        
+        android {
+          compileSdk 29
+  
+          defaultConfig {
+            minSdk 29
+          }
+  
+          buildTypes {
+            debug {
+              minifyEnabled true
+              proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+            }
+          }
+        }
+      """.trimIndent()
+    )
+
+    GradleRunner.create()
+      .withProjectDir(tempFolder.root)
+      .withArguments("clean", "assembleDebug")
+      .withPluginClasspath()
+      .build()
+
+    // apk has been built
+    val apkFile = File(tempFolder.root, "build/outputs/apk/debug")
+      .listFiles()
+      ?.firstOrNull { it.extension == "apk" }
+    assertThat(apkFile != null).isTrue()
+
+    // apk doesn't contain obfuscation mapping file in assets dir
+    val obfuscationMappingEntry = ZipFile(apkFile).use { zipFile ->
+      zipFile.entries().toList().firstOrNull { entry ->
+        entry.name.contains("assets/leakCanaryObfuscationMapping.txt")
+      }
+    }
+    assertThat(obfuscationMappingEntry == null).isTrue()
+  }
+
+  @Test
+  fun `should throw if there is no variant with enabled minification`() {
+    buildFile.writeText(
+      """
+        plugins {
+          id 'com.android.application'
+          id 'com.squareup.leakcanary.deobfuscation'
+        }
+        
+        allprojects {
+          repositories {
+            google()
+            jcenter()
+          }
+        }
+        
+        android {
+          compileSdk 29
+  
+          defaultConfig {
+            minSdk 29
+          }
+  
+          buildTypes {
+            debug {}
+          }
+        }
+        
+        leakCanary {
+          filterObfuscatedVariants { variant ->
+            variant.name == "debug"
+          }
+        }
+      """.trimIndent()
+    )
+
+    val result = GradleRunner.create()
+      .withProjectDir(tempFolder.root)
+      .withArguments("clean", "assembleDebug")
+      .withPluginClasspath()
+      .buildAndFail()
+
+    assertThat(
+      result.output.contains(
+        "LeakCanary deobfuscation plugin couldn't find any variant with minification enabled."
+      )
+    ).isTrue()
+  }
+}
diff --git a/leakcanary-deobfuscation-gradle-plugin/src/test/test-project/src/main/AndroidManifest.xml b/leakcanary-deobfuscation-gradle-plugin/src/test/test-project/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..4c3903bc
--- /dev/null
+++ b/leakcanary-deobfuscation-gradle-plugin/src/test/test-project/src/main/AndroidManifest.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest package="com.leakcanary.test" />
diff --git a/leakcanary-deobfuscation-gradle-plugin/src/test/test-project/src/main/java/com/leakcanary/test/TestProjectClass.java b/leakcanary-deobfuscation-gradle-plugin/src/test/test-project/src/main/java/com/leakcanary/test/TestProjectClass.java
new file mode 100644
index 00000000..57e9b2fb
--- /dev/null
+++ b/leakcanary-deobfuscation-gradle-plugin/src/test/test-project/src/main/java/com/leakcanary/test/TestProjectClass.java
@@ -0,0 +1,7 @@
+package com.leakcanary.test;
+
+public class TestProjectClass {
+  public void foo() {
+
+  }
+}
diff --git a/leakcanary-object-watcher-android-androidx/api/leakcanary-object-watcher-android-androidx.api b/leakcanary-object-watcher-android-androidx/api/leakcanary-object-watcher-android-androidx.api
new file mode 100644
index 00000000..e69de29b
diff --git a/leakcanary-object-watcher-android-androidx/build.gradle b/leakcanary-object-watcher-android-androidx/build.gradle
new file mode 100644
index 00000000..b979f1bb
--- /dev/null
+++ b/leakcanary-object-watcher-android-androidx/build.gradle
@@ -0,0 +1,27 @@
+plugins {
+  id("com.android.library")
+  id("org.jetbrains.kotlin.android")
+  id("com.vanniktech.maven.publish")
+}
+
+dependencies {
+  api projects.leakcanaryObjectWatcherAndroidCore
+
+  implementation libs.kotlin.stdlib
+  // Optional dependency
+  compileOnly libs.androidX.fragment
+}
+
+android {
+  compileSdk versions.compileSdk
+  defaultConfig {
+    minSdk versions.minSdk
+    consumerProguardFiles 'consumer-proguard-rules.pro'
+  }
+  buildFeatures.buildConfig = false
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
+    checkOnly 'Interoperability'
+  }
+}
diff --git a/leakcanary-object-watcher-android-androidx/consumer-proguard-rules.pro b/leakcanary-object-watcher-android-androidx/consumer-proguard-rules.pro
new file mode 100644
index 00000000..6160db8a
--- /dev/null
+++ b/leakcanary-object-watcher-android-androidx/consumer-proguard-rules.pro
@@ -0,0 +1,4 @@
+# AndroidXFragmentDestroyWatcher is loaded via reflection
+-keep class leakcanary.internal.AndroidXFragmentDestroyWatcher { *; }
+# ViewModelClearedWatcher reaches into ViewModelStore using reflection.
+-keep class androidx.lifecycle.ViewModelStore { *; }
diff --git a/leakcanary-object-watcher-android-androidx/gradle.properties b/leakcanary-object-watcher-android-androidx/gradle.properties
new file mode 100644
index 00000000..2a0b9c8f
--- /dev/null
+++ b/leakcanary-object-watcher-android-androidx/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-object-watcher-android-androidx
+POM_NAME=LeakCanary Object Watcher for Android extension: Android X fragments support
+POM_PACKAGING=aar
diff --git a/leakcanary-object-watcher-android-androidx/src/main/AndroidManifest.xml b/leakcanary-object-watcher-android-androidx/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..22eac305
--- /dev/null
+++ b/leakcanary-object-watcher-android-androidx/src/main/AndroidManifest.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    package="com.squareup.leakcanary.fragments.androidx"
+    >
+</manifest>
diff --git a/leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt b/leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
new file mode 100644
index 00000000..c68a6539
--- /dev/null
+++ b/leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.app.Activity
+import android.os.Bundle
+import androidx.fragment.app.Fragment
+import androidx.fragment.app.FragmentActivity
+import androidx.fragment.app.FragmentManager
+import leakcanary.ReachabilityWatcher
+
+internal class AndroidXFragmentDestroyWatcher(
+  private val reachabilityWatcher: ReachabilityWatcher
+) : (Activity) -> Unit {
+
+  private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
+
+    override fun onFragmentCreated(
+      fm: FragmentManager,
+      fragment: Fragment,
+      savedInstanceState: Bundle?
+    ) {
+      ViewModelClearedWatcher.install(fragment, reachabilityWatcher)
+    }
+
+    override fun onFragmentViewDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      val view = fragment.view
+      if (view != null) {
+        reachabilityWatcher.expectWeaklyReachable(
+          view, "${fragment::class.java.name} received Fragment#onDestroyView() callback " +
+          "(references to its views should be cleared to prevent leaks)"
+        )
+      }
+    }
+
+    override fun onFragmentDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      reachabilityWatcher.expectWeaklyReachable(
+        fragment, "${fragment::class.java.name} received Fragment#onDestroy() callback"
+      )
+    }
+  }
+
+  override fun invoke(activity: Activity) {
+    if (activity is FragmentActivity) {
+      val supportFragmentManager = activity.supportFragmentManager
+      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
+      ViewModelClearedWatcher.install(activity, reachabilityWatcher)
+    }
+  }
+}
diff --git a/leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/ViewModelClearedWatcher.kt b/leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/ViewModelClearedWatcher.kt
new file mode 100644
index 00000000..1fc4e573
--- /dev/null
+++ b/leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/ViewModelClearedWatcher.kt
@@ -0,0 +1,64 @@
+package leakcanary.internal
+
+import androidx.lifecycle.ViewModel
+import androidx.lifecycle.ViewModelProvider
+import androidx.lifecycle.ViewModelProvider.Factory
+import androidx.lifecycle.ViewModelStore
+import androidx.lifecycle.ViewModelStoreOwner
+import leakcanary.ReachabilityWatcher
+import leakcanary.internal.ViewModelClearedWatcher.Companion.install
+import shark.SharkLog
+
+/**
+ * [AndroidXFragmentDestroyWatcher] calls [install] to add a spy [ViewModel] in every
+ * [ViewModelStoreOwner] instance (i.e. FragmentActivity and Fragment). [ViewModelClearedWatcher]
+ * holds on to the map of [ViewModel]s backing its store. When [ViewModelClearedWatcher] receives
+ * the [onCleared] callback, it adds each live [ViewModel] from the store to the [ReachabilityWatcher].
+ */
+internal class ViewModelClearedWatcher(
+  storeOwner: ViewModelStoreOwner,
+  private val reachabilityWatcher: ReachabilityWatcher
+) : ViewModel() {
+
+  // We could call ViewModelStore#keys with a package spy in androidx.lifecycle instead,
+  // however that was added in 2.1.0 and we support AndroidX first stable release. viewmodel-2.0.0
+  // does not have ViewModelStore#keys. All versions currently have the mMap field.
+  private val viewModelMap: Map<String, ViewModel>? = try {
+    val storeClass = ViewModelStore::class.java
+    val mapField = try {
+      storeClass.getDeclaredField("map")
+    } catch (exception: NoSuchFieldException) {
+      // Field name changed from mMap to map with Kotlin conversion
+      // https://cs.android.com/androidx/platform/frameworks/support/+/8aa6ca1c924ab10d263b21b99b8790d5f0b50cc6
+      storeClass.getDeclaredField("mMap")
+    }
+    mapField.isAccessible = true
+    @Suppress("UNCHECKED_CAST")
+    mapField[storeOwner.viewModelStore] as Map<String, ViewModel>
+  } catch (ignored: Exception) {
+    SharkLog.d(ignored) { "Could not find ViewModelStore map of view models" }
+    null
+  }
+
+  override fun onCleared() {
+    viewModelMap?.values?.forEach { viewModel ->
+      reachabilityWatcher.expectWeaklyReachable(
+        viewModel, "${viewModel::class.java.name} received ViewModel#onCleared() callback"
+      )
+    }
+  }
+
+  companion object {
+    fun install(
+      storeOwner: ViewModelStoreOwner,
+      reachabilityWatcher: ReachabilityWatcher
+    ) {
+      val provider = ViewModelProvider(storeOwner, object : Factory {
+        @Suppress("UNCHECKED_CAST")
+        override fun <T : ViewModel?> create(modelClass: Class<T>): T =
+          ViewModelClearedWatcher(storeOwner, reachabilityWatcher) as T
+      })
+      provider.get(ViewModelClearedWatcher::class.java)
+    }
+  }
+}
diff --git a/leakcanary-object-watcher-android-core/api/leakcanary-object-watcher-android-core.api b/leakcanary-object-watcher-android-core/api/leakcanary-object-watcher-android-core.api
new file mode 100644
index 00000000..694db906
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/api/leakcanary-object-watcher-android-core.api
@@ -0,0 +1,86 @@
+public final class leakcanary/ActivityWatcher : leakcanary/InstallableWatcher {
+	public fun <init> (Landroid/app/Application;Lleakcanary/ReachabilityWatcher;)V
+	public fun install ()V
+	public fun uninstall ()V
+}
+
+public final class leakcanary/AppWatcher {
+	public static final field INSTANCE Lleakcanary/AppWatcher;
+	public final fun appDefaultWatchers (Landroid/app/Application;Lleakcanary/ReachabilityWatcher;)Ljava/util/List;
+	public static synthetic fun appDefaultWatchers$default (Lleakcanary/AppWatcher;Landroid/app/Application;Lleakcanary/ReachabilityWatcher;ILjava/lang/Object;)Ljava/util/List;
+	public static final fun getConfig ()Lleakcanary/AppWatcher$Config;
+	public final fun getObjectWatcher ()Lleakcanary/ObjectWatcher;
+	public final fun getRetainedDelayMillis ()J
+	public final fun isInstalled ()Z
+	public final fun manualInstall (Landroid/app/Application;)V
+	public final fun manualInstall (Landroid/app/Application;J)V
+	public final fun manualInstall (Landroid/app/Application;JLjava/util/List;)V
+	public static synthetic fun manualInstall$default (Lleakcanary/AppWatcher;Landroid/app/Application;JLjava/util/List;ILjava/lang/Object;)V
+	public static final fun setConfig (Lleakcanary/AppWatcher$Config;)V
+}
+
+public final class leakcanary/AppWatcher$Config {
+	public fun <init> ()V
+	public fun <init> (ZZZZJZ)V
+	public synthetic fun <init> (ZZZZJZILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun component1 ()Z
+	public final fun component2 ()Z
+	public final fun component3 ()Z
+	public final fun component4 ()Z
+	public final fun component5 ()J
+	public final fun component6 ()Z
+	public final fun copy (ZZZZJZ)Lleakcanary/AppWatcher$Config;
+	public static synthetic fun copy$default (Lleakcanary/AppWatcher$Config;ZZZZJZILjava/lang/Object;)Lleakcanary/AppWatcher$Config;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getEnabled ()Z
+	public final fun getWatchActivities ()Z
+	public final fun getWatchDurationMillis ()J
+	public final fun getWatchFragmentViews ()Z
+	public final fun getWatchFragments ()Z
+	public final fun getWatchViewModels ()Z
+	public fun hashCode ()I
+	public final fun newBuilder ()Lleakcanary/AppWatcher$Config$Builder;
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class leakcanary/AppWatcher$Config$Builder {
+	public final fun build ()Lleakcanary/AppWatcher$Config;
+	public final fun enabled (Z)Lleakcanary/AppWatcher$Config$Builder;
+	public final fun watchActivities (Z)Lleakcanary/AppWatcher$Config$Builder;
+	public final fun watchDurationMillis (J)Lleakcanary/AppWatcher$Config$Builder;
+	public final fun watchFragmentViews (Z)Lleakcanary/AppWatcher$Config$Builder;
+	public final fun watchFragments (Z)Lleakcanary/AppWatcher$Config$Builder;
+	public final fun watchViewModels (Z)Lleakcanary/AppWatcher$Config$Builder;
+}
+
+public final class leakcanary/FragmentAndViewModelWatcher : leakcanary/InstallableWatcher {
+	public static final field Companion Lleakcanary/FragmentAndViewModelWatcher$Companion;
+	public fun <init> (Landroid/app/Application;Lleakcanary/ReachabilityWatcher;)V
+	public fun install ()V
+	public fun uninstall ()V
+}
+
+public final class leakcanary/FragmentAndViewModelWatcher$Companion {
+}
+
+public abstract interface class leakcanary/InstallableWatcher {
+	public abstract fun install ()V
+	public abstract fun uninstall ()V
+}
+
+public final class leakcanary/RootViewWatcher : leakcanary/InstallableWatcher {
+	public fun <init> (Lleakcanary/ReachabilityWatcher;)V
+	public fun install ()V
+	public fun uninstall ()V
+}
+
+public final class leakcanary/ServiceWatcher : leakcanary/InstallableWatcher {
+	public static final field Companion Lleakcanary/ServiceWatcher$Companion;
+	public fun <init> (Lleakcanary/ReachabilityWatcher;)V
+	public fun install ()V
+	public fun uninstall ()V
+}
+
+public final class leakcanary/ServiceWatcher$Companion {
+}
+
diff --git a/leakcanary-object-watcher-android-core/build.gradle b/leakcanary-object-watcher-android-core/build.gradle
new file mode 100644
index 00000000..14af8862
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/build.gradle
@@ -0,0 +1,36 @@
+plugins {
+  id("com.android.library")
+  id("org.jetbrains.kotlin.android")
+  id("com.vanniktech.maven.publish")
+}
+
+dependencies {
+  api projects.leakcanaryObjectWatcher
+  api projects.leakcanaryAndroidUtils
+
+  implementation libs.curtains
+  implementation libs.kotlin.stdlib
+
+  testImplementation libs.assertjCore
+  testImplementation libs.junit
+  testImplementation libs.kotlin.reflect
+}
+
+android {
+  resourcePrefix 'leak_canary_watcher_'
+  compileSdk versions.compileSdk
+
+  defaultConfig {
+    minSdk versions.minSdk
+    consumerProguardFiles 'consumer-proguard-rules.pro'
+  }
+
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    checkOnly 'Interoperability'
+  }
+
+  buildFeatures {
+    buildConfig = false
+  }
+}
diff --git a/leakcanary-object-watcher-android-core/consumer-proguard-rules.pro b/leakcanary-object-watcher-android-core/consumer-proguard-rules.pro
new file mode 100644
index 00000000..74b6872a
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/consumer-proguard-rules.pro
@@ -0,0 +1,2 @@
+# KeyedWeakReference is looked up in the hprof file
+-keep class leakcanary.KeyedWeakReference { *; }
diff --git a/leakcanary-object-watcher-android-core/gradle.properties b/leakcanary-object-watcher-android-core/gradle.properties
new file mode 100644
index 00000000..ca96b805
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-object-watcher-android-core
+POM_NAME=LeakCanary Object Watcher for Android - Core
+POM_PACKAGING=aar
diff --git a/leakcanary-object-watcher-android-core/src/main/AndroidManifest.xml b/leakcanary-object-watcher-android-core/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..57d4471c
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/src/main/AndroidManifest.xml
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="com.squareup.leakcanary.objectwatcher.core">
+</manifest>
diff --git a/leakcanary-object-watcher-android-core/src/main/java/leakcanary/ActivityWatcher.kt b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/ActivityWatcher.kt
new file mode 100644
index 00000000..49ce2814
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/ActivityWatcher.kt
@@ -0,0 +1,32 @@
+package leakcanary
+
+import android.app.Activity
+import android.app.Application
+import leakcanary.internal.friendly.noOpDelegate
+
+/**
+ * Expects activities to become weakly reachable soon after they receive the [Activity.onDestroy]
+ * callback.
+ */
+class ActivityWatcher(
+  private val application: Application,
+  private val reachabilityWatcher: ReachabilityWatcher
+) : InstallableWatcher {
+
+  private val lifecycleCallbacks =
+    object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
+      override fun onActivityDestroyed(activity: Activity) {
+        reachabilityWatcher.expectWeaklyReachable(
+          activity, "${activity::class.java.name} received Activity#onDestroy() callback"
+        )
+      }
+    }
+
+  override fun install() {
+    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)
+  }
+
+  override fun uninstall() {
+    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)
+  }
+}
diff --git a/leakcanary-object-watcher-android-core/src/main/java/leakcanary/AppWatcher.kt b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/AppWatcher.kt
new file mode 100644
index 00000000..cfb606ae
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/AppWatcher.kt
@@ -0,0 +1,218 @@
+package leakcanary
+
+import android.app.Application
+import android.os.SystemClock
+import java.util.concurrent.TimeUnit
+import leakcanary.AppWatcher.objectWatcher
+import leakcanary.internal.LeakCanaryDelegate
+import leakcanary.internal.friendly.checkMainThread
+import leakcanary.internal.friendly.mainHandler
+import leakcanary.internal.isDebuggableBuild
+
+/**
+ * The entry point API for using [ObjectWatcher] in an Android app. [AppWatcher.objectWatcher] is
+ * in charge of detecting retained objects, and [AppWatcher] is auto configured on app start to
+ * pass it activity and fragment instances. Call [ObjectWatcher.watch] on [objectWatcher] to
+ * watch any other object that you expect to be unreachable.
+ */
+object AppWatcher {
+
+  private const val RETAINED_DELAY_NOT_SET = -1L
+
+  @Volatile
+  var retainedDelayMillis = RETAINED_DELAY_NOT_SET
+    private set
+
+  private var installCause: Exception? = null
+
+  /**
+   * The [ObjectWatcher] used by AppWatcher to detect retained objects.
+   * Only set when [isInstalled] is true.
+   */
+  val objectWatcher = ObjectWatcher(
+    clock = { SystemClock.uptimeMillis() },
+    checkRetainedExecutor = {
+      check(isInstalled) {
+        "AppWatcher not installed"
+      }
+      mainHandler.postDelayed(it, retainedDelayMillis)
+    },
+    isEnabled = { true }
+  )
+
+  /** @see [manualInstall] */
+  val isInstalled: Boolean
+    get() = installCause != null
+
+  /**
+   * Enables usage of [AppWatcher.objectWatcher] which will expect passed in objects to become
+   * weakly reachable within [retainedDelayMillis] ms and if not will trigger LeakCanary (if
+   * LeakCanary is in the classpath).
+   *
+   * In the main process, this method is automatically called with default parameter values  on app
+   * startup. You can call this method directly to customize the installation, however you must
+   * first disable the automatic call by overriding the `leak_canary_watcher_auto_install` boolean
+   * resource:
+   *
+   * ```xml
+   * <?xml version="1.0" encoding="utf-8"?>
+   * <resources>
+   *   <bool name="leak_canary_watcher_auto_install">false</bool>
+   * </resources>
+   * ```
+   *
+   * [watchersToInstall] can be customized to a subset of the default app watchers:
+   *
+   * ```kotlin
+   * val watchersToInstall = AppWatcher.appDefaultWatchers(application)
+   *   .filter { it !is RootViewWatcher }
+   * AppWatcher.manualInstall(
+   *   application = application,
+   *   watchersToInstall = watchersToInstall
+   * )
+   * ```
+   *
+   * [watchersToInstall] can also be customized to ignore specific instances (e.g. here ignoring
+   * leaks of BadSdkLeakingFragment):
+   *
+   * ```kotlin
+   * val watchersToInstall = AppWatcher.appDefaultWatchers(application, ReachabilityWatcher { watchedObject, description ->
+   *   if (watchedObject !is BadSdkLeakingFragment) {
+   *     AppWatcher.objectWatcher.expectWeaklyReachable(watchedObject, description)
+   *   }
+   * })
+   * AppWatcher.manualInstall(
+   *   application = application,
+   *   watchersToInstall = watchersToInstall
+   * )
+   * ```
+   */
+  @JvmOverloads
+  fun manualInstall(
+    application: Application,
+    retainedDelayMillis: Long = TimeUnit.SECONDS.toMillis(5),
+    watchersToInstall: List<InstallableWatcher> = appDefaultWatchers(application)
+  ) {
+    checkMainThread()
+    if (isInstalled) {
+      throw IllegalStateException(
+        "AppWatcher already installed, see exception cause for prior install call", installCause
+      )
+    }
+    check(retainedDelayMillis >= 0) {
+      "retainedDelayMillis $retainedDelayMillis must be at least 0 ms"
+    }
+    this.retainedDelayMillis = retainedDelayMillis
+    if (application.isDebuggableBuild) {
+      LogcatSharkLog.install()
+    }
+    // Requires AppWatcher.objectWatcher to be set
+    LeakCanaryDelegate.loadLeakCanary(application)
+
+    watchersToInstall.forEach {
+      it.install()
+    }
+    // Only install after we're fully done with init.
+    installCause = RuntimeException("manualInstall() first called here")
+  }
+
+  /**
+   * Creates a new list of default app [InstallableWatcher], created with the passed in
+   * [reachabilityWatcher] (which defaults to [objectWatcher]). Once installed,
+   * these watchers will pass in to [reachabilityWatcher] objects that they expect to become
+   * weakly reachable.
+   *
+   * The passed in [reachabilityWatcher] should probably delegate to [objectWatcher] but can
+   * be used to filter out specific instances.
+   */
+  fun appDefaultWatchers(
+    application: Application,
+    reachabilityWatcher: ReachabilityWatcher = objectWatcher
+  ): List<InstallableWatcher> {
+    return listOf(
+      ActivityWatcher(application, reachabilityWatcher),
+      FragmentAndViewModelWatcher(application, reachabilityWatcher),
+      RootViewWatcher(reachabilityWatcher),
+      ServiceWatcher(reachabilityWatcher)
+    )
+  }
+
+  @Deprecated("Call AppWatcher.manualInstall() ")
+  data class Config(
+    @Deprecated("Call AppWatcher.manualInstall() with a custom watcher list")
+    val watchActivities: Boolean = true,
+
+    @Deprecated("Call AppWatcher.manualInstall() with a custom watcher list")
+    val watchFragments: Boolean = true,
+
+    @Deprecated("Call AppWatcher.manualInstall() with a custom watcher list")
+    val watchFragmentViews: Boolean = true,
+
+    @Deprecated("Call AppWatcher.manualInstall() with a custom watcher list")
+    val watchViewModels: Boolean = true,
+
+    @Deprecated("Call AppWatcher.manualInstall() with a custom retainedDelayMillis value")
+    val watchDurationMillis: Long = TimeUnit.SECONDS.toMillis(5),
+
+    @Deprecated("Call AppWatcher.appDefaultWatchers() with a custom ReachabilityWatcher")
+    val enabled: Boolean = true
+  ) {
+
+    @Deprecated("Configuration moved to AppWatcher.manualInstall()", replaceWith = ReplaceWith(""))
+    @Suppress("NEWER_VERSION_IN_SINCE_KOTLIN")
+    @SinceKotlin("999.9") // Hide from Kotlin code, this method is only for Java code
+    fun newBuilder(): Builder = Builder(this)
+
+    @Deprecated("Configuration moved to XML resources")
+    class Builder internal constructor(config: Config) {
+      private var watchActivities = config.watchActivities
+      private var watchFragments = config.watchFragments
+      private var watchFragmentViews = config.watchFragmentViews
+      private var watchViewModels = config.watchViewModels
+      private var watchDurationMillis = config.watchDurationMillis
+
+      /** Deprecated. @see [Config.enabled] */
+      @Deprecated("see [Config.enabled]", replaceWith = ReplaceWith(""))
+      fun enabled(enabled: Boolean) = this
+
+      /** @see [Config.watchActivities] */
+      @Deprecated("see [Config.watchActivities]", replaceWith = ReplaceWith(""))
+      fun watchActivities(watchActivities: Boolean) =
+        apply { this.watchActivities = watchActivities }
+
+      @Deprecated("see [Config.watchFragments]", replaceWith = ReplaceWith(""))
+        /** @see [Config.watchFragments] */
+      fun watchFragments(watchFragments: Boolean) =
+        apply { this.watchFragments = watchFragments }
+
+      @Deprecated("see [Config.watchFragmentViews]", replaceWith = ReplaceWith(""))
+        /** @see [Config.watchFragmentViews] */
+      fun watchFragmentViews(watchFragmentViews: Boolean) =
+        apply { this.watchFragmentViews = watchFragmentViews }
+
+      @Deprecated("see [Config.watchViewModels]", replaceWith = ReplaceWith(""))
+        /** @see [Config.watchViewModels] */
+      fun watchViewModels(watchViewModels: Boolean) =
+        apply { this.watchViewModels = watchViewModels }
+
+      @Deprecated("see [Config.watchDurationMillis]", replaceWith = ReplaceWith(""))
+        /** @see [Config.watchDurationMillis] */
+      fun watchDurationMillis(watchDurationMillis: Long) =
+        apply { this.watchDurationMillis = watchDurationMillis }
+
+      @Deprecated("Configuration moved to AppWatcher.manualInstall()")
+      fun build() = config.copy(
+        watchActivities = watchActivities,
+        watchFragments = watchFragments,
+        watchFragmentViews = watchFragmentViews,
+        watchViewModels = watchViewModels,
+        watchDurationMillis = watchDurationMillis
+      )
+    }
+  }
+
+  @Deprecated("Configuration moved to AppWatcher.manualInstall()")
+  @JvmStatic @Volatile
+  var config: Config = Config()
+
+}
diff --git a/leakcanary-object-watcher-android-core/src/main/java/leakcanary/FragmentAndViewModelWatcher.kt b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/FragmentAndViewModelWatcher.kt
new file mode 100644
index 00000000..2588b6a6
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/FragmentAndViewModelWatcher.kt
@@ -0,0 +1,120 @@
+package leakcanary
+
+import android.app.Activity
+import android.app.Application
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.O
+import android.os.Bundle
+import leakcanary.internal.AndroidOFragmentDestroyWatcher
+import leakcanary.internal.friendly.noOpDelegate
+
+/**
+ * Expects:
+ * - Fragments (Support Library, Android X and AOSP) to become weakly reachable soon after they
+ * receive the Fragment#onDestroy() callback.
+ * - Fragment views (Support Library, Android X and AOSP) to become weakly reachable soon after
+ * fragments receive the Fragment#onDestroyView() callback.
+ * - Android X view models (both activity and fragment view models) to become weakly reachable soon
+ * after they received the ViewModel#onCleared() callback.
+ */
+class FragmentAndViewModelWatcher(
+  private val application: Application,
+  private val reachabilityWatcher: ReachabilityWatcher
+) : InstallableWatcher {
+
+  private val fragmentDestroyWatchers: List<(Activity) -> Unit> = run {
+    val fragmentDestroyWatchers = mutableListOf<(Activity) -> Unit>()
+
+    if (SDK_INT >= O) {
+      fragmentDestroyWatchers.add(
+        AndroidOFragmentDestroyWatcher(reachabilityWatcher)
+      )
+    }
+
+    getWatcherIfAvailable(
+      ANDROIDX_FRAGMENT_CLASS_NAME,
+      ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,
+      reachabilityWatcher
+    )?.let {
+      fragmentDestroyWatchers.add(it)
+    }
+
+    getWatcherIfAvailable(
+      ANDROID_SUPPORT_FRAGMENT_CLASS_NAME,
+      ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,
+      reachabilityWatcher
+    )?.let {
+      fragmentDestroyWatchers.add(it)
+    }
+    fragmentDestroyWatchers
+  }
+
+  private val lifecycleCallbacks =
+    object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
+      override fun onActivityCreated(
+        activity: Activity,
+        savedInstanceState: Bundle?
+      ) {
+        for (watcher in fragmentDestroyWatchers) {
+          watcher(activity)
+        }
+      }
+    }
+
+  override fun install() {
+    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)
+  }
+
+  override fun uninstall() {
+    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)
+  }
+
+  private fun getWatcherIfAvailable(
+    fragmentClassName: String,
+    watcherClassName: String,
+    reachabilityWatcher: ReachabilityWatcher
+  ): ((Activity) -> Unit)? {
+
+    return if (classAvailable(fragmentClassName) &&
+      classAvailable(watcherClassName)
+    ) {
+      val watcherConstructor =
+        Class.forName(watcherClassName).getDeclaredConstructor(ReachabilityWatcher::class.java)
+      @Suppress("UNCHECKED_CAST")
+      watcherConstructor.newInstance(reachabilityWatcher) as (Activity) -> Unit
+    } else {
+      null
+    }
+  }
+
+  private fun classAvailable(className: String): Boolean {
+    return try {
+      Class.forName(className)
+      true
+    } catch (e: Throwable) {
+      // e is typically expected to be a ClassNotFoundException
+      // Unfortunately, prior to version 25.0.2 of the support library the
+      // FragmentManager.FragmentLifecycleCallbacks class was a non static inner class.
+      // Our AndroidSupportFragmentDestroyWatcher class is compiled against the static version of
+      // the FragmentManager.FragmentLifecycleCallbacks class, leading to the
+      // AndroidSupportFragmentDestroyWatcher class being rejected and a NoClassDefFoundError being
+      // thrown here. So we're just covering our butts here and catching everything, and assuming
+      // any throwable means "can't use this". See https://github.com/square/leakcanary/issues/1662
+      false
+    }
+  }
+
+  companion object {
+    private const val ANDROIDX_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"
+    private const val ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =
+      "leakcanary.internal.AndroidXFragmentDestroyWatcher"
+
+    // Using a string builder to prevent Jetifier from changing this string to Android X Fragment
+    @Suppress("VariableNaming", "PropertyName")
+    private val ANDROID_SUPPORT_FRAGMENT_CLASS_NAME =
+      StringBuilder("android.").append("support.v4.app.Fragment")
+        .toString()
+    private const val ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =
+      "leakcanary.internal.AndroidSupportFragmentDestroyWatcher"
+  }
+}
diff --git a/leakcanary-object-watcher-android-core/src/main/java/leakcanary/InstallableWatcher.kt b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/InstallableWatcher.kt
new file mode 100644
index 00000000..e74d1837
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/InstallableWatcher.kt
@@ -0,0 +1,8 @@
+package leakcanary
+
+interface InstallableWatcher {
+
+  fun install()
+
+  fun uninstall()
+}
\ No newline at end of file
diff --git a/leakcanary-object-watcher-android-core/src/main/java/leakcanary/RootViewWatcher.kt b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/RootViewWatcher.kt
new file mode 100644
index 00000000..a566d865
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/RootViewWatcher.kt
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import android.app.Activity
+import android.app.Dialog
+import android.view.View
+import android.view.View.OnAttachStateChangeListener
+import com.squareup.leakcanary.objectwatcher.core.R
+import curtains.Curtains
+import curtains.OnRootViewAddedListener
+import curtains.WindowType.PHONE_WINDOW
+import curtains.WindowType.POPUP_WINDOW
+import curtains.WindowType.TOAST
+import curtains.WindowType.TOOLTIP
+import curtains.WindowType.UNKNOWN
+import curtains.phoneWindow
+import curtains.windowType
+import curtains.wrappedCallback
+import leakcanary.internal.friendly.mainHandler
+
+/**
+ * Expects root views to become weakly reachable soon after they are removed from the window
+ * manager.
+ */
+class RootViewWatcher(
+  private val reachabilityWatcher: ReachabilityWatcher
+) : InstallableWatcher {
+
+  private val listener = OnRootViewAddedListener { rootView ->
+    val trackDetached = when(rootView.windowType) {
+      PHONE_WINDOW -> {
+        when (rootView.phoneWindow?.callback?.wrappedCallback) {
+          // Activities are already tracked by ActivityWatcher
+          is Activity -> false
+          is Dialog -> {
+            // Use app context resources to avoid NotFoundException
+            // https://github.com/square/leakcanary/issues/2137
+            val resources = rootView.context.applicationContext.resources
+            resources.getBoolean(R.bool.leak_canary_watcher_watch_dismissed_dialogs)
+          }
+          // Probably a DreamService
+          else -> true
+        }
+      }
+      // Android widgets keep detached popup window instances around.
+      POPUP_WINDOW -> false
+      TOOLTIP, TOAST, UNKNOWN -> true
+    }
+    if (trackDetached) {
+      rootView.addOnAttachStateChangeListener(object : OnAttachStateChangeListener {
+
+        val watchDetachedView = Runnable {
+          reachabilityWatcher.expectWeaklyReachable(
+            rootView, "${rootView::class.java.name} received View#onDetachedFromWindow() callback"
+          )
+        }
+
+        override fun onViewAttachedToWindow(v: View) {
+          mainHandler.removeCallbacks(watchDetachedView)
+        }
+
+        override fun onViewDetachedFromWindow(v: View) {
+          mainHandler.post(watchDetachedView)
+        }
+      })
+    }
+  }
+
+  override fun install() {
+    Curtains.onRootViewsChangedListeners += listener
+  }
+
+  override fun uninstall() {
+    Curtains.onRootViewsChangedListeners -= listener
+  }
+}
diff --git a/leakcanary-object-watcher-android-core/src/main/java/leakcanary/ServiceWatcher.kt b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/ServiceWatcher.kt
new file mode 100644
index 00000000..bfad8e62
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/ServiceWatcher.kt
@@ -0,0 +1,174 @@
+package leakcanary
+
+import android.annotation.SuppressLint
+import android.app.Service
+import android.os.Build
+import android.os.Handler
+import android.os.IBinder
+import leakcanary.internal.friendly.checkMainThread
+import shark.SharkLog
+import java.lang.ref.WeakReference
+import java.lang.reflect.InvocationTargetException
+import java.lang.reflect.Proxy
+import java.util.WeakHashMap
+
+/**
+ * Expects services to become weakly reachable soon after they receive the [Service.onDestroy]
+ * callback.
+ */
+@SuppressLint("PrivateApi")
+class ServiceWatcher(private val reachabilityWatcher: ReachabilityWatcher) : InstallableWatcher {
+
+  private val servicesToBeDestroyed = WeakHashMap<IBinder, WeakReference<Service>>()
+
+  private val activityThreadClass by lazy { Class.forName("android.app.ActivityThread") }
+
+  private val activityThreadInstance by lazy {
+    activityThreadClass.getDeclaredMethod("currentActivityThread").invoke(null)!!
+  }
+
+  private val activityThreadServices by lazy {
+    val mServicesField =
+      activityThreadClass.getDeclaredField("mServices").apply { isAccessible = true }
+
+    @Suppress("UNCHECKED_CAST")
+    mServicesField[activityThreadInstance] as Map<IBinder, Service>
+  }
+
+  private var uninstallActivityThreadHandlerCallback: (() -> Unit)? = null
+  private var uninstallActivityManager: (() -> Unit)? = null
+
+  override fun install() {
+    checkMainThread()
+    check(uninstallActivityThreadHandlerCallback == null) {
+      "ServiceWatcher already installed"
+    }
+    check(uninstallActivityManager == null) {
+      "ServiceWatcher already installed"
+    }
+    try {
+      swapActivityThreadHandlerCallback { mCallback ->
+        uninstallActivityThreadHandlerCallback = {
+          swapActivityThreadHandlerCallback {
+            mCallback
+          }
+        }
+        Handler.Callback { msg ->
+          // https://github.com/square/leakcanary/issues/2114
+          // On some Motorola devices (Moto E5 and G6), the msg.obj returns an ActivityClientRecord
+          // instead of an IBinder. This crashes on a ClassCastException. Adding a type check
+          // here to prevent the crash.
+          if (msg.obj !is IBinder) {
+            return@Callback false
+          }
+
+          if (msg.what == STOP_SERVICE) {
+            val key = msg.obj as IBinder
+            activityThreadServices[key]?.let {
+              onServicePreDestroy(key, it)
+            }
+          }
+          mCallback?.handleMessage(msg) ?: false
+        }
+      }
+      swapActivityManager { activityManagerInterface, activityManagerInstance ->
+        uninstallActivityManager = {
+          swapActivityManager { _, _ ->
+            activityManagerInstance
+          }
+        }
+        Proxy.newProxyInstance(
+          activityManagerInterface.classLoader, arrayOf(activityManagerInterface)
+        ) { _, method, args ->
+          if (METHOD_SERVICE_DONE_EXECUTING == method.name) {
+            val token = args!![0] as IBinder
+            if (servicesToBeDestroyed.containsKey(token)) {
+              onServiceDestroyed(token)
+            }
+          }
+          try {
+            if (args == null) {
+              method.invoke(activityManagerInstance)
+            } else {
+              method.invoke(activityManagerInstance, *args)
+            }
+          } catch (invocationException: InvocationTargetException) {
+            throw invocationException.targetException
+          }
+        }
+      }
+    } catch (ignored: Throwable) {
+      SharkLog.d(ignored) { "Could not watch destroyed services" }
+    }
+  }
+
+  override fun uninstall() {
+    checkMainThread()
+    uninstallActivityManager?.invoke()
+    uninstallActivityThreadHandlerCallback?.invoke()
+    uninstallActivityManager = null
+    uninstallActivityThreadHandlerCallback = null
+  }
+
+  private fun onServicePreDestroy(
+    token: IBinder,
+    service: Service
+  ) {
+    servicesToBeDestroyed[token] = WeakReference(service)
+  }
+
+  private fun onServiceDestroyed(token: IBinder) {
+    servicesToBeDestroyed.remove(token)?.also { serviceWeakReference ->
+      serviceWeakReference.get()?.let { service ->
+        reachabilityWatcher.expectWeaklyReachable(
+          service, "${service::class.java.name} received Service#onDestroy() callback"
+        )
+      }
+    }
+  }
+
+  private fun swapActivityThreadHandlerCallback(swap: (Handler.Callback?) -> Handler.Callback?) {
+    val mHField =
+      activityThreadClass.getDeclaredField("mH").apply { isAccessible = true }
+    val mH = mHField[activityThreadInstance] as Handler
+
+    val mCallbackField =
+      Handler::class.java.getDeclaredField("mCallback").apply { isAccessible = true }
+    val mCallback = mCallbackField[mH] as Handler.Callback?
+    mCallbackField[mH] = swap(mCallback)
+  }
+
+  @SuppressLint("PrivateApi")
+  private fun swapActivityManager(swap: (Class<*>, Any) -> Any) {
+    val singletonClass = Class.forName("android.util.Singleton")
+    val mInstanceField =
+      singletonClass.getDeclaredField("mInstance").apply { isAccessible = true }
+
+    val singletonGetMethod = singletonClass.getDeclaredMethod("get")
+
+    val (className, fieldName) = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      "android.app.ActivityManager" to "IActivityManagerSingleton"
+    } else {
+      "android.app.ActivityManagerNative" to "gDefault"
+    }
+
+    val activityManagerClass = Class.forName(className)
+    val activityManagerSingletonField =
+      activityManagerClass.getDeclaredField(fieldName).apply { isAccessible = true }
+    val activityManagerSingletonInstance = activityManagerSingletonField[activityManagerClass]
+
+    // Calling get() instead of reading from the field directly to ensure the singleton is
+    // created.
+    val activityManagerInstance = singletonGetMethod.invoke(activityManagerSingletonInstance)
+
+    val iActivityManagerInterface = Class.forName("android.app.IActivityManager")
+    mInstanceField[activityManagerSingletonInstance] =
+      swap(iActivityManagerInterface, activityManagerInstance!!)
+  }
+
+  companion object {
+    private const val STOP_SERVICE = 116
+
+    private const val METHOD_SERVICE_DONE_EXECUTING = "serviceDoneExecuting"
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-object-watcher-android-core/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
new file mode 100644
index 00000000..9401cd08
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@file:Suppress("DEPRECATION")
+
+package leakcanary.internal
+
+import android.annotation.SuppressLint
+import android.app.Activity
+import android.app.Fragment
+import android.app.FragmentManager
+import leakcanary.ReachabilityWatcher
+
+@SuppressLint("NewApi")
+internal class AndroidOFragmentDestroyWatcher(
+  private val reachabilityWatcher: ReachabilityWatcher
+) : (Activity) -> Unit {
+  private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
+
+    override fun onFragmentViewDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      val view = fragment.view
+      if (view != null) {
+        reachabilityWatcher.expectWeaklyReachable(
+          view, "${fragment::class.java.name} received Fragment#onDestroyView() callback " +
+          "(references to its views should be cleared to prevent leaks)"
+        )
+      }
+    }
+
+    override fun onFragmentDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      reachabilityWatcher.expectWeaklyReachable(
+        fragment, "${fragment::class.java.name} received Fragment#onDestroy() callback"
+      )
+    }
+  }
+
+  override fun invoke(activity: Activity) {
+    val fragmentManager = activity.fragmentManager
+    fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
+  }
+}
diff --git a/leakcanary-object-watcher-android-core/src/main/java/leakcanary/internal/Applications.kt b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/internal/Applications.kt
new file mode 100644
index 00000000..ef4e7992
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/internal/Applications.kt
@@ -0,0 +1,7 @@
+package leakcanary.internal
+
+import android.app.Application
+import android.content.pm.ApplicationInfo
+
+internal val Application.isDebuggableBuild: Boolean
+  get() = (applicationInfo.flags and ApplicationInfo.FLAG_DEBUGGABLE) != 0
\ No newline at end of file
diff --git a/leakcanary-object-watcher-android-core/src/main/java/leakcanary/internal/LeakCanaryDelegate.kt b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/internal/LeakCanaryDelegate.kt
new file mode 100644
index 00000000..79717fd6
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/internal/LeakCanaryDelegate.kt
@@ -0,0 +1,26 @@
+package leakcanary.internal
+
+import android.app.Application
+import leakcanary.OnObjectRetainedListener
+
+internal object LeakCanaryDelegate {
+
+  @Suppress("UNCHECKED_CAST")
+  val loadLeakCanary by lazy {
+    try {
+      val leakCanaryListener = Class.forName("leakcanary.internal.InternalLeakCanary")
+      leakCanaryListener.getDeclaredField("INSTANCE")
+        .get(null) as (Application) -> Unit
+    } catch (ignored: Throwable) {
+      NoLeakCanary
+    }
+  }
+
+  object NoLeakCanary : (Application) -> Unit, OnObjectRetainedListener {
+    override fun invoke(application: Application) {
+    }
+
+    override fun onObjectRetained() {
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-object-watcher-android-core/src/main/java/leakcanary/internal/friendly/Friendly.kt b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/internal/friendly/Friendly.kt
new file mode 100644
index 00000000..b8c81cef
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/src/main/java/leakcanary/internal/friendly/Friendly.kt
@@ -0,0 +1,11 @@
+@file:Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER", "NOTHING_TO_INLINE")
+@file:JvmName("leakcanary-object-watcher-android_Friendly")
+
+package leakcanary.internal.friendly
+
+internal inline val mainHandler
+  get() = leakcanary.internal.mainHandler
+
+internal inline fun checkMainThread() = leakcanary.internal.checkMainThread()
+
+internal inline fun <reified T : Any> noOpDelegate(): T = leakcanary.internal.noOpDelegate()
diff --git a/leakcanary-object-watcher-android-core/src/main/res/values/leak_canary_public.xml b/leakcanary-object-watcher-android-core/src/main/res/values/leak_canary_public.xml
new file mode 100644
index 00000000..935b223e
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/src/main/res/values/leak_canary_public.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <public name="leak_canary_watcher_watch_dismissed_dialogs" type="bool"/>
+</resources>
diff --git a/leakcanary-object-watcher-android-core/src/main/res/values/watcher_bools.xml b/leakcanary-object-watcher-android-core/src/main/res/values/watcher_bools.xml
new file mode 100644
index 00000000..dafec30a
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/src/main/res/values/watcher_bools.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <!-- Whether to automatically install in the main process on startup via a custom ContentProvider.
+   If false, you need to call AppWatcher.manualInstall().
+   -->
+  <bool name="leak_canary_watcher_watch_dismissed_dialogs">false</bool>
+</resources>
diff --git a/leakcanary-object-watcher-android-core/src/test/java/leakcanary/AppWatcherTest.kt b/leakcanary-object-watcher-android-core/src/test/java/leakcanary/AppWatcherTest.kt
new file mode 100644
index 00000000..16914c76
--- /dev/null
+++ b/leakcanary-object-watcher-android-core/src/test/java/leakcanary/AppWatcherTest.kt
@@ -0,0 +1,38 @@
+package leakcanary
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import kotlin.reflect.full.memberFunctions
+import kotlin.reflect.full.memberProperties
+
+class AppWatcherTest {
+
+  @Test fun appWatcherLoads_notInstalled() {
+    assertThat(AppWatcher.isInstalled)
+      .describedAs("Ensure AppWatcher doesn't crash in JUnit tests")
+      .isFalse()
+  }
+
+  /**
+   * Validates that each field in [AppWatcher.Config] has a matching builder function
+   * in [AppWatcher.Config.Builder]
+   */
+  @Test fun `AppWatcher Config Builder matches AppWatcher Config`() {
+    assertThat(configProperties())
+      .containsExactlyInAnyOrderElementsOf(configBuilderFunctions())
+  }
+
+  private fun configBuilderFunctions() = AppWatcher.Config.Builder::class.memberFunctions
+    .filter { member ->
+      member.annotations.none { it is Deprecated }
+    }
+    .map { it.name }
+    .subtract(setOf("build", "equals", "hashCode", "toString"))
+
+  private fun configProperties() = AppWatcher.Config::class.memberProperties
+    .filter { member ->
+      // Ignore deprecated fields, we don't need builders for those
+      member.annotations.none { it is Deprecated }
+    }
+    .map { it.name }
+}
diff --git a/leakcanary-object-watcher-android-startup/api/leakcanary-object-watcher-android-startup.api b/leakcanary-object-watcher-android-startup/api/leakcanary-object-watcher-android-startup.api
new file mode 100644
index 00000000..95c65c5c
--- /dev/null
+++ b/leakcanary-object-watcher-android-startup/api/leakcanary-object-watcher-android-startup.api
@@ -0,0 +1,7 @@
+public final class leakcanary/AppWatcherStartupInitializer : androidx/startup/Initializer {
+	public fun <init> ()V
+	public synthetic fun create (Landroid/content/Context;)Ljava/lang/Object;
+	public fun create (Landroid/content/Context;)Lleakcanary/AppWatcherStartupInitializer;
+	public fun dependencies ()Ljava/util/List;
+}
+
diff --git a/leakcanary-object-watcher-android-startup/build.gradle b/leakcanary-object-watcher-android-startup/build.gradle
new file mode 100644
index 00000000..753492c6
--- /dev/null
+++ b/leakcanary-object-watcher-android-startup/build.gradle
@@ -0,0 +1,25 @@
+plugins {
+  id("com.android.library")
+  id("org.jetbrains.kotlin.android")
+  id("com.vanniktech.maven.publish")
+}
+
+dependencies {
+  api projects.leakcanaryObjectWatcherAndroidCore
+
+  implementation libs.androidX.startup
+}
+
+android {
+  resourcePrefix 'leak_canary_watcher_'
+  compileSdk versions.compileSdk
+  defaultConfig {
+    minSdk versions.minSdk
+  }
+  buildFeatures.buildConfig = false
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
+    checkOnly 'Interoperability'
+  }
+}
diff --git a/leakcanary-object-watcher-android-startup/gradle.properties b/leakcanary-object-watcher-android-startup/gradle.properties
new file mode 100644
index 00000000..4b9c1c83
--- /dev/null
+++ b/leakcanary-object-watcher-android-startup/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-object-watcher-android-startup
+POM_NAME=AndroidX Startup config for leakcanary-object-watcher-android-core
+POM_PACKAGING=aar
diff --git a/leakcanary-object-watcher-android-startup/src/main/AndroidManifest.xml b/leakcanary-object-watcher-android-startup/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..e82a4538
--- /dev/null
+++ b/leakcanary-object-watcher-android-startup/src/main/AndroidManifest.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.squareup.leakcanary.objectwatcher.startup">
+  <application>
+    <provider
+      android:name="androidx.startup.InitializationProvider"
+      android:authorities="${applicationId}.androidx-startup"
+      android:exported="false"
+      tools:node="merge">
+
+      <meta-data
+        android:name="leakcanary.AppWatcherStartupInitializer"
+        android:value="androidx.startup"/>
+    </provider>
+
+  </application>
+</manifest>
diff --git a/leakcanary-object-watcher-android-startup/src/main/java/leakcanary/AppWatcherStartupInitializer.kt b/leakcanary-object-watcher-android-startup/src/main/java/leakcanary/AppWatcherStartupInitializer.kt
new file mode 100644
index 00000000..b521b0bd
--- /dev/null
+++ b/leakcanary-object-watcher-android-startup/src/main/java/leakcanary/AppWatcherStartupInitializer.kt
@@ -0,0 +1,13 @@
+package leakcanary
+
+import android.app.Application
+import android.content.Context
+import androidx.startup.Initializer
+
+class AppWatcherStartupInitializer : Initializer<AppWatcherStartupInitializer> {
+  override fun create(context: Context) = apply {
+    val application = context.applicationContext as Application
+    AppWatcher.manualInstall(application)
+  }
+  override fun dependencies() = emptyList<Class<out Initializer<*>>>()
+}
diff --git a/leakcanary-object-watcher-android-support-fragments/api/leakcanary-object-watcher-android-support-fragments.api b/leakcanary-object-watcher-android-support-fragments/api/leakcanary-object-watcher-android-support-fragments.api
new file mode 100644
index 00000000..e69de29b
diff --git a/leakcanary-object-watcher-android-support-fragments/build.gradle b/leakcanary-object-watcher-android-support-fragments/build.gradle
new file mode 100644
index 00000000..45839f77
--- /dev/null
+++ b/leakcanary-object-watcher-android-support-fragments/build.gradle
@@ -0,0 +1,27 @@
+plugins {
+  id("com.android.library")
+  id("org.jetbrains.kotlin.android")
+  id("com.vanniktech.maven.publish")
+}
+
+dependencies {
+  api projects.leakcanaryObjectWatcherAndroidCore
+
+  implementation libs.kotlin.stdlib
+  // Optional dependency
+  compileOnly libs.androidSupport
+}
+
+android {
+  compileSdk versions.compileSdk
+  defaultConfig {
+    minSdk versions.minSdk
+    consumerProguardFiles 'consumer-proguard-rules.pro'
+  }
+  buildFeatures.buildConfig = false
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
+    checkOnly 'Interoperability'
+  }
+}
diff --git a/leakcanary-object-watcher-android-support-fragments/consumer-proguard-rules.pro b/leakcanary-object-watcher-android-support-fragments/consumer-proguard-rules.pro
new file mode 100644
index 00000000..636103e3
--- /dev/null
+++ b/leakcanary-object-watcher-android-support-fragments/consumer-proguard-rules.pro
@@ -0,0 +1,2 @@
+# AndroidSupportFragmentDestroyWatcher is loaded via reflection
+-keep class leakcanary.internal.AndroidSupportFragmentDestroyWatcher { *; }
diff --git a/leakcanary-object-watcher-android-support-fragments/gradle.properties b/leakcanary-object-watcher-android-support-fragments/gradle.properties
new file mode 100644
index 00000000..d78acb64
--- /dev/null
+++ b/leakcanary-object-watcher-android-support-fragments/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-object-watcher-android-support-fragments
+POM_NAME=LeakCanary Object Watcher for Android extension: Android support library fragments support
+POM_PACKAGING=aar
diff --git a/leakcanary-object-watcher-android-support-fragments/src/main/AndroidManifest.xml b/leakcanary-object-watcher-android-support-fragments/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..fd26de19
--- /dev/null
+++ b/leakcanary-object-watcher-android-support-fragments/src/main/AndroidManifest.xml
@@ -0,0 +1 @@
+<manifest package="com.squareup.leakcanary.fragments.android_support" />
diff --git a/leakcanary-object-watcher-android-support-fragments/src/main/java/leakcanary/internal/AndroidSupportFragmentDestroyWatcher.kt b/leakcanary-object-watcher-android-support-fragments/src/main/java/leakcanary/internal/AndroidSupportFragmentDestroyWatcher.kt
new file mode 100644
index 00000000..601ecb21
--- /dev/null
+++ b/leakcanary-object-watcher-android-support-fragments/src/main/java/leakcanary/internal/AndroidSupportFragmentDestroyWatcher.kt
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.app.Activity
+import android.support.v4.app.Fragment
+import android.support.v4.app.FragmentActivity
+import android.support.v4.app.FragmentManager
+import leakcanary.ReachabilityWatcher
+
+internal class AndroidSupportFragmentDestroyWatcher(
+  private val reachabilityWatcher: ReachabilityWatcher
+) : (Activity) -> Unit {
+
+  private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
+
+    override fun onFragmentViewDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      val view = fragment.view
+      if (view != null) {
+        reachabilityWatcher.expectWeaklyReachable(
+          view, "${fragment::class.java.name} received Fragment#onDestroyView() callback " +
+          "(references to its views should be cleared to prevent leaks)"
+        )
+      }
+    }
+
+    override fun onFragmentDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      reachabilityWatcher.expectWeaklyReachable(
+        fragment, "${fragment::class.java.name} received Fragment#onDestroy() callback"
+      )
+    }
+  }
+
+  override fun invoke(activity: Activity) {
+    if (activity is FragmentActivity) {
+      val supportFragmentManager = activity.supportFragmentManager
+      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
+    }
+  }
+}
diff --git a/leakcanary-object-watcher-android/api/leakcanary-object-watcher-android.api b/leakcanary-object-watcher-android/api/leakcanary-object-watcher-android.api
new file mode 100644
index 00000000..e69de29b
diff --git a/leakcanary-object-watcher-android/build.gradle b/leakcanary-object-watcher-android/build.gradle
new file mode 100644
index 00000000..badf31c9
--- /dev/null
+++ b/leakcanary-object-watcher-android/build.gradle
@@ -0,0 +1,28 @@
+plugins {
+  id("com.android.library")
+  id("org.jetbrains.kotlin.android")
+  id("com.vanniktech.maven.publish")
+}
+
+dependencies {
+  api projects.leakcanaryObjectWatcherAndroidCore
+}
+
+android {
+  resourcePrefix 'leak_canary_watcher_'
+  compileSdk versions.compileSdk
+
+  defaultConfig {
+    minSdk versions.minSdk
+    consumerProguardFiles 'consumer-proguard-rules.pro'
+  }
+
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    checkOnly 'Interoperability'
+  }
+
+  buildFeatures {
+    buildConfig = false
+  }
+}
diff --git a/leakcanary-object-watcher-android/consumer-proguard-rules.pro b/leakcanary-object-watcher-android/consumer-proguard-rules.pro
new file mode 100644
index 00000000..de655729
--- /dev/null
+++ b/leakcanary-object-watcher-android/consumer-proguard-rules.pro
@@ -0,0 +1,2 @@
+# A ContentProvider that gets created by Android on startup
+-keep class leakcanary.internal.MainProcessAppWatcherInstaller { <init>(); }
diff --git a/leakcanary-object-watcher-android/gradle.properties b/leakcanary-object-watcher-android/gradle.properties
new file mode 100644
index 00000000..589676b8
--- /dev/null
+++ b/leakcanary-object-watcher-android/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-object-watcher-android
+POM_NAME=LeakCanary Object Watcher for Android - Auto installing
+POM_PACKAGING=aar
diff --git a/leakcanary-object-watcher-android/src/main/AndroidManifest.xml b/leakcanary-object-watcher-android/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..7c42908b
--- /dev/null
+++ b/leakcanary-object-watcher-android/src/main/AndroidManifest.xml
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary.objectwatcher"
+    >
+
+  <application>
+    <provider
+        android:name="leakcanary.internal.MainProcessAppWatcherInstaller"
+        android:authorities="${applicationId}.leakcanary-installer"
+        android:enabled="@bool/leak_canary_watcher_auto_install"
+        android:exported="false"/>
+  </application>
+</manifest>
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/MainProcessAppWatcherInstaller.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/MainProcessAppWatcherInstaller.kt
new file mode 100644
index 00000000..bebb2830
--- /dev/null
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/MainProcessAppWatcherInstaller.kt
@@ -0,0 +1,42 @@
+package leakcanary.internal
+
+import android.app.Application
+import android.content.ContentProvider
+import android.content.ContentValues
+import android.database.Cursor
+import android.net.Uri
+import leakcanary.AppWatcher
+
+/**
+ * Content providers are loaded before the application class is created. [MainProcessAppWatcherInstaller] is
+ * used to install [leakcanary.AppWatcher] on application start.
+ *
+ * [MainProcessAppWatcherInstaller] automatically sets up the LeakCanary code that runs in the main
+ * app process.
+ */
+internal class MainProcessAppWatcherInstaller : ContentProvider() {
+
+  override fun onCreate(): Boolean {
+    val application = context!!.applicationContext as Application
+    AppWatcher.manualInstall(application)
+    return true
+  }
+
+  override fun query(
+    uri: Uri,
+    projectionArg: Array<String>?,
+    selection: String?,
+    selectionArgs: Array<String>?,
+    sortOrder: String?
+  ): Cursor? = null
+
+  override fun getType(uri: Uri): String? = null
+
+  override fun insert(uri: Uri, contentValues: ContentValues?): Uri? = null
+
+  override fun delete(uri: Uri, selection: String?, selectionArgs: Array<out String>?): Int = 0
+
+  override fun update(
+    uri: Uri, values: ContentValues?, selection: String?, selectionArgs: Array<out String>?
+  ): Int = 0
+}
diff --git a/leakcanary-object-watcher-android/src/main/res/values/leak_canary_public.xml b/leakcanary-object-watcher-android/src/main/res/values/leak_canary_public.xml
new file mode 100644
index 00000000..18f26d32
--- /dev/null
+++ b/leakcanary-object-watcher-android/src/main/res/values/leak_canary_public.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <public name="leak_canary_watcher_auto_install" type="bool"/>
+</resources>
diff --git a/leakcanary-object-watcher-android/src/main/res/values/watcher_bools.xml b/leakcanary-object-watcher-android/src/main/res/values/watcher_bools.xml
new file mode 100644
index 00000000..e550b45b
--- /dev/null
+++ b/leakcanary-object-watcher-android/src/main/res/values/watcher_bools.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <!-- Whether to automatically install in the main process on startup via a custom ContentProvider.
+   If false, you need to call AppWatcher.manualInstall().
+   -->
+  <bool name="leak_canary_watcher_auto_install">true</bool>
+</resources>
diff --git a/leakcanary-object-watcher/api/leakcanary-object-watcher.api b/leakcanary-object-watcher/api/leakcanary-object-watcher.api
new file mode 100644
index 00000000..b8a304bf
--- /dev/null
+++ b/leakcanary-object-watcher/api/leakcanary-object-watcher.api
@@ -0,0 +1,65 @@
+public abstract interface class leakcanary/Clock {
+	public static final field Companion Lleakcanary/Clock$Companion;
+	public abstract fun uptimeMillis ()J
+}
+
+public final class leakcanary/Clock$Companion {
+	public final fun invoke (Lkotlin/jvm/functions/Function0;)Lleakcanary/Clock;
+}
+
+public abstract interface class leakcanary/GcTrigger {
+	public abstract fun runGc ()V
+}
+
+public final class leakcanary/GcTrigger$Default : leakcanary/GcTrigger {
+	public static final field INSTANCE Lleakcanary/GcTrigger$Default;
+	public fun runGc ()V
+}
+
+public final class leakcanary/KeyedWeakReference : java/lang/ref/WeakReference {
+	public static final field Companion Lleakcanary/KeyedWeakReference$Companion;
+	public fun <init> (Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;JLjava/lang/ref/ReferenceQueue;)V
+	public fun clear ()V
+	public final fun getDescription ()Ljava/lang/String;
+	public static final fun getHeapDumpUptimeMillis ()J
+	public final fun getKey ()Ljava/lang/String;
+	public final fun getRetainedUptimeMillis ()J
+	public final fun getWatchUptimeMillis ()J
+	public static final fun setHeapDumpUptimeMillis (J)V
+	public final fun setRetainedUptimeMillis (J)V
+}
+
+public final class leakcanary/KeyedWeakReference$Companion {
+	public final fun getHeapDumpUptimeMillis ()J
+	public final fun setHeapDumpUptimeMillis (J)V
+}
+
+public final class leakcanary/ObjectWatcher : leakcanary/ReachabilityWatcher {
+	public fun <init> (Lleakcanary/Clock;Ljava/util/concurrent/Executor;Lkotlin/jvm/functions/Function0;)V
+	public synthetic fun <init> (Lleakcanary/Clock;Ljava/util/concurrent/Executor;Lkotlin/jvm/functions/Function0;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun addOnObjectRetainedListener (Lleakcanary/OnObjectRetainedListener;)V
+	public final fun clearObjectsWatchedBefore (J)V
+	public final fun clearWatchedObjects ()V
+	public fun expectWeaklyReachable (Ljava/lang/Object;Ljava/lang/String;)V
+	public final fun getHasRetainedObjects ()Z
+	public final fun getHasWatchedObjects ()Z
+	public final fun getRetainedObjectCount ()I
+	public final fun getRetainedObjects ()Ljava/util/List;
+	public final fun removeOnObjectRetainedListener (Lleakcanary/OnObjectRetainedListener;)V
+	public final fun watch (Ljava/lang/Object;)V
+	public final fun watch (Ljava/lang/Object;Ljava/lang/String;)V
+}
+
+public abstract interface class leakcanary/OnObjectRetainedListener {
+	public static final field Companion Lleakcanary/OnObjectRetainedListener$Companion;
+	public abstract fun onObjectRetained ()V
+}
+
+public final class leakcanary/OnObjectRetainedListener$Companion {
+	public final fun invoke (Lkotlin/jvm/functions/Function0;)Lleakcanary/OnObjectRetainedListener;
+}
+
+public abstract interface class leakcanary/ReachabilityWatcher {
+	public abstract fun expectWeaklyReachable (Ljava/lang/Object;Ljava/lang/String;)V
+}
+
diff --git a/leakcanary-object-watcher/build.gradle b/leakcanary-object-watcher/build.gradle
new file mode 100644
index 00000000..b98d1c23
--- /dev/null
+++ b/leakcanary-object-watcher/build.gradle
@@ -0,0 +1,15 @@
+plugins {
+  id("org.jetbrains.kotlin.jvm")
+  id("com.vanniktech.maven.publish")
+}
+
+sourceCompatibility = JavaVersion.VERSION_1_8
+targetCompatibility = JavaVersion.VERSION_1_8
+
+dependencies {
+  implementation libs.kotlin.stdlib
+  api projects.sharkLog
+
+  testImplementation libs.assertjCore
+  testImplementation libs.junit
+}
diff --git a/leakcanary-object-watcher/gradle.properties b/leakcanary-object-watcher/gradle.properties
new file mode 100644
index 00000000..16794121
--- /dev/null
+++ b/leakcanary-object-watcher/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-object-watcher
+POM_NAME=LeakCanary Object Watcher
+POM_PACKAGING=jar
diff --git a/leakcanary-object-watcher/src/main/java/leakcanary/Clock.kt b/leakcanary-object-watcher/src/main/java/leakcanary/Clock.kt
new file mode 100644
index 00000000..8d071f98
--- /dev/null
+++ b/leakcanary-object-watcher/src/main/java/leakcanary/Clock.kt
@@ -0,0 +1,30 @@
+package leakcanary
+
+/**
+ * An interface to abstract the SystemClock.uptimeMillis() Android API in non Android artifacts.
+ *
+ * This is a functional interface with which you can create a [Clock] from a lambda.
+ */
+fun interface Clock {
+  /**
+   * On Android VMs, this should return android.os.SystemClock.uptimeMillis().
+   */
+  fun uptimeMillis(): Long
+
+  companion object {
+    /**
+     * Utility function to create a [Clock] from the passed in [block] lambda
+     * instead of using the anonymous `object : Clock` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val clock = Clock {
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: () -> Long): Clock =
+      Clock { block() }
+  }
+}
diff --git a/leakcanary-object-watcher/src/main/java/leakcanary/GcTrigger.kt b/leakcanary-object-watcher/src/main/java/leakcanary/GcTrigger.kt
new file mode 100644
index 00000000..309216a7
--- /dev/null
+++ b/leakcanary-object-watcher/src/main/java/leakcanary/GcTrigger.kt
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+/**
+ * [GcTrigger] is used to try triggering garbage collection and enqueuing [KeyedWeakReference] into
+ * the associated [java.lang.ref.ReferenceQueue]. The default implementation [Default] comes from
+ * AOSP.
+ */
+fun interface GcTrigger {
+
+  /**
+   * Attempts to run garbage collection.
+   */
+  fun runGc()
+
+  /**
+   * Default implementation of [GcTrigger].
+   */
+  object Default : GcTrigger {
+    override fun runGc() {
+      // Code taken from AOSP FinalizationTest:
+      // https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
+      // java/lang/ref/FinalizationTester.java
+      // System.gc() does not garbage collect every time. Runtime.gc() is
+      // more likely to perform a gc.
+      Runtime.getRuntime()
+        .gc()
+      enqueueReferences()
+      System.runFinalization()
+    }
+
+    private fun enqueueReferences() {
+      // Hack. We don't have a programmatic way to wait for the reference queue daemon to move
+      // references to the appropriate queues.
+      try {
+        Thread.sleep(100)
+      } catch (e: InterruptedException) {
+        throw AssertionError()
+      }
+    }
+  }
+}
diff --git a/leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt b/leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
new file mode 100644
index 00000000..314155e8
--- /dev/null
+++ b/leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import leakcanary.KeyedWeakReference.Companion.heapDumpUptimeMillis
+import java.lang.ref.ReferenceQueue
+import java.lang.ref.WeakReference
+
+/**
+ * A weak reference used by [ObjectWatcher] to determine which objects become weakly reachable
+ * and which don't. [ObjectWatcher] uses [key] to keep track of [KeyedWeakReference] instances that
+ * haven't made it into the associated [ReferenceQueue] yet.
+ *
+ * [heapDumpUptimeMillis] should be set with the current time from [Clock.uptimeMillis] right
+ * before dumping the heap, so that we can later determine how long an object was retained.
+ */
+class KeyedWeakReference(
+  referent: Any,
+  val key: String,
+  val description: String,
+  val watchUptimeMillis: Long,
+  referenceQueue: ReferenceQueue<Any>
+) : WeakReference<Any>(
+  referent, referenceQueue
+) {
+  /**
+   * Time at which the associated object ([referent]) was considered retained, or -1 if it hasn't
+   * been yet.
+   */
+  @Volatile
+  var retainedUptimeMillis = -1L
+
+  override fun clear() {
+    super.clear()
+    retainedUptimeMillis = -1L
+  }
+
+  companion object {
+    @Volatile
+    @JvmStatic var heapDumpUptimeMillis = 0L
+  }
+}
diff --git a/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt b/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt
new file mode 100644
index 00000000..2154a8b6
--- /dev/null
+++ b/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import shark.SharkLog
+import java.lang.ref.ReferenceQueue
+import java.util.UUID
+import java.util.concurrent.Executor
+
+/**
+ * [ObjectWatcher] can be passed objects to [watch]. It will create [KeyedWeakReference] instances
+ * that reference watches objects, and check if those references have been cleared as expected on
+ * the [checkRetainedExecutor] executor. If not, these objects are considered retained and
+ * [ObjectWatcher] will then notify registered [OnObjectRetainedListener]s on that executor thread.
+ *
+ * [checkRetainedExecutor] is expected to run its tasks on a background thread, with a significant
+ * delay to give the GC the opportunity to identify weakly reachable objects.
+ *
+ * [ObjectWatcher] is thread safe.
+ */
+// Thread safe by locking on all methods, which is reasonably efficient given how often
+// these methods are accessed.
+class ObjectWatcher constructor(
+  private val clock: Clock,
+  private val checkRetainedExecutor: Executor,
+  /**
+   * Calls to [watch] will be ignored when [isEnabled] returns false
+   */
+  private val isEnabled: () -> Boolean = { true }
+) : ReachabilityWatcher {
+
+  private val onObjectRetainedListeners = mutableSetOf<OnObjectRetainedListener>()
+
+  /**
+   * References passed to [watch].
+   */
+  private val watchedObjects = mutableMapOf<String, KeyedWeakReference>()
+
+  private val queue = ReferenceQueue<Any>()
+
+  /**
+   * Returns true if there are watched objects that aren't weakly reachable, and
+   * have been watched for long enough to be considered retained.
+   */
+  val hasRetainedObjects: Boolean
+    @Synchronized get() {
+      removeWeaklyReachableObjects()
+      return watchedObjects.any { it.value.retainedUptimeMillis != -1L }
+    }
+
+  /**
+   * Returns the number of retained objects, ie the number of watched objects that aren't weakly
+   * reachable, and have been watched for long enough to be considered retained.
+   */
+  val retainedObjectCount: Int
+    @Synchronized get() {
+      removeWeaklyReachableObjects()
+      return watchedObjects.count { it.value.retainedUptimeMillis != -1L }
+    }
+
+  /**
+   * Returns true if there are watched objects that aren't weakly reachable, even
+   * if they haven't been watched for long enough to be considered retained.
+   */
+  val hasWatchedObjects: Boolean
+    @Synchronized get() {
+      removeWeaklyReachableObjects()
+      return watchedObjects.isNotEmpty()
+    }
+
+  /**
+   * Returns the objects that are currently considered retained. Useful for logging purposes.
+   * Be careful with those objects and release them ASAP as you may creating longer lived leaks
+   * then the one that are already there.
+   */
+  val retainedObjects: List<Any>
+    @Synchronized get() {
+      removeWeaklyReachableObjects()
+      val instances = mutableListOf<Any>()
+      for (weakReference in watchedObjects.values) {
+        if (weakReference.retainedUptimeMillis != -1L) {
+          val instance = weakReference.get()
+          if (instance != null) {
+            instances.add(instance)
+          }
+        }
+      }
+      return instances
+    }
+
+  @Synchronized fun addOnObjectRetainedListener(listener: OnObjectRetainedListener) {
+    onObjectRetainedListeners.add(listener)
+  }
+
+  @Synchronized fun removeOnObjectRetainedListener(listener: OnObjectRetainedListener) {
+    onObjectRetainedListeners.remove(listener)
+  }
+
+  /**
+   * Identical to [watch] with an empty string reference name.
+   */
+  @Deprecated(
+    "Add description parameter explaining why an object is watched to help understand leak traces.",
+    replaceWith = ReplaceWith(
+      "expectWeaklyReachable(watchedObject, \"Explain why this object should be garbage collected soon\")"
+    )
+  )
+  fun watch(watchedObject: Any) {
+    expectWeaklyReachable(watchedObject, "")
+  }
+
+  @Deprecated(
+    "Method renamed expectWeaklyReachable() to clarify usage.",
+    replaceWith = ReplaceWith(
+      "expectWeaklyReachable(watchedObject, description)"
+    )
+  )
+  fun watch(
+    watchedObject: Any,
+    description: String
+  ) {
+    expectWeaklyReachable(watchedObject, description)
+  }
+
+
+  @Synchronized override fun expectWeaklyReachable(
+    watchedObject: Any,
+    description: String
+  ) {
+    if (!isEnabled()) {
+      return
+    }
+    removeWeaklyReachableObjects()
+    val key = UUID.randomUUID()
+      .toString()
+    val watchUptimeMillis = clock.uptimeMillis()
+    val reference =
+      KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)
+    SharkLog.d {
+      "Watching " +
+        (if (watchedObject is Class<*>) watchedObject.toString() else "instance of ${watchedObject.javaClass.name}") +
+        (if (description.isNotEmpty()) " ($description)" else "") +
+        " with key $key"
+    }
+
+    watchedObjects[key] = reference
+    checkRetainedExecutor.execute {
+      moveToRetained(key)
+    }
+  }
+
+  /**
+   * Clears all [KeyedWeakReference] that were created before [heapDumpUptimeMillis] (based on
+   * [clock] [Clock.uptimeMillis])
+   */
+  @Synchronized fun clearObjectsWatchedBefore(heapDumpUptimeMillis: Long) {
+    val weakRefsToRemove =
+      watchedObjects.filter { it.value.watchUptimeMillis <= heapDumpUptimeMillis }
+    weakRefsToRemove.values.forEach { it.clear() }
+    watchedObjects.keys.removeAll(weakRefsToRemove.keys)
+  }
+
+  /**
+   * Clears all [KeyedWeakReference]
+   */
+  @Synchronized fun clearWatchedObjects() {
+    watchedObjects.values.forEach { it.clear() }
+    watchedObjects.clear()
+  }
+
+  @Synchronized private fun moveToRetained(key: String) {
+    removeWeaklyReachableObjects()
+    val retainedRef = watchedObjects[key]
+    if (retainedRef != null) {
+      retainedRef.retainedUptimeMillis = clock.uptimeMillis()
+      onObjectRetainedListeners.forEach { it.onObjectRetained() }
+    }
+  }
+
+  private fun removeWeaklyReachableObjects() {
+    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
+    // reachable. This is before finalization or garbage collection has actually happened.
+    var ref: KeyedWeakReference?
+    do {
+      ref = queue.poll() as KeyedWeakReference?
+      if (ref != null) {
+        watchedObjects.remove(ref.key)
+      }
+    } while (ref != null)
+  }
+}
diff --git a/leakcanary-object-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt b/leakcanary-object-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt
new file mode 100644
index 00000000..0e5b548b
--- /dev/null
+++ b/leakcanary-object-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt
@@ -0,0 +1,31 @@
+package leakcanary
+
+/**
+ * Listener used by [ObjectWatcher] to report retained objects.
+ *
+ * This is a functional interface with which you can create a [OnObjectRetainedListener] from a lambda.
+ */
+fun interface OnObjectRetainedListener {
+
+  /**
+   * A watched object became retained.
+   */
+  fun onObjectRetained()
+
+  companion object {
+    /**
+     * Utility function to create a [OnObjectRetainedListener] from the passed in [block] lambda
+     * instead of using the anonymous `object : OnObjectRetainedListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val listener = OnObjectRetainedListener {
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: () -> Unit): OnObjectRetainedListener =
+      OnObjectRetainedListener { block() }
+  }
+}
diff --git a/leakcanary-object-watcher/src/main/java/leakcanary/ReachabilityWatcher.kt b/leakcanary-object-watcher/src/main/java/leakcanary/ReachabilityWatcher.kt
new file mode 100644
index 00000000..afdf3800
--- /dev/null
+++ b/leakcanary-object-watcher/src/main/java/leakcanary/ReachabilityWatcher.kt
@@ -0,0 +1,13 @@
+package leakcanary
+
+fun interface ReachabilityWatcher {
+
+  /**
+   * Expects the provided [watchedObject] to become weakly reachable soon. If not,
+   * [watchedObject] will be considered retained.
+   */
+  fun expectWeaklyReachable(
+    watchedObject: Any,
+    description: String
+  )
+}
\ No newline at end of file
diff --git a/leakcanary-object-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt b/leakcanary-object-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt
new file mode 100644
index 00000000..579ecada
--- /dev/null
+++ b/leakcanary-object-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt
@@ -0,0 +1,31 @@
+package leakcanary
+
+import leakcanary.GcTrigger.Default.runGc
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import java.util.concurrent.Executor
+
+class ObjectWatcherTest {
+
+  private val checkRetainedExecutor = Executor {
+    it.run()
+  }
+
+  private val objectWatcher = ObjectWatcher({ time }, checkRetainedExecutor)
+  var time: Long = 0
+
+  var ref: Any? = Any()
+
+  @Test fun `unreachable object not retained`() {
+    objectWatcher.expectWeaklyReachable(ref!!, "unreachable object not retained")
+    ref = null
+    runGc()
+    assertThat(objectWatcher.hasRetainedObjects).isFalse()
+  }
+
+  @Test fun `reachable object retained`() {
+    objectWatcher.expectWeaklyReachable(ref!!, "reachable object retained")
+    runGc()
+    assertThat(objectWatcher.hasRetainedObjects).isTrue()
+  }
+}
\ No newline at end of file
diff --git a/mkdocs.yml b/mkdocs.yml
new file mode 100644
index 00000000..ea1d2dff
--- /dev/null
+++ b/mkdocs.yml
@@ -0,0 +1,98 @@
+extra:
+  leak_canary:
+    release: '2.13'
+    next_release: '2.14'
+  social:
+    - icon: fontawesome/brands/github-alt
+      link: https://square.github.io/
+    - icon: fontawesome/brands/twitter
+      link: https://twitter.com/Piwai
+    - icon: fontawesome/brands/stack-overflow
+      link: https://stackoverflow.com/questions/tagged/leakcanary?sort=active
+    - icon: fontawesome/brands/linkedin
+      link: https://www.linkedin.com/company/joinsquare/
+
+site_name: LeakCanary
+site_url: https://square.github.io/leakcanary/
+repo_name: LeakCanary
+repo_url: https://github.com/square/leakcanary
+edit_uri: edit/main/docs/
+site_description: "A memory leak detection library for Android"
+site_author: Square, Inc.
+remote_branch: gh-pages
+
+copyright: 'Copyright &copy; 2015 Square, Inc.'
+
+theme:
+  name: 'material'
+  custom_dir: 'docs/theme'
+  logo: 'images/logo.png'
+  icon:
+    repo: fontawesome/brands/github
+  favicon: 'images/logo.png'
+  palette:
+    primary: 'deep-orange'
+    accent: 'deep-purple'
+  features:
+    - tabs
+
+markdown_extensions:
+  - smarty
+  - codehilite:
+      guess_lang: false
+  - footnotes
+  - meta
+  - toc:
+      permalink: true
+  - pymdownx.betterem:
+      smart_enable: all
+  - pymdownx.caret
+  - pymdownx.inlinehilite
+  - pymdownx.magiclink
+  - pymdownx.smartsymbols
+  - pymdownx.superfences
+  - pymdownx.emoji
+  - pymdownx.tabbed
+  - pymdownx.snippets
+  - tables
+  - admonition
+
+
+plugins:
+    - search
+    - markdownextradata: {}
+
+nav:
+  - 'Overview': index.md
+  - 'Getting Started': getting_started.md
+  - 'Fundamentals':
+    - 'Introduction': 'fundamentals.md'
+    - 'How LeakCanary works': 'fundamentals-how-leakcanary-works.md'
+    - 'Fixing a memory leak': 'fundamentals-fixing-a-memory-leak.md'
+  - 'LeakCanary at scale':
+    - 'Leak detection in UI tests': 'ui-tests.md'
+    - 'Uploading analysis results': 'uploading.md'
+    - 'LeakCanary for releases': 'leakcanary-for-releases.md'
+  - 'Help & Community':
+    - 'Code recipes': recipes.md
+    - 'FAQ': faq.md
+    - 'Support': support.md
+    - 'Upgrading to LeakCanary 2': upgrading-to-leakcanary-2.0.md
+    - 'Recorded Presentations': recorded-presentations.md
+    - 'Blog Articles': blog-articles.md
+    - 'Stack Overflow â': https://stackoverflow.com/questions/tagged/leakcanary?sort=active
+    - 'Contributing':
+        - 'Code of Conduct': code_of_conduct.md
+        - 'Dev Environment': dev-env.md
+        - 'Releasing': releasing.md
+        - 'How to help': how_to_help.md
+  - 'Shark':
+    - 'Overview': shark.md
+    - 'Shark API': api/shark/index.md
+  - 'LeakCanary API': api/leakcanary/index.md
+  - 'Change Log': changelog.md
+
+# Google Analytics. Add export LEAKCANARY_GOOGLE_ANALYTICS_KEY="UA-XXXXXXXXX-X" to your ~/.bashrc
+google_analytics:
+  - !!python/object/apply:os.getenv ["LEAKCANARY_GOOGLE_ANALYTICS_KEY"]
+  - auto
diff --git a/plumber-android-core/api/plumber-android-core.api b/plumber-android-core/api/plumber-android-core.api
new file mode 100644
index 00000000..6e8d5687
--- /dev/null
+++ b/plumber-android-core/api/plumber-android-core.api
@@ -0,0 +1,32 @@
+public abstract class leakcanary/AndroidLeakFixes : java/lang/Enum {
+	public static final field ACCESSIBILITY_NODE_INFO Lleakcanary/AndroidLeakFixes;
+	public static final field ACTIVITY_MANAGER Lleakcanary/AndroidLeakFixes;
+	public static final field BUBBLE_POPUP Lleakcanary/AndroidLeakFixes;
+	public static final field CONNECTIVITY_MANAGER Lleakcanary/AndroidLeakFixes;
+	public static final field Companion Lleakcanary/AndroidLeakFixes$Companion;
+	public static final field FLUSH_HANDLER_THREADS Lleakcanary/AndroidLeakFixes;
+	public static final field IMM_CUR_ROOT_VIEW Lleakcanary/AndroidLeakFixes;
+	public static final field IMM_FOCUSED_VIEW Lleakcanary/AndroidLeakFixes;
+	public static final field LAST_HOVERED_VIEW Lleakcanary/AndroidLeakFixes;
+	public static final field MEDIA_SESSION_LEGACY_HELPER Lleakcanary/AndroidLeakFixes;
+	public static final field SAMSUNG_CLIPBOARD_MANAGER Lleakcanary/AndroidLeakFixes;
+	public static final field SPELL_CHECKER Lleakcanary/AndroidLeakFixes;
+	public static final field TEXT_LINE_POOL Lleakcanary/AndroidLeakFixes;
+	public static final field USER_MANAGER Lleakcanary/AndroidLeakFixes;
+	public static final field VIEW_LOCATION_HOLDER Lleakcanary/AndroidLeakFixes;
+	public synthetic fun <init> (Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	protected abstract fun apply (Landroid/app/Application;)V
+	public static fun valueOf (Ljava/lang/String;)Lleakcanary/AndroidLeakFixes;
+	public static fun values ()[Lleakcanary/AndroidLeakFixes;
+}
+
+public final class leakcanary/AndroidLeakFixes$Companion {
+	public final fun applyFixes (Landroid/app/Application;Ljava/util/Set;)V
+	public static synthetic fun applyFixes$default (Lleakcanary/AndroidLeakFixes$Companion;Landroid/app/Application;Ljava/util/Set;ILjava/lang/Object;)V
+}
+
+public final class leakcanary/ViewLocationHolderLeakFix {
+	public static final field INSTANCE Lleakcanary/ViewLocationHolderLeakFix;
+	public final fun clearStaticPool (Landroid/app/Application;)V
+}
+
diff --git a/plumber-android-core/build.gradle b/plumber-android-core/build.gradle
new file mode 100644
index 00000000..3e88a9cd
--- /dev/null
+++ b/plumber-android-core/build.gradle
@@ -0,0 +1,30 @@
+plugins {
+  id("com.android.library")
+  id("org.jetbrains.kotlin.android")
+  id("com.vanniktech.maven.publish")
+}
+
+dependencies {
+  api projects.sharkLog
+  api projects.leakcanaryAndroidUtils
+
+  implementation libs.kotlin.stdlib
+  implementation libs.curtains
+  // Optional dependency
+  compileOnly libs.androidX.fragment
+}
+
+android {
+  resourcePrefix 'leak_canary_plumber'
+  compileSdk versions.compileSdk
+  defaultConfig {
+    minSdk versions.minSdk
+    consumerProguardFiles 'consumer-proguard-rules.pro'
+  }
+  buildFeatures.buildConfig = false
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
+    checkOnly 'Interoperability'
+  }
+}
diff --git a/plumber-android-core/consumer-proguard-rules.pro b/plumber-android-core/consumer-proguard-rules.pro
new file mode 100644
index 00000000..8458e5a9
--- /dev/null
+++ b/plumber-android-core/consumer-proguard-rules.pro
@@ -0,0 +1,4 @@
+# Enum values are referenced reflectively in EnumSet initialization
+-keepclassmembers,allowoptimization enum leakcanary.AndroidLeakFixes {
+    public static **[] values();
+}
diff --git a/plumber-android-core/gradle.properties b/plumber-android-core/gradle.properties
new file mode 100644
index 00000000..26e9ddc7
--- /dev/null
+++ b/plumber-android-core/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=plumber-android-core
+POM_NAME=Use Plumber Android to fix known leaks in the Android Framework and other Google Android libraries.
+POM_PACKAGING=aar
diff --git a/plumber-android-core/src/main/AndroidManifest.xml b/plumber-android-core/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..3224be99
--- /dev/null
+++ b/plumber-android-core/src/main/AndroidManifest.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="com.squareup.leakcanary.plumber.core" />
diff --git a/plumber-android-core/src/main/java/leakcanary/AndroidLeakFixes.kt b/plumber-android-core/src/main/java/leakcanary/AndroidLeakFixes.kt
new file mode 100644
index 00000000..796c25d8
--- /dev/null
+++ b/plumber-android-core/src/main/java/leakcanary/AndroidLeakFixes.kt
@@ -0,0 +1,824 @@
+package leakcanary
+
+import android.annotation.SuppressLint
+import android.annotation.TargetApi
+import android.app.Activity
+import android.app.Application
+import android.content.Context
+import android.content.Context.INPUT_METHOD_SERVICE
+import android.content.ContextWrapper
+import android.os.Build.MANUFACTURER
+import android.os.Build.VERSION.SDK_INT
+import android.os.Bundle
+import android.os.Handler
+import android.os.HandlerThread
+import android.os.Looper
+import android.os.UserManager
+import android.view.View
+import android.view.Window
+import android.view.accessibility.AccessibilityNodeInfo
+import android.view.inputmethod.InputMethodManager
+import android.view.textservice.TextServicesManager
+import android.widget.TextView
+import curtains.Curtains
+import curtains.OnRootViewRemovedListener
+import java.lang.reflect.Array
+import java.lang.reflect.Field
+import java.lang.reflect.InvocationTargetException
+import java.lang.reflect.Method
+import java.lang.reflect.Modifier
+import java.lang.reflect.Proxy
+import java.util.EnumSet
+import leakcanary.internal.ReferenceCleaner
+import leakcanary.internal.friendly.checkMainThread
+import leakcanary.internal.friendly.noOpDelegate
+import shark.SharkLog
+
+/**
+ * A collection of hacks to fix leaks in the Android Framework and other Google Android libraries.
+ */
+@SuppressLint("NewApi")
+enum class AndroidLeakFixes {
+
+  /**
+   * MediaSessionLegacyHelper is a static singleton and did not use the application context.
+   * Introduced in android-5.0.1_r1, fixed in Android 5.1.0_r1.
+   * https://github.com/android/platform_frameworks_base/commit/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091
+   *
+   * We fix this leak by invoking MediaSessionLegacyHelper.getHelper() early in the app lifecycle.
+   */
+  MEDIA_SESSION_LEGACY_HELPER {
+    override fun apply(application: Application) {
+      if (SDK_INT != 21) {
+        return
+      }
+      backgroundHandler.post {
+        try {
+          val clazz = Class.forName("android.media.session.MediaSessionLegacyHelper")
+          val getHelperMethod = clazz.getDeclaredMethod("getHelper", Context::class.java)
+          getHelperMethod.invoke(null, application)
+        } catch (ignored: Exception) {
+          SharkLog.d(ignored) { "Could not fix the $name leak" }
+        }
+      }
+    }
+  },
+
+  /**
+   * This flushes the TextLine pool when an activity is destroyed, to prevent memory leaks.
+   *
+   * The first memory leak has been fixed in android-5.1.0_r1
+   * https://github.com/android/platform_frameworks_base/commit/893d6fe48d37f71e683f722457bea646994a10bf
+   *
+   * Second memory leak: https://github.com/android/platform_frameworks_base/commit/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5ee4
+   */
+  TEXT_LINE_POOL {
+    override fun apply(application: Application) {
+      // Can't use reflection starting in SDK 28
+      if (SDK_INT >= 28) {
+        return
+      }
+      backgroundHandler.post {
+        try {
+          val textLineClass = Class.forName("android.text.TextLine")
+          val sCachedField = textLineClass.getDeclaredField("sCached")
+          sCachedField.isAccessible = true
+          // One time retrieval to make sure this will work.
+          val sCached = sCachedField.get(null)
+          // Can't happen in current Android source, but hidden APIs can change.
+          if (sCached == null || !sCached.javaClass.isArray) {
+            SharkLog.d { "Could not fix the $name leak, sCached=$sCached" }
+            return@post
+          }
+          application.onActivityDestroyed {
+            // Pool of TextLine instances.
+            val sCached = sCachedField.get(null)
+            // TextLine locks on sCached. We take that lock and clear the whole array at once.
+            synchronized(sCached) {
+              val length = Array.getLength(sCached)
+              for (i in 0 until length) {
+                Array.set(sCached, i, null)
+              }
+            }
+          }
+        } catch (ignored: Exception) {
+          SharkLog.d(ignored) { "Could not fix the $name leak" }
+          return@post
+        }
+      }
+    }
+  },
+
+  /**
+   * Obtaining the UserManager service ends up calling the hidden UserManager.get() method which
+   * stores the context in a singleton UserManager instance and then stores that instance in a
+   * static field.
+   *
+   * We obtain the user manager from an activity context, so if it hasn't been created yet it will
+   * leak that activity forever.
+   *
+   * This fix makes sure the UserManager is created and holds on to the Application context.
+   *
+   * Issue: https://code.google.com/p/android/issues/detail?id=173789
+   *
+   * Fixed in https://android.googlesource.com/platform/frameworks/base/+/5200e1cb07190a1f6874d72a4561064cad3ee3e0%5E%21/#F0
+   * (Android O)
+   */
+  USER_MANAGER {
+    @SuppressLint("NewApi")
+    override fun apply(application: Application) {
+      if (SDK_INT !in 17..25) {
+        return
+      }
+      try {
+        val getMethod = UserManager::class.java.getDeclaredMethod("get", Context::class.java)
+        getMethod.invoke(null, application)
+      } catch (ignored: Exception) {
+        SharkLog.d(ignored) { "Could not fix the $name leak" }
+      }
+    }
+  },
+
+  /**
+   * HandlerThread instances keep local reference to their last handled message after recycling it.
+   * That message is obtained by a dialog which sets on an OnClickListener on it and then never
+   * recycles it, expecting it to be garbage collected but it ends up being held by the
+   * HandlerThread.
+   */
+  FLUSH_HANDLER_THREADS {
+    override fun apply(application: Application) {
+      if (SDK_INT >= 31) {
+        return
+      }
+      val flushedThreadIds = mutableSetOf<Int>()
+      // Don't flush the backgroundHandler's thread, we're rescheduling all the time anyway.
+      flushedThreadIds += (backgroundHandler.looper.thread as HandlerThread).threadId
+      // Wait 2 seconds then look for handler threads every 3 seconds.
+      val flushNewHandlerThread = object : Runnable {
+        override fun run() {
+          val newHandlerThreadsById = findAllHandlerThreads()
+            .mapNotNull { thread ->
+              val threadId = thread.threadId
+              if (threadId == -1 || threadId in flushedThreadIds) {
+                null
+              } else {
+                threadId to thread
+              }
+            }
+          newHandlerThreadsById
+            .forEach { (threadId, handlerThread) ->
+              val looper = handlerThread.looper
+              if (looper == null) {
+                SharkLog.d { "Handler thread found without a looper: $handlerThread" }
+                return@forEach
+              }
+              flushedThreadIds += threadId
+              SharkLog.d { "Setting up flushing for $handlerThread" }
+              var scheduleFlush = true
+              val flushHandler = Handler(looper)
+              flushHandler.onEachIdle {
+                if (handlerThread.isAlive && scheduleFlush) {
+                  scheduleFlush = false
+                  // When the Handler thread becomes idle, we post a message to force it to move.
+                  // Source: https://developer.squareup.com/blog/a-small-leak-will-sink-a-great-ship/
+                  try {
+                    val posted = flushHandler.postDelayed({
+                      // Right after this postDelayed executes, the idle handler will likely be called
+                      // again (if the queue is otherwise empty), so we'll need to schedule a flush
+                      // again.
+                      scheduleFlush = true
+                    }, 1000)
+                    if (!posted) {
+                      SharkLog.d { "Failed to post to ${handlerThread.name}" }
+                    }
+                  } catch (ignored: RuntimeException) {
+                    // If the thread is quitting, posting to it may throw. There is no safe and atomic way
+                    // to check if a thread is quitting first then post it it.
+                    SharkLog.d(ignored) { "Failed to post to ${handlerThread.name}" }
+                  }
+                }
+              }
+            }
+          backgroundHandler.postDelayed(this, 3000)
+        }
+      }
+      backgroundHandler.postDelayed(flushNewHandlerThread, 2000)
+    }
+  },
+
+  /**
+   * Until API 28, AccessibilityNodeInfo has a mOriginalText field that was not properly cleared
+   * when instance were put back in the pool.
+   * Leak introduced here: https://android.googlesource.com/platform/frameworks/base/+/193520e3dff5248ddcf8435203bf99d2ba667219%5E%21/core/java/android/view/accessibility/AccessibilityNodeInfo.java
+   *
+   * Fixed here: https://android.googlesource.com/platform/frameworks/base/+/6f8ec1fd8c159b09d617ed6d9132658051443c0c
+   */
+  ACCESSIBILITY_NODE_INFO {
+    override fun apply(application: Application) {
+      if (SDK_INT >= 28) {
+        return
+      }
+
+      val starvePool = object : Runnable {
+        override fun run() {
+          val maxPoolSize = 50
+          for (i in 0 until maxPoolSize) {
+            AccessibilityNodeInfo.obtain()
+          }
+          backgroundHandler.postDelayed(this, 5000)
+        }
+      }
+      backgroundHandler.postDelayed(starvePool, 5000)
+    }
+  },
+
+  /**
+   * ConnectivityManager has a sInstance field that is set when the first ConnectivityManager instance is created.
+   * ConnectivityManager has a mContext field.
+   * When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first ConnectivityManager instance
+   * is created with the activity context and stored in sInstance.
+   * That activity context then leaks forever.
+   *
+   * This fix makes sure the connectivity manager is created with the application context.
+   *
+   * Tracked here: https://code.google.com/p/android/issues/detail?id=198852
+   * Introduced here: https://github.com/android/platform_frameworks_base/commit/e0bef71662d81caaaa0d7214fb0bef5d39996a69
+   */
+  CONNECTIVITY_MANAGER {
+    override fun apply(application: Application) {
+      if (SDK_INT > 23) {
+        return
+      }
+
+      try {
+        application.getSystemService(Context.CONNECTIVITY_SERVICE)
+      } catch (ignored: Exception) {
+        SharkLog.d(ignored) { "Could not fix the $name leak" }
+      }
+    }
+  },
+
+  /**
+   * ClipboardUIManager is a static singleton that leaks an activity context.
+   * This fix makes sure the manager is called with an application context.
+   */
+  SAMSUNG_CLIPBOARD_MANAGER {
+    override fun apply(application: Application) {
+      if (MANUFACTURER != SAMSUNG || SDK_INT !in 19..21) {
+        return
+      }
+
+      try {
+        val managerClass = Class.forName("android.sec.clipboard.ClipboardUIManager")
+        val instanceMethod = managerClass.getDeclaredMethod("getInstance", Context::class.java)
+        instanceMethod.isAccessible = true
+        instanceMethod.invoke(null, application)
+      } catch (ignored: Exception) {
+        SharkLog.d(ignored) { "Could not fix the $name leak" }
+      }
+    }
+  },
+
+  /**
+   * A static helper for EditText bubble popups leaks a reference to the latest focused view.
+   *
+   * This fix clears it when the activity is destroyed.
+   */
+  BUBBLE_POPUP {
+    override fun apply(application: Application) {
+      if (MANUFACTURER != LG || SDK_INT !in 19..21) {
+        return
+      }
+
+      backgroundHandler.post {
+        val helperField: Field
+        try {
+          val helperClass = Class.forName("android.widget.BubblePopupHelper")
+          helperField = helperClass.getDeclaredField("sHelper")
+          helperField.isAccessible = true
+        } catch (ignored: Exception) {
+          SharkLog.d(ignored) { "Could not fix the $name leak" }
+          return@post
+        }
+
+        application.onActivityDestroyed {
+          try {
+            helperField.set(null, null)
+          } catch (ignored: Exception) {
+            SharkLog.d(ignored) { "Could not fix the $name leak" }
+          }
+        }
+      }
+    }
+  },
+
+  /**
+   * mLastHoveredView is a static field in TextView that leaks the last hovered view.
+   *
+   * This fix clears it when the activity is destroyed.
+   */
+  LAST_HOVERED_VIEW {
+    override fun apply(application: Application) {
+      if (MANUFACTURER != SAMSUNG || SDK_INT !in 19..21) {
+        return
+      }
+
+      backgroundHandler.post {
+        val field: Field
+        try {
+          field = TextView::class.java.getDeclaredField("mLastHoveredView")
+          field.isAccessible = true
+        } catch (ignored: Exception) {
+          SharkLog.d(ignored) { "Could not fix the $name leak" }
+          return@post
+        }
+
+        application.onActivityDestroyed {
+          try {
+            field.set(null, null)
+          } catch (ignored: Exception) {
+            SharkLog.d(ignored) { "Could not fix the $name leak" }
+          }
+        }
+      }
+    }
+  },
+
+  /**
+   * Samsung added a static mContext field to ActivityManager, holding a reference to the activity.
+   *
+   * This fix clears the field when an activity is destroyed if it refers to this specific activity.
+   *
+   * Observed here: https://github.com/square/leakcanary/issues/177
+   */
+  ACTIVITY_MANAGER {
+    override fun apply(application: Application) {
+      if (MANUFACTURER != SAMSUNG || SDK_INT != 22) {
+        return
+      }
+
+      backgroundHandler.post {
+        val contextField: Field
+        try {
+          contextField = application
+            .getSystemService(Context.ACTIVITY_SERVICE)
+            .javaClass
+            .getDeclaredField("mContext")
+          contextField.isAccessible = true
+          if ((contextField.modifiers or Modifier.STATIC) != contextField.modifiers) {
+            SharkLog.d { "Could not fix the $name leak, contextField=$contextField" }
+            return@post
+          }
+        } catch (ignored: Exception) {
+          SharkLog.d(ignored) { "Could not fix the $name leak" }
+          return@post
+        }
+
+        application.onActivityDestroyed { activity ->
+          try {
+            if (contextField.get(null) == activity) {
+              contextField.set(null, null)
+            }
+          } catch (ignored: Exception) {
+            SharkLog.d(ignored) { "Could not fix the $name leak" }
+          }
+        }
+      }
+    }
+  },
+
+  /**
+   * In Android P, ViewLocationHolder has an mRoot field that is not cleared in its clear() method.
+   * Introduced in https://github.com/aosp-mirror/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909d
+   *
+   * This leaks triggers very often when accessibility is on. To fix this leak we need to clear
+   * the ViewGroup.ViewLocationHolder.sPool pool. Unfortunately Android P prevents accessing that
+   * field through reflection. So instead, we call [ViewGroup#addChildrenForAccessibility] with
+   * a view group that has 32 children (32 being the pool size), which as result fills in the pool
+   * with 32 dumb views that reference a dummy context instead of an activity context.
+   *
+   * This fix empties the pool on every activity destroy and every AndroidX fragment view destroy.
+   * You can support other cases where views get detached by calling directly
+   * [ViewLocationHolderLeakFix.clearStaticPool].
+   */
+  VIEW_LOCATION_HOLDER {
+    override fun apply(application: Application) {
+      ViewLocationHolderLeakFix.applyFix(application)
+    }
+  },
+
+  /**
+   * Fix for https://code.google.com/p/android/issues/detail?id=171190 .
+   *
+   * When a view that has focus gets detached, we wait for the main thread to be idle and then
+   * check if the InputMethodManager is leaking a view. If yes, we tell it that the decor view got
+   * focus, which is what happens if you press home and come back from recent apps. This replaces
+   * the reference to the detached view with a reference to the decor view.
+   */
+  IMM_FOCUSED_VIEW {
+    // mServedView should not be accessed on API 29+. Make this clear to Lint with the
+    // TargetApi annotation.
+    @TargetApi(23)
+    @SuppressLint("PrivateApi")
+    override fun apply(application: Application) {
+      // Fixed in API 24.
+      if (SDK_INT > 23) {
+        return
+      }
+      val inputMethodManager =
+        application.getSystemService(INPUT_METHOD_SERVICE) as InputMethodManager
+      val mServedViewField: Field
+      val mHField: Field
+      val finishInputLockedMethod: Method
+      val focusInMethod: Method
+      try {
+        mServedViewField =
+          InputMethodManager::class.java.getDeclaredField("mServedView")
+        mServedViewField.isAccessible = true
+        mHField = InputMethodManager::class.java.getDeclaredField("mH")
+        mHField.isAccessible = true
+        finishInputLockedMethod =
+          InputMethodManager::class.java.getDeclaredMethod("finishInputLocked")
+        finishInputLockedMethod.isAccessible = true
+        focusInMethod = InputMethodManager::class.java.getDeclaredMethod(
+          "focusIn", View::class.java
+        )
+        focusInMethod.isAccessible = true
+      } catch (ignored: Exception) {
+        SharkLog.d(ignored) { "Could not fix the $name leak" }
+        return
+      }
+      application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks
+      by noOpDelegate() {
+        override fun onActivityCreated(
+          activity: Activity,
+          savedInstanceState: Bundle?
+        ) {
+          activity.window.onDecorViewReady {
+            val cleaner = ReferenceCleaner(
+              inputMethodManager,
+              mHField,
+              mServedViewField,
+              finishInputLockedMethod
+            )
+            val rootView = activity.window.decorView.rootView
+            val viewTreeObserver = rootView.viewTreeObserver
+            viewTreeObserver.addOnGlobalFocusChangeListener(cleaner)
+          }
+        }
+      })
+    }
+  },
+
+  /**
+   * When an activity is destroyed, the corresponding ViewRootImpl instance is released and ready to
+   * be garbage collected.
+   * Some time after that, ViewRootImpl#W receives a windowfocusChanged() callback, which it
+   * normally delegates to ViewRootImpl which in turn calls
+   * InputMethodManager#onPreWindowFocus which clears InputMethodManager#mCurRootView.
+   *
+   * Unfortunately, since the ViewRootImpl instance is garbage collectable it may be garbage
+   * collected before that happens.
+   * ViewRootImpl#W has a weak reference on ViewRootImpl, so that weak reference will then return
+   * null and the windowfocusChanged() callback will be ignored, leading to
+   * InputMethodManager#mCurRootView not being cleared.
+   *
+   * Filed here: https://issuetracker.google.com/u/0/issues/116078227
+   * Fixed here: https://android.googlesource.com/platform/frameworks/base/+/dff365ef4dc61239fac70953b631e92972a9f41f%5E%21/#F0
+   * InputMethodManager.mCurRootView is part of the unrestricted grey list on Android 9:
+   * https://android.googlesource.com/platform/frameworks/base/+/pie-release/config/hiddenapi-light-greylist.txt#6057
+   */
+  IMM_CUR_ROOT_VIEW {
+    override fun apply(application: Application) {
+      if (SDK_INT >= 29) {
+        return
+      }
+      val inputMethodManager = try {
+        application.getSystemService(INPUT_METHOD_SERVICE) as InputMethodManager
+      } catch (ignored: Throwable) {
+        // https://github.com/square/leakcanary/issues/2140
+        SharkLog.d(ignored) { "Could not retrieve InputMethodManager service" }
+        return
+      }
+      val mCurRootViewField = try {
+        InputMethodManager::class.java.getDeclaredField("mCurRootView").apply {
+          isAccessible = true
+        }
+      } catch (ignored: Throwable) {
+        SharkLog.d(ignored) { "Could not read InputMethodManager.mCurRootView field" }
+        return
+      }
+      // Clear InputMethodManager.mCurRootView on activity destroy
+      application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks
+      by noOpDelegate() {
+        override fun onActivityDestroyed(activity: Activity) {
+          try {
+            val rootView = mCurRootViewField[inputMethodManager] as View?
+            val isDestroyedActivity = rootView != null &&
+              activity.window != null &&
+              activity.window.decorView === rootView
+            val rootViewActivityContext = rootView?.context?.activityOrNull
+            val isChildWindowOfDestroyedActivity = rootViewActivityContext === activity
+            if (isDestroyedActivity || isChildWindowOfDestroyedActivity) {
+              mCurRootViewField[inputMethodManager] = null
+            }
+          } catch (ignored: Throwable) {
+            SharkLog.d(ignored) { "Could not update InputMethodManager.mCurRootView field" }
+          }
+        }
+      })
+      // Clear InputMethodManager.mCurRootView on window removal (e.g. dialog dismiss)
+      Curtains.onRootViewsChangedListeners += OnRootViewRemovedListener { removedRootView ->
+        val immRootView = mCurRootViewField[inputMethodManager] as View?
+        if (immRootView === removedRootView) {
+          mCurRootViewField[inputMethodManager] = null
+        }
+      }
+    }
+
+    private val Context.activityOrNull: Activity?
+      get() {
+        var context = this
+        while (true) {
+          if (context is Application) {
+            return null
+          }
+          if (context is Activity) {
+            return context
+          }
+          if (context is ContextWrapper) {
+            val baseContext = context.baseContext
+            // Prevent Stack Overflow.
+            if (baseContext === this) {
+              return null
+            }
+            context = baseContext
+          } else {
+            return null
+          }
+        }
+      }
+  },
+
+  /**
+   * Every editable TextView has an Editor instance which has a SpellChecker instance. SpellChecker
+   * is in charge of displaying the little squiggle spans that show typos. SpellChecker starts a
+   * SpellCheckerSession as needed and then closes it when the TextView is detached from the window.
+   * A SpellCheckerSession is in charge of communicating with the spell checker service (which lives
+   * in another process) through TextServicesManager.
+   *
+   * The SpellChecker sends the TextView content to the spell checker service every 400ms, ie every
+   * time the service calls back with a result the SpellChecker schedules another check for 400ms
+   * later.
+   *
+   * When the TextView is detached from the window, the spell checker closes the session. In practice,
+   * SpellCheckerSessionListenerImpl.mHandler is set to null and when the service calls
+   * SpellCheckerSessionListenerImpl.onGetSuggestions or
+   * SpellCheckerSessionListenerImpl.onGetSentenceSuggestions back from another process, there's a
+   * null check for SpellCheckerSessionListenerImpl.mHandler and the callback is dropped.
+   *
+   * Unfortunately, on Android M there's a race condition in how that's done. When the service calls
+   * back into our app process, the IPC call is received on a binder thread. That's when the null
+   * check happens. If the session is not closed at this point (mHandler not null), the callback is
+   * then posted to the main thread. If on the main thread the session is closed after that post but
+   * prior to that post being handled, then the post will still be processed, after the session has
+   * been closed.
+   *
+   * When the post is processed, SpellCheckerSession calls back into SpellChecker which in turns
+   * schedules a new spell check to be ran in 400ms. The check is an anonymous inner class
+   * (SpellChecker$1) stored as SpellChecker.mSpellRunnable and implementing Runnable. It is scheduled
+   * by calling [View.postDelayed]. As we've seen, at this point the session may be closed which means
+   * that the view has been detached. [View.postDelayed] behaves differently when a view is detached:
+   * instead of posting to the single [Handler] used by the view hierarchy, it enqueues the Runnable
+   * into ViewRootImpl.RunQueue, a static queue that holds on to "actions" to be executed. As soon as
+   * a view hierarchy is attached, the ViewRootImpl.RunQueue is processed and emptied.
+   *
+   * Unfortunately, that means that as long as no view hierarchy is attached, ie as long as there
+   * are no activities alive, the actions stay in ViewRootImpl.RunQueue. That means SpellChecker$1
+   * ends up being kept in memory. It holds on to SpellChecker which in turns holds on
+   * to the detached TextView and corresponding destroyed activity & view hierarchy.
+   *
+   * We have a fix for this! When the spell check session is closed, we replace
+   * SpellCheckerSession.mSpellCheckerSessionListener (which normally is the SpellChecker) with a
+   * no-op implementation. So even if callbacks are enqueued to the main thread handler, these
+   * callbacks will call the no-op implementation and SpellChecker will not be scheduling a spell
+   * check.
+   *
+   * Sources to corroborate:
+   *
+   * https://android.googlesource.com/platform/frameworks/base/+/marshmallow-release/core/java/android/view/textservice/SpellCheckerSession.java
+   * https://android.googlesource.com/platform/frameworks/base/+/marshmallow-release/core/java/android/view/textservice/TextServicesManager.java
+   * https://android.googlesource.com/platform/frameworks/base/+/marshmallow-release/core/java/android/widget/SpellChecker.java
+   * https://android.googlesource.com/platform/frameworks/base/+/marshmallow-release/core/java/android/view/ViewRootImpl.java
+   */
+  SPELL_CHECKER {
+    @TargetApi(23)
+    @SuppressLint("PrivateApi")
+    override fun apply(application: Application) {
+      if (SDK_INT != 23) {
+        return
+      }
+
+      try {
+        val textServiceClass = TextServicesManager::class.java
+        val getInstanceMethod = textServiceClass.getDeclaredMethod("getInstance")
+
+        val sServiceField = textServiceClass.getDeclaredField("sService")
+        sServiceField.isAccessible = true
+
+        val serviceStubInterface =
+          Class.forName("com.android.internal.textservice.ITextServicesManager")
+
+        val spellCheckSessionClass = Class.forName("android.view.textservice.SpellCheckerSession")
+        val mSpellCheckerSessionListenerField =
+          spellCheckSessionClass.getDeclaredField("mSpellCheckerSessionListener")
+        mSpellCheckerSessionListenerField.isAccessible = true
+
+        val spellCheckerSessionListenerImplClass =
+          Class.forName(
+            "android.view.textservice.SpellCheckerSession\$SpellCheckerSessionListenerImpl"
+          )
+        val listenerImplHandlerField =
+          spellCheckerSessionListenerImplClass.getDeclaredField("mHandler")
+        listenerImplHandlerField.isAccessible = true
+
+        val spellCheckSessionHandlerClass =
+          Class.forName("android.view.textservice.SpellCheckerSession\$1")
+        val outerInstanceField = spellCheckSessionHandlerClass.getDeclaredField("this$0")
+        outerInstanceField.isAccessible = true
+
+        val listenerInterface =
+          Class.forName("android.view.textservice.SpellCheckerSession\$SpellCheckerSessionListener")
+        val noOpListener = Proxy.newProxyInstance(
+          listenerInterface.classLoader, arrayOf(listenerInterface)
+        ) { _: Any, _: Method, _: kotlin.Array<Any>? ->
+          SharkLog.d { "Received call to no-op SpellCheckerSessionListener after session closed" }
+        }
+
+        // Ensure a TextServicesManager instance is created and TextServicesManager.sService set.
+        getInstanceMethod
+          .invoke(null)
+        val realService = sServiceField[null]!!
+
+        val spellCheckerListenerToSession = mutableMapOf<Any, Any>()
+
+        val proxyService = Proxy.newProxyInstance(
+          serviceStubInterface.classLoader, arrayOf(serviceStubInterface)
+        ) { _: Any, method: Method, args: kotlin.Array<Any>? ->
+          try {
+            if (method.name == "getSpellCheckerService") {
+              // getSpellCheckerService is called when the session is opened, which allows us to
+              // capture the corresponding SpellCheckerSession instance via
+              // SpellCheckerSessionListenerImpl.mHandler.this$0
+              val spellCheckerSessionListener = args!![3]
+              val handler = listenerImplHandlerField[spellCheckerSessionListener]!!
+              val spellCheckerSession = outerInstanceField[handler]!!
+              // We add to a map of SpellCheckerSessionListenerImpl to SpellCheckerSession
+              spellCheckerListenerToSession[spellCheckerSessionListener] = spellCheckerSession
+            } else if (method.name == "finishSpellCheckerService") {
+              // finishSpellCheckerService is called when the session is open. After the session has been
+              // closed, any pending work posted to SpellCheckerSession.mHandler should be ignored. We do
+              // so by replacing mSpellCheckerSessionListener with a no-op implementation.
+              val spellCheckerSessionListener = args!![0]
+              val spellCheckerSession =
+                spellCheckerListenerToSession.remove(spellCheckerSessionListener)!!
+              // We use the SpellCheckerSessionListenerImpl to find the corresponding SpellCheckerSession
+              // At this point in time the session was just closed to
+              // SpellCheckerSessionListenerImpl.mHandler is null, which is why we had to capture
+              // the SpellCheckerSession during the getSpellCheckerService call.
+              mSpellCheckerSessionListenerField[spellCheckerSession] = noOpListener
+            }
+          } catch (ignored: Exception) {
+            SharkLog.d(ignored) { "Unable to fix SpellChecker leak" }
+          }
+          // Standard delegation
+          try {
+            return@newProxyInstance if (args != null) {
+              method.invoke(realService, *args)
+            } else {
+              method.invoke(realService)
+            }
+          } catch (invocationException: InvocationTargetException) {
+            throw invocationException.targetException
+          }
+        }
+        sServiceField[null] = proxyService
+      } catch (ignored: Exception) {
+        SharkLog.d(ignored) { "Unable to fix SpellChecker leak" }
+      }
+    }
+  }
+
+  ;
+
+  protected abstract fun apply(application: Application)
+
+  private var applied = false
+
+  companion object {
+
+    private const val SAMSUNG = "samsung"
+    private const val LG = "LGE"
+
+    fun applyFixes(
+      application: Application,
+      fixes: Set<AndroidLeakFixes> = EnumSet.allOf(AndroidLeakFixes::class.java)
+    ) {
+      checkMainThread()
+      fixes.forEach { fix ->
+        if (!fix.applied) {
+          fix.apply(application)
+          fix.applied = true
+        } else {
+          SharkLog.d { "${fix.name} leak fix already applied." }
+        }
+      }
+    }
+
+    internal val backgroundHandler by lazy {
+      val handlerThread = HandlerThread("plumber-android-leaks")
+      handlerThread.start()
+      Handler(handlerThread.looper)
+    }
+
+    private fun Handler.onEachIdle(onIdle: () -> Unit) {
+      try {
+        // Unfortunately Looper.getQueue() is API 23. Looper.myQueue() is API 1.
+        // So we have to post to the handler thread to be able to obtain the queue for that
+        // thread from within that thread.
+        post {
+          Looper
+            .myQueue()
+            .addIdleHandler {
+              onIdle()
+              true
+            }
+        }
+      } catch (ignored: RuntimeException) {
+        // If the thread is quitting, posting to it will throw. There is no safe and atomic way
+        // to check if a thread is quitting first then post it it.
+      }
+    }
+
+    private fun findAllHandlerThreads(): List<HandlerThread> {
+      // Based on https://stackoverflow.com/a/1323480
+      var rootGroup = Thread.currentThread().threadGroup!!
+      while (rootGroup.parent != null) rootGroup = rootGroup.parent
+      var threads = arrayOfNulls<Thread>(rootGroup.activeCount())
+      while (rootGroup.enumerate(threads, true) == threads.size) {
+        threads = arrayOfNulls(threads.size * 2)
+      }
+      return threads.mapNotNull { if (it is HandlerThread) it else null }
+    }
+
+    internal fun Application.onActivityDestroyed(block: (Activity) -> Unit) {
+      registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks
+      by noOpDelegate() {
+        override fun onActivityDestroyed(activity: Activity) {
+          block(activity)
+        }
+      })
+    }
+
+    private fun Window.onDecorViewReady(callback: () -> Unit) {
+      if (peekDecorView() == null) {
+        onContentChanged {
+          callback()
+          return@onContentChanged false
+        }
+      } else {
+        callback()
+      }
+    }
+
+    private fun Window.onContentChanged(block: () -> Boolean) {
+      val callback = wrapCallback()
+      callback.onContentChangedCallbacks += block
+    }
+
+    private fun Window.wrapCallback(): WindowDelegateCallback {
+      val currentCallback = callback
+      return if (currentCallback is WindowDelegateCallback) {
+        currentCallback
+      } else {
+        val newCallback = WindowDelegateCallback(currentCallback)
+        callback = newCallback
+        newCallback
+      }
+    }
+
+    private class WindowDelegateCallback constructor(
+      private val delegate: Window.Callback
+    ) : FixedWindowCallback(delegate) {
+
+      val onContentChangedCallbacks = mutableListOf<() -> Boolean>()
+
+      override fun onContentChanged() {
+        onContentChangedCallbacks.removeAll { callback ->
+          !callback()
+        }
+        delegate.onContentChanged()
+      }
+    }
+  }
+}
diff --git a/plumber-android-core/src/main/java/leakcanary/FixedWindowCallback.java b/plumber-android-core/src/main/java/leakcanary/FixedWindowCallback.java
new file mode 100644
index 00000000..533d4e7b
--- /dev/null
+++ b/plumber-android-core/src/main/java/leakcanary/FixedWindowCallback.java
@@ -0,0 +1,141 @@
+package leakcanary;
+
+import android.view.ActionMode;
+import android.view.KeyEvent;
+import android.view.KeyboardShortcutGroup;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.MotionEvent;
+import android.view.SearchEvent;
+import android.view.View;
+import android.view.Window;
+import android.view.WindowManager;
+import android.view.accessibility.AccessibilityEvent;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
+import java.util.List;
+
+/**
+ * Implementation of Window.Callback that updates the signature of
+ * {@link #onMenuOpened(int, Menu)} to change the menu param from
+ * non null to nullable to avoid runtime null check crashes.
+ * Issue: https://issuetracker.google.com/issues/188568911
+ */
+class FixedWindowCallback implements Window.Callback {
+
+  private final Window.Callback delegate;
+
+  FixedWindowCallback(@NonNull Window.Callback delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public boolean dispatchKeyEvent(KeyEvent event) {
+    return delegate.dispatchKeyEvent(event);
+  }
+
+  @Override public boolean dispatchKeyShortcutEvent(KeyEvent event) {
+    return delegate.dispatchKeyShortcutEvent(event);
+  }
+
+  @Override public boolean dispatchTouchEvent(MotionEvent event) {
+    return delegate.dispatchTouchEvent(event);
+  }
+
+  @Override public boolean dispatchTrackballEvent(MotionEvent event) {
+    return delegate.dispatchTrackballEvent(event);
+  }
+
+  @Override public boolean dispatchGenericMotionEvent(MotionEvent event) {
+    return delegate.dispatchGenericMotionEvent(event);
+  }
+
+  @Override public boolean dispatchPopulateAccessibilityEvent(
+      AccessibilityEvent event) {
+    return delegate.dispatchPopulateAccessibilityEvent(event);
+  }
+
+  @Nullable @Override public View onCreatePanelView(int featureId) {
+    return delegate.onCreatePanelView(featureId);
+  }
+
+  @Override public boolean onCreatePanelMenu(int featureId, @NonNull Menu menu) {
+    return delegate.onCreatePanelMenu(featureId, menu);
+  }
+
+  @Override public boolean onPreparePanel(int featureId, @Nullable View view,
+      @NonNull Menu menu) {
+    return delegate.onPreparePanel(featureId, view, menu);
+  }
+
+  @Override public boolean onMenuOpened(int featureId, @Nullable Menu menu) {
+    return delegate.onMenuOpened(featureId, menu);
+  }
+
+  @Override public boolean onMenuItemSelected(int featureId,
+      @NonNull MenuItem item) {
+    return delegate.onMenuItemSelected(featureId, item);
+  }
+
+  @Override public void onWindowAttributesChanged(WindowManager.LayoutParams attrs) {
+    delegate.onWindowAttributesChanged(attrs);
+  }
+
+  @Override public void onContentChanged() {
+    delegate.onContentChanged();
+  }
+
+  @Override public void onWindowFocusChanged(boolean hasFocus) {
+    delegate.onWindowFocusChanged(hasFocus);
+  }
+
+  @Override public void onAttachedToWindow() {
+    delegate.onAttachedToWindow();
+  }
+
+  @Override public void onDetachedFromWindow() {
+    delegate.onDetachedFromWindow();
+  }
+
+  @Override public void onPanelClosed(int featureId, @NonNull Menu menu) {
+    delegate.onPanelClosed(featureId, menu);
+  }
+
+  @Override public boolean onSearchRequested() {
+    return delegate.onSearchRequested();
+  }
+
+  @RequiresApi(23)
+  @Override public boolean onSearchRequested(SearchEvent searchEvent) {
+    return delegate.onSearchRequested(searchEvent);
+  }
+
+  @Nullable @Override public ActionMode onWindowStartingActionMode(ActionMode.Callback callback) {
+    return delegate.onWindowStartingActionMode(callback);
+  }
+
+  @RequiresApi(23) @Nullable @Override
+  public ActionMode onWindowStartingActionMode(ActionMode.Callback callback,
+      int type) {
+    return delegate.onWindowStartingActionMode(callback, type);
+  }
+
+  @Override public void onActionModeStarted(ActionMode mode) {
+    delegate.onActionModeStarted(mode);
+  }
+
+  @Override public void onActionModeFinished(ActionMode mode) {
+    delegate.onActionModeFinished(mode);
+  }
+
+  @RequiresApi(24)
+  @Override public void onProvideKeyboardShortcuts(List<KeyboardShortcutGroup> data,
+      @Nullable Menu menu, int deviceId) {
+    delegate.onProvideKeyboardShortcuts(data, menu, deviceId);
+  }
+
+  @RequiresApi(26)
+  @Override public void onPointerCaptureChanged(boolean hasCapture) {
+    delegate.onPointerCaptureChanged(hasCapture);
+  }
+}
diff --git a/plumber-android-core/src/main/java/leakcanary/ViewLocationHolderLeakFix.kt b/plumber-android-core/src/main/java/leakcanary/ViewLocationHolderLeakFix.kt
new file mode 100644
index 00000000..21384e5c
--- /dev/null
+++ b/plumber-android-core/src/main/java/leakcanary/ViewLocationHolderLeakFix.kt
@@ -0,0 +1,91 @@
+package leakcanary
+
+import android.annotation.SuppressLint
+import android.app.Activity
+import android.app.Application
+import android.os.Build.VERSION
+import android.os.Bundle
+import android.view.View
+import android.view.ViewGroup
+import android.widget.FrameLayout
+import curtains.Curtains
+import curtains.OnRootViewRemovedListener
+import leakcanary.internal.friendly.checkMainThread
+import leakcanary.internal.friendly.isMainThread
+import leakcanary.internal.friendly.mainHandler
+import leakcanary.internal.friendly.noOpDelegate
+import leakcanary.internal.onAndroidXFragmentViewDestroyed
+import shark.SharkLog
+
+/**
+ * @see [AndroidLeakFixes.VIEW_LOCATION_HOLDER].
+ */
+@SuppressLint("NewApi")
+object ViewLocationHolderLeakFix {
+
+  private var groupAndOutChildren: Pair<ViewGroup, ArrayList<View>>? = null
+  private var failedClearing = false
+
+  internal fun applyFix(application: Application) {
+    if (VERSION.SDK_INT != 28) {
+      return
+    }
+    // Takes care of child windows (e.g. dialogs)
+    Curtains.onRootViewsChangedListeners += OnRootViewRemovedListener {
+      if (isMainThread) {
+        uncheckedClearStaticPool(application)
+      } else {
+        mainHandler.post {
+          uncheckedClearStaticPool(application)
+        }
+      }
+    }
+    application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks
+    by noOpDelegate() {
+
+      override fun onActivityCreated(
+        activity: Activity,
+        savedInstanceState: Bundle?
+      ) {
+        activity.onAndroidXFragmentViewDestroyed {
+          uncheckedClearStaticPool(application)
+        }
+      }
+    })
+  }
+
+  /**
+   * Clears the ViewGroup.ViewLocationHolder.sPool static pool.
+   */
+  fun clearStaticPool(application: Application) {
+    checkMainThread()
+    if (VERSION.SDK_INT != 28) {
+      return
+    }
+    uncheckedClearStaticPool(application)
+  }
+
+  private fun uncheckedClearStaticPool(application: Application) {
+    if (failedClearing) {
+      return
+    }
+    try {
+      if (groupAndOutChildren == null) {
+        val viewGroup = FrameLayout(application)
+        // ViewLocationHolder.MAX_POOL_SIZE = 32
+        for (i in 0 until 32) {
+          val childView = View(application)
+          viewGroup.addView(childView)
+        }
+        groupAndOutChildren = viewGroup to ArrayList()
+      }
+      val (group, outChildren) = groupAndOutChildren!!
+      group.addChildrenForAccessibility(outChildren)
+    } catch (ignored: Throwable) {
+      SharkLog.d(ignored) {
+        "Failed to clear ViewLocationHolder leak, will not try again."
+      }
+      failedClearing = true
+    }
+  }
+}
diff --git a/plumber-android-core/src/main/java/leakcanary/internal/FragmentExtensions.kt b/plumber-android-core/src/main/java/leakcanary/internal/FragmentExtensions.kt
new file mode 100644
index 00000000..32fc43f0
--- /dev/null
+++ b/plumber-android-core/src/main/java/leakcanary/internal/FragmentExtensions.kt
@@ -0,0 +1,33 @@
+package leakcanary.internal
+
+import android.app.Activity
+import androidx.fragment.app.Fragment
+import androidx.fragment.app.FragmentActivity
+import androidx.fragment.app.FragmentManager
+
+private val hasAndroidXFragmentActivity: Boolean by lazy {
+  try {
+    Class.forName("androidx.fragment.app.FragmentActivity")
+    true
+  } catch (ignored: Throwable) {
+    false
+  }
+}
+
+internal fun Activity.onAndroidXFragmentViewDestroyed(block: () -> Unit) {
+  if (!hasAndroidXFragmentActivity) {
+    return
+  }
+  if (this is FragmentActivity) {
+    supportFragmentManager.registerFragmentLifecycleCallbacks(
+      object : FragmentManager.FragmentLifecycleCallbacks() {
+        override fun onFragmentViewDestroyed(
+          fm: FragmentManager,
+          fragment: Fragment
+        ) {
+          block()
+        }
+      }, true
+    )
+  }
+}
diff --git a/plumber-android-core/src/main/java/leakcanary/internal/ReferenceCleaner.kt b/plumber-android-core/src/main/java/leakcanary/internal/ReferenceCleaner.kt
new file mode 100644
index 00000000..c68d0346
--- /dev/null
+++ b/plumber-android-core/src/main/java/leakcanary/internal/ReferenceCleaner.kt
@@ -0,0 +1,122 @@
+package leakcanary.internal
+
+import android.app.Activity
+import android.app.Application
+import android.content.Context
+import android.content.ContextWrapper
+import android.os.Looper
+import android.os.MessageQueue.IdleHandler
+import android.view.View
+import android.view.View.OnAttachStateChangeListener
+import android.view.ViewTreeObserver.OnGlobalFocusChangeListener
+import android.view.inputmethod.InputMethodManager
+import java.lang.reflect.Field
+import java.lang.reflect.Method
+import shark.SharkLog
+
+internal class ReferenceCleaner(
+  private val inputMethodManager: InputMethodManager,
+  private val mHField: Field,
+  private val mServedViewField: Field,
+  private val finishInputLockedMethod: Method
+) : IdleHandler,
+  OnAttachStateChangeListener,
+  OnGlobalFocusChangeListener {
+  override fun onGlobalFocusChanged(
+    oldFocus: View?,
+    newFocus: View?
+  ) {
+    if (newFocus == null) {
+      return
+    }
+    oldFocus?.removeOnAttachStateChangeListener(this)
+    Looper.myQueue()
+      .removeIdleHandler(this)
+    newFocus.addOnAttachStateChangeListener(this)
+  }
+
+  override fun onViewAttachedToWindow(v: View) {}
+  override fun onViewDetachedFromWindow(v: View) {
+    v.removeOnAttachStateChangeListener(this)
+    Looper.myQueue()
+      .removeIdleHandler(this)
+    Looper.myQueue()
+      .addIdleHandler(this)
+  }
+
+  override fun queueIdle(): Boolean {
+    clearInputMethodManagerLeak()
+    return false
+  }
+
+  private fun clearInputMethodManagerLeak() {
+    try {
+      val lock = mHField[inputMethodManager]
+      if (lock == null) {
+        SharkLog.d { "InputMethodManager.mH was null, could not fix leak." }
+        return
+      }
+      // This is highly dependent on the InputMethodManager implementation.
+      synchronized(lock) {
+        val servedView =
+          mServedViewField[inputMethodManager] as View?
+        if (servedView != null) {
+          val servedViewAttached =
+            servedView.windowVisibility != View.GONE
+          if (servedViewAttached) {
+            // The view held by the IMM was replaced without a global focus change. Let's make
+            // sure we get notified when that view detaches.
+            // Avoid double registration.
+            servedView.removeOnAttachStateChangeListener(this)
+            servedView.addOnAttachStateChangeListener(this)
+          } else { // servedView is not attached. InputMethodManager is being stupid!
+            val activity = extractActivity(servedView.context)
+            if (activity == null || activity.window == null) {
+              // Unlikely case. Let's finish the input anyways.
+              finishInputLockedMethod.invoke(inputMethodManager)
+            } else {
+              val decorView = activity.window
+                .peekDecorView()
+              val windowAttached =
+                decorView.windowVisibility != View.GONE
+              // If the window is attached, we do nothing. The IMM is leaking a detached view
+              // hierarchy, but we haven't found a way to clear the reference without breaking
+              // the IMM behavior.
+              if (!windowAttached) {
+                finishInputLockedMethod.invoke(inputMethodManager)
+              }
+            }
+          }
+        }
+      }
+    } catch (ignored: Throwable) {
+      SharkLog.d(ignored) { "Could not fix leak" }
+    }
+  }
+
+  private fun extractActivity(sourceContext: Context): Activity? {
+    var context = sourceContext
+    while (true) {
+      context = when (context) {
+        is Application -> {
+          return null
+        }
+        is Activity -> {
+          return context
+        }
+        is ContextWrapper -> {
+          val baseContext =
+            context.baseContext
+          // Prevent Stack Overflow.
+          if (baseContext === context) {
+            return null
+          }
+          baseContext
+        }
+        else -> {
+          return null
+        }
+      }
+    }
+  }
+}
diff --git a/plumber-android-core/src/main/java/leakcanary/internal/friendly/Friendly.kt b/plumber-android-core/src/main/java/leakcanary/internal/friendly/Friendly.kt
new file mode 100644
index 00000000..f275977c
--- /dev/null
+++ b/plumber-android-core/src/main/java/leakcanary/internal/friendly/Friendly.kt
@@ -0,0 +1,16 @@
+@file:Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER", "NOTHING_TO_INLINE")
+@file:JvmName("plumber-android_Friendly")
+
+package leakcanary.internal.friendly
+
+import android.os.Handler
+
+internal inline fun checkMainThread() = leakcanary.internal.checkMainThread()
+
+internal inline fun <reified T : Any> noOpDelegate(): T = leakcanary.internal.noOpDelegate()
+
+internal inline val mainHandler: Handler
+  get() = leakcanary.internal.mainHandler
+
+internal inline val isMainThread: Boolean
+  get() = leakcanary.internal.isMainThread
diff --git a/plumber-android-startup/api/plumber-android-startup.api b/plumber-android-startup/api/plumber-android-startup.api
new file mode 100644
index 00000000..77e8a4ff
--- /dev/null
+++ b/plumber-android-startup/api/plumber-android-startup.api
@@ -0,0 +1,7 @@
+public final class leakcanary/PlumberStartupInitializer : androidx/startup/Initializer {
+	public fun <init> ()V
+	public synthetic fun create (Landroid/content/Context;)Ljava/lang/Object;
+	public fun create (Landroid/content/Context;)Lleakcanary/PlumberStartupInitializer;
+	public fun dependencies ()Ljava/util/List;
+}
+
diff --git a/plumber-android-startup/build.gradle b/plumber-android-startup/build.gradle
new file mode 100644
index 00000000..29378cf2
--- /dev/null
+++ b/plumber-android-startup/build.gradle
@@ -0,0 +1,26 @@
+plugins {
+  id("com.android.library")
+  id("org.jetbrains.kotlin.android")
+  id("com.vanniktech.maven.publish")
+}
+
+dependencies {
+  api projects.plumberAndroidCore
+
+  implementation libs.kotlin.stdlib
+  implementation libs.androidX.startup
+}
+
+android {
+  resourcePrefix 'leak_canary_plumber'
+  compileSdk versions.compileSdk
+  defaultConfig {
+    minSdk versions.minSdk
+  }
+  buildFeatures.buildConfig = false
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
+    checkOnly 'Interoperability'
+  }
+}
diff --git a/plumber-android-startup/gradle.properties b/plumber-android-startup/gradle.properties
new file mode 100644
index 00000000..cfa50e28
--- /dev/null
+++ b/plumber-android-startup/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=plumber-android-startup
+POM_NAME=AndroidX Startup config for plumber-android-core
+POM_PACKAGING=aar
diff --git a/plumber-android-startup/src/main/AndroidManifest.xml b/plumber-android-startup/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..e6f89448
--- /dev/null
+++ b/plumber-android-startup/src/main/AndroidManifest.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.squareup.leakcanary.plumber.startup">
+  <application>
+    <provider
+      android:name="androidx.startup.InitializationProvider"
+      android:authorities="${applicationId}.androidx-startup"
+      android:exported="false"
+      tools:node="merge">
+
+      <meta-data
+        android:name="leakcanary.PlumberStartupInitializer"
+        android:value="androidx.startup"/>
+    </provider>
+
+  </application>
+</manifest>
diff --git a/plumber-android-startup/src/main/java/leakcanary/PlumberStartupInitializer.kt b/plumber-android-startup/src/main/java/leakcanary/PlumberStartupInitializer.kt
new file mode 100644
index 00000000..146e78f2
--- /dev/null
+++ b/plumber-android-startup/src/main/java/leakcanary/PlumberStartupInitializer.kt
@@ -0,0 +1,13 @@
+package leakcanary
+
+import android.app.Application
+import android.content.Context
+import androidx.startup.Initializer
+
+class PlumberStartupInitializer : Initializer<PlumberStartupInitializer> {
+  override fun create(context: Context) = apply {
+    val application = context.applicationContext as Application
+    AndroidLeakFixes.applyFixes(application)
+  }
+  override fun dependencies() = emptyList<Class<out Initializer<*>>>()
+}
diff --git a/plumber-android/api/plumber-android.api b/plumber-android/api/plumber-android.api
new file mode 100644
index 00000000..e69de29b
diff --git a/plumber-android/build.gradle b/plumber-android/build.gradle
new file mode 100644
index 00000000..41b3b94a
--- /dev/null
+++ b/plumber-android/build.gradle
@@ -0,0 +1,26 @@
+plugins {
+  id("com.android.library")
+  id("org.jetbrains.kotlin.android")
+  id("com.vanniktech.maven.publish")
+}
+
+dependencies {
+  api projects.plumberAndroidCore
+
+  implementation libs.kotlin.stdlib
+}
+
+android {
+  resourcePrefix 'leak_canary_plumber'
+  compileSdk versions.compileSdk
+  defaultConfig {
+    minSdk versions.minSdk
+    consumerProguardFiles 'consumer-proguard-rules.pro'
+  }
+  buildFeatures.buildConfig = false
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
+    checkOnly 'Interoperability'
+  }
+}
diff --git a/plumber-android/consumer-proguard-rules.pro b/plumber-android/consumer-proguard-rules.pro
new file mode 100644
index 00000000..e0108df0
--- /dev/null
+++ b/plumber-android/consumer-proguard-rules.pro
@@ -0,0 +1,2 @@
+# A ContentProvider that gets created by Android on startup
+-keep class leakcanary.internal.PlumberInstaller { <init>(); }
diff --git a/plumber-android/gradle.properties b/plumber-android/gradle.properties
new file mode 100644
index 00000000..16cee90f
--- /dev/null
+++ b/plumber-android/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=plumber-android
+POM_NAME=Auto installer for plumber-android-core
+POM_PACKAGING=aar
diff --git a/plumber-android/src/main/AndroidManifest.xml b/plumber-android/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..4adb1233
--- /dev/null
+++ b/plumber-android/src/main/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary.plumber">
+  <application>
+    <provider
+        android:name="leakcanary.internal.PlumberInstaller"
+        android:authorities="${applicationId}.plumber-installer"
+        android:enabled="@bool/leak_canary_plumber_auto_install"
+        android:exported="false" />
+  </application>
+</manifest>
diff --git a/plumber-android/src/main/java/leakcanary/internal/PlumberInstaller.kt b/plumber-android/src/main/java/leakcanary/internal/PlumberInstaller.kt
new file mode 100644
index 00000000..18f8a67d
--- /dev/null
+++ b/plumber-android/src/main/java/leakcanary/internal/PlumberInstaller.kt
@@ -0,0 +1,39 @@
+package leakcanary.internal
+
+import android.app.Application
+import android.content.ContentProvider
+import android.content.ContentValues
+import android.database.Cursor
+import android.net.Uri
+import leakcanary.AndroidLeakFixes
+
+/**
+ * Content providers are loaded before the application class is created. [PlumberInstaller] is
+ * used to install [leakcanary.AndroidLeakFixes] fixes on application start.
+ */
+internal class PlumberInstaller : ContentProvider() {
+
+  override fun onCreate(): Boolean {
+    val application = context!!.applicationContext as Application
+    AndroidLeakFixes.applyFixes(application)
+    return true
+  }
+
+  override fun query(
+    uri: Uri,
+    projectionArg: Array<String>?,
+    selection: String?,
+    selectionArgs: Array<String>?,
+    sortOrder: String?
+  ): Cursor? = null
+
+  override fun getType(uri: Uri): String? = null
+
+  override fun insert(uri: Uri, contentValues: ContentValues?): Uri? = null
+
+  override fun delete(uri: Uri, selection: String?, selectionArgs: Array<out String>?): Int = 0
+
+  override fun update(
+    uri: Uri, values: ContentValues?, selection: String?, selectionArgs: Array<out String>?
+  ): Int = 0
+}
diff --git a/plumber-android/src/main/res/values/plumber_bools.xml b/plumber-android/src/main/res/values/plumber_bools.xml
new file mode 100644
index 00000000..39094792
--- /dev/null
+++ b/plumber-android/src/main/res/values/plumber_bools.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <bool name="leak_canary_plumber_auto_install">true</bool>
+</resources>
diff --git a/plumber-android/src/main/res/values/plumber_public.xml b/plumber-android/src/main/res/values/plumber_public.xml
new file mode 100644
index 00000000..5551381b
--- /dev/null
+++ b/plumber-android/src/main/res/values/plumber_public.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+
+  <public name="leak_canary_plumber_auto_install" type="bool"/>
+</resources>
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 00000000..baeb23d9
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1,28 @@
+include ':leakcanary-android'
+include ':leakcanary-android-core'
+include ':leakcanary-android-instrumentation'
+include ':leakcanary-android-process'
+include ':leakcanary-android-release'
+include ':leakcanary-android-sample'
+include ':leakcanary-android-startup'
+include ':leakcanary-android-utils'
+include ':leakcanary-object-watcher'
+include ':leakcanary-object-watcher-android'
+include ':leakcanary-object-watcher-android-androidx'
+include ':leakcanary-object-watcher-android-core'
+include ':leakcanary-object-watcher-android-startup'
+include ':leakcanary-object-watcher-android-support-fragments'
+include ':plumber-android'
+include ':plumber-android-core'
+include ':plumber-android-startup'
+include ':shark'
+include ':shark-android'
+include ':shark-cli'
+include ':shark-graph'
+include ':shark-hprof'
+include ':shark-hprof-test'
+include ':shark-log'
+include ':shark-test'
+include ':leakcanary-deobfuscation-gradle-plugin'
+
+enableFeaturePreview("TYPESAFE_PROJECT_ACCESSORS")
diff --git a/shark-android/api/shark-android.api b/shark-android/api/shark-android.api
new file mode 100644
index 00000000..fa6e6b11
--- /dev/null
+++ b/shark-android/api/shark-android.api
@@ -0,0 +1,215 @@
+public final class shark/AndroidBuildMirror {
+	public static final field Companion Lshark/AndroidBuildMirror$Companion;
+	public fun <init> (Ljava/lang/String;ILjava/lang/String;)V
+	public final fun getId ()Ljava/lang/String;
+	public final fun getManufacturer ()Ljava/lang/String;
+	public final fun getSdkInt ()I
+}
+
+public final class shark/AndroidBuildMirror$Companion {
+	public final fun fromHeapGraph (Lshark/HeapGraph;)Lshark/AndroidBuildMirror;
+}
+
+public final class shark/AndroidExtensionsKt {
+	public static final fun getHexIdentityHashCode (Lshark/HeapObject$HeapInstance;)Ljava/lang/String;
+	public static final fun getIdentityHashCode (Lshark/HeapObject$HeapInstance;)Ljava/lang/Integer;
+}
+
+public final class shark/AndroidMetadataExtractor : shark/MetadataExtractor {
+	public static final field INSTANCE Lshark/AndroidMetadataExtractor;
+	public fun extractMetadata (Lshark/HeapGraph;)Ljava/util/Map;
+}
+
+public abstract class shark/AndroidObjectInspectors : java/lang/Enum, shark/ObjectInspector {
+	public static final field ACTIVITY Lshark/AndroidObjectInspectors;
+	public static final field ACTIVITY_THREAD Lshark/AndroidObjectInspectors;
+	public static final field ANDROIDX_FRAGMENT Lshark/AndroidObjectInspectors;
+	public static final field ANIMATOR Lshark/AndroidObjectInspectors;
+	public static final field APPLICATION Lshark/AndroidObjectInspectors;
+	public static final field APPLICATION_PACKAGE_MANAGER Lshark/AndroidObjectInspectors;
+	public static final field COMPOSITION_IMPL Lshark/AndroidObjectInspectors;
+	public static final field CONTEXT_FIELD Lshark/AndroidObjectInspectors;
+	public static final field CONTEXT_IMPL Lshark/AndroidObjectInspectors;
+	public static final field CONTEXT_WRAPPER Lshark/AndroidObjectInspectors;
+	public static final field COORDINATOR Lshark/AndroidObjectInspectors;
+	public static final field Companion Lshark/AndroidObjectInspectors$Companion;
+	public static final field DIALOG Lshark/AndroidObjectInspectors;
+	public static final field EDITOR Lshark/AndroidObjectInspectors;
+	public static final field FRAGMENT Lshark/AndroidObjectInspectors;
+	public static final field INPUT_METHOD_MANAGER Lshark/AndroidObjectInspectors;
+	public static final field LIFECYCLE_REGISTRY Lshark/AndroidObjectInspectors;
+	public static final field LOADED_APK Lshark/AndroidObjectInspectors;
+	public static final field MAIN_THREAD Lshark/AndroidObjectInspectors;
+	public static final field MESSAGE Lshark/AndroidObjectInspectors;
+	public static final field MESSAGE_QUEUE Lshark/AndroidObjectInspectors;
+	public static final field MORTAR_PRESENTER Lshark/AndroidObjectInspectors;
+	public static final field MORTAR_SCOPE Lshark/AndroidObjectInspectors;
+	public static final field OBJECT_ANIMATOR Lshark/AndroidObjectInspectors;
+	public static final field RECOMPOSER Lshark/AndroidObjectInspectors;
+	public static final field SERVICE Lshark/AndroidObjectInspectors;
+	public static final field STUB Lshark/AndroidObjectInspectors;
+	public static final field SUPPORT_FRAGMENT Lshark/AndroidObjectInspectors;
+	public static final field TOAST Lshark/AndroidObjectInspectors;
+	public static final field VIEW Lshark/AndroidObjectInspectors;
+	public static final field VIEW_ROOT_IMPL Lshark/AndroidObjectInspectors;
+	public static final field WINDOW Lshark/AndroidObjectInspectors;
+	public synthetic fun <init> (Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public static fun valueOf (Ljava/lang/String;)Lshark/AndroidObjectInspectors;
+	public static fun values ()[Lshark/AndroidObjectInspectors;
+}
+
+public final class shark/AndroidObjectInspectors$Companion {
+	public final fun createLeakingObjectFilters (Ljava/util/Set;)Ljava/util/List;
+	public final fun getAppDefaults ()Ljava/util/List;
+	public final fun getAppLeakingObjectFilters ()Ljava/util/List;
+}
+
+public abstract class shark/AndroidReferenceMatchers : java/lang/Enum {
+	public static final field ACCESSIBILITY_ITERATORS Lshark/AndroidReferenceMatchers;
+	public static final field ACCESSIBILITY_NODE_ID_MANAGER Lshark/AndroidReferenceMatchers;
+	public static final field ACCESSIBILITY_NODE_INFO__MORIGINALTEXT Lshark/AndroidReferenceMatchers;
+	public static final field ACCOUNT_MANAGER__AMS_TASK__RESPONSE Lshark/AndroidReferenceMatchers;
+	public static final field ACTIVITY_CHOOSE_MODEL Lshark/AndroidReferenceMatchers;
+	public static final field ACTIVITY_MANAGER_MCONTEXT Lshark/AndroidReferenceMatchers;
+	public static final field ACTIVITY_THREAD__M_NEW_ACTIVITIES Lshark/AndroidReferenceMatchers;
+	public static final field ACTIVITY_TRANSITION_STATE__M_EXITING_TO_VIEW Lshark/AndroidReferenceMatchers;
+	public static final field ANIMATION_HANDLER__ANIMATOR_REQUESTORS Lshark/AndroidReferenceMatchers;
+	public static final field APPLICATION_PACKAGE_MANAGER__HAS_SYSTEM_FEATURE_QUERY Lshark/AndroidReferenceMatchers;
+	public static final field APP_OPS_MANAGER__CALLBACK_STUB Lshark/AndroidReferenceMatchers;
+	public static final field APP_WIDGET_HOST_CALLBACKS Lshark/AndroidReferenceMatchers;
+	public static final field ASSIST_STRUCTURE Lshark/AndroidReferenceMatchers;
+	public static final field AUDIO_MANAGER Lshark/AndroidReferenceMatchers;
+	public static final field AUDIO_MANAGER__MCONTEXT_STATIC Lshark/AndroidReferenceMatchers;
+	public static final field AW_CONTENTS_POSTED_CALLBACK Lshark/AndroidReferenceMatchers;
+	public static final field AW_CONTENTS__A0 Lshark/AndroidReferenceMatchers;
+	public static final field AW_RESOURCE__SRESOURCES Lshark/AndroidReferenceMatchers;
+	public static final field BACKDROP_FRAME_RENDERER__MDECORVIEW Lshark/AndroidReferenceMatchers;
+	public static final field BIOMETRIC_PROMPT Lshark/AndroidReferenceMatchers;
+	public static final field BLOCKING_QUEUE Lshark/AndroidReferenceMatchers;
+	public static final field BUBBLE_POPUP_HELPER__SHELPER Lshark/AndroidReferenceMatchers;
+	public static final field CLIPBOARD_EX_MANAGER Lshark/AndroidReferenceMatchers;
+	public static final field CLIPBOARD_UI_MANAGER__SINSTANCE Lshark/AndroidReferenceMatchers;
+	public static final field COMPANION_DEVICE_SERVICE__STUB Lshark/AndroidReferenceMatchers;
+	public static final field CONNECTIVITY_MANAGER_CALLBACK_HANDLER Lshark/AndroidReferenceMatchers;
+	public static final field CONNECTIVITY_MANAGER__SINSTANCE Lshark/AndroidReferenceMatchers;
+	public static final field CONTROLLED_INPUT_CONNECTION_WRAPPER Lshark/AndroidReferenceMatchers;
+	public static final field Companion Lshark/AndroidReferenceMatchers$Companion;
+	public static final field DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER Lshark/AndroidReferenceMatchers;
+	public static final field DREAM_SERVICE Lshark/AndroidReferenceMatchers;
+	public static final field EDITTEXT_BLINK_MESSAGEQUEUE Lshark/AndroidReferenceMatchers;
+	public static final field EVENT_RECEIVER__MMESSAGE_QUEUE Lshark/AndroidReferenceMatchers;
+	public static final field EXTENDED_STATUS_BAR_MANAGER Lshark/AndroidReferenceMatchers;
+	public static final field FINALIZER_WATCHDOG_DAEMON Lshark/AndroidReferenceMatchers;
+	public static final field FLIPPER__APPLICATION_DESCRIPTOR Lshark/AndroidReferenceMatchers;
+	public static final field GESTURE_BOOST_MANAGER Lshark/AndroidReferenceMatchers;
+	public static final field HMD_GLOBAL Ljava/lang/String;
+	public static final field HOST_ADPU_SERVICE_MSG_HANDLER Lshark/AndroidReferenceMatchers;
+	public static final field HUAWEI Ljava/lang/String;
+	public static final field IMM_CURRENT_INPUT_CONNECTION Lshark/AndroidReferenceMatchers;
+	public static final field IMM_LAST_FOCUS_VIEW Lshark/AndroidReferenceMatchers;
+	public static final field INFINIX Ljava/lang/String;
+	public static final field INPUT_MANAGER__M_LATE_INIT_CONTEXT Lshark/AndroidReferenceMatchers;
+	public static final field INPUT_METHOD_MANAGER_IS_TERRIBLE Lshark/AndroidReferenceMatchers;
+	public static final field INSTRUMENTATION_RECOMMEND_ACTIVITY Lshark/AndroidReferenceMatchers;
+	public static final field IREQUEST_FINISH_CALLBACK Lshark/AndroidReferenceMatchers;
+	public static final field JOB_SERVICE Lshark/AndroidReferenceMatchers;
+	public static final field LAYOUT_TRANSITION Lshark/AndroidReferenceMatchers;
+	public static final field LEAK_CANARY_HEAP_DUMPER Lshark/AndroidReferenceMatchers;
+	public static final field LEAK_CANARY_INTERNAL Lshark/AndroidReferenceMatchers;
+	public static final field LEAK_CANARY_THREAD Lshark/AndroidReferenceMatchers;
+	public static final field LENOVO Ljava/lang/String;
+	public static final field LG Ljava/lang/String;
+	public static final field LGCONTEXT__MCONTEXT Lshark/AndroidReferenceMatchers;
+	public static final field MAGNIFIER Lshark/AndroidReferenceMatchers;
+	public static final field MAIN Lshark/AndroidReferenceMatchers;
+	public static final field MAPPER_CLIENT Lshark/AndroidReferenceMatchers;
+	public static final field MEDIA_PROJECTION_CALLBACK Lshark/AndroidReferenceMatchers;
+	public static final field MEDIA_SCANNER_CONNECTION Lshark/AndroidReferenceMatchers;
+	public static final field MEDIA_SESSION_LEGACY_HELPER__SINSTANCE Lshark/AndroidReferenceMatchers;
+	public static final field MEIZU Ljava/lang/String;
+	public static final field MOTOROLA Ljava/lang/String;
+	public static final field MULTI_WINDOW_DECOR_SUPPORT__MWINDOW Lshark/AndroidReferenceMatchers;
+	public static final field NVIDIA Ljava/lang/String;
+	public static final field OEM_SCENE_CALL_BLOCKER Lshark/AndroidReferenceMatchers;
+	public static final field ONE_PLUS Ljava/lang/String;
+	public static final field PERF_MONITOR_LAST_CALLBACK Lshark/AndroidReferenceMatchers;
+	public static final field PERSONA_MANAGER Lshark/AndroidReferenceMatchers;
+	public static final field PLAYER_BASE Lshark/AndroidReferenceMatchers;
+	public static final field RAZER Ljava/lang/String;
+	public static final field RAZER_TEXT_KEY_LISTENER__MCONTEXT Lshark/AndroidReferenceMatchers;
+	public static final field REALME Ljava/lang/String;
+	public static final field REFERENCES Lshark/AndroidReferenceMatchers;
+	public static final field RENDER_NODE_ANIMATOR Lshark/AndroidReferenceMatchers;
+	public static final field RESOURCES__MCONTEXT Lshark/AndroidReferenceMatchers;
+	public static final field SAMSUNG Ljava/lang/String;
+	public static final field SEM_APP_ICON_SOLUTION Lshark/AndroidReferenceMatchers;
+	public static final field SEM_CLIPBOARD_MANAGER__MCONTEXT Lshark/AndroidReferenceMatchers;
+	public static final field SEM_EMERGENCY_MANAGER__MCONTEXT Lshark/AndroidReferenceMatchers;
+	public static final field SEM_PERSONA_MANAGER Lshark/AndroidReferenceMatchers;
+	public static final field SHARP Ljava/lang/String;
+	public static final field SMART_COVER_MANAGER Lshark/AndroidReferenceMatchers;
+	public static final field SPAN_CONTROLLER Lshark/AndroidReferenceMatchers;
+	public static final field SPEECH_RECOGNIZER Lshark/AndroidReferenceMatchers;
+	public static final field SPELL_CHECKER Lshark/AndroidReferenceMatchers;
+	public static final field SPELL_CHECKER_SESSION Lshark/AndroidReferenceMatchers;
+	public static final field SPEN_GESTURE_MANAGER Lshark/AndroidReferenceMatchers;
+	public static final field STATIC_MTARGET_VIEW Lshark/AndroidReferenceMatchers;
+	public static final field SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL Lshark/AndroidReferenceMatchers;
+	public static final field TES Ljava/lang/String;
+	public static final field TEXT_LINE__SCACHED Lshark/AndroidReferenceMatchers;
+	public static final field TEXT_TO_SPEECH Lshark/AndroidReferenceMatchers;
+	public static final field TEXT_VIEW__MLAST_HOVERED_VIEW Lshark/AndroidReferenceMatchers;
+	public static final field TOAST_TN Lshark/AndroidReferenceMatchers;
+	public static final field USER_MANAGER__SINSTANCE Lshark/AndroidReferenceMatchers;
+	public static final field VIEWLOCATIONHOLDER_ROOT Lshark/AndroidReferenceMatchers;
+	public static final field VIEW_CONFIGURATION__MCONTEXT Lshark/AndroidReferenceMatchers;
+	public static final field VIEW_GROUP__M_CURRENT_DRAG_CHILD Lshark/AndroidReferenceMatchers;
+	public static final field VIEW_GROUP__M_PRE_SORTED_CHILDREN Lshark/AndroidReferenceMatchers;
+	public static final field VIEW_TOOLTIP_CALLBACK Lshark/AndroidReferenceMatchers;
+	public static final field VIVO Ljava/lang/String;
+	public static final field WINDOW_ON_BACK_INVOKED_DISPATCHER__STUB Lshark/AndroidReferenceMatchers;
+	public static final field XIAMI__RESOURCES_IMPL Lshark/AndroidReferenceMatchers;
+	public static final field XIAOMI Ljava/lang/String;
+	public synthetic fun <init> (Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public static final fun buildKnownReferences (Ljava/util/Set;)Ljava/util/List;
+	public static final fun getAppDefaults ()Ljava/util/List;
+	public static final fun getIgnoredReferencesOnly ()Ljava/util/List;
+	public static final fun ignoredInstanceField (Ljava/lang/String;Ljava/lang/String;)Lshark/IgnoredReferenceMatcher;
+	public static final fun ignoredJavaLocal (Ljava/lang/String;)Lshark/IgnoredReferenceMatcher;
+	public static final fun instanceFieldLeak (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lshark/LibraryLeakReferenceMatcher;
+	public static final fun nativeGlobalVariableLeak (Ljava/lang/String;Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lshark/LibraryLeakReferenceMatcher;
+	public static final fun staticFieldLeak (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lshark/LibraryLeakReferenceMatcher;
+	public static fun valueOf (Ljava/lang/String;)Lshark/AndroidReferenceMatchers;
+	public static fun values ()[Lshark/AndroidReferenceMatchers;
+}
+
+public final class shark/AndroidReferenceMatchers$Companion {
+	public final fun buildKnownReferences (Ljava/util/Set;)Ljava/util/List;
+	public final fun getAppDefaults ()Ljava/util/List;
+	public final fun getIgnoredReferencesOnly ()Ljava/util/List;
+	public final fun ignoredInstanceField (Ljava/lang/String;Ljava/lang/String;)Lshark/IgnoredReferenceMatcher;
+	public final fun ignoredJavaLocal (Ljava/lang/String;)Lshark/IgnoredReferenceMatcher;
+	public final fun instanceFieldLeak (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lshark/LibraryLeakReferenceMatcher;
+	public static synthetic fun instanceFieldLeak$default (Lshark/AndroidReferenceMatchers$Companion;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)Lshark/LibraryLeakReferenceMatcher;
+	public final fun nativeGlobalVariableLeak (Ljava/lang/String;Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lshark/LibraryLeakReferenceMatcher;
+	public static synthetic fun nativeGlobalVariableLeak$default (Lshark/AndroidReferenceMatchers$Companion;Ljava/lang/String;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)Lshark/LibraryLeakReferenceMatcher;
+	public final fun staticFieldLeak (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lshark/LibraryLeakReferenceMatcher;
+	public static synthetic fun staticFieldLeak$default (Lshark/AndroidReferenceMatchers$Companion;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)Lshark/LibraryLeakReferenceMatcher;
+}
+
+public final class shark/AndroidResourceIdNames {
+	public static final field Companion Lshark/AndroidResourceIdNames$Companion;
+	public synthetic fun <init> ([I[Ljava/lang/String;Lkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun get (I)Ljava/lang/String;
+}
+
+public final class shark/AndroidResourceIdNames$Companion {
+	public final fun readFromHeap (Lshark/HeapGraph;)Lshark/AndroidResourceIdNames;
+	public final fun saveToMemory (Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)V
+}
+
+public final class shark/AndroidServices {
+	public static final field INSTANCE Lshark/AndroidServices;
+	public final fun getAliveAndroidServiceObjectIds (Lshark/HeapGraph;)Ljava/util/List;
+}
+
diff --git a/shark-android/build.gradle b/shark-android/build.gradle
new file mode 100644
index 00000000..9f0038f0
--- /dev/null
+++ b/shark-android/build.gradle
@@ -0,0 +1,22 @@
+plugins {
+  id("org.jetbrains.kotlin.jvm")
+  id("com.vanniktech.maven.publish")
+}
+
+sourceCompatibility = JavaVersion.VERSION_1_8
+targetCompatibility = JavaVersion.VERSION_1_8
+
+dependencies {
+  api projects.shark
+
+  implementation libs.kotlin.stdlib
+
+  testImplementation libs.assertjCore
+  testImplementation libs.junit
+  testImplementation libs.kotlinStatistics
+  testImplementation libs.mockito
+  testImplementation libs.mockitoKotlin
+  testImplementation libs.okio2
+  testImplementation projects.sharkHprofTest
+  testImplementation projects.sharkTest
+}
diff --git a/shark-android/gradle.properties b/shark-android/gradle.properties
new file mode 100644
index 00000000..e2aa8623
--- /dev/null
+++ b/shark-android/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark-android
+POM_NAME=Shark for Android heaps
+POM_PACKAGING=jar
diff --git a/shark-android/src/main/java/shark/AndroidBuildMirror.kt b/shark-android/src/main/java/shark/AndroidBuildMirror.kt
new file mode 100644
index 00000000..70fd38c0
--- /dev/null
+++ b/shark-android/src/main/java/shark/AndroidBuildMirror.kt
@@ -0,0 +1,37 @@
+package shark
+
+/**
+ * Caches values from the android.os.Build class in the heap dump.
+ * Retrieve a cached instances via [fromHeapGraph].
+ */
+class AndroidBuildMirror(
+  /**
+   * Value of android.os.Build.MANUFACTURER
+   */
+  val manufacturer: String,
+  /**
+   * Value of android.os.Build.VERSION.SDK_INT
+   */
+  val sdkInt: Int,
+
+  /**
+   * Value of android.os.Build.ID
+   */
+  val id: String
+) {
+  companion object {
+    /**
+     * @see AndroidBuildMirror
+     */
+    fun fromHeapGraph(graph: HeapGraph): AndroidBuildMirror {
+      return graph.context.getOrPut(AndroidBuildMirror::class.java.name) {
+        val buildClass = graph.findClassByName("android.os.Build")!!
+        val versionClass = graph.findClassByName("android.os.Build\$VERSION")!!
+        val manufacturer = buildClass["MANUFACTURER"]!!.value.readAsJavaString()!!
+        val sdkInt = versionClass["SDK_INT"]!!.value.asInt!!
+        val id = buildClass["ID"]!!.value.readAsJavaString()!!
+        AndroidBuildMirror(manufacturer, sdkInt, id)
+      }
+    }
+  }
+}
diff --git a/shark-android/src/main/java/shark/AndroidExtensions.kt b/shark-android/src/main/java/shark/AndroidExtensions.kt
new file mode 100644
index 00000000..eaf4f7b9
--- /dev/null
+++ b/shark-android/src/main/java/shark/AndroidExtensions.kt
@@ -0,0 +1,38 @@
+package shark
+
+import shark.HeapObject.HeapInstance
+
+/**
+ * The system identity hash code, or null if it couldn't be found.
+ *
+ * Based on the Object.identityHashCode implementation in AOSP.
+ *
+ * Backing field shadow$_monitor_ was added in API 24.
+ * https://cs.android.com/android/_/android/platform/libcore/+
+ * /de626ec8a109ea18283d96c720cc57e2f32f67fa:ojluni/src/main/java/java/lang/Object.java;
+ * dlc=ba7cc9f5357c323a1006119a20ce025fd4c57fd2
+ */
+val HeapInstance.identityHashCode: Int?
+  get() {
+    // Top 2 bits.
+    val lockWordStateMask = -0x40000000
+    // Top 2 bits are value 2 (kStateHash).
+    val lockWordStateHash = -0x80000000
+    // Low 28 bits.
+    val lockWordHashMask = 0x0FFFFFFF
+    val lockWord = this["java.lang.Object", "shadow\$_monitor_"]?.value?.asInt
+    return if (lockWord != null && lockWord and lockWordStateMask == lockWordStateHash) {
+      lockWord and lockWordHashMask
+    } else null
+  }
+
+/**
+ * The system identity hashCode represented as hex, or null if it couldn't be found.
+ * This is the string identifier you see when calling Object.toString() at runtime on a class that
+ * does not override its hashCode() method, e.g. com.example.MyThing@6bd57cf
+ */
+val HeapInstance.hexIdentityHashCode: String?
+  get() {
+    val hashCode = identityHashCode ?: return null
+    return Integer.toHexString(hashCode)
+  }
diff --git a/shark-android/src/main/java/shark/AndroidMetadataExtractor.kt b/shark-android/src/main/java/shark/AndroidMetadataExtractor.kt
new file mode 100644
index 00000000..b857f932
--- /dev/null
+++ b/shark-android/src/main/java/shark/AndroidMetadataExtractor.kt
@@ -0,0 +1,127 @@
+package shark
+
+import shark.GcRoot.ThreadObject
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.internal.friendly.mapNativeSizes
+
+object AndroidMetadataExtractor : MetadataExtractor {
+  override fun extractMetadata(graph: HeapGraph): Map<String, String> {
+    val metadata = mutableMapOf<String, String>()
+
+    val build = AndroidBuildMirror.fromHeapGraph(graph)
+    metadata["Build.VERSION.SDK_INT"] = build.sdkInt.toString()
+    metadata["Build.MANUFACTURER"] = build.manufacturer
+    metadata["LeakCanary version"] = readLeakCanaryVersion(graph)
+    metadata["App process name"] = readProcessName(graph)
+    metadata["Class count"] = graph.classCount.toString()
+    metadata["Instance count"] = graph.instanceCount.toString()
+    metadata["Primitive array count"] = graph.primitiveArrayCount.toString()
+    metadata["Object array count"] = graph.objectArrayCount.toString()
+    metadata["Thread count"] = readThreadCount(graph).toString()
+    metadata["Heap total bytes"] = readHeapTotalBytes(graph).toString()
+    metadata.putBitmaps(graph)
+    metadata.putDbLabels(graph)
+
+    return metadata
+  }
+
+  private fun readHeapTotalBytes(graph: HeapGraph): Int {
+    return graph.objects.sumBy { heapObject ->
+      when(heapObject) {
+        is HeapInstance -> {
+          heapObject.byteSize
+        }
+        // This is probably way off but is a cheap approximation.
+        is HeapClass -> heapObject.recordSize
+        is HeapObjectArray -> heapObject.byteSize
+        is HeapPrimitiveArray -> heapObject.byteSize
+      }
+    }
+  }
+
+  private fun MutableMap<String, String>.putBitmaps(
+    graph: HeapGraph,
+  ) {
+
+    val bitmapClass = graph.findClassByName("android.graphics.Bitmap") ?: return
+
+    val maxDisplayPixels =
+      graph.findClassByName("android.util.DisplayMetrics")?.directInstances?.map { instance ->
+        val width = instance["android.util.DisplayMetrics", "widthPixels"]?.value?.asInt ?: 0
+        val height = instance["android.util.DisplayMetrics", "heightPixels"]?.value?.asInt ?: 0
+        width * height
+      }?.max() ?: 0
+
+    val maxDisplayPixelsWithThreshold = (maxDisplayPixels * 1.1).toInt()
+
+    val sizeMap = graph.mapNativeSizes()
+
+    var sizeSum = 0
+    var count = 0
+    var largeBitmapCount = 0
+    var largeBitmapSizeSum = 0
+    bitmapClass.instances.forEach { bitmap ->
+      val width = bitmap["android.graphics.Bitmap", "mWidth"]?.value?.asInt ?: 0
+      val height = bitmap["android.graphics.Bitmap", "mHeight"]?.value?.asInt ?: 0
+      val size = sizeMap[bitmap.objectId] ?: 0
+
+      count++
+      sizeSum += size
+      if (maxDisplayPixelsWithThreshold > 0 && width * height > maxDisplayPixelsWithThreshold) {
+        largeBitmapCount++
+        largeBitmapSizeSum += size
+      }
+    }
+    this["Bitmap count"] = count.toString()
+    this["Bitmap total bytes"] = sizeSum.toString()
+    this["Large bitmap count"] = largeBitmapCount.toString()
+    this["Large bitmap total bytes"] = largeBitmapSizeSum.toString()
+  }
+
+  private fun readThreadCount(graph: HeapGraph): Int {
+    return graph.gcRoots.filterIsInstance<ThreadObject>().map { it.id }.toSet().size
+  }
+
+  private fun readLeakCanaryVersion(graph: HeapGraph): String {
+    val versionHolderClass = graph.findClassByName("leakcanary.internal.InternalLeakCanary")
+    return versionHolderClass?.get("version")?.value?.readAsJavaString() ?: "Unknown"
+  }
+
+  private fun readProcessName(graph: HeapGraph): String {
+    val activityThread = graph.findClassByName("android.app.ActivityThread")
+      ?.get("sCurrentActivityThread")
+      ?.valueAsInstance
+    val appBindData = activityThread?.get("android.app.ActivityThread", "mBoundApplication")
+      ?.valueAsInstance
+    val appInfo = appBindData?.get("android.app.ActivityThread\$AppBindData", "appInfo")
+      ?.valueAsInstance
+
+    return appInfo?.get(
+      "android.content.pm.ApplicationInfo", "processName"
+    )?.valueAsInstance?.readAsJavaString() ?: "Unknown"
+  }
+
+  private fun MutableMap<String, String>.putDbLabels(graph: HeapGraph) {
+    val dbClass = graph.findClassByName("android.database.sqlite.SQLiteDatabase") ?: return
+
+    val openDbLabels = dbClass.instances.mapNotNull { instance ->
+      val config =
+        instance["android.database.sqlite.SQLiteDatabase", "mConfigurationLocked"]?.valueAsInstance
+          ?: return@mapNotNull null
+      val label =
+        config["android.database.sqlite.SQLiteDatabaseConfiguration", "label"]?.value?.readAsJavaString()
+          ?: return@mapNotNull null
+      val open =
+        instance["android.database.sqlite.SQLiteDatabase", "mConnectionPoolLocked"]?.value?.isNonNullReference
+          ?: return@mapNotNull null
+      label to open
+    }
+
+    openDbLabels.forEachIndexed { index, (label, open) ->
+      this["Db ${index + 1}"] = (if (open) "open " else "closed ") + label
+    }
+  }
+}
diff --git a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
new file mode 100644
index 00000000..2b284182
--- /dev/null
+++ b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
@@ -0,0 +1,1098 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package shark
+
+import java.util.EnumSet
+import kotlin.math.absoluteValue
+import shark.AndroidObjectInspectors.Companion.appDefaults
+import shark.AndroidServices.aliveAndroidServiceObjectIds
+import shark.FilteringLeakingObjectFinder.LeakingObjectFilter
+import shark.HeapObject.HeapInstance
+import shark.internal.InternalSharkCollectionsHelper
+
+/**
+ * A set of default [ObjectInspector]s that knows about common AOSP and library
+ * classes.
+ *
+ * These are heuristics based on our experience and knowledge of AOSP and various library
+ * internals. We only make a decision if we're reasonably sure the state of an object is
+ * unlikely to be the result of a programmer mistake.
+ *
+ * For example, no matter how many mistakes we make in our code, the value of Activity.mDestroy
+ * will not be influenced by those mistakes.
+ *
+ * Most developers should use the entire set of default [ObjectInspector] by calling [appDefaults],
+ * unless there's a bug and you temporarily want to remove an inspector.
+ */
+enum class AndroidObjectInspectors : ObjectInspector {
+
+  VIEW {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      if (heapObject is HeapInstance && heapObject instanceOf "android.view.View") {
+        // Leaking if null parent or non view parent.
+        val viewParent = heapObject["android.view.View", "mParent"]!!.valueAsInstance
+        val isParentlessView = viewParent == null
+        val isChildOfViewRootImpl =
+          viewParent != null && !(viewParent instanceOf "android.view.View")
+        val isRootView = isParentlessView || isChildOfViewRootImpl
+
+        // This filter only cares for root view because we only need one view in a view hierarchy.
+        if (isRootView) {
+          val mContext = heapObject["android.view.View", "mContext"]!!.value.asObject!!.asInstance!!
+          val activityContext = mContext.unwrapActivityContext()
+          val mContextIsDestroyedActivity = (activityContext != null &&
+            activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean == true)
+          if (mContextIsDestroyedActivity) {
+            // Root view with unwrapped mContext a destroyed activity.
+            true
+          } else {
+            val viewDetached =
+              heapObject["android.view.View", "mAttachInfo"]!!.value.isNullReference
+            if (viewDetached) {
+              val mWindowAttachCount =
+                heapObject["android.view.View", "mWindowAttachCount"]?.value!!.asInt!!
+              if (mWindowAttachCount > 0) {
+                when {
+                  isChildOfViewRootImpl -> {
+                    // Child of ViewRootImpl that was once attached and is now detached.
+                    // Unwrapped mContext not a destroyed activity. This could be a dialog root.
+                    true
+                  }
+                  heapObject.instanceClassName == "com.android.internal.policy.DecorView" -> {
+                    // DecorView with null parent, once attached now detached.
+                    // Unwrapped mContext not a destroyed activity. This could be a dialog root.
+                    // Unlikely to be a reusable cached view => leak.
+                    true
+                  }
+                  else -> {
+                    // View with null parent, once attached now detached.
+                    // Unwrapped mContext not a destroyed activity. This could be a dialog root.
+                    // Could be a leak or could be a reusable cached view.
+                    false
+                  }
+                }
+              } else {
+                // Root view, detached but was never attached.
+                // This could be a cached instance.
+                false
+              }
+            } else {
+              // Root view that is attached.
+              false
+            }
+          }
+        } else {
+          // Not a root view.
+          false
+        }
+      } else {
+        // Not a view
+        false
+      }
+    }
+
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.view.View") { instance ->
+        // This skips edge cases like Toast$TN.mNextView holding on to an unattached and unparented
+        // next toast view
+        var rootParent = instance["android.view.View", "mParent"]!!.valueAsInstance
+        var rootView: HeapInstance? = null
+        while (rootParent != null && rootParent instanceOf "android.view.View") {
+          rootView = rootParent
+          rootParent = rootParent["android.view.View", "mParent"]!!.valueAsInstance
+        }
+
+        val partOfWindowHierarchy = rootParent != null || (rootView != null &&
+          rootView.instanceClassName == "com.android.internal.policy.DecorView")
+
+        val mWindowAttachCount =
+          instance["android.view.View", "mWindowAttachCount"]?.value!!.asInt!!
+        val viewDetached = instance["android.view.View", "mAttachInfo"]!!.value.isNullReference
+        val mContext = instance["android.view.View", "mContext"]!!.value.asObject!!.asInstance!!
+
+        val activityContext = mContext.unwrapActivityContext()
+        if (activityContext != null && activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean == true) {
+          leakingReasons += "View.mContext references a destroyed activity"
+        } else {
+          if (partOfWindowHierarchy && mWindowAttachCount > 0) {
+            if (viewDetached) {
+              leakingReasons += "View detached yet still part of window view hierarchy"
+            } else {
+              if (rootView != null && rootView["android.view.View", "mAttachInfo"]!!.value.isNullReference) {
+                leakingReasons += "View attached but root view ${rootView.instanceClassName} detached (attach disorder)"
+              } else {
+                notLeakingReasons += "View attached"
+              }
+            }
+          }
+        }
+
+        labels += if (partOfWindowHierarchy) {
+          "View is part of a window view hierarchy"
+        } else {
+          "View not part of a window view hierarchy"
+        }
+
+        labels += if (viewDetached) {
+          "View.mAttachInfo is null (view detached)"
+        } else {
+          "View.mAttachInfo is not null (view attached)"
+        }
+
+        AndroidResourceIdNames.readFromHeap(instance.graph)
+          ?.let { resIds ->
+            val mID = instance["android.view.View", "mID"]!!.value.asInt!!
+            val noViewId = -1
+            if (mID != noViewId) {
+              val resourceName = resIds[mID]
+              labels += "View.mID = R.id.$resourceName"
+            }
+          }
+        labels += "View.mWindowAttachCount = $mWindowAttachCount"
+      }
+    }
+  },
+
+  EDITOR {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+        heapObject instanceOf "android.widget.Editor" &&
+        heapObject["android.widget.Editor", "mTextView"]?.value?.asObject?.let { textView ->
+          VIEW.leakingObjectFilter!!(textView)
+        } ?: false
+    }
+
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("android.widget.Editor") { instance ->
+        applyFromField(VIEW, instance["android.widget.Editor", "mTextView"])
+      }
+    }
+  },
+
+  ACTIVITY {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+        heapObject instanceOf "android.app.Activity" &&
+        heapObject["android.app.Activity", "mDestroyed"]?.value?.asBoolean == true
+    }
+
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.app.Activity") { instance ->
+        // Activity.mDestroyed was introduced in 17.
+        // https://android.googlesource.com/platform/frameworks/base/+
+        // /6d9dcbccec126d9b87ab6587e686e28b87e5a04d
+        val field = instance["android.app.Activity", "mDestroyed"]
+
+        if (field != null) {
+          if (field.value.asBoolean!!) {
+            leakingReasons += field describedWithValue "true"
+          } else {
+            notLeakingReasons += field describedWithValue "false"
+          }
+        }
+      }
+    }
+  },
+
+  SERVICE {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+        heapObject instanceOf "android.app.Service" &&
+        heapObject.objectId !in heapObject.graph.aliveAndroidServiceObjectIds
+    }
+
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.app.Service") { instance ->
+        if (instance.objectId in instance.graph.aliveAndroidServiceObjectIds) {
+          notLeakingReasons += "Service held by ActivityThread"
+        } else {
+          leakingReasons += "Service not held by ActivityThread"
+        }
+      }
+    }
+  },
+
+  CONTEXT_FIELD {
+    override fun inspect(reporter: ObjectReporter) {
+      val instance = reporter.heapObject
+      if (instance !is HeapInstance) {
+        return
+      }
+      instance.readFields().forEach { field ->
+        val fieldInstance = field.valueAsInstance
+        if (fieldInstance != null && fieldInstance instanceOf "android.content.Context") {
+          reporter.run {
+            val componentContext = fieldInstance.unwrapComponentContext()
+            labels += if (componentContext == null) {
+              "${field.name} instance of ${fieldInstance.instanceClassName}"
+            } else if (componentContext instanceOf "android.app.Activity") {
+              val activityDescription =
+                "with mDestroyed = " + (componentContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean?.toString()
+                  ?: "UNKNOWN")
+              if (componentContext == fieldInstance) {
+                "${field.name} instance of ${fieldInstance.instanceClassName} $activityDescription"
+              } else {
+                "${field.name} instance of ${fieldInstance.instanceClassName}, " +
+                  "wrapping activity ${componentContext.instanceClassName} $activityDescription"
+              }
+            } else if (componentContext == fieldInstance) {
+              // No need to add "instance of Application / Service", devs know their own classes.
+              "${field.name} instance of ${fieldInstance.instanceClassName}"
+            } else {
+              "${field.name} instance of ${fieldInstance.instanceClassName}, wrapping ${componentContext.instanceClassName}"
+            }
+          }
+        }
+      }
+    }
+  },
+
+  CONTEXT_WRAPPER {
+
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+        heapObject.unwrapActivityContext()
+          ?.get("android.app.Activity", "mDestroyed")?.value?.asBoolean == true
+    }
+
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      val instance = reporter.heapObject
+      if (instance !is HeapInstance) {
+        return
+      }
+
+      // We're looking for ContextWrapper instances that are not Activity, Application or Service.
+      // So we stop whenever we find any of those 4 classes, and then only keep ContextWrapper.
+      val matchingClassName = instance.instanceClass.classHierarchy.map { it.name }
+        .firstOrNull {
+          when (it) {
+            "android.content.ContextWrapper",
+            "android.app.Activity",
+            "android.app.Application",
+            "android.app.Service"
+            -> true
+            else -> false
+          }
+        }
+
+      if (matchingClassName == "android.content.ContextWrapper") {
+        reporter.run {
+          val componentContext = instance.unwrapComponentContext()
+          if (componentContext != null) {
+            if (componentContext instanceOf "android.app.Activity") {
+              val mDestroyed = componentContext["android.app.Activity", "mDestroyed"]
+              if (mDestroyed != null) {
+                if (mDestroyed.value.asBoolean!!) {
+                  leakingReasons += "${instance.instanceClassSimpleName} wraps an Activity with Activity.mDestroyed true"
+                } else {
+                  // We can't assume it's not leaking, because this context might have a shorter lifecycle
+                  // than the activity. So we'll just add a label.
+                  labels += "${instance.instanceClassSimpleName} wraps an Activity with Activity.mDestroyed false"
+                }
+              }
+            } else if (componentContext instanceOf "android.app.Application") {
+              labels += "${instance.instanceClassSimpleName} wraps an Application context"
+            } else {
+              labels += "${instance.instanceClassSimpleName} wraps a Service context"
+            }
+          } else {
+            labels += "${instance.instanceClassSimpleName} does not wrap a known Android context"
+          }
+        }
+      }
+    }
+  },
+
+  APPLICATION_PACKAGE_MANAGER {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+        heapObject instanceOf "android.app.ApplicationContextManager" &&
+        heapObject["android.app.ApplicationContextManager", "mContext"]!!
+          .valueAsInstance!!.outerContextIsLeaking()
+    }
+
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("android.app.ApplicationContextManager") { instance ->
+        val outerContext = instance["android.app.ApplicationContextManager", "mContext"]!!
+          .valueAsInstance!!["android.app.ContextImpl", "mOuterContext"]!!
+          .valueAsInstance!!
+        inspectContextImplOuterContext(outerContext, instance, "ApplicationContextManager.mContext")
+      }
+    }
+  },
+
+  CONTEXT_IMPL {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+        heapObject instanceOf "android.app.ContextImpl" &&
+        heapObject.outerContextIsLeaking()
+    }
+
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("android.app.ContextImpl") { instance ->
+        val outerContext = instance["android.app.ContextImpl", "mOuterContext"]!!
+          .valueAsInstance!!
+        inspectContextImplOuterContext(outerContext, instance)
+      }
+    }
+  },
+
+  DIALOG {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.app.Dialog") { instance ->
+        val mDecor = instance["android.app.Dialog", "mDecor"]!!
+        // Can't infer leaking status: mDecor null means either never shown or dismiss.
+        // mDecor non null means the dialog is showing, but sometimes dialogs stay showing
+        // after activity destroyed so that's not really a non leak either.
+        labels += mDecor describedWithValue if (mDecor.value.isNullReference) {
+          "null"
+        } else {
+          "not null"
+        }
+      }
+    }
+  },
+
+  ACTIVITY_THREAD {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("android.app.ActivityThread") {
+        notLeakingReasons += "ActivityThread is a singleton"
+      }
+    }
+  },
+
+  APPLICATION {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.app.Application") {
+        notLeakingReasons += "Application is a singleton"
+      }
+    }
+  },
+
+  INPUT_METHOD_MANAGER {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.view.inputmethod.InputMethodManager") {
+        notLeakingReasons += "InputMethodManager is a singleton"
+      }
+    }
+  },
+
+  FRAGMENT {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+        heapObject instanceOf "android.app.Fragment" &&
+        heapObject["android.app.Fragment", "mFragmentManager"]!!.value.isNullReference
+    }
+
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.app.Fragment") { instance ->
+        val fragmentManager = instance["android.app.Fragment", "mFragmentManager"]!!
+        if (fragmentManager.value.isNullReference) {
+          leakingReasons += fragmentManager describedWithValue "null"
+        } else {
+          notLeakingReasons += fragmentManager describedWithValue "not null"
+        }
+        val mTag = instance["android.app.Fragment", "mTag"]?.value?.readAsJavaString()
+        if (!mTag.isNullOrEmpty()) {
+          labels += "Fragment.mTag=$mTag"
+        }
+      }
+    }
+  },
+
+  SUPPORT_FRAGMENT {
+
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+        heapObject instanceOf ANDROID_SUPPORT_FRAGMENT_CLASS_NAME &&
+        heapObject.getOrThrow(
+          ANDROID_SUPPORT_FRAGMENT_CLASS_NAME, "mFragmentManager"
+        ).value.isNullReference
+    }
+
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf(ANDROID_SUPPORT_FRAGMENT_CLASS_NAME) { instance ->
+        val fragmentManager =
+          instance.getOrThrow(ANDROID_SUPPORT_FRAGMENT_CLASS_NAME, "mFragmentManager")
+        if (fragmentManager.value.isNullReference) {
+          leakingReasons += fragmentManager describedWithValue "null"
+        } else {
+          notLeakingReasons += fragmentManager describedWithValue "not null"
+        }
+        val mTag = instance[ANDROID_SUPPORT_FRAGMENT_CLASS_NAME, "mTag"]?.value?.readAsJavaString()
+        if (!mTag.isNullOrEmpty()) {
+          labels += "Fragment.mTag=$mTag"
+        }
+      }
+    }
+  },
+
+  ANDROIDX_FRAGMENT {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+        heapObject instanceOf "androidx.fragment.app.Fragment" &&
+        heapObject["androidx.fragment.app.Fragment", "mLifecycleRegistry"]!!
+          .valueAsInstance
+          ?.lifecycleRegistryState == "DESTROYED"
+    }
+
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("androidx.fragment.app.Fragment") { instance ->
+        val lifecycleRegistryField = instance["androidx.fragment.app.Fragment", "mLifecycleRegistry"]!!
+        val lifecycleRegistry = lifecycleRegistryField.valueAsInstance
+        if (lifecycleRegistry != null) {
+          val state = lifecycleRegistry.lifecycleRegistryState
+          val reason = "Fragment.mLifecycleRegistry.state is $state"
+          if (state == "DESTROYED") {
+            leakingReasons += reason
+          } else {
+            notLeakingReasons += reason
+          }
+        } else {
+          labels += "Fragment.mLifecycleRegistry = null"
+        }
+        val mTag = instance["androidx.fragment.app.Fragment", "mTag"]?.value?.readAsJavaString()
+        if (!mTag.isNullOrEmpty()) {
+          labels += "Fragment.mTag = $mTag"
+        }
+      }
+    }
+  },
+
+  MESSAGE_QUEUE {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+        heapObject instanceOf "android.os.MessageQueue" &&
+        (heapObject["android.os.MessageQueue", "mQuitting"]
+          ?: heapObject["android.os.MessageQueue", "mQuiting"]!!).value.asBoolean!!
+    }
+
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.os.MessageQueue") { instance ->
+        // mQuiting had a typo and was renamed to mQuitting
+        // https://android.googlesource.com/platform/frameworks/base/+/013cf847bcfd2828d34dced60adf2d3dd98021dc
+        val mQuitting = instance["android.os.MessageQueue", "mQuitting"]
+          ?: instance["android.os.MessageQueue", "mQuiting"]!!
+        if (mQuitting.value.asBoolean!!) {
+          leakingReasons += mQuitting describedWithValue "true"
+        } else {
+          notLeakingReasons += mQuitting describedWithValue "false"
+        }
+
+        val queueHead = instance["android.os.MessageQueue", "mMessages"]!!.valueAsInstance
+        if (queueHead != null) {
+          val targetHandler = queueHead["android.os.Message", "target"]!!.valueAsInstance
+          if (targetHandler != null) {
+            val looper = targetHandler["android.os.Handler", "mLooper"]!!.valueAsInstance
+            if (looper != null) {
+              val thread = looper["android.os.Looper", "mThread"]!!.valueAsInstance!!
+              val threadName = thread[Thread::class, "name"]!!.value.readAsJavaString()
+              labels += "HandlerThread: \"$threadName\""
+            }
+          }
+        }
+      }
+    }
+  },
+
+  LOADED_APK {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.app.LoadedApk") { instance ->
+        val receiversMap = instance["android.app.LoadedApk", "mReceivers"]!!.valueAsInstance!!
+        val receiversArray = receiversMap["android.util.ArrayMap", "mArray"]!!.valueAsObjectArray!!
+        val receiverContextList = receiversArray.readElements().toList()
+
+        val allReceivers = (receiverContextList.indices step 2).mapNotNull { index ->
+          val context = receiverContextList[index]
+          if (context.isNonNullReference) {
+            val contextReceiversMap = receiverContextList[index + 1].asObject!!.asInstance!!
+            val contextReceivers = contextReceiversMap["android.util.ArrayMap", "mArray"]!!
+              .valueAsObjectArray!!
+              .readElements()
+              .toList()
+
+            val receivers =
+              (contextReceivers.indices step 2).mapNotNull { contextReceivers[it].asObject?.asInstance }
+            val contextInstance = context.asObject!!.asInstance!!
+            val contextString =
+              "${contextInstance.instanceClassSimpleName}@${contextInstance.objectId}"
+            contextString to receivers.map { "${it.instanceClassSimpleName}@${it.objectId}" }
+          } else {
+            null
+          }
+        }.toList()
+
+        if (allReceivers.isNotEmpty()) {
+          labels += "Receivers"
+          allReceivers.forEach { (contextString, receiverStrings) ->
+            labels += "..$contextString"
+            receiverStrings.forEach { receiverString ->
+              labels += "....$receiverString"
+            }
+          }
+        }
+      }
+    }
+  },
+
+  MORTAR_PRESENTER {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("mortar.Presenter") { instance ->
+        val view = instance.getOrThrow("mortar.Presenter", "view")
+        labels += view describedWithValue if (view.value.isNullReference) "null" else "not null"
+      }
+    }
+  },
+
+  MORTAR_SCOPE {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+        heapObject instanceOf "mortar.MortarScope" &&
+        heapObject.getOrThrow("mortar.MortarScope", "dead").value.asBoolean!!
+    }
+
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("mortar.MortarScope") { instance ->
+        val dead = instance.getOrThrow("mortar.MortarScope", "dead").value.asBoolean!!
+        val scopeName = instance.getOrThrow("mortar.MortarScope", "name").value.readAsJavaString()
+        if (dead) {
+          leakingReasons += "mortar.MortarScope.dead is true for scope $scopeName"
+        } else {
+          notLeakingReasons += "mortar.MortarScope.dead is false for scope $scopeName"
+        }
+      }
+    }
+  },
+
+  COORDINATOR {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("com.squareup.coordinators.Coordinator") { instance ->
+        val attached = instance.getOrThrow("com.squareup.coordinators.Coordinator", "attached")
+        labels += attached describedWithValue "${attached.value.asBoolean}"
+      }
+    }
+  },
+
+  MAIN_THREAD {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf(Thread::class) { instance ->
+        val threadName = instance[Thread::class, "name"]!!.value.readAsJavaString()
+        if (threadName == "main") {
+          notLeakingReasons += "the main thread always runs"
+        }
+      }
+    }
+  },
+
+  VIEW_ROOT_IMPL {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      if (heapObject is HeapInstance &&
+        heapObject instanceOf "android.view.ViewRootImpl"
+      ) {
+        if (heapObject["android.view.ViewRootImpl", "mView"]!!.value.isNullReference) {
+          true
+        } else {
+          val mContextField = heapObject["android.view.ViewRootImpl", "mContext"]
+          if (mContextField != null) {
+            val mContext = mContextField.valueAsInstance!!
+            val activityContext = mContext.unwrapActivityContext()
+            (activityContext != null && activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean == true)
+          } else {
+            false
+          }
+        }
+      } else {
+        false
+      }
+    }
+
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("android.view.ViewRootImpl") { instance ->
+        val mViewField = instance["android.view.ViewRootImpl", "mView"]!!
+        if (mViewField.value.isNullReference) {
+          leakingReasons += mViewField describedWithValue "null"
+        } else {
+          // ViewRootImpl.mContext wasn't always here.
+          val mContextField = instance["android.view.ViewRootImpl", "mContext"]
+          if (mContextField != null) {
+            val mContext = mContextField.valueAsInstance!!
+            val activityContext = mContext.unwrapActivityContext()
+            if (activityContext != null && activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean == true) {
+              leakingReasons += "ViewRootImpl.mContext references a destroyed activity, did you forget to cancel toasts or dismiss dialogs?"
+            }
+          }
+          labels += mViewField describedWithValue "not null"
+        }
+        val mWindowAttributes =
+          instance["android.view.ViewRootImpl", "mWindowAttributes"]!!.valueAsInstance!!
+        val mTitleField = mWindowAttributes["android.view.WindowManager\$LayoutParams", "mTitle"]!!
+        labels += if (mTitleField.value.isNonNullReference) {
+          val mTitle =
+            mTitleField.valueAsInstance!!.readAsJavaString()!!
+          "mWindowAttributes.mTitle = \"$mTitle\""
+        } else {
+          "mWindowAttributes.mTitle is null"
+        }
+
+        val type =
+          mWindowAttributes["android.view.WindowManager\$LayoutParams", "type"]!!.value.asInt!!
+        // android.view.WindowManager.LayoutParams.TYPE_TOAST
+        val details = if (type == 2005) {
+          " (Toast)"
+        } else ""
+        labels += "mWindowAttributes.type = $type$details"
+      }
+    }
+  },
+
+  WINDOW {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+        heapObject instanceOf "android.view.Window" &&
+        heapObject["android.view.Window", "mDestroyed"]!!.value.asBoolean!!
+    }
+
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.view.Window") { instance ->
+        val mDestroyed = instance["android.view.Window", "mDestroyed"]!!
+
+        if (mDestroyed.value.asBoolean!!) {
+          leakingReasons += mDestroyed describedWithValue "true"
+        } else {
+          // A dialog window could be leaking, destroy is only set to false for activity windows.
+          labels += mDestroyed describedWithValue "false"
+        }
+      }
+    }
+  },
+
+  MESSAGE {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("android.os.Message") { instance ->
+        labels += "Message.what = ${instance["android.os.Message", "what"]!!.value.asInt}"
+
+        val heapDumpUptimeMillis = KeyedWeakReferenceFinder.heapDumpUptimeMillis(instance.graph)
+        val whenUptimeMillis = instance["android.os.Message", "when"]!!.value.asLong!!
+
+        labels += if (heapDumpUptimeMillis != null) {
+          val diffMs = whenUptimeMillis - heapDumpUptimeMillis
+          if (diffMs > 0) {
+            "Message.when = $whenUptimeMillis ($diffMs ms after heap dump)"
+          } else {
+            "Message.when = $whenUptimeMillis (${diffMs.absoluteValue} ms before heap dump)"
+          }
+        } else {
+          "Message.when = $whenUptimeMillis"
+        }
+
+        labels += "Message.obj = ${instance["android.os.Message", "obj"]!!.value.asObject}"
+        labels += "Message.callback = ${instance["android.os.Message", "callback"]!!.value.asObject}"
+        labels += "Message.target = ${instance["android.os.Message", "target"]!!.value.asObject}"
+      }
+    }
+  },
+
+  TOAST {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      if (heapObject is HeapInstance && heapObject instanceOf "android.widget.Toast") {
+        val tnInstance =
+          heapObject["android.widget.Toast", "mTN"]!!.value.asObject!!.asInstance!!
+        (tnInstance["android.widget.Toast\$TN", "mWM"]!!.value.isNonNullReference &&
+          tnInstance["android.widget.Toast\$TN", "mView"]!!.value.isNullReference)
+      } else false
+    }
+
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.widget.Toast") { instance ->
+        val tnInstance =
+          instance["android.widget.Toast", "mTN"]!!.value.asObject!!.asInstance!!
+        // mWM is set in android.widget.Toast.TN#handleShow and never unset, so this toast was never
+        // shown, we don't know if it's leaking.
+        if (tnInstance["android.widget.Toast\$TN", "mWM"]!!.value.isNonNullReference) {
+          // mView is reset to null in android.widget.Toast.TN#handleHide
+          if (tnInstance["android.widget.Toast\$TN", "mView"]!!.value.isNullReference) {
+            leakingReasons += "This toast is done showing (Toast.mTN.mWM != null && Toast.mTN.mView == null)"
+          } else {
+            notLeakingReasons += "This toast is showing (Toast.mTN.mWM != null && Toast.mTN.mView != null)"
+          }
+        }
+      }
+    }
+  },
+
+  RECOMPOSER {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("androidx.compose.runtime.Recomposer") { instance ->
+        val stateFlow =
+          instance["androidx.compose.runtime.Recomposer", "_state"]!!.valueAsInstance!!
+        val state = stateFlow["kotlinx.coroutines.flow.StateFlowImpl", "_state"]?.valueAsInstance
+        if (state != null) {
+          val stateName = state["java.lang.Enum", "name"]!!.valueAsInstance!!.readAsJavaString()!!
+          val label = "Recomposer is in state $stateName"
+          when (stateName) {
+            "ShutDown", "ShuttingDown" -> leakingReasons += label
+            "Inactive", "InactivePendingWork" -> labels += label
+            "PendingWork", "Idle" -> notLeakingReasons += label
+          }
+        }
+      }
+    }
+  },
+
+  COMPOSITION_IMPL {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("androidx.compose.runtime.CompositionImpl") { instance ->
+        if (instance["androidx.compose.runtime.CompositionImpl", "disposed"]!!.value.asBoolean!!) {
+          leakingReasons += "Composition disposed"
+        } else {
+          notLeakingReasons += "Composition not disposed"
+        }
+      }
+    }
+  },
+
+  ANIMATOR {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("android.animation.Animator") { instance ->
+        val mListeners = instance["android.animation.Animator", "mListeners"]!!.valueAsInstance
+        if (mListeners != null) {
+          val listenerValues = InternalSharkCollectionsHelper.arrayListValues(mListeners).toList()
+          if (listenerValues.isNotEmpty()) {
+            listenerValues.forEach { value ->
+              labels += "mListeners$value"
+            }
+          } else {
+            labels += "mListeners is empty"
+          }
+        } else {
+          labels += "mListeners = null"
+        }
+      }
+    }
+  },
+
+  OBJECT_ANIMATOR {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("android.animation.ObjectAnimator") { instance ->
+        labels += "mPropertyName = " + (instance["android.animation.ObjectAnimator", "mPropertyName"]!!.valueAsInstance?.readAsJavaString()
+          ?: "null")
+        val mProperty = instance["android.animation.ObjectAnimator", "mProperty"]!!.valueAsInstance
+        if (mProperty == null) {
+          labels += "mProperty = null"
+        } else {
+          labels += "mProperty.mName = " + (mProperty["android.util.Property", "mName"]!!.valueAsInstance?.readAsJavaString()
+            ?: "null")
+          labels += "mProperty.mType = " + (mProperty["android.util.Property", "mType"]!!.valueAsClass?.name
+            ?: "null")
+        }
+        labels += "mInitialized = " + instance["android.animation.ValueAnimator", "mInitialized"]!!.value.asBoolean!!
+        labels += "mStarted = " + instance["android.animation.ValueAnimator", "mStarted"]!!.value.asBoolean!!
+        labels += "mRunning = " + instance["android.animation.ValueAnimator", "mRunning"]!!.value.asBoolean!!
+        labels += "mAnimationEndRequested = " + instance["android.animation.ValueAnimator", "mAnimationEndRequested"]!!.value.asBoolean!!
+        labels += "mDuration = " + instance["android.animation.ValueAnimator", "mDuration"]!!.value.asLong!!
+        labels += "mStartDelay = " + instance["android.animation.ValueAnimator", "mStartDelay"]!!.value.asLong!!
+        val repeatCount = instance["android.animation.ValueAnimator", "mRepeatCount"]!!.value.asInt!!
+        labels += "mRepeatCount = " + if (repeatCount == -1) "INFINITE (-1)" else repeatCount
+
+        val repeatModeConstant = when (val repeatMode =
+          instance["android.animation.ValueAnimator", "mRepeatMode"]!!.value.asInt!!) {
+          1 -> "RESTART (1)"
+          2 -> "REVERSE (2)"
+          else -> "Unknown ($repeatMode)"
+        }
+        labels += "mRepeatMode = $repeatModeConstant"
+      }
+    }
+  },
+
+  LIFECYCLE_REGISTRY {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("androidx.lifecycle.LifecycleRegistry") { instance ->
+        val state = instance.lifecycleRegistryState
+        // If state is DESTROYED, this doesn't mean the LifecycleRegistry itself is leaking.
+        // Fragment.mViewLifecycleRegistry becomes DESTROYED when the fragment view is destroyed,
+        // but the registry itself is still held in memory by the fragment.
+        if (state != "DESTROYED") {
+          notLeakingReasons += "state is $state"
+        } else {
+          labels += "state = $state"
+        }
+      }
+    }
+  },
+
+  STUB {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("android.os.Binder") { instance ->
+        labels + "${instance.instanceClassSimpleName} is a binder stub. Binder stubs will often be" +
+          " retained long after the associated activity or service is destroyed, as by design stubs" +
+          " are retained until the other side gets GCed. If ${instance.instanceClassSimpleName} is" +
+          " not a *static* inner class then that's most likely the root cause of this leak. Make" +
+          " it static. If ${instance.instanceClassSimpleName} is an Android Framework class, file" +
+          " a ticket here: https://issuetracker.google.com/issues/new?component=192705"
+      }
+    }
+  },
+  ;
+
+  internal open val leakingObjectFilter: ((heapObject: HeapObject) -> Boolean)? = null
+
+  companion object {
+    /** @see AndroidObjectInspectors */
+    val appDefaults: List<ObjectInspector>
+      get() = ObjectInspectors.jdkDefaults + values()
+
+    /**
+     * Returns a list of [LeakingObjectFilter] suitable for apps.
+     */
+    val appLeakingObjectFilters: List<LeakingObjectFilter> =
+      ObjectInspectors.jdkLeakingObjectFilters +
+        createLeakingObjectFilters(EnumSet.allOf(AndroidObjectInspectors::class.java))
+
+    /**
+     * Creates a list of [LeakingObjectFilter] based on the passed in [AndroidObjectInspectors].
+     */
+    fun createLeakingObjectFilters(inspectors: Set<AndroidObjectInspectors>): List<LeakingObjectFilter> =
+      inspectors.mapNotNull { it.leakingObjectFilter }
+        .map { filter ->
+          LeakingObjectFilter { heapObject -> filter(heapObject) }
+        }
+  }
+
+  // Using a string builder to prevent Jetifier from changing this string to Android X Fragment
+  @Suppress("VariableNaming", "PropertyName")
+  internal val ANDROID_SUPPORT_FRAGMENT_CLASS_NAME =
+    StringBuilder("android.").append("support.v4.app.Fragment")
+      .toString()
+}
+
+private fun HeapInstance.outerContextIsLeaking() =
+  this["android.app.ContextImpl", "mOuterContext"]!!
+    .valueAsInstance!!
+    .run {
+      this instanceOf "android.app.Activity" &&
+        this["android.app.Activity", "mDestroyed"]?.value?.asBoolean == true
+    }
+
+private fun ObjectReporter.inspectContextImplOuterContext(
+  outerContext: HeapInstance,
+  contextImpl: HeapInstance,
+  prefix: String = "ContextImpl"
+) {
+  if (outerContext instanceOf "android.app.Activity") {
+    val mDestroyed = outerContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean
+    if (mDestroyed != null) {
+      if (mDestroyed) {
+        leakingReasons += "$prefix.mOuterContext is an instance of" +
+          " ${outerContext.instanceClassName} with Activity.mDestroyed true"
+      } else {
+        notLeakingReasons += "$prefix.mOuterContext is an instance of " +
+          "${outerContext.instanceClassName} with Activity.mDestroyed false"
+      }
+    } else {
+      labels += "$prefix.mOuterContext is an instance of ${outerContext.instanceClassName}"
+    }
+  } else if (outerContext instanceOf "android.app.Application") {
+    notLeakingReasons += "$prefix.mOuterContext is an instance of" +
+      " ${outerContext.instanceClassName} which extends android.app.Application"
+  } else if (outerContext.objectId == contextImpl.objectId) {
+    labels += "$prefix.mOuterContext == ContextImpl.this: not tied to any particular lifecycle"
+  } else {
+    labels += "$prefix.mOuterContext is an instance of ${outerContext.instanceClassName}"
+  }
+}
+
+private infix fun HeapField.describedWithValue(valueDescription: String): String {
+  return "${declaringClass.simpleName}#$name is $valueDescription"
+}
+
+private fun ObjectReporter.applyFromField(
+  inspector: ObjectInspector,
+  field: HeapField?
+) {
+  if (field == null) {
+    return
+  }
+  if (field.value.isNullReference) {
+    return
+  }
+  val heapObject = field.value.asObject!!
+  val delegateReporter = ObjectReporter(heapObject)
+  inspector.inspect(delegateReporter)
+  val prefix = "${field.declaringClass.simpleName}#${field.name}:"
+
+  labels += delegateReporter.labels.map { "$prefix $it" }
+  leakingReasons += delegateReporter.leakingReasons.map { "$prefix $it" }
+  notLeakingReasons += delegateReporter.notLeakingReasons.map { "$prefix $it" }
+}
+
+private val HeapInstance.lifecycleRegistryState: String
+  get() {
+    // LifecycleRegistry was converted to Kotlin
+    // https://cs.android.com/androidx/platform/frameworks/support/+/36833f9ab0c50bf449fc795e297a0e124df3356e
+    val stateField = this["androidx.lifecycle.LifecycleRegistry", "state"]
+      ?: this["androidx.lifecycle.LifecycleRegistry", "mState"]!!
+    val state = stateField.valueAsInstance!!
+    return state["java.lang.Enum", "name"]!!.value.readAsJavaString()!!
+}
+
+/**
+ * Recursively unwraps `this` [HeapInstance] as a ContextWrapper until an Activity is found in which case it is
+ * returned. Returns null if no activity was found.
+ */
+internal fun HeapInstance.unwrapActivityContext(): HeapInstance? {
+  return unwrapComponentContext().let { context ->
+    if (context != null && context instanceOf "android.app.Activity") {
+      context
+    } else {
+      null
+    }
+  }
+}
+
+/**
+ * Recursively unwraps `this` [HeapInstance] as a ContextWrapper until an known Android component
+ * context is found in which case it is returned. Returns null if no activity was found.
+ */
+@Suppress("NestedBlockDepth", "ReturnCount")
+internal fun HeapInstance.unwrapComponentContext(): HeapInstance? {
+  val matchingClassName = instanceClass.classHierarchy.map { it.name }
+    .firstOrNull {
+      when (it) {
+        "android.content.ContextWrapper",
+        "android.app.Activity",
+        "android.app.Application",
+        "android.app.Service"
+        -> true
+        else -> false
+      }
+    }
+    ?: return null
+
+  if (matchingClassName != "android.content.ContextWrapper") {
+    return this
+  }
+
+  var context = this
+  val visitedInstances = mutableListOf<Long>()
+  var keepUnwrapping = true
+  while (keepUnwrapping) {
+    visitedInstances += context.objectId
+    keepUnwrapping = false
+    val mBase = context["android.content.ContextWrapper", "mBase"]!!.value
+
+    if (mBase.isNonNullReference) {
+      val wrapperContext = context
+      context = mBase.asObject!!.asInstance!!
+
+      val contextMatchingClassName = context.instanceClass.classHierarchy.map { it.name }
+        .firstOrNull {
+          when (it) {
+            "android.content.ContextWrapper",
+            "android.app.Activity",
+            "android.app.Application",
+            "android.app.Service"
+            -> true
+            else -> false
+          }
+        }
+
+      var isContextWrapper = contextMatchingClassName == "android.content.ContextWrapper"
+
+      if (contextMatchingClassName == "android.app.Activity") {
+        return context
+      } else {
+        if (wrapperContext instanceOf "com.android.internal.policy.DecorContext") {
+          // mBase isn't an activity, let's unwrap DecorContext.mPhoneWindow.mContext instead
+          val mPhoneWindowField =
+            wrapperContext["com.android.internal.policy.DecorContext", "mPhoneWindow"]
+          if (mPhoneWindowField != null) {
+            val phoneWindow = mPhoneWindowField.valueAsInstance!!
+            context = phoneWindow["android.view.Window", "mContext"]!!.valueAsInstance!!
+            if (context instanceOf "android.app.Activity") {
+              return context
+            }
+            isContextWrapper = context instanceOf "android.content.ContextWrapper"
+          }
+        }
+        if (contextMatchingClassName == "android.app.Service" ||
+          contextMatchingClassName == "android.app.Application"
+        ) {
+          return context
+        }
+        if (isContextWrapper &&
+          // Avoids infinite loops
+          context.objectId !in visitedInstances
+        ) {
+          keepUnwrapping = true
+        }
+      }
+    }
+  }
+  return null
+}
+
+/**
+ * Same as [HeapInstance.readField] but throws if the field doesnt exist
+ */
+internal fun HeapInstance.getOrThrow(
+  declaringClassName: String,
+  fieldName: String
+): HeapField {
+  return this[declaringClassName, fieldName] ?: throw IllegalStateException(
+    """
+$instanceClassName is expected to have a $declaringClassName.$fieldName field which cannot be found.
+This might be due to the app code being obfuscated. If that's the case, then the heap analysis
+is unable to proceed without a mapping file to deobfuscate class names.
+You can run LeakCanary on obfuscated builds by following the instructions at
+https://square.github.io/leakcanary/recipes/#using-leakcanary-with-obfuscated-apps
+      """
+  )
+}
diff --git a/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt b/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
new file mode 100644
index 00000000..7e2b2cee
--- /dev/null
+++ b/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
@@ -0,0 +1,1737 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package shark
+
+import java.lang.ref.PhantomReference
+import java.lang.ref.SoftReference
+import java.lang.ref.WeakReference
+import java.util.EnumSet
+import shark.AndroidReferenceMatchers.Companion.appDefaults
+import shark.AndroidReferenceMatchers.Companion.buildKnownReferences
+import shark.ReferencePattern.InstanceFieldPattern
+import shark.ReferencePattern.JavaLocalPattern
+import shark.ReferencePattern.NativeGlobalVariablePattern
+import shark.ReferencePattern.StaticFieldPattern
+
+/**
+ * [AndroidReferenceMatchers] values add [ReferenceMatcher] instances to a global list via their
+ * [add] method. A [ReferenceMatcher] is either a [IgnoredReferenceMatcher] or
+ * a [LibraryLeakReferenceMatcher].
+ *
+ * [AndroidReferenceMatchers] is used to build the list of known references that cannot ever create
+ * leaks (via [IgnoredReferenceMatcher]) as well as the list of known leaks in the Android Framework
+ * andÂ in manufacturer specific Android implementations.
+ *
+ * This class is a work in progress. You can help by reporting leak traces that seem to be caused
+ * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
+ *
+ * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
+ * manufacturer implementation, they usually share their builds across multiple models, and the
+ * leaks eventually get fixed in newer versions.
+ *
+ * Most app developers should use [appDefaults]. However, you can also use a subset of
+ * [AndroidReferenceMatchers] by creating an [EnumSet] that matches your needs and calling
+ * [buildKnownReferences].
+ */
+enum class AndroidReferenceMatchers {
+
+  // ######## Android Framework known leaks ########
+
+  IREQUEST_FINISH_CALLBACK {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.app.Activity\$1", "this\$0",
+        description = "Android Q added a new android.app.IRequestFinishCallback\$Stub " +
+          "class. android.app.Activity creates an implementation of that interface as an " +
+          "anonymous subclass. That anonymous subclass has a reference to the activity. " +
+          "Another process is keeping the android.app.IRequestFinishCallback\$Stub " +
+          "reference alive long after Activity.onDestroyed() has been called, " +
+          "causing the activity to leak. " +
+          "Fix: You can \"fix\" this leak by overriding Activity.onBackPressed() and calling " +
+          "Activity.finishAfterTransition(); instead of super if the activity is task root and the " +
+          "fragment stack is empty. " +
+          "Tracked here: https://issuetracker.google.com/issues/139738913"
+      ) {
+        sdkInt == 29
+      }
+    }
+  },
+
+  /**
+   * See AndroidReferenceReaders.ACTIVITY_THREAD__NEW_ACTIVITIES for more context
+   */
+  ACTIVITY_THREAD__M_NEW_ACTIVITIES {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.app.ActivityThread", "mNewActivities",
+        description = """
+          New activities are leaked by ActivityThread until the main thread becomes idle.
+          Tracked here: https://issuetracker.google.com/issues/258390457
+        """.trimIndent()
+      ) {
+        sdkInt >= 19
+      }
+    }
+  },
+
+  SPAN_CONTROLLER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      val description =
+        ("Editor inserts a special span, which has a reference to the EditText. That span is a"
+          + " NoCopySpan, which makes sure it gets dropped when creating a new"
+          + " SpannableStringBuilder from a given CharSequence."
+          + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
+          + " bundle. Prior to KitKat, that copy was done using the SpannableString"
+          + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
+          + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
+          + " reference to the textview and therefore the entire view hierarchy & activity"
+          + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
+          + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
+          + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
+          + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.")
+
+      references += instanceFieldLeak(
+        "android.widget.Editor\$SpanController", "this$0", description
+      ) {
+        sdkInt <= 19
+      }
+
+      references += instanceFieldLeak(
+        "android.widget.Editor\$EasyEditSpanController", "this$0", description
+      ) {
+        sdkInt <= 19
+      }
+    }
+  },
+
+  MEDIA_SESSION_LEGACY_HELPER__SINSTANCE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references +=
+        staticFieldLeak(
+          "android.media.session.MediaSessionLegacyHelper", "sInstance",
+          description = "MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
+            + " keeps a reference to the context it's given the first time"
+            + " MediaSessionLegacyHelper.getHelper() is called."
+            + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
+            + " calling context.getApplicationContext()."
+            + " Fix: https://github.com/android/platform_frameworks_base/commit"
+            + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
+            + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
+            + " in Application.onCreate() and pass it the application context."
+        ) {
+          sdkInt == 21
+        }
+    }
+  },
+
+  TEXT_LINE__SCACHED {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+        "android.text.TextLine", "sCached",
+        description = "TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
+          + " at least two bugs that created memory leaks by not correctly clearing the"
+          + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
+          + " https://github.com/android/platform_frameworks_base/commit"
+          + "/893d6fe48d37f71e683f722457bea646994a10"
+          + " The second was fixed, not released yet:"
+          + " https://github.com/android/platform_frameworks_base/commit"
+          + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
+          + " To fix this, you could access TextLine.sCached and clear the pool every now"
+          + " and then (e.g. on activity destroy)."
+      ) {
+        sdkInt <= 22
+      }
+    }
+  },
+
+  BLOCKING_QUEUE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      val description = ("A thread waiting on a blocking queue will leak the last"
+        + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
+        + " keeps a local reference to the last message it received. That message then gets"
+        + " recycled and can be used again. As long as all messages are recycled after being"
+        + " used, this won't be a problem, because these references are cleared when being"
+        + " recycled. However, dialogs create template Message instances to be copied when a"
+        + " message needs to be sent. These Message templates holds references to the dialog"
+        + " listeners, which most likely leads to holding a reference onto the activity in some"
+        + " way. Dialogs never recycle their template Message, assuming these Message instances"
+        + " will get GCed when the dialog is GCed."
+        + " The combination of these two things creates a high potential for memory leaks as soon"
+        + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
+        + " sleep for a long time."
+        + " This leak is fixed by AndroidLeakFixes.FLUSH_HANDLER_THREADS in plumber-android."
+        + " Bug report: https://issuetracker.google.com/issues/146144484"
+        + " Fixed in Android 12: https://cs.android.com/android/_/android/platform/frameworks/base"
+        + "/+/d577e728e9bccbafc707af3060ea914caa73c14f")
+
+      references += instanceFieldLeak("android.os.Message", "obj", description) {
+        sdkInt < 31
+      }
+    }
+  },
+
+  INPUT_METHOD_MANAGER_IS_TERRIBLE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      val description =
+        ("When we detach a view that receives keyboard input, the InputMethodManager"
+          + " leaks a reference to it until a new view asks for keyboard input."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
+          + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414")
+
+      references += instanceFieldLeak(
+        "android.view.inputmethod.InputMethodManager", "mNextServedView", description
+      ) {
+        sdkInt in 15..33
+      }
+
+      references += instanceFieldLeak(
+        "android.view.inputmethod.InputMethodManager", "mServedView", description
+      ) {
+        sdkInt in 15..28
+      }
+
+      references += instanceFieldLeak(
+        "android.view.inputmethod.InputMethodManager", "mServedInputConnection", description
+      ) {
+        sdkInt in 15..27
+      }
+
+      references += instanceFieldLeak(
+        "android.view.inputmethod.InputMethodManager", "mLastSrvView",
+        description =
+        "HUAWEI added a mLastSrvView field to InputMethodManager" + " that leaks a reference to the last served view."
+      ) {
+        manufacturer == HUAWEI && sdkInt in 23..28
+      }
+
+      references += instanceFieldLeak(
+        "android.view.inputmethod.InputMethodManager", "mCurRootView",
+        description = "The singleton InputMethodManager is holding a reference to mCurRootView long"
+          + " after the activity has been destroyed."
+          + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
+          + "#issuecomment-100579429"
+          + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414"
+      ) {
+        sdkInt in 15..28
+      }
+
+      references += instanceFieldLeak(
+        "android.view.inputmethod.InputMethodManager", "mImeInsetsConsumer",
+        description = """
+              InputMethodManager.mImeInsetsConsumer isn't set to null when the activity is destroyed.
+            """.trimIndent()
+      ) {
+        sdkInt >= 30
+      }
+    }
+  },
+
+  INPUT_MANAGER__M_LATE_INIT_CONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.hardware.input.InputManager", "mLateInitContext",
+        description = "InputManager singleton leaks its init context which is an activity"
+      ) {
+        sdkInt == 33
+      }
+    }
+  },
+
+  LAYOUT_TRANSITION {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.animation.LayoutTransition$1", "val\$parent",
+        description = "LayoutTransition leaks parent ViewGroup through"
+          + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
+          + " window is destroyed. Tracked here:"
+          + " https://code.google.com/p/android/issues/detail?id=171830"
+      ) {
+        sdkInt in 14..22
+      }
+    }
+  },
+
+  SPELL_CHECKER_SESSION {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.view.textservice.SpellCheckerSession$1", "this$0",
+        description = "SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
+          + " SpellCheckerSession is closed before the service is connected."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542"
+      ) {
+        sdkInt in 16..24
+      }
+    }
+  },
+
+  SPELL_CHECKER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.widget.SpellChecker$1", "this$0",
+        description = "SpellChecker holds on to a detached view that points to a destroyed activity."
+          + " mSpellRunnable is being enqueued, and that callback should be removed when "
+          + " closeSession() is called. Maybe closeSession() wasn't called, or maybe it was "
+          + " called after the view was detached."
+      ) {
+        sdkInt == 22
+      }
+    }
+  },
+
+  ACTIVITY_CHOOSE_MODEL {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      val description = ("ActivityChooserModel holds a static reference to the last set"
+        + " ActivityChooserModelPolicy which can be an activity context."
+        + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
+        + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0")
+
+
+      references += instanceFieldLeak(
+        "android.support.v7.internal.widget.ActivityChooserModel",
+        "mActivityChoserModelPolicy",
+        description = description
+      ) {
+        sdkInt in 15..22
+      }
+
+      references += instanceFieldLeak(
+        "android.widget.ActivityChooserModel", "mActivityChoserModelPolicy",
+        description = description
+      )
+    }
+  },
+
+  MEDIA_PROJECTION_CALLBACK {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+        "android.media.projection.MediaProjection\$MediaProjectionCallback",
+        "this$0", description = """
+              MediaProjectionCallback is held by another process, and holds on to MediaProjection
+              which has an activity as its context.
+            """.trimIndent()
+      ) {
+        sdkInt in 22..28
+      }
+    }
+  },
+
+  SPEECH_RECOGNIZER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.speech.SpeechRecognizer\$InternalListener", "this$0",
+        description = "Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
+          + " class and leaked the SpeechRecognizer which leaked an activity context."
+          + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+          + " /b37866db469e81aca534ff6186bdafd44352329b"
+      ) {
+        sdkInt < 21
+      }
+    }
+  },
+
+  ACCOUNT_MANAGER__AMS_TASK__RESPONSE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += nativeGlobalVariableLeak(
+        "android.accounts.AccountManager\$AmsTask\$Response",
+        description = """
+          AccountManager.AmsTask.Response is a stub, and as all stubs it's held in memory by a
+          native ref until the calling side gets GCed, which can happen long after the stub is no
+          longer of use.
+          https://issuetracker.google.com/issues/318303120
+        """.trimIndent()
+      ) {
+        sdkInt >= 5
+      }
+    }
+  },
+
+  MEDIA_SCANNER_CONNECTION {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.media.MediaScannerConnection", "mContext",
+
+        description =
+        "The static method MediaScannerConnection.scanFile() takes an activity context"
+          + " but the service might not disconnect after the activity has been destroyed."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
+          + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
+          + " application context. Call connect() and disconnect() manually."
+      ) {
+        sdkInt <= 22
+      }
+    }
+  },
+
+  USER_MANAGER__SINSTANCE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.os.UserManager", "mContext",
+        description =
+        "UserManager has a static sInstance field that creates an instance and caches it"
+          + " the first time UserManager.get() is called. This instance is created with the"
+          + " outer context (which is an activity base context)."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
+          + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
+          + "/27db46850b708070452c0ce49daf5f79503fbde6"
+          + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
+          + " UserManager instance gets cached with a reference to the application context."
+      ) {
+        sdkInt in 18..25
+      }
+    }
+  },
+
+  APP_WIDGET_HOST_CALLBACKS {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.appwidget.AppWidgetHost\$Callbacks", "this$0",
+        description =
+        "android.appwidget.AppWidgetHost\$Callbacks is a stub and is held in memory native"
+          + " code. The reference to the `mContext` was not being cleared, which caused the"
+          + " Callbacks instance to retain this reference"
+          + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+          + "/7a96f3c917e0001ee739b65da37b2fadec7d7765"
+      ) {
+        sdkInt < 22
+      }
+    }
+  },
+
+  AUDIO_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.media.AudioManager$1", "this$0",
+        description =
+        "Prior to Android M, VideoView required audio focus from AudioManager and"
+          + " never abandoned it, which leaks the Activity context through the AudioManager."
+          + " The root of the problem is that AudioManager uses whichever"
+          + " context it receives, which in the case of the VideoView example is an Activity,"
+          + " even though it only needs the application's context. The issue is fixed in"
+          + " Android M, and the AudioManager now uses the application's context."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
+          + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2"
+      ) {
+        sdkInt <= 22
+      }
+    }
+  },
+
+  EDITTEXT_BLINK_MESSAGEQUEUE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.widget.Editor\$Blink", "this$0",
+        description =
+        "The EditText Blink of the Cursor is implemented using a callback and Messages,"
+          + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
+          + " contains a blinking cursor is detached, a message is posted with a delay after the"
+          + " dialog has been closed and as a result leaks the Activity."
+          + " This can be fixed manually by calling TextView.setCursorVisible(false) in the"
+          + " dismiss() method of the dialog."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
+          + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
+          + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/"
+      ) {
+        sdkInt <= 23
+      }
+    }
+  },
+
+  CONNECTIVITY_MANAGER__SINSTANCE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.net.ConnectivityManager", "sInstance",
+        description =
+        "ConnectivityManager has a sInstance field that is set when the first"
+          + " ConnectivityManager instance is created. ConnectivityManager has a mContext field."
+          + " When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first"
+          + " ConnectivityManager instance is created with the activity context and stored in"
+          + " sInstance. That activity context then leaks forever."
+          + " Until this is fixed, app developers can prevent this leak by making sure the"
+          + " ConnectivityManager is first created with an App Context. E.g. in some static"
+          + " init do: context.getApplicationContext()"
+          + ".getSystemService(Context.CONNECTIVITY_SERVICE)"
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=198852"
+          + " Introduced here: https://github.com/android/platform_frameworks_base/commit/"
+          + "e0bef71662d81caaaa0d7214fb0bef5d39996a69"
+      ) {
+        sdkInt <= 23
+      }
+    }
+  },
+
+  ACCESSIBILITY_NODE_INFO__MORIGINALTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.view.accessibility.AccessibilityNodeInfo", "mOriginalText",
+        description =
+        "AccessibilityNodeInfo has a static sPool of AccessibilityNodeInfo. When"
+          + " AccessibilityNodeInfo instances are released back in the pool,"
+          + " AccessibilityNodeInfo.clear() does not clear the mOriginalText field, which"
+          + " causes spans to leak which in turns causes TextView.ChangeWatcher to leak and the"
+          + " whole view hierarchy. Introduced here: https://android.googlesource.com/platform/"
+          + "frameworks/base/+/193520e3dff5248ddcf8435203bf99d2ba667219%5E%21/core/java/"
+          + "android/view/accessibility/AccessibilityNodeInfo.java"
+      ) {
+        sdkInt in 26..27
+      }
+    }
+  },
+
+  ASSIST_STRUCTURE {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+        "android.app.assist.AssistStructure\$ViewNodeText", "mText",
+        description = "AssistStructure (google assistant / autofill) holds on to text spannables" +
+          " on the screen. TextView.ChangeWatcher and android.widget.Editor end up in spans and" +
+          " typically hold on to the view hierarchy"
+      ) {
+        sdkInt >= 24
+      }
+    }
+  },
+
+  ACCESSIBILITY_ITERATORS {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+        "android.widget.AccessibilityIterators\$LineTextSegmentIterator", "mLayout",
+        description = "AccessibilityIterators holds on to text layouts which can hold on to spans" +
+          " TextView.ChangeWatcher and android.widget.Editor end up in spans and" +
+          " typically hold on to the view hierarchy"
+      ) {
+        sdkInt == 27
+      }
+    }
+  },
+
+  BIOMETRIC_PROMPT {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+        "android.hardware.biometrics.BiometricPrompt", "mFingerprintManager",
+        description = "BiometricPrompt holds on to a FingerprintManager which holds on to a " +
+          "destroyed activity."
+      ) {
+        sdkInt == 28
+      }
+    }
+  },
+
+  MAGNIFIER {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+        "android.widget.Magnifier\$InternalPopupWindow", "mCallback",
+        description = "android.widget.Magnifier.InternalPopupWindow registers a frame callback" +
+          " on android.view.ThreadedRenderer.SimpleRenderer which holds it as a native" +
+          " reference. android.widget.Editor\$InsertionHandleView registers an" +
+          " OnOperationCompleteCallback on Magnifier.InternalPopupWindow. These references are" +
+          " held after the activity has been destroyed."
+      ) {
+        sdkInt == 28
+      }
+    }
+  },
+
+  BACKDROP_FRAME_RENDERER__MDECORVIEW {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "com.android.internal.policy.BackdropFrameRenderer", "mDecorView",
+        description =
+        "When BackdropFrameRenderer.releaseRenderer() is called, there's an unknown case"
+          + " where mRenderer becomes null but mChoreographer doesn't and the thread doesn't"
+          + " stop and ends up leaking mDecorView which itself holds on to a destroyed"
+          + " activity"
+      ) {
+        sdkInt in 24..26
+      }
+    }
+  },
+
+  VIEWLOCATIONHOLDER_ROOT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.view.ViewGroup\$ViewLocationHolder",
+        "mRoot",
+        description = "In Android P, ViewLocationHolder has an mRoot field that is not cleared " +
+          "in its clear() method. Introduced in https://github.com/aosp-mirror" +
+          "/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909d Bug " +
+          "report: https://issuetracker.google.com/issues/112792715"
+      ) {
+        sdkInt == 28
+      }
+    }
+  },
+
+  ACCESSIBILITY_NODE_ID_MANAGER {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+        "android.view.accessibility.AccessibilityNodeIdManager", "mIdsToViews",
+        description = """
+              Android Q Beta added AccessibilityNodeIdManager which stores all views from their
+              onAttachedToWindow() call, until detached. Unfortunately it's possible to trigger
+              the view framework to call detach before attach (by having a view removing itself
+              from its parent in onAttach, which then causes AccessibilityNodeIdManager to keep
+              children view forever. Future releases of Q will hold weak references.
+            """.trimIndent()
+      ) {
+        sdkInt in 28..29
+      }
+    }
+  },
+
+  TEXT_TO_SPEECH {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      val description =
+        ("TextToSpeech.shutdown() does not release its references to context objects." +
+          " Furthermore, TextToSpeech instances cannot be garbage collected due to other process" +
+          " keeping the references, resulting the context objects leaked." +
+          " Developers might be able to mitigate the issue by passing application context" +
+          " to TextToSpeech constructor." +
+          " Tracked at: https://github.com/square/leakcanary/issues/1210 and" +
+          " https://issuetracker.google.com/issues/129250419")
+      references += instanceFieldLeak(
+        "android.speech.tts.TextToSpeech", "mContext",
+        description = description
+      ) {
+        sdkInt == 24
+      }
+
+      references += instanceFieldLeak(
+        "android.speech.tts.TtsEngines", "mContext",
+        description = description
+      ) {
+        sdkInt == 24
+      }
+    }
+  },
+
+  CONTROLLED_INPUT_CONNECTION_WRAPPER {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += nativeGlobalVariableLeak(
+        "android.view.inputmethod.InputMethodManager\$ControlledInputConnectionWrapper",
+        description = """
+        ControlledInputConnectionWrapper is held by a global variable in native code.
+      """.trimIndent()
+      )
+    }
+  },
+
+  TOAST_TN {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += nativeGlobalVariableLeak(
+        "android.widget.Toast\$TN",
+        description = """
+        Toast.TN is held by a global variable in native code due to an IPC call to show the toast.
+      """.trimIndent()
+      )
+    }
+  },
+
+  APPLICATION_PACKAGE_MANAGER__HAS_SYSTEM_FEATURE_QUERY {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+        "android.app.ApplicationPackageManager\$HasSystemFeatureQuery", "this\$0",
+        description = """
+          In Android 11 DP 2 ApplicationPackageManager.HasSystemFeatureQuery was an inner class.
+          Introduced in https://cs.android.com/android/_/android/platform/frameworks/base/+/89608118192580ffca026b5dacafa637a556d578
+          Fixed in https://cs.android.com/android/_/android/platform/frameworks/base/+/1f771846c51148b7cb6283e6dc82a216ffaa5353
+          Related blog: https://dev.to/pyricau/beware-packagemanager-leaks-223g
+        """.trimIndent()
+      ) {
+        sdkInt == 29
+      }
+    }
+  },
+
+  COMPANION_DEVICE_SERVICE__STUB {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+        "android.companion.CompanionDeviceService\$Stub", "this\$0",
+        description = """
+          Android 12 added android.companion.CompanionDeviceService, a bounded service extended by
+          applications to which the system binds. CompanionDeviceService.Stub is an inner class
+          that holds a reference to CompanionDeviceService, which itself holds a Stub instance
+          that's not nullified after the service is destroyed.
+          Introduced in https://android.googlesource.com/platform/frameworks/base/+/df69bbaf29e41d9df105612500c27be730feedfc
+          Source code: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/companion/CompanionDeviceService.java
+        """.trimIndent()
+      ) {
+        sdkInt == 31
+      }
+    }
+  },
+
+  RENDER_NODE_ANIMATOR {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += nativeGlobalVariableLeak(
+        "android.graphics.animation.RenderNodeAnimator",
+        description = """
+          When a view is detached while a ripple animation is still playing on it, the native code
+          doesn't properly end the RenderNodeAnimator, i.e. it doesn't call
+          RenderNodeAnimator.callOnFinished and doesn't let go of the native ref, leading to a
+          leak of the detached animated view.
+          Tracked at: https://issuetracker.google.com/issues/229136453
+        """.trimIndent()
+      ) {
+        sdkInt in 31..32
+      }
+    }
+  },
+
+  PLAYER_BASE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += nativeGlobalVariableLeak(
+        "android.media.PlayerBase\$1",
+        description = """
+          PlayerBase$1 implements IAppOpsCallback as an inner class and is held by a native
+          ref, preventing subclasses of PlayerBase to be GC'd.
+          Introduced in API 24: https://cs.android.com/android/_/android/platform/frameworks/base/+/3c86a343dfca1b9e2e28c240dc894f60709e392c
+          Fixed in API 28: https://cs.android.com/android/_/android/platform/frameworks/base/+/aee6ee94675d56e71a42d52b16b8d8e5fa6ea3ff
+        """.trimIndent()
+      ) {
+        sdkInt in 24..27
+      }
+    }
+  },
+
+  WINDOW_ON_BACK_INVOKED_DISPATCHER__STUB {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.window.WindowOnBackInvokedDispatcher\$OnBackInvokedCallbackWrapper", "mCallback",
+        description = """
+          WindowOnBackInvokedDispatcher.OnBackInvokedCallbackWrapper is an IPC stub that holds a
+          reference to a callback which itself holds a view root. Another process is keeping the
+          stub alive long after the view root has been detached.
+          Tracked here: https://issuetracker.google.com/issues/229007483
+        """.trimIndent()
+      ) {
+        // Detected in Android 13 DP2, should be fixed in the next release.
+        sdkInt == 32 && id == "TPP2.220218.008"
+      }
+    }
+  },
+
+  CONNECTIVITY_MANAGER_CALLBACK_HANDLER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "ConnectivityManager\$CallbackHandler", "this\$0",
+        description = """
+          ConnectivityManager.CallbackHandler instances can be held statically and hold
+          a reference to ConnectivityManager instances created with a local context (e.g. activity).
+          Filed: https://issuetracker.google.com/issues/258053962
+          Fixed in API 34.
+        """.trimIndent()
+      ) {
+        sdkInt == 33
+      }
+    }
+  },
+
+  HOST_ADPU_SERVICE_MSG_HANDLER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.nfc.cardemulation.HostApduService\$MsgHandler", "this\$0",
+        description = """
+          Destroyed HostApduService instances are held by a handler instance that lives longer
+          than the service.
+          Report: https://github.com/square/leakcanary/issues/2390
+        """.trimIndent()
+      ) {
+        sdkInt in 29..33
+      }
+    }
+  },
+
+  APP_OPS_MANAGER__CALLBACK_STUB {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += nativeGlobalVariableLeak(
+        "android.app.AppOpsManager\$3",
+        description = """
+          Fix: Update androidx.core:core to 1.10.0-alpha01 or greater as it includes an Android 12
+          fix for this leak on Android 12, see https://github.com/androidx/androidx/pull/435 .
+          AppOpsManager\$3 implements IAppOpsActiveCallback.Stub and is held by a native ref long
+          until the calling side gets GCed, which can happen long after the stub is no longer of
+          use.
+        """.trimIndent()
+      ) {
+        sdkInt in 31..32
+      }
+    }
+  },
+
+  VIEW_GROUP__M_PRE_SORTED_CHILDREN {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.view.ViewGroup", "mPreSortedChildren",
+        description = """
+          ViewGroup.mPreSortedChildren is used as a temporary list but not cleared after being
+          used.
+          Report: https://issuetracker.google.com/issues/178029590
+          Fix: https://cs.android.com/android/_/android/platform/frameworks/base/+/73590c7751b9185137de962ba9ad9ff5a6e11e5d
+        """.trimIndent()
+      ) {
+        sdkInt == 30
+      }
+    }
+  },
+
+  VIEW_GROUP__M_CURRENT_DRAG_CHILD {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.view.ViewGroup", "mCurrentDragChild",
+        description = """
+          ViewGroup.mCurrentDragChild keeps a reference to a view that was dragged after that view
+          has been detached.
+          Report: https://issuetracker.google.com/issues/170276524
+        """.trimIndent()
+      ) {
+        sdkInt in 29..30
+      }
+    }
+  },
+
+  VIEW_TOOLTIP_CALLBACK {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      // Note: the lambda order changes every release, so ideally we'd pull the dex code for
+      // every release and look at the exact class name for the this::showHoverTooltip and the
+      // this::hideTooltip lambda references in View.java . That's too much work, so we'll just
+      // rely on reports from the field:
+      // - API 33: android.view.View$$ExternalSyntheticLambda3.f$0
+      references += instanceFieldLeak(
+        "android.view.View\$\$ExternalSyntheticLambda3", "f\$0",
+        description = """
+          When a View has tooltip text set, every hover event will fire a callback
+          to hide the tooltip after a 15 second timeout. Since the callback holds
+          a reference to the View, it will leak the View for that duration after
+          the Activity is finished or the View is removed.
+          https://cs.android.com/android/_/android/platform/frameworks/base/+/708dbe80902b963388c412f670c56ae00953273a
+        """.trimIndent()
+      ) {
+        sdkInt in 26..34
+      }
+    }
+  },
+
+  ACTIVITY_TRANSITION_STATE__M_EXITING_TO_VIEW {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.app.ActivityTransitionState", "mExitingToView",
+        description = """
+          Shared element transition leak the view that was used in the transition.
+          Report: https://issuetracker.google.com/issues/141132765
+        """.trimIndent()
+      ) {
+        sdkInt in 28..29
+      }
+    }
+  },
+
+  ANIMATION_HANDLER__ANIMATOR_REQUESTORS {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.animation.AnimationHandler", "mAnimatorRequestors",
+        description = """
+          AnimationHandler is a singleton holding an activity ViewRootImpl requestor after the
+          activity has been destroyed.
+          Report: https://issuetracker.google.com/issues/258534826
+        """.trimIndent()
+      ) {
+        sdkInt == 33
+      }
+    }
+  },
+
+  FLIPPER__APPLICATION_DESCRIPTOR {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+        "com.facebook.flipper.plugins.inspector.descriptors.ApplicationDescriptor",
+        "editedDelegates",
+        description = """
+          Flipper's ApplicationDescriptor leaks root views after they've been detached.
+          https://github.com/facebook/flipper/issues/4270
+        """.trimIndent()
+      )
+    }
+  },
+
+  AW_CONTENTS__A0 {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      staticFieldLeak(
+        "org.chromium.android_webview.AwContents",
+        "A0",
+        description = """
+          WindowAndroidWrapper has a strong ref to the context key so this breaks the WeakHashMap
+          contracts and WeakHashMap is unable to perform its job of auto cleaning.
+          https://github.com/square/leakcanary/issues/2538
+        """.trimIndent()
+      )
+    }
+  },
+
+  AW_CONTENTS_POSTED_CALLBACK {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      val description = "Android System WebView leak: " +
+        "https://bugs.chromium.org/p/chromium/issues/detail?id=1499154"
+      instanceFieldLeak(
+        "WV.R9",
+        "e",
+        description
+      )
+      instanceFieldLeak(
+        "WV.a6",
+        "c",
+        description
+      )
+      instanceFieldLeak(
+        "WV.H5",
+        "c",
+        description
+      )
+      instanceFieldLeak(
+        "WV.Y9",
+        "e",
+        description
+      )
+      instanceFieldLeak(
+        "WV.U4",
+        "c",
+        description
+      )
+    }
+  },
+
+  JOB_SERVICE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      AndroidReferenceMatchers.nativeGlobalVariableLeak(
+        className = "android.app.job.JobService\$1",
+        description = """
+          JobService used to be leaked via a binder stub.
+          Fix: https://cs.android.com/android/_/android/platform/frameworks/base/+/0796e9fb3dc2dd03fa5ff2053c63f14861cffa2f
+        """.trimIndent()
+      ) { sdkInt < 24 }
+    }
+  },
+
+  DREAM_SERVICE {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      AndroidReferenceMatchers.nativeGlobalVariableLeak(
+        className = "android.service.dreams.DreamService\$1",
+        description = """
+          DreamService leaks a binder stub.
+          https://github.com/square/leakcanary/issues/2534
+        """.trimIndent()
+      ) { sdkInt >= 33 }
+    }
+  },
+
+  // ######## Manufacturer specific known leaks ########
+
+  // SAMSUNG
+
+  SPEN_GESTURE_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+        "com.samsung.android.smartclip.SpenGestureManager", "mContext",
+        description =
+        "SpenGestureManager has a static mContext field that leaks a reference to the" + " activity. Yes, a STATIC mContext field."
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  CLIPBOARD_UI_MANAGER__SINSTANCE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.sec.clipboard.ClipboardUIManager", "mContext",
+        description =
+        "ClipboardUIManager is a static singleton that leaks an activity context."
+          + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
+          + " , so that the ClipboardUIManager instance gets cached with a reference to the"
+          + " application context. Example: https://gist.github.com/cypressious/"
+          + "91c4fb1455470d803a602838dfcd5774"
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 19..21
+      }
+    }
+  },
+
+  SEM_CLIPBOARD_MANAGER__MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      val description = """
+         SemClipboardManager inner classes are held by native references due to IPC calls
+      """.trimIndent()
+      references += nativeGlobalVariableLeak(
+        "com.samsung.android.content.clipboard.SemClipboardManager$1", description
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 19..28
+      }
+      references += nativeGlobalVariableLeak(
+        "com.samsung.android.content.clipboard.SemClipboardManager$3", description
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 19..28
+      }
+    }
+  },
+
+  CLIPBOARD_EX_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.sec.clipboard.ClipboardExManager", "mContext",
+        description = "android.sec.clipboard.ClipboardExManager\$IClipboardDataPasteEventImpl\$1" +
+          " is a native callback that holds IClipboardDataPasteEventImpl which holds" +
+          " ClipboardExManager which has a destroyed activity as mContext"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 23
+      }
+      references += instanceFieldLeak(
+        "android.sec.clipboard.ClipboardExManager", "mPersonaManager",
+        description = "android.sec.clipboard.ClipboardExManager\$IClipboardDataPasteEventImpl\$1" +
+          " is a native callback that holds IClipboardDataPasteEventImpl which holds" +
+          " ClipboardExManager which holds PersonaManager which has a destroyed activity as" +
+          " mContext"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 23
+      }
+      references += instanceFieldLeak(
+        "android.widget.TextView\$IClipboardDataPasteEventImpl", "this\$0",
+        description = "TextView\$IClipboardDataPasteEventImpl\$1 is held by a native ref, and" +
+          " IClipboardDataPasteEventImpl ends up leaking a detached textview"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 22
+      }
+    }
+  },
+
+  SEM_EMERGENCY_MANAGER__MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "com.samsung.android.emergencymode.SemEmergencyManager", "mContext",
+        description =
+        "SemEmergencyManager is a static singleton that leaks a DecorContext." +
+          " Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d"
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 19..24
+      }
+    }
+  },
+
+  SEM_PERSONA_MANAGER {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+        "com.samsung.android.knox.SemPersonaManager", "mContext"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 24
+      }
+    }
+  },
+
+  SEM_APP_ICON_SOLUTION {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+        "android.app.SemAppIconSolution", "mContext"
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 28..29
+      }
+    }
+  },
+
+  AW_RESOURCE__SRESOURCES {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      // AwResource#setResources() is called with resources that hold a reference to the
+      // activity context (instead of the application context) and doesn't clear it.
+      // Not sure what's going on there, input welcome.
+      references += staticFieldLeak(
+        "com.android.org.chromium.android_webview.AwResource", "sResources"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  TEXT_VIEW__MLAST_HOVERED_VIEW {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+        "android.widget.TextView", "mLastHoveredView",
+        description =
+        "mLastHoveredView is a static field in TextView that leaks the last hovered view."
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 19..31
+      }
+    }
+  },
+
+  PERSONA_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.os.PersonaManager", "mContext",
+        description =
+        "android.app.LoadedApk.mResources has a reference to"
+          + " android.content.res.Resources.mPersonaManager which has a reference to"
+          + " android.os.PersonaManager.mContext which is an activity."
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  RESOURCES__MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.content.res.Resources", "mContext",
+        description =
+        "In AOSP the Resources class does not have a context."
+          + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
+          + " instance that has a context that is the activity."
+          + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  VIEW_CONFIGURATION__MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.view.ViewConfiguration", "mContext",
+        description =
+        "In AOSP the ViewConfiguration class does not have a context."
+          + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
+          + " ViewConfiguration instance that has a context that is the activity."
+          + " Observed here: https://github.com/square/leakcanary/issues"
+          + "/1#issuecomment-100324683"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  AUDIO_MANAGER__MCONTEXT_STATIC {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+        "android.media.AudioManager", "mContext_static",
+        description =
+        "Samsung added a static mContext_static field to AudioManager, holds a reference"
+          + " to the activity."
+          + " Observed here: https://github.com/square/leakcanary/issues/32"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  ACTIVITY_MANAGER_MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+        "android.app.ActivityManager", "mContext",
+        description =
+        "Samsung added a static mContext field to ActivityManager, holds a reference"
+          + " to the activity."
+          + " Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:"
+          + " https://github.com/square/leakcanary/issues/177#issuecomment-222724283"
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 22..23
+      }
+    }
+  },
+
+  STATIC_MTARGET_VIEW {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+        "android.widget.TextView", "mTargetView",
+        description =
+        "Samsung added a static mTargetView field to TextView which holds on to detached views."
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 27
+      }
+    }
+  },
+
+  MULTI_WINDOW_DECOR_SUPPORT__MWINDOW {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "com.android.internal.policy.MultiWindowDecorSupport", "mWindow",
+        description = """DecorView isn't leaking but its mDecorViewSupport field holds
+            |a MultiWindowDecorSupport which has a mWindow field which holds a leaking PhoneWindow.
+            |DecorView.mDecorViewSupport doesn't exist in AOSP.
+            |Filed here: https://github.com/square/leakcanary/issues/1819
+          """.trimMargin()
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 26..29
+      }
+    }
+  },
+
+  IMM_CURRENT_INPUT_CONNECTION {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+        "android.view.inputmethod.InputMethodManager", "mCurrentInputConnection",
+        description = """
+              InputMethodManager keeps its EditableInputConnection after the activity has been
+              destroyed.
+              Filed here: https://github.com/square/leakcanary/issues/2300
+            """.trimIndent()
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 28..30
+      }
+    }
+  },
+
+  // OTHER MANUFACTURERS
+
+  GESTURE_BOOST_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+        "android.gestureboost.GestureBoostManager", "mContext",
+        description =
+        "GestureBoostManager is a static singleton that leaks an activity context." +
+          " Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756"
+      ) {
+        manufacturer == HUAWEI && sdkInt in 24..25
+      }
+    }
+  },
+
+  BUBBLE_POPUP_HELPER__SHELPER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+        "android.widget.BubblePopupHelper", "sHelper",
+        description =
+        "A static helper for EditText bubble popups leaks a reference to the latest" + " focused view."
+      ) {
+        manufacturer == LG && sdkInt in 19..22
+      }
+    }
+  },
+
+  LGCONTEXT__MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "com.lge.systemservice.core.LGContext", "mContext",
+        description = "LGContext is a static singleton that leaks an activity context."
+      ) {
+        manufacturer == LG && sdkInt == 21
+      }
+    }
+  },
+
+  SMART_COVER_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "com.lge.systemservice.core.SmartCoverManager", "mContext",
+        description = "SmartCoverManager\$CallbackRegister is a callback held by a native ref," +
+          " and SmartCoverManager ends up leaking an activity context."
+      ) {
+        manufacturer == LG && sdkInt == 27
+      }
+    }
+  },
+
+  IMM_LAST_FOCUS_VIEW {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.view.inputmethod.InputMethodManager", "mLastFocusView",
+        description = """
+          InputMethodManager has a mLastFocusView field that doesn't get cleared when the last
+          focused view becomes detached.
+        """.trimIndent()
+      ) {
+        manufacturer == LG && sdkInt == 29
+      }
+    }
+  },
+
+  MAPPER_CLIENT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "com.nvidia.ControllerMapper.MapperClient\$ServiceClient", "this$0",
+        description =
+        "Not sure exactly what ControllerMapper is about, but there is an anonymous"
+          + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
+          + " ControllerMapper.MapperClient which leaks the activity context."
+      ) {
+        manufacturer == NVIDIA && sdkInt == 19
+      }
+    }
+  },
+
+  SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+        "android.hardware.SystemSensorManager", "mAppContextImpl",
+        description =
+        "SystemSensorManager stores a reference to context"
+          + " in a static field in its constructor."
+          + " Fix: use application context to get SensorManager"
+      ) {
+        (manufacturer == LENOVO && sdkInt == 19) || (manufacturer == VIVO && sdkInt == 22)
+      }
+    }
+  },
+
+  INSTRUMENTATION_RECOMMEND_ACTIVITY {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+        "android.app.Instrumentation", "mRecommendActivity",
+        description =
+        "Instrumentation would leak com.android.internal.app.RecommendActivity (in"
+          + " framework.jar) in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and "
+          + " above"
+      ) {
+        manufacturer == MEIZU && sdkInt in 21..22
+      }
+    }
+  },
+
+  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.app.admin.DevicePolicyManager\$SettingsObserver", "this$0",
+        description =
+        "DevicePolicyManager keeps a reference to the context it has been created with"
+          + " instead of extracting the application context. In this Motorola build,"
+          + " DevicePolicyManager has an inner SettingsObserver class that is a content"
+          + " observer, which is held into memory by a binder transport object."
+      ) {
+        manufacturer == MOTOROLA && sdkInt in 19..22
+      }
+    }
+  },
+
+  EXTENDED_STATUS_BAR_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.app.ExtendedStatusBarManager", "mContext",
+        description =
+        """
+            ExtendedStatusBarManager has a mContext field which references a decor context which
+            references a destroyed activity.
+          """.trimIndent()
+      ) {
+        manufacturer == SHARP && sdkInt >= 30
+      }
+    }
+  },
+
+  OEM_SCENE_CALL_BLOCKER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+        "com.oneplus.util.OemSceneCallBlocker", "sContext",
+        description =
+        """
+            OemSceneCallBlocker has a sContext static field which holds on to an activity instance.
+          """.trimIndent()
+      ) {
+        manufacturer == ONE_PLUS && sdkInt == 28
+      }
+    }
+  },
+
+  PERF_MONITOR_LAST_CALLBACK {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+        "android.os.PerfMonitor", "mLastCallback",
+        description =
+        """
+            PerfMonitor has a mLastCallback static field which holds on to View.PerformClick.
+          """.trimIndent()
+      ) {
+        manufacturer == ONE_PLUS && sdkInt == 30
+      }
+    }
+  },
+
+  RAZER_TEXT_KEY_LISTENER__MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+        "android.text.method.TextKeyListener", "mContext",
+        description =
+        """
+            In AOSP, TextKeyListener instances are held in a TextKeyListener.sInstances static
+            array. The Razer implementation added a mContext field, creating activity leaks.
+          """.trimIndent()
+      ) {
+        manufacturer == RAZER && sdkInt == 28
+      }
+    }
+  },
+
+  XIAMI__RESOURCES_IMPL {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += staticFieldLeak(
+        "android.content.res.ResourcesImpl", "mAppContext",
+        description = """
+          A fork of Android added a static mAppContext field to the ResourcesImpl class
+          and that field ends up referencing lower contexts (e.g. service). Several Android
+          manufacturers seem to be using the same broken Android fork sources.
+        """.trimIndent()
+      ) {
+        listOf(
+          HMD_GLOBAL,
+          INFINIX,
+          LENOVO,
+          XIAOMI,
+          TES,
+          REALME
+        ).contains(manufacturer) &&
+          sdkInt >= 30
+      }
+    }
+  },
+
+  // ######## Ignored references (not leaks) ########
+
+  REFERENCES {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += ignoredInstanceField(WeakReference::class.java.name, "referent")
+      references += ignoredInstanceField("leakcanary.KeyedWeakReference", "referent")
+      references += ignoredInstanceField(SoftReference::class.java.name, "referent")
+      references += ignoredInstanceField(PhantomReference::class.java.name, "referent")
+      references += ignoredInstanceField("java.lang.ref.Finalizer", "prev")
+      references += ignoredInstanceField("java.lang.ref.Finalizer", "element")
+      references += ignoredInstanceField("java.lang.ref.Finalizer", "next")
+      references += ignoredInstanceField("java.lang.ref.FinalizerReference", "prev")
+      references += ignoredInstanceField("java.lang.ref.FinalizerReference", "element")
+      references += ignoredInstanceField("java.lang.ref.FinalizerReference", "next")
+      references += ignoredInstanceField("sun.misc.Cleaner", "prev")
+      references += ignoredInstanceField("sun.misc.Cleaner", "next")
+    }
+  },
+
+  FINALIZER_WATCHDOG_DAEMON {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
+      // reference to the object and it was about to be GCed.
+      references += ignoredJavaLocal("FinalizerWatchdogDaemon")
+    }
+  },
+
+  MAIN {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      // The main thread stack is ever changing so local variables aren't likely to hold references
+      // for long. If this is on the shortest path, it's probably that there's a longer path with
+      // a real leak.
+      references += ignoredJavaLocal("main")
+    }
+  },
+
+  LEAK_CANARY_THREAD {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += ignoredJavaLocal(LEAK_CANARY_THREAD_NAME)
+    }
+  },
+
+  LEAK_CANARY_HEAP_DUMPER {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      // Holds on to the resumed activity (which is never destroyed), so this will not cause leaks
+      // but may surface on the path when a resumed activity holds on to destroyed objects.
+      // Would have a path that doesn't include LeakCanary instead.
+      references += ignoredInstanceField(
+        "leakcanary.internal.InternalLeakCanary", "resumedActivity"
+      )
+    }
+  },
+
+  LEAK_CANARY_INTERNAL {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += ignoredInstanceField("leakcanary.internal.InternalLeakCanary", "application")
+    }
+  },
+
+  EVENT_RECEIVER__MMESSAGE_QUEUE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
+      // the native peer of the receiver is using them.
+      // The main thread message queue is held on by the main Looper, but that might be a longer
+      // path. Let's not confuse people with a shorter path that is less meaningful.
+      references += ignoredInstanceField(
+        "android.view.Choreographer\$FrameDisplayEventReceiver", "mMessageQueue"
+      )
+    }
+  },
+
+  ;
+
+  internal abstract fun add(references: MutableList<ReferenceMatcher>)
+
+  companion object {
+    private const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
+    const val SAMSUNG = "samsung"
+    const val MOTOROLA = "motorola"
+    const val LENOVO = "LENOVO"
+    const val LG = "LGE"
+    const val NVIDIA = "NVIDIA"
+    const val MEIZU = "Meizu"
+    const val ONE_PLUS = "OnePlus"
+    const val HUAWEI = "HUAWEI"
+    const val VIVO = "vivo"
+    const val RAZER = "Razer"
+    const val SHARP = "SHARP"
+    const val XIAOMI = "Xiaomi"
+    const val HMD_GLOBAL = "HMD Global"
+    const val INFINIX = "INFINIX"
+    const val TES = "TES"
+    const val REALME = "realme"
+
+    /**
+     * Returns a list of [ReferenceMatcher] that only contains [IgnoredReferenceMatcher] and no
+     * [LibraryLeakReferenceMatcher].
+     */
+    @JvmStatic
+    val ignoredReferencesOnly: List<ReferenceMatcher>
+      get() = buildKnownReferences(
+        EnumSet.of(
+          REFERENCES,
+          FINALIZER_WATCHDOG_DAEMON,
+          MAIN,
+          LEAK_CANARY_THREAD,
+          EVENT_RECEIVER__MMESSAGE_QUEUE
+        )
+      )
+
+    /**
+     * @see [AndroidReferenceMatchers]
+     */
+    @JvmStatic
+    val appDefaults: List<ReferenceMatcher>
+      get() = buildKnownReferences(EnumSet.allOf(AndroidReferenceMatchers::class.java))
+
+    /**
+     * Builds a list of [ReferenceMatcher] from the [referenceMatchers] set of
+     * [AndroidReferenceMatchers].
+     */
+    @JvmStatic
+    fun buildKnownReferences(referenceMatchers: Set<AndroidReferenceMatchers>): List<ReferenceMatcher> {
+      val resultSet = mutableListOf<ReferenceMatcher>()
+      referenceMatchers.forEach {
+        it.add(resultSet)
+      }
+      return resultSet
+    }
+
+    private val ALWAYS: AndroidBuildMirror.() -> Boolean = {
+      true
+    }
+
+    /**
+     * Creates a [LibraryLeakReferenceMatcher] that matches a [StaticFieldPattern].
+     * [description] should convey what we know about this library leak.
+     */
+    @JvmStatic
+    fun staticFieldLeak(
+      className: String,
+      fieldName: String,
+      description: String = "",
+      patternApplies: AndroidBuildMirror.() -> Boolean = ALWAYS
+    ): LibraryLeakReferenceMatcher {
+      return libraryLeak(StaticFieldPattern(className, fieldName), description, patternApplies)
+    }
+
+    /**
+     * Creates a [LibraryLeakReferenceMatcher] that matches a [InstanceFieldPattern].
+     * [description] should convey what we know about this library leak.
+     */
+    @JvmStatic
+    fun instanceFieldLeak(
+      className: String,
+      fieldName: String,
+      description: String = "",
+      patternApplies: AndroidBuildMirror.() -> Boolean = ALWAYS
+    ): LibraryLeakReferenceMatcher {
+      return libraryLeak(InstanceFieldPattern(className, fieldName), description, patternApplies)
+    }
+
+    @JvmStatic
+    fun nativeGlobalVariableLeak(
+      className: String,
+      description: String = "",
+      patternApplies: AndroidBuildMirror.() -> Boolean = ALWAYS
+    ): LibraryLeakReferenceMatcher {
+      return libraryLeak(NativeGlobalVariablePattern(className), description, patternApplies)
+    }
+
+    private fun libraryLeak(
+      referencePattern: ReferencePattern,
+      description: String,
+      patternApplies: AndroidBuildMirror.() -> Boolean
+    ): LibraryLeakReferenceMatcher {
+      return LibraryLeakReferenceMatcher(
+        pattern = referencePattern,
+        description = description,
+        patternApplies = { graph ->
+          AndroidBuildMirror.fromHeapGraph(graph)
+            .patternApplies()
+        }
+      )
+    }
+
+    /**
+     * Creates a [IgnoredReferenceMatcher] that matches a [InstanceFieldPattern].
+     */
+    @JvmStatic
+    fun ignoredInstanceField(
+      className: String,
+      fieldName: String
+    ): IgnoredReferenceMatcher {
+      return IgnoredReferenceMatcher(pattern = InstanceFieldPattern(className, fieldName))
+    }
+
+    /**
+     * Creates a [IgnoredReferenceMatcher] that matches a [JavaLocalPattern].
+     */
+    @JvmStatic
+    fun ignoredJavaLocal(
+      threadName: String
+    ): IgnoredReferenceMatcher {
+      return IgnoredReferenceMatcher(pattern = JavaLocalPattern(threadName))
+    }
+  }
+}
+
diff --git a/shark-android/src/main/java/shark/AndroidResourceIdNames.kt b/shark-android/src/main/java/shark/AndroidResourceIdNames.kt
new file mode 100644
index 00000000..58774993
--- /dev/null
+++ b/shark-android/src/main/java/shark/AndroidResourceIdNames.kt
@@ -0,0 +1,100 @@
+package shark
+
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+
+class AndroidResourceIdNames private constructor(
+  private val resourceIds: IntArray,
+  private val names: Array<String>
+) {
+
+  operator fun get(id: Int): String? {
+    val indexOfId = resourceIds.binarySearch(id)
+    return if (indexOfId >= 0) {
+      names[indexOfId]
+    } else {
+      null
+    }
+  }
+
+  companion object {
+
+    internal const val FIRST_APP_RESOURCE_ID = 0x7F010000
+    internal const val RESOURCE_ID_TYPE_ITERATOR = 0x00010000
+
+    @Volatile
+    @JvmStatic
+    private var holderField: AndroidResourceIdNames? = null
+
+    /**
+     * @param getResourceTypeName a function that delegates to Android
+     * Resources.getResourceTypeName but returns null when the name isn't found instead of
+     * throwing an exception.
+     *
+     * @param getResourceEntryName a function that delegates to Android
+     * Resources.getResourceEntryName but returns null when the name isn't found instead of
+     * throwing an exception.
+     */
+    @Synchronized fun saveToMemory(
+      getResourceTypeName: (Int) -> String?,
+      getResourceEntryName: (Int) -> String?
+    ) {
+      if (holderField != null) {
+        return
+      }
+
+      // This is based on https://jebware.com/blog/?p=600 which itself is based on
+      // https://stackoverflow.com/a/6646113/703646
+
+      val idToNamePairs = mutableListOf<Pair<Int, String>>()
+      findIdTypeResourceIdStart(getResourceTypeName)?.let { idTypeResourceIdStart ->
+        var resourceId = idTypeResourceIdStart
+        while (true) {
+          val entry = getResourceEntryName(resourceId) ?: break
+          idToNamePairs += resourceId to entry
+          resourceId++
+        }
+      }
+      val resourceIds = idToNamePairs.map { it.first }
+        .toIntArray()
+      val names = idToNamePairs.map { it.second }
+        .toTypedArray()
+      holderField = AndroidResourceIdNames(resourceIds, names)
+    }
+
+    private fun findIdTypeResourceIdStart(getResourceTypeName: (Int) -> String?): Int? {
+      var resourceTypeId = FIRST_APP_RESOURCE_ID
+      while (true) {
+        when (getResourceTypeName(resourceTypeId)) {
+          null -> return null
+          "id" -> return resourceTypeId
+          else -> resourceTypeId += RESOURCE_ID_TYPE_ITERATOR
+        }
+      }
+    }
+
+    fun readFromHeap(graph: HeapGraph): AndroidResourceIdNames? {
+      return graph.context.getOrPut(AndroidResourceIdNames::class.java.name) {
+        val className = AndroidResourceIdNames::class.java.name
+        val holderClass = graph.findClassByName(className)
+        holderClass?.let {
+          val holderField = holderClass["holderField"]!!
+          holderField.valueAsInstance?.let { instance ->
+            val resourceIdsField = instance[className, "resourceIds"]!!
+            val resourceIdsArray = resourceIdsField.valueAsPrimitiveArray!!
+            val resourceIds =
+              (resourceIdsArray.readRecord() as IntArrayDump).array
+            val names = instance[className, "names"]!!.valueAsObjectArray!!.readElements()
+              .map { it.readAsJavaString()!! }
+              .toList()
+              .toTypedArray()
+            AndroidResourceIdNames(resourceIds, names)
+          }
+        }
+      }
+    }
+
+    internal fun resetForTests() {
+      holderField = null
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark-android/src/main/java/shark/AndroidServices.kt b/shark-android/src/main/java/shark/AndroidServices.kt
new file mode 100644
index 00000000..eb9f667a
--- /dev/null
+++ b/shark-android/src/main/java/shark/AndroidServices.kt
@@ -0,0 +1,28 @@
+package shark
+
+object AndroidServices {
+  val HeapGraph.aliveAndroidServiceObjectIds: List<Long>
+    get() {
+      return context.getOrPut(AndroidServices::class.java.name) {
+        val activityThreadClass = findClassByName("android.app.ActivityThread")!!
+        val currentActivityThread = activityThreadClass
+          .readStaticField("sCurrentActivityThread")!!
+          .valueAsInstance!!
+
+        val mServices = currentActivityThread["android.app.ActivityThread", "mServices"]!!
+          .valueAsInstance!!
+
+        val servicesArray = mServices["android.util.ArrayMap", "mArray"]!!.valueAsObjectArray!!
+
+        servicesArray.readElements()
+          .filterIndexed { index, heapValue ->
+            // ArrayMap<IBinder, Service>
+            // even: key, odd: value
+            index % 2 == 1
+              && heapValue.isNonNullReference
+          }
+          .map { it.asNonNullObjectId!! }
+          .toList()
+      }
+    }
+}
\ No newline at end of file
diff --git a/shark-android/src/main/java/shark/internal/friendly/Friendly.kt b/shark-android/src/main/java/shark/internal/friendly/Friendly.kt
new file mode 100644
index 00000000..09f1fcdb
--- /dev/null
+++ b/shark-android/src/main/java/shark/internal/friendly/Friendly.kt
@@ -0,0 +1,9 @@
+@file:Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER")
+@file:JvmName("shark-android_Friendly")
+
+package shark.internal.friendly
+
+import shark.HeapGraph
+
+internal inline fun HeapGraph.mapNativeSizes() =
+  shark.internal.AndroidNativeSizeMapper.mapNativeSizes(this)
diff --git a/shark-android/src/main/resources/META-INF/proguard/shark.pro b/shark-android/src/main/resources/META-INF/proguard/shark.pro
new file mode 100644
index 00000000..c66a7af4
--- /dev/null
+++ b/shark-android/src/main/resources/META-INF/proguard/shark.pro
@@ -0,0 +1,2 @@
+# Used during heap analysis to find resource id names
+-keep class shark.AndroidResourceIdNames { *; }
diff --git a/shark-android/src/test/java/shark/AndroidObjectInspectorsTest.kt b/shark-android/src/test/java/shark/AndroidObjectInspectorsTest.kt
new file mode 100644
index 00000000..83908be9
--- /dev/null
+++ b/shark-android/src/test/java/shark/AndroidObjectInspectorsTest.kt
@@ -0,0 +1,67 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.LeakTraceObject.LeakingStatus.LEAKING
+import shark.LeakTraceObject.LeakingStatus.NOT_LEAKING
+import shark.LeakTraceObject.ObjectType.INSTANCE
+
+class AndroidObjectInspectorsTest {
+
+  @Test fun `RECOMPOSER leaking status relies on state`() {
+    val hprofFile = "compose_leak.hprof".classpathFile()
+    val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+    val analysis = heapAnalyzer.analyze(
+      heapDumpFile = hprofFile,
+      leakingObjectFinder = { graph ->
+        val composeViewClass =
+          graph.findClassByName("androidx.compose.ui.platform.AndroidComposeView")
+        composeViewClass!!.instances.filter { instance ->
+          val filter = AndroidObjectInspectors.VIEW.leakingObjectFilter!!
+          filter.invoke(instance)
+          true
+        }.map { it.objectId }.toSet()
+      },
+      referenceMatchers = AndroidReferenceMatchers.appDefaults,
+      objectInspectors = AndroidObjectInspectors.appDefaults
+    )
+    println(analysis)
+    analysis as HeapAnalysisSuccess
+    val recomposerNode = analysis.applicationLeaks.single()
+      .leakTraces.single()
+      .referencePath.single {
+        it.originObject.type == INSTANCE
+          && it.owningClassSimpleName == "Recomposer"
+      }
+    assertThat(recomposerNode.originObject.leakingStatus == NOT_LEAKING)
+    assertThat(recomposerNode.originObject.leakingStatusReason == "Recomposer is in state PendingWork")
+  }
+
+  @Test fun `COMPOSITION_IMPL leaking status relies on disposal`() {
+    val hprofFile = "compose_leak.hprof".classpathFile()
+    val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+    val analysis = heapAnalyzer.analyze(
+      heapDumpFile = hprofFile,
+      leakingObjectFinder = { graph ->
+        val composeViewClass =
+          graph.findClassByName("androidx.compose.ui.platform.AndroidComposeView")
+        composeViewClass!!.instances.filter { instance ->
+          val filter = AndroidObjectInspectors.VIEW.leakingObjectFilter!!
+          filter.invoke(instance)
+          true
+        }.map { it.objectId }.toSet()
+      },
+      referenceMatchers = AndroidReferenceMatchers.appDefaults,
+      objectInspectors = AndroidObjectInspectors.appDefaults
+    )
+    println(analysis)
+    analysis as HeapAnalysisSuccess
+    val recomposerNode = analysis.applicationLeaks.single()
+      .leakTraces.single()
+      .referencePath.single {
+        it.owningClassSimpleName == "CompositionImpl"
+      }
+    assertThat(recomposerNode.originObject.leakingStatus == LEAKING)
+    assertThat(recomposerNode.originObject.leakingStatusReason == "Composition disposed")
+  }
+}
diff --git a/shark-android/src/test/java/shark/AndroidReferenceMatcher_XIAMI__RESOURCES_IMPL_Test.kt b/shark-android/src/test/java/shark/AndroidReferenceMatcher_XIAMI__RESOURCES_IMPL_Test.kt
new file mode 100644
index 00000000..d3ed22f0
--- /dev/null
+++ b/shark-android/src/test/java/shark/AndroidReferenceMatcher_XIAMI__RESOURCES_IMPL_Test.kt
@@ -0,0 +1,157 @@
+package shark
+
+import java.io.File
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+import shark.AndroidReferenceMatcher_XIAMI__RESOURCES_IMPL_Test.Companion.expectedKnownClassLeakingContext
+import shark.AndroidReferenceMatcher_XIAMI__RESOURCES_IMPL_Test.Companion.expectedKnownReferenceName
+import shark.AndroidReferenceMatchers.Companion.HMD_GLOBAL
+import shark.AndroidReferenceMatchers.Companion.INFINIX
+import shark.AndroidReferenceMatchers.Companion.LENOVO
+import shark.AndroidReferenceMatchers.Companion.NVIDIA
+import shark.AndroidReferenceMatchers.Companion.XIAOMI
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.ReferencePattern.StaticFieldPattern
+import shark.ValueHolder.IntHolder
+
+/**
+ * Tests for [AndroidReferenceMatchers.XIAMI__RESOURCES_IMPL] known leaks, to ensure we
+ * don't report the ones we know about as application leaks, and do report the ones we don't.
+ */
+@RunWith(Parameterized::class)
+class AndroidReferenceMatcher_XIAMI__RESOURCES_IMPL_Test(
+  private val manufacturer: String,
+  private val sdkInt: Int,
+  private val verifyResults: HeapAnalysisSuccess.() -> Unit
+) {
+
+  companion object {
+
+    /**
+     * It's known that some device manufacturers on SDK 30 and above leak
+     * a statically held [android.content.Context] from a class [android.content.res.ResourcesImpl]
+     * in a variable named [mContext].
+     */
+    const val expectedKnownClassLeakingContext = "android.content.res.ResourcesImpl"
+    const val expectedKnownReferenceName = "mAppContext"
+
+    @JvmStatic
+    @Parameterized.Parameters
+    fun data() = listOf(
+      // HMD_GLOBAL is in the list of known offenders, but we want to validate that
+      // below SDK 30 unknown, above SDK 30 known
+      arrayOf(HMD_GLOBAL, 29, HeapAnalysisSuccess::expectApplicationLeak),
+      arrayOf(HMD_GLOBAL, 30, HeapAnalysisSuccess::expectKnownLibraryLeak),
+      arrayOf(HMD_GLOBAL, 31, HeapAnalysisSuccess::expectKnownLibraryLeak),
+
+      // NVIDIA is not in the list of known manufacturers,
+      // so validate a leak is reported even if we're above SDK 30
+      arrayOf(NVIDIA, 30, HeapAnalysisSuccess::expectApplicationLeak),
+
+      // Ensure that each known offender is reported as known and not an application leak
+      arrayOf(XIAOMI, 30, HeapAnalysisSuccess::expectKnownLibraryLeak),
+      arrayOf(LENOVO, 30, HeapAnalysisSuccess::expectKnownLibraryLeak),
+      arrayOf(INFINIX, 30, HeapAnalysisSuccess::expectKnownLibraryLeak),
+      arrayOf(HMD_GLOBAL, 30, HeapAnalysisSuccess::expectKnownLibraryLeak),
+    )
+  }
+
+  /**
+   * Sets up the known leak for some manufacturers in a fake, in-memory heap dump.
+   * Then analyzes for leaks with [AndroidReferenceMatchers.XIAMI__RESOURCES_IMPL] added.
+   * The HeapAnalysis is returned for assertions against it.
+   */
+  @Test fun givenLeakingContextFor() {
+    val hprofBytes = dumpToBytes {
+      clazz(
+        "android.os.Build",
+        staticFields = listOf("MANUFACTURER" to string(manufacturer), "ID" to string("someId"))
+      )
+      clazz(
+        "android.os.Build\$VERSION",
+        staticFields = listOf("SDK_INT" to IntHolder(sdkInt))
+      )
+      val leaking = instance(clazz("android.content.Context"))
+      keyedWeakReference(leaking)
+      clazz(
+        expectedKnownClassLeakingContext,
+        staticFields = listOf(expectedKnownReferenceName to leaking)
+      )
+    }
+
+    val matchers = mutableListOf<ReferenceMatcher>()
+    AndroidReferenceMatchers.XIAMI__RESOURCES_IMPL.add(matchers)
+    val analysis =
+      hprofBytes.checkForLeaks<HeapAnalysisSuccess>(referenceMatchers = matchers)
+
+    analysis.verifyResults()
+  }
+}
+
+fun <T : HeapAnalysis> ByteArray.checkForLeaks(
+  referenceMatchers: List<ReferenceMatcher>
+): T {
+  val basp = ByteArraySourceProvider(this)
+  val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+  val result = basp.openHeapGraph(proguardMapping = null).use { graph ->
+    heapAnalyzer.analyze(
+      heapDumpFile = File("ignored"),
+      graph = graph,
+      leakingObjectFinder = FilteringLeakingObjectFinder(
+        ObjectInspectors.jdkLeakingObjectFilters
+      ),
+      referenceMatchers = referenceMatchers,
+      computeRetainedHeapSize = false,
+      objectInspectors = listOf(ObjectInspectors.KEYED_WEAK_REFERENCE),
+      metadataExtractor = MetadataExtractor.NO_OP,
+    )
+  }
+  if (result is HeapAnalysisFailure) {
+    println(result)
+  }
+  @Suppress("UNCHECKED_CAST")
+  return result as T
+}
+
+/**
+ * Validate that there are no known library leaks, and instead the application leak we expect.
+ */
+private fun HeapAnalysisSuccess.expectApplicationLeak() {
+  // Expect that we don't know about this leak
+  assertThat(libraryLeaks).isEmpty()
+
+  // And hence it shows up as an application leak.
+  assertThat(applicationLeaks)
+    .describedAs(applicationLeaks.toString()).hasSize(1)
+
+  val (actualLeakedClassName, actualLeakedRefName) =
+    applicationLeaks.first()
+      .leakTraces.first()
+      .referencePath.first().let {
+        it.owningClassName to it.referenceName
+      }
+
+  assertThat(actualLeakedClassName).isEqualTo(expectedKnownClassLeakingContext)
+  assertThat(actualLeakedRefName).isEqualTo(expectedKnownReferenceName)
+}
+
+/**
+ * Validate that this is a known library leak, that we do not report it as an application leak.
+ */
+private fun HeapAnalysisSuccess.expectKnownLibraryLeak() {
+  // Expect no application leaks found
+  assertThat(applicationLeaks)
+    .describedAs(applicationLeaks.toString()).isEmpty()
+
+  // Expect we see a known library leak instead matching the leak pattern we expect.
+  assertThat(libraryLeaks).hasSize(1)
+  val (actualKnownClassName, actualKnownPattern) =
+    (libraryLeaks.first().pattern as StaticFieldPattern).let {
+      it.className to it.fieldName
+    }
+
+  assertThat(actualKnownClassName).isEqualTo(expectedKnownClassLeakingContext)
+  assertThat(actualKnownPattern).isEqualTo(expectedKnownReferenceName)
+}
diff --git a/shark-android/src/test/java/shark/AndroidResourceIdNamesTest.kt b/shark-android/src/test/java/shark/AndroidResourceIdNamesTest.kt
new file mode 100644
index 00000000..60f9962a
--- /dev/null
+++ b/shark-android/src/test/java/shark/AndroidResourceIdNamesTest.kt
@@ -0,0 +1,146 @@
+package shark
+
+import com.nhaarman.mockitokotlin2.any
+import com.nhaarman.mockitokotlin2.mock
+import com.nhaarman.mockitokotlin2.verify
+import com.nhaarman.mockitokotlin2.whenever
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.AndroidResourceIdNames.Companion.FIRST_APP_RESOURCE_ID
+import shark.AndroidResourceIdNames.Companion.RESOURCE_ID_TYPE_ITERATOR
+import java.io.File
+
+class AndroidResourceIdNamesTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+
+  @Before fun setUp() {
+    AndroidResourceIdNames.resetForTests()
+  }
+
+  @After fun tearDown() {
+    AndroidResourceIdNames.resetForTests()
+  }
+
+  @Test fun `saveToMemory call is cached`() {
+    val getResourceTypeName: (Int) -> String? = mock()
+
+    for (i in 0..2) {
+      AndroidResourceIdNames.saveToMemory(
+        getResourceTypeName = getResourceTypeName,
+        getResourceEntryName = { null }
+      )
+    }
+
+    verify(getResourceTypeName).invoke(any())
+  }
+
+  @Test fun `AndroidResourceIdNames available in heap dump when saveToMemory is called`() {
+    AndroidResourceIdNames.saveToMemory(
+      getResourceTypeName = { null }, getResourceEntryName = { null })
+
+    dumpAndReadHeap { resIdNames ->
+      assertThat(resIdNames).isNotNull
+    }
+  }
+
+  @Test fun `AndroidResourceIdNames not available in heap dump when saveToMemory is not called`() {
+    dumpAndReadHeap { resIdNames ->
+      assertThat(resIdNames).isNull()
+    }
+  }
+
+  @Test fun `saveToMemory stores and retrieves resource id`() {
+    val firstIdResourceId = FIRST_APP_RESOURCE_ID
+
+    val getResourceTypeName =
+      createGetResourceTypeName(mapOf(firstIdResourceId to "id"))
+
+    val getResourceEntryName =
+      createGetResourceEntryName(mapOf(FIRST_APP_RESOURCE_ID to "view_container"))
+
+    AndroidResourceIdNames.saveToMemory(getResourceTypeName, getResourceEntryName)
+
+    dumpAndReadHeap { resIdNames ->
+      assertThat(resIdNames!![firstIdResourceId]).isEqualTo("view_container")
+    }
+  }
+
+  @Test fun `id type starts after layout`() {
+    val layoutResourceId = FIRST_APP_RESOURCE_ID
+    val firstIdResourceId = layoutResourceId + RESOURCE_ID_TYPE_ITERATOR
+
+    val getResourceTypeName =
+      createGetResourceTypeName(
+        mapOf(
+          layoutResourceId to "layout",
+          firstIdResourceId to "id"
+        )
+      )
+    val getResourceEntryName =
+      createGetResourceEntryName(mapOf(firstIdResourceId to "view_container"))
+
+    AndroidResourceIdNames.saveToMemory(getResourceTypeName, getResourceEntryName)
+
+    dumpAndReadHeap { resIdNames ->
+      assertThat(resIdNames!![firstIdResourceId]).isEqualTo("view_container")
+    }
+  }
+
+  @Test fun `two consecutive id resource ids`() {
+    val firstIdResourceId = FIRST_APP_RESOURCE_ID
+    val secondIdResourceId = FIRST_APP_RESOURCE_ID + 1
+
+    val getResourceTypeName =
+      createGetResourceTypeName(
+        mapOf(
+          firstIdResourceId to "id"
+        )
+      )
+    val getResourceEntryName = createGetResourceEntryName(
+      mapOf(
+        firstIdResourceId to "view_container",
+        secondIdResourceId to "menu_button"
+      )
+    )
+
+    AndroidResourceIdNames.saveToMemory(getResourceTypeName, getResourceEntryName)
+
+    dumpAndReadHeap { resIdNames ->
+      assertThat(resIdNames!![secondIdResourceId]).isEqualTo("menu_button")
+    }
+  }
+
+  private fun createGetResourceEntryName(resourceIdMap: Map<Int, String>): (Int) -> String? {
+    val getResourceEntryName: (Int) -> String? = mock()
+    resourceIdMap.forEach { (resourceId, resourceName) ->
+      whenever(getResourceEntryName.invoke(resourceId)).thenReturn(resourceName)
+    }
+    return getResourceEntryName
+  }
+
+  private fun createGetResourceTypeName(resourceIdMap: Map<Int, String>): (Int) -> String? {
+    val getResourceTypeName: (Int) -> String? = mock()
+    resourceIdMap.forEach { (resourceId, resourceName) ->
+      whenever(getResourceTypeName.invoke(resourceId)).thenReturn(resourceName)
+    }
+    return getResourceTypeName
+  }
+
+  fun dumpAndReadHeap(block: (AndroidResourceIdNames?) -> Unit) {
+    val hprofFolder = testFolder.newFolder()
+    val hprofFile = File(hprofFolder, "heapdump.hprof")
+    JvmTestHeapDumper.dumpHeap(hprofFile.absolutePath)
+    Hprof.open(hprofFile)
+      .use { hprof ->
+        val graph = HprofHeapGraph.indexHprof(hprof)
+        val idNames = AndroidResourceIdNames.readFromHeap(graph)
+        block(idNames)
+      }
+  }
+}
\ No newline at end of file
diff --git a/shark-android/src/test/java/shark/HprofIOPerfTest.kt b/shark-android/src/test/java/shark/HprofIOPerfTest.kt
new file mode 100644
index 00000000..30a299a5
--- /dev/null
+++ b/shark-android/src/test/java/shark/HprofIOPerfTest.kt
@@ -0,0 +1,286 @@
+package shark
+
+import java.io.File
+import kotlin.math.floor
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import org.nield.kotlinstatistics.median
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.PrimitiveType.INT
+
+/**
+ * IO reads is the largest factor on Shark's performance so this helps prevents
+ * regressions.
+ */
+class HprofIOPerfTest {
+
+  @Test fun `HeapObjectArray#readByteSize() does not read`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+    val arrayId = hprofFile.openHeapGraph().use { graph ->
+      graph.objectArrays.maxBy { it.readRecord().elementIds.size * graph.identifierByteSize }!!.objectId
+    }
+
+    val source = MetricsDualSourceProvider(hprofFile)
+
+    val bytesRead = source.openHeapGraph().use { graph ->
+      val bytesReadMetrics = source.sourcesMetrics.last().apply { clear() }
+      graph.findObjectById(arrayId).asObjectArray!!.byteSize
+      bytesReadMetrics.sum()
+    }
+
+    assertThat(bytesRead).isEqualTo(0)
+  }
+
+  @Test fun `HeapObjectArray#byteSize correctly reads size of array`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+    hprofFile.openHeapGraph().use { graph ->
+      graph.objectArrays.forEach { array ->
+        assertThat(array.byteSize).isEqualTo(
+          array.readRecord().elementIds.size * graph.identifierByteSize
+        )
+      }
+    }
+  }
+
+  @Test fun `HeapPrimitiveArray#byteSize does not read`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+    val arrayId = hprofFile.openHeapGraph().use { graph ->
+      graph.primitiveArrays.maxBy { it.readRecord().size * it.primitiveType.byteSize }!!.objectId
+    }
+
+    val source = MetricsDualSourceProvider(hprofFile)
+
+    val bytesRead = source.openHeapGraph().use { graph ->
+      val bytesReadMetrics = source.sourcesMetrics.last().apply { clear() }
+      graph.findObjectById(arrayId).asPrimitiveArray!!.byteSize
+      bytesReadMetrics.sum()
+    }
+
+    assertThat(bytesRead).isEqualTo(0)
+  }
+
+  @Test fun `HeapPrimitiveArray#readByteSize() correctly reads size of array`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+    hprofFile.openHeapGraph().use { graph ->
+      graph.primitiveArrays.forEach { array ->
+        assertThat(array.byteSize).isEqualTo(
+          array.readRecord().size * array.primitiveType.byteSize
+        )
+      }
+    }
+  }
+
+  @Test fun `HeapInstance#byteSize reads 0 bytes`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+
+    val source = MetricsDualSourceProvider(hprofFile)
+
+    val bytesRead = source.openHeapGraph().use { graph ->
+      val bytesReadMetrics = source.sourcesMetrics.last().apply { clear() }
+      graph.instances.first().byteSize
+      bytesReadMetrics.sum()
+    }
+
+    assertThat(bytesRead).isEqualTo(0)
+  }
+
+  @Test fun `consecutive call to HeapObject#readRecord() reads 0 bytes`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+
+    val source = MetricsDualSourceProvider(hprofFile)
+
+    val bytesRead = source.openHeapGraph().use { graph ->
+      graph.objects.first().readRecord()
+      val bytesReadMetrics = source.sourcesMetrics.last().apply { clear() }
+      graph.objects.first().readRecord()
+      bytesReadMetrics.sum()
+    }
+
+    assertThat(bytesRead).isEqualTo(0)
+  }
+
+  @Test fun `HeapObject#readRecord() reads 0 bytes when reading from LRU`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+
+    val source = MetricsDualSourceProvider(hprofFile)
+
+    val bytesRead = source.openHeapGraph().use { graph ->
+      graph.objects.take(HPROF_HEAP_GRAPH_LRU_OBJECT_CACHE_SIZE).forEach { it.readRecord() }
+      val bytesReadMetrics = source.sourcesMetrics.last().apply { clear() }
+      graph.objects.take(HPROF_HEAP_GRAPH_LRU_OBJECT_CACHE_SIZE).forEach { it.readRecord() }
+      bytesReadMetrics.sum()
+    }
+
+    assertThat(bytesRead).isEqualTo(0)
+  }
+
+  @Test fun `HeapObject#readRecord() reads bytes when reading evicted object`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+
+    val source = MetricsDualSourceProvider(hprofFile)
+
+    val bytesRead = source.openHeapGraph().use { graph ->
+      graph.objects.take(HPROF_HEAP_GRAPH_LRU_OBJECT_CACHE_SIZE + 1).forEach { it.readRecord() }
+      val bytesReadMetrics = source.sourcesMetrics.last().apply { clear() }
+      graph.objects.first().readRecord()
+      bytesReadMetrics.sum()
+    }
+
+    assertThat(bytesRead).isGreaterThan(0)
+  }
+
+  @Test fun `analyze() creates 4 separate sources`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+
+    val metrics = trackAnalyzeIoReadMetrics(hprofFile)
+
+    // 4 phases: Read headers, fast scan, indexing, then random access for analysis.
+    assertThat(metrics).hasSize(4)
+  }
+
+  @Test fun `header parsing requires only one segment`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+
+    val metrics = trackAnalyzeIoReadMetrics(hprofFile)
+
+    val headerParsingReads = metrics[0]
+    assertThat(headerParsingReads).isEqualTo(listOf(OKIO_SEGMENT_SIZE))
+  }
+
+  @Test fun `fast scan pre indexing is a full file scan`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+
+    val metrics = trackAnalyzeIoReadMetrics(hprofFile)
+
+    val fastScanReads = metrics[1]
+    val expectedReads = fullScanExpectedReads(hprofFile.length())
+    assertThat(fastScanReads).hasSameSizeAs(expectedReads).isEqualTo(expectedReads)
+  }
+
+  @Test fun `indexing is a full file scan`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+
+    val metrics = trackAnalyzeIoReadMetrics(hprofFile)
+
+    val indexingReads = metrics[2]
+    val expectedReads = fullScanExpectedReads(hprofFile.length())
+    assertThat(indexingReads).hasSameSizeAs(expectedReads).isEqualTo(expectedReads)
+  }
+
+  @Test fun `freeze leak_asynctask_o hprof random access metrics`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+
+    val metrics = trackAnalyzeRandomAccessMetrics(hprofFile)
+
+    assertThat(
+      listOf(
+        metrics.first.readsCount, metrics.first.medianBytesRead, metrics.first.totalBytesRead,
+        metrics.second.readsCount, metrics.second.medianBytesRead, metrics.second.totalBytesRead
+      )
+    )
+      .isEqualTo(
+        listOf(
+          25760, 40.0, 1309045, 25765, 40.0, 1309225
+        )
+      )
+  }
+
+  @Test fun `freeze leak_asynctask_m hprof random access metrics`() {
+    val hprofFile = "leak_asynctask_m.hprof".classpathFile()
+
+    val metrics = trackAnalyzeRandomAccessMetrics(hprofFile)
+
+    assertThat(
+      listOf(
+        metrics.first.readsCount, metrics.first.medianBytesRead, metrics.first.totalBytesRead,
+        metrics.second.readsCount, metrics.second.medianBytesRead, metrics.second.totalBytesRead
+      )
+    )
+      .isEqualTo(
+        listOf(
+          22493, 40.0, 2203818, 22498, 40.0, 2203998
+        )
+      )
+  }
+
+  @Test fun `freeze leak_asynctask_pre_m hprof random access metrics`() {
+    val hprofFile = "leak_asynctask_pre_m.hprof".classpathFile()
+
+    val metrics = trackAnalyzeRandomAccessMetrics(hprofFile)
+
+    assertThat(
+      listOf(
+        metrics.first.readsCount, metrics.first.medianBytesRead, metrics.first.totalBytesRead,
+        metrics.second.readsCount, metrics.second.medianBytesRead, metrics.second.totalBytesRead
+      )
+    )
+      .isEqualTo(
+        listOf(
+          16889, 32.0, 768692, 16891, 32.0, 768756
+        )
+      )
+  }
+
+  class Reads(reads: List<Int>) {
+    val readsCount = reads.size
+    val medianBytesRead = reads.median()
+    val totalBytesRead = reads.sum()
+  }
+
+  private fun trackAnalyzeRandomAccessMetrics(hprofFile: File): Pair<Reads, Reads> {
+    return trackAnalyzeIoReadMetrics(hprofFile).run {
+      Reads(this[3])
+    } to trackAnalyzeIoReadMetrics(
+      hprofFile,
+      computeRetainedHeapSize = true,
+      printResult = true
+    ).run {
+      Reads(this[3])
+    }
+  }
+
+  private fun trackAnalyzeIoReadMetrics(
+    hprofFile: File,
+    computeRetainedHeapSize: Boolean = false,
+    printResult: Boolean = false
+  ): List<List<Int>> {
+    val source = MetricsDualSourceProvider(hprofFile)
+    val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+    val analysis = source.openHeapGraph().use { graph ->
+      heapAnalyzer.analyze(
+        heapDumpFile = hprofFile,
+        graph = graph,
+        leakingObjectFinder = FilteringLeakingObjectFinder(
+          AndroidObjectInspectors.appLeakingObjectFilters
+        ),
+        referenceMatchers = AndroidReferenceMatchers.appDefaults,
+        computeRetainedHeapSize = computeRetainedHeapSize,
+        objectInspectors = AndroidObjectInspectors.appDefaults,
+        metadataExtractor = AndroidMetadataExtractor
+      )
+    }
+    check(analysis is HeapAnalysisSuccess) {
+      "Expected success not $analysis"
+    }
+    if (printResult) {
+      println(analysis)
+    }
+    return source.sourcesMetrics
+  }
+
+  private fun fullScanExpectedReads(fileLength: Long): List<Int> {
+    val fullReadsCount = floor(fileLength / OKIO_SEGMENT_SIZE.toDouble()).toInt()
+    val remainderBytes = (fileLength - (OKIO_SEGMENT_SIZE * fullReadsCount)).toInt()
+
+    val finalReads = if (remainderBytes > 0) listOf(remainderBytes, 0) else listOf(0)
+
+    return List(fullReadsCount) {
+      OKIO_SEGMENT_SIZE
+    } + finalReads
+  }
+
+  companion object {
+    private const val OKIO_SEGMENT_SIZE = 8192
+    private const val HPROF_HEAP_GRAPH_LRU_OBJECT_CACHE_SIZE = 3000
+  }
+}
diff --git a/shark-android/src/test/java/shark/HprofRetainedHeapPerfTest.kt b/shark-android/src/test/java/shark/HprofRetainedHeapPerfTest.kt
new file mode 100644
index 00000000..8dd73b4a
--- /dev/null
+++ b/shark-android/src/test/java/shark/HprofRetainedHeapPerfTest.kt
@@ -0,0 +1,269 @@
+package shark
+
+import java.io.File
+import java.util.EnumSet
+import java.util.concurrent.CountDownLatch
+import java.util.concurrent.TimeUnit.SECONDS
+import kotlin.concurrent.thread
+import kotlin.math.absoluteValue
+import kotlin.reflect.KClass
+import org.assertj.core.api.AbstractIntegerAssert
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.AndroidReferenceMatchers.Companion.buildKnownReferences
+import shark.AndroidReferenceMatchers.FINALIZER_WATCHDOG_DAEMON
+import shark.AndroidReferenceMatchers.REFERENCES
+import shark.GcRoot.ThreadObject
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.OnAnalysisProgressListener.Step.COMPUTING_NATIVE_RETAINED_SIZE
+import shark.OnAnalysisProgressListener.Step.COMPUTING_RETAINED_SIZE
+import shark.OnAnalysisProgressListener.Step.EXTRACTING_METADATA
+import shark.OnAnalysisProgressListener.Step.FINDING_DOMINATORS
+import shark.OnAnalysisProgressListener.Step.FINDING_PATHS_TO_RETAINED_OBJECTS
+import shark.OnAnalysisProgressListener.Step.FINDING_RETAINED_OBJECTS
+import shark.OnAnalysisProgressListener.Step.INSPECTING_OBJECTS
+import shark.OnAnalysisProgressListener.Step.PARSING_HEAP_DUMP
+import shark.internal.ObjectDominators
+
+private const val ANALYSIS_THREAD = "analysis"
+
+class HprofRetainedHeapPerfTest {
+
+  @get:Rule
+  var tmpFolder = TemporaryFolder()
+
+  lateinit var folder: File
+
+  @Before
+  fun setUp() {
+    folder = tmpFolder.newFolder()
+  }
+
+  @Test fun `freeze retained memory when indexing leak_asynctask_o`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+
+    val (baselineHeap, heapWithIndex) = runInThread(ANALYSIS_THREAD) {
+      val baselineHeap = dumpHeap("baseline")
+      val hprofIndex = indexRecordsOf(hprofFile)
+      val heapWithIndex = dumpHeapRetaining(hprofIndex)
+      baselineHeap to heapWithIndex
+    }
+
+    val (analysisRetained, _) = heapWithIndex.retainedHeap(ANALYSIS_THREAD)
+
+    val retained = analysisRetained - baselineHeap.retainedHeap(ANALYSIS_THREAD).first
+
+    assertThat(retained).isEqualTo(5.07 MB +-5 % margin)
+  }
+
+  @Test fun `freeze retained memory when indexing leak_asynctask_m`() {
+    val hprofFile = "leak_asynctask_m.hprof".classpathFile()
+
+    val (baselineHeap, heapWithIndex) = runInThread(ANALYSIS_THREAD) {
+      val baselineHeap = dumpHeap("baseline")
+      val hprofIndex = indexRecordsOf(hprofFile)
+      val heapWithIndex = dumpHeapRetaining(hprofIndex)
+      baselineHeap to heapWithIndex
+    }
+
+    val (analysisRetained, _) = heapWithIndex.retainedHeap(ANALYSIS_THREAD)
+
+    val retained = analysisRetained - baselineHeap.retainedHeap(ANALYSIS_THREAD).first
+
+    assertThat(retained).isEqualTo(4.9 MB +-5 % margin)
+  }
+
+  @Test fun `freeze retained memory through analysis steps of leak_asynctask_o`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+    val stepsToHeapDumpFile = mutableMapOf<OnAnalysisProgressListener.Step, File>()
+    val heapAnalyzer = HeapAnalyzer { step ->
+      stepsToHeapDumpFile[step] = dumpHeap(step.name)
+    }
+
+    // matchers contain large description strings which depending on the VM maybe be reachable
+    // only via matchers (=> thread locals), and otherwise also statically by the enum class that
+    // defines them. So we create a reference outside of the working thread to exclude them from
+    // the retained count and avoid a varying count.
+    val matchers = AndroidReferenceMatchers.appDefaults
+    val baselineHeap = runInThread(ANALYSIS_THREAD) {
+      val baselineHeap = dumpHeap("baseline")
+      heapAnalyzer.analyze(
+        heapDumpFile = hprofFile,
+        leakingObjectFinder = FilteringLeakingObjectFinder(
+          AndroidObjectInspectors.appLeakingObjectFilters
+        ),
+        referenceMatchers = matchers,
+        objectInspectors = AndroidObjectInspectors.appDefaults,
+        metadataExtractor = AndroidMetadataExtractor,
+        computeRetainedHeapSize = true
+      ).apply {
+        check(this is HeapAnalysisSuccess) {
+          "Expected success not $this"
+        }
+      }
+      baselineHeap
+    }
+
+    val retainedBeforeAnalysis = baselineHeap.retainedHeap(ANALYSIS_THREAD).first
+    val retained = stepsToHeapDumpFile.mapValues {
+      val retainedPair = it.value.retainedHeap(ANALYSIS_THREAD, computeDominators = true)
+      retainedPair.first - retainedBeforeAnalysis to retainedPair.second
+    }
+
+    assertThat(retained after PARSING_HEAP_DUMP).isEqualTo(5.57 MB +-5 % margin)
+    assertThat(retained after EXTRACTING_METADATA).isEqualTo(5.62 MB +-5 % margin)
+    assertThat(retained after FINDING_RETAINED_OBJECTS).isEqualTo(5.72 MB +-5 % margin)
+    assertThat(retained after FINDING_PATHS_TO_RETAINED_OBJECTS).isEqualTo(7.12 MB +-5 % margin)
+    assertThat(retained after FINDING_DOMINATORS).isEqualTo(7.12 MB +-5 % margin)
+    assertThat(retained after INSPECTING_OBJECTS).isEqualTo(7.13 MB +-5 % margin)
+    assertThat(retained after COMPUTING_NATIVE_RETAINED_SIZE).isEqualTo(7.13 MB +-5 % margin)
+    assertThat(retained after COMPUTING_RETAINED_SIZE).isEqualTo(6.05 MB +-5 % margin)
+  }
+
+  private fun indexRecordsOf(hprofFile: File): HprofIndex {
+    return HprofIndex.indexRecordsOf(
+      hprofSourceProvider = FileSourceProvider(hprofFile),
+      hprofHeader = HprofHeader.parseHeaderOf(hprofFile)
+    )
+  }
+
+  private fun dumpHeapRetaining(instance: Any): File {
+    val heapDumpFile = dumpHeap("retaining-${instance::class.java.name}")
+    // Dumb check to prevent instance from being garbage collected.
+    check(instance::class::class.isInstance(KClass::class))
+    return heapDumpFile
+  }
+
+  private fun dumpHeap(name: String): File {
+    // Dumps the heap in a separate thread to avoid java locals being added to the count of
+    // bytes retained by this thread.
+    return runInThread("heap dump") {
+      val testHprofFile = File(folder, "$name.hprof")
+      if (testHprofFile.exists()) {
+        testHprofFile.delete()
+      }
+      JvmTestHeapDumper.dumpHeap(testHprofFile.absolutePath)
+      testHprofFile
+    }
+  }
+
+  private fun <T : Any> runInThread(
+    threadName: String,
+    work: () -> T
+  ): T {
+    lateinit var result: T
+    val latch = CountDownLatch(1)
+    thread(name = threadName) {
+      result = work()
+      latch.countDown()
+    }
+    check(latch.await(30, SECONDS))
+    return result
+  }
+
+  private infix fun Map<OnAnalysisProgressListener.Step, Pair<Bytes, String>>.after(step: OnAnalysisProgressListener.Step): Pair<Bytes, String> {
+    val values = OnAnalysisProgressListener.Step.values()
+    for (nextOrdinal in step.ordinal + 1 until values.size) {
+      val pair = this[values[nextOrdinal]]
+      if (pair != null) {
+        val (nextStepRetained, dominatorTree) = pair
+
+        return nextStepRetained to "\n$nextStepRetained retained by analysis thread after step ${step.name} not valid\n" + dominatorTree
+      }
+    }
+    error("No step in $this after $step")
+  }
+
+  private fun File.retainedHeap(
+    threadName: String,
+    computeDominators: Boolean = false
+  ): Pair<Bytes, String> {
+    val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+
+    val (analysis, dominatorTree) = openHeapGraph().use { graph ->
+      val analysis = heapAnalyzer.analyze(
+        heapDumpFile = this,
+        graph = graph,
+        referenceMatchers = buildKnownReferences(
+          EnumSet.of(REFERENCES, FINALIZER_WATCHDOG_DAEMON)
+        ),
+        leakingObjectFinder = {
+          setOf(graph.gcRoots.first { gcRoot ->
+            gcRoot is ThreadObject &&
+              graph.objectExists(gcRoot.id) &&
+              graph.findObjectById(gcRoot.id)
+                .asInstance!!["java.lang.Thread", "name"]!!
+                .value.readAsJavaString() == threadName
+          }.id)
+        },
+        computeRetainedHeapSize = true
+      )
+      check(analysis is HeapAnalysisSuccess) {
+        "Expected success not $analysis"
+      }
+
+      val dominatorTree = if (computeDominators) {
+        val weakAndFinalizerRefs = EnumSet.of(REFERENCES, FINALIZER_WATCHDOG_DAEMON)
+        val ignoredRefs = buildKnownReferences(weakAndFinalizerRefs).map { matcher ->
+          matcher as IgnoredReferenceMatcher
+        }
+        ObjectDominators().renderDominatorTree(
+          graph, ignoredRefs, 200, threadName, true
+        )
+      } else ""
+      analysis to dominatorTree
+    }
+
+    return analysis.applicationLeaks.single().leakTraces.single().retainedHeapByteSize!!.bytes to dominatorTree
+  }
+
+  class BytesAssert(
+    bytes: Bytes,
+    description: String
+  ) : AbstractIntegerAssert<BytesAssert>(
+    bytes.count, BytesAssert::class.java
+  ) {
+
+    init {
+      describedAs(description)
+    }
+
+    fun isEqualTo(expected: BytesWithError): BytesAssert {
+      val errorPercentage = expected.error.percentage.absoluteValue
+      return isBetween(
+        (expected.count * (1 - errorPercentage)).toInt(),
+        (expected.count * (1 + errorPercentage)).toInt()
+      )
+    }
+  }
+
+  private fun assertThat(bytes: Bytes) = BytesAssert(bytes, "")
+
+  private fun assertThat(pair: Pair<Bytes, String>) = BytesAssert(pair.first, pair.second)
+
+  data class Bytes(val count: Int)
+
+  operator fun Bytes.minus(other: Bytes) = Bytes(count - other.count)
+
+  private val Int.bytes: Bytes
+    get() = Bytes(this)
+
+  class BytesWithError(
+    val count: Int,
+    val error: ErrorPercentage
+  )
+
+  object Margin
+
+  private val margin
+    get() = Margin
+
+  class ErrorPercentage(val percentage: Double)
+
+  infix fun Double.MB(error: ErrorPercentage) =
+    BytesWithError((this * 1_000_000).toInt(), error)
+
+  operator fun Int.rem(ignored: Margin): ErrorPercentage = ErrorPercentage(this / 100.0)
+}
diff --git a/shark-android/src/test/java/shark/LegacyHprofTest.kt b/shark-android/src/test/java/shark/LegacyHprofTest.kt
new file mode 100644
index 00000000..6c68dbf6
--- /dev/null
+++ b/shark-android/src/test/java/shark/LegacyHprofTest.kt
@@ -0,0 +1,272 @@
+package shark
+
+import java.io.File
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.HeapObject.HeapInstance
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.HprofRecordTag.LOAD_CLASS
+import shark.HprofRecordTag.ROOT_STICKY_CLASS
+import shark.HprofRecordTag.STRING_IN_UTF8
+import shark.LeakTrace.GcRootType
+import shark.LegacyHprofTest.WRAPS_ACTIVITY.DESTROYED
+import shark.LegacyHprofTest.WRAPS_ACTIVITY.NOT_ACTIVITY
+import shark.LegacyHprofTest.WRAPS_ACTIVITY.NOT_DESTROYED
+import shark.SharkLog.Logger
+
+class LegacyHprofTest {
+
+  @Test fun preM() {
+    val analysis = analyzeHprof("leak_asynctask_pre_m.hprof")
+    assertThat(analysis.applicationLeaks).hasSize(2)
+    val leak1 = analysis.applicationLeaks[0].leakTraces.first()
+    val leak2 = analysis.applicationLeaks[1].leakTraces.first()
+    assertThat(leak1.leakingObject.className).isEqualTo("android.graphics.Bitmap")
+    assertThat(leak2.leakingObject.className).isEqualTo("com.example.leakcanary.MainActivity")
+    assertThat(analysis.metadata).containsAllEntriesOf(
+      mapOf(
+        "App process name" to "com.example.leakcanary",
+        "Build.MANUFACTURER" to "Genymotion",
+        "Build.VERSION.SDK_INT" to "19",
+        "LeakCanary version" to "Unknown"
+      )
+    )
+    assertThat(analysis.allLeaks.sumBy { it.totalRetainedHeapByteSize!! }).isEqualTo(193431)
+  }
+
+  @Test fun androidM() {
+    val analysis = analyzeHprof("leak_asynctask_m.hprof")
+
+    assertThat(analysis.applicationLeaks).hasSize(1)
+    val leak = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leak.leakingObject.className).isEqualTo("com.example.leakcanary.MainActivity")
+    assertThat(leak.gcRootType).isEqualTo(GcRootType.STICKY_CLASS)
+    assertThat(analysis.allLeaks.sumBy { it.totalRetainedHeapByteSize!! }).isEqualTo(49584)
+  }
+
+  @Test fun gcRootReferencesUnknownObject() {
+    val analysis = analyzeHprof("gcroot_unknown_object.hprof")
+
+    assertThat(analysis.applicationLeaks).hasSize(2)
+    assertThat(analysis.allLeaks.sumBy { it.totalRetainedHeapByteSize!! }).isEqualTo(5306218)
+  }
+
+  @Test fun androidMStripped() {
+    val stripper = HprofPrimitiveArrayStripper()
+    val sourceHprof = "leak_asynctask_m.hprof".classpathFile()
+    val strippedHprof = stripper.stripPrimitiveArrays(sourceHprof)
+
+    assertThat(readThreadNames(sourceHprof)).contains("AsyncTask #1")
+    assertThat(readThreadNames(strippedHprof)).allMatch { threadName ->
+      threadName.all { character -> character == '?' }
+    }
+  }
+
+  private fun readThreadNames(hprofFile: File): List<String> {
+    return hprofFile.openHeapGraph().use { graph ->
+      graph.findClassByName("java.lang.Thread")!!.instances.map { instance ->
+        instance["java.lang.Thread", "name"]!!.value.readAsJavaString()!!
+      }
+        .toList()
+    }
+  }
+
+  @Test fun androidO() {
+    val analysis = analyzeHprof("leak_asynctask_o.hprof")
+
+    assertThat(analysis.applicationLeaks).hasSize(1)
+    val leak = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leak.leakingObject.className).isEqualTo("com.example.leakcanary.MainActivity")
+    assertThat(analysis.allLeaks.sumBy { it.totalRetainedHeapByteSize!! }).isEqualTo(211038)
+  }
+
+  private enum class WRAPS_ACTIVITY {
+    DESTROYED,
+    NOT_DESTROYED,
+    NOT_ACTIVITY
+  }
+
+  @Test fun `AndroidObjectInspectors#CONTEXT_FIELD labels Context fields`() {
+    val toastLabels = "leak_asynctask_o.hprof".classpathFile().openHeapGraph().use { graph ->
+      graph.instances.filter { it.instanceClassName == "android.widget.Toast" }
+        .map { instance ->
+          ObjectReporter(instance).apply {
+            AndroidObjectInspectors.CONTEXT_FIELD.inspect(this)
+          }.labels.joinToString(",")
+        }.toList()
+    }
+    assertThat(toastLabels).containsExactly(
+      "mContext instance of com.example.leakcanary.ExampleApplication"
+    )
+  }
+
+  @Test fun androidOCountActivityWrappingContexts() {
+    val contextWrapperStatuses = Hprof.open("leak_asynctask_o.hprof".classpathFile())
+      .use { hprof ->
+        val graph = HprofHeapGraph.indexHprof(hprof)
+        graph.instances.filter {
+          it instanceOf "android.content.ContextWrapper"
+            && !(it instanceOf "android.app.Activity")
+            && !(it instanceOf "android.app.Application")
+            && !(it instanceOf "android.app.Service")
+        }
+          .map { instance ->
+            val reporter = ObjectReporter(instance)
+            AndroidObjectInspectors.CONTEXT_WRAPPER.inspect(reporter)
+            if (reporter.leakingReasons.size == 1) {
+              DESTROYED
+            } else if (reporter.labels.size == 1) {
+              if ("Activity.mDestroyed false" in reporter.labels.first()) {
+                NOT_DESTROYED
+              } else {
+                NOT_ACTIVITY
+              }
+            } else throw IllegalStateException(
+              "Unexpected, should have 1 leaking status ${reporter.leakingReasons} or one label ${reporter.labels}"
+            )
+          }
+          .toList()
+      }
+    assertThat(contextWrapperStatuses.filter { it == DESTROYED }).hasSize(12)
+    assertThat(contextWrapperStatuses.filter { it == NOT_DESTROYED }).hasSize(6)
+    assertThat(contextWrapperStatuses.filter { it == NOT_ACTIVITY }).hasSize(0)
+  }
+
+  @Test fun gcRootInNonPrimaryHeap() {
+    val analysis = analyzeHprof("gc_root_in_non_primary_heap.hprof")
+
+    assertThat(analysis.applicationLeaks).hasSize(1)
+    val leak = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leak.leakingObject.className).isEqualTo("com.example.leakcanary.MainActivity")
+  }
+
+  @Test fun `MessageQueue shows list of messages as array`() {
+    val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+    val analysis = heapAnalyzer.analyze(
+      heapDumpFile = "gc_root_in_non_primary_heap.hprof".classpathFile(),
+      leakingObjectFinder = FilteringLeakingObjectFinder(
+        listOf(FilteringLeakingObjectFinder.LeakingObjectFilter { heapObject ->
+          heapObject is HeapInstance &&
+            heapObject instanceOf "android.os.Message" &&
+            heapObject["android.os.Message", "target"]?.valueAsInstance?.instanceClassName == "android.app.ActivityThread\$H" &&
+            heapObject["android.os.Message", "what"]!!.value.asInt!! == 132 // ENABLE_JIT
+        })
+      ),
+      referenceMatchers = AndroidReferenceMatchers.appDefaults,
+      computeRetainedHeapSize = true,
+      objectInspectors = AndroidObjectInspectors.appDefaults,
+      metadataExtractor = AndroidMetadataExtractor
+    )
+    println(analysis)
+    analysis as HeapAnalysisSuccess
+    assertThat(analysis.applicationLeaks).hasSize(1)
+    val leak = analysis.applicationLeaks[0].leakTraces.first()
+    val firstReference = leak.referencePath.first()
+    assertThat(firstReference.originObject.className).isEqualTo("android.os.MessageQueue")
+    assertThat(firstReference.referenceDisplayName).isEqualTo("[0]")
+  }
+
+  @Test fun `duplicated unloaded classes are ignored`() {
+    val expectedDuplicatedClassNames = setOf(
+      "leakcanary.internal.DebuggerControl",
+      "shark.AndroidResourceIdNames\$Companion",
+      "shark.GraphContext",
+      "shark.AndroidResourceIdNames\$Companion\$readFromHeap$1",
+      "leakcanary.internal.HeapDumpTrigger\$saveResourceIdNamesToMemory$1",
+      "leakcanary.internal.HeapDumpTrigger\$saveResourceIdNamesToMemory$2",
+      "shark.AndroidResourceIdNames",
+      "leakcanary.internal.FutureResult",
+      "leakcanary.internal.AndroidHeapDumper\$showToast$1",
+      "android.widget.Toast\$TN",
+      "android.widget.Toast\$TN$1",
+      "android.widget.Toast\$TN$2",
+      "leakcanary.internal.AndroidHeapDumper\$showToast$1$1",
+      "com.squareup.leakcanary.core.R\$dimen",
+      "com.squareup.leakcanary.core.R\$layout",
+      "android.text.style.WrapTogetherSpan[]"
+    )
+
+    val file = "unloaded_classes-stripped.hprof".classpathFile()
+
+    val header = HprofHeader.parseHeaderOf(file)
+
+    val stickyClasses = mutableListOf<Long>()
+    val classesAndNameStringId = mutableMapOf<Long, Long>()
+    val stringRecordById = mutableMapOf<Long, String>()
+    StreamingHprofReader.readerFor(file, header).readRecords(setOf(ROOT_STICKY_CLASS, STRING_IN_UTF8, LOAD_CLASS)) { tag, length, reader ->
+      when(tag) {
+        ROOT_STICKY_CLASS -> reader.readStickyClassGcRootRecord().apply {
+          stickyClasses += id
+        }
+        STRING_IN_UTF8 -> reader.readStringRecord(length).apply {
+          stringRecordById[id] = string
+        }
+        LOAD_CLASS -> reader.readLoadClassRecord().apply {
+          classesAndNameStringId[id] = classNameStringId
+        }
+      }
+    }
+    val duplicatedClassObjectIdsByNameStringId =
+      classesAndNameStringId.entries
+        .groupBy { (_, className) -> className }
+        .mapValues { (_, value) -> value.map { (key, _) -> key } }
+        .filter { (_, values) -> values.size > 1 }
+
+    val actualDuplicatedClassNames = duplicatedClassObjectIdsByNameStringId.keys
+      .map { stringRecordById.getValue(it) }
+      .toSet()
+    assertThat(actualDuplicatedClassNames).isEqualTo(expectedDuplicatedClassNames)
+
+    val duplicateRootClassObjectIdByClassName = duplicatedClassObjectIdsByNameStringId
+      .mapKeys { (key, _) -> stringRecordById.getValue(key) }
+      .mapValues { (_, value) -> value.single { it in stickyClasses } }
+
+    file.openHeapGraph().use { graph ->
+      val expectedDuplicatedRootClassObjectIds =
+        duplicateRootClassObjectIdByClassName.values.toSortedSet()
+
+      val actualDuplicatedRootClassObjectIds = duplicateRootClassObjectIdByClassName.keys
+        .map { className ->
+          graph.findClassByName(className)!!.objectId
+        }
+        .toSortedSet()
+
+      assertThat(actualDuplicatedRootClassObjectIds).isEqualTo(
+        expectedDuplicatedRootClassObjectIds
+      )
+    }
+  }
+
+  private fun analyzeHprof(fileName: String): HeapAnalysisSuccess {
+    return analyzeHprof(fileName.classpathFile())
+  }
+
+  private fun analyzeHprof(hprofFile: File): HeapAnalysisSuccess {
+    SharkLog.logger = object : Logger {
+      override fun d(message: String) {
+        println(message)
+      }
+
+      override fun d(
+        throwable: Throwable,
+        message: String
+      ) {
+        println(message)
+        throwable.printStackTrace()
+      }
+    }
+    val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+    val analysis = heapAnalyzer.analyze(
+      heapDumpFile = hprofFile,
+      leakingObjectFinder = FilteringLeakingObjectFinder(
+        AndroidObjectInspectors.appLeakingObjectFilters
+      ),
+      referenceMatchers = AndroidReferenceMatchers.appDefaults,
+      computeRetainedHeapSize = true,
+      objectInspectors = AndroidObjectInspectors.appDefaults,
+      metadataExtractor = AndroidMetadataExtractor
+    )
+    println(analysis)
+    return analysis as HeapAnalysisSuccess
+  }
+}
diff --git a/shark-android/src/test/java/shark/LruCacheTuning.kt b/shark-android/src/test/java/shark/LruCacheTuning.kt
new file mode 100644
index 00000000..be785b00
--- /dev/null
+++ b/shark-android/src/test/java/shark/LruCacheTuning.kt
@@ -0,0 +1,163 @@
+package shark
+
+import okio.buffer
+import okio.source
+import shark.AndroidReferenceMatchers.FINALIZER_WATCHDOG_DAEMON
+import shark.AndroidReferenceMatchers.REFERENCES
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import java.io.File
+import java.io.FileWriter
+import java.util.EnumSet
+import java.util.UUID
+
+/**
+ * Tests different values for the lru cache size when performing the leak analysss, measuring IO
+ * reads and memory retained by the cache for each cache size, and outputting the result as
+ * a CSV.
+ *
+ * Data saved at https://docs.google.com/spreadsheets/d/14BRd1CJO2_WRBqNQRdfDUDLhr3_2R5N461a74XA4pjE/edit?usp=sharing
+ */
+fun main() {
+  val tmpHeapDumpFolder = createTemporaryFolder()
+
+  val lruCacheSizes = 100..20000 step 500
+  val files = listOf("leak_asynctask_o", "leak_asynctask_m")
+  val computeRetainedHeapSizeList = listOf(false, true)
+
+  val stats = mutableListOf<MutableList<Int>>()
+  for (lruCacheSize in lruCacheSizes) {
+    val row = mutableListOf<Int>()
+    row.add(lruCacheSize)
+    stats.add(row)
+  }
+
+  for (filename in files) {
+    val hprofFile = "$filename.hprof".classpathFile()
+    val bytes = hprofFile.inputStream().source().buffer().readByteArray()
+    lruCacheSizes.forEachIndexed { index, lruCacheSize ->
+      val row = stats[index]
+      for (computeRetainedHeapSize in computeRetainedHeapSizeList) {
+        val (randomAccessReads, lruRetainedSize) = trackAnalyzeMetrics(
+          hprofFile, bytes, tmpHeapDumpFolder, computeRetainedHeapSize, lruCacheSize
+        )
+        val bytesRead = randomAccessReads.sum()
+        val readCount = randomAccessReads.size
+        row.add(bytesRead)
+        row.add(readCount)
+        row.add(lruRetainedSize)
+      }
+    }
+  }
+
+  tmpHeapDumpFolder.recursiveDelete()
+
+  FileWriter("lru_cache_tuning.csv").use {
+    with(it) {
+      append("lru_size")
+      for (filename in files) {
+        for (computeRetainedHeapSize in computeRetainedHeapSizeList) {
+          listOf("bytes_read", "read_count", "lru_retained").forEach { column ->
+            append(",${filename}_size_${computeRetainedHeapSize}_$column")
+          }
+        }
+      }
+      append('\n')
+      for (statRow in stats) {
+        append(statRow.joinToString(",", postfix = "\n"))
+      }
+    }
+  }
+}
+
+private fun trackAnalyzeMetrics(
+  hprofFile: File,
+  bytes: ByteArray,
+  tmpHeapDumpFolder: File,
+  computeRetainedHeapSize: Boolean,
+  lruCacheSize: Int
+): Pair<List<Int>, Int> {
+  println(
+    "Analysing ${hprofFile.name} computeRetainedHeapSize=$computeRetainedHeapSize lruCacheSize=$lruCacheSize"
+  )
+
+  val source = MetricsDualSourceProvider(ByteArraySourceProvider(bytes))
+  val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+  val heapAfterAnalysis = withLruCacheSize(lruCacheSize) {
+    source.openHeapGraph().use { graph ->
+      val analysis = heapAnalyzer.analyze(
+        heapDumpFile = hprofFile,
+        graph = graph,
+        leakingObjectFinder = FilteringLeakingObjectFinder(
+          AndroidObjectInspectors.appLeakingObjectFilters
+        ),
+        referenceMatchers = AndroidReferenceMatchers.appDefaults,
+        computeRetainedHeapSize = computeRetainedHeapSize,
+        objectInspectors = AndroidObjectInspectors.appDefaults,
+        metadataExtractor = AndroidMetadataExtractor
+      )
+      check(analysis is HeapAnalysisSuccess) {
+        "Expected success not $analysis"
+      }
+      tmpHeapDumpFolder.dumpHeap()
+    }
+  }
+  val randomAccessReads = source.sourcesMetrics[3]
+
+  val lruCacheAnalysis = heapAnalyzer.analyze(
+    heapDumpFile = heapAfterAnalysis,
+    referenceMatchers = AndroidReferenceMatchers.buildKnownReferences(
+      EnumSet.of(REFERENCES, FINALIZER_WATCHDOG_DAEMON)
+    ),
+    leakingObjectFinder = { graph ->
+      setOf(graph.findClassByName("shark.internal.LruCache")!!.instances.single().objectId)
+    },
+    computeRetainedHeapSize = true
+  )
+  check(lruCacheAnalysis is HeapAnalysisSuccess) {
+    "Expected success not $lruCacheAnalysis"
+  }
+  val lruRetainedSize =
+    lruCacheAnalysis.allLeaks.single().leakTraces.single().retainedHeapByteSize!!
+
+  println(
+    "${randomAccessReads.sum()} bytes in ${randomAccessReads.size} reads, retaining $lruRetainedSize bytes in cache"
+  )
+
+  return randomAccessReads to lruRetainedSize
+}
+
+private fun <T> withLruCacheSize(
+  lruCacheSize: Int,
+  block: () -> T
+): T {
+  val sizeBefore = HprofHeapGraph.INTERNAL_LRU_CACHE_SIZE
+  HprofHeapGraph.INTERNAL_LRU_CACHE_SIZE = lruCacheSize
+  try {
+    return block()
+  } finally {
+    HprofHeapGraph.INTERNAL_LRU_CACHE_SIZE = sizeBefore
+  }
+}
+
+private fun createTemporaryFolder(): File {
+  val createdFolder = File.createTempFile("shark", "", null)
+  createdFolder.delete()
+  createdFolder.mkdir()
+  return createdFolder
+}
+
+private fun File.recursiveDelete() {
+  val files = listFiles()
+  if (files != null) {
+    for (each in files) {
+      each.recursiveDelete()
+    }
+  }
+  delete()
+}
+
+private fun File.dumpHeap(): File {
+  val testHprofFile = File(this, "${UUID.randomUUID()}.hprof")
+  JvmTestHeapDumper.dumpHeap(testHprofFile.absolutePath)
+  return testHprofFile
+}
diff --git a/shark-android/src/test/java/shark/MetricsDualSourceProvider.kt b/shark-android/src/test/java/shark/MetricsDualSourceProvider.kt
new file mode 100644
index 00000000..f6ca1994
--- /dev/null
+++ b/shark-android/src/test/java/shark/MetricsDualSourceProvider.kt
@@ -0,0 +1,55 @@
+package shark
+
+import java.io.File
+import okio.Buffer
+import okio.BufferedSource
+import okio.Source
+import okio.buffer
+
+class MetricsDualSourceProvider(
+  private val realSourceProvider: DualSourceProvider
+) : DualSourceProvider {
+
+  constructor(file: File) : this(FileSourceProvider(file))
+
+  val sourcesMetrics = mutableListOf<MutableList<Int>>()
+
+  override fun openStreamingSource(): BufferedSource {
+    val sourceMetrics = mutableListOf<Int>()
+    sourcesMetrics += sourceMetrics
+    val fileSource = realSourceProvider.openStreamingSource()
+    return object : Source {
+      override fun read(
+        sink: Buffer,
+        byteCount: Long
+      ): Long {
+        val bytesRead = fileSource.read(sink, byteCount)
+        sourceMetrics += if (bytesRead >= 0) bytesRead.toInt() else 0
+        return bytesRead
+      }
+
+      override fun close() = fileSource.close()
+
+      override fun timeout() = fileSource.timeout()
+    }.buffer()
+  }
+
+  override fun openRandomAccessSource(): RandomAccessSource {
+    val sourceMetrics = mutableListOf<Int>()
+    sourcesMetrics += sourceMetrics
+    val randomAccessSource = realSourceProvider.openRandomAccessSource()
+    return object : RandomAccessSource {
+      override fun read(
+        sink: Buffer,
+        position: Long,
+        byteCount: Long
+      ): Long {
+        val bytesRead = randomAccessSource.read(sink, position, byteCount)
+        sourceMetrics += bytesRead.toInt()
+        return bytesRead
+      }
+
+      override fun close() = randomAccessSource.close()
+    }
+  }
+}
diff --git a/shark-android/src/test/java/shark/Resources.kt b/shark-android/src/test/java/shark/Resources.kt
new file mode 100644
index 00000000..e48ad75d
--- /dev/null
+++ b/shark-android/src/test/java/shark/Resources.kt
@@ -0,0 +1,10 @@
+package shark
+
+import java.io.File
+
+fun String.classpathFile(): File {
+  val classLoader = Thread.currentThread()
+    .contextClassLoader
+  val url = classLoader.getResource(this)!!
+  return File(url.path)
+}
\ No newline at end of file
diff --git a/shark-android/src/test/java/shark/StringPathFinderOptimTest.kt b/shark-android/src/test/java/shark/StringPathFinderOptimTest.kt
new file mode 100644
index 00000000..e2ff3d7d
--- /dev/null
+++ b/shark-android/src/test/java/shark/StringPathFinderOptimTest.kt
@@ -0,0 +1,54 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import java.io.File
+
+/**
+ * Our path finding algorithm skips going through the content of strings to avoid unnecessary reads.
+ * We add back the corresponding size when computing the shallow size of retained strings,
+ * however that only works if those byte arrays aren't reachable through other references.
+ * If they were, this could either inflate the retained size number (byte array should not be
+ * considered retained) or deflate it (byte array counted twice when reached from two retained
+ * instances).
+ */
+class StringPathFinderOptimTest {
+
+  @Test fun `String#value not reachable on Android O`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+    val analysis = findStringContent(hprofFile)
+    assertThat(analysis.allLeaks.count()).isEqualTo(0)
+  }
+
+  @Test fun `String#value not reachable on Android M`() {
+    val hprofFile = "leak_asynctask_m.hprof".classpathFile()
+    val analysis = findStringContent(hprofFile)
+    assertThat(analysis.allLeaks.count()).isEqualTo(0)
+  }
+
+  @Test fun `String#value only reachable for String#ASCII pre Android M`() {
+    val hprofFile = "leak_asynctask_pre_m.hprof".classpathFile()
+    val analysis = findStringContent(hprofFile)
+    assertThat(analysis.allLeaks.count()).isEqualTo(1)
+    val path = analysis.applicationLeaks.first().leakTraces.first()
+    assertThat(path.referencePath.first().referenceName).isEqualTo("ASCII")
+  }
+
+  private fun findStringContent(hprofFile: File): HeapAnalysisSuccess {
+    val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+    val analysis = heapAnalyzer.analyze(
+      heapDumpFile = hprofFile,
+      leakingObjectFinder = { graph ->
+        graph.findClassByName("java.lang.String")!!.instances.map { instance ->
+          instance["java.lang.String", "value"]?.value?.asNonNullObjectId!!
+        }.toSet()
+      },
+      referenceMatchers = AndroidReferenceMatchers.appDefaults,
+      computeRetainedHeapSize = true,
+      objectInspectors = AndroidObjectInspectors.appDefaults,
+      metadataExtractor = AndroidMetadataExtractor
+    )
+    println(analysis)
+    return analysis as HeapAnalysisSuccess
+  }
+}
diff --git a/shark-android/src/test/resources/compose_leak.hprof b/shark-android/src/test/resources/compose_leak.hprof
new file mode 100644
index 00000000..996ad2af
Binary files /dev/null and b/shark-android/src/test/resources/compose_leak.hprof differ
diff --git a/shark-android/src/test/resources/gc_root_in_non_primary_heap.hprof b/shark-android/src/test/resources/gc_root_in_non_primary_heap.hprof
new file mode 100644
index 00000000..7ca6d0bc
Binary files /dev/null and b/shark-android/src/test/resources/gc_root_in_non_primary_heap.hprof differ
diff --git a/shark-android/src/test/resources/gcroot_unknown_object.hprof b/shark-android/src/test/resources/gcroot_unknown_object.hprof
new file mode 100755
index 00000000..f08f4545
Binary files /dev/null and b/shark-android/src/test/resources/gcroot_unknown_object.hprof differ
diff --git a/shark-android/src/test/resources/leak_asynctask_m.hprof b/shark-android/src/test/resources/leak_asynctask_m.hprof
new file mode 100644
index 00000000..6945c82d
Binary files /dev/null and b/shark-android/src/test/resources/leak_asynctask_m.hprof differ
diff --git a/shark-android/src/test/resources/leak_asynctask_o.hprof b/shark-android/src/test/resources/leak_asynctask_o.hprof
new file mode 100644
index 00000000..1c62d0e5
Binary files /dev/null and b/shark-android/src/test/resources/leak_asynctask_o.hprof differ
diff --git a/shark-android/src/test/resources/leak_asynctask_pre_m.hprof b/shark-android/src/test/resources/leak_asynctask_pre_m.hprof
new file mode 100644
index 00000000..a1d60adc
Binary files /dev/null and b/shark-android/src/test/resources/leak_asynctask_pre_m.hprof differ
diff --git a/shark-android/src/test/resources/unloaded_classes-stripped.hprof b/shark-android/src/test/resources/unloaded_classes-stripped.hprof
new file mode 100644
index 00000000..e9097f18
Binary files /dev/null and b/shark-android/src/test/resources/unloaded_classes-stripped.hprof differ
diff --git a/shark-cli.sh b/shark-cli.sh
new file mode 100755
index 00000000..ed8b746a
--- /dev/null
+++ b/shark-cli.sh
@@ -0,0 +1,2 @@
+./gradlew --quiet :shark-cli:installDist
+./shark-cli/build/install/shark-cli/bin/shark-cli "$@"
\ No newline at end of file
diff --git a/shark-cli/build.gradle b/shark-cli/build.gradle
new file mode 100644
index 00000000..289c4170
--- /dev/null
+++ b/shark-cli/build.gradle
@@ -0,0 +1,51 @@
+import org.jetbrains.kotlin.gradle.dsl.KotlinCompile
+
+plugins {
+  id("org.jetbrains.kotlin.jvm")
+  id("application")
+  id("com.vanniktech.maven.publish")
+}
+
+sourceCompatibility = JavaVersion.VERSION_1_8
+targetCompatibility = JavaVersion.VERSION_1_8
+
+// Workaround for https://stackoverflow.com/questions/48988778
+// /cannot-inline-bytecode-built-with-jvm-target-1-8-into-bytecode-that-is-being-bui
+tasks.withType(KotlinCompile).configureEach {
+  kotlinOptions.jvmTarget = JavaVersion.VERSION_1_8.toString()
+}
+
+dependencies {
+  api projects.sharkAndroid
+
+  implementation libs.clikt
+  implementation libs.neo4j
+  implementation libs.jline
+  implementation libs.kotlin.stdlib
+}
+
+application {
+  mainClassName = 'shark.MainKt'
+}
+
+def generatedVersionDir = "${buildDir}/generated-version"
+
+sourceSets {
+  main {
+    output.dir(generatedVersionDir, builtBy: 'generateVersionProperties')
+  }
+}
+
+tasks.register("generateVersionProperties") {
+  doLast {
+    def propertiesFile = file "$generatedVersionDir/version.properties"
+    propertiesFile.parentFile.mkdirs()
+    def properties = new Properties()
+    properties.setProperty("version_name", rootProject.VERSION_NAME.toString())
+    propertiesFile.withWriter { properties.store(it, null) }
+  }
+}
+tasks.named("processResources") {
+  dependsOn("generateVersionProperties")
+}
+
diff --git a/shark-cli/gradle.properties b/shark-cli/gradle.properties
new file mode 100644
index 00000000..8f2712b1
--- /dev/null
+++ b/shark-cli/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark-cli
+POM_NAME=Shark Command Line Interface
+POM_PACKAGING=jar
diff --git a/shark-cli/src/main/java/shark/AnalyzeCommand.kt b/shark-cli/src/main/java/shark/AnalyzeCommand.kt
new file mode 100644
index 00000000..c2e5fd0f
--- /dev/null
+++ b/shark-cli/src/main/java/shark/AnalyzeCommand.kt
@@ -0,0 +1,50 @@
+package shark
+
+import com.github.ajalt.clikt.core.CliktCommand
+import shark.SharkCliCommand.Companion.echo
+import shark.SharkCliCommand.Companion.retrieveHeapDumpFile
+import shark.SharkCliCommand.Companion.sharkCliParams
+import java.io.File
+
+class AnalyzeCommand : CliktCommand(
+  name = "analyze",
+  help = "Analyze a heap dump."
+) {
+
+  override fun run() {
+    val params = context.sharkCliParams
+    analyze(retrieveHeapDumpFile(params), params.obfuscationMappingPath)
+  }
+
+  companion object {
+    fun CliktCommand.analyze(
+      heapDumpFile: File,
+      proguardMappingFile: File?
+    ) {
+      val proguardMapping = proguardMappingFile?.let {
+        ProguardMappingReader(it.inputStream()).readProguardMapping()
+      }
+      val objectInspectors = AndroidObjectInspectors.appDefaults.toMutableList()
+
+      val listener = OnAnalysisProgressListener { step ->
+        SharkLog.d { "Analysis in progress, working on: ${step.name}" }
+      }
+
+      val heapAnalyzer = HeapAnalyzer(listener)
+      SharkLog.d { "Analyzing heap dump $heapDumpFile" }
+
+      val heapAnalysis = heapAnalyzer.analyze(
+        heapDumpFile = heapDumpFile,
+        leakingObjectFinder = FilteringLeakingObjectFinder(
+          AndroidObjectInspectors.appLeakingObjectFilters
+        ),
+        referenceMatchers = AndroidReferenceMatchers.appDefaults,
+        computeRetainedHeapSize = true,
+        objectInspectors = objectInspectors,
+        proguardMapping = proguardMapping,
+        metadataExtractor = AndroidMetadataExtractor
+      )
+      echo(heapAnalysis)
+    }
+  }
+}
diff --git a/shark-cli/src/main/java/shark/DeobfuscateHprofCommand.kt b/shark-cli/src/main/java/shark/DeobfuscateHprofCommand.kt
new file mode 100644
index 00000000..52b69653
--- /dev/null
+++ b/shark-cli/src/main/java/shark/DeobfuscateHprofCommand.kt
@@ -0,0 +1,25 @@
+package shark
+
+import com.github.ajalt.clikt.core.CliktCommand
+import com.github.ajalt.clikt.core.PrintMessage
+import shark.SharkCliCommand.Companion.retrieveHeapDumpFile
+import shark.SharkCliCommand.Companion.sharkCliParams
+
+class DeobfuscateHprofCommand : CliktCommand(
+  name = "deobfuscate-hprof",
+  help = "Deobfuscate the provided heap dump and generate a new \"-deobfuscated.hprof\" file."
+) {
+
+  override fun run() {
+    val params = context.sharkCliParams
+    val obfuscationMappingFile = params.obfuscationMappingPath
+      ?: throw PrintMessage("Error: Missing obfuscation mapping file")
+    val heapDumpFile = retrieveHeapDumpFile(params)
+    SharkLog.d { "Deobfuscating heap dump $heapDumpFile" }
+    val proguardMapping =
+      ProguardMappingReader(obfuscationMappingFile.inputStream()).readProguardMapping()
+    val deobfuscator = HprofDeobfuscator()
+    val outputFile = deobfuscator.deobfuscate(proguardMapping, heapDumpFile)
+    echo("Created deobfuscated hprof to $outputFile")
+  }
+}
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/DumpProcessCommand.kt b/shark-cli/src/main/java/shark/DumpProcessCommand.kt
new file mode 100644
index 00000000..10ea5235
--- /dev/null
+++ b/shark-cli/src/main/java/shark/DumpProcessCommand.kt
@@ -0,0 +1,127 @@
+package shark
+
+import com.github.ajalt.clikt.core.CliktCommand
+import com.github.ajalt.clikt.core.PrintMessage
+import com.github.ajalt.clikt.core.UsageError
+import shark.SharkCliCommand.Companion.echo
+import shark.SharkCliCommand.Companion.retrieveHeapDumpFile
+import shark.SharkCliCommand.Companion.runCommand
+import shark.SharkCliCommand.Companion.sharkCliParams
+import shark.SharkCliCommand.HeapDumpSource.ProcessSource
+import java.io.File
+import java.text.SimpleDateFormat
+import java.util.Date
+import java.util.Locale
+
+class DumpProcessCommand : CliktCommand(
+  name = "dump-process",
+  help = "Dump the heap and pull the hprof file."
+) {
+
+  override fun run() {
+    val params = context.sharkCliParams
+    if (params.source !is ProcessSource) {
+      throw UsageError("dump-process must be used with --process")
+    }
+    val file = retrieveHeapDumpFile(params)
+    echo("Pulled heap dump to $file")
+  }
+
+  companion object {
+
+    private val SPACE_PATTERN = Regex("\\s+")
+
+    @Suppress("ThrowsCount")
+    fun CliktCommand.dumpHeap(
+      processNameParam: String,
+      maybeDeviceId: String?
+    ): File {
+      val workingDirectory = File(System.getProperty("user.dir"))
+
+      val deviceList = runCommand(workingDirectory, "adb", "devices")
+
+      val connectedDevices = deviceList.lines()
+        .drop(1)
+        .filter { it.isNotBlank() }
+        .map { SPACE_PATTERN.split(it)[0] }
+
+      val deviceId = if (connectedDevices.isEmpty()) {
+        throw PrintMessage("Error: No device connected to adb")
+      } else if (maybeDeviceId == null) {
+        if (connectedDevices.size == 1) {
+          connectedDevices[0]
+        } else {
+          throw PrintMessage(
+            "Error: more than one device/emulator connected to adb," +
+              " use '--device ID' argument with one of $connectedDevices"
+          )
+        }
+      } else {
+        if (maybeDeviceId in connectedDevices) {
+          maybeDeviceId
+        } else {
+          throw PrintMessage(
+            "Error: device '$maybeDeviceId' not in the list of connected devices $connectedDevices"
+          )
+        }
+      }
+
+      val processList = runCommand(workingDirectory, "adb", "-s", deviceId, "shell", "ps")
+
+      val matchingProcesses = processList.lines()
+        .filter { it.contains(processNameParam) }
+        .map {
+          val columns = SPACE_PATTERN.split(it)
+          columns[8] to columns[1]
+        }
+
+      val (processName, processId) = when {
+        matchingProcesses.size == 1 -> {
+          matchingProcesses[0]
+        }
+        matchingProcesses.isEmpty() -> {
+          throw PrintMessage("Error: No process matching \"$processNameParam\"")
+        }
+        else -> {
+          matchingProcesses.firstOrNull { it.first == processNameParam }
+            ?: throw PrintMessage(
+              "Error: More than one process matches \"$processNameParam\" but none matches exactly: ${matchingProcesses.map { it.first }}"
+            )
+        }
+      }
+
+      val heapDumpFileName =
+        SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'-$processName.hprof'", Locale.US).format(
+          Date()
+        )
+
+      val heapDumpDevicePath = "/data/local/tmp/$heapDumpFileName"
+
+      echo(
+        "Dumping heap on $deviceId for process \"$processName\" with pid $processId to $heapDumpDevicePath"
+      )
+
+      runCommand(
+        workingDirectory, "adb", "-s", deviceId, "shell", "am", "dumpheap", processId,
+        heapDumpDevicePath
+      )
+
+      // Dump heap takes time but adb returns immediately.
+      Thread.sleep(5000)
+
+      SharkLog.d { "Pulling $heapDumpDevicePath" }
+
+      val pullResult =
+        runCommand(workingDirectory, "adb", "-s", deviceId, "pull", heapDumpDevicePath)
+      SharkLog.d { pullResult }
+      SharkLog.d { "Removing $heapDumpDevicePath" }
+
+      runCommand(workingDirectory, "adb", "-s", deviceId, "shell", "rm", heapDumpDevicePath)
+
+      val heapDumpFile = File(workingDirectory, heapDumpFileName)
+      SharkLog.d { "Pulled heap dump to $heapDumpFile" }
+
+      return heapDumpFile
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/InteractiveCommand.kt b/shark-cli/src/main/java/shark/InteractiveCommand.kt
new file mode 100644
index 00000000..458fecef
--- /dev/null
+++ b/shark-cli/src/main/java/shark/InteractiveCommand.kt
@@ -0,0 +1,608 @@
+package shark
+
+import com.github.ajalt.clikt.core.CliktCommand
+import com.github.ajalt.clikt.core.PrintMessage
+import jline.console.ConsoleReader
+import jline.console.UserInterruptException
+import jline.console.completer.CandidateListCompletionHandler
+import jline.console.completer.StringsCompleter
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.InteractiveCommand.COMMAND.ANALYZE
+import shark.InteractiveCommand.COMMAND.ARRAY
+import shark.InteractiveCommand.COMMAND.CLASS
+import shark.InteractiveCommand.COMMAND.Companion.matchesCommand
+import shark.InteractiveCommand.COMMAND.DETAILED_PATH_TO_INSTANCE
+import shark.InteractiveCommand.COMMAND.EXIT
+import shark.InteractiveCommand.COMMAND.HELP
+import shark.InteractiveCommand.COMMAND.INSTANCE
+import shark.InteractiveCommand.COMMAND.PATH_TO_INSTANCE
+import shark.SharkCliCommand.Companion.echoNewline
+import shark.SharkCliCommand.Companion.retrieveHeapDumpFile
+import shark.SharkCliCommand.Companion.sharkCliParams
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+import java.io.File
+import java.util.Locale
+
+class InteractiveCommand : CliktCommand(
+  name = "interactive",
+  help = "Explore a heap dump."
+) {
+
+  enum class COMMAND(
+    val commandName: String,
+    val suffix: String = "",
+    val help: String
+  ) {
+    ANALYZE(
+      commandName = "analyze",
+      help = "Analyze the heap dump."
+    ),
+    CLASS(
+      commandName = "class",
+      suffix = "NAME@ID",
+      help = "Show class with a matching NAME and Object ID."
+    ),
+    INSTANCE(
+      commandName = "instance",
+      suffix = "CLASS_NAME@ID",
+      help = "Show instance with a matching CLASS_NAME and Object ID."
+    ),
+    ARRAY(
+      commandName = "array",
+      suffix = "CLASS_NAME@ID",
+      help = "Show array instance with a matching CLASS_NAME and Object ID."
+    ),
+    PATH_TO_INSTANCE(
+      commandName = "->instance",
+      suffix = "CLASS_NAME@ID",
+      help = "Show path from GC Roots to instance."
+    ),
+    DETAILED_PATH_TO_INSTANCE(
+      commandName = "~>instance",
+      suffix = "CLASS_NAME@ID",
+      help = "Show path from GC Roots to instance, highlighting suspect references."
+    ),
+    HELP(
+      commandName = "help",
+      help = "Show this message."
+    ),
+    EXIT(
+      commandName = "exit",
+      help = "Exit this interactive prompt."
+    ),
+    ;
+
+    val pattern: String
+      get() = if (suffix.isEmpty()) commandName else "$commandName "
+
+    val patternHelp: String
+      get() = pattern + suffix
+
+    override fun toString() = commandName
+
+    companion object {
+      infix fun String.matchesCommand(command: COMMAND): Boolean {
+        return if (command.suffix.isEmpty()) {
+          this == command.commandName
+        } else {
+          startsWith(command.pattern)
+        }
+      }
+    }
+  }
+
+  override fun run() {
+    openHprof { graph, heapDumpFile ->
+      val console = setupConsole(graph)
+      var exit = false
+      while (!exit) {
+        val input = console.readCommand()
+        exit = handleCommand(input, heapDumpFile, graph)
+        echoNewline()
+      }
+    }
+  }
+
+  private fun openHprof(block: (HeapGraph, File) -> Unit) {
+    val params = context.sharkCliParams
+    val heapDumpFile = retrieveHeapDumpFile(params)
+    val obfuscationMappingPath = params.obfuscationMappingPath
+
+    val proguardMapping = obfuscationMappingPath?.let {
+      ProguardMappingReader(it.inputStream()).readProguardMapping()
+    }
+
+    heapDumpFile.openHeapGraph().use { graph ->
+      block(graph, heapDumpFile)
+    }
+  }
+
+  private fun setupConsole(graph: HeapGraph): ConsoleReader {
+    val console = ConsoleReader()
+    console.handleUserInterrupt = true
+
+    console.addCompleter(StringsCompleter(COMMAND.values().map { it.pattern }))
+    console.addCompleter { buffer, _, candidates ->
+      if (buffer != null) {
+        when {
+          buffer matchesCommand CLASS -> {
+            val matchingObjects = findMatchingObjects(buffer, graph.classes) {
+              it.name
+            }
+            candidates.addAll(matchingObjects.map { renderHeapObject(it) })
+          }
+          buffer matchesCommand INSTANCE -> {
+            val matchingObjects = findMatchingObjects(buffer, graph.instances) {
+              it.instanceClassSimpleName
+            }
+            candidates.addAll(matchingObjects.map { renderHeapObject(it) })
+          }
+          buffer matchesCommand PATH_TO_INSTANCE -> {
+            val matchingObjects = findMatchingObjects(buffer, graph.instances) {
+              it.instanceClassSimpleName
+            }
+            candidates.addAll(matchingObjects.map { "->${renderHeapObject(it)}" })
+          }
+          buffer matchesCommand DETAILED_PATH_TO_INSTANCE -> {
+            val matchingObjects = findMatchingObjects(buffer, graph.instances) {
+              it.instanceClassSimpleName
+            }
+            candidates.addAll(matchingObjects.map { "~>${renderHeapObject(it)}" })
+          }
+          buffer matchesCommand ARRAY -> {
+            val matchingObjects =
+              findMatchingObjects(buffer, graph.primitiveArrays + graph.objectArrays) {
+                if (it is HeapPrimitiveArray) {
+                  it.arrayClassName
+                } else {
+                  (it as HeapObjectArray).arrayClassSimpleName
+                }
+              }
+            candidates.addAll(matchingObjects.map { renderHeapObject(it) })
+          }
+        }
+      }
+      if (candidates.isEmpty()) -1 else 0
+    }
+    val completionHandler = CandidateListCompletionHandler()
+    completionHandler.printSpaceAfterFullCompletion = false
+    console.completionHandler = completionHandler
+    console.prompt = "Enter command [help]:\n"
+    return console
+  }
+
+  private fun ConsoleReader.readCommand(): String? {
+    val input = try {
+      readLine()
+    } catch (ignored: UserInterruptException) {
+      throw PrintMessage("Program interrupted by user")
+    }
+    echoNewline()
+    return input
+  }
+
+  private fun handleCommand(
+    input: String?,
+    heapDumpFile: File,
+    graph: HeapGraph
+  ): Boolean {
+    when {
+      input == null -> throw PrintMessage("End Of File was encountered")
+      input.isBlank() || input matchesCommand HELP -> echoHelp()
+      input matchesCommand EXIT -> return true
+      input matchesCommand ANALYZE -> analyze(heapDumpFile, graph)
+      input matchesCommand PATH_TO_INSTANCE -> {
+        analyzeMatchingObjects(heapDumpFile, input, graph.instances, false) {
+          it.instanceClassSimpleName
+        }
+      }
+      input matchesCommand DETAILED_PATH_TO_INSTANCE -> {
+        analyzeMatchingObjects(heapDumpFile, input, graph.instances, true) {
+          it.instanceClassSimpleName
+        }
+      }
+      input matchesCommand CLASS -> {
+        renderMatchingObjects(input, graph.classes) {
+          it.name
+        }
+      }
+      input matchesCommand INSTANCE -> {
+        renderMatchingObjects(input, graph.instances) {
+          it.instanceClassSimpleName
+        }
+      }
+      input matchesCommand ARRAY -> {
+        renderMatchingObjects(input, graph.primitiveArrays + graph.objectArrays) {
+          if (it is HeapPrimitiveArray) {
+            it.arrayClassName
+          } else {
+            (it as HeapObjectArray).arrayClassSimpleName
+          }
+        }
+      }
+      else -> {
+        echo("Unknown command [$input].\n")
+        echoHelp()
+      }
+    }
+    return false
+  }
+
+  private fun echoHelp() {
+    echo("Available commands:")
+    val longestPatternHelp = COMMAND.values()
+      .map { it.patternHelp }.maxBy { it.length }!!.length
+    COMMAND.values()
+      .forEach { command ->
+        val patternHelp = command.patternHelp
+        val extraSpaceCount = (longestPatternHelp - patternHelp.length)
+        val extraSpaces = " ".repeat(extraSpaceCount)
+        println("  $patternHelp$extraSpaces  ${command.help}")
+      }
+  }
+
+  private fun <T : HeapObject> renderMatchingObjects(
+    pattern: String,
+    objects: Sequence<T>,
+    namer: (T) -> String
+  ) {
+    val matchingObjects = findMatchingObjects(pattern, objects, namer)
+    when {
+      matchingObjects.size == 1 -> {
+        matchingObjects.first()
+          .show()
+      }
+      matchingObjects.isNotEmpty() -> {
+        matchingObjects.forEach { heapObject ->
+          echo(renderHeapObject(heapObject))
+        }
+      }
+      else -> {
+        echo("No object found matching [$pattern]")
+      }
+    }
+  }
+
+  private fun <T : HeapObject> analyzeMatchingObjects(
+    heapDumpFile: File,
+    pattern: String,
+    objects: Sequence<T>,
+    showDetails: Boolean,
+    namer: (T) -> String
+  ) {
+    val matchingObjects = findMatchingObjects(pattern, objects, namer)
+    when {
+      matchingObjects.size == 1 -> {
+        val heapObject = matchingObjects.first()
+        analyze(heapDumpFile, heapObject.graph, showDetails, heapObject.objectId)
+      }
+      matchingObjects.isNotEmpty() -> {
+        matchingObjects.forEach { heapObject ->
+          echo(if (showDetails) "~>" else "->" + renderHeapObject(heapObject))
+        }
+      }
+      else -> {
+        echo("No object found matching [$pattern]")
+      }
+    }
+  }
+
+  private fun <T : HeapObject> findMatchingObjects(
+    pattern: String,
+    objects: Sequence<T>,
+    namer: (T) -> String
+  ): List<T> {
+    val firstSpaceIndex = pattern.indexOf(' ')
+    val contentStartIndex = firstSpaceIndex + 1
+    val nextSpaceIndex = pattern.indexOf(' ', contentStartIndex)
+    val endIndex = if (nextSpaceIndex != -1) nextSpaceIndex else pattern.length
+    val content = pattern.substring(contentStartIndex, endIndex)
+    val identifierIndex = content.indexOf('@')
+    val (classNamePart, objectIdStart) = if (identifierIndex == -1) {
+      content to null
+    } else {
+      content.substring(0, identifierIndex) to
+        content.substring(identifierIndex + 1)
+    }
+
+    val objectId = objectIdStart?.toLongOrNull()
+    val checkObjectId = objectId != null
+    val matchingObjects = objects
+      .filter {
+        classNamePart in namer(it) &&
+          (!checkObjectId ||
+            it.objectId.toString().startsWith(objectIdStart!!))
+      }
+      .toList()
+
+    if (objectIdStart != null) {
+      val exactMatchingByObjectId = matchingObjects.firstOrNull { objectId == it.objectId }
+      if (exactMatchingByObjectId != null) {
+        return listOf(exactMatchingByObjectId)
+      }
+    }
+
+    val exactMatchingByName = matchingObjects.filter { classNamePart == namer(it) }
+
+    return exactMatchingByName.ifEmpty {
+      matchingObjects
+    }
+  }
+
+  private fun HeapObject.show() {
+    when (this) {
+      is HeapInstance -> showInstance()
+      is HeapClass -> showClass()
+      is HeapObjectArray -> showObjectArray()
+      is HeapPrimitiveArray -> showPrimitiveArray()
+    }
+  }
+
+  private fun HeapInstance.showInstance() {
+    echo(renderHeapObject(this))
+    echo("  Instance of ${renderHeapObject(instanceClass)}")
+
+    val fieldsPerClass = readFields()
+      .toList()
+      .groupBy { it.declaringClass }
+      .toList()
+      .filter { it.first.name != "java.lang.Object" }
+      .reversed()
+
+    fieldsPerClass.forEach { (heapClass, fields) ->
+      echo("  Fields from ${renderHeapObject(heapClass)}")
+      fields.forEach { field ->
+        echo("    ${field.name} = ${renderHeapValue(field.value)}")
+      }
+    }
+  }
+
+  private fun HeapClass.showClass() {
+    echo(this@InteractiveCommand.renderHeapObject(this))
+    val superclass = superclass
+    if (superclass != null) {
+      echo("  Extends ${renderHeapObject(superclass)}")
+    }
+
+    val staticFields = readStaticFields()
+      .filter { field ->
+        !field.name.startsWith(
+          "\$class\$"
+        ) && field.name != "\$classOverhead"
+      }
+      .toList()
+    if (staticFields.isNotEmpty()) {
+      echo("  Static fields")
+      staticFields
+        .forEach { field ->
+          echo("    static ${field.name} = ${renderHeapValue(field.value)}")
+        }
+    }
+
+    val instances = when {
+      isPrimitiveArrayClass -> primitiveArrayInstances
+      isObjectArrayClass -> objectArrayInstances
+      else -> instances
+    }.toList()
+    if (instances.isNotEmpty()) {
+      echo("  ${instances.size} instance" + if (instances.size != 1) "s" else "")
+      instances.forEach { arrayOrInstance ->
+        echo("    ${renderHeapObject(arrayOrInstance)}")
+      }
+    }
+  }
+
+  private fun HeapObjectArray.showObjectArray() {
+    val elements = readElements()
+    echo(renderHeapObject(this))
+    echo("  Instance of ${renderHeapObject(arrayClass)}")
+    var repeatedValue: HeapValue? = null
+    var repeatStartIndex = 0
+    var lastIndex = 0
+    elements.forEachIndexed { index, element ->
+      lastIndex = index
+      if (repeatedValue == null) {
+        repeatedValue = element
+        repeatStartIndex = index
+      } else if (repeatedValue != element) {
+        val repeatEndIndex = index - 1
+        if (repeatStartIndex == repeatEndIndex) {
+          echo("  $repeatStartIndex = ${renderHeapValue(repeatedValue!!)}")
+        } else {
+          echo("  $repeatStartIndex..$repeatEndIndex = ${renderHeapValue(repeatedValue!!)}")
+        }
+        repeatedValue = element
+        repeatStartIndex = index
+      }
+    }
+    if (repeatedValue != null) {
+      if (repeatStartIndex == lastIndex) {
+        echo("  $repeatStartIndex = ${renderHeapValue(repeatedValue!!)}")
+      } else {
+        echo("  $repeatStartIndex..$lastIndex = ${renderHeapValue(repeatedValue!!)}")
+      }
+    }
+  }
+
+  private fun HeapPrimitiveArray.showPrimitiveArray() {
+    val record = readRecord()
+    echo(renderHeapObject(this))
+    echo("  Instance of ${renderHeapObject(arrayClass)}")
+
+    var repeatedValue: Any? = null
+    var repeatStartIndex = 0
+    var lastIndex = 0
+    val action: (Int, Any) -> Unit = { index, value ->
+      lastIndex = index
+      if (repeatedValue == null) {
+        repeatedValue = value
+        repeatStartIndex = index
+      } else if (repeatedValue != value) {
+        val repeatEndIndex = index - 1
+        if (repeatStartIndex == repeatEndIndex) {
+          echo("  $repeatStartIndex = $repeatedValue")
+        } else {
+          echo("  $repeatStartIndex..$repeatEndIndex = $repeatedValue")
+        }
+        repeatedValue = value
+        repeatStartIndex = index
+      }
+    }
+
+    when (record) {
+      is BooleanArrayDump -> record.array.forEachIndexed(action)
+      is CharArrayDump -> record.array.forEachIndexed(action)
+      is FloatArrayDump -> record.array.forEachIndexed(action)
+      is DoubleArrayDump -> record.array.forEachIndexed(action)
+      is ByteArrayDump -> record.array.forEachIndexed(action)
+      is ShortArrayDump -> record.array.forEachIndexed(action)
+      is IntArrayDump -> record.array.forEachIndexed(action)
+      is LongArrayDump -> record.array.forEachIndexed(action)
+    }
+    if (repeatedValue != null) {
+      if (repeatStartIndex == lastIndex) {
+        echo("  $repeatStartIndex = $repeatedValue")
+      } else {
+        echo("  $repeatStartIndex..$lastIndex = $repeatedValue")
+      }
+    }
+  }
+
+  private fun renderHeapValue(heapValue: HeapValue): String {
+    return when (val holder = heapValue.holder) {
+      is ReferenceHolder -> {
+        when {
+          holder.isNull -> "null"
+          !heapValue.graph.objectExists(holder.value) -> "@${holder.value} object not found"
+          else -> {
+            val heapObject = heapValue.asObject!!
+            renderHeapObject(heapObject)
+          }
+        }
+      }
+      is BooleanHolder -> holder.value.toString()
+      is CharHolder -> holder.value.toString()
+      is FloatHolder -> holder.value.toString()
+      is DoubleHolder -> holder.value.toString()
+      is ByteHolder -> holder.value.toString()
+      is ShortHolder -> holder.value.toString()
+      is IntHolder -> holder.value.toString()
+      is LongHolder -> holder.value.toString()
+    }
+  }
+
+  private fun renderHeapObject(heapObject: HeapObject): String {
+    return when (heapObject) {
+      is HeapClass -> {
+        val instanceCount = when {
+          heapObject.isPrimitiveArrayClass -> heapObject.primitiveArrayInstances
+          heapObject.isObjectArrayClass -> heapObject.objectArrayInstances
+          else -> heapObject.instances
+        }.count()
+        val plural = if (instanceCount != 1) "s" else ""
+        "$CLASS ${heapObject.name}@${heapObject.objectId} (${instanceCount} instance$plural)"
+      }
+      is HeapInstance -> {
+        val asJavaString = heapObject.readAsJavaString()
+
+        val value =
+          if (asJavaString != null) {
+            " \"${asJavaString}\""
+          } else ""
+
+        "$INSTANCE ${heapObject.instanceClassSimpleName}@${heapObject.objectId}$value"
+      }
+      is HeapObjectArray -> {
+        val className = heapObject.arrayClassSimpleName.removeSuffix("[]")
+        "$ARRAY $className[${heapObject.readElements().count()}]@${heapObject.objectId}"
+      }
+      is HeapPrimitiveArray -> {
+        val record = heapObject.readRecord()
+        val primitiveName = heapObject.primitiveType.name.toLowerCase(Locale.US)
+        "$ARRAY $primitiveName[${record.size}]@${heapObject.objectId}"
+      }
+    }
+  }
+
+  private fun analyze(
+    heapDumpFile: File,
+    graph: HeapGraph,
+    showDetails: Boolean = true,
+    leakingObjectId: Long? = null
+  ) {
+    if (leakingObjectId != null) {
+      if (!graph.objectExists(leakingObjectId)) {
+        echo("@$leakingObjectId not found")
+        return
+      } else {
+        val heapObject = graph.findObjectById(leakingObjectId)
+        if (heapObject !is HeapInstance) {
+          echo("${renderHeapObject(heapObject)} is not an instance")
+          return
+        }
+      }
+    }
+
+    val objectInspectors =
+      if (showDetails) AndroidObjectInspectors.appDefaults.toMutableList() else mutableListOf()
+
+    objectInspectors += ObjectInspector {
+      it.labels += renderHeapObject(it.heapObject)
+    }
+
+    val leakingObjectFinder = if (leakingObjectId == null) {
+      FilteringLeakingObjectFinder(
+        AndroidObjectInspectors.appLeakingObjectFilters
+      )
+    } else {
+      LeakingObjectFinder {
+        setOf(leakingObjectId)
+      }
+    }
+
+    val listener = OnAnalysisProgressListener { step ->
+      SharkLog.d { "Analysis in progress, working on: ${step.name}" }
+    }
+
+    val heapAnalyzer = HeapAnalyzer(listener)
+    SharkLog.d { "Analyzing heap dump $heapDumpFile" }
+
+    val heapAnalysis = heapAnalyzer.analyze(
+      heapDumpFile = heapDumpFile,
+      graph = graph,
+      leakingObjectFinder = leakingObjectFinder,
+      referenceMatchers = AndroidReferenceMatchers.appDefaults,
+      computeRetainedHeapSize = true,
+      objectInspectors = objectInspectors,
+      metadataExtractor = AndroidMetadataExtractor
+    )
+
+    if (leakingObjectId == null || heapAnalysis is HeapAnalysisFailure) {
+      echo(heapAnalysis)
+    } else {
+      val leakTrace = (heapAnalysis as HeapAnalysisSuccess).allLeaks.first()
+        .leakTraces.first()
+      echo(if (showDetails) leakTrace else leakTrace.toSimplePathString())
+    }
+  }
+}
diff --git a/shark-cli/src/main/java/shark/Main.kt b/shark-cli/src/main/java/shark/Main.kt
new file mode 100644
index 00000000..88cf53c5
--- /dev/null
+++ b/shark-cli/src/main/java/shark/Main.kt
@@ -0,0 +1,13 @@
+package shark
+
+import com.github.ajalt.clikt.core.subcommands
+
+fun main(args: Array<String>) =
+  SharkCliCommand().subcommands(
+    InteractiveCommand(),
+    AnalyzeCommand(),
+    Neo4JCommand(),
+    DumpProcessCommand(),
+    StripHprofCommand(),
+    DeobfuscateHprofCommand()
+  ).main(args)
diff --git a/shark-cli/src/main/java/shark/Neo4JCommand.kt b/shark-cli/src/main/java/shark/Neo4JCommand.kt
new file mode 100644
index 00000000..8dd50dcb
--- /dev/null
+++ b/shark-cli/src/main/java/shark/Neo4JCommand.kt
@@ -0,0 +1,759 @@
+package shark
+
+import com.github.ajalt.clikt.core.Abort
+import com.github.ajalt.clikt.core.CliktCommand
+import com.github.ajalt.clikt.output.TermUi
+import com.github.ajalt.clikt.parameters.arguments.argument
+import com.github.ajalt.clikt.parameters.arguments.optional
+import com.github.ajalt.clikt.parameters.types.file
+import java.io.File
+import java.io.PrintWriter
+import java.io.StringWriter
+import java.lang.ref.PhantomReference
+import java.lang.ref.SoftReference
+import java.lang.ref.WeakReference
+import java.util.regex.Pattern
+import jline.console.ConsoleReader
+import org.neo4j.configuration.GraphDatabaseSettings
+import org.neo4j.configuration.connectors.BoltConnector
+import org.neo4j.configuration.helpers.SocketAddress
+import org.neo4j.dbms.api.DatabaseManagementServiceBuilder
+import org.neo4j.graphdb.Entity
+import org.neo4j.graphdb.GraphDatabaseService
+import org.neo4j.graphdb.Path
+import org.neo4j.graphdb.Relationship
+import org.neo4j.graphdb.Transaction
+import org.neo4j.kernel.api.procedure.GlobalProcedures
+import org.neo4j.kernel.internal.GraphDatabaseAPI
+import org.neo4j.logging.Level
+import org.neo4j.procedure.UserFunction
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.LeakTraceObject.LeakingStatus.LEAKING
+import shark.LeakTraceObject.LeakingStatus.NOT_LEAKING
+import shark.LeakTraceObject.LeakingStatus.UNKNOWN
+import shark.SharkCliCommand.Companion.echo
+import shark.SharkCliCommand.Companion.retrieveHeapDumpFile
+import shark.SharkCliCommand.Companion.sharkCliParams
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+
+
+/**
+ * Example commands:
+ *
+ * MATCH (roots: GcRoots)
+ * RETURN roots
+ *
+ * MATCH (activity: Instance) -[:CLASS|SUPER*1..]-> (c:Class {className: "android.app.Activity"})
+ * RETURN activity
+ *
+ * MATCH (activity: Instance) -[:CLASS|SUPER*1..]-> (c:Class {className: "android.app.Activity"})
+ * WHERE "android.app.Activity.mDestroyed = true" in activity.fields
+ * RETURN activity
+ *
+ * MATCH (roots: GcRoots)
+ * MATCH (activity: Instance) -[:CLASS|SUPER*1..]->(c:Class {className: "android.app.Activity"})
+ * WHERE "android.app.Activity.mDestroyed = true" in activity.fields
+ * RETURN shortestPath((roots)-[:ROOT|REF*]->(activity))
+ */
+@SuppressWarnings("MaxLineLength", "LongMethod")
+class Neo4JCommand : CliktCommand(
+  name = "neo4j",
+  help = "Convert heap dump to Neo4j database"
+) {
+
+  private val optionalDbFolder by argument("NEO4J_DATABASE_DIRECTORY").file(
+    exists = true,
+    fileOkay = false,
+    folderOkay = true,
+    writable = true
+  ).optional()
+
+  override fun run() {
+    val params = context.sharkCliParams
+    val heapDumpFile = retrieveHeapDumpFile(params)
+
+    val dbFolder = optionalDbFolder ?: heapDumpFile.parentFile
+
+    dump(heapDumpFile, dbFolder, params.obfuscationMappingPath)
+  }
+
+  companion object {
+    val REFERENCE = "REF"
+    val WEAK_REFERENCE = "WEAK_REF"
+    val SOFT_REFERENCE = "SOFT_REF"
+    val PHANTOM_REFERENCE = "PHANTOM_REF"
+
+    fun CliktCommand.dump(
+      heapDumpFile: File,
+      dbParentFolder: File,
+      proguardMappingFile: File?
+    ) {
+      val proguardMapping = proguardMappingFile?.let {
+        ProguardMappingReader(it.inputStream()).readProguardMapping()
+      }
+
+      val name = heapDumpFile.name.substringBeforeLast(".hprof")
+      val dbFolder = File(dbParentFolder, name)
+
+      if (dbFolder.exists()) {
+        val continueImport = TermUi.confirm(
+          "Directory $dbFolder already exists, delete it and continue?",
+          default = true,
+          abort = true
+        ) ?: false
+
+        if (!continueImport) {
+          throw Abort()
+        }
+        echo("Deleting $dbFolder")
+        dbFolder.deleteRecursively()
+      }
+
+      // Ideally we'd get a random free port. We could do this by using
+      // `new SocketAddress("localhost", 0)` but we wouldn't be able to retrieve the port via Neo4j
+      // means afterwards (it would indicate 0 as ephemeral port)
+      val boltListenPort = 2929
+
+      echo("Creating db in $dbFolder")
+      // Note: we're creating an embedded neo4j rather than connecting to a real neo4j instance,
+      // mostly out of convenience (ie this is a demo that works without installing anything)
+      val managementService =
+        DatabaseManagementServiceBuilder(dbFolder.toPath().normalize())
+          .setConfig(BoltConnector.enabled, true)
+          .setConfig(BoltConnector.listen_address, SocketAddress("localhost", boltListenPort))
+          .setConfig(GraphDatabaseSettings.store_internal_log_level, Level.DEBUG)
+          .build()
+      val dbService = managementService.database("neo4j")
+      val api = dbService as GraphDatabaseAPI
+      val registry = api.dependencyResolver.resolveDependency(GlobalProcedures::class.java)
+      registry.registerFunction(FindLeakPaths::class.java)
+
+      echo("Done with creating empty db, now importing heap dump")
+      heapDumpFile.openHeapGraph(proguardMapping).use { graph ->
+
+        val total = graph.objectCount
+
+
+        dbService.executeTransactionally("create constraint for (object:Object) require object.objectId is unique")
+        dbService.executeTransactionally("create constraint for (class:Class) require class.objectId is unique")
+        dbService.executeTransactionally("create constraint for (instance:Instance) require instance.objectId is unique")
+        dbService.executeTransactionally("create constraint for (array:ObjectArray) require array.objectId is unique")
+        dbService.executeTransactionally("create constraint for (array:PrimitiveArray) require array.objectId is unique")
+        // TODO Split in several transactions when reaching a predefined threshold.
+
+        dumpNodes(dbService, graph, total)
+        dumpClassHierarchy(dbService, graph, total)
+        dumpEdges(dbService, graph, total)
+        dumpLabels(dbService, graph, total)
+        dumpGcRoots(dbService, graph)
+      }
+
+      echo("Retrieving server bolt port...")
+
+      // TODO Unclear why we need to query the port again?
+      val boltPort = dbService.executeTransactionally(
+        "CALL dbms.listConfig() yield name, value " +
+          "WHERE name = 'dbms.connector.bolt.listen_address' " +
+          "RETURN value", mapOf()
+      ) { result ->
+        val listenAddress = result.next()["value"] as String
+        val pattern = Pattern.compile("(?:\\w+:)?(\\d+)")
+        val matcher = pattern.matcher(listenAddress)
+        if (!matcher.matches()) {
+          error("Could not extract bolt port from [$listenAddress]")
+        }
+        matcher.toMatchResult().group(1)
+      }
+
+      val browserUrl = "http://browser.graphapp.io/?dbms=bolt://localhost:$boltPort"
+      echo("Opening: $browserUrl")
+      Runtime.getRuntime().exec("open $browserUrl")
+      ConsoleReader().readLine("Press ENTER to shut down Neo4j server")
+      echo("Shutting down...")
+      managementService.shutdown()
+    }
+
+    private fun CliktCommand.dumpGcRoots(
+      dbService: GraphDatabaseService,
+      graph: CloseableHeapGraph
+    ) {
+      val gcRootsTx = dbService.beginTx()
+      echo("Progress gc roots: 0%")
+      var lastPct = 0
+      val gcRootTotal = graph.gcRoots.size
+
+      // A root for all gc roots that makes it easy to query starting from that single root.
+      gcRootsTx.execute("create (:GcRoots {name:\"GC roots\", leakingStatus:\"${NOT_LEAKING.name}\"})")
+
+      graph.gcRoots.forEachIndexed { index, gcRoot ->
+        val pct = ((index * 10f) / gcRootTotal).toInt()
+        if (pct != lastPct) {
+          lastPct = pct
+          echo("Progress gc roots: ${pct * 10}%")
+        }
+        gcRootsTx.execute(
+          "match (roots:GcRoots), (object:Object{objectId:\$objectId}) create (roots)-[:ROOT]->(:GcRoot {type:\$type})-[:ROOT]->(object)",
+          mapOf(
+            "objectId" to gcRoot.id,
+            "type" to gcRoot::class.java.simpleName
+          )
+        )
+      }
+      echo("Progress gc roots: 100%, committing transaction")
+      gcRootsTx.commit()
+    }
+
+    private fun CliktCommand.dumpLabels(
+      dbService: GraphDatabaseService,
+      graph: CloseableHeapGraph,
+      total: Int
+    ) {
+      val labelsTx = dbService.beginTx()
+      echo("Progress labels: 0%")
+      var lastPct = 0
+      val inspectors = AndroidObjectInspectors.appDefaults
+      val leakFilters = ObjectInspectors.jdkLeakingObjectFilters
+
+      graph.objects.forEachIndexed { index, heapObject ->
+        val pct = ((index * 10f) / total).toInt()
+        if (pct != lastPct) {
+          lastPct = pct
+          echo("Progress labels: ${pct * 10}%")
+        }
+
+        val leaked = leakFilters.any { filter ->
+          filter.isLeakingObject(heapObject)
+        }
+
+        val reporter = ObjectReporter(heapObject)
+        inspectors.forEach { inspector ->
+          inspector.inspect(reporter)
+        }
+
+        // Cribbed from shark.HeapAnalyzer.resolveStatus
+        var status = UNKNOWN
+        var reason = ""
+        if (reporter.notLeakingReasons.isNotEmpty()) {
+          status = NOT_LEAKING
+          reason = reporter.notLeakingReasons.joinToString(" and ")
+        }
+        val leakingReasons = reporter.leakingReasons
+        if (leakingReasons.isNotEmpty()) {
+          val winReasons = leakingReasons.joinToString(" and ")
+          // Conflict
+          if (status == NOT_LEAKING) {
+            reason += ". Conflicts with $winReasons"
+          } else {
+            status = LEAKING
+            reason = winReasons
+          }
+        }
+
+        labelsTx.execute(
+          "match (node:Object{objectId:\$objectId})" +
+            " set node.leakingStatus = \$leakingStatus, node.leakingStatusReason = \$leakingStatusReason",
+          mapOf(
+            "objectId" to heapObject.objectId,
+            "leakingStatus" to status.name,
+            "leakingStatusReason" to reason
+          )
+        )
+
+        if (reporter.labels.isNotEmpty()) {
+          labelsTx.execute(
+            "match (node:Object{objectId:\$objectId})" +
+              " set node.labels = \$labels",
+            mapOf(
+              "objectId" to heapObject.objectId,
+              "labels" to reporter.labels,
+            )
+          )
+        }
+
+        if (leaked) {
+          labelsTx.execute(
+            "match (node:Object{objectId:\$objectId})" +
+              " set node.leaked = true",
+            mapOf(
+              "objectId" to heapObject.objectId,
+            )
+          )
+        }
+      }
+      echo("Progress labels: 100%, committing transaction")
+      labelsTx.commit()
+    }
+
+    private fun CliktCommand.dumpEdges(
+      dbService: GraphDatabaseService,
+      graph: CloseableHeapGraph,
+      total: Int
+    ) {
+      val edgeTx = dbService.beginTx()
+      echo("Progress edges: 0%")
+      var lastPct = 0
+      graph.objects.forEachIndexed { index, heapObject ->
+        val pct = ((index * 10f) / total).toInt()
+        if (pct != lastPct) {
+          lastPct = pct
+          echo("Progress edges: ${pct * 10}%")
+        }
+        when (heapObject) {
+          is HeapClass -> {
+            val fields = heapObject.readStaticFields().mapNotNull { field ->
+              if (field.value.isNonNullReference) {
+                mapOf(
+                  "targetObjectId" to field.value.asObjectId!!,
+                  "name" to field.name
+                )
+              } else {
+                null
+              }
+            }.toList()
+
+            edgeTx.execute(
+              "unwind \$fields as field" +
+                " match (source:Object{objectId:\$sourceObjectId}), (target:Object{objectId:field.targetObjectId})" +
+                " create (source)-[:$REFERENCE {name:field.name}]->(target)", mapOf(
+                "sourceObjectId" to heapObject.objectId,
+                "fields" to fields
+              )
+            )
+
+            val primitiveAndNullFields = heapObject.readStaticFields().mapNotNull { field ->
+              if (!field.value.isNonNullReference) {
+                "${field.name}: ${field.value.heapValueAsString()}"
+              } else {
+                null
+              }
+            }.toList()
+
+            edgeTx.execute(
+              "match (node:Object{objectId:\$objectId})" +
+                " set node.staticFields = \$values",
+              mapOf(
+                "objectId" to heapObject.objectId,
+                "values" to primitiveAndNullFields
+              )
+            )
+          }
+          is HeapInstance -> {
+            val fields = heapObject.readFields().mapNotNull { field ->
+              if (field.value.isNonNullReference) {
+                mapOf(
+                  "targetObjectId" to field.value.asObjectId!!,
+                  "name" to "${field.declaringClass.name}.${field.name}"
+                )
+              } else {
+                null
+              }
+            }.toList()
+
+            val (updatedFields, referentField, refType) = when {
+              heapObject instanceOf WeakReference::class -> {
+                val referentField = heapObject["java.lang.ref.Reference", "referent"]
+                Triple(
+                  fields.filter { it["name"] != "java.lang.ref.Reference.referent" },
+                  referentField,
+                  WEAK_REFERENCE
+                )
+              }
+              heapObject instanceOf SoftReference::class -> {
+                val referentField = heapObject["java.lang.ref.Reference", "referent"]
+                Triple(
+                  fields.filter { it["name"] != "java.lang.ref.Reference.referent" },
+                  referentField,
+                  SOFT_REFERENCE
+                )
+              }
+              heapObject instanceOf PhantomReference::class -> {
+                val referentField = heapObject["java.lang.ref.Reference", "referent"]
+                Triple(
+                  fields.filter { it["name"] != "java.lang.ref.Reference.referent" },
+                  referentField,
+                  PHANTOM_REFERENCE
+                )
+              }
+              else -> Triple(fields, null, null)
+            }
+
+            edgeTx.execute(
+              "unwind \$fields as field" +
+                " match (source:Object{objectId:\$sourceObjectId}), (target:Object{objectId:field.targetObjectId})" +
+                " create (source)-[:$REFERENCE {name:field.name}]->(target)", mapOf(
+                "sourceObjectId" to heapObject.objectId,
+                "fields" to updatedFields
+              )
+            )
+
+            if (referentField != null) {
+              edgeTx.execute(
+                "match (source:Object{objectId:\$sourceObjectId}), (target:Object{objectId:\$targetObjectId})" +
+                  " create (source)-[:$refType {name:\"java.lang.ref.Reference.referent\"}]->(target)",
+                mapOf(
+                  "sourceObjectId" to heapObject.objectId,
+                  "targetObjectId" to referentField.value.asObjectId!!,
+                )
+              )
+            }
+
+            val primitiveAndNullFields = heapObject.readFields().mapNotNull { field ->
+              if (!field.value.isNonNullReference) {
+                "${field.declaringClass.name}.${field.name} = ${field.value.heapValueAsString()}"
+              } else {
+                null
+              }
+            }.toList()
+
+            edgeTx.execute(
+              "match (node:Object{objectId:\$objectId})" +
+                " set node.fields = \$values",
+              mapOf(
+                "objectId" to heapObject.objectId,
+                "values" to primitiveAndNullFields
+              )
+            )
+          }
+          is HeapObjectArray -> {
+            // TODO Add null values somehow?
+            val elements = heapObject.readRecord().elementIds.mapIndexed { arrayIndex, objectId ->
+              if (objectId != ValueHolder.NULL_REFERENCE) {
+                mapOf(
+                  "targetObjectId" to objectId,
+                  "name" to "[$arrayIndex]"
+                )
+              } else {
+                null
+              }
+            }.filterNotNull().toList()
+
+            edgeTx.execute(
+              "unwind \$elements as element" +
+                " match (source:Object{objectId:\$sourceObjectId}), (target:Object{objectId:element.targetObjectId})" +
+                " create (source)-[:$REFERENCE {name:element.name}]->(target)", mapOf(
+                "sourceObjectId" to heapObject.objectId,
+                "elements" to elements
+              )
+            )
+          }
+          is HeapPrimitiveArray -> {
+            when (val record = heapObject.readRecord()) {
+              is BooleanArrayDump -> {
+                edgeTx.execute(
+                  "match (node:Object{objectId:\$objectId})" +
+                    " set node.values = \$values",
+                  mapOf(
+                    "objectId" to heapObject.objectId,
+                    "values" to record.array.joinToString()
+                  )
+                )
+              }
+              is ByteArrayDump -> {
+                edgeTx.execute(
+                  "match (node:Object{objectId:\$objectId})" +
+                    " set node.values = \$values",
+                  mapOf(
+                    "objectId" to heapObject.objectId,
+                    "values" to record.array.joinToString()
+                  )
+                )
+              }
+              is CharArrayDump -> {
+                edgeTx.execute(
+                  "match (node:Object{objectId:\$objectId})" +
+                    " set node.values = \$values",
+                  mapOf(
+                    "objectId" to heapObject.objectId,
+                    "values" to record.array.joinToString()
+                  )
+                )
+              }
+              is DoubleArrayDump -> {
+                edgeTx.execute(
+                  "match (node:Object{objectId:\$objectId})" +
+                    " set node.values = \$values",
+                  mapOf(
+                    "objectId" to heapObject.objectId,
+                    "values" to record.array.joinToString()
+                  )
+                )
+              }
+              is FloatArrayDump -> {
+                edgeTx.execute(
+                  "match (node:Object{objectId:\$objectId})" +
+                    " set node.values = \$values",
+                  mapOf(
+                    "objectId" to heapObject.objectId,
+                    "values" to record.array.joinToString()
+                  )
+                )
+              }
+              is IntArrayDump -> {
+                edgeTx.execute(
+                  "match (node:Object{objectId:\$objectId})" +
+                    " set node.values = \$values",
+                  mapOf(
+                    "objectId" to heapObject.objectId,
+                    "values" to record.array.joinToString()
+                  )
+                )
+              }
+              is LongArrayDump -> {
+                edgeTx.execute(
+                  "match (node:Object{objectId:\$objectId})" +
+                    " set node.values = \$values",
+                  mapOf(
+                    "objectId" to heapObject.objectId,
+                    "values" to record.array.joinToString()
+                  )
+                )
+              }
+              is ShortArrayDump -> {
+                edgeTx.execute(
+                  "match (node:Object{objectId:\$objectId})" +
+                    " set node.values = \$values",
+                  mapOf(
+                    "objectId" to heapObject.objectId,
+                    "values" to record.array.joinToString()
+                  )
+                )
+              }
+            }
+          }
+        }
+      }
+      echo("Progress edges: 100%, committing transaction")
+      edgeTx.commit()
+    }
+
+    private fun CliktCommand.dumpNodes(
+      dbService: GraphDatabaseService,
+      graph: CloseableHeapGraph,
+      total: Int,
+    ) {
+      var lastPct = 0
+      val nodeTx = dbService.beginTx()
+      echo("Progress nodes: 0%")
+      graph.objects.forEachIndexed { index, heapObject ->
+        val pct = ((index * 10f) / total).toInt()
+        if (pct != lastPct) {
+          lastPct = pct
+          echo("Progress nodes: ${pct * 10}%")
+        }
+        when (heapObject) {
+          is HeapClass -> {
+            heapObject.readStaticFields().forEach { field ->
+              field.name
+              field.value
+            }
+            nodeTx.execute(
+              "create (:Object :Class {objectType: 'Class', name:\$name, className:\$className, objectId:\$objectId})",
+              mapOf(
+                "name" to heapObject.simpleName,
+                "className" to heapObject.name,
+                "objectId" to heapObject.objectId
+              )
+            )
+          }
+          is HeapInstance -> {
+            nodeTx.execute(
+              "create (:Object :Instance {objectType: 'Instance', name:\$name, className:\$className, objectId:\$objectId})",
+              mapOf(
+                "name" to "${heapObject.instanceClassSimpleName}@" + (heapObject.hexIdentityHashCode
+                  ?: heapObject.positiveObjectId),
+                "className" to heapObject.instanceClassName,
+                "objectId" to heapObject.objectId,
+              )
+            )
+          }
+          is HeapObjectArray -> {
+            nodeTx.execute(
+              "create (:Object :ObjectArray {objectType: 'ObjectArray', name:\$name," +
+                " className:\$className, objectId:\$objectId})",
+              mapOf(
+                "name" to "${heapObject.arrayClassSimpleName}[]@${heapObject.positiveObjectId}",
+                "className" to heapObject.arrayClassName,
+                "objectId" to heapObject.objectId,
+              )
+            )
+          }
+          is HeapPrimitiveArray -> {
+            nodeTx.execute(
+              "create (:Object :PrimitiveArray {objectType: 'PrimitiveArray', name:\$name," +
+                " className:\$className, objectId:\$objectId})",
+              mapOf(
+                "name" to "${heapObject.arrayClassName}@${heapObject.positiveObjectId}",
+                "className" to heapObject.arrayClassName,
+                "objectId" to heapObject.objectId
+              )
+            )
+          }
+        }
+      }
+      echo("Progress nodes: 100%, committing transaction")
+      nodeTx.commit()
+    }
+
+    private fun CliktCommand.dumpClassHierarchy(
+      dbService: GraphDatabaseService,
+      graph: CloseableHeapGraph,
+      total: Int
+    ) {
+      val classTx = dbService.beginTx()
+      echo("Progress class hierarchy: 0%")
+      var lastPct = 0
+      graph.objects.forEachIndexed { index, heapObject ->
+        val pct = ((index * 10f) / total).toInt()
+        if (pct != lastPct) {
+          lastPct = pct
+          echo("Progress class hierarchy: ${pct * 10}%")
+        }
+        when (heapObject) {
+          is HeapClass -> {
+            heapObject.superclass?.let { superclass ->
+              classTx.execute(
+                "match (superclass:Class{objectId:\$superclassObjectId}) ," +
+                  " (class:Class {objectId:\$objectId}) create (class) -[:SUPER]->(superclass)",
+                mapOf(
+                  "objectId" to heapObject.objectId,
+                  "superclassObjectId" to superclass.objectId
+                )
+              )
+            }
+          }
+          is HeapInstance -> {
+            classTx.execute(
+              "match (class:Class{objectId:\$classObjectId}) ," +
+                " (instance:Instance {objectId:\$objectId}) create (instance) -[:CLASS]->(class)",
+              mapOf(
+                "objectId" to heapObject.objectId,
+                "classObjectId" to heapObject.instanceClassId
+              )
+            )
+          }
+          is HeapObjectArray -> {
+            classTx.execute(
+              "match (class:Class{objectId:\$classObjectId}) ," +
+                " (array:ObjectArray {objectId:\$objectId}) create (array) -[:CLASS]->(class)",
+              mapOf(
+                "objectId" to heapObject.objectId,
+                "classObjectId" to heapObject.arrayClassId
+              )
+            )
+          }
+        }
+      }
+      echo("Progress class hierarchy: 100%, committing transaction")
+      classTx.commit()
+    }
+
+    fun HeapValue.heapValueAsString(): String {
+      return when (val heapValue = holder) {
+        is ReferenceHolder -> {
+          if (isNullReference) {
+            "null"
+          } else {
+            error("should not happen")
+          }
+        }
+        is BooleanHolder -> heapValue.value.toString()
+        is CharHolder -> heapValue.value.toString()
+        is FloatHolder -> heapValue.value.toString()
+        is DoubleHolder -> heapValue.value.toString()
+        is ByteHolder -> heapValue.value.toString()
+        is ShortHolder -> heapValue.value.toString()
+        is IntHolder -> heapValue.value.toString()
+        is LongHolder -> heapValue.value.toString()
+      }
+    }
+  }
+}
+
+class FindLeakPaths {
+
+  @org.neo4j.procedure.Context
+  lateinit var transaction: Transaction
+
+  @UserFunction("shark.leakPaths")
+  fun leakPaths(): List<Path> {
+    try {
+      val result = transaction.execute(
+        """
+      match (roots:GcRoots)
+      match (object:Object {leaked: true})
+        with shortestPath((roots)-[:ROOT|REF*]->(object)) as path
+        where reduce(
+            leakCount=0, n in nodes(path) | leakCount + case n.leaked when true then 1 else 0 end
+          ) = 1
+      return path
+      """.trimIndent()
+      )
+
+      return result.asSequence().map { row ->
+        val realPath = row["path"] as Path
+        DecoratedPath(realPath)
+      }.toList()
+    } catch (e: Throwable) {
+      TermUi.echo("failed to findLeakPaths: " + getStackTraceString(e))
+      throw e
+    }
+  }
+
+  private fun getStackTraceString(throwable: Throwable): String {
+    val stringWriter = StringWriter()
+    val printWriter = PrintWriter(stringWriter, false)
+    throwable.printStackTrace(printWriter)
+    printWriter.flush()
+    return stringWriter.toString()
+  }
+}
+
+class DecoratedPath(private val delegate: Path) : Path by delegate {
+
+  private val relationships by lazy {
+    // TODO Here we'll map a subset of relationships as one of not leaking, leak suspect, leaking.
+    // We can then add the "leaking reason" as an attribute of the relationship.
+    // Then we should remove these 2 from the full dump. We can find the leaking nodes early
+    // and set those attribute as part of node creation instead of a separate transaction.
+    // The mapping of relationships here can be down dy duplicating the logic in
+    // shark.HeapAnalyzer.computeLeakStatuses which goes through relationships and splits
+    // the path in 3 areas (not leaking, leak suspect, leaking).
+    delegate.relationships().toList()
+  }
+
+  override fun relationships(): Iterable<Relationship> {
+    return relationships
+  }
+
+  override fun reverseRelationships(): Iterable<Relationship> {
+    return relationships.asReversed()
+  }
+
+  override fun iterator(): MutableIterator<Entity> {
+    val nodeList = nodes().toList()
+    val relationshipsList = relationships
+    return (listOf(nodeList[0]) + relationshipsList.indices.flatMap { index ->
+      listOf(relationshipsList[index], nodeList[index])
+    }).toMutableList().iterator()
+  }
+}
diff --git a/shark-cli/src/main/java/shark/SharkCliCommand.kt b/shark-cli/src/main/java/shark/SharkCliCommand.kt
new file mode 100644
index 00000000..32d53d5a
--- /dev/null
+++ b/shark-cli/src/main/java/shark/SharkCliCommand.kt
@@ -0,0 +1,214 @@
+package shark
+
+import com.github.ajalt.clikt.core.CliktCommand
+import com.github.ajalt.clikt.core.CliktError
+import com.github.ajalt.clikt.core.Context
+import com.github.ajalt.clikt.core.UsageError
+import com.github.ajalt.clikt.output.TermUi
+import com.github.ajalt.clikt.parameters.groups.OptionGroup
+import com.github.ajalt.clikt.parameters.groups.cooccurring
+import com.github.ajalt.clikt.parameters.options.flag
+import com.github.ajalt.clikt.parameters.options.option
+import com.github.ajalt.clikt.parameters.options.required
+import com.github.ajalt.clikt.parameters.options.versionOption
+import com.github.ajalt.clikt.parameters.types.file
+import shark.DumpProcessCommand.Companion.dumpHeap
+import shark.SharkCliCommand.HeapDumpSource.HprofFileSource
+import shark.SharkCliCommand.HeapDumpSource.ProcessSource
+import shark.SharkLog.Logger
+import java.io.File
+import java.io.PrintWriter
+import java.io.StringWriter
+import java.util.Properties
+import java.util.concurrent.TimeUnit.SECONDS
+
+class SharkCliCommand : CliktCommand(
+  name = "shark-cli",
+  // This ASCII art is a remix of a shark from -David "TAZ" Baltazar- and chick from jgs.
+  help = """
+    |Version: $versionName
+    |
+    |```
+    |$S                ^`.                 .=""=.
+    |$S^_              \  \               / _  _ \
+    |$S\ \             {   \             |  d  b  |
+    |$S{  \           /     `~~~--__     \   /\   /
+    |$S{   \___----~~'              `~~-_/'-=\/=-'\,
+    |$S \                         /// a  `~.      \ \
+    |$S / /~~~~-, ,__.    ,      ///  __,,,,)      \ |
+    |$S \/      \/    `~~~;   ,---~~-_`/ \        / \/
+    |$S                  /   /            '.    .'
+    |$S                 '._.'             _|`~~`|_
+    |$S                                   /|\  /|\
+    |```
+    """.trimMargin()
+) {
+
+  private class ProcessOptions : OptionGroup() {
+    val processName by option(
+      "--process", "-p",
+      help = "Full or partial name of a process, e.g. \"example\" would match \"com.example.app\""
+    ).required()
+
+    val device by option(
+      "-d", "--device", metavar = "ID", help = "device/emulator id"
+    )
+  }
+
+  private val processOptions by ProcessOptions().cooccurring()
+
+  private val obfuscationMappingPath by option(
+    "-m", "--obfuscation-mapping", help = "path to obfuscation mapping file"
+  ).file()
+
+  private val verbose by option(
+    help = "provide additional details as to what shark-cli is doing"
+  ).flag("--no-verbose")
+
+  private val heapDumpFile by option("--hprof", "-h", help = "path to a .hprof file").file(
+    exists = true,
+    folderOkay = false,
+    readable = true
+  )
+
+  init {
+    versionOption(versionName)
+  }
+
+  class CommandParams(
+    val source: HeapDumpSource,
+    val obfuscationMappingPath: File?
+  )
+
+  sealed class HeapDumpSource {
+    class HprofFileSource(val file: File) : HeapDumpSource()
+    class ProcessSource(
+      val processName: String,
+      val deviceId: String?
+    ) : HeapDumpSource()
+  }
+
+  override fun run() {
+    if (verbose) {
+      setupVerboseLogger()
+    }
+    if (processOptions != null && heapDumpFile != null) {
+      throw UsageError("Option --process cannot be used with --hprof")
+    } else if (processOptions != null) {
+      context.sharkCliParams = CommandParams(
+        source = ProcessSource(processOptions!!.processName, processOptions!!.device),
+        obfuscationMappingPath = obfuscationMappingPath
+      )
+    } else if (heapDumpFile != null) {
+      context.sharkCliParams = CommandParams(
+        source = HprofFileSource(heapDumpFile!!),
+        obfuscationMappingPath = obfuscationMappingPath
+      )
+    } else {
+      throw UsageError("Must provide one of --process, --hprof")
+    }
+  }
+
+  private fun setupVerboseLogger() {
+    class CLILogger : Logger {
+
+      override fun d(message: String) {
+        echo(message)
+      }
+
+      override fun d(
+        throwable: Throwable,
+        message: String
+      ) {
+        d("$message\n${getStackTraceString(throwable)}")
+      }
+
+      private fun getStackTraceString(throwable: Throwable): String {
+        val stringWriter = StringWriter()
+        val printWriter = PrintWriter(stringWriter, false)
+        throwable.printStackTrace(printWriter)
+        printWriter.flush()
+        return stringWriter.toString()
+      }
+    }
+
+    SharkLog.logger = CLILogger()
+  }
+
+  companion object {
+    /** Zero width space */
+    private const val S = '\u200b'
+
+    var Context.sharkCliParams: CommandParams
+      get() {
+        var ctx: Context? = this
+        while (ctx != null) {
+          if (ctx.obj is CommandParams) return ctx.obj as CommandParams
+          ctx = ctx.parent
+        }
+        throw IllegalStateException("CommandParams not found in Context.obj")
+      }
+      set(value) {
+        obj = value
+      }
+
+    fun CliktCommand.retrieveHeapDumpFile(params: CommandParams): File {
+      return when (val source = params.source) {
+        is HprofFileSource -> source.file
+        is ProcessSource -> dumpHeap(source.processName, source.deviceId)
+      }
+    }
+
+    fun CliktCommand.echoNewline() {
+      echo("")
+    }
+
+    /**
+     * Copy of [CliktCommand.echo] to make it publicly visible and therefore accessible
+     * from [CliktCommand] extension functions
+     */
+    fun CliktCommand.echo(
+      message: Any?,
+      trailingNewline: Boolean = true,
+      err: Boolean = false,
+      lineSeparator: String = context.console.lineSeparator
+    ) {
+      TermUi.echo(message, trailingNewline, err, context.console, lineSeparator)
+    }
+
+    fun runCommand(
+      directory: File,
+      vararg arguments: String
+    ): String {
+      val process = ProcessBuilder(*arguments)
+        .directory(directory)
+        .start()
+        .also { it.waitFor(10, SECONDS) }
+
+      // See https://github.com/square/leakcanary/issues/1711
+      // On Windows, the process doesn't always exit; calling to readText() makes it finish, so
+      // we're reading the output before checking for the exit value
+      val output = process.inputStream.bufferedReader().readText()
+      if (process.exitValue() != 0) {
+        val command = arguments.joinToString(" ")
+        val errorOutput = process.errorStream.bufferedReader()
+          .readText()
+        throw CliktError(
+          "Failed command: '$command', error output:\n---\n$errorOutput---"
+        )
+      }
+      return output
+    }
+
+    private val versionName = run {
+      val properties = Properties()
+      properties.load(
+        SharkCliCommand::class.java.getResourceAsStream("/version.properties")
+          ?: throw IllegalStateException("version.properties missing")
+      )
+      properties.getProperty("version_name") ?: throw IllegalStateException(
+        "version_name property missing"
+      )
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/StripHprofCommand.kt b/shark-cli/src/main/java/shark/StripHprofCommand.kt
new file mode 100644
index 00000000..8c42b47b
--- /dev/null
+++ b/shark-cli/src/main/java/shark/StripHprofCommand.kt
@@ -0,0 +1,19 @@
+package shark
+
+import com.github.ajalt.clikt.core.CliktCommand
+import shark.SharkCliCommand.Companion.retrieveHeapDumpFile
+import shark.SharkCliCommand.Companion.sharkCliParams
+
+class StripHprofCommand : CliktCommand(
+  name = "strip-hprof",
+  help = "Replace all primitive arrays from the provided heap dump with arrays of zeroes and generate a new \"-stripped.hprof\" file."
+) {
+
+  override fun run() {
+    val heapDumpFile = retrieveHeapDumpFile(context.sharkCliParams)
+    SharkLog.d { "Stripping primitive arrays in heap dump $heapDumpFile" }
+    val stripper = HprofPrimitiveArrayStripper()
+    val outputFile = stripper.stripPrimitiveArrays(heapDumpFile)
+    echo("Created hprof with stripped primitive arrays to $outputFile")
+  }
+}
\ No newline at end of file
diff --git a/shark-graph/api/shark-graph.api b/shark-graph/api/shark-graph.api
new file mode 100644
index 00000000..7325222d
--- /dev/null
+++ b/shark-graph/api/shark-graph.api
@@ -0,0 +1,223 @@
+public abstract interface class shark/CloseableHeapGraph : java/io/Closeable, shark/HeapGraph {
+}
+
+public final class shark/GraphContext {
+	public fun <init> ()V
+	public final fun contains (Ljava/lang/String;)Z
+	public final fun get (Ljava/lang/String;)Ljava/lang/Object;
+	public final fun getOrPut (Ljava/lang/String;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
+	public final fun minusAssign (Ljava/lang/String;)V
+	public final fun set (Ljava/lang/String;Ljava/lang/Object;)V
+}
+
+public final class shark/HeapField {
+	public fun <init> (Lshark/HeapObject$HeapClass;Ljava/lang/String;Lshark/HeapValue;)V
+	public final fun getDeclaringClass ()Lshark/HeapObject$HeapClass;
+	public final fun getName ()Ljava/lang/String;
+	public final fun getValue ()Lshark/HeapValue;
+	public final fun getValueAsClass ()Lshark/HeapObject$HeapClass;
+	public final fun getValueAsInstance ()Lshark/HeapObject$HeapInstance;
+	public final fun getValueAsObjectArray ()Lshark/HeapObject$HeapObjectArray;
+	public final fun getValueAsPrimitiveArray ()Lshark/HeapObject$HeapPrimitiveArray;
+}
+
+public abstract interface class shark/HeapGraph {
+	public abstract fun findClassByName (Ljava/lang/String;)Lshark/HeapObject$HeapClass;
+	public abstract fun findHeapDumpIndex (J)I
+	public abstract fun findObjectByHeapDumpIndex (I)Lshark/HeapObject;
+	public abstract fun findObjectById (J)Lshark/HeapObject;
+	public abstract fun findObjectByIdOrNull (J)Lshark/HeapObject;
+	public abstract fun findObjectByIndex (I)Lshark/HeapObject;
+	public abstract fun getClassCount ()I
+	public abstract fun getClasses ()Lkotlin/sequences/Sequence;
+	public abstract fun getContext ()Lshark/GraphContext;
+	public abstract fun getGcRoots ()Ljava/util/List;
+	public abstract fun getIdentifierByteSize ()I
+	public abstract fun getInstanceCount ()I
+	public abstract fun getInstances ()Lkotlin/sequences/Sequence;
+	public abstract fun getObjectArrayCount ()I
+	public abstract fun getObjectArrays ()Lkotlin/sequences/Sequence;
+	public abstract fun getObjectCount ()I
+	public abstract fun getObjects ()Lkotlin/sequences/Sequence;
+	public abstract fun getPrimitiveArrayCount ()I
+	public abstract fun getPrimitiveArrays ()Lkotlin/sequences/Sequence;
+	public abstract fun objectExists (J)Z
+}
+
+public abstract class shark/HeapObject {
+	public static final field Companion Lshark/HeapObject$Companion;
+	public final fun getAsClass ()Lshark/HeapObject$HeapClass;
+	public final fun getAsInstance ()Lshark/HeapObject$HeapInstance;
+	public final fun getAsObjectArray ()Lshark/HeapObject$HeapObjectArray;
+	public final fun getAsPrimitiveArray ()Lshark/HeapObject$HeapPrimitiveArray;
+	public abstract fun getGraph ()Lshark/HeapGraph;
+	public abstract fun getObjectId ()J
+	public abstract fun getObjectIndex ()I
+	public final fun getPositiveObjectId ()J
+	public abstract fun getRecordSize ()I
+	public abstract fun readRecord ()Lshark/HprofRecord$HeapDumpRecord$ObjectRecord;
+}
+
+public final class shark/HeapObject$Companion {
+}
+
+public final class shark/HeapObject$HeapClass : shark/HeapObject {
+	public final fun get (Ljava/lang/String;)Lshark/HeapField;
+	public final fun getClassHierarchy ()Lkotlin/sequences/Sequence;
+	public final fun getDirectInstances ()Lkotlin/sequences/Sequence;
+	public fun getGraph ()Lshark/HeapGraph;
+	public final fun getHasReferenceInstanceFields ()Z
+	public final fun getInstanceByteSize ()I
+	public final fun getInstances ()Lkotlin/sequences/Sequence;
+	public final fun getName ()Ljava/lang/String;
+	public final fun getObjectArrayInstances ()Lkotlin/sequences/Sequence;
+	public fun getObjectId ()J
+	public fun getObjectIndex ()I
+	public final fun getPrimitiveArrayInstances ()Lkotlin/sequences/Sequence;
+	public fun getRecordSize ()I
+	public final fun getSimpleName ()Ljava/lang/String;
+	public final fun getSubclasses ()Lkotlin/sequences/Sequence;
+	public final fun getSuperclass ()Lshark/HeapObject$HeapClass;
+	public final fun instanceFieldName (Lshark/HprofRecord$HeapDumpRecord$ObjectRecord$ClassDumpRecord$FieldRecord;)Ljava/lang/String;
+	public final fun isArrayClass ()Z
+	public final fun isObjectArrayClass ()Z
+	public final fun isPrimitiveArrayClass ()Z
+	public final fun isPrimitiveWrapperClass ()Z
+	public final fun readFieldsByteSize ()I
+	public fun readRecord ()Lshark/HprofRecord$HeapDumpRecord$ObjectRecord$ClassDumpRecord;
+	public synthetic fun readRecord ()Lshark/HprofRecord$HeapDumpRecord$ObjectRecord;
+	public final fun readRecordFields ()Ljava/util/List;
+	public final fun readRecordStaticFields ()Ljava/util/List;
+	public final fun readStaticField (Ljava/lang/String;)Lshark/HeapField;
+	public final fun readStaticFields ()Lkotlin/sequences/Sequence;
+	public final fun subclassOf (Lshark/HeapObject$HeapClass;)Z
+	public final fun superclassOf (Lshark/HeapObject$HeapClass;)Z
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/HeapObject$HeapInstance : shark/HeapObject {
+	public final fun get (Ljava/lang/String;Ljava/lang/String;)Lshark/HeapField;
+	public final fun get (Lkotlin/reflect/KClass;Ljava/lang/String;)Lshark/HeapField;
+	public final fun getByteSize ()I
+	public fun getGraph ()Lshark/HeapGraph;
+	public final fun getInstanceClass ()Lshark/HeapObject$HeapClass;
+	public final fun getInstanceClassId ()J
+	public final fun getInstanceClassName ()Ljava/lang/String;
+	public final fun getInstanceClassSimpleName ()Ljava/lang/String;
+	public fun getObjectId ()J
+	public fun getObjectIndex ()I
+	public fun getRecordSize ()I
+	public final fun instanceOf (Ljava/lang/String;)Z
+	public final fun instanceOf (Lkotlin/reflect/KClass;)Z
+	public final fun instanceOf (Lshark/HeapObject$HeapClass;)Z
+	public final fun isPrimitiveWrapper ()Z
+	public final fun readAsJavaString ()Ljava/lang/String;
+	public final fun readField (Ljava/lang/String;Ljava/lang/String;)Lshark/HeapField;
+	public final fun readField (Lkotlin/reflect/KClass;Ljava/lang/String;)Lshark/HeapField;
+	public final fun readFields ()Lkotlin/sequences/Sequence;
+	public fun readRecord ()Lshark/HprofRecord$HeapDumpRecord$ObjectRecord$InstanceDumpRecord;
+	public synthetic fun readRecord ()Lshark/HprofRecord$HeapDumpRecord$ObjectRecord;
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/HeapObject$HeapObjectArray : shark/HeapObject {
+	public final fun getArrayClass ()Lshark/HeapObject$HeapClass;
+	public final fun getArrayClassId ()J
+	public final fun getArrayClassName ()Ljava/lang/String;
+	public final fun getArrayClassSimpleName ()Ljava/lang/String;
+	public final fun getByteSize ()I
+	public fun getGraph ()Lshark/HeapGraph;
+	public fun getObjectId ()J
+	public fun getObjectIndex ()I
+	public fun getRecordSize ()I
+	public final fun readByteSize ()I
+	public final fun readElements ()Lkotlin/sequences/Sequence;
+	public fun readRecord ()Lshark/HprofRecord$HeapDumpRecord$ObjectRecord$ObjectArrayDumpRecord;
+	public synthetic fun readRecord ()Lshark/HprofRecord$HeapDumpRecord$ObjectRecord;
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/HeapObject$HeapPrimitiveArray : shark/HeapObject {
+	public final fun getArrayClass ()Lshark/HeapObject$HeapClass;
+	public final fun getArrayClassName ()Ljava/lang/String;
+	public final fun getByteSize ()I
+	public fun getGraph ()Lshark/HeapGraph;
+	public fun getObjectId ()J
+	public fun getObjectIndex ()I
+	public final fun getPrimitiveType ()Lshark/PrimitiveType;
+	public fun getRecordSize ()I
+	public final fun readByteSize ()I
+	public fun readRecord ()Lshark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord;
+	public synthetic fun readRecord ()Lshark/HprofRecord$HeapDumpRecord$ObjectRecord;
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/HeapValue {
+	public fun <init> (Lshark/HeapGraph;Lshark/ValueHolder;)V
+	public final fun getAsBoolean ()Ljava/lang/Boolean;
+	public final fun getAsByte ()Ljava/lang/Byte;
+	public final fun getAsChar ()Ljava/lang/Character;
+	public final fun getAsDouble ()Ljava/lang/Double;
+	public final fun getAsFloat ()Ljava/lang/Float;
+	public final fun getAsInt ()Ljava/lang/Integer;
+	public final fun getAsLong ()Ljava/lang/Long;
+	public final fun getAsNonNullObjectId ()Ljava/lang/Long;
+	public final fun getAsObject ()Lshark/HeapObject;
+	public final fun getAsObjectId ()Ljava/lang/Long;
+	public final fun getAsShort ()Ljava/lang/Short;
+	public final fun getGraph ()Lshark/HeapGraph;
+	public final fun getHolder ()Lshark/ValueHolder;
+	public final fun isNonNullReference ()Z
+	public final fun isNullReference ()Z
+	public final fun readAsJavaString ()Ljava/lang/String;
+}
+
+public final class shark/HprofHeapGraph : shark/CloseableHeapGraph {
+	public static final field Companion Lshark/HprofHeapGraph$Companion;
+	public fun close ()V
+	public fun findClassByName (Ljava/lang/String;)Lshark/HeapObject$HeapClass;
+	public fun findHeapDumpIndex (J)I
+	public fun findObjectByHeapDumpIndex (I)Lshark/HeapObject;
+	public fun findObjectById (J)Lshark/HeapObject;
+	public fun findObjectByIdOrNull (J)Lshark/HeapObject;
+	public fun findObjectByIndex (I)Lshark/HeapObject;
+	public fun getClassCount ()I
+	public fun getClasses ()Lkotlin/sequences/Sequence;
+	public fun getContext ()Lshark/GraphContext;
+	public fun getGcRoots ()Ljava/util/List;
+	public fun getIdentifierByteSize ()I
+	public fun getInstanceCount ()I
+	public fun getInstances ()Lkotlin/sequences/Sequence;
+	public fun getObjectArrayCount ()I
+	public fun getObjectArrays ()Lkotlin/sequences/Sequence;
+	public fun getObjectCount ()I
+	public fun getObjects ()Lkotlin/sequences/Sequence;
+	public fun getPrimitiveArrayCount ()I
+	public fun getPrimitiveArrays ()Lkotlin/sequences/Sequence;
+	public final fun lruCacheStats ()Ljava/lang/String;
+	public fun objectExists (J)Z
+}
+
+public final class shark/HprofHeapGraph$Companion {
+	public final fun getINTERNAL_LRU_CACHE_SIZE ()I
+	public final fun indexHprof (Lshark/Hprof;Lshark/ProguardMapping;Ljava/util/Set;)Lshark/HeapGraph;
+	public static synthetic fun indexHprof$default (Lshark/HprofHeapGraph$Companion;Lshark/Hprof;Lshark/ProguardMapping;Ljava/util/Set;ILjava/lang/Object;)Lshark/HeapGraph;
+	public final fun openHeapGraph (Ljava/io/File;Lshark/ProguardMapping;Ljava/util/Set;)Lshark/CloseableHeapGraph;
+	public final fun openHeapGraph (Lshark/DualSourceProvider;Lshark/ProguardMapping;Ljava/util/Set;)Lshark/CloseableHeapGraph;
+	public static synthetic fun openHeapGraph$default (Lshark/HprofHeapGraph$Companion;Ljava/io/File;Lshark/ProguardMapping;Ljava/util/Set;ILjava/lang/Object;)Lshark/CloseableHeapGraph;
+	public static synthetic fun openHeapGraph$default (Lshark/HprofHeapGraph$Companion;Lshark/DualSourceProvider;Lshark/ProguardMapping;Ljava/util/Set;ILjava/lang/Object;)Lshark/CloseableHeapGraph;
+	public final fun setINTERNAL_LRU_CACHE_SIZE (I)V
+}
+
+public final class shark/HprofIndex {
+	public static final field Companion Lshark/HprofIndex$Companion;
+	public synthetic fun <init> (Lshark/RandomAccessSourceProvider;Lshark/HprofHeader;Lshark/internal/HprofInMemoryIndex;Lkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun openHeapGraph ()Lshark/CloseableHeapGraph;
+}
+
+public final class shark/HprofIndex$Companion {
+	public final fun defaultIndexedGcRootTags ()Ljava/util/EnumSet;
+	public final fun indexRecordsOf (Lshark/DualSourceProvider;Lshark/HprofHeader;Lshark/ProguardMapping;Ljava/util/Set;)Lshark/HprofIndex;
+	public static synthetic fun indexRecordsOf$default (Lshark/HprofIndex$Companion;Lshark/DualSourceProvider;Lshark/HprofHeader;Lshark/ProguardMapping;Ljava/util/Set;ILjava/lang/Object;)Lshark/HprofIndex;
+}
+
diff --git a/shark-graph/build.gradle b/shark-graph/build.gradle
new file mode 100644
index 00000000..18d4068a
--- /dev/null
+++ b/shark-graph/build.gradle
@@ -0,0 +1,19 @@
+plugins {
+  id("org.jetbrains.kotlin.jvm")
+  id("com.vanniktech.maven.publish")
+}
+
+sourceCompatibility = JavaVersion.VERSION_1_8
+targetCompatibility = JavaVersion.VERSION_1_8
+
+dependencies {
+  api projects.sharkHprof
+
+  implementation libs.kotlin.stdlib
+  implementation libs.okio2
+
+  testImplementation libs.assertjCore
+  testImplementation libs.junit
+  testImplementation projects.sharkTest
+  testImplementation projects.sharkHprofTest
+}
diff --git a/shark-graph/gradle.properties b/shark-graph/gradle.properties
new file mode 100644
index 00000000..0049f0e5
--- /dev/null
+++ b/shark-graph/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark-graph
+POM_NAME=Shark Graph
+POM_PACKAGING=jar
diff --git a/shark-graph/src/main/java/shark/CloseableHeapGraph.kt b/shark-graph/src/main/java/shark/CloseableHeapGraph.kt
new file mode 100644
index 00000000..1b989fb7
--- /dev/null
+++ b/shark-graph/src/main/java/shark/CloseableHeapGraph.kt
@@ -0,0 +1,8 @@
+package shark
+
+import java.io.Closeable
+
+/**
+ * A [HeapGraph] that should be closed after being used.
+ */
+interface CloseableHeapGraph : HeapGraph, Closeable
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/GraphContext.kt b/shark-graph/src/main/java/shark/GraphContext.kt
new file mode 100644
index 00000000..be1eee25
--- /dev/null
+++ b/shark-graph/src/main/java/shark/GraphContext.kt
@@ -0,0 +1,51 @@
+package shark
+
+/**
+ * In memory store that can be used to store objects in a given [HeapGraph] instance.
+ * This is a simple [MutableMap] of [String] to [Any], but with unsafe generics access.
+ */
+class GraphContext {
+  private val store = mutableMapOf<String, Any?>()
+  operator fun <T> get(key: String): T? {
+    @Suppress("UNCHECKED_CAST")
+    return store[key] as T?
+  }
+
+  /**
+   * @see MutableMap.getOrPut
+   */
+  fun <T> getOrPut(
+    key: String,
+    defaultValue: () -> T
+  ): T {
+    @Suppress("UNCHECKED_CAST")
+    return store.getOrPut(key) {
+      defaultValue()
+    } as T
+  }
+
+  /**
+   * @see MutableMap.set
+   */
+  operator fun <T> set(
+    key: String,
+    value: T
+  ) {
+    store[key] = (value as Any?)
+  }
+
+  /**
+   * @see MutableMap.containsKey
+   */
+  operator fun contains(key: String): Boolean {
+    return key in store
+  }
+
+  /**
+   * @see MutableMap.remove
+   */
+  operator fun minusAssign(key: String) {
+    @Suppress("UNCHECKED_CAST")
+    store -= key
+  }
+}
diff --git a/shark-graph/src/main/java/shark/HeapField.kt b/shark-graph/src/main/java/shark/HeapField.kt
new file mode 100644
index 00000000..e4500c4b
--- /dev/null
+++ b/shark-graph/src/main/java/shark/HeapField.kt
@@ -0,0 +1,51 @@
+package shark
+
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+
+/**
+ * Represents a static field or an instance field.
+ */
+class HeapField(
+  /**
+   * The class this field was declared in.
+   */
+  val declaringClass: HeapClass,
+  /**
+   * Name of the field
+   */
+  val name: String,
+  /**
+   * Value of the field. Also see shorthands [valueAsClass], [valueAsInstance],
+   * [valueAsObjectArray], [valueAsPrimitiveArray].
+   */
+  val value: HeapValue
+) {
+
+  /**
+   * Return a [HeapClass] is [value] references a class, and null otherwise.
+   */
+  val valueAsClass: HeapClass?
+    get() = value.asObject?.asClass
+
+  /**
+   * Return a [HeapInstance] is [value] references an instance, and null otherwise.
+   */
+  val valueAsInstance: HeapInstance?
+    get() = value.asObject?.asInstance
+
+  /**
+   * Return a [HeapObjectArray] is [value] references an object array, and null otherwise.
+   */
+  val valueAsObjectArray: HeapObjectArray?
+    get() = value.asObject?.asObjectArray
+
+  /**
+   * Return a [HeapPrimitiveArray] is [value] references a primitive array, and null
+   * otherwise.
+   */
+  val valueAsPrimitiveArray: HeapPrimitiveArray?
+    get() = value.asObject?.asPrimitiveArray
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/HeapGraph.kt b/shark-graph/src/main/java/shark/HeapGraph.kt
new file mode 100644
index 00000000..36d7e678
--- /dev/null
+++ b/shark-graph/src/main/java/shark/HeapGraph.kt
@@ -0,0 +1,118 @@
+package shark
+
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+
+/**
+ * Enables navigation through the heap graph of objects.
+ */
+interface HeapGraph {
+  val identifierByteSize: Int
+
+  /**
+   * In memory store that can be used to store objects this [HeapGraph] instance.
+   */
+  val context: GraphContext
+
+  val objectCount: Int
+
+  val classCount: Int
+
+  val instanceCount: Int
+
+  val objectArrayCount: Int
+
+  val primitiveArrayCount: Int
+
+  /**
+   * All GC roots which type matches types known to this heap graph and which point to non null
+   * references. You can retrieve the object that a GC Root points to by calling [findObjectById]
+   * with [GcRoot.id], however you need to first check that [objectExists] returns true because
+   * GC roots can point to objects that don't exist in the heap dump.
+   */
+  val gcRoots: List<GcRoot>
+
+  /**
+   * Sequence of all objects in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val objects: Sequence<HeapObject>
+
+  /**
+   * Sequence of all classes in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val classes: Sequence<HeapClass>
+
+  /**
+   * Sequence of all instances in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val instances: Sequence<HeapInstance>
+
+  /**
+   * Sequence of all object arrays in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val objectArrays: Sequence<HeapObjectArray>
+
+  /**
+   * Sequence of all primitive arrays in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val primitiveArrays: Sequence<HeapPrimitiveArray>
+
+  /**
+   * Returns the [HeapObject] corresponding to the provided [objectId], and throws
+   * [IllegalArgumentException] otherwise.
+   */
+  @Throws(IllegalArgumentException::class)
+  fun findObjectById(objectId: Long): HeapObject
+
+  /**
+   * Returns the [HeapObject] corresponding to the provided [objectIndex], and throws
+   * [IllegalArgumentException] if [objectIndex] is less than 0 or more than [objectCount] - 1.
+   */
+  @Throws(IllegalArgumentException::class)
+  fun findObjectByIndex(objectIndex: Int): HeapObject
+
+  /**
+   * Returns the [HeapObject] corresponding to the provided [objectId] or null if it cannot be
+   * found.
+   */
+  fun findObjectByIdOrNull(objectId: Long): HeapObject?
+
+  /**
+   * Returns the [HeapClass] corresponding to the provided [className], or null if the
+   * class cannot be found.
+   */
+  fun findClassByName(className: String): HeapClass?
+
+  /**
+   * Returns true if the provided [objectId] exists in the heap dump.
+   */
+  fun objectExists(objectId: Long): Boolean
+
+  /**
+   * Returns the 1-based index in the heap dump of the object corresponding to the provided
+   * [objectId], and throws [IllegalArgumentException] otherwise.
+   *
+   * This is the object index that YourKit provides in its Java profiler.
+   */
+  fun findHeapDumpIndex(objectId: Long): Int
+
+  /**
+   * Returns the [HeapObject] corresponding to the provided [heapDumpIndex], and throws
+   * [IllegalArgumentException] if [heapDumpIndex] is less than 1 or more than [objectCount].
+   *
+   * This is the object index that YourKit provides in its Java profiler.
+   */
+  fun findObjectByHeapDumpIndex(heapDumpIndex: Int): HeapObject
+}
diff --git a/shark-graph/src/main/java/shark/HeapObject.kt b/shark-graph/src/main/java/shark/HeapObject.kt
new file mode 100644
index 00000000..4e1f7793
--- /dev/null
+++ b/shark-graph/src/main/java/shark/HeapObject.kt
@@ -0,0 +1,677 @@
+package shark
+
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.ValueHolder.ReferenceHolder
+import shark.internal.IndexedObject.IndexedClass
+import shark.internal.IndexedObject.IndexedInstance
+import shark.internal.IndexedObject.IndexedObjectArray
+import shark.internal.IndexedObject.IndexedPrimitiveArray
+import java.nio.charset.Charset
+import java.util.Locale
+import kotlin.LazyThreadSafetyMode.NONE
+import kotlin.reflect.KClass
+import shark.PrimitiveType.INT
+
+/**
+ * An object in the heap dump.
+ */
+sealed class HeapObject {
+
+  /**
+   * The graph of objects in the heap, which you can use to navigate the heap.
+   */
+
+  abstract val graph: HeapGraph
+
+  /**
+   * The heap identifier of this object.
+   */
+  abstract val objectId: Long
+
+  /**
+   * [objectId] masked to be a positive unique identifier, as reported in Android Studio.
+   */
+  val positiveObjectId: Long
+    get() = objectId and (-0x1L ushr (8 - graph.identifierByteSize) * 8)
+
+  /**
+   * An positive object index that's specific to how Shark stores objects in memory.
+   * The index starts at 0 and ends at [HeapGraph.objectCount] - 1. There are no gaps, every index
+   * value corresponds to an object. Classes are first, then instances, then object arrays then
+   * primitive arrays.
+   */
+  abstract val objectIndex: Int
+
+  /**
+   * Reads and returns the underlying [ObjectRecord].
+   *
+   * This may trigger IO reads.
+   */
+  abstract fun readRecord(): ObjectRecord
+
+  /**
+   * The total byte size for the record of this object in the heap dump.
+   */
+  abstract val recordSize: Int
+
+  /**
+   * This [HeapObject] as a [HeapClass] if it is one, or null otherwise
+   */
+  val asClass: HeapClass?
+    get() = if (this is HeapClass) this else null
+
+  /**
+   * This [HeapObject] as a [HeapInstance] if it is one, or null otherwise
+   */
+  val asInstance: HeapInstance?
+    get() = if (this is HeapInstance) this else null
+
+  /**
+   * This [HeapObject] as a [HeapObjectArray] if it is one, or null otherwise
+   */
+  val asObjectArray: HeapObjectArray?
+    get() = if (this is HeapObjectArray) this else null
+
+  /**
+   * This [HeapObject] as a [HeapPrimitiveArray] if it is one, or null otherwise
+   */
+  val asPrimitiveArray: HeapPrimitiveArray?
+    get() = if (this is HeapPrimitiveArray) this else null
+
+  /**
+   * A class in the heap dump.
+   */
+  class HeapClass internal constructor(
+    private val hprofGraph: HprofHeapGraph,
+    private val indexedObject: IndexedClass,
+    override val objectId: Long,
+    override val objectIndex: Int
+  ) : HeapObject() {
+    override val graph: HeapGraph
+      get() = hprofGraph
+
+    /**
+     * Whether this is class is a primitive wrapper type
+     */
+    val isPrimitiveWrapperClass: Boolean
+      get() = (name in primitiveWrapperClassNames)
+
+    /**
+     * The name of this class, identical to [Class.getName].
+     * If this class is an array class, the name has a suffix of brackets for each dimension of
+     * the array, e.g. `com.Foo[][]` is a class for 2 dimensional arrays of `com.Foo`.
+     *
+     * The behavior for primitive types changes depending on the VM that dumped the heap. JVM
+     * heap dumps don't have any [HeapClass] object for primitive types, instead the
+     * `java.land.Class` class has 9 instances (the 8 primitive types and `void`). Android heap
+     * dumps have an [HeapClass] object for primitive type and the `java.land.Class` class has no
+     * instance.
+     *
+     * If this is an array class, you can find the component type by removing the brackets at the
+     * end, e.g. `name.substringBefore('[')`. Be careful when doing this for JVM heap dumps though,
+     * as if the component type is a primitive type there will not be a [HeapClass] object for it.
+     * This is especially tricky with N dimension primitive type arrays, which are instances of
+     * [HeapObjectArray] (vs single dimension primitive type arrays which are instances of
+     * [HeapPrimitiveArray]).
+     */
+    val name: String
+      get() = hprofGraph.className(objectId)
+
+    /**
+     * Returns [name] stripped of any string content before the last period (included).
+     */
+    val simpleName: String
+      get() = classSimpleName(name)
+
+    /**
+     * The total byte size of fields for instances of this class, as registered in the class dump.
+     * This includes the size of fields from superclasses.
+     *
+     * @see readFieldsByteSize
+     */
+    val instanceByteSize: Int
+      get() = indexedObject.instanceSize
+
+    override val recordSize: Int
+      get() = indexedObject.recordSize.toInt()
+
+    val hasReferenceInstanceFields: Boolean
+      get() = hprofGraph.classDumpHasReferenceFields(indexedObject)
+
+    /**
+     * Returns true if this class is an array class, and false otherwise.
+     */
+    val isArrayClass: Boolean
+      get() = name.endsWith("[]")
+
+    val isPrimitiveArrayClass: Boolean
+      get() = name in primitiveTypesByPrimitiveArrayClassName
+
+    val isObjectArrayClass: Boolean
+      get() = isArrayClass && !isPrimitiveArrayClass
+
+    /**
+     * The total byte size of fields for instances of this class, computed as the sum of the
+     * individual size of each field of this class. This does not include the size of fields from
+     * superclasses.
+     *
+     * This may trigger IO reads.
+     *
+     * @see instanceByteSize
+     */
+    fun readFieldsByteSize(): Int {
+      return readRecordFields().sumBy {
+        if (it.type == PrimitiveType.REFERENCE_HPROF_TYPE) {
+          hprofGraph.identifierByteSize
+        } else PrimitiveType.byteSizeByHprofType.getValue(it.type)
+      }
+    }
+
+    /**
+     * The [HeapClass] representing the superclass of this [HeapClass]. If this [HeapClass]
+     * represents either the [Object] class or a primitive type, then
+     * null is returned. If this [HeapClass] represents an array class then the
+     * [HeapClass] object representing the [Object] class is returned.
+     */
+    val superclass: HeapClass?
+      get() {
+        if (indexedObject.superclassId == ValueHolder.NULL_REFERENCE) return null
+        return hprofGraph.findObjectById(indexedObject.superclassId) as HeapClass
+      }
+
+    /**
+     * The class hierarchy starting at this class (included) and ending at the [Object] class
+     * (included).
+     */
+    val classHierarchy: Sequence<HeapClass>
+      get() = generateSequence(this) { it.superclass }
+
+    /**
+     * All the subclasses (direct and indirect) of this class,
+     * in the order they were recorded in the heap dump.
+     */
+    val subclasses: Sequence<HeapClass>
+      get() = hprofGraph.classes.filter { it subclassOf this }
+
+    /**
+     * Returns true if [subclass] is a sub class of this [HeapClass].
+     */
+    infix fun superclassOf(subclass: HeapClass): Boolean {
+      return subclass.classHierarchy.any { it.objectId == objectId }
+    }
+
+    /**
+     * Returns true if [superclass] is a superclass of this [HeapClass].
+     */
+    infix fun subclassOf(superclass: HeapClass): Boolean {
+      return superclass.objectId != objectId && classHierarchy.any { it.objectId == superclass.objectId }
+    }
+
+    /**
+     * All instances of this class, including instances of subclasses of this class.
+     */
+    val instances: Sequence<HeapInstance>
+      get() = if (!isArrayClass) {
+        hprofGraph.instances.filter { it instanceOf this }
+      } else {
+        emptySequence()
+      }
+
+    val objectArrayInstances: Sequence<HeapObjectArray>
+      get() = if (isObjectArrayClass) {
+        hprofGraph.objectArrays.filter { it.indexedObject.arrayClassId == objectId }
+      } else {
+        emptySequence()
+      }
+
+    /**
+     * Primitive arrays are one dimensional arrays of a primitive type.
+     * N-dimension arrays of primitive types (e.g. int[][]) are object arrays pointing to primitive
+     * arrays.
+     */
+    val primitiveArrayInstances: Sequence<HeapPrimitiveArray>
+      get() {
+        val primitiveType = primitiveTypesByPrimitiveArrayClassName[name]
+        return if (primitiveType != null) {
+          hprofGraph.primitiveArrays.filter { it.primitiveType == primitiveType }
+        } else {
+          emptySequence()
+        }
+      }
+
+    /**
+     * All direct instances of this class, ie excluding any instance of subclasses of this class.
+     */
+    val directInstances: Sequence<HeapInstance>
+      get() = hprofGraph.instances.filter { it.indexedObject.classId == objectId }
+
+    /**
+     * Reads and returns the underlying [ClassDumpRecord].
+     *
+     * This may trigger IO reads.
+     */
+    override fun readRecord(): ClassDumpRecord {
+      return hprofGraph.readClassDumpRecord(objectId, indexedObject)
+    }
+
+    fun readRecordStaticFields() = hprofGraph.classDumpStaticFields(indexedObject)
+
+    fun readRecordFields() = hprofGraph.classDumpFields(indexedObject)
+
+    /**
+     * Returns the name of the field declared in this class for the specified [fieldRecord].
+     */
+    fun instanceFieldName(fieldRecord: FieldRecord): String {
+      return hprofGraph.fieldName(objectId, fieldRecord)
+    }
+
+    /**
+     * The static fields of this class, as a sequence of [HeapField].
+     *
+     * This may trigger IO reads.
+     */
+    fun readStaticFields(): Sequence<HeapField> {
+      return readRecordStaticFields().asSequence()
+        .map { fieldRecord ->
+          HeapField(
+            this, hprofGraph.staticFieldName(objectId, fieldRecord),
+            HeapValue(hprofGraph, fieldRecord.value)
+          )
+        }
+    }
+
+    /**
+     * Returns a [HeapField] object that reflects the specified declared
+     * field of the class represented by this [HeapClass] object, or null if this field does not
+     * exist. The [name] parameter specifies the simple name of the desired field.
+     *
+     * Also available as a convenience operator: [get]
+     *
+     * This may trigger IO reads.
+     */
+    fun readStaticField(fieldName: String): HeapField? {
+      for (fieldRecord in readRecordStaticFields()) {
+        val recordFieldName = hprofGraph.staticFieldName(objectId, fieldRecord)
+        if (recordFieldName == fieldName) {
+          return HeapField(this, fieldName, HeapValue(hprofGraph, fieldRecord.value))
+        }
+      }
+      return null
+    }
+
+    /**
+     * @see readStaticField
+     */
+    operator fun get(fieldName: String) = readStaticField(fieldName)
+
+    override fun toString(): String {
+      return "class $name"
+    }
+  }
+
+  /**
+   * An instance in the heap dump.
+   */
+  class HeapInstance internal constructor(
+    private val hprofGraph: HprofHeapGraph,
+    internal val indexedObject: IndexedInstance,
+    override val objectId: Long,
+    override val objectIndex: Int
+  ) : HeapObject() {
+
+    /**
+     * Whether this is an instance of a primitive wrapper type.
+     */
+    val isPrimitiveWrapper: Boolean
+      get() = instanceClassName in primitiveWrapperClassNames
+
+    override val graph: HeapGraph
+      get() = hprofGraph
+
+    /**
+     * @see HeapClass.instanceByteSize
+     */
+    val byteSize
+      get() = instanceClass.instanceByteSize
+
+    /**
+     * The name of the class of this instance, identical to [Class.getName].
+     */
+    val instanceClassName: String
+      get() = hprofGraph.className(indexedObject.classId)
+
+    /**
+     * Returns [instanceClassName] stripped of any string content before the last period (included).
+     */
+    val instanceClassSimpleName: String
+      get() = classSimpleName(instanceClassName)
+
+    /**
+     * The class of this instance.
+     */
+    val instanceClass: HeapClass
+      get() = hprofGraph.findObjectById(indexedObject.classId) as HeapClass
+
+    /**
+     * The heap identifier of the class of this instance.
+     */
+    val instanceClassId: Long
+      get() = indexedObject.classId
+
+    /**
+     * Reads and returns the underlying [InstanceDumpRecord].
+     *
+     * This may trigger IO reads.
+     */
+    override fun readRecord(): InstanceDumpRecord {
+      return hprofGraph.readInstanceDumpRecord(objectId, indexedObject)
+    }
+
+    override val recordSize: Int
+      get() = indexedObject.recordSize.toInt()
+
+    /**
+     * Returns true if this is an instance of the class named [className] or an instance of a
+     * subclass of that class.
+     */
+    infix fun instanceOf(className: String): Boolean =
+      instanceClass.classHierarchy.any { it.name == className }
+
+    /**
+     * Returns true if this is an instance of [expectedClass] or an instance of a subclass of that
+     * class.
+     */
+    infix fun instanceOf(expectedClass: KClass<*>) =
+      this instanceOf expectedClass.java.name
+
+    /**
+     * Returns true if this is an instance of [expectedClass] or an instance of a subclass of that
+     * class.
+     */
+    infix fun instanceOf(expectedClass: HeapClass) =
+      instanceClass.classHierarchy.any { it.objectId == expectedClass.objectId }
+
+    /**
+     * @see readField
+     */
+    fun readField(
+      declaringClass: KClass<out Any>,
+      fieldName: String
+    ): HeapField? {
+      return readField(declaringClass.java.name, fieldName)
+    }
+
+    /**
+     * Returns a [HeapField] object that reflects the specified declared
+     * field of the instance represented by this [HeapInstance] object, or null if this field does
+     * not exist. The [declaringClassName] specifies the class in which the desired field is
+     * declared, and the [fieldName] parameter specifies the simple name of the desired field.
+     *
+     * Also available as a convenience operator: [get]
+     *
+     * This may trigger IO reads.
+     */
+    fun readField(
+      declaringClassName: String,
+      fieldName: String
+    ): HeapField? {
+      return readFields().firstOrNull { field -> field.declaringClass.name == declaringClassName && field.name == fieldName }
+    }
+
+    /**
+     * @see readField
+     */
+    operator fun get(
+      declaringClass: KClass<out Any>,
+      fieldName: String
+    ): HeapField? {
+      return readField(declaringClass, fieldName)
+    }
+
+    /**
+     * @see readField
+     */
+    operator fun get(
+      declaringClassName: String,
+      fieldName: String
+    ) = readField(declaringClassName, fieldName)
+
+    /**
+     * The fields of this instance, as a sequence of [HeapField].
+     *
+     * This may trigger IO reads.
+     */
+    fun readFields(): Sequence<HeapField> {
+      val fieldReader by lazy(NONE) {
+        hprofGraph.createFieldValuesReader(readRecord())
+      }
+      return instanceClass.classHierarchy
+        .map { heapClass ->
+          heapClass.readRecordFields().asSequence()
+            .map { fieldRecord ->
+              val fieldName = hprofGraph.fieldName(heapClass.objectId, fieldRecord)
+              val fieldValue = fieldReader.readValue(fieldRecord)
+              HeapField(heapClass, fieldName, HeapValue(hprofGraph, fieldValue))
+            }
+        }
+        .flatten()
+    }
+
+    /**
+     * If this [HeapInstance] is an instance of the [String] class, returns a [String] instance
+     * with content that matches the string in the heap dump. Otherwise returns null.
+     *
+     * This may trigger IO reads.
+     */
+    fun readAsJavaString(): String? {
+      if (instanceClassName != "java.lang.String") {
+        return null
+      }
+
+      // JVM strings don't have a count field.
+      val count = this["java.lang.String", "count"]?.value?.asInt
+      if (count == 0) {
+        return ""
+      }
+
+      // Prior to API 26 String.value was a char array.
+      // Since API 26 String.value is backed by native code. The vast majority of strings in a
+      // heap dump are backed by a byte array, but we still find a few backed by a char array.
+      when (val valueRecord =
+        this["java.lang.String", "value"]!!.value.asObject!!.readRecord()) {
+        is CharArrayDump -> {
+          // < API 23
+          // As of Marshmallow, substrings no longer share their parent strings' char arrays
+          // eliminating the need for String.offset
+          // https://android-review.googlesource.com/#/c/83611/
+          val offset = this["java.lang.String", "offset"]?.value?.asInt
+
+          val chars = if (count != null && offset != null) {
+            // Handle heap dumps where all primitive arrays have been replaced with empty arrays,
+            // e.g. with HprofPrimitiveArrayStripper
+            val toIndex = if (offset + count > valueRecord.array.size) {
+              valueRecord.array.size
+            } else offset + count
+            valueRecord.array.copyOfRange(offset, toIndex)
+          } else {
+            valueRecord.array
+          }
+          return String(chars)
+        }
+        is ByteArrayDump -> {
+          return String(valueRecord.array, Charset.forName("UTF-8"))
+        }
+        else -> throw UnsupportedOperationException(
+          "'value' field ${this["java.lang.String", "value"]!!.value} was expected to be either" +
+            " a char or byte array in string instance with id $objectId"
+        )
+      }
+    }
+
+    override fun toString(): String {
+      return "instance @$objectId of $instanceClassName"
+    }
+  }
+
+  /**
+   * An object array in the heap dump.
+   */
+  class HeapObjectArray internal constructor(
+    private val hprofGraph: HprofHeapGraph,
+    internal val indexedObject: IndexedObjectArray,
+    override val objectId: Long,
+    override val objectIndex: Int
+  ) : HeapObject() {
+
+    override val graph: HeapGraph
+      get() = hprofGraph
+
+    /**
+     * The name of the class of this array, identical to [Class.getName].
+     */
+    val arrayClassName: String
+      get() = hprofGraph.className(indexedObject.arrayClassId)
+
+    /**
+     * Returns [arrayClassName] stripped of any string content before the last period (included).
+     */
+    val arrayClassSimpleName: String
+      get() = classSimpleName(arrayClassName)
+
+    /**
+     * The class of this array.
+     */
+    val arrayClass: HeapClass
+      get() = hprofGraph.findObjectById(indexedObject.arrayClassId) as HeapClass
+
+    /**
+     * The heap identifier of the class of this array.
+     */
+    val arrayClassId: Long
+      get() = indexedObject.arrayClassId
+
+
+    @Deprecated("Use byteSize property instead", ReplaceWith("byteSize"))
+    fun readByteSize() = byteSize
+
+    /**
+     * The total byte shallow size of elements in this array.
+     */
+    val byteSize: Int
+      get() = recordSize - hprofGraph.objectArrayRecordNonElementSize
+
+    /**
+     * Reads and returns the underlying [ObjectArrayDumpRecord].
+     *
+     * This may trigger IO reads.
+     */
+    override fun readRecord(): ObjectArrayDumpRecord {
+      return hprofGraph.readObjectArrayDumpRecord(objectId, indexedObject)
+    }
+
+    override val recordSize: Int
+      get() = indexedObject.recordSize.toInt()
+
+    /**
+     * The elements in this array, as a sequence of [HeapValue].
+     *
+     * This may trigger IO reads.
+     */
+    fun readElements(): Sequence<HeapValue> {
+      return readRecord().elementIds.asSequence()
+        .map { HeapValue(hprofGraph, ReferenceHolder(it)) }
+    }
+
+    override fun toString(): String {
+      return "object array @$objectId of $arrayClassName"
+    }
+  }
+
+  /**
+   * A primitive array in the heap dump.
+   */
+  class HeapPrimitiveArray internal constructor(
+    private val hprofGraph: HprofHeapGraph,
+    private val indexedObject: IndexedPrimitiveArray,
+    override val objectId: Long,
+    override val objectIndex: Int
+  ) : HeapObject() {
+
+    override val graph: HeapGraph
+      get() = hprofGraph
+
+    @Deprecated("Use byteSize property instead", ReplaceWith("byteSize"))
+    fun readByteSize() = byteSize
+
+    /**
+     * The total byte shallow size of elements in this array.
+     */
+    val byteSize: Int
+      get() = recordSize - hprofGraph.primitiveArrayRecordNonElementSize
+
+
+    /**
+     * The [PrimitiveType] of elements in this array.
+     */
+    val primitiveType: PrimitiveType
+      get() = indexedObject.primitiveType
+
+    /**
+     * The name of the class of this array, identical to [Class.getName].
+     */
+    val arrayClassName: String
+      get() = "${primitiveType.name.toLowerCase(Locale.US)}[]"
+
+    /**
+     * The class of this array.
+     */
+    val arrayClass: HeapClass
+      get() = graph.findClassByName(arrayClassName)!!
+
+    /**
+     * Reads and returns the underlying [PrimitiveArrayDumpRecord].
+     *
+     * This may trigger IO reads.
+     */
+    override fun readRecord(): PrimitiveArrayDumpRecord {
+      return hprofGraph.readPrimitiveArrayDumpRecord(objectId, indexedObject)
+    }
+
+    override val recordSize: Int
+      get() = indexedObject.recordSize.toInt()
+
+    override fun toString(): String {
+      return "primitive array @$objectId of $arrayClassName"
+    }
+  }
+
+  companion object {
+
+    internal val primitiveTypesByPrimitiveArrayClassName =
+      PrimitiveType.values().associateBy { "${it.name.toLowerCase(Locale.US)}[]" }
+
+    private val primitiveWrapperClassNames = setOf<String>(
+      Boolean::class.javaObjectType.name, Char::class.javaObjectType.name,
+      Float::class.javaObjectType.name,
+      Double::class.javaObjectType.name, Byte::class.javaObjectType.name,
+      Short::class.javaObjectType.name,
+      Int::class.javaObjectType.name, Long::class.javaObjectType.name
+    )
+
+    private fun classSimpleName(className: String): String {
+      val separator = className.lastIndexOf('.')
+      return if (separator == -1) {
+        className
+      } else {
+        className.substring(separator + 1)
+      }
+    }
+  }
+}
diff --git a/shark-graph/src/main/java/shark/HeapValue.kt b/shark-graph/src/main/java/shark/HeapValue.kt
new file mode 100644
index 00000000..574ef061
--- /dev/null
+++ b/shark-graph/src/main/java/shark/HeapValue.kt
@@ -0,0 +1,127 @@
+package shark
+
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+
+/**
+ * Represents a value in the heap dump, which can be an object reference or
+ * a primitive type.
+ */
+class HeapValue(
+  /**
+   * The graph of objects in the heap, which you can use to navigate the heap.
+   */
+  val graph: HeapGraph,
+  /**
+   * Holds the actual value that this [HeapValue] represents.
+   */
+  val holder: ValueHolder
+) {
+
+  /**
+   * This [HeapValue] as a [Boolean] if it represents one, or null otherwise.
+   */
+  val asBoolean: Boolean?
+    get() = if (holder is BooleanHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Char] if it represents one, or null otherwise.
+   */
+  val asChar: Char?
+    get() = if (holder is CharHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Float] if it represents one, or null otherwise.
+   */
+  val asFloat: Float?
+    get() = if (holder is FloatHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Double] if it represents one, or null otherwise.
+   */
+  val asDouble: Double?
+    get() = if (holder is DoubleHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Byte] if it represents one, or null otherwise.
+   */
+  val asByte: Byte?
+    get() = if (holder is ByteHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Short] if it represents one, or null otherwise.
+   */
+  val asShort: Short?
+    get() = if (holder is ShortHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as an [Int] if it represents one, or null otherwise.
+   */
+  val asInt: Int?
+    get() = if (holder is IntHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Long] if it represents one, or null otherwise.
+   */
+  val asLong: Long?
+    get() = if (holder is LongHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Long] if it represents an object reference, or null otherwise.
+   */
+  val asObjectId: Long?
+    get() = if (holder is ReferenceHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Long] if it represents a non null object reference, or null otherwise.
+   */
+  val asNonNullObjectId: Long?
+    get() = if (holder is ReferenceHolder && !holder.isNull) holder.value else null
+
+  /**
+   * True is this [HeapValue] represents a null object reference, false otherwise.
+   */
+  val isNullReference: Boolean
+    get() = holder is ReferenceHolder && holder.isNull
+
+  /**
+   * True is this [HeapValue] represents a non null object reference, false otherwise.
+   */
+  val isNonNullReference: Boolean
+    get() = holder is ReferenceHolder && !holder.isNull
+
+  /**
+   * The [HeapObject] referenced by this [HeapValue] if it represents a non null object reference,
+   * or null otherwise.
+   */
+  val asObject: HeapObject?
+    get() {
+      return if (holder is ReferenceHolder && !holder.isNull) {
+        return graph.findObjectById(holder.value)
+      } else {
+        null
+      }
+    }
+
+  /**
+   * If this [HeapValue] if it represents a non null object reference to an instance of the
+   * [String] class that exists in the heap dump, returns a [String] instance with content that
+   * matches the string in the heap dump. Otherwise returns null.
+   *
+   * This may trigger IO reads.
+   */
+  fun readAsJavaString(): String? {
+    if (holder is ReferenceHolder && !holder.isNull) {
+      val heapObject = graph.findObjectByIdOrNull(holder.value)
+      return heapObject?.asInstance?.readAsJavaString()
+    }
+    return null
+  }
+}
diff --git a/shark-graph/src/main/java/shark/HprofHeapGraph.kt b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
new file mode 100644
index 00000000..eb4d18b0
--- /dev/null
+++ b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
@@ -0,0 +1,486 @@
+package shark
+
+import shark.GcRoot.Debugger
+import shark.GcRoot.Finalizing
+import shark.GcRoot.InternedString
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.JniGlobal
+import shark.GcRoot.JniLocal
+import shark.GcRoot.JniMonitor
+import shark.GcRoot.MonitorUsed
+import shark.GcRoot.NativeStack
+import shark.GcRoot.ReferenceCleanup
+import shark.GcRoot.StickyClass
+import shark.GcRoot.ThreadBlock
+import shark.GcRoot.ThreadObject
+import shark.GcRoot.Unknown
+import shark.GcRoot.Unreachable
+import shark.GcRoot.VmInternal
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.HprofVersion.ANDROID
+import shark.internal.FieldValuesReader
+import shark.internal.HprofInMemoryIndex
+import shark.internal.IndexedObject
+import shark.internal.IndexedObject.IndexedClass
+import shark.internal.IndexedObject.IndexedInstance
+import shark.internal.IndexedObject.IndexedObjectArray
+import shark.internal.IndexedObject.IndexedPrimitiveArray
+import shark.internal.LruCache
+import java.io.File
+import kotlin.reflect.KClass
+import shark.PrimitiveType.BYTE
+import shark.PrimitiveType.INT
+
+/**
+ * A [HeapGraph] that reads from an Hprof file indexed by [HprofIndex].
+ */
+class HprofHeapGraph internal constructor(
+  private val header: HprofHeader,
+  private val reader: RandomAccessHprofReader,
+  private val index: HprofInMemoryIndex
+) : CloseableHeapGraph {
+
+  override val identifierByteSize: Int get() = header.identifierByteSize
+
+  override val context = GraphContext()
+
+  override val objectCount: Int
+    get() = classCount + instanceCount + objectArrayCount + primitiveArrayCount
+
+  override val classCount: Int
+    get() = index.classCount
+
+  override val instanceCount: Int
+    get() = index.instanceCount
+
+  override val objectArrayCount: Int
+    get() = index.objectArrayCount
+
+  override val primitiveArrayCount: Int
+    get() = index.primitiveArrayCount
+
+  override val gcRoots: List<GcRoot>
+    get() = index.gcRoots()
+
+  override val objects: Sequence<HeapObject>
+    get() {
+      var objectIndex = 0
+      return index.indexedObjectSequence()
+        .map {
+          wrapIndexedObject(objectIndex++, it.second, it.first)
+        }
+    }
+
+  override val classes: Sequence<HeapClass>
+    get() {
+      var objectIndex = 0
+      return index.indexedClassSequence()
+        .map {
+          val objectId = it.first
+          val indexedObject = it.second
+          HeapClass(this, indexedObject, objectId, objectIndex++)
+        }
+    }
+
+  override val instances: Sequence<HeapInstance>
+    get() {
+      var objectIndex = classCount
+      return index.indexedInstanceSequence()
+        .map {
+          val objectId = it.first
+          val indexedObject = it.second
+          HeapInstance(this, indexedObject, objectId, objectIndex++)
+        }
+    }
+
+  override val objectArrays: Sequence<HeapObjectArray>
+    get() {
+      var objectIndex = classCount + instanceCount
+      return index.indexedObjectArraySequence().map {
+        val objectId = it.first
+        val indexedObject = it.second
+        HeapObjectArray(this, indexedObject, objectId, objectIndex++)
+      }
+    }
+
+  override val primitiveArrays: Sequence<HeapPrimitiveArray>
+    get() {
+      var objectIndex = classCount + instanceCount + objectArrayCount
+      return index.indexedPrimitiveArraySequence().map {
+        val objectId = it.first
+        val indexedObject = it.second
+        HeapPrimitiveArray(this, indexedObject, objectId, objectIndex++)
+      }
+    }
+
+  private val objectCache = LruCache<Long, ObjectRecord>(INTERNAL_LRU_CACHE_SIZE)
+
+  // java.lang.Object is the most accessed class in Heap, so we want to memoize a reference to it
+  private val javaLangObjectClass: HeapClass? = findClassByName("java.lang.Object")
+
+  internal val objectArrayRecordNonElementSize = 2 * identifierByteSize + 2 * INT.byteSize
+
+  internal val primitiveArrayRecordNonElementSize =
+    identifierByteSize + 2 * INT.byteSize + BYTE.byteSize
+
+  /**
+   * This is only public so that we can publish stats. Accessing this requires casting
+   * [HeapGraph] to [HprofHeapGraph] so it's really not a public API. May change at any time!
+   */
+  fun lruCacheStats(): String = objectCache.toString()
+
+  override fun findObjectById(objectId: Long): HeapObject {
+    return findObjectByIdOrNull(objectId) ?: throw IllegalArgumentException(
+      "Object id $objectId not found in heap dump."
+    )
+  }
+
+  override fun findObjectByIndex(objectIndex: Int): HeapObject {
+    require(objectIndex in 0 until objectCount) {
+      "$objectIndex should be in range [0, $objectCount["
+    }
+    val (objectId, indexedObject) = index.objectAtIndex(objectIndex)
+    return wrapIndexedObject(objectIndex, indexedObject, objectId)
+  }
+
+  override fun findObjectByIdOrNull(objectId: Long): HeapObject? {
+    if (objectId == javaLangObjectClass?.objectId) return javaLangObjectClass
+
+    val (objectIndex, indexedObject) = index.indexedObjectOrNull(objectId) ?: return null
+    return wrapIndexedObject(objectIndex, indexedObject, objectId)
+  }
+
+  override fun findClassByName(className: String): HeapClass? {
+    val heapDumpClassName = if (header.version != ANDROID) {
+      val indexOfArrayChar = className.indexOf('[')
+      if (indexOfArrayChar != -1) {
+        val dimensions = (className.length - indexOfArrayChar) / 2
+        val componentClassName = className.substring(0, indexOfArrayChar)
+        "[".repeat(dimensions) + when (componentClassName) {
+          "char" -> 'C'
+          "float" -> 'F'
+          "double" -> 'D'
+          "byte" -> 'B'
+          "short" -> 'S'
+          "int" -> 'I'
+          "long" -> 'J'
+          else -> "L$componentClassName;"
+        }
+      } else {
+        className
+      }
+    } else {
+      className
+    }
+    val classId = index.classId(heapDumpClassName)
+    return if (classId == null) {
+      null
+    } else {
+      return findObjectById(classId) as HeapClass
+    }
+  }
+
+  override fun objectExists(objectId: Long): Boolean {
+    return index.objectIdIsIndexed(objectId)
+  }
+
+  override fun findHeapDumpIndex(objectId: Long): Int {
+    val (_, indexedObject) = index.indexedObjectOrNull(objectId)?: throw IllegalArgumentException(
+      "Object id $objectId not found in heap dump."
+    )
+    val position = indexedObject.position
+
+    var countObjectsBefore = 1
+    index.indexedObjectSequence()
+      .forEach {
+        if (position > it.second.position) {
+          countObjectsBefore++
+        }
+      }
+    return countObjectsBefore
+  }
+
+  override fun findObjectByHeapDumpIndex(heapDumpIndex: Int): HeapObject {
+    require(heapDumpIndex in 1..objectCount) {
+      "$heapDumpIndex should be in range [1, $objectCount]"
+    }
+    val (objectId, _) = index.indexedObjectSequence().toList().sortedBy { it.second.position }[heapDumpIndex]
+    return findObjectById(objectId)
+  }
+
+  override fun close() {
+    reader.close()
+  }
+
+  internal fun classDumpStaticFields(indexedClass: IndexedClass): List<StaticFieldRecord> {
+    return index.classFieldsReader.classDumpStaticFields(indexedClass)
+  }
+
+  internal fun classDumpFields(indexedClass: IndexedClass): List<FieldRecord> {
+    return index.classFieldsReader.classDumpFields(indexedClass)
+  }
+
+  internal fun classDumpHasReferenceFields(indexedClass: IndexedClass): Boolean {
+    return index.classFieldsReader.classDumpHasReferenceFields(indexedClass)
+  }
+
+  internal fun fieldName(
+    classId: Long,
+    fieldRecord: FieldRecord
+  ): String {
+    return index.fieldName(classId, fieldRecord.nameStringId)
+  }
+
+  internal fun staticFieldName(
+    classId: Long,
+    fieldRecord: StaticFieldRecord
+  ): String {
+    return index.fieldName(classId, fieldRecord.nameStringId)
+  }
+
+  internal fun createFieldValuesReader(record: InstanceDumpRecord) =
+    FieldValuesReader(record, identifierByteSize)
+
+  internal fun className(classId: Long): String {
+    val hprofClassName = index.className(classId)
+    if (header.version != ANDROID) {
+      if (hprofClassName.startsWith('[')) {
+        val arrayCharLastIndex = hprofClassName.lastIndexOf('[')
+        val brackets = "[]".repeat(arrayCharLastIndex + 1)
+        return when (val typeChar = hprofClassName[arrayCharLastIndex + 1]) {
+          'L' -> {
+            val classNameStart = arrayCharLastIndex + 2
+            hprofClassName.substring(classNameStart, hprofClassName.length - 1) + brackets
+          }
+          'Z' -> "boolean$brackets"
+          'C' -> "char$brackets"
+          'F' -> "float$brackets"
+          'D' -> "double$brackets"
+          'B' -> "byte$brackets"
+          'S' -> "short$brackets"
+          'I' -> "int$brackets"
+          'J' -> "long$brackets"
+          else -> error("Unexpected type char $typeChar")
+        }
+      }
+    }
+    return hprofClassName
+  }
+
+  internal fun readObjectArrayDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedObjectArray
+  ): ObjectArrayDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      readObjectArrayDumpRecord()
+    }
+  }
+
+  internal fun readObjectArrayByteSize(
+    objectId: Long,
+    indexedObject: IndexedObjectArray
+  ): Int {
+    val cachedRecord = objectCache[objectId] as ObjectArrayDumpRecord?
+    if (cachedRecord != null) {
+      return cachedRecord.elementIds.size * identifierByteSize
+    }
+    val position = indexedObject.position + identifierByteSize + PrimitiveType.INT.byteSize
+    val size = PrimitiveType.INT.byteSize.toLong()
+    val thinRecordSize = reader.readRecord(position, size) {
+      readInt()
+    }
+    return thinRecordSize * identifierByteSize
+  }
+
+  internal fun readPrimitiveArrayDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedPrimitiveArray
+  ): PrimitiveArrayDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      readPrimitiveArrayDumpRecord()
+    }
+  }
+
+  internal fun readPrimitiveArrayByteSize(
+    objectId: Long,
+    indexedObject: IndexedPrimitiveArray
+  ): Int {
+    val cachedRecord = objectCache[objectId] as PrimitiveArrayDumpRecord?
+    if (cachedRecord != null) {
+      return when (cachedRecord) {
+        is BooleanArrayDump -> cachedRecord.array.size * PrimitiveType.BOOLEAN.byteSize
+        is CharArrayDump -> cachedRecord.array.size * PrimitiveType.CHAR.byteSize
+        is FloatArrayDump -> cachedRecord.array.size * PrimitiveType.FLOAT.byteSize
+        is DoubleArrayDump -> cachedRecord.array.size * PrimitiveType.DOUBLE.byteSize
+        is ByteArrayDump -> cachedRecord.array.size * PrimitiveType.BYTE.byteSize
+        is ShortArrayDump -> cachedRecord.array.size * PrimitiveType.SHORT.byteSize
+        is IntArrayDump -> cachedRecord.array.size * PrimitiveType.INT.byteSize
+        is LongArrayDump -> cachedRecord.array.size * PrimitiveType.LONG.byteSize
+      }
+    }
+    val position = indexedObject.position + identifierByteSize + PrimitiveType.INT.byteSize
+    val size = reader.readRecord(position, PrimitiveType.INT.byteSize.toLong()) {
+      readInt()
+    }
+    return size * indexedObject.primitiveType.byteSize
+  }
+
+  internal fun readClassDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedClass
+  ): ClassDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      readClassDumpRecord()
+    }
+  }
+
+  internal fun readInstanceDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedInstance
+  ): InstanceDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      readInstanceDumpRecord()
+    }
+  }
+
+  private fun <T : ObjectRecord> readObjectRecord(
+    objectId: Long,
+    indexedObject: IndexedObject,
+    readBlock: HprofRecordReader.() -> T
+  ): T {
+    val objectRecordOrNull = objectCache[objectId]
+    @Suppress("UNCHECKED_CAST")
+    if (objectRecordOrNull != null) {
+      return objectRecordOrNull as T
+    }
+    return reader.readRecord(indexedObject.position, indexedObject.recordSize) {
+      readBlock()
+    }.apply { objectCache.put(objectId, this) }
+  }
+
+  private fun wrapIndexedObject(
+    objectIndex: Int,
+    indexedObject: IndexedObject,
+    objectId: Long
+  ): HeapObject {
+    return when (indexedObject) {
+      is IndexedClass -> {
+        HeapClass(this, indexedObject, objectId, objectIndex)
+      }
+      is IndexedInstance -> {
+        HeapInstance(this, indexedObject, objectId, objectIndex)
+      }
+      is IndexedObjectArray -> {
+        HeapObjectArray(this, indexedObject, objectId, objectIndex)
+      }
+      is IndexedPrimitiveArray -> HeapPrimitiveArray(this, indexedObject, objectId, objectIndex)
+    }
+  }
+
+  companion object {
+
+    /**
+     * This is not a public API, it's only public so that we can evaluate the effectiveness of
+     * different cache size in tests in a different module.
+     *
+     * LRU cache size of 3000 is a sweet spot to balance hits vs memory usage.
+     * This is based on running InstrumentationLeakDetectorTest a bunch of time on a
+     * Pixel 2 XL API 28. Hit count was ~120K, miss count ~290K
+     */
+    var INTERNAL_LRU_CACHE_SIZE = 3000
+
+    /**
+     * A facility for opening a [CloseableHeapGraph] from a [File].
+     * This first parses the file headers with [HprofHeader.parseHeaderOf], then indexes the file content
+     * with [HprofIndex.indexRecordsOf] and then opens a [CloseableHeapGraph] from the index, which
+     * you are responsible for closing after using.
+     */
+    fun File.openHeapGraph(
+      proguardMapping: ProguardMapping? = null,
+      indexedGcRootTypes: Set<HprofRecordTag> = HprofIndex.defaultIndexedGcRootTags()
+    ): CloseableHeapGraph {
+      return FileSourceProvider(this).openHeapGraph(proguardMapping, indexedGcRootTypes)
+    }
+
+    fun DualSourceProvider.openHeapGraph(
+      proguardMapping: ProguardMapping? = null,
+      indexedGcRootTypes: Set<HprofRecordTag> = HprofIndex.defaultIndexedGcRootTags()
+    ): CloseableHeapGraph {
+      val header = openStreamingSource().use { HprofHeader.parseHeaderOf(it) }
+      val index = HprofIndex.indexRecordsOf(this, header, proguardMapping, indexedGcRootTypes)
+      return index.openHeapGraph()
+    }
+
+    @Deprecated(
+      "Replaced by HprofIndex.indexRecordsOf().openHeapGraph() or File.openHeapGraph()",
+      replaceWith = ReplaceWith(
+        "HprofIndex.indexRecordsOf(hprof, proguardMapping, indexedGcRootTypes)" +
+          ".openHeapGraph()"
+      )
+    )
+    fun indexHprof(
+      hprof: Hprof,
+      proguardMapping: ProguardMapping? = null,
+      indexedGcRootTypes: Set<KClass<out GcRoot>> = deprecatedDefaultIndexedGcRootTypes()
+    ): HeapGraph {
+      val indexedRootTags = indexedGcRootTypes.map {
+        when (it) {
+          Unknown::class -> HprofRecordTag.ROOT_UNKNOWN
+          JniGlobal::class -> HprofRecordTag.ROOT_JNI_GLOBAL
+          JniLocal::class -> HprofRecordTag.ROOT_JNI_LOCAL
+          JavaFrame::class -> HprofRecordTag.ROOT_JAVA_FRAME
+          NativeStack::class -> HprofRecordTag.ROOT_NATIVE_STACK
+          StickyClass::class -> HprofRecordTag.ROOT_STICKY_CLASS
+          ThreadBlock::class -> HprofRecordTag.ROOT_THREAD_BLOCK
+          MonitorUsed::class -> HprofRecordTag.ROOT_MONITOR_USED
+          ThreadObject::class -> HprofRecordTag.ROOT_THREAD_OBJECT
+          InternedString::class -> HprofRecordTag.ROOT_INTERNED_STRING
+          Finalizing::class -> HprofRecordTag.ROOT_FINALIZING
+          Debugger::class -> HprofRecordTag.ROOT_DEBUGGER
+          ReferenceCleanup::class -> HprofRecordTag.ROOT_REFERENCE_CLEANUP
+          VmInternal::class -> HprofRecordTag.ROOT_VM_INTERNAL
+          JniMonitor::class -> HprofRecordTag.ROOT_JNI_MONITOR
+          Unreachable::class -> HprofRecordTag.ROOT_UNREACHABLE
+          else -> error("Unknown root $it")
+        }
+      }.toSet()
+      val index =
+        HprofIndex.indexRecordsOf(
+          FileSourceProvider(hprof.file), hprof.header, proguardMapping, indexedRootTags
+        )
+      val graph = index.openHeapGraph()
+      hprof.attachClosable(graph)
+      return graph
+    }
+
+    private fun deprecatedDefaultIndexedGcRootTypes() = setOf(
+      JniGlobal::class,
+      JavaFrame::class,
+      JniLocal::class,
+      MonitorUsed::class,
+      NativeStack::class,
+      StickyClass::class,
+      ThreadBlock::class,
+      ThreadObject::class,
+      JniMonitor::class
+    )
+  }
+}
diff --git a/shark-graph/src/main/java/shark/HprofIndex.kt b/shark-graph/src/main/java/shark/HprofIndex.kt
new file mode 100644
index 00000000..db9d1622
--- /dev/null
+++ b/shark-graph/src/main/java/shark/HprofIndex.kt
@@ -0,0 +1,71 @@
+package shark
+
+import shark.internal.HprofInMemoryIndex
+import java.util.EnumSet
+
+/**
+ * An index on a Hprof file. See [openHeapGraph].
+ */
+class HprofIndex private constructor(
+  private val sourceProvider: RandomAccessSourceProvider,
+  private val header: HprofHeader,
+  private val index: HprofInMemoryIndex
+) {
+
+  /**
+   * Opens a [CloseableHeapGraph] which you can use to navigate the indexed hprof and then close.
+   */
+  fun openHeapGraph(): CloseableHeapGraph {
+    val reader = RandomAccessHprofReader.openReaderFor(sourceProvider, header)
+    return HprofHeapGraph(header, reader, index)
+  }
+
+  companion object {
+    /**
+     * Creates an in memory index of an hprof source provided by [hprofSourceProvider].
+     */
+    fun indexRecordsOf(
+      hprofSourceProvider: DualSourceProvider,
+      hprofHeader: HprofHeader,
+      proguardMapping: ProguardMapping? = null,
+      indexedGcRootTags: Set<HprofRecordTag> = defaultIndexedGcRootTags()
+    ): HprofIndex {
+      val reader = StreamingHprofReader.readerFor(hprofSourceProvider, hprofHeader)
+      val index = HprofInMemoryIndex.indexHprof(
+        reader = reader,
+        hprofHeader = hprofHeader,
+        proguardMapping = proguardMapping,
+        indexedGcRootTags = indexedGcRootTags
+      )
+      return HprofIndex(hprofSourceProvider, hprofHeader, index)
+    }
+
+    fun defaultIndexedGcRootTags(): EnumSet<HprofRecordTag> = EnumSet.of(
+      HprofRecordTag.ROOT_JNI_GLOBAL,
+      HprofRecordTag.ROOT_JAVA_FRAME,
+      HprofRecordTag.ROOT_JNI_LOCAL,
+      HprofRecordTag.ROOT_MONITOR_USED,
+      HprofRecordTag.ROOT_NATIVE_STACK,
+      HprofRecordTag.ROOT_STICKY_CLASS,
+      HprofRecordTag.ROOT_THREAD_BLOCK,
+      // ThreadObject points to threads, which we need to find the thread that a JavaLocalPattern
+      // belongs to
+      HprofRecordTag.ROOT_THREAD_OBJECT,
+      HprofRecordTag.ROOT_JNI_MONITOR
+      /*
+      Not included here:
+
+      VmInternal: Ignoring because we've got 150K of it, but is this the right thing
+      to do? What's VmInternal exactly? History does not go further than
+      https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
+      We should log to figure out what objects VmInternal points to.
+
+      ReferenceCleanup: We used to keep it, but the name doesn't seem like it should create a leak.
+
+      Unknown: it's unknown, should we care?
+
+      We definitely don't care about those for leak finding: InternedString, Finalizing, Debugger, Unreachable
+       */
+    )
+  }
+}
diff --git a/shark-graph/src/main/java/shark/internal/ByteSubArray.kt b/shark-graph/src/main/java/shark/internal/ByteSubArray.kt
new file mode 100644
index 00000000..df9ad3b0
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/ByteSubArray.kt
@@ -0,0 +1,106 @@
+package shark.internal
+
+/**
+ * Provides read access to a sub part of a larger array.
+ */
+internal class ByteSubArray(
+  private val array: ByteArray,
+  private val rangeStart: Int,
+  size: Int,
+  private val longIdentifiers: Boolean
+) {
+
+  private val endInclusive = size - 1
+
+  private var currentIndex = 0
+
+  fun readByte(): Byte {
+    val index = currentIndex
+    currentIndex++
+    require(index in 0..endInclusive) {
+      "Index $index should be between 0 and $endInclusive"
+    }
+    return array[rangeStart + index]
+  }
+
+  fun readId(): Long {
+    return if (longIdentifiers) {
+      readLong()
+    } else {
+      readInt().toLong()
+    }
+  }
+
+  fun readInt(): Int {
+    val index = currentIndex
+    currentIndex += 4
+    require(index >= 0 && index <= endInclusive - 3) {
+      "Index $index should be between 0 and ${endInclusive - 3}"
+    }
+    return array.readInt(rangeStart + index)
+  }
+
+  fun readTruncatedLong(byteCount: Int): Long {
+    val index = currentIndex
+    currentIndex += byteCount
+    require(index >= 0 && index <= endInclusive - (byteCount - 1)) {
+      "Index $index should be between 0 and ${endInclusive - (byteCount - 1)}"
+    }
+    var pos = rangeStart + index
+    val array = array
+
+    var value = 0L
+
+    var shift = (byteCount - 1) * 8
+    while (shift >= 8) {
+      value = value or (array[pos++] and 0xffL shl shift)
+      shift -= 8
+    }
+    value = value or (array[pos] and 0xffL)
+    return value
+  }
+
+  fun readLong(): Long {
+    val index = currentIndex
+    currentIndex += 8
+    require(index >= 0 && index <= endInclusive - 7) {
+      "Index $index should be between 0 and ${endInclusive - 7}"
+    }
+    return array.readLong(rangeStart + index)
+  }
+}
+
+internal fun ByteArray.readShort(index: Int): Short {
+  var pos = index
+  val array = this
+  val valueAsInt = array[pos++] and 0xff shl 8 or (array[pos] and 0xff)
+  return valueAsInt.toShort()
+}
+
+internal fun ByteArray.readInt(index: Int): Int {
+  var pos = index
+  val array = this
+  return (array[pos++] and 0xff shl 24
+    or (array[pos++] and 0xff shl 16)
+    or (array[pos++] and 0xff shl 8)
+    or (array[pos] and 0xff))
+}
+
+internal fun ByteArray.readLong(index: Int): Long {
+  var pos = index
+  val array = this
+  return (array[pos++] and 0xffL shl 56
+    or (array[pos++] and 0xffL shl 48)
+    or (array[pos++] and 0xffL shl 40)
+    or (array[pos++] and 0xffL shl 32)
+    or (array[pos++] and 0xffL shl 24)
+    or (array[pos++] and 0xffL shl 16)
+    or (array[pos++] and 0xffL shl 8)
+    or (array[pos] and 0xffL))
+}
+
+@Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+private inline infix fun Byte.and(other: Long): Long = toLong() and other
+
+@Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+private inline infix fun Byte.and(other: Int): Int = toInt() and other
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/ClassFieldsReader.kt b/shark-graph/src/main/java/shark/internal/ClassFieldsReader.kt
new file mode 100644
index 00000000..bb603949
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/ClassFieldsReader.kt
@@ -0,0 +1,193 @@
+package shark.internal
+
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import shark.PrimitiveType
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.BYTE
+import shark.PrimitiveType.CHAR
+import shark.PrimitiveType.DOUBLE
+import shark.PrimitiveType.FLOAT
+import shark.PrimitiveType.INT
+import shark.PrimitiveType.LONG
+import shark.PrimitiveType.SHORT
+import shark.ValueHolder
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+import shark.internal.IndexedObject.IndexedClass
+
+internal class ClassFieldsReader(
+  private val identifierByteSize: Int,
+  private val classFieldBytes: ByteArray
+) {
+
+  fun classDumpStaticFields(indexedClass: IndexedClass): List<StaticFieldRecord> {
+    return read(initialPosition = indexedClass.fieldsIndex) {
+      val staticFieldCount = readUnsignedShort()
+      val staticFields = ArrayList<StaticFieldRecord>(staticFieldCount)
+      for (i in 0 until staticFieldCount) {
+        val nameStringId = readId()
+        val type = readUnsignedByte()
+        val value = readValue(type)
+        staticFields.add(
+          StaticFieldRecord(
+            nameStringId = nameStringId,
+            type = type,
+            value = value
+          )
+        )
+      }
+      staticFields
+    }
+  }
+
+  fun classDumpFields(indexedClass: IndexedClass): List<FieldRecord> {
+    return read(initialPosition = indexedClass.fieldsIndex) {
+      skipStaticFields()
+
+      val fieldCount = readUnsignedShort()
+      val fields = ArrayList<FieldRecord>(fieldCount)
+      for (i in 0 until fieldCount) {
+        fields.add(FieldRecord(nameStringId = readId(), type = readUnsignedByte()))
+      }
+      fields
+    }
+  }
+
+  fun classDumpHasReferenceFields(indexedClass: IndexedClass): Boolean {
+    return read(initialPosition = indexedClass.fieldsIndex) {
+      skipStaticFields()
+      val fieldCount = readUnsignedShort()
+      for (i in 0 until fieldCount) {
+        position += identifierByteSize
+        val type = readUnsignedByte()
+        if (type == PrimitiveType.REFERENCE_HPROF_TYPE) {
+          return@read true
+        }
+      }
+      return@read false
+    }
+  }
+
+  private fun <R> read(
+    initialPosition: Int,
+    block: ReadInFlight.() -> R
+  ): R {
+    val readInFlight = ReadInFlight()
+    readInFlight.position = initialPosition
+    return readInFlight.run(block)
+  }
+
+  private inner class ReadInFlight {
+    var position = 0
+
+    fun skipStaticFields() {
+      val staticFieldCount = readUnsignedShort()
+      for (i in 0 until staticFieldCount) {
+        position += identifierByteSize
+        val type = readUnsignedByte()
+        position += if (type == PrimitiveType.REFERENCE_HPROF_TYPE) {
+          identifierByteSize
+        } else {
+          PrimitiveType.byteSizeByHprofType.getValue(type)
+        }
+      }
+    }
+
+    fun readValue(type: Int): ValueHolder {
+      return when (type) {
+        PrimitiveType.REFERENCE_HPROF_TYPE -> ReferenceHolder(readId())
+        BOOLEAN_TYPE -> BooleanHolder(readBoolean())
+        CHAR_TYPE -> CharHolder(readChar())
+        FLOAT_TYPE -> FloatHolder(readFloat())
+        DOUBLE_TYPE -> DoubleHolder(readDouble())
+        BYTE_TYPE -> ByteHolder(readByte())
+        SHORT_TYPE -> ShortHolder(readShort())
+        INT_TYPE -> IntHolder(readInt())
+        LONG_TYPE -> LongHolder(readLong())
+        else -> throw IllegalStateException("Unknown type $type")
+      }
+    }
+
+    fun readByte(): Byte {
+      return classFieldBytes[position++]
+    }
+
+    fun readInt(): Int {
+      return (classFieldBytes[position++].toInt() and 0xff shl 24) or
+        (classFieldBytes[position++].toInt() and 0xff shl 16) or
+        (classFieldBytes[position++].toInt() and 0xff shl 8) or
+        (classFieldBytes[position++].toInt() and 0xff)
+    }
+
+    fun readLong(): Long {
+      return (classFieldBytes[position++].toLong() and 0xff shl 56) or
+        (classFieldBytes[position++].toLong() and 0xff shl 48) or
+        (classFieldBytes[position++].toLong() and 0xff shl 40) or
+        (classFieldBytes[position++].toLong() and 0xff shl 32) or
+        (classFieldBytes[position++].toLong() and 0xff shl 24) or
+        (classFieldBytes[position++].toLong() and 0xff shl 16) or
+        (classFieldBytes[position++].toLong() and 0xff shl 8) or
+        (classFieldBytes[position++].toLong() and 0xff)
+    }
+
+    fun readShort(): Short {
+      return ((classFieldBytes[position++].toInt() and 0xff shl 8) or
+        (classFieldBytes[position++].toInt() and 0xff)).toShort()
+    }
+
+    fun readUnsignedShort(): Int {
+      return readShort().toInt() and 0xFFFF
+    }
+
+    fun readUnsignedByte(): Int {
+      return readByte().toInt() and 0xFF
+    }
+
+    fun readId(): Long {
+      // As long as we don't interpret IDs, reading signed values here is fine.
+      return when (identifierByteSize) {
+        1 -> readByte().toLong()
+        2 -> readShort().toLong()
+        4 -> readInt().toLong()
+        8 -> readLong()
+        else -> throw IllegalArgumentException("ID Length must be 1, 2, 4, or 8")
+      }
+    }
+
+    fun readBoolean(): Boolean {
+      return readByte()
+        .toInt() != 0
+    }
+
+    fun readChar(): Char {
+      return readShort().toChar()
+    }
+
+    fun readFloat(): Float {
+      return Float.fromBits(readInt())
+    }
+
+    fun readDouble(): Double {
+      return Double.fromBits(readLong())
+    }
+  }
+
+  companion object {
+    private val BOOLEAN_TYPE = BOOLEAN.hprofType
+    private val CHAR_TYPE = CHAR.hprofType
+    private val FLOAT_TYPE = FLOAT.hprofType
+    private val DOUBLE_TYPE = DOUBLE.hprofType
+    private val BYTE_TYPE = BYTE.hprofType
+    private val SHORT_TYPE = SHORT.hprofType
+    private val INT_TYPE = INT.hprofType
+    private val LONG_TYPE = LONG.hprofType
+  }
+}
diff --git a/shark-graph/src/main/java/shark/internal/FieldValuesReader.kt b/shark-graph/src/main/java/shark/internal/FieldValuesReader.kt
new file mode 100644
index 00000000..2f1d54a0
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/FieldValuesReader.kt
@@ -0,0 +1,112 @@
+package shark.internal
+
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.PrimitiveType
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.BYTE
+import shark.PrimitiveType.CHAR
+import shark.PrimitiveType.DOUBLE
+import shark.PrimitiveType.FLOAT
+import shark.PrimitiveType.INT
+import shark.PrimitiveType.LONG
+import shark.PrimitiveType.SHORT
+import shark.ValueHolder
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+
+internal class FieldValuesReader(
+  private val record: InstanceDumpRecord,
+  private val identifierByteSize: Int
+) {
+
+  private var position = 0
+
+  fun readValue(field: FieldRecord): ValueHolder {
+    return when (field.type) {
+      PrimitiveType.REFERENCE_HPROF_TYPE -> ReferenceHolder(readId())
+      BOOLEAN_TYPE -> BooleanHolder(readBoolean())
+      CHAR_TYPE -> CharHolder(readChar())
+      FLOAT_TYPE -> FloatHolder(readFloat())
+      DOUBLE_TYPE -> DoubleHolder(readDouble())
+      BYTE_TYPE -> ByteHolder(readByte())
+      SHORT_TYPE -> ShortHolder(readShort())
+      INT_TYPE -> IntHolder(readInt())
+      LONG_TYPE -> LongHolder(readLong())
+      else -> throw IllegalStateException("Unknown type ${field.type}")
+    }
+  }
+
+  private fun readId(): Long {
+    // As long as we don't interpret IDs, reading signed values here is fine.
+    return when (identifierByteSize) {
+      1 -> readByte().toLong()
+      2 -> readShort().toLong()
+      4 -> readInt().toLong()
+      8 -> readLong()
+      else -> throw IllegalArgumentException("ID Length must be 1, 2, 4, or 8")
+    }
+  }
+
+  private fun readBoolean(): Boolean {
+    val value = record.fieldValues[position]
+    position++
+    return value != 0.toByte()
+  }
+
+  private fun readByte(): Byte {
+    val value = record.fieldValues[position]
+    position++
+    return value
+  }
+
+  private fun readInt(): Int {
+    val value = record.fieldValues.readInt(position)
+    position += 4
+    return value
+  }
+
+  private fun readShort(): Short {
+    val value = record.fieldValues.readShort(position)
+    position += 2
+    return value
+  }
+
+  private fun readLong(): Long {
+    val value = record.fieldValues.readLong(position)
+    position += 8
+    return value
+  }
+
+  private fun readFloat(): Float {
+    return Float.fromBits(readInt())
+  }
+
+  private fun readDouble(): Double {
+    return Double.fromBits(readLong())
+  }
+
+  private fun readChar(): Char {
+    val string = String(record.fieldValues, position, 2, Charsets.UTF_16BE)
+    position += 2
+    return string[0]
+  }
+
+  companion object {
+    private val BOOLEAN_TYPE = BOOLEAN.hprofType
+    private val CHAR_TYPE = CHAR.hprofType
+    private val FLOAT_TYPE = FLOAT.hprofType
+    private val DOUBLE_TYPE = DOUBLE.hprofType
+    private val BYTE_TYPE = BYTE.hprofType
+    private val SHORT_TYPE = SHORT.hprofType
+    private val INT_TYPE = INT.hprofType
+    private val LONG_TYPE = LONG.hprofType
+  }
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
new file mode 100644
index 00000000..486f9a71
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
@@ -0,0 +1,781 @@
+package shark.internal
+
+import java.util.EnumSet
+import kotlin.math.max
+import shark.GcRoot
+import shark.GcRoot.StickyClass
+import shark.HprofHeader
+import shark.HprofRecordReader
+import shark.HprofRecordTag
+import shark.HprofRecordTag.CLASS_DUMP
+import shark.HprofRecordTag.INSTANCE_DUMP
+import shark.HprofRecordTag.LOAD_CLASS
+import shark.HprofRecordTag.OBJECT_ARRAY_DUMP
+import shark.HprofRecordTag.PRIMITIVE_ARRAY_DUMP
+import shark.HprofRecordTag.ROOT_DEBUGGER
+import shark.HprofRecordTag.ROOT_FINALIZING
+import shark.HprofRecordTag.ROOT_INTERNED_STRING
+import shark.HprofRecordTag.ROOT_JAVA_FRAME
+import shark.HprofRecordTag.ROOT_JNI_GLOBAL
+import shark.HprofRecordTag.ROOT_JNI_LOCAL
+import shark.HprofRecordTag.ROOT_JNI_MONITOR
+import shark.HprofRecordTag.ROOT_MONITOR_USED
+import shark.HprofRecordTag.ROOT_NATIVE_STACK
+import shark.HprofRecordTag.ROOT_REFERENCE_CLEANUP
+import shark.HprofRecordTag.ROOT_STICKY_CLASS
+import shark.HprofRecordTag.ROOT_THREAD_BLOCK
+import shark.HprofRecordTag.ROOT_THREAD_OBJECT
+import shark.HprofRecordTag.ROOT_UNKNOWN
+import shark.HprofRecordTag.ROOT_UNREACHABLE
+import shark.HprofRecordTag.ROOT_VM_INTERNAL
+import shark.HprofRecordTag.STRING_IN_UTF8
+import shark.HprofVersion
+import shark.HprofVersion.ANDROID
+import shark.OnHprofRecordTagListener
+import shark.PrimitiveType
+import shark.PrimitiveType.INT
+import shark.ProguardMapping
+import shark.StreamingHprofReader
+import shark.ValueHolder
+import shark.internal.IndexedObject.IndexedClass
+import shark.internal.IndexedObject.IndexedInstance
+import shark.internal.IndexedObject.IndexedObjectArray
+import shark.internal.IndexedObject.IndexedPrimitiveArray
+import shark.internal.hppc.IntObjectPair
+import shark.internal.hppc.LongLongScatterMap
+import shark.internal.hppc.LongObjectPair
+import shark.internal.hppc.LongObjectScatterMap
+import shark.internal.hppc.LongScatterSet
+import shark.internal.hppc.to
+
+/**
+ * This class is not thread safe, should be used from a single thread.
+ */
+internal class HprofInMemoryIndex private constructor(
+  private val positionSize: Int,
+  private val hprofStringCache: LongObjectScatterMap<String>,
+  private val classNames: LongLongScatterMap,
+  private val classIndex: SortedBytesMap,
+  private val instanceIndex: SortedBytesMap,
+  private val objectArrayIndex: SortedBytesMap,
+  private val primitiveArrayIndex: SortedBytesMap,
+  private val gcRoots: List<GcRoot>,
+  private val proguardMapping: ProguardMapping?,
+  private val bytesForClassSize: Int,
+  private val bytesForInstanceSize: Int,
+  private val bytesForObjectArraySize: Int,
+  private val bytesForPrimitiveArraySize: Int,
+  private val useForwardSlashClassPackageSeparator: Boolean,
+  val classFieldsReader: ClassFieldsReader,
+  private val classFieldsIndexSize: Int,
+  private val stickyClassGcRootIds: LongScatterSet,
+) {
+
+  val classCount: Int
+    get() = classIndex.size
+
+  val instanceCount: Int
+    get() = instanceIndex.size
+
+  val objectArrayCount: Int
+    get() = objectArrayIndex.size
+
+  val primitiveArrayCount: Int
+    get() = primitiveArrayIndex.size
+
+  fun fieldName(
+    classId: Long,
+    id: Long
+  ): String {
+    val fieldNameString = hprofStringById(id)
+    return proguardMapping?.let {
+      val classNameStringId = classNames[classId]
+      val classNameString = hprofStringById(classNameStringId)
+      proguardMapping.deobfuscateFieldName(classNameString, fieldNameString)
+    } ?: fieldNameString
+  }
+
+  fun className(classId: Long): String {
+    // String, primitive types
+    val classNameStringId = classNames[classId]
+    val classNameString = hprofStringById(classNameStringId)
+    return (proguardMapping?.deobfuscateClassName(classNameString) ?: classNameString).run {
+      if (useForwardSlashClassPackageSeparator) {
+        // JVM heap dumps use "/" for package separators (vs "." for Android heap dumps)
+        replace('/', '.')
+      } else this
+    }
+  }
+
+  /**
+   * Returns the first class that matches the provided name, prioritizing system classes (as held
+   * by sticky class gc roots).
+   *
+   * On Android, all currently loaded classes are sticky. The heap dump may also contain classes
+   * that were unloaded but not garbage collected yet, leading to classes being present twice
+   * in the heap dump. To work around that we prioritize classes that are held by a sticky class GC
+   * root.
+   */
+  fun classId(className: String): Long? {
+    val internalClassName = if (useForwardSlashClassPackageSeparator) {
+      // JVM heap dumps use "/" for package separators (vs "." for Android heap dumps)
+      className.replace('.', '/')
+    } else className
+
+    // Note: this performs two linear scans over arrays
+    val hprofStringId = hprofStringCache.entrySequence()
+      .firstOrNull { it.second == internalClassName }
+      ?.first ?: return null
+
+    val classNamesIterator = classNames.entrySequence().iterator()
+
+    var firstNonStickyMatchingClass: Long? = null
+    while(classNamesIterator.hasNext()) {
+      val (classId, classNameStringId) = classNamesIterator.next()
+      if (hprofStringId == classNameStringId) {
+        if (classId in stickyClassGcRootIds) {
+          return classId
+        } else {
+          firstNonStickyMatchingClass = classId
+        }
+      }
+    }
+    return firstNonStickyMatchingClass
+  }
+
+  fun indexedClassSequence(): Sequence<LongObjectPair<IndexedClass>> {
+    return classIndex.entrySequence()
+      .map {
+        val id = it.first
+        val array = it.second
+        id to array.readClass()
+      }
+  }
+
+  fun indexedInstanceSequence(): Sequence<LongObjectPair<IndexedInstance>> {
+    return instanceIndex.entrySequence()
+      .map {
+        val id = it.first
+        val array = it.second
+        val instance = IndexedInstance(
+          position = array.readTruncatedLong(positionSize),
+          classId = array.readId(),
+          recordSize = array.readTruncatedLong(bytesForInstanceSize)
+        )
+        id to instance
+      }
+  }
+
+  fun indexedObjectArraySequence(): Sequence<LongObjectPair<IndexedObjectArray>> {
+    return objectArrayIndex.entrySequence()
+      .map {
+        val id = it.first
+        val array = it.second
+        val objectArray = IndexedObjectArray(
+          position = array.readTruncatedLong(positionSize),
+          arrayClassId = array.readId(),
+          recordSize = array.readTruncatedLong(bytesForObjectArraySize)
+        )
+        id to objectArray
+      }
+  }
+
+  fun indexedPrimitiveArraySequence(): Sequence<LongObjectPair<IndexedPrimitiveArray>> {
+    return primitiveArrayIndex.entrySequence()
+      .map {
+        val id = it.first
+        val array = it.second
+
+        val primitiveArray = IndexedPrimitiveArray(
+          position = array.readTruncatedLong(positionSize),
+          primitiveType = PrimitiveType.values()[array.readByte()
+            .toInt()],
+          recordSize = array.readTruncatedLong(bytesForPrimitiveArraySize)
+        )
+        id to primitiveArray
+      }
+  }
+
+  fun indexedObjectSequence(): Sequence<LongObjectPair<IndexedObject>> {
+    return indexedClassSequence() +
+      indexedInstanceSequence() +
+      indexedObjectArraySequence() +
+      indexedPrimitiveArraySequence()
+  }
+
+  fun gcRoots(): List<GcRoot> {
+    return gcRoots
+  }
+
+  fun objectAtIndex(index: Int): LongObjectPair<IndexedObject> {
+    require(index > 0)
+    if (index < classIndex.size) {
+      val objectId = classIndex.keyAt(index)
+      val array = classIndex.getAtIndex(index)
+      return objectId to array.readClass()
+    }
+    var shiftedIndex = index - classIndex.size
+    if (shiftedIndex < instanceIndex.size) {
+      val objectId = instanceIndex.keyAt(shiftedIndex)
+      val array = instanceIndex.getAtIndex(shiftedIndex)
+      return objectId to IndexedInstance(
+        position = array.readTruncatedLong(positionSize),
+        classId = array.readId(),
+        recordSize = array.readTruncatedLong(bytesForInstanceSize)
+      )
+    }
+    shiftedIndex -= instanceIndex.size
+    if (shiftedIndex < objectArrayIndex.size) {
+      val objectId = objectArrayIndex.keyAt(shiftedIndex)
+      val array = objectArrayIndex.getAtIndex(shiftedIndex)
+      return objectId to IndexedObjectArray(
+        position = array.readTruncatedLong(positionSize),
+        arrayClassId = array.readId(),
+        recordSize = array.readTruncatedLong(bytesForObjectArraySize)
+      )
+    }
+    shiftedIndex -= objectArrayIndex.size
+    require(index < primitiveArrayIndex.size)
+    val objectId = primitiveArrayIndex.keyAt(shiftedIndex)
+    val array = primitiveArrayIndex.getAtIndex(shiftedIndex)
+    return objectId to IndexedPrimitiveArray(
+      position = array.readTruncatedLong(positionSize),
+      primitiveType = PrimitiveType.values()[array.readByte()
+        .toInt()],
+      recordSize = array.readTruncatedLong(bytesForPrimitiveArraySize)
+    )
+  }
+
+  @Suppress("ReturnCount")
+  fun indexedObjectOrNull(objectId: Long): IntObjectPair<IndexedObject>? {
+    var index = classIndex.indexOf(objectId)
+    if (index >= 0) {
+      val array = classIndex.getAtIndex(index)
+      return index to array.readClass()
+    }
+    index = instanceIndex.indexOf(objectId)
+    if (index >= 0) {
+      val array = instanceIndex.getAtIndex(index)
+      return classIndex.size + index to IndexedInstance(
+        position = array.readTruncatedLong(positionSize),
+        classId = array.readId(),
+        recordSize = array.readTruncatedLong(bytesForInstanceSize)
+      )
+    }
+    index = objectArrayIndex.indexOf(objectId)
+    if (index >= 0) {
+      val array = objectArrayIndex.getAtIndex(index)
+      return classIndex.size + instanceIndex.size + index to IndexedObjectArray(
+        position = array.readTruncatedLong(positionSize),
+        arrayClassId = array.readId(),
+        recordSize = array.readTruncatedLong(bytesForObjectArraySize)
+      )
+    }
+    index = primitiveArrayIndex.indexOf(objectId)
+    if (index >= 0) {
+      val array = primitiveArrayIndex.getAtIndex(index)
+      return classIndex.size + instanceIndex.size + index + primitiveArrayIndex.size to IndexedPrimitiveArray(
+        position = array.readTruncatedLong(positionSize),
+        primitiveType = PrimitiveType.values()[array.readByte()
+          .toInt()],
+        recordSize = array.readTruncatedLong(bytesForPrimitiveArraySize)
+      )
+    }
+    return null
+  }
+
+  private fun ByteSubArray.readClass(): IndexedClass {
+    val position = readTruncatedLong(positionSize)
+    val superclassId = readId()
+    val instanceSize = readInt()
+
+    val recordSize = readTruncatedLong(bytesForClassSize)
+    val fieldsIndex = readTruncatedLong(classFieldsIndexSize).toInt()
+
+    return IndexedClass(
+      position = position,
+      superclassId = superclassId,
+      instanceSize = instanceSize,
+      recordSize = recordSize,
+      fieldsIndex = fieldsIndex
+    )
+  }
+
+  @Suppress("ReturnCount")
+  fun objectIdIsIndexed(objectId: Long): Boolean {
+    if (classIndex[objectId] != null) {
+      return true
+    }
+    if (instanceIndex[objectId] != null) {
+      return true
+    }
+    if (objectArrayIndex[objectId] != null) {
+      return true
+    }
+    if (primitiveArrayIndex[objectId] != null) {
+      return true
+    }
+    return false
+  }
+
+  private fun hprofStringById(id: Long): String {
+    return hprofStringCache[id] ?: throw IllegalArgumentException("Hprof string $id not in cache")
+  }
+
+  private class Builder(
+    longIdentifiers: Boolean,
+    maxPosition: Long,
+    classCount: Int,
+    instanceCount: Int,
+    objectArrayCount: Int,
+    primitiveArrayCount: Int,
+    val bytesForClassSize: Int,
+    val bytesForInstanceSize: Int,
+    val bytesForObjectArraySize: Int,
+    val bytesForPrimitiveArraySize: Int,
+    val classFieldsTotalBytes: Int,
+    val stickyClassGcRootIds: LongScatterSet,
+  ) : OnHprofRecordTagListener {
+
+    private val identifierSize = if (longIdentifiers) 8 else 4
+    private val positionSize = byteSizeForUnsigned(maxPosition)
+    private val classFieldsIndexSize = byteSizeForUnsigned(classFieldsTotalBytes.toLong())
+
+    /**
+     * Map of string id to string
+     * This currently keeps all the hprof strings that we could care about: class names,
+     * static field names and instance fields names
+     */
+    // TODO Replacing with a radix trie reversed into a sparse array of long to trie leaf could save
+    // memory. Can be stored as 3 arrays: array of keys, array of values which are indexes into
+    // a large array of string bytes. Each "entry" consists of a size, the index of the previous
+    // segment and then the segment content.
+
+    private val hprofStringCache = LongObjectScatterMap<String>()
+
+    /**
+     * class id to string id
+     */
+    private val classNames = LongLongScatterMap(expectedElements = classCount)
+
+    private val classFieldBytes = ByteArray(classFieldsTotalBytes)
+
+    private var classFieldsIndex = 0
+
+    private val classIndex = UnsortedByteEntries(
+      bytesPerValue = positionSize + identifierSize + 4 + bytesForClassSize + classFieldsIndexSize,
+      longIdentifiers = longIdentifiers,
+      initialCapacity = classCount
+    )
+    private val instanceIndex = UnsortedByteEntries(
+      bytesPerValue = positionSize + identifierSize + bytesForInstanceSize,
+      longIdentifiers = longIdentifiers,
+      initialCapacity = instanceCount
+    )
+    private val objectArrayIndex = UnsortedByteEntries(
+      bytesPerValue = positionSize + identifierSize + bytesForObjectArraySize,
+      longIdentifiers = longIdentifiers,
+      initialCapacity = objectArrayCount
+    )
+    private val primitiveArrayIndex = UnsortedByteEntries(
+      bytesPerValue = positionSize + 1 + bytesForPrimitiveArraySize,
+      longIdentifiers = longIdentifiers,
+      initialCapacity = primitiveArrayCount
+    )
+
+    // Pre seeding gc roots with the sticky class gc roots we've already parsed.
+    private val gcRoots: MutableList<GcRoot> = ArrayList<GcRoot>(stickyClassGcRootIds.size()).apply {
+      stickyClassGcRootIds.elementSequence().forEach {classId ->
+        add(StickyClass(classId))
+      }
+    }
+
+    private fun HprofRecordReader.copyToClassFields(byteCount: Int) {
+      for (i in 1..byteCount) {
+        classFieldBytes[classFieldsIndex++] = readByte()
+      }
+    }
+
+    private fun lastClassFieldsShort() =
+      ((classFieldBytes[classFieldsIndex - 2].toInt() and 0xff shl 8) or
+        (classFieldBytes[classFieldsIndex - 1].toInt() and 0xff)).toShort()
+
+    @Suppress("LongMethod")
+    override fun onHprofRecord(
+      tag: HprofRecordTag,
+      length: Long,
+      reader: HprofRecordReader
+    ) {
+      when (tag) {
+        STRING_IN_UTF8 -> {
+          hprofStringCache[reader.readId()] = reader.readUtf8(length - identifierSize)
+        }
+        LOAD_CLASS -> {
+          // classSerialNumber
+          reader.skip(INT.byteSize)
+          val id = reader.readId()
+          // stackTraceSerialNumber
+          reader.skip(INT.byteSize)
+          val classNameStringId = reader.readId()
+          classNames[id] = classNameStringId
+        }
+        ROOT_UNKNOWN -> {
+          reader.readUnknownGcRootRecord().apply {
+            if (id != ValueHolder.NULL_REFERENCE) {
+              gcRoots += this
+            }
+          }
+        }
+        ROOT_JNI_GLOBAL -> {
+          reader.readJniGlobalGcRootRecord().apply {
+            if (id != ValueHolder.NULL_REFERENCE) {
+              gcRoots += this
+            }
+          }
+        }
+        ROOT_JNI_LOCAL -> {
+          reader.readJniLocalGcRootRecord().apply {
+            if (id != ValueHolder.NULL_REFERENCE) {
+              gcRoots += this
+            }
+          }
+        }
+        ROOT_JAVA_FRAME -> {
+          reader.readJavaFrameGcRootRecord().apply {
+            if (id != ValueHolder.NULL_REFERENCE) {
+              gcRoots += this
+            }
+          }
+        }
+        ROOT_NATIVE_STACK -> {
+          reader.readNativeStackGcRootRecord().apply {
+            if (id != ValueHolder.NULL_REFERENCE) {
+              gcRoots += this
+            }
+          }
+        }
+        ROOT_STICKY_CLASS -> {
+          // We already parse these gc roots in the initial scan.
+          reader.skipId()
+        }
+        ROOT_THREAD_BLOCK -> {
+          reader.readThreadBlockGcRootRecord().apply {
+            if (id != ValueHolder.NULL_REFERENCE) {
+              gcRoots += this
+            }
+          }
+        }
+        ROOT_MONITOR_USED -> {
+          reader.readMonitorUsedGcRootRecord().apply {
+            if (id != ValueHolder.NULL_REFERENCE) {
+              gcRoots += this
+            }
+          }
+        }
+        ROOT_THREAD_OBJECT -> {
+          reader.readThreadObjectGcRootRecord().apply {
+            if (id != ValueHolder.NULL_REFERENCE) {
+              gcRoots += this
+            }
+          }
+        }
+        ROOT_INTERNED_STRING -> {
+          reader.readInternedStringGcRootRecord().apply {
+            if (id != ValueHolder.NULL_REFERENCE) {
+              gcRoots += this
+            }
+          }
+        }
+        ROOT_FINALIZING -> {
+          reader.readFinalizingGcRootRecord().apply {
+            if (id != ValueHolder.NULL_REFERENCE) {
+              gcRoots += this
+            }
+          }
+        }
+        ROOT_DEBUGGER -> {
+          reader.readDebuggerGcRootRecord().apply {
+            if (id != ValueHolder.NULL_REFERENCE) {
+              gcRoots += this
+            }
+          }
+        }
+        ROOT_REFERENCE_CLEANUP -> {
+          reader.readReferenceCleanupGcRootRecord().apply {
+            if (id != ValueHolder.NULL_REFERENCE) {
+              gcRoots += this
+            }
+          }
+        }
+        ROOT_VM_INTERNAL -> {
+          reader.readVmInternalGcRootRecord().apply {
+            if (id != ValueHolder.NULL_REFERENCE) {
+              gcRoots += this
+            }
+          }
+        }
+        ROOT_JNI_MONITOR -> {
+          reader.readJniMonitorGcRootRecord().apply {
+            if (id != ValueHolder.NULL_REFERENCE) {
+              gcRoots += this
+            }
+          }
+        }
+        ROOT_UNREACHABLE -> {
+          reader.readUnreachableGcRootRecord().apply {
+            if (id != ValueHolder.NULL_REFERENCE) {
+              gcRoots += this
+            }
+          }
+        }
+        CLASS_DUMP -> {
+          val bytesReadStart = reader.bytesRead
+          val id = reader.readId()
+          // stack trace serial number
+          reader.skip(INT.byteSize)
+          val superclassId = reader.readId()
+          reader.skip(5 * identifierSize)
+
+          // instance size (in bytes)
+          // Useful to compute retained size
+          val instanceSize = reader.readInt()
+
+          reader.skipClassDumpConstantPool()
+
+          val startPosition = classFieldsIndex
+
+          val bytesReadFieldStart = reader.bytesRead
+
+          reader.copyToClassFields(2)
+          val staticFieldCount = lastClassFieldsShort().toInt() and 0xFFFF
+          for (i in 0 until staticFieldCount) {
+            reader.copyToClassFields(identifierSize)
+            reader.copyToClassFields(1)
+            val type = classFieldBytes[classFieldsIndex - 1].toInt() and 0xff
+            if (type == PrimitiveType.REFERENCE_HPROF_TYPE) {
+              reader.copyToClassFields(identifierSize)
+            } else {
+              reader.copyToClassFields(PrimitiveType.byteSizeByHprofType.getValue(type))
+            }
+          }
+
+          reader.copyToClassFields(2)
+          val fieldCount = lastClassFieldsShort().toInt() and 0xFFFF
+          for (i in 0 until fieldCount) {
+            reader.copyToClassFields(identifierSize)
+            reader.copyToClassFields(1)
+          }
+
+          val fieldsSize = (reader.bytesRead - bytesReadFieldStart).toInt()
+          val recordSize = reader.bytesRead - bytesReadStart
+
+          classIndex.append(id)
+            .apply {
+              writeTruncatedLong(bytesReadStart, positionSize)
+              writeId(superclassId)
+              writeInt(instanceSize)
+              writeTruncatedLong(recordSize, bytesForClassSize)
+              writeTruncatedLong(startPosition.toLong(), classFieldsIndexSize)
+            }
+          require(startPosition + fieldsSize == classFieldsIndex) {
+            "Expected $classFieldsIndex to have moved by $fieldsSize and be equal to ${startPosition + fieldsSize}"
+          }
+        }
+        INSTANCE_DUMP -> {
+          val bytesReadStart = reader.bytesRead
+          val id = reader.readId()
+          reader.skip(INT.byteSize)
+          val classId = reader.readId()
+          val remainingBytesInInstance = reader.readInt()
+          reader.skip(remainingBytesInInstance)
+          val recordSize = reader.bytesRead - bytesReadStart
+          instanceIndex.append(id)
+            .apply {
+              writeTruncatedLong(bytesReadStart, positionSize)
+              writeId(classId)
+              writeTruncatedLong(recordSize, bytesForInstanceSize)
+            }
+        }
+        OBJECT_ARRAY_DUMP -> {
+          val bytesReadStart = reader.bytesRead
+          val id = reader.readId()
+          // stack trace serial number
+          reader.skip(INT.byteSize)
+          val size = reader.readInt()
+          val arrayClassId = reader.readId()
+          reader.skip(identifierSize * size)
+          // record size - (ID+INT + INT + ID)
+          val recordSize = reader.bytesRead - bytesReadStart
+          objectArrayIndex.append(id)
+            .apply {
+              writeTruncatedLong(bytesReadStart, positionSize)
+              writeId(arrayClassId)
+              writeTruncatedLong(recordSize, bytesForObjectArraySize)
+            }
+        }
+        PRIMITIVE_ARRAY_DUMP -> {
+          val bytesReadStart = reader.bytesRead
+          val id = reader.readId()
+          reader.skip(INT.byteSize)
+          val size = reader.readInt()
+          val type = PrimitiveType.primitiveTypeByHprofType.getValue(reader.readUnsignedByte())
+          reader.skip(size * type.byteSize)
+          val recordSize = reader.bytesRead - bytesReadStart
+          primitiveArrayIndex.append(id)
+            .apply {
+              writeTruncatedLong(bytesReadStart, positionSize)
+              writeByte(type.ordinal.toByte())
+              writeTruncatedLong(recordSize, bytesForPrimitiveArraySize)
+            }
+        }
+      }
+    }
+
+    fun buildIndex(
+      proguardMapping: ProguardMapping?,
+      hprofHeader: HprofHeader
+    ): HprofInMemoryIndex {
+      require(classFieldsIndex == classFieldBytes.size) {
+        "Read $classFieldsIndex into fields bytes instead of expected ${classFieldBytes.size}"
+      }
+
+      val sortedInstanceIndex = instanceIndex.moveToSortedMap()
+      val sortedObjectArrayIndex = objectArrayIndex.moveToSortedMap()
+      val sortedPrimitiveArrayIndex = primitiveArrayIndex.moveToSortedMap()
+      val sortedClassIndex = classIndex.moveToSortedMap()
+      // Passing references to avoid copying the underlying data structures.
+      return HprofInMemoryIndex(
+        positionSize = positionSize,
+        hprofStringCache = hprofStringCache,
+        classNames = classNames,
+        classIndex = sortedClassIndex,
+        instanceIndex = sortedInstanceIndex,
+        objectArrayIndex = sortedObjectArrayIndex,
+        primitiveArrayIndex = sortedPrimitiveArrayIndex,
+        gcRoots = gcRoots,
+        proguardMapping = proguardMapping,
+        bytesForClassSize = bytesForClassSize,
+        bytesForInstanceSize = bytesForInstanceSize,
+        bytesForObjectArraySize = bytesForObjectArraySize,
+        bytesForPrimitiveArraySize = bytesForPrimitiveArraySize,
+        useForwardSlashClassPackageSeparator = hprofHeader.version != ANDROID,
+        classFieldsReader = ClassFieldsReader(identifierSize, classFieldBytes),
+        classFieldsIndexSize = classFieldsIndexSize,
+        stickyClassGcRootIds = stickyClassGcRootIds,
+      )
+    }
+  }
+
+  companion object {
+
+    private fun byteSizeForUnsigned(maxValue: Long): Int {
+      var value = maxValue
+      var byteCount = 0
+      while (value != 0L) {
+        value = value shr 8
+        byteCount++
+      }
+      return byteCount
+    }
+
+    fun indexHprof(
+      reader: StreamingHprofReader,
+      hprofHeader: HprofHeader,
+      proguardMapping: ProguardMapping?,
+      indexedGcRootTags: Set<HprofRecordTag>
+    ): HprofInMemoryIndex {
+
+      // First pass to count and correctly size arrays once and for all.
+      var maxClassSize = 0L
+      var maxInstanceSize = 0L
+      var maxObjectArraySize = 0L
+      var maxPrimitiveArraySize = 0L
+      var classCount = 0
+      var instanceCount = 0
+      var objectArrayCount = 0
+      var primitiveArrayCount = 0
+      var classFieldsTotalBytes = 0
+      val stickyClassGcRootIds = LongScatterSet()
+
+      val bytesRead = reader.readRecords(
+        EnumSet.of(
+          CLASS_DUMP,
+          INSTANCE_DUMP,
+          OBJECT_ARRAY_DUMP,
+          PRIMITIVE_ARRAY_DUMP,
+          ROOT_STICKY_CLASS
+        )
+      ) { tag, _, reader ->
+        val bytesReadStart = reader.bytesRead
+        when (tag) {
+          CLASS_DUMP -> {
+            classCount++
+            reader.skipClassDumpHeader()
+            val bytesReadStaticFieldStart = reader.bytesRead
+            reader.skipClassDumpStaticFields()
+            reader.skipClassDumpFields()
+            maxClassSize = max(maxClassSize, reader.bytesRead - bytesReadStart)
+            classFieldsTotalBytes += (reader.bytesRead - bytesReadStaticFieldStart).toInt()
+          }
+          INSTANCE_DUMP -> {
+            instanceCount++
+            reader.skipInstanceDumpRecord()
+            maxInstanceSize = max(maxInstanceSize, reader.bytesRead - bytesReadStart)
+          }
+          OBJECT_ARRAY_DUMP -> {
+            objectArrayCount++
+            reader.skipObjectArrayDumpRecord()
+            maxObjectArraySize = max(maxObjectArraySize, reader.bytesRead - bytesReadStart)
+          }
+          PRIMITIVE_ARRAY_DUMP -> {
+            primitiveArrayCount++
+            reader.skipPrimitiveArrayDumpRecord()
+            maxPrimitiveArraySize = max(maxPrimitiveArraySize, reader.bytesRead - bytesReadStart)
+          }
+          ROOT_STICKY_CLASS -> {
+            // StickyClass has only 1 field: id. Our API 23 emulators in CI are creating heap
+            // dumps with duplicated sticky class roots, up to 30K times for some objects.
+            // There's no point in keeping all these in our list of roots, 1 per each is enough
+            // so we deduplicate with stickyClassGcRootIds.
+            val id = reader.readStickyClassGcRootRecord().id
+            if (id != ValueHolder.NULL_REFERENCE) {
+              stickyClassGcRootIds += id
+            }
+          }
+        }
+      }
+
+      val bytesForClassSize = byteSizeForUnsigned(maxClassSize)
+      val bytesForInstanceSize = byteSizeForUnsigned(maxInstanceSize)
+      val bytesForObjectArraySize = byteSizeForUnsigned(maxObjectArraySize)
+      val bytesForPrimitiveArraySize = byteSizeForUnsigned(maxPrimitiveArraySize)
+
+      val indexBuilderListener = Builder(
+        longIdentifiers = hprofHeader.identifierByteSize == 8,
+        maxPosition = bytesRead,
+        classCount = classCount,
+        instanceCount = instanceCount,
+        objectArrayCount = objectArrayCount,
+        primitiveArrayCount = primitiveArrayCount,
+        bytesForClassSize = bytesForClassSize,
+        bytesForInstanceSize = bytesForInstanceSize,
+        bytesForObjectArraySize = bytesForObjectArraySize,
+        bytesForPrimitiveArraySize = bytesForPrimitiveArraySize,
+        classFieldsTotalBytes = classFieldsTotalBytes,
+        stickyClassGcRootIds
+      )
+
+      val recordTypes = EnumSet.of(
+        STRING_IN_UTF8,
+        LOAD_CLASS,
+        CLASS_DUMP,
+        INSTANCE_DUMP,
+        OBJECT_ARRAY_DUMP,
+        PRIMITIVE_ARRAY_DUMP
+      ) + HprofRecordTag.rootTags.intersect(indexedGcRootTags)
+
+      reader.readRecords(recordTypes, indexBuilderListener)
+      return indexBuilderListener.buildIndex(proguardMapping, hprofHeader)
+    }
+  }
+}
diff --git a/shark-graph/src/main/java/shark/internal/IndexedObject.kt b/shark-graph/src/main/java/shark/internal/IndexedObject.kt
new file mode 100644
index 00000000..5fada7b7
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/IndexedObject.kt
@@ -0,0 +1,38 @@
+package shark.internal
+
+import shark.PrimitiveType
+
+internal sealed class IndexedObject {
+  abstract val position: Long
+  abstract val recordSize: Long
+
+  class IndexedClass(
+    override val position: Long,
+    val superclassId: Long,
+    val instanceSize: Int,
+    override val recordSize: Long,
+    val fieldsIndex: Int
+  ) : IndexedObject()
+
+  class IndexedInstance(
+    override val position: Long,
+    val classId: Long,
+    override val recordSize: Long
+  ) : IndexedObject()
+
+  class IndexedObjectArray(
+    override val position: Long,
+    val arrayClassId: Long,
+    override val recordSize: Long
+  ) : IndexedObject()
+
+  class IndexedPrimitiveArray(
+    override val position: Long,
+    primitiveType: PrimitiveType,
+    override val recordSize: Long
+  ) : IndexedObject() {
+    private val primitiveTypeOrdinal: Byte = primitiveType.ordinal.toByte()
+    val primitiveType: PrimitiveType
+      get() = PrimitiveType.values()[primitiveTypeOrdinal.toInt()]
+  }
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/LruCache.kt b/shark-graph/src/main/java/shark/internal/LruCache.kt
new file mode 100644
index 00000000..6e54aaad
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/LruCache.kt
@@ -0,0 +1,77 @@
+package shark.internal
+
+import java.util.LinkedHashMap
+import kotlin.collections.MutableMap.MutableEntry
+
+/**
+ * API is a simplified version of android.util.LruCache
+ * Implementation is inspired from http://chriswu.me/blog/a-lru-cache-in-10-lines-of-java/
+ */
+internal class LruCache<K, V>(
+  val maxSize: Int
+) {
+  private val cache: LinkedHashMap<K, V>
+
+  val size
+    get() = cache.size
+
+  var putCount: Int = 0
+    private set
+  var evictionCount: Int = 0
+    private set
+  var hitCount: Int = 0
+    private set
+  var missCount: Int = 0
+    private set
+
+  init {
+    require(maxSize > 0) {
+      "maxSize=$maxSize <= 0"
+    }
+    this.cache = object : LinkedHashMap<K, V>(maxSize, 0.75f, true) {
+      override fun removeEldestEntry(eldest: MutableEntry<K, V>?) = if (size > maxSize) {
+        evictionCount++
+        true
+      } else {
+        false
+      }
+    }
+  }
+
+  operator fun get(key: K?): V? {
+    // get() moves the key to the front
+    val value: V? = cache[key]
+    return if (value != null) {
+      hitCount++
+      value
+    } else {
+      missCount++
+      null
+    }
+  }
+
+  fun put(
+    key: K,
+    value: V
+  ): V? {
+    putCount++
+    return cache.put(key, value)
+  }
+
+  fun remove(key: K): V? {
+    return cache.remove(key)
+  }
+
+  fun evictAll() {
+    cache.clear()
+  }
+
+  override fun toString(): String {
+    val accesses = hitCount + missCount
+    val hitPercent = if (accesses != 0) 100 * hitCount / accesses else 0
+    return String.format(
+      "LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]",
+      maxSize, hitCount, missCount, hitPercent
+    )
+  }
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt b/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt
new file mode 100644
index 00000000..35738515
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt
@@ -0,0 +1,81 @@
+package shark.internal
+
+import shark.internal.hppc.LongObjectPair
+import shark.internal.hppc.to
+
+/**
+ * A read only map of `id` => `byte array` sorted by id, where `id` is a long if [longIdentifiers]
+ * is true and an int otherwise. Each entry has a value byte array of size [bytesPerValue].
+ *
+ * Instances are created by [UnsortedByteEntries]
+ *
+ * [get] and [contains] perform a binary search to locate a specific entry by key.
+ */
+internal class SortedBytesMap(
+  private val longIdentifiers: Boolean,
+  private val bytesPerValue: Int,
+  private val sortedEntries: ByteArray
+) {
+  private val bytesPerKey = if (longIdentifiers) 8 else 4
+  private val bytesPerEntry = bytesPerKey + bytesPerValue
+
+  val size = sortedEntries.size / bytesPerEntry
+
+  operator fun get(key: Long): ByteSubArray? {
+    val keyIndex = binarySearch(key)
+    if (keyIndex < 0) {
+      return null
+    }
+    return getAtIndex(keyIndex)
+  }
+
+  fun indexOf(key: Long): Int {
+    return binarySearch(key)
+  }
+
+  fun getAtIndex(keyIndex: Int): ByteSubArray {
+    val valueIndex = keyIndex * bytesPerEntry + bytesPerKey
+    return ByteSubArray(sortedEntries, valueIndex, bytesPerValue, longIdentifiers)
+  }
+
+  operator fun contains(key: Long): Boolean {
+    val keyIndex = binarySearch(key)
+    return keyIndex >= 0
+  }
+
+  fun entrySequence(): Sequence<LongObjectPair<ByteSubArray>> {
+    return (0 until size).asSequence()
+      .map { keyIndex ->
+        val valueIndex = keyIndex * bytesPerEntry + bytesPerKey
+        keyAt(keyIndex) to ByteSubArray(sortedEntries, valueIndex, bytesPerValue, longIdentifiers)
+      }
+  }
+
+  private fun binarySearch(
+    key: Long
+  ): Int {
+    val startIndex = 0
+    val endIndex = size
+    var lo = startIndex
+    var hi = endIndex - 1
+    while (lo <= hi) {
+      val mid = (lo + hi).ushr(1)
+      val midVal = keyAt(mid)
+      when {
+        midVal < key -> lo = mid + 1
+        midVal > key -> hi = mid - 1
+        else -> return mid
+      }
+    }
+    return lo.inv()
+  }
+
+  fun keyAt(index: Int): Long {
+    val keyIndex = index * bytesPerEntry
+    return if (longIdentifiers) {
+      sortedEntries.readLong(keyIndex)
+    } else {
+      sortedEntries.readInt(keyIndex).toLong()
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/UnsortedByteEntries.kt b/shark-graph/src/main/java/shark/internal/UnsortedByteEntries.kt
new file mode 100644
index 00000000..ebac837e
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/UnsortedByteEntries.kt
@@ -0,0 +1,186 @@
+package shark.internal
+
+import shark.internal.aosp.ByteArrayTimSort
+
+/**
+ * Wraps a byte array of entries where each entry is an id followed by bytes for the value.
+ * `id` is a long if [longIdentifiers] is true and an int otherwise. Each entry has [bytesPerValue]
+ * value bytes. Entries are appended into the array via [append]. Once done, the backing array
+ * is sorted and turned into a [SortedBytesMap] by calling [moveToSortedMap].
+ */
+internal class UnsortedByteEntries(
+  private val bytesPerValue: Int,
+  private val longIdentifiers: Boolean,
+  private val initialCapacity: Int = 4,
+  private val growthFactor: Double = 2.0
+) {
+
+  private val bytesPerEntry = bytesPerValue + if (longIdentifiers) 8 else 4
+
+  private var entries: ByteArray? = null
+  private val subArray = MutableByteSubArray()
+  private var subArrayIndex = 0
+
+  private var assigned: Int = 0
+  private var currentCapacity = 0
+
+  fun append(
+    key: Long
+  ): MutableByteSubArray {
+    if (entries == null) {
+      currentCapacity = initialCapacity
+      entries = ByteArray(currentCapacity * bytesPerEntry)
+    } else {
+      if (currentCapacity == assigned) {
+        val newCapacity = (currentCapacity * growthFactor).toInt()
+        growEntries(newCapacity)
+        currentCapacity = newCapacity
+      }
+    }
+    assigned++
+    subArrayIndex = 0
+    subArray.writeId(key)
+    return subArray
+  }
+
+  fun moveToSortedMap(): SortedBytesMap {
+    if (assigned == 0) {
+      return SortedBytesMap(longIdentifiers, bytesPerValue, ByteArray(0))
+    }
+    val entries = entries!!
+    // Sort entries by keys, which are ids of 4 or 8 bytes.
+    ByteArrayTimSort.sort(entries, 0, assigned, bytesPerEntry) {
+        entrySize, o1Array, o1Index, o2Array, o2Index ->
+      if (longIdentifiers) {
+        readLong(o1Array, o1Index * entrySize)
+          .compareTo(
+            readLong(o2Array, o2Index * entrySize)
+          )
+      } else {
+        readInt(o1Array, o1Index * entrySize)
+          .compareTo(
+            readInt(o2Array, o2Index * entrySize)
+          )
+      }
+    }
+    val sortedEntries = if (entries.size > assigned * bytesPerEntry) {
+      entries.copyOf(assigned * bytesPerEntry)
+    } else entries
+    this.entries = null
+    assigned = 0
+    return SortedBytesMap(
+      longIdentifiers, bytesPerValue, sortedEntries
+    )
+  }
+
+  private fun readInt(
+    array: ByteArray,
+    index: Int
+  ): Int {
+    var pos = index
+    return (array[pos++] and 0xff shl 24
+      or (array[pos++] and 0xff shl 16)
+      or (array[pos++] and 0xff shl 8)
+      or (array[pos] and 0xff))
+  }
+
+  @Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+  private inline infix fun Byte.and(other: Long): Long = toLong() and other
+
+  @Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+  private inline infix fun Byte.and(other: Int): Int = toInt() and other
+
+  private fun readLong(
+    array: ByteArray,
+    index: Int
+  ): Long {
+    var pos = index
+    return (array[pos++] and 0xffL shl 56
+      or (array[pos++] and 0xffL shl 48)
+      or (array[pos++] and 0xffL shl 40)
+      or (array[pos++] and 0xffL shl 32)
+      or (array[pos++] and 0xffL shl 24)
+      or (array[pos++] and 0xffL shl 16)
+      or (array[pos++] and 0xffL shl 8)
+      or (array[pos] and 0xffL))
+  }
+
+  private fun growEntries(newCapacity: Int) {
+    val newEntries = ByteArray(newCapacity * bytesPerEntry)
+    System.arraycopy(entries, 0, newEntries, 0, assigned * bytesPerEntry)
+    entries = newEntries
+  }
+
+  internal inner class MutableByteSubArray {
+    fun writeByte(value: Byte) {
+      val index = subArrayIndex
+      subArrayIndex++
+      require(index in 0..bytesPerEntry) {
+        "Index $index should be between 0 and $bytesPerEntry"
+      }
+      val valuesIndex = ((assigned - 1) * bytesPerEntry) + index
+      entries!![valuesIndex] = value
+    }
+
+    fun writeId(value: Long) {
+      if (longIdentifiers) {
+        writeLong(value)
+      } else {
+        writeInt(value.toInt())
+      }
+    }
+
+    fun writeInt(value: Int) {
+      val index = subArrayIndex
+      subArrayIndex += 4
+      require(index >= 0 && index <= bytesPerEntry - 4) {
+        "Index $index should be between 0 and ${bytesPerEntry - 4}"
+      }
+      var pos = ((assigned - 1) * bytesPerEntry) + index
+      val values = entries!!
+      values[pos++] = (value ushr 24 and 0xff).toByte()
+      values[pos++] = (value ushr 16 and 0xff).toByte()
+      values[pos++] = (value ushr 8 and 0xff).toByte()
+      values[pos] = (value and 0xff).toByte()
+    }
+
+    fun writeTruncatedLong(
+      value: Long,
+      byteCount: Int
+    ) {
+      val index = subArrayIndex
+      subArrayIndex += byteCount
+      require(index >= 0 && index <= bytesPerEntry - byteCount) {
+        "Index $index should be between 0 and ${bytesPerEntry - byteCount}"
+      }
+      var pos = ((assigned - 1) * bytesPerEntry) + index
+      val values = entries!!
+
+      var shift = (byteCount - 1) * 8
+      while (shift >= 8) {
+        values[pos++] = (value ushr shift and 0xffL).toByte()
+        shift -= 8
+      }
+      values[pos] = (value and 0xffL).toByte()
+    }
+
+    fun writeLong(value: Long) {
+      val index = subArrayIndex
+      subArrayIndex += 8
+      require(index >= 0 && index <= bytesPerEntry - 8) {
+        "Index $index should be between 0 and ${bytesPerEntry - 8}"
+      }
+      var pos = ((assigned - 1) * bytesPerEntry) + index
+      val values = entries!!
+      values[pos++] = (value ushr 56 and 0xffL).toByte()
+      values[pos++] = (value ushr 48 and 0xffL).toByte()
+      values[pos++] = (value ushr 40 and 0xffL).toByte()
+      values[pos++] = (value ushr 32 and 0xffL).toByte()
+      values[pos++] = (value ushr 24 and 0xffL).toByte()
+      values[pos++] = (value ushr 16 and 0xffL).toByte()
+      values[pos++] = (value ushr 8 and 0xffL).toByte()
+      values[pos] = (value and 0xffL).toByte()
+    }
+  }
+}
+
diff --git a/shark-graph/src/main/java/shark/internal/aosp/ByteArrayComparator.kt b/shark-graph/src/main/java/shark/internal/aosp/ByteArrayComparator.kt
new file mode 100644
index 00000000..d125bf58
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/aosp/ByteArrayComparator.kt
@@ -0,0 +1,15 @@
+package shark.internal.aosp
+
+internal fun interface ByteArrayComparator {
+
+  /**
+   * Indexes are divided by entrySize
+   */
+  fun compare(
+    entrySize: Int,
+    o1Array: ByteArray,
+    o1Index: Int,
+    o2Array: ByteArray,
+    o2Index: Int
+  ): Int
+}
diff --git a/shark-graph/src/main/java/shark/internal/aosp/ByteArrayTimSort.kt b/shark-graph/src/main/java/shark/internal/aosp/ByteArrayTimSort.kt
new file mode 100644
index 00000000..b7f01204
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/aosp/ByteArrayTimSort.kt
@@ -0,0 +1,1088 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package shark.internal.aosp
+
+import kotlin.math.min
+
+/*
+This is TimSort.java from AOSP (Jelly Bean MR2, Apache 2 license), converted to Kotlin and adapted
+to work with byte array chunks. The passed in byte array is virtually divided into entries of a
+fixed number of bytes N. Each entry is compared by a custom comparator.
+
+ Copied from https://android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/java/util/TimSort.java
+*/
+
+/**
+ * A stable, adaptive, iterative mergesort that requires far fewer than
+ * n lg(n) comparisons when running on partially sorted arrays, while
+ * offering performance comparable to a traditional mergesort when run
+ * on random arrays.  Like all proper mergesorts, this sort is stable and
+ * runs O(n log n) time (worst case).  In the worst case, this sort requires
+ * temporary storage space for n/2 object references; in the best case,
+ * it requires only a small constant amount of space.
+ *
+ * This implementation was adapted from Tim Peters's list sort for
+ * Python, which is described in detail here:
+ *
+ * http://svn.python.org/projects/python/trunk/Objects/listsort.txt
+ *
+ * Tim's C code may be found here:
+ *
+ * http://svn.python.org/projects/python/trunk/Objects/listobject.c
+ *
+ * The underlying techniques are described in this paper (and may have
+ * even earlier origins):
+ *
+ * "Optimistic Sorting and Information Theoretic Complexity"
+ * Peter McIlroy
+ * SODA (Fourth Annual ACM-SIAM Symposium on Discrete Algorithms),
+ * pp 467-474, Austin, Texas, 25-27 January 1993.
+ *
+ * While the API to this class consists solely of static methods, it is
+ * (privately) instantiable; a TimSort instance holds the state of an ongoing
+ * sort, assuming the input array is large enough to warrant the full-blown
+ * TimSort. Small arrays are sorted in place, using a binary insertion sort.
+ */
+@Suppress("detekt.complexity", "detekt.style")
+internal class ByteArrayTimSort
+/**
+ * Creates a TimSort instance to maintain the state of an ongoing sort.
+ *
+ * @param a the array to be sorted
+ * @param c the comparator to determine the order of the sort
+ */
+private constructor(
+  /**
+   * The array being sorted.
+   */
+  private val a: ByteArray,
+  /**
+   * The comparator for this sort.
+   */
+  private val c: ByteArrayComparator,
+
+  private val entrySize: Int
+) {
+  /**
+   * This controls when we get *into* galloping mode.  It is initialized
+   * to MIN_GALLOP.  The mergeLo and mergeHi methods nudge it higher for
+   * random data, and lower for highly structured data.
+   */
+  private var minGallop = MIN_GALLOP
+
+  /**
+   * Temp storage for merges.
+   */
+  private var tmp: ByteArray? = null // Actual runtime type will be Object[], regardless of T
+
+  /**
+   * A stack of pending runs yet to be merged.  Run i starts at
+   * address `base[i]` and extends for `len[i]` elements.  It's always
+   * true (so long as the indices are in bounds) that:
+   *
+   * `runBase[i] + runLen[i] == runBase[i + 1]`
+   *
+   * so we could cut the storage for this, but it's a minor amount,
+   * and keeping all the info explicit simplifies the code.
+   */
+  private var stackSize = 0  // Number of pending runs on stack
+  private val runBase: IntArray
+  private val runLen: IntArray
+
+  init {
+    // Allocate temp storage (which may be increased later if necessary)
+    val len = a.size / entrySize
+    val newArray = ByteArray(
+      entrySize *
+        if (len < 2 * INITIAL_TMP_STORAGE_LENGTH)
+          len.ushr(1)
+        else
+          INITIAL_TMP_STORAGE_LENGTH
+    )
+    tmp = newArray
+    /*
+         * Allocate runs-to-be-merged stack (which cannot be expanded).  The
+         * stack length requirements are described in listsort.txt.  The C
+         * version always uses the same stack length (85), but this was
+         * measured to be too expensive when sorting "mid-sized" arrays (e.g.,
+         * 100 elements) in Java.  Therefore, we use smaller (but sufficiently
+         * large) stack lengths for smaller arrays.  The "magic numbers" in the
+         * computation below must be changed if MIN_MERGE is decreased.  See
+         * the MIN_MERGE declaration above for more information.
+         */
+    val stackLen = when {
+        len < 120 -> 5
+        len < 1542 -> 10
+        len < 119151 -> 19
+        else -> 40
+    }
+    runBase = IntArray(stackLen)
+    runLen = IntArray(stackLen)
+  }
+
+  /**
+   * Pushes the specified run onto the pending-run stack.
+   *
+   * @param runBase index of the first element in the run
+   * @param runLen  the number of elements in the run
+   */
+  private fun pushRun(
+    runBase: Int,
+    runLen: Int
+  ) {
+    this.runBase[stackSize] = runBase
+    this.runLen[stackSize] = runLen
+    stackSize++
+  }
+
+  /**
+   * Examines the stack of runs waiting to be merged and merges adjacent runs
+   * until the stack invariants are reestablished:
+   *
+   * 1. runLen[i - 3] > runLen[i - 2] + runLen[i - 1]
+   * 2. runLen[i - 2] > runLen[i - 1]
+   *
+   * This method is called each time a new run is pushed onto the stack,
+   * so the invariants are guaranteed to hold for i < stackSize upon
+   * entry to the method.
+   */
+  // Fixed with http://www.envisage-project.eu/proving-android-java-and-python-sorting-algorithm-is-broken-and-how-to-fix-it/
+  private fun mergeCollapse() {
+    while (stackSize > 1) {
+      var n = stackSize - 2
+      if (n >= 1 && runLen[n - 1] <= runLen[n] + runLen[n + 1] || n >= 2 && runLen[n - 2] <= runLen[n] + runLen[n - 1]) {
+        if (runLen[n - 1] < runLen[n + 1])
+          n--
+      } else if (runLen[n] > runLen[n + 1]) {
+        break // Invariant is established
+      }
+      mergeAt(n)
+    }
+  }
+
+  /**
+   * Merges all runs on the stack until only one remains.  This method is
+   * called once, to complete the sort.
+   */
+  private fun mergeForceCollapse() {
+    while (stackSize > 1) {
+      var n = stackSize - 2
+      if (n > 0 && runLen[n - 1] < runLen[n + 1])
+        n--
+      mergeAt(n)
+    }
+  }
+
+  /**
+   * Merges the two runs at stack indices i and i+1.  Run i must be
+   * the penultimate or antepenultimate run on the stack.  In other words,
+   * i must be equal to stackSize-2 or stackSize-3.
+   *
+   * @param i stack index of the first of the two runs to merge
+   */
+  private fun mergeAt(i: Int) {
+    if (DEBUG) assert(stackSize >= 2)
+    if (DEBUG) assert(i >= 0)
+    if (DEBUG) assert(i == stackSize - 2 || i == stackSize - 3)
+    var base1 = runBase[i]
+    var len1 = runLen[i]
+    val base2 = runBase[i + 1]
+    var len2 = runLen[i + 1]
+    if (DEBUG) assert(len1 > 0 && len2 > 0)
+    if (DEBUG) assert(base1 + len1 == base2)
+    /*
+         * Record the length of the combined runs; if i is the 3rd-last
+         * run now, also slide over the last run (which isn't involved
+         * in this merge).  The current run (i+1) goes away in any case.
+         */
+    runLen[i] = len1 + len2
+    if (i == stackSize - 3) {
+      runBase[i + 1] = runBase[i + 2]
+      runLen[i + 1] = runLen[i + 2]
+    }
+    stackSize--
+    /*
+         * Find where the first element of run2 goes in run1. Prior elements
+         * in run1 can be ignored (because they're already in place).
+         */
+    val k = gallopRight(a, base2, a, base1, len1, 0, entrySize, c)
+    if (DEBUG) assert(k >= 0)
+    base1 += k
+    len1 -= k
+    if (len1 == 0)
+      return
+    /*
+         * Find where the last element of run1 goes in run2. Subsequent elements
+         * in run2 can be ignored (because they're already in place).
+         */
+    len2 = gallopLeft(a, base1 + len1 - 1, a, base2, len2, len2 - 1, entrySize, c)
+    if (DEBUG) assert(len2 >= 0)
+    if (len2 == 0)
+      return
+    // Merge remaining runs, using tmp array with min(len1, len2) elements
+    if (len1 <= len2)
+      mergeLo(base1, len1, base2, len2)
+    else
+      mergeHi(base1, len1, base2, len2)
+  }
+
+  /**
+   * Merges two adjacent runs in place, in a stable fashion.  The first
+   * element of the first run must be greater than the first element of the
+   * second run (a[base1] > a[base2]), and the last element of the first run
+   * (a[base1 + len1-1]) must be greater than all elements of the second run.
+   *
+   * For performance, this method should be called only when len1 <= len2;
+   * its twin, mergeHi should be called if len1 >= len2.  (Either method
+   * may be called if len1 == len2.)
+   *
+   * @param base1 index of first element in first run to be merged
+   * @param len1  length of first run to be merged (must be > 0)
+   * @param base2 index of first element in second run to be merged
+   * (must be aBase + aLen)
+   * @param len2  length of second run to be merged (must be > 0)
+   */
+  private fun mergeLo(
+    base1: Int,
+    len1: Int,
+    base2: Int,
+    len2: Int
+  ) {
+    var len1 = len1
+    var len2 = len2
+    if (DEBUG) assert(len1 > 0 && len2 > 0 && base1 + len1 == base2)
+    // Copy first run into temp array
+    val a = this.a // For performance
+    val entrySize = entrySize
+    val tmp = ensureCapacity(len1)
+    System.arraycopy(a, base1 * entrySize, tmp, 0, len1 * entrySize)
+    var cursor1 = 0       // Indexes into tmp array
+    var cursor2 = base2   // Indexes int a
+    var dest = base1      // Indexes int a
+    // Move first element of second run and deal with degenerate cases
+    val destIndex = dest * entrySize
+    val cursor2Index = cursor2 * entrySize
+    for (i in 0 until entrySize) {
+      a[destIndex + i] = a[cursor2Index + i]
+    }
+    dest++
+    cursor2++
+
+    if (--len2 == 0) {
+      System.arraycopy(tmp, cursor1 * entrySize, a, dest * entrySize, len1 * entrySize)
+      return
+    }
+    if (len1 == 1) {
+      System.arraycopy(a, cursor2 * entrySize, a, dest * entrySize, len2 * entrySize)
+      val destLen2Index = (dest + len2) * entrySize
+      val cursor1Index = cursor1 * entrySize
+      for (i in 0 until entrySize) {
+        a[destLen2Index + i] = tmp[cursor1Index + i] // Last elt of run 1 to end of merge
+      }
+      return
+    }
+    val c = this.c  // Use local variable for performance
+    var minGallop = this.minGallop    //  "    "       "     "      "
+    outer@ while (true) {
+      var count1 = 0 // Number of times in a row that first run won
+      var count2 = 0 // Number of times in a row that second run won
+      /*
+       * Do the straightforward thing until (if ever) one run starts
+       * winning consistently.
+       */
+      do {
+        if (DEBUG) assert(len1 > 1 && len2 > 0)
+        if (c.compare(entrySize, a, cursor2, tmp, cursor1) < 0) {
+          val destIndex = dest * entrySize
+          val cursor2Index = cursor2 * entrySize
+          for (i in 0 until entrySize) {
+            a[destIndex + i] = a[cursor2Index + i]
+          }
+          dest++
+          cursor2++
+          count2++
+          count1 = 0
+          if (--len2 == 0)
+            break@outer
+        } else {
+          val destIndex = dest * entrySize
+          val cursor1Index = cursor1 * entrySize
+          for (i in 0 until entrySize) {
+            a[destIndex + i] = tmp[cursor1Index + i]
+          }
+          dest++
+          cursor1++
+          count1++
+          count2 = 0
+          if (--len1 == 1)
+            break@outer
+        }
+      } while (count1 or count2 < minGallop)
+      /*
+             * One run is winning so consistently that galloping may be a
+             * huge win. So try that, and continue galloping until (if ever)
+             * neither run appears to be winning consistently anymore.
+             */
+      do {
+        if (DEBUG) assert(len1 > 1 && len2 > 0)
+        count1 = gallopRight(a, cursor2, tmp, cursor1, len1, 0, entrySize, c)
+        if (count1 != 0) {
+          System.arraycopy(tmp, cursor1 * entrySize, a, dest * entrySize, count1 * entrySize)
+          dest += count1
+          cursor1 += count1
+          len1 -= count1
+          if (len1 <= 1)
+          // len1 == 1 || len1 == 0
+            break@outer
+        }
+        var destIndex = dest * entrySize
+        val cursor2Index = cursor2 * entrySize
+        for (i in 0 until entrySize) {
+          a[destIndex + i] = a[cursor2Index + i]
+        }
+        dest++
+        cursor2++
+        if (--len2 == 0)
+          break@outer
+        count2 = gallopLeft(tmp, cursor1, a, cursor2, len2, 0, entrySize, c)
+        if (count2 != 0) {
+          System.arraycopy(a, cursor2 * entrySize, a, dest * entrySize, count2 * entrySize)
+          dest += count2
+          cursor2 += count2
+          len2 -= count2
+          if (len2 == 0)
+            break@outer
+        }
+        destIndex = dest * entrySize
+        val cursor1Index = cursor1 * entrySize
+        for (i in 0 until entrySize) {
+          a[destIndex + i] = tmp[cursor1Index + i]
+        }
+        dest++
+        cursor1++
+        if (--len1 == 1)
+          break@outer
+        minGallop--
+      } while ((count1 >= MIN_GALLOP) or (count2 >= MIN_GALLOP))
+      if (minGallop < 0)
+        minGallop = 0
+      minGallop += 2  // Penalize for leaving gallop mode
+    }  // End of "outer" loop
+    this.minGallop = if (minGallop < 1) 1 else minGallop  // Write back to field
+    when (len1) {
+        1 -> {
+          if (DEBUG) assert(len2 > 0)
+          System.arraycopy(a, cursor2 * entrySize, a, dest * entrySize, len2 * entrySize)
+          val destLen2Index = (dest + len2) * entrySize
+          val cursor1Index = cursor1 * entrySize
+          for (i in 0 until entrySize) {
+            a[destLen2Index + i] = tmp[cursor1Index + i] //  Last elt of run 1 to end of merge
+          }
+        }
+        0 -> {
+          throw IllegalArgumentException(
+            "Comparison method violates its general contract!"
+          )
+        }
+        else -> {
+          if (DEBUG) assert(len2 == 0)
+          if (DEBUG) assert(len1 > 1)
+          System.arraycopy(tmp, cursor1 * entrySize, a, dest * entrySize, len1 * entrySize)
+        }
+    }
+  }
+
+  /**
+   * Like mergeLo, except that this method should be called only if
+   * len1 >= len2; mergeLo should be called if len1 <= len2.  (Either method
+   * may be called if len1 == len2.)
+   *
+   * @param base1 index of first element in first run to be merged
+   * @param len1  length of first run to be merged (must be > 0)
+   * @param base2 index of first element in second run to be merged
+   * (must be aBase + aLen)
+   * @param len2  length of second run to be merged (must be > 0)
+   */
+  private fun mergeHi(
+    base1: Int,
+    len1: Int,
+    base2: Int,
+    len2: Int
+  ) {
+    var len1 = len1
+    var len2 = len2
+    if (DEBUG) assert(len1 > 0 && len2 > 0 && base1 + len1 == base2)
+    // Copy second run into temp array
+    val a = this.a // For performance
+    val tmp = ensureCapacity(len2)
+    val entrySize = entrySize
+    System.arraycopy(a, base2 * entrySize, tmp, 0, len2 * entrySize)
+    var cursor1 = base1 + len1 - 1  // Indexes into a
+    var cursor2 = len2 - 1          // Indexes into tmp array
+    var dest = base2 + len2 - 1     // Indexes into a
+    // Move last element of first run and deal with degenerate cases
+    var destIndex = dest * entrySize
+    val cursor1Index = cursor1 * entrySize
+    for (i in 0 until entrySize) {
+      a[destIndex + i] = a[cursor1Index + i]
+    }
+    dest--
+    cursor1--
+    if (--len1 == 0) {
+      System.arraycopy(tmp, 0, a, (dest - (len2 - 1)) * entrySize, len2 * entrySize)
+      return
+    }
+    if (len2 == 1) {
+      dest -= len1
+      cursor1 -= len1
+      System.arraycopy(a, (cursor1 + 1) * entrySize, a, (dest + 1) * entrySize, len1 * entrySize)
+      val destIndex = dest * entrySize
+      val cursor2Index = cursor2 * entrySize
+      for (i in 0 until entrySize) {
+        a[destIndex + i] = tmp[cursor2Index + i]
+      }
+      return
+    }
+    val c = this.c  // Use local variable for performance
+    var minGallop = this.minGallop    //  "    "       "     "      "
+    outer@ while (true) {
+      var count1 = 0 // Number of times in a row that first run won
+      var count2 = 0 // Number of times in a row that second run won
+      /*
+             * Do the straightforward thing until (if ever) one run
+             * appears to win consistently.
+             */
+      do {
+        if (DEBUG) assert(len1 > 0 && len2 > 1)
+        if (c.compare(entrySize, tmp, cursor2, a, cursor1) < 0) {
+          val destIndex = dest * entrySize
+          val cursor1Index = cursor1 * entrySize
+          for (i in 0 until entrySize) {
+            a[destIndex + i] = a[cursor1Index + i]
+          }
+          dest--
+          cursor1--
+          count1++
+          count2 = 0
+          if (--len1 == 0)
+            break@outer
+        } else {
+          val destIndex = dest * entrySize
+          val cursor2Index = cursor2 * entrySize
+          for (i in 0 until entrySize) {
+            a[destIndex + i] = tmp[cursor2Index + i]
+          }
+          dest--
+          cursor2--
+          count2++
+          count1 = 0
+          if (--len2 == 1)
+            break@outer
+        }
+      } while (count1 or count2 < minGallop)
+      /*
+             * One run is winning so consistently that galloping may be a
+             * huge win. So try that, and continue galloping until (if ever)
+             * neither run appears to be winning consistently anymore.
+             */
+      do {
+        if (DEBUG) assert(len1 > 0 && len2 > 1)
+        count1 = len1 - gallopRight(tmp, cursor2, a, base1, len1, len1 - 1, entrySize, c)
+        if (count1 != 0) {
+          dest -= count1
+          cursor1 -= count1
+          len1 -= count1
+          System.arraycopy(
+            a, (cursor1 + 1) * entrySize, a, (dest + 1) * entrySize, count1 * entrySize
+          )
+          if (len1 == 0)
+            break@outer
+        }
+        destIndex = dest * entrySize
+        val cursor2Index = cursor2 * entrySize
+        for (i in 0 until entrySize) {
+          a[destIndex + i] = tmp[cursor2Index + i]
+        }
+        dest--
+        cursor2--
+        if (--len2 == 1)
+          break@outer
+        count2 = len2 - gallopLeft(a, cursor1, tmp, 0, len2, len2 - 1, entrySize, c)
+        if (count2 != 0) {
+          dest -= count2
+          cursor2 -= count2
+          len2 -= count2
+          System.arraycopy(
+            tmp, (cursor2 + 1) * entrySize, a, (dest + 1) * entrySize, count2 * entrySize
+          )
+          if (len2 <= 1)
+          // len2 == 1 || len2 == 0
+            break@outer
+        }
+        val destIndex = dest * entrySize
+        val cursor1Index = cursor1 * entrySize
+        for (i in 0 until entrySize) {
+          a[destIndex + i] = a[cursor1Index + i]
+        }
+        dest--
+        cursor1--
+        if (--len1 == 0)
+          break@outer
+        minGallop--
+      } while ((count1 >= MIN_GALLOP) or (count2 >= MIN_GALLOP))
+      if (minGallop < 0)
+        minGallop = 0
+      minGallop += 2  // Penalize for leaving gallop mode
+    }  // End of "outer" loop
+    this.minGallop = if (minGallop < 1) 1 else minGallop  // Write back to field
+    when (len2) {
+        1 -> {
+          if (DEBUG) assert(len1 > 0)
+          dest -= len1
+          cursor1 -= len1
+          System.arraycopy(a, (cursor1 + 1) * entrySize, a, (dest + 1) * entrySize, len1 * entrySize)
+          val destIndex = dest * entrySize
+          val cursor2Index = cursor2 * entrySize
+          for (i in 0 until entrySize) {
+            a[destIndex + i] = tmp[cursor2Index + i] // Move first elt of run2 to front of merge
+          }
+        }
+        0 -> {
+          throw IllegalArgumentException(
+            "Comparison method violates its general contract!"
+          )
+        }
+        else -> {
+          if (DEBUG) assert(len1 == 0)
+          if (DEBUG) assert(len2 > 0)
+          System.arraycopy(tmp, 0, a, (dest - (len2 - 1)) * entrySize, len2 * entrySize)
+        }
+    }
+  }
+
+  /**
+   * Ensures that the external array tmp has at least the specified
+   * number of elements, increasing its size if necessary.  The size
+   * increases exponentially to ensure amortized linear time complexity.
+   *
+   * @param minCapacity the minimum required capacity of the tmp array
+   * @return tmp, whether or not it grew
+   */
+  private fun ensureCapacity(minCapacity: Int): ByteArray {
+    if (tmp!!.size < minCapacity * entrySize) {
+      // Compute smallest power of 2 > minCapacity
+      var newSize = minCapacity
+      newSize = newSize or (newSize shr 1)
+      newSize = newSize or (newSize shr 2)
+      newSize = newSize or (newSize shr 4)
+      newSize = newSize or (newSize shr 8)
+      newSize = newSize or (newSize shr 16)
+      newSize++
+      newSize = if (newSize < 0)
+      // Not bloody likely!
+        minCapacity
+      else
+        min(newSize, (a.size / entrySize).ushr(1))
+      val newArray = ByteArray(newSize * entrySize)
+      tmp = newArray
+    }
+    return tmp!!
+  }
+
+  companion object {
+    /**
+     * This is the minimum sized sequence that will be merged.  Shorter
+     * sequences will be lengthened by calling binarySort.  If the entire
+     * array is less than this length, no merges will be performed.
+     *
+     * This constant should be a power of two.  It was 64 in Tim Peter's C
+     * implementation, but 32 was empirically determined to work better in
+     * this implementation.  In the unlikely event that you set this constant
+     * to be a number that's not a power of two, you'll need to change the
+     * [.minRunLength] computation.
+     *
+     * If you decrease this constant, you must change the stackLen
+     * computation in the TimSort constructor, or you risk an
+     * ArrayOutOfBounds exception.  See listsort.txt for a discussion
+     * of the minimum stack length required as a function of the length
+     * of the array being sorted and the minimum merge sequence length.
+     */
+    private const val MIN_MERGE = 32
+
+    /**
+     * When we get into galloping mode, we stay there until both runs win less
+     * often than MIN_GALLOP consecutive times.
+     */
+    private const val MIN_GALLOP = 7
+
+    /**
+     * Maximum initial size of tmp array, which is used for merging.  The array
+     * can grow to accommodate demand.
+     *
+     * Unlike Tim's original C version, we do not allocate this much storage
+     * when sorting smaller arrays.  This change was required for performance.
+     */
+    private const val INITIAL_TMP_STORAGE_LENGTH = 256
+
+    /**
+     * Asserts have been placed in if-statements for performace. To enable them,
+     * set this field to true and enable them in VM with a command line flag.
+     * If you modify this class, please do test the asserts!
+     */
+    private const val DEBUG = false
+
+    /*
+     * The next two methods (which are package private and static) constitute
+     * the entire API of this class.  Each of these methods obeys the contract
+     * of the public method with the same signature in java.util.Arrays.
+     */
+    fun sort(
+      a: ByteArray,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ) {
+      sort(a, 0, a.size / entrySize, entrySize, c)
+    }
+
+    fun sort(
+      a: ByteArray,
+      lo: Int,
+      hi: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ) {
+      var lo = lo
+      checkStartAndEnd(a.size / entrySize, lo, hi)
+      var nRemaining = hi - lo
+      if (nRemaining < 2)
+        return   // Arrays of size 0 and 1 are always sorted
+      // If array is small, do a "mini-TimSort" with no merges
+      if (nRemaining < MIN_MERGE) {
+        val initRunLen = countRunAndMakeAscending(a, lo, hi, entrySize, c)
+        binarySort(a, lo, hi, lo + initRunLen, entrySize, c)
+        return
+      }
+      /**
+       * March over the array once, left to right, finding natural runs,
+       * extending short natural runs to minRun elements, and merging runs
+       * to maintain stack invariant.
+       */
+      val ts = ByteArrayTimSort(a, c, entrySize)
+      val minRun = minRunLength(nRemaining)
+      do {
+        // Identify next run
+        var runLen = countRunAndMakeAscending(a, lo, hi, entrySize, c)
+        // If run is short, extend to min(minRun, nRemaining)
+        if (runLen < minRun) {
+          val force = if (nRemaining <= minRun) nRemaining else minRun
+          binarySort(a, lo, lo + force, lo + runLen, entrySize, c)
+          runLen = force
+        }
+        // Push run onto pending-run stack, and maybe merge
+        ts.pushRun(lo, runLen)
+        ts.mergeCollapse()
+        // Advance to find next run
+        lo += runLen
+        nRemaining -= runLen
+      } while (nRemaining != 0)
+      // Merge all remaining runs to complete sort
+      if (DEBUG) assert(lo == hi)
+      ts.mergeForceCollapse()
+      if (DEBUG) assert(ts.stackSize == 1)
+    }
+
+    private fun checkStartAndEnd(
+      len: Int,
+      start: Int,
+      end: Int
+    ) {
+      if (start < 0 || end > len) {
+        throw ArrayIndexOutOfBoundsException(
+          "start < 0 || end > len."
+            + " start=" + start + ", end=" + end + ", len=" + len
+        )
+      }
+      if (start > end) {
+        throw IllegalArgumentException("start > end: $start > $end")
+      }
+    }
+
+    /**
+     * Sorts the specified portion of the specified array using a binary
+     * insertion sort.  This is the best method for sorting small numbers
+     * of elements.  It requires O(n log n) compares, but O(n^2) data
+     * movement (worst case).
+     *
+     * If the initial part of the specified range is already sorted,
+     * this method can take advantage of it: the method assumes that the
+     * elements from index `lo`, inclusive, to `start`,
+     * exclusive are already sorted.
+     *
+     * @param a the array in which a range is to be sorted
+     * @param lo the index of the first element in the range to be sorted
+     * @param hi the index after the last element in the range to be sorted
+     * @param start the index of the first element in the range that is
+     * not already known to be sorted (@code lo <= start <= hi}
+     * @param c comparator to used for the sort
+     */
+    private fun binarySort(
+      a: ByteArray,
+      lo: Int,
+      hi: Int,
+      start: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ) {
+      var start = start
+      if (DEBUG) assert(start in lo..hi)
+      if (start == lo)
+        start++
+      val pivot = ByteArray(entrySize)
+      while (start < hi) {
+        val startIndex = start * entrySize
+        for (i in 0 until entrySize) {
+          pivot[i] = a[startIndex + i]
+        }
+        // Set left (and right) to the index where a[start] (pivot) belongs
+        var left = lo
+        var right = start
+        if (DEBUG) assert(left <= right)
+        /*
+             * Invariants:
+             *   pivot >= all in [lo, left).
+             *   pivot <  all in [right, start).
+             */
+        while (left < right) {
+          val mid = (left + right).ushr(1)
+          if (c.compare(entrySize, pivot, 0, a, mid) < 0)
+            right = mid
+          else
+            left = mid + 1
+        }
+        if (DEBUG) assert(left == right)
+        /*
+             * The invariants still hold: pivot >= all in [lo, left) and
+             * pivot < all in [left, start), so pivot belongs at left.  Note
+             * that if there are elements equal to pivot, left points to the
+             * first slot after them -- that's why this sort is stable.
+             * Slide elements over to make room for pivot.
+             */
+        // Switch is just an optimization for arraycopy in default case
+        when (val n = start - left) {  // The number of elements to move
+          2 -> {
+            val leftIndex = left * entrySize
+            val leftPlusOneIndex = (left + 1) * entrySize
+            val leftPlusTwoIndex = (left + 2) * entrySize
+            for (i in 0 until entrySize) {
+              a[leftPlusTwoIndex + i] = a[leftPlusOneIndex + i]
+            }
+            for (i in 0 until entrySize) {
+              a[leftPlusOneIndex + i] = a[leftIndex + i]
+            }
+          }
+          1 -> {
+            val leftIndex = left * entrySize
+            val leftPlusOneIndex = (left + 1) * entrySize
+            for (i in 0 until entrySize) {
+              a[leftPlusOneIndex + i] = a[leftIndex + i]
+            }
+          }
+          else -> {
+            System.arraycopy(a, left * entrySize, a, (left + 1) * entrySize, n * entrySize)
+          }
+        }
+        val leftIndex = left * entrySize
+        for (i in 0 until entrySize) {
+          a[leftIndex + i] = pivot[i]
+        }
+        start++
+      }
+    }
+
+    /**
+     * Returns the length of the run beginning at the specified position in
+     * the specified array and reverses the run if it is descending (ensuring
+     * that the run will always be ascending when the method returns).
+     *
+     * A run is the longest ascending sequence with:
+     *
+     * a[lo] <= a[lo + 1] <= a[lo + 2] <= ...
+     *
+     * or the longest descending sequence with:
+     *
+     * a[lo] >  a[lo + 1] >  a[lo + 2] >  ...
+     *
+     * For its intended use in a stable mergesort, the strictness of the
+     * definition of "descending" is needed so that the call can safely
+     * reverse a descending sequence without violating stability.
+     *
+     * @param a the array in which a run is to be counted and possibly reversed
+     * @param lo index of the first element in the run
+     * @param hi index after the last element that may be contained in the run.
+     * It is required that @code{lo < hi}.
+     * @param c the comparator to used for the sort
+     * @return  the length of the run beginning at the specified position in
+     * the specified array
+     */
+    private fun countRunAndMakeAscending(
+      a: ByteArray,
+      lo: Int,
+      hi: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ): Int {
+      if (DEBUG) assert(lo < hi)
+      var runHi = lo + 1
+      if (runHi == hi)
+        return 1
+      // Find end of run, and reverse range if descending
+
+      val comparison = c.compare(entrySize, a, runHi, a, lo)
+      runHi++
+      if (comparison < 0) { // Descending
+        while (runHi < hi && c.compare(entrySize, a, runHi, a, runHi - 1) < 0)
+          runHi++
+        reverseRange(a, lo, runHi, entrySize)
+      } else {                              // Ascending
+        while (runHi < hi && c.compare(entrySize, a, runHi, a, runHi - 1) >= 0)
+          runHi++
+      }
+      return runHi - lo
+    }
+
+    /**
+     * Reverse the specified range of the specified array.
+     *
+     * @param a the array in which a range is to be reversed
+     * @param lo the index of the first element in the range to be reversed
+     * @param hi the index after the last element in the range to be reversed
+     */
+    private fun reverseRange(
+      a: ByteArray,
+      lo: Int,
+      hi: Int,
+      entrySize: Int
+    ) {
+      var lo = lo
+      var hi = hi
+      hi--
+      while (lo < hi) {
+        val loIndex = lo * entrySize
+        val hiIndex = hi * entrySize
+        for (i in 0 until entrySize) {
+          val t = a[loIndex + i]
+          a[loIndex + i] = a[hiIndex + i]
+          a[hiIndex + i] = t
+        }
+        lo++
+        hi--
+      }
+    }
+
+    /**
+     * Returns the minimum acceptable run length for an array of the specified
+     * length. Natural runs shorter than this will be extended with
+     * [.binarySort].
+     *
+     * Roughly speaking, the computation is:
+     *
+     * If n < MIN_MERGE, return n (it's too small to bother with fancy stuff).
+     * Else if n is an exact power of 2, return MIN_MERGE/2.
+     * Else return an int k, MIN_MERGE/2 <= k <= MIN_MERGE, such that n/k
+     * is close to, but strictly less than, an exact power of 2.
+     *
+     * For the rationale, see listsort.txt.
+     *
+     * @param n the length of the array to be sorted
+     * @return the length of the minimum run to be merged
+     */
+    private fun minRunLength(n: Int): Int {
+      var n = n
+      if (DEBUG) assert(n >= 0)
+      var r = 0      // Becomes 1 if any 1 bits are shifted off
+      while (n >= MIN_MERGE) {
+        r = r or (n and 1)
+        n = n shr 1
+      }
+      return n + r
+    }
+
+    /**
+     * Locates the position at which to insert the specified key into the
+     * specified sorted range; if the range contains an element equal to key,
+     * returns the index of the leftmost equal element.
+     *
+     * @param keyIndex the key whose insertion point to search for
+     * @param a the array in which to search
+     * @param base the index of the first element in the range
+     * @param len the length of the range; must be > 0
+     * @param hint the index at which to begin the search, 0 <= hint < n.
+     * The closer hint is to the result, the faster this method will run.
+     * @param c the comparator used to order the range, and to search
+     * @return the int k,  0 <= k <= n such that a[b + k - 1] < key <= a[b + k],
+     * pretending that a[b - 1] is minus infinity and a[b + n] is infinity.
+     * In other words, key belongs at index b + k; or in other words,
+     * the first k elements of a should precede key, and the last n - k
+     * should follow it.
+     */
+    private fun gallopLeft(
+      keyArray: ByteArray,
+      // Index already divided by entrySize
+      keyIndex: Int,
+      a: ByteArray,
+      base: Int,
+      len: Int,
+      hint: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ): Int {
+      if (DEBUG) assert(len > 0 && hint >= 0 && hint < len)
+      var lastOfs = 0
+      var ofs = 1
+      if (c.compare(entrySize, keyArray, keyIndex, a, base + hint) > 0) {
+        // Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
+        val maxOfs = len - hint
+        while (ofs < maxOfs && c.compare(entrySize, keyArray, keyIndex, a, base + hint + ofs) > 0) {
+          lastOfs = ofs
+          ofs = ofs * 2 + 1
+          if (ofs <= 0)
+          // int overflow
+            ofs = maxOfs
+        }
+        if (ofs > maxOfs)
+          ofs = maxOfs
+        // Make offsets relative to base
+        lastOfs += hint
+        ofs += hint
+      } else { // key <= a[base + hint]
+        // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
+        val maxOfs = hint + 1
+        while (ofs < maxOfs && c.compare(
+            entrySize, keyArray, keyIndex, a, base + hint - ofs
+          ) <= 0
+        ) {
+          lastOfs = ofs
+          ofs = ofs * 2 + 1
+          if (ofs <= 0)
+          // int overflow
+            ofs = maxOfs
+        }
+        if (ofs > maxOfs)
+          ofs = maxOfs
+        // Make offsets relative to base
+        val tmp = lastOfs
+        lastOfs = hint - ofs
+        ofs = hint - tmp
+      }
+      if (DEBUG) assert(-1 <= lastOfs && lastOfs < ofs && ofs <= len)
+      /*
+         * Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
+         * to the right of lastOfs but no farther right than ofs.  Do a binary
+         * search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
+         */
+      lastOfs++
+      while (lastOfs < ofs) {
+        val m = lastOfs + (ofs - lastOfs).ushr(1)
+        if (c.compare(entrySize, keyArray, keyIndex, a, base + m) > 0)
+          lastOfs = m + 1  // a[base + m] < key
+        else
+          ofs = m          // key <= a[base + m]
+      }
+      if (DEBUG) assert(lastOfs == ofs)    // so a[base + ofs - 1] < key <= a[base + ofs]
+      return ofs
+    }
+
+    /**
+     * Like gallopLeft, except that if the range contains an element equal to
+     * key, gallopRight returns the index after the rightmost equal element.
+     *
+     * @param keyIndex the key whose insertion point to search for
+     * @param a the array in which to search
+     * @param base the index of the first element in the range
+     * @param len the length of the range; must be > 0
+     * @param hint the index at which to begin the search, 0 <= hint < n.
+     * The closer hint is to the result, the faster this method will run.
+     * @param c the comparator used to order the range, and to search
+     * @return the int k,  0 <= k <= n such that a[b + k - 1] <= key < a[b + k]
+     */
+    private fun gallopRight(
+      keyArray: ByteArray,
+      // Index already divided by entrySize
+      keyIndex: Int,
+      a: ByteArray,
+      base: Int,
+      len: Int,
+      hint: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ): Int {
+      if (DEBUG) assert(len > 0 && hint >= 0 && hint < len)
+      var ofs = 1
+      var lastOfs = 0
+      if (c.compare(entrySize, keyArray, keyIndex, a, base + hint) < 0) {
+        // Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
+        val maxOfs = hint + 1
+        while (ofs < maxOfs && c.compare(entrySize, keyArray, keyIndex, a, base + hint - ofs) < 0) {
+          lastOfs = ofs
+          ofs = ofs * 2 + 1
+          if (ofs <= 0)
+          // int overflow
+            ofs = maxOfs
+        }
+        if (ofs > maxOfs)
+          ofs = maxOfs
+        // Make offsets relative to b
+        val tmp = lastOfs
+        lastOfs = hint - ofs
+        ofs = hint - tmp
+      } else { // a[b + hint] <= key
+        // Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
+        val maxOfs = len - hint
+        while (ofs < maxOfs && c.compare(
+            entrySize, keyArray, keyIndex, a, base + hint + ofs
+          ) >= 0
+        ) {
+          lastOfs = ofs
+          ofs = ofs * 2 + 1
+          if (ofs <= 0)
+          // int overflow
+            ofs = maxOfs
+        }
+        if (ofs > maxOfs)
+          ofs = maxOfs
+        // Make offsets relative to b
+        lastOfs += hint
+        ofs += hint
+      }
+      if (DEBUG) assert(-1 <= lastOfs && lastOfs < ofs && ofs <= len)
+      /*
+         * Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
+         * the right of lastOfs but no farther right than ofs.  Do a binary
+         * search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
+         */
+      lastOfs++
+      while (lastOfs < ofs) {
+        val m = lastOfs + (ofs - lastOfs).ushr(1)
+        if (c.compare(entrySize, keyArray, keyIndex, a, base + m) < 0)
+          ofs = m          // key < a[b + m]
+        else
+          lastOfs = m + 1  // a[b + m] <= key
+      }
+      if (DEBUG) assert(lastOfs == ofs)    // so a[b + ofs - 1] <= key < a[b + ofs]
+      return ofs
+    }
+  }
+}
diff --git a/shark-graph/src/main/java/shark/internal/hppc/HPPC.kt b/shark-graph/src/main/java/shark/internal/hppc/HPPC.kt
new file mode 100644
index 00000000..fe76548c
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/hppc/HPPC.kt
@@ -0,0 +1,102 @@
+/*
+ *  Copyright 2010-2013, Carrot Search s.c., Boznicza 11/56, Poznan, Poland
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package shark.internal.hppc
+
+import java.util.Locale
+import kotlin.math.ceil
+import kotlin.math.max
+import kotlin.math.min
+
+/**
+ * Code from https://github.com/carrotsearch/hppc copy pasted, inlined and converted to Kotlin.
+ */
+internal object HPPC {
+
+  private const val PHI_C64 = -0x61c8864680b583ebL
+
+  fun mixPhi(k: Long): Int {
+    val h = k * PHI_C64
+    return (h xor h.ushr(32)).toInt()
+  }
+
+  private const val MIN_HASH_ARRAY_LENGTH = 4
+  private const val MAX_HASH_ARRAY_LENGTH = (-0x80000000).ushr(1)
+
+  fun minBufferSize(
+    elements: Int,
+    loadFactor: Double
+  ): Int {
+    var length = ceil(elements / loadFactor)
+      .toLong()
+    if (length == elements.toLong()) {
+      length++
+    }
+    length = max(MIN_HASH_ARRAY_LENGTH.toLong(), nextHighestPowerOfTwo(length))
+
+    if (length > MAX_HASH_ARRAY_LENGTH) {
+      throw RuntimeException(
+        String.format(
+          Locale.ROOT,
+          "Maximum array size exceeded for this load factor (elements: %d, load factor: %f)",
+          elements,
+          loadFactor
+        )
+      )
+    }
+
+    return length.toInt()
+  }
+
+  fun nextHighestPowerOfTwo(input: Long): Long {
+    var v = input
+    v--
+    v = v or (v shr 1)
+    v = v or (v shr 2)
+    v = v or (v shr 4)
+    v = v or (v shr 8)
+    v = v or (v shr 16)
+    v = v or (v shr 32)
+    v++
+    return v
+  }
+
+  fun expandAtCount(
+    arraySize: Int,
+    loadFactor: Double
+  ): Int {
+    return min(arraySize - 1, ceil(arraySize * loadFactor).toInt())
+  }
+
+  fun nextBufferSize(
+    arraySize: Int,
+    elements: Int,
+    loadFactor: Double
+  ): Int {
+    if (arraySize == MAX_HASH_ARRAY_LENGTH) {
+      throw RuntimeException(
+        String.format(
+          Locale.ROOT,
+          "Maximum array size exceeded for this load factor (elements: %d, load factor: %f)",
+          elements,
+          loadFactor
+        )
+      )
+    }
+
+    return arraySize shl 1
+  }
+}
diff --git a/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt b/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
new file mode 100644
index 00000000..1da1ece0
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
@@ -0,0 +1,407 @@
+/*
+ *  Copyright 2010-2013, Carrot Search s.c., Boznicza 11/56, Poznan, Poland
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package shark.internal.hppc
+
+import java.util.Locale
+
+/**
+ * Code from com.carrotsearch.hppc.LongLongScatterMap copy pasted, inlined and converted to Kotlin.
+ *
+ * See https://github.com/carrotsearch/hppc .
+ */
+internal class LongLongScatterMap constructor(expectedElements: Int = 4) {
+
+  fun interface ForEachCallback {
+    fun onEntry(key: Long, value: Long)
+  }
+
+  /**
+   * The array holding keys.
+   */
+  private var keys: LongArray = longArrayOf()
+
+  /**
+   * The array holding values.
+   */
+  private var values: LongArray = longArrayOf()
+
+  /**
+   * The number of stored keys (assigned key slots), excluding the special
+   * "empty" key, if any (use [.size] instead).
+   *
+   * @see .size
+   */
+  private var assigned: Int = 0
+
+  /**
+   * Mask for slot scans in [.keys].
+   */
+  private var mask: Int = 0
+
+  /**
+   * Expand (rehash) [.keys] when [.assigned] hits this value.
+   */
+  private var resizeAt: Int = 0
+
+  /**
+   * Special treatment for the "empty slot" key marker.
+   */
+  private var hasEmptyKey: Boolean = false
+
+  /**
+   * The load factor for [.keys].
+   */
+  private var loadFactor: Double = 0.75
+
+  val isEmpty: Boolean
+    get() = size == 0
+
+  init {
+    ensureCapacity(expectedElements)
+  }
+
+  operator fun set(
+    key: Long,
+    value: Long
+  ): Long {
+    val mask = this.mask
+    if (key == 0L) {
+      hasEmptyKey = true
+      val previousValue = values[mask + 1]
+      values[mask + 1] = value
+      return previousValue
+    } else {
+      val keys = this.keys
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          val previousValue = values[slot]
+          values[slot] = value
+          return previousValue
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      if (assigned == resizeAt) {
+        allocateThenInsertThenRehash(slot, key, value)
+      } else {
+        keys[slot] = key
+        values[slot] = value
+      }
+
+      assigned++
+      return 0L
+    }
+  }
+
+  fun remove(key: Long): Long {
+    val mask = this.mask
+    if (key == 0L) {
+      hasEmptyKey = false
+      val previousValue = values[mask + 1]
+      values[mask + 1] = 0L
+      return previousValue
+    } else {
+      val keys = this.keys
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          val previousValue = values[slot]
+          shiftConflictingKeys(slot)
+          return previousValue
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return 0L
+    }
+  }
+
+  /**
+   * Being given a key looks it up in the map and returns the slot where element sits, so it later
+   * can be retrieved with [getSlotValue]; return '-1' if element not found.
+   * Why so complicated and not just make [get] return null if value not found? The reason is performance:
+   * this approach prevents unnecessary boxing of the primitive long that would happen with nullable Long?
+   */
+  fun getSlot(key: Long): Int {
+    if (key == 0L) {
+      return if (hasEmptyKey) mask + 1 else -1
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return slot
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return -1
+    }
+  }
+
+  /**
+   * Being given a slot of element retrieves it from the collection
+   */
+  fun getSlotValue(slot: Int): Long = values[slot]
+
+  /**
+   * Returns an element matching a provided [key]; throws [IllegalArgumentException] if element not found
+   */
+  operator fun get(key: Long): Long {
+    val slot = getSlot(key)
+    require(slot != -1) { "Unknown key $key" }
+
+    return getSlotValue(slot)
+  }
+
+  fun forEach(forEachCallback: ForEachCallback) {
+    val max = mask + 1
+    var slot = -1
+
+    exitWhile@ while (true) {
+      if (slot < max) {
+        var existing: Long
+        slot++
+        while (slot < max) {
+          existing = keys[slot]
+          if (existing != 0L) {
+            forEachCallback.onEntry(existing, values[slot])
+            continue@exitWhile
+          }
+          slot++
+        }
+      }
+
+      if (slot == max && hasEmptyKey) {
+        slot++
+        forEachCallback.onEntry(0L, values[max])
+        continue@exitWhile
+      }
+      break@exitWhile
+    }
+  }
+
+  fun entrySequence(): Sequence<LongLongPair> {
+    val max = mask + 1
+    var slot = -1
+    return generateSequence {
+      if (slot < max) {
+        var existing: Long
+        slot++
+        while (slot < max) {
+          existing = keys[slot]
+          if (existing != 0L) {
+            return@generateSequence existing to values[slot]
+          }
+          slot++
+        }
+      }
+      if (slot == max && hasEmptyKey) {
+        slot++
+        return@generateSequence 0L to values[max]
+      }
+      return@generateSequence null
+    }
+  }
+
+  fun containsKey(key: Long): Boolean {
+    if (key == 0L) {
+      return hasEmptyKey
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return true
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return false
+    }
+  }
+
+  fun release() {
+    assigned = 0
+    hasEmptyKey = false
+
+    allocateBuffers(HPPC.minBufferSize(4, loadFactor))
+  }
+
+  val size: Int
+    get() {
+      return assigned + if (hasEmptyKey) 1 else 0
+    }
+
+  fun ensureCapacity(expectedElements: Int) {
+    if (expectedElements > resizeAt) {
+      val prevKeys = this.keys
+      val prevValues = this.values
+      allocateBuffers(HPPC.minBufferSize(expectedElements, loadFactor))
+      if (!isEmpty) {
+        rehash(prevKeys, prevValues)
+      }
+    }
+  }
+
+  private fun hashKey(key: Long): Int {
+    return HPPC.mixPhi(key)
+  }
+
+  /**
+   * Rehash from old buffers to new buffers.
+   */
+  private fun rehash(
+    fromKeys: LongArray,
+    fromValues: LongArray
+  ) {
+    // Rehash all stored key/value pairs into the new buffers.
+    val keys = this.keys
+    val values = this.values
+    val mask = this.mask
+    var existing: Long
+
+    // Copy the zero element's slot, then rehash everything else.
+    var from = fromKeys.size - 1
+    keys[keys.size - 1] = fromKeys[from]
+    values[values.size - 1] = fromValues[from]
+    while (--from >= 0) {
+      existing = fromKeys[from]
+      if (existing != 0L) {
+        var slot = hashKey(existing) and mask
+        while (keys[slot] != 0L) {
+          slot = slot + 1 and mask
+        }
+        keys[slot] = existing
+        values[slot] = fromValues[from]
+      }
+    }
+  }
+
+  /**
+   * Allocate new internal buffers. This method attempts to allocate
+   * and assign internal buffers atomically (either allocations succeed or not).
+   */
+  private fun allocateBuffers(arraySize: Int) {
+
+    // Ensure no change is done if we hit an OOM.
+    val prevKeys = this.keys
+    val prevValues = this.values
+    try {
+      val emptyElementSlot = 1
+      this.keys = LongArray(arraySize + emptyElementSlot)
+      this.values = LongArray(arraySize + emptyElementSlot)
+    } catch (e: OutOfMemoryError) {
+      this.keys = prevKeys
+      this.values = prevValues
+      throw RuntimeException(
+        String.format(
+          Locale.ROOT,
+          "Not enough memory to allocate buffers for rehashing: %d -> %d",
+          this.mask + 1,
+          arraySize
+        ), e
+      )
+    }
+
+    this.resizeAt = HPPC.expandAtCount(arraySize, loadFactor)
+    this.mask = arraySize - 1
+  }
+
+  /**
+   * This method is invoked when there is a new key/ value pair to be inserted into
+   * the buffers but there is not enough empty slots to do so.
+   *
+   * New buffers are allocated. If this succeeds, we know we can proceed
+   * with rehashing so we assign the pending element to the previous buffer
+   * (possibly violating the invariant of having at least one empty slot)
+   * and rehash all keys, substituting new buffers at the end.
+   */
+  private fun allocateThenInsertThenRehash(
+    slot: Int,
+    pendingKey: Long,
+    pendingValue: Long
+  ) {
+
+    // Try to allocate new buffers first. If we OOM, we leave in a consistent state.
+    val prevKeys = this.keys
+    val prevValues = this.values
+    allocateBuffers(HPPC.nextBufferSize(mask + 1, size, loadFactor))
+
+    // We have succeeded at allocating new data so insert the pending key/value at
+    // the free slot in the old arrays before rehashing.
+    prevKeys[slot] = pendingKey
+    prevValues[slot] = pendingValue
+
+    // Rehash old keys, including the pending key.
+    rehash(prevKeys, prevValues)
+  }
+
+  /**
+   * Shift all the slot-conflicting keys and values allocated to
+   * (and including) `slot`.
+   */
+  private fun shiftConflictingKeys(gapSlotArg: Int) {
+    var gapSlot = gapSlotArg
+    val keys = this.keys
+    val values = this.values
+    val mask = this.mask
+
+    // Perform shifts of conflicting keys to fill in the gap.
+    var distance = 0
+    while (true) {
+      val slot = gapSlot + ++distance and mask
+      val existing = keys[slot]
+      if (existing == 0L) {
+        break
+      }
+
+      val idealSlot = hashKey(existing)
+      val shift = slot - idealSlot and mask
+      if (shift >= distance) {
+        // Entry at this position was originally at or before the gap slot.
+        // Move the conflict-shifted entry to the gap's position and repeat the procedure
+        // for any entries to the right of the current position, treating it
+        // as the new gap.
+        keys[gapSlot] = existing
+        values[gapSlot] = values[slot]
+        gapSlot = slot
+        distance = 0
+      }
+    }
+
+    // Mark the last found gap slot without a conflict as empty.
+    keys[gapSlot] = 0L
+    values[gapSlot] = 0L
+    assigned--
+  }
+}
diff --git a/shark-graph/src/main/java/shark/internal/hppc/LongObjectScatterMap.kt b/shark-graph/src/main/java/shark/internal/hppc/LongObjectScatterMap.kt
new file mode 100644
index 00000000..5f7ba0d6
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/hppc/LongObjectScatterMap.kt
@@ -0,0 +1,356 @@
+/*
+ *  Copyright 2010-2013, Carrot Search s.c., Boznicza 11/56, Poznan, Poland
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package shark.internal.hppc
+
+import java.util.Locale
+
+/**
+ * Code from com.carrotsearch.hppc.LongLongScatterMap copy pasted, inlined and converted to Kotlin.
+ *
+ * See https://github.com/carrotsearch/hppc .
+ */
+internal class LongObjectScatterMap<T> {
+  /**
+   * The array holding keys.
+   */
+  private var keys: LongArray = longArrayOf()
+
+  /**
+   * The array holding values.
+   */
+  @Suppress("UNCHECKED_CAST")
+  private var values: Array<T?> = emptyArray<Any?>() as Array<T?>
+
+  /**
+   * The number of stored keys (assigned key slots), excluding the special
+   * "empty" key, if any (use [.size] instead).
+   *
+   * @see .size
+   */
+  private var assigned: Int = 0
+
+  /**
+   * Mask for slot scans in [.keys].
+   */
+  private var mask: Int = 0
+
+  /**
+   * Expand (rehash) [.keys] when [.assigned] hits this value.
+   */
+  private var resizeAt: Int = 0
+
+  /**
+   * Special treatment for the "empty slot" key marker.
+   */
+  private var hasEmptyKey: Boolean = false
+
+  /**
+   * The load factor for [.keys].
+   */
+  private var loadFactor: Double = 0.75
+
+  val isEmpty: Boolean
+    get() = size == 0
+
+  init {
+    ensureCapacity(4)
+  }
+
+  operator fun set(
+    key: Long,
+    value: T
+  ): T? {
+    val mask = this.mask
+    if (key == 0L) {
+      hasEmptyKey = true
+      val previousValue = values[mask + 1]
+      values[mask + 1] = value
+      return previousValue
+    } else {
+      val keys = this.keys
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          val previousValue = values[slot]
+          values[slot] = value
+          return previousValue
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      if (assigned == resizeAt) {
+        allocateThenInsertThenRehash(slot, key, value)
+      } else {
+        keys[slot] = key
+        values[slot] = value
+      }
+
+      assigned++
+      return null
+    }
+  }
+
+  fun remove(key: Long): T? {
+    val mask = this.mask
+    if (key == 0L) {
+      hasEmptyKey = false
+      val previousValue = values[mask + 1]
+      values[mask + 1] = null
+      return previousValue
+    } else {
+      val keys = this.keys
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          val previousValue = values[slot]
+          shiftConflictingKeys(slot)
+          return previousValue
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return null
+    }
+  }
+
+  operator fun get(key: Long): T? {
+    if (key == 0L) {
+      return if (hasEmptyKey) values[mask + 1] else null
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return values[slot]
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return null
+    }
+  }
+
+  fun entrySequence(): Sequence<LongObjectPair<T>> {
+    val max = mask + 1
+    var slot = -1
+    return generateSequence {
+      if (slot < max) {
+        var existing: Long
+        slot++
+        while (slot < max) {
+          existing = keys[slot]
+          if (existing != 0L) {
+            return@generateSequence existing to values[slot]!!
+          }
+          slot++
+        }
+      }
+      if (slot == max && hasEmptyKey) {
+        slot++
+        return@generateSequence 0L to values[max]!!
+      }
+      return@generateSequence null
+    }
+  }
+
+  fun containsKey(key: Long): Boolean {
+    if (key == 0L) {
+      return hasEmptyKey
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return true
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return false
+    }
+  }
+
+  fun release() {
+    assigned = 0
+    hasEmptyKey = false
+
+    allocateBuffers(HPPC.minBufferSize(4, loadFactor))
+  }
+
+  val size: Int
+    get() {
+      return assigned + if (hasEmptyKey) 1 else 0
+    }
+
+  fun ensureCapacity(expectedElements: Int) {
+    if (expectedElements > resizeAt) {
+      val prevKeys = this.keys
+      val prevValues = this.values
+      allocateBuffers(HPPC.minBufferSize(expectedElements, loadFactor))
+      if (!isEmpty) {
+        rehash(prevKeys, prevValues)
+      }
+    }
+  }
+
+  private fun hashKey(key: Long): Int {
+    return HPPC.mixPhi(key)
+  }
+
+  /**
+   * Rehash from old buffers to new buffers.
+   */
+  private fun rehash(
+    fromKeys: LongArray,
+    fromValues: Array<T?>
+  ) {
+    // Rehash all stored key/value pairs into the new buffers.
+    val keys = this.keys
+    val values = this.values
+    val mask = this.mask
+    var existing: Long
+
+    // Copy the zero element's slot, then rehash everything else.
+    var from = fromKeys.size - 1
+    keys[keys.size - 1] = fromKeys[from]
+    values[values.size - 1] = fromValues[from]
+    while (--from >= 0) {
+      existing = fromKeys[from]
+      if (existing != 0L) {
+        var slot = hashKey(existing) and mask
+        while (keys[slot] != 0L) {
+          slot = slot + 1 and mask
+        }
+        keys[slot] = existing
+        values[slot] = fromValues[from]
+      }
+    }
+  }
+
+  /**
+   * Allocate new internal buffers. This method attempts to allocate
+   * and assign internal buffers atomically (either allocations succeed or not).
+   */
+  private fun allocateBuffers(arraySize: Int) {
+
+    // Ensure no change is done if we hit an OOM.
+    val prevKeys = this.keys
+    val prevValues = this.values
+    try {
+      val emptyElementSlot = 1
+      this.keys = LongArray(arraySize + emptyElementSlot)
+      @Suppress("UNCHECKED_CAST")
+      this.values = arrayOfNulls<Any?>(arraySize + emptyElementSlot) as Array<T?>
+    } catch (e: OutOfMemoryError) {
+      this.keys = prevKeys
+      this.values = prevValues
+      throw RuntimeException(
+        String.format(
+          Locale.ROOT,
+          "Not enough memory to allocate buffers for rehashing: %d -> %d",
+          this.mask + 1,
+          arraySize
+        ), e
+      )
+    }
+
+    this.resizeAt = HPPC.expandAtCount(arraySize, loadFactor)
+    this.mask = arraySize - 1
+  }
+
+  /**
+   * This method is invoked when there is a new key/ value pair to be inserted into
+   * the buffers but there is not enough empty slots to do so.
+   *
+   * New buffers are allocated. If this succeeds, we know we can proceed
+   * with rehashing so we assign the pending element to the previous buffer
+   * (possibly violating the invariant of having at least one empty slot)
+   * and rehash all keys, substituting new buffers at the end.
+   */
+  private fun allocateThenInsertThenRehash(
+    slot: Int,
+    pendingKey: Long,
+    pendingValue: T
+  ) {
+
+    // Try to allocate new buffers first. If we OOM, we leave in a consistent state.
+    val prevKeys = this.keys
+    val prevValues = this.values
+    allocateBuffers(HPPC.nextBufferSize(mask + 1, size, loadFactor))
+
+    // We have succeeded at allocating new data so insert the pending key/value at
+    // the free slot in the old arrays before rehashing.
+    prevKeys[slot] = pendingKey
+    prevValues[slot] = pendingValue
+
+    // Rehash old keys, including the pending key.
+    rehash(prevKeys, prevValues)
+  }
+
+  /**
+   * Shift all the slot-conflicting keys and values allocated to
+   * (and including) `slot`.
+   */
+  private fun shiftConflictingKeys(gapSlotArg: Int) {
+    var gapSlot = gapSlotArg
+    val keys = this.keys
+    val values = this.values
+    val mask = this.mask
+
+    // Perform shifts of conflicting keys to fill in the gap.
+    var distance = 0
+    while (true) {
+      val slot = gapSlot + ++distance and mask
+      val existing = keys[slot]
+      if (existing == 0L) {
+        break
+      }
+
+      val idealSlot = hashKey(existing)
+      val shift = slot - idealSlot and mask
+      if (shift >= distance) {
+        // Entry at this position was originally at or before the gap slot.
+        // Move the conflict-shifted entry to the gap's position and repeat the procedure
+        // for any entries to the right of the current position, treating it
+        // as the new gap.
+        keys[gapSlot] = existing
+        values[gapSlot] = values[slot]
+        gapSlot = slot
+        distance = 0
+      }
+    }
+
+    // Mark the last found gap slot without a conflict as empty.
+    keys[gapSlot] = 0L
+    values[gapSlot] = null
+    assigned--
+  }
+}
diff --git a/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt b/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt
new file mode 100644
index 00000000..b311d48f
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt
@@ -0,0 +1,276 @@
+/*
+ *  Copyright 2010-2013, Carrot Search s.c., Boznicza 11/56, Poznan, Poland
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package shark.internal.hppc
+
+import java.util.Locale
+
+/**
+ * Code from com.carrotsearch.hppc.LongScatterSet copy pasted, inlined and converted to Kotlin.
+ *
+ * See https://github.com/carrotsearch/hppc .
+ */
+internal class LongScatterSet(expectedElements: Int = 4) {
+  /** The hash array holding keys.  */
+  private var keys: LongArray = longArrayOf()
+
+  /**
+   * The number of stored keys (assigned key slots), excluding the special
+   * "empty" key, if any.
+   *
+   * @see .size
+   * @see .hasEmptyKey
+   */
+  private var assigned = 0
+
+  /**
+   * Mask for slot scans in [.keys].
+   */
+  private var mask = 0
+
+  /**
+   * Expand (rehash) [.keys] when [.assigned] hits this value.
+   */
+  private var resizeAt = 0
+
+  /**
+   * Special treatment for the "empty slot" key marker.
+   */
+  private var hasEmptyKey = false
+
+  /**
+   * The load factor for [.keys].
+   */
+  private val loadFactor = 0.75
+
+  init {
+    ensureCapacity(expectedElements)
+  }
+
+  fun elementSequence(): Sequence<Long> {
+    val max = mask + 1
+    var slot = -1
+    return generateSequence {
+      if (slot < max) {
+        var existing: Long
+        slot++
+        while (slot < max) {
+          existing = keys[slot]
+          if (existing != 0L) {
+            return@generateSequence existing
+          }
+          slot++
+        }
+      }
+      if (slot == max && hasEmptyKey) {
+        slot++
+        return@generateSequence 0L
+      }
+      return@generateSequence null
+    }
+  }
+
+  private fun hashKey(key: Long): Int {
+    return HPPC.mixPhi(key)
+  }
+
+  operator fun plusAssign(key: Long) {
+    add(key)
+  }
+
+  fun add(key: Long): Boolean {
+    if (key == 0L) {
+      val added = !hasEmptyKey
+      hasEmptyKey = true
+      return added
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return false
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      if (assigned == resizeAt) {
+        allocateThenInsertThenRehash(slot, key)
+      } else {
+        keys[slot] = key
+      }
+
+      assigned++
+      return true
+    }
+  }
+
+  operator fun contains(key: Long): Boolean {
+    if (key == 0L) {
+      return hasEmptyKey
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return true
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+      return false
+    }
+  }
+
+  fun remove(key: Long): Boolean {
+    return if (key == 0L) {
+      val hadEmptyKey = hasEmptyKey
+      hasEmptyKey = false
+      hadEmptyKey
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+      var existing: Long = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          shiftConflictingKeys(slot)
+          return true
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+      false
+    }
+  }
+
+  /**
+   * Shift all the slot-conflicting keys allocated to (and including) `slot`.
+   */
+  private fun shiftConflictingKeys(inputGapSlot: Int) {
+    var gapSlot = inputGapSlot
+    val keys = keys
+    val mask = mask
+    // Perform shifts of conflicting keys to fill in the gap.
+    var distance = 0
+    while (true) {
+      val slot = (gapSlot + (++distance)) and mask
+      val existing = keys[slot]
+      if (existing == 0L) {
+        break
+      }
+      val idealSlot = hashKey(existing)
+      val shift = (slot - idealSlot) and mask
+      if (shift >= distance) {
+        // Entry at this position was originally at or before the gap slot.
+        // Move the conflict-shifted entry to the gap's position and repeat the procedure
+        // for any entries to the right of the current position, treating it
+        // as the new gap.
+        keys[gapSlot] = existing
+        gapSlot = slot
+        distance = 0
+      }
+    }
+    // Mark the last found gap slot without a conflict as empty.
+    keys[gapSlot] = 0L
+    assigned--
+  }
+
+  fun release() {
+    assigned = 0
+    hasEmptyKey = false
+    allocateBuffers(HPPC.minBufferSize(4, loadFactor))
+  }
+
+  fun ensureCapacity(expectedElements: Int) {
+    if (expectedElements > resizeAt) {
+      val prevKeys = this.keys
+      allocateBuffers(HPPC.minBufferSize(expectedElements, loadFactor))
+      if (size() != 0) {
+        rehash(prevKeys)
+      }
+    }
+  }
+
+  fun size(): Int {
+    return assigned + if (hasEmptyKey) 1 else 0
+  }
+
+  private fun rehash(fromKeys: LongArray) {
+    // Rehash all stored keys into the new buffers.
+    val keys = this.keys
+    val mask = this.mask
+    var existing: Long
+    var i = fromKeys.size - 1
+    while (--i >= 0) {
+      existing = fromKeys[i]
+      if (existing != 0L) {
+        var slot = hashKey(existing) and mask
+        while (keys[slot] != 0L) {
+          slot = slot + 1 and mask
+        }
+        keys[slot] = existing
+      }
+    }
+  }
+
+  /**
+   * Allocate new internal buffers. This method attempts to allocate
+   * and assign internal buffers atomically (either allocations succeed or not).
+   */
+  private fun allocateBuffers(arraySize: Int) {
+    // Ensure no change is done if we hit an OOM.
+    val prevKeys = this.keys
+    try {
+      val emptyElementSlot = 1
+      this.keys = LongArray(arraySize + emptyElementSlot)
+    } catch (e: OutOfMemoryError) {
+      this.keys = prevKeys
+      throw RuntimeException(
+        String.format(
+          Locale.ROOT,
+          "Not enough memory to allocate buffers for rehashing: %d -> %d",
+          size(),
+          arraySize
+        ), e
+      )
+    }
+
+    this.resizeAt = HPPC.expandAtCount(arraySize, loadFactor)
+    this.mask = arraySize - 1
+  }
+
+  private fun allocateThenInsertThenRehash(
+    slot: Int,
+    pendingKey: Long
+  ) {
+    // Try to allocate new buffers first. If we OOM, we leave in a consistent state.
+    val prevKeys = this.keys
+    allocateBuffers(HPPC.nextBufferSize(mask + 1, size(), loadFactor))
+
+    // We have succeeded at allocating new data so insert the pending key/value at
+    // the free slot in the old arrays before rehashing.
+    prevKeys[slot] = pendingKey
+
+    // Rehash old keys, including the pending key.
+    rehash(prevKeys)
+  }
+}
diff --git a/shark-graph/src/main/java/shark/internal/hppc/Tuples.kt b/shark-graph/src/main/java/shark/internal/hppc/Tuples.kt
new file mode 100644
index 00000000..63ab0c39
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/hppc/Tuples.kt
@@ -0,0 +1,25 @@
+package shark.internal.hppc
+
+/** Alternative to Pair<Long, Object> that doesn't box long.*/
+internal data class LongObjectPair<out B>(
+  val first: Long,
+  val second: B
+)
+
+/** Alternative to Pair<Int, Object> that doesn't box int.*/
+internal data class IntObjectPair<out B>(
+  val first: Int,
+  val second: B
+)
+
+/** Alternative to Pair<Long, Long> that doesn't box longs. */
+internal data class LongLongPair(
+  val first: Long,
+  val second: Long
+)
+
+internal infix fun <B> Long.to(that: B): LongObjectPair<B> = LongObjectPair(this, that)
+
+internal infix fun <B> Int.to(that: B): IntObjectPair<B> = IntObjectPair(this, that)
+
+internal infix fun Long.to(that: Long): LongLongPair = LongLongPair(this, that)
diff --git a/shark-graph/src/test/java/shark/ByteArrayTimSortTest.kt b/shark-graph/src/test/java/shark/ByteArrayTimSortTest.kt
new file mode 100644
index 00000000..d1ffee58
--- /dev/null
+++ b/shark-graph/src/test/java/shark/ByteArrayTimSortTest.kt
@@ -0,0 +1,86 @@
+package shark
+
+import kotlin.random.Random
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.internal.aosp.ByteArrayTimSort
+
+class ByteArrayTimSortTest {
+
+  @Test fun smallArray1BytePerEntry() {
+    val toSort = byteArrayOf(2, 1, 4)
+
+    ByteArrayTimSort.sort(toSort, 0, 3, 1) { _, o1Array, o1Index, o2Array, o2Index ->
+      o1Array[o1Index].compareTo(o2Array[o2Index])
+    }
+    assertThat(toSort).containsExactly(1, 2, 4)
+  }
+
+  @Test fun smallArray3BytesPerEntry1ByteKey() {
+    val toSort = byteArrayOf(2, 3, 3, 1, 5, 5, 4, 6, 6)
+
+    ByteArrayTimSort.sort(toSort, 3) { entrySize, o1Array, o1Index, o2Array, o2Index ->
+      // Sort based on first byte
+      o1Array[o1Index * entrySize].compareTo(o2Array[o2Index * entrySize])
+    }
+    assertThat(toSort).containsExactly(1, 5, 5, 2, 3, 3, 4, 6, 6)
+  }
+
+  @Test fun largeRandomArray8BytesPerEntry4BytesKey() {
+    val entryCount = 10000
+    val entrySize = 8
+    val random = Random(Int.MIN_VALUE)
+    val librarySorted = random.nextBytes(entryCount * entrySize)
+
+    class Entry(val eightBytes: ByteArray) : Comparable<Entry> {
+      override fun compareTo(other: Entry): Int {
+        val compared = readInt(eightBytes, 0).compareTo(readInt(other.eightBytes, 0))
+        if (compared == 0) {
+          return readInt(eightBytes, 4).compareTo(readInt(other.eightBytes, 4))
+        }
+        return compared
+      }
+    }
+
+    val androidSorted = arrayOfNulls<Entry>(entryCount)
+    for (i in 0 until entryCount) {
+      val index = i * entrySize
+      androidSorted[i] = Entry(librarySorted.copyOfRange(index, index + entrySize))
+    }
+    androidSorted.sort()
+    val androidSortedAsBytes = ByteArray(entryCount * entrySize)
+
+    for (i in 0 until entryCount) {
+      System.arraycopy(
+        androidSorted[i]!!.eightBytes, 0, androidSortedAsBytes, i * entrySize, entrySize
+      )
+    }
+
+    ByteArrayTimSort.sort(librarySorted, entrySize) { entrySize, o1Array, o1Index, o2Array, o2Index ->
+      val compared = readInt(o1Array, o1Index * entrySize)
+        .compareTo(readInt(o2Array, o2Index * entrySize))
+      if (compared == 0) {
+        readInt(o1Array, o1Index * entrySize + 4).compareTo(
+          readInt(o2Array, o2Index * entrySize + 4)
+        )
+      }
+      compared
+    }
+
+    assertThat(librarySorted.asList()).isEqualTo(androidSortedAsBytes.asList())
+  }
+
+  fun readInt(
+    array: ByteArray,
+    index: Int
+  ): Int {
+    var pos = index
+    return (array[pos++] and 0xff shl 24
+      or (array[pos++] and 0xff shl 16)
+      or (array[pos++] and 0xff shl 8)
+      or (array[pos] and 0xff))
+  }
+
+  @Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+  private inline infix fun Byte.and(other: Int): Int = toInt() and other
+}
diff --git a/shark-graph/src/test/java/shark/HprofDeobfuscatorTest.kt b/shark-graph/src/test/java/shark/HprofDeobfuscatorTest.kt
new file mode 100644
index 00000000..ea0e22c1
--- /dev/null
+++ b/shark-graph/src/test/java/shark/HprofDeobfuscatorTest.kt
@@ -0,0 +1,227 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.ValueHolder.IntHolder
+import java.io.File
+
+class HprofDeobfuscatorTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test
+  fun deobfuscateHprofClassName() {
+    val proguardMapping = ProguardMapping().create {
+      clazz("Foo" to "a")
+    }
+
+    hprofFile.dump {
+      "a" clazz {}
+    }
+
+    val deobfuscator = HprofDeobfuscator()
+    val deobfuscatedFile = deobfuscator.deobfuscate(proguardMapping, hprofFile)
+
+    deobfuscatedFile.readHprof { graph ->
+      val fooClass = graph.findClassByName("Foo")
+      assertThat(fooClass).isNotNull
+    }
+  }
+
+  @Test
+  fun deobfuscateHprofStaticFieldName() {
+    val proguardMapping = ProguardMapping().create {
+      clazz("Foo" to "a") {
+        field { "staticField" to "b" }
+      }
+    }
+
+    hprofFile.dump {
+      "a" clazz {
+        staticField["b"] = IntHolder(42)
+      }
+    }
+
+    val deobfuscator = HprofDeobfuscator()
+    val deobfuscatedFile = deobfuscator.deobfuscate(proguardMapping, hprofFile)
+
+    deobfuscatedFile.readHprof { graph ->
+      val fooClass = graph.findClassByName("Foo")!!
+
+      assertThat(
+        fooClass.readStaticFields()
+          .map { it.name }
+          .toList()
+      ).contains("staticField")
+    }
+  }
+
+  @Test
+  fun deobfuscateHprofMemberFieldName() {
+    val proguardMapping = ProguardMapping().create {
+      clazz("Foo" to "a") {
+        field { "instanceField" to "b" }
+      }
+    }
+
+    hprofFile.dump {
+      val classId = clazz(
+        className = "a",
+        fields = listOf("b" to IntHolder::class)
+      )
+      instance(classId, listOf(IntHolder(0)))
+    }
+
+    val deobfuscator = HprofDeobfuscator()
+    val deobfuscatedFile = deobfuscator.deobfuscate(proguardMapping, hprofFile)
+
+    deobfuscatedFile.readHprof { graph ->
+      val instance = graph.instances.find { heapInstance ->
+        heapInstance.instanceClassName == "Foo"
+      }!!
+
+      assertThat(
+        instance.readFields()
+          .map { it.name }
+          .toList()
+      ).contains("instanceField")
+    }
+  }
+
+  @Test
+  fun deobfuscateHprofClassNameUsedAsFieldName() {
+    val proguardMapping = ProguardMapping().create {
+      clazz("Foo" to "a") {
+        field { "instanceField" to "a" }
+      }
+    }
+
+    hprofFile.dump {
+      val classNameRecord = stringRecord("a")
+
+      val classId = clazz(
+        classNameRecord = classNameRecord,
+        fields = listOf(classNameRecord.id to IntHolder::class)
+      )
+      instance(classId, listOf(IntHolder(0)))
+    }
+
+    val deobfuscator = HprofDeobfuscator()
+    val deobfuscatedFile = deobfuscator.deobfuscate(proguardMapping, hprofFile)
+
+    deobfuscatedFile.readHprof { graph ->
+      val instance = graph.instances.find { heapInstance ->
+        heapInstance.instanceClassName == "Foo"
+      }!!
+
+      assertThat(
+        instance.readFields()
+          .map { it.name }
+          .toList()
+      ).contains("instanceField")
+    }
+  }
+
+  @Test
+  fun deobfuscateHprofClassNameUsedAsStaticFieldName() {
+    val proguardMapping = ProguardMapping().create {
+      clazz("Foo" to "a") {
+        field { "staticField" to "a" }
+      }
+    }
+
+    hprofFile.dump {
+      val classNameRecord = stringRecord("a")
+
+      clazz(
+        classNameRecord = classNameRecord,
+        staticFields = listOf(classNameRecord.id to IntHolder(42))
+      )
+    }
+
+    val deobfuscator = HprofDeobfuscator()
+    val deobfuscatedFile = deobfuscator.deobfuscate(proguardMapping, hprofFile)
+
+    deobfuscatedFile.readHprof { graph ->
+      val fooClass = graph.findClassByName("Foo")!!
+
+      assertThat(
+        fooClass.readStaticFields()
+          .map { it.name }
+          .toList()
+      ).contains("staticField")
+    }
+  }
+
+  @Test
+  fun deobfuscateHprofTwoFieldsWithSameName() {
+    val proguardMapping = ProguardMapping().create {
+      clazz("Foo" to "a") {
+        field { "instanceField1" to "c" }
+      }
+      clazz("Bar" to "b") {
+        field { "instanceField2" to "c" }
+      }
+    }
+
+    hprofFile.dump {
+      val fooClassNameRecord = stringRecord("a")
+      val barClassNameRecord = stringRecord("b")
+      val fieldNameRecord = stringRecord("c")
+
+      val fooClassId = clazz(
+        classNameRecord = fooClassNameRecord,
+        fields = listOf(fieldNameRecord.id to IntHolder::class)
+      )
+      instance(fooClassId, listOf(IntHolder(0)))
+
+      val barClassId = clazz(
+        classNameRecord = barClassNameRecord,
+        fields = listOf(fieldNameRecord.id to IntHolder::class)
+      )
+      instance(barClassId, listOf(IntHolder(0)))
+    }
+
+    val deobfuscator = HprofDeobfuscator()
+    val deobfuscatedFile = deobfuscator.deobfuscate(proguardMapping, hprofFile)
+
+    deobfuscatedFile.readHprof { graph ->
+      val fooInstance = graph.instances.find { heapInstance ->
+        heapInstance.instanceClassName == "Foo"
+      }!!
+
+      assertThat(
+        fooInstance.readFields()
+          .map { it.name }
+          .toList()
+      ).contains("instanceField1")
+
+      val barInstance = graph.instances.find { heapInstance ->
+        heapInstance.instanceClassName == "Bar"
+      }!!
+
+      assertThat(
+        barInstance.readFields()
+          .map { it.name }
+          .toList()
+      ).contains("instanceField2")
+    }
+  }
+
+  private fun File.readHprof(block: (HeapGraph) -> Unit) {
+    Hprof.open(this)
+      .use { hprof ->
+        block(HprofHeapGraph.indexHprof(hprof))
+      }
+  }
+}
\ No newline at end of file
diff --git a/shark-graph/src/test/java/shark/HprofHeapGraphTest.kt b/shark-graph/src/test/java/shark/HprofHeapGraphTest.kt
new file mode 100644
index 00000000..c2f3b608
--- /dev/null
+++ b/shark-graph/src/test/java/shark/HprofHeapGraphTest.kt
@@ -0,0 +1,100 @@
+package shark
+
+import java.io.File
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.GcRoot.StickyClass
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.HprofRecord.HeapDumpRecord.GcRootRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StringRecord
+
+class HprofHeapGraphTest {
+
+  @get:Rule
+  val testFolder = TemporaryFolder()
+
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test
+  fun `non system class can be found`() {
+    val className = "com.example.SimpleClass"
+
+    HprofWriter.openWriterFor(hprofFile).use { writer ->
+      val classNameRecord = StringRecord(1L, className)
+      writer.write(classNameRecord)
+      writer.writeClass(42, classNameRecord, rootClass = false)
+    }
+
+    hprofFile.openHeapGraph().use { graph ->
+      assertThat(graph.findClassByName(className)).isNotNull
+    }
+  }
+
+  @Test
+  fun `system class can be found`() {
+    val className = "com.example.SimpleClass"
+
+    HprofWriter.openWriterFor(hprofFile).use { writer ->
+      val classNameRecord = StringRecord(1L, className)
+      writer.write(classNameRecord)
+      writer.writeClass(42, classNameRecord, rootClass = true)
+    }
+
+    hprofFile.openHeapGraph().use { graph ->
+      assertThat(graph.findClassByName(className)).isNotNull
+    }
+  }
+
+  @Test
+  fun `system class prioritized over non system class`() {
+    val className = "com.example.SimpleClass"
+
+    HprofWriter.openWriterFor(hprofFile).use { writer ->
+      val classNameRecord = StringRecord(1L, className)
+      writer.write(classNameRecord)
+      writer.writeClass(24, classNameRecord, rootClass = false)
+      writer.writeClass(25, classNameRecord, rootClass = false)
+      writer.writeClass(42, classNameRecord, rootClass = true)
+      writer.writeClass(43, classNameRecord, rootClass = false)
+    }
+
+    hprofFile.openHeapGraph().use { graph ->
+      val heapClass = graph.findClassByName(className)!!
+      assertThat(heapClass.objectId).isEqualTo(42)
+    }
+  }
+
+  private fun HprofWriter.writeClass(
+    classId: Long,
+    classNameRecord: StringRecord,
+    rootClass: Boolean
+  ) {
+    val loadClass = LoadClassRecord(1, classId, 1, classNameRecord.id)
+    val classDump = ClassDumpRecord(
+      id = loadClass.id,
+      stackTraceSerialNumber = 1,
+      superclassId = 0,
+      classLoaderId = 0,
+      signersId = 0,
+      protectionDomainId = 0,
+      instanceSize = 0,
+      staticFields = emptyList(),
+      fields = emptyList()
+    )
+    write(loadClass)
+    if (rootClass) {
+      write(GcRootRecord(gcRoot = StickyClass(classId)))
+    }
+    write(classDump)
+  }
+}
diff --git a/shark-graph/src/test/java/shark/HprofIndexParsingTest.kt b/shark-graph/src/test/java/shark/HprofIndexParsingTest.kt
new file mode 100644
index 00000000..976843d4
--- /dev/null
+++ b/shark-graph/src/test/java/shark/HprofIndexParsingTest.kt
@@ -0,0 +1,65 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.GcRoot.StickyClass
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.HprofRecord.HeapDumpRecord.GcRootRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StringRecord
+
+class HprofIndexParsingTest {
+
+  private var lastId = 0L
+  private val id: Long
+    get() = ++lastId
+
+  @Test fun `duplicated StickyClass GC roots are deduplicated`() {
+    val className = StringRecord(id, "com.example.VeryStickyClass")
+    val loadClassRecord = LoadClassRecord(1, id, 1, className.id)
+    val classDump = ClassDumpRecord(
+      id = loadClassRecord.id,
+      stackTraceSerialNumber = 1,
+      superclassId = 0,
+      classLoaderId = 0,
+      signersId = 0,
+      protectionDomainId = 0,
+      instanceSize = 0,
+      staticFields = emptyList(),
+      fields = emptyList()
+    )
+    val stickyClassRecords = (1..5).map { GcRootRecord(StickyClass(loadClassRecord.id)) }
+    val bytes = (listOf(className, loadClassRecord, classDump) + stickyClassRecords).asHprofBytes()
+
+    val stickyClassRoots = bytes.openHeapGraph().use { graph: HeapGraph ->
+      graph.gcRoots.filterIsInstance(StickyClass::class.java)
+    }
+
+    assertThat(stickyClassRoots).hasSize(1)
+    assertThat(stickyClassRoots.first().id).isEqualTo(loadClassRecord.id)
+  }
+
+  @Test fun `heap dump index is computed based on position in heap dump`() {
+    val bytes = dump {
+      instance(clazz("com.example.MyClass1"))
+      instance(clazz("com.example.MyClass2"))
+    }
+
+    bytes.openHeapGraph().use { graph ->
+      val class1 = graph.findClassByName("com.example.MyClass1")!!
+      val class1Index = graph.findHeapDumpIndex(class1.objectId)
+      val instance1 = class1.instances.single()
+      val instance1Index = graph.findHeapDumpIndex(instance1.objectId)
+
+      val class2 = graph.findClassByName("com.example.MyClass2")!!
+      val class2Index = graph.findHeapDumpIndex(class2.objectId)
+      val instance2 = class2.instances.single()
+      val instance2Index = graph.findHeapDumpIndex(instance2.objectId)
+
+      assertThat(instance1Index).isEqualTo(class1Index + 1)
+      assertThat(class2Index).isEqualTo(instance1Index + 1)
+      assertThat(instance2Index).isEqualTo(class2Index + 1)
+    }
+  }
+}
diff --git a/shark-graph/src/test/java/shark/HprofPrimitiveArrayStripperTest.kt b/shark-graph/src/test/java/shark/HprofPrimitiveArrayStripperTest.kt
new file mode 100644
index 00000000..3576da18
--- /dev/null
+++ b/shark-graph/src/test/java/shark/HprofPrimitiveArrayStripperTest.kt
@@ -0,0 +1,92 @@
+package shark
+
+import java.io.File
+import okio.Buffer
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.HeapObject.HeapPrimitiveArray
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.CHAR
+
+class HprofPrimitiveArrayStripperTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+
+  private var lastId = 0L
+  private val id: Long
+    get() = ++lastId
+
+  @Test
+  fun stripHprof() {
+    val booleanArray = BooleanArrayDump(id, 1, booleanArrayOf(true, false, true, true))
+    val charArray = CharArrayDump(id, 1, "Hello World!".toCharArray())
+    val hprofBytes = listOf(booleanArray, charArray).asHprofBytes()
+
+    val stripper = HprofPrimitiveArrayStripper()
+
+    val strippedBuffer = Buffer()
+    stripper.stripPrimitiveArrays(hprofBytes, strippedBuffer)
+
+    val strippedSource = ByteArraySourceProvider(strippedBuffer.readByteArray())
+
+    strippedSource.openHeapGraph().use { graph ->
+      val booleanArrays = graph.objects
+        .filter { it is HeapPrimitiveArray && it.primitiveType == BOOLEAN }
+        .map { it.readRecord() as BooleanArrayDump }
+        .toList()
+      assertThat(booleanArrays).hasSize(1)
+      assertThat(booleanArrays[0].id).isEqualTo(booleanArray.id)
+      assertThat(booleanArrays[0].array).isEqualTo(booleanArrayOf(false, false, false, false))
+
+      val charArrays = graph.objects
+        .filter { it is HeapPrimitiveArray && it.primitiveType == CHAR }
+        .map { it.readRecord() as CharArrayDump }
+        .toList()
+      assertThat(charArrays).hasSize(1)
+      assertThat(charArrays[0].id).isEqualTo(charArray.id)
+      assertThat(charArrays[0].array).isEqualTo("????????????".toCharArray())
+    }
+  }
+
+  @Test
+  fun `ByteArray based String content is replaced with question marks`() {
+    val hprofFolder = testFolder.newFolder()
+    val hprofFile = File(hprofFolder, "jvm_heap.hprof")
+    val stringSavedToDump = "Yo!"
+    hold(TestStringHolder(stringSavedToDump)) {
+      JvmTestHeapDumper.dumpHeap(hprofFile.absolutePath)
+    }
+
+    val strippedFile = HprofPrimitiveArrayStripper().stripPrimitiveArrays(hprofFile)
+
+    val initialString = hprofFile.readHolderString()
+    val strippedString = strippedFile.readHolderString()
+    assertThat(initialString).isEqualTo(stringSavedToDump)
+    assertThat(strippedString).isEqualTo("?".repeat(stringSavedToDump.length))
+  }
+
+  private class TestStringHolder(val string: String)
+
+  private fun File.readHolderString() = openHeapGraph().use { graph ->
+    val className = "shark.HprofPrimitiveArrayStripperTest\$TestStringHolder"
+    val holderClass = graph.findClassByName(className)!!
+    val holderInstance = holderClass.instances.single()
+    holderInstance[className, "string"]!!.value.readAsJavaString()!!
+  }
+
+  private fun hold(held: Any, block: () -> Unit) {
+    try {
+      block()
+    } finally {
+      if (System.identityHashCode(held) * 0 > 0f) {
+        error("this will never happen")
+      }
+    }
+  }
+}
diff --git a/shark-graph/src/test/java/shark/HprofWriterTest.kt b/shark-graph/src/test/java/shark/HprofWriterTest.kt
new file mode 100644
index 00000000..1c29c01d
--- /dev/null
+++ b/shark-graph/src/test/java/shark/HprofWriterTest.kt
@@ -0,0 +1,197 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.HprofRecord.HeapDumpEndRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StringRecord
+import shark.StreamingRecordReaderAdapter.Companion.asStreamingRecordReader
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.ReferenceHolder
+
+class HprofWriterTest {
+
+  private var lastId = 0L
+  private val id: Long
+    get() = ++lastId
+
+  @Test
+  fun writeAndReadStringRecord() {
+    val record = StringRecord(id, MAGIC_WAND_CLASS_NAME)
+    val bytes = listOf(record).asHprofBytes()
+
+    val readRecords = bytes.readAllRecords()
+
+    assertThat(readRecords).hasSize(1)
+    assertThat(readRecords[0]).isInstanceOf(StringRecord::class.java)
+    assertThat((readRecords[0] as StringRecord).id).isEqualTo(record.id)
+    assertThat((readRecords[0] as StringRecord).string).isEqualTo(record.string)
+  }
+
+  @Test
+  fun writeAndReadClassRecord() {
+    val className = StringRecord(id, MAGIC_WAND_CLASS_NAME)
+    val loadClassRecord = LoadClassRecord(1, id, 1, className.id)
+    val classDump = ClassDumpRecord(
+      id = loadClassRecord.id,
+      stackTraceSerialNumber = 1,
+      superclassId = 0,
+      classLoaderId = 0,
+      signersId = 0,
+      protectionDomainId = 0,
+      instanceSize = 0,
+      staticFields = emptyList(),
+      fields = emptyList()
+    )
+
+    val bytes = listOf(className, loadClassRecord, classDump).asHprofBytes()
+    bytes.openHeapGraph().use { graph: HeapGraph ->
+      assertThat(graph.findClassByName(className.string)).isNotNull
+    }
+  }
+
+  @Test
+  fun writeAndReadStaticField() {
+    val className = StringRecord(id, MAGIC_WAND_CLASS_NAME)
+    val field1Name = StringRecord(id, "field1")
+    val field2Name = StringRecord(id, "field2")
+    val loadClassRecord = LoadClassRecord(1, id, 1, className.id)
+    val classDump = ClassDumpRecord(
+      id = loadClassRecord.id,
+      stackTraceSerialNumber = 1,
+      superclassId = 0,
+      classLoaderId = 0,
+      signersId = 0,
+      protectionDomainId = 0,
+      instanceSize = 0,
+      staticFields = listOf(
+        StaticFieldRecord(field1Name.id, PrimitiveType.BOOLEAN.hprofType, BooleanHolder(true)),
+        StaticFieldRecord(field2Name.id, PrimitiveType.INT.hprofType, IntHolder(42))
+      ),
+      fields = emptyList()
+    )
+    val bytes = listOf(className, field1Name, field2Name, loadClassRecord, classDump)
+      .asHprofBytes()
+    bytes.openHeapGraph().use { graph: HeapGraph ->
+      val heapClass = graph.findClassByName(className.string)!!
+      val staticFields = heapClass.readStaticFields().toList()
+      assertThat(staticFields).hasSize(2)
+      assertThat(staticFields[0].name).isEqualTo(field1Name.string)
+      assertThat(staticFields[0].value.asBoolean).isEqualTo(true)
+      assertThat(staticFields[1].name).isEqualTo(field2Name.string)
+      assertThat(staticFields[1].value.asInt).isEqualTo(42)
+    }
+  }
+
+  @Test
+  fun writeAndReadHprof() {
+    val records = createRecords()
+
+    val bytes = records.asHprofBytes()
+
+    val readRecords = bytes.readAllRecords()
+    assertThat(readRecords).hasSameSizeAs(records + HeapDumpEndRecord)
+
+    bytes.openHeapGraph().use { graph: HeapGraph ->
+      val treasureChestClass = graph.findClassByName(
+        TREASURE_CHEST_CLASS_NAME
+      )!!
+      val baguetteInstance =
+        treasureChestClass[CONTENT_FIELD_NAME]!!.value.asObject!!.asInstance!!
+
+      assertThat(
+        baguetteInstance[BAGUETTE_CLASS_NAME, ANSWER_FIELD_NAME]!!.value.asInt!!
+      ).isEqualTo(42)
+    }
+  }
+
+  private fun createRecords(): List<HprofRecord> {
+    val magicWandClassName = StringRecord(id, MAGIC_WAND_CLASS_NAME)
+    val baguetteClassName = StringRecord(id, BAGUETTE_CLASS_NAME)
+    val answerFieldName = StringRecord(id, ANSWER_FIELD_NAME)
+    val treasureChestClassName = StringRecord(
+      id,
+      TREASURE_CHEST_CLASS_NAME
+    )
+    val contentFieldName = StringRecord(id, CONTENT_FIELD_NAME)
+    val loadMagicWandClass = LoadClassRecord(1, id, 1, magicWandClassName.id)
+    val loadBaguetteClass = LoadClassRecord(1, id, 1, baguetteClassName.id)
+    val loadTreasureChestClass = LoadClassRecord(1, id, 1, treasureChestClassName.id)
+    val magicWandClassDump = ClassDumpRecord(
+      id = loadMagicWandClass.id,
+      stackTraceSerialNumber = 1,
+      superclassId = 0,
+      classLoaderId = 0,
+      signersId = 0,
+      protectionDomainId = 0,
+      instanceSize = 0,
+      staticFields = emptyList(),
+      fields = emptyList()
+    )
+    val baguetteClassDump = ClassDumpRecord(
+      id = loadBaguetteClass.id,
+      stackTraceSerialNumber = 1,
+      superclassId = loadMagicWandClass.id,
+      classLoaderId = 0,
+      signersId = 0,
+      protectionDomainId = 0,
+      instanceSize = 0,
+      staticFields = emptyList(),
+      fields = listOf(FieldRecord(answerFieldName.id, PrimitiveType.INT.hprofType))
+    )
+
+    val baguetteInstanceDump = InstanceDumpRecord(
+      id = id,
+      stackTraceSerialNumber = 1,
+      classId = loadBaguetteClass.id,
+      fieldValues = byteArrayOf(0x0, 0x0, 0x0, 0x2a)
+    )
+
+    val treasureChestClassDump = ClassDumpRecord(
+      id = loadTreasureChestClass.id,
+      stackTraceSerialNumber = 1,
+      superclassId = 0,
+      classLoaderId = 0,
+      signersId = 0,
+      protectionDomainId = 0,
+      instanceSize = 0,
+      staticFields = listOf(
+        StaticFieldRecord(
+          contentFieldName.id, PrimitiveType.REFERENCE_HPROF_TYPE,
+          ReferenceHolder(baguetteInstanceDump.id)
+        )
+      ),
+      fields = emptyList()
+    )
+
+    return listOf(
+      magicWandClassName, baguetteClassName, answerFieldName, treasureChestClassName,
+      contentFieldName, loadMagicWandClass,
+      loadBaguetteClass, loadTreasureChestClass,
+      magicWandClassDump, baguetteClassDump, baguetteInstanceDump, treasureChestClassDump
+    )
+  }
+
+  private fun DualSourceProvider.readAllRecords(): MutableList<HprofRecord> {
+    val readRecords = mutableListOf<HprofRecord>()
+    StreamingHprofReader.readerFor(this).asStreamingRecordReader()
+      .readRecords(setOf(HprofRecord::class)) { position, record ->
+        readRecords += record
+      }
+    return readRecords
+  }
+
+  companion object {
+    const val MAGIC_WAND_CLASS_NAME = "com.example.MagicWand"
+    const val BAGUETTE_CLASS_NAME = "com.example.Baguette"
+    const val ANSWER_FIELD_NAME = "answer"
+    const val TREASURE_CHEST_CLASS_NAME = "com.example.TreasureChest"
+    const val CONTENT_FIELD_NAME = "content"
+  }
+}
diff --git a/shark-graph/src/test/java/shark/JvmHprofParsingTest.kt b/shark-graph/src/test/java/shark/JvmHprofParsingTest.kt
new file mode 100644
index 00000000..85848b6d
--- /dev/null
+++ b/shark-graph/src/test/java/shark/JvmHprofParsingTest.kt
@@ -0,0 +1,154 @@
+package shark
+
+import java.io.File
+import kotlin.reflect.KClass
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.PrimitiveType.INT
+
+class JvmHprofParsingTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+
+  @Test fun dumpHeapAndReadString() {
+    val hprofFolder = testFolder.newFolder()
+    val hprofFile = File(hprofFolder, "jvm_heap.hprof")
+
+    JvmTestHeapDumper.dumpHeap(hprofFile.absolutePath)
+
+    hprofFile.openHeapGraph().use { graph ->
+      val testInstances = graph.instances
+        .filter { it.instanceClassName == JvmHprofParsingTest::class.name }
+        .toList()
+
+      assertThat(testInstances).hasSize(1)
+      val test = testInstances[0]
+      val folderPath = test[JvmHprofParsingTest::class.name, "testFolder"]!!
+        .valueAsInstance!![TemporaryFolder::class.name, "folder"]!!
+        .valueAsInstance!![File::class.name, "path"]!!
+        .value.readAsJavaString()!!
+
+      assertThat(folderPath).isEqualTo(testFolder.root.path)
+    }
+  }
+
+  @Test fun `JVM object array class name is translated to brackets`() {
+    val objectArray = arrayOf<JvmHprofParsingTest>()
+    val hprofFile = dumpHeapRetaining(objectArray)
+
+    val expectedArrayClassName = "${JvmHprofParsingTest::class.java.name}[]"
+
+    hprofFile.openHeapGraph().use { graph ->
+      val arrayClass = graph.findClassByName(expectedArrayClassName)
+      assertThat(arrayClass).isNotNull
+      assertThat(arrayClass!!.isObjectArrayClass).isTrue()
+      assertThat(arrayClass.name).isEqualTo(expectedArrayClassName)
+
+      val array = arrayClass.objectArrayInstances.single()
+      assertThat(array.arrayClassName).isEqualTo(expectedArrayClassName)
+    }
+  }
+
+  @Test fun `JVM multi dimension object array class name is translated to brackets`() {
+    val objectArray = arrayOf(arrayOf(), arrayOf<JvmHprofParsingTest>())
+    val hprofFile = dumpHeapRetaining(objectArray)
+
+    val expectedArrayClassName = "${JvmHprofParsingTest::class.java.name}[][]"
+
+    hprofFile.openHeapGraph().use { graph ->
+      val arrayClass = graph.findClassByName(expectedArrayClassName)
+      assertThat(arrayClass).isNotNull
+      assertThat(arrayClass!!.isObjectArrayClass).isTrue()
+      assertThat(arrayClass.name).isEqualTo(expectedArrayClassName)
+
+      val array = arrayClass.objectArrayInstances.single()
+      assertThat(array.arrayClassName).isEqualTo(expectedArrayClassName)
+    }
+  }
+
+  @Test fun `JVM primitive wrapper array class name is translated to brackets`() {
+    val hprofFile = dumpHeapRetaining(arrayOfNulls<Int?>(42))
+
+    val expectedArrayClassName = "java.lang.Integer[]"
+
+    hprofFile.openHeapGraph().use { graph ->
+      val arrayClass = graph.findClassByName(expectedArrayClassName)
+      assertThat(arrayClass).isNotNull
+      assertThat(arrayClass!!.isObjectArrayClass).isTrue()
+      assertThat(arrayClass.name).isEqualTo(expectedArrayClassName)
+
+      val array = arrayClass.objectArrayInstances.single { it.readElements().count() == 42 }
+      assertThat(array.arrayClassName).isEqualTo(expectedArrayClassName)
+    }
+  }
+
+  @Test fun `JVM multi dimension wrapper primitive array class name is translated to brackets`() {
+    val hprofFile = dumpHeapRetaining(arrayOf(arrayOf(), arrayOf<Int?>()))
+
+    val expectedArrayClassName = "java.lang.Integer[][]"
+
+    hprofFile.openHeapGraph().use { graph ->
+      val arrayClass = graph.findClassByName(expectedArrayClassName)
+      assertThat(arrayClass).isNotNull
+      assertThat(arrayClass!!.isObjectArrayClass).isTrue()
+      assertThat(arrayClass.name).isEqualTo(expectedArrayClassName)
+
+      val array = arrayClass.objectArrayInstances.single { it.readElements().count() == 2 }
+      assertThat(array.arrayClassName).isEqualTo(expectedArrayClassName)
+    }
+  }
+
+  @Test fun `JVM primitive array class name is translated to brackets`() {
+    val hprofFile = dumpHeapRetaining(IntArray(42).apply { this[0] = 0xDad })
+
+    val expectedArrayClassName = "int[]"
+
+    hprofFile.openHeapGraph().use { graph ->
+      val arrayClass = graph.findClassByName(expectedArrayClassName)
+      assertThat(arrayClass).isNotNull
+      assertThat(arrayClass!!.isPrimitiveArrayClass).isTrue()
+      assertThat(arrayClass.name).isEqualTo(expectedArrayClassName)
+
+      val array = arrayClass.primitiveArrayInstances.single {
+        it.primitiveType == INT && it.readRecord()
+          .run { size == 42 && (this as IntArrayDump).array[0] == 0xDad }
+      }
+      assertThat(array.arrayClassName).isEqualTo(expectedArrayClassName)
+    }
+  }
+
+  @Test fun `JVM multi dimension primitive array class name is translated to brackets`() {
+    val hprofFile = dumpHeapRetaining(arrayOf(IntArray(42), IntArray(42)))
+
+    val expectedArrayClassName = "int[][]"
+
+    hprofFile.openHeapGraph().use { graph ->
+      val arrayClass = graph.findClassByName(expectedArrayClassName)
+      assertThat(arrayClass).isNotNull
+      assertThat(arrayClass!!.isPrimitiveArrayClass).isFalse()
+      assertThat(arrayClass.name).isEqualTo(expectedArrayClassName)
+
+      val array = arrayClass.objectArrayInstances.single {
+        it.readRecord().elementIds.size == 2
+      }
+      assertThat(array.arrayClassName).isEqualTo(expectedArrayClassName)
+    }
+  }
+
+  private fun dumpHeapRetaining(retained: Any): File {
+    val hprofFolder = testFolder.newFolder()
+    val hprofFile = File(hprofFolder, "jvm_heap.hprof")
+    JvmTestHeapDumper.dumpHeap(hprofFile.absolutePath)
+    // Dumb check to prevent instance from being garbage collected.
+    check(retained::class::class.isInstance(KClass::class))
+    return hprofFile
+  }
+}
+
+private val KClass<out Any>.name: String
+  get() = this.java.name
diff --git a/shark-graph/src/test/java/shark/LongScatterSetAssertion.kt b/shark-graph/src/test/java/shark/LongScatterSetAssertion.kt
new file mode 100644
index 00000000..7ce30a81
--- /dev/null
+++ b/shark-graph/src/test/java/shark/LongScatterSetAssertion.kt
@@ -0,0 +1,40 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import shark.internal.hppc.LongScatterSet
+
+/**
+ * Assertion class for writing checks for [LongScatterSet] in AssertJ style.
+ * API is made similar to [org.assertj.core.api.AbstractIterableAssert].
+ */
+internal class LongScatterSetAssertion(private val actual: LongScatterSet) {
+
+  fun contains(value: Long) = apply {
+    assertThat(value in actual).isTrue()
+  }
+
+  fun contains(values: List<Long>) = apply {
+    values.forEach { contains(it) }
+  }
+
+  fun containsExactly(value: Long) = apply {
+    hasSize(1)
+    contains(value)
+  }
+
+  fun containsExactly(values: List<Long>) = apply {
+    hasSize(values.size)
+    contains(values)
+  }
+
+  fun hasSize(expected: Int) = apply {
+    assertThat(actual.size()).isEqualTo(expected)
+  }
+
+  fun isEmpty() = hasSize(0)
+
+  companion object {
+    fun assertThat(actual: LongScatterSet): LongScatterSetAssertion =
+      LongScatterSetAssertion(actual)
+  }
+}
diff --git a/shark-graph/src/test/java/shark/LongScatterSetTest.kt b/shark-graph/src/test/java/shark/LongScatterSetTest.kt
new file mode 100644
index 00000000..490d9f8b
--- /dev/null
+++ b/shark-graph/src/test/java/shark/LongScatterSetTest.kt
@@ -0,0 +1,136 @@
+package shark
+
+import org.assertj.core.api.Assertions
+import org.junit.Test
+import shark.LongScatterSetAssertion.Companion.assertThat
+import shark.internal.hppc.HPPC.mixPhi
+import shark.internal.hppc.LongScatterSet
+
+class LongScatterSetTest {
+
+  @Test fun `new set is empty`() {
+    assertThat(LongScatterSet())
+      .isEmpty()
+  }
+
+  @Test fun `LongScatterSet#add() adds elements`() {
+    val set = LongScatterSet()
+
+    TEST_VALUES_LIST.forEach { set.add(it) }
+
+    assertThat(set)
+      .containsExactly(TEST_VALUES_LIST)
+  }
+
+  @Test fun `+= operator works as addition`() {
+    val set = LongScatterSet()
+
+    set += TEST_VALUE
+
+    assertThat(set)
+      .containsExactly(TEST_VALUE)
+  }
+
+  @Test fun `when adding element twice, it is only added once`() {
+    val set = LongScatterSet()
+
+    set.add(TEST_VALUE)
+    set.add(TEST_VALUE)
+
+    assertThat(set)
+      .containsExactly(TEST_VALUE)
+  }
+
+  /**
+   * [LongScatterSet] calculates hash for its values using [mixPhi] function.
+   * Inevitably, there can be collisions when two different values have same hash value;
+   * [LongScatterSet] should handle such collisions properly.
+   * There are two tests that verify adding and removing operations for values with matching hash value;
+   * current test verifies that values we use in those tests actually do have matching hashes.
+   */
+  @Test fun `11 and 14_723_950_898 have same hash`() {
+    Assertions.assertThat(mixPhi(11))
+      .isEqualTo(mixPhi(14_723_950_898))
+  }
+
+  @Test fun `elements with equal hash can be added`() {
+    val set = LongScatterSet()
+
+    set.add(SAME_MIX_PHI_1)
+    set.add(SAME_MIX_PHI_2)
+
+    assertThat(set)
+      .containsExactly(listOf(SAME_MIX_PHI_1, SAME_MIX_PHI_2))
+  }
+
+  @Test fun `LongScatterSet#remove() removes elements`() {
+    val set = LongScatterSet()
+    TEST_VALUES_LIST.forEach { set.add(it) }
+
+    TEST_VALUES_LIST.forEach { set.remove(it) }
+
+    assertThat(set)
+      .isEmpty()
+  }
+
+  @Test fun `removing from empty set`() {
+    val set = LongScatterSet()
+
+    set.remove(TEST_VALUE)
+
+    assertThat(set)
+      .isEmpty()
+  }
+
+  @Test fun `elements with equal hash can be removed`() {
+    val set = LongScatterSet()
+    set.add(SAME_MIX_PHI_1)
+    set.add(SAME_MIX_PHI_2)
+
+    set.remove(SAME_MIX_PHI_2)
+
+    assertThat(set)
+      .containsExactly(SAME_MIX_PHI_1)
+  }
+
+  @Test fun `LongScatterSet#release() empties set`() {
+    val set = LongScatterSet()
+    set.add(TEST_VALUE)
+
+    set.release()
+
+    assertThat(set)
+      .isEmpty()
+  }
+
+  /**
+   * Verifies that calling [LongScatterSet.ensureCapacity] after elements has been added to set
+   * does not damage the data in set
+   */
+  @Test fun `setting initial capacity after operations`() {
+    val set = LongScatterSet()
+    set.add(TEST_VALUE)
+
+    set.ensureCapacity(TEST_CAPACITY)
+
+    assertThat(set)
+      .containsExactly(TEST_VALUE)
+  }
+
+  @Test fun `adding a lot of elements causes resizing`() {
+    val set = LongScatterSet()
+    (1..100L).forEach { set.add(it) }
+
+    assertThat(set)
+      .containsExactly((1..100L).toList())
+  }
+
+  companion object {
+    // Values SAME_MIX_PHI_1 and SAME_MIX_PHI_2 have same hash when calculated via HHPC.mixPhi()
+    const val SAME_MIX_PHI_1 = 11L
+    const val SAME_MIX_PHI_2 = 14_723_950_898L
+    val TEST_VALUES_LIST = listOf(42, 0, Long.MIN_VALUE, Long.MAX_VALUE, -1)
+    const val TEST_VALUE = 12L
+    const val TEST_CAPACITY = 10
+  }
+}
diff --git a/shark-graph/src/test/java/shark/SortedBytesMapTest.kt b/shark-graph/src/test/java/shark/SortedBytesMapTest.kt
new file mode 100644
index 00000000..c747f5e0
--- /dev/null
+++ b/shark-graph/src/test/java/shark/SortedBytesMapTest.kt
@@ -0,0 +1,202 @@
+package shark
+
+import kotlin.random.Random
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.internal.UnsortedByteEntries
+
+class SortedBytesMapTest {
+
+  @Test fun writeAndReadLongValue() {
+    val unsortedEntries = UnsortedByteEntries(bytesPerValue = 8, longIdentifiers = false)
+    unsortedEntries.append(1)
+      .apply {
+        writeLong(Long.MIN_VALUE)
+      }
+
+    val array = unsortedEntries.moveToSortedMap()[1]!!
+    assertThat(array.readLong()).isEqualTo(Long.MIN_VALUE)
+  }
+
+  @Test fun writeAndReadTruncatedLongValue() {
+    val maxUnsigned3Bytes = 0x00000FFFL
+    val unsortedMap = UnsortedByteEntries(bytesPerValue = 3, longIdentifiers = false)
+    unsortedMap.append(1)
+      .apply {
+        writeTruncatedLong(maxUnsigned3Bytes, 3)
+      }
+
+    val array = unsortedMap.moveToSortedMap()[1]!!
+    assertThat(array.readTruncatedLong(3)).isEqualTo(maxUnsigned3Bytes)
+  }
+
+  @Test fun fourEntriesWithLongKey1ByteValueSorted() {
+    val unsortedEntries = UnsortedByteEntries(bytesPerValue = 1, longIdentifiers = true)
+    unsortedEntries.append(42)
+      .apply {
+        writeByte(4)
+      }
+    unsortedEntries.append(0)
+      .apply {
+        writeByte(3)
+      }
+    unsortedEntries.append(3)
+      .apply {
+        writeByte(20)
+      }
+    unsortedEntries.append(Long.MAX_VALUE)
+      .apply {
+        writeByte(127)
+      }
+    val sortedEntries = unsortedEntries.moveToSortedMap()
+      .entrySequence()
+      .toList()
+
+    assertThat(sortedEntries.map { it.first }).containsExactly(0, 3, 42, Long.MAX_VALUE)
+    assertThat(
+      sortedEntries.map {
+        byteArrayOf(
+          it.second.readByte()
+        )
+      }).containsExactly(
+      byteArrayOf(3), byteArrayOf(20), byteArrayOf(4),
+      byteArrayOf(127)
+    )
+  }
+
+  @Test fun fourEntriesWithLongKey3ByteValueSorted() {
+    val unsortedMap = UnsortedByteEntries(bytesPerValue = 3, longIdentifiers = true)
+    unsortedMap.append(42)
+      .apply {
+        writeByte(4)
+        writeByte(2)
+        writeByte(0)
+      }
+    unsortedMap.append(0)
+      .apply {
+        writeByte(3)
+        writeByte(2)
+        writeByte(1)
+      }
+    unsortedMap.append(3)
+      .apply {
+        writeByte(20)
+        writeByte(52)
+        writeByte(-17)
+      }
+    unsortedMap.append(Long.MAX_VALUE)
+      .apply {
+        writeByte(127)
+        writeByte(0)
+        writeByte(-128)
+      }
+    val sortedEntries = unsortedMap.moveToSortedMap()
+      .entrySequence()
+      .toList()
+
+    assertThat(sortedEntries.map { it.first }).containsExactly(0, 3, 42, Long.MAX_VALUE)
+    assertThat(
+      sortedEntries.map {
+        byteArrayOf(
+          it.second.readByte(), it.second.readByte(), it.second.readByte()
+        )
+      }).containsExactly(
+      byteArrayOf(3, 2, 1), byteArrayOf(20, 52, -17), byteArrayOf(4, 2, 0),
+      byteArrayOf(127, 0, -128)
+    )
+  }
+
+  class Entry(
+    val key: Long,
+    val value: ByteArray
+  ) : Comparable<Entry> {
+    override fun compareTo(other: Entry): Int = key.compareTo(other.key)
+    override fun equals(other: Any?): Boolean {
+      if (this === other) return true
+      if (javaClass != other?.javaClass) return false
+
+      other as Entry
+
+      if (key != other.key) return false
+      if (!value.contentEquals(other.value)) return false
+
+      return true
+    }
+
+    override fun toString(): String {
+      return "Entry(key=$key, value=${value.contentToString()})"
+    }
+  }
+
+  @Test fun largeRandomArrayIntKey3ByteValueSorted() {
+    val random = Random(Long.MAX_VALUE)
+
+    val bytesPerValue = 3
+    val longIdentifiers = false
+
+    val sourceEntryArray = Array(10000) {
+      Entry(random.nextInt().toLong(), random.nextBytes(bytesPerValue))
+    }
+
+    sortAndCompare(bytesPerValue, longIdentifiers, sourceEntryArray)
+  }
+
+  @Test fun largeRandomArrayLongKey3ByteValueSorted() {
+    val random = Random(42)
+
+    val bytesPerValue = 3
+    val longIdentifiers = true
+
+    val sourceEntryArray = Array(10000) {
+      Entry(random.nextLong(), random.nextBytes(bytesPerValue))
+    }
+
+    sortAndCompare(bytesPerValue, longIdentifiers, sourceEntryArray)
+  }
+
+  @Test fun largeRandomArrayLongKey7ByteValueSorted() {
+    val random = Random(Long.MIN_VALUE)
+
+    val bytesPerValue = 7
+    val longIdentifiers = true
+
+    val sourceEntryArray = Array(10000) {
+      Entry(random.nextLong(), random.nextBytes(bytesPerValue))
+    }
+
+    sortAndCompare(bytesPerValue, longIdentifiers, sourceEntryArray)
+  }
+
+  private fun sortAndCompare(
+    bytesPerValue: Int,
+    longIdentifiers: Boolean,
+    sourceEntryArray: Array<Entry>
+  ) {
+    val unsortedEntries =
+      UnsortedByteEntries(bytesPerValue = bytesPerValue, longIdentifiers = longIdentifiers)
+
+    sourceEntryArray.forEach { entry ->
+      val subArray = unsortedEntries.append(entry.key)
+      entry.value.forEach { subArray.writeByte(it) }
+    }
+
+    val sortedMap = unsortedEntries.moveToSortedMap()
+    sourceEntryArray.sort()
+
+    val sortedEntryArray = sortedMap.entrySequence()
+      .map {
+        val key = it.first
+        val value = it.second
+
+        val bytes = mutableListOf<Byte>()
+        for (i in 0 until bytesPerValue) {
+          bytes += value.readByte()
+        }
+        Entry(key, bytes.toByteArray())
+      }
+      .toList()
+      .toTypedArray()
+
+    assertThat(sortedEntryArray).isEqualTo(sourceEntryArray)
+  }
+}
diff --git a/shark-hprof-test/build.gradle b/shark-hprof-test/build.gradle
new file mode 100644
index 00000000..1a9cee7f
--- /dev/null
+++ b/shark-hprof-test/build.gradle
@@ -0,0 +1,14 @@
+plugins {
+  id("org.jetbrains.kotlin.jvm")
+}
+
+sourceCompatibility = JavaVersion.VERSION_1_8
+targetCompatibility = JavaVersion.VERSION_1_8
+
+dependencies {
+    implementation libs.kotlin.stdlib
+    implementation libs.junit
+    implementation libs.okio2
+
+    implementation projects.sharkHprof
+}
diff --git a/shark-hprof-test/src/main/kotlin/shark/HprofWriterHelper.kt b/shark-hprof-test/src/main/kotlin/shark/HprofWriterHelper.kt
new file mode 100644
index 00000000..81987320
--- /dev/null
+++ b/shark-hprof-test/src/main/kotlin/shark/HprofWriterHelper.kt
@@ -0,0 +1,387 @@
+package shark
+
+import okio.Buffer
+import shark.GcRoot.StickyClass
+import shark.HprofRecord.HeapDumpRecord.GcRootRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StringRecord
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.BYTE
+import shark.PrimitiveType.CHAR
+import shark.PrimitiveType.DOUBLE
+import shark.PrimitiveType.FLOAT
+import shark.PrimitiveType.INT
+import shark.PrimitiveType.LONG
+import shark.PrimitiveType.SHORT
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+import java.io.Closeable
+import java.io.File
+import java.util.UUID
+import kotlin.random.Random
+import kotlin.reflect.KClass
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+
+class HprofWriterHelper constructor(
+  private val writer: HprofWriter
+) : Closeable {
+
+  private var lastId = 0L
+  private val id: Long
+    get() = ++lastId
+
+  private val weakRefKeyRandom = Random(42)
+
+  // Sequence identical for every test run
+  private val weakRefKey: String
+    get() =
+      UUID(weakRefKeyRandom.nextLong(), weakRefKeyRandom.nextLong()).toString()
+
+  private val typeSizes =
+    PrimitiveType.byteSizeByHprofType + (PrimitiveType.REFERENCE_HPROF_TYPE to writer.hprofHeader.identifierByteSize)
+
+  private val classDumps = mutableMapOf<Long, ClassDumpRecord>()
+
+  private val objectClassId = clazz(superclassId = 0, className = "java.lang.Object")
+  private val objectArrayClassId = arrayClass("java.lang.Object")
+  private val stringClassId = clazz(
+    className = "java.lang.String", fields = listOf(
+    "value" to ReferenceHolder::class,
+    "count" to IntHolder::class
+  )
+  )
+
+  private val referenceClassId = clazz(
+    className = "java.lang.ref.Reference",
+    fields = listOf(
+      "referent" to ReferenceHolder::class
+    )
+  )
+
+  private val weakReferenceClassId = clazz(
+    className = "java.lang.ref.WeakReference",
+    superclassId = referenceClassId
+  )
+  private val keyedWeakReferenceClassId = clazz(
+    superclassId = weakReferenceClassId,
+    className = "leakcanary.KeyedWeakReference",
+    staticFields = listOf("heapDumpUptimeMillis" to LongHolder(30000)),
+    fields = listOf(
+      "key" to ReferenceHolder::class,
+      "name" to ReferenceHolder::class,
+      "watchUptimeMillis" to LongHolder::class,
+      "retainedUptimeMillis" to LongHolder::class
+    )
+  )
+
+  fun clazz(
+    className: String,
+    superclassId: Long = -1L, // -1 defaults to java.lang.Object
+    staticFields: List<Pair<String, ValueHolder>> = emptyList(),
+    fields: List<Pair<String, KClass<out ValueHolder>>> = emptyList()
+  ): Long {
+    val classNameRecord = StringRecord(id, className)
+    writer.write(classNameRecord)
+    val loadClass = LoadClassRecord(1, id, 1, classNameRecord.id)
+    writer.write(loadClass)
+
+    val staticFieldRecords = staticFields.map {
+      val fieldName = StringRecord(id, it.first)
+      writer.write(fieldName)
+      StaticFieldRecord(fieldName.id, typeOf(it.second), it.second)
+    }
+
+    val fieldRecords = fields.map {
+      val fieldName = StringRecord(id, it.first)
+      writer.write(fieldName)
+      FieldRecord(fieldName.id, typeOf(it.second))
+    }
+
+    var instanceSize = fieldRecords.sumBy {
+      typeSizes.getValue(it.type)
+    }
+
+    var nextUpId = if (superclassId == -1L) objectClassId else superclassId
+    while (nextUpId != 0L) {
+      val nextUp = classDumps[nextUpId]!!
+      instanceSize += nextUp.fields.sumBy {
+        typeSizes.getValue(it.type)
+      }
+      nextUpId = nextUp.superclassId
+    }
+    val classDump = ClassDumpRecord(
+      id = loadClass.id,
+      stackTraceSerialNumber = 1,
+      superclassId = if (superclassId == -1L) objectClassId else superclassId,
+      classLoaderId = 0,
+      signersId = 0,
+      protectionDomainId = 0,
+      instanceSize = instanceSize,
+      staticFields = staticFieldRecords,
+      fields = fieldRecords
+    )
+    classDumps[loadClass.id] = classDump
+    writer.write(classDump)
+    val gcRoot = StickyClass(classDump.id)
+    gcRoot(gcRoot)
+    return classDump.id
+  }
+
+  fun stringRecord(
+    name: String
+  ): StringRecord {
+    val stringRecord = StringRecord(id, name)
+    writer.write(stringRecord)
+    return stringRecord
+  }
+
+  fun clazz(
+    classNameRecord: StringRecord,
+    superclassId: Long = -1L, // -1 defaults to java.lang.Object
+    staticFields: List<Pair<Long, ValueHolder>> = emptyList(),
+    fields: List<Pair<Long, KClass<out ValueHolder>>> = emptyList()
+  ): Long {
+    val loadClass = LoadClassRecord(1, id, 1, classNameRecord.id)
+    writer.write(loadClass)
+
+    val staticFieldRecords = staticFields.map {
+      StaticFieldRecord(it.first, typeOf(it.second), it.second)
+    }
+
+    val fieldRecords = fields.map {
+      FieldRecord(it.first, typeOf(it.second))
+    }
+
+    var instanceSize = fieldRecords.sumBy {
+      typeSizes.getValue(it.type)
+    }
+
+    var nextUpId = if (superclassId == -1L) objectClassId else superclassId
+    while (nextUpId != 0L) {
+      val nextUp = classDumps[nextUpId]!!
+      instanceSize += nextUp.fields.sumBy {
+        typeSizes.getValue(it.type)
+      }
+      nextUpId = nextUp.superclassId
+    }
+    val classDump = ClassDumpRecord(
+      id = loadClass.id,
+      stackTraceSerialNumber = 1,
+      superclassId = if (superclassId == -1L) objectClassId else superclassId,
+      classLoaderId = 0,
+      signersId = 0,
+      protectionDomainId = 0,
+      instanceSize = instanceSize,
+      staticFields = staticFieldRecords,
+      fields = fieldRecords
+    )
+    classDumps[loadClass.id] = classDump
+    writer.write(classDump)
+    val gcRoot = StickyClass(classDump.id)
+    gcRoot(gcRoot)
+    return classDump.id
+  }
+
+  fun gcRoot(gcRoot: GcRoot) {
+    val gcRootRecord = GcRootRecord(gcRoot = gcRoot)
+    writer.write(gcRootRecord)
+  }
+
+  fun arrayClass(className: String): Long {
+    return clazz(className = "$className[]")
+  }
+
+  fun string(
+    string: String
+  ): ReferenceHolder {
+    return instance(
+      stringClassId,
+      fields = listOf(string.charArrayDump, IntHolder(string.length))
+    )
+  }
+
+  fun keyedWeakReference(
+    referentInstanceId: ReferenceHolder
+  ): ReferenceHolder {
+    val referenceKey = string(weakRefKey)
+    return instance(
+      classId = keyedWeakReferenceClassId,
+      fields = listOf(
+        referenceKey,
+        string("its lifecycle has ended"),
+        LongHolder(5000),
+        LongHolder(20000),
+        ReferenceHolder(referentInstanceId.value)
+      )
+    )
+  }
+
+  fun instance(
+    classId: Long,
+    fields: List<ValueHolder> = emptyList()
+  ): ReferenceHolder {
+    val instanceDump = InstanceDumpRecord(
+      id = id,
+      stackTraceSerialNumber = 1,
+      classId = classId,
+      fieldValues = writer.valuesToBytes(fields)
+    )
+    writer.write(instanceDump)
+    return ReferenceHolder(instanceDump.id)
+  }
+
+  inner class InstanceAndClassDefinition {
+    val field = LinkedHashMap<String, ValueHolder>()
+    val staticField = LinkedHashMap<String, ValueHolder>()
+  }
+
+  inner class ClassDefinition {
+    val staticField = LinkedHashMap<String, ValueHolder>()
+  }
+
+  infix fun String.watchedInstance(block: InstanceAndClassDefinition.() -> Unit): ReferenceHolder {
+    val instance = this.instance(block)
+    keyedWeakReference(instance)
+    return instance
+  }
+
+  infix fun String.instance(block: InstanceAndClassDefinition.() -> Unit): ReferenceHolder {
+    val definition = InstanceAndClassDefinition()
+    block(definition)
+
+    val classFields = definition.field.map {
+      it.key to it.value::class
+    }
+
+    val staticFields = definition.staticField.map { it.key to it.value }
+
+    val instanceFields = definition.field.map { it.value }
+
+    return instance(clazz(this, fields = classFields, staticFields = staticFields), instanceFields)
+  }
+
+  infix fun String.clazz(block: ClassDefinition.() -> Unit): Long {
+    val definition = ClassDefinition()
+    block(definition)
+
+    val staticFields = definition.staticField.map { it.key to it.value }
+    return clazz(this, staticFields = staticFields)
+  }
+
+  val String.charArrayDump: ReferenceHolder
+    get() {
+      val arrayDump = CharArrayDump(id, 1, toCharArray())
+      writer.write(arrayDump)
+      return ReferenceHolder(arrayDump.id)
+    }
+
+  fun objectArray(
+    vararg elements: ReferenceHolder
+  ): ReferenceHolder {
+    return objectArrayOf(objectArrayClassId, *elements)
+  }
+
+  fun objectArrayOf(
+    classId: Long,
+    vararg elements: ReferenceHolder
+  ): ReferenceHolder {
+    return ReferenceHolder(objectArray(classId, elements.map { it.value }.toLongArray()))
+  }
+
+  fun objectArray(
+    classId: Long,
+    array: LongArray
+  ): Long {
+    val arrayDump = ObjectArrayDumpRecord(id, 1, classId, array)
+    writer.write(arrayDump)
+    return arrayDump.id
+  }
+
+  fun primitiveLongArray(array: LongArray): Long {
+    val arrayDump = LongArrayDump(id, 1, array)
+    writer.write(arrayDump)
+    return arrayDump.id
+  }
+
+  private fun typeOf(wrapper: ValueHolder): Int {
+    return when (wrapper) {
+      is ReferenceHolder -> PrimitiveType.REFERENCE_HPROF_TYPE
+      is BooleanHolder -> BOOLEAN.hprofType
+      is CharHolder -> CHAR.hprofType
+      is FloatHolder -> FLOAT.hprofType
+      is DoubleHolder -> DOUBLE.hprofType
+      is ByteHolder -> BYTE.hprofType
+      is ShortHolder -> SHORT.hprofType
+      is IntHolder -> INT.hprofType
+      is LongHolder -> LONG.hprofType
+    }
+  }
+
+  private fun typeOf(wrapperClass: KClass<out ValueHolder>): Int {
+    return when (wrapperClass) {
+      ReferenceHolder::class -> PrimitiveType.REFERENCE_HPROF_TYPE
+      BooleanHolder::class -> BOOLEAN.hprofType
+      CharHolder::class -> CHAR.hprofType
+      FloatHolder::class -> FLOAT.hprofType
+      DoubleHolder::class -> DOUBLE.hprofType
+      ByteHolder::class -> BYTE.hprofType
+      ShortHolder::class -> SHORT.hprofType
+      IntHolder::class -> INT.hprofType
+      LongHolder::class -> LONG.hprofType
+      else -> throw IllegalArgumentException("Unexpected class $wrapperClass")
+    }
+  }
+
+  override fun close() {
+    writer.close()
+  }
+}
+
+fun File.dump(block: HprofWriterHelper.() -> Unit) {
+  HprofWriterHelper(HprofWriter.openWriterFor(this))
+    .use(block)
+}
+
+fun dump(
+  hprofHeader: HprofHeader = HprofHeader(),
+  block: HprofWriterHelper.() -> Unit
+): DualSourceProvider {
+  val buffer = Buffer()
+  HprofWriterHelper(HprofWriter.openWriterFor(buffer, hprofHeader))
+    .use(block)
+  return ByteArraySourceProvider(buffer.readByteArray())
+}
+
+fun dumpToBytes(
+  hprofHeader: HprofHeader = HprofHeader(),
+  block: HprofWriterHelper.() -> Unit
+): ByteArray {
+  val buffer = Buffer()
+  HprofWriterHelper(HprofWriter.openWriterFor(buffer, hprofHeader))
+    .use(block)
+  return buffer.readByteArray()
+}
+
+fun List<HprofRecord>.asHprofBytes(): DualSourceProvider {
+  val buffer = Buffer()
+  HprofWriter.openWriterFor(buffer)
+    .use { writer ->
+      forEach { record ->
+        writer.write(record)
+      }
+    }
+  return ByteArraySourceProvider(buffer.readByteArray())
+}
diff --git a/shark-hprof-test/src/main/kotlin/shark/ProguardMappingHelper.kt b/shark-hprof-test/src/main/kotlin/shark/ProguardMappingHelper.kt
new file mode 100644
index 00000000..c9b8b8cd
--- /dev/null
+++ b/shark-hprof-test/src/main/kotlin/shark/ProguardMappingHelper.kt
@@ -0,0 +1,30 @@
+package shark
+
+class ProguardMappingHelper(
+  private val proguardMapping: ProguardMapping
+) {
+  fun clazz(
+    className: Pair<String, String>,
+    fieldsBlock: Class.() -> Unit = {}
+  ) {
+    val clazz = Class(className)
+    fieldsBlock(clazz)
+    proguardMapping.addMapping(clazz.nameMapping.second, clazz.nameMapping.first)
+    clazz.fieldMappings.forEach { field ->
+      proguardMapping.addMapping("${clazz.nameMapping.second}.${field.second}", field.first)
+    }
+  }
+
+  inner class Class(val nameMapping: Pair<String, String>) {
+    val fieldMappings = mutableSetOf<Pair<String, String>>()
+  }
+
+  fun Class.field(block: () -> Pair<String, String>) {
+    fieldMappings.add(block())
+  }
+}
+
+fun ProguardMapping.create(block: ProguardMappingHelper.() -> Unit): ProguardMapping {
+  block(ProguardMappingHelper(this))
+  return this
+}
\ No newline at end of file
diff --git a/shark-hprof/api/shark-hprof.api b/shark-hprof/api/shark-hprof.api
new file mode 100644
index 00000000..5acd1994
--- /dev/null
+++ b/shark-hprof/api/shark-hprof.api
@@ -0,0 +1,744 @@
+public final class shark/ByteArraySourceProvider : shark/DualSourceProvider {
+	public fun <init> ([B)V
+	public fun openRandomAccessSource ()Lshark/RandomAccessSource;
+	public fun openStreamingSource ()Lokio/BufferedSource;
+}
+
+public final class shark/ConstantMemoryMetricsDualSourceProvider : shark/DualSourceProvider {
+	public fun <init> (Lshark/DualSourceProvider;)V
+	public final fun getByteTravelRange ()J
+	public final fun getRandomAccessByteReads ()J
+	public final fun getRandomAccessByteTravel ()J
+	public final fun getRandomAccessReadCount ()J
+	public fun openRandomAccessSource ()Lshark/RandomAccessSource;
+	public fun openStreamingSource ()Lokio/BufferedSource;
+}
+
+public abstract interface class shark/DualSourceProvider : shark/RandomAccessSourceProvider, shark/StreamingSourceProvider {
+}
+
+public final class shark/FileSourceProvider : shark/DualSourceProvider {
+	public fun <init> (Ljava/io/File;)V
+	public fun openRandomAccessSource ()Lshark/RandomAccessSource;
+	public fun openStreamingSource ()Lokio/BufferedSource;
+}
+
+public abstract class shark/GcRoot {
+	public abstract fun getId ()J
+}
+
+public final class shark/GcRoot$Debugger : shark/GcRoot {
+	public fun <init> (J)V
+	public fun getId ()J
+}
+
+public final class shark/GcRoot$Finalizing : shark/GcRoot {
+	public fun <init> (J)V
+	public fun getId ()J
+}
+
+public final class shark/GcRoot$InternedString : shark/GcRoot {
+	public fun <init> (J)V
+	public fun getId ()J
+}
+
+public final class shark/GcRoot$JavaFrame : shark/GcRoot {
+	public fun <init> (JII)V
+	public final fun getFrameNumber ()I
+	public fun getId ()J
+	public final fun getThreadSerialNumber ()I
+}
+
+public final class shark/GcRoot$JniGlobal : shark/GcRoot {
+	public fun <init> (JJ)V
+	public fun getId ()J
+	public final fun getJniGlobalRefId ()J
+}
+
+public final class shark/GcRoot$JniLocal : shark/GcRoot {
+	public fun <init> (JII)V
+	public final fun getFrameNumber ()I
+	public fun getId ()J
+	public final fun getThreadSerialNumber ()I
+}
+
+public final class shark/GcRoot$JniMonitor : shark/GcRoot {
+	public fun <init> (JII)V
+	public fun getId ()J
+	public final fun getStackDepth ()I
+	public final fun getStackTraceSerialNumber ()I
+}
+
+public final class shark/GcRoot$MonitorUsed : shark/GcRoot {
+	public fun <init> (J)V
+	public fun getId ()J
+}
+
+public final class shark/GcRoot$NativeStack : shark/GcRoot {
+	public fun <init> (JI)V
+	public fun getId ()J
+	public final fun getThreadSerialNumber ()I
+}
+
+public final class shark/GcRoot$ReferenceCleanup : shark/GcRoot {
+	public fun <init> (J)V
+	public fun getId ()J
+}
+
+public final class shark/GcRoot$StickyClass : shark/GcRoot {
+	public fun <init> (J)V
+	public fun getId ()J
+}
+
+public final class shark/GcRoot$ThreadBlock : shark/GcRoot {
+	public fun <init> (JI)V
+	public fun getId ()J
+	public final fun getThreadSerialNumber ()I
+}
+
+public final class shark/GcRoot$ThreadObject : shark/GcRoot {
+	public fun <init> (JII)V
+	public fun getId ()J
+	public final fun getStackTraceSerialNumber ()I
+	public final fun getThreadSerialNumber ()I
+}
+
+public final class shark/GcRoot$Unknown : shark/GcRoot {
+	public fun <init> (J)V
+	public fun getId ()J
+}
+
+public final class shark/GcRoot$Unreachable : shark/GcRoot {
+	public fun <init> (J)V
+	public fun getId ()J
+}
+
+public final class shark/GcRoot$VmInternal : shark/GcRoot {
+	public fun <init> (J)V
+	public fun getId ()J
+}
+
+public final class shark/Hprof : java/io/Closeable {
+	public static final field Companion Lshark/Hprof$Companion;
+	public synthetic fun <init> (Ljava/io/File;Lshark/HprofHeader;Lkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun attachClosable (Ljava/io/Closeable;)V
+	public fun close ()V
+	public final fun getFile ()Ljava/io/File;
+	public final fun getFileLength ()J
+	public final fun getHeader ()Lshark/HprofHeader;
+	public final fun getHeapDumpTimestamp ()J
+	public final fun getHprofVersion ()Lshark/Hprof$HprofVersion;
+	public final fun getReader ()Lshark/HprofReader;
+}
+
+public final class shark/Hprof$Companion {
+	public final fun open (Ljava/io/File;)Lshark/Hprof;
+}
+
+public final class shark/Hprof$HprofVersion : java/lang/Enum {
+	public static final field ANDROID Lshark/Hprof$HprofVersion;
+	public static final field JDK1_2_BETA3 Lshark/Hprof$HprofVersion;
+	public static final field JDK1_2_BETA4 Lshark/Hprof$HprofVersion;
+	public static final field JDK_6 Lshark/Hprof$HprofVersion;
+	public final fun getVersionString ()Ljava/lang/String;
+	public static fun valueOf (Ljava/lang/String;)Lshark/Hprof$HprofVersion;
+	public static fun values ()[Lshark/Hprof$HprofVersion;
+}
+
+public final class shark/HprofDeobfuscator {
+	public fun <init> ()V
+	public final fun deobfuscate (Lshark/ProguardMapping;Ljava/io/File;Ljava/io/File;)Ljava/io/File;
+	public static synthetic fun deobfuscate$default (Lshark/HprofDeobfuscator;Lshark/ProguardMapping;Ljava/io/File;Ljava/io/File;ILjava/lang/Object;)Ljava/io/File;
+}
+
+public final class shark/HprofHeader {
+	public static final field Companion Lshark/HprofHeader$Companion;
+	public fun <init> ()V
+	public fun <init> (JLshark/HprofVersion;I)V
+	public synthetic fun <init> (JLshark/HprofVersion;IILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun component1 ()J
+	public final fun component2 ()Lshark/HprofVersion;
+	public final fun component3 ()I
+	public final fun copy (JLshark/HprofVersion;I)Lshark/HprofHeader;
+	public static synthetic fun copy$default (Lshark/HprofHeader;JLshark/HprofVersion;IILjava/lang/Object;)Lshark/HprofHeader;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getHeapDumpTimestamp ()J
+	public final fun getIdentifierByteSize ()I
+	public final fun getRecordsPosition ()I
+	public final fun getVersion ()Lshark/HprofVersion;
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/HprofHeader$Companion {
+	public final fun parseHeaderOf (Ljava/io/File;)Lshark/HprofHeader;
+	public final fun parseHeaderOf (Lokio/BufferedSource;)Lshark/HprofHeader;
+}
+
+public final class shark/HprofPrimitiveArrayStripper {
+	public fun <init> ()V
+	public final fun stripPrimitiveArrays (Ljava/io/File;Ljava/io/File;)Ljava/io/File;
+	public final fun stripPrimitiveArrays (Lshark/StreamingSourceProvider;Lokio/BufferedSink;)V
+	public static synthetic fun stripPrimitiveArrays$default (Lshark/HprofPrimitiveArrayStripper;Ljava/io/File;Ljava/io/File;ILjava/lang/Object;)Ljava/io/File;
+}
+
+public final class shark/HprofReader {
+	public final fun getIdentifierByteSize ()I
+	public final fun getStartPosition ()J
+	public final fun readHprofRecords (Ljava/util/Set;Lshark/OnHprofRecordListener;)V
+}
+
+public abstract class shark/HprofRecord {
+}
+
+public final class shark/HprofRecord$HeapDumpEndRecord : shark/HprofRecord {
+	public static final field INSTANCE Lshark/HprofRecord$HeapDumpEndRecord;
+}
+
+public abstract class shark/HprofRecord$HeapDumpRecord : shark/HprofRecord {
+}
+
+public final class shark/HprofRecord$HeapDumpRecord$GcRootRecord : shark/HprofRecord$HeapDumpRecord {
+	public fun <init> (Lshark/GcRoot;)V
+	public final fun getGcRoot ()Lshark/GcRoot;
+}
+
+public final class shark/HprofRecord$HeapDumpRecord$HeapDumpInfoRecord : shark/HprofRecord$HeapDumpRecord {
+	public fun <init> (IJ)V
+	public final fun getHeapId ()I
+	public final fun getHeapNameStringId ()J
+}
+
+public abstract class shark/HprofRecord$HeapDumpRecord$ObjectRecord : shark/HprofRecord$HeapDumpRecord {
+}
+
+public final class shark/HprofRecord$HeapDumpRecord$ObjectRecord$ClassDumpRecord : shark/HprofRecord$HeapDumpRecord$ObjectRecord {
+	public fun <init> (JIJJJJILjava/util/List;Ljava/util/List;)V
+	public final fun getClassLoaderId ()J
+	public final fun getFields ()Ljava/util/List;
+	public final fun getId ()J
+	public final fun getInstanceSize ()I
+	public final fun getProtectionDomainId ()J
+	public final fun getSignersId ()J
+	public final fun getStackTraceSerialNumber ()I
+	public final fun getStaticFields ()Ljava/util/List;
+	public final fun getSuperclassId ()J
+}
+
+public final class shark/HprofRecord$HeapDumpRecord$ObjectRecord$ClassDumpRecord$FieldRecord {
+	public fun <init> (JI)V
+	public final fun component1 ()J
+	public final fun component2 ()I
+	public final fun copy (JI)Lshark/HprofRecord$HeapDumpRecord$ObjectRecord$ClassDumpRecord$FieldRecord;
+	public static synthetic fun copy$default (Lshark/HprofRecord$HeapDumpRecord$ObjectRecord$ClassDumpRecord$FieldRecord;JIILjava/lang/Object;)Lshark/HprofRecord$HeapDumpRecord$ObjectRecord$ClassDumpRecord$FieldRecord;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getNameStringId ()J
+	public final fun getType ()I
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/HprofRecord$HeapDumpRecord$ObjectRecord$ClassDumpRecord$StaticFieldRecord {
+	public fun <init> (JILshark/ValueHolder;)V
+	public final fun component1 ()J
+	public final fun component2 ()I
+	public final fun component3 ()Lshark/ValueHolder;
+	public final fun copy (JILshark/ValueHolder;)Lshark/HprofRecord$HeapDumpRecord$ObjectRecord$ClassDumpRecord$StaticFieldRecord;
+	public static synthetic fun copy$default (Lshark/HprofRecord$HeapDumpRecord$ObjectRecord$ClassDumpRecord$StaticFieldRecord;JILshark/ValueHolder;ILjava/lang/Object;)Lshark/HprofRecord$HeapDumpRecord$ObjectRecord$ClassDumpRecord$StaticFieldRecord;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getNameStringId ()J
+	public final fun getType ()I
+	public final fun getValue ()Lshark/ValueHolder;
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/HprofRecord$HeapDumpRecord$ObjectRecord$InstanceDumpRecord : shark/HprofRecord$HeapDumpRecord$ObjectRecord {
+	public fun <init> (JIJ[B)V
+	public final fun getClassId ()J
+	public final fun getFieldValues ()[B
+	public final fun getId ()J
+	public final fun getStackTraceSerialNumber ()I
+}
+
+public final class shark/HprofRecord$HeapDumpRecord$ObjectRecord$ObjectArrayDumpRecord : shark/HprofRecord$HeapDumpRecord$ObjectRecord {
+	public fun <init> (JIJ[J)V
+	public final fun getArrayClassId ()J
+	public final fun getElementIds ()[J
+	public final fun getId ()J
+	public final fun getStackTraceSerialNumber ()I
+}
+
+public abstract class shark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord : shark/HprofRecord$HeapDumpRecord$ObjectRecord {
+	public abstract fun getId ()J
+	public abstract fun getSize ()I
+	public abstract fun getStackTraceSerialNumber ()I
+}
+
+public final class shark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord$BooleanArrayDump : shark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord {
+	public fun <init> (JI[Z)V
+	public final fun getArray ()[Z
+	public fun getId ()J
+	public fun getSize ()I
+	public fun getStackTraceSerialNumber ()I
+}
+
+public final class shark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord$ByteArrayDump : shark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord {
+	public fun <init> (JI[B)V
+	public final fun getArray ()[B
+	public fun getId ()J
+	public fun getSize ()I
+	public fun getStackTraceSerialNumber ()I
+}
+
+public final class shark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord$CharArrayDump : shark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord {
+	public fun <init> (JI[C)V
+	public final fun getArray ()[C
+	public fun getId ()J
+	public fun getSize ()I
+	public fun getStackTraceSerialNumber ()I
+}
+
+public final class shark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord$DoubleArrayDump : shark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord {
+	public fun <init> (JI[D)V
+	public final fun getArray ()[D
+	public fun getId ()J
+	public fun getSize ()I
+	public fun getStackTraceSerialNumber ()I
+}
+
+public final class shark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord$FloatArrayDump : shark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord {
+	public fun <init> (JI[F)V
+	public final fun getArray ()[F
+	public fun getId ()J
+	public fun getSize ()I
+	public fun getStackTraceSerialNumber ()I
+}
+
+public final class shark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord$IntArrayDump : shark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord {
+	public fun <init> (JI[I)V
+	public final fun getArray ()[I
+	public fun getId ()J
+	public fun getSize ()I
+	public fun getStackTraceSerialNumber ()I
+}
+
+public final class shark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord$LongArrayDump : shark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord {
+	public fun <init> (JI[J)V
+	public final fun getArray ()[J
+	public fun getId ()J
+	public fun getSize ()I
+	public fun getStackTraceSerialNumber ()I
+}
+
+public final class shark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord$ShortArrayDump : shark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord {
+	public fun <init> (JI[S)V
+	public final fun getArray ()[S
+	public fun getId ()J
+	public fun getSize ()I
+	public fun getStackTraceSerialNumber ()I
+}
+
+public final class shark/HprofRecord$LoadClassRecord : shark/HprofRecord {
+	public fun <init> (IJIJ)V
+	public final fun getClassNameStringId ()J
+	public final fun getClassSerialNumber ()I
+	public final fun getId ()J
+	public final fun getStackTraceSerialNumber ()I
+}
+
+public final class shark/HprofRecord$StackFrameRecord : shark/HprofRecord {
+	public fun <init> (JJJJII)V
+	public final fun getClassSerialNumber ()I
+	public final fun getId ()J
+	public final fun getLineNumber ()I
+	public final fun getMethodNameStringId ()J
+	public final fun getMethodSignatureStringId ()J
+	public final fun getSourceFileNameStringId ()J
+}
+
+public final class shark/HprofRecord$StackTraceRecord : shark/HprofRecord {
+	public fun <init> (II[J)V
+	public final fun getStackFrameIds ()[J
+	public final fun getStackTraceSerialNumber ()I
+	public final fun getThreadSerialNumber ()I
+}
+
+public final class shark/HprofRecord$StringRecord : shark/HprofRecord {
+	public fun <init> (JLjava/lang/String;)V
+	public final fun getId ()J
+	public final fun getString ()Ljava/lang/String;
+}
+
+public final class shark/HprofRecordReader {
+	public static final field Companion Lshark/HprofRecordReader$Companion;
+	public final fun getBytesRead ()J
+	public final fun readBoolean ()Z
+	public final fun readBooleanArray (I)[Z
+	public final fun readByte ()B
+	public final fun readByteArray (I)[B
+	public final fun readChar ()C
+	public final fun readCharArray (I)[C
+	public final fun readClassDumpRecord ()Lshark/HprofRecord$HeapDumpRecord$ObjectRecord$ClassDumpRecord;
+	public final fun readDebuggerGcRootRecord ()Lshark/GcRoot$Debugger;
+	public final fun readDouble ()D
+	public final fun readDoubleArray (I)[D
+	public final fun readFinalizingGcRootRecord ()Lshark/GcRoot$Finalizing;
+	public final fun readFloat ()F
+	public final fun readFloatArray (I)[F
+	public final fun readHeapDumpInfoRecord ()Lshark/HprofRecord$HeapDumpRecord$HeapDumpInfoRecord;
+	public final fun readId ()J
+	public final fun readIdArray (I)[J
+	public final fun readInstanceDumpRecord ()Lshark/HprofRecord$HeapDumpRecord$ObjectRecord$InstanceDumpRecord;
+	public final fun readInt ()I
+	public final fun readIntArray (I)[I
+	public final fun readInternedStringGcRootRecord ()Lshark/GcRoot$InternedString;
+	public final fun readJavaFrameGcRootRecord ()Lshark/GcRoot$JavaFrame;
+	public final fun readJniGlobalGcRootRecord ()Lshark/GcRoot$JniGlobal;
+	public final fun readJniLocalGcRootRecord ()Lshark/GcRoot$JniLocal;
+	public final fun readJniMonitorGcRootRecord ()Lshark/GcRoot$JniMonitor;
+	public final fun readLoadClassRecord ()Lshark/HprofRecord$LoadClassRecord;
+	public final fun readLong ()J
+	public final fun readLongArray (I)[J
+	public final fun readMonitorUsedGcRootRecord ()Lshark/GcRoot$MonitorUsed;
+	public final fun readNativeStackGcRootRecord ()Lshark/GcRoot$NativeStack;
+	public final fun readObjectArrayDumpRecord ()Lshark/HprofRecord$HeapDumpRecord$ObjectRecord$ObjectArrayDumpRecord;
+	public final fun readPrimitiveArrayDumpRecord ()Lshark/HprofRecord$HeapDumpRecord$ObjectRecord$PrimitiveArrayDumpRecord;
+	public final fun readReferenceCleanupGcRootRecord ()Lshark/GcRoot$ReferenceCleanup;
+	public final fun readShort ()S
+	public final fun readShortArray (I)[S
+	public final fun readStackFrameRecord ()Lshark/HprofRecord$StackFrameRecord;
+	public final fun readStackTraceRecord ()Lshark/HprofRecord$StackTraceRecord;
+	public final fun readStickyClassGcRootRecord ()Lshark/GcRoot$StickyClass;
+	public final fun readString (ILjava/nio/charset/Charset;)Ljava/lang/String;
+	public final fun readStringRecord (J)Lshark/HprofRecord$StringRecord;
+	public final fun readThreadBlockGcRootRecord ()Lshark/GcRoot$ThreadBlock;
+	public final fun readThreadObjectGcRootRecord ()Lshark/GcRoot$ThreadObject;
+	public final fun readUnknownGcRootRecord ()Lshark/GcRoot$Unknown;
+	public final fun readUnreachableGcRootRecord ()Lshark/GcRoot$Unreachable;
+	public final fun readUnsignedByte ()I
+	public final fun readUnsignedInt ()J
+	public final fun readUnsignedShort ()I
+	public final fun readUtf8 (J)Ljava/lang/String;
+	public final fun readValue (I)Lshark/ValueHolder;
+	public final fun readVmInternalGcRootRecord ()Lshark/GcRoot$VmInternal;
+	public final fun sizeOf (I)I
+	public final fun skip (I)V
+	public final fun skip (J)V
+	public final fun skipClassDumpConstantPool ()V
+	public final fun skipClassDumpFields ()V
+	public final fun skipClassDumpHeader ()V
+	public final fun skipClassDumpRecord ()V
+	public final fun skipClassDumpStaticFields ()V
+	public final fun skipHeapDumpInfoRecord ()V
+	public final fun skipId ()V
+	public final fun skipInstanceDumpRecord ()V
+	public final fun skipObjectArrayDumpRecord ()V
+	public final fun skipPrimitiveArrayDumpRecord ()V
+}
+
+public final class shark/HprofRecordReader$Companion {
+}
+
+public final class shark/HprofRecordTag : java/lang/Enum {
+	public static final field ALLOC_SITES Lshark/HprofRecordTag;
+	public static final field CLASS_DUMP Lshark/HprofRecordTag;
+	public static final field CONTROL_SETTINGS Lshark/HprofRecordTag;
+	public static final field CPU_SAMPLES Lshark/HprofRecordTag;
+	public static final field Companion Lshark/HprofRecordTag$Companion;
+	public static final field END_THREAD Lshark/HprofRecordTag;
+	public static final field HEAP_DUMP Lshark/HprofRecordTag;
+	public static final field HEAP_DUMP_END Lshark/HprofRecordTag;
+	public static final field HEAP_DUMP_INFO Lshark/HprofRecordTag;
+	public static final field HEAP_DUMP_SEGMENT Lshark/HprofRecordTag;
+	public static final field HEAP_SUMMARY Lshark/HprofRecordTag;
+	public static final field INSTANCE_DUMP Lshark/HprofRecordTag;
+	public static final field LOAD_CLASS Lshark/HprofRecordTag;
+	public static final field OBJECT_ARRAY_DUMP Lshark/HprofRecordTag;
+	public static final field PRIMITIVE_ARRAY_DUMP Lshark/HprofRecordTag;
+	public static final field PRIMITIVE_ARRAY_NODATA Lshark/HprofRecordTag;
+	public static final field ROOT_DEBUGGER Lshark/HprofRecordTag;
+	public static final field ROOT_FINALIZING Lshark/HprofRecordTag;
+	public static final field ROOT_INTERNED_STRING Lshark/HprofRecordTag;
+	public static final field ROOT_JAVA_FRAME Lshark/HprofRecordTag;
+	public static final field ROOT_JNI_GLOBAL Lshark/HprofRecordTag;
+	public static final field ROOT_JNI_LOCAL Lshark/HprofRecordTag;
+	public static final field ROOT_JNI_MONITOR Lshark/HprofRecordTag;
+	public static final field ROOT_MONITOR_USED Lshark/HprofRecordTag;
+	public static final field ROOT_NATIVE_STACK Lshark/HprofRecordTag;
+	public static final field ROOT_REFERENCE_CLEANUP Lshark/HprofRecordTag;
+	public static final field ROOT_STICKY_CLASS Lshark/HprofRecordTag;
+	public static final field ROOT_THREAD_BLOCK Lshark/HprofRecordTag;
+	public static final field ROOT_THREAD_OBJECT Lshark/HprofRecordTag;
+	public static final field ROOT_UNKNOWN Lshark/HprofRecordTag;
+	public static final field ROOT_UNREACHABLE Lshark/HprofRecordTag;
+	public static final field ROOT_VM_INTERNAL Lshark/HprofRecordTag;
+	public static final field STACK_FRAME Lshark/HprofRecordTag;
+	public static final field STACK_TRACE Lshark/HprofRecordTag;
+	public static final field START_THREAD Lshark/HprofRecordTag;
+	public static final field STRING_IN_UTF8 Lshark/HprofRecordTag;
+	public static final field UNLOAD_CLASS Lshark/HprofRecordTag;
+	public final fun getTag ()I
+	public static fun valueOf (Ljava/lang/String;)Lshark/HprofRecordTag;
+	public static fun values ()[Lshark/HprofRecordTag;
+}
+
+public final class shark/HprofRecordTag$Companion {
+	public final fun getRootTags ()Ljava/util/EnumSet;
+}
+
+public final class shark/HprofVersion : java/lang/Enum {
+	public static final field ANDROID Lshark/HprofVersion;
+	public static final field JDK1_2_BETA3 Lshark/HprofVersion;
+	public static final field JDK1_2_BETA4 Lshark/HprofVersion;
+	public static final field JDK_6 Lshark/HprofVersion;
+	public final fun getVersionString ()Ljava/lang/String;
+	public static fun valueOf (Ljava/lang/String;)Lshark/HprofVersion;
+	public static fun values ()[Lshark/HprofVersion;
+}
+
+public final class shark/HprofWriter : java/io/Closeable {
+	public static final field Companion Lshark/HprofWriter$Companion;
+	public synthetic fun <init> (Lokio/BufferedSink;Lshark/HprofHeader;Lkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public fun close ()V
+	public final fun getHprofHeader ()Lshark/HprofHeader;
+	public final fun getHprofVersion ()Lshark/Hprof$HprofVersion;
+	public final fun getIdentifierByteSize ()I
+	public final fun valuesToBytes (Ljava/util/List;)[B
+	public final fun write (Lshark/HprofRecord;)V
+}
+
+public final class shark/HprofWriter$Companion {
+	public final fun open (Ljava/io/File;ILshark/Hprof$HprofVersion;)Lshark/HprofWriter;
+	public static synthetic fun open$default (Lshark/HprofWriter$Companion;Ljava/io/File;ILshark/Hprof$HprofVersion;ILjava/lang/Object;)Lshark/HprofWriter;
+	public final fun openWriterFor (Ljava/io/File;Lshark/HprofHeader;)Lshark/HprofWriter;
+	public final fun openWriterFor (Lokio/BufferedSink;Lshark/HprofHeader;)Lshark/HprofWriter;
+	public static synthetic fun openWriterFor$default (Lshark/HprofWriter$Companion;Ljava/io/File;Lshark/HprofHeader;ILjava/lang/Object;)Lshark/HprofWriter;
+	public static synthetic fun openWriterFor$default (Lshark/HprofWriter$Companion;Lokio/BufferedSink;Lshark/HprofHeader;ILjava/lang/Object;)Lshark/HprofWriter;
+}
+
+public abstract interface class shark/OnHprofRecordListener {
+	public static final field Companion Lshark/OnHprofRecordListener$Companion;
+	public abstract fun onHprofRecord (JLshark/HprofRecord;)V
+}
+
+public final class shark/OnHprofRecordListener$Companion {
+	public final fun invoke (Lkotlin/jvm/functions/Function2;)Lshark/OnHprofRecordListener;
+}
+
+public abstract interface class shark/OnHprofRecordTagListener {
+	public static final field Companion Lshark/OnHprofRecordTagListener$Companion;
+	public abstract fun onHprofRecord (Lshark/HprofRecordTag;JLshark/HprofRecordReader;)V
+}
+
+public final class shark/OnHprofRecordTagListener$Companion {
+	public final fun invoke (Lkotlin/jvm/functions/Function3;)Lshark/OnHprofRecordTagListener;
+}
+
+public final class shark/PrimitiveType : java/lang/Enum {
+	public static final field BOOLEAN Lshark/PrimitiveType;
+	public static final field BYTE Lshark/PrimitiveType;
+	public static final field CHAR Lshark/PrimitiveType;
+	public static final field Companion Lshark/PrimitiveType$Companion;
+	public static final field DOUBLE Lshark/PrimitiveType;
+	public static final field FLOAT Lshark/PrimitiveType;
+	public static final field INT Lshark/PrimitiveType;
+	public static final field LONG Lshark/PrimitiveType;
+	public static final field REFERENCE_HPROF_TYPE I
+	public static final field SHORT Lshark/PrimitiveType;
+	public final fun getByteSize ()I
+	public final fun getHprofType ()I
+	public static fun valueOf (Ljava/lang/String;)Lshark/PrimitiveType;
+	public static fun values ()[Lshark/PrimitiveType;
+}
+
+public final class shark/PrimitiveType$Companion {
+	public final fun getByteSizeByHprofType ()Ljava/util/Map;
+	public final fun getPrimitiveTypeByHprofType ()Ljava/util/Map;
+}
+
+public final class shark/ProguardMapping {
+	public fun <init> ()V
+	public final fun addMapping (Ljava/lang/String;Ljava/lang/String;)V
+	public final fun deobfuscateClassName (Ljava/lang/String;)Ljava/lang/String;
+	public final fun deobfuscateFieldName (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
+}
+
+public final class shark/ProguardMappingReader {
+	public static final field Companion Lshark/ProguardMappingReader$Companion;
+	public fun <init> (Ljava/io/InputStream;)V
+	public final fun readProguardMapping ()Lshark/ProguardMapping;
+}
+
+public final class shark/ProguardMappingReader$Companion {
+}
+
+public final class shark/RandomAccessHprofReader : java/io/Closeable {
+	public static final field Companion Lshark/RandomAccessHprofReader$Companion;
+	public synthetic fun <init> (Lshark/RandomAccessSource;Lshark/HprofHeader;Lkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public fun close ()V
+	public final fun readRecord (JJLkotlin/jvm/functions/Function1;)Ljava/lang/Object;
+}
+
+public final class shark/RandomAccessHprofReader$Companion {
+	public final fun openReaderFor (Ljava/io/File;Lshark/HprofHeader;)Lshark/RandomAccessHprofReader;
+	public final fun openReaderFor (Lshark/RandomAccessSourceProvider;Lshark/HprofHeader;)Lshark/RandomAccessHprofReader;
+	public static synthetic fun openReaderFor$default (Lshark/RandomAccessHprofReader$Companion;Ljava/io/File;Lshark/HprofHeader;ILjava/lang/Object;)Lshark/RandomAccessHprofReader;
+	public static synthetic fun openReaderFor$default (Lshark/RandomAccessHprofReader$Companion;Lshark/RandomAccessSourceProvider;Lshark/HprofHeader;ILjava/lang/Object;)Lshark/RandomAccessHprofReader;
+}
+
+public abstract interface class shark/RandomAccessSource : java/io/Closeable {
+	public abstract fun asStreamingSource ()Lokio/BufferedSource;
+	public abstract fun read (Lokio/Buffer;JJ)J
+}
+
+public final class shark/RandomAccessSource$DefaultImpls {
+	public static fun asStreamingSource (Lshark/RandomAccessSource;)Lokio/BufferedSource;
+}
+
+public abstract interface class shark/RandomAccessSourceProvider {
+	public abstract fun openRandomAccessSource ()Lshark/RandomAccessSource;
+}
+
+public final class shark/StreamingHprofReader {
+	public static final field Companion Lshark/StreamingHprofReader$Companion;
+	public synthetic fun <init> (Lshark/StreamingSourceProvider;Lshark/HprofHeader;Lkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun readRecords (Ljava/util/Set;Lshark/OnHprofRecordTagListener;)J
+}
+
+public final class shark/StreamingHprofReader$Companion {
+	public final fun readerFor (Ljava/io/File;Lshark/HprofHeader;)Lshark/StreamingHprofReader;
+	public final fun readerFor (Lshark/StreamingSourceProvider;Lshark/HprofHeader;)Lshark/StreamingHprofReader;
+	public static synthetic fun readerFor$default (Lshark/StreamingHprofReader$Companion;Ljava/io/File;Lshark/HprofHeader;ILjava/lang/Object;)Lshark/StreamingHprofReader;
+	public static synthetic fun readerFor$default (Lshark/StreamingHprofReader$Companion;Lshark/StreamingSourceProvider;Lshark/HprofHeader;ILjava/lang/Object;)Lshark/StreamingHprofReader;
+}
+
+public final class shark/StreamingRecordReaderAdapter {
+	public static final field Companion Lshark/StreamingRecordReaderAdapter$Companion;
+	public fun <init> (Lshark/StreamingHprofReader;)V
+	public final fun readRecords (Ljava/util/Set;Lshark/OnHprofRecordListener;)J
+}
+
+public final class shark/StreamingRecordReaderAdapter$Companion {
+	public final fun asHprofTags (Ljava/util/Set;)Ljava/util/EnumSet;
+	public final fun asStreamingRecordReader (Lshark/StreamingHprofReader;)Lshark/StreamingRecordReaderAdapter;
+}
+
+public abstract interface class shark/StreamingSourceProvider {
+	public abstract fun openStreamingSource ()Lokio/BufferedSource;
+}
+
+public final class shark/ThrowingCancelableFileSourceProvider : shark/DualSourceProvider {
+	public fun <init> (Ljava/io/File;Ljava/lang/Runnable;)V
+	public fun openRandomAccessSource ()Lshark/RandomAccessSource;
+	public fun openStreamingSource ()Lokio/BufferedSource;
+}
+
+public abstract class shark/ValueHolder {
+	public static final field Companion Lshark/ValueHolder$Companion;
+	public static final field NULL_REFERENCE J
+}
+
+public final class shark/ValueHolder$BooleanHolder : shark/ValueHolder {
+	public fun <init> (Z)V
+	public final fun component1 ()Z
+	public final fun copy (Z)Lshark/ValueHolder$BooleanHolder;
+	public static synthetic fun copy$default (Lshark/ValueHolder$BooleanHolder;ZILjava/lang/Object;)Lshark/ValueHolder$BooleanHolder;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getValue ()Z
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/ValueHolder$ByteHolder : shark/ValueHolder {
+	public fun <init> (B)V
+	public final fun component1 ()B
+	public final fun copy (B)Lshark/ValueHolder$ByteHolder;
+	public static synthetic fun copy$default (Lshark/ValueHolder$ByteHolder;BILjava/lang/Object;)Lshark/ValueHolder$ByteHolder;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getValue ()B
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/ValueHolder$CharHolder : shark/ValueHolder {
+	public fun <init> (C)V
+	public final fun component1 ()C
+	public final fun copy (C)Lshark/ValueHolder$CharHolder;
+	public static synthetic fun copy$default (Lshark/ValueHolder$CharHolder;CILjava/lang/Object;)Lshark/ValueHolder$CharHolder;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getValue ()C
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/ValueHolder$Companion {
+}
+
+public final class shark/ValueHolder$DoubleHolder : shark/ValueHolder {
+	public fun <init> (D)V
+	public final fun component1 ()D
+	public final fun copy (D)Lshark/ValueHolder$DoubleHolder;
+	public static synthetic fun copy$default (Lshark/ValueHolder$DoubleHolder;DILjava/lang/Object;)Lshark/ValueHolder$DoubleHolder;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getValue ()D
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/ValueHolder$FloatHolder : shark/ValueHolder {
+	public fun <init> (F)V
+	public final fun component1 ()F
+	public final fun copy (F)Lshark/ValueHolder$FloatHolder;
+	public static synthetic fun copy$default (Lshark/ValueHolder$FloatHolder;FILjava/lang/Object;)Lshark/ValueHolder$FloatHolder;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getValue ()F
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/ValueHolder$IntHolder : shark/ValueHolder {
+	public fun <init> (I)V
+	public final fun component1 ()I
+	public final fun copy (I)Lshark/ValueHolder$IntHolder;
+	public static synthetic fun copy$default (Lshark/ValueHolder$IntHolder;IILjava/lang/Object;)Lshark/ValueHolder$IntHolder;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getValue ()I
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/ValueHolder$LongHolder : shark/ValueHolder {
+	public fun <init> (J)V
+	public final fun component1 ()J
+	public final fun copy (J)Lshark/ValueHolder$LongHolder;
+	public static synthetic fun copy$default (Lshark/ValueHolder$LongHolder;JILjava/lang/Object;)Lshark/ValueHolder$LongHolder;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getValue ()J
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/ValueHolder$ReferenceHolder : shark/ValueHolder {
+	public fun <init> (J)V
+	public final fun component1 ()J
+	public final fun copy (J)Lshark/ValueHolder$ReferenceHolder;
+	public static synthetic fun copy$default (Lshark/ValueHolder$ReferenceHolder;JILjava/lang/Object;)Lshark/ValueHolder$ReferenceHolder;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getValue ()J
+	public fun hashCode ()I
+	public final fun isNull ()Z
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/ValueHolder$ShortHolder : shark/ValueHolder {
+	public fun <init> (S)V
+	public final fun component1 ()S
+	public final fun copy (S)Lshark/ValueHolder$ShortHolder;
+	public static synthetic fun copy$default (Lshark/ValueHolder$ShortHolder;SILjava/lang/Object;)Lshark/ValueHolder$ShortHolder;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getValue ()S
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
diff --git a/shark-hprof/build.gradle b/shark-hprof/build.gradle
new file mode 100644
index 00000000..98a517f0
--- /dev/null
+++ b/shark-hprof/build.gradle
@@ -0,0 +1,25 @@
+plugins {
+  id("org.jetbrains.kotlin.jvm")
+  id("com.vanniktech.maven.publish")
+}
+
+sourceCompatibility = JavaVersion.VERSION_1_8
+targetCompatibility = JavaVersion.VERSION_1_8
+
+dependencies {
+  api projects.sharkLog
+
+  implementation libs.kotlin.stdlib
+  // compileOnly ensures this dependency is not exposed through this artifact's pom.xml in Maven Central.
+  // Okio is a required dependency, but we're making it required on the "shark" artifact which is the main artifact that
+  // should generally be used. The shark artifact depends on Okio 2.x (ensure compatibility with modern Okio). Depending on 1.x here
+  // enables us to ensure binary compatibility with Okio 1.x and allow us to use the deprecated (error level) Okio APIs to keep that
+  // compatibility.
+  // See https://github.com/square/leakcanary/issues/1624
+  compileOnly libs.okio1
+  testImplementation libs.okio1
+
+  testImplementation libs.assertjCore
+  testImplementation libs.junit
+  testImplementation projects.sharkTest
+}
diff --git a/shark-hprof/gradle.properties b/shark-hprof/gradle.properties
new file mode 100644
index 00000000..585cfc8d
--- /dev/null
+++ b/shark-hprof/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark-hprof
+POM_NAME=Shark Hprof
+POM_PACKAGING=jar
diff --git a/shark-hprof/src/main/java/shark/ByteArraySourceProvider.kt b/shark-hprof/src/main/java/shark/ByteArraySourceProvider.kt
new file mode 100644
index 00000000..0feab4dd
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/ByteArraySourceProvider.kt
@@ -0,0 +1,33 @@
+package shark
+
+import java.io.IOException
+import okio.Buffer
+import okio.BufferedSource
+
+class ByteArraySourceProvider(private val byteArray: ByteArray) : DualSourceProvider {
+  override fun openStreamingSource(): BufferedSource = Buffer().apply { write(byteArray) }
+
+  override fun openRandomAccessSource(): RandomAccessSource {
+    return object : RandomAccessSource {
+
+      var closed = false
+
+      override fun read(
+        sink: Buffer,
+        position: Long,
+        byteCount: Long
+      ): Long {
+        if (closed) {
+          throw IOException("Source closed")
+        }
+        val maxByteCount = byteCount.coerceAtMost(byteArray.size - position)
+        sink.write(byteArray, position.toInt(), maxByteCount.toInt())
+        return maxByteCount
+      }
+
+      override fun close() {
+        closed = true
+      }
+    }
+  }
+}
diff --git a/shark-hprof/src/main/java/shark/ConstantMemoryMetricsDualSourceProvider.kt b/shark-hprof/src/main/java/shark/ConstantMemoryMetricsDualSourceProvider.kt
new file mode 100644
index 00000000..a71803ac
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/ConstantMemoryMetricsDualSourceProvider.kt
@@ -0,0 +1,66 @@
+package shark
+
+import okio.Buffer
+import kotlin.math.absoluteValue
+
+/**
+ * Captures IO read metrics without using much memory.
+ */
+class ConstantMemoryMetricsDualSourceProvider(
+  private val realSourceProvider: DualSourceProvider
+) : DualSourceProvider {
+
+  var randomAccessByteReads = 0L
+    internal set
+
+  var randomAccessReadCount = 0L
+    internal set
+
+  var randomAccessByteTravel = 0L
+    internal set
+
+  private var lastRandomAccessPosition = -1L
+  private var minPosition = -1L
+  private var maxPosition = -1L
+
+  private fun updateRandomAccessStatsOnRead(
+    position: Long,
+    bytesRead: Long
+  ) {
+    randomAccessByteReads += bytesRead
+    randomAccessReadCount++
+    if (lastRandomAccessPosition != -1L) {
+      randomAccessByteTravel += (position - lastRandomAccessPosition).absoluteValue
+      minPosition = minPosition.coerceAtMost(position)
+      maxPosition = maxPosition.coerceAtLeast(position)
+    } else {
+      minPosition = position
+      maxPosition = position
+    }
+
+
+    lastRandomAccessPosition = position
+  }
+
+  val byteTravelRange
+    get() = (maxPosition - minPosition)
+
+  override fun openStreamingSource() = realSourceProvider.openStreamingSource()
+
+  override fun openRandomAccessSource(): RandomAccessSource {
+    val randomAccessSource = realSourceProvider.openRandomAccessSource()
+    return object : RandomAccessSource {
+      override fun read(
+        sink: Buffer,
+        position: Long,
+        byteCount: Long
+      ): Long {
+        val bytesRead = randomAccessSource.read(sink, position, byteCount)
+        updateRandomAccessStatsOnRead(position, bytesRead)
+        return bytesRead
+      }
+
+      override fun close() = randomAccessSource.close()
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/DualSourceProvider.kt b/shark-hprof/src/main/java/shark/DualSourceProvider.kt
new file mode 100644
index 00000000..8ac2572c
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/DualSourceProvider.kt
@@ -0,0 +1,6 @@
+package shark
+
+/**
+ * Both a [StreamingSourceProvider] and a [RandomAccessSourceProvider]
+ */
+interface DualSourceProvider : StreamingSourceProvider, RandomAccessSourceProvider
diff --git a/shark-hprof/src/main/java/shark/FileSourceProvider.kt b/shark-hprof/src/main/java/shark/FileSourceProvider.kt
new file mode 100644
index 00000000..f558c202
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/FileSourceProvider.kt
@@ -0,0 +1,54 @@
+package shark
+
+import java.io.File
+import java.io.RandomAccessFile
+import kotlin.math.min
+import okio.Buffer
+import okio.BufferedSource
+import okio.Okio
+
+class FileSourceProvider(private val file: File) : DualSourceProvider {
+  override fun openStreamingSource(): BufferedSource = Okio.buffer(Okio.source(file.inputStream()))
+
+  override fun openRandomAccessSource(): RandomAccessSource {
+
+    val randomAccessFile = RandomAccessFile(file, "r")
+
+    val arrayBuffer = ByteArray(500_000)
+
+    return object : RandomAccessSource {
+      override fun read(
+        sink: Buffer,
+        position: Long,
+        byteCount: Long
+      ): Long {
+        val byteCountInt = byteCount.toInt()
+        randomAccessFile.seek(position)
+        var totalBytesRead = 0
+        val maxRead = arrayBuffer.size
+        while (totalBytesRead < byteCount) {
+          val toRead = min(byteCountInt - totalBytesRead, maxRead)
+          val bytesRead = randomAccessFile.read(arrayBuffer, 0, toRead)
+          if (bytesRead == -1) {
+            check(totalBytesRead != 0) {
+              "Did not expect to reach end of file after reading 0 bytes"
+            }
+            break
+          }
+          sink.write(arrayBuffer, 0, bytesRead)
+          totalBytesRead += bytesRead
+        }
+        return totalBytesRead.toLong()
+      }
+
+      override fun close() {
+        try {
+          randomAccessFile.close()
+        } catch (ignored: Throwable) {
+          SharkLog.d(ignored) { "Failed to close file, ignoring" }
+        }
+      }
+    }
+  }
+}
+
diff --git a/shark-hprof/src/main/java/shark/GcRoot.kt b/shark-hprof/src/main/java/shark/GcRoot.kt
new file mode 100644
index 00000000..87db239c
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/GcRoot.kt
@@ -0,0 +1,131 @@
+package shark
+
+/**
+ * A GcRoot as identified by [HprofRecord.HeapDumpRecord.GcRootRecord] in the heap dump.
+ */
+sealed class GcRoot {
+
+  /**
+   * The object id of the object that this gc root references.
+   */
+  abstract val id: Long
+
+  /**
+   * An unknown gc root.
+   */
+  class Unknown(override val id: Long) : GcRoot()
+
+  /**
+   * A global variable in native code.
+   */
+  class JniGlobal(
+    override val id: Long,
+    val jniGlobalRefId: Long
+  ) : GcRoot()
+
+  /**
+   * A local variable in native code.
+   */
+  class JniLocal(
+    override val id: Long,
+    /** Corresponds to [ThreadObject.threadSerialNumber] */
+    val threadSerialNumber: Int,
+    /**
+     * frame number in stack trace (-1 for empty)
+     */
+    val frameNumber: Int
+  ) : GcRoot()
+
+  /**
+   * A java local variable
+   */
+  class JavaFrame(
+    override val id: Long,
+    /** Corresponds to [ThreadObject.threadSerialNumber] */
+    val threadSerialNumber: Int,
+    /**
+     * frame number in stack trace (-1 for empty)
+     */
+    val frameNumber: Int
+  ) : GcRoot()
+
+  /**
+   * Input or output parameters in native code
+   */
+  class NativeStack(
+    override val id: Long,
+    /**
+     * Corresponds to [ThreadObject.threadSerialNumber]
+     * Note: the corresponding thread is sometimes not found, see:
+     * https://issuetracker.google.com/issues/122713143
+     */
+    val threadSerialNumber: Int
+  ) : GcRoot()
+
+  /**
+   * A system class
+   */
+  class StickyClass(override val id: Long) : GcRoot()
+
+  class ThreadBlock(
+    override val id: Long,
+    /** Corresponds to [ThreadObject.threadSerialNumber] */
+    val threadSerialNumber: Int
+  ) : GcRoot()
+
+  /**
+   * Everything that called the wait() or notify() methods, or
+   * that is synchronized.
+   */
+  class MonitorUsed(override val id: Long) : GcRoot()
+
+  /**
+   * A thread.
+   *
+   * Added at https://android.googlesource.com/platform/tools/base/+/c0f0d528c155cab32e372dac77370569a386245c
+   */
+  class ThreadObject(
+    override val id: Long,
+    val threadSerialNumber: Int,
+    val stackTraceSerialNumber: Int
+  ) : GcRoot()
+
+  /**
+   * It's unclear what this is, documentation welcome.
+   */
+  class ReferenceCleanup(override val id: Long) : GcRoot()
+
+  /**
+   * It's unclear what this is, documentation welcome.
+   */
+  class VmInternal(override val id: Long) : GcRoot()
+
+  /**
+   * It's unclear what this is, documentation welcome.
+   */
+  class JniMonitor(
+    override val id: Long,
+    val stackTraceSerialNumber: Int,
+    val stackDepth: Int
+  ) : GcRoot()
+
+  /**
+   * An interned string, see [java.lang.String.intern].
+   */
+  class InternedString(override val id: Long) : GcRoot()
+
+  /**
+   * An object that is in a queue, waiting for a finalizer to run.
+   */
+  class Finalizing(override val id: Long) : GcRoot()
+
+  /**
+   * An object held by a connected debugger
+   */
+  class Debugger(override val id: Long) : GcRoot()
+
+  /**
+   * An object that is unreachable from any other root, but not a root itself.
+   */
+  class Unreachable(override val id: Long) : GcRoot()
+}
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/Hprof.kt b/shark-hprof/src/main/java/shark/Hprof.kt
new file mode 100644
index 00000000..8263b730
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/Hprof.kt
@@ -0,0 +1,59 @@
+package shark
+
+import java.io.Closeable
+import java.io.File
+
+/**
+ * Hprof is deprecated, and we offer partial backward compatibility. Any code that was
+ * previously using HprofReader directly now has to call [StreamingHprofReader.readerFor] or
+ * [HprofRandomAcccessReader.readerFor]
+ */
+@Deprecated("Replaced by HprofStreamingReader.readerFor or HprofRandomAccessReader.openReaderFor")
+class Hprof private constructor(
+  val file: File,
+  val header: HprofHeader
+) : Closeable {
+
+  val reader: HprofReader = HprofReader(this)
+
+  val heapDumpTimestamp: Long
+    get() = header.heapDumpTimestamp
+
+  val hprofVersion: HprofVersion
+    get() = HprofVersion.valueOf(header.version.name)
+
+  val fileLength: Long
+    get() = file.length()
+
+  private val closeables = mutableListOf<Closeable>()
+
+  /**
+   * Maintains backward compatibility because [Hprof.open] returns a closeable. This allows
+   * consuming libraries to attach a closeable that will be closed whe [Hprof] is closed.
+   */
+  fun attachClosable(closeable: Closeable) {
+    closeables += closeable
+  }
+
+  override fun close() {
+    closeables.forEach { it.close() }
+  }
+
+  @Deprecated(message = "Moved to top level class", replaceWith = ReplaceWith("shark.HprofVersion"))
+  enum class HprofVersion {
+    JDK1_2_BETA3,
+    JDK1_2_BETA4,
+    JDK_6,
+    ANDROID;
+
+    val versionString: String
+      get() = shark.HprofVersion.valueOf(name).versionString
+  }
+
+  companion object {
+    @Deprecated(
+      message = "Replaced by HprofStreamingReader.readerFor or HprofRandomAccessReader.openReaderFor"
+    )
+    fun open(hprofFile: File): Hprof = Hprof(hprofFile, HprofHeader.parseHeaderOf(hprofFile))
+  }
+}
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/HprofDeobfuscator.kt b/shark-hprof/src/main/java/shark/HprofDeobfuscator.kt
new file mode 100644
index 00000000..e87e4772
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/HprofDeobfuscator.kt
@@ -0,0 +1,208 @@
+package shark
+
+import shark.HprofHeader.Companion.parseHeaderOf
+import shark.HprofRecord.HeapDumpEndRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StackFrameRecord
+import shark.HprofRecord.StringRecord
+import shark.StreamingRecordReaderAdapter.Companion.asStreamingRecordReader
+import java.io.File
+
+/**
+ * Converts a Hprof file to another file with deobfuscated class and field names.
+ */
+class HprofDeobfuscator {
+
+  /**
+   * @see HprofDeobfuscator
+   */
+  fun deobfuscate(
+    proguardMapping: ProguardMapping,
+    inputHprofFile: File,
+    /**
+     * Optional output file. Defaults to a file in the same directory as [inputHprofFile], with
+     * the same name and "-deobfuscated" prepended before the ".hprof" extension. If the file extension
+     * is not ".hprof", then "-deobfuscated" is added at the end of the file.
+     */
+    outputHprofFile: File = File(
+      inputHprofFile.parent, inputHprofFile.name.replace(
+      ".hprof", "-deobfuscated.hprof"
+    ).let { if (it != inputHprofFile.name) it else inputHprofFile.name + "-deobfuscated" })
+  ): File {
+    val (hprofStringCache, classNames, maxId) = readHprofRecords(inputHprofFile)
+
+    return writeHprofRecords(
+      inputHprofFile,
+      outputHprofFile,
+      proguardMapping,
+      hprofStringCache,
+      classNames,
+      maxId + 1
+    )
+  }
+
+  /**
+   * Reads StringRecords and LoadClassRecord from an Hprof file and tracks maximum HprofRecord id
+   * value.
+   *
+   * @return a Triple of: hprofStringCache map, classNames map and maxId value
+   */
+  private fun readHprofRecords(
+    inputHprofFile: File
+  ): Triple<Map<Long, String>, Map<Long, Long>, Long> {
+    val hprofStringCache = mutableMapOf<Long, String>()
+    val classNames = mutableMapOf<Long, Long>()
+
+    var maxId: Long = 0
+
+    val reader = StreamingHprofReader.readerFor(inputHprofFile).asStreamingRecordReader()
+    reader.readRecords(setOf(HprofRecord::class)
+    ) { _, record ->
+      when (record) {
+        is StringRecord -> {
+          maxId = maxId.coerceAtLeast(record.id)
+          hprofStringCache[record.id] = record.string
+        }
+        is LoadClassRecord -> {
+          maxId = maxId.coerceAtLeast(record.id)
+          classNames[record.id] = record.classNameStringId
+        }
+        is StackFrameRecord -> maxId = maxId.coerceAtLeast(record.id)
+        is ObjectRecord -> {
+          maxId = when (record) {
+            is ClassDumpRecord -> maxId.coerceAtLeast(record.id)
+            is InstanceDumpRecord -> maxId.coerceAtLeast(record.id)
+            is ObjectArrayDumpRecord -> maxId.coerceAtLeast(record.id)
+            is PrimitiveArrayDumpRecord -> maxId.coerceAtLeast(record.id)
+          }
+        }
+      }
+    }
+    return Triple(hprofStringCache, classNames, maxId)
+  }
+
+  @Suppress("LongParameterList")
+  private fun writeHprofRecords(
+    inputHprofFile: File,
+    outputHprofFile: File,
+    proguardMapping: ProguardMapping,
+    hprofStringCache: Map<Long, String>,
+    classNames: Map<Long, Long>,
+    firstId: Long
+  ): File {
+    var id = firstId
+
+    val hprofHeader = parseHeaderOf(inputHprofFile)
+    val reader =
+      StreamingHprofReader.readerFor(inputHprofFile, hprofHeader).asStreamingRecordReader()
+    HprofWriter.openWriterFor(
+      outputHprofFile,
+      hprofHeader = hprofHeader
+    ).use { writer ->
+      reader.readRecords(setOf(HprofRecord::class),
+        OnHprofRecordListener { _,
+          record ->
+          // HprofWriter automatically emits HeapDumpEndRecord, because it flushes
+          // all continuous heap dump sub records as one heap dump record.
+          if (record is HeapDumpEndRecord) {
+            return@OnHprofRecordListener
+          }
+
+          when (record) {
+            is StringRecord -> {
+              writer.write(
+                createDeobfuscatedStringRecord(record, proguardMapping, hprofStringCache)
+              )
+            }
+            is ClassDumpRecord -> {
+              val (recordsToWrite, maxId) = createDeobfuscatedClassDumpRecord(
+                record, proguardMapping, hprofStringCache, classNames, id
+              )
+              id = maxId
+              recordsToWrite.forEach {
+                writer.write(it)
+              }
+            }
+            else -> writer.write(record)
+          }
+        })
+    }
+
+    return outputHprofFile
+  }
+
+  private fun createDeobfuscatedStringRecord(
+    record: StringRecord,
+    proguardMapping: ProguardMapping,
+    hprofStringCache: Map<Long, String>
+  ): StringRecord {
+    val obfuscatedName = hprofStringCache[record.id]!!
+    return StringRecord(
+      record.id, proguardMapping.deobfuscateClassName(obfuscatedName)
+    )
+  }
+
+  /**
+   * Deobfuscated ClassDumpRecord's field names. Different classes can have fields with the same
+   * names. We need to generate new StringRecords in such cases.
+   *
+   * @return a Pair of: list of HprofRecords to write and new maxId value
+   */
+  private fun createDeobfuscatedClassDumpRecord(
+    record: ClassDumpRecord,
+    proguardMapping: ProguardMapping,
+    hprofStringCache: Map<Long, String>,
+    classNames: Map<Long, Long>,
+    maxId: Long
+  ): Pair<List<HprofRecord>, Long> {
+    val recordsToWrite = mutableListOf<HprofRecord>()
+
+    var id = maxId
+
+    val newFields = record.fields.map { field ->
+      val className = hprofStringCache[classNames[record.id]]!!
+      val fieldName = hprofStringCache[field.nameStringId]!!
+      val deobfuscatedName =
+        proguardMapping.deobfuscateFieldName(className, fieldName)
+
+      val newStringRecord = StringRecord(id++, deobfuscatedName)
+      recordsToWrite.add(newStringRecord)
+
+      FieldRecord(newStringRecord.id, field.type)
+    }
+    val newStaticFields = record.staticFields.map { field ->
+      val className = hprofStringCache[classNames[record.id]]!!
+      val fieldName = hprofStringCache[field.nameStringId]!!
+      val deobfuscatedName =
+        proguardMapping.deobfuscateFieldName(className, fieldName)
+
+      val newStringRecord = StringRecord(id++, deobfuscatedName)
+      recordsToWrite.add(newStringRecord)
+
+      StaticFieldRecord(newStringRecord.id, field.type, field.value)
+    }
+
+    recordsToWrite.add(
+      ClassDumpRecord(
+        record.id,
+        record.stackTraceSerialNumber,
+        record.superclassId,
+        record.classLoaderId,
+        record.signersId,
+        record.protectionDomainId,
+        record.instanceSize,
+        newStaticFields,
+        newFields
+      )
+    )
+
+    return Pair(recordsToWrite, id)
+  }
+}
diff --git a/shark-hprof/src/main/java/shark/HprofHeader.kt b/shark-hprof/src/main/java/shark/HprofHeader.kt
new file mode 100644
index 00000000..56d531f8
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/HprofHeader.kt
@@ -0,0 +1,67 @@
+package shark
+
+import okio.BufferedSource
+import okio.Okio
+import java.io.File
+
+/**
+ * Represents the header metadata of a Hprof file.
+ */
+data class HprofHeader(
+  /** Unix timestamp at which the heap was dumped. */
+  val heapDumpTimestamp: Long = System.currentTimeMillis(),
+  /** Hprof version, which is tied to the runtime where the heap was dumped. */
+  val version: HprofVersion = HprofVersion.ANDROID,
+  /**
+   * Size of Hprof identifiers. Identifiers are used to represent UTF8 strings, objects,
+   * stack traces, etc. They can have the same size as host pointers or sizeof(void*), but are not
+   * required to be.
+   */
+  val identifierByteSize: Int = 4
+) {
+  /**
+   * How many bytes from the beginning of the file can we find the hprof records at.
+   * Version string, 0 delimiter (1 byte), identifier byte size int (4 bytes) ,timestamp long
+   * (8 bytes)
+   */
+  val recordsPosition: Int = version.versionString.toByteArray(Charsets.UTF_8).size + 1 + 4 + 8
+
+  companion object {
+    private val supportedVersions = HprofVersion.values().associateBy { it.versionString }
+
+    /**
+     * Reads the header of the provided [hprofFile] and returns it as a [HprofHeader]
+     */
+    fun parseHeaderOf(hprofFile: File): HprofHeader {
+      val fileLength = hprofFile.length()
+      if (fileLength == 0L) {
+        throw IllegalArgumentException("Hprof file is 0 byte length")
+      }
+      return Okio.buffer(Okio.source(hprofFile.inputStream())).use {
+        parseHeaderOf(it)
+      }
+    }
+
+    /**
+     * Reads the header of the provided [source] and returns it as a [HprofHeader].
+     * This does not close the [source].
+     */
+    fun parseHeaderOf(source: BufferedSource): HprofHeader {
+      require(!source.exhausted()) {
+        throw IllegalArgumentException("Source has no available bytes")
+      }
+      val endOfVersionString = source.indexOf(0)
+      val versionName = source.readUtf8(endOfVersionString)
+
+      val version = supportedVersions[versionName]
+      checkNotNull(version) {
+        "Unsupported Hprof version [$versionName] not in supported list ${supportedVersions.keys}"
+      }
+      // Skip the 0 at the end of the version string.
+      source.skip(1)
+      val identifierByteSize = source.readInt()
+      val heapDumpTimestamp = source.readLong()
+      return HprofHeader(heapDumpTimestamp, version, identifierByteSize)
+    }
+  }
+}
diff --git a/shark-hprof/src/main/java/shark/HprofPrimitiveArrayStripper.kt b/shark-hprof/src/main/java/shark/HprofPrimitiveArrayStripper.kt
new file mode 100644
index 00000000..1e0b6918
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/HprofPrimitiveArrayStripper.kt
@@ -0,0 +1,116 @@
+package shark
+
+import okio.BufferedSink
+import okio.Okio
+import shark.HprofRecord.HeapDumpEndRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.StreamingRecordReaderAdapter.Companion.asStreamingRecordReader
+import java.io.File
+
+/**
+ * Converts a Hprof file to another file with all primitive arrays replaced with arrays of zeroes,
+ * which can be useful to remove PII. Char arrays are handled slightly differently because 0 would
+ * be the null character so instead these become arrays of '?'.
+ */
+class HprofPrimitiveArrayStripper {
+
+  /**
+   * @see HprofPrimitiveArrayStripper
+   */
+  fun stripPrimitiveArrays(
+    inputHprofFile: File,
+    /**
+     * Optional output file. Defaults to a file in the same directory as [inputHprofFile], with
+     * the same name and "-stripped" prepended before the ".hprof" extension. If the file extension
+     * is not ".hprof", then "-stripped" is added at the end of the file.
+     */
+    outputHprofFile: File = File(
+      inputHprofFile.parent, inputHprofFile.name.replace(
+      ".hprof", "-stripped.hprof"
+    ).let { if (it != inputHprofFile.name) it else inputHprofFile.name + "-stripped" })
+  ): File {
+    stripPrimitiveArrays(
+      hprofSourceProvider = FileSourceProvider(inputHprofFile),
+      hprofSink = Okio.buffer(Okio.sink(outputHprofFile.outputStream()))
+    )
+    return outputHprofFile
+  }
+
+  /**
+   * @see HprofPrimitiveArrayStripper
+   */
+  fun stripPrimitiveArrays(
+    hprofSourceProvider: StreamingSourceProvider,
+    hprofSink: BufferedSink
+  ) {
+    val header = hprofSourceProvider.openStreamingSource().use { HprofHeader.parseHeaderOf(it) }
+    val reader =
+      StreamingHprofReader.readerFor(hprofSourceProvider, header).asStreamingRecordReader()
+    HprofWriter.openWriterFor(
+      hprofSink,
+      hprofHeader = header
+    )
+      .use { writer ->
+        reader.readRecords(setOf(HprofRecord::class),
+          OnHprofRecordListener { _,
+            record ->
+            // HprofWriter automatically emits HeapDumpEndRecord, because it flushes
+            // all continuous heap dump sub records as one heap dump record.
+            if (record is HeapDumpEndRecord) {
+              return@OnHprofRecordListener
+            }
+            writer.write(
+              when (record) {
+                is BooleanArrayDump -> BooleanArrayDump(
+                  record.id, record.stackTraceSerialNumber,
+                  BooleanArray(record.array.size)
+                )
+                is CharArrayDump -> CharArrayDump(
+                  record.id, record.stackTraceSerialNumber,
+                  CharArray(record.array.size) {
+                    '?'
+                  }
+                )
+                is FloatArrayDump -> FloatArrayDump(
+                  record.id, record.stackTraceSerialNumber,
+                  FloatArray(record.array.size)
+                )
+                is DoubleArrayDump -> DoubleArrayDump(
+                  record.id, record.stackTraceSerialNumber,
+                  DoubleArray(record.array.size)
+                )
+                is ByteArrayDump -> ByteArrayDump(
+                  record.id, record.stackTraceSerialNumber,
+                  ByteArray(record.array.size) {
+                    // Converts to '?' in UTF-8 for byte backed strings
+                    63
+                  }
+                )
+                is ShortArrayDump -> ShortArrayDump(
+                  record.id, record.stackTraceSerialNumber,
+                  ShortArray(record.array.size)
+                )
+                is IntArrayDump -> IntArrayDump(
+                  record.id, record.stackTraceSerialNumber,
+                  IntArray(record.array.size)
+                )
+                is LongArrayDump -> LongArrayDump(
+                  record.id, record.stackTraceSerialNumber,
+                  LongArray(record.array.size)
+                )
+                else -> {
+                  record
+                }
+              }
+            )
+          })
+      }
+  }
+}
diff --git a/shark-hprof/src/main/java/shark/HprofReader.kt b/shark-hprof/src/main/java/shark/HprofReader.kt
new file mode 100644
index 00000000..f32a0c1f
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/HprofReader.kt
@@ -0,0 +1,23 @@
+package shark
+
+import shark.StreamingRecordReaderAdapter.Companion.asStreamingRecordReader
+import kotlin.reflect.KClass
+
+@Deprecated("Replaced by HprofStreamingReader.readerFor or HprofRandomAccessReader.openReaderFor")
+class HprofReader internal constructor(
+  private val hprof: Hprof
+) {
+  val identifierByteSize: Int
+    get() = hprof.header.identifierByteSize
+
+  val startPosition: Long
+    get() = hprof.header.recordsPosition.toLong()
+
+  fun readHprofRecords(
+    recordTypes: Set<KClass<out HprofRecord>>,
+    listener: OnHprofRecordListener
+  ) {
+    val reader = StreamingHprofReader.readerFor(hprof.file, hprof.header).asStreamingRecordReader()
+    reader.readRecords(recordTypes, listener)
+  }
+}
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/HprofRecord.kt b/shark-hprof/src/main/java/shark/HprofRecord.kt
new file mode 100644
index 00000000..84ac4317
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/HprofRecord.kt
@@ -0,0 +1,177 @@
+package shark
+
+/**
+ * A Hprof record. These data structure map 1:1 with how records are written in hprof files.
+ */
+sealed class HprofRecord {
+  class StringRecord(
+    val id: Long,
+    val string: String
+  ) : HprofRecord()
+
+  class LoadClassRecord(
+    val classSerialNumber: Int,
+    val id: Long,
+    val stackTraceSerialNumber: Int,
+    val classNameStringId: Long
+  ) : HprofRecord()
+
+  /**
+   * Terminates a series of heap dump segments. Concatenation of heap dump segments equals a
+   * heap dump.
+   */
+  object HeapDumpEndRecord : HprofRecord()
+
+  class StackFrameRecord(
+    val id: Long,
+    val methodNameStringId: Long,
+    val methodSignatureStringId: Long,
+    val sourceFileNameStringId: Long,
+    val classSerialNumber: Int,
+    /**
+     * >0 line number
+     * 0 no line information available
+     * -1 unknown location
+     * -2 compiled method (Not implemented)
+     * -3 native method (Not implemented)
+     */
+    val lineNumber: Int
+  ) : HprofRecord()
+
+  class StackTraceRecord(
+    val stackTraceSerialNumber: Int,
+    val threadSerialNumber: Int,
+    val stackFrameIds: LongArray
+  ) : HprofRecord()
+
+  sealed class HeapDumpRecord : HprofRecord() {
+    class GcRootRecord(
+      val gcRoot: GcRoot
+    ) : HeapDumpRecord()
+
+    sealed class ObjectRecord : HeapDumpRecord() {
+      class ClassDumpRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val superclassId: Long,
+        val classLoaderId: Long,
+        val signersId: Long,
+        val protectionDomainId: Long,
+        val instanceSize: Int,
+        val staticFields: List<StaticFieldRecord>,
+        val fields: List<FieldRecord>
+      ) : ObjectRecord() {
+        data class StaticFieldRecord(
+          val nameStringId: Long,
+          val type: Int,
+          val value: ValueHolder
+        )
+
+        data class FieldRecord(
+          val nameStringId: Long,
+          val type: Int
+        )
+      }
+
+      class InstanceDumpRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val classId: Long,
+        /**
+         * Instance field values (this class, followed by super class, etc)
+         */
+        val fieldValues: ByteArray
+      ) : ObjectRecord()
+
+      class ObjectArrayDumpRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val arrayClassId: Long,
+        val elementIds: LongArray
+      ) : ObjectRecord()
+
+      sealed class PrimitiveArrayDumpRecord : ObjectRecord() {
+        abstract val id: Long
+        abstract val stackTraceSerialNumber: Int
+        abstract val size: Int
+
+        class BooleanArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: BooleanArray
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
+
+        class CharArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: CharArray
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
+
+        class FloatArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: FloatArray
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
+
+        class DoubleArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: DoubleArray
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
+
+        class ByteArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: ByteArray
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
+
+        class ShortArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: ShortArray
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
+
+        class IntArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: IntArray
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
+
+        class LongArrayDump(
+          override val id: Long,
+          override val stackTraceSerialNumber: Int,
+          val array: LongArray
+        ) : PrimitiveArrayDumpRecord() {
+          override val size: Int
+            get() = array.size
+        }
+      }
+    }
+
+    class HeapDumpInfoRecord(
+      val heapId: Int,
+      val heapNameStringId: Long
+    ) : HeapDumpRecord()
+  }
+}
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/HprofRecordReader.kt b/shark-hprof/src/main/java/shark/HprofRecordReader.kt
new file mode 100644
index 00000000..44f771f3
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/HprofRecordReader.kt
@@ -0,0 +1,572 @@
+package shark
+
+import okio.BufferedSource
+import shark.GcRoot.Debugger
+import shark.GcRoot.Finalizing
+import shark.GcRoot.InternedString
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.JniGlobal
+import shark.GcRoot.JniLocal
+import shark.GcRoot.JniMonitor
+import shark.GcRoot.MonitorUsed
+import shark.GcRoot.NativeStack
+import shark.GcRoot.ReferenceCleanup
+import shark.GcRoot.StickyClass
+import shark.GcRoot.ThreadBlock
+import shark.GcRoot.ThreadObject
+import shark.GcRoot.Unknown
+import shark.GcRoot.Unreachable
+import shark.GcRoot.VmInternal
+import shark.HprofRecord.HeapDumpRecord.HeapDumpInfoRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StackFrameRecord
+import shark.HprofRecord.StackTraceRecord
+import shark.HprofRecord.StringRecord
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.BYTE
+import shark.PrimitiveType.CHAR
+import shark.PrimitiveType.DOUBLE
+import shark.PrimitiveType.FLOAT
+import shark.PrimitiveType.INT
+import shark.PrimitiveType.LONG
+import shark.PrimitiveType.SHORT
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+import java.nio.charset.Charset
+
+/**
+ * Reads hprof content from an Okio [BufferedSource].
+ *
+ * Binary Dump Format reference: http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share
+ * /demo/jvmti/hprof/manual.html#mozTocId848088
+ *
+ * The Android Hprof format differs in some ways from that reference. This parser implementation
+ * is largely adapted from https://android.googlesource.com/platform/tools/base/+/studio-master-dev
+ * /perflib/src/main/java/com/android/tools/perflib
+ *
+ * Not thread safe, should be used from a single thread.
+ */
+@Suppress("LargeClass", "TooManyFunctions")
+class HprofRecordReader internal constructor(
+  header: HprofHeader,
+  private val source: BufferedSource
+) {
+
+  /**
+   * How many bytes this reader has read from [source]. Can only increase.
+   */
+  var bytesRead = 0L
+    private set
+
+  private val identifierByteSize = header.identifierByteSize
+
+  private val typeSizes: IntArray
+
+  init {
+    val typeSizesMap =
+      PrimitiveType.byteSizeByHprofType + (PrimitiveType.REFERENCE_HPROF_TYPE to identifierByteSize)
+
+    val maxKey = typeSizesMap.keys.max()!!
+
+    typeSizes = IntArray(maxKey + 1) { key ->
+      typeSizesMap[key] ?: 0
+    }
+  }
+
+  fun sizeOf(type: Int) = typeSizes[type]
+
+  fun readStringRecord(length: Long) = StringRecord(
+    id = readId(),
+    string = readUtf8(length - identifierByteSize)
+  )
+
+  fun readLoadClassRecord() = LoadClassRecord(
+    classSerialNumber = readInt(),
+    id = readId(),
+    stackTraceSerialNumber = readInt(),
+    classNameStringId = readId()
+  )
+
+  fun readStackFrameRecord() = StackFrameRecord(
+    id = readId(),
+    methodNameStringId = readId(),
+    methodSignatureStringId = readId(),
+    sourceFileNameStringId = readId(),
+    classSerialNumber = readInt(),
+    lineNumber = readInt()
+  )
+
+  fun readStackTraceRecord() = StackTraceRecord(
+    stackTraceSerialNumber = readInt(),
+    threadSerialNumber = readInt(),
+    stackFrameIds = readIdArray(readInt())
+  )
+
+  fun readUnknownGcRootRecord() = Unknown(id = readId())
+
+  fun readJniGlobalGcRootRecord() = JniGlobal(
+    id = readId(),
+    jniGlobalRefId = readId()
+  )
+
+  fun readJniLocalGcRootRecord() = JniLocal(
+    id = readId(),
+    threadSerialNumber = readInt(),
+    frameNumber = readInt()
+  )
+
+  fun readJavaFrameGcRootRecord() = JavaFrame(
+    id = readId(),
+    threadSerialNumber = readInt(),
+    frameNumber = readInt()
+  )
+
+  fun readNativeStackGcRootRecord() = NativeStack(
+    id = readId(),
+    threadSerialNumber = readInt()
+  )
+
+  fun readStickyClassGcRootRecord() = StickyClass(id = readId())
+
+  fun readThreadBlockGcRootRecord() = ThreadBlock(id = readId(), threadSerialNumber = readInt())
+
+  fun readMonitorUsedGcRootRecord() = MonitorUsed(id = readId())
+
+  fun readThreadObjectGcRootRecord() = ThreadObject(
+    id = readId(),
+    threadSerialNumber = readInt(),
+    stackTraceSerialNumber = readInt()
+  )
+
+  fun readInternedStringGcRootRecord() = InternedString(id = readId())
+
+  fun readFinalizingGcRootRecord() = Finalizing(id = readId())
+
+  fun readDebuggerGcRootRecord() = Debugger(id = readId())
+
+  fun readReferenceCleanupGcRootRecord() = ReferenceCleanup(id = readId())
+
+  fun readVmInternalGcRootRecord() = VmInternal(id = readId())
+
+  fun readJniMonitorGcRootRecord() = JniMonitor(
+    id = readId(),
+    stackTraceSerialNumber = readInt(),
+    stackDepth = readInt()
+  )
+
+  fun readUnreachableGcRootRecord() = Unreachable(id = readId())
+
+  /**
+   * Reads a full instance record after a instance dump tag.
+   */
+  fun readInstanceDumpRecord(): InstanceDumpRecord {
+    val id = readId()
+    val stackTraceSerialNumber = readInt()
+    val classId = readId()
+    val remainingBytesInInstance = readInt()
+    val fieldValues = readByteArray(remainingBytesInInstance)
+    return InstanceDumpRecord(
+      id = id,
+      stackTraceSerialNumber = stackTraceSerialNumber,
+      classId = classId,
+      fieldValues = fieldValues
+    )
+  }
+
+  fun readHeapDumpInfoRecord(): HeapDumpInfoRecord {
+    val heapId = readInt()
+    return HeapDumpInfoRecord(heapId = heapId, heapNameStringId = readId())
+  }
+
+  /**
+   * Reads a full class record after a class dump tag.
+   */
+  fun readClassDumpRecord(): ClassDumpRecord {
+    val id = readId()
+    // stack trace serial number
+    val stackTraceSerialNumber = readInt()
+    val superclassId = readId()
+    // class loader object ID
+    val classLoaderId = readId()
+    // signers object ID
+    val signersId = readId()
+    // protection domain object ID
+    val protectionDomainId = readId()
+    // reserved
+    readId()
+    // reserved
+    readId()
+
+    // instance size (in bytes)
+    // Useful to compute retained size
+    val instanceSize = readInt()
+
+    // Skip over the constant pool
+    val constantPoolCount = readUnsignedShort()
+    for (i in 0 until constantPoolCount) {
+      // constant pool index
+      skip(SHORT_SIZE)
+      skip(typeSizes[readUnsignedByte()])
+    }
+
+    val staticFieldCount = readUnsignedShort()
+    val staticFields = ArrayList<StaticFieldRecord>(staticFieldCount)
+    for (i in 0 until staticFieldCount) {
+
+      val nameStringId = readId()
+      val type = readUnsignedByte()
+      val value = readValue(type)
+
+      staticFields.add(
+        StaticFieldRecord(
+          nameStringId = nameStringId,
+          type = type,
+          value = value
+        )
+      )
+    }
+
+    val fieldCount = readUnsignedShort()
+    val fields = ArrayList<FieldRecord>(fieldCount)
+    for (i in 0 until fieldCount) {
+      fields.add(FieldRecord(nameStringId = readId(), type = readUnsignedByte()))
+    }
+
+    return ClassDumpRecord(
+      id = id,
+      stackTraceSerialNumber = stackTraceSerialNumber,
+      superclassId = superclassId,
+      classLoaderId = classLoaderId,
+      signersId = signersId,
+      protectionDomainId = protectionDomainId,
+      instanceSize = instanceSize,
+      staticFields = staticFields,
+      fields = fields
+    )
+  }
+
+  /**
+   * Reads a full primitive array record after a primitive array dump tag.
+   */
+  fun readPrimitiveArrayDumpRecord(): PrimitiveArrayDumpRecord {
+    val id = readId()
+    val stackTraceSerialNumber = readInt()
+    // length
+    val arrayLength = readInt()
+    return when (val type = readUnsignedByte()) {
+      BOOLEAN_TYPE -> BooleanArrayDump(
+        id, stackTraceSerialNumber, readBooleanArray(arrayLength)
+      )
+      CHAR_TYPE -> CharArrayDump(
+        id, stackTraceSerialNumber, readCharArray(arrayLength)
+      )
+      FLOAT_TYPE -> FloatArrayDump(
+        id, stackTraceSerialNumber, readFloatArray(arrayLength)
+      )
+      DOUBLE_TYPE -> DoubleArrayDump(
+        id, stackTraceSerialNumber, readDoubleArray(arrayLength)
+      )
+      BYTE_TYPE -> ByteArrayDump(
+        id, stackTraceSerialNumber, readByteArray(arrayLength)
+      )
+      SHORT_TYPE -> ShortArrayDump(
+        id, stackTraceSerialNumber, readShortArray(arrayLength)
+      )
+      INT_TYPE -> IntArrayDump(
+        id, stackTraceSerialNumber, readIntArray(arrayLength)
+      )
+      LONG_TYPE -> LongArrayDump(
+        id, stackTraceSerialNumber, readLongArray(arrayLength)
+      )
+      else -> throw IllegalStateException("Unexpected type $type")
+    }
+  }
+
+  /**
+   * Reads a full object array record after a object array dump tag.
+   */
+  fun readObjectArrayDumpRecord(): ObjectArrayDumpRecord {
+    val id = readId()
+    // stack trace serial number
+    val stackTraceSerialNumber = readInt()
+    val arrayLength = readInt()
+    val arrayClassId = readId()
+    val elementIds = readIdArray(arrayLength)
+    return ObjectArrayDumpRecord(
+      id = id,
+      stackTraceSerialNumber = stackTraceSerialNumber,
+      arrayClassId = arrayClassId,
+      elementIds = elementIds
+    )
+  }
+
+  fun skipClassDumpHeader() {
+    skip(INT_SIZE * 2 + identifierByteSize * 7)
+    skipClassDumpConstantPool()
+  }
+
+  fun skipClassDumpConstantPool() {
+    // Skip over the constant pool
+    val constantPoolCount = readUnsignedShort()
+    for (i in 0 until constantPoolCount) {
+      // constant pool index
+      skip(SHORT.byteSize)
+      skip(sizeOf(readUnsignedByte()))
+    }
+  }
+
+  fun skipClassDumpStaticFields() {
+    val staticFieldCount = readUnsignedShort()
+    for (i in 0 until staticFieldCount) {
+      skip(identifierByteSize)
+      val type = readUnsignedByte()
+      skip(
+        if (type == PrimitiveType.REFERENCE_HPROF_TYPE) {
+          identifierByteSize
+        } else {
+          PrimitiveType.byteSizeByHprofType.getValue(type)
+        }
+      )
+    }
+  }
+
+  fun skipClassDumpFields() {
+    val fieldCount = readUnsignedShort()
+    skip((identifierByteSize + 1) * fieldCount)
+  }
+
+  fun skipInstanceDumpRecord() {
+    skip(identifierByteSize + INT_SIZE + identifierByteSize)
+    val remainingBytesInInstance = readInt()
+    skip(remainingBytesInInstance)
+  }
+
+  fun skipClassDumpRecord() {
+    skip(
+      identifierByteSize + INT_SIZE + identifierByteSize + identifierByteSize + identifierByteSize +
+        identifierByteSize + identifierByteSize + identifierByteSize + INT_SIZE
+    )
+    // Skip over the constant pool
+    val constantPoolCount = readUnsignedShort()
+    for (i in 0 until constantPoolCount) {
+      // constant pool index
+      skip(SHORT_SIZE)
+      skip(typeSizes[readUnsignedByte()])
+    }
+
+    val staticFieldCount = readUnsignedShort()
+
+    for (i in 0 until staticFieldCount) {
+      skip(identifierByteSize)
+      val type = readUnsignedByte()
+      skip(typeSizes[type])
+    }
+
+    val fieldCount = readUnsignedShort()
+    skip(fieldCount * (identifierByteSize + BYTE_SIZE))
+  }
+
+  fun skipObjectArrayDumpRecord() {
+    skip(identifierByteSize + INT_SIZE)
+    val arrayLength = readInt()
+    skip(identifierByteSize + arrayLength * identifierByteSize)
+  }
+
+  fun skipPrimitiveArrayDumpRecord() {
+    skip(identifierByteSize + INT_SIZE)
+    val arrayLength = readInt()
+    val type = readUnsignedByte()
+    skip(arrayLength * typeSizes[type])
+  }
+
+  fun skipHeapDumpInfoRecord() {
+    skip(identifierByteSize + identifierByteSize)
+  }
+
+  fun skip(byteCount: Int) {
+    bytesRead += byteCount
+    return source.skip(byteCount.toLong())
+  }
+
+  fun skipId() {
+    skip(identifierByteSize)
+  }
+
+  fun skip(byteCount: Long) {
+    bytesRead += byteCount
+    return source.skip(byteCount)
+  }
+
+  fun readUnsignedInt(): Long {
+    return readInt().toLong() and INT_MASK
+  }
+
+  fun readUnsignedByte(): Int {
+    return readByte().toInt() and BYTE_MASK
+  }
+
+  /**
+   * Reads a value in the heap dump, which can be a reference or a primitive type.
+   */
+  fun readValue(type: Int): ValueHolder {
+    return when (type) {
+      PrimitiveType.REFERENCE_HPROF_TYPE -> ReferenceHolder(readId())
+      BOOLEAN_TYPE -> BooleanHolder(readBoolean())
+      CHAR_TYPE -> CharHolder(readChar())
+      FLOAT_TYPE -> FloatHolder(readFloat())
+      DOUBLE_TYPE -> DoubleHolder(readDouble())
+      BYTE_TYPE -> ByteHolder(readByte())
+      SHORT_TYPE -> ShortHolder(readShort())
+      INT_TYPE -> IntHolder(readInt())
+      LONG_TYPE -> LongHolder(readLong())
+      else -> throw IllegalStateException("Unknown type $type")
+    }
+  }
+
+  fun readShort(): Short {
+    bytesRead += SHORT_SIZE
+    return source.readShort()
+  }
+
+  fun readInt(): Int {
+    bytesRead += INT_SIZE
+    return source.readInt()
+  }
+
+  fun readIdArray(arrayLength: Int): LongArray {
+    return LongArray(arrayLength) { readId() }
+  }
+
+  fun readBooleanArray(arrayLength: Int): BooleanArray {
+    return BooleanArray(arrayLength) { readByte().toInt() != 0 }
+  }
+
+  fun readCharArray(arrayLength: Int): CharArray {
+    return CharArray(arrayLength) {
+      readChar()
+    }
+  }
+
+  fun readString(
+    byteCount: Int,
+    charset: Charset
+  ): String {
+    bytesRead += byteCount
+    return source.readString(byteCount.toLong(), charset)
+  }
+
+  fun readFloatArray(arrayLength: Int): FloatArray {
+    return FloatArray(arrayLength) { readFloat() }
+  }
+
+  fun readDoubleArray(arrayLength: Int): DoubleArray {
+    return DoubleArray(arrayLength) { readDouble() }
+  }
+
+  fun readShortArray(arrayLength: Int): ShortArray {
+    return ShortArray(arrayLength) { readShort() }
+  }
+
+  fun readIntArray(arrayLength: Int): IntArray {
+    return IntArray(arrayLength) { readInt() }
+  }
+
+  fun readLongArray(arrayLength: Int): LongArray {
+    return LongArray(arrayLength) { readLong() }
+  }
+
+  fun readLong(): Long {
+    bytesRead += LONG_SIZE
+    return source.readLong()
+  }
+
+  fun readByte(): Byte {
+    bytesRead += BYTE_SIZE
+    return source.readByte()
+  }
+
+  fun readBoolean(): Boolean {
+    bytesRead += BOOLEAN_SIZE
+    return source.readByte()
+      .toInt() != 0
+  }
+
+  fun readByteArray(byteCount: Int): ByteArray {
+    bytesRead += byteCount
+    return source.readByteArray(byteCount.toLong())
+  }
+
+  fun readChar(): Char {
+    return readString(CHAR_SIZE, Charsets.UTF_16BE)[0]
+  }
+
+  fun readFloat(): Float {
+    return Float.fromBits(readInt())
+  }
+
+  fun readDouble(): Double {
+    return Double.fromBits(readLong())
+  }
+
+  fun readId(): Long {
+    // As long as we don't interpret IDs, reading signed values here is fine.
+    return when (identifierByteSize) {
+      1 -> readByte().toLong()
+      2 -> readShort().toLong()
+      4 -> readInt().toLong()
+      8 -> readLong()
+      else -> throw IllegalArgumentException("ID Length must be 1, 2, 4, or 8")
+    }
+  }
+
+  fun readUtf8(byteCount: Long): String {
+    bytesRead += byteCount
+    return source.readUtf8(byteCount)
+  }
+
+  fun readUnsignedShort(): Int {
+    return readShort().toInt() and 0xFFFF
+  }
+
+  companion object {
+    private val BOOLEAN_SIZE = BOOLEAN.byteSize
+    private val CHAR_SIZE = CHAR.byteSize
+    private val BYTE_SIZE = BYTE.byteSize
+    private val SHORT_SIZE = SHORT.byteSize
+    private val INT_SIZE = INT.byteSize
+    private val LONG_SIZE = LONG.byteSize
+
+    private val BOOLEAN_TYPE = BOOLEAN.hprofType
+    private val CHAR_TYPE = CHAR.hprofType
+    private val FLOAT_TYPE = FLOAT.hprofType
+    private val DOUBLE_TYPE = DOUBLE.hprofType
+    private val BYTE_TYPE = BYTE.hprofType
+    private val SHORT_TYPE = SHORT.hprofType
+    private val INT_TYPE = INT.hprofType
+    private val LONG_TYPE = LONG.hprofType
+
+    private const val INT_MASK = 0xffffffffL
+    private const val BYTE_MASK = 0xff
+  }
+}
diff --git a/shark-hprof/src/main/java/shark/HprofRecordTag.kt b/shark-hprof/src/main/java/shark/HprofRecordTag.kt
new file mode 100644
index 00000000..7bb4a2fd
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/HprofRecordTag.kt
@@ -0,0 +1,98 @@
+package shark
+
+import java.util.EnumSet
+
+enum class HprofRecordTag(val tag: Int) {
+  STRING_IN_UTF8(0x01),
+  LOAD_CLASS(0x02),
+
+  // Currently ignored
+  UNLOAD_CLASS(0x03),
+  STACK_FRAME(0x04),
+  STACK_TRACE(0x05),
+
+  // Currently ignored
+  ALLOC_SITES(0x06),
+
+  // Currently ignored
+  HEAP_SUMMARY(0x07),
+
+  // Currently ignored
+  START_THREAD(0x0a),
+
+  // Currently ignored
+  END_THREAD(0x0b),
+
+  // Currently not reported
+  HEAP_DUMP(0x0c),
+
+  // Currently not reported
+  HEAP_DUMP_SEGMENT(0x1c),
+  HEAP_DUMP_END(0x2c),
+
+  // Currently ignored
+  CPU_SAMPLES(0x0d),
+
+  // Currently ignored
+  CONTROL_SETTINGS(0x0e),
+  ROOT_UNKNOWN(0xff),
+  ROOT_JNI_GLOBAL(0x01),
+  ROOT_JNI_LOCAL(0x02),
+  ROOT_JAVA_FRAME(0x03),
+  ROOT_NATIVE_STACK(0x04),
+  ROOT_STICKY_CLASS(0x05),
+
+  // An object that was referenced from an active thread block.
+  ROOT_THREAD_BLOCK(0x06),
+  ROOT_MONITOR_USED(0x07),
+  ROOT_THREAD_OBJECT(0x08),
+
+  /**
+   * Android format addition
+   *
+   * Specifies information about which heap certain objects came from. When a sub-tag of this type
+   * appears in a HPROF_HEAP_DUMP or HPROF_HEAP_DUMP_SEGMENT record, entries that follow it will
+   * be associated with the specified heap.  The HEAP_DUMP_INFO data is reset at the end of the
+   * `HEAP_DUMP[_SEGMENT]`.  Multiple HEAP_DUMP_INFO entries may appear in a single
+   * `HEAP_DUMP[_SEGMENT]`.
+   *
+   * Format: u1: Tag value (0xFE) u4: heap ID ID: heap name string ID
+   */
+  HEAP_DUMP_INFO(0xfe),
+  ROOT_INTERNED_STRING(0x89),
+  ROOT_FINALIZING(0x8a),
+  ROOT_DEBUGGER(0x8b),
+  ROOT_REFERENCE_CLEANUP(0x8c),
+  ROOT_VM_INTERNAL(0x8d),
+  ROOT_JNI_MONITOR(0x8e),
+  ROOT_UNREACHABLE(0x90),
+
+  // Not supported.
+  PRIMITIVE_ARRAY_NODATA(0xc3),
+  CLASS_DUMP(0x20),
+  INSTANCE_DUMP(0x21),
+  OBJECT_ARRAY_DUMP(0x22),
+  PRIMITIVE_ARRAY_DUMP(0x23),
+  ;
+
+  companion object {
+    val rootTags: EnumSet<HprofRecordTag> = EnumSet.of(
+      ROOT_UNKNOWN,
+      ROOT_JNI_GLOBAL,
+      ROOT_JNI_LOCAL,
+      ROOT_JAVA_FRAME,
+      ROOT_NATIVE_STACK,
+      ROOT_STICKY_CLASS,
+      ROOT_THREAD_BLOCK,
+      ROOT_MONITOR_USED,
+      ROOT_THREAD_OBJECT,
+      ROOT_INTERNED_STRING,
+      ROOT_FINALIZING,
+      ROOT_DEBUGGER,
+      ROOT_REFERENCE_CLEANUP,
+      ROOT_VM_INTERNAL,
+      ROOT_JNI_MONITOR,
+      ROOT_UNREACHABLE
+    )
+  }
+}
diff --git a/shark-hprof/src/main/java/shark/HprofVersion.kt b/shark-hprof/src/main/java/shark/HprofVersion.kt
new file mode 100644
index 00000000..df74d1b0
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/HprofVersion.kt
@@ -0,0 +1,11 @@
+package shark
+
+/**
+ * Supported hprof versions
+ */
+enum class HprofVersion(val versionString: String) {
+  JDK1_2_BETA3("JAVA PROFILE 1.0"),
+  JDK1_2_BETA4("JAVA PROFILE 1.0.1"),
+  JDK_6("JAVA PROFILE 1.0.2"),
+  ANDROID("JAVA PROFILE 1.0.3")
+}
diff --git a/shark-hprof/src/main/java/shark/HprofWriter.kt b/shark-hprof/src/main/java/shark/HprofWriter.kt
new file mode 100644
index 00000000..faa146b6
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/HprofWriter.kt
@@ -0,0 +1,473 @@
+package shark
+
+import okio.Buffer
+import okio.BufferedSink
+import okio.Okio
+import shark.GcRoot.Debugger
+import shark.GcRoot.Finalizing
+import shark.GcRoot.InternedString
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.JniGlobal
+import shark.GcRoot.JniLocal
+import shark.GcRoot.JniMonitor
+import shark.GcRoot.MonitorUsed
+import shark.GcRoot.NativeStack
+import shark.GcRoot.ReferenceCleanup
+import shark.GcRoot.StickyClass
+import shark.GcRoot.ThreadBlock
+import shark.GcRoot.ThreadObject
+import shark.GcRoot.Unknown
+import shark.GcRoot.Unreachable
+import shark.GcRoot.VmInternal
+import shark.HprofRecord.HeapDumpEndRecord
+import shark.HprofRecord.HeapDumpRecord.GcRootRecord
+import shark.HprofRecord.HeapDumpRecord.HeapDumpInfoRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StackTraceRecord
+import shark.HprofRecord.StringRecord
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.BYTE
+import shark.PrimitiveType.CHAR
+import shark.PrimitiveType.DOUBLE
+import shark.PrimitiveType.FLOAT
+import shark.PrimitiveType.INT
+import shark.PrimitiveType.LONG
+import shark.PrimitiveType.SHORT
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+import java.io.Closeable
+import java.io.File
+
+/**
+ * Generates Hprof files.
+ *
+ * Call [openWriterFor] to obtain a new instance.
+ *
+ * Call [write] to add records and [close] when you're done.
+ */
+class HprofWriter private constructor(
+  private val sink: BufferedSink,
+  val hprofHeader: HprofHeader
+) : Closeable {
+
+  @Deprecated(
+    "Replaced by HprofWriter.hprofHeader.identifierByteSize",
+    ReplaceWith("hprofHeader.identifierByteSize")
+  )
+  val identifierByteSize: Int
+    get() = hprofHeader.identifierByteSize
+
+  @Deprecated(
+    "Replaced by HprofWriter.hprofHeader.version",
+    ReplaceWith("hprofHeader.version")
+  )
+  val hprofVersion: Hprof.HprofVersion
+    get() = Hprof.HprofVersion.valueOf(hprofHeader.version.name)
+
+  private val workBuffer = Buffer()
+
+  /**
+   * Appends a [HprofRecord] to the heap dump. If [record] is a [HprofRecord.HeapDumpRecord] then
+   * it will not be written to an in memory buffer and written to file only when the next a record
+   * that is not a [HprofRecord.HeapDumpRecord] is written or when [close] is called.
+   */
+  fun write(record: HprofRecord) {
+    sink.write(record)
+  }
+
+  /**
+   * Helper method for creating a [ByteArray] for [InstanceDumpRecord.fieldValues] from a
+   * list of [ValueHolder].
+   */
+  fun valuesToBytes(values: List<ValueHolder>): ByteArray {
+    val valuesBuffer = Buffer()
+    values.forEach { value ->
+      valuesBuffer.writeValue(value)
+    }
+    return valuesBuffer.readByteArray()
+  }
+
+  /**
+   * Flushes to disk all [HprofRecord.HeapDumpRecord] that are currently written to the in memory
+   * buffer, then closes the file.
+   */
+  override fun close() {
+    sink.flushHeapBuffer()
+    sink.close()
+  }
+
+  private fun BufferedSink.writeValue(wrapper: ValueHolder) {
+    when (wrapper) {
+      is ReferenceHolder -> writeId(wrapper.value)
+      is BooleanHolder -> writeBoolean(wrapper.value)
+      is CharHolder -> write(charArrayOf(wrapper.value))
+      is FloatHolder -> writeFloat(wrapper.value)
+      is DoubleHolder -> writeDouble(wrapper.value)
+      is ByteHolder -> writeByte(wrapper.value.toInt())
+      is ShortHolder -> writeShort(wrapper.value.toInt())
+      is IntHolder -> writeInt(wrapper.value)
+      is LongHolder -> writeLong(wrapper.value)
+    }
+  }
+
+  @Suppress("LongMethod")
+  private fun BufferedSink.write(record: HprofRecord) {
+    when (record) {
+      is StringRecord -> {
+        writeNonHeapRecord(HprofRecordTag.STRING_IN_UTF8.tag) {
+          writeId(record.id)
+          writeUtf8(record.string)
+        }
+      }
+      is LoadClassRecord -> {
+        writeNonHeapRecord(HprofRecordTag.LOAD_CLASS.tag) {
+          writeInt(record.classSerialNumber)
+          writeId(record.id)
+          writeInt(record.stackTraceSerialNumber)
+          writeId(record.classNameStringId)
+        }
+      }
+      is StackTraceRecord -> {
+        writeNonHeapRecord(HprofRecordTag.STACK_TRACE.tag) {
+          writeInt(record.stackTraceSerialNumber)
+          writeInt(record.threadSerialNumber)
+          writeInt(record.stackFrameIds.size)
+          writeIdArray(record.stackFrameIds)
+        }
+      }
+      is GcRootRecord -> {
+        with(workBuffer) {
+          when (val gcRoot = record.gcRoot) {
+            is Unknown -> {
+              writeByte(HprofRecordTag.ROOT_UNKNOWN.tag)
+              writeId(gcRoot.id)
+            }
+            is JniGlobal -> {
+              writeByte(
+                HprofRecordTag.ROOT_JNI_GLOBAL.tag
+              )
+              writeId(gcRoot.id)
+              writeId(gcRoot.jniGlobalRefId)
+            }
+            is JniLocal -> {
+              writeByte(HprofRecordTag.ROOT_JNI_LOCAL.tag)
+              writeId(gcRoot.id)
+              writeInt(gcRoot.threadSerialNumber)
+              writeInt(gcRoot.frameNumber)
+            }
+            is JavaFrame -> {
+              writeByte(HprofRecordTag.ROOT_JAVA_FRAME.tag)
+              writeId(gcRoot.id)
+              writeInt(gcRoot.threadSerialNumber)
+              writeInt(gcRoot.frameNumber)
+            }
+            is NativeStack -> {
+              writeByte(HprofRecordTag.ROOT_NATIVE_STACK.tag)
+              writeId(gcRoot.id)
+              writeInt(gcRoot.threadSerialNumber)
+            }
+            is StickyClass -> {
+              writeByte(HprofRecordTag.ROOT_STICKY_CLASS.tag)
+              writeId(gcRoot.id)
+            }
+            is ThreadBlock -> {
+              writeByte(HprofRecordTag.ROOT_THREAD_BLOCK.tag)
+              writeId(gcRoot.id)
+              writeInt(gcRoot.threadSerialNumber)
+            }
+            is MonitorUsed -> {
+              writeByte(HprofRecordTag.ROOT_MONITOR_USED.tag)
+              writeId(gcRoot.id)
+            }
+            is ThreadObject -> {
+              writeByte(HprofRecordTag.ROOT_THREAD_OBJECT.tag)
+              writeId(gcRoot.id)
+              writeInt(gcRoot.threadSerialNumber)
+              writeInt(gcRoot.stackTraceSerialNumber)
+            }
+            is ReferenceCleanup -> {
+              writeByte(HprofRecordTag.ROOT_REFERENCE_CLEANUP.tag)
+              writeId(gcRoot.id)
+            }
+            is VmInternal -> {
+              writeByte(HprofRecordTag.ROOT_VM_INTERNAL.tag)
+              writeId(gcRoot.id)
+            }
+            is JniMonitor -> {
+              writeByte(HprofRecordTag.ROOT_JNI_MONITOR.tag)
+              writeId(gcRoot.id)
+              writeInt(gcRoot.stackTraceSerialNumber)
+              writeInt(gcRoot.stackDepth)
+            }
+            is InternedString -> {
+              writeByte(HprofRecordTag.ROOT_INTERNED_STRING.tag)
+              writeId(gcRoot.id)
+            }
+            is Finalizing -> {
+              writeByte(HprofRecordTag.ROOT_FINALIZING.tag)
+              writeId(gcRoot.id)
+            }
+            is Debugger -> {
+              writeByte(HprofRecordTag.ROOT_DEBUGGER.tag)
+              writeId(gcRoot.id)
+            }
+            is Unreachable -> {
+              writeByte(HprofRecordTag.ROOT_UNREACHABLE.tag)
+              writeId(gcRoot.id)
+            }
+          }
+        }
+      }
+      is ClassDumpRecord -> {
+        with(workBuffer) {
+          writeByte(HprofRecordTag.CLASS_DUMP.tag)
+          writeId(record.id)
+          writeInt(record.stackTraceSerialNumber)
+          writeId(record.superclassId)
+          writeId(record.classLoaderId)
+          writeId(record.signersId)
+          writeId(record.protectionDomainId)
+          // reserved
+          writeId(0)
+          // reserved
+          writeId(0)
+          writeInt(record.instanceSize)
+          // Not writing anything in the constant pool
+          val constantPoolCount = 0
+          writeShort(constantPoolCount)
+          writeShort(record.staticFields.size)
+          record.staticFields.forEach { field ->
+            writeId(field.nameStringId)
+            writeByte(field.type)
+            writeValue(field.value)
+          }
+          writeShort(record.fields.size)
+          record.fields.forEach { field ->
+            writeId(field.nameStringId)
+            writeByte(field.type)
+          }
+        }
+      }
+      is InstanceDumpRecord -> {
+        with(workBuffer) {
+          writeByte(HprofRecordTag.INSTANCE_DUMP.tag)
+          writeId(record.id)
+          writeInt(record.stackTraceSerialNumber)
+          writeId(record.classId)
+          writeInt(record.fieldValues.size)
+          write(record.fieldValues)
+        }
+      }
+      is ObjectArrayDumpRecord -> {
+        with(workBuffer) {
+          writeByte(HprofRecordTag.OBJECT_ARRAY_DUMP.tag)
+          writeId(record.id)
+          writeInt(record.stackTraceSerialNumber)
+          writeInt(record.elementIds.size)
+          writeId(record.arrayClassId)
+          writeIdArray(record.elementIds)
+        }
+      }
+      is PrimitiveArrayDumpRecord -> {
+        with(workBuffer) {
+          writeByte(HprofRecordTag.PRIMITIVE_ARRAY_DUMP.tag)
+          writeId(record.id)
+          writeInt(record.stackTraceSerialNumber)
+
+          when (record) {
+            is BooleanArrayDump -> {
+              writeInt(record.array.size)
+              writeByte(BOOLEAN.hprofType)
+              write(record.array)
+            }
+            is CharArrayDump -> {
+              writeInt(record.array.size)
+              writeByte(CHAR.hprofType)
+              write(record.array)
+            }
+            is FloatArrayDump -> {
+              writeInt(record.array.size)
+              writeByte(FLOAT.hprofType)
+              write(record.array)
+            }
+            is DoubleArrayDump -> {
+              writeInt(record.array.size)
+              writeByte(DOUBLE.hprofType)
+              write(record.array)
+            }
+            is ByteArrayDump -> {
+              writeInt(record.array.size)
+              writeByte(BYTE.hprofType)
+              write(record.array)
+            }
+            is ShortArrayDump -> {
+              writeInt(record.array.size)
+              writeByte(SHORT.hprofType)
+              write(record.array)
+            }
+            is IntArrayDump -> {
+              writeInt(record.array.size)
+              writeByte(INT.hprofType)
+              write(record.array)
+            }
+            is LongArrayDump -> {
+              writeInt(record.array.size)
+              writeByte(LONG.hprofType)
+              write(record.array)
+            }
+          }
+        }
+      }
+      is HeapDumpInfoRecord -> {
+        with(workBuffer) {
+          writeByte(HprofRecordTag.HEAP_DUMP_INFO.tag)
+          writeInt(record.heapId)
+          writeId(record.heapNameStringId)
+        }
+      }
+      is HeapDumpEndRecord -> {
+        throw IllegalArgumentException("HprofWriter automatically emits HeapDumpEndRecord")
+      }
+    }
+  }
+
+  private fun BufferedSink.writeDouble(value: Double) {
+    writeLong(value.toBits())
+  }
+
+  private fun BufferedSink.writeFloat(value: Float) {
+    writeInt(value.toBits())
+  }
+
+  private fun BufferedSink.writeBoolean(value: Boolean) {
+    writeByte(if (value) 1 else 0)
+  }
+
+  private fun BufferedSink.writeIdArray(array: LongArray) {
+    array.forEach { writeId(it) }
+  }
+
+  private fun BufferedSink.write(array: BooleanArray) {
+    array.forEach { writeByte(if (it) 1 else 0) }
+  }
+
+  private fun BufferedSink.write(array: CharArray) {
+    writeString(String(array), Charsets.UTF_16BE)
+  }
+
+  private fun BufferedSink.write(array: FloatArray) {
+    array.forEach { writeFloat(it) }
+  }
+
+  private fun BufferedSink.write(array: DoubleArray) {
+    array.forEach { writeDouble(it) }
+  }
+
+  private fun BufferedSink.write(array: ShortArray) {
+    array.forEach { writeShort(it.toInt()) }
+  }
+
+  private fun BufferedSink.write(array: IntArray) {
+    array.forEach { writeInt(it) }
+  }
+
+  private fun BufferedSink.write(array: LongArray) {
+    array.forEach { writeLong(it) }
+  }
+
+  private fun BufferedSink.writeNonHeapRecord(
+    tag: Int,
+    block: BufferedSink.() -> Unit
+  ) {
+    flushHeapBuffer()
+    workBuffer.block()
+    writeTagHeader(tag, workBuffer.size())
+    writeAll(workBuffer)
+  }
+
+  private fun BufferedSink.flushHeapBuffer() {
+    if (workBuffer.size() > 0) {
+      writeTagHeader(HprofRecordTag.HEAP_DUMP.tag, workBuffer.size())
+      writeAll(workBuffer)
+      writeTagHeader(HprofRecordTag.HEAP_DUMP_END.tag, 0)
+    }
+  }
+
+  private fun BufferedSink.writeTagHeader(
+    tag: Int,
+    length: Long
+  ) {
+    writeByte(tag)
+    // number of microseconds since the time stamp in the header
+    writeInt(0)
+    writeInt(length.toInt())
+  }
+
+  private fun BufferedSink.writeId(id: Long) {
+    when (hprofHeader.identifierByteSize) {
+      1 -> writeByte(id.toInt())
+      2 -> writeShort(id.toInt())
+      4 -> writeInt(id.toInt())
+      8 -> writeLong(id)
+      else -> throw IllegalArgumentException("ID Length must be 1, 2, 4, or 8")
+    }
+  }
+
+  companion object {
+
+    fun openWriterFor(
+      hprofFile: File,
+      hprofHeader: HprofHeader = HprofHeader()
+    ): HprofWriter {
+      return openWriterFor(Okio.buffer(Okio.sink(hprofFile.outputStream())), hprofHeader)
+    }
+
+    fun openWriterFor(
+      hprofSink: BufferedSink,
+      hprofHeader: HprofHeader = HprofHeader()
+    ): HprofWriter {
+      hprofSink.writeUtf8(hprofHeader.version.versionString)
+      hprofSink.writeByte(0)
+      hprofSink.writeInt(hprofHeader.identifierByteSize)
+      hprofSink.writeLong(hprofHeader.heapDumpTimestamp)
+      return HprofWriter(hprofSink, hprofHeader)
+    }
+
+    @Deprecated(
+      "Replaced by HprofWriter.openWriterFor()",
+      ReplaceWith(
+        "shark.HprofWriter.openWriterFor(hprofFile)"
+      )
+    )
+    fun open(
+      hprofFile: File,
+      identifierByteSize: Int = 4,
+      hprofVersion: Hprof.HprofVersion = Hprof.HprofVersion.ANDROID
+    ): HprofWriter = openWriterFor(
+      hprofFile,
+      HprofHeader(
+        version = HprofVersion.valueOf(hprofVersion.name),
+        identifierByteSize = identifierByteSize
+      )
+    )
+  }
+}
diff --git a/shark-hprof/src/main/java/shark/OnHprofRecordListener.kt b/shark-hprof/src/main/java/shark/OnHprofRecordListener.kt
new file mode 100644
index 00000000..24b6e1e1
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/OnHprofRecordListener.kt
@@ -0,0 +1,35 @@
+package shark
+
+/**
+ * Listener passed in to [StreamingHprofReader.readRecords], gets notified for each [HprofRecord]
+ * found in the heap dump which types is in the set of the recordTypes parameter passed to
+ * [StreamingHprofReader.readRecords].
+ *
+ * This is a functional interface with which you can create a [OnHprofRecordListener] from a lambda.
+ */
+fun interface OnHprofRecordListener {
+  fun onHprofRecord(
+    /**
+     * The position of the record in the underlying hprof file.
+     */
+    position: Long,
+    record: HprofRecord
+  )
+
+  companion object {
+    /**
+     * Utility function to create a [OnHprofRecordListener] from the passed in [block] lambda
+     * instead of using the anonymous `object : OnHprofRecordListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val listener = OnHprofRecordListener { position, record ->
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (Long, HprofRecord) -> Unit): OnHprofRecordListener =
+      OnHprofRecordListener { position, record -> block(position, record) }
+  }
+}
diff --git a/shark-hprof/src/main/java/shark/OnHprofRecordTagListener.kt b/shark-hprof/src/main/java/shark/OnHprofRecordTagListener.kt
new file mode 100644
index 00000000..8994b13a
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/OnHprofRecordTagListener.kt
@@ -0,0 +1,36 @@
+package shark
+
+/**
+ * Listener passed in to [StreamingHprofReader.readRecords], gets notified for each
+ * [HprofRecordTag] found in the heap dump.
+ *
+ * Listener implementations are expected to read all bytes corresponding to a given tag from the
+ * provided reader before returning.
+ */
+fun interface OnHprofRecordTagListener {
+  fun onHprofRecord(
+    tag: HprofRecordTag,
+    /**
+     * Length of the record or -1 if there is the length is not known
+     */
+    length: Long,
+    reader: HprofRecordReader
+  )
+
+  companion object {
+    /**
+     * Utility function to create a [OnHprofRecordTagListener] from the passed in [block] lambda
+     * instead of using the anonymous `object : OnHprofRecordTagListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val listener = OnHprofRecordTagListener { tag, length, reader ->
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (HprofRecordTag, Long, HprofRecordReader) -> Unit): OnHprofRecordTagListener =
+      OnHprofRecordTagListener { tag, length, reader -> block(tag, length, reader) }
+  }
+}
diff --git a/shark-hprof/src/main/java/shark/PrimitiveType.kt b/shark-hprof/src/main/java/shark/PrimitiveType.kt
new file mode 100644
index 00000000..e285782a
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/PrimitiveType.kt
@@ -0,0 +1,35 @@
+package shark
+
+/**
+ * A primitive type in the prof.
+ */
+enum class PrimitiveType(
+  /**
+   * The hprof defined "basic type".
+   */
+  val hprofType: Int,
+  /**
+   * The size in bytes for each value of that type.
+   */
+  val byteSize: Int
+) {
+  BOOLEAN(4, 1),
+  CHAR(5, 2),
+  FLOAT(6, 4),
+  DOUBLE(7, 8),
+  BYTE(8, 1),
+  SHORT(9, 2),
+  INT(10, 4),
+  LONG(11, 8);
+
+  companion object {
+    /**
+     * The hprof defined "basic type" for references.
+     */
+    const val REFERENCE_HPROF_TYPE = 2
+
+    val byteSizeByHprofType = values().associate { it.hprofType to it.byteSize }
+
+    val primitiveTypeByHprofType = values().associateBy { it.hprofType }
+  }
+}
diff --git a/shark-hprof/src/main/java/shark/ProguardMapping.kt b/shark-hprof/src/main/java/shark/ProguardMapping.kt
new file mode 100644
index 00000000..f0a63829
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/ProguardMapping.kt
@@ -0,0 +1,40 @@
+package shark
+
+class ProguardMapping {
+
+  // Classes can be simply stored as a obfuscatedName -> clearName
+  // For fields it's a bit more complicated since we need to know
+  // the class that a given field belongs to (two different classes
+  // can have a field with the same name). So files are stored as:
+  // obfuscatedClassName.obfuscatedFieldName -> clearFieldName
+  private val obfuscatedToClearNamesMap = linkedMapOf<String, String>()
+
+  /**
+   * Returns deobfuscated class name or original string if there is no
+   * mapping for given obfuscated name.
+   */
+  fun deobfuscateClassName(obfuscatedClassName: String): String {
+    return obfuscatedToClearNamesMap[obfuscatedClassName] ?: obfuscatedClassName
+  }
+
+  /**
+   * Returns deobfuscated field name or original string if there is no
+   * mapping for given obfuscated name.
+   */
+  fun deobfuscateFieldName(
+    obfuscatedClass: String,
+    obfuscatedField: String
+  ): String {
+    return obfuscatedToClearNamesMap["$obfuscatedClass.$obfuscatedField"] ?: return obfuscatedField
+  }
+
+  /**
+   * Adds entry to the obfuscatedToClearNamesMap map.
+   */
+  fun addMapping(
+    obfuscatedName: String,
+    clearName: String
+  ) {
+    obfuscatedToClearNamesMap[obfuscatedName] = clearName
+  }
+}
diff --git a/shark-hprof/src/main/java/shark/ProguardMappingReader.kt b/shark-hprof/src/main/java/shark/ProguardMappingReader.kt
new file mode 100644
index 00000000..44126c15
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/ProguardMappingReader.kt
@@ -0,0 +1,92 @@
+package shark
+
+import java.io.FileNotFoundException
+import java.io.IOException
+import java.io.InputStream
+import java.text.ParseException
+
+class ProguardMappingReader(
+  private val proguardMappingInputStream: InputStream
+) {
+
+  @Throws(FileNotFoundException::class, IOException::class, ParseException::class)
+  fun readProguardMapping(): ProguardMapping {
+    val proguardMapping = ProguardMapping()
+    proguardMappingInputStream.bufferedReader(Charsets.UTF_8).use { bufferedReader ->
+
+      var currentClassName: String? = null
+      while (true) {
+        val line = bufferedReader.readLine()?.trim() ?: break
+
+        if (line.isEmpty() || line.startsWith(HASH_SYMBOL)) {
+          // empty line or comment
+          continue
+        }
+
+        if (line.endsWith(COLON_SYMBOL)) {
+          currentClassName = parseClassMapping(line, proguardMapping)
+        } else if (currentClassName != null) {
+          val isMethodMapping = line.contains(OPENING_PAREN_SYMBOL)
+          if (!isMethodMapping) {
+            parseClassField(line, currentClassName, proguardMapping)
+          }
+        }
+      }
+    }
+    return proguardMapping
+  }
+
+  // classes are stored as "clearName -> obfuscatedName:"
+  private fun parseClassMapping(
+    line: String,
+    proguardMapping: ProguardMapping
+  ): String? {
+    val arrowPosition = line.indexOf(ARROW_SYMBOL)
+    if (arrowPosition == -1) {
+      return null
+    }
+
+    val colonPosition = line.indexOf(COLON_SYMBOL, arrowPosition + ARROW_SYMBOL.length)
+    if (colonPosition == -1) {
+      return null
+    }
+
+    val clearClassName = line.substring(0, arrowPosition).trim()
+    val obfuscatedClassName =
+      line.substring(arrowPosition + ARROW_SYMBOL.length, colonPosition).trim()
+
+    proguardMapping.addMapping(obfuscatedClassName, clearClassName)
+
+    return obfuscatedClassName
+  }
+
+  // fields are stored as "typeName clearFieldName -> obfuscatedFieldName"
+  private fun parseClassField(
+    line: String,
+    currentClassName: String,
+    proguardMapping: ProguardMapping
+  ) {
+    val spacePosition = line.indexOf(SPACE_SYMBOL)
+    if (spacePosition == -1) {
+      return
+    }
+
+    val arrowPosition = line.indexOf(ARROW_SYMBOL, spacePosition + SPACE_SYMBOL.length)
+    if (arrowPosition == -1) {
+      return
+    }
+
+    val clearFieldName = line.substring(spacePosition + SPACE_SYMBOL.length, arrowPosition).trim()
+    val obfuscatedFieldName = line.substring(arrowPosition + ARROW_SYMBOL.length).trim()
+
+    proguardMapping.addMapping("$currentClassName.$obfuscatedFieldName", clearFieldName)
+  }
+
+  companion object {
+    private const val HASH_SYMBOL = "#"
+    private const val ARROW_SYMBOL = "->"
+    private const val COLON_SYMBOL = ":"
+    private const val SPACE_SYMBOL = " "
+    private const val OPENING_PAREN_SYMBOL = "("
+  }
+}
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/RandomAccessHprofReader.kt b/shark-hprof/src/main/java/shark/RandomAccessHprofReader.kt
new file mode 100644
index 00000000..46402e7d
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/RandomAccessHprofReader.kt
@@ -0,0 +1,72 @@
+package shark
+
+import okio.Buffer
+import java.io.Closeable
+import java.io.File
+
+/**
+ * Reads records in a Hprof source, one at a time with a specific position and size.
+ * Call [openReaderFor] to obtain a new instance.
+ */
+class RandomAccessHprofReader private constructor(
+  private val source: RandomAccessSource,
+  hprofHeader: HprofHeader
+) : Closeable {
+  private val buffer = Buffer()
+  private val reader = HprofRecordReader(hprofHeader, buffer)
+
+  /**
+   * Loads [recordSize] bytes at [recordPosition] into the buffer that backs [HprofRecordReader]
+   * then calls [withRecordReader] with that reader as a receiver. [withRecordReader] is expected
+   * to use the receiver reader to read one record of exactly [recordSize] bytes.
+   * @return the results from [withRecordReader]
+   */
+  fun <T> readRecord(
+    recordPosition: Long,
+    recordSize: Long,
+    withRecordReader: HprofRecordReader.() -> T
+  ): T {
+    require(recordSize > 0L) {
+      "recordSize $recordSize must be > 0"
+    }
+    var mutablePos = recordPosition
+    var mutableByteCount = recordSize
+
+    while (mutableByteCount > 0L) {
+      val bytesRead = source.read(buffer, mutablePos, mutableByteCount)
+      check(bytesRead > 0) {
+        "Requested $mutableByteCount bytes after reading ${mutablePos - recordPosition}, got 0 bytes instead."
+      }
+      mutablePos += bytesRead
+      mutableByteCount -= bytesRead
+    }
+    return withRecordReader(reader).apply {
+      check(buffer.size() == 0L) {
+        "Buffer not fully consumed: ${buffer.size()} bytes left"
+      }
+    }
+  }
+
+  override fun close() {
+    source.close()
+  }
+
+  companion object {
+
+    fun openReaderFor(
+      hprofFile: File,
+      hprofHeader: HprofHeader = HprofHeader.parseHeaderOf(hprofFile)
+    ): RandomAccessHprofReader {
+      val sourceProvider = FileSourceProvider(hprofFile)
+      return openReaderFor(sourceProvider, hprofHeader)
+    }
+
+    fun openReaderFor(
+      hprofSourceProvider: RandomAccessSourceProvider,
+      hprofHeader: HprofHeader = hprofSourceProvider.openRandomAccessSource()
+        .use { HprofHeader.parseHeaderOf(it.asStreamingSource()) }
+    ): RandomAccessHprofReader {
+      return RandomAccessHprofReader(hprofSourceProvider.openRandomAccessSource(), hprofHeader)
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/RandomAccessSource.kt b/shark-hprof/src/main/java/shark/RandomAccessSource.kt
new file mode 100644
index 00000000..c25001bc
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/RandomAccessSource.kt
@@ -0,0 +1,45 @@
+package shark
+
+import okio.Buffer
+import okio.BufferedSource
+import okio.Okio
+import okio.Source
+import okio.Timeout
+import java.io.Closeable
+import java.io.IOException
+
+interface RandomAccessSource : Closeable {
+  @Throws(IOException::class)
+  fun read(
+    sink: Buffer,
+    position: Long,
+    byteCount: Long
+  ): Long
+
+  fun asStreamingSource(): BufferedSource {
+    return Okio.buffer(object : Source {
+      var position = 0L
+
+      override fun timeout() = Timeout.NONE
+
+      override fun close() {
+        position = -1
+      }
+
+      override fun read(
+        sink: Buffer,
+        byteCount: Long
+      ): Long {
+        if (position == -1L) {
+          throw IOException("Source closed")
+        }
+        val bytesRead = read(sink, position, byteCount)
+        if (bytesRead == 0L) {
+          return -1
+        }
+        position += bytesRead
+        return bytesRead
+      }
+    })
+  }
+}
diff --git a/shark-hprof/src/main/java/shark/RandomAccessSourceProvider.kt b/shark-hprof/src/main/java/shark/RandomAccessSourceProvider.kt
new file mode 100644
index 00000000..2ce2b8bb
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/RandomAccessSourceProvider.kt
@@ -0,0 +1,8 @@
+package shark
+
+/**
+ * Can open [RandomAccessSource] instances.
+ */
+fun interface RandomAccessSourceProvider {
+  fun openRandomAccessSource(): RandomAccessSource
+}
diff --git a/shark-hprof/src/main/java/shark/StreamingHprofReader.kt b/shark-hprof/src/main/java/shark/StreamingHprofReader.kt
new file mode 100644
index 00000000..4d09ede4
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/StreamingHprofReader.kt
@@ -0,0 +1,336 @@
+package shark
+
+import java.io.File
+import okio.Source
+import shark.HprofRecordTag.CLASS_DUMP
+import shark.HprofRecordTag.HEAP_DUMP
+import shark.HprofRecordTag.HEAP_DUMP_END
+import shark.HprofRecordTag.HEAP_DUMP_INFO
+import shark.HprofRecordTag.HEAP_DUMP_SEGMENT
+import shark.HprofRecordTag.INSTANCE_DUMP
+import shark.HprofRecordTag.LOAD_CLASS
+import shark.HprofRecordTag.OBJECT_ARRAY_DUMP
+import shark.HprofRecordTag.PRIMITIVE_ARRAY_DUMP
+import shark.HprofRecordTag.PRIMITIVE_ARRAY_NODATA
+import shark.HprofRecordTag.ROOT_DEBUGGER
+import shark.HprofRecordTag.ROOT_FINALIZING
+import shark.HprofRecordTag.ROOT_INTERNED_STRING
+import shark.HprofRecordTag.ROOT_JAVA_FRAME
+import shark.HprofRecordTag.ROOT_JNI_GLOBAL
+import shark.HprofRecordTag.ROOT_JNI_LOCAL
+import shark.HprofRecordTag.ROOT_JNI_MONITOR
+import shark.HprofRecordTag.ROOT_MONITOR_USED
+import shark.HprofRecordTag.ROOT_NATIVE_STACK
+import shark.HprofRecordTag.ROOT_REFERENCE_CLEANUP
+import shark.HprofRecordTag.ROOT_STICKY_CLASS
+import shark.HprofRecordTag.ROOT_THREAD_BLOCK
+import shark.HprofRecordTag.ROOT_THREAD_OBJECT
+import shark.HprofRecordTag.ROOT_UNKNOWN
+import shark.HprofRecordTag.ROOT_UNREACHABLE
+import shark.HprofRecordTag.ROOT_VM_INTERNAL
+import shark.HprofRecordTag.STACK_FRAME
+import shark.HprofRecordTag.STACK_TRACE
+import shark.HprofRecordTag.STRING_IN_UTF8
+import shark.PrimitiveType.Companion.REFERENCE_HPROF_TYPE
+import shark.PrimitiveType.INT
+import shark.StreamingHprofReader.Companion.readerFor
+
+/**
+ * Reads the entire content of a Hprof source in one fell swoop.
+ * Call [readerFor] to obtain a new instance.
+ */
+class StreamingHprofReader private constructor(
+  private val sourceProvider: StreamingSourceProvider,
+  private val header: HprofHeader
+) {
+
+  /**
+   * Obtains a new source to read all hprof records from and calls [listener] back for each record
+   * that matches one of the provided [recordTags].
+   *
+   * @return the number of bytes read from the source
+   */
+  @Suppress("ComplexMethod", "LongMethod", "NestedBlockDepth")
+  fun readRecords(
+    recordTags: Set<HprofRecordTag>,
+    listener: OnHprofRecordTagListener
+  ): Long {
+    return sourceProvider.openStreamingSource().use { source ->
+      val reader = HprofRecordReader(header, source)
+      reader.skip(header.recordsPosition)
+
+      // Local ref optimizations
+      val intByteSize = INT.byteSize
+      val identifierByteSize = reader.sizeOf(REFERENCE_HPROF_TYPE)
+
+      while (!source.exhausted()) {
+        // type of the record
+        val tag = reader.readUnsignedByte()
+
+        // number of microseconds since the time stamp in the header
+        reader.skip(intByteSize)
+
+        // number of bytes that follow and belong to this record
+        val length = reader.readUnsignedInt()
+
+        when (tag) {
+          STRING_IN_UTF8.tag -> {
+            if (STRING_IN_UTF8 in recordTags) {
+              listener.onHprofRecord(STRING_IN_UTF8, length, reader)
+            } else {
+              reader.skip(length)
+            }
+          }
+          LOAD_CLASS.tag -> {
+            if (LOAD_CLASS in recordTags) {
+              listener.onHprofRecord(LOAD_CLASS, length, reader)
+            } else {
+              reader.skip(length)
+            }
+          }
+          STACK_FRAME.tag -> {
+            if (STACK_FRAME in recordTags) {
+              listener.onHprofRecord(STACK_FRAME, length, reader)
+            } else {
+              reader.skip(length)
+            }
+          }
+          STACK_TRACE.tag -> {
+            if (STACK_TRACE in recordTags) {
+              listener.onHprofRecord(STACK_TRACE, length, reader)
+            } else {
+              reader.skip(length)
+            }
+          }
+          HEAP_DUMP.tag, HEAP_DUMP_SEGMENT.tag -> {
+            val heapDumpStart = reader.bytesRead
+            var previousTag = 0
+            var previousTagPosition = 0L
+            while (reader.bytesRead - heapDumpStart < length) {
+              val heapDumpTagPosition = reader.bytesRead
+              val heapDumpTag = reader.readUnsignedByte()
+              when (heapDumpTag) {
+                ROOT_UNKNOWN.tag -> {
+                  if (ROOT_UNKNOWN in recordTags) {
+                    listener.onHprofRecord(ROOT_UNKNOWN, -1, reader)
+                  } else {
+                    reader.skip(identifierByteSize)
+                  }
+                }
+                ROOT_JNI_GLOBAL.tag -> {
+                  if (ROOT_JNI_GLOBAL in recordTags) {
+                    listener.onHprofRecord(ROOT_JNI_GLOBAL, -1, reader)
+                  } else {
+                    reader.skip(identifierByteSize + identifierByteSize)
+                  }
+                }
+                ROOT_JNI_LOCAL.tag -> {
+                  if (ROOT_JNI_LOCAL in recordTags) {
+                    listener.onHprofRecord(ROOT_JNI_LOCAL, -1, reader)
+                  } else {
+                    reader.skip(identifierByteSize + intByteSize + intByteSize)
+                  }
+                }
+
+                ROOT_JAVA_FRAME.tag -> {
+                  if (ROOT_JAVA_FRAME in recordTags) {
+                    listener.onHprofRecord(ROOT_JAVA_FRAME, -1, reader)
+                  } else {
+                    reader.skip(identifierByteSize + intByteSize + intByteSize)
+                  }
+                }
+
+                ROOT_NATIVE_STACK.tag -> {
+                  if (ROOT_NATIVE_STACK in recordTags) {
+                    listener.onHprofRecord(ROOT_NATIVE_STACK, -1, reader)
+                  } else {
+                    reader.skip(identifierByteSize + intByteSize)
+                  }
+                }
+
+                ROOT_STICKY_CLASS.tag -> {
+                  if (ROOT_STICKY_CLASS in recordTags) {
+                    listener.onHprofRecord(ROOT_STICKY_CLASS, -1, reader)
+                  } else {
+                    reader.skip(identifierByteSize)
+                  }
+                }
+                ROOT_THREAD_BLOCK.tag -> {
+                  if (ROOT_THREAD_BLOCK in recordTags) {
+                    listener.onHprofRecord(ROOT_THREAD_BLOCK, -1, reader)
+                  } else {
+                    reader.skip(identifierByteSize + intByteSize)
+                  }
+                }
+
+                ROOT_MONITOR_USED.tag -> {
+                  if (ROOT_MONITOR_USED in recordTags) {
+                    listener.onHprofRecord(ROOT_MONITOR_USED, -1, reader)
+                  } else {
+                    reader.skip(identifierByteSize)
+                  }
+                }
+
+                ROOT_THREAD_OBJECT.tag -> {
+                  if (ROOT_THREAD_OBJECT in recordTags) {
+                    listener.onHprofRecord(ROOT_THREAD_OBJECT, -1, reader)
+                  } else {
+                    reader.skip(identifierByteSize + intByteSize + intByteSize)
+                  }
+                }
+
+                ROOT_INTERNED_STRING.tag -> {
+                  if (ROOT_INTERNED_STRING in recordTags) {
+                    listener.onHprofRecord(ROOT_INTERNED_STRING, -1, reader)
+                  } else {
+                    reader.skip(identifierByteSize)
+                  }
+                }
+
+                ROOT_FINALIZING.tag -> {
+                  if (ROOT_FINALIZING in recordTags) {
+                    listener.onHprofRecord(ROOT_FINALIZING, -1, reader)
+                  } else {
+                    reader.skip(identifierByteSize)
+                  }
+                }
+
+                ROOT_DEBUGGER.tag -> {
+                  if (ROOT_DEBUGGER in recordTags) {
+                    listener.onHprofRecord(ROOT_DEBUGGER, -1, reader)
+                  } else {
+                    reader.skip(identifierByteSize)
+                  }
+                }
+
+                ROOT_REFERENCE_CLEANUP.tag -> {
+                  if (ROOT_REFERENCE_CLEANUP in recordTags) {
+                    listener.onHprofRecord(ROOT_REFERENCE_CLEANUP, -1, reader)
+                  } else {
+                    reader.skip(identifierByteSize)
+                  }
+                }
+
+                ROOT_VM_INTERNAL.tag -> {
+                  if (ROOT_VM_INTERNAL in recordTags) {
+                    listener.onHprofRecord(ROOT_VM_INTERNAL, -1, reader)
+                  } else {
+                    reader.skip(identifierByteSize)
+                  }
+                }
+
+                ROOT_JNI_MONITOR.tag -> {
+                  if (ROOT_JNI_MONITOR in recordTags) {
+                    listener.onHprofRecord(ROOT_JNI_MONITOR, -1, reader)
+                  } else {
+                    reader.skip(identifierByteSize + intByteSize + intByteSize)
+                  }
+                }
+
+                ROOT_UNREACHABLE.tag -> {
+                  if (ROOT_UNREACHABLE in recordTags) {
+                    listener.onHprofRecord(ROOT_UNREACHABLE, -1, reader)
+                  } else {
+                    reader.skip(identifierByteSize)
+                  }
+                }
+                CLASS_DUMP.tag -> {
+                  if (CLASS_DUMP in recordTags) {
+                    listener.onHprofRecord(CLASS_DUMP, -1, reader)
+                  } else {
+                    reader.skipClassDumpRecord()
+                  }
+                }
+                INSTANCE_DUMP.tag -> {
+                  if (INSTANCE_DUMP in recordTags) {
+                    listener.onHprofRecord(INSTANCE_DUMP, -1, reader)
+                  } else {
+                    reader.skipInstanceDumpRecord()
+                  }
+                }
+
+                OBJECT_ARRAY_DUMP.tag -> {
+                  if (OBJECT_ARRAY_DUMP in recordTags) {
+                    listener.onHprofRecord(OBJECT_ARRAY_DUMP, -1, reader)
+                  } else {
+                    reader.skipObjectArrayDumpRecord()
+                  }
+                }
+
+                PRIMITIVE_ARRAY_DUMP.tag -> {
+                  if (PRIMITIVE_ARRAY_DUMP in recordTags) {
+                    listener.onHprofRecord(PRIMITIVE_ARRAY_DUMP, -1, reader)
+                  } else {
+                    reader.skipPrimitiveArrayDumpRecord()
+                  }
+                }
+
+                PRIMITIVE_ARRAY_NODATA.tag -> {
+                  throw UnsupportedOperationException("$PRIMITIVE_ARRAY_NODATA cannot be parsed")
+                }
+
+                HEAP_DUMP_INFO.tag -> {
+                  if (HEAP_DUMP_INFO in recordTags) {
+                    listener.onHprofRecord(HEAP_DUMP_INFO, -1, reader)
+                  } else {
+                    reader.skipHeapDumpInfoRecord()
+                  }
+                }
+                else -> throw IllegalStateException(
+                  "Unknown tag ${
+                    "0x%02x".format(
+                      heapDumpTag
+                    )
+                  } at $heapDumpTagPosition after ${
+                    "0x%02x".format(
+                      previousTag
+                    )
+                  } at $previousTagPosition"
+                )
+              }
+              previousTag = heapDumpTag
+              previousTagPosition = heapDumpTagPosition
+            }
+          }
+          HEAP_DUMP_END.tag -> {
+            if (HEAP_DUMP_END in recordTags) {
+              listener.onHprofRecord(HEAP_DUMP_END, length, reader)
+            }
+          }
+          else -> {
+            reader.skip(length)
+          }
+        }
+      }
+      reader.bytesRead
+    }
+  }
+
+  companion object {
+
+    /**
+     * Creates a [StreamingHprofReader] for the provided [hprofFile]. [hprofHeader] will be read from
+     * [hprofFile] unless you provide it.
+     */
+    fun readerFor(
+      hprofFile: File,
+      hprofHeader: HprofHeader = HprofHeader.parseHeaderOf(hprofFile)
+    ): StreamingHprofReader {
+      val sourceProvider = FileSourceProvider(hprofFile)
+      return readerFor(sourceProvider, hprofHeader)
+    }
+
+    /**
+     * Creates a [StreamingHprofReader] that will call [StreamingSourceProvider.openStreamingSource]
+     * on every [readRecords] to obtain a [Source] to read the hprof data from. Before reading the
+     * hprof records, [StreamingHprofReader] will skip [HprofHeader.recordsPosition] bytes.
+     */
+    fun readerFor(
+      hprofSourceProvider: StreamingSourceProvider,
+      hprofHeader: HprofHeader = hprofSourceProvider.openStreamingSource()
+        .use { HprofHeader.parseHeaderOf(it) }
+    ): StreamingHprofReader {
+      return StreamingHprofReader(hprofSourceProvider, hprofHeader)
+    }
+  }
+}
diff --git a/shark-hprof/src/main/java/shark/StreamingRecordReaderAdapter.kt b/shark-hprof/src/main/java/shark/StreamingRecordReaderAdapter.kt
new file mode 100644
index 00000000..d2bfa21e
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/StreamingRecordReaderAdapter.kt
@@ -0,0 +1,266 @@
+package shark
+
+import shark.HprofRecord.HeapDumpEndRecord
+import shark.HprofRecord.HeapDumpRecord
+import shark.HprofRecord.HeapDumpRecord.GcRootRecord
+import shark.HprofRecord.HeapDumpRecord.HeapDumpInfoRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StackFrameRecord
+import shark.HprofRecord.StackTraceRecord
+import shark.HprofRecord.StringRecord
+import shark.HprofRecordTag.CLASS_DUMP
+import shark.HprofRecordTag.HEAP_DUMP_END
+import shark.HprofRecordTag.HEAP_DUMP_INFO
+import shark.HprofRecordTag.INSTANCE_DUMP
+import shark.HprofRecordTag.LOAD_CLASS
+import shark.HprofRecordTag.OBJECT_ARRAY_DUMP
+import shark.HprofRecordTag.PRIMITIVE_ARRAY_DUMP
+import shark.HprofRecordTag.ROOT_DEBUGGER
+import shark.HprofRecordTag.ROOT_FINALIZING
+import shark.HprofRecordTag.ROOT_INTERNED_STRING
+import shark.HprofRecordTag.ROOT_JAVA_FRAME
+import shark.HprofRecordTag.ROOT_JNI_GLOBAL
+import shark.HprofRecordTag.ROOT_JNI_LOCAL
+import shark.HprofRecordTag.ROOT_JNI_MONITOR
+import shark.HprofRecordTag.ROOT_MONITOR_USED
+import shark.HprofRecordTag.ROOT_NATIVE_STACK
+import shark.HprofRecordTag.ROOT_REFERENCE_CLEANUP
+import shark.HprofRecordTag.ROOT_STICKY_CLASS
+import shark.HprofRecordTag.ROOT_THREAD_BLOCK
+import shark.HprofRecordTag.ROOT_THREAD_OBJECT
+import shark.HprofRecordTag.ROOT_UNKNOWN
+import shark.HprofRecordTag.ROOT_UNREACHABLE
+import shark.HprofRecordTag.ROOT_VM_INTERNAL
+import shark.HprofRecordTag.STACK_FRAME
+import shark.HprofRecordTag.STACK_TRACE
+import shark.HprofRecordTag.STRING_IN_UTF8
+import java.util.EnumSet
+import kotlin.reflect.KClass
+
+/**
+ * Wraps a [StreamingHprofReader] to provide a higher level API that streams [HprofRecord]
+ * instances.
+ */
+class StreamingRecordReaderAdapter(private val streamingHprofReader: StreamingHprofReader) {
+
+  /**
+   * Obtains a new source to read all hprof records from and calls [listener] back for each record
+   * that matches one of the provided [recordTypes].
+   *
+   * @return the number of bytes read from the source
+   */
+  @Suppress("ComplexMethod", "LongMethod", "NestedBlockDepth")
+  fun readRecords(
+    recordTypes: Set<KClass<out HprofRecord>>,
+    listener: OnHprofRecordListener
+  ): Long {
+    val recordTags = recordTypes.asHprofTags()
+    return streamingHprofReader.readRecords(
+      recordTags
+    ) { tag, length, reader ->
+      when (tag) {
+        STRING_IN_UTF8 -> {
+          val recordPosition = reader.bytesRead
+          val record = reader.readStringRecord(length)
+          listener.onHprofRecord(recordPosition, record)
+        }
+        LOAD_CLASS -> {
+          val recordPosition = reader.bytesRead
+          val record = reader.readLoadClassRecord()
+          listener.onHprofRecord(recordPosition, record)
+        }
+        STACK_FRAME -> {
+          val recordPosition = reader.bytesRead
+          val record = reader.readStackFrameRecord()
+          listener.onHprofRecord(recordPosition, record)
+        }
+        STACK_TRACE -> {
+          val recordPosition = reader.bytesRead
+          val record = reader.readStackTraceRecord()
+          listener.onHprofRecord(recordPosition, record)
+        }
+        ROOT_UNKNOWN -> {
+          val recordPosition = reader.bytesRead
+          val record = reader.readUnknownGcRootRecord()
+          listener.onHprofRecord(recordPosition, GcRootRecord(record))
+        }
+        ROOT_JNI_GLOBAL -> {
+          val recordPosition = reader.bytesRead
+          val gcRootRecord = reader.readJniGlobalGcRootRecord()
+          listener.onHprofRecord(recordPosition, GcRootRecord(gcRootRecord))
+        }
+        ROOT_JNI_LOCAL -> {
+          val recordPosition = reader.bytesRead
+          val gcRootRecord = reader.readJniLocalGcRootRecord()
+          listener.onHprofRecord(recordPosition, GcRootRecord(gcRootRecord))
+        }
+
+        ROOT_JAVA_FRAME -> {
+          val recordPosition = reader.bytesRead
+          val gcRootRecord = reader.readJavaFrameGcRootRecord()
+          listener.onHprofRecord(recordPosition, GcRootRecord(gcRootRecord))
+        }
+
+        ROOT_NATIVE_STACK -> {
+          val recordPosition = reader.bytesRead
+          val gcRootRecord = reader.readNativeStackGcRootRecord()
+          listener.onHprofRecord(recordPosition, GcRootRecord(gcRootRecord))
+        }
+
+        ROOT_STICKY_CLASS -> {
+          val recordPosition = reader.bytesRead
+          val gcRootRecord = reader.readStickyClassGcRootRecord()
+          listener.onHprofRecord(recordPosition, GcRootRecord(gcRootRecord))
+        }
+
+        ROOT_THREAD_BLOCK -> {
+          val recordPosition = reader.bytesRead
+          val gcRootRecord = reader.readThreadBlockGcRootRecord()
+          listener.onHprofRecord(recordPosition, GcRootRecord(gcRootRecord))
+        }
+
+        ROOT_MONITOR_USED -> {
+          val recordPosition = reader.bytesRead
+          val gcRootRecord = reader.readMonitorUsedGcRootRecord()
+          listener.onHprofRecord(recordPosition, GcRootRecord(gcRootRecord))
+        }
+
+        ROOT_THREAD_OBJECT -> {
+          val recordPosition = reader.bytesRead
+          val gcRootRecord = reader.readThreadObjectGcRootRecord()
+          listener.onHprofRecord(recordPosition, GcRootRecord(gcRootRecord))
+        }
+
+        ROOT_INTERNED_STRING -> {
+          val recordPosition = reader.bytesRead
+          val gcRootRecord = reader.readInternedStringGcRootRecord()
+          listener.onHprofRecord(recordPosition, GcRootRecord(gcRootRecord))
+        }
+
+        ROOT_FINALIZING -> {
+          val recordPosition = reader.bytesRead
+          val gcRootRecord = reader.readFinalizingGcRootRecord()
+          listener.onHprofRecord(recordPosition, GcRootRecord(gcRootRecord))
+        }
+
+        ROOT_DEBUGGER -> {
+          val recordPosition = reader.bytesRead
+          val gcRootRecord = reader.readDebuggerGcRootRecord()
+          listener.onHprofRecord(recordPosition, GcRootRecord(gcRootRecord))
+        }
+
+        ROOT_REFERENCE_CLEANUP -> {
+          val recordPosition = reader.bytesRead
+          val gcRootRecord = reader.readReferenceCleanupGcRootRecord()
+          listener.onHprofRecord(recordPosition, GcRootRecord(gcRootRecord))
+        }
+
+        ROOT_VM_INTERNAL -> {
+          val recordPosition = reader.bytesRead
+          val gcRootRecord = reader.readVmInternalGcRootRecord()
+          listener.onHprofRecord(recordPosition, GcRootRecord(gcRootRecord))
+        }
+
+        ROOT_JNI_MONITOR -> {
+          val recordPosition = reader.bytesRead
+          val gcRootRecord = reader.readJniMonitorGcRootRecord()
+          listener.onHprofRecord(recordPosition, GcRootRecord(gcRootRecord))
+        }
+
+        ROOT_UNREACHABLE -> {
+          val recordPosition = reader.bytesRead
+          val gcRootRecord = reader.readUnreachableGcRootRecord()
+          listener.onHprofRecord(recordPosition, GcRootRecord(gcRootRecord))
+        }
+        CLASS_DUMP -> {
+          val recordPosition = reader.bytesRead
+          val record = reader.readClassDumpRecord()
+          listener.onHprofRecord(recordPosition, record)
+        }
+        INSTANCE_DUMP -> {
+          val recordPosition = reader.bytesRead
+          val record = reader.readInstanceDumpRecord()
+          listener.onHprofRecord(recordPosition, record)
+        }
+
+        OBJECT_ARRAY_DUMP -> {
+          val recordPosition = reader.bytesRead
+          val arrayRecord = reader.readObjectArrayDumpRecord()
+          listener.onHprofRecord(recordPosition, arrayRecord)
+        }
+
+        PRIMITIVE_ARRAY_DUMP -> {
+          val recordPosition = reader.bytesRead
+          val record = reader.readPrimitiveArrayDumpRecord()
+          listener.onHprofRecord(recordPosition, record)
+        }
+
+        HEAP_DUMP_INFO -> {
+          val recordPosition = reader.bytesRead
+          val record = reader.readHeapDumpInfoRecord()
+          listener.onHprofRecord(recordPosition, record)
+        }
+        HEAP_DUMP_END -> {
+          val recordPosition = reader.bytesRead
+          val record = HeapDumpEndRecord
+          listener.onHprofRecord(recordPosition, record)
+        }
+        else -> error("Unexpected heap dump tag $tag at position ${reader.bytesRead}")
+      }
+    }
+  }
+
+  companion object {
+    fun StreamingHprofReader.asStreamingRecordReader() = StreamingRecordReaderAdapter(this)
+
+    fun Set<KClass<out HprofRecord>>.asHprofTags(): EnumSet<HprofRecordTag> {
+      val recordTypes = this
+      return if (HprofRecord::class in recordTypes) {
+        EnumSet.allOf(HprofRecordTag::class.java)
+      } else {
+        EnumSet.noneOf(HprofRecordTag::class.java).apply {
+          if (StringRecord::class in recordTypes) {
+            add(STRING_IN_UTF8)
+          }
+          if (LoadClassRecord::class in recordTypes) {
+            add(LOAD_CLASS)
+          }
+          if (HeapDumpEndRecord::class in recordTypes) {
+            add(HEAP_DUMP_END)
+          }
+          if (StackFrameRecord::class in recordTypes) {
+            add(STACK_FRAME)
+          }
+          if (StackTraceRecord::class in recordTypes) {
+            add(STACK_TRACE)
+          }
+          if (HeapDumpInfoRecord::class in recordTypes) {
+            add(HEAP_DUMP_INFO)
+          }
+          val readAllHeapDumpRecords = HeapDumpRecord::class in recordTypes
+          if (readAllHeapDumpRecords || GcRootRecord::class in recordTypes) {
+            addAll(HprofRecordTag.rootTags)
+          }
+          val readAllObjectRecords = readAllHeapDumpRecords || ObjectRecord::class in recordTypes
+          if (readAllObjectRecords || ClassDumpRecord::class in recordTypes) {
+            add(CLASS_DUMP)
+          }
+          if (readAllObjectRecords || InstanceDumpRecord::class in recordTypes) {
+            add(INSTANCE_DUMP)
+          }
+          if (readAllObjectRecords || ObjectArrayDumpRecord::class in recordTypes) {
+            add(OBJECT_ARRAY_DUMP)
+          }
+          if (readAllObjectRecords || PrimitiveArrayDumpRecord::class in recordTypes) {
+            add(PRIMITIVE_ARRAY_DUMP)
+          }
+        }
+      }
+    }
+  }
+}
diff --git a/shark-hprof/src/main/java/shark/StreamingSourceProvider.kt b/shark-hprof/src/main/java/shark/StreamingSourceProvider.kt
new file mode 100644
index 00000000..0648140c
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/StreamingSourceProvider.kt
@@ -0,0 +1,11 @@
+package shark
+
+import okio.BufferedSource
+import okio.Source
+
+/**
+ * Can open [Source] instances.
+ */
+fun interface StreamingSourceProvider {
+  fun openStreamingSource(): BufferedSource
+}
diff --git a/shark-hprof/src/main/java/shark/ThrowingCancelableFileSourceProvider.kt b/shark-hprof/src/main/java/shark/ThrowingCancelableFileSourceProvider.kt
new file mode 100644
index 00000000..3f40c68a
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/ThrowingCancelableFileSourceProvider.kt
@@ -0,0 +1,53 @@
+package shark
+
+import java.io.File
+import java.io.IOException
+import okio.Buffer
+import okio.BufferedSource
+import okio.Okio
+import okio.Source
+
+/**
+ * A [DualSourceProvider] that invokes [throwIfCanceled] before every read, allowing
+ * cancellation of IO based work built on top by throwing an exception.
+ */
+class ThrowingCancelableFileSourceProvider(
+  private val file: File,
+  private val throwIfCanceled: Runnable
+) : DualSourceProvider {
+
+  override fun openStreamingSource(): BufferedSource {
+    val realSource = Okio.source(file.inputStream())
+    return Okio.buffer(object : Source by realSource {
+      override fun read(
+        sink: Buffer,
+        byteCount: Long
+      ): Long {
+        throwIfCanceled.run()
+        return realSource.read(sink, byteCount)
+      }
+    })
+  }
+
+  override fun openRandomAccessSource(): RandomAccessSource {
+    val channel = file.inputStream().channel
+    return object : RandomAccessSource {
+      override fun read(
+        sink: Buffer,
+        position: Long,
+        byteCount: Long
+      ): Long {
+        throwIfCanceled.run()
+        return channel.transferTo(position, byteCount, sink)
+      }
+
+      override fun close() {
+        try {
+          channel.close()
+        } catch (ignored: Throwable) {
+          SharkLog.d(ignored) { "Failed to close file, ignoring" }
+        }
+      }
+    }
+  }
+}
diff --git a/shark-hprof/src/main/java/shark/ValueHolder.kt b/shark-hprof/src/main/java/shark/ValueHolder.kt
new file mode 100644
index 00000000..ed53c436
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/ValueHolder.kt
@@ -0,0 +1,27 @@
+package shark
+
+import shark.ValueHolder.ReferenceHolder
+
+/**
+ * A value in the heap dump, which can be a [ReferenceHolder] or
+ * a primitive type.
+ */
+sealed class ValueHolder {
+  data class ReferenceHolder(val value: Long) : ValueHolder() {
+    val isNull
+      get() = value == NULL_REFERENCE
+  }
+
+  data class BooleanHolder(val value: Boolean) : ValueHolder()
+  data class CharHolder(val value: Char) : ValueHolder()
+  data class FloatHolder(val value: Float) : ValueHolder()
+  data class DoubleHolder(val value: Double) : ValueHolder()
+  data class ByteHolder(val value: Byte) : ValueHolder()
+  data class ShortHolder(val value: Short) : ValueHolder()
+  data class IntHolder(val value: Int) : ValueHolder()
+  data class LongHolder(val value: Long) : ValueHolder()
+
+  companion object {
+    const val NULL_REFERENCE = 0L
+  }
+}
\ No newline at end of file
diff --git a/shark-hprof/src/test/java/shark/HprofReaderPrimitiveArrayTest.kt b/shark-hprof/src/test/java/shark/HprofReaderPrimitiveArrayTest.kt
new file mode 100644
index 00000000..93743583
--- /dev/null
+++ b/shark-hprof/src/test/java/shark/HprofReaderPrimitiveArrayTest.kt
@@ -0,0 +1,47 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Rule
+import org.junit.Test
+import kotlin.text.Charsets.UTF_8
+
+class HprofReaderPrimitiveArrayTest {
+
+  @get:Rule
+  var heapDumpRule = HeapDumpRule()
+
+  @Test
+  fun skips_primitive_arrays_correctly() {
+    val heapDump = heapDumpRule.dumpHeap()
+
+    Hprof.open(heapDump).use { hprof ->
+      hprof.reader.readHprofRecords(
+        emptySet()
+      ) // skip everything including primitive arrays
+      { _, _ -> }
+    }
+  }
+
+  @Test
+  fun reads_primitive_arrays_correctly() {
+    val byteArray = ("Sharks also have a sensory organ called the \"ampullae of Lorenzini\" " +
+      "which they use to \"feel\" the electrical field coming from its prey.")
+      .toByteArray(UTF_8)
+
+    val heapDump = heapDumpRule.dumpHeap()
+
+    var myByteArrayIsInHeapDump = false
+    Hprof.open(heapDump).use { hprof ->
+      hprof.reader.readHprofRecords(
+        setOf(HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord::class)
+      ) { _, record ->
+        if (record is HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump) {
+          if (byteArray.contentEquals(record.array)) {
+            myByteArrayIsInHeapDump = true
+          }
+        }
+      }
+    }
+    assertThat(myByteArrayIsInHeapDump).isTrue()
+  }
+}
diff --git a/shark-hprof/src/test/java/shark/ProguardMappingTest.kt b/shark-hprof/src/test/java/shark/ProguardMappingTest.kt
new file mode 100644
index 00000000..dd47bf67
--- /dev/null
+++ b/shark-hprof/src/test/java/shark/ProguardMappingTest.kt
@@ -0,0 +1,44 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+
+class ProguardMappingTest {
+
+  @Test
+  fun readAndParseMappingFile() {
+    val proguardMappingText = """
+            # comment
+            com.test.ClearClassName1 -> com.test.ObfuscatedClassName1:
+                com.test.FieldType1 clearFieldName1 -> obfuscatedFieldName1
+            com.test.ClearClassName2 -> com.test.ObfuscatedClassName2:
+                com.test.FieldType2 clearFieldName2 -> obfuscatedFieldName2
+        """.trimIndent()
+
+    val proguardMapping =
+      ProguardMappingReader(proguardMappingText.byteInputStream(Charsets.UTF_8))
+        .readProguardMapping()
+
+    assertThat(
+      proguardMapping.deobfuscateClassName("com.test.ObfuscatedClassName1")
+    ).isEqualTo("com.test.ClearClassName1")
+
+    assertThat(
+      proguardMapping.deobfuscateFieldName(
+        "com.test.ObfuscatedClassName1",
+        "obfuscatedFieldName1"
+      )
+    ).isEqualTo("clearFieldName1")
+
+    assertThat(
+      proguardMapping.deobfuscateClassName("com.test.ObfuscatedClassName2")
+    ).isEqualTo("com.test.ClearClassName2")
+
+    assertThat(
+      proguardMapping.deobfuscateFieldName(
+        "com.test.ObfuscatedClassName2",
+        "obfuscatedFieldName2"
+      )
+    ).isEqualTo("clearFieldName2")
+  }
+}
\ No newline at end of file
diff --git a/shark-log/api/shark-log.api b/shark-log/api/shark-log.api
new file mode 100644
index 00000000..b2296272
--- /dev/null
+++ b/shark-log/api/shark-log.api
@@ -0,0 +1,13 @@
+public final class shark/SharkLog {
+	public static final field INSTANCE Lshark/SharkLog;
+	public final fun d (Ljava/lang/Throwable;Lkotlin/jvm/functions/Function0;)V
+	public final fun d (Lkotlin/jvm/functions/Function0;)V
+	public final fun getLogger ()Lshark/SharkLog$Logger;
+	public final fun setLogger (Lshark/SharkLog$Logger;)V
+}
+
+public abstract interface class shark/SharkLog$Logger {
+	public abstract fun d (Ljava/lang/String;)V
+	public abstract fun d (Ljava/lang/Throwable;Ljava/lang/String;)V
+}
+
diff --git a/shark-log/build.gradle b/shark-log/build.gradle
new file mode 100644
index 00000000..8ebe0922
--- /dev/null
+++ b/shark-log/build.gradle
@@ -0,0 +1,14 @@
+plugins {
+  id("org.jetbrains.kotlin.jvm")
+  id("com.vanniktech.maven.publish")
+}
+
+sourceCompatibility = JavaVersion.VERSION_1_8
+targetCompatibility = JavaVersion.VERSION_1_8
+
+dependencies {
+  implementation libs.kotlin.stdlib
+
+  testImplementation libs.assertjCore
+  testImplementation libs.junit
+}
diff --git a/shark-log/gradle.properties b/shark-log/gradle.properties
new file mode 100644
index 00000000..319b4dfc
--- /dev/null
+++ b/shark-log/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark-log
+POM_NAME=Shark Log
+POM_PACKAGING=jar
diff --git a/shark-log/src/main/java/shark/SharkLog.kt b/shark-log/src/main/java/shark/SharkLog.kt
new file mode 100644
index 00000000..ae3c23e6
--- /dev/null
+++ b/shark-log/src/main/java/shark/SharkLog.kt
@@ -0,0 +1,49 @@
+package shark
+
+/**
+ * Central Logger for all Shark artifacts. Set [logger] to change where these logs go.
+ */
+object SharkLog {
+
+  /**
+   * @see SharkLog
+   */
+  interface Logger {
+
+    /**
+     * Logs a debug message formatted with the passed in arguments.
+     */
+    fun d(message: String)
+
+    /**
+     * Logs a [Throwable] and debug message formatted with the passed in arguments.
+     */
+    fun d(
+      throwable: Throwable,
+      message: String
+    )
+  }
+
+  @Volatile var logger: Logger? = null
+
+  /**
+   * @see Logger.d
+   */
+  inline fun d(message: () -> String) {
+    // Local variable to prevent the ref from becoming null after the null check.
+    val logger = logger ?: return
+    logger.d(message.invoke())
+  }
+
+  /**
+   * @see Logger.d
+   */
+  inline fun d(
+    throwable: Throwable,
+    message: () -> String
+  ) {
+    // Local variable to prevent the ref from becoming null after the null check.
+    val logger = logger ?: return
+    logger.d(throwable, message.invoke())
+  }
+}
diff --git a/shark-log/src/test/java/shark/SharkLogTest.kt b/shark-log/src/test/java/shark/SharkLogTest.kt
new file mode 100644
index 00000000..97b0f474
--- /dev/null
+++ b/shark-log/src/test/java/shark/SharkLogTest.kt
@@ -0,0 +1,48 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.SharkLog.Logger
+import java.io.ByteArrayOutputStream
+import java.io.PrintStream
+
+class SharkLogTest {
+
+  private class StreamLogger(private val stream: PrintStream) : Logger {
+    override fun d(message: String) = stream.print(message)
+    override fun d(
+      throwable: Throwable,
+      message: String
+    ) = stream.print("$message ${throwable.message}")
+  }
+
+  @Test fun `logging works when logger is set`() {
+    val outputStream = ByteArrayOutputStream()
+
+    SharkLog.logger = StreamLogger(PrintStream(outputStream))
+
+    // Test debug logging
+    SharkLog.d { "Test debug" }
+    assertThat(outputStream.toString()).isEqualTo("Test debug")
+  }
+
+  @Test fun `logging with exception works when logger is set`() {
+    val outputStream = ByteArrayOutputStream()
+
+    SharkLog.logger = StreamLogger(PrintStream(outputStream))
+
+    // Test error logging
+    SharkLog.d(Exception("Test exception")) { "Test error" }
+    assertThat(outputStream.toString()).isEqualTo("Test error Test exception")
+  }
+
+  @Test fun `logging is no-op without logger and string is ignored`() {
+    SharkLog.logger = null
+
+    // Logging message will throw an exception when attempting to use it
+    // But since it's in lambda string will not be accessed
+    SharkLog.d { "".substring(1) }
+
+    SharkLog.d(Exception("Test exception")) { "".substring(1) }
+  }
+}
\ No newline at end of file
diff --git a/shark-test/build.gradle b/shark-test/build.gradle
new file mode 100644
index 00000000..5a46a6c6
--- /dev/null
+++ b/shark-test/build.gradle
@@ -0,0 +1,13 @@
+plugins {
+  id("org.jetbrains.kotlin.jvm")
+}
+
+sourceCompatibility = JavaVersion.VERSION_1_8
+targetCompatibility = JavaVersion.VERSION_1_8
+
+dependencies {
+    implementation libs.kotlin.stdlib
+    implementation libs.assertjCore
+    implementation libs.junit
+}
+
diff --git a/shark-test/src/main/kotlin/shark/HeapDumpRule.kt b/shark-test/src/main/kotlin/shark/HeapDumpRule.kt
new file mode 100644
index 00000000..7fc2875d
--- /dev/null
+++ b/shark-test/src/main/kotlin/shark/HeapDumpRule.kt
@@ -0,0 +1,27 @@
+package shark
+
+import org.junit.rules.ExternalResource
+import org.junit.rules.TemporaryFolder
+import java.io.File
+import java.io.IOException
+import java.util.UUID
+
+class HeapDumpRule : ExternalResource() {
+  private val temporaryFolder = TemporaryFolder()
+
+  @Throws(Throwable::class)
+  override fun before() {
+    temporaryFolder.create()
+  }
+
+  override fun after() {
+    temporaryFolder.delete()
+  }
+
+  @Throws(IOException::class)
+  fun dumpHeap(): File {
+    val hprof = File(temporaryFolder.root, "heapDump" + UUID.randomUUID() + ".hprof")
+    JvmTestHeapDumper.dumpHeap(hprof.absolutePath)
+    return hprof
+  }
+}
diff --git a/shark-test/src/main/kotlin/shark/JvmTestHeapDumper.kt b/shark-test/src/main/kotlin/shark/JvmTestHeapDumper.kt
new file mode 100644
index 00000000..54d72519
--- /dev/null
+++ b/shark-test/src/main/kotlin/shark/JvmTestHeapDumper.kt
@@ -0,0 +1,22 @@
+package shark
+
+import com.sun.management.HotSpotDiagnosticMXBean
+import java.lang.management.ManagementFactory
+
+object JvmTestHeapDumper {
+  private val hotspotMBean: HotSpotDiagnosticMXBean by lazy {
+    val mBeanServer = ManagementFactory.getPlatformMBeanServer()
+    ManagementFactory.newPlatformMXBeanProxy(
+      mBeanServer,
+      "com.sun.management:type=HotSpotDiagnostic",
+      HotSpotDiagnosticMXBean::class.java
+    )
+  }
+
+  fun dumpHeap(
+    fileName: String
+  ) {
+    val live = true
+    hotspotMBean.dumpHeap(fileName, live)
+  }
+}
\ No newline at end of file
diff --git a/shark/api/shark.api b/shark/api/shark.api
new file mode 100644
index 00000000..fc112713
--- /dev/null
+++ b/shark/api/shark.api
@@ -0,0 +1,469 @@
+public final class shark/AppSingletonInspector : shark/ObjectInspector {
+	public fun <init> ([Ljava/lang/String;)V
+	public fun inspect (Lshark/ObjectReporter;)V
+}
+
+public final class shark/ApplicationLeak : shark/Leak {
+	public static final field Companion Lshark/ApplicationLeak$Companion;
+	public fun <init> (Ljava/util/List;)V
+	public final fun component1 ()Ljava/util/List;
+	public final fun copy (Ljava/util/List;)Lshark/ApplicationLeak;
+	public static synthetic fun copy$default (Lshark/ApplicationLeak;Ljava/util/List;ILjava/lang/Object;)Lshark/ApplicationLeak;
+	public fun equals (Ljava/lang/Object;)Z
+	public fun getLeakTraces ()Ljava/util/List;
+	public fun getShortDescription ()Ljava/lang/String;
+	public fun getSignature ()Ljava/lang/String;
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/ApplicationLeak$Companion {
+}
+
+public final class shark/FilteringLeakingObjectFinder : shark/LeakingObjectFinder {
+	public fun <init> (Ljava/util/List;)V
+	public fun findLeakingObjectIds (Lshark/HeapGraph;)Ljava/util/Set;
+}
+
+public abstract interface class shark/FilteringLeakingObjectFinder$LeakingObjectFilter {
+	public abstract fun isLeakingObject (Lshark/HeapObject;)Z
+}
+
+public abstract class shark/HeapAnalysis : java/io/Serializable {
+	public static final field Companion Lshark/HeapAnalysis$Companion;
+	public static final field DUMP_DURATION_UNKNOWN J
+	public abstract fun getAnalysisDurationMillis ()J
+	public abstract fun getCreatedAtTimeMillis ()J
+	public abstract fun getDumpDurationMillis ()J
+	public abstract fun getHeapDumpFile ()Ljava/io/File;
+}
+
+public final class shark/HeapAnalysis$Companion {
+}
+
+public final class shark/HeapAnalysisException : java/lang/RuntimeException {
+	public static final field Companion Lshark/HeapAnalysisException$Companion;
+	public fun <init> (Ljava/lang/Throwable;)V
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/HeapAnalysisException$Companion {
+}
+
+public final class shark/HeapAnalysisFailure : shark/HeapAnalysis {
+	public static final field Companion Lshark/HeapAnalysisFailure$Companion;
+	public fun <init> (Ljava/io/File;JJJLshark/HeapAnalysisException;)V
+	public synthetic fun <init> (Ljava/io/File;JJJLshark/HeapAnalysisException;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun component1 ()Ljava/io/File;
+	public final fun component2 ()J
+	public final fun component3 ()J
+	public final fun component4 ()J
+	public final fun component5 ()Lshark/HeapAnalysisException;
+	public final fun copy (Ljava/io/File;JJJLshark/HeapAnalysisException;)Lshark/HeapAnalysisFailure;
+	public static synthetic fun copy$default (Lshark/HeapAnalysisFailure;Ljava/io/File;JJJLshark/HeapAnalysisException;ILjava/lang/Object;)Lshark/HeapAnalysisFailure;
+	public fun equals (Ljava/lang/Object;)Z
+	public fun getAnalysisDurationMillis ()J
+	public fun getCreatedAtTimeMillis ()J
+	public fun getDumpDurationMillis ()J
+	public final fun getException ()Lshark/HeapAnalysisException;
+	public fun getHeapDumpFile ()Ljava/io/File;
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/HeapAnalysisFailure$Companion {
+}
+
+public final class shark/HeapAnalysisSuccess : shark/HeapAnalysis {
+	public static final field Companion Lshark/HeapAnalysisSuccess$Companion;
+	public fun <init> (Ljava/io/File;JJJLjava/util/Map;Ljava/util/List;Ljava/util/List;Ljava/util/List;)V
+	public synthetic fun <init> (Ljava/io/File;JJJLjava/util/Map;Ljava/util/List;Ljava/util/List;Ljava/util/List;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun component1 ()Ljava/io/File;
+	public final fun component2 ()J
+	public final fun component3 ()J
+	public final fun component4 ()J
+	public final fun component5 ()Ljava/util/Map;
+	public final fun component6 ()Ljava/util/List;
+	public final fun component7 ()Ljava/util/List;
+	public final fun component8 ()Ljava/util/List;
+	public final fun copy (Ljava/io/File;JJJLjava/util/Map;Ljava/util/List;Ljava/util/List;Ljava/util/List;)Lshark/HeapAnalysisSuccess;
+	public static synthetic fun copy$default (Lshark/HeapAnalysisSuccess;Ljava/io/File;JJJLjava/util/Map;Ljava/util/List;Ljava/util/List;Ljava/util/List;ILjava/lang/Object;)Lshark/HeapAnalysisSuccess;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getAllLeaks ()Lkotlin/sequences/Sequence;
+	public fun getAnalysisDurationMillis ()J
+	public final fun getApplicationLeaks ()Ljava/util/List;
+	public fun getCreatedAtTimeMillis ()J
+	public fun getDumpDurationMillis ()J
+	public fun getHeapDumpFile ()Ljava/io/File;
+	public final fun getLibraryLeaks ()Ljava/util/List;
+	public final fun getMetadata ()Ljava/util/Map;
+	public final fun getUnreachableObjects ()Ljava/util/List;
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/HeapAnalysisSuccess$Companion {
+}
+
+public final class shark/HeapAnalyzer {
+	public fun <init> (Lshark/OnAnalysisProgressListener;)V
+	public final fun analyze (Ljava/io/File;Lshark/HeapGraph;Lshark/LeakingObjectFinder;Ljava/util/List;ZLjava/util/List;Lshark/MetadataExtractor;)Lshark/HeapAnalysis;
+	public final fun analyze (Ljava/io/File;Lshark/LeakingObjectFinder;Ljava/util/List;ZLjava/util/List;Lshark/MetadataExtractor;Lshark/ProguardMapping;)Lshark/HeapAnalysis;
+	public static synthetic fun analyze$default (Lshark/HeapAnalyzer;Ljava/io/File;Lshark/HeapGraph;Lshark/LeakingObjectFinder;Ljava/util/List;ZLjava/util/List;Lshark/MetadataExtractor;ILjava/lang/Object;)Lshark/HeapAnalysis;
+	public static synthetic fun analyze$default (Lshark/HeapAnalyzer;Ljava/io/File;Lshark/LeakingObjectFinder;Ljava/util/List;ZLjava/util/List;Lshark/MetadataExtractor;Lshark/ProguardMapping;ILjava/lang/Object;)Lshark/HeapAnalysis;
+}
+
+public final class shark/IgnoredReferenceMatcher : shark/ReferenceMatcher {
+	public fun <init> (Lshark/ReferencePattern;)V
+	public fun getPattern ()Lshark/ReferencePattern;
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/KeyedWeakReferenceFinder : shark/LeakingObjectFinder {
+	public static final field INSTANCE Lshark/KeyedWeakReferenceFinder;
+	public fun findLeakingObjectIds (Lshark/HeapGraph;)Ljava/util/Set;
+	public final fun heapDumpUptimeMillis (Lshark/HeapGraph;)Ljava/lang/Long;
+}
+
+public abstract class shark/Leak : java/io/Serializable {
+	public static final field Companion Lshark/Leak$Companion;
+	public abstract fun getLeakTraces ()Ljava/util/List;
+	public abstract fun getShortDescription ()Ljava/lang/String;
+	public abstract fun getSignature ()Ljava/lang/String;
+	public final fun getTotalRetainedHeapByteSize ()Ljava/lang/Integer;
+	public final fun getTotalRetainedObjectCount ()Ljava/lang/Integer;
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/Leak$Companion {
+}
+
+public final class shark/LeakTrace : java/io/Serializable {
+	public static final field Companion Lshark/LeakTrace$Companion;
+	public fun <init> (Lshark/LeakTrace$GcRootType;Ljava/util/List;Lshark/LeakTraceObject;)V
+	public final fun component1 ()Lshark/LeakTrace$GcRootType;
+	public final fun component2 ()Ljava/util/List;
+	public final fun component3 ()Lshark/LeakTraceObject;
+	public final fun copy (Lshark/LeakTrace$GcRootType;Ljava/util/List;Lshark/LeakTraceObject;)Lshark/LeakTrace;
+	public static synthetic fun copy$default (Lshark/LeakTrace;Lshark/LeakTrace$GcRootType;Ljava/util/List;Lshark/LeakTraceObject;ILjava/lang/Object;)Lshark/LeakTrace;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getGcRootType ()Lshark/LeakTrace$GcRootType;
+	public final fun getLeakingObject ()Lshark/LeakTraceObject;
+	public final fun getReferencePath ()Ljava/util/List;
+	public final fun getRetainedHeapByteSize ()Ljava/lang/Integer;
+	public final fun getRetainedObjectCount ()Ljava/lang/Integer;
+	public final fun getSignature ()Ljava/lang/String;
+	public final fun getSuspectReferenceSubpath ()Lkotlin/sequences/Sequence;
+	public fun hashCode ()I
+	public final fun referencePathElementIsSuspect (I)Z
+	public final fun toSimplePathString ()Ljava/lang/String;
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/LeakTrace$Companion {
+}
+
+public final class shark/LeakTrace$GcRootType : java/lang/Enum {
+	public static final field Companion Lshark/LeakTrace$GcRootType$Companion;
+	public static final field JAVA_FRAME Lshark/LeakTrace$GcRootType;
+	public static final field JNI_GLOBAL Lshark/LeakTrace$GcRootType;
+	public static final field JNI_LOCAL Lshark/LeakTrace$GcRootType;
+	public static final field JNI_MONITOR Lshark/LeakTrace$GcRootType;
+	public static final field MONITOR_USED Lshark/LeakTrace$GcRootType;
+	public static final field NATIVE_STACK Lshark/LeakTrace$GcRootType;
+	public static final field STICKY_CLASS Lshark/LeakTrace$GcRootType;
+	public static final field THREAD_BLOCK Lshark/LeakTrace$GcRootType;
+	public static final field THREAD_OBJECT Lshark/LeakTrace$GcRootType;
+	public final fun getDescription ()Ljava/lang/String;
+	public static fun valueOf (Ljava/lang/String;)Lshark/LeakTrace$GcRootType;
+	public static fun values ()[Lshark/LeakTrace$GcRootType;
+}
+
+public final class shark/LeakTrace$GcRootType$Companion {
+	public final fun fromGcRoot (Lshark/GcRoot;)Lshark/LeakTrace$GcRootType;
+}
+
+public final class shark/LeakTraceObject : java/io/Serializable {
+	public static final field Companion Lshark/LeakTraceObject$Companion;
+	public fun <init> (Lshark/LeakTraceObject$ObjectType;Ljava/lang/String;Ljava/util/Set;Lshark/LeakTraceObject$LeakingStatus;Ljava/lang/String;Ljava/lang/Integer;Ljava/lang/Integer;)V
+	public final fun component1 ()Lshark/LeakTraceObject$ObjectType;
+	public final fun component2 ()Ljava/lang/String;
+	public final fun component3 ()Ljava/util/Set;
+	public final fun component4 ()Lshark/LeakTraceObject$LeakingStatus;
+	public final fun component5 ()Ljava/lang/String;
+	public final fun component6 ()Ljava/lang/Integer;
+	public final fun component7 ()Ljava/lang/Integer;
+	public final fun copy (Lshark/LeakTraceObject$ObjectType;Ljava/lang/String;Ljava/util/Set;Lshark/LeakTraceObject$LeakingStatus;Ljava/lang/String;Ljava/lang/Integer;Ljava/lang/Integer;)Lshark/LeakTraceObject;
+	public static synthetic fun copy$default (Lshark/LeakTraceObject;Lshark/LeakTraceObject$ObjectType;Ljava/lang/String;Ljava/util/Set;Lshark/LeakTraceObject$LeakingStatus;Ljava/lang/String;Ljava/lang/Integer;Ljava/lang/Integer;ILjava/lang/Object;)Lshark/LeakTraceObject;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getClassName ()Ljava/lang/String;
+	public final fun getClassSimpleName ()Ljava/lang/String;
+	public final fun getLabels ()Ljava/util/Set;
+	public final fun getLeakingStatus ()Lshark/LeakTraceObject$LeakingStatus;
+	public final fun getLeakingStatusReason ()Ljava/lang/String;
+	public final fun getRetainedHeapByteSize ()Ljava/lang/Integer;
+	public final fun getRetainedObjectCount ()Ljava/lang/Integer;
+	public final fun getType ()Lshark/LeakTraceObject$ObjectType;
+	public final fun getTypeName ()Ljava/lang/String;
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/LeakTraceObject$Companion {
+}
+
+public final class shark/LeakTraceObject$LeakingStatus : java/lang/Enum {
+	public static final field LEAKING Lshark/LeakTraceObject$LeakingStatus;
+	public static final field NOT_LEAKING Lshark/LeakTraceObject$LeakingStatus;
+	public static final field UNKNOWN Lshark/LeakTraceObject$LeakingStatus;
+	public static fun valueOf (Ljava/lang/String;)Lshark/LeakTraceObject$LeakingStatus;
+	public static fun values ()[Lshark/LeakTraceObject$LeakingStatus;
+}
+
+public final class shark/LeakTraceObject$ObjectType : java/lang/Enum {
+	public static final field ARRAY Lshark/LeakTraceObject$ObjectType;
+	public static final field CLASS Lshark/LeakTraceObject$ObjectType;
+	public static final field INSTANCE Lshark/LeakTraceObject$ObjectType;
+	public static fun valueOf (Ljava/lang/String;)Lshark/LeakTraceObject$ObjectType;
+	public static fun values ()[Lshark/LeakTraceObject$ObjectType;
+}
+
+public final class shark/LeakTraceReference : java/io/Serializable {
+	public static final field Companion Lshark/LeakTraceReference$Companion;
+	public fun <init> (Lshark/LeakTraceObject;Lshark/LeakTraceReference$ReferenceType;Ljava/lang/String;Ljava/lang/String;)V
+	public final fun component1 ()Lshark/LeakTraceObject;
+	public final fun component2 ()Lshark/LeakTraceReference$ReferenceType;
+	public final fun component3 ()Ljava/lang/String;
+	public final fun component4 ()Ljava/lang/String;
+	public final fun copy (Lshark/LeakTraceObject;Lshark/LeakTraceReference$ReferenceType;Ljava/lang/String;Ljava/lang/String;)Lshark/LeakTraceReference;
+	public static synthetic fun copy$default (Lshark/LeakTraceReference;Lshark/LeakTraceObject;Lshark/LeakTraceReference$ReferenceType;Ljava/lang/String;Ljava/lang/String;ILjava/lang/Object;)Lshark/LeakTraceReference;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getOriginObject ()Lshark/LeakTraceObject;
+	public final fun getOwningClassName ()Ljava/lang/String;
+	public final fun getOwningClassSimpleName ()Ljava/lang/String;
+	public final fun getReferenceDisplayName ()Ljava/lang/String;
+	public final fun getReferenceGenericName ()Ljava/lang/String;
+	public final fun getReferenceName ()Ljava/lang/String;
+	public final fun getReferenceType ()Lshark/LeakTraceReference$ReferenceType;
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/LeakTraceReference$Companion {
+}
+
+public final class shark/LeakTraceReference$ReferenceType : java/lang/Enum {
+	public static final field ARRAY_ENTRY Lshark/LeakTraceReference$ReferenceType;
+	public static final field INSTANCE_FIELD Lshark/LeakTraceReference$ReferenceType;
+	public static final field LOCAL Lshark/LeakTraceReference$ReferenceType;
+	public static final field STATIC_FIELD Lshark/LeakTraceReference$ReferenceType;
+	public static fun valueOf (Ljava/lang/String;)Lshark/LeakTraceReference$ReferenceType;
+	public static fun values ()[Lshark/LeakTraceReference$ReferenceType;
+}
+
+public abstract interface class shark/LeakingObjectFinder {
+	public static final field Companion Lshark/LeakingObjectFinder$Companion;
+	public abstract fun findLeakingObjectIds (Lshark/HeapGraph;)Ljava/util/Set;
+}
+
+public final class shark/LeakingObjectFinder$Companion {
+	public final fun invoke (Lkotlin/jvm/functions/Function1;)Lshark/LeakingObjectFinder;
+}
+
+public final class shark/LibraryLeak : shark/Leak {
+	public static final field Companion Lshark/LibraryLeak$Companion;
+	public fun <init> (Ljava/util/List;Lshark/ReferencePattern;Ljava/lang/String;)V
+	public final fun component1 ()Ljava/util/List;
+	public final fun component2 ()Lshark/ReferencePattern;
+	public final fun component3 ()Ljava/lang/String;
+	public final fun copy (Ljava/util/List;Lshark/ReferencePattern;Ljava/lang/String;)Lshark/LibraryLeak;
+	public static synthetic fun copy$default (Lshark/LibraryLeak;Ljava/util/List;Lshark/ReferencePattern;Ljava/lang/String;ILjava/lang/Object;)Lshark/LibraryLeak;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getDescription ()Ljava/lang/String;
+	public fun getLeakTraces ()Ljava/util/List;
+	public final fun getPattern ()Lshark/ReferencePattern;
+	public fun getShortDescription ()Ljava/lang/String;
+	public fun getSignature ()Ljava/lang/String;
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/LibraryLeak$Companion {
+}
+
+public final class shark/LibraryLeakReferenceMatcher : shark/ReferenceMatcher {
+	public fun <init> (Lshark/ReferencePattern;Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
+	public synthetic fun <init> (Lshark/ReferencePattern;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun component1 ()Lshark/ReferencePattern;
+	public final fun component2 ()Ljava/lang/String;
+	public final fun component3 ()Lkotlin/jvm/functions/Function1;
+	public final fun copy (Lshark/ReferencePattern;Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lshark/LibraryLeakReferenceMatcher;
+	public static synthetic fun copy$default (Lshark/LibraryLeakReferenceMatcher;Lshark/ReferencePattern;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)Lshark/LibraryLeakReferenceMatcher;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getDescription ()Ljava/lang/String;
+	public fun getPattern ()Lshark/ReferencePattern;
+	public final fun getPatternApplies ()Lkotlin/jvm/functions/Function1;
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public abstract interface class shark/MetadataExtractor {
+	public static final field Companion Lshark/MetadataExtractor$Companion;
+	public abstract fun extractMetadata (Lshark/HeapGraph;)Ljava/util/Map;
+}
+
+public final class shark/MetadataExtractor$Companion {
+	public final fun getNO_OP ()Lshark/MetadataExtractor;
+	public final fun invoke (Lkotlin/jvm/functions/Function1;)Lshark/MetadataExtractor;
+}
+
+public abstract interface class shark/ObjectInspector {
+	public static final field Companion Lshark/ObjectInspector$Companion;
+	public abstract fun inspect (Lshark/ObjectReporter;)V
+}
+
+public final class shark/ObjectInspector$Companion {
+	public final fun invoke (Lkotlin/jvm/functions/Function1;)Lshark/ObjectInspector;
+}
+
+public abstract class shark/ObjectInspectors : java/lang/Enum, shark/ObjectInspector {
+	public static final field ANONYMOUS_CLASS Lshark/ObjectInspectors;
+	public static final field CLASS Lshark/ObjectInspectors;
+	public static final field CLASSLOADER Lshark/ObjectInspectors;
+	public static final field Companion Lshark/ObjectInspectors$Companion;
+	public static final field KEYED_WEAK_REFERENCE Lshark/ObjectInspectors;
+	public static final field THREAD Lshark/ObjectInspectors;
+	public synthetic fun <init> (Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public static fun valueOf (Ljava/lang/String;)Lshark/ObjectInspectors;
+	public static fun values ()[Lshark/ObjectInspectors;
+}
+
+public final class shark/ObjectInspectors$Companion {
+	public final fun createLeakingObjectFilters (Ljava/util/Set;)Ljava/util/List;
+	public final fun getJdkDefaults ()Ljava/util/List;
+	public final fun getJdkLeakingObjectFilters ()Ljava/util/List;
+}
+
+public final class shark/ObjectReporter {
+	public fun <init> (Lshark/HeapObject;)V
+	public final fun getHeapObject ()Lshark/HeapObject;
+	public final fun getLabels ()Ljava/util/LinkedHashSet;
+	public final fun getLeakingReasons ()Ljava/util/Set;
+	public final fun getLikelyLeakingReasons ()Ljava/util/Set;
+	public final fun getNotLeakingReasons ()Ljava/util/Set;
+	public final fun whenInstanceOf (Ljava/lang/String;Lkotlin/jvm/functions/Function2;)V
+	public final fun whenInstanceOf (Lkotlin/reflect/KClass;Lkotlin/jvm/functions/Function2;)V
+}
+
+public abstract interface class shark/OnAnalysisProgressListener {
+	public static final field Companion Lshark/OnAnalysisProgressListener$Companion;
+	public abstract fun onAnalysisProgress (Lshark/OnAnalysisProgressListener$Step;)V
+}
+
+public final class shark/OnAnalysisProgressListener$Companion {
+	public final fun getNO_OP ()Lshark/OnAnalysisProgressListener;
+	public final fun invoke (Lkotlin/jvm/functions/Function1;)Lshark/OnAnalysisProgressListener;
+}
+
+public final class shark/OnAnalysisProgressListener$Step : java/lang/Enum {
+	public static final field BUILDING_LEAK_TRACES Lshark/OnAnalysisProgressListener$Step;
+	public static final field COMPUTING_NATIVE_RETAINED_SIZE Lshark/OnAnalysisProgressListener$Step;
+	public static final field COMPUTING_RETAINED_SIZE Lshark/OnAnalysisProgressListener$Step;
+	public static final field EXTRACTING_METADATA Lshark/OnAnalysisProgressListener$Step;
+	public static final field FINDING_DOMINATORS Lshark/OnAnalysisProgressListener$Step;
+	public static final field FINDING_PATHS_TO_RETAINED_OBJECTS Lshark/OnAnalysisProgressListener$Step;
+	public static final field FINDING_RETAINED_OBJECTS Lshark/OnAnalysisProgressListener$Step;
+	public static final field INSPECTING_OBJECTS Lshark/OnAnalysisProgressListener$Step;
+	public static final field PARSING_HEAP_DUMP Lshark/OnAnalysisProgressListener$Step;
+	public static final field REPORTING_HEAP_ANALYSIS Lshark/OnAnalysisProgressListener$Step;
+	public final fun getHumanReadableName ()Ljava/lang/String;
+	public static fun valueOf (Ljava/lang/String;)Lshark/OnAnalysisProgressListener$Step;
+	public static fun values ()[Lshark/OnAnalysisProgressListener$Step;
+}
+
+public abstract class shark/ReferenceMatcher {
+	public abstract fun getPattern ()Lshark/ReferencePattern;
+}
+
+public abstract class shark/ReferencePattern : java/io/Serializable {
+	public static final field Companion Lshark/ReferencePattern$Companion;
+}
+
+public final class shark/ReferencePattern$Companion {
+}
+
+public final class shark/ReferencePattern$InstanceFieldPattern : shark/ReferencePattern {
+	public static final field Companion Lshark/ReferencePattern$InstanceFieldPattern$Companion;
+	public fun <init> (Ljava/lang/String;Ljava/lang/String;)V
+	public final fun component1 ()Ljava/lang/String;
+	public final fun component2 ()Ljava/lang/String;
+	public final fun copy (Ljava/lang/String;Ljava/lang/String;)Lshark/ReferencePattern$InstanceFieldPattern;
+	public static synthetic fun copy$default (Lshark/ReferencePattern$InstanceFieldPattern;Ljava/lang/String;Ljava/lang/String;ILjava/lang/Object;)Lshark/ReferencePattern$InstanceFieldPattern;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getClassName ()Ljava/lang/String;
+	public final fun getFieldName ()Ljava/lang/String;
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/ReferencePattern$InstanceFieldPattern$Companion {
+}
+
+public final class shark/ReferencePattern$JavaLocalPattern : shark/ReferencePattern {
+	public static final field Companion Lshark/ReferencePattern$JavaLocalPattern$Companion;
+	public fun <init> (Ljava/lang/String;)V
+	public final fun component1 ()Ljava/lang/String;
+	public final fun copy (Ljava/lang/String;)Lshark/ReferencePattern$JavaLocalPattern;
+	public static synthetic fun copy$default (Lshark/ReferencePattern$JavaLocalPattern;Ljava/lang/String;ILjava/lang/Object;)Lshark/ReferencePattern$JavaLocalPattern;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getThreadName ()Ljava/lang/String;
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/ReferencePattern$JavaLocalPattern$Companion {
+}
+
+public final class shark/ReferencePattern$NativeGlobalVariablePattern : shark/ReferencePattern {
+	public static final field Companion Lshark/ReferencePattern$NativeGlobalVariablePattern$Companion;
+	public fun <init> (Ljava/lang/String;)V
+	public final fun component1 ()Ljava/lang/String;
+	public final fun copy (Ljava/lang/String;)Lshark/ReferencePattern$NativeGlobalVariablePattern;
+	public static synthetic fun copy$default (Lshark/ReferencePattern$NativeGlobalVariablePattern;Ljava/lang/String;ILjava/lang/Object;)Lshark/ReferencePattern$NativeGlobalVariablePattern;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getClassName ()Ljava/lang/String;
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/ReferencePattern$NativeGlobalVariablePattern$Companion {
+}
+
+public final class shark/ReferencePattern$StaticFieldPattern : shark/ReferencePattern {
+	public static final field Companion Lshark/ReferencePattern$StaticFieldPattern$Companion;
+	public fun <init> (Ljava/lang/String;Ljava/lang/String;)V
+	public final fun component1 ()Ljava/lang/String;
+	public final fun component2 ()Ljava/lang/String;
+	public final fun copy (Ljava/lang/String;Ljava/lang/String;)Lshark/ReferencePattern$StaticFieldPattern;
+	public static synthetic fun copy$default (Lshark/ReferencePattern$StaticFieldPattern;Ljava/lang/String;Ljava/lang/String;ILjava/lang/Object;)Lshark/ReferencePattern$StaticFieldPattern;
+	public fun equals (Ljava/lang/Object;)Z
+	public final fun getClassName ()Ljava/lang/String;
+	public final fun getFieldName ()Ljava/lang/String;
+	public fun hashCode ()I
+	public fun toString ()Ljava/lang/String;
+}
+
+public final class shark/ReferencePattern$StaticFieldPattern$Companion {
+}
+
+public final class shark/internal/InternalSharkCollectionsHelper {
+	public static final field INSTANCE Lshark/internal/InternalSharkCollectionsHelper;
+	public final fun arrayListValues (Lshark/HeapObject$HeapInstance;)Lkotlin/sequences/Sequence;
+}
+
+public final class shark/internal/ObjectDominators {
+	public fun <init> ()V
+	public final fun renderDominatorTree (Lshark/HeapGraph;Ljava/util/List;ILjava/lang/String;Z)Ljava/lang/String;
+	public static synthetic fun renderDominatorTree$default (Lshark/internal/ObjectDominators;Lshark/HeapGraph;Ljava/util/List;ILjava/lang/String;ZILjava/lang/Object;)Ljava/lang/String;
+}
+
diff --git a/shark/build.gradle b/shark/build.gradle
new file mode 100644
index 00000000..32435aaa
--- /dev/null
+++ b/shark/build.gradle
@@ -0,0 +1,20 @@
+plugins {
+  id("org.jetbrains.kotlin.jvm")
+  id("com.vanniktech.maven.publish")
+}
+
+sourceCompatibility = JavaVersion.VERSION_1_8
+targetCompatibility = JavaVersion.VERSION_1_8
+
+dependencies {
+  api projects.sharkGraph
+
+  implementation libs.kotlin.stdlib
+  implementation libs.okio2
+
+  testImplementation libs.assertjCore
+  testImplementation libs.junit
+  testImplementation libs.okio2
+  testImplementation projects.sharkTest
+  testImplementation projects.sharkHprofTest
+}
diff --git a/shark/gradle.properties b/shark/gradle.properties
new file mode 100644
index 00000000..0053d064
--- /dev/null
+++ b/shark/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark
+POM_NAME=Shark
+POM_PACKAGING=jar
diff --git a/shark/src/main/java/shark/AppSingletonInspector.kt b/shark/src/main/java/shark/AppSingletonInspector.kt
new file mode 100644
index 00000000..62c53c72
--- /dev/null
+++ b/shark/src/main/java/shark/AppSingletonInspector.kt
@@ -0,0 +1,23 @@
+package shark
+
+import shark.HeapObject.HeapInstance
+
+/**
+ * Inspector that automatically marks instances of the provided class names as not leaking
+ * because they're app wide singletons.
+ */
+class AppSingletonInspector(private vararg val singletonClasses: String) : ObjectInspector {
+  override fun inspect(
+    reporter: ObjectReporter
+  ) {
+    if (reporter.heapObject is HeapInstance) {
+      reporter.heapObject.instanceClass
+        .classHierarchy
+        .forEach { heapClass ->
+          if (heapClass.name in singletonClasses) {
+            reporter.notLeakingReasons += "${heapClass.name} is an app singleton"
+          }
+        }
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/FilteringLeakingObjectFinder.kt b/shark/src/main/java/shark/FilteringLeakingObjectFinder.kt
new file mode 100644
index 00000000..585b2f73
--- /dev/null
+++ b/shark/src/main/java/shark/FilteringLeakingObjectFinder.kt
@@ -0,0 +1,31 @@
+package shark
+
+/**
+ * Finds the objects that are leaking by scanning all objects in the heap dump
+ * and delegating the decision to a list of [FilteringLeakingObjectFinder.LeakingObjectFilter]
+ */
+class FilteringLeakingObjectFinder(private val filters: List<LeakingObjectFilter>) :
+  LeakingObjectFinder {
+
+  /**
+   * Filter to be passed to the [FilteringLeakingObjectFinder] constructor.
+   */
+  fun interface LeakingObjectFilter {
+    /**
+     * Returns whether the passed in [heapObject] is leaking. This should only return true
+     * when we're 100% sure the passed in [heapObject] should not be in memory anymore.
+     */
+    fun isLeakingObject(heapObject: HeapObject): Boolean
+  }
+
+  override fun findLeakingObjectIds(graph: HeapGraph): Set<Long> {
+    return graph.objects
+      .filter { heapObject ->
+        filters.any { filter ->
+          filter.isLeakingObject(heapObject)
+        }
+      }
+      .map { it.objectId }
+      .toSet()
+  }
+}
diff --git a/shark/src/main/java/shark/HeapAnalysis.kt b/shark/src/main/java/shark/HeapAnalysis.kt
new file mode 100644
index 00000000..af381943
--- /dev/null
+++ b/shark/src/main/java/shark/HeapAnalysis.kt
@@ -0,0 +1,302 @@
+package shark
+
+import shark.internal.createSHA1Hash
+import java.io.File
+import java.io.Serializable
+
+/**
+ * The result of an analysis performed by [HeapAnalyzer], either a [HeapAnalysisSuccess] or a
+ * [HeapAnalysisFailure]. This class is serializable however there are no guarantees of forward
+ * compatibility.
+ */
+sealed class HeapAnalysis : Serializable {
+  /**
+   * The hprof file that was analyzed.
+   */
+  abstract val heapDumpFile: File
+
+  /**
+   * The [System.currentTimeMillis] when this [HeapAnalysis] instance was created.
+   */
+  abstract val createdAtTimeMillis: Long
+
+  /**
+   * Total time spent dumping the heap.
+   */
+  abstract val dumpDurationMillis: Long
+
+  /**
+   * Total time spent analyzing the heap.
+   */
+  abstract val analysisDurationMillis: Long
+
+  companion object {
+    private const val serialVersionUID: Long = -8657286725869987172
+    const val DUMP_DURATION_UNKNOWN: Long = -1
+  }
+}
+
+/**
+ * The analysis performed by [HeapAnalyzer] did not complete successfully.
+ */
+data class HeapAnalysisFailure(
+  override val heapDumpFile: File,
+  override val createdAtTimeMillis: Long,
+  override val dumpDurationMillis: Long = DUMP_DURATION_UNKNOWN,
+  override val analysisDurationMillis: Long,
+  /**
+   * An exception wrapping the actual exception that was thrown.
+   */
+  val exception: HeapAnalysisException
+) : HeapAnalysis() {
+
+  override fun toString(): String {
+    return """====================================
+HEAP ANALYSIS FAILED
+
+You can report this failure at https://github.com/square/leakcanary/issues
+Please provide the stacktrace, metadata and the heap dump file.
+====================================
+STACKTRACE
+
+$exception====================================
+METADATA
+
+Build.VERSION.SDK_INT: ${androidSdkInt()}
+Build.MANUFACTURER: ${androidManufacturer()}
+LeakCanary version: ${leakCanaryVersion()}
+Analysis duration: $analysisDurationMillis ms
+Heap dump file path: ${heapDumpFile.absolutePath}
+Heap dump timestamp: $createdAtTimeMillis
+===================================="""
+  }
+
+  companion object {
+    private const val serialVersionUID: Long = 8483254400637792414
+  }
+}
+
+/**
+ * The result of a successful heap analysis performed by [HeapAnalyzer].
+ */
+data class HeapAnalysisSuccess(
+  override val heapDumpFile: File,
+  override val createdAtTimeMillis: Long,
+  override val dumpDurationMillis: Long = DUMP_DURATION_UNKNOWN,
+  override val analysisDurationMillis: Long,
+  val metadata: Map<String, String>,
+  /**
+   * The list of [ApplicationLeak] found in the heap dump by [HeapAnalyzer].
+   */
+  val applicationLeaks: List<ApplicationLeak>,
+  /**
+   * The list of [LibraryLeak] found in the heap dump by [HeapAnalyzer].
+   */
+  val libraryLeaks: List<LibraryLeak>,
+  val unreachableObjects: List<LeakTraceObject>
+) : HeapAnalysis() {
+  /**
+   * The list of [Leak] found in the heap dump by [HeapAnalyzer], ie all [applicationLeaks] and
+   * all [libraryLeaks] in one list.
+   */
+  val allLeaks: Sequence<Leak>
+    get() = applicationLeaks.asSequence() + libraryLeaks.asSequence()
+
+  override fun toString(): String {
+    return """====================================
+HEAP ANALYSIS RESULT
+====================================
+${applicationLeaks.size} APPLICATION LEAKS
+
+References underlined with "~~~" are likely causes.
+Learn more at https://squ.re/leaks.
+${
+      if (applicationLeaks.isNotEmpty()) "\n" + applicationLeaks.joinToString(
+        "\n\n"
+      ) + "\n" else ""
+    }====================================
+${libraryLeaks.size} LIBRARY LEAKS
+
+A Library Leak is a leak caused by a known bug in 3rd party code that you do not have control over.
+See https://square.github.io/leakcanary/fundamentals-how-leakcanary-works/#4-categorizing-leaks
+${
+      if (libraryLeaks.isNotEmpty()) "\n" + libraryLeaks.joinToString(
+        "\n\n"
+      ) + "\n" else ""
+    }====================================
+${unreachableObjects.size} UNREACHABLE OBJECTS
+
+An unreachable object is still in memory but LeakCanary could not find a strong reference path
+from GC roots.
+${
+      if (unreachableObjects.isNotEmpty()) "\n" + unreachableObjects.joinToString(
+        "\n\n"
+      ) + "\n" else ""
+    }====================================
+METADATA
+
+Please include this in bug reports and Stack Overflow questions.
+${
+      if (metadata.isNotEmpty()) "\n" + metadata.map { "${it.key}: ${it.value}" }.joinToString(
+        "\n"
+      ) else ""
+    }
+Analysis duration: $analysisDurationMillis ms
+Heap dump file path: ${heapDumpFile.absolutePath}
+Heap dump timestamp: $createdAtTimeMillis
+Heap dump duration: ${if (dumpDurationMillis != DUMP_DURATION_UNKNOWN) "$dumpDurationMillis ms" else "Unknown"}
+===================================="""
+  }
+
+  companion object {
+    private const val serialVersionUID: Long = 130453013437459642
+  }
+}
+
+/**
+ * A leak found by [HeapAnalyzer], either an [ApplicationLeak] or a [LibraryLeak].
+ */
+sealed class Leak : Serializable {
+
+  /**
+   * Group of leak traces which share the same leak signature.
+   */
+  abstract val leakTraces: List<LeakTrace>
+
+  /**
+   * Sum of [LeakTrace.retainedHeapByteSize] for all elements in [leakTraces].
+   * Null if the retained heap size was not computed.
+   */
+  val totalRetainedHeapByteSize: Int?
+    get() = if (leakTraces.first().retainedHeapByteSize == null) {
+      null
+    } else {
+      leakTraces.sumBy { it.retainedHeapByteSize!! }
+    }
+
+  /**
+   * Sum of [LeakTrace.retainedObjectCount] for all elements in [leakTraces].
+   * Null if the retained heap size was not computed.
+   */
+  val totalRetainedObjectCount: Int?
+    get() = if (leakTraces.first().retainedObjectCount == null) {
+      null
+    } else {
+      leakTraces.sumBy { it.retainedObjectCount!! }
+    }
+
+  /**
+   * A unique SHA1 hash that represents this group of leak traces.
+   *
+   * For [ApplicationLeak] this is based on [LeakTrace.signature] and for [LibraryLeak] this is
+   * based on [LibraryLeak.pattern].
+   */
+  abstract val signature: String
+
+  abstract val shortDescription: String
+
+  override fun toString(): String {
+    return (if (totalRetainedHeapByteSize != null) "$totalRetainedHeapByteSize bytes retained by leaking objects\n" else "") +
+      (if (leakTraces.size > 1) "Displaying only 1 leak trace out of ${leakTraces.size} with the same signature\n" else "") +
+      "Signature: $signature\n" +
+      leakTraces.first()
+  }
+
+  companion object {
+    private const val serialVersionUID: Long = -2287572510360910916
+  }
+}
+
+/**
+ * A leak found by [HeapAnalyzer], where the only path to the leaking object required going
+ * through a reference matched by [pattern], as provided to a [LibraryLeakReferenceMatcher]
+ * instance. This is a known leak in library code that is beyond your control.
+ */
+data class LibraryLeak(
+  override val leakTraces: List<LeakTrace>,
+  /**
+   * The pattern that matched one of the references in each of [leakTraces], as provided to a
+   * [LibraryLeakReferenceMatcher] instance.
+   */
+  val pattern: ReferencePattern,
+  /**
+   * A description that conveys what we know about this library leak.
+   */
+  val description: String
+) : Leak() {
+  override val signature: String
+    get() = pattern.toString().createSHA1Hash()
+
+  override val shortDescription: String
+    get() = pattern.toString()
+
+  override fun toString(): String {
+    return """Leak pattern: $pattern
+Description: $description
+${super.toString()}
+"""
+  }
+
+  companion object {
+    private const val serialVersionUID: Long = 3943636164568681903
+  }
+}
+
+/**
+ * A leak found by [HeapAnalyzer] in your application.
+ */
+data class ApplicationLeak(
+  override val leakTraces: List<LeakTrace>
+) : Leak() {
+  override val signature: String
+    get() = leakTraces.first().signature
+
+  override val shortDescription: String
+    get() {
+      val leakTrace = leakTraces.first()
+      return leakTrace.suspectReferenceSubpath.firstOrNull()?.let { firstSuspectReferencePath ->
+        val referenceName = firstSuspectReferencePath.referenceGenericName
+        firstSuspectReferencePath.originObject.classSimpleName + "." + referenceName
+      } ?: leakTrace.leakingObject.className
+    }
+
+  // Override required to avoid the default toString() from data classes
+  override fun toString(): String {
+    return super.toString()
+  }
+
+  companion object {
+    private const val serialVersionUID: Long = 524928276700576863
+  }
+}
+
+private fun androidSdkInt(): Int {
+  return try {
+    val versionClass = Class.forName("android.os.Build\$VERSION")
+    val sdkIntField = versionClass.getDeclaredField("SDK_INT")
+    sdkIntField.get(null) as Int
+  } catch (e: Exception) {
+    -1
+  }
+}
+
+private fun androidManufacturer(): String {
+  return try {
+    val buildClass = Class.forName("android.os.Build")
+    val manufacturerField = buildClass.getDeclaredField("MANUFACTURER")
+    manufacturerField.get(null) as String
+  } catch (e: Exception) {
+    "Unknown"
+  }
+}
+
+private fun leakCanaryVersion(): String {
+  return try {
+    val versionHolderClass = Class.forName("leakcanary.internal.InternalLeakCanary")
+    val versionField = versionHolderClass.getDeclaredField("version")
+    versionField.isAccessible = true
+    versionField.get(null) as String
+  } catch (e: Exception) {
+    "Unknown"
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/HeapAnalysisException.kt b/shark/src/main/java/shark/HeapAnalysisException.kt
new file mode 100644
index 00000000..81b5d4a7
--- /dev/null
+++ b/shark/src/main/java/shark/HeapAnalysisException.kt
@@ -0,0 +1,17 @@
+package shark
+
+import java.io.PrintWriter
+import java.io.StringWriter
+
+class HeapAnalysisException(cause: Throwable) : RuntimeException(cause) {
+
+  override fun toString(): String {
+    val stringWriter = StringWriter()
+    cause!!.printStackTrace(PrintWriter(stringWriter))
+    return stringWriter.toString()
+  }
+
+  companion object {
+    private const val serialVersionUID: Long = -2522323377375290608
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/HeapAnalyzer.kt b/shark/src/main/java/shark/HeapAnalyzer.kt
new file mode 100644
index 00000000..53a671b8
--- /dev/null
+++ b/shark/src/main/java/shark/HeapAnalyzer.kt
@@ -0,0 +1,726 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package shark
+
+import shark.HeapAnalyzer.TrieNode.LeafNode
+import shark.HeapAnalyzer.TrieNode.ParentNode
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.LeakTrace.GcRootType
+import shark.LeakTraceObject.LeakingStatus
+import shark.LeakTraceObject.LeakingStatus.LEAKING
+import shark.LeakTraceObject.LeakingStatus.NOT_LEAKING
+import shark.LeakTraceObject.LeakingStatus.UNKNOWN
+import shark.LeakTraceObject.ObjectType.ARRAY
+import shark.LeakTraceObject.ObjectType.CLASS
+import shark.LeakTraceObject.ObjectType.INSTANCE
+import shark.OnAnalysisProgressListener.Step.BUILDING_LEAK_TRACES
+import shark.OnAnalysisProgressListener.Step.COMPUTING_NATIVE_RETAINED_SIZE
+import shark.OnAnalysisProgressListener.Step.COMPUTING_RETAINED_SIZE
+import shark.OnAnalysisProgressListener.Step.EXTRACTING_METADATA
+import shark.OnAnalysisProgressListener.Step.FINDING_RETAINED_OBJECTS
+import shark.OnAnalysisProgressListener.Step.INSPECTING_OBJECTS
+import shark.OnAnalysisProgressListener.Step.PARSING_HEAP_DUMP
+import shark.internal.AndroidNativeSizeMapper
+import shark.internal.DominatorTree
+import shark.internal.PathFinder
+import shark.internal.PathFinder.PathFindingResults
+import shark.internal.ReferencePathNode
+import shark.internal.ReferencePathNode.ChildNode
+import shark.internal.ReferencePathNode.RootNode
+import shark.internal.ShallowSizeCalculator
+import shark.internal.createSHA1Hash
+import shark.internal.lastSegment
+import java.io.File
+import java.util.ArrayList
+import java.util.concurrent.TimeUnit.NANOSECONDS
+import shark.internal.AndroidReferenceReaders
+import shark.internal.ApacheHarmonyInstanceRefReaders
+import shark.internal.ChainingInstanceReferenceReader
+import shark.internal.ClassReferenceReader
+import shark.internal.DelegatingObjectReferenceReader
+import shark.internal.FieldInstanceReferenceReader
+import shark.internal.JavaLocalReferenceReader
+import shark.internal.ObjectArrayReferenceReader
+import shark.internal.OpenJdkInstanceRefReaders
+import shark.internal.ReferenceLocationType
+import shark.internal.ReferencePathNode.RootNode.LibraryLeakRootNode
+import shark.internal.ReferenceReader
+
+/**
+ * Analyzes heap dumps to look for leaks.
+ */
+class HeapAnalyzer constructor(
+  private val listener: OnAnalysisProgressListener
+) {
+
+  private class FindLeakInput(
+    val graph: HeapGraph,
+    val referenceMatchers: List<ReferenceMatcher>,
+    val computeRetainedHeapSize: Boolean,
+    val objectInspectors: List<ObjectInspector>,
+    val referenceReader: ReferenceReader<HeapObject>
+  )
+
+  @Deprecated("Use the non deprecated analyze method instead")
+  fun analyze(
+    heapDumpFile: File,
+    leakingObjectFinder: LeakingObjectFinder,
+    referenceMatchers: List<ReferenceMatcher> = emptyList(),
+    computeRetainedHeapSize: Boolean = false,
+    objectInspectors: List<ObjectInspector> = emptyList(),
+    metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,
+    proguardMapping: ProguardMapping? = null
+  ): HeapAnalysis {
+    if (!heapDumpFile.exists()) {
+      val exception = IllegalArgumentException("File does not exist: $heapDumpFile")
+      return HeapAnalysisFailure(
+        heapDumpFile = heapDumpFile,
+        createdAtTimeMillis = System.currentTimeMillis(),
+        analysisDurationMillis = 0,
+        exception = HeapAnalysisException(exception)
+      )
+    }
+    listener.onAnalysisProgress(PARSING_HEAP_DUMP)
+    val sourceProvider = ConstantMemoryMetricsDualSourceProvider(FileSourceProvider(heapDumpFile))
+    return try {
+      sourceProvider.openHeapGraph(proguardMapping).use { graph ->
+        analyze(
+          heapDumpFile,
+          graph,
+          leakingObjectFinder,
+          referenceMatchers,
+          computeRetainedHeapSize,
+          objectInspectors,
+          metadataExtractor
+        ).let { result ->
+          if (result is HeapAnalysisSuccess) {
+            val lruCacheStats = (graph as HprofHeapGraph).lruCacheStats()
+            val randomAccessStats =
+              "RandomAccess[" +
+                "bytes=${sourceProvider.randomAccessByteReads}," +
+                "reads=${sourceProvider.randomAccessReadCount}," +
+                "travel=${sourceProvider.randomAccessByteTravel}," +
+                "range=${sourceProvider.byteTravelRange}," +
+                "size=${heapDumpFile.length()}" +
+                "]"
+            val stats = "$lruCacheStats $randomAccessStats"
+            result.copy(metadata = result.metadata + ("Stats" to stats))
+          } else result
+        }
+      }
+    } catch (throwable: Throwable) {
+      HeapAnalysisFailure(
+        heapDumpFile = heapDumpFile,
+        createdAtTimeMillis = System.currentTimeMillis(),
+        analysisDurationMillis = 0,
+        exception = HeapAnalysisException(throwable)
+      )
+    }
+  }
+
+  /**
+   * Searches the heap dump for leaking instances and then computes the shortest strong reference
+   * path from those instances to the GC roots.
+   */
+  fun analyze(
+    heapDumpFile: File,
+    graph: HeapGraph,
+    leakingObjectFinder: LeakingObjectFinder,
+    referenceMatchers: List<ReferenceMatcher> = emptyList(),
+    computeRetainedHeapSize: Boolean = false,
+    objectInspectors: List<ObjectInspector> = emptyList(),
+    metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,
+  ): HeapAnalysis {
+    val analysisStartNanoTime = System.nanoTime()
+
+    val referenceReader = DelegatingObjectReferenceReader(
+      classReferenceReader = ClassReferenceReader(graph, referenceMatchers),
+      instanceReferenceReader = ChainingInstanceReferenceReader(
+        listOf(
+          JavaLocalReferenceReader(graph, referenceMatchers),
+        )
+          + OpenJdkInstanceRefReaders.values().mapNotNull { it.create(graph) }
+          + ApacheHarmonyInstanceRefReaders.values().mapNotNull { it.create(graph) }
+          + AndroidReferenceReaders.values().mapNotNull { it.create(graph) },
+        FieldInstanceReferenceReader(graph, referenceMatchers)
+      ),
+      objectArrayReferenceReader = ObjectArrayReferenceReader()
+    )
+    return analyze(
+      heapDumpFile,
+      graph,
+      leakingObjectFinder,
+      referenceMatchers,
+      computeRetainedHeapSize,
+      objectInspectors,
+      metadataExtractor,
+      referenceReader
+    ).run {
+      val updatedDurationMillis = since(analysisStartNanoTime)
+      when (this) {
+        is HeapAnalysisSuccess -> copy(analysisDurationMillis = updatedDurationMillis)
+        is HeapAnalysisFailure -> copy(analysisDurationMillis = updatedDurationMillis)
+      }
+    }
+  }
+
+  // TODO Callers should add to analysisStartNanoTime
+  // Input should be a builder or part of the object state probs?
+  // Maybe there's some sort of helper for setting up the right analysis?
+  // There's a part focused on finding leaks, and then we add to that.
+  // Maybe the result isn't even a leaktrace yet, but something with live object ids?
+  // Ideally the result contains only what this can return. No file, etc.
+  // File: used to create the graph + in result
+  // leakingObjectFinder: Helper object, shared
+  // computeRetainedHeapSize: boolean param for single analysis
+  // referenceMatchers: param?. though honestly not great.
+  // objectInspectors: Helper object.
+  // metadataExtractor: helper object, not needed for leak finding
+  // referenceReader: can't be helper object, needs graph => param something that can produce it from
+  // graph (and in the impl we give that thing the referenceMatchers)
+  @Suppress("LongParameterList")
+  internal fun analyze(
+    // TODO Kill this file
+    heapDumpFile: File,
+    graph: HeapGraph,
+    leakingObjectFinder: LeakingObjectFinder,
+    referenceMatchers: List<ReferenceMatcher>,
+    computeRetainedHeapSize: Boolean,
+    objectInspectors: List<ObjectInspector>,
+    metadataExtractor: MetadataExtractor,
+    referenceReader: ReferenceReader<HeapObject>
+  ): HeapAnalysis {
+    val analysisStartNanoTime = System.nanoTime()
+    return try {
+      val helpers =
+        FindLeakInput(
+          graph, referenceMatchers, computeRetainedHeapSize, objectInspectors,
+          referenceReader
+        )
+      helpers.analyzeGraph(
+        metadataExtractor, leakingObjectFinder, heapDumpFile, analysisStartNanoTime
+      )
+    } catch (exception: Throwable) {
+      HeapAnalysisFailure(
+        heapDumpFile = heapDumpFile,
+        createdAtTimeMillis = System.currentTimeMillis(),
+        analysisDurationMillis = since(analysisStartNanoTime),
+        exception = HeapAnalysisException(exception)
+      )
+    }
+  }
+
+  private fun FindLeakInput.analyzeGraph(
+    metadataExtractor: MetadataExtractor,
+    leakingObjectFinder: LeakingObjectFinder,
+    heapDumpFile: File,
+    analysisStartNanoTime: Long
+  ): HeapAnalysisSuccess {
+    listener.onAnalysisProgress(EXTRACTING_METADATA)
+    val metadata = metadataExtractor.extractMetadata(graph)
+
+    val retainedClearedWeakRefCount = KeyedWeakReferenceFinder.findKeyedWeakReferences(graph)
+      .count { it.isRetained && !it.hasReferent }
+
+    // This should rarely happens, as we generally remove all cleared weak refs right before a heap
+    // dump.
+    val metadataWithCount = if (retainedClearedWeakRefCount > 0) {
+      metadata + ("Count of retained yet cleared" to "$retainedClearedWeakRefCount KeyedWeakReference instances")
+    } else {
+      metadata
+    }
+
+    listener.onAnalysisProgress(FINDING_RETAINED_OBJECTS)
+    val leakingObjectIds = leakingObjectFinder.findLeakingObjectIds(graph)
+
+    val (applicationLeaks, libraryLeaks, unreachableObjects) = findLeaks(leakingObjectIds)
+
+    return HeapAnalysisSuccess(
+      heapDumpFile = heapDumpFile,
+      createdAtTimeMillis = System.currentTimeMillis(),
+      analysisDurationMillis = since(analysisStartNanoTime),
+      metadata = metadataWithCount,
+      applicationLeaks = applicationLeaks,
+      libraryLeaks = libraryLeaks,
+      unreachableObjects = unreachableObjects
+    )
+  }
+
+  private data class LeaksAndUnreachableObjects(
+    val applicationLeaks: List<ApplicationLeak>,
+    val libraryLeaks: List<LibraryLeak>,
+    val unreachableObjects: List<LeakTraceObject>
+  )
+
+  private fun FindLeakInput.findLeaks(leakingObjectIds: Set<Long>): LeaksAndUnreachableObjects {
+    val pathFinder = PathFinder(graph, listener, referenceReader, referenceMatchers)
+    val pathFindingResults =
+      pathFinder.findPathsFromGcRoots(leakingObjectIds, computeRetainedHeapSize)
+
+    val unreachableObjects = findUnreachableObjects(pathFindingResults, leakingObjectIds)
+
+    val shortestPaths =
+      deduplicateShortestPaths(pathFindingResults.pathsToLeakingObjects)
+
+    val inspectedObjectsByPath = inspectObjects(shortestPaths)
+
+    val retainedSizes =
+      if (pathFindingResults.dominatorTree != null) {
+        computeRetainedSizes(inspectedObjectsByPath, pathFindingResults.dominatorTree)
+      } else {
+        null
+      }
+    val (applicationLeaks, libraryLeaks) = buildLeakTraces(
+      shortestPaths, inspectedObjectsByPath, retainedSizes
+    )
+    return LeaksAndUnreachableObjects(applicationLeaks, libraryLeaks, unreachableObjects)
+  }
+
+  private fun FindLeakInput.findUnreachableObjects(
+    pathFindingResults: PathFindingResults,
+    leakingObjectIds: Set<Long>
+  ): List<LeakTraceObject> {
+    val reachableLeakingObjectIds =
+      pathFindingResults.pathsToLeakingObjects.map { it.objectId }.toSet()
+
+    val unreachableLeakingObjectIds = leakingObjectIds - reachableLeakingObjectIds
+
+    val unreachableObjectReporters = unreachableLeakingObjectIds.map { objectId ->
+      ObjectReporter(heapObject = graph.findObjectById(objectId))
+    }
+
+    objectInspectors.forEach { inspector ->
+      unreachableObjectReporters.forEach { reporter ->
+        inspector.inspect(reporter)
+      }
+    }
+
+    val unreachableInspectedObjects = unreachableObjectReporters.map { reporter ->
+      val reason = resolveStatus(reporter, leakingWins = true).let { (status, reason) ->
+        when (status) {
+          LEAKING -> reason
+          UNKNOWN -> "This is a leaking object"
+          NOT_LEAKING -> "This is a leaking object. Conflicts with $reason"
+        }
+      }
+      InspectedObject(
+        reporter.heapObject, LEAKING, reason, reporter.labels
+      )
+    }
+
+    return buildLeakTraceObjects(unreachableInspectedObjects, null)
+  }
+
+  internal sealed class TrieNode {
+    abstract val objectId: Long
+
+    class ParentNode(override val objectId: Long) : TrieNode() {
+      val children = mutableMapOf<Long, TrieNode>()
+      override fun toString(): String {
+        return "ParentNode(objectId=$objectId, children=$children)"
+      }
+    }
+
+    class LeafNode(
+      override val objectId: Long,
+      val pathNode: ReferencePathNode
+    ) : TrieNode()
+  }
+
+  private fun deduplicateShortestPaths(
+    inputPathResults: List<ReferencePathNode>
+  ): List<ShortestPath> {
+    val rootTrieNode = ParentNode(0)
+
+    inputPathResults.forEach { pathNode ->
+      // Go through the linked list of nodes and build the reverse list of instances from
+      // root to leaking.
+      val path = mutableListOf<Long>()
+      var leakNode: ReferencePathNode = pathNode
+      while (leakNode is ChildNode) {
+        path.add(0, leakNode.objectId)
+        leakNode = leakNode.parent
+      }
+      path.add(0, leakNode.objectId)
+      updateTrie(pathNode, path, 0, rootTrieNode)
+    }
+
+    val outputPathResults = mutableListOf<ReferencePathNode>()
+    findResultsInTrie(rootTrieNode, outputPathResults)
+
+    if (outputPathResults.size != inputPathResults.size) {
+      SharkLog.d {
+        "Found ${inputPathResults.size} paths to retained objects," +
+          " down to ${outputPathResults.size} after removing duplicated paths"
+      }
+    } else {
+      SharkLog.d { "Found ${outputPathResults.size} paths to retained objects" }
+    }
+
+    return outputPathResults.map { retainedObjectNode ->
+      val shortestChildPath = mutableListOf<ChildNode>()
+      var node = retainedObjectNode
+      while (node is ChildNode) {
+        shortestChildPath.add(0, node)
+        node = node.parent
+      }
+      val rootNode = node as RootNode
+      ShortestPath(rootNode, shortestChildPath)
+    }
+  }
+
+  private fun updateTrie(
+    pathNode: ReferencePathNode,
+    path: List<Long>,
+    pathIndex: Int,
+    parentNode: ParentNode
+  ) {
+    val objectId = path[pathIndex]
+    if (pathIndex == path.lastIndex) {
+      parentNode.children[objectId] = LeafNode(objectId, pathNode)
+    } else {
+      val childNode = parentNode.children[objectId] ?: run {
+        val newChildNode = ParentNode(objectId)
+        parentNode.children[objectId] = newChildNode
+        newChildNode
+      }
+      if (childNode is ParentNode) {
+        updateTrie(pathNode, path, pathIndex + 1, childNode)
+      }
+    }
+  }
+
+  private fun findResultsInTrie(
+    parentNode: ParentNode,
+    outputPathResults: MutableList<ReferencePathNode>
+  ) {
+    parentNode.children.values.forEach { childNode ->
+      when (childNode) {
+        is ParentNode -> {
+          findResultsInTrie(childNode, outputPathResults)
+        }
+        is LeafNode -> {
+          outputPathResults += childNode.pathNode
+        }
+      }
+    }
+  }
+
+  internal class ShortestPath(
+    val root: RootNode,
+    val childPath: List<ChildNode>
+  ) {
+
+    val childPathWithDetails = childPath.map { it to it.lazyDetailsResolver.resolve() }
+
+    fun asList() = listOf(root) + childPath
+
+    fun firstLibraryLeakMatcher(): LibraryLeakReferenceMatcher? {
+      if (root is LibraryLeakRootNode) {
+        return root.matcher
+      }
+      return childPathWithDetails.map { it.second.matchedLibraryLeak }.firstOrNull { it != null }
+    }
+
+    fun asNodesWithMatchers(): List<Pair<ReferencePathNode, LibraryLeakReferenceMatcher?>> {
+      val rootMatcher = if (root is LibraryLeakRootNode) {
+        root.matcher
+      } else null
+      val childPathWithMatchers =
+        childPathWithDetails.map { it.first to it.second.matchedLibraryLeak }
+      return listOf(root to rootMatcher) + childPathWithMatchers
+    }
+  }
+
+  private fun FindLeakInput.buildLeakTraces(
+    shortestPaths: List<ShortestPath>,
+    inspectedObjectsByPath: List<List<InspectedObject>>,
+    retainedSizes: Map<Long, Pair<Int, Int>>?
+  ): Pair<List<ApplicationLeak>, List<LibraryLeak>> {
+    listener.onAnalysisProgress(BUILDING_LEAK_TRACES)
+
+    val applicationLeaksMap = mutableMapOf<String, MutableList<LeakTrace>>()
+    val libraryLeaksMap =
+      mutableMapOf<String, Pair<LibraryLeakReferenceMatcher, MutableList<LeakTrace>>>()
+
+    shortestPaths.forEachIndexed { pathIndex, shortestPath ->
+      val inspectedObjects = inspectedObjectsByPath[pathIndex]
+
+      val leakTraceObjects = buildLeakTraceObjects(inspectedObjects, retainedSizes)
+
+      val referencePath = buildReferencePath(shortestPath, leakTraceObjects)
+
+      val leakTrace = LeakTrace(
+        gcRootType = GcRootType.fromGcRoot(shortestPath.root.gcRoot),
+        referencePath = referencePath,
+        leakingObject = leakTraceObjects.last()
+      )
+
+      val firstLibraryLeakMatcher = shortestPath.firstLibraryLeakMatcher()
+      if (firstLibraryLeakMatcher != null) {
+        val signature: String = firstLibraryLeakMatcher.pattern.toString()
+          .createSHA1Hash()
+        libraryLeaksMap.getOrPut(signature) { firstLibraryLeakMatcher to mutableListOf() }
+          .second += leakTrace
+      } else {
+        applicationLeaksMap.getOrPut(leakTrace.signature) { mutableListOf() } += leakTrace
+      }
+    }
+    val applicationLeaks = applicationLeaksMap.map { (_, leakTraces) ->
+      ApplicationLeak(leakTraces)
+    }
+    val libraryLeaks = libraryLeaksMap.map { (_, pair) ->
+      val (matcher, leakTraces) = pair
+      LibraryLeak(leakTraces, matcher.pattern, matcher.description)
+    }
+    return applicationLeaks to libraryLeaks
+  }
+
+  private fun FindLeakInput.inspectObjects(shortestPaths: List<ShortestPath>): List<List<InspectedObject>> {
+    listener.onAnalysisProgress(INSPECTING_OBJECTS)
+
+    val leakReportersByPath = shortestPaths.map { path ->
+      val pathList = path.asNodesWithMatchers()
+      pathList
+        .mapIndexed { index, (node, _) ->
+          val reporter = ObjectReporter(heapObject = graph.findObjectById(node.objectId))
+          if (index + 1 < pathList.size) {
+            val (_, nextMatcher) = pathList[index + 1]
+            if (nextMatcher != null) {
+              reporter.labels += "Library leak match: ${nextMatcher.pattern}"
+            }
+          }
+          reporter
+        }
+    }
+
+    objectInspectors.forEach { inspector ->
+      leakReportersByPath.forEach { leakReporters ->
+        leakReporters.forEach { reporter ->
+          inspector.inspect(reporter)
+        }
+      }
+    }
+
+    return leakReportersByPath.map { leakReporters ->
+      computeLeakStatuses(leakReporters)
+    }
+  }
+
+  private fun FindLeakInput.computeRetainedSizes(
+    inspectedObjectsByPath: List<List<InspectedObject>>,
+    dominatorTree: DominatorTree
+  ): Map<Long, Pair<Int, Int>> {
+    val nodeObjectIds = inspectedObjectsByPath.flatMap { inspectedObjects ->
+      inspectedObjects.filter { it.leakingStatus == UNKNOWN || it.leakingStatus == LEAKING }
+        .map { it.heapObject.objectId }
+    }.toSet()
+    listener.onAnalysisProgress(COMPUTING_NATIVE_RETAINED_SIZE)
+    val nativeSizeMapper = AndroidNativeSizeMapper(graph)
+    val nativeSizes = nativeSizeMapper.mapNativeSizes()
+    listener.onAnalysisProgress(COMPUTING_RETAINED_SIZE)
+    val shallowSizeCalculator = ShallowSizeCalculator(graph)
+    return dominatorTree.computeRetainedSizes(nodeObjectIds) { objectId ->
+      val nativeSize = nativeSizes[objectId] ?: 0
+      val shallowSize = shallowSizeCalculator.computeShallowSize(objectId)
+      nativeSize + shallowSize
+    }
+  }
+
+  private fun buildLeakTraceObjects(
+    inspectedObjects: List<InspectedObject>,
+    retainedSizes: Map<Long, Pair<Int, Int>>?
+  ): List<LeakTraceObject> {
+    return inspectedObjects.map { inspectedObject ->
+      val heapObject = inspectedObject.heapObject
+      val className = recordClassName(heapObject)
+
+      val objectType = when (heapObject) {
+        is HeapClass -> CLASS
+        is HeapObjectArray, is HeapPrimitiveArray -> ARRAY
+        else -> INSTANCE
+      }
+
+      val retainedSizeAndObjectCount = retainedSizes?.get(inspectedObject.heapObject.objectId)
+
+      LeakTraceObject(
+        type = objectType,
+        className = className,
+        labels = inspectedObject.labels,
+        leakingStatus = inspectedObject.leakingStatus,
+        leakingStatusReason = inspectedObject.leakingStatusReason,
+        retainedHeapByteSize = retainedSizeAndObjectCount?.first,
+        retainedObjectCount = retainedSizeAndObjectCount?.second
+      )
+    }
+  }
+
+  private fun FindLeakInput.buildReferencePath(
+    shortestPath: ShortestPath,
+    leakTraceObjects: List<LeakTraceObject>
+  ): List<LeakTraceReference> {
+    return shortestPath.childPathWithDetails.mapIndexed { index, (childNode, details) ->
+      LeakTraceReference(
+        originObject = leakTraceObjects[index],
+        referenceType = when (details.locationType) {
+          ReferenceLocationType.INSTANCE_FIELD -> LeakTraceReference.ReferenceType.INSTANCE_FIELD
+          ReferenceLocationType.STATIC_FIELD -> LeakTraceReference.ReferenceType.STATIC_FIELD
+          ReferenceLocationType.LOCAL -> LeakTraceReference.ReferenceType.LOCAL
+          ReferenceLocationType.ARRAY_ENTRY -> LeakTraceReference.ReferenceType.ARRAY_ENTRY
+        },
+        owningClassName = graph.findObjectById(details.locationClassObjectId).asClass!!.name,
+        referenceName = details.name
+      )
+    }
+  }
+
+  internal class InspectedObject(
+    val heapObject: HeapObject,
+    val leakingStatus: LeakingStatus,
+    val leakingStatusReason: String,
+    val labels: MutableSet<String>
+  )
+
+  private fun computeLeakStatuses(leakReporters: List<ObjectReporter>): List<InspectedObject> {
+    val lastElementIndex = leakReporters.size - 1
+
+    var lastNotLeakingElementIndex = -1
+    var firstLeakingElementIndex = lastElementIndex
+
+    val leakStatuses = ArrayList<Pair<LeakingStatus, String>>()
+
+    for ((index, reporter) in leakReporters.withIndex()) {
+      val resolvedStatusPair =
+        resolveStatus(reporter, leakingWins = index == lastElementIndex).let { statusPair ->
+          if (index == lastElementIndex) {
+            // The last element should always be leaking.
+            when (statusPair.first) {
+              LEAKING -> statusPair
+              UNKNOWN -> LEAKING to "This is the leaking object"
+              NOT_LEAKING -> LEAKING to "This is the leaking object. Conflicts with ${statusPair.second}"
+            }
+          } else statusPair
+        }
+
+      leakStatuses.add(resolvedStatusPair)
+      val (leakStatus, _) = resolvedStatusPair
+      if (leakStatus == NOT_LEAKING) {
+        lastNotLeakingElementIndex = index
+        // Reset firstLeakingElementIndex so that we never have
+        // firstLeakingElementIndex < lastNotLeakingElementIndex
+        firstLeakingElementIndex = lastElementIndex
+      } else if (leakStatus == LEAKING && firstLeakingElementIndex == lastElementIndex) {
+        firstLeakingElementIndex = index
+      }
+    }
+
+    val simpleClassNames = leakReporters.map { reporter ->
+      recordClassName(reporter.heapObject).lastSegment('.')
+    }
+
+    for (i in 0 until lastNotLeakingElementIndex) {
+      val (leakStatus, leakStatusReason) = leakStatuses[i]
+      val nextNotLeakingIndex = generateSequence(i + 1) { index ->
+        if (index < lastNotLeakingElementIndex) index + 1 else null
+      }.first { index ->
+        leakStatuses[index].first == NOT_LEAKING
+      }
+
+      // Element is forced to NOT_LEAKING
+      val nextNotLeakingName = simpleClassNames[nextNotLeakingIndex]
+      leakStatuses[i] = when (leakStatus) {
+        UNKNOWN -> NOT_LEAKING to "$nextNotLeakingNameâ†“ is not leaking"
+        NOT_LEAKING -> NOT_LEAKING to "$nextNotLeakingNameâ†“ is not leaking and $leakStatusReason"
+        LEAKING -> NOT_LEAKING to "$nextNotLeakingNameâ†“ is not leaking. Conflicts with $leakStatusReason"
+      }
+    }
+
+    if (firstLeakingElementIndex < lastElementIndex - 1) {
+      // We already know the status of firstLeakingElementIndex and lastElementIndex
+      for (i in lastElementIndex - 1 downTo firstLeakingElementIndex + 1) {
+        val (leakStatus, leakStatusReason) = leakStatuses[i]
+        val previousLeakingIndex = generateSequence(i - 1) { index ->
+          if (index > firstLeakingElementIndex) index - 1 else null
+        }.first { index ->
+          leakStatuses[index].first == LEAKING
+        }
+
+        // Element is forced to LEAKING
+        val previousLeakingName = simpleClassNames[previousLeakingIndex]
+        leakStatuses[i] = when (leakStatus) {
+          UNKNOWN -> LEAKING to "$previousLeakingNameâ†‘ is leaking"
+          LEAKING -> LEAKING to "$previousLeakingNameâ†‘ is leaking and $leakStatusReason"
+          NOT_LEAKING -> throw IllegalStateException("Should never happen")
+        }
+      }
+    }
+
+    return leakReporters.mapIndexed { index, objectReporter ->
+      val (leakingStatus, leakingStatusReason) = leakStatuses[index]
+      InspectedObject(
+        objectReporter.heapObject, leakingStatus, leakingStatusReason, objectReporter.labels
+      )
+    }
+  }
+
+  private fun resolveStatus(
+    reporter: ObjectReporter,
+    leakingWins: Boolean
+  ): Pair<LeakingStatus, String> {
+    var status = UNKNOWN
+    var reason = ""
+    if (reporter.notLeakingReasons.isNotEmpty()) {
+      status = NOT_LEAKING
+      reason = reporter.notLeakingReasons.joinToString(" and ")
+    }
+    val leakingReasons = reporter.leakingReasons
+    if (leakingReasons.isNotEmpty()) {
+      val winReasons = leakingReasons.joinToString(" and ")
+      // Conflict
+      if (status == NOT_LEAKING) {
+        if (leakingWins) {
+          status = LEAKING
+          reason = "$winReasons. Conflicts with $reason"
+        } else {
+          reason += ". Conflicts with $winReasons"
+        }
+      } else {
+        status = LEAKING
+        reason = winReasons
+      }
+    }
+    return status to reason
+  }
+
+  private fun recordClassName(
+    heap: HeapObject
+  ): String {
+    return when (heap) {
+      is HeapClass -> heap.name
+      is HeapInstance -> heap.instanceClassName
+      is HeapObjectArray -> heap.arrayClassName
+      is HeapPrimitiveArray -> heap.arrayClassName
+    }
+  }
+
+  private fun since(analysisStartNanoTime: Long): Long {
+    return NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime)
+  }
+}
diff --git a/shark/src/main/java/shark/KeyedWeakReferenceFinder.kt b/shark/src/main/java/shark/KeyedWeakReferenceFinder.kt
new file mode 100644
index 00000000..a98f064b
--- /dev/null
+++ b/shark/src/main/java/shark/KeyedWeakReferenceFinder.kt
@@ -0,0 +1,59 @@
+package shark
+
+import shark.ObjectInspectors.KEYED_WEAK_REFERENCE
+import shark.internal.KeyedWeakReferenceMirror
+
+/**
+ * Finds all objects tracked by a KeyedWeakReference, ie all objects that were passed to
+ * ObjectWatcher.watch.
+ */
+object KeyedWeakReferenceFinder : LeakingObjectFinder {
+
+  override fun findLeakingObjectIds(graph: HeapGraph): Set<Long> =
+    findKeyedWeakReferences(graph)
+      .filter { it.hasReferent && it.isRetained }
+      .map { it.referent.value }
+      .toSet()
+
+  fun heapDumpUptimeMillis(graph: HeapGraph): Long? {
+    return graph.context.getOrPut("heapDumpUptimeMillis") {
+      val keyedWeakReferenceClass = graph.findClassByName("leakcanary.KeyedWeakReference")
+      val heapDumpUptimeMillis = if (keyedWeakReferenceClass == null) {
+        null
+      } else {
+        keyedWeakReferenceClass["heapDumpUptimeMillis"]?.value?.asLong
+      }
+      if (heapDumpUptimeMillis == null) {
+        SharkLog.d {
+          "leakcanary.KeyedWeakReference.heapDumpUptimeMillis field not found"
+        }
+      }
+      heapDumpUptimeMillis
+    }
+  }
+
+  internal fun findKeyedWeakReferences(graph: HeapGraph): List<KeyedWeakReferenceMirror> {
+    return graph.context.getOrPut(KEYED_WEAK_REFERENCE.name) {
+      val keyedWeakReferenceClass = graph.findClassByName("leakcanary.KeyedWeakReference")
+
+      val keyedWeakReferenceClassId = keyedWeakReferenceClass?.objectId ?: 0
+      val legacyKeyedWeakReferenceClassId =
+        graph.findClassByName("com.squareup.leakcanary.KeyedWeakReference")?.objectId ?: 0
+
+      val heapDumpUptimeMillis = heapDumpUptimeMillis(graph)
+
+      val addedToContext: List<KeyedWeakReferenceMirror> = graph.instances
+        .filter { instance ->
+          instance.instanceClassId == keyedWeakReferenceClassId || instance.instanceClassId == legacyKeyedWeakReferenceClassId
+        }
+        .map {
+          KeyedWeakReferenceMirror.fromInstance(
+            it, heapDumpUptimeMillis
+          )
+        }
+        .toList()
+      graph.context[KEYED_WEAK_REFERENCE.name] = addedToContext
+      addedToContext
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/LeakNodeStatus.kt b/shark/src/main/java/shark/LeakNodeStatus.kt
new file mode 100644
index 00000000..f914ca36
--- /dev/null
+++ b/shark/src/main/java/shark/LeakNodeStatus.kt
@@ -0,0 +1,10 @@
+package shark
+
+/**
+ * This class is kept to support backward compatible deserialization.
+ */
+internal enum class LeakNodeStatus {
+  NOT_LEAKING,
+  LEAKING,
+  UNKNOWN;
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/LeakTrace.kt b/shark/src/main/java/shark/LeakTrace.kt
new file mode 100644
index 00000000..dbfa91c6
--- /dev/null
+++ b/shark/src/main/java/shark/LeakTrace.kt
@@ -0,0 +1,187 @@
+package shark
+
+import shark.LeakTraceObject.LeakingStatus.LEAKING
+import shark.LeakTraceObject.LeakingStatus.NOT_LEAKING
+import shark.LeakTraceObject.LeakingStatus.UNKNOWN
+import shark.LeakTraceReference.ReferenceType.INSTANCE_FIELD
+import shark.LeakTraceReference.ReferenceType.STATIC_FIELD
+import shark.internal.createSHA1Hash
+import java.io.Serializable
+
+/**
+ * The best strong reference path from a GC root to the leaking object. "Best" here means the
+ * shortest prioritized path. A large number of distinct paths can generally be found leading
+ * to a leaking object. Shark prioritizes paths that don't go through known
+ * [LibraryLeakReferenceMatcher] (because those are known to create leaks so it's more interesting
+ * to find other paths causing leaks), then it prioritize paths that don't go through java local
+ * gc roots (because those are harder to reason about). Taking those priorities into account,
+ * finding the shortest path means there are less [LeakTraceReference] that can be suspected to
+ * cause the leak.
+ */
+data class LeakTrace(
+  /**
+   * The Garbage Collection root that references the [LeakTraceReference.originObject] in
+   * the first [LeakTraceReference] of [referencePath].
+   */
+  val gcRootType: GcRootType,
+  val referencePath: List<LeakTraceReference>,
+  val leakingObject: LeakTraceObject
+) : Serializable {
+
+  /**
+   * The minimum number of bytes which would be freed if the leak was fixed.
+   * Null if the retained heap size was not computed.
+   */
+  val retainedHeapByteSize: Int?
+    get() {
+      val allObjects = listOf(leakingObject) + referencePath.map { it.originObject }
+      return allObjects.filter { it.leakingStatus == LEAKING }
+        .mapNotNull { it.retainedHeapByteSize }
+        // The minimum released is the max held by a leaking object.
+        .max()
+    }
+
+  /**
+   * The minimum number of objects which would be unreachable if the leak was fixed. Null if the
+   * retained heap size was not computed.
+   */
+  val retainedObjectCount: Int?
+    get() {
+      val allObjects = listOf(leakingObject) + referencePath.map { it.originObject }
+      return allObjects.filter { it.leakingStatus == LEAKING }
+        .mapNotNull { it.retainedObjectCount }
+        // The minimum released is the max held by a leaking object.
+        .max()
+    }
+
+  /**
+   * A part of [referencePath] that contains the references suspected to cause the leak.
+   * Starts at the last non leaking object and ends before the first leaking object.
+   */
+  val suspectReferenceSubpath
+    get() = referencePath.asSequence()
+      .filterIndexed { index, _ ->
+        referencePathElementIsSuspect(index)
+      }
+
+  /**
+   * A SHA1 hash that represents this leak trace. This can be useful to group together similar
+   * leak traces.
+   *
+   * The signature is a hash of [suspectReferenceSubpath].
+   */
+  val signature: String
+    get() = suspectReferenceSubpath
+      .joinToString(separator = "") { element ->
+        element.originObject.className + element.referenceGenericName
+      }
+      .createSHA1Hash()
+
+  /**
+   * Returns true if the [referencePath] element at the provided [index] contains a reference
+   * that is suspected to cause the leak, ie if [index] is greater than or equal to the index
+   * of the [LeakTraceReference] of the last non leaking object and strictly lower than the index
+   * of the [LeakTraceReference] of the first leaking object.
+   */
+  fun referencePathElementIsSuspect(index: Int): Boolean {
+    return when (referencePath[index].originObject.leakingStatus) {
+      UNKNOWN -> true
+      NOT_LEAKING -> index == referencePath.lastIndex ||
+        referencePath[index + 1].originObject.leakingStatus != NOT_LEAKING
+      else -> false
+    }
+  }
+
+  override fun toString(): String = leakTraceAsString(showLeakingStatus = true)
+
+  fun toSimplePathString(): String = leakTraceAsString(showLeakingStatus = false)
+
+  private fun leakTraceAsString(showLeakingStatus: Boolean): String {
+    var result = """
+        â”¬â”€â”€â”€
+        â”‚ GC Root: ${gcRootType.description}
+        â”‚
+      """.trimIndent()
+
+    referencePath.forEachIndexed { index, element ->
+      val originObject = element.originObject
+      result += "\n"
+      result += originObject.toString(
+        firstLinePrefix = "â”œâ”€ ",
+        additionalLinesPrefix = "â”‚    ",
+        showLeakingStatus = showLeakingStatus,
+        typeName = originObject.typeName
+      )
+      result += getNextElementString(this, element, index, showLeakingStatus)
+    }
+
+    result += "\n"
+    result += leakingObject.toString(
+      firstLinePrefix = "â•°â†’ ",
+      additionalLinesPrefix = "$ZERO_WIDTH_SPACE     ",
+      showLeakingStatus = showLeakingStatus
+    )
+    return result
+  }
+
+  enum class GcRootType(val description: String) {
+    JNI_GLOBAL("Global variable in native code"),
+    JNI_LOCAL("Local variable in native code"),
+    JAVA_FRAME("Java local variable"),
+    NATIVE_STACK("Input or output parameters in native code"),
+    STICKY_CLASS("System class"),
+    THREAD_BLOCK("Thread block"),
+    MONITOR_USED(
+      "Monitor (anything that called the wait() or notify() methods, or that is synchronized.)"
+    ),
+    THREAD_OBJECT("Thread object"),
+    JNI_MONITOR("Root JNI monitor"),
+    ;
+
+    companion object {
+      fun fromGcRoot(gcRoot: GcRoot): GcRootType = when (gcRoot) {
+        is GcRoot.JniGlobal -> JNI_GLOBAL
+        is GcRoot.JniLocal -> JNI_LOCAL
+        is GcRoot.JavaFrame -> JAVA_FRAME
+        is GcRoot.NativeStack -> NATIVE_STACK
+        is GcRoot.StickyClass -> STICKY_CLASS
+        is GcRoot.ThreadBlock -> THREAD_BLOCK
+        is GcRoot.MonitorUsed -> MONITOR_USED
+        is GcRoot.ThreadObject -> THREAD_OBJECT
+        is GcRoot.JniMonitor -> JNI_MONITOR
+        else -> throw IllegalStateException("Unexpected gc root $gcRoot")
+      }
+    }
+  }
+
+  companion object {
+    private fun getNextElementString(
+      leakTrace: LeakTrace,
+      reference: LeakTraceReference,
+      index: Int,
+      showLeakingStatus: Boolean
+    ): String {
+      val static = if (reference.referenceType == STATIC_FIELD) " static" else ""
+
+      val referenceLinePrefix = "    â†“$static ${reference.owningClassSimpleName.removeSuffix("[]")}" +
+       when (reference.referenceType) {
+         STATIC_FIELD, INSTANCE_FIELD -> "."
+         else -> ""
+       }
+
+      val referenceName = reference.referenceDisplayName
+      val referenceLine = referenceLinePrefix + referenceName
+
+      return if (showLeakingStatus && leakTrace.referencePathElementIsSuspect(index)) {
+        val spaces = " ".repeat(referenceLinePrefix.length)
+        val underline = "~".repeat(referenceName.length)
+        "\nâ”‚$referenceLine\nâ”‚$spaces$underline"
+      } else {
+        "\nâ”‚$referenceLine"
+      }
+    }
+
+    internal const val ZERO_WIDTH_SPACE = '\u200b'
+    private const val serialVersionUID = -6315725584154386429
+  }
+}
diff --git a/shark/src/main/java/shark/LeakTraceObject.kt b/shark/src/main/java/shark/LeakTraceObject.kt
new file mode 100644
index 00000000..e9c2b7a5
--- /dev/null
+++ b/shark/src/main/java/shark/LeakTraceObject.kt
@@ -0,0 +1,116 @@
+package shark
+
+import shark.LeakTrace.Companion.ZERO_WIDTH_SPACE
+import shark.LeakTraceObject.LeakingStatus
+import shark.LeakTraceObject.LeakingStatus.LEAKING
+import shark.LeakTraceObject.LeakingStatus.NOT_LEAKING
+import shark.LeakTraceObject.LeakingStatus.UNKNOWN
+import shark.internal.lastSegment
+import java.io.Serializable
+import java.util.Locale
+import kotlin.math.ln
+import kotlin.math.pow
+
+data class LeakTraceObject(
+  val type: ObjectType,
+  /**
+   * Class name of the object.
+   * The class name format is the same as what would be returned by [Class.getName].
+   */
+  val className: String,
+
+  /**
+   * Labels that were computed during analysis. A label provides extra information that helps
+   * understand the state of the leak trace object.
+   */
+  val labels: Set<String>,
+  val leakingStatus: LeakingStatus,
+  val leakingStatusReason: String,
+  /**
+   * The minimum number of bytes which would be freed if all references to this object were
+   * released. Not null only if the retained heap size was computed AND [leakingStatus] is
+   * equal to [LeakingStatus.UNKNOWN] or [LeakingStatus.LEAKING].
+   */
+  val retainedHeapByteSize: Int?,
+  /**
+   * The minimum number of objects which would be unreachable if all references to this object were
+   * released. Not null only if the retained heap size was computed AND [leakingStatus] is
+   * equal to [LeakingStatus.UNKNOWN] or [LeakingStatus.LEAKING].
+   */
+  val retainedObjectCount: Int?
+) : Serializable {
+
+  /**
+   * Returns {@link #className} without the package, ie stripped of any string content before the
+   * last period (included).
+   */
+  val classSimpleName: String get() = className.lastSegment('.')
+
+  val typeName
+    get() = type.name.toLowerCase(Locale.US)
+
+  override fun toString(): String {
+    val firstLinePrefix = ""
+    val additionalLinesPrefix = "$ZERO_WIDTH_SPACE  "
+    return toString(firstLinePrefix, additionalLinesPrefix, true)
+  }
+
+  internal fun toString(
+    firstLinePrefix: String,
+    additionalLinesPrefix: String,
+    showLeakingStatus: Boolean,
+    typeName: String = this.typeName
+  ): String {
+    val leakStatus = when (leakingStatus) {
+      UNKNOWN -> "UNKNOWN"
+      NOT_LEAKING -> "NO ($leakingStatusReason)"
+      LEAKING -> "YES ($leakingStatusReason)"
+    }
+
+    var result = ""
+    result += "$firstLinePrefix$className $typeName"
+    if (showLeakingStatus) {
+      result += "\n${additionalLinesPrefix}Leaking: $leakStatus"
+    }
+
+    if (retainedHeapByteSize != null) {
+      val humanReadableRetainedHeapSize =
+        humanReadableByteCount(retainedHeapByteSize.toLong())
+      result += "\n${additionalLinesPrefix}Retaining $humanReadableRetainedHeapSize in $retainedObjectCount objects"
+    }
+    for (label in labels) {
+      result += "\n${additionalLinesPrefix}$label"
+    }
+    return result
+  }
+
+  enum class ObjectType {
+    CLASS,
+    ARRAY,
+    INSTANCE
+  }
+
+  enum class LeakingStatus {
+    /** The object was needed and therefore expected to be reachable. */
+    NOT_LEAKING,
+
+    /** The object was no longer needed and therefore expected to be unreachable. */
+    LEAKING,
+
+    /** No decision can be made about the provided object. */
+    UNKNOWN;
+  }
+
+  companion object {
+    private const val serialVersionUID = -3616216391305196341L
+
+    // https://stackoverflow.com/a/3758880
+    private fun humanReadableByteCount(bytes: Long): String {
+      val unit = 1000
+      if (bytes < unit) return "$bytes B"
+      val exp = (ln(bytes.toDouble()) / ln(unit.toDouble())).toInt()
+      val pre = "kMGTPE"[exp - 1]
+      return String.format("%.1f %sB", bytes / unit.toDouble().pow(exp.toDouble()), pre)
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/LeakTraceReference.kt b/shark/src/main/java/shark/LeakTraceReference.kt
new file mode 100644
index 00000000..0bfee57a
--- /dev/null
+++ b/shark/src/main/java/shark/LeakTraceReference.kt
@@ -0,0 +1,62 @@
+package shark
+
+import shark.LeakTraceReference.ReferenceType.ARRAY_ENTRY
+import shark.LeakTraceReference.ReferenceType.INSTANCE_FIELD
+import shark.LeakTraceReference.ReferenceType.LOCAL
+import shark.LeakTraceReference.ReferenceType.STATIC_FIELD
+import shark.internal.lastSegment
+import java.io.Serializable
+
+/**
+ * A [LeakTraceReference] represents an origin [LeakTraceObject] and either a reference from that
+ * object to the [LeakTraceObject] in the next [LeakTraceReference] in [LeakTrace.referencePath],
+ * or to [LeakTrace.leakingObject] if this is the last [LeakTraceReference] in
+ * [LeakTrace.referencePath].
+ */
+data class LeakTraceReference(
+  val originObject: LeakTraceObject,
+
+  val referenceType: ReferenceType,
+
+  val owningClassName: String,
+
+  val referenceName: String
+
+) : Serializable {
+
+  enum class ReferenceType {
+    INSTANCE_FIELD,
+    STATIC_FIELD,
+    LOCAL,
+    ARRAY_ENTRY
+  }
+
+  /**
+   * Returns {@link #className} without the package, ie stripped of any string content before the
+   * last period (included).
+   */
+  val owningClassSimpleName: String get() = owningClassName.lastSegment('.')
+
+  val referenceDisplayName: String
+    get() {
+      return when (referenceType) {
+        ARRAY_ENTRY -> "[$referenceName]"
+        STATIC_FIELD, INSTANCE_FIELD -> referenceName
+        LOCAL -> "<Java Local>"
+      }
+    }
+
+  val referenceGenericName: String
+    get() {
+      return when (referenceType) {
+        // The specific array index in a leak rarely matters, this improves grouping.
+        ARRAY_ENTRY -> "[x]"
+        STATIC_FIELD, INSTANCE_FIELD -> referenceName
+        LOCAL -> "<Java Local>"
+      }
+    }
+
+  companion object {
+    private const val serialVersionUID = 1L
+  }
+}
diff --git a/shark/src/main/java/shark/LeakingObjectFinder.kt b/shark/src/main/java/shark/LeakingObjectFinder.kt
new file mode 100644
index 00000000..80ca2af1
--- /dev/null
+++ b/shark/src/main/java/shark/LeakingObjectFinder.kt
@@ -0,0 +1,32 @@
+package shark
+
+/**
+ * Finds the objects that are leaking, for which Shark will compute
+ * leak traces.
+ *
+ * This is a functional interface with which you can create a [LeakingObjectFinder] from a lambda.
+ */
+fun interface LeakingObjectFinder {
+
+  /**
+   * For a given heap graph, returns a set of object ids for the objects that are leaking.
+   */
+  fun findLeakingObjectIds(graph: HeapGraph): Set<Long>
+
+  companion object {
+    /**
+     * Utility function to create a [LeakingObjectFinder] from the passed in [block] lambda
+     * instead of using the anonymous `object : LeakingObjectFinder` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val listener = LeakingObjectFinder {
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (HeapGraph) -> Set<Long>): LeakingObjectFinder =
+      LeakingObjectFinder { graph -> block(graph) }
+  }
+}
diff --git a/shark/src/main/java/shark/MetadataExtractor.kt b/shark/src/main/java/shark/MetadataExtractor.kt
new file mode 100644
index 00000000..b3d56eb5
--- /dev/null
+++ b/shark/src/main/java/shark/MetadataExtractor.kt
@@ -0,0 +1,33 @@
+package shark
+
+/**
+ * Extracts metadata from a hprof to be reported in [HeapAnalysisSuccess.metadata].
+ *
+ * This is a functional interface with which you can create a [MetadataExtractor] from a lambda.
+ */
+fun interface MetadataExtractor {
+  fun extractMetadata(graph: HeapGraph): Map<String, String>
+
+  companion object {
+
+    /**
+     * A no-op [MetadataExtractor]
+     */
+    val NO_OP = MetadataExtractor { emptyMap() }
+
+    /**
+     * Utility function to create a [MetadataExtractor] from the passed in [block] lambda instead of
+     * using the anonymous `object : MetadataExtractor` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val inspector = MetadataExtractor { graph ->
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (HeapGraph) -> Map<String, String>): MetadataExtractor =
+      MetadataExtractor { graph -> block(graph) }
+  }
+}
diff --git a/shark/src/main/java/shark/ObjectInspector.kt b/shark/src/main/java/shark/ObjectInspector.kt
new file mode 100644
index 00000000..5bb30e3e
--- /dev/null
+++ b/shark/src/main/java/shark/ObjectInspector.kt
@@ -0,0 +1,34 @@
+package shark
+
+/**
+ * Provides LeakCanary with insights about objects (classes, instances and arrays) found in the
+ * heap. [inspect] will be called for each object that LeakCanary wants to know more about.
+ * The implementation can then use the provided [ObjectReporter] to provide insights for that
+ * object.
+ *
+ * This is a functional interface with which you can create a [ObjectInspector] from a lambda.
+ */
+fun interface ObjectInspector {
+
+  /**
+   * @see [ObjectInspector]
+   */
+  fun inspect(reporter: ObjectReporter)
+
+  companion object {
+    /**
+     * Utility function to create a [ObjectInspector] from the passed in [block] lambda instead of
+     * using the anonymous `object : OnHeapAnalyzedListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val inspector = ObjectInspector { reporter ->
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (ObjectReporter) -> Unit): ObjectInspector =
+      ObjectInspector { reporter -> block(reporter) }
+  }
+}
diff --git a/shark/src/main/java/shark/ObjectInspectors.kt b/shark/src/main/java/shark/ObjectInspectors.kt
new file mode 100644
index 00000000..a480d570
--- /dev/null
+++ b/shark/src/main/java/shark/ObjectInspectors.kt
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package shark
+
+import shark.FilteringLeakingObjectFinder.LeakingObjectFilter
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import java.util.EnumSet
+
+/**
+ * A set of default [ObjectInspector]s that knows about common JDK objects.
+ */
+enum class ObjectInspectors : ObjectInspector {
+
+  KEYED_WEAK_REFERENCE {
+
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      KeyedWeakReferenceFinder.findKeyedWeakReferences(heapObject.graph)
+        .filter { it.hasReferent && it.isRetained }
+        .any { reference ->
+          reference.referent.value == heapObject.objectId
+        }
+    }
+
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      val graph = reporter.heapObject.graph
+      val references = KeyedWeakReferenceFinder.findKeyedWeakReferences(graph)
+
+      val objectId = reporter.heapObject.objectId
+      references.forEach { ref ->
+        if (ref.referent.value == objectId) {
+          reporter.leakingReasons += if (ref.description.isNotEmpty()) {
+            "ObjectWatcher was watching this because ${ref.description}"
+          } else {
+            "ObjectWatcher was watching this"
+          }
+          reporter.labels += "key = ${ref.key}"
+          if (ref.watchDurationMillis != null) {
+            reporter.labels += "watchDurationMillis = ${ref.watchDurationMillis}"
+          }
+          if (ref.retainedDurationMillis != null) {
+            reporter.labels += "retainedDurationMillis = ${ref.retainedDurationMillis}"
+          }
+        }
+      }
+    }
+  },
+
+  CLASSLOADER {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf(ClassLoader::class) {
+        notLeakingReasons += "A ClassLoader is never leaking"
+      }
+    }
+  },
+
+  CLASS {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      if (reporter.heapObject is HeapClass) {
+        reporter.notLeakingReasons += "a class is never leaking"
+      }
+    }
+  },
+
+  ANONYMOUS_CLASS {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      val heapObject = reporter.heapObject
+      if (heapObject is HeapInstance) {
+        val instanceClass = heapObject.instanceClass
+        if (instanceClass.name.matches(ANONYMOUS_CLASS_NAME_PATTERN_REGEX)) {
+          val parentClassRecord = instanceClass.superclass!!
+          if (parentClassRecord.name == "java.lang.Object") {
+            try {
+              // This is an anonymous class implementing an interface. The API does not give access
+              // to the interfaces implemented by the class. We check if it's in the class path and
+              // use that instead.
+              val actualClass = Class.forName(instanceClass.name)
+              val interfaces = actualClass.interfaces
+              reporter.labels += if (interfaces.isNotEmpty()) {
+                val implementedInterface = interfaces[0]
+                "Anonymous class implementing ${implementedInterface.name}"
+              } else {
+                "Anonymous subclass of java.lang.Object"
+              }
+            } catch (ignored: ClassNotFoundException) {
+            }
+          } else {
+            // Makes it easier to figure out which anonymous class we're looking at.
+            reporter.labels += "Anonymous subclass of ${parentClassRecord.name}"
+          }
+        }
+      }
+    }
+  },
+
+  THREAD {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf(Thread::class) { instance ->
+        val threadName = instance[Thread::class, "name"]!!.value.readAsJavaString()
+        labels += "Thread name: '$threadName'"
+      }
+    }
+  };
+
+  internal open val leakingObjectFilter: ((heapObject: HeapObject) -> Boolean)? = null
+
+  companion object {
+    private const val ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$"
+    private val ANONYMOUS_CLASS_NAME_PATTERN_REGEX = ANONYMOUS_CLASS_NAME_PATTERN.toRegex()
+
+    /** @see ObjectInspectors */
+    val jdkDefaults: List<ObjectInspector>
+      get() {
+        return values().toList()
+      }
+
+    /**
+     * Returns a list of [LeakingObjectFilter] suitable for common JDK projects.
+     */
+    val jdkLeakingObjectFilters: List<LeakingObjectFilter> =
+      createLeakingObjectFilters(EnumSet.allOf(ObjectInspectors::class.java))
+
+    /**
+     * Creates a list of [LeakingObjectFilter] based on the passed in [ObjectInspectors].
+     */
+    fun createLeakingObjectFilters(inspectors: Set<ObjectInspectors>): List<LeakingObjectFilter> =
+      inspectors.mapNotNull { it.leakingObjectFilter }
+        .map { filter ->
+          LeakingObjectFilter { heapObject -> filter(heapObject) }
+        }
+  }
+}
diff --git a/shark/src/main/java/shark/ObjectReporter.kt b/shark/src/main/java/shark/ObjectReporter.kt
new file mode 100644
index 00000000..f562a5df
--- /dev/null
+++ b/shark/src/main/java/shark/ObjectReporter.kt
@@ -0,0 +1,64 @@
+package shark
+
+import shark.HeapObject.HeapInstance
+import kotlin.reflect.KClass
+
+/**
+ * Enables [ObjectInspector] implementations to provide insights on [heapObject], which is
+ * an object (class, instance or array) found in the heap.
+ *
+ * A given [ObjectReporter] only maps to one object in the heap, but is shared to many
+ * [ObjectInspector] implementations and accumulates insights.
+ */
+class ObjectReporter constructor(val heapObject: HeapObject) {
+
+  /**
+   * Labels that will be visible on the corresponding [heapObject] in the leak trace.
+   */
+  val labels = linkedSetOf<String>()
+
+  /**
+   * Reasons for which this object is expected to be unreachable (ie it's leaking).
+   */
+  val leakingReasons = mutableSetOf<String>()
+
+  /**
+   * Deprecated, use leakingReasons instead.
+   */
+  @Deprecated(
+    "Replace likelyLeakingReasons with leakingReasons",
+    replaceWith = ReplaceWith(
+      "leakingReasons"
+    )
+  )
+  val likelyLeakingReasons
+    get() = leakingReasons
+
+  /**
+   * Reasons for which this object is expected to be reachable (ie it's not leaking).
+   */
+  val notLeakingReasons = mutableSetOf<String>()
+
+  /**
+   * Runs [block] if [ObjectReporter.heapObject] is an instance of [expectedClass].
+   */
+  fun whenInstanceOf(
+    expectedClass: KClass<out Any>,
+    block: ObjectReporter.(HeapInstance) -> Unit
+  ) {
+    whenInstanceOf(expectedClass.java.name, block)
+  }
+
+  /**
+   * Runs [block] if [ObjectReporter.heapObject] is an instance of [expectedClassName].
+   */
+  fun whenInstanceOf(
+    expectedClassName: String,
+    block: ObjectReporter.(HeapInstance) -> Unit
+  ) {
+    val heapObject = heapObject
+    if (heapObject is HeapInstance && heapObject instanceOf expectedClassName) {
+      block(heapObject)
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/OnAnalysisProgressListener.kt b/shark/src/main/java/shark/OnAnalysisProgressListener.kt
new file mode 100644
index 00000000..92cdbff9
--- /dev/null
+++ b/shark/src/main/java/shark/OnAnalysisProgressListener.kt
@@ -0,0 +1,59 @@
+package shark
+
+import java.util.Locale
+
+/**
+ * Reports progress from the [HeapAnalyzer] as they occur, as [Step] values.
+ *
+ * This is a functional interface with which you can create a [OnAnalysisProgressListener] from a lambda.
+ */
+fun interface OnAnalysisProgressListener {
+
+  // These steps are defined in the order in which they occur.
+  enum class Step {
+    PARSING_HEAP_DUMP,
+    EXTRACTING_METADATA,
+    FINDING_RETAINED_OBJECTS,
+    FINDING_PATHS_TO_RETAINED_OBJECTS,
+    FINDING_DOMINATORS,
+    INSPECTING_OBJECTS,
+    COMPUTING_NATIVE_RETAINED_SIZE,
+    COMPUTING_RETAINED_SIZE,
+    BUILDING_LEAK_TRACES,
+    REPORTING_HEAP_ANALYSIS;
+
+    val humanReadableName: String
+
+    init {
+      val lowercaseName = name.replace("_", " ")
+        .toLowerCase(Locale.US)
+      humanReadableName =
+        lowercaseName.substring(0, 1).toUpperCase(Locale.US) + lowercaseName.substring(1)
+    }
+  }
+
+  fun onAnalysisProgress(step: Step)
+
+  companion object {
+
+    /**
+     * A no-op [OnAnalysisProgressListener]
+     */
+    val NO_OP = OnAnalysisProgressListener {}
+
+    /**
+     * Utility function to create a [OnAnalysisProgressListener] from the passed in [block] lambda
+     * instead of using the anonymous `object : OnAnalysisProgressListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val listener = OnAnalysisProgressListener {
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (Step) -> Unit): OnAnalysisProgressListener =
+      OnAnalysisProgressListener { step -> block(step) }
+  }
+}
diff --git a/shark/src/main/java/shark/ReferenceMatcher.kt b/shark/src/main/java/shark/ReferenceMatcher.kt
new file mode 100644
index 00000000..34b0c419
--- /dev/null
+++ b/shark/src/main/java/shark/ReferenceMatcher.kt
@@ -0,0 +1,49 @@
+package shark
+
+/**
+ * Used to pattern match known patterns of references in the heap, either to ignore them
+ * ([IgnoredReferenceMatcher]) or to mark them as library leaks ([LibraryLeakReferenceMatcher]).
+ */
+sealed class ReferenceMatcher {
+
+  /** The pattern that references will be matched against. */
+  abstract val pattern: ReferencePattern
+}
+
+/**
+ * [LibraryLeakReferenceMatcher] should be used to match references in library code that are
+ * known to create leaks and are beyond your control. The shortest path finder will only go
+ * through matching references after it has exhausted references that don't match, prioritizing
+ * finding an application leak over a known library leak. Library leaks will be reported as
+ * [LibraryLeak] instead of [ApplicationLeak].
+ */
+data class LibraryLeakReferenceMatcher(
+  override val pattern: ReferencePattern,
+  /**
+   * A description that conveys what we know about this library leak.
+   */
+  val description: String = "",
+  /**
+   * Whether the identified leak may exist in the provided [HeapGraph]. Defaults to true. If
+   * the heap dump comes from a VM that runs a different version of the library that doesn't
+   * have the leak, then this should return false.
+   */
+  val patternApplies: (HeapGraph) -> Boolean = { true }
+) : ReferenceMatcher() {
+  override fun toString() = "library leak: $pattern"
+}
+
+/**
+ * [IgnoredReferenceMatcher] should be used to match references that cannot ever create leaks. The
+ * shortest path finder will never go through matching references.
+ */
+class IgnoredReferenceMatcher(override val pattern: ReferencePattern) : ReferenceMatcher() {
+  override fun toString() = "ignored ref: $pattern"
+}
+
+internal fun Iterable<ReferenceMatcher>.filterFor(graph: HeapGraph): List<ReferenceMatcher> {
+  return filter { matcher ->
+    (matcher is IgnoredReferenceMatcher ||
+      (matcher is LibraryLeakReferenceMatcher && matcher.patternApplies(graph)))
+  }
+}
diff --git a/shark/src/main/java/shark/ReferencePattern.kt b/shark/src/main/java/shark/ReferencePattern.kt
new file mode 100644
index 00000000..a44c1f79
--- /dev/null
+++ b/shark/src/main/java/shark/ReferencePattern.kt
@@ -0,0 +1,72 @@
+package shark
+
+import java.io.Serializable
+
+/**
+ * A pattern that will match references for a given [ReferenceMatcher].
+ */
+sealed class ReferencePattern : Serializable {
+
+  /**
+   * Matches local references held in the stack of frames of a given thread, identified by its name.
+   */
+  data class JavaLocalPattern(
+    val threadName: String
+  ) : ReferencePattern() {
+    override fun toString() = "local variable on thread $threadName"
+
+    companion object {
+      private const val serialVersionUID: Long = -8985446122829543654
+    }
+  }
+
+  /**
+   * Matches static field references, identified by [className] and [fieldName].
+   */
+  data class StaticFieldPattern(
+    val className: String,
+    val fieldName: String
+  ) : ReferencePattern() {
+    override fun toString() = "static field $className#$fieldName"
+
+    companion object {
+      private const val serialVersionUID: Long = 7656908128775899611
+    }
+  }
+
+  /**
+   * Matches instances field references, identified by [className] and [fieldName].
+   *
+   * Note: If [fieldName] is declared in a superclass it will still match for subclasses.
+   * This is to support overriding of rules for specific cases. If two [ReferenceMatcher] match for
+   * the same [fieldName] but for different [className] in a class hierarchy, then the closest
+   * class in the hierarchy wins.
+   */
+  data class InstanceFieldPattern(
+    val className: String,
+    val fieldName: String
+  ) : ReferencePattern() {
+    override fun toString() = "instance field $className#$fieldName"
+
+    companion object {
+      private const val serialVersionUID: Long = 6649791455204159802
+    }
+  }
+
+  /**
+   * Matches native global variables (also known as jni global gc roots) that reference
+   * Java objects. The class name will match against classes, instances and object arrays with
+   * a matching class name.
+   */
+  data class NativeGlobalVariablePattern(val className: String) : ReferencePattern() {
+    override fun toString() = "native global variable referencing $className"
+
+    companion object {
+      private const val serialVersionUID: Long = -2651328076202244933
+    }
+  }
+
+  companion object {
+    private const val serialVersionUID: Long = -5113635523713591133
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/internal/AndroidNativeSizeMapper.kt b/shark/src/main/java/shark/internal/AndroidNativeSizeMapper.kt
new file mode 100644
index 00000000..a52e347c
--- /dev/null
+++ b/shark/src/main/java/shark/internal/AndroidNativeSizeMapper.kt
@@ -0,0 +1,60 @@
+package shark.internal
+
+import shark.HeapGraph
+import shark.HeapObject.HeapInstance
+
+internal class AndroidNativeSizeMapper(private val graph: HeapGraph) {
+
+  /**
+   * Returns a map of Object id to native size as tracked by NativeAllocationRegistry$CleanerThunk
+   */
+  fun mapNativeSizes(): Map<Long, Int> {
+    return graph.context.getOrPut("AndroidNativeSizeMapper") {
+      buildNativeSizeMap()
+    }
+  }
+
+  private fun buildNativeSizeMap(): Map<Long, Int> {
+    val nativeSizes = mutableMapOf<Long, Int>()
+    // Doc from perflib:
+    // Native allocations can be identified by looking at instances of
+    // libcore.util.NativeAllocationRegistry$CleanerThunk. The "owning" Java object is the
+    // "referent" field of the "sun.misc.Cleaner" instance with a hard reference to the
+    // CleanerThunk.
+    //
+    // The size is in the 'size' field of the libcore.util.NativeAllocationRegistry instance
+    // that the CleanerThunk has a pointer to. The native pointer is in the 'nativePtr' field of
+    // the CleanerThunk. The hprof does not include the native bytes pointed to.
+    graph.findClassByName("sun.misc.Cleaner")?.let { cleanerClass ->
+      cleanerClass.directInstances.forEach { cleaner ->
+        val thunkField = cleaner["sun.misc.Cleaner", "thunk"]
+        val thunkId = thunkField?.value?.asNonNullObjectId
+        val referentId =
+          cleaner["java.lang.ref.Reference", "referent"]?.value?.asNonNullObjectId
+        if (thunkId != null && referentId != null) {
+          val thunkRecord = thunkField.value.asObject
+          if (thunkRecord is HeapInstance && thunkRecord instanceOf "libcore.util.NativeAllocationRegistry\$CleanerThunk") {
+            val allocationRegistryIdField =
+              thunkRecord["libcore.util.NativeAllocationRegistry\$CleanerThunk", "this\$0"]
+            if (allocationRegistryIdField != null && allocationRegistryIdField.value.isNonNullReference) {
+              val allocationRegistryRecord = allocationRegistryIdField.value.asObject
+              if (allocationRegistryRecord is HeapInstance && allocationRegistryRecord instanceOf "libcore.util.NativeAllocationRegistry") {
+                var nativeSize = nativeSizes[referentId] ?: 0
+                nativeSize += allocationRegistryRecord["libcore.util.NativeAllocationRegistry", "size"]?.value?.asLong?.toInt()
+                  ?: 0
+                nativeSizes[referentId] = nativeSize
+              }
+            }
+          }
+        }
+      }
+    }
+    return nativeSizes
+  }
+
+  companion object {
+    fun mapNativeSizes(heapGraph: HeapGraph): Map<Long, Int> {
+      return AndroidNativeSizeMapper(heapGraph).mapNativeSizes()
+    }
+  }
+}
diff --git a/shark/src/main/java/shark/internal/AndroidReferenceReaders.kt b/shark/src/main/java/shark/internal/AndroidReferenceReaders.kt
new file mode 100644
index 00000000..15ab5bdd
--- /dev/null
+++ b/shark/src/main/java/shark/internal/AndroidReferenceReaders.kt
@@ -0,0 +1,350 @@
+package shark.internal
+
+import shark.HeapGraph
+import shark.HeapObject.HeapInstance
+import shark.LibraryLeakReferenceMatcher
+import shark.ReferencePattern.InstanceFieldPattern
+import shark.ValueHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.internal.ChainingInstanceReferenceReader.VirtualInstanceReferenceReader
+import shark.internal.ChainingInstanceReferenceReader.VirtualInstanceReferenceReader.OptionalFactory
+import shark.internal.Reference.LazyDetails
+import shark.internal.ReferenceLocationType.ARRAY_ENTRY
+import shark.internal.ReferenceLocationType.INSTANCE_FIELD
+
+internal enum class AndroidReferenceReaders : OptionalFactory {
+
+  /**
+   * ActivityThread.mNewActivity is a linked list of ActivityClientRecord that keeps track of
+   * activities after they were resumed, until the main thread is idle. This is used to report
+   * analytics to system_server about how long it took for the main thread to settle after
+   * resuming an activity. Unfortunately, if the main thread never becomes idle, all these
+   * new activities leak in memory.
+   *
+   * We'd normally catch these with a pattern in AndroidReferenceMatchers, and we do have
+   * AndroidReferenceMatchers.ACTIVITY_THREAD__M_NEW_ACTIVITIES to do that, however this matching
+   * only works if none of the activities alive are waiting for idle. If any activity alive is
+   * still waiting for idle (which all the alive activities would be if they main thread is never
+   * idle) then ActivityThread.mActivities will reference an ActivityClientRecord through an
+   * ArrayMap and because ActivityClientRecord are reused that instance will also have its nextIdle
+   * fields set, so we're effectively traversing the ActivityThread.mNewActivity from a completely
+   * different and unexpected entry point.
+   *
+   * To fix that problem of broken pattern matching, we emit the mNewActivities field when
+   * finding an ActivityThread instance, and because custom ref readers have priority over the
+   * default instance field reader, we're guaranteed that mNewActivities is enqueued before
+   * mActivities. Unfortunately, that also means we can't rely on AndroidReferenceMatchers as
+   * those aren't used here, so we recreate our own LibraryLeakReferenceMatcher.
+   *
+   * We want to traverse mNewActivities before mActivities so we can't set isLowPriority to true
+   * like we would for normal path tagged as source of leak. So we will prioritize going through all
+   * activities in mNewActivities, some of which aren't destroyed yet (and therefore not leaking).
+   * Going through those paths of non leaking activities, we might find other leaks though.
+   * This would result in us tagging unrelated leaks as part of the mNewActivities leak. To prevent
+   * this, we traverse ActivityThread.mNewActivities as a linked list through
+   * ActivityClientRecord.nextIdle as a linked list, but we emit only ActivityClientRecord.activity
+   * fields if such activities are destroyed, which means any live activity in
+   * ActivityThread.mNewActivities will be discovered through the normal field navigation process
+   * and should go through ActivityThread.mActivities.
+   */
+  ACTIVITY_THREAD__NEW_ACTIVITIES {
+    override fun create(graph: HeapGraph): VirtualInstanceReferenceReader? {
+      val activityThreadClass = graph.findClassByName("android.app.ActivityThread") ?: return null
+
+      if (activityThreadClass.readRecordFields().none {
+          activityThreadClass.instanceFieldName(it) == "mNewActivities"
+        }
+      ) {
+        return null
+      }
+
+      val activityClientRecordClass =
+        graph.findClassByName("android.app.ActivityThread\$ActivityClientRecord") ?: return null
+
+      val activityClientRecordFieldNames = activityClientRecordClass.readRecordFields()
+        .map { activityThreadClass.instanceFieldName(it) }
+        .toList()
+
+      if ("nextIdle" !in activityClientRecordFieldNames ||
+        "activity" !in activityClientRecordFieldNames) {
+        return null
+      }
+
+      val activityThreadClassId = activityThreadClass.objectId
+      val activityClientRecordClassId = activityClientRecordClass.objectId
+
+      return object : VirtualInstanceReferenceReader {
+        override fun matches(instance: HeapInstance) =
+          instance.instanceClassId == activityThreadClassId ||
+            instance.instanceClassId == activityClientRecordClassId
+
+        override fun read(source: HeapInstance): Sequence<Reference> {
+          return if (source.instanceClassId == activityThreadClassId) {
+            val mNewActivities =
+              source["android.app.ActivityThread", "mNewActivities"]!!.value.asObjectId!!
+            if (mNewActivities == ValueHolder.NULL_REFERENCE) {
+              emptySequence()
+            } else {
+              source.graph.context[ACTIVITY_THREAD__NEW_ACTIVITIES.name] = mNewActivities
+              sequenceOf(
+                Reference(
+                  valueObjectId = mNewActivities,
+                  isLowPriority = false,
+                  lazyDetailsResolver = {
+                    LazyDetails(
+                      name = "mNewActivities",
+                      locationClassObjectId = activityThreadClassId,
+                      locationType = INSTANCE_FIELD,
+                      isVirtual = false,
+                      matchedLibraryLeak = LibraryLeakReferenceMatcher(
+                        pattern = InstanceFieldPattern(
+                          "android.app.ActivityThread", "mNewActivities"
+                        ),
+                        description = """
+                       New activities are leaked by ActivityThread until the main thread becomes idle.
+                       Tracked here: https://issuetracker.google.com/issues/258390457
+                     """.trimIndent()
+                      )
+                    )
+                  })
+              )
+            }
+          } else {
+            val mNewActivities =
+              source.graph.context.get<Long?>(ACTIVITY_THREAD__NEW_ACTIVITIES.name)
+            if (mNewActivities == null || source.objectId != mNewActivities) {
+              emptySequence()
+            } else {
+              generateSequence(source) { node ->
+                node["android.app.ActivityThread\$ActivityClientRecord", "nextIdle"]!!.valueAsInstance
+              }.withIndex().mapNotNull { (index, node) ->
+
+                val activity = node["android.app.ActivityThread\$ActivityClientRecord", "activity"]!!.valueAsInstance
+                if (activity == null ||
+                  // Skip non destroyed activities.
+                  // (!= true because we also skip if mDestroyed is missing)
+                  activity["android.app.Activity", "mDestroyed"]?.value?.asBoolean != true
+                ) {
+                  null
+                } else {
+                  Reference(
+                    valueObjectId = activity.objectId,
+                    isLowPriority = false,
+                    lazyDetailsResolver = {
+                      LazyDetails(
+                        name = "$index",
+                        locationClassObjectId = activityClientRecordClassId,
+                        locationType = ARRAY_ENTRY,
+                        isVirtual = true,
+                        matchedLibraryLeak = null
+                      )
+                    })
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  },
+
+
+  MESSAGE_QUEUE {
+    override fun create(graph: HeapGraph): VirtualInstanceReferenceReader? {
+      val messageQueueClass =
+        graph.findClassByName("android.os.MessageQueue") ?: return null
+
+      val messageQueueClassId = messageQueueClass.objectId
+
+      return object : VirtualInstanceReferenceReader {
+        override fun matches(instance: HeapInstance) =
+          instance.instanceClassId == messageQueueClassId
+
+        override fun read(source: HeapInstance): Sequence<Reference> {
+          val firstMessage = source["android.os.MessageQueue", "mMessages"]!!.valueAsInstance
+          return generateSequence(firstMessage) { node ->
+            node["android.os.Message", "next"]!!.valueAsInstance
+          }
+            .withIndex()
+            .map { (index, node) ->
+              Reference(
+                valueObjectId = node.objectId,
+                isLowPriority = false,
+                lazyDetailsResolver = {
+                  LazyDetails(
+                    name = "$index",
+                    locationClassObjectId = messageQueueClassId,
+                    locationType = ARRAY_ENTRY,
+                    isVirtual = true,
+                    matchedLibraryLeak = null
+                  )
+                }
+              )
+            }
+        }
+      }
+    }
+  },
+
+  ANIMATOR_WEAK_REF_SUCKS {
+    override fun create(graph: HeapGraph): VirtualInstanceReferenceReader? {
+      val objectAnimatorClass =
+        graph.findClassByName("android.animation.ObjectAnimator") ?: return null
+
+      val weakRefClassId =
+        graph.findClassByName("java.lang.ref.WeakReference")?.objectId ?: return null
+
+      val objectAnimatorClassId = objectAnimatorClass.objectId
+
+      return object : VirtualInstanceReferenceReader {
+        override fun matches(instance: HeapInstance) =
+          instance.instanceClassId == objectAnimatorClassId
+
+        override fun read(source: HeapInstance): Sequence<Reference> {
+          val mTarget = source["android.animation.ObjectAnimator", "mTarget"]?.valueAsInstance
+            ?: return emptySequence()
+
+          if (mTarget.instanceClassId != weakRefClassId) {
+            return emptySequence()
+          }
+
+          val actualRef =
+            mTarget["java.lang.ref.Reference", "referent"]!!.value.holder as ReferenceHolder
+
+          return if (actualRef.isNull) {
+            emptySequence()
+          } else {
+            sequenceOf(Reference(
+              valueObjectId = actualRef.value,
+              isLowPriority = true,
+              lazyDetailsResolver = {
+                LazyDetails(
+                  name = "mTarget",
+                  locationClassObjectId = objectAnimatorClassId,
+                  locationType = INSTANCE_FIELD,
+                  matchedLibraryLeak = null,
+                  isVirtual = true
+                )
+              }
+            ))
+          }
+        }
+      }
+    }
+  },
+
+  SAFE_ITERABLE_MAP {
+    override fun create(graph: HeapGraph): VirtualInstanceReferenceReader? {
+      val mapClass =
+        graph.findClassByName(SAFE_ITERABLE_MAP_CLASS_NAME) ?: return null
+      // A subclass of SafeIterableMap with dual storage in a backing HashMap for fast get.
+      // Yes, that's a little weird.
+      val fastMapClass = graph.findClassByName(FAST_SAFE_ITERABLE_MAP_CLASS_NAME)
+
+      val mapClassId = mapClass.objectId
+      val fastMapClassId = fastMapClass?.objectId
+
+      return object : VirtualInstanceReferenceReader {
+        override fun matches(instance: HeapInstance) =
+          instance.instanceClassId.let { classId ->
+            classId == mapClassId || classId == fastMapClassId
+          }
+
+        override fun read(source: HeapInstance): Sequence<Reference> {
+          val start = source[SAFE_ITERABLE_MAP_CLASS_NAME, "mStart"]!!.valueAsInstance
+
+          val entries = generateSequence(start) { node ->
+            node[SAFE_ITERABLE_MAP_ENTRY_CLASS_NAME, "mNext"]!!.valueAsInstance
+          }
+
+          val locationClassObjectId = source.instanceClassId
+          return entries.flatMap { entry ->
+            // mkey is never null
+            val key = entry[SAFE_ITERABLE_MAP_ENTRY_CLASS_NAME, "mKey"]!!.value
+
+            val keyRef = Reference(
+              valueObjectId = key.asObjectId!!,
+              isLowPriority = false,
+              lazyDetailsResolver = {
+                LazyDetails(
+                  name = "key()",
+                  locationClassObjectId = locationClassObjectId,
+                  locationType = ARRAY_ENTRY,
+                  isVirtual = true,
+                  matchedLibraryLeak = null
+                )
+              }
+            )
+
+            // mValue is never null
+            val value = entry[SAFE_ITERABLE_MAP_ENTRY_CLASS_NAME, "mValue"]!!.value
+
+            val valueRef = Reference(
+              valueObjectId = value.asObjectId!!,
+              isLowPriority = false,
+              lazyDetailsResolver = {
+                val keyAsString = key.asObject?.asInstance?.readAsJavaString()?.let { "\"$it\"" }
+                val keyAsName =
+                  keyAsString ?: key.asObject?.toString() ?: "null"
+                LazyDetails(
+                  name = keyAsName,
+                  locationClassObjectId = locationClassObjectId,
+                  locationType = ARRAY_ENTRY,
+                  isVirtual = true,
+                  matchedLibraryLeak = null
+                )
+              }
+            )
+            sequenceOf(keyRef, valueRef)
+          }
+        }
+      }
+    }
+  },
+
+  ARRAY_SET {
+    override fun create(graph: HeapGraph): VirtualInstanceReferenceReader? {
+      val arraySetClassId = graph.findClassByName(ARRAY_SET_CLASS_NAME)?.objectId ?:return null
+
+      return object : VirtualInstanceReferenceReader {
+        override fun matches(instance: HeapInstance) = instance.instanceClassId == arraySetClassId
+
+        override fun read(source: HeapInstance): Sequence<Reference> {
+          val mArray = source[ARRAY_SET_CLASS_NAME, "mArray"]!!.valueAsObjectArray!!
+          val locationClassObjectId = source.instanceClassId
+          return mArray.readElements()
+            .filter { it.isNonNullReference }
+            .map { reference ->
+              Reference(
+                valueObjectId = reference.asNonNullObjectId!!,
+                isLowPriority = false,
+                lazyDetailsResolver = {
+                  LazyDetails(
+                    name = "element()",
+                    locationClassObjectId = locationClassObjectId,
+                    locationType = ARRAY_ENTRY,
+                    isVirtual = true,
+                    matchedLibraryLeak = null,
+                  )
+                }
+              )
+            }
+        }
+      }
+    }
+  },
+
+  ;
+
+  companion object {
+    private const val ARRAY_SET_CLASS_NAME = "android.util.ArraySet"
+
+    // Note: not supporting the support lib version of these, which is identical but with an
+    // "android" package prefix instead of "androidx".
+    private const val SAFE_ITERABLE_MAP_CLASS_NAME = "androidx.arch.core.internal.SafeIterableMap"
+    private const val FAST_SAFE_ITERABLE_MAP_CLASS_NAME =
+      "androidx.arch.core.internal.FastSafeIterableMap"
+    private const val SAFE_ITERABLE_MAP_ENTRY_CLASS_NAME =
+      "androidx.arch.core.internal.SafeIterableMap\$Entry"
+  }
+}
diff --git a/shark/src/main/java/shark/internal/ApacheHarmonyInstanceRefReaders.kt b/shark/src/main/java/shark/internal/ApacheHarmonyInstanceRefReaders.kt
new file mode 100644
index 00000000..8e194ed8
--- /dev/null
+++ b/shark/src/main/java/shark/internal/ApacheHarmonyInstanceRefReaders.kt
@@ -0,0 +1,163 @@
+package shark.internal
+
+import shark.internal.ChainingInstanceReferenceReader.VirtualInstanceReferenceReader.OptionalFactory
+import shark.internal.ChainingInstanceReferenceReader.VirtualInstanceReferenceReader
+import shark.HeapGraph
+import shark.HeapObject.HeapInstance
+
+/**
+ * Defines [VirtualInstanceReferenceReader] factories for common Apache Harmony data structures.
+ *
+ * Note: the expanders target the direct classes and don't target subclasses, as these might
+ * include additional out going references that would be missed.
+ */
+internal enum class ApacheHarmonyInstanceRefReaders : OptionalFactory {
+
+  // https://cs.android.com/android/platform/superproject/+/android-6.0.1_r81:libcore/luni/src/main/java/java/util/LinkedList.java
+  LINKED_LIST {
+    override fun create(graph: HeapGraph): VirtualInstanceReferenceReader? {
+      val linkedListClass = graph.findClassByName("java.util.LinkedList") ?: return null
+      val isApacheHarmonyImpl = linkedListClass.readRecordFields()
+        .any { linkedListClass.instanceFieldName(it) == "voidLink" }
+
+      if (!isApacheHarmonyImpl) {
+        return null
+      }
+      return InternalSharedLinkedListReferenceReader(
+        classObjectId = linkedListClass.objectId,
+        headFieldName = "voidLink",
+        nodeClassName = "java.util.LinkedList\$Link",
+        nodeNextFieldName = "next",
+        nodeElementFieldName = "data",
+      )
+    }
+  },
+
+  // https://cs.android.com/android/platform/superproject/+/android-6.0.1_r81:libcore/luni/src/main/java/java/util/ArrayList.java
+  ARRAY_LIST {
+    override fun create(graph: HeapGraph): VirtualInstanceReferenceReader? {
+      val arrayListClass = graph.findClassByName("java.util.ArrayList") ?: return null
+
+      val isApacheHarmonyImpl = arrayListClass.readRecordFields()
+        .any { arrayListClass.instanceFieldName(it) == "array" }
+
+      if (!isApacheHarmonyImpl) {
+        return null
+      }
+
+      return InternalSharedArrayListReferenceReader(
+        className = "java.util.ArrayList",
+        classObjectId = arrayListClass.objectId,
+        elementArrayName = "array",
+        sizeFieldName = "size",
+      )
+    }
+  },
+
+  // https://cs.android.com/android/platform/superproject/+/android-6.0.1_r81:libcore/luni/src/main/java/java/util/concurrent/CopyOnWriteArrayList.java
+  COPY_ON_WRITE_ARRAY_LIST {
+    override fun create(graph: HeapGraph): VirtualInstanceReferenceReader? {
+      val arrayListClass =
+        graph.findClassByName("java.util.concurrent.CopyOnWriteArrayList") ?: return null
+
+      val isApacheHarmonyImpl = arrayListClass.readRecordFields()
+        .any { arrayListClass.instanceFieldName(it) == "elements" }
+
+      if (!isApacheHarmonyImpl) {
+        return null
+      }
+
+      return InternalSharedArrayListReferenceReader(
+        className = "java.util.concurrent.CopyOnWriteArrayList",
+        classObjectId = arrayListClass.objectId,
+        elementArrayName = "elements",
+        sizeFieldName = null,
+      )
+    }
+  },
+
+  // https://cs.android.com/android/platform/superproject/+/android-6.0.1_r81:libcore/luni/src/main/java/java/util/HashMap.java
+  /**
+   * Handles HashMap & LinkedHashMap
+   */
+  HASH_MAP {
+    override fun create(graph: HeapGraph): VirtualInstanceReferenceReader? {
+      val hashMapClass = graph.findClassByName("java.util.HashMap") ?: return null
+
+      // No loadFactor field in the Apache Harmony impl.
+      val isOpenJdkImpl = hashMapClass.readRecordFields()
+        .any { hashMapClass.instanceFieldName(it) == "loadFactor" }
+
+      if (isOpenJdkImpl) {
+        return null
+      }
+      val linkedHashMapClass = graph.findClassByName("java.util.LinkedHashMap")
+
+      val hashMapClassId = hashMapClass.objectId
+      val linkedHashMapClassId = linkedHashMapClass?.objectId ?: 0
+
+      return InternalSharedHashMapReferenceReader(
+        className = "java.util.HashMap",
+        tableFieldName = "table",
+        nodeClassName = "java.util.HashMap\$HashMapEntry",
+        nodeNextFieldName = "next",
+        nodeKeyFieldName = "key",
+        nodeValueFieldName = "value",
+        keyName = "key()",
+        keysOnly = false,
+        matches = {
+          val instanceClassId = it.instanceClassId
+          instanceClassId == hashMapClassId || instanceClassId == linkedHashMapClassId
+        },
+        declaringClassId = { it.instanceClassId }
+      )
+    }
+  },
+
+  // https://cs.android.com/android/platform/superproject/+/android-6.0.1_r81:libcore/luni/src/main/java/java/util/HashSet.java
+  /**
+   * Handles HashSet & LinkedHashSet
+   */
+  HASH_SET {
+    override fun create(graph: HeapGraph): VirtualInstanceReferenceReader? {
+      val hashSetClass = graph.findClassByName("java.util.HashSet") ?: return null
+
+      val isApacheHarmonyImpl = hashSetClass.readRecordFields()
+        .any { hashSetClass.instanceFieldName(it) == "backingMap" }
+
+      if (!isApacheHarmonyImpl) {
+        return null
+      }
+
+      val linkedHashSetClass = graph.findClassByName("java.util.LinkedHashSet")
+      val hashSetClassId = hashSetClass.objectId
+      val linkedHashSetClassId = linkedHashSetClass?.objectId ?: 0
+      return object : VirtualInstanceReferenceReader {
+
+        override fun matches(instance: HeapInstance): Boolean {
+          val instanceClassId = instance.instanceClassId
+          return (instanceClassId == hashSetClassId || instanceClassId == linkedHashSetClassId)
+        }
+
+        override fun read(instance: HeapInstance): Sequence<Reference> {
+          // "HashSet.backingMap" is never null.
+          val map = instance["java.util.HashSet", "backingMap"]!!.valueAsInstance!!
+          return InternalSharedHashMapReferenceReader(
+            className = "java.util.HashMap",
+            tableFieldName = "table",
+            nodeClassName = "java.util.HashMap\$HashMapEntry",
+            nodeNextFieldName = "next",
+            nodeKeyFieldName = "key",
+            nodeValueFieldName = "value",
+            keyName = "element()",
+            keysOnly = true,
+            matches = { true },
+            declaringClassId = { instance.instanceClassId }
+          ).read(map)
+        }
+      }
+    }
+  }
+
+  ;
+}
diff --git a/shark/src/main/java/shark/internal/ByteStringCompat.java b/shark/src/main/java/shark/internal/ByteStringCompat.java
new file mode 100644
index 00000000..efa82e7b
--- /dev/null
+++ b/shark/src/main/java/shark/internal/ByteStringCompat.java
@@ -0,0 +1,14 @@
+package shark.internal;
+
+import okio.ByteString;
+
+class ByteStringCompat {
+
+  /**
+   * This is deprecated (error) to invoke from Kotlin but invoking the Kotlin extension function
+   * leads to improper bytecode that goes through the companion class.
+   */
+  static ByteString encodeUtf8(String string) {
+    return ByteString.encodeUtf8(string);
+  }
+}
diff --git a/shark/src/main/java/shark/internal/ChainingInstanceReferenceReader.kt b/shark/src/main/java/shark/internal/ChainingInstanceReferenceReader.kt
new file mode 100644
index 00000000..8ce1d65d
--- /dev/null
+++ b/shark/src/main/java/shark/internal/ChainingInstanceReferenceReader.kt
@@ -0,0 +1,56 @@
+package shark.internal
+
+import shark.HeapGraph
+import shark.HeapObject.HeapInstance
+
+/**
+ * A [ReferenceReader] that first delegates expanding to [virtualRefReaders] in order until one
+ * matches (or none), and then always proceeds with [fieldRefReader]. This means any
+ * synthetic ref will be on the shortest path, but we still explore the entire data structure so
+ * that we correctly track which objects have been visited and correctly compute dominators and
+ * retained size.
+ */
+internal class ChainingInstanceReferenceReader(
+  private val virtualRefReaders: List<VirtualInstanceReferenceReader>,
+  private val fieldRefReader: FieldInstanceReferenceReader
+) : ReferenceReader<HeapInstance> {
+
+  override fun read(source: HeapInstance): Sequence<Reference> {
+    val virtualRefs = expandVirtualRefs(source)
+    // Note: always forwarding to fieldRefReader means we may navigate the structure twice
+    // which increases IO reads. However this is a trade-of that allows virtualRef impls to
+    // focus on a subset of references and more importantly it means we still get a proper
+    // calculation of retained size as we don't skip any instance.
+    val fieldRefs = fieldRefReader.read(source)
+    return virtualRefs + fieldRefs
+  }
+
+  private fun expandVirtualRefs(instance: HeapInstance): Sequence<Reference> {
+    for (expander in virtualRefReaders) {
+      if (expander.matches(instance)) {
+        return expander.read(instance)
+      }
+    }
+    return emptySequence()
+  }
+
+  /**
+   * Same as [ReferenceReader] but [read] is only invoked when [matches] returns
+   * true. [matches] should return false if this [VirtualInstanceReferenceReader] implementation isn't
+   * able to expand the provided instance, in which case [ChainingInstanceReferenceReader] will delegate
+   * to the next [VirtualInstanceReferenceReader] implementation.
+   */
+  interface VirtualInstanceReferenceReader : ReferenceReader<HeapInstance> {
+    fun matches(instance: HeapInstance): Boolean
+
+    /**
+     * May create a new InstanceExpander, depending on what's in the heap graph.
+     * [OptionalFactory] implementations might return a different [ReferenceReader]
+     * depending on which version of a class is present in the heap dump, or they might return null if
+     * that class is missing.
+     */
+    fun interface OptionalFactory {
+      fun create(graph: HeapGraph): VirtualInstanceReferenceReader?
+    }
+  }
+}
diff --git a/shark/src/main/java/shark/internal/ClassReferenceReader.kt b/shark/src/main/java/shark/internal/ClassReferenceReader.kt
new file mode 100644
index 00000000..d58f5495
--- /dev/null
+++ b/shark/src/main/java/shark/internal/ClassReferenceReader.kt
@@ -0,0 +1,75 @@
+package shark.internal
+
+import shark.HeapGraph
+import shark.HeapObject.HeapClass
+import shark.IgnoredReferenceMatcher
+import shark.LibraryLeakReferenceMatcher
+import shark.internal.Reference.LazyDetails
+import shark.internal.ReferenceLocationType.STATIC_FIELD
+import shark.ReferenceMatcher
+import shark.ReferencePattern.StaticFieldPattern
+import shark.ValueHolder.ReferenceHolder
+import shark.filterFor
+
+internal class ClassReferenceReader(
+  graph: HeapGraph,
+  referenceMatchers: List<ReferenceMatcher>
+) : ReferenceReader<HeapClass> {
+  private val staticFieldNameByClassName: Map<String, Map<String, ReferenceMatcher>>
+
+  init {
+    val staticFieldNameByClassName = mutableMapOf<String, MutableMap<String, ReferenceMatcher>>()
+    referenceMatchers.filterFor(graph).forEach { referenceMatcher ->
+      val pattern = referenceMatcher.pattern
+      if (pattern is StaticFieldPattern) {
+        val mapOrNull = staticFieldNameByClassName[pattern.className]
+        val map = if (mapOrNull != null) mapOrNull else {
+          val newMap = mutableMapOf<String, ReferenceMatcher>()
+          staticFieldNameByClassName[pattern.className] = newMap
+          newMap
+        }
+        map[pattern.fieldName] = referenceMatcher
+      }
+    }
+    this.staticFieldNameByClassName = staticFieldNameByClassName
+  }
+
+  override fun read(source: HeapClass): Sequence<Reference> {
+    val ignoredStaticFields = staticFieldNameByClassName[source.name] ?: emptyMap()
+
+    return source.readStaticFields().mapNotNull {  staticField ->
+      // not non null: no null + no primitives.
+      if (!staticField.value.isNonNullReference) {
+        return@mapNotNull null
+      }
+      val fieldName = staticField.name
+      if (fieldName == "\$staticOverhead" || fieldName == "\$classOverhead") {
+        return@mapNotNull null
+      }
+
+      // Note: instead of calling staticField.value.asObjectId!! we cast holder to ReferenceHolder
+      // and access value directly. This allows us to avoid unnecessary boxing of Long.
+      val valueObjectId = (staticField.value.holder as ReferenceHolder).value
+      val referenceMatcher = ignoredStaticFields[fieldName]
+
+      if (referenceMatcher is IgnoredReferenceMatcher) {
+        null
+      } else {
+        val sourceObjectId = source.objectId
+        Reference(
+          valueObjectId = valueObjectId,
+          isLowPriority = referenceMatcher != null,
+          lazyDetailsResolver = {
+            LazyDetails(
+              name = fieldName,
+              locationClassObjectId = sourceObjectId,
+              locationType = STATIC_FIELD,
+              isVirtual = false,
+              matchedLibraryLeak = referenceMatcher as LibraryLeakReferenceMatcher?,
+            )
+          }
+        )
+      }
+    }
+  }
+}
diff --git a/shark/src/main/java/shark/internal/DelegatingObjectReferenceReader.kt b/shark/src/main/java/shark/internal/DelegatingObjectReferenceReader.kt
new file mode 100644
index 00000000..b9210ad1
--- /dev/null
+++ b/shark/src/main/java/shark/internal/DelegatingObjectReferenceReader.kt
@@ -0,0 +1,22 @@
+package shark.internal
+
+import shark.HeapObject
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+
+internal class DelegatingObjectReferenceReader(
+  private val classReferenceReader: ReferenceReader<HeapClass>,
+  private val instanceReferenceReader: ReferenceReader<HeapInstance>,
+  private val objectArrayReferenceReader: ReferenceReader<HeapObjectArray>,
+) : ReferenceReader<HeapObject> {
+  override fun read(source: HeapObject): Sequence<Reference> {
+    return when(source) {
+      is HeapClass -> classReferenceReader.read(source)
+      is HeapInstance -> instanceReferenceReader.read(source)
+      is HeapObjectArray -> objectArrayReferenceReader.read(source)
+      is HeapPrimitiveArray -> emptySequence()
+    }
+  }
+}
diff --git a/shark/src/main/java/shark/internal/DominatorTree.kt b/shark/src/main/java/shark/internal/DominatorTree.kt
new file mode 100644
index 00000000..5420ebab
--- /dev/null
+++ b/shark/src/main/java/shark/internal/DominatorTree.kt
@@ -0,0 +1,215 @@
+@file:Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER", "CANNOT_OVERRIDE_INVISIBLE_MEMBER")
+package shark.internal
+
+import shark.ValueHolder
+import shark.internal.ObjectDominators.DominatorNode
+import shark.internal.hppc.LongLongScatterMap
+import shark.internal.hppc.LongLongScatterMap.ForEachCallback
+import shark.internal.hppc.LongScatterSet
+
+internal class DominatorTree(expectedElements: Int = 4) {
+
+  /**
+   * Map of objects to their dominator.
+   *
+   * If an object is dominated by more than one GC root then its dominator is set to
+   * [ValueHolder.NULL_REFERENCE].
+   */
+  private val dominated = LongLongScatterMap(expectedElements)
+
+  /**
+   * Records that [objectId] is a root.
+   */
+  fun updateDominatedAsRoot(objectId: Long): Boolean {
+    return updateDominated(objectId, ValueHolder.NULL_REFERENCE)
+  }
+
+  /**
+   * Records that [objectId] can be reached through [parentObjectId], updating the dominator for
+   * [objectId] to be either [parentObjectId] if [objectId] has no known dominator and otherwise to
+   * the Lowest Common Dominator between [parentObjectId] and the previously determined dominator
+   * for [objectId].
+   *
+   * [parentObjectId] should already have been added via [updateDominatedAsRoot]. Failing to do
+   * that will throw [IllegalStateException] on future calls.
+   *
+   * This implementation is optimized with the assumption that the graph is visited as a breadth
+   * first search, so when objectId already has a known dominator then its dominator path is
+   * shorter than the dominator path of [parentObjectId].
+   *
+   * @return true if [objectId] already had a known dominator, false otherwise.
+   */
+  fun updateDominated(
+    objectId: Long,
+    parentObjectId: Long
+  ): Boolean {
+    val dominatedSlot = dominated.getSlot(objectId)
+
+    val hasDominator = dominatedSlot != -1
+
+    if (!hasDominator || parentObjectId == ValueHolder.NULL_REFERENCE) {
+      dominated[objectId] = parentObjectId
+    } else {
+      val currentDominator = dominated.getSlotValue(dominatedSlot)
+      if (currentDominator != ValueHolder.NULL_REFERENCE) {
+        // We're looking for the Lowest Common Dominator between currentDominator and
+        // parentObjectId. We know that currentDominator likely has a shorter dominator path than
+        // parentObjectId since we're exploring the graph with a breadth first search. So we build
+        // a temporary hash set for the dominator path of currentDominator (since it's smaller)
+        // and then go through the dominator path of parentObjectId checking if any id exists
+        // in that hash set.
+        // Once we find either a common dominator or none, we update the map accordingly
+        val currentDominators = LongScatterSet()
+        var dominator = currentDominator
+        while (dominator != ValueHolder.NULL_REFERENCE) {
+          currentDominators.add(dominator)
+          val nextDominatorSlot = dominated.getSlot(dominator)
+          if (nextDominatorSlot == -1) {
+            throw IllegalStateException(
+              "Did not find dominator for $dominator when going through the dominator chain for $currentDominator: $currentDominators"
+            )
+          } else {
+            dominator = dominated.getSlotValue(nextDominatorSlot)
+          }
+        }
+        dominator = parentObjectId
+        while (dominator != ValueHolder.NULL_REFERENCE) {
+          if (dominator in currentDominators) {
+            break
+          }
+          val nextDominatorSlot = dominated.getSlot(dominator)
+          if (nextDominatorSlot == -1) {
+            throw IllegalStateException(
+              "Did not find dominator for $dominator when going through the dominator chain for $parentObjectId"
+            )
+          } else {
+            dominator = dominated.getSlotValue(nextDominatorSlot)
+          }
+        }
+        dominated[objectId] = dominator
+      }
+    }
+    return hasDominator
+  }
+
+  private class MutableDominatorNode {
+    var shallowSize = 0
+    var retainedSize = 0
+    var retainedCount = 0
+    val dominated = mutableListOf<Long>()
+  }
+
+  fun buildFullDominatorTree(computeSize: (Long) -> Int): Map<Long, DominatorNode> {
+    val dominators = mutableMapOf<Long, MutableDominatorNode>()
+    dominated.forEach(ForEachCallback {key, value ->
+      // create entry for dominated
+      dominators.getOrPut(key) {
+        MutableDominatorNode()
+      }
+      // If dominator is null ref then we still have an entry for that, to collect all dominator
+      // roots.
+      dominators.getOrPut(value) {
+        MutableDominatorNode()
+      }.dominated += key
+    })
+
+    val allReachableObjectIds = dominators.keys.toSet() - ValueHolder.NULL_REFERENCE
+
+    val retainedSizes = computeRetainedSizes(allReachableObjectIds) { objectId ->
+      val shallowSize = computeSize(objectId)
+      dominators.getValue(objectId).shallowSize = shallowSize
+      shallowSize
+    }
+
+    dominators.forEach { (objectId, node) ->
+      if (objectId != ValueHolder.NULL_REFERENCE) {
+        val (retainedSize, retainedCount) = retainedSizes.getValue(objectId)
+        node.retainedSize = retainedSize
+        node.retainedCount = retainedCount
+      }
+    }
+
+    val rootDominator = dominators.getValue(ValueHolder.NULL_REFERENCE)
+    rootDominator.retainedSize = rootDominator.dominated.map { dominators[it]!!.retainedSize }.sum()
+    rootDominator.retainedCount =
+      rootDominator.dominated.map { dominators[it]!!.retainedCount }.sum()
+
+    // Sort children with largest retained first
+    dominators.values.forEach { node ->
+      node.dominated.sortBy { -dominators.getValue(it).retainedSize }
+    }
+
+    return dominators.mapValues { (_, node) ->
+      DominatorNode(
+        node.shallowSize, node.retainedSize, node.retainedCount, node.dominated
+      )
+    }
+  }
+
+  /**
+   * Computes the size retained by [retainedObjectIds] using the dominator tree built using
+   * [updateDominatedAsRoot]. The shallow size of each object is provided by [computeSize].
+   * @return a map of object id to retained size.
+   */
+  fun computeRetainedSizes(
+    retainedObjectIds: Set<Long>,
+    computeSize: (Long) -> Int
+  ): Map<Long, Pair<Int, Int>> {
+    val nodeRetainedSizes = mutableMapOf<Long, Pair<Int, Int>>()
+    retainedObjectIds.forEach { objectId ->
+      nodeRetainedSizes[objectId] = 0 to 0
+    }
+
+    dominated.forEach(object : ForEachCallback {
+      override fun onEntry(
+        key: Long,
+        value: Long
+      ) {
+        // lazy computing of instance size
+        var instanceSize = -1
+
+        // If the entry is a node, add its size to nodeRetainedSizes
+        nodeRetainedSizes[key]?.let { (currentRetainedSize, currentRetainedCount) ->
+          instanceSize = computeSize(key)
+          nodeRetainedSizes[key] = currentRetainedSize + instanceSize to currentRetainedCount + 1
+        }
+
+        if (value != ValueHolder.NULL_REFERENCE) {
+          var dominator = value
+          val dominatedByNextNode = mutableListOf(key)
+          while (dominator != ValueHolder.NULL_REFERENCE) {
+            // If dominator is a node
+            if (nodeRetainedSizes.containsKey(dominator)) {
+              // Update dominator for all objects in the dominator path so far to directly point
+              // to it. We're compressing the dominator path to make this iteration faster and
+              // faster as we go through each entry.
+              dominatedByNextNode.forEach { objectId ->
+                dominated[objectId] = dominator
+              }
+              if (instanceSize == -1) {
+                instanceSize = computeSize(key)
+              }
+              // Update retained size for that node
+              val (currentRetainedSize, currentRetainedCount) = nodeRetainedSizes.getValue(
+                dominator
+              )
+              nodeRetainedSizes[dominator] =
+                (currentRetainedSize + instanceSize) to currentRetainedCount + 1
+              dominatedByNextNode.clear()
+            } else {
+              dominatedByNextNode += dominator
+            }
+            dominator = dominated[dominator]
+          }
+          // Update all dominator for all objects found in the dominator path after the last node
+          dominatedByNextNode.forEach { objectId ->
+            dominated[objectId] = ValueHolder.NULL_REFERENCE
+          }
+        }
+      }
+    })
+    dominated.release()
+
+    return nodeRetainedSizes
+  }
+}
diff --git a/shark/src/main/java/shark/internal/FieldIdReader.kt b/shark/src/main/java/shark/internal/FieldIdReader.kt
new file mode 100644
index 00000000..3ba69b1f
--- /dev/null
+++ b/shark/src/main/java/shark/internal/FieldIdReader.kt
@@ -0,0 +1,79 @@
+package shark.internal
+
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+
+/**
+ * Simplified version of [FieldValuesReader] class that can only read an ID or skip a certain
+ * amount of bytes.
+ */
+internal class FieldIdReader(
+  private val record: InstanceDumpRecord,
+  private val identifierByteSize: Int
+) {
+
+  private var position = 0
+
+  fun readId(): Long {
+    // As long as we don't interpret IDs, reading signed values here is fine.
+    val value = when (identifierByteSize) {
+      1 -> readByteId(position, record.fieldValues)
+      2 -> readShortId(position, record.fieldValues)
+      4 -> readIntId(position, record.fieldValues)
+      8 -> readLongId(position, record.fieldValues)
+      else -> error("ID Length must be 1, 2, 4, or 8")
+    }
+    position += identifierByteSize
+    return value
+  }
+
+  fun skipBytes(count: Int) {
+    position += count
+  }
+
+  private fun readByteId(
+    index: Int,
+    array: ByteArray
+  ) =
+    array[index].toLong()
+
+  private fun readShortId(
+    index: Int,
+    array: ByteArray
+  ): Long {
+    var pos = index
+    return (array[pos++] and 0xff shl 8
+      or (array[pos] and 0xff)).toLong()
+  }
+
+  private fun readIntId(
+    index: Int,
+    array: ByteArray
+  ): Long {
+    var pos = index
+    return (array[pos++] and 0xff shl 24
+      or (array[pos++] and 0xff shl 16)
+      or (array[pos++] and 0xff shl 8)
+      or (array[pos] and 0xff)).toLong()
+  }
+
+  private fun readLongId(
+    index: Int,
+    array: ByteArray
+  ): Long {
+    var pos = index
+    return (array[pos++] and 0xffL shl 56
+      or (array[pos++] and 0xffL shl 48)
+      or (array[pos++] and 0xffL shl 40)
+      or (array[pos++] and 0xffL shl 32)
+      or (array[pos++] and 0xffL shl 24)
+      or (array[pos++] and 0xffL shl 16)
+      or (array[pos++] and 0xffL shl 8)
+      or (array[pos] and 0xffL))
+  }
+
+  @Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+  private inline infix fun Byte.and(other: Long): Long = toLong() and other
+
+  @Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+  private inline infix fun Byte.and(other: Int): Int = toInt() and other
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/internal/FieldInstanceReferenceReader.kt b/shark/src/main/java/shark/internal/FieldInstanceReferenceReader.kt
new file mode 100644
index 00000000..9c038804
--- /dev/null
+++ b/shark/src/main/java/shark/internal/FieldInstanceReferenceReader.kt
@@ -0,0 +1,196 @@
+package shark.internal
+
+import java.util.LinkedHashMap
+import kotlin.LazyThreadSafetyMode.NONE
+import shark.HeapGraph
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.IgnoredReferenceMatcher
+import shark.LibraryLeakReferenceMatcher
+import shark.PrimitiveType
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.BYTE
+import shark.PrimitiveType.CHAR
+import shark.PrimitiveType.DOUBLE
+import shark.PrimitiveType.FLOAT
+import shark.PrimitiveType.INT
+import shark.PrimitiveType.LONG
+import shark.PrimitiveType.SHORT
+import shark.internal.Reference.LazyDetails
+import shark.internal.ReferenceLocationType.INSTANCE_FIELD
+import shark.ReferenceMatcher
+import shark.ReferencePattern.InstanceFieldPattern
+import shark.filterFor
+
+/**
+ * Expands instance fields that hold non null references.
+ */
+internal class FieldInstanceReferenceReader(
+  graph: HeapGraph,
+  referenceMatchers: List<ReferenceMatcher>
+) : ReferenceReader<HeapInstance> {
+
+  private val fieldNameByClassName: Map<String, Map<String, ReferenceMatcher>>
+  private val javaLangObjectId: Long
+
+  private val sizeOfObjectInstances: Int
+
+  init {
+    val objectClass = graph.findClassByName("java.lang.Object")
+    javaLangObjectId = objectClass?.objectId ?: -1
+    sizeOfObjectInstances = determineSizeOfObjectInstances(objectClass, graph)
+
+    val fieldNameByClassName = mutableMapOf<String, MutableMap<String, ReferenceMatcher>>()
+    referenceMatchers.filterFor(graph).forEach { referenceMatcher ->
+      val pattern = referenceMatcher.pattern
+      if (pattern is InstanceFieldPattern) {
+        val mapOrNull = fieldNameByClassName[pattern.className]
+        val map = if (mapOrNull != null) mapOrNull else {
+          val newMap = mutableMapOf<String, ReferenceMatcher>()
+          fieldNameByClassName[pattern.className] = newMap
+          newMap
+        }
+        map[pattern.fieldName] = referenceMatcher
+      }
+    }
+    this.fieldNameByClassName = fieldNameByClassName
+  }
+
+  override fun read(source: HeapInstance): Sequence<Reference> {
+    if (source.isPrimitiveWrapper ||
+      // We ignore the fact that String references a value array to avoid having
+      // to read the string record and find the object id for that array, since we know
+      // it won't be interesting anyway.
+      // That also means the value array isn't added to the dominator tree, so we need to
+      // add that back when computing shallow size in ShallowSizeCalculator.
+      // Another side effect is that if the array is referenced elsewhere, we might
+      // double count its side.
+      source.instanceClassName == "java.lang.String" ||
+      source.instanceClass.instanceByteSize <= sizeOfObjectInstances
+    ) {
+      return emptySequence()
+    }
+
+    val fieldReferenceMatchers = LinkedHashMap<String, ReferenceMatcher>()
+
+    val classHierarchy = source.instanceClass.classHierarchyWithoutJavaLangObject(javaLangObjectId)
+
+    classHierarchy.forEach {
+      val referenceMatcherByField = fieldNameByClassName[it.name]
+      if (referenceMatcherByField != null) {
+        for ((fieldName, referenceMatcher) in referenceMatcherByField) {
+          if (!fieldReferenceMatchers.containsKey(fieldName)) {
+            fieldReferenceMatchers[fieldName] = referenceMatcher
+          }
+        }
+      }
+    }
+
+    return with(source) {
+      // Assigning to local variable to avoid repeated lookup and cast:
+      // HeapInstance.graph casts HeapInstance.hprofGraph to HeapGraph in its getter
+      val hprofGraph = graph
+      val fieldReader by lazy(NONE) {
+        FieldIdReader(readRecord(), hprofGraph.identifierByteSize)
+      }
+      val result = mutableListOf<Pair<String, Reference>>()
+      var skipBytesCount = 0
+
+      for (heapClass in classHierarchy) {
+        for (fieldRecord in heapClass.readRecordFields()) {
+          if (fieldRecord.type != PrimitiveType.REFERENCE_HPROF_TYPE) {
+            // Skip all fields that are not references. Track how many bytes to skip
+            skipBytesCount += hprofGraph.getRecordSize(fieldRecord)
+          } else {
+            // Skip the accumulated bytes offset
+            fieldReader.skipBytes(skipBytesCount)
+            skipBytesCount = 0
+            val valueObjectId = fieldReader.readId()
+            if (valueObjectId != 0L) {
+              val name = heapClass.instanceFieldName(fieldRecord)
+              val referenceMatcher = fieldReferenceMatchers[name]
+              if (referenceMatcher !is IgnoredReferenceMatcher) {
+                val locationClassObjectId = heapClass.objectId
+                result.add(
+                  name to Reference(
+                    valueObjectId = valueObjectId,
+                    isLowPriority = referenceMatcher != null,
+                    lazyDetailsResolver = {
+                      LazyDetails(
+                        name = name,
+                        locationClassObjectId = locationClassObjectId,
+                        locationType = INSTANCE_FIELD,
+                        matchedLibraryLeak = referenceMatcher as LibraryLeakReferenceMatcher?,
+                        isVirtual = false
+                      )
+                    }
+                  )
+                )
+              }
+            }
+          }
+        }
+      }
+      result.sortBy { it.first }
+      result.asSequence().map { it.second }
+    }
+  }
+
+  /**
+   * Returns class hierarchy for an instance, but without it's root element, which is always
+   * java.lang.Object.
+   * Why do we want class hierarchy without java.lang.Object?
+   * In pre-M there were no ref fields in java.lang.Object; and FieldIdReader wouldn't be created
+   * Android M added shadow$_klass_ reference to class, so now it triggers extra record read.
+   * Solution: skip heap class for java.lang.Object completely when reading the records
+   * @param javaLangObjectId ID of the java.lang.Object to run comparison against
+   */
+  private fun HeapClass.classHierarchyWithoutJavaLangObject(
+    javaLangObjectId: Long
+  ): List<HeapClass> {
+    val result = mutableListOf<HeapClass>()
+    var parent: HeapClass? = this
+    while (parent != null && parent.objectId != javaLangObjectId) {
+      result += parent
+      parent = parent.superclass
+    }
+    return result
+  }
+
+  private fun HeapGraph.getRecordSize(field: FieldRecord) =
+    when (field.type) {
+      PrimitiveType.REFERENCE_HPROF_TYPE -> identifierByteSize
+      BOOLEAN.hprofType -> 1
+      CHAR.hprofType -> 2
+      FLOAT.hprofType -> 4
+      DOUBLE.hprofType -> 8
+      BYTE.hprofType -> 1
+      SHORT.hprofType -> 2
+      INT.hprofType -> 4
+      LONG.hprofType -> 8
+      else -> throw IllegalStateException("Unknown type ${field.type}")
+    }
+
+  private fun determineSizeOfObjectInstances(
+    objectClass: HeapClass?,
+    graph: HeapGraph
+  ): Int {
+    return if (objectClass != null) {
+      // In Android 16 ClassDumpRecord.instanceSize for java.lang.Object can be 8 yet there are 0
+      // fields. This is likely because there is extra per instance data that isn't coming from
+      // fields in the Object class. See #1374
+      val objectClassFieldSize = objectClass.readFieldsByteSize()
+
+      // shadow$_klass_ (object id) + shadow$_monitor_ (Int)
+      val sizeOfObjectOnArt = graph.identifierByteSize + INT.byteSize
+      if (objectClassFieldSize == sizeOfObjectOnArt) {
+        sizeOfObjectOnArt
+      } else {
+        0
+      }
+    } else {
+      0
+    }
+  }
+}
diff --git a/shark/src/main/java/shark/internal/GcRootProvider.kt b/shark/src/main/java/shark/internal/GcRootProvider.kt
new file mode 100644
index 00000000..3068db7f
--- /dev/null
+++ b/shark/src/main/java/shark/internal/GcRootProvider.kt
@@ -0,0 +1,156 @@
+package shark.internal
+
+import shark.GcRoot
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.JniGlobal
+import shark.GcRoot.ThreadObject
+import shark.HeapGraph
+import shark.HeapObject
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.IgnoredReferenceMatcher
+import shark.LibraryLeakReferenceMatcher
+import shark.ReferenceMatcher
+import shark.ReferencePattern.NativeGlobalVariablePattern
+import shark.filterFor
+
+/**
+ * Extracted from PathFinder, this should eventually be part of public API surface
+ * and we should likely also revisit the gc root type filtering which happens during
+ * heap parsing, as that's not really a concern for the heap parser and more for path
+ * finding. There are probably memory concerns as well there though. We could:
+ * - compress the storing of these roots
+ * - keep only the roots locations and read / deserialize as needed
+ * - Ensure a unique / consistent view of roots by doing the work of GcRootProvider
+ * at parsing time and keeping that list.
+ */
+internal class GcRootProvider(
+  private val graph: HeapGraph,
+  referenceMatchers: List<ReferenceMatcher>
+) {
+
+  private val jniGlobalReferenceMatchers: Map<String, ReferenceMatcher>
+
+  init {
+    val jniGlobals = mutableMapOf<String, ReferenceMatcher>()
+    referenceMatchers.filterFor(graph).forEach { referenceMatcher ->
+      when (val pattern = referenceMatcher.pattern) {
+        is NativeGlobalVariablePattern -> {
+          jniGlobals[pattern.className] = referenceMatcher
+        }
+      }
+    }
+    this.jniGlobalReferenceMatchers = jniGlobals
+  }
+
+  class GcRootReference(
+    val gcRoot: GcRoot,
+    val isLowPriority: Boolean,
+    val matchedLibraryLeak: LibraryLeakReferenceMatcher?,
+  )
+
+  fun provideGcRoots(): Sequence<GcRootReference> {
+    return sortedGcRoots().asSequence().mapNotNull { (heapObject, gcRoot) ->
+      when (gcRoot) {
+        // Note: in sortedGcRoots we already filter out any java frame that has an associated
+        // thread. These are the remaining ones (shouldn't be any, this is just in case).
+        is JavaFrame -> {
+          GcRootReference(
+            gcRoot,
+            isLowPriority = true,
+            matchedLibraryLeak = null
+          )
+        }
+        is JniGlobal -> {
+          val referenceMatcher = when (heapObject) {
+            is HeapClass -> jniGlobalReferenceMatchers[heapObject.name]
+            is HeapInstance -> jniGlobalReferenceMatchers[heapObject.instanceClassName]
+            is HeapObjectArray -> jniGlobalReferenceMatchers[heapObject.arrayClassName]
+            is HeapPrimitiveArray -> jniGlobalReferenceMatchers[heapObject.arrayClassName]
+          }
+          if (referenceMatcher !is IgnoredReferenceMatcher) {
+            if (referenceMatcher is LibraryLeakReferenceMatcher) {
+              GcRootReference(
+                gcRoot,
+                isLowPriority = true,
+                matchedLibraryLeak = referenceMatcher
+              )
+            } else {
+              GcRootReference(
+                gcRoot,
+                isLowPriority = false,
+                matchedLibraryLeak = null
+              )
+            }
+          } else {
+            null
+          }
+        }
+        else -> {
+          GcRootReference(
+            gcRoot,
+            isLowPriority = false,
+            matchedLibraryLeak = null
+          )
+        }
+      }
+    }
+  }
+
+  /**
+   * Sorting GC roots to get stable shortest path
+   * Once sorted all ThreadObject Gc Roots are located before JavaLocalPattern Gc Roots.
+   * This ensures ThreadObjects are visited before JavaFrames, and threadsBySerialNumber can be
+   * built before JavaFrames.
+   */
+  private fun sortedGcRoots(): List<Pair<HeapObject, GcRoot>> {
+    val rootClassName: (HeapObject) -> String = { graphObject ->
+      when (graphObject) {
+        is HeapClass -> {
+          graphObject.name
+        }
+        is HeapInstance -> {
+          graphObject.instanceClassName
+        }
+        is HeapObjectArray -> {
+          graphObject.arrayClassName
+        }
+        is HeapPrimitiveArray -> {
+          graphObject.arrayClassName
+        }
+      }
+    }
+
+    val threadSerialNumbers =
+      ThreadObjects.getThreadObjects(graph).map { it.threadSerialNumber }.toSet()
+
+    return graph.gcRoots
+      .filter { gcRoot ->
+        // GC roots sometimes reference objects that don't exist in the heap dump
+        // See https://github.com/square/leakcanary/issues/1516
+        graph.objectExists(gcRoot.id) &&
+          // Only include java frames that do not have a corresponding ThreadObject.
+          // JavaLocalReferenceReader will insert the other java frames.
+          !(gcRoot is JavaFrame && gcRoot.threadSerialNumber in threadSerialNumbers)
+      }
+      .map { graph.findObjectById(it.id) to it }
+      .sortedWith { (graphObject1, root1), (graphObject2, root2) ->
+        // Sorting based on pattern name first, but we want ThreadObjects to be first because
+        // they'll later enqueue java frames via JavaLocalReferenceReader in the low priority queue
+        // and we want those java frames at the head of the low priority queue.
+        if (root1 is ThreadObject && root2 !is ThreadObject) {
+          return@sortedWith -1
+        } else if (root1 !is ThreadObject && root2 is ThreadObject) {
+          return@sortedWith 1
+        }
+        val gcRootTypeComparison = root2::class.java.name.compareTo(root1::class.java.name)
+        if (gcRootTypeComparison != 0) {
+          gcRootTypeComparison
+        } else {
+          rootClassName(graphObject1).compareTo(rootClassName(graphObject2))
+        }
+      }
+  }
+}
diff --git a/shark/src/main/java/shark/internal/InternalSharedExpanderHelpers.kt b/shark/src/main/java/shark/internal/InternalSharedExpanderHelpers.kt
new file mode 100644
index 00000000..dc329a9d
--- /dev/null
+++ b/shark/src/main/java/shark/internal/InternalSharedExpanderHelpers.kt
@@ -0,0 +1,199 @@
+package shark.internal
+
+import shark.internal.ChainingInstanceReferenceReader.VirtualInstanceReferenceReader
+import shark.HeapObject.HeapInstance
+import shark.HeapValue
+import shark.internal.Reference.LazyDetails
+import shark.internal.ReferenceLocationType.ARRAY_ENTRY
+
+internal class InternalSharedHashMapReferenceReader(
+  private val className: String,
+  private val tableFieldName: String,
+  private val nodeClassName: String,
+  private val nodeNextFieldName: String,
+  private val nodeKeyFieldName: String,
+  private val nodeValueFieldName: String,
+  private val keyName: String,
+  private val keysOnly: Boolean,
+  private val matches: (HeapInstance) -> Boolean,
+  private val declaringClassId: (HeapInstance) -> (Long)
+) : VirtualInstanceReferenceReader {
+  override fun matches(instance: HeapInstance): Boolean {
+    return matches.invoke(instance)
+  }
+
+  override fun read(source: HeapInstance): Sequence<Reference> {
+    val table = source[className, tableFieldName]!!.valueAsObjectArray
+    return if (table != null) {
+      val entries = table.readElements().mapNotNull { entryRef ->
+        if (entryRef.isNonNullReference) {
+          val entry = entryRef.asObject!!.asInstance!!
+          generateSequence(entry) { node ->
+            node[nodeClassName, nodeNextFieldName]!!.valueAsInstance
+          }
+        } else {
+          null
+        }
+      }.flatten()
+
+      val declaringClassId = declaringClassId(source)
+
+      val createKeyRef: (HeapValue) -> Reference? = { key ->
+        if (key.isNonNullReference) {
+          Reference(
+            valueObjectId = key.asObjectId!!,
+            isLowPriority = false,
+            lazyDetailsResolver = {
+              LazyDetails(
+                // All entries are represented by the same key name, e.g. "key()"
+                name = keyName,
+                locationClassObjectId = declaringClassId,
+                locationType = ARRAY_ENTRY,
+                isVirtual = true,
+                matchedLibraryLeak = null
+              )
+            }
+          )
+        } else null
+      }
+
+      if (keysOnly) {
+        entries.mapNotNull { entry ->
+          val key = entry[nodeClassName, nodeKeyFieldName]!!.value
+          createKeyRef(key)
+        }
+      } else {
+        entries.flatMap { entry ->
+          val key = entry[nodeClassName, nodeKeyFieldName]!!.value
+          val keyRef = createKeyRef(key)
+          val value = entry[nodeClassName, nodeValueFieldName]!!.value
+          val valueRef = if (value.isNonNullReference) {
+            Reference(
+              valueObjectId = value.asObjectId!!,
+              isLowPriority = false,
+              lazyDetailsResolver = {
+                val keyAsString = key.asObject?.asInstance?.readAsJavaString()?.let { "\"$it\"" }
+                val keyAsName =
+                  keyAsString ?: key.asObject?.toString() ?: "null"
+                LazyDetails(
+                  name = keyAsName,
+                  locationClassObjectId = declaringClassId,
+                  locationType = ARRAY_ENTRY,
+                  isVirtual = true,
+                  matchedLibraryLeak = null
+                )
+              }
+            )
+          } else null
+          if (keyRef != null && valueRef != null) {
+            sequenceOf(keyRef, valueRef)
+          } else if (keyRef != null) {
+            sequenceOf(keyRef)
+          } else if (valueRef != null) {
+            sequenceOf(valueRef)
+          } else {
+            emptySequence()
+          }
+        }
+      }
+    } else {
+      emptySequence()
+    }
+  }
+}
+
+internal class InternalSharedArrayListReferenceReader(
+  private val className: String,
+  private val classObjectId: Long,
+  private val elementArrayName: String,
+  private val sizeFieldName: String?
+) : VirtualInstanceReferenceReader {
+
+  override fun matches(instance: HeapInstance): Boolean {
+    return instance.instanceClassId == classObjectId
+  }
+
+  override fun read(source: HeapInstance): Sequence<Reference> {
+    val instanceClassId = source.instanceClassId
+    val elementFieldRef =
+      source[className, elementArrayName]!!.valueAsObjectArray ?: return emptySequence()
+
+    val elements = if (sizeFieldName != null) {
+      val size = source[className, sizeFieldName]!!.value.asInt!!
+      elementFieldRef.readElements().take(size)
+    } else {
+      elementFieldRef.readElements()
+    }
+    return elements.withIndex()
+      .mapNotNull { (index, elementValue) ->
+        if (elementValue.isNonNullReference) {
+          Reference(
+            valueObjectId = elementValue.asObjectId!!,
+            isLowPriority = false,
+            lazyDetailsResolver = {
+              LazyDetails(
+                name = "$index",
+                locationClassObjectId = instanceClassId,
+                locationType = ARRAY_ENTRY,
+                isVirtual = true,
+                matchedLibraryLeak = null
+              )
+            }
+          )
+        } else {
+          null
+        }
+      }
+  }
+}
+
+internal class InternalSharedLinkedListReferenceReader(
+  private val classObjectId: Long,
+  private val headFieldName: String,
+  private val nodeClassName: String,
+  private val nodeNextFieldName: String,
+  private val nodeElementFieldName: String
+) : VirtualInstanceReferenceReader {
+
+  override fun matches(instance: HeapInstance): Boolean {
+    return instance.instanceClassId == classObjectId
+  }
+
+  override fun read(source: HeapInstance): Sequence<Reference> {
+    val instanceClassId = source.instanceClassId
+    // head may be null, in that case we generate an empty sequence.
+    val firstNode = source["java.util.LinkedList", headFieldName]!!.valueAsInstance
+    val visitedNodes = mutableSetOf<Long>()
+    if (firstNode != null) {
+      visitedNodes += firstNode.objectId
+    }
+    return generateSequence(firstNode) { node ->
+      val nextNode = node[nodeClassName, nodeNextFieldName]!!.valueAsInstance
+      if (nextNode != null && visitedNodes.add(nextNode.objectId)) {
+        nextNode
+      } else {
+        null
+      }
+    }
+      .withIndex()
+      .mapNotNull { (index, node) ->
+        val itemObjectId = node[nodeClassName, nodeElementFieldName]!!.value.asObjectId
+        itemObjectId?.run {
+          Reference(
+            valueObjectId = this,
+            isLowPriority = false,
+            lazyDetailsResolver = {
+              LazyDetails(
+                // All entries are represented by the same key name, e.g. "key()"
+                name = "$index",
+                locationClassObjectId = instanceClassId,
+                locationType = ARRAY_ENTRY,
+                isVirtual = true,
+                matchedLibraryLeak = null
+              )
+            }
+          )
+        }
+      }
+  }
+}
diff --git a/shark/src/main/java/shark/internal/InternalSharkCollectionsHelper.kt b/shark/src/main/java/shark/internal/InternalSharkCollectionsHelper.kt
new file mode 100644
index 00000000..99cf8718
--- /dev/null
+++ b/shark/src/main/java/shark/internal/InternalSharkCollectionsHelper.kt
@@ -0,0 +1,50 @@
+package shark.internal
+
+import shark.HeapObject
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+
+/**
+ * INTERNAL
+ *
+ * This class is public to be accessible from other LeakCanary modules but shouldn't be
+ * called directly, the API may break at any point.
+ */
+object InternalSharkCollectionsHelper {
+
+  fun arrayListValues(heapInstance: HeapInstance): Sequence<String> {
+    val graph = heapInstance.graph
+    val arrayListReader = OpenJdkInstanceRefReaders.ARRAY_LIST.create(graph)
+      ?: ApacheHarmonyInstanceRefReaders.ARRAY_LIST.create(graph)
+      ?: return emptySequence()
+
+    if (!arrayListReader.matches(heapInstance)) {
+      return emptySequence()
+    }
+
+    return arrayListReader.read(heapInstance).map { reference ->
+      val arrayListValue = graph.findObjectById(reference.valueObjectId)
+      val details = reference.lazyDetailsResolver.resolve()
+      "[${details.name}] = ${className(arrayListValue)}"
+    }
+  }
+
+  private fun className(graphObject: HeapObject): String {
+    return when (graphObject) {
+      is HeapClass -> {
+        graphObject.name
+      }
+      is HeapInstance -> {
+        graphObject.instanceClassName
+      }
+      is HeapObjectArray -> {
+        graphObject.arrayClassName
+      }
+      is HeapPrimitiveArray -> {
+        graphObject.arrayClassName
+      }
+    }
+  }
+}
diff --git a/shark/src/main/java/shark/internal/JavaFrames.kt b/shark/src/main/java/shark/internal/JavaFrames.kt
new file mode 100644
index 00000000..c566eddb
--- /dev/null
+++ b/shark/src/main/java/shark/internal/JavaFrames.kt
@@ -0,0 +1,20 @@
+package shark.internal
+
+import shark.GcRoot.JavaFrame
+import shark.HeapGraph
+
+internal object JavaFrames {
+
+  private fun getJavaFramesByThreadSerialNumber(graph: HeapGraph) =
+    graph.context.getOrPut(JavaFrames::class.java.name) {
+      graph.gcRoots.asSequence().filterIsInstance<JavaFrame>().groupBy { javaFrame ->
+        javaFrame.threadSerialNumber
+      }
+    }
+
+  fun getByThreadObjectId(graph: HeapGraph, threadObjectId: Long): List<JavaFrame>? {
+    val threadObject = ThreadObjects.getByThreadObjectId(graph, threadObjectId) ?: return null
+    val javaFrameByThreadSerial = getJavaFramesByThreadSerialNumber(graph)
+    return javaFrameByThreadSerial[threadObject.threadSerialNumber]
+  }
+}
diff --git a/shark/src/main/java/shark/internal/JavaLocalReferenceReader.kt b/shark/src/main/java/shark/internal/JavaLocalReferenceReader.kt
new file mode 100644
index 00000000..15e3734c
--- /dev/null
+++ b/shark/src/main/java/shark/internal/JavaLocalReferenceReader.kt
@@ -0,0 +1,77 @@
+package shark.internal
+
+import shark.HeapGraph
+import shark.internal.ChainingInstanceReferenceReader.VirtualInstanceReferenceReader
+import shark.HeapObject.HeapInstance
+import shark.IgnoredReferenceMatcher
+import shark.LibraryLeakReferenceMatcher
+import shark.internal.Reference.LazyDetails
+import shark.internal.ReferenceLocationType.LOCAL
+import shark.ReferenceMatcher
+import shark.ReferencePattern.JavaLocalPattern
+import shark.filterFor
+
+internal class JavaLocalReferenceReader(
+  val graph: HeapGraph,
+  referenceMatchers: List<ReferenceMatcher>
+) : VirtualInstanceReferenceReader {
+
+  private val threadClassObjectIds: Set<Long> =
+    graph.findClassByName(Thread::class.java.name)?.let { threadClass ->
+      setOf(threadClass.objectId) + (threadClass.subclasses
+        .map { it.objectId }
+        .toSet())
+    }?: emptySet()
+
+  private val threadNameReferenceMatchers: Map<String, ReferenceMatcher>
+
+  init {
+    val threadNames = mutableMapOf<String, ReferenceMatcher>()
+    referenceMatchers.filterFor(graph).forEach { referenceMatcher ->
+      when (val pattern = referenceMatcher.pattern) {
+        is JavaLocalPattern -> {
+          threadNames[pattern.threadName] = referenceMatcher
+        }
+      }
+    }
+    this.threadNameReferenceMatchers = threadNames
+  }
+
+  override fun matches(instance: HeapInstance): Boolean {
+    return instance.instanceClassId in threadClassObjectIds &&
+      ThreadObjects.getByThreadObjectId(graph, instance.objectId) != null
+  }
+
+  override fun read(source: HeapInstance): Sequence<Reference> {
+    val referenceMatcher =  source[Thread::class, "name"]?.value?.readAsJavaString()?.let { threadName ->
+      threadNameReferenceMatchers[threadName]
+    }
+
+    if (referenceMatcher is IgnoredReferenceMatcher) {
+      return emptySequence()
+    }
+    val threadClassId = source.instanceClassId
+    return JavaFrames.getByThreadObjectId(graph, source.objectId)?.let { frames ->
+      frames.asSequence().map { frame ->
+        Reference(
+          valueObjectId = frame.id,
+          // Java Frames always have low priority because their path is harder to understand
+          // for developers
+          isLowPriority = true,
+          lazyDetailsResolver = {
+            LazyDetails(
+              // Unfortunately Android heap dumps do not include stack trace data, so
+              // JavaFrame.frameNumber is always -1 and we cannot know which method is causing the
+              // reference to be held.
+              name = "",
+              locationClassObjectId = threadClassId,
+              locationType = LOCAL,
+              matchedLibraryLeak = referenceMatcher as LibraryLeakReferenceMatcher?,
+              isVirtual = true
+            )
+          }
+        )
+      }
+    } ?: emptySequence()
+  }
+}
diff --git a/shark/src/main/java/shark/internal/KeyedWeakReferenceMirror.kt b/shark/src/main/java/shark/internal/KeyedWeakReferenceMirror.kt
new file mode 100644
index 00000000..347c4293
--- /dev/null
+++ b/shark/src/main/java/shark/internal/KeyedWeakReferenceMirror.kt
@@ -0,0 +1,62 @@
+package shark.internal
+
+import shark.HeapObject.HeapInstance
+import shark.ValueHolder
+import shark.ValueHolder.ReferenceHolder
+
+internal class KeyedWeakReferenceMirror(
+  val referent: ReferenceHolder,
+  val key: String,
+  // The name field does not exist in pre 1.0 heap dumps.
+  val description: String,
+  // null in pre 2.0 alpha 3 heap dumps
+  val watchDurationMillis: Long?,
+  // null in pre 2.0 alpha 3 heap dumps, -1 if the instance is not retained.
+  val retainedDurationMillis: Long?
+) {
+
+  val hasReferent = referent.value != ValueHolder.NULL_REFERENCE
+
+  val isRetained = retainedDurationMillis == null || retainedDurationMillis != -1L
+
+  companion object {
+
+    private const val UNKNOWN_LEGACY = "Unknown (legacy)"
+
+    fun fromInstance(
+      weakRef: HeapInstance,
+      // Null for pre 2.0 alpha 3 heap dumps
+      heapDumpUptimeMillis: Long?
+    ): KeyedWeakReferenceMirror {
+
+      val keyWeakRefClassName = weakRef.instanceClassName
+      val watchDurationMillis = if (heapDumpUptimeMillis != null) {
+        heapDumpUptimeMillis - weakRef[keyWeakRefClassName, "watchUptimeMillis"]!!.value.asLong!!
+      } else {
+        null
+      }
+
+      val retainedDurationMillis = if (heapDumpUptimeMillis != null) {
+        val retainedUptimeMillis =
+          weakRef[keyWeakRefClassName, "retainedUptimeMillis"]!!.value.asLong!!
+        if (retainedUptimeMillis == -1L) -1L else heapDumpUptimeMillis - retainedUptimeMillis
+      } else {
+        null
+      }
+
+      val keyString = weakRef[keyWeakRefClassName, "key"]!!.value.readAsJavaString()!!
+
+      // Changed from name to description after 2.0
+      val description = (weakRef[keyWeakRefClassName, "description"]
+        ?: weakRef[keyWeakRefClassName, "name"])?.value?.readAsJavaString() ?: UNKNOWN_LEGACY
+      return KeyedWeakReferenceMirror(
+        watchDurationMillis = watchDurationMillis,
+        retainedDurationMillis = retainedDurationMillis,
+        referent = weakRef["java.lang.ref.Reference", "referent"]!!.value.holder as ReferenceHolder,
+        key = keyString,
+        description = description
+      )
+    }
+  }
+}
+
diff --git a/shark/src/main/java/shark/internal/ObjectArrayReferenceReader.kt b/shark/src/main/java/shark/internal/ObjectArrayReferenceReader.kt
new file mode 100644
index 00000000..9c52d438
--- /dev/null
+++ b/shark/src/main/java/shark/internal/ObjectArrayReferenceReader.kt
@@ -0,0 +1,55 @@
+package shark.internal
+
+import shark.HeapObject.HeapObjectArray
+import shark.internal.Reference.LazyDetails
+import shark.internal.ReferenceLocationType.ARRAY_ENTRY
+import shark.ValueHolder
+
+internal class ObjectArrayReferenceReader : ReferenceReader<HeapObjectArray> {
+  override fun read(source: HeapObjectArray): Sequence<Reference> {
+    if (source.isSkippablePrimitiveWrapperArray) {
+      // primitive wrapper arrays aren't interesting.
+      // That also means the wrapped size isn't added to the dominator tree, so we need to
+      // add that back when computing shallow size in ShallowSizeCalculator.
+      // Another side effect is that if the wrapped primitive is referenced elsewhere, we might
+      // double count its size.
+      return emptySequence()
+    }
+
+    val graph = source.graph
+    val record = source.readRecord()
+    val arrayClassId = source.arrayClassId
+    return record.elementIds.asSequence().filter { objectId ->
+      objectId != ValueHolder.NULL_REFERENCE && graph.objectExists(objectId)
+    }.mapIndexed { index, elementObjectId ->
+      Reference(
+        valueObjectId = elementObjectId,
+        isLowPriority = false,
+        lazyDetailsResolver = {
+          LazyDetails(
+            name = index.toString(),
+            locationClassObjectId = arrayClassId,
+            locationType = ARRAY_ENTRY,
+            isVirtual = false,
+            matchedLibraryLeak = null
+          )
+        }
+      )
+    }
+  }
+  internal companion object {
+    private val skippablePrimitiveWrapperArrayTypes = setOf(
+      Boolean::class,
+      Char::class,
+      Float::class,
+      Double::class,
+      Byte::class,
+      Short::class,
+      Int::class,
+      Long::class
+    ).map { it.javaObjectType.name + "[]" }
+
+    internal val HeapObjectArray.isSkippablePrimitiveWrapperArray: Boolean
+      get() = arrayClassName in skippablePrimitiveWrapperArrayTypes
+  }
+}
diff --git a/shark/src/main/java/shark/internal/ObjectDominators.kt b/shark/src/main/java/shark/internal/ObjectDominators.kt
new file mode 100644
index 00000000..94149f5e
--- /dev/null
+++ b/shark/src/main/java/shark/internal/ObjectDominators.kt
@@ -0,0 +1,164 @@
+package shark.internal
+
+import shark.GcRoot.ThreadObject
+import shark.HeapGraph
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.IgnoredReferenceMatcher
+import shark.OnAnalysisProgressListener
+import shark.ValueHolder
+
+/**
+ * Exposes high level APIs to compute and render a dominator tree. This class
+ * needs to be public to be used by other LeakCanary modules but is internal and
+ * its API might change at any moment.
+ *
+ * Note that the exposed APIs are not optimized for speed, memory or IO.
+ *
+ * Eventually this capability should become part of the Shark public APIs, please
+ * open an issue if you'd like to use this directly.
+ */
+class ObjectDominators {
+
+  internal data class DominatorNode(
+    val shallowSize: Int,
+    val retainedSize: Int,
+    val retainedCount: Int,
+    val dominatedObjectIds: List<Long>
+  )
+
+  fun renderDominatorTree(
+    graph: HeapGraph,
+    ignoredRefs: List<IgnoredReferenceMatcher>,
+    minRetainedSize: Int,
+    threadName: String? = null,
+    printStringContent: Boolean = false
+  ): String {
+    val stringBuilder = StringBuilder()
+
+    val dominatorTree = buildDominatorTree(graph, ignoredRefs)
+
+    val root = dominatorTree.getValue(ValueHolder.NULL_REFERENCE)
+    stringBuilder.append(
+      "Total retained: ${root.retainedSize} bytes in ${root.retainedCount} objects. Root dominators: ${root.dominatedObjectIds.size}\n\n"
+    )
+
+    val rootIds = if (threadName != null) {
+      setOf(graph.gcRoots.first { gcRoot ->
+        gcRoot is ThreadObject &&
+          graph.objectExists(gcRoot.id) &&
+          graph.findObjectById(gcRoot.id)
+            .asInstance!!["java.lang.Thread", "name"]!!
+            .value.readAsJavaString() == threadName
+      }.id)
+    } else {
+      root.dominatedObjectIds.filter { dominatorTree.getValue(it).retainedSize > minRetainedSize }
+    }
+
+    rootIds
+      .forEach { objectId ->
+        printTree(
+          stringBuilder, graph, dominatorTree, objectId, minRetainedSize, 0, "", true,
+          printStringContent
+        )
+        stringBuilder.append("\n")
+      }
+    return stringBuilder.toString()
+  }
+
+  @Suppress("LongParameterList")
+  private fun printTree(
+    stringBuilder: StringBuilder,
+    graph: HeapGraph,
+    tree: Map<Long, DominatorNode>,
+    objectId: Long,
+    minSize: Int,
+    depth: Int,
+    prefix: String,
+    isLast: Boolean,
+    printStringContent: Boolean
+  ) {
+    val node = tree.getValue(objectId)
+    val heapObject = graph.findObjectById(objectId)
+    val className = when (heapObject) {
+      is HeapClass -> "class ${heapObject.name}"
+      is HeapInstance -> heapObject.instanceClassName
+      is HeapObjectArray -> heapObject.arrayClassName
+      is HeapPrimitiveArray -> heapObject.arrayClassName
+    }
+    val anchor = if (depth == 0) "" else if (isLast) "â•°â”€" else "â”œâ”€"
+    val size = if (node.retainedSize != node.shallowSize) {
+      "${node.retainedSize} bytes (${node.shallowSize} self)"
+    } else {
+      "${node.shallowSize} bytes"
+    }
+    val count = if (node.retainedCount > 1) {
+      " ${node.retainedCount} objects"
+    } else {
+      ""
+    }
+    val stringContent = if (
+      printStringContent &&
+      heapObject is HeapInstance &&
+      heapObject.instanceClassName == "java.lang.String"
+    ) " \"${heapObject.readAsJavaString()}\"" else ""
+    stringBuilder.append(
+      "$prefix$anchor$className #${heapObject.objectIndex} Retained: $size$count$stringContent\n"
+    )
+
+    val newPrefix = when {
+      depth == 0 -> ""
+      isLast -> {
+        "$prefix  "
+      }
+      else -> {
+        "$prefixâ”‚ "
+      }
+    }
+
+    val largeChildren = node.dominatedObjectIds.filter { tree.getValue(it).retainedSize > minSize }
+    val lastIndex = node.dominatedObjectIds.lastIndex
+
+    largeChildren.forEachIndexed { index, objectId ->
+      printTree(
+        stringBuilder,
+        graph, tree, objectId, minSize, depth + 1, newPrefix,
+        index == lastIndex,
+        printStringContent
+      )
+    }
+    if (largeChildren.size < node.dominatedObjectIds.size) {
+      stringBuilder.append("$newPrefixâ•°â”„\n")
+    }
+  }
+
+  private fun buildDominatorTree(
+    graph: HeapGraph,
+    ignoredRefs: List<IgnoredReferenceMatcher>
+  ): Map<Long, DominatorNode> {
+    val referenceReader = DelegatingObjectReferenceReader(
+      classReferenceReader = ClassReferenceReader(graph, emptyList()),
+      instanceReferenceReader = ChainingInstanceReferenceReader(
+        listOf(JavaLocalReferenceReader(graph, emptyList())),
+        FieldInstanceReferenceReader(graph, emptyList())
+      ),      objectArrayReferenceReader = ObjectArrayReferenceReader()
+    )
+
+    val pathFinder = PathFinder(
+      graph,
+      OnAnalysisProgressListener.NO_OP, referenceReader,  ignoredRefs
+    )
+    val nativeSizeMapper = AndroidNativeSizeMapper(graph)
+    val nativeSizes = nativeSizeMapper.mapNativeSizes()
+    val shallowSizeCalculator = ShallowSizeCalculator(graph)
+
+    val result = pathFinder.findPathsFromGcRoots(setOf(), true)
+    return result.dominatorTree!!.buildFullDominatorTree { objectId ->
+      val nativeSize = nativeSizes[objectId] ?: 0
+      val shallowSize = shallowSizeCalculator.computeShallowSize(objectId)
+      nativeSize + shallowSize
+    }
+  }
+}
diff --git a/shark/src/main/java/shark/internal/OpenJdkInstanceRefReaders.kt b/shark/src/main/java/shark/internal/OpenJdkInstanceRefReaders.kt
new file mode 100644
index 00000000..8eaccae6
--- /dev/null
+++ b/shark/src/main/java/shark/internal/OpenJdkInstanceRefReaders.kt
@@ -0,0 +1,212 @@
+package shark.internal
+
+import shark.HeapGraph
+import shark.internal.ChainingInstanceReferenceReader.VirtualInstanceReferenceReader.OptionalFactory
+import shark.internal.ChainingInstanceReferenceReader.VirtualInstanceReferenceReader
+import shark.HeapObject.HeapInstance
+
+/**
+ * Defines [VirtualInstanceReferenceReader] factories for common OpenJDK data structures.
+ *
+ * Note: the expanders target the direct classes and don't target subclasses, as these might
+ * include additional out going references that would be missed.
+ */
+internal enum class OpenJdkInstanceRefReaders : OptionalFactory {
+
+  // https://cs.android.com/android/platform/superproject/+/master:libcore/ojluni/src/main/java/java/util/LinkedList.java
+  LINKED_LIST {
+    override fun create(graph: HeapGraph): VirtualInstanceReferenceReader? {
+      val linkedListClass = graph.findClassByName("java.util.LinkedList") ?: return null
+      val isOpenJdkImpl = linkedListClass.readRecordFields()
+        .any { linkedListClass.instanceFieldName(it) == "first" }
+
+      if (!isOpenJdkImpl) {
+        return null
+      }
+      return InternalSharedLinkedListReferenceReader(
+        classObjectId = linkedListClass.objectId,
+        headFieldName = "first",
+        nodeClassName = "java.util.LinkedList\$Node",
+        nodeNextFieldName = "next",
+        nodeElementFieldName = "item",
+      )
+    }
+  },
+
+  // https://cs.android.com/android/platform/superproject/+/master:libcore/ojluni/src/main/java/java/util/ArrayList.java
+  ARRAY_LIST {
+    override fun create(graph: HeapGraph): VirtualInstanceReferenceReader? {
+      val arrayListClass = graph.findClassByName("java.util.ArrayList") ?: return null
+
+      val isOpenJdkImpl = arrayListClass.readRecordFields()
+        .any { arrayListClass.instanceFieldName(it) == "elementData" }
+
+      if (!isOpenJdkImpl) {
+        return null
+      }
+
+      return InternalSharedArrayListReferenceReader(
+        className = "java.util.ArrayList",
+        classObjectId = arrayListClass.objectId,
+        elementArrayName = "elementData",
+        sizeFieldName = "size",
+      )
+    }
+  },
+
+  // https://cs.android.com/android/platform/superproject/+/master:libcore/ojluni/src/main/java/java/util/concurrent/CopyOnWriteArrayList.java;bpv=0;bpt=1
+  COPY_ON_WRITE_ARRAY_LIST {
+    override fun create(graph: HeapGraph): VirtualInstanceReferenceReader? {
+      val arrayListClass = graph.findClassByName("java.util.concurrent.CopyOnWriteArrayList") ?: return null
+
+      val isOpenJdkImpl = arrayListClass.readRecordFields()
+        .any { arrayListClass.instanceFieldName(it) == "array" }
+
+      if (!isOpenJdkImpl) {
+        return null
+      }
+
+      return InternalSharedArrayListReferenceReader(
+        className = "java.util.concurrent.CopyOnWriteArrayList",
+        classObjectId = arrayListClass.objectId,
+        elementArrayName = "array",
+        sizeFieldName = null,
+      )
+    }
+  },
+
+  // Initial import
+  // https://cs.android.com/android/_/android/platform/libcore/+/51b1b6997fd3f980076b8081f7f1165ccc2a4008:ojluni/src/main/java/java/util/HashMap.java
+  // Latest on master
+  // https://cs.android.com/android/platform/superproject/+/master:libcore/ojluni/src/main/java/java/util/HashMap.java
+  /**
+   * Handles HashMap & LinkedHashMap
+   */
+  HASH_MAP {
+    override fun create(graph: HeapGraph): VirtualInstanceReferenceReader? {
+      val hashMapClass = graph.findClassByName("java.util.HashMap") ?: return null
+
+      // No loadFactor field in the Apache Harmony impl.
+      val isOpenJdkImpl = hashMapClass.readRecordFields()
+        .any { hashMapClass.instanceFieldName(it) == "loadFactor" }
+
+      if (!isOpenJdkImpl) {
+        return null
+      }
+
+      val linkedHashMapClass = graph.findClassByName("java.util.LinkedHashMap")
+      // Initially Entry, changed to Node in JDK 1.8
+      val nodeClassName = if (graph.findClassByName("java.util.HashMap\$Entry") != null) {
+        "java.util.HashMap\$Entry"
+      } else if (graph.findClassByName("java.util.HashMap\$HashMapEntry") != null) {
+        "java.util.HashMap\$HashMapEntry"
+      } else {
+        "java.util.HashMap\$Node"
+      }
+
+      val hashMapClassId = hashMapClass.objectId
+      val linkedHashMapClassId = linkedHashMapClass?.objectId ?: 0
+
+      return InternalSharedHashMapReferenceReader(
+        className = "java.util.HashMap",
+        tableFieldName = "table",
+        nodeClassName = nodeClassName,
+        nodeNextFieldName = "next",
+        nodeKeyFieldName = "key",
+        nodeValueFieldName = "value",
+        keyName = "key()",
+        keysOnly = false,
+        matches = {
+          val instanceClassId = it.instanceClassId
+          instanceClassId == hashMapClassId || instanceClassId == linkedHashMapClassId
+        },
+        declaringClassId = { it.instanceClassId }
+      )
+    }
+  },
+
+  // https://cs.android.com/android/platform/superproject/+/master:libcore/ojluni/src/main/java/java/util/concurrent/ConcurrentHashMap.java
+  // Note: structure of impl shared by OpenJDK & Apache Harmony.
+  CONCURRENT_HASH_MAP {
+    override fun create(graph: HeapGraph): VirtualInstanceReferenceReader? {
+      val hashMapClass =
+        graph.findClassByName("java.util.concurrent.ConcurrentHashMap") ?: return null
+
+      // No table field in Apache Harmony impl (as seen on Android 4).
+      val isOpenJdkImpl = hashMapClass.readRecordFields()
+        .any { hashMapClass.instanceFieldName(it) == "table" }
+
+      if (!isOpenJdkImpl) {
+        return null
+      }
+
+      val hashMapClassId = hashMapClass.objectId
+      return InternalSharedHashMapReferenceReader(
+        className = "java.util.concurrent.ConcurrentHashMap",
+        tableFieldName = "table",
+        nodeClassName = "java.util.concurrent.ConcurrentHashMap\$Node",
+        nodeNextFieldName = "next",
+        nodeKeyFieldName = "key",
+        nodeValueFieldName = "val",
+        keyName = "key()",
+        keysOnly = false,
+        matches = { it.instanceClassId == hashMapClassId },
+        declaringClassId = { it.instanceClassId }
+      )
+    }
+  },
+
+  /**
+   * Handles HashSet & LinkedHashSet
+   */
+  HASH_SET {
+    override fun create(graph: HeapGraph): VirtualInstanceReferenceReader? {
+      val hashSetClass = graph.findClassByName("java.util.HashSet") ?: return null
+
+      val isOpenJdkImpl = hashSetClass.readRecordFields()
+        .any { hashSetClass.instanceFieldName(it) == "map" }
+
+      if (!isOpenJdkImpl) {
+        return null
+      }
+
+      val linkedHashSetClass = graph.findClassByName("java.util.LinkedHashSet")
+      // Initially Entry, changed to Node in JDK 1.8
+      val nodeClassName = if (graph.findClassByName("java.util.HashMap\$Entry") != null) {
+        "java.util.HashMap\$Entry"
+      } else if (graph.findClassByName("java.util.HashMap\$HashMapEntry") != null) {
+        "java.util.HashMap\$HashMapEntry"
+      } else {
+        "java.util.HashMap\$Node"
+      }
+      val hashSetClassId = hashSetClass.objectId
+      val linkedHashSetClassId = linkedHashSetClass?.objectId ?: 0
+      return object : VirtualInstanceReferenceReader {
+        override fun matches(instance: HeapInstance): Boolean {
+          val instanceClassId = instance.instanceClassId
+          return instanceClassId == hashSetClassId || instanceClassId == linkedHashSetClassId
+        }
+
+        override fun read(source: HeapInstance): Sequence<Reference> {
+          // "HashSet.map" is never null when looking at the Android sources history, however
+          // we've had a crash report where it was null on API 24.
+          // https://github.com/square/leakcanary/issues/2342
+          val map = source["java.util.HashSet", "map"]!!.valueAsInstance ?: return emptySequence()
+          return InternalSharedHashMapReferenceReader(
+            className = "java.util.HashMap",
+            tableFieldName = "table",
+            nodeClassName = nodeClassName,
+            nodeNextFieldName = "next",
+            nodeKeyFieldName = "key",
+            nodeValueFieldName = "value",
+            keyName = "element()",
+            keysOnly = true,
+            matches = { true },
+            declaringClassId = { source.instanceClassId }
+          ).read(map)
+        }
+      }
+    }
+  }
+  ;
+}
diff --git a/shark/src/main/java/shark/internal/PathFinder.kt b/shark/src/main/java/shark/internal/PathFinder.kt
new file mode 100644
index 00000000..c329b182
--- /dev/null
+++ b/shark/src/main/java/shark/internal/PathFinder.kt
@@ -0,0 +1,256 @@
+@file:Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER")
+
+package shark.internal
+
+import java.util.ArrayDeque
+import java.util.Deque
+import shark.HeapGraph
+import shark.HeapObject
+import shark.OnAnalysisProgressListener
+import shark.OnAnalysisProgressListener.Step.FINDING_DOMINATORS
+import shark.OnAnalysisProgressListener.Step.FINDING_PATHS_TO_RETAINED_OBJECTS
+import shark.ReferenceMatcher
+import shark.ValueHolder
+import shark.internal.PathFinder.VisitTracker.Dominated
+import shark.internal.PathFinder.VisitTracker.Visited
+import shark.internal.ReferencePathNode.ChildNode
+import shark.internal.ReferencePathNode.RootNode
+import shark.internal.ReferencePathNode.RootNode.LibraryLeakRootNode
+import shark.internal.ReferencePathNode.RootNode.NormalRootNode
+import shark.internal.hppc.LongScatterSet
+
+/**
+ * Not thread safe.
+ *
+ * Finds the shortest path from leaking references to a gc root, first ignoring references
+ * identified as "to visit last" and then visiting them as needed if no path is
+ * found.
+ */
+internal class PathFinder(
+  private val graph: HeapGraph,
+  private val listener: OnAnalysisProgressListener,
+  private val objectReferenceReader: ReferenceReader<HeapObject>,
+  referenceMatchers: List<ReferenceMatcher>
+) {
+
+  class PathFindingResults(
+    val pathsToLeakingObjects: List<ReferencePathNode>,
+    val dominatorTree: DominatorTree?
+  )
+
+  sealed class VisitTracker {
+
+    abstract fun visited(
+      objectId: Long,
+      parentObjectId: Long
+    ): Boolean
+
+    class Dominated(expectedElements: Int) : VisitTracker() {
+      /**
+       * Tracks visited objecs and their dominator.
+       * If an object is not in [dominatorTree] then it hasn't been enqueued yet.
+       * If an object is in [dominatorTree] but not in [State.toVisitSet] nor [State.toVisitLastSet]
+       * then it has already been dequeued.
+       *
+       * If an object is dominated by more than one GC root then its dominator is set to
+       * [ValueHolder.NULL_REFERENCE].
+       */
+      val dominatorTree = DominatorTree(expectedElements)
+      override fun visited(
+        objectId: Long,
+        parentObjectId: Long
+      ): Boolean {
+        return dominatorTree.updateDominated(objectId, parentObjectId)
+      }
+    }
+
+    class Visited(expectedElements: Int) : VisitTracker() {
+      /**
+       * Set of visited objects.
+       */
+      private val visitedSet = LongScatterSet(expectedElements)
+      override fun visited(
+        objectId: Long,
+        parentObjectId: Long
+      ): Boolean {
+        return !visitedSet.add(objectId)
+      }
+    }
+  }
+
+  private class State(
+    val leakingObjectIds: LongScatterSet,
+    val computeRetainedHeapSize: Boolean,
+    estimatedVisitedObjects: Int
+  ) {
+
+    /** Set of objects to visit */
+    val toVisitQueue: Deque<ReferencePathNode> = ArrayDeque()
+
+    /**
+     * Objects to visit when [toVisitQueue] is empty.
+     */
+    val toVisitLastQueue: Deque<ReferencePathNode> = ArrayDeque()
+
+    /**
+     * Enables fast checking of whether a node is already in the queue.
+     */
+    val toVisitSet = LongScatterSet()
+    val toVisitLastSet = LongScatterSet()
+
+    val queuesNotEmpty: Boolean
+      get() = toVisitQueue.isNotEmpty() || toVisitLastQueue.isNotEmpty()
+
+    val visitTracker = if (computeRetainedHeapSize) {
+      Dominated(estimatedVisitedObjects)
+    } else {
+      Visited(estimatedVisitedObjects)
+    }
+
+    /**
+     * A marker for when we're done exploring the graph of higher priority references and start
+     * visiting the lower priority references, at which point we won't add any reference to
+     * the high priority queue anymore.
+     */
+    var visitingLast = false
+  }
+
+  private val gcRootProvider = GcRootProvider(graph, referenceMatchers)
+
+  fun findPathsFromGcRoots(
+    leakingObjectIds: Set<Long>,
+    computeRetainedHeapSize: Boolean
+  ): PathFindingResults {
+    listener.onAnalysisProgress(FINDING_PATHS_TO_RETAINED_OBJECTS)
+    // Estimate of how many objects we'll visit. This is a conservative estimate, we should always
+    // visit more than that but this limits the number of early array growths.
+    val estimatedVisitedObjects = (graph.instanceCount / 2).coerceAtLeast(4)
+
+    val state = State(
+      leakingObjectIds = leakingObjectIds.toLongScatterSet(),
+      computeRetainedHeapSize = computeRetainedHeapSize,
+      estimatedVisitedObjects = estimatedVisitedObjects
+    )
+
+    return state.findPathsFromGcRoots()
+  }
+
+  private fun Set<Long>.toLongScatterSet(): LongScatterSet {
+    val longScatterSet = LongScatterSet()
+    longScatterSet.ensureCapacity(size)
+    forEach { longScatterSet.add(it) }
+    return longScatterSet
+  }
+
+  private fun State.findPathsFromGcRoots(): PathFindingResults {
+    enqueueGcRoots()
+
+    val shortestPathsToLeakingObjects = mutableListOf<ReferencePathNode>()
+    visitingQueue@ while (queuesNotEmpty) {
+      val node = poll()
+      if (leakingObjectIds.contains(node.objectId)) {
+        shortestPathsToLeakingObjects.add(node)
+        // Found all refs, stop searching (unless computing retained size)
+        if (shortestPathsToLeakingObjects.size == leakingObjectIds.size()) {
+          if (computeRetainedHeapSize) {
+            listener.onAnalysisProgress(FINDING_DOMINATORS)
+          } else {
+            break@visitingQueue
+          }
+        }
+      }
+
+      val heapObject = graph.findObjectById(node.objectId)
+      objectReferenceReader.read(heapObject).forEach { reference ->
+        val newNode = ChildNode(
+          objectId = reference.valueObjectId,
+          parent = node,
+          lazyDetailsResolver = reference.lazyDetailsResolver
+        )
+        enqueue(newNode, isLowPriority = reference.isLowPriority)
+      }
+    }
+    return PathFindingResults(
+      shortestPathsToLeakingObjects,
+      if (visitTracker is Dominated) visitTracker.dominatorTree else null
+    )
+  }
+
+  private fun State.poll(): ReferencePathNode {
+    return if (!visitingLast && !toVisitQueue.isEmpty()) {
+      val removedNode = toVisitQueue.poll()
+      toVisitSet.remove(removedNode.objectId)
+      removedNode
+    } else {
+      visitingLast = true
+      val removedNode = toVisitLastQueue.poll()
+      toVisitLastSet.remove(removedNode.objectId)
+      removedNode
+    }
+  }
+
+  private fun State.enqueueGcRoots() {
+    gcRootProvider.provideGcRoots().forEach { gcRootReference ->
+      enqueue(
+        gcRootReference.matchedLibraryLeak?.let { matchedLibraryLeak ->
+          LibraryLeakRootNode(
+            gcRootReference.gcRoot,
+            matchedLibraryLeak
+          )
+        } ?: NormalRootNode(
+          gcRootReference.gcRoot
+        ),
+        isLowPriority = gcRootReference.isLowPriority
+      )
+    }
+  }
+
+  @Suppress("ReturnCount")
+  private fun State.enqueue(
+    node: ReferencePathNode,
+    isLowPriority: Boolean
+  ) {
+    if (node.objectId == ValueHolder.NULL_REFERENCE) {
+      return
+    }
+
+    val parentObjectId = when (node) {
+      is RootNode -> ValueHolder.NULL_REFERENCE
+      is ChildNode -> node.parent.objectId
+    }
+
+    // Note: when computing dominators, this has a side effects of updating
+    // the dominator for node.objectId.
+    val alreadyEnqueued = visitTracker.visited(node.objectId, parentObjectId)
+
+    val visitLast = visitingLast || isLowPriority
+
+    when {
+      alreadyEnqueued -> {
+        val bumpPriority =
+          !visitLast &&
+            node.objectId !in toVisitSet &&
+            // This could be false if node had already been visited.
+            node.objectId in toVisitLastSet
+
+        if (bumpPriority) {
+          // Move from "visit last" to "visit first" queue.
+          toVisitQueue.add(node)
+          toVisitSet.add(node.objectId)
+          val nodeToRemove = toVisitLastQueue.first { it.objectId == node.objectId }
+          toVisitLastQueue.remove(nodeToRemove)
+          toVisitLastSet.remove(node.objectId)
+        }
+      }
+      visitLast -> {
+        toVisitLastQueue.add(node)
+        toVisitLastSet.add(node.objectId)
+      }
+      else -> {
+        toVisitQueue.add(node)
+        toVisitSet.add(node.objectId)
+      }
+    }
+  }
+}
+
diff --git a/shark/src/main/java/shark/internal/Reference.kt b/shark/src/main/java/shark/internal/Reference.kt
new file mode 100644
index 00000000..8fe675e9
--- /dev/null
+++ b/shark/src/main/java/shark/internal/Reference.kt
@@ -0,0 +1,48 @@
+package shark.internal
+
+import shark.LibraryLeakReferenceMatcher
+import shark.internal.Reference.LazyDetails.Resolver
+
+internal class Reference(
+  /**
+   * The value of the reference, i.e. the object the reference is pointing to.
+   */
+  val valueObjectId: Long,
+
+  /**
+   * Low priority references are references that should be explored after any non low priority
+   * reference has been explored. This ensures that such references are not on the shortest best
+   * path if there is any other path that doesn't include any low priority reference.
+   *
+   * This is useful to highlight references that most likely exist due to known leaks (which means
+   * we can potentially find unknown leaks instead) as well as references which are harder to
+   * interpret for developers (such as java locals).
+   */
+  val isLowPriority: Boolean,
+
+  val lazyDetailsResolver: Resolver
+) {
+  class LazyDetails(
+    val name: String,
+    val locationClassObjectId: Long,
+    val locationType: ReferenceLocationType,
+    /**
+     * Non null if this reference matches a known library leak pattern, null otherwise.
+     *
+     * Usually associated  with [Reference.isLowPriority] being true, so that the shortest path
+     * finder will only go through matching references after it has exhausted references that don't
+     * match, prioritizing finding an application leak over a known library leak.
+     */
+    val matchedLibraryLeak: LibraryLeakReferenceMatcher?,
+    // TODO Better name
+    val isVirtual: Boolean
+  ) {
+    /**
+     * Implementations should keep the minimal state they need and if needed rehydrate the objects
+     * when resolving.
+     */
+    fun interface Resolver {
+      fun resolve(): LazyDetails
+    }
+  }
+}
diff --git a/shark/src/main/java/shark/internal/ReferenceLocationType.kt b/shark/src/main/java/shark/internal/ReferenceLocationType.kt
new file mode 100644
index 00000000..e1c83db7
--- /dev/null
+++ b/shark/src/main/java/shark/internal/ReferenceLocationType.kt
@@ -0,0 +1,8 @@
+package shark.internal
+
+internal enum class ReferenceLocationType {
+  INSTANCE_FIELD,
+  STATIC_FIELD,
+  LOCAL,
+  ARRAY_ENTRY
+}
diff --git a/shark/src/main/java/shark/internal/ReferencePathNode.kt b/shark/src/main/java/shark/internal/ReferencePathNode.kt
new file mode 100644
index 00000000..9164145b
--- /dev/null
+++ b/shark/src/main/java/shark/internal/ReferencePathNode.kt
@@ -0,0 +1,33 @@
+package shark.internal
+
+import shark.GcRoot
+import shark.LibraryLeakReferenceMatcher
+import shark.internal.Reference.LazyDetails
+
+internal sealed class ReferencePathNode {
+  abstract val objectId: Long
+
+  sealed class RootNode : ReferencePathNode() {
+    abstract val gcRoot: GcRoot
+    override val objectId: Long
+      get() = gcRoot.id
+
+    class LibraryLeakRootNode(
+      override val gcRoot: GcRoot,
+      val matcher: LibraryLeakReferenceMatcher
+    ) : RootNode()
+
+    class NormalRootNode(
+      override val gcRoot: GcRoot
+    ) : RootNode()
+  }
+
+  class ChildNode(
+    override val objectId: Long,
+    /**
+     * The reference from the parent to this node
+     */
+    val parent: ReferencePathNode,
+    val lazyDetailsResolver: LazyDetails.Resolver,
+  ) : ReferencePathNode()
+}
diff --git a/shark/src/main/java/shark/internal/ReferenceReader.kt b/shark/src/main/java/shark/internal/ReferenceReader.kt
new file mode 100644
index 00000000..07cad461
--- /dev/null
+++ b/shark/src/main/java/shark/internal/ReferenceReader.kt
@@ -0,0 +1,24 @@
+package shark.internal
+
+import shark.HeapGraph
+import shark.HeapObject
+
+internal fun interface ReferenceReader<T : HeapObject> {
+
+  /**
+   * Returns the sequences of non null outgoing references from [source]. Outgoing refs
+   * can be actual JVM references or they can be virtual references when simplifying known data
+   * structures.
+   *
+   * Whenever possible, the returned sequence should be sorted in a way that ensures consistent
+   * graph traversal across heap dumps.
+   *
+   * The returned sequence may contain several [Reference] with an identical
+   * [Reference.valueObjectId].
+   */
+  fun read(source: T): Sequence<Reference>
+
+  fun interface Factory<T : HeapObject> {
+    fun create(graph: HeapGraph): ReferenceReader<T>
+  }
+}
diff --git a/shark/src/main/java/shark/internal/ShallowSizeCalculator.kt b/shark/src/main/java/shark/internal/ShallowSizeCalculator.kt
new file mode 100644
index 00000000..07db5601
--- /dev/null
+++ b/shark/src/main/java/shark/internal/ShallowSizeCalculator.kt
@@ -0,0 +1,65 @@
+package shark.internal
+
+import shark.HeapGraph
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.internal.ObjectArrayReferenceReader.Companion.isSkippablePrimitiveWrapperArray
+import shark.ValueHolder
+
+/**
+ * Provides approximations for the shallow size of objects in memory.
+ *
+ * Determining the actual shallow size of an object in memory is hard, as it changes for each VM
+ * implementation, depending on the various memory layout optimizations and bit alignment.
+ *
+ * More on this topic: https://dev.to/pyricau/the-real-size-of-android-objects-1i2e
+ */
+internal class ShallowSizeCalculator(private val graph: HeapGraph) {
+
+  fun computeShallowSize(objectId: Long): Int {
+    return when (val heapObject = graph.findObjectById(objectId)) {
+      is HeapInstance -> {
+        if (heapObject.instanceClassName == "java.lang.String") {
+          // In PathFinder we ignore the value field of String instances when building the dominator
+          // tree, so we add that size back here.
+          val valueObjectId =
+            heapObject["java.lang.String", "value"]?.value?.asNonNullObjectId
+          heapObject.byteSize + if (valueObjectId != null) {
+            computeShallowSize(valueObjectId)
+          } else {
+            0
+          }
+        } else {
+          // Total byte size of fields for instances of this class, as registered in the class dump.
+          // The actual memory layout likely differs.
+          heapObject.byteSize
+        }
+      }
+      // Number of elements * object id size
+      is HeapObjectArray -> {
+        if (heapObject.isSkippablePrimitiveWrapperArray) {
+          // In PathFinder we ignore references from primitive wrapper arrays when building the
+          // dominator tree, so we add that size back here.
+          val elementIds = heapObject.readRecord().elementIds
+          val shallowSize = elementIds.size * graph.identifierByteSize
+          val firstNonNullElement = elementIds.firstOrNull { it != ValueHolder.NULL_REFERENCE }
+          if (firstNonNullElement != null) {
+            val sizeOfOneElement = computeShallowSize(firstNonNullElement)
+            val countOfNonNullElements = elementIds.count { it != ValueHolder.NULL_REFERENCE }
+            shallowSize + (sizeOfOneElement * countOfNonNullElements)
+          } else {
+            shallowSize
+          }
+        } else {
+          heapObject.byteSize
+        }
+      }
+      // Number of elements * primitive type size
+      is HeapPrimitiveArray -> heapObject.byteSize
+      // This is probably way off but is a cheap approximation.
+      is HeapClass -> heapObject.recordSize
+    }
+  }
+}
diff --git a/shark/src/main/java/shark/internal/Strings.kt b/shark/src/main/java/shark/internal/Strings.kt
new file mode 100644
index 00000000..91a0cc5a
--- /dev/null
+++ b/shark/src/main/java/shark/internal/Strings.kt
@@ -0,0 +1,8 @@
+package shark.internal
+
+internal fun String.lastSegment(segmentingChar: Char): String {
+  val separator = lastIndexOf(segmentingChar)
+  return if (separator == -1) this else this.substring(separator + 1)
+}
+
+internal fun String.createSHA1Hash() = ByteStringCompat.encodeUtf8(this).sha1().hex()
diff --git a/shark/src/main/java/shark/internal/ThreadObjects.kt b/shark/src/main/java/shark/internal/ThreadObjects.kt
new file mode 100644
index 00000000..c851322c
--- /dev/null
+++ b/shark/src/main/java/shark/internal/ThreadObjects.kt
@@ -0,0 +1,18 @@
+package shark.internal
+
+import shark.GcRoot.ThreadObject
+import shark.HeapGraph
+
+internal object ThreadObjects {
+
+  private fun getThreadObjectsByIdMap(graph: HeapGraph) = graph.context.getOrPut(ThreadObjects::class.java.name) {
+    graph.gcRoots.asSequence().filterIsInstance<ThreadObject>().associateBy { it.id }
+  }
+
+  fun getThreadObjects(graph: HeapGraph) = getThreadObjectsByIdMap(graph).values
+
+  fun getByThreadObjectId(graph: HeapGraph, objectId: Long): ThreadObject? {
+    val threadObjectsById = getThreadObjectsByIdMap(graph)
+    return threadObjectsById[objectId]
+  }
+}
diff --git a/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt b/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt
new file mode 100644
index 00000000..edbb4749
--- /dev/null
+++ b/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt
@@ -0,0 +1,139 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+import java.util.regex.Pattern
+
+class HeapAnalysisStringRenderingTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun emptyFile() {
+    val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+    val analysis = heapAnalyzer.analyze(hprofFile, leakingObjectFinder = { error("never called") })
+
+    analysis renders """
+      |====================================
+      |HEAP ANALYSIS FAILED
+      |
+      |You can report this failure at https://github.com/square/leakcanary/issues
+      |Please provide the stacktrace, metadata and the heap dump file.
+      |====================================
+      |STACKTRACE
+      |
+      |java.lang.IllegalArgumentException: Source has no available bytes
+      |.*
+      |====================================
+      |METADATA
+      |
+      |Build.VERSION.SDK_INT: -1
+      |Build.MANUFACTURER: Unknown
+      |LeakCanary version: Unknown
+      |Analysis duration: \d* ms
+      |Heap dump file path: ${hprofFile.absolutePath}
+      |Heap dump timestamp: \d*
+      |===================================="""
+  }
+
+  @Test fun successNoLeak() {
+    hprofFile.dump {
+      "GcRoot" clazz {}
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysis>()
+
+
+    analysis renders """
+      |====================================
+      |HEAP ANALYSIS RESULT
+      |====================================
+      |0 APPLICATION LEAKS
+      |
+      |References underlined with "~~~" are likely causes.
+      |Learn more at https://squ.re/leaks.
+      |====================================
+      |0 LIBRARY LEAKS
+      |
+      |A Library Leak is a leak caused by a known bug in 3rd party code that you do not have control over.
+      |See https://square.github.io/leakcanary/fundamentals-how-leakcanary-works/#4-categorizing-leaks
+      |====================================
+      |0 UNREACHABLE OBJECTS
+      |
+      |An unreachable object is still in memory but LeakCanary could not find a strong reference path
+      |from GC roots.
+      |====================================
+      |METADATA
+      |
+      |Please include this in bug reports and Stack Overflow questions.
+      |
+      |Analysis duration: \d* ms
+      |Heap dump file path: ${hprofFile.absolutePath}
+      |Heap dump timestamp: \d*
+      |Heap dump duration: Unknown
+      |===================================="""
+  }
+
+  @Test fun successWithLeaks() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["leak"] = "Leaking" watchedInstance {}
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysis>()
+
+
+    analysis renders """
+      |====================================
+      |HEAP ANALYSIS RESULT
+      |====================================
+      |1 APPLICATION LEAKS
+      |
+      |References underlined with "~~~" are likely causes.
+      |Learn more at https://squ.re/leaks.
+      |
+      |Signature: a49095c3373b957532aff14eb32987bb75ffe9d5
+      |â”¬â”€â”€â”€
+      |â”‚ GC Root: System class
+      |â”‚
+      |â”œâ”€ GcRoot class
+      |.*
+      |====================================
+      |0 LIBRARY LEAKS
+      |
+      |A Library Leak is a leak caused by a known bug in 3rd party code that you do not have control over.
+      |See https://square.github.io/leakcanary/fundamentals-how-leakcanary-works/#4-categorizing-leaks
+      |====================================
+      |0 UNREACHABLE OBJECTS
+      |
+      |An unreachable object is still in memory but LeakCanary could not find a strong reference path
+      |from GC roots.
+      |====================================
+      |METADATA
+      |
+      |Please include this in bug reports and Stack Overflow questions.
+      |
+      |Analysis duration: \d* ms
+      |Heap dump file path: ${hprofFile.absolutePath}
+      |Heap dump timestamp: \d*
+      |Heap dump duration: Unknown
+      |===================================="""
+  }
+
+  private infix fun HeapAnalysis.renders(multilineRegexString: String) {
+    val regex: Pattern =
+      Pattern.compile("^" + multilineRegexString.trimMargin() + "$", Pattern.DOTALL)
+    assertThat(toString()).matches(regex)
+  }
+}
\ No newline at end of file
diff --git a/shark/src/test/java/shark/HeapAnalyzerTest.kt b/shark/src/test/java/shark/HeapAnalyzerTest.kt
new file mode 100644
index 00000000..b5478add
--- /dev/null
+++ b/shark/src/test/java/shark/HeapAnalyzerTest.kt
@@ -0,0 +1,171 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.GcRoot.JniGlobal
+import shark.GcRoot.ThreadObject
+import shark.LeakTraceReference.ReferenceType.STATIC_FIELD
+import shark.LeakTraceReference.ReferenceType.LOCAL
+import shark.ValueHolder.ReferenceHolder
+import java.io.File
+
+class HeapAnalyzerTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun singlePathToInstance() {
+    hprofFile.writeSinglePathToInstance()
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    assertThat(analysis.applicationLeaks[0]).isInstanceOf(Leak::class.java)
+  }
+
+  @Test fun pathToString() {
+    hprofFile.writeSinglePathToString()
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    val leak = analysis.applicationLeaks[0]
+
+    assertThat(leak.leakTraces.first().leakingObject.className).isEqualTo("java.lang.String")
+  }
+
+  @Test fun pathToCharArray() {
+    hprofFile.writeSinglePathsToCharArrays(listOf("Hello"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.leakingObject.className).isEqualTo("char[]")
+  }
+
+  // Two char arrays to ensure we keep going after finding the first one
+  @Test fun pathToTwoCharArrays() {
+    hprofFile.writeSinglePathsToCharArrays(listOf("Hello", "World"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysis>()
+    assertThat(analysis).isInstanceOf(HeapAnalysisSuccess::class.java)
+  }
+
+  @Test fun shortestPath() {
+    hprofFile.writeTwoPathsToInstance()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath).hasSize(1)
+    assertThat(leakTrace.referencePath[0].originObject.className).isEqualTo("GcRoot")
+    assertThat(leakTrace.referencePath[0].referenceName).isEqualTo("shortestPath")
+    assertThat(leakTrace.leakingObject.className).isEqualTo("Leaking")
+  }
+
+  @Test fun noPathToInstance() {
+    hprofFile.writeNoPathToInstance()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    assertThat(analysis.applicationLeaks).isEmpty()
+  }
+
+  @Test fun weakRefCleared() {
+    hprofFile.writeWeakReferenceCleared()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+    assertThat(analysis.applicationLeaks).isEmpty()
+  }
+
+  @Test fun failsNoRetainedKeys() {
+    hprofFile.writeMultipleActivityLeaks(0)
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    assertThat(analysis.applicationLeaks).isEmpty()
+  }
+
+  @Test fun findMultipleIdenticalLeaks() {
+    hprofFile.writeMultipleActivityLeaks(5)
+
+    val leaks = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    assertThat(leaks.applicationLeaks).hasSize(1)
+    assertThat(leaks.applicationLeaks.first().leakTraces).hasSize(5)
+  }
+
+  @Test fun localVariableLeakThreadSubclass() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath).hasSize(1)
+    assertThat(leakTrace.referencePath[0].originObject.className).isEqualTo("MyThread")
+    assertThat(leakTrace.referencePath[0].referenceType).isEqualTo(LOCAL)
+    assertThat(leakTrace.leakingObject.className).isEqualTo("Leaking")
+  }
+
+  @Test fun localVariableLeak() {
+    hprofFile.writeJavaLocalLeak()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+    println(analysis)
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath).hasSize(1)
+    assertThat(leakTrace.referencePath[0].originObject.className).isEqualTo(Thread::class.java.name)
+    assertThat(leakTrace.referencePath[0].referenceType).isEqualTo(LOCAL)
+    assertThat(leakTrace.leakingObject.className).isEqualTo("Leaking")
+  }
+
+  @Test fun localVariableLeakShortestPathGoesLast() {
+    hprofFile.writeTwoPathJavaLocalShorterLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+    println(analysis)
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath).hasSize(2)
+    assertThat(leakTrace.referencePath[0].originObject.className).isEqualTo("GcRoot")
+    assertThat(leakTrace.referencePath[0].referenceType).isEqualTo(STATIC_FIELD)
+  }
+
+  @Test fun threadFieldLeak() {
+    hprofFile.dump {
+      val threadClassId =
+        clazz(className = "java.lang.Thread", fields = listOf("name" to ReferenceHolder::class))
+      val myThreadClassId = clazz(
+        className = "MyThread", superclassId = threadClassId,
+        fields = listOf("leaking" to ReferenceHolder::class)
+      )
+      val threadInstance =
+        instance(myThreadClassId, listOf("Leaking" watchedInstance {}, string("Thread Name")))
+      gcRoot(
+        ThreadObject(
+          id = threadInstance.value, threadSerialNumber = 42, stackTraceSerialNumber = 0
+        )
+      )
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath).hasSize(1)
+    assertThat(leakTrace.referencePath[0].originObject.className).isEqualTo("MyThread")
+    assertThat(leakTrace.referencePath[0].referenceName).isEqualTo("leaking")
+    assertThat(leakTrace.leakingObject.className).isEqualTo("Leaking")
+  }
+
+  @Test fun nativeGlobalVariableApplicationLeak() {
+    hprofFile.dump {
+      gcRoot(JniGlobal(id = "Leaking".watchedInstance {}.value, jniGlobalRefId = 42))
+    }
+
+    val leaks = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+    assertThat(leaks.applicationLeaks).hasSize(1)
+  }
+}
diff --git a/shark/src/test/java/shark/HeapDumps.kt b/shark/src/test/java/shark/HeapDumps.kt
new file mode 100644
index 00000000..e69c5e65
--- /dev/null
+++ b/shark/src/test/java/shark/HeapDumps.kt
@@ -0,0 +1,175 @@
+package shark
+
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.ThreadObject
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ReferenceHolder
+import java.io.File
+
+fun File.writeWeakReferenceCleared() {
+  dump {
+    keyedWeakReference(ReferenceHolder(0))
+  }
+}
+
+fun File.writeNoPathToInstance() {
+  dump {
+    keyedWeakReference(instance(clazz("Leaking")))
+  }
+}
+
+fun File.writeSinglePathToInstance() {
+  dump {
+    val leaking = instance(clazz("Leaking"))
+    keyedWeakReference(leaking)
+    clazz(
+      "GcRoot", staticFields = listOf(
+        "shortestPath" to leaking
+      )
+    )
+  }
+}
+
+fun File.writeSinglePathToString(value: String = "Hi") {
+  dump {
+    val leaking = string(value)
+    keyedWeakReference(leaking)
+    clazz(
+      "GcRoot", staticFields = listOf(
+        "shortestPath" to leaking
+      )
+    )
+  }
+}
+
+fun File.writeSinglePathsToCharArrays(values: List<String>) {
+  dump {
+    val arrays = mutableListOf<Long>()
+    values.forEach {
+      val leaking = it.charArrayDump
+      keyedWeakReference(leaking)
+      arrays.add(leaking.value)
+    }
+    clazz(
+      className = "GcRoot",
+      staticFields = listOf(
+        "arrays" to ReferenceHolder(
+          objectArray(clazz("char[][]"), arrays.toLongArray())
+        )
+      )
+    )
+
+  }
+}
+
+fun File.writeTwoPathsToInstance() {
+  dump {
+    val leaking = instance(clazz("Leaking"))
+    keyedWeakReference(leaking)
+    val hasLeaking = instance(
+      clazz("HasLeaking", fields = listOf("leaking" to ReferenceHolder::class)),
+      fields = listOf(leaking)
+    )
+    clazz(
+      "GcRoot", staticFields = listOf(
+        "shortestPath" to leaking,
+        "longestPath" to hasLeaking
+      )
+    )
+  }
+}
+
+fun File.writeMultipleActivityLeaks(leakCount: Int) {
+  dump {
+    val activityClassId = clazz(
+      className = "android.app.Activity",
+      fields = listOf("mDestroyed" to BooleanHolder::class)
+    )
+    val exampleActivityClassId = clazz(
+      superclassId = activityClassId,
+      className = "com.example.ExampleActivity"
+    )
+    val activityArrayClassId = arrayClass("com.example.ExampleActivity")
+
+    val destroyedActivities = mutableListOf<ReferenceHolder>()
+    for (i in 1..leakCount) {
+      destroyedActivities.add(instance(exampleActivityClassId, listOf(BooleanHolder(true))))
+    }
+
+    clazz(
+      className = "com.example.ActivityHolder",
+      staticFields = listOf(
+        "activities" to
+          objectArrayOf(
+            activityArrayClassId, *destroyedActivities.toTypedArray()
+          )
+      )
+    )
+    destroyedActivities.forEach { instanceId ->
+      keyedWeakReference(instanceId)
+    }
+  }
+}
+
+fun File.writeJavaLocalLeak(
+  threadClass: String? = null,
+  threadName: String? = null
+) {
+  dump {
+    val threadClassId =
+      clazz(
+        className = Thread::class.java.name,
+        fields = if (threadName != null) listOf("name" to ReferenceHolder::class) else emptyList()
+      )
+    val myThreadClassId = if (threadClass == null) {
+      threadClassId
+    } else {
+      clazz(className = threadClass, superclassId = threadClassId)
+    }
+    val threadInstance = instance(
+      myThreadClassId, if (threadName != null) {
+        listOf(string(threadName))
+      } else {
+        emptyList()
+      }
+    )
+    gcRoot(
+      ThreadObject(
+        id = threadInstance.value, threadSerialNumber = 42, stackTraceSerialNumber = 0
+      )
+    )
+
+    val leaking = "Leaking" watchedInstance {}
+    gcRoot(JavaFrame(id = leaking.value, threadSerialNumber = 42, frameNumber = 0))
+  }
+}
+
+fun File.writeTwoPathJavaLocalShorterLeak(
+  threadClass: String,
+  threadName: String
+) {
+  dump {
+    val threadClassId =
+      clazz(className = "java.lang.Thread", fields = listOf("name" to ReferenceHolder::class))
+    val myThreadClassId = clazz(className = threadClass, superclassId = threadClassId)
+    val threadInstance = instance(myThreadClassId, listOf(string(threadName)))
+    gcRoot(
+      ThreadObject(
+        id = threadInstance.value, threadSerialNumber = 42, stackTraceSerialNumber = 0
+      )
+    )
+
+    val leaking = "Leaking" watchedInstance {}
+    gcRoot(JavaFrame(id = leaking.value, threadSerialNumber = 42, frameNumber = 0))
+
+    val hasLeaking = instance(
+      clazz("HasLeaking", fields = listOf("leaking" to ReferenceHolder::class)),
+      fields = listOf(leaking)
+    )
+    clazz(
+      "GcRoot", staticFields = listOf(
+        "longestPath" to hasLeaking
+      )
+    )
+  }
+}
diff --git a/shark/src/test/java/shark/HprofHeapGraphTest.kt b/shark/src/test/java/shark/HprofHeapGraphTest.kt
new file mode 100644
index 00000000..4299c02f
--- /dev/null
+++ b/shark/src/test/java/shark/HprofHeapGraphTest.kt
@@ -0,0 +1,56 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.ValueHolder.CharHolder
+
+class HprofHeapGraphTest {
+
+  @Test fun `class index is consistent when parsing dump twice`() {
+    val heapDump = dump {
+      "SomeClass" clazz {}
+    }
+
+    val classIndex = heapDump.openHeapGraph().use { graph ->
+      graph.findClassByName("SomeClass")!!.objectIndex
+    }
+
+    heapDump.openHeapGraph().use { graph ->
+      val heapObject = graph.findObjectByIndex(classIndex)
+      assertThat(heapObject).isInstanceOf(HeapClass::class.java)
+      heapObject as HeapClass
+      assertThat(heapObject.name).isEqualTo("SomeClass")
+    }
+  }
+
+  @Test fun `instance index is consistent when parsing dump twice`() {
+    val heapDump = dump {
+      "SomeClass" instance {}
+    }
+
+    val instanceIndex = heapDump.openHeapGraph().use { graph ->
+      graph.findClassByName("SomeClass")!!.instances.single().objectIndex
+    }
+
+    heapDump.openHeapGraph().use { graph ->
+      val heapObject = graph.findObjectByIndex(instanceIndex)
+      assertThat(heapObject).isInstanceOf(HeapInstance::class.java)
+      heapObject as HeapInstance
+      assertThat(heapObject.instanceClassName).isEqualTo("SomeClass")
+    }
+  }
+
+  @Test fun `char is correctly converted back`() {
+    val heapDump = dump {
+      "SomeClass" clazz { staticField["myChar"] = CharHolder('p') }
+    }
+    val myChar = heapDump.openHeapGraph().use { graph ->
+      val myClass = graph.findClassByName("SomeClass")!!
+      myClass.readStaticField("myChar")!!.value.asChar!!
+    }
+    assertThat(myChar).isEqualTo('p')
+  }
+}
\ No newline at end of file
diff --git a/shark/src/test/java/shark/LabelerTest.kt b/shark/src/test/java/shark/LabelerTest.kt
new file mode 100644
index 00000000..e5cab7af
--- /dev/null
+++ b/shark/src/test/java/shark/LabelerTest.kt
@@ -0,0 +1,68 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+
+class LabelerTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun stringContentAsLabel() {
+    hprofFile.writeSinglePathToString("World")
+
+    val labeler = ObjectInspector { reporter ->
+      reporter.whenInstanceOf("java.lang.String") { instance ->
+        labels += "Hello ${instance.readAsJavaString()}"
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(objectInspectors = listOf(labeler))
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+
+    assertThat(leakTrace.leakingObject.labels).contains("Hello World")
+  }
+
+  @Test fun labelOnUnreachableObject() {
+    val heapDump = dump {
+      "com.example.SomeClass" watchedInstance {
+      }
+    }
+
+    val labeler = ObjectInspector { reporter ->
+      reporter.whenInstanceOf("java.lang.Object") { instance ->
+        labels += instance.instanceClassSimpleName
+      }
+    }
+
+    val analysis = heapDump.checkForLeaks<HeapAnalysisSuccess>(objectInspectors = listOf(labeler))
+
+    assertThat(analysis.unreachableObjects[0].labels).contains("SomeClass")
+  }
+
+  @Test fun threadNameLabel() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(ObjectInspectors.THREAD)
+      )
+
+    val leak = analysis.applicationLeaks[0]
+
+    assertThat(leak.leakTraces.first().referencePath.first().originObject.labels).contains(
+      "Thread name: 'kroutine'"
+    )
+  }
+}
diff --git a/shark/src/test/java/shark/LeakStatusTest.kt b/shark/src/test/java/shark/LeakStatusTest.kt
new file mode 100644
index 00000000..5c808685
--- /dev/null
+++ b/shark/src/test/java/shark/LeakStatusTest.kt
@@ -0,0 +1,571 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.LeakTraceObject.LeakingStatus.LEAKING
+import shark.LeakTraceObject.LeakingStatus.NOT_LEAKING
+import shark.LeakTraceObject.LeakingStatus.UNKNOWN
+import java.io.File
+
+class LeakStatusTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun gcRootClassNotLeaking() {
+    hprofFile.writeSinglePathToInstance()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+      objectInspectors = listOf(ObjectInspectors.CLASS)
+    )
+
+    val leak = analysis.applicationLeaks[0]
+
+    assertThat(leak.leakTraces.first().referencePath.first().originObject.leakingStatus).isEqualTo(
+      NOT_LEAKING
+    )
+  }
+
+  @Test fun leakingInstanceLeaking() {
+    hprofFile.writeSinglePathToInstance()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.leakingObject.leakingStatus).isEqualTo(LEAKING)
+  }
+
+  @Test fun unreachableInstanceLeaking() {
+    val heapDump = dump {
+      "SomeClass" watchedInstance {
+      }
+    }
+
+    val analysis = heapDump.checkForLeaks<HeapAnalysisSuccess>()
+
+    assertThat(analysis.unreachableObjects[0].leakingStatus).isEqualTo(LEAKING)
+  }
+
+  @Test fun defaultsToUnknown() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatus).isEqualTo(UNKNOWN)
+  }
+
+  @Test fun inspectorNotLeaking() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+      objectInspectors = listOf(notLeakingInstance("Class1"))
+    )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatus).isEqualTo(NOT_LEAKING)
+  }
+
+  @Test fun inspectorLeaking() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(leakingInstance("Class1"))
+      )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatusReason).isEqualTo(
+      "Class1 is leaking"
+    )
+  }
+
+  @Test fun leakingWinsUnknown() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(leakingInstance("Class1"))
+      )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatus).isEqualTo(LEAKING)
+  }
+
+  @Test fun notLeakingWhenNextIsNotLeaking() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(notLeakingInstance("Class3"))
+      )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatus).isEqualTo(NOT_LEAKING)
+  }
+
+  @Test fun leakingWhenPreviousIsLeaking() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(leakingInstance("Class1"))
+      )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath).hasSize(4)
+    assertThat(leakTrace.referencePath[2].originObject.leakingStatus).isEqualTo(LEAKING)
+    assertThat(leakTrace.referencePath[2].originObject.leakingStatusReason).isEqualTo(
+      "Class1â†‘ is leaking"
+    )
+  }
+
+  @Test fun middleUnknown() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(
+          notLeakingInstance("Class1"), leakingInstance("Class3")
+        )
+      )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[2].originObject.leakingStatus).isEqualTo(UNKNOWN)
+  }
+
+  @Test fun gcRootClassNotLeakingConflictingWithInspector() {
+    hprofFile.writeSinglePathToInstance()
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(leakingClass("GcRoot"), ObjectInspectors.CLASS)
+      )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+
+    assertThat(leakTrace.referencePath.first().originObject.leakingStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leakTrace.referencePath.first().originObject.leakingStatusReason).isEqualTo(
+      "a class is never leaking. Conflicts with GcRoot is leaking"
+    )
+  }
+
+  @Test fun gcRootClassNotLeakingAgreesWithInspector() {
+    hprofFile.writeSinglePathToInstance()
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(notLeakingClass("GcRoot"), ObjectInspectors.CLASS)
+      )
+
+    println(analysis)
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+
+    assertThat(leakTrace.referencePath.first().originObject.leakingStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leakTrace.referencePath.first().originObject.leakingStatusReason).isEqualTo(
+      "GcRoot is not leaking and a class is never leaking"
+    )
+  }
+
+  @Test fun leakingInstanceLeakingConflictingWithInspector() {
+    hprofFile.writeSinglePathToInstance()
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(notLeakingInstance("Leaking"))
+      )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.leakingObject.leakingStatus).isEqualTo(LEAKING)
+    assertThat(leakTrace.leakingObject.leakingStatusReason).isEqualTo(
+      "ObjectWatcher was watching this because its lifecycle has ended. " +
+        "Conflicts with Leaking is not leaking"
+    )
+  }
+
+  @Test fun leakingInstanceLeakingAgreesWithInspector() {
+    hprofFile.writeSinglePathToInstance()
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(leakingInstance("Leaking"))
+      )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.leakingObject.leakingStatus).isEqualTo(LEAKING)
+    assertThat(leakTrace.leakingObject.leakingStatusReason).isEqualTo(
+      "Leaking is leaking and ObjectWatcher was watching this because its lifecycle has ended"
+    )
+  }
+
+  @Test fun conflictNotLeakingWins() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(
+          notLeakingInstance("Class1"), leakingInstance("Class1")
+        )
+      )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+
+    println(leakTrace)
+
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatusReason).isEqualTo(
+      "Class1 is not leaking. Conflicts with Class1 is leaking"
+    )
+  }
+
+  @Test fun twoInspectorsAgreeNotLeaking() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(
+          notLeakingInstance("Class1"), notLeakingInstance("Class1")
+        )
+      )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatusReason).isEqualTo(
+      "Class1 is not leaking"
+    )
+  }
+
+  @Test fun twoInspectorsAgreeLeaking() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(leakingInstance("Class1"), leakingInstance("Class1"))
+      )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatus).isEqualTo(LEAKING)
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatusReason).isEqualTo(
+      "Class1 is leaking"
+    )
+  }
+
+  @Test fun notLeakingWhenFurtherDownIsNotLeaking() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(notLeakingInstance("Class3"))
+      )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[1].originObject.className).isEqualTo("Class1")
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatusReason).isEqualTo(
+      "Class3â†“ is not leaking"
+    )
+  }
+
+  @Test fun leakingWhenFurtherUpIsleaking() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(leakingInstance("Class1"))
+      )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[3].originObject.className).isEqualTo("Class3")
+    assertThat(leakTrace.referencePath[3].originObject.leakingStatus).isEqualTo(LEAKING)
+    assertThat(leakTrace.referencePath[3].originObject.leakingStatusReason).isEqualTo(
+      "Class1â†‘ is leaking"
+    )
+  }
+
+  @Test fun leakCausesAreLastNotLeakingAndUnknown() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(
+          notLeakingInstance("Class1"), leakingInstance("Class3")
+        )
+      )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePathElementIsSuspect(0)).isFalse()
+    assertThat(leakTrace.referencePathElementIsSuspect(1)).isTrue()
+    assertThat(leakTrace.referencePathElementIsSuspect(2)).isTrue()
+  }
+
+  @Test fun sameLeakTraceSameSignature() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash1 = computeSignature(notLeaking = "Class1", leaking = "Class3")
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash2 = computeSignature(notLeaking = "Class1", leaking = "Class3")
+    assertThat(hash1).isEqualTo(hash2)
+  }
+
+  @Test fun differentLeakTraceDifferentSignature() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1a"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash1 = computeSignature(notLeaking = "Class1", leaking = "Class3")
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1b"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash2 = computeSignature(notLeaking = "Class1", leaking = "Class3")
+    assertThat(hash1).isNotEqualTo(hash2)
+  }
+
+  @Test fun sameCausesSameSignature() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3a"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash1 = computeSignature(notLeaking = "Class1", leaking = "Class3")
+
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3b"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+    val hash2 = computeSignature(notLeaking = "Class1", leaking = "Class3")
+    assertThat(hash1).isEqualTo(hash2)
+  }
+
+  @Test fun sameCausesSameApplicationLeak() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3a"] = "Leaking" watchedInstance {}
+              field["field3b"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(notLeakingInstance("Class1"), leakingInstance("Class3"))
+      )
+
+    assertThat(analysis.applicationLeaks).hasSize(1)
+    assertThat(analysis.applicationLeaks.first().leakTraces).hasSize(2)
+  }
+
+  private fun notLeakingInstance(className: String): ObjectInspector {
+    return ObjectInspector { reporter ->
+      val record = reporter.heapObject
+      if (record is HeapInstance && record.instanceClassName == className) {
+        reporter.notLeakingReasons += "$className is not leaking"
+      }
+    }
+  }
+
+  private fun leakingInstance(className: String): ObjectInspector {
+    return ObjectInspector { reporter ->
+      val record = reporter.heapObject
+      if (record is HeapInstance && record.instanceClassName == className) {
+        reporter.leakingReasons += "$className is leaking"
+      }
+    }
+  }
+
+  private fun notLeakingClass(className: String): ObjectInspector {
+    return ObjectInspector { reporter ->
+      val record = reporter.heapObject
+      if (record is HeapClass && record.name == className) {
+        reporter.notLeakingReasons += "$className is not leaking"
+      }
+    }
+  }
+
+  private fun leakingClass(className: String): ObjectInspector {
+    return ObjectInspector { reporter ->
+      val record = reporter.heapObject
+      if (record is HeapClass && record.name == className) {
+        reporter.leakingReasons += "$className is leaking"
+      }
+    }
+  }
+
+  private fun computeSignature(
+    notLeaking: String,
+    leaking: String
+  ): String {
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(notLeakingInstance(notLeaking), leakingInstance(leaking))
+      )
+    require(analysis.applicationLeaks.size == 1) {
+      "Expecting 1 retained instance in ${analysis.applicationLeaks}"
+    }
+    val leak = analysis.applicationLeaks[0]
+    return leak.signature
+  }
+}
diff --git a/shark/src/test/java/shark/LeakTraceRenderingTest.kt b/shark/src/test/java/shark/LeakTraceRenderingTest.kt
new file mode 100644
index 00000000..7ebb55e6
--- /dev/null
+++ b/shark/src/test/java/shark/LeakTraceRenderingTest.kt
@@ -0,0 +1,331 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.FilteringLeakingObjectFinder.LeakingObjectFilter
+import shark.HeapObject.HeapInstance
+import shark.ReferencePattern.InstanceFieldPattern
+import shark.ReferencePattern.StaticFieldPattern
+import shark.ValueHolder.ReferenceHolder
+import java.io.File
+
+class LeakTraceRenderingTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun rendersSimplePath() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["leak"] = "Leaking" watchedInstance {}
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    analysis renders """
+    â”¬â”€â”€â”€
+    â”‚ GC Root: System class
+    â”‚
+    â”œâ”€ GcRoot class
+    â”‚    Leaking: UNKNOWN
+    â”‚    â†“ static GcRoot.leak
+    â”‚                    ~~~~
+    â•°â†’ Leaking instance
+    â€‹     Leaking: YES (ObjectWatcher was watching this because its lifecycle has ended)
+    â€‹     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    â€‹     watchDurationMillis = 25000
+    â€‹     retainedDurationMillis = 10000
+    """
+  }
+
+  @Test fun rendersDeobfuscatedSimplePath() {
+    hprofFile.dump {
+      "a" clazz {
+        staticField["b.c"] = "Leaking" watchedInstance {}
+      }
+    }
+
+    val proguardMappingText = """
+            GcRoot -> a:
+                type leak -> b.c
+        """.trimIndent()
+
+    val reader = ProguardMappingReader(proguardMappingText.byteInputStream(Charsets.UTF_8))
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+      proguardMapping = reader.readProguardMapping()
+    )
+
+    analysis renders """
+    â”¬â”€â”€â”€
+    â”‚ GC Root: System class
+    â”‚
+    â”œâ”€ GcRoot class
+    â”‚    Leaking: UNKNOWN
+    â”‚    â†“ static GcRoot.leak
+    â”‚                    ~~~~
+    â•°â†’ Leaking instance
+    â€‹     Leaking: YES (ObjectWatcher was watching this because its lifecycle has ended)
+    â€‹     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    â€‹     watchDurationMillis = 25000
+    â€‹     retainedDurationMillis = 10000
+    """
+  }
+
+  @Test fun rendersLeakingWithReason() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["instanceA"] = "ClassA" instance {
+          field["instanceB"] = "ClassB" instance {
+            field["leak"] = "Leaking" watchedInstance {}
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(object : ObjectInspector {
+          override fun inspect(
+            reporter: ObjectReporter
+          ) {
+            reporter.whenInstanceOf("ClassB") {
+              leakingReasons += "because reasons"
+            }
+          }
+        }), leakingObjectFinder = FilteringLeakingObjectFinder(listOf(LeakingObjectFilter { heapObject ->
+          heapObject is HeapInstance && heapObject instanceOf "ClassB"
+      }))
+      )
+
+    analysis renders """
+    â”¬â”€â”€â”€
+    â”‚ GC Root: System class
+    â”‚
+    â”œâ”€ GcRoot class
+    â”‚    Leaking: UNKNOWN
+    â”‚    â†“ static GcRoot.instanceA
+    â”‚                    ~~~~~~~~~
+    â”œâ”€ ClassA instance
+    â”‚    Leaking: UNKNOWN
+    â”‚    â†“ ClassA.instanceB
+    â”‚             ~~~~~~~~~
+    â•°â†’ ClassB instance
+    â€‹     Leaking: YES (because reasons)
+    """
+  }
+
+  @Test fun rendersLabelsOnAllNodes() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["leak"] = "Leaking" watchedInstance {}
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+      objectInspectors = listOf(object : ObjectInspector {
+        override fun inspect(
+          reporter: ObjectReporter
+        ) {
+          reporter.labels += "Â¯\\_(ãƒ„)_/Â¯"
+        }
+      })
+    )
+
+    analysis renders """
+    â”¬â”€â”€â”€
+    â”‚ GC Root: System class
+    â”‚
+    â”œâ”€ GcRoot class
+    â”‚    Leaking: UNKNOWN
+    â”‚    Â¯\_(ãƒ„)_/Â¯
+    â”‚    â†“ static GcRoot.leak
+    â”‚                    ~~~~
+    â•°â†’ Leaking instance
+    â€‹     Leaking: YES (ObjectWatcher was watching this because its lifecycle has ended)
+    â€‹     Â¯\_(ãƒ„)_/Â¯
+    â€‹     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    â€‹     watchDurationMillis = 25000
+    â€‹     retainedDurationMillis = 10000
+    """
+  }
+
+  @Test fun rendersExclusion() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["instanceA"] = "ClassA" instance {
+          field["leak"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(
+          LibraryLeakReferenceMatcher(pattern = InstanceFieldPattern("ClassA", "leak"))
+        )
+      )
+
+    analysis rendersLibraryLeak """
+    â”¬â”€â”€â”€
+    â”‚ GC Root: System class
+    â”‚
+    â”œâ”€ GcRoot class
+    â”‚    Leaking: UNKNOWN
+    â”‚    â†“ static GcRoot.instanceA
+    â”‚                    ~~~~~~~~~
+    â”œâ”€ ClassA instance
+    â”‚    Leaking: UNKNOWN
+    â”‚    Library leak match: instance field ClassA#leak
+    â”‚    â†“ ClassA.leak
+    â”‚             ~~~~
+    â•°â†’ Leaking instance
+    â€‹     Leaking: YES (ObjectWatcher was watching this because its lifecycle has ended)
+    â€‹     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    â€‹     watchDurationMillis = 25000
+    â€‹     retainedDurationMillis = 10000
+    """
+  }
+
+  @Test fun rendersRootExclusion() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["leak"] = "Leaking" watchedInstance {}
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(
+          LibraryLeakReferenceMatcher(pattern = StaticFieldPattern("GcRoot", "leak"))
+        )
+      )
+
+    analysis rendersLibraryLeak """
+    â”¬â”€â”€â”€
+    â”‚ GC Root: System class
+    â”‚
+    â”œâ”€ GcRoot class
+    â”‚    Leaking: UNKNOWN
+    â”‚    Library leak match: static field GcRoot#leak
+    â”‚    â†“ static GcRoot.leak
+    â”‚                    ~~~~
+    â•°â†’ Leaking instance
+    â€‹     Leaking: YES (ObjectWatcher was watching this because its lifecycle has ended)
+    â€‹     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    â€‹     watchDurationMillis = 25000
+    â€‹     retainedDurationMillis = 10000
+    """
+  }
+
+  @Test fun rendersArray() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["array"] = objectArray("Leaking" watchedInstance {})
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    analysis renders """
+    â”¬â”€â”€â”€
+    â”‚ GC Root: System class
+    â”‚
+    â”œâ”€ GcRoot class
+    â”‚    Leaking: UNKNOWN
+    â”‚    â†“ static GcRoot.array
+    â”‚                    ~~~~~
+    â”œâ”€ java.lang.Object[] array
+    â”‚    Leaking: UNKNOWN
+    â”‚    â†“ Object[0]
+    â”‚            ~~~
+    â•°â†’ Leaking instance
+    â€‹     Leaking: YES (ObjectWatcher was watching this because its lifecycle has ended)
+    â€‹     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    â€‹     watchDurationMillis = 25000
+    â€‹     retainedDurationMillis = 10000
+    """
+  }
+
+  @Test fun rendersThread() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = ObjectInspectors.jdkDefaults
+      )
+
+    analysis renders """
+    â”¬â”€â”€â”€
+    â”‚ GC Root: Thread object
+    â”‚
+    â”œâ”€ MyThread instance
+    â”‚    Leaking: UNKNOWN
+    â”‚    Thread name: 'kroutine'
+    â”‚    â†“ MyThread<Java Local>
+    â”‚              ~~~~~~~~~~~~
+    â•°â†’ Leaking instance
+    â€‹     Leaking: YES (ObjectWatcher was watching this because its lifecycle has ended)
+    â€‹     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    â€‹     watchDurationMillis = 25000
+    â€‹     retainedDurationMillis = 10000
+    """
+  }
+
+  @Test fun renderFieldFromSuperClass() {
+    hprofFile.dump {
+      val leakingInstance = "Leaking" watchedInstance {}
+      val parentClassId =
+        clazz("com.ParentClass", fields = listOf("leak" to ReferenceHolder::class))
+      val childClassId = clazz("com.ChildClass", superclassId = parentClassId)
+      "GcRoot" clazz {
+        staticField["child"] = instance(childClassId, listOf(leakingInstance))
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    analysis renders """
+    â”¬â”€â”€â”€
+    â”‚ GC Root: System class
+    â”‚
+    â”œâ”€ GcRoot class
+    â”‚    Leaking: UNKNOWN
+    â”‚    â†“ static GcRoot.child
+    â”‚                    ~~~~~
+    â”œâ”€ com.ChildClass instance
+    â”‚    Leaking: UNKNOWN
+    â”‚    â†“ ParentClass.leak
+    â”‚                  ~~~~
+    â•°â†’ Leaking instance
+    â€‹     Leaking: YES (ObjectWatcher was watching this because its lifecycle has ended)
+    â€‹     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    â€‹     watchDurationMillis = 25000
+    â€‹     retainedDurationMillis = 10000
+        """
+  }
+
+  private infix fun HeapAnalysisSuccess.renders(expectedString: String) {
+    assertThat(applicationLeaks[0].leakTraces.first().toString()).isEqualTo(
+      expectedString.trimIndent()
+    )
+  }
+
+  private infix fun HeapAnalysisSuccess.rendersLibraryLeak(expectedString: String) {
+    assertThat(libraryLeaks[0].leakTraces.first().toString()).isEqualTo(
+      expectedString.trimIndent()
+    )
+  }
+}
diff --git a/shark/src/test/java/shark/MetadataExtractorTest.kt b/shark/src/test/java/shark/MetadataExtractorTest.kt
new file mode 100644
index 00000000..a548f648
--- /dev/null
+++ b/shark/src/test/java/shark/MetadataExtractorTest.kt
@@ -0,0 +1,43 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+
+class MetadataExtractorTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun extractStaticStringField() {
+    hprofFile.dump {
+      val helloString = string("Hello")
+      clazz(
+        "World", staticFields = listOf(
+        "message" to helloString
+      )
+      )
+    }
+
+    val extractor = MetadataExtractor { graph ->
+      val message =
+        graph.findClassByName("World")!!["message"]!!.valueAsInstance!!.readAsJavaString()!!
+      mapOf("World message" to message)
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(metadataExtractor = extractor)
+
+    val metadata = analysis.metadata
+
+    assertThat(metadata).containsAllEntriesOf(mapOf("World message" to "Hello"))
+  }
+}
diff --git a/shark/src/test/java/shark/OpenJdkInstanceRefReadersTest.kt b/shark/src/test/java/shark/OpenJdkInstanceRefReadersTest.kt
new file mode 100644
index 00000000..b27dd749
--- /dev/null
+++ b/shark/src/test/java/shark/OpenJdkInstanceRefReadersTest.kt
@@ -0,0 +1,430 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.After
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.FilteringLeakingObjectFinder.LeakingObjectFilter
+import shark.internal.OpenJdkInstanceRefReaders.LINKED_LIST
+import java.io.File
+import java.util.LinkedList
+import java.util.concurrent.ConcurrentHashMap
+import java.util.concurrent.CopyOnWriteArrayList
+import shark.internal.ChainingInstanceReferenceReader.VirtualInstanceReferenceReader.OptionalFactory
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.internal.ChainingInstanceReferenceReader
+import shark.internal.ClassReferenceReader
+import shark.internal.DelegatingObjectReferenceReader
+import shark.internal.FieldInstanceReferenceReader
+import shark.internal.JavaLocalReferenceReader
+import shark.internal.ObjectArrayReferenceReader
+import shark.internal.OpenJdkInstanceRefReaders
+
+class OpenJdkInstanceRefReadersTest {
+
+  class Retained
+  class SomeKey
+
+  companion object {
+    @JvmStatic
+    var leakRoot: Any? = null
+  }
+
+  @get:Rule
+  val testFolder = TemporaryFolder()
+
+  @After fun tearDown() {
+    leakRoot = null
+  }
+
+  @Test fun `LinkedList expanded`() {
+    val list = LinkedList<Any>()
+    list += Retained()
+    leakRoot = list
+
+    val refPath = findLeak(LINKED_LIST)
+
+    assertThat(refPath).hasSize(1)
+
+    with(refPath.first()) {
+      assertThat(owningClassName).isEqualTo(LinkedList::class.qualifiedName)
+      assertThat(referenceDisplayName).isEqualTo("[0]")
+    }
+  }
+
+  @Test fun `LinkedList no expander`() {
+    val list = LinkedList<Any>()
+    list += Retained()
+    leakRoot = list
+
+    val refPath = findLeak { null }
+
+    assertThat(refPath).hasSize(2)
+
+    with(refPath[0]) {
+      assertThat(owningClassName).isEqualTo(LinkedList::class.qualifiedName)
+      assertThat(referenceDisplayName).isEqualTo("first")
+    }
+    with(refPath[1]) {
+      assertThat(owningClassName).isEqualTo("java.util.LinkedList\$Node")
+      assertThat(referenceDisplayName).isEqualTo("item")
+    }
+  }
+
+  @Test fun `LinkedList retained size is identical whether expanding or not`() {
+    val list = LinkedList<Any>()
+    list += Retained()
+    leakRoot = list
+
+    val hprofFile = dumpHeap()
+
+    val retainedSizeExpanded = hprofFile.findPathFromLeak(
+      computeRetainedHeapSize = true,
+      virtualRefReaderFactory = LINKED_LIST
+    )
+      .first()
+      .originObject
+      .retainedHeapByteSize
+
+    val retainedSizeNotExpanded = hprofFile.findPathFromLeak(
+      computeRetainedHeapSize = true,
+      virtualRefReaderFactory = { null }
+    )
+      .first()
+      .originObject
+      .retainedHeapByteSize
+
+    assertThat(retainedSizeExpanded).isEqualTo(retainedSizeNotExpanded)
+  }
+
+  @Test fun `ArrayList expanded`() {
+    val list = ArrayList<Any>()
+    list += Retained()
+    leakRoot = list
+
+    val refPath = findLeak(OpenJdkInstanceRefReaders.ARRAY_LIST)
+
+    assertThat(refPath).hasSize(1)
+
+    with(refPath.first()) {
+      assertThat(owningClassName).isEqualTo(ArrayList::class.qualifiedName)
+      assertThat(referenceDisplayName).isEqualTo("[0]")
+    }
+  }
+
+  @Test fun `ArrayList no expander`() {
+    val list = ArrayList<Any>()
+    list += Retained()
+    leakRoot = list
+
+    val refPath = findLeak { null }
+
+    assertThat(refPath).hasSize(2)
+
+    with(refPath[0]) {
+      assertThat(owningClassName).isEqualTo(ArrayList::class.qualifiedName)
+      assertThat(referenceDisplayName).isEqualTo("elementData")
+    }
+    with(refPath[1]) {
+      assertThat(owningClassName).isEqualTo("java.lang.Object[]")
+      assertThat(referenceDisplayName).isEqualTo("[0]")
+    }
+  }
+
+  @Test fun `CopyOnWriteArrayList expanded`() {
+    val list = CopyOnWriteArrayList<Any>()
+    list += Retained()
+    leakRoot = list
+
+    val refPath = findLeak(OpenJdkInstanceRefReaders.COPY_ON_WRITE_ARRAY_LIST)
+
+    assertThat(refPath).hasSize(1)
+
+    with(refPath.first()) {
+      assertThat(owningClassName).isEqualTo(CopyOnWriteArrayList::class.qualifiedName)
+      assertThat(referenceDisplayName).isEqualTo("[0]")
+    }
+  }
+
+  @Test fun `CopyOnWriteArrayList no expander`() {
+    val list = CopyOnWriteArrayList<Any>()
+    list += Retained()
+    leakRoot = list
+
+    val refPath = findLeak { null }
+
+    assertThat(refPath).hasSize(2)
+
+    with(refPath[0]) {
+      assertThat(owningClassName).isEqualTo(CopyOnWriteArrayList::class.qualifiedName)
+      assertThat(referenceDisplayName).isEqualTo("array")
+    }
+    with(refPath[1]) {
+      assertThat(owningClassName).isEqualTo("java.lang.Object[]")
+      assertThat(referenceDisplayName).isEqualTo("[0]")
+    }
+  }
+
+  @Test fun `HashMap expanded`() {
+    val map = HashMap<Any, Any>()
+    map[SomeKey()] = Retained()
+    leakRoot = map
+
+    val refPath = findLeak(OpenJdkInstanceRefReaders.HASH_MAP)
+
+    assertThat(refPath).hasSize(1)
+
+    with(refPath.first()) {
+      assertThat(owningClassName).isEqualTo(HashMap::class.qualifiedName)
+    }
+  }
+
+  @Test fun `HashMap key expanded`() {
+    val map = HashMap<Any, Any>()
+    map[Retained()] = "value"
+    leakRoot = map
+
+    val refPath = findLeak(OpenJdkInstanceRefReaders.HASH_MAP)
+
+    assertThat(refPath).hasSize(1)
+
+    with(refPath.first()) {
+      assertThat(owningClassName).isEqualTo(HashMap::class.qualifiedName)
+      assertThat(referenceDisplayName).isEqualTo("[key()]")
+    }
+  }
+
+  @Test fun `LinkedHashMap expanded`() {
+    val map = LinkedHashMap<Any, Any>()
+    map[SomeKey()] = Retained()
+    leakRoot = map
+
+    val refPath = findLeak(OpenJdkInstanceRefReaders.HASH_MAP)
+
+    assertThat(refPath).hasSize(1)
+
+    with(refPath.first()) {
+      assertThat(owningClassName).isEqualTo(LinkedHashMap::class.qualifiedName)
+    }
+  }
+
+  @Test fun `ConcurrentHashMap expanded`() {
+    val map = ConcurrentHashMap<Any, Any>()
+    map[SomeKey()] = Retained()
+    leakRoot = map
+
+    val refPath = findLeak(OpenJdkInstanceRefReaders.CONCURRENT_HASH_MAP)
+
+    assertThat(refPath).hasSize(1)
+
+    with(refPath.first()) {
+      assertThat(owningClassName).isEqualTo(ConcurrentHashMap::class.qualifiedName)
+    }
+  }
+
+  @Test fun `ConcurrentHashMap key expanded`() {
+    val map = ConcurrentHashMap<Any, Any>()
+    map[Retained()] = "value"
+    leakRoot = map
+
+    val refPath = findLeak(OpenJdkInstanceRefReaders.CONCURRENT_HASH_MAP)
+
+    assertThat(refPath).hasSize(1)
+
+    with(refPath.first()) {
+      assertThat(owningClassName).isEqualTo(ConcurrentHashMap::class.qualifiedName)
+      assertThat(referenceDisplayName).isEqualTo("[key()]")
+    }
+  }
+
+  @Test fun `ConcurrentHashMap no expander`() {
+    val map = ConcurrentHashMap<Any, Any>()
+    map[SomeKey()] = Retained()
+    leakRoot = map
+
+    val refPath = findLeak { null }
+
+    assertThat(refPath).hasSize(3)
+
+    with(refPath[0]) {
+      assertThat(owningClassName).isEqualTo(ConcurrentHashMap::class.qualifiedName)
+      assertThat(referenceDisplayName).isEqualTo("table")
+    }
+    with(refPath[1]) {
+      assertThat(owningClassName).isEqualTo("java.util.concurrent.ConcurrentHashMap\$Node[]")
+      assertThat(referenceDisplayName).isEqualTo("[0]")
+    }
+    with(refPath[2]) {
+      assertThat(owningClassName).isEqualTo("java.util.concurrent.ConcurrentHashMap\$Node")
+      assertThat(referenceDisplayName).isEqualTo("val")
+    }
+  }
+
+  @Test fun `HashMap no expander`() {
+    val map = HashMap<Any, Any>()
+    map[SomeKey()] = Retained()
+    leakRoot = map
+
+    val refPath = findLeak { null }
+
+    assertThat(refPath).hasSize(3)
+
+    with(refPath[0]) {
+      assertThat(owningClassName).isEqualTo(HashMap::class.qualifiedName)
+      assertThat(referenceDisplayName).isEqualTo("table")
+    }
+    with(refPath[1]) {
+      assertThat(owningClassName).isEqualTo("java.util.HashMap\$Node[]")
+      assertThat(referenceDisplayName).isEqualTo("[0]")
+    }
+    with(refPath[2]) {
+      assertThat(owningClassName).isEqualTo("java.util.HashMap\$Node")
+      assertThat(referenceDisplayName).isEqualTo("value")
+    }
+  }
+
+  @Test fun `HashMap expanded with non string key`() {
+    val map = HashMap<Any, Any>()
+    map[SomeKey()] = Retained()
+    leakRoot = map
+
+    val refPath = findLeak(OpenJdkInstanceRefReaders.HASH_MAP)
+
+    with(refPath.first()) {
+      assertThat(referenceDisplayName).matches("\\[instance @\\d* of shark\\.OpenJdkInstanceRefReadersTest\\\$SomeKey]")
+    }
+  }
+
+  @Test fun `HashMap expanded with string key`() {
+    val map = HashMap<Any, Any>()
+    map["StringKey"] = Retained()
+    leakRoot = map
+
+    val refPath = findLeak(OpenJdkInstanceRefReaders.HASH_MAP)
+
+    with(refPath.first()) {
+      assertThat(referenceDisplayName).isEqualTo("[\"StringKey\"]")
+    }
+  }
+
+  @Test fun `HashSet expanded`() {
+    val set = HashSet<Any>()
+    set += Retained()
+    leakRoot = set
+
+    val refPath = findLeak(OpenJdkInstanceRefReaders.HASH_SET)
+
+    assertThat(refPath).hasSize(1)
+
+    with(refPath.first()) {
+      assertThat(owningClassName).isEqualTo(HashSet::class.qualifiedName)
+      assertThat(referenceDisplayName).isEqualTo("[element()]")
+    }
+  }
+
+  @Test fun `LinkedHashSet expanded`() {
+    val set = LinkedHashSet<Any>()
+    set += Retained()
+    leakRoot = set
+
+    val refPath = findLeak(OpenJdkInstanceRefReaders.HASH_SET)
+
+    assertThat(refPath).hasSize(1)
+
+    with(refPath.first()) {
+      assertThat(owningClassName).isEqualTo(LinkedHashSet::class.qualifiedName)
+      assertThat(referenceDisplayName).isEqualTo("[element()]")
+    }
+  }
+
+  @Test fun `HashSet no expander`() {
+    val set = HashSet<Any>()
+    set += Retained()
+    leakRoot = set
+
+    val refPath = findLeak { null }
+
+    assertThat(refPath).hasSize(4)
+
+    with(refPath[0]) {
+      assertThat(owningClassName).isEqualTo(HashSet::class.qualifiedName)
+      assertThat(referenceDisplayName).isEqualTo("map")
+    }
+    with(refPath[1]) {
+      assertThat(owningClassName).isEqualTo(HashMap::class.qualifiedName)
+      assertThat(referenceDisplayName).isEqualTo("table")
+    }
+    with(refPath[2]) {
+      assertThat(owningClassName).isEqualTo("java.util.HashMap\$Node[]")
+      assertThat(referenceDisplayName).isEqualTo("[0]")
+    }
+    with(refPath[3]) {
+      assertThat(owningClassName).isEqualTo("java.util.HashMap\$Node")
+      assertThat(referenceDisplayName).isEqualTo("key")
+    }
+  }
+
+  private fun findLeak(expanderFactory: OptionalFactory): List<LeakTraceReference> {
+    val hprofFile = dumpHeap()
+    return hprofFile.findPathFromLeak(computeRetainedHeapSize = false, expanderFactory)
+  }
+
+  private fun File.findPathFromLeak(
+    computeRetainedHeapSize: Boolean,
+    virtualRefReaderFactory: OptionalFactory,
+  ): List<LeakTraceReference> {
+    val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+
+    val analysis = openHeapGraph().use { graph ->
+      val referenceMatchers = defaultReferenceMatchers
+
+      val virtualRefReaders = virtualRefReaderFactory.create(graph)?.let {
+        listOf(it)
+      } ?: emptyList()
+
+      val instanceExpander = ChainingInstanceReferenceReader(
+        virtualRefReaders = virtualRefReaders + JavaLocalReferenceReader(graph, referenceMatchers),
+        fieldRefReader = FieldInstanceReferenceReader(graph, referenceMatchers)
+      )
+
+      val referenceReader = DelegatingObjectReferenceReader(
+        classReferenceReader = ClassReferenceReader(graph, referenceMatchers),
+        instanceReferenceReader = instanceExpander,
+        objectArrayReferenceReader = ObjectArrayReferenceReader()
+      )
+
+      heapAnalyzer.analyze(
+        heapDumpFile = this,
+        graph = graph,
+        leakingObjectFinder = FilteringLeakingObjectFinder(listOf(object :
+          LeakingObjectFilter {
+          override fun isLeakingObject(heapObject: HeapObject): Boolean {
+            return heapObject.asInstance?.instanceOf(Retained::class) ?: false
+          }
+        })),
+        referenceMatchers = referenceMatchers,
+        computeRetainedHeapSize = computeRetainedHeapSize,
+        objectInspectors = emptyList(),
+        metadataExtractor = MetadataExtractor.NO_OP,
+        referenceReader = referenceReader
+      )
+    }.apply {
+      if (this is HeapAnalysisFailure) {
+        println(this)
+      }
+    } as HeapAnalysisSuccess
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    println(leakTrace.toSimplePathString())
+    val index = leakTrace.referencePath.indexOfFirst { it.referenceName == ::leakRoot.name }
+    val refFromExpandedTypeIndex = index + 1
+    return leakTrace.referencePath.subList(refFromExpandedTypeIndex, leakTrace.referencePath.size)
+  }
+
+  private fun dumpHeap(): File {
+    val hprofFolder = testFolder.newFolder()
+    val hprofFile = File(hprofFolder, "jvm_heap.hprof")
+    JvmTestHeapDumper.dumpHeap(hprofFile.absolutePath)
+    return hprofFile
+  }
+}
diff --git a/shark/src/test/java/shark/ReferenceMatcherTest.kt b/shark/src/test/java/shark/ReferenceMatcherTest.kt
new file mode 100644
index 00000000..9365960d
--- /dev/null
+++ b/shark/src/test/java/shark/ReferenceMatcherTest.kt
@@ -0,0 +1,145 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.GcRoot.JniGlobal
+import shark.ReferencePattern.InstanceFieldPattern
+import shark.ReferencePattern.JavaLocalPattern
+import shark.ReferencePattern.NativeGlobalVariablePattern
+import shark.ReferencePattern.StaticFieldPattern
+import shark.ValueHolder.ReferenceHolder
+import java.io.File
+import java.lang.ref.WeakReference
+
+class ReferenceMatcherTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun shortestPathExcluded() {
+    hprofFile.writeTwoPathsToInstance()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+      referenceMatchers = listOf(
+        LibraryLeakReferenceMatcher(StaticFieldPattern("GcRoot", "shortestPath"))
+      )
+    )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath).hasSize(2)
+    assertThat(leakTrace.referencePath[0].originObject.className).isEqualTo("GcRoot")
+    assertThat(leakTrace.referencePath[0].referenceName).isEqualTo("longestPath")
+    assertThat(leakTrace.referencePath[1].originObject.className).isEqualTo("HasLeaking")
+    assertThat(leakTrace.referencePath[1].referenceName).isEqualTo("leaking")
+    assertThat(leakTrace.leakingObject.className).isEqualTo("Leaking")
+  }
+
+  @Test fun allPathsExcluded_ShortestWins() {
+    hprofFile.writeTwoPathsToInstance()
+
+    val expectedMatcher = LibraryLeakReferenceMatcher(StaticFieldPattern("GcRoot", "shortestPath"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+      referenceMatchers = listOf(
+        expectedMatcher,
+        LibraryLeakReferenceMatcher(InstanceFieldPattern("HasLeaking", "leaking"))
+      )
+    )
+
+    val leak = analysis.libraryLeaks[0]
+    assertThat(leak.pattern).isEqualTo(expectedMatcher.pattern)
+    val leakTrace = leak.leakTraces.first()
+    assertThat(leakTrace.referencePath).hasSize(1)
+    assertThat(leakTrace.referencePath[0].originObject.className).isEqualTo("GcRoot")
+    assertThat(leakTrace.referencePath[0].referenceName).isEqualTo("shortestPath")
+    assertThat(leakTrace.leakingObject.className).isEqualTo("Leaking")
+  }
+
+  @Test fun noPathToInstanceNeverReachable() {
+    hprofFile.writeTwoPathsToInstance()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+      referenceMatchers = listOf(
+        IgnoredReferenceMatcher(StaticFieldPattern("GcRoot", "shortestPath")),
+        IgnoredReferenceMatcher(InstanceFieldPattern("HasLeaking", "leaking"))
+      )
+    )
+    assertThat(analysis.libraryLeaks).isEmpty()
+  }
+
+  @Test fun excludedThread() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val matcher = LibraryLeakReferenceMatcher(JavaLocalPattern("kroutine"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+      referenceMatchers = listOf(matcher)
+    )
+
+    val leak = analysis.libraryLeaks[0]
+    assertThat(leak.pattern).isEqualTo(matcher.pattern)
+  }
+
+  @Test fun overrideSuperclassExclusion() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["ref"] =
+          keyedWeakReference(referentInstanceId = "Leaking" instance {})
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+      referenceMatchers = listOf(
+        LibraryLeakReferenceMatcher(
+          pattern = InstanceFieldPattern(WeakReference::class.java.name, "referent")
+        ),
+        IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("leakcanary.KeyedWeakReference", "referent")
+        )
+      )
+    )
+    assertThat(analysis.libraryLeaks).isEmpty()
+  }
+
+  @Test fun nativeGlobalVariableLibraryLeak() {
+    hprofFile.dump {
+      gcRoot(JniGlobal(id = "Leaking".watchedInstance {}.value, jniGlobalRefId = 42))
+    }
+
+    val matcher = LibraryLeakReferenceMatcher(NativeGlobalVariablePattern("Leaking"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+      referenceMatchers = listOf(matcher)
+    )
+    val leak = analysis.libraryLeaks[0]
+    assertThat(leak.pattern).isEqualTo(matcher.pattern)
+  }
+
+  @Test fun nativeGlobalVariableShortestPathExcluded() {
+    hprofFile.dump {
+      val leaking = instance(clazz("Leaking"))
+      keyedWeakReference(leaking)
+      val hasLeaking = instance(
+        clazz("HasLeaking", fields = listOf("leaking" to ReferenceHolder::class)),
+        fields = listOf(leaking)
+      )
+      clazz("GcRoot", staticFields = listOf("longestPath" to hasLeaking))
+      gcRoot(JniGlobal(id = leaking.value, jniGlobalRefId = 42))
+    }
+
+    val matcher = LibraryLeakReferenceMatcher(NativeGlobalVariablePattern("Leaking"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+      referenceMatchers = listOf(matcher)
+    )
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath).hasSize(2)
+    assertThat(leakTrace.referencePath[0].originObject.className).isEqualTo("GcRoot")
+    assertThat(leakTrace.referencePath[0].referenceName).isEqualTo("longestPath")
+  }
+}
\ No newline at end of file
diff --git a/shark/src/test/java/shark/RetainedSizeTest.kt b/shark/src/test/java/shark/RetainedSizeTest.kt
new file mode 100644
index 00000000..fe00929a
--- /dev/null
+++ b/shark/src/test/java/shark/RetainedSizeTest.kt
@@ -0,0 +1,358 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+import java.io.File
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.ThreadObject
+import shark.HeapObject.HeapInstance
+
+class RetainedSizeTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun emptyLeakingInstance() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {}
+      }
+    }
+
+    val retainedSize = retainedInstances()
+      .firstRetainedSize()
+
+    assertThat(retainedSize).isEqualTo(0)
+  }
+
+  @Test fun leakingInstanceWithPrimitiveType() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = LongHolder(42)
+        }
+      }
+    }
+    val retainedSize = retainedInstances()
+      .firstRetainedSize()
+
+    // 8 bytes for long
+    assertThat(retainedSize).isEqualTo(8)
+  }
+
+  @Test fun leakingInstanceWithPrimitiveArray() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = "42".charArrayDump
+        }
+      }
+    }
+
+    val retainedSize = retainedInstances()
+      .firstRetainedSize()
+
+    // 4 byte reference, 2 bytes per char
+    assertThat(retainedSize).isEqualTo(8)
+  }
+
+  @Test fun leakingInstanceWithString() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = string("42")
+        }
+      }
+    }
+
+    val retainedSize = retainedInstances()
+      .firstRetainedSize()
+
+    // 4 byte reference, string (4 array ref + 4 int + 2 byte per char)
+    assertThat(retainedSize).isEqualTo(16)
+  }
+
+  @Test fun leakingInstanceWithInstance() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = "FortyTwo" instance {
+            field["number"] = IntHolder(42)
+          }
+        }
+      }
+    }
+
+    val retainedSize = retainedInstances()
+      .firstRetainedSize()
+
+    // 4 byte reference + 4 byte int
+    assertThat(retainedSize).isEqualTo(8)
+  }
+
+  @Test fun leakingInstanceWithPrimitiveWrapper() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = "java.lang.Integer" instance {
+            field["value"] = IntHolder(42)
+          }
+        }
+      }
+    }
+
+    val retainedSize = retainedInstances()
+      .firstRetainedSize()
+
+    // 4 byte reference, int field
+    assertThat(retainedSize).isEqualTo(8)
+  }
+
+  @Test fun leakingInstanceWithPrimitiveWrapperArray() {
+    hprofFile.dump {
+      val intWrapperClass = clazz("java.lang.Integer", fields = listOf("value" to IntHolder::class))
+
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = objectArrayOf(
+            intWrapperClass,
+            instance(
+              intWrapperClass,
+              fields = listOf<ValueHolder>(IntHolder(4))
+            ),
+            instance(
+              intWrapperClass,
+              fields = listOf<ValueHolder>(IntHolder(2))
+            )
+          )
+        }
+      }
+    }
+
+    val retainedSize = retainedInstances()
+      .firstRetainedSize()
+
+    // 4 byte reference * 3, 2 ints
+    assertThat(retainedSize).isEqualTo(20)
+  }
+
+  @Test fun leakingInstanceWithObjectArray() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = objectArray("Forty" instance {}, "Two" instance {})
+        }
+      }
+    }
+
+    val retainedSize = retainedInstances()
+      .firstRetainedSize()
+
+    // 4 byte reference, 4 bytes per object entry
+    assertThat(retainedSize).isEqualTo(12)
+  }
+
+  @Test fun leakingInstanceWithDeepRetainedObjects() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = "Forty" instance {
+            field["forty"] = "Two" instance {
+              field["two"] = string("42")
+            }
+          }
+        }
+      }
+    }
+
+    val retainedSize = retainedInstances()
+      .firstRetainedSize()
+
+    // 4 byte reference * 3, string (4 array ref + 4 int + 2 byte per char)
+    assertThat(retainedSize).isEqualTo(24)
+  }
+
+  @Test fun leakingInstanceNotDominating() {
+    hprofFile.dump {
+      val fortyTwo = string("42")
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = fortyTwo
+        }
+        staticField["rootDominator"] = fortyTwo
+      }
+    }
+
+    val retainedSize = retainedInstances()
+      .firstRetainedSize()
+
+    // 4 byte reference
+    assertThat(retainedSize).isEqualTo(4)
+  }
+
+  @Test fun leakingInstanceWithSuperClass() {
+    hprofFile.dump {
+      val parentClass = clazz("Parent", fields = listOf("value" to LongHolder::class))
+      val childClass =
+        clazz("Child", superclassId = parentClass, fields = listOf("value" to IntHolder::class))
+
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["answer"] = instance(childClass, listOf(LongHolder(42), IntHolder(42)))
+        }
+      }
+    }
+
+    val retainedSize = retainedInstances()
+      .firstRetainedSize()
+
+    // 4 byte reference + Long + Int
+    assertThat(retainedSize).isEqualTo(16)
+  }
+
+  @Test fun leakingInstanceDominatedByOther() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "GrandParentLeaking" watchedInstance {
+          field["answer"] = ShortHolder(42)
+          field["child"] = "ParentLeaking" watchedInstance {
+            field["answer"] = IntHolder(42)
+            field["child"] = "ChildLeaking" watchedInstance {
+              field["answer"] = LongHolder(42)
+            }
+          }
+        }
+      }
+    }
+
+    val retainedInstances = retainedInstances()
+    require(retainedInstances.size == 1)
+
+    val instance = retainedInstances[0]
+
+    assertThat(instance.leakTraces.first().leakingObject.className).isEqualTo("GrandParentLeaking")
+    // 4 bytes per ref * 2 + short + int + long
+    assertThat(instance.totalRetainedHeapByteSize).isEqualTo(22)
+  }
+
+  @Test fun crossDominatedIsNotDominated() {
+    hprofFile.dump {
+      val fortyTwo = string("42")
+      "GcRoot1" clazz {
+        staticField["shortestPath"] = "Leaking1" watchedInstance {
+          field["answer"] = fortyTwo
+        }
+      }
+      "GcRoot2" clazz {
+        staticField["shortestPath"] = "Leaking2" watchedInstance {
+          field["answer"] = fortyTwo
+        }
+      }
+    }
+
+    val retainedInstances = retainedInstances()
+    require(retainedInstances.size == 2)
+
+    retainedInstances.forEach { instance ->
+      // 4 byte reference
+      assertThat(instance.totalRetainedHeapByteSize).isEqualTo(4)
+    }
+  }
+
+  @Test fun nativeSizeAccountedFor() {
+    val width = 24
+    val height = 16
+    // pixel count * 4 bytes per pixel (ARGB_8888)
+    val nativeBitmapSize = width * height * 4
+
+    hprofFile.dump {
+      val bitmap = "android.graphics.Bitmap" instance {
+        field["mWidth"] = IntHolder(width)
+        field["mHeight"] = IntHolder(height)
+      }
+
+      val referenceClass =
+        clazz("java.lang.ref.Reference", fields = listOf("referent" to ReferenceHolder::class))
+      val cleanerClass = clazz(
+        "sun.misc.Cleaner", clazz("java.lang.ref.PhantomReference", referenceClass),
+        fields = listOf("thunk" to ReferenceHolder::class)
+      )
+
+      instance(
+        cleanerClass,
+        fields = listOf("libcore.util.NativeAllocationRegistry\$CleanerThunk" instance {
+          field["this\$0"] = "libcore.util.NativeAllocationRegistry" instance {
+            field["size"] = LongHolder(nativeBitmapSize.toLong())
+          }
+        }, bitmap)
+      )
+
+      "GcRoot" clazz {
+        staticField["shortestPath"] = "Leaking" watchedInstance {
+          field["bitmap"] = bitmap
+        }
+      }
+    }
+
+    val retainedSize = retainedInstances()
+      .firstRetainedSize()
+
+    // 4 byte reference + 2 * Int + native size
+    assertThat(retainedSize).isEqualTo(12 + nativeBitmapSize)
+  }
+
+  @Test fun `thread retained size includes java local references`() {
+    hprofFile.dump {
+      val threadInstance = Thread::class.java.name instance { }
+      gcRoot(
+        ThreadObject(
+          id = threadInstance.value,
+          threadSerialNumber = 42,
+          stackTraceSerialNumber = 0
+        )
+      )
+      val longArrayId = primitiveLongArray(LongArray(3))
+      gcRoot(JavaFrame(id = longArrayId, threadSerialNumber = 42, frameNumber = 0))
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysis>(
+      computeRetainedHeapSize = true,
+      leakingObjectFinder = FilteringLeakingObjectFinder(listOf(FilteringLeakingObjectFinder.LeakingObjectFilter { heapObject ->
+        heapObject is HeapInstance &&
+          heapObject.instanceClassName == Thread::class.java.name
+      }))
+    )
+    println(analysis.toString())
+    analysis as HeapAnalysisSuccess
+    val retainedInstances = analysis.applicationLeaks
+    val retainedSize = retainedInstances.firstRetainedSize()
+
+    // LongArray(3), 8 bytes per long
+    assertThat(retainedSize).isEqualTo(3 * 8)
+  }
+
+  private fun retainedInstances(): List<Leak> {
+    val analysis = hprofFile.checkForLeaks<HeapAnalysis>(computeRetainedHeapSize = true)
+    println(analysis.toString())
+    analysis as HeapAnalysisSuccess
+    return analysis.applicationLeaks
+  }
+
+  private fun List<Leak>.firstRetainedSize(): Int {
+    return map { it.totalRetainedHeapByteSize!! }
+      .first()
+  }
+}
diff --git a/shark/src/test/java/shark/TestUtil.kt b/shark/src/test/java/shark/TestUtil.kt
new file mode 100644
index 00000000..74bbd014
--- /dev/null
+++ b/shark/src/test/java/shark/TestUtil.kt
@@ -0,0 +1,104 @@
+package shark
+
+import java.io.File
+import java.lang.ref.PhantomReference
+import java.lang.ref.SoftReference
+import java.lang.ref.WeakReference
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.ReferencePattern.InstanceFieldPattern
+import shark.ReferencePattern.JavaLocalPattern
+
+fun <T : HeapAnalysis> DualSourceProvider.checkForLeaks(
+  objectInspectors: List<ObjectInspector> = emptyList(),
+  computeRetainedHeapSize: Boolean = false,
+  referenceMatchers: List<ReferenceMatcher> = defaultReferenceMatchers,
+  metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,
+  proguardMapping: ProguardMapping? = null,
+  leakingObjectFinder: LeakingObjectFinder = FilteringLeakingObjectFinder(ObjectInspectors.jdkLeakingObjectFilters),
+  file: File = File("/no/file")
+): T {
+  val inspectors = if (ObjectInspectors.KEYED_WEAK_REFERENCE !in objectInspectors) {
+    objectInspectors + ObjectInspectors.KEYED_WEAK_REFERENCE
+  } else {
+    objectInspectors
+  }
+  val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+
+  val result = openHeapGraph(proguardMapping).use { graph ->
+    heapAnalyzer.analyze(
+      heapDumpFile = file,
+      graph = graph,
+      leakingObjectFinder = leakingObjectFinder,
+      referenceMatchers = referenceMatchers,
+      computeRetainedHeapSize = computeRetainedHeapSize,
+      objectInspectors = inspectors,
+      metadataExtractor = metadataExtractor,
+    )
+  }
+  if (result is HeapAnalysisFailure) {
+    println(result)
+  }
+  @Suppress("UNCHECKED_CAST")
+  return result as T
+}
+
+fun <T : HeapAnalysis> File.checkForLeaks(
+  objectInspectors: List<ObjectInspector> = emptyList(),
+  computeRetainedHeapSize: Boolean = false,
+  referenceMatchers: List<ReferenceMatcher> = defaultReferenceMatchers,
+  metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,
+  proguardMapping: ProguardMapping? = null,
+  leakingObjectFinder: LeakingObjectFinder = FilteringLeakingObjectFinder(ObjectInspectors.jdkLeakingObjectFilters),
+): T {
+  return FileSourceProvider(this).checkForLeaks(
+    objectInspectors, computeRetainedHeapSize, referenceMatchers, metadataExtractor,
+    proguardMapping, leakingObjectFinder, this
+  )
+}
+
+val defaultReferenceMatchers: List<ReferenceMatcher> =
+  listOf(
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern(WeakReference::class.java.name, "referent")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("leakcanary.KeyedWeakReference", "referent")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern(SoftReference::class.java.name, "referent")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern(PhantomReference::class.java.name, "referent")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("java.lang.ref.Finalizer", "prev")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("java.lang.ref.Finalizer", "element")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("java.lang.ref.Finalizer", "next")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("java.lang.ref.FinalizerReference", "prev")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("java.lang.ref.FinalizerReference", "element")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("java.lang.ref.FinalizerReference", "next")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("sun.misc.Cleaner", "prev")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("sun.misc.Cleaner", "next")
+    ),
+
+    IgnoredReferenceMatcher(
+      pattern = JavaLocalPattern("FinalizerWatchdogDaemon")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = JavaLocalPattern("main")
+    )
+  )
diff --git a/shark/src/test/java/shark/UnreachableObjectRenderingTest.kt b/shark/src/test/java/shark/UnreachableObjectRenderingTest.kt
new file mode 100644
index 00000000..6f30cb10
--- /dev/null
+++ b/shark/src/test/java/shark/UnreachableObjectRenderingTest.kt
@@ -0,0 +1,31 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+
+class UnreachableObjectRenderingTest {
+
+  @Test fun `renders unreachable object`() {
+    val heapDump = dump {
+      "com.example.SomeClass" watchedInstance {
+      }
+    }
+
+    val analysis = heapDump.checkForLeaks<HeapAnalysisSuccess>()
+
+    analysis renders """
+    com.example.SomeClass instance
+    _  Leaking: YES (ObjectWatcher was watching this because its lifecycle has ended)
+    _  key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    _  watchDurationMillis = 25000
+    _  retainedDurationMillis = 10000
+        """
+  }
+
+  private infix fun HeapAnalysisSuccess.renders(expectedString: String) {
+    assertThat(unreachableObjects[0].toString()).isEqualTo(
+      expectedString.trimIndent().replace('_', LeakTrace.ZERO_WIDTH_SPACE)
+    )
+  }
+
+}
\ No newline at end of file
diff --git a/shark/src/test/java/shark/internal/AndroidReferenceReadersHprofTest.kt b/shark/src/test/java/shark/internal/AndroidReferenceReadersHprofTest.kt
new file mode 100644
index 00000000..62d7a097
--- /dev/null
+++ b/shark/src/test/java/shark/internal/AndroidReferenceReadersHprofTest.kt
@@ -0,0 +1,104 @@
+package shark.internal
+
+import java.io.File
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.FilteringLeakingObjectFinder
+import shark.HeapAnalysisSuccess
+import shark.HeapGraph
+import shark.HeapObject
+import shark.HeapObject.HeapInstance
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.IgnoredReferenceMatcher
+import shark.LeakTraceReference.ReferenceType.ARRAY_ENTRY
+import shark.LeakingObjectFinder
+import shark.ReferenceMatcher
+import shark.ReferencePattern.StaticFieldPattern
+import shark.checkForLeaks
+import shark.defaultReferenceMatchers
+import shark.internal.AndroidReferenceReaders.Companion
+
+class AndroidReferenceReadersHprofTest {
+
+  @Test fun `safe iterable map traversed as dictionary`() {
+    val hprofFile = "safe_iterable_map.hprof".classpathFile()
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+    val leakTrace = analysis.applicationLeaks.single().leakTraces.single()
+
+    val mapReference =
+      leakTrace.referencePath.single { it.owningClassSimpleName == "FastSafeIterableMap" }
+    assertThat(mapReference.referenceName).isEqualTo("key()")
+    assertThat(mapReference.referenceType).isEqualTo(ARRAY_ENTRY)
+  }
+
+  @Test fun `API 25 HashMap$HashMapEntry supported`() {
+    val hprofFile = "hashmap_api_25.hprof".classpathFile()
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+    val leakTrace = analysis.applicationLeaks.single().leakTraces.single()
+
+    val mapReference =
+      leakTrace.referencePath.single { it.owningClassSimpleName == "HashMap" }
+    assertThat(mapReference.referenceName).isEqualTo("\"leaking\"")
+    assertThat(mapReference.referenceType).isEqualTo(ARRAY_ENTRY)
+  }
+
+  @Test fun `ArraySet traversed as set`() {
+    // This hprof happens to have an ArraySet in it.
+    val hprofFile = "safe_iterable_map.hprof".classpathFile()
+
+    val analysis = hprofFile.checkForFakeArraySetLeak()
+
+    val leakTrace = analysis.applicationLeaks.single().leakTraces.single()
+
+    println(leakTrace)
+
+    val mapReference =
+      leakTrace.referencePath.single { it.owningClassSimpleName == "ArraySet" }
+    assertThat(mapReference.referenceName).isEqualTo("element()")
+    assertThat(mapReference.referenceType).isEqualTo(ARRAY_ENTRY)
+  }
+}
+
+fun File.checkForFakeArraySetLeak(): HeapAnalysisSuccess {
+  val instanceHeldByArraySet =
+    "android.view.accessibility.AccessibilityNodeInfo\$AccessibilityAction"
+
+  class ArraySetFakeLeakingObjectFinder : LeakingObjectFinder {
+    override fun findLeakingObjectIds(graph: HeapGraph): Set<Long> {
+      val arraySetInstances = graph.findClassByName("android.util.ArraySet")!!
+        .instances
+        .map { arraySetInstance ->
+          arraySetInstance to arraySetInstance["android.util.ArraySet", "mArray"]!!
+            .valueAsObjectArray!!
+            .readElements()
+            .filter {
+              it.asObject?.asInstance?.instanceClass?.name == instanceHeldByArraySet
+            }
+            .toList()
+        }
+      val firstElementReferencedByArraySet = arraySetInstances.first { (_, elements) ->
+        elements.isNotEmpty()
+      }.second.first()
+
+      return setOf(firstElementReferencedByArraySet.asObjectId!!)
+    }
+  }
+  return checkForLeaks(
+    referenceMatchers = defaultReferenceMatchers + IgnoredReferenceMatcher(
+      StaticFieldPattern(
+        instanceHeldByArraySet,
+        "ACTION_FOCUS"
+      )
+    ),
+    leakingObjectFinder = ArraySetFakeLeakingObjectFinder()
+  )
+}
+
+fun String.classpathFile(): File {
+  val classLoader = Thread.currentThread()
+    .contextClassLoader
+  val url = classLoader.getResource(this)!!
+  return File(url.path)
+}
+
+
diff --git a/shark/src/test/java/shark/internal/DominatorTreeTest.kt b/shark/src/test/java/shark/internal/DominatorTreeTest.kt
new file mode 100644
index 00000000..6c2e496f
--- /dev/null
+++ b/shark/src/test/java/shark/internal/DominatorTreeTest.kt
@@ -0,0 +1,200 @@
+package shark.internal
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.ValueHolder
+
+@Suppress("UsePropertyAccessSyntax")
+class DominatorTreeTest {
+
+  var latestObjectId: Long = 0
+  private fun newObjectId() = ++latestObjectId
+
+  @Suppress("PrivatePropertyName")
+  private val `10 bytes per object`: (Long) -> Int = { 10 }
+
+  @Test fun `new object is not already dominated`() {
+    val tree = DominatorTree()
+    val root = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+
+    val alreadyDominated = tree.updateDominated(newObjectId(), root)
+
+    assertThat(alreadyDominated).isFalse()
+  }
+
+  @Test fun `dominated object is already dominated`() {
+    val tree = DominatorTree()
+    val root1 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val root2 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val child = newObjectId().apply { tree.updateDominated(this, root1) }
+
+    val alreadyDominated = tree.updateDominated(child, root2)
+
+    assertThat(alreadyDominated).isTrue()
+  }
+
+  @Test fun `only retained objects are returned in sizes map`() {
+    val tree = DominatorTree()
+    val root = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val child = newObjectId().apply { tree.updateDominated(this, root) }
+
+    val sizes = tree.computeRetainedSizes(setOf(child), `10 bytes per object`)
+
+    assertThat(sizes).containsOnlyKeys(child)
+  }
+
+  @Test fun `single root has self size as retained size`() {
+    val tree = DominatorTree()
+    val root = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+
+    val sizes = tree.computeRetainedSizes(setOf(root), `10 bytes per object`)
+
+    assertThat(sizes[root]).isEqualTo(10 to 1)
+  }
+
+  @Test fun `size of dominator includes dominated`() {
+    val tree = DominatorTree()
+    val root = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    tree.updateDominated(newObjectId(), root)
+
+    val sizes = tree.computeRetainedSizes(setOf(root), `10 bytes per object`)
+
+    assertThat(sizes[root]).isEqualTo(20 to 2)
+  }
+
+  @Test fun `size of chain of dominators is additive`() {
+    val tree = DominatorTree()
+    val root = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val child = newObjectId().apply { tree.updateDominated(this, root) }
+    tree.updateDominated(newObjectId(), child)
+
+    val sizes = tree.computeRetainedSizes(setOf(root, child), `10 bytes per object`)
+
+    assertThat(sizes[root]).isEqualTo(30 to 3)
+    assertThat(sizes[child]).isEqualTo(20 to 2)
+  }
+
+  @Test fun `diamond dominators don't dominate`() {
+    val tree = DominatorTree()
+    val root = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val child1 = newObjectId().apply { tree.updateDominated(this, root) }
+    val child2 = newObjectId().apply { tree.updateDominated(this, root) }
+    val grandChild = newObjectId()
+    tree.updateDominated(grandChild, child1)
+    tree.updateDominated(grandChild, child2)
+
+    val sizes = tree.computeRetainedSizes(setOf(root, child1, child2), `10 bytes per object`)
+
+    assertThat(sizes[child1]).isEqualTo(10 to 1)
+    assertThat(sizes[child2]).isEqualTo(10 to 1)
+    assertThat(sizes[root]).isEqualTo(40 to 4)
+  }
+
+  @Test fun `two dominators dominated by common ancestor`() {
+    val tree = DominatorTree()
+    val root = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val child1 = newObjectId().apply { tree.updateDominated(this, root) }
+    val child2 = newObjectId().apply { tree.updateDominated(this, root) }
+    val grandChild = newObjectId()
+    tree.updateDominated(grandChild, child1)
+    tree.updateDominated(grandChild, child2)
+
+    val sizes = tree.computeRetainedSizes(setOf(root, child1, child2), `10 bytes per object`)
+
+    assertThat(sizes[child1]).isEqualTo(10 to 1)
+    assertThat(sizes[child2]).isEqualTo(10 to 1)
+    assertThat(sizes[root]).isEqualTo(40 to 4)
+  }
+
+  @Test fun `two dominators dominated by lowest common ancestor`() {
+    val tree = DominatorTree()
+    val root = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val child = newObjectId().apply { tree.updateDominated(this, root) }
+    val grandChild1 = newObjectId().apply { tree.updateDominated(this, child) }
+    val grandChild2 = newObjectId().apply { tree.updateDominated(this, child) }
+    val grandGrandChild = newObjectId()
+    tree.updateDominated(grandGrandChild, grandChild1)
+    tree.updateDominated(grandGrandChild, grandChild2)
+
+    val sizes =
+      tree.computeRetainedSizes(setOf(root, child, grandChild1, grandChild2), `10 bytes per object`)
+
+    assertThat(sizes[grandChild1]).isEqualTo(10 to 1)
+    assertThat(sizes[grandChild1]).isEqualTo(10 to 1)
+    assertThat(sizes[child]).isEqualTo(40 to 4)
+    assertThat(sizes[root]).isEqualTo(50 to 5)
+  }
+
+  @Test fun `two separate trees do not share size`() {
+    val tree = DominatorTree()
+    val root1 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val root2 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    var descendant1 = root1
+    var descendant2 = root2
+    for (i in 1..10) {
+      descendant1 = newObjectId().apply { tree.updateDominated(this, descendant1) }
+      descendant2 = newObjectId().apply { tree.updateDominated(this, descendant2) }
+    }
+
+    val sizes =
+      tree.computeRetainedSizes(setOf(root1, root2), `10 bytes per object`)
+
+    assertThat(sizes[root1]).isEqualTo(110 to 11)
+    assertThat(sizes[root2]).isEqualTo(110 to 11)
+  }
+
+  @Test fun `no common descendant does not include size`() {
+    val tree = DominatorTree()
+    val root1 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val root2 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    var descendant = root1
+    for (i in 1..10) {
+      descendant = newObjectId().apply { tree.updateDominated(this, descendant) }
+    }
+    tree.updateDominated(descendant, root2)
+
+    val sizes =
+      tree.computeRetainedSizes(setOf(root1, root2), `10 bytes per object`)
+
+    assertThat(sizes[root1]).isEqualTo(100 to 10)
+    assertThat(sizes[root2]).isEqualTo(10 to 1)
+  }
+
+  @Test fun `only compute retained size for retained objects`() {
+    val tree = DominatorTree()
+    val root1 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val root2 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val child = newObjectId().apply { tree.updateDominated(this, root1) }
+    val grandChild = newObjectId().apply { tree.updateDominated(this, child) }
+    val grandGrandChild = newObjectId().apply { tree.updateDominated(this, grandChild) }
+    tree.updateDominated(grandGrandChild, root2)
+
+    val objectsWithComputedSize = mutableSetOf<Long>()
+    tree.computeRetainedSizes(setOf(child)) { objectId ->
+      objectsWithComputedSize += objectId
+      1
+    }
+
+    assertThat(objectsWithComputedSize).containsOnly(child, grandChild)
+  }
+
+  @Test fun `null ref dominates all`() {
+    val tree = DominatorTree()
+    val root1 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val root2 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val root3 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val child = newObjectId()
+    tree.updateDominated(child, root1)
+    tree.updateDominated(child, root2)
+    val grandChild = newObjectId().apply { tree.updateDominated(this, child) }
+
+    val fullDominatorTree = tree.buildFullDominatorTree(`10 bytes per object`)
+
+    assertThat(fullDominatorTree.getValue(root1).retainedSize).isEqualTo(10)
+    assertThat(fullDominatorTree.getValue(root2).retainedSize).isEqualTo(10)
+    assertThat(fullDominatorTree.getValue(root3).retainedSize).isEqualTo(10)
+    assertThat(fullDominatorTree.getValue(child).retainedSize).isEqualTo(20)
+    assertThat(fullDominatorTree.getValue(grandChild).retainedSize).isEqualTo(10)
+    assertThat(fullDominatorTree.getValue(ValueHolder.NULL_REFERENCE).retainedSize).isEqualTo(50)
+  }
+}
\ No newline at end of file
diff --git a/shark/src/test/java/shark/internal/ShallowSizeCalculatorTest.kt b/shark/src/test/java/shark/internal/ShallowSizeCalculatorTest.kt
new file mode 100644
index 00000000..ee45a490
--- /dev/null
+++ b/shark/src/test/java/shark/internal/ShallowSizeCalculatorTest.kt
@@ -0,0 +1,107 @@
+package shark.internal
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.dump
+import java.io.File
+
+private const val EMPTY_CLASS_SIZE = 42
+
+class ShallowSizeCalculatorTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun `empty class has instance size 0`() {
+    hprofFile.dump {
+      "SomeClass" instance {}
+    }
+
+    val instanceSize = hprofFile.openHeapGraph().use { graph ->
+      val calculator = ShallowSizeCalculator(graph)
+      calculator.computeShallowSize(
+        graph.findClassByName("SomeClass")!!.instances.single().objectId
+      )
+    }
+
+    assertThat(instanceSize).isEqualTo(0)
+  }
+
+  @Test fun `class with static field has instance size 0`() {
+    hprofFile.dump {
+      "SomeClass" instance {
+        staticField["someStaticField"] = LongHolder(42)
+      }
+    }
+
+    val instanceSize = hprofFile.openHeapGraph().use { graph ->
+      val calculator = ShallowSizeCalculator(graph)
+      calculator.computeShallowSize(
+        graph.findClassByName("SomeClass")!!.instances.single().objectId
+      )
+    }
+
+    assertThat(instanceSize).isEqualTo(0)
+  }
+
+  @Test fun `class with int field has instance size 4`() {
+    hprofFile.dump {
+      "SomeClass" instance {
+        field["someIntField"] = IntHolder(42)
+      }
+    }
+
+    val instanceSize = hprofFile.openHeapGraph().use { graph ->
+      val calculator = ShallowSizeCalculator(graph)
+      calculator.computeShallowSize(
+        graph.findClassByName("SomeClass")!!.instances.single().objectId
+      )
+    }
+    assertThat(instanceSize).isEqualTo(4)
+  }
+
+  @Test fun `empty class has size EMPTY_CLASS_SIZE`() {
+    hprofFile.dump {
+      "SomeClass" clazz {}
+    }
+
+    val classSize = hprofFile.openHeapGraph().use { graph ->
+      val calculator = ShallowSizeCalculator(graph)
+      calculator.computeShallowSize(graph.findClassByName("SomeClass")!!.objectId)
+    }
+    assertThat(classSize).isEqualTo(EMPTY_CLASS_SIZE)
+  }
+
+  @Test fun `class with static int field has class size that includes field`() {
+    hprofFile.dump {
+      "SomeClass" clazz {
+        staticField["someStaticField"] = IntHolder(42)
+      }
+    }
+
+    val classSize = hprofFile.openHeapGraph().use { graph ->
+      val calculator = ShallowSizeCalculator(graph)
+      calculator.computeShallowSize(graph.findClassByName("SomeClass")!!.objectId)
+    }
+
+    val bytesForFieldId = 4
+    val bytesForFieldType = 1
+    val bytesForFieldValue = 4
+
+    assertThat(classSize).isEqualTo(
+      EMPTY_CLASS_SIZE + bytesForFieldId + bytesForFieldType + bytesForFieldValue
+    )
+  }
+}
\ No newline at end of file
diff --git a/shark/src/test/resources/hashmap_api_25.hprof b/shark/src/test/resources/hashmap_api_25.hprof
new file mode 100644
index 00000000..dcb9e0ab
Binary files /dev/null and b/shark/src/test/resources/hashmap_api_25.hprof differ
diff --git a/shark/src/test/resources/safe_iterable_map.hprof b/shark/src/test/resources/safe_iterable_map.hprof
new file mode 100644
index 00000000..143aa879
Binary files /dev/null and b/shark/src/test/resources/safe_iterable_map.hprof differ
```

