```diff
diff --git a/.cargo_vcs_info.json b/.cargo_vcs_info.json
index 793a871..4c46237 100644
--- a/.cargo_vcs_info.json
+++ b/.cargo_vcs_info.json
@@ -1,6 +1,6 @@
 {
   "git": {
-    "sha1": "4f9fa49ca907b831fdc3aecdfaec36b16d03c8d8"
+    "sha1": "7c6858deab9cdd6812822e9e1060d44df674455b"
   },
   "path_in_vcs": "bindgen"
 }
\ No newline at end of file
diff --git a/Android.bp b/Android.bp
index b0ed501..66ba1e2 100644
--- a/Android.bp
+++ b/Android.bp
@@ -1,52 +1,24 @@
 // This file is generated by cargo_embargo.
-// Do not modify this file after the first "rust_*" or "genrule" module
-// because the changes will be overridden on upgrade.
-// Content before the first "rust_*" or "genrule" module is preserved.
+// Do not modify this file because the changes will be overridden on upgrade.
 
 package {
     default_applicable_licenses: ["external_rust_crates_bindgen_license"],
 }
 
-// Added automatically by a large-scale-change that took the approach of
-// 'apply every license found to every target'. While this makes sure we respect
-// every license restriction, it may not be entirely correct.
-//
-// e.g. GPL in an MIT project might only apply to the contrib/ directory.
-//
-// Please consider splitting the single license below into multiple licenses,
-// taking care not to lose any license_kind information, and overriding the
-// default license using the 'licenses: [...]' property on targets as needed.
-//
-// For unused files, consider creating a 'fileGroup' with "//visibility:private"
-// to attach the license to, and including a comment whether the files may be
-// used in the current project.
-// See: http://go/android-license-faq
 license {
     name: "external_rust_crates_bindgen_license",
     visibility: [":__subpackages__"],
-    license_kinds: [
-        "SPDX-license-identifier-Apache-2.0",
-        "SPDX-license-identifier-BSD",
-    ],
-    license_text: [
-        "LICENSE",
-    ],
-}
-
-genrule {
-    name: "copy_bindgen_build_out",
-    srcs: ["out/*"],
-    cmd: "cp $(in) $(genDir)",
-    out: ["host-target.txt"],
+    license_kinds: ["SPDX-license-identifier-BSD-3-Clause"],
+    license_text: ["LICENSE"],
 }
 
 rust_library_host {
     name: "libbindgen",
+    host_cross_supported: false,
     crate_name: "bindgen",
     cargo_env_compat: true,
-    cargo_pkg_version: "0.69.1",
+    cargo_pkg_version: "0.69.4",
     crate_root: "lib.rs",
-    srcs: [":copy_bindgen_build_out"],
     edition: "2018",
     features: [
         "__cli",
@@ -59,9 +31,9 @@ rust_library_host {
         "libbitflags",
         "libcexpr",
         "libclang_sys",
+        "libitertools",
         "liblazy_static",
         "liblazycell",
-        "libpeeking_take_while",
         "libproc_macro2",
         "libquote",
         "libregex",
diff --git a/Cargo.toml b/Cargo.toml
index 24132d6..c4f5f56 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -13,7 +13,7 @@
 edition = "2018"
 rust-version = "1.60.0"
 name = "bindgen"
-version = "0.69.1"
+version = "0.69.4"
 authors = [
     "Jyun-Yan You <jyyou.tw@gmail.com>",
     "Emilio Cobos √Ålvarez <emilio@crisal.io>",
@@ -79,6 +79,10 @@ version = "0.6"
 version = "1"
 features = ["clang_6_0"]
 
+[dependencies.itertools]
+version = ">=0.10,<0.13"
+default-features = false
+
 [dependencies.lazy_static]
 version = "1"
 
@@ -89,9 +93,6 @@ version = "1"
 version = "0.4"
 optional = true
 
-[dependencies.peeking_take_while]
-version = "0.1.2"
-
 [dependencies.prettyplease]
 version = "0.2.7"
 features = ["verbatim"]
@@ -106,10 +107,10 @@ version = "1"
 default-features = false
 
 [dependencies.regex]
-version = "1.5"
+version = "1.5.1"
 features = [
     "std",
-    "unicode",
+    "unicode-perl",
 ]
 default-features = false
 
@@ -135,7 +136,7 @@ default-features = false
 [features]
 __cli = []
 __testing_only_extra_assertions = []
-__testing_only_libclang_5 = []
+__testing_only_libclang_16 = []
 __testing_only_libclang_9 = []
 default = [
     "logging",
diff --git a/Cargo.toml.orig b/Cargo.toml.orig
index 18f43c0..a231efc 100644
--- a/Cargo.toml.orig
+++ b/Cargo.toml.orig
@@ -14,7 +14,7 @@ readme = "../README.md"
 repository = "https://github.com/rust-lang/rust-bindgen"
 documentation = "https://docs.rs/bindgen"
 homepage = "https://rust-lang.github.io/rust-bindgen/"
-version = "0.69.1"
+version = "0.69.4"
 edition = "2018"
 build = "build.rs"
 # If you change this, also update README.md and msrv in .github/workflows/bindgen.yml
@@ -29,14 +29,14 @@ annotate-snippets = { version = "0.9.1", features = ["color"], optional = true }
 bitflags = "2.2.1"
 cexpr = "0.6"
 clang-sys = { version = "1", features = ["clang_6_0"] }
+itertools = { version = ">=0.10,<0.13", default-features = false }
 lazy_static = "1"
 lazycell = "1"
 log = { version = "0.4", optional = true }
-peeking_take_while = "0.1.2"
 prettyplease = { version = "0.2.7", optional = true, features = ["verbatim"] }
 proc-macro2 = { version = "1", default-features = false }
 quote = { version = "1", default-features = false }
-regex = { version = "1.5", default-features = false, features = ["std", "unicode"] }
+regex = { version = "1.5.1", default-features = false, features = ["std", "unicode-perl"] }
 rustc-hash = "1.0.1"
 shlex = "1"
 syn = { version = "2.0", features = ["full", "extra-traits", "visit-mut"] }
@@ -53,12 +53,12 @@ experimental = ["dep:annotate-snippets"]
 
 ## The following features are for internal use and they shouldn't be used if
 ## you're not hacking on bindgen
-# Features used by `bindgen-cli` 
+# Features used by `bindgen-cli`
 __cli = []
-# Features used for CI testing 
+# Features used for CI testing
 __testing_only_extra_assertions = []
 __testing_only_libclang_9 = []
-__testing_only_libclang_5 = []
+__testing_only_libclang_16 = []
 
 [package.metadata.docs.rs]
 features = ["experimental"]
diff --git a/METADATA b/METADATA
index cca20de..9144a8a 100644
--- a/METADATA
+++ b/METADATA
@@ -1,23 +1,20 @@
 # This project was upgraded with external_updater.
-# Usage: tools/external_updater/updater.sh update rust/crates/bindgen
+# Usage: tools/external_updater/updater.sh update external/rust/crates/bindgen
 # For more info, check https://cs.android.com/android/platform/superproject/+/main:tools/external_updater/README.md
 
 name: "bindgen"
 description: "Automatically generates Rust FFI bindings to C and C++ libraries."
 third_party {
-  url {
-    type: HOMEPAGE
-    value: "https://crates.io/crates/bindgen"
-  }
-  url {
-    type: ARCHIVE
-    value: "https://static.crates.io/crates/bindgen/bindgen-0.69.1.crate"
-  }
-  version: "0.69.1"
   license_type: NOTICE
   last_upgrade_date {
-    year: 2023
-    month: 11
-    day: 20
+    year: 2024
+    month: 6
+    day: 17
+  }
+  homepage: "https://crates.io/crates/bindgen"
+  identifier {
+    type: "Archive"
+    value: "https://static.crates.io/crates/bindgen/bindgen-0.69.4.crate"
+    version: "0.69.4"
   }
 }
diff --git a/android/bindgen_cmd/Android.bp b/android/bindgen_cmd/Android.bp
index 689e7ae..9189742 100644
--- a/android/bindgen_cmd/Android.bp
+++ b/android/bindgen_cmd/Android.bp
@@ -9,6 +9,7 @@ package {
 
 rust_library_host {
     name: "libbindgen_cmd",
+    host_cross_supported: false,
     crate_name: "bindgen_cmd",
     srcs: ["src/lib.rs"],
     edition: "2018",
diff --git a/clang.rs b/clang.rs
index 3438bfa..4a4ed89 100644
--- a/clang.rs
+++ b/clang.rs
@@ -2297,6 +2297,15 @@ impl Drop for EvalResult {
         unsafe { clang_EvalResult_dispose(self.x) };
     }
 }
+/// ABI kinds as defined in
+/// <https://github.com/llvm/llvm-project/blob/ddf1de20a3f7db3bca1ef6ba7e6cbb90aac5fd2d/clang/include/clang/Basic/TargetCXXABI.def>
+#[derive(Debug, Eq, PartialEq, Copy, Clone)]
+pub(crate) enum ABIKind {
+    /// All the regular targets like Linux, Mac, WASM, etc. implement the Itanium ABI
+    GenericItanium,
+    /// The ABI used when compiling for the MSVC target
+    Microsoft,
+}
 
 /// Target information obtained from libclang.
 #[derive(Debug)]
@@ -2305,6 +2314,8 @@ pub(crate) struct TargetInfo {
     pub(crate) triple: String,
     /// The width of the pointer _in bits_.
     pub(crate) pointer_width: usize,
+    /// The ABI of the target
+    pub(crate) abi: ABIKind,
 }
 
 impl TargetInfo {
@@ -2320,9 +2331,17 @@ impl TargetInfo {
         }
         assert!(pointer_width > 0);
         assert_eq!(pointer_width % 8, 0);
+
+        let abi = if triple.contains("msvc") {
+            ABIKind::Microsoft
+        } else {
+            ABIKind::GenericItanium
+        };
+
         TargetInfo {
             triple,
             pointer_width: pointer_width as usize,
+            abi,
         }
     }
 }
diff --git a/codegen/helpers.rs b/codegen/helpers.rs
index 7ef44fe..48bfe56 100644
--- a/codegen/helpers.rs
+++ b/codegen/helpers.rs
@@ -232,6 +232,15 @@ pub(crate) mod ast_ty {
         //
         // Also, maybe this one shouldn't be the default?
         match (fk, ctx.options().convert_floats) {
+            (FloatKind::Float16, _) => {
+                // TODO: do f16 when rust lands it
+                ctx.generated_bindgen_float16();
+                if ctx.options().enable_cxx_namespaces {
+                    syn::parse_quote! { root::__BindgenFloat16 }
+                } else {
+                    syn::parse_quote! { __BindgenFloat16 }
+                }
+            }
             (FloatKind::Float, true) => syn::parse_quote! { f32 },
             (FloatKind::Double, true) => syn::parse_quote! { f64 },
             (FloatKind::Float, false) => raw_type(ctx, "c_float"),
diff --git a/codegen/mod.rs b/codegen/mod.rs
index 8e13606..dd1486d 100644
--- a/codegen/mod.rs
+++ b/codegen/mod.rs
@@ -578,6 +578,9 @@ impl CodeGenerator for Module {
                 if result.saw_incomplete_array {
                     utils::prepend_incomplete_array_types(ctx, &mut *result);
                 }
+                if ctx.need_bindgen_float16_type() {
+                    utils::prepend_float16_type(&mut *result);
+                }
                 if ctx.need_bindgen_complex_type() {
                     utils::prepend_complex_type(&mut *result);
                 }
@@ -1974,6 +1977,7 @@ impl CodeGenerator for CompInfo {
             ty,
             &canonical_name,
             visibility,
+            packed,
         );
 
         if !is_opaque {
@@ -2193,7 +2197,14 @@ impl CodeGenerator for CompInfo {
         if let Some(comment) = item.comment(ctx) {
             attributes.push(attributes::doc(comment));
         }
-        if packed && !is_opaque {
+
+        // if a type has both a "packed" attribute and an "align(N)" attribute, then check if the
+        // "packed" attr is redundant, and do not include it if so.
+        if packed &&
+            !is_opaque &&
+            !(explicit_align.is_some() &&
+                self.already_packed(ctx).unwrap_or(false))
+        {
             let n = layout.map_or(1, |l| l.align);
             assert!(ctx.options().rust_features().repr_packed_n || n == 1);
             let packed_repr = if n == 1 {
@@ -5136,6 +5147,20 @@ pub(crate) mod utils {
         result.extend(old_items);
     }
 
+    pub(crate) fn prepend_float16_type(
+        result: &mut Vec<proc_macro2::TokenStream>,
+    ) {
+        let float16_type = quote! {
+            #[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
+            #[repr(transparent)]
+            pub struct __BindgenFloat16(pub u16);
+        };
+
+        let items = vec![float16_type];
+        let old_items = mem::replace(result, items);
+        result.extend(old_items);
+    }
+
     pub(crate) fn prepend_complex_type(
         result: &mut Vec<proc_macro2::TokenStream>,
     ) {
diff --git a/codegen/serialize.rs b/codegen/serialize.rs
index 02c4680..9765a8b 100644
--- a/codegen/serialize.rs
+++ b/codegen/serialize.rs
@@ -270,6 +270,7 @@ impl<'a> CSerialize<'a> for Type {
                     write!(writer, "const ")?;
                 }
                 match float_kind {
+                    FloatKind::Float16 => write!(writer, "_Float16")?,
                     FloatKind::Float => write!(writer, "float")?,
                     FloatKind::Double => write!(writer, "double")?,
                     FloatKind::LongDouble => write!(writer, "long double")?,
@@ -281,6 +282,7 @@ impl<'a> CSerialize<'a> for Type {
                     write!(writer, "const ")?;
                 }
                 match float_kind {
+                    FloatKind::Float16 => write!(writer, "_Float16 complex")?,
                     FloatKind::Float => write!(writer, "float complex")?,
                     FloatKind::Double => write!(writer, "double complex")?,
                     FloatKind::LongDouble => {
diff --git a/codegen/struct_layout.rs b/codegen/struct_layout.rs
index 5673060..f4596a1 100644
--- a/codegen/struct_layout.rs
+++ b/codegen/struct_layout.rs
@@ -91,9 +91,9 @@ impl<'a> StructLayoutTracker<'a> {
         ty: &'a Type,
         name: &'a str,
         visibility: FieldVisibilityKind,
+        is_packed: bool,
     ) -> Self {
         let known_type_layout = ty.layout(ctx);
-        let is_packed = comp.is_packed(ctx, known_type_layout.as_ref());
         let (is_rust_union, can_copy_union_fields) =
             comp.is_rust_union(ctx, known_type_layout.as_ref(), name);
         StructLayoutTracker {
@@ -156,9 +156,7 @@ impl<'a> StructLayoutTracker<'a> {
 
         self.latest_field_layout = Some(layout);
         self.last_field_was_bitfield = true;
-        // NB: We intentionally don't update the max_field_align here, since our
-        // bitfields code doesn't necessarily guarantee it, so we need to
-        // actually generate the dummy alignment.
+        self.max_field_align = cmp::max(self.max_field_align, layout.align);
     }
 
     /// Returns a padding field if necessary for a given new field _before_
@@ -214,7 +212,10 @@ impl<'a> StructLayoutTracker<'a> {
                     0
                 } else if !self.is_packed {
                     self.padding_bytes(field_layout)
-                } else if let Some(l) = self.known_type_layout {
+                } else if let Some(mut l) = self.known_type_layout {
+                    if field_layout.align < l.align {
+                        l.align = field_layout.align;
+                    }
                     self.padding_bytes(l)
                 } else {
                     0
diff --git a/features.rs b/features.rs
index 67c6fb4..e5e2068 100644
--- a/features.rs
+++ b/features.rs
@@ -95,9 +95,9 @@ macro_rules! define_rust_targets {
 // not stable.
 define_rust_targets! {
     Nightly => {
-        thiscall_abi: #42202,
         vectorcall_abi,
     },
+    Stable_1_73(73) => { thiscall_abi: #42202 },
     Stable_1_71(71) => { c_unwind_abi: #106075 },
     Stable_1_68(68) => { abi_efiapi: #105795 },
     Stable_1_64(64) => { core_ffi_c: #94503 },
diff --git a/ir/comp.rs b/ir/comp.rs
index 89e77e1..fed6ba8 100644
--- a/ir/comp.rs
+++ b/ir/comp.rs
@@ -1,5 +1,7 @@
 //! Compound types (unions and structs) in our intermediate representation.
 
+use itertools::Itertools;
+
 use super::analysis::Sizedness;
 use super::annotations::Annotations;
 use super::context::{BindgenContext, FunctionId, ItemId, TypeId, VarId};
@@ -15,7 +17,6 @@ use crate::ir::derive::CanDeriveCopy;
 use crate::parse::ParseError;
 use crate::HashMap;
 use crate::NonCopyUnionStyle;
-use peeking_take_while::PeekableExt;
 use std::cmp;
 use std::io;
 use std::mem;
@@ -1641,6 +1642,26 @@ impl CompInfo {
         false
     }
 
+    /// Return true if a compound type is "naturally packed". This means we can exclude the
+    /// "packed" attribute without changing the layout.
+    /// This is useful for types that need an "align(N)" attribute since rustc won't compile
+    /// structs that have both of those attributes.
+    pub(crate) fn already_packed(&self, ctx: &BindgenContext) -> Option<bool> {
+        let mut total_size: usize = 0;
+
+        for field in self.fields().iter() {
+            let layout = field.layout(ctx)?;
+
+            if layout.align != 0 && total_size % layout.align != 0 {
+                return Some(false);
+            }
+
+            total_size += layout.size;
+        }
+
+        Some(true)
+    }
+
     /// Returns true if compound type has been forward declared
     pub(crate) fn is_forward_declaration(&self) -> bool {
         self.is_forward_declaration
diff --git a/ir/context.rs b/ir/context.rs
index c5e2832..517d336 100644
--- a/ir/context.rs
+++ b/ir/context.rs
@@ -19,7 +19,7 @@ use super::module::{Module, ModuleKind};
 use super::template::{TemplateInstantiation, TemplateParameters};
 use super::traversal::{self, Edge, ItemTraversal};
 use super::ty::{FloatKind, Type, TypeKind};
-use crate::clang::{self, Cursor};
+use crate::clang::{self, ABIKind, Cursor};
 use crate::codegen::CodegenError;
 use crate::BindgenOptions;
 use crate::{Entry, HashMap, HashSet};
@@ -386,6 +386,9 @@ pub(crate) struct BindgenContext {
     /// Whether a bindgen complex was generated
     generated_bindgen_complex: Cell<bool>,
 
+    /// Whether a bindgen float16 was generated
+    generated_bindgen_float16: Cell<bool>,
+
     /// The set of `ItemId`s that are allowlisted. This the very first thing
     /// computed after parsing our IR, and before running any of our analyses.
     allowlisted: Option<ItemSet>,
@@ -585,6 +588,7 @@ If you encounter an error missing from this list, please file an issue or a PR!"
             target_info,
             options,
             generated_bindgen_complex: Cell::new(false),
+            generated_bindgen_float16: Cell::new(false),
             allowlisted: None,
             blocklisted_types_implement_traits: Default::default(),
             codegen_items: None,
@@ -622,6 +626,11 @@ If you encounter an error missing from this list, please file an issue or a PR!"
         self.target_info.pointer_width / 8
     }
 
+    /// Returns the ABI, which is mostly useful for determining the mangling kind.
+    pub(crate) fn abi_kind(&self) -> ABIKind {
+        self.target_info.abi
+    }
+
     /// Get the stack of partially parsed types that we are in the middle of
     /// parsing.
     pub(crate) fn currently_parsed_types(&self) -> &[PartialType] {
@@ -2005,6 +2014,7 @@ If you encounter an error missing from this list, please file an issue or a PR!"
             CXType_ULongLong => TypeKind::Int(IntKind::ULongLong),
             CXType_Int128 => TypeKind::Int(IntKind::I128),
             CXType_UInt128 => TypeKind::Int(IntKind::U128),
+            CXType_Float16 | CXType_Half => TypeKind::Float(FloatKind::Float16),
             CXType_Float => TypeKind::Float(FloatKind::Float),
             CXType_Double => TypeKind::Float(FloatKind::Double),
             CXType_LongDouble => TypeKind::Float(FloatKind::LongDouble),
@@ -2013,6 +2023,7 @@ If you encounter an error missing from this list, please file an issue or a PR!"
                 let float_type =
                     ty.elem_type().expect("Not able to resolve complex type?");
                 let float_kind = match float_type.kind() {
+                    CXType_Float16 | CXType_Half => FloatKind::Float16,
                     CXType_Float => FloatKind::Float,
                     CXType_Double => FloatKind::Double,
                     CXType_LongDouble => FloatKind::LongDouble,
@@ -2528,6 +2539,16 @@ If you encounter an error missing from this list, please file an issue or a PR!"
         self.generated_bindgen_complex.get()
     }
 
+    /// Call if a bindgen float16 is generated
+    pub(crate) fn generated_bindgen_float16(&self) {
+        self.generated_bindgen_float16.set(true)
+    }
+
+    /// Whether we need to generate the bindgen float16 type
+    pub(crate) fn need_bindgen_float16_type(&self) -> bool {
+        self.generated_bindgen_float16.get()
+    }
+
     /// Compute which `enum`s have an associated `typedef` definition.
     fn compute_enum_typedef_combos(&mut self) {
         let _t = self.timer("compute_enum_typedef_combos");
diff --git a/ir/function.rs b/ir/function.rs
index 5bfb70e..448bcd2 100644
--- a/ir/function.rs
+++ b/ir/function.rs
@@ -7,7 +7,7 @@ use super::item::Item;
 use super::traversal::{EdgeKind, Trace, Tracer};
 use super::ty::TypeKind;
 use crate::callbacks::{ItemInfo, ItemKind};
-use crate::clang::{self, Attribute};
+use crate::clang::{self, ABIKind, Attribute};
 use crate::parse::{ClangSubItemParser, ParseError, ParseResult};
 use clang_sys::{self, CXCallingConv};
 
@@ -303,6 +303,7 @@ fn get_abi(cc: CXCallingConv) -> ClangAbi {
         CXCallingConv_X86VectorCall => ClangAbi::Known(Abi::Vectorcall),
         CXCallingConv_AAPCS => ClangAbi::Known(Abi::Aapcs),
         CXCallingConv_X86_64Win64 => ClangAbi::Known(Abi::Win64),
+        CXCallingConv_AArch64VectorCall => ClangAbi::Known(Abi::Vectorcall),
         other => ClangAbi::Unknown(other),
     }
 }
@@ -323,11 +324,12 @@ pub(crate) fn cursor_mangling(
         return None;
     }
 
+    let is_itanium_abi = ctx.abi_kind() == ABIKind::GenericItanium;
     let is_destructor = cursor.kind() == clang_sys::CXCursor_Destructor;
     if let Ok(mut manglings) = cursor.cxx_manglings() {
         while let Some(m) = manglings.pop() {
             // Only generate the destructor group 1, see below.
-            if is_destructor && !m.ends_with("D1Ev") {
+            if is_itanium_abi && is_destructor && !m.ends_with("D1Ev") {
                 continue;
             }
 
@@ -340,7 +342,7 @@ pub(crate) fn cursor_mangling(
         return None;
     }
 
-    if is_destructor {
+    if is_itanium_abi && is_destructor {
         // With old (3.8-) libclang versions, and the Itanium ABI, clang returns
         // the "destructor group 0" symbol, which means that it'll try to free
         // memory, which definitely isn't what we want.
@@ -503,10 +505,24 @@ impl FunctionSig {
                 Default::default()
             };
 
-        // This looks easy to break but the clang parser keeps the type spelling clean even if
-        // other attributes are added.
-        is_divergent =
-            is_divergent || ty.spelling().contains("__attribute__((noreturn))");
+        // Check if the type contains __attribute__((noreturn)) outside of parentheses. This is
+        // somewhat fragile, but it seems to be the only way to get at this information as of
+        // libclang 9.
+        let ty_spelling = ty.spelling();
+        let has_attribute_noreturn = ty_spelling
+            .match_indices("__attribute__((noreturn))")
+            .any(|(i, _)| {
+                let depth = ty_spelling[..i]
+                    .bytes()
+                    .filter_map(|ch| match ch {
+                        b'(' => Some(1),
+                        b')' => Some(-1),
+                        _ => None,
+                    })
+                    .sum::<isize>();
+                depth == 0
+            });
+        is_divergent = is_divergent || has_attribute_noreturn;
 
         let is_method = kind == CXCursor_CXXMethod;
         let is_constructor = kind == CXCursor_Constructor;
diff --git a/ir/item.rs b/ir/item.rs
index 0556452..2941eb8 100644
--- a/ir/item.rs
+++ b/ir/item.rs
@@ -668,8 +668,11 @@ impl Item {
                 ItemKind::Function(..) => {
                     ctx.options().blocklisted_functions.matches(&name)
                 }
-                // TODO: Add constant / namespace blocklisting?
-                ItemKind::Var(..) | ItemKind::Module(..) => false,
+                ItemKind::Var(..) => {
+                    ctx.options().blocklisted_vars.matches(&name)
+                }
+                // TODO: Add namespace blocklisting?
+                ItemKind::Module(..) => false,
             }
     }
 
@@ -1432,57 +1435,58 @@ impl Item {
             }
         }
 
-        // Guess how does clang treat extern "C" blocks?
-        if cursor.kind() == CXCursor_UnexposedDecl {
-            Err(ParseError::Recurse)
-        } else {
+        match cursor.kind() {
+            // On Clang 18+, extern "C" is reported accurately as a LinkageSpec.
+            // Older LLVM treat it as UnexposedDecl.
+            CXCursor_LinkageSpec | CXCursor_UnexposedDecl => {
+                Err(ParseError::Recurse)
+            }
+
             // We allowlist cursors here known to be unhandled, to prevent being
             // too noisy about this.
-            match cursor.kind() {
-                CXCursor_MacroDefinition |
-                CXCursor_MacroExpansion |
-                CXCursor_UsingDeclaration |
-                CXCursor_UsingDirective |
-                CXCursor_StaticAssert |
-                CXCursor_FunctionTemplate => {
-                    debug!(
-                        "Unhandled cursor kind {:?}: {:?}",
-                        cursor.kind(),
-                        cursor
-                    );
-                }
-                CXCursor_InclusionDirective => {
-                    let file = cursor.get_included_file_name();
-                    match file {
-                        None => {
-                            warn!(
-                                "Inclusion of a nameless file in {:?}",
-                                cursor
-                            );
-                        }
-                        Some(included_file) => {
-                            for cb in &ctx.options().parse_callbacks {
-                                cb.include_file(&included_file);
-                            }
+            CXCursor_MacroDefinition |
+            CXCursor_MacroExpansion |
+            CXCursor_UsingDeclaration |
+            CXCursor_UsingDirective |
+            CXCursor_StaticAssert |
+            CXCursor_FunctionTemplate => {
+                debug!(
+                    "Unhandled cursor kind {:?}: {:?}",
+                    cursor.kind(),
+                    cursor
+                );
+                Err(ParseError::Continue)
+            }
 
-                            ctx.add_dep(included_file.into_boxed_str());
-                        }
+            CXCursor_InclusionDirective => {
+                let file = cursor.get_included_file_name();
+                match file {
+                    None => {
+                        warn!("Inclusion of a nameless file in {:?}", cursor);
                     }
-                }
-                _ => {
-                    // ignore toplevel operator overloads
-                    let spelling = cursor.spelling();
-                    if !spelling.starts_with("operator") {
-                        warn!(
-                            "Unhandled cursor kind {:?}: {:?}",
-                            cursor.kind(),
-                            cursor
-                        );
+                    Some(included_file) => {
+                        for cb in &ctx.options().parse_callbacks {
+                            cb.include_file(&included_file);
+                        }
+
+                        ctx.add_dep(included_file.into_boxed_str());
                     }
                 }
+                Err(ParseError::Continue)
             }
 
-            Err(ParseError::Continue)
+            _ => {
+                // ignore toplevel operator overloads
+                let spelling = cursor.spelling();
+                if !spelling.starts_with("operator") {
+                    warn!(
+                        "Unhandled cursor kind {:?}: {:?}",
+                        cursor.kind(),
+                        cursor
+                    );
+                }
+                Err(ParseError::Continue)
+            }
         }
     }
 
diff --git a/ir/ty.rs b/ir/ty.rs
index 1aee065..b7a4293 100644
--- a/ir/ty.rs
+++ b/ir/ty.rs
@@ -558,6 +558,8 @@ impl TemplateParameters for TypeKind {
 /// The kind of float this type represents.
 #[derive(Debug, Copy, Clone, PartialEq, Eq)]
 pub(crate) enum FloatKind {
+    /// A half (`_Float16` or `__fp16`)
+    Float16,
     /// A `float`.
     Float,
     /// A `double`.
diff --git a/lib.rs b/lib.rs
index eeb8649..4720bac 100644
--- a/lib.rs
+++ b/lib.rs
@@ -440,13 +440,14 @@ impl Builder {
 
 impl BindgenOptions {
     fn build(&mut self) {
-        const REGEX_SETS_LEN: usize = 28;
+        const REGEX_SETS_LEN: usize = 29;
 
         let regex_sets: [_; REGEX_SETS_LEN] = [
             &mut self.blocklisted_types,
             &mut self.blocklisted_functions,
             &mut self.blocklisted_items,
             &mut self.blocklisted_files,
+            &mut self.blocklisted_vars,
             &mut self.opaque_types,
             &mut self.allowlisted_vars,
             &mut self.allowlisted_types,
@@ -483,6 +484,7 @@ impl BindgenOptions {
                     "--blocklist-function",
                     "--blocklist-item",
                     "--blocklist-file",
+                    "--blocklist-var",
                     "--opaque-type",
                     "--allowlist-type",
                     "--allowlist-function",
@@ -927,22 +929,24 @@ impl Bindings {
 
     /// Write these bindings as source text to the given `Write`able.
     pub fn write<'a>(&self, mut writer: Box<dyn Write + 'a>) -> io::Result<()> {
+        const NL: &str = if cfg!(windows) { "\r\n" } else { "\n" };
+
         if !self.options.disable_header_comment {
             let version =
-                Some("0.69.1").unwrap_or("(unknown version)");
-            let header = format!(
-                "/* automatically generated by rust-bindgen {version} */\n\n",
-            );
-            writer.write_all(header.as_bytes())?;
+                Some("0.69.4").unwrap_or("(unknown version)");
+            writeln!(
+                writer,
+                "/* automatically generated by rust-bindgen {version} */{NL}",
+            )?;
         }
 
         for line in self.options.raw_lines.iter() {
             writer.write_all(line.as_bytes())?;
-            writer.write_all("\n".as_bytes())?;
+            writer.write_all(NL.as_bytes())?;
         }
 
         if !self.options.raw_lines.is_empty() {
-            writer.write_all("\n".as_bytes())?;
+            writer.write_all(NL.as_bytes())?;
         }
 
         match self.format_tokens(&self.module) {
@@ -1237,7 +1241,7 @@ fn get_target_dependent_env_var(
 /// use bindgen::builder;
 /// let bindings = builder()
 ///     .header("path/to/input/header")
-///     .parse_callbacks(Box::new(bindgen::CargoCallbacks))
+///     .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
 ///     .generate();
 /// ```
 #[derive(Debug)]
diff --git a/options/mod.rs b/options/mod.rs
index 3a82bcf..1fc2241 100644
--- a/options/mod.rs
+++ b/options/mod.rs
@@ -222,6 +222,22 @@ options! {
         },
         as_args: "--blocklist-file",
     },
+    /// Variables that have been blocklisted and should not appear in the generated code.
+    blocklisted_vars: RegexSet {
+        methods: {
+            regex_option! {
+                /// Do not generate any bindings for the given variable.
+                ///
+                /// This option is not recursive, meaning that it will only block variables whose
+                /// names explicitly match the argument of this method.
+                pub fn blocklist_var<T: AsRef<str>>(mut self, arg: T) -> Builder {
+                    self.options.blocklisted_vars.insert(arg);
+                    self
+                }
+            }
+        },
+        as_args: "--blocklist-var",
+    },
     /// Types that should be treated as opaque structures in the generated code.
     opaque_types: RegexSet {
         methods: {
```

