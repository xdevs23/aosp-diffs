```diff
diff --git a/.cargo_vcs_info.json b/.cargo_vcs_info.json
index 6e76df7..7ee50d6 100644
--- a/.cargo_vcs_info.json
+++ b/.cargo_vcs_info.json
@@ -1,6 +1,6 @@
 {
   "git": {
-    "sha1": "0a27d8c95ad4cdf1b04793cc3b19520f2f19c4f4"
+    "sha1": "7ec3d41d39b28190ec1d42db38021107b3951f3a"
   },
   "path_in_vcs": ""
 }
\ No newline at end of file
diff --git a/Android.bp b/Android.bp
index f566a0d..96beb97 100644
--- a/Android.bp
+++ b/Android.bp
@@ -1,133 +1 @@
-// This file is generated by cargo_embargo.
-// Do not modify this file after the first "rust_*" or "genrule" module
-// because the changes will be overridden on upgrade.
-// Content before the first "rust_*" or "genrule" module is preserved.
-
-package {
-    default_applicable_licenses: ["external_rust_crates_num-traits_license"],
-}
-
-// Added automatically by a large-scale-change that took the approach of
-// 'apply every license found to every target'. While this makes sure we respect
-// every license restriction, it may not be entirely correct.
-//
-// e.g. GPL in an MIT project might only apply to the contrib/ directory.
-//
-// Please consider splitting the single license below into multiple licenses,
-// taking care not to lose any license_kind information, and overriding the
-// default license using the 'licenses: [...]' property on targets as needed.
-//
-// For unused files, consider creating a 'fileGroup' with "//visibility:private"
-// to attach the license to, and including a comment whether the files may be
-// used in the current project.
-//
-// large-scale-change included anything that looked like it might be a license
-// text as a license_text. e.g. LICENSE, NOTICE, COPYING etc.
-//
-// Please consider removing redundant or irrelevant files from 'license_text:'.
-// See: http://go/android-license-faq
-license {
-    name: "external_rust_crates_num-traits_license",
-    visibility: [":__subpackages__"],
-    license_kinds: [
-        "SPDX-license-identifier-Apache-2.0",
-        "SPDX-license-identifier-MIT",
-    ],
-    license_text: [
-        "LICENSE-APACHE",
-        "LICENSE-MIT",
-    ],
-}
-
-rust_library {
-    name: "libnum_traits",
-    host_supported: true,
-    crate_name: "num_traits",
-    cargo_env_compat: true,
-    cargo_pkg_version: "0.2.17",
-    crate_root: "src/lib.rs",
-    edition: "2018",
-    features: [
-        "default",
-        "std",
-    ],
-    cfgs: [
-        "has_copysign",
-        "has_div_euclid",
-        "has_float_to_from_bytes",
-        "has_int_to_from_bytes",
-        "has_is_subnormal",
-        "has_leading_trailing_ones",
-        "has_reverse_bits",
-        "has_to_int_unchecked",
-    ],
-    apex_available: [
-        "//apex_available:platform",
-        "com.android.btservices",
-        "com.android.compos",
-        "com.android.uwb",
-        "com.android.virt",
-    ],
-    product_available: true,
-    vendor_available: true,
-    min_sdk_version: "29",
-}
-
-rust_test {
-    name: "num-traits_test_src_lib",
-    host_supported: true,
-    crate_name: "num_traits",
-    cargo_env_compat: true,
-    cargo_pkg_version: "0.2.17",
-    crate_root: "src/lib.rs",
-    test_suites: ["general-tests"],
-    auto_gen_config: true,
-    test_options: {
-        unit_test: true,
-    },
-    edition: "2018",
-    features: [
-        "default",
-        "std",
-    ],
-    cfgs: [
-        "has_copysign",
-        "has_div_euclid",
-        "has_float_to_from_bytes",
-        "has_int_to_from_bytes",
-        "has_is_subnormal",
-        "has_leading_trailing_ones",
-        "has_reverse_bits",
-        "has_to_int_unchecked",
-    ],
-}
-
-rust_test {
-    name: "num-traits_test_tests_cast",
-    host_supported: true,
-    crate_name: "cast",
-    cargo_env_compat: true,
-    cargo_pkg_version: "0.2.17",
-    crate_root: "tests/cast.rs",
-    test_suites: ["general-tests"],
-    auto_gen_config: true,
-    test_options: {
-        unit_test: true,
-    },
-    edition: "2018",
-    features: [
-        "default",
-        "std",
-    ],
-    cfgs: [
-        "has_copysign",
-        "has_div_euclid",
-        "has_float_to_from_bytes",
-        "has_int_to_from_bytes",
-        "has_is_subnormal",
-        "has_leading_trailing_ones",
-        "has_reverse_bits",
-        "has_to_int_unchecked",
-    ],
-    rustlibs: ["libnum_traits"],
-}
+// This crate has been migrated to external/rust/android-crates-io.
diff --git a/Cargo.toml b/Cargo.toml
index ef37eb7..97ceb1b 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -10,14 +10,13 @@
 # See Cargo.toml.orig for the original contents.
 
 [package]
-edition = "2018"
-rust-version = "1.31"
+edition = "2021"
+rust-version = "1.60"
 name = "num-traits"
-version = "0.2.17"
+version = "0.2.19"
 authors = ["The Rust Project Developers"]
 build = "build.rs"
 exclude = [
-    "/bors.toml",
     "/ci/*",
     "/.github/*",
 ]
@@ -51,4 +50,5 @@ version = "1"
 [features]
 default = ["std"]
 i128 = []
+libm = ["dep:libm"]
 std = []
diff --git a/Cargo.toml.orig b/Cargo.toml.orig
index f97bc68..226d416 100644
--- a/Cargo.toml.orig
+++ b/Cargo.toml.orig
@@ -8,12 +8,12 @@ categories = ["algorithms", "science", "no-std"]
 license = "MIT OR Apache-2.0"
 repository = "https://github.com/rust-num/num-traits"
 name = "num-traits"
-version = "0.2.17"
+version = "0.2.19"
 readme = "README.md"
 build = "build.rs"
-exclude = ["/bors.toml", "/ci/*", "/.github/*"]
-edition = "2018"
-rust-version = "1.31"
+exclude = ["/ci/*", "/.github/*"]
+edition = "2021"
+rust-version = "1.60"
 
 [package.metadata.docs.rs]
 features = ["std"]
@@ -24,6 +24,7 @@ libm = { version = "0.2.0", optional = true }
 
 [features]
 default = ["std"]
+libm = ["dep:libm"]
 std = []
 
 # vestigial features, now always in effect
diff --git a/METADATA b/METADATA
index 0625c82..735d36f 100644
--- a/METADATA
+++ b/METADATA
@@ -1,23 +1,20 @@
 # This project was upgraded with external_updater.
-# Usage: tools/external_updater/updater.sh update rust/crates/num-traits
+# Usage: tools/external_updater/updater.sh update external/rust/crates/num-traits
 # For more info, check https://cs.android.com/android/platform/superproject/+/main:tools/external_updater/README.md
 
 name: "num-traits"
 description: "Numeric traits for generic mathematics"
 third_party {
-  url {
-    type: HOMEPAGE
-    value: "https://crates.io/crates/num-traits"
-  }
-  url {
-    type: ARCHIVE
-    value: "https://static.crates.io/crates/num-traits/num-traits-0.2.17.crate"
-  }
-  version: "0.2.17"
   license_type: NOTICE
   last_upgrade_date {
-    year: 2023
-    month: 11
-    day: 14
+    year: 2024
+    month: 7
+    day: 25
+  }
+  homepage: "https://crates.io/crates/num-traits"
+  identifier {
+    type: "Archive"
+    value: "https://static.crates.io/crates/num-traits/num-traits-0.2.19.crate"
+    version: "0.2.19"
   }
 }
diff --git a/README.md b/README.md
index fa2f297..fd42070 100644
--- a/README.md
+++ b/README.md
@@ -2,7 +2,7 @@
 
 [![crate](https://img.shields.io/crates/v/num-traits.svg)](https://crates.io/crates/num-traits)
 [![documentation](https://docs.rs/num-traits/badge.svg)](https://docs.rs/num-traits)
-[![minimum rustc 1.31](https://img.shields.io/badge/rustc-1.31+-red.svg)](https://rust-lang.github.io/rfcs/2495-min-rust-version.html)
+[![minimum rustc 1.60](https://img.shields.io/badge/rustc-1.60+-red.svg)](https://rust-lang.github.io/rfcs/2495-min-rust-version.html)
 [![build status](https://github.com/rust-num/num-traits/workflows/master/badge.svg)](https://github.com/rust-num/num-traits/actions)
 
 Numeric traits for generic mathematics in Rust.
@@ -28,7 +28,7 @@ default-features = false
 # features = ["libm"]    # <--- Uncomment if you wish to use `Float` and `Real` without `std`
 ```
 
-The `Float` and `Real` traits are only available when either `std` or `libm` is enabled.  
+The `Float` and `Real` traits are only available when either `std` or `libm` is enabled.
 
 The `FloatCore` trait is always available.  `MulAdd` and `MulAddAssign` for `f32`
 and `f64` also require `std` or `libm`, as do implementations of signed and floating-
@@ -40,7 +40,7 @@ Release notes are available in [RELEASES.md](RELEASES.md).
 
 ## Compatibility
 
-The `num-traits` crate is tested for rustc 1.31 and greater.
+The `num-traits` crate is tested for rustc 1.60 and greater.
 
 ## License
 
diff --git a/RELEASES.md b/RELEASES.md
index f0c0cf8..5f23f56 100644
--- a/RELEASES.md
+++ b/RELEASES.md
@@ -1,3 +1,27 @@
+# Release 0.2.19 (2024-05-03)
+
+- [Upgrade to 2021 edition, **MSRV 1.60**][310]
+- [The new `Float::clamp` limits values by minimum and maximum][305]
+
+**Contributors**: @cuviper, @michaelciraci
+
+[305]: https://github.com/rust-num/num-traits/pull/305
+[310]: https://github.com/rust-num/num-traits/pull/310
+
+# Release 0.2.18 (2024-02-07)
+
+- [The new `Euclid::div_rem_euclid` and `CheckedEuclid::checked_div_rem_euclid` methods][291]
+  compute and return the quotient and remainder at the same time.
+- [The new `TotalOrder` trait implements the IEEE 754 `totalOrder` predicate.][295]
+- [The new `ConstZero` and `ConstOne` traits offered associated constants][303],
+  extending the non-const `Zero` and `One` traits for types that have constant values.
+
+**Contributors**: @andrewjradcliffe, @cuviper, @tarcieri, @tdelabro, @waywardmonkeys
+
+[291]: https://github.com/rust-num/num-traits/pull/291
+[295]: https://github.com/rust-num/num-traits/pull/295
+[303]: https://github.com/rust-num/num-traits/pull/303
+
 # Release 0.2.17 (2023-10-07)
 
 - [Fix a doc warning about custom classes with newer rustdoc.][286]
diff --git a/TEST_MAPPING b/TEST_MAPPING
deleted file mode 100644
index 54125e0..0000000
--- a/TEST_MAPPING
+++ /dev/null
@@ -1,69 +0,0 @@
-// Generated by update_crate_tests.py for tests that depend on this crate.
-{
-  "imports": [
-    {
-      "path": "external/rust/crates/base64"
-    },
-    {
-      "path": "external/rust/crates/gdbstub_arch"
-    },
-    {
-      "path": "external/rust/crates/num-bigint"
-    },
-    {
-      "path": "external/rust/crates/num-integer"
-    },
-    {
-      "path": "external/rust/crates/oid-registry"
-    },
-    {
-      "path": "external/rust/crates/tinytemplate"
-    },
-    {
-      "path": "external/rust/crates/tinyvec"
-    },
-    {
-      "path": "external/rust/crates/unicode-xid"
-    },
-    {
-      "path": "external/uwb/src"
-    },
-    {
-      "path": "packages/modules/Virtualization/apkdmverity"
-    },
-    {
-      "path": "packages/modules/Virtualization/authfs"
-    },
-    {
-      "path": "packages/modules/Virtualization/avmd"
-    },
-    {
-      "path": "packages/modules/Virtualization/libs/apkverify"
-    },
-    {
-      "path": "packages/modules/Virtualization/microdroid_manager"
-    },
-    {
-      "path": "packages/modules/Virtualization/virtualizationmanager"
-    },
-    {
-      "path": "packages/modules/Virtualization/zipfuse"
-    }
-  ],
-  "presubmit": [
-    {
-      "name": "num-traits_test_src_lib"
-    },
-    {
-      "name": "num-traits_test_tests_cast"
-    }
-  ],
-  "presubmit-rust": [
-    {
-      "name": "num-traits_test_src_lib"
-    },
-    {
-      "name": "num-traits_test_tests_cast"
-    }
-  ]
-}
diff --git a/build.rs b/build.rs
index bb78328..98b06be 100644
--- a/build.rs
+++ b/build.rs
@@ -1,24 +1,7 @@
-use std::env;
-
 fn main() {
     let ac = autocfg::new();
 
-    ac.emit_expression_cfg(
-        "unsafe { 1f64.to_int_unchecked::<i32>() }",
-        "has_to_int_unchecked",
-    );
-
-    ac.emit_expression_cfg("1u32.reverse_bits()", "has_reverse_bits");
-    ac.emit_expression_cfg("1u32.trailing_ones()", "has_leading_trailing_ones");
-    ac.emit_expression_cfg("1u32.div_euclid(1u32)", "has_div_euclid");
-
-    if env::var_os("CARGO_FEATURE_STD").is_some() {
-        ac.emit_expression_cfg("1f64.copysign(-1f64)", "has_copysign");
-    }
-    ac.emit_expression_cfg("1f64.is_subnormal()", "has_is_subnormal");
-
-    ac.emit_expression_cfg("1u32.to_ne_bytes()", "has_int_to_from_bytes");
-    ac.emit_expression_cfg("3.14f64.to_ne_bytes()", "has_float_to_from_bytes");
+    ac.emit_expression_cfg("1f64.total_cmp(&2f64)", "has_total_cmp"); // 1.62
 
     autocfg::rerun_path("build.rs");
 }
diff --git a/cargo_embargo.json b/cargo_embargo.json
deleted file mode 100644
index aa3ec87..0000000
--- a/cargo_embargo.json
+++ /dev/null
@@ -1,20 +0,0 @@
-{
-  "apex_available": [
-    "//apex_available:platform",
-    "com.android.btservices",
-    "com.android.compos",
-    "com.android.uwb",
-    "com.android.virt"
-  ],
-  "min_sdk_version": "29",
-  "tests": true,
-  "variants": [
-    {},
-    {
-        "generate_androidbp": false,
-        "generate_rulesmk": true,
-        "tests": false,
-        "features": []
-    }
-]
-}
diff --git a/rules.mk b/rules.mk
index 53c851c..a39eb25 100644
--- a/rules.mk
+++ b/rules.mk
@@ -8,15 +8,9 @@ MODULE := $(LOCAL_DIR)
 MODULE_CRATE_NAME := num_traits
 MODULE_RUST_CRATE_TYPES := rlib
 MODULE_SRCS := $(LOCAL_DIR)/src/lib.rs
-MODULE_RUST_EDITION := 2018
+MODULE_RUST_EDITION := 2021
 MODULE_RUSTFLAGS += \
-	--cfg 'has_div_euclid' \
-	--cfg 'has_float_to_from_bytes' \
-	--cfg 'has_int_to_from_bytes' \
-	--cfg 'has_is_subnormal' \
-	--cfg 'has_leading_trailing_ones' \
-	--cfg 'has_reverse_bits' \
-	--cfg 'has_to_int_unchecked'
+	--cfg 'has_total_cmp'
 
 MODULE_LIBRARY_DEPS := \
 	
diff --git a/src/cast.rs b/src/cast.rs
index 125e2e3..a3e4dd8 100644
--- a/src/cast.rs
+++ b/src/cast.rs
@@ -277,7 +277,6 @@ macro_rules! impl_to_primitive_float_to_float {
     )*}
 }
 
-#[cfg(has_to_int_unchecked)]
 macro_rules! float_to_int_unchecked {
     // SAFETY: Must not be NaN or infinite; must be representable as the integer after truncating.
     // We already checked that the float is in the exclusive range `(MIN-1, MAX+1)`.
@@ -286,13 +285,6 @@ macro_rules! float_to_int_unchecked {
     };
 }
 
-#[cfg(not(has_to_int_unchecked))]
-macro_rules! float_to_int_unchecked {
-    ($float:expr => $int:ty) => {
-        $float as $int
-    };
-}
-
 macro_rules! impl_to_primitive_float_to_signed_int {
     ($f:ident : $( $(#[$cfg:meta])* fn $method:ident -> $i:ident ; )*) => {$(
         #[inline]
diff --git a/src/float.rs b/src/float.rs
index 87f8387..d0d21a5 100644
--- a/src/float.rs
+++ b/src/float.rs
@@ -1,3 +1,4 @@
+use core::cmp::Ordering;
 use core::num::FpCategory;
 use core::ops::{Add, Div, Neg};
 
@@ -651,6 +652,36 @@ pub trait FloatCore: Num + NumCast + Neg<Output = Self> + PartialOrd + Copy {
         }
     }
 
+    /// A value bounded by a minimum and a maximum
+    ///
+    ///  If input is less than min then this returns min.
+    ///  If input is greater than max then this returns max.
+    ///  Otherwise this returns input.
+    ///
+    /// **Panics** in debug mode if `!(min <= max)`.
+    ///
+    /// # Examples
+    ///
+    /// ```
+    /// use num_traits::float::FloatCore;
+    ///
+    /// fn check<T: FloatCore>(val: T, min: T, max: T, expected: T) {
+    ///     assert!(val.clamp(min, max) == expected);
+    /// }
+    ///
+    ///
+    /// check(1.0f32, 0.0, 2.0, 1.0);
+    /// check(1.0f32, 2.0, 3.0, 2.0);
+    /// check(3.0f32, 0.0, 2.0, 2.0);
+    ///
+    /// check(1.0f64, 0.0, 2.0, 1.0);
+    /// check(1.0f64, 2.0, 3.0, 2.0);
+    /// check(3.0f64, 0.0, 2.0, 2.0);
+    /// ```
+    fn clamp(self, min: Self, max: Self) -> Self {
+        crate::clamp(self, min, max)
+    }
+
     /// Returns the reciprocal (multiplicative inverse) of the number.
     ///
     /// # Examples
@@ -789,6 +820,8 @@ impl FloatCore for f32 {
         Self::is_infinite(self) -> bool;
         Self::is_finite(self) -> bool;
         Self::is_normal(self) -> bool;
+        Self::is_subnormal(self) -> bool;
+        Self::clamp(self, min: Self, max: Self) -> Self;
         Self::classify(self) -> FpCategory;
         Self::is_sign_positive(self) -> bool;
         Self::is_sign_negative(self) -> bool;
@@ -799,11 +832,6 @@ impl FloatCore for f32 {
         Self::to_radians(self) -> Self;
     }
 
-    #[cfg(has_is_subnormal)]
-    forward! {
-        Self::is_subnormal(self) -> bool;
-    }
-
     #[cfg(feature = "std")]
     forward! {
         Self::floor(self) -> Self;
@@ -854,6 +882,8 @@ impl FloatCore for f64 {
         Self::is_infinite(self) -> bool;
         Self::is_finite(self) -> bool;
         Self::is_normal(self) -> bool;
+        Self::is_subnormal(self) -> bool;
+        Self::clamp(self, min: Self, max: Self) -> Self;
         Self::classify(self) -> FpCategory;
         Self::is_sign_positive(self) -> bool;
         Self::is_sign_negative(self) -> bool;
@@ -864,11 +894,6 @@ impl FloatCore for f64 {
         Self::to_radians(self) -> Self;
     }
 
-    #[cfg(has_is_subnormal)]
-    forward! {
-        Self::is_subnormal(self) -> bool;
-    }
-
     #[cfg(feature = "std")]
     forward! {
         Self::floor(self) -> Self;
@@ -1504,6 +1529,23 @@ pub trait Float: Num + Copy + NumCast + PartialOrd + Neg<Output = Self> {
     /// ```
     fn min(self, other: Self) -> Self;
 
+    /// Clamps a value between a min and max.
+    ///
+    /// **Panics** in debug mode if `!(min <= max)`.
+    ///
+    /// ```
+    /// use num_traits::Float;
+    ///
+    /// let x = 1.0;
+    /// let y = 2.0;
+    /// let z = 3.0;
+    ///
+    /// assert_eq!(x.clamp(y, z), 2.0);
+    /// ```
+    fn clamp(self, min: Self, max: Self) -> Self {
+        crate::clamp(self, min, max)
+    }
+
     /// The positive difference of two numbers.
     ///
     /// * If `self <= other`: `0:0`
@@ -1900,7 +1942,9 @@ macro_rules! float_impl_std {
                 Self::is_infinite(self) -> bool;
                 Self::is_finite(self) -> bool;
                 Self::is_normal(self) -> bool;
+                Self::is_subnormal(self) -> bool;
                 Self::classify(self) -> FpCategory;
+                Self::clamp(self, min: Self, max: Self) -> Self;
                 Self::floor(self) -> Self;
                 Self::ceil(self) -> Self;
                 Self::round(self) -> Self;
@@ -1943,17 +1987,8 @@ macro_rules! float_impl_std {
                 Self::asinh(self) -> Self;
                 Self::acosh(self) -> Self;
                 Self::atanh(self) -> Self;
-            }
-
-            #[cfg(has_copysign)]
-            forward! {
                 Self::copysign(self, sign: Self) -> Self;
             }
-
-            #[cfg(has_is_subnormal)]
-            forward! {
-                Self::is_subnormal(self) -> bool;
-            }
         }
     };
 }
@@ -1992,6 +2027,8 @@ macro_rules! float_impl_libm {
             Self::is_infinite(self) -> bool;
             Self::is_finite(self) -> bool;
             Self::is_normal(self) -> bool;
+            Self::is_subnormal(self) -> bool;
+            Self::clamp(self, min: Self, max: Self) -> Self;
             Self::classify(self) -> FpCategory;
             Self::is_sign_positive(self) -> bool;
             Self::is_sign_negative(self) -> bool;
@@ -2002,11 +2039,6 @@ macro_rules! float_impl_libm {
             Self::to_radians(self) -> Self;
         }
 
-        #[cfg(has_is_subnormal)]
-        forward! {
-            Self::is_subnormal(self) -> bool;
-        }
-
         forward! {
             FloatCore::signum(self) -> Self;
             FloatCore::powi(self, n: i32) -> Self;
@@ -2210,6 +2242,89 @@ float_const_impl! {
     SQRT_2,
 }
 
+/// Trait for floating point numbers that provide an implementation
+/// of the `totalOrder` predicate as defined in the IEEE 754 (2008 revision)
+/// floating point standard.
+pub trait TotalOrder {
+    /// Return the ordering between `self` and `other`.
+    ///
+    /// Unlike the standard partial comparison between floating point numbers,
+    /// this comparison always produces an ordering in accordance to
+    /// the `totalOrder` predicate as defined in the IEEE 754 (2008 revision)
+    /// floating point standard. The values are ordered in the following sequence:
+    ///
+    /// - negative quiet NaN
+    /// - negative signaling NaN
+    /// - negative infinity
+    /// - negative numbers
+    /// - negative subnormal numbers
+    /// - negative zero
+    /// - positive zero
+    /// - positive subnormal numbers
+    /// - positive numbers
+    /// - positive infinity
+    /// - positive signaling NaN
+    /// - positive quiet NaN.
+    ///
+    /// The ordering established by this function does not always agree with the
+    /// [`PartialOrd`] and [`PartialEq`] implementations. For example,
+    /// they consider negative and positive zero equal, while `total_cmp`
+    /// doesn't.
+    ///
+    /// The interpretation of the signaling NaN bit follows the definition in
+    /// the IEEE 754 standard, which may not match the interpretation by some of
+    /// the older, non-conformant (e.g. MIPS) hardware implementations.
+    ///
+    /// # Examples
+    /// ```
+    /// use num_traits::float::TotalOrder;
+    /// use std::cmp::Ordering;
+    /// use std::{f32, f64};
+    ///
+    /// fn check_eq<T: TotalOrder>(x: T, y: T) {
+    ///     assert_eq!(x.total_cmp(&y), Ordering::Equal);
+    /// }
+    ///
+    /// check_eq(f64::NAN, f64::NAN);
+    /// check_eq(f32::NAN, f32::NAN);
+    ///
+    /// fn check_lt<T: TotalOrder>(x: T, y: T) {
+    ///     assert_eq!(x.total_cmp(&y), Ordering::Less);
+    /// }
+    ///
+    /// check_lt(-f64::NAN, f64::NAN);
+    /// check_lt(f64::INFINITY, f64::NAN);
+    /// check_lt(-0.0_f64, 0.0_f64);
+    /// ```
+    fn total_cmp(&self, other: &Self) -> Ordering;
+}
+macro_rules! totalorder_impl {
+    ($T:ident, $I:ident, $U:ident, $bits:expr) => {
+        impl TotalOrder for $T {
+            #[inline]
+            #[cfg(has_total_cmp)]
+            fn total_cmp(&self, other: &Self) -> Ordering {
+                // Forward to the core implementation
+                Self::total_cmp(&self, other)
+            }
+            #[inline]
+            #[cfg(not(has_total_cmp))]
+            fn total_cmp(&self, other: &Self) -> Ordering {
+                // Backport the core implementation (since 1.62)
+                let mut left = self.to_bits() as $I;
+                let mut right = other.to_bits() as $I;
+
+                left ^= (((left >> ($bits - 1)) as $U) >> 1) as $I;
+                right ^= (((right >> ($bits - 1)) as $U) >> 1) as $I;
+
+                left.cmp(&right)
+            }
+        }
+    };
+}
+totalorder_impl!(f64, i64, u64, 64);
+totalorder_impl!(f32, i32, u32, 32);
+
 #[cfg(test)]
 mod tests {
     use core::f64::consts;
@@ -2341,4 +2456,58 @@ mod tests {
         test_subnormal::<f64>();
         test_subnormal::<f32>();
     }
+
+    #[test]
+    fn total_cmp() {
+        use crate::float::TotalOrder;
+        use core::cmp::Ordering;
+        use core::{f32, f64};
+
+        fn check_eq<T: TotalOrder>(x: T, y: T) {
+            assert_eq!(x.total_cmp(&y), Ordering::Equal);
+        }
+        fn check_lt<T: TotalOrder>(x: T, y: T) {
+            assert_eq!(x.total_cmp(&y), Ordering::Less);
+        }
+        fn check_gt<T: TotalOrder>(x: T, y: T) {
+            assert_eq!(x.total_cmp(&y), Ordering::Greater);
+        }
+
+        check_eq(f64::NAN, f64::NAN);
+        check_eq(f32::NAN, f32::NAN);
+
+        check_lt(-0.0_f64, 0.0_f64);
+        check_lt(-0.0_f32, 0.0_f32);
+
+        // x87 registers don't preserve the exact value of signaling NaN:
+        // https://github.com/rust-lang/rust/issues/115567
+        #[cfg(not(target_arch = "x86"))]
+        {
+            let s_nan = f64::from_bits(0x7ff4000000000000);
+            let q_nan = f64::from_bits(0x7ff8000000000000);
+            check_lt(s_nan, q_nan);
+
+            let neg_s_nan = f64::from_bits(0xfff4000000000000);
+            let neg_q_nan = f64::from_bits(0xfff8000000000000);
+            check_lt(neg_q_nan, neg_s_nan);
+
+            let s_nan = f32::from_bits(0x7fa00000);
+            let q_nan = f32::from_bits(0x7fc00000);
+            check_lt(s_nan, q_nan);
+
+            let neg_s_nan = f32::from_bits(0xffa00000);
+            let neg_q_nan = f32::from_bits(0xffc00000);
+            check_lt(neg_q_nan, neg_s_nan);
+        }
+
+        check_lt(-f64::NAN, f64::NEG_INFINITY);
+        check_gt(1.0_f64, -f64::NAN);
+        check_lt(f64::INFINITY, f64::NAN);
+        check_gt(f64::NAN, 1.0_f64);
+
+        check_lt(-f32::NAN, f32::NEG_INFINITY);
+        check_gt(1.0_f32, -f32::NAN);
+        check_lt(f32::INFINITY, f32::NAN);
+        check_gt(f32::NAN, 1.0_f32);
+    }
 }
diff --git a/src/identities.rs b/src/identities.rs
index 2486cb1..c30cd1d 100644
--- a/src/identities.rs
+++ b/src/identities.rs
@@ -28,6 +28,13 @@ pub trait Zero: Sized + Add<Self, Output = Self> {
     fn is_zero(&self) -> bool;
 }
 
+/// Defines an associated constant representing the additive identity element
+/// for `Self`.
+pub trait ConstZero: Zero {
+    /// The additive identity element of `Self`, `0`.
+    const ZERO: Self;
+}
+
 macro_rules! zero_impl {
     ($t:ty, $v:expr) => {
         impl Zero for $t {
@@ -40,6 +47,10 @@ macro_rules! zero_impl {
                 *self == $v
             }
         }
+
+        impl ConstZero for $t {
+            const ZERO: Self = $v;
+        }
     };
 }
 
@@ -77,6 +88,13 @@ where
     }
 }
 
+impl<T: ConstZero> ConstZero for Wrapping<T>
+where
+    Wrapping<T>: Add<Output = Wrapping<T>>,
+{
+    const ZERO: Self = Wrapping(T::ZERO);
+}
+
 /// Defines a multiplicative identity element for `Self`.
 ///
 /// # Laws
@@ -115,6 +133,13 @@ pub trait One: Sized + Mul<Self, Output = Self> {
     }
 }
 
+/// Defines an associated constant representing the multiplicative identity
+/// element for `Self`.
+pub trait ConstOne: One {
+    /// The multiplicative identity element of `Self`, `1`.
+    const ONE: Self;
+}
+
 macro_rules! one_impl {
     ($t:ty, $v:expr) => {
         impl One for $t {
@@ -127,6 +152,10 @@ macro_rules! one_impl {
                 *self == $v
             }
         }
+
+        impl ConstOne for $t {
+            const ONE: Self = $v;
+        }
     };
 }
 
@@ -160,6 +189,13 @@ where
     }
 }
 
+impl<T: ConstOne> ConstOne for Wrapping<T>
+where
+    Wrapping<T>: Mul<Output = Wrapping<T>>,
+{
+    const ONE: Self = Wrapping(T::ONE);
+}
+
 // Some helper functions provided for backwards compatibility.
 
 /// Returns the additive identity, `0`.
diff --git a/src/int.rs b/src/int.rs
index e3ca72c..c6284bf 100644
--- a/src/int.rs
+++ b/src/int.rs
@@ -404,7 +404,6 @@ macro_rules! prim_int_impl {
                 <$T>::count_zeros(self)
             }
 
-            #[cfg(has_leading_trailing_ones)]
             #[inline]
             fn leading_ones(self) -> u32 {
                 <$T>::leading_ones(self)
@@ -415,7 +414,6 @@ macro_rules! prim_int_impl {
                 <$T>::leading_zeros(self)
             }
 
-            #[cfg(has_leading_trailing_ones)]
             #[inline]
             fn trailing_ones(self) -> u32 {
                 <$T>::trailing_ones(self)
@@ -461,7 +459,6 @@ macro_rules! prim_int_impl {
                 <$T>::swap_bytes(self)
             }
 
-            #[cfg(has_reverse_bits)]
             #[inline]
             fn reverse_bits(self) -> Self {
                 <$T>::reverse_bits(self)
diff --git a/src/lib.rs b/src/lib.rs
index 54dab6e..d392e92 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -12,7 +12,7 @@
 //!
 //! ## Compatibility
 //!
-//! The `num-traits` crate is tested for rustc 1.31 and greater.
+//! The `num-traits` crate is tested for rustc 1.60 and greater.
 
 #![doc(html_root_url = "https://docs.rs/num-traits/0.2")]
 #![deny(unconditional_recursion)]
@@ -33,7 +33,7 @@ pub use crate::float::Float;
 pub use crate::float::FloatConst;
 // pub use real::{FloatCore, Real}; // NOTE: Don't do this, it breaks `use num_traits::*;`.
 pub use crate::cast::{cast, AsPrimitive, FromPrimitive, NumCast, ToPrimitive};
-pub use crate::identities::{one, zero, One, Zero};
+pub use crate::identities::{one, zero, ConstOne, ConstZero, One, Zero};
 pub use crate::int::PrimInt;
 pub use crate::ops::bytes::{FromBytes, ToBytes};
 pub use crate::ops::checked::{
diff --git a/src/ops/bytes.rs b/src/ops/bytes.rs
index 4df9ecd..f6a8030 100644
--- a/src/ops/bytes.rs
+++ b/src/ops/bytes.rs
@@ -2,8 +2,6 @@ use core::borrow::{Borrow, BorrowMut};
 use core::cmp::{Eq, Ord, PartialEq, PartialOrd};
 use core::fmt::Debug;
 use core::hash::Hash;
-#[cfg(not(has_int_to_from_bytes))]
-use core::mem::transmute;
 
 pub trait NumBytes:
     Debug
@@ -152,7 +150,6 @@ pub trait FromBytes: Sized {
 
 macro_rules! float_to_from_bytes_impl {
     ($T:ty, $L:expr) => {
-        #[cfg(has_float_to_from_bytes)]
         impl ToBytes for $T {
             type Bytes = [u8; $L];
 
@@ -172,7 +169,6 @@ macro_rules! float_to_from_bytes_impl {
             }
         }
 
-        #[cfg(has_float_to_from_bytes)]
         impl FromBytes for $T {
             type Bytes = [u8; $L];
 
@@ -191,52 +187,11 @@ macro_rules! float_to_from_bytes_impl {
                 <$T>::from_ne_bytes(*bytes)
             }
         }
-
-        #[cfg(not(has_float_to_from_bytes))]
-        impl ToBytes for $T {
-            type Bytes = [u8; $L];
-
-            #[inline]
-            fn to_be_bytes(&self) -> Self::Bytes {
-                ToBytes::to_be_bytes(&self.to_bits())
-            }
-
-            #[inline]
-            fn to_le_bytes(&self) -> Self::Bytes {
-                ToBytes::to_le_bytes(&self.to_bits())
-            }
-
-            #[inline]
-            fn to_ne_bytes(&self) -> Self::Bytes {
-                ToBytes::to_ne_bytes(&self.to_bits())
-            }
-        }
-
-        #[cfg(not(has_float_to_from_bytes))]
-        impl FromBytes for $T {
-            type Bytes = [u8; $L];
-
-            #[inline]
-            fn from_be_bytes(bytes: &Self::Bytes) -> Self {
-                Self::from_bits(FromBytes::from_be_bytes(bytes))
-            }
-
-            #[inline]
-            fn from_le_bytes(bytes: &Self::Bytes) -> Self {
-                Self::from_bits(FromBytes::from_le_bytes(bytes))
-            }
-
-            #[inline]
-            fn from_ne_bytes(bytes: &Self::Bytes) -> Self {
-                Self::from_bits(FromBytes::from_ne_bytes(bytes))
-            }
-        }
     };
 }
 
 macro_rules! int_to_from_bytes_impl {
     ($T:ty, $L:expr) => {
-        #[cfg(has_int_to_from_bytes)]
         impl ToBytes for $T {
             type Bytes = [u8; $L];
 
@@ -256,7 +211,6 @@ macro_rules! int_to_from_bytes_impl {
             }
         }
 
-        #[cfg(has_int_to_from_bytes)]
         impl FromBytes for $T {
             type Bytes = [u8; $L];
 
@@ -275,46 +229,6 @@ macro_rules! int_to_from_bytes_impl {
                 <$T>::from_ne_bytes(*bytes)
             }
         }
-
-        #[cfg(not(has_int_to_from_bytes))]
-        impl ToBytes for $T {
-            type Bytes = [u8; $L];
-
-            #[inline]
-            fn to_be_bytes(&self) -> Self::Bytes {
-                <$T as ToBytes>::to_ne_bytes(&<$T>::to_be(*self))
-            }
-
-            #[inline]
-            fn to_le_bytes(&self) -> Self::Bytes {
-                <$T as ToBytes>::to_ne_bytes(&<$T>::to_le(*self))
-            }
-
-            #[inline]
-            fn to_ne_bytes(&self) -> Self::Bytes {
-                unsafe { transmute(*self) }
-            }
-        }
-
-        #[cfg(not(has_int_to_from_bytes))]
-        impl FromBytes for $T {
-            type Bytes = [u8; $L];
-
-            #[inline]
-            fn from_be_bytes(bytes: &Self::Bytes) -> Self {
-                Self::from_be(<Self as FromBytes>::from_ne_bytes(bytes))
-            }
-
-            #[inline]
-            fn from_le_bytes(bytes: &Self::Bytes) -> Self {
-                Self::from_le(<Self as FromBytes>::from_ne_bytes(bytes))
-            }
-
-            #[inline]
-            fn from_ne_bytes(bytes: &Self::Bytes) -> Self {
-                unsafe { transmute(*bytes) }
-            }
-        }
     };
 }
 
diff --git a/src/ops/euclid.rs b/src/ops/euclid.rs
index 4547fee..fa7b317 100644
--- a/src/ops/euclid.rs
+++ b/src/ops/euclid.rs
@@ -46,11 +46,31 @@ pub trait Euclid: Sized + Div<Self, Output = Self> + Rem<Self, Output = Self> {
     /// assert_eq!(Euclid::rem_euclid(&-a, &-b), 1);
     /// ```
     fn rem_euclid(&self, v: &Self) -> Self;
+
+    /// Returns both the quotient and remainder from Euclidean division.
+    ///
+    /// By default, it internally calls both `Euclid::div_euclid` and `Euclid::rem_euclid`,
+    /// but it can be overridden in order to implement some optimization.
+    ///
+    /// # Examples
+    ///
+    /// ```
+    /// # use num_traits::Euclid;
+    /// let x = 5u8;
+    /// let y = 3u8;
+    ///
+    /// let div = Euclid::div_euclid(&x, &y);
+    /// let rem = Euclid::rem_euclid(&x, &y);
+    ///
+    /// assert_eq!((div, rem), Euclid::div_rem_euclid(&x, &y));
+    /// ```
+    fn div_rem_euclid(&self, v: &Self) -> (Self, Self) {
+        (self.div_euclid(v), self.rem_euclid(v))
+    }
 }
 
 macro_rules! euclid_forward_impl {
     ($($t:ty)*) => {$(
-        #[cfg(has_div_euclid)]
         impl Euclid for $t {
             #[inline]
             fn div_euclid(&self, v: &$t) -> Self {
@@ -65,64 +85,13 @@ macro_rules! euclid_forward_impl {
     )*}
 }
 
-macro_rules! euclid_int_impl {
-    ($($t:ty)*) => {$(
-        euclid_forward_impl!($t);
+euclid_forward_impl!(isize i8 i16 i32 i64 i128);
+euclid_forward_impl!(usize u8 u16 u32 u64 u128);
 
-        #[cfg(not(has_div_euclid))]
-        impl Euclid for $t {
-            #[inline]
-            fn div_euclid(&self, v: &$t) -> Self {
-                let q = self / v;
-                if self % v < 0 {
-                    return if *v > 0 { q - 1 } else { q + 1 }
-                }
-                q
-            }
-
-            #[inline]
-            fn rem_euclid(&self, v: &$t) -> Self {
-                let r = self % v;
-                if r < 0 {
-                    if *v < 0 {
-                        r - v
-                    } else {
-                        r + v
-                    }
-                } else {
-                    r
-                }
-            }
-        }
-    )*}
-}
-
-macro_rules! euclid_uint_impl {
-    ($($t:ty)*) => {$(
-        euclid_forward_impl!($t);
-
-        #[cfg(not(has_div_euclid))]
-        impl Euclid for $t {
-            #[inline]
-            fn div_euclid(&self, v: &$t) -> Self {
-                self / v
-            }
-
-            #[inline]
-            fn rem_euclid(&self, v: &$t) -> Self {
-                self % v
-            }
-        }
-    )*}
-}
-
-euclid_int_impl!(isize i8 i16 i32 i64 i128);
-euclid_uint_impl!(usize u8 u16 u32 u64 u128);
-
-#[cfg(all(has_div_euclid, feature = "std"))]
+#[cfg(feature = "std")]
 euclid_forward_impl!(f32 f64);
 
-#[cfg(not(all(has_div_euclid, feature = "std")))]
+#[cfg(not(feature = "std"))]
 impl Euclid for f32 {
     #[inline]
     fn div_euclid(&self, v: &f32) -> f32 {
@@ -144,7 +113,7 @@ impl Euclid for f32 {
     }
 }
 
-#[cfg(not(all(has_div_euclid, feature = "std")))]
+#[cfg(not(feature = "std"))]
 impl Euclid for f64 {
     #[inline]
     fn div_euclid(&self, v: &f64) -> f64 {
@@ -174,11 +143,30 @@ pub trait CheckedEuclid: Euclid {
     /// Finds the euclid remainder of dividing two numbers, checking for underflow, overflow and
     /// division by zero. If any of that happens, `None` is returned.
     fn checked_rem_euclid(&self, v: &Self) -> Option<Self>;
+
+    /// Returns both the quotient and remainder from checked Euclidean division.
+    ///
+    /// By default, it internally calls both `CheckedEuclid::checked_div_euclid` and `CheckedEuclid::checked_rem_euclid`,
+    /// but it can be overridden in order to implement some optimization.
+    /// # Examples
+    ///
+    /// ```
+    /// # use num_traits::CheckedEuclid;
+    /// let x = 5u8;
+    /// let y = 3u8;
+    ///
+    /// let div = CheckedEuclid::checked_div_euclid(&x, &y);
+    /// let rem = CheckedEuclid::checked_rem_euclid(&x, &y);
+    ///
+    /// assert_eq!(Some((div.unwrap(), rem.unwrap())), CheckedEuclid::checked_div_rem_euclid(&x, &y));
+    /// ```
+    fn checked_div_rem_euclid(&self, v: &Self) -> Option<(Self, Self)> {
+        Some((self.checked_div_euclid(v)?, self.checked_rem_euclid(v)?))
+    }
 }
 
 macro_rules! checked_euclid_forward_impl {
     ($($t:ty)*) => {$(
-        #[cfg(has_div_euclid)]
         impl CheckedEuclid for $t {
             #[inline]
             fn checked_div_euclid(&self, v: &$t) -> Option<Self> {
@@ -193,62 +181,8 @@ macro_rules! checked_euclid_forward_impl {
     )*}
 }
 
-macro_rules! checked_euclid_int_impl {
-    ($($t:ty)*) => {$(
-        checked_euclid_forward_impl!($t);
-
-        #[cfg(not(has_div_euclid))]
-        impl CheckedEuclid for $t {
-            #[inline]
-            fn checked_div_euclid(&self, v: &$t) -> Option<$t> {
-                if *v == 0 || (*self == Self::min_value() && *v == -1) {
-                    None
-                } else {
-                    Some(Euclid::div_euclid(self, v))
-                }
-            }
-
-            #[inline]
-            fn checked_rem_euclid(&self, v: &$t) -> Option<$t> {
-                if *v == 0 || (*self == Self::min_value() && *v == -1) {
-                    None
-                } else {
-                    Some(Euclid::rem_euclid(self, v))
-                }
-            }
-        }
-    )*}
-}
-
-macro_rules! checked_euclid_uint_impl {
-    ($($t:ty)*) => {$(
-        checked_euclid_forward_impl!($t);
-
-        #[cfg(not(has_div_euclid))]
-        impl CheckedEuclid for $t {
-            #[inline]
-            fn checked_div_euclid(&self, v: &$t) -> Option<$t> {
-                if *v == 0 {
-                    None
-                } else {
-                    Some(Euclid::div_euclid(self, v))
-                }
-            }
-
-            #[inline]
-            fn checked_rem_euclid(&self, v: &$t) -> Option<$t> {
-                if *v == 0 {
-                    None
-                } else {
-                    Some(Euclid::rem_euclid(self, v))
-                }
-            }
-        }
-    )*}
-}
-
-checked_euclid_int_impl!(isize i8 i16 i32 i64 i128);
-checked_euclid_uint_impl!(usize u8 u16 u32 u64 u128);
+checked_euclid_forward_impl!(isize i8 i16 i32 i64 i128);
+checked_euclid_forward_impl!(usize u8 u16 u32 u64 u128);
 
 #[cfg(test)]
 mod tests {
@@ -262,8 +196,11 @@ mod tests {
                     {
                         let x: $t = 10;
                         let y: $t = 3;
-                        assert_eq!(Euclid::div_euclid(&x, &y), 3);
-                        assert_eq!(Euclid::rem_euclid(&x, &y), 1);
+                        let div = Euclid::div_euclid(&x, &y);
+                        let rem = Euclid::rem_euclid(&x, &y);
+                        assert_eq!(div, 3);
+                        assert_eq!(rem, 1);
+                        assert_eq!((div, rem), Euclid::div_rem_euclid(&x, &y));
                     }
                 )+
             };
@@ -284,6 +221,7 @@ mod tests {
                         assert_eq!(Euclid::div_euclid(&-x, &y), 4);
                         assert_eq!(Euclid::rem_euclid(&x, &y), 1);
                         assert_eq!(Euclid::rem_euclid(&-x, &y), 2);
+                        assert_eq!((Euclid::div_euclid(&x, &y), Euclid::rem_euclid(&x, &y)), Euclid::div_rem_euclid(&x, &y));
                         let x: $t = $t::min_value() + 1;
                         let y: $t = -1;
                         assert_eq!(Euclid::div_euclid(&x, &y), $t::max_value());
@@ -311,6 +249,7 @@ mod tests {
                         <= 46.4 * <$t as crate::float::FloatCore>::epsilon());
                         assert!(Euclid::div_euclid(&-x, &-y) * -y + Euclid::rem_euclid(&-x, &-y) + x
                         <= 46.4 * <$t as crate::float::FloatCore>::epsilon());
+                        assert_eq!((Euclid::div_euclid(&x, &y), Euclid::rem_euclid(&x, &y)), Euclid::div_rem_euclid(&x, &y));
                     }
                 )+
             };
diff --git a/src/real.rs b/src/real.rs
index d4feee0..25ec873 100644
--- a/src/real.rs
+++ b/src/real.rs
@@ -270,7 +270,7 @@ pub trait Real: Num + Copy + NumCast + PartialOrd + Neg<Output = Self> {
 
     /// Take the square root of a number.
     ///
-    /// Returns NaN if `self` is a negative floating-point number.  
+    /// Returns NaN if `self` is a negative floating-point number.
     ///
     /// # Panics
     ///
```

