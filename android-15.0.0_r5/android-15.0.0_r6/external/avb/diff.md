```diff
diff --git a/avbtool.py b/avbtool.py
index d923b31..7e292f0 100755
--- a/avbtool.py
+++ b/avbtool.py
@@ -4446,9 +4446,14 @@ class AvbTool(object):
     sub_parser.add_argument('--partition_name',
                             help='Partition name',
                             default='')
+    # For backwards compatibility, add_hashtree_footer defaults to sha1, even
+    # though sha1 is not actually allowed to be used in Android. At the earliest
+    # opportunity, the default should be fixed to be sha256. For now we just
+    # print a warning when the algorithm defaults to sha1. Below uses default=''
+    # so that defaulted sha1 can be distinguished from explicit sha1.
     sub_parser.add_argument('--hash_algorithm',
                             help='Hash algorithm to use (default: sha1)',
-                            default='sha1')
+                            default='')
     sub_parser.add_argument('--salt',
                             help='Salt in hex (default: /dev/urandom)')
     sub_parser.add_argument('--block_size',
@@ -4869,6 +4874,16 @@ class AvbTool(object):
       sys.stderr.write('The --generate_fec option is deprecated since FEC '
                        'is now generated by default. Use the option '
                        '--do_not_generate_fec to not generate FEC.\n')
+    if args.hash_algorithm == '':
+      args.hash_algorithm = 'sha1'
+      # In --calc_max_image_size mode don't show the sha1 warning, since sha1
+      # digests get padded to the same size as sha256 anyway.
+      if not args.calc_max_image_size:
+        sys.stderr.write(
+"""Warning: 'avbtool add_hashtree_footer' executed without an explicit
+--hash_algorithm option. Defaulting to sha1 for backwards compatibility.
+Please use '--hash_algorithm sha256'.
+""")
     self.avb.add_hashtree_footer(
         args.image.name if args.image else None,
         args.partition_size,
diff --git a/rust/Android.bp b/rust/Android.bp
index 9188819..ce1c261 100644
--- a/rust/Android.bp
+++ b/rust/Android.bp
@@ -70,6 +70,9 @@ rust_defaults {
         "libcrypto_baremetal",
     ],
     rustlibs: ["libzerocopy_nostd_noalloc"],
+    dylib: {
+        enabled: false,
+    },
 }
 
 // Internal source-only bindgen with std.
diff --git a/rust/src/verify.rs b/rust/src/verify.rs
index b718d63..bea2275 100644
--- a/rust/src/verify.rs
+++ b/rust/src/verify.rs
@@ -109,6 +109,19 @@ impl VbmetaData {
         // `slot_verify()`, so we know we have been properly validated.
         unsafe { get_descriptors(self) }
     }
+
+    /// Gets a property from the vbmeta image for the given key
+    ///
+    /// This function re-implements the libavb avb_property_lookup logic.
+    ///
+    /// # Returns
+    /// Byte array with property data or None in case property not found or failure.
+    pub fn get_property_value(&self, key: &str) -> Option<&[u8]> {
+        self.descriptors().ok()?.iter().find_map(|d| match d {
+            Descriptor::Property(p) if p.key == key => Some(p.value),
+            _ => None,
+        })
+    }
 }
 
 impl fmt::Display for VbmetaData {
diff --git a/rust/tests/verify_tests.rs b/rust/tests/verify_tests.rs
index dfe4ec8..dfe5c62 100644
--- a/rust/tests/verify_tests.rs
+++ b/rust/tests/verify_tests.rs
@@ -794,3 +794,31 @@ fn verify_chain_partition_descriptor() {
         .unwrap()
         .contains(&Descriptor::ChainPartition(expected)));
 }
+
+#[test]
+fn verify_get_property_value() {
+    let mut ops = build_test_ops_one_image_one_vbmeta();
+    ops.add_partition("vbmeta", fs::read(TEST_VBMETA_WITH_PROPERTY_PATH).unwrap());
+
+    let data = verify_one_image_one_vbmeta(&mut ops).unwrap();
+
+    assert_eq!(
+        data.vbmeta_data()[0].get_property_value(TEST_PROPERTY_KEY),
+        Some(TEST_PROPERTY_VALUE),
+        "Expected valid buffer for the given key"
+    );
+}
+
+#[test]
+fn verify_get_property_value_not_found() {
+    let mut ops = build_test_ops_one_image_one_vbmeta();
+    ops.add_partition("vbmeta", fs::read(TEST_VBMETA_WITH_PROPERTY_PATH).unwrap());
+
+    let data = verify_one_image_one_vbmeta(&mut ops).unwrap();
+
+    assert_eq!(
+        data.vbmeta_data()[0].get_property_value("test_prop_doesnt_exist"),
+        None,
+        "Expected property not found for not existing key"
+    );
+}
diff --git a/test/avb_ab_flow_unittest.cc b/test/avb_ab_flow_unittest.cc
index e055efe..adb24bd 100644
--- a/test/avb_ab_flow_unittest.cc
+++ b/test/avb_ab_flow_unittest.cc
@@ -22,15 +22,14 @@
  * SOFTWARE.
  */
 
+#include <android-base/file.h>
+#include <gtest/gtest.h>
+#include <libavb_ab/libavb_ab.h>
 #include <string.h>
 
 #include <map>
 #include <vector>
 
-#include <gtest/gtest.h>
-
-#include <libavb_ab/libavb_ab.h>
-
 #include "avb_unittest_util.h"
 #include "fake_avb_ops.h"
 
@@ -142,16 +141,15 @@ class AvbABFlowTest : public BaseAvbToolTest {
     // zeroes.
     std::vector<uint8_t> misc;
     misc.resize(MISC_PART_SIZE);
-    base::FilePath misc_path = testdir_.Append("misc.img");
+    std::filesystem::path misc_path = testdir_ / "misc.img";
     EXPECT_EQ(misc.size(),
               static_cast<const size_t>(
-                  base::WriteFile(misc_path,
+                  base::WriteFile(base::FilePath(misc_path.c_str()),
                                   reinterpret_cast<const char*>(misc.data()),
                                   misc.size())));
 
     // We're going to use this key for all images.
-    ops_.set_expected_public_key(
-        PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+    ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
   }
 
   void GenerateSlot(unsigned int slot_number,
@@ -178,7 +176,7 @@ class AvbABFlowTest : public BaseAvbToolTest {
 
     const size_t boot_partition_size = 16 * 1024 * 1024;
     const size_t boot_image_size = 5 * 1024 * 1024;
-    base::FilePath boot_path = GenerateImage(boot_name, boot_image_size);
+    std::string boot_path = GenerateImage(boot_name, boot_image_size);
     EXPECT_COMMAND(0,
                    "./avbtool.py add_hash_footer"
                    " --image %s"
@@ -186,13 +184,13 @@ class AvbABFlowTest : public BaseAvbToolTest {
                    " --partition_name boot"
                    " --partition_size %zd"
                    " --salt deadbeef",
-                   boot_path.value().c_str(),
+                   boot_path.c_str(),
                    rollback_boot,
                    boot_partition_size);
 
     const size_t odm_partition_size = 512 * 1024;
     const size_t odm_image_size = 80 * 1024;
-    base::FilePath odm_path = GenerateImage(odm_name, odm_image_size);
+    std::string odm_path = GenerateImage(odm_name, odm_image_size);
     EXPECT_COMMAND(0,
                    "./avbtool.py add_hashtree_footer"
                    " --image %s"
@@ -203,16 +201,16 @@ class AvbABFlowTest : public BaseAvbToolTest {
                    " --algorithm SHA512_RSA4096 "
                    " --key test/data/testkey_rsa4096.pem"
                    " --do_not_generate_fec",
-                   odm_path.value().c_str(),
+                   odm_path.c_str(),
                    rollback_odm,
                    odm_partition_size);
 
-    base::FilePath pk_path = testdir_.Append("testkey_rsa4096.avbpubkey");
+    std::string pk_path = (testdir_ / "testkey_rsa4096.avbpubkey").string();
     EXPECT_COMMAND(
         0,
         "./avbtool.py extract_public_key --key test/data/testkey_rsa4096.pem"
         " --output %s",
-        pk_path.value().c_str());
+        pk_path.c_str());
 
     // If requested to make the image unverified, just use another key
     // in the chain_partition descriptor since this will cause
@@ -221,14 +219,15 @@ class AvbABFlowTest : public BaseAvbToolTest {
       pk_path = GenerateImage("dummy.avbpubkey", 32);
     }
 
-    GenerateVBMetaImage(vbmeta_name,
-                        "SHA256_RSA2048",
-                        rollback_boot,
-                        base::FilePath("test/data/testkey_rsa2048.pem"),
-                        base::StringPrintf("--include_descriptors_from_image %s"
-                                           " --chain_partition odm:1:%s",
-                                           boot_path.value().c_str(),
-                                           pk_path.value().c_str()));
+    GenerateVBMetaImage(
+        vbmeta_name,
+        "SHA256_RSA2048",
+        rollback_boot,
+        "test/data/testkey_rsa2048.pem",
+        android::base::StringPrintf("--include_descriptors_from_image %s"
+                                    " --chain_partition odm:1:%s",
+                                    boot_path.c_str(),
+                                    pk_path.c_str()));
   }
 
   void SetMD(int a_pri,
@@ -1225,8 +1224,8 @@ TEST_F(AvbABFlowTest, OtherMetadataStorage) {
 
   // Check that 'misc' hasn't been written to at all.
   std::string misc_data;
-  base::FilePath misc_path = testdir_.Append("misc.img");
-  ASSERT_TRUE(base::ReadFileToString(misc_path, &misc_data));
+  std::filesystem::path misc_path = testdir_ / "misc.img";
+  ASSERT_TRUE(android::base::ReadFileToString(misc_path.string(), &misc_data));
   EXPECT_EQ(size_t(MISC_PART_SIZE), misc_data.size());
   for (size_t n = 0; n < misc_data.size(); n++) {
     ASSERT_EQ(uint8_t(misc_data[n]), 0);
@@ -1302,12 +1301,12 @@ TEST_F(AvbABFlowTest, UnlockedUnverifiedSlot) {
 TEST_F(AvbABFlowTest, AvbtoolMetadataGeneratorEmptyFile) {
   AvbABData data;
 
-  base::FilePath misc_path = testdir_.Append("misc.img");
+  std::filesystem::path misc_path = testdir_ / "misc.img";
   EXPECT_COMMAND(0,
                  "./avbtool.py set_ab_metadata"
                  " --misc_image %s"
                  " --slot_data 13:3:0:11:2:1",
-                 misc_path.value().c_str());
+                 misc_path.c_str());
 
   EXPECT_EQ(AVB_IO_RESULT_OK,
             ops_.avb_ab_ops()->read_ab_metadata(ops_.avb_ab_ops(), &data));
@@ -1324,12 +1323,12 @@ TEST_F(AvbABFlowTest, AvbtoolMetadataGeneratorExistingFile) {
   size_t n;
 
   size_t misc_size = 1024 * 1024;
-  base::FilePath misc_path = GenerateImage("misc.img", misc_size);
+  std::string misc_path = GenerateImage("misc.img", misc_size);
   EXPECT_COMMAND(0,
                  "./avbtool.py set_ab_metadata"
                  " --misc_image %s"
                  " --slot_data 12:2:1:10:5:0",
-                 misc_path.value().c_str());
+                 misc_path.c_str());
 
   EXPECT_EQ(AVB_IO_RESULT_OK,
             ops_.avb_ab_ops()->read_ab_metadata(ops_.avb_ab_ops(), &data));
@@ -1341,7 +1340,7 @@ TEST_F(AvbABFlowTest, AvbtoolMetadataGeneratorExistingFile) {
   EXPECT_EQ(0, data.slots[1].successful_boot);
 
   std::string misc_data;
-  ASSERT_TRUE(base::ReadFileToString(misc_path, &misc_data));
+  ASSERT_TRUE(android::base::ReadFileToString(misc_path, &misc_data));
   EXPECT_EQ(misc_size, misc_data.size());
   for (n = 0; n < 2048; n++) {
     ASSERT_EQ(uint8_t(misc_data[n]), uint8_t(n));
diff --git a/test/avb_cert_slot_verify_unittest.cc b/test/avb_cert_slot_verify_unittest.cc
index 69cd412..0337418 100644
--- a/test/avb_cert_slot_verify_unittest.cc
+++ b/test/avb_cert_slot_verify_unittest.cc
@@ -107,12 +107,12 @@ class AvbCertSlotVerifyExampleTest
     GenerateVBMetaImage("vbmeta_a.img",
                         "SHA512_RSA4096",
                         kNewRollbackValue,
-                        base::FilePath("test/data/testkey_cert_psk.pem"),
+                        "test/data/testkey_cert_psk.pem",
                         metadata_option);
     SHA256(vbmeta_image_.data(), vbmeta_image_.size(), expected_vbh_extension_);
 
     ops_.set_expected_public_key(
-        PublicKeyAVB(base::FilePath("test/data/testkey_cert_psk.pem")));
+        PublicKeyAVB("test/data/testkey_cert_psk.pem"));
 
     AvbSlotVerifyData* slot_data = NULL;
     EXPECT_EQ(expected_result_,
diff --git a/test/avb_cert_validate_unittest.cc b/test/avb_cert_validate_unittest.cc
index 63a34fe..30718aa 100644
--- a/test/avb_cert_validate_unittest.cc
+++ b/test/avb_cert_validate_unittest.cc
@@ -1022,11 +1022,10 @@ TEST_F(AvbCertSlotVerifyTest, SlotVerifyWithCert) {
   GenerateVBMetaImage("vbmeta_a.img",
                       "SHA512_RSA4096",
                       0,
-                      base::FilePath("test/data/testkey_cert_psk.pem"),
+                      "test/data/testkey_cert_psk.pem",
                       metadata_option);
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_cert_psk.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_cert_psk.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"boot", NULL};
diff --git a/test/avb_slot_verify_unittest.cc b/test/avb_slot_verify_unittest.cc
index 9360155..76af86a 100644
--- a/test/avb_slot_verify_unittest.cc
+++ b/test/avb_slot_verify_unittest.cc
@@ -22,11 +22,11 @@
  * SOFTWARE.
  */
 
-#include <iostream>
-
+#include <android-base/file.h>
+#include <android-base/stringprintf.h>
 #include <base/files/file_util.h>
-#include <base/strings/string_util.h>
-#include <base/strings/stringprintf.h>
+
+#include <iostream>
 
 #include "avb_unittest_util.h"
 #include "fake_avb_ops.h"
@@ -57,11 +57,10 @@ TEST_F(AvbSlotVerifyTest, Basic) {
   GenerateVBMetaImage("vbmeta_a.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\"");
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"boot", NULL};
@@ -98,11 +97,10 @@ TEST_F(AvbSlotVerifyTest, BasicSha512) {
   GenerateVBMetaImage("vbmeta_a.img",
                       "SHA512_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\"");
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"boot", NULL};
@@ -144,11 +142,10 @@ TEST_F(AvbSlotVerifyTest, BasicUnlocked) {
   GenerateVBMetaImage("vbmeta_a.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\"");
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   ops_.set_stored_is_device_unlocked(true);
 
@@ -179,11 +176,10 @@ TEST_F(AvbSlotVerifyTest, PreloadedEnabledButNotUsed) {
   GenerateVBMetaImage("vbmeta_a.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\"");
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
   ops_.enable_get_preloaded_partition();
 
   AvbSlotVerifyData* slot_data = NULL;
@@ -203,11 +199,10 @@ TEST_F(AvbSlotVerifyTest, SlotDataIsCorrect) {
   GenerateVBMetaImage("vbmeta_a.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\"");
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"boot", NULL};
@@ -226,7 +221,7 @@ TEST_F(AvbSlotVerifyTest, WrongPublicKey) {
   GenerateVBMetaImage("vbmeta_a.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\"");
 
   AvbSlotVerifyData* slot_data = NULL;
@@ -264,11 +259,8 @@ TEST_F(AvbSlotVerifyTest, NoImage) {
 }
 
 TEST_F(AvbSlotVerifyTest, UnsignedVBMeta) {
-  GenerateVBMetaImage("vbmeta_a.img",
-                      "",
-                      0,
-                      base::FilePath(""),
-                      "--internal_release_string \"\"");
+  GenerateVBMetaImage(
+      "vbmeta_a.img", "", 0, "", "--internal_release_string \"\"");
 
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"boot", NULL};
@@ -295,7 +287,7 @@ TEST_F(AvbSlotVerifyTest, CorruptedImage) {
   GenerateVBMetaImage("vbmeta_a.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\"");
 
   // Corrupt four bytes of data in the end of the image. Since the aux
@@ -334,7 +326,7 @@ TEST_F(AvbSlotVerifyTest, CorruptedMetadata) {
   GenerateVBMetaImage("vbmeta_a.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\"");
 
   // Corrupt four bytes of data in the beginning of the image. Unlike
@@ -366,11 +358,10 @@ TEST_F(AvbSlotVerifyTest, RollbackIndex) {
   GenerateVBMetaImage("vbmeta_a.img",
                       "SHA256_RSA2048",
                       42,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\"");
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"boot", NULL};
@@ -414,11 +405,10 @@ TEST_F(AvbSlotVerifyTest, RollbackIndexLocationSpecified) {
   GenerateVBMetaImage("vbmeta_a.img",
                       "SHA256_RSA2048",
                       42,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--rollback_index_location 15");
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"boot", NULL};
@@ -470,15 +460,15 @@ TEST_F(AvbSlotVerifyTest, RollbackIndexLocationSpecified) {
 
 TEST_F(AvbSlotVerifyTest, RollbackIndexLocationInvalid) {
   uint32_t rollback_index_location = AVB_MAX_NUMBER_OF_ROLLBACK_INDEX_LOCATIONS;
-  GenerateVBMetaImage("vbmeta_a.img",
-                      "SHA256_RSA2048",
-                      42,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
-                      base::StringPrintf("--rollback_index_location %d",
-                                         rollback_index_location));
+  GenerateVBMetaImage(
+      "vbmeta_a.img",
+      "SHA256_RSA2048",
+      42,
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--rollback_index_location %d",
+                                  rollback_index_location));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"boot", NULL};
@@ -497,7 +487,7 @@ TEST_F(AvbSlotVerifyTest, LoadEntirePartitionIfAllowingVerificationError) {
   const size_t boot_partition_size = 16 * 1024 * 1024;
   const size_t boot_image_size = 5 * 1024 * 1024;
   const size_t new_boot_image_size = 10 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot_a.img", boot_image_size);
+  std::string boot_path = GenerateImage("boot_a.img", boot_image_size);
 
   // If we're allowing verification errors then check that the whole
   // partition is loaded. This is needed because in this mode for
@@ -514,19 +504,19 @@ TEST_F(AvbSlotVerifyTest, LoadEntirePartitionIfAllowingVerificationError) {
       " --kernel_cmdline 'cmdline in hash footer $(ANDROID_SYSTEM_PARTUUID)'"
       " --salt deadbeef"
       " --internal_release_string \"\"",
-      boot_path.value().c_str(),
+      boot_path.c_str(),
       boot_partition_size);
 
   GenerateVBMetaImage(
       "vbmeta_a.img",
       "SHA256_RSA2048",
       4,
-      base::FilePath("test/data/testkey_rsa2048.pem"),
-      base::StringPrintf(
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf(
           "--include_descriptors_from_image %s"
           " --kernel_cmdline 'cmdline in vbmeta $(ANDROID_BOOT_PARTUUID)'"
           " --internal_release_string \"\"",
-          boot_path.value().c_str()));
+          boot_path.c_str()));
 
   // Now replace the boot partition with something bigger and
   // different. Because FakeOps's get_size_of_partition() operation
@@ -538,8 +528,7 @@ TEST_F(AvbSlotVerifyTest, LoadEntirePartitionIfAllowingVerificationError) {
   // to return ERROR_VERIFICATION below.
   GenerateImage("boot_a.img", new_boot_image_size, 1 /* start_byte */);
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"boot", NULL};
@@ -565,7 +554,7 @@ TEST_F(AvbSlotVerifyTest, LoadSmallerPartitionIfAllowingVerificationError) {
   const size_t boot_partition_size = 16 * 1024 * 1024;
   const size_t boot_image_size = 5 * 1024 * 1024;
   const size_t new_boot_image_size = 1 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot_a.img", boot_image_size);
+  std::string boot_path = GenerateImage("boot_a.img", boot_image_size);
 
   // If we're allowing verification errors then check that the whole
   // partition is loaded. This is needed because in this mode for
@@ -582,19 +571,19 @@ TEST_F(AvbSlotVerifyTest, LoadSmallerPartitionIfAllowingVerificationError) {
       " --kernel_cmdline 'cmdline in hash footer $(ANDROID_SYSTEM_PARTUUID)'"
       " --salt deadbeef"
       " --internal_release_string \"\"",
-      boot_path.value().c_str(),
+      boot_path.c_str(),
       boot_partition_size);
 
   GenerateVBMetaImage(
       "vbmeta_a.img",
       "SHA256_RSA2048",
       4,
-      base::FilePath("test/data/testkey_rsa2048.pem"),
-      base::StringPrintf(
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf(
           "--include_descriptors_from_image %s"
           " --kernel_cmdline 'cmdline in vbmeta $(ANDROID_BOOT_PARTUUID)'"
           " --internal_release_string \"\"",
-          boot_path.value().c_str()));
+          boot_path.c_str()));
 
   // Now replace the boot partition with something bigger and
   // different. Because FakeOps's get_size_of_partition() operation
@@ -606,8 +595,7 @@ TEST_F(AvbSlotVerifyTest, LoadSmallerPartitionIfAllowingVerificationError) {
   // to return ERROR_VERIFICATION below.
   GenerateImage("boot_a.img", new_boot_image_size, 1 /* start_byte */);
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"boot", NULL};
@@ -632,7 +620,7 @@ TEST_F(AvbSlotVerifyTest, LoadSmallerPartitionIfAllowingVerificationError) {
 TEST_F(AvbSlotVerifyTest, HashDescriptorInVBMeta) {
   const size_t boot_partition_size = 16 * 1024 * 1024;
   const size_t boot_image_size = 5 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot_a.img", boot_image_size);
+  std::string boot_path = GenerateImage("boot_a.img", boot_image_size);
 
   EXPECT_COMMAND(
       0,
@@ -644,19 +632,19 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInVBMeta) {
       " --kernel_cmdline 'cmdline in hash footer $(ANDROID_SYSTEM_PARTUUID)'"
       " --salt deadbeef"
       " --internal_release_string \"\"",
-      boot_path.value().c_str(),
+      boot_path.c_str(),
       boot_partition_size);
 
   GenerateVBMetaImage(
       "vbmeta_a.img",
       "SHA256_RSA2048",
       4,
-      base::FilePath("test/data/testkey_rsa2048.pem"),
-      base::StringPrintf(
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf(
           "--include_descriptors_from_image %s"
           " --kernel_cmdline 'cmdline in vbmeta $(ANDROID_BOOT_PARTUUID)'"
           " --internal_release_string \"\"",
-          boot_path.value().c_str()));
+          boot_path.c_str()));
 
   EXPECT_EQ(
       "Minimum libavb version:   1.0\n"
@@ -686,19 +674,17 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInVBMeta) {
       "      Digest:                "
       "184cb36243adb8b87d2d8c4802de32125fe294ec46753d732144ee65df68a23d\n"
       "      Flags:                 0\n",
-      InfoImage(vbmeta_image_path_));
+      InfoImage(vbmeta_image_path_.string()));
 
   EXPECT_COMMAND(0,
                  "./avbtool.py erase_footer"
                  " --image %s",
-                 boot_path.value().c_str());
+                 boot_path.c_str());
 
   // With no footer, 'avbtool info_image' should fail (exit status 1).
-  EXPECT_COMMAND(
-      1, "./avbtool.py info_image --image %s", boot_path.value().c_str());
+  EXPECT_COMMAND(1, "./avbtool.py info_image --image %s", boot_path.c_str());
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"boot", NULL};
@@ -756,7 +742,7 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInVBMeta) {
 TEST_F(AvbSlotVerifyTest, HashDescriptorInVBMetaWithPreloadedPartition) {
   const size_t boot_partition_size = 16 * 1024 * 1024;
   const size_t boot_image_size = 5 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot_a.img", boot_image_size);
+  std::string boot_path = GenerateImage("boot_a.img", boot_image_size);
 
   EXPECT_COMMAND(
       0,
@@ -768,33 +754,31 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInVBMetaWithPreloadedPartition) {
       " --kernel_cmdline 'cmdline in hash footer $(ANDROID_SYSTEM_PARTUUID)'"
       " --salt deadbeef"
       " --internal_release_string \"\"",
-      boot_path.value().c_str(),
+      boot_path.c_str(),
       boot_partition_size);
 
   GenerateVBMetaImage(
       "vbmeta_a.img",
       "SHA256_RSA2048",
       4,
-      base::FilePath("test/data/testkey_rsa2048.pem"),
-      base::StringPrintf(
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf(
           "--include_descriptors_from_image %s"
           " --kernel_cmdline 'cmdline in vbmeta $(ANDROID_BOOT_PARTUUID)'"
           " --internal_release_string \"\"",
-          boot_path.value().c_str()));
+          boot_path.c_str()));
 
   EXPECT_COMMAND(0,
                  "./avbtool.py erase_footer"
                  " --image %s",
-                 boot_path.value().c_str());
+                 boot_path.c_str());
 
   // With no footer, 'avbtool info_image' should fail (exit status 1).
-  EXPECT_COMMAND(
-      1, "./avbtool.py info_image --image %s", boot_path.value().c_str());
+  EXPECT_COMMAND(1, "./avbtool.py info_image --image %s", boot_path.c_str());
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
   ops_.enable_get_preloaded_partition();
-  EXPECT_TRUE(ops_.preload_partition("boot_a", boot_path));
+  EXPECT_TRUE(ops_.preload_partition("boot_a", base::FilePath(boot_path)));
 
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"boot", NULL};
@@ -835,7 +819,7 @@ TEST_F(AvbSlotVerifyTest, SmallPreallocatedPreloadedPartitionFailGracefully) {
   const size_t boot_partition_size = 16 * 1024 * 1024;
   const size_t boot_image_size = 5 * 1024 * 1024;
   // Generate vbmeta based on this boot image.
-  base::FilePath boot_path = GenerateImage("boot_a.img", boot_image_size);
+  std::string boot_path = GenerateImage("boot_a.img", boot_image_size);
 
   // Preload smaller image than expected on the stack
   // libavb should not attempt to free this buffer.
@@ -852,27 +836,26 @@ TEST_F(AvbSlotVerifyTest, SmallPreallocatedPreloadedPartitionFailGracefully) {
       " --kernel_cmdline 'cmdline in hash footer $(ANDROID_SYSTEM_PARTUUID)'"
       " --salt deadbeef"
       " --internal_release_string \"\"",
-      boot_path.value().c_str(),
+      boot_path.c_str(),
       boot_partition_size);
 
   GenerateVBMetaImage(
       "vbmeta_a.img",
       "SHA256_RSA2048",
       4,
-      base::FilePath("test/data/testkey_rsa2048.pem"),
-      base::StringPrintf(
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf(
           "--include_descriptors_from_image %s"
           " --kernel_cmdline 'cmdline in vbmeta $(ANDROID_BOOT_PARTUUID)'"
           " --internal_release_string \"\"",
-          boot_path.value().c_str()));
+          boot_path.c_str()));
 
   EXPECT_COMMAND(0,
                  "./avbtool.py erase_footer"
                  " --image %s",
-                 boot_path.value().c_str());
+                 boot_path.c_str());
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
   ops_.enable_get_preloaded_partition();
   EXPECT_TRUE(ops_.preload_preallocated_partition(
       "boot_a", fake_preload_buf, fake_preload_image_size));
@@ -891,7 +874,7 @@ TEST_F(AvbSlotVerifyTest, SmallPreallocatedPreloadedPartitionFailGracefully) {
 
 TEST_F(AvbSlotVerifyTest, HashDescriptorInVBMetaCorruptBoot) {
   size_t boot_partition_size = 16 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot_a.img", 5 * 1024 * 1024);
+  std::string boot_path = GenerateImage("boot_a.img", 5 * 1024 * 1024);
   const char* requested_partitions[] = {"boot", NULL};
 
   EXPECT_COMMAND(0,
@@ -902,24 +885,24 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInVBMetaCorruptBoot) {
                  " --partition_size %zd"
                  " --salt deadbeef"
                  " --internal_release_string \"\"",
-                 boot_path.value().c_str(),
+                 boot_path.c_str(),
                  boot_partition_size);
 
-  GenerateVBMetaImage("vbmeta_a.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
-                      base::StringPrintf("--include_descriptors_from_image %s"
-                                         " --internal_release_string \"\"",
-                                         boot_path.value().c_str()));
+  GenerateVBMetaImage(
+      "vbmeta_a.img",
+      "SHA256_RSA2048",
+      0,
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--include_descriptors_from_image %s"
+                                  " --internal_release_string \"\"",
+                                  boot_path.c_str()));
 
   EXPECT_COMMAND(0,
                  "./avbtool.py erase_footer"
                  " --image %s",
-                 boot_path.value().c_str());
+                 boot_path.c_str());
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   // So far, so good.
   AvbSlotVerifyData* slot_data = NULL;
@@ -964,7 +947,7 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInVBMetaCorruptBoot) {
 TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartition) {
   size_t boot_partition_size = 16 * 1024 * 1024;
   const size_t boot_image_size = 5 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot.img", boot_image_size);
+  std::string boot_path = GenerateImage("boot.img", boot_image_size);
   const char* requested_partitions[] = {"boot", NULL};
 
   EXPECT_COMMAND(0,
@@ -978,25 +961,25 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartition) {
                  " --key test/data/testkey_rsa4096.pem"
                  " --salt deadbeef"
                  " --internal_release_string \"\"",
-                 boot_path.value().c_str(),
+                 boot_path.c_str(),
                  boot_partition_size);
 
-  base::FilePath pk_path = testdir_.Append("testkey_rsa4096.avbpubkey");
+  std::filesystem::path pk_path = testdir_ / "testkey_rsa4096.avbpubkey";
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa4096.pem"
       " --output %s",
-      pk_path.value().c_str());
+      pk_path.c_str());
 
   GenerateVBMetaImage(
       "vbmeta.img",
       "SHA256_RSA2048",
       11,
-      base::FilePath("test/data/testkey_rsa2048.pem"),
-      base::StringPrintf("--chain_partition boot:1:%s"
-                         " --kernel_cmdline 'cmdline2 in vbmeta'"
-                         " --internal_release_string \"\"",
-                         pk_path.value().c_str()));
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--chain_partition boot:1:%s"
+                                  " --kernel_cmdline 'cmdline2 in vbmeta'"
+                                  " --internal_release_string \"\"",
+                                  pk_path.c_str()));
 
   EXPECT_EQ(
       "Minimum libavb version:   1.0\n"
@@ -1019,7 +1002,7 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartition) {
       "    Kernel Cmdline descriptor:\n"
       "      Flags:                 0\n"
       "      Kernel Cmdline:        'cmdline2 in vbmeta'\n",
-      InfoImage(vbmeta_image_path_));
+      InfoImage(vbmeta_image_path_.string()));
 
   EXPECT_EQ(
       "Footer version:           1.0\n"
@@ -1052,8 +1035,7 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartition) {
       "      Kernel Cmdline:        'cmdline2 in hash footer'\n",
       InfoImage(boot_path));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   EXPECT_EQ(AVB_SLOT_VERIFY_RESULT_OK,
@@ -1150,36 +1132,37 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartition) {
 TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartitionNoAB) {
   size_t boot_partition_size = 16 * 1024 * 1024;
   const size_t boot_image_size = 5 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot.img", boot_image_size);
-  EXPECT_COMMAND(0,
-                 "./avbtool.py add_hash_footer"
-                 " --image %s"
-                 " --rollback_index 12"
-                 " --partition_name boot"
-                 " --partition_size %zd"
-                 " --algorithm SHA256_RSA4096"
-                 " --key test/data/testkey_rsa4096.pem"
-                 " --salt d70fd60d0f7d9c3b4587b9782c0dd2012ba01bfb3598a47ca8dce88d6afb9415"
-                 " --internal_release_string \"\""
-                 " --do_not_use_ab",
-                 boot_path.value().c_str(),
-                 boot_partition_size);
+  std::string boot_path = GenerateImage("boot.img", boot_image_size);
+  EXPECT_COMMAND(
+      0,
+      "./avbtool.py add_hash_footer"
+      " --image %s"
+      " --rollback_index 12"
+      " --partition_name boot"
+      " --partition_size %zd"
+      " --algorithm SHA256_RSA4096"
+      " --key test/data/testkey_rsa4096.pem"
+      " --salt d70fd60d0f7d9c3b4587b9782c0dd2012ba01bfb3598a47ca8dce88d6afb9415"
+      " --internal_release_string \"\""
+      " --do_not_use_ab",
+      boot_path.c_str(),
+      boot_partition_size);
 
-  base::FilePath pk_path = testdir_.Append("testkey_rsa4096.avbpubkey");
+  std::filesystem::path pk_path = testdir_ / "testkey_rsa4096.avbpubkey";
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa4096.pem"
       " --output %s",
-      pk_path.value().c_str());
+      pk_path.c_str());
 
   GenerateVBMetaImage(
       "vbmeta_a.img",
       "SHA256_RSA2048",
       11,
-      base::FilePath("test/data/testkey_rsa2048.pem"),
-      base::StringPrintf("--chain_partition_do_not_use_ab boot:1:%s"
-                         " --internal_release_string \"\"",
-                         pk_path.value().c_str()));
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--chain_partition_do_not_use_ab boot:1:%s"
+                                  " --internal_release_string \"\"",
+                                  pk_path.c_str()));
 
   EXPECT_EQ(
       "Minimum libavb version:   1.3\n"
@@ -1199,7 +1182,7 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartitionNoAB) {
       "      Public key (sha1):       "
       "2597c218aae470a130f61162feaae70afd97f011\n"
       "      Flags:                   1\n",
-      InfoImage(vbmeta_image_path_));
+      InfoImage(vbmeta_image_path_.string()));
 
   EXPECT_EQ(
       "Footer version:           1.0\n"
@@ -1230,8 +1213,7 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartitionNoAB) {
       "      Flags:                 1\n",
       InfoImage(boot_path));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"boot", NULL};
@@ -1310,7 +1292,7 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartitionNoAB) {
 TEST_F(AvbSlotVerifyTest, RollbackIndexLocationInChainedPartition) {
   size_t boot_partition_size = 16 * 1024 * 1024;
   const size_t boot_image_size = 5 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot.img", boot_image_size);
+  std::string boot_path = GenerateImage("boot.img", boot_image_size);
   const char* requested_partitions[] = {"boot", NULL};
 
   EXPECT_COMMAND(0,
@@ -1325,26 +1307,26 @@ TEST_F(AvbSlotVerifyTest, RollbackIndexLocationInChainedPartition) {
                  " --key test/data/testkey_rsa4096.pem"
                  " --salt deadbeef"
                  " --internal_release_string \"\"",
-                 boot_path.value().c_str(),
+                 boot_path.c_str(),
                  boot_partition_size);
 
-  base::FilePath pk_path = testdir_.Append("testkey_rsa4096.avbpubkey");
+  std::filesystem::path pk_path = testdir_ / "testkey_rsa4096.avbpubkey";
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa4096.pem"
       " --output %s",
-      pk_path.value().c_str());
+      pk_path.c_str());
 
   GenerateVBMetaImage(
       "vbmeta.img",
       "SHA256_RSA2048",
       11,
-      base::FilePath("test/data/testkey_rsa2048.pem"),
-      base::StringPrintf("--chain_partition boot:2:%s"
-                         " --kernel_cmdline 'cmdline2 in vbmeta'"
-                         " --rollback_index_location 1"
-                         " --internal_release_string \"\"",
-                         pk_path.value().c_str()));
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--chain_partition boot:2:%s"
+                                  " --kernel_cmdline 'cmdline2 in vbmeta'"
+                                  " --rollback_index_location 1"
+                                  " --internal_release_string \"\"",
+                                  pk_path.c_str()));
 
   EXPECT_EQ(
       "Minimum libavb version:   1.2\n"
@@ -1367,7 +1349,7 @@ TEST_F(AvbSlotVerifyTest, RollbackIndexLocationInChainedPartition) {
       "    Kernel Cmdline descriptor:\n"
       "      Flags:                 0\n"
       "      Kernel Cmdline:        'cmdline2 in vbmeta'\n",
-      InfoImage(vbmeta_image_path_));
+      InfoImage(vbmeta_image_path_.string()));
 
   EXPECT_EQ(
       "Footer version:           1.0\n"
@@ -1400,8 +1382,7 @@ TEST_F(AvbSlotVerifyTest, RollbackIndexLocationInChainedPartition) {
       "      Kernel Cmdline:        'cmdline2 in hash footer'\n",
       InfoImage(boot_path));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   // Verify that the rollback index location in the chained partition is ignored
   ops_.set_stored_rollback_indexes({{1, 11}, {2, 12}, {3, 20}});
@@ -1428,8 +1409,8 @@ TEST_F(AvbSlotVerifyTest, RollbackIndexLocationInChainedPartition) {
 TEST_F(AvbSlotVerifyTest, HashDescriptorInOtherVBMetaPartition) {
   size_t boot_partition_size = 16 * 1024 * 1024;
   const size_t boot_image_size = 5 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot.img", boot_image_size);
-  base::FilePath other_vbmeta_path = testdir_.Append("vbmeta_google.img");
+  std::string boot_path = GenerateImage("boot.img", boot_image_size);
+  std::filesystem::path other_vbmeta_path = testdir_ / "vbmeta_google.img";
   const char* requested_partitions[] = {"boot", NULL};
 
   EXPECT_COMMAND(0,
@@ -1443,7 +1424,7 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInOtherVBMetaPartition) {
                  " --key test/data/testkey_rsa4096.pem"
                  " --salt deadbeef"
                  " --internal_release_string \"\"",
-                 boot_path.value().c_str(),
+                 boot_path.c_str(),
                  boot_partition_size);
 
   // Extract the vbmeta blob from the footer in boot.img, put it into
@@ -1452,29 +1433,29 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInOtherVBMetaPartition) {
                  "./avbtool.py extract_vbmeta_image"
                  " --image %s"
                  " --output %s",
-                 boot_path.value().c_str(),
-                 other_vbmeta_path.value().c_str());
+                 boot_path.c_str(),
+                 other_vbmeta_path.c_str());
   EXPECT_COMMAND(0,
                  "./avbtool.py erase_footer"
                  " --image %s",
-                 boot_path.value().c_str());
+                 boot_path.c_str());
 
-  base::FilePath pk_path = testdir_.Append("testkey_rsa4096.avbpubkey");
+  std::filesystem::path pk_path = testdir_ / "testkey_rsa4096.avbpubkey";
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa4096.pem"
       " --output %s",
-      pk_path.value().c_str());
+      pk_path.c_str());
 
   GenerateVBMetaImage(
       "vbmeta.img",
       "SHA256_RSA2048",
       11,
-      base::FilePath("test/data/testkey_rsa2048.pem"),
-      base::StringPrintf("--chain_partition vbmeta_google:1:%s"
-                         " --kernel_cmdline 'cmdline2 in vbmeta'"
-                         " --internal_release_string \"\"",
-                         pk_path.value().c_str()));
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--chain_partition vbmeta_google:1:%s"
+                                  " --kernel_cmdline 'cmdline2 in vbmeta'"
+                                  " --internal_release_string \"\"",
+                                  pk_path.c_str()));
 
   EXPECT_EQ(
       "Minimum libavb version:   1.0\n"
@@ -1497,7 +1478,7 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInOtherVBMetaPartition) {
       "    Kernel Cmdline descriptor:\n"
       "      Flags:                 0\n"
       "      Kernel Cmdline:        'cmdline2 in vbmeta'\n",
-      InfoImage(vbmeta_image_path_));
+      InfoImage(vbmeta_image_path_.string()));
 
   EXPECT_EQ(
       "Minimum libavb version:   1.0\n"
@@ -1522,10 +1503,9 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInOtherVBMetaPartition) {
       "    Kernel Cmdline descriptor:\n"
       "      Flags:                 0\n"
       "      Kernel Cmdline:        'cmdline2 in hash footer'\n",
-      InfoImage(other_vbmeta_path));
+      InfoImage(other_vbmeta_path.string()));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   EXPECT_EQ(AVB_SLOT_VERIFY_RESULT_OK,
@@ -1622,7 +1602,7 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInOtherVBMetaPartition) {
 
 TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartitionCorruptBoot) {
   size_t boot_partition_size = 16 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot_a.img", 5 * 1024 * 1024);
+  std::string boot_path = GenerateImage("boot_a.img", 5 * 1024 * 1024);
   const char* requested_partitions[] = {"boot", NULL};
 
   EXPECT_COMMAND(0,
@@ -1635,26 +1615,26 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartitionCorruptBoot) {
                  " --key test/data/testkey_rsa4096.pem"
                  " --salt deadbeef"
                  " --internal_release_string \"\"",
-                 boot_path.value().c_str(),
+                 boot_path.c_str(),
                  boot_partition_size);
 
-  base::FilePath pk_path = testdir_.Append("testkey_rsa4096.avbpubkey");
+  std::filesystem::path pk_path = testdir_ / "testkey_rsa4096.avbpubkey";
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa4096.pem"
       " --output %s",
-      pk_path.value().c_str());
+      pk_path.c_str());
 
-  GenerateVBMetaImage("vbmeta_a.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
-                      base::StringPrintf("--chain_partition boot:1:%s"
-                                         " --internal_release_string \"\"",
-                                         pk_path.value().c_str()));
+  GenerateVBMetaImage(
+      "vbmeta_a.img",
+      "SHA256_RSA2048",
+      0,
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--chain_partition boot:1:%s"
+                                  " --internal_release_string \"\"",
+                                  pk_path.c_str()));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   EXPECT_EQ(AVB_SLOT_VERIFY_RESULT_OK,
@@ -1697,7 +1677,7 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartitionCorruptBoot) {
 
 TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartitionKeyMismatch) {
   size_t boot_partition_size = 16 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot_a.img", 5 * 1024 * 1024);
+  std::string boot_path = GenerateImage("boot_a.img", 5 * 1024 * 1024);
   const char* requested_partitions[] = {"boot", NULL};
 
   // Use different key to sign vbmeta in boot_a (we use the 8192 bit
@@ -1715,26 +1695,26 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartitionKeyMismatch) {
                  " --key test/data/testkey_rsa8192.pem"
                  " --salt deadbeef"
                  " --internal_release_string \"\"",
-                 boot_path.value().c_str(),
+                 boot_path.c_str(),
                  boot_partition_size);
 
-  base::FilePath pk_path = testdir_.Append("testkey_rsa4096.avbpubkey");
+  std::filesystem::path pk_path = testdir_ / "testkey_rsa4096.avbpubkey";
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa4096.pem"
       " --output %s",
-      pk_path.value().c_str());
+      pk_path.c_str());
 
-  GenerateVBMetaImage("vbmeta_a.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
-                      base::StringPrintf("--chain_partition boot:1:%s"
-                                         " --internal_release_string \"\"",
-                                         pk_path.value().c_str()));
+  GenerateVBMetaImage(
+      "vbmeta_a.img",
+      "SHA256_RSA2048",
+      0,
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--chain_partition boot:1:%s"
+                                  " --internal_release_string \"\"",
+                                  pk_path.c_str()));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   EXPECT_EQ(AVB_SLOT_VERIFY_RESULT_ERROR_PUBLIC_KEY_REJECTED,
@@ -1758,7 +1738,7 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartitionKeyMismatch) {
 
 TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartitionRollbackIndexFail) {
   size_t boot_partition_size = 16 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot_a.img", 5 * 1024 * 1024);
+  std::string boot_path = GenerateImage("boot_a.img", 5 * 1024 * 1024);
   const char* requested_partitions[] = {"boot", NULL};
 
   EXPECT_COMMAND(0,
@@ -1771,26 +1751,26 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartitionRollbackIndexFail) {
                  " --key test/data/testkey_rsa4096.pem"
                  " --salt deadbeef"
                  " --internal_release_string \"\"",
-                 boot_path.value().c_str(),
+                 boot_path.c_str(),
                  boot_partition_size);
 
-  base::FilePath pk_path = testdir_.Append("testkey_rsa4096.avbpubkey");
+  std::filesystem::path pk_path = testdir_ / "testkey_rsa4096.avbpubkey";
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa4096.pem"
       " --output %s",
-      pk_path.value().c_str());
+      pk_path.c_str());
 
-  GenerateVBMetaImage("vbmeta_a.img",
-                      "SHA256_RSA2048",
-                      110,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
-                      base::StringPrintf("--chain_partition boot:1:%s"
-                                         " --internal_release_string \"\"",
-                                         pk_path.value().c_str()));
+  GenerateVBMetaImage(
+      "vbmeta_a.img",
+      "SHA256_RSA2048",
+      110,
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--chain_partition boot:1:%s"
+                                  " --internal_release_string \"\"",
+                                  pk_path.c_str()));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
 
@@ -1846,7 +1826,7 @@ TEST_F(AvbSlotVerifyTest, HashDescriptorInChainedPartitionRollbackIndexFail) {
 TEST_F(AvbSlotVerifyTest, ChainedPartitionNoSlots) {
   size_t boot_partition_size = 16 * 1024 * 1024;
   const size_t boot_image_size = 5 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot.img", boot_image_size);
+  std::string boot_path = GenerateImage("boot.img", boot_image_size);
   const char* requested_partitions[] = {"boot", NULL};
 
   EXPECT_COMMAND(0,
@@ -1860,25 +1840,25 @@ TEST_F(AvbSlotVerifyTest, ChainedPartitionNoSlots) {
                  " --key test/data/testkey_rsa4096.pem"
                  " --salt deadbeef"
                  " --internal_release_string \"\"",
-                 boot_path.value().c_str(),
+                 boot_path.c_str(),
                  boot_partition_size);
 
-  base::FilePath pk_path = testdir_.Append("testkey_rsa4096.avbpubkey");
+  std::filesystem::path pk_path = testdir_ / "testkey_rsa4096.avbpubkey";
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa4096.pem"
       " --output %s",
-      pk_path.value().c_str());
+      pk_path.c_str());
 
   GenerateVBMetaImage(
       "vbmeta.img",
       "SHA256_RSA2048",
       11,
-      base::FilePath("test/data/testkey_rsa2048.pem"),
-      base::StringPrintf("--chain_partition boot:1:%s"
-                         " --kernel_cmdline 'cmdline2 in vbmeta'"
-                         " --internal_release_string \"\"",
-                         pk_path.value().c_str()));
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--chain_partition boot:1:%s"
+                                  " --kernel_cmdline 'cmdline2 in vbmeta'"
+                                  " --internal_release_string \"\"",
+                                  pk_path.c_str()));
 
   EXPECT_EQ(
       "Minimum libavb version:   1.0\n"
@@ -1901,10 +1881,9 @@ TEST_F(AvbSlotVerifyTest, ChainedPartitionNoSlots) {
       "    Kernel Cmdline descriptor:\n"
       "      Flags:                 0\n"
       "      Kernel Cmdline:        'cmdline2 in vbmeta'\n",
-      InfoImage(vbmeta_image_path_));
+      InfoImage(vbmeta_image_path_.string()));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   EXPECT_EQ(AVB_SLOT_VERIFY_RESULT_OK,
@@ -1964,8 +1943,8 @@ TEST_F(AvbSlotVerifyTest, PartitionsOtherThanBoot) {
   const size_t bar_partition_size = 32 * 1024 * 1024;
   const size_t foo_image_size = 5 * 1024 * 1024;
   const size_t bar_image_size = 10 * 1024 * 1024;
-  base::FilePath foo_path = GenerateImage("foo_a.img", foo_image_size);
-  base::FilePath bar_path = GenerateImage("bar_a.img", bar_image_size);
+  std::string foo_path = GenerateImage("foo_a.img", foo_image_size);
+  std::string bar_path = GenerateImage("bar_a.img", bar_image_size);
 
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hash_footer"
@@ -1974,7 +1953,7 @@ TEST_F(AvbSlotVerifyTest, PartitionsOtherThanBoot) {
                  " --partition_size %zd"
                  " --salt deadbeef"
                  " --internal_release_string \"\"",
-                 foo_path.value().c_str(),
+                 foo_path.c_str(),
                  foo_partition_size);
 
   EXPECT_COMMAND(0,
@@ -1984,18 +1963,19 @@ TEST_F(AvbSlotVerifyTest, PartitionsOtherThanBoot) {
                  " --partition_size %zd"
                  " --salt deadbeef"
                  " --internal_release_string \"\"",
-                 bar_path.value().c_str(),
+                 bar_path.c_str(),
                  bar_partition_size);
 
-  GenerateVBMetaImage("vbmeta_a.img",
-                      "SHA256_RSA2048",
-                      4,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
-                      base::StringPrintf("--include_descriptors_from_image %s"
-                                         " --include_descriptors_from_image %s"
-                                         " --internal_release_string \"\"",
-                                         foo_path.value().c_str(),
-                                         bar_path.value().c_str()));
+  GenerateVBMetaImage(
+      "vbmeta_a.img",
+      "SHA256_RSA2048",
+      4,
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--include_descriptors_from_image %s"
+                                  " --include_descriptors_from_image %s"
+                                  " --internal_release_string \"\"",
+                                  foo_path.c_str(),
+                                  bar_path.c_str()));
 
   EXPECT_EQ(
       "Minimum libavb version:   1.0\n"
@@ -2025,10 +2005,9 @@ TEST_F(AvbSlotVerifyTest, PartitionsOtherThanBoot) {
       "      Digest:                "
       "184cb36243adb8b87d2d8c4802de32125fe294ec46753d732144ee65df68a23d\n"
       "      Flags:                 0\n",
-      InfoImage(vbmeta_image_path_));
+      InfoImage(vbmeta_image_path_.string()));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"foo", "bar", NULL};
@@ -2079,8 +2058,8 @@ TEST_F(AvbSlotVerifyTest, OnlyLoadWhatHasBeenRequested) {
   const size_t bar_partition_size = 32 * 1024 * 1024;
   const size_t foo_image_size = 5 * 1024 * 1024;
   const size_t bar_image_size = 10 * 1024 * 1024;
-  base::FilePath foo_path = GenerateImage("foo_a.img", foo_image_size);
-  base::FilePath bar_path = GenerateImage("bar_a.img", bar_image_size);
+  std::string foo_path = GenerateImage("foo_a.img", foo_image_size);
+  std::string bar_path = GenerateImage("bar_a.img", bar_image_size);
 
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hash_footer"
@@ -2089,7 +2068,7 @@ TEST_F(AvbSlotVerifyTest, OnlyLoadWhatHasBeenRequested) {
                  " --partition_size %zd"
                  " --salt deadbeef"
                  " --internal_release_string \"\"",
-                 foo_path.value().c_str(),
+                 foo_path.c_str(),
                  foo_partition_size);
 
   EXPECT_COMMAND(0,
@@ -2099,18 +2078,19 @@ TEST_F(AvbSlotVerifyTest, OnlyLoadWhatHasBeenRequested) {
                  " --partition_size %zd"
                  " --salt deadbeef"
                  " --internal_release_string \"\"",
-                 bar_path.value().c_str(),
+                 bar_path.c_str(),
                  bar_partition_size);
 
-  GenerateVBMetaImage("vbmeta_a.img",
-                      "SHA256_RSA2048",
-                      4,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
-                      base::StringPrintf("--include_descriptors_from_image %s"
-                                         " --include_descriptors_from_image %s"
-                                         " --internal_release_string \"\"",
-                                         foo_path.value().c_str(),
-                                         bar_path.value().c_str()));
+  GenerateVBMetaImage(
+      "vbmeta_a.img",
+      "SHA256_RSA2048",
+      4,
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--include_descriptors_from_image %s"
+                                  " --include_descriptors_from_image %s"
+                                  " --internal_release_string \"\"",
+                                  foo_path.c_str(),
+                                  bar_path.c_str()));
 
   EXPECT_EQ(
       "Minimum libavb version:   1.0\n"
@@ -2140,10 +2120,9 @@ TEST_F(AvbSlotVerifyTest, OnlyLoadWhatHasBeenRequested) {
       "      Digest:                "
       "184cb36243adb8b87d2d8c4802de32125fe294ec46753d732144ee65df68a23d\n"
       "      Flags:                 0\n",
-      InfoImage(vbmeta_image_path_));
+      InfoImage(vbmeta_image_path_.string()));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"foo", NULL};
   EXPECT_EQ(AVB_SLOT_VERIFY_RESULT_OK,
@@ -2171,8 +2150,8 @@ TEST_F(AvbSlotVerifyTest, NoVBMetaPartitionFlag) {
   const size_t bar_partition_size = 32 * 1024 * 1024;
   const size_t foo_image_size = 5 * 1024 * 1024;
   const size_t bar_image_size = 10 * 1024 * 1024;
-  base::FilePath foo_path = GenerateImage("foo_a.img", foo_image_size);
-  base::FilePath bar_path = GenerateImage("bar_a.img", bar_image_size);
+  std::string foo_path = GenerateImage("foo_a.img", foo_image_size);
+  std::string bar_path = GenerateImage("bar_a.img", bar_image_size);
 
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hash_footer"
@@ -2186,7 +2165,7 @@ TEST_F(AvbSlotVerifyTest, NoVBMetaPartitionFlag) {
                  " --salt deadbeef"
                  " --key test/data/testkey_rsa4096.pem"
                  " --rollback_index 42",
-                 foo_path.value().c_str(),
+                 foo_path.c_str(),
                  foo_partition_size);
 
   EXPECT_COMMAND(0,
@@ -2201,17 +2180,13 @@ TEST_F(AvbSlotVerifyTest, NoVBMetaPartitionFlag) {
                  " --salt deadbeef"
                  " --key test/data/testkey_rsa2048.pem"
                  " --rollback_index 43",
-                 bar_path.value().c_str(),
+                 bar_path.c_str(),
                  bar_partition_size);
 
   ops_.set_expected_public_key_for_partition(
-      "foo_a",
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa4096.pem")),
-      1);
+      "foo_a", PublicKeyAVB("test/data/testkey_rsa4096.pem"), 1);
   ops_.set_expected_public_key_for_partition(
-      "bar_a",
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")),
-      2);
+      "bar_a", PublicKeyAVB("test/data/testkey_rsa2048.pem"), 2);
   ops_.set_stored_rollback_indexes({{0, 1000}, {1, 10}, {2, 11}});
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"foo", "bar", NULL};
@@ -2276,21 +2251,21 @@ TEST_F(AvbSlotVerifyTest, NoVBMetaPartitionFlag) {
 }
 
 TEST_F(AvbSlotVerifyTest, PublicKeyMetadata) {
-  base::FilePath md_path = GenerateImage("md.bin", 1536);
+  std::string md_path = GenerateImage("md.bin", 1536);
 
-  GenerateVBMetaImage("vbmeta_a.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
-                      base::StringPrintf("--public_key_metadata %s"
-                                         " --internal_release_string \"\"",
-                                         md_path.value().c_str()));
+  GenerateVBMetaImage(
+      "vbmeta_a.img",
+      "SHA256_RSA2048",
+      0,
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--public_key_metadata %s"
+                                  " --internal_release_string \"\"",
+                                  md_path.c_str()));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   std::string md_data;
-  ASSERT_TRUE(base::ReadFileToString(md_path, &md_data));
+  ASSERT_TRUE(android::base::ReadFileToString(md_path, &md_data));
   ops_.set_expected_public_key_metadata(md_data);
 
   AvbSlotVerifyData* slot_data = NULL;
@@ -2326,10 +2301,10 @@ void AvbSlotVerifyTest::CmdlineWithHashtreeVerification(
   rootfs.resize(rootfs_size);
   for (size_t n = 0; n < rootfs_size; n++)
     rootfs[n] = uint8_t(n);
-  base::FilePath rootfs_path = testdir_.Append("rootfs.bin");
+  std::filesystem::path rootfs_path = testdir_ / "rootfs.bin";
   EXPECT_EQ(rootfs_size,
             static_cast<const size_t>(
-                base::WriteFile(rootfs_path,
+                base::WriteFile(base::FilePath(rootfs_path.c_str()),
                                 reinterpret_cast<const char*>(rootfs.data()),
                                 rootfs.size())));
 
@@ -2340,7 +2315,7 @@ void AvbSlotVerifyTest::CmdlineWithHashtreeVerification(
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\" "
                  "--do_not_generate_fec",
-                 rootfs_path.value().c_str(),
+                 rootfs_path.c_str(),
                  (int)partition_size);
 
   // Check that we correctly generate dm-verity kernel cmdline
@@ -2349,19 +2324,19 @@ void AvbSlotVerifyTest::CmdlineWithHashtreeVerification(
       "vbmeta_a.img",
       "SHA256_RSA2048",
       4,
-      base::FilePath("test/data/testkey_rsa2048.pem"),
-      base::StringPrintf("--setup_rootfs_from_kernel %s "
-                         "--kernel_cmdline should_be_in_both=1 "
-                         "--algorithm SHA256_RSA2048 "
-                         "--flags %d "
-                         "--internal_release_string \"\"",
-                         rootfs_path.value().c_str(),
-                         hashtree_verification_on
-                             ? 0
-                             : AVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED));
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf(
+          "--setup_rootfs_from_kernel %s "
+          "--kernel_cmdline should_be_in_both=1 "
+          "--algorithm SHA256_RSA2048 "
+          "--flags %d "
+          "--internal_release_string \"\"",
+          rootfs_path.c_str(),
+          hashtree_verification_on ? 0
+                                   : AVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED));
 
   EXPECT_EQ(
-      base::StringPrintf(
+      android::base::StringPrintf(
           "Minimum libavb version:   1.0\n"
           "Header Block:             256 bytes\n"
           "Authentication Block:     320 bytes\n"
@@ -2389,10 +2364,9 @@ void AvbSlotVerifyTest::CmdlineWithHashtreeVerification(
           "      Kernel Cmdline:        'should_be_in_both=1'\n",
           hashtree_verification_on ? 0
                                    : AVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED),
-      InfoImage(vbmeta_image_path_));
+      InfoImage(vbmeta_image_path_.string()));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   // Check that avb_slot_verify() picks the cmdline decsriptors based
   // on their flags value.
@@ -2458,10 +2432,10 @@ void AvbSlotVerifyTest::CmdlineWithChainedHashtreeVerification(
   contents.resize(system_size);
   for (size_t n = 0; n < system_size; n++)
     contents[n] = uint8_t(n);
-  base::FilePath system_path = testdir_.Append("system_a.img");
+  std::filesystem::path system_path = testdir_ / "system_a.img";
   EXPECT_EQ(system_size,
             static_cast<const size_t>(
-                base::WriteFile(system_path,
+                base::WriteFile(base::FilePath(system_path.c_str()),
                                 reinterpret_cast<const char*>(contents.data()),
                                 contents.size())));
 
@@ -2475,7 +2449,7 @@ void AvbSlotVerifyTest::CmdlineWithChainedHashtreeVerification(
                  "--internal_release_string \"\" "
                  "--do_not_generate_fec "
                  "--setup_as_rootfs_from_kernel",
-                 system_path.value().c_str(),
+                 system_path.c_str(),
                  (int)system_partition_size);
 
   EXPECT_EQ(
@@ -2521,59 +2495,58 @@ void AvbSlotVerifyTest::CmdlineWithChainedHashtreeVerification(
       "      Flags:                 2\n"
       "      Kernel Cmdline:        "
       "'root=PARTUUID=$(ANDROID_SYSTEM_PARTUUID)'\n",
-      InfoImage(system_path));
+      InfoImage(system_path.string()));
 
-  base::FilePath pk_path = testdir_.Append("testkey_rsa2048.avbpubkey");
+  std::filesystem::path pk_path = testdir_ / "testkey_rsa2048.avbpubkey";
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa2048.pem"
       " --output %s",
-      pk_path.value().c_str());
+      pk_path.c_str());
 
   GenerateVBMetaImage(
       "vbmeta_a.img",
       "SHA256_RSA2048",
       4,
-      base::FilePath("test/data/testkey_rsa2048.pem"),
-      base::StringPrintf("--kernel_cmdline should_be_in_both=1 "
-                         "--algorithm SHA256_RSA2048 "
-                         "--flags %d "
-                         "--chain_partition system:1:%s "
-                         "--internal_release_string \"\"",
-                         hashtree_verification_on
-                             ? 0
-                             : AVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED,
-                         pk_path.value().c_str()));
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf(
+          "--kernel_cmdline should_be_in_both=1 "
+          "--algorithm SHA256_RSA2048 "
+          "--flags %d "
+          "--chain_partition system:1:%s "
+          "--internal_release_string \"\"",
+          hashtree_verification_on ? 0
+                                   : AVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED,
+          pk_path.c_str()));
 
   EXPECT_EQ(
-      base::StringPrintf("Minimum libavb version:   1.0\n"
-                         "Header Block:             256 bytes\n"
-                         "Authentication Block:     320 bytes\n"
-                         "Auxiliary Block:          1216 bytes\n"
-                         "Public key (sha1):        "
-                         "cdbb77177f731920bbe0a0f94f84d9038ae0617d\n"
-                         "Algorithm:                SHA256_RSA2048\n"
-                         "Rollback Index:           4\n"
-                         "Flags:                    %d\n"
-                         "Rollback Index Location:  0\n"
-                         "Release String:           ''\n"
-                         "Descriptors:\n"
-                         "    Chain Partition descriptor:\n"
-                         "      Partition Name:          system\n"
-                         "      Rollback Index Location: 1\n"
-                         "      Public key (sha1):       "
-                         "cdbb77177f731920bbe0a0f94f84d9038ae0617d\n"
-                         "      Flags:                   0\n"
-                         "    Kernel Cmdline descriptor:\n"
-                         "      Flags:                 0\n"
-                         "      Kernel Cmdline:        'should_be_in_both=1'\n",
-                         hashtree_verification_on
-                             ? 0
-                             : AVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED),
-      InfoImage(vbmeta_image_path_));
-
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+      android::base::StringPrintf(
+          "Minimum libavb version:   1.0\n"
+          "Header Block:             256 bytes\n"
+          "Authentication Block:     320 bytes\n"
+          "Auxiliary Block:          1216 bytes\n"
+          "Public key (sha1):        "
+          "cdbb77177f731920bbe0a0f94f84d9038ae0617d\n"
+          "Algorithm:                SHA256_RSA2048\n"
+          "Rollback Index:           4\n"
+          "Flags:                    %d\n"
+          "Rollback Index Location:  0\n"
+          "Release String:           ''\n"
+          "Descriptors:\n"
+          "    Chain Partition descriptor:\n"
+          "      Partition Name:          system\n"
+          "      Rollback Index Location: 1\n"
+          "      Public key (sha1):       "
+          "cdbb77177f731920bbe0a0f94f84d9038ae0617d\n"
+          "      Flags:                   0\n"
+          "    Kernel Cmdline descriptor:\n"
+          "      Flags:                 0\n"
+          "      Kernel Cmdline:        'should_be_in_both=1'\n",
+          hashtree_verification_on ? 0
+                                   : AVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED),
+      InfoImage(vbmeta_image_path_.string()));
+
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   // Check that avb_slot_verify() picks the cmdline descriptors based
   // on their flags value... note that these descriptors are in the
@@ -2641,9 +2614,9 @@ void AvbSlotVerifyTest::VerificationDisabled(bool use_avbctl,
   // Generate boot_a.img and dtbo_a.img since avb_slot_verify() will
   // attempt to load them upon encountering the VERIFICATION_DISABLED
   // flag.
-  base::FilePath boot_path = GenerateImage("boot_a.img", boot_part_size);
+  std::string boot_path = GenerateImage("boot_a.img", boot_part_size);
   const size_t DTBO_DATA_OFFSET = 42;
-  base::FilePath dtbo_path =
+  std::string dtbo_path =
       GenerateImage("dtbo_a.img", dtbo_part_size, DTBO_DATA_OFFSET);
 
   // Generate a 1028 KiB file with known content.
@@ -2651,10 +2624,10 @@ void AvbSlotVerifyTest::VerificationDisabled(bool use_avbctl,
   rootfs.resize(rootfs_size);
   for (size_t n = 0; n < rootfs_size; n++)
     rootfs[n] = uint8_t(n);
-  base::FilePath rootfs_path = testdir_.Append("rootfs.bin");
+  std::filesystem::path rootfs_path = testdir_ / "rootfs.bin";
   EXPECT_EQ(rootfs_size,
             static_cast<const size_t>(
-                base::WriteFile(rootfs_path,
+                base::WriteFile(base::FilePath(rootfs_path.c_str()),
                                 reinterpret_cast<const char*>(rootfs.data()),
                                 rootfs.size())));
 
@@ -2665,7 +2638,7 @@ void AvbSlotVerifyTest::VerificationDisabled(bool use_avbctl,
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\" "
                  "--do_not_generate_fec",
-                 rootfs_path.value().c_str(),
+                 rootfs_path.c_str(),
                  (int)partition_size);
 
   // Check that we correctly generate dm-verity kernel cmdline
@@ -2674,18 +2647,18 @@ void AvbSlotVerifyTest::VerificationDisabled(bool use_avbctl,
       "vbmeta_a.img",
       "SHA256_RSA2048",
       4,
-      base::FilePath("test/data/testkey_rsa2048.pem"),
-      base::StringPrintf(
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf(
           "--setup_rootfs_from_kernel %s "
           "--kernel_cmdline should_be_in_both=1 "
           "--algorithm SHA256_RSA2048 "
           "--flags %d "
           "--internal_release_string \"\"",
-          rootfs_path.value().c_str(),
+          rootfs_path.c_str(),
           use_avbctl ? 0 : AVB_VBMETA_IMAGE_FLAGS_VERIFICATION_DISABLED));
 
   EXPECT_EQ(
-      base::StringPrintf(
+      android::base::StringPrintf(
           "Minimum libavb version:   1.0\n"
           "Header Block:             256 bytes\n"
           "Authentication Block:     320 bytes\n"
@@ -2712,10 +2685,9 @@ void AvbSlotVerifyTest::VerificationDisabled(bool use_avbctl,
           "      Flags:                 0\n"
           "      Kernel Cmdline:        'should_be_in_both=1'\n",
           use_avbctl ? 0 : AVB_VBMETA_IMAGE_FLAGS_VERIFICATION_DISABLED),
-      InfoImage(vbmeta_image_path_));
+      InfoImage(vbmeta_image_path_.string()));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   if (!has_system_partition) {
     ops_.set_hidden_partitions({"system", "system_a", "system_b"});
@@ -2737,7 +2709,7 @@ void AvbSlotVerifyTest::VerificationDisabled(bool use_avbctl,
 
   if (preload_boot) {
     ops_.enable_get_preloaded_partition();
-    EXPECT_TRUE(ops_.preload_partition("boot_a", boot_path));
+    EXPECT_TRUE(ops_.preload_partition("boot_a", base::FilePath(boot_path)));
   }
 
   // Check that avb_slot_verify() doesn't return any of the
@@ -2841,10 +2813,10 @@ TEST_F(AvbSlotVerifyTest, NoVBMetaPartition) {
   const size_t foobar_part_size = 16 * MiB;
   const size_t bazboo_size = 4 * MiB;
   const size_t bazboo_part_size = 8 * MiB;
-  base::FilePath boot_path = GenerateImage("boot.img", boot_size);
-  base::FilePath system_path = GenerateImage("system.img", system_size);
-  base::FilePath foobar_path = GenerateImage("foobar.img", foobar_size);
-  base::FilePath bazboo_path = GenerateImage("bazboo.img", bazboo_size);
+  std::string boot_path = GenerateImage("boot.img", boot_size);
+  std::string system_path = GenerateImage("system.img", system_size);
+  std::string foobar_path = GenerateImage("foobar.img", foobar_size);
+  std::string bazboo_path = GenerateImage("bazboo.img", bazboo_size);
 
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer --salt d00df00d --image %s "
@@ -2853,7 +2825,7 @@ TEST_F(AvbSlotVerifyTest, NoVBMetaPartition) {
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\" "
                  "--do_not_generate_fec",
-                 system_path.value().c_str(),
+                 system_path.c_str(),
                  (int)system_part_size);
 
   EXPECT_COMMAND(0,
@@ -2863,7 +2835,7 @@ TEST_F(AvbSlotVerifyTest, NoVBMetaPartition) {
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\" "
                  "--do_not_generate_fec",
-                 foobar_path.value().c_str(),
+                 foobar_path.c_str(),
                  (int)foobar_part_size);
 
   EXPECT_COMMAND(0,
@@ -2873,15 +2845,15 @@ TEST_F(AvbSlotVerifyTest, NoVBMetaPartition) {
                  "--key test/data/testkey_rsa4096.pem "
                  "--internal_release_string \"\" "
                  "--do_not_generate_fec",
-                 bazboo_path.value().c_str(),
+                 bazboo_path.c_str(),
                  (int)bazboo_part_size);
 
-  base::FilePath pk_path = testdir_.Append("testkey_rsa4096.avbpubkey");
+  std::filesystem::path pk_path = testdir_ / "testkey_rsa4096.avbpubkey";
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa4096.pem"
       " --output %s",
-      pk_path.value().c_str());
+      pk_path.c_str());
 
   // Explicitly pass "--flags 2147483648" (i.e. 1<<31) to check that
   // boot.img is treated as top-level. Note the corresponding "Flags:"
@@ -2898,12 +2870,12 @@ TEST_F(AvbSlotVerifyTest, NoVBMetaPartition) {
                  "--setup_rootfs_from_kernel %s "
                  "--chain_partition bazboo:1:%s "
                  "--flags 2147483648",
-                 boot_path.value().c_str(),
+                 boot_path.c_str(),
                  (int)boot_part_size,
-                 system_path.value().c_str(),
-                 foobar_path.value().c_str(),
-                 system_path.value().c_str(),
-                 pk_path.value().c_str());
+                 system_path.c_str(),
+                 foobar_path.c_str(),
+                 system_path.c_str(),
+                 pk_path.c_str());
 
   ASSERT_EQ(
       "Footer version:           1.0\n"
@@ -2979,8 +2951,7 @@ TEST_F(AvbSlotVerifyTest, NoVBMetaPartition) {
       "      Flags:                 0\n",
       InfoImage(boot_path));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   // Now check that libavb will fall back to reading from 'boot'
   // instead of 'vbmeta' when encountering
@@ -3020,7 +2991,7 @@ TEST_F(AvbSlotVerifyTest, NoVBMetaPartition) {
 TEST_F(AvbSlotVerifyTest, ChainedPartitionEnforceFlagsZero) {
   size_t boot_partition_size = 16 * 1024 * 1024;
   const size_t boot_image_size = 5 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot_a.img", boot_image_size);
+  std::string boot_path = GenerateImage("boot_a.img", boot_image_size);
   const char* requested_partitions[] = {"boot", NULL};
 
   EXPECT_COMMAND(0,
@@ -3035,28 +3006,27 @@ TEST_F(AvbSlotVerifyTest, ChainedPartitionEnforceFlagsZero) {
                  " --salt deadbeef"
                  " --flags 1"
                  " --internal_release_string \"\"",
-                 boot_path.value().c_str(),
+                 boot_path.c_str(),
                  boot_partition_size);
 
-  base::FilePath pk_path = testdir_.Append("testkey_rsa4096.avbpubkey");
+  std::filesystem::path pk_path = testdir_ / "testkey_rsa4096.avbpubkey";
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa4096.pem"
       " --output %s",
-      pk_path.value().c_str());
+      pk_path.c_str());
 
   GenerateVBMetaImage(
       "vbmeta_a.img",
       "SHA256_RSA2048",
       11,
-      base::FilePath("test/data/testkey_rsa2048.pem"),
-      base::StringPrintf("--chain_partition boot:1:%s"
-                         " --kernel_cmdline 'cmdline2 in vbmeta'"
-                         " --internal_release_string \"\"",
-                         pk_path.value().c_str()));
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--chain_partition boot:1:%s"
+                                  " --kernel_cmdline 'cmdline2 in vbmeta'"
+                                  " --internal_release_string \"\"",
+                                  pk_path.c_str()));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   EXPECT_EQ(AVB_SLOT_VERIFY_RESULT_ERROR_INVALID_METADATA,
@@ -3074,15 +3044,15 @@ TEST_F(AvbSlotVerifyTest, ChainedPartitionEnforceFlagsZero) {
 TEST_F(AvbSlotVerifyTest, ChainedPartitionEnforceNoChainPartitions) {
   size_t boot_partition_size = 16 * 1024 * 1024;
   const size_t boot_image_size = 5 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot_a.img", boot_image_size);
+  std::string boot_path = GenerateImage("boot_a.img", boot_image_size);
   const char* requested_partitions[] = {"boot", NULL};
 
-  base::FilePath pk_path = testdir_.Append("testkey_rsa4096.avbpubkey");
+  std::filesystem::path pk_path = testdir_ / "testkey_rsa4096.avbpubkey";
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa4096.pem"
       " --output %s",
-      pk_path.value().c_str());
+      pk_path.c_str());
 
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hash_footer"
@@ -3096,22 +3066,21 @@ TEST_F(AvbSlotVerifyTest, ChainedPartitionEnforceNoChainPartitions) {
                  " --salt deadbeef"
                  " --chain_partition other:2:%s"
                  " --internal_release_string \"\"",
-                 boot_path.value().c_str(),
+                 boot_path.c_str(),
                  boot_partition_size,
-                 pk_path.value().c_str());
+                 pk_path.c_str());
 
   GenerateVBMetaImage(
       "vbmeta_a.img",
       "SHA256_RSA2048",
       11,
-      base::FilePath("test/data/testkey_rsa2048.pem"),
-      base::StringPrintf("--chain_partition boot:1:%s"
-                         " --kernel_cmdline 'cmdline2 in vbmeta'"
-                         " --internal_release_string \"\"",
-                         pk_path.value().c_str()));
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--chain_partition boot:1:%s"
+                                  " --kernel_cmdline 'cmdline2 in vbmeta'"
+                                  " --internal_release_string \"\"",
+                                  pk_path.c_str()));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   EXPECT_EQ(AVB_SLOT_VERIFY_RESULT_ERROR_INVALID_METADATA,
@@ -3128,7 +3097,7 @@ TEST_F(AvbSlotVerifyTest, HashtreeErrorModes) {
   const size_t MiB = 1024 * 1024;
   const size_t system_size = 16 * MiB;
   const size_t system_part_size = 32 * MiB;
-  base::FilePath system_path = GenerateImage("system.img", system_size);
+  std::string system_path = GenerateImage("system.img", system_size);
 
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer --salt d00df00d --image %s "
@@ -3137,21 +3106,21 @@ TEST_F(AvbSlotVerifyTest, HashtreeErrorModes) {
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\" "
                  "--do_not_generate_fec",
-                 system_path.value().c_str(),
+                 system_path.c_str(),
                  (int)system_part_size);
 
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
-                      base::StringPrintf("--setup_rootfs_from_kernel %s "
-                                         "--include_descriptors_from_image %s"
-                                         " --internal_release_string \"\"",
-                                         system_path.value().c_str(),
-                                         system_path.value().c_str()));
+  GenerateVBMetaImage(
+      "vbmeta.img",
+      "SHA256_RSA2048",
+      0,
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--setup_rootfs_from_kernel %s "
+                                  "--include_descriptors_from_image %s"
+                                  " --internal_release_string \"\"",
+                                  system_path.c_str(),
+                                  system_path.c_str()));
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"boot", NULL};
@@ -3287,16 +3256,17 @@ TEST_F(AvbSlotVerifyTest, HashtreeErrorModes) {
 
   // Check we'll get androidboot.veritymode=disabled for any
   // |hashtree_error_mode| if dm-verity is disabled.
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
-                      base::StringPrintf("--setup_rootfs_from_kernel %s "
-                                         "--include_descriptors_from_image %s "
-                                         "--set_hashtree_disabled_flag "
-                                         "--internal_release_string \"\"",
-                                         system_path.value().c_str(),
-                                         system_path.value().c_str()));
+  GenerateVBMetaImage(
+      "vbmeta.img",
+      "SHA256_RSA2048",
+      0,
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--setup_rootfs_from_kernel %s "
+                                  "--include_descriptors_from_image %s "
+                                  "--set_hashtree_disabled_flag "
+                                  "--internal_release_string \"\"",
+                                  system_path.c_str(),
+                                  system_path.c_str()));
   for (int n = 0; n < 4; n++) {
     AvbHashtreeErrorMode modes[4] = {
         AVB_HASHTREE_ERROR_MODE_RESTART_AND_INVALIDATE,
@@ -3331,8 +3301,7 @@ class AvbSlotVerifyTestWithPersistentDigest : public AvbSlotVerifyTest {
   void SetupWithHashDescriptor(bool do_not_use_ab = true) {
     const size_t factory_partition_size = 16 * 1024 * 1024;
     const size_t factory_image_size = 5 * 1024 * 1024;
-    base::FilePath factory_path =
-        GenerateImage("factory.img", factory_image_size);
+    std::string factory_path = GenerateImage("factory.img", factory_image_size);
 
     EXPECT_COMMAND(0,
                    "./avbtool.py add_hash_footer"
@@ -3342,7 +3311,7 @@ class AvbSlotVerifyTestWithPersistentDigest : public AvbSlotVerifyTest {
                    " --partition_size %zd"
                    " --internal_release_string \"\""
                    " --use_persistent_digest %s",
-                   factory_path.value().c_str(),
+                   factory_path.c_str(),
                    factory_partition_size,
                    do_not_use_ab ? "--do_not_use_ab" : "");
 
@@ -3350,42 +3319,41 @@ class AvbSlotVerifyTestWithPersistentDigest : public AvbSlotVerifyTest {
         "vbmeta_a.img",
         "SHA256_RSA2048",
         0,
-        base::FilePath("test/data/testkey_rsa2048.pem"),
-        base::StringPrintf("--internal_release_string \"\" "
-                           "--include_descriptors_from_image %s ",
-                           factory_path.value().c_str()));
-
-    EXPECT_EQ(base::StringPrintf("Minimum libavb version:   1.1\n"
-                                 "Header Block:             256 bytes\n"
-                                 "Authentication Block:     320 bytes\n"
-                                 "Auxiliary Block:          704 bytes\n"
-                                 "Public key (sha1):        "
-                                 "cdbb77177f731920bbe0a0f94f84d9038ae0617d\n"
-                                 "Algorithm:                SHA256_RSA2048\n"
-                                 "Rollback Index:           0\n"
-                                 "Flags:                    0\n"
-                                 "Rollback Index Location:  0\n"
-                                 "Release String:           ''\n"
-                                 "Descriptors:\n"
-                                 "    Hash descriptor:\n"
-                                 "      Image Size:            5242880 bytes\n"
-                                 "      Hash Algorithm:        sha256\n"
-                                 "      Partition Name:        factory\n"
-                                 "      Salt:                  \n"
-                                 "      Digest:                \n"
-                                 "      Flags:                 %d\n",
-                                 do_not_use_ab ? 1 : 0),
-              InfoImage(vbmeta_image_path_));
-
-    ops_.set_expected_public_key(
-        PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+        "test/data/testkey_rsa2048.pem",
+        android::base::StringPrintf("--internal_release_string \"\" "
+                                    "--include_descriptors_from_image %s ",
+                                    factory_path.c_str()));
+
+    EXPECT_EQ(android::base::StringPrintf(
+                  "Minimum libavb version:   1.1\n"
+                  "Header Block:             256 bytes\n"
+                  "Authentication Block:     320 bytes\n"
+                  "Auxiliary Block:          704 bytes\n"
+                  "Public key (sha1):        "
+                  "cdbb77177f731920bbe0a0f94f84d9038ae0617d\n"
+                  "Algorithm:                SHA256_RSA2048\n"
+                  "Rollback Index:           0\n"
+                  "Flags:                    0\n"
+                  "Rollback Index Location:  0\n"
+                  "Release String:           ''\n"
+                  "Descriptors:\n"
+                  "    Hash descriptor:\n"
+                  "      Image Size:            5242880 bytes\n"
+                  "      Hash Algorithm:        sha256\n"
+                  "      Partition Name:        factory\n"
+                  "      Salt:                  \n"
+                  "      Digest:                \n"
+                  "      Flags:                 %d\n",
+                  do_not_use_ab ? 1 : 0),
+              InfoImage(vbmeta_image_path_.string()));
+
+    ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
   }
 
   void SetupWithHashtreeDescriptor(bool do_not_use_ab = true) {
     const size_t factory_partition_size = 16 * 1024 * 1024;
     const size_t factory_image_size = 5 * 1024 * 1024;
-    base::FilePath factory_path =
-        GenerateImage("factory.img", factory_image_size);
+    std::string factory_path = GenerateImage("factory.img", factory_image_size);
 
     EXPECT_COMMAND(
         0,
@@ -3399,7 +3367,7 @@ class AvbSlotVerifyTestWithPersistentDigest : public AvbSlotVerifyTest {
         " --kernel_cmdline "
         "'androidboot.vbmeta.root_digest.factory=$(AVB_FACTORY_ROOT_DIGEST)'"
         " --use_persistent_digest %s",
-        factory_path.value().c_str(),
+        factory_path.c_str(),
         factory_partition_size,
         verity_hash_algorithm_.c_str(),
         do_not_use_ab ? "--do_not_use_ab" : "");
@@ -3408,55 +3376,55 @@ class AvbSlotVerifyTestWithPersistentDigest : public AvbSlotVerifyTest {
         "vbmeta_a.img",
         "SHA256_RSA2048",
         0,
-        base::FilePath("test/data/testkey_rsa2048.pem"),
-        base::StringPrintf("--internal_release_string \"\" "
-                           "--include_descriptors_from_image %s ",
-                           factory_path.value().c_str()));
+        "test/data/testkey_rsa2048.pem",
+        android::base::StringPrintf("--internal_release_string \"\" "
+                                    "--include_descriptors_from_image %s ",
+                                    factory_path.c_str()));
 
     int expected_tree_size =
         (verity_hash_algorithm_ == "sha512") ? 86016 : 45056;
     int expected_fec_offset =
         (verity_hash_algorithm_ == "sha512") ? 5328896 : 5287936;
-    EXPECT_EQ(base::StringPrintf("Minimum libavb version:   1.1\n"
-                                 "Header Block:             256 bytes\n"
-                                 "Authentication Block:     320 bytes\n"
-                                 "Auxiliary Block:          832 bytes\n"
-                                 "Public key (sha1):        "
-                                 "cdbb77177f731920bbe0a0f94f84d9038ae0617d\n"
-                                 "Algorithm:                SHA256_RSA2048\n"
-                                 "Rollback Index:           0\n"
-                                 "Flags:                    0\n"
-                                 "Rollback Index Location:  0\n"
-                                 "Release String:           ''\n"
-                                 "Descriptors:\n"
-                                 "    Kernel Cmdline descriptor:\n"
-                                 "      Flags:                 0\n"
-                                 "      Kernel Cmdline:        "
-                                 "'androidboot.vbmeta.root_digest.factory=$("
-                                 "AVB_FACTORY_ROOT_DIGEST)'\n"
-                                 "    Hashtree descriptor:\n"
-                                 "      Version of dm-verity:  1\n"
-                                 "      Image Size:            5242880 bytes\n"
-                                 "      Tree Offset:           5242880\n"
-                                 "      Tree Size:             %d bytes\n"
-                                 "      Data Block Size:       4096 bytes\n"
-                                 "      Hash Block Size:       4096 bytes\n"
-                                 "      FEC num roots:         2\n"
-                                 "      FEC offset:            %d\n"
-                                 "      FEC size:              49152 bytes\n"
-                                 "      Hash Algorithm:        %s\n"
-                                 "      Partition Name:        factory\n"
-                                 "      Salt:                  \n"
-                                 "      Root Digest:           \n"
-                                 "      Flags:                 %d\n",
-                                 expected_tree_size,
-                                 expected_fec_offset,
-                                 verity_hash_algorithm_.c_str(),
-                                 do_not_use_ab ? 1 : 0),
-              InfoImage(vbmeta_image_path_));
-
-    ops_.set_expected_public_key(
-        PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+    EXPECT_EQ(android::base::StringPrintf(
+                  "Minimum libavb version:   1.1\n"
+                  "Header Block:             256 bytes\n"
+                  "Authentication Block:     320 bytes\n"
+                  "Auxiliary Block:          832 bytes\n"
+                  "Public key (sha1):        "
+                  "cdbb77177f731920bbe0a0f94f84d9038ae0617d\n"
+                  "Algorithm:                SHA256_RSA2048\n"
+                  "Rollback Index:           0\n"
+                  "Flags:                    0\n"
+                  "Rollback Index Location:  0\n"
+                  "Release String:           ''\n"
+                  "Descriptors:\n"
+                  "    Kernel Cmdline descriptor:\n"
+                  "      Flags:                 0\n"
+                  "      Kernel Cmdline:        "
+                  "'androidboot.vbmeta.root_digest.factory=$("
+                  "AVB_FACTORY_ROOT_DIGEST)'\n"
+                  "    Hashtree descriptor:\n"
+                  "      Version of dm-verity:  1\n"
+                  "      Image Size:            5242880 bytes\n"
+                  "      Tree Offset:           5242880\n"
+                  "      Tree Size:             %d bytes\n"
+                  "      Data Block Size:       4096 bytes\n"
+                  "      Hash Block Size:       4096 bytes\n"
+                  "      FEC num roots:         2\n"
+                  "      FEC offset:            %d\n"
+                  "      FEC size:              49152 bytes\n"
+                  "      Hash Algorithm:        %s\n"
+                  "      Partition Name:        factory\n"
+                  "      Salt:                  \n"
+                  "      Root Digest:           \n"
+                  "      Flags:                 %d\n",
+                  expected_tree_size,
+                  expected_fec_offset,
+                  verity_hash_algorithm_.c_str(),
+                  do_not_use_ab ? 1 : 0),
+              InfoImage(vbmeta_image_path_.string()));
+
+    ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
   }
 
   void Verify(bool expect_success) {
@@ -3896,11 +3864,10 @@ TEST_F(AvbSlotVerifyTest, ManagedVerityMode) {
   GenerateVBMetaImage("vbmeta.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\"");
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
 
   AvbSlotVerifyData* slot_data = NULL;
   const char* requested_partitions[] = {"boot", NULL};
@@ -4014,7 +3981,7 @@ TEST_F(AvbSlotVerifyTest, ManagedVerityMode) {
   GenerateVBMetaImage("vbmeta.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\" --prop key:value");
 
   // run 7: Reboot again, but this time the OS changed underneath.. check
@@ -4058,11 +4025,10 @@ TEST_F(AvbSlotVerifyTest, NoSystemPartition) {
   GenerateVBMetaImage("vbmeta_a.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\"");
 
-  ops_.set_expected_public_key(
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem")));
+  ops_.set_expected_public_key(PublicKeyAVB("test/data/testkey_rsa2048.pem"));
   ops_.set_hidden_partitions({"system_a"});
 
   AvbSlotVerifyData* slot_data = NULL;
diff --git a/test/avb_unittest_util.cc b/test/avb_unittest_util.cc
index f59458a..fa8de93 100644
--- a/test/avb_unittest_util.cc
+++ b/test/avb_unittest_util.cc
@@ -58,7 +58,7 @@ void BaseAvbToolTest::SetUp() {
   base::FilePath ret;
   char* buf = strdup("/tmp/libavb-tests.XXXXXX");
   ASSERT_TRUE(mkdtemp(buf) != nullptr);
-  testdir_ = base::FilePath(buf);
+  testdir_ = buf;
   free(buf);
 
   /* Reset memory leak tracing */
@@ -67,25 +67,27 @@ void BaseAvbToolTest::SetUp() {
 
 void BaseAvbToolTest::TearDown() {
   /* Nuke temporary directory. */
-  ASSERT_EQ(0U, testdir_.value().find("/tmp/libavb-tests"));
-  ASSERT_TRUE(base::DeleteFile(testdir_, true /* recursive */));
+  ASSERT_EQ(0U, testdir_.string().find("/tmp/libavb-tests"));
+  ASSERT_TRUE(
+      base::DeleteFile(base::FilePath(testdir_.c_str()), true /* recursive */));
   /* Ensure all memory has been freed. */
   EXPECT_TRUE(avb::testing_memory_all_freed());
 }
 
 std::string BaseAvbToolTest::CalcVBMetaDigest(const std::string& vbmeta_image,
                                               const std::string& digest_alg) {
-  base::FilePath vbmeta_path = testdir_.Append(vbmeta_image);
-  base::FilePath vbmeta_digest_path = testdir_.Append("vbmeta_digest");
+  std::filesystem::path vbmeta_path = testdir_ / vbmeta_image;
+  std::filesystem::path vbmeta_digest_path = testdir_ / "vbmeta_digest";
   EXPECT_COMMAND(
       0,
       "./avbtool.py calculate_vbmeta_digest --image %s --hash_algorithm %s"
       " --output %s",
-      vbmeta_path.value().c_str(),
+      vbmeta_path.c_str(),
       digest_alg.c_str(),
-      vbmeta_digest_path.value().c_str());
+      vbmeta_digest_path.c_str());
   std::string vbmeta_digest_data;
-  EXPECT_TRUE(base::ReadFileToString(vbmeta_digest_path, &vbmeta_digest_data));
+  EXPECT_TRUE(android::base::ReadFileToString(vbmeta_digest_path.string(),
+                                              &vbmeta_digest_data));
   return string_trim(vbmeta_digest_data);
 }
 
@@ -93,16 +95,16 @@ void BaseAvbToolTest::GenerateVBMetaImage(
     const std::string& image_name,
     const std::string& algorithm,
     uint64_t rollback_index,
-    const base::FilePath& key_path,
+    const std::string& key_path,
     const std::string& additional_options) {
   std::string signing_options;
   if (algorithm == "") {
     signing_options = " --algorithm NONE ";
   } else {
-    signing_options = std::string(" --algorithm ") + algorithm + " --key " +
-                      key_path.value() + " ";
+    signing_options =
+        std::string(" --algorithm ") + algorithm + " --key " + key_path + " ";
   }
-  vbmeta_image_path_ = testdir_.Append(image_name);
+  vbmeta_image_path_ = testdir_ / image_name;
   EXPECT_COMMAND(0,
                  "./avbtool.py make_vbmeta_image"
                  " --rollback_index %" PRIu64
@@ -111,11 +113,12 @@ void BaseAvbToolTest::GenerateVBMetaImage(
                  rollback_index,
                  additional_options.c_str(),
                  signing_options.c_str(),
-                 vbmeta_image_path_.value().c_str());
+                 vbmeta_image_path_.c_str());
   int64_t file_size;
-  ASSERT_TRUE(base::GetFileSize(vbmeta_image_path_, &file_size));
+  ASSERT_TRUE(base::GetFileSize(base::FilePath(vbmeta_image_path_.c_str()),
+                                &file_size));
   vbmeta_image_.resize(file_size);
-  ASSERT_TRUE(base::ReadFile(vbmeta_image_path_,
+  ASSERT_TRUE(base::ReadFile(base::FilePath(vbmeta_image_path_.c_str()),
                              reinterpret_cast<char*>(vbmeta_image_.data()),
                              vbmeta_image_.size()));
 }
@@ -123,10 +126,10 @@ void BaseAvbToolTest::GenerateVBMetaImage(
 /* Generate a file with name |file_name| of size |image_size| with
  * known content (0x00 0x01 0x02 .. 0xff 0x00 0x01 ..).
  */
-base::FilePath BaseAvbToolTest::GenerateImage(const std::string file_name,
-                                              size_t image_size,
-                                              uint8_t start_byte) {
-  base::FilePath image_path = testdir_.Append(file_name);
+std::string BaseAvbToolTest::GenerateImage(const std::string file_name,
+                                           size_t image_size,
+                                           uint8_t start_byte) {
+  std::filesystem::path image_path = testdir_ / file_name;
   EXPECT_COMMAND(0,
                  "./avbtool.py generate_test_image "
                  "--image_size %d "
@@ -134,33 +137,33 @@ base::FilePath BaseAvbToolTest::GenerateImage(const std::string file_name,
                  "--output %s",
                  image_size,
                  start_byte,
-                 image_path.value().c_str());
+                 image_path.c_str());
   base::File::Info stats;
-  EXPECT_TRUE(base::GetFileInfo(image_path, &stats));
+  EXPECT_TRUE(base::GetFileInfo(base::FilePath(image_path.c_str()), &stats));
   EXPECT_EQ((size_t)stats.size, image_size);
-  return image_path;
+  return image_path.string();
 }
 
-std::string BaseAvbToolTest::InfoImage(const base::FilePath& image_path) {
-  base::FilePath tmp_path = testdir_.Append("info_output.txt");
+std::string BaseAvbToolTest::InfoImage(const std::string& image_path) {
+  std::filesystem::path tmp_path = testdir_ / "info_output.txt";
   EXPECT_COMMAND(0,
                  "./avbtool.py info_image --image %s --output %s",
-                 image_path.value().c_str(),
-                 tmp_path.value().c_str());
+                 image_path.c_str(),
+                 tmp_path.c_str());
   std::string info_data;
-  EXPECT_TRUE(base::ReadFileToString(tmp_path, &info_data));
+  EXPECT_TRUE(android::base::ReadFileToString(tmp_path.string(), &info_data));
   return info_data;
 }
 
-std::string BaseAvbToolTest::PublicKeyAVB(const base::FilePath& key_path) {
-  base::FilePath tmp_path = testdir_.Append("public_key.bin");
+std::string BaseAvbToolTest::PublicKeyAVB(const std::string& key_path) {
+  std::filesystem::path tmp_path = testdir_ / "public_key.bin";
   EXPECT_COMMAND(0,
                  "./avbtool.py extract_public_key --key %s"
                  " --output %s",
-                 key_path.value().c_str(),
-                 tmp_path.value().c_str());
+                 key_path.c_str(),
+                 tmp_path.c_str());
   std::string key_data;
-  EXPECT_TRUE(base::ReadFileToString(tmp_path, &key_data));
+  EXPECT_TRUE(android::base::ReadFileToString(tmp_path.string(), &key_data));
   return key_data;
 }
 
diff --git a/test/avb_unittest_util.h b/test/avb_unittest_util.h
index e14e6a7..781877a 100644
--- a/test/avb_unittest_util.h
+++ b/test/avb_unittest_util.h
@@ -25,12 +25,12 @@
 #ifndef AVB_UNITTEST_UTIL_H_
 #define AVB_UNITTEST_UTIL_H_
 
-#include <inttypes.h>
-
+#include <android-base/stringprintf.h>
+#include <base/files/file_util.h>
 #include <gtest/gtest.h>
+#include <inttypes.h>
 
-#include <base/files/file_util.h>
-#include <base/strings/stringprintf.h>
+#include <filesystem>
 
 // Encodes |len| bytes of |data| as a lower-case hex-string.
 std::string mem_to_hexstring(const uint8_t* data, size_t len);
@@ -42,12 +42,12 @@ std::string string_trim(const std::string& str);
  * |command_format| using the system(3) utility function. Will assert unless
  * the command exits normally with exit status |expected_exit_status|.
  */
-#define EXPECT_COMMAND(expected_exit_status, command_format, ...)          \
-  do {                                                                     \
-    int rc =                                                               \
-        system(base::StringPrintf(command_format, ##__VA_ARGS__).c_str()); \
-    EXPECT_TRUE(WIFEXITED(rc));                                            \
-    EXPECT_EQ(WEXITSTATUS(rc), expected_exit_status);                      \
+#define EXPECT_COMMAND(expected_exit_status, command_format, ...)            \
+  do {                                                                       \
+    int rc = system(                                                         \
+        android::base::StringPrintf(command_format, ##__VA_ARGS__).c_str()); \
+    EXPECT_TRUE(WIFEXITED(rc));                                              \
+    EXPECT_EQ(WEXITSTATUS(rc), expected_exit_status);                        \
   } while (0);
 
 namespace avb {
@@ -77,30 +77,30 @@ class BaseAvbToolTest : public ::testing::Test {
   void GenerateVBMetaImage(const std::string& image_name,
                            const std::string& algorithm,
                            uint64_t rollback_index,
-                           const base::FilePath& key_path,
+                           const std::string& key_path,
                            const std::string& additional_options = "");
 
   /* Generate a file with name |file_name| of size |image_size| with
    * known content (0x00 0x01 0x02 .. 0xff 0x00 0x01 ..).
    */
-  base::FilePath GenerateImage(const std::string file_name,
-                               size_t image_size,
-                               uint8_t start_byte = 0);
+  std::string GenerateImage(const std::string file_name,
+                            size_t image_size,
+                            uint8_t start_byte = 0);
 
   /* Returns the output of 'avbtool info_image' for a given image. */
-  std::string InfoImage(const base::FilePath& image_path);
+  std::string InfoImage(const std::string& image_path);
 
   /* Returns public key in AVB format for a .pem key */
-  std::string PublicKeyAVB(const base::FilePath& key_path);
+  std::string PublicKeyAVB(const std::string& key_path);
 
   void SetUp() override;
   void TearDown() override;
 
   /* Temporary directory created in SetUp(). */
-  base::FilePath testdir_;
+  std::filesystem::path testdir_;
 
   /* Path to vbmeta image generated with GenerateVBMetaImage(). */
-  base::FilePath vbmeta_image_path_;
+  std::filesystem::path vbmeta_image_path_;
 
   /* Contents of the image generated with GenerateVBMetaImage(). */
   std::vector<uint8_t> vbmeta_image_;
diff --git a/test/avb_vbmeta_image_unittest.cc b/test/avb_vbmeta_image_unittest.cc
index 9343eaf..167dd78 100644
--- a/test/avb_vbmeta_image_unittest.cc
+++ b/test/avb_vbmeta_image_unittest.cc
@@ -22,17 +22,14 @@
  * SOFTWARE.
  */
 
-#include <iostream>
-
+#include <base/files/file_util.h>
+#include <base/strings/string_util.h>
 #include <endian.h>
 #include <inttypes.h>
+#include <libavb/libavb.h>
 #include <string.h>
 
-#include <base/files/file_util.h>
-#include <base/strings/string_util.h>
-#include <base/strings/stringprintf.h>
-
-#include <libavb/libavb.h>
+#include <iostream>
 
 #include "avb_unittest_util.h"
 
@@ -57,77 +54,63 @@ TEST_F(VerifyTest, BootImageStructSize) {
 }
 
 TEST_F(VerifyTest, CheckSHA256RSA2048) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
   EXPECT_EQ(AVB_VBMETA_VERIFY_RESULT_OK,
             avb_vbmeta_image_verify(
                 vbmeta_image_.data(), vbmeta_image_.size(), NULL, NULL));
 }
 
 TEST_F(VerifyTest, CheckSHA256RSA4096) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA4096",
-                      0,
-                      base::FilePath("test/data/testkey_rsa4096.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA4096", 0, "test/data/testkey_rsa4096.pem");
   EXPECT_EQ(AVB_VBMETA_VERIFY_RESULT_OK,
             avb_vbmeta_image_verify(
                 vbmeta_image_.data(), vbmeta_image_.size(), NULL, NULL));
 }
 
 TEST_F(VerifyTest, CheckSHA256RSA8192) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA8192",
-                      0,
-                      base::FilePath("test/data/testkey_rsa8192.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA8192", 0, "test/data/testkey_rsa8192.pem");
   EXPECT_EQ(AVB_VBMETA_VERIFY_RESULT_OK,
             avb_vbmeta_image_verify(
                 vbmeta_image_.data(), vbmeta_image_.size(), NULL, NULL));
 }
 
 TEST_F(VerifyTest, CheckSHA512RSA2048) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA512_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA512_RSA2048", 0, "test/data/testkey_rsa2048.pem");
   EXPECT_EQ(AVB_VBMETA_VERIFY_RESULT_OK,
             avb_vbmeta_image_verify(
                 vbmeta_image_.data(), vbmeta_image_.size(), NULL, NULL));
 }
 
 TEST_F(VerifyTest, CheckSHA512RSA4096) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA512_RSA4096",
-                      0,
-                      base::FilePath("test/data/testkey_rsa4096.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA512_RSA4096", 0, "test/data/testkey_rsa4096.pem");
   EXPECT_EQ(AVB_VBMETA_VERIFY_RESULT_OK,
             avb_vbmeta_image_verify(
                 vbmeta_image_.data(), vbmeta_image_.size(), NULL, NULL));
 }
 
 TEST_F(VerifyTest, CheckSHA512RSA8192) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA512_RSA8192",
-                      0,
-                      base::FilePath("test/data/testkey_rsa8192.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA512_RSA8192", 0, "test/data/testkey_rsa8192.pem");
   EXPECT_EQ(AVB_VBMETA_VERIFY_RESULT_OK,
             avb_vbmeta_image_verify(
                 vbmeta_image_.data(), vbmeta_image_.size(), NULL, NULL));
 }
 
 TEST_F(VerifyTest, CheckUnsigned) {
-  GenerateVBMetaImage("vbmeta.img", "", 0, base::FilePath(""));
+  GenerateVBMetaImage("vbmeta.img", "", 0, "");
   EXPECT_EQ(AVB_VBMETA_VERIFY_RESULT_OK_NOT_SIGNED,
             avb_vbmeta_image_verify(
                 vbmeta_image_.data(), vbmeta_image_.size(), NULL, NULL));
 }
 
 TEST_F(VerifyTest, CheckBiggerLength) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
   // Check that it's OK if we pass a bigger length than what the
   // header indicates.
   EXPECT_EQ(AVB_VBMETA_VERIFY_RESULT_OK,
@@ -136,10 +119,8 @@ TEST_F(VerifyTest, CheckBiggerLength) {
 }
 
 TEST_F(VerifyTest, BadMagic) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
   vbmeta_image_[0] = 'Z';
   EXPECT_EQ(AVB_VBMETA_VERIFY_RESULT_INVALID_VBMETA_HEADER,
             avb_vbmeta_image_verify(
@@ -147,10 +128,8 @@ TEST_F(VerifyTest, BadMagic) {
 }
 
 TEST_F(VerifyTest, MajorVersionCheck) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
 
   // Bail if it's a different major version.
   AvbVBMetaImageHeader* h =
@@ -162,7 +141,7 @@ TEST_F(VerifyTest, MajorVersionCheck) {
 }
 
 TEST_F(VerifyTest, MinorVersionCheck) {
-  GenerateVBMetaImage("vbmeta.img", "", 0, base::FilePath(""));
+  GenerateVBMetaImage("vbmeta.img", "", 0, "");
 
   // Bail if required_libavb_version_minor exceeds our libavb version.
   AvbVBMetaImageHeader* h =
@@ -174,7 +153,7 @@ TEST_F(VerifyTest, MinorVersionCheck) {
 }
 
 TEST_F(VerifyTest, NulTerminatedReleaseString) {
-  GenerateVBMetaImage("vbmeta.img", "", 0, base::FilePath(""));
+  GenerateVBMetaImage("vbmeta.img", "", 0, "");
 
   // Bail if |release_string| isn't NUL-terminated.
   AvbVBMetaImageHeader* h =
@@ -188,10 +167,8 @@ TEST_F(VerifyTest, NulTerminatedReleaseString) {
 }
 
 TEST_F(VerifyTest, BlockSizesAddUpToLessThanLength) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
 
   AvbVBMetaImageHeader* h =
       reinterpret_cast<AvbVBMetaImageHeader*>(vbmeta_image_.data());
@@ -236,10 +213,8 @@ TEST_F(VerifyTest, BlockSizesAddUpToLessThanLength) {
 }
 
 TEST_F(VerifyTest, BlockSizesMultipleOf64) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
 
   AvbVBMetaImageHeader* h =
       reinterpret_cast<AvbVBMetaImageHeader*>(vbmeta_image_.data());
@@ -265,10 +240,8 @@ TEST_F(VerifyTest, BlockSizesMultipleOf64) {
 }
 
 TEST_F(VerifyTest, HashOutOfBounds) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
 
   AvbVBMetaImageHeader* h =
       reinterpret_cast<AvbVBMetaImageHeader*>(vbmeta_image_.data());
@@ -289,10 +262,8 @@ TEST_F(VerifyTest, HashOutOfBounds) {
 }
 
 TEST_F(VerifyTest, SignatureOutOfBounds) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
 
   AvbVBMetaImageHeader* h =
       reinterpret_cast<AvbVBMetaImageHeader*>(vbmeta_image_.data());
@@ -313,10 +284,8 @@ TEST_F(VerifyTest, SignatureOutOfBounds) {
 }
 
 TEST_F(VerifyTest, PublicKeyOutOfBounds) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
 
   AvbVBMetaImageHeader* h =
       reinterpret_cast<AvbVBMetaImageHeader*>(vbmeta_image_.data());
@@ -337,10 +306,8 @@ TEST_F(VerifyTest, PublicKeyOutOfBounds) {
 }
 
 TEST_F(VerifyTest, PublicKeyMetadataOutOfBounds) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
 
   AvbVBMetaImageHeader* h =
       reinterpret_cast<AvbVBMetaImageHeader*>(vbmeta_image_.data());
@@ -361,10 +328,8 @@ TEST_F(VerifyTest, PublicKeyMetadataOutOfBounds) {
 }
 
 TEST_F(VerifyTest, InvalidAlgorithmField) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
 
   AvbVBMetaImageHeader* h =
       reinterpret_cast<AvbVBMetaImageHeader*>(vbmeta_image_.data());
@@ -382,10 +347,8 @@ TEST_F(VerifyTest, InvalidAlgorithmField) {
 }
 
 TEST_F(VerifyTest, PublicKeyBlockTooSmall) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
 
   AvbVBMetaImageHeader* h =
       reinterpret_cast<AvbVBMetaImageHeader*>(vbmeta_image_.data());
@@ -434,10 +397,8 @@ bool VerifyTest::test_modification(AvbVBMetaVerifyResult expected_result,
 }
 
 TEST_F(VerifyTest, ModificationDetection) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
 
   EXPECT_EQ(AVB_VBMETA_VERIFY_RESULT_OK,
             avb_vbmeta_image_verify(
diff --git a/test/avbtool_unittest.cc b/test/avbtool_unittest.cc
index 96e68e2..e1d14d8 100644
--- a/test/avbtool_unittest.cc
+++ b/test/avbtool_unittest.cc
@@ -22,19 +22,18 @@
  * SOFTWARE.
  */
 
-#include <iostream>
-
-#include <endian.h>
-#include <inttypes.h>
-#include <string.h>
-
+#include <android-base/file.h>
+#include <android-base/stringprintf.h>
 #include <base/files/file_util.h>
 #include <base/strings/string_split.h>
 #include <base/strings/string_util.h>
-#include <base/strings/stringprintf.h>
-
+#include <endian.h>
+#include <inttypes.h>
 #include <libavb/avb_sha.h>
 #include <libavb/libavb.h>
+#include <string.h>
+
+#include <iostream>
 
 #include "avb_unittest_util.h"
 #include "fake_avb_ops.h"
@@ -56,7 +55,7 @@ class AvbToolTest : public BaseAvbToolTest {
   void CreateRootfsWithHashtreeFooter(bool sparse_image,
                                       const std::string& hash_algorithm,
                                       const std::string& root_digest,
-                                      base::FilePath* rootfs_path);
+                                      std::filesystem::path* rootfs_path);
   void AddHashtreeFooterTest(bool sparse_image);
   void AddHashtreeFooterFECTest(bool sparse_image);
 
@@ -68,10 +67,10 @@ class AvbToolTest : public BaseAvbToolTest {
 // This test ensure that the version is increased in both
 // avb_boot_image.h and the avb tool.
 TEST_F(AvbToolTest, AvbVersionInSync) {
-  base::FilePath path = testdir_.Append("version.txt");
-  EXPECT_COMMAND(0, "./avbtool.py version > %s", path.value().c_str());
+  std::filesystem::path path = testdir_ / "version.txt";
+  EXPECT_COMMAND(0, "./avbtool.py version > %s", path.c_str());
   std::string printed_version;
-  ASSERT_TRUE(base::ReadFileToString(path, &printed_version));
+  ASSERT_TRUE(android::base::ReadFileToString(path.string(), &printed_version));
   base::TrimWhitespaceASCII(printed_version, base::TRIM_ALL, &printed_version);
   // See comments in libavb/avb_version.c and avbtool's get_release_string()
   // about being in sync.
@@ -80,10 +79,8 @@ TEST_F(AvbToolTest, AvbVersionInSync) {
 }
 
 TEST_F(AvbToolTest, DefaultReleaseString) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
 
   // Default release string is "avbtool " + avb_version_string().
   AvbVBMetaImageHeader h;
@@ -97,7 +94,7 @@ TEST_F(AvbToolTest, ReleaseStringAppend) {
   GenerateVBMetaImage("vbmeta.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--append_to_release_string \"Woot XYZ\"");
 
   // Note that avbtool inserts the space by itself.
@@ -123,7 +120,7 @@ TEST_F(AvbToolTest, ReleaseStringAppendTruncated) {
       "vbmeta.img",
       "SHA256_RSA2048",
       0,
-      base::FilePath("test/data/testkey_rsa2048.pem"),
+      "test/data/testkey_rsa2048.pem",
       std::string("--append_to_release_string \"") + append_str + "\"");
 
   // This checks that it ends with a NUL byte.
@@ -142,11 +139,10 @@ TEST_F(AvbToolTest, ExtractPublicKey) {
   GenerateVBMetaImage("vbmeta.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\"");
 
-  std::string key_data =
-      PublicKeyAVB(base::FilePath("test/data/testkey_rsa2048.pem"));
+  std::string key_data = PublicKeyAVB("test/data/testkey_rsa2048.pem");
 
   AvbVBMetaImageHeader h;
   avb_vbmeta_image_header_to_host_byte_order(
@@ -165,7 +161,7 @@ TEST_F(AvbToolTest, CheckDescriptors) {
   GenerateVBMetaImage("vbmeta.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--prop foo:brillo "
                       "--prop bar:chromeos "
                       "--prop prisoner:24601 "
@@ -271,20 +267,22 @@ TEST_F(AvbToolTest, Padding) {
   GenerateVBMetaImage("vbmeta.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\"");
 
   GenerateVBMetaImage("vbmeta_padded.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\" --padding_size 4096");
 
-  base::FilePath vbmeta_path = testdir_.Append("vbmeta.img");
-  base::FilePath vbmeta_padded_path = testdir_.Append("vbmeta_padded.img");
+  std::filesystem::path vbmeta_path = testdir_ / "vbmeta.img";
+  std::filesystem::path vbmeta_padded_path = testdir_ / "vbmeta_padded.img";
   int64_t vbmeta_size, vbmeta_padded_size;
-  ASSERT_TRUE(base::GetFileSize(vbmeta_path, &vbmeta_size));
-  ASSERT_TRUE(base::GetFileSize(vbmeta_padded_path, &vbmeta_padded_size));
+  ASSERT_TRUE(
+      base::GetFileSize(base::FilePath(vbmeta_path.c_str()), &vbmeta_size));
+  ASSERT_TRUE(base::GetFileSize(base::FilePath(vbmeta_padded_path.c_str()),
+                                &vbmeta_padded_size));
 
   EXPECT_NE(vbmeta_size, vbmeta_padded_size);
 
@@ -301,7 +299,7 @@ TEST_F(AvbToolTest, CheckRollbackIndex) {
   GenerateVBMetaImage("vbmeta.img",
                       "SHA256_RSA2048",
                       rollback_index,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\"");
 
   AvbVBMetaImageHeader h;
@@ -317,7 +315,7 @@ TEST_F(AvbToolTest, CheckRollbackIndexLocationOmitted) {
   GenerateVBMetaImage("vbmeta.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\"");
 
   AvbVBMetaImageHeader h;
@@ -331,12 +329,13 @@ TEST_F(AvbToolTest, CheckRollbackIndexLocationOmitted) {
 
 TEST_F(AvbToolTest, CheckRollbackIndexLocation) {
   uint32_t rollback_index_location = 42;
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
-                      base::StringPrintf("--rollback_index_location %d",
-                                         rollback_index_location));
+  GenerateVBMetaImage(
+      "vbmeta.img",
+      "SHA256_RSA2048",
+      0,
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--rollback_index_location %d",
+                                  rollback_index_location));
 
   AvbVBMetaImageHeader h;
   avb_vbmeta_image_header_to_host_byte_order(
@@ -351,7 +350,7 @@ TEST_F(AvbToolTest, CheckPubkeyReturned) {
   GenerateVBMetaImage("vbmeta.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--internal_release_string \"\"");
 
   const uint8_t* pubkey = NULL;
@@ -378,7 +377,7 @@ TEST_F(AvbToolTest, Info) {
   GenerateVBMetaImage("vbmeta.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       "--prop foo:brillo "
                       "--prop bar:chromeos "
                       "--prop prisoner:24601 "
@@ -414,7 +413,7 @@ TEST_F(AvbToolTest, Info) {
       "    Prop: blob -> '\\x00\\x00brillo "
       "ftw!\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\n'\n"
       "    Prop: large_blob -> (2048 bytes)\n",
-      InfoImage(vbmeta_image_path_));
+      InfoImage(vbmeta_image_path_.string()));
 }
 
 static bool collect_descriptors(const AvbDescriptor* descriptor,
@@ -427,7 +426,7 @@ static bool collect_descriptors(const AvbDescriptor* descriptor,
 
 static std::string AddHashFooterGetExpectedVBMetaInfo(
     const bool sparse_image, const uint64_t partition_size) {
-  return base::StringPrintf(
+  return android::base::StringPrintf(
       "Footer version:           1.0\n"
       "Image size:               %" PRIu64
       " bytes\n"
@@ -477,26 +476,22 @@ void AvbToolTest::AddHashFooterTest(bool sparse_image) {
       rootfs[n] = uint8_t(n);
     }
   }
-  base::FilePath external_vbmeta_path = testdir_.Append("external_vbmeta.bin");
-  base::FilePath extracted_vbmeta_path =
-      testdir_.Append("extracted_vbmeta.bin");
-  base::FilePath rootfs_path = testdir_.Append("rootfs.bin");
+  std::filesystem::path external_vbmeta_path = testdir_ / "external_vbmeta.bin";
+  std::filesystem::path extracted_vbmeta_path =
+      testdir_ / "extracted_vbmeta.bin";
+  std::filesystem::path rootfs_path = testdir_ / "rootfs.bin";
   EXPECT_EQ(rootfs_size,
             static_cast<const size_t>(
-                base::WriteFile(rootfs_path,
+                base::WriteFile(base::FilePath(rootfs_path.c_str()),
                                 reinterpret_cast<const char*>(rootfs.data()),
                                 rootfs.size())));
 
   if (sparse_image) {
-    EXPECT_COMMAND(0,
-                   "mv %s %s.unsparse",
-                   rootfs_path.value().c_str(),
-                   rootfs_path.value().c_str());
-    EXPECT_COMMAND(0,
-                   "img2simg %s.unsparse %s",
-                   rootfs_path.value().c_str(),
-                   rootfs_path.value().c_str());
-    EXPECT_COMMAND(0, "rm -f %s.unsparse", rootfs_path.value().c_str());
+    EXPECT_COMMAND(
+        0, "mv %s %s.unsparse", rootfs_path.c_str(), rootfs_path.c_str());
+    EXPECT_COMMAND(
+        0, "img2simg %s.unsparse %s", rootfs_path.c_str(), rootfs_path.c_str());
+    EXPECT_COMMAND(0, "rm -f %s.unsparse", rootfs_path.c_str());
   }
 
   /* Do this twice to check that 'add_hash_footer' is idempotent. */
@@ -509,12 +504,12 @@ void AvbToolTest::AddHashFooterTest(bool sparse_image) {
                    "--key test/data/testkey_rsa2048.pem "
                    "--output_vbmeta %s "
                    "--internal_release_string \"\"",
-                   rootfs_path.value().c_str(),
+                   rootfs_path.c_str(),
                    (int)partition_size,
-                   external_vbmeta_path.value().c_str());
+                   external_vbmeta_path.c_str());
 
     ASSERT_EQ(AddHashFooterGetExpectedVBMetaInfo(sparse_image, partition_size),
-              InfoImage(rootfs_path));
+              InfoImage(rootfs_path.string()));
 
     ASSERT_EQ(
         "Minimum libavb version:   1.0\n"
@@ -537,18 +532,18 @@ void AvbToolTest::AddHashFooterTest(bool sparse_image) {
         "9a58cc996d405e08a1e00f96dbfe9104fedf41cb83b1f"
         "5e4ed357fbcf58d88d9\n"
         "      Flags:                 0\n",
-        InfoImage(external_vbmeta_path));
+        InfoImage(external_vbmeta_path.string()));
 
     // Check that the extracted vbmeta matches the externally generally one.
     EXPECT_COMMAND(0,
                    "./avbtool.py extract_vbmeta_image --image %s "
                    "--output %s",
-                   rootfs_path.value().c_str(),
-                   extracted_vbmeta_path.value().c_str());
+                   rootfs_path.c_str(),
+                   extracted_vbmeta_path.c_str());
     EXPECT_COMMAND(0,
                    "diff %s %s",
-                   external_vbmeta_path.value().c_str(),
-                   extracted_vbmeta_path.value().c_str());
+                   external_vbmeta_path.c_str(),
+                   extracted_vbmeta_path.c_str());
   }
 
   // Resize the image and check that the only thing that has changed
@@ -559,27 +554,23 @@ void AvbToolTest::AddHashFooterTest(bool sparse_image) {
   EXPECT_COMMAND(1,
                  "./avbtool.py resize_image --image %s "
                  "--partition_size %d",
-                 rootfs_path.value().c_str(),
+                 rootfs_path.c_str(),
                  (int)(rootfs_size - 16 * 1024));
   EXPECT_COMMAND(0,
                  "./avbtool.py resize_image --image %s "
                  "--partition_size %d",
-                 rootfs_path.value().c_str(),
+                 rootfs_path.c_str(),
                  (int)resized_partition_size);
   ASSERT_EQ(
       AddHashFooterGetExpectedVBMetaInfo(sparse_image, resized_partition_size),
-      InfoImage(rootfs_path));
+      InfoImage(rootfs_path.string()));
 
   if (sparse_image) {
-    EXPECT_COMMAND(0,
-                   "mv %s %s.sparse",
-                   rootfs_path.value().c_str(),
-                   rootfs_path.value().c_str());
-    EXPECT_COMMAND(0,
-                   "simg2img %s.sparse %s",
-                   rootfs_path.value().c_str(),
-                   rootfs_path.value().c_str());
-    EXPECT_COMMAND(0, "rm -f %s.sparse", rootfs_path.value().c_str());
+    EXPECT_COMMAND(
+        0, "mv %s %s.sparse", rootfs_path.c_str(), rootfs_path.c_str());
+    EXPECT_COMMAND(
+        0, "simg2img %s.sparse %s", rootfs_path.c_str(), rootfs_path.c_str());
+    EXPECT_COMMAND(0, "rm -f %s.sparse", rootfs_path.c_str());
   }
 
   // Manually calculate the hash to check that it agrees with avbtool.
@@ -594,7 +585,8 @@ void AvbToolTest::AddHashFooterTest(bool sparse_image) {
 
   // Now check that we can find the VBMeta block again from the footer.
   std::string part_data;
-  ASSERT_TRUE(base::ReadFileToString(rootfs_path, &part_data));
+  ASSERT_TRUE(
+      android::base::ReadFileToString(rootfs_path.string(), &part_data));
 
   // Check footer contains correct data.
   AvbFooter f;
@@ -650,14 +642,15 @@ void AvbToolTest::AddHashFooterTest(bool sparse_image) {
 
   // Check that the footer is correctly erased.
   EXPECT_COMMAND(
-      0, "./avbtool.py erase_footer --image %s", rootfs_path.value().c_str());
+      0, "./avbtool.py erase_footer --image %s", rootfs_path.c_str());
   int64_t erased_footer_file_size;
-  ASSERT_TRUE(base::GetFileSize(rootfs_path, &erased_footer_file_size));
+  ASSERT_TRUE(base::GetFileSize(base::FilePath(rootfs_path.c_str()),
+                                &erased_footer_file_size));
   EXPECT_EQ(static_cast<size_t>(erased_footer_file_size), rootfs_size);
 
   // Check that --do_not_append_vbmeta_image works as intended.
   // In this case we don't modify the input image so it should work read-only.
-  EXPECT_COMMAND(0, "chmod a-w %s", rootfs_path.value().c_str());
+  EXPECT_COMMAND(0, "chmod a-w %s", rootfs_path.c_str());
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hash_footer --salt d00df00d "
                  "--hash_algorithm sha256 --image %s "
@@ -666,16 +659,17 @@ void AvbToolTest::AddHashFooterTest(bool sparse_image) {
                  "--key test/data/testkey_rsa2048.pem "
                  "--output_vbmeta %s_2nd_run --do_not_append_vbmeta_image "
                  "--internal_release_string \"\"",
-                 rootfs_path.value().c_str(),
+                 rootfs_path.c_str(),
                  (int)partition_size,
-                 external_vbmeta_path.value().c_str());
+                 external_vbmeta_path.c_str());
   int64_t file_size;
-  ASSERT_TRUE(base::GetFileSize(rootfs_path, &file_size));
+  ASSERT_TRUE(
+      base::GetFileSize(base::FilePath(rootfs_path.c_str()), &file_size));
   EXPECT_EQ(static_cast<size_t>(file_size), rootfs_size);
   EXPECT_COMMAND(0,
                  "diff %s %s_2nd_run",
-                 external_vbmeta_path.value().c_str(),
-                 external_vbmeta_path.value().c_str());
+                 external_vbmeta_path.c_str(),
+                 external_vbmeta_path.c_str());
 }
 
 TEST_F(AvbToolTest, AddHashFooter) {
@@ -713,11 +707,11 @@ TEST_F(AvbToolTest, DISABLED_AddHashFooterSparseWithHoleAtTheEnd) {
   // 0x00000000)" and not "Don't care". Instead, use make_ext4fs for
   // this since it will put a big hole (e.g. "Don't care" chunk) at
   // the end.
-  base::FilePath partition_path = testdir_.Append("partition.bin");
+  std::filesystem::path partition_path = testdir_ / "partition.bin";
   EXPECT_COMMAND(0,
                  "make_ext4fs -s -L test -l %zd %s",
                  partition_size - metadata_size,
-                 partition_path.value().c_str());
+                 partition_path.c_str());
 
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hash_footer --salt d00df00d "
@@ -726,15 +720,15 @@ TEST_F(AvbToolTest, DISABLED_AddHashFooterSparseWithHoleAtTheEnd) {
                  "--algorithm SHA256_RSA2048 "
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\"",
-                 partition_path.value().c_str(),
+                 partition_path.c_str(),
                  (int)partition_size);
 
   // Since we may be using an arbritary version of make_ext4fs
   // (because of different branches) the contents of the resulting
   // disk image may slightly change. It's enough to just remove the
   // "Digest:" line from the output to work around this.
-  std::string info =
-      RemoveLinesStartingWith(InfoImage(partition_path), "      Digest:");
+  std::string info = RemoveLinesStartingWith(InfoImage(partition_path.string()),
+                                             "      Digest:");
   ASSERT_EQ(
       "Footer version:           1.0\n"
       "Image size:               10485760 bytes\n"
@@ -761,29 +755,28 @@ TEST_F(AvbToolTest, DISABLED_AddHashFooterSparseWithHoleAtTheEnd) {
       "      Flags:                 0\n",
       info);
 
-  EXPECT_COMMAND(0,
-                 "mv %s %s.sparse",
-                 partition_path.value().c_str(),
-                 partition_path.value().c_str());
+  EXPECT_COMMAND(
+      0, "mv %s %s.sparse", partition_path.c_str(), partition_path.c_str());
   EXPECT_COMMAND(0,
                  "simg2img %s.sparse %s",
-                 partition_path.value().c_str(),
-                 partition_path.value().c_str());
-  EXPECT_COMMAND(0, "rm -f %s.sparse", partition_path.value().c_str());
+                 partition_path.c_str(),
+                 partition_path.c_str());
+  EXPECT_COMMAND(0, "rm -f %s.sparse", partition_path.c_str());
 }
 
 TEST_F(AvbToolTest, AddHashFooterCalcMaxImageSize) {
   const size_t partition_size = 10 * 1024 * 1024;
-  base::FilePath output_path = testdir_.Append("max_size.txt");
+  std::filesystem::path output_path = testdir_ / "max_size.txt";
 
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hash_footer "
                  "--partition_size %zd "
                  "--calc_max_image_size > %s",
                  partition_size,
-                 output_path.value().c_str());
+                 output_path.c_str());
   std::string max_image_size_data;
-  EXPECT_TRUE(base::ReadFileToString(output_path, &max_image_size_data));
+  EXPECT_TRUE(android::base::ReadFileToString(output_path.string(),
+                                              &max_image_size_data));
   EXPECT_EQ("10416128\n", max_image_size_data);
   size_t max_image_size = atoll(max_image_size_data.c_str());
 
@@ -792,7 +785,7 @@ TEST_F(AvbToolTest, AddHashFooterCalcMaxImageSize) {
 
   // Check that we can add a hash footer for an image this size for
   // such a partition size.
-  base::FilePath boot_path = GenerateImage("boot", max_image_size);
+  std::string boot_path = GenerateImage("boot", max_image_size);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hash_footer"
                  " --image %s"
@@ -802,13 +795,13 @@ TEST_F(AvbToolTest, AddHashFooterCalcMaxImageSize) {
                  " --algorithm SHA512_RSA4096 "
                  " --key test/data/testkey_rsa4096.pem"
                  " --internal_release_string \"\"",
-                 boot_path.value().c_str(),
+                 boot_path.c_str(),
                  partition_size);
 }
 
 TEST_F(AvbToolTest, AddHashFooterWithPersistentDigest) {
   size_t partition_size = 1024 * 1024;
-  base::FilePath path = GenerateImage("digest_location", 1024);
+  std::string path = GenerateImage("digest_location", 1024);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hash_footer "
                  "--hash_algorithm sha256 --image %s "
@@ -817,7 +810,7 @@ TEST_F(AvbToolTest, AddHashFooterWithPersistentDigest) {
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\" "
                  "--use_persistent_digest",
-                 path.value().c_str(),
+                 path.c_str(),
                  (int)partition_size);
   // There are two important bits specific to these flags:
   //   Minimum libavb version = 1.1
@@ -852,7 +845,7 @@ TEST_F(AvbToolTest, AddHashFooterWithPersistentDigest) {
 
 TEST_F(AvbToolTest, AddHashFooterWithNoAB) {
   size_t partition_size = 1024 * 1024;
-  base::FilePath path = GenerateImage("digest_location", 1024);
+  std::string path = GenerateImage("digest_location", 1024);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hash_footer --salt d00df00d "
                  "--hash_algorithm sha256 --image %s "
@@ -861,7 +854,7 @@ TEST_F(AvbToolTest, AddHashFooterWithNoAB) {
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\" "
                  "--do_not_use_ab",
-                 path.value().c_str(),
+                 path.c_str(),
                  (int)partition_size);
   // There are two important bits specific to these flags:
   //   Minimum libavb version = 1.1
@@ -897,7 +890,7 @@ TEST_F(AvbToolTest, AddHashFooterWithNoAB) {
 
 TEST_F(AvbToolTest, AddHashFooterWithPersistentDigestAndNoAB) {
   size_t partition_size = 1024 * 1024;
-  base::FilePath path = GenerateImage("digest_location", 1024);
+  std::string path = GenerateImage("digest_location", 1024);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hash_footer "
                  "--hash_algorithm sha256 --image %s "
@@ -906,7 +899,7 @@ TEST_F(AvbToolTest, AddHashFooterWithPersistentDigestAndNoAB) {
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\" "
                  "--use_persistent_digest --do_not_use_ab",
-                 path.value().c_str(),
+                 path.c_str(),
                  (int)partition_size);
   // There are three important bits specific to these flags:
   //   Minimum libavb version = 1.1
@@ -944,7 +937,7 @@ void AvbToolTest::CreateRootfsWithHashtreeFooter(
     bool sparse_image,
     const std::string& hash_algorithm,
     const std::string& root_digest,
-    base::FilePath* output_rootfs_path) {
+    std::filesystem::path* output_rootfs_path) {
   const size_t rootfs_size = 1028 * 1024;
   const size_t partition_size = 1536 * 1024;
 
@@ -953,166 +946,155 @@ void AvbToolTest::CreateRootfsWithHashtreeFooter(
   rootfs.resize(rootfs_size);
   for (size_t n = 0; n < rootfs_size; n++)
     rootfs[n] = uint8_t(n);
-  base::FilePath external_vbmeta_path = testdir_.Append("external_vbmeta.bin");
-  base::FilePath extracted_vbmeta_path =
-      testdir_.Append("extracted_vbmeta.bin");
-  base::FilePath rootfs_path = testdir_.Append("rootfs.bin");
+  std::filesystem::path external_vbmeta_path = testdir_ / "external_vbmeta.bin";
+  std::filesystem::path extracted_vbmeta_path =
+      testdir_ / "extracted_vbmeta.bin";
+  std::filesystem::path rootfs_path = testdir_ / "rootfs.bin";
   EXPECT_EQ(rootfs_size,
             static_cast<const size_t>(
-                base::WriteFile(rootfs_path,
+                base::WriteFile(base::FilePath(rootfs_path.c_str()),
                                 reinterpret_cast<const char*>(rootfs.data()),
                                 rootfs.size())));
 
   if (sparse_image) {
-    EXPECT_COMMAND(0,
-                   "mv %s %s.unsparse",
-                   rootfs_path.value().c_str(),
-                   rootfs_path.value().c_str());
-    EXPECT_COMMAND(0,
-                   "img2simg %s.unsparse %s",
-                   rootfs_path.value().c_str(),
-                   rootfs_path.value().c_str());
-    EXPECT_COMMAND(0, "rm -f %s.unsparse", rootfs_path.value().c_str());
+    EXPECT_COMMAND(
+        0, "mv %s %s.unsparse", rootfs_path.c_str(), rootfs_path.c_str());
+    EXPECT_COMMAND(
+        0, "img2simg %s.unsparse %s", rootfs_path.c_str(), rootfs_path.c_str());
+    EXPECT_COMMAND(0, "rm -f %s.unsparse", rootfs_path.c_str());
   }
 
   /* Do this twice to check that 'add_hashtree_footer' is idempotent. */
   for (int n = 0; n < 2; n++) {
-    EXPECT_COMMAND(0,
-                   "./avbtool.py add_hashtree_footer --salt d00df00d --image %s "
-                   "--hash_algorithm %s "
-                   "--partition_size %d --partition_name foobar "
-                   "--algorithm SHA256_RSA2048 "
-                   "--key test/data/testkey_rsa2048.pem "
-                   "--output_vbmeta_image %s "
-                   "--internal_release_string \"\" "
-                   "--do_not_generate_fec",
-                   rootfs_path.value().c_str(),
-                   hash_algorithm.c_str(),
-                   (int)partition_size,
-                   external_vbmeta_path.value().c_str());
-
-    ASSERT_EQ(base::StringPrintf("Footer version:           1.0\n"
-                                 "Image size:               1572864 bytes\n"
-                                 "Original image size:      1052672 bytes\n"
-                                 "VBMeta offset:            1069056\n"
-                                 "VBMeta size:              1344 bytes\n"
-                                 "--\n"
-                                 "Minimum libavb version:   1.0%s\n"
-                                 "Header Block:             256 bytes\n"
-                                 "Authentication Block:     320 bytes\n"
-                                 "Auxiliary Block:          768 bytes\n"
-                                 "Public key (sha1):        "
-                                 "cdbb77177f731920bbe0a0f94f84d9038ae0617d\n"
-                                 "Algorithm:                SHA256_RSA2048\n"
-                                 "Rollback Index:           0\n"
-                                 "Flags:                    0\n"
-                                 "Rollback Index Location:  0\n"
-                                 "Release String:           ''\n"
-                                 "Descriptors:\n"
-                                 "    Hashtree descriptor:\n"
-                                 "      Version of dm-verity:  1\n"
-                                 "      Image Size:            1052672 bytes\n"
-                                 "      Tree Offset:           1052672\n"
-                                 "      Tree Size:             16384 bytes\n"
-                                 "      Data Block Size:       4096 bytes\n"
-                                 "      Hash Block Size:       4096 bytes\n"
-                                 "      FEC num roots:         0\n"
-                                 "      FEC offset:            0\n"
-                                 "      FEC size:              0 bytes\n"
-                                 "      Hash Algorithm:        %s\n"
-                                 "      Partition Name:        foobar\n"
-                                 "      Salt:                  d00df00d\n"
-                                 "      Root Digest:           "
-                                 "%s\n"
-                                 "      Flags:                 0\n",
-                                 sparse_image ? " (Sparse)" : "",
-                                 hash_algorithm.c_str(),
-                                 root_digest.c_str()),
-              InfoImage(rootfs_path));
-
-    ASSERT_EQ(base::StringPrintf("Minimum libavb version:   1.0\n"
-                                 "Header Block:             256 bytes\n"
-                                 "Authentication Block:     320 bytes\n"
-                                 "Auxiliary Block:          768 bytes\n"
-                                 "Public key (sha1):        "
-                                 "cdbb77177f731920bbe0a0f94f84d9038ae0617d\n"
-                                 "Algorithm:                SHA256_RSA2048\n"
-                                 "Rollback Index:           0\n"
-                                 "Flags:                    0\n"
-                                 "Rollback Index Location:  0\n"
-                                 "Release String:           ''\n"
-                                 "Descriptors:\n"
-                                 "    Hashtree descriptor:\n"
-                                 "      Version of dm-verity:  1\n"
-                                 "      Image Size:            1052672 bytes\n"
-                                 "      Tree Offset:           1052672\n"
-                                 "      Tree Size:             16384 bytes\n"
-                                 "      Data Block Size:       4096 bytes\n"
-                                 "      Hash Block Size:       4096 bytes\n"
-                                 "      FEC num roots:         0\n"
-                                 "      FEC offset:            0\n"
-                                 "      FEC size:              0 bytes\n"
-                                 "      Hash Algorithm:        %s\n"
-                                 "      Partition Name:        foobar\n"
-                                 "      Salt:                  d00df00d\n"
-                                 "      Root Digest:           "
-                                 "%s\n"
-                                 "      Flags:                 0\n",
-                                 hash_algorithm.c_str(),
-                                 root_digest.c_str()),
-              InfoImage(external_vbmeta_path));
+    EXPECT_COMMAND(
+        0,
+        "./avbtool.py add_hashtree_footer --salt d00df00d --image %s "
+        "--hash_algorithm %s "
+        "--partition_size %d --partition_name foobar "
+        "--algorithm SHA256_RSA2048 "
+        "--key test/data/testkey_rsa2048.pem "
+        "--output_vbmeta_image %s "
+        "--internal_release_string \"\" "
+        "--do_not_generate_fec",
+        rootfs_path.c_str(),
+        hash_algorithm.c_str(),
+        (int)partition_size,
+        external_vbmeta_path.c_str());
+
+    ASSERT_EQ(android::base::StringPrintf(
+                  "Footer version:           1.0\n"
+                  "Image size:               1572864 bytes\n"
+                  "Original image size:      1052672 bytes\n"
+                  "VBMeta offset:            1069056\n"
+                  "VBMeta size:              1344 bytes\n"
+                  "--\n"
+                  "Minimum libavb version:   1.0%s\n"
+                  "Header Block:             256 bytes\n"
+                  "Authentication Block:     320 bytes\n"
+                  "Auxiliary Block:          768 bytes\n"
+                  "Public key (sha1):        "
+                  "cdbb77177f731920bbe0a0f94f84d9038ae0617d\n"
+                  "Algorithm:                SHA256_RSA2048\n"
+                  "Rollback Index:           0\n"
+                  "Flags:                    0\n"
+                  "Rollback Index Location:  0\n"
+                  "Release String:           ''\n"
+                  "Descriptors:\n"
+                  "    Hashtree descriptor:\n"
+                  "      Version of dm-verity:  1\n"
+                  "      Image Size:            1052672 bytes\n"
+                  "      Tree Offset:           1052672\n"
+                  "      Tree Size:             16384 bytes\n"
+                  "      Data Block Size:       4096 bytes\n"
+                  "      Hash Block Size:       4096 bytes\n"
+                  "      FEC num roots:         0\n"
+                  "      FEC offset:            0\n"
+                  "      FEC size:              0 bytes\n"
+                  "      Hash Algorithm:        %s\n"
+                  "      Partition Name:        foobar\n"
+                  "      Salt:                  d00df00d\n"
+                  "      Root Digest:           "
+                  "%s\n"
+                  "      Flags:                 0\n",
+                  sparse_image ? " (Sparse)" : "",
+                  hash_algorithm.c_str(),
+                  root_digest.c_str()),
+              InfoImage(rootfs_path.string()));
+
+    ASSERT_EQ(android::base::StringPrintf(
+                  "Minimum libavb version:   1.0\n"
+                  "Header Block:             256 bytes\n"
+                  "Authentication Block:     320 bytes\n"
+                  "Auxiliary Block:          768 bytes\n"
+                  "Public key (sha1):        "
+                  "cdbb77177f731920bbe0a0f94f84d9038ae0617d\n"
+                  "Algorithm:                SHA256_RSA2048\n"
+                  "Rollback Index:           0\n"
+                  "Flags:                    0\n"
+                  "Rollback Index Location:  0\n"
+                  "Release String:           ''\n"
+                  "Descriptors:\n"
+                  "    Hashtree descriptor:\n"
+                  "      Version of dm-verity:  1\n"
+                  "      Image Size:            1052672 bytes\n"
+                  "      Tree Offset:           1052672\n"
+                  "      Tree Size:             16384 bytes\n"
+                  "      Data Block Size:       4096 bytes\n"
+                  "      Hash Block Size:       4096 bytes\n"
+                  "      FEC num roots:         0\n"
+                  "      FEC offset:            0\n"
+                  "      FEC size:              0 bytes\n"
+                  "      Hash Algorithm:        %s\n"
+                  "      Partition Name:        foobar\n"
+                  "      Salt:                  d00df00d\n"
+                  "      Root Digest:           "
+                  "%s\n"
+                  "      Flags:                 0\n",
+                  hash_algorithm.c_str(),
+                  root_digest.c_str()),
+              InfoImage(external_vbmeta_path.string()));
 
     // Check that the extracted vbmeta matches the externally generally one.
     EXPECT_COMMAND(0,
                    "./avbtool.py extract_vbmeta_image --image %s "
                    "--output %s",
-                   rootfs_path.value().c_str(),
-                   extracted_vbmeta_path.value().c_str());
+                   rootfs_path.c_str(),
+                   extracted_vbmeta_path.c_str());
     EXPECT_COMMAND(0,
                    "diff %s %s",
-                   external_vbmeta_path.value().c_str(),
-                   extracted_vbmeta_path.value().c_str());
+                   external_vbmeta_path.c_str(),
+                   extracted_vbmeta_path.c_str());
   }
 
-  *output_rootfs_path = rootfs_path;
+  *output_rootfs_path = rootfs_path.c_str();
 }
 
 void AvbToolTest::AddHashtreeFooterTest(bool sparse_image) {
-  base::FilePath rootfs_path;
+  std::filesystem::path rootfs_path;
   CreateRootfsWithHashtreeFooter(sparse_image,
                                  "sha1",
                                  "e811611467dcd6e8dc4324e45f706c2bdd51db67",
                                  &rootfs_path);
 
   /* Zero the hashtree on a copy of the image. */
-  EXPECT_COMMAND(0,
-                 "cp %s %s.zht",
-                 rootfs_path.value().c_str(),
-                 rootfs_path.value().c_str());
-  EXPECT_COMMAND(0,
-                 "./avbtool.py zero_hashtree --image %s.zht ",
-                 rootfs_path.value().c_str());
+  EXPECT_COMMAND(0, "cp %s %s.zht", rootfs_path.c_str(), rootfs_path.c_str());
+  EXPECT_COMMAND(
+      0, "./avbtool.py zero_hashtree --image %s.zht ", rootfs_path.c_str());
 
   if (sparse_image) {
-    EXPECT_COMMAND(0,
-                   "mv %s %s.sparse",
-                   rootfs_path.value().c_str(),
-                   rootfs_path.value().c_str());
-    EXPECT_COMMAND(0,
-                   "simg2img %s.sparse %s",
-                   rootfs_path.value().c_str(),
-                   rootfs_path.value().c_str());
-    EXPECT_COMMAND(0, "rm -f %s.sparse", rootfs_path.value().c_str());
-
-    EXPECT_COMMAND(0,
-                   "mv %s.zht %s.zht.sparse",
-                   rootfs_path.value().c_str(),
-                   rootfs_path.value().c_str());
+    EXPECT_COMMAND(
+        0, "mv %s %s.sparse", rootfs_path.c_str(), rootfs_path.c_str());
+    EXPECT_COMMAND(
+        0, "simg2img %s.sparse %s", rootfs_path.c_str(), rootfs_path.c_str());
+    EXPECT_COMMAND(0, "rm -f %s.sparse", rootfs_path.c_str());
+
+    EXPECT_COMMAND(
+        0, "mv %s.zht %s.zht.sparse", rootfs_path.c_str(), rootfs_path.c_str());
     EXPECT_COMMAND(0,
                    "simg2img %s.zht.sparse %s.zht",
-                   rootfs_path.value().c_str(),
-                   rootfs_path.value().c_str());
-    EXPECT_COMMAND(0, "rm -f %s.zht.sparse", rootfs_path.value().c_str());
+                   rootfs_path.c_str(),
+                   rootfs_path.c_str());
+    EXPECT_COMMAND(0, "rm -f %s.zht.sparse", rootfs_path.c_str());
   }
 
   // To check that we generate the correct hashtree we can use
@@ -1131,17 +1113,18 @@ void AvbToolTest::AddHashtreeFooterTest(bool sparse_image) {
                  "verify "
                  "%s %s "
                  "e811611467dcd6e8dc4324e45f706c2bdd51db67",
-                 rootfs_path.value().c_str(),
-                 rootfs_path.value().c_str());
+                 rootfs_path.c_str(),
+                 rootfs_path.c_str());
 
   // Now check that we can find the VBMeta block again from the footer.
   std::string part_data;
-  ASSERT_TRUE(base::ReadFileToString(rootfs_path, &part_data));
+  ASSERT_TRUE(
+      android::base::ReadFileToString(rootfs_path.string(), &part_data));
 
   // Also read the zeroed hash-tree version.
   std::string zht_part_data;
   ASSERT_TRUE(base::ReadFileToString(
-      base::FilePath(rootfs_path.value() + ".zht"), &zht_part_data));
+      base::FilePath(rootfs_path.string() + ".zht"), &zht_part_data));
 
   // Check footer contains correct data.
   AvbFooter f;
@@ -1229,7 +1212,8 @@ void AvbToolTest::AddHashtreeFooterTest(bool sparse_image) {
 
   // Check that we correctly generate dm-verity kernel cmdline
   // snippets, if requested.
-  base::FilePath vbmeta_dmv_path = testdir_.Append("vbmeta_dm_verity_desc.bin");
+  std::filesystem::path vbmeta_dmv_path =
+      testdir_ / "vbmeta_dm_verity_desc.bin";
   EXPECT_COMMAND(0,
                  "./avbtool.py make_vbmeta_image "
                  "--output %s "
@@ -1237,8 +1221,8 @@ void AvbToolTest::AddHashtreeFooterTest(bool sparse_image) {
                  "--algorithm SHA256_RSA2048 "
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\"",
-                 vbmeta_dmv_path.value().c_str(),
-                 rootfs_path.value().c_str());
+                 vbmeta_dmv_path.c_str(),
+                 rootfs_path.c_str());
 
   ASSERT_EQ(
       "Minimum libavb version:   1.0\n"
@@ -1262,26 +1246,26 @@ void AvbToolTest::AddHashtreeFooterTest(bool sparse_image) {
       "      Flags:                 2\n"
       "      Kernel Cmdline:        "
       "'root=PARTUUID=$(ANDROID_SYSTEM_PARTUUID)'\n",
-      InfoImage(vbmeta_dmv_path));
+      InfoImage(vbmeta_dmv_path.string()));
 
   // Check that the footer is correctly erased and the hashtree
   // remains - see above for why the constant 1069056 is used.
   EXPECT_COMMAND(0,
                  "./avbtool.py erase_footer --image %s --keep_hashtree",
-                 rootfs_path.value().c_str());
+                 rootfs_path.c_str());
   int64_t erased_footer_file_size;
-  ASSERT_TRUE(base::GetFileSize(rootfs_path, &erased_footer_file_size));
+  ASSERT_TRUE(base::GetFileSize(base::FilePath(rootfs_path.c_str()),
+                                &erased_footer_file_size));
   EXPECT_EQ(static_cast<size_t>(erased_footer_file_size), 1069056UL);
 
   const size_t rootfs_size = 1028 * 1024;
   const size_t partition_size = 1536 * 1024;
-  base::FilePath external_vbmeta_path = testdir_.Append("external_vbmeta.bin");
+  std::filesystem::path external_vbmeta_path = testdir_ / "external_vbmeta.bin";
   // Check that --do_not_append_vbmeta_image works as intended.
   //
   // For this we need to reset the size of the image to the original
   // size because it's not possible to identify the existing hashtree.
-  EXPECT_COMMAND(
-      0, "truncate -s %d %s", (int)rootfs_size, rootfs_path.value().c_str());
+  EXPECT_COMMAND(0, "truncate -s %d %s", (int)rootfs_size, rootfs_path.c_str());
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer --salt d00df00d --image %s "
                  "--partition_size %d --partition_name foobar "
@@ -1290,16 +1274,17 @@ void AvbToolTest::AddHashtreeFooterTest(bool sparse_image) {
                  "--output_vbmeta %s_2nd_run --do_not_append_vbmeta_image "
                  "--internal_release_string \"\" "
                  "--do_not_generate_fec",
-                 rootfs_path.value().c_str(),
+                 rootfs_path.c_str(),
                  (int)partition_size,
-                 external_vbmeta_path.value().c_str());
+                 external_vbmeta_path.c_str());
   int64_t file_size;
-  ASSERT_TRUE(base::GetFileSize(rootfs_path, &file_size));
+  ASSERT_TRUE(
+      base::GetFileSize(base::FilePath(rootfs_path.c_str()), &file_size));
   EXPECT_EQ(static_cast<size_t>(file_size), 1069056UL);
   EXPECT_COMMAND(0,
                  "diff %s %s_2nd_run",
-                 external_vbmeta_path.value().c_str(),
-                 external_vbmeta_path.value().c_str());
+                 external_vbmeta_path.c_str(),
+                 external_vbmeta_path.c_str());
 }
 
 TEST_F(AvbToolTest, AddHashtreeFooter) {
@@ -1311,7 +1296,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterSparse) {
 }
 
 TEST_F(AvbToolTest, AddHashtreeFooterSparseWithBlake2b256) {
-  base::FilePath rootfs_path;
+  std::filesystem::path rootfs_path;
   CreateRootfsWithHashtreeFooter(
       true,
       "blake2b-256",
@@ -1328,115 +1313,104 @@ void AvbToolTest::AddHashtreeFooterFECTest(bool sparse_image) {
   rootfs.resize(rootfs_size);
   for (size_t n = 0; n < rootfs_size; n++)
     rootfs[n] = uint8_t(n);
-  base::FilePath rootfs_path = testdir_.Append("rootfs.bin");
+  std::filesystem::path rootfs_path = testdir_ / "rootfs.bin";
   EXPECT_EQ(rootfs_size,
             static_cast<const size_t>(
-                base::WriteFile(rootfs_path,
+                base::WriteFile(base::FilePath(rootfs_path.c_str()),
                                 reinterpret_cast<const char*>(rootfs.data()),
                                 rootfs.size())));
 
   if (sparse_image) {
-    EXPECT_COMMAND(0,
-                   "mv %s %s.unsparse",
-                   rootfs_path.value().c_str(),
-                   rootfs_path.value().c_str());
-    EXPECT_COMMAND(0,
-                   "img2simg %s.unsparse %s",
-                   rootfs_path.value().c_str(),
-                   rootfs_path.value().c_str());
-    EXPECT_COMMAND(0, "rm -f %s.unsparse", rootfs_path.value().c_str());
+    EXPECT_COMMAND(
+        0, "mv %s %s.unsparse", rootfs_path.c_str(), rootfs_path.c_str());
+    EXPECT_COMMAND(
+        0, "img2simg %s.unsparse %s", rootfs_path.c_str(), rootfs_path.c_str());
+    EXPECT_COMMAND(0, "rm -f %s.unsparse", rootfs_path.c_str());
   }
 
   /* Do this twice to check that 'add_hashtree_footer' is idempotent. */
   for (int n = 0; n < 2; n++) {
-    EXPECT_COMMAND(0,
-                   "./avbtool.py add_hashtree_footer --salt d00df00d --image %s "
-                   "--partition_size %d --partition_name foobar "
-                   "--algorithm SHA256_RSA2048 "
-                   "--key test/data/testkey_rsa2048.pem "
-                   "--internal_release_string \"\"",
-                   rootfs_path.value().c_str(),
-                   (int)partition_size);
-
-    ASSERT_EQ(base::StringPrintf("Footer version:           1.0\n"
-                                 "Image size:               1572864 bytes\n"
-                                 "Original image size:      1052672 bytes\n"
-                                 "VBMeta offset:            1085440\n"
-                                 "VBMeta size:              1344 bytes\n"
-                                 "--\n"
-                                 "Minimum libavb version:   1.0%s\n"
-                                 "Header Block:             256 bytes\n"
-                                 "Authentication Block:     320 bytes\n"
-                                 "Auxiliary Block:          768 bytes\n"
-                                 "Public key (sha1):        "
-                                 "cdbb77177f731920bbe0a0f94f84d9038ae0617d\n"
-                                 "Algorithm:                SHA256_RSA2048\n"
-                                 "Rollback Index:           0\n"
-                                 "Flags:                    0\n"
-                                 "Rollback Index Location:  0\n"
-                                 "Release String:           ''\n"
-                                 "Descriptors:\n"
-                                 "    Hashtree descriptor:\n"
-                                 "      Version of dm-verity:  1\n"
-                                 "      Image Size:            1052672 bytes\n"
-                                 "      Tree Offset:           1052672\n"
-                                 "      Tree Size:             16384 bytes\n"
-                                 "      Data Block Size:       4096 bytes\n"
-                                 "      Hash Block Size:       4096 bytes\n"
-                                 "      FEC num roots:         2\n"
-                                 "      FEC offset:            1069056\n"
-                                 "      FEC size:              16384 bytes\n"
-                                 "      Hash Algorithm:        sha1\n"
-                                 "      Partition Name:        foobar\n"
-                                 "      Salt:                  d00df00d\n"
-                                 "      Root Digest:           "
-                                 "e811611467dcd6e8dc4324e45f706c2bdd51db67\n"
-                                 "      Flags:                 0\n",
-                                 sparse_image ? " (Sparse)" : ""),
-              InfoImage(rootfs_path));
+    EXPECT_COMMAND(
+        0,
+        "./avbtool.py add_hashtree_footer --salt d00df00d --image %s "
+        "--partition_size %d --partition_name foobar "
+        "--algorithm SHA256_RSA2048 "
+        "--key test/data/testkey_rsa2048.pem "
+        "--internal_release_string \"\"",
+        rootfs_path.c_str(),
+        (int)partition_size);
+
+    ASSERT_EQ(android::base::StringPrintf(
+                  "Footer version:           1.0\n"
+                  "Image size:               1572864 bytes\n"
+                  "Original image size:      1052672 bytes\n"
+                  "VBMeta offset:            1085440\n"
+                  "VBMeta size:              1344 bytes\n"
+                  "--\n"
+                  "Minimum libavb version:   1.0%s\n"
+                  "Header Block:             256 bytes\n"
+                  "Authentication Block:     320 bytes\n"
+                  "Auxiliary Block:          768 bytes\n"
+                  "Public key (sha1):        "
+                  "cdbb77177f731920bbe0a0f94f84d9038ae0617d\n"
+                  "Algorithm:                SHA256_RSA2048\n"
+                  "Rollback Index:           0\n"
+                  "Flags:                    0\n"
+                  "Rollback Index Location:  0\n"
+                  "Release String:           ''\n"
+                  "Descriptors:\n"
+                  "    Hashtree descriptor:\n"
+                  "      Version of dm-verity:  1\n"
+                  "      Image Size:            1052672 bytes\n"
+                  "      Tree Offset:           1052672\n"
+                  "      Tree Size:             16384 bytes\n"
+                  "      Data Block Size:       4096 bytes\n"
+                  "      Hash Block Size:       4096 bytes\n"
+                  "      FEC num roots:         2\n"
+                  "      FEC offset:            1069056\n"
+                  "      FEC size:              16384 bytes\n"
+                  "      Hash Algorithm:        sha1\n"
+                  "      Partition Name:        foobar\n"
+                  "      Salt:                  d00df00d\n"
+                  "      Root Digest:           "
+                  "e811611467dcd6e8dc4324e45f706c2bdd51db67\n"
+                  "      Flags:                 0\n",
+                  sparse_image ? " (Sparse)" : ""),
+              InfoImage(rootfs_path.string()));
   }
 
   /* Zero the hashtree and FEC on a copy of the image. */
-  EXPECT_COMMAND(0,
-                 "cp %s %s.zht",
-                 rootfs_path.value().c_str(),
-                 rootfs_path.value().c_str());
-  EXPECT_COMMAND(0,
-                 "./avbtool.py zero_hashtree --image %s.zht ",
-                 rootfs_path.value().c_str());
+  EXPECT_COMMAND(0, "cp %s %s.zht", rootfs_path.c_str(), rootfs_path.c_str());
+  EXPECT_COMMAND(
+      0, "./avbtool.py zero_hashtree --image %s.zht ", rootfs_path.c_str());
 
   if (sparse_image) {
-    EXPECT_COMMAND(0,
-                   "mv %s %s.sparse",
-                   rootfs_path.value().c_str(),
-                   rootfs_path.value().c_str());
-    EXPECT_COMMAND(0,
-                   "simg2img %s.sparse %s",
-                   rootfs_path.value().c_str(),
-                   rootfs_path.value().c_str());
-    EXPECT_COMMAND(0, "rm -f %s.sparse", rootfs_path.value().c_str());
-
-    EXPECT_COMMAND(0,
-                   "mv %s.zht %s.zht.sparse",
-                   rootfs_path.value().c_str(),
-                   rootfs_path.value().c_str());
+    EXPECT_COMMAND(
+        0, "mv %s %s.sparse", rootfs_path.c_str(), rootfs_path.c_str());
+    EXPECT_COMMAND(
+        0, "simg2img %s.sparse %s", rootfs_path.c_str(), rootfs_path.c_str());
+    EXPECT_COMMAND(0, "rm -f %s.sparse", rootfs_path.c_str());
+
+    EXPECT_COMMAND(
+        0, "mv %s.zht %s.zht.sparse", rootfs_path.c_str(), rootfs_path.c_str());
     EXPECT_COMMAND(0,
                    "simg2img %s.zht.sparse %s.zht",
-                   rootfs_path.value().c_str(),
-                   rootfs_path.value().c_str());
-    EXPECT_COMMAND(0, "rm -f %s.zht.sparse", rootfs_path.value().c_str());
+                   rootfs_path.c_str(),
+                   rootfs_path.c_str());
+    EXPECT_COMMAND(0, "rm -f %s.zht.sparse", rootfs_path.c_str());
   }
 
   /* TODO: would be nice to verify that the FEC data is correct. */
 
   // Now check that we can find the VBMeta block again from the footer.
   std::string part_data;
-  ASSERT_TRUE(base::ReadFileToString(rootfs_path, &part_data));
+  ASSERT_TRUE(
+      android::base::ReadFileToString(rootfs_path.string(), &part_data));
 
   // Also read the zeroed hash-tree version.
   std::string zht_part_data;
   ASSERT_TRUE(base::ReadFileToString(
-      base::FilePath(rootfs_path.value() + ".zht"), &zht_part_data));
+      base::FilePath(rootfs_path.string() + ".zht"), &zht_part_data));
 
   // Check footer contains correct data.
   AvbFooter f;
@@ -1526,7 +1500,8 @@ void AvbToolTest::AddHashtreeFooterFECTest(bool sparse_image) {
 
   // Check that we correctly generate dm-verity kernel cmdline
   // snippets, if requested.
-  base::FilePath vbmeta_dmv_path = testdir_.Append("vbmeta_dm_verity_desc.bin");
+  std::filesystem::path vbmeta_dmv_path =
+      testdir_ / "vbmeta_dm_verity_desc.bin";
   EXPECT_COMMAND(0,
                  "./avbtool.py make_vbmeta_image "
                  "--output %s "
@@ -1534,8 +1509,8 @@ void AvbToolTest::AddHashtreeFooterFECTest(bool sparse_image) {
                  "--algorithm SHA256_RSA2048 "
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\"",
-                 vbmeta_dmv_path.value().c_str(),
-                 rootfs_path.value().c_str());
+                 vbmeta_dmv_path.c_str(),
+                 rootfs_path.c_str());
 
   ASSERT_EQ(
       "Minimum libavb version:   1.0\n"
@@ -1562,16 +1537,17 @@ void AvbToolTest::AddHashtreeFooterFECTest(bool sparse_image) {
       "      Flags:                 2\n"
       "      Kernel Cmdline:        "
       "'root=PARTUUID=$(ANDROID_SYSTEM_PARTUUID)'\n",
-      InfoImage(vbmeta_dmv_path));
+      InfoImage(vbmeta_dmv_path.string()));
 
   // Check that the footer is correctly erased and the hashtree and
   // FEC data remains. The constant 1085440 is used because it's where
   // the FEC data ends (it's at offset 1069056 and size 16384).
   EXPECT_COMMAND(0,
                  "./avbtool.py erase_footer --image %s --keep_hashtree",
-                 rootfs_path.value().c_str());
+                 rootfs_path.c_str());
   int64_t erased_footer_file_size;
-  ASSERT_TRUE(base::GetFileSize(rootfs_path, &erased_footer_file_size));
+  ASSERT_TRUE(base::GetFileSize(base::FilePath(rootfs_path.c_str()),
+                                &erased_footer_file_size));
   EXPECT_EQ(static_cast<size_t>(erased_footer_file_size), 1085440UL);
 }
 
@@ -1585,16 +1561,17 @@ TEST_F(AvbToolTest, AddHashtreeFooterFECSparse) {
 
 TEST_F(AvbToolTest, AddHashtreeFooterCalcMaxImageSize) {
   const size_t partition_size = 10 * 1024 * 1024;
-  base::FilePath output_path = testdir_.Append("max_size.txt");
+  std::filesystem::path output_path = testdir_ / "max_size.txt";
 
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer "
                  "--partition_size %zd --calc_max_image_size "
                  "--do_not_generate_fec > %s",
                  partition_size,
-                 output_path.value().c_str());
+                 output_path.c_str());
   std::string max_image_size_data;
-  EXPECT_TRUE(base::ReadFileToString(output_path, &max_image_size_data));
+  EXPECT_TRUE(android::base::ReadFileToString(output_path.string(),
+                                              &max_image_size_data));
   EXPECT_EQ("10330112\n", max_image_size_data);
   size_t max_image_size = atoll(max_image_size_data.c_str());
 
@@ -1604,7 +1581,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterCalcMaxImageSize) {
 
   // Check that we can add a hashtree with an image this size for such
   // a partition size.
-  base::FilePath system_path = GenerateImage("system", max_image_size);
+  std::string system_path = GenerateImage("system", max_image_size);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer"
                  " --image %s"
@@ -1615,21 +1592,22 @@ TEST_F(AvbToolTest, AddHashtreeFooterCalcMaxImageSize) {
                  " --key test/data/testkey_rsa4096.pem"
                  " --internal_release_string \"\" "
                  "--do_not_generate_fec",
-                 system_path.value().c_str(),
+                 system_path.c_str(),
                  partition_size);
 }
 
 TEST_F(AvbToolTest, AddHashtreeFooterCalcMaxImageSizeWithFEC) {
   const size_t partition_size = 10 * 1024 * 1024;
-  base::FilePath output_path = testdir_.Append("max_size.txt");
+  std::filesystem::path output_path = testdir_ / "max_size.txt";
 
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer "
                  "--partition_size %zd --calc_max_image_size > %s",
                  partition_size,
-                 output_path.value().c_str());
+                 output_path.c_str());
   std::string max_image_size_data;
-  EXPECT_TRUE(base::ReadFileToString(output_path, &max_image_size_data));
+  EXPECT_TRUE(android::base::ReadFileToString(output_path.string(),
+                                              &max_image_size_data));
   EXPECT_EQ("10235904\n", max_image_size_data);
   size_t max_image_size = atoll(max_image_size_data.c_str());
 
@@ -1639,7 +1617,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterCalcMaxImageSizeWithFEC) {
 
   // Check that we can add a hashtree with an image this size for such
   // a partition size.
-  base::FilePath system_path = GenerateImage("system", max_image_size);
+  std::string system_path = GenerateImage("system", max_image_size);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer"
                  " --image %s"
@@ -1649,22 +1627,23 @@ TEST_F(AvbToolTest, AddHashtreeFooterCalcMaxImageSizeWithFEC) {
                  " --algorithm SHA512_RSA4096 "
                  " --key test/data/testkey_rsa4096.pem"
                  " --internal_release_string \"\"",
-                 system_path.value().c_str(),
+                 system_path.c_str(),
                  partition_size);
 }
 
 TEST_F(AvbToolTest, AddHashtreeFooterCalcMaxImageSizeWithNoHashtree) {
   const size_t partition_size = 10 * 1024 * 1024;
-  base::FilePath output_path = testdir_.Append("max_size.txt");
+  std::filesystem::path output_path = testdir_ / "max_size.txt";
 
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer "
                  "--no_hashtree "
                  "--partition_size %zd --calc_max_image_size > %s",
                  partition_size,
-                 output_path.value().c_str());
+                 output_path.c_str());
   std::string max_image_size_data;
-  EXPECT_TRUE(base::ReadFileToString(output_path, &max_image_size_data));
+  EXPECT_TRUE(android::base::ReadFileToString(output_path.string(),
+                                              &max_image_size_data));
   EXPECT_EQ("10416128\n", max_image_size_data);
   size_t max_image_size = atoll(max_image_size_data.c_str());
 
@@ -1673,7 +1652,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterCalcMaxImageSizeWithNoHashtree) {
 
   // Check that we can add a hashtree with an image this size for such
   // a partition size.
-  base::FilePath system_path = GenerateImage("system", max_image_size);
+  std::string system_path = GenerateImage("system", max_image_size);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer"
                  " --image %s"
@@ -1684,7 +1663,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterCalcMaxImageSizeWithNoHashtree) {
                  " --algorithm SHA512_RSA4096 "
                  " --key test/data/testkey_rsa4096.pem"
                  " --internal_release_string \"\"",
-                 system_path.value().c_str(),
+                 system_path.c_str(),
                  partition_size);
   // with --no_hashtree, Tree/FEC sizes are 0 bytes
   ASSERT_EQ(
@@ -1725,7 +1704,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterCalcMaxImageSizeWithNoHashtree) {
 
 TEST_F(AvbToolTest, AddHashtreeFooterWithPersistentDigest) {
   size_t partition_size = 10 * 1024 * 1024;
-  base::FilePath path = GenerateImage("digest_location", partition_size / 2);
+  std::string path = GenerateImage("digest_location", partition_size / 2);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer "
                  "--hash_algorithm sha256 --image %s "
@@ -1734,7 +1713,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterWithPersistentDigest) {
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\" "
                  "--use_persistent_digest",
-                 path.value().c_str(),
+                 path.c_str(),
                  (int)partition_size);
   // There are two important bits here specific to --use_persistent_digest:
   //   Minimum libavb version = 1.1
@@ -1777,7 +1756,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterWithPersistentDigest) {
 
 TEST_F(AvbToolTest, AddHashtreeFooterWithNoAB) {
   size_t partition_size = 10 * 1024 * 1024;
-  base::FilePath path = GenerateImage("digest_location", partition_size / 2);
+  std::string path = GenerateImage("digest_location", partition_size / 2);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer --salt d00df00d "
                  "--hash_algorithm sha256 --image %s "
@@ -1786,7 +1765,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterWithNoAB) {
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\" "
                  "--do_not_use_ab",
-                 path.value().c_str(),
+                 path.c_str(),
                  (int)partition_size);
   // There are two important bits here we're expecting with --do_not_use_ab:
   //   Minimum libavb version = 1.1
@@ -1830,7 +1809,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterWithNoAB) {
 
 TEST_F(AvbToolTest, AddHashtreeFooterWithPersistentDigestAndNoAB) {
   size_t partition_size = 10 * 1024 * 1024;
-  base::FilePath path = GenerateImage("digest_location", partition_size / 2);
+  std::string path = GenerateImage("digest_location", partition_size / 2);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer "
                  "--hash_algorithm sha256 --image %s "
@@ -1839,7 +1818,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterWithPersistentDigestAndNoAB) {
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\" "
                  "--use_persistent_digest --do_not_use_ab",
-                 path.value().c_str(),
+                 path.c_str(),
                  (int)partition_size);
   // There are three important bits specific to these flags:
   //   Minimum libavb version = 1.1
@@ -1884,7 +1863,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterWithPersistentDigestAndNoAB) {
 TEST_F(AvbToolTest, AddHashtreeFooterNoSizeOrName) {
   // Size must be a multiple of block size (4096 bytes)
   size_t file_size = 72 * 1024;
-  base::FilePath path = GenerateImage("data.bin", file_size);
+  std::string path = GenerateImage("data.bin", file_size);
 
   // Note how there is no --partition_size or --partition_name here.
   EXPECT_COMMAND(0,
@@ -1893,7 +1872,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterNoSizeOrName) {
                  "--algorithm SHA256_RSA2048 "
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\" ",
-                 path.value().c_str());
+                 path.c_str());
 
   ASSERT_EQ(
       "Footer version:           1.0\n"
@@ -1934,13 +1913,13 @@ TEST_F(AvbToolTest, AddHashtreeFooterNoSizeOrName) {
   EXPECT_COMMAND(0,
                  "./avbtool.py verify_image "
                  "--image %s ",
-                 path.value().c_str());
+                 path.c_str());
 }
 
 TEST_F(AvbToolTest, AddHashtreeFooterSingleBlock) {
   // Tests a special case that the file size is just one block.
   size_t file_size = 4096;
-  base::FilePath path = GenerateImage("data.bin", file_size);
+  std::string path = GenerateImage("data.bin", file_size);
 
   // Note how there is no --partition_size or --partition_name here.
   EXPECT_COMMAND(0,
@@ -1949,7 +1928,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterSingleBlock) {
                  "--algorithm SHA256_RSA2048 "
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\" ",
-                 path.value().c_str());
+                 path.c_str());
 
   ASSERT_EQ(
       "Footer version:           1.0\n"
@@ -1990,13 +1969,13 @@ TEST_F(AvbToolTest, AddHashtreeFooterSingleBlock) {
   EXPECT_COMMAND(0,
                  "./avbtool.py verify_image "
                  "--image %s ",
-                 path.value().c_str());
+                 path.c_str());
 }
 
 TEST_F(AvbToolTest, AddHashtreeFooterNoSizeWrongSize) {
   // Size must be a multiple of block size (4096 bytes) and this one isn't...
   size_t file_size = 70 * 1024;
-  base::FilePath path = GenerateImage("data.bin", file_size);
+  std::string path = GenerateImage("data.bin", file_size);
 
   // ... so we expect this command to fail.
   EXPECT_COMMAND(1,
@@ -2005,7 +1984,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterNoSizeWrongSize) {
                  "--algorithm SHA256_RSA2048 "
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\" ",
-                 path.value().c_str());
+                 path.c_str());
 }
 
 TEST_F(AvbToolTest, AddHashtreeFooterRoundImageSize) {
@@ -2013,7 +1992,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterRoundImageSize) {
   // --partition_size is specified. avbtool will round the image size being
   // a multiple of block size, prior to add an AVB footer.
   size_t image_size = 70 * 1024;
-  base::FilePath path = GenerateImage("data.bin", image_size);
+  std::string path = GenerateImage("data.bin", image_size);
 
   size_t partition_size = 10 * 1024 * 1024;
   // Note that there is --partition_size here.
@@ -2024,7 +2003,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterRoundImageSize) {
                  "--key test/data/testkey_rsa2048.pem "
                  "--partition_size %d --partition_name foobar "
                  "--internal_release_string \"\" ",
-                 path.value().c_str(),
+                 path.c_str(),
                  (int)partition_size);
 }
 
@@ -2035,7 +2014,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterNoWrongPartitionSize) {
 
   // Image size doesn't matter in this case.
   size_t image_size = 70 * 1024;
-  base::FilePath path = GenerateImage("data.bin", image_size);
+  std::string path = GenerateImage("data.bin", image_size);
 
   // ... so we expect this command to fail.
   EXPECT_COMMAND(1,
@@ -2045,13 +2024,13 @@ TEST_F(AvbToolTest, AddHashtreeFooterNoWrongPartitionSize) {
                  "--key test/data/testkey_rsa2048.pem "
                  "--partition_size %d --partition_name foobar "
                  "--internal_release_string \"\" ",
-                 path.value().c_str(),
+                 path.c_str(),
                  (int)partition_size);
 }
 
 TEST_F(AvbToolTest, AddHashtreeFooterWithCheckAtMostOnce) {
   size_t partition_size = 10 * 1024 * 1024;
-  base::FilePath path = GenerateImage("digest_location", partition_size / 2);
+  std::string path = GenerateImage("digest_location", partition_size / 2);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer --salt d00df00d "
                  "--hash_algorithm sha256 --image %s "
@@ -2060,7 +2039,7 @@ TEST_F(AvbToolTest, AddHashtreeFooterWithCheckAtMostOnce) {
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\" "
                  "--check_at_most_once",
-                 path.value().c_str(),
+                 path.c_str(),
                  (int)partition_size);
   // There are two important bits here we're expecting with --check_at_most_once:
   //   Minimum libavb version = 1.1
@@ -2103,8 +2082,8 @@ TEST_F(AvbToolTest, AddHashtreeFooterWithCheckAtMostOnce) {
 }
 
 TEST_F(AvbToolTest, KernelCmdlineDescriptor) {
-  base::FilePath vbmeta_path =
-      testdir_.Append("vbmeta_kernel_cmdline_desc.bin");
+  std::filesystem::path vbmeta_path =
+      testdir_ / "vbmeta_kernel_cmdline_desc.bin";
 
   EXPECT_COMMAND(0,
                  "./avbtool.py make_vbmeta_image "
@@ -2114,7 +2093,7 @@ TEST_F(AvbToolTest, KernelCmdlineDescriptor) {
                  "--algorithm SHA256_RSA2048 "
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\"",
-                 vbmeta_path.value().c_str());
+                 vbmeta_path.c_str());
 
   ASSERT_EQ(
       "Minimum libavb version:   1.0\n"
@@ -2134,11 +2113,12 @@ TEST_F(AvbToolTest, KernelCmdlineDescriptor) {
       "    Kernel Cmdline descriptor:\n"
       "      Flags:                 0\n"
       "      Kernel Cmdline:        'second cmdline'\n",
-      InfoImage(vbmeta_path));
+      InfoImage(vbmeta_path.string()));
 
   // Now check the VBMeta image.
   std::string image_data;
-  ASSERT_TRUE(base::ReadFileToString(vbmeta_path, &image_data));
+  ASSERT_TRUE(
+      android::base::ReadFileToString(vbmeta_path.string(), &image_data));
 
   const uint8_t* vbmeta_data =
       reinterpret_cast<const uint8_t*>(image_data.data());
@@ -2179,7 +2159,7 @@ TEST_F(AvbToolTest, KernelCmdlineDescriptor) {
 }
 
 TEST_F(AvbToolTest, CalculateKernelCmdline) {
-  base::FilePath vbmeta_path = testdir_.Append("vbmeta.bin");
+  std::filesystem::path vbmeta_path = testdir_ / "vbmeta.bin";
   EXPECT_COMMAND(0,
                  "./avbtool.py make_vbmeta_image "
                  "--output %s "
@@ -2188,15 +2168,15 @@ TEST_F(AvbToolTest, CalculateKernelCmdline) {
                  "--algorithm SHA256_RSA2048 "
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\"",
-                 vbmeta_path.value().c_str());
+                 vbmeta_path.c_str());
 
-  base::FilePath out_path = testdir_.Append("out.txt");
+  std::filesystem::path out_path = testdir_ / "out.txt";
   std::string out;
   EXPECT_COMMAND(0,
                  "./avbtool.py calculate_kernel_cmdline --image %s > %s",
-                 vbmeta_path.value().c_str(),
-                 out_path.value().c_str());
-  ASSERT_TRUE(base::ReadFileToString(out_path, &out));
+                 vbmeta_path.c_str(),
+                 out_path.c_str());
+  ASSERT_TRUE(android::base::ReadFileToString(out_path.string(), &out));
   EXPECT_EQ(out, "foo bar baz second cmdline");
 }
 
@@ -2204,7 +2184,7 @@ TEST_F(AvbToolTest, CalculateKernelCmdlineChainedAndWithFlags) {
   const size_t rootfs_size = 1028 * 1024;
   const size_t partition_size = 1536 * 1024;
 
-  base::FilePath pk_path = testdir_.Append("testkey_rsa2048.avbpubkey");
+  std::filesystem::path pk_path = testdir_ / "testkey_rsa2048.avbpubkey";
 
   // Generate a 1028 KiB file with known content, add a hashtree, and cmdline
   // descriptors for setting up this hashtree. Notably this will create *two*
@@ -2214,10 +2194,10 @@ TEST_F(AvbToolTest, CalculateKernelCmdlineChainedAndWithFlags) {
   rootfs.resize(rootfs_size);
   for (size_t n = 0; n < rootfs_size; n++)
     rootfs[n] = uint8_t(n);
-  base::FilePath rootfs_path = testdir_.Append("rootfs.bin");
+  std::filesystem::path rootfs_path = testdir_ / "rootfs.bin";
   EXPECT_EQ(rootfs_size,
             static_cast<const size_t>(
-                base::WriteFile(rootfs_path,
+                base::WriteFile(base::FilePath(rootfs_path.c_str()),
                                 reinterpret_cast<const char*>(rootfs.data()),
                                 rootfs.size())));
 
@@ -2225,7 +2205,7 @@ TEST_F(AvbToolTest, CalculateKernelCmdlineChainedAndWithFlags) {
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa2048.pem"
       " --output %s",
-      pk_path.value().c_str());
+      pk_path.c_str());
 
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer --salt d00df00d --image %s "
@@ -2234,7 +2214,7 @@ TEST_F(AvbToolTest, CalculateKernelCmdlineChainedAndWithFlags) {
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\" "
                  "--setup_as_rootfs_from_kernel",
-                 rootfs_path.value().c_str(),
+                 rootfs_path.c_str(),
                  (int)partition_size);
   EXPECT_EQ(
       "Footer version:           1.0\n"
@@ -2281,10 +2261,10 @@ TEST_F(AvbToolTest, CalculateKernelCmdlineChainedAndWithFlags) {
       "      Flags:                 2\n"
       "      Kernel Cmdline:        "
       "'root=PARTUUID=$(ANDROID_SYSTEM_PARTUUID)'\n",
-      InfoImage(rootfs_path));
+      InfoImage(rootfs_path.string()));
 
   // Chain to the rootfs.img and include two cmdline descriptors.
-  base::FilePath vbmeta_path = testdir_.Append("vbmeta.bin");
+  std::filesystem::path vbmeta_path = testdir_ / "vbmeta.bin";
   EXPECT_COMMAND(0,
                  "./avbtool.py make_vbmeta_image "
                  "--output %s "
@@ -2294,8 +2274,8 @@ TEST_F(AvbToolTest, CalculateKernelCmdlineChainedAndWithFlags) {
                  "--algorithm SHA256_RSA2048 "
                  "--key test/data/testkey_rsa2048.pem "
                  "--internal_release_string \"\"",
-                 vbmeta_path.value().c_str(),
-                 pk_path.value().c_str());
+                 vbmeta_path.c_str(),
+                 pk_path.c_str());
   EXPECT_EQ(
       "Minimum libavb version:   1.0\n"
       "Header Block:             256 bytes\n"
@@ -2320,18 +2300,18 @@ TEST_F(AvbToolTest, CalculateKernelCmdlineChainedAndWithFlags) {
       "    Kernel Cmdline descriptor:\n"
       "      Flags:                 0\n"
       "      Kernel Cmdline:        'second cmdline'\n",
-      InfoImage(vbmeta_path));
+      InfoImage(vbmeta_path.string()));
 
-  base::FilePath out_path = testdir_.Append("out.txt");
+  std::filesystem::path out_path = testdir_ / "out.txt";
   std::string out;
 
   // First check the kernel cmdline without --hashtree_disabled - compare with
   // above info_image output.
   EXPECT_COMMAND(0,
                  "./avbtool.py calculate_kernel_cmdline --image %s > %s",
-                 vbmeta_path.value().c_str(),
-                 out_path.value().c_str());
-  ASSERT_TRUE(base::ReadFileToString(out_path, &out));
+                 vbmeta_path.c_str(),
+                 out_path.c_str());
+  ASSERT_TRUE(android::base::ReadFileToString(out_path.string(), &out));
   EXPECT_EQ(
       "dm=\"1 vroot none ro 1,0 2056 verity 1 "
       "PARTUUID=$(ANDROID_SYSTEM_PARTUUID) PARTUUID=$(ANDROID_SYSTEM_PARTUUID) "
@@ -2344,12 +2324,12 @@ TEST_F(AvbToolTest, CalculateKernelCmdlineChainedAndWithFlags) {
 
   // Then check the kernel cmdline with --hashtree_disabled - compare with above
   // info_image output.
-  EXPECT_COMMAND(
-      0,
-      "./avbtool.py calculate_kernel_cmdline --image %s --hashtree_disabled > %s",
-      vbmeta_path.value().c_str(),
-      out_path.value().c_str());
-  ASSERT_TRUE(base::ReadFileToString(out_path, &out));
+  EXPECT_COMMAND(0,
+                 "./avbtool.py calculate_kernel_cmdline --image %s "
+                 "--hashtree_disabled > %s",
+                 vbmeta_path.c_str(),
+                 out_path.c_str());
+  ASSERT_TRUE(android::base::ReadFileToString(out_path.string(), &out));
   EXPECT_EQ(
       "root=PARTUUID=$(ANDROID_SYSTEM_PARTUUID) foo bar baz second cmdline",
       out);
@@ -2364,11 +2344,11 @@ TEST_F(AvbToolTest, AddHashFooterSmallImageWithExternalVbmeta) {
     image[n] = uint8_t(n);
   }
 
-  base::FilePath ext_vbmeta_path = testdir_.Append("ext_vbmeta.bin");
-  base::FilePath image_path = testdir_.Append("kernel.bin");
+  std::filesystem::path ext_vbmeta_path = testdir_ / "ext_vbmeta.bin";
+  std::filesystem::path image_path = testdir_ / "kernel.bin";
   EXPECT_EQ(image_size,
             static_cast<const size_t>(
-                base::WriteFile(image_path,
+                base::WriteFile(base::FilePath(image_path.c_str()),
                                 reinterpret_cast<const char*>(image.data()),
                                 image.size())));
   EXPECT_COMMAND(0,
@@ -2380,21 +2360,22 @@ TEST_F(AvbToolTest, AddHashFooterSmallImageWithExternalVbmeta) {
                  "--output_vbmeta %s "
                  "--do_not_append_vbmeta_image "
                  "--internal_release_string \"\"",
-                 image_path.value().c_str(),
+                 image_path.c_str(),
                  partition_size,
-                 ext_vbmeta_path.value().c_str());
+                 ext_vbmeta_path.c_str());
 
   // It is not this unit test's job to check the vbmeta content.
 
   int64_t file_size;
-  ASSERT_TRUE(base::GetFileSize(image_path, &file_size));
+  ASSERT_TRUE(
+      base::GetFileSize(base::FilePath(image_path.c_str()), &file_size));
   EXPECT_EQ(static_cast<size_t>(file_size), image_size);
 }
 
 TEST_F(AvbToolTest, IncludeDescriptor) {
-  base::FilePath vbmeta1_path = testdir_.Append("vbmeta_id1.bin");
-  base::FilePath vbmeta2_path = testdir_.Append("vbmeta_id2.bin");
-  base::FilePath vbmeta3_path = testdir_.Append("vbmeta_id3.bin");
+  std::filesystem::path vbmeta1_path = testdir_ / "vbmeta_id1.bin";
+  std::filesystem::path vbmeta2_path = testdir_ / "vbmeta_id2.bin";
+  std::filesystem::path vbmeta3_path = testdir_ / "vbmeta_id3.bin";
 
   EXPECT_COMMAND(0,
                  "./avbtool.py make_vbmeta_image "
@@ -2402,7 +2383,7 @@ TEST_F(AvbToolTest, IncludeDescriptor) {
                  "--kernel_cmdline 'something' "
                  "--prop name:value "
                  "--internal_release_string \"\"",
-                 vbmeta1_path.value().c_str());
+                 vbmeta1_path.c_str());
 
   EXPECT_COMMAND(0,
                  "./avbtool.py make_vbmeta_image "
@@ -2410,7 +2391,7 @@ TEST_F(AvbToolTest, IncludeDescriptor) {
                  "--prop name2:value2 "
                  "--prop name3:value3 "
                  "--internal_release_string \"\"",
-                 vbmeta2_path.value().c_str());
+                 vbmeta2_path.c_str());
 
   EXPECT_COMMAND(0,
                  "./avbtool.py make_vbmeta_image "
@@ -2419,9 +2400,9 @@ TEST_F(AvbToolTest, IncludeDescriptor) {
                  "--include_descriptors_from_image %s "
                  "--include_descriptors_from_image %s "
                  "--internal_release_string \"\"",
-                 vbmeta3_path.value().c_str(),
-                 vbmeta1_path.value().c_str(),
-                 vbmeta2_path.value().c_str());
+                 vbmeta3_path.c_str(),
+                 vbmeta1_path.c_str(),
+                 vbmeta2_path.c_str());
 
   ASSERT_EQ(
       "Minimum libavb version:   1.0\n"
@@ -2441,19 +2422,19 @@ TEST_F(AvbToolTest, IncludeDescriptor) {
       "      Kernel Cmdline:        'something'\n"
       "    Prop: name2 -> 'value2'\n"
       "    Prop: name3 -> 'value3'\n",
-      InfoImage(vbmeta3_path));
+      InfoImage(vbmeta3_path.string()));
 }
 
 TEST_F(AvbToolTest, ChainedPartition) {
-  base::FilePath vbmeta_path = testdir_.Append("vbmeta_cp.bin");
+  std::filesystem::path vbmeta_path = testdir_ / "vbmeta_cp.bin";
 
-  base::FilePath pk_path = testdir_.Append("testkey_rsa2048.avbpubkey");
+  std::filesystem::path pk_path = testdir_ / "testkey_rsa2048.avbpubkey";
 
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa2048.pem"
       " --output %s",
-      pk_path.value().c_str());
+      pk_path.c_str());
 
   EXPECT_COMMAND(
       0,
@@ -2462,8 +2443,8 @@ TEST_F(AvbToolTest, ChainedPartition) {
       "--chain_partition system:1:%s "
       "--algorithm SHA256_RSA2048 --key test/data/testkey_rsa2048.pem "
       "--internal_release_string \"\"",
-      vbmeta_path.value().c_str(),
-      pk_path.value().c_str());
+      vbmeta_path.c_str(),
+      pk_path.c_str());
 
   ASSERT_EQ(
       "Minimum libavb version:   1.0\n"
@@ -2483,11 +2464,12 @@ TEST_F(AvbToolTest, ChainedPartition) {
       "      Public key (sha1):       "
       "cdbb77177f731920bbe0a0f94f84d9038ae0617d\n"
       "      Flags:                   0\n",
-      InfoImage(vbmeta_path));
+      InfoImage(vbmeta_path.string()));
 
   // Now check the VBMeta image.
   std::string image_data;
-  ASSERT_TRUE(base::ReadFileToString(vbmeta_path, &image_data));
+  ASSERT_TRUE(
+      android::base::ReadFileToString(vbmeta_path.string(), &image_data));
 
   const uint8_t* vbmeta_data =
       reinterpret_cast<const uint8_t*>(image_data.data());
@@ -2504,7 +2486,7 @@ TEST_F(AvbToolTest, ChainedPartition) {
   EXPECT_EQ(1UL, descriptors.size());
 
   std::string pk_data;
-  ASSERT_TRUE(base::ReadFileToString(pk_path, &pk_data));
+  ASSERT_TRUE(android::base::ReadFileToString(pk_path.string(), &pk_data));
 
   AvbChainPartitionDescriptor d;
   EXPECT_EQ(AVB_DESCRIPTOR_TAG_CHAIN_PARTITION,
@@ -2528,15 +2510,15 @@ TEST_F(AvbToolTest, ChainedPartition) {
 }
 
 TEST_F(AvbToolTest, ChainedPartitionNoAB) {
-  base::FilePath vbmeta_path = testdir_.Append("vbmeta_cp.bin");
+  std::filesystem::path vbmeta_path = testdir_ / "vbmeta_cp.bin";
 
-  base::FilePath pk_path = testdir_.Append("testkey_rsa2048.avbpubkey");
+  std::filesystem::path pk_path = testdir_ / "testkey_rsa2048.avbpubkey";
 
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa2048.pem"
       " --output %s",
-      pk_path.value().c_str());
+      pk_path.c_str());
 
   EXPECT_COMMAND(
       0,
@@ -2545,8 +2527,8 @@ TEST_F(AvbToolTest, ChainedPartitionNoAB) {
       "--chain_partition_do_not_use_ab system:1:%s "
       "--algorithm SHA256_RSA2048 --key test/data/testkey_rsa2048.pem "
       "--internal_release_string \"\"",
-      vbmeta_path.value().c_str(),
-      pk_path.value().c_str());
+      vbmeta_path.c_str(),
+      pk_path.c_str());
 
   ASSERT_EQ(
       "Minimum libavb version:   1.3\n"
@@ -2566,11 +2548,12 @@ TEST_F(AvbToolTest, ChainedPartitionNoAB) {
       "      Public key (sha1):       "
       "cdbb77177f731920bbe0a0f94f84d9038ae0617d\n"
       "      Flags:                   1\n",
-      InfoImage(vbmeta_path));
+      InfoImage(vbmeta_path.string()));
 
   // Now check the VBMeta image.
   std::string image_data;
-  ASSERT_TRUE(base::ReadFileToString(vbmeta_path, &image_data));
+  ASSERT_TRUE(
+      android::base::ReadFileToString(vbmeta_path.string(), &image_data));
 
   const uint8_t* vbmeta_data =
       reinterpret_cast<const uint8_t*>(image_data.data());
@@ -2587,7 +2570,7 @@ TEST_F(AvbToolTest, ChainedPartitionNoAB) {
   EXPECT_EQ(1UL, descriptors.size());
 
   std::string pk_data;
-  ASSERT_TRUE(base::ReadFileToString(pk_path, &pk_data));
+  ASSERT_TRUE(android::base::ReadFileToString(pk_path.string(), &pk_data));
 
   AvbChainPartitionDescriptor d;
   EXPECT_EQ(AVB_DESCRIPTOR_TAG_CHAIN_PARTITION,
@@ -2611,15 +2594,15 @@ TEST_F(AvbToolTest, ChainedPartitionNoAB) {
 }
 
 TEST_F(AvbToolTest, ChainedPartitionNoLocationCollision) {
-  base::FilePath vbmeta_path = testdir_.Append("vbmeta_cp.bin");
+  std::filesystem::path vbmeta_path = testdir_ / "vbmeta_cp.bin";
 
-  base::FilePath pk_path = testdir_.Append("testkey_rsa2048.avbpubkey");
+  std::filesystem::path pk_path = testdir_ / "testkey_rsa2048.avbpubkey";
 
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa2048.pem"
       " --output %s",
-      pk_path.value().c_str());
+      pk_path.c_str());
 
   // Check that avbtool bails if the same Rollback Index Location is
   // used for multiple chained partitions.
@@ -2631,20 +2614,20 @@ TEST_F(AvbToolTest, ChainedPartitionNoLocationCollision) {
       "--chain_partition other:1:%s "
       "--algorithm SHA256_RSA2048 --key test/data/testkey_rsa2048.pem "
       "--internal_release_string \"\"",
-      vbmeta_path.value().c_str(),
-      pk_path.value().c_str(),
-      pk_path.value().c_str());
+      vbmeta_path.c_str(),
+      pk_path.c_str(),
+      pk_path.c_str());
 }
 
 TEST_F(AvbToolTest, AppendVBMetaImage) {
   size_t boot_size = 5 * 1024 * 1024;
   size_t boot_partition_size = 32 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot", boot_size);
+  std::string boot_path = GenerateImage("boot", boot_size);
 
   GenerateVBMetaImage("vbmeta.img",
                       "SHA256_RSA2048",
                       0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
+                      "test/data/testkey_rsa2048.pem",
                       std::string("--append_to_release_string \"\" "
                                   "--kernel_cmdline foo"));
 
@@ -2653,11 +2636,11 @@ TEST_F(AvbToolTest, AppendVBMetaImage) {
                  "--image %s "
                  "--partition_size %d "
                  "--vbmeta_image %s ",
-                 boot_path.value().c_str(),
+                 boot_path.c_str(),
                  (int)boot_partition_size,
-                 vbmeta_image_path_.value().c_str());
+                 vbmeta_image_path_.c_str());
 
-  std::string vbmeta_contents = InfoImage(vbmeta_image_path_);
+  std::string vbmeta_contents = InfoImage(vbmeta_image_path_.string());
   std::string boot_contents = InfoImage(boot_path);
 
   // Check that boot.img has the same vbmeta blob as from vbmeta.img -
@@ -2690,8 +2673,8 @@ TEST_F(AvbToolTest, AppendVBMetaImage) {
   ASSERT_EQ(known_footer + vbmeta_contents, boot_contents);
 
   // Also verify that the blobs are the same, bit for bit.
-  base::File f =
-      base::File(boot_path, base::File::FLAG_OPEN | base::File::FLAG_READ);
+  base::File f = base::File(base::FilePath(boot_path),
+                            base::File::FLAG_OPEN | base::File::FLAG_READ);
   std::vector<uint8_t> loaded_vbmeta;
   loaded_vbmeta.resize(1152);
   EXPECT_EQ(
@@ -2702,9 +2685,9 @@ TEST_F(AvbToolTest, AppendVBMetaImage) {
 }
 
 TEST_F(AvbToolTest, SigningHelperBasic) {
-  base::FilePath vbmeta_path = testdir_.Append("vbmeta.bin");
-  base::FilePath signing_helper_test_path =
-      testdir_.Append("signing_helper_test");
+  std::filesystem::path vbmeta_path = testdir_ / "vbmeta.bin";
+  std::filesystem::path signing_helper_test_path =
+      testdir_ / "signing_helper_test";
   EXPECT_COMMAND(
       0,
       "SIGNING_HELPER_TEST=\"%s\" ./avbtool.py make_vbmeta_image "
@@ -2712,19 +2695,20 @@ TEST_F(AvbToolTest, SigningHelperBasic) {
       "--algorithm SHA256_RSA2048 --key test/data/testkey_rsa2048.pem "
       "--signing_helper test/avbtool_signing_helper_test.py "
       "--internal_release_string \"\"",
-      signing_helper_test_path.value().c_str(),
-      vbmeta_path.value().c_str());
+      signing_helper_test_path.c_str(),
+      vbmeta_path.c_str());
 
   // Now check the value in test file.
   std::string value;
-  ASSERT_TRUE(base::ReadFileToString(signing_helper_test_path, &value));
+  ASSERT_TRUE(android::base::ReadFileToString(signing_helper_test_path.string(),
+                                              &value));
   EXPECT_EQ("DONE", value);
 }
 
 TEST_F(AvbToolTest, SigningHelperWithFilesBasic) {
-  base::FilePath vbmeta_path = testdir_.Append("vbmeta.bin");
-  base::FilePath signing_helper_test_path =
-      testdir_.Append("signing_helper_test");
+  std::filesystem::path vbmeta_path = testdir_ / "vbmeta.bin";
+  std::filesystem::path signing_helper_test_path =
+      testdir_ / "signing_helper_test";
   EXPECT_COMMAND(
       0,
       "SIGNING_HELPER_TEST=\"%s\" ./avbtool.py make_vbmeta_image "
@@ -2733,17 +2717,18 @@ TEST_F(AvbToolTest, SigningHelperWithFilesBasic) {
       "--signing_helper_with_files "
       "test/avbtool_signing_helper_with_files_test.py "
       "--internal_release_string \"\"",
-      signing_helper_test_path.value().c_str(),
-      vbmeta_path.value().c_str());
+      signing_helper_test_path.c_str(),
+      vbmeta_path.c_str());
 
   // Now check the value in test file.
   std::string value;
-  ASSERT_TRUE(base::ReadFileToString(signing_helper_test_path, &value));
+  ASSERT_TRUE(android::base::ReadFileToString(signing_helper_test_path.string(),
+                                              &value));
   EXPECT_EQ("DONE", value);
 }
 
 TEST_F(AvbToolTest, SigningHelperReturnError) {
-  base::FilePath vbmeta_path = testdir_.Append("vbmeta.bin");
+  std::filesystem::path vbmeta_path = testdir_ / "vbmeta.bin";
   EXPECT_COMMAND(
       1,
       "./avbtool.py make_vbmeta_image "
@@ -2751,11 +2736,11 @@ TEST_F(AvbToolTest, SigningHelperReturnError) {
       "--algorithm SHA256_RSA2048 --key test/data/testkey_rsa2048.pem "
       "--signing_helper test/avbtool_signing_helper_test.py "
       "--internal_release_string \"\"",
-      vbmeta_path.value().c_str());
+      vbmeta_path.c_str());
 }
 
 TEST_F(AvbToolTest, SigningHelperWithFilesReturnError) {
-  base::FilePath vbmeta_path = testdir_.Append("vbmeta.bin");
+  std::filesystem::path vbmeta_path = testdir_ / "vbmeta.bin";
   EXPECT_COMMAND(
       1,
       "./avbtool.py make_vbmeta_image "
@@ -2764,38 +2749,34 @@ TEST_F(AvbToolTest, SigningHelperWithFilesReturnError) {
       "--signing_helper_with_files "
       "test/avbtool_signing_helper_with_files_test.py "
       "--internal_release_string \"\"",
-      vbmeta_path.value().c_str());
+      vbmeta_path.c_str());
 }
 
 TEST_F(AvbToolTest, VerifyImageNoSignature) {
   GenerateVBMetaImage("vbmeta.img",
                       "",  // NONE
                       0,
-                      base::FilePath());
+                      "");
 
   EXPECT_COMMAND(0,
                  "./avbtool.py verify_image "
                  "--image %s ",
-                 vbmeta_image_path_.value().c_str());
+                 vbmeta_image_path_.c_str());
 }
 
 TEST_F(AvbToolTest, VerifyImageValidSignature) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
 
   EXPECT_COMMAND(0,
                  "./avbtool.py verify_image "
                  "--image %s ",
-                 vbmeta_image_path_.value().c_str());
+                 vbmeta_image_path_.c_str());
 }
 
 TEST_F(AvbToolTest, VerifyImageCorruptedVBMeta) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
 
   // Corrupt four bytes of data in the end of the image. Since the aux
   // data is at the end and this data is signed, this will change the
@@ -2811,59 +2792,56 @@ TEST_F(AvbToolTest, VerifyImageCorruptedVBMeta) {
   EXPECT_COMMAND(1,
                  "./avbtool.py verify_image "
                  "--image %s ",
-                 vbmeta_image_path_.value().c_str());
+                 vbmeta_image_path_.c_str());
 }
 
 TEST_F(AvbToolTest, VerifyImageOtherKeyMatching) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
 
   EXPECT_COMMAND(0,
                  "./avbtool.py verify_image "
                  "--image %s --key test/data/testkey_rsa2048.pem",
-                 vbmeta_image_path_.value().c_str());
+                 vbmeta_image_path_.c_str());
 }
 
 TEST_F(AvbToolTest, VerifyImageOtherKeyNotMatching) {
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"));
+  GenerateVBMetaImage(
+      "vbmeta.img", "SHA256_RSA2048", 0, "test/data/testkey_rsa2048.pem");
 
   EXPECT_COMMAND(1,
                  "./avbtool.py verify_image "
                  "--image %s --key test/data/testkey_rsa4096.pem",
-                 vbmeta_image_path_.value().c_str());
+                 vbmeta_image_path_.c_str());
 }
 
 TEST_F(AvbToolTest, VerifyImageBrokenSignature) {
-  base::FilePath vbmeta_path = testdir_.Append("vbmeta.bin");
-  base::FilePath signing_helper_test_path =
-      testdir_.Append("signing_helper_test");
+  std::filesystem::path vbmeta_path = testdir_ / "vbmeta.bin";
+  std::filesystem::path signing_helper_test_path =
+      testdir_ / "signing_helper_test";
 
   // Intentionally make the signer generate a wrong signature.
   EXPECT_COMMAND(
       0,
-      "SIGNING_HELPER_GENERATE_WRONG_SIGNATURE=1 ./avbtool.py make_vbmeta_image "
+      "SIGNING_HELPER_GENERATE_WRONG_SIGNATURE=1 ./avbtool.py "
+      "make_vbmeta_image "
       "--output %s "
       "--algorithm SHA256_RSA2048 --key test/data/testkey_rsa2048.pem "
       "--signing_helper test/avbtool_signing_helper_test.py "
       "--internal_release_string \"\"",
-      vbmeta_path.value().c_str());
+      vbmeta_path.c_str());
 
   EXPECT_COMMAND(1,
                  "./avbtool.py verify_image "
                  "--image %s ",
-                 vbmeta_path.value().c_str());
+                 vbmeta_path.c_str());
 }
 
 // Helper to generate boot.img, unsparse system.img, and vbmeta.img.
 void AvbToolTest::GenerateImageWithHashAndHashtreeSetup() {
   const size_t boot_partition_size = 16 * 1024 * 1024;
   const size_t boot_image_size = 5 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot.img", boot_image_size);
+  std::string boot_path = GenerateImage("boot.img", boot_image_size);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hash_footer"
                  " --image %s"
@@ -2872,27 +2850,28 @@ void AvbToolTest::GenerateImageWithHashAndHashtreeSetup() {
                  " --partition_size %zd"
                  " --salt deadbeef"
                  " --internal_release_string \"\"",
-                 boot_path.value().c_str(),
+                 boot_path.c_str(),
                  boot_partition_size);
 
   const size_t system_partition_size = 10 * 1024 * 1024;
   const size_t system_image_size = 8 * 1024 * 1024;
-  base::FilePath system_path = GenerateImage("system.img", system_image_size);
+  std::string system_path = GenerateImage("system.img", system_image_size);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer --salt d00df00d --image %s "
                  "--partition_size %zd --partition_name system "
                  "--internal_release_string \"\" ",
-                 system_path.value().c_str(),
+                 system_path.c_str(),
                  system_partition_size);
 
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
-                      base::StringPrintf("--include_descriptors_from_image %s "
-                                         "--include_descriptors_from_image %s",
-                                         boot_path.value().c_str(),
-                                         system_path.value().c_str()));
+  GenerateVBMetaImage(
+      "vbmeta.img",
+      "SHA256_RSA2048",
+      0,
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--include_descriptors_from_image %s "
+                                  "--include_descriptors_from_image %s",
+                                  boot_path.c_str(),
+                                  system_path.c_str()));
 }
 
 TEST_F(AvbToolTest, VerifyImageWithHashAndHashtree) {
@@ -2904,16 +2883,16 @@ TEST_F(AvbToolTest, VerifyImageWithHashAndHashtree) {
     EXPECT_COMMAND(0,
                    "./avbtool.py verify_image "
                    "--image %s ",
-                   vbmeta_image_path_.value().c_str());
+                   vbmeta_image_path_.c_str());
     if (n == 0) {
       EXPECT_COMMAND(0,
                      "img2simg %s %s.sparse",
-                     testdir_.Append("system.img").value().c_str(),
-                     testdir_.Append("system.img").value().c_str());
+                     (testdir_ / "system.img").c_str(),
+                     (testdir_ / "system.img").c_str());
       EXPECT_COMMAND(0,
                      "mv %s.sparse %s",
-                     testdir_.Append("system.img").value().c_str(),
-                     testdir_.Append("system.img").value().c_str());
+                     (testdir_ / "system.img").c_str(),
+                     (testdir_ / "system.img").c_str());
     }
   }
 }
@@ -2921,63 +2900,66 @@ TEST_F(AvbToolTest, VerifyImageWithHashAndHashtree) {
 TEST_F(AvbToolTest, VerifyImageWithHashAndZeroedHashtree) {
   const size_t system_partition_size = 10 * 1024 * 1024;
   const size_t system_image_size = 8 * 1024 * 1024;
-  base::FilePath system_path = GenerateImage("system.img", system_image_size);
+  std::string system_path = GenerateImage("system.img", system_image_size);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer --salt d00df00d --image %s "
                  "--partition_size %zd --partition_name system "
                  "--internal_release_string \"\" ",
-                 system_path.value().c_str(),
+                 system_path.c_str(),
                  system_partition_size);
 
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
-                      base::StringPrintf("--include_descriptors_from_image %s ",
-                                         system_path.value().c_str()));
+  GenerateVBMetaImage(
+      "vbmeta.img",
+      "SHA256_RSA2048",
+      0,
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--include_descriptors_from_image %s ",
+                                  system_path.c_str()));
 
-  EXPECT_COMMAND(0,
-                 "./avbtool.py verify_image --image %s --accept_zeroed_hashtree",
-                 vbmeta_image_path_.value().c_str());
+  EXPECT_COMMAND(
+      0,
+      "./avbtool.py verify_image --image %s --accept_zeroed_hashtree",
+      vbmeta_image_path_.c_str());
 
   EXPECT_COMMAND(
-      0, "./avbtool.py zero_hashtree --image %s", system_path.value().c_str());
+      0, "./avbtool.py zero_hashtree --image %s", system_path.c_str());
 
-  EXPECT_COMMAND(1,
-                 "./avbtool.py verify_image --image %s",
-                 vbmeta_image_path_.value().c_str());
+  EXPECT_COMMAND(
+      1, "./avbtool.py verify_image --image %s", vbmeta_image_path_.c_str());
 
-  EXPECT_COMMAND(0,
-                 "./avbtool.py verify_image --image %s --accept_zeroed_hashtree",
-                 vbmeta_image_path_.value().c_str());
+  EXPECT_COMMAND(
+      0,
+      "./avbtool.py verify_image --image %s --accept_zeroed_hashtree",
+      vbmeta_image_path_.c_str());
 }
 
 TEST_F(AvbToolTest, VerifyImageWithNoHashtree) {
   const size_t system_partition_size = 10 * 1024 * 1024;
   const size_t system_image_size = 8 * 1024 * 1024;
-  base::FilePath system_path = GenerateImage("system.img", system_image_size);
+  std::string system_path = GenerateImage("system.img", system_image_size);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer --salt d00df00d --image %s "
                  "--partition_size %zd --partition_name system "
                  "--no_hashtree "
                  "--internal_release_string \"\" ",
-                 system_path.value().c_str(),
+                 system_path.c_str(),
                  system_partition_size);
 
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
-                      base::StringPrintf("--include_descriptors_from_image %s ",
-                                         system_path.value().c_str()));
+  GenerateVBMetaImage(
+      "vbmeta.img",
+      "SHA256_RSA2048",
+      0,
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--include_descriptors_from_image %s ",
+                                  system_path.c_str()));
 
-  EXPECT_COMMAND(1,
-                 "./avbtool.py verify_image --image %s",
-                 vbmeta_image_path_.value().c_str());
+  EXPECT_COMMAND(
+      1, "./avbtool.py verify_image --image %s", vbmeta_image_path_.c_str());
 
-  EXPECT_COMMAND(0,
-                 "./avbtool.py verify_image --image %s --accept_zeroed_hashtree",
-                 vbmeta_image_path_.value().c_str());
+  EXPECT_COMMAND(
+      0,
+      "./avbtool.py verify_image --image %s --accept_zeroed_hashtree",
+      vbmeta_image_path_.c_str());
 }
 
 TEST_F(AvbToolTest, VerifyImageWithHashAndHashtreeCorruptHash) {
@@ -2995,7 +2977,7 @@ TEST_F(AvbToolTest, VerifyImageWithHashAndHashtreeCorruptHash) {
   EXPECT_COMMAND(1,
                  "./avbtool.py verify_image "
                  "--image %s ",
-                 vbmeta_image_path_.value().c_str());
+                 vbmeta_image_path_.c_str());
 }
 
 TEST_F(AvbToolTest, VerifyImageWithHashAndHashtreeCorruptHashtree) {
@@ -3016,106 +2998,108 @@ TEST_F(AvbToolTest, VerifyImageWithHashAndHashtreeCorruptHashtree) {
     EXPECT_COMMAND(1,
                    "./avbtool.py verify_image "
                    "--image %s ",
-                   vbmeta_image_path_.value().c_str());
+                   vbmeta_image_path_.c_str());
     if (n == 0) {
       EXPECT_COMMAND(0,
                      "img2simg %s %s.sparse",
-                     testdir_.Append("system.img").value().c_str(),
-                     testdir_.Append("system.img").value().c_str());
+                     (testdir_ / "system.img").c_str(),
+                     (testdir_ / "system.img").c_str());
       EXPECT_COMMAND(0,
                      "mv %s.sparse %s",
-                     testdir_.Append("system.img").value().c_str(),
-                     testdir_.Append("system.img").value().c_str());
+                     (testdir_ / "system.img").c_str(),
+                     (testdir_ / "system.img").c_str());
     }
   }
 }
 
 TEST_F(AvbToolTest, VerifyImageChainPartition) {
-  base::FilePath pk4096_path = testdir_.Append("testkey_rsa4096.avbpubkey");
+  std::filesystem::path pk4096_path = testdir_ / "testkey_rsa4096.avbpubkey";
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa4096.pem"
       " --output %s",
-      pk4096_path.value().c_str());
+      pk4096_path.c_str());
 
-  base::FilePath pk8192_path = testdir_.Append("testkey_rsa8192.avbpubkey");
+  std::filesystem::path pk8192_path = testdir_ / "testkey_rsa8192.avbpubkey";
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa8192.pem"
       " --output %s",
-      pk8192_path.value().c_str());
+      pk8192_path.c_str());
 
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
-                      base::StringPrintf("--chain_partition system:1:%s ",
-                                         pk4096_path.value().c_str()));
+  GenerateVBMetaImage(
+      "vbmeta.img",
+      "SHA256_RSA2048",
+      0,
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--chain_partition system:1:%s ",
+                                  pk4096_path.c_str()));
 
   // Should not fail (name, rollback_index, contents all correct).
   EXPECT_COMMAND(0,
                  "./avbtool.py verify_image "
                  "--image %s "
                  "--expected_chain_partition system:1:%s",
-                 vbmeta_image_path_.value().c_str(),
-                 pk4096_path.value().c_str());
+                 vbmeta_image_path_.c_str(),
+                 pk4096_path.c_str());
 
   // Should fail because we didn't use --expected_chain_partition.
   EXPECT_COMMAND(1,
                  "./avbtool.py verify_image "
                  "--image %s ",
-                 vbmeta_image_path_.value().c_str());
+                 vbmeta_image_path_.c_str());
 
   // Should fail because partition name is wrong.
   EXPECT_COMMAND(1,
                  "./avbtool.py verify_image "
                  "--image %s "
                  "--expected_chain_partition xyz:1:%s",
-                 vbmeta_image_path_.value().c_str(),
-                 pk4096_path.value().c_str());
+                 vbmeta_image_path_.c_str(),
+                 pk4096_path.c_str());
 
   // Should fail because rollback index location is wrong.
   EXPECT_COMMAND(1,
                  "./avbtool.py verify_image "
                  "--image %s "
                  "--expected_chain_partition system:2:%s",
-                 vbmeta_image_path_.value().c_str(),
-                 pk4096_path.value().c_str());
+                 vbmeta_image_path_.c_str(),
+                 pk4096_path.c_str());
 
   // Should fail because public key blob is wrong.
   EXPECT_COMMAND(1,
                  "./avbtool.py verify_image "
                  "--image %s "
                  "--expected_chain_partition system:1:%s",
-                 vbmeta_image_path_.value().c_str(),
-                 pk8192_path.value().c_str());
+                 vbmeta_image_path_.c_str(),
+                 pk8192_path.c_str());
 }
 
 TEST_F(AvbToolTest, VerifyImageChainPartitionWithFollow) {
-  base::FilePath pk4096_path = testdir_.Append("testkey_rsa4096.avbpubkey");
+  std::filesystem::path pk4096_path = testdir_ / "testkey_rsa4096.avbpubkey";
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa4096.pem"
       " --output %s",
-      pk4096_path.value().c_str());
+      pk4096_path.c_str());
 
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
-                      base::StringPrintf("--chain_partition system:1:%s ",
-                                         pk4096_path.value().c_str()));
+  GenerateVBMetaImage(
+      "vbmeta.img",
+      "SHA256_RSA2048",
+      0,
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--chain_partition system:1:%s ",
+                                  pk4096_path.c_str()));
 
   const size_t system_partition_size = 10 * 1024 * 1024;
   const size_t system_image_size = 8 * 1024 * 1024;
-  base::FilePath system_path = GenerateImage("system.img", system_image_size);
+  std::string system_path = GenerateImage("system.img", system_image_size);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer --salt d00df00d --image %s "
                  "--partition_size %zd --partition_name system "
                  "--algorithm SHA256_RSA4096 "
                  "--key test/data/testkey_rsa4096.pem "
                  "--internal_release_string \"\" ",
-                 system_path.value().c_str(),
+                 system_path.c_str(),
                  system_partition_size);
 
   // Even without --expected_chain_partition this shouldn't fail because we use
@@ -3127,11 +3111,11 @@ TEST_F(AvbToolTest, VerifyImageChainPartitionWithFollow) {
   EXPECT_COMMAND(0,
                  "cd %s && (%s/avbtool.py verify_image "
                  "--image vbmeta.img --follow_chain_partitions > out.txt)",
-                 testdir_.value().c_str(),
+                 testdir_.c_str(),
                  cwdbuf);
-  base::FilePath out_path = testdir_.Append("out.txt");
+  std::filesystem::path out_path = testdir_ / "out.txt";
   std::string out;
-  ASSERT_TRUE(base::ReadFileToString(out_path, &out));
+  ASSERT_TRUE(android::base::ReadFileToString(out_path.string(), &out));
   EXPECT_EQ(
       "Verifying image vbmeta.img using embedded public key\n"
       "vbmeta: Successfully verified SHA256_RSA2048 vbmeta struct in "
@@ -3152,10 +3136,10 @@ TEST_F(AvbToolTest, VerifyImageChainPartitionWithFollow) {
                  "cd %s && (%s/avbtool.py verify_image "
                  "--image vbmeta.img --expected_chain_partition system:1:%s "
                  "--follow_chain_partitions > out.txt)",
-                 testdir_.value().c_str(),
+                 testdir_.c_str(),
                  cwdbuf,
-                 pk4096_path.value().c_str());
-  ASSERT_TRUE(base::ReadFileToString(out_path, &out));
+                 pk4096_path.c_str());
+  ASSERT_TRUE(android::base::ReadFileToString(out_path.string(), &out));
   EXPECT_EQ(
       "Verifying image vbmeta.img using embedded public key\n"
       "vbmeta: Successfully verified SHA256_RSA2048 vbmeta struct in "
@@ -3172,82 +3156,82 @@ TEST_F(AvbToolTest, VerifyImageChainPartitionWithFollow) {
 }
 
 TEST_F(AvbToolTest, VerifyImageChainPartitionOtherVBMeta) {
-  base::FilePath pk4096_path = testdir_.Append("testkey_rsa4096.avbpubkey");
+  std::filesystem::path pk4096_path = testdir_ / "testkey_rsa4096.avbpubkey";
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa4096.pem"
       " --output %s",
-      pk4096_path.value().c_str());
+      pk4096_path.c_str());
 
   const size_t system_partition_size = 10 * 1024 * 1024;
   const size_t system_image_size = 8 * 1024 * 1024;
-  base::FilePath system_path = GenerateImage("system.img", system_image_size);
+  std::string system_path = GenerateImage("system.img", system_image_size);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer --salt d00df00d --image %s "
                  "--partition_size %zd --partition_name system "
                  "--internal_release_string \"\" "
                  "--algorithm SHA256_RSA4096 "
                  "--key test/data/testkey_rsa4096.pem ",
-                 system_path.value().c_str(),
+                 system_path.c_str(),
                  system_partition_size,
-                 pk4096_path.value().c_str());
+                 pk4096_path.c_str());
 
   GenerateVBMetaImage(
       "vbmeta.img",
       "SHA256_RSA2048",
       0,
-      base::FilePath("test/data/testkey_rsa2048.pem"),
-      base::StringPrintf("--chain_partition vbmeta_google:1:%s ",
-                         pk4096_path.value().c_str()));
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--chain_partition vbmeta_google:1:%s ",
+                                  pk4096_path.c_str()));
 
   // Should not fail (name, rollback_index, contents all correct).
   EXPECT_COMMAND(0,
                  "./avbtool.py verify_image "
                  "--image %s "
                  "--expected_chain_partition vbmeta_google:1:%s",
-                 vbmeta_image_path_.value().c_str(),
-                 pk4096_path.value().c_str());
+                 vbmeta_image_path_.c_str(),
+                 pk4096_path.c_str());
 
   // Should not fail (looks in system.img image).
   EXPECT_COMMAND(0,
                  "./avbtool.py verify_image "
                  "--image %s ",
-                 system_path.value().c_str());
+                 system_path.c_str());
 
   // Extract the vbmeta blob from the footer in system.img, put it into
   // vbmeta_google.img, and erase the footer from system.img (but keep
   // the hash tree in system.img)
-  base::FilePath vbmeta_google_path = GenerateImage("vbmeta_google.img", 0);
+  std::string vbmeta_google_path = GenerateImage("vbmeta_google.img", 0);
   EXPECT_COMMAND(0,
                  "./avbtool.py extract_vbmeta_image"
                  " --image %s"
                  " --output %s",
-                 system_path.value().c_str(),
-                 vbmeta_google_path.value().c_str());
+                 system_path.c_str(),
+                 vbmeta_google_path.c_str());
   EXPECT_COMMAND(0,
                  "./avbtool.py erase_footer"
                  " --image %s --keep_hashtree",
-                 system_path.value().c_str());
+                 system_path.c_str());
 
   // Should not fail - looks in system.img's detached vbmeta (vbmeta_google.img)
   // for vbmeta blob and system.img for the actual hashtree.
   EXPECT_COMMAND(0,
                  "./avbtool.py verify_image "
                  "--image %s ",
-                 vbmeta_google_path.value().c_str());
+                 vbmeta_google_path.c_str());
 }
 
 TEST_F(AvbToolTest, PrintPartitionDigests) {
-  base::FilePath pk4096_path = testdir_.Append("testkey_rsa4096.avbpubkey");
+  std::filesystem::path pk4096_path = testdir_ / "testkey_rsa4096.avbpubkey";
   EXPECT_COMMAND(
       0,
       "./avbtool.py extract_public_key --key test/data/testkey_rsa4096.pem"
       " --output %s",
-      pk4096_path.value().c_str());
+      pk4096_path.c_str());
 
   const size_t boot_partition_size = 16 * 1024 * 1024;
   const size_t boot_image_size = 5 * 1024 * 1024;
-  base::FilePath boot_path = GenerateImage("boot.img", boot_image_size);
+  std::string boot_path = GenerateImage("boot.img", boot_image_size);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hash_footer"
                  " --image %s"
@@ -3256,39 +3240,40 @@ TEST_F(AvbToolTest, PrintPartitionDigests) {
                  " --partition_size %zd"
                  " --salt deadbeef"
                  " --internal_release_string \"\"",
-                 boot_path.value().c_str(),
+                 boot_path.c_str(),
                  boot_partition_size);
 
-  GenerateVBMetaImage("vbmeta.img",
-                      "SHA256_RSA2048",
-                      0,
-                      base::FilePath("test/data/testkey_rsa2048.pem"),
-                      base::StringPrintf("--chain_partition system:1:%s "
-                                         "--include_descriptors_from_image %s",
-                                         pk4096_path.value().c_str(),
-                                         boot_path.value().c_str()));
+  GenerateVBMetaImage(
+      "vbmeta.img",
+      "SHA256_RSA2048",
+      0,
+      "test/data/testkey_rsa2048.pem",
+      android::base::StringPrintf("--chain_partition system:1:%s "
+                                  "--include_descriptors_from_image %s",
+                                  pk4096_path.c_str(),
+                                  boot_path.c_str()));
 
   const size_t system_partition_size = 10 * 1024 * 1024;
   const size_t system_image_size = 8 * 1024 * 1024;
-  base::FilePath system_path = GenerateImage("system.img", system_image_size);
+  std::string system_path = GenerateImage("system.img", system_image_size);
   EXPECT_COMMAND(0,
                  "./avbtool.py add_hashtree_footer --salt d00df00d --image %s "
                  "--partition_size %zd --partition_name system "
                  "--algorithm SHA256_RSA4096 "
                  "--key test/data/testkey_rsa4096.pem "
                  "--internal_release_string \"\" ",
-                 system_path.value().c_str(),
+                 system_path.c_str(),
                  system_partition_size);
 
-  base::FilePath out_path = testdir_.Append("out.txt");
+  std::filesystem::path out_path = testdir_ / "out.txt";
   std::string out;
 
   // Normal output
   EXPECT_COMMAND(0,
                  "./avbtool.py print_partition_digests --image %s --output %s",
-                 vbmeta_image_path_.value().c_str(),
-                 out_path.value().c_str());
-  ASSERT_TRUE(base::ReadFileToString(out_path, &out));
+                 vbmeta_image_path_.c_str(),
+                 out_path.c_str());
+  ASSERT_TRUE(android::base::ReadFileToString(out_path.string(), &out));
   EXPECT_EQ(
       "system: d52d93c988d336a79abe1c05240ae9a79a9b7d61\n"
       "boot: "
@@ -3299,9 +3284,9 @@ TEST_F(AvbToolTest, PrintPartitionDigests) {
   EXPECT_COMMAND(
       0,
       "./avbtool.py print_partition_digests --image %s --json --output %s",
-      vbmeta_image_path_.value().c_str(),
-      out_path.value().c_str());
-  ASSERT_TRUE(base::ReadFileToString(out_path, &out));
+      vbmeta_image_path_.c_str(),
+      out_path.c_str());
+  ASSERT_TRUE(android::base::ReadFileToString(out_path.string(), &out));
   // The trailing whitespace comes from python. If they fix that bug we need
   // to update this test...
   EXPECT_EQ(
@@ -3335,7 +3320,7 @@ class AvbToolTest_PrintRequiredVersion : public AvbToolTest {
     }
 
     const size_t boot_partition_size = 16 * 1024 * 1024;
-    base::FilePath output_path = testdir_.Append(kOutputFile);
+    std::filesystem::path output_path = testdir_ / kOutputFile;
     EXPECT_COMMAND(0,
                    "./avbtool.py add_hash_footer"
                    " --rollback_index 0"
@@ -3347,7 +3332,7 @@ class AvbToolTest_PrintRequiredVersion : public AvbToolTest {
                    " --print_required_libavb_version > %s",
                    boot_partition_size,
                    extra_args.c_str(),
-                   output_path.value().c_str());
+                   output_path.c_str());
     CheckVersion(target_required_minor_version);
   }
 
@@ -3360,7 +3345,7 @@ class AvbToolTest_PrintRequiredVersion : public AvbToolTest {
       extra_args = "--rollback_index_location 2";
     }
     const size_t system_partition_size = 10 * 1024 * 1024;
-    base::FilePath output_path = testdir_.Append(kOutputFile);
+    std::filesystem::path output_path = testdir_ / kOutputFile;
     EXPECT_COMMAND(0,
                    "./avbtool.py add_hashtree_footer --salt d00df00d "
                    "--partition_size %zd --partition_name system "
@@ -3369,7 +3354,7 @@ class AvbToolTest_PrintRequiredVersion : public AvbToolTest {
                    " --print_required_libavb_version > %s",
                    system_partition_size,
                    extra_args.c_str(),
-                   output_path.value().c_str());
+                   output_path.c_str());
     CheckVersion(target_required_minor_version);
   }
 
@@ -3378,7 +3363,7 @@ class AvbToolTest_PrintRequiredVersion : public AvbToolTest {
     if (target_required_minor_version == 1) {
       // An included descriptor that requires 1.1 will require 1.1 for vbmeta.
       const size_t boot_partition_size = 16 * 1024 * 1024;
-      base::FilePath image_path = GenerateImage("test_print_version", 1024);
+      std::string image_path = GenerateImage("test_print_version", 1024);
       EXPECT_COMMAND(0,
                      "./avbtool.py add_hash_footer --salt d00df00d "
                      "--hash_algorithm sha256 --image %s "
@@ -3387,15 +3372,15 @@ class AvbToolTest_PrintRequiredVersion : public AvbToolTest {
                      "--key test/data/testkey_rsa2048.pem "
                      "--internal_release_string \"\" "
                      "--do_not_use_ab",
-                     image_path.value().c_str(),
+                     image_path.c_str(),
                      (int)boot_partition_size);
-      extra_args = base::StringPrintf("--include_descriptors_from_image %s",
-                                      image_path.value().c_str());
+      extra_args = android::base::StringPrintf(
+          "--include_descriptors_from_image %s", image_path.c_str());
     } else if (target_required_minor_version == 2) {
       extra_args = "--rollback_index_location 2";
     }
 
-    base::FilePath output_path = testdir_.Append(kOutputFile);
+    std::filesystem::path output_path = testdir_ / kOutputFile;
     EXPECT_COMMAND(0,
                    "./avbtool.py make_vbmeta_image "
                    "--algorithm SHA256_RSA2048 "
@@ -3404,16 +3389,17 @@ class AvbToolTest_PrintRequiredVersion : public AvbToolTest {
                    " %s"
                    " --print_required_libavb_version > %s",
                    extra_args.c_str(),
-                   output_path.value().c_str());
+                   output_path.c_str());
     CheckVersion(target_required_minor_version);
   }
 
   void CheckVersion(int expected_required_minor_version) {
-    base::FilePath output_path = testdir_.Append(kOutputFile);
+    std::filesystem::path output_path = testdir_ / kOutputFile;
     std::string output;
-    ASSERT_TRUE(base::ReadFileToString(output_path, &output));
-    EXPECT_EQ(output,
-              base::StringPrintf("1.%d\n", expected_required_minor_version));
+    ASSERT_TRUE(android::base::ReadFileToString(output_path.string(), &output));
+    EXPECT_EQ(
+        output,
+        android::base::StringPrintf("1.%d\n", expected_required_minor_version));
   }
 };
 
@@ -3454,15 +3440,16 @@ TEST_F(AvbToolTest_PrintRequiredVersion, Vbmeta_1_2) {
 }
 
 TEST_F(AvbToolTest, MakeCertPikCertificate) {
-  base::FilePath subject_path = testdir_.Append("tmp_subject");
-  ASSERT_TRUE(base::WriteFile(subject_path, "fake PIK subject", 16));
-  base::FilePath pubkey_path = testdir_.Append("tmp_pubkey.pem");
+  std::filesystem::path subject_path = testdir_ / "tmp_subject";
+  ASSERT_TRUE(base::WriteFile(
+      base::FilePath(subject_path.c_str()), "fake PIK subject", 16));
+  std::filesystem::path pubkey_path = testdir_ / "tmp_pubkey.pem";
   EXPECT_COMMAND(
       0,
       "openssl pkey -pubout -in test/data/testkey_cert_pik.pem -out %s",
-      pubkey_path.value().c_str());
+      pubkey_path.c_str());
 
-  base::FilePath output_path = testdir_.Append("tmp_certificate.bin");
+  std::filesystem::path output_path = testdir_ / "tmp_certificate.bin";
   EXPECT_COMMAND(0,
                  "./avbtool.py make_certificate"
                  " --subject %s"
@@ -3471,23 +3458,22 @@ TEST_F(AvbToolTest, MakeCertPikCertificate) {
                  " --subject_is_intermediate_authority"
                  " --authority_key test/data/testkey_cert_prk.pem"
                  " --output %s",
-                 subject_path.value().c_str(),
-                 pubkey_path.value().c_str(),
-                 output_path.value().c_str());
+                 subject_path.c_str(),
+                 pubkey_path.c_str(),
+                 output_path.c_str());
 
-  EXPECT_COMMAND(0,
-                 "diff test/data/cert_pik_certificate.bin %s",
-                 output_path.value().c_str());
+  EXPECT_COMMAND(
+      0, "diff test/data/cert_pik_certificate.bin %s", output_path.c_str());
 }
 
 TEST_F(AvbToolTest, MakeCertPskCertificate) {
-  base::FilePath pubkey_path = testdir_.Append("tmp_pubkey.pem");
+  std::filesystem::path pubkey_path = testdir_ / "tmp_pubkey.pem";
   EXPECT_COMMAND(
       0,
       "openssl pkey -pubout -in test/data/testkey_cert_psk.pem -out %s",
-      pubkey_path.value().c_str());
+      pubkey_path.c_str());
 
-  base::FilePath output_path = testdir_.Append("tmp_certificate.bin");
+  std::filesystem::path output_path = testdir_ / "tmp_certificate.bin";
   EXPECT_COMMAND(0,
                  "./avbtool.py make_certificate"
                  " --subject test/data/cert_product_id.bin"
@@ -3495,22 +3481,21 @@ TEST_F(AvbToolTest, MakeCertPskCertificate) {
                  " --subject_key_version 42"
                  " --authority_key test/data/testkey_cert_pik.pem"
                  " --output %s",
-                 pubkey_path.value().c_str(),
-                 output_path.value().c_str());
+                 pubkey_path.c_str(),
+                 output_path.c_str());
 
-  EXPECT_COMMAND(0,
-                 "diff test/data/cert_psk_certificate.bin %s",
-                 output_path.value().c_str());
+  EXPECT_COMMAND(
+      0, "diff test/data/cert_psk_certificate.bin %s", output_path.c_str());
 }
 
 TEST_F(AvbToolTest, MakeCertPukCertificate) {
-  base::FilePath pubkey_path = testdir_.Append("tmp_pubkey.pem");
+  std::filesystem::path pubkey_path = testdir_ / "tmp_pubkey.pem";
   EXPECT_COMMAND(
       0,
       "openssl pkey -pubout -in test/data/testkey_cert_puk.pem -out %s",
-      pubkey_path.value().c_str());
+      pubkey_path.c_str());
 
-  base::FilePath output_path = testdir_.Append("tmp_certificate.bin");
+  std::filesystem::path output_path = testdir_ / "tmp_certificate.bin";
 
   // Test with both legacy manual unlock --usage as well as --usage_for_unlock.
   std::string usage_args[] = {"--usage com.google.android.things.vboot.unlock",
@@ -3524,39 +3509,38 @@ TEST_F(AvbToolTest, MakeCertPukCertificate) {
                    " %s"
                    " --authority_key test/data/testkey_cert_pik.pem"
                    " --output %s",
-                   pubkey_path.value().c_str(),
+                   pubkey_path.c_str(),
                    usage.c_str(),
-                   output_path.value().c_str());
+                   output_path.c_str());
 
-    EXPECT_COMMAND(0,
-                   "diff test/data/cert_puk_certificate.bin %s",
-                   output_path.value().c_str());
+    EXPECT_COMMAND(
+        0, "diff test/data/cert_puk_certificate.bin %s", output_path.c_str());
   }
 }
 
 TEST_F(AvbToolTest, MakeCertPermanentAttributes) {
-  base::FilePath pubkey_path = testdir_.Append("tmp_pubkey.pem");
+  std::filesystem::path pubkey_path = testdir_ / "tmp_pubkey.pem";
   EXPECT_COMMAND(
       0,
       "openssl pkey -pubout -in test/data/testkey_cert_prk.pem -out %s",
-      pubkey_path.value().c_str());
+      pubkey_path.c_str());
 
-  base::FilePath output_path = testdir_.Append("tmp_attributes.bin");
+  std::filesystem::path output_path = testdir_ / "tmp_attributes.bin";
   EXPECT_COMMAND(0,
                  "./avbtool.py make_cert_permanent_attributes"
                  " --root_authority_key %s"
                  " --product_id test/data/cert_product_id.bin"
                  " --output %s",
-                 pubkey_path.value().c_str(),
-                 output_path.value().c_str());
+                 pubkey_path.c_str(),
+                 output_path.c_str());
 
   EXPECT_COMMAND(0,
                  "diff test/data/cert_permanent_attributes.bin %s",
-                 output_path.value().c_str());
+                 output_path.c_str());
 }
 
 TEST_F(AvbToolTest, MakeCertMetadata) {
-  base::FilePath output_path = testdir_.Append("tmp_metadata.bin");
+  std::filesystem::path output_path = testdir_ / "tmp_metadata.bin";
 
   EXPECT_COMMAND(
       0,
@@ -3564,14 +3548,13 @@ TEST_F(AvbToolTest, MakeCertMetadata) {
       " --intermediate_key_certificate test/data/cert_pik_certificate.bin"
       " --product_key_certificate test/data/cert_psk_certificate.bin"
       " --output %s",
-      output_path.value().c_str());
+      output_path.c_str());
 
-  EXPECT_COMMAND(
-      0, "diff test/data/cert_metadata.bin %s", output_path.value().c_str());
+  EXPECT_COMMAND(0, "diff test/data/cert_metadata.bin %s", output_path.c_str());
 }
 
 TEST_F(AvbToolTest, MakeCertUnlockCredential) {
-  base::FilePath output_path = testdir_.Append("tmp_credential.bin");
+  std::filesystem::path output_path = testdir_ / "tmp_credential.bin";
 
   EXPECT_COMMAND(
       0,
@@ -3581,11 +3564,10 @@ TEST_F(AvbToolTest, MakeCertUnlockCredential) {
       " --challenge test/data/cert_unlock_challenge.bin"
       " --unlock_key test/data/testkey_cert_puk.pem"
       " --output %s",
-      output_path.value().c_str());
+      output_path.c_str());
 
-  EXPECT_COMMAND(0,
-                 "diff test/data/cert_unlock_credential.bin %s",
-                 output_path.value().c_str());
+  EXPECT_COMMAND(
+      0, "diff test/data/cert_unlock_credential.bin %s", output_path.c_str());
 }
 
 }  // namespace avb
diff --git a/test/fake_avb_ops.cc b/test/fake_avb_ops.cc
index 517770e..ce630da 100644
--- a/test/fake_avb_ops.cc
+++ b/test/fake_avb_ops.cc
@@ -22,25 +22,23 @@
  * SOFTWARE.
  */
 
-#include <iostream>
+#include "fake_avb_ops.h"
 
+#include <base/files/file_util.h>
+#include <base/strings/string_util.h>
 #include <endian.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <inttypes.h>
+#include <openssl/rand.h>
+#include <openssl/sha.h>
 #include <string.h>
-
-#include <fcntl.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <unistd.h>
 
-#include <base/files/file_util.h>
-#include <base/strings/string_util.h>
-#include <base/strings/stringprintf.h>
-#include <openssl/rand.h>
-#include <openssl/sha.h>
-
-#include "fake_avb_ops.h"
+#include <filesystem>
+#include <iostream>
 
 namespace avb {
 
@@ -108,27 +106,24 @@ AvbIOResult FakeAvbOps::read_from_partition(const char* partition,
     return AVB_IO_RESULT_ERROR_NO_SUCH_PARTITION;
   }
 
-  base::FilePath path =
-      partition_dir_.Append(std::string(partition)).AddExtension("img");
+  std::filesystem::path path =
+      (partition_dir_ / partition).replace_extension("img");
 
   partition_names_read_from_.insert(partition);
 
   if (offset < 0) {
     int64_t file_size;
-    if (!base::GetFileSize(path, &file_size)) {
-      fprintf(
-          stderr, "Error getting size of file '%s'\n", path.value().c_str());
+    if (!base::GetFileSize(base::FilePath(path.c_str()), &file_size)) {
+      fprintf(stderr, "Error getting size of file '%s'\n", path.c_str());
       return AVB_IO_RESULT_ERROR_IO;
     }
     offset = file_size - (-offset);
   }
 
-  int fd = open(path.value().c_str(), O_RDONLY);
+  int fd = open(path.c_str(), O_RDONLY);
   if (fd < 0) {
-    fprintf(stderr,
-            "Error opening file '%s': %s\n",
-            path.value().c_str(),
-            strerror(errno));
+    fprintf(
+        stderr, "Error opening file '%s': %s\n", path.c_str(), strerror(errno));
     if (errno == ENOENT) {
       return AVB_IO_RESULT_ERROR_NO_SUCH_PARTITION;
     } else {
@@ -139,7 +134,7 @@ AvbIOResult FakeAvbOps::read_from_partition(const char* partition,
     fprintf(stderr,
             "Error seeking to pos %zd in file %s: %s\n",
             offset,
-            path.value().c_str(),
+            path.c_str(),
             strerror(errno));
     close(fd);
     return AVB_IO_RESULT_ERROR_IO;
@@ -150,7 +145,7 @@ AvbIOResult FakeAvbOps::read_from_partition(const char* partition,
             "Error reading %zd bytes from pos %" PRId64 " in file %s: %s\n",
             num_bytes,
             offset,
-            path.value().c_str(),
+            path.c_str(),
             strerror(errno));
     close(fd);
     return AVB_IO_RESULT_ERROR_IO;
@@ -208,25 +203,22 @@ AvbIOResult FakeAvbOps::write_to_partition(const char* partition,
     return AVB_IO_RESULT_ERROR_NO_SUCH_PARTITION;
   }
 
-  base::FilePath path =
-      partition_dir_.Append(std::string(partition)).AddExtension("img");
+  std::filesystem::path path =
+      (partition_dir_ / partition).replace_extension("img");
 
   if (offset < 0) {
     int64_t file_size;
-    if (!base::GetFileSize(path, &file_size)) {
-      fprintf(
-          stderr, "Error getting size of file '%s'\n", path.value().c_str());
+    if (!base::GetFileSize(base::FilePath(path.c_str()), &file_size)) {
+      fprintf(stderr, "Error getting size of file '%s'\n", path.c_str());
       return AVB_IO_RESULT_ERROR_IO;
     }
     offset = file_size - (-offset);
   }
 
-  int fd = open(path.value().c_str(), O_WRONLY);
+  int fd = open(path.c_str(), O_WRONLY);
   if (fd < 0) {
-    fprintf(stderr,
-            "Error opening file '%s': %s\n",
-            path.value().c_str(),
-            strerror(errno));
+    fprintf(
+        stderr, "Error opening file '%s': %s\n", path.c_str(), strerror(errno));
     if (errno == ENOENT) {
       return AVB_IO_RESULT_ERROR_NO_SUCH_PARTITION;
     } else {
@@ -237,7 +229,7 @@ AvbIOResult FakeAvbOps::write_to_partition(const char* partition,
     fprintf(stderr,
             "Error seeking to pos %zd in file %s: %s\n",
             offset,
-            path.value().c_str(),
+            path.c_str(),
             strerror(errno));
     close(fd);
     return AVB_IO_RESULT_ERROR_IO;
@@ -248,7 +240,7 @@ AvbIOResult FakeAvbOps::write_to_partition(const char* partition,
             "Error writing %zd bytes at pos %" PRId64 " in file %s: %s\n",
             num_bytes,
             offset,
-            path.value().c_str(),
+            path.c_str(),
             strerror(errno));
     close(fd);
     return AVB_IO_RESULT_ERROR_IO;
@@ -359,11 +351,11 @@ AvbIOResult FakeAvbOps::get_size_of_partition(AvbOps* ops,
     return AVB_IO_RESULT_ERROR_NO_SUCH_PARTITION;
   }
 
-  base::FilePath path =
-      partition_dir_.Append(std::string(partition)).AddExtension("img");
+  std::filesystem::path path =
+      (partition_dir_ / partition).replace_extension("img");
 
   int64_t file_size;
-  if (!base::GetFileSize(path, &file_size)) {
+  if (!base::GetFileSize(base::FilePath(path.c_str()), &file_size)) {
     return AVB_IO_RESULT_ERROR_NO_SUCH_PARTITION;
   }
   *out_size = file_size;
diff --git a/test/fake_avb_ops.h b/test/fake_avb_ops.h
index 8d9e49b..03eb2ac 100644
--- a/test/fake_avb_ops.h
+++ b/test/fake_avb_ops.h
@@ -29,6 +29,7 @@
 #include <libavb_ab/libavb_ab.h>
 #include <libavb_cert/libavb_cert.h>
 
+#include <filesystem>
 #include <map>
 #include <set>
 #include <string>
@@ -152,7 +153,7 @@ class FakeAvbOps : public FakeAvbOpsDelegate {
     delegate_ = delegate;
   }
 
-  void set_partition_dir(const base::FilePath& partition_dir) {
+  void set_partition_dir(const std::filesystem::path& partition_dir) {
     partition_dir_ = partition_dir;
   }
 
@@ -300,7 +301,7 @@ class FakeAvbOps : public FakeAvbOpsDelegate {
 
   FakeAvbOpsDelegate* delegate_;
 
-  base::FilePath partition_dir_;
+  std::filesystem::path partition_dir_;
 
   std::string expected_public_key_;
   std::string expected_public_key_metadata_;
```

