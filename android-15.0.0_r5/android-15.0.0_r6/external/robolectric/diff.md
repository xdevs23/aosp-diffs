```diff
diff --git a/.github/dependabot.yml b/.github/dependabot.yml
index 808af6dd2..52671c8ba 100644
--- a/.github/dependabot.yml
+++ b/.github/dependabot.yml
@@ -1,4 +1,5 @@
 version: 2
+
 updates:
   - package-ecosystem: "github-actions"
     directory: "/"
@@ -9,11 +10,18 @@ updates:
     directory: "/"
     schedule:
       interval: "weekly"
+    groups:
+      androidx-test:
+        patterns:
+          - "androidx.test*"
+      androidx:
+        patterns:
+          - "androidx.*"
     ignore:
-       # don't auto update guava since it requires updating gradle
-       - dependency-name: "*guava*"
-       # don't auto update errorprone since it requires updating guava
-       - dependency-name: "*errorprone*"
-       # don't auto update nativeruntime-dist-compat since it needs
-       # to be updated with code changes together
-       - dependency-name: "org.robolectric:nativeruntime-dist-compat"
+      # don't auto update guava since it requires updating gradle
+      - dependency-name: "*guava*"
+      # don't auto update errorprone since it requires updating guava
+      - dependency-name: "*errorprone*"
+      # don't auto update nativeruntime-dist-compat since it needs
+      # to be updated with code changes together
+      - dependency-name: "org.robolectric:nativeruntime-dist-compat"
diff --git a/.github/workflows/check_code_style.yml b/.github/workflows/check_code_style.yml
index 5c020d298..95fc36012 100644
--- a/.github/workflows/check_code_style.yml
+++ b/.github/workflows/check_code_style.yml
@@ -33,10 +33,10 @@ jobs:
           distribution: 'adopt'
           java-version: 17
 
-      - name: Download google-java-format 1.9
+      - name: Download google-java-format
         run: |
-          curl -L -o $HOME/google-java-format.jar https://github.com/google/google-java-format/releases/download/v1.15.0/google-java-format-1.15.0-all-deps.jar
-          curl -L -o $HOME/google-java-format-diff.py https://raw.githubusercontent.com/google/google-java-format/v1.15.0/scripts/google-java-format-diff.py
+          curl -L -o $HOME/google-java-format.jar https://github.com/google/google-java-format/releases/download/v1.22.0/google-java-format-1.22.0-all-deps.jar
+          curl -L -o $HOME/google-java-format-diff.py https://raw.githubusercontent.com/google/google-java-format/v1.22.0/scripts/google-java-format-diff.py
           chmod +x $HOME/google-java-format-diff.py
 
       - name: Check Java formatting
@@ -55,6 +55,6 @@ jobs:
         run: |
           ./gradlew spotlessCheck
 
-      - name: Check Kotlin Code Style
+      - name: Check Kotlin Quality
         run: |
           ./gradlew detekt
diff --git a/.github/workflows/gradle_tasks_validation.yml b/.github/workflows/gradle_tasks_validation.yml
index a3661d768..bca86899f 100644
--- a/.github/workflows/gradle_tasks_validation.yml
+++ b/.github/workflows/gradle_tasks_validation.yml
@@ -36,6 +36,12 @@ jobs:
       - name: Run aggregateDocs
         run: ./gradlew clean aggregateDocs
 
+      - name: Upload docs
+        uses: actions/upload-artifact@v4
+        with:
+          name: robolectric-javadoc-artifacts
+          path: build/docs
+
   run_javadocJar:
     runs-on: ubuntu-22.04
 
@@ -53,6 +59,7 @@ jobs:
       - name: Run javadocJar
         run: ./gradlew clean javadocJar
 
+
   run_instrumentAll:
     runs-on: ubuntu-22.04
 
@@ -73,6 +80,9 @@ jobs:
       - name: Run :preinstrumented:instrumentAll with SDK 33
         run: PREINSTRUMENTED_SDK_VERSIONS=33 ./gradlew :preinstrumented:instrumentAll
 
+      - name: Run :preinstrumented:publishToMavenLocal with SDK 33
+        run: PREINSTRUMENTED_SDK_VERSIONS=33 PUBLISH_PREINSTRUMENTED_JARS=true ./gradlew :preinstrumented:publishToMavenLocal
+
   run_publishToMavenLocal:
     runs-on: ubuntu-22.04
 
diff --git a/.github/workflows/gradle_wrapper_validation.yml b/.github/workflows/gradle_wrapper_validation.yml
index 722f2caff..6789cb12a 100644
--- a/.github/workflows/gradle_wrapper_validation.yml
+++ b/.github/workflows/gradle_wrapper_validation.yml
@@ -24,4 +24,4 @@ jobs:
     runs-on: ubuntu-22.04
     steps:
       - uses: actions/checkout@v4
-      - uses: gradle/wrapper-validation-action@v2
+      - uses: gradle/actions/wrapper-validation@v3
diff --git a/.github/workflows/graphics_tests.yml b/.github/workflows/graphics_tests.yml
index e523a9ce1..64cb44718 100644
--- a/.github/workflows/graphics_tests.yml
+++ b/.github/workflows/graphics_tests.yml
@@ -7,9 +7,8 @@ on:
       - '**.md'
 
   pull_request:
+    # Do not add `paths-ignore` here, this is required to be run on every PR for the `google` branch.
     branches: [ master, google ]
-    paths-ignore:
-      - '**.md'
 
 concurrency:
   group: ${{ github.workflow }}-${{ github.ref }}
diff --git a/.github/workflows/tests.yml b/.github/workflows/tests.yml
index fb6573b43..7ae48559e 100644
--- a/.github/workflows/tests.yml
+++ b/.github/workflows/tests.yml
@@ -88,9 +88,15 @@ jobs:
       # Allow tests to continue on other devices if they fail on one device.
       fail-fast: false
       matrix:
-        api-level: [ 29 ]
+        api-level: [ 29, 34 ]
 
     steps:
+      - name: Free disk space
+        uses: jlumbroso/free-disk-space@v1.3.1
+        with:
+          tool-cache: true
+          android: false
+
       - uses: actions/checkout@v4
 
       - name: Set up JDK 17
@@ -138,7 +144,8 @@ jobs:
           script: echo "Generated AVD snapshot for caching."
 
       - name: Run device tests
-        # See https://github.com/orgs/community/discussions/27121
+        # We need to use adb shell wm density to reset device's density to use fixed density
+        # for all devices. Hope it can improve the stability of Emulator testing.
         uses: reactivecircus/android-emulator-runner@v2
         with:
           api-level: ${{ matrix.api-level }}
@@ -147,9 +154,9 @@ jobs:
           force-avd-creation: false
           emulator-options: -no-snapshot-save -no-window -gpu swiftshader_indirect -noaudio -no-boot-anim -camera-back none
           disable-animations: true
-
           profile: Nexus One
           script: |
+            adb shell wm density 240
             SKIP_ERRORPRONE=true SKIP_JAVADOC=true ./gradlew cAT --info --stacktrace --no-watch-fs -Dorg.gradle.workers.max=2
 
       - name: Upload test results
diff --git a/.gitignore b/.gitignore
index cae6b8035..c67a81b15 100644
--- a/.gitignore
+++ b/.gitignore
@@ -21,6 +21,9 @@ release.properties
 .gradle/
 build
 
+# Kotlin
+.kotlin
+
 # Android Profiling
 *.hprof
 
diff --git a/Android.bp b/Android.bp
index ef8c34716..ffbd38a95 100644
--- a/Android.bp
+++ b/Android.bp
@@ -104,7 +104,7 @@ java_device_for_host {
         "services.accessibility",
         "telephony-common",
         "android.car",
-        "android.car.builtin",
+        "android.car.builtin.impl",
     ],
 }
 
@@ -180,6 +180,50 @@ java_library_host {
     ],
 }
 
+// Using visibility as allow list for tests to bypass strict_mode
+java_library {
+    name: "robolectric_non_strict_mode_permission",
+    sdk_version: "current",
+    visibility: [
+        ":__subpackages__",
+        "//vendor:__subpackages__",
+        "//platform_testing/robolab/roboStandaloneProj/tests:__pkg__",
+        "//packages/modules/DeviceLock/DeviceLockController/tests/robolectric:__pkg__",
+        "//packages/apps/StorageManager/robotests:__pkg__",
+        "//packages/apps/KeyChain/robotests:__pkg__",
+        "//packages/apps/CertInstaller/robotests:__pkg__",
+        "//packages/services/Mms/tests/robotests:__pkg__",
+        "//packages/apps/Car/Cluster/DirectRenderingCluster/tests/robotests:__pkg__",
+        "//packages/apps/QuickAccessWallet/tests/robolectric:__pkg__",
+        "//packages/services/Car/tests/CarLibTests:__pkg__",
+        "//frameworks/libs/systemui:__subpackages__",
+        "//packages/apps/WallpaperPicker2/tests/robotests:__pkg__",
+        "//frameworks/opt/wear/signaldetector/robotests:__pkg__",
+        "//packages/apps/EmergencyInfo/tests/robolectric:__pkg__",
+        "//packages/modules/Bluetooth/service:__pkg__",
+        "//frameworks/opt/wear/robotests:__pkg__",
+        "//packages/apps/ThemePicker/tests/robotests:__pkg__",
+        "//packages/modules/DeviceLock/tests/unittests:__pkg__",
+        "//external/mobile-data-download/javatests:__pkg__",
+        "//frameworks/opt/car/setupwizard/library/main/tests/robotests:__pkg__",
+        "//packages/apps/Car/Notification/tests/robotests:__pkg__",
+        "//packages/apps/TvSettings/Settings/tests/robotests:__pkg__",
+        "//packages/apps/Car/Settings/tests/robotests:__pkg__",
+        "//packages/apps/Car/SystemUI:__pkg__",
+        "//packages/apps/Settings/tests/robotests:__pkg__",
+        "//frameworks/base/packages/SystemUI:__pkg__",
+        "//frameworks/base/services/robotests:__pkg__",
+        "//frameworks/base/services/robotests/backup:__pkg__",
+        "//frameworks/base/packages/CredentialManager/wear/robotests",
+        "//frameworks/base/tests/InputScreenshotTest:__subpackages__",
+        "//frameworks/base/packages/SettingsLib:__subpackages__",
+        "//packages/apps/TV/common/tests/robotests:__pkg__",
+        "//packages/apps/Launcher3/tests:__pkg__",
+        "//packages/apps/Car/Launcher/libs/appgrid/lib/robotests:__pkg__",
+        "//cts/tests:__subpackages__",
+    ],
+}
+
 // Make Robolectric_all available as a target jar, but treated as an aar
 java_host_for_device {
     name: "Robolectric_all-target_upstream",
@@ -226,6 +270,7 @@ java_host_for_device {
         "//packages/apps/Car/Launcher/libs/appgrid/lib/robotests:__pkg__",
         "//packages/apps/Car/Cluster/DirectRenderingCluster/tests/robotests:__pkg__",
         "//packages/apps/Car/Settings/tests/robotests:__pkg__",
+        "//packages/apps/Car/SystemUI:__pkg__",
         "//packages/apps/EmergencyInfo/tests/robolectric:__pkg__",
         "//packages/apps/StorageManager/robotests:__pkg__",
         "//packages/apps/Settings/tests/robotests:__pkg__",
@@ -242,6 +287,7 @@ java_host_for_device {
         "//frameworks/base/packages/BackupEncryption/test/robolectric-integration:__pkg__",
         "//frameworks/base/packages/BackupEncryption/test/robolectric:__pkg__",
         "//packages/apps/Settings/tests/screenshot:__pkg__",
+        "//cts/tests:__subpackages__",
     ],
 }
 
diff --git a/README.md b/README.md
index 8138b804d..541b50a9e 100644
--- a/README.md
+++ b/README.md
@@ -40,7 +40,7 @@ If you'd like to start a new project with Robolectric tests you can refer to `de
 
 ```groovy
 testImplementation "junit:junit:4.13.2"
-testImplementation "org.robolectric:robolectric:4.11.1"
+testImplementation "org.robolectric:robolectric:4.12.2"
 ```
 
 ## Building And Contributing
@@ -56,7 +56,7 @@ See [Building Robolectric](http://robolectric.org/building-robolectric/) for mor
 
 ### Building
 
-Robolectric supports running tests against multiple Android API levels. The work it must do to support each API level is slightly different, so its shadows are built separately for each. To build shadows for every API version, run:
+Robolectric supports running tests against multiple Android API levels. To build Robolectric, run:
 
     ./gradlew clean assemble testClasses --parallel
 
@@ -70,7 +70,7 @@ Run tests for all API levels:
 
 Run tests for part of supported API levels, e.g. run tests for API level 26, 27, 28:
 
-    ./gradlew test --parallel -Drobolectric.enabledSdks=26,27,28
+    ./gradlew test --parallel "-Drobolectric.enabledSdks=26,27,28"
 
 Run compatibility test suites on opening Emulator:
 
@@ -87,6 +87,6 @@ repositories {
     maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
 }
 dependencies {
-    testImplementation "org.robolectric:robolectric:4.12-SNAPSHOT"
+    testImplementation "org.robolectric:robolectric:4.13-SNAPSHOT"
 }
 ```
diff --git a/annotations/build.gradle b/annotations/build.gradle
index c26efdb25..7255f1106 100644
--- a/annotations/build.gradle
+++ b/annotations/build.gradle
@@ -1,8 +1,7 @@
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
-apply plugin: DeployedRoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+}
 
 dependencies {
     compileOnly libs.findbugs.jsr305
diff --git a/annotations/src/main/java/org/robolectric/annotation/ClassName.java b/annotations/src/main/java/org/robolectric/annotation/ClassName.java
index 74e09c4fa..81ac098a5 100644
--- a/annotations/src/main/java/org/robolectric/annotation/ClassName.java
+++ b/annotations/src/main/java/org/robolectric/annotation/ClassName.java
@@ -5,7 +5,24 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-/** Parameters with types that can't be resolved at compile time may be annotated @ClassName. */
+/**
+ * Parameters with types that can't be resolved at compile time may be annotated @ClassName.
+ *
+ * <p>Use this annotation when creating shadow methods that contain new Android types in the method
+ * signature that do not exist in older SDK levels.
+ *
+ * <pre>
+ * &#64;Implements(FooAndroidClass.class)
+ * class ShadowFooAndroidClass {
+ *
+ *    // A method shadowing FooAndroidClass#setBar(com.android.RealClassName, int, String)
+ *    &#64;Implementation
+ *    public void setBar(&#64;ClassName("com.android.RealClassName") Object para1, int para2, String para3) {
+ *
+ *    }
+ * }
+ * </pre>
+ */
 @Target(ElementType.PARAMETER)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface ClassName {
diff --git a/annotations/src/main/java/org/robolectric/annotation/Implementation.java b/annotations/src/main/java/org/robolectric/annotation/Implementation.java
index a041c273c..b90a27fb8 100644
--- a/annotations/src/main/java/org/robolectric/annotation/Implementation.java
+++ b/annotations/src/main/java/org/robolectric/annotation/Implementation.java
@@ -21,4 +21,18 @@ public @interface Implementation {
 
   /** The annotated shadow method will be invoked only for the specified SDK or lesser. */
   int maxSdk() default DEFAULT_SDK;
+
+  /**
+   * The implemented method name.
+   *
+   * <p>Sometimes internal methods return different types for different SDKs. It's safe because
+   * these methods are internal/private methods, not public methods. To support different return
+   * types of a method for different SDKs, we often use looseSignature method, although all return
+   * types are common types like bool and int. This field/property can be used to fix this issue by
+   * using different real methods for different SDKs.
+   *
+   * @return The expected implemented method name. If it is empty/null, the Robolectric will uses
+   *     the method's name that marked by @Implementation as the implemented method name.
+   */
+  String methodName() default "";
 }
diff --git a/annotations/src/main/java/org/robolectric/annotation/ResourcesMode.java b/annotations/src/main/java/org/robolectric/annotation/ResourcesMode.java
new file mode 100644
index 000000000..b923df69a
--- /dev/null
+++ b/annotations/src/main/java/org/robolectric/annotation/ResourcesMode.java
@@ -0,0 +1,39 @@
+package org.robolectric.annotation;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * A {@link org.robolectric.pluginapi.config.Configurer} annotation for controlling Robolectric's
+ * android resource implementation.
+ *
+ * <p>Currently Robolectric will default to {@link ResourcesMode.Mode#BINARY} , but this can be
+ * overridden by applying a @ResourcesMode(NewMode) annotation to a test package, test class, or
+ * test method, or via the 'robolectric.resourcesMode' system property.
+ *
+ * @see org.robolectric.plugins.ResourceModeConfigurer
+ */
+@Documented
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.PACKAGE, ElementType.TYPE, ElementType.METHOD})
+public @interface ResourcesMode {
+
+  enum Mode {
+    /**
+     * Default: Reads binary resource data (arsc) using a Java implementation, manually
+     * transliterated from native code
+     */
+    BINARY,
+    /**
+     * Experimental: use AOSP native code to read resource data. Currently only functioning on
+     * android V and linux
+     */
+    NATIVE,
+  }
+
+  /** Set the Resources mode. */
+  ResourcesMode.Mode value();
+}
diff --git a/annotations/src/main/java/org/robolectric/annotation/SQLiteMode.java b/annotations/src/main/java/org/robolectric/annotation/SQLiteMode.java
index 63f9169ea..f6de313d7 100644
--- a/annotations/src/main/java/org/robolectric/annotation/SQLiteMode.java
+++ b/annotations/src/main/java/org/robolectric/annotation/SQLiteMode.java
@@ -17,7 +17,12 @@ public @interface SQLiteMode {
 
   /** Specifies the different supported SQLite modes. */
   enum Mode {
-    /** Use the legacy SQLite implementation backed by sqlite4java. */
+    /**
+     * Use the legacy SQLite implementation backed by sqlite4java.
+     *
+     * @deprecated This mode is obsolete and will be removed soon.
+     */
+    @Deprecated
     LEGACY,
     /** Use the new SQLite implementation backed by native Android code from AOSP. */
     NATIVE,
diff --git a/annotations/src/main/java/org/robolectric/annotation/internal/ConfigUtils.java b/annotations/src/main/java/org/robolectric/annotation/internal/ConfigUtils.java
index ed4a19a14..b4d9f043b 100644
--- a/annotations/src/main/java/org/robolectric/annotation/internal/ConfigUtils.java
+++ b/annotations/src/main/java/org/robolectric/annotation/internal/ConfigUtils.java
@@ -3,8 +3,7 @@ package org.robolectric.annotation.internal;
 import org.robolectric.annotation.Config;
 
 public class ConfigUtils {
-  private ConfigUtils() {
-  }
+  private ConfigUtils() {}
 
   public static String[] parseStringArrayProperty(String property) {
     if (property.isEmpty()) return new String[0];
diff --git a/annotations/src/main/java/org/robolectric/versioning/AndroidVersions.java b/annotations/src/main/java/org/robolectric/versioning/AndroidVersions.java
index 0b5f18ed7..16905cb2e 100644
--- a/annotations/src/main/java/org/robolectric/versioning/AndroidVersions.java
+++ b/annotations/src/main/java/org/robolectric/versioning/AndroidVersions.java
@@ -32,6 +32,7 @@ import java.util.Map;
 import java.util.Objects;
 import java.util.Properties;
 import java.util.jar.JarFile;
+import java.util.stream.Collectors;
 import java.util.zip.ZipEntry;
 import javax.annotation.Nullable;
 
@@ -711,7 +712,7 @@ public final class AndroidVersions {
    * SDK API Level: 34+ <br>
    * release: false <br>
    */
-  public static final class V extends AndroidUnreleased {
+  public static final class V extends AndroidReleased {
 
     public static final int SDK_INT = 35;
 
@@ -735,6 +736,35 @@ public final class AndroidVersions {
     }
   }
 
+  /**
+   * Placeholder for the next InDevelopment SDK after V
+   *
+   * <p>All values here subject to change.
+   */
+  public static final class W extends AndroidUnreleased {
+
+    public static final int SDK_INT = 36;
+
+    public static final String SHORT_CODE = "W";
+
+    public static final String VERSION = "16";
+
+    @Override
+    public int getSdkInt() {
+      return SDK_INT;
+    }
+
+    @Override
+    public String getShortCode() {
+      return SHORT_CODE;
+    }
+
+    @Override
+    public String getVersion() {
+      return VERSION;
+    }
+  }
+
   /** The current release this process is running on. */
   public static final AndroidRelease CURRENT;
 
@@ -748,23 +778,11 @@ public final class AndroidVersions {
   }
 
   public static List<AndroidRelease> getReleases() {
-    List<AndroidRelease> output = new ArrayList<>();
-    for (AndroidRelease release : information.allReleases) {
-      if (release.isReleased()) {
-        output.add(release);
-      }
-    }
-    return output;
+    return information.released;
   }
 
   public static List<AndroidRelease> getUnreleased() {
-    List<AndroidRelease> output = new ArrayList<>();
-    for (AndroidRelease release : information.allReleases) {
-      if (!release.isReleased()) {
-        output.add(release);
-      }
-    }
-    return output;
+    return information.unreleased;
   }
 
   /**
@@ -776,6 +794,8 @@ public final class AndroidVersions {
     final List<Class<? extends AndroidRelease>> classesWithIllegalNames;
     final AndroidRelease latestRelease;
     final AndroidRelease earliestUnreleased;
+    final List<AndroidRelease> unreleased;
+    final List<AndroidRelease> released;
 
     // In the future we may need a multimap for sdkInts should they stay static across releases.
     final Map<Integer, AndroidRelease> sdkIntToAllReleases = new HashMap<>();
@@ -794,17 +814,27 @@ public final class AndroidVersions {
       AndroidRelease earliestUnreleased = null;
       for (AndroidRelease release : allReleases) {
         if (release.isReleased()) {
-          if (latestRelease == null || latestRelease.compareTo(release) > 0) {
+          if (latestRelease == null || release.compareTo(latestRelease) > 0) {
             latestRelease = release;
           }
         } else {
-          if (earliestUnreleased == null || earliestUnreleased.compareTo(release) < 0) {
+          if (earliestUnreleased == null || release.compareTo(earliestUnreleased) < 0) {
             earliestUnreleased = release;
           }
         }
       }
       this.latestRelease = latestRelease;
       this.earliestUnreleased = earliestUnreleased;
+      this.unreleased =
+          allReleases.stream()
+              .filter(r -> !r.isReleased())
+              .sorted()
+              .collect(Collectors.toUnmodifiableList());
+      this.released =
+          allReleases.stream()
+              .filter(AndroidRelease::isReleased)
+              .sorted()
+              .collect(Collectors.toUnmodifiableList());
       verifyStaticInformation();
     }
 
@@ -933,11 +963,23 @@ public final class AndroidVersions {
                 .append(codename)
                 .append("\"\n");
           } else if (current.isReleased()) {
-            detectedProblems
+            StringBuilder problem = new StringBuilder();
+            problem
                 .append("The current sdk ")
                 .append(current.getShortCode())
                 .append(" has been been marked as released. Please update the ")
                 .append("contents of current sdk jar to the released version.\n");
+            if (current.getSdkInt() < latestRelease.getSdkInt()) {
+              // If the current sdk is lower than the latest release it should never be reported as
+              // unreleased.
+              detectedProblems.append(problem);
+            } else {
+              // If the current sdk is the latest release and it is reporting itself as unreleased
+              //  we simply log as this will occur when android build devs have not yet updated the
+              // branch's build definitions.  (git/main and aosp/main still claim to be the
+              // unreleased version of the latest release)
+              System.err.println(problem);
+            }
           }
           if (detectedProblems.length() > 0) {
             errorMessage(detectedProblems.toString(), null);
diff --git a/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsEdgeCaseTest.java b/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsEdgeCaseTest.java
index 90870abef..c9f6e825c 100644
--- a/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsEdgeCaseTest.java
+++ b/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsEdgeCaseTest.java
@@ -63,11 +63,12 @@ public final class AndroidVersionsEdgeCaseTest {
     try {
       forceWarningMode(false);
       SdkInformation information = AndroidVersions.gatherStaticSdkInformationFromThisClass();
-      latestRelease = information.latestRelease;
+      latestRelease =
+          information.sdkIntToAllReleases.get(information.latestRelease.getSdkInt() - 1);
       information.computeCurrentSdk(
           latestRelease.getSdkInt(),
           null,
-          information.latestRelease.getShortCode(),
+          latestRelease.getShortCode(),
           Arrays.asList(latestRelease.getShortCode()));
       assertThat(this).isNull();
     } catch (RuntimeException e) {
@@ -88,7 +89,8 @@ public final class AndroidVersionsEdgeCaseTest {
     try {
       forceWarningMode(true);
       SdkInformation information = AndroidVersions.gatherStaticSdkInformationFromThisClass();
-      latestRelease = information.latestRelease;
+      latestRelease =
+          information.sdkIntToAllReleases.get(information.latestRelease.getSdkInt() - 1);
       information.computeCurrentSdk(
           latestRelease.getSdkInt(),
           null,
@@ -99,6 +101,24 @@ public final class AndroidVersionsEdgeCaseTest {
     }
   }
 
+  /**
+   * sdkInt lower than known release, claims it's released. Expects an error message to update the
+   * jar if release is older than the latest release, otherwise warn only.
+   */
+  @Test
+  public void lastReleasedIntReleasedButStillReportsCodeName_noException() {
+    forceWarningMode(false);
+    SdkInformation information = AndroidVersions.gatherStaticSdkInformationFromThisClass();
+    AndroidRelease latestRelease =
+        information.sdkIntToAllReleases.get(information.latestRelease.getSdkInt());
+    information.computeCurrentSdk(
+        latestRelease.getSdkInt(),
+        null,
+        information.latestRelease.getShortCode(),
+        Arrays.asList(latestRelease.getShortCode()));
+    assertThat(this).isNotNull();
+  }
+
   @Test
   public void unknownSdkInt_warningMode() {
     try {
diff --git a/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java b/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java
index 764a7fa2d..57233817a 100644
--- a/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java
+++ b/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java
@@ -2,9 +2,11 @@ package org.robolectric.versioning;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import java.util.stream.Collectors;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import org.robolectric.versioning.AndroidVersions.AndroidRelease;
 
 /**
  * Check versions information aligns with runtime information. Primarily, selected SDK with
@@ -13,6 +15,54 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class AndroidVersionsTest {
 
+  @Test
+  public void testUnreleased() {
+    assertThat(
+            AndroidVersions.getReleases().stream()
+                .map(AndroidRelease::getSdkInt)
+                .collect(Collectors.toList()))
+        .containsExactly(
+            16, 17, 18, 19, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35);
+    assertThat(
+            AndroidVersions.getUnreleased().stream()
+                .map(AndroidRelease::getSdkInt)
+                .collect(Collectors.toList()))
+        .containsExactly(36);
+  }
+
+  @Test
+  public void testStandardInitializationW() {
+    assertThat(AndroidVersions.W.SDK_INT).isEqualTo(36);
+    assertThat(AndroidVersions.W.SHORT_CODE).isEqualTo("W");
+    assertThat(AndroidVersions.W.VERSION).isEqualTo("16");
+    assertThat(new AndroidVersions.W().getSdkInt()).isEqualTo(36);
+    assertThat(new AndroidVersions.W().getShortCode()).isEqualTo("W");
+    assertThat(new AndroidVersions.W().getVersion()).isEqualTo("16");
+    assertThat(new AndroidVersions.W().isReleased()).isFalse();
+  }
+
+  @Test
+  public void testStandardInitializationV() {
+    assertThat(AndroidVersions.V.SDK_INT).isEqualTo(35);
+    assertThat(AndroidVersions.V.SHORT_CODE).isEqualTo("V");
+    assertThat(AndroidVersions.V.VERSION).isEqualTo("15");
+    assertThat(new AndroidVersions.V().getSdkInt()).isEqualTo(35);
+    assertThat(new AndroidVersions.V().getShortCode()).isEqualTo("V");
+    assertThat(new AndroidVersions.V().getVersion()).isEqualTo("15");
+    assertThat(new AndroidVersions.V().isReleased()).isTrue();
+  }
+
+  @Test
+  public void testStandardInitializationU() {
+    assertThat(AndroidVersions.U.SDK_INT).isEqualTo(34);
+    assertThat(AndroidVersions.U.SHORT_CODE).isEqualTo("U");
+    assertThat(AndroidVersions.U.VERSION).isEqualTo("14.0");
+    assertThat(new AndroidVersions.U().getSdkInt()).isEqualTo(34);
+    assertThat(new AndroidVersions.U().getShortCode()).isEqualTo("U");
+    assertThat(new AndroidVersions.U().getVersion()).isEqualTo("14.0");
+    assertThat(new AndroidVersions.U().isReleased()).isTrue();
+  }
+
   @Test
   public void testStandardInitializationT() {
     assertThat(AndroidVersions.T.SDK_INT).isEqualTo(33);
@@ -21,7 +71,7 @@ public final class AndroidVersionsTest {
     assertThat(new AndroidVersions.T().getSdkInt()).isEqualTo(33);
     assertThat(new AndroidVersions.T().getShortCode()).isEqualTo("T");
     assertThat(new AndroidVersions.T().getVersion()).isEqualTo("13.0");
-    assertThat(new AndroidVersions.T().isReleased()).isEqualTo(true);
+    assertThat(new AndroidVersions.T().isReleased()).isTrue();
   }
 
   @Test
@@ -32,7 +82,7 @@ public final class AndroidVersionsTest {
     assertThat(new AndroidVersions.Sv2().getSdkInt()).isEqualTo(32);
     assertThat(new AndroidVersions.Sv2().getShortCode()).isEqualTo("Sv2");
     assertThat(new AndroidVersions.Sv2().getVersion()).isEqualTo("12.1");
-    assertThat(new AndroidVersions.Sv2().isReleased()).isEqualTo(true);
+    assertThat(new AndroidVersions.Sv2().isReleased()).isTrue();
   }
 
   @Test
@@ -43,7 +93,7 @@ public final class AndroidVersionsTest {
     assertThat(new AndroidVersions.S().getSdkInt()).isEqualTo(31);
     assertThat(new AndroidVersions.S().getShortCode()).isEqualTo("S");
     assertThat(new AndroidVersions.S().getVersion()).isEqualTo("12.0");
-    assertThat(new AndroidVersions.S().isReleased()).isEqualTo(true);
+    assertThat(new AndroidVersions.S().isReleased()).isTrue();
   }
 
   @Test
@@ -54,7 +104,7 @@ public final class AndroidVersionsTest {
     assertThat(new AndroidVersions.R().getSdkInt()).isEqualTo(30);
     assertThat(new AndroidVersions.R().getShortCode()).isEqualTo("R");
     assertThat(new AndroidVersions.R().getVersion()).isEqualTo("11.0");
-    assertThat(new AndroidVersions.R().isReleased()).isEqualTo(true);
+    assertThat(new AndroidVersions.R().isReleased()).isTrue();
   }
 
   @Test
@@ -65,7 +115,7 @@ public final class AndroidVersionsTest {
     assertThat(new AndroidVersions.Q().getSdkInt()).isEqualTo(29);
     assertThat(new AndroidVersions.Q().getShortCode()).isEqualTo("Q");
     assertThat(new AndroidVersions.Q().getVersion()).isEqualTo("10.0");
-    assertThat(new AndroidVersions.Q().isReleased()).isEqualTo(true);
+    assertThat(new AndroidVersions.Q().isReleased()).isTrue();
   }
 
   @Test
@@ -76,7 +126,7 @@ public final class AndroidVersionsTest {
     assertThat(new AndroidVersions.P().getSdkInt()).isEqualTo(28);
     assertThat(new AndroidVersions.P().getShortCode()).isEqualTo("P");
     assertThat(new AndroidVersions.P().getVersion()).isEqualTo("9.0");
-    assertThat(new AndroidVersions.P().isReleased()).isEqualTo(true);
+    assertThat(new AndroidVersions.P().isReleased()).isTrue();
   }
 
   @Test
@@ -87,7 +137,7 @@ public final class AndroidVersionsTest {
     assertThat(new AndroidVersions.OMR1().getSdkInt()).isEqualTo(27);
     assertThat(new AndroidVersions.OMR1().getShortCode()).isEqualTo("OMR1");
     assertThat(new AndroidVersions.OMR1().getVersion()).isEqualTo("8.1");
-    assertThat(new AndroidVersions.OMR1().isReleased()).isEqualTo(true);
+    assertThat(new AndroidVersions.OMR1().isReleased()).isTrue();
   }
 
   @Test
@@ -98,7 +148,7 @@ public final class AndroidVersionsTest {
     assertThat(new AndroidVersions.O().getSdkInt()).isEqualTo(26);
     assertThat(new AndroidVersions.O().getShortCode()).isEqualTo("O");
     assertThat(new AndroidVersions.O().getVersion()).isEqualTo("8.0");
-    assertThat(new AndroidVersions.O().isReleased()).isEqualTo(true);
+    assertThat(new AndroidVersions.O().isReleased()).isTrue();
   }
 
   @Test
@@ -109,7 +159,7 @@ public final class AndroidVersionsTest {
     assertThat(new AndroidVersions.NMR1().getSdkInt()).isEqualTo(25);
     assertThat(new AndroidVersions.NMR1().getShortCode()).isEqualTo("NMR1");
     assertThat(new AndroidVersions.NMR1().getVersion()).isEqualTo("7.1");
-    assertThat(new AndroidVersions.NMR1().isReleased()).isEqualTo(true);
+    assertThat(new AndroidVersions.NMR1().isReleased()).isTrue();
   }
 
   @Test
@@ -120,7 +170,7 @@ public final class AndroidVersionsTest {
     assertThat(new AndroidVersions.N().getSdkInt()).isEqualTo(24);
     assertThat(new AndroidVersions.N().getShortCode()).isEqualTo("N");
     assertThat(new AndroidVersions.N().getVersion()).isEqualTo("7.0");
-    assertThat(new AndroidVersions.N().isReleased()).isEqualTo(true);
+    assertThat(new AndroidVersions.N().isReleased()).isTrue();
   }
 
   @Test
@@ -131,7 +181,7 @@ public final class AndroidVersionsTest {
     assertThat(new AndroidVersions.M().getSdkInt()).isEqualTo(23);
     assertThat(new AndroidVersions.M().getShortCode()).isEqualTo("M");
     assertThat(new AndroidVersions.M().getVersion()).isEqualTo("6.0");
-    assertThat(new AndroidVersions.M().isReleased()).isEqualTo(true);
+    assertThat(new AndroidVersions.M().isReleased()).isTrue();
   }
 
   @Test
@@ -142,7 +192,7 @@ public final class AndroidVersionsTest {
     assertThat(new AndroidVersions.LMR1().getSdkInt()).isEqualTo(22);
     assertThat(new AndroidVersions.LMR1().getShortCode()).isEqualTo("LMR1");
     assertThat(new AndroidVersions.LMR1().getVersion()).isEqualTo("5.1");
-    assertThat(new AndroidVersions.LMR1().isReleased()).isEqualTo(true);
+    assertThat(new AndroidVersions.LMR1().isReleased()).isTrue();
   }
 
   @Test
@@ -153,6 +203,6 @@ public final class AndroidVersionsTest {
     assertThat(new AndroidVersions.L().getSdkInt()).isEqualTo(21);
     assertThat(new AndroidVersions.L().getShortCode()).isEqualTo("L");
     assertThat(new AndroidVersions.L().getVersion()).isEqualTo("5.0");
-    assertThat(new AndroidVersions.L().isReleased()).isEqualTo(true);
+    assertThat(new AndroidVersions.L().isReleased()).isTrue();
   }
 }
diff --git a/build.gradle b/build.gradle
index 0f79ab057..dce14a224 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,5 +1,6 @@
 import org.gradle.plugins.ide.idea.model.IdeaModel
-import org.robolectric.gradle.SpotlessPlugin
+import org.robolectric.gradle.ShadowsPlugin
+
 buildscript {
     apply from: 'dependencies.gradle'
 
@@ -8,34 +9,26 @@ buildscript {
         mavenCentral()
         gradlePluginPortal()
     }
+}
 
-    dependencies {
-        gradle
-        classpath libs.android.gradle
-        classpath libs.error.prone.gradle
-        classpath libs.aggregate.javadocs.gradle
-        classpath libs.kotlin.gradle
-        classpath libs.spotless.gradle
-        classpath libs.detekt.gradle
-        classpath libs.roborazzi.gradle
-    }
+plugins {
+    alias(libs.plugins.android.library) apply false
+    alias(libs.plugins.detekt) apply false
+    alias(libs.plugins.error.prone)
+    alias(libs.plugins.idea)
+    alias(libs.plugins.kotlin.android) apply false
+    alias(libs.plugins.kotlin.jvm) apply false
+    alias(libs.plugins.robolectric.spotless)
+    alias(libs.plugins.robolectric.javadoc)
+    alias(libs.plugins.roborazzi) apply false
+    alias(libs.plugins.spotless) apply false
 }
 
 allprojects {
-    repositories {
-        google()
-        mavenCentral()
-        gradlePluginPortal()
-    }
-
     group = "org.robolectric"
     version = thisVersion
 }
 
-apply plugin: 'idea'
-// apply SpotlessPlugin
-apply plugin: SpotlessPlugin
-
 project.ext.configAnnotationProcessing = []
 project.afterEvaluate {
     def ideaProject = rootProject.extensions.getByType(IdeaModel).project
@@ -79,8 +72,6 @@ project.afterEvaluate {
     }
 }
 
-apply plugin: 'nebula-aggregate-javadocs'
-
 rootProject.gradle.projectsEvaluated {
     rootProject.tasks.named("aggregateJavadocs").configure {
         it.failOnError = false
diff --git a/buildSrc/build.gradle b/buildSrc/build.gradle
index 6aea4ada5..655e792bc 100644
--- a/buildSrc/build.gradle
+++ b/buildSrc/build.gradle
@@ -1,23 +1,57 @@
-apply plugin: "java-library"
-apply plugin: "groovy"
+plugins {
+    alias(libs.plugins.groovy)
+    alias(libs.plugins.java.gradle.plugin)
+    alias(libs.plugins.java.library)
+}
 
-repositories {
-    google()
-    mavenCentral()
-    gradlePluginPortal()
+gradlePlugin {
+    plugins {
+        AarDepsPlugin {
+            id = "org.robolectric.gradle.AarDepsPlugin"
+            implementationClass = "org.robolectric.gradle.AarDepsPlugin"
+        }
+        AndrodiProjectConfigPlugin {
+            id = "org.robolectric.gradle.AndroidProjectConfigPlugin"
+            implementationClass = "org.robolectric.gradle.AndroidProjectConfigPlugin"
+        }
+        DeployedRoboJavaModulePlugin {
+            id = "org.robolectric.gradle.DeployedRoboJavaModulePlugin"
+            implementationClass = "org.robolectric.gradle.DeployedRoboJavaModulePlugin"
+        }
+        GradleManagedDevicePlugin {
+            id = "org.robolectric.gradle.GradleManagedDevicePlugin"
+            implementationClass = "org.robolectric.gradle.GradleManagedDevicePlugin"
+        }
+        RoboJavaModulePlugin {
+            id = "org.robolectric.gradle.RoboJavaModulePlugin"
+            implementationClass = "org.robolectric.gradle.RoboJavaModulePlugin"
+        }
+        SpotlessPlugin {
+            id = "org.robolectric.gradle.SpotlessPlugin"
+            implementationClass = "org.robolectric.gradle.SpotlessPlugin"
+        }
+        ShadowsPlugin {
+            id = "org.robolectric.gradle.ShadowsPlugin"
+            implementationClass = "org.robolectric.gradle.ShadowsPlugin"
+        }
+        AggregateJavadocPlugin {
+            id = "org.robolectric.gradle.AggregateJavadocPlugin"
+            implementationClass = "org.robolectric.gradle.AggregateJavadocPlugin"
+        }
+    }
 }
 
 dependencies {
     implementation gradleApi()
     implementation localGroovy()
 
-    api libs.guava
-    api libs.jetbrains.annotations
     implementation libs.asm.tree
-    implementation libs.android.gradle
+    implementation libs.android.gradle.api
+    implementation libs.android.tools.common
+    implementation libs.guava
 }
 
 java {
     sourceCompatibility = JavaVersion.VERSION_11
     targetCompatibility = JavaVersion.VERSION_11
-}
\ No newline at end of file
+}
diff --git a/buildSrc/settings.gradle b/buildSrc/settings.gradle
index 6f31e6ef7..7a96a41f1 100644
--- a/buildSrc/settings.gradle
+++ b/buildSrc/settings.gradle
@@ -1,4 +1,13 @@
+import org.gradle.api.initialization.resolve.RepositoriesMode
+
 dependencyResolutionManagement {
+    repositoriesMode = RepositoriesMode.FAIL_ON_PROJECT_REPOS
+
+    repositories {
+        google()
+        mavenCentral()
+    }
+
     versionCatalogs {
         libs {
             from(files("../gradle/libs.versions.toml"))
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/AarDepsPlugin.java b/buildSrc/src/main/groovy/org/robolectric/gradle/AarDepsPlugin.java
index 9322d6cd2..e5d193450 100644
--- a/buildSrc/src/main/groovy/org/robolectric/gradle/AarDepsPlugin.java
+++ b/buildSrc/src/main/groovy/org/robolectric/gradle/AarDepsPlugin.java
@@ -2,12 +2,12 @@ package org.robolectric.gradle;
 
 import static org.gradle.api.artifacts.type.ArtifactTypeDefinition.ARTIFACT_TYPE_ATTRIBUTE;
 
-import com.android.build.gradle.internal.dependency.ExtractAarTransform;
-import com.google.common.base.Joiner;
 import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Objects;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.stream.Collectors;
 import javax.inject.Inject;
 import org.gradle.api.Action;
 import org.gradle.api.Plugin;
@@ -17,6 +17,7 @@ import org.gradle.api.artifacts.transform.TransformOutputs;
 import org.gradle.api.file.FileCollection;
 import org.gradle.api.tasks.compile.JavaCompile;
 import org.jetbrains.annotations.NotNull;
+import org.robolectric.gradle.agp.ExtractAarTransform;
 
 /** Resolve aar dependencies into jars for non-Android projects. */
 public class AarDepsPlugin implements Plugin<Project> {
@@ -63,7 +64,11 @@ public class AarDepsPlugin implements Plugin<Project> {
                         List<File> aarFiles = AarDepsPlugin.this.findAarFiles(t.getClasspath());
                         if (!aarFiles.isEmpty()) {
                           throw new IllegalStateException(
-                              "AARs on classpath: " + Joiner.on("\n  ").join(aarFiles));
+                              "AARs on classpath: "
+                                  + aarFiles.stream()
+                                      .filter(Objects::nonNull)
+                                      .map(File::toString)
+                                      .collect(Collectors.joining("\n  ")));
                         }
                       }
                     }));
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/AggregateJavadocPlugin.groovy b/buildSrc/src/main/groovy/org/robolectric/gradle/AggregateJavadocPlugin.groovy
new file mode 100644
index 000000000..67f67d17f
--- /dev/null
+++ b/buildSrc/src/main/groovy/org/robolectric/gradle/AggregateJavadocPlugin.groovy
@@ -0,0 +1,46 @@
+package org.robolectric.gradle
+
+import org.gradle.api.Plugin
+import org.gradle.api.Project
+import org.gradle.api.plugins.JavaBasePlugin
+import org.gradle.api.plugins.JavaPlugin
+import org.gradle.api.tasks.javadoc.Javadoc
+
+/**
+ * Modified from https://github.com/nebula-plugins/gradle-aggregate-javadocs-plugin.
+ *
+ * The origin license is Apache v2:
+ * https://github.com/nebula-plugins/gradle-aggregate-javadocs-plugin?tab=Apache-2.0-1-ov-file#readme.
+ */
+class AggregateJavadocPlugin implements Plugin<Project> {
+    private static final String AGGREGATE_JAVADOCS_TASK_NAME = 'aggregateJavadocs'
+
+    @Override
+    void apply(Project project) {
+        Project rootProject = project.rootProject
+        // This plugin only works for root project.
+        if (project != rootProject) {
+            return
+        }
+        rootProject.gradle.projectsEvaluated {
+            Set<Project> javaSubprojects = getJavaSubprojects(rootProject)
+            if (!javaSubprojects.isEmpty()) {
+                rootProject.tasks.register(AGGREGATE_JAVADOCS_TASK_NAME, Javadoc) {
+                    description = 'Aggregates Javadoc API documentation of all subprojects.'
+                    group = JavaBasePlugin.DOCUMENTATION_GROUP
+
+                    dependsOn javaSubprojects.javadoc
+                    source javaSubprojects.javadoc.source
+
+                    String buildDirectory = rootProject.layout.buildDirectory.get().asFile.path
+                    destinationDir rootProject.file("$buildDirectory/docs/javadoc")
+                    classpath = rootProject.files(javaSubprojects.javadoc.classpath)
+                }
+            }
+        }
+    }
+
+    private static Set<Project> getJavaSubprojects(Project rootProject) {
+        rootProject.subprojects.findAll { subproject -> subproject.plugins.hasPlugin(JavaPlugin) }
+    }
+}
\ No newline at end of file
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/AndroidProjectConfigPlugin.groovy b/buildSrc/src/main/groovy/org/robolectric/gradle/AndroidProjectConfigPlugin.groovy
index 18249f5b1..ea8f04c36 100644
--- a/buildSrc/src/main/groovy/org/robolectric/gradle/AndroidProjectConfigPlugin.groovy
+++ b/buildSrc/src/main/groovy/org/robolectric/gradle/AndroidProjectConfigPlugin.groovy
@@ -34,6 +34,7 @@ class AndroidProjectConfigPlugin implements Plugin<Project> {
                     '--add-opens=java.base/java.lang.reflect=ALL-UNNAMED',
                     '--add-opens=java.base/java.io=ALL-UNNAMED',
                     '--add-opens=java.base/java.net=ALL-UNNAMED',
+                    '--add-opens=java.base/java.nio=ALL-UNNAMED', // required for ShadowVMRuntime
                     '--add-opens=java.base/java.security=ALL-UNNAMED',
                     '--add-opens=java.base/java.text=ALL-UNNAMED',
                     '--add-opens=java.base/java.util=ALL-UNNAMED',
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/DeployedRoboJavaModulePlugin.groovy b/buildSrc/src/main/groovy/org/robolectric/gradle/DeployedRoboJavaModulePlugin.groovy
index 09e3b8d4a..299b4e838 100644
--- a/buildSrc/src/main/groovy/org/robolectric/gradle/DeployedRoboJavaModulePlugin.groovy
+++ b/buildSrc/src/main/groovy/org/robolectric/gradle/DeployedRoboJavaModulePlugin.groovy
@@ -10,6 +10,10 @@ class DeployedRoboJavaModulePlugin implements Plugin<Project> {
         project.apply plugin: "signing"
         project.apply plugin: "maven-publish"
 
+        if (!project.plugins.hasPlugin("org.robolectric.gradle.RoboJavaModulePlugin")) {
+            project.apply plugin: "org.robolectric.gradle.RoboJavaModulePlugin"
+        }
+
         task('sourcesJar', type: Jar, dependsOn: classes) {
             archiveClassifier = "sources"
             from sourceSets.main.allJava
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/RoboJavaModulePlugin.groovy b/buildSrc/src/main/groovy/org/robolectric/gradle/RoboJavaModulePlugin.groovy
index 38f704159..092c0379c 100644
--- a/buildSrc/src/main/groovy/org/robolectric/gradle/RoboJavaModulePlugin.groovy
+++ b/buildSrc/src/main/groovy/org/robolectric/gradle/RoboJavaModulePlugin.groovy
@@ -76,6 +76,7 @@ class RoboJavaModulePlugin implements Plugin<Project> {
                     '--add-opens=java.base/java.lang.reflect=ALL-UNNAMED',
                     '--add-opens=java.base/java.io=ALL-UNNAMED',
                     '--add-opens=java.base/java.net=ALL-UNNAMED',
+                    '--add-opens=java.base/java.nio=ALL-UNNAMED', // required for ShadowVMRuntime
                     '--add-opens=java.base/java.security=ALL-UNNAMED',
                     '--add-opens=java.base/java.text=ALL-UNNAMED',
                     '--add-opens=java.base/java.util=ALL-UNNAMED',
diff --git a/buildSrc/src/main/groovy/ShadowsPlugin.groovy b/buildSrc/src/main/groovy/org/robolectric/gradle/ShadowsPlugin.groovy
similarity index 99%
rename from buildSrc/src/main/groovy/ShadowsPlugin.groovy
rename to buildSrc/src/main/groovy/org/robolectric/gradle/ShadowsPlugin.groovy
index a0563ee85..f11b7f004 100644
--- a/buildSrc/src/main/groovy/ShadowsPlugin.groovy
+++ b/buildSrc/src/main/groovy/org/robolectric/gradle/ShadowsPlugin.groovy
@@ -1,3 +1,5 @@
+package org.robolectric.gradle
+
 import org.gradle.api.Plugin
 import org.gradle.api.Project
 import org.gradle.api.tasks.compile.JavaCompile
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/SpotlessPlugin.groovy b/buildSrc/src/main/groovy/org/robolectric/gradle/SpotlessPlugin.groovy
index 8622fd2a0..3aa88664a 100644
--- a/buildSrc/src/main/groovy/org/robolectric/gradle/SpotlessPlugin.groovy
+++ b/buildSrc/src/main/groovy/org/robolectric/gradle/SpotlessPlugin.groovy
@@ -11,7 +11,7 @@ class SpotlessPlugin implements Plugin<Project> {
             kotlin {
                 // Add configurations for Kotlin files
                 target '**/*.kt'
-                ktfmt('0.42').googleStyle()
+                ktfmt('0.49').googleStyle()
             }
             groovy {
                 // Add configurations for Groovy files
@@ -21,7 +21,6 @@ class SpotlessPlugin implements Plugin<Project> {
                 // Add configurations for Groovy Gradle files
                 target('*.gradle', "**/*.gradle")
             }
-
         }
     }
 }
\ No newline at end of file
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/agp/ExtractAarTransform.java b/buildSrc/src/main/groovy/org/robolectric/gradle/agp/ExtractAarTransform.java
new file mode 100644
index 000000000..cbad436f3
--- /dev/null
+++ b/buildSrc/src/main/groovy/org/robolectric/gradle/agp/ExtractAarTransform.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * This class comes from AGP internals:
+ * https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:build-system/gradle-core/src/main/java/com/android/build/gradle/internal/dependency/ExtractAarTransform.kt;bpv=0
+ */
+
+package org.robolectric.gradle.agp;
+
+import com.android.SdkConstants;
+import com.android.utils.FileUtils;
+import com.google.common.io.Files;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.jar.JarOutputStream;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+import org.gradle.api.artifacts.transform.InputArtifact;
+import org.gradle.api.artifacts.transform.TransformAction;
+import org.gradle.api.artifacts.transform.TransformOutputs;
+import org.gradle.api.file.FileSystemLocation;
+import org.gradle.api.provider.Provider;
+import org.gradle.api.tasks.Classpath;
+import org.gradle.work.DisableCachingByDefault;
+import org.jetbrains.annotations.NotNull;
+
+// TODO Keep the original Kotlin implementation when `buildSrc` is migrated to Kotlin.
+@DisableCachingByDefault(because = "Copy task")
+public abstract class ExtractAarTransform implements TransformAction<GenericTransformParameters> {
+  @Classpath
+  @InputArtifact
+  public abstract Provider<FileSystemLocation> getAarFile();
+
+  @Override
+  public void transform(@NotNull TransformOutputs outputs) {
+    // TODO: record transform execution span
+    File inputFile = getAarFile().get().getAsFile();
+    String inputFileNameWithoutExtension = Files.getNameWithoutExtension(inputFile.getName());
+    File outputDir = outputs.dir(inputFileNameWithoutExtension);
+    FileUtils.mkdirs(outputDir);
+    new AarExtractor().extract(inputFile, outputDir);
+  }
+}
+
+class AarExtractor {
+  private static final String LIBS_PREFIX = SdkConstants.LIBS_FOLDER + '/';
+  private static final int LIBS_PREFIX_LENGTH = LIBS_PREFIX.length();
+  private static final int JARS_PREFIX_LENGTH = SdkConstants.FD_JARS.length() + 1;
+
+  // Note:
+  //  - A jar doesn't need a manifest entry, but if we ever want to create a manifest entry, be
+  //    sure to set a fixed timestamp for it so that the jar is deterministic
+  //  - This empty jar takes up only ~22 bytes, so we don't need to GC it at the end of the build.
+  private static final byte[] emptyJar;
+
+  /**
+   * {@link StringBuilder} used to construct all paths. It gets truncated back to {@link
+   * JARS_PREFIX_LENGTH} on every calculation.
+   */
+  private final StringBuilder stringBuilder = new StringBuilder(60);
+
+  static {
+    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+    //noinspection EmptyTryBlock
+    try (JarOutputStream outputStream = new JarOutputStream(byteArrayOutputStream)) {
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+
+    emptyJar = byteArrayOutputStream.toByteArray();
+  }
+
+  AarExtractor() {
+    stringBuilder.append(SdkConstants.FD_JARS);
+    stringBuilder.append(File.separatorChar);
+  }
+
+  private String choosePathInOutput(@NotNull String entryName) {
+    stringBuilder.setLength(JARS_PREFIX_LENGTH);
+
+    if (entryName.equals(SdkConstants.FN_CLASSES_JAR)
+        || entryName.equals(SdkConstants.FN_LINT_JAR)) {
+      stringBuilder.append(entryName);
+
+      return stringBuilder.toString();
+    } else if (entryName.startsWith(LIBS_PREFIX)) {
+      // In case we have libs/classes.jar we are going to rename them, due an issue in
+      // Gradle.
+      // TODO: stop doing this once this is fixed in gradle.
+      String pathWithinLibs = entryName.substring(LIBS_PREFIX_LENGTH);
+
+      if (pathWithinLibs.equals(SdkConstants.FN_CLASSES_JAR)) {
+        stringBuilder.append(LIBS_PREFIX).append("classes-2" + SdkConstants.DOT_JAR);
+      } else if (pathWithinLibs.equals(SdkConstants.FN_LINT_JAR)) {
+        stringBuilder.append(LIBS_PREFIX).append("lint-2" + SdkConstants.DOT_JAR);
+      } else {
+        stringBuilder.append(LIBS_PREFIX).append(pathWithinLibs);
+      }
+
+      return stringBuilder.toString();
+    } else {
+      return entryName;
+    }
+  }
+
+  /**
+   * Extracts an AAR file into a directory.
+   *
+   * <p>Note: There are small adjustments made to the extracted contents. For example, classes.jar
+   * inside the AAR will be extracted to jars/classes.jar, and if the jar does not exist, we will
+   * create an empty classes.jar.
+   */
+  void extract(@NotNull File aar, @NotNull File outputDir) {
+    try (ZipInputStream zipInputStream =
+        new ZipInputStream(java.nio.file.Files.newInputStream(aar.toPath()))) {
+      while (true) {
+        ZipEntry entry = zipInputStream.getNextEntry();
+        if (entry == null) {
+          break;
+        }
+
+        if (entry.isDirectory() || entry.getName().contains("../") || entry.getName().isEmpty()) {
+          continue;
+        }
+
+        String path = FileUtils.toSystemDependentPath(choosePathInOutput(entry.getName()));
+        File outputFile = new File(outputDir, path);
+        Files.createParentDirs(outputFile);
+        Files.asByteSink(outputFile).writeFrom(zipInputStream);
+      }
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+
+    // If classes.jar does not exist, create an empty one
+    File classesJar = resolve(outputDir, SdkConstants.FD_JARS + "/" + SdkConstants.FN_CLASSES_JAR);
+    if (!classesJar.exists()) {
+      try {
+        Files.createParentDirs(classesJar);
+        Files.write(emptyJar, classesJar);
+      } catch (IOException e) {
+        throw new RuntimeException(e);
+      }
+    }
+  }
+
+  @NotNull
+  private File resolve(@NotNull File source, @NotNull String relative) {
+    Path baseDir = source.toPath();
+    Path relativeFile = Paths.get(relative);
+    Path resolvedFile = baseDir.resolve(relativeFile);
+
+    return resolvedFile.toFile();
+  }
+}
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/agp/GenericTransformParameters.java b/buildSrc/src/main/groovy/org/robolectric/gradle/agp/GenericTransformParameters.java
new file mode 100644
index 000000000..820532311
--- /dev/null
+++ b/buildSrc/src/main/groovy/org/robolectric/gradle/agp/GenericTransformParameters.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * This class comes from AGP internals:
+ * https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:build-system/gradle-core/src/main/java/com/android/build/gradle/internal/dependency/GenericTransformParameters.kt;bpv=0
+ */
+
+package org.robolectric.gradle.agp;
+
+import org.gradle.api.artifacts.transform.TransformParameters;
+import org.gradle.api.provider.Property;
+import org.gradle.api.tasks.Internal;
+
+/** Generic {@link TransformParameters} for all of our Artifact Transforms. */
+// TODO Keep the original Kotlin implementation when `buildSrc` is migrated to Kotlin.
+public interface GenericTransformParameters extends TransformParameters {
+  @Internal
+  Property<String> getProjectName();
+}
diff --git a/errorprone/build.gradle b/errorprone/build.gradle
index ab8db7dcb..6f8428d63 100644
--- a/errorprone/build.gradle
+++ b/errorprone/build.gradle
@@ -1,9 +1,9 @@
 import org.gradle.internal.jvm.Jvm
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
 
-apply plugin: RoboJavaModulePlugin
-apply plugin: DeployedRoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+}
 
 // Disable annotation processor for tests
 compileTestJava {
diff --git a/errorprone/src/main/java/org/robolectric/errorprone/bugpatterns/Helpers.java b/errorprone/src/main/java/org/robolectric/errorprone/bugpatterns/Helpers.java
index 96dab0134..d467e0c58 100644
--- a/errorprone/src/main/java/org/robolectric/errorprone/bugpatterns/Helpers.java
+++ b/errorprone/src/main/java/org/robolectric/errorprone/bugpatterns/Helpers.java
@@ -28,9 +28,10 @@ public class Helpers {
 
   public static boolean isInShadowClass(TreePath path, VisitorState state) {
     Tree leaf = path.getLeaf();
-    JCClassDecl classDecl = JCClassDecl.class.isInstance(leaf)
-        ? (JCClassDecl) leaf
-        : findEnclosingNode(state.getPath(), JCClassDecl.class);
+    JCClassDecl classDecl =
+        JCClassDecl.class.isInstance(leaf)
+            ? (JCClassDecl) leaf
+            : findEnclosingNode(state.getPath(), JCClassDecl.class);
 
     return ASTHelpers.hasAnnotation(classDecl, Implements.class.getName(), state);
   }
@@ -54,5 +55,4 @@ public class Helpers {
       return ASTHelpers.isCastable(type, bound, state);
     }
   }
-
 }
diff --git a/errorprone/src/test/java/org/robolectric/errorprone/bugpatterns/RobolectricShadowTest.java b/errorprone/src/test/java/org/robolectric/errorprone/bugpatterns/RobolectricShadowTest.java
index 091979727..430c195aa 100644
--- a/errorprone/src/test/java/org/robolectric/errorprone/bugpatterns/RobolectricShadowTest.java
+++ b/errorprone/src/test/java/org/robolectric/errorprone/bugpatterns/RobolectricShadowTest.java
@@ -7,7 +7,9 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/** @author christianw@google.com (Christian Williams) */
+/**
+ * @author christianw@google.com (Christian Williams)
+ */
 @RunWith(JUnit4.class)
 public class RobolectricShadowTest {
   private BugCheckerRefactoringTestHelper testHelper;
diff --git a/errorprone/src/test/java/xxx/XShadowLooper.java b/errorprone/src/test/java/xxx/XShadowLooper.java
index 619a0831f..79935bccd 100644
--- a/errorprone/src/test/java/xxx/XShadowLooper.java
+++ b/errorprone/src/test/java/xxx/XShadowLooper.java
@@ -18,6 +18,5 @@ public class XShadowLooper {
     return null;
   }
 
-  public void runToEndOfTasks() {
-  }
+  public void runToEndOfTasks() {}
 }
diff --git a/errorprone/src/test/java/xxx/XShadowNetworkInfo.java b/errorprone/src/test/java/xxx/XShadowNetworkInfo.java
index 17e15ca31..a46191bbd 100644
--- a/errorprone/src/test/java/xxx/XShadowNetworkInfo.java
+++ b/errorprone/src/test/java/xxx/XShadowNetworkInfo.java
@@ -8,6 +8,5 @@ import org.robolectric.annotation.Implements;
  */
 @Implements(ConnectivityManager.class)
 public class XShadowNetworkInfo {
-  public void setConnectionType(int connectionType) {
-  }
+  public void setConnectionType(int connectionType) {}
 }
diff --git a/errorprone/src/test/java/xxx/XShadows.java b/errorprone/src/test/java/xxx/XShadows.java
index af9d6a0a5..a62745ae7 100644
--- a/errorprone/src/test/java/xxx/XShadows.java
+++ b/errorprone/src/test/java/xxx/XShadows.java
@@ -14,8 +14,8 @@ import java.util.Collection;
 import java.util.Map;
 
 /**
- * Fake {@link org.robolectric.internal.ShadowProvider} for testing
- * {@link org.robolectric.errorprone.bugpatterns.ShadowUsageCheck}.
+ * Fake {@link org.robolectric.internal.ShadowProvider} for testing {@link
+ * org.robolectric.errorprone.bugpatterns.ShadowUsageCheck}.
  */
 public class XShadows implements org.robolectric.internal.ShadowProvider {
   public static XShadowAlertDialog shadowOf(AlertDialog actual) {
diff --git a/gradle.properties b/gradle.properties
index bbb5374f5..f31bcb2c8 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,3 +1,19 @@
-thisVersion=4.12-SNAPSHOT
+thisVersion=4.13-SNAPSHOT
+
+# This project uses AndroidX instead of Support Libraries
+# https://developer.android.com/jetpack/androidx/migrate#migrate_an_existing_project_using_android_studio
 android.useAndroidX=true
+
+# Don't include Kotlin's standard library by default
+# https://kotlinlang.org/docs/gradle-configure-project.html#dependency-on-the-standard-library
 kotlin.stdlib.default.dependency=false
+
+# Enable Gradle's Build Cache
+# https://docs.gradle.org/current/userguide/performance.html#enable_the_build_cache
+org.gradle.caching=true
+
+# Increase Gradle's max memory due to OutOfMemoryException during compilation
+org.gradle.jvmargs=-Xmx2g
+
+# Give Kotlin's daemon 2g of memory
+kotlin.daemon.jvmargs=-Xmx2g
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index c96769d48..49280f850 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -1,14 +1,16 @@
 [versions]
-robolectric-nativeruntime-dist-compat = "1.0.11"
+robolectric-nativeruntime-dist-compat = "1.0.14"
 
 # https://developer.android.com/studio/releases
-android-gradle = "8.3.1"
+android-gradle = "8.5.0"
+
+android-tools-common = "31.5.0"
 
 # https://github.com/google/conscrypt/tags
 conscrypt = "2.5.2"
 
 # https://github.com/bcgit/bc-java/tags
-bouncycastle = "1.77"
+bouncycastle = "1.78.1"
 
 # https://github.com/findbugsproject/findbugs/tags
 findbugs-jsr305 = "3.0.2"
@@ -16,9 +18,6 @@ findbugs-jsr305 = "3.0.2"
 # https://github.com/hamcrest/JavaHamcrest/releases
 hamcrest = "2.0.0.0"
 
-# https://github.com/nebula-plugins/gradle-aggregate-javadocs-plugin/releases
-aggregate-javadocs-gradle = "3.0.1"
-
 # https://github.com/google/error-prone/releases
 error-prone = "2.19.1"
 error-prone-javac = "9+181-r4173-1"
@@ -27,10 +26,10 @@ error-prone-javac = "9+181-r4173-1"
 error-prone-gradle = "3.1.0"
 
 # https://kotlinlang.org/docs/releases.html#release-details
-kotlin = "1.9.23"
+kotlin = "2.0.0"
 
 # https://github.com/Kotlin/kotlinx.coroutines/releases/
-kotlinx-coroutines = '1.8.0'
+kotlinx-coroutines = '1.8.1'
 
 # https://github.com/diffplug/spotless/blob/main/plugin-gradle/CHANGES.md
 spotless-gradle = "6.25.0"
@@ -48,7 +47,7 @@ asm = "9.7"
 # https://github.com/google/auto/releases
 auto-common = "1.2.2"
 auto-service = "1.1.1"
-auto-value = "1.10.4"
+auto-value = "1.11.0"
 
 # https://github.com/google/compile-testing/releases
 compile-testing = "0.21.0"
@@ -57,13 +56,13 @@ compile-testing = "0.21.0"
 guava-jre = "31.1-jre"
 
 # https://github.com/google/gson/releases
-gson = "2.10.1"
+gson = "2.11.0"
 
 # https://github.com/google/truth/releases
-truth = "1.4.0"
+truth = "1.4.2"
 
 # https://github.com/unicode-org/icu/releases
-icu4j = "74.2"
+icu4j = "75.1"
 
 # https://www.eclemma.org/jacoco/
 jacoco = "0.8.11"
@@ -73,14 +72,11 @@ javax-annotation-api = "1.3.2"
 javax-annotation-jsr250-api = "1.0"
 javax-inject = "1"
 
-# https://github.com/JetBrains/java-annotations/releases
-jetbrains-annotations = "24.1.0"
-
 # https://junit.org/junit4/
 junit4 = "4.13.2"
 
 # https://github.com/google/libphonenumber/releases
-libphonenumber = "8.13.33"
+libphonenumber = "8.13.40"
 
 # https://github.com/mockito/mockito/releases
 mockito = "4.11.0"
@@ -89,7 +85,7 @@ mockito = "4.11.0"
 mockk = "1.13.7"
 
 # https://github.com/takahirom/roborazzi/releases
-roborazzi = "1.11.0"
+roborazzi = "1.20.0"
 
 # https://square.github.io/okhttp/changelogs/changelog/
 okhttp = "4.12.0"
@@ -100,14 +96,14 @@ powermock = "2.0.9"
 sqlite4java = "1.0.392"
 
 # https://developer.android.com/jetpack/androidx/versions
-androidx-annotation = "1.7.1"
-androidx-appcompat = "1.6.1"
+androidx-annotation = "1.8.0"
+androidx-appcompat = "1.7.0"
 androidx-biometric = "1.1.0"
 androidx-constraintlayout = "2.1.4"
-androidx-core = "1.12.0"
-androidx-fragment = "1.6.2"
+androidx-core = "1.13.1"
+androidx-fragment = "1.8.1"
 androidx-multidex = "2.0.1"
-androidx-window = "1.2.0"
+androidx-window = "1.3.0"
 androidx-room = "2.6.1"
 
 # https://github.com/android/android-test/tags
@@ -127,12 +123,12 @@ play-services-for-shadows = "17.0.0"
 play-services-basement = "18.0.1"
 
 [libraries]
-android-gradle = { module = "com.android.tools.build:gradle", version.ref = "android-gradle" }
-kotlin-gradle = { module = "org.jetbrains.kotlin:kotlin-gradle-plugin", version.ref = "kotlin" }
-spotless-gradle = { module = "com.diffplug.spotless:spotless-plugin-gradle", version.ref = "spotless-gradle" }
-detekt-gradle = { module = "io.gitlab.arturbosch.detekt:detekt-gradle-plugin", version.ref = "detekt-gradle" }
+android-gradle-api = { module = "com.android.tools.build:gradle-api", version.ref = "android-gradle" }
+
+android-tools-common = { module = "com.android.tools:common", version.ref = "android-tools-common" }
 
 kotlin-stdlib = { module = "org.jetbrains.kotlin:kotlin-stdlib", version.ref = "kotlin" }
+kotlin-bom = { module = "org.jetbrains.kotlin:kotlin-bom", version.ref = "kotlin" }
 kotlinx-coroutines-android = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-android", version.ref = "kotlinx-coroutines" }
 
 auto-common = { module = "com.google.auto:auto-common", version.ref = "auto-common" }
@@ -151,8 +147,6 @@ asm-tree = { module = "org.ow2.asm:asm-tree", version.ref = "asm" }
 
 compile-testing = { module = "com.google.testing.compile:compile-testing", version.ref = "compile-testing" }
 
-aggregate-javadocs-gradle = { module = "com.netflix.nebula:gradle-aggregate-javadocs-plugin", version.ref = "aggregate-javadocs-gradle" }
-
 error-prone-core = { module = "com.google.errorprone:error_prone_core", version.ref = "error-prone" }
 error-prone-annotations = { module = "com.google.errorprone:error_prone_annotation", version.ref = "error-prone" }
 error-prone-refaster = { module = "com.google.errorprone:error_prone_refaster", version.ref = "error-prone" }
@@ -160,8 +154,6 @@ error-prone-check-api = { module = "com.google.errorprone:error_prone_check_api"
 error-prone-test-helpers = { module = "com.google.errorprone:error_prone_test_helpers", version.ref = "error-prone" }
 error-prone-javac = { module = "com.google.errorprone:javac", version.ref = "error-prone-javac" }
 
-error-prone-gradle = { module = "net.ltgt.gradle:gradle-errorprone-plugin", version.ref = "error-prone-gradle" }
-
 conscrypt-openjdk-uber = { module = "org.conscrypt:conscrypt-openjdk-uber", version.ref = "conscrypt" }
 bcprov-jdk18on = { module = "org.bouncycastle:bcprov-jdk18on", version.ref = "bouncycastle" }
 findbugs-jsr305 = { module = "com.google.code.findbugs:jsr305", version.ref = "findbugs-jsr305" }
@@ -179,8 +171,6 @@ javax-annotation-api = { module = "javax.annotation:javax.annotation-api", versi
 javax-annotation-jsr250-api = { module = "javax.annotation:jsr250-api", version.ref = "javax-annotation-jsr250-api" }
 javax-inject = { module = "javax.inject:javax.inject", version.ref = "javax-inject" }
 
-jetbrains-annotations = { module = "org.jetbrains:annotations", version.ref = "jetbrains-annotations" }
-
 libphonenumber = { module = "com.googlecode.libphonenumber:libphonenumber", version.ref = "libphonenumber" }
 
 okhttp = { module = "com.squareup.okhttp3:okhttp" }
@@ -201,7 +191,6 @@ sqlite4java-linux-i386 = { module = "com.almworks.sqlite4java:libsqlite4java-lin
 sqlite4java-win32-x86 = { module = "com.almworks.sqlite4java:sqlite4java-win32-x86", version.ref = "sqlite4java" }
 
 truth = { module = "com.google.truth:truth", version.ref = "truth" }
-truth-java8-extension = { module = "com.google.truth.extensions:truth-java8-extension", version.ref = "truth" }
 
 mockito = { module = "org.mockito:mockito-core", version.ref = "mockito" }
 mockito-inline = { module = "org.mockito:mockito-inline", version.ref = "mockito" }
@@ -209,7 +198,6 @@ mockk = { module = "io.mockk:mockk", version.ref = "mockk" }
 
 roborazzi = { module = "io.github.takahirom.roborazzi:roborazzi", version.ref = "roborazzi" }
 roborazzi-rule = { module = "io.github.takahirom.roborazzi:roborazzi-junit-rule", version.ref = "roborazzi" }
-roborazzi-gradle = { module = "io.github.takahirom.roborazzi:roborazzi-gradle-plugin", version.ref = "roborazzi" }
 
 androidx-annotation = { module = "androidx.annotation:annotation", version.ref = "androidx-annotation" }
 androidx-appcompat = { module = "androidx.appcompat:appcompat", version.ref = "androidx-appcompat" }
@@ -243,8 +231,29 @@ play-services-basement-for-shadows = { module = "com.google.android.gms:play-ser
 play-services-basement = { module = "com.google.android.gms:play-services-basement", version.ref = "play-services-basement" }
 
 [bundles]
-play-services-for-shadows = [ "androidx-fragment-for-shadows", "play-services-auth-for-shadows", "play-services-base-for-shadows", "play-services-basement-for-shadows" ]
-powermock = [ "powermock-module-junit4", "powermock-module-junit4-rule", "powermock-api-mockito2", "powermock-classloading-xstream" ]
-sqlite4java-native = [ "sqlite4java-osx", "sqlite4java-linux-amd64", "sqlite4java-win32-x64", "sqlite4java-linux-i386", "sqlite4java-win32-x86" ]
+play-services-for-shadows = ["androidx-fragment-for-shadows", "play-services-auth-for-shadows", "play-services-base-for-shadows", "play-services-basement-for-shadows"]
+powermock = ["powermock-module-junit4", "powermock-module-junit4-rule", "powermock-api-mockito2", "powermock-classloading-xstream"]
+sqlite4java-native = ["sqlite4java-osx", "sqlite4java-linux-amd64", "sqlite4java-win32-x64", "sqlite4java-linux-i386", "sqlite4java-win32-x86"]
 
 [plugins]
+android-library = { id = "com.android.library", version.ref = "android-gradle" }
+application = { id = "application" }
+detekt = { id = "io.gitlab.arturbosch.detekt", version.ref = "detekt-gradle" }
+error-prone = { id = "net.ltgt.errorprone", version.ref = "error-prone-gradle" }
+groovy = { id = "groovy" }
+idea = { id = "idea" }
+jacoco = { id = "jacoco" }
+java = { id = "java" }
+java-gradle-plugin = { id = "java-gradle-plugin" }
+java-library = { id = "java-library" }
+kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
+kotlin-jvm = { id = "org.jetbrains.kotlin.jvm", version.ref = "kotlin" }
+robolectric-android-project = { id = "org.robolectric.gradle.AndroidProjectConfigPlugin" }
+robolectric-deployed-java-module = { id = "org.robolectric.gradle.DeployedRoboJavaModulePlugin" }
+robolectric-gradle-managed-device = { id = "org.robolectric.gradle.GradleManagedDevicePlugin" }
+robolectric-java-module = { id = "org.robolectric.gradle.RoboJavaModulePlugin" }
+robolectric-spotless = { id = "org.robolectric.gradle.SpotlessPlugin" }
+robolectric-shadows = { id = "org.robolectric.gradle.ShadowsPlugin" }
+robolectric-javadoc = { id = "org.robolectric.gradle.AggregateJavadocPlugin" }
+roborazzi = { id = "io.github.takahirom.roborazzi", version.ref = "roborazzi" }
+spotless = { id = "com.diffplug.spotless", version.ref = "spotless-gradle" }
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index b82aa23a4..a4413138c 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-8.7-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.8-bin.zip
 networkTimeout=10000
 validateDistributionUrl=true
 zipStoreBase=GRADLE_USER_HOME
diff --git a/gradlew b/gradlew
index 1aa94a426..b740cf133 100755
--- a/gradlew
+++ b/gradlew
@@ -55,7 +55,7 @@
 #       Darwin, MinGW, and NonStop.
 #
 #   (3) This script is generated from the Groovy template
-#       https://github.com/gradle/gradle/blob/HEAD/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
+#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
 #       within the Gradle project.
 #
 #       You can find Gradle at https://github.com/gradle/gradle/.
diff --git a/integration_tests/agp/build.gradle b/integration_tests/agp/build.gradle
index 71b9e74f7..27a85fa98 100644
--- a/integration_tests/agp/build.gradle
+++ b/integration_tests/agp/build.gradle
@@ -1,14 +1,14 @@
-import org.robolectric.gradle.AndroidProjectConfigPlugin
-
-apply plugin: 'com.android.library'
-apply plugin: AndroidProjectConfigPlugin
+plugins {
+    alias(libs.plugins.android.library)
+    alias(libs.plugins.robolectric.android.project)
+}
 
 android {
     compileSdk 34
     namespace 'org.robolectric.integrationtests.agp'
 
     defaultConfig {
-        minSdk 19
+        minSdk 21
         targetSdk 34
     }
 
diff --git a/integration_tests/agp/testsupport/build.gradle b/integration_tests/agp/testsupport/build.gradle
index 4da0f495b..080a6186c 100644
--- a/integration_tests/agp/testsupport/build.gradle
+++ b/integration_tests/agp/testsupport/build.gradle
@@ -1,11 +1,13 @@
-apply plugin: 'com.android.library'
+plugins {
+    alias(libs.plugins.android.library)
+}
 
 android {
     compileSdk 34
     namespace 'org.robolectric.integrationtests.agp.testsupport'
 
     defaultConfig {
-        minSdk 19
+        minSdk 21
         targetSdk 34
     }
 
diff --git a/integration_tests/agp/testsupport/src/main/java/org/robolectric/integrationtests/agp/testsupport/TestActivity.java b/integration_tests/agp/testsupport/src/main/java/org/robolectric/integrationtests/agp/testsupport/TestActivity.java
index eb6d5d2fb..6a01201bc 100644
--- a/integration_tests/agp/testsupport/src/main/java/org/robolectric/integrationtests/agp/testsupport/TestActivity.java
+++ b/integration_tests/agp/testsupport/src/main/java/org/robolectric/integrationtests/agp/testsupport/TestActivity.java
@@ -3,6 +3,4 @@ package org.robolectric.integrationtests.agp.testsupport;
 import android.app.Activity;
 
 /** Activity for use in unit tests. */
-public class TestActivity extends Activity {
-
-}
\ No newline at end of file
+public class TestActivity extends Activity {}
diff --git a/integration_tests/androidx/build.gradle b/integration_tests/androidx/build.gradle
index 2664b2c2e..c2b458de9 100644
--- a/integration_tests/androidx/build.gradle
+++ b/integration_tests/androidx/build.gradle
@@ -1,14 +1,14 @@
-import org.robolectric.gradle.AndroidProjectConfigPlugin
-
-apply plugin: 'com.android.library'
-apply plugin: AndroidProjectConfigPlugin
+plugins {
+    alias(libs.plugins.android.library)
+    alias(libs.plugins.robolectric.android.project)
+}
 
 android {
     compileSdk 34
     namespace 'org.robolectric.integrationtests.androidx'
 
     defaultConfig {
-        minSdk 19
+        minSdk 21
         targetSdk 34
     }
 
diff --git a/integration_tests/androidx/src/test/java/org/robolectric/integrationtests/androidx/BuildCompatTest.java b/integration_tests/androidx/src/test/java/org/robolectric/integrationtests/androidx/BuildCompatTest.java
index b9e2243a8..c998184a9 100644
--- a/integration_tests/androidx/src/test/java/org/robolectric/integrationtests/androidx/BuildCompatTest.java
+++ b/integration_tests/androidx/src/test/java/org/robolectric/integrationtests/androidx/BuildCompatTest.java
@@ -8,10 +8,8 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
 /** Compatibility test for {@link BuildCompat} */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public class BuildCompatTest {
 
diff --git a/integration_tests/androidx_test/build.gradle b/integration_tests/androidx_test/build.gradle
index 89c242c6c..71bd9aecb 100644
--- a/integration_tests/androidx_test/build.gradle
+++ b/integration_tests/androidx_test/build.gradle
@@ -1,9 +1,8 @@
-import org.robolectric.gradle.AndroidProjectConfigPlugin
-import org.robolectric.gradle.GradleManagedDevicePlugin
-
-apply plugin: 'com.android.library'
-apply plugin: AndroidProjectConfigPlugin
-apply plugin: GradleManagedDevicePlugin
+plugins {
+    alias(libs.plugins.android.library)
+    alias(libs.plugins.robolectric.android.project)
+    alias(libs.plugins.robolectric.gradle.managed.device)
+}
 
 android {
     compileSdk 34
@@ -11,7 +10,7 @@ android {
 
     defaultConfig {
         testApplicationId 'org.robolectric.integrationtests.axt'
-        minSdk 19
+        minSdk 21
         targetSdk 34
         multiDexEnabled true
         testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
@@ -71,6 +70,7 @@ dependencies {
     androidTestImplementation libs.androidx.test.ext.truth
     androidTestImplementation libs.androidx.test.core
     androidTestImplementation libs.androidx.test.ext.junit
+    androidTestImplementation platform(libs.kotlin.bom)
     androidTestImplementation libs.truth
     androidTestUtil libs.androidx.test.services
 }
diff --git a/integration_tests/androidx_test/src/main/AndroidManifest.xml b/integration_tests/androidx_test/src/main/AndroidManifest.xml
index 5d77da862..6aac983cf 100644
--- a/integration_tests/androidx_test/src/main/AndroidManifest.xml
+++ b/integration_tests/androidx_test/src/main/AndroidManifest.xml
@@ -10,11 +10,11 @@
         <activity android:name="org.robolectric.integrationtests.axt.EspressoActivity"
                   android:label="Activity Label"
                   android:exported="true" >
-                           <intent-filter >
-        <action android:name="android.intent.action.VIEW" />
-        <category android:name="android.intent.category.DEFAULT" />
-        </intent-filter>
-                  </activity>
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
         <activity android:name="org.robolectric.integrationtests.axt.EspressoScrollingActivity"
             android:exported="true" />
         <activity android:name="org.robolectric.integrationtests.axt.ActivityWithPlatformMenu"
diff --git a/integration_tests/androidx_test/src/sharedTest/AndroidManifest-NoTestPackageActivities.xml b/integration_tests/androidx_test/src/sharedTest/AndroidManifest-NoTestPackageActivities.xml
index b712d7508..43cf9617b 100644
--- a/integration_tests/androidx_test/src/sharedTest/AndroidManifest-NoTestPackageActivities.xml
+++ b/integration_tests/androidx_test/src/sharedTest/AndroidManifest-NoTestPackageActivities.xml
@@ -4,7 +4,7 @@
     package="org.robolectric.integrationtests.axt">
 
   <uses-sdk
-      android:minSdkVersion="19"
+      android:minSdkVersion="21"
       android:targetSdkVersion="34"/>
 
   <application>
diff --git a/integration_tests/androidx_test/src/test/AndroidManifest-ActivityScenario.xml b/integration_tests/androidx_test/src/test/AndroidManifest-ActivityScenario.xml
index 62402b2fd..a08c46165 100644
--- a/integration_tests/androidx_test/src/test/AndroidManifest-ActivityScenario.xml
+++ b/integration_tests/androidx_test/src/test/AndroidManifest-ActivityScenario.xml
@@ -4,7 +4,7 @@
     package="org.robolectric.integrationtests.axt">
 
   <uses-sdk
-      android:minSdkVersion="19"
+      android:minSdkVersion="21"
       android:targetSdkVersion="34"/>
 
   <application
diff --git a/integration_tests/androidx_test/src/test/AndroidManifest-ActivityTestRule.xml b/integration_tests/androidx_test/src/test/AndroidManifest-ActivityTestRule.xml
index d52207387..334fe3b2a 100644
--- a/integration_tests/androidx_test/src/test/AndroidManifest-ActivityTestRule.xml
+++ b/integration_tests/androidx_test/src/test/AndroidManifest-ActivityTestRule.xml
@@ -4,7 +4,7 @@
     package="org.robolectric.integrationtests.axt">
 
   <uses-sdk
-      android:minSdkVersion="19"
+      android:minSdkVersion="21"
       android:targetSdkVersion="34"/>
 
   <application>
diff --git a/integration_tests/androidx_test/src/test/AndroidManifest-Intents.xml b/integration_tests/androidx_test/src/test/AndroidManifest-Intents.xml
index b4142a61f..0f59ec4a8 100644
--- a/integration_tests/androidx_test/src/test/AndroidManifest-Intents.xml
+++ b/integration_tests/androidx_test/src/test/AndroidManifest-Intents.xml
@@ -4,7 +4,7 @@
     package="org.robolectric.integrationtests.axt">
 
   <uses-sdk
-      android:minSdkVersion="19"
+      android:minSdkVersion="21"
       android:targetSdkVersion="34"/>
 
   <application>
diff --git a/integration_tests/androidx_test/src/test/AndroidManifest-NoTestPackageActivities.xml b/integration_tests/androidx_test/src/test/AndroidManifest-NoTestPackageActivities.xml
index b712d7508..43cf9617b 100644
--- a/integration_tests/androidx_test/src/test/AndroidManifest-NoTestPackageActivities.xml
+++ b/integration_tests/androidx_test/src/test/AndroidManifest-NoTestPackageActivities.xml
@@ -4,7 +4,7 @@
     package="org.robolectric.integrationtests.axt">
 
   <uses-sdk
-      android:minSdkVersion="19"
+      android:minSdkVersion="21"
       android:targetSdkVersion="34"/>
 
   <application>
diff --git a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/ActivityScenarioTest.java b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/ActivityScenarioTest.java
index 8f9760846..b4ddf9939 100644
--- a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/ActivityScenarioTest.java
+++ b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/ActivityScenarioTest.java
@@ -139,10 +139,10 @@ public class ActivityScenarioTest {
   public void launch_callbackSequence() {
     try (ActivityScenario<TranscriptActivity> activityScenario =
         ActivityScenario.launch(TranscriptActivity.class)) {
-    assertThat(activityScenario).isNotNull();
-    assertThat(callbacks)
-        .containsExactly(
-            "onCreate", "onStart", "onPostCreate", "onResume", "onWindowFocusChanged true");
+      assertThat(activityScenario).isNotNull();
+      assertThat(callbacks)
+          .containsExactly(
+              "onCreate", "onStart", "onPostCreate", "onResume", "onWindowFocusChanged true");
     }
   }
 
@@ -150,13 +150,18 @@ public class ActivityScenarioTest {
   public void launch_pauseAndResume_callbackSequence() {
     try (ActivityScenario<TranscriptActivity> activityScenario =
         ActivityScenario.launch(TranscriptActivity.class)) {
-    assertThat(activityScenario).isNotNull();
-    activityScenario.moveToState(State.STARTED);
-    activityScenario.moveToState(State.RESUMED);
-    assertThat(callbacks)
-        .containsExactly(
-            "onCreate", "onStart", "onPostCreate", "onResume", "onWindowFocusChanged true",
-            "onPause", "onResume");
+      assertThat(activityScenario).isNotNull();
+      activityScenario.moveToState(State.STARTED);
+      activityScenario.moveToState(State.RESUMED);
+      assertThat(callbacks)
+          .containsExactly(
+              "onCreate",
+              "onStart",
+              "onPostCreate",
+              "onResume",
+              "onWindowFocusChanged true",
+              "onPause",
+              "onResume");
     }
   }
 
@@ -167,18 +172,18 @@ public class ActivityScenarioTest {
       assertThat(activityScenario).isNotNull();
       activityScenario.moveToState(State.CREATED);
       activityScenario.moveToState(State.RESUMED);
-    assertThat(callbacks)
-        .containsExactly(
-            "onCreate",
-            "onStart",
-            "onPostCreate",
-            "onResume",
-            "onWindowFocusChanged true",
-            "onPause",
-            "onStop false",
-            "onRestart",
-            "onStart",
-            "onResume");
+      assertThat(callbacks)
+          .containsExactly(
+              "onCreate",
+              "onStart",
+              "onPostCreate",
+              "onResume",
+              "onWindowFocusChanged true",
+              "onPause",
+              "onStop false",
+              "onRestart",
+              "onStart",
+              "onResume");
     }
   }
 
@@ -191,12 +196,12 @@ public class ActivityScenarioTest {
                 .setClassName(
                     context, "org.robolectric.integrationtests.axt.ActivityScenarioTestAlias"))) {
 
-    assertThat(activityScenario).isNotNull();
-    activityScenario.onActivity(
-        activity -> assertThat(activity).isInstanceOf(TranscriptActivity.class));
-    assertThat(callbacks)
-        .containsExactly(
-            "onCreate", "onStart", "onPostCreate", "onResume", "onWindowFocusChanged true");
+      assertThat(activityScenario).isNotNull();
+      activityScenario.onActivity(
+          activity -> assertThat(activity).isInstanceOf(TranscriptActivity.class));
+      assertThat(callbacks)
+          .containsExactly(
+              "onCreate", "onStart", "onPostCreate", "onResume", "onWindowFocusChanged true");
     }
   }
 
@@ -204,15 +209,18 @@ public class ActivityScenarioTest {
   public void launch_lifecycleOwnerActivity() {
     try (ActivityScenario<LifecycleOwnerActivity> activityScenario =
         ActivityScenario.launch(LifecycleOwnerActivity.class)) {
-    assertThat(activityScenario).isNotNull();
-    activityScenario.onActivity(
-        activity -> assertThat(activity.getLifecycle().getCurrentState()).isEqualTo(State.RESUMED));
-    activityScenario.moveToState(State.STARTED);
-    activityScenario.onActivity(
-        activity -> assertThat(activity.getLifecycle().getCurrentState()).isEqualTo(State.STARTED));
-    activityScenario.moveToState(State.CREATED);
-    activityScenario.onActivity(
-        activity -> assertThat(activity.getLifecycle().getCurrentState()).isEqualTo(State.CREATED));
+      assertThat(activityScenario).isNotNull();
+      activityScenario.onActivity(
+          activity ->
+              assertThat(activity.getLifecycle().getCurrentState()).isEqualTo(State.RESUMED));
+      activityScenario.moveToState(State.STARTED);
+      activityScenario.onActivity(
+          activity ->
+              assertThat(activity.getLifecycle().getCurrentState()).isEqualTo(State.STARTED));
+      activityScenario.moveToState(State.CREATED);
+      activityScenario.onActivity(
+          activity ->
+              assertThat(activity.getLifecycle().getCurrentState()).isEqualTo(State.CREATED));
     }
   }
 
@@ -222,22 +230,23 @@ public class ActivityScenarioTest {
     fragment.setRetainInstance(true);
     try (ActivityScenario<LifecycleOwnerActivity> activityScenario =
         ActivityScenario.launch(LifecycleOwnerActivity.class)) {
-    assertThat(activityScenario).isNotNull();
-    activityScenario.onActivity(
-        activity -> {
-          activity
-              .getSupportFragmentManager()
-              .beginTransaction()
-              .add(android.R.id.content, fragment)
-              .commitNow();
-          assertThat(activity.getSupportFragmentManager().findFragmentById(android.R.id.content))
-              .isSameInstanceAs(fragment);
-        });
-    activityScenario.recreate();
-    activityScenario.onActivity(
-        activity ->
+      assertThat(activityScenario).isNotNull();
+      activityScenario.onActivity(
+          activity -> {
+            activity
+                .getSupportFragmentManager()
+                .beginTransaction()
+                .add(android.R.id.content, fragment)
+                .commitNow();
             assertThat(activity.getSupportFragmentManager().findFragmentById(android.R.id.content))
-                .isSameInstanceAs(fragment));
+                .isSameInstanceAs(fragment);
+          });
+      activityScenario.recreate();
+      activityScenario.onActivity(
+          activity ->
+              assertThat(
+                      activity.getSupportFragmentManager().findFragmentById(android.R.id.content))
+                  .isSameInstanceAs(fragment));
     }
   }
 
@@ -247,22 +256,23 @@ public class ActivityScenarioTest {
     fragment.setRetainInstance(false);
     try (ActivityScenario<LifecycleOwnerActivity> activityScenario =
         ActivityScenario.launch(LifecycleOwnerActivity.class)) {
-    assertThat(activityScenario).isNotNull();
-    activityScenario.onActivity(
-        activity -> {
-          activity
-              .getSupportFragmentManager()
-              .beginTransaction()
-              .add(android.R.id.content, fragment)
-              .commitNow();
-          assertThat(activity.getSupportFragmentManager().findFragmentById(android.R.id.content))
-              .isSameInstanceAs(fragment);
-        });
-    activityScenario.recreate();
-    activityScenario.onActivity(
-        activity ->
+      assertThat(activityScenario).isNotNull();
+      activityScenario.onActivity(
+          activity -> {
+            activity
+                .getSupportFragmentManager()
+                .beginTransaction()
+                .add(android.R.id.content, fragment)
+                .commitNow();
             assertThat(activity.getSupportFragmentManager().findFragmentById(android.R.id.content))
-                .isNotSameInstanceAs(fragment));
+                .isSameInstanceAs(fragment);
+          });
+      activityScenario.recreate();
+      activityScenario.onActivity(
+          activity ->
+              assertThat(
+                      activity.getSupportFragmentManager().findFragmentById(android.R.id.content))
+                  .isNotSameInstanceAs(fragment));
     }
   }
 
diff --git a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/ActivityTestRuleTest.java b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/ActivityTestRuleTest.java
index 49ea7e943..736729775 100644
--- a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/ActivityTestRuleTest.java
+++ b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/ActivityTestRuleTest.java
@@ -16,8 +16,10 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-/** Integration tests for {@link ActivityTestRule} that verify it behaves consistently on device and
- * Robolectric. */
+/**
+ * Integration tests for {@link ActivityTestRule} that verify it behaves consistently on device and
+ * Robolectric.
+ */
 @RunWith(AndroidJUnit4.class)
 public class ActivityTestRuleTest {
 
@@ -58,7 +60,7 @@ public class ActivityTestRuleTest {
     @Override
     public void onStart() {
       super.onStart();
-     callbacks.add("onStart");
+      callbacks.add("onStart");
     }
 
     @Override
@@ -116,7 +118,8 @@ public class ActivityTestRuleTest {
     assertThat(activity.receivedBundle).isNull();
   }
 
-  @Test public void launchActivity_intentExtras() {
+  @Test
+  public void launchActivity_intentExtras() {
     Intent intent = new Intent();
     intent.putExtra("Key", "Value");
 
diff --git a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/InstrumentationRegistryTest.java b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/InstrumentationRegistryTest.java
index 285fac069..17d9fb208 100644
--- a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/InstrumentationRegistryTest.java
+++ b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/InstrumentationRegistryTest.java
@@ -56,5 +56,4 @@ public class InstrumentationRegistryTest {
           .isNotEqualTo(InstrumentationRegistry.getInstrumentation().getTargetContext());
     }
   }
-
 }
diff --git a/integration_tests/compat-target28/build.gradle b/integration_tests/compat-target28/build.gradle
deleted file mode 100644
index 7e11b884e..000000000
--- a/integration_tests/compat-target28/build.gradle
+++ /dev/null
@@ -1,45 +0,0 @@
-import org.robolectric.gradle.AndroidProjectConfigPlugin
-
-apply plugin: 'com.android.library'
-apply plugin: AndroidProjectConfigPlugin
-apply plugin: 'kotlin-android'
-apply plugin: "com.diffplug.spotless"
-apply plugin: "io.gitlab.arturbosch.detekt"
-
-spotless {
-    kotlin {
-        target '**/*.kt'
-        ktfmt('0.42').googleStyle()
-    }
-}
-
-android {
-    compileSdk 28
-    namespace 'org.robolectric.integrationtests.compattarget28'
-
-    defaultConfig {
-        minSdk 19
-        // We must keep targetSdk to 28 for compatibility testing purpose
-        targetSdk 28
-    }
-
-    compileOptions {
-        sourceCompatibility = '1.8'
-        targetCompatibility = '1.8'
-    }
-
-    kotlinOptions {
-        jvmTarget = '1.8'
-    }
-
-    testOptions.unitTests.includeAndroidResources true
-}
-
-dependencies {
-    implementation libs.kotlin.stdlib
-
-    testImplementation project(":testapp")
-    testImplementation project(":robolectric")
-    testImplementation libs.junit4
-    testImplementation libs.truth
-}
diff --git a/integration_tests/compat-target28/src/test/resources/robolectric.properties b/integration_tests/compat-target28/src/test/resources/robolectric.properties
deleted file mode 100644
index 89a6c8b4c..000000000
--- a/integration_tests/compat-target28/src/test/resources/robolectric.properties
+++ /dev/null
@@ -1 +0,0 @@
-sdk=28
\ No newline at end of file
diff --git a/integration_tests/ctesque/Android.bp b/integration_tests/ctesque/Android.bp
index a6ac50749..01e2c82f5 100644
--- a/integration_tests/ctesque/Android.bp
+++ b/integration_tests/ctesque/Android.bp
@@ -20,9 +20,9 @@ android_robolectric_test {
         "androidx.test.ext.truth",
     ],
     libs: [
-        "android.test.runner",
-        "android.test.base",
-        "android.test.mock",
+        "android.test.runner.stubs.system",
+        "android.test.base.stubs.system",
+        "android.test.mock.stubs.system",
         "truth",
         "guava",
     ],
diff --git a/integration_tests/ctesque/AndroidManifest.xml b/integration_tests/ctesque/AndroidManifest.xml
index 2600a4e7c..846c6ad43 100644
--- a/integration_tests/ctesque/AndroidManifest.xml
+++ b/integration_tests/ctesque/AndroidManifest.xml
@@ -5,7 +5,7 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="org.robolectric.integrationtests.ctesque">
   <uses-sdk
-      android:minSdkVersion="19"
+      android:minSdkVersion="21"
       android:targetSdkVersion="34" />
 
   <application />
diff --git a/integration_tests/ctesque/build.gradle b/integration_tests/ctesque/build.gradle
index e192e0d81..019007b5e 100644
--- a/integration_tests/ctesque/build.gradle
+++ b/integration_tests/ctesque/build.gradle
@@ -1,16 +1,15 @@
-import org.robolectric.gradle.AndroidProjectConfigPlugin
-import org.robolectric.gradle.GradleManagedDevicePlugin
-
-apply plugin: 'com.android.library'
-apply plugin: AndroidProjectConfigPlugin
-apply plugin: GradleManagedDevicePlugin
+plugins {
+    alias(libs.plugins.android.library)
+    alias(libs.plugins.robolectric.android.project)
+    alias(libs.plugins.robolectric.gradle.managed.device)
+}
 
 android {
     compileSdk 34
     namespace 'org.robolectric.integrationtests.ctesque'
 
     defaultConfig {
-        minSdk 19
+        minSdk 21
         targetSdk 34
         testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
     }
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/ActivityInstrTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/ActivityInstrTest.java
index 65e042781..589897eed 100644
--- a/integration_tests/ctesque/src/androidTest/java/android/app/ActivityInstrTest.java
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/ActivityInstrTest.java
@@ -9,12 +9,10 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
 import org.robolectric.testapp.ActivityWithAnotherTheme;
 import org.robolectric.testapp.ActivityWithoutTheme;
 import org.robolectric.testapp.R;
 
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public class ActivityInstrTest {
 
@@ -77,5 +75,4 @@ public class ActivityInstrTest {
           });
     }
   }
-
 }
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/ContextTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/ContextTest.java
new file mode 100644
index 000000000..b6943308d
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/ContextTest.java
@@ -0,0 +1,126 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.Manifest;
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.content.Context;
+import android.media.AudioManager;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.rule.GrantPermissionRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+@RunWith(AndroidJUnit4.class)
+public class ContextTest {
+  @Rule
+  public GrantPermissionRule mRuntimePermissionRule =
+      GrantPermissionRule.grant(
+          Manifest.permission.MODIFY_AUDIO_SETTINGS, Manifest.permission.GET_ACCOUNTS);
+
+  @Test
+  public void audioManager_applicationInstance_isNotSameAsActivityInstance() {
+    AudioManager applicationAudioManager =
+        (AudioManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.AUDIO_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AudioManager activityAudioManager =
+                (AudioManager) activity.getSystemService(Context.AUDIO_SERVICE);
+            assertThat(applicationAudioManager).isNotSameInstanceAs(activityAudioManager);
+          });
+    }
+  }
+
+  @Test
+  public void audioManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AudioManager activityAudioManager =
+                (AudioManager) activity.getSystemService(Context.AUDIO_SERVICE);
+            AudioManager anotherActivityAudioManager =
+                (AudioManager) activity.getSystemService(Context.AUDIO_SERVICE);
+            assertThat(anotherActivityAudioManager).isSameInstanceAs(activityAudioManager);
+          });
+    }
+  }
+
+  @Test
+  public void audioManager_instance_changesAffectEachOther() {
+    AudioManager applicationAudioManager =
+        (AudioManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.AUDIO_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AudioManager activityAudioManager =
+                (AudioManager) activity.getSystemService(Context.AUDIO_SERVICE);
+
+            activityAudioManager.setMode(AudioManager.MODE_RINGTONE);
+            assertThat(activityAudioManager.getMode()).isEqualTo(AudioManager.MODE_RINGTONE);
+            assertThat(applicationAudioManager.getMode()).isEqualTo(AudioManager.MODE_RINGTONE);
+
+            applicationAudioManager.setMode(AudioManager.MODE_NORMAL);
+            assertThat(activityAudioManager.getMode()).isEqualTo(AudioManager.MODE_NORMAL);
+            assertThat(applicationAudioManager.getMode()).isEqualTo(AudioManager.MODE_NORMAL);
+          });
+    }
+  }
+
+  @Test
+  public void accountManager_applicationInstance_isNotSameAsActivityInstance() {
+    AccountManager applicationAccountManager =
+        (AccountManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.ACCOUNT_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AccountManager activityAccountManager =
+                (AccountManager) activity.getSystemService(Context.ACCOUNT_SERVICE);
+            assertThat(applicationAccountManager).isNotSameInstanceAs(activityAccountManager);
+          });
+    }
+  }
+
+  @Test
+  public void accountManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AccountManager activityAccountManager =
+                (AccountManager) activity.getSystemService(Context.ACCOUNT_SERVICE);
+            AccountManager anotherActivityAccountManager =
+                (AccountManager) activity.getSystemService(Context.ACCOUNT_SERVICE);
+            assertThat(anotherActivityAccountManager).isSameInstanceAs(activityAccountManager);
+          });
+    }
+  }
+
+  @Test
+  public void accountManager_instance_retrievesSameAccounts() {
+    AccountManager applicationAccountManager =
+        (AccountManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.ACCOUNT_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AccountManager activityAccountManager =
+                (AccountManager) activity.getSystemService(Context.ACCOUNT_SERVICE);
+
+            Account[] applicationAccounts =
+                applicationAccountManager.getAccountsByType("com.example.account_type");
+            Account[] activityAccounts =
+                activityAccountManager.getAccountsByType("com.example.account_type");
+
+            assertThat(activityAccounts).isEqualTo(applicationAccounts);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/main/AndroidManifest.xml b/integration_tests/ctesque/src/main/AndroidManifest.xml
index c63fdfd37..56305cad8 100644
--- a/integration_tests/ctesque/src/main/AndroidManifest.xml
+++ b/integration_tests/ctesque/src/main/AndroidManifest.xml
@@ -3,6 +3,7 @@
   Manifest for ctesque tests
 -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android">
-
+  <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />
+  <uses-permission android:name="android.permission.GET_ACCOUNTS" />
   <application />
 </manifest>
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/animation/AnimationTest.java b/integration_tests/ctesque/src/sharedTest/java/android/animation/AnimationTest.java
index 9e6531811..c9cd02b4d 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/animation/AnimationTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/animation/AnimationTest.java
@@ -11,11 +11,9 @@ import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
 import org.robolectric.testapp.ActivityWithoutTheme;
 
 /** Compatibility test for animation-related logic. */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public final class AnimationTest {
 
@@ -62,7 +60,6 @@ public final class AnimationTest {
   }
 
   /** Private class with a public member. */
-  @DoNotInstrument
   @SuppressWarnings("unused")
   private static class PropertyBag {
     public float x;
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/app/ActivityTest.java b/integration_tests/ctesque/src/sharedTest/java/android/app/ActivityTest.java
index 71d404ca4..69f789087 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/app/ActivityTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/app/ActivityTest.java
@@ -1,6 +1,7 @@
 package android.app;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
 
 import android.graphics.drawable.ColorDrawable;
 import android.widget.Button;
@@ -9,17 +10,16 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
+import org.robolectric.testapp.AbstractTestActivity;
 import org.robolectric.testapp.ActivityWithAnotherTheme;
 import org.robolectric.testapp.ActivityWithoutTheme;
 import org.robolectric.testapp.R;
 
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public class ActivityTest {
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     ActivityWithAnotherTheme.setThemeBeforeContentView = null;
   }
 
@@ -77,4 +77,16 @@ public class ActivityTest {
           });
     }
   }
+
+  @Test
+  public void launchActivity_abstractActivity_throwsRuntimeException() {
+    assertThrows(
+        RuntimeException.class,
+        () -> {
+          try (ActivityScenario<AbstractTestActivity> scenario =
+              ActivityScenario.launch(AbstractTestActivity.class)) {
+            assertThat(scenario).isNull();
+          }
+        });
+  }
 }
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/app/InstrumentationTest.java b/integration_tests/ctesque/src/sharedTest/java/android/app/InstrumentationTest.java
index 0c2823fe3..44eb1a5a0 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/app/InstrumentationTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/app/InstrumentationTest.java
@@ -13,13 +13,11 @@ import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.LooperMode;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
 /**
  * Tests to verify android.app.Instrumentation APIs behave consistently between Robolectric and
  * device.
  */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 @LooperMode(PAUSED)
 public final class InstrumentationTest {
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/app/UiAutomationTest.java b/integration_tests/ctesque/src/sharedTest/java/android/app/UiAutomationTest.java
new file mode 100644
index 000000000..feb40051a
--- /dev/null
+++ b/integration_tests/ctesque/src/sharedTest/java/android/app/UiAutomationTest.java
@@ -0,0 +1,58 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.res.Configuration;
+import android.view.Display;
+import android.view.Surface;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.platform.app.InstrumentationRegistry;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.internal.DoNotInstrument;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link UiAutomation}. */
+@DoNotInstrument
+@RunWith(AndroidJUnit4.class)
+public class UiAutomationTest {
+  @Test
+  public void setRotation_freeze90_isLandscape() {
+    UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
+
+    uiAutomation.setRotation(UiAutomation.ROTATION_FREEZE_90);
+
+    try (ActivityScenario<? extends TestActivity> scenario =
+        ActivityScenario.launch(TestActivity.class)) {
+
+      scenario.onActivity(
+          activity -> {
+            Display display = activity.getWindowManager().getDefaultDisplay();
+            Configuration configuration = activity.getResources().getConfiguration();
+            assertThat(display.getRotation()).isEqualTo(Surface.ROTATION_90);
+            assertThat(display.getWidth()).isGreaterThan(display.getHeight());
+            assertThat(configuration.orientation).isEqualTo(Configuration.ORIENTATION_LANDSCAPE);
+            assertThat(configuration.screenWidthDp).isGreaterThan(configuration.screenHeightDp);
+          });
+    }
+  }
+
+  @Test
+  public void setRotation_freeze180_isPortrait() {
+    UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
+    uiAutomation.setRotation(UiAutomation.ROTATION_FREEZE_180);
+    try (ActivityScenario<? extends TestActivity> scenario =
+        ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            Display display = activity.getWindowManager().getDefaultDisplay();
+            Configuration configuration = activity.getResources().getConfiguration();
+            assertThat(display.getRotation()).isEqualTo(Surface.ROTATION_180);
+            assertThat(display.getWidth()).isLessThan(display.getHeight());
+            assertThat(configuration.orientation).isEqualTo(Configuration.ORIENTATION_PORTRAIT);
+            assertThat(configuration.screenWidthDp).isLessThan(configuration.screenHeightDp);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/app/UiAutomationTest.kt b/integration_tests/ctesque/src/sharedTest/java/android/app/UiAutomationTest.kt
deleted file mode 100644
index fc31e5a23..000000000
--- a/integration_tests/ctesque/src/sharedTest/java/android/app/UiAutomationTest.kt
+++ /dev/null
@@ -1,53 +0,0 @@
-package android.app
-
-import android.content.res.Configuration
-import android.view.Surface
-import androidx.test.core.app.ActivityScenario
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import androidx.test.platform.app.InstrumentationRegistry
-import com.google.common.truth.Truth.assertThat
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.robolectric.annotation.internal.DoNotInstrument
-import org.robolectric.testapp.TestActivity
-
-@Suppress("DEPRECATION")
-@DoNotInstrument
-@RunWith(AndroidJUnit4::class)
-class UiAutomationTest {
-  @Test
-  fun setRotation_freeze90_isLandscape() {
-    val uiAutomation = InstrumentationRegistry.getInstrumentation().uiAutomation
-
-    uiAutomation.setRotation(UiAutomation.ROTATION_FREEZE_90)
-
-    ActivityScenario.launch(TestActivity::class.java).use { scenario ->
-      scenario.onActivity { activity ->
-        val display = activity.windowManager.defaultDisplay
-        val configuration = activity.resources.configuration
-        assertThat(display.rotation).isEqualTo(Surface.ROTATION_90)
-        assertThat(display.width).isGreaterThan(display.height)
-        assertThat(configuration.orientation).isEqualTo(Configuration.ORIENTATION_LANDSCAPE)
-        assertThat(configuration.screenWidthDp).isGreaterThan(configuration.screenHeightDp)
-      }
-    }
-  }
-
-  @Test
-  fun setRotation_freeze180_isPortrait() {
-    val uiAutomation = InstrumentationRegistry.getInstrumentation().uiAutomation
-
-    uiAutomation.setRotation(UiAutomation.ROTATION_FREEZE_180)
-
-    ActivityScenario.launch(TestActivity::class.java).use { scenario ->
-      scenario.onActivity { activity ->
-        val display = activity.windowManager.defaultDisplay
-        val configuration = activity.resources.configuration
-        assertThat(display.rotation).isEqualTo(Surface.ROTATION_180)
-        assertThat(display.width).isLessThan(display.height)
-        assertThat(configuration.orientation).isEqualTo(Configuration.ORIENTATION_PORTRAIT)
-        assertThat(configuration.screenWidthDp).isLessThan(configuration.screenHeightDp)
-      }
-    }
-  }
-}
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/content/pm/PackageManagerTest.java b/integration_tests/ctesque/src/sharedTest/java/android/content/pm/PackageManagerTest.java
index 694760b57..da0eb311b 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/content/pm/PackageManagerTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/content/pm/PackageManagerTest.java
@@ -26,11 +26,9 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
-import org.robolectric.annotation.internal.DoNotInstrument;
 import org.robolectric.testapp.TestService;
 
 /** Compatibility test for {@link PackageManager} */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public final class PackageManagerTest {
   private Context context;
@@ -254,8 +252,7 @@ public final class PackageManagerTest {
 
     PackageInfo packageInfo =
         pm.getPackageInfo(
-            context.getPackageName(),
-            GET_SERVICES | GET_ACTIVITIES | MATCH_DISABLED_COMPONENTS);
+            context.getPackageName(), GET_SERVICES | GET_ACTIVITIES | MATCH_DISABLED_COMPONENTS);
     ActivityInfo[] activities = filterExtraneous(packageInfo.activities);
 
     assertThat(packageInfo.applicationInfo.enabled).isFalse();
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/content/res/AssetManagerTest.java b/integration_tests/ctesque/src/sharedTest/java/android/content/res/AssetManagerTest.java
index 15576c69a..9dddc1e33 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/content/res/AssetManagerTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/content/res/AssetManagerTest.java
@@ -16,12 +16,8 @@ import java.nio.charset.Charset;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
-/**
- * Compatibility test for {@link AssetManager}
- */
-@DoNotInstrument
+/** Compatibility test for {@link AssetManager} */
 @RunWith(AndroidJUnit4.class)
 public class AssetManagerTest {
 
@@ -41,8 +37,7 @@ public class AssetManagerTest {
         .asList()
         .containsAtLeast("assetsHome.txt", "robolectric.png", "myFont.ttf");
 
-    assertThat(assetManager.list("testing")).asList()
-        .contains("hello.txt");
+    assertThat(assetManager.list("testing")).asList().contains("hello.txt");
 
     assertThat(assetManager.list("bogus-dir")).isEmpty();
   }
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/content/res/ResourcesTest.java b/integration_tests/ctesque/src/sharedTest/java/android/content/res/ResourcesTest.java
index 5a08f8d29..d987e962e 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/content/res/ResourcesTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/content/res/ResourcesTest.java
@@ -52,15 +52,11 @@ import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
-import org.robolectric.annotation.internal.DoNotInstrument;
 import org.robolectric.testapp.R;
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
 
-/**
- * Compatibility test for {@link Resources}
- */
-@DoNotInstrument
+/** Compatibility test for {@link Resources} */
 @RunWith(AndroidJUnit4.class)
 public class ResourcesTest {
   private Resources resources;
@@ -125,8 +121,8 @@ public class ResourcesTest {
 
   @Test
   public void getStringShouldConvertCodePoints() {
-    assertThat(resources.getString(R.string.non_breaking_space)).isEqualTo("Closing"
-                                                                               + " soon:\u00A05pm");
+    assertThat(resources.getString(R.string.non_breaking_space))
+        .isEqualTo("Closing" + " soon:\u00A05pm");
     assertThat(resources.getString(R.string.space)).isEqualTo("Closing soon: 5pm");
   }
 
@@ -171,7 +167,7 @@ public class ResourcesTest {
 
   @Test
   public void getStringArray() {
-    assertThat(resources.getStringArray(R.array.items)).isEqualTo(new String[]{"foo", "bar"});
+    assertThat(resources.getStringArray(R.array.items)).isEqualTo(new String[] {"foo", "bar"});
     assertThat(resources.getStringArray(R.array.greetings))
         .isEqualTo(new String[] {"hola", "Hello"});
   }
@@ -252,10 +248,13 @@ public class ResourcesTest {
 
   @Test
   public void getIntArray() {
-    assertThat(resources.getIntArray(R.array.empty_int_array)).isEqualTo(new int[]{});
-    assertThat(resources.getIntArray(R.array.zero_to_four_int_array)).isEqualTo(new int[]{0, 1, 2, 3, 4});
-    assertThat(resources.getIntArray(R.array.with_references_int_array)).isEqualTo(new int[]{0, 2000, 1});
-    assertThat(resources.getIntArray(R.array.referenced_colors_int_array)).isEqualTo(new int[]{0x1, 0xFFFFFFFF, 0xFF000000, 0xFFF5F5F5, 0x802C76AD});
+    assertThat(resources.getIntArray(R.array.empty_int_array)).isEqualTo(new int[] {});
+    assertThat(resources.getIntArray(R.array.zero_to_four_int_array))
+        .isEqualTo(new int[] {0, 1, 2, 3, 4});
+    assertThat(resources.getIntArray(R.array.with_references_int_array))
+        .isEqualTo(new int[] {0, 2000, 1});
+    assertThat(resources.getIntArray(R.array.referenced_colors_int_array))
+        .isEqualTo(new int[] {0x1, 0xFFFFFFFF, 0xFF000000, 0xFFF5F5F5, 0x802C76AD});
   }
 
   @Test
@@ -371,10 +370,15 @@ public class ResourcesTest {
     assertThat(resources.getFraction(R.fraction.half_of_parent, myself, myParent)).isEqualTo(300f);
 
     assertThat(resources.getFraction(R.fraction.quarter_as_item, myself, myParent)).isEqualTo(75f);
-    assertThat(resources.getFraction(R.fraction.quarter_of_parent_as_item, myself, myParent)).isEqualTo(150f);
+    assertThat(resources.getFraction(R.fraction.quarter_of_parent_as_item, myself, myParent))
+        .isEqualTo(150f);
 
-    assertThat(resources.getFraction(R.fraction.fifth_as_reference, myself, myParent)).isWithin(0.01f).of(60f);
-    assertThat(resources.getFraction(R.fraction.fifth_of_parent_as_reference, myself, myParent)).isWithin(0.01f).of(120f);
+    assertThat(resources.getFraction(R.fraction.fifth_as_reference, myself, myParent))
+        .isWithin(0.01f)
+        .of(60f);
+    assertThat(resources.getFraction(R.fraction.fifth_of_parent_as_reference, myself, myParent))
+        .isWithin(0.01f)
+        .of(120f);
   }
 
   @Test
@@ -430,7 +434,8 @@ public class ResourcesTest {
 
   @Test
   public void testGetColorStateList() {
-    assertThat(resources.getColorStateList(R.color.color_state_list)).isInstanceOf(ColorStateList.class);
+    assertThat(resources.getColorStateList(R.color.color_state_list))
+        .isInstanceOf(ColorStateList.class);
   }
 
   @Test
@@ -440,7 +445,8 @@ public class ResourcesTest {
 
   @Test
   public void testGetNinePatchDrawable() {
-    assertThat(resources.getDrawable(R.drawable.nine_patch_drawable)).isInstanceOf(NinePatchDrawable.class);
+    assertThat(resources.getDrawable(R.drawable.nine_patch_drawable))
+        .isInstanceOf(NinePatchDrawable.class);
   }
 
   @Test
@@ -486,7 +492,6 @@ public class ResourcesTest {
     String string = resources.getString(R.string.hello);
     assertThat(string).isEqualTo("Hello");
 
-
     int id = resources.getIdentifier("hello", "string", context.getPackageName());
     assertThat(id).isEqualTo(R.string.hello);
 
@@ -718,11 +723,14 @@ public class ResourcesTest {
 
   // @Test
   // public void obtainAttributes_shouldUseReferencedIdFromAttributeSet() throws Exception {
-  //   // android:id/mask was introduced in API 21, but it's still possible for apps built against API 21 to refer to it
-  //   // in older runtimes because referenced resource ids are compiled (by aapt) into the binary XML format.
+  //   // android:id/mask was introduced in API 21, but it's still possible for apps built against
+  // API 21 to refer to it
+  //   // in older runtimes because referenced resource ids are compiled (by aapt) into the binary
+  // XML format.
   //   AttributeSet attributeSet = Robolectric.buildAttributeSet()
   //       .addAttribute(android.R.attr.id, "@android:id/mask").build();
-  //   TypedArray typedArray = resources.obtainAttributes(attributeSet, new int[]{android.R.attr.id});
+  //   TypedArray typedArray = resources.obtainAttributes(attributeSet, new
+  // int[]{android.R.attr.id});
   //   assertThat(typedArray.getResourceId(0, -9)).isEqualTo(android.R.id.mask);
   // }
 
@@ -730,7 +738,7 @@ public class ResourcesTest {
   public void obtainStyledAttributesShouldDereferenceValues() {
     Resources.Theme theme = resources.newTheme();
     theme.applyStyle(R.style.MyBlackTheme, false);
-    TypedArray arr = theme.obtainStyledAttributes(new int[]{android.R.attr.windowBackground});
+    TypedArray arr = theme.obtainStyledAttributes(new int[] {android.R.attr.windowBackground});
     TypedValue value = new TypedValue();
     arr.getValue(0, value);
     arr.recycle();
@@ -740,11 +748,15 @@ public class ResourcesTest {
   }
 
   // @Test
-  // public void obtainStyledAttributes_shouldCheckXmlFirst_fromAttributeSetBuilder() throws Exception {
+  // public void obtainStyledAttributes_shouldCheckXmlFirst_fromAttributeSetBuilder() throws
+  // Exception {
   //
-  //   // This simulates a ResourceProvider built from a 21+ SDK as viewportHeight / viewportWidth were introduced in API 21
-  //   // but the public ID values they are assigned clash with private com.android.internal.R values on older SDKs. This
-  //   // test ensures that even on older SDKs, on calls to obtainStyledAttributes() Robolectric will first check for matching
+  //   // This simulates a ResourceProvider built from a 21+ SDK as viewportHeight / viewportWidth
+  // were introduced in API 21
+  //   // but the public ID values they are assigned clash with private com.android.internal.R
+  // values on older SDKs. This
+  //   // test ensures that even on older SDKs, on calls to obtainStyledAttributes() Robolectric
+  // will first check for matching
   //   // resource ID values in the AttributeSet before checking the theme.
   //
   //   AttributeSet attributes = Robolectric.buildAttributeSet()
@@ -762,11 +774,15 @@ public class ResourcesTest {
   // }
 
   @Test
-  public void obtainStyledAttributes_shouldCheckXmlFirst_fromXmlLoadedFromResources() throws Exception {
+  public void obtainStyledAttributes_shouldCheckXmlFirst_fromXmlLoadedFromResources()
+      throws Exception {
 
-    // This simulates a ResourceProvider built from a 21+ SDK as viewportHeight / viewportWidth were introduced in API 21
-    // but the public ID values they are assigned clash with private com.android.internal.R values on older SDKs. This
-    // test ensures that even on older SDKs, on calls to obtainStyledAttributes() Robolectric will first check for matching
+    // This simulates a ResourceProvider built from a 21+ SDK as viewportHeight / viewportWidth were
+    // introduced in API 21
+    // but the public ID values they are assigned clash with private com.android.internal.R values
+    // on older SDKs. This
+    // test ensures that even on older SDKs, on calls to obtainStyledAttributes() Robolectric will
+    // first check for matching
     // resource ID values in the AttributeSet before checking the theme.
 
     XmlResourceParser xml = context.getResources().getXml(R.drawable.vector);
@@ -774,10 +790,14 @@ public class ResourcesTest {
     xml.next();
     AttributeSet attributeSet = Xml.asAttributeSet(xml);
 
-    TypedArray typedArray = context.getTheme().obtainStyledAttributes(attributeSet, new int[] {
-        android.R.attr.viewportWidth,
-        android.R.attr.viewportHeight
-    }, 0, 0);
+    TypedArray typedArray =
+        context
+            .getTheme()
+            .obtainStyledAttributes(
+                attributeSet,
+                new int[] {android.R.attr.viewportWidth, android.R.attr.viewportHeight},
+                0,
+                0);
     assertThat(typedArray.getFloat(0, 0)).isEqualTo(12.0f);
     assertThat(typedArray.getFloat(1, 0)).isEqualTo(24.0f);
     typedArray.recycle();
@@ -800,7 +820,9 @@ public class ResourcesTest {
     final Resources.Theme theme = resources.newTheme();
 
     theme.applyStyle(R.style.MyBlackTheme, true);
-    TypedArray arr = theme.obtainStyledAttributes(new int[]{android.R.attr.windowBackground, android.R.attr.textColorHint});
+    TypedArray arr =
+        theme.obtainStyledAttributes(
+            new int[] {android.R.attr.windowBackground, android.R.attr.textColorHint});
 
     final TypedValue blackBackgroundColor = new TypedValue();
     arr.getValue(0, blackBackgroundColor);
@@ -808,7 +830,13 @@ public class ResourcesTest {
     arr.recycle();
 
     theme.applyStyle(R.style.MyBlueTheme, true);
-    arr = theme.obtainStyledAttributes(new int[]{android.R.attr.windowBackground, android.R.attr.textColor, android.R.attr.textColorHint});
+    arr =
+        theme.obtainStyledAttributes(
+            new int[] {
+              android.R.attr.windowBackground,
+              android.R.attr.textColor,
+              android.R.attr.textColorHint
+            });
 
     final TypedValue blueBackgroundColor = new TypedValue();
     arr.getValue(0, blueBackgroundColor);
@@ -831,7 +859,9 @@ public class ResourcesTest {
 
     // Apply black theme
     theme.applyStyle(R.style.MyBlackTheme, true);
-    TypedArray arr = theme.obtainStyledAttributes(new int[]{android.R.attr.windowBackground, android.R.attr.textColorHint});
+    TypedArray arr =
+        theme.obtainStyledAttributes(
+            new int[] {android.R.attr.windowBackground, android.R.attr.textColorHint});
 
     final TypedValue blackBackgroundColor = new TypedValue();
     arr.getValue(0, blackBackgroundColor);
@@ -845,7 +875,13 @@ public class ResourcesTest {
 
     // Apply blue theme
     theme.applyStyle(R.style.MyBlueTheme, false);
-    arr = theme.obtainStyledAttributes(new int[]{android.R.attr.windowBackground, android.R.attr.textColor, android.R.attr.textColorHint});
+    arr =
+        theme.obtainStyledAttributes(
+            new int[] {
+              android.R.attr.windowBackground,
+              android.R.attr.textColor,
+              android.R.attr.textColorHint
+            });
 
     final TypedValue blueBackgroundColor = new TypedValue();
     arr.getValue(0, blueBackgroundColor);
@@ -988,14 +1024,14 @@ public class ResourcesTest {
 
   @Test
   public void getResourceIdentifier_shouldReturnValueFromRClass() {
-    assertThat(
-        resources.getIdentifier("id_declared_in_item_tag", "id", context.getPackageName()))
+    assertThat(resources.getIdentifier("id_declared_in_item_tag", "id", context.getPackageName()))
         .isEqualTo(R.id.id_declared_in_item_tag);
     assertThat(
-        resources.getIdentifier("id/id_declared_in_item_tag", null, context.getPackageName()))
+            resources.getIdentifier("id/id_declared_in_item_tag", null, context.getPackageName()))
         .isEqualTo(R.id.id_declared_in_item_tag);
     assertThat(
-        resources.getIdentifier(context.getPackageName() + ":id_declared_in_item_tag", "id", null))
+            resources.getIdentifier(
+                context.getPackageName() + ":id_declared_in_item_tag", "id", null))
         .isEqualTo(R.id.id_declared_in_item_tag);
     assertThat(
             resources.getIdentifier(
@@ -1005,30 +1041,19 @@ public class ResourcesTest {
 
   @Test
   public void whenPackageIsUnknown_getResourceIdentifier_shouldReturnZero() {
-    assertThat(
-        resources.getIdentifier("whatever", "id", "some.unknown.package"))
-        .isEqualTo(0);
-    assertThat(
-        resources.getIdentifier("id/whatever", null, "some.unknown.package"))
-        .isEqualTo(0);
-    assertThat(
-        resources.getIdentifier("some.unknown.package:whatever", "id", null))
-        .isEqualTo(0);
-    assertThat(
-        resources.getIdentifier("some.unknown.package:id/whatever", "other", "other"))
+    assertThat(resources.getIdentifier("whatever", "id", "some.unknown.package")).isEqualTo(0);
+    assertThat(resources.getIdentifier("id/whatever", null, "some.unknown.package")).isEqualTo(0);
+    assertThat(resources.getIdentifier("some.unknown.package:whatever", "id", null)).isEqualTo(0);
+    assertThat(resources.getIdentifier("some.unknown.package:id/whatever", "other", "other"))
         .isEqualTo(0);
 
-    assertThat(
-        resources.getIdentifier("whatever", "drawable", "some.unknown.package"))
+    assertThat(resources.getIdentifier("whatever", "drawable", "some.unknown.package"))
         .isEqualTo(0);
-    assertThat(
-        resources.getIdentifier("drawable/whatever", null, "some.unknown.package"))
+    assertThat(resources.getIdentifier("drawable/whatever", null, "some.unknown.package"))
         .isEqualTo(0);
-    assertThat(
-        resources.getIdentifier("some.unknown.package:whatever", "drawable", null))
+    assertThat(resources.getIdentifier("some.unknown.package:whatever", "drawable", null))
         .isEqualTo(0);
-    assertThat(
-        resources.getIdentifier("some.unknown.package:id/whatever", "other", "other"))
+    assertThat(resources.getIdentifier("some.unknown.package:id/whatever", "other", "other"))
         .isEqualTo(0);
   }
 
@@ -1038,44 +1063,39 @@ public class ResourcesTest {
           + "layouts for +@id/___, which is expensive")
   public void whenCalledForIdWithNameNotInRClassOrXml_getResourceIdentifier_shouldReturnZero() {
     assertThat(
-        resources.getIdentifier(
-            "org.robolectric:id/idThatDoesntExistAnywhere", "other", "other"))
+            resources.getIdentifier(
+                "org.robolectric:id/idThatDoesntExistAnywhere", "other", "other"))
         .isEqualTo(0);
   }
 
   @Test
   public void
       whenIdIsAbsentInXmlButPresentInRClass_getResourceIdentifier_shouldReturnIdFromRClass_probablyBecauseItWasDeclaredInALayout() {
-    assertThat(
-        resources.getIdentifier("id_declared_in_layout", "id", context.getPackageName()))
+    assertThat(resources.getIdentifier("id_declared_in_layout", "id", context.getPackageName()))
         .isEqualTo(R.id.id_declared_in_layout);
   }
 
   @Test
   public void whenResourceIsAbsentInXml_getResourceIdentifier_shouldReturn0() {
-    assertThat(
-        resources.getIdentifier("fictitiousDrawable", "drawable", context.getPackageName()))
+    assertThat(resources.getIdentifier("fictitiousDrawable", "drawable", context.getPackageName()))
         .isEqualTo(0);
   }
 
   @Test
   public void whenResourceIsAbsentInXml_getResourceIdentifier_shouldReturnId() {
-    assertThat(
-        resources.getIdentifier("an_image", "drawable", context.getPackageName()))
+    assertThat(resources.getIdentifier("an_image", "drawable", context.getPackageName()))
         .isEqualTo(R.drawable.an_image);
   }
 
   @Test
   public void whenResourceIsXml_getResourceIdentifier_shouldReturnId() {
-    assertThat(
-        resources.getIdentifier("preferences", "xml", context.getPackageName()))
+    assertThat(resources.getIdentifier("preferences", "xml", context.getPackageName()))
         .isEqualTo(R.xml.preferences);
   }
 
   @Test
   public void whenResourceIsRaw_getResourceIdentifier_shouldReturnId() {
-    assertThat(
-        resources.getIdentifier("raw_resource", "raw", context.getPackageName()))
+    assertThat(resources.getIdentifier("raw_resource", "raw", context.getPackageName()))
         .isEqualTo(R.raw.raw_resource);
   }
 
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/content/res/ThemeTest.java b/integration_tests/ctesque/src/sharedTest/java/android/content/res/ThemeTest.java
index b546a373e..341a6487f 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/content/res/ThemeTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/content/res/ThemeTest.java
@@ -13,13 +13,9 @@ import androidx.test.platform.app.InstrumentationRegistry;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
 import org.robolectric.testapp.R;
 
-/**
- * Compatibility test for {@link Resources.Theme}
- */
-@DoNotInstrument
+/** Compatibility test for {@link Resources.Theme} */
 @RunWith(AndroidJUnit4.class)
 public class ThemeTest {
 
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/database/SQLiteDatabaseTest.java b/integration_tests/ctesque/src/sharedTest/java/android/database/SQLiteDatabaseTest.java
index b00502897..bd08d5712 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/database/SQLiteDatabaseTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/database/SQLiteDatabaseTest.java
@@ -26,10 +26,8 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
 /** Compatibility test for {@link android.database.sqlite.SQLiteDatabase} */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public class SQLiteDatabaseTest {
 
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/graphics/BitmapFactoryTest.java b/integration_tests/ctesque/src/sharedTest/java/android/graphics/BitmapFactoryTest.java
index b9d95d517..94cbe146d 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/graphics/BitmapFactoryTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/graphics/BitmapFactoryTest.java
@@ -17,11 +17,9 @@ import java.nio.charset.Charset;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
 import org.robolectric.testapp.R;
 
 /** Compatibility test for {@link BitmapFactory} */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public class BitmapFactoryTest {
 
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/graphics/BitmapTest.java b/integration_tests/ctesque/src/sharedTest/java/android/graphics/BitmapTest.java
index a68fce2b4..f3604d3ba 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/graphics/BitmapTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/graphics/BitmapTest.java
@@ -29,11 +29,9 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
-import org.robolectric.annotation.internal.DoNotInstrument;
 import org.robolectric.testapp.R;
 
 /** Compatibility test for {@link Bitmap} */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public class BitmapTest {
 
@@ -46,7 +44,8 @@ public class BitmapTest {
 
   @Config(minSdk = P)
   @SdkSuppress(minSdkVersion = P)
-  @Test public void createBitmap() {
+  @Test
+  public void createBitmap() {
     assume().that(System.getProperty("robolectric.graphicsMode")).isNotEqualTo("NATIVE");
     // Bitmap.createBitmap(Picture) requires hardware-backed bitmaps
     HardwareRendererCompat.setDrawingEnabled(true);
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/graphics/CanvasTest.java b/integration_tests/ctesque/src/sharedTest/java/android/graphics/CanvasTest.java
index 039b5b69a..6eebe7fc7 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/graphics/CanvasTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/graphics/CanvasTest.java
@@ -5,10 +5,8 @@ import static com.google.common.truth.Truth.assertThat;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
 /** Compatibility tests for {@link Canvas} */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public class CanvasTest {
   @Test
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/graphics/ColorTest.java b/integration_tests/ctesque/src/sharedTest/java/android/graphics/ColorTest.java
index 308410b44..075d2798b 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/graphics/ColorTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/graphics/ColorTest.java
@@ -5,10 +5,8 @@ import static com.google.common.truth.Truth.assertThat;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
 /** Compatibility tests for {@link Color} */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public class ColorTest {
   @Test
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/graphics/MatrixTest.java b/integration_tests/ctesque/src/sharedTest/java/android/graphics/MatrixTest.java
index 14ecd5b0d..b085fd3a8 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/graphics/MatrixTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/graphics/MatrixTest.java
@@ -7,10 +7,8 @@ import android.graphics.Matrix.ScaleToFit;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
 /** Compatibility test for {@link Matrix} */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public final class MatrixTest {
 
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/graphics/PathTest.java b/integration_tests/ctesque/src/sharedTest/java/android/graphics/PathTest.java
index f92d5a60a..f899a7d4f 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/graphics/PathTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/graphics/PathTest.java
@@ -2,13 +2,11 @@ package android.graphics;
 
 import static com.google.common.truth.Truth.assertThat;
 
-import androidx.test.runner.AndroidJUnit4;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
 /** Compatibility test for {@link Path} */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public class PathTest {
 
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/media/MediaPlayerTest.java b/integration_tests/ctesque/src/sharedTest/java/android/media/MediaPlayerTest.java
new file mode 100644
index 000000000..e492fc516
--- /dev/null
+++ b/integration_tests/ctesque/src/sharedTest/java/android/media/MediaPlayerTest.java
@@ -0,0 +1,27 @@
+package android.media;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Build;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Compatibility test for {@link android.media.MediaPlayer} */
+@RunWith(AndroidJUnit4.class)
+public class MediaPlayerTest {
+
+  /**
+   * Checks that a MediaPlayer in the IDLE state does not throw an exception when calling {@link
+   * MediaPlayer#getCurrentPosition()}.
+   */
+  @Test
+  public void newMediaPlayer_getCurrentPosition_doesNotThrow() {
+    MediaPlayer mediaPlayer = new MediaPlayer();
+    int currentPosition = mediaPlayer.getCurrentPosition();
+    // currentPosition appears to be inconsistent garbage when run on emulators for SDKs < 30
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
+      assertThat(currentPosition).isEqualTo(0);
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/os/LooperTest.java b/integration_tests/ctesque/src/sharedTest/java/android/os/LooperTest.java
index 14a4a7d79..9d9e806e6 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/os/LooperTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/os/LooperTest.java
@@ -9,10 +9,8 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.LooperMode.Mode;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
 /** Tests to verify INSTRUMENTATION_TEST mode Looper behaves like a looping Looper. */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public class LooperTest {
 
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/text/format/DateFormatTest.java b/integration_tests/ctesque/src/sharedTest/java/android/text/format/DateFormatTest.java
index 82ad1658b..95436dbb0 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/text/format/DateFormatTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/text/format/DateFormatTest.java
@@ -14,11 +14,9 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
 /** Tests that Robolectric's android.text.format.DateFormat support is consistent with device. */
 @RunWith(AndroidJUnit4.class)
-@DoNotInstrument
 @Config(qualifiers = "+en-rUS")
 public class DateFormatTest {
 
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/text/format/LineBreakerTest.java b/integration_tests/ctesque/src/sharedTest/java/android/text/format/LineBreakerTest.java
index 8bf97ce3d..d9cd94a34 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/text/format/LineBreakerTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/text/format/LineBreakerTest.java
@@ -12,10 +12,8 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
 /** Tests that Robolectric's android.graphics.text.LineBreaker support is consistent with device. */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public class LineBreakerTest {
   @Test
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/text/format/StaticLayoutTest.java b/integration_tests/ctesque/src/sharedTest/java/android/text/format/StaticLayoutTest.java
index 51f49d65a..5fa3b417d 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/text/format/StaticLayoutTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/text/format/StaticLayoutTest.java
@@ -8,10 +8,8 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
 /** Tests that Robolectric's android.text.StaticLayout support is consistent with device. */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public class StaticLayoutTest {
   @Test
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/text/format/TimeTest.java b/integration_tests/ctesque/src/sharedTest/java/android/text/format/TimeTest.java
index 41d066dfd..d7a497aa1 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/text/format/TimeTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/text/format/TimeTest.java
@@ -14,9 +14,7 @@ import java.util.TimeZone;
 import org.junit.After;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public class TimeTest {
 
@@ -262,14 +260,10 @@ public class TimeTest {
     // ICS
 
     // date_and_time
-    assertEquals(
-        "Sep 8, 1987, 2:13:12 PM",
-        t.format("%b %-e, %Y, %-l:%M:%S %p"));
+    assertEquals("Sep 8, 1987, 2:13:12 PM", t.format("%b %-e, %Y, %-l:%M:%S %p"));
 
     // hour_minute_cap_ampm
-    assertEquals(
-        "2:13PM",
-        t.format("%-l:%M%^p"));
+    assertEquals("2:13PM", t.format("%-l:%M%^p"));
   }
 
   @Test
@@ -279,8 +273,8 @@ public class TimeTest {
     assertEquals("19700101T000000", t.format2445());
 
     t.timezone = Time.TIMEZONE_UTC;
-    //2445 formatted date should hava a Z postfix
-    assertEquals("19700101T000000Z",t.format2445());
+    // 2445 formatted date should hava a Z postfix
+    assertEquals("19700101T000000Z", t.format2445());
   }
 
   @Test
@@ -339,5 +333,4 @@ public class TimeTest {
 
     assertEquals(day, julianDay);
   }
-
 }
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/util/RationalTest.java b/integration_tests/ctesque/src/sharedTest/java/android/util/RationalTest.java
index 46565be13..e0e3dd431 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/util/RationalTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/util/RationalTest.java
@@ -12,10 +12,6 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- *
- * This test is created from Android CTS tests:
- *
- * https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/util/src/android/util/cts/RationalTest.java
  */
 
 package android.util;
@@ -29,6 +25,7 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+import android.os.Build;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
@@ -40,9 +37,13 @@ import java.io.Serializable;
 import java.lang.reflect.Field;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
-@DoNotInstrument
+/**
+ * CTS tests for {@link Rational}.
+ *
+ * <p>Copied from <a
+ * href="https://cs.android.com/android/platform/superproject/main/+/main:cts/tests/tests/util/src/android/util/cts/RationalTest.java">RationalTest</a>
+ */
 @RunWith(AndroidJUnit4.class)
 public class RationalTest {
 
@@ -324,7 +325,7 @@ public class RationalTest {
   }
 
   @Test
-  public void testSerialize() throws ClassNotFoundException, IOException, NoSuchFieldException {
+  public void testSerialize() throws ClassNotFoundException, IOException {
     /*
      * Check correct [de]serialization
      */
@@ -338,47 +339,54 @@ public class RationalTest {
     verifyEqualsAfterSerializing(new Rational(5, 1));
     verifyEqualsAfterSerializing(new Rational(Integer.MAX_VALUE, Integer.MIN_VALUE));
 
-    /*
-     * Check bad deserialization fails
-     */
-    try {
-      Rational badZero = createIllegalRational(0, 100); // [0, 100] , should be [0, 1]
-      Rational results = serializeRoundTrip(badZero);
-      fail("Deserializing " + results + " should not have succeeded");
-    } catch (InvalidObjectException e) {
-      // OK
-    }
-
-    try {
-      Rational badPosInfinity = createIllegalRational(100, 0); // [100, 0] , should be [1, 0]
-      Rational results = serializeRoundTrip(badPosInfinity);
-      fail("Deserializing " + results + " should not have succeeded");
-    } catch (InvalidObjectException e) {
-      // OK
-    }
-
-    try {
-      Rational badNegInfinity = createIllegalRational(-100, 0); // [-100, 0] , should be [-1, 0]
-      Rational results = serializeRoundTrip(badNegInfinity);
-      fail("Deserializing " + results + " should not have succeeded");
-    } catch (InvalidObjectException e) {
-      // OK
-    }
-
-    try {
-      Rational badReduced = createIllegalRational(2, 4); // [2,4] , should be [1, 2]
-      Rational results = serializeRoundTrip(badReduced);
-      fail("Deserializing " + results + " should not have succeeded");
-    } catch (InvalidObjectException e) {
-      // OK
-    }
-
-    try {
-      Rational badReducedNeg = createIllegalRational(-2, 4); // [-2, 4] should be [-1, 2]
-      Rational results = serializeRoundTrip(badReducedNeg);
-      fail("Deserializing " + results + " should not have succeeded");
-    } catch (InvalidObjectException e) {
-      // OK
+    // We only run following illegal Rational serialization tests as it use reflections
+    // to construct illegal Rational and these private fields are restricted after
+    // Android S. We have tried Test Orchestrator with --no-hidden-api-checks, but it didn't
+    // work and we don't want to bring external libraries to bypass it. So just disabling it
+    // for Android S+ devices.
+    if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.R) {
+      /*
+       * Check bad deserialization fails
+       */
+      try {
+        Rational badZero = createIllegalRational(0, 100); // [0, 100] , should be [0, 1]
+        Rational results = serializeRoundTrip(badZero);
+        fail("Deserializing " + results + " should not have succeeded");
+      } catch (InvalidObjectException e) {
+        // OK
+      }
+
+      try {
+        Rational badPosInfinity = createIllegalRational(100, 0); // [100, 0] , should be [1, 0]
+        Rational results = serializeRoundTrip(badPosInfinity);
+        fail("Deserializing " + results + " should not have succeeded");
+      } catch (InvalidObjectException e) {
+        // OK
+      }
+
+      try {
+        Rational badNegInfinity = createIllegalRational(-100, 0); // [-100, 0] , should be [-1, 0]
+        Rational results = serializeRoundTrip(badNegInfinity);
+        fail("Deserializing " + results + " should not have succeeded");
+      } catch (InvalidObjectException e) {
+        // OK
+      }
+
+      try {
+        Rational badReduced = createIllegalRational(2, 4); // [2,4] , should be [1, 2]
+        Rational results = serializeRoundTrip(badReduced);
+        fail("Deserializing " + results + " should not have succeeded");
+      } catch (InvalidObjectException e) {
+        // OK
+      }
+
+      try {
+        Rational badReducedNeg = createIllegalRational(-2, 4); // [-2, 4] should be [-1, 2]
+        Rational results = serializeRoundTrip(badReducedNeg);
+        fail("Deserializing " + results + " should not have succeeded");
+      } catch (InvalidObjectException e) {
+        // OK
+      }
     }
   }
 
@@ -498,8 +506,7 @@ public class RationalTest {
       throws IOException, ClassNotFoundException {
     Class<T> klass = (Class<T>) obj.getClass();
     byte[] arr = serialize(obj);
-    T serialized = deserialize(arr, klass);
-    return serialized;
+    return deserialize(arr, klass);
   }
 
   private static <T extends Serializable> void verifyEqualsAfterSerializing(T obj)
@@ -520,11 +527,7 @@ public class RationalTest {
       Field f = object.getClass().getDeclaredField(name);
       f.setAccessible(true);
       f.set(object, value);
-    } catch (NoSuchFieldException e) {
-      throw new AssertionError(e);
-    } catch (IllegalAccessException e) {
-      throw new AssertionError(e);
-    } catch (IllegalArgumentException e) {
+    } catch (NoSuchFieldException | IllegalAccessException | IllegalArgumentException e) {
       throw new AssertionError(e);
     }
   }
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/view/KeyCharacterMapTest.java b/integration_tests/ctesque/src/sharedTest/java/android/view/KeyCharacterMapTest.java
index 20e84a22c..5660d95d8 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/view/KeyCharacterMapTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/view/KeyCharacterMapTest.java
@@ -8,14 +8,12 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
 /**
  * Test {@link android.view.KeyCharacterMap}.
  *
  * <p>Inspired from Android cts/tests/tests/view/src/android/view/cts/KeyCharacterMap.java
  */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public final class KeyCharacterMapTest {
 
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/view/KeyEventTest.java b/integration_tests/ctesque/src/sharedTest/java/android/view/KeyEventTest.java
index 6772cb7e1..8aa4b25d1 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/view/KeyEventTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/view/KeyEventTest.java
@@ -8,14 +8,12 @@ import android.os.Build.VERSION_CODES;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
 /**
  * Test {@link KeyEventTest}.
  *
  * <p>Inspired from Android cts/tests/tests/view/src/android/view/cts/KeyEventTest.java
  */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public final class KeyEventTest {
 
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/view/MotionEventTest.java b/integration_tests/ctesque/src/sharedTest/java/android/view/MotionEventTest.java
index 87f19de11..06eba43ae 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/view/MotionEventTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/view/MotionEventTest.java
@@ -26,14 +26,12 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
 /**
  * Test {@link android.view.MotionEvent}.
  *
  * <p>Baselined from Android cts/tests/tests/view/src/android/view/cts/MotionEventTest.java
  */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public class MotionEventTest {
   private MotionEvent motionEvent1;
@@ -408,6 +406,7 @@ public class MotionEventTest {
     }
   }
 
+  @SuppressWarnings("ReturnValueIgnored")
   @Test
   public void testToString() {
     // make sure this method never throw exception.
@@ -987,10 +986,6 @@ public class MotionEventTest {
       this.actual = actual;
     }
 
-    public static PointerCoordsEqualitySubject assertThat(PointerCoords coords) {
-      return Truth.assertAbout(pointerCoords()).that(coords);
-    }
-
     public static Subject.Factory<PointerCoordsEqualitySubject, PointerCoords> pointerCoords() {
       return PointerCoordsEqualitySubject::new;
     }
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/view/ViewConfigurationTest.java b/integration_tests/ctesque/src/sharedTest/java/android/view/ViewConfigurationTest.java
index a490b5842..031b63413 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/view/ViewConfigurationTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/view/ViewConfigurationTest.java
@@ -3,7 +3,10 @@ package android.view;
 import static android.os.Build.VERSION_CODES.O_MR1;
 import static com.google.common.truth.Truth.assertThat;
 
+import android.content.res.Configuration;
+import android.content.res.Resources;
 import android.os.Build;
+import android.util.DisplayMetrics;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.lang.reflect.Method;
@@ -11,10 +14,8 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
 /** Tests that {@link android.view.ViewConfiguration} behavior is consistent with real Android. */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public final class ViewConfigurationTest {
 
@@ -23,6 +24,15 @@ public final class ViewConfigurationTest {
 
   @Before
   public void setUp() {
+    Resources resources = ApplicationProvider.getApplicationContext().getResources();
+    DisplayMetrics metrics = resources.getDisplayMetrics();
+    metrics.density = 1.5f;
+    metrics.densityDpi = 240;
+    metrics.setTo(metrics);
+    Configuration configuration = resources.getConfiguration();
+    configuration.densityDpi = 240;
+    configuration.setTo(configuration);
+    resources.updateConfiguration(configuration, metrics);
     density =
         ApplicationProvider.getApplicationContext().getResources().getDisplayMetrics().density;
     viewConfiguration = ViewConfiguration.get(ApplicationProvider.getApplicationContext());
@@ -49,7 +59,6 @@ public final class ViewConfigurationTest {
     assertThat(isFadingMarqueeEnabled).isFalse();
   }
 
-  // Emulators have hdpi density by default, so match this in Robolectric for consistency.
   @Config(qualifiers = "hdpi")
   @Test
   public void overfling_distance() {
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/view/accessibility/AccessibilityEventTest.java b/integration_tests/ctesque/src/sharedTest/java/android/view/accessibility/AccessibilityEventTest.java
new file mode 100644
index 000000000..b64ac973c
--- /dev/null
+++ b/integration_tests/ctesque/src/sharedTest/java/android/view/accessibility/AccessibilityEventTest.java
@@ -0,0 +1,327 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.view.accessibility;
+
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import android.os.Build;
+import android.os.Message;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.filters.SdkSuppress;
+import java.util.Iterator;
+import java.util.List;
+import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+/**
+ * CTS for {@link AccessibilityEvent}.
+ *
+ * <p>Copied from
+ * cts/tests/accessibility/src/android/view/accessibility/cts/AccessibilityEventTest.java and
+ * cts/tests/accessibility/src/android/view/accessibility/cts/AccessibilityRecordTest.java.
+ *
+ * <p>But this test class migrates assertions from junit to Google Truth.
+ */
+@RunWith(AndroidJUnit4.class)
+public class AccessibilityEventTest {
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.R)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.R)
+  public void testConstructors() {
+    final AccessibilityEvent populatedEvent = new AccessibilityEvent();
+    fullyPopulateAccessibilityEvent(populatedEvent);
+    final AccessibilityEvent event = new AccessibilityEvent(populatedEvent);
+
+    assertEqualsAccessibilityEvent(event, populatedEvent);
+
+    final AccessibilityEvent firstEvent = new AccessibilityEvent();
+    firstEvent.setEventType(AccessibilityEvent.TYPE_VIEW_FOCUSED);
+    final AccessibilityEvent secondEvent =
+        new AccessibilityEvent(AccessibilityEvent.TYPE_VIEW_FOCUSED);
+
+    assertEqualsAccessibilityEvent(firstEvent, secondEvent);
+  }
+
+  /**
+   * Fully populates the {@link AccessibilityEvent} to marshal.
+   *
+   * @param sentEvent The event to populate.
+   */
+  private void fullyPopulateAccessibilityEvent(AccessibilityEvent sentEvent) {
+    // Skip setDisplay because current implementation doesn't support
+    // AccessibilityEvent#setDispalyId.
+    sentEvent.setAddedCount(1);
+    sentEvent.setBeforeText("BeforeText");
+    sentEvent.setChecked(true);
+    sentEvent.setClassName("foo.bar.baz.Class");
+    sentEvent.setContentDescription("ContentDescription");
+    sentEvent.setCurrentItemIndex(1);
+    sentEvent.setEnabled(true);
+    sentEvent.setEventType(AccessibilityEvent.TYPE_VIEW_FOCUSED);
+    sentEvent.setEventTime(1000);
+    sentEvent.setFromIndex(1);
+    sentEvent.setFullScreen(true);
+    sentEvent.setItemCount(1);
+    sentEvent.setPackageName("foo.bar.baz");
+    sentEvent.setParcelableData(Message.obtain(null, 1, 2, 3));
+    sentEvent.setPassword(true);
+    sentEvent.setRemovedCount(1);
+    sentEvent.getText().add("Foo");
+    sentEvent.setMaxScrollX(1);
+    sentEvent.setMaxScrollY(1);
+    sentEvent.setScrollX(1);
+    sentEvent.setScrollY(1);
+    sentEvent.setScrollDeltaX(3);
+    sentEvent.setScrollDeltaY(3);
+    sentEvent.setToIndex(1);
+    sentEvent.setScrollable(true);
+    sentEvent.setAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
+    sentEvent.setMovementGranularity(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_LINE);
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
+      sentEvent.setSpeechStateChangeTypes(AccessibilityEvent.SPEECH_STATE_SPEAKING_START);
+    }
+
+    AccessibilityRecord record = AccessibilityRecord.obtain();
+    fullyPopulateAccessibilityRecord(record);
+    sentEvent.appendRecord(record);
+  }
+
+  /**
+   * Compares all properties of the <code>expectedEvent</code> and the <code>receivedEvent</code> to
+   * verify that the received event is the one that is expected.
+   */
+  private static void assertEqualsAccessibilityEvent(
+      AccessibilityEvent expectedEvent, AccessibilityEvent receivedEvent) {
+    assertWithMessage("addedCount has incorrect value")
+        .that(receivedEvent.getAddedCount())
+        .isEqualTo(expectedEvent.getAddedCount());
+    assertWithMessage("beforeText has incorrect value")
+        .that(receivedEvent.getBeforeText())
+        .isEqualTo(expectedEvent.getBeforeText());
+    assertWithMessage("checked has incorrect value")
+        .that(receivedEvent.isChecked())
+        .isEqualTo(expectedEvent.isChecked());
+    assertWithMessage("className has incorrect value")
+        .that(receivedEvent.getClassName())
+        .isEqualTo(expectedEvent.getClassName());
+    assertWithMessage("contentDescription has incorrect value")
+        .that(receivedEvent.getContentDescription())
+        .isEqualTo(expectedEvent.getContentDescription());
+    assertWithMessage("currentItemIndex has incorrect value")
+        .that(receivedEvent.getCurrentItemIndex())
+        .isEqualTo(expectedEvent.getCurrentItemIndex());
+    assertWithMessage("enabled has incorrect value")
+        .that(receivedEvent.isEnabled())
+        .isEqualTo(expectedEvent.isEnabled());
+    assertWithMessage("eventType has incorrect value")
+        .that(receivedEvent.getEventType())
+        .isEqualTo(expectedEvent.getEventType());
+    assertWithMessage("fromIndex has incorrect value")
+        .that(receivedEvent.getFromIndex())
+        .isEqualTo(expectedEvent.getFromIndex());
+    assertWithMessage("fullScreen has incorrect value")
+        .that(receivedEvent.isFullScreen())
+        .isEqualTo(expectedEvent.isFullScreen());
+    assertWithMessage("itemCount has incorrect value")
+        .that(receivedEvent.getItemCount())
+        .isEqualTo(expectedEvent.getItemCount());
+    assertWithMessage("password has incorrect value")
+        .that(receivedEvent.isPassword())
+        .isEqualTo(expectedEvent.isPassword());
+    assertWithMessage("removedCount has incorrect value")
+        .that(receivedEvent.getRemovedCount())
+        .isEqualTo(expectedEvent.getRemovedCount());
+    assertWithMessage("maxScrollX has incorrect value")
+        .that(receivedEvent.getMaxScrollX())
+        .isEqualTo(expectedEvent.getMaxScrollX());
+    assertWithMessage("maxScrollY has incorrect value")
+        .that(receivedEvent.getMaxScrollY())
+        .isEqualTo(expectedEvent.getMaxScrollY());
+    assertWithMessage("scrollX has incorrect value")
+        .that(receivedEvent.getScrollX())
+        .isEqualTo(expectedEvent.getScrollX());
+    assertWithMessage("scrollY has incorrect value")
+        .that(receivedEvent.getScrollY())
+        .isEqualTo(expectedEvent.getScrollY());
+    assertWithMessage("scrollDeltaX has incorrect value")
+        .that(receivedEvent.getScrollDeltaX())
+        .isEqualTo(expectedEvent.getScrollDeltaX());
+    assertWithMessage("scrollDeltaY has incorrect value")
+        .that(receivedEvent.getScrollDeltaY())
+        .isEqualTo(expectedEvent.getScrollDeltaY());
+    assertWithMessage("toIndex has incorrect value")
+        .that(receivedEvent.getToIndex())
+        .isEqualTo(expectedEvent.getToIndex());
+    assertWithMessage("scrollable has incorrect value")
+        .that(receivedEvent.isScrollable())
+        .isEqualTo(expectedEvent.isScrollable());
+    assertWithMessage("granularity has incorrect value")
+        .that(receivedEvent.getMovementGranularity())
+        .isEqualTo(expectedEvent.getMovementGranularity());
+    assertWithMessage("action has incorrect value")
+        .that(receivedEvent.getAction())
+        .isEqualTo(expectedEvent.getAction());
+    assertWithMessage("windowChangeTypes has incorrect value")
+        .that(receivedEvent.getWindowChanges())
+        .isEqualTo(expectedEvent.getWindowChanges());
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
+      assertWithMessage("speechStateChangeTypes has incorrect value")
+          .that(receivedEvent.getSpeechStateChangeTypes())
+          .isEqualTo(expectedEvent.getSpeechStateChangeTypes());
+    }
+
+    assertEqualsText(expectedEvent.getText(), receivedEvent.getText());
+    assertEqualAccessibilityRecord(expectedEvent, receivedEvent);
+
+    assertEqualAppendedRecord(expectedEvent, receivedEvent);
+  }
+
+  private static void assertEqualAppendedRecord(
+      AccessibilityEvent expectedEvent, AccessibilityEvent receivedEvent) {
+    assertWithMessage("recordCount has incorrect value")
+        .that(receivedEvent.getRecordCount())
+        .isEqualTo(expectedEvent.getRecordCount());
+    if (expectedEvent.getRecordCount() != 0 && receivedEvent.getRecordCount() != 0) {
+      AccessibilityRecord expectedRecord = expectedEvent.getRecord(0);
+      AccessibilityRecord receivedRecord = receivedEvent.getRecord(0);
+      assertEqualAccessibilityRecord(expectedRecord, receivedRecord);
+    }
+  }
+
+  static void assertEqualAccessibilityRecord(
+      AccessibilityRecord expectedRecord, AccessibilityRecord receivedRecord) {
+    assertWithMessage("addedCount has incorrect value")
+        .that(receivedRecord.getAddedCount())
+        .isEqualTo(expectedRecord.getAddedCount());
+    assertWithMessage("beforeText has incorrect value")
+        .that(receivedRecord.getBeforeText())
+        .isEqualTo(expectedRecord.getBeforeText());
+    assertWithMessage("checked has incorrect value")
+        .that(receivedRecord.isChecked())
+        .isEqualTo(expectedRecord.isChecked());
+    assertWithMessage("className has incorrect value")
+        .that(receivedRecord.getClassName())
+        .isEqualTo(expectedRecord.getClassName());
+    assertWithMessage("contentDescription has incorrect value")
+        .that(receivedRecord.getContentDescription())
+        .isEqualTo(expectedRecord.getContentDescription());
+    assertWithMessage("currentItemIndex has incorrect value")
+        .that(receivedRecord.getCurrentItemIndex())
+        .isEqualTo(expectedRecord.getCurrentItemIndex());
+    assertWithMessage("enabled has incorrect value")
+        .that(receivedRecord.isEnabled())
+        .isEqualTo(expectedRecord.isEnabled());
+    assertWithMessage("fromIndex has incorrect value")
+        .that(receivedRecord.getFromIndex())
+        .isEqualTo(expectedRecord.getFromIndex());
+    assertWithMessage("fullScreen has incorrect value")
+        .that(receivedRecord.isFullScreen())
+        .isEqualTo(expectedRecord.isFullScreen());
+    assertWithMessage("itemCount has incorrect value")
+        .that(receivedRecord.getItemCount())
+        .isEqualTo(expectedRecord.getItemCount());
+    assertWithMessage("password has incorrect value")
+        .that(receivedRecord.isPassword())
+        .isEqualTo(expectedRecord.isPassword());
+    assertWithMessage("removedCount has incorrect value")
+        .that(receivedRecord.getRemovedCount())
+        .isEqualTo(expectedRecord.getRemovedCount());
+    assertEqualsText(expectedRecord.getText(), receivedRecord.getText());
+    assertWithMessage("maxScrollX has incorrect value")
+        .that(receivedRecord.getMaxScrollX())
+        .isEqualTo(expectedRecord.getMaxScrollX());
+    assertWithMessage("maxScrollY has incorrect value")
+        .that(receivedRecord.getMaxScrollY())
+        .isEqualTo(expectedRecord.getMaxScrollY());
+    assertWithMessage("scrollX has incorrect value")
+        .that(receivedRecord.getScrollX())
+        .isEqualTo(expectedRecord.getScrollX());
+    assertWithMessage("scrollY has incorrect value")
+        .that(receivedRecord.getScrollY())
+        .isEqualTo(expectedRecord.getScrollY());
+    assertWithMessage("toIndex has incorrect value")
+        .that(receivedRecord.getToIndex())
+        .isEqualTo(expectedRecord.getToIndex());
+    assertWithMessage("scrollable has incorrect value")
+        .that(receivedRecord.isScrollable())
+        .isEqualTo(expectedRecord.isScrollable());
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
+      assertWithMessage("displayId has incorrect value")
+          .that(receivedRecord.getDisplayId())
+          .isEqualTo(expectedRecord.getDisplayId());
+    }
+
+    assertWithMessage("one of the parcelableData is null")
+        .that(
+            expectedRecord.getParcelableData() == null ^ receivedRecord.getParcelableData() == null)
+        .isFalse();
+    if (expectedRecord.getParcelableData() != null && receivedRecord.getParcelableData() != null) {
+      assertWithMessage("parcelableData has incorrect value")
+          .that(((Message) receivedRecord.getParcelableData()).what)
+          .isEqualTo(((Message) expectedRecord.getParcelableData()).what);
+    }
+  }
+
+  /**
+   * Fully populates the {@link AccessibilityRecord}.
+   *
+   * @param record The record to populate.
+   */
+  static void fullyPopulateAccessibilityRecord(AccessibilityRecord record) {
+    record.setAddedCount(1);
+    record.setBeforeText("BeforeText");
+    record.setChecked(true);
+    record.setClassName("foo.bar.baz.Class");
+    record.setContentDescription("ContentDescription");
+    record.setCurrentItemIndex(1);
+    record.setEnabled(true);
+    record.setFromIndex(1);
+    record.setFullScreen(true);
+    record.setItemCount(1);
+    record.setParcelableData(Message.obtain(null, 1, 2, 3));
+    record.setPassword(true);
+    record.setRemovedCount(1);
+    record.getText().add("Foo");
+    record.setMaxScrollX(1);
+    record.setMaxScrollY(1);
+    record.setScrollX(1);
+    record.setScrollY(1);
+    record.setToIndex(1);
+    record.setScrollable(true);
+  }
+
+  /**
+   * Compares the text of the <code>expectedEvent</code> and <code>receivedEvent</code> by comparing
+   * the string representation of the corresponding {@link CharSequence}s.
+   */
+  static void assertEqualsText(List<CharSequence> expectedText, List<CharSequence> receivedText) {
+    String message = "text has incorrect value";
+
+    TestCase.assertEquals(message, expectedText.size(), receivedText.size());
+
+    Iterator<CharSequence> expectedTextIterator = expectedText.iterator();
+    Iterator<CharSequence> receivedTextIterator = receivedText.iterator();
+
+    for (int i = 0; i < expectedText.size(); i++) {
+      // compare the string representation
+      assertWithMessage(message)
+          .that(receivedTextIterator.next().toString())
+          .isEqualTo(expectedTextIterator.next().toString());
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/view/accessibility/AccessibilityNodeInfoTest.java b/integration_tests/ctesque/src/sharedTest/java/android/view/accessibility/AccessibilityNodeInfoTest.java
new file mode 100644
index 000000000..073f050bf
--- /dev/null
+++ b/integration_tests/ctesque/src/sharedTest/java/android/view/accessibility/AccessibilityNodeInfoTest.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.view.accessibility;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Build;
+import android.view.View;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.filters.SdkSuppress;
+import androidx.test.platform.app.InstrumentationRegistry;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+/**
+ * CTS for {@link AccessibilityNodeInfo}.
+ *
+ * <p>Copied from
+ * cts/tests/accessibility/src/android/view/accessibility/cts/AccessibilityNodeInfoTest.java.
+ *
+ * <p>But this test class migrates assertions from junit to Google Truth.
+ */
+@RunWith(AndroidJUnit4.class)
+public class AccessibilityNodeInfoTest {
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.R)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.R)
+  public void testConstructor() {
+    // Skip getSourceId as current implementation doesn't support it.
+    final View view = new View(InstrumentationRegistry.getInstrumentation().getContext());
+    AccessibilityNodeInfo firstInfo = new AccessibilityNodeInfo(view);
+    AccessibilityNodeInfo secondInfo = new AccessibilityNodeInfo();
+    secondInfo.setSource(view);
+
+    assertThat(secondInfo.getWindowId()).isEqualTo(firstInfo.getWindowId());
+
+    firstInfo = new AccessibilityNodeInfo(view, /* virtualDescendantId */ 1);
+    secondInfo.setSource(view, /* virtualDescendantId */ 1);
+
+    assertThat(secondInfo.getWindowId()).isEqualTo(firstInfo.getWindowId());
+  }
+}
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/webkit/CookieManagerTest.java b/integration_tests/ctesque/src/sharedTest/java/android/webkit/CookieManagerTest.java
index 351cf82ac..27ff1adc2 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/webkit/CookieManagerTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/webkit/CookieManagerTest.java
@@ -6,10 +6,8 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.After;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
 /** Compatibility test for {@link CookieManager} */
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public class CookieManagerTest {
 
diff --git a/integration_tests/dependency-on-stubs/build.gradle b/integration_tests/dependency-on-stubs/build.gradle
index 1757653eb..a4b40f1a0 100644
--- a/integration_tests/dependency-on-stubs/build.gradle
+++ b/integration_tests/dependency-on-stubs/build.gradle
@@ -1,17 +1,17 @@
-import org.robolectric.gradle.AndroidProjectConfigPlugin
-
-apply plugin: 'com.android.library'
-apply plugin: AndroidProjectConfigPlugin
+plugins {
+    alias(libs.plugins.android.library)
+    alias(libs.plugins.robolectric.android.project)
+}
 
 // test with a project that depends on the stubs jar, not org.robolectric:android-all
 
 android {
-    compileSdk 33
+    compileSdk 34
     namespace 'org.robolectric'
 
     defaultConfig {
-        minSdk 19
-        targetSdk 33
+        minSdk 21
+        targetSdk 34
     }
 
     compileOptions {
diff --git a/integration_tests/jacoco-offline/build.gradle b/integration_tests/jacoco-offline/build.gradle
index 423a62395..5f047b57f 100644
--- a/integration_tests/jacoco-offline/build.gradle
+++ b/integration_tests/jacoco-offline/build.gradle
@@ -1,7 +1,7 @@
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
-apply plugin: "jacoco"
+plugins {
+    alias(libs.plugins.jacoco)
+    alias(libs.plugins.robolectric.java.module)
+}
 
 def jacocoVersion = libs.versions.jacoco.get()
 
diff --git a/integration_tests/kotlin/build.gradle b/integration_tests/kotlin/build.gradle
index 37686d981..7bdd8fcf9 100644
--- a/integration_tests/kotlin/build.gradle
+++ b/integration_tests/kotlin/build.gradle
@@ -1,7 +1,12 @@
 import org.jetbrains.kotlin.gradle.dsl.JvmTarget
-import org.robolectric.gradle.RoboJavaModulePlugin
-apply plugin: RoboJavaModulePlugin
-apply plugin: 'kotlin'
+
+plugins {
+    alias(libs.plugins.detekt)
+    alias(libs.plugins.kotlin.jvm)
+    alias(libs.plugins.robolectric.java.module)
+    alias(libs.plugins.robolectric.spotless)
+}
+
 compileKotlin {
     compilerOptions.jvmTarget = JvmTarget.JVM_1_8
 }
diff --git a/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/CustomShadowImageViewTest.kt b/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/CustomShadowImageViewTest.kt
index e641233d8..1a9641a04 100644
--- a/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/CustomShadowImageViewTest.kt
+++ b/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/CustomShadowImageViewTest.kt
@@ -22,7 +22,6 @@ class CustomShadowImageViewTest {
     val shadowImageView = Shadow.extract<CustomShadowImageView>(imageView)
     assertThat(shadowImageView).isNotNull()
     assertThat(shadowImageView.realImageView).isSameInstanceAs(imageView)
-    val resourceId = Int.MAX_VALUE
     imageView.performLongClick()
     assertThat(shadowImageView.longClickPerformed).isTrue()
   }
diff --git a/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/flow/BluetoothProvisioner.kt b/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/flow/BluetoothProvisioner.kt
index 2094dd13b..ccc8d740a 100644
--- a/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/flow/BluetoothProvisioner.kt
+++ b/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/flow/BluetoothProvisioner.kt
@@ -30,7 +30,7 @@ class BluetoothProvisioner(applicationContext: Context) {
       object : ScanCallback() {
         override fun onScanResult(callbackType: Int, result: ScanResult?) {
           if (result?.device != null) {
-            val unused = trySend(result.device)
+            @Suppress("UnusedPrivateProperty") val unused = trySend(result.device)
           }
         }
 
@@ -49,7 +49,7 @@ class BluetoothProvisioner(applicationContext: Context) {
       object : BluetoothGattCallback() {
         override fun onConnectionStateChange(gatt: BluetoothGatt?, status: Int, newState: Int) {
           if (newState == BluetoothProfile.STATE_CONNECTED) {
-            val unused = gatt!!.discoverServices()
+            gatt!!.discoverServices()
           } else {
             cancel("Connect Failed", null)
           }
@@ -57,7 +57,7 @@ class BluetoothProvisioner(applicationContext: Context) {
 
         override fun onServicesDiscovered(gatt: BluetoothGatt?, status: Int) {
           if (status == BluetoothGatt.GATT_SUCCESS) {
-            val unused = trySend(gatt!!)
+            @Suppress("UnusedPrivateProperty") val unused = trySend(gatt!!)
           } else {
             cancel("Service discovery failed", null)
           }
diff --git a/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/flow/BluetoothProvisionerTest.kt b/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/flow/BluetoothProvisionerTest.kt
index 181b6a8b9..e57b6badc 100644
--- a/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/flow/BluetoothProvisionerTest.kt
+++ b/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/flow/BluetoothProvisionerTest.kt
@@ -30,8 +30,6 @@ import org.robolectric.shadows.ShadowBluetoothLeScanner
 @Config(sdk = [S])
 class BluetoothProvisionerTest {
 
-  val BLUETOOTH_MAC = "00:11:22:33:AA:BB"
-
   val context = RuntimeEnvironment.getApplication()
 
   val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
@@ -80,4 +78,8 @@ class BluetoothProvisionerTest {
 
     executor.runAll()
   }
+
+  private companion object {
+    private const val BLUETOOTH_MAC = "00:11:22:33:AA:BB"
+  }
 }
diff --git a/integration_tests/libphonenumber/build.gradle b/integration_tests/libphonenumber/build.gradle
index 61120f227..8e567a8d5 100644
--- a/integration_tests/libphonenumber/build.gradle
+++ b/integration_tests/libphonenumber/build.gradle
@@ -1,6 +1,6 @@
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.java.module)
+}
 
 dependencies {
     api project(":robolectric")
diff --git a/integration_tests/libphonenumber/src/test/java/org/robolectric/integrationtests/libphonenumber/ClassloadingTest.java b/integration_tests/libphonenumber/src/test/java/org/robolectric/integrationtests/libphonenumber/ClassloadingTest.java
index 199da35bc..c2bd47911 100644
--- a/integration_tests/libphonenumber/src/test/java/org/robolectric/integrationtests/libphonenumber/ClassloadingTest.java
+++ b/integration_tests/libphonenumber/src/test/java/org/robolectric/integrationtests/libphonenumber/ClassloadingTest.java
@@ -10,18 +10,18 @@ import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.ALL_SDKS )
+@Config(sdk = Config.ALL_SDKS)
 public class ClassloadingTest {
 
-  /**
-   * <a href="https://github.com/robolectric/robolectric/issues/2773">Issue</a>
-   */
+  /** <a href="https://github.com/robolectric/robolectric/issues/2773">Issue</a> */
   @Test
   public void getResourceAsStream() throws Exception {
     Phonenumber.PhoneNumber phoneNumber = new Phonenumber.PhoneNumber();
     phoneNumber.setCountryCode(7);
     phoneNumber.setNationalNumber(4956360636L);
-    String format = PhoneNumberUtil.getInstance().format(phoneNumber, PhoneNumberUtil.PhoneNumberFormat.INTERNATIONAL);
+    String format =
+        PhoneNumberUtil.getInstance()
+            .format(phoneNumber, PhoneNumberUtil.PhoneNumberFormat.INTERNATIONAL);
     assertThat(format).isNotNull();
   }
 }
diff --git a/integration_tests/memoryleaks/build.gradle b/integration_tests/memoryleaks/build.gradle
index 7a8249fbd..643717f70 100644
--- a/integration_tests/memoryleaks/build.gradle
+++ b/integration_tests/memoryleaks/build.gradle
@@ -1,14 +1,14 @@
-import org.robolectric.gradle.AndroidProjectConfigPlugin
-
-apply plugin: 'com.android.library'
-apply plugin: AndroidProjectConfigPlugin
+plugins {
+    alias(libs.plugins.android.library)
+    alias(libs.plugins.robolectric.android.project)
+}
 
 android {
     compileSdk 34
     namespace 'org.robolectric.integrationtests.memoryleaks'
 
     defaultConfig {
-        minSdk 19
+        minSdk 21
         targetSdk 34
     }
 
@@ -31,5 +31,5 @@ dependencies {
     testImplementation libs.junit4
     testImplementation libs.guava.testlib
     testImplementation libs.androidx.fragment
-    testImplementation 'com.google.truth:truth:1.1.3'
+    testImplementation libs.truth
 }
diff --git a/integration_tests/mockito-experimental/build.gradle b/integration_tests/mockito-experimental/build.gradle
index f5172d6af..a185073ac 100644
--- a/integration_tests/mockito-experimental/build.gradle
+++ b/integration_tests/mockito-experimental/build.gradle
@@ -1,6 +1,6 @@
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.java.module)
+}
 
 dependencies {
     api project(":robolectric")
diff --git a/integration_tests/mockito-kotlin/build.gradle b/integration_tests/mockito-kotlin/build.gradle
index 3d8970e7f..52d8e586c 100644
--- a/integration_tests/mockito-kotlin/build.gradle
+++ b/integration_tests/mockito-kotlin/build.gradle
@@ -1,16 +1,10 @@
 import org.jetbrains.kotlin.gradle.dsl.JvmTarget
-import org.robolectric.gradle.RoboJavaModulePlugin
 
-apply plugin: RoboJavaModulePlugin
-apply plugin: 'kotlin'
-apply plugin: "com.diffplug.spotless"
-apply plugin: "io.gitlab.arturbosch.detekt"
-
-spotless {
-    kotlin {
-        target '**/*.kt'
-        ktfmt('0.42').googleStyle()
-    }
+plugins {
+    alias(libs.plugins.detekt)
+    alias(libs.plugins.kotlin.jvm)
+    alias(libs.plugins.robolectric.java.module)
+    alias(libs.plugins.robolectric.spotless)
 }
 
 compileKotlin {
diff --git a/integration_tests/mockito/build.gradle b/integration_tests/mockito/build.gradle
index 31e6ce675..17b387d2e 100644
--- a/integration_tests/mockito/build.gradle
+++ b/integration_tests/mockito/build.gradle
@@ -1,6 +1,6 @@
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.java.module)
+}
 
 dependencies {
     api project(":robolectric")
diff --git a/integration_tests/mockito/src/test/java/org/robolectric/integrationtests/mockito/MockitoInjectMocksTest.java b/integration_tests/mockito/src/test/java/org/robolectric/integrationtests/mockito/MockitoInjectMocksTest.java
index f893bc339..3a94f6940 100644
--- a/integration_tests/mockito/src/test/java/org/robolectric/integrationtests/mockito/MockitoInjectMocksTest.java
+++ b/integration_tests/mockito/src/test/java/org/robolectric/integrationtests/mockito/MockitoInjectMocksTest.java
@@ -14,14 +14,11 @@ import org.robolectric.RobolectricTestRunner;
 
 @RunWith(RobolectricTestRunner.class)
 public class MockitoInjectMocksTest {
-  @Rule
-  public MockitoRule mockitoRule = MockitoJUnit.rule();
+  @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();
 
-  @Mock
-  TextView textView;
+  @Mock TextView textView;
 
-  @InjectMocks
-  Activity activity = Robolectric.setupActivity(Activity.class);
+  @InjectMocks Activity activity = Robolectric.setupActivity(Activity.class);
 
   @Test
   public void testInjection() {
diff --git a/integration_tests/mockk/build.gradle b/integration_tests/mockk/build.gradle
index f74691aae..770a390e0 100644
--- a/integration_tests/mockk/build.gradle
+++ b/integration_tests/mockk/build.gradle
@@ -1,16 +1,10 @@
 import org.jetbrains.kotlin.gradle.dsl.JvmTarget
-import org.robolectric.gradle.RoboJavaModulePlugin
 
-apply plugin: RoboJavaModulePlugin
-apply plugin: 'kotlin'
-apply plugin: "com.diffplug.spotless"
-apply plugin: "io.gitlab.arturbosch.detekt"
-
-spotless {
-    kotlin {
-        target '**/*.kt'
-        ktfmt('0.42').googleStyle()
-    }
+plugins {
+    alias(libs.plugins.detekt)
+    alias(libs.plugins.kotlin.jvm)
+    alias(libs.plugins.robolectric.java.module)
+    alias(libs.plugins.robolectric.spotless)
 }
 
 compileKotlin {
diff --git a/integration_tests/multidex/src/test/AndroidManifest.xml b/integration_tests/multidex/src/test/AndroidManifest.xml
index df7a6251c..9a55a085e 100644
--- a/integration_tests/multidex/src/test/AndroidManifest.xml
+++ b/integration_tests/multidex/src/test/AndroidManifest.xml
@@ -4,7 +4,7 @@
     package="org.robolectric.integrationtests.multidex">
 
   <uses-sdk
-      android:minSdkVersion="19"
+      android:minSdkVersion="21"
       android:targetSdkVersion="34"/>
 
   <application />
diff --git a/integration_tests/multidex/src/test/java/org/robolectric/integrationtests/multidex/MultiDexTest.java b/integration_tests/multidex/src/test/java/org/robolectric/integrationtests/multidex/MultiDexTest.java
index 02715f102..d0dcd2014 100644
--- a/integration_tests/multidex/src/test/java/org/robolectric/integrationtests/multidex/MultiDexTest.java
+++ b/integration_tests/multidex/src/test/java/org/robolectric/integrationtests/multidex/MultiDexTest.java
@@ -2,7 +2,7 @@ package org.robolectric.integrationtests.multidex;
 
 import android.support.multidex.MultiDex;
 import androidx.test.core.app.ApplicationProvider;
-import androidx.test.runner.AndroidJUnit4;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
diff --git a/integration_tests/nativegraphics/Android.bp b/integration_tests/nativegraphics/Android.bp
index 41ac4f712..6d552fea5 100644
--- a/integration_tests/nativegraphics/Android.bp
+++ b/integration_tests/nativegraphics/Android.bp
@@ -8,7 +8,6 @@ android_library {
     resource_dirs: ["src/main/res"],
     min_sdk_version: "26",
     target_sdk_version: "31",
-    platform_apis: true,
     manifest: "AndroidManifest.xml",
     optimize: {
         enabled: false,
@@ -57,9 +56,9 @@ android_robolectric_test {
         "androidx.test.ext.junit",
     ],
     libs: [
-        "android.test.runner",
-        "android.test.base",
-        "android.test.mock",
+        "android.test.runner.stubs.system",
+        "android.test.base.stubs.system",
+        "android.test.mock.stubs.system",
         "truth",
         "guava-android-testlib",
     ],
diff --git a/integration_tests/nativegraphics/build.gradle b/integration_tests/nativegraphics/build.gradle
index a44f12c28..6822a8182 100644
--- a/integration_tests/nativegraphics/build.gradle
+++ b/integration_tests/nativegraphics/build.gradle
@@ -1,9 +1,7 @@
-import org.robolectric.gradle.AndroidProjectConfigPlugin
-import org.robolectric.gradle.GradleManagedDevicePlugin
-
-apply plugin: 'com.android.library'
-apply plugin: AndroidProjectConfigPlugin
-apply plugin: GradleManagedDevicePlugin
+plugins {
+    alias(libs.plugins.android.library)
+    alias(libs.plugins.robolectric.android.project)
+}
 
 android {
     compileSdk 34
diff --git a/integration_tests/nativegraphics/config/robolectric.properties b/integration_tests/nativegraphics/config/robolectric.properties
index 0d16e6b27..23fdc013a 100644
--- a/integration_tests/nativegraphics/config/robolectric.properties
+++ b/integration_tests/nativegraphics/config/robolectric.properties
@@ -13,3 +13,4 @@
 # limitations under the License.
 #
 sdk=NEWEST_SDK
+graphicsMode=NATIVE
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBitmapTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBitmapTest.java
index e8be56288..a1dfc566e 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBitmapTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBitmapTest.java
@@ -16,8 +16,8 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.O;
+import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
-import static android.os.Build.VERSION_CODES.S;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -1721,7 +1721,7 @@ public class ShadowNativeBitmapTest {
     Parcel p = Parcel.obtain();
     bitmap = Bitmap.createBitmap(100, 100, Config.ARGB_8888);
     bitmap.eraseColor(Color.GREEN);
-    Bitmap immutable = bitmap.copy(Config.ARGB_8888, /*isMutable=*/ false);
+    Bitmap immutable = bitmap.copy(Config.ARGB_8888, /* isMutable= */ false);
     assertThat(immutable.isMutable()).isFalse();
     immutable.writeToParcel(p, 0);
     p.setDataPosition(0);
@@ -1772,8 +1772,7 @@ public class ShadowNativeBitmapTest {
     assertThat(copy.sameAs(orig)).isTrue();
   }
 
-  // TODO(hoisie): Fix this test in Q and R.
-  @org.robolectric.annotation.Config(minSdk = S)
+  @org.robolectric.annotation.Config(minSdk = P)
   @Test
   public void testCreateBitmap_picture_immutable() {
     Picture picture = new Picture();
@@ -1798,11 +1797,13 @@ public class ShadowNativeBitmapTest {
     assertNotNull(bitmap.getColorSpace());
 
     bitmap = Bitmap.createBitmap(picture, 100, 100, Config.ARGB_8888);
-    assertFalse(bitmap.isMutable());
+    if (RuntimeEnvironment.getApiLevel() >= Q) {
+      // In P, the bitmap returned is mutable.
+      assertFalse(bitmap.isMutable());
+    }
   }
 
-  // TODO(hoisie): Fix this test in Q and R.
-  @org.robolectric.annotation.Config(minSdk = S)
+  @org.robolectric.annotation.Config(minSdk = P)
   @Test
   public void testCreateBitmap_picture_requiresHWAcceleration_checkPixels() {
     Picture picture = new Picture();
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeColorSpaceTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeColorSpaceTest.java
index 926a6ae46..5ab1fc47e 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeColorSpaceTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeColorSpaceTest.java
@@ -30,6 +30,7 @@ import static org.junit.Assert.fail;
 
 import android.graphics.ColorSpace;
 import java.util.Arrays;
+import java.util.Objects;
 import java.util.function.DoubleUnaryOperator;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -74,6 +75,11 @@ public class ShadowNativeColorSpaceTest {
   @Test
   public void testNamedColorSpaces() {
     for (ColorSpace.Named named : ColorSpace.Named.values()) {
+      // OK_LAB is behind a feature flag that is not yet enabled by default.
+      if (Objects.equals(named.toString(), "OK_LAB")) {
+        continue;
+      }
+
       ColorSpace colorSpace = ColorSpace.get(named);
       assertNotNull(colorSpace.getName());
       assertNotNull(colorSpace);
@@ -336,6 +342,11 @@ public class ShadowNativeColorSpaceTest {
   @Config(minSdk = Q)
   public void testIsSRGB() {
     for (ColorSpace.Named e : ColorSpace.Named.values()) {
+      // OK_LAB is behind a feature flag that is not yet enabled by default.
+      if (Objects.equals(e.toString(), "OK_LAB")) {
+        continue;
+      }
+
       ColorSpace colorSpace = ColorSpace.get(e);
       if (e == ColorSpace.Named.SRGB) {
         assertTrue(colorSpace.isSrgb());
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageDecoderTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageDecoderTest.java
index 55adc24da..0eab7ad5a 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageDecoderTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageDecoderTest.java
@@ -2,6 +2,7 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
+import static com.google.common.base.StandardSystemProperty.OS_NAME;
 import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertSame;
 import static org.junit.Assert.assertEquals;
@@ -12,19 +13,25 @@ import android.graphics.Bitmap;
 import android.graphics.ColorSpace;
 import android.graphics.ImageDecoder;
 import android.graphics.ImageDecoder.Source;
+import com.google.common.collect.ImmutableList;
 import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
+import java.nio.file.Files;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Locale;
 import java.util.function.IntFunction;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
+import org.robolectric.versioning.AndroidVersions.V;
 
 @Config(minSdk = P)
 @RunWith(RobolectricTestRunner.class)
@@ -70,7 +77,7 @@ public class ShadowNativeImageDecoderTest {
                 new Record(R.drawable.webp_test, 640, 480, "image/webp", false, false, SRGB)));
 
     // x-adobe-dng is not supported on Windows
-    if (!System.getProperty("os.name").toLowerCase().contains("win")) {
+    if (!OS_NAME.value().toLowerCase(Locale.ROOT).contains("win")) {
       records.add(new Record(R.raw.sample_1mp, 600, 338, "image/x-adobe-dng", false, false, SRGB));
     }
 
@@ -129,15 +136,37 @@ public class ShadowNativeImageDecoderTest {
     return getAsByteBufferWrap(resId).asReadOnlyBuffer();
   }
 
+  private File getAsFile(int resId) {
+    try {
+      File file = Files.createTempFile("ShadowNativeBitmapFactoryTest", "").toFile();
+      file.deleteOnExit();
+      try (FileOutputStream output = new FileOutputStream(file)) {
+        writeToStream(output, resId, 0, 0);
+      }
+      return file;
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
+
   private interface SourceCreator extends IntFunction<Source> {}
 
-  private SourceCreator[] creators =
-      new SourceCreator[] {
+  private ImmutableList<SourceCreator> getSourceCreators() {
+    ImmutableList.Builder<SourceCreator> builder = ImmutableList.builder();
+
+    builder.add(
         resId -> ImageDecoder.createSource(getAsByteArray(resId)),
         resId -> ImageDecoder.createSource(getAsByteBufferWrap(resId)),
         resId -> ImageDecoder.createSource(getAsDirectByteBuffer(resId)),
-        resId -> ImageDecoder.createSource(getAsReadOnlyByteBuffer(resId)),
-      };
+        resId -> ImageDecoder.createSource(getAsReadOnlyByteBuffer(resId)));
+
+    // TODO(hoisie): Support file sources in Android V+.
+    if (RuntimeEnvironment.getApiLevel() < V.SDK_INT) {
+      builder.add(resId -> ImageDecoder.createSource(getAsFile(resId)));
+    }
+
+    return builder.build();
+  }
 
   private static Resources getResources() {
     return RuntimeEnvironment.getApplication().getResources();
@@ -146,7 +175,7 @@ public class ShadowNativeImageDecoderTest {
   @Test
   public void testInfo() throws Exception {
     for (Record record : getRecords()) {
-      for (SourceCreator f : creators) {
+      for (SourceCreator f : getSourceCreators()) {
         ImageDecoder.Source src = f.apply(record.resId);
         assertNotNull(src);
         ImageDecoder.decodeDrawable(
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageReaderTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageReaderTest.java
index c10e8555b..ed9cded3b 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageReaderTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageReaderTest.java
@@ -1,16 +1,22 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.Q;
+import static android.os.Build.VERSION_CODES.P;
 import static com.google.common.truth.Truth.assertThat;
+import static org.robolectric.Shadows.shadowOf;
 
+import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Color;
 import android.graphics.PixelFormat;
 import android.graphics.Rect;
 import android.hardware.HardwareBuffer;
 import android.media.Image;
+import android.media.Image.Plane;
 import android.media.ImageReader;
+import android.os.Handler;
+import android.os.Looper;
 import android.view.Surface;
+import java.util.concurrent.atomic.AtomicBoolean;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -20,7 +26,7 @@ import org.robolectric.annotation.Config;
  * Test for {@link org.robolectric.shadows.ShadowNativeImageReader} and {@link
  * org.robolectric.shadows.ShadowNativeImageReaderSurfaceImage}.
  */
-@Config(minSdk = Q)
+@Config(minSdk = P)
 @RunWith(RobolectricTestRunner.class)
 public class ShadowNativeImageReaderTest {
 
@@ -74,6 +80,37 @@ public class ShadowNativeImageReaderTest {
     }
   }
 
+  @Test
+  public void imageReader_setOnImageAvailableListener() {
+    try (ImageReader imageReader = ImageReader.newInstance(SX, SY, PixelFormat.RGBA_8888, 1)) {
+      AtomicBoolean onImageAvailableInvoked = new AtomicBoolean();
+      imageReader.setOnImageAvailableListener(
+          reader -> onImageAvailableInvoked.set(true), new Handler(Looper.getMainLooper()));
+      Surface surface = imageReader.getSurface();
+      Canvas canvas = surface.lockHardwareCanvas();
+      surface.unlockCanvasAndPost(canvas);
+      shadowOf(Looper.getMainLooper()).idle();
+      assertThat(onImageAvailableInvoked.get()).isTrue();
+    }
+  }
+
+  @Test
+  public void imageReader_lockHardwareCanvas_drawColor() {
+    ImageReader reader = ImageReader.newInstance(100, 100, PixelFormat.RGBA_8888, 1);
+    Surface surface = reader.getSurface();
+    Canvas canvas = surface.lockHardwareCanvas();
+    canvas.drawColor(Color.RED);
+    surface.unlockCanvasAndPost(canvas);
+    Image image = reader.acquireNextImage();
+    assertThat(image).isNotNull();
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Plane[] planes = image.getPlanes();
+    bitmap.copyPixelsFromBuffer(planes[0].getBuffer());
+    surface.release();
+    assertThat(Integer.toHexString(bitmap.getPixel(50, 50)))
+        .isEqualTo(Integer.toHexString(Color.RED));
+  }
+
   @Test
   public void testGetHardwareBuffer() throws Exception {
     ImageReader reader = ImageReader.newInstance(1, 1, PixelFormat.RGBA_8888, 1);
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePaintTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePaintTest.java
index 93e65c48c..aa62c359f 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePaintTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePaintTest.java
@@ -123,26 +123,26 @@ public class ShadowNativePaintTest {
     assertThat(
             paint.breakText(
                 new char[] {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd'},
-                /*index=*/ 0,
-                /*count=*/ 11,
-                /*maxWidth=*/ 100,
-                /*measuredWidth=*/ null))
+                /* index= */ 0,
+                /* count= */ 11,
+                /* maxWidth= */ 100,
+                /* measuredWidth= */ null))
         .isGreaterThan(0);
     assertThat(
             paint.breakText(
                 "Hello World",
-                /*start=*/ 0,
-                /*end=*/ 11,
-                /*measureForwards=*/ true,
-                /*maxWidth=*/ 100,
-                /*measuredWidth=*/ null))
+                /* start= */ 0,
+                /* end= */ 11,
+                /* measureForwards= */ true,
+                /* maxWidth= */ 100,
+                /* measuredWidth= */ null))
         .isGreaterThan(0);
     assertThat(
             paint.breakText(
                 "Hello World",
-                /*measureForwards=*/ true,
-                /*maxWidth=*/ 100,
-                /*measuredWidth=*/ null))
+                /* measureForwards= */ true,
+                /* maxWidth= */ 100,
+                /* measuredWidth= */ null))
         .isGreaterThan(0);
   }
 
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathIteratorTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathIteratorTest.java
new file mode 100644
index 000000000..aea232219
--- /dev/null
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathIteratorTest.java
@@ -0,0 +1,535 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Derived from
+ * https://cs.android.com/android/platform/superproject/+/android-14.0.0_r1:cts/tests/tests/graphics/src/android/graphics/cts/PathIteratorTest.java
+ */
+
+package org.robolectric.shadows;
+
+import static android.graphics.PathIterator.VERB_CLOSE;
+import static android.graphics.PathIterator.VERB_CONIC;
+import static android.graphics.PathIterator.VERB_CUBIC;
+import static android.graphics.PathIterator.VERB_DONE;
+import static android.graphics.PathIterator.VERB_LINE;
+import static android.graphics.PathIterator.VERB_MOVE;
+import static android.graphics.PathIterator.VERB_QUAD;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertThrows;
+
+import android.graphics.Path;
+import android.graphics.PathIterator;
+import java.util.ConcurrentModificationException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.versioning.AndroidVersions.U;
+import org.robolectric.versioning.AndroidVersions.V;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(minSdk = U.SDK_INT)
+public class ShadowNativePathIteratorTest {
+
+  private Path mPath;
+  private final float[] mPoints = new float[8];
+
+  @Before
+  public void setup() {
+    mPath = new Path();
+  }
+
+  @Test
+  public void testIteratorExists() {
+    PathIterator iterator = mPath.getPathIterator();
+    assertNotNull(iterator);
+  }
+
+  @Test
+  public void testEmptyPath() {
+    PathIterator iterator = mPath.getPathIterator();
+    assertFalse(iterator.hasNext());
+    assertEquals(
+        "Empty path should have no verbs", PathIterator.VERB_DONE, iterator.next(mPoints, 0));
+
+    // Now with next()
+    iterator = mPath.getPathIterator();
+    assertFalse(iterator.hasNext());
+    assertEquals(
+        "Empty path should have no verbs", PathIterator.VERB_DONE, iterator.next().getVerb());
+  }
+
+  @Test
+  public void testMove() {
+    mPath.moveTo(100f, 200f);
+    PathIterator iterator;
+
+    iterator = mPath.getPathIterator();
+    assertEquals(PathIterator.VERB_MOVE, iterator.next(mPoints, 0));
+    assertEquals(PathIterator.VERB_DONE, iterator.next(mPoints, 0));
+
+    // Now with next()
+    iterator = mPath.getPathIterator();
+    assertEquals(PathIterator.VERB_MOVE, iterator.next().getVerb());
+    assertEquals(PathIterator.VERB_DONE, iterator.next().getVerb());
+  }
+
+  @Test
+  public void testDoneDone() {
+    mPath.lineTo(100f, 200f);
+    int verbIndex = 0;
+    for (PathIterator it = mPath.getPathIterator(); it.hasNext(); ) {
+      PathIterator.Segment segment = it.next();
+      int verb = segment.getVerb();
+      switch (verbIndex) {
+        case 0:
+          assertEquals(PathIterator.VERB_MOVE, verb);
+          break;
+        case 1:
+          assertEquals(PathIterator.VERB_LINE, verb);
+          break;
+        default: // fall out
+      }
+      verbIndex++;
+    }
+    assertThat(verbIndex).isLessThan(3);
+
+    // Now with next(float[], int)
+    PathIterator iterator = mPath.getPathIterator();
+    assertEquals(PathIterator.VERB_MOVE, iterator.next(mPoints, 0));
+    assertEquals(PathIterator.VERB_LINE, iterator.next(mPoints, 0));
+    assertEquals(PathIterator.VERB_DONE, iterator.next(mPoints, 0));
+    // An iterator with no more elements simply returns DONE on all subsequent next calls
+    assertEquals(PathIterator.VERB_DONE, iterator.next(mPoints, 0));
+  }
+
+  @Test
+  public void testPeek() {
+    mPath.lineTo(100f, 200f);
+    mPath.quadTo(300f, 400f, 500f, 600f);
+    PathIterator iterator = mPath.getPathIterator();
+    assertEquals(PathIterator.VERB_MOVE, iterator.peek());
+    // Calling peek() again should not change the next operation
+    assertEquals(PathIterator.VERB_MOVE, iterator.peek());
+    assertEquals(PathIterator.VERB_MOVE, iterator.next(mPoints, 0));
+    assertEquals(PathIterator.VERB_LINE, iterator.peek());
+    assertEquals(PathIterator.VERB_LINE, iterator.next(mPoints, 0));
+    assertEquals(PathIterator.VERB_QUAD, iterator.next(mPoints, 0));
+    assertEquals(PathIterator.VERB_DONE, iterator.peek());
+
+    // Now with next()
+    iterator = mPath.getPathIterator();
+    assertEquals(PathIterator.VERB_MOVE, iterator.peek());
+    // Calling peek() again should not change the next operation
+    assertEquals(PathIterator.VERB_MOVE, iterator.peek());
+    assertEquals(PathIterator.VERB_MOVE, iterator.next().getVerb());
+    assertEquals(PathIterator.VERB_LINE, iterator.peek());
+    assertEquals(PathIterator.VERB_LINE, iterator.next().getVerb());
+    assertEquals(PathIterator.VERB_QUAD, iterator.next().getVerb());
+    assertEquals(PathIterator.VERB_DONE, iterator.peek());
+  }
+
+  @Test
+  public void testLine() {
+    mPath.lineTo(100f, 200f);
+    PathIterator iterator = mPath.getPathIterator();
+    assertEquals(PathIterator.VERB_MOVE, iterator.next(mPoints, 0));
+    assertEquals(PathIterator.VERB_LINE, iterator.next(mPoints, 0));
+    assertEquals(0f, mPoints[0], 0f);
+    assertEquals(0f, mPoints[1], 0f);
+    assertEquals(100f, mPoints[2], 0f);
+    assertEquals(200f, mPoints[3], 0f);
+    assertEquals(PathIterator.VERB_DONE, iterator.next(mPoints, 0));
+
+    // Now with next()
+    iterator = mPath.getPathIterator();
+    PathIterator.Segment segment;
+    segment = iterator.next();
+    assertEquals(PathIterator.VERB_MOVE, segment.getVerb());
+    segment = iterator.next();
+    assertEquals(PathIterator.VERB_LINE, segment.getVerb());
+    float[] points = segment.getPoints();
+    assertEquals(0f, points[0], 0f);
+    assertEquals(0f, points[1], 0f);
+    assertEquals(100f, points[2], 0f);
+    assertEquals(200f, points[3], 0f);
+    segment = iterator.next();
+    assertEquals(PathIterator.VERB_DONE, segment.getVerb());
+  }
+
+  // TODO(hoisie): Enable for U when Path.conicTo is supported in RNG
+  @Config(minSdk = V.SDK_INT)
+  @Test
+  public void testIterable() {
+    mPath.lineTo(100f, 200f);
+    mPath.conicTo(300f, 400f, 500f, 600f, 2f);
+    int verbIndex = 0;
+    for (PathIterator it = mPath.getPathIterator(); it.hasNext(); ) {
+      PathIterator.Segment segment = it.next();
+      int verb = segment.getVerb();
+      float[] points = segment.getPoints();
+      float weight = segment.getConicWeight();
+      switch (verbIndex) {
+        case 0:
+          assertEquals(PathIterator.VERB_MOVE, verb);
+          break;
+        case 1:
+          assertEquals(PathIterator.VERB_LINE, verb);
+          assertEquals(0f, points[0], 0f);
+          assertEquals(0f, points[1], 0f);
+          assertEquals(100f, points[2], 0f);
+          assertEquals(200f, points[3], 0f);
+          break;
+        case 2:
+          assertEquals(PathIterator.VERB_CONIC, verb);
+          assertEquals(100f, points[0], 0f);
+          assertEquals(200f, points[1], 0f);
+          assertEquals(300f, points[2], 0f);
+          assertEquals(400f, points[3], 0f);
+          assertEquals(500f, points[4], 0f);
+          assertEquals(600f, points[5], 0f);
+          assertEquals(2f, weight, 0f);
+          break;
+        case 3:
+          assertEquals(PathIterator.VERB_DONE, verb);
+          break;
+        default: // fall out
+      }
+      verbIndex++;
+      if (verbIndex > 3) {
+        break;
+      }
+    }
+  }
+
+  @Test
+  public void testQuad() {
+    mPath.quadTo(100f, 200f, 300f, 400f);
+    PathIterator iterator;
+    iterator = mPath.getPathIterator();
+    assertEquals(PathIterator.VERB_MOVE, iterator.next(mPoints, 0));
+    assertEquals(PathIterator.VERB_QUAD, iterator.next(mPoints, 0));
+    assertEquals(0f, mPoints[0], 0f);
+    assertEquals(0f, mPoints[1], 0f);
+    assertEquals(100f, mPoints[2], 0f);
+    assertEquals(200f, mPoints[3], 0f);
+    assertEquals(300f, mPoints[4], 0f);
+    assertEquals(400f, mPoints[5], 0f);
+    assertEquals(PathIterator.VERB_DONE, iterator.next(mPoints, 0));
+
+    // Now with next()
+    iterator = mPath.getPathIterator();
+    assertEquals(PathIterator.VERB_MOVE, iterator.next().getVerb());
+    PathIterator.Segment segment = iterator.next();
+    assertEquals(PathIterator.VERB_QUAD, segment.getVerb());
+    float[] points = segment.getPoints();
+    assertEquals(0f, points[0], 0f);
+    assertEquals(0f, points[1], 0f);
+    assertEquals(100f, points[2], 0f);
+    assertEquals(200f, points[3], 0f);
+    assertEquals(300f, points[4], 0f);
+    assertEquals(400f, points[5], 0f);
+    assertEquals(PathIterator.VERB_DONE, iterator.next().getVerb());
+  }
+
+  // TODO(hoisie): Enable for U when Path.conicTo is supported in RNG
+  @Config(minSdk = V.SDK_INT)
+  @Test
+  public void testConic() {
+    mPath.conicTo(100f, 200f, 300f, 400f, 2f);
+    PathIterator iterator;
+    iterator = mPath.getPathIterator();
+    assertEquals(PathIterator.VERB_MOVE, iterator.next(mPoints, 0));
+    assertEquals(PathIterator.VERB_CONIC, iterator.next(mPoints, 0));
+    assertEquals(0f, mPoints[0], 0f);
+    assertEquals(0f, mPoints[1], 0f);
+    assertEquals(100f, mPoints[2], 0f);
+    assertEquals(200f, mPoints[3], 0f);
+    assertEquals(300f, mPoints[4], 0f);
+    assertEquals(400f, mPoints[5], 0f);
+    assertEquals(2f, mPoints[6], 0f);
+    assertEquals(PathIterator.VERB_DONE, iterator.next(mPoints, 0));
+
+    // Now with next()
+    iterator = mPath.getPathIterator();
+    assertEquals(PathIterator.VERB_MOVE, iterator.next().getVerb());
+    PathIterator.Segment segment = iterator.next();
+    assertEquals(PathIterator.VERB_CONIC, segment.getVerb());
+    float[] points = segment.getPoints();
+    assertEquals(0f, points[0], 0f);
+    assertEquals(0f, points[1], 0f);
+    assertEquals(100f, points[2], 0f);
+    assertEquals(200f, points[3], 0f);
+    assertEquals(300f, points[4], 0f);
+    assertEquals(400f, points[5], 0f);
+    assertEquals(2f, segment.getConicWeight(), 0f);
+    assertEquals(PathIterator.VERB_DONE, iterator.next().getVerb());
+  }
+
+  @Test
+  public void testCubic() {
+    mPath.cubicTo(100f, 200f, 300f, 400f, 500f, 600f);
+    PathIterator iterator;
+    iterator = mPath.getPathIterator();
+    assertEquals(PathIterator.VERB_MOVE, iterator.next(mPoints, 0));
+    assertEquals(PathIterator.VERB_CUBIC, iterator.next(mPoints, 0));
+    assertEquals(0f, mPoints[0], 0f);
+    assertEquals(0f, mPoints[1], 0f);
+    assertEquals(100f, mPoints[2], 0f);
+    assertEquals(200f, mPoints[3], 0f);
+    assertEquals(300f, mPoints[4], 0f);
+    assertEquals(400f, mPoints[5], 0f);
+    assertEquals(500f, mPoints[6], 0f);
+    assertEquals(600f, mPoints[7], 0f);
+    assertEquals(PathIterator.VERB_DONE, iterator.next(mPoints, 0));
+
+    // Now with next()
+    iterator = mPath.getPathIterator();
+    assertEquals(PathIterator.VERB_MOVE, iterator.next().getVerb());
+    PathIterator.Segment segment = iterator.next();
+    assertEquals(PathIterator.VERB_CUBIC, segment.getVerb());
+    float[] points = segment.getPoints();
+    assertEquals(0f, points[0], 0f);
+    assertEquals(0f, points[1], 0f);
+    assertEquals(100f, points[2], 0f);
+    assertEquals(200f, points[3], 0f);
+    assertEquals(300f, points[4], 0f);
+    assertEquals(400f, points[5], 0f);
+    assertEquals(500f, points[6], 0f);
+    assertEquals(600f, points[7], 0f);
+    assertEquals(PathIterator.VERB_DONE, iterator.next().getVerb());
+  }
+
+  @Test
+  public void testClose() {
+    mPath.quadTo(100f, 200f, 300f, 400f);
+    mPath.close();
+    PathIterator iterator;
+    iterator = mPath.getPathIterator();
+    assertEquals(PathIterator.VERB_MOVE, iterator.next(mPoints, 0));
+    assertEquals(PathIterator.VERB_QUAD, iterator.next(mPoints, 0));
+    assertEquals(PathIterator.VERB_CLOSE, iterator.next(mPoints, 0));
+    assertEquals(PathIterator.VERB_DONE, iterator.next(mPoints, 0));
+
+    // Now with next()
+    iterator = mPath.getPathIterator();
+    assertEquals(PathIterator.VERB_MOVE, iterator.next().getVerb());
+    assertEquals(PathIterator.VERB_QUAD, iterator.next().getVerb());
+    assertEquals(PathIterator.VERB_CLOSE, iterator.next().getVerb());
+    assertEquals(PathIterator.VERB_DONE, iterator.next().getVerb());
+  }
+
+  // TODO(hoisie): Enable for U when Path.getGenerationId is supported in RNG
+  @Config(minSdk = V.SDK_INT)
+  @Test
+  public void testPathModification() {
+    mPath.lineTo(100f, 200f);
+    final PathIterator iterator = mPath.getPathIterator();
+    mPath.lineTo(300f, 400);
+    assertThrows(ConcurrentModificationException.class, () -> iterator.next(mPoints, 0));
+
+    final PathIterator iterator1 = mPath.getPathIterator();
+    mPath.reset();
+    assertThrows(ConcurrentModificationException.class, () -> iterator1.next(mPoints, 0));
+
+    // Now with next()
+    final PathIterator iterator2 = mPath.getPathIterator();
+    mPath.lineTo(300f, 400);
+    assertThrows(ConcurrentModificationException.class, iterator2::next);
+
+    final PathIterator iterator3 = mPath.getPathIterator();
+    mPath.reset();
+    assertThrows(ConcurrentModificationException.class, iterator3::next);
+  }
+
+  @Test
+  public void testPointsArray() {
+    mPath.lineTo(100f, 200f);
+    PathIterator iterator = mPath.getPathIterator();
+    for (int i = 0; i < 8; ++i) {
+      float[] smallArray = new float[i];
+      assertThrows(
+          "Points array of size " + i + " too small",
+          ArrayIndexOutOfBoundsException.class,
+          () -> iterator.next(smallArray, 0));
+    }
+    // Also check a proper-sized array with an offset that makes it too small
+    for (int i = 1; i < 8; ++i) {
+      final int offset = i;
+      assertThrows(
+          "Points array with offset " + offset + " too small",
+          ArrayIndexOutOfBoundsException.class,
+          () -> iterator.next(mPoints, offset));
+    }
+  }
+
+  @Test
+  public void testPointsArrayOffset() {
+    float[] pointsArray = new float[16];
+    mPath.lineTo(100f, 200f);
+    for (int offset = 0; offset < 8; ++offset) {
+      PathIterator iterator = mPath.getPathIterator();
+      assertEquals(PathIterator.VERB_MOVE, iterator.next(pointsArray, offset));
+      assertEquals(PathIterator.VERB_LINE, iterator.next(pointsArray, offset));
+      assertEquals(0f, pointsArray[offset + 0], 0f);
+      assertEquals(0f, pointsArray[offset + 1], 0f);
+      assertEquals(100f, pointsArray[offset + 2], 0f);
+      assertEquals(200f, pointsArray[offset + 3], 0f);
+      assertEquals(PathIterator.VERB_DONE, iterator.next(pointsArray, offset));
+    }
+  }
+
+  // TODO(hoisie): Enable for U when Path.conicTo is supported in RNG
+  @Config(minSdk = V.SDK_INT)
+  @Test
+  public void testRecreation() {
+    mPath.moveTo(10f, 10f);
+    mPath.quadTo(100f, 200f, 300f, 400f);
+    mPath.lineTo(500f, 600f);
+    mPath.cubicTo(700f, 800f, 900f, 1000f, 1100f, 1200f);
+    mPath.conicTo(1f, 2f, 3f, 4f, 2f);
+    mPath.close();
+    PathIterator iterator = mPath.getPathIterator();
+    Path pathCopy = new Path();
+    boolean lineDone = false;
+    var verb = iterator.next(mPoints, 0);
+    while (verb != VERB_DONE) {
+      lineDone = issuePathCommand(pathCopy, mPoints, lineDone, verb, mPoints[6]);
+      verb = iterator.next(mPoints, 0);
+    }
+    assertPathsEqual(mPath, pathCopy);
+
+    // Now with next()
+    iterator = mPath.getPathIterator();
+    pathCopy = new Path();
+    lineDone = false;
+    PathIterator.Segment segment = iterator.next();
+    while (segment.getVerb() != PathIterator.VERB_DONE) {
+      lineDone =
+          issuePathCommand(
+              pathCopy, segment.getPoints(), lineDone, segment.getVerb(), segment.getConicWeight());
+      segment = iterator.next();
+    }
+    assertPathsEqual(mPath, pathCopy);
+  }
+
+  private boolean issuePathCommand(
+      Path pathCopy, float[] points, boolean lineDone, int verb, float conicWeight) {
+    switch (verb) {
+      case VERB_MOVE:
+        pathCopy.moveTo(points[0], points[1]);
+        break;
+      case VERB_LINE:
+        if (!lineDone) {
+          // Skia inserts a lineTo() when close() is issued. We should
+          // ignore that second lineTo() because it will make the paths unequal
+          // in operations if not in geometry
+          pathCopy.lineTo(points[2], points[3]);
+          lineDone = true;
+        }
+        break;
+      case VERB_QUAD:
+        pathCopy.quadTo(points[2], points[3], points[4], points[5]);
+        break;
+      case VERB_CONIC:
+        pathCopy.conicTo(points[2], points[3], points[4], points[5], conicWeight);
+        break;
+      case VERB_CUBIC:
+        pathCopy.cubicTo(points[2], points[3], points[4], points[5], points[6], points[7]);
+        break;
+      case VERB_CLOSE:
+        pathCopy.close();
+        break;
+      default: // fall out
+    }
+    return lineDone;
+  }
+
+  private void assertPathsEqual(Path path1, Path path2) {
+    PathIterator iterator1 = path1.getPathIterator();
+    PathIterator iterator2 = path2.getPathIterator();
+    float[] points1 = new float[8];
+    float[] points2 = new float[8];
+    int verb1 = iterator1.next(points1, 0);
+    int verb2 = iterator2.next(points2, 0);
+    while (verb1 != PathIterator.VERB_DONE && verb2 != PathIterator.VERB_DONE) {
+      assertEquals(verb1, verb2);
+      switch (verb1) {
+        case VERB_MOVE:
+          assertPointsEqual(points1, points2, 2);
+          break;
+        case VERB_LINE:
+          assertPointsEqual(points1, points2, 4);
+          break;
+        case VERB_QUAD:
+          assertPointsEqual(points1, points2, 6);
+          break;
+        case VERB_CONIC:
+        case VERB_CUBIC:
+          assertPointsEqual(points1, points2, 8);
+          break;
+        case VERB_CLOSE:
+          assertPointsEqual(points1, points2, 0);
+          break;
+        default: // fall out
+      }
+      verb1 = iterator1.next(points1, 0);
+      verb2 = iterator2.next(points2, 0);
+    }
+
+    // Now with next()
+    iterator1 = path1.getPathIterator();
+    iterator2 = path2.getPathIterator();
+    PathIterator.Segment segment1 = iterator1.next();
+    PathIterator.Segment segment2 = iterator2.next();
+    while ((verb1 = segment1.getVerb()) != PathIterator.VERB_DONE
+        && (verb2 = segment2.getVerb()) != PathIterator.VERB_DONE) {
+      points1 = segment1.getPoints();
+      points2 = segment2.getPoints();
+      assertEquals(verb1, verb2);
+      switch (verb1) {
+        case VERB_MOVE:
+          assertPointsEqual(points1, points2, 2);
+          break;
+        case VERB_LINE:
+          assertPointsEqual(points1, points2, 4);
+          break;
+        case VERB_QUAD:
+          assertPointsEqual(points1, points2, 6);
+          break;
+        case VERB_CONIC:
+        case VERB_CUBIC:
+          assertPointsEqual(points1, points2, 8);
+          break;
+        case VERB_CLOSE:
+          assertPointsEqual(points1, points2, 0);
+          break;
+        default: // fall out
+      }
+      segment1 = iterator1.next();
+      segment2 = iterator2.next();
+    }
+  }
+
+  private void assertPointsEqual(float[] points1, float[] points2, int numToCheck) {
+    for (int i = 0; i < numToCheck; ++i) {
+      assertEquals("point " + i + "not equal", points1[i], points2[i], 0f);
+    }
+  }
+}
diff --git a/integration_tests/play_services/build.gradle b/integration_tests/play_services/build.gradle
index c7e522020..2c2111bf8 100644
--- a/integration_tests/play_services/build.gradle
+++ b/integration_tests/play_services/build.gradle
@@ -1,6 +1,6 @@
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.java.module)
+}
 
 dependencies {
     api project(":robolectric")
diff --git a/integration_tests/powermock/build.gradle b/integration_tests/powermock/build.gradle
index 6d5cf689d..1c5d3fae4 100644
--- a/integration_tests/powermock/build.gradle
+++ b/integration_tests/powermock/build.gradle
@@ -1,6 +1,6 @@
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.java.module)
+}
 
 dependencies {
     api project(":robolectric")
diff --git a/integration_tests/powermock/src/test/java/org/robolectric/integrationtests/mockito/PowerMockStaticTest.java b/integration_tests/powermock/src/test/java/org/robolectric/integrationtests/mockito/PowerMockStaticTest.java
index 60040d640..adefa5a0c 100644
--- a/integration_tests/powermock/src/test/java/org/robolectric/integrationtests/mockito/PowerMockStaticTest.java
+++ b/integration_tests/powermock/src/test/java/org/robolectric/integrationtests/mockito/PowerMockStaticTest.java
@@ -16,8 +16,7 @@ import org.robolectric.RobolectricTestRunner;
 @PowerMockIgnore({"org.mockito.*", "org.robolectric.*", "android.*"})
 @PrepareForTest(PowerMockStaticTest.Static.class)
 public class PowerMockStaticTest {
-  @Rule
-  public PowerMockRule rule = new PowerMockRule();
+  @Rule public PowerMockRule rule = new PowerMockRule();
 
   @Test
   public void testStaticMocking() {
diff --git a/integration_tests/roborazzi/build.gradle b/integration_tests/roborazzi/build.gradle
index 034a69bba..54c0dc029 100644
--- a/integration_tests/roborazzi/build.gradle
+++ b/integration_tests/roborazzi/build.gradle
@@ -1,8 +1,12 @@
-import org.robolectric.gradle.AndroidProjectConfigPlugin
-apply plugin: 'com.android.library'
-apply plugin: AndroidProjectConfigPlugin
-apply plugin: 'kotlin-android'
-apply plugin: "io.github.takahirom.roborazzi"
+plugins {
+    alias(libs.plugins.android.library)
+    alias(libs.plugins.detekt)
+    alias(libs.plugins.kotlin.android)
+    alias(libs.plugins.robolectric.android.project)
+    alias(libs.plugins.robolectric.spotless)
+    alias(libs.plugins.roborazzi)
+}
+
 android {
     compileSdk 34
     namespace 'org.robolectric.integration.roborazzi'
diff --git a/integration_tests/roborazzi/src/test/java/org/robolectric/integration/roborazzi/RoborazziCaptureTest.kt b/integration_tests/roborazzi/src/test/java/org/robolectric/integration/roborazzi/RoborazziCaptureTest.kt
index 6a54739fd..5995d7f92 100644
--- a/integration_tests/roborazzi/src/test/java/org/robolectric/integration/roborazzi/RoborazziCaptureTest.kt
+++ b/integration_tests/roborazzi/src/test/java/org/robolectric/integration/roborazzi/RoborazziCaptureTest.kt
@@ -114,6 +114,7 @@ private fun registerActivityToPackageManager(activity: String) {
     .addActivityIfNotPresent(ComponentName(appContext.packageName, activity))
 }
 
+@Suppress("ForbiddenComment")
 private fun hardwareRendererEnvironment(block: () -> Unit) {
   val originalHwrdrOption =
     System.getProperty(RoborazziCaptureTest.USE_HARDWARE_RENDERER_NATIVE_ENV, null)
diff --git a/integration_tests/room/build.gradle b/integration_tests/room/build.gradle
index 52831db58..418c20e9f 100644
--- a/integration_tests/room/build.gradle
+++ b/integration_tests/room/build.gradle
@@ -1,14 +1,14 @@
-import org.robolectric.gradle.AndroidProjectConfigPlugin
-
-apply plugin: 'com.android.library'
-apply plugin: AndroidProjectConfigPlugin
+plugins {
+    alias(libs.plugins.android.library)
+    alias(libs.plugins.robolectric.android.project)
+}
 
 android {
     compileSdk 34
     namespace 'org.robolectric.integrationtests.room'
 
     defaultConfig {
-        minSdk 19
+        minSdk 21
         targetSdk 34
     }
 
diff --git a/integration_tests/sdkcompat/build.gradle b/integration_tests/sdkcompat/build.gradle
new file mode 100644
index 000000000..09700a5db
--- /dev/null
+++ b/integration_tests/sdkcompat/build.gradle
@@ -0,0 +1,39 @@
+plugins {
+    alias(libs.plugins.android.library)
+    alias(libs.plugins.detekt)
+    alias(libs.plugins.kotlin.android)
+    alias(libs.plugins.robolectric.android.project)
+    alias(libs.plugins.robolectric.spotless)
+}
+
+
+android {
+    compileSdk 29
+    namespace 'org.robolectric.integrationtests.sdkcompat'
+
+    defaultConfig {
+        minSdk 21
+        // We must keep targetSdk to 29 for compatibility testing purpose
+        targetSdk 29
+    }
+
+    compileOptions {
+        sourceCompatibility = '1.8'
+        targetCompatibility = '1.8'
+    }
+
+    kotlinOptions {
+        jvmTarget = '1.8'
+    }
+
+    testOptions.unitTests.includeAndroidResources true
+}
+
+dependencies {
+    implementation libs.kotlin.stdlib
+
+    testImplementation project(":testapp")
+    testImplementation project(":robolectric")
+    testImplementation libs.junit4
+    testImplementation libs.truth
+}
diff --git a/integration_tests/compat-target28/src/main/AndroidManifest.xml b/integration_tests/sdkcompat/src/main/AndroidManifest.xml
similarity index 76%
rename from integration_tests/compat-target28/src/main/AndroidManifest.xml
rename to integration_tests/sdkcompat/src/main/AndroidManifest.xml
index b4251821a..760b4af4a 100644
--- a/integration_tests/compat-target28/src/main/AndroidManifest.xml
+++ b/integration_tests/sdkcompat/src/main/AndroidManifest.xml
@@ -2,6 +2,6 @@
 <manifest xmlns:tools="http://schemas.android.com/tools"
     xmlns:android="http://schemas.android.com/apk/res/android">
     <application
-        android:appComponentFactory="org.robolectric.integrationtests.compattarget28.TestAppComponentFactory"
-        tools:targetApi="p" />
+        android:appComponentFactory="org.robolectric.integrationtests.sdkcompat.TestAppComponentFactory"
+        tools:targetApi="q" />
 </manifest>
diff --git a/integration_tests/compat-target28/src/main/java/org/robolectric/integrationtests/compattarget28/MainActivity.java b/integration_tests/sdkcompat/src/main/java/org/robolectric/integrationtests/sdkcompat/MainActivity.java
similarity index 87%
rename from integration_tests/compat-target28/src/main/java/org/robolectric/integrationtests/compattarget28/MainActivity.java
rename to integration_tests/sdkcompat/src/main/java/org/robolectric/integrationtests/sdkcompat/MainActivity.java
index 88722c541..b4f27c88e 100644
--- a/integration_tests/compat-target28/src/main/java/org/robolectric/integrationtests/compattarget28/MainActivity.java
+++ b/integration_tests/sdkcompat/src/main/java/org/robolectric/integrationtests/sdkcompat/MainActivity.java
@@ -1,4 +1,4 @@
-package org.robolectric.integrationtests.compattarget28;
+package org.robolectric.integrationtests.sdkcompat;
 
 import android.app.Activity;
 
diff --git a/integration_tests/compat-target28/src/main/java/org/robolectric/integrationtests/compattarget28/TestAppComponentFactory.java b/integration_tests/sdkcompat/src/main/java/org/robolectric/integrationtests/sdkcompat/TestAppComponentFactory.java
similarity index 92%
rename from integration_tests/compat-target28/src/main/java/org/robolectric/integrationtests/compattarget28/TestAppComponentFactory.java
rename to integration_tests/sdkcompat/src/main/java/org/robolectric/integrationtests/sdkcompat/TestAppComponentFactory.java
index 8f16ee0e7..b059a72ab 100644
--- a/integration_tests/compat-target28/src/main/java/org/robolectric/integrationtests/compattarget28/TestAppComponentFactory.java
+++ b/integration_tests/sdkcompat/src/main/java/org/robolectric/integrationtests/sdkcompat/TestAppComponentFactory.java
@@ -1,4 +1,4 @@
-package org.robolectric.integrationtests.compattarget28;
+package org.robolectric.integrationtests.sdkcompat;
 
 import android.app.Activity;
 import android.app.AppComponentFactory;
diff --git a/integration_tests/compat-target28/src/test/java/org/robolectric/integration/compat/target28/JavaClassResolveCompatibilityTest.java b/integration_tests/sdkcompat/src/test/java/org/robolectric/integrationtests/sdkcompat/JavaClassResolveCompatibilityTest.java
similarity index 69%
rename from integration_tests/compat-target28/src/test/java/org/robolectric/integration/compat/target28/JavaClassResolveCompatibilityTest.java
rename to integration_tests/sdkcompat/src/test/java/org/robolectric/integrationtests/sdkcompat/JavaClassResolveCompatibilityTest.java
index 9c86cffd0..06324c734 100644
--- a/integration_tests/compat-target28/src/test/java/org/robolectric/integration/compat/target28/JavaClassResolveCompatibilityTest.java
+++ b/integration_tests/sdkcompat/src/test/java/org/robolectric/integrationtests/sdkcompat/JavaClassResolveCompatibilityTest.java
@@ -1,4 +1,4 @@
-package org.robolectric.integration.compat.target28;
+package org.robolectric.integrationtests.sdkcompat;
 
 import static com.google.common.truth.Truth.assertThat;
 
@@ -6,6 +6,8 @@ import android.os.Build;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
 
 /**
  * Test class for Java's class resolve compatibility test. We must keep it with Java instead of
@@ -14,15 +16,13 @@ import org.robolectric.RobolectricTestRunner;
 @RunWith(RobolectricTestRunner.class)
 public class JavaClassResolveCompatibilityTest {
   @Test
-  public void sdkIs28() {
-    assertThat(Build.VERSION.SDK_INT).isEqualTo(Build.VERSION_CODES.P);
+  public void sdkIs29() {
+    assertThat(Build.VERSION.SDK_INT).isEqualTo(Build.VERSION_CODES.Q);
   }
 
   @Test
   public void shadowOf() {
     // https://github.com/robolectric/robolectric/issues/7095
-    // Enable this assertion when resolving all shadowOf compatibility problem
-    // assertThat(Shadows.shadowOf((Application) ApplicationProvider.getApplicationContext()))
-    //     .isNotNull();
+    assertThat(Shadows.shadowOf(RuntimeEnvironment.getApplication())).isNotNull();
   }
 }
diff --git a/integration_tests/compat-target28/src/test/java/org/robolectric/integration/compat/target28/NormalCompatibilityTest.kt b/integration_tests/sdkcompat/src/test/java/org/robolectric/integrationtests/sdkcompat/NormalCompatibilityTest.kt
similarity index 92%
rename from integration_tests/compat-target28/src/test/java/org/robolectric/integration/compat/target28/NormalCompatibilityTest.kt
rename to integration_tests/sdkcompat/src/test/java/org/robolectric/integrationtests/sdkcompat/NormalCompatibilityTest.kt
index 8521b5698..1a775ed6a 100644
--- a/integration_tests/compat-target28/src/test/java/org/robolectric/integration/compat/target28/NormalCompatibilityTest.kt
+++ b/integration_tests/sdkcompat/src/test/java/org/robolectric/integrationtests/sdkcompat/NormalCompatibilityTest.kt
@@ -1,4 +1,4 @@
-package org.robolectric.integration.compat.target28
+package org.robolectric.integrationtests.sdkcompat
 
 import android.content.Context
 import android.content.Context.VIBRATOR_SERVICE
@@ -19,8 +19,7 @@ import org.robolectric.RobolectricTestRunner
 import org.robolectric.RuntimeEnvironment
 import org.robolectric.Shadows
 import org.robolectric.annotation.Config
-import org.robolectric.integrationtests.compattarget28.MainActivity
-import org.robolectric.integrationtests.compattarget28.MainActivity.CreationSource
+import org.robolectric.integrationtests.sdkcompat.MainActivity.CreationSource
 import org.robolectric.testapp.TestActivity
 
 @RunWith(RobolectricTestRunner::class)
@@ -28,8 +27,8 @@ class NormalCompatibilityTest {
   private val application = RuntimeEnvironment.getApplication()
 
   @Test
-  fun `Environment SDK is 28`() {
-    assertThat(Build.VERSION.SDK_INT).isEqualTo(Build.VERSION_CODES.P)
+  fun `Environment SDK is 29`() {
+    assertThat(Build.VERSION.SDK_INT).isEqualTo(Build.VERSION_CODES.Q)
   }
 
   @Test
diff --git a/integration_tests/sdkcompat/src/test/resources/robolectric.properties b/integration_tests/sdkcompat/src/test/resources/robolectric.properties
new file mode 100644
index 000000000..3d78689f2
--- /dev/null
+++ b/integration_tests/sdkcompat/src/test/resources/robolectric.properties
@@ -0,0 +1 @@
+sdk=29
diff --git a/integration_tests/security-providers/build.gradle b/integration_tests/security-providers/build.gradle
index 8ac0264a8..7a3b0a231 100644
--- a/integration_tests/security-providers/build.gradle
+++ b/integration_tests/security-providers/build.gradle
@@ -1,6 +1,6 @@
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.java.module)
+}
 
 dependencies {
     api project(":robolectric")
diff --git a/integration_tests/sparsearray/build.gradle b/integration_tests/sparsearray/build.gradle
index 6353b6b91..fd6f19705 100644
--- a/integration_tests/sparsearray/build.gradle
+++ b/integration_tests/sparsearray/build.gradle
@@ -1,14 +1,17 @@
-import org.robolectric.gradle.AndroidProjectConfigPlugin
-apply plugin: 'com.android.library'
-apply plugin: AndroidProjectConfigPlugin
-apply plugin: 'kotlin-android'
-apply plugin: "io.gitlab.arturbosch.detekt"
+plugins {
+    alias(libs.plugins.android.library)
+    alias(libs.plugins.detekt)
+    alias(libs.plugins.kotlin.android)
+    alias(libs.plugins.robolectric.android.project)
+    alias(libs.plugins.robolectric.spotless)
+}
+
 android {
     compileSdk 34
     namespace 'org.robolectric.sparsearray'
 
     defaultConfig {
-        minSdk 19
+        minSdk 21
         targetSdk 34
     }
 
@@ -27,6 +30,7 @@ android {
         }
     }
 }
+
 dependencies {
     compileOnly AndroidSdk.MAX_SDK.coordinates
     implementation project(path: ':shadowapi', configuration: 'default')
diff --git a/integration_tests/versioning/build.gradle b/integration_tests/versioning/build.gradle
index 8ae425b51..b33bdcbd4 100644
--- a/integration_tests/versioning/build.gradle
+++ b/integration_tests/versioning/build.gradle
@@ -1,15 +1,15 @@
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
-apply plugin: DeployedRoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+}
 
 configurations {
     earlyRuntime
 }
 
 dependencies {
-    compileOnly AndroidSdk.MAX_SDK.coordinates // compile against latest Android SDK (AndroidSdk.s.coordinates) { force = true }
+    // compile against latest Android SDK (AndroidSdk.s.coordinates) { force = true }
+    compileOnly AndroidSdk.MAX_SDK.coordinates
     testImplementation project(":robolectric")
     testImplementation libs.truth
     testImplementation "androidx.test.ext:junit:$axtJunitVersion@aar"
diff --git a/junit/build.gradle b/junit/build.gradle
index 5d5855254..c378838c1 100644
--- a/junit/build.gradle
+++ b/junit/build.gradle
@@ -1,8 +1,7 @@
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
-apply plugin: DeployedRoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+}
 
 dependencies {
     api project(":annotations")
diff --git a/junit/src/main/java/org/robolectric/internal/SandboxTestRunner.java b/junit/src/main/java/org/robolectric/internal/SandboxTestRunner.java
index 2821ff8bf..5d960ba0b 100644
--- a/junit/src/main/java/org/robolectric/internal/SandboxTestRunner.java
+++ b/junit/src/main/java/org/robolectric/internal/SandboxTestRunner.java
@@ -13,7 +13,9 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Queue;
+import java.util.WeakHashMap;
 import javax.annotation.Nonnull;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
@@ -68,6 +70,7 @@ public class SandboxTestRunner extends BlockJUnit4ClassRunner {
   private final List<PerfStatsReporter> perfStatsReporters;
   private final HashMap<Class<?>, Sandbox> loadedTestClasses = new HashMap<>();
   private final HashMap<Class<?>, HelperTestRunner> helperRunners = new HashMap<>();
+  private final WeakHashMap<Sandbox, LinkageError> firstLinkageErrors = new WeakHashMap<>();
 
   public SandboxTestRunner(Class<?> klass) throws InitializationError {
     this(klass, DEFAULT_INJECTOR);
@@ -165,16 +168,7 @@ public class SandboxTestRunner extends BlockJUnit4ClassRunner {
    */
   @Nonnull
   protected InstrumentationConfiguration createClassLoaderConfig(FrameworkMethod method) {
-    InstrumentationConfiguration.Builder builder =
-        InstrumentationConfiguration.newBuilder()
-            .doNotAcquirePackage("java.")
-            .doNotAcquirePackage("jdk.internal.")
-            .doNotAcquirePackage("sun.")
-            .doNotAcquirePackage("org.robolectric.annotation.")
-            .doNotAcquirePackage("org.robolectric.internal.")
-            .doNotAcquirePackage("org.robolectric.pluginapi.")
-            .doNotAcquirePackage("org.robolectric.util.")
-            .doNotAcquirePackage("org.junit");
+    InstrumentationConfiguration.Builder builder = InstrumentationConfiguration.newBuilder();
 
     String customPackages = System.getProperty("org.robolectric.packagesToNotAcquire", "");
     for (String pkg : Splitter.on(',').split(customPackages)) {
@@ -310,6 +304,11 @@ public class SandboxTestRunner extends BlockJUnit4ClassRunner {
 
               Throwable first = thrown.poll();
               if (first != null) {
+                if (first instanceof LinkageError) {
+                  // Potentially upgrade the LinkageError with a potentially more complete
+                  // descriptive exception.
+                  first = handleLinkageError(first, sandbox);
+                }
                 while (!thrown.isEmpty()) {
                   first.addSuppressed(thrown.remove());
                 }
@@ -320,6 +319,41 @@ public class SandboxTestRunner extends BlockJUnit4ClassRunner {
     };
   }
 
+  /**
+   * If an exception occurs when a class is being loaded (e.g. an exception during static
+   * initialization), the initial LinkageError is complete and informative. However, in subsequent
+   * tests, if the same class is attempted to be loaded, the JVM throws an error that is a truncated
+   * and incomplete NoClassDefError. This logic attempts to cache initial LinkageErrors and replace
+   * incomplete NoClassDefError with the original and more descriptive LinkageErrors.
+   */
+  private Throwable handleLinkageError(Throwable throwable, Sandbox sandbox) {
+    if (!firstLinkageErrors.containsKey(sandbox)) {
+      firstLinkageErrors.put(sandbox, (LinkageError) throwable);
+      return throwable;
+    }
+
+    if (throwable instanceof NoClassDefFoundError
+        && firstLinkageErrors.containsKey(sandbox)
+        && linkageErrorsMatch((NoClassDefFoundError) throwable, firstLinkageErrors.get(sandbox))) {
+      return firstLinkageErrors.get(sandbox);
+    }
+
+    return throwable;
+  }
+
+  private boolean linkageErrorsMatch(NoClassDefFoundError error, LinkageError first) {
+    if (error.getStackTrace().length == 0 || first.getStackTrace().length == 0) {
+      return false;
+    }
+    StackTraceElement firstElement = error.getStackTrace()[0];
+    for (StackTraceElement element : first.getStackTrace()) {
+      if (Objects.equals(firstElement, element)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   @SuppressWarnings("CatchAndPrintStackTrace")
   private void reportPerfStats(PerfStatsCollector perfStatsCollector) {
     if (perfStatsReporters.isEmpty()) {
diff --git a/junit/src/main/java/org/robolectric/internal/TimeLimitedStatement.java b/junit/src/main/java/org/robolectric/internal/TimeLimitedStatement.java
index 53cdf98da..3e16dfa81 100644
--- a/junit/src/main/java/org/robolectric/internal/TimeLimitedStatement.java
+++ b/junit/src/main/java/org/robolectric/internal/TimeLimitedStatement.java
@@ -5,10 +5,10 @@ import org.junit.runners.model.Statement;
 import org.junit.runners.model.TestTimedOutException;
 
 /**
- * Similar to JUnit's {@link org.junit.internal.runners.statements.FailOnTimeout}, but runs the
- * test on the current thread (with a timer on a new thread) rather than the other way around.
+ * Similar to JUnit's {@link org.junit.internal.runners.statements.FailOnTimeout}, but runs the test
+ * on the current thread (with a timer on a new thread) rather than the other way around.
  */
-class TimeLimitedStatement extends Statement {
+public class TimeLimitedStatement extends Statement {
 
   private final long timeout;
   private final Statement delegate;
diff --git a/nativeruntime/build.gradle b/nativeruntime/build.gradle
index 65f1e60a9..13eea5f8b 100644
--- a/nativeruntime/build.gradle
+++ b/nativeruntime/build.gradle
@@ -1,78 +1,77 @@
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
-apply plugin: DeployedRoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+}
 
 if (System.getenv('PUBLISH_NATIVERUNTIME_DIST_COMPAT') == "true") {
-  apply plugin: 'maven-publish'
-  apply plugin: "signing"
+    apply plugin: 'maven-publish'
+    apply plugin: "signing"
 
-  publishing {
-    publications {
-      nativeRuntimeDist(MavenPublication) {
-        artifact System.env["NATIVERUNTIME_DIST_COMPAT_JAR"]
-        artifactId 'nativeruntime-dist-compat'
-        version System.env["NATIVERUNTIME_DIST_COMPAT_VERSION"]
+    publishing {
+        publications {
+            nativeRuntimeDist(MavenPublication) {
+                artifact System.env["NATIVERUNTIME_DIST_COMPAT_JAR"]
+                artifactId 'nativeruntime-dist-compat'
+                version System.env["NATIVERUNTIME_DIST_COMPAT_VERSION"]
 
-        pom {
-          name = "Robolectric Nativeruntime Distribution Compat"
-          description = "Robolectric Nativeruntime Distribution Compat"
-          url = "https://source.android.com/"
-          inceptionYear = "2008"
-          licenses {
-            license {
-              name = "Apache 2.0"
-              url = "http://www.apache.org/licenses/LICENSE-2.0"
-              comments = "While the EULA for the Android SDK restricts distribution of those binaries, the source code is licensed under Apache 2.0 which allows compiling binaries from source and then distributing those versions."
-              distribution = "repo"
-            }
-          }
+                pom {
+                    name = "Robolectric Nativeruntime Distribution Compat"
+                    description = "Robolectric Nativeruntime Distribution Compat"
+                    url = "https://source.android.com/"
+                    inceptionYear = "2008"
+                    licenses {
+                        license {
+                            name = "Apache 2.0"
+                            url = "http://www.apache.org/licenses/LICENSE-2.0"
+                            comments = "While the EULA for the Android SDK restricts distribution of those binaries, the source code is licensed under Apache 2.0 which allows compiling binaries from source and then distributing those versions."
+                            distribution = "repo"
+                        }
+                    }
 
-          scm {
-            url = "https://android.googlesource.com/platform/manifest.git"
-            connection = "https://android.googlesource.com/platform/manifest.git"
-          }
+                    scm {
+                        url = "https://android.googlesource.com/platform/manifest.git"
+                        connection = "https://android.googlesource.com/platform/manifest.git"
+                    }
 
-          developers {
-            developer {
-              name = "The Android Open Source Projects"
+                    developers {
+                        developer {
+                            name = "The Android Open Source Projects"
+                        }
+                    }
+                }
             }
-          }
         }
-      }
-    }
-    repositories {
-      maven {
-        url = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
+        repositories {
+            maven {
+                url = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
 
-        credentials {
-          username = System.properties["sonatype-login"] ?: System.env['SONATYPE_LOGIN']
-          password = System.properties["sonatype-password"] ?: System.env['SONATYPE_PASSWORD']
+                credentials {
+                    username = System.properties["sonatype-login"] ?: System.env['SONATYPE_LOGIN']
+                    password = System.properties["sonatype-password"] ?: System.env['SONATYPE_PASSWORD']
+                }
+            }
         }
-      }
     }
-  }
 
-  signing {
-    sign publishing.publications.nativeRuntimeDist
-  }
+    signing {
+        sign publishing.publications.nativeRuntimeDist
+    }
 }
 
 dependencies {
-  api project(":utils")
-  api project(":utils:reflector")
-  api libs.guava
+    api project(":utils")
+    api project(":utils:reflector")
+    api libs.guava
 
-  implementation libs.robolectric.nativeruntime.dist.compat
+    implementation libs.robolectric.nativeruntime.dist.compat
 
-  annotationProcessor libs.auto.service
-  compileOnly libs.auto.service.annotations
-  compileOnly AndroidSdk.MAX_SDK.coordinates
+    annotationProcessor libs.auto.service
+    compileOnly libs.auto.service.annotations
+    compileOnly AndroidSdk.MAX_SDK.coordinates
 
-  testCompileOnly AndroidSdk.MAX_SDK.coordinates
-  testRuntimeOnly AndroidSdk.MAX_SDK.coordinates
-  testImplementation project(":robolectric")
-  testImplementation libs.junit4
-  testImplementation libs.truth
+    testCompileOnly AndroidSdk.MAX_SDK.coordinates
+    testRuntimeOnly AndroidSdk.MAX_SDK.coordinates
+    testImplementation project(":robolectric")
+    testImplementation libs.junit4
+    testImplementation libs.truth
 }
diff --git a/nativeruntime/src/main/java/org/robolectric/nativeruntime/BitmapNatives.java b/nativeruntime/src/main/java/org/robolectric/nativeruntime/BitmapNatives.java
index 8bc2e3656..3cdd5d319 100644
--- a/nativeruntime/src/main/java/org/robolectric/nativeruntime/BitmapNatives.java
+++ b/nativeruntime/src/main/java/org/robolectric/nativeruntime/BitmapNatives.java
@@ -84,8 +84,10 @@ public final class BitmapNatives {
   public static native int nativeGenerationId(long nativeBitmap);
 
   public static native Bitmap nativeCreateFromParcel(Parcel p);
+
   // returns true on success
   public static native boolean nativeWriteToParcel(long nativeBitmap, int density, Parcel p);
+
   // returns a new bitmap built from the native bitmap's alpha, and the paint
   public static native Bitmap nativeExtractAlpha(
       long nativeBitmap, long nativePaint, int[] offsetXY);
diff --git a/nativeruntime/src/main/java/org/robolectric/nativeruntime/FontFamilyNatives.java b/nativeruntime/src/main/java/org/robolectric/nativeruntime/FontFamilyNatives.java
index 933baff04..576e25550 100644
--- a/nativeruntime/src/main/java/org/robolectric/nativeruntime/FontFamilyNatives.java
+++ b/nativeruntime/src/main/java/org/robolectric/nativeruntime/FontFamilyNatives.java
@@ -36,6 +36,7 @@ public final class FontFamilyNatives {
   public static native long nGetBuilderReleaseFunc();
 
   public static native long nGetFamilyReleaseFunc();
+
   // By passing -1 to weight argument, the weight value is resolved by OS/2 table in the font.
   // By passing -1 to italic argument, the italic value is resolved by OS/2 table in the font.
   public static native boolean nAddFont(
diff --git a/nativeruntime/src/main/java/org/robolectric/nativeruntime/HardwareRendererNatives.java b/nativeruntime/src/main/java/org/robolectric/nativeruntime/HardwareRendererNatives.java
index 8553ecc48..140751417 100644
--- a/nativeruntime/src/main/java/org/robolectric/nativeruntime/HardwareRendererNatives.java
+++ b/nativeruntime/src/main/java/org/robolectric/nativeruntime/HardwareRendererNatives.java
@@ -58,6 +58,8 @@ public final class HardwareRendererNatives {
 
   public static native void nSetSurface(long nativeProxy, Surface window, boolean discardBuffer);
 
+  public static native void nSetSurfacePtr(long nativeProxy, long surfacePtr);
+
   public static native void nSetSurfaceControl(long nativeProxy, long nativeSurfaceControl);
 
   public static native boolean nPause(long nativeProxy);
diff --git a/nativeruntime/src/main/java/org/robolectric/nativeruntime/ImageDecoderNatives.java b/nativeruntime/src/main/java/org/robolectric/nativeruntime/ImageDecoderNatives.java
index 36d492587..ccefab37f 100644
--- a/nativeruntime/src/main/java/org/robolectric/nativeruntime/ImageDecoderNatives.java
+++ b/nativeruntime/src/main/java/org/robolectric/nativeruntime/ImageDecoderNatives.java
@@ -47,6 +47,7 @@ public final class ImageDecoderNatives {
 
   public static native ImageDecoder nCreate(
       InputStream is, byte[] storage, boolean preferAnimation, Source src) throws IOException;
+
   // The fd must be seekable.
   public static native ImageDecoder nCreate(
       FileDescriptor fd, long length, boolean preferAnimation, Source src) throws IOException;
diff --git a/nativeruntime/src/main/java/org/robolectric/nativeruntime/PathIteratorNatives.java b/nativeruntime/src/main/java/org/robolectric/nativeruntime/PathIteratorNatives.java
new file mode 100644
index 000000000..b8c21f0d5
--- /dev/null
+++ b/nativeruntime/src/main/java/org/robolectric/nativeruntime/PathIteratorNatives.java
@@ -0,0 +1,20 @@
+package org.robolectric.nativeruntime;
+
+/**
+ * Native methods for PathIterator JNI registration.
+ *
+ * <p>Native method signatures are derived from
+ * https://cs.android.com/android/platform/superproject/+/android-14.0.0_r1:frameworks/base/graphics/java/android/graphics/PathIterator.java
+ */
+public final class PathIteratorNatives {
+
+  public static native long nCreate(long nativePath);
+
+  public static native long nGetFinalizer();
+
+  public static native int nNext(long nativeIterator, long pointsAddress);
+
+  public static native int nPeek(long nativeIterator);
+
+  private PathIteratorNatives() {}
+}
diff --git a/nativeruntime/src/main/resources/arsc/Android.bp b/nativeruntime/src/main/resources/arsc/Android.bp
index 46f147911..6d627ffe5 100644
--- a/nativeruntime/src/main/resources/arsc/Android.bp
+++ b/nativeruntime/src/main/resources/arsc/Android.bp
@@ -18,8 +18,8 @@ genrule {
     out: ["values/public.xml"],
     cmd: "mkdir -p $(genDir)/values; echo '<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
         " <resources>" +
-        " <public type=\"string\" name=\"config_bodyFontFamily\" id=\"0x010401f8\" /> " +
-        " <public type=\"string\" name=\"config_headlineFontFamily\" id=\"0x0104026d\" /> " +
+        " <public type=\"string\" name=\"config_bodyFontFamily\" id=\"0x010401fe\" /> " +
+        " <public type=\"string\" name=\"config_headlineFontFamily\" id=\"0x01040273\" /> " +
         " </resources>' > $(out)",
 }
 
diff --git a/nativeruntime/src/main/resources/fonts/GoogleSans-Italic.ttf b/nativeruntime/src/main/resources/fonts/GoogleSans-Italic.ttf
index b6e807992..d246004e3 100644
Binary files a/nativeruntime/src/main/resources/fonts/GoogleSans-Italic.ttf and b/nativeruntime/src/main/resources/fonts/GoogleSans-Italic.ttf differ
diff --git a/nativeruntime/src/main/resources/fonts/GoogleSans-Regular.ttf b/nativeruntime/src/main/resources/fonts/GoogleSans-Regular.ttf
index 4e97ca945..b0ee9bef8 100644
Binary files a/nativeruntime/src/main/resources/fonts/GoogleSans-Regular.ttf and b/nativeruntime/src/main/resources/fonts/GoogleSans-Regular.ttf differ
diff --git a/nativeruntime/src/main/resources/fonts/GoogleSansFlex-Regular.ttf b/nativeruntime/src/main/resources/fonts/GoogleSansFlex-Regular.ttf
index f6dae398f..e3e837e8b 100644
Binary files a/nativeruntime/src/main/resources/fonts/GoogleSansFlex-Regular.ttf and b/nativeruntime/src/main/resources/fonts/GoogleSansFlex-Regular.ttf differ
diff --git a/nativeruntime/src/test/resources/resources.ap_ b/nativeruntime/src/test/resources/resources.ap_
index 13cc837ec..d5c10672f 100644
Binary files a/nativeruntime/src/test/resources/resources.ap_ and b/nativeruntime/src/test/resources/resources.ap_ differ
diff --git a/pluginapi/build.gradle b/pluginapi/build.gradle
index 9d7885291..f3ffe7625 100644
--- a/pluginapi/build.gradle
+++ b/pluginapi/build.gradle
@@ -1,8 +1,7 @@
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
-apply plugin: DeployedRoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+}
 
 dependencies {
     compileOnly libs.findbugs.jsr305
diff --git a/pluginapi/src/main/java/org/robolectric/internal/dependency/DependencyJar.java b/pluginapi/src/main/java/org/robolectric/internal/dependency/DependencyJar.java
index b8f5d7304..7d53edd99 100644
--- a/pluginapi/src/main/java/org/robolectric/internal/dependency/DependencyJar.java
+++ b/pluginapi/src/main/java/org/robolectric/internal/dependency/DependencyJar.java
@@ -38,7 +38,11 @@ public class DependencyJar {
   }
 
   public String getShortName() {
-    return getGroupId() + ":" + getArtifactId() + ":" + getVersion()
+    return getGroupId()
+        + ":"
+        + getArtifactId()
+        + ":"
+        + getVersion()
         + ((getClassifier() == null) ? "" : ":" + getClassifier());
   }
 
diff --git a/pluginapi/src/main/java/org/robolectric/internal/dependency/DependencyResolver.java b/pluginapi/src/main/java/org/robolectric/internal/dependency/DependencyResolver.java
index b21dce5ed..1d6546d28 100644
--- a/pluginapi/src/main/java/org/robolectric/internal/dependency/DependencyResolver.java
+++ b/pluginapi/src/main/java/org/robolectric/internal/dependency/DependencyResolver.java
@@ -17,8 +17,9 @@ public interface DependencyResolver {
 
   /**
    * Returns URLs representing the full transitive dependency graph of the given Maven dependency.
-   * @deprecated Robolectric will never ask for a dependency composed of more than one artifact,
-   *     so this method isn't necessary.
+   *
+   * @deprecated Robolectric will never ask for a dependency composed of more than one artifact, so
+   *     this method isn't necessary.
    */
   @Deprecated
   default URL[] getLocalArtifactUrls(DependencyJar dependency) {
diff --git a/pluginapi/src/main/java/org/robolectric/pluginapi/ExtensionPoint.java b/pluginapi/src/main/java/org/robolectric/pluginapi/ExtensionPoint.java
index 6264994db..a992cf2c8 100644
--- a/pluginapi/src/main/java/org/robolectric/pluginapi/ExtensionPoint.java
+++ b/pluginapi/src/main/java/org/robolectric/pluginapi/ExtensionPoint.java
@@ -4,11 +4,7 @@ import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Target;
 
-/**
- * Marks a component of Robolectric that may be replaced with a custom implementation.
- */
+/** Marks a component of Robolectric that may be replaced with a custom implementation. */
 @Documented
 @Target(ElementType.TYPE)
-public @interface ExtensionPoint {
-
-}
+public @interface ExtensionPoint {}
diff --git a/pluginapi/src/main/java/org/robolectric/pluginapi/Sdk.java b/pluginapi/src/main/java/org/robolectric/pluginapi/Sdk.java
index 22f57e333..af6511fdb 100644
--- a/pluginapi/src/main/java/org/robolectric/pluginapi/Sdk.java
+++ b/pluginapi/src/main/java/org/robolectric/pluginapi/Sdk.java
@@ -3,9 +3,7 @@ package org.robolectric.pluginapi;
 import java.nio.file.Path;
 import javax.annotation.Nonnull;
 
-/**
- * Represents a unique build of the Android SDK.
- */
+/** Represents a unique build of the Android SDK. */
 @SuppressWarnings("NewApi")
 public abstract class Sdk implements Comparable<Sdk> {
 
@@ -49,34 +47,33 @@ public abstract class Sdk implements Comparable<Sdk> {
    */
   public abstract String getAndroidCodeName();
 
-  /**
-   * Returns the path to jar for this SDK.
-   */
+  /** Returns the path to jar for this SDK. */
   public abstract Path getJarPath();
 
   /**
    * Determines if this SDK is supported in the running Robolectric environment.
    *
-   * An SDK might be unsupported if e.g. it requires a newer version of the JVM than is currently
+   * <p>An SDK might be unsupported if e.g. it requires a newer version of the JVM than is currently
    * running.
    *
-   * Unsupported SDKs should throw some explanatory exception when {@link #getJarPath()} is invoked.
+   * <p>Unsupported SDKs should throw some explanatory exception when {@link #getJarPath()} is
+   * invoked.
    *
-   * If this is an expensive operation, the implementation should cache the return value.
+   * <p>If this is an expensive operation, the implementation should cache the return value.
    */
   public abstract boolean isSupported();
 
   /**
    * Returns a human-readable message explaining why this SDK isn't supported.
    *
-   * If this is an expensive operation, the implementation should cache the return value.
+   * <p>If this is an expensive operation, the implementation should cache the return value.
    */
   public abstract String getUnsupportedMessage();
 
   /**
    * Determines if this SDK is known by its provider.
    *
-   * Unknown SDKs can serve as placeholder objects; they should throw some explanatory exception
+   * <p>Unknown SDKs can serve as placeholder objects; they should throw some explanatory exception
    * when {@link #getJarPath()} is invoked.
    */
   public boolean isKnown() {
@@ -117,7 +114,6 @@ public abstract class Sdk implements Comparable<Sdk> {
    * <p>Implementations should throw an exception if SDK is unsupported. They can choose to either
    * throw org.junit.AssumptionViolatedException to just skip execution of tests on the SDK, with a
    * warning, or throw a RuntimeException to fail the test.
-   *
    */
   public abstract void verifySupportedSdk(String testClassName);
 }
diff --git a/pluginapi/src/main/java/org/robolectric/pluginapi/SdkProvider.java b/pluginapi/src/main/java/org/robolectric/pluginapi/SdkProvider.java
index 1623ad60b..a07253081 100644
--- a/pluginapi/src/main/java/org/robolectric/pluginapi/SdkProvider.java
+++ b/pluginapi/src/main/java/org/robolectric/pluginapi/SdkProvider.java
@@ -6,7 +6,7 @@ import java.util.Collection;
  * A provider of known instances of {@link Sdk}. Implement this interface if you need to provide
  * SDKs in a special way for your environment.
  *
- * This is an extension point for Robolectric; see {@link org.robolectric.pluginapi} for details.
+ * <p>This is an extension point for Robolectric; see {@link org.robolectric.pluginapi} for details.
  */
 @ExtensionPoint
 public interface SdkProvider {
@@ -14,8 +14,8 @@ public interface SdkProvider {
   /**
    * Returns the set of SDKs available to run tests against.
    *
-   * It's okay for the implementation to block briefly while building the list; the results will be
-   * cached.
+   * <p>It's okay for the implementation to block briefly while building the list; the results will
+   * be cached.
    */
   Collection<Sdk> getSdks();
 }
diff --git a/pluginapi/src/main/java/org/robolectric/pluginapi/TestEnvironmentLifecyclePlugin.java b/pluginapi/src/main/java/org/robolectric/pluginapi/TestEnvironmentLifecyclePlugin.java
index 3c01577a4..7b47a8e2d 100644
--- a/pluginapi/src/main/java/org/robolectric/pluginapi/TestEnvironmentLifecyclePlugin.java
+++ b/pluginapi/src/main/java/org/robolectric/pluginapi/TestEnvironmentLifecyclePlugin.java
@@ -1,12 +1,8 @@
 package org.robolectric.pluginapi;
 
-/**
- * Plugin which allows behaviour extension in TestEnvironment.
- */
+/** Plugin which allows behaviour extension in TestEnvironment. */
 public interface TestEnvironmentLifecyclePlugin {
 
-  /**
-   * Runs additional setup during TestEnvironment.before().
-   */
+  /** Runs additional setup during TestEnvironment.before(). */
   void onSetupApplicationState();
 }
diff --git a/pluginapi/src/main/java/org/robolectric/pluginapi/UsesSdk.java b/pluginapi/src/main/java/org/robolectric/pluginapi/UsesSdk.java
index 94b6bf252..1fa9f2ae9 100644
--- a/pluginapi/src/main/java/org/robolectric/pluginapi/UsesSdk.java
+++ b/pluginapi/src/main/java/org/robolectric/pluginapi/UsesSdk.java
@@ -14,7 +14,7 @@ public interface UsesSdk {
    * Returns the Android SDK version that this package prefers to be run on, as specified in the
    * manifest.
    *
-   * Note that this value changes the behavior of some Android code (notably {@link
+   * <p>Note that this value changes the behavior of some Android code (notably {@link
    * android.content.SharedPreferences}) to emulate old bugs.
    *
    * @return the target SDK version
diff --git a/pluginapi/src/main/java/org/robolectric/pluginapi/config/Configurer.java b/pluginapi/src/main/java/org/robolectric/pluginapi/config/Configurer.java
index b51f32391..980ed5a9e 100644
--- a/pluginapi/src/main/java/org/robolectric/pluginapi/config/Configurer.java
+++ b/pluginapi/src/main/java/org/robolectric/pluginapi/config/Configurer.java
@@ -46,7 +46,8 @@ public interface Configurer<T> {
   /**
    * Returns the default configuration for tests that do not specify a configuration of this type.
    */
-  @Nonnull T defaultConfig();
+  @Nonnull
+  T defaultConfig();
 
   /**
    * Returns the configuration for a given package.
@@ -84,12 +85,13 @@ public interface Configurer<T> {
   /**
    * Merges two configurations.
    *
-   * This method will called whenever {@link #getConfigFor} returns a non-null configuration object.
+   * <p>This method will called whenever {@link #getConfigFor} returns a non-null configuration
+   * object.
    *
    * @param parentConfig a less specific configuration object
    * @param childConfig a more specific configuration object
    * @return the new configuration with merged parent and child data.
    */
-  @Nonnull T merge(@Nonnull T parentConfig, @Nonnull T childConfig);
-
+  @Nonnull
+  T merge(@Nonnull T parentConfig, @Nonnull T childConfig);
 }
diff --git a/pluginapi/src/main/java/org/robolectric/pluginapi/perf/Metadata.java b/pluginapi/src/main/java/org/robolectric/pluginapi/perf/Metadata.java
index 4d00de84b..27f856a45 100644
--- a/pluginapi/src/main/java/org/robolectric/pluginapi/perf/Metadata.java
+++ b/pluginapi/src/main/java/org/robolectric/pluginapi/perf/Metadata.java
@@ -3,9 +3,7 @@ package org.robolectric.pluginapi.perf;
 import java.util.HashMap;
 import java.util.Map;
 
-/**
- * Metadata for perf stats collection.
- */
+/** Metadata for perf stats collection. */
 public class Metadata {
   private final Map<Class<?>, Object> metadata;
 
diff --git a/pluginapi/src/main/java/org/robolectric/pluginapi/perf/Metric.java b/pluginapi/src/main/java/org/robolectric/pluginapi/perf/Metric.java
index ec9a1ba2f..7e635e4cd 100644
--- a/pluginapi/src/main/java/org/robolectric/pluginapi/perf/Metric.java
+++ b/pluginapi/src/main/java/org/robolectric/pluginapi/perf/Metric.java
@@ -1,8 +1,6 @@
 package org.robolectric.pluginapi.perf;
 
-/**
- * Metric for perf stats collection.
- */
+/** Metric for perf stats collection. */
 public class Metric {
   private final String name;
   private int count;
@@ -91,12 +89,19 @@ public class Metric {
   @Override
   public String toString() {
     return "Metric{"
-        + "name='" + name + '\''
-        + ", count=" + count
-        + ", minNs=" + minNs
-        + ", maxNs=" + maxNs
-        + ", elapsedNs=" + elapsedNs
-        + ", success=" + success
+        + "name='"
+        + name
+        + '\''
+        + ", count="
+        + count
+        + ", minNs="
+        + minNs
+        + ", maxNs="
+        + maxNs
+        + ", elapsedNs="
+        + elapsedNs
+        + ", success="
+        + success
         + '}';
   }
 }
diff --git a/pluginapi/src/main/java/org/robolectric/pluginapi/perf/PerfStatsReporter.java b/pluginapi/src/main/java/org/robolectric/pluginapi/perf/PerfStatsReporter.java
index 4cc6da0ca..df02ea362 100644
--- a/pluginapi/src/main/java/org/robolectric/pluginapi/perf/PerfStatsReporter.java
+++ b/pluginapi/src/main/java/org/robolectric/pluginapi/perf/PerfStatsReporter.java
@@ -11,5 +11,4 @@ public interface PerfStatsReporter {
    * @param metrics the metrics.
    */
   void report(Metadata metadata, Collection<Metric> metrics);
-
 }
diff --git a/pluginapi/src/test/java/org/robolectric/internal/dependency/DependencyJarTest.java b/pluginapi/src/test/java/org/robolectric/internal/dependency/DependencyJarTest.java
index 039ccbaa0..08074cd88 100644
--- a/pluginapi/src/test/java/org/robolectric/internal/dependency/DependencyJarTest.java
+++ b/pluginapi/src/test/java/org/robolectric/internal/dependency/DependencyJarTest.java
@@ -15,4 +15,4 @@ public class DependencyJarTest {
     assertThat(new DependencyJar("com.group", "artifact", "1.3", "dll").getShortName())
         .isEqualTo("com.group:artifact:1.3:dll");
   }
-}
\ No newline at end of file
+}
diff --git a/plugins/maven-dependency-resolver/build.gradle b/plugins/maven-dependency-resolver/build.gradle
index acbff55b6..4f23a8368 100644
--- a/plugins/maven-dependency-resolver/build.gradle
+++ b/plugins/maven-dependency-resolver/build.gradle
@@ -1,17 +1,11 @@
 import org.jetbrains.kotlin.gradle.dsl.JvmTarget
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
 
-apply plugin: RoboJavaModulePlugin
-apply plugin: DeployedRoboJavaModulePlugin
-apply plugin: 'kotlin'
-apply plugin: "com.diffplug.spotless"
-
-spotless {
-    kotlin {
-        target '**/*.kt'
-        ktfmt('0.42').googleStyle()
-    }
+plugins {
+    alias(libs.plugins.detekt)
+    alias(libs.plugins.kotlin.jvm)
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+    alias(libs.plugins.robolectric.spotless)
 }
 
 tasks.withType(GenerateModuleMetadata).configureEach {
diff --git a/plugins/maven-dependency-resolver/src/main/java/org/robolectric/MavenRoboSettings.java b/plugins/maven-dependency-resolver/src/main/java/org/robolectric/MavenRoboSettings.java
index 0c8d0697c..db0109078 100644
--- a/plugins/maven-dependency-resolver/src/main/java/org/robolectric/MavenRoboSettings.java
+++ b/plugins/maven-dependency-resolver/src/main/java/org/robolectric/MavenRoboSettings.java
@@ -1,7 +1,8 @@
 package org.robolectric;
 
 /**
- * Class that encapsulates reading global configuration options from the Java system properties file.
+ * Class that encapsulates reading global configuration options from the Java system properties
+ * file.
  *
  * @deprecated Don't put more stuff here.
  */
diff --git a/plugins/maven-dependency-resolver/src/main/java/org/robolectric/internal/dependency/MavenDependencyResolver.java b/plugins/maven-dependency-resolver/src/main/java/org/robolectric/internal/dependency/MavenDependencyResolver.java
index 91d2af75e..940295a3b 100644
--- a/plugins/maven-dependency-resolver/src/main/java/org/robolectric/internal/dependency/MavenDependencyResolver.java
+++ b/plugins/maven-dependency-resolver/src/main/java/org/robolectric/internal/dependency/MavenDependencyResolver.java
@@ -79,8 +79,9 @@ public class MavenDependencyResolver implements DependencyResolver {
   }
 
   /**
-   * Get an array of local artifact URLs for the given dependencies. The order of the URLs is guaranteed to be the
-   * same as the input order of dependencies, i.e., urls[i] is the local artifact URL for dependencies[i].
+   * Get an array of local artifact URLs for the given dependencies. The order of the URLs is
+   * guaranteed to be the same as the input order of dependencies, i.e., urls[i] is the local
+   * artifact URL for dependencies[i].
    */
   @SuppressWarnings("NewApi")
   public URL[] getLocalArtifactUrls(DependencyJar... dependencies) {
diff --git a/plugins/maven-dependency-resolver/src/test/java/org/robolectric/MavenRoboSettingsTest.kt b/plugins/maven-dependency-resolver/src/test/java/org/robolectric/MavenRoboSettingsTest.kt
index da7d56ac9..befa73091 100644
--- a/plugins/maven-dependency-resolver/src/test/java/org/robolectric/MavenRoboSettingsTest.kt
+++ b/plugins/maven-dependency-resolver/src/test/java/org/robolectric/MavenRoboSettingsTest.kt
@@ -15,6 +15,7 @@ class MavenRoboSettingsTest {
   private var originalMavenRepositoryPassword: String? = null
   private var originalMavenRepositoryProxyHost: String? = null
   private var originalMavenProxyPort = 0
+
   @Before
   fun setUp() {
     originalMavenRepositoryId = MavenRoboSettings.getMavenRepositoryId()
diff --git a/plugins/maven-dependency-resolver/src/test/java/org/robolectric/internal/dependency/MavenDependencyResolverTest.kt b/plugins/maven-dependency-resolver/src/test/java/org/robolectric/internal/dependency/MavenDependencyResolverTest.kt
index 1f5c3f836..4b9c5c8b9 100644
--- a/plugins/maven-dependency-resolver/src/test/java/org/robolectric/internal/dependency/MavenDependencyResolverTest.kt
+++ b/plugins/maven-dependency-resolver/src/test/java/org/robolectric/internal/dependency/MavenDependencyResolverTest.kt
@@ -39,7 +39,7 @@ class MavenDependencyResolverTest {
         PROXY_HOST,
         PROXY_PORT,
         localRepositoryDir,
-        executorService
+        executorService,
       )
     mavenDependencyResolver = TestMavenDependencyResolver()
   }
@@ -151,7 +151,7 @@ class MavenDependencyResolverTest {
       proxyHost: String?,
       proxyPort: Int,
       localRepositoryDir: File,
-      executorService: ExecutorService
+      executorService: ExecutorService,
     ): MavenArtifactFetcher {
       return mavenArtifactFetcher
     }
@@ -169,6 +169,7 @@ class MavenDependencyResolverTest {
     }
   }
 
+  @Suppress("LongParameterList")
   internal class TestMavenArtifactFetcher(
     repositoryUrl: String?,
     repositoryUserName: String?,
@@ -176,7 +177,7 @@ class MavenDependencyResolverTest {
     proxyHost: String?,
     proxyPort: Int,
     localRepositoryDir: File,
-    private val executorService: ExecutorService
+    private val executorService: ExecutorService,
   ) :
     MavenArtifactFetcher(
       repositoryUrl,
@@ -185,7 +186,7 @@ class MavenDependencyResolverTest {
       proxyHost,
       proxyPort,
       localRepositoryDir,
-      executorService
+      executorService,
     ) {
     var numRequests = 0
       private set
@@ -199,7 +200,7 @@ class MavenDependencyResolverTest {
             return super.call()
           }
         },
-        executorService
+        executorService,
       )
     }
   }
@@ -216,7 +217,7 @@ class MavenDependencyResolverTest {
       arrayOf(
         DependencyJar("group", "artifact", "1"),
         DependencyJar("org.group2", "artifact2-name", "2.4.5"),
-        DependencyJar("org.robolectric", "android-all", "10-robolectric-5803371")
+        DependencyJar("org.robolectric", "android-all", "10-robolectric-5803371"),
       )
 
     init {
@@ -240,20 +241,20 @@ class MavenDependencyResolverTest {
         val jarContents = "$mavenJarArtifact jar contents"
         Files.write(
           jarContents.toByteArray(StandardCharsets.UTF_8),
-          File(REPOSITORY_DIR, mavenJarArtifact.jarPath())
+          File(REPOSITORY_DIR, mavenJarArtifact.jarPath()),
         )
         Files.write(
           sha512(jarContents).toByteArray(),
-          File(REPOSITORY_DIR, mavenJarArtifact.jarSha512Path())
+          File(REPOSITORY_DIR, mavenJarArtifact.jarSha512Path()),
         )
         val pomContents = "$mavenJarArtifact pom contents"
         Files.write(
           pomContents.toByteArray(StandardCharsets.UTF_8),
-          File(REPOSITORY_DIR, mavenJarArtifact.pomPath())
+          File(REPOSITORY_DIR, mavenJarArtifact.pomPath()),
         )
         Files.write(
           sha512(pomContents).toByteArray(),
-          File(REPOSITORY_DIR, mavenJarArtifact.pomSha512Path())
+          File(REPOSITORY_DIR, mavenJarArtifact.pomSha512Path()),
         )
       } catch (e: MalformedURLException) {
         throw AssertionError(e)
@@ -269,13 +270,13 @@ class MavenDependencyResolverTest {
         Files.write(jarContents.toByteArray(), File(REPOSITORY_DIR, mavenJarArtifact.jarPath()))
         Files.write(
           sha512("No the same content").toByteArray(),
-          File(REPOSITORY_DIR, mavenJarArtifact.jarSha512Path())
+          File(REPOSITORY_DIR, mavenJarArtifact.jarSha512Path()),
         )
         val pomContents = "$mavenJarArtifact pom contents"
         Files.write(pomContents.toByteArray(), File(REPOSITORY_DIR, mavenJarArtifact.pomPath()))
         Files.write(
           sha512("Really not the same content").toByteArray(),
-          File(REPOSITORY_DIR, mavenJarArtifact.pomSha512Path())
+          File(REPOSITORY_DIR, mavenJarArtifact.pomSha512Path()),
         )
       } catch (e: MalformedURLException) {
         throw AssertionError(e)
diff --git a/preinstrumented/build.gradle b/preinstrumented/build.gradle
index 8e6481622..a24212320 100644
--- a/preinstrumented/build.gradle
+++ b/preinstrumented/build.gradle
@@ -1,7 +1,7 @@
 plugins {
-    id "application"
+    alias(libs.plugins.application)
+    alias(libs.plugins.java)
 }
-apply plugin: 'java'
 
 ext {
     javaMainClass = "org.robolectric.preinstrumented.JarInstrumentor"
@@ -65,7 +65,7 @@ if (System.getenv('PUBLISH_PREINSTRUMENTED_JARS') == "true") {
         publications {
             sdksToInstrument().each { androidSdk ->
                 "sdk${androidSdk.apiLevel}"(MavenPublication) {
-                    artifact = layout.buildDirectory.file(androidSdk.preinstrumentedJarFileName).get().asFile.path
+                    artifact layout.buildDirectory.file(androidSdk.preinstrumentedJarFileName).get().asFile.path
                     artifactId 'android-all-instrumented'
                     artifact emptySourcesJar
                     artifact emptyJavadocJar
@@ -113,6 +113,8 @@ if (System.getenv('PUBLISH_PREINSTRUMENTED_JARS') == "true") {
     }
 
     signing {
+        // Skip signing if a signing key is not configured.
+        required { project.hasProperty("signing.keyId") }
         sdksToInstrument().each { androidSdk ->
             sign publishing.publications."sdk${androidSdk.apiLevel}"
         }
diff --git a/processor/build.gradle b/processor/build.gradle
index e462cd881..d5897d019 100644
--- a/processor/build.gradle
+++ b/processor/build.gradle
@@ -1,9 +1,9 @@
 import org.gradle.internal.jvm.Jvm
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
 
-apply plugin: RoboJavaModulePlugin
-apply plugin: DeployedRoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+}
 
 class GenerateSdksFileTask extends DefaultTask {
     @OutputFile
diff --git a/processor/src/main/java/org/robolectric/annotation/processing/RobolectricProcessor.java b/processor/src/main/java/org/robolectric/annotation/processing/RobolectricProcessor.java
index b82622885..a5ec0e18d 100644
--- a/processor/src/main/java/org/robolectric/annotation/processing/RobolectricProcessor.java
+++ b/processor/src/main/java/org/robolectric/annotation/processing/RobolectricProcessor.java
@@ -42,6 +42,8 @@ public class RobolectricProcessor extends AbstractProcessor {
   static final String JSON_DOCS_ENABLED = "org.robolectric.annotation.processing.jsonDocsEnabled";
   static final String SDK_CHECK_MODE = "org.robolectric.annotation.processing.sdkCheckMode";
   private static final String SDKS_FILE = "org.robolectric.annotation.processing.sdks";
+  private static final String DISABLE_INDEVELOPMENT =
+      "org.robolectric.annotation.processing.disableInDevelopment";
 
   /** required for Android Development. */
   private static final String VALIDATE_COMPILE_SDKS =
@@ -62,6 +64,7 @@ public class RobolectricProcessor extends AbstractProcessor {
   private File jsonDocsDir;
   private boolean jsonDocsEnabled;
   private boolean validateCompiledSdk;
+  private boolean allowInDev;
   private String overrideSdkLocation;
   private int overrideSdkInt;
 
@@ -97,7 +100,8 @@ public class RobolectricProcessor extends AbstractProcessor {
         new SdkStore(sdksFile, validateCompiledSdk, overrideSdkLocation, overrideSdkInt);
 
     addValidator(new ImplementationValidator(modelBuilder, environment));
-    addValidator(new ImplementsValidator(modelBuilder, environment, sdkCheckMode, sdkStore));
+    addValidator(
+        new ImplementsValidator(modelBuilder, environment, sdkCheckMode, sdkStore, allowInDev));
     addValidator(new RealObjectValidator(modelBuilder, environment));
     addValidator(new ResetterValidator(modelBuilder, environment));
   }
@@ -150,7 +154,8 @@ public class RobolectricProcessor extends AbstractProcessor {
           "true".equalsIgnoreCase(options.getOrDefault(VALIDATE_COMPILE_SDKS, "false"));
       this.sdksFile = getSdksFile(options, SDKS_FILE);
       this.priority = Integer.parseInt(options.getOrDefault(PRIORITY, "0"));
-
+      this.allowInDev =
+          !"true".equalsIgnoreCase(options.getOrDefault(DISABLE_INDEVELOPMENT, "false"));
       if (this.shadowPackage == null) {
         throw new IllegalArgumentException("no package specified for " + PACKAGE_OPT);
       }
diff --git a/processor/src/main/java/org/robolectric/annotation/processing/validator/ImplementsValidator.java b/processor/src/main/java/org/robolectric/annotation/processing/validator/ImplementsValidator.java
index 68482ec95..e10b0d044 100644
--- a/processor/src/main/java/org/robolectric/annotation/processing/validator/ImplementsValidator.java
+++ b/processor/src/main/java/org/robolectric/annotation/processing/validator/ImplementsValidator.java
@@ -44,6 +44,7 @@ public class ImplementsValidator extends Validator {
   private final SdkCheckMode sdkCheckMode;
   private final Kind checkKind;
   private final SdkStore sdkStore;
+  private final boolean allowInDev;
 
   /** Supported modes for validation of {@link Implementation} methods against SDKs. */
   public enum SdkCheckMode {
@@ -56,13 +57,15 @@ public class ImplementsValidator extends Validator {
       RobolectricModel.Builder modelBuilder,
       ProcessingEnvironment env,
       SdkCheckMode sdkCheckMode,
-      SdkStore sdkStore) {
+      SdkStore sdkStore,
+      boolean allowInDev) {
     super(modelBuilder, env, IMPLEMENTS_CLASS);
 
     this.env = env;
     this.sdkCheckMode = sdkCheckMode;
     this.checkKind = sdkCheckMode == SdkCheckMode.WARN ? Kind.WARNING : Kind.ERROR;
     this.sdkStore = sdkStore;
+    this.allowInDev = allowInDev;
   }
 
   private TypeElement getClassNameTypeElement(AnnotationValue cv) {
@@ -146,7 +149,7 @@ public class ImplementsValidator extends Validator {
     boolean looseSignatures =
         looseSignaturesAttr != null && (Boolean) looseSignaturesAttr.getValue();
     String sdkClassNameFq = sdkClassNameFq(av, cv);
-    validateShadow(sdkClassNameFq, shadowType, minSdk, maxSdk, looseSignatures);
+    validateShadow(sdkClassNameFq, shadowType, minSdk, maxSdk, looseSignatures, allowInDev);
 
     return null;
   }
@@ -196,13 +199,15 @@ public class ImplementsValidator extends Validator {
       TypeElement shadowClassElem,
       int classMinSdk,
       int classMaxSdk,
-      boolean looseSignatures) {
+      boolean looseSignatures,
+      boolean allowInDev) {
     Problems problems = new Problems(this.checkKind);
     if (sdkCheckMode != SdkCheckMode.OFF) {
       for (SdkStore.Sdk sdk : sdkStore.sdksMatching(classMinSdk, classMaxSdk)) {
         SdkStore.ClassInfo classInfo = sdk.getClassInfo(shadowedClassName);
         if (classInfo == null) {
-          if (!sdk.suppressWarnings(shadowClassElem, "robolectric.internal.IgnoreMissingClass")) {
+          if (!sdk.suppressWarnings(
+              shadowClassElem, "robolectric.internal.IgnoreMissingClass", allowInDev)) {
             problems.add("Shadowed type is not found: " + shadowedClassName, sdk.sdkInt);
           }
         } else {
@@ -210,7 +215,7 @@ public class ImplementsValidator extends Validator {
           helpers.appendParameterList(builder, shadowClassElem.getTypeParameters());
           String shadowParams = builder.toString();
           if (!classInfo.getSignature().equals(shadowParams)
-              && !sdk.suppressWarnings(shadowClassElem, "robolectric.mismatchedTypes")
+              && !sdk.suppressWarnings(shadowClassElem, "robolectric.mismatchedTypes", allowInDev)
               && !looseSignatures) {
             problems.add(
                 "Shadow type is mismatched, expected "
@@ -265,7 +270,7 @@ public class ImplementsValidator extends Validator {
       Problems problems = new Problems(this.checkKind);
 
       for (SdkStore.Sdk sdk : sdkStore.sdksMatching(implementation, classMinSdk, classMaxSdk)) {
-        String problem = sdk.verifyMethod(sdkClassName, methodElement, looseSignatures);
+        String problem = sdk.verifyMethod(sdkClassName, methodElement, looseSignatures, allowInDev);
         if (problem != null) {
           problems.add(problem, sdk.sdkInt);
         }
@@ -298,7 +303,7 @@ public class ImplementsValidator extends Validator {
       Problems problems = new Problems(kind);
 
       for (SdkStore.Sdk sdk : sdkStore.sdksMatching(implementation, classMinSdk, classMaxSdk)) {
-        String problem = sdk.verifyMethod(sdkClassName, methodElement, looseSignatures);
+        String problem = sdk.verifyMethod(sdkClassName, methodElement, looseSignatures, allowInDev);
         if (problem == null && sdk.getClassInfo(sdkClassName) != null) {
           problems.add(
               "Missing @Implementation on method " + methodElement.getSimpleName(), sdk.sdkInt);
diff --git a/processor/src/main/java/org/robolectric/annotation/processing/validator/SdkStore.java b/processor/src/main/java/org/robolectric/annotation/processing/validator/SdkStore.java
index 6fb0f6b92..8b5273ab5 100644
--- a/processor/src/main/java/org/robolectric/annotation/processing/validator/SdkStore.java
+++ b/processor/src/main/java/org/robolectric/annotation/processing/validator/SdkStore.java
@@ -31,6 +31,8 @@ import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 import java.util.zip.ZipEntry;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
@@ -45,6 +47,7 @@ import org.objectweb.asm.signature.SignatureReader;
 import org.objectweb.asm.tree.ClassNode;
 import org.objectweb.asm.tree.MethodNode;
 import org.objectweb.asm.util.TraceSignatureVisitor;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.InDevelopment;
 import org.robolectric.versioning.AndroidVersionInitTools;
@@ -277,22 +280,27 @@ public class SdkStore {
      * @return a string describing any problems with this method, or null if it checks out.
      */
     public String verifyMethod(
-        String sdkClassName, ExecutableElement methodElement, boolean looseSignatures) {
+        String sdkClassName,
+        ExecutableElement methodElement,
+        boolean looseSignatures,
+        boolean allowInDev) {
       ClassInfo classInfo = getClassInfo(sdkClassName);
 
       // Probably should not be reachable
-      if (classInfo == null && !suppressWarnings(methodElement.getEnclosingElement(), null)) {
+      if (classInfo == null
+          && !suppressWarnings(methodElement.getEnclosingElement(), null, allowInDev)) {
         return null;
       }
 
       MethodExtraInfo sdkMethod = classInfo.findMethod(methodElement, looseSignatures);
-      if (sdkMethod == null && !suppressWarnings(methodElement, null)) {
-        return "No such method in " + sdkClassName;
+      if (sdkMethod == null && !suppressWarnings(methodElement, null, allowInDev)) {
+        return "No method " + methodElement + " in " + sdkClassName;
       }
       if (sdkMethod != null) {
         MethodExtraInfo implMethod = new MethodExtraInfo(methodElement);
         if (!sdkMethod.equals(implMethod)
-            && !suppressWarnings(methodElement, "robolectric.ShadowReturnTypeMismatch")) {
+            && !suppressWarnings(
+                methodElement, "robolectric.ShadowReturnTypeMismatch", allowInDev)) {
           if (implMethod.isStatic != sdkMethod.isStatic) {
             return "@Implementation for "
                 + methodElement.getSimpleName()
@@ -329,7 +337,7 @@ public class SdkStore {
      * @param warningName the name of the warning, if null, @InDevelopment will still be honored.
      * @return true if the warning should be suppressed, else false
      */
-    boolean suppressWarnings(Element annotatedElement, String warningName) {
+    boolean suppressWarnings(Element annotatedElement, String warningName, boolean allowInDev) {
       SuppressWarnings[] suppressWarnings =
           annotatedElement.getAnnotationsByType(SuppressWarnings.class);
       for (SuppressWarnings suppression : suppressWarnings) {
@@ -340,7 +348,15 @@ public class SdkStore {
         }
       }
       InDevelopment[] inDev = annotatedElement.getAnnotationsByType(InDevelopment.class);
-      if (inDev.length > 0 && !sdkRelease.isReleased()) {
+      // Marked in development, sdk is not released, or is the last release (which may still be
+      // marked unreleased in g/main aosp/main.
+      if (allowInDev
+          && inDev.length > 0
+          && (!sdkRelease.isReleased()
+              || sdkRelease
+                  == AndroidVersions.getReleases().stream()
+                      .max(AndroidVersions.AndroidRelease::compareTo)
+                      .get())) {
         return true;
       }
       return false;
@@ -411,21 +427,22 @@ public class SdkStore {
         tempFile.deleteOnExit();
         tempDir = tempFile.getParentFile();
       }
-      InputStream jarIn = SdkStore.class.getClassLoader().getResourceAsStream(resourcePath);
-      if (jarIn == null) {
-        throw new RuntimeException("SDK " + resourcePath + " not found");
-      }
-      File outFile = new File(tempDir, new File(resourcePath).getName());
-      outFile.deleteOnExit();
-      try (FileOutputStream jarOut = new FileOutputStream(outFile)) {
-        byte[] buffer = new byte[4096];
-        int len;
-        while ((len = jarIn.read(buffer)) != -1) {
-          jarOut.write(buffer, 0, len);
+      try (InputStream jarIn = SdkStore.class.getClassLoader().getResourceAsStream(resourcePath)) {
+        if (jarIn == null) {
+          throw new RuntimeException("SDK " + resourcePath + " not found");
+        }
+        File outFile = new File(tempDir, new File(resourcePath).getName());
+        outFile.deleteOnExit();
+        try (FileOutputStream jarOut = new FileOutputStream(outFile)) {
+          byte[] buffer = new byte[4096];
+          int len;
+          while ((len = jarIn.read(buffer)) != -1) {
+            jarOut.write(buffer, 0, len);
+          }
         }
-      }
 
-      return outFile;
+        return outFile;
+      }
     }
 
     private ClassNode loadClassNode(String name) {
@@ -574,6 +591,25 @@ public class SdkStore {
       for (VariableElement variableElement : methodElement.getParameters()) {
         TypeMirror varTypeMirror = variableElement.asType();
         String paramType = canonicalize(varTypeMirror);
+
+        // If parameter is annotated with @ClassName, then use the indicated type instead.
+        List<? extends AnnotationMirror> annotationMirrors = variableElement.getAnnotationMirrors();
+        for (AnnotationMirror am : annotationMirrors) {
+          if (am.getAnnotationType().toString().equals(ClassName.class.getName())) {
+            Map<? extends ExecutableElement, ? extends AnnotationValue> annotationEntries =
+                am.getElementValues();
+            Set<? extends ExecutableElement> keys = annotationEntries.keySet();
+            for (ExecutableElement key : keys) {
+              if ("value()".equals(key.toString())) {
+                AnnotationValue annotationValue = annotationEntries.get(key);
+                paramType = annotationValue.getValue().toString().replace('$', '.');
+                break;
+              }
+            }
+            break;
+          }
+        }
+
         String paramTypeWithoutGenerics = typeWithoutGenerics(paramType);
         paramTypes.add(paramTypeWithoutGenerics);
       }
@@ -586,7 +622,14 @@ public class SdkStore {
       } else if (STATIC_INITIALIZER_METHOD_NAME.equals(name)) {
         return "<clinit>";
       } else {
-        return name;
+        Implementation implementation = methodElement.getAnnotation(Implementation.class);
+        String methodName = implementation == null ? "" : implementation.methodName();
+        methodName = methodName == null ? "" : methodName.trim();
+        if (methodName.isEmpty()) {
+          return name;
+        } else {
+          return methodName;
+        }
       }
     }
 
diff --git a/processor/src/test/java/org/robolectric/annotation/processing/validator/InDevelopmentValidatorTest.java b/processor/src/test/java/org/robolectric/annotation/processing/validator/InDevelopmentValidatorTest.java
index 6e3581357..5180a6ef5 100644
--- a/processor/src/test/java/org/robolectric/annotation/processing/validator/InDevelopmentValidatorTest.java
+++ b/processor/src/test/java/org/robolectric/annotation/processing/validator/InDevelopmentValidatorTest.java
@@ -42,7 +42,9 @@ public final class InDevelopmentValidatorTest {
   @Test
   public void implementationWithInDevelopmentCompiles() {
     AndroidVersions.AndroidRelease unreleased =
-        AndroidVersions.getUnreleased().stream().findFirst().get();
+        AndroidVersions.getUnreleased().stream()
+            .min(AndroidVersions.AndroidRelease::compareTo)
+            .get();
     final String testClass =
         "org.robolectric.annotation.processing.shadows.ShadowImplementsInDevelopment";
     HashMap<String, String> props = new HashMap<>();
@@ -53,10 +55,49 @@ public final class InDevelopmentValidatorTest {
         .compilesWithoutError();
   }
 
+  @Test
+  public void implementationWithInDevelopmentFailsToCompilesOnLastReleaseDisableInDevelopment() {
+    AndroidVersions.AndroidRelease lastRelease =
+        AndroidVersions.getReleases().stream().max(AndroidVersions.AndroidRelease::compareTo).get();
+    final String testClass =
+        "org.robolectric.annotation.processing.shadows.ShadowImplementsInDevelopment";
+    HashMap<String, String> props = new HashMap<>();
+    props.put("org.robolectric.annotation.processing.sdkCheckMode", "ERROR");
+    props.put("org.robolectric.annotation.processing.disableInDevelopment", "true");
+    props.put("org.robolectric.annotation.processing.validateCompileSdk", "true");
+    assertAbout(singleClass(props, getClassRootDir(Dummy.class), lastRelease.getSdkInt()))
+        .that(testClass)
+        .failsToCompile()
+        .withErrorContaining(
+            "No method doSomething() in com.example.objects.Dummy for SDK "
+                + lastRelease.getSdkInt())
+        .onLine(13);
+  }
+
   @Test
   public void implementationWithoutInDevelopmentFailsToCompiles() {
     AndroidVersions.AndroidRelease unreleased =
-        AndroidVersions.getUnreleased().stream().findFirst().get();
+        AndroidVersions.getUnreleased().stream()
+            .min(AndroidVersions.AndroidRelease::compareTo)
+            .get();
+    final String testClass =
+        "org.robolectric.annotation.processing.shadows.ShadowImplementsInDevelopmentMissing";
+    HashMap<String, String> props = new HashMap<>();
+    props.put("org.robolectric.annotation.processing.sdkCheckMode", "ERROR");
+    props.put("org.robolectric.annotation.processing.validateCompileSdk", "true");
+    assertAbout(singleClass(props, getClassRootDir(Dummy.class), unreleased.getSdkInt()))
+        .that(testClass)
+        .failsToCompile()
+        .withErrorContaining(
+            "No method doSomething() in com.example.objects.Dummy for SDK "
+                + unreleased.getSdkInt())
+        .onLine(11);
+  }
+
+  @Test
+  public void implementationWithoutInDevelopmentFailsToCompilesLastRelease() {
+    AndroidVersions.AndroidRelease unreleased =
+        AndroidVersions.getReleases().stream().min(AndroidVersions.AndroidRelease::compareTo).get();
     final String testClass =
         "org.robolectric.annotation.processing.shadows.ShadowImplementsInDevelopmentMissing";
     HashMap<String, String> props = new HashMap<>();
@@ -65,7 +106,9 @@ public final class InDevelopmentValidatorTest {
     assertAbout(singleClass(props, getClassRootDir(Dummy.class), unreleased.getSdkInt()))
         .that(testClass)
         .failsToCompile()
-        .withErrorContaining("No such method in com.example.objects.Dummy for SDK 35")
+        .withErrorContaining(
+            "No method doSomething() in com.example.objects.Dummy for SDK "
+                + unreleased.getSdkInt())
         .onLine(11);
   }
 }
diff --git a/resources/build.gradle b/resources/build.gradle
index 06a43247f..4c0ee24ae 100644
--- a/resources/build.gradle
+++ b/resources/build.gradle
@@ -1,8 +1,7 @@
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
-apply plugin: DeployedRoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+}
 
 dependencies {
     api project(":utils")
diff --git a/resources/src/main/java/org/robolectric/RoboSettings.java b/resources/src/main/java/org/robolectric/RoboSettings.java
index 80dbe21bb..cf7954bfe 100644
--- a/resources/src/main/java/org/robolectric/RoboSettings.java
+++ b/resources/src/main/java/org/robolectric/RoboSettings.java
@@ -1,7 +1,8 @@
 package org.robolectric;
 
 /**
- * Class that encapsulates reading global configuration options from the Java system properties file.
+ * Class that encapsulates reading global configuration options from the Java system properties
+ * file.
  *
  * @deprecated Don't put more stuff here.
  */
diff --git a/resources/src/main/java/org/robolectric/manifest/ActivityData.java b/resources/src/main/java/org/robolectric/manifest/ActivityData.java
index 0da5d19b2..fcdcc7adc 100644
--- a/resources/src/main/java/org/robolectric/manifest/ActivityData.java
+++ b/resources/src/main/java/org/robolectric/manifest/ActivityData.java
@@ -36,22 +36,26 @@ public class ActivityData {
   // Non-null only for activity-alias'es.
   private final ActivityData targetActivity;
 
-  /**
-   * XML Namespace used for android.
-   */
+  /** XML Namespace used for android. */
   private final String xmlns;
+
   private final MetaData metaData;
 
   public ActivityData(Map<String, String> attrMap, List<IntentFilterData> intentFilters) {
     this("android", attrMap, intentFilters);
   }
 
-  public ActivityData(String xmlns, Map<String, String> attrMap, List<IntentFilterData> intentFilters) {
+  public ActivityData(
+      String xmlns, Map<String, String> attrMap, List<IntentFilterData> intentFilters) {
     this(xmlns, attrMap, intentFilters, null, null);
   }
 
-  public ActivityData(String xmlns, Map<String, String> attrMap, List<IntentFilterData> intentFilters,
-      ActivityData targetActivity, MetaData metaData) {
+  public ActivityData(
+      String xmlns,
+      Map<String, String> attrMap,
+      List<IntentFilterData> intentFilters,
+      ActivityData targetActivity,
+      MetaData metaData) {
     this.xmlns = xmlns;
     attrs = new HashMap<>();
     attrs.putAll(attrMap);
@@ -165,7 +169,7 @@ public class ActivityData {
   }
 
   private boolean getBooleanAttr(String n, boolean defaultValue) {
-    return (attrs.containsKey(n) ? Boolean.parseBoolean(attrs.get(n)): defaultValue);
+    return (attrs.containsKey(n) ? Boolean.parseBoolean(attrs.get(n)) : defaultValue);
   }
 
   private String withXMLNS(String attr) {
@@ -174,6 +178,7 @@ public class ActivityData {
 
   /**
    * Get the map for all attributes defined for the activity XML.
+   *
    * @return map of attributes names to values from the manifest. Not null.
    */
   public Map<String, String> getAllAttributes() {
@@ -182,6 +187,7 @@ public class ActivityData {
 
   /**
    * Get the intent filters defined for activity.
+   *
    * @return A list of intent filters. Not null.
    */
   public List<IntentFilterData> getIntentFilters() {
diff --git a/resources/src/main/java/org/robolectric/manifest/AndroidManifest.java b/resources/src/main/java/org/robolectric/manifest/AndroidManifest.java
index aab424ed1..1a4f7e0d7 100644
--- a/resources/src/main/java/org/robolectric/manifest/AndroidManifest.java
+++ b/resources/src/main/java/org/robolectric/manifest/AndroidManifest.java
@@ -12,6 +12,7 @@ import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
@@ -92,7 +93,12 @@ public class AndroidManifest implements UsesSdk {
       Path resDirectory,
       Path assetsDirectory,
       String overridePackageName) {
-    this(androidManifestFile, resDirectory, assetsDirectory, Collections.emptyList(), overridePackageName);
+    this(
+        androidManifestFile,
+        resDirectory,
+        assetsDirectory,
+        Collections.emptyList(),
+        overridePackageName);
   }
 
   /**
@@ -310,13 +316,13 @@ public class AndroidManifest implements UsesSdk {
 
       List<PathPermissionData> pathPermissionDatas = new ArrayList<>();
       for (Node node : getChildrenTags(contentProviderNode, "path-permission")) {
-        pathPermissionDatas.add(new PathPermissionData(
+        pathPermissionDatas.add(
+            new PathPermissionData(
                 getAttributeValue(node, "android:path"),
                 getAttributeValue(node, "android:pathPrefix"),
                 getAttributeValue(node, "android:pathPattern"),
                 getAttributeValue(node, "android:readPermission"),
-                getAttributeValue(node, "android:writePermission")
-        ));
+                getAttributeValue(node, "android:writePermission")));
       }
 
       providers.add(
@@ -448,7 +454,7 @@ public class AndroidManifest implements UsesSdk {
     for (Node n : getChildrenTags(activityNode, "intent-filter")) {
       ArrayList<String> actionNames = new ArrayList<>();
       ArrayList<String> categories = new ArrayList<>();
-      //should only be one action.
+      // should only be one action.
       for (Node action : getChildrenTags(n, "action")) {
         NamedNodeMap attributes = action.getAttributes();
         Node actionNameNode = attributes.getNamedItem("android:name");
@@ -471,7 +477,8 @@ public class AndroidManifest implements UsesSdk {
     return intentFilterDatas;
   }
 
-  private IntentFilterData parseIntentFilterData(final Node intentFilterNode, IntentFilterData intentFilterData) {
+  private IntentFilterData parseIntentFilterData(
+      final Node intentFilterNode, IntentFilterData intentFilterData) {
     for (Node n : getChildrenTags(intentFilterNode, "data")) {
       NamedNodeMap attributes = n.getAttributes();
       String host = null;
@@ -562,11 +569,13 @@ public class AndroidManifest implements UsesSdk {
     return children;
   }
 
-  private Integer getTagAttributeIntValue(final Document doc, final String tag, final String attribute) {
+  private Integer getTagAttributeIntValue(
+      final Document doc, final String tag, final String attribute) {
     return getTagAttributeIntValue(doc, tag, attribute, null);
   }
 
-  private Integer getTagAttributeIntValue(final Document doc, final String tag, final String attribute, final Integer defaultValue) {
+  private Integer getTagAttributeIntValue(
+      final Document doc, final String tag, final String attribute, final Integer defaultValue) {
     String valueString = getTagAttributeText(doc, tag, attribute);
     if (valueString != null) {
       return Integer.parseInt(valueString);
@@ -666,7 +675,8 @@ public class AndroidManifest implements UsesSdk {
   }
 
   public List<ResourcePath> getIncludedResourcePaths() {
-    Collection<ResourcePath> resourcePaths = new LinkedHashSet<>(); // Needs stable ordering and no duplicates
+    Collection<ResourcePath> resourcePaths =
+        new LinkedHashSet<>(); // Needs stable ordering and no duplicates
     resourcePaths.add(getResourcePath());
     for (AndroidManifest libraryManifest : getLibraryManifests()) {
       resourcePaths.addAll(libraryManifest.getIncludedResourcePaths());
@@ -680,7 +690,7 @@ public class AndroidManifest implements UsesSdk {
   }
 
   public List<AndroidManifest> getLibraryManifests() {
-    assert(libraryManifests != null);
+    assert (libraryManifests != null);
     return Collections.unmodifiableList(libraryManifests);
   }
 
@@ -731,7 +741,8 @@ public class AndroidManifest implements UsesSdk {
     return serviceDatas.get(serviceClassName);
   }
 
-  private static String getTagAttributeText(final Document doc, final String tag, final String attribute) {
+  private static String getTagAttributeText(
+      final Document doc, final String tag, final String attribute) {
     NodeList elementsByTagName = doc.getElementsByTagName(tag);
     for (int i = 0; i < elementsByTagName.getLength(); ++i) {
       Node item = elementsByTagName.item(i);
@@ -754,27 +765,22 @@ public class AndroidManifest implements UsesSdk {
 
     AndroidManifest that = (AndroidManifest) o;
 
-    if (androidManifestFile != null ? !androidManifestFile.equals(that.androidManifestFile)
-        : that.androidManifestFile != null) {
+    if (!Objects.equals(androidManifestFile, that.androidManifestFile)) {
       return false;
     }
-    if (resDirectory != null ? !resDirectory.equals(that.resDirectory)
-        : that.resDirectory != null) {
+    if (!Objects.equals(resDirectory, that.resDirectory)) {
       return false;
     }
-    if (assetsDirectory != null ? !assetsDirectory.equals(that.assetsDirectory)
-        : that.assetsDirectory != null) {
+    if (!Objects.equals(assetsDirectory, that.assetsDirectory)) {
       return false;
     }
-    if (overridePackageName != null ? !overridePackageName.equals(that.overridePackageName)
-        : that.overridePackageName != null) {
+    if (!Objects.equals(overridePackageName, that.overridePackageName)) {
       return false;
     }
-    if (libraryManifests != null ? !libraryManifests.equals(that.libraryManifests)
-        : that.libraryManifests != null) {
+    if (!Objects.equals(libraryManifests, that.libraryManifests)) {
       return false;
     }
-    return apkFile != null ? apkFile.equals(that.apkFile) : that.apkFile == null;
+    return Objects.equals(apkFile, that.apkFile);
   }
 
   @Override
@@ -847,9 +853,11 @@ public class AndroidManifest implements UsesSdk {
     return true;
   }
 
-  /** @deprecated Do not use. */
+  /**
+   * @deprecated Do not use.
+   */
   @Deprecated
-  synchronized public boolean supportsBinaryResourcesMode() {
+  public synchronized boolean supportsBinaryResourcesMode() {
     return true;
   }
 }
diff --git a/resources/src/main/java/org/robolectric/manifest/MetaData.java b/resources/src/main/java/org/robolectric/manifest/MetaData.java
index d6c85538a..0c7b33d0f 100644
--- a/resources/src/main/java/org/robolectric/manifest/MetaData.java
+++ b/resources/src/main/java/org/robolectric/manifest/MetaData.java
@@ -34,7 +34,7 @@ public final class MetaData {
 
   public void init(ResourceTable resourceTable, String packageName) throws RoboNotFoundException {
     if (!initialised) {
-      for (Map.Entry<String,VALUE_TYPE> entry : typeMap.entrySet()) {
+      for (Map.Entry<String, VALUE_TYPE> entry : typeMap.entrySet()) {
         String value = valueMap.get(entry.getKey()).toString();
         if (value.startsWith("@")) {
           ResName resName = ResName.qualifyResName(value.substring(1), packageName, null);
@@ -52,11 +52,14 @@ public final class MetaData {
                 throw new RoboNotFoundException(resName.getFullyQualifiedName());
               }
               switch (typedRes.getResType()) {
-                case BOOLEAN: case COLOR: case INTEGER: case FLOAT:
+                case BOOLEAN:
+                case COLOR:
+                case INTEGER:
+                case FLOAT:
                   valueMap.put(entry.getKey(), parseValue(typedRes.getData().toString()));
                   break;
                 default:
-                  valueMap.put(entry.getKey(),typedRes.getData());
+                  valueMap.put(entry.getKey(), typedRes.getData());
               }
               break;
           }
@@ -91,7 +94,7 @@ public final class MetaData {
       try {
         return getColor(value);
       } catch (NumberFormatException e) {
-            /* Not a color */
+        /* Not a color */
       }
     } else if (value.contains(".")) {
       // most likely a float
@@ -116,6 +119,7 @@ public final class MetaData {
   // todo: this is copied from ResourceHelper, dedupe
   /**
    * Returns the color value represented by the given string value
+   *
    * @param value the color value
    * @return the color as an int
    * @throws NumberFormatException if the conversion failed.
@@ -123,18 +127,18 @@ public final class MetaData {
   public static int getColor(String value) {
     if (value != null) {
       if (value.startsWith("#") == false) {
-        throw new NumberFormatException(
-            String.format("Color value '%s' must start with #", value));
+        throw new NumberFormatException(String.format("Color value '%s' must start with #", value));
       }
 
       value = value.substring(1);
 
       // make sure it's not longer than 32bit
       if (value.length() > 8) {
-        throw new NumberFormatException(String.format(
-            "Color value '%s' is too long. Format is either" +
-                "#AARRGGBB, #RRGGBB, #RGB, or #ARGB",
-            value));
+        throw new NumberFormatException(
+            String.format(
+                "Color value '%s' is too long. Format is either"
+                    + "#AARRGGBB, #RRGGBB, #RGB, or #ARGB",
+                value));
       }
 
       if (value.length() == 3) { // RGB format
@@ -160,10 +164,9 @@ public final class MetaData {
       // Integer.parseInt will fail to inferFromValue strings like "ff191919", so we use
       // a Long, but cast the result back into an int, since we know that we're only
       // dealing with 32 bit values.
-      return (int)Long.parseLong(value, 16);
+      return (int) Long.parseLong(value, 16);
     }
 
     throw new NumberFormatException();
   }
-
 }
diff --git a/resources/src/main/java/org/robolectric/manifest/PathPermissionData.java b/resources/src/main/java/org/robolectric/manifest/PathPermissionData.java
index 48820dbef..b0ea90cf7 100644
--- a/resources/src/main/java/org/robolectric/manifest/PathPermissionData.java
+++ b/resources/src/main/java/org/robolectric/manifest/PathPermissionData.java
@@ -7,7 +7,12 @@ public class PathPermissionData {
   public final String readPermission;
   public final String writePermission;
 
-  PathPermissionData(String path, String pathPrefix, String pathPattern, String readPermission, String writePermission) {
+  PathPermissionData(
+      String path,
+      String pathPrefix,
+      String pathPattern,
+      String readPermission,
+      String writePermission) {
     this.path = path;
     this.pathPrefix = pathPrefix;
     this.pathPattern = pathPattern;
diff --git a/resources/src/main/java/org/robolectric/manifest/PermissionGroupItemData.java b/resources/src/main/java/org/robolectric/manifest/PermissionGroupItemData.java
index eb678887e..cdc33f183 100644
--- a/resources/src/main/java/org/robolectric/manifest/PermissionGroupItemData.java
+++ b/resources/src/main/java/org/robolectric/manifest/PermissionGroupItemData.java
@@ -1,15 +1,12 @@
 package org.robolectric.manifest;
 
-/**
- * Holds permission data from manifest.
- */
+/** Holds permission data from manifest. */
 public class PermissionGroupItemData extends PackageItemData {
 
   private final String label;
   private final String description;
 
-  public PermissionGroupItemData(String name, String label, String description,
-      MetaData metaData) {
+  public PermissionGroupItemData(String name, String label, String description, MetaData metaData) {
     super(name, metaData);
 
     this.label = label;
diff --git a/resources/src/main/java/org/robolectric/manifest/PermissionItemData.java b/resources/src/main/java/org/robolectric/manifest/PermissionItemData.java
index 938dc1abb..c100f0fdf 100644
--- a/resources/src/main/java/org/robolectric/manifest/PermissionItemData.java
+++ b/resources/src/main/java/org/robolectric/manifest/PermissionItemData.java
@@ -1,8 +1,6 @@
 package org.robolectric.manifest;
 
-/**
- * Holds permission data from manifest.
- */
+/** Holds permission data from manifest. */
 public class PermissionItemData extends PackageItemData {
 
   private final String label;
@@ -10,8 +8,13 @@ public class PermissionItemData extends PackageItemData {
   private final String permissionGroup;
   private final String protectionLevel;
 
-  public PermissionItemData(String name, String label, String description,
-      String permissionGroup, String protectionLevel, MetaData metaData) {
+  public PermissionItemData(
+      String name,
+      String label,
+      String description,
+      String permissionGroup,
+      String protectionLevel,
+      MetaData metaData) {
     super(name, metaData);
 
     this.label = label;
diff --git a/resources/src/main/java/org/robolectric/manifest/ServiceData.java b/resources/src/main/java/org/robolectric/manifest/ServiceData.java
index 82f9d8777..850055358 100644
--- a/resources/src/main/java/org/robolectric/manifest/ServiceData.java
+++ b/resources/src/main/java/org/robolectric/manifest/ServiceData.java
@@ -4,9 +4,7 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
-/**
- * Holds parsed service data from manifest.
- */
+/** Holds parsed service data from manifest. */
 public class ServiceData extends PackageItemData {
 
   private static final String EXPORTED = "android:exported";
diff --git a/resources/src/main/java/org/robolectric/res/AttrData.java b/resources/src/main/java/org/robolectric/res/AttrData.java
index f6b59a279..d2f1c202b 100644
--- a/resources/src/main/java/org/robolectric/res/AttrData.java
+++ b/resources/src/main/java/org/robolectric/res/AttrData.java
@@ -44,19 +44,17 @@ public class AttrData {
     return false;
   }
 
-  @Override public String toString() {
-    StringBuilder builder = new StringBuilder("AttrData{name='")
-        .append(name)
-        .append("', format='")
-        .append(format)
-        .append('\'');
+  @Override
+  public String toString() {
+    StringBuilder builder =
+        new StringBuilder("AttrData{name='")
+            .append(name)
+            .append("', format='")
+            .append(format)
+            .append('\'');
     if (pairs != null) {
       for (Pair p : pairs) {
-        builder.append(' ')
-            .append(p.name)
-            .append("='")
-            .append(p.value)
-            .append('\'');
+        builder.append(' ').append(p.name).append("='").append(p.value).append('\'');
       }
     }
     builder.append('}');
diff --git a/resources/src/main/java/org/robolectric/res/AttributeResource.java b/resources/src/main/java/org/robolectric/res/AttributeResource.java
index e3fd66a53..3cd24d640 100644
--- a/resources/src/main/java/org/robolectric/res/AttributeResource.java
+++ b/resources/src/main/java/org/robolectric/res/AttributeResource.java
@@ -18,13 +18,19 @@ public class AttributeResource {
   public final @Nonnull String contextPackageName;
   private final Integer referenceResId;
 
-  public AttributeResource(@Nonnull ResName resName, @Nonnull String value, @Nonnull String contextPackageName) {
+  public AttributeResource(
+      @Nonnull ResName resName, @Nonnull String value, @Nonnull String contextPackageName) {
     this(resName, value, contextPackageName, null);
   }
 
-  public AttributeResource(@Nonnull ResName resName, @Nonnull String value, @Nonnull String contextPackageName, Integer referenceResId) {
+  public AttributeResource(
+      @Nonnull ResName resName,
+      @Nonnull String value,
+      @Nonnull String contextPackageName,
+      Integer referenceResId) {
     this.referenceResId = referenceResId;
-    if (!resName.type.equals("attr")) throw new IllegalStateException("\"" + resName.getFullyQualifiedName() + "\" unexpected");
+    if (!resName.type.equals("attr"))
+      throw new IllegalStateException("\"" + resName.getFullyQualifiedName() + "\" unexpected");
 
     this.resName = resName;
     this.value = value;
@@ -38,7 +44,8 @@ public class AttributeResource {
 
   public @Nonnull ResName getResourceReference() {
     if (!isResourceReference()) throw new RuntimeException("not a resource reference: " + this);
-    return ResName.qualifyResName(deref(trimmedValue).replace("+", ""), contextPackageName, "style");
+    return ResName.qualifyResName(
+        deref(trimmedValue).replace("+", ""), contextPackageName, "style");
   }
 
   public boolean isStyleReference() {
@@ -60,19 +67,27 @@ public class AttributeResource {
 
   @Override
   public String toString() {
-    return "Attribute{" +
-        "name='" + resName + '\'' +
-        ", value='" + value + '\'' +
-        ", contextPackageName='" + contextPackageName + '\'' +
-        '}';
+    return "Attribute{"
+        + "name='"
+        + resName
+        + '\''
+        + ", value='"
+        + value
+        + '\''
+        + ", contextPackageName='"
+        + contextPackageName
+        + '\''
+        + '}';
   }
 
   public static boolean isResourceReference(String value) {
     return IS_RESOURCE_REFERENCE.matcher(value).find() && !isNull(value);
   }
 
-  public static @Nonnull ResName getResourceReference(String value, String defPackage, String defType) {
-    if (!isResourceReference(value)) throw new IllegalArgumentException("not a resource reference: " + value);
+  public static @Nonnull ResName getResourceReference(
+      String value, String defPackage, String defType) {
+    if (!isResourceReference(value))
+      throw new IllegalArgumentException("not a resource reference: " + value);
     return ResName.qualifyResName(deref(value).replace("+", ""), defPackage, defType);
   }
 
@@ -85,7 +100,8 @@ public class AttributeResource {
   }
 
   public static ResName getStyleReference(String value, String defPackage, String defType) {
-    if (!isStyleReference(value)) throw new IllegalArgumentException("not a style reference: " + value);
+    if (!isStyleReference(value))
+      throw new IllegalArgumentException("not a style reference: " + value);
     return ResName.qualifyResName(value.substring(1), defPackage, defType);
   }
 
diff --git a/resources/src/main/java/org/robolectric/res/DrawableResourceLoader.java b/resources/src/main/java/org/robolectric/res/DrawableResourceLoader.java
index 956ae7104..62b70725b 100644
--- a/resources/src/main/java/org/robolectric/res/DrawableResourceLoader.java
+++ b/resources/src/main/java/org/robolectric/res/DrawableResourceLoader.java
@@ -57,7 +57,8 @@ public class DrawableResourceLoader {
         }
 
         XmlContext fakeXmlContext = new XmlContext(resourceTable.getPackageName(), f, qualifiers);
-        resourceTable.addResource(type, shortName, new FileTypedResource.Image(f, isNinePatch, fakeXmlContext));
+        resourceTable.addResource(
+            type, shortName, new FileTypedResource.Image(f, isNinePatch, fakeXmlContext));
       }
     }
   }
diff --git a/resources/src/main/java/org/robolectric/res/FileTypedResource.java b/resources/src/main/java/org/robolectric/res/FileTypedResource.java
index c1873d4e9..c4526468a 100644
--- a/resources/src/main/java/org/robolectric/res/FileTypedResource.java
+++ b/resources/src/main/java/org/robolectric/res/FileTypedResource.java
@@ -12,7 +12,8 @@ public class FileTypedResource extends TypedResource<String> {
     this.path = path;
   }
 
-  @Override public boolean isFile() {
+  @Override
+  public boolean isFile() {
     return true;
   }
 
diff --git a/resources/src/main/java/org/robolectric/res/Fs.java b/resources/src/main/java/org/robolectric/res/Fs.java
index dd4587675..5591c9948 100644
--- a/resources/src/main/java/org/robolectric/res/Fs.java
+++ b/resources/src/main/java/org/robolectric/res/Fs.java
@@ -29,7 +29,7 @@ import javax.annotation.concurrent.GuardedBy;
 import org.robolectric.util.Util;
 
 @SuppressWarnings({"NewApi", "AndroidJdkLibsChecker"})
-abstract public class Fs {
+public abstract class Fs {
 
   @GuardedBy("ZIP_FILESYSTEMS")
   private static final Map<Path, FsWrapper> ZIP_FILESYSTEMS = new HashMap<>();
diff --git a/resources/src/main/java/org/robolectric/res/FsFile.java b/resources/src/main/java/org/robolectric/res/FsFile.java
index 07a5a87cd..fd4207468 100644
--- a/resources/src/main/java/org/robolectric/res/FsFile.java
+++ b/resources/src/main/java/org/robolectric/res/FsFile.java
@@ -2,18 +2,24 @@ package org.robolectric.res;
 
 import java.nio.file.Path;
 
-/** @deprecated Use {@link Path} instead. */
+/**
+ * @deprecated Use {@link Path} instead.
+ */
 @Deprecated
 @SuppressWarnings("NewApi")
 public interface FsFile extends Path {
 
-  /** @deprecated use {@link Fs#externalize(Path)} instead. */
+  /**
+   * @deprecated use {@link Fs#externalize(Path)} instead.
+   */
   @Deprecated
   default String getPath() {
     return Fs.externalize(this);
   }
 
-  /** @deprecated use {@link Path#resolve(Path)} instead. */
+  /**
+   * @deprecated use {@link Path#resolve(Path)} instead.
+   */
   @Deprecated
   default Path join(String name) {
     return this.resolve(name);
diff --git a/resources/src/main/java/org/robolectric/res/NodeHandler.java b/resources/src/main/java/org/robolectric/res/NodeHandler.java
index 69a1fd6b6..f471b7b8d 100644
--- a/resources/src/main/java/org/robolectric/res/NodeHandler.java
+++ b/resources/src/main/java/org/robolectric/res/NodeHandler.java
@@ -20,8 +20,7 @@ class NodeHandler {
     }
   }
 
-  private static class AttrHandler extends HashMap<String, NodeHandler> {
-  }
+  private static class AttrHandler extends HashMap<String, NodeHandler> {}
 
   NodeHandler findMatchFor(XMLStreamReader xml) {
     String tagName = xml.getLocalName();
@@ -80,12 +79,9 @@ class NodeHandler {
     return this;
   }
 
-  public void onStart(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-  }
+  public void onStart(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {}
 
-  public void onCharacters(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-  }
+  public void onCharacters(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {}
 
-  public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-  }
+  public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {}
 }
diff --git a/resources/src/main/java/org/robolectric/res/PackageResourceTable.java b/resources/src/main/java/org/robolectric/res/PackageResourceTable.java
index 7d4387109..a7070f55a 100644
--- a/resources/src/main/java/org/robolectric/res/PackageResourceTable.java
+++ b/resources/src/main/java/org/robolectric/res/PackageResourceTable.java
@@ -9,9 +9,7 @@ import javax.annotation.Nonnull;
 import org.robolectric.res.android.ResTable_config;
 import org.robolectric.res.builder.XmlBlock;
 
-/**
- * A {@link ResourceTable} for a single package, e.g: "android" / ox01
- */
+/** A {@link ResourceTable} for a single package, e.g: "android" / ox01 */
 public class PackageResourceTable implements ResourceTable {
 
   private final ResBunch resources = new ResBunch();
@@ -21,7 +19,6 @@ public class PackageResourceTable implements ResourceTable {
   private final String packageName;
   private int packageIdentifier;
 
-
   public PackageResourceTable(String packageName) {
     this.packageName = packageName;
   }
@@ -64,7 +61,8 @@ public class PackageResourceTable implements ResourceTable {
     return resources.get(getResName(resId), config);
   }
 
-  @Override public XmlBlock getXml(ResName resName, ResTable_config config) {
+  @Override
+  public XmlBlock getXml(ResName resName, ResTable_config config) {
     FileTypedResource fileTypedResource = getFileResource(resName, config);
     if (fileTypedResource == null || !fileTypedResource.isXml()) {
       return null;
@@ -73,7 +71,8 @@ public class PackageResourceTable implements ResourceTable {
     }
   }
 
-  @Override public InputStream getRawValue(ResName resName, ResTable_config config) {
+  @Override
+  public InputStream getRawValue(ResName resName, ResTable_config config) {
     FileTypedResource fileTypedResource = getFileResource(resName, config);
     if (fileTypedResource == null) {
       return null;
@@ -107,21 +106,37 @@ public class PackageResourceTable implements ResourceTable {
   }
 
   void addResource(int resId, String type, String name) {
-      if (ResourceIds.isFrameworkResource(resId)) {
-        androidResourceIdGenerator.record(resId, type, name);
-      }
-      ResName resName = new ResName(packageName, type, name);
-      int resIdPackageIdentifier = ResourceIds.getPackageIdentifier(resId);
-      if (getPackageIdentifier() == 0) {
-        this.packageIdentifier = resIdPackageIdentifier;
-      } else if (getPackageIdentifier() != resIdPackageIdentifier) {
-        throw new IllegalArgumentException("Incompatible package for " + packageName + ":" + type + "/" + name + " with resId " + resIdPackageIdentifier + " to ResourceIndex with packageIdentifier " + getPackageIdentifier());
-      }
+    if (ResourceIds.isFrameworkResource(resId)) {
+      androidResourceIdGenerator.record(resId, type, name);
+    }
+    ResName resName = new ResName(packageName, type, name);
+    int resIdPackageIdentifier = ResourceIds.getPackageIdentifier(resId);
+    if (getPackageIdentifier() == 0) {
+      this.packageIdentifier = resIdPackageIdentifier;
+    } else if (getPackageIdentifier() != resIdPackageIdentifier) {
+      throw new IllegalArgumentException(
+          "Incompatible package for "
+              + packageName
+              + ":"
+              + type
+              + "/"
+              + name
+              + " with resId "
+              + resIdPackageIdentifier
+              + " to ResourceIndex with packageIdentifier "
+              + getPackageIdentifier());
+    }
 
-      ResName existingEntry = resourceTable.put(resId, resName);
-      if (existingEntry != null && !existingEntry.equals(resName)) {
-        throw new IllegalArgumentException("ResId " + Integer.toHexString(resId) + " mapped to both " + resName + " and " + existingEntry);
-      }
+    ResName existingEntry = resourceTable.put(resId, resName);
+    if (existingEntry != null && !existingEntry.equals(resName)) {
+      throw new IllegalArgumentException(
+          "ResId "
+              + Integer.toHexString(resId)
+              + " mapped to both "
+              + resName
+              + " and "
+              + existingEntry);
+    }
   }
 
   void addResource(String type, String name, TypedResource value) {
diff --git a/resources/src/main/java/org/robolectric/res/ResBundle.java b/resources/src/main/java/org/robolectric/res/ResBundle.java
index 52da22cd1..677ba3e8b 100644
--- a/resources/src/main/java/org/robolectric/res/ResBundle.java
+++ b/resources/src/main/java/org/robolectric/res/ResBundle.java
@@ -35,15 +35,19 @@ public class ResBundle {
       for (TypedResource candidate : values) {
         ResTable_config candidateConfig = candidate.getConfig();
         if (candidateConfig.match(toMatch)) {
-          if (bestMatchSoFar == null || candidateConfig.isBetterThan(bestMatchSoFar.getConfig(), toMatch)) {
+          if (bestMatchSoFar == null
+              || candidateConfig.isBetterThan(bestMatchSoFar.getConfig(), toMatch)) {
             bestMatchSoFar = candidate;
           }
         }
       }
 
       if (Logger.loggingEnabled()) {
-        Logger.debug("Picked '%s' for %s for qualifiers '%s' (%d candidates)",
-            bestMatchSoFar == null ? "<none>" : bestMatchSoFar.getXmlContext().getQualifiers().toString(),
+        Logger.debug(
+            "Picked '%s' for %s for qualifiers '%s' (%d candidates)",
+            bestMatchSoFar == null
+                ? "<none>"
+                : bestMatchSoFar.getXmlContext().getQualifiers().toString(),
             resName.getFullyQualifiedName(),
             toMatch,
             values.size());
diff --git a/resources/src/main/java/org/robolectric/res/ResName.java b/resources/src/main/java/org/robolectric/res/ResName.java
index 18ebc6e52..eb3aac2dd 100644
--- a/resources/src/main/java/org/robolectric/res/ResName.java
+++ b/resources/src/main/java/org/robolectric/res/ResName.java
@@ -47,15 +47,20 @@ public class ResName {
       @Nonnull String possiblyQualifiedResourceName,
       String defaultPackageName,
       String defaultType) {
-    ResName resName = qualifyResName(possiblyQualifiedResourceName, defaultPackageName, defaultType);
+    ResName resName =
+        qualifyResName(possiblyQualifiedResourceName, defaultPackageName, defaultType);
     return resName != null ? resName.getFullyQualifiedName() : null;
   }
 
-  public static ResName qualifyResName(@Nonnull String possiblyQualifiedResourceName, ResName defaults) {
+  public static ResName qualifyResName(
+      @Nonnull String possiblyQualifiedResourceName, ResName defaults) {
     return qualifyResName(possiblyQualifiedResourceName, defaults.packageName, defaults.type);
   }
 
-  public static ResName qualifyResName(@Nonnull String possiblyQualifiedResourceName, String defaultPackageName, String defaultType) {
+  public static ResName qualifyResName(
+      @Nonnull String possiblyQualifiedResourceName,
+      String defaultPackageName,
+      String defaultType) {
     int indexOfColon = possiblyQualifiedResourceName.indexOf(':');
     int indexOfSlash = possiblyQualifiedResourceName.indexOf('/');
     String type = null;
@@ -66,7 +71,7 @@ public class ResName {
         type = possiblyQualifiedResourceName.substring(0, indexOfSlash);
       }
       packageName = possiblyQualifiedResourceName.substring(indexOfSlash + 1, indexOfColon);
-      name =  possiblyQualifiedResourceName.substring(indexOfColon + 1);
+      name = possiblyQualifiedResourceName.substring(indexOfColon + 1);
     } else if (indexOfSlash > indexOfColon) {
       if (indexOfColon > 0) {
         packageName = possiblyQualifiedResourceName.substring(0, indexOfColon);
@@ -75,7 +80,8 @@ public class ResName {
       name = possiblyQualifiedResourceName.substring(indexOfSlash + 1);
     }
 
-    if ((type == null && defaultType == null) || (packageName == null && defaultPackageName == null)) {
+    if ((type == null && defaultType == null)
+        || (packageName == null && defaultPackageName == null)) {
       return null;
     }
 
@@ -88,7 +94,8 @@ public class ResName {
     return new ResName(packageName, type == null ? defaultType : type, name);
   }
 
-  public static String qualifyResName(String possiblyQualifiedResourceName, String contextPackageName) {
+  public static String qualifyResName(
+      String possiblyQualifiedResourceName, String contextPackageName) {
     if (possiblyQualifiedResourceName == null) {
       return null;
     }
@@ -98,7 +105,8 @@ public class ResName {
     }
 
     // Was not able to fully qualify the resource name
-    String fullyQualifiedResourceName = qualifyResourceName(possiblyQualifiedResourceName, contextPackageName, null);
+    String fullyQualifiedResourceName =
+        qualifyResourceName(possiblyQualifiedResourceName, contextPackageName, null);
     if (fullyQualifiedResourceName == null) {
       return null;
     }
@@ -106,7 +114,8 @@ public class ResName {
     return fullyQualifiedResourceName.replaceAll("[@+]", "");
   }
 
-  public static ResName qualifyFromFilePath(@Nonnull final String packageName, @Nonnull final String filePath) {
+  public static ResName qualifyFromFilePath(
+      @Nonnull final String packageName, @Nonnull final String filePath) {
     final File file = new File(filePath);
     final String type = file.getParentFile().getName().split("-", 0)[0];
     final String name = Fs.baseNameFor(file.toPath());
diff --git a/resources/src/main/java/org/robolectric/res/ResType.java b/resources/src/main/java/org/robolectric/res/ResType.java
index ea6ab923d..2593dd07c 100644
--- a/resources/src/main/java/org/robolectric/res/ResType.java
+++ b/resources/src/main/java/org/robolectric/res/ResType.java
@@ -40,9 +40,7 @@ public enum ResType {
     return itemResType;
   }
 
-  /**
-   * Parses a resource value to infer the type
-   */
+  /** Parses a resource value to infer the type */
   public static ResType inferFromValue(String value) {
     if (value.startsWith("#")) {
       return COLOR;
diff --git a/resources/src/main/java/org/robolectric/res/ResourceIdGenerator.java b/resources/src/main/java/org/robolectric/res/ResourceIdGenerator.java
index 6863c7988..e3b1a5c09 100644
--- a/resources/src/main/java/org/robolectric/res/ResourceIdGenerator.java
+++ b/resources/src/main/java/org/robolectric/res/ResourceIdGenerator.java
@@ -3,9 +3,7 @@ package org.robolectric.res;
 import java.util.HashMap;
 import java.util.Map;
 
-/**
- * Tracks resource ids and generates new unique values.
- */
+/** Tracks resource ids and generates new unique values. */
 public class ResourceIdGenerator {
 
   private final Map<String, TypeTracker> typeInfo = new HashMap<>();
@@ -51,7 +49,8 @@ public class ResourceIdGenerator {
       typeTracker = new TypeTracker(getNextFreeTypeIdentifier());
       typeInfo.put(type, typeTracker);
     }
-    return ResourceIds.makeIdentifer(packageIdentifier, typeTracker.getTypeIdentifier(), typeTracker.getFreeIdentifier());
+    return ResourceIds.makeIdentifer(
+        packageIdentifier, typeTracker.getTypeIdentifier(), typeTracker.getFreeIdentifier());
   }
 
   private int getNextFreeTypeIdentifier() {
diff --git a/resources/src/main/java/org/robolectric/res/ResourceIds.java b/resources/src/main/java/org/robolectric/res/ResourceIds.java
index a4dbdb735..a00602f8b 100644
--- a/resources/src/main/java/org/robolectric/res/ResourceIds.java
+++ b/resources/src/main/java/org/robolectric/res/ResourceIds.java
@@ -23,4 +23,4 @@ public class ResourceIds {
   public static int makeIdentifer(int packageIdentifier, int typeIdentifier, int entryIdenifier) {
     return packageIdentifier << 24 | typeIdentifier << 16 | entryIdenifier;
   }
-}
\ No newline at end of file
+}
diff --git a/resources/src/main/java/org/robolectric/res/ResourceMerger.java b/resources/src/main/java/org/robolectric/res/ResourceMerger.java
index 8a54f8402..7d4c4db6f 100644
--- a/resources/src/main/java/org/robolectric/res/ResourceMerger.java
+++ b/resources/src/main/java/org/robolectric/res/ResourceMerger.java
@@ -17,7 +17,9 @@ public class ResourceMerger {
       }
     }
 
-    return new ResourceTableFactory().newResourceTable(appManifest.getPackageName(),
-        allResourcePaths.toArray(new ResourcePath[allResourcePaths.size()]));
+    return new ResourceTableFactory()
+        .newResourceTable(
+            appManifest.getPackageName(),
+            allResourcePaths.toArray(new ResourcePath[allResourcePaths.size()]));
   }
 }
diff --git a/resources/src/main/java/org/robolectric/res/ResourcePath.java b/resources/src/main/java/org/robolectric/res/ResourcePath.java
index 2f43db9ad..09e43a9bb 100644
--- a/resources/src/main/java/org/robolectric/res/ResourcePath.java
+++ b/resources/src/main/java/org/robolectric/res/ResourcePath.java
@@ -54,10 +54,13 @@ public class ResourcePath {
     ResourcePath that = (ResourcePath) o;
 
     if (rClass != null ? !rClass.equals(that.rClass) : that.rClass != null) return false;
-    if (resourceBase != null ? !resourceBase.equals(that.resourceBase) : that.resourceBase != null) return false;
-    if (assetsDir != null ? !assetsDir.equals(that.assetsDir) : that.assetsDir != null) return false;
-    return internalRClass != null ? internalRClass.equals(that.internalRClass) : that.internalRClass == null;
-
+    if (resourceBase != null ? !resourceBase.equals(that.resourceBase) : that.resourceBase != null)
+      return false;
+    if (assetsDir != null ? !assetsDir.equals(that.assetsDir) : that.assetsDir != null)
+      return false;
+    return internalRClass != null
+        ? internalRClass.equals(that.internalRClass)
+        : that.internalRClass == null;
   }
 
   @Override
diff --git a/resources/src/main/java/org/robolectric/res/ResourceRemapper.java b/resources/src/main/java/org/robolectric/res/ResourceRemapper.java
index 901240bf1..2e2a25663 100644
--- a/resources/src/main/java/org/robolectric/res/ResourceRemapper.java
+++ b/resources/src/main/java/org/robolectric/res/ResourceRemapper.java
@@ -8,19 +8,17 @@ import java.util.HashMap;
 import java.util.Map;
 
 /**
- * This class rewrites application R class resource values from multiple input R classes to all have unique values
- * existing within the same ID space, i.e: no resource collisions. This replicates the behaviour of AAPT when building
- * the final APK.
+ * This class rewrites application R class resource values from multiple input R classes to all have
+ * unique values existing within the same ID space, i.e: no resource collisions. This replicates the
+ * behaviour of AAPT when building the final APK.
  *
- * IDs are in the format:-
+ * <p>IDs are in the format:-
  *
- * 0x PPTTEEEE
+ * <p>0x PPTTEEEE
  *
- * where:
+ * <p>where:
  *
- * P is unique for the package
- * T is unique for the type
- * E is the entry within that type.
+ * <p>P is unique for the package T is unique for the type E is the entry within that type.
  */
 class ResourceRemapper {
 
@@ -28,10 +26,10 @@ class ResourceRemapper {
   private ResourceIdGenerator resourceIdGenerator = new ResourceIdGenerator(0x7F);
 
   /**
-   * @param primaryRClass - An R class (usually the applications) that can be assumed to have a complete set of IDs. If
-   *                      this is provided then use the values from this class for re-writting all values in follow up
-   *                      calls to {@link #remapRClass(Class)}. If it is not provided the ResourceRemapper will generate
-   *                      its own unique non-conflicting IDs.
+   * @param primaryRClass - An R class (usually the applications) that can be assumed to have a
+   *     complete set of IDs. If this is provided then use the values from this class for
+   *     re-writting all values in follow up calls to {@link #remapRClass(Class)}. If it is not
+   *     provided the ResourceRemapper will generate its own unique non-conflicting IDs.
    */
   ResourceRemapper(Class<?> primaryRClass) {
     if (primaryRClass != null) {
@@ -44,15 +42,17 @@ class ResourceRemapper {
   }
 
   /**
-   * @param isPrimary - Only one R class can allow final values and that is the final R class for the application
-   *                  that has had its resource id values generated to include all libraries in its dependency graph
-   *                  and therefore will be the only R file with the complete set of IDs in a unique ID space so we
-   *                  can assume to use the values from this class only. All other R files are partial R files for each
-   *                  library and on non-Android aware build systems like Maven where library R files are not re-written
-   *                  with the final R values we need to rewrite them ourselves.
+   * @param isPrimary - Only one R class can allow final values and that is the final R class for
+   *     the application that has had its resource id values generated to include all libraries in
+   *     its dependency graph and therefore will be the only R file with the complete set of IDs in
+   *     a unique ID space so we can assume to use the values from this class only. All other R
+   *     files are partial R files for each library and on non-Android aware build systems like
+   *     Maven where library R files are not re-written with the final R values we need to rewrite
+   *     them ourselves.
    */
   private void remapRClass(boolean isPrimary, Class<?> rClass) {
-    // Collect all the local attribute id -> name mappings. These are used when processing the stylables to look up
+    // Collect all the local attribute id -> name mappings. These are used when processing the
+    // stylables to look up
     // the reassigned values.
     Map<Integer, String> localAttributeIds = new HashMap<>();
     for (Class<?> aClass : rClass.getClasses()) {
diff --git a/resources/src/main/java/org/robolectric/res/ResourceTableFactory.java b/resources/src/main/java/org/robolectric/res/ResourceTableFactory.java
index 9f65367a2..906e2382a 100644
--- a/resources/src/main/java/org/robolectric/res/ResourceTableFactory.java
+++ b/resources/src/main/java/org/robolectric/res/ResourceTableFactory.java
@@ -83,8 +83,9 @@ public class ResourceTableFactory {
   }
 
   /**
-   * Check the stylable elements. Not for aapt generated R files but for framework R files it is possible to
-   * have attributes in the styleable array for which there is no corresponding R.attr field.
+   * Check the stylable elements. Not for aapt generated R files but for framework R files it is
+   * possible to have attributes in the styleable array for which there is no corresponding R.attr
+   * field.
    */
   private void addMissingStyleableAttributes(PackageResourceTable resourceTable, Class<?> rClass) {
     for (Class innerClass : rClass.getClasses()) {
@@ -99,7 +100,8 @@ public class ResourceTableFactory {
             } catch (IllegalAccessException e) {
               throw new RuntimeException(e);
             }
-          } else if (field.getType().equals(Integer.TYPE) && Modifier.isStatic(field.getModifiers())) {
+          } else if (field.getType().equals(Integer.TYPE)
+              && Modifier.isStatic(field.getModifiers())) {
             String attributeName = field.getName().substring(styleableName.length() + 1);
             try {
               int styleableIndex = field.getInt(null);
diff --git a/resources/src/main/java/org/robolectric/res/RoutingResourceTable.java b/resources/src/main/java/org/robolectric/res/RoutingResourceTable.java
index 4e63dcc60..b1645b47d 100644
--- a/resources/src/main/java/org/robolectric/res/RoutingResourceTable.java
+++ b/resources/src/main/java/org/robolectric/res/RoutingResourceTable.java
@@ -9,7 +9,8 @@ import org.robolectric.res.android.ResTable_config;
 import org.robolectric.res.builder.XmlBlock;
 
 public class RoutingResourceTable implements ResourceTable {
-  private static final PackageResourceTable EMPTY_RESOURCE_TABLE = new ResourceTableFactory().newResourceTable("");
+  private static final PackageResourceTable EMPTY_RESOURCE_TABLE =
+      new ResourceTableFactory().newResourceTable("");
   private final Map<String, PackageResourceTable> resourceTables;
 
   public RoutingResourceTable(PackageResourceTable... resourceTables) {
@@ -20,25 +21,30 @@ public class RoutingResourceTable implements ResourceTable {
     }
   }
 
-  @Override public InputStream getRawValue(int resId, ResTable_config config) {
+  @Override
+  public InputStream getRawValue(int resId, ResTable_config config) {
     ResName resName = getResName(resId);
     return resName != null ? getRawValue(resName, config) : null;
   }
 
-  @Override public TypedResource getValue(@Nonnull ResName resName, ResTable_config config) {
+  @Override
+  public TypedResource getValue(@Nonnull ResName resName, ResTable_config config) {
     return pickFor(resName).getValue(resName, config);
   }
 
-  @Override public TypedResource getValue(int resId, ResTable_config config) {
+  @Override
+  public TypedResource getValue(int resId, ResTable_config config) {
     ResName resName = pickFor(resId).getResName(resId);
     return resName != null ? getValue(resName, config) : null;
   }
 
-  @Override public XmlBlock getXml(ResName resName, ResTable_config config) {
+  @Override
+  public XmlBlock getXml(ResName resName, ResTable_config config) {
     return pickFor(resName).getXml(resName, config);
   }
 
-  @Override public InputStream getRawValue(ResName resName, ResTable_config config) {
+  @Override
+  public InputStream getRawValue(ResName resName, ResTable_config config) {
     return pickFor(resName).getRawValue(resName, config);
   }
 
diff --git a/resources/src/main/java/org/robolectric/res/StaxArrayLoader.java b/resources/src/main/java/org/robolectric/res/StaxArrayLoader.java
index e21d80925..53b023e13 100644
--- a/resources/src/main/java/org/robolectric/res/StaxArrayLoader.java
+++ b/resources/src/main/java/org/robolectric/res/StaxArrayLoader.java
@@ -10,31 +10,40 @@ public class StaxArrayLoader extends StaxLoader {
   private List<TypedResource> items;
   private final StringBuilder buf = new StringBuilder();
 
-  public StaxArrayLoader(PackageResourceTable resourceTable, String attrType, ResType arrayResType, final ResType scalarResType) {
+  public StaxArrayLoader(
+      PackageResourceTable resourceTable,
+      String attrType,
+      ResType arrayResType,
+      final ResType scalarResType) {
     super(resourceTable, attrType, arrayResType);
 
-    addHandler("item", new NodeHandler() {
-      @Override
-      public void onStart(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-        buf.setLength(0);
-      }
-
-      @Override
-      public void onCharacters(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-        buf.append(xml.getText());
-      }
-
-      @Override
-      public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-        ResType resType = scalarResType == null ? ResType.inferType(buf.toString()) : scalarResType;
-        items.add(new TypedResource<>(buf.toString(), resType, xmlContext));
-      }
-
-      @Override
-      NodeHandler findMatchFor(XMLStreamReader xml) {
-        return new TextCollectingNodeHandler(buf);
-      }
-    });
+    addHandler(
+        "item",
+        new NodeHandler() {
+          @Override
+          public void onStart(XMLStreamReader xml, XmlContext xmlContext)
+              throws XMLStreamException {
+            buf.setLength(0);
+          }
+
+          @Override
+          public void onCharacters(XMLStreamReader xml, XmlContext xmlContext)
+              throws XMLStreamException {
+            buf.append(xml.getText());
+          }
+
+          @Override
+          public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
+            ResType resType =
+                scalarResType == null ? ResType.inferType(buf.toString()) : scalarResType;
+            items.add(new TypedResource<>(buf.toString(), resType, xmlContext));
+          }
+
+          @Override
+          NodeHandler findMatchFor(XMLStreamReader xml) {
+            return new TextCollectingNodeHandler(buf);
+          }
+        });
   }
 
   @Override
diff --git a/resources/src/main/java/org/robolectric/res/StaxAttrLoader.java b/resources/src/main/java/org/robolectric/res/StaxAttrLoader.java
index 92bf880b5..2358a27f9 100644
--- a/resources/src/main/java/org/robolectric/res/StaxAttrLoader.java
+++ b/resources/src/main/java/org/robolectric/res/StaxAttrLoader.java
@@ -13,33 +13,35 @@ public class StaxAttrLoader extends StaxLoader {
   public StaxAttrLoader(PackageResourceTable resourceTable, String attrType, ResType resType) {
     super(resourceTable, attrType, resType);
 
-    addHandler("*", new NodeHandler() {
-      private String value;
-      private String name;
-
-      @Override
-      public void onStart(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-        String type = xml.getLocalName();
-        if (pairs.isEmpty()) {
-          if (format == null) {
-            format = type;
-          } else {
-            format = format + "|" + type;
+    addHandler(
+        "*",
+        new NodeHandler() {
+          private String value;
+          private String name;
+
+          @Override
+          public void onStart(XMLStreamReader xml, XmlContext xmlContext)
+              throws XMLStreamException {
+            String type = xml.getLocalName();
+            if (pairs.isEmpty()) {
+              if (format == null) {
+                format = type;
+              } else {
+                format = format + "|" + type;
+              }
+            }
+            name = xml.getAttributeValue(null, "name");
+            value = xml.getAttributeValue(null, "value");
+            pairs.add(new AttrData.Pair(name, value));
           }
-        }
-        name = xml.getAttributeValue(null, "name");
-        value = xml.getAttributeValue(null, "value");
-        pairs.add(new AttrData.Pair(name, value));
-      }
-
-      @Override
-      public void onCharacters(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-      }
-
-      @Override
-      public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-      }
-    });
+
+          @Override
+          public void onCharacters(XMLStreamReader xml, XmlContext xmlContext)
+              throws XMLStreamException {}
+
+          @Override
+          public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {}
+        });
   }
 
   @Override
@@ -53,7 +55,7 @@ public class StaxAttrLoader extends StaxLoader {
     AttrData attrData = new AttrData(name, format, new ArrayList<>(pairs));
     pairs.clear();
 
-//      xmlContext = xmlContext.withLineNumber(xml.getLocation().getLineNumber());
+    //      xmlContext = xmlContext.withLineNumber(xml.getLocation().getLineNumber());
     if (attrData.getFormat() != null) {
       resourceTable.addResource(attrType, name, new TypedResource<>(attrData, resType, xmlContext));
     }
diff --git a/resources/src/main/java/org/robolectric/res/StaxLoader.java b/resources/src/main/java/org/robolectric/res/StaxLoader.java
index 3c19ab40c..be1f21c9d 100644
--- a/resources/src/main/java/org/robolectric/res/StaxLoader.java
+++ b/resources/src/main/java/org/robolectric/res/StaxLoader.java
@@ -16,14 +16,11 @@ public abstract class StaxLoader extends NodeHandler {
   }
 
   @Override
-  public void onStart(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-  }
+  public void onStart(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {}
 
   @Override
-  public void onCharacters(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-  }
+  public void onCharacters(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {}
 
   @Override
-  public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-  }
+  public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {}
 }
diff --git a/resources/src/main/java/org/robolectric/res/StaxPluralsLoader.java b/resources/src/main/java/org/robolectric/res/StaxPluralsLoader.java
index 7be9dfe86..53b8d1597 100644
--- a/resources/src/main/java/org/robolectric/res/StaxPluralsLoader.java
+++ b/resources/src/main/java/org/robolectric/res/StaxPluralsLoader.java
@@ -10,33 +10,38 @@ public class StaxPluralsLoader extends StaxLoader {
   private String quantity;
   private final List<Plural> plurals = new ArrayList<>();
 
-  public StaxPluralsLoader(PackageResourceTable resourceTable, String attrType, ResType charSequence) {
+  public StaxPluralsLoader(
+      PackageResourceTable resourceTable, String attrType, ResType charSequence) {
     super(resourceTable, attrType, charSequence);
 
-    addHandler("item", new NodeHandler() {
-      private final StringBuilder buf = new StringBuilder();
-
-      @Override
-      public void onStart(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-        quantity = xml.getAttributeValue(null, "quantity");
-        buf.setLength(0);
-      }
-
-      @Override
-      public void onCharacters(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-        buf.append(xml.getText());
-      }
-
-      @Override
-      public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-        plurals.add(new Plural(quantity, buf.toString()));
-      }
-
-      @Override
-      NodeHandler findMatchFor(XMLStreamReader xml) {
-        return new TextCollectingNodeHandler(buf);
-      }
-    });
+    addHandler(
+        "item",
+        new NodeHandler() {
+          private final StringBuilder buf = new StringBuilder();
+
+          @Override
+          public void onStart(XMLStreamReader xml, XmlContext xmlContext)
+              throws XMLStreamException {
+            quantity = xml.getAttributeValue(null, "quantity");
+            buf.setLength(0);
+          }
+
+          @Override
+          public void onCharacters(XMLStreamReader xml, XmlContext xmlContext)
+              throws XMLStreamException {
+            buf.append(xml.getText());
+          }
+
+          @Override
+          public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
+            plurals.add(new Plural(quantity, buf.toString()));
+          }
+
+          @Override
+          NodeHandler findMatchFor(XMLStreamReader xml) {
+            return new TextCollectingNodeHandler(buf);
+          }
+        });
   }
 
   @Override
@@ -46,7 +51,8 @@ public class StaxPluralsLoader extends StaxLoader {
 
   @Override
   public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-    resourceTable.addResource(attrType, name, new PluralRules(new ArrayList<>(plurals), resType, xmlContext));
+    resourceTable.addResource(
+        attrType, name, new PluralRules(new ArrayList<>(plurals), resType, xmlContext));
     plurals.clear();
   }
 }
diff --git a/resources/src/main/java/org/robolectric/res/StaxStyleLoader.java b/resources/src/main/java/org/robolectric/res/StaxStyleLoader.java
index db11295ee..587ddb716 100644
--- a/resources/src/main/java/org/robolectric/res/StaxStyleLoader.java
+++ b/resources/src/main/java/org/robolectric/res/StaxStyleLoader.java
@@ -13,27 +13,33 @@ public class StaxStyleLoader extends StaxLoader {
   public StaxStyleLoader(PackageResourceTable resourceTable, String attrType, ResType resType) {
     super(resourceTable, attrType, resType);
 
-    addHandler("item", new NodeHandler() {
-      private String attrName;
-      private StringBuilder buf = new StringBuilder();
-
-      @Override
-      public void onStart(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-        attrName = xml.getAttributeValue(null, "name");
-        buf.setLength(0);
-      }
+    addHandler(
+        "item",
+        new NodeHandler() {
+          private String attrName;
+          private StringBuilder buf = new StringBuilder();
 
-      @Override
-      public void onCharacters(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-        buf.append(xml.getText());
-      }
+          @Override
+          public void onStart(XMLStreamReader xml, XmlContext xmlContext)
+              throws XMLStreamException {
+            attrName = xml.getAttributeValue(null, "name");
+            buf.setLength(0);
+          }
 
-      @Override
-      public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
-        ResName attrResName = ResName.qualifyResName(attrName, xmlContext.getPackageName(), "attr");
-        attributeResources.add(new AttributeResource(attrResName, buf.toString(), xmlContext.getPackageName()));
-      }
-    });
+          @Override
+          public void onCharacters(XMLStreamReader xml, XmlContext xmlContext)
+              throws XMLStreamException {
+            buf.append(xml.getText());
+          }
+
+          @Override
+          public void onEnd(XMLStreamReader xml, XmlContext xmlContext) throws XMLStreamException {
+            ResName attrResName =
+                ResName.qualifyResName(attrName, xmlContext.getPackageName(), "attr");
+            attributeResources.add(
+                new AttributeResource(attrResName, buf.toString(), xmlContext.getPackageName()));
+          }
+        });
   }
 
   @Override
@@ -54,8 +60,10 @@ public class StaxStyleLoader extends StaxLoader {
       }
     }
 
-    StyleData styleData = new StyleData(xmlContext.getPackageName(), name, styleParent, attributeResources);
+    StyleData styleData =
+        new StyleData(xmlContext.getPackageName(), name, styleParent, attributeResources);
 
-    resourceTable.addResource("style", styleData.getName(), new TypedResource<>(styleData, resType, xmlContext));
+    resourceTable.addResource(
+        "style", styleData.getName(), new TypedResource<>(styleData, resType, xmlContext));
   }
 }
diff --git a/resources/src/main/java/org/robolectric/res/StringResources.java b/resources/src/main/java/org/robolectric/res/StringResources.java
index b58855ce5..450d2e345 100644
--- a/resources/src/main/java/org/robolectric/res/StringResources.java
+++ b/resources/src/main/java/org/robolectric/res/StringResources.java
@@ -10,10 +10,8 @@ public class StringResources {
   private static final int CODE_POINT_LENGTH = 4;
 
   /**
-   * Processes String resource values in the same way real Android does, namely:-
-   * 1) Trim leading and trailing whitespace.
-   * 2) Converts code points.
-   * 3) Escapes
+   * Processes String resource values in the same way real Android does, namely:- 1) Trim leading
+   * and trailing whitespace. 2) Converts code points. 3) Escapes
    */
   public static String processStringResources(String inputValue) {
     return escape(whitespace().collapseFrom(inputValue.trim(), ' '));
diff --git a/resources/src/main/java/org/robolectric/res/StyleData.java b/resources/src/main/java/org/robolectric/res/StyleData.java
index 4270e2654..1d7a64e4c 100644
--- a/resources/src/main/java/org/robolectric/res/StyleData.java
+++ b/resources/src/main/java/org/robolectric/res/StyleData.java
@@ -13,7 +13,8 @@ public class StyleData implements Style {
   private final String parent;
   private final Map<ResName, AttributeResource> items = new LinkedHashMap<>();
 
-  public StyleData(String packageName, String name, String parent, List<AttributeResource> attributeResources) {
+  public StyleData(
+      String packageName, String name, String parent, List<AttributeResource> attributeResources) {
     this.packageName = packageName;
     this.name = name;
     this.parent = parent;
@@ -36,17 +37,21 @@ public class StyleData implements Style {
     items.put(attrName, attribute);
   }
 
-  @Override public AttributeResource getAttrValue(ResName resName) {
+  @Override
+  public AttributeResource getAttrValue(ResName resName) {
     AttributeResource attributeResource = items.get(resName);
 
     // This hack allows us to look up attributes from downstream dependencies, see comment in
     // org.robolectric.shadows.ShadowThemeTest.obtainTypedArrayFromDependencyLibrary()
     // for an explanation. TODO(jongerrish): Make Robolectric use a more realistic resource merging
     // scheme.
-    if (attributeResource == null && !"android".equals(resName.packageName) && !"android".equals(packageName)) {
+    if (attributeResource == null
+        && !"android".equals(resName.packageName)
+        && !"android".equals(packageName)) {
       attributeResource = items.get(resName.withPackageName(packageName));
       if (attributeResource != null && !"android".equals(attributeResource.contextPackageName)) {
-        attributeResource = new AttributeResource(resName, attributeResource.value, resName.packageName);
+        attributeResource =
+            new AttributeResource(resName, attributeResource.value, resName.packageName);
       }
     }
 
@@ -95,7 +100,8 @@ public class StyleData implements Style {
     return hashCode;
   }
 
-  @Override public String toString() {
+  @Override
+  public String toString() {
     return "Style " + packageName + ":" + name;
   }
 
diff --git a/resources/src/main/java/org/robolectric/res/StyleResolver.java b/resources/src/main/java/org/robolectric/res/StyleResolver.java
index 0c0f816a8..f354fe796 100644
--- a/resources/src/main/java/org/robolectric/res/StyleResolver.java
+++ b/resources/src/main/java/org/robolectric/res/StyleResolver.java
@@ -13,8 +13,13 @@ public class StyleResolver implements Style {
   private final ResName myResName;
   private final ResTable_config config;
 
-  public StyleResolver(ResourceTable appResourceTable, ResourceTable systemResourceTable, StyleData styleData,
-                       Style theme, ResName myResName, ResTable_config config) {
+  public StyleResolver(
+      ResourceTable appResourceTable,
+      ResourceTable systemResourceTable,
+      StyleData styleData,
+      Style theme,
+      ResName myResName,
+      ResTable_config config) {
     this.appResourceTable = appResourceTable;
     this.systemResourceTable = systemResourceTable;
     this.theme = theme;
@@ -23,7 +28,8 @@ public class StyleResolver implements Style {
     styles.add(styleData);
   }
 
-  @Override public AttributeResource getAttrValue(ResName resName) {
+  @Override
+  public AttributeResource getAttrValue(ResName resName) {
     for (StyleData style : styles) {
       AttributeResource value = style.getAttrValue(resName);
       if (value != null) return value;
@@ -88,14 +94,19 @@ public class StyleResolver implements Style {
     styleRef = dereferenceResName(styleRef);
 
     // TODO: Refactor this to a ResourceLoaderChooser
-    ResourceTable resourceProvider = "android".equals(styleRef.packageName) ? systemResourceTable : appResourceTable;
+    ResourceTable resourceProvider =
+        "android".equals(styleRef.packageName) ? systemResourceTable : appResourceTable;
     TypedResource typedResource = resourceProvider.getValue(styleRef, config);
 
     if (typedResource == null) {
-      StringBuilder builder = new StringBuilder("Could not find any resource")
-          .append(" from reference ").append(styleRef)
-          .append(" from ").append(style)
-          .append(" with ").append(theme);
+      StringBuilder builder =
+          new StringBuilder("Could not find any resource")
+              .append(" from reference ")
+              .append(styleRef)
+              .append(" from ")
+              .append(style)
+              .append(" with ")
+              .append(theme);
       throw new RuntimeException(builder.toString());
     }
 
@@ -103,11 +114,16 @@ public class StyleResolver implements Style {
     if (data instanceof StyleData) {
       return (StyleData) data;
     } else {
-      StringBuilder builder = new StringBuilder(styleRef.toString())
-          .append(" does not resolve to a Style.")
-          .append(" got ").append(data).append(" instead. ")
-          .append(" from ").append(style)
-          .append(" with ").append(theme);
+      StringBuilder builder =
+          new StringBuilder(styleRef.toString())
+              .append(" does not resolve to a Style.")
+              .append(" got ")
+              .append(data)
+              .append(" instead. ")
+              .append(" from ")
+              .append(style)
+              .append(" with ")
+              .append(theme);
       throw new RuntimeException(builder.toString());
     }
   }
@@ -172,5 +188,4 @@ public class StyleResolver implements Style {
   public String toString() {
     return styles.get(0) + " (and parents)";
   }
-
-}
\ No newline at end of file
+}
diff --git a/resources/src/main/java/org/robolectric/res/ThemeStyleSet.java b/resources/src/main/java/org/robolectric/res/ThemeStyleSet.java
index 9c893e5ef..75a138108 100644
--- a/resources/src/main/java/org/robolectric/res/ThemeStyleSet.java
+++ b/resources/src/main/java/org/robolectric/res/ThemeStyleSet.java
@@ -3,14 +3,13 @@ package org.robolectric.res;
 import java.util.ArrayList;
 import java.util.List;
 
-/**
- * Represents the list of styles applied to a Theme.
- */
+/** Represents the list of styles applied to a Theme. */
 public class ThemeStyleSet implements Style {
 
   private List<OverlayedStyle> styles = new ArrayList<>();
 
-  @Override public AttributeResource getAttrValue(ResName attrName) {
+  @Override
+  public AttributeResource getAttrValue(ResName attrName) {
     AttributeResource attribute = null;
 
     for (OverlayedStyle overlayedStyle : styles) {
@@ -77,5 +76,4 @@ public class ThemeStyleSet implements Style {
       return style.toString() + (force ? " (forced)" : "");
     }
   }
-
 }
diff --git a/resources/src/main/java/org/robolectric/res/TypedResource.java b/resources/src/main/java/org/robolectric/res/TypedResource.java
index 50978fea5..13eb20a4e 100644
--- a/resources/src/main/java/org/robolectric/res/TypedResource.java
+++ b/resources/src/main/java/org/robolectric/res/TypedResource.java
@@ -47,12 +47,17 @@ public class TypedResource<T> {
     return false;
   }
 
-  @Override public String toString() {
-    return getClass().getSimpleName() + "{" +
-        "values=" + data +
-        ", resType=" + resType +
-        ", xmlContext=" + xmlContext +
-        '}';
+  @Override
+  public String toString() {
+    return getClass().getSimpleName()
+        + "{"
+        + "values="
+        + data
+        + ", resType="
+        + resType
+        + ", xmlContext="
+        + xmlContext
+        + '}';
   }
 
   public boolean isXml() {
diff --git a/resources/src/main/java/org/robolectric/res/XmlContext.java b/resources/src/main/java/org/robolectric/res/XmlContext.java
index e2fae7a00..127484e71 100644
--- a/resources/src/main/java/org/robolectric/res/XmlContext.java
+++ b/resources/src/main/java/org/robolectric/res/XmlContext.java
@@ -30,7 +30,8 @@ public class XmlContext {
     return xmlFile;
   }
 
-  @Override public String toString() {
+  @Override
+  public String toString() {
     return '{' + packageName + ':' + xmlFile + '}';
   }
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/AConfiguration.java b/resources/src/main/java/org/robolectric/res/android/AConfiguration.java
index 11b2ad430..579f76c78 100644
--- a/resources/src/main/java/org/robolectric/res/android/AConfiguration.java
+++ b/resources/src/main/java/org/robolectric/res/android/AConfiguration.java
@@ -1,413 +1,506 @@
 package org.robolectric.res.android;
 
-// transliterated from https://android.googlesource.com/platform/frameworks/native/+/android-9.0.0_r12/include/android/configuration.h
+// transliterated from
+// https://android.googlesource.com/platform/frameworks/native/+/android-9.0.0_r12/include/android/configuration.h
 public class AConfiguration {
-/** Orientation: not specified. */
-  public static final int ACONFIGURATION_ORIENTATION_ANY  = 0x0000;
+  /** Orientation: not specified. */
+  public static final int ACONFIGURATION_ORIENTATION_ANY = 0x0000;
+
   /**
-   * Orientation: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#OrientationQualifier">port</a>
+   * Orientation: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#OrientationQualifier">port</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_ORIENTATION_PORT = 0x0001;
+
   /**
-   * Orientation: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#OrientationQualifier">land</a>
+   * Orientation: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#OrientationQualifier">land</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_ORIENTATION_LAND = 0x0002;
-  /** @deprecated Not currently supported or used. */
-  @Deprecated
-  public static final int ACONFIGURATION_ORIENTATION_SQUARE = 0x0003;
+
+  /**
+   * @deprecated Not currently supported or used.
+   */
+  @Deprecated public static final int ACONFIGURATION_ORIENTATION_SQUARE = 0x0003;
+
   /** Touchscreen: not specified. */
-  public static final int ACONFIGURATION_TOUCHSCREEN_ANY  = 0x0000;
+  public static final int ACONFIGURATION_TOUCHSCREEN_ANY = 0x0000;
+
   /**
-   * Touchscreen: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#TouchscreenQualifier">notouch</a>
+   * Touchscreen: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#TouchscreenQualifier">notouch</a>
    * resource qualifier.
    */
-  public static final int ACONFIGURATION_TOUCHSCREEN_NOTOUCH  = 0x0001;
-  /** @deprecated Not currently supported or used. */
-  @Deprecated
-  public static final int ACONFIGURATION_TOUCHSCREEN_STYLUS  = 0x0002;
+  public static final int ACONFIGURATION_TOUCHSCREEN_NOTOUCH = 0x0001;
+
+  /**
+   * @deprecated Not currently supported or used.
+   */
+  @Deprecated public static final int ACONFIGURATION_TOUCHSCREEN_STYLUS = 0x0002;
+
   /**
-   * Touchscreen: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#TouchscreenQualifier">finger</a>
+   * Touchscreen: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#TouchscreenQualifier">finger</a>
    * resource qualifier.
    */
-  public static final int ACONFIGURATION_TOUCHSCREEN_FINGER  = 0x0003;
+  public static final int ACONFIGURATION_TOUCHSCREEN_FINGER = 0x0003;
+
   /** Density: default density. */
   public static final int ACONFIGURATION_DENSITY_DEFAULT = 0;
+
   /**
-   * Density: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#DensityQualifier">ldpi</a>
+   * Density: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#DensityQualifier">ldpi</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_DENSITY_LOW = 120;
+
   /**
-   * Density: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#DensityQualifier">mdpi</a>
+   * Density: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#DensityQualifier">mdpi</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_DENSITY_MEDIUM = 160;
+
   /**
-   * Density: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#DensityQualifier">tvdpi</a>
+   * Density: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#DensityQualifier">tvdpi</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_DENSITY_TV = 213;
+
   /**
-   * Density: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#DensityQualifier">hdpi</a>
+   * Density: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#DensityQualifier">hdpi</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_DENSITY_HIGH = 240;
+
   /**
-   * Density: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#DensityQualifier">xhdpi</a>
+   * Density: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#DensityQualifier">xhdpi</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_DENSITY_XHIGH = 320;
+
   /**
-   * Density: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#DensityQualifier">xxhdpi</a>
+   * Density: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#DensityQualifier">xxhdpi</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_DENSITY_XXHIGH = 480;
+
   /**
-   * Density: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#DensityQualifier">xxxhdpi</a>
+   * Density: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#DensityQualifier">xxxhdpi</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_DENSITY_XXXHIGH = 640;
+
   /** Density: any density. */
   public static final int ACONFIGURATION_DENSITY_ANY = 0xfffe;
+
   /** Density: no density specified. */
   public static final int ACONFIGURATION_DENSITY_NONE = 0xffff;
+
   /** Keyboard: not specified. */
-  public static final int ACONFIGURATION_KEYBOARD_ANY  = 0x0000;
+  public static final int ACONFIGURATION_KEYBOARD_ANY = 0x0000;
+
   /**
-   * Keyboard: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#ImeQualifier">nokeys</a>
+   * Keyboard: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#ImeQualifier">nokeys</a>
    * resource qualifier.
    */
-  public static final int ACONFIGURATION_KEYBOARD_NOKEYS  = 0x0001;
+  public static final int ACONFIGURATION_KEYBOARD_NOKEYS = 0x0001;
+
   /**
-   * Keyboard: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#ImeQualifier">qwerty</a>
+   * Keyboard: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#ImeQualifier">qwerty</a>
    * resource qualifier.
    */
-  public static final int ACONFIGURATION_KEYBOARD_QWERTY  = 0x0002;
+  public static final int ACONFIGURATION_KEYBOARD_QWERTY = 0x0002;
+
   /**
-   * Keyboard: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#ImeQualifier">12key</a>
-   * resource qualifier.
+   * Keyboard: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#ImeQualifier">12key</a> resource
+   * qualifier.
    */
-  public static final int ACONFIGURATION_KEYBOARD_12KEY  = 0x0003;
+  public static final int ACONFIGURATION_KEYBOARD_12KEY = 0x0003;
+
   /** Navigation: not specified. */
-  public static final int ACONFIGURATION_NAVIGATION_ANY  = 0x0000;
+  public static final int ACONFIGURATION_NAVIGATION_ANY = 0x0000;
+
   /**
-   * Navigation: value corresponding to the
-   * <a href="@@dacRoot/guide/topics/resources/providing-resources.html#NavigationQualifier">nonav</a>
+   * Navigation: value corresponding to the <a
+   * href="@@dacRoot/guide/topics/resources/providing-resources.html#NavigationQualifier">nonav</a>
    * resource qualifier.
    */
-  public static final int ACONFIGURATION_NAVIGATION_NONAV  = 0x0001;
+  public static final int ACONFIGURATION_NAVIGATION_NONAV = 0x0001;
+
   /**
-   * Navigation: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#NavigationQualifier">dpad</a>
+   * Navigation: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#NavigationQualifier">dpad</a>
    * resource qualifier.
    */
-  public static final int ACONFIGURATION_NAVIGATION_DPAD  = 0x0002;
+  public static final int ACONFIGURATION_NAVIGATION_DPAD = 0x0002;
+
   /**
-   * Navigation: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#NavigationQualifier">trackball</a>
+   * Navigation: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#NavigationQualifier">trackball</a>
    * resource qualifier.
    */
-  public static final int ACONFIGURATION_NAVIGATION_TRACKBALL  = 0x0003;
+  public static final int ACONFIGURATION_NAVIGATION_TRACKBALL = 0x0003;
+
   /**
-   * Navigation: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#NavigationQualifier">wheel</a>
+   * Navigation: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#NavigationQualifier">wheel</a>
    * resource qualifier.
    */
-  public static final int ACONFIGURATION_NAVIGATION_WHEEL  = 0x0004;
+  public static final int ACONFIGURATION_NAVIGATION_WHEEL = 0x0004;
+
   /** Keyboard availability: not specified. */
   public static final int ACONFIGURATION_KEYSHIDDEN_ANY = 0x0000;
+
   /**
-   * Keyboard availability: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#KeyboardAvailQualifier">keysexposed</a>
+   * Keyboard availability: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#KeyboardAvailQualifier">keysexposed</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_KEYSHIDDEN_NO = 0x0001;
+
   /**
-   * Keyboard availability: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#KeyboardAvailQualifier">keyshidden</a>
+   * Keyboard availability: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#KeyboardAvailQualifier">keyshidden</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_KEYSHIDDEN_YES = 0x0002;
+
   /**
-   * Keyboard availability: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#KeyboardAvailQualifier">keyssoft</a>
+   * Keyboard availability: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#KeyboardAvailQualifier">keyssoft</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_KEYSHIDDEN_SOFT = 0x0003;
+
   /** Navigation availability: not specified. */
   public static final int ACONFIGURATION_NAVHIDDEN_ANY = 0x0000;
+
   /**
-   * Navigation availability: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#NavAvailQualifier">navexposed</a>
+   * Navigation availability: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#NavAvailQualifier">navexposed</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_NAVHIDDEN_NO = 0x0001;
+
   /**
-   * Navigation availability: value corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#NavAvailQualifier">navhidden</a>
+   * Navigation availability: value corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#NavAvailQualifier">navhidden</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_NAVHIDDEN_YES = 0x0002;
+
   /** Screen size: not specified. */
-  public static final int ACONFIGURATION_SCREENSIZE_ANY  = 0x00;
+  public static final int ACONFIGURATION_SCREENSIZE_ANY = 0x00;
+
   /**
-   * Screen size: value indicating the screen is at least
-   * approximately 320x426 dp units, corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#ScreenSizeQualifier">small</a>
+   * Screen size: value indicating the screen is at least approximately 320x426 dp units,
+   * corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#ScreenSizeQualifier">small</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_SCREENSIZE_SMALL = 0x01;
+
   /**
-   * Screen size: value indicating the screen is at least
-   * approximately 320x470 dp units, corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#ScreenSizeQualifier">normal</a>
+   * Screen size: value indicating the screen is at least approximately 320x470 dp units,
+   * corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#ScreenSizeQualifier">normal</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_SCREENSIZE_NORMAL = 0x02;
+
   /**
-   * Screen size: value indicating the screen is at least
-   * approximately 480x640 dp units, corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#ScreenSizeQualifier">large</a>
+   * Screen size: value indicating the screen is at least approximately 480x640 dp units,
+   * corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#ScreenSizeQualifier">large</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_SCREENSIZE_LARGE = 0x03;
+
   /**
-   * Screen size: value indicating the screen is at least
-   * approximately 720x960 dp units, corresponding to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#ScreenSizeQualifier">xlarge</a>
+   * Screen size: value indicating the screen is at least approximately 720x960 dp units,
+   * corresponding to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#ScreenSizeQualifier">xlarge</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_SCREENSIZE_XLARGE = 0x04;
+
   /** Screen layout: not specified. */
   public static final int ACONFIGURATION_SCREENLONG_ANY = 0x00;
+
   /**
-   * Screen layout: value that corresponds to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#ScreenAspectQualifier">notlong</a>
+   * Screen layout: value that corresponds to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#ScreenAspectQualifier">notlong</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_SCREENLONG_NO = 0x1;
+
   /**
-   * Screen layout: value that corresponds to the
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#ScreenAspectQualifier">long</a>
+   * Screen layout: value that corresponds to the <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#ScreenAspectQualifier">long</a>
    * resource qualifier.
    */
   public static final int ACONFIGURATION_SCREENLONG_YES = 0x2;
+
   public static final int ACONFIGURATION_SCREENROUND_ANY = 0x00;
   public static final int ACONFIGURATION_SCREENROUND_NO = 0x1;
   public static final int ACONFIGURATION_SCREENROUND_YES = 0x2;
 
   /** Wide color gamut: not specified. */
   public static final int ACONFIGURATION_WIDE_COLOR_GAMUT_ANY = 0x00;
+
   /**
-   * Wide color gamut: value that corresponds to
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#WideColorGamutQualifier">no
+   * Wide color gamut: value that corresponds to <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#WideColorGamutQualifier">no
    * nowidecg</a> resource qualifier specified.
    */
   public static final int ACONFIGURATION_WIDE_COLOR_GAMUT_NO = 0x1;
+
   /**
-   * Wide color gamut: value that corresponds to
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#WideColorGamutQualifier">
+   * Wide color gamut: value that corresponds to <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#WideColorGamutQualifier">
    * widecg</a> resource qualifier specified.
    */
   public static final int ACONFIGURATION_WIDE_COLOR_GAMUT_YES = 0x2;
 
   /** HDR: not specified. */
   public static final int ACONFIGURATION_HDR_ANY = 0x00;
+
   /**
-   * HDR: value that corresponds to
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#HDRQualifier">
-   * lowdr</a> resource qualifier specified.
+   * HDR: value that corresponds to <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#HDRQualifier">lowdr</a> resource
+   * qualifier specified.
    */
   public static final int ACONFIGURATION_HDR_NO = 0x1;
+
   /**
-   * HDR: value that corresponds to
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#HDRQualifier">
-   * highdr</a> resource qualifier specified.
+   * HDR: value that corresponds to <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#HDRQualifier">highdr</a>
+   * resource qualifier specified.
    */
   public static final int ACONFIGURATION_HDR_YES = 0x2;
 
   /** UI mode: not specified. */
   public static final int ACONFIGURATION_UI_MODE_TYPE_ANY = 0x00;
+
   /**
-   * UI mode: value that corresponds to
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#UiModeQualifier">no
-   * UI mode type</a> resource qualifier specified.
+   * UI mode: value that corresponds to <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#UiModeQualifier">no UI mode
+   * type</a> resource qualifier specified.
    */
   public static final int ACONFIGURATION_UI_MODE_TYPE_NORMAL = 0x01;
+
   /**
-   * UI mode: value that corresponds to
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#UiModeQualifier">desk</a> resource qualifier specified.
+   * UI mode: value that corresponds to <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#UiModeQualifier">desk</a>
+   * resource qualifier specified.
    */
   public static final int ACONFIGURATION_UI_MODE_TYPE_DESK = 0x02;
+
   /**
-   * UI mode: value that corresponds to
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#UiModeQualifier">car</a> resource qualifier specified.
+   * UI mode: value that corresponds to <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#UiModeQualifier">car</a>
+   * resource qualifier specified.
    */
   public static final int ACONFIGURATION_UI_MODE_TYPE_CAR = 0x03;
+
   /**
-   * UI mode: value that corresponds to
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#UiModeQualifier">television</a> resource qualifier specified.
+   * UI mode: value that corresponds to <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#UiModeQualifier">television</a>
+   * resource qualifier specified.
    */
   public static final int ACONFIGURATION_UI_MODE_TYPE_TELEVISION = 0x04;
+
   /**
-   * UI mode: value that corresponds to
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#UiModeQualifier">appliance</a> resource qualifier specified.
+   * UI mode: value that corresponds to <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#UiModeQualifier">appliance</a>
+   * resource qualifier specified.
    */
   public static final int ACONFIGURATION_UI_MODE_TYPE_APPLIANCE = 0x05;
+
   /**
-   * UI mode: value that corresponds to
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#UiModeQualifier">watch</a> resource qualifier specified.
+   * UI mode: value that corresponds to <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#UiModeQualifier">watch</a>
+   * resource qualifier specified.
    */
   public static final int ACONFIGURATION_UI_MODE_TYPE_WATCH = 0x06;
-   /**
-  * UI mode: value that corresponds to
-  * <a href="@dacRoot/guide/topics/resources/providing-resources.html#UiModeQualifier">vr</a> resource qualifier specified.
-  */
+
+  /**
+   * UI mode: value that corresponds to <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#UiModeQualifier">vr</a> resource
+   * qualifier specified.
+   */
   public static final int ACONFIGURATION_UI_MODE_TYPE_VR_HEADSET = 0x07;
-  /** UI night mode: not specified.*/
+
+  /** UI night mode: not specified. */
   public static final int ACONFIGURATION_UI_MODE_NIGHT_ANY = 0x00;
+
   /**
-   * UI night mode: value that corresponds to
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#NightQualifier">notnight</a> resource qualifier specified.
+   * UI night mode: value that corresponds to <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#NightQualifier">notnight</a>
+   * resource qualifier specified.
    */
   public static final int ACONFIGURATION_UI_MODE_NIGHT_NO = 0x1;
+
   /**
-   * UI night mode: value that corresponds to
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#NightQualifier">night</a> resource qualifier specified.
+   * UI night mode: value that corresponds to <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#NightQualifier">night</a>
+   * resource qualifier specified.
    */
   public static final int ACONFIGURATION_UI_MODE_NIGHT_YES = 0x2;
+
   /** Screen width DPI: not specified. */
   public static final int ACONFIGURATION_SCREEN_WIDTH_DP_ANY = 0x0000;
+
   /** Screen height DPI: not specified. */
   public static final int ACONFIGURATION_SCREEN_HEIGHT_DP_ANY = 0x0000;
-  /** Smallest screen width DPI: not specified.*/
+
+  /** Smallest screen width DPI: not specified. */
   public static final int ACONFIGURATION_SMALLEST_SCREEN_WIDTH_DP_ANY = 0x0000;
+
   /** Layout direction: not specified. */
-  public static final int ACONFIGURATION_LAYOUTDIR_ANY  = 0x00;
+  public static final int ACONFIGURATION_LAYOUTDIR_ANY = 0x00;
+
   /**
-   * Layout direction: value that corresponds to
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#LayoutDirectionQualifier">ldltr</a> resource qualifier specified.
+   * Layout direction: value that corresponds to <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#LayoutDirectionQualifier">ldltr</a>
+   * resource qualifier specified.
    */
-  public static final int ACONFIGURATION_LAYOUTDIR_LTR  = 0x01;
+  public static final int ACONFIGURATION_LAYOUTDIR_LTR = 0x01;
+
   /**
-   * Layout direction: value that corresponds to
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#LayoutDirectionQualifier">ldrtl</a> resource qualifier specified.
+   * Layout direction: value that corresponds to <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#LayoutDirectionQualifier">ldrtl</a>
+   * resource qualifier specified.
    */
-  public static final int ACONFIGURATION_LAYOUTDIR_RTL  = 0x02;
+  public static final int ACONFIGURATION_LAYOUTDIR_RTL = 0x02;
+
   /**
-   * Bit mask for
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#MccQualifier">mcc</a>
+   * Bit mask for <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#MccQualifier">mcc</a>
    * configuration.
    */
   public static final int ACONFIGURATION_MCC = 0x0001;
+
   /**
-   * Bit mask for
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#MccQualifier">mnc</a>
+   * Bit mask for <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#MccQualifier">mnc</a>
    * configuration.
    */
   public static final int ACONFIGURATION_MNC = 0x0002;
+
   /**
-   * Bit mask for
-   * <a href="{@docRoot}guide/topics/resources/providing-resources.html#LocaleQualifier">locale</a>
+   * Bit mask for <a
+   * href="{@docRoot}guide/topics/resources/providing-resources.html#LocaleQualifier">locale</a>
    * configuration.
    */
   public static final int ACONFIGURATION_LOCALE = 0x0004;
+
   /**
-   * Bit mask for
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#TouchscreenQualifier">touchscreen</a>
+   * Bit mask for <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#TouchscreenQualifier">touchscreen</a>
    * configuration.
    */
   public static final int ACONFIGURATION_TOUCHSCREEN = 0x0008;
+
   /**
-   * Bit mask for
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#ImeQualifier">keyboard</a>
+   * Bit mask for <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#ImeQualifier">keyboard</a>
    * configuration.
    */
   public static final int ACONFIGURATION_KEYBOARD = 0x0010;
+
   /**
-   * Bit mask for
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#KeyboardAvailQualifier">keyboardHidden</a>
+   * Bit mask for <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#KeyboardAvailQualifier">keyboardHidden</a>
    * configuration.
    */
   public static final int ACONFIGURATION_KEYBOARD_HIDDEN = 0x0020;
+
   /**
-   * Bit mask for
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#NavigationQualifier">navigation</a>
+   * Bit mask for <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#NavigationQualifier">navigation</a>
    * configuration.
    */
   public static final int ACONFIGURATION_NAVIGATION = 0x0040;
+
   /**
-   * Bit mask for
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#OrientationQualifier">orientation</a>
+   * Bit mask for <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#OrientationQualifier">orientation</a>
    * configuration.
    */
   public static final int ACONFIGURATION_ORIENTATION = 0x0080;
+
   /**
-   * Bit mask for
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#DensityQualifier">density</a>
+   * Bit mask for <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#DensityQualifier">density</a>
    * configuration.
    */
   public static final int ACONFIGURATION_DENSITY = 0x0100;
+
   /**
-   * Bit mask for
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#ScreenSizeQualifier">screen size</a>
-   * configuration.
+   * Bit mask for <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#ScreenSizeQualifier">screen
+   * size</a> configuration.
    */
   public static final int ACONFIGURATION_SCREEN_SIZE = 0x0200;
+
   /**
-   * Bit mask for
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#VersionQualifier">platform version</a>
-   * configuration.
+   * Bit mask for <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#VersionQualifier">platform
+   * version</a> configuration.
    */
   public static final int ACONFIGURATION_VERSION = 0x0400;
-  /**
-   * Bit mask for screen layout configuration.
-   */
+
+  /** Bit mask for screen layout configuration. */
   public static final int ACONFIGURATION_SCREEN_LAYOUT = 0x0800;
+
   /**
-   * Bit mask for
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#UiModeQualifier">ui mode</a>
+   * Bit mask for <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#UiModeQualifier">ui mode</a>
    * configuration.
    */
   public static final int ACONFIGURATION_UI_MODE = 0x1000;
+
   /**
-   * Bit mask for
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#SmallestScreenWidthQualifier">smallest screen width</a>
-   * configuration.
+   * Bit mask for <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#SmallestScreenWidthQualifier">smallest
+   * screen width</a> configuration.
    */
   public static final int ACONFIGURATION_SMALLEST_SCREEN_SIZE = 0x2000;
+
   /**
-   * Bit mask for
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#LayoutDirectionQualifier">layout direction</a>
-   * configuration.
+   * Bit mask for <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#LayoutDirectionQualifier">layout
+   * direction</a> configuration.
    */
   public static final int ACONFIGURATION_LAYOUTDIR = 0x4000;
+
   public static final int ACONFIGURATION_SCREEN_ROUND = 0x8000;
+
   /**
-   * Bit mask for
-   * <a href="@dacRoot/guide/topics/resources/providing-resources.html#WideColorGamutQualifier">wide color gamut</a>
-   * and <a href="@dacRoot/guide/topics/resources/providing-resources.html#HDRQualifier">HDR</a> configurations.
+   * Bit mask for <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#WideColorGamutQualifier">wide
+   * color gamut</a> and <a
+   * href="@dacRoot/guide/topics/resources/providing-resources.html#HDRQualifier">HDR</a>
+   * configurations.
    */
   public static final int ACONFIGURATION_COLOR_MODE = 0x10000;
+
   /**
-   * Constant used to to represent MNC (Mobile Network Code) zero.
-   * 0 cannot be used, since it is used to represent an undefined MNC.
+   * Constant used to to represent MNC (Mobile Network Code) zero. 0 cannot be used, since it is
+   * used to represent an undefined MNC.
    */
   public static final int ACONFIGURATION_MNC_ZERO = 0xffff;
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/ApkAssetsCookie.java b/resources/src/main/java/org/robolectric/res/android/ApkAssetsCookie.java
index cf9791862..6164728a8 100644
--- a/resources/src/main/java/org/robolectric/res/android/ApkAssetsCookie.java
+++ b/resources/src/main/java/org/robolectric/res/android/ApkAssetsCookie.java
@@ -7,6 +7,7 @@ public class ApkAssetsCookie {
 
   // hey memory/gc optimization!
   private static final ApkAssetsCookie[] PREBAKED = new ApkAssetsCookie[256];
+
   static {
     for (int i = 0; i < PREBAKED.length; i++) {
       PREBAKED[i] = new ApkAssetsCookie(i);
diff --git a/resources/src/main/java/org/robolectric/res/android/Asset.java b/resources/src/main/java/org/robolectric/res/android/Asset.java
index 85e3629a0..54751b489 100644
--- a/resources/src/main/java/org/robolectric/res/android/Asset.java
+++ b/resources/src/main/java/org/robolectric/res/android/Asset.java
@@ -107,14 +107,14 @@ public abstract class Asset {
    */
   public abstract long seek(long offset, int whence);
 
-    /*
-     * Close the asset, freeing all associated resources.
-     */
-    public abstract void close();
+  /*
+   * Close the asset, freeing all associated resources.
+   */
+  public abstract void close();
 
-    /*
-     * Get a pointer to a buffer with the entire contents of the file.
-     */
+  /*
+   * Get a pointer to a buffer with the entire contents of the file.
+   */
   public abstract byte[] getBuffer(boolean wordAligned);
 
   /*
@@ -127,11 +127,11 @@ public abstract class Asset {
    */
   public abstract long getRemainingLength();
 
-    /*
-     * Open a new file descriptor that can be used to read this asset.
-     * Returns -1 if you can not use the file descriptor (for example if the
-     * asset is compressed).
-     */
+  /*
+   * Open a new file descriptor that can be used to read this asset.
+   * Returns -1 if you can not use the file descriptor (for example if the
+   * asset is compressed).
+   */
   public abstract FileDescriptor openFileDescriptor(Ref<Long> outStart, Ref<Long> outLength);
 
   public abstract File getFile();
@@ -151,164 +151,166 @@ public abstract class Asset {
    * This is NOT intended to be used for anything except debug output.
    * DO NOT try to parse this or use it to open a file.
    */
-  final String getAssetSource() { return mAssetSource.string(); }
+  final String getAssetSource() {
+    return mAssetSource.string();
+  }
 
   public abstract boolean isNinePatch();
 
-//   protected:
-//   /*
-//    * Adds this Asset to the global Asset list for debugging and
-//    * accounting.
-//    * Concrete subclasses must call this in their finalructor.
-//    */
-//   static void registerAsset(Asset asset);
-//
-//   /*
-//    * Removes this Asset from the global Asset list.
-//    * Concrete subclasses must call this in their destructor.
-//    */
-//   static void unregisterAsset(Asset asset);
-//
-//   Asset(void);        // finalructor; only invoked indirectly
-//
-//   /* handle common seek() housekeeping */
-//   long handleSeek(long offset, int whence, long curPosn, long maxPosn);
+  //   protected:
+  //   /*
+  //    * Adds this Asset to the global Asset list for debugging and
+  //    * accounting.
+  //    * Concrete subclasses must call this in their finalructor.
+  //    */
+  //   static void registerAsset(Asset asset);
+  //
+  //   /*
+  //    * Removes this Asset from the global Asset list.
+  //    * Concrete subclasses must call this in their destructor.
+  //    */
+  //   static void unregisterAsset(Asset asset);
+  //
+  //   Asset(void);        // finalructor; only invoked indirectly
+  //
+  //   /* handle common seek() housekeeping */
+  //   long handleSeek(long offset, int whence, long curPosn, long maxPosn);
 
   /* set the asset source string */
-  void setAssetSource(final String8 path) { mAssetSource = path; }
-
-  AccessMode getAccessMode() { return mAccessMode; }
-
-//   private:
-//   /* these operations are not implemented */
-//   Asset(final Asset& src);
-//   Asset& operator=(final Asset& src);
-//
-//     /* AssetManager needs access to our "create" functions */
-//   friend class AssetManager;
-//
-//     /*
-//      * Create the asset from a named file on disk.
-//      */
-//   static Asset createFromFile(final String fileName, AccessMode mode);
-//
-//     /*
-//      * Create the asset from a named, compressed file on disk (e.g. ".gz").
-//      */
-//   static Asset createFromCompressedFile(final String fileName,
-//       AccessMode mode);
-//
-// #if 0
-//     /*
-//      * Create the asset from a segment of an open file.  This will fail
-//      * if "offset" and "length" don't fit within the bounds of the file.
-//      *
-//      * The asset takes ownership of the file descriptor.
-//      */
-//   static Asset createFromFileSegment(int fd, long offset, int length,
-//       AccessMode mode);
-//
-//     /*
-//      * Create from compressed data.  "fd" should be seeked to the start of
-//      * the compressed data.  This could be inside a gzip file or part of a
-//      * Zip archive.
-//      *
-//      * The asset takes ownership of the file descriptor.
-//      *
-//      * This may not verify the validity of the compressed data until first
-//      * use.
-//      */
-//   static Asset createFromCompressedData(int fd, long offset,
-//       int compressionMethod, int compressedLength,
-//       int uncompressedLength, AccessMode mode);
-// #endif
-//
-//     /*
-//      * Create the asset from a memory-mapped file segment.
-//      *
-//      * The asset takes ownership of the FileMap.
-//      */
-//   static Asset createFromUncompressedMap(FileMap dataMap, AccessMode mode);
-//
-//     /*
-//      * Create the asset from a memory-mapped file segment with compressed
-//      * data.
-//      *
-//      * The asset takes ownership of the FileMap.
-//      */
-//   static Asset createFromCompressedMap(FileMap dataMap,
-//       int uncompressedLen, AccessMode mode);
-//
-//
-//     /*
-//      * Create from a reference-counted chunk of shared memory.
-//      */
-//   // TODO
-
-  AccessMode  mAccessMode;        // how the asset was opened
-  String8    mAssetSource;       // debug string
-
-  Asset		mNext;				// linked list.
-  Asset		mPrev;
+  void setAssetSource(final String8 path) {
+    mAssetSource = path;
+  }
+
+  AccessMode getAccessMode() {
+    return mAccessMode;
+  }
+
+  //   private:
+  //   /* these operations are not implemented */
+  //   Asset(final Asset& src);
+  //   Asset& operator=(final Asset& src);
+  //
+  //     /* AssetManager needs access to our "create" functions */
+  //   friend class AssetManager;
+  //
+  //     /*
+  //      * Create the asset from a named file on disk.
+  //      */
+  //   static Asset createFromFile(final String fileName, AccessMode mode);
+  //
+  //     /*
+  //      * Create the asset from a named, compressed file on disk (e.g. ".gz").
+  //      */
+  //   static Asset createFromCompressedFile(final String fileName,
+  //       AccessMode mode);
+  //
+  // #if 0
+  //     /*
+  //      * Create the asset from a segment of an open file.  This will fail
+  //      * if "offset" and "length" don't fit within the bounds of the file.
+  //      *
+  //      * The asset takes ownership of the file descriptor.
+  //      */
+  //   static Asset createFromFileSegment(int fd, long offset, int length,
+  //       AccessMode mode);
+  //
+  //     /*
+  //      * Create from compressed data.  "fd" should be seeked to the start of
+  //      * the compressed data.  This could be inside a gzip file or part of a
+  //      * Zip archive.
+  //      *
+  //      * The asset takes ownership of the file descriptor.
+  //      *
+  //      * This may not verify the validity of the compressed data until first
+  //      * use.
+  //      */
+  //   static Asset createFromCompressedData(int fd, long offset,
+  //       int compressionMethod, int compressedLength,
+  //       int uncompressedLength, AccessMode mode);
+  // #endif
+  //
+  //     /*
+  //      * Create the asset from a memory-mapped file segment.
+  //      *
+  //      * The asset takes ownership of the FileMap.
+  //      */
+  //   static Asset createFromUncompressedMap(FileMap dataMap, AccessMode mode);
+  //
+  //     /*
+  //      * Create the asset from a memory-mapped file segment with compressed
+  //      * data.
+  //      *
+  //      * The asset takes ownership of the FileMap.
+  //      */
+  //   static Asset createFromCompressedMap(FileMap dataMap,
+  //       int uncompressedLen, AccessMode mode);
+  //
+  //
+  //     /*
+  //      * Create from a reference-counted chunk of shared memory.
+  //      */
+  //   // TODO
+
+  AccessMode mAccessMode; // how the asset was opened
+  String8 mAssetSource; // debug string
+
+  Asset mNext; // linked list.
+  Asset mPrev;
 
   static final boolean kIsDebug = false;
 
-  final static Object gAssetLock = new Object();
+  static final Object gAssetLock = new Object();
   static int gCount = 0;
   static Asset gHead = null;
   static Asset gTail = null;
 
-  void registerAsset(Asset asset)
-  {
-  //   AutoMutex _l(gAssetLock);
-  //   gCount++;
-  //   asset.mNext = asset.mPrev = null;
-  //   if (gTail == null) {
-  //     gHead = gTail = asset;
-  //   } else {
-  //     asset.mPrev = gTail;
-  //     gTail.mNext = asset;
-  //     gTail = asset;
-  //   }
-  //
-  //   if (kIsDebug) {
-  //     ALOGI("Creating Asset %s #%d\n", asset, gCount);
-  //   }
+  void registerAsset(Asset asset) {
+    //   AutoMutex _l(gAssetLock);
+    //   gCount++;
+    //   asset.mNext = asset.mPrev = null;
+    //   if (gTail == null) {
+    //     gHead = gTail = asset;
+    //   } else {
+    //     asset.mPrev = gTail;
+    //     gTail.mNext = asset;
+    //     gTail = asset;
+    //   }
+    //
+    //   if (kIsDebug) {
+    //     ALOGI("Creating Asset %s #%d\n", asset, gCount);
+    //   }
   }
 
-  void unregisterAsset(Asset asset)
-  {
-  //   AutoMutex _l(gAssetLock);
-  //   gCount--;
-  //   if (gHead == asset) {
-  //     gHead = asset.mNext;
-  //   }
-  //   if (gTail == asset) {
-  //     gTail = asset.mPrev;
-  //   }
-  //   if (asset.mNext != null) {
-  //     asset.mNext.mPrev = asset.mPrev;
-  //   }
-  //   if (asset.mPrev != null) {
-  //     asset.mPrev.mNext = asset.mNext;
-  //   }
-  //   asset.mNext = asset.mPrev = null;
-  //
-  //   if (kIsDebug) {
-  //     ALOGI("Destroying Asset in %s #%d\n", asset, gCount);
-  //   }
+  void unregisterAsset(Asset asset) {
+    //   AutoMutex _l(gAssetLock);
+    //   gCount--;
+    //   if (gHead == asset) {
+    //     gHead = asset.mNext;
+    //   }
+    //   if (gTail == asset) {
+    //     gTail = asset.mPrev;
+    //   }
+    //   if (asset.mNext != null) {
+    //     asset.mNext.mPrev = asset.mPrev;
+    //   }
+    //   if (asset.mPrev != null) {
+    //     asset.mPrev.mNext = asset.mNext;
+    //   }
+    //   asset.mNext = asset.mPrev = null;
+    //
+    //   if (kIsDebug) {
+    //     ALOGI("Destroying Asset in %s #%d\n", asset, gCount);
+    //   }
   }
 
-  public static int getGlobalCount()
-  {
+  public static int getGlobalCount() {
     // AutoMutex _l(gAssetLock);
     synchronized (gAssetLock) {
       return gCount;
     }
   }
 
-  public static String getAssetAllocations()
-  {
+  public static String getAssetAllocations() {
     // AutoMutex _l(gAssetLock);
     synchronized (gAssetLock) {
       StringBuilder res = new StringBuilder();
@@ -317,8 +319,8 @@ public abstract class Asset {
         if (cur.isAllocated()) {
           res.append("    ");
           res.append(cur.getAssetSource());
-          long size = (cur.getLength()+512)/1024;
-          String buf = String.format(": %dK\n", (int)size);
+          long size = (cur.getLength() + 512) / 1024;
+          String buf = String.format(": %dK\n", (int) size);
           res.append(buf);
         }
         cur = cur.mNext;
@@ -339,8 +341,7 @@ public abstract class Asset {
    *
    * We can use "mode" to decide how we want to go about it.
    */
-  static Asset createFromFile(final String fileName, AccessMode mode)
-  {
+  static Asset createFromFile(final String fileName, AccessMode mode) {
     File file = new File(fileName);
     if (!file.exists()) {
       return null;
@@ -453,60 +454,56 @@ public abstract class Asset {
     // return pAsset;
   }
 
-
-//     #if 0
-// /*
-//  * Create a new Asset from part of an open file.
-//  */
-// /*static*/ Asset createFromFileSegment(int fd, long offset,
-//       int length, AccessMode mode)
-//   {
-//     _FileAsset pAsset;
-//     int result;
-//
-//     pAsset = new _FileAsset;
-//     result = pAsset.openChunk(null, fd, offset, length);
-//     if (result != NO_ERROR)
-//       return null;
-//
-//     pAsset.mAccessMode = mode;
-//     return pAsset;
-//   }
-//
-// /*
-//  * Create a new Asset from compressed data in an open file.
-//  */
-// /*static*/ Asset createFromCompressedData(int fd, long offset,
-//       int compressionMethod, int uncompressedLen, int compressedLen,
-//       AccessMode mode)
-//   {
-//     _CompressedAsset pAsset;
-//     int result;
-//
-//     pAsset = new _CompressedAsset;
-//     result = pAsset.openChunk(fd, offset, compressionMethod,
-//         uncompressedLen, compressedLen);
-//     if (result != NO_ERROR)
-//       return null;
-//
-//     pAsset.mAccessMode = mode;
-//     return pAsset;
-//   }
-//     #endif
+  //     #if 0
+  // /*
+  //  * Create a new Asset from part of an open file.
+  //  */
+  // /*static*/ Asset createFromFileSegment(int fd, long offset,
+  //       int length, AccessMode mode)
+  //   {
+  //     _FileAsset pAsset;
+  //     int result;
+  //
+  //     pAsset = new _FileAsset;
+  //     result = pAsset.openChunk(null, fd, offset, length);
+  //     if (result != NO_ERROR)
+  //       return null;
+  //
+  //     pAsset.mAccessMode = mode;
+  //     return pAsset;
+  //   }
+  //
+  // /*
+  //  * Create a new Asset from compressed data in an open file.
+  //  */
+  // /*static*/ Asset createFromCompressedData(int fd, long offset,
+  //       int compressionMethod, int uncompressedLen, int compressedLen,
+  //       AccessMode mode)
+  //   {
+  //     _CompressedAsset pAsset;
+  //     int result;
+  //
+  //     pAsset = new _CompressedAsset;
+  //     result = pAsset.openChunk(fd, offset, compressionMethod,
+  //         uncompressedLen, compressedLen);
+  //     if (result != NO_ERROR)
+  //       return null;
+  //
+  //     pAsset.mAccessMode = mode;
+  //     return pAsset;
+  //   }
+  //     #endif
 
   /*
    * Create a new Asset from a memory mapping.
    */
-  static Asset createFromUncompressedMap(FileMap dataMap,
-      AccessMode mode)
-  {
+  static Asset createFromUncompressedMap(FileMap dataMap, AccessMode mode) {
     _FileAsset pAsset;
     int result;
 
     pAsset = new _FileAsset();
     result = pAsset.openChunk(dataMap);
-    if (result != NO_ERROR)
-      return null;
+    if (result != NO_ERROR) return null;
 
     pAsset.mAccessMode = mode;
     return pAsset;
@@ -515,22 +512,18 @@ public abstract class Asset {
   /*
    * Create a new Asset from compressed data in a memory mapping.
    */
-static Asset createFromCompressedMap(FileMap dataMap,
-      int uncompressedLen, AccessMode mode)
-  {
+  static Asset createFromCompressedMap(FileMap dataMap, int uncompressedLen, AccessMode mode) {
     _CompressedAsset pAsset;
     int result;
 
     pAsset = new _CompressedAsset();
     result = pAsset.openChunk(dataMap, uncompressedLen);
-    if (result != NO_ERROR)
-      return null;
+    if (result != NO_ERROR) return null;
 
     pAsset.mAccessMode = mode;
     return pAsset;
   }
 
-
   /*
    * Do generic seek() housekeeping.  Pass in the offset/whence values from
    * the seek request, along with the current chunk offset and the chunk
@@ -538,8 +531,7 @@ static Asset createFromCompressedMap(FileMap dataMap,
    *
    * Returns the new chunk offset, or -1 if the seek is illegal.
    */
-  long handleSeek(long offset, int whence, long curPosn, long maxPosn)
-  {
+  long handleSeek(long offset, int whence, long curPosn, long maxPosn) {
     long newOffset;
 
     switch (whence) {
@@ -574,40 +566,46 @@ static Asset createFromCompressedMap(FileMap dataMap,
   static class _FileAsset extends Asset {
 
     // public:
-//     _FileAsset(void);
-//     virtual ~_FileAsset(void);
-//
-//     /*
-//      * Use a piece of an already-open file.
-//      *
-//      * On success, the object takes ownership of "fd".
-//      */
-//     int openChunk(final String fileName, int fd, long offset, int length);
-//
-//     /*
-//      * Use a memory-mapped region.
-//      *
-//      * On success, the object takes ownership of "dataMap".
-//      */
-//     int openChunk(FileMap dataMap);
-//
-//     /*
-//      * Standard Asset interfaces.
-//      */
-//     virtual ssize_t read(void* buf, int count);
-//     virtual long seek(long offset, int whence);
-//     virtual void close(void);
-//     virtual final void* getBuffer(boolean wordAligned);
+    //     _FileAsset(void);
+    //     virtual ~_FileAsset(void);
+    //
+    //     /*
+    //      * Use a piece of an already-open file.
+    //      *
+    //      * On success, the object takes ownership of "fd".
+    //      */
+    //     int openChunk(final String fileName, int fd, long offset, int length);
+    //
+    //     /*
+    //      * Use a memory-mapped region.
+    //      *
+    //      * On success, the object takes ownership of "dataMap".
+    //      */
+    //     int openChunk(FileMap dataMap);
+    //
+    //     /*
+    //      * Standard Asset interfaces.
+    //      */
+    //     virtual ssize_t read(void* buf, int count);
+    //     virtual long seek(long offset, int whence);
+    //     virtual void close(void);
+    //     virtual final void* getBuffer(boolean wordAligned);
 
     @Override
-    public long getLength() { return mLength; }
+    public long getLength() {
+      return mLength;
+    }
 
     @Override
-    public long getRemainingLength() { return mLength-mOffset; }
+    public long getRemainingLength() {
+      return mLength - mOffset;
+    }
 
-//     virtual int openFileDescriptor(long* outStart, long* outLength) final;
+    //     virtual int openFileDescriptor(long* outStart, long* outLength) final;
     @Override
-    boolean isAllocated() { return mBuf != null; }
+    boolean isAllocated() {
+      return mBuf != null;
+    }
 
     @Override
     public boolean isNinePatch() {
@@ -619,39 +617,39 @@ static Asset createFromCompressedMap(FileMap dataMap,
     }
 
     //
-// private:
-    long mStart;         // absolute file offset of start of chunk
-    long mLength;        // length of the chunk
-    long mOffset;        // current local offset, 0 == mStart
+    // private:
+    long mStart; // absolute file offset of start of chunk
+    long mLength; // length of the chunk
+    long mOffset; // current local offset, 0 == mStart
     // FILE*       mFp;            // for read/seek
-    RandomAccessFile mFp;            // for read/seek
-    String mFileName;      // for opening
+    RandomAccessFile mFp; // for read/seek
+    String mFileName; // for opening
 
     /*
      * To support getBuffer() we either need to read the entire thing into
      * a buffer or memory-map it.  For small files it's probably best to
      * just read them in.
      */
-// enum {
-  public static int kReadVsMapThreshold = 4096;
-// };
+    // enum {
+    public static int kReadVsMapThreshold = 4096;
+    // };
 
-    FileMap mMap;           // for memory map
-    byte[] mBuf;        // for read
+    FileMap mMap; // for memory map
+    byte[] mBuf; // for read
 
     // final void* ensureAlignment(FileMap map);
-/*
- * ===========================================================================
- *      _FileAsset
- * ===========================================================================
- */
+    /*
+     * ===========================================================================
+     *      _FileAsset
+     * ===========================================================================
+     */
 
     /*
      * Constructor.
      */
     _FileAsset()
-    // : mStart(0), mLength(0), mOffset(0), mFp(null), mFileName(null), mMap(null), mBuf(null)
-    {
+          // : mStart(0), mLength(0), mOffset(0), mFp(null), mFileName(null), mMap(null), mBuf(null)
+        {
       // Register the Asset with the global list here after it is fully constructed and its
       // vtable pointer points to this concrete type.
       registerAsset(this);
@@ -721,14 +719,14 @@ static Asset createFromCompressedMap(FileMap dataMap,
      * Create the chunk from the map.
      */
     int openChunk(FileMap dataMap) {
-      assert(mFp == null);    // no reopen
-      assert(mMap == null);
-      assert(dataMap != null);
+      assert (mFp == null); // no reopen
+      assert (mMap == null);
+      assert (dataMap != null);
 
       mMap = dataMap;
-      mStart = -1;            // not used
+      mStart = -1; // not used
       mLength = dataMap.getDataLength();
-      assert(mOffset == 0);
+      assert (mOffset == 0);
 
       mBuf = dataMap.getDataPtr();
 
@@ -743,48 +741,45 @@ static Asset createFromCompressedMap(FileMap dataMap,
       int maxLen;
       int actual;
 
-      assert(mOffset >= 0 && mOffset <= mLength);
+      assert (mOffset >= 0 && mOffset <= mLength);
 
       if (getAccessMode() == ACCESS_BUFFER) {
-          /*
-           * On first access, read or map the entire file.  The caller has
-           * requested buffer access, either because they're going to be
-           * using the buffer or because what they're doing has appropriate
-           * performance needs and access patterns.
-           */
-        if (mBuf == null)
-          getBuffer(false);
+        /*
+         * On first access, read or map the entire file.  The caller has
+         * requested buffer access, either because they're going to be
+         * using the buffer or because what they're doing has appropriate
+         * performance needs and access patterns.
+         */
+        if (mBuf == null) getBuffer(false);
       }
 
       /* adjust count if we're near EOF */
       maxLen = toIntExact(mLength - mOffset);
-      if (count > maxLen)
-        count = maxLen;
+      if (count > maxLen) count = maxLen;
 
       if (!isTruthy(count)) {
         return 0;
       }
 
       if (mMap != null) {
-          /* copy from mapped area */
-        //printf("map read\n");
+        /* copy from mapped area */
+        // printf("map read\n");
         // memcpy(buf, (String)mMap.getDataPtr() + mOffset, count);
         System.arraycopy(mMap.getDataPtr(), toIntExact(mOffset), buf, bufOffset, count);
         actual = count;
       } else if (mBuf != null) {
-          /* copy from buffer */
-        //printf("buf read\n");
+        /* copy from buffer */
+        // printf("buf read\n");
         // memcpy(buf, (String)mBuf + mOffset, count);
         System.arraycopy(mBuf, toIntExact(mOffset), buf, bufOffset, count);
         actual = count;
       } else {
-          /* read from the file */
-        //printf("file read\n");
+        /* read from the file */
+        // printf("file read\n");
         // if (ftell(mFp) != mStart + mOffset) {
         try {
           if (mFp.getFilePointer() != mStart + mOffset) {
-            ALOGE("Hosed: %d != %d+%d\n",
-                mFp.getFilePointer(), (long) mStart, (long) mOffset);
+            ALOGE("Hosed: %d != %d+%d\n", mFp.getFilePointer(), (long) mStart, (long) mOffset);
             assert false;
           }
 
@@ -796,10 +791,10 @@ static Asset createFromCompressedMap(FileMap dataMap,
            * hosed.
            */
           actual = mFp.read(buf, 0, count);
-          if (actual == 0)        // something failed -- I/O error?
-            return -1;
+          if (actual == 0) // something failed -- I/O error?
+          return -1;
 
-          assert(actual == count);
+          assert (actual == count);
         } catch (IOException e) {
           throw new RuntimeException(e);
         }
@@ -819,8 +814,7 @@ static Asset createFromCompressedMap(FileMap dataMap,
 
       // compute new position within chunk
       newPosn = handleSeek(offset, whence, mOffset, mLength);
-      if (newPosn == (long) -1)
-        return newPosn;
+      if (newPosn == (long) -1) return newPosn;
 
       actualOffset = mStart + newPosn;
 
@@ -873,11 +867,10 @@ static Asset createFromCompressedMap(FileMap dataMap,
     @Override
     public final byte[] getBuffer(boolean wordAligned) {
       /* subsequent requests just use what we did previously */
-      if (mBuf != null)
-        return mBuf;
+      if (mBuf != null) return mBuf;
       if (mMap != null) {
         // if (!wordAligned) {
-          return  mMap.getDataPtr();
+        return mMap.getDataPtr();
         // }
         // return ensureAlignment(mMap);
       }
@@ -888,11 +881,10 @@ static Asset createFromCompressedMap(FileMap dataMap,
         byte[] buf;
         int allocLen;
 
-          /* zero-length files are allowed; not sure about zero-len allocs */
-          /* (works fine with gcc + x86linux) */
+        /* zero-length files are allowed; not sure about zero-len allocs */
+        /* (works fine with gcc + x86linux) */
         allocLen = toIntExact(mLength);
-        if (mLength == 0)
-          allocLen = 1;
+        if (mLength == 0) allocLen = 1;
 
         buf = new byte[allocLen];
         if (buf == null) {
@@ -900,7 +892,7 @@ static Asset createFromCompressedMap(FileMap dataMap,
           return null;
         }
 
-        ALOGV("Asset %s allocating buffer size %d (smaller than threshold)", this, (int)allocLen);
+        ALOGV("Asset %s allocating buffer size %d (smaller than threshold)", this, (int) allocLen);
         if (mLength > 0) {
           try {
             // long oldPosn = ftell(mFp);
@@ -947,7 +939,7 @@ static Asset createFromCompressedMap(FileMap dataMap,
     /**
      * Return the file on disk representing this asset.
      *
-     * Non-Android framework method. Based on {@link #openFileDescriptor(Ref, Ref)}.
+     * <p>Non-Android framework method. Based on {@link #openFileDescriptor(Ref, Ref)}.
      */
     @Override
     public File getFile() {
@@ -1035,13 +1027,9 @@ static Asset createFromCompressedMap(FileMap dataMap,
     @Override
     public String toString() {
       if (mFileName == null) {
-        return "_FileAsset{" +
-            "mMap=" + mMap +
-            '}';
+        return "_FileAsset{" + "mMap=" + mMap + '}';
       } else {
-        return "_FileAsset{" +
-            "mFileName='" + mFileName + '\'' +
-            '}';
+        return "_FileAsset{" + "mFileName='" + mFileName + '\'' + '}';
       }
     }
   }
@@ -1050,38 +1038,42 @@ static Asset createFromCompressedMap(FileMap dataMap,
    * An asset based on compressed data in a file.
    */
   static class _CompressedAsset extends Asset {
-// public:
-//     _CompressedAsset(void);
-//     virtual ~_CompressedAsset(void);
-//
-//     /*
-//      * Use a piece of an already-open file.
-//      *
-//      * On success, the object takes ownership of "fd".
-//      */
-//     int openChunk(int fd, long offset, int compressionMethod,
-//     int uncompressedLen, int compressedLen);
-//
-//     /*
-//      * Use a memory-mapped region.
-//      *
-//      * On success, the object takes ownership of "fd".
-//      */
-//     int openChunk(FileMap dataMap, int uncompressedLen);
-//
-//     /*
-//      * Standard Asset interfaces.
-//      */
-//     virtual ssize_t read(void* buf, int count);
-//     virtual long seek(long offset, int whence);
-//     virtual void close(void);
-//     virtual final void* getBuffer(boolean wordAligned);
+    // public:
+    //     _CompressedAsset(void);
+    //     virtual ~_CompressedAsset(void);
+    //
+    //     /*
+    //      * Use a piece of an already-open file.
+    //      *
+    //      * On success, the object takes ownership of "fd".
+    //      */
+    //     int openChunk(int fd, long offset, int compressionMethod,
+    //     int uncompressedLen, int compressedLen);
+    //
+    //     /*
+    //      * Use a memory-mapped region.
+    //      *
+    //      * On success, the object takes ownership of "fd".
+    //      */
+    //     int openChunk(FileMap dataMap, int uncompressedLen);
+    //
+    //     /*
+    //      * Standard Asset interfaces.
+    //      */
+    //     virtual ssize_t read(void* buf, int count);
+    //     virtual long seek(long offset, int whence);
+    //     virtual void close(void);
+    //     virtual final void* getBuffer(boolean wordAligned);
 
     @Override
-    public long getLength() { return mUncompressedLen; }
+    public long getLength() {
+      return mUncompressedLen;
+    }
 
     @Override
-    public long getRemainingLength() { return mUncompressedLen-mOffset; }
+    public long getRemainingLength() {
+      return mUncompressedLen - mOffset;
+    }
 
     @Override
     public File getFile() {
@@ -1095,10 +1087,14 @@ static Asset createFromCompressedMap(FileMap dataMap,
     }
 
     @Override
-    public FileDescriptor openFileDescriptor(Ref<Long> outStart, Ref<Long> outLength) { return null; }
+    public FileDescriptor openFileDescriptor(Ref<Long> outStart, Ref<Long> outLength) {
+      return null;
+    }
 
     @Override
-    boolean isAllocated() { return mBuf != null; }
+    boolean isAllocated() {
+      return mBuf != null;
+    }
 
     @Override
     public boolean isNinePatch() {
@@ -1107,30 +1103,31 @@ static Asset createFromCompressedMap(FileMap dataMap,
     }
 
     // private:
-    long mStart;         // offset to start of compressed data
+    long mStart; // offset to start of compressed data
     long mCompressedLen; // length of the compressed data
     long mUncompressedLen; // length of the uncompressed data
-    long mOffset;        // current offset, 0 == start of uncomp data
+    long mOffset; // current offset, 0 == start of uncomp data
 
-    FileMap mMap;           // for memory-mapped input
-    int mFd;            // for file input
+    FileMap mMap; // for memory-mapped input
+    int mFd; // for file input
 
-// class StreamingZipInflater mZipInflater;  // for streaming large compressed assets
+    // class StreamingZipInflater mZipInflater;  // for streaming large compressed assets
 
-    byte[] mBuf;       // for getBuffer()
-/*
- * ===========================================================================
- *      _CompressedAsset
- * ===========================================================================
- */
+    byte[] mBuf; // for getBuffer()
+
+    /*
+     * ===========================================================================
+     *      _CompressedAsset
+     * ===========================================================================
+     */
 
     /*
      * Constructor.
      */
     _CompressedAsset()
-    // : mStart(0), mCompressedLen(0), mUncompressedLen(0), mOffset(0),
-    // mMap(null), mFd(-1), mZipInflater(null), mBuf(null)
-    {
+          // : mStart(0), mCompressedLen(0), mUncompressedLen(0), mOffset(0),
+          // mMap(null), mFd(-1), mZipInflater(null), mBuf(null)
+        {
       mFd = -1;
 
       // Register the Asset with the global list here after it is fully constructed and its
@@ -1175,8 +1172,8 @@ static Asset createFromCompressedMap(FileMap dataMap,
      * This currently just sets up some values and returns.  On the first
      * read, we expand the entire file into a buffer and return data from it.
      */
-    int openChunk(int fd, long offset,
-        int compressionMethod, int uncompressedLen, int compressedLen) {
+    int openChunk(
+        int fd, long offset, int compressionMethod, int uncompressedLen, int compressedLen) {
       throw new UnsupportedOperationException();
       // assert(mFd < 0);        // no re-open
       // assert(mMap == null);
@@ -1209,15 +1206,15 @@ static Asset createFromCompressedMap(FileMap dataMap,
      * Nothing is expanded until the first read call.
      */
     int openChunk(FileMap dataMap, int uncompressedLen) {
-      assert(mFd < 0);        // no re-open
-      assert(mMap == null);
-      assert(dataMap != null);
+      assert (mFd < 0); // no re-open
+      assert (mMap == null);
+      assert (dataMap != null);
 
       mMap = dataMap;
-      mStart = -1;        // not used
+      mStart = -1; // not used
       mCompressedLen = dataMap.getDataLength();
       mUncompressedLen = uncompressedLen;
-      assert(mOffset == 0);
+      assert (mOffset == 0);
 
       // if (uncompressedLen > StreamingZipInflater::OUTPUT_CHUNK_SIZE) {
       // mZipInflater = new StreamingZipInflater(dataMap, uncompressedLen);
@@ -1235,32 +1232,29 @@ static Asset createFromCompressedMap(FileMap dataMap,
       int maxLen;
       int actual;
 
-      assert(mOffset >= 0 && mOffset <= mUncompressedLen);
+      assert (mOffset >= 0 && mOffset <= mUncompressedLen);
 
-       /* If we're relying on a streaming inflater, go through that */
-//       if (mZipInflater) {
-//       actual = mZipInflater.read(buf, count);
-//       } else {
+      /* If we're relying on a streaming inflater, go through that */
+      //       if (mZipInflater) {
+      //       actual = mZipInflater.read(buf, count);
+      //       } else {
       if (mBuf == null) {
-        if (getBuffer(false) == null)
-          return -1;
+        if (getBuffer(false) == null) return -1;
       }
-      assert(mBuf != null);
+      assert (mBuf != null);
 
       /* adjust count if we're near EOF */
       maxLen = toIntExact(mUncompressedLen - mOffset);
-      if (count > maxLen)
-        count = maxLen;
+      if (count > maxLen) count = maxLen;
 
-      if (!isTruthy(count))
-        return 0;
+      if (!isTruthy(count)) return 0;
 
       /* copy from buffer */
-      //printf("comp buf read\n");
-//      memcpy(buf, (String)mBuf + mOffset, count);
+      // printf("comp buf read\n");
+      //      memcpy(buf, (String)mBuf + mOffset, count);
       System.arraycopy(mBuf, toIntExact(mOffset), buf, bufOffset, count);
       actual = count;
-//       }
+      //       }
 
       mOffset += actual;
       return actual;
@@ -1293,21 +1287,21 @@ static Asset createFromCompressedMap(FileMap dataMap,
      */
     @Override
     public void close() {
-       if (mMap != null) {
-//       delete mMap;
-       mMap = null;
-       }
+      if (mMap != null) {
+        //       delete mMap;
+        mMap = null;
+      }
 
-//       delete[] mBuf;
-       mBuf = null;
+      //       delete[] mBuf;
+      mBuf = null;
 
-//       delete mZipInflater;
-//       mZipInflater = null;
+      //       delete mZipInflater;
+      //       mZipInflater = null;
 
-       if (mFd > 0) {
-//       ::close(mFd);
-       mFd = -1;
-       }
+      if (mFd > 0) {
+        //       ::close(mFd);
+        mFd = -1;
+      }
     }
 
     /*
@@ -1321,8 +1315,7 @@ static Asset createFromCompressedMap(FileMap dataMap,
       // return mBuf = mMap.getDataPtr();
       byte[] buf = null;
 
-      if (mBuf != null)
-        return mBuf;
+      if (mBuf != null) return mBuf;
 
       /*
        * Allocate a buffer and read the file into it.
@@ -1373,17 +1366,15 @@ static Asset createFromCompressedMap(FileMap dataMap,
 
     @Override
     public String toString() {
-      return "_CompressedAsset{" +
-          "mMap=" + mMap +
-          '}';
+      return "_CompressedAsset{" + "mMap=" + mMap + '}';
     }
   }
 
   // todo: remove when Android supports this
   static int toIntExact(long value) {
-    if ((int)value != value) {
+    if ((int) value != value) {
       throw new ArithmeticException("integer overflow");
     }
-    return (int)value;
+    return (int) value;
   }
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/AssetDir.java b/resources/src/main/java/org/robolectric/res/android/AssetDir.java
index fcf97cb82..7fb65e911 100644
--- a/resources/src/main/java/org/robolectric/res/android/AssetDir.java
+++ b/resources/src/main/java/org/robolectric/res/android/AssetDir.java
@@ -2,7 +2,8 @@ package org.robolectric.res.android;
 
 import org.robolectric.res.android.CppAssetManager.FileType;
 
-// transliterated from https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/AssetDir.cpp and
+// transliterated from
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/AssetDir.cpp and
 // https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/include/androidfw/AssetDir.h
 public class AssetDir {
 
@@ -12,13 +13,11 @@ public class AssetDir {
     mFileInfo = null;
   }
 
-  AssetDir(AssetDir src) {
-
-  }
+  AssetDir(AssetDir src) {}
 
   /*
- * Vector-style access.
- */
+   * Vector-style access.
+   */
   public int getFileCount() {
     if (mFileInfo == null) {
       return 0;
@@ -30,40 +29,39 @@ public class AssetDir {
     return mFileInfo.itemAt(idx).getFileName();
   }
 
-//    const String8& getSourceName(int idx) {
-//    return mFileInfo->itemAt(idx).getSourceName();
-//  }
+  //    const String8& getSourceName(int idx) {
+  //    return mFileInfo->itemAt(idx).getSourceName();
+  //  }
 
   /*
    * Get the type of a file (usually regular or directory).
    */
-//  FileType getFileType(int idx) {
-//    return mFileInfo->itemAt(idx).getFileType();
-//  }
+  //  FileType getFileType(int idx) {
+  //    return mFileInfo->itemAt(idx).getFileType();
+  //  }
 
-  /**
-   * This holds information about files in the asset hierarchy.
-   */
+  /** This holds information about files in the asset hierarchy. */
   static class FileInfo implements Comparable<FileInfo> {
-    private String8    mFileName;    // filename only
-    private FileType mFileType;      // regular, directory, etc
-    private String8    mSourceName;  // currently debug-only
+    private String8 mFileName; // filename only
+    private FileType mFileType; // regular, directory, etc
+    private String8 mSourceName; // currently debug-only
 
     FileInfo() {}
 
-    FileInfo(String8 path) {      // useful for e.g. svect.indexOf
-            mFileName = path;
-            mFileType = FileType.kFileTypeUnknown;
+    FileInfo(String8 path) { // useful for e.g. svect.indexOf
+      mFileName = path;
+      mFileType = FileType.kFileTypeUnknown;
     }
 
     FileInfo(FileInfo src) {
       copyMembers(src);
     }
-//        const FileInfo& operator= (const FileInfo& src) {
-//      if (this != &src)
-//        copyMembers(src);
-//      return *this;
-//    }
+
+    //        const FileInfo& operator= (const FileInfo& src) {
+    //      if (this != &src)
+    //        copyMembers(src);
+    //      return *this;
+    //    }
 
     void copyMembers(final FileInfo src) {
       mFileName = src.mFileName;
@@ -72,28 +70,43 @@ public class AssetDir {
     }
 
     /* need this for SortedVector; must compare only on file name */
-//    bool operator< (const FileInfo& rhs) const {
-//      return mFileName < rhs.mFileName;
-//    }
-//
-//    /* used by AssetManager */
-//    bool operator== (const FileInfo& rhs) const {
-//      return mFileName == rhs.mFileName;
-//    }
+    //    bool operator< (const FileInfo& rhs) const {
+    //      return mFileName < rhs.mFileName;
+    //    }
+    //
+    //    /* used by AssetManager */
+    //    bool operator== (const FileInfo& rhs) const {
+    //      return mFileName == rhs.mFileName;
+    //    }
 
     void set(final String8 path, FileType type) {
       mFileName = path;
       mFileType = type;
     }
 
-    String8 getFileName()  { return mFileName; }
-    void setFileName(String8 path) { mFileName = path; }
+    String8 getFileName() {
+      return mFileName;
+    }
+
+    void setFileName(String8 path) {
+      mFileName = path;
+    }
+
+    FileType getFileType() {
+      return mFileType;
+    }
+
+    void setFileType(FileType type) {
+      mFileType = type;
+    }
 
-    FileType getFileType() { return mFileType; }
-    void setFileType(FileType type) { mFileType = type; }
+    String8 getSourceName() {
+      return mSourceName;
+    }
 
-    String8 getSourceName() { return mSourceName; }
-    void setSourceName(String8 path) { mSourceName = path; }
+    void setSourceName(String8 path) {
+      mSourceName = path;
+    }
 
     public boolean isLessThan(FileInfo fileInfo) {
       return mFileName.string().compareTo(fileInfo.mFileName.string()) < 0;
@@ -108,18 +121,17 @@ public class AssetDir {
      * Handy utility for finding an entry in a sorted vector of FileInfo.
      * Returns the index of the matching entry, or -1 if none found.
      */
-    static int findEntry(SortedVector<FileInfo> pVector,
-             String8 fileName) {
+    static int findEntry(SortedVector<FileInfo> pVector, String8 fileName) {
       FileInfo tmpInfo = new FileInfo();
 
       tmpInfo.setFileName(fileName);
       return pVector.indexOf(tmpInfo);
     }
-
-
-  };
+  }
+  ;
 
   /* AssetManager uses this to initialize us */
-  void setFileList(SortedVector<FileInfo> list) { mFileInfo = list; }
-
+  void setFileList(SortedVector<FileInfo> list) {
+    mFileInfo = list;
+  }
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/AttributeResolution.java b/resources/src/main/java/org/robolectric/res/android/AttributeResolution.java
index 752e0f482..57ab24a8b 100644
--- a/resources/src/main/java/org/robolectric/res/android/AttributeResolution.java
+++ b/resources/src/main/java/org/robolectric/res/android/AttributeResolution.java
@@ -61,10 +61,16 @@ public class AttributeResolution {
     }
   }
 
-  public static boolean ResolveAttrs(ResTableTheme theme, int defStyleAttr,
-                                     int defStyleRes, int[] srcValues,
-                                     int srcValuesLength, int[] attrs,
-                                     int attrsLength, int[] outValues, int[] outIndices) {
+  public static boolean ResolveAttrs(
+      ResTableTheme theme,
+      int defStyleAttr,
+      int defStyleRes,
+      int[] srcValues,
+      int srcValuesLength,
+      int[] attrs,
+      int attrsLength,
+      int[] outValues,
+      int[] outIndices) {
     if (kDebugStyles) {
       ALOGI(
           "APPLY STYLE: theme=%s defStyleAttr=0x%x defStyleRes=0x%x",
@@ -95,17 +101,18 @@ public class AttributeResolution {
     // Retrieve the default style bag, if requested.
     final Ref<ResTable.bag_entry[]> defStyleStart = new Ref<>(null);
     Ref<Integer> defStyleTypeSetFlags = new Ref<>(0);
-    int bagOff = defStyleRes != 0
-        ? res.getBagLocked(defStyleRes, defStyleStart, defStyleTypeSetFlags) : -1;
+    int bagOff =
+        defStyleRes != 0 ? res.getBagLocked(defStyleRes, defStyleStart, defStyleTypeSetFlags) : -1;
     defStyleTypeSetFlags.set(defStyleTypeSetFlags.get() | defStyleBagTypeSetFlags.get());
-//    const ResTable::bag_entry* const defStyleEnd = defStyleStart + (bagOff >= 0 ? bagOff : 0);
+    //    const ResTable::bag_entry* const defStyleEnd = defStyleStart + (bagOff >= 0 ? bagOff : 0);
     final int defStyleEnd = (bagOff >= 0 ? bagOff : 0);
-    BagAttributeFinder defStyleAttrFinder = new BagAttributeFinder(defStyleStart.get(), defStyleEnd);
+    BagAttributeFinder defStyleAttrFinder =
+        new BagAttributeFinder(defStyleStart.get(), defStyleEnd);
 
     // Now iterate through all of the attributes that the client has requested,
     // filling in each with whatever data we can find.
     int destOffset = 0;
-    for (int ii=0; ii<attrsLength; ii++) {
+    for (int ii = 0; ii < attrsLength; ii++) {
       final int curIdent = attrs[ii];
 
       if (kDebugStyles) {
@@ -147,8 +154,8 @@ public class AttributeResolution {
       Ref<ResTable_config> configRef = new Ref<>(config);
       if (value.dataType != Res_value.TYPE_NULL) {
         // Take care of resolving the found resource to its final value.
-        int newBlock = theme.resolveAttributeReference(valueRef, block,
-            residRef, typeSetFlagsRef, configRef);
+        int newBlock =
+            theme.resolveAttributeReference(valueRef, block, residRef, typeSetFlagsRef, configRef);
         value = valueRef.get();
         resid = residRef.get();
         typeSetFlags = typeSetFlagsRef.get();
@@ -195,15 +202,13 @@ public class AttributeResolution {
       }
 
       if (kDebugStyles) {
-        ALOGI("Attribute 0x%08x: type=0x%x, data=0x%08x", curIdent, value.dataType,
-            value.data);
+        ALOGI("Attribute 0x%08x: type=0x%x, data=0x%08x", curIdent, value.dataType, value.data);
       }
 
       // Write the final value back to Java.
       outValues[destOffset + STYLE_TYPE] = value.dataType;
       outValues[destOffset + STYLE_DATA] = value.data;
-      outValues[destOffset + STYLE_ASSET_COOKIE] =
-          block != -1 ? res.getTableCookie(block) : -1;
+      outValues[destOffset + STYLE_ASSET_COOKIE] = block != -1 ? res.getTableCookie(block) : -1;
       outValues[destOffset + STYLE_RESOURCE_ID] = resid;
       outValues[destOffset + STYLE_CHANGING_CONFIGURATIONS] = typeSetFlags;
       outValues[destOffset + STYLE_DENSITY] = config.density;
@@ -224,10 +229,18 @@ public class AttributeResolution {
     return true;
   }
 
-  public static void ApplyStyle(ResTableTheme theme, ResXMLParser xmlParser, int defStyleAttr, int defStyleRes,
-                                int[] attrs, int attrsLength, int[] outValues, int[] outIndices) {
+  public static void ApplyStyle(
+      ResTableTheme theme,
+      ResXMLParser xmlParser,
+      int defStyleAttr,
+      int defStyleRes,
+      int[] attrs,
+      int attrsLength,
+      int[] outValues,
+      int[] outIndices) {
     if (kDebugStyles) {
-      ALOGI("APPLY STYLE: theme=%s defStyleAttr=0x%x defStyleRes=0x%x xml=%s",
+      ALOGI(
+          "APPLY STYLE: theme=%s defStyleAttr=0x%x defStyleRes=0x%x xml=%s",
           theme, defStyleAttr, defStyleRes, xmlParser);
     }
 
@@ -270,25 +283,25 @@ public class AttributeResolution {
     // Retrieve the default style bag, if requested.
     final Ref<ResTable.bag_entry[]> defStyleAttrStart = new Ref<>(null);
     Ref<Integer> defStyleTypeSetFlags = new Ref<>(0);
-    int bagOff = defStyleRes != 0
-        ? res.getBagLocked(defStyleRes, defStyleAttrStart, defStyleTypeSetFlags)
-        : -1;
+    int bagOff =
+        defStyleRes != 0
+            ? res.getBagLocked(defStyleRes, defStyleAttrStart, defStyleTypeSetFlags)
+            : -1;
     defStyleTypeSetFlags.set(defStyleTypeSetFlags.get() | defStyleBagTypeSetFlags.get());
     // const ResTable::bag_entry* defStyleAttrEnd = defStyleAttrStart + (bagOff >= 0 ? bagOff : 0);
     final ResTable.bag_entry defStyleAttrEnd = null;
-    // BagAttributeFinder defStyleAttrFinder = new BagAttributeFinder(defStyleAttrStart, defStyleAttrEnd);
+    // BagAttributeFinder defStyleAttrFinder = new BagAttributeFinder(defStyleAttrStart,
+    // defStyleAttrEnd);
     BagAttributeFinder defStyleAttrFinder = new BagAttributeFinder(defStyleAttrStart.get(), bagOff);
 
     // Retrieve the style class bag, if requested.
     final Ref<ResTable.bag_entry[]> styleAttrStart = new Ref<>(null);
     Ref<Integer> styleTypeSetFlags = new Ref<>(0);
-    bagOff = style != 0
-        ? res.getBagLocked(style, styleAttrStart, styleTypeSetFlags)
-        : -1;
+    bagOff = style != 0 ? res.getBagLocked(style, styleAttrStart, styleTypeSetFlags) : -1;
     styleTypeSetFlags.set(styleTypeSetFlags.get() | styleBagTypeSetFlags.get());
     // final ResTable::bag_entry* final styleAttrEnd = styleAttrStart + (bagOff >= 0 ? bagOff : 0);
     final ResTable.bag_entry styleAttrEnd = null;
-    //BagAttributeFinder styleAttrFinder = new BagAttributeFinder(styleAttrStart, styleAttrEnd);
+    // BagAttributeFinder styleAttrFinder = new BagAttributeFinder(styleAttrStart, styleAttrEnd);
     BagAttributeFinder styleAttrFinder = new BagAttributeFinder(styleAttrStart.get(), bagOff);
 
     // Retrieve the XML attributes, if requested.
@@ -325,7 +338,8 @@ public class AttributeResolution {
         }
       }
 
-      if (value.get().dataType == DataType.NULL.code() && value.get().data != Res_value.DATA_NULL_EMPTY) {
+      if (value.get().dataType == DataType.NULL.code()
+          && value.get().data != Res_value.DATA_NULL_EMPTY) {
         // Walk through the style class values looking for the requested attribute.
         final ResTable.bag_entry styleAttrEntry = styleAttrFinder.find(curIdent);
         if (styleAttrEntry != styleAttrEnd) {
@@ -339,7 +353,8 @@ public class AttributeResolution {
         }
       }
 
-      if (value.get().dataType == DataType.NULL.code() && value.get().data != Res_value.DATA_NULL_EMPTY) {
+      if (value.get().dataType == DataType.NULL.code()
+          && value.get().data != Res_value.DATA_NULL_EMPTY) {
         // Walk through the default style values looking for the requested attribute.
         final ResTable.bag_entry defStyleAttrEntry = defStyleAttrFinder.find(curIdent);
         if (defStyleAttrEntry != defStyleAttrEnd) {
@@ -358,8 +373,7 @@ public class AttributeResolution {
       Ref<Integer> resid = new Ref<>(0);
       if (value.get().dataType != DataType.NULL.code()) {
         // Take care of resolving the found resource to its final value.
-        int newBlock = theme.resolveAttributeReference(value, block,
-            resid, typeSetFlags, config);
+        int newBlock = theme.resolveAttributeReference(value, block, resid, typeSetFlags, config);
         if (newBlock >= 0) {
           block = newBlock;
         }
@@ -413,7 +427,8 @@ public class AttributeResolution {
       outValues[destIndex + STYLE_CHANGING_CONFIGURATIONS] = typeSetFlags.get();
       outValues[destIndex + STYLE_DENSITY] = config.get().density;
 
-      if (res_value.dataType != DataType.NULL.code() || res_value.data == Res_value.DATA_NULL_EMPTY) {
+      if (res_value.dataType != DataType.NULL.code()
+          || res_value.data == Res_value.DATA_NULL_EMPTY) {
         indices_idx++;
 
         // out_indices must NOT be nullptr.
@@ -427,11 +442,10 @@ public class AttributeResolution {
         boolean gotRefName = res.getResourceName(res_value.data, true, attrRefName);
         Logger.warn(
             "Failed to resolve attribute lookup: %s=\"?%s\"; theme: %s",
-            gotName ? attrName : "unknown", gotRefName ? attrRefName : "unknown",
-            theme);
+            gotName ? attrName : "unknown", gotRefName ? attrRefName : "unknown", theme);
       }
 
-//      out_values += STYLE_NUM_ENTRIES;
+      //      out_values += STYLE_NUM_ENTRIES;
     }
 
     res.unlock();
@@ -440,7 +454,13 @@ public class AttributeResolution {
     outIndices[0] = indices_idx;
   }
 
-  public static boolean RetrieveAttributes(ResTable res, ResXMLParser xmlParser, int[] attrs, int attrsLength, int[] outValues, int[] outIndices) {
+  public static boolean RetrieveAttributes(
+      ResTable res,
+      ResXMLParser xmlParser,
+      int[] attrs,
+      int attrsLength,
+      int[] outValues,
+      int[] outIndices) {
     Ref<ResTable_config> config = new Ref<>(new ResTable_config());
     Ref<Res_value> value = new Ref<>(null);
 
@@ -451,7 +471,7 @@ public class AttributeResolution {
 
     // Retrieve the XML attributes, if requested.
     final int xmlAttrCount = xmlParser.getAttributeCount();
-    int ix=0;
+    int ix = 0;
     int curXmlAttr = xmlParser.getAttributeNameResID(ix);
 
     final int kXmlBlock = 0x10000000;
@@ -459,7 +479,7 @@ public class AttributeResolution {
     // Now iterate through all of the attributes that the client has requested,
     // filling in each with whatever data we can find.
     int baseDest = 0;
-    for (int ii=0; ii<attrsLength; ii++) {
+    for (int ii = 0; ii < attrsLength; ii++) {
       final int curIdent = attrs[ii];
       int block = 0;
       Ref<Integer> typeSetFlags = new Ref<>(0);
@@ -481,13 +501,12 @@ public class AttributeResolution {
         curXmlAttr = xmlParser.getAttributeNameResID(ix);
       }
 
-      //printf("Attribute 0x%08x: type=0x%x, data=0x%08x\n", curIdent, value.dataType, value.data);
+      // printf("Attribute 0x%08x: type=0x%x, data=0x%08x\n", curIdent, value.dataType, value.data);
       Ref<Integer> resid = new Ref<>(0);
       if (value.get().dataType != Res_value.TYPE_NULL) {
         // Take care of resolving the found resource to its final value.
-        //printf("Resolving attribute reference\n");
-        int newBlock = res.resolveReference(value, block, resid,
-            typeSetFlags, config);
+        // printf("Resolving attribute reference\n");
+        int newBlock = res.resolveReference(value, block, resid, typeSetFlags, config);
         if (newBlock >= 0) block = newBlock;
       }
 
@@ -497,7 +516,8 @@ public class AttributeResolution {
         block = kXmlBlock;
       }
 
-      //printf("Attribute 0x%08x: final type=0x%x, data=0x%08x\n", curIdent, value.dataType, value.data);
+      // printf("Attribute 0x%08x: final type=0x%x, data=0x%08x\n", curIdent, value.dataType,
+      // value.data);
 
       // Write the final value back to Java.
       outValues[baseDest + STYLE_TYPE] = value.get().dataType;
@@ -508,13 +528,14 @@ public class AttributeResolution {
       outValues[baseDest + STYLE_CHANGING_CONFIGURATIONS] = typeSetFlags.get();
       outValues[baseDest + STYLE_DENSITY] = config.get().density;
 
-      if (outIndices != null &&
-          (value.get().dataType != Res_value.TYPE_NULL || value.get().data == Res_value.DATA_NULL_EMPTY)) {
+      if (outIndices != null
+          && (value.get().dataType != Res_value.TYPE_NULL
+              || value.get().data == Res_value.DATA_NULL_EMPTY)) {
         indices_idx++;
         outIndices[indices_idx] = ii;
       }
 
-//      dest += STYLE_NUM_ENTRIES;
+      //      dest += STYLE_NUM_ENTRIES;
       baseDest += STYLE_NUM_ENTRIES;
     }
 
diff --git a/resources/src/main/java/org/robolectric/res/android/AttributeResolution10.java b/resources/src/main/java/org/robolectric/res/android/AttributeResolution10.java
index 2d5d73482..3e5e22ddb 100644
--- a/resources/src/main/java/org/robolectric/res/android/AttributeResolution10.java
+++ b/resources/src/main/java/org/robolectric/res/android/AttributeResolution10.java
@@ -16,515 +16,547 @@ import org.robolectric.res.android.ResourceTypes.Res_value;
 // https://android.googlesource.com/platform/frameworks/base/+/android-10.0.0_rXX/libs/androidfw/include/androidfw/AttributeResolution.h
 
 public class AttributeResolution10 {
-    public static final boolean kThrowOnBadId = false;
-    private static final boolean kDebugStyles = false;
-
-    // Offsets into the outValues array populated by the methods below. outValues is a uint32_t
-    // array, but each logical element takes up 7 uint32_t-sized physical elements.
-    // Keep these in sync with android.content.res.TypedArray java class
-    public static final int STYLE_NUM_ENTRIES = 7;
-    public static final int STYLE_TYPE = 0;
-    public static final int STYLE_DATA = 1;
-    public static final int STYLE_ASSET_COOKIE = 2;
-    public static final int STYLE_RESOURCE_ID = 3;
-    public static final int STYLE_CHANGING_CONFIGURATIONS = 4;
-    public static final int STYLE_DENSITY = 5;
-    public static final int STYLE_SOURCE_STYLE_RESOURCE_ID = 6;
-
-    // Java asset cookies have 0 as an invalid cookie, but TypedArray expects < 0.
-    private static int ApkAssetsCookieToJavaCookie(ApkAssetsCookie cookie) {
-        return cookie.intValue() != kInvalidCookie ? (cookie.intValue() + 1) : -1;
+  public static final boolean kThrowOnBadId = false;
+  private static final boolean kDebugStyles = false;
+
+  // Offsets into the outValues array populated by the methods below. outValues is a uint32_t
+  // array, but each logical element takes up 7 uint32_t-sized physical elements.
+  // Keep these in sync with android.content.res.TypedArray java class
+  public static final int STYLE_NUM_ENTRIES = 7;
+  public static final int STYLE_TYPE = 0;
+  public static final int STYLE_DATA = 1;
+  public static final int STYLE_ASSET_COOKIE = 2;
+  public static final int STYLE_RESOURCE_ID = 3;
+  public static final int STYLE_CHANGING_CONFIGURATIONS = 4;
+  public static final int STYLE_DENSITY = 5;
+  public static final int STYLE_SOURCE_STYLE_RESOURCE_ID = 6;
+
+  // Java asset cookies have 0 as an invalid cookie, but TypedArray expects < 0.
+  private static int ApkAssetsCookieToJavaCookie(ApkAssetsCookie cookie) {
+    return cookie.intValue() != kInvalidCookie ? (cookie.intValue() + 1) : -1;
+  }
+
+  public static class XmlAttributeFinder {
+
+    private ResXMLParser xmlParser;
+
+    XmlAttributeFinder(ResXMLParser xmlParser) {
+      this.xmlParser = xmlParser;
     }
 
-    public static class XmlAttributeFinder {
+    public int Find(int curIdent) {
+      if (xmlParser == null) {
+        return -1;
+      }
 
-        private ResXMLParser xmlParser;
-
-        XmlAttributeFinder(ResXMLParser xmlParser) {
-            this.xmlParser = xmlParser;
-        }
-
-        public int Find(int curIdent) {
-            if (xmlParser == null) {
-                return -1;
-            }
-
-            int attributeCount = xmlParser.getAttributeCount();
-            for (int i = 0; i < attributeCount; i++) {
-                if (xmlParser.getAttributeNameResID(i) == curIdent) {
-                    return i;
-                }
-            }
-            return -1;
+      int attributeCount = xmlParser.getAttributeCount();
+      for (int i = 0; i < attributeCount; i++) {
+        if (xmlParser.getAttributeNameResID(i) == curIdent) {
+          return i;
         }
+      }
+      return -1;
     }
+  }
 
-    public static class BagAttributeFinder {
-        private final Entry[] bagEntries;
+  public static class BagAttributeFinder {
+    private final Entry[] bagEntries;
 
-        BagAttributeFinder(ResolvedBag bag) {
-            this.bagEntries = bag == null ? null : bag.entries;
-        }
+    BagAttributeFinder(ResolvedBag bag) {
+      this.bagEntries = bag == null ? null : bag.entries;
+    }
 
-        // Robolectric: unoptimized relative to Android impl
-        Entry Find(int ident) {
-            Entry needle = new Entry();
-            needle.key = ident;
+    // Robolectric: unoptimized relative to Android impl
+    Entry Find(int ident) {
+      Entry needle = new Entry();
+      needle.key = ident;
 
-            if (bagEntries == null) {
-                return null;
-            }
+      if (bagEntries == null) {
+        return null;
+      }
 
-            int i = Arrays.binarySearch(bagEntries, needle, (o1, o2) -> o1.key - o2.key);
-            return i < 0 ? null : bagEntries[i];
+      int i = Arrays.binarySearch(bagEntries, needle, (o1, o2) -> o1.key - o2.key);
+      return i < 0 ? null : bagEntries[i];
+    }
+  }
+
+  // These are all variations of the same method. They each perform the exact same operation,
+  // but on various data sources. I *think* they are re-written to avoid an extra branch
+  // in the inner loop, but after one branch miss (some pointer != null), the branch predictor
+  // should
+  // predict the rest of the iterations' branch correctly.
+  // TODO(adamlesinski): Run performance tests against these methods and a new, single method
+  // that uses all the sources and branches to the right ones within the inner loop.
+
+  // `out_values` must NOT be nullptr.
+  // `out_indices` may be nullptr.
+  public static boolean ResolveAttrs(
+      Theme theme,
+      int def_style_attr,
+      int def_style_res,
+      int[] src_values,
+      int src_values_length,
+      int[] attrs,
+      int attrs_length,
+      int[] out_values,
+      int[] out_indices) {
+    if (kDebugStyles) {
+      ALOGI(
+          "APPLY STYLE: theme=0x%s defStyleAttr=0x%x defStyleRes=0x%x",
+          theme, def_style_attr, def_style_res);
+    }
+
+    CppAssetManager2 assetmanager = theme.GetAssetManager();
+    ResTable_config config = new ResTable_config();
+    Res_value value;
+
+    int indicesIdx = 0;
+
+    // Load default style from attribute, if specified...
+    final Ref<Integer> def_style_flags = new Ref<>(0);
+    if (def_style_attr != 0) {
+      final Ref<Res_value> valueRef = new Ref<>(null);
+      if (theme.GetAttribute(def_style_attr, valueRef, def_style_flags).intValue()
+          != kInvalidCookie) {
+        value = valueRef.get();
+        if (value.dataType == Res_value.TYPE_REFERENCE) {
+          def_style_res = value.data;
         }
+      }
+    }
+
+    // Retrieve the default style bag, if requested.
+    ResolvedBag default_style_bag = null;
+    if (def_style_res != 0) {
+      default_style_bag = assetmanager.GetBag(def_style_res);
+      if (default_style_bag != null) {
+        def_style_flags.set(def_style_flags.get() | default_style_bag.type_spec_flags);
+      }
     }
+    BagAttributeFinder def_style_attr_finder = new BagAttributeFinder(default_style_bag);
+
+    // Now iterate through all of the attributes that the client has requested,
+    // filling in each with whatever data we can find.
+    int destOffset = 0;
+    for (int ii = 0; ii < attrs_length; ii++) {
+      final int cur_ident = attrs[ii];
+
+      if (kDebugStyles) {
+        ALOGI("RETRIEVING ATTR 0x%08x...", cur_ident);
+      }
+
+      ApkAssetsCookie cookie = K_INVALID_COOKIE;
+      int type_set_flags = 0;
 
-    // These are all variations of the same method. They each perform the exact same operation,
-    // but on various data sources. I *think* they are re-written to avoid an extra branch
-    // in the inner loop, but after one branch miss (some pointer != null), the branch predictor should
-    // predict the rest of the iterations' branch correctly.
-    // TODO(adamlesinski): Run performance tests against these methods and a new, single method
-    // that uses all the sources and branches to the right ones within the inner loop.
-
-    // `out_values` must NOT be nullptr.
-    // `out_indices` may be nullptr.
-    public static boolean ResolveAttrs(Theme theme, int def_style_attr,
-            int def_style_res, int[] src_values,
-            int src_values_length, int[] attrs,
-            int attrs_length, int[] out_values, int[] out_indices) {
+      value = Res_value.NULL_VALUE;
+      config.density = 0;
+
+      // Try to find a value for this attribute...  we prioritize values
+      // coming from, first XML attributes, then XML style, then default
+      // style, and finally the theme.
+
+      // Retrieve the current input value if available.
+      if (src_values_length > 0 && src_values[ii] != 0) {
+        value = new Res_value((byte) Res_value.TYPE_ATTRIBUTE, src_values[ii]);
         if (kDebugStyles) {
-            ALOGI("APPLY STYLE: theme=0x%s defStyleAttr=0x%x defStyleRes=0x%x", theme,
-                    def_style_attr, def_style_res);
+          ALOGI("-> From values: type=0x%x, data=0x%08x", value.dataType, value.data);
         }
-
-        CppAssetManager2 assetmanager = theme.GetAssetManager();
-        ResTable_config config = new ResTable_config();
-        Res_value value;
-
-        int indicesIdx = 0;
-
-        // Load default style from attribute, if specified...
-        final Ref<Integer> def_style_flags = new Ref<>(0);
-        if (def_style_attr != 0) {
-            final Ref<Res_value> valueRef = new Ref<>(null);
-            if (theme.GetAttribute(def_style_attr, valueRef, def_style_flags).intValue() != kInvalidCookie) {
-                value = valueRef.get();
-                if (value.dataType == Res_value.TYPE_REFERENCE) {
-                    def_style_res = value.data;
-                }
-            }
+      } else {
+        final Entry entry = def_style_attr_finder.Find(cur_ident);
+        if (entry != null) {
+          cookie = entry.cookie;
+          type_set_flags = def_style_flags.get();
+          value = entry.value;
+          if (kDebugStyles) {
+            ALOGI("-> From def style: type=0x%x, data=0x%08x", value.dataType, value.data);
+          }
         }
-
-        // Retrieve the default style bag, if requested.
-        ResolvedBag default_style_bag = null;
-        if (def_style_res != 0) {
-            default_style_bag = assetmanager.GetBag(def_style_res);
-            if (default_style_bag != null) {
-                def_style_flags.set(def_style_flags.get() | default_style_bag.type_spec_flags);
-            }
+      }
+
+      int resid = 0;
+      final Ref<Res_value> valueRef = new Ref<>(value);
+      final Ref<Integer> residRef = new Ref<>(resid);
+      final Ref<Integer> type_set_flagsRef = new Ref<>(type_set_flags);
+      final Ref<ResTable_config> configRef = new Ref<>(config);
+      if (value.dataType != Res_value.TYPE_NULL) {
+        // Take care of resolving the found resource to its final value.
+        ApkAssetsCookie new_cookie =
+            theme.ResolveAttributeReference(
+                cookie, valueRef, configRef, type_set_flagsRef, residRef);
+        if (new_cookie.intValue() != kInvalidCookie) {
+          cookie = new_cookie;
         }
-        BagAttributeFinder def_style_attr_finder = new BagAttributeFinder(default_style_bag);
-
-        // Now iterate through all of the attributes that the client has requested,
-        // filling in each with whatever data we can find.
-        int destOffset = 0;
-        for (int ii=0; ii<attrs_length; ii++) {
-            final int cur_ident = attrs[ii];
-
-            if (kDebugStyles) {
-                ALOGI("RETRIEVING ATTR 0x%08x...", cur_ident);
-            }
-
-            ApkAssetsCookie cookie = K_INVALID_COOKIE;
-            int type_set_flags = 0;
-
-            value = Res_value.NULL_VALUE;
-            config.density = 0;
-
-            // Try to find a value for this attribute...  we prioritize values
-            // coming from, first XML attributes, then XML style, then default
-            // style, and finally the theme.
-
-            // Retrieve the current input value if available.
-            if (src_values_length > 0 && src_values[ii] != 0) {
-                value = new Res_value((byte) Res_value.TYPE_ATTRIBUTE, src_values[ii]);
-                if (kDebugStyles) {
-                    ALOGI("-> From values: type=0x%x, data=0x%08x", value.dataType, value.data);
-                }
-            } else {
-                final Entry entry = def_style_attr_finder.Find(cur_ident);
-                if (entry != null) {
-                    cookie = entry.cookie;
-                    type_set_flags = def_style_flags.get();
-                    value = entry.value;
-                    if (kDebugStyles) {
-                        ALOGI("-> From def style: type=0x%x, data=0x%08x", value.dataType, value.data);
-                    }
-                }
-            }
-
-            int resid = 0;
-            final Ref<Res_value> valueRef = new Ref<>(value);
-            final Ref<Integer> residRef = new Ref<>(resid);
-            final Ref<Integer> type_set_flagsRef = new Ref<>(type_set_flags);
-            final Ref<ResTable_config> configRef = new Ref<>(config);
-            if (value.dataType != Res_value.TYPE_NULL) {
-                // Take care of resolving the found resource to its final value.
-                ApkAssetsCookie new_cookie =
-                        theme.ResolveAttributeReference(cookie, valueRef, configRef, type_set_flagsRef, residRef);
-                if (new_cookie.intValue() != kInvalidCookie) {
-                    cookie = new_cookie;
-                }
-                if (kDebugStyles) {
-                    ALOGI("-> Resolved attr: type=0x%x, data=0x%08x", value.dataType, value.data);
-                }
-            } else if (value.data != Res_value.DATA_NULL_EMPTY) {
-                // If we still don't have a value for this attribute, try to find it in the theme!
-                ApkAssetsCookie new_cookie = theme.GetAttribute(cur_ident, valueRef, type_set_flagsRef);
-                if (new_cookie.intValue() != kInvalidCookie) {
-                    if (kDebugStyles) {
-                        ALOGI("-> From theme: type=0x%x, data=0x%08x", value.dataType, value.data);
-                    }
-                    new_cookie =
-                            assetmanager.ResolveReference(new_cookie, valueRef, configRef, type_set_flagsRef, residRef);
-                    if (new_cookie.intValue() != kInvalidCookie) {
-                        cookie = new_cookie;
-                    }
-                    if (kDebugStyles) {
-                        ALOGI("-> Resolved theme: type=0x%x, data=0x%08x", value.dataType, value.data);
-                    }
-                }
-            }
-            value = valueRef.get();
-            resid = residRef.get();
-            type_set_flags = type_set_flagsRef.get();
-            config = configRef.get();
-
-            // Deal with the special @null value -- it turns back to TYPE_NULL.
-            if (value.dataType == Res_value.TYPE_REFERENCE && value.data == 0) {
-                if (kDebugStyles) {
-                    ALOGI("-> Setting to @null!");
-                }
-                value = Res_value.NULL_VALUE;
-                cookie = K_INVALID_COOKIE;
-            }
-
-            if (kDebugStyles) {
-                ALOGI("Attribute 0x%08x: type=0x%x, data=0x%08x", cur_ident, value.dataType,
-                        value.data);
-            }
-
-            // Write the final value back to Java.
-            out_values[destOffset + STYLE_TYPE] = value.dataType;
-            out_values[destOffset + STYLE_DATA] = value.data;
-            out_values[destOffset + STYLE_ASSET_COOKIE] = ApkAssetsCookieToJavaCookie(cookie);
-            out_values[destOffset + STYLE_RESOURCE_ID] = resid;
-            out_values[destOffset + STYLE_CHANGING_CONFIGURATIONS] = type_set_flags;
-            out_values[destOffset + STYLE_DENSITY] = config.density;
-
-            if (out_indices != null && value.dataType != Res_value.TYPE_NULL) {
-                indicesIdx++;
-                out_indices[indicesIdx] = ii;
-            }
-
-            destOffset += STYLE_NUM_ENTRIES;
+        if (kDebugStyles) {
+          ALOGI("-> Resolved attr: type=0x%x, data=0x%08x", value.dataType, value.data);
         }
-
-        if (out_indices != null) {
-            out_indices[0] = indicesIdx;
+      } else if (value.data != Res_value.DATA_NULL_EMPTY) {
+        // If we still don't have a value for this attribute, try to find it in the theme!
+        ApkAssetsCookie new_cookie = theme.GetAttribute(cur_ident, valueRef, type_set_flagsRef);
+        if (new_cookie.intValue() != kInvalidCookie) {
+          if (kDebugStyles) {
+            ALOGI("-> From theme: type=0x%x, data=0x%08x", value.dataType, value.data);
+          }
+          new_cookie =
+              assetmanager.ResolveReference(
+                  new_cookie, valueRef, configRef, type_set_flagsRef, residRef);
+          if (new_cookie.intValue() != kInvalidCookie) {
+            cookie = new_cookie;
+          }
+          if (kDebugStyles) {
+            ALOGI("-> Resolved theme: type=0x%x, data=0x%08x", value.dataType, value.data);
+          }
         }
-        return true;
-    }
-
-    public static void ApplyStyle(Theme theme, ResXMLParser xml_parser, int def_style_attr,
-            int def_style_resid, int[] attrs, int attrs_length,
-            int[] out_values, int[] out_indices) {
+      }
+      value = valueRef.get();
+      resid = residRef.get();
+      type_set_flags = type_set_flagsRef.get();
+      config = configRef.get();
+
+      // Deal with the special @null value -- it turns back to TYPE_NULL.
+      if (value.dataType == Res_value.TYPE_REFERENCE && value.data == 0) {
         if (kDebugStyles) {
-            ALOGI("APPLY STYLE: theme=%s defStyleAttr=0x%x defStyleRes=0x%x xml=%s",
-                    theme, def_style_attr, def_style_resid, xml_parser);
+          ALOGI("-> Setting to @null!");
         }
+        value = Res_value.NULL_VALUE;
+        cookie = K_INVALID_COOKIE;
+      }
+
+      if (kDebugStyles) {
+        ALOGI("Attribute 0x%08x: type=0x%x, data=0x%08x", cur_ident, value.dataType, value.data);
+      }
+
+      // Write the final value back to Java.
+      out_values[destOffset + STYLE_TYPE] = value.dataType;
+      out_values[destOffset + STYLE_DATA] = value.data;
+      out_values[destOffset + STYLE_ASSET_COOKIE] = ApkAssetsCookieToJavaCookie(cookie);
+      out_values[destOffset + STYLE_RESOURCE_ID] = resid;
+      out_values[destOffset + STYLE_CHANGING_CONFIGURATIONS] = type_set_flags;
+      out_values[destOffset + STYLE_DENSITY] = config.density;
+
+      if (out_indices != null && value.dataType != Res_value.TYPE_NULL) {
+        indicesIdx++;
+        out_indices[indicesIdx] = ii;
+      }
+
+      destOffset += STYLE_NUM_ENTRIES;
+    }
+
+    if (out_indices != null) {
+      out_indices[0] = indicesIdx;
+    }
+    return true;
+  }
+
+  public static void ApplyStyle(
+      Theme theme,
+      ResXMLParser xml_parser,
+      int def_style_attr,
+      int def_style_resid,
+      int[] attrs,
+      int attrs_length,
+      int[] out_values,
+      int[] out_indices) {
+    if (kDebugStyles) {
+      ALOGI(
+          "APPLY STYLE: theme=%s defStyleAttr=0x%x defStyleRes=0x%x xml=%s",
+          theme, def_style_attr, def_style_resid, xml_parser);
+    }
 
-        CppAssetManager2 assetmanager = theme.GetAssetManager();
-        final Ref<ResTable_config> config = new Ref<>(new ResTable_config());
-        final Ref<Res_value> value = new Ref<>(new Res_value());
+    CppAssetManager2 assetmanager = theme.GetAssetManager();
+    final Ref<ResTable_config> config = new Ref<>(new ResTable_config());
+    final Ref<Res_value> value = new Ref<>(new Res_value());
 
-        int indices_idx = 0;
+    int indices_idx = 0;
 
-        // Load default style from attribute, if specified...
-        final Ref<Integer> def_style_flags = new Ref<>(0);
-        if (def_style_attr != 0) {
-            if (theme.GetAttribute(def_style_attr, value, def_style_flags).intValue() != kInvalidCookie) {
-                if (value.get().dataType == DataType.REFERENCE.code()) {
-                    def_style_resid = value.get().data;
-                }
-            }
+    // Load default style from attribute, if specified...
+    final Ref<Integer> def_style_flags = new Ref<>(0);
+    if (def_style_attr != 0) {
+      if (theme.GetAttribute(def_style_attr, value, def_style_flags).intValue() != kInvalidCookie) {
+        if (value.get().dataType == DataType.REFERENCE.code()) {
+          def_style_resid = value.get().data;
         }
+      }
+    }
 
-        // Retrieve the style resource ID associated with the current XML tag's style attribute.
-        int style_resid = 0;
-        final Ref<Integer> style_flags = new Ref<>(0);
-        if (xml_parser != null) {
-            int idx = xml_parser.indexOfStyle();
-            if (idx >= 0 && xml_parser.getAttributeValue(idx, value) >= 0) {
-                if (value.get().dataType == DataType.ATTRIBUTE.code()) {
-                    // Resolve the attribute with out theme.
-                    if (theme.GetAttribute(value.get().data, value, style_flags).intValue() == kInvalidCookie) {
-                        value.set(value.get().withType(DataType.NULL.code()));
-                    }
-                }
-
-                if (value.get().dataType == DataType.REFERENCE.code()) {
-                    style_resid = value.get().data;
-                }
-            }
+    // Retrieve the style resource ID associated with the current XML tag's style attribute.
+    int style_resid = 0;
+    final Ref<Integer> style_flags = new Ref<>(0);
+    if (xml_parser != null) {
+      int idx = xml_parser.indexOfStyle();
+      if (idx >= 0 && xml_parser.getAttributeValue(idx, value) >= 0) {
+        if (value.get().dataType == DataType.ATTRIBUTE.code()) {
+          // Resolve the attribute with out theme.
+          if (theme.GetAttribute(value.get().data, value, style_flags).intValue()
+              == kInvalidCookie) {
+            value.set(value.get().withType(DataType.NULL.code()));
+          }
         }
 
-        // Retrieve the default style bag, if requested.
-        ResolvedBag default_style_bag = null;
-        if (def_style_resid != 0) {
-            default_style_bag = assetmanager.GetBag(def_style_resid);
-            if (default_style_bag != null) {
-                def_style_flags.set(def_style_flags.get() | default_style_bag.type_spec_flags);
-            }
+        if (value.get().dataType == DataType.REFERENCE.code()) {
+          style_resid = value.get().data;
         }
+      }
+    }
+
+    // Retrieve the default style bag, if requested.
+    ResolvedBag default_style_bag = null;
+    if (def_style_resid != 0) {
+      default_style_bag = assetmanager.GetBag(def_style_resid);
+      if (default_style_bag != null) {
+        def_style_flags.set(def_style_flags.get() | default_style_bag.type_spec_flags);
+      }
+    }
+
+    BagAttributeFinder def_style_attr_finder = new BagAttributeFinder(default_style_bag);
+
+    // Retrieve the style class bag, if requested.
+    ResolvedBag xml_style_bag = null;
+    if (style_resid != 0) {
+      xml_style_bag = assetmanager.GetBag(style_resid);
+      if (xml_style_bag != null) {
+        style_flags.set(style_flags.get() | xml_style_bag.type_spec_flags);
+      }
+    }
+
+    BagAttributeFinder xml_style_attr_finder = new BagAttributeFinder(xml_style_bag);
 
-        BagAttributeFinder def_style_attr_finder = new BagAttributeFinder(default_style_bag);
+    // Retrieve the XML attributes, if requested.
+    XmlAttributeFinder xml_attr_finder = new XmlAttributeFinder(xml_parser);
 
-        // Retrieve the style class bag, if requested.
-        ResolvedBag xml_style_bag = null;
-        if (style_resid != 0) {
-            xml_style_bag = assetmanager.GetBag(style_resid);
-            if (xml_style_bag != null) {
-                style_flags.set(style_flags.get() | xml_style_bag.type_spec_flags);
-            }
+    // Now iterate through all of the attributes that the client has requested,
+    // filling in each with whatever data we can find.
+    for (int ii = 0; ii < attrs_length; ii++) {
+      final int cur_ident = attrs[ii];
+
+      if (kDebugStyles) {
+        ALOGI("RETRIEVING ATTR 0x%08x...", cur_ident);
+      }
+
+      ApkAssetsCookie cookie = K_INVALID_COOKIE;
+      final Ref<Integer> type_set_flags = new Ref<>(0);
+
+      value.set(Res_value.NULL_VALUE);
+      config.get().density = 0;
+      int source_style_resid = 0;
+
+      // Try to find a value for this attribute...  we prioritize values
+      // coming from, first XML attributes, then XML style, then default
+      // style, and finally the theme.
+
+      // Walk through the xml attributes looking for the requested attribute.
+      int xml_attr_idx = xml_attr_finder.Find(cur_ident);
+      if (xml_attr_idx != -1) {
+        // We found the attribute we were looking for.
+        xml_parser.getAttributeValue(xml_attr_idx, value);
+        type_set_flags.set(style_flags.get());
+        if (kDebugStyles) {
+          ALOGI("-> From XML: type=0x%x, data=0x%08x", value.get().dataType, value.get().data);
         }
+      }
+
+      if (value.get().dataType == DataType.NULL.code()
+          && value.get().data != Res_value.DATA_NULL_EMPTY) {
+        // Walk through the style class values looking for the requested attribute.
+        Entry entry = xml_style_attr_finder.Find(cur_ident);
+        if (entry != null) {
+          // We found the attribute we were looking for.
+          cookie = entry.cookie;
+          type_set_flags.set(style_flags.get());
+          value.set(entry.value);
+          source_style_resid = entry.style;
+          if (kDebugStyles) {
+            ALOGI(
+                "-> From style: type=0x%x, data=0x%08x, style=0x%08x",
+                value.get().dataType, value.get().data, entry.style);
+          }
+        }
+      }
+
+      if (value.get().dataType == DataType.NULL.code()
+          && value.get().data != Res_value.DATA_NULL_EMPTY) {
+        // Walk through the default style values looking for the requested attribute.
+        Entry entry = def_style_attr_finder.Find(cur_ident);
+        if (entry != null) {
+          // We found the attribute we were looking for.
+          cookie = entry.cookie;
+          type_set_flags.set(def_style_flags.get());
+
+          value.set(entry.value);
+          if (kDebugStyles) {
+            ALOGI(
+                "-> From def style: type=0x%x, data=0x%08x, style=0x%08x",
+                value.get().dataType, value.get().data, entry.style);
+          }
+          source_style_resid = entry.style;
+        }
+      }
+
+      final Ref<Integer> resid = new Ref<>(0);
+      if (value.get().dataType != DataType.NULL.code()) {
+        // Take care of resolving the found resource to its final value.
+        ApkAssetsCookie new_cookie =
+            theme.ResolveAttributeReference(cookie, value, config, type_set_flags, resid);
+        if (new_cookie.intValue() != kInvalidCookie) {
+          cookie = new_cookie;
+        }
+
+        if (kDebugStyles) {
+          ALOGI("-> Resolved attr: type=0x%x, data=0x%08x", value.get().dataType, value.get().data);
+        }
+      } else if (value.get().data != Res_value.DATA_NULL_EMPTY) {
+        // If we still don't have a value for this attribute, try to find it in the theme!
+        ApkAssetsCookie new_cookie = theme.GetAttribute(cur_ident, value, type_set_flags);
+        if (new_cookie.intValue() != kInvalidCookie) {
+          if (kDebugStyles) {
+            ALOGI("-> From theme: type=0x%x, data=0x%08x", value.get().dataType, value.get().data);
+          }
+          new_cookie =
+              assetmanager.ResolveReference(new_cookie, value, config, type_set_flags, resid);
+          if (new_cookie.intValue() != kInvalidCookie) {
+            cookie = new_cookie;
+          }
+
+          if (kDebugStyles) {
+            ALOGI(
+                "-> Resolved theme: type=0x%x, data=0x%08x",
+                value.get().dataType, value.get().data);
+          }
+        }
+      }
 
-        BagAttributeFinder xml_style_attr_finder = new BagAttributeFinder(xml_style_bag);
-
-        // Retrieve the XML attributes, if requested.
-        XmlAttributeFinder xml_attr_finder = new XmlAttributeFinder(xml_parser);
-
-        // Now iterate through all of the attributes that the client has requested,
-        // filling in each with whatever data we can find.
-        for (int ii = 0; ii < attrs_length; ii++) {
-            final int cur_ident = attrs[ii];
-
-            if (kDebugStyles) {
-                ALOGI("RETRIEVING ATTR 0x%08x...", cur_ident);
-            }
-
-            ApkAssetsCookie cookie = K_INVALID_COOKIE;
-            final Ref<Integer> type_set_flags = new Ref<>(0);
-
-            value.set(Res_value.NULL_VALUE);
-            config.get().density = 0;
-            int source_style_resid = 0;
-
-            // Try to find a value for this attribute...  we prioritize values
-            // coming from, first XML attributes, then XML style, then default
-            // style, and finally the theme.
-
-            // Walk through the xml attributes looking for the requested attribute.
-            int xml_attr_idx = xml_attr_finder.Find(cur_ident);
-            if (xml_attr_idx != -1) {
-                // We found the attribute we were looking for.
-                xml_parser.getAttributeValue(xml_attr_idx, value);
-                type_set_flags.set(style_flags.get());
-                if (kDebugStyles) {
-                    ALOGI("-> From XML: type=0x%x, data=0x%08x", value.get().dataType, value.get().data);
-                }
-            }
-
-            if (value.get().dataType == DataType.NULL.code() && value.get().data != Res_value.DATA_NULL_EMPTY) {
-                // Walk through the style class values looking for the requested attribute.
-                Entry entry = xml_style_attr_finder.Find(cur_ident);
-                if (entry != null) {
-                    // We found the attribute we were looking for.
-                    cookie = entry.cookie;
-                    type_set_flags.set(style_flags.get());
-                    value.set(entry.value);
-                    source_style_resid = entry.style;
-                    if (kDebugStyles) {
-                        ALOGI("-> From style: type=0x%x, data=0x%08x, style=0x%08x", value.get().dataType, value.get().data,
-                                entry.style);
-                    }
-                }
-            }
-
-            if (value.get().dataType == DataType.NULL.code() && value.get().data != Res_value.DATA_NULL_EMPTY) {
-                // Walk through the default style values looking for the requested attribute.
-                Entry entry = def_style_attr_finder.Find(cur_ident);
-                if (entry != null) {
-                    // We found the attribute we were looking for.
-                    cookie = entry.cookie;
-                    type_set_flags.set(def_style_flags.get());
-
-                    value.set(entry.value);
-                    if (kDebugStyles) {
-                        ALOGI("-> From def style: type=0x%x, data=0x%08x, style=0x%08x", value.get().dataType, value.get().data,
-                                entry.style);
-                    }
-                    source_style_resid = entry.style;
-                }
-            }
-
-            final Ref<Integer> resid = new Ref<>(0);
-            if (value.get().dataType != DataType.NULL.code()) {
-                // Take care of resolving the found resource to its final value.
-                ApkAssetsCookie new_cookie =
-                        theme.ResolveAttributeReference(cookie, value, config, type_set_flags, resid);
-                if (new_cookie.intValue() != kInvalidCookie) {
-                    cookie = new_cookie;
-                }
-
-                if (kDebugStyles) {
-                    ALOGI("-> Resolved attr: type=0x%x, data=0x%08x", value.get().dataType, value.get().data);
-                }
-            } else if (value.get().data != Res_value.DATA_NULL_EMPTY) {
-                // If we still don't have a value for this attribute, try to find it in the theme!
-                ApkAssetsCookie new_cookie = theme.GetAttribute(cur_ident, value, type_set_flags);
-                if (new_cookie.intValue() != kInvalidCookie) {
-                    if (kDebugStyles) {
-                        ALOGI("-> From theme: type=0x%x, data=0x%08x", value.get().dataType, value.get().data);
-                    }
-                    new_cookie =
-                            assetmanager.ResolveReference(new_cookie, value, config, type_set_flags, resid);
-                    if (new_cookie.intValue() != kInvalidCookie) {
-                        cookie = new_cookie;
-                    }
-
-                    if (kDebugStyles) {
-                        ALOGI("-> Resolved theme: type=0x%x, data=0x%08x", value.get().dataType, value.get().data);
-                    }
-                }
-            }
-
-            // Deal with the special @null value -- it turns back to TYPE_NULL.
-            if (value.get().dataType == DataType.REFERENCE.code() && value.get().data == 0) {
-                if (kDebugStyles) {
-                    ALOGI(". Setting to @null!");
-                }
-                value.set(Res_value.NULL_VALUE);
-                cookie = K_INVALID_COOKIE;
-            }
-
-            if (kDebugStyles) {
-                ALOGI("Attribute 0x%08x: type=0x%x, data=0x%08x", cur_ident, value.get().dataType, value.get().data);
-            }
-
-            // Write the final value back to Java.
-            int destIndex = ii * STYLE_NUM_ENTRIES;
-            Res_value res_value = value.get();
-            out_values[destIndex + STYLE_TYPE] = res_value.dataType;
-            out_values[destIndex + STYLE_DATA] = res_value.data;
-            out_values[destIndex + STYLE_ASSET_COOKIE] = ApkAssetsCookieToJavaCookie(cookie);
-            out_values[destIndex + STYLE_RESOURCE_ID] = resid.get();
-            out_values[destIndex + STYLE_CHANGING_CONFIGURATIONS] = type_set_flags.get();
-            out_values[destIndex + STYLE_DENSITY] = config.get().density;
-            out_values[destIndex + STYLE_SOURCE_STYLE_RESOURCE_ID] = source_style_resid;
-
-            if (res_value.dataType != DataType.NULL.code() || res_value.data == Res_value.DATA_NULL_EMPTY) {
-                indices_idx++;
-
-                // out_indices must NOT be nullptr.
-                out_indices[indices_idx] = ii;
-            }
-
-            // Robolectric-custom:
-            // if (false && res_value.dataType == DataType.ATTRIBUTE.code()) {
-            //   final Ref<ResourceName> attrName = new Ref<>(null);
-            //   final Ref<ResourceName> attrRefName = new Ref<>(null);
-            //   boolean gotName = assetmanager.GetResourceName(cur_ident, attrName);
-            //   boolean gotRefName = assetmanager.GetResourceName(res_value.data, attrRefName);
-            //   Logger.warn(
-            //       "Failed to resolve attribute lookup: %s=\"?%s\"; theme: %s",
-            //       gotName ? attrName.get() : "unknown", gotRefName ? attrRefName.get() : "unknown",
-            //       theme);
-            // }
-
-//      out_values += STYLE_NUM_ENTRIES;
+      // Deal with the special @null value -- it turns back to TYPE_NULL.
+      if (value.get().dataType == DataType.REFERENCE.code() && value.get().data == 0) {
+        if (kDebugStyles) {
+          ALOGI(". Setting to @null!");
         }
+        value.set(Res_value.NULL_VALUE);
+        cookie = K_INVALID_COOKIE;
+      }
+
+      if (kDebugStyles) {
+        ALOGI(
+            "Attribute 0x%08x: type=0x%x, data=0x%08x",
+            cur_ident, value.get().dataType, value.get().data);
+      }
+
+      // Write the final value back to Java.
+      int destIndex = ii * STYLE_NUM_ENTRIES;
+      Res_value res_value = value.get();
+      out_values[destIndex + STYLE_TYPE] = res_value.dataType;
+      out_values[destIndex + STYLE_DATA] = res_value.data;
+      out_values[destIndex + STYLE_ASSET_COOKIE] = ApkAssetsCookieToJavaCookie(cookie);
+      out_values[destIndex + STYLE_RESOURCE_ID] = resid.get();
+      out_values[destIndex + STYLE_CHANGING_CONFIGURATIONS] = type_set_flags.get();
+      out_values[destIndex + STYLE_DENSITY] = config.get().density;
+      out_values[destIndex + STYLE_SOURCE_STYLE_RESOURCE_ID] = source_style_resid;
+
+      if (res_value.dataType != DataType.NULL.code()
+          || res_value.data == Res_value.DATA_NULL_EMPTY) {
+        indices_idx++;
 
         // out_indices must NOT be nullptr.
-        out_indices[0] = indices_idx;
+        out_indices[indices_idx] = ii;
+      }
+
+      // Robolectric-custom:
+      // if (false && res_value.dataType == DataType.ATTRIBUTE.code()) {
+      //   final Ref<ResourceName> attrName = new Ref<>(null);
+      //   final Ref<ResourceName> attrRefName = new Ref<>(null);
+      //   boolean gotName = assetmanager.GetResourceName(cur_ident, attrName);
+      //   boolean gotRefName = assetmanager.GetResourceName(res_value.data, attrRefName);
+      //   Logger.warn(
+      //       "Failed to resolve attribute lookup: %s=\"?%s\"; theme: %s",
+      //       gotName ? attrName.get() : "unknown", gotRefName ? attrRefName.get() : "unknown",
+      //       theme);
+      // }
+
+      //      out_values += STYLE_NUM_ENTRIES;
     }
 
-    public static boolean RetrieveAttributes(CppAssetManager2 assetmanager, ResXMLParser xml_parser, int[] attrs,
-            int attrs_length, int[] out_values, int[] out_indices) {
-        final Ref<ResTable_config> config = new Ref<>(new ResTable_config());
-        final Ref<Res_value> value = new Ref<>(null);
-
-        int indices_idx = 0;
-
-        // Retrieve the XML attributes, if requested.
-        final int xml_attr_count = xml_parser.getAttributeCount();
-        int ix = 0;
-        int cur_xml_attr = xml_parser.getAttributeNameResID(ix);
-
-        // Now iterate through all of the attributes that the client has requested,
-        // filling in each with whatever data we can find.
-        int baseDest = 0;
-        for (int ii = 0; ii < attrs_length; ii++) {
-            final int cur_ident = attrs[ii];
-            ApkAssetsCookie cookie = K_INVALID_COOKIE;
-            final Ref<Integer> type_set_flags = new Ref<>(0);
-
-            value.set(Res_value.NULL_VALUE);
-            config.get().density = 0;
-
-            // Try to find a value for this attribute...
-            // Skip through XML attributes until the end or the next possible match.
-            while (ix < xml_attr_count && cur_ident > cur_xml_attr) {
-                ix++;
-                cur_xml_attr = xml_parser.getAttributeNameResID(ix);
-            }
-            // Retrieve the current XML attribute if it matches, and step to next.
-            if (ix < xml_attr_count && cur_ident == cur_xml_attr) {
-                xml_parser.getAttributeValue(ix, value);
-                ix++;
-                cur_xml_attr = xml_parser.getAttributeNameResID(ix);
-            }
-
-            final Ref<Integer> resid = new Ref<>(0);
-            if (value.get().dataType != Res_value.TYPE_NULL) {
-                // Take care of resolving the found resource to its final value.
-                ApkAssetsCookie new_cookie =
-                        assetmanager.ResolveReference(cookie, value, config, type_set_flags, resid);
-                if (new_cookie.intValue() != kInvalidCookie) {
-                    cookie = new_cookie;
-                }
-            }
-
-            // Deal with the special @null value -- it turns back to TYPE_NULL.
-            if (value.get().dataType == Res_value.TYPE_REFERENCE && value.get().data == 0) {
-                value.set(Res_value.NULL_VALUE);
-                cookie = K_INVALID_COOKIE;
-            }
-
-            // Write the final value back to Java.
-            out_values[baseDest + STYLE_TYPE] = value.get().dataType;
-            out_values[baseDest + STYLE_DATA] = value.get().data;
-            out_values[baseDest + STYLE_ASSET_COOKIE] = ApkAssetsCookieToJavaCookie(cookie);
-            out_values[baseDest + STYLE_RESOURCE_ID] = resid.get();
-            out_values[baseDest + STYLE_CHANGING_CONFIGURATIONS] = type_set_flags.get();
-            out_values[baseDest + STYLE_DENSITY] = config.get().density;
-
-            if (out_indices != null &&
-                    (value.get().dataType != Res_value.TYPE_NULL
-                            || value.get().data == Res_value.DATA_NULL_EMPTY)) {
-                indices_idx++;
-                out_indices[indices_idx] = ii;
-            }
-
-//      out_values += STYLE_NUM_ENTRIES;
-            baseDest += STYLE_NUM_ENTRIES;
-        }
-
-        if (out_indices != null) {
-            out_indices[0] = indices_idx;
+    // out_indices must NOT be nullptr.
+    out_indices[0] = indices_idx;
+  }
+
+  public static boolean RetrieveAttributes(
+      CppAssetManager2 assetmanager,
+      ResXMLParser xml_parser,
+      int[] attrs,
+      int attrs_length,
+      int[] out_values,
+      int[] out_indices) {
+    final Ref<ResTable_config> config = new Ref<>(new ResTable_config());
+    final Ref<Res_value> value = new Ref<>(null);
+
+    int indices_idx = 0;
+
+    // Retrieve the XML attributes, if requested.
+    final int xml_attr_count = xml_parser.getAttributeCount();
+    int ix = 0;
+    int cur_xml_attr = xml_parser.getAttributeNameResID(ix);
+
+    // Now iterate through all of the attributes that the client has requested,
+    // filling in each with whatever data we can find.
+    int baseDest = 0;
+    for (int ii = 0; ii < attrs_length; ii++) {
+      final int cur_ident = attrs[ii];
+      ApkAssetsCookie cookie = K_INVALID_COOKIE;
+      final Ref<Integer> type_set_flags = new Ref<>(0);
+
+      value.set(Res_value.NULL_VALUE);
+      config.get().density = 0;
+
+      // Try to find a value for this attribute...
+      // Skip through XML attributes until the end or the next possible match.
+      while (ix < xml_attr_count && cur_ident > cur_xml_attr) {
+        ix++;
+        cur_xml_attr = xml_parser.getAttributeNameResID(ix);
+      }
+      // Retrieve the current XML attribute if it matches, and step to next.
+      if (ix < xml_attr_count && cur_ident == cur_xml_attr) {
+        xml_parser.getAttributeValue(ix, value);
+        ix++;
+        cur_xml_attr = xml_parser.getAttributeNameResID(ix);
+      }
+
+      final Ref<Integer> resid = new Ref<>(0);
+      if (value.get().dataType != Res_value.TYPE_NULL) {
+        // Take care of resolving the found resource to its final value.
+        ApkAssetsCookie new_cookie =
+            assetmanager.ResolveReference(cookie, value, config, type_set_flags, resid);
+        if (new_cookie.intValue() != kInvalidCookie) {
+          cookie = new_cookie;
         }
+      }
+
+      // Deal with the special @null value -- it turns back to TYPE_NULL.
+      if (value.get().dataType == Res_value.TYPE_REFERENCE && value.get().data == 0) {
+        value.set(Res_value.NULL_VALUE);
+        cookie = K_INVALID_COOKIE;
+      }
+
+      // Write the final value back to Java.
+      out_values[baseDest + STYLE_TYPE] = value.get().dataType;
+      out_values[baseDest + STYLE_DATA] = value.get().data;
+      out_values[baseDest + STYLE_ASSET_COOKIE] = ApkAssetsCookieToJavaCookie(cookie);
+      out_values[baseDest + STYLE_RESOURCE_ID] = resid.get();
+      out_values[baseDest + STYLE_CHANGING_CONFIGURATIONS] = type_set_flags.get();
+      out_values[baseDest + STYLE_DENSITY] = config.get().density;
+
+      if (out_indices != null
+          && (value.get().dataType != Res_value.TYPE_NULL
+              || value.get().data == Res_value.DATA_NULL_EMPTY)) {
+        indices_idx++;
+        out_indices[indices_idx] = ii;
+      }
+
+      //      out_values += STYLE_NUM_ENTRIES;
+      baseDest += STYLE_NUM_ENTRIES;
+    }
 
-        return true;
+    if (out_indices != null) {
+      out_indices[0] = indices_idx;
     }
+
+    return true;
+  }
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/AttributeResolution9.java b/resources/src/main/java/org/robolectric/res/android/AttributeResolution9.java
index 4fcc26c02..529c07d03 100644
--- a/resources/src/main/java/org/robolectric/res/android/AttributeResolution9.java
+++ b/resources/src/main/java/org/robolectric/res/android/AttributeResolution9.java
@@ -79,20 +79,28 @@ public class AttributeResolution9 {
 
   // These are all variations of the same method. They each perform the exact same operation,
   // but on various data sources. I *think* they are re-written to avoid an extra branch
-  // in the inner loop, but after one branch miss (some pointer != null), the branch predictor should
+  // in the inner loop, but after one branch miss (some pointer != null), the branch predictor
+  // should
   // predict the rest of the iterations' branch correctly.
   // TODO(adamlesinski): Run performance tests against these methods and a new, single method
   // that uses all the sources and branches to the right ones within the inner loop.
 
   // `out_values` must NOT be nullptr.
   // `out_indices` may be nullptr.
-  public static boolean ResolveAttrs(Theme theme, int def_style_attr,
-                                     int def_style_res, int[] src_values,
-                                     int src_values_length, int[] attrs,
-                                     int attrs_length, int[] out_values, int[] out_indices) {
+  public static boolean ResolveAttrs(
+      Theme theme,
+      int def_style_attr,
+      int def_style_res,
+      int[] src_values,
+      int src_values_length,
+      int[] attrs,
+      int attrs_length,
+      int[] out_values,
+      int[] out_indices) {
     if (kDebugStyles) {
-      ALOGI("APPLY STYLE: theme=0x%s defStyleAttr=0x%x defStyleRes=0x%x", theme,
-          def_style_attr, def_style_res);
+      ALOGI(
+          "APPLY STYLE: theme=0x%s defStyleAttr=0x%x defStyleRes=0x%x",
+          theme, def_style_attr, def_style_res);
     }
 
     CppAssetManager2 assetmanager = theme.GetAssetManager();
@@ -105,7 +113,8 @@ public class AttributeResolution9 {
     final Ref<Integer> def_style_flags = new Ref<>(0);
     if (def_style_attr != 0) {
       final Ref<Res_value> valueRef = new Ref<>(null);
-      if (theme.GetAttribute(def_style_attr, valueRef, def_style_flags).intValue() != kInvalidCookie) {
+      if (theme.GetAttribute(def_style_attr, valueRef, def_style_flags).intValue()
+          != kInvalidCookie) {
         value = valueRef.get();
         if (value.dataType == Res_value.TYPE_REFERENCE) {
           def_style_res = value.data;
@@ -126,7 +135,7 @@ public class AttributeResolution9 {
     // Now iterate through all of the attributes that the client has requested,
     // filling in each with whatever data we can find.
     int destOffset = 0;
-    for (int ii=0; ii<attrs_length; ii++) {
+    for (int ii = 0; ii < attrs_length; ii++) {
       final int cur_ident = attrs[ii];
 
       if (kDebugStyles) {
@@ -169,7 +178,8 @@ public class AttributeResolution9 {
       if (value.dataType != Res_value.TYPE_NULL) {
         // Take care of resolving the found resource to its final value.
         ApkAssetsCookie new_cookie =
-            theme.ResolveAttributeReference(cookie, valueRef, configRef, type_set_flagsRef, residRef);
+            theme.ResolveAttributeReference(
+                cookie, valueRef, configRef, type_set_flagsRef, residRef);
         if (new_cookie.intValue() != kInvalidCookie) {
           cookie = new_cookie;
         }
@@ -184,7 +194,8 @@ public class AttributeResolution9 {
             ALOGI("-> From theme: type=0x%x, data=0x%08x", value.dataType, value.data);
           }
           new_cookie =
-              assetmanager.ResolveReference(new_cookie, valueRef, configRef, type_set_flagsRef, residRef);
+              assetmanager.ResolveReference(
+                  new_cookie, valueRef, configRef, type_set_flagsRef, residRef);
           if (new_cookie.intValue() != kInvalidCookie) {
             cookie = new_cookie;
           }
@@ -208,8 +219,7 @@ public class AttributeResolution9 {
       }
 
       if (kDebugStyles) {
-        ALOGI("Attribute 0x%08x: type=0x%x, data=0x%08x", cur_ident, value.dataType,
-            value.data);
+        ALOGI("Attribute 0x%08x: type=0x%x, data=0x%08x", cur_ident, value.dataType, value.data);
       }
 
       // Write the final value back to Java.
@@ -234,11 +244,18 @@ public class AttributeResolution9 {
     return true;
   }
 
-  public static void ApplyStyle(Theme theme, ResXMLParser xml_parser, int def_style_attr,
-                                int def_style_resid, int[] attrs, int attrs_length,
-                                int[] out_values, int[] out_indices) {
+  public static void ApplyStyle(
+      Theme theme,
+      ResXMLParser xml_parser,
+      int def_style_attr,
+      int def_style_resid,
+      int[] attrs,
+      int attrs_length,
+      int[] out_values,
+      int[] out_indices) {
     if (kDebugStyles) {
-      ALOGI("APPLY STYLE: theme=%s defStyleAttr=0x%x defStyleRes=0x%x xml=%s",
+      ALOGI(
+          "APPLY STYLE: theme=%s defStyleAttr=0x%x defStyleRes=0x%x xml=%s",
           theme, def_style_attr, def_style_resid, xml_parser);
     }
 
@@ -266,7 +283,8 @@ public class AttributeResolution9 {
       if (idx >= 0 && xml_parser.getAttributeValue(idx, value) >= 0) {
         if (value.get().dataType == DataType.ATTRIBUTE.code()) {
           // Resolve the attribute with out theme.
-          if (theme.GetAttribute(value.get().data, value, style_flags).intValue() == kInvalidCookie) {
+          if (theme.GetAttribute(value.get().data, value, style_flags).intValue()
+              == kInvalidCookie) {
             value.set(value.get().withType(DataType.NULL.code()));
           }
         }
@@ -332,7 +350,8 @@ public class AttributeResolution9 {
         }
       }
 
-      if (value.get().dataType == DataType.NULL.code() && value.get().data != Res_value.DATA_NULL_EMPTY) {
+      if (value.get().dataType == DataType.NULL.code()
+          && value.get().data != Res_value.DATA_NULL_EMPTY) {
         // Walk through the style class values looking for the requested attribute.
         Entry entry = xml_style_attr_finder.Find(cur_ident);
         if (entry != null) {
@@ -346,17 +365,20 @@ public class AttributeResolution9 {
         }
       }
 
-      if (value.get().dataType == DataType.NULL.code() && value.get().data != Res_value.DATA_NULL_EMPTY) {
+      if (value.get().dataType == DataType.NULL.code()
+          && value.get().data != Res_value.DATA_NULL_EMPTY) {
         // Walk through the default style values looking for the requested attribute.
         Entry entry = def_style_attr_finder.Find(cur_ident);
         if (entry != null) {
           // We found the attribute we were looking for.
           cookie = entry.cookie;
           type_set_flags.set(def_style_flags.get());
-          
+
           value.set(entry.value);
           if (kDebugStyles) {
-            ALOGI("-> From def style: type=0x%x, data=0x%08x", value.get().dataType, value.get().data);
+            ALOGI(
+                "-> From def style: type=0x%x, data=0x%08x",
+                value.get().dataType, value.get().data);
           }
         }
       }
@@ -387,7 +409,9 @@ public class AttributeResolution9 {
           }
 
           if (kDebugStyles) {
-            ALOGI("-> Resolved theme: type=0x%x, data=0x%08x", value.get().dataType, value.get().data);
+            ALOGI(
+                "-> Resolved theme: type=0x%x, data=0x%08x",
+                value.get().dataType, value.get().data);
           }
         }
       }
@@ -402,7 +426,9 @@ public class AttributeResolution9 {
       }
 
       if (kDebugStyles) {
-        ALOGI("Attribute 0x%08x: type=0x%x, data=0x%08x", cur_ident, value.get().dataType, value.get().data);
+        ALOGI(
+            "Attribute 0x%08x: type=0x%x, data=0x%08x",
+            cur_ident, value.get().dataType, value.get().data);
       }
 
       // Write the final value back to Java.
@@ -415,7 +441,8 @@ public class AttributeResolution9 {
       out_values[destIndex + STYLE_CHANGING_CONFIGURATIONS] = type_set_flags.get();
       out_values[destIndex + STYLE_DENSITY] = config.get().density;
 
-      if (res_value.dataType != DataType.NULL.code() || res_value.data == Res_value.DATA_NULL_EMPTY) {
+      if (res_value.dataType != DataType.NULL.code()
+          || res_value.data == Res_value.DATA_NULL_EMPTY) {
         indices_idx++;
 
         // out_indices must NOT be nullptr.
@@ -434,15 +461,20 @@ public class AttributeResolution9 {
       //       theme);
       // }
 
-//      out_values += STYLE_NUM_ENTRIES;
+      //      out_values += STYLE_NUM_ENTRIES;
     }
 
     // out_indices must NOT be nullptr.
     out_indices[0] = indices_idx;
   }
 
-  public static boolean RetrieveAttributes(CppAssetManager2 assetmanager, ResXMLParser xml_parser, int[] attrs,
-      int attrs_length, int[] out_values, int[] out_indices) {
+  public static boolean RetrieveAttributes(
+      CppAssetManager2 assetmanager,
+      ResXMLParser xml_parser,
+      int[] attrs,
+      int attrs_length,
+      int[] out_values,
+      int[] out_indices) {
     final Ref<ResTable_config> config = new Ref<>(new ResTable_config());
     final Ref<Res_value> value = new Ref<>(null);
 
@@ -501,14 +533,14 @@ public class AttributeResolution9 {
       out_values[baseDest + STYLE_CHANGING_CONFIGURATIONS] = type_set_flags.get();
       out_values[baseDest + STYLE_DENSITY] = config.get().density;
 
-      if (out_indices != null &&
-          (value.get().dataType != Res_value.TYPE_NULL
+      if (out_indices != null
+          && (value.get().dataType != Res_value.TYPE_NULL
               || value.get().data == Res_value.DATA_NULL_EMPTY)) {
         indices_idx++;
         out_indices[indices_idx] = ii;
       }
 
-//      out_values += STYLE_NUM_ENTRIES;
+      //      out_values += STYLE_NUM_ENTRIES;
       baseDest += STYLE_NUM_ENTRIES;
     }
 
diff --git a/resources/src/main/java/org/robolectric/res/android/ByteBucketArray.java b/resources/src/main/java/org/robolectric/res/android/ByteBucketArray.java
index c4d508831..c91899569 100644
--- a/resources/src/main/java/org/robolectric/res/android/ByteBucketArray.java
+++ b/resources/src/main/java/org/robolectric/res/android/ByteBucketArray.java
@@ -16,9 +16,9 @@ public abstract class ByteBucketArray<T> {
     return NUM_BUCKETS * BUCKET_SIZE;
   }
 
-//  inline const T& get(size_t index) const {
-//    return (*this)[index];
-//  }
+  //  inline const T& get(size_t index) const {
+  //    return (*this)[index];
+  //  }
 
   final T get(int index) {
     if (index >= size()) {
@@ -45,7 +45,7 @@ public abstract class ByteBucketArray<T> {
     if (bucket == null) {
       bucket = mBuckets[bucketIndex] = new Object[BUCKET_SIZE];
     }
-//    return bucket[0x0f & static_cast<uint8_t>(index)];
+    //    return bucket[0x0f & static_cast<uint8_t>(index)];
     T t = (T) bucket[0x0f & ((byte) index)];
     if (t == null) {
       t = newInstance();
@@ -76,5 +76,4 @@ public abstract class ByteBucketArray<T> {
 
   Object[][] mBuckets = new Object[NUM_BUCKETS][];
   T mDefault;
-
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/Chunk.java b/resources/src/main/java/org/robolectric/res/android/Chunk.java
index 71e19e901..05e3aafe0 100644
--- a/resources/src/main/java/org/robolectric/res/android/Chunk.java
+++ b/resources/src/main/java/org/robolectric/res/android/Chunk.java
@@ -149,15 +149,27 @@ class Chunk {
       this.len_ = itemSize;
     }
 
-    boolean HasNext() { return !HadError() && len_ != 0; };
+    boolean HasNext() {
+      return !HadError() && len_ != 0;
+    }
+    ;
+
     // Returns whether there was an error and processing should stop
-    boolean HadError() { return last_error_ != null; }
-    String GetLastError() { return last_error_; }
+    boolean HadError() {
+      return last_error_ != null;
+    }
+
+    String GetLastError() {
+      return last_error_;
+    }
+
     // Returns whether there was an error and processing should stop. For legacy purposes,
     // some errors are considered "non fatal". Fatal errors stop processing new chunks and
     // throw away any chunks already processed. Non fatal errors also stop processing new
     // chunks, but, will retain and use any valid chunks already processed.
-    boolean HadFatalError() { return HadError() && last_error_was_fatal_; }
+    boolean HadFatalError() {
+      return HadError() && last_error_was_fatal_;
+    }
 
     Chunk Next() {
       assert (len_ != 0) : "called Next() after last chunk";
@@ -171,8 +183,8 @@ class Chunk {
       if (remaining <= 0) {
         next_chunk_ = null;
       } else {
-        next_chunk_ = new ResChunk_header(
-            this_chunk.myBuf(), this_chunk.myOffset() + dtohl(this_chunk.size));
+        next_chunk_ =
+            new ResChunk_header(this_chunk.myBuf(), this_chunk.myOffset() + dtohl(this_chunk.size));
       }
       len_ -= dtohl(this_chunk.size);
 
diff --git a/resources/src/main/java/org/robolectric/res/android/ConfigDescription.java b/resources/src/main/java/org/robolectric/res/android/ConfigDescription.java
index 1f512c864..82e6ca95d 100644
--- a/resources/src/main/java/org/robolectric/res/android/ConfigDescription.java
+++ b/resources/src/main/java/org/robolectric/res/android/ConfigDescription.java
@@ -41,8 +41,8 @@ public class ConfigDescription {
   public static final int SDK_O = 26;
 
   /**
-   * Constant used to to represent MNC (Mobile Network Code) zero.
-   * 0 cannot be used, since it is used to represent an undefined MNC.
+   * Constant used to to represent MNC (Mobile Network Code) zero. 0 cannot be used, since it is
+   * used to represent an undefined MNC.
    */
   private static final int ACONFIGURATION_MNC_ZERO = 0xffff;
 
@@ -73,15 +73,15 @@ public class ConfigDescription {
     }
 
     void set_script(String script_chars) {
-      script = String.valueOf(Character.toUpperCase(script_chars.charAt(0))) +
-          script_chars.substring(1).toLowerCase();
+      script =
+          String.valueOf(Character.toUpperCase(script_chars.charAt(0)))
+              + script_chars.substring(1).toLowerCase();
     }
 
     void set_variant(String variant_chars) {
       variant = variant_chars.trim();
     }
 
-
     static boolean is_alpha(final String str) {
       for (int i = 0; i < str.length(); i++) {
         if (!Character.isAlphabetic(str.charAt(i))) {
@@ -160,8 +160,9 @@ public class ConfigDescription {
         iter.next();
 
       } else {
-        if ((part.length() == 2 || part.length() == 3) && is_alpha(part) &&
-            !Objects.equals(part, "car")) {
+        if ((part.length() == 2 || part.length() == 3)
+            && is_alpha(part)
+            && !Objects.equals(part, "car")) {
           set_language(part);
           iter.next();
 
@@ -196,9 +197,10 @@ public class ConfigDescription {
     return parse(str, out, true);
   }
 
-  public static boolean parse(final String str, ResTable_config out, boolean applyVersionForCompat) {
-    PeekingIterator<String> part_iter = Iterators
-        .peekingIterator(Arrays.asList(str.toLowerCase().split("-")).iterator());
+  public static boolean parse(
+      final String str, ResTable_config out, boolean applyVersionForCompat) {
+    PeekingIterator<String> part_iter =
+        Iterators.peekingIterator(Arrays.asList(str.toLowerCase().split("-")).iterator());
 
     LocaleValue locale = new LocaleValue();
 
@@ -386,22 +388,19 @@ public class ConfigDescription {
     if (Objects.equals(name, kWildcardName)) {
       if (out != null) {
         out.screenLayout =
-            (out.screenLayout & ~ResTable_config.MASK_LAYOUTDIR) |
-                ResTable_config.LAYOUTDIR_ANY;
+            (out.screenLayout & ~ResTable_config.MASK_LAYOUTDIR) | ResTable_config.LAYOUTDIR_ANY;
       }
       return true;
     } else if (Objects.equals(name, "ldltr")) {
       if (out != null) {
         out.screenLayout =
-            (out.screenLayout & ~ResTable_config.MASK_LAYOUTDIR) |
-                ResTable_config.LAYOUTDIR_LTR;
+            (out.screenLayout & ~ResTable_config.MASK_LAYOUTDIR) | ResTable_config.LAYOUTDIR_LTR;
       }
       return true;
     } else if (Objects.equals(name, "ldrtl")) {
       if (out != null) {
         out.screenLayout =
-            (out.screenLayout & ~ResTable_config.MASK_LAYOUTDIR) |
-                ResTable_config.LAYOUTDIR_RTL;
+            (out.screenLayout & ~ResTable_config.MASK_LAYOUTDIR) | ResTable_config.LAYOUTDIR_RTL;
       }
       return true;
     }
@@ -461,36 +460,35 @@ public class ConfigDescription {
     if (Objects.equals(name, kWildcardName)) {
       if (out != null) {
         out.screenLayout =
-            (out.screenLayout & ~ResTable_config.MASK_SCREENSIZE) |
-                ResTable_config.SCREENSIZE_ANY;
+            (out.screenLayout & ~ResTable_config.MASK_SCREENSIZE) | ResTable_config.SCREENSIZE_ANY;
       }
       return true;
     } else if (Objects.equals(name, "small")) {
       if (out != null) {
         out.screenLayout =
-            (out.screenLayout & ~ResTable_config.MASK_SCREENSIZE) |
-                ResTable_config.SCREENSIZE_SMALL;
+            (out.screenLayout & ~ResTable_config.MASK_SCREENSIZE)
+                | ResTable_config.SCREENSIZE_SMALL;
       }
       return true;
     } else if (Objects.equals(name, "normal")) {
       if (out != null) {
         out.screenLayout =
-            (out.screenLayout & ~ResTable_config.MASK_SCREENSIZE) |
-                ResTable_config.SCREENSIZE_NORMAL;
+            (out.screenLayout & ~ResTable_config.MASK_SCREENSIZE)
+                | ResTable_config.SCREENSIZE_NORMAL;
       }
       return true;
     } else if (Objects.equals(name, "large")) {
       if (out != null) {
         out.screenLayout =
-            (out.screenLayout & ~ResTable_config.MASK_SCREENSIZE) |
-                ResTable_config.SCREENSIZE_LARGE;
+            (out.screenLayout & ~ResTable_config.MASK_SCREENSIZE)
+                | ResTable_config.SCREENSIZE_LARGE;
       }
       return true;
     } else if (Objects.equals(name, "xlarge")) {
       if (out != null) {
         out.screenLayout =
-            (out.screenLayout & ~ResTable_config.MASK_SCREENSIZE) |
-                ResTable_config.SCREENSIZE_XLARGE;
+            (out.screenLayout & ~ResTable_config.MASK_SCREENSIZE)
+                | ResTable_config.SCREENSIZE_XLARGE;
       }
       return true;
     }
@@ -502,19 +500,18 @@ public class ConfigDescription {
     if (Objects.equals(name, kWildcardName)) {
       if (out != null) {
         out.screenLayout =
-            (out.screenLayout&~ResTable_config.MASK_SCREENLONG)
-                | ResTable_config.SCREENLONG_ANY;
+            (out.screenLayout & ~ResTable_config.MASK_SCREENLONG) | ResTable_config.SCREENLONG_ANY;
       }
       return true;
     } else if (Objects.equals(name, "long")) {
-      if (out != null) out.screenLayout =
-          (out.screenLayout&~ResTable_config.MASK_SCREENLONG)
-              | ResTable_config.SCREENLONG_YES;
+      if (out != null)
+        out.screenLayout =
+            (out.screenLayout & ~ResTable_config.MASK_SCREENLONG) | ResTable_config.SCREENLONG_YES;
       return true;
     } else if (Objects.equals(name, "notlong")) {
-      if (out != null) out.screenLayout =
-          (out.screenLayout&~ResTable_config.MASK_SCREENLONG)
-              | ResTable_config.SCREENLONG_NO;
+      if (out != null)
+        out.screenLayout =
+            (out.screenLayout & ~ResTable_config.MASK_SCREENLONG) | ResTable_config.SCREENLONG_NO;
       return true;
     }
     return false;
@@ -524,22 +521,25 @@ public class ConfigDescription {
     if (Objects.equals(name, kWildcardName)) {
       if (out != null) {
         out.screenLayout2 =
-            (byte) ((out.screenLayout2 & ~ResTable_config.MASK_SCREENROUND) |
-                            ResTable_config.SCREENROUND_ANY);
+            (byte)
+                ((out.screenLayout2 & ~ResTable_config.MASK_SCREENROUND)
+                    | ResTable_config.SCREENROUND_ANY);
       }
       return true;
     } else if (Objects.equals(name, "round")) {
       if (out != null) {
         out.screenLayout2 =
-            (byte) ((out.screenLayout2 & ~ResTable_config.MASK_SCREENROUND) |
-                            ResTable_config.SCREENROUND_YES);
+            (byte)
+                ((out.screenLayout2 & ~ResTable_config.MASK_SCREENROUND)
+                    | ResTable_config.SCREENROUND_YES);
       }
       return true;
     } else if (Objects.equals(name, "notround")) {
       if (out != null) {
         out.screenLayout2 =
-            (byte) ((out.screenLayout2 & ~ResTable_config.MASK_SCREENROUND) |
-                ResTable_config.SCREENROUND_NO);
+            (byte)
+                ((out.screenLayout2 & ~ResTable_config.MASK_SCREENROUND)
+                    | ResTable_config.SCREENROUND_NO);
       }
       return true;
     }
@@ -550,20 +550,23 @@ public class ConfigDescription {
     if (Objects.equals(name, kWildcardName)) {
       if (out != null)
         out.colorMode =
-            (byte) ((out.colorMode & ~ResTable_config.MASK_WIDE_COLOR_GAMUT) |
-                            ResTable_config.WIDE_COLOR_GAMUT_ANY);
+            (byte)
+                ((out.colorMode & ~ResTable_config.MASK_WIDE_COLOR_GAMUT)
+                    | ResTable_config.WIDE_COLOR_GAMUT_ANY);
       return true;
     } else if (Objects.equals(name, "widecg")) {
       if (out != null)
         out.colorMode =
-            (byte) ((out.colorMode & ~ResTable_config.MASK_WIDE_COLOR_GAMUT) |
-                            ResTable_config.WIDE_COLOR_GAMUT_YES);
+            (byte)
+                ((out.colorMode & ~ResTable_config.MASK_WIDE_COLOR_GAMUT)
+                    | ResTable_config.WIDE_COLOR_GAMUT_YES);
       return true;
     } else if (Objects.equals(name, "nowidecg")) {
       if (out != null)
         out.colorMode =
-            (byte) ((out.colorMode & ~ResTable_config.MASK_WIDE_COLOR_GAMUT) |
-                            ResTable_config.WIDE_COLOR_GAMUT_NO);
+            (byte)
+                ((out.colorMode & ~ResTable_config.MASK_WIDE_COLOR_GAMUT)
+                    | ResTable_config.WIDE_COLOR_GAMUT_NO);
       return true;
     }
     return false;
@@ -573,20 +576,17 @@ public class ConfigDescription {
     if (Objects.equals(name, kWildcardName)) {
       if (out != null)
         out.colorMode =
-            (byte) ((out.colorMode & ~ResTable_config.MASK_HDR) |
-                            ResTable_config.HDR_ANY);
+            (byte) ((out.colorMode & ~ResTable_config.MASK_HDR) | ResTable_config.HDR_ANY);
       return true;
     } else if (Objects.equals(name, "highdr")) {
       if (out != null)
         out.colorMode =
-            (byte) ((out.colorMode & ~ResTable_config.MASK_HDR) |
-                            ResTable_config.HDR_YES);
+            (byte) ((out.colorMode & ~ResTable_config.MASK_HDR) | ResTable_config.HDR_YES);
       return true;
     } else if (Objects.equals(name, "lowdr")) {
       if (out != null)
         out.colorMode =
-            (byte) ((out.colorMode & ~ResTable_config.MASK_HDR) |
-                            ResTable_config.HDR_NO);
+            (byte) ((out.colorMode & ~ResTable_config.MASK_HDR) | ResTable_config.HDR_NO);
       return true;
     }
     return false;
@@ -621,44 +621,47 @@ public class ConfigDescription {
   private static boolean parseUiModeType(String name, ResTable_config out) {
     if (Objects.equals(name, kWildcardName)) {
       if (out != null) {
-        out.uiMode = (out.uiMode & ~ResTable_config.MASK_UI_MODE_TYPE) |
-            ResTable_config.UI_MODE_TYPE_ANY;
+        out.uiMode =
+            (out.uiMode & ~ResTable_config.MASK_UI_MODE_TYPE) | ResTable_config.UI_MODE_TYPE_ANY;
       }
       return true;
     } else if (Objects.equals(name, "desk")) {
       if (out != null) {
-        out.uiMode = (out.uiMode & ~ResTable_config.MASK_UI_MODE_TYPE) |
-            ResTable_config.UI_MODE_TYPE_DESK;
+        out.uiMode =
+            (out.uiMode & ~ResTable_config.MASK_UI_MODE_TYPE) | ResTable_config.UI_MODE_TYPE_DESK;
       }
       return true;
     } else if (Objects.equals(name, "car")) {
       if (out != null) {
-        out.uiMode = (out.uiMode & ~ResTable_config.MASK_UI_MODE_TYPE) |
-            ResTable_config.UI_MODE_TYPE_CAR;
+        out.uiMode =
+            (out.uiMode & ~ResTable_config.MASK_UI_MODE_TYPE) | ResTable_config.UI_MODE_TYPE_CAR;
       }
       return true;
     } else if (Objects.equals(name, "television")) {
       if (out != null) {
-        out.uiMode = (out.uiMode & ~ResTable_config.MASK_UI_MODE_TYPE) |
-            ResTable_config.UI_MODE_TYPE_TELEVISION;
+        out.uiMode =
+            (out.uiMode & ~ResTable_config.MASK_UI_MODE_TYPE)
+                | ResTable_config.UI_MODE_TYPE_TELEVISION;
       }
       return true;
     } else if (Objects.equals(name, "appliance")) {
       if (out != null) {
-        out.uiMode = (out.uiMode & ~ResTable_config.MASK_UI_MODE_TYPE) |
-            ResTable_config.UI_MODE_TYPE_APPLIANCE;
+        out.uiMode =
+            (out.uiMode & ~ResTable_config.MASK_UI_MODE_TYPE)
+                | ResTable_config.UI_MODE_TYPE_APPLIANCE;
       }
       return true;
     } else if (Objects.equals(name, "watch")) {
       if (out != null) {
-        out.uiMode = (out.uiMode & ~ResTable_config.MASK_UI_MODE_TYPE) |
-            ResTable_config.UI_MODE_TYPE_WATCH;
+        out.uiMode =
+            (out.uiMode & ~ResTable_config.MASK_UI_MODE_TYPE) | ResTable_config.UI_MODE_TYPE_WATCH;
       }
       return true;
     } else if (Objects.equals(name, "vrheadset")) {
       if (out != null) {
-        out.uiMode = (out.uiMode & ~ResTable_config.MASK_UI_MODE_TYPE) |
-            ResTable_config.UI_MODE_TYPE_VR_HEADSET;
+        out.uiMode =
+            (out.uiMode & ~ResTable_config.MASK_UI_MODE_TYPE)
+                | ResTable_config.UI_MODE_TYPE_VR_HEADSET;
       }
       return true;
     }
@@ -669,20 +672,20 @@ public class ConfigDescription {
   private static boolean parseUiModeNight(String name, ResTable_config out) {
     if (Objects.equals(name, kWildcardName)) {
       if (out != null) {
-        out.uiMode = (out.uiMode & ~ResTable_config.MASK_UI_MODE_NIGHT) |
-            ResTable_config.UI_MODE_NIGHT_ANY;
+        out.uiMode =
+            (out.uiMode & ~ResTable_config.MASK_UI_MODE_NIGHT) | ResTable_config.UI_MODE_NIGHT_ANY;
       }
       return true;
     } else if (Objects.equals(name, "night")) {
       if (out != null) {
-        out.uiMode = (out.uiMode & ~ResTable_config.MASK_UI_MODE_NIGHT) |
-            ResTable_config.UI_MODE_NIGHT_YES;
+        out.uiMode =
+            (out.uiMode & ~ResTable_config.MASK_UI_MODE_NIGHT) | ResTable_config.UI_MODE_NIGHT_YES;
       }
       return true;
     } else if (Objects.equals(name, "notnight")) {
       if (out != null) {
-        out.uiMode = (out.uiMode & ~ResTable_config.MASK_UI_MODE_NIGHT) |
-            ResTable_config.UI_MODE_NIGHT_NO;
+        out.uiMode =
+            (out.uiMode & ~ResTable_config.MASK_UI_MODE_NIGHT) | ResTable_config.UI_MODE_NIGHT_NO;
       }
       return true;
     }
@@ -980,16 +983,17 @@ public class ConfigDescription {
     return false;
   }
 
-  // transliterated from https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/tools/aapt/AaptConfig.cpp
+  // transliterated from
+  // https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/tools/aapt/AaptConfig.cpp
   private static void applyVersionForCompatibility(ResTable_config config) {
     if (config == null) {
       return;
     }
     int min_sdk = 0;
     if (((config.uiMode & ResTable_config.MASK_UI_MODE_TYPE)
-        == ResTable_config.UI_MODE_TYPE_VR_HEADSET) ||
-        (config.colorMode & ResTable_config.MASK_WIDE_COLOR_GAMUT) != 0 ||
-            (config.colorMode & ResTable_config.MASK_HDR) != 0) {
+            == ResTable_config.UI_MODE_TYPE_VR_HEADSET)
+        || (config.colorMode & ResTable_config.MASK_WIDE_COLOR_GAMUT) != 0
+        || (config.colorMode & ResTable_config.MASK_HDR) != 0) {
       min_sdk = SDK_O;
     } else if (isTruthy(config.screenLayout2 & ResTable_config.MASK_SCREENROUND)) {
       min_sdk = SDK_MNC;
@@ -1000,14 +1004,13 @@ public class ConfigDescription {
         || config.screenHeightDp != ResTable_config.SCREENHEIGHT_ANY) {
       min_sdk = SDK_HONEYCOMB_MR2;
     } else if ((config.uiMode & ResTable_config.MASK_UI_MODE_TYPE)
-        != ResTable_config.UI_MODE_TYPE_ANY
-        ||  (config.uiMode & ResTable_config.MASK_UI_MODE_NIGHT)
-        != ResTable_config.UI_MODE_NIGHT_ANY) {
+            != ResTable_config.UI_MODE_TYPE_ANY
+        || (config.uiMode & ResTable_config.MASK_UI_MODE_NIGHT)
+            != ResTable_config.UI_MODE_NIGHT_ANY) {
       min_sdk = SDK_FROYO;
     } else if ((config.screenLayout & ResTable_config.MASK_SCREENSIZE)
-        != ResTable_config.SCREENSIZE_ANY
-        ||  (config.screenLayout & ResTable_config.MASK_SCREENLONG)
-        != ResTable_config.SCREENLONG_ANY
+            != ResTable_config.SCREENSIZE_ANY
+        || (config.screenLayout & ResTable_config.MASK_SCREENLONG) != ResTable_config.SCREENLONG_ANY
         || config.density != ResTable_config.DENSITY_DEFAULT) {
       min_sdk = SDK_DONUT;
     }
diff --git a/resources/src/main/java/org/robolectric/res/android/CppApkAssets.java b/resources/src/main/java/org/robolectric/res/android/CppApkAssets.java
index 58370c892..275c884fd 100644
--- a/resources/src/main/java/org/robolectric/res/android/CppApkAssets.java
+++ b/resources/src/main/java/org/robolectric/res/android/CppApkAssets.java
@@ -1,7 +1,9 @@
 package org.robolectric.res.android;
 
-// transliterated from https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/include/androidfw/ApkAssets.h
-// and https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/ApkAssets.cpp
+// transliterated from
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/include/androidfw/ApkAssets.h
+// and
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/ApkAssets.cpp
 
 import static org.robolectric.res.android.CppAssetManager.FileType.kFileTypeDirectory;
 import static org.robolectric.res.android.CppAssetManager.FileType.kFileTypeRegular;
@@ -66,7 +68,9 @@ public class CppApkAssets {
     this.zipFileRO = new ZipFileRO(zip_handle_, zip_handle_.zipFile.getName());
   }
 
-  public String GetPath() { return path_; }
+  public String GetPath() {
+    return path_;
+  }
 
   // This is never nullptr.
   public LoadedArsc GetLoadedArsc() {
@@ -74,19 +78,20 @@ public class CppApkAssets {
   }
 
   //  private:
-//   DISALLOW_COPY_AND_ASSIGN(ApkAssets);
-//
-//   static std::unique_ptr<const ApkAssets> LoadImpl(const String& path, bool system,
-//                                                    bool load_as_shared_library);
-//
-//   ApkAssets() = default;
-//
-//   struct ZipArchivePtrCloser {
-//     void operator()(::ZipArchiveHandle handle) { ::CloseArchive(handle); }
-//   };
-//
-//   using ZipArchivePtr =
-//       std::unique_ptr<typename std::remove_pointer<::ZipArchiveHandle>::type, ZipArchivePtrCloser>;
+  //   DISALLOW_COPY_AND_ASSIGN(ApkAssets);
+  //
+  //   static std::unique_ptr<const ApkAssets> LoadImpl(const String& path, bool system,
+  //                                                    bool load_as_shared_library);
+  //
+  //   ApkAssets() = default;
+  //
+  //   struct ZipArchivePtrCloser {
+  //     void operator()(::ZipArchiveHandle handle) { ::CloseArchive(handle); }
+  //   };
+  //
+  //   using ZipArchivePtr =
+  //       std::unique_ptr<typename std::remove_pointer<::ZipArchiveHandle>::type,
+  // ZipArchivePtrCloser>;
 
   ZipArchiveHandle zip_handle_;
   private final ZipFileRO zipFileRO;
@@ -94,6 +99,7 @@ public class CppApkAssets {
   Asset resources_asset_;
   Asset idmap_asset_;
   private LoadedArsc loaded_arsc_;
+
   // };
   //
   // }  // namespace android
@@ -121,16 +127,15 @@ public class CppApkAssets {
   // filter out this package when computing what configurations/resources are available.
   // std::unique_ptr<const ApkAssets> ApkAssets::Load(const String& path, bool system) {
   public static CppApkAssets Load(String path, boolean system) {
-    return LoadImpl(/*{}*/-1 /*fd*/, path, null, null, system, false /*load_as_shared_library*/);
+    return LoadImpl(/*{}*/ -1 /*fd*/, path, null, null, system, false /*load_as_shared_library*/);
   }
 
   // Creates an ApkAssets, but forces any package with ID 0x7f to be loaded as a shared library.
   // If `system` is true, the package is marked as a system package, and allows some functions to
   // filter out this package when computing what configurations/resources are available.
-// std::unique_ptr<const ApkAssets> ApkAssets::LoadAsSharedLibrary(const String& path,
-//                                                                 bool system) {
-  public static CppApkAssets LoadAsSharedLibrary(String path,
-      boolean system) {
+  // std::unique_ptr<const ApkAssets> ApkAssets::LoadAsSharedLibrary(const String& path,
+  //                                                                 bool system) {
+  public static CppApkAssets LoadAsSharedLibrary(String path, boolean system) {
     return LoadImpl(/*{}*/ -1 /*fd*/, path, null, null, system, true /*load_as_shared_library*/);
   }
 
@@ -199,30 +204,36 @@ public class CppApkAssets {
     throw new UnsupportedOperationException();
     // unique_fd fd(base.utf8.open(path.c_str(), O_RDONLY | O_BINARY | O_CLOEXEC));
     // if (fd == -1) {
-    //   System.err.println( + "Failed to open file '" + path + "': " + SystemErrorCodeToString(errno);
+    //   System.err.println( + "Failed to open file '" + path + "': " +
+    // SystemErrorCodeToString(errno);
     //   return {};
     // }
     //
     // long file_len = lseek64(fd, 0, SEEK_END);
     // if (file_len < 0) {
-    //   System.err.println( + "Failed to get size of file '" + path + "': " + SystemErrorCodeToString(errno);
+    //   System.err.println( + "Failed to get size of file '" + path + "': " +
+    // SystemErrorCodeToString(errno);
     //   return {};
     // }
     //
     // std.unique_ptr<FileMap> file_map = util.make_unique<FileMap>();
-    // if (!file_map.create(path.c_str(), fd, 0, static_cast<size_t>(file_len), true /*readOnly*/)) {
-    //   System.err.println( + "Failed to mmap file '" + path + "': " + SystemErrorCodeToString(errno);
+    // if (!file_map.create(path.c_str(), fd, 0, static_cast<size_t>(file_len), true /*readOnly*/))
+    // {
+    //   System.err.println( + "Failed to mmap file '" + path + "': " +
+    // SystemErrorCodeToString(errno);
     //   return {};
     // }
     // return Asset.createFromUncompressedMap(std.move(file_map), Asset.AccessMode.ACCESS_RANDOM);
   }
 
-  /**
-   * Measure performance implications of loading {@link CppApkAssets}.
-   */
+  /** Measure performance implications of loading {@link CppApkAssets}. */
   static CppApkAssets LoadImpl(
-      int fd, String path, Asset idmap_asset,
-      LoadedIdmap loaded_idmap, boolean system, boolean load_as_shared_library) {
+      int fd,
+      String path,
+      Asset idmap_asset,
+      LoadedIdmap loaded_idmap,
+      boolean system,
+      boolean load_as_shared_library) {
     return PerfStatsCollector.getInstance()
         .measure(
             "load binary " + (system ? "framework" : "app") + " resources",
@@ -233,10 +244,15 @@ public class CppApkAssets {
 
   // std::unique_ptr<const ApkAssets> ApkAssets::LoadImpl(
   //     unique_fd fd, const std::string& path, std::unique_ptr<Asset> idmap_asset,
-  //     std::unique_ptr<const LoadedIdmap> loaded_idmap, bool system, bool load_as_shared_library) {
+  //     std::unique_ptr<const LoadedIdmap> loaded_idmap, bool system, bool load_as_shared_library)
+  // {
   static CppApkAssets LoadImpl_measured(
-      int fd, String path, Asset idmap_asset,
-      LoadedIdmap loaded_idmap, boolean system, boolean load_as_shared_library) {
+      int fd,
+      String path,
+      Asset idmap_asset,
+      LoadedIdmap loaded_idmap,
+      boolean system,
+      boolean load_as_shared_library) {
     Ref<ZipArchiveHandle> unmanaged_handle = new Ref<>(null);
     int result;
     if (fd >= 0) {
@@ -266,25 +282,28 @@ public class CppApkAssets {
       return loaded_apk;
     }
 
-    // Open the resource table via mmap unless it is compressed. This logic is taken care of by Open.
+    // Open the resource table via mmap unless it is compressed. This logic is taken care of by
+    // Open.
     loaded_apk.resources_asset_ = loaded_apk.Open(kResourcesArsc, Asset.AccessMode.ACCESS_BUFFER);
     if (loaded_apk.resources_asset_ == null) {
       System.err.println("Failed to open '" + kResourcesArsc + "' in APK '" + path + "'.");
       return null;
     }
 
-    // Must retain ownership of the IDMAP Asset so that all pointers to its mmapped data remain valid.
+    // Must retain ownership of the IDMAP Asset so that all pointers to its mmapped data remain
+    // valid.
     loaded_apk.idmap_asset_ = idmap_asset;
 
-  // const StringPiece data(
-  //       reinterpret_cast<const char*>(loaded_apk.resources_asset_.getBuffer(true /*wordAligned*/)),
-  //       loaded_apk.resources_asset_.getLength());
-    StringPiece data = new StringPiece(
-        ByteBuffer.wrap(loaded_apk.resources_asset_.getBuffer(true /*wordAligned*/))
-            .order(ByteOrder.LITTLE_ENDIAN),
-        0 /*(int) loaded_apk.resources_asset_.getLength()*/);
-    loaded_apk.loaded_arsc_ =
-        LoadedArsc.Load(data, loaded_idmap, system, load_as_shared_library);
+    // const StringPiece data(
+    //       reinterpret_cast<const char*>(loaded_apk.resources_asset_.getBuffer(true
+    // /*wordAligned*/)),
+    //       loaded_apk.resources_asset_.getLength());
+    StringPiece data =
+        new StringPiece(
+            ByteBuffer.wrap(loaded_apk.resources_asset_.getBuffer(true /*wordAligned*/))
+                .order(ByteOrder.LITTLE_ENDIAN),
+            0 /*(int) loaded_apk.resources_asset_.getLength()*/);
+    loaded_apk.loaded_arsc_ = LoadedArsc.Load(data, loaded_idmap, system, load_as_shared_library);
     if (loaded_apk.loaded_arsc_ == null) {
       System.err.println("Failed to load '" + kResourcesArsc + "' in APK '" + path + "'.");
       return null;
@@ -325,8 +344,7 @@ public class CppApkAssets {
       // }
       FileMap map = zipFileRO.createEntryFileMap(entry);
 
-      Asset asset =
-          Asset.createFromCompressedMap(map, (int) entry.entry.getSize(), mode);
+      Asset asset = Asset.createFromCompressedMap(map, (int) entry.entry.getSize(), mode);
       if (asset == null) {
         System.err.println("Failed to decompress '" + path + "'.");
         return null;
@@ -354,8 +372,7 @@ public class CppApkAssets {
     void callback(String string, FileType fileType);
   }
 
-  boolean ForEachFile(String root_path,
-      ForEachFileCallback f) {
+  boolean ForEachFile(String root_path, ForEachFileCallback f) {
     if (zip_handle_ == null || zipFileRO == null) {
       // In this case, the ApkAssets was loaded from a pure ARSC, and does not have assets.
       return false;
@@ -386,7 +403,7 @@ public class CppApkAssets {
     // int32_t result;
     // while ((result = Next(cookie, &entry, &name)) == 0) {
     while (entries.hasMoreElements()) {
-      ZipEntry zipEntry =  entries.nextElement();
+      ZipEntry zipEntry = entries.nextElement();
       if (!zipEntry.getName().startsWith(prefix)) {
         continue;
       }
@@ -422,6 +439,5 @@ public class CppApkAssets {
     // return result == -1;
     return true;
   }
-//
-}  // namespace android
-
+  //
+} // namespace android
diff --git a/resources/src/main/java/org/robolectric/res/android/CppAssetManager.java b/resources/src/main/java/org/robolectric/res/android/CppAssetManager.java
index 4f95df813..92cd7b328 100644
--- a/resources/src/main/java/org/robolectric/res/android/CppAssetManager.java
+++ b/resources/src/main/java/org/robolectric/res/android/CppAssetManager.java
@@ -33,7 +33,8 @@ import org.robolectric.res.android.AssetDir.FileInfo;
 import org.robolectric.res.android.ZipFileRO.ZipEntryRO;
 import org.robolectric.util.PerfStatsCollector;
 
-// transliterated from https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/AssetManager.cpp
+// transliterated from
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/AssetManager.cpp
 @SuppressWarnings("NewApi")
 public class CppAssetManager {
 
@@ -41,7 +42,7 @@ public class CppAssetManager {
 
   enum FileType {
     kFileTypeUnknown,
-    kFileTypeNonexistent,       // i.e. ENOENT
+    kFileTypeNonexistent, // i.e. ENOENT
     kFileTypeRegular,
     kFileTypeDirectory,
     kFileTypeCharDev,
@@ -54,15 +55,17 @@ public class CppAssetManager {
   // transliterated from
   // https://cs.android.com/android/platform/superproject/+/master:frameworks/base/libs/androidfw/include/androidfw/AssetManager.h
   private static class asset_path {
-//    asset_path() : path(""), type(kFileTypeRegular), idmap(""),
-//      isSystemOverlay(false), isSystemAsset(false) {}
-
+    //    asset_path() : path(""), type(kFileTypeRegular), idmap(""),
+    //      isSystemOverlay(false), isSystemAsset(false) {}
 
     public asset_path() {
       this(new String8(), FileType.kFileTypeRegular, new String8(""), false, false);
     }
 
-    public asset_path(String8 path, FileType fileType, String8 idmap,
+    public asset_path(
+        String8 path,
+        FileType fileType,
+        String8 idmap,
         boolean isSystemOverlay,
         boolean isSystemAsset) {
       this.path = path;
@@ -80,13 +83,19 @@ public class CppAssetManager {
 
     @Override
     public String toString() {
-      return "asset_path{" +
-          "path=" + path +
-          ", type=" + type +
-          ", idmap='" + idmap + '\'' +
-          ", isSystemOverlay=" + isSystemOverlay +
-          ", isSystemAsset=" + isSystemAsset +
-          '}';
+      return "asset_path{"
+          + "path="
+          + path
+          + ", type="
+          + type
+          + ", idmap='"
+          + idmap
+          + '\''
+          + ", isSystemOverlay="
+          + isSystemOverlay
+          + ", isSystemAsset="
+          + isSystemAsset
+          + '}';
     }
   }
 
@@ -102,120 +111,119 @@ public class CppAssetManager {
   private ResTable mResources;
   private ResTable_config mConfig = new ResTable_config();
 
-
   //  static final boolean kIsDebug = false;
-//  
+  //
   static final String kAssetsRoot = "assets";
-  static final String kAppZipName = null; //"classes.jar";
+  static final String kAppZipName = null; // "classes.jar";
   static final String kSystemAssets = "android.jar";
   //  static final char* kResourceCache = "resource-cache";
-//  
+  //
   static final String kExcludeExtension = ".EXCLUDE";
-//  
+  //
 
   // static Asset final kExcludedAsset = (Asset*) 0xd000000d;
   static final Asset kExcludedAsset = Asset.EXCLUDED_ASSET;
 
+  static volatile int gCount = 0;
 
- static volatile int gCount = 0;
-
-//  final char* RESOURCES_FILENAME = "resources.arsc";
-//  final char* IDMAP_BIN = "/system/bin/idmap";
-//  final char* OVERLAY_DIR = "/vendor/overlay";
-//  final char* OVERLAY_THEME_DIR_PROPERTY = "ro.boot.vendor.overlay.theme";
-//  final char* TARGET_PACKAGE_NAME = "android";
-//  final char* TARGET_APK_PATH = "/system/framework/framework-res.apk";
-//  final char* IDMAP_DIR = "/data/resource-cache";
-//  
-//  namespace {
-//  
+  //  final char* RESOURCES_FILENAME = "resources.arsc";
+  //  final char* IDMAP_BIN = "/system/bin/idmap";
+  //  final char* OVERLAY_DIR = "/vendor/overlay";
+  //  final char* OVERLAY_THEME_DIR_PROPERTY = "ro.boot.vendor.overlay.theme";
+  //  final char* TARGET_PACKAGE_NAME = "android";
+  //  final char* TARGET_APK_PATH = "/system/framework/framework-res.apk";
+  //  final char* IDMAP_DIR = "/data/resource-cache";
+  //
+  //  namespace {
+  //
   String8 idmapPathForPackagePath(final String8 pkgPath) {
     // TODO: implement this?
     return pkgPath;
-//    const char* root = getenv("ANDROID_DATA");
-//    LOG_ALWAYS_FATAL_IF(root == NULL, "ANDROID_DATA not set");
-//    String8 path(root);
-//    path.appendPath(kResourceCache);
-//    char buf[256]; // 256 chars should be enough for anyone...
-//    strncpy(buf, pkgPath.string(), 255);
-//    buf[255] = '\0';
-//    char* filename = buf;
-//    while (*filename && *filename == '/') {
-//      ++filename;
-//    }
-//    char* p = filename;
-//    while (*p) {
-//      if (*p == '/') {
-//           *p = '@';
-//      }
-//      ++p;
-//    }
-//    path.appendPath(filename);
-//    path.append("@idmap");
-//    return path;
+    //    const char* root = getenv("ANDROID_DATA");
+    //    LOG_ALWAYS_FATAL_IF(root == NULL, "ANDROID_DATA not set");
+    //    String8 path(root);
+    //    path.appendPath(kResourceCache);
+    //    char buf[256]; // 256 chars should be enough for anyone...
+    //    strncpy(buf, pkgPath.string(), 255);
+    //    buf[255] = '\0';
+    //    char* filename = buf;
+    //    while (*filename && *filename == '/') {
+    //      ++filename;
+    //    }
+    //    char* p = filename;
+    //    while (*p) {
+    //      if (*p == '/') {
+    //           *p = '@';
+    //      }
+    //      ++p;
+    //    }
+    //    path.appendPath(filename);
+    //    path.append("@idmap");
+    //    return path;
   }
-//  
-//  /*
-//   * Like strdup(), but uses C++ "new" operator instead of malloc.
-//   */
-//  static char* strdupNew(final char* str) {
-//      char* newStr;
-//      int len;
-//  
-//      if (str == null)
-//          return null;
-//  
-//      len = strlen(str);
-//      newStr = new char[len+1];
-//      memcpy(newStr, str, len+1);
-//  
-//      return newStr;
-//  }
-//  
-//  } // namespace
-//  
-//  /*
-//   * ===========================================================================
-//   *      AssetManager
-//   * ===========================================================================
-//   */
+
+  //
+  //  /*
+  //   * Like strdup(), but uses C++ "new" operator instead of malloc.
+  //   */
+  //  static char* strdupNew(final char* str) {
+  //      char* newStr;
+  //      int len;
+  //
+  //      if (str == null)
+  //          return null;
+  //
+  //      len = strlen(str);
+  //      newStr = new char[len+1];
+  //      memcpy(newStr, str, len+1);
+  //
+  //      return newStr;
+  //  }
+  //
+  //  } // namespace
+  //
+  //  /*
+  //   * ===========================================================================
+  //   *      AssetManager
+  //   * ===========================================================================
+  //   */
 
   public static int getGlobalCount() {
     return gCount;
   }
 
-//  AssetManager() :
-//          mLocale(null), mResources(null), mConfig(new ResTable_config) {
-//      int count = android_atomic_inc(&gCount) + 1;
-//      if (kIsDebug) {
-//          ALOGI("Creating AssetManager %s #%d\n", this, count);
-//      }
-//      memset(mConfig, 0, sizeof(ResTable_config));
-//  }
-//  
-//  ~AssetManager() {
-//      int count = android_atomic_dec(&gCount);
-//      if (kIsDebug) {
-//          ALOGI("Destroying AssetManager in %s #%d\n", this, count);
-//      } else {
-//          ALOGI("Destroying AssetManager in %s #%d\n", this, count);
-//      }
-//      // Manually close any fd paths for which we have not yet opened their zip (which
-//      // will take ownership of the fd and close it when done).
-//      for (size_t i=0; i<mAssetPaths.size(); i++) {
-//          ALOGV("Cleaning path #%d: fd=%d, zip=%p", (int)i, mAssetPaths[i].rawFd,
-//                  mAssetPaths[i].zip.get());
-//          if (mAssetPaths[i].rawFd >= 0 && mAssetPaths[i].zip == NULL) {
-//              close(mAssetPaths[i].rawFd);
-//          }
-//      }
-//
-//      delete mConfig;
-//      delete mResources;
-//  
-//      // don't have a String class yet, so make sure we clean up
-//      delete[] mLocale;
-//  }
+  //  AssetManager() :
+  //          mLocale(null), mResources(null), mConfig(new ResTable_config) {
+  //      int count = android_atomic_inc(&gCount) + 1;
+  //      if (kIsDebug) {
+  //          ALOGI("Creating AssetManager %s #%d\n", this, count);
+  //      }
+  //      memset(mConfig, 0, sizeof(ResTable_config));
+  //  }
+  //
+  //  ~AssetManager() {
+  //      int count = android_atomic_dec(&gCount);
+  //      if (kIsDebug) {
+  //          ALOGI("Destroying AssetManager in %s #%d\n", this, count);
+  //      } else {
+  //          ALOGI("Destroying AssetManager in %s #%d\n", this, count);
+  //      }
+  //      // Manually close any fd paths for which we have not yet opened their zip (which
+  //      // will take ownership of the fd and close it when done).
+  //      for (size_t i=0; i<mAssetPaths.size(); i++) {
+  //          ALOGV("Cleaning path #%d: fd=%d, zip=%p", (int)i, mAssetPaths[i].rawFd,
+  //                  mAssetPaths[i].zip.get());
+  //          if (mAssetPaths[i].rawFd >= 0 && mAssetPaths[i].zip == NULL) {
+  //              close(mAssetPaths[i].rawFd);
+  //          }
+  //      }
+  //
+  //      delete mConfig;
+  //      delete mResources;
+  //
+  //      // don't have a String class yet, so make sure we clean up
+  //      delete[] mLocale;
+  //  }
 
   public boolean addAssetPath(String8 path, Ref<Integer> cookie, boolean appAsLib) {
     return addAssetPath(path, cookie, appAsLib, false);
@@ -224,7 +232,6 @@ public class CppAssetManager {
   public boolean addAssetPath(
       final String8 path, @Nullable Ref<Integer> cookie, boolean appAsLib, boolean isSystemAsset) {
     synchronized (mLock) {
-
       asset_path ap = new asset_path();
 
       String8 realPath = path;
@@ -238,7 +245,8 @@ public class CppAssetManager {
         ap.path = path;
         ap.type = getFileType(path.string());
         if (ap.type != kFileTypeDirectory && ap.type != FileType.kFileTypeRegular) {
-          ALOGW("Asset path %s is neither a directory nor file (type=%s).",
+          ALOGW(
+              "Asset path %s is neither a directory nor file (type=%s).",
               path.toString(), ap.type.name());
           return false;
         }
@@ -254,8 +262,7 @@ public class CppAssetManager {
         }
       }
 
-      ALOGV("In %s Asset %s path: %s", this,
-          ap.type.name(), ap.path.toString());
+      ALOGV("In %s Asset %s path: %s", this, ap.type.name(), ap.path.toString());
 
       ap.isSystemAsset = isSystemAsset;
       /*int apPos =*/ mAssetPaths.add(ap);
@@ -266,15 +273,15 @@ public class CppAssetManager {
       }
 
       // TODO: implement this?
-      //#ifdef __ANDROID__
+      // #ifdef __ANDROID__
       // Load overlays, if any
-      //asset_path oap;
-      //for (int idx = 0; mZipSet.getOverlay(ap.path, idx, & oap)
+      // asset_path oap;
+      // for (int idx = 0; mZipSet.getOverlay(ap.path, idx, & oap)
       //  ; idx++){
       //  oap.isSystemAsset = isSystemAsset;
       //  mAssetPaths.add(oap);
       // }
-      //#endif
+      // #endif
 
       if (mResources != null) {
         // appendPathToResTable(mAssetPaths.editItemAt(apPos), appAsLib);
@@ -396,23 +403,24 @@ public class CppAssetManager {
     String8 path = new String8(systemAssetsPath);
     return addAssetPath(path, null, false /* appAsLib */, true /* isSystemAsset */);
   }
-//  
-//  int nextAssetPath(final int cookie) final
-//  {
-//      AutoMutex _l(mLock);
-//      final int next = static_cast<int>(cookie) + 1;
-//      return next > mAssetPaths.size() ? -1 : next;
-//  }
-//  
-//  String8 getAssetPath(final int cookie) final
-//  {
-//      AutoMutex _l(mLock);
-//      final int which = static_cast<int>(cookie) - 1;
-//      if (which < mAssetPaths.size()) {
-//          return mAssetPaths[which].path;
-//      }
-//      return String8();
-//  }
+
+  //
+  //  int nextAssetPath(final int cookie) final
+  //  {
+  //      AutoMutex _l(mLock);
+  //      final int next = static_cast<int>(cookie) + 1;
+  //      return next > mAssetPaths.size() ? -1 : next;
+  //  }
+  //
+  //  String8 getAssetPath(final int cookie) final
+  //  {
+  //      AutoMutex _l(mLock);
+  //      final int which = static_cast<int>(cookie) - 1;
+  //      if (which < mAssetPaths.size()) {
+  //          return mAssetPaths[which].path;
+  //      }
+  //      return String8();
+  //  }
 
   void setLocaleLocked(final String locale) {
     //      if (mLocale != null) {
@@ -430,7 +438,7 @@ public class CppAssetManager {
         setLocaleLocked(locale);
       } else {
         if (config.language[0] != 0) {
-//          byte[] spec = new byte[RESTABLE_MAX_LOCALE_LEN];
+          //          byte[] spec = new byte[RESTABLE_MAX_LOCALE_LEN];
           String spec = config.getBcp47Locale(false);
           setLocaleLocked(spec);
         } else {
@@ -471,10 +479,10 @@ public class CppAssetManager {
       int i = mAssetPaths.size();
       while (i > 0) {
         i--;
-        ALOGV("Looking for asset '%s' in '%s'\n",
+        ALOGV(
+            "Looking for asset '%s' in '%s'\n",
             assetName.string(), mAssetPaths.get(i).path.string());
-        Asset pAsset = openNonAssetInPathLocked(assetName.string(), mode,
-            mAssetPaths.get(i));
+        Asset pAsset = openNonAssetInPathLocked(assetName.string(), mode, mAssetPaths.get(i));
         if (pAsset != null) {
           return Objects.equals(pAsset, kExcludedAsset) ? null : pAsset;
         }
@@ -502,10 +510,8 @@ public class CppAssetManager {
       int i = mAssetPaths.size();
       while (i > 0) {
         i--;
-        ALOGV("Looking for non-asset '%s' in '%s'\n", fileName,
-            mAssetPaths.get(i).path.string());
-        Asset pAsset = openNonAssetInPathLocked(
-            fileName, mode, mAssetPaths.get(i));
+        ALOGV("Looking for non-asset '%s' in '%s'\n", fileName, mAssetPaths.get(i).path.string());
+        Asset pAsset = openNonAssetInPathLocked(fileName, mode, mAssetPaths.get(i));
         if (pAsset != null) {
           if (outCookie != null) {
             outCookie.set(i + 1);
@@ -525,10 +531,9 @@ public class CppAssetManager {
       LOG_FATAL_IF(mAssetPaths.isEmpty(), "No assets added to AssetManager");
 
       if (which < mAssetPaths.size()) {
-        ALOGV("Looking for non-asset '%s' in '%s'\n", fileName,
-            mAssetPaths.get(which).path.string());
-        Asset pAsset = openNonAssetInPathLocked(
-            fileName, mode, mAssetPaths.get(which));
+        ALOGV(
+            "Looking for non-asset '%s' in '%s'\n", fileName, mAssetPaths.get(which).path.string());
+        Asset pAsset = openNonAssetInPathLocked(fileName, mode, mAssetPaths.get(which));
         if (pAsset != null) {
           return pAsset != kExcludedAsset ? pAsset : null;
         }
@@ -553,21 +558,21 @@ public class CppAssetManager {
       return kFileTypeDirectory;
     }
     return FileType.kFileTypeNonexistent;
-//      Asset pAsset = null;
-//
-//      /*
-//       * Open the asset.  This is less efficient than simply finding the
-//       * file, but it's not too bad (we don't uncompress or mmap data until
-//       * the first read() call).
-//       */
-//      pAsset = open(fileName, Asset.AccessMode.ACCESS_STREAMING);
-//      // delete pAsset;
-//
-//      if (pAsset == null) {
-//          return FileType.kFileTypeNonexistent;
-//      } else {
-//          return FileType.kFileTypeRegular;
-//      }
+    //      Asset pAsset = null;
+    //
+    //      /*
+    //       * Open the asset.  This is less efficient than simply finding the
+    //       * file, but it's not too bad (we don't uncompress or mmap data until
+    //       * the first read() call).
+    //       */
+    //      pAsset = open(fileName, Asset.AccessMode.ACCESS_STREAMING);
+    //      // delete pAsset;
+    //
+    //      if (pAsset == null) {
+    //          return FileType.kFileTypeNonexistent;
+    //      } else {
+    //          return FileType.kFileTypeRegular;
+    //      }
   }
 
   boolean appendPathToResTable(final asset_path ap, boolean appAsLib) {
@@ -579,29 +584,30 @@ public class CppAssetManager {
 
   boolean appendPathToResTable_measured(final asset_path ap, boolean appAsLib) {
     // TODO: properly handle reading system resources
-//    if (!ap.isSystemAsset) {
-//      URL resource = getClass().getResource("/resources.ap_"); // todo get this from asset_path
-//      // System.out.println("Reading ARSC file  from " + resource);
-//      LOG_FATAL_IF(resource == null, "Could not find resources.ap_");
-//      try {
-//        ZipFile zipFile = new ZipFile(resource.getFile());
-//        ZipEntry arscEntry = zipFile.getEntry("resources.arsc");
-//        InputStream inputStream = zipFile.getInputStream(arscEntry);
-//        mResources.add(inputStream, mResources.getTableCount() + 1);
-//      } catch (IOException e) {
-//        throw new RuntimeException(e);
-//      }
-//    } else {
-//      try {
-//        ZipFile zipFile = new ZipFile(ap.path.string());
-//        ZipEntry arscEntry = zipFile.getEntry("resources.arsc");
-//        InputStream inputStream = zipFile.getInputStream(arscEntry);
-//        mResources.add(inputStream, mResources.getTableCount() + 1);
-//      } catch (IOException e) {
-//        e.printStackTrace();
-//      }
-//    }
-//    return false;
+    //    if (!ap.isSystemAsset) {
+    //      URL resource = getClass().getResource("/resources.ap_"); // todo get this from
+    // asset_path
+    //      // System.out.println("Reading ARSC file  from " + resource);
+    //      LOG_FATAL_IF(resource == null, "Could not find resources.ap_");
+    //      try {
+    //        ZipFile zipFile = new ZipFile(resource.getFile());
+    //        ZipEntry arscEntry = zipFile.getEntry("resources.arsc");
+    //        InputStream inputStream = zipFile.getInputStream(arscEntry);
+    //        mResources.add(inputStream, mResources.getTableCount() + 1);
+    //      } catch (IOException e) {
+    //        throw new RuntimeException(e);
+    //      }
+    //    } else {
+    //      try {
+    //        ZipFile zipFile = new ZipFile(ap.path.string());
+    //        ZipEntry arscEntry = zipFile.getEntry("resources.arsc");
+    //        InputStream inputStream = zipFile.getInputStream(arscEntry);
+    //        mResources.add(inputStream, mResources.getTableCount() + 1);
+    //      } catch (IOException e) {
+    //        e.printStackTrace();
+    //      }
+    //    }
+    //    return false;
 
     // skip those ap's that correspond to system overlays
     if (ap.isSystemOverlay) {
@@ -612,7 +618,7 @@ public class CppAssetManager {
     ResTable sharedRes = null;
     boolean shared = true;
     boolean onlyEmptyResources = true;
-//      ATRACE_NAME(ap.path.string());
+    //      ATRACE_NAME(ap.path.string());
     Asset idmap = openIdmapLocked(ap);
     int nextEntryIdx = mResources.getTableCount();
     ALOGV("Looking for resource asset in '%s'\n", ap.path.string());
@@ -630,9 +636,7 @@ public class CppAssetManager {
         ass = mZipSet.getZipResourceTableAsset(ap.path);
         if (ass == null) {
           ALOGV("loading resource table %s\n", ap.path.string());
-          ass = openNonAssetInPathLocked("resources.arsc",
-              AccessMode.ACCESS_BUFFER,
-              ap);
+          ass = openNonAssetInPathLocked("resources.arsc", AccessMode.ACCESS_BUFFER, ap);
           if (ass != null && ass != kExcludedAsset) {
             ass = mZipSet.setZipResourceTableAsset(ap.path, ass);
           }
@@ -645,22 +649,21 @@ public class CppAssetManager {
           ALOGV("Creating shared resources for %s", ap.path.string());
           sharedRes = new ResTable();
           sharedRes.add(ass, idmap, nextEntryIdx + 1, false, false, false);
-//  #ifdef __ANDROID__
-//                  final char* data = getenv("ANDROID_DATA");
-//                  LOG_ALWAYS_FATAL_IF(data == null, "ANDROID_DATA not set");
-//                  String8 overlaysListPath(data);
-//                  overlaysListPath.appendPath(kResourceCache);
-//                  overlaysListPath.appendPath("overlays.list");
-//                  addSystemOverlays(overlaysListPath.string(), ap.path, sharedRes, nextEntryIdx);
-//  #endif
+          //  #ifdef __ANDROID__
+          //                  final char* data = getenv("ANDROID_DATA");
+          //                  LOG_ALWAYS_FATAL_IF(data == null, "ANDROID_DATA not set");
+          //                  String8 overlaysListPath(data);
+          //                  overlaysListPath.appendPath(kResourceCache);
+          //                  overlaysListPath.appendPath("overlays.list");
+          //                  addSystemOverlays(overlaysListPath.string(), ap.path, sharedRes,
+          // nextEntryIdx);
+          //  #endif
           sharedRes = mZipSet.setZipResourceTable(ap.path, sharedRes);
         }
       }
     } else {
       ALOGV("loading resource table %s\n", ap.path.string());
-      ass = openNonAssetInPathLocked("resources.arsc",
-          AccessMode.ACCESS_BUFFER,
-          ap);
+      ass = openNonAssetInPathLocked("resources.arsc", AccessMode.ACCESS_BUFFER, ap);
       shared = false;
     }
 
@@ -675,17 +678,17 @@ public class CppAssetManager {
       }
       onlyEmptyResources = false;
 
-//          if (!shared) {
-//              delete ass;
-//          }
+      //          if (!shared) {
+      //              delete ass;
+      //          }
     } else {
       ALOGV("Installing empty resources in to table %s\n", mResources);
       mResources.addEmpty(nextEntryIdx + 1);
     }
 
-//      if (idmap != null) {
-//          delete idmap;
-//      }
+    //      if (idmap != null) {
+    //          delete idmap;
+    //      }
     return onlyEmptyResources;
   }
 
@@ -706,23 +709,26 @@ public class CppAssetManager {
         LOG_FATAL_IF(mAssetPaths.isEmpty(), "No assets added to AssetManager");
       }
 
-      PerfStatsCollector.getInstance().measure("load binary resources", () -> {
-        mResources = new ResTable();
-        updateResourceParamsLocked();
-
-        boolean onlyEmptyResources = true;
-        final int N = mAssetPaths.size();
-        for (int i = 0; i < N; i++) {
-          boolean empty = appendPathToResTable(mAssetPaths.get(i), false);
-          onlyEmptyResources = onlyEmptyResources && empty;
-        }
-
-        if (required && onlyEmptyResources) {
-          ALOGW("Unable to find resources file resources.arsc");
-//          delete mResources;
-          mResources = null;
-        }
-      });
+      PerfStatsCollector.getInstance()
+          .measure(
+              "load binary resources",
+              () -> {
+                mResources = new ResTable();
+                updateResourceParamsLocked();
+
+                boolean onlyEmptyResources = true;
+                final int N = mAssetPaths.size();
+                for (int i = 0; i < N; i++) {
+                  boolean empty = appendPathToResTable(mAssetPaths.get(i), false);
+                  onlyEmptyResources = onlyEmptyResources && empty;
+                }
+
+                if (required && onlyEmptyResources) {
+                  ALOGW("Unable to find resources file resources.arsc");
+                  //          delete mResources;
+                  mResources = null;
+                }
+              });
 
       return mResources;
     }
@@ -757,57 +763,57 @@ public class CppAssetManager {
     return ass;
   }
 
-//  void addSystemOverlays(final char* pathOverlaysList,
-//          final String8& targetPackagePath, ResTable* sharedRes, int offset) final
-//  {
-//      FILE* fin = fopen(pathOverlaysList, "r");
-//      if (fin == null) {
-//          return;
-//      }
-//  
-//  #ifndef _WIN32
-//      if (TEMP_FAILURE_RETRY(flock(fileno(fin), LOCK_SH)) != 0) {
-//          fclose(fin);
-//          return;
-//      }
-//  #endif
-//      char buf[1024];
-//      while (fgets(buf, sizeof(buf), fin)) {
-//          // format of each line:
-//          //   <path to apk><space><path to idmap><newline>
-//          char* space = strchr(buf, ' ');
-//          char* newline = strchr(buf, '\n');
-//          asset_path oap;
-//  
-//          if (space == null || newline == null || newline < space) {
-//              continue;
-//          }
-//  
-//          oap.path = String8(buf, space - buf);
-//          oap.type = kFileTypeRegular;
-//          oap.idmap = String8(space + 1, newline - space - 1);
-//          oap.isSystemOverlay = true;
-//  
-//          Asset* oass = final_cast<AssetManager*>(this).
-//              openNonAssetInPathLocked("resources.arsc",
-//                      Asset.ACCESS_BUFFER,
-//                      oap);
-//  
-//          if (oass != null) {
-//              Asset* oidmap = openIdmapLocked(oap);
-//              offset++;
-//              sharedRes.add(oass, oidmap, offset + 1, false);
-//              final_cast<AssetManager*>(this).mAssetPaths.add(oap);
-//              final_cast<AssetManager*>(this).mZipSet.addOverlay(targetPackagePath, oap);
-//              delete oidmap;
-//          }
-//      }
-//  
-//  #ifndef _WIN32
-//      TEMP_FAILURE_RETRY(flock(fileno(fin), LOCK_UN));
-//  #endif
-//      fclose(fin);
-//  }
+  //  void addSystemOverlays(final char* pathOverlaysList,
+  //          final String8& targetPackagePath, ResTable* sharedRes, int offset) final
+  //  {
+  //      FILE* fin = fopen(pathOverlaysList, "r");
+  //      if (fin == null) {
+  //          return;
+  //      }
+  //
+  //  #ifndef _WIN32
+  //      if (TEMP_FAILURE_RETRY(flock(fileno(fin), LOCK_SH)) != 0) {
+  //          fclose(fin);
+  //          return;
+  //      }
+  //  #endif
+  //      char buf[1024];
+  //      while (fgets(buf, sizeof(buf), fin)) {
+  //          // format of each line:
+  //          //   <path to apk><space><path to idmap><newline>
+  //          char* space = strchr(buf, ' ');
+  //          char* newline = strchr(buf, '\n');
+  //          asset_path oap;
+  //
+  //          if (space == null || newline == null || newline < space) {
+  //              continue;
+  //          }
+  //
+  //          oap.path = String8(buf, space - buf);
+  //          oap.type = kFileTypeRegular;
+  //          oap.idmap = String8(space + 1, newline - space - 1);
+  //          oap.isSystemOverlay = true;
+  //
+  //          Asset* oass = final_cast<AssetManager*>(this).
+  //              openNonAssetInPathLocked("resources.arsc",
+  //                      Asset.ACCESS_BUFFER,
+  //                      oap);
+  //
+  //          if (oass != null) {
+  //              Asset* oidmap = openIdmapLocked(oap);
+  //              offset++;
+  //              sharedRes.add(oass, oidmap, offset + 1, false);
+  //              final_cast<AssetManager*>(this).mAssetPaths.add(oap);
+  //              final_cast<AssetManager*>(this).mZipSet.addOverlay(targetPackagePath, oap);
+  //              delete oidmap;
+  //          }
+  //      }
+  //
+  //  #ifndef _WIN32
+  //      TEMP_FAILURE_RETRY(flock(fileno(fin), LOCK_UN));
+  //  #endif
+  //      fclose(fin);
+  //  }
 
   public final ResTable getResources() {
     return getResources(true);
@@ -819,19 +825,19 @@ public class CppAssetManager {
   }
 
   //  boolean isUpToDate()
-//  {
-//      AutoMutex _l(mLock);
-//      return mZipSet.isUpToDate();
-//  }
-//  
-//  void getLocales(Vector<String8>* locales, boolean includeSystemLocales) final
-//  {
-//      ResTable* res = mResources;
-//      if (res != null) {
-//          res.getLocales(locales, includeSystemLocales, true /* mergeEquivalentLangs */);
-//      }
-//  }
-//  
+  //  {
+  //      AutoMutex _l(mLock);
+  //      return mZipSet.isUpToDate();
+  //  }
+  //
+  //  void getLocales(Vector<String8>* locales, boolean includeSystemLocales) final
+  //  {
+  //      ResTable* res = mResources;
+  //      if (res != null) {
+  //          res.getLocales(locales, includeSystemLocales, true /* mergeEquivalentLangs */);
+  //      }
+  //  }
+  //
   /*
    * Open a non-asset file as if it were an asset, searching for it in the
    * specified app.
@@ -839,11 +845,11 @@ public class CppAssetManager {
    * Pass in a null values for "appName" if the common app directory should
    * be used.
    */
-  static Asset openNonAssetInPathLocked(final String fileName, AccessMode mode,
-      final asset_path ap) {
+  static Asset openNonAssetInPathLocked(
+      final String fileName, AccessMode mode, final asset_path ap) {
     Asset pAsset = null;
 
-      /* look at the filesystem on disk */
+    /* look at the filesystem on disk */
     if (ap.type == kFileTypeDirectory) {
       String8 path = new String8(ap.path);
       path.appendPath(fileName);
@@ -851,13 +857,13 @@ public class CppAssetManager {
       pAsset = openAssetFromFileLocked(path, mode);
 
       if (pAsset == null) {
-              /* try again, this time with ".gz" */
+        /* try again, this time with ".gz" */
         path.append(".gz");
         pAsset = openAssetFromFileLocked(path, mode);
       }
 
       if (pAsset != null) {
-        //printf("FOUND NA '%s' on disk\n", fileName);
+        // printf("FOUND NA '%s' on disk\n", fileName);
         pAsset.setAssetSource(path);
       }
 
@@ -865,20 +871,20 @@ public class CppAssetManager {
     } else {
       String8 path = new String8(fileName);
 
-          /* check the appropriate Zip file */
+      /* check the appropriate Zip file */
       ZipFileRO pZip = getZipFileLocked(ap);
       if (pZip != null) {
-        //printf("GOT zip, checking NA '%s'\n", (final char*) path);
+        // printf("GOT zip, checking NA '%s'\n", (final char*) path);
         ZipEntryRO entry = pZip.findEntryByName(path.string());
         if (entry != null) {
-          //printf("FOUND NA in Zip file for %s\n", appName ? appName : kAppCommon);
+          // printf("FOUND NA in Zip file for %s\n", appName ? appName : kAppCommon);
           pAsset = openAssetFromZipLocked(pZip, entry, mode, path);
           pZip.releaseEntry(entry);
         }
       }
 
       if (pAsset != null) {
-              /* create a "source" name, for debug/display */
+        /* create a "source" name, for debug/display */
         pAsset.setAssetSource(
             createZipSourceNameLocked(ap.path, new String8(), new String8(fileName)));
       }
@@ -890,8 +896,8 @@ public class CppAssetManager {
   /*
    * Create a "source name" for a file from a Zip archive.
    */
-  static String8 createZipSourceNameLocked(final String8 zipFileName,
-      final String8 dirName, final String8 fileName) {
+  static String8 createZipSourceNameLocked(
+      final String8 zipFileName, final String8 dirName, final String8 fileName) {
     String8 sourceName = new String8("zip:");
     sourceName.append(zipFileName.string());
     sourceName.append(":");
@@ -935,15 +941,14 @@ public class CppAssetManager {
    * This returns null if the file doesn't exist, couldn't be opened, or
    * claims to be a ".gz" but isn't.
    */
-  static Asset openAssetFromFileLocked(final String8 pathName,
-      AccessMode mode) {
+  static Asset openAssetFromFileLocked(final String8 pathName, AccessMode mode) {
     Asset pAsset = null;
 
     if (pathName.getPathExtension().toLowerCase().equals(".gz")) {
-      //printf("TRYING '%s'\n", (final char*) pathName);
+      // printf("TRYING '%s'\n", (final char*) pathName);
       pAsset = Asset.createFromCompressedFile(pathName.string(), mode);
     } else {
-      //printf("TRYING '%s'\n", (final char*) pathName);
+      // printf("TRYING '%s'\n", (final char*) pathName);
       pAsset = Asset.createFromFile(pathName.string(), mode);
     }
 
@@ -956,40 +961,41 @@ public class CppAssetManager {
    * If the entry is uncompressed, we may want to create or share a
    * slice of shared memory.
    */
-  static Asset openAssetFromZipLocked(final ZipFileRO pZipFile,
-      final ZipEntryRO entry, AccessMode mode, final String8 entryName) {
+  static Asset openAssetFromZipLocked(
+      final ZipFileRO pZipFile, final ZipEntryRO entry, AccessMode mode, final String8 entryName) {
     Asset pAsset = null;
 
     // TODO: look for previously-created shared memory slice?
     final Ref<Short> method = new Ref<>((short) 0);
     final Ref<Long> uncompressedLen = new Ref<>(0L);
 
-    //printf("USING Zip '%s'\n", pEntry.getFileName());
+    // printf("USING Zip '%s'\n", pEntry.getFileName());
 
-    if (!pZipFile.getEntryInfo(entry, method, uncompressedLen, null, null,
-        null, null)) {
+    if (!pZipFile.getEntryInfo(entry, method, uncompressedLen, null, null, null, null)) {
       ALOGW("getEntryInfo failed\n");
       return null;
     }
 
-    //return Asset.createFromZipEntry(pZipFile, entry, entryName);
+    // return Asset.createFromZipEntry(pZipFile, entry, entryName);
     FileMap dataMap = pZipFile.createEntryFileMap(entry);
-//      if (dataMap == null) {
-//          ALOGW("create map from entry failed\n");
-//          return null;
-//      }
-//
+    //      if (dataMap == null) {
+    //          ALOGW("create map from entry failed\n");
+    //          return null;
+    //      }
+    //
     if (method.get() == ZipFileRO.kCompressStored) {
       pAsset = Asset.createFromUncompressedMap(dataMap, mode);
-      ALOGV("Opened uncompressed entry %s in zip %s mode %s: %s", entryName.string(),
-          pZipFile.mFileName, mode, pAsset);
+      ALOGV(
+          "Opened uncompressed entry %s in zip %s mode %s: %s",
+          entryName.string(), pZipFile.mFileName, mode, pAsset);
     } else {
       pAsset = Asset.createFromCompressedMap(dataMap, toIntExact(uncompressedLen.get()), mode);
-      ALOGV("Opened compressed entry %s in zip %s mode %s: %s", entryName.string(),
-          pZipFile.mFileName, mode, pAsset);
+      ALOGV(
+          "Opened compressed entry %s in zip %s mode %s: %s",
+          entryName.string(), pZipFile.mFileName, mode, pAsset);
     }
     if (pAsset == null) {
-         /* unexpected */
+      /* unexpected */
       ALOGW("create from segment failed\n");
     }
 
@@ -1011,7 +1017,7 @@ public class CppAssetManager {
       LOG_FATAL_IF(mAssetPaths.isEmpty(), "No assets added to AssetManager");
       Preconditions.checkNotNull(dirName);
 
-      //printf("+++ openDir(%s) in '%s'\n", dirName, (final char*) mAssetBase);
+      // printf("+++ openDir(%s) in '%s'\n", dirName, (final char*) mAssetBase);
 
       pDir = new AssetDir();
 
@@ -1039,14 +1045,14 @@ public class CppAssetManager {
         }
       }
 
-//  #if 0
-//        printf("FILE LIST:\n");
-//        for (i = 0; i < (int) pMergedInfo.size(); i++) {
-//          printf(" %d: (%d) '%s'\n", i,
-//              pMergedInfo.itemAt(i).getFileType(),
-//              ( final char*)pMergedInfo.itemAt(i).getFileName());
-//        }
-//  #endif
+      //  #if 0
+      //        printf("FILE LIST:\n");
+      //        for (i = 0; i < (int) pMergedInfo.size(); i++) {
+      //          printf(" %d: (%d) '%s'\n", i,
+      //              pMergedInfo.itemAt(i).getFileType(),
+      //              ( final char*)pMergedInfo.itemAt(i).getFileName());
+      //        }
+      //  #endif
 
       pDir.setFileList(pMergedInfo.get());
       return pDir;
@@ -1054,55 +1060,55 @@ public class CppAssetManager {
   }
 
   //
-//  /*
-//   * Open a directory in the non-asset namespace.
-//   *
-//   * An "asset directory" is simply the combination of all asset paths' "assets/" directories.
-//   *
-//   * Pass in "" for the root dir.
-//   */
-//  AssetDir* openNonAssetDir(final int cookie, final char* dirName)
-//  {
-//      AutoMutex _l(mLock);
-//  
-//      AssetDir* pDir = null;
-//      SortedVector<AssetDir.FileInfo>* pMergedInfo = null;
-//  
-//      LOG_FATAL_IF(mAssetPaths.isEmpty(), "No assets added to AssetManager");
-//      assert(dirName != null);
-//  
-//      //printf("+++ openDir(%s) in '%s'\n", dirName, (final char*) mAssetBase);
-//  
-//      pDir = new AssetDir;
-//  
-//      pMergedInfo = new SortedVector<AssetDir.FileInfo>;
-//  
-//      final int which = static_cast<int>(cookie) - 1;
-//  
-//      if (which < mAssetPaths.size()) {
-//          final asset_path& ap = mAssetPaths.itemAt(which);
-//          if (ap.type == kFileTypeRegular) {
-//              ALOGV("Adding directory %s from zip %s", dirName, ap.path.string());
-//              scanAndMergeZipLocked(pMergedInfo, ap, null, dirName);
-//          } else {
-//              ALOGV("Adding directory %s from dir %s", dirName, ap.path.string());
-//              scanAndMergeDirLocked(pMergedInfo, ap, null, dirName);
-//          }
-//      }
-//  
-//  #if 0
-//      printf("FILE LIST:\n");
-//      for (i = 0; i < (int) pMergedInfo.size(); i++) {
-//          printf(" %d: (%d) '%s'\n", i,
-//              pMergedInfo.itemAt(i).getFileType(),
-//              (final char*) pMergedInfo.itemAt(i).getFileName());
-//      }
-//  #endif
-//  
-//      pDir.setFileList(pMergedInfo);
-//      return pDir;
-//  }
-//  
+  //  /*
+  //   * Open a directory in the non-asset namespace.
+  //   *
+  //   * An "asset directory" is simply the combination of all asset paths' "assets/" directories.
+  //   *
+  //   * Pass in "" for the root dir.
+  //   */
+  //  AssetDir* openNonAssetDir(final int cookie, final char* dirName)
+  //  {
+  //      AutoMutex _l(mLock);
+  //
+  //      AssetDir* pDir = null;
+  //      SortedVector<AssetDir.FileInfo>* pMergedInfo = null;
+  //
+  //      LOG_FATAL_IF(mAssetPaths.isEmpty(), "No assets added to AssetManager");
+  //      assert(dirName != null);
+  //
+  //      //printf("+++ openDir(%s) in '%s'\n", dirName, (final char*) mAssetBase);
+  //
+  //      pDir = new AssetDir;
+  //
+  //      pMergedInfo = new SortedVector<AssetDir.FileInfo>;
+  //
+  //      final int which = static_cast<int>(cookie) - 1;
+  //
+  //      if (which < mAssetPaths.size()) {
+  //          final asset_path& ap = mAssetPaths.itemAt(which);
+  //          if (ap.type == kFileTypeRegular) {
+  //              ALOGV("Adding directory %s from zip %s", dirName, ap.path.string());
+  //              scanAndMergeZipLocked(pMergedInfo, ap, null, dirName);
+  //          } else {
+  //              ALOGV("Adding directory %s from dir %s", dirName, ap.path.string());
+  //              scanAndMergeDirLocked(pMergedInfo, ap, null, dirName);
+  //          }
+  //      }
+  //
+  //  #if 0
+  //      printf("FILE LIST:\n");
+  //      for (i = 0; i < (int) pMergedInfo.size(); i++) {
+  //          printf(" %d: (%d) '%s'\n", i,
+  //              pMergedInfo.itemAt(i).getFileType(),
+  //              (final char*) pMergedInfo.itemAt(i).getFileName());
+  //      }
+  //  #endif
+  //
+  //      pDir.setFileList(pMergedInfo);
+  //      return pDir;
+  //  }
+  //
   /*
    * Scan the contents of the specified directory and merge them into the
    * "pMergedInfo" vector, removing previous entries if we find "exclude"
@@ -1110,12 +1116,15 @@ public class CppAssetManager {
    *
    * Returns "false" if we found nothing to contribute.
    */
-  boolean scanAndMergeDirLocked(Ref<SortedVector<AssetDir.FileInfo>> pMergedInfoRef,
-      final asset_path ap, final String rootDir, final String dirName) {
+  boolean scanAndMergeDirLocked(
+      Ref<SortedVector<AssetDir.FileInfo>> pMergedInfoRef,
+      final asset_path ap,
+      final String rootDir,
+      final String dirName) {
     SortedVector<AssetDir.FileInfo> pMergedInfo = pMergedInfoRef.get();
     assert (pMergedInfo != null);
 
-    //printf("scanAndMergeDir: %s %s %s\n", ap.path.string(), rootDir, dirName);
+    // printf("scanAndMergeDir: %s %s %s\n", ap.path.string(), rootDir, dirName);
 
     String8 path = createPathNameLocked(ap, rootDir);
     if (dirName.charAt(0) != '\0') {
@@ -1129,11 +1138,11 @@ public class CppAssetManager {
 
     // if we wanted to do an incremental cache fill, we would do it here
 
-      /*
-       * Process "exclude" directives.  If we find a filename that ends with
-       * ".EXCLUDE", we look for a matching entry in the "merged" set, and
-       * remove it if we find it.  We also delete the "exclude" entry.
-       */
+    /*
+     * Process "exclude" directives.  If we find a filename that ends with
+     * ".EXCLUDE", we look for a matching entry in the "merged" set, and
+     * remove it if we find it.  We also delete the "exclude" entry.
+     */
     int i, count, exclExtLen;
 
     count = pContents.size();
@@ -1150,18 +1159,19 @@ public class CppAssetManager {
 
         matchIdx = AssetDir.FileInfo.findEntry(pMergedInfo, match);
         if (matchIdx > 0) {
-          ALOGV("Excluding '%s' [%s]\n",
+          ALOGV(
+              "Excluding '%s' [%s]\n",
               pMergedInfo.itemAt(matchIdx).getFileName().string(),
               pMergedInfo.itemAt(matchIdx).getSourceName().string());
           pMergedInfo.removeAt(matchIdx);
         } else {
-          //printf("+++ no match on '%s'\n", (final char*) match);
+          // printf("+++ no match on '%s'\n", (final char*) match);
         }
 
         ALOGD("HEY: size=%d removing %d\n", (int) pContents.size(), i);
         pContents.removeAt(i);
-        i--;        // adjust "for" loop
-        count--;    //  and loop limit
+        i--; // adjust "for" loop
+        count--; //  and loop limit
       }
     }
 
@@ -1185,7 +1195,7 @@ public class CppAssetManager {
 
     String8 pathCopy = new String8(path);
     SortedVector<AssetDir.FileInfo> pContents;
-    //DIR* dir;
+    // DIR* dir;
     File dir;
     FileType fileType;
 
@@ -1203,21 +1213,21 @@ public class CppAssetManager {
         break;
       }
 
-//          if (strcmp(entry.d_name, ".") == 0 ||
-//              strcmp(entry.d_name, "..") == 0)
-//              continue;
-
-//  #ifdef _DIRENT_HAVE_D_TYPE
-//          if (entry.d_type == DT_REG)
-//              fileType = kFileTypeRegular;
-//          else if (entry.d_type == DT_DIR)
-//              fileType = kFileTypeDirectory;
-//          else
-//              fileType = kFileTypeUnknown;
-//  #else
+      //          if (strcmp(entry.d_name, ".") == 0 ||
+      //              strcmp(entry.d_name, "..") == 0)
+      //              continue;
+
+      //  #ifdef _DIRENT_HAVE_D_TYPE
+      //          if (entry.d_type == DT_REG)
+      //              fileType = kFileTypeRegular;
+      //          else if (entry.d_type == DT_DIR)
+      //              fileType = kFileTypeDirectory;
+      //          else
+      //              fileType = kFileTypeUnknown;
+      //  #else
       // stat the file
       fileType = getFileType(pathCopy.appendPath(entry.getName()).string());
-//  #endif
+      //  #endif
 
       if (fileType != FileType.kFileTypeRegular && fileType != kFileTypeDirectory) {
         continue;
@@ -1242,11 +1252,14 @@ public class CppAssetManager {
    *
    * Returns "false" if we found nothing to contribute.
    */
-  boolean scanAndMergeZipLocked(Ref<SortedVector<AssetDir.FileInfo>> pMergedInfo,
-      final asset_path ap, final String rootDir, final String baseDirName) {
+  boolean scanAndMergeZipLocked(
+      Ref<SortedVector<AssetDir.FileInfo>> pMergedInfo,
+      final asset_path ap,
+      final String rootDir,
+      final String baseDirName) {
     ZipFileRO pZip;
     List<String8> dirs = new ArrayList<>();
-    //AssetDir.FileInfo info = new FileInfo();
+    // AssetDir.FileInfo info = new FileInfo();
     SortedVector<AssetDir.FileInfo> contents = new SortedVector<>();
     String8 zipName;
     String8 dirName = new String8();
@@ -1259,7 +1272,7 @@ public class CppAssetManager {
 
     zipName = ZipSet.getPathName(ap.path.string());
 
-      /* convert "sounds" to "rootDir/sounds" */
+    /* convert "sounds" to "rootDir/sounds" */
     if (rootDir != null) {
       dirName = new String8(rootDir);
     }
@@ -1300,7 +1313,7 @@ public class CppAssetManager {
         continue;
       }
 
-//      System.out.printf("Comparing %s in %s?\n", nameBuf.get(), dirName.string());
+      //      System.out.printf("Comparing %s in %s?\n", nameBuf.get(), dirName.string());
       if (!nameBuf.get().startsWith(dirName.string() + '/')) {
         // not matching
         continue;
@@ -1309,14 +1322,14 @@ public class CppAssetManager {
         int cp = 0;
         int nextSlashIndex;
 
-        //cp = nameBuf + dirNameLen;
+        // cp = nameBuf + dirNameLen;
         cp += dirNameLen;
         if (dirNameLen != 0) {
-          cp++;       // advance past the '/'
+          cp++; // advance past the '/'
         }
 
         nextSlashIndex = nameBuf.get().indexOf('/', cp);
-        //xxx this may break if there are bare directory entries
+        // xxx this may break if there are bare directory entries
         if (nextSlashIndex == -1) {
           /* this is a file in the requested directory */
           String8 fileName = new String8(nameBuf.get()).getPathLeaf();
@@ -1327,11 +1340,10 @@ public class CppAssetManager {
           AssetDir.FileInfo info = new FileInfo();
           info.set(fileName, FileType.kFileTypeRegular);
 
-          info.setSourceName(
-              createZipSourceNameLocked(zipName, dirName, info.getFileName()));
+          info.setSourceName(createZipSourceNameLocked(zipName, dirName, info.getFileName()));
 
           contents.add(info);
-          //printf("FOUND: file '%s'\n", info.getFileName().string());
+          // printf("FOUND: file '%s'\n", info.getFileName().string());
         } else {
           /* this is a subdir; add it if we don't already have it*/
           String8 subdirName = new String8(nameBuf.get().substring(cp, nextSlashIndex));
@@ -1347,31 +1359,28 @@ public class CppAssetManager {
             dirs.add(subdirName);
           }
 
-          //printf("FOUND: dir '%s'\n", subdirName.string());
+          // printf("FOUND: dir '%s'\n", subdirName.string());
         }
       }
     }
 
     pZip.endIteration(iterationCookie);
 
-      /*
-       * Add the set of unique directories.
-       */
+    /*
+     * Add the set of unique directories.
+     */
     for (int i = 0; i < dirs.size(); i++) {
       AssetDir.FileInfo info = new FileInfo();
       info.set(dirs.get(i), kFileTypeDirectory);
-      info.setSourceName(
-          createZipSourceNameLocked(zipName, dirName, info.getFileName()));
+      info.setSourceName(createZipSourceNameLocked(zipName, dirName, info.getFileName()));
       contents.add(info);
     }
 
     mergeInfoLocked(pMergedInfo, contents);
 
     return true;
-
   }
 
-
   /*
    * Merge two vectors of FileInfo.
    *
@@ -1380,28 +1389,29 @@ public class CppAssetManager {
    * If an entry for a file exists in both "pMergedInfo" and "pContents",
    * we use the newer "pContents" entry.
    */
-  void mergeInfoLocked(Ref<SortedVector<AssetDir.FileInfo>> pMergedInfoRef,
+  void mergeInfoLocked(
+      Ref<SortedVector<AssetDir.FileInfo>> pMergedInfoRef,
       final SortedVector<AssetDir.FileInfo> pContents) {
-      /*
-       * Merge what we found in this directory with what we found in
-       * other places.
-       *
-       * Two basic approaches:
-       * (1) Create a new array that holds the unique values of the two
-       *     arrays.
-       * (2) Take the elements from pContents and shove them into pMergedInfo.
-       *
-       * Because these are vectors of complex objects, moving elements around
-       * inside the vector requires finalructing new objects and allocating
-       * storage for members.  With approach #1, we're always adding to the
-       * end, whereas with #2 we could be inserting multiple elements at the
-       * front of the vector.  Approach #1 requires a full copy of the
-       * contents of pMergedInfo, but approach #2 requires the same copy for
-       * every insertion at the front of pMergedInfo.
-       *
-       * (We should probably use a SortedVector interface that allows us to
-       * just stuff items in, trusting us to maintain the sort order.)
-       */
+    /*
+     * Merge what we found in this directory with what we found in
+     * other places.
+     *
+     * Two basic approaches:
+     * (1) Create a new array that holds the unique values of the two
+     *     arrays.
+     * (2) Take the elements from pContents and shove them into pMergedInfo.
+     *
+     * Because these are vectors of complex objects, moving elements around
+     * inside the vector requires finalructing new objects and allocating
+     * storage for members.  With approach #1, we're always adding to the
+     * end, whereas with #2 we could be inserting multiple elements at the
+     * front of the vector.  Approach #1 requires a full copy of the
+     * contents of pMergedInfo, but approach #2 requires the same copy for
+     * every insertion at the front of pMergedInfo.
+     *
+     * (We should probably use a SortedVector interface that allows us to
+     * just stuff items in, trusting us to maintain the sort order.)
+     */
     SortedVector<AssetDir.FileInfo> pNewSorted;
     int mergeMax, contMax;
     int mergeIdx, contIdx;
@@ -1414,20 +1424,20 @@ public class CppAssetManager {
 
     while (mergeIdx < mergeMax || contIdx < contMax) {
       if (mergeIdx == mergeMax) {
-              /* hit end of "merge" list, copy rest of "contents" */
+        /* hit end of "merge" list, copy rest of "contents" */
         pNewSorted.add(pContents.itemAt(contIdx));
         contIdx++;
       } else if (contIdx == contMax) {
-              /* hit end of "cont" list, copy rest of "merge" */
+        /* hit end of "cont" list, copy rest of "merge" */
         pNewSorted.add(pMergedInfo.itemAt(mergeIdx));
         mergeIdx++;
       } else if (pMergedInfo.itemAt(mergeIdx) == pContents.itemAt(contIdx)) {
-              /* items are identical, add newer and advance both indices */
+        /* items are identical, add newer and advance both indices */
         pNewSorted.add(pContents.itemAt(contIdx));
         mergeIdx++;
         contIdx++;
       } else if (pMergedInfo.itemAt(mergeIdx).isLessThan(pContents.itemAt(contIdx))) {
-              /* "merge" is lower, add that one */
+        /* "merge" is lower, add that one */
         pNewSorted.add(pMergedInfo.itemAt(mergeIdx));
         mergeIdx++;
       } else {
@@ -1438,31 +1448,31 @@ public class CppAssetManager {
       }
     }
 
-      /*
-       * Overwrite the "merged" list with the new stuff.
-       */
+    /*
+     * Overwrite the "merged" list with the new stuff.
+     */
     pMergedInfoRef.set(pNewSorted);
 
-//  #if 0       // for Vector, rather than SortedVector
-//      int i, j;
-//      for (i = pContents.size() -1; i >= 0; i--) {
-//          boolean add = true;
-//
-//          for (j = pMergedInfo.size() -1; j >= 0; j--) {
-//              /* case-sensitive comparisons, to behave like UNIX fs */
-//              if (strcmp(pContents.itemAt(i).mFileName,
-//                         pMergedInfo.itemAt(j).mFileName) == 0)
-//              {
-//                  /* match, don't add this entry */
-//                  add = false;
-//                  break;
-//              }
-//          }
-//
-//          if (add)
-//              pMergedInfo.add(pContents.itemAt(i));
-//      }
-//  #endif
+    //  #if 0       // for Vector, rather than SortedVector
+    //      int i, j;
+    //      for (i = pContents.size() -1; i >= 0; i--) {
+    //          boolean add = true;
+    //
+    //          for (j = pMergedInfo.size() -1; j >= 0; j--) {
+    //              /* case-sensitive comparisons, to behave like UNIX fs */
+    //              if (strcmp(pContents.itemAt(i).mFileName,
+    //                         pMergedInfo.itemAt(j).mFileName) == 0)
+    //              {
+    //                  /* match, don't add this entry */
+    //                  add = false;
+    //                  break;
+    //              }
+    //          }
+    //
+    //          if (add)
+    //              pMergedInfo.add(pContents.itemAt(i));
+    //      }
+    //  #endif
   }
 
   /*
@@ -1482,8 +1492,8 @@ public class CppAssetManager {
 
     List<asset_path> mOverlays;
 
-    final static Object gLock = new Object();
-    final static Map<String8, WeakReference<SharedZip>> gOpen = new HashMap<>();
+    static final Object gLock = new Object();
+    static final Map<String8, WeakReference<SharedZip>> gOpen = new HashMap<>();
 
     public SharedZip(String path, long modWhen) {
       this.mPath = path;
@@ -1519,9 +1529,7 @@ public class CppAssetManager {
         zip = new SharedZip(path.string(), modWhen);
         gOpen.put(path, new WeakReference<>(zip));
         return zip;
-
       }
-
     }
 
     ZipFileRO getZip() {
@@ -1563,42 +1571,42 @@ public class CppAssetManager {
       return mResourceTable;
     }
 
-//  boolean SharedZip.isUpToDate()
-//  {
-//      time_t modWhen = getFileModDate(mPath.string());
-//      return mModWhen == modWhen;
-//  }
-//
-//  void SharedZip.addOverlay(final asset_path& ap)
-//  {
-//      mOverlays.add(ap);
-//  }
-//
-//  boolean SharedZip.getOverlay(int idx, asset_path* out) final
-//  {
-//      if (idx >= mOverlays.size()) {
-//          return false;
-//      }
-//      *out = mOverlays[idx];
-//      return true;
-//  }
-//
-//  SharedZip.~SharedZip()
-//  {
-//      if (kIsDebug) {
-//          ALOGI("Destroying SharedZip %s %s\n", this, (final char*)mPath);
-//      }
-//      if (mResourceTable != null) {
-//          delete mResourceTable;
-//      }
-//      if (mResourceTableAsset != null) {
-//          delete mResourceTableAsset;
-//      }
-//      if (mZipFile != null) {
-//          delete mZipFile;
-//          ALOGV("Closed '%s'\n", mPath.string());
-//      }
-//  }
+    //  boolean SharedZip.isUpToDate()
+    //  {
+    //      time_t modWhen = getFileModDate(mPath.string());
+    //      return mModWhen == modWhen;
+    //  }
+    //
+    //  void SharedZip.addOverlay(final asset_path& ap)
+    //  {
+    //      mOverlays.add(ap);
+    //  }
+    //
+    //  boolean SharedZip.getOverlay(int idx, asset_path* out) final
+    //  {
+    //      if (idx >= mOverlays.size()) {
+    //          return false;
+    //      }
+    //      *out = mOverlays[idx];
+    //      return true;
+    //  }
+    //
+    //  SharedZip.~SharedZip()
+    //  {
+    //      if (kIsDebug) {
+    //          ALOGI("Destroying SharedZip %s %s\n", this, (final char*)mPath);
+    //      }
+    //      if (mResourceTable != null) {
+    //          delete mResourceTable;
+    //      }
+    //      if (mResourceTableAsset != null) {
+    //          delete mResourceTableAsset;
+    //      }
+    //      if (mZipFile != null) {
+    //          delete mZipFile;
+    //          ALOGV("Closed '%s'\n", mPath.string());
+    //      }
+    //  }
 
     @Override
     public String toString() {
@@ -1607,29 +1615,28 @@ public class CppAssetManager {
     }
   }
 
-
   /*
- * Manage a set of Zip files.  For each file we need a pointer to the
- * ZipFile and a time_t with the file's modification date.
- *
- * We currently only have two zip files (current app, "common" app).
- * (This was originally written for 8, based on app/locale/vendor.)
- */
+   * Manage a set of Zip files.  For each file we need a pointer to the
+   * ZipFile and a time_t with the file's modification date.
+   *
+   * We currently only have two zip files (current app, "common" app).
+   * (This was originally written for 8, based on app/locale/vendor.)
+   */
   static class ZipSet {
 
     final List<String> mZipPath = new ArrayList<>();
     final List<SharedZip> mZipFile = new ArrayList<>();
 
-  /*
-   * ===========================================================================
-   *      ZipSet
-   * ===========================================================================
-   */
+    /*
+     * ===========================================================================
+     *      ZipSet
+     * ===========================================================================
+     */
 
     /*
      * Destructor.  Close any open archives.
      */
-//  ZipSet.~ZipSet(void)
+    //  ZipSet.~ZipSet(void)
     @Override
     protected void finalize() {
       int N = mZipFile.size();
@@ -1645,7 +1652,6 @@ public class CppAssetManager {
       mZipFile.set(idx, null);
     }
 
-
     /*
      * Retrieve the appropriate Zip file from the set.
      */
@@ -1704,39 +1710,39 @@ public class CppAssetManager {
     }
 
     //
-//  boolean ZipSet.isUpToDate()
-//  {
-//      final int N = mZipFile.size();
-//      for (int i=0; i<N; i++) {
-//          if (mZipFile[i] != null && !mZipFile[i].isUpToDate()) {
-//              return false;
-//          }
-//      }
-//      return true;
-//  }
-//
-//  void ZipSet.addOverlay(final String8& path, final asset_path& overlay)
-//  {
-//      int idx = getIndex(path);
-//      sp<SharedZip> zip = mZipFile[idx];
-//      zip.addOverlay(overlay);
-//  }
-//
-//  boolean ZipSet.getOverlay(final String8& path, int idx, asset_path* out) final
-//  {
-//      sp<SharedZip> zip = SharedZip.get(path, false);
-//      if (zip == null) {
-//          return false;
-//      }
-//      return zip.getOverlay(idx, out);
-//  }
-//
-  /*
-   * Compute the zip file's index.
-   *
-   * "appName", "locale", and "vendor" should be set to null to indicate the
-   * default directory.
-   */
+    //  boolean ZipSet.isUpToDate()
+    //  {
+    //      final int N = mZipFile.size();
+    //      for (int i=0; i<N; i++) {
+    //          if (mZipFile[i] != null && !mZipFile[i].isUpToDate()) {
+    //              return false;
+    //          }
+    //      }
+    //      return true;
+    //  }
+    //
+    //  void ZipSet.addOverlay(final String8& path, final asset_path& overlay)
+    //  {
+    //      int idx = getIndex(path);
+    //      sp<SharedZip> zip = mZipFile[idx];
+    //      zip.addOverlay(overlay);
+    //  }
+    //
+    //  boolean ZipSet.getOverlay(final String8& path, int idx, asset_path* out) final
+    //  {
+    //      sp<SharedZip> zip = SharedZip.get(path, false);
+    //      if (zip == null) {
+    //          return false;
+    //      }
+    //      return zip.getOverlay(idx, out);
+    //  }
+    //
+    /*
+     * Compute the zip file's index.
+     *
+     * "appName", "locale", and "vendor" should be set to null to indicate the
+     * default directory.
+     */
     int getIndex(final String zip) {
       final int N = mZipPath.size();
       for (int i = 0; i < N; i++) {
@@ -1750,7 +1756,6 @@ public class CppAssetManager {
 
       return mZipPath.size() - 1;
     }
-
   }
 
   private static long getFileModDate(String path) {
diff --git a/resources/src/main/java/org/robolectric/res/android/CppAssetManager2.java b/resources/src/main/java/org/robolectric/res/android/CppAssetManager2.java
index 92280825e..e48d5b90e 100644
--- a/resources/src/main/java/org/robolectric/res/android/CppAssetManager2.java
+++ b/resources/src/main/java/org/robolectric/res/android/CppAssetManager2.java
@@ -41,33 +41,35 @@ import org.robolectric.res.android.ResourceTypes.ResTable_type;
 import org.robolectric.res.android.ResourceTypes.Res_value;
 import org.robolectric.util.PerfStatsCollector;
 
-// transliterated from https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/include/androidfw/AssetManager2.h
-// and https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/AssetManager2.cpp
+// transliterated from
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/include/androidfw/AssetManager2.h
+// and
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/AssetManager2.cpp
 @SuppressWarnings("NewApi")
 public class CppAssetManager2 {
-//  #define ATRACE_TAG ATRACE_TAG_RESOURCES
-//  
-//  #include "androidfw/AssetManager2.h"
-
-//#include <array>
-//#include <limits>
-//#include <set>
-//#include <unordered_map>
-//
-//#include "androidfw/ApkAssets.h"
-//#include "androidfw/Asset.h"
-//#include "androidfw/AssetManager.h"
-//#include "androidfw/ResourceTypes.h"
-//#include "androidfw/Util.h"
-//
-//namespace android {
-//
-//class Theme;
-//
-//using ApkAssetsCookie = int32_t;
-//
-//enum : ApkAssetsCookie {
-  //};
+  //  #define ATRACE_TAG ATRACE_TAG_RESOURCES
+  //
+  //  #include "androidfw/AssetManager2.h"
+
+  // #include <array>
+  // #include <limits>
+  // #include <set>
+  // #include <unordered_map>
+  //
+  // #include "androidfw/ApkAssets.h"
+  // #include "androidfw/Asset.h"
+  // #include "androidfw/AssetManager.h"
+  // #include "androidfw/ResourceTypes.h"
+  // #include "androidfw/Util.h"
+  //
+  // namespace android {
+  //
+  // class Theme;
+  //
+  // using ApkAssetsCookie = int32_t;
+  //
+  // enum : ApkAssetsCookie {
+  // };
 
   // Holds a bag that has been merged with its parent, if one exists.
   public static class ResolvedBag {
@@ -99,12 +101,10 @@ public class CppAssetManager2 {
 
       @Override
       public String toString() {
-        return "Entry{" +
-            "key=" + key +
-            ", value=" + value +
-            '}';
+        return "Entry{" + "key=" + key + ", value=" + value + '}';
       }
-    };
+    }
+    ;
 
     // Denotes the configuration axis that this bag varies with.
     // If a configuration changes with respect to one of these axis,
@@ -117,12 +117,13 @@ public class CppAssetManager2 {
     // The array of entries for this bag. An empty array is a neat trick to force alignment
     // of the Entry structs that follow this structure and avoids a bunch of casts.
     public Entry[] entries;
-  };
+  }
+  ;
 
   // AssetManager2 is the main entry point for accessing assets and resources.
   // AssetManager2 provides caching of resources retrieved via the underlying ApkAssets.
-//  class AssetManager2 : public .AAssetManager {
-//   public:
+  //  class AssetManager2 : public .AAssetManager {
+  //   public:
   public static class ResourceName {
     public String package_ = null;
     // int package_len = 0;
@@ -134,18 +135,21 @@ public class CppAssetManager2 {
     public String entry = null;
     // public String entry16 = null;
     // int entry_len = 0;
-  };
-
-  public CppAssetManager2() {
   }
+  ;
 
+  public CppAssetManager2() {}
 
-  public final List<CppApkAssets> GetApkAssets() { return apk_assets_; }
+  public final List<CppApkAssets> GetApkAssets() {
+    return apk_assets_;
+  }
 
-  final ResTable_config GetConfiguration() { return configuration_; }
+  final ResTable_config GetConfiguration() {
+    return configuration_;
+  }
 
-// private:
-//  DISALLOW_COPY_AND_ASSIGN(AssetManager2);
+  // private:
+  //  DISALLOW_COPY_AND_ASSIGN(AssetManager2);
 
   // The ordered list of ApkAssets to search. These are not owned by the AssetManager, and must
   // have a longer lifetime.
@@ -191,12 +195,12 @@ public class CppAssetManager2 {
   // These are ordered according to apk_assets_. The mappings may change depending on what is
   // in apk_assets_, therefore they must be stored in the AssetManager and not in the
   // immutable ApkAssets class.
-  final private List<PackageGroup> package_groups_ = new ArrayList<>();
+  private final List<PackageGroup> package_groups_ = new ArrayList<>();
 
   // An array mapping package ID to index into package_groups. This keeps the lookup fast
   // without taking too much memory.
-//  private std.array<byte, std.numeric_limits<byte>.max() + 1> package_ids_;
-  final private byte[] package_ids_ = new byte[256];
+  //  private std.array<byte, std.numeric_limits<byte>.max() + 1> package_ids_;
+  private final byte[] package_ids_ = new byte[256];
 
   // The current configuration set for this AssetManager. When this changes, cached resources
   // may need to be purged.
@@ -204,8 +208,9 @@ public class CppAssetManager2 {
 
   // Cached set of bags. These are cached because they can inherit keys from parent bags,
   // which involves some calculation.
-//  private std.unordered_map<int, util.unique_cptr<ResolvedBag>> cached_bags_;
-  final private Map<Integer, ResolvedBag> cached_bags_ = new HashMap<>();
+  //  private std.unordered_map<int, util.unique_cptr<ResolvedBag>> cached_bags_;
+  private final Map<Integer, ResolvedBag> cached_bags_ = new HashMap<>();
+
   //  };
 
   // final ResolvedBag.Entry* begin(final ResolvedBag* bag) { return bag.entries; }
@@ -260,7 +265,7 @@ public class CppAssetManager2 {
     StringPoolRef entry_string_ref;
   }
 
-//  AssetManager2() { memset(&configuration_, 0, sizeof(configuration_)); }
+  //  AssetManager2() { memset(&configuration_, 0, sizeof(configuration_)); }
 
   // Sets/resets the underlying ApkAssets for this AssetManager. The ApkAssets
   // are not owned by the AssetManager, and must have a longer lifetime.
@@ -268,13 +273,13 @@ public class CppAssetManager2 {
   // Only pass invalidate_caches=false when it is known that the structure
   // change in ApkAssets is due to a safe addition of resources with completely
   // new resource IDs.
-//  boolean SetApkAssets(final List<ApkAssets> apk_assets, boolean invalidate_caches = true);
+  //  boolean SetApkAssets(final List<ApkAssets> apk_assets, boolean invalidate_caches = true);
   public boolean SetApkAssets(final List<CppApkAssets> apk_assets, boolean invalidate_caches) {
     apk_assets_ = apk_assets;
     BuildDynamicRefTable();
     RebuildFilterList();
     if (invalidate_caches) {
-//      InvalidateCaches(static_cast<int>(-1));
+      //      InvalidateCaches(static_cast<int>(-1));
       InvalidateCaches(-1);
     }
     return true;
@@ -282,10 +287,10 @@ public class CppAssetManager2 {
 
   // Assigns package IDs to all shared library ApkAssets.
   // Should be called whenever the ApkAssets are changed.
-//  void BuildDynamicRefTable();
+  //  void BuildDynamicRefTable();
   void BuildDynamicRefTable() {
     package_groups_.clear();
-//    package_ids_.fill(0xff);
+    //    package_ids_.fill(0xff);
     for (int i = 0; i < package_ids_.length; i++) {
       package_ids_[i] = (byte) 0xff;
     }
@@ -295,9 +300,8 @@ public class CppAssetManager2 {
     final int apk_assets_count = apk_assets_.size();
     for (int i = 0; i < apk_assets_count; i++) {
       final LoadedArsc loaded_arsc = apk_assets_.get(i).GetLoadedArsc();
-//      for (final std.unique_ptr<final LoadedPackage>& package_ :
-      for (final LoadedPackage package_ :
-          loaded_arsc.GetPackages()) {
+      //      for (final std.unique_ptr<final LoadedPackage>& package_ :
+      for (final LoadedPackage package_ : loaded_arsc.GetPackages()) {
         // Get the package ID or assign one if a shared library.
         int package_id;
         if (package_.IsDynamic()) {
@@ -314,8 +318,9 @@ public class CppAssetManager2 {
           // DynamicRefTable& ref_table = package_groups_.back().dynamic_ref_table;
           // ref_table.mAssignedPackageId = package_id;
           // ref_table.mAppAsLib = package->IsDynamic() && package->GetPackageId() == 0x7f;
-          DynamicRefTable ref_table = new DynamicRefTable((byte) package_id,
-              package_.IsDynamic() && package_.GetPackageId() == 0x7f);
+          DynamicRefTable ref_table =
+              new DynamicRefTable(
+                  (byte) package_id, package_.IsDynamic() && package_.GetPackageId() == 0x7f);
           PackageGroup newPackageGroup = new PackageGroup();
           newPackageGroup.dynamic_ref_table = ref_table;
 
@@ -332,8 +337,7 @@ public class CppAssetManager2 {
         // Add the package name . build time ID mappings.
         for (final DynamicPackageEntry entry : package_.GetDynamicPackageMap()) {
           // String package_name(entry.package_name.c_str(), entry.package_name.size());
-          package_group.dynamic_ref_table.mEntries.put(
-              entry.package_name, (byte) entry.package_id);
+          package_group.dynamic_ref_table.mEntries.put(entry.package_name, (byte) entry.package_id);
         }
       }
     }
@@ -342,8 +346,7 @@ public class CppAssetManager2 {
     for (PackageGroup iter : package_groups_) {
       String package_name = iter.packages_.get(0).loaded_package_.GetPackageName();
       for (PackageGroup iter2 : package_groups_) {
-        iter2.dynamic_ref_table.addMapping(package_name,
-            iter.dynamic_ref_table.mAssignedPackageId);
+        iter2.dynamic_ref_table.addMapping(package_name, iter.dynamic_ref_table.mAssignedPackageId);
 
         // Add the alias resources to the dynamic reference table of every package group. Since
         // staging aliases can only be defined by the framework package (which is not a shared
@@ -359,42 +362,42 @@ public class CppAssetManager2 {
     }
   }
 
-// void AssetManager2::DumpToLog() const {
-//   base::ScopedLogSeverity _log(base::INFO);
-//
-//   LOG(INFO) << base::StringPrintf("AssetManager2(this=%p)", this);
-//
-//   std::string list;
-//   for (const auto& apk_assets : apk_assets_) {
-//     base::StringAppendF(&list, "%s,", apk_assets->GetPath().c_str());
-//   }
-//   LOG(INFO) << "ApkAssets: " << list;
-//
-//   list = "";
-//   for (size_t i = 0; i < package_ids_.size(); i++) {
-//     if (package_ids_[i] != 0xff) {
-//       base::StringAppendF(&list, "%02x -> %d, ", (int)i, package_ids_[i]);
-//     }
-//   }
-//   LOG(INFO) << "Package ID map: " << list;
-//
-//   for (const auto& package_group: package_groups_) {
-//     list = "";
-//     for (const auto& package : package_group.packages_) {
-//       const LoadedPackage* loaded_package = package.loaded_package_;
-//       base::StringAppendF(&list, "%s(%02x%s), ", loaded_package->GetPackageName().c_str(),
-//                           loaded_package->GetPackageId(),
-//                           (loaded_package->IsDynamic() ? " dynamic" : ""));
-//     }
-//     LOG(INFO) << base::StringPrintf("PG (%02x): ",
-//                                     package_group.dynamic_ref_table.mAssignedPackageId)
-//               << list;
-//   }
-// }
+  // void AssetManager2::DumpToLog() const {
+  //   base::ScopedLogSeverity _log(base::INFO);
+  //
+  //   LOG(INFO) << base::StringPrintf("AssetManager2(this=%p)", this);
+  //
+  //   std::string list;
+  //   for (const auto& apk_assets : apk_assets_) {
+  //     base::StringAppendF(&list, "%s,", apk_assets->GetPath().c_str());
+  //   }
+  //   LOG(INFO) << "ApkAssets: " << list;
+  //
+  //   list = "";
+  //   for (size_t i = 0; i < package_ids_.size(); i++) {
+  //     if (package_ids_[i] != 0xff) {
+  //       base::StringAppendF(&list, "%02x -> %d, ", (int)i, package_ids_[i]);
+  //     }
+  //   }
+  //   LOG(INFO) << "Package ID map: " << list;
+  //
+  //   for (const auto& package_group: package_groups_) {
+  //     list = "";
+  //     for (const auto& package : package_group.packages_) {
+  //       const LoadedPackage* loaded_package = package.loaded_package_;
+  //       base::StringAppendF(&list, "%s(%02x%s), ", loaded_package->GetPackageName().c_str(),
+  //                           loaded_package->GetPackageId(),
+  //                           (loaded_package->IsDynamic() ? " dynamic" : ""));
+  //     }
+  //     LOG(INFO) << base::StringPrintf("PG (%02x): ",
+  //                                     package_group.dynamic_ref_table.mAssignedPackageId)
+  //               << list;
+  //   }
+  // }
 
   // Returns the string pool for the given asset cookie.
   // Use the string pool returned here with a valid Res_value object of type Res_value.TYPE_STRING.
-//  final ResStringPool GetStringPoolForCookie(ApkAssetsCookie cookie) const;
+  //  final ResStringPool GetStringPoolForCookie(ApkAssetsCookie cookie) const;
   final ResStringPool GetStringPoolForCookie(ApkAssetsCookie cookie) {
     if (cookie.intValue() < 0 || cookie.intValue() >= apk_assets_.size()) {
       return null;
@@ -404,7 +407,7 @@ public class CppAssetManager2 {
 
   // Returns the DynamicRefTable for the given package ID.
   // This may be nullptr if the APK represented by `cookie` has no resource table.
-//  final DynamicRefTable GetDynamicRefTableForPackage(int package_id) const;
+  //  final DynamicRefTable GetDynamicRefTableForPackage(int package_id) const;
   final DynamicRefTable GetDynamicRefTableForPackage(int package_id) {
     if (package_id >= package_ids_.length) {
       return null;
@@ -418,7 +421,7 @@ public class CppAssetManager2 {
   }
 
   // Returns the DynamicRefTable for the ApkAssets represented by the cookie.
-//  final DynamicRefTable GetDynamicRefTableForCookie(ApkAssetsCookie cookie) const;
+  //  final DynamicRefTable GetDynamicRefTableForCookie(ApkAssetsCookie cookie) const;
   public final DynamicRefTable GetDynamicRefTableForCookie(ApkAssetsCookie cookie) {
     for (final PackageGroup package_group : package_groups_) {
       for (final ApkAssetsCookie package_cookie : package_group.cookies_) {
@@ -432,14 +435,14 @@ public class CppAssetManager2 {
 
   // Sets/resets the configuration for this AssetManager. This will cause all
   // caches that are related to the configuration change to be invalidated.
-//  void SetConfiguration(final ResTable_config& configuration);
+  //  void SetConfiguration(final ResTable_config& configuration);
   public void SetConfiguration(final ResTable_config configuration) {
     final int diff = configuration_.diff(configuration);
     configuration_ = configuration;
 
     if (isTruthy(diff)) {
       RebuildFilterList();
-//      InvalidateCaches(static_cast<int>(diff));
+      //      InvalidateCaches(static_cast<int>(diff));
       InvalidateCaches(diff);
     }
   }
@@ -450,10 +453,10 @@ public class CppAssetManager2 {
   // ('android' package, other libraries) will be excluded from the list.
   // If `exclude_mipmap` is set to true, resource configurations defined for resource type 'mipmap'
   // will be excluded from the list.
-//  Set<ResTable_config> GetResourceConfigurations(boolean exclude_system = false,
-//                                                 boolean exclude_mipmap = false);
-  public Set<ResTable_config> GetResourceConfigurations(boolean exclude_system,
-      boolean exclude_mipmap) {
+  //  Set<ResTable_config> GetResourceConfigurations(boolean exclude_system = false,
+  //                                                 boolean exclude_mipmap = false);
+  public Set<ResTable_config> GetResourceConfigurations(
+      boolean exclude_system, boolean exclude_mipmap) {
     // ATRACE_NAME("AssetManager::GetResourceConfigurations");
     Set<ResTable_config> configurations = new HashSet<>();
     for (final PackageGroup package_group : package_groups_) {
@@ -473,10 +476,10 @@ public class CppAssetManager2 {
   // ('android' package, other libraries) will be excluded from the list.
   // If `merge_equivalent_languages` is set to true, resource locales will be canonicalized
   // and de-duped in the resulting list.
-//  Set<String> GetResourceLocales(boolean exclude_system = false,
-//                                 boolean merge_equivalent_languages = false);
-  public Set<String> GetResourceLocales(boolean exclude_system,
-      boolean merge_equivalent_languages) {
+  //  Set<String> GetResourceLocales(boolean exclude_system = false,
+  //                                 boolean merge_equivalent_languages = false);
+  public Set<String> GetResourceLocales(
+      boolean exclude_system, boolean merge_equivalent_languages) {
     ATRACE_CALL();
     Set<String> locales = new HashSet<>();
     for (final PackageGroup package_group : package_groups_) {
@@ -495,7 +498,7 @@ public class CppAssetManager2 {
   // `mode` controls how the file is opened.
   //
   // NOTE: The loaded APKs are searched in reverse order.
-//  Asset Open(final String filename, Asset.AccessMode mode);
+  //  Asset Open(final String filename, Asset.AccessMode mode);
   public Asset Open(final String filename, Asset.AccessMode mode) {
     final String new_path = "assets/" + filename;
     return OpenNonAsset(new_path, mode);
@@ -503,10 +506,9 @@ public class CppAssetManager2 {
 
   // Opens a file within the assets/ directory of the APK specified by `cookie`.
   // `mode` controls how the file is opened.
-//  Asset Open(final String filename, ApkAssetsCookie cookie,
-//             Asset.AccessMode mode);
-  Asset Open(final String filename, ApkAssetsCookie cookie,
-      Asset.AccessMode mode) {
+  //  Asset Open(final String filename, ApkAssetsCookie cookie,
+  //             Asset.AccessMode mode);
+  Asset Open(final String filename, ApkAssetsCookie cookie, Asset.AccessMode mode) {
     final String new_path = "assets/" + filename;
     return OpenNonAsset(new_path, cookie, mode);
   }
@@ -514,7 +516,7 @@ public class CppAssetManager2 {
   // Opens the directory specified by `dirname`. The result is an AssetDir that is the combination
   // of all directories matching `dirname` under the assets/ directory of every ApkAssets loaded.
   // The entries are sorted by their ASCII name.
-//  AssetDir OpenDir(final String dirname);
+  //  AssetDir OpenDir(final String dirname);
   public AssetDir OpenDir(final String dirname) {
     ATRACE_CALL();
 
@@ -526,13 +528,14 @@ public class CppAssetManager2 {
     // Start from the back.
     for (CppApkAssets apk_assets : apk_assets_) {
       // auto func = [&](final String& name, FileType type) {
-      ForEachFileCallback func = (final String name, FileType type) -> {
-        AssetDir.FileInfo info = new FileInfo();
-        info.setFileName(new String8(name));
-        info.setFileType(type);
-        info.setSourceName(new String8(apk_assets.GetPath()));
-        files.add(info);
-      };
+      ForEachFileCallback func =
+          (final String name, FileType type) -> {
+            AssetDir.FileInfo info = new FileInfo();
+            info.setFileName(new String8(name));
+            info.setFileType(type);
+            info.setSourceName(new String8(apk_assets.GetPath()));
+            files.add(info);
+          };
 
       if (!apk_assets.ForEachFile(full_path, func)) {
         return new AssetDir();
@@ -550,14 +553,13 @@ public class CppAssetManager2 {
   // `out_cookie` is populated with the cookie of the APK this file was found in.
   //
   // NOTE: The loaded APKs are searched in reverse order.
-//  Asset OpenNonAsset(final String filename, Asset.AccessMode mode,
-//                     ApkAssetsCookie* out_cookie = null);
+  //  Asset OpenNonAsset(final String filename, Asset.AccessMode mode,
+  //                     ApkAssetsCookie* out_cookie = null);
   // Search in reverse because that's how we used to do it and we need to preserve behaviour.
   // This is unfortunate, because ClassLoaders delegate to the parent first, so the order
   // is inconsistent for split APKs.
-  public Asset OpenNonAsset(final String filename,
-      Asset.AccessMode mode,
-      Ref<ApkAssetsCookie> out_cookie) {
+  public Asset OpenNonAsset(
+      final String filename, Asset.AccessMode mode, Ref<ApkAssetsCookie> out_cookie) {
     ATRACE_CALL();
     for (int i = apk_assets_.size() - 1; i >= 0; i--) {
       Asset asset = apk_assets_.get(i).Open(filename, mode);
@@ -582,10 +584,9 @@ public class CppAssetManager2 {
   // Opens a file in the APK specified by `cookie`. `mode` controls how the file is opened.
   // This is typically used to open a specific AndroidManifest.xml, or a binary XML file
   // referenced by a resource lookup with GetResource().
-//  Asset OpenNonAsset(final String filename, ApkAssetsCookie cookie,
-//                     Asset.AccessMode mode);
-  public Asset OpenNonAsset(final String filename,
-      ApkAssetsCookie cookie, Asset.AccessMode mode) {
+  //  Asset OpenNonAsset(final String filename, ApkAssetsCookie cookie,
+  //                     Asset.AccessMode mode);
+  public Asset OpenNonAsset(final String filename, ApkAssetsCookie cookie, Asset.AccessMode mode) {
     ATRACE_CALL();
     if (cookie.intValue() < 0 || cookie.intValue() >= apk_assets_.size()) {
       return null;
@@ -600,7 +601,8 @@ public class CppAssetManager2 {
 
   public void ForEachPackage(PackageFunc func) {
     for (PackageGroup package_group : package_groups_) {
-      func.apply(package_group.packages_.get(0).loaded_package_.GetPackageName(),
+      func.apply(
+          package_group.packages_.get(0).loaded_package_.GetPackageName(),
           package_group.dynamic_ref_table.mAssignedPackageId);
     }
   }
@@ -619,11 +621,11 @@ public class CppAssetManager2 {
   //
   // NOTE: FindEntry takes care of ensuring that structs within FindEntryResult have been properly
   // bounds-checked. Callers of FindEntry are free to trust the data if this method succeeds.
-//  ApkAssetsCookie FindEntry(int resid, short density_override, boolean stop_at_first_match,
-//                            LoadedArscEntry* out_entry, ResTable_config out_selected_config,
-//                            int* out_flags);
-  private ApkAssetsCookie FindEntry(int resid, short density_override,
-      final Ref<FindEntryResult> out_entry) {
+  //  ApkAssetsCookie FindEntry(int resid, short density_override, boolean stop_at_first_match,
+  //                            LoadedArscEntry* out_entry, ResTable_config out_selected_config,
+  //                            int* out_flags);
+  private ApkAssetsCookie FindEntry(
+      int resid, short density_override, final Ref<FindEntryResult> out_entry) {
     ATRACE_CALL();
 
     // Might use this if density_override != 0.
@@ -675,7 +677,8 @@ public class CppAssetManager2 {
       LoadedPackage loaded_package = loaded_package_impl.loaded_package_;
       ApkAssetsCookie cookie = package_group.cookies_.get(pi);
 
-      // If the type IDs are offset in this package, we need to take that into account when searching
+      // If the type IDs are offset in this package, we need to take that into account when
+      // searching
       // for a type.
       TypeSpec type_spec = loaded_package.GetTypeSpecByTypeIndex(type_idx);
       if (Util.UNLIKELY(type_spec == null)) {
@@ -686,8 +689,8 @@ public class CppAssetManager2 {
 
       // If there is an IDMAP supplied with this package, translate the entry ID.
       if (type_spec.idmap_entries != null) {
-        if (!LoadedIdmap
-            .Lookup(type_spec.idmap_entries, local_entry_idx, new Ref<>(local_entry_idx))) {
+        if (!LoadedIdmap.Lookup(
+            type_spec.idmap_entries, local_entry_idx, new Ref<>(local_entry_idx))) {
           // There is no mapping, so the resource is not meant to be in this overlay package.
           continue;
         }
@@ -707,8 +710,8 @@ public class CppAssetManager2 {
 
           // We can skip calling ResTable_config.match() because we know that all candidate
           // configurations that do NOT match have been filtered-out.
-          if ((best_config == null || this_config.isBetterThan(best_config, desired_config)) ||
-              (package_is_overlay && this_config.compare(best_config) == 0)) {
+          if ((best_config == null || this_config.isBetterThan(best_config, desired_config))
+              || (package_is_overlay && this_config.compare(best_config) == 0)) {
             // The configuration matches and is better than the previous selection.
             // Find the entry value if it exists for this configuration.
             ResTable_type type_chunk = filtered_group.types.get(i);
@@ -736,8 +739,8 @@ public class CppAssetManager2 {
           ResTable_config this_config = ResTable_config.fromDtoH(type.config);
 
           if (this_config.match(desired_config)) {
-            if ((best_config == null || this_config.isBetterThan(best_config, desired_config)) ||
-                (package_is_overlay && this_config.compare(best_config) == 0)) {
+            if ((best_config == null || this_config.isBetterThan(best_config, desired_config))
+                || (package_is_overlay && this_config.compare(best_config) == 0)) {
               // The configuration matches and is better than the previous selection.
               // Find the entry value if it exists for this configuration.
               int offset = LoadedPackage.GetEntryOffset(type, local_entry_idx);
@@ -770,7 +773,8 @@ public class CppAssetManager2 {
     out_entry_.entry = best_entry;
     out_entry_.config = best_config;
     out_entry_.type_flags = type_flags;
-    out_entry_.type_string_ref = new StringPoolRef(best_package.GetTypeStringPool(), best_type.id - 1);
+    out_entry_.type_string_ref =
+        new StringPoolRef(best_package.GetTypeStringPool(), best_type.id - 1);
     out_entry_.entry_string_ref =
         new StringPoolRef(best_package.GetKeyStringPool(), best_entry.getKeyIndex());
     out_entry_.dynamic_ref_table = package_group.dynamic_ref_table;
@@ -782,7 +786,7 @@ public class CppAssetManager2 {
   // Utf8 strings are preferred, and only if they are unavailable are
   // the Utf16 variants populated.
   // Returns false if the resource was not found or the name was missing/corrupt.
-//  boolean GetResourceName(int resid, ResourceName* out_name);
+  //  boolean GetResourceName(int resid, ResourceName* out_name);
   public boolean GetResourceName(int resid, ResourceName out_name) {
     final Ref<FindEntryResult> entryRef = new Ref<>(null);
     ApkAssetsCookie cookie = FindEntry(resid, (short) 0 /* density_override */, entryRef);
@@ -807,7 +811,7 @@ public class CppAssetManager2 {
       // out_name.type16 = entry.type_string_ref.string();
       // out_name.type_len = out_name.type16 == null ? 0 : out_name.type16.length();
       // if (out_name.type16 == null) {
-        return false;
+      return false;
       // }
     }
 
@@ -818,7 +822,7 @@ public class CppAssetManager2 {
       // out_name.entry16 = entry.entry_string_ref.string();
       // out_name.entry_len = out_name.entry16 == null ? 0 : out_name.entry16.length();
       // if (out_name.entry16 == null) {
-        return false;
+      return false;
       // }
     }
     return true;
@@ -827,7 +831,7 @@ public class CppAssetManager2 {
   // Populates `out_flags` with the bitmask of configuration axis that this resource varies with.
   // See ResTable_config for the list of configuration axis.
   // Returns false if the resource was not found.
-//  boolean GetResourceFlags(int resid, int* out_flags);
+  //  boolean GetResourceFlags(int resid, int* out_flags);
   boolean GetResourceFlags(int resid, Ref<Integer> out_flags) {
     final Ref<FindEntryResult> entry = new Ref<>(null);
     ApkAssetsCookie cookie = FindEntry(resid, (short) 0 /* density_override */, entry);
@@ -842,7 +846,6 @@ public class CppAssetManager2 {
     return cookie.intValue() != kInvalidCookie;
   }
 
-
   // Retrieves the best matching resource with ID `resid`. The resource value is filled into
   // `out_value` and the configuration for the selected value is populated in `out_selected_config`.
   // `out_flags` holds the same flags as retrieved with GetResourceFlags().
@@ -852,11 +855,14 @@ public class CppAssetManager2 {
   // Returns a valid cookie if the resource was found. If the resource was not found, or if the
   // resource was a map/bag type, then kInvalidCookie is returned. If `may_be_bag` is false,
   // this function logs if the resource was a map/bag type before returning kInvalidCookie.
-//  ApkAssetsCookie GetResource(int resid, boolean may_be_bag, short density_override,
-//                              Res_value out_value, ResTable_config out_selected_config,
-//                              int* out_flags);
-  public ApkAssetsCookie GetResource(int resid, boolean may_be_bag,
-      short density_override, Ref<Res_value> out_value,
+  //  ApkAssetsCookie GetResource(int resid, boolean may_be_bag, short density_override,
+  //                              Res_value out_value, ResTable_config out_selected_config,
+  //                              int* out_flags);
+  public ApkAssetsCookie GetResource(
+      int resid,
+      boolean may_be_bag,
+      short density_override,
+      Ref<Res_value> out_value,
       final Ref<ResTable_config> out_selected_config,
       final Ref<Integer> out_flags) {
     final Ref<FindEntryResult> entry = new Ref<>(null);
@@ -907,22 +913,32 @@ public class CppAssetManager2 {
   // value. This is only initialized if the passed in `in_out_value` is a reference.
   // Returns the cookie of the APK the resolved resource was defined in, or kInvalidCookie if
   // it was not found.
-//  ApkAssetsCookie ResolveReference(ApkAssetsCookie cookie, Res_value in_out_value,
-//                                   ResTable_config in_out_selected_config, int* in_out_flags,
-//                                   int* out_last_reference);
-  public ApkAssetsCookie ResolveReference(ApkAssetsCookie cookie, Ref<Res_value> in_out_value,
+  //  ApkAssetsCookie ResolveReference(ApkAssetsCookie cookie, Res_value in_out_value,
+  //                                   ResTable_config in_out_selected_config, int* in_out_flags,
+  //                                   int* out_last_reference);
+  public ApkAssetsCookie ResolveReference(
+      ApkAssetsCookie cookie,
+      Ref<Res_value> in_out_value,
       final Ref<ResTable_config> in_out_selected_config,
       final Ref<Integer> in_out_flags,
       final Ref<Integer> out_last_reference) {
     final int kMaxIterations = 20;
 
-    for (int iteration = 0; in_out_value.get().dataType == Res_value.TYPE_REFERENCE &&
-        in_out_value.get().data != 0 && iteration < kMaxIterations;
+    for (int iteration = 0;
+        in_out_value.get().dataType == Res_value.TYPE_REFERENCE
+            && in_out_value.get().data != 0
+            && iteration < kMaxIterations;
         iteration++) {
       out_last_reference.set(in_out_value.get().data);
       final Ref<Integer> new_flags = new Ref<>(0);
-      cookie = GetResource(in_out_value.get().data, true /*may_be_bag*/, (short) 0 /*density_override*/,
-          in_out_value, in_out_selected_config, new_flags);
+      cookie =
+          GetResource(
+              in_out_value.get().data,
+              true /*may_be_bag*/,
+              (short) 0 /*density_override*/,
+              in_out_value,
+              in_out_selected_config,
+              new_flags);
       if (cookie.intValue() == kInvalidCookie) {
         return K_INVALID_COOKIE;
       }
@@ -974,8 +990,8 @@ public class CppAssetManager2 {
     // Check that the size of the entry header is at least as big as
     // the desired ResTable_map_entry. Also verify that the entry
     // was intended to be a map.
-    if (dtohs(entry.entry.size) < ResTable_map_entry.BASE_SIZEOF ||
-        (dtohs(entry.entry.flags) & ResourceTypes.ResTable_entry.FLAG_COMPLEX) == 0) {
+    if (dtohs(entry.entry.size) < ResTable_map_entry.BASE_SIZEOF
+        || (dtohs(entry.entry.flags) & ResourceTypes.ResTable_entry.FLAG_COMPLEX) == 0) {
       // Not a bag, nothing to do.
       return null;
     }
@@ -984,11 +1000,11 @@ public class CppAssetManager2 {
     // final ResTable_map map_entry =
     //     reinterpret_cast<final ResTable_map*>(reinterpret_cast<final byte*>(map) + map.size);
     // final ResTable_map map_entry_end = map_entry + dtohl(map.count);
-    final ResTable_map_entry map = new ResTable_map_entry(entry.entry.myBuf(), entry.entry.myOffset());
+    final ResTable_map_entry map =
+        new ResTable_map_entry(entry.entry.myBuf(), entry.entry.myOffset());
     int curOffset = map.myOffset() + map.size;
     ResTable_map map_entry = null; // = new ResTable_map(map.myBuf(), curOffset);
-    final int map_entry_end =
-        curOffset + dtohl(map.count) * ResTable_map.SIZEOF;
+    final int map_entry_end = curOffset + dtohl(map.count) * ResTable_map.SIZEOF;
     if (curOffset < map_entry_end) {
       map_entry = new ResTable_map(map.myBuf(), curOffset);
     }
@@ -1040,9 +1056,8 @@ public class CppAssetManager2 {
         ++i;
 
         final int size = dtohs(map_entry.value.size);
-//      curOffset += size + sizeof(*map)-sizeof(map->value);
-        curOffset += size + ResTable_map.SIZEOF-Res_value.SIZEOF;
-
+        //      curOffset += size + sizeof(*map)-sizeof(map->value);
+        curOffset += size + ResTable_map.SIZEOF - Res_value.SIZEOF;
       }
       new_bag.type_spec_flags = entry.type_flags;
       new_bag.entry_count = entry_count;
@@ -1073,7 +1088,7 @@ public class CppAssetManager2 {
     final ResolvedBag.Entry[] new_entry = new_bag.entries;
     int newEntryIndex = 0;
 
-  // const ResolvedBag::Entry* parent_entry = parent_bag->entries;
+    // const ResolvedBag::Entry* parent_entry = parent_bag->entries;
     int parentEntryIndex = 0;
     // final ResolvedBag.Entry parent_entry_end = parent_entry + parent_bag.entry_count;
     final int parentEntryCount = parent_bag.entry_count;
@@ -1161,10 +1176,10 @@ public class CppAssetManager2 {
       int err = entry.dynamic_ref_table.lookupResourceValue(valueRef);
       new_entry_.value = valueRef.get();
       if (err != NO_ERROR) {
-        System.err.println(String.format(
-            "Failed to resolve value t=0x%02x d=0x%08x for key 0x%08x.",
-            new_entry_.value.dataType,
-            new_entry_.value.data, new_key.get()));
+        System.err.println(
+            String.format(
+                "Failed to resolve value t=0x%02x d=0x%08x for key 0x%08x.",
+                new_entry_.value.dataType, new_entry_.value.data, new_key.get()));
         return null;
       }
       // ++map_entry;
@@ -1191,7 +1206,8 @@ public class CppAssetManager2 {
     final int actual_count = newEntryIndex;
     if (actual_count != max_count) {
       // new_bag.reset(reinterpret_cast<ResolvedBag*>(realloc(
-      //     new_bag.release(), sizeof(ResolvedBag) + (actual_count * sizeof(ResolvedBag::Entry)))));
+      //     new_bag.release(), sizeof(ResolvedBag) + (actual_count *
+      // sizeof(ResolvedBag::Entry)))));
       Entry[] resizedEntries = new Entry[actual_count];
       System.arraycopy(new_bag.entries, 0, resizedEntries, 0, actual_count);
       new_bag.entries = resizedEntries;
@@ -1234,12 +1250,11 @@ public class CppAssetManager2 {
   // If no package is specified in `resource_name`, then `fallback_package` is used as the package.
   // If no type is specified in `resource_name`, then `fallback_type` is used as the type.
   // Returns 0x0 if no resource by that name was found.
-//  int GetResourceId(final String resource_name, final String fallback_type = {},
-//    final String fallback_package = {});
+  //  int GetResourceId(final String resource_name, final String fallback_type = {},
+  //    final String fallback_package = {});
   @SuppressWarnings("NewApi")
-  public int GetResourceId(final String resource_name,
-      final String fallback_type,
-      final String fallback_package) {
+  public int GetResourceId(
+      final String resource_name, final String fallback_type, final String fallback_package) {
     final Ref<String> package_name = new Ref<>(null),
         type = new Ref<>(null),
         entry = new Ref<>(null);
@@ -1274,7 +1289,7 @@ public class CppAssetManager2 {
 
     for (final PackageGroup package_group : package_groups_) {
       for (final ConfiguredPackage package_impl : package_group.packages_) {
-        LoadedPackage package_= package_impl.loaded_package_;
+        LoadedPackage package_ = package_impl.loaded_package_;
         if (!Objects.equals(package_name.get(), package_.GetPackageName())) {
           // All packages in the same group are expected to have the same package name.
           break;
@@ -1340,7 +1355,7 @@ public class CppAssetManager2 {
 
   // Purge all resources that are cached and vary by the configuration axis denoted by the
   // bitmask `diff`.
-//  void InvalidateCaches(int diff);
+  //  void InvalidateCaches(int diff);
   private void InvalidateCaches(int diff) {
     if (diff == 0xffffffff) {
       // Everything must go.
@@ -1361,31 +1376,36 @@ public class CppAssetManager2 {
   }
 
   // Creates a new Theme from this AssetManager.
-//  std.unique_ptr<Theme> NewTheme();
+  //  std.unique_ptr<Theme> NewTheme();
   public Theme NewTheme() {
     return new Theme(this);
   }
 
   public static class Theme {
     //  friend class AssetManager2;
-//
-// public:
-//
-//
-//
-//  final AssetManager2* GetAssetManager() { return asset_manager_; }
-//
-    public CppAssetManager2 GetAssetManager() { return asset_manager_; }
     //
-//  // Returns a bit mask of configuration changes that will impact this
-//  // theme (and thus require completely reloading it).
-    public int GetChangingConfigurations() { return type_spec_flags_; }
+    // public:
+    //
+    //
+    //
+    //  final AssetManager2* GetAssetManager() { return asset_manager_; }
+    //
+    public CppAssetManager2 GetAssetManager() {
+      return asset_manager_;
+    }
+
+    //
+    //  // Returns a bit mask of configuration changes that will impact this
+    //  // theme (and thus require completely reloading it).
+    public int GetChangingConfigurations() {
+      return type_spec_flags_;
+    }
 
-// private:
-//  private DISALLOW_COPY_AND_ASSIGN(Theme);
+    // private:
+    //  private DISALLOW_COPY_AND_ASSIGN(Theme);
 
     // Called by AssetManager2.
-//  private explicit Theme(AssetManager2* asset_manager) : asset_manager_(asset_manager) {}
+    //  private explicit Theme(AssetManager2* asset_manager) : asset_manager_(asset_manager) {}
 
     private final CppAssetManager2 asset_manager_;
     private int type_spec_flags_ = 0;
@@ -1429,7 +1449,7 @@ public class CppAssetManager2 {
     // to true, this behavior is changed and all theme attributes from the style at
     // `resid` are applied.
     // Returns false if the style failed to apply.
-//  boolean ApplyStyle(int resid, boolean force = false);
+    //  boolean ApplyStyle(int resid, boolean force = false);
     public boolean ApplyStyle(int resid, boolean force) {
       // ATRACE_NAME("Theme::ApplyStyle");
 
@@ -1446,18 +1466,21 @@ public class CppAssetManager2 {
       ThemePackage last_package = null;
       ThemeType last_type = null;
 
-      // Iterate backwards, because each bag is sorted in ascending key ID order, meaning we will only
+      // Iterate backwards, because each bag is sorted in ascending key ID order, meaning we will
+      // only
       // need to perform one resize per type.
       //     using reverse_bag_iterator = std::reverse_iterator<const ResolvedBag::Entry*>;
       // const auto bag_iter_end = reverse_bag_iterator(begin(bag));
-      //     for (auto bag_iter = reverse_bag_iterator(end(bag)); bag_iter != bag_iter_end; ++bag_iter) {
+      //     for (auto bag_iter = reverse_bag_iterator(end(bag)); bag_iter != bag_iter_end;
+      // ++bag_iter) {
       List<Entry> bagEntries = new ArrayList<>(Arrays.asList(bag.entries));
       Collections.reverse(bagEntries);
       for (ResolvedBag.Entry bag_iter : bagEntries) {
         //   final int attr_resid = bag_iter.key;
         final int attr_resid = bag_iter == null ? 0 : bag_iter.key;
 
-        // If the resource ID passed in is not a style, the key can be some other identifier that is not
+        // If the resource ID passed in is not a style, the key can be some other identifier that is
+        // not
         // a resource ID. We should fail fast instead of operating with strange resource IDs.
         if (!is_valid_resid(attr_resid)) {
           return false;
@@ -1484,7 +1507,8 @@ public class CppAssetManager2 {
         if (last_type_idx != type_idx) {
           ThemeType type = last_package.types[type_idx];
           if (type == null) {
-            // Allocate enough memory to contain this entry_idx. Since we're iterating in reverse over
+            // Allocate enough memory to contain this entry_idx. Since we're iterating in reverse
+            // over
             // a sorted list of attributes, this shouldn't be resized again during this method call.
             // type.reset(reinterpret_cast<ThemeType*>(
             //     calloc(sizeof(ThemeType) + (entry_idx + 1) * sizeof(ThemeEntry), 1)));
@@ -1492,7 +1516,8 @@ public class CppAssetManager2 {
             type.entries = new ThemeEntry[entry_idx + 1];
             type.entry_count = entry_idx + 1;
           } else if (entry_idx >= type.entry_count) {
-            // Reallocate the memory to contain this entry_idx. Since we're iterating in reverse over
+            // Reallocate the memory to contain this entry_idx. Since we're iterating in reverse
+            // over
             // a sorted list of attributes, this shouldn't be resized again during this method call.
             int new_count = entry_idx + 1;
             // type.reset(reinterpret_cast<ThemeType*>(
@@ -1515,8 +1540,9 @@ public class CppAssetManager2 {
           entry = last_type.entries[entry_idx] = new ThemeEntry();
           entry.value = new Res_value();
         }
-        if (force || (entry.value.dataType == Res_value.TYPE_NULL &&
-            entry.value.data != Res_value.DATA_NULL_EMPTY)) {
+        if (force
+            || (entry.value.dataType == Res_value.TYPE_NULL
+                && entry.value.data != Res_value.DATA_NULL_EMPTY)) {
           entry.cookie = bag_iter.cookie;
           entry.type_spec_flags |= bag.type_spec_flags;
           entry.value = bag_iter.value;
@@ -1532,13 +1558,14 @@ public class CppAssetManager2 {
     //
     // If the attribute is not found, returns kInvalidCookie.
     //
-    // NOTE: This function does not do reference traversal. If you want to follow references to other
+    // NOTE: This function does not do reference traversal. If you want to follow references to
+    // other
     // resources to get the "real" value to use, you need to call ResolveReference() after this
     // function.
-//  ApkAssetsCookie GetAttribute(int resid, Res_value* out_value,
-//                               int* out_flags) const;
-    public ApkAssetsCookie GetAttribute(int resid, Ref<Res_value> out_value,
-        final Ref<Integer> out_flags) {
+    //  ApkAssetsCookie GetAttribute(int resid, Res_value* out_value,
+    //                               int* out_flags) const;
+    public ApkAssetsCookie GetAttribute(
+        int resid, Ref<Res_value> out_value, final Ref<Integer> out_flags) {
       int cnt = 20;
 
       int type_spec_flags = 0;
@@ -1570,8 +1597,8 @@ public class CppAssetManager2 {
               }
 
               // @null is different than @empty.
-              if (entry.value.dataType == Res_value.TYPE_NULL &&
-                  entry.value.data != Res_value.DATA_NULL_EMPTY) {
+              if (entry.value.dataType == Res_value.TYPE_NULL
+                  && entry.value.data != Res_value.DATA_NULL_EMPTY) {
                 return K_INVALID_COOKIE;
               }
 
@@ -1588,11 +1615,13 @@ public class CppAssetManager2 {
 
     // This is like ResolveReference(), but also takes
     // care of resolving attribute references to the theme.
-//  ApkAssetsCookie ResolveAttributeReference(ApkAssetsCookie cookie, Res_value* in_out_value,
-//                                            ResTable_config in_out_selected_config = null,
-//                                            int* in_out_type_spec_flags = null,
-//                                            int* out_last_ref = null);
-    ApkAssetsCookie ResolveAttributeReference(ApkAssetsCookie cookie, Ref<Res_value> in_out_value,
+    //  ApkAssetsCookie ResolveAttributeReference(ApkAssetsCookie cookie, Res_value* in_out_value,
+    //                                            ResTable_config in_out_selected_config = null,
+    //                                            int* in_out_type_spec_flags = null,
+    //                                            int* out_last_ref = null);
+    ApkAssetsCookie ResolveAttributeReference(
+        ApkAssetsCookie cookie,
+        Ref<Res_value> in_out_value,
         final Ref<ResTable_config> in_out_selected_config,
         final Ref<Integer> in_out_type_spec_flags,
         final Ref<Integer> out_last_ref) {
@@ -1604,26 +1633,26 @@ public class CppAssetManager2 {
         }
 
         if (in_out_type_spec_flags != null) {
-//          *in_out_type_spec_flags |= new_flags;
+          //          *in_out_type_spec_flags |= new_flags;
           in_out_type_spec_flags.set(in_out_type_spec_flags.get() | new_flags.get());
         }
       }
-      return asset_manager_.ResolveReference(cookie, in_out_value, in_out_selected_config,
-          in_out_type_spec_flags, out_last_ref);
+      return asset_manager_.ResolveReference(
+          cookie, in_out_value, in_out_selected_config, in_out_type_spec_flags, out_last_ref);
     }
 
     //  void Clear();
     public void Clear() {
       type_spec_flags_ = 0;
       for (int i = 0; i < packages_.length; i++) {
-//        package_.reset();
+        //        package_.reset();
         packages_[i] = null;
       }
     }
 
     // Sets this Theme to be a copy of `o` if `o` has the same AssetManager as this Theme.
     // Returns false if the AssetManagers of the Themes were not compatible.
-//  boolean SetTo(final Theme& o);
+    //  boolean SetTo(final Theme& o);
     public boolean SetTo(final Theme o) {
       if (this == o) {
         return true;
@@ -1659,7 +1688,8 @@ public class CppAssetManager2 {
           }
 
           // Create a new type and update it to theirs.
-          // const size_t type_alloc_size = sizeof(ThemeType) + (type->entry_count * sizeof(ThemeEntry));
+          // const size_t type_alloc_size = sizeof(ThemeType) + (type->entry_count *
+          // sizeof(ThemeEntry));
           // void* copied_data = malloc(type_alloc_size);
           ThemeType copied_data = new ThemeType();
           copied_data.entry_count = type.entry_count;
@@ -1685,8 +1715,8 @@ public class CppAssetManager2 {
       return true;
     }
 
-//
-  }  // namespace android
+    //
+  } // namespace android
 
   public List<AssetPath> getAssetPaths() {
     ArrayList<AssetPath> assetPaths = new ArrayList<>(apk_assets_.size());
@@ -1696,5 +1726,4 @@ public class CppAssetManager2 {
     }
     return assetPaths;
   }
-
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/DataType.java b/resources/src/main/java/org/robolectric/res/android/DataType.java
index b238544b6..f9e00a71b 100644
--- a/resources/src/main/java/org/robolectric/res/android/DataType.java
+++ b/resources/src/main/java/org/robolectric/res/android/DataType.java
@@ -23,9 +23,10 @@ public enum DataType {
   FRACTION(0x06),
   /** {@code data} holds a dynamic {@link ResourceTableChunk} entry reference. */
   DYNAMIC_REFERENCE(0x07),
-  /** {@code data} holds an attribute resource identifier, which needs to be resolved
-    * before it can be used like a TYPE_ATTRIBUTE.
-    */
+  /**
+   * {@code data} holds an attribute resource identifier, which needs to be resolved before it can
+   * be used like a TYPE_ATTRIBUTE.
+   */
   DYNAMIC_ATTRIBUTE(0x08),
   /** {@code data} is a raw integer value of the form n..n. */
   INT_DEC(0x10),
diff --git a/resources/src/main/java/org/robolectric/res/android/DynamicRefTable.java b/resources/src/main/java/org/robolectric/res/android/DynamicRefTable.java
index 537a9f2f2..af11726a0 100644
--- a/resources/src/main/java/org/robolectric/res/android/DynamicRefTable.java
+++ b/resources/src/main/java/org/robolectric/res/android/DynamicRefTable.java
@@ -18,15 +18,14 @@ import java.util.Objects;
 import org.robolectric.res.android.ResourceTypes.Res_value;
 
 /**
- * Holds the shared library ID table. Shared libraries are assigned package IDs at
- * build time, but they may be loaded in a different order, so we need to maintain
- * a mapping of build-time package ID to run-time assigned package ID.
+ * Holds the shared library ID table. Shared libraries are assigned package IDs at build time, but
+ * they may be loaded in a different order, so we need to maintain a mapping of build-time package
+ * ID to run-time assigned package ID.
  *
- * Dynamic references are not currently supported in overlays. Only the base package
- * may have dynamic references.
+ * <p>Dynamic references are not currently supported in overlays. Only the base package may have
+ * dynamic references.
  */
-public class DynamicRefTable
-{
+public class DynamicRefTable {
   DynamicRefTable(byte packageId, boolean appAsLib) {
     this.mAssignedPackageId = packageId;
     this.mAppAsLib = appAsLib;
@@ -35,10 +34,10 @@ public class DynamicRefTable
     mLookupTable[SYS_PACKAGE_ID] = SYS_PACKAGE_ID;
   }
 
-//  // Loads an unmapped reference table from the package.
-//  Errors load(final ResTable_lib_header header) {
-//    return null;
-//  }
+  //  // Loads an unmapped reference table from the package.
+  //  Errors load(final ResTable_lib_header header) {
+  //    return null;
+  //  }
 
   // Adds mappings from the other DynamicRefTable
   int addMappings(final DynamicRefTable other) {
@@ -46,17 +45,17 @@ public class DynamicRefTable
       return UNKNOWN_ERROR;
     }
 
-//    final int entryCount = other.mEntries.size();
-//    for (size_t i = 0; i < entryCount; i++) {
-//      ssize_t index = mEntries.indexOfKey(other.mEntries.keyAt(i));
-//      if (index < 0) {
-//        mEntries.add(other.mEntries.keyAt(i), other.mEntries[i]);
-//      } else {
-//        if (other.mEntries[i] != mEntries[index]) {
-//          return UNKNOWN_ERROR;
-//        }
-//      }
-//    }
+    //    final int entryCount = other.mEntries.size();
+    //    for (size_t i = 0; i < entryCount; i++) {
+    //      ssize_t index = mEntries.indexOfKey(other.mEntries.keyAt(i));
+    //      if (index < 0) {
+    //        mEntries.add(other.mEntries.keyAt(i), other.mEntries[i]);
+    //      } else {
+    //        if (other.mEntries[i] != mEntries[index]) {
+    //          return UNKNOWN_ERROR;
+    //        }
+    //      }
+    //    }
     for (Entry<String, Byte> otherEntry : other.mEntries.entrySet()) {
       String key = otherEntry.getKey();
       Byte curValue = mEntries.get(key);
@@ -98,8 +97,8 @@ public class DynamicRefTable
     mAliasId.put(stagedId, finalizedId);
   }
 
-//  // Performs the actual conversion of build-time resource ID to run-time
-//  // resource ID.
+  //  // Performs the actual conversion of build-time resource ID to run-time
+  //  // resource ID.
   int lookupResourceId(Ref<Integer> resId) {
     int res = resId.get();
     int packageId = Res_GETPACKAGE(res) + 1;
@@ -130,7 +129,8 @@ public class DynamicRefTable
     // Do a proper lookup.
     int translatedId = mLookupTable[packageId];
     if (translatedId == 0) {
-      ALOGW("DynamicRefTable(0x%02x): No mapping for build-time package ID 0x%02x.",
+      ALOGW(
+          "DynamicRefTable(0x%02x): No mapping for build-time package ID 0x%02x.",
           mAssignedPackageId, packageId);
       for (int i = 0; i < 256; i++) {
         if (mLookupTable[i] != 0) {
@@ -143,7 +143,8 @@ public class DynamicRefTable
     resId.set((res & 0x00ffffff) | (((int) translatedId) << 24));
     return NO_ERROR;
   }
-//
+
+  //
   int lookupResourceValue(Ref<Res_value> value) {
     byte resolvedType = DataType.REFERENCE.code();
     Res_value inValue = value.get();
@@ -185,21 +186,21 @@ public class DynamicRefTable
 
     value.set(new Res_value(resolvedType, resIdRef.get()));
     return NO_ERROR;
- }
+  }
 
   public Map<String, Byte> entries() {
     return mEntries;
   }
 
   //
-//  final KeyedVector<String16, uint8_t>& entries() final {
-//  return mEntries;
-//}
-//
-//  private:
-    final byte                   mAssignedPackageId;
-  final byte[]                         mLookupTable = new byte[256];
+  //  final KeyedVector<String16, uint8_t>& entries() final {
+  //  return mEntries;
+  // }
+  //
+  //  private:
+  final byte mAssignedPackageId;
+  final byte[] mLookupTable = new byte[256];
   final Map<String, Byte> mEntries = new HashMap<>();
-  boolean                            mAppAsLib;
+  boolean mAppAsLib;
   final Map<Integer, Integer> mAliasId = new HashMap<>();
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/Errors.java b/resources/src/main/java/org/robolectric/res/android/Errors.java
index 0cab2b773..c9ec6e718 100644
--- a/resources/src/main/java/org/robolectric/res/android/Errors.java
+++ b/resources/src/main/java/org/robolectric/res/android/Errors.java
@@ -1,6 +1,7 @@
 package org.robolectric.res.android;
 
-// transliterated from https://android.googlesource.com/platform/system/core/+/android-9.0.0_r12/include/utils/Errors.h
+// transliterated from
+// https://android.googlesource.com/platform/system/core/+/android-9.0.0_r12/include/utils/Errors.h
 
 public class Errors {
 
diff --git a/resources/src/main/java/org/robolectric/res/android/FileMap.java b/resources/src/main/java/org/robolectric/res/android/FileMap.java
index 0672bbde4..e633a34cf 100644
--- a/resources/src/main/java/org/robolectric/res/android/FileMap.java
+++ b/resources/src/main/java/org/robolectric/res/android/FileMap.java
@@ -49,14 +49,12 @@ public class FileMap {
   private boolean isFromZip;
 
   // Create a new mapping on an open file.
-//
-// Closing the file descriptor does not unmap the pages, so we don't
-// claim ownership of the fd.
-//
-// Returns "false" on failure.
-  boolean create(String origFileName, int fd, long offset, int length,
-      boolean readOnly)
-  {
+  //
+  // Closing the file descriptor does not unmap the pages, so we don't
+  // claim ownership of the fd.
+  //
+  // Returns "false" on failure.
+  boolean create(String origFileName, int fd, long offset, int length, boolean readOnly) {
     this.mFileName = origFileName;
     this.fd = fd;
     this.mDataOffset = offset;
@@ -64,95 +62,95 @@ public class FileMap {
     return true;
   }
 
-// #if defined(__MINGW32__)
-//     int     adjust;
-//     off64_t adjOffset;
-//     size_t  adjLength;
-//
-//     if (mPageSize == -1) {
-//       SYSTEM_INFO  si;
-//
-//       GetSystemInfo( &si );
-//       mPageSize = si.dwAllocationGranularity;
-//     }
-//
-//     DWORD  protect = readOnly ? PAGE_READONLY : PAGE_READWRITE;
-//
-//     mFileHandle  = (HANDLE) _get_osfhandle(fd);
-//     mFileMapping = CreateFileMapping( mFileHandle, NULL, protect, 0, 0, NULL);
-//     if (mFileMapping == NULL) {
-//       ALOGE("CreateFileMapping(%s, %" PRIx32 ") failed with error %" PRId32 "\n",
-//           mFileHandle, protect, GetLastError() );
-//       return false;
-//     }
-//
-//     adjust    = offset % mPageSize;
-//     adjOffset = offset - adjust;
-//     adjLength = length + adjust;
-//
-//     mBasePtr = MapViewOfFile( mFileMapping,
-//         readOnly ? FILE_MAP_READ : FILE_MAP_ALL_ACCESS,
-//         0,
-//         (DWORD)(adjOffset),
-//         adjLength );
-//     if (mBasePtr == NULL) {
-//       ALOGE("MapViewOfFile(%" PRId64 ", 0x%x) failed with error %" PRId32 "\n",
-//           adjOffset, adjLength, GetLastError() );
-//       CloseHandle(mFileMapping);
-//       mFileMapping = INVALID_HANDLE_VALUE;
-//       return false;
-//     }
-// #else // !defined(__MINGW32__)
-//     int     prot, flags, adjust;
-//     off64_t adjOffset;
-//     size_t  adjLength;
-//
-//     void* ptr;
-//
-//     assert(fd >= 0);
-//     assert(offset >= 0);
-//     assert(length > 0);
-//
-//     // init on first use
-//     if (mPageSize == -1) {
-//       mPageSize = sysconf(_SC_PAGESIZE);
-//       if (mPageSize == -1) {
-//         ALOGE("could not get _SC_PAGESIZE\n");
-//         return false;
-//       }
-//     }
-//
-//     adjust = offset % mPageSize;
-//     adjOffset = offset - adjust;
-//     adjLength = length + adjust;
-//
-//     flags = MAP_SHARED;
-//     prot = PROT_READ;
-//     if (!readOnly)
-//       prot |= PROT_WRITE;
-//
-//     ptr = mmap(NULL, adjLength, prot, flags, fd, adjOffset);
-//     if (ptr == MAP_FAILED) {
-//       ALOGE("mmap(%lld,0x%x) failed: %s\n",
-//           (long long)adjOffset, adjLength, strerror(errno));
-//       return false;
-//     }
-//     mBasePtr = ptr;
-// #endif // !defined(__MINGW32__)
-//
-//       mFileName = origFileName != NULL ? strdup(origFileName) : NULL;
-//     mBaseLength = adjLength;
-//     mDataOffset = offset;
-//     mDataPtr = (char*) mBasePtr + adjust;
-//     mDataLength = length;
-//
-//     assert(mBasePtr != NULL);
-//
-//     ALOGV("MAP: base %s/0x%x data %s/0x%x\n",
-//         mBasePtr, mBaseLength, mDataPtr, mDataLength);
-//
-//     return true;
-//   }
+  // #if defined(__MINGW32__)
+  //     int     adjust;
+  //     off64_t adjOffset;
+  //     size_t  adjLength;
+  //
+  //     if (mPageSize == -1) {
+  //       SYSTEM_INFO  si;
+  //
+  //       GetSystemInfo( &si );
+  //       mPageSize = si.dwAllocationGranularity;
+  //     }
+  //
+  //     DWORD  protect = readOnly ? PAGE_READONLY : PAGE_READWRITE;
+  //
+  //     mFileHandle  = (HANDLE) _get_osfhandle(fd);
+  //     mFileMapping = CreateFileMapping( mFileHandle, NULL, protect, 0, 0, NULL);
+  //     if (mFileMapping == NULL) {
+  //       ALOGE("CreateFileMapping(%s, %" PRIx32 ") failed with error %" PRId32 "\n",
+  //           mFileHandle, protect, GetLastError() );
+  //       return false;
+  //     }
+  //
+  //     adjust    = offset % mPageSize;
+  //     adjOffset = offset - adjust;
+  //     adjLength = length + adjust;
+  //
+  //     mBasePtr = MapViewOfFile( mFileMapping,
+  //         readOnly ? FILE_MAP_READ : FILE_MAP_ALL_ACCESS,
+  //         0,
+  //         (DWORD)(adjOffset),
+  //         adjLength );
+  //     if (mBasePtr == NULL) {
+  //       ALOGE("MapViewOfFile(%" PRId64 ", 0x%x) failed with error %" PRId32 "\n",
+  //           adjOffset, adjLength, GetLastError() );
+  //       CloseHandle(mFileMapping);
+  //       mFileMapping = INVALID_HANDLE_VALUE;
+  //       return false;
+  //     }
+  // #else // !defined(__MINGW32__)
+  //     int     prot, flags, adjust;
+  //     off64_t adjOffset;
+  //     size_t  adjLength;
+  //
+  //     void* ptr;
+  //
+  //     assert(fd >= 0);
+  //     assert(offset >= 0);
+  //     assert(length > 0);
+  //
+  //     // init on first use
+  //     if (mPageSize == -1) {
+  //       mPageSize = sysconf(_SC_PAGESIZE);
+  //       if (mPageSize == -1) {
+  //         ALOGE("could not get _SC_PAGESIZE\n");
+  //         return false;
+  //       }
+  //     }
+  //
+  //     adjust = offset % mPageSize;
+  //     adjOffset = offset - adjust;
+  //     adjLength = length + adjust;
+  //
+  //     flags = MAP_SHARED;
+  //     prot = PROT_READ;
+  //     if (!readOnly)
+  //       prot |= PROT_WRITE;
+  //
+  //     ptr = mmap(NULL, adjLength, prot, flags, fd, adjOffset);
+  //     if (ptr == MAP_FAILED) {
+  //       ALOGE("mmap(%lld,0x%x) failed: %s\n",
+  //           (long long)adjOffset, adjLength, strerror(errno));
+  //       return false;
+  //     }
+  //     mBasePtr = ptr;
+  // #endif // !defined(__MINGW32__)
+  //
+  //       mFileName = origFileName != NULL ? strdup(origFileName) : NULL;
+  //     mBaseLength = adjLength;
+  //     mDataOffset = offset;
+  //     mDataPtr = (char*) mBasePtr + adjust;
+  //     mDataLength = length;
+  //
+  //     assert(mBasePtr != NULL);
+  //
+  //     ALOGV("MAP: base %s/0x%x data %s/0x%x\n",
+  //         mBasePtr, mBaseLength, mDataPtr, mDataLength);
+  //
+  //     return true;
+  //   }
 
   boolean createFromZip(
       String origFileName,
@@ -165,26 +163,26 @@ public class FileMap {
     this.zipFile = zipFile;
     this.zipEntry = entry;
 
-    assert(fd >= 0);
-    assert(offset >= 0);
+    assert (fd >= 0);
+    assert (offset >= 0);
     // assert(length > 0);
 
     // init on first use
-//    if (mPageSize == -1) {
-//      mPageSize = sysconf(_SC_PAGESIZE);
-//      if (mPageSize == -1) {
-//        ALOGE("could not get _SC_PAGESIZE\n");
-//        return false;
-//      }
-//    }
+    //    if (mPageSize == -1) {
+    //      mPageSize = sysconf(_SC_PAGESIZE);
+    //      if (mPageSize == -1) {
+    //        ALOGE("could not get _SC_PAGESIZE\n");
+    //        return false;
+    //      }
+    //    }
 
     // adjust = Math.toIntExact(offset % mPageSize);
     // adjOffset = offset - adjust;
     // adjLength = length + adjust;
 
-    //flags = MAP_SHARED;
-    //prot = PROT_READ;
-    //if (!readOnly)
+    // flags = MAP_SHARED;
+    // prot = PROT_READ;
+    // if (!readOnly)
     //  prot |= PROT_WRITE;
 
     // ptr = mmap(null, adjLength, prot, flags, fd, adjOffset);
@@ -196,15 +194,14 @@ public class FileMap {
     // mBasePtr = ptr;
 
     mFileName = origFileName != null ? origFileName : null;
-    //mBaseLength = adjLength;
+    // mBaseLength = adjLength;
     mDataOffset = offset;
-    //mDataPtr = mBasePtr + adjust;
+    // mDataPtr = mBasePtr + adjust;
     mDataLength = toIntExact(entry.getSize());
 
-    //assert(mBasePtr != 0);
+    // assert(mBasePtr != 0);
 
-    ALOGV("MAP: base %s/0x%x data %s/0x%x\n",
-        mBasePtr, mBaseLength, mDataPtr, mDataLength);
+    ALOGV("MAP: base %s/0x%x data %s/0x%x\n", mBasePtr, mBaseLength, mDataPtr, mDataLength);
 
     return true;
   }
@@ -398,16 +395,18 @@ public class FileMap {
   //     long offset, int length, boolean readOnly) {
   // }
 
-    // ~FileMap(void);
+  // ~FileMap(void);
 
-    /*
-     * Return the name of the file this map came from, if known.
-     */
-    String getFileName() { return mFileName; }
+  /*
+   * Return the name of the file this map came from, if known.
+   */
+  String getFileName() {
+    return mFileName;
+  }
 
-    /*
-     * Get a pointer to the piece of the file we requested.
-     */
+  /*
+   * Get a pointer to the piece of the file we requested.
+   */
   synchronized byte[] getDataPtr() {
     if (mDataPtr == null) {
       mDataPtr = new byte[mDataLength];
@@ -451,58 +450,57 @@ public class FileMap {
   /*
    * Get the length we requested.
    */
-  int getDataLength() { return mDataLength; }
+  int getDataLength() {
+    return mDataLength;
+  }
 
   /*
    * Get the data offset used to create this map.
    */
-  long getDataOffset() { return mDataOffset; }
+  long getDataOffset() {
+    return mDataOffset;
+  }
 
   public ZipEntry getZipEntry() {
     return zipEntry;
   }
 
   //   /*
-//    * This maps directly to madvise() values, but allows us to avoid
-//    * including <sys/mman.h> everywhere.
-//    */
-//   enum MapAdvice {
-//     NORMAL, RANDOM, SEQUENTIAL, WILLNEED, DONTNEED
-//   };
-//
-//   /*
-//    * Apply an madvise() call to the entire file.
-//    *
-//    * Returns 0 on success, -1 on failure.
-//    */
-//   int advise(MapAdvice advice);
-//
-//   protected:
-//
-//   private:
-//   // these are not implemented
-//   FileMap(const FileMap& src);
-//     const FileMap& operator=(const FileMap& src);
-//
-  String       mFileName;      // original file name, if known
-  int       mBasePtr;       // base of mmap area; page aligned
-  int      mBaseLength;    // length, measured from "mBasePtr"
-  long     mDataOffset;    // offset used when map was created
-  byte[]       mDataPtr;       // start of requested data, offset from base
-  int      mDataLength;    // length, measured from "mDataPtr"
+  //    * This maps directly to madvise() values, but allows us to avoid
+  //    * including <sys/mman.h> everywhere.
+  //    */
+  //   enum MapAdvice {
+  //     NORMAL, RANDOM, SEQUENTIAL, WILLNEED, DONTNEED
+  //   };
+  //
+  //   /*
+  //    * Apply an madvise() call to the entire file.
+  //    *
+  //    * Returns 0 on success, -1 on failure.
+  //    */
+  //   int advise(MapAdvice advice);
+  //
+  //   protected:
+  //
+  //   private:
+  //   // these are not implemented
+  //   FileMap(const FileMap& src);
+  //     const FileMap& operator=(const FileMap& src);
+  //
+  String mFileName; // original file name, if known
+  int mBasePtr; // base of mmap area; page aligned
+  int mBaseLength; // length, measured from "mBasePtr"
+  long mDataOffset; // offset used when map was created
+  byte[] mDataPtr; // start of requested data, offset from base
+  int mDataLength; // length, measured from "mDataPtr"
   static long mPageSize;
 
   @Override
   public String toString() {
     if (isFromZip) {
-      return "FileMap{" +
-          "zipFile=" + zipFile.getName() +
-          ", zipEntry=" + zipEntry +
-          '}';
+      return "FileMap{" + "zipFile=" + zipFile.getName() + ", zipEntry=" + zipEntry + '}';
     } else {
-      return "FileMap{" +
-          "mFileName='" + mFileName + '\'' +
-          '}';
+      return "FileMap{" + "mFileName='" + mFileName + '\'' + '}';
     }
   }
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/Idmap.java b/resources/src/main/java/org/robolectric/res/android/Idmap.java
index b7f6a9cb4..b52d667d1 100644
--- a/resources/src/main/java/org/robolectric/res/android/Idmap.java
+++ b/resources/src/main/java/org/robolectric/res/android/Idmap.java
@@ -64,8 +64,8 @@ class Idmap {
 
     // Performs a lookup of the expected entry ID for the given IDMAP entry header.
     // Returns true if the mapping exists and fills `output_entry_id` with the result.
-    static boolean Lookup(IdmapEntry_header header, int input_entry_id,
-        final Ref<Integer> output_entry_id) {
+    static boolean Lookup(
+        IdmapEntry_header header, int input_entry_id, final Ref<Integer> output_entry_id) {
       if (input_entry_id < dtohs(header.entry_id_offset)) {
         // After applying the offset, the entry is not present.
         return false;
@@ -92,50 +92,52 @@ class Idmap {
     @SuppressWarnings("DoNotCallSuggester")
     static boolean IsValidIdmapHeader(StringPiece data) {
       throw new UnsupportedOperationException();
-//   if (!is_word_aligned(data.data())) {
-//     LOG(ERROR) << "Idmap header is not word aligned.";
-//     return false;
-//   }
-//
-//   if (data.size() < sizeof(Idmap_header)) {
-//     LOG(ERROR) << "Idmap header is too small.";
-//     return false;
-//   }
-//
-//   const Idmap_header* header = reinterpret_cast<const Idmap_header*>(data.data());
-//   if (dtohl(header->magic) != kIdmapMagic) {
-//     LOG(ERROR) << StringPrintf("Invalid Idmap file: bad magic value (was 0x%08x, expected 0x%08x)",
-//                                dtohl(header->magic), kIdmapMagic);
-//     return false;
-//   }
-//
-//   if (dtohl(header->version) != kIdmapCurrentVersion) {
-//     // We are strict about versions because files with this format are auto-generated and don't need
-//     // backwards compatibility.
-//     LOG(ERROR) << StringPrintf("Version mismatch in Idmap (was 0x%08x, expected 0x%08x)",
-//                                dtohl(header->version), kIdmapCurrentVersion);
-//     return false;
-//   }
-//
-//   if (!is_valid_package_id(dtohs(header->target_package_id))) {
-//     LOG(ERROR) << StringPrintf("Target package ID in Idmap is invalid: 0x%02x",
-//                                dtohs(header->target_package_id));
-//     return false;
-//   }
-//
-//   if (dtohs(header->type_count) > 255) {
-//     LOG(ERROR) << StringPrintf("Idmap has too many type mappings (was %d, max 255)",
-//                                (int)dtohs(header->type_count));
-//     return false;
-//   }
-//   return true;
+      //   if (!is_word_aligned(data.data())) {
+      //     LOG(ERROR) << "Idmap header is not word aligned.";
+      //     return false;
+      //   }
+      //
+      //   if (data.size() < sizeof(Idmap_header)) {
+      //     LOG(ERROR) << "Idmap header is too small.";
+      //     return false;
+      //   }
+      //
+      //   const Idmap_header* header = reinterpret_cast<const Idmap_header*>(data.data());
+      //   if (dtohl(header->magic) != kIdmapMagic) {
+      //     LOG(ERROR) << StringPrintf("Invalid Idmap file: bad magic value (was 0x%08x, expected
+      // 0x%08x)",
+      //                                dtohl(header->magic), kIdmapMagic);
+      //     return false;
+      //   }
+      //
+      //   if (dtohl(header->version) != kIdmapCurrentVersion) {
+      //     // We are strict about versions because files with this format are auto-generated and
+      // don't need
+      //     // backwards compatibility.
+      //     LOG(ERROR) << StringPrintf("Version mismatch in Idmap (was 0x%08x, expected 0x%08x)",
+      //                                dtohl(header->version), kIdmapCurrentVersion);
+      //     return false;
+      //   }
+      //
+      //   if (!is_valid_package_id(dtohs(header->target_package_id))) {
+      //     LOG(ERROR) << StringPrintf("Target package ID in Idmap is invalid: 0x%02x",
+      //                                dtohs(header->target_package_id));
+      //     return false;
+      //   }
+      //
+      //   if (dtohs(header->type_count) > 255) {
+      //     LOG(ERROR) << StringPrintf("Idmap has too many type mappings (was %d, max 255)",
+      //                                (int)dtohs(header->type_count));
+      //     return false;
+      //   }
+      //   return true;
     }
 
-// LoadedIdmap::LoadedIdmap(const Idmap_header* header) : header_(header) {
-//   size_t length = strnlen(reinterpret_cast<const char*>(header_->overlay_path),
-//                           arraysize(header_->overlay_path));
-//   overlay_apk_path_.assign(reinterpret_cast<const char*>(header_->overlay_path), length);
-// }
+    // LoadedIdmap::LoadedIdmap(const Idmap_header* header) : header_(header) {
+    //   size_t length = strnlen(reinterpret_cast<const char*>(header_->overlay_path),
+    //                           arraysize(header_->overlay_path));
+    //   overlay_apk_path_.assign(reinterpret_cast<const char*>(header_->overlay_path), length);
+    // }
     // Loads an IDMAP from a chunk of memory. Returns nullptr if the IDMAP data was malformed.
     LoadedIdmap Load(StringPiece idmap_data) {
       ATRACE_CALL();
@@ -149,9 +151,9 @@ class Idmap {
       // Can't use make_unique because LoadedImpl constructor is private.
       LoadedIdmap loaded_idmap = new LoadedIdmap(header);
 
-  // const byte* data_ptr = reinterpret_cast<const byte*>(idmap_data.data()) + sizeof(*header);
-      StringPiece data_ptr = new StringPiece(idmap_data.myBuf(),
-          idmap_data.myOffset() + SIZEOF_CPTR);
+      // const byte* data_ptr = reinterpret_cast<const byte*>(idmap_data.data()) + sizeof(*header);
+      StringPiece data_ptr =
+          new StringPiece(idmap_data.myBuf(), idmap_data.myOffset() + SIZEOF_CPTR);
       // int data_size = idmap_data.size() - sizeof(*header);
       int data_size = idmap_data.size() - SIZEOF_CPTR;
 
@@ -163,19 +165,24 @@ class Idmap {
         }
 
         // Validate the type IDs.
-    // IdmapEntry_header entry_header = reinterpret_cast<const IdmapEntry_header*>(data_ptr);
-        IdmapEntry_header entry_header = new IdmapEntry_header(data_ptr.myBuf(), data_ptr.myOffset());
-        if (!is_valid_type_id(dtohs(entry_header.target_type_id)) || !is_valid_type_id(dtohs(entry_header.overlay_type_id))) {
-          logError(String.format("Invalid type map (0x%02x -> 0x%02x)",
-              dtohs(entry_header.target_type_id),
-              dtohs(entry_header.overlay_type_id)));
+        // IdmapEntry_header entry_header = reinterpret_cast<const IdmapEntry_header*>(data_ptr);
+        IdmapEntry_header entry_header =
+            new IdmapEntry_header(data_ptr.myBuf(), data_ptr.myOffset());
+        if (!is_valid_type_id(dtohs(entry_header.target_type_id))
+            || !is_valid_type_id(dtohs(entry_header.overlay_type_id))) {
+          logError(
+              String.format(
+                  "Invalid type map (0x%02x -> 0x%02x)",
+                  dtohs(entry_header.target_type_id), dtohs(entry_header.overlay_type_id)));
           return emptyBraces();
         }
 
         // Make sure there is enough space for the entries declared in the header.
         if ((data_size - SIZEOF_CPTR) / SIZEOF_INT < dtohs(entry_header.entry_count)) {
-          logError(String.format("Idmap too small for the number of entries (%d)",
-              (int) dtohs(entry_header.entry_count)));
+          logError(
+              String.format(
+                  "Idmap too small for the number of entries (%d)",
+                  (int) dtohs(entry_header.entry_count)));
           return emptyBraces();
         }
 
@@ -183,14 +190,12 @@ class Idmap {
         if (dtohs(entry_header.entry_count) != 0) {
           // loaded_idmap.type_map_[static_cast<byte>(dtohs(entry_header.overlay_type_id))] =
           //     entry_header;
-          loaded_idmap.type_map_.put((byte) dtohs(entry_header.overlay_type_id),
-              entry_header);
+          loaded_idmap.type_map_.put((byte) dtohs(entry_header.overlay_type_id), entry_header);
         }
 
         // int entry_size_bytes =
         //     sizeof(*entry_header) + (dtohs(entry_header.entry_count) * SIZEOF_INT);
-        int entry_size_bytes =
-            SIZEOF_CPTR + (dtohs(entry_header.entry_count) * SIZEOF_INT);
+        int entry_size_bytes = SIZEOF_CPTR + (dtohs(entry_header.entry_count) * SIZEOF_INT);
         data_ptr = new StringPiece(data_ptr.myBuf(), data_ptr.myOffset() + entry_size_bytes);
         data_size -= entry_size_bytes;
         type_maps_encountered++;
@@ -198,8 +203,11 @@ class Idmap {
 
       // Verify that we parsed all the type maps.
       if (type_maps_encountered != dtohs(header.type_count)) {
-        logError("Parsed " + type_maps_encountered + " type maps but expected "
-            + (int) dtohs(header.type_count));
+        logError(
+            "Parsed "
+                + type_maps_encountered
+                + " type maps but expected "
+                + (int) dtohs(header.type_count));
         return emptyBraces();
       }
       // return std.move(loaded_idmap);
@@ -215,7 +223,8 @@ class Idmap {
       return dtohs(header_.target_package_id);
     }
 
-    // Returns the path to the RRO (Runtime Resource Overlay) APK for which this IDMAP was generated.
+    // Returns the path to the RRO (Runtime Resource Overlay) APK for which this IDMAP was
+    // generated.
     String OverlayApkPath() {
       return overlay_apk_path_;
     }
@@ -229,7 +238,7 @@ class Idmap {
       // return null;
       return type_map_.get(type_id);
     }
-//
-// }  // namespace android
+    //
+    // }  // namespace android
   }
-}
\ No newline at end of file
+}
diff --git a/resources/src/main/java/org/robolectric/res/android/IdmapEntries.java b/resources/src/main/java/org/robolectric/res/android/IdmapEntries.java
index 0ea0d9a55..8857cae01 100644
--- a/resources/src/main/java/org/robolectric/res/android/IdmapEntries.java
+++ b/resources/src/main/java/org/robolectric/res/android/IdmapEntries.java
@@ -2,7 +2,8 @@ package org.robolectric.res.android;
 
 import static org.robolectric.res.android.Errors.*;
 
-// transliterated from https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/ResourceTypes.cpp
+// transliterated from
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/ResourceTypes.cpp
 public class IdmapEntries {
 
   public boolean hasEntries() {
@@ -13,13 +14,13 @@ public class IdmapEntries {
     return (Util.dtohs(mData[0]) > 0);
   }
 
-//  int byteSize() {
-//    if (mData == null) {
-//      return 0;
-//    }
-//    short entryCount = Util.dtohs(mData[2]);
-//    return (SIZEOF_SHORT * 4) + (SIZEOF_INT * static_cast<int>(entryCount));
-//  }
+  //  int byteSize() {
+  //    if (mData == null) {
+  //      return 0;
+  //    }
+  //    short entryCount = Util.dtohs(mData[2]);
+  //    return (SIZEOF_SHORT * 4) + (SIZEOF_INT * static_cast<int>(entryCount));
+  //  }
 
   byte targetTypeId() {
     if (mData == null) {
@@ -53,19 +54,18 @@ public class IdmapEntries {
 
     throw new UnsupportedOperationException("todo"); // todo
 
-//    // It is safe to access the type here without checking the size because
-//    // we have checked this when it was first loaded.
-////        final int[] entries = reinterpret_cast<final uint32_t*>(mData) + 2;
-//        final int[] entries = reinterpret_cast<final uint32_t*>(mData) + 2;
-//    int mappedEntry = Util.dtohl(entries[entryId]);
-//    if (mappedEntry == 0xffffffff) {
-//      // This entry is not present in this idmap
-//      return BAD_INDEX;
-//    }
-//        *outEntryId = static_cast<short>(mappedEntry);
-//    return NO_ERROR;
+    //    // It is safe to access the type here without checking the size because
+    //    // we have checked this when it was first loaded.
+    ////        final int[] entries = reinterpret_cast<final uint32_t*>(mData) + 2;
+    //        final int[] entries = reinterpret_cast<final uint32_t*>(mData) + 2;
+    //    int mappedEntry = Util.dtohl(entries[entryId]);
+    //    if (mappedEntry == 0xffffffff) {
+    //      // This entry is not present in this idmap
+    //      return BAD_INDEX;
+    //    }
+    //        *outEntryId = static_cast<short>(mappedEntry);
+    //    return NO_ERROR;
   }
 
   private short[] mData;
-
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java b/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java
index d480dc9f0..a524b3151 100644
--- a/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java
+++ b/resources/src/main/java/org/robolectric/res/android/LoadedArsc.java
@@ -43,8 +43,10 @@ import org.robolectric.res.android.ResourceTypes.ResTable_type;
 import org.robolectric.res.android.ResourceTypes.ResTable_typeSpec;
 import org.robolectric.res.android.ResourceTypes.Res_value;
 
-// transliterated from https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/include/androidfw/LoadedArsc.h
-// and https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/LoadedArsc.cpp
+// transliterated from
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/include/androidfw/LoadedArsc.h
+// and
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/LoadedArsc.cpp
 public class LoadedArsc {
 
   // #ifndef LOADEDARSC_H_
@@ -82,11 +84,11 @@ public class LoadedArsc {
   }
 
   // TypeSpec is going to be immediately proceeded by
-// an array of Type structs, all in the same block of memory.
+  // an array of Type structs, all in the same block of memory.
   static class TypeSpec {
 
     public static final int SIZEOF = ResTable_typeSpec.SIZEOF + IdmapEntry_header.SIZEOF;
-    
+
     // Pointer to the mmapped data where flags are kept.
     // Flags denote whether the resource entry is public
     // and under which configurations it varies.
@@ -133,12 +135,13 @@ public class LoadedArsc {
   }
 
   //
-// private:
-//  DISALLOW_COPY_AND_ASSIGN(LoadedArsc);
-//
-//  LoadedArsc() = default;
-//   bool LoadTable(const Chunk& chunk, const LoadedIdmap* loaded_idmap, bool load_as_shared_library);
-//
+  // private:
+  //  DISALLOW_COPY_AND_ASSIGN(LoadedArsc);
+  //
+  //  LoadedArsc() = default;
+  //   bool LoadTable(const Chunk& chunk, const LoadedIdmap* loaded_idmap, bool
+  // load_as_shared_library);
+  //
   final ResStringPool global_string_pool_ = new ResStringPool();
   final List<LoadedPackage> packages_ = new ArrayList<>();
   boolean system_ = false;
@@ -177,7 +180,7 @@ public class LoadedArsc {
 
   static final int kAppPackageId = 0x7f;
 
-//  namespace {
+  //  namespace {
 
   // Builder that helps accumulate Type structs and then create a single
   // contiguous block of memory to store both the TypeSpec struct and
@@ -211,7 +214,6 @@ public class LoadedArsc {
       // memcpy(type_spec + 1, types_.data(), types_.size() * sizeof(ElementType));
       for (int i = 0; i < type_spec.types.length; i++) {
         type_spec.types[i] = types_.get(i);
-        
       }
       return type_spec;
     }
@@ -222,12 +224,14 @@ public class LoadedArsc {
     ResTable_typeSpec header_;
     IdmapEntry_header idmap_header_;
     final List<ResTable_type> types_ = new ArrayList<>();
-  };
+  }
+  ;
 
-//  }  // namespace
+  //  }  // namespace
 
-  // Precondition: The header passed in has already been verified, so reading any fields and trusting
-// the ResChunk_header is safe.
+  // Precondition: The header passed in has already been verified, so reading any fields and
+  // trusting
+  // the ResChunk_header is safe.
   static boolean VerifyResTableType(ResTable_type header) {
     if (header.id == 0) {
       logError("RES_TABLE_TYPE_TYPE has invalid ID 0.");
@@ -282,8 +286,7 @@ public class LoadedArsc {
 
     entry_offset += dtohl(type.entriesStart);
     if (entry_offset > chunk_size - ResTable_entry.SIZEOF) {
-      logError("Entry at offset " + entry_offset
-          + " is too large. No room for ResTable_entry.");
+      logError("Entry at offset " + entry_offset + " is too large. No room for ResTable_entry.");
       return false;
     }
 
@@ -312,8 +315,12 @@ public class LoadedArsc {
     if (entrySize < ResTable_map_entry.BASE_SIZEOF) {
       // There needs to be room for one Res_value struct.
       if (entry_offset + entrySize > chunk_size - Res_value.SIZEOF) {
-        logError("No room for Res_value after ResTable_entry at offset " + entry_offset
-            + " for type " + (int) type.id + ".");
+        logError(
+            "No room for Res_value after ResTable_entry at offset "
+                + entry_offset
+                + " for type "
+                + (int) type.id
+                + ".");
         return false;
       }
 
@@ -327,8 +334,7 @@ public class LoadedArsc {
       }
 
       if (value_size > chunk_size || entry_offset + entrySize > chunk_size - value_size) {
-        logError("Res_value size " + value_size + " at offset " + entry_offset
-            + " is too large.");
+        logError("Res_value size " + value_size + " at offset " + entry_offset + " is too large.");
         return false;
       }
     } else {
@@ -375,8 +381,7 @@ public class LoadedArsc {
     final List<DynamicPackageEntry> dynamic_package_map_ = new ArrayList<>();
     final Map<Integer, Integer> aliasIdMap = new HashMap<>();
 
-    ResTable_entry GetEntry(ResTable_type type_chunk,
-        short entry_index) {
+    ResTable_entry GetEntry(ResTable_type type_chunk, short entry_index) {
       int entry_offset = GetEntryOffset(type_chunk, entry_index);
       if (entry_offset == ResTable_type.NO_ENTRY) {
         return null;
@@ -438,19 +443,17 @@ public class LoadedArsc {
       return dtohl(type_chunk.entryOffset(entry_index));
     }
 
-    static ResTable_entry GetEntryFromOffset(ResTable_type type_chunk,
-        int offset) {
+    static ResTable_entry GetEntryFromOffset(ResTable_type type_chunk, int offset) {
       if (UNLIKELY(!VerifyResTableEntry(type_chunk, offset))) {
         return null;
       }
       // return reinterpret_cast<ResTable_entry*>(reinterpret_cast<uint8_t*>(type_chunk) +
       //     offset + dtohl(type_chunk.entriesStart));
-      return new ResTable_entry(type_chunk.myBuf(),
-          type_chunk.myOffset() + offset + dtohl(type_chunk.entriesStart));
+      return new ResTable_entry(
+          type_chunk.myBuf(), type_chunk.myOffset() + offset + dtohl(type_chunk.entriesStart));
     }
 
-    void CollectConfigurations(boolean exclude_mipmap,
-        Set<ResTable_config> out_configs) {
+    void CollectConfigurations(boolean exclude_mipmap, Set<ResTable_config> out_configs) {
       String kMipMap = "mipmap";
       int type_count = type_specs_.size();
       for (int i = 0; i < type_count; i++) {
@@ -600,9 +603,8 @@ public class LoadedArsc {
       return 0;
     }
 
-    static LoadedPackage Load(Chunk chunk,
-        LoadedIdmap loaded_idmap,
-        boolean system, boolean load_as_shared_library) {
+    static LoadedPackage Load(
+        Chunk chunk, LoadedIdmap loaded_idmap, boolean system, boolean load_as_shared_library) {
       // ATRACE_NAME("LoadedPackage::Load");
       LoadedPackage loaded_package = new LoadedPackage();
 
@@ -621,8 +623,8 @@ public class LoadedArsc {
       loaded_package.system_ = system;
 
       loaded_package.package_id_ = dtohl(header.id);
-      if (loaded_package.package_id_ == 0 ||
-          (loaded_package.package_id_ == kAppPackageId && load_as_shared_library)) {
+      if (loaded_package.package_id_ == 0
+          || (loaded_package.package_id_ == kAppPackageId && load_as_shared_library)) {
         // Package ID of 0 means this is a shared library.
         loaded_package.dynamic_ = true;
       }
@@ -643,11 +645,12 @@ public class LoadedArsc {
         loaded_package.type_id_offset_ = type_id_offset;
       }
 
-      loaded_package.package_name_ = Util
-          .ReadUtf16StringFromDevice(header.name, header.name.length);
+      loaded_package.package_name_ =
+          Util.ReadUtf16StringFromDevice(header.name, header.name.length);
 
       // A map of TypeSpec builders, each associated with an type index.
-      // We use these to accumulate the set of Types available for a TypeSpec, and later build a single,
+      // We use these to accumulate the set of Types available for a TypeSpec, and later build a
+      // single,
       // contiguous block of memory that holds all the Types together with the TypeSpec.
       Map<Integer, TypeSpecPtrBuilder> type_builder_map = new HashMap<>();
 
@@ -655,158 +658,169 @@ public class LoadedArsc {
       while (iter.HasNext()) {
         Chunk child_chunk = iter.Next();
         switch (child_chunk.type()) {
-          case RES_STRING_POOL_TYPE: {
-            // uintptr_t pool_address =
-            //     reinterpret_cast<uintptr_t>(child_chunk.header<ResChunk_header>());
-            // uintptr_t header_address = reinterpret_cast<uintptr_t>(header);
-            int pool_address =
-                child_chunk.myOffset();
-            int header_address = header.myOffset();
-            if (pool_address == header_address + dtohl(header.typeStrings)) {
-              // This string pool is the type string pool.
-              int err = loaded_package.type_string_pool_.setTo(
-                  child_chunk.myBuf(), child_chunk.myOffset(), child_chunk.size(), false);
-              if (err != NO_ERROR) {
-                logError("RES_STRING_POOL_TYPE for types corrupt.");
+          case RES_STRING_POOL_TYPE:
+            {
+              // uintptr_t pool_address =
+              //     reinterpret_cast<uintptr_t>(child_chunk.header<ResChunk_header>());
+              // uintptr_t header_address = reinterpret_cast<uintptr_t>(header);
+              int pool_address = child_chunk.myOffset();
+              int header_address = header.myOffset();
+              if (pool_address == header_address + dtohl(header.typeStrings)) {
+                // This string pool is the type string pool.
+                int err =
+                    loaded_package.type_string_pool_.setTo(
+                        child_chunk.myBuf(), child_chunk.myOffset(), child_chunk.size(), false);
+                if (err != NO_ERROR) {
+                  logError("RES_STRING_POOL_TYPE for types corrupt.");
+                  return emptyBraces();
+                }
+              } else if (pool_address == header_address + dtohl(header.keyStrings)) {
+                // This string pool is the key string pool.
+                int err =
+                    loaded_package.key_string_pool_.setTo(
+                        child_chunk.myBuf(), child_chunk.myOffset(), child_chunk.size(), false);
+                if (err != NO_ERROR) {
+                  logError("RES_STRING_POOL_TYPE for keys corrupt.");
+                  return emptyBraces();
+                }
+              } else {
+                logWarning("Too many RES_STRING_POOL_TYPEs found in RES_TABLE_PACKAGE_TYPE.");
+              }
+            }
+            break;
+
+          case RES_TABLE_TYPE_SPEC_TYPE:
+            {
+              ResTable_typeSpec type_spec =
+                  new ResTable_typeSpec(child_chunk.myBuf(), child_chunk.myOffset());
+              if (type_spec == null) {
+                logError("RES_TABLE_TYPE_SPEC_TYPE too small.");
                 return emptyBraces();
               }
-            } else if (pool_address == header_address + dtohl(header.keyStrings)) {
-              // This string pool is the key string pool.
-              int err = loaded_package.key_string_pool_.setTo(
-                  child_chunk.myBuf(), child_chunk.myOffset(), child_chunk.size(), false);
-              if (err != NO_ERROR) {
-                logError("RES_STRING_POOL_TYPE for keys corrupt.");
+
+              if (type_spec.id == 0) {
+                logError("RES_TABLE_TYPE_SPEC_TYPE has invalid ID 0.");
                 return emptyBraces();
               }
-            } else {
-              logWarning("Too many RES_STRING_POOL_TYPEs found in RES_TABLE_PACKAGE_TYPE.");
-            }
-          } break;
-
-          case RES_TABLE_TYPE_SPEC_TYPE: {
-            ResTable_typeSpec type_spec = new ResTable_typeSpec(child_chunk.myBuf(),
-                child_chunk.myOffset());
-            if (type_spec == null) {
-              logError("RES_TABLE_TYPE_SPEC_TYPE too small.");
-              return emptyBraces();
-            }
 
-            if (type_spec.id == 0) {
-              logError("RES_TABLE_TYPE_SPEC_TYPE has invalid ID 0.");
-              return emptyBraces();
-            }
+              // if (loaded_package.type_id_offset_ + static_cast<int>(type_spec.id) >
+              //     std.numeric_limits<uint8_t>.max()) {
+              if (loaded_package.type_id_offset_ + type_spec.id > 255) {
+                logError("RES_TABLE_TYPE_SPEC_TYPE has out of range ID.");
+                return emptyBraces();
+              }
 
-            // if (loaded_package.type_id_offset_ + static_cast<int>(type_spec.id) >
-            //     std.numeric_limits<uint8_t>.max()) {
-            if (loaded_package.type_id_offset_ + type_spec.id > 255) {
-              logError("RES_TABLE_TYPE_SPEC_TYPE has out of range ID.");
-              return emptyBraces();
-            }
+              // The data portion of this chunk contains entry_count 32bit entries,
+              // each one representing a set of flags.
+              // Here we only validate that the chunk is well formed.
+              int entry_count = dtohl(type_spec.entryCount);
 
-            // The data portion of this chunk contains entry_count 32bit entries,
-            // each one representing a set of flags.
-            // Here we only validate that the chunk is well formed.
-            int entry_count = dtohl(type_spec.entryCount);
-
-            // There can only be 2^16 entries in a type, because that is the ID
-            // space for entries (EEEE) in the resource ID 0xPPTTEEEE.
-            // if (entry_count > std.numeric_limits<short>.max()) {
-            if (entry_count > 0xffff) {
-              logError("RES_TABLE_TYPE_SPEC_TYPE has too many entries (" + entry_count + ").");
-              return emptyBraces();
-            }
+              // There can only be 2^16 entries in a type, because that is the ID
+              // space for entries (EEEE) in the resource ID 0xPPTTEEEE.
+              // if (entry_count > std.numeric_limits<short>.max()) {
+              if (entry_count > 0xffff) {
+                logError("RES_TABLE_TYPE_SPEC_TYPE has too many entries (" + entry_count + ").");
+                return emptyBraces();
+              }
 
-            if (entry_count * 4 /*sizeof(int)*/ > chunk.data_size()) {
-              logError("RES_TABLE_TYPE_SPEC_TYPE too small to hold entries.");
-              return emptyBraces();
-            }
+              if (entry_count * 4 /*sizeof(int)*/ > chunk.data_size()) {
+                logError("RES_TABLE_TYPE_SPEC_TYPE too small to hold entries.");
+                return emptyBraces();
+              }
 
-            // If this is an overlay, associate the mapping of this type to the target type
-            // from the IDMAP.
-            IdmapEntry_header idmap_entry_header = null;
-            if (loaded_idmap != null) {
-              idmap_entry_header = loaded_idmap.GetEntryMapForType(type_spec.id);
-            }
+              // If this is an overlay, associate the mapping of this type to the target type
+              // from the IDMAP.
+              IdmapEntry_header idmap_entry_header = null;
+              if (loaded_idmap != null) {
+                idmap_entry_header = loaded_idmap.GetEntryMapForType(type_spec.id);
+              }
 
-            TypeSpecPtrBuilder builder_ptr = type_builder_map.get(type_spec.id - 1);
-            if (builder_ptr == null) {
-              // builder_ptr = util.make_unique<TypeSpecPtrBuilder>(type_spec, idmap_entry_header);
-              builder_ptr = new TypeSpecPtrBuilder(type_spec, idmap_entry_header);
-              type_builder_map.put(type_spec.id - 1, builder_ptr);
-            } else {
-              logWarning(String.format("RES_TABLE_TYPE_SPEC_TYPE already defined for ID %02x",
-                  type_spec.id));
-            }
-          } break;
-
-          case RES_TABLE_TYPE_TYPE: {
-            // ResTable_type type = child_chunk.header<ResTable_type, kResTableTypeMinSize>();
-            ResTable_type type = child_chunk.asResTable_type(kResTableTypeMinSize);
-            if (type == null) {
-              logError("RES_TABLE_TYPE_TYPE too small.");
-              return emptyBraces();
+              TypeSpecPtrBuilder builder_ptr = type_builder_map.get(type_spec.id - 1);
+              if (builder_ptr == null) {
+                // builder_ptr = util.make_unique<TypeSpecPtrBuilder>(type_spec,
+                // idmap_entry_header);
+                builder_ptr = new TypeSpecPtrBuilder(type_spec, idmap_entry_header);
+                type_builder_map.put(type_spec.id - 1, builder_ptr);
+              } else {
+                logWarning(
+                    String.format(
+                        "RES_TABLE_TYPE_SPEC_TYPE already defined for ID %02x", type_spec.id));
+              }
             }
+            break;
 
-            if (!VerifyResTableType(type)) {
-              return emptyBraces();
-            }
+          case RES_TABLE_TYPE_TYPE:
+            {
+              // ResTable_type type = child_chunk.header<ResTable_type, kResTableTypeMinSize>();
+              ResTable_type type = child_chunk.asResTable_type(kResTableTypeMinSize);
+              if (type == null) {
+                logError("RES_TABLE_TYPE_TYPE too small.");
+                return emptyBraces();
+              }
 
-            // Type chunks must be preceded by their TypeSpec chunks.
-            TypeSpecPtrBuilder builder_ptr = type_builder_map.get(type.id - 1);
-            if (builder_ptr != null) {
-              builder_ptr.AddType(type);
-            } else {
+              if (!VerifyResTableType(type)) {
+                return emptyBraces();
+              }
+
+              // Type chunks must be preceded by their TypeSpec chunks.
+              TypeSpecPtrBuilder builder_ptr = type_builder_map.get(type.id - 1);
+              if (builder_ptr != null) {
+                builder_ptr.AddType(type);
+              } else {
                 logError(
                     String.format(
                         "RES_TABLE_TYPE_TYPE with ID %02x found without preceding"
                             + " RES_TABLE_TYPE_SPEC_TYPE.",
                         type.id));
-              return emptyBraces();
-            }
-          } break;
-
-          case RES_TABLE_LIBRARY_TYPE: {
-            ResTable_lib_header lib = child_chunk.asResTable_lib_header();
-            if (lib == null) {
-              logError("RES_TABLE_LIBRARY_TYPE too small.");
-              return emptyBraces();
+                return emptyBraces();
+              }
             }
+            break;
 
-            if (child_chunk.data_size() / ResTable_lib_entry.SIZEOF < dtohl(lib.count)) {
-              logError("RES_TABLE_LIBRARY_TYPE too small to hold entries.");
-              return emptyBraces();
-            }
+          case RES_TABLE_LIBRARY_TYPE:
+            {
+              ResTable_lib_header lib = child_chunk.asResTable_lib_header();
+              if (lib == null) {
+                logError("RES_TABLE_LIBRARY_TYPE too small.");
+                return emptyBraces();
+              }
 
-            // loaded_package.dynamic_package_map_.reserve(dtohl(lib.count));
-
-            // ResTable_lib_entry entryBegin =
-            //     reinterpret_cast<ResTable_lib_entry*>(child_chunk.data_ptr());
-            ResTable_lib_entry entryBegin =
-                child_chunk.asResTable_lib_entry();
-            // ResTable_lib_entry entry_end = entryBegin + dtohl(lib.count);
-            // for (auto entryIter = entryBegin; entryIter != entry_end; ++entryIter) {
-            for (ResTable_lib_entry entryIter = entryBegin;
-                entryIter.myOffset() != entryBegin.myOffset() + dtohl(lib.count);
-                entryIter = new ResTable_lib_entry(
-                    entryIter.myBuf(), entryIter.myOffset() + ResTable_lib_entry.SIZEOF)) {
-              String package_name =
-                  Util.ReadUtf16StringFromDevice(entryIter.packageName,
-                      entryIter.packageName.length);
-              
-              if (dtohl(entryIter.packageId) >= 255) {
-                logError(String.format(
-                    "Package ID %02x in RES_TABLE_LIBRARY_TYPE too large for package '%s'.",
-                    dtohl(entryIter.packageId), package_name));
+              if (child_chunk.data_size() / ResTable_lib_entry.SIZEOF < dtohl(lib.count)) {
+                logError("RES_TABLE_LIBRARY_TYPE too small to hold entries.");
                 return emptyBraces();
               }
 
-              // loaded_package.dynamic_package_map_.emplace_back(std.move(package_name),
-              //     dtohl(entryIter.packageId));
-              loaded_package.dynamic_package_map_.add(new DynamicPackageEntry(package_name,
-                  dtohl(entryIter.packageId)));
-            }
+              // loaded_package.dynamic_package_map_.reserve(dtohl(lib.count));
 
-          } break;
+              // ResTable_lib_entry entryBegin =
+              //     reinterpret_cast<ResTable_lib_entry*>(child_chunk.data_ptr());
+              ResTable_lib_entry entryBegin = child_chunk.asResTable_lib_entry();
+              // ResTable_lib_entry entry_end = entryBegin + dtohl(lib.count);
+              // for (auto entryIter = entryBegin; entryIter != entry_end; ++entryIter) {
+              for (ResTable_lib_entry entryIter = entryBegin;
+                  entryIter.myOffset() != entryBegin.myOffset() + dtohl(lib.count);
+                  entryIter =
+                      new ResTable_lib_entry(
+                          entryIter.myBuf(), entryIter.myOffset() + ResTable_lib_entry.SIZEOF)) {
+                String package_name =
+                    Util.ReadUtf16StringFromDevice(
+                        entryIter.packageName, entryIter.packageName.length);
+
+                if (dtohl(entryIter.packageId) >= 255) {
+                  logError(
+                      String.format(
+                          "Package ID %02x in RES_TABLE_LIBRARY_TYPE too large for package '%s'.",
+                          dtohl(entryIter.packageId), package_name));
+                  return emptyBraces();
+                }
+
+                // loaded_package.dynamic_package_map_.emplace_back(std.move(package_name),
+                //     dtohl(entryIter.packageId));
+                loaded_package.dynamic_package_map_.add(
+                    new DynamicPackageEntry(package_name, dtohl(entryIter.packageId)));
+              }
+            }
+            break;
 
           case RES_TABLE_STAGED_ALIAS_TYPE:
             {
@@ -834,8 +848,7 @@ public class LoadedArsc {
               // const auto entry_end = entryBegin + dtohl(libAlias.count);
               ResTableStagedAliasEntry entryBegin = child_chunk.asResTableStagedAliasEntry();
               int entryEndOffset =
-                  entryBegin.myOffset()
-                      + dtohl(libAlias.count) * ResTableStagedAliasEntry.SIZEOF;
+                  entryBegin.myOffset() + dtohl(libAlias.count) * ResTableStagedAliasEntry.SIZEOF;
               // std::unordered_set<uint32_t> finalizedIds;
               // finalizedIds.reserve(entry_end - entryBegin);
               Set<Integer> finalizedIds = new HashSet<>();
@@ -851,8 +864,7 @@ public class LoadedArsc {
                 if (!finalizedIds.add(finalizedId)) {
                   logError(
                       String.format(
-                          "Repeated finalized resource id '%08x' in staged aliases.",
-                          finalizedId));
+                          "Repeated finalized resource id '%08x' in staged aliases.", finalizedId));
                   return emptyBraces();
                 }
 
@@ -950,7 +962,8 @@ public class LoadedArsc {
 
     // type_idx is TT - 1 from 0xPPTTEEEE.
     TypeSpec GetTypeSpecByTypeIndex(int type_index) {
-      // If the type IDs are offset in this package, we need to take that into account when searching
+      // If the type IDs are offset in this package, we need to take that into account when
+      // searching
       // for a type.
       return type_specs_.get(type_index - type_id_offset_);
     }
@@ -993,8 +1006,7 @@ public class LoadedArsc {
     return null;
   }
 
-  boolean LoadTable(Chunk chunk, LoadedIdmap loaded_idmap,
-      boolean load_as_shared_library) {
+  boolean LoadTable(Chunk chunk, LoadedIdmap loaded_idmap, boolean load_as_shared_library) {
     // ResTable_header header = chunk.header<ResTable_header>();
     ResTable_header header = chunk.asResTable_header();
     if (header == null) {
@@ -1015,9 +1027,12 @@ public class LoadedArsc {
           // Only use the first string pool. Ignore others.
           if (global_string_pool_.getError() == NO_INIT) {
             ResStringPool_header resStringPool_header = child_chunk.asResStringPool_header();
-            int err = global_string_pool_.setTo(resStringPool_header.myBuf(),
-                resStringPool_header.myOffset(),
-                child_chunk.size(), false);
+            int err =
+                global_string_pool_.setTo(
+                    resStringPool_header.myBuf(),
+                    resStringPool_header.myOffset(),
+                    child_chunk.size(),
+                    false);
             if (err != NO_ERROR) {
               logError("RES_STRING_POOL_TYPE corrupt.");
               return false;
@@ -1027,21 +1042,25 @@ public class LoadedArsc {
           }
           break;
 
-        case RES_TABLE_PACKAGE_TYPE: {
-          if (packages_seen + 1 > package_count) {
-            logError("More package chunks were found than the " + package_count
-                + " declared in the header.");
-            return false;
-          }
-          packages_seen++;
+        case RES_TABLE_PACKAGE_TYPE:
+          {
+            if (packages_seen + 1 > package_count) {
+              logError(
+                  "More package chunks were found than the "
+                      + package_count
+                      + " declared in the header.");
+              return false;
+            }
+            packages_seen++;
 
-          LoadedPackage loaded_package =
-              LoadedPackage.Load(child_chunk, loaded_idmap, system_, load_as_shared_library);
-          if (!isTruthy(loaded_package)) {
-            return false;
+            LoadedPackage loaded_package =
+                LoadedPackage.Load(child_chunk, loaded_idmap, system_, load_as_shared_library);
+            if (!isTruthy(loaded_package)) {
+              return false;
+            }
+            packages_.add(loaded_package);
           }
-          packages_.add(loaded_package);
-        } break;
+          break;
 
         default:
           logWarning(String.format("Unknown chunk type '%02x'.", chunk.type()));
@@ -1059,17 +1078,19 @@ public class LoadedArsc {
   }
 
   // Read-only view into a resource table. This class validates all data
-// when loading, including offsets and lengths.
-//class LoadedArsc {
-// public:
+  // when loading, including offsets and lengths.
+  // class LoadedArsc {
+  // public:
   // Load a resource table from memory pointed to by `data` of size `len`.
   // The lifetime of `data` must out-live the LoadedArsc returned from this method.
   // If `system` is set to true, the LoadedArsc is considered as a system provided resource.
   // If `load_as_shared_library` is set to true, the application package (0x7f) is treated
   // as a shared library (0x00). When loaded into an AssetManager, the package will be assigned an
   // ID.
-  static LoadedArsc Load(StringPiece data,
-      LoadedIdmap loaded_idmap /* = null */, boolean system /* = false */,
+  static LoadedArsc Load(
+      StringPiece data,
+      LoadedIdmap loaded_idmap /* = null */,
+      boolean system /* = false */,
       boolean load_as_shared_library /* = false */) {
     // ATRACE_NAME("LoadedArsc::LoadTable");
 
@@ -1122,5 +1143,4 @@ public class LoadedArsc {
   private static LoadedArsc emptyBraces() {
     return new LoadedArsc();
   }
-
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/LocaleData.java b/resources/src/main/java/org/robolectric/res/android/LocaleData.java
index 359b6434a..4ec1be9d2 100644
--- a/resources/src/main/java/org/robolectric/res/android/LocaleData.java
+++ b/resources/src/main/java/org/robolectric/res/android/LocaleData.java
@@ -9,12 +9,15 @@ import static org.robolectric.res.android.LocaleDataTables.SCRIPT_PARENTS;
 import java.util.Arrays;
 import java.util.Map;
 
-// transliterated from https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/LocaleData.cpp
+// transliterated from
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/LocaleData.cpp
 public class LocaleData {
 
   private static int packLocale(final byte[] language, final byte[] region) {
-    return ((language[0] & 0xff) << 24) | ((language[1] & 0xff) << 16) |
-        ((region[0] & 0xff) << 8) | (region[1] & 0xff);
+    return ((language[0] & 0xff) << 24)
+        | ((language[1] & 0xff) << 16)
+        | ((region[0] & 0xff) << 8)
+        | (region[1] & 0xff);
   }
 
   private static int dropRegion(int packed_locale) {
@@ -57,9 +60,13 @@ public class LocaleData {
   //
   // (If 'out' is null, we do everything the same way but we simply don't write
   // any results in 'out'.)
-  static int findAncestors(int[] out, Ref<Long> stop_list_index,
-      int packed_locale, final String script,
-      final int[] stop_list, int stop_set_length) {
+  static int findAncestors(
+      int[] out,
+      Ref<Long> stop_list_index,
+      int packed_locale,
+      final String script,
+      final int[] stop_list,
+      int stop_set_length) {
     int ancestor = packed_locale;
     int count = 0;
     do {
@@ -79,15 +86,20 @@ public class LocaleData {
     return count;
   }
 
-  static int findDistance(int supported,
+  static int findDistance(
+      int supported,
       final String script,
       final int[] request_ancestors,
       int request_ancestors_count) {
     final Ref<Long> request_ancestors_indexRef = new Ref<>(null);
-    final int supported_ancestor_count = findAncestors(
-        null, request_ancestors_indexRef,
-        supported, script,
-        request_ancestors, request_ancestors_count);
+    final int supported_ancestor_count =
+        findAncestors(
+            null,
+            request_ancestors_indexRef,
+            supported,
+            script,
+            request_ancestors,
+            request_ancestors_count);
     // Since both locales share the same root, there will always be a shared
     // ancestor, so the distance in the parent tree is the sum of the distance
     // of 'supported' to the lowest common ancestor (number of ancestors
@@ -97,12 +109,12 @@ public class LocaleData {
   }
 
   static boolean isRepresentative(int language_and_region, final String script) {
-    final long packed_locale = (
-        (((long) language_and_region) << 32) |
-            (((long) script.charAt(0) & 0xff) << 24) |
-            (((long) script.charAt(1) & 0xff) << 16) |
-            (((long) script.charAt(2) & 0xff) << 8) |
-            ((long) script.charAt(3) & 0xff));
+    final long packed_locale =
+        ((((long) language_and_region) << 32)
+            | (((long) script.charAt(0) & 0xff) << 24)
+            | (((long) script.charAt(1) & 0xff) << 16)
+            | (((long) script.charAt(2) & 0xff) << 8)
+            | ((long) script.charAt(3) & 0xff));
     return REPRESENTATIVE_LOCALES.contains(packed_locale);
   }
 
@@ -111,14 +123,16 @@ public class LocaleData {
   private static final int LATIN_AMERICAN_SPANISH = 0x6573A424; // es-419
 
   // The two locales es-US and es-MX are treated as special fallbacks for es-419.
-// If there is no es-419, they are considered its equivalent.
+  // If there is no es-419, they are considered its equivalent.
   private static boolean isSpecialSpanish(int language_and_region) {
     return (language_and_region == US_SPANISH || language_and_region == MEXICAN_SPANISH);
   }
 
   static int localeDataCompareRegions(
-      final byte[] left_region, final byte[] right_region,
-      final byte[] requested_language, final String requested_script,
+      final byte[] left_region,
+      final byte[] right_region,
+      final byte[] requested_language,
+      final String requested_script,
       final byte[] requested_region) {
     if (left_region[0] == right_region[0] && left_region[1] == right_region[1]) {
       return 0;
@@ -143,10 +157,11 @@ public class LocaleData {
     final Ref<Long> left_right_indexRef = new Ref<Long>(null);
     // Find the parents of the request, but stop as soon as we saw left or right
     final int left_and_right[] = {left, right};
-    final int ancestor_count = findAncestors(
-        request_ancestors, left_right_indexRef,
-        request, requested_script,
-        left_and_right, sizeof(left_and_right));
+    final int ancestor_count =
+        findAncestors(
+            request_ancestors, left_right_indexRef,
+            request, requested_script,
+            left_and_right, sizeof(left_and_right));
     if (left_right_indexRef.get() == 0) { // We saw left earlier
       return 1;
     }
@@ -157,10 +172,10 @@ public class LocaleData {
     // request. This means that all the ancestors have been computed and
     // the last ancestor is just the language by itself. We will use the
     // distance in the parent tree for determining the better match.
-    final int left_distance = findDistance(
-        left, requested_script, request_ancestors, ancestor_count);
-    final int right_distance = findDistance(
-        right, requested_script, request_ancestors, ancestor_count);
+    final int left_distance =
+        findDistance(left, requested_script, request_ancestors, ancestor_count);
+    final int right_distance =
+        findDistance(right, requested_script, request_ancestors, ancestor_count);
     if (left_distance != right_distance) {
       return (int) right_distance - (int) left_distance; // smaller distance is better
     }
@@ -180,7 +195,7 @@ public class LocaleData {
 
   static void localeDataComputeScript(byte[] out, final byte[] language, final byte[] region) {
     if (language[0] == '\0') {
-//      memset(out, '\0', SCRIPT_LENGTH);
+      //      memset(out, '\0', SCRIPT_LENGTH);
       Arrays.fill(out, (byte) 0);
       return;
     }
@@ -192,25 +207,25 @@ public class LocaleData {
         lookup_key = dropRegion(lookup_key);
         lookup_result = LIKELY_SCRIPTS.get(lookup_key);
         if (lookup_result != null) {
-//          memcpy(out, SCRIPT_CODES[lookup_result.second], SCRIPT_LENGTH);
+          //          memcpy(out, SCRIPT_CODES[lookup_result.second], SCRIPT_LENGTH);
           System.arraycopy(SCRIPT_CODES[lookup_result], 0, out, 0, SCRIPT_LENGTH);
           return;
         }
       }
       // We don't know anything about the locale
-//      memset(out, '\0', SCRIPT_LENGTH);
+      //      memset(out, '\0', SCRIPT_LENGTH);
       Arrays.fill(out, (byte) 0);
       return;
     } else {
       // We found the locale.
-//      memcpy(out, SCRIPT_CODES[lookup_result.second], SCRIPT_LENGTH);
+      //      memcpy(out, SCRIPT_CODES[lookup_result.second], SCRIPT_LENGTH);
       System.arraycopy(SCRIPT_CODES[lookup_result], 0, out, 0, SCRIPT_LENGTH);
     }
   }
 
   static final int[] ENGLISH_STOP_LIST = {
-      0x656E0000, // en
-      0x656E8400, // en-001
+    0x656E0000, // en
+    0x656E8400, // en-001
   };
 
   static final byte[] ENGLISH_CHARS = {'e', 'n'};
@@ -225,9 +240,7 @@ public class LocaleData {
     return stop_list_indexRef.get() == 0; // 'en' is first in ENGLISH_STOP_LIST
   }
 
-
   private static int sizeof(int[] array) {
     return array.length;
   }
-
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/LocaleDataTables.java b/resources/src/main/java/org/robolectric/res/android/LocaleDataTables.java
index 56c2e6240..cbbc3557c 100644
--- a/resources/src/main/java/org/robolectric/res/android/LocaleDataTables.java
+++ b/resources/src/main/java/org/robolectric/res/android/LocaleDataTables.java
@@ -6,7 +6,8 @@ import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
-// transliterated from https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/LocaleDataTables.cpp
+// transliterated from
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/LocaleDataTables.cpp
 public class LocaleDataTables {
 
   // Auto-generated by ./tools/localedata/extract_icu_data.py
@@ -106,1355 +107,1355 @@ public class LocaleDataTables {
 
   static {
     int[][] entries = {
-        {0x61610000, 40}, // aa -> Latn
-        {0xA0000000, 40}, // aai -> Latn
-        {0xA8000000, 40}, // aak -> Latn
-        {0xD0000000, 40}, // aau -> Latn
-        {0x61620000, 15}, // ab -> Cyrl
-        {0xA0200000, 40}, // abi -> Latn
-        {0xC4200000, 40}, // abr -> Latn
-        {0xCC200000, 40}, // abt -> Latn
-        {0xE0200000, 40}, // aby -> Latn
-        {0x8C400000, 40}, // acd -> Latn
-        {0x90400000, 40}, // ace -> Latn
-        {0x9C400000, 40}, // ach -> Latn
-        {0x80600000, 40}, // ada -> Latn
-        {0x90600000, 40}, // ade -> Latn
-        {0xA4600000, 40}, // adj -> Latn
-        {0xE0600000, 15}, // ady -> Cyrl
-        {0xE4600000, 40}, // adz -> Latn
-        {0x61650000,  4}, // ae -> Avst
-        {0x84800000,  1}, // aeb -> Arab
-        {0xE0800000, 40}, // aey -> Latn
-        {0x61660000, 40}, // af -> Latn
-        {0x88C00000, 40}, // agc -> Latn
-        {0x8CC00000, 40}, // agd -> Latn
-        {0x98C00000, 40}, // agg -> Latn
-        {0xB0C00000, 40}, // agm -> Latn
-        {0xB8C00000, 40}, // ago -> Latn
-        {0xC0C00000, 40}, // agq -> Latn
-        {0x80E00000, 40}, // aha -> Latn
-        {0xACE00000, 40}, // ahl -> Latn
-        {0xB8E00000,  0}, // aho -> Ahom
-        {0x99200000, 40}, // ajg -> Latn
-        {0x616B0000, 40}, // ak -> Latn
-        {0xA9400000, 85}, // akk -> Xsux
-        {0x81600000, 40}, // ala -> Latn
-        {0xA1600000, 40}, // ali -> Latn
-        {0xB5600000, 40}, // aln -> Latn
-        {0xCD600000, 15}, // alt -> Cyrl
-        {0x616D0000, 18}, // am -> Ethi
-        {0xB1800000, 40}, // amm -> Latn
-        {0xB5800000, 40}, // amn -> Latn
-        {0xB9800000, 40}, // amo -> Latn
-        {0xBD800000, 40}, // amp -> Latn
-        {0x89A00000, 40}, // anc -> Latn
-        {0xA9A00000, 40}, // ank -> Latn
-        {0xB5A00000, 40}, // ann -> Latn
-        {0xE1A00000, 40}, // any -> Latn
-        {0xA5C00000, 40}, // aoj -> Latn
-        {0xB1C00000, 40}, // aom -> Latn
-        {0xE5C00000, 40}, // aoz -> Latn
-        {0x89E00000,  1}, // apc -> Arab
-        {0x8DE00000,  1}, // apd -> Arab
-        {0x91E00000, 40}, // ape -> Latn
-        {0xC5E00000, 40}, // apr -> Latn
-        {0xC9E00000, 40}, // aps -> Latn
-        {0xE5E00000, 40}, // apz -> Latn
-        {0x61720000,  1}, // ar -> Arab
-        {0x61725842, 88}, // ar-XB -> ~~~B
-        {0x8A200000,  2}, // arc -> Armi
-        {0x9E200000, 40}, // arh -> Latn
-        {0xB6200000, 40}, // arn -> Latn
-        {0xBA200000, 40}, // aro -> Latn
-        {0xC2200000,  1}, // arq -> Arab
-        {0xE2200000,  1}, // ary -> Arab
-        {0xE6200000,  1}, // arz -> Arab
-        {0x61730000,  7}, // as -> Beng
-        {0x82400000, 40}, // asa -> Latn
-        {0x92400000, 68}, // ase -> Sgnw
-        {0x9A400000, 40}, // asg -> Latn
-        {0xBA400000, 40}, // aso -> Latn
-        {0xCE400000, 40}, // ast -> Latn
-        {0x82600000, 40}, // ata -> Latn
-        {0x9A600000, 40}, // atg -> Latn
-        {0xA6600000, 40}, // atj -> Latn
-        {0xE2800000, 40}, // auy -> Latn
-        {0x61760000, 15}, // av -> Cyrl
-        {0xAEA00000,  1}, // avl -> Arab
-        {0xB6A00000, 40}, // avn -> Latn
-        {0xCEA00000, 40}, // avt -> Latn
-        {0xD2A00000, 40}, // avu -> Latn
-        {0x82C00000, 16}, // awa -> Deva
-        {0x86C00000, 40}, // awb -> Latn
-        {0xBAC00000, 40}, // awo -> Latn
-        {0xDEC00000, 40}, // awx -> Latn
-        {0x61790000, 40}, // ay -> Latn
-        {0x87000000, 40}, // ayb -> Latn
-        {0x617A0000, 40}, // az -> Latn
-        {0x617A4951,  1}, // az-IQ -> Arab
-        {0x617A4952,  1}, // az-IR -> Arab
-        {0x617A5255, 15}, // az-RU -> Cyrl
-        {0x62610000, 15}, // ba -> Cyrl
-        {0xAC010000,  1}, // bal -> Arab
-        {0xB4010000, 40}, // ban -> Latn
-        {0xBC010000, 16}, // bap -> Deva
-        {0xC4010000, 40}, // bar -> Latn
-        {0xC8010000, 40}, // bas -> Latn
-        {0xD4010000, 40}, // bav -> Latn
-        {0xDC010000,  5}, // bax -> Bamu
-        {0x80210000, 40}, // bba -> Latn
-        {0x84210000, 40}, // bbb -> Latn
-        {0x88210000, 40}, // bbc -> Latn
-        {0x8C210000, 40}, // bbd -> Latn
-        {0xA4210000, 40}, // bbj -> Latn
-        {0xBC210000, 40}, // bbp -> Latn
-        {0xC4210000, 40}, // bbr -> Latn
-        {0x94410000, 40}, // bcf -> Latn
-        {0x9C410000, 40}, // bch -> Latn
-        {0xA0410000, 40}, // bci -> Latn
-        {0xB0410000, 40}, // bcm -> Latn
-        {0xB4410000, 40}, // bcn -> Latn
-        {0xB8410000, 40}, // bco -> Latn
-        {0xC0410000, 18}, // bcq -> Ethi
-        {0xD0410000, 40}, // bcu -> Latn
-        {0x8C610000, 40}, // bdd -> Latn
-        {0x62650000, 15}, // be -> Cyrl
-        {0x94810000, 40}, // bef -> Latn
-        {0x9C810000, 40}, // beh -> Latn
-        {0xA4810000,  1}, // bej -> Arab
-        {0xB0810000, 40}, // bem -> Latn
-        {0xCC810000, 40}, // bet -> Latn
-        {0xD8810000, 40}, // bew -> Latn
-        {0xDC810000, 40}, // bex -> Latn
-        {0xE4810000, 40}, // bez -> Latn
-        {0x8CA10000, 40}, // bfd -> Latn
-        {0xC0A10000, 74}, // bfq -> Taml
-        {0xCCA10000,  1}, // bft -> Arab
-        {0xE0A10000, 16}, // bfy -> Deva
-        {0x62670000, 15}, // bg -> Cyrl
-        {0x88C10000, 16}, // bgc -> Deva
-        {0xB4C10000,  1}, // bgn -> Arab
-        {0xDCC10000, 21}, // bgx -> Grek
-        {0x84E10000, 16}, // bhb -> Deva
-        {0x98E10000, 40}, // bhg -> Latn
-        {0xA0E10000, 16}, // bhi -> Deva
-        {0xA8E10000, 40}, // bhk -> Latn
-        {0xACE10000, 40}, // bhl -> Latn
-        {0xB8E10000, 16}, // bho -> Deva
-        {0xE0E10000, 40}, // bhy -> Latn
-        {0x62690000, 40}, // bi -> Latn
-        {0x85010000, 40}, // bib -> Latn
-        {0x99010000, 40}, // big -> Latn
-        {0xA9010000, 40}, // bik -> Latn
-        {0xB1010000, 40}, // bim -> Latn
-        {0xB5010000, 40}, // bin -> Latn
-        {0xB9010000, 40}, // bio -> Latn
-        {0xC1010000, 40}, // biq -> Latn
-        {0x9D210000, 40}, // bjh -> Latn
-        {0xA1210000, 18}, // bji -> Ethi
-        {0xA5210000, 16}, // bjj -> Deva
-        {0xB5210000, 40}, // bjn -> Latn
-        {0xB9210000, 40}, // bjo -> Latn
-        {0xC5210000, 40}, // bjr -> Latn
-        {0xE5210000, 40}, // bjz -> Latn
-        {0x89410000, 40}, // bkc -> Latn
-        {0xB1410000, 40}, // bkm -> Latn
-        {0xC1410000, 40}, // bkq -> Latn
-        {0xD1410000, 40}, // bku -> Latn
-        {0xD5410000, 40}, // bkv -> Latn
-        {0xCD610000, 76}, // blt -> Tavt
-        {0x626D0000, 40}, // bm -> Latn
-        {0x9D810000, 40}, // bmh -> Latn
-        {0xA9810000, 40}, // bmk -> Latn
-        {0xC1810000, 40}, // bmq -> Latn
-        {0xD1810000, 40}, // bmu -> Latn
-        {0x626E0000,  7}, // bn -> Beng
-        {0x99A10000, 40}, // bng -> Latn
-        {0xB1A10000, 40}, // bnm -> Latn
-        {0xBDA10000, 40}, // bnp -> Latn
-        {0x626F0000, 81}, // bo -> Tibt
-        {0xA5C10000, 40}, // boj -> Latn
-        {0xB1C10000, 40}, // bom -> Latn
-        {0xB5C10000, 40}, // bon -> Latn
-        {0xE1E10000,  7}, // bpy -> Beng
-        {0x8A010000, 40}, // bqc -> Latn
-        {0xA2010000,  1}, // bqi -> Arab
-        {0xBE010000, 40}, // bqp -> Latn
-        {0xD6010000, 40}, // bqv -> Latn
-        {0x62720000, 40}, // br -> Latn
-        {0x82210000, 16}, // bra -> Deva
-        {0x9E210000,  1}, // brh -> Arab
-        {0xDE210000, 16}, // brx -> Deva
-        {0xE6210000, 40}, // brz -> Latn
-        {0x62730000, 40}, // bs -> Latn
-        {0xA6410000, 40}, // bsj -> Latn
-        {0xC2410000,  6}, // bsq -> Bass
-        {0xCA410000, 40}, // bss -> Latn
-        {0xCE410000, 18}, // bst -> Ethi
-        {0xBA610000, 40}, // bto -> Latn
-        {0xCE610000, 40}, // btt -> Latn
-        {0xD6610000, 16}, // btv -> Deva
-        {0x82810000, 15}, // bua -> Cyrl
-        {0x8A810000, 40}, // buc -> Latn
-        {0x8E810000, 40}, // bud -> Latn
-        {0x9A810000, 40}, // bug -> Latn
-        {0xAA810000, 40}, // buk -> Latn
-        {0xB2810000, 40}, // bum -> Latn
-        {0xBA810000, 40}, // buo -> Latn
-        {0xCA810000, 40}, // bus -> Latn
-        {0xD2810000, 40}, // buu -> Latn
-        {0x86A10000, 40}, // bvb -> Latn
-        {0x8EC10000, 40}, // bwd -> Latn
-        {0xC6C10000, 40}, // bwr -> Latn
-        {0x9EE10000, 40}, // bxh -> Latn
-        {0x93010000, 40}, // bye -> Latn
-        {0xB7010000, 18}, // byn -> Ethi
-        {0xC7010000, 40}, // byr -> Latn
-        {0xCB010000, 40}, // bys -> Latn
-        {0xD7010000, 40}, // byv -> Latn
-        {0xDF010000, 40}, // byx -> Latn
-        {0x83210000, 40}, // bza -> Latn
-        {0x93210000, 40}, // bze -> Latn
-        {0x97210000, 40}, // bzf -> Latn
-        {0x9F210000, 40}, // bzh -> Latn
-        {0xDB210000, 40}, // bzw -> Latn
-        {0x63610000, 40}, // ca -> Latn
-        {0xB4020000, 40}, // can -> Latn
-        {0xA4220000, 40}, // cbj -> Latn
-        {0x9C420000, 40}, // cch -> Latn
-        {0xBC420000,  7}, // ccp -> Beng
-        {0x63650000, 15}, // ce -> Cyrl
-        {0x84820000, 40}, // ceb -> Latn
-        {0x80A20000, 40}, // cfa -> Latn
-        {0x98C20000, 40}, // cgg -> Latn
-        {0x63680000, 40}, // ch -> Latn
-        {0xA8E20000, 40}, // chk -> Latn
-        {0xB0E20000, 15}, // chm -> Cyrl
-        {0xB8E20000, 40}, // cho -> Latn
-        {0xBCE20000, 40}, // chp -> Latn
-        {0xC4E20000, 12}, // chr -> Cher
-        {0x81220000,  1}, // cja -> Arab
-        {0xB1220000, 11}, // cjm -> Cham
-        {0xD5220000, 40}, // cjv -> Latn
-        {0x85420000,  1}, // ckb -> Arab
-        {0xAD420000, 40}, // ckl -> Latn
-        {0xB9420000, 40}, // cko -> Latn
-        {0xE1420000, 40}, // cky -> Latn
-        {0x81620000, 40}, // cla -> Latn
-        {0x91820000, 40}, // cme -> Latn
-        {0x636F0000, 40}, // co -> Latn
-        {0xBDC20000, 13}, // cop -> Copt
-        {0xC9E20000, 40}, // cps -> Latn
-        {0x63720000,  9}, // cr -> Cans
-        {0xA6220000,  9}, // crj -> Cans
-        {0xAA220000,  9}, // crk -> Cans
-        {0xAE220000,  9}, // crl -> Cans
-        {0xB2220000,  9}, // crm -> Cans
-        {0xCA220000, 40}, // crs -> Latn
-        {0x63730000, 40}, // cs -> Latn
-        {0x86420000, 40}, // csb -> Latn
-        {0xDA420000,  9}, // csw -> Cans
-        {0x8E620000, 59}, // ctd -> Pauc
-        {0x63750000, 15}, // cu -> Cyrl
-        {0x63760000, 15}, // cv -> Cyrl
-        {0x63790000, 40}, // cy -> Latn
-        {0x64610000, 40}, // da -> Latn
-        {0x8C030000, 40}, // dad -> Latn
-        {0x94030000, 40}, // daf -> Latn
-        {0x98030000, 40}, // dag -> Latn
-        {0x9C030000, 40}, // dah -> Latn
-        {0xA8030000, 40}, // dak -> Latn
-        {0xC4030000, 15}, // dar -> Cyrl
-        {0xD4030000, 40}, // dav -> Latn
-        {0x8C230000, 40}, // dbd -> Latn
-        {0xC0230000, 40}, // dbq -> Latn
-        {0x88430000,  1}, // dcc -> Arab
-        {0xB4630000, 40}, // ddn -> Latn
-        {0x64650000, 40}, // de -> Latn
-        {0x8C830000, 40}, // ded -> Latn
-        {0xB4830000, 40}, // den -> Latn
-        {0x80C30000, 40}, // dga -> Latn
-        {0x9CC30000, 40}, // dgh -> Latn
-        {0xA0C30000, 40}, // dgi -> Latn
-        {0xACC30000,  1}, // dgl -> Arab
-        {0xC4C30000, 40}, // dgr -> Latn
-        {0xE4C30000, 40}, // dgz -> Latn
-        {0x81030000, 40}, // dia -> Latn
-        {0x91230000, 40}, // dje -> Latn
-        {0xA5A30000, 40}, // dnj -> Latn
-        {0x85C30000, 40}, // dob -> Latn
-        {0xA1C30000,  1}, // doi -> Arab
-        {0xBDC30000, 40}, // dop -> Latn
-        {0xD9C30000, 40}, // dow -> Latn
-        {0xA2230000, 40}, // dri -> Latn
-        {0xCA230000, 18}, // drs -> Ethi
-        {0x86430000, 40}, // dsb -> Latn
-        {0xB2630000, 40}, // dtm -> Latn
-        {0xBE630000, 40}, // dtp -> Latn
-        {0xCA630000, 40}, // dts -> Latn
-        {0xE2630000, 16}, // dty -> Deva
-        {0x82830000, 40}, // dua -> Latn
-        {0x8A830000, 40}, // duc -> Latn
-        {0x8E830000, 40}, // dud -> Latn
-        {0x9A830000, 40}, // dug -> Latn
-        {0x64760000, 79}, // dv -> Thaa
-        {0x82A30000, 40}, // dva -> Latn
-        {0xDAC30000, 40}, // dww -> Latn
-        {0xBB030000, 40}, // dyo -> Latn
-        {0xD3030000, 40}, // dyu -> Latn
-        {0x647A0000, 81}, // dz -> Tibt
-        {0x9B230000, 40}, // dzg -> Latn
-        {0xD0240000, 40}, // ebu -> Latn
-        {0x65650000, 40}, // ee -> Latn
-        {0xA0A40000, 40}, // efi -> Latn
-        {0xACC40000, 40}, // egl -> Latn
-        {0xE0C40000, 17}, // egy -> Egyp
-        {0xE1440000, 32}, // eky -> Kali
-        {0x656C0000, 21}, // el -> Grek
-        {0x81840000, 40}, // ema -> Latn
-        {0xA1840000, 40}, // emi -> Latn
-        {0x656E0000, 40}, // en -> Latn
-        {0x656E5841, 87}, // en-XA -> ~~~A
-        {0xB5A40000, 40}, // enn -> Latn
-        {0xC1A40000, 40}, // enq -> Latn
-        {0x656F0000, 40}, // eo -> Latn
-        {0xA2240000, 40}, // eri -> Latn
-        {0x65730000, 40}, // es -> Latn
-        {0xD2440000, 40}, // esu -> Latn
-        {0x65740000, 40}, // et -> Latn
-        {0xC6640000, 40}, // etr -> Latn
-        {0xCE640000, 30}, // ett -> Ital
-        {0xD2640000, 40}, // etu -> Latn
-        {0xDE640000, 40}, // etx -> Latn
-        {0x65750000, 40}, // eu -> Latn
-        {0xBAC40000, 40}, // ewo -> Latn
-        {0xCEE40000, 40}, // ext -> Latn
-        {0x66610000,  1}, // fa -> Arab
-        {0x80050000, 40}, // faa -> Latn
-        {0x84050000, 40}, // fab -> Latn
-        {0x98050000, 40}, // fag -> Latn
-        {0xA0050000, 40}, // fai -> Latn
-        {0xB4050000, 40}, // fan -> Latn
-        {0x66660000, 40}, // ff -> Latn
-        {0xA0A50000, 40}, // ffi -> Latn
-        {0xB0A50000, 40}, // ffm -> Latn
-        {0x66690000, 40}, // fi -> Latn
-        {0x81050000,  1}, // fia -> Arab
-        {0xAD050000, 40}, // fil -> Latn
-        {0xCD050000, 40}, // fit -> Latn
-        {0x666A0000, 40}, // fj -> Latn
-        {0xC5650000, 40}, // flr -> Latn
-        {0xBD850000, 40}, // fmp -> Latn
-        {0x666F0000, 40}, // fo -> Latn
-        {0x8DC50000, 40}, // fod -> Latn
-        {0xB5C50000, 40}, // fon -> Latn
-        {0xC5C50000, 40}, // for -> Latn
-        {0x91E50000, 40}, // fpe -> Latn
-        {0xCA050000, 40}, // fqs -> Latn
-        {0x66720000, 40}, // fr -> Latn
-        {0x8A250000, 40}, // frc -> Latn
-        {0xBE250000, 40}, // frp -> Latn
-        {0xC6250000, 40}, // frr -> Latn
-        {0xCA250000, 40}, // frs -> Latn
-        {0x86850000,  1}, // fub -> Arab
-        {0x8E850000, 40}, // fud -> Latn
-        {0x92850000, 40}, // fue -> Latn
-        {0x96850000, 40}, // fuf -> Latn
-        {0x9E850000, 40}, // fuh -> Latn
-        {0xC2850000, 40}, // fuq -> Latn
-        {0xC6850000, 40}, // fur -> Latn
-        {0xD6850000, 40}, // fuv -> Latn
-        {0xE2850000, 40}, // fuy -> Latn
-        {0xC6A50000, 40}, // fvr -> Latn
-        {0x66790000, 40}, // fy -> Latn
-        {0x67610000, 40}, // ga -> Latn
-        {0x80060000, 40}, // gaa -> Latn
-        {0x94060000, 40}, // gaf -> Latn
-        {0x98060000, 40}, // gag -> Latn
-        {0x9C060000, 40}, // gah -> Latn
-        {0xA4060000, 40}, // gaj -> Latn
-        {0xB0060000, 40}, // gam -> Latn
-        {0xB4060000, 24}, // gan -> Hans
-        {0xD8060000, 40}, // gaw -> Latn
-        {0xE0060000, 40}, // gay -> Latn
-        {0x94260000, 40}, // gbf -> Latn
-        {0xB0260000, 16}, // gbm -> Deva
-        {0xE0260000, 40}, // gby -> Latn
-        {0xE4260000,  1}, // gbz -> Arab
-        {0xC4460000, 40}, // gcr -> Latn
-        {0x67640000, 40}, // gd -> Latn
-        {0x90660000, 40}, // gde -> Latn
-        {0xB4660000, 40}, // gdn -> Latn
-        {0xC4660000, 40}, // gdr -> Latn
-        {0x84860000, 40}, // geb -> Latn
-        {0xA4860000, 40}, // gej -> Latn
-        {0xAC860000, 40}, // gel -> Latn
-        {0xE4860000, 18}, // gez -> Ethi
-        {0xA8A60000, 40}, // gfk -> Latn
-        {0xB4C60000, 16}, // ggn -> Deva
-        {0xC8E60000, 40}, // ghs -> Latn
-        {0xAD060000, 40}, // gil -> Latn
-        {0xB1060000, 40}, // gim -> Latn
-        {0xA9260000,  1}, // gjk -> Arab
-        {0xB5260000, 40}, // gjn -> Latn
-        {0xD1260000,  1}, // gju -> Arab
-        {0xB5460000, 40}, // gkn -> Latn
-        {0xBD460000, 40}, // gkp -> Latn
-        {0x676C0000, 40}, // gl -> Latn
-        {0xA9660000,  1}, // glk -> Arab
-        {0xB1860000, 40}, // gmm -> Latn
-        {0xD5860000, 18}, // gmv -> Ethi
-        {0x676E0000, 40}, // gn -> Latn
-        {0x8DA60000, 40}, // gnd -> Latn
-        {0x99A60000, 40}, // gng -> Latn
-        {0x8DC60000, 40}, // god -> Latn
-        {0x95C60000, 18}, // gof -> Ethi
-        {0xA1C60000, 40}, // goi -> Latn
-        {0xB1C60000, 16}, // gom -> Deva
-        {0xB5C60000, 77}, // gon -> Telu
-        {0xC5C60000, 40}, // gor -> Latn
-        {0xC9C60000, 40}, // gos -> Latn
-        {0xCDC60000, 20}, // got -> Goth
-        {0x8A260000, 14}, // grc -> Cprt
-        {0xCE260000,  7}, // grt -> Beng
-        {0xDA260000, 40}, // grw -> Latn
-        {0xDA460000, 40}, // gsw -> Latn
-        {0x67750000, 22}, // gu -> Gujr
-        {0x86860000, 40}, // gub -> Latn
-        {0x8A860000, 40}, // guc -> Latn
-        {0x8E860000, 40}, // gud -> Latn
-        {0xC6860000, 40}, // gur -> Latn
-        {0xDA860000, 40}, // guw -> Latn
-        {0xDE860000, 40}, // gux -> Latn
-        {0xE6860000, 40}, // guz -> Latn
-        {0x67760000, 40}, // gv -> Latn
-        {0x96A60000, 40}, // gvf -> Latn
-        {0xC6A60000, 16}, // gvr -> Deva
-        {0xCAA60000, 40}, // gvs -> Latn
-        {0x8AC60000,  1}, // gwc -> Arab
-        {0xA2C60000, 40}, // gwi -> Latn
-        {0xCEC60000,  1}, // gwt -> Arab
-        {0xA3060000, 40}, // gyi -> Latn
-        {0x68610000, 40}, // ha -> Latn
-        {0x6861434D,  1}, // ha-CM -> Arab
-        {0x68615344,  1}, // ha-SD -> Arab
-        {0x98070000, 40}, // hag -> Latn
-        {0xA8070000, 24}, // hak -> Hans
-        {0xB0070000, 40}, // ham -> Latn
-        {0xD8070000, 40}, // haw -> Latn
-        {0xE4070000,  1}, // haz -> Arab
-        {0x84270000, 40}, // hbb -> Latn
-        {0xE0670000, 18}, // hdy -> Ethi
-        {0x68650000, 27}, // he -> Hebr
-        {0xE0E70000, 40}, // hhy -> Latn
-        {0x68690000, 16}, // hi -> Deva
-        {0x81070000, 40}, // hia -> Latn
-        {0x95070000, 40}, // hif -> Latn
-        {0x99070000, 40}, // hig -> Latn
-        {0x9D070000, 40}, // hih -> Latn
-        {0xAD070000, 40}, // hil -> Latn
-        {0x81670000, 40}, // hla -> Latn
-        {0xD1670000, 28}, // hlu -> Hluw
-        {0x8D870000, 62}, // hmd -> Plrd
-        {0xCD870000, 40}, // hmt -> Latn
-        {0x8DA70000,  1}, // hnd -> Arab
-        {0x91A70000, 16}, // hne -> Deva
-        {0xA5A70000, 29}, // hnj -> Hmng
-        {0xB5A70000, 40}, // hnn -> Latn
-        {0xB9A70000,  1}, // hno -> Arab
-        {0x686F0000, 40}, // ho -> Latn
-        {0x89C70000, 16}, // hoc -> Deva
-        {0xA5C70000, 16}, // hoj -> Deva
-        {0xCDC70000, 40}, // hot -> Latn
-        {0x68720000, 40}, // hr -> Latn
-        {0x86470000, 40}, // hsb -> Latn
-        {0xB6470000, 24}, // hsn -> Hans
-        {0x68740000, 40}, // ht -> Latn
-        {0x68750000, 40}, // hu -> Latn
-        {0xA2870000, 40}, // hui -> Latn
-        {0x68790000,  3}, // hy -> Armn
-        {0x687A0000, 40}, // hz -> Latn
-        {0x69610000, 40}, // ia -> Latn
-        {0xB4080000, 40}, // ian -> Latn
-        {0xC4080000, 40}, // iar -> Latn
-        {0x80280000, 40}, // iba -> Latn
-        {0x84280000, 40}, // ibb -> Latn
-        {0xE0280000, 40}, // iby -> Latn
-        {0x80480000, 40}, // ica -> Latn
-        {0x9C480000, 40}, // ich -> Latn
-        {0x69640000, 40}, // id -> Latn
-        {0x8C680000, 40}, // idd -> Latn
-        {0xA0680000, 40}, // idi -> Latn
-        {0xD0680000, 40}, // idu -> Latn
-        {0x69670000, 40}, // ig -> Latn
-        {0x84C80000, 40}, // igb -> Latn
-        {0x90C80000, 40}, // ige -> Latn
-        {0x69690000, 86}, // ii -> Yiii
-        {0xA5280000, 40}, // ijj -> Latn
-        {0x696B0000, 40}, // ik -> Latn
-        {0xA9480000, 40}, // ikk -> Latn
-        {0xCD480000, 40}, // ikt -> Latn
-        {0xD9480000, 40}, // ikw -> Latn
-        {0xDD480000, 40}, // ikx -> Latn
-        {0xB9680000, 40}, // ilo -> Latn
-        {0xB9880000, 40}, // imo -> Latn
-        {0x696E0000, 40}, // in -> Latn
-        {0x9DA80000, 15}, // inh -> Cyrl
-        {0xD1C80000, 40}, // iou -> Latn
-        {0xA2280000, 40}, // iri -> Latn
-        {0x69730000, 40}, // is -> Latn
-        {0x69740000, 40}, // it -> Latn
-        {0x69750000,  9}, // iu -> Cans
-        {0x69770000, 27}, // iw -> Hebr
-        {0xB2C80000, 40}, // iwm -> Latn
-        {0xCAC80000, 40}, // iws -> Latn
-        {0x9F280000, 40}, // izh -> Latn
-        {0xA3280000, 40}, // izi -> Latn
-        {0x6A610000, 31}, // ja -> Jpan
-        {0x84090000, 40}, // jab -> Latn
-        {0xB0090000, 40}, // jam -> Latn
-        {0xD0290000, 40}, // jbu -> Latn
-        {0xB4890000, 40}, // jen -> Latn
-        {0xA8C90000, 40}, // jgk -> Latn
-        {0xB8C90000, 40}, // jgo -> Latn
-        {0x6A690000, 27}, // ji -> Hebr
-        {0x85090000, 40}, // jib -> Latn
-        {0x89890000, 40}, // jmc -> Latn
-        {0xAD890000, 16}, // jml -> Deva
-        {0x82290000, 40}, // jra -> Latn
-        {0xCE890000, 40}, // jut -> Latn
-        {0x6A760000, 40}, // jv -> Latn
-        {0x6A770000, 40}, // jw -> Latn
-        {0x6B610000, 19}, // ka -> Geor
-        {0x800A0000, 15}, // kaa -> Cyrl
-        {0x840A0000, 40}, // kab -> Latn
-        {0x880A0000, 40}, // kac -> Latn
-        {0x8C0A0000, 40}, // kad -> Latn
-        {0xA00A0000, 40}, // kai -> Latn
-        {0xA40A0000, 40}, // kaj -> Latn
-        {0xB00A0000, 40}, // kam -> Latn
-        {0xB80A0000, 40}, // kao -> Latn
-        {0x8C2A0000, 15}, // kbd -> Cyrl
-        {0xB02A0000, 40}, // kbm -> Latn
-        {0xBC2A0000, 40}, // kbp -> Latn
-        {0xC02A0000, 40}, // kbq -> Latn
-        {0xDC2A0000, 40}, // kbx -> Latn
-        {0xE02A0000,  1}, // kby -> Arab
-        {0x984A0000, 40}, // kcg -> Latn
-        {0xA84A0000, 40}, // kck -> Latn
-        {0xAC4A0000, 40}, // kcl -> Latn
-        {0xCC4A0000, 40}, // kct -> Latn
-        {0x906A0000, 40}, // kde -> Latn
-        {0x9C6A0000,  1}, // kdh -> Arab
-        {0xAC6A0000, 40}, // kdl -> Latn
-        {0xCC6A0000, 80}, // kdt -> Thai
-        {0x808A0000, 40}, // kea -> Latn
-        {0xB48A0000, 40}, // ken -> Latn
-        {0xE48A0000, 40}, // kez -> Latn
-        {0xB8AA0000, 40}, // kfo -> Latn
-        {0xC4AA0000, 16}, // kfr -> Deva
-        {0xE0AA0000, 16}, // kfy -> Deva
-        {0x6B670000, 40}, // kg -> Latn
-        {0x90CA0000, 40}, // kge -> Latn
-        {0x94CA0000, 40}, // kgf -> Latn
-        {0xBCCA0000, 40}, // kgp -> Latn
-        {0x80EA0000, 40}, // kha -> Latn
-        {0x84EA0000, 73}, // khb -> Talu
-        {0xB4EA0000, 16}, // khn -> Deva
-        {0xC0EA0000, 40}, // khq -> Latn
-        {0xC8EA0000, 40}, // khs -> Latn
-        {0xCCEA0000, 52}, // kht -> Mymr
-        {0xD8EA0000,  1}, // khw -> Arab
-        {0xE4EA0000, 40}, // khz -> Latn
-        {0x6B690000, 40}, // ki -> Latn
-        {0xA50A0000, 40}, // kij -> Latn
-        {0xD10A0000, 40}, // kiu -> Latn
-        {0xD90A0000, 40}, // kiw -> Latn
-        {0x6B6A0000, 40}, // kj -> Latn
-        {0x8D2A0000, 40}, // kjd -> Latn
-        {0x992A0000, 39}, // kjg -> Laoo
-        {0xC92A0000, 40}, // kjs -> Latn
-        {0xE12A0000, 40}, // kjy -> Latn
-        {0x6B6B0000, 15}, // kk -> Cyrl
-        {0x6B6B4146,  1}, // kk-AF -> Arab
-        {0x6B6B434E,  1}, // kk-CN -> Arab
-        {0x6B6B4952,  1}, // kk-IR -> Arab
-        {0x6B6B4D4E,  1}, // kk-MN -> Arab
-        {0x894A0000, 40}, // kkc -> Latn
-        {0xA54A0000, 40}, // kkj -> Latn
-        {0x6B6C0000, 40}, // kl -> Latn
-        {0xB56A0000, 40}, // kln -> Latn
-        {0xC16A0000, 40}, // klq -> Latn
-        {0xCD6A0000, 40}, // klt -> Latn
-        {0xDD6A0000, 40}, // klx -> Latn
-        {0x6B6D0000, 35}, // km -> Khmr
-        {0x858A0000, 40}, // kmb -> Latn
-        {0x9D8A0000, 40}, // kmh -> Latn
-        {0xB98A0000, 40}, // kmo -> Latn
-        {0xC98A0000, 40}, // kms -> Latn
-        {0xD18A0000, 40}, // kmu -> Latn
-        {0xD98A0000, 40}, // kmw -> Latn
-        {0x6B6E0000, 36}, // kn -> Knda
-        {0xBDAA0000, 40}, // knp -> Latn
-        {0x6B6F0000, 37}, // ko -> Kore
-        {0xA1CA0000, 15}, // koi -> Cyrl
-        {0xA9CA0000, 16}, // kok -> Deva
-        {0xADCA0000, 40}, // kol -> Latn
-        {0xC9CA0000, 40}, // kos -> Latn
-        {0xE5CA0000, 40}, // koz -> Latn
-        {0x91EA0000, 40}, // kpe -> Latn
-        {0x95EA0000, 40}, // kpf -> Latn
-        {0xB9EA0000, 40}, // kpo -> Latn
-        {0xC5EA0000, 40}, // kpr -> Latn
-        {0xDDEA0000, 40}, // kpx -> Latn
-        {0x860A0000, 40}, // kqb -> Latn
-        {0x960A0000, 40}, // kqf -> Latn
-        {0xCA0A0000, 40}, // kqs -> Latn
-        {0xE20A0000, 18}, // kqy -> Ethi
-        {0x8A2A0000, 15}, // krc -> Cyrl
-        {0xA22A0000, 40}, // kri -> Latn
-        {0xA62A0000, 40}, // krj -> Latn
-        {0xAE2A0000, 40}, // krl -> Latn
-        {0xCA2A0000, 40}, // krs -> Latn
-        {0xD22A0000, 16}, // kru -> Deva
-        {0x6B730000,  1}, // ks -> Arab
-        {0x864A0000, 40}, // ksb -> Latn
-        {0x8E4A0000, 40}, // ksd -> Latn
-        {0x964A0000, 40}, // ksf -> Latn
-        {0x9E4A0000, 40}, // ksh -> Latn
-        {0xA64A0000, 40}, // ksj -> Latn
-        {0xC64A0000, 40}, // ksr -> Latn
-        {0x866A0000, 18}, // ktb -> Ethi
-        {0xB26A0000, 40}, // ktm -> Latn
-        {0xBA6A0000, 40}, // kto -> Latn
-        {0x6B750000, 40}, // ku -> Latn
-        {0x6B754952,  1}, // ku-IR -> Arab
-        {0x6B754C42,  1}, // ku-LB -> Arab
-        {0x868A0000, 40}, // kub -> Latn
-        {0x8E8A0000, 40}, // kud -> Latn
-        {0x928A0000, 40}, // kue -> Latn
-        {0xA68A0000, 40}, // kuj -> Latn
-        {0xB28A0000, 15}, // kum -> Cyrl
-        {0xB68A0000, 40}, // kun -> Latn
-        {0xBE8A0000, 40}, // kup -> Latn
-        {0xCA8A0000, 40}, // kus -> Latn
-        {0x6B760000, 15}, // kv -> Cyrl
-        {0x9AAA0000, 40}, // kvg -> Latn
-        {0xC6AA0000, 40}, // kvr -> Latn
-        {0xDEAA0000,  1}, // kvx -> Arab
-        {0x6B770000, 40}, // kw -> Latn
-        {0xA6CA0000, 40}, // kwj -> Latn
-        {0xBACA0000, 40}, // kwo -> Latn
-        {0x82EA0000, 40}, // kxa -> Latn
-        {0x8AEA0000, 18}, // kxc -> Ethi
-        {0xB2EA0000, 80}, // kxm -> Thai
-        {0xBEEA0000,  1}, // kxp -> Arab
-        {0xDAEA0000, 40}, // kxw -> Latn
-        {0xE6EA0000, 40}, // kxz -> Latn
-        {0x6B790000, 15}, // ky -> Cyrl
-        {0x6B79434E,  1}, // ky-CN -> Arab
-        {0x6B795452, 40}, // ky-TR -> Latn
-        {0x930A0000, 40}, // kye -> Latn
-        {0xDF0A0000, 40}, // kyx -> Latn
-        {0xC72A0000, 40}, // kzr -> Latn
-        {0x6C610000, 40}, // la -> Latn
-        {0x840B0000, 42}, // lab -> Lina
-        {0x8C0B0000, 27}, // lad -> Hebr
-        {0x980B0000, 40}, // lag -> Latn
-        {0x9C0B0000,  1}, // lah -> Arab
-        {0xA40B0000, 40}, // laj -> Latn
-        {0xC80B0000, 40}, // las -> Latn
-        {0x6C620000, 40}, // lb -> Latn
-        {0x902B0000, 15}, // lbe -> Cyrl
-        {0xD02B0000, 40}, // lbu -> Latn
-        {0xD82B0000, 40}, // lbw -> Latn
-        {0xB04B0000, 40}, // lcm -> Latn
-        {0xBC4B0000, 80}, // lcp -> Thai
-        {0x846B0000, 40}, // ldb -> Latn
-        {0x8C8B0000, 40}, // led -> Latn
-        {0x908B0000, 40}, // lee -> Latn
-        {0xB08B0000, 40}, // lem -> Latn
-        {0xBC8B0000, 41}, // lep -> Lepc
-        {0xC08B0000, 40}, // leq -> Latn
-        {0xD08B0000, 40}, // leu -> Latn
-        {0xE48B0000, 15}, // lez -> Cyrl
-        {0x6C670000, 40}, // lg -> Latn
-        {0x98CB0000, 40}, // lgg -> Latn
-        {0x6C690000, 40}, // li -> Latn
-        {0x810B0000, 40}, // lia -> Latn
-        {0x8D0B0000, 40}, // lid -> Latn
-        {0x950B0000, 16}, // lif -> Deva
-        {0x990B0000, 40}, // lig -> Latn
-        {0x9D0B0000, 40}, // lih -> Latn
-        {0xA50B0000, 40}, // lij -> Latn
-        {0xC90B0000, 43}, // lis -> Lisu
-        {0xBD2B0000, 40}, // ljp -> Latn
-        {0xA14B0000,  1}, // lki -> Arab
-        {0xCD4B0000, 40}, // lkt -> Latn
-        {0x916B0000, 40}, // lle -> Latn
-        {0xB56B0000, 40}, // lln -> Latn
-        {0xB58B0000, 77}, // lmn -> Telu
-        {0xB98B0000, 40}, // lmo -> Latn
-        {0xBD8B0000, 40}, // lmp -> Latn
-        {0x6C6E0000, 40}, // ln -> Latn
-        {0xC9AB0000, 40}, // lns -> Latn
-        {0xD1AB0000, 40}, // lnu -> Latn
-        {0x6C6F0000, 39}, // lo -> Laoo
-        {0xA5CB0000, 40}, // loj -> Latn
-        {0xA9CB0000, 40}, // lok -> Latn
-        {0xADCB0000, 40}, // lol -> Latn
-        {0xC5CB0000, 40}, // lor -> Latn
-        {0xC9CB0000, 40}, // los -> Latn
-        {0xE5CB0000, 40}, // loz -> Latn
-        {0x8A2B0000,  1}, // lrc -> Arab
-        {0x6C740000, 40}, // lt -> Latn
-        {0x9A6B0000, 40}, // ltg -> Latn
-        {0x6C750000, 40}, // lu -> Latn
-        {0x828B0000, 40}, // lua -> Latn
-        {0xBA8B0000, 40}, // luo -> Latn
-        {0xE28B0000, 40}, // luy -> Latn
-        {0xE68B0000,  1}, // luz -> Arab
-        {0x6C760000, 40}, // lv -> Latn
-        {0xAECB0000, 80}, // lwl -> Thai
-        {0x9F2B0000, 24}, // lzh -> Hans
-        {0xE72B0000, 40}, // lzz -> Latn
-        {0x8C0C0000, 40}, // mad -> Latn
-        {0x940C0000, 40}, // maf -> Latn
-        {0x980C0000, 16}, // mag -> Deva
-        {0xA00C0000, 16}, // mai -> Deva
-        {0xA80C0000, 40}, // mak -> Latn
-        {0xB40C0000, 40}, // man -> Latn
-        {0xB40C474E, 54}, // man-GN -> Nkoo
-        {0xC80C0000, 40}, // mas -> Latn
-        {0xD80C0000, 40}, // maw -> Latn
-        {0xE40C0000, 40}, // maz -> Latn
-        {0x9C2C0000, 40}, // mbh -> Latn
-        {0xB82C0000, 40}, // mbo -> Latn
-        {0xC02C0000, 40}, // mbq -> Latn
-        {0xD02C0000, 40}, // mbu -> Latn
-        {0xD82C0000, 40}, // mbw -> Latn
-        {0xA04C0000, 40}, // mci -> Latn
-        {0xBC4C0000, 40}, // mcp -> Latn
-        {0xC04C0000, 40}, // mcq -> Latn
-        {0xC44C0000, 40}, // mcr -> Latn
-        {0xD04C0000, 40}, // mcu -> Latn
-        {0x806C0000, 40}, // mda -> Latn
-        {0x906C0000,  1}, // mde -> Arab
-        {0x946C0000, 15}, // mdf -> Cyrl
-        {0x9C6C0000, 40}, // mdh -> Latn
-        {0xA46C0000, 40}, // mdj -> Latn
-        {0xC46C0000, 40}, // mdr -> Latn
-        {0xDC6C0000, 18}, // mdx -> Ethi
-        {0x8C8C0000, 40}, // med -> Latn
-        {0x908C0000, 40}, // mee -> Latn
-        {0xA88C0000, 40}, // mek -> Latn
-        {0xB48C0000, 40}, // men -> Latn
-        {0xC48C0000, 40}, // mer -> Latn
-        {0xCC8C0000, 40}, // met -> Latn
-        {0xD08C0000, 40}, // meu -> Latn
-        {0x80AC0000,  1}, // mfa -> Arab
-        {0x90AC0000, 40}, // mfe -> Latn
-        {0xB4AC0000, 40}, // mfn -> Latn
-        {0xB8AC0000, 40}, // mfo -> Latn
-        {0xC0AC0000, 40}, // mfq -> Latn
-        {0x6D670000, 40}, // mg -> Latn
-        {0x9CCC0000, 40}, // mgh -> Latn
-        {0xACCC0000, 40}, // mgl -> Latn
-        {0xB8CC0000, 40}, // mgo -> Latn
-        {0xBCCC0000, 16}, // mgp -> Deva
-        {0xE0CC0000, 40}, // mgy -> Latn
-        {0x6D680000, 40}, // mh -> Latn
-        {0xA0EC0000, 40}, // mhi -> Latn
-        {0xACEC0000, 40}, // mhl -> Latn
-        {0x6D690000, 40}, // mi -> Latn
-        {0x950C0000, 40}, // mif -> Latn
-        {0xB50C0000, 40}, // min -> Latn
-        {0xC90C0000, 26}, // mis -> Hatr
-        {0xD90C0000, 40}, // miw -> Latn
-        {0x6D6B0000, 15}, // mk -> Cyrl
-        {0xA14C0000,  1}, // mki -> Arab
-        {0xAD4C0000, 40}, // mkl -> Latn
-        {0xBD4C0000, 40}, // mkp -> Latn
-        {0xD94C0000, 40}, // mkw -> Latn
-        {0x6D6C0000, 49}, // ml -> Mlym
-        {0x916C0000, 40}, // mle -> Latn
-        {0xBD6C0000, 40}, // mlp -> Latn
-        {0xC96C0000, 40}, // mls -> Latn
-        {0xB98C0000, 40}, // mmo -> Latn
-        {0xD18C0000, 40}, // mmu -> Latn
-        {0xDD8C0000, 40}, // mmx -> Latn
-        {0x6D6E0000, 15}, // mn -> Cyrl
-        {0x6D6E434E, 50}, // mn-CN -> Mong
-        {0x81AC0000, 40}, // mna -> Latn
-        {0x95AC0000, 40}, // mnf -> Latn
-        {0xA1AC0000,  7}, // mni -> Beng
-        {0xD9AC0000, 52}, // mnw -> Mymr
-        {0x81CC0000, 40}, // moa -> Latn
-        {0x91CC0000, 40}, // moe -> Latn
-        {0x9DCC0000, 40}, // moh -> Latn
-        {0xC9CC0000, 40}, // mos -> Latn
-        {0xDDCC0000, 40}, // mox -> Latn
-        {0xBDEC0000, 40}, // mpp -> Latn
-        {0xC9EC0000, 40}, // mps -> Latn
-        {0xCDEC0000, 40}, // mpt -> Latn
-        {0xDDEC0000, 40}, // mpx -> Latn
-        {0xAE0C0000, 40}, // mql -> Latn
-        {0x6D720000, 16}, // mr -> Deva
-        {0x8E2C0000, 16}, // mrd -> Deva
-        {0xA62C0000, 15}, // mrj -> Cyrl
-        {0xBA2C0000, 51}, // mro -> Mroo
-        {0x6D730000, 40}, // ms -> Latn
-        {0x6D734343,  1}, // ms-CC -> Arab
-        {0x6D734944,  1}, // ms-ID -> Arab
-        {0x6D740000, 40}, // mt -> Latn
-        {0x8A6C0000, 40}, // mtc -> Latn
-        {0x966C0000, 40}, // mtf -> Latn
-        {0xA26C0000, 40}, // mti -> Latn
-        {0xC66C0000, 16}, // mtr -> Deva
-        {0x828C0000, 40}, // mua -> Latn
-        {0xC68C0000, 40}, // mur -> Latn
-        {0xCA8C0000, 40}, // mus -> Latn
-        {0x82AC0000, 40}, // mva -> Latn
-        {0xB6AC0000, 40}, // mvn -> Latn
-        {0xE2AC0000,  1}, // mvy -> Arab
-        {0xAACC0000, 40}, // mwk -> Latn
-        {0xC6CC0000, 16}, // mwr -> Deva
-        {0xD6CC0000, 40}, // mwv -> Latn
-        {0x8AEC0000, 40}, // mxc -> Latn
-        {0xB2EC0000, 40}, // mxm -> Latn
-        {0x6D790000, 52}, // my -> Mymr
-        {0xAB0C0000, 40}, // myk -> Latn
-        {0xB30C0000, 18}, // mym -> Ethi
-        {0xD70C0000, 15}, // myv -> Cyrl
-        {0xDB0C0000, 40}, // myw -> Latn
-        {0xDF0C0000, 40}, // myx -> Latn
-        {0xE70C0000, 46}, // myz -> Mand
-        {0xAB2C0000, 40}, // mzk -> Latn
-        {0xB32C0000, 40}, // mzm -> Latn
-        {0xB72C0000,  1}, // mzn -> Arab
-        {0xBF2C0000, 40}, // mzp -> Latn
-        {0xDB2C0000, 40}, // mzw -> Latn
-        {0xE72C0000, 40}, // mzz -> Latn
-        {0x6E610000, 40}, // na -> Latn
-        {0x880D0000, 40}, // nac -> Latn
-        {0x940D0000, 40}, // naf -> Latn
-        {0xA80D0000, 40}, // nak -> Latn
-        {0xB40D0000, 24}, // nan -> Hans
-        {0xBC0D0000, 40}, // nap -> Latn
-        {0xC00D0000, 40}, // naq -> Latn
-        {0xC80D0000, 40}, // nas -> Latn
-        {0x6E620000, 40}, // nb -> Latn
-        {0x804D0000, 40}, // nca -> Latn
-        {0x904D0000, 40}, // nce -> Latn
-        {0x944D0000, 40}, // ncf -> Latn
-        {0x9C4D0000, 40}, // nch -> Latn
-        {0xB84D0000, 40}, // nco -> Latn
-        {0xD04D0000, 40}, // ncu -> Latn
-        {0x6E640000, 40}, // nd -> Latn
-        {0x886D0000, 40}, // ndc -> Latn
-        {0xC86D0000, 40}, // nds -> Latn
-        {0x6E650000, 16}, // ne -> Deva
-        {0x848D0000, 40}, // neb -> Latn
-        {0xD88D0000, 16}, // new -> Deva
-        {0xDC8D0000, 40}, // nex -> Latn
-        {0xC4AD0000, 40}, // nfr -> Latn
-        {0x6E670000, 40}, // ng -> Latn
-        {0x80CD0000, 40}, // nga -> Latn
-        {0x84CD0000, 40}, // ngb -> Latn
-        {0xACCD0000, 40}, // ngl -> Latn
-        {0x84ED0000, 40}, // nhb -> Latn
-        {0x90ED0000, 40}, // nhe -> Latn
-        {0xD8ED0000, 40}, // nhw -> Latn
-        {0x950D0000, 40}, // nif -> Latn
-        {0xA10D0000, 40}, // nii -> Latn
-        {0xA50D0000, 40}, // nij -> Latn
-        {0xB50D0000, 40}, // nin -> Latn
-        {0xD10D0000, 40}, // niu -> Latn
-        {0xE10D0000, 40}, // niy -> Latn
-        {0xE50D0000, 40}, // niz -> Latn
-        {0xB92D0000, 40}, // njo -> Latn
-        {0x994D0000, 40}, // nkg -> Latn
-        {0xB94D0000, 40}, // nko -> Latn
-        {0x6E6C0000, 40}, // nl -> Latn
-        {0x998D0000, 40}, // nmg -> Latn
-        {0xE58D0000, 40}, // nmz -> Latn
-        {0x6E6E0000, 40}, // nn -> Latn
-        {0x95AD0000, 40}, // nnf -> Latn
-        {0x9DAD0000, 40}, // nnh -> Latn
-        {0xA9AD0000, 40}, // nnk -> Latn
-        {0xB1AD0000, 40}, // nnm -> Latn
-        {0x6E6F0000, 40}, // no -> Latn
-        {0x8DCD0000, 38}, // nod -> Lana
-        {0x91CD0000, 16}, // noe -> Deva
-        {0xB5CD0000, 64}, // non -> Runr
-        {0xBDCD0000, 40}, // nop -> Latn
-        {0xD1CD0000, 40}, // nou -> Latn
-        {0xBA0D0000, 54}, // nqo -> Nkoo
-        {0x6E720000, 40}, // nr -> Latn
-        {0x862D0000, 40}, // nrb -> Latn
-        {0xAA4D0000,  9}, // nsk -> Cans
-        {0xB64D0000, 40}, // nsn -> Latn
-        {0xBA4D0000, 40}, // nso -> Latn
-        {0xCA4D0000, 40}, // nss -> Latn
-        {0xB26D0000, 40}, // ntm -> Latn
-        {0xC66D0000, 40}, // ntr -> Latn
-        {0xA28D0000, 40}, // nui -> Latn
-        {0xBE8D0000, 40}, // nup -> Latn
-        {0xCA8D0000, 40}, // nus -> Latn
-        {0xD68D0000, 40}, // nuv -> Latn
-        {0xDE8D0000, 40}, // nux -> Latn
-        {0x6E760000, 40}, // nv -> Latn
-        {0x86CD0000, 40}, // nwb -> Latn
-        {0xC2ED0000, 40}, // nxq -> Latn
-        {0xC6ED0000, 40}, // nxr -> Latn
-        {0x6E790000, 40}, // ny -> Latn
-        {0xB30D0000, 40}, // nym -> Latn
-        {0xB70D0000, 40}, // nyn -> Latn
-        {0xA32D0000, 40}, // nzi -> Latn
-        {0x6F630000, 40}, // oc -> Latn
-        {0x88CE0000, 40}, // ogc -> Latn
-        {0xC54E0000, 40}, // okr -> Latn
-        {0xD54E0000, 40}, // okv -> Latn
-        {0x6F6D0000, 40}, // om -> Latn
-        {0x99AE0000, 40}, // ong -> Latn
-        {0xB5AE0000, 40}, // onn -> Latn
-        {0xC9AE0000, 40}, // ons -> Latn
-        {0xB1EE0000, 40}, // opm -> Latn
-        {0x6F720000, 57}, // or -> Orya
-        {0xBA2E0000, 40}, // oro -> Latn
-        {0xD22E0000,  1}, // oru -> Arab
-        {0x6F730000, 15}, // os -> Cyrl
-        {0x824E0000, 58}, // osa -> Osge
-        {0x826E0000,  1}, // ota -> Arab
-        {0xAA6E0000, 56}, // otk -> Orkh
-        {0xB32E0000, 40}, // ozm -> Latn
-        {0x70610000, 23}, // pa -> Guru
-        {0x7061504B,  1}, // pa-PK -> Arab
-        {0x980F0000, 40}, // pag -> Latn
-        {0xAC0F0000, 60}, // pal -> Phli
-        {0xB00F0000, 40}, // pam -> Latn
-        {0xBC0F0000, 40}, // pap -> Latn
-        {0xD00F0000, 40}, // pau -> Latn
-        {0xA02F0000, 40}, // pbi -> Latn
-        {0x8C4F0000, 40}, // pcd -> Latn
-        {0xB04F0000, 40}, // pcm -> Latn
-        {0x886F0000, 40}, // pdc -> Latn
-        {0xCC6F0000, 40}, // pdt -> Latn
-        {0x8C8F0000, 40}, // ped -> Latn
-        {0xB88F0000, 84}, // peo -> Xpeo
-        {0xDC8F0000, 40}, // pex -> Latn
-        {0xACAF0000, 40}, // pfl -> Latn
-        {0xACEF0000,  1}, // phl -> Arab
-        {0xB4EF0000, 61}, // phn -> Phnx
-        {0xAD0F0000, 40}, // pil -> Latn
-        {0xBD0F0000, 40}, // pip -> Latn
-        {0x814F0000,  8}, // pka -> Brah
-        {0xB94F0000, 40}, // pko -> Latn
-        {0x706C0000, 40}, // pl -> Latn
-        {0x816F0000, 40}, // pla -> Latn
-        {0xC98F0000, 40}, // pms -> Latn
-        {0x99AF0000, 40}, // png -> Latn
-        {0xB5AF0000, 40}, // pnn -> Latn
-        {0xCDAF0000, 21}, // pnt -> Grek
-        {0xB5CF0000, 40}, // pon -> Latn
-        {0xB9EF0000, 40}, // ppo -> Latn
-        {0x822F0000, 34}, // pra -> Khar
-        {0x8E2F0000,  1}, // prd -> Arab
-        {0x9A2F0000, 40}, // prg -> Latn
-        {0x70730000,  1}, // ps -> Arab
-        {0xCA4F0000, 40}, // pss -> Latn
-        {0x70740000, 40}, // pt -> Latn
-        {0xBE6F0000, 40}, // ptp -> Latn
-        {0xD28F0000, 40}, // puu -> Latn
-        {0x82CF0000, 40}, // pwa -> Latn
-        {0x71750000, 40}, // qu -> Latn
-        {0x8A900000, 40}, // quc -> Latn
-        {0x9A900000, 40}, // qug -> Latn
-        {0xA0110000, 40}, // rai -> Latn
-        {0xA4110000, 16}, // raj -> Deva
-        {0xB8110000, 40}, // rao -> Latn
-        {0x94510000, 40}, // rcf -> Latn
-        {0xA4910000, 40}, // rej -> Latn
-        {0xAC910000, 40}, // rel -> Latn
-        {0xC8910000, 40}, // res -> Latn
-        {0xB4D10000, 40}, // rgn -> Latn
-        {0x98F10000,  1}, // rhg -> Arab
-        {0x81110000, 40}, // ria -> Latn
-        {0x95110000, 78}, // rif -> Tfng
-        {0x95114E4C, 40}, // rif-NL -> Latn
-        {0xC9310000, 16}, // rjs -> Deva
-        {0xCD510000,  7}, // rkt -> Beng
-        {0x726D0000, 40}, // rm -> Latn
-        {0x95910000, 40}, // rmf -> Latn
-        {0xB9910000, 40}, // rmo -> Latn
-        {0xCD910000,  1}, // rmt -> Arab
-        {0xD1910000, 40}, // rmu -> Latn
-        {0x726E0000, 40}, // rn -> Latn
-        {0x81B10000, 40}, // rna -> Latn
-        {0x99B10000, 40}, // rng -> Latn
-        {0x726F0000, 40}, // ro -> Latn
-        {0x85D10000, 40}, // rob -> Latn
-        {0x95D10000, 40}, // rof -> Latn
-        {0xB9D10000, 40}, // roo -> Latn
-        {0xBA310000, 40}, // rro -> Latn
-        {0xB2710000, 40}, // rtm -> Latn
-        {0x72750000, 15}, // ru -> Cyrl
-        {0x92910000, 15}, // rue -> Cyrl
-        {0x9A910000, 40}, // rug -> Latn
-        {0x72770000, 40}, // rw -> Latn
-        {0xAAD10000, 40}, // rwk -> Latn
-        {0xBAD10000, 40}, // rwo -> Latn
-        {0xD3110000, 33}, // ryu -> Kana
-        {0x73610000, 16}, // sa -> Deva
-        {0x94120000, 40}, // saf -> Latn
-        {0x9C120000, 15}, // sah -> Cyrl
-        {0xC0120000, 40}, // saq -> Latn
-        {0xC8120000, 40}, // sas -> Latn
-        {0xCC120000, 40}, // sat -> Latn
-        {0xE4120000, 67}, // saz -> Saur
-        {0x80320000, 40}, // sba -> Latn
-        {0x90320000, 40}, // sbe -> Latn
-        {0xBC320000, 40}, // sbp -> Latn
-        {0x73630000, 40}, // sc -> Latn
-        {0xA8520000, 16}, // sck -> Deva
-        {0xAC520000,  1}, // scl -> Arab
-        {0xB4520000, 40}, // scn -> Latn
-        {0xB8520000, 40}, // sco -> Latn
-        {0xC8520000, 40}, // scs -> Latn
-        {0x73640000,  1}, // sd -> Arab
-        {0x88720000, 40}, // sdc -> Latn
-        {0x9C720000,  1}, // sdh -> Arab
-        {0x73650000, 40}, // se -> Latn
-        {0x94920000, 40}, // sef -> Latn
-        {0x9C920000, 40}, // seh -> Latn
-        {0xA0920000, 40}, // sei -> Latn
-        {0xC8920000, 40}, // ses -> Latn
-        {0x73670000, 40}, // sg -> Latn
-        {0x80D20000, 55}, // sga -> Ogam
-        {0xC8D20000, 40}, // sgs -> Latn
-        {0xD8D20000, 18}, // sgw -> Ethi
-        {0xE4D20000, 40}, // sgz -> Latn
-        {0x73680000, 40}, // sh -> Latn
-        {0xA0F20000, 78}, // shi -> Tfng
-        {0xA8F20000, 40}, // shk -> Latn
-        {0xB4F20000, 52}, // shn -> Mymr
-        {0xD0F20000,  1}, // shu -> Arab
-        {0x73690000, 69}, // si -> Sinh
-        {0x8D120000, 40}, // sid -> Latn
-        {0x99120000, 40}, // sig -> Latn
-        {0xAD120000, 40}, // sil -> Latn
-        {0xB1120000, 40}, // sim -> Latn
-        {0xC5320000, 40}, // sjr -> Latn
-        {0x736B0000, 40}, // sk -> Latn
-        {0x89520000, 40}, // skc -> Latn
-        {0xC5520000,  1}, // skr -> Arab
-        {0xC9520000, 40}, // sks -> Latn
-        {0x736C0000, 40}, // sl -> Latn
-        {0x8D720000, 40}, // sld -> Latn
-        {0xA1720000, 40}, // sli -> Latn
-        {0xAD720000, 40}, // sll -> Latn
-        {0xE1720000, 40}, // sly -> Latn
-        {0x736D0000, 40}, // sm -> Latn
-        {0x81920000, 40}, // sma -> Latn
-        {0xA5920000, 40}, // smj -> Latn
-        {0xB5920000, 40}, // smn -> Latn
-        {0xBD920000, 65}, // smp -> Samr
-        {0xC1920000, 40}, // smq -> Latn
-        {0xC9920000, 40}, // sms -> Latn
-        {0x736E0000, 40}, // sn -> Latn
-        {0x89B20000, 40}, // snc -> Latn
-        {0xA9B20000, 40}, // snk -> Latn
-        {0xBDB20000, 40}, // snp -> Latn
-        {0xDDB20000, 40}, // snx -> Latn
-        {0xE1B20000, 40}, // sny -> Latn
-        {0x736F0000, 40}, // so -> Latn
-        {0xA9D20000, 40}, // sok -> Latn
-        {0xC1D20000, 40}, // soq -> Latn
-        {0xD1D20000, 80}, // sou -> Thai
-        {0xE1D20000, 40}, // soy -> Latn
-        {0x8DF20000, 40}, // spd -> Latn
-        {0xADF20000, 40}, // spl -> Latn
-        {0xC9F20000, 40}, // sps -> Latn
-        {0x73710000, 40}, // sq -> Latn
-        {0x73720000, 15}, // sr -> Cyrl
-        {0x73724D45, 40}, // sr-ME -> Latn
-        {0x7372524F, 40}, // sr-RO -> Latn
-        {0x73725255, 40}, // sr-RU -> Latn
-        {0x73725452, 40}, // sr-TR -> Latn
-        {0x86320000, 70}, // srb -> Sora
-        {0xB6320000, 40}, // srn -> Latn
-        {0xC6320000, 40}, // srr -> Latn
-        {0xDE320000, 16}, // srx -> Deva
-        {0x73730000, 40}, // ss -> Latn
-        {0x8E520000, 40}, // ssd -> Latn
-        {0x9A520000, 40}, // ssg -> Latn
-        {0xE2520000, 40}, // ssy -> Latn
-        {0x73740000, 40}, // st -> Latn
-        {0xAA720000, 40}, // stk -> Latn
-        {0xC2720000, 40}, // stq -> Latn
-        {0x73750000, 40}, // su -> Latn
-        {0x82920000, 40}, // sua -> Latn
-        {0x92920000, 40}, // sue -> Latn
-        {0xAA920000, 40}, // suk -> Latn
-        {0xC6920000, 40}, // sur -> Latn
-        {0xCA920000, 40}, // sus -> Latn
-        {0x73760000, 40}, // sv -> Latn
-        {0x73770000, 40}, // sw -> Latn
-        {0x86D20000,  1}, // swb -> Arab
-        {0x8AD20000, 40}, // swc -> Latn
-        {0x9AD20000, 40}, // swg -> Latn
-        {0xBED20000, 40}, // swp -> Latn
-        {0xD6D20000, 16}, // swv -> Deva
-        {0xB6F20000, 40}, // sxn -> Latn
-        {0xDAF20000, 40}, // sxw -> Latn
-        {0xAF120000,  7}, // syl -> Beng
-        {0xC7120000, 71}, // syr -> Syrc
-        {0xAF320000, 40}, // szl -> Latn
-        {0x74610000, 74}, // ta -> Taml
-        {0xA4130000, 16}, // taj -> Deva
-        {0xAC130000, 40}, // tal -> Latn
-        {0xB4130000, 40}, // tan -> Latn
-        {0xC0130000, 40}, // taq -> Latn
-        {0x88330000, 40}, // tbc -> Latn
-        {0x8C330000, 40}, // tbd -> Latn
-        {0x94330000, 40}, // tbf -> Latn
-        {0x98330000, 40}, // tbg -> Latn
-        {0xB8330000, 40}, // tbo -> Latn
-        {0xD8330000, 40}, // tbw -> Latn
-        {0xE4330000, 40}, // tbz -> Latn
-        {0xA0530000, 40}, // tci -> Latn
-        {0xE0530000, 36}, // tcy -> Knda
-        {0x8C730000, 72}, // tdd -> Tale
-        {0x98730000, 16}, // tdg -> Deva
-        {0x9C730000, 16}, // tdh -> Deva
-        {0x74650000, 77}, // te -> Telu
-        {0x8C930000, 40}, // ted -> Latn
-        {0xB0930000, 40}, // tem -> Latn
-        {0xB8930000, 40}, // teo -> Latn
-        {0xCC930000, 40}, // tet -> Latn
-        {0xA0B30000, 40}, // tfi -> Latn
-        {0x74670000, 15}, // tg -> Cyrl
-        {0x7467504B,  1}, // tg-PK -> Arab
-        {0x88D30000, 40}, // tgc -> Latn
-        {0xB8D30000, 40}, // tgo -> Latn
-        {0xD0D30000, 40}, // tgu -> Latn
-        {0x74680000, 80}, // th -> Thai
-        {0xACF30000, 16}, // thl -> Deva
-        {0xC0F30000, 16}, // thq -> Deva
-        {0xC4F30000, 16}, // thr -> Deva
-        {0x74690000, 18}, // ti -> Ethi
-        {0x95130000, 40}, // tif -> Latn
-        {0x99130000, 18}, // tig -> Ethi
-        {0xA9130000, 40}, // tik -> Latn
-        {0xB1130000, 40}, // tim -> Latn
-        {0xB9130000, 40}, // tio -> Latn
-        {0xD5130000, 40}, // tiv -> Latn
-        {0x746B0000, 40}, // tk -> Latn
-        {0xAD530000, 40}, // tkl -> Latn
-        {0xC5530000, 40}, // tkr -> Latn
-        {0xCD530000, 16}, // tkt -> Deva
-        {0x746C0000, 40}, // tl -> Latn
-        {0x95730000, 40}, // tlf -> Latn
-        {0xDD730000, 40}, // tlx -> Latn
-        {0xE1730000, 40}, // tly -> Latn
-        {0x9D930000, 40}, // tmh -> Latn
-        {0xE1930000, 40}, // tmy -> Latn
-        {0x746E0000, 40}, // tn -> Latn
-        {0x9DB30000, 40}, // tnh -> Latn
-        {0x746F0000, 40}, // to -> Latn
-        {0x95D30000, 40}, // tof -> Latn
-        {0x99D30000, 40}, // tog -> Latn
-        {0xC1D30000, 40}, // toq -> Latn
-        {0xA1F30000, 40}, // tpi -> Latn
-        {0xB1F30000, 40}, // tpm -> Latn
-        {0xE5F30000, 40}, // tpz -> Latn
-        {0xBA130000, 40}, // tqo -> Latn
-        {0x74720000, 40}, // tr -> Latn
-        {0xD2330000, 40}, // tru -> Latn
-        {0xD6330000, 40}, // trv -> Latn
-        {0xDA330000,  1}, // trw -> Arab
-        {0x74730000, 40}, // ts -> Latn
-        {0x8E530000, 21}, // tsd -> Grek
-        {0x96530000, 16}, // tsf -> Deva
-        {0x9A530000, 40}, // tsg -> Latn
-        {0xA6530000, 81}, // tsj -> Tibt
-        {0xDA530000, 40}, // tsw -> Latn
-        {0x74740000, 15}, // tt -> Cyrl
-        {0x8E730000, 40}, // ttd -> Latn
-        {0x92730000, 40}, // tte -> Latn
-        {0xA6730000, 40}, // ttj -> Latn
-        {0xC6730000, 40}, // ttr -> Latn
-        {0xCA730000, 80}, // tts -> Thai
-        {0xCE730000, 40}, // ttt -> Latn
-        {0x9E930000, 40}, // tuh -> Latn
-        {0xAE930000, 40}, // tul -> Latn
-        {0xB2930000, 40}, // tum -> Latn
-        {0xC2930000, 40}, // tuq -> Latn
-        {0x8EB30000, 40}, // tvd -> Latn
-        {0xAEB30000, 40}, // tvl -> Latn
-        {0xD2B30000, 40}, // tvu -> Latn
-        {0x9ED30000, 40}, // twh -> Latn
-        {0xC2D30000, 40}, // twq -> Latn
-        {0x9AF30000, 75}, // txg -> Tang
-        {0x74790000, 40}, // ty -> Latn
-        {0x83130000, 40}, // tya -> Latn
-        {0xD7130000, 15}, // tyv -> Cyrl
-        {0xB3330000, 40}, // tzm -> Latn
-        {0xD0340000, 40}, // ubu -> Latn
-        {0xB0740000, 15}, // udm -> Cyrl
-        {0x75670000,  1}, // ug -> Arab
-        {0x75674B5A, 15}, // ug-KZ -> Cyrl
-        {0x75674D4E, 15}, // ug-MN -> Cyrl
-        {0x80D40000, 82}, // uga -> Ugar
-        {0x756B0000, 15}, // uk -> Cyrl
-        {0xA1740000, 40}, // uli -> Latn
-        {0x85940000, 40}, // umb -> Latn
-        {0xC5B40000,  7}, // unr -> Beng
-        {0xC5B44E50, 16}, // unr-NP -> Deva
-        {0xDDB40000,  7}, // unx -> Beng
-        {0x75720000,  1}, // ur -> Arab
-        {0xA2340000, 40}, // uri -> Latn
-        {0xCE340000, 40}, // urt -> Latn
-        {0xDA340000, 40}, // urw -> Latn
-        {0x82540000, 40}, // usa -> Latn
-        {0xC6740000, 40}, // utr -> Latn
-        {0x9EB40000, 40}, // uvh -> Latn
-        {0xAEB40000, 40}, // uvl -> Latn
-        {0x757A0000, 40}, // uz -> Latn
-        {0x757A4146,  1}, // uz-AF -> Arab
-        {0x757A434E, 15}, // uz-CN -> Cyrl
-        {0x98150000, 40}, // vag -> Latn
-        {0xA0150000, 83}, // vai -> Vaii
-        {0xB4150000, 40}, // van -> Latn
-        {0x76650000, 40}, // ve -> Latn
-        {0x88950000, 40}, // vec -> Latn
-        {0xBC950000, 40}, // vep -> Latn
-        {0x76690000, 40}, // vi -> Latn
-        {0x89150000, 40}, // vic -> Latn
-        {0xD5150000, 40}, // viv -> Latn
-        {0xC9750000, 40}, // vls -> Latn
-        {0x95950000, 40}, // vmf -> Latn
-        {0xD9950000, 40}, // vmw -> Latn
-        {0x766F0000, 40}, // vo -> Latn
-        {0xCDD50000, 40}, // vot -> Latn
-        {0xBA350000, 40}, // vro -> Latn
-        {0xB6950000, 40}, // vun -> Latn
-        {0xCE950000, 40}, // vut -> Latn
-        {0x77610000, 40}, // wa -> Latn
-        {0x90160000, 40}, // wae -> Latn
-        {0xA4160000, 40}, // waj -> Latn
-        {0xAC160000, 18}, // wal -> Ethi
-        {0xB4160000, 40}, // wan -> Latn
-        {0xC4160000, 40}, // war -> Latn
-        {0xBC360000, 40}, // wbp -> Latn
-        {0xC0360000, 77}, // wbq -> Telu
-        {0xC4360000, 16}, // wbr -> Deva
-        {0xA0560000, 40}, // wci -> Latn
-        {0xC4960000, 40}, // wer -> Latn
-        {0xA0D60000, 40}, // wgi -> Latn
-        {0x98F60000, 40}, // whg -> Latn
-        {0x85160000, 40}, // wib -> Latn
-        {0xD1160000, 40}, // wiu -> Latn
-        {0xD5160000, 40}, // wiv -> Latn
-        {0x81360000, 40}, // wja -> Latn
-        {0xA1360000, 40}, // wji -> Latn
-        {0xC9760000, 40}, // wls -> Latn
-        {0xB9960000, 40}, // wmo -> Latn
-        {0x89B60000, 40}, // wnc -> Latn
-        {0xA1B60000,  1}, // wni -> Arab
-        {0xD1B60000, 40}, // wnu -> Latn
-        {0x776F0000, 40}, // wo -> Latn
-        {0x85D60000, 40}, // wob -> Latn
-        {0xC9D60000, 40}, // wos -> Latn
-        {0xCA360000, 40}, // wrs -> Latn
-        {0xAA560000, 40}, // wsk -> Latn
-        {0xB2760000, 16}, // wtm -> Deva
-        {0xD2960000, 24}, // wuu -> Hans
-        {0xD6960000, 40}, // wuv -> Latn
-        {0x82D60000, 40}, // wwa -> Latn
-        {0xD4170000, 40}, // xav -> Latn
-        {0xA0370000, 40}, // xbi -> Latn
-        {0xC4570000, 10}, // xcr -> Cari
-        {0xC8970000, 40}, // xes -> Latn
-        {0x78680000, 40}, // xh -> Latn
-        {0x81770000, 40}, // xla -> Latn
-        {0x89770000, 44}, // xlc -> Lyci
-        {0x8D770000, 45}, // xld -> Lydi
-        {0x95970000, 19}, // xmf -> Geor
-        {0xB5970000, 47}, // xmn -> Mani
-        {0xC5970000, 48}, // xmr -> Merc
-        {0x81B70000, 53}, // xna -> Narb
-        {0xC5B70000, 16}, // xnr -> Deva
-        {0x99D70000, 40}, // xog -> Latn
-        {0xB5D70000, 40}, // xon -> Latn
-        {0xC5F70000, 63}, // xpr -> Prti
-        {0x86370000, 40}, // xrb -> Latn
-        {0x82570000, 66}, // xsa -> Sarb
-        {0xA2570000, 40}, // xsi -> Latn
-        {0xB2570000, 40}, // xsm -> Latn
-        {0xC6570000, 16}, // xsr -> Deva
-        {0x92D70000, 40}, // xwe -> Latn
-        {0xB0180000, 40}, // yam -> Latn
-        {0xB8180000, 40}, // yao -> Latn
-        {0xBC180000, 40}, // yap -> Latn
-        {0xC8180000, 40}, // yas -> Latn
-        {0xCC180000, 40}, // yat -> Latn
-        {0xD4180000, 40}, // yav -> Latn
-        {0xE0180000, 40}, // yay -> Latn
-        {0xE4180000, 40}, // yaz -> Latn
-        {0x80380000, 40}, // yba -> Latn
-        {0x84380000, 40}, // ybb -> Latn
-        {0xE0380000, 40}, // yby -> Latn
-        {0xC4980000, 40}, // yer -> Latn
-        {0xC4D80000, 40}, // ygr -> Latn
-        {0xD8D80000, 40}, // ygw -> Latn
-        {0x79690000, 27}, // yi -> Hebr
-        {0xB9580000, 40}, // yko -> Latn
-        {0x91780000, 40}, // yle -> Latn
-        {0x99780000, 40}, // ylg -> Latn
-        {0xAD780000, 40}, // yll -> Latn
-        {0xAD980000, 40}, // yml -> Latn
-        {0x796F0000, 40}, // yo -> Latn
-        {0xB5D80000, 40}, // yon -> Latn
-        {0x86380000, 40}, // yrb -> Latn
-        {0x92380000, 40}, // yre -> Latn
-        {0xAE380000, 40}, // yrl -> Latn
-        {0xCA580000, 40}, // yss -> Latn
-        {0x82980000, 40}, // yua -> Latn
-        {0x92980000, 25}, // yue -> Hant
-        {0x9298434E, 24}, // yue-CN -> Hans
-        {0xA6980000, 40}, // yuj -> Latn
-        {0xCE980000, 40}, // yut -> Latn
-        {0xDA980000, 40}, // yuw -> Latn
-        {0x7A610000, 40}, // za -> Latn
-        {0x98190000, 40}, // zag -> Latn
-        {0xA4790000,  1}, // zdj -> Arab
-        {0x80990000, 40}, // zea -> Latn
-        {0x9CD90000, 78}, // zgh -> Tfng
-        {0x7A680000, 24}, // zh -> Hans
-        {0x7A684155, 25}, // zh-AU -> Hant
-        {0x7A68424E, 25}, // zh-BN -> Hant
-        {0x7A684742, 25}, // zh-GB -> Hant
-        {0x7A684746, 25}, // zh-GF -> Hant
-        {0x7A68484B, 25}, // zh-HK -> Hant
-        {0x7A684944, 25}, // zh-ID -> Hant
-        {0x7A684D4F, 25}, // zh-MO -> Hant
-        {0x7A684D59, 25}, // zh-MY -> Hant
-        {0x7A685041, 25}, // zh-PA -> Hant
-        {0x7A685046, 25}, // zh-PF -> Hant
-        {0x7A685048, 25}, // zh-PH -> Hant
-        {0x7A685352, 25}, // zh-SR -> Hant
-        {0x7A685448, 25}, // zh-TH -> Hant
-        {0x7A685457, 25}, // zh-TW -> Hant
-        {0x7A685553, 25}, // zh-US -> Hant
-        {0x7A68564E, 25}, // zh-VN -> Hant
-        {0x81190000, 40}, // zia -> Latn
-        {0xB1790000, 40}, // zlm -> Latn
-        {0xA1990000, 40}, // zmi -> Latn
-        {0x91B90000, 40}, // zne -> Latn
-        {0x7A750000, 40}, // zu -> Latn
-        {0x83390000, 40}, // zza -> Latn
+      {0x61610000, 40}, // aa -> Latn
+      {0xA0000000, 40}, // aai -> Latn
+      {0xA8000000, 40}, // aak -> Latn
+      {0xD0000000, 40}, // aau -> Latn
+      {0x61620000, 15}, // ab -> Cyrl
+      {0xA0200000, 40}, // abi -> Latn
+      {0xC4200000, 40}, // abr -> Latn
+      {0xCC200000, 40}, // abt -> Latn
+      {0xE0200000, 40}, // aby -> Latn
+      {0x8C400000, 40}, // acd -> Latn
+      {0x90400000, 40}, // ace -> Latn
+      {0x9C400000, 40}, // ach -> Latn
+      {0x80600000, 40}, // ada -> Latn
+      {0x90600000, 40}, // ade -> Latn
+      {0xA4600000, 40}, // adj -> Latn
+      {0xE0600000, 15}, // ady -> Cyrl
+      {0xE4600000, 40}, // adz -> Latn
+      {0x61650000, 4}, // ae -> Avst
+      {0x84800000, 1}, // aeb -> Arab
+      {0xE0800000, 40}, // aey -> Latn
+      {0x61660000, 40}, // af -> Latn
+      {0x88C00000, 40}, // agc -> Latn
+      {0x8CC00000, 40}, // agd -> Latn
+      {0x98C00000, 40}, // agg -> Latn
+      {0xB0C00000, 40}, // agm -> Latn
+      {0xB8C00000, 40}, // ago -> Latn
+      {0xC0C00000, 40}, // agq -> Latn
+      {0x80E00000, 40}, // aha -> Latn
+      {0xACE00000, 40}, // ahl -> Latn
+      {0xB8E00000, 0}, // aho -> Ahom
+      {0x99200000, 40}, // ajg -> Latn
+      {0x616B0000, 40}, // ak -> Latn
+      {0xA9400000, 85}, // akk -> Xsux
+      {0x81600000, 40}, // ala -> Latn
+      {0xA1600000, 40}, // ali -> Latn
+      {0xB5600000, 40}, // aln -> Latn
+      {0xCD600000, 15}, // alt -> Cyrl
+      {0x616D0000, 18}, // am -> Ethi
+      {0xB1800000, 40}, // amm -> Latn
+      {0xB5800000, 40}, // amn -> Latn
+      {0xB9800000, 40}, // amo -> Latn
+      {0xBD800000, 40}, // amp -> Latn
+      {0x89A00000, 40}, // anc -> Latn
+      {0xA9A00000, 40}, // ank -> Latn
+      {0xB5A00000, 40}, // ann -> Latn
+      {0xE1A00000, 40}, // any -> Latn
+      {0xA5C00000, 40}, // aoj -> Latn
+      {0xB1C00000, 40}, // aom -> Latn
+      {0xE5C00000, 40}, // aoz -> Latn
+      {0x89E00000, 1}, // apc -> Arab
+      {0x8DE00000, 1}, // apd -> Arab
+      {0x91E00000, 40}, // ape -> Latn
+      {0xC5E00000, 40}, // apr -> Latn
+      {0xC9E00000, 40}, // aps -> Latn
+      {0xE5E00000, 40}, // apz -> Latn
+      {0x61720000, 1}, // ar -> Arab
+      {0x61725842, 88}, // ar-XB -> ~~~B
+      {0x8A200000, 2}, // arc -> Armi
+      {0x9E200000, 40}, // arh -> Latn
+      {0xB6200000, 40}, // arn -> Latn
+      {0xBA200000, 40}, // aro -> Latn
+      {0xC2200000, 1}, // arq -> Arab
+      {0xE2200000, 1}, // ary -> Arab
+      {0xE6200000, 1}, // arz -> Arab
+      {0x61730000, 7}, // as -> Beng
+      {0x82400000, 40}, // asa -> Latn
+      {0x92400000, 68}, // ase -> Sgnw
+      {0x9A400000, 40}, // asg -> Latn
+      {0xBA400000, 40}, // aso -> Latn
+      {0xCE400000, 40}, // ast -> Latn
+      {0x82600000, 40}, // ata -> Latn
+      {0x9A600000, 40}, // atg -> Latn
+      {0xA6600000, 40}, // atj -> Latn
+      {0xE2800000, 40}, // auy -> Latn
+      {0x61760000, 15}, // av -> Cyrl
+      {0xAEA00000, 1}, // avl -> Arab
+      {0xB6A00000, 40}, // avn -> Latn
+      {0xCEA00000, 40}, // avt -> Latn
+      {0xD2A00000, 40}, // avu -> Latn
+      {0x82C00000, 16}, // awa -> Deva
+      {0x86C00000, 40}, // awb -> Latn
+      {0xBAC00000, 40}, // awo -> Latn
+      {0xDEC00000, 40}, // awx -> Latn
+      {0x61790000, 40}, // ay -> Latn
+      {0x87000000, 40}, // ayb -> Latn
+      {0x617A0000, 40}, // az -> Latn
+      {0x617A4951, 1}, // az-IQ -> Arab
+      {0x617A4952, 1}, // az-IR -> Arab
+      {0x617A5255, 15}, // az-RU -> Cyrl
+      {0x62610000, 15}, // ba -> Cyrl
+      {0xAC010000, 1}, // bal -> Arab
+      {0xB4010000, 40}, // ban -> Latn
+      {0xBC010000, 16}, // bap -> Deva
+      {0xC4010000, 40}, // bar -> Latn
+      {0xC8010000, 40}, // bas -> Latn
+      {0xD4010000, 40}, // bav -> Latn
+      {0xDC010000, 5}, // bax -> Bamu
+      {0x80210000, 40}, // bba -> Latn
+      {0x84210000, 40}, // bbb -> Latn
+      {0x88210000, 40}, // bbc -> Latn
+      {0x8C210000, 40}, // bbd -> Latn
+      {0xA4210000, 40}, // bbj -> Latn
+      {0xBC210000, 40}, // bbp -> Latn
+      {0xC4210000, 40}, // bbr -> Latn
+      {0x94410000, 40}, // bcf -> Latn
+      {0x9C410000, 40}, // bch -> Latn
+      {0xA0410000, 40}, // bci -> Latn
+      {0xB0410000, 40}, // bcm -> Latn
+      {0xB4410000, 40}, // bcn -> Latn
+      {0xB8410000, 40}, // bco -> Latn
+      {0xC0410000, 18}, // bcq -> Ethi
+      {0xD0410000, 40}, // bcu -> Latn
+      {0x8C610000, 40}, // bdd -> Latn
+      {0x62650000, 15}, // be -> Cyrl
+      {0x94810000, 40}, // bef -> Latn
+      {0x9C810000, 40}, // beh -> Latn
+      {0xA4810000, 1}, // bej -> Arab
+      {0xB0810000, 40}, // bem -> Latn
+      {0xCC810000, 40}, // bet -> Latn
+      {0xD8810000, 40}, // bew -> Latn
+      {0xDC810000, 40}, // bex -> Latn
+      {0xE4810000, 40}, // bez -> Latn
+      {0x8CA10000, 40}, // bfd -> Latn
+      {0xC0A10000, 74}, // bfq -> Taml
+      {0xCCA10000, 1}, // bft -> Arab
+      {0xE0A10000, 16}, // bfy -> Deva
+      {0x62670000, 15}, // bg -> Cyrl
+      {0x88C10000, 16}, // bgc -> Deva
+      {0xB4C10000, 1}, // bgn -> Arab
+      {0xDCC10000, 21}, // bgx -> Grek
+      {0x84E10000, 16}, // bhb -> Deva
+      {0x98E10000, 40}, // bhg -> Latn
+      {0xA0E10000, 16}, // bhi -> Deva
+      {0xA8E10000, 40}, // bhk -> Latn
+      {0xACE10000, 40}, // bhl -> Latn
+      {0xB8E10000, 16}, // bho -> Deva
+      {0xE0E10000, 40}, // bhy -> Latn
+      {0x62690000, 40}, // bi -> Latn
+      {0x85010000, 40}, // bib -> Latn
+      {0x99010000, 40}, // big -> Latn
+      {0xA9010000, 40}, // bik -> Latn
+      {0xB1010000, 40}, // bim -> Latn
+      {0xB5010000, 40}, // bin -> Latn
+      {0xB9010000, 40}, // bio -> Latn
+      {0xC1010000, 40}, // biq -> Latn
+      {0x9D210000, 40}, // bjh -> Latn
+      {0xA1210000, 18}, // bji -> Ethi
+      {0xA5210000, 16}, // bjj -> Deva
+      {0xB5210000, 40}, // bjn -> Latn
+      {0xB9210000, 40}, // bjo -> Latn
+      {0xC5210000, 40}, // bjr -> Latn
+      {0xE5210000, 40}, // bjz -> Latn
+      {0x89410000, 40}, // bkc -> Latn
+      {0xB1410000, 40}, // bkm -> Latn
+      {0xC1410000, 40}, // bkq -> Latn
+      {0xD1410000, 40}, // bku -> Latn
+      {0xD5410000, 40}, // bkv -> Latn
+      {0xCD610000, 76}, // blt -> Tavt
+      {0x626D0000, 40}, // bm -> Latn
+      {0x9D810000, 40}, // bmh -> Latn
+      {0xA9810000, 40}, // bmk -> Latn
+      {0xC1810000, 40}, // bmq -> Latn
+      {0xD1810000, 40}, // bmu -> Latn
+      {0x626E0000, 7}, // bn -> Beng
+      {0x99A10000, 40}, // bng -> Latn
+      {0xB1A10000, 40}, // bnm -> Latn
+      {0xBDA10000, 40}, // bnp -> Latn
+      {0x626F0000, 81}, // bo -> Tibt
+      {0xA5C10000, 40}, // boj -> Latn
+      {0xB1C10000, 40}, // bom -> Latn
+      {0xB5C10000, 40}, // bon -> Latn
+      {0xE1E10000, 7}, // bpy -> Beng
+      {0x8A010000, 40}, // bqc -> Latn
+      {0xA2010000, 1}, // bqi -> Arab
+      {0xBE010000, 40}, // bqp -> Latn
+      {0xD6010000, 40}, // bqv -> Latn
+      {0x62720000, 40}, // br -> Latn
+      {0x82210000, 16}, // bra -> Deva
+      {0x9E210000, 1}, // brh -> Arab
+      {0xDE210000, 16}, // brx -> Deva
+      {0xE6210000, 40}, // brz -> Latn
+      {0x62730000, 40}, // bs -> Latn
+      {0xA6410000, 40}, // bsj -> Latn
+      {0xC2410000, 6}, // bsq -> Bass
+      {0xCA410000, 40}, // bss -> Latn
+      {0xCE410000, 18}, // bst -> Ethi
+      {0xBA610000, 40}, // bto -> Latn
+      {0xCE610000, 40}, // btt -> Latn
+      {0xD6610000, 16}, // btv -> Deva
+      {0x82810000, 15}, // bua -> Cyrl
+      {0x8A810000, 40}, // buc -> Latn
+      {0x8E810000, 40}, // bud -> Latn
+      {0x9A810000, 40}, // bug -> Latn
+      {0xAA810000, 40}, // buk -> Latn
+      {0xB2810000, 40}, // bum -> Latn
+      {0xBA810000, 40}, // buo -> Latn
+      {0xCA810000, 40}, // bus -> Latn
+      {0xD2810000, 40}, // buu -> Latn
+      {0x86A10000, 40}, // bvb -> Latn
+      {0x8EC10000, 40}, // bwd -> Latn
+      {0xC6C10000, 40}, // bwr -> Latn
+      {0x9EE10000, 40}, // bxh -> Latn
+      {0x93010000, 40}, // bye -> Latn
+      {0xB7010000, 18}, // byn -> Ethi
+      {0xC7010000, 40}, // byr -> Latn
+      {0xCB010000, 40}, // bys -> Latn
+      {0xD7010000, 40}, // byv -> Latn
+      {0xDF010000, 40}, // byx -> Latn
+      {0x83210000, 40}, // bza -> Latn
+      {0x93210000, 40}, // bze -> Latn
+      {0x97210000, 40}, // bzf -> Latn
+      {0x9F210000, 40}, // bzh -> Latn
+      {0xDB210000, 40}, // bzw -> Latn
+      {0x63610000, 40}, // ca -> Latn
+      {0xB4020000, 40}, // can -> Latn
+      {0xA4220000, 40}, // cbj -> Latn
+      {0x9C420000, 40}, // cch -> Latn
+      {0xBC420000, 7}, // ccp -> Beng
+      {0x63650000, 15}, // ce -> Cyrl
+      {0x84820000, 40}, // ceb -> Latn
+      {0x80A20000, 40}, // cfa -> Latn
+      {0x98C20000, 40}, // cgg -> Latn
+      {0x63680000, 40}, // ch -> Latn
+      {0xA8E20000, 40}, // chk -> Latn
+      {0xB0E20000, 15}, // chm -> Cyrl
+      {0xB8E20000, 40}, // cho -> Latn
+      {0xBCE20000, 40}, // chp -> Latn
+      {0xC4E20000, 12}, // chr -> Cher
+      {0x81220000, 1}, // cja -> Arab
+      {0xB1220000, 11}, // cjm -> Cham
+      {0xD5220000, 40}, // cjv -> Latn
+      {0x85420000, 1}, // ckb -> Arab
+      {0xAD420000, 40}, // ckl -> Latn
+      {0xB9420000, 40}, // cko -> Latn
+      {0xE1420000, 40}, // cky -> Latn
+      {0x81620000, 40}, // cla -> Latn
+      {0x91820000, 40}, // cme -> Latn
+      {0x636F0000, 40}, // co -> Latn
+      {0xBDC20000, 13}, // cop -> Copt
+      {0xC9E20000, 40}, // cps -> Latn
+      {0x63720000, 9}, // cr -> Cans
+      {0xA6220000, 9}, // crj -> Cans
+      {0xAA220000, 9}, // crk -> Cans
+      {0xAE220000, 9}, // crl -> Cans
+      {0xB2220000, 9}, // crm -> Cans
+      {0xCA220000, 40}, // crs -> Latn
+      {0x63730000, 40}, // cs -> Latn
+      {0x86420000, 40}, // csb -> Latn
+      {0xDA420000, 9}, // csw -> Cans
+      {0x8E620000, 59}, // ctd -> Pauc
+      {0x63750000, 15}, // cu -> Cyrl
+      {0x63760000, 15}, // cv -> Cyrl
+      {0x63790000, 40}, // cy -> Latn
+      {0x64610000, 40}, // da -> Latn
+      {0x8C030000, 40}, // dad -> Latn
+      {0x94030000, 40}, // daf -> Latn
+      {0x98030000, 40}, // dag -> Latn
+      {0x9C030000, 40}, // dah -> Latn
+      {0xA8030000, 40}, // dak -> Latn
+      {0xC4030000, 15}, // dar -> Cyrl
+      {0xD4030000, 40}, // dav -> Latn
+      {0x8C230000, 40}, // dbd -> Latn
+      {0xC0230000, 40}, // dbq -> Latn
+      {0x88430000, 1}, // dcc -> Arab
+      {0xB4630000, 40}, // ddn -> Latn
+      {0x64650000, 40}, // de -> Latn
+      {0x8C830000, 40}, // ded -> Latn
+      {0xB4830000, 40}, // den -> Latn
+      {0x80C30000, 40}, // dga -> Latn
+      {0x9CC30000, 40}, // dgh -> Latn
+      {0xA0C30000, 40}, // dgi -> Latn
+      {0xACC30000, 1}, // dgl -> Arab
+      {0xC4C30000, 40}, // dgr -> Latn
+      {0xE4C30000, 40}, // dgz -> Latn
+      {0x81030000, 40}, // dia -> Latn
+      {0x91230000, 40}, // dje -> Latn
+      {0xA5A30000, 40}, // dnj -> Latn
+      {0x85C30000, 40}, // dob -> Latn
+      {0xA1C30000, 1}, // doi -> Arab
+      {0xBDC30000, 40}, // dop -> Latn
+      {0xD9C30000, 40}, // dow -> Latn
+      {0xA2230000, 40}, // dri -> Latn
+      {0xCA230000, 18}, // drs -> Ethi
+      {0x86430000, 40}, // dsb -> Latn
+      {0xB2630000, 40}, // dtm -> Latn
+      {0xBE630000, 40}, // dtp -> Latn
+      {0xCA630000, 40}, // dts -> Latn
+      {0xE2630000, 16}, // dty -> Deva
+      {0x82830000, 40}, // dua -> Latn
+      {0x8A830000, 40}, // duc -> Latn
+      {0x8E830000, 40}, // dud -> Latn
+      {0x9A830000, 40}, // dug -> Latn
+      {0x64760000, 79}, // dv -> Thaa
+      {0x82A30000, 40}, // dva -> Latn
+      {0xDAC30000, 40}, // dww -> Latn
+      {0xBB030000, 40}, // dyo -> Latn
+      {0xD3030000, 40}, // dyu -> Latn
+      {0x647A0000, 81}, // dz -> Tibt
+      {0x9B230000, 40}, // dzg -> Latn
+      {0xD0240000, 40}, // ebu -> Latn
+      {0x65650000, 40}, // ee -> Latn
+      {0xA0A40000, 40}, // efi -> Latn
+      {0xACC40000, 40}, // egl -> Latn
+      {0xE0C40000, 17}, // egy -> Egyp
+      {0xE1440000, 32}, // eky -> Kali
+      {0x656C0000, 21}, // el -> Grek
+      {0x81840000, 40}, // ema -> Latn
+      {0xA1840000, 40}, // emi -> Latn
+      {0x656E0000, 40}, // en -> Latn
+      {0x656E5841, 87}, // en-XA -> ~~~A
+      {0xB5A40000, 40}, // enn -> Latn
+      {0xC1A40000, 40}, // enq -> Latn
+      {0x656F0000, 40}, // eo -> Latn
+      {0xA2240000, 40}, // eri -> Latn
+      {0x65730000, 40}, // es -> Latn
+      {0xD2440000, 40}, // esu -> Latn
+      {0x65740000, 40}, // et -> Latn
+      {0xC6640000, 40}, // etr -> Latn
+      {0xCE640000, 30}, // ett -> Ital
+      {0xD2640000, 40}, // etu -> Latn
+      {0xDE640000, 40}, // etx -> Latn
+      {0x65750000, 40}, // eu -> Latn
+      {0xBAC40000, 40}, // ewo -> Latn
+      {0xCEE40000, 40}, // ext -> Latn
+      {0x66610000, 1}, // fa -> Arab
+      {0x80050000, 40}, // faa -> Latn
+      {0x84050000, 40}, // fab -> Latn
+      {0x98050000, 40}, // fag -> Latn
+      {0xA0050000, 40}, // fai -> Latn
+      {0xB4050000, 40}, // fan -> Latn
+      {0x66660000, 40}, // ff -> Latn
+      {0xA0A50000, 40}, // ffi -> Latn
+      {0xB0A50000, 40}, // ffm -> Latn
+      {0x66690000, 40}, // fi -> Latn
+      {0x81050000, 1}, // fia -> Arab
+      {0xAD050000, 40}, // fil -> Latn
+      {0xCD050000, 40}, // fit -> Latn
+      {0x666A0000, 40}, // fj -> Latn
+      {0xC5650000, 40}, // flr -> Latn
+      {0xBD850000, 40}, // fmp -> Latn
+      {0x666F0000, 40}, // fo -> Latn
+      {0x8DC50000, 40}, // fod -> Latn
+      {0xB5C50000, 40}, // fon -> Latn
+      {0xC5C50000, 40}, // for -> Latn
+      {0x91E50000, 40}, // fpe -> Latn
+      {0xCA050000, 40}, // fqs -> Latn
+      {0x66720000, 40}, // fr -> Latn
+      {0x8A250000, 40}, // frc -> Latn
+      {0xBE250000, 40}, // frp -> Latn
+      {0xC6250000, 40}, // frr -> Latn
+      {0xCA250000, 40}, // frs -> Latn
+      {0x86850000, 1}, // fub -> Arab
+      {0x8E850000, 40}, // fud -> Latn
+      {0x92850000, 40}, // fue -> Latn
+      {0x96850000, 40}, // fuf -> Latn
+      {0x9E850000, 40}, // fuh -> Latn
+      {0xC2850000, 40}, // fuq -> Latn
+      {0xC6850000, 40}, // fur -> Latn
+      {0xD6850000, 40}, // fuv -> Latn
+      {0xE2850000, 40}, // fuy -> Latn
+      {0xC6A50000, 40}, // fvr -> Latn
+      {0x66790000, 40}, // fy -> Latn
+      {0x67610000, 40}, // ga -> Latn
+      {0x80060000, 40}, // gaa -> Latn
+      {0x94060000, 40}, // gaf -> Latn
+      {0x98060000, 40}, // gag -> Latn
+      {0x9C060000, 40}, // gah -> Latn
+      {0xA4060000, 40}, // gaj -> Latn
+      {0xB0060000, 40}, // gam -> Latn
+      {0xB4060000, 24}, // gan -> Hans
+      {0xD8060000, 40}, // gaw -> Latn
+      {0xE0060000, 40}, // gay -> Latn
+      {0x94260000, 40}, // gbf -> Latn
+      {0xB0260000, 16}, // gbm -> Deva
+      {0xE0260000, 40}, // gby -> Latn
+      {0xE4260000, 1}, // gbz -> Arab
+      {0xC4460000, 40}, // gcr -> Latn
+      {0x67640000, 40}, // gd -> Latn
+      {0x90660000, 40}, // gde -> Latn
+      {0xB4660000, 40}, // gdn -> Latn
+      {0xC4660000, 40}, // gdr -> Latn
+      {0x84860000, 40}, // geb -> Latn
+      {0xA4860000, 40}, // gej -> Latn
+      {0xAC860000, 40}, // gel -> Latn
+      {0xE4860000, 18}, // gez -> Ethi
+      {0xA8A60000, 40}, // gfk -> Latn
+      {0xB4C60000, 16}, // ggn -> Deva
+      {0xC8E60000, 40}, // ghs -> Latn
+      {0xAD060000, 40}, // gil -> Latn
+      {0xB1060000, 40}, // gim -> Latn
+      {0xA9260000, 1}, // gjk -> Arab
+      {0xB5260000, 40}, // gjn -> Latn
+      {0xD1260000, 1}, // gju -> Arab
+      {0xB5460000, 40}, // gkn -> Latn
+      {0xBD460000, 40}, // gkp -> Latn
+      {0x676C0000, 40}, // gl -> Latn
+      {0xA9660000, 1}, // glk -> Arab
+      {0xB1860000, 40}, // gmm -> Latn
+      {0xD5860000, 18}, // gmv -> Ethi
+      {0x676E0000, 40}, // gn -> Latn
+      {0x8DA60000, 40}, // gnd -> Latn
+      {0x99A60000, 40}, // gng -> Latn
+      {0x8DC60000, 40}, // god -> Latn
+      {0x95C60000, 18}, // gof -> Ethi
+      {0xA1C60000, 40}, // goi -> Latn
+      {0xB1C60000, 16}, // gom -> Deva
+      {0xB5C60000, 77}, // gon -> Telu
+      {0xC5C60000, 40}, // gor -> Latn
+      {0xC9C60000, 40}, // gos -> Latn
+      {0xCDC60000, 20}, // got -> Goth
+      {0x8A260000, 14}, // grc -> Cprt
+      {0xCE260000, 7}, // grt -> Beng
+      {0xDA260000, 40}, // grw -> Latn
+      {0xDA460000, 40}, // gsw -> Latn
+      {0x67750000, 22}, // gu -> Gujr
+      {0x86860000, 40}, // gub -> Latn
+      {0x8A860000, 40}, // guc -> Latn
+      {0x8E860000, 40}, // gud -> Latn
+      {0xC6860000, 40}, // gur -> Latn
+      {0xDA860000, 40}, // guw -> Latn
+      {0xDE860000, 40}, // gux -> Latn
+      {0xE6860000, 40}, // guz -> Latn
+      {0x67760000, 40}, // gv -> Latn
+      {0x96A60000, 40}, // gvf -> Latn
+      {0xC6A60000, 16}, // gvr -> Deva
+      {0xCAA60000, 40}, // gvs -> Latn
+      {0x8AC60000, 1}, // gwc -> Arab
+      {0xA2C60000, 40}, // gwi -> Latn
+      {0xCEC60000, 1}, // gwt -> Arab
+      {0xA3060000, 40}, // gyi -> Latn
+      {0x68610000, 40}, // ha -> Latn
+      {0x6861434D, 1}, // ha-CM -> Arab
+      {0x68615344, 1}, // ha-SD -> Arab
+      {0x98070000, 40}, // hag -> Latn
+      {0xA8070000, 24}, // hak -> Hans
+      {0xB0070000, 40}, // ham -> Latn
+      {0xD8070000, 40}, // haw -> Latn
+      {0xE4070000, 1}, // haz -> Arab
+      {0x84270000, 40}, // hbb -> Latn
+      {0xE0670000, 18}, // hdy -> Ethi
+      {0x68650000, 27}, // he -> Hebr
+      {0xE0E70000, 40}, // hhy -> Latn
+      {0x68690000, 16}, // hi -> Deva
+      {0x81070000, 40}, // hia -> Latn
+      {0x95070000, 40}, // hif -> Latn
+      {0x99070000, 40}, // hig -> Latn
+      {0x9D070000, 40}, // hih -> Latn
+      {0xAD070000, 40}, // hil -> Latn
+      {0x81670000, 40}, // hla -> Latn
+      {0xD1670000, 28}, // hlu -> Hluw
+      {0x8D870000, 62}, // hmd -> Plrd
+      {0xCD870000, 40}, // hmt -> Latn
+      {0x8DA70000, 1}, // hnd -> Arab
+      {0x91A70000, 16}, // hne -> Deva
+      {0xA5A70000, 29}, // hnj -> Hmng
+      {0xB5A70000, 40}, // hnn -> Latn
+      {0xB9A70000, 1}, // hno -> Arab
+      {0x686F0000, 40}, // ho -> Latn
+      {0x89C70000, 16}, // hoc -> Deva
+      {0xA5C70000, 16}, // hoj -> Deva
+      {0xCDC70000, 40}, // hot -> Latn
+      {0x68720000, 40}, // hr -> Latn
+      {0x86470000, 40}, // hsb -> Latn
+      {0xB6470000, 24}, // hsn -> Hans
+      {0x68740000, 40}, // ht -> Latn
+      {0x68750000, 40}, // hu -> Latn
+      {0xA2870000, 40}, // hui -> Latn
+      {0x68790000, 3}, // hy -> Armn
+      {0x687A0000, 40}, // hz -> Latn
+      {0x69610000, 40}, // ia -> Latn
+      {0xB4080000, 40}, // ian -> Latn
+      {0xC4080000, 40}, // iar -> Latn
+      {0x80280000, 40}, // iba -> Latn
+      {0x84280000, 40}, // ibb -> Latn
+      {0xE0280000, 40}, // iby -> Latn
+      {0x80480000, 40}, // ica -> Latn
+      {0x9C480000, 40}, // ich -> Latn
+      {0x69640000, 40}, // id -> Latn
+      {0x8C680000, 40}, // idd -> Latn
+      {0xA0680000, 40}, // idi -> Latn
+      {0xD0680000, 40}, // idu -> Latn
+      {0x69670000, 40}, // ig -> Latn
+      {0x84C80000, 40}, // igb -> Latn
+      {0x90C80000, 40}, // ige -> Latn
+      {0x69690000, 86}, // ii -> Yiii
+      {0xA5280000, 40}, // ijj -> Latn
+      {0x696B0000, 40}, // ik -> Latn
+      {0xA9480000, 40}, // ikk -> Latn
+      {0xCD480000, 40}, // ikt -> Latn
+      {0xD9480000, 40}, // ikw -> Latn
+      {0xDD480000, 40}, // ikx -> Latn
+      {0xB9680000, 40}, // ilo -> Latn
+      {0xB9880000, 40}, // imo -> Latn
+      {0x696E0000, 40}, // in -> Latn
+      {0x9DA80000, 15}, // inh -> Cyrl
+      {0xD1C80000, 40}, // iou -> Latn
+      {0xA2280000, 40}, // iri -> Latn
+      {0x69730000, 40}, // is -> Latn
+      {0x69740000, 40}, // it -> Latn
+      {0x69750000, 9}, // iu -> Cans
+      {0x69770000, 27}, // iw -> Hebr
+      {0xB2C80000, 40}, // iwm -> Latn
+      {0xCAC80000, 40}, // iws -> Latn
+      {0x9F280000, 40}, // izh -> Latn
+      {0xA3280000, 40}, // izi -> Latn
+      {0x6A610000, 31}, // ja -> Jpan
+      {0x84090000, 40}, // jab -> Latn
+      {0xB0090000, 40}, // jam -> Latn
+      {0xD0290000, 40}, // jbu -> Latn
+      {0xB4890000, 40}, // jen -> Latn
+      {0xA8C90000, 40}, // jgk -> Latn
+      {0xB8C90000, 40}, // jgo -> Latn
+      {0x6A690000, 27}, // ji -> Hebr
+      {0x85090000, 40}, // jib -> Latn
+      {0x89890000, 40}, // jmc -> Latn
+      {0xAD890000, 16}, // jml -> Deva
+      {0x82290000, 40}, // jra -> Latn
+      {0xCE890000, 40}, // jut -> Latn
+      {0x6A760000, 40}, // jv -> Latn
+      {0x6A770000, 40}, // jw -> Latn
+      {0x6B610000, 19}, // ka -> Geor
+      {0x800A0000, 15}, // kaa -> Cyrl
+      {0x840A0000, 40}, // kab -> Latn
+      {0x880A0000, 40}, // kac -> Latn
+      {0x8C0A0000, 40}, // kad -> Latn
+      {0xA00A0000, 40}, // kai -> Latn
+      {0xA40A0000, 40}, // kaj -> Latn
+      {0xB00A0000, 40}, // kam -> Latn
+      {0xB80A0000, 40}, // kao -> Latn
+      {0x8C2A0000, 15}, // kbd -> Cyrl
+      {0xB02A0000, 40}, // kbm -> Latn
+      {0xBC2A0000, 40}, // kbp -> Latn
+      {0xC02A0000, 40}, // kbq -> Latn
+      {0xDC2A0000, 40}, // kbx -> Latn
+      {0xE02A0000, 1}, // kby -> Arab
+      {0x984A0000, 40}, // kcg -> Latn
+      {0xA84A0000, 40}, // kck -> Latn
+      {0xAC4A0000, 40}, // kcl -> Latn
+      {0xCC4A0000, 40}, // kct -> Latn
+      {0x906A0000, 40}, // kde -> Latn
+      {0x9C6A0000, 1}, // kdh -> Arab
+      {0xAC6A0000, 40}, // kdl -> Latn
+      {0xCC6A0000, 80}, // kdt -> Thai
+      {0x808A0000, 40}, // kea -> Latn
+      {0xB48A0000, 40}, // ken -> Latn
+      {0xE48A0000, 40}, // kez -> Latn
+      {0xB8AA0000, 40}, // kfo -> Latn
+      {0xC4AA0000, 16}, // kfr -> Deva
+      {0xE0AA0000, 16}, // kfy -> Deva
+      {0x6B670000, 40}, // kg -> Latn
+      {0x90CA0000, 40}, // kge -> Latn
+      {0x94CA0000, 40}, // kgf -> Latn
+      {0xBCCA0000, 40}, // kgp -> Latn
+      {0x80EA0000, 40}, // kha -> Latn
+      {0x84EA0000, 73}, // khb -> Talu
+      {0xB4EA0000, 16}, // khn -> Deva
+      {0xC0EA0000, 40}, // khq -> Latn
+      {0xC8EA0000, 40}, // khs -> Latn
+      {0xCCEA0000, 52}, // kht -> Mymr
+      {0xD8EA0000, 1}, // khw -> Arab
+      {0xE4EA0000, 40}, // khz -> Latn
+      {0x6B690000, 40}, // ki -> Latn
+      {0xA50A0000, 40}, // kij -> Latn
+      {0xD10A0000, 40}, // kiu -> Latn
+      {0xD90A0000, 40}, // kiw -> Latn
+      {0x6B6A0000, 40}, // kj -> Latn
+      {0x8D2A0000, 40}, // kjd -> Latn
+      {0x992A0000, 39}, // kjg -> Laoo
+      {0xC92A0000, 40}, // kjs -> Latn
+      {0xE12A0000, 40}, // kjy -> Latn
+      {0x6B6B0000, 15}, // kk -> Cyrl
+      {0x6B6B4146, 1}, // kk-AF -> Arab
+      {0x6B6B434E, 1}, // kk-CN -> Arab
+      {0x6B6B4952, 1}, // kk-IR -> Arab
+      {0x6B6B4D4E, 1}, // kk-MN -> Arab
+      {0x894A0000, 40}, // kkc -> Latn
+      {0xA54A0000, 40}, // kkj -> Latn
+      {0x6B6C0000, 40}, // kl -> Latn
+      {0xB56A0000, 40}, // kln -> Latn
+      {0xC16A0000, 40}, // klq -> Latn
+      {0xCD6A0000, 40}, // klt -> Latn
+      {0xDD6A0000, 40}, // klx -> Latn
+      {0x6B6D0000, 35}, // km -> Khmr
+      {0x858A0000, 40}, // kmb -> Latn
+      {0x9D8A0000, 40}, // kmh -> Latn
+      {0xB98A0000, 40}, // kmo -> Latn
+      {0xC98A0000, 40}, // kms -> Latn
+      {0xD18A0000, 40}, // kmu -> Latn
+      {0xD98A0000, 40}, // kmw -> Latn
+      {0x6B6E0000, 36}, // kn -> Knda
+      {0xBDAA0000, 40}, // knp -> Latn
+      {0x6B6F0000, 37}, // ko -> Kore
+      {0xA1CA0000, 15}, // koi -> Cyrl
+      {0xA9CA0000, 16}, // kok -> Deva
+      {0xADCA0000, 40}, // kol -> Latn
+      {0xC9CA0000, 40}, // kos -> Latn
+      {0xE5CA0000, 40}, // koz -> Latn
+      {0x91EA0000, 40}, // kpe -> Latn
+      {0x95EA0000, 40}, // kpf -> Latn
+      {0xB9EA0000, 40}, // kpo -> Latn
+      {0xC5EA0000, 40}, // kpr -> Latn
+      {0xDDEA0000, 40}, // kpx -> Latn
+      {0x860A0000, 40}, // kqb -> Latn
+      {0x960A0000, 40}, // kqf -> Latn
+      {0xCA0A0000, 40}, // kqs -> Latn
+      {0xE20A0000, 18}, // kqy -> Ethi
+      {0x8A2A0000, 15}, // krc -> Cyrl
+      {0xA22A0000, 40}, // kri -> Latn
+      {0xA62A0000, 40}, // krj -> Latn
+      {0xAE2A0000, 40}, // krl -> Latn
+      {0xCA2A0000, 40}, // krs -> Latn
+      {0xD22A0000, 16}, // kru -> Deva
+      {0x6B730000, 1}, // ks -> Arab
+      {0x864A0000, 40}, // ksb -> Latn
+      {0x8E4A0000, 40}, // ksd -> Latn
+      {0x964A0000, 40}, // ksf -> Latn
+      {0x9E4A0000, 40}, // ksh -> Latn
+      {0xA64A0000, 40}, // ksj -> Latn
+      {0xC64A0000, 40}, // ksr -> Latn
+      {0x866A0000, 18}, // ktb -> Ethi
+      {0xB26A0000, 40}, // ktm -> Latn
+      {0xBA6A0000, 40}, // kto -> Latn
+      {0x6B750000, 40}, // ku -> Latn
+      {0x6B754952, 1}, // ku-IR -> Arab
+      {0x6B754C42, 1}, // ku-LB -> Arab
+      {0x868A0000, 40}, // kub -> Latn
+      {0x8E8A0000, 40}, // kud -> Latn
+      {0x928A0000, 40}, // kue -> Latn
+      {0xA68A0000, 40}, // kuj -> Latn
+      {0xB28A0000, 15}, // kum -> Cyrl
+      {0xB68A0000, 40}, // kun -> Latn
+      {0xBE8A0000, 40}, // kup -> Latn
+      {0xCA8A0000, 40}, // kus -> Latn
+      {0x6B760000, 15}, // kv -> Cyrl
+      {0x9AAA0000, 40}, // kvg -> Latn
+      {0xC6AA0000, 40}, // kvr -> Latn
+      {0xDEAA0000, 1}, // kvx -> Arab
+      {0x6B770000, 40}, // kw -> Latn
+      {0xA6CA0000, 40}, // kwj -> Latn
+      {0xBACA0000, 40}, // kwo -> Latn
+      {0x82EA0000, 40}, // kxa -> Latn
+      {0x8AEA0000, 18}, // kxc -> Ethi
+      {0xB2EA0000, 80}, // kxm -> Thai
+      {0xBEEA0000, 1}, // kxp -> Arab
+      {0xDAEA0000, 40}, // kxw -> Latn
+      {0xE6EA0000, 40}, // kxz -> Latn
+      {0x6B790000, 15}, // ky -> Cyrl
+      {0x6B79434E, 1}, // ky-CN -> Arab
+      {0x6B795452, 40}, // ky-TR -> Latn
+      {0x930A0000, 40}, // kye -> Latn
+      {0xDF0A0000, 40}, // kyx -> Latn
+      {0xC72A0000, 40}, // kzr -> Latn
+      {0x6C610000, 40}, // la -> Latn
+      {0x840B0000, 42}, // lab -> Lina
+      {0x8C0B0000, 27}, // lad -> Hebr
+      {0x980B0000, 40}, // lag -> Latn
+      {0x9C0B0000, 1}, // lah -> Arab
+      {0xA40B0000, 40}, // laj -> Latn
+      {0xC80B0000, 40}, // las -> Latn
+      {0x6C620000, 40}, // lb -> Latn
+      {0x902B0000, 15}, // lbe -> Cyrl
+      {0xD02B0000, 40}, // lbu -> Latn
+      {0xD82B0000, 40}, // lbw -> Latn
+      {0xB04B0000, 40}, // lcm -> Latn
+      {0xBC4B0000, 80}, // lcp -> Thai
+      {0x846B0000, 40}, // ldb -> Latn
+      {0x8C8B0000, 40}, // led -> Latn
+      {0x908B0000, 40}, // lee -> Latn
+      {0xB08B0000, 40}, // lem -> Latn
+      {0xBC8B0000, 41}, // lep -> Lepc
+      {0xC08B0000, 40}, // leq -> Latn
+      {0xD08B0000, 40}, // leu -> Latn
+      {0xE48B0000, 15}, // lez -> Cyrl
+      {0x6C670000, 40}, // lg -> Latn
+      {0x98CB0000, 40}, // lgg -> Latn
+      {0x6C690000, 40}, // li -> Latn
+      {0x810B0000, 40}, // lia -> Latn
+      {0x8D0B0000, 40}, // lid -> Latn
+      {0x950B0000, 16}, // lif -> Deva
+      {0x990B0000, 40}, // lig -> Latn
+      {0x9D0B0000, 40}, // lih -> Latn
+      {0xA50B0000, 40}, // lij -> Latn
+      {0xC90B0000, 43}, // lis -> Lisu
+      {0xBD2B0000, 40}, // ljp -> Latn
+      {0xA14B0000, 1}, // lki -> Arab
+      {0xCD4B0000, 40}, // lkt -> Latn
+      {0x916B0000, 40}, // lle -> Latn
+      {0xB56B0000, 40}, // lln -> Latn
+      {0xB58B0000, 77}, // lmn -> Telu
+      {0xB98B0000, 40}, // lmo -> Latn
+      {0xBD8B0000, 40}, // lmp -> Latn
+      {0x6C6E0000, 40}, // ln -> Latn
+      {0xC9AB0000, 40}, // lns -> Latn
+      {0xD1AB0000, 40}, // lnu -> Latn
+      {0x6C6F0000, 39}, // lo -> Laoo
+      {0xA5CB0000, 40}, // loj -> Latn
+      {0xA9CB0000, 40}, // lok -> Latn
+      {0xADCB0000, 40}, // lol -> Latn
+      {0xC5CB0000, 40}, // lor -> Latn
+      {0xC9CB0000, 40}, // los -> Latn
+      {0xE5CB0000, 40}, // loz -> Latn
+      {0x8A2B0000, 1}, // lrc -> Arab
+      {0x6C740000, 40}, // lt -> Latn
+      {0x9A6B0000, 40}, // ltg -> Latn
+      {0x6C750000, 40}, // lu -> Latn
+      {0x828B0000, 40}, // lua -> Latn
+      {0xBA8B0000, 40}, // luo -> Latn
+      {0xE28B0000, 40}, // luy -> Latn
+      {0xE68B0000, 1}, // luz -> Arab
+      {0x6C760000, 40}, // lv -> Latn
+      {0xAECB0000, 80}, // lwl -> Thai
+      {0x9F2B0000, 24}, // lzh -> Hans
+      {0xE72B0000, 40}, // lzz -> Latn
+      {0x8C0C0000, 40}, // mad -> Latn
+      {0x940C0000, 40}, // maf -> Latn
+      {0x980C0000, 16}, // mag -> Deva
+      {0xA00C0000, 16}, // mai -> Deva
+      {0xA80C0000, 40}, // mak -> Latn
+      {0xB40C0000, 40}, // man -> Latn
+      {0xB40C474E, 54}, // man-GN -> Nkoo
+      {0xC80C0000, 40}, // mas -> Latn
+      {0xD80C0000, 40}, // maw -> Latn
+      {0xE40C0000, 40}, // maz -> Latn
+      {0x9C2C0000, 40}, // mbh -> Latn
+      {0xB82C0000, 40}, // mbo -> Latn
+      {0xC02C0000, 40}, // mbq -> Latn
+      {0xD02C0000, 40}, // mbu -> Latn
+      {0xD82C0000, 40}, // mbw -> Latn
+      {0xA04C0000, 40}, // mci -> Latn
+      {0xBC4C0000, 40}, // mcp -> Latn
+      {0xC04C0000, 40}, // mcq -> Latn
+      {0xC44C0000, 40}, // mcr -> Latn
+      {0xD04C0000, 40}, // mcu -> Latn
+      {0x806C0000, 40}, // mda -> Latn
+      {0x906C0000, 1}, // mde -> Arab
+      {0x946C0000, 15}, // mdf -> Cyrl
+      {0x9C6C0000, 40}, // mdh -> Latn
+      {0xA46C0000, 40}, // mdj -> Latn
+      {0xC46C0000, 40}, // mdr -> Latn
+      {0xDC6C0000, 18}, // mdx -> Ethi
+      {0x8C8C0000, 40}, // med -> Latn
+      {0x908C0000, 40}, // mee -> Latn
+      {0xA88C0000, 40}, // mek -> Latn
+      {0xB48C0000, 40}, // men -> Latn
+      {0xC48C0000, 40}, // mer -> Latn
+      {0xCC8C0000, 40}, // met -> Latn
+      {0xD08C0000, 40}, // meu -> Latn
+      {0x80AC0000, 1}, // mfa -> Arab
+      {0x90AC0000, 40}, // mfe -> Latn
+      {0xB4AC0000, 40}, // mfn -> Latn
+      {0xB8AC0000, 40}, // mfo -> Latn
+      {0xC0AC0000, 40}, // mfq -> Latn
+      {0x6D670000, 40}, // mg -> Latn
+      {0x9CCC0000, 40}, // mgh -> Latn
+      {0xACCC0000, 40}, // mgl -> Latn
+      {0xB8CC0000, 40}, // mgo -> Latn
+      {0xBCCC0000, 16}, // mgp -> Deva
+      {0xE0CC0000, 40}, // mgy -> Latn
+      {0x6D680000, 40}, // mh -> Latn
+      {0xA0EC0000, 40}, // mhi -> Latn
+      {0xACEC0000, 40}, // mhl -> Latn
+      {0x6D690000, 40}, // mi -> Latn
+      {0x950C0000, 40}, // mif -> Latn
+      {0xB50C0000, 40}, // min -> Latn
+      {0xC90C0000, 26}, // mis -> Hatr
+      {0xD90C0000, 40}, // miw -> Latn
+      {0x6D6B0000, 15}, // mk -> Cyrl
+      {0xA14C0000, 1}, // mki -> Arab
+      {0xAD4C0000, 40}, // mkl -> Latn
+      {0xBD4C0000, 40}, // mkp -> Latn
+      {0xD94C0000, 40}, // mkw -> Latn
+      {0x6D6C0000, 49}, // ml -> Mlym
+      {0x916C0000, 40}, // mle -> Latn
+      {0xBD6C0000, 40}, // mlp -> Latn
+      {0xC96C0000, 40}, // mls -> Latn
+      {0xB98C0000, 40}, // mmo -> Latn
+      {0xD18C0000, 40}, // mmu -> Latn
+      {0xDD8C0000, 40}, // mmx -> Latn
+      {0x6D6E0000, 15}, // mn -> Cyrl
+      {0x6D6E434E, 50}, // mn-CN -> Mong
+      {0x81AC0000, 40}, // mna -> Latn
+      {0x95AC0000, 40}, // mnf -> Latn
+      {0xA1AC0000, 7}, // mni -> Beng
+      {0xD9AC0000, 52}, // mnw -> Mymr
+      {0x81CC0000, 40}, // moa -> Latn
+      {0x91CC0000, 40}, // moe -> Latn
+      {0x9DCC0000, 40}, // moh -> Latn
+      {0xC9CC0000, 40}, // mos -> Latn
+      {0xDDCC0000, 40}, // mox -> Latn
+      {0xBDEC0000, 40}, // mpp -> Latn
+      {0xC9EC0000, 40}, // mps -> Latn
+      {0xCDEC0000, 40}, // mpt -> Latn
+      {0xDDEC0000, 40}, // mpx -> Latn
+      {0xAE0C0000, 40}, // mql -> Latn
+      {0x6D720000, 16}, // mr -> Deva
+      {0x8E2C0000, 16}, // mrd -> Deva
+      {0xA62C0000, 15}, // mrj -> Cyrl
+      {0xBA2C0000, 51}, // mro -> Mroo
+      {0x6D730000, 40}, // ms -> Latn
+      {0x6D734343, 1}, // ms-CC -> Arab
+      {0x6D734944, 1}, // ms-ID -> Arab
+      {0x6D740000, 40}, // mt -> Latn
+      {0x8A6C0000, 40}, // mtc -> Latn
+      {0x966C0000, 40}, // mtf -> Latn
+      {0xA26C0000, 40}, // mti -> Latn
+      {0xC66C0000, 16}, // mtr -> Deva
+      {0x828C0000, 40}, // mua -> Latn
+      {0xC68C0000, 40}, // mur -> Latn
+      {0xCA8C0000, 40}, // mus -> Latn
+      {0x82AC0000, 40}, // mva -> Latn
+      {0xB6AC0000, 40}, // mvn -> Latn
+      {0xE2AC0000, 1}, // mvy -> Arab
+      {0xAACC0000, 40}, // mwk -> Latn
+      {0xC6CC0000, 16}, // mwr -> Deva
+      {0xD6CC0000, 40}, // mwv -> Latn
+      {0x8AEC0000, 40}, // mxc -> Latn
+      {0xB2EC0000, 40}, // mxm -> Latn
+      {0x6D790000, 52}, // my -> Mymr
+      {0xAB0C0000, 40}, // myk -> Latn
+      {0xB30C0000, 18}, // mym -> Ethi
+      {0xD70C0000, 15}, // myv -> Cyrl
+      {0xDB0C0000, 40}, // myw -> Latn
+      {0xDF0C0000, 40}, // myx -> Latn
+      {0xE70C0000, 46}, // myz -> Mand
+      {0xAB2C0000, 40}, // mzk -> Latn
+      {0xB32C0000, 40}, // mzm -> Latn
+      {0xB72C0000, 1}, // mzn -> Arab
+      {0xBF2C0000, 40}, // mzp -> Latn
+      {0xDB2C0000, 40}, // mzw -> Latn
+      {0xE72C0000, 40}, // mzz -> Latn
+      {0x6E610000, 40}, // na -> Latn
+      {0x880D0000, 40}, // nac -> Latn
+      {0x940D0000, 40}, // naf -> Latn
+      {0xA80D0000, 40}, // nak -> Latn
+      {0xB40D0000, 24}, // nan -> Hans
+      {0xBC0D0000, 40}, // nap -> Latn
+      {0xC00D0000, 40}, // naq -> Latn
+      {0xC80D0000, 40}, // nas -> Latn
+      {0x6E620000, 40}, // nb -> Latn
+      {0x804D0000, 40}, // nca -> Latn
+      {0x904D0000, 40}, // nce -> Latn
+      {0x944D0000, 40}, // ncf -> Latn
+      {0x9C4D0000, 40}, // nch -> Latn
+      {0xB84D0000, 40}, // nco -> Latn
+      {0xD04D0000, 40}, // ncu -> Latn
+      {0x6E640000, 40}, // nd -> Latn
+      {0x886D0000, 40}, // ndc -> Latn
+      {0xC86D0000, 40}, // nds -> Latn
+      {0x6E650000, 16}, // ne -> Deva
+      {0x848D0000, 40}, // neb -> Latn
+      {0xD88D0000, 16}, // new -> Deva
+      {0xDC8D0000, 40}, // nex -> Latn
+      {0xC4AD0000, 40}, // nfr -> Latn
+      {0x6E670000, 40}, // ng -> Latn
+      {0x80CD0000, 40}, // nga -> Latn
+      {0x84CD0000, 40}, // ngb -> Latn
+      {0xACCD0000, 40}, // ngl -> Latn
+      {0x84ED0000, 40}, // nhb -> Latn
+      {0x90ED0000, 40}, // nhe -> Latn
+      {0xD8ED0000, 40}, // nhw -> Latn
+      {0x950D0000, 40}, // nif -> Latn
+      {0xA10D0000, 40}, // nii -> Latn
+      {0xA50D0000, 40}, // nij -> Latn
+      {0xB50D0000, 40}, // nin -> Latn
+      {0xD10D0000, 40}, // niu -> Latn
+      {0xE10D0000, 40}, // niy -> Latn
+      {0xE50D0000, 40}, // niz -> Latn
+      {0xB92D0000, 40}, // njo -> Latn
+      {0x994D0000, 40}, // nkg -> Latn
+      {0xB94D0000, 40}, // nko -> Latn
+      {0x6E6C0000, 40}, // nl -> Latn
+      {0x998D0000, 40}, // nmg -> Latn
+      {0xE58D0000, 40}, // nmz -> Latn
+      {0x6E6E0000, 40}, // nn -> Latn
+      {0x95AD0000, 40}, // nnf -> Latn
+      {0x9DAD0000, 40}, // nnh -> Latn
+      {0xA9AD0000, 40}, // nnk -> Latn
+      {0xB1AD0000, 40}, // nnm -> Latn
+      {0x6E6F0000, 40}, // no -> Latn
+      {0x8DCD0000, 38}, // nod -> Lana
+      {0x91CD0000, 16}, // noe -> Deva
+      {0xB5CD0000, 64}, // non -> Runr
+      {0xBDCD0000, 40}, // nop -> Latn
+      {0xD1CD0000, 40}, // nou -> Latn
+      {0xBA0D0000, 54}, // nqo -> Nkoo
+      {0x6E720000, 40}, // nr -> Latn
+      {0x862D0000, 40}, // nrb -> Latn
+      {0xAA4D0000, 9}, // nsk -> Cans
+      {0xB64D0000, 40}, // nsn -> Latn
+      {0xBA4D0000, 40}, // nso -> Latn
+      {0xCA4D0000, 40}, // nss -> Latn
+      {0xB26D0000, 40}, // ntm -> Latn
+      {0xC66D0000, 40}, // ntr -> Latn
+      {0xA28D0000, 40}, // nui -> Latn
+      {0xBE8D0000, 40}, // nup -> Latn
+      {0xCA8D0000, 40}, // nus -> Latn
+      {0xD68D0000, 40}, // nuv -> Latn
+      {0xDE8D0000, 40}, // nux -> Latn
+      {0x6E760000, 40}, // nv -> Latn
+      {0x86CD0000, 40}, // nwb -> Latn
+      {0xC2ED0000, 40}, // nxq -> Latn
+      {0xC6ED0000, 40}, // nxr -> Latn
+      {0x6E790000, 40}, // ny -> Latn
+      {0xB30D0000, 40}, // nym -> Latn
+      {0xB70D0000, 40}, // nyn -> Latn
+      {0xA32D0000, 40}, // nzi -> Latn
+      {0x6F630000, 40}, // oc -> Latn
+      {0x88CE0000, 40}, // ogc -> Latn
+      {0xC54E0000, 40}, // okr -> Latn
+      {0xD54E0000, 40}, // okv -> Latn
+      {0x6F6D0000, 40}, // om -> Latn
+      {0x99AE0000, 40}, // ong -> Latn
+      {0xB5AE0000, 40}, // onn -> Latn
+      {0xC9AE0000, 40}, // ons -> Latn
+      {0xB1EE0000, 40}, // opm -> Latn
+      {0x6F720000, 57}, // or -> Orya
+      {0xBA2E0000, 40}, // oro -> Latn
+      {0xD22E0000, 1}, // oru -> Arab
+      {0x6F730000, 15}, // os -> Cyrl
+      {0x824E0000, 58}, // osa -> Osge
+      {0x826E0000, 1}, // ota -> Arab
+      {0xAA6E0000, 56}, // otk -> Orkh
+      {0xB32E0000, 40}, // ozm -> Latn
+      {0x70610000, 23}, // pa -> Guru
+      {0x7061504B, 1}, // pa-PK -> Arab
+      {0x980F0000, 40}, // pag -> Latn
+      {0xAC0F0000, 60}, // pal -> Phli
+      {0xB00F0000, 40}, // pam -> Latn
+      {0xBC0F0000, 40}, // pap -> Latn
+      {0xD00F0000, 40}, // pau -> Latn
+      {0xA02F0000, 40}, // pbi -> Latn
+      {0x8C4F0000, 40}, // pcd -> Latn
+      {0xB04F0000, 40}, // pcm -> Latn
+      {0x886F0000, 40}, // pdc -> Latn
+      {0xCC6F0000, 40}, // pdt -> Latn
+      {0x8C8F0000, 40}, // ped -> Latn
+      {0xB88F0000, 84}, // peo -> Xpeo
+      {0xDC8F0000, 40}, // pex -> Latn
+      {0xACAF0000, 40}, // pfl -> Latn
+      {0xACEF0000, 1}, // phl -> Arab
+      {0xB4EF0000, 61}, // phn -> Phnx
+      {0xAD0F0000, 40}, // pil -> Latn
+      {0xBD0F0000, 40}, // pip -> Latn
+      {0x814F0000, 8}, // pka -> Brah
+      {0xB94F0000, 40}, // pko -> Latn
+      {0x706C0000, 40}, // pl -> Latn
+      {0x816F0000, 40}, // pla -> Latn
+      {0xC98F0000, 40}, // pms -> Latn
+      {0x99AF0000, 40}, // png -> Latn
+      {0xB5AF0000, 40}, // pnn -> Latn
+      {0xCDAF0000, 21}, // pnt -> Grek
+      {0xB5CF0000, 40}, // pon -> Latn
+      {0xB9EF0000, 40}, // ppo -> Latn
+      {0x822F0000, 34}, // pra -> Khar
+      {0x8E2F0000, 1}, // prd -> Arab
+      {0x9A2F0000, 40}, // prg -> Latn
+      {0x70730000, 1}, // ps -> Arab
+      {0xCA4F0000, 40}, // pss -> Latn
+      {0x70740000, 40}, // pt -> Latn
+      {0xBE6F0000, 40}, // ptp -> Latn
+      {0xD28F0000, 40}, // puu -> Latn
+      {0x82CF0000, 40}, // pwa -> Latn
+      {0x71750000, 40}, // qu -> Latn
+      {0x8A900000, 40}, // quc -> Latn
+      {0x9A900000, 40}, // qug -> Latn
+      {0xA0110000, 40}, // rai -> Latn
+      {0xA4110000, 16}, // raj -> Deva
+      {0xB8110000, 40}, // rao -> Latn
+      {0x94510000, 40}, // rcf -> Latn
+      {0xA4910000, 40}, // rej -> Latn
+      {0xAC910000, 40}, // rel -> Latn
+      {0xC8910000, 40}, // res -> Latn
+      {0xB4D10000, 40}, // rgn -> Latn
+      {0x98F10000, 1}, // rhg -> Arab
+      {0x81110000, 40}, // ria -> Latn
+      {0x95110000, 78}, // rif -> Tfng
+      {0x95114E4C, 40}, // rif-NL -> Latn
+      {0xC9310000, 16}, // rjs -> Deva
+      {0xCD510000, 7}, // rkt -> Beng
+      {0x726D0000, 40}, // rm -> Latn
+      {0x95910000, 40}, // rmf -> Latn
+      {0xB9910000, 40}, // rmo -> Latn
+      {0xCD910000, 1}, // rmt -> Arab
+      {0xD1910000, 40}, // rmu -> Latn
+      {0x726E0000, 40}, // rn -> Latn
+      {0x81B10000, 40}, // rna -> Latn
+      {0x99B10000, 40}, // rng -> Latn
+      {0x726F0000, 40}, // ro -> Latn
+      {0x85D10000, 40}, // rob -> Latn
+      {0x95D10000, 40}, // rof -> Latn
+      {0xB9D10000, 40}, // roo -> Latn
+      {0xBA310000, 40}, // rro -> Latn
+      {0xB2710000, 40}, // rtm -> Latn
+      {0x72750000, 15}, // ru -> Cyrl
+      {0x92910000, 15}, // rue -> Cyrl
+      {0x9A910000, 40}, // rug -> Latn
+      {0x72770000, 40}, // rw -> Latn
+      {0xAAD10000, 40}, // rwk -> Latn
+      {0xBAD10000, 40}, // rwo -> Latn
+      {0xD3110000, 33}, // ryu -> Kana
+      {0x73610000, 16}, // sa -> Deva
+      {0x94120000, 40}, // saf -> Latn
+      {0x9C120000, 15}, // sah -> Cyrl
+      {0xC0120000, 40}, // saq -> Latn
+      {0xC8120000, 40}, // sas -> Latn
+      {0xCC120000, 40}, // sat -> Latn
+      {0xE4120000, 67}, // saz -> Saur
+      {0x80320000, 40}, // sba -> Latn
+      {0x90320000, 40}, // sbe -> Latn
+      {0xBC320000, 40}, // sbp -> Latn
+      {0x73630000, 40}, // sc -> Latn
+      {0xA8520000, 16}, // sck -> Deva
+      {0xAC520000, 1}, // scl -> Arab
+      {0xB4520000, 40}, // scn -> Latn
+      {0xB8520000, 40}, // sco -> Latn
+      {0xC8520000, 40}, // scs -> Latn
+      {0x73640000, 1}, // sd -> Arab
+      {0x88720000, 40}, // sdc -> Latn
+      {0x9C720000, 1}, // sdh -> Arab
+      {0x73650000, 40}, // se -> Latn
+      {0x94920000, 40}, // sef -> Latn
+      {0x9C920000, 40}, // seh -> Latn
+      {0xA0920000, 40}, // sei -> Latn
+      {0xC8920000, 40}, // ses -> Latn
+      {0x73670000, 40}, // sg -> Latn
+      {0x80D20000, 55}, // sga -> Ogam
+      {0xC8D20000, 40}, // sgs -> Latn
+      {0xD8D20000, 18}, // sgw -> Ethi
+      {0xE4D20000, 40}, // sgz -> Latn
+      {0x73680000, 40}, // sh -> Latn
+      {0xA0F20000, 78}, // shi -> Tfng
+      {0xA8F20000, 40}, // shk -> Latn
+      {0xB4F20000, 52}, // shn -> Mymr
+      {0xD0F20000, 1}, // shu -> Arab
+      {0x73690000, 69}, // si -> Sinh
+      {0x8D120000, 40}, // sid -> Latn
+      {0x99120000, 40}, // sig -> Latn
+      {0xAD120000, 40}, // sil -> Latn
+      {0xB1120000, 40}, // sim -> Latn
+      {0xC5320000, 40}, // sjr -> Latn
+      {0x736B0000, 40}, // sk -> Latn
+      {0x89520000, 40}, // skc -> Latn
+      {0xC5520000, 1}, // skr -> Arab
+      {0xC9520000, 40}, // sks -> Latn
+      {0x736C0000, 40}, // sl -> Latn
+      {0x8D720000, 40}, // sld -> Latn
+      {0xA1720000, 40}, // sli -> Latn
+      {0xAD720000, 40}, // sll -> Latn
+      {0xE1720000, 40}, // sly -> Latn
+      {0x736D0000, 40}, // sm -> Latn
+      {0x81920000, 40}, // sma -> Latn
+      {0xA5920000, 40}, // smj -> Latn
+      {0xB5920000, 40}, // smn -> Latn
+      {0xBD920000, 65}, // smp -> Samr
+      {0xC1920000, 40}, // smq -> Latn
+      {0xC9920000, 40}, // sms -> Latn
+      {0x736E0000, 40}, // sn -> Latn
+      {0x89B20000, 40}, // snc -> Latn
+      {0xA9B20000, 40}, // snk -> Latn
+      {0xBDB20000, 40}, // snp -> Latn
+      {0xDDB20000, 40}, // snx -> Latn
+      {0xE1B20000, 40}, // sny -> Latn
+      {0x736F0000, 40}, // so -> Latn
+      {0xA9D20000, 40}, // sok -> Latn
+      {0xC1D20000, 40}, // soq -> Latn
+      {0xD1D20000, 80}, // sou -> Thai
+      {0xE1D20000, 40}, // soy -> Latn
+      {0x8DF20000, 40}, // spd -> Latn
+      {0xADF20000, 40}, // spl -> Latn
+      {0xC9F20000, 40}, // sps -> Latn
+      {0x73710000, 40}, // sq -> Latn
+      {0x73720000, 15}, // sr -> Cyrl
+      {0x73724D45, 40}, // sr-ME -> Latn
+      {0x7372524F, 40}, // sr-RO -> Latn
+      {0x73725255, 40}, // sr-RU -> Latn
+      {0x73725452, 40}, // sr-TR -> Latn
+      {0x86320000, 70}, // srb -> Sora
+      {0xB6320000, 40}, // srn -> Latn
+      {0xC6320000, 40}, // srr -> Latn
+      {0xDE320000, 16}, // srx -> Deva
+      {0x73730000, 40}, // ss -> Latn
+      {0x8E520000, 40}, // ssd -> Latn
+      {0x9A520000, 40}, // ssg -> Latn
+      {0xE2520000, 40}, // ssy -> Latn
+      {0x73740000, 40}, // st -> Latn
+      {0xAA720000, 40}, // stk -> Latn
+      {0xC2720000, 40}, // stq -> Latn
+      {0x73750000, 40}, // su -> Latn
+      {0x82920000, 40}, // sua -> Latn
+      {0x92920000, 40}, // sue -> Latn
+      {0xAA920000, 40}, // suk -> Latn
+      {0xC6920000, 40}, // sur -> Latn
+      {0xCA920000, 40}, // sus -> Latn
+      {0x73760000, 40}, // sv -> Latn
+      {0x73770000, 40}, // sw -> Latn
+      {0x86D20000, 1}, // swb -> Arab
+      {0x8AD20000, 40}, // swc -> Latn
+      {0x9AD20000, 40}, // swg -> Latn
+      {0xBED20000, 40}, // swp -> Latn
+      {0xD6D20000, 16}, // swv -> Deva
+      {0xB6F20000, 40}, // sxn -> Latn
+      {0xDAF20000, 40}, // sxw -> Latn
+      {0xAF120000, 7}, // syl -> Beng
+      {0xC7120000, 71}, // syr -> Syrc
+      {0xAF320000, 40}, // szl -> Latn
+      {0x74610000, 74}, // ta -> Taml
+      {0xA4130000, 16}, // taj -> Deva
+      {0xAC130000, 40}, // tal -> Latn
+      {0xB4130000, 40}, // tan -> Latn
+      {0xC0130000, 40}, // taq -> Latn
+      {0x88330000, 40}, // tbc -> Latn
+      {0x8C330000, 40}, // tbd -> Latn
+      {0x94330000, 40}, // tbf -> Latn
+      {0x98330000, 40}, // tbg -> Latn
+      {0xB8330000, 40}, // tbo -> Latn
+      {0xD8330000, 40}, // tbw -> Latn
+      {0xE4330000, 40}, // tbz -> Latn
+      {0xA0530000, 40}, // tci -> Latn
+      {0xE0530000, 36}, // tcy -> Knda
+      {0x8C730000, 72}, // tdd -> Tale
+      {0x98730000, 16}, // tdg -> Deva
+      {0x9C730000, 16}, // tdh -> Deva
+      {0x74650000, 77}, // te -> Telu
+      {0x8C930000, 40}, // ted -> Latn
+      {0xB0930000, 40}, // tem -> Latn
+      {0xB8930000, 40}, // teo -> Latn
+      {0xCC930000, 40}, // tet -> Latn
+      {0xA0B30000, 40}, // tfi -> Latn
+      {0x74670000, 15}, // tg -> Cyrl
+      {0x7467504B, 1}, // tg-PK -> Arab
+      {0x88D30000, 40}, // tgc -> Latn
+      {0xB8D30000, 40}, // tgo -> Latn
+      {0xD0D30000, 40}, // tgu -> Latn
+      {0x74680000, 80}, // th -> Thai
+      {0xACF30000, 16}, // thl -> Deva
+      {0xC0F30000, 16}, // thq -> Deva
+      {0xC4F30000, 16}, // thr -> Deva
+      {0x74690000, 18}, // ti -> Ethi
+      {0x95130000, 40}, // tif -> Latn
+      {0x99130000, 18}, // tig -> Ethi
+      {0xA9130000, 40}, // tik -> Latn
+      {0xB1130000, 40}, // tim -> Latn
+      {0xB9130000, 40}, // tio -> Latn
+      {0xD5130000, 40}, // tiv -> Latn
+      {0x746B0000, 40}, // tk -> Latn
+      {0xAD530000, 40}, // tkl -> Latn
+      {0xC5530000, 40}, // tkr -> Latn
+      {0xCD530000, 16}, // tkt -> Deva
+      {0x746C0000, 40}, // tl -> Latn
+      {0x95730000, 40}, // tlf -> Latn
+      {0xDD730000, 40}, // tlx -> Latn
+      {0xE1730000, 40}, // tly -> Latn
+      {0x9D930000, 40}, // tmh -> Latn
+      {0xE1930000, 40}, // tmy -> Latn
+      {0x746E0000, 40}, // tn -> Latn
+      {0x9DB30000, 40}, // tnh -> Latn
+      {0x746F0000, 40}, // to -> Latn
+      {0x95D30000, 40}, // tof -> Latn
+      {0x99D30000, 40}, // tog -> Latn
+      {0xC1D30000, 40}, // toq -> Latn
+      {0xA1F30000, 40}, // tpi -> Latn
+      {0xB1F30000, 40}, // tpm -> Latn
+      {0xE5F30000, 40}, // tpz -> Latn
+      {0xBA130000, 40}, // tqo -> Latn
+      {0x74720000, 40}, // tr -> Latn
+      {0xD2330000, 40}, // tru -> Latn
+      {0xD6330000, 40}, // trv -> Latn
+      {0xDA330000, 1}, // trw -> Arab
+      {0x74730000, 40}, // ts -> Latn
+      {0x8E530000, 21}, // tsd -> Grek
+      {0x96530000, 16}, // tsf -> Deva
+      {0x9A530000, 40}, // tsg -> Latn
+      {0xA6530000, 81}, // tsj -> Tibt
+      {0xDA530000, 40}, // tsw -> Latn
+      {0x74740000, 15}, // tt -> Cyrl
+      {0x8E730000, 40}, // ttd -> Latn
+      {0x92730000, 40}, // tte -> Latn
+      {0xA6730000, 40}, // ttj -> Latn
+      {0xC6730000, 40}, // ttr -> Latn
+      {0xCA730000, 80}, // tts -> Thai
+      {0xCE730000, 40}, // ttt -> Latn
+      {0x9E930000, 40}, // tuh -> Latn
+      {0xAE930000, 40}, // tul -> Latn
+      {0xB2930000, 40}, // tum -> Latn
+      {0xC2930000, 40}, // tuq -> Latn
+      {0x8EB30000, 40}, // tvd -> Latn
+      {0xAEB30000, 40}, // tvl -> Latn
+      {0xD2B30000, 40}, // tvu -> Latn
+      {0x9ED30000, 40}, // twh -> Latn
+      {0xC2D30000, 40}, // twq -> Latn
+      {0x9AF30000, 75}, // txg -> Tang
+      {0x74790000, 40}, // ty -> Latn
+      {0x83130000, 40}, // tya -> Latn
+      {0xD7130000, 15}, // tyv -> Cyrl
+      {0xB3330000, 40}, // tzm -> Latn
+      {0xD0340000, 40}, // ubu -> Latn
+      {0xB0740000, 15}, // udm -> Cyrl
+      {0x75670000, 1}, // ug -> Arab
+      {0x75674B5A, 15}, // ug-KZ -> Cyrl
+      {0x75674D4E, 15}, // ug-MN -> Cyrl
+      {0x80D40000, 82}, // uga -> Ugar
+      {0x756B0000, 15}, // uk -> Cyrl
+      {0xA1740000, 40}, // uli -> Latn
+      {0x85940000, 40}, // umb -> Latn
+      {0xC5B40000, 7}, // unr -> Beng
+      {0xC5B44E50, 16}, // unr-NP -> Deva
+      {0xDDB40000, 7}, // unx -> Beng
+      {0x75720000, 1}, // ur -> Arab
+      {0xA2340000, 40}, // uri -> Latn
+      {0xCE340000, 40}, // urt -> Latn
+      {0xDA340000, 40}, // urw -> Latn
+      {0x82540000, 40}, // usa -> Latn
+      {0xC6740000, 40}, // utr -> Latn
+      {0x9EB40000, 40}, // uvh -> Latn
+      {0xAEB40000, 40}, // uvl -> Latn
+      {0x757A0000, 40}, // uz -> Latn
+      {0x757A4146, 1}, // uz-AF -> Arab
+      {0x757A434E, 15}, // uz-CN -> Cyrl
+      {0x98150000, 40}, // vag -> Latn
+      {0xA0150000, 83}, // vai -> Vaii
+      {0xB4150000, 40}, // van -> Latn
+      {0x76650000, 40}, // ve -> Latn
+      {0x88950000, 40}, // vec -> Latn
+      {0xBC950000, 40}, // vep -> Latn
+      {0x76690000, 40}, // vi -> Latn
+      {0x89150000, 40}, // vic -> Latn
+      {0xD5150000, 40}, // viv -> Latn
+      {0xC9750000, 40}, // vls -> Latn
+      {0x95950000, 40}, // vmf -> Latn
+      {0xD9950000, 40}, // vmw -> Latn
+      {0x766F0000, 40}, // vo -> Latn
+      {0xCDD50000, 40}, // vot -> Latn
+      {0xBA350000, 40}, // vro -> Latn
+      {0xB6950000, 40}, // vun -> Latn
+      {0xCE950000, 40}, // vut -> Latn
+      {0x77610000, 40}, // wa -> Latn
+      {0x90160000, 40}, // wae -> Latn
+      {0xA4160000, 40}, // waj -> Latn
+      {0xAC160000, 18}, // wal -> Ethi
+      {0xB4160000, 40}, // wan -> Latn
+      {0xC4160000, 40}, // war -> Latn
+      {0xBC360000, 40}, // wbp -> Latn
+      {0xC0360000, 77}, // wbq -> Telu
+      {0xC4360000, 16}, // wbr -> Deva
+      {0xA0560000, 40}, // wci -> Latn
+      {0xC4960000, 40}, // wer -> Latn
+      {0xA0D60000, 40}, // wgi -> Latn
+      {0x98F60000, 40}, // whg -> Latn
+      {0x85160000, 40}, // wib -> Latn
+      {0xD1160000, 40}, // wiu -> Latn
+      {0xD5160000, 40}, // wiv -> Latn
+      {0x81360000, 40}, // wja -> Latn
+      {0xA1360000, 40}, // wji -> Latn
+      {0xC9760000, 40}, // wls -> Latn
+      {0xB9960000, 40}, // wmo -> Latn
+      {0x89B60000, 40}, // wnc -> Latn
+      {0xA1B60000, 1}, // wni -> Arab
+      {0xD1B60000, 40}, // wnu -> Latn
+      {0x776F0000, 40}, // wo -> Latn
+      {0x85D60000, 40}, // wob -> Latn
+      {0xC9D60000, 40}, // wos -> Latn
+      {0xCA360000, 40}, // wrs -> Latn
+      {0xAA560000, 40}, // wsk -> Latn
+      {0xB2760000, 16}, // wtm -> Deva
+      {0xD2960000, 24}, // wuu -> Hans
+      {0xD6960000, 40}, // wuv -> Latn
+      {0x82D60000, 40}, // wwa -> Latn
+      {0xD4170000, 40}, // xav -> Latn
+      {0xA0370000, 40}, // xbi -> Latn
+      {0xC4570000, 10}, // xcr -> Cari
+      {0xC8970000, 40}, // xes -> Latn
+      {0x78680000, 40}, // xh -> Latn
+      {0x81770000, 40}, // xla -> Latn
+      {0x89770000, 44}, // xlc -> Lyci
+      {0x8D770000, 45}, // xld -> Lydi
+      {0x95970000, 19}, // xmf -> Geor
+      {0xB5970000, 47}, // xmn -> Mani
+      {0xC5970000, 48}, // xmr -> Merc
+      {0x81B70000, 53}, // xna -> Narb
+      {0xC5B70000, 16}, // xnr -> Deva
+      {0x99D70000, 40}, // xog -> Latn
+      {0xB5D70000, 40}, // xon -> Latn
+      {0xC5F70000, 63}, // xpr -> Prti
+      {0x86370000, 40}, // xrb -> Latn
+      {0x82570000, 66}, // xsa -> Sarb
+      {0xA2570000, 40}, // xsi -> Latn
+      {0xB2570000, 40}, // xsm -> Latn
+      {0xC6570000, 16}, // xsr -> Deva
+      {0x92D70000, 40}, // xwe -> Latn
+      {0xB0180000, 40}, // yam -> Latn
+      {0xB8180000, 40}, // yao -> Latn
+      {0xBC180000, 40}, // yap -> Latn
+      {0xC8180000, 40}, // yas -> Latn
+      {0xCC180000, 40}, // yat -> Latn
+      {0xD4180000, 40}, // yav -> Latn
+      {0xE0180000, 40}, // yay -> Latn
+      {0xE4180000, 40}, // yaz -> Latn
+      {0x80380000, 40}, // yba -> Latn
+      {0x84380000, 40}, // ybb -> Latn
+      {0xE0380000, 40}, // yby -> Latn
+      {0xC4980000, 40}, // yer -> Latn
+      {0xC4D80000, 40}, // ygr -> Latn
+      {0xD8D80000, 40}, // ygw -> Latn
+      {0x79690000, 27}, // yi -> Hebr
+      {0xB9580000, 40}, // yko -> Latn
+      {0x91780000, 40}, // yle -> Latn
+      {0x99780000, 40}, // ylg -> Latn
+      {0xAD780000, 40}, // yll -> Latn
+      {0xAD980000, 40}, // yml -> Latn
+      {0x796F0000, 40}, // yo -> Latn
+      {0xB5D80000, 40}, // yon -> Latn
+      {0x86380000, 40}, // yrb -> Latn
+      {0x92380000, 40}, // yre -> Latn
+      {0xAE380000, 40}, // yrl -> Latn
+      {0xCA580000, 40}, // yss -> Latn
+      {0x82980000, 40}, // yua -> Latn
+      {0x92980000, 25}, // yue -> Hant
+      {0x9298434E, 24}, // yue-CN -> Hans
+      {0xA6980000, 40}, // yuj -> Latn
+      {0xCE980000, 40}, // yut -> Latn
+      {0xDA980000, 40}, // yuw -> Latn
+      {0x7A610000, 40}, // za -> Latn
+      {0x98190000, 40}, // zag -> Latn
+      {0xA4790000, 1}, // zdj -> Arab
+      {0x80990000, 40}, // zea -> Latn
+      {0x9CD90000, 78}, // zgh -> Tfng
+      {0x7A680000, 24}, // zh -> Hans
+      {0x7A684155, 25}, // zh-AU -> Hant
+      {0x7A68424E, 25}, // zh-BN -> Hant
+      {0x7A684742, 25}, // zh-GB -> Hant
+      {0x7A684746, 25}, // zh-GF -> Hant
+      {0x7A68484B, 25}, // zh-HK -> Hant
+      {0x7A684944, 25}, // zh-ID -> Hant
+      {0x7A684D4F, 25}, // zh-MO -> Hant
+      {0x7A684D59, 25}, // zh-MY -> Hant
+      {0x7A685041, 25}, // zh-PA -> Hant
+      {0x7A685046, 25}, // zh-PF -> Hant
+      {0x7A685048, 25}, // zh-PH -> Hant
+      {0x7A685352, 25}, // zh-SR -> Hant
+      {0x7A685448, 25}, // zh-TH -> Hant
+      {0x7A685457, 25}, // zh-TW -> Hant
+      {0x7A685553, 25}, // zh-US -> Hant
+      {0x7A68564E, 25}, // zh-VN -> Hant
+      {0x81190000, 40}, // zia -> Latn
+      {0xB1790000, 40}, // zlm -> Latn
+      {0xA1990000, 40}, // zmi -> Latn
+      {0x91B90000, 40}, // zne -> Latn
+      {0x7A750000, 40}, // zu -> Latn
+      {0x83390000, 40}, // zza -> Latn
     };
 
     Map<Integer, Byte> buildMap = new HashMap<>();
@@ -1468,733 +1469,733 @@ public class LocaleDataTables {
 
   static {
     long[] entries = {
-        0x616145544C61746EL, // aa_Latn_ET
-        0x616247454379726CL, // ab_Cyrl_GE
-        0xC42047484C61746EL, // abr_Latn_GH
-        0x904049444C61746EL, // ace_Latn_ID
-        0x9C4055474C61746EL, // ach_Latn_UG
-        0x806047484C61746EL, // ada_Latn_GH
-        0xE06052554379726CL, // ady_Cyrl_RU
-        0x6165495241767374L, // ae_Avst_IR
-        0x8480544E41726162L, // aeb_Arab_TN
-        0x61665A414C61746EL, // af_Latn_ZA
-        0xC0C0434D4C61746EL, // agq_Latn_CM
-        0xB8E0494E41686F6DL, // aho_Ahom_IN
-        0x616B47484C61746EL, // ak_Latn_GH
-        0xA940495158737578L, // akk_Xsux_IQ
-        0xB560584B4C61746EL, // aln_Latn_XK
-        0xCD6052554379726CL, // alt_Cyrl_RU
-        0x616D455445746869L, // am_Ethi_ET
-        0xB9804E474C61746EL, // amo_Latn_NG
-        0xE5C049444C61746EL, // aoz_Latn_ID
-        0x8DE0544741726162L, // apd_Arab_TG
-        0x6172454741726162L, // ar_Arab_EG
-        0x8A20495241726D69L, // arc_Armi_IR
-        0x8A204A4F4E626174L, // arc_Nbat_JO
-        0x8A20535950616C6DL, // arc_Palm_SY
-        0xB620434C4C61746EL, // arn_Latn_CL
-        0xBA20424F4C61746EL, // aro_Latn_BO
-        0xC220445A41726162L, // arq_Arab_DZ
-        0xE2204D4141726162L, // ary_Arab_MA
-        0xE620454741726162L, // arz_Arab_EG
-        0x6173494E42656E67L, // as_Beng_IN
-        0x8240545A4C61746EL, // asa_Latn_TZ
-        0x9240555353676E77L, // ase_Sgnw_US
-        0xCE4045534C61746EL, // ast_Latn_ES
-        0xA66043414C61746EL, // atj_Latn_CA
-        0x617652554379726CL, // av_Cyrl_RU
-        0x82C0494E44657661L, // awa_Deva_IN
-        0x6179424F4C61746EL, // ay_Latn_BO
-        0x617A495241726162L, // az_Arab_IR
-        0x617A415A4C61746EL, // az_Latn_AZ
-        0x626152554379726CL, // ba_Cyrl_RU
-        0xAC01504B41726162L, // bal_Arab_PK
-        0xB40149444C61746EL, // ban_Latn_ID
-        0xBC014E5044657661L, // bap_Deva_NP
-        0xC40141544C61746EL, // bar_Latn_AT
-        0xC801434D4C61746EL, // bas_Latn_CM
-        0xDC01434D42616D75L, // bax_Bamu_CM
-        0x882149444C61746EL, // bbc_Latn_ID
-        0xA421434D4C61746EL, // bbj_Latn_CM
-        0xA04143494C61746EL, // bci_Latn_CI
-        0x626542594379726CL, // be_Cyrl_BY
-        0xA481534441726162L, // bej_Arab_SD
-        0xB0815A4D4C61746EL, // bem_Latn_ZM
-        0xD88149444C61746EL, // bew_Latn_ID
-        0xE481545A4C61746EL, // bez_Latn_TZ
-        0x8CA1434D4C61746EL, // bfd_Latn_CM
-        0xC0A1494E54616D6CL, // bfq_Taml_IN
-        0xCCA1504B41726162L, // bft_Arab_PK
-        0xE0A1494E44657661L, // bfy_Deva_IN
-        0x626742474379726CL, // bg_Cyrl_BG
-        0x88C1494E44657661L, // bgc_Deva_IN
-        0xB4C1504B41726162L, // bgn_Arab_PK
-        0xDCC154524772656BL, // bgx_Grek_TR
-        0x84E1494E44657661L, // bhb_Deva_IN
-        0xA0E1494E44657661L, // bhi_Deva_IN
-        0xA8E150484C61746EL, // bhk_Latn_PH
-        0xB8E1494E44657661L, // bho_Deva_IN
-        0x626956554C61746EL, // bi_Latn_VU
-        0xA90150484C61746EL, // bik_Latn_PH
-        0xB5014E474C61746EL, // bin_Latn_NG
-        0xA521494E44657661L, // bjj_Deva_IN
-        0xB52149444C61746EL, // bjn_Latn_ID
-        0xB141434D4C61746EL, // bkm_Latn_CM
-        0xD14150484C61746EL, // bku_Latn_PH
-        0xCD61564E54617674L, // blt_Tavt_VN
-        0x626D4D4C4C61746EL, // bm_Latn_ML
-        0xC1814D4C4C61746EL, // bmq_Latn_ML
-        0x626E424442656E67L, // bn_Beng_BD
-        0x626F434E54696274L, // bo_Tibt_CN
-        0xE1E1494E42656E67L, // bpy_Beng_IN
-        0xA201495241726162L, // bqi_Arab_IR
-        0xD60143494C61746EL, // bqv_Latn_CI
-        0x627246524C61746EL, // br_Latn_FR
-        0x8221494E44657661L, // bra_Deva_IN
-        0x9E21504B41726162L, // brh_Arab_PK
-        0xDE21494E44657661L, // brx_Deva_IN
-        0x627342414C61746EL, // bs_Latn_BA
-        0xC2414C5242617373L, // bsq_Bass_LR
-        0xCA41434D4C61746EL, // bss_Latn_CM
-        0xBA6150484C61746EL, // bto_Latn_PH
-        0xD661504B44657661L, // btv_Deva_PK
-        0x828152554379726CL, // bua_Cyrl_RU
-        0x8A8159544C61746EL, // buc_Latn_YT
-        0x9A8149444C61746EL, // bug_Latn_ID
-        0xB281434D4C61746EL, // bum_Latn_CM
-        0x86A147514C61746EL, // bvb_Latn_GQ
-        0xB701455245746869L, // byn_Ethi_ER
-        0xD701434D4C61746EL, // byv_Latn_CM
-        0x93214D4C4C61746EL, // bze_Latn_ML
-        0x636145534C61746EL, // ca_Latn_ES
-        0x9C424E474C61746EL, // cch_Latn_NG
-        0xBC42494E42656E67L, // ccp_Beng_IN
-        0xBC42424443616B6DL, // ccp_Cakm_BD
-        0x636552554379726CL, // ce_Cyrl_RU
-        0x848250484C61746EL, // ceb_Latn_PH
-        0x98C255474C61746EL, // cgg_Latn_UG
-        0x636847554C61746EL, // ch_Latn_GU
-        0xA8E2464D4C61746EL, // chk_Latn_FM
-        0xB0E252554379726CL, // chm_Cyrl_RU
-        0xB8E255534C61746EL, // cho_Latn_US
-        0xBCE243414C61746EL, // chp_Latn_CA
-        0xC4E2555343686572L, // chr_Cher_US
-        0x81224B4841726162L, // cja_Arab_KH
-        0xB122564E4368616DL, // cjm_Cham_VN
-        0x8542495141726162L, // ckb_Arab_IQ
-        0x636F46524C61746EL, // co_Latn_FR
-        0xBDC24547436F7074L, // cop_Copt_EG
-        0xC9E250484C61746EL, // cps_Latn_PH
-        0x6372434143616E73L, // cr_Cans_CA
-        0xA622434143616E73L, // crj_Cans_CA
-        0xAA22434143616E73L, // crk_Cans_CA
-        0xAE22434143616E73L, // crl_Cans_CA
-        0xB222434143616E73L, // crm_Cans_CA
-        0xCA2253434C61746EL, // crs_Latn_SC
-        0x6373435A4C61746EL, // cs_Latn_CZ
-        0x8642504C4C61746EL, // csb_Latn_PL
-        0xDA42434143616E73L, // csw_Cans_CA
-        0x8E624D4D50617563L, // ctd_Pauc_MM
-        0x637552554379726CL, // cu_Cyrl_RU
-        0x63754247476C6167L, // cu_Glag_BG
-        0x637652554379726CL, // cv_Cyrl_RU
-        0x637947424C61746EL, // cy_Latn_GB
-        0x6461444B4C61746EL, // da_Latn_DK
-        0xA80355534C61746EL, // dak_Latn_US
-        0xC40352554379726CL, // dar_Cyrl_RU
-        0xD4034B454C61746EL, // dav_Latn_KE
-        0x8843494E41726162L, // dcc_Arab_IN
-        0x646544454C61746EL, // de_Latn_DE
-        0xB48343414C61746EL, // den_Latn_CA
-        0xC4C343414C61746EL, // dgr_Latn_CA
-        0x91234E454C61746EL, // dje_Latn_NE
-        0xA5A343494C61746EL, // dnj_Latn_CI
-        0xA1C3494E41726162L, // doi_Arab_IN
-        0x864344454C61746EL, // dsb_Latn_DE
-        0xB2634D4C4C61746EL, // dtm_Latn_ML
-        0xBE634D594C61746EL, // dtp_Latn_MY
-        0xE2634E5044657661L, // dty_Deva_NP
-        0x8283434D4C61746EL, // dua_Latn_CM
-        0x64764D5654686161L, // dv_Thaa_MV
-        0xBB03534E4C61746EL, // dyo_Latn_SN
-        0xD30342464C61746EL, // dyu_Latn_BF
-        0x647A425454696274L, // dz_Tibt_BT
-        0xD0244B454C61746EL, // ebu_Latn_KE
-        0x656547484C61746EL, // ee_Latn_GH
-        0xA0A44E474C61746EL, // efi_Latn_NG
-        0xACC449544C61746EL, // egl_Latn_IT
-        0xE0C4454745677970L, // egy_Egyp_EG
-        0xE1444D4D4B616C69L, // eky_Kali_MM
-        0x656C47524772656BL, // el_Grek_GR
-        0x656E47424C61746EL, // en_Latn_GB
-        0x656E55534C61746EL, // en_Latn_US
-        0x656E474253686177L, // en_Shaw_GB
-        0x657345534C61746EL, // es_Latn_ES
-        0x65734D584C61746EL, // es_Latn_MX
-        0x657355534C61746EL, // es_Latn_US
-        0xD24455534C61746EL, // esu_Latn_US
-        0x657445454C61746EL, // et_Latn_EE
-        0xCE6449544974616CL, // ett_Ital_IT
-        0x657545534C61746EL, // eu_Latn_ES
-        0xBAC4434D4C61746EL, // ewo_Latn_CM
-        0xCEE445534C61746EL, // ext_Latn_ES
-        0x6661495241726162L, // fa_Arab_IR
-        0xB40547514C61746EL, // fan_Latn_GQ
-        0x6666474E41646C6DL, // ff_Adlm_GN
-        0x6666534E4C61746EL, // ff_Latn_SN
-        0xB0A54D4C4C61746EL, // ffm_Latn_ML
-        0x666946494C61746EL, // fi_Latn_FI
-        0x8105534441726162L, // fia_Arab_SD
-        0xAD0550484C61746EL, // fil_Latn_PH
-        0xCD0553454C61746EL, // fit_Latn_SE
-        0x666A464A4C61746EL, // fj_Latn_FJ
-        0x666F464F4C61746EL, // fo_Latn_FO
-        0xB5C5424A4C61746EL, // fon_Latn_BJ
-        0x667246524C61746EL, // fr_Latn_FR
-        0x8A2555534C61746EL, // frc_Latn_US
-        0xBE2546524C61746EL, // frp_Latn_FR
-        0xC62544454C61746EL, // frr_Latn_DE
-        0xCA2544454C61746EL, // frs_Latn_DE
-        0x8685434D41726162L, // fub_Arab_CM
-        0x8E8557464C61746EL, // fud_Latn_WF
-        0x9685474E4C61746EL, // fuf_Latn_GN
-        0xC2854E454C61746EL, // fuq_Latn_NE
-        0xC68549544C61746EL, // fur_Latn_IT
-        0xD6854E474C61746EL, // fuv_Latn_NG
-        0xC6A553444C61746EL, // fvr_Latn_SD
-        0x66794E4C4C61746EL, // fy_Latn_NL
-        0x676149454C61746EL, // ga_Latn_IE
-        0x800647484C61746EL, // gaa_Latn_GH
-        0x98064D444C61746EL, // gag_Latn_MD
-        0xB406434E48616E73L, // gan_Hans_CN
-        0xE00649444C61746EL, // gay_Latn_ID
-        0xB026494E44657661L, // gbm_Deva_IN
-        0xE426495241726162L, // gbz_Arab_IR
-        0xC44647464C61746EL, // gcr_Latn_GF
-        0x676447424C61746EL, // gd_Latn_GB
-        0xE486455445746869L, // gez_Ethi_ET
-        0xB4C64E5044657661L, // ggn_Deva_NP
-        0xAD064B494C61746EL, // gil_Latn_KI
-        0xA926504B41726162L, // gjk_Arab_PK
-        0xD126504B41726162L, // gju_Arab_PK
-        0x676C45534C61746EL, // gl_Latn_ES
-        0xA966495241726162L, // glk_Arab_IR
-        0x676E50594C61746EL, // gn_Latn_PY
-        0xB1C6494E44657661L, // gom_Deva_IN
-        0xB5C6494E54656C75L, // gon_Telu_IN
-        0xC5C649444C61746EL, // gor_Latn_ID
-        0xC9C64E4C4C61746EL, // gos_Latn_NL
-        0xCDC65541476F7468L, // got_Goth_UA
-        0x8A26435943707274L, // grc_Cprt_CY
-        0x8A2647524C696E62L, // grc_Linb_GR
-        0xCE26494E42656E67L, // grt_Beng_IN
-        0xDA4643484C61746EL, // gsw_Latn_CH
-        0x6775494E47756A72L, // gu_Gujr_IN
-        0x868642524C61746EL, // gub_Latn_BR
-        0x8A86434F4C61746EL, // guc_Latn_CO
-        0xC68647484C61746EL, // gur_Latn_GH
-        0xE6864B454C61746EL, // guz_Latn_KE
-        0x6776494D4C61746EL, // gv_Latn_IM
-        0xC6A64E5044657661L, // gvr_Deva_NP
-        0xA2C643414C61746EL, // gwi_Latn_CA
-        0x68614E474C61746EL, // ha_Latn_NG
-        0xA807434E48616E73L, // hak_Hans_CN
-        0xD80755534C61746EL, // haw_Latn_US
-        0xE407414641726162L, // haz_Arab_AF
-        0x6865494C48656272L, // he_Hebr_IL
-        0x6869494E44657661L, // hi_Deva_IN
-        0x9507464A4C61746EL, // hif_Latn_FJ
-        0xAD0750484C61746EL, // hil_Latn_PH
-        0xD1675452486C7577L, // hlu_Hluw_TR
-        0x8D87434E506C7264L, // hmd_Plrd_CN
-        0x8DA7504B41726162L, // hnd_Arab_PK
-        0x91A7494E44657661L, // hne_Deva_IN
-        0xA5A74C41486D6E67L, // hnj_Hmng_LA
-        0xB5A750484C61746EL, // hnn_Latn_PH
-        0xB9A7504B41726162L, // hno_Arab_PK
-        0x686F50474C61746EL, // ho_Latn_PG
-        0x89C7494E44657661L, // hoc_Deva_IN
-        0xA5C7494E44657661L, // hoj_Deva_IN
-        0x687248524C61746EL, // hr_Latn_HR
-        0x864744454C61746EL, // hsb_Latn_DE
-        0xB647434E48616E73L, // hsn_Hans_CN
-        0x687448544C61746EL, // ht_Latn_HT
-        0x687548554C61746EL, // hu_Latn_HU
-        0x6879414D41726D6EL, // hy_Armn_AM
-        0x687A4E414C61746EL, // hz_Latn_NA
-        0x696146524C61746EL, // ia_Latn_FR
-        0x80284D594C61746EL, // iba_Latn_MY
-        0x84284E474C61746EL, // ibb_Latn_NG
-        0x696449444C61746EL, // id_Latn_ID
-        0x69674E474C61746EL, // ig_Latn_NG
-        0x6969434E59696969L, // ii_Yiii_CN
-        0x696B55534C61746EL, // ik_Latn_US
-        0xCD4843414C61746EL, // ikt_Latn_CA
-        0xB96850484C61746EL, // ilo_Latn_PH
-        0x696E49444C61746EL, // in_Latn_ID
-        0x9DA852554379726CL, // inh_Cyrl_RU
-        0x697349534C61746EL, // is_Latn_IS
-        0x697449544C61746EL, // it_Latn_IT
-        0x6975434143616E73L, // iu_Cans_CA
-        0x6977494C48656272L, // iw_Hebr_IL
-        0x9F2852554C61746EL, // izh_Latn_RU
-        0x6A614A504A70616EL, // ja_Jpan_JP
-        0xB0094A4D4C61746EL, // jam_Latn_JM
-        0xB8C9434D4C61746EL, // jgo_Latn_CM
-        0x8989545A4C61746EL, // jmc_Latn_TZ
-        0xAD894E5044657661L, // jml_Deva_NP
-        0xCE89444B4C61746EL, // jut_Latn_DK
-        0x6A7649444C61746EL, // jv_Latn_ID
-        0x6A7749444C61746EL, // jw_Latn_ID
-        0x6B61474547656F72L, // ka_Geor_GE
-        0x800A555A4379726CL, // kaa_Cyrl_UZ
-        0x840A445A4C61746EL, // kab_Latn_DZ
-        0x880A4D4D4C61746EL, // kac_Latn_MM
-        0xA40A4E474C61746EL, // kaj_Latn_NG
-        0xB00A4B454C61746EL, // kam_Latn_KE
-        0xB80A4D4C4C61746EL, // kao_Latn_ML
-        0x8C2A52554379726CL, // kbd_Cyrl_RU
-        0xE02A4E4541726162L, // kby_Arab_NE
-        0x984A4E474C61746EL, // kcg_Latn_NG
-        0xA84A5A574C61746EL, // kck_Latn_ZW
-        0x906A545A4C61746EL, // kde_Latn_TZ
-        0x9C6A544741726162L, // kdh_Arab_TG
-        0xCC6A544854686169L, // kdt_Thai_TH
-        0x808A43564C61746EL, // kea_Latn_CV
-        0xB48A434D4C61746EL, // ken_Latn_CM
-        0xB8AA43494C61746EL, // kfo_Latn_CI
-        0xC4AA494E44657661L, // kfr_Deva_IN
-        0xE0AA494E44657661L, // kfy_Deva_IN
-        0x6B6743444C61746EL, // kg_Latn_CD
-        0x90CA49444C61746EL, // kge_Latn_ID
-        0xBCCA42524C61746EL, // kgp_Latn_BR
-        0x80EA494E4C61746EL, // kha_Latn_IN
-        0x84EA434E54616C75L, // khb_Talu_CN
-        0xB4EA494E44657661L, // khn_Deva_IN
-        0xC0EA4D4C4C61746EL, // khq_Latn_ML
-        0xCCEA494E4D796D72L, // kht_Mymr_IN
-        0xD8EA504B41726162L, // khw_Arab_PK
-        0x6B694B454C61746EL, // ki_Latn_KE
-        0xD10A54524C61746EL, // kiu_Latn_TR
-        0x6B6A4E414C61746EL, // kj_Latn_NA
-        0x992A4C414C616F6FL, // kjg_Laoo_LA
-        0x6B6B434E41726162L, // kk_Arab_CN
-        0x6B6B4B5A4379726CL, // kk_Cyrl_KZ
-        0xA54A434D4C61746EL, // kkj_Latn_CM
-        0x6B6C474C4C61746EL, // kl_Latn_GL
-        0xB56A4B454C61746EL, // kln_Latn_KE
-        0x6B6D4B484B686D72L, // km_Khmr_KH
-        0x858A414F4C61746EL, // kmb_Latn_AO
-        0x6B6E494E4B6E6461L, // kn_Knda_IN
-        0x6B6F4B524B6F7265L, // ko_Kore_KR
-        0xA1CA52554379726CL, // koi_Cyrl_RU
-        0xA9CA494E44657661L, // kok_Deva_IN
-        0xC9CA464D4C61746EL, // kos_Latn_FM
-        0x91EA4C524C61746EL, // kpe_Latn_LR
-        0x8A2A52554379726CL, // krc_Cyrl_RU
-        0xA22A534C4C61746EL, // kri_Latn_SL
-        0xA62A50484C61746EL, // krj_Latn_PH
-        0xAE2A52554C61746EL, // krl_Latn_RU
-        0xD22A494E44657661L, // kru_Deva_IN
-        0x6B73494E41726162L, // ks_Arab_IN
-        0x864A545A4C61746EL, // ksb_Latn_TZ
-        0x964A434D4C61746EL, // ksf_Latn_CM
-        0x9E4A44454C61746EL, // ksh_Latn_DE
-        0x6B75495141726162L, // ku_Arab_IQ
-        0x6B7554524C61746EL, // ku_Latn_TR
-        0xB28A52554379726CL, // kum_Cyrl_RU
-        0x6B7652554379726CL, // kv_Cyrl_RU
-        0xC6AA49444C61746EL, // kvr_Latn_ID
-        0xDEAA504B41726162L, // kvx_Arab_PK
-        0x6B7747424C61746EL, // kw_Latn_GB
-        0xB2EA544854686169L, // kxm_Thai_TH
-        0xBEEA504B41726162L, // kxp_Arab_PK
-        0x6B79434E41726162L, // ky_Arab_CN
-        0x6B794B474379726CL, // ky_Cyrl_KG
-        0x6B7954524C61746EL, // ky_Latn_TR
-        0x6C6156414C61746EL, // la_Latn_VA
-        0x840B47524C696E61L, // lab_Lina_GR
-        0x8C0B494C48656272L, // lad_Hebr_IL
-        0x980B545A4C61746EL, // lag_Latn_TZ
-        0x9C0B504B41726162L, // lah_Arab_PK
-        0xA40B55474C61746EL, // laj_Latn_UG
-        0x6C624C554C61746EL, // lb_Latn_LU
-        0x902B52554379726CL, // lbe_Cyrl_RU
-        0xD82B49444C61746EL, // lbw_Latn_ID
-        0xBC4B434E54686169L, // lcp_Thai_CN
-        0xBC8B494E4C657063L, // lep_Lepc_IN
-        0xE48B52554379726CL, // lez_Cyrl_RU
-        0x6C6755474C61746EL, // lg_Latn_UG
-        0x6C694E4C4C61746EL, // li_Latn_NL
-        0x950B4E5044657661L, // lif_Deva_NP
-        0x950B494E4C696D62L, // lif_Limb_IN
-        0xA50B49544C61746EL, // lij_Latn_IT
-        0xC90B434E4C697375L, // lis_Lisu_CN
-        0xBD2B49444C61746EL, // ljp_Latn_ID
-        0xA14B495241726162L, // lki_Arab_IR
-        0xCD4B55534C61746EL, // lkt_Latn_US
-        0xB58B494E54656C75L, // lmn_Telu_IN
-        0xB98B49544C61746EL, // lmo_Latn_IT
-        0x6C6E43444C61746EL, // ln_Latn_CD
-        0x6C6F4C414C616F6FL, // lo_Laoo_LA
-        0xADCB43444C61746EL, // lol_Latn_CD
-        0xE5CB5A4D4C61746EL, // loz_Latn_ZM
-        0x8A2B495241726162L, // lrc_Arab_IR
-        0x6C744C544C61746EL, // lt_Latn_LT
-        0x9A6B4C564C61746EL, // ltg_Latn_LV
-        0x6C7543444C61746EL, // lu_Latn_CD
-        0x828B43444C61746EL, // lua_Latn_CD
-        0xBA8B4B454C61746EL, // luo_Latn_KE
-        0xE28B4B454C61746EL, // luy_Latn_KE
-        0xE68B495241726162L, // luz_Arab_IR
-        0x6C764C564C61746EL, // lv_Latn_LV
-        0xAECB544854686169L, // lwl_Thai_TH
-        0x9F2B434E48616E73L, // lzh_Hans_CN
-        0xE72B54524C61746EL, // lzz_Latn_TR
-        0x8C0C49444C61746EL, // mad_Latn_ID
-        0x940C434D4C61746EL, // maf_Latn_CM
-        0x980C494E44657661L, // mag_Deva_IN
-        0xA00C494E44657661L, // mai_Deva_IN
-        0xA80C49444C61746EL, // mak_Latn_ID
-        0xB40C474D4C61746EL, // man_Latn_GM
-        0xB40C474E4E6B6F6FL, // man_Nkoo_GN
-        0xC80C4B454C61746EL, // mas_Latn_KE
-        0xE40C4D584C61746EL, // maz_Latn_MX
-        0x946C52554379726CL, // mdf_Cyrl_RU
-        0x9C6C50484C61746EL, // mdh_Latn_PH
-        0xC46C49444C61746EL, // mdr_Latn_ID
-        0xB48C534C4C61746EL, // men_Latn_SL
-        0xC48C4B454C61746EL, // mer_Latn_KE
-        0x80AC544841726162L, // mfa_Arab_TH
-        0x90AC4D554C61746EL, // mfe_Latn_MU
-        0x6D674D474C61746EL, // mg_Latn_MG
-        0x9CCC4D5A4C61746EL, // mgh_Latn_MZ
-        0xB8CC434D4C61746EL, // mgo_Latn_CM
-        0xBCCC4E5044657661L, // mgp_Deva_NP
-        0xE0CC545A4C61746EL, // mgy_Latn_TZ
-        0x6D684D484C61746EL, // mh_Latn_MH
-        0x6D694E5A4C61746EL, // mi_Latn_NZ
-        0xB50C49444C61746EL, // min_Latn_ID
-        0xC90C495148617472L, // mis_Hatr_IQ
-        0x6D6B4D4B4379726CL, // mk_Cyrl_MK
-        0x6D6C494E4D6C796DL, // ml_Mlym_IN
-        0xC96C53444C61746EL, // mls_Latn_SD
-        0x6D6E4D4E4379726CL, // mn_Cyrl_MN
-        0x6D6E434E4D6F6E67L, // mn_Mong_CN
-        0xA1AC494E42656E67L, // mni_Beng_IN
-        0xD9AC4D4D4D796D72L, // mnw_Mymr_MM
-        0x91CC43414C61746EL, // moe_Latn_CA
-        0x9DCC43414C61746EL, // moh_Latn_CA
-        0xC9CC42464C61746EL, // mos_Latn_BF
-        0x6D72494E44657661L, // mr_Deva_IN
-        0x8E2C4E5044657661L, // mrd_Deva_NP
-        0xA62C52554379726CL, // mrj_Cyrl_RU
-        0xBA2C42444D726F6FL, // mro_Mroo_BD
-        0x6D734D594C61746EL, // ms_Latn_MY
-        0x6D744D544C61746EL, // mt_Latn_MT
-        0xC66C494E44657661L, // mtr_Deva_IN
-        0x828C434D4C61746EL, // mua_Latn_CM
-        0xCA8C55534C61746EL, // mus_Latn_US
-        0xE2AC504B41726162L, // mvy_Arab_PK
-        0xAACC4D4C4C61746EL, // mwk_Latn_ML
-        0xC6CC494E44657661L, // mwr_Deva_IN
-        0xD6CC49444C61746EL, // mwv_Latn_ID
-        0x8AEC5A574C61746EL, // mxc_Latn_ZW
-        0x6D794D4D4D796D72L, // my_Mymr_MM
-        0xD70C52554379726CL, // myv_Cyrl_RU
-        0xDF0C55474C61746EL, // myx_Latn_UG
-        0xE70C49524D616E64L, // myz_Mand_IR
-        0xB72C495241726162L, // mzn_Arab_IR
-        0x6E614E524C61746EL, // na_Latn_NR
-        0xB40D434E48616E73L, // nan_Hans_CN
-        0xBC0D49544C61746EL, // nap_Latn_IT
-        0xC00D4E414C61746EL, // naq_Latn_NA
-        0x6E624E4F4C61746EL, // nb_Latn_NO
-        0x9C4D4D584C61746EL, // nch_Latn_MX
-        0x6E645A574C61746EL, // nd_Latn_ZW
-        0x886D4D5A4C61746EL, // ndc_Latn_MZ
-        0xC86D44454C61746EL, // nds_Latn_DE
-        0x6E654E5044657661L, // ne_Deva_NP
-        0xD88D4E5044657661L, // new_Deva_NP
-        0x6E674E414C61746EL, // ng_Latn_NA
-        0xACCD4D5A4C61746EL, // ngl_Latn_MZ
-        0x90ED4D584C61746EL, // nhe_Latn_MX
-        0xD8ED4D584C61746EL, // nhw_Latn_MX
-        0xA50D49444C61746EL, // nij_Latn_ID
-        0xD10D4E554C61746EL, // niu_Latn_NU
-        0xB92D494E4C61746EL, // njo_Latn_IN
-        0x6E6C4E4C4C61746EL, // nl_Latn_NL
-        0x998D434D4C61746EL, // nmg_Latn_CM
-        0x6E6E4E4F4C61746EL, // nn_Latn_NO
-        0x9DAD434D4C61746EL, // nnh_Latn_CM
-        0x6E6F4E4F4C61746EL, // no_Latn_NO
-        0x8DCD54484C616E61L, // nod_Lana_TH
-        0x91CD494E44657661L, // noe_Deva_IN
-        0xB5CD534552756E72L, // non_Runr_SE
-        0xBA0D474E4E6B6F6FL, // nqo_Nkoo_GN
-        0x6E725A414C61746EL, // nr_Latn_ZA
-        0xAA4D434143616E73L, // nsk_Cans_CA
-        0xBA4D5A414C61746EL, // nso_Latn_ZA
-        0xCA8D53534C61746EL, // nus_Latn_SS
-        0x6E7655534C61746EL, // nv_Latn_US
-        0xC2ED434E4C61746EL, // nxq_Latn_CN
-        0x6E794D574C61746EL, // ny_Latn_MW
-        0xB30D545A4C61746EL, // nym_Latn_TZ
-        0xB70D55474C61746EL, // nyn_Latn_UG
-        0xA32D47484C61746EL, // nzi_Latn_GH
-        0x6F6346524C61746EL, // oc_Latn_FR
-        0x6F6D45544C61746EL, // om_Latn_ET
-        0x6F72494E4F727961L, // or_Orya_IN
-        0x6F7347454379726CL, // os_Cyrl_GE
-        0x824E55534F736765L, // osa_Osge_US
-        0xAA6E4D4E4F726B68L, // otk_Orkh_MN
-        0x7061504B41726162L, // pa_Arab_PK
-        0x7061494E47757275L, // pa_Guru_IN
-        0x980F50484C61746EL, // pag_Latn_PH
-        0xAC0F495250686C69L, // pal_Phli_IR
-        0xAC0F434E50686C70L, // pal_Phlp_CN
-        0xB00F50484C61746EL, // pam_Latn_PH
-        0xBC0F41574C61746EL, // pap_Latn_AW
-        0xD00F50574C61746EL, // pau_Latn_PW
-        0x8C4F46524C61746EL, // pcd_Latn_FR
-        0xB04F4E474C61746EL, // pcm_Latn_NG
-        0x886F55534C61746EL, // pdc_Latn_US
-        0xCC6F43414C61746EL, // pdt_Latn_CA
-        0xB88F49525870656FL, // peo_Xpeo_IR
-        0xACAF44454C61746EL, // pfl_Latn_DE
-        0xB4EF4C4250686E78L, // phn_Phnx_LB
-        0x814F494E42726168L, // pka_Brah_IN
-        0xB94F4B454C61746EL, // pko_Latn_KE
-        0x706C504C4C61746EL, // pl_Latn_PL
-        0xC98F49544C61746EL, // pms_Latn_IT
-        0xCDAF47524772656BL, // pnt_Grek_GR
-        0xB5CF464D4C61746EL, // pon_Latn_FM
-        0x822F504B4B686172L, // pra_Khar_PK
-        0x8E2F495241726162L, // prd_Arab_IR
-        0x7073414641726162L, // ps_Arab_AF
-        0x707442524C61746EL, // pt_Latn_BR
-        0xD28F47414C61746EL, // puu_Latn_GA
-        0x717550454C61746EL, // qu_Latn_PE
-        0x8A9047544C61746EL, // quc_Latn_GT
-        0x9A9045434C61746EL, // qug_Latn_EC
-        0xA411494E44657661L, // raj_Deva_IN
-        0x945152454C61746EL, // rcf_Latn_RE
-        0xA49149444C61746EL, // rej_Latn_ID
-        0xB4D149544C61746EL, // rgn_Latn_IT
-        0x8111494E4C61746EL, // ria_Latn_IN
-        0x95114D4154666E67L, // rif_Tfng_MA
-        0xC9314E5044657661L, // rjs_Deva_NP
-        0xCD51424442656E67L, // rkt_Beng_BD
-        0x726D43484C61746EL, // rm_Latn_CH
-        0x959146494C61746EL, // rmf_Latn_FI
-        0xB99143484C61746EL, // rmo_Latn_CH
-        0xCD91495241726162L, // rmt_Arab_IR
-        0xD19153454C61746EL, // rmu_Latn_SE
-        0x726E42494C61746EL, // rn_Latn_BI
-        0x99B14D5A4C61746EL, // rng_Latn_MZ
-        0x726F524F4C61746EL, // ro_Latn_RO
-        0x85D149444C61746EL, // rob_Latn_ID
-        0x95D1545A4C61746EL, // rof_Latn_TZ
-        0xB271464A4C61746EL, // rtm_Latn_FJ
-        0x727552554379726CL, // ru_Cyrl_RU
-        0x929155414379726CL, // rue_Cyrl_UA
-        0x9A9153424C61746EL, // rug_Latn_SB
-        0x727752574C61746EL, // rw_Latn_RW
-        0xAAD1545A4C61746EL, // rwk_Latn_TZ
-        0xD3114A504B616E61L, // ryu_Kana_JP
-        0x7361494E44657661L, // sa_Deva_IN
-        0x941247484C61746EL, // saf_Latn_GH
-        0x9C1252554379726CL, // sah_Cyrl_RU
-        0xC0124B454C61746EL, // saq_Latn_KE
-        0xC81249444C61746EL, // sas_Latn_ID
-        0xCC12494E4C61746EL, // sat_Latn_IN
-        0xE412494E53617572L, // saz_Saur_IN
-        0xBC32545A4C61746EL, // sbp_Latn_TZ
-        0x736349544C61746EL, // sc_Latn_IT
-        0xA852494E44657661L, // sck_Deva_IN
-        0xB45249544C61746EL, // scn_Latn_IT
-        0xB85247424C61746EL, // sco_Latn_GB
-        0xC85243414C61746EL, // scs_Latn_CA
-        0x7364504B41726162L, // sd_Arab_PK
-        0x7364494E44657661L, // sd_Deva_IN
-        0x7364494E4B686F6AL, // sd_Khoj_IN
-        0x7364494E53696E64L, // sd_Sind_IN
-        0x887249544C61746EL, // sdc_Latn_IT
-        0x9C72495241726162L, // sdh_Arab_IR
-        0x73654E4F4C61746EL, // se_Latn_NO
-        0x949243494C61746EL, // sef_Latn_CI
-        0x9C924D5A4C61746EL, // seh_Latn_MZ
-        0xA0924D584C61746EL, // sei_Latn_MX
-        0xC8924D4C4C61746EL, // ses_Latn_ML
-        0x736743464C61746EL, // sg_Latn_CF
-        0x80D249454F67616DL, // sga_Ogam_IE
-        0xC8D24C544C61746EL, // sgs_Latn_LT
-        0xA0F24D4154666E67L, // shi_Tfng_MA
-        0xB4F24D4D4D796D72L, // shn_Mymr_MM
-        0x73694C4B53696E68L, // si_Sinh_LK
-        0x8D1245544C61746EL, // sid_Latn_ET
-        0x736B534B4C61746EL, // sk_Latn_SK
-        0xC552504B41726162L, // skr_Arab_PK
-        0x736C53494C61746EL, // sl_Latn_SI
-        0xA172504C4C61746EL, // sli_Latn_PL
-        0xE17249444C61746EL, // sly_Latn_ID
-        0x736D57534C61746EL, // sm_Latn_WS
-        0x819253454C61746EL, // sma_Latn_SE
-        0xA59253454C61746EL, // smj_Latn_SE
-        0xB59246494C61746EL, // smn_Latn_FI
-        0xBD92494C53616D72L, // smp_Samr_IL
-        0xC99246494C61746EL, // sms_Latn_FI
-        0x736E5A574C61746EL, // sn_Latn_ZW
-        0xA9B24D4C4C61746EL, // snk_Latn_ML
-        0x736F534F4C61746EL, // so_Latn_SO
-        0xD1D2544854686169L, // sou_Thai_TH
-        0x7371414C4C61746EL, // sq_Latn_AL
-        0x737252534379726CL, // sr_Cyrl_RS
-        0x737252534C61746EL, // sr_Latn_RS
-        0x8632494E536F7261L, // srb_Sora_IN
-        0xB63253524C61746EL, // srn_Latn_SR
-        0xC632534E4C61746EL, // srr_Latn_SN
-        0xDE32494E44657661L, // srx_Deva_IN
-        0x73735A414C61746EL, // ss_Latn_ZA
-        0xE25245524C61746EL, // ssy_Latn_ER
-        0x73745A414C61746EL, // st_Latn_ZA
-        0xC27244454C61746EL, // stq_Latn_DE
-        0x737549444C61746EL, // su_Latn_ID
-        0xAA92545A4C61746EL, // suk_Latn_TZ
-        0xCA92474E4C61746EL, // sus_Latn_GN
-        0x737653454C61746EL, // sv_Latn_SE
-        0x7377545A4C61746EL, // sw_Latn_TZ
-        0x86D2595441726162L, // swb_Arab_YT
-        0x8AD243444C61746EL, // swc_Latn_CD
-        0x9AD244454C61746EL, // swg_Latn_DE
-        0xD6D2494E44657661L, // swv_Deva_IN
-        0xB6F249444C61746EL, // sxn_Latn_ID
-        0xAF12424442656E67L, // syl_Beng_BD
-        0xC712495153797263L, // syr_Syrc_IQ
-        0xAF32504C4C61746EL, // szl_Latn_PL
-        0x7461494E54616D6CL, // ta_Taml_IN
-        0xA4134E5044657661L, // taj_Deva_NP
-        0xD83350484C61746EL, // tbw_Latn_PH
-        0xE053494E4B6E6461L, // tcy_Knda_IN
-        0x8C73434E54616C65L, // tdd_Tale_CN
-        0x98734E5044657661L, // tdg_Deva_NP
-        0x9C734E5044657661L, // tdh_Deva_NP
-        0x7465494E54656C75L, // te_Telu_IN
-        0xB093534C4C61746EL, // tem_Latn_SL
-        0xB89355474C61746EL, // teo_Latn_UG
-        0xCC93544C4C61746EL, // tet_Latn_TL
-        0x7467504B41726162L, // tg_Arab_PK
-        0x7467544A4379726CL, // tg_Cyrl_TJ
-        0x7468544854686169L, // th_Thai_TH
-        0xACF34E5044657661L, // thl_Deva_NP
-        0xC0F34E5044657661L, // thq_Deva_NP
-        0xC4F34E5044657661L, // thr_Deva_NP
-        0x7469455445746869L, // ti_Ethi_ET
-        0x9913455245746869L, // tig_Ethi_ER
-        0xD5134E474C61746EL, // tiv_Latn_NG
-        0x746B544D4C61746EL, // tk_Latn_TM
-        0xAD53544B4C61746EL, // tkl_Latn_TK
-        0xC553415A4C61746EL, // tkr_Latn_AZ
-        0xCD534E5044657661L, // tkt_Deva_NP
-        0x746C50484C61746EL, // tl_Latn_PH
-        0xE173415A4C61746EL, // tly_Latn_AZ
-        0x9D934E454C61746EL, // tmh_Latn_NE
-        0x746E5A414C61746EL, // tn_Latn_ZA
-        0x746F544F4C61746EL, // to_Latn_TO
-        0x99D34D574C61746EL, // tog_Latn_MW
-        0xA1F350474C61746EL, // tpi_Latn_PG
-        0x747254524C61746EL, // tr_Latn_TR
-        0xD23354524C61746EL, // tru_Latn_TR
-        0xD63354574C61746EL, // trv_Latn_TW
-        0x74735A414C61746EL, // ts_Latn_ZA
-        0x8E5347524772656BL, // tsd_Grek_GR
-        0x96534E5044657661L, // tsf_Deva_NP
-        0x9A5350484C61746EL, // tsg_Latn_PH
-        0xA653425454696274L, // tsj_Tibt_BT
-        0x747452554379726CL, // tt_Cyrl_RU
-        0xA67355474C61746EL, // ttj_Latn_UG
-        0xCA73544854686169L, // tts_Thai_TH
-        0xCE73415A4C61746EL, // ttt_Latn_AZ
-        0xB2934D574C61746EL, // tum_Latn_MW
-        0xAEB354564C61746EL, // tvl_Latn_TV
-        0xC2D34E454C61746EL, // twq_Latn_NE
-        0x9AF3434E54616E67L, // txg_Tang_CN
-        0x747950464C61746EL, // ty_Latn_PF
-        0xD71352554379726CL, // tyv_Cyrl_RU
-        0xB3334D414C61746EL, // tzm_Latn_MA
-        0xB07452554379726CL, // udm_Cyrl_RU
-        0x7567434E41726162L, // ug_Arab_CN
-        0x75674B5A4379726CL, // ug_Cyrl_KZ
-        0x80D4535955676172L, // uga_Ugar_SY
-        0x756B55414379726CL, // uk_Cyrl_UA
-        0xA174464D4C61746EL, // uli_Latn_FM
-        0x8594414F4C61746EL, // umb_Latn_AO
-        0xC5B4494E42656E67L, // unr_Beng_IN
-        0xC5B44E5044657661L, // unr_Deva_NP
-        0xDDB4494E42656E67L, // unx_Beng_IN
-        0x7572504B41726162L, // ur_Arab_PK
-        0x757A414641726162L, // uz_Arab_AF
-        0x757A555A4C61746EL, // uz_Latn_UZ
-        0xA0154C5256616969L, // vai_Vaii_LR
-        0x76655A414C61746EL, // ve_Latn_ZA
-        0x889549544C61746EL, // vec_Latn_IT
-        0xBC9552554C61746EL, // vep_Latn_RU
-        0x7669564E4C61746EL, // vi_Latn_VN
-        0x891553584C61746EL, // vic_Latn_SX
-        0xC97542454C61746EL, // vls_Latn_BE
-        0x959544454C61746EL, // vmf_Latn_DE
-        0xD9954D5A4C61746EL, // vmw_Latn_MZ
-        0xCDD552554C61746EL, // vot_Latn_RU
-        0xBA3545454C61746EL, // vro_Latn_EE
-        0xB695545A4C61746EL, // vun_Latn_TZ
-        0x776142454C61746EL, // wa_Latn_BE
-        0x901643484C61746EL, // wae_Latn_CH
-        0xAC16455445746869L, // wal_Ethi_ET
-        0xC41650484C61746EL, // war_Latn_PH
-        0xBC3641554C61746EL, // wbp_Latn_AU
-        0xC036494E54656C75L, // wbq_Telu_IN
-        0xC436494E44657661L, // wbr_Deva_IN
-        0xC97657464C61746EL, // wls_Latn_WF
-        0xA1B64B4D41726162L, // wni_Arab_KM
-        0x776F534E4C61746EL, // wo_Latn_SN
-        0xB276494E44657661L, // wtm_Deva_IN
-        0xD296434E48616E73L, // wuu_Hans_CN
-        0xD41742524C61746EL, // xav_Latn_BR
-        0xC457545243617269L, // xcr_Cari_TR
-        0x78685A414C61746EL, // xh_Latn_ZA
-        0x897754524C796369L, // xlc_Lyci_TR
-        0x8D7754524C796469L, // xld_Lydi_TR
-        0x9597474547656F72L, // xmf_Geor_GE
-        0xB597434E4D616E69L, // xmn_Mani_CN
-        0xC59753444D657263L, // xmr_Merc_SD
-        0x81B753414E617262L, // xna_Narb_SA
-        0xC5B7494E44657661L, // xnr_Deva_IN
-        0x99D755474C61746EL, // xog_Latn_UG
-        0xC5F7495250727469L, // xpr_Prti_IR
-        0x8257594553617262L, // xsa_Sarb_YE
-        0xC6574E5044657661L, // xsr_Deva_NP
-        0xB8184D5A4C61746EL, // yao_Latn_MZ
-        0xBC18464D4C61746EL, // yap_Latn_FM
-        0xD418434D4C61746EL, // yav_Latn_CM
-        0x8438434D4C61746EL, // ybb_Latn_CM
-        0x796F4E474C61746EL, // yo_Latn_NG
-        0xAE3842524C61746EL, // yrl_Latn_BR
-        0x82984D584C61746EL, // yua_Latn_MX
-        0x9298434E48616E73L, // yue_Hans_CN
-        0x9298484B48616E74L, // yue_Hant_HK
-        0x7A61434E4C61746EL, // za_Latn_CN
-        0x981953444C61746EL, // zag_Latn_SD
-        0xA4794B4D41726162L, // zdj_Arab_KM
-        0x80994E4C4C61746EL, // zea_Latn_NL
-        0x9CD94D4154666E67L, // zgh_Tfng_MA
-        0x7A685457426F706FL, // zh_Bopo_TW
-        0x7A68545748616E62L, // zh_Hanb_TW
-        0x7A68434E48616E73L, // zh_Hans_CN
-        0x7A68545748616E74L, // zh_Hant_TW
-        0xB17954474C61746EL, // zlm_Latn_TG
-        0xA1994D594C61746EL, // zmi_Latn_MY
-        0x7A755A414C61746EL, // zu_Latn_ZA
-        0x833954524C61746EL, // zza_Latn_TR
+      0x616145544C61746EL, // aa_Latn_ET
+      0x616247454379726CL, // ab_Cyrl_GE
+      0xC42047484C61746EL, // abr_Latn_GH
+      0x904049444C61746EL, // ace_Latn_ID
+      0x9C4055474C61746EL, // ach_Latn_UG
+      0x806047484C61746EL, // ada_Latn_GH
+      0xE06052554379726CL, // ady_Cyrl_RU
+      0x6165495241767374L, // ae_Avst_IR
+      0x8480544E41726162L, // aeb_Arab_TN
+      0x61665A414C61746EL, // af_Latn_ZA
+      0xC0C0434D4C61746EL, // agq_Latn_CM
+      0xB8E0494E41686F6DL, // aho_Ahom_IN
+      0x616B47484C61746EL, // ak_Latn_GH
+      0xA940495158737578L, // akk_Xsux_IQ
+      0xB560584B4C61746EL, // aln_Latn_XK
+      0xCD6052554379726CL, // alt_Cyrl_RU
+      0x616D455445746869L, // am_Ethi_ET
+      0xB9804E474C61746EL, // amo_Latn_NG
+      0xE5C049444C61746EL, // aoz_Latn_ID
+      0x8DE0544741726162L, // apd_Arab_TG
+      0x6172454741726162L, // ar_Arab_EG
+      0x8A20495241726D69L, // arc_Armi_IR
+      0x8A204A4F4E626174L, // arc_Nbat_JO
+      0x8A20535950616C6DL, // arc_Palm_SY
+      0xB620434C4C61746EL, // arn_Latn_CL
+      0xBA20424F4C61746EL, // aro_Latn_BO
+      0xC220445A41726162L, // arq_Arab_DZ
+      0xE2204D4141726162L, // ary_Arab_MA
+      0xE620454741726162L, // arz_Arab_EG
+      0x6173494E42656E67L, // as_Beng_IN
+      0x8240545A4C61746EL, // asa_Latn_TZ
+      0x9240555353676E77L, // ase_Sgnw_US
+      0xCE4045534C61746EL, // ast_Latn_ES
+      0xA66043414C61746EL, // atj_Latn_CA
+      0x617652554379726CL, // av_Cyrl_RU
+      0x82C0494E44657661L, // awa_Deva_IN
+      0x6179424F4C61746EL, // ay_Latn_BO
+      0x617A495241726162L, // az_Arab_IR
+      0x617A415A4C61746EL, // az_Latn_AZ
+      0x626152554379726CL, // ba_Cyrl_RU
+      0xAC01504B41726162L, // bal_Arab_PK
+      0xB40149444C61746EL, // ban_Latn_ID
+      0xBC014E5044657661L, // bap_Deva_NP
+      0xC40141544C61746EL, // bar_Latn_AT
+      0xC801434D4C61746EL, // bas_Latn_CM
+      0xDC01434D42616D75L, // bax_Bamu_CM
+      0x882149444C61746EL, // bbc_Latn_ID
+      0xA421434D4C61746EL, // bbj_Latn_CM
+      0xA04143494C61746EL, // bci_Latn_CI
+      0x626542594379726CL, // be_Cyrl_BY
+      0xA481534441726162L, // bej_Arab_SD
+      0xB0815A4D4C61746EL, // bem_Latn_ZM
+      0xD88149444C61746EL, // bew_Latn_ID
+      0xE481545A4C61746EL, // bez_Latn_TZ
+      0x8CA1434D4C61746EL, // bfd_Latn_CM
+      0xC0A1494E54616D6CL, // bfq_Taml_IN
+      0xCCA1504B41726162L, // bft_Arab_PK
+      0xE0A1494E44657661L, // bfy_Deva_IN
+      0x626742474379726CL, // bg_Cyrl_BG
+      0x88C1494E44657661L, // bgc_Deva_IN
+      0xB4C1504B41726162L, // bgn_Arab_PK
+      0xDCC154524772656BL, // bgx_Grek_TR
+      0x84E1494E44657661L, // bhb_Deva_IN
+      0xA0E1494E44657661L, // bhi_Deva_IN
+      0xA8E150484C61746EL, // bhk_Latn_PH
+      0xB8E1494E44657661L, // bho_Deva_IN
+      0x626956554C61746EL, // bi_Latn_VU
+      0xA90150484C61746EL, // bik_Latn_PH
+      0xB5014E474C61746EL, // bin_Latn_NG
+      0xA521494E44657661L, // bjj_Deva_IN
+      0xB52149444C61746EL, // bjn_Latn_ID
+      0xB141434D4C61746EL, // bkm_Latn_CM
+      0xD14150484C61746EL, // bku_Latn_PH
+      0xCD61564E54617674L, // blt_Tavt_VN
+      0x626D4D4C4C61746EL, // bm_Latn_ML
+      0xC1814D4C4C61746EL, // bmq_Latn_ML
+      0x626E424442656E67L, // bn_Beng_BD
+      0x626F434E54696274L, // bo_Tibt_CN
+      0xE1E1494E42656E67L, // bpy_Beng_IN
+      0xA201495241726162L, // bqi_Arab_IR
+      0xD60143494C61746EL, // bqv_Latn_CI
+      0x627246524C61746EL, // br_Latn_FR
+      0x8221494E44657661L, // bra_Deva_IN
+      0x9E21504B41726162L, // brh_Arab_PK
+      0xDE21494E44657661L, // brx_Deva_IN
+      0x627342414C61746EL, // bs_Latn_BA
+      0xC2414C5242617373L, // bsq_Bass_LR
+      0xCA41434D4C61746EL, // bss_Latn_CM
+      0xBA6150484C61746EL, // bto_Latn_PH
+      0xD661504B44657661L, // btv_Deva_PK
+      0x828152554379726CL, // bua_Cyrl_RU
+      0x8A8159544C61746EL, // buc_Latn_YT
+      0x9A8149444C61746EL, // bug_Latn_ID
+      0xB281434D4C61746EL, // bum_Latn_CM
+      0x86A147514C61746EL, // bvb_Latn_GQ
+      0xB701455245746869L, // byn_Ethi_ER
+      0xD701434D4C61746EL, // byv_Latn_CM
+      0x93214D4C4C61746EL, // bze_Latn_ML
+      0x636145534C61746EL, // ca_Latn_ES
+      0x9C424E474C61746EL, // cch_Latn_NG
+      0xBC42494E42656E67L, // ccp_Beng_IN
+      0xBC42424443616B6DL, // ccp_Cakm_BD
+      0x636552554379726CL, // ce_Cyrl_RU
+      0x848250484C61746EL, // ceb_Latn_PH
+      0x98C255474C61746EL, // cgg_Latn_UG
+      0x636847554C61746EL, // ch_Latn_GU
+      0xA8E2464D4C61746EL, // chk_Latn_FM
+      0xB0E252554379726CL, // chm_Cyrl_RU
+      0xB8E255534C61746EL, // cho_Latn_US
+      0xBCE243414C61746EL, // chp_Latn_CA
+      0xC4E2555343686572L, // chr_Cher_US
+      0x81224B4841726162L, // cja_Arab_KH
+      0xB122564E4368616DL, // cjm_Cham_VN
+      0x8542495141726162L, // ckb_Arab_IQ
+      0x636F46524C61746EL, // co_Latn_FR
+      0xBDC24547436F7074L, // cop_Copt_EG
+      0xC9E250484C61746EL, // cps_Latn_PH
+      0x6372434143616E73L, // cr_Cans_CA
+      0xA622434143616E73L, // crj_Cans_CA
+      0xAA22434143616E73L, // crk_Cans_CA
+      0xAE22434143616E73L, // crl_Cans_CA
+      0xB222434143616E73L, // crm_Cans_CA
+      0xCA2253434C61746EL, // crs_Latn_SC
+      0x6373435A4C61746EL, // cs_Latn_CZ
+      0x8642504C4C61746EL, // csb_Latn_PL
+      0xDA42434143616E73L, // csw_Cans_CA
+      0x8E624D4D50617563L, // ctd_Pauc_MM
+      0x637552554379726CL, // cu_Cyrl_RU
+      0x63754247476C6167L, // cu_Glag_BG
+      0x637652554379726CL, // cv_Cyrl_RU
+      0x637947424C61746EL, // cy_Latn_GB
+      0x6461444B4C61746EL, // da_Latn_DK
+      0xA80355534C61746EL, // dak_Latn_US
+      0xC40352554379726CL, // dar_Cyrl_RU
+      0xD4034B454C61746EL, // dav_Latn_KE
+      0x8843494E41726162L, // dcc_Arab_IN
+      0x646544454C61746EL, // de_Latn_DE
+      0xB48343414C61746EL, // den_Latn_CA
+      0xC4C343414C61746EL, // dgr_Latn_CA
+      0x91234E454C61746EL, // dje_Latn_NE
+      0xA5A343494C61746EL, // dnj_Latn_CI
+      0xA1C3494E41726162L, // doi_Arab_IN
+      0x864344454C61746EL, // dsb_Latn_DE
+      0xB2634D4C4C61746EL, // dtm_Latn_ML
+      0xBE634D594C61746EL, // dtp_Latn_MY
+      0xE2634E5044657661L, // dty_Deva_NP
+      0x8283434D4C61746EL, // dua_Latn_CM
+      0x64764D5654686161L, // dv_Thaa_MV
+      0xBB03534E4C61746EL, // dyo_Latn_SN
+      0xD30342464C61746EL, // dyu_Latn_BF
+      0x647A425454696274L, // dz_Tibt_BT
+      0xD0244B454C61746EL, // ebu_Latn_KE
+      0x656547484C61746EL, // ee_Latn_GH
+      0xA0A44E474C61746EL, // efi_Latn_NG
+      0xACC449544C61746EL, // egl_Latn_IT
+      0xE0C4454745677970L, // egy_Egyp_EG
+      0xE1444D4D4B616C69L, // eky_Kali_MM
+      0x656C47524772656BL, // el_Grek_GR
+      0x656E47424C61746EL, // en_Latn_GB
+      0x656E55534C61746EL, // en_Latn_US
+      0x656E474253686177L, // en_Shaw_GB
+      0x657345534C61746EL, // es_Latn_ES
+      0x65734D584C61746EL, // es_Latn_MX
+      0x657355534C61746EL, // es_Latn_US
+      0xD24455534C61746EL, // esu_Latn_US
+      0x657445454C61746EL, // et_Latn_EE
+      0xCE6449544974616CL, // ett_Ital_IT
+      0x657545534C61746EL, // eu_Latn_ES
+      0xBAC4434D4C61746EL, // ewo_Latn_CM
+      0xCEE445534C61746EL, // ext_Latn_ES
+      0x6661495241726162L, // fa_Arab_IR
+      0xB40547514C61746EL, // fan_Latn_GQ
+      0x6666474E41646C6DL, // ff_Adlm_GN
+      0x6666534E4C61746EL, // ff_Latn_SN
+      0xB0A54D4C4C61746EL, // ffm_Latn_ML
+      0x666946494C61746EL, // fi_Latn_FI
+      0x8105534441726162L, // fia_Arab_SD
+      0xAD0550484C61746EL, // fil_Latn_PH
+      0xCD0553454C61746EL, // fit_Latn_SE
+      0x666A464A4C61746EL, // fj_Latn_FJ
+      0x666F464F4C61746EL, // fo_Latn_FO
+      0xB5C5424A4C61746EL, // fon_Latn_BJ
+      0x667246524C61746EL, // fr_Latn_FR
+      0x8A2555534C61746EL, // frc_Latn_US
+      0xBE2546524C61746EL, // frp_Latn_FR
+      0xC62544454C61746EL, // frr_Latn_DE
+      0xCA2544454C61746EL, // frs_Latn_DE
+      0x8685434D41726162L, // fub_Arab_CM
+      0x8E8557464C61746EL, // fud_Latn_WF
+      0x9685474E4C61746EL, // fuf_Latn_GN
+      0xC2854E454C61746EL, // fuq_Latn_NE
+      0xC68549544C61746EL, // fur_Latn_IT
+      0xD6854E474C61746EL, // fuv_Latn_NG
+      0xC6A553444C61746EL, // fvr_Latn_SD
+      0x66794E4C4C61746EL, // fy_Latn_NL
+      0x676149454C61746EL, // ga_Latn_IE
+      0x800647484C61746EL, // gaa_Latn_GH
+      0x98064D444C61746EL, // gag_Latn_MD
+      0xB406434E48616E73L, // gan_Hans_CN
+      0xE00649444C61746EL, // gay_Latn_ID
+      0xB026494E44657661L, // gbm_Deva_IN
+      0xE426495241726162L, // gbz_Arab_IR
+      0xC44647464C61746EL, // gcr_Latn_GF
+      0x676447424C61746EL, // gd_Latn_GB
+      0xE486455445746869L, // gez_Ethi_ET
+      0xB4C64E5044657661L, // ggn_Deva_NP
+      0xAD064B494C61746EL, // gil_Latn_KI
+      0xA926504B41726162L, // gjk_Arab_PK
+      0xD126504B41726162L, // gju_Arab_PK
+      0x676C45534C61746EL, // gl_Latn_ES
+      0xA966495241726162L, // glk_Arab_IR
+      0x676E50594C61746EL, // gn_Latn_PY
+      0xB1C6494E44657661L, // gom_Deva_IN
+      0xB5C6494E54656C75L, // gon_Telu_IN
+      0xC5C649444C61746EL, // gor_Latn_ID
+      0xC9C64E4C4C61746EL, // gos_Latn_NL
+      0xCDC65541476F7468L, // got_Goth_UA
+      0x8A26435943707274L, // grc_Cprt_CY
+      0x8A2647524C696E62L, // grc_Linb_GR
+      0xCE26494E42656E67L, // grt_Beng_IN
+      0xDA4643484C61746EL, // gsw_Latn_CH
+      0x6775494E47756A72L, // gu_Gujr_IN
+      0x868642524C61746EL, // gub_Latn_BR
+      0x8A86434F4C61746EL, // guc_Latn_CO
+      0xC68647484C61746EL, // gur_Latn_GH
+      0xE6864B454C61746EL, // guz_Latn_KE
+      0x6776494D4C61746EL, // gv_Latn_IM
+      0xC6A64E5044657661L, // gvr_Deva_NP
+      0xA2C643414C61746EL, // gwi_Latn_CA
+      0x68614E474C61746EL, // ha_Latn_NG
+      0xA807434E48616E73L, // hak_Hans_CN
+      0xD80755534C61746EL, // haw_Latn_US
+      0xE407414641726162L, // haz_Arab_AF
+      0x6865494C48656272L, // he_Hebr_IL
+      0x6869494E44657661L, // hi_Deva_IN
+      0x9507464A4C61746EL, // hif_Latn_FJ
+      0xAD0750484C61746EL, // hil_Latn_PH
+      0xD1675452486C7577L, // hlu_Hluw_TR
+      0x8D87434E506C7264L, // hmd_Plrd_CN
+      0x8DA7504B41726162L, // hnd_Arab_PK
+      0x91A7494E44657661L, // hne_Deva_IN
+      0xA5A74C41486D6E67L, // hnj_Hmng_LA
+      0xB5A750484C61746EL, // hnn_Latn_PH
+      0xB9A7504B41726162L, // hno_Arab_PK
+      0x686F50474C61746EL, // ho_Latn_PG
+      0x89C7494E44657661L, // hoc_Deva_IN
+      0xA5C7494E44657661L, // hoj_Deva_IN
+      0x687248524C61746EL, // hr_Latn_HR
+      0x864744454C61746EL, // hsb_Latn_DE
+      0xB647434E48616E73L, // hsn_Hans_CN
+      0x687448544C61746EL, // ht_Latn_HT
+      0x687548554C61746EL, // hu_Latn_HU
+      0x6879414D41726D6EL, // hy_Armn_AM
+      0x687A4E414C61746EL, // hz_Latn_NA
+      0x696146524C61746EL, // ia_Latn_FR
+      0x80284D594C61746EL, // iba_Latn_MY
+      0x84284E474C61746EL, // ibb_Latn_NG
+      0x696449444C61746EL, // id_Latn_ID
+      0x69674E474C61746EL, // ig_Latn_NG
+      0x6969434E59696969L, // ii_Yiii_CN
+      0x696B55534C61746EL, // ik_Latn_US
+      0xCD4843414C61746EL, // ikt_Latn_CA
+      0xB96850484C61746EL, // ilo_Latn_PH
+      0x696E49444C61746EL, // in_Latn_ID
+      0x9DA852554379726CL, // inh_Cyrl_RU
+      0x697349534C61746EL, // is_Latn_IS
+      0x697449544C61746EL, // it_Latn_IT
+      0x6975434143616E73L, // iu_Cans_CA
+      0x6977494C48656272L, // iw_Hebr_IL
+      0x9F2852554C61746EL, // izh_Latn_RU
+      0x6A614A504A70616EL, // ja_Jpan_JP
+      0xB0094A4D4C61746EL, // jam_Latn_JM
+      0xB8C9434D4C61746EL, // jgo_Latn_CM
+      0x8989545A4C61746EL, // jmc_Latn_TZ
+      0xAD894E5044657661L, // jml_Deva_NP
+      0xCE89444B4C61746EL, // jut_Latn_DK
+      0x6A7649444C61746EL, // jv_Latn_ID
+      0x6A7749444C61746EL, // jw_Latn_ID
+      0x6B61474547656F72L, // ka_Geor_GE
+      0x800A555A4379726CL, // kaa_Cyrl_UZ
+      0x840A445A4C61746EL, // kab_Latn_DZ
+      0x880A4D4D4C61746EL, // kac_Latn_MM
+      0xA40A4E474C61746EL, // kaj_Latn_NG
+      0xB00A4B454C61746EL, // kam_Latn_KE
+      0xB80A4D4C4C61746EL, // kao_Latn_ML
+      0x8C2A52554379726CL, // kbd_Cyrl_RU
+      0xE02A4E4541726162L, // kby_Arab_NE
+      0x984A4E474C61746EL, // kcg_Latn_NG
+      0xA84A5A574C61746EL, // kck_Latn_ZW
+      0x906A545A4C61746EL, // kde_Latn_TZ
+      0x9C6A544741726162L, // kdh_Arab_TG
+      0xCC6A544854686169L, // kdt_Thai_TH
+      0x808A43564C61746EL, // kea_Latn_CV
+      0xB48A434D4C61746EL, // ken_Latn_CM
+      0xB8AA43494C61746EL, // kfo_Latn_CI
+      0xC4AA494E44657661L, // kfr_Deva_IN
+      0xE0AA494E44657661L, // kfy_Deva_IN
+      0x6B6743444C61746EL, // kg_Latn_CD
+      0x90CA49444C61746EL, // kge_Latn_ID
+      0xBCCA42524C61746EL, // kgp_Latn_BR
+      0x80EA494E4C61746EL, // kha_Latn_IN
+      0x84EA434E54616C75L, // khb_Talu_CN
+      0xB4EA494E44657661L, // khn_Deva_IN
+      0xC0EA4D4C4C61746EL, // khq_Latn_ML
+      0xCCEA494E4D796D72L, // kht_Mymr_IN
+      0xD8EA504B41726162L, // khw_Arab_PK
+      0x6B694B454C61746EL, // ki_Latn_KE
+      0xD10A54524C61746EL, // kiu_Latn_TR
+      0x6B6A4E414C61746EL, // kj_Latn_NA
+      0x992A4C414C616F6FL, // kjg_Laoo_LA
+      0x6B6B434E41726162L, // kk_Arab_CN
+      0x6B6B4B5A4379726CL, // kk_Cyrl_KZ
+      0xA54A434D4C61746EL, // kkj_Latn_CM
+      0x6B6C474C4C61746EL, // kl_Latn_GL
+      0xB56A4B454C61746EL, // kln_Latn_KE
+      0x6B6D4B484B686D72L, // km_Khmr_KH
+      0x858A414F4C61746EL, // kmb_Latn_AO
+      0x6B6E494E4B6E6461L, // kn_Knda_IN
+      0x6B6F4B524B6F7265L, // ko_Kore_KR
+      0xA1CA52554379726CL, // koi_Cyrl_RU
+      0xA9CA494E44657661L, // kok_Deva_IN
+      0xC9CA464D4C61746EL, // kos_Latn_FM
+      0x91EA4C524C61746EL, // kpe_Latn_LR
+      0x8A2A52554379726CL, // krc_Cyrl_RU
+      0xA22A534C4C61746EL, // kri_Latn_SL
+      0xA62A50484C61746EL, // krj_Latn_PH
+      0xAE2A52554C61746EL, // krl_Latn_RU
+      0xD22A494E44657661L, // kru_Deva_IN
+      0x6B73494E41726162L, // ks_Arab_IN
+      0x864A545A4C61746EL, // ksb_Latn_TZ
+      0x964A434D4C61746EL, // ksf_Latn_CM
+      0x9E4A44454C61746EL, // ksh_Latn_DE
+      0x6B75495141726162L, // ku_Arab_IQ
+      0x6B7554524C61746EL, // ku_Latn_TR
+      0xB28A52554379726CL, // kum_Cyrl_RU
+      0x6B7652554379726CL, // kv_Cyrl_RU
+      0xC6AA49444C61746EL, // kvr_Latn_ID
+      0xDEAA504B41726162L, // kvx_Arab_PK
+      0x6B7747424C61746EL, // kw_Latn_GB
+      0xB2EA544854686169L, // kxm_Thai_TH
+      0xBEEA504B41726162L, // kxp_Arab_PK
+      0x6B79434E41726162L, // ky_Arab_CN
+      0x6B794B474379726CL, // ky_Cyrl_KG
+      0x6B7954524C61746EL, // ky_Latn_TR
+      0x6C6156414C61746EL, // la_Latn_VA
+      0x840B47524C696E61L, // lab_Lina_GR
+      0x8C0B494C48656272L, // lad_Hebr_IL
+      0x980B545A4C61746EL, // lag_Latn_TZ
+      0x9C0B504B41726162L, // lah_Arab_PK
+      0xA40B55474C61746EL, // laj_Latn_UG
+      0x6C624C554C61746EL, // lb_Latn_LU
+      0x902B52554379726CL, // lbe_Cyrl_RU
+      0xD82B49444C61746EL, // lbw_Latn_ID
+      0xBC4B434E54686169L, // lcp_Thai_CN
+      0xBC8B494E4C657063L, // lep_Lepc_IN
+      0xE48B52554379726CL, // lez_Cyrl_RU
+      0x6C6755474C61746EL, // lg_Latn_UG
+      0x6C694E4C4C61746EL, // li_Latn_NL
+      0x950B4E5044657661L, // lif_Deva_NP
+      0x950B494E4C696D62L, // lif_Limb_IN
+      0xA50B49544C61746EL, // lij_Latn_IT
+      0xC90B434E4C697375L, // lis_Lisu_CN
+      0xBD2B49444C61746EL, // ljp_Latn_ID
+      0xA14B495241726162L, // lki_Arab_IR
+      0xCD4B55534C61746EL, // lkt_Latn_US
+      0xB58B494E54656C75L, // lmn_Telu_IN
+      0xB98B49544C61746EL, // lmo_Latn_IT
+      0x6C6E43444C61746EL, // ln_Latn_CD
+      0x6C6F4C414C616F6FL, // lo_Laoo_LA
+      0xADCB43444C61746EL, // lol_Latn_CD
+      0xE5CB5A4D4C61746EL, // loz_Latn_ZM
+      0x8A2B495241726162L, // lrc_Arab_IR
+      0x6C744C544C61746EL, // lt_Latn_LT
+      0x9A6B4C564C61746EL, // ltg_Latn_LV
+      0x6C7543444C61746EL, // lu_Latn_CD
+      0x828B43444C61746EL, // lua_Latn_CD
+      0xBA8B4B454C61746EL, // luo_Latn_KE
+      0xE28B4B454C61746EL, // luy_Latn_KE
+      0xE68B495241726162L, // luz_Arab_IR
+      0x6C764C564C61746EL, // lv_Latn_LV
+      0xAECB544854686169L, // lwl_Thai_TH
+      0x9F2B434E48616E73L, // lzh_Hans_CN
+      0xE72B54524C61746EL, // lzz_Latn_TR
+      0x8C0C49444C61746EL, // mad_Latn_ID
+      0x940C434D4C61746EL, // maf_Latn_CM
+      0x980C494E44657661L, // mag_Deva_IN
+      0xA00C494E44657661L, // mai_Deva_IN
+      0xA80C49444C61746EL, // mak_Latn_ID
+      0xB40C474D4C61746EL, // man_Latn_GM
+      0xB40C474E4E6B6F6FL, // man_Nkoo_GN
+      0xC80C4B454C61746EL, // mas_Latn_KE
+      0xE40C4D584C61746EL, // maz_Latn_MX
+      0x946C52554379726CL, // mdf_Cyrl_RU
+      0x9C6C50484C61746EL, // mdh_Latn_PH
+      0xC46C49444C61746EL, // mdr_Latn_ID
+      0xB48C534C4C61746EL, // men_Latn_SL
+      0xC48C4B454C61746EL, // mer_Latn_KE
+      0x80AC544841726162L, // mfa_Arab_TH
+      0x90AC4D554C61746EL, // mfe_Latn_MU
+      0x6D674D474C61746EL, // mg_Latn_MG
+      0x9CCC4D5A4C61746EL, // mgh_Latn_MZ
+      0xB8CC434D4C61746EL, // mgo_Latn_CM
+      0xBCCC4E5044657661L, // mgp_Deva_NP
+      0xE0CC545A4C61746EL, // mgy_Latn_TZ
+      0x6D684D484C61746EL, // mh_Latn_MH
+      0x6D694E5A4C61746EL, // mi_Latn_NZ
+      0xB50C49444C61746EL, // min_Latn_ID
+      0xC90C495148617472L, // mis_Hatr_IQ
+      0x6D6B4D4B4379726CL, // mk_Cyrl_MK
+      0x6D6C494E4D6C796DL, // ml_Mlym_IN
+      0xC96C53444C61746EL, // mls_Latn_SD
+      0x6D6E4D4E4379726CL, // mn_Cyrl_MN
+      0x6D6E434E4D6F6E67L, // mn_Mong_CN
+      0xA1AC494E42656E67L, // mni_Beng_IN
+      0xD9AC4D4D4D796D72L, // mnw_Mymr_MM
+      0x91CC43414C61746EL, // moe_Latn_CA
+      0x9DCC43414C61746EL, // moh_Latn_CA
+      0xC9CC42464C61746EL, // mos_Latn_BF
+      0x6D72494E44657661L, // mr_Deva_IN
+      0x8E2C4E5044657661L, // mrd_Deva_NP
+      0xA62C52554379726CL, // mrj_Cyrl_RU
+      0xBA2C42444D726F6FL, // mro_Mroo_BD
+      0x6D734D594C61746EL, // ms_Latn_MY
+      0x6D744D544C61746EL, // mt_Latn_MT
+      0xC66C494E44657661L, // mtr_Deva_IN
+      0x828C434D4C61746EL, // mua_Latn_CM
+      0xCA8C55534C61746EL, // mus_Latn_US
+      0xE2AC504B41726162L, // mvy_Arab_PK
+      0xAACC4D4C4C61746EL, // mwk_Latn_ML
+      0xC6CC494E44657661L, // mwr_Deva_IN
+      0xD6CC49444C61746EL, // mwv_Latn_ID
+      0x8AEC5A574C61746EL, // mxc_Latn_ZW
+      0x6D794D4D4D796D72L, // my_Mymr_MM
+      0xD70C52554379726CL, // myv_Cyrl_RU
+      0xDF0C55474C61746EL, // myx_Latn_UG
+      0xE70C49524D616E64L, // myz_Mand_IR
+      0xB72C495241726162L, // mzn_Arab_IR
+      0x6E614E524C61746EL, // na_Latn_NR
+      0xB40D434E48616E73L, // nan_Hans_CN
+      0xBC0D49544C61746EL, // nap_Latn_IT
+      0xC00D4E414C61746EL, // naq_Latn_NA
+      0x6E624E4F4C61746EL, // nb_Latn_NO
+      0x9C4D4D584C61746EL, // nch_Latn_MX
+      0x6E645A574C61746EL, // nd_Latn_ZW
+      0x886D4D5A4C61746EL, // ndc_Latn_MZ
+      0xC86D44454C61746EL, // nds_Latn_DE
+      0x6E654E5044657661L, // ne_Deva_NP
+      0xD88D4E5044657661L, // new_Deva_NP
+      0x6E674E414C61746EL, // ng_Latn_NA
+      0xACCD4D5A4C61746EL, // ngl_Latn_MZ
+      0x90ED4D584C61746EL, // nhe_Latn_MX
+      0xD8ED4D584C61746EL, // nhw_Latn_MX
+      0xA50D49444C61746EL, // nij_Latn_ID
+      0xD10D4E554C61746EL, // niu_Latn_NU
+      0xB92D494E4C61746EL, // njo_Latn_IN
+      0x6E6C4E4C4C61746EL, // nl_Latn_NL
+      0x998D434D4C61746EL, // nmg_Latn_CM
+      0x6E6E4E4F4C61746EL, // nn_Latn_NO
+      0x9DAD434D4C61746EL, // nnh_Latn_CM
+      0x6E6F4E4F4C61746EL, // no_Latn_NO
+      0x8DCD54484C616E61L, // nod_Lana_TH
+      0x91CD494E44657661L, // noe_Deva_IN
+      0xB5CD534552756E72L, // non_Runr_SE
+      0xBA0D474E4E6B6F6FL, // nqo_Nkoo_GN
+      0x6E725A414C61746EL, // nr_Latn_ZA
+      0xAA4D434143616E73L, // nsk_Cans_CA
+      0xBA4D5A414C61746EL, // nso_Latn_ZA
+      0xCA8D53534C61746EL, // nus_Latn_SS
+      0x6E7655534C61746EL, // nv_Latn_US
+      0xC2ED434E4C61746EL, // nxq_Latn_CN
+      0x6E794D574C61746EL, // ny_Latn_MW
+      0xB30D545A4C61746EL, // nym_Latn_TZ
+      0xB70D55474C61746EL, // nyn_Latn_UG
+      0xA32D47484C61746EL, // nzi_Latn_GH
+      0x6F6346524C61746EL, // oc_Latn_FR
+      0x6F6D45544C61746EL, // om_Latn_ET
+      0x6F72494E4F727961L, // or_Orya_IN
+      0x6F7347454379726CL, // os_Cyrl_GE
+      0x824E55534F736765L, // osa_Osge_US
+      0xAA6E4D4E4F726B68L, // otk_Orkh_MN
+      0x7061504B41726162L, // pa_Arab_PK
+      0x7061494E47757275L, // pa_Guru_IN
+      0x980F50484C61746EL, // pag_Latn_PH
+      0xAC0F495250686C69L, // pal_Phli_IR
+      0xAC0F434E50686C70L, // pal_Phlp_CN
+      0xB00F50484C61746EL, // pam_Latn_PH
+      0xBC0F41574C61746EL, // pap_Latn_AW
+      0xD00F50574C61746EL, // pau_Latn_PW
+      0x8C4F46524C61746EL, // pcd_Latn_FR
+      0xB04F4E474C61746EL, // pcm_Latn_NG
+      0x886F55534C61746EL, // pdc_Latn_US
+      0xCC6F43414C61746EL, // pdt_Latn_CA
+      0xB88F49525870656FL, // peo_Xpeo_IR
+      0xACAF44454C61746EL, // pfl_Latn_DE
+      0xB4EF4C4250686E78L, // phn_Phnx_LB
+      0x814F494E42726168L, // pka_Brah_IN
+      0xB94F4B454C61746EL, // pko_Latn_KE
+      0x706C504C4C61746EL, // pl_Latn_PL
+      0xC98F49544C61746EL, // pms_Latn_IT
+      0xCDAF47524772656BL, // pnt_Grek_GR
+      0xB5CF464D4C61746EL, // pon_Latn_FM
+      0x822F504B4B686172L, // pra_Khar_PK
+      0x8E2F495241726162L, // prd_Arab_IR
+      0x7073414641726162L, // ps_Arab_AF
+      0x707442524C61746EL, // pt_Latn_BR
+      0xD28F47414C61746EL, // puu_Latn_GA
+      0x717550454C61746EL, // qu_Latn_PE
+      0x8A9047544C61746EL, // quc_Latn_GT
+      0x9A9045434C61746EL, // qug_Latn_EC
+      0xA411494E44657661L, // raj_Deva_IN
+      0x945152454C61746EL, // rcf_Latn_RE
+      0xA49149444C61746EL, // rej_Latn_ID
+      0xB4D149544C61746EL, // rgn_Latn_IT
+      0x8111494E4C61746EL, // ria_Latn_IN
+      0x95114D4154666E67L, // rif_Tfng_MA
+      0xC9314E5044657661L, // rjs_Deva_NP
+      0xCD51424442656E67L, // rkt_Beng_BD
+      0x726D43484C61746EL, // rm_Latn_CH
+      0x959146494C61746EL, // rmf_Latn_FI
+      0xB99143484C61746EL, // rmo_Latn_CH
+      0xCD91495241726162L, // rmt_Arab_IR
+      0xD19153454C61746EL, // rmu_Latn_SE
+      0x726E42494C61746EL, // rn_Latn_BI
+      0x99B14D5A4C61746EL, // rng_Latn_MZ
+      0x726F524F4C61746EL, // ro_Latn_RO
+      0x85D149444C61746EL, // rob_Latn_ID
+      0x95D1545A4C61746EL, // rof_Latn_TZ
+      0xB271464A4C61746EL, // rtm_Latn_FJ
+      0x727552554379726CL, // ru_Cyrl_RU
+      0x929155414379726CL, // rue_Cyrl_UA
+      0x9A9153424C61746EL, // rug_Latn_SB
+      0x727752574C61746EL, // rw_Latn_RW
+      0xAAD1545A4C61746EL, // rwk_Latn_TZ
+      0xD3114A504B616E61L, // ryu_Kana_JP
+      0x7361494E44657661L, // sa_Deva_IN
+      0x941247484C61746EL, // saf_Latn_GH
+      0x9C1252554379726CL, // sah_Cyrl_RU
+      0xC0124B454C61746EL, // saq_Latn_KE
+      0xC81249444C61746EL, // sas_Latn_ID
+      0xCC12494E4C61746EL, // sat_Latn_IN
+      0xE412494E53617572L, // saz_Saur_IN
+      0xBC32545A4C61746EL, // sbp_Latn_TZ
+      0x736349544C61746EL, // sc_Latn_IT
+      0xA852494E44657661L, // sck_Deva_IN
+      0xB45249544C61746EL, // scn_Latn_IT
+      0xB85247424C61746EL, // sco_Latn_GB
+      0xC85243414C61746EL, // scs_Latn_CA
+      0x7364504B41726162L, // sd_Arab_PK
+      0x7364494E44657661L, // sd_Deva_IN
+      0x7364494E4B686F6AL, // sd_Khoj_IN
+      0x7364494E53696E64L, // sd_Sind_IN
+      0x887249544C61746EL, // sdc_Latn_IT
+      0x9C72495241726162L, // sdh_Arab_IR
+      0x73654E4F4C61746EL, // se_Latn_NO
+      0x949243494C61746EL, // sef_Latn_CI
+      0x9C924D5A4C61746EL, // seh_Latn_MZ
+      0xA0924D584C61746EL, // sei_Latn_MX
+      0xC8924D4C4C61746EL, // ses_Latn_ML
+      0x736743464C61746EL, // sg_Latn_CF
+      0x80D249454F67616DL, // sga_Ogam_IE
+      0xC8D24C544C61746EL, // sgs_Latn_LT
+      0xA0F24D4154666E67L, // shi_Tfng_MA
+      0xB4F24D4D4D796D72L, // shn_Mymr_MM
+      0x73694C4B53696E68L, // si_Sinh_LK
+      0x8D1245544C61746EL, // sid_Latn_ET
+      0x736B534B4C61746EL, // sk_Latn_SK
+      0xC552504B41726162L, // skr_Arab_PK
+      0x736C53494C61746EL, // sl_Latn_SI
+      0xA172504C4C61746EL, // sli_Latn_PL
+      0xE17249444C61746EL, // sly_Latn_ID
+      0x736D57534C61746EL, // sm_Latn_WS
+      0x819253454C61746EL, // sma_Latn_SE
+      0xA59253454C61746EL, // smj_Latn_SE
+      0xB59246494C61746EL, // smn_Latn_FI
+      0xBD92494C53616D72L, // smp_Samr_IL
+      0xC99246494C61746EL, // sms_Latn_FI
+      0x736E5A574C61746EL, // sn_Latn_ZW
+      0xA9B24D4C4C61746EL, // snk_Latn_ML
+      0x736F534F4C61746EL, // so_Latn_SO
+      0xD1D2544854686169L, // sou_Thai_TH
+      0x7371414C4C61746EL, // sq_Latn_AL
+      0x737252534379726CL, // sr_Cyrl_RS
+      0x737252534C61746EL, // sr_Latn_RS
+      0x8632494E536F7261L, // srb_Sora_IN
+      0xB63253524C61746EL, // srn_Latn_SR
+      0xC632534E4C61746EL, // srr_Latn_SN
+      0xDE32494E44657661L, // srx_Deva_IN
+      0x73735A414C61746EL, // ss_Latn_ZA
+      0xE25245524C61746EL, // ssy_Latn_ER
+      0x73745A414C61746EL, // st_Latn_ZA
+      0xC27244454C61746EL, // stq_Latn_DE
+      0x737549444C61746EL, // su_Latn_ID
+      0xAA92545A4C61746EL, // suk_Latn_TZ
+      0xCA92474E4C61746EL, // sus_Latn_GN
+      0x737653454C61746EL, // sv_Latn_SE
+      0x7377545A4C61746EL, // sw_Latn_TZ
+      0x86D2595441726162L, // swb_Arab_YT
+      0x8AD243444C61746EL, // swc_Latn_CD
+      0x9AD244454C61746EL, // swg_Latn_DE
+      0xD6D2494E44657661L, // swv_Deva_IN
+      0xB6F249444C61746EL, // sxn_Latn_ID
+      0xAF12424442656E67L, // syl_Beng_BD
+      0xC712495153797263L, // syr_Syrc_IQ
+      0xAF32504C4C61746EL, // szl_Latn_PL
+      0x7461494E54616D6CL, // ta_Taml_IN
+      0xA4134E5044657661L, // taj_Deva_NP
+      0xD83350484C61746EL, // tbw_Latn_PH
+      0xE053494E4B6E6461L, // tcy_Knda_IN
+      0x8C73434E54616C65L, // tdd_Tale_CN
+      0x98734E5044657661L, // tdg_Deva_NP
+      0x9C734E5044657661L, // tdh_Deva_NP
+      0x7465494E54656C75L, // te_Telu_IN
+      0xB093534C4C61746EL, // tem_Latn_SL
+      0xB89355474C61746EL, // teo_Latn_UG
+      0xCC93544C4C61746EL, // tet_Latn_TL
+      0x7467504B41726162L, // tg_Arab_PK
+      0x7467544A4379726CL, // tg_Cyrl_TJ
+      0x7468544854686169L, // th_Thai_TH
+      0xACF34E5044657661L, // thl_Deva_NP
+      0xC0F34E5044657661L, // thq_Deva_NP
+      0xC4F34E5044657661L, // thr_Deva_NP
+      0x7469455445746869L, // ti_Ethi_ET
+      0x9913455245746869L, // tig_Ethi_ER
+      0xD5134E474C61746EL, // tiv_Latn_NG
+      0x746B544D4C61746EL, // tk_Latn_TM
+      0xAD53544B4C61746EL, // tkl_Latn_TK
+      0xC553415A4C61746EL, // tkr_Latn_AZ
+      0xCD534E5044657661L, // tkt_Deva_NP
+      0x746C50484C61746EL, // tl_Latn_PH
+      0xE173415A4C61746EL, // tly_Latn_AZ
+      0x9D934E454C61746EL, // tmh_Latn_NE
+      0x746E5A414C61746EL, // tn_Latn_ZA
+      0x746F544F4C61746EL, // to_Latn_TO
+      0x99D34D574C61746EL, // tog_Latn_MW
+      0xA1F350474C61746EL, // tpi_Latn_PG
+      0x747254524C61746EL, // tr_Latn_TR
+      0xD23354524C61746EL, // tru_Latn_TR
+      0xD63354574C61746EL, // trv_Latn_TW
+      0x74735A414C61746EL, // ts_Latn_ZA
+      0x8E5347524772656BL, // tsd_Grek_GR
+      0x96534E5044657661L, // tsf_Deva_NP
+      0x9A5350484C61746EL, // tsg_Latn_PH
+      0xA653425454696274L, // tsj_Tibt_BT
+      0x747452554379726CL, // tt_Cyrl_RU
+      0xA67355474C61746EL, // ttj_Latn_UG
+      0xCA73544854686169L, // tts_Thai_TH
+      0xCE73415A4C61746EL, // ttt_Latn_AZ
+      0xB2934D574C61746EL, // tum_Latn_MW
+      0xAEB354564C61746EL, // tvl_Latn_TV
+      0xC2D34E454C61746EL, // twq_Latn_NE
+      0x9AF3434E54616E67L, // txg_Tang_CN
+      0x747950464C61746EL, // ty_Latn_PF
+      0xD71352554379726CL, // tyv_Cyrl_RU
+      0xB3334D414C61746EL, // tzm_Latn_MA
+      0xB07452554379726CL, // udm_Cyrl_RU
+      0x7567434E41726162L, // ug_Arab_CN
+      0x75674B5A4379726CL, // ug_Cyrl_KZ
+      0x80D4535955676172L, // uga_Ugar_SY
+      0x756B55414379726CL, // uk_Cyrl_UA
+      0xA174464D4C61746EL, // uli_Latn_FM
+      0x8594414F4C61746EL, // umb_Latn_AO
+      0xC5B4494E42656E67L, // unr_Beng_IN
+      0xC5B44E5044657661L, // unr_Deva_NP
+      0xDDB4494E42656E67L, // unx_Beng_IN
+      0x7572504B41726162L, // ur_Arab_PK
+      0x757A414641726162L, // uz_Arab_AF
+      0x757A555A4C61746EL, // uz_Latn_UZ
+      0xA0154C5256616969L, // vai_Vaii_LR
+      0x76655A414C61746EL, // ve_Latn_ZA
+      0x889549544C61746EL, // vec_Latn_IT
+      0xBC9552554C61746EL, // vep_Latn_RU
+      0x7669564E4C61746EL, // vi_Latn_VN
+      0x891553584C61746EL, // vic_Latn_SX
+      0xC97542454C61746EL, // vls_Latn_BE
+      0x959544454C61746EL, // vmf_Latn_DE
+      0xD9954D5A4C61746EL, // vmw_Latn_MZ
+      0xCDD552554C61746EL, // vot_Latn_RU
+      0xBA3545454C61746EL, // vro_Latn_EE
+      0xB695545A4C61746EL, // vun_Latn_TZ
+      0x776142454C61746EL, // wa_Latn_BE
+      0x901643484C61746EL, // wae_Latn_CH
+      0xAC16455445746869L, // wal_Ethi_ET
+      0xC41650484C61746EL, // war_Latn_PH
+      0xBC3641554C61746EL, // wbp_Latn_AU
+      0xC036494E54656C75L, // wbq_Telu_IN
+      0xC436494E44657661L, // wbr_Deva_IN
+      0xC97657464C61746EL, // wls_Latn_WF
+      0xA1B64B4D41726162L, // wni_Arab_KM
+      0x776F534E4C61746EL, // wo_Latn_SN
+      0xB276494E44657661L, // wtm_Deva_IN
+      0xD296434E48616E73L, // wuu_Hans_CN
+      0xD41742524C61746EL, // xav_Latn_BR
+      0xC457545243617269L, // xcr_Cari_TR
+      0x78685A414C61746EL, // xh_Latn_ZA
+      0x897754524C796369L, // xlc_Lyci_TR
+      0x8D7754524C796469L, // xld_Lydi_TR
+      0x9597474547656F72L, // xmf_Geor_GE
+      0xB597434E4D616E69L, // xmn_Mani_CN
+      0xC59753444D657263L, // xmr_Merc_SD
+      0x81B753414E617262L, // xna_Narb_SA
+      0xC5B7494E44657661L, // xnr_Deva_IN
+      0x99D755474C61746EL, // xog_Latn_UG
+      0xC5F7495250727469L, // xpr_Prti_IR
+      0x8257594553617262L, // xsa_Sarb_YE
+      0xC6574E5044657661L, // xsr_Deva_NP
+      0xB8184D5A4C61746EL, // yao_Latn_MZ
+      0xBC18464D4C61746EL, // yap_Latn_FM
+      0xD418434D4C61746EL, // yav_Latn_CM
+      0x8438434D4C61746EL, // ybb_Latn_CM
+      0x796F4E474C61746EL, // yo_Latn_NG
+      0xAE3842524C61746EL, // yrl_Latn_BR
+      0x82984D584C61746EL, // yua_Latn_MX
+      0x9298434E48616E73L, // yue_Hans_CN
+      0x9298484B48616E74L, // yue_Hant_HK
+      0x7A61434E4C61746EL, // za_Latn_CN
+      0x981953444C61746EL, // zag_Latn_SD
+      0xA4794B4D41726162L, // zdj_Arab_KM
+      0x80994E4C4C61746EL, // zea_Latn_NL
+      0x9CD94D4154666E67L, // zgh_Tfng_MA
+      0x7A685457426F706FL, // zh_Bopo_TW
+      0x7A68545748616E62L, // zh_Hanb_TW
+      0x7A68434E48616E73L, // zh_Hans_CN
+      0x7A68545748616E74L, // zh_Hant_TW
+      0xB17954474C61746EL, // zlm_Latn_TG
+      0xA1994D594C61746EL, // zmi_Latn_MY
+      0x7A755A414C61746EL, // zu_Latn_ZA
+      0x833954524C61746EL, // zza_Latn_TR
     };
 
     HashSet<Long> buildSet = new HashSet<>();
@@ -2208,11 +2209,11 @@ public class LocaleDataTables {
 
   static {
     int[][] entries = {
-        {0x6172445A, 0x61729420}, // ar-DZ -> ar-015
-        {0x61724548, 0x61729420}, // ar-EH -> ar-015
-        {0x61724C59, 0x61729420}, // ar-LY -> ar-015
-        {0x61724D41, 0x61729420}, // ar-MA -> ar-015
-        {0x6172544E, 0x61729420}, // ar-TN -> ar-015
+      {0x6172445A, 0x61729420}, // ar-DZ -> ar-015
+      {0x61724548, 0x61729420}, // ar-EH -> ar-015
+      {0x61724C59, 0x61729420}, // ar-LY -> ar-015
+      {0x61724D41, 0x61729420}, // ar-MA -> ar-015
+      {0x6172544E, 0x61729420}, // ar-TN -> ar-015
     };
 
     Map<Integer, Integer> buildMap = new HashMap<>();
@@ -2226,7 +2227,7 @@ public class LocaleDataTables {
 
   static {
     int[][] entries = {
-        {0x7A684D4F, 0x7A68484B}, // zh-Hant-MO -> zh-Hant-HK
+      {0x7A684D4F, 0x7A68484B}, // zh-Hant-MO -> zh-Hant-HK
     };
 
     Map<Integer, Integer> buildMap = new HashMap<>();
@@ -2240,131 +2241,131 @@ public class LocaleDataTables {
 
   static {
     int[][] entries = {
-        {0x656E80A1, 0x656E8400}, // en-150 -> en-001
-        {0x656E4147, 0x656E8400}, // en-AG -> en-001
-        {0x656E4149, 0x656E8400}, // en-AI -> en-001
-        {0x656E4154, 0x656E80A1}, // en-AT -> en-150
-        {0x656E4155, 0x656E8400}, // en-AU -> en-001
-        {0x656E4242, 0x656E8400}, // en-BB -> en-001
-        {0x656E4245, 0x656E8400}, // en-BE -> en-001
-        {0x656E424D, 0x656E8400}, // en-BM -> en-001
-        {0x656E4253, 0x656E8400}, // en-BS -> en-001
-        {0x656E4257, 0x656E8400}, // en-BW -> en-001
-        {0x656E425A, 0x656E8400}, // en-BZ -> en-001
-        {0x656E4341, 0x656E8400}, // en-CA -> en-001
-        {0x656E4343, 0x656E8400}, // en-CC -> en-001
-        {0x656E4348, 0x656E80A1}, // en-CH -> en-150
-        {0x656E434B, 0x656E8400}, // en-CK -> en-001
-        {0x656E434D, 0x656E8400}, // en-CM -> en-001
-        {0x656E4358, 0x656E8400}, // en-CX -> en-001
-        {0x656E4359, 0x656E8400}, // en-CY -> en-001
-        {0x656E4445, 0x656E80A1}, // en-DE -> en-150
-        {0x656E4447, 0x656E8400}, // en-DG -> en-001
-        {0x656E444B, 0x656E80A1}, // en-DK -> en-150
-        {0x656E444D, 0x656E8400}, // en-DM -> en-001
-        {0x656E4552, 0x656E8400}, // en-ER -> en-001
-        {0x656E4649, 0x656E80A1}, // en-FI -> en-150
-        {0x656E464A, 0x656E8400}, // en-FJ -> en-001
-        {0x656E464B, 0x656E8400}, // en-FK -> en-001
-        {0x656E464D, 0x656E8400}, // en-FM -> en-001
-        {0x656E4742, 0x656E8400}, // en-GB -> en-001
-        {0x656E4744, 0x656E8400}, // en-GD -> en-001
-        {0x656E4747, 0x656E8400}, // en-GG -> en-001
-        {0x656E4748, 0x656E8400}, // en-GH -> en-001
-        {0x656E4749, 0x656E8400}, // en-GI -> en-001
-        {0x656E474D, 0x656E8400}, // en-GM -> en-001
-        {0x656E4759, 0x656E8400}, // en-GY -> en-001
-        {0x656E484B, 0x656E8400}, // en-HK -> en-001
-        {0x656E4945, 0x656E8400}, // en-IE -> en-001
-        {0x656E494C, 0x656E8400}, // en-IL -> en-001
-        {0x656E494D, 0x656E8400}, // en-IM -> en-001
-        {0x656E494E, 0x656E8400}, // en-IN -> en-001
-        {0x656E494F, 0x656E8400}, // en-IO -> en-001
-        {0x656E4A45, 0x656E8400}, // en-JE -> en-001
-        {0x656E4A4D, 0x656E8400}, // en-JM -> en-001
-        {0x656E4B45, 0x656E8400}, // en-KE -> en-001
-        {0x656E4B49, 0x656E8400}, // en-KI -> en-001
-        {0x656E4B4E, 0x656E8400}, // en-KN -> en-001
-        {0x656E4B59, 0x656E8400}, // en-KY -> en-001
-        {0x656E4C43, 0x656E8400}, // en-LC -> en-001
-        {0x656E4C52, 0x656E8400}, // en-LR -> en-001
-        {0x656E4C53, 0x656E8400}, // en-LS -> en-001
-        {0x656E4D47, 0x656E8400}, // en-MG -> en-001
-        {0x656E4D4F, 0x656E8400}, // en-MO -> en-001
-        {0x656E4D53, 0x656E8400}, // en-MS -> en-001
-        {0x656E4D54, 0x656E8400}, // en-MT -> en-001
-        {0x656E4D55, 0x656E8400}, // en-MU -> en-001
-        {0x656E4D57, 0x656E8400}, // en-MW -> en-001
-        {0x656E4D59, 0x656E8400}, // en-MY -> en-001
-        {0x656E4E41, 0x656E8400}, // en-NA -> en-001
-        {0x656E4E46, 0x656E8400}, // en-NF -> en-001
-        {0x656E4E47, 0x656E8400}, // en-NG -> en-001
-        {0x656E4E4C, 0x656E80A1}, // en-NL -> en-150
-        {0x656E4E52, 0x656E8400}, // en-NR -> en-001
-        {0x656E4E55, 0x656E8400}, // en-NU -> en-001
-        {0x656E4E5A, 0x656E8400}, // en-NZ -> en-001
-        {0x656E5047, 0x656E8400}, // en-PG -> en-001
-        {0x656E5048, 0x656E8400}, // en-PH -> en-001
-        {0x656E504B, 0x656E8400}, // en-PK -> en-001
-        {0x656E504E, 0x656E8400}, // en-PN -> en-001
-        {0x656E5057, 0x656E8400}, // en-PW -> en-001
-        {0x656E5257, 0x656E8400}, // en-RW -> en-001
-        {0x656E5342, 0x656E8400}, // en-SB -> en-001
-        {0x656E5343, 0x656E8400}, // en-SC -> en-001
-        {0x656E5344, 0x656E8400}, // en-SD -> en-001
-        {0x656E5345, 0x656E80A1}, // en-SE -> en-150
-        {0x656E5347, 0x656E8400}, // en-SG -> en-001
-        {0x656E5348, 0x656E8400}, // en-SH -> en-001
-        {0x656E5349, 0x656E80A1}, // en-SI -> en-150
-        {0x656E534C, 0x656E8400}, // en-SL -> en-001
-        {0x656E5353, 0x656E8400}, // en-SS -> en-001
-        {0x656E5358, 0x656E8400}, // en-SX -> en-001
-        {0x656E535A, 0x656E8400}, // en-SZ -> en-001
-        {0x656E5443, 0x656E8400}, // en-TC -> en-001
-        {0x656E544B, 0x656E8400}, // en-TK -> en-001
-        {0x656E544F, 0x656E8400}, // en-TO -> en-001
-        {0x656E5454, 0x656E8400}, // en-TT -> en-001
-        {0x656E5456, 0x656E8400}, // en-TV -> en-001
-        {0x656E545A, 0x656E8400}, // en-TZ -> en-001
-        {0x656E5547, 0x656E8400}, // en-UG -> en-001
-        {0x656E5643, 0x656E8400}, // en-VC -> en-001
-        {0x656E5647, 0x656E8400}, // en-VG -> en-001
-        {0x656E5655, 0x656E8400}, // en-VU -> en-001
-        {0x656E5753, 0x656E8400}, // en-WS -> en-001
-        {0x656E5A41, 0x656E8400}, // en-ZA -> en-001
-        {0x656E5A4D, 0x656E8400}, // en-ZM -> en-001
-        {0x656E5A57, 0x656E8400}, // en-ZW -> en-001
-        {0x65734152, 0x6573A424}, // es-AR -> es-419
-        {0x6573424F, 0x6573A424}, // es-BO -> es-419
-        {0x65734252, 0x6573A424}, // es-BR -> es-419
-        {0x6573434C, 0x6573A424}, // es-CL -> es-419
-        {0x6573434F, 0x6573A424}, // es-CO -> es-419
-        {0x65734352, 0x6573A424}, // es-CR -> es-419
-        {0x65734355, 0x6573A424}, // es-CU -> es-419
-        {0x6573444F, 0x6573A424}, // es-DO -> es-419
-        {0x65734543, 0x6573A424}, // es-EC -> es-419
-        {0x65734754, 0x6573A424}, // es-GT -> es-419
-        {0x6573484E, 0x6573A424}, // es-HN -> es-419
-        {0x65734D58, 0x6573A424}, // es-MX -> es-419
-        {0x65734E49, 0x6573A424}, // es-NI -> es-419
-        {0x65735041, 0x6573A424}, // es-PA -> es-419
-        {0x65735045, 0x6573A424}, // es-PE -> es-419
-        {0x65735052, 0x6573A424}, // es-PR -> es-419
-        {0x65735059, 0x6573A424}, // es-PY -> es-419
-        {0x65735356, 0x6573A424}, // es-SV -> es-419
-        {0x65735553, 0x6573A424}, // es-US -> es-419
-        {0x65735559, 0x6573A424}, // es-UY -> es-419
-        {0x65735645, 0x6573A424}, // es-VE -> es-419
-        {0x7074414F, 0x70745054}, // pt-AO -> pt-PT
-        {0x70744348, 0x70745054}, // pt-CH -> pt-PT
-        {0x70744356, 0x70745054}, // pt-CV -> pt-PT
-        {0x70744751, 0x70745054}, // pt-GQ -> pt-PT
-        {0x70744757, 0x70745054}, // pt-GW -> pt-PT
-        {0x70744C55, 0x70745054}, // pt-LU -> pt-PT
-        {0x70744D4F, 0x70745054}, // pt-MO -> pt-PT
-        {0x70744D5A, 0x70745054}, // pt-MZ -> pt-PT
-        {0x70745354, 0x70745054}, // pt-ST -> pt-PT
-        {0x7074544C, 0x70745054}, // pt-TL -> pt-PT
+      {0x656E80A1, 0x656E8400}, // en-150 -> en-001
+      {0x656E4147, 0x656E8400}, // en-AG -> en-001
+      {0x656E4149, 0x656E8400}, // en-AI -> en-001
+      {0x656E4154, 0x656E80A1}, // en-AT -> en-150
+      {0x656E4155, 0x656E8400}, // en-AU -> en-001
+      {0x656E4242, 0x656E8400}, // en-BB -> en-001
+      {0x656E4245, 0x656E8400}, // en-BE -> en-001
+      {0x656E424D, 0x656E8400}, // en-BM -> en-001
+      {0x656E4253, 0x656E8400}, // en-BS -> en-001
+      {0x656E4257, 0x656E8400}, // en-BW -> en-001
+      {0x656E425A, 0x656E8400}, // en-BZ -> en-001
+      {0x656E4341, 0x656E8400}, // en-CA -> en-001
+      {0x656E4343, 0x656E8400}, // en-CC -> en-001
+      {0x656E4348, 0x656E80A1}, // en-CH -> en-150
+      {0x656E434B, 0x656E8400}, // en-CK -> en-001
+      {0x656E434D, 0x656E8400}, // en-CM -> en-001
+      {0x656E4358, 0x656E8400}, // en-CX -> en-001
+      {0x656E4359, 0x656E8400}, // en-CY -> en-001
+      {0x656E4445, 0x656E80A1}, // en-DE -> en-150
+      {0x656E4447, 0x656E8400}, // en-DG -> en-001
+      {0x656E444B, 0x656E80A1}, // en-DK -> en-150
+      {0x656E444D, 0x656E8400}, // en-DM -> en-001
+      {0x656E4552, 0x656E8400}, // en-ER -> en-001
+      {0x656E4649, 0x656E80A1}, // en-FI -> en-150
+      {0x656E464A, 0x656E8400}, // en-FJ -> en-001
+      {0x656E464B, 0x656E8400}, // en-FK -> en-001
+      {0x656E464D, 0x656E8400}, // en-FM -> en-001
+      {0x656E4742, 0x656E8400}, // en-GB -> en-001
+      {0x656E4744, 0x656E8400}, // en-GD -> en-001
+      {0x656E4747, 0x656E8400}, // en-GG -> en-001
+      {0x656E4748, 0x656E8400}, // en-GH -> en-001
+      {0x656E4749, 0x656E8400}, // en-GI -> en-001
+      {0x656E474D, 0x656E8400}, // en-GM -> en-001
+      {0x656E4759, 0x656E8400}, // en-GY -> en-001
+      {0x656E484B, 0x656E8400}, // en-HK -> en-001
+      {0x656E4945, 0x656E8400}, // en-IE -> en-001
+      {0x656E494C, 0x656E8400}, // en-IL -> en-001
+      {0x656E494D, 0x656E8400}, // en-IM -> en-001
+      {0x656E494E, 0x656E8400}, // en-IN -> en-001
+      {0x656E494F, 0x656E8400}, // en-IO -> en-001
+      {0x656E4A45, 0x656E8400}, // en-JE -> en-001
+      {0x656E4A4D, 0x656E8400}, // en-JM -> en-001
+      {0x656E4B45, 0x656E8400}, // en-KE -> en-001
+      {0x656E4B49, 0x656E8400}, // en-KI -> en-001
+      {0x656E4B4E, 0x656E8400}, // en-KN -> en-001
+      {0x656E4B59, 0x656E8400}, // en-KY -> en-001
+      {0x656E4C43, 0x656E8400}, // en-LC -> en-001
+      {0x656E4C52, 0x656E8400}, // en-LR -> en-001
+      {0x656E4C53, 0x656E8400}, // en-LS -> en-001
+      {0x656E4D47, 0x656E8400}, // en-MG -> en-001
+      {0x656E4D4F, 0x656E8400}, // en-MO -> en-001
+      {0x656E4D53, 0x656E8400}, // en-MS -> en-001
+      {0x656E4D54, 0x656E8400}, // en-MT -> en-001
+      {0x656E4D55, 0x656E8400}, // en-MU -> en-001
+      {0x656E4D57, 0x656E8400}, // en-MW -> en-001
+      {0x656E4D59, 0x656E8400}, // en-MY -> en-001
+      {0x656E4E41, 0x656E8400}, // en-NA -> en-001
+      {0x656E4E46, 0x656E8400}, // en-NF -> en-001
+      {0x656E4E47, 0x656E8400}, // en-NG -> en-001
+      {0x656E4E4C, 0x656E80A1}, // en-NL -> en-150
+      {0x656E4E52, 0x656E8400}, // en-NR -> en-001
+      {0x656E4E55, 0x656E8400}, // en-NU -> en-001
+      {0x656E4E5A, 0x656E8400}, // en-NZ -> en-001
+      {0x656E5047, 0x656E8400}, // en-PG -> en-001
+      {0x656E5048, 0x656E8400}, // en-PH -> en-001
+      {0x656E504B, 0x656E8400}, // en-PK -> en-001
+      {0x656E504E, 0x656E8400}, // en-PN -> en-001
+      {0x656E5057, 0x656E8400}, // en-PW -> en-001
+      {0x656E5257, 0x656E8400}, // en-RW -> en-001
+      {0x656E5342, 0x656E8400}, // en-SB -> en-001
+      {0x656E5343, 0x656E8400}, // en-SC -> en-001
+      {0x656E5344, 0x656E8400}, // en-SD -> en-001
+      {0x656E5345, 0x656E80A1}, // en-SE -> en-150
+      {0x656E5347, 0x656E8400}, // en-SG -> en-001
+      {0x656E5348, 0x656E8400}, // en-SH -> en-001
+      {0x656E5349, 0x656E80A1}, // en-SI -> en-150
+      {0x656E534C, 0x656E8400}, // en-SL -> en-001
+      {0x656E5353, 0x656E8400}, // en-SS -> en-001
+      {0x656E5358, 0x656E8400}, // en-SX -> en-001
+      {0x656E535A, 0x656E8400}, // en-SZ -> en-001
+      {0x656E5443, 0x656E8400}, // en-TC -> en-001
+      {0x656E544B, 0x656E8400}, // en-TK -> en-001
+      {0x656E544F, 0x656E8400}, // en-TO -> en-001
+      {0x656E5454, 0x656E8400}, // en-TT -> en-001
+      {0x656E5456, 0x656E8400}, // en-TV -> en-001
+      {0x656E545A, 0x656E8400}, // en-TZ -> en-001
+      {0x656E5547, 0x656E8400}, // en-UG -> en-001
+      {0x656E5643, 0x656E8400}, // en-VC -> en-001
+      {0x656E5647, 0x656E8400}, // en-VG -> en-001
+      {0x656E5655, 0x656E8400}, // en-VU -> en-001
+      {0x656E5753, 0x656E8400}, // en-WS -> en-001
+      {0x656E5A41, 0x656E8400}, // en-ZA -> en-001
+      {0x656E5A4D, 0x656E8400}, // en-ZM -> en-001
+      {0x656E5A57, 0x656E8400}, // en-ZW -> en-001
+      {0x65734152, 0x6573A424}, // es-AR -> es-419
+      {0x6573424F, 0x6573A424}, // es-BO -> es-419
+      {0x65734252, 0x6573A424}, // es-BR -> es-419
+      {0x6573434C, 0x6573A424}, // es-CL -> es-419
+      {0x6573434F, 0x6573A424}, // es-CO -> es-419
+      {0x65734352, 0x6573A424}, // es-CR -> es-419
+      {0x65734355, 0x6573A424}, // es-CU -> es-419
+      {0x6573444F, 0x6573A424}, // es-DO -> es-419
+      {0x65734543, 0x6573A424}, // es-EC -> es-419
+      {0x65734754, 0x6573A424}, // es-GT -> es-419
+      {0x6573484E, 0x6573A424}, // es-HN -> es-419
+      {0x65734D58, 0x6573A424}, // es-MX -> es-419
+      {0x65734E49, 0x6573A424}, // es-NI -> es-419
+      {0x65735041, 0x6573A424}, // es-PA -> es-419
+      {0x65735045, 0x6573A424}, // es-PE -> es-419
+      {0x65735052, 0x6573A424}, // es-PR -> es-419
+      {0x65735059, 0x6573A424}, // es-PY -> es-419
+      {0x65735356, 0x6573A424}, // es-SV -> es-419
+      {0x65735553, 0x6573A424}, // es-US -> es-419
+      {0x65735559, 0x6573A424}, // es-UY -> es-419
+      {0x65735645, 0x6573A424}, // es-VE -> es-419
+      {0x7074414F, 0x70745054}, // pt-AO -> pt-PT
+      {0x70744348, 0x70745054}, // pt-CH -> pt-PT
+      {0x70744356, 0x70745054}, // pt-CV -> pt-PT
+      {0x70744751, 0x70745054}, // pt-GQ -> pt-PT
+      {0x70744757, 0x70745054}, // pt-GW -> pt-PT
+      {0x70744C55, 0x70745054}, // pt-LU -> pt-PT
+      {0x70744D4F, 0x70745054}, // pt-MO -> pt-PT
+      {0x70744D5A, 0x70745054}, // pt-MZ -> pt-PT
+      {0x70745354, 0x70745054}, // pt-ST -> pt-PT
+      {0x7074544C, 0x70745054}, // pt-TL -> pt-PT
     };
     Map<Integer, Integer> buildMap = new HashMap<>();
     for (int[] entry : entries) {
diff --git a/resources/src/main/java/org/robolectric/res/android/Registries.java b/resources/src/main/java/org/robolectric/res/android/Registries.java
index 2408f6389..057a3d957 100644
--- a/resources/src/main/java/org/robolectric/res/android/Registries.java
+++ b/resources/src/main/java/org/robolectric/res/android/Registries.java
@@ -16,7 +16,7 @@ public class Registries {
   public static final NativeObjRegistry<ResXMLTree> NATIVE_RES_XML_TREES =
       new NativeObjRegistry<>(ResXMLTree.class);
   public static final NativeObjRegistry<ResXMLParser> NATIVE_RES_XML_PARSERS =
-          new NativeObjRegistry<>(ResXMLParser.class);
+      new NativeObjRegistry<>(ResXMLParser.class);
   static final NativeObjRegistry<WeakReference<ResStringPool>> NATIVE_STRING_POOLS =
       new NativeObjRegistry<>("ResStringPool");
   public static final NativeObjRegistry<Theme> NATIVE_THEME9_REGISTRY =
diff --git a/resources/src/main/java/org/robolectric/res/android/ResStringPool.java b/resources/src/main/java/org/robolectric/res/android/ResStringPool.java
index 9817e088b..0b6d1e731 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResStringPool.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResStringPool.java
@@ -1,7 +1,9 @@
 package org.robolectric.res.android;
 
-// transliterated from https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/ResourceTypes.cpp
-//   and https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/include/androidfw/ResourceTypes.h
+// transliterated from
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/ResourceTypes.cpp
+//   and
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/include/androidfw/ResourceTypes.h
 
 import static org.robolectric.res.android.Errors.BAD_TYPE;
 import static org.robolectric.res.android.Errors.NAME_NOT_FOUND;
@@ -25,9 +27,7 @@ import org.robolectric.res.android.ResourceTypes.ResStringPool_ref;
 import org.robolectric.res.android.ResourceTypes.ResStringPool_span;
 import org.robolectric.res.android.ResourceTypes.WithOffset;
 
-/**
- * Convenience class for accessing data in a ResStringPool resource.
- */
+/** Convenience class for accessing data in a ResStringPool resource. */
 @SuppressWarnings("NewApi")
 public class ResStringPool {
 
@@ -35,27 +35,27 @@ public class ResStringPool {
 
   private final long myNativePtr;
 
-  private int                    mError;
+  private int mError;
 
-   byte[]                       mOwnedData;
-  //private Object mOwnedData;
+  byte[] mOwnedData;
+  // private Object mOwnedData;
 
   private ResStringPool_header mHeader;
-  private int                      mSize;
-//    private mutable Mutex               mDecodeLock;
-//    const uint32_t*             mEntries;
-  private IntArray             mEntries;
-//    const uint32_t*             mEntryStyles;
-    private IntArray             mEntryStyles;
-//    const void*                 mStrings;
-    private int                 mStrings;
-  //private List<String> mStrings;
-  //private String[] mCache;
-  //private char16_t mutable**          mCache;
-    private int                    mStringPoolSize;    // number of uint16_t
-//    const uint32_t*             mStyles;
-    private int             mStyles;
-    private int                    mStylePoolSize;    // number of int
+  private int mSize;
+  //    private mutable Mutex               mDecodeLock;
+  //    const uint32_t*             mEntries;
+  private IntArray mEntries;
+  //    const uint32_t*             mEntryStyles;
+  private IntArray mEntryStyles;
+  //    const void*                 mStrings;
+  private int mStrings;
+  // private List<String> mStrings;
+  // private String[] mCache;
+  // private char16_t mutable**          mCache;
+  private int mStringPoolSize; // number of uint16_t
+  //    const uint32_t*             mStyles;
+  private int mStyles;
+  private int mStylePoolSize; // number of int
 
   public ResStringPool() {
     mError = NO_INIT;
@@ -85,8 +85,7 @@ public class ResStringPool {
     }
   }
 
-  void setToEmpty()
-  {
+  void setToEmpty() {
     uninit();
 
     ByteBuffer buf = ByteBuffer.allocate(16 * 1024).order(ByteOrder.LITTLE_ENDIAN);
@@ -110,7 +109,7 @@ public class ResStringPool {
   //  status_t setTo(const void* data, size_t size, bool copyData=false);
   public int setTo(ByteBuffer buf, int offset, int size, boolean copyData) {
     if (!isTruthy(buf) || !isTruthy(size)) {
-      return (mError=BAD_TYPE);
+      return (mError = BAD_TYPE);
     }
 
     uninit();
@@ -118,63 +117,66 @@ public class ResStringPool {
     // The chunk must be at least the size of the string pool header.
     if (size < ResStringPool_header.SIZEOF) {
       ALOGW("Bad string block: data size %d is too small to be a string block", size);
-      return (mError=BAD_TYPE);
+      return (mError = BAD_TYPE);
     }
 
     // The data is at least as big as a ResChunk_header, so we can safely validate the other
     // header fields.
     // `data + size` is safe because the source of `size` comes from the kernel/filesystem.
-    if (validate_chunk(new ResChunk_header(buf, offset), ResStringPool_header.SIZEOF,
-        size,
-        "ResStringPool_header") != NO_ERROR) {
+    if (validate_chunk(
+            new ResChunk_header(buf, offset),
+            ResStringPool_header.SIZEOF,
+            size,
+            "ResStringPool_header")
+        != NO_ERROR) {
       ALOGW("Bad string block: malformed block dimensions");
-      return (mError=BAD_TYPE);
+      return (mError = BAD_TYPE);
     }
 
-//    final boolean notDeviceEndian = htods((short) 0xf0) != 0xf0;
-//
-//    if (copyData || notDeviceEndian) {
-//      mOwnedData = data;
-//      if (mOwnedData == null) {
-//        return (mError=NO_MEMORY);
-//      }
-////      memcpy(mOwnedData, data, size);
-//      data = mOwnedData;
-//    }
+    //    final boolean notDeviceEndian = htods((short) 0xf0) != 0xf0;
+    //
+    //    if (copyData || notDeviceEndian) {
+    //      mOwnedData = data;
+    //      if (mOwnedData == null) {
+    //        return (mError=NO_MEMORY);
+    //      }
+    ////      memcpy(mOwnedData, data, size);
+    //      data = mOwnedData;
+    //    }
 
     // The size has been checked, so it is safe to read the data in the ResStringPool_header
     // data structure.
     mHeader = new ResStringPool_header(buf, offset);
 
-//    if (notDeviceEndian) {
-//      ResStringPool_header h = final_cast<ResStringPool_header*>(mHeader);
-//      h.header.headerSize = dtohs(mHeader.header.headerSize);
-//      h.header.type = dtohs(mHeader.header.type);
-//      h.header.size = dtohl(mHeader.header.size);
-//      h.stringCount = dtohl(mHeader.stringCount);
-//      h.styleCount = dtohl(mHeader.styleCount);
-//      h.flags = dtohl(mHeader.flags);
-//      h.stringsStart = dtohl(mHeader.stringsStart);
-//      h.stylesStart = dtohl(mHeader.stylesStart);
-//    }
-
-    if (mHeader.header.headerSize > mHeader.header.size
-        || mHeader.header.size > size) {
-      ALOGW("Bad string block: header size %d or total size %d is larger than data size %d\n",
-          (int)mHeader.header.headerSize, (int)mHeader.header.size, (int)size);
-      return (mError=BAD_TYPE);
+    //    if (notDeviceEndian) {
+    //      ResStringPool_header h = final_cast<ResStringPool_header*>(mHeader);
+    //      h.header.headerSize = dtohs(mHeader.header.headerSize);
+    //      h.header.type = dtohs(mHeader.header.type);
+    //      h.header.size = dtohl(mHeader.header.size);
+    //      h.stringCount = dtohl(mHeader.stringCount);
+    //      h.styleCount = dtohl(mHeader.styleCount);
+    //      h.flags = dtohl(mHeader.flags);
+    //      h.stringsStart = dtohl(mHeader.stringsStart);
+    //      h.stylesStart = dtohl(mHeader.stylesStart);
+    //    }
+
+    if (mHeader.header.headerSize > mHeader.header.size || mHeader.header.size > size) {
+      ALOGW(
+          "Bad string block: header size %d or total size %d is larger than data size %d\n",
+          (int) mHeader.header.headerSize, (int) mHeader.header.size, (int) size);
+      return (mError = BAD_TYPE);
     }
     mSize = mHeader.header.size;
     mEntries = new IntArray(mHeader.myBuf(), mHeader.myOffset() + mHeader.header.headerSize);
 
     if (mHeader.stringCount > 0) {
-      if ((mHeader.stringCount*4 /*sizeof(uint32_t)*/ < mHeader.stringCount)  // uint32 overflow?
-          || (mHeader.header.headerSize+(mHeader.stringCount*4 /*sizeof(uint32_t)*/))
-          > size) {
-        ALOGW("Bad string block: entry of %d items extends past data size %d\n",
-            (int)(mHeader.header.headerSize+(mHeader.stringCount*4/*sizeof(uint32_t)*/)),
-            (int)size);
-        return (mError=BAD_TYPE);
+      if ((mHeader.stringCount * 4 /*sizeof(uint32_t)*/ < mHeader.stringCount) // uint32 overflow?
+          || (mHeader.header.headerSize + (mHeader.stringCount * 4 /*sizeof(uint32_t)*/)) > size) {
+        ALOGW(
+            "Bad string block: entry of %d items extends past data size %d\n",
+            (int) (mHeader.header.headerSize + (mHeader.stringCount * 4 /*sizeof(uint32_t)*/)),
+            (int) size);
+        return (mError = BAD_TYPE);
       }
 
       int charSize;
@@ -187,9 +189,10 @@ public class ResStringPool {
       // There should be at least space for the smallest string
       // (2 bytes length, null terminator).
       if (mHeader.stringsStart >= (mSize - 2 /*sizeof(uint16_t)*/)) {
-        ALOGW("Bad string block: string pool starts at %d, after total size %d\n",
-            (int)mHeader.stringsStart, (int)mHeader.header.size);
-        return (mError=BAD_TYPE);
+        ALOGW(
+            "Bad string block: string pool starts at %d, after total size %d\n",
+            (int) mHeader.stringsStart, (int) mHeader.header.size);
+        return (mError = BAD_TYPE);
       }
 
       mStrings = mHeader.stringsStart;
@@ -199,24 +202,26 @@ public class ResStringPool {
       } else {
         // check invariant: styles starts before end of data
         if (mHeader.stylesStart >= (mSize - 2 /*sizeof(uint16_t)*/)) {
-          ALOGW("Bad style block: style block starts at %d past data size of %d\n",
-              (int)mHeader.stylesStart, (int)mHeader.header.size);
-          return (mError=BAD_TYPE);
+          ALOGW(
+              "Bad style block: style block starts at %d past data size of %d\n",
+              (int) mHeader.stylesStart, (int) mHeader.header.size);
+          return (mError = BAD_TYPE);
         }
         // check invariant: styles follow the strings
         if (mHeader.stylesStart <= mHeader.stringsStart) {
-          ALOGW("Bad style block: style block starts at %d, before strings at %d\n",
-              (int)mHeader.stylesStart, (int)mHeader.stringsStart);
-          return (mError=BAD_TYPE);
+          ALOGW(
+              "Bad style block: style block starts at %d, before strings at %d\n",
+              (int) mHeader.stylesStart, (int) mHeader.stringsStart);
+          return (mError = BAD_TYPE);
         }
-        mStringPoolSize =
-            (mHeader.stylesStart-mHeader.stringsStart)/charSize;
+        mStringPoolSize = (mHeader.stylesStart - mHeader.stringsStart) / charSize;
       }
 
       // check invariant: stringCount > 0 requires a string pool to exist
       if (mStringPoolSize == 0) {
-        ALOGW("Bad string block: stringCount is %d but pool size is 0\n", (int)mHeader.stringCount);
-        return (mError=BAD_TYPE);
+        ALOGW(
+            "Bad string block: stringCount is %d but pool size is 0\n", (int) mHeader.stringCount);
+        return (mError = BAD_TYPE);
       }
 
       //      if (notDeviceEndian) {
@@ -244,7 +249,7 @@ public class ResStringPool {
           || (!isTruthy(mHeader.flags & ResStringPool_header.UTF8_FLAG)
               && (mHeader.getShort(mStrings + mStringPoolSize * 2 - 2) != 0))) {
         ALOGW("Bad string block: last string is not 0-terminated\n");
-        return (mError=BAD_TYPE);
+        return (mError = BAD_TYPE);
       }
     } else {
       mStrings = -1;
@@ -252,52 +257,57 @@ public class ResStringPool {
     }
 
     if (mHeader.styleCount > 0) {
-      mEntryStyles = new IntArray(mEntries.myBuf(), mEntries.myOffset() + mHeader.stringCount * SIZEOF_INT);
+      mEntryStyles =
+          new IntArray(mEntries.myBuf(), mEntries.myOffset() + mHeader.stringCount * SIZEOF_INT);
       // invariant: integer overflow in calculating mEntryStyles
       if (mEntryStyles.myOffset() < mEntries.myOffset()) {
         ALOGW("Bad string block: integer overflow finding styles\n");
-        return (mError=BAD_TYPE);
+        return (mError = BAD_TYPE);
       }
 
-//      if (((const uint8_t*)mEntryStyles-(const uint8_t*)mHeader) > (int)size) {
-      if ((mEntryStyles.myOffset() - mHeader.myOffset()) > (int)size) {
+      //      if (((const uint8_t*)mEntryStyles-(const uint8_t*)mHeader) > (int)size) {
+      if ((mEntryStyles.myOffset() - mHeader.myOffset()) > (int) size) {
         ALOGW(
             "Bad string block: entry of %d styles extends past data size %d\n",
             (int) mEntryStyles.myOffset(), (int) size);
-        return (mError=BAD_TYPE);
+        return (mError = BAD_TYPE);
       }
       mStyles = mHeader.stylesStart;
       if (mHeader.stylesStart >= mHeader.header.size) {
-        ALOGW("Bad string block: style pool starts %d, after total size %d\n",
-            (int)mHeader.stylesStart, (int)mHeader.header.size);
-        return (mError=BAD_TYPE);
+        ALOGW(
+            "Bad string block: style pool starts %d, after total size %d\n",
+            (int) mHeader.stylesStart, (int) mHeader.header.size);
+        return (mError = BAD_TYPE);
       }
-      mStylePoolSize =
-          (mHeader.header.size-mHeader.stylesStart) /* / sizeof(uint32_t)*/;
-
-//      if (notDeviceEndian) {
-//        size_t i;
-//        uint32_t* e = final_cast<uint32_t*>(mEntryStyles);
-//        for (i=0; i<mHeader.styleCount; i++) {
-//          e[i] = dtohl(mEntryStyles[i]);
-//        }
-//        uint32_t* s = final_cast<uint32_t*>(mStyles);
-//        for (i=0; i<mStylePoolSize; i++) {
-//          s[i] = dtohl(mStyles[i]);
-//        }
-//      }
-
-//        final ResStringPool_span endSpan = {
-//          { htodl(ResStringPool_span.END) },
-//          htodl(ResStringPool_span.END), htodl(ResStringPool_span.END)
-//      };
-//      if (memcmp(&mStyles[mStylePoolSize-(sizeof(endSpan)/sizeof(uint32_t))],
-//                   &endSpan, sizeof(endSpan)) != 0) {
-      ResStringPool_span endSpan = new ResStringPool_span(buf,
-          mHeader.myOffset() + mStyles + (mStylePoolSize - ResStringPool_span.SIZEOF /* / 4 */));
+      mStylePoolSize = (mHeader.header.size - mHeader.stylesStart) /* / sizeof(uint32_t)*/;
+
+      //      if (notDeviceEndian) {
+      //        size_t i;
+      //        uint32_t* e = final_cast<uint32_t*>(mEntryStyles);
+      //        for (i=0; i<mHeader.styleCount; i++) {
+      //          e[i] = dtohl(mEntryStyles[i]);
+      //        }
+      //        uint32_t* s = final_cast<uint32_t*>(mStyles);
+      //        for (i=0; i<mStylePoolSize; i++) {
+      //          s[i] = dtohl(mStyles[i]);
+      //        }
+      //      }
+
+      //        final ResStringPool_span endSpan = {
+      //          { htodl(ResStringPool_span.END) },
+      //          htodl(ResStringPool_span.END), htodl(ResStringPool_span.END)
+      //      };
+      //      if (memcmp(&mStyles[mStylePoolSize-(sizeof(endSpan)/sizeof(uint32_t))],
+      //                   &endSpan, sizeof(endSpan)) != 0) {
+      ResStringPool_span endSpan =
+          new ResStringPool_span(
+              buf,
+              mHeader.myOffset()
+                  + mStyles
+                  + (mStylePoolSize - ResStringPool_span.SIZEOF /* / 4 */));
       if (!endSpan.isEnd()) {
         ALOGW("Bad string block: last style is not 0xFFFFFFFF-terminated\n");
-        return (mError=BAD_TYPE);
+        return (mError = BAD_TYPE);
       }
     } else {
       mEntryStyles = null;
@@ -305,14 +315,14 @@ public class ResStringPool {
       mStylePoolSize = 0;
     }
 
-    return (mError=NO_ERROR);
+    return (mError = NO_ERROR);
   }
 
-//  public void setTo(XmlResStringPool xmlStringPool) {
-//    this.mHeader = new ResStringPoolHeader();
-//    this.mStrings = new ArrayList<>();
-//    Collections.addAll(mStrings, xmlStringPool.strings());
-//  }
+  //  public void setTo(XmlResStringPool xmlStringPool) {
+  //    this.mHeader = new ResStringPoolHeader();
+  //    this.mStrings = new ArrayList<>();
+  //    Collections.addAll(mStrings, xmlStringPool.strings());
+  //  }
 
   private int setError(int error) {
     mError = error;
@@ -326,117 +336,119 @@ public class ResStringPool {
 
   public String stringAt(int idx) {
     if (mError == NO_ERROR && idx < mHeader.stringCount) {
-        final boolean isUTF8 = (mHeader.flags&ResStringPool_header.UTF8_FLAG) != 0;
-//        const uint32_t off = mEntries[idx]/(isUTF8?sizeof(uint8_t):sizeof(uint16_t));
+      final boolean isUTF8 = (mHeader.flags & ResStringPool_header.UTF8_FLAG) != 0;
+      //        const uint32_t off = mEntries[idx]/(isUTF8?sizeof(uint8_t):sizeof(uint16_t));
       ByteBuffer buf = mHeader.myBuf();
       int bufOffset = mHeader.myOffset();
       // const uint32_t off = mEntries[idx]/(isUTF8?sizeof(uint8_t):sizeof(uint16_t));
-      final int off = mEntries.get(idx)
-            /(isUTF8?1/*sizeof(uint8_t)*/:2/*sizeof(uint16_t)*/);
-      if (off < (mStringPoolSize-1)) {
+      final int off = mEntries.get(idx) / (isUTF8 ? 1 /*sizeof(uint8_t)*/ : 2 /*sizeof(uint16_t)*/);
+      if (off < (mStringPoolSize - 1)) {
         if (!isUTF8) {
           final int strings = mStrings;
-          final int str = strings+off*2;
+          final int str = strings + off * 2;
           return decodeString(buf, bufOffset + str, ResourceString.Type.UTF16);
-//          int u16len = decodeLengthUTF16(buf, bufOffset + str);
-//          if ((str+u16len*2-strings) < mStringPoolSize) {
-//            // Reject malformed (non null-terminated) strings
-//            if (buf.getShort(bufOffset + str + u16len*2) != 0x0000) {
-//              ALOGW("Bad string block: string #%d is not null-terminated",
-//                  (int)idx);
-//              return null;
-//            }
-//            byte[] bytes = new byte[u16len * 2];
-//            buf.position(bufOffset + str);
-//            buf.get(bytes);
-//               // Reject malformed (non null-terminated) strings
-//               if (str[encLen] != 0x00) {
-//                   ALOGW("Bad string block: string #%d is not null-terminated",
-//                         (int)idx);
-//                   return NULL;
-//               }
-//            return new String(bytes, StandardCharsets.UTF_16);
-//          } else {
-//            ALOGW("Bad string block: string #%d extends to %d, past end at %d\n",
-//                (int)idx, (int)(str+u16len-strings), (int)mStringPoolSize);
-//          }
+          //          int u16len = decodeLengthUTF16(buf, bufOffset + str);
+          //          if ((str+u16len*2-strings) < mStringPoolSize) {
+          //            // Reject malformed (non null-terminated) strings
+          //            if (buf.getShort(bufOffset + str + u16len*2) != 0x0000) {
+          //              ALOGW("Bad string block: string #%d is not null-terminated",
+          //                  (int)idx);
+          //              return null;
+          //            }
+          //            byte[] bytes = new byte[u16len * 2];
+          //            buf.position(bufOffset + str);
+          //            buf.get(bytes);
+          //               // Reject malformed (non null-terminated) strings
+          //               if (str[encLen] != 0x00) {
+          //                   ALOGW("Bad string block: string #%d is not null-terminated",
+          //                         (int)idx);
+          //                   return NULL;
+          //               }
+          //            return new String(bytes, StandardCharsets.UTF_16);
+          //          } else {
+          //            ALOGW("Bad string block: string #%d extends to %d, past end at %d\n",
+          //                (int)idx, (int)(str+u16len-strings), (int)mStringPoolSize);
+          //          }
         } else {
           final int strings = mStrings;
-          final int u8str = strings+off;
+          final int u8str = strings + off;
           return decodeString(buf, bufOffset + u8str, ResourceString.Type.UTF8);
 
-//                *u16len = decodeLength(&u8str);
-//          size_t u8len = decodeLength(&u8str);
-//
-//          // encLen must be less than 0x7FFF due to encoding.
-//          if ((uint32_t)(u8str+u8len-strings) < mStringPoolSize) {
-//            AutoMutex lock(mDecodeLock);
-//
-//            if (mCache != NULL && mCache[idx] != NULL) {
-//              return mCache[idx];
-//            }
-//
-//            // Retrieve the actual length of the utf8 string if the
-//            // encoded length was truncated
-//            if (stringDecodeAt(idx, u8str, u8len, &u8len) == NULL) {
-//                return NULL;
-//            }
-//
-//            // Since AAPT truncated lengths longer than 0x7FFF, check
-//            // that the bits that remain after truncation at least match
-//            // the bits of the actual length
-//            ssize_t actualLen = utf8_to_utf16_length(u8str, u8len);
-//            if (actualLen < 0 || ((size_t)actualLen & 0x7FFF) != *u16len) {
-//              ALOGW("Bad string block: string #%lld decoded length is not correct "
-//                  "%lld vs %llu\n",
-//                  (long long)idx, (long long)actualLen, (long long)*u16len);
-//              return NULL;
-//            }
-//
-//            utf8_to_utf16(u8str, u8len, u16str, *u16len + 1);
-//
-//            if (mCache == NULL) {
-// #ifndef __ANDROID__
-//                if (kDebugStringPoolNoisy) {
-//                    ALOGI("CREATING STRING CACHE OF %zu bytes",
-//                          mHeader->stringCount*sizeof(char16_t**));
-//                }
-// #else
-//                // We do not want to be in this case when actually running Android.
-//                ALOGW("CREATING STRING CACHE OF %zu bytes",
-//                        static_cast<size_t>(mHeader->stringCount*sizeof(char16_t**)));
-// #endif
-//                mCache = (char16_t**)calloc(mHeader->stringCount, sizeof(char16_t*));
-//                if (mCache == NULL) {
-//                    ALOGW("No memory trying to allocate decode cache table of %d bytes\n",
-//                          (int)(mHeader->stringCount*sizeof(char16_t**)));
-//                    return NULL;
-//                }
-//            }
-//            *u16len = (size_t) actualLen;
-//            char16_t *u16str = (char16_t *)calloc(*u16len+1, sizeof(char16_t));
-//            if (!u16str) {
-//              ALOGW("No memory when trying to allocate decode cache for string #%d\n",
-//                  (int)idx);
-//              return NULL;
-//            }
-//
-//            if (kDebugStringPoolNoisy) {
-//              ALOGI("Caching UTF8 string: %s", u8str);
-//            }
-//
-//            mCache[idx] = u16str;
-//            return u16str;
-//          } else {
-//            ALOGW("Bad string block: string #%lld extends to %lld, past end at %lld\n",
-//                (long long)idx, (long long)(u8str+u8len-strings),
-//                (long long)mStringPoolSize);
-//          }
+          //                *u16len = decodeLength(&u8str);
+          //          size_t u8len = decodeLength(&u8str);
+          //
+          //          // encLen must be less than 0x7FFF due to encoding.
+          //          if ((uint32_t)(u8str+u8len-strings) < mStringPoolSize) {
+          //            AutoMutex lock(mDecodeLock);
+          //
+          //            if (mCache != NULL && mCache[idx] != NULL) {
+          //              return mCache[idx];
+          //            }
+          //
+          //            // Retrieve the actual length of the utf8 string if the
+          //            // encoded length was truncated
+          //            if (stringDecodeAt(idx, u8str, u8len, &u8len) == NULL) {
+          //                return NULL;
+          //            }
+          //
+          //            // Since AAPT truncated lengths longer than 0x7FFF, check
+          //            // that the bits that remain after truncation at least match
+          //            // the bits of the actual length
+          //            ssize_t actualLen = utf8_to_utf16_length(u8str, u8len);
+          //            if (actualLen < 0 || ((size_t)actualLen & 0x7FFF) != *u16len) {
+          //              ALOGW("Bad string block: string #%lld decoded length is not correct "
+          //                  "%lld vs %llu\n",
+          //                  (long long)idx, (long long)actualLen, (long long)*u16len);
+          //              return NULL;
+          //            }
+          //
+          //            utf8_to_utf16(u8str, u8len, u16str, *u16len + 1);
+          //
+          //            if (mCache == NULL) {
+          // #ifndef __ANDROID__
+          //                if (kDebugStringPoolNoisy) {
+          //                    ALOGI("CREATING STRING CACHE OF %zu bytes",
+          //                          mHeader->stringCount*sizeof(char16_t**));
+          //                }
+          // #else
+          //                // We do not want to be in this case when actually running Android.
+          //                ALOGW("CREATING STRING CACHE OF %zu bytes",
+          //                        static_cast<size_t>(mHeader->stringCount*sizeof(char16_t**)));
+          // #endif
+          //                mCache = (char16_t**)calloc(mHeader->stringCount, sizeof(char16_t*));
+          //                if (mCache == NULL) {
+          //                    ALOGW("No memory trying to allocate decode cache table of %d
+          // bytes\n",
+          //                          (int)(mHeader->stringCount*sizeof(char16_t**)));
+          //                    return NULL;
+          //                }
+          //            }
+          //            *u16len = (size_t) actualLen;
+          //            char16_t *u16str = (char16_t *)calloc(*u16len+1, sizeof(char16_t));
+          //            if (!u16str) {
+          //              ALOGW("No memory when trying to allocate decode cache for string #%d\n",
+          //                  (int)idx);
+          //              return NULL;
+          //            }
+          //
+          //            if (kDebugStringPoolNoisy) {
+          //              ALOGI("Caching UTF8 string: %s", u8str);
+          //            }
+          //
+          //            mCache[idx] = u16str;
+          //            return u16str;
+          //          } else {
+          //            ALOGW("Bad string block: string #%lld extends to %lld, past end at %lld\n",
+          //                (long long)idx, (long long)(u8str+u8len-strings),
+          //                (long long)mStringPoolSize);
+          //          }
         }
       } else {
-        ALOGW("Bad string block: string #%d entry is at %d, past end at %d\n",
-            (int)idx, (int)(off*2/*sizeof(uint16_t)*/),
-            (int)(mStringPoolSize*2/*sizeof(uint16_t)*/));
+        ALOGW(
+            "Bad string block: string #%d entry is at %d, past end at %d\n",
+            (int) idx,
+            (int) (off * 2 /*sizeof(uint16_t)*/),
+            (int) (mStringPoolSize * 2 /*sizeof(uint16_t)*/));
       }
     }
     return null;
@@ -467,9 +479,9 @@ public class ResStringPool {
         return new ResStringPool_span(
             mHeader.myBuf(), mHeader.myOffset() + mStyles + off * SIZEOF_INT);
       } else {
-        ALOGW("Bad string block: style #%d entry is at %d, past end at %d\n",
-            (int)idx, (int)(off*SIZEOF_INT),
-            (int)(mStylePoolSize*SIZEOF_INT));
+        ALOGW(
+            "Bad string block: style #%d entry is at %d, past end at %d\n",
+            (int) idx, (int) (off * SIZEOF_INT), (int) (mStylePoolSize * SIZEOF_INT));
       }
     }
     return null;
@@ -484,23 +496,22 @@ public class ResStringPool {
       ALOGI("indexOfString : %s", str);
     }
 
-    if ( (mHeader.flags&ResStringPoolHeader.SORTED_FLAG) != 0) {
+    if ((mHeader.flags & ResStringPoolHeader.SORTED_FLAG) != 0) {
       // Do a binary search for the string...  this is a little tricky,
       // because the strings are sorted with strzcmp16().  So to match
       // the ordering, we need to convert strings in the pool to UTF-16.
       // But we don't want to hit the cache, so instead we will have a
       // local temporary allocation for the conversions.
       int l = 0;
-      int h = mHeader.stringCount-1;
+      int h = mHeader.stringCount - 1;
 
       int mid;
       while (l <= h) {
-        mid = l + (h - l)/2;
+        mid = l + (h - l) / 2;
         String s = stringAt(mid);
         int c = s != null ? s.compareTo(str) : -1;
         if (kDebugStringPoolNoisy) {
-          ALOGI("Looking at %s, cmp=%d, l/mid/h=%d/%d/%d\n",
-              s, c, (int)l, (int)mid, (int)h);
+          ALOGI("Looking at %s, cmp=%d, l/mid/h=%d/%d/%d\n", s, c, (int) l, (int) mid, (int) h);
         }
         if (c == 0) {
           if (kDebugStringPoolNoisy) {
@@ -518,7 +529,7 @@ public class ResStringPool {
       // most often this happens because we want to get IDs for style
       // span tags; since those always appear at the end of the string
       // block, start searching at the back.
-      for (int i = mHeader.stringCount; i>=0; i--) {
+      for (int i = mHeader.stringCount; i >= 0; i--) {
         String s = stringAt(i);
         if (kDebugStringPoolNoisy) {
           ALOGI("Looking at %s, i=%d\n", s, i);
@@ -534,18 +545,19 @@ public class ResStringPool {
 
     return NAME_NOT_FOUND;
   }
-//
-    public int size() {
-      return mError == NO_ERROR ? mHeader.stringCount : 0;
-    }
 
-    int styleCount() {
-      return mError == NO_ERROR ? mHeader.styleCount : 0;
-    }
+  //
+  public int size() {
+    return mError == NO_ERROR ? mHeader.stringCount : 0;
+  }
 
-    int bytes() {
-      return mError == NO_ERROR ? mHeader.header.size : 0;
-    }
+  int styleCount() {
+    return mError == NO_ERROR ? mHeader.styleCount : 0;
+  }
+
+  int bytes() {
+    return mError == NO_ERROR ? mHeader.header.size : 0;
+  }
 
   public boolean isUTF8() {
     return true;
@@ -555,11 +567,11 @@ public class ResStringPool {
     return mError;
   }
 
-//    int styleCount() final;
-//    int bytes() final;
-//
-//    boolean isSorted() final;
-//    boolean isUTF8() final;
-//
+  //    int styleCount() final;
+  //    int bytes() final;
+  //
+  //    boolean isSorted() final;
+  //    boolean isUTF8() final;
+  //
 
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/ResStringPoolHeader.java b/resources/src/main/java/org/robolectric/res/android/ResStringPoolHeader.java
index 308ab6843..830454f28 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResStringPoolHeader.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResStringPoolHeader.java
@@ -3,21 +3,19 @@ package org.robolectric.res.android;
 import org.robolectric.res.android.ResourceTypes.ResChunk_header;
 
 /**
- * Definition for a pool of strings.  The data of this chunk is an
- * array of uint32_t providing indices into the pool, relative to
- * stringsStart.  At stringsStart are all of the UTF-16 strings
- * concatenated together; each starts with a uint16_t of the string's
- * length and each ends with a 0x0000 terminator.  If a string is >
- * 32767 characters, the high bit of the length is set meaning to take
- * those 15 bits as a high word and it will be followed by another
- * uint16_t containing the low word.
+ * Definition for a pool of strings. The data of this chunk is an array of uint32_t providing
+ * indices into the pool, relative to stringsStart. At stringsStart are all of the UTF-16 strings
+ * concatenated together; each starts with a uint16_t of the string's length and each ends with a
+ * 0x0000 terminator. If a string is > 32767 characters, the high bit of the length is set meaning
+ * to take those 15 bits as a high word and it will be followed by another uint16_t containing the
+ * low word.
  *
- * If styleCount is not zero, then immediately following the array of
- * uint32_t indices into the string table is another array of indices
- * into a style table starting at stylesStart.  Each entry in the
- * style table is an array of ResStringPool_span structures.
+ * <p>If styleCount is not zero, then immediately following the array of uint32_t indices into the
+ * string table is another array of indices into a style table starting at stylesStart. Each entry
+ * in the style table is an array of ResStringPool_span structures.
  */
-// transliterated from https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/include/androidfw/ResourceTypes.h#434
+// transliterated from
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/include/androidfw/ResourceTypes.h#434
 public class ResStringPoolHeader {
   public static final int SIZEOF = ResChunk_header.SIZEOF + 20;
 
@@ -33,9 +31,9 @@ public class ResStringPoolHeader {
 
   // If set, the string index is sorted by the string values (based
   // on strcmp16()).
-  public static final int SORTED_FLAG = 1<<0;
+  public static final int SORTED_FLAG = 1 << 0;
   // String pool is encoded in UTF-8
-  public static final int UTF8_FLAG = 1<<8;
+  public static final int UTF8_FLAG = 1 << 8;
   int flags;
 
   // Index from header of the string data.
diff --git a/resources/src/main/java/org/robolectric/res/android/ResStringPoolRef.java b/resources/src/main/java/org/robolectric/res/android/ResStringPoolRef.java
index b748d7e47..c15b365b4 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResStringPoolRef.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResStringPoolRef.java
@@ -1,15 +1,13 @@
 package org.robolectric.res.android;
 
-/**
- * Reference to a string in a string pool.
- */
+/** Reference to a string in a string pool. */
 class ResStringPoolRef {
-    // Index into the string pool table (uint32_t-offset from the indices
-    // immediately after ResStringPool_header) at which to find the location
-    // of the string data in the pool.
-    int index;
+  // Index into the string pool table (uint32_t-offset from the indices
+  // immediately after ResStringPool_header) at which to find the location
+  // of the string data in the pool.
+  int index;
 
-    ResStringPoolRef(int index) {
-        this.index = index;
-    }
+  ResStringPoolRef(int index) {
+    this.index = index;
+  }
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/ResTable.java b/resources/src/main/java/org/robolectric/res/android/ResTable.java
index dd3ed1b09..1b93be631 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResTable.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResTable.java
@@ -59,8 +59,8 @@ public class ResTable {
   @SuppressWarnings("unused")
   private static final int IDMAP_CURRENT_VERSION = 0x00000001;
 
-  static final int APP_PACKAGE_ID      = 0x7f;
-  static final int SYS_PACKAGE_ID      = 0x01;
+  static final int APP_PACKAGE_ID = 0x7f;
+  static final int SYS_PACKAGE_ID = 0x01;
 
   static final boolean kDebugStringPoolNoisy = false;
   static final boolean kDebugXMLNoisy = false;
@@ -83,7 +83,7 @@ public class ResTable {
   // When iterating over a bag, the mLock mutex is locked. While mLock is locked,
   // we do resource lookups.
   // Mutex is not reentrant, so we must use a different lock than mLock.
-  final Object               mFilteredConfigLock = new Object();
+  final Object mFilteredConfigLock = new Object();
 
   // type defined in Errors
   int mError;
@@ -91,65 +91,79 @@ public class ResTable {
   ResTable_config mParams;
 
   // Array of all resource tables.
-  final List<Header>             mHeaders = new ArrayList<>();
+  final List<Header> mHeaders = new ArrayList<>();
 
   // Array of packages in all resource tables.
   final Map<Integer, PackageGroup> mPackageGroups = new HashMap<>();
 
   // Mapping from resource package IDs to indices into the internal
   // package array.
-  final byte[]                     mPackageMap = new byte[256];
+  final byte[] mPackageMap = new byte[256];
 
-  byte                     mNextPackageId;
+  byte mNextPackageId;
+
+  static boolean Res_CHECKID(int resid) {
+    return ((resid & 0xFFFF0000) != 0);
+  }
 
-  static boolean Res_CHECKID(int resid) { return ((resid&0xFFFF0000) != 0);}
   static int Res_GETPACKAGE(int id) {
-    return ((id>>24)-1);
+    return ((id >> 24) - 1);
   }
+
   public static int Res_GETTYPE(int id) {
-    return (((id>>16)&0xFF)-1);
+    return (((id >> 16) & 0xFF) - 1);
   }
+
   static int Res_GETENTRY(int id) {
-    return (id&0xFFFF);
+    return (id & 0xFFFF);
   }
-  static int Res_MAKEARRAY(int entry) { return (0x02000000 | (entry&0xFFFF)); }
-  static boolean Res_INTERNALID(int resid) { return ((resid&0xFFFF0000) != 0 && (resid&0xFF0000) == 0); }
 
-  int getResourcePackageIndex(int resID)
-  {
+  static int Res_MAKEARRAY(int entry) {
+    return (0x02000000 | (entry & 0xFFFF));
+  }
+
+  static boolean Res_INTERNALID(int resid) {
+    return ((resid & 0xFFFF0000) != 0 && (resid & 0xFF0000) == 0);
+  }
+
+  int getResourcePackageIndex(int resID) {
     return Res_GETPACKAGE(resID) + 1;
-    //return mPackageMap[Res_GETPACKAGE(resID)+1]-1;
+    // return mPackageMap[Res_GETPACKAGE(resID)+1]-1;
   }
 
   int getResourcePackageIndexFromPackage(byte packageID) {
-    return ((int)mPackageMap[packageID])-1;
+    return ((int) mPackageMap[packageID]) - 1;
   }
 
   //  Errors add(final Object data, int size, final int cookie, boolean copyData) {
-//    return addInternal(data, size, NULL, 0, false, cookie, copyData);
-//  }
-//
-//  Errors add(final Object data, int size, final Object idmapData, int idmapDataSize,
-//        final int cookie, boolean copyData, boolean appAsLib) {
-//    return addInternal(data, size, idmapData, idmapDataSize, appAsLib, cookie, copyData);
-//  }
-//
-//  Errors add(Asset asset, final int cookie, boolean copyData) {
-//    final Object data = asset.getBuffer(true);
-//    if (data == NULL) {
-//      ALOGW("Unable to get buffer of resource asset file");
-//      return UNKNOWN_ERROR;
-//    }
-//
-//    return addInternal(data, static_cast<int>(asset.getLength()), NULL, false, 0, cookie,
-//        copyData);
-//  }
-
-//  status_t add(Asset* asset, Asset* idmapAsset, const int32_t cookie=-1, bool copyData=false,
-//      bool appAsLib=false, bool isSystemAsset=false);
+  //    return addInternal(data, size, NULL, 0, false, cookie, copyData);
+  //  }
+  //
+  //  Errors add(final Object data, int size, final Object idmapData, int idmapDataSize,
+  //        final int cookie, boolean copyData, boolean appAsLib) {
+  //    return addInternal(data, size, idmapData, idmapDataSize, appAsLib, cookie, copyData);
+  //  }
+  //
+  //  Errors add(Asset asset, final int cookie, boolean copyData) {
+  //    final Object data = asset.getBuffer(true);
+  //    if (data == NULL) {
+  //      ALOGW("Unable to get buffer of resource asset file");
+  //      return UNKNOWN_ERROR;
+  //    }
+  //
+  //    return addInternal(data, static_cast<int>(asset.getLength()), NULL, false, 0, cookie,
+  //        copyData);
+  //  }
+
+  //  status_t add(Asset* asset, Asset* idmapAsset, const int32_t cookie=-1, bool copyData=false,
+  //      bool appAsLib=false, bool isSystemAsset=false);
   int add(
-      Asset asset, Asset idmapAsset, final int cookie, boolean copyData,
-      boolean appAsLib, boolean isSystemAsset) {
+      Asset asset,
+      Asset idmapAsset,
+      final int cookie,
+      boolean copyData,
+      boolean appAsLib,
+      boolean isSystemAsset) {
     final byte[] data = asset.getBuffer(true);
     if (data == NULL) {
       ALOGW("Unable to get buffer of resource asset file");
@@ -167,22 +181,34 @@ public class ResTable {
       idmapSize = (int) idmapAsset.getLength();
     }
 
-    return addInternal(data, (int) asset.getLength(),
-        idmapData, idmapSize, appAsLib, cookie, copyData, isSystemAsset);
+    return addInternal(
+        data,
+        (int) asset.getLength(),
+        idmapData,
+        idmapSize,
+        appAsLib,
+        cookie,
+        copyData,
+        isSystemAsset);
   }
 
-  int add(ResTable src, boolean isSystemAsset)
-  {
+  int add(ResTable src, boolean isSystemAsset) {
     mError = src.mError;
 
-    for (int i=0; i < src.mHeaders.size(); i++) {
+    for (int i = 0; i < src.mHeaders.size(); i++) {
       mHeaders.add(src.mHeaders.get(i));
     }
 
     for (PackageGroup srcPg : src.mPackageGroups.values()) {
-      PackageGroup pg = new PackageGroup(this, srcPg.name, srcPg.id,
-          false /* appAsLib */, isSystemAsset || srcPg.isSystemAsset, srcPg.isDynamic);
-      for (int j=0; j<srcPg.packages.size(); j++) {
+      PackageGroup pg =
+          new PackageGroup(
+              this,
+              srcPg.name,
+              srcPg.id,
+              false /* appAsLib */,
+              isSystemAsset || srcPg.isSystemAsset,
+              srcPg.isDynamic);
+      for (int j = 0; j < srcPg.packages.size(); j++) {
         pg.packages.add(srcPg.packages.get(j));
       }
 
@@ -195,7 +221,7 @@ public class ResTable {
       mPackageGroups.put(pg.id, pg);
     }
 
-//    memcpy(mPackageMap, src->mPackageMap, sizeof(mPackageMap));
+    //    memcpy(mPackageMap, src->mPackageMap, sizeof(mPackageMap));
     System.arraycopy(src.mPackageMap, 0, mPackageMap, 0, mPackageMap.length);
 
     return mError;
@@ -212,26 +238,34 @@ public class ResTable {
     ResChunk_header.write(buf, (short) RES_TABLE_TYPE, () -> {}, () -> {});
 
     ResTable_header resHeader = new ResTable_header(buf, 0);
-//    resHeader.header.type = RES_TABLE_TYPE;
-//    resHeader.header.headerSize = sizeof(ResTable_header);
-//    resHeader.header.size = sizeof(ResTable_header);
+    //    resHeader.header.type = RES_TABLE_TYPE;
+    //    resHeader.header.headerSize = sizeof(ResTable_header);
+    //    resHeader.header.size = sizeof(ResTable_header);
 
     header.header = resHeader;
     mHeaders.add(header);
-    return (mError=NO_ERROR);
+    return (mError = NO_ERROR);
   }
 
-//  status_t addInternal(const void* data, size_t size, const void* idmapData, size_t idmapDataSize,
-//      bool appAsLib, const int32_t cookie, bool copyData, bool isSystemAsset=false);
-  int addInternal(byte[] data, int dataSize, final Object idmapData, int idmapDataSize,
-      boolean appAsLib, final int cookie, boolean copyData, boolean isSystemAsset)
-  {
+  //  status_t addInternal(const void* data, size_t size, const void* idmapData, size_t
+  // idmapDataSize,
+  //      bool appAsLib, const int32_t cookie, bool copyData, bool isSystemAsset=false);
+  int addInternal(
+      byte[] data,
+      int dataSize,
+      final Object idmapData,
+      int idmapDataSize,
+      boolean appAsLib,
+      final int cookie,
+      boolean copyData,
+      boolean isSystemAsset) {
     if (!isTruthy(data)) {
       return NO_ERROR;
     }
 
     if (dataSize < ResTable_header.SIZEOF) {
-      ALOGE("Invalid data. Size(%d) is smaller than a ResTable_header(%d).",
+      ALOGE(
+          "Invalid data. Size(%d) is smaller than a ResTable_header(%d).",
           (int) dataSize, (int) ResTable_header.SIZEOF);
       return UNKNOWN_ERROR;
     }
@@ -242,119 +276,126 @@ public class ResTable {
     if (idmapData != NULL) {
       header.resourceIDMap = new int[idmapDataSize / 4];
       if (header.resourceIDMap == NULL) {
-//        delete header;
+        //        delete header;
         return (mError = NO_MEMORY);
       }
-//      memcpy(header.resourceIDMap, idmapData, idmapDataSize);
-//      header.resourceIDMapSize = idmapDataSize;
+      //      memcpy(header.resourceIDMap, idmapData, idmapDataSize);
+      //      header.resourceIDMapSize = idmapDataSize;
     }
     mHeaders.add(header);
 
     final boolean notDeviceEndian = htods((short) 0xf0) != 0xf0;
 
     if (kDebugLoadTableNoisy) {
-      ALOGV("Adding resources to ResTable: data=%s, size=0x%x, cookie=%d, copy=%b " +
-          "idmap=%s\n", data, dataSize, cookie, copyData, idmapData);
+      ALOGV(
+          "Adding resources to ResTable: data=%s, size=0x%x, cookie=%d, copy=%b " + "idmap=%s\n",
+          data, dataSize, cookie, copyData, idmapData);
     }
 
     if (copyData || notDeviceEndian) {
       header.ownedData = data; // malloc(dataSize);
       if (header.ownedData == NULL) {
-        return (mError=NO_MEMORY);
+        return (mError = NO_MEMORY);
       }
-//      memcpy(header.ownedData, data, dataSize);
+      //      memcpy(header.ownedData, data, dataSize);
       data = header.ownedData;
     }
 
     ByteBuffer buf = ByteBuffer.wrap(data).order(ByteOrder.LITTLE_ENDIAN);
-//    header->header = (const ResTable_header*)data;
+    //    header->header = (const ResTable_header*)data;
     header.header = new ResTable_header(buf, 0);
     header.size = dtohl(header.header.header.size);
     if (kDebugLoadTableSuperNoisy) {
-      ALOGI("Got size 0x%x, again size 0x%x, raw size 0x%x\n", header.size,
-          dtohl(header.header.header.size), header.header.header.size);
+      ALOGI(
+          "Got size 0x%x, again size 0x%x, raw size 0x%x\n",
+          header.size, dtohl(header.header.header.size), header.header.header.size);
     }
     if (kDebugLoadTableNoisy) {
       ALOGV("Loading ResTable @%s:\n", header.header);
     }
-    if (dtohs(header.header.header.headerSize) > header.size
-        || header.size > dataSize) {
+    if (dtohs(header.header.header.headerSize) > header.size || header.size > dataSize) {
       ALOGW(
           "Bad resource table: header size 0x%x or total size 0x%x is larger than data size 0x%x\n",
           (int) dtohs(header.header.header.headerSize), (int) header.size, (int) dataSize);
-      return (mError=BAD_TYPE);
+      return (mError = BAD_TYPE);
     }
-    if (((dtohs(header.header.header.headerSize)|header.size)&0x3) != 0) {
+    if (((dtohs(header.header.header.headerSize) | header.size) & 0x3) != 0) {
       ALOGW(
           "Bad resource table: header size 0x%x or total size 0x%x is not on an integer boundary\n",
           (int) dtohs(header.header.header.headerSize), (int) header.size);
-      return (mError=BAD_TYPE);
+      return (mError = BAD_TYPE);
     }
-//    header->dataEnd = ((const uint8_t*)header->header) + header->size;
+    //    header->dataEnd = ((const uint8_t*)header->header) + header->size;
     header.dataEnd = header.size;
 
     // Iterate through all chunks.
     int curPackage = 0;
 
-//    const ResChunk_header* chunk =
-//      (const ResChunk_header*)(((const uint8_t*)header->header)
-//    + dtohs(header->header->header.headerSize));
-    ResChunk_header chunk =
-      new ResChunk_header(buf, dtohs(header.header.header.headerSize));
+    //    const ResChunk_header* chunk =
+    //      (const ResChunk_header*)(((const uint8_t*)header->header)
+    //    + dtohs(header->header->header.headerSize));
+    ResChunk_header chunk = new ResChunk_header(buf, dtohs(header.header.header.headerSize));
     while (chunk != null
         && (chunk.myOffset() <= (header.dataEnd - ResChunk_header.SIZEOF)
             && chunk.myOffset() <= (header.dataEnd - dtohl(chunk.size)))) {
-    int err = validate_chunk(chunk, ResChunk_header.SIZEOF, header.dataEnd, "ResTable");
-    if (err != NO_ERROR) {
-      return (mError=err);
-    }
-    if (kDebugTableNoisy) {
+      int err = validate_chunk(chunk, ResChunk_header.SIZEOF, header.dataEnd, "ResTable");
+      if (err != NO_ERROR) {
+        return (mError = err);
+      }
+      if (kDebugTableNoisy) {
         ALOGV(
             "Chunk: type=0x%x, headerSize=0x%x, size=0x%x, pos=%s\n",
             dtohs(chunk.type),
             dtohs(chunk.headerSize),
             dtohl(chunk.size),
             (Object) (chunk.myOffset() - header.header.myOffset()));
-    }
-    final int csize = dtohl(chunk.size);
-    final int ctype = dtohs(chunk.type);
-    if (ctype == RES_STRING_POOL_TYPE) {
-      if (header.values.getError() != NO_ERROR) {
-        // Only use the first string chunk; ignore any others that
-        // may appear.
-        err = header.values.setTo(chunk.myBuf(), chunk.myOffset(), csize, false);
-        if (err != NO_ERROR) {
-          return (mError=err);
-        }
-      } else {
-        ALOGW("Multiple string chunks found in resource table.");
-      }
-    } else if (ctype == RES_TABLE_PACKAGE_TYPE) {
-      if (curPackage >= dtohl(header.header.packageCount)) {
-        ALOGW("More package chunks were found than the %d declared in the header.",
-            dtohl(header.header.packageCount));
-        return (mError=BAD_TYPE);
       }
+      final int csize = dtohl(chunk.size);
+      final int ctype = dtohs(chunk.type);
+      if (ctype == RES_STRING_POOL_TYPE) {
+        if (header.values.getError() != NO_ERROR) {
+          // Only use the first string chunk; ignore any others that
+          // may appear.
+          err = header.values.setTo(chunk.myBuf(), chunk.myOffset(), csize, false);
+          if (err != NO_ERROR) {
+            return (mError = err);
+          }
+        } else {
+          ALOGW("Multiple string chunks found in resource table.");
+        }
+      } else if (ctype == RES_TABLE_PACKAGE_TYPE) {
+        if (curPackage >= dtohl(header.header.packageCount)) {
+          ALOGW(
+              "More package chunks were found than the %d declared in the header.",
+              dtohl(header.header.packageCount));
+          return (mError = BAD_TYPE);
+        }
 
-      if (parsePackage(
-          new ResTable_package(chunk.myBuf(), chunk.myOffset()), header, appAsLib, isSystemAsset) != NO_ERROR) {
-        return mError;
-      }
-      curPackage++;
-    } else {
+        if (parsePackage(
+                new ResTable_package(chunk.myBuf(), chunk.myOffset()),
+                header,
+                appAsLib,
+                isSystemAsset)
+            != NO_ERROR) {
+          return mError;
+        }
+        curPackage++;
+      } else {
         ALOGW(
             "Unknown chunk type 0x%x in table at 0x%x.\n",
             ctype, chunk.myOffset() - header.header.myOffset());
+      }
+      chunk =
+          chunk.myOffset() + csize < header.dataEnd
+              ? new ResChunk_header(chunk.myBuf(), chunk.myOffset() + csize)
+              : null;
     }
-    chunk = chunk.myOffset() + csize < header.dataEnd
-        ? new ResChunk_header(chunk.myBuf(), chunk.myOffset() + csize)
-        : null;
-  }
 
     if (curPackage < dtohl(header.header.packageCount)) {
-      ALOGW("Fewer package chunks (%d) were found than the %d declared in the header.",
-          (int)curPackage, dtohl(header.header.packageCount));
-      return (mError=BAD_TYPE);
+      ALOGW(
+          "Fewer package chunks (%d) were found than the %d declared in the header.",
+          (int) curPackage, dtohl(header.header.packageCount));
+      return (mError = BAD_TYPE);
     }
     mError = header.values.getError();
     if (mError != NO_ERROR) {
@@ -367,9 +408,13 @@ public class ResTable {
     return mError;
   }
 
-  public final int getResource(int resID, Ref<Res_value> outValue, boolean mayBeBag, int density,
-      final Ref<Integer> outSpecFlags, Ref<ResTable_config> outConfig)
-  {
+  public final int getResource(
+      int resID,
+      Ref<Res_value> outValue,
+      boolean mayBeBag,
+      int density,
+      final Ref<Integer> outSpecFlags,
+      Ref<ResTable_config> outConfig) {
     if (mError != NO_ERROR) {
       return mError;
     }
@@ -377,7 +422,7 @@ public class ResTable {
     final int t = Res_GETTYPE(resID);
     final int e = Res_GETENTRY(resID);
     if (p < 0) {
-      if (Res_GETPACKAGE(resID)+1 == 0) {
+      if (Res_GETPACKAGE(resID) + 1 == 0) {
         ALOGW("No package identifier when getting value for resource number 0x%08x", resID);
       } else {
         ALOGW("No known package when getting value for resource number 0x%08x", resID);
@@ -414,14 +459,14 @@ public class ResTable {
       return BAD_VALUE;
     }
 
-//    const Res_value* value = reinterpret_cast<const Res_value*>(
-//      reinterpret_cast<const uint8_t*>(entry.entry) + entry.entry->size);
+    //    const Res_value* value = reinterpret_cast<const Res_value*>(
+    //      reinterpret_cast<const uint8_t*>(entry.entry) + entry.entry->size);
     Res_value value = new Res_value(entry.entry.myBuf(), entry.entry.myOffset() + entry.entry.size);
 
-//    outValue.size = dtohs(value.size);
-//    outValue.res0 = value.res0;
-//    outValue.dataType = value.dataType;
-//    outValue.data = dtohl(value.data);
+    //    outValue.size = dtohs(value.size);
+    //    outValue.res0 = value.res0;
+    //    outValue.dataType = value.dataType;
+    //    outValue.data = dtohl(value.data);
     outValue.set(value);
 
     // The reference may be pointing to a resource in a shared library. These
@@ -433,57 +478,64 @@ public class ResTable {
       return BAD_VALUE;
     }
 
-//    if (kDebugTableNoisy) {
-//      size_t len;
-//      printf("Found value: pkg=0x%x, type=%d, str=%s, int=%d\n",
-//          entry.package.header.index,
-//          outValue.dataType,
-//          outValue.dataType == Res_value::TYPE_STRING ?
-//              String8(entry.package.header.values.stringAt(outValue.data, &len)).string() :
-//      "",
-//          outValue.data);
-//    }
+    //    if (kDebugTableNoisy) {
+    //      size_t len;
+    //      printf("Found value: pkg=0x%x, type=%d, str=%s, int=%d\n",
+    //          entry.package.header.index,
+    //          outValue.dataType,
+    //          outValue.dataType == Res_value::TYPE_STRING ?
+    //              String8(entry.package.header.values.stringAt(outValue.data, &len)).string() :
+    //      "",
+    //          outValue.data);
+    //    }
 
     if (outSpecFlags != null) {
-        outSpecFlags.set(entry.specFlags);
+      outSpecFlags.set(entry.specFlags);
     }
     if (outConfig != null) {
-        outConfig.set(entry.config);
+      outConfig.set(entry.config);
     }
     return entry._package_.header.index;
   }
 
-  public final int resolveReference(Ref<Res_value> value, int blockIndex,
-      final Ref<Integer> outLastRef) {
+  public final int resolveReference(
+      Ref<Res_value> value, int blockIndex, final Ref<Integer> outLastRef) {
     return resolveReference(value, blockIndex, outLastRef, null, null);
   }
 
-  public final int resolveReference(Ref<Res_value> value, int blockIndex,
-      final Ref<Integer> outLastRef, Ref<Integer> inoutTypeSpecFlags) {
+  public final int resolveReference(
+      Ref<Res_value> value,
+      int blockIndex,
+      final Ref<Integer> outLastRef,
+      Ref<Integer> inoutTypeSpecFlags) {
     return resolveReference(value, blockIndex, outLastRef, inoutTypeSpecFlags, null);
   }
 
-  public final int resolveReference(Ref<Res_value> value, int blockIndex,
-      final Ref<Integer> outLastRef, Ref<Integer> inoutTypeSpecFlags,
-      final Ref<ResTable_config> outConfig)
-  {
-    int count=0;
-    while (blockIndex >= 0 && value.get().dataType == DataType.REFERENCE.code()
-        && value.get().data != 0 && count < 20) {
+  public final int resolveReference(
+      Ref<Res_value> value,
+      int blockIndex,
+      final Ref<Integer> outLastRef,
+      Ref<Integer> inoutTypeSpecFlags,
+      final Ref<ResTable_config> outConfig) {
+    int count = 0;
+    while (blockIndex >= 0
+        && value.get().dataType == DataType.REFERENCE.code()
+        && value.get().data != 0
+        && count < 20) {
       if (outLastRef != null) {
         outLastRef.set(value.get().data);
       }
       final Ref<Integer> newFlags = new Ref<>(0);
-      final int newIndex = getResource(value.get().data, value, true, 0,
-          newFlags, outConfig);
+      final int newIndex = getResource(value.get().data, value, true, 0, newFlags, outConfig);
       if (newIndex == BAD_INDEX) {
         return BAD_INDEX;
       }
       if (kDebugTableTheme) {
-        ALOGI("Resolving reference 0x%x: newIndex=%d, type=0x%x, data=0x%x\n",
-            value.get().data, (int)newIndex, (int)value.get().dataType, value.get().data);
+        ALOGI(
+            "Resolving reference 0x%x: newIndex=%d, type=0x%x, data=0x%x\n",
+            value.get().data, (int) newIndex, (int) value.get().dataType, value.get().data);
       }
-      //printf("Getting reference 0x%08x: newIndex=%d\n", value.data, newIndex);
+      // printf("Getting reference 0x%08x: newIndex=%d\n", value.data, newIndex);
       if (inoutTypeSpecFlags != null) {
         inoutTypeSpecFlags.set(inoutTypeSpecFlags.get() | newFlags.get());
       }
@@ -503,9 +555,11 @@ public class ResTable {
     boolean compare(ResTable_sparseTypeEntry a, ResTable_sparseTypeEntry b);
   }
 
-  ResTable_sparseTypeEntry lower_bound(ResTable_sparseTypeEntry first, ResTable_sparseTypeEntry last,
-                                       ResTable_sparseTypeEntry value,
-                                       Compare comparator) {
+  ResTable_sparseTypeEntry lower_bound(
+      ResTable_sparseTypeEntry first,
+      ResTable_sparseTypeEntry last,
+      ResTable_sparseTypeEntry value,
+      Compare comparator) {
     int count = (last.myOffset() - first.myOffset()) / ResTable_sparseTypeEntry.SIZEOF;
     int itOffset;
     int step;
@@ -523,13 +577,14 @@ public class ResTable {
     return first;
   }
 
-
   private int getEntry(
-      final PackageGroup packageGroup, int typeIndex, int entryIndex,
+      final PackageGroup packageGroup,
+      int typeIndex,
+      int entryIndex,
       final ResTable_config config,
-      Entry outEntry)
-  {
-    final List<Type> typeList = getOrDefault(packageGroup.types, typeIndex, Collections.emptyList());
+      Entry outEntry) {
+    final List<Type> typeList =
+        getOrDefault(packageGroup.types, typeIndex, Collections.emptyList());
     if (typeList.isEmpty()) {
       ALOGV("Skipping entry type index 0x%02x because type is NULL!\n", typeIndex);
       return BAD_TYPE;
@@ -541,7 +596,7 @@ public class ResTable {
     int specFlags = 0;
     byte actualTypeIndex = (byte) typeIndex;
     ResTable_config bestConfig = null;
-//    memset(&bestConfig, 0, sizeof(bestConfig));
+    //    memset(&bestConfig, 0, sizeof(bestConfig));
 
     // Iterate over the Types of each package.
     final int typeCount = typeList.size();
@@ -569,9 +624,11 @@ public class ResTable {
       // Particular types (ResTable_type) may be encoded with sparse entries, and so their
       // entryCount do not need to match.
       if (((int) realEntryIndex) >= typeSpec.entryCount) {
-        ALOGW("For resource 0x%08x, entry index(%d) is beyond type entryCount(%d)",
+        ALOGW(
+            "For resource 0x%08x, entry index(%d) is beyond type entryCount(%d)",
             Res_MAKEID(packageGroup.id - 1, typeIndex, entryIndex),
-            entryIndex, ((int) typeSpec.entryCount));
+            entryIndex,
+            ((int) typeSpec.entryCount));
         // We should normally abort here, but some legacy apps declare
         // resources in the 'android' package (old bug in AAPT).
         continue;
@@ -586,26 +643,26 @@ public class ResTable {
 
       List<ResTable_type> candidateConfigs = typeSpec.configs;
 
-//      List<ResTable_type> filteredConfigs;
-//      if (isTruthy(config) && Objects.equals(mParams, config)) {
-//        // Grab the lock first so we can safely get the current filtered list.
-//        synchronized (mFilteredConfigLock) {
-//          // This configuration is equal to the one we have previously cached for,
-//          // so use the filtered configs.
-//
-//          final TypeCacheEntry cacheEntry = packageGroup.typeCacheEntries.get(typeIndex);
-//          if (i < cacheEntry.filteredConfigs.size()) {
-//            if (isTruthy(cacheEntry.filteredConfigs.get(i))) {
-//              // Grab a reference to the shared_ptr so it doesn't get destroyed while
-//              // going through this list.
-//              filteredConfigs = cacheEntry.filteredConfigs.get(i);
-//
-//              // Use this filtered list.
-//              candidateConfigs = filteredConfigs;
-//            }
-//          }
-//        }
-//      }
+      //      List<ResTable_type> filteredConfigs;
+      //      if (isTruthy(config) && Objects.equals(mParams, config)) {
+      //        // Grab the lock first so we can safely get the current filtered list.
+      //        synchronized (mFilteredConfigLock) {
+      //          // This configuration is equal to the one we have previously cached for,
+      //          // so use the filtered configs.
+      //
+      //          final TypeCacheEntry cacheEntry = packageGroup.typeCacheEntries.get(typeIndex);
+      //          if (i < cacheEntry.filteredConfigs.size()) {
+      //            if (isTruthy(cacheEntry.filteredConfigs.get(i))) {
+      //              // Grab a reference to the shared_ptr so it doesn't get destroyed while
+      //              // going through this list.
+      //              filteredConfigs = cacheEntry.filteredConfigs.get(i);
+      //
+      //              // Use this filtered list.
+      //              candidateConfigs = filteredConfigs;
+      //            }
+      //          }
+      //        }
+      //      }
 
       final int numConfigs = candidateConfigs.size();
       for (int c = 0; c < numConfigs; c++) {
@@ -615,7 +672,7 @@ public class ResTable {
         }
 
         final ResTable_config thisConfig;
-//        thisConfig.copyFromDtoH(thisType.config);
+        //        thisConfig.copyFromDtoH(thisType.config);
         thisConfig = ResTable_config.fromDtoH(thisType.config);
 
         // Check to make sure this one is valid for the current parameters.
@@ -658,7 +715,7 @@ public class ResTable {
             // Entry does not exist.
             continue;
           }
-//          thisOffset = dtohl(eindex[realEntryIndex]);
+          //          thisOffset = dtohl(eindex[realEntryIndex]);
           thisOffset = thisType.entryOffset(realEntryIndex);
         }
 
@@ -697,9 +754,10 @@ public class ResTable {
 
     bestOffset += dtohl(bestType.entriesStart);
 
-//    if (bestOffset > (dtohl(bestType->header.size)-sizeof(ResTable_entry))) {
-    if (bestOffset > (dtohl(bestType.header.size)- ResTable_entry.SIZEOF)) {
-      ALOGW("ResTable_entry at 0x%x is beyond type chunk data 0x%x",
+    //    if (bestOffset > (dtohl(bestType->header.size)-sizeof(ResTable_entry))) {
+    if (bestOffset > (dtohl(bestType.header.size) - ResTable_entry.SIZEOF)) {
+      ALOGW(
+          "ResTable_entry at 0x%x is beyond type chunk data 0x%x",
           bestOffset, dtohl(bestType.header.size));
       return BAD_TYPE;
     }
@@ -708,10 +766,10 @@ public class ResTable {
       return BAD_TYPE;
     }
 
-//    const ResTable_entry* const entry = reinterpret_cast<const ResTable_entry*>(
-//      reinterpret_cast<const uint8_t*>(bestType) + bestOffset);
-    final ResTable_entry entry = new ResTable_entry(bestType.myBuf(),
-        bestType.myOffset() + bestOffset);
+    //    const ResTable_entry* const entry = reinterpret_cast<const ResTable_entry*>(
+    //      reinterpret_cast<const uint8_t*>(bestType) + bestOffset);
+    final ResTable_entry entry =
+        new ResTable_entry(bestType.myBuf(), bestType.myOffset() + bestOffset);
     int entrySize = entry.isCompact() ? ResTable_entry.SIZEOF : dtohs(entry.size);
     if (entrySize < ResTable_entry.SIZEOF) {
       ALOGW("ResTable_entry size 0x%x is too small", dtohs(entry.size));
@@ -724,63 +782,71 @@ public class ResTable {
       outEntry.type = bestType;
       outEntry.specFlags = specFlags;
       outEntry._package_ = bestPackage;
-      outEntry.typeStr = new StringPoolRef(bestPackage.typeStrings, actualTypeIndex - bestPackage.typeIdOffset);
+      outEntry.typeStr =
+          new StringPoolRef(bestPackage.typeStrings, actualTypeIndex - bestPackage.typeIdOffset);
       outEntry.keyStr = new StringPoolRef(bestPackage.keyStrings, dtohl(entry.getKeyIndex()));
     }
     return NO_ERROR;
   }
 
-  int parsePackage(ResTable_package pkg,
-                                Header header, boolean appAsLib, boolean isSystemAsset)
-  {
+  int parsePackage(ResTable_package pkg, Header header, boolean appAsLib, boolean isSystemAsset) {
     int base = pkg.myOffset();
-    int err = validate_chunk(pkg.header, ResTable_package.SIZEOF - 4 /*sizeof(pkg.typeIdOffset)*/,
-      header.dataEnd, "ResTable_package");
+    int err =
+        validate_chunk(
+            pkg.header,
+            ResTable_package.SIZEOF - 4 /*sizeof(pkg.typeIdOffset)*/,
+            header.dataEnd,
+            "ResTable_package");
     if (err != NO_ERROR) {
-      return (mError=err);
+      return (mError = err);
     }
 
     final int pkgSize = dtohl(pkg.header.size);
 
     if (dtohl(pkg.typeStrings) >= pkgSize) {
-      ALOGW("ResTable_package type strings at 0x%x are past chunk size 0x%x.",
+      ALOGW(
+          "ResTable_package type strings at 0x%x are past chunk size 0x%x.",
           dtohl(pkg.typeStrings), pkgSize);
-      return (mError=BAD_TYPE);
+      return (mError = BAD_TYPE);
     }
-    if ((dtohl(pkg.typeStrings)&0x3) != 0) {
-      ALOGW("ResTable_package type strings at 0x%x is not on an integer boundary.",
+    if ((dtohl(pkg.typeStrings) & 0x3) != 0) {
+      ALOGW(
+          "ResTable_package type strings at 0x%x is not on an integer boundary.",
           dtohl(pkg.typeStrings));
-      return (mError=BAD_TYPE);
+      return (mError = BAD_TYPE);
     }
     if (dtohl(pkg.keyStrings) >= pkgSize) {
-      ALOGW("ResTable_package key strings at 0x%x are past chunk size 0x%x.",
+      ALOGW(
+          "ResTable_package key strings at 0x%x are past chunk size 0x%x.",
           dtohl(pkg.keyStrings), pkgSize);
-      return (mError=BAD_TYPE);
+      return (mError = BAD_TYPE);
     }
-    if ((dtohl(pkg.keyStrings)&0x3) != 0) {
-      ALOGW("ResTable_package key strings at 0x%x is not on an integer boundary.",
+    if ((dtohl(pkg.keyStrings) & 0x3) != 0) {
+      ALOGW(
+          "ResTable_package key strings at 0x%x is not on an integer boundary.",
           dtohl(pkg.keyStrings));
-      return (mError=BAD_TYPE);
+      return (mError = BAD_TYPE);
     }
 
     int id = dtohl(pkg.id);
     final Map<Byte, IdmapEntries> idmapEntries = new HashMap<>();
 
     if (header.resourceIDMap != NULL) {
-//      byte targetPackageId = 0;
-//      int err = parseIdmap(header.resourceIDMap, header.resourceIDMapSize, &targetPackageId, &idmapEntries);
-//      if (err != NO_ERROR) {
-//        ALOGW("Overlay is broken");
-//        return (mError=err);
-//      }
-//      id = targetPackageId;
+      //      byte targetPackageId = 0;
+      //      int err = parseIdmap(header.resourceIDMap, header.resourceIDMapSize, &targetPackageId,
+      // &idmapEntries);
+      //      if (err != NO_ERROR) {
+      //        ALOGW("Overlay is broken");
+      //        return (mError=err);
+      //      }
+      //      id = targetPackageId;
     }
 
     boolean isDynamic = false;
     if (id >= 256) {
-//      LOG_ALWAYS_FATAL("Package id out of range");
+      //      LOG_ALWAYS_FATAL("Package id out of range");
       throw new IllegalStateException("Package id out of range");
-//      return NO_ERROR;
+      //      return NO_ERROR;
     } else if (id == 0 || (id == 0x7f && appAsLib) || isSystemAsset) {
       // This is a library or a system asset, so assign an ID
       id = mNextPackageId++;
@@ -790,70 +856,77 @@ public class ResTable {
     PackageGroup group = null;
     ResTablePackage _package = new ResTablePackage(this, header, pkg);
     if (_package == NULL) {
-    return (mError=NO_MEMORY);
-  }
-
-//    err = package->typeStrings.setTo(base+dtohl(pkg->typeStrings),
-//      header->dataEnd-(base+dtohl(pkg->typeStrings)));
-    err = _package.typeStrings.setTo(pkg.myBuf(), base+dtohl(pkg.typeStrings),
-      header.dataEnd -(base+dtohl(pkg.typeStrings)), false);
-    if (err != NO_ERROR) {
-//      delete group;
-//      delete _package;
-      return (mError=err);
+      return (mError = NO_MEMORY);
     }
 
-//    err = package->keyStrings.setTo(base+dtohl(pkg->keyStrings),
-//      header->dataEnd-(base+dtohl(pkg->keyStrings)));
-    err = _package.keyStrings.setTo(pkg.myBuf(), base+dtohl(pkg.keyStrings),
-      header.dataEnd -(base+dtohl(pkg.keyStrings)), false);
+    //    err = package->typeStrings.setTo(base+dtohl(pkg->typeStrings),
+    //      header->dataEnd-(base+dtohl(pkg->typeStrings)));
+    err =
+        _package.typeStrings.setTo(
+            pkg.myBuf(),
+            base + dtohl(pkg.typeStrings),
+            header.dataEnd - (base + dtohl(pkg.typeStrings)),
+            false);
+    if (err != NO_ERROR) {
+      //      delete group;
+      //      delete _package;
+      return (mError = err);
+    }
+
+    //    err = package->keyStrings.setTo(base+dtohl(pkg->keyStrings),
+    //      header->dataEnd-(base+dtohl(pkg->keyStrings)));
+    err =
+        _package.keyStrings.setTo(
+            pkg.myBuf(),
+            base + dtohl(pkg.keyStrings),
+            header.dataEnd - (base + dtohl(pkg.keyStrings)),
+            false);
     if (err != NO_ERROR) {
-//      delete group;
-//      delete _package;
-      return (mError=err);
+      //      delete group;
+      //      delete _package;
+      return (mError = err);
     }
 
     int idx = mPackageMap[id];
     if (idx == 0) {
       idx = mPackageGroups.size() + 1;
 
-//      char[] tmpName = new char[pkg.name.length /*sizeof(pkg.name)/sizeof(pkg.name[0])*/];
-//      strcpy16_dtoh(tmpName, pkg.name, sizeof(pkg.name)/sizeof(pkg.name[0]));
+      //      char[] tmpName = new char[pkg.name.length /*sizeof(pkg.name)/sizeof(pkg.name[0])*/];
+      //      strcpy16_dtoh(tmpName, pkg.name, sizeof(pkg.name)/sizeof(pkg.name[0]));
       group = new PackageGroup(this, new String(pkg.name), id, appAsLib, isSystemAsset, isDynamic);
       if (group == NULL) {
-//        delete _package;
-        return (mError=NO_MEMORY);
+        //        delete _package;
+        return (mError = NO_MEMORY);
       }
 
       mPackageGroups.put(group.id, group);
-//      if (err < NO_ERROR) {
-//        return (mError=err);
-//      }
+      //      if (err < NO_ERROR) {
+      //        return (mError=err);
+      //      }
 
       mPackageMap[id] = (byte) idx;
 
       // Find all packages that reference this package
-//      int N = mPackageGroups.size();
-//      for (int i = 0; i < N; i++) {
+      //      int N = mPackageGroups.size();
+      //      for (int i = 0; i < N; i++) {
       for (PackageGroup packageGroup : mPackageGroups.values()) {
-        packageGroup.dynamicRefTable.addMapping(
-            group.name, (byte) group.id);
+        packageGroup.dynamicRefTable.addMapping(group.name, (byte) group.id);
       }
     } else {
       group = mPackageGroups.get(idx - 1);
       if (group == NULL) {
-        return (mError=UNKNOWN_ERROR);
+        return (mError = UNKNOWN_ERROR);
       }
     }
 
     group.packages.add(_package);
-//    if (err < NO_ERROR) {
-//      return (mError=err);
-//    }
+    //    if (err < NO_ERROR) {
+    //      return (mError=err);
+    //    }
 
     // Iterate through all chunks.
     ResChunk_header chunk =
-      new ResChunk_header(pkg.myBuf(), pkg.myOffset() + dtohs(pkg.header.headerSize));
+        new ResChunk_header(pkg.myBuf(), pkg.myOffset() + dtohs(pkg.header.headerSize));
     //      const uint8_t* endPos = ((const uint8_t*)pkg) + dtohs(pkg->header.size);
     final int endPos = pkg.myOffset() + pkg.header.size;
     //    while (((const uint8_t*)chunk) <= (endPos-sizeof(ResChunk_header)) &&
@@ -861,198 +934,211 @@ public class ResTable {
     while (chunk != null
         && chunk.myOffset() <= (endPos - ResChunk_header.SIZEOF)
         && chunk.myOffset() <= (endPos - dtohl(chunk.size))) {
-    if (kDebugTableNoisy) {
+      if (kDebugTableNoisy) {
         ALOGV(
             "PackageChunk: type=0x%x, headerSize=0x%x, size=0x%x, pos=%s\n",
             dtohs(chunk.type),
             dtohs(chunk.headerSize),
             dtohl(chunk.size),
             (chunk.myOffset() - header.header.myOffset()));
-    }
-        final int csize = dtohl(chunk.size);
-        final short ctype = dtohs(chunk.type);
-    if (ctype == RES_TABLE_TYPE_SPEC_TYPE) {
-            final ResTable_typeSpec typeSpec = new ResTable_typeSpec(chunk.myBuf(), chunk.myOffset());
-      err = validate_chunk(typeSpec.header, ResTable_typeSpec.SIZEOF,
-      endPos, "ResTable_typeSpec");
-      if (err != NO_ERROR) {
-        return (mError=err);
       }
+      final int csize = dtohl(chunk.size);
+      final short ctype = dtohs(chunk.type);
+      if (ctype == RES_TABLE_TYPE_SPEC_TYPE) {
+        final ResTable_typeSpec typeSpec = new ResTable_typeSpec(chunk.myBuf(), chunk.myOffset());
+        err =
+            validate_chunk(typeSpec.header, ResTable_typeSpec.SIZEOF, endPos, "ResTable_typeSpec");
+        if (err != NO_ERROR) {
+          return (mError = err);
+        }
 
-            final int typeSpecSize = dtohl(typeSpec.header.size);
-            final int newEntryCount = dtohl(typeSpec.entryCount);
-
-      if (kDebugLoadTableNoisy) {
-        ALOGI("TypeSpec off %s: type=0x%x, headerSize=0x%x, size=%s\n",
-            (base-chunk.myOffset()),
-        dtohs(typeSpec.header.type),
-            dtohs(typeSpec.header.headerSize),
-            typeSpecSize);
-      }
-      // look for block overrun or int overflow when multiplying by 4
-      if ((dtohl(typeSpec.entryCount) > (Integer.MAX_VALUE/4 /*sizeof(int)*/)
-          || dtohs(typeSpec.header.headerSize)+(4 /*sizeof(int)*/*newEntryCount)
-          > typeSpecSize)) {
-        ALOGW("ResTable_typeSpec entry index to %s extends beyond chunk end %s.",
-            (dtohs(typeSpec.header.headerSize) + (4 /*sizeof(int)*/*newEntryCount)),
-            typeSpecSize);
-        return (mError=BAD_TYPE);
-      }
+        final int typeSpecSize = dtohl(typeSpec.header.size);
+        final int newEntryCount = dtohl(typeSpec.entryCount);
 
-      if (typeSpec.id == 0) {
-        ALOGW("ResTable_type has an id of 0.");
-        return (mError=BAD_TYPE);
-      }
+        if (kDebugLoadTableNoisy) {
+          ALOGI(
+              "TypeSpec off %s: type=0x%x, headerSize=0x%x, size=%s\n",
+              (base - chunk.myOffset()),
+              dtohs(typeSpec.header.type),
+              dtohs(typeSpec.header.headerSize),
+              typeSpecSize);
+        }
+        // look for block overrun or int overflow when multiplying by 4
+        if ((dtohl(typeSpec.entryCount) > (Integer.MAX_VALUE / 4 /*sizeof(int)*/)
+            || dtohs(typeSpec.header.headerSize) + (4 /*sizeof(int)*/ * newEntryCount)
+                > typeSpecSize)) {
+          ALOGW(
+              "ResTable_typeSpec entry index to %s extends beyond chunk end %s.",
+              (dtohs(typeSpec.header.headerSize) + (4 /*sizeof(int)*/ * newEntryCount)),
+              typeSpecSize);
+          return (mError = BAD_TYPE);
+        }
 
-      if (newEntryCount > 0) {
-        boolean addToType = true;
-        byte typeIndex = (byte) (typeSpec.id - 1);
-        IdmapEntries idmapEntry = idmapEntries.get(typeSpec.id);
-        if (idmapEntry != null) {
-          typeIndex = (byte) (idmapEntry.targetTypeId() - 1);
-        } else if (header.resourceIDMap != NULL) {
-          // This is an overlay, but the types in this overlay are not
-          // overlaying anything according to the idmap. We can skip these
-          // as they will otherwise conflict with the other resources in the package
-          // without a mapping.
-          addToType = false;
+        if (typeSpec.id == 0) {
+          ALOGW("ResTable_type has an id of 0.");
+          return (mError = BAD_TYPE);
         }
 
-        if (addToType) {
-          List<Type> typeList = computeIfAbsent(group.types, (int) typeIndex, k -> new ArrayList<>());
-          if (!typeList.isEmpty()) {
-            final Type existingType = typeList.get(0);
-            if (existingType.entryCount != newEntryCount && idmapEntry == null) {
-              ALOGW("ResTable_typeSpec entry count inconsistent: given %d, previously %d",
-                  (int) newEntryCount, (int) existingType.entryCount);
-              // We should normally abort here, but some legacy apps declare
-              // resources in the 'android' package (old bug in AAPT).
-            }
+        if (newEntryCount > 0) {
+          boolean addToType = true;
+          byte typeIndex = (byte) (typeSpec.id - 1);
+          IdmapEntries idmapEntry = idmapEntries.get(typeSpec.id);
+          if (idmapEntry != null) {
+            typeIndex = (byte) (idmapEntry.targetTypeId() - 1);
+          } else if (header.resourceIDMap != NULL) {
+            // This is an overlay, but the types in this overlay are not
+            // overlaying anything according to the idmap. We can skip these
+            // as they will otherwise conflict with the other resources in the package
+            // without a mapping.
+            addToType = false;
           }
 
-          Type t = new Type(header, _package, newEntryCount);
-          t.typeSpec = typeSpec;
-          t.typeSpecFlags = typeSpec.getSpecFlags();
-          if (idmapEntry != null) {
-            t.idmapEntries = idmapEntry;
+          if (addToType) {
+            List<Type> typeList =
+                computeIfAbsent(group.types, (int) typeIndex, k -> new ArrayList<>());
+            if (!typeList.isEmpty()) {
+              final Type existingType = typeList.get(0);
+              if (existingType.entryCount != newEntryCount && idmapEntry == null) {
+                ALOGW(
+                    "ResTable_typeSpec entry count inconsistent: given %d, previously %d",
+                    (int) newEntryCount, (int) existingType.entryCount);
+                // We should normally abort here, but some legacy apps declare
+                // resources in the 'android' package (old bug in AAPT).
+              }
+            }
+
+            Type t = new Type(header, _package, newEntryCount);
+            t.typeSpec = typeSpec;
+            t.typeSpecFlags = typeSpec.getSpecFlags();
+            if (idmapEntry != null) {
+              t.idmapEntries = idmapEntry;
+            }
+            typeList.add(t);
+            group.largestTypeId = max(group.largestTypeId, typeSpec.id);
           }
-          typeList.add(t);
-          group.largestTypeId = max(group.largestTypeId, typeSpec.id);
+        } else {
+          ALOGV("Skipping empty ResTable_typeSpec for type %d", typeSpec.id);
         }
-      } else {
-        ALOGV("Skipping empty ResTable_typeSpec for type %d", typeSpec.id);
-      }
 
-    } else if (ctype == RES_TABLE_TYPE_TYPE) {
-            ResTable_type type = new ResTable_type(chunk.myBuf(), chunk.myOffset());
-      err = validate_chunk(type.header, ResTable_type.SIZEOF_WITHOUT_CONFIG/*-sizeof(ResTable_config)*/+4,
-          endPos, "ResTable_type");
-      if (err != NO_ERROR) {
-        return (mError=err);
-      }
-
-            final int typeSize = dtohl(type.header.size);
-            final int newEntryCount = dtohl(type.entryCount);
+      } else if (ctype == RES_TABLE_TYPE_TYPE) {
+        ResTable_type type = new ResTable_type(chunk.myBuf(), chunk.myOffset());
+        err =
+            validate_chunk(
+                type.header,
+                ResTable_type.SIZEOF_WITHOUT_CONFIG /*-sizeof(ResTable_config)*/ + 4,
+                endPos,
+                "ResTable_type");
+        if (err != NO_ERROR) {
+          return (mError = err);
+        }
 
-      if (kDebugLoadTableNoisy) {
-        System.out.println(String.format("Type off 0x%x: type=0x%x, headerSize=0x%x, size=%d\n",
-            base-chunk.myOffset(),
-        dtohs(type.header.type),
-            dtohs(type.header.headerSize),
-            typeSize));
-      }
+        final int typeSize = dtohl(type.header.size);
+        final int newEntryCount = dtohl(type.entryCount);
+
+        if (kDebugLoadTableNoisy) {
+          System.out.println(
+              String.format(
+                  "Type off 0x%x: type=0x%x, headerSize=0x%x, size=%d\n",
+                  base - chunk.myOffset(),
+                  dtohs(type.header.type),
+                  dtohs(type.header.headerSize),
+                  typeSize));
+        }
         // Check if the table uses compact encoding.
         int bytesPerEntry = isTruthy(type.flags & ResTable_type.FLAG_OFFSET16) ? 2 : 4;
         if (dtohs(type.header.headerSize) + (bytesPerEntry * newEntryCount) > typeSize) {
           ALOGW(
               "ResTable_type entry index to %s extends beyond chunk end 0x%x.",
               (dtohs(type.header.headerSize) + (bytesPerEntry * newEntryCount)), typeSize);
-        return (mError=BAD_TYPE);
-      }
-
-      if (newEntryCount != 0
-          && dtohl(type.entriesStart) > (typeSize- ResTable_entry.SIZEOF)) {
-        ALOGW("ResTable_type entriesStart at 0x%x extends beyond chunk end 0x%x.",
-            dtohl(type.entriesStart), typeSize);
-        return (mError=BAD_TYPE);
-      }
+          return (mError = BAD_TYPE);
+        }
 
-      if (type.id == 0) {
-        ALOGW("ResTable_type has an id of 0.");
-        return (mError=BAD_TYPE);
-      }
+        if (newEntryCount != 0 && dtohl(type.entriesStart) > (typeSize - ResTable_entry.SIZEOF)) {
+          ALOGW(
+              "ResTable_type entriesStart at 0x%x extends beyond chunk end 0x%x.",
+              dtohl(type.entriesStart), typeSize);
+          return (mError = BAD_TYPE);
+        }
 
-      if (newEntryCount > 0) {
-        boolean addToType = true;
-        byte typeIndex = (byte) (type.id - 1);
-        IdmapEntries idmapEntry = idmapEntries.get(type.id);
-        if (idmapEntry != null) {
-          typeIndex = (byte) (idmapEntry.targetTypeId() - 1);
-        } else if (header.resourceIDMap != NULL) {
-          // This is an overlay, but the types in this overlay are not
-          // overlaying anything according to the idmap. We can skip these
-          // as they will otherwise conflict with the other resources in the package
-          // without a mapping.
-          addToType = false;
+        if (type.id == 0) {
+          ALOGW("ResTable_type has an id of 0.");
+          return (mError = BAD_TYPE);
         }
 
-        if (addToType) {
-          List<Type> typeList = getOrDefault(group.types, (int) typeIndex, Collections.emptyList());
-          if (typeList.isEmpty()) {
-            ALOGE("No TypeSpec for type %d", type.id);
-            return (mError = BAD_TYPE);
+        if (newEntryCount > 0) {
+          boolean addToType = true;
+          byte typeIndex = (byte) (type.id - 1);
+          IdmapEntries idmapEntry = idmapEntries.get(type.id);
+          if (idmapEntry != null) {
+            typeIndex = (byte) (idmapEntry.targetTypeId() - 1);
+          } else if (header.resourceIDMap != NULL) {
+            // This is an overlay, but the types in this overlay are not
+            // overlaying anything according to the idmap. We can skip these
+            // as they will otherwise conflict with the other resources in the package
+            // without a mapping.
+            addToType = false;
           }
 
+          if (addToType) {
+            List<Type> typeList =
+                getOrDefault(group.types, (int) typeIndex, Collections.emptyList());
+            if (typeList.isEmpty()) {
+              ALOGE("No TypeSpec for type %d", type.id);
+              return (mError = BAD_TYPE);
+            }
+
             Type t = typeList.get(typeList.size() - 1);
-          if (t._package_ != _package) {
-            ALOGE("No TypeSpec for type %d", type.id);
-            return (mError = BAD_TYPE);
-          }
+            if (t._package_ != _package) {
+              ALOGE("No TypeSpec for type %d", type.id);
+              return (mError = BAD_TYPE);
+            }
 
-          t.configs.add(type);
+            t.configs.add(type);
 
-          if (kDebugTableGetEntry) {
-            ResTable_config thisConfig = ResTable_config.fromDtoH(type.config);
-            ALOGI("Adding config to type %d: %s\n", type.id,
-                thisConfig.toString());
+            if (kDebugTableGetEntry) {
+              ResTable_config thisConfig = ResTable_config.fromDtoH(type.config);
+              ALOGI("Adding config to type %d: %s\n", type.id, thisConfig.toString());
+            }
           }
+        } else {
+          ALOGV("Skipping empty ResTable_type for type %d", type.id);
         }
-      } else {
-        ALOGV("Skipping empty ResTable_type for type %d", type.id);
-      }
 
-    } else if (ctype == RES_TABLE_LIBRARY_TYPE) {
-      if (group.dynamicRefTable.entries().isEmpty()) {
-        throw new UnsupportedOperationException("libraries not supported yet");
-//       const ResTable_lib_header* lib = (const ResTable_lib_header*) chunk;
-//       status_t err = validate_chunk(&lib->header, sizeof(*lib),
-//       endPos, "ResTable_lib_header");
-//       if (err != NO_ERROR) {
-//         return (mError=err);
-//       }
-//
-//       err = group->dynamicRefTable.load(lib);
-//       if (err != NO_ERROR) {
-//          return (mError=err);
-//        }
-//
-//        // Fill in the reference table with the entries we already know about.
-//        size_t N = mPackageGroups.size();
-//        for (size_t i = 0; i < N; i++) {
-//          group.dynamicRefTable.addMapping(mPackageGroups[i].name, mPackageGroups[i].id);
-//        }
+      } else if (ctype == RES_TABLE_LIBRARY_TYPE) {
+        if (group.dynamicRefTable.entries().isEmpty()) {
+          throw new UnsupportedOperationException("libraries not supported yet");
+          //       const ResTable_lib_header* lib = (const ResTable_lib_header*) chunk;
+          //       status_t err = validate_chunk(&lib->header, sizeof(*lib),
+          //       endPos, "ResTable_lib_header");
+          //       if (err != NO_ERROR) {
+          //         return (mError=err);
+          //       }
+          //
+          //       err = group->dynamicRefTable.load(lib);
+          //       if (err != NO_ERROR) {
+          //          return (mError=err);
+          //        }
+          //
+          //        // Fill in the reference table with the entries we already know about.
+          //        size_t N = mPackageGroups.size();
+          //        for (size_t i = 0; i < N; i++) {
+          //          group.dynamicRefTable.addMapping(mPackageGroups[i].name,
+          // mPackageGroups[i].id);
+          //        }
+        } else {
+          ALOGW("Found multiple library tables, ignoring...");
+        }
       } else {
-        ALOGW("Found multiple library tables, ignoring...");
-      }
-    } else {
-      err = validate_chunk(chunk, ResChunk_header.SIZEOF,
-          endPos, "ResTable_package:unknown");
-      if (err != NO_ERROR) {
-        return (mError=err);
+        err = validate_chunk(chunk, ResChunk_header.SIZEOF, endPos, "ResTable_package:unknown");
+        if (err != NO_ERROR) {
+          return (mError = err);
+        }
       }
+      chunk =
+          chunk.myOffset() + csize < endPos
+              ? new ResChunk_header(chunk.myBuf(), chunk.myOffset() + csize)
+              : null;
     }
-      chunk = chunk.myOffset() + csize < endPos ? new ResChunk_header(chunk.myBuf(), chunk.myOffset() + csize) : null;
-  }
 
     return NO_ERROR;
   }
@@ -1061,10 +1147,9 @@ public class ResTable {
     return mHeaders.get(index).cookie;
   }
 
-  void setParameters(ResTable_config params)
-  {
-//    AutoMutex _lock(mLock);
-//    AutoMutex _lock2(mFilteredConfigLock);
+  void setParameters(ResTable_config params) {
+    //    AutoMutex _lock(mLock);
+    //    AutoMutex _lock2(mFilteredConfigLock);
     synchronized (mLock) {
       synchronized (mFilteredConfigLock) {
         if (kDebugTableGetEntry) {
@@ -1079,25 +1164,25 @@ public class ResTable {
 
           // Find which configurations match the set of parameters. This allows for a much
           // faster lookup in getEntry() if the set of values is narrowed down.
-          //for (int t = 0; t < packageGroup.types.size(); t++) {
-            //if (packageGroup.types.get(t).isEmpty()) {
-            //   continue;
-            // }
-            //
-            // List<Type> typeList = packageGroup.types.get(t);
-        for (List<Type> typeList : packageGroup.types.values()) {
-          if (typeList.isEmpty()) {
-               continue;
+          // for (int t = 0; t < packageGroup.types.size(); t++) {
+          // if (packageGroup.types.get(t).isEmpty()) {
+          //   continue;
+          // }
+          //
+          // List<Type> typeList = packageGroup.types.get(t);
+          for (List<Type> typeList : packageGroup.types.values()) {
+            if (typeList.isEmpty()) {
+              continue;
             }
 
-          // Retrieve the cache entry for this type.
-            //TypeCacheEntry cacheEntry = packageGroup.typeCacheEntries.editItemAt(t);
+            // Retrieve the cache entry for this type.
+            // TypeCacheEntry cacheEntry = packageGroup.typeCacheEntries.editItemAt(t);
 
             for (int ts = 0; ts < typeList.size(); ts++) {
               Type type = typeList.get(ts);
 
-//              std::shared_ptr<Vector<const ResTable_type*>> newFilteredConfigs =
-//                  std::make_shared<Vector<const ResTable_type*>>();
+              //              std::shared_ptr<Vector<const ResTable_type*>> newFilteredConfigs =
+              //                  std::make_shared<Vector<const ResTable_type*>>();
               List<ResTable_type> newFilteredConfigs = new ArrayList<>();
 
               for (int ti = 0; ti < type.configs.size(); ti++) {
@@ -1109,12 +1194,13 @@ public class ResTable {
               }
 
               if (kDebugTableNoisy) {
-                ALOGD("Updating pkg=0x%x type=0x%x with 0x%x filtered configs",
+                ALOGD(
+                    "Updating pkg=0x%x type=0x%x with 0x%x filtered configs",
                     packageGroup.id, ts, newFilteredConfigs.size());
               }
 
               // todo: implement cache
-//              cacheEntry.filteredConfigs.add(newFilteredConfigs);
+              //              cacheEntry.filteredConfigs.add(newFilteredConfigs);
             }
           }
         }
@@ -1122,20 +1208,20 @@ public class ResTable {
     }
   }
 
-  ResTable_config getParameters()
-  {
-//    mLock.lock();
+  ResTable_config getParameters() {
+    //    mLock.lock();
     synchronized (mLock) {
       return mParams;
     }
-//    mLock.unlock();
+    //    mLock.unlock();
   }
 
   private static final Map<String, Integer> sInternalNameToIdMap = new HashMap<>();
+
   static {
     sInternalNameToIdMap.put("^type", ResTable_map.ATTR_TYPE);
     sInternalNameToIdMap.put("^l10n", ResTable_map.ATTR_L10N);
-    sInternalNameToIdMap.put("^min" , ResTable_map.ATTR_MIN);
+    sInternalNameToIdMap.put("^min", ResTable_map.ATTR_MIN);
     sInternalNameToIdMap.put("^max", ResTable_map.ATTR_MAX);
     sInternalNameToIdMap.put("^other", ResTable_map.ATTR_OTHER);
     sInternalNameToIdMap.put("^zero", ResTable_map.ATTR_ZERO);
@@ -1145,17 +1231,19 @@ public class ResTable {
     sInternalNameToIdMap.put("^many", ResTable_map.ATTR_MANY);
   }
 
+  // TODO(BC): remove. This is deprecated and only used for SDKs < M, and is broken
+  // for android V
   public int identifierForName(String name, String type, String packageName) {
     return identifierForName(name, type, packageName, null);
   }
 
-  public int identifierForName(String nameString, String type, String packageName,
-      final Ref<Integer> outTypeSpecFlags) {
-//    if (kDebugTableSuperNoisy) {
-//      printf("Identifier for name: error=%d\n", mError);
-//    }
-//    // Check for internal resource identifier as the very first thing, so
-//    // that we will always find them even when there are no resources.
+  public int identifierForName(
+      String nameString, String type, String packageName, final Ref<Integer> outTypeSpecFlags) {
+    //    if (kDebugTableSuperNoisy) {
+    //      printf("Identifier for name: error=%d\n", mError);
+    //    }
+    //    // Check for internal resource identifier as the very first thing, so
+    //    // that we will always find them even when there are no resources.
     if (nameString.startsWith("^")) {
       if (sInternalNameToIdMap.containsKey(nameString)) {
         if (outTypeSpecFlags != null) {
@@ -1167,14 +1255,13 @@ public class ResTable {
         if (nameString.substring(1, 6).equals("index_")) {
           int index = Integer.getInteger(nameString.substring(7));
           if (Res_CHECKID(index)) {
-            ALOGW("Array resource index: %d is too large.",
-                index);
+            ALOGW("Array resource index: %d is too large.", index);
             return 0;
           }
           if (outTypeSpecFlags != null) {
             outTypeSpecFlags.set(ResTable_typeSpec.SPEC_PUBLIC);
           }
-          return  Res_MAKEARRAY(index);
+          return Res_MAKEARRAY(index);
         }
 
       return 0;
@@ -1184,10 +1271,9 @@ public class ResTable {
       return 0;
     }
 
-
     // Figure out the package and type we are looking in...
     // TODO(BC): The following code block was a best effort attempt to directly transliterate
-    // C++ code which uses pointer artihmetic. Consider replacing with simpler logic
+    // C++ code which uses pointer arithmetic. Consider replacing with simpler logic
 
     boolean fakePublic = false;
     char[] name = nameString.toCharArray();
@@ -1207,20 +1293,20 @@ public class ResTable {
       if (name[nameIndex] == '*') {
         fakePublic = true;
         nameIndex++;
+      }
     }
-  }
     if (nameIndex >= nameEnd) {
       return 0;
     }
     if (packageEnd != -1) {
-        packageName = nameString.substring(nameIndex, packageEnd);
-        nameIndex = packageEnd+1;
+      packageName = nameString.substring(nameIndex, packageEnd);
+      nameIndex = packageEnd + 1;
     } else if (packageName == null) {
       return 0;
     }
     if (typeEnd != -1) {
       type = nameString.substring(nameIndex, typeEnd);
-      nameIndex = typeEnd+1;
+      nameIndex = typeEnd + 1;
     } else if (type == null) {
       return 0;
     }
@@ -1229,19 +1315,19 @@ public class ResTable {
     }
     nameString = nameString.substring(nameIndex, nameEnd);
 
-//    nameLen = nameEnd-name;
-//    if (kDebugTableNoisy) {
-//      printf("Looking for identifier: type=%s, name=%s, package=%s\n",
-//          String8(type, typeLen).string(),
-//          String8(name, nameLen).string(),
-//          String8(package, packageLen).string());
-//    }
+    //    nameLen = nameEnd-name;
+    //    if (kDebugTableNoisy) {
+    //      printf("Looking for identifier: type=%s, name=%s, package=%s\n",
+    //          String8(type, typeLen).string(),
+    //          String8(name, nameLen).string(),
+    //          String8(package, packageLen).string());
+    //    }
     final String attr = "attr";
     final String attrPrivate = "^attr-private";
     for (PackageGroup group : mPackageGroups.values()) {
       if (!Objects.equals(packageName.trim(), group.name.trim())) {
         if (kDebugTableNoisy) {
-           System.out.println(String.format("Skipping package group: %s\n", group.name));
+          System.out.println(String.format("Skipping package group: %s\n", group.name));
         }
         continue;
       }
@@ -1257,13 +1343,11 @@ public class ResTable {
           int identifier = findEntry(group, ti, nameString, outTypeSpecFlags);
           if (identifier != 0) {
             if (fakePublic && outTypeSpecFlags != null) {
-                        outTypeSpecFlags.set(outTypeSpecFlags.get() | ResTable_typeSpec.SPEC_PUBLIC);
+              outTypeSpecFlags.set(outTypeSpecFlags.get() | ResTable_typeSpec.SPEC_PUBLIC);
             }
             return identifier;
           }
-        } while (attr.compareTo(targetType) == 0
-            && ((targetType = attrPrivate) != null)
-            );
+        } while (attr.compareTo(targetType) == 0 && ((targetType = attrPrivate) != null));
       }
       break;
     }
@@ -1313,1092 +1397,1100 @@ public class ResTable {
     return 0;
   }
 
-//bool ResTable::expandResourceRef(const char16_t* refStr, size_t refLen,
-//                                 String16* outPackage,
-//                                 String16* outType,
-//                                 String16* outName,
-//                                 const String16* defType,
-//                                 const String16* defPackage,
-//                                 const char** outErrorMsg,
-//                                 bool* outPublicOnly)
-//{
-//    const char16_t* packageEnd = NULL;
-//    const char16_t* typeEnd = NULL;
-//    const char16_t* p = refStr;
-//    const char16_t* const end = p + refLen;
-//    while (p < end) {
-//        if (*p == ':') packageEnd = p;
-//        else if (*p == '/') {
-//            typeEnd = p;
-//            break;
-//        }
-//        p++;
-//    }
-//    p = refStr;
-//    if (*p == '@') p++;
-//
-//    if (outPublicOnly != NULL) {
-//        *outPublicOnly = true;
-//    }
-//    if (*p == '*') {
-//        p++;
-//        if (outPublicOnly != NULL) {
-//            *outPublicOnly = false;
-//        }
-//    }
-//
-//    if (packageEnd) {
-//        *outPackage = String16(p, packageEnd-p);
-//        p = packageEnd+1;
-//    } else {
-//        if (!defPackage) {
-//            if (outErrorMsg) {
-//                *outErrorMsg = "No resource package specified";
-//            }
-//            return false;
-//        }
-//        *outPackage = *defPackage;
-//    }
-//    if (typeEnd) {
-//        *outType = String16(p, typeEnd-p);
-//        p = typeEnd+1;
-//    } else {
-//        if (!defType) {
-//            if (outErrorMsg) {
-//                *outErrorMsg = "No resource type specified";
-//            }
-//            return false;
-//        }
-//        *outType = *defType;
-//    }
-//    *outName = String16(p, end-p);
-//    if(**outPackage == 0) {
-//        if(outErrorMsg) {
-//            *outErrorMsg = "Resource package cannot be an empty string";
-//        }
-//        return false;
-//    }
-//    if(**outType == 0) {
-//        if(outErrorMsg) {
-//            *outErrorMsg = "Resource type cannot be an empty string";
-//        }
-//        return false;
-//    }
-//    if(**outName == 0) {
-//        if(outErrorMsg) {
-//            *outErrorMsg = "Resource id cannot be an empty string";
-//        }
-//        return false;
-//    }
-//    return true;
-//}
-//
-//static uint32_t get_hex(char c, bool* outError)
-//{
-//    if (c >= '0' && c <= '9') {
-//        return c - '0';
-//    } else if (c >= 'a' && c <= 'f') {
-//        return c - 'a' + 0xa;
-//    } else if (c >= 'A' && c <= 'F') {
-//        return c - 'A' + 0xa;
-//    }
-//    *outError = true;
-//    return 0;
-//}
-//
-//struct unit_entry
-//{
-//    const char* name;
-//    size_t len;
-//    uint8_t type;
-//    uint32_t unit;
-//    float scale;
-//};
-//
-//static const unit_entry unitNames[] = {
-//    { "px", strlen("px"), Res_value::TYPE_DIMENSION, Res_value::COMPLEX_UNIT_PX, 1.0f },
-//    { "dip", strlen("dip"), Res_value::TYPE_DIMENSION, Res_value::COMPLEX_UNIT_DIP, 1.0f },
-//    { "dp", strlen("dp"), Res_value::TYPE_DIMENSION, Res_value::COMPLEX_UNIT_DIP, 1.0f },
-//    { "sp", strlen("sp"), Res_value::TYPE_DIMENSION, Res_value::COMPLEX_UNIT_SP, 1.0f },
-//    { "pt", strlen("pt"), Res_value::TYPE_DIMENSION, Res_value::COMPLEX_UNIT_PT, 1.0f },
-//    { "in", strlen("in"), Res_value::TYPE_DIMENSION, Res_value::COMPLEX_UNIT_IN, 1.0f },
-//    { "mm", strlen("mm"), Res_value::TYPE_DIMENSION, Res_value::COMPLEX_UNIT_MM, 1.0f },
-//    { "%", strlen("%"), Res_value::TYPE_FRACTION, Res_value::COMPLEX_UNIT_FRACTION, 1.0f/100 },
-//    { "%s", strlen("%s"), Res_value::TYPE_FRACTION, Res_value::COMPLEX_UNIT_FRACTION_PARENT, 1.0f/100 },
-//    { NULL, 0, 0, 0, 0 }
-//};
-//
-//static bool parse_unit(const char* str, Res_value* outValue,
-//                       float* outScale, const char** outEnd)
-//{
-//    const char* end = str;
-//    while (*end != 0 && !isspace((unsigned char)*end)) {
-//        end++;
-//    }
-//    const size_t len = end-str;
-//
-//    const char* realEnd = end;
-//    while (*realEnd != 0 && isspace((unsigned char)*realEnd)) {
-//        realEnd++;
-//    }
-//    if (*realEnd != 0) {
-//        return false;
-//    }
-//
-//    const unit_entry* cur = unitNames;
-//    while (cur->name) {
-//        if (len == cur->len && strncmp(cur->name, str, len) == 0) {
-//            outValue->dataType = cur->type;
-//            outValue->data = cur->unit << Res_value::COMPLEX_UNIT_SHIFT;
-//            *outScale = cur->scale;
-//            *outEnd = end;
-//            //printf("Found unit %s for %s\n", cur->name, str);
-//            return true;
-//        }
-//        cur++;
-//    }
-//
-//    return false;
-//}
-//
-//bool U16StringToInt(const char16_t* s, size_t len, Res_value* outValue)
-//{
-//    while (len > 0 && isspace16(*s)) {
-//        s++;
-//        len--;
-//    }
-//
-//    if (len <= 0) {
-//        return false;
-//    }
-//
-//    size_t i = 0;
-//    int64_t val = 0;
-//    bool neg = false;
-//
-//    if (*s == '-') {
-//        neg = true;
-//        i++;
-//    }
-//
-//    if (s[i] < '0' || s[i] > '9') {
-//        return false;
-//    }
-//
-//    static_assert(std::is_same<uint32_t, Res_value::data_type>::value,
-//                  "Res_value::data_type has changed. The range checks in this "
-//                  "function are no longer correct.");
-//
-//    // Decimal or hex?
-//    bool isHex;
-//    if (len > 1 && s[i] == '0' && s[i+1] == 'x') {
-//        isHex = true;
-//        i += 2;
-//
-//        if (neg) {
-//            return false;
-//        }
-//
-//        if (i == len) {
-//            // Just u"0x"
-//            return false;
-//        }
-//
-//        bool error = false;
-//        while (i < len && !error) {
-//            val = (val*16) + get_hex(s[i], &error);
-//            i++;
-//
-//            if (val > std::numeric_limits<uint32_t>::max()) {
-//                return false;
-//            }
-//        }
-//        if (error) {
-//            return false;
-//        }
-//    } else {
-//        isHex = false;
-//        while (i < len) {
-//            if (s[i] < '0' || s[i] > '9') {
-//                return false;
-//            }
-//            val = (val*10) + s[i]-'0';
-//            i++;
-//
-//            if ((neg && -val < std::numeric_limits<int32_t>::min()) ||
-//                (!neg && val > std::numeric_limits<int32_t>::max())) {
-//                return false;
-//            }
-//        }
-//    }
-//
-//    if (neg) val = -val;
-//
-//    while (i < len && isspace16(s[i])) {
-//        i++;
-//    }
-//
-//    if (i != len) {
-//        return false;
-//    }
-//
-//    if (outValue) {
-//        outValue->dataType =
-//            isHex ? outValue->TYPE_INT_HEX : outValue->TYPE_INT_DEC;
-//        outValue->data = static_cast<Res_value::data_type>(val);
-//    }
-//    return true;
-//}
-//
-//bool ResTable::stringToInt(const char16_t* s, size_t len, Res_value* outValue)
-//{
-//    return U16StringToInt(s, len, outValue);
-//}
-//
-//bool ResTable::stringToFloat(const char16_t* s, size_t len, Res_value* outValue)
-//{
-//    while (len > 0 && isspace16(*s)) {
-//        s++;
-//        len--;
-//    }
-//
-//    if (len <= 0) {
-//        return false;
-//    }
-//
-//    char buf[128];
-//    int i=0;
-//    while (len > 0 && *s != 0 && i < 126) {
-//        if (*s > 255) {
-//            return false;
-//        }
-//        buf[i++] = *s++;
-//        len--;
-//    }
-//
-//    if (len > 0) {
-//        return false;
-//    }
-//    if ((buf[0] < '0' || buf[0] > '9') && buf[0] != '.' && buf[0] != '-' && buf[0] != '+') {
-//        return false;
-//    }
-//
-//    buf[i] = 0;
-//    const char* end;
-//    float f = strtof(buf, (char**)&end);
-//
-//    if (*end != 0 && !isspace((unsigned char)*end)) {
-//        // Might be a unit...
-//        float scale;
-//        if (parse_unit(end, outValue, &scale, &end)) {
-//            f *= scale;
-//            const bool neg = f < 0;
-//            if (neg) f = -f;
-//            uint64_t bits = (uint64_t)(f*(1<<23)+.5f);
-//            uint32_t radix;
-//            uint32_t shift;
-//            if ((bits&0x7fffff) == 0) {
-//                // Always use 23p0 if there is no fraction, just to make
-//                // things easier to read.
-//                radix = Res_value::COMPLEX_RADIX_23p0;
-//                shift = 23;
-//            } else if ((bits&0xffffffffff800000LL) == 0) {
-//                // Magnitude is zero -- can fit in 0 bits of precision.
-//                radix = Res_value::COMPLEX_RADIX_0p23;
-//                shift = 0;
-//            } else if ((bits&0xffffffff80000000LL) == 0) {
-//                // Magnitude can fit in 8 bits of precision.
-//                radix = Res_value::COMPLEX_RADIX_8p15;
-//                shift = 8;
-//            } else if ((bits&0xffffff8000000000LL) == 0) {
-//                // Magnitude can fit in 16 bits of precision.
-//                radix = Res_value::COMPLEX_RADIX_16p7;
-//                shift = 16;
-//            } else {
-//                // Magnitude needs entire range, so no fractional part.
-//                radix = Res_value::COMPLEX_RADIX_23p0;
-//                shift = 23;
-//            }
-//            int32_t mantissa = (int32_t)(
-//                (bits>>shift) & Res_value::COMPLEX_MANTISSA_MASK);
-//            if (neg) {
-//                mantissa = (-mantissa) & Res_value::COMPLEX_MANTISSA_MASK;
-//            }
-//            outValue->data |=
-//                (radix<<Res_value::COMPLEX_RADIX_SHIFT)
-//                | (mantissa<<Res_value::COMPLEX_MANTISSA_SHIFT);
-//            //printf("Input value: %f 0x%016Lx, mult: %f, radix: %d, shift: %d, final: 0x%08x\n",
-//            //       f * (neg ? -1 : 1), bits, f*(1<<23),
-//            //       radix, shift, outValue->data);
-//            return true;
-//        }
-//        return false;
-//    }
-//
-//    while (*end != 0 && isspace((unsigned char)*end)) {
-//        end++;
-//    }
-//
-//    if (*end == 0) {
-//        if (outValue) {
-//            outValue->dataType = outValue->TYPE_FLOAT;
-//            *(float*)(&outValue->data) = f;
-//            return true;
-//        }
-//    }
-//
-//    return false;
-//}
-//
-//bool ResTable::stringToValue(Res_value* outValue, String16* outString,
-//                             const char16_t* s, size_t len,
-//                             bool preserveSpaces, bool coerceType,
-//                             uint32_t attrID,
-//                             const String16* defType,
-//                             const String16* defPackage,
-//                             Accessor* accessor,
-//                             void* accessorCookie,
-//                             uint32_t attrType,
-//                             bool enforcePrivate) const
-//{
-//    bool localizationSetting = accessor != NULL && accessor->getLocalizationSetting();
-//    const char* errorMsg = NULL;
-//
-//    outValue->size = sizeof(Res_value);
-//    outValue->res0 = 0;
-//
-//    // First strip leading/trailing whitespace.  Do this before handling
-//    // escapes, so they can be used to force whitespace into the string.
-//    if (!preserveSpaces) {
-//        while (len > 0 && isspace16(*s)) {
-//            s++;
-//            len--;
-//        }
-//        while (len > 0 && isspace16(s[len-1])) {
-//            len--;
-//        }
-//        // If the string ends with '\', then we keep the space after it.
-//        if (len > 0 && s[len-1] == '\\' && s[len] != 0) {
-//            len++;
-//        }
-//    }
-//
-//    //printf("Value for: %s\n", String8(s, len).string());
-//
-//    uint32_t l10nReq = ResTable_map::L10N_NOT_REQUIRED;
-//    uint32_t attrMin = 0x80000000, attrMax = 0x7fffffff;
-//    bool fromAccessor = false;
-//    if (attrID != 0 && !Res_INTERNALID(attrID)) {
-//        const ssize_t p = getResourcePackageIndex(attrID);
-//        const bag_entry* bag;
-//        ssize_t cnt = p >= 0 ? lockBag(attrID, &bag) : -1;
-//        //printf("For attr 0x%08x got bag of %d\n", attrID, cnt);
-//        if (cnt >= 0) {
-//            while (cnt > 0) {
-//                //printf("Entry 0x%08x = 0x%08x\n", bag->map.name.ident, bag->map.value.data);
-//                switch (bag->map.name.ident) {
-//                case ResTable_map::ATTR_TYPE:
-//                    attrType = bag->map.value.data;
-//                    break;
-//                case ResTable_map::ATTR_MIN:
-//                    attrMin = bag->map.value.data;
-//                    break;
-//                case ResTable_map::ATTR_MAX:
-//                    attrMax = bag->map.value.data;
-//                    break;
-//                case ResTable_map::ATTR_L10N:
-//                    l10nReq = bag->map.value.data;
-//                    break;
-//                }
-//                bag++;
-//                cnt--;
-//            }
-//            unlockBag(bag);
-//        } else if (accessor && accessor->getAttributeType(attrID, &attrType)) {
-//            fromAccessor = true;
-//            if (attrType == ResTable_map::TYPE_ENUM
-//                    || attrType == ResTable_map::TYPE_FLAGS
-//                    || attrType == ResTable_map::TYPE_INTEGER) {
-//                accessor->getAttributeMin(attrID, &attrMin);
-//                accessor->getAttributeMax(attrID, &attrMax);
-//            }
-//            if (localizationSetting) {
-//                l10nReq = accessor->getAttributeL10N(attrID);
-//            }
-//        }
-//    }
-//
-//    const bool canStringCoerce =
-//        coerceType && (attrType&ResTable_map::TYPE_STRING) != 0;
-//
-//    if (*s == '@') {
-//        outValue->dataType = outValue->TYPE_REFERENCE;
-//
-//        // Note: we don't check attrType here because the reference can
-//        // be to any other type; we just need to count on the client making
-//        // sure the referenced type is correct.
-//
-//        //printf("Looking up ref: %s\n", String8(s, len).string());
-//
-//        // It's a reference!
-//        if (len == 5 && s[1]=='n' && s[2]=='u' && s[3]=='l' && s[4]=='l') {
-//            // Special case @null as undefined. This will be converted by
-//            // AssetManager to TYPE_NULL with data DATA_NULL_UNDEFINED.
-//            outValue->data = 0;
-//            return true;
-//        } else if (len == 6 && s[1]=='e' && s[2]=='m' && s[3]=='p' && s[4]=='t' && s[5]=='y') {
-//            // Special case @empty as explicitly defined empty value.
-//            outValue->dataType = Res_value::TYPE_NULL;
-//            outValue->data = Res_value::DATA_NULL_EMPTY;
-//            return true;
-//        } else {
-//            bool createIfNotFound = false;
-//            const char16_t* resourceRefName;
-//            int resourceNameLen;
-//            if (len > 2 && s[1] == '+') {
-//                createIfNotFound = true;
-//                resourceRefName = s + 2;
-//                resourceNameLen = len - 2;
-//            } else if (len > 2 && s[1] == '*') {
-//                enforcePrivate = false;
-//                resourceRefName = s + 2;
-//                resourceNameLen = len - 2;
-//            } else {
-//                createIfNotFound = false;
-//                resourceRefName = s + 1;
-//                resourceNameLen = len - 1;
-//            }
-//            String16 package, type, name;
-//            if (!expandResourceRef(resourceRefName,resourceNameLen, &package, &type, &name,
-//                                   defType, defPackage, &errorMsg)) {
-//                if (accessor != NULL) {
-//                    accessor->reportError(accessorCookie, errorMsg);
-//                }
-//                return false;
-//            }
-//
-//            uint32_t specFlags = 0;
-//            uint32_t rid = identifierForName(name.string(), name.size(), type.string(),
-//                    type.size(), package.string(), package.size(), &specFlags);
-//            if (rid != 0) {
-//                if (enforcePrivate) {
-//                    if (accessor == NULL || accessor->getAssetsPackage() != package) {
-//                        if ((specFlags&ResTable_typeSpec::SPEC_PUBLIC) == 0) {
-//                            if (accessor != NULL) {
-//                                accessor->reportError(accessorCookie, "Resource is not public.");
-//                            }
-//                            return false;
-//                        }
-//                    }
-//                }
-//
-//                if (accessor) {
-//                    rid = Res_MAKEID(
-//                        accessor->getRemappedPackage(Res_GETPACKAGE(rid)),
-//                        Res_GETTYPE(rid), Res_GETENTRY(rid));
-//                    if (kDebugTableNoisy) {
-//                        ALOGI("Incl %s:%s/%s: 0x%08x\n",
-//                                String8(package).string(), String8(type).string(),
-//                                String8(name).string(), rid);
-//                    }
-//                }
-//
-//                uint32_t packageId = Res_GETPACKAGE(rid) + 1;
-//                if (packageId != APP_PACKAGE_ID && packageId != SYS_PACKAGE_ID) {
-//                    outValue->dataType = Res_value::TYPE_DYNAMIC_REFERENCE;
-//                }
-//                outValue->data = rid;
-//                return true;
-//            }
-//
-//            if (accessor) {
-//                uint32_t rid = accessor->getCustomResourceWithCreation(package, type, name,
-//                                                                       createIfNotFound);
-//                if (rid != 0) {
-//                    if (kDebugTableNoisy) {
-//                        ALOGI("Pckg %s:%s/%s: 0x%08x\n",
-//                                String8(package).string(), String8(type).string(),
-//                                String8(name).string(), rid);
-//                    }
-//                    uint32_t packageId = Res_GETPACKAGE(rid) + 1;
-//                    if (packageId == 0x00) {
-//                        outValue->data = rid;
-//                        outValue->dataType = Res_value::TYPE_DYNAMIC_REFERENCE;
-//                        return true;
-//                    } else if (packageId == APP_PACKAGE_ID || packageId == SYS_PACKAGE_ID) {
-//                        // We accept packageId's generated as 0x01 in order to support
-//                        // building the android system resources
-//                        outValue->data = rid;
-//                        return true;
-//                    }
-//                }
-//            }
-//        }
-//
-//        if (accessor != NULL) {
-//            accessor->reportError(accessorCookie, "No resource found that matches the given name");
-//        }
-//        return false;
-//    }
-//
-//    // if we got to here, and localization is required and it's not a reference,
-//    // complain and bail.
-//    if (l10nReq == ResTable_map::L10N_SUGGESTED) {
-//        if (localizationSetting) {
-//            if (accessor != NULL) {
-//                accessor->reportError(accessorCookie, "This attribute must be localized.");
-//            }
-//        }
-//    }
-//
-//    if (*s == '#') {
-//        // It's a color!  Convert to an integer of the form 0xaarrggbb.
-//        uint32_t color = 0;
-//        bool error = false;
-//        if (len == 4) {
-//            outValue->dataType = outValue->TYPE_INT_COLOR_RGB4;
-//            color |= 0xFF000000;
-//            color |= get_hex(s[1], &error) << 20;
-//            color |= get_hex(s[1], &error) << 16;
-//            color |= get_hex(s[2], &error) << 12;
-//            color |= get_hex(s[2], &error) << 8;
-//            color |= get_hex(s[3], &error) << 4;
-//            color |= get_hex(s[3], &error);
-//        } else if (len == 5) {
-//            outValue->dataType = outValue->TYPE_INT_COLOR_ARGB4;
-//            color |= get_hex(s[1], &error) << 28;
-//            color |= get_hex(s[1], &error) << 24;
-//            color |= get_hex(s[2], &error) << 20;
-//            color |= get_hex(s[2], &error) << 16;
-//            color |= get_hex(s[3], &error) << 12;
-//            color |= get_hex(s[3], &error) << 8;
-//            color |= get_hex(s[4], &error) << 4;
-//            color |= get_hex(s[4], &error);
-//        } else if (len == 7) {
-//            outValue->dataType = outValue->TYPE_INT_COLOR_RGB8;
-//            color |= 0xFF000000;
-//            color |= get_hex(s[1], &error) << 20;
-//            color |= get_hex(s[2], &error) << 16;
-//            color |= get_hex(s[3], &error) << 12;
-//            color |= get_hex(s[4], &error) << 8;
-//            color |= get_hex(s[5], &error) << 4;
-//            color |= get_hex(s[6], &error);
-//        } else if (len == 9) {
-//            outValue->dataType = outValue->TYPE_INT_COLOR_ARGB8;
-//            color |= get_hex(s[1], &error) << 28;
-//            color |= get_hex(s[2], &error) << 24;
-//            color |= get_hex(s[3], &error) << 20;
-//            color |= get_hex(s[4], &error) << 16;
-//            color |= get_hex(s[5], &error) << 12;
-//            color |= get_hex(s[6], &error) << 8;
-//            color |= get_hex(s[7], &error) << 4;
-//            color |= get_hex(s[8], &error);
-//        } else {
-//            error = true;
-//        }
-//        if (!error) {
-//            if ((attrType&ResTable_map::TYPE_COLOR) == 0) {
-//                if (!canStringCoerce) {
-//                    if (accessor != NULL) {
-//                        accessor->reportError(accessorCookie,
-//                                "Color types not allowed");
-//                    }
-//                    return false;
-//                }
-//            } else {
-//                outValue->data = color;
-//                //printf("Color input=%s, output=0x%x\n", String8(s, len).string(), color);
-//                return true;
-//            }
-//        } else {
-//            if ((attrType&ResTable_map::TYPE_COLOR) != 0) {
-//                if (accessor != NULL) {
-//                    accessor->reportError(accessorCookie, "Color value not valid --"
-//                            " must be #rgb, #argb, #rrggbb, or #aarrggbb");
-//                }
-//                #if 0
-//                fprintf(stderr, "%s: Color ID %s value %s is not valid\n",
-//                        "Resource File", //(const char*)in->getPrintableSource(),
-//                        String8(*curTag).string(),
-//                        String8(s, len).string());
-//                #endif
-//                return false;
-//            }
-//        }
-//    }
-//
-//    if (*s == '?') {
-//        outValue->dataType = outValue->TYPE_ATTRIBUTE;
-//
-//        // Note: we don't check attrType here because the reference can
-//        // be to any other type; we just need to count on the client making
-//        // sure the referenced type is correct.
-//
-//        //printf("Looking up attr: %s\n", String8(s, len).string());
-//
-//        static const String16 attr16("attr");
-//        String16 package, type, name;
-//        if (!expandResourceRef(s+1, len-1, &package, &type, &name,
-//                               &attr16, defPackage, &errorMsg)) {
-//            if (accessor != NULL) {
-//                accessor->reportError(accessorCookie, errorMsg);
-//            }
-//            return false;
-//        }
-//
-//        //printf("Pkg: %s, Type: %s, Name: %s\n",
-//        //       String8(package).string(), String8(type).string(),
-//        //       String8(name).string());
-//        uint32_t specFlags = 0;
-//        uint32_t rid =
-//            identifierForName(name.string(), name.size(),
-//                              type.string(), type.size(),
-//                              package.string(), package.size(), &specFlags);
-//        if (rid != 0) {
-//            if (enforcePrivate) {
-//                if ((specFlags&ResTable_typeSpec::SPEC_PUBLIC) == 0) {
-//                    if (accessor != NULL) {
-//                        accessor->reportError(accessorCookie, "Attribute is not public.");
-//                    }
-//                    return false;
-//                }
-//            }
-//
-//            if (accessor) {
-//                rid = Res_MAKEID(
-//                    accessor->getRemappedPackage(Res_GETPACKAGE(rid)),
-//                    Res_GETTYPE(rid), Res_GETENTRY(rid));
-//            }
-//
-//            uint32_t packageId = Res_GETPACKAGE(rid) + 1;
-//            if (packageId != APP_PACKAGE_ID && packageId != SYS_PACKAGE_ID) {
-//                outValue->dataType = Res_value::TYPE_DYNAMIC_ATTRIBUTE;
-//            }
-//            outValue->data = rid;
-//            return true;
-//        }
-//
-//        if (accessor) {
-//            uint32_t rid = accessor->getCustomResource(package, type, name);
-//            if (rid != 0) {
-//                uint32_t packageId = Res_GETPACKAGE(rid) + 1;
-//                if (packageId == 0x00) {
-//                    outValue->data = rid;
-//                    outValue->dataType = Res_value::TYPE_DYNAMIC_ATTRIBUTE;
-//                    return true;
-//                } else if (packageId == APP_PACKAGE_ID || packageId == SYS_PACKAGE_ID) {
-//                    // We accept packageId's generated as 0x01 in order to support
-//                    // building the android system resources
-//                    outValue->data = rid;
-//                    return true;
-//                }
-//            }
-//        }
-//
-//        if (accessor != NULL) {
-//            accessor->reportError(accessorCookie, "No resource found that matches the given name");
-//        }
-//        return false;
-//    }
-//
-//    if (stringToInt(s, len, outValue)) {
-//        if ((attrType&ResTable_map::TYPE_INTEGER) == 0) {
-//            // If this type does not allow integers, but does allow floats,
-//            // fall through on this error case because the float type should
-//            // be able to accept any integer value.
-//            if (!canStringCoerce && (attrType&ResTable_map::TYPE_FLOAT) == 0) {
-//                if (accessor != NULL) {
-//                    accessor->reportError(accessorCookie, "Integer types not allowed");
-//                }
-//                return false;
-//            }
-//        } else {
-//            if (((int32_t)outValue->data) < ((int32_t)attrMin)
-//                    || ((int32_t)outValue->data) > ((int32_t)attrMax)) {
-//                if (accessor != NULL) {
-//                    accessor->reportError(accessorCookie, "Integer value out of range");
-//                }
-//                return false;
-//            }
-//            return true;
-//        }
-//    }
-//
-//    if (stringToFloat(s, len, outValue)) {
-//        if (outValue->dataType == Res_value::TYPE_DIMENSION) {
-//            if ((attrType&ResTable_map::TYPE_DIMENSION) != 0) {
-//                return true;
-//            }
-//            if (!canStringCoerce) {
-//                if (accessor != NULL) {
-//                    accessor->reportError(accessorCookie, "Dimension types not allowed");
-//                }
-//                return false;
-//            }
-//        } else if (outValue->dataType == Res_value::TYPE_FRACTION) {
-//            if ((attrType&ResTable_map::TYPE_FRACTION) != 0) {
-//                return true;
-//            }
-//            if (!canStringCoerce) {
-//                if (accessor != NULL) {
-//                    accessor->reportError(accessorCookie, "Fraction types not allowed");
-//                }
-//                return false;
-//            }
-//        } else if ((attrType&ResTable_map::TYPE_FLOAT) == 0) {
-//            if (!canStringCoerce) {
-//                if (accessor != NULL) {
-//                    accessor->reportError(accessorCookie, "Float types not allowed");
-//                }
-//                return false;
-//            }
-//        } else {
-//            return true;
-//        }
-//    }
-//
-//    if (len == 4) {
-//        if ((s[0] == 't' || s[0] == 'T') &&
-//            (s[1] == 'r' || s[1] == 'R') &&
-//            (s[2] == 'u' || s[2] == 'U') &&
-//            (s[3] == 'e' || s[3] == 'E')) {
-//            if ((attrType&ResTable_map::TYPE_BOOLEAN) == 0) {
-//                if (!canStringCoerce) {
-//                    if (accessor != NULL) {
-//                        accessor->reportError(accessorCookie, "Boolean types not allowed");
-//                    }
-//                    return false;
-//                }
-//            } else {
-//                outValue->dataType = outValue->TYPE_INT_BOOLEAN;
-//                outValue->data = (uint32_t)-1;
-//                return true;
-//            }
-//        }
-//    }
-//
-//    if (len == 5) {
-//        if ((s[0] == 'f' || s[0] == 'F') &&
-//            (s[1] == 'a' || s[1] == 'A') &&
-//            (s[2] == 'l' || s[2] == 'L') &&
-//            (s[3] == 's' || s[3] == 'S') &&
-//            (s[4] == 'e' || s[4] == 'E')) {
-//            if ((attrType&ResTable_map::TYPE_BOOLEAN) == 0) {
-//                if (!canStringCoerce) {
-//                    if (accessor != NULL) {
-//                        accessor->reportError(accessorCookie, "Boolean types not allowed");
-//                    }
-//                    return false;
-//                }
-//            } else {
-//                outValue->dataType = outValue->TYPE_INT_BOOLEAN;
-//                outValue->data = 0;
-//                return true;
-//            }
-//        }
-//    }
-//
-//    if ((attrType&ResTable_map::TYPE_ENUM) != 0) {
-//        const ssize_t p = getResourcePackageIndex(attrID);
-//        const bag_entry* bag;
-//        ssize_t cnt = p >= 0 ? lockBag(attrID, &bag) : -1;
-//        //printf("Got %d for enum\n", cnt);
-//        if (cnt >= 0) {
-//            resource_name rname;
-//            while (cnt > 0) {
-//                if (!Res_INTERNALID(bag->map.name.ident)) {
-//                    //printf("Trying attr #%08x\n", bag->map.name.ident);
-//                    if (getResourceName(bag->map.name.ident, false, &rname)) {
-//                        #if 0
-//                        printf("Matching %s against %s (0x%08x)\n",
-//                               String8(s, len).string(),
-//                               String8(rname.name, rname.nameLen).string(),
-//                               bag->map.name.ident);
-//                        #endif
-//                        if (strzcmp16(s, len, rname.name, rname.nameLen) == 0) {
-//                            outValue->dataType = bag->map.value.dataType;
-//                            outValue->data = bag->map.value.data;
-//                            unlockBag(bag);
-//                            return true;
-//                        }
-//                    }
-//
-//                }
-//                bag++;
-//                cnt--;
-//            }
-//            unlockBag(bag);
-//        }
-//
-//        if (fromAccessor) {
-//            if (accessor->getAttributeEnum(attrID, s, len, outValue)) {
-//                return true;
-//            }
-//        }
-//    }
-//
-//    if ((attrType&ResTable_map::TYPE_FLAGS) != 0) {
-//        const ssize_t p = getResourcePackageIndex(attrID);
-//        const bag_entry* bag;
-//        ssize_t cnt = p >= 0 ? lockBag(attrID, &bag) : -1;
-//        //printf("Got %d for flags\n", cnt);
-//        if (cnt >= 0) {
-//            bool failed = false;
-//            resource_name rname;
-//            outValue->dataType = Res_value::TYPE_INT_HEX;
-//            outValue->data = 0;
-//            const char16_t* end = s + len;
-//            const char16_t* pos = s;
-//            while (pos < end && !failed) {
-//                const char16_t* start = pos;
-//                pos++;
-//                while (pos < end && *pos != '|') {
-//                    pos++;
-//                }
-//                //printf("Looking for: %s\n", String8(start, pos-start).string());
-//                const bag_entry* bagi = bag;
-//                ssize_t i;
-//                for (i=0; i<cnt; i++, bagi++) {
-//                    if (!Res_INTERNALID(bagi->map.name.ident)) {
-//                        //printf("Trying attr #%08x\n", bagi->map.name.ident);
-//                        if (getResourceName(bagi->map.name.ident, false, &rname)) {
-//                            #if 0
-//                            printf("Matching %s against %s (0x%08x)\n",
-//                                   String8(start,pos-start).string(),
-//                                   String8(rname.name, rname.nameLen).string(),
-//                                   bagi->map.name.ident);
-//                            #endif
-//                            if (strzcmp16(start, pos-start, rname.name, rname.nameLen) == 0) {
-//                                outValue->data |= bagi->map.value.data;
-//                                break;
-//                            }
-//                        }
-//                    }
-//                }
-//                if (i >= cnt) {
-//                    // Didn't find this flag identifier.
-//                    failed = true;
-//                }
-//                if (pos < end) {
-//                    pos++;
-//                }
-//            }
-//            unlockBag(bag);
-//            if (!failed) {
-//                //printf("Final flag value: 0x%lx\n", outValue->data);
-//                return true;
-//            }
-//        }
-//
-//
-//        if (fromAccessor) {
-//            if (accessor->getAttributeFlags(attrID, s, len, outValue)) {
-//                //printf("Final flag value: 0x%lx\n", outValue->data);
-//                return true;
-//            }
-//        }
-//    }
-//
-//    if ((attrType&ResTable_map::TYPE_STRING) == 0) {
-//        if (accessor != NULL) {
-//            accessor->reportError(accessorCookie, "String types not allowed");
-//        }
-//        return false;
-//    }
-//
-//    // Generic string handling...
-//    outValue->dataType = outValue->TYPE_STRING;
-//    if (outString) {
-//        bool failed = collectString(outString, s, len, preserveSpaces, &errorMsg);
-//        if (accessor != NULL) {
-//            accessor->reportError(accessorCookie, errorMsg);
-//        }
-//        return failed;
-//    }
-//
-//    return true;
-//}
-//
-//bool ResTable::collectString(String16* outString,
-//                             const char16_t* s, size_t len,
-//                             bool preserveSpaces,
-//                             const char** outErrorMsg,
-//                             bool append)
-//{
-//    String16 tmp;
-//
-//    char quoted = 0;
-//    const char16_t* p = s;
-//    while (p < (s+len)) {
-//        while (p < (s+len)) {
-//            const char16_t c = *p;
-//            if (c == '\\') {
-//                break;
-//            }
-//            if (!preserveSpaces) {
-//                if (quoted == 0 && isspace16(c)
-//                    && (c != ' ' || isspace16(*(p+1)))) {
-//                    break;
-//                }
-//                if (c == '"' && (quoted == 0 || quoted == '"')) {
-//                    break;
-//                }
-//                if (c == '\'' && (quoted == 0 || quoted == '\'')) {
-//                    /*
-//                     * In practice, when people write ' instead of \'
-//                     * in a string, they are doing it by accident
-//                     * instead of really meaning to use ' as a quoting
-//                     * character.  Warn them so they don't lose it.
-//                     */
-//                    if (outErrorMsg) {
-//                        *outErrorMsg = "Apostrophe not preceded by \\";
-//                    }
-//                    return false;
-//                }
-//            }
-//            p++;
-//        }
-//        if (p < (s+len)) {
-//            if (p > s) {
-//                tmp.append(String16(s, p-s));
-//            }
-//            if (!preserveSpaces && (*p == '"' || *p == '\'')) {
-//                if (quoted == 0) {
-//                    quoted = *p;
-//                } else {
-//                    quoted = 0;
-//                }
-//                p++;
-//            } else if (!preserveSpaces && isspace16(*p)) {
-//                // Space outside of a quote -- consume all spaces and
-//                // leave a single plain space char.
-//                tmp.append(String16(" "));
-//                p++;
-//                while (p < (s+len) && isspace16(*p)) {
-//                    p++;
-//                }
-//            } else if (*p == '\\') {
-//                p++;
-//                if (p < (s+len)) {
-//                    switch (*p) {
-//                    case 't':
-//                        tmp.append(String16("\t"));
-//                        break;
-//                    case 'n':
-//                        tmp.append(String16("\n"));
-//                        break;
-//                    case '#':
-//                        tmp.append(String16("#"));
-//                        break;
-//                    case '@':
-//                        tmp.append(String16("@"));
-//                        break;
-//                    case '?':
-//                        tmp.append(String16("?"));
-//                        break;
-//                    case '"':
-//                        tmp.append(String16("\""));
-//                        break;
-//                    case '\'':
-//                        tmp.append(String16("'"));
-//                        break;
-//                    case '\\':
-//                        tmp.append(String16("\\"));
-//                        break;
-//                    case 'u':
-//                    {
-//                        char16_t chr = 0;
-//                        int i = 0;
-//                        while (i < 4 && p[1] != 0) {
-//                            p++;
-//                            i++;
-//                            int c;
-//                            if (*p >= '0' && *p <= '9') {
-//                                c = *p - '0';
-//                            } else if (*p >= 'a' && *p <= 'f') {
-//                                c = *p - 'a' + 10;
-//                            } else if (*p >= 'A' && *p <= 'F') {
-//                                c = *p - 'A' + 10;
-//                            } else {
-//                                if (outErrorMsg) {
-//                                    *outErrorMsg = "Bad character in \\u unicode escape sequence";
-//                                }
-//                                return false;
-//                            }
-//                            chr = (chr<<4) | c;
-//                        }
-//                        tmp.append(String16(&chr, 1));
-//                    } break;
-//                    default:
-//                        // ignore unknown escape chars.
-//                        break;
-//                    }
-//                    p++;
-//                }
-//            }
-//            len -= (p-s);
-//            s = p;
-//        }
-//    }
-//
-//    if (tmp.size() != 0) {
-//        if (len > 0) {
-//            tmp.append(String16(s, len));
-//        }
-//        if (append) {
-//            outString->append(tmp);
-//        } else {
-//            outString->setTo(tmp);
-//        }
-//    } else {
-//        if (append) {
-//            outString->append(String16(s, len));
-//        } else {
-//            outString->setTo(s, len);
-//        }
-//    }
-//
-//    return true;
-//}
-
-  public int getBasePackageCount()
-  {
+  // bool ResTable::expandResourceRef(const char16_t* refStr, size_t refLen,
+  //                                 String16* outPackage,
+  //                                 String16* outType,
+  //                                 String16* outName,
+  //                                 const String16* defType,
+  //                                 const String16* defPackage,
+  //                                 const char** outErrorMsg,
+  //                                 bool* outPublicOnly)
+  // {
+  //    const char16_t* packageEnd = NULL;
+  //    const char16_t* typeEnd = NULL;
+  //    const char16_t* p = refStr;
+  //    const char16_t* const end = p + refLen;
+  //    while (p < end) {
+  //        if (*p == ':') packageEnd = p;
+  //        else if (*p == '/') {
+  //            typeEnd = p;
+  //            break;
+  //        }
+  //        p++;
+  //    }
+  //    p = refStr;
+  //    if (*p == '@') p++;
+  //
+  //    if (outPublicOnly != NULL) {
+  //        *outPublicOnly = true;
+  //    }
+  //    if (*p == '*') {
+  //        p++;
+  //        if (outPublicOnly != NULL) {
+  //            *outPublicOnly = false;
+  //        }
+  //    }
+  //
+  //    if (packageEnd) {
+  //        *outPackage = String16(p, packageEnd-p);
+  //        p = packageEnd+1;
+  //    } else {
+  //        if (!defPackage) {
+  //            if (outErrorMsg) {
+  //                *outErrorMsg = "No resource package specified";
+  //            }
+  //            return false;
+  //        }
+  //        *outPackage = *defPackage;
+  //    }
+  //    if (typeEnd) {
+  //        *outType = String16(p, typeEnd-p);
+  //        p = typeEnd+1;
+  //    } else {
+  //        if (!defType) {
+  //            if (outErrorMsg) {
+  //                *outErrorMsg = "No resource type specified";
+  //            }
+  //            return false;
+  //        }
+  //        *outType = *defType;
+  //    }
+  //    *outName = String16(p, end-p);
+  //    if(**outPackage == 0) {
+  //        if(outErrorMsg) {
+  //            *outErrorMsg = "Resource package cannot be an empty string";
+  //        }
+  //        return false;
+  //    }
+  //    if(**outType == 0) {
+  //        if(outErrorMsg) {
+  //            *outErrorMsg = "Resource type cannot be an empty string";
+  //        }
+  //        return false;
+  //    }
+  //    if(**outName == 0) {
+  //        if(outErrorMsg) {
+  //            *outErrorMsg = "Resource id cannot be an empty string";
+  //        }
+  //        return false;
+  //    }
+  //    return true;
+  // }
+  //
+  // static uint32_t get_hex(char c, bool* outError)
+  // {
+  //    if (c >= '0' && c <= '9') {
+  //        return c - '0';
+  //    } else if (c >= 'a' && c <= 'f') {
+  //        return c - 'a' + 0xa;
+  //    } else if (c >= 'A' && c <= 'F') {
+  //        return c - 'A' + 0xa;
+  //    }
+  //    *outError = true;
+  //    return 0;
+  // }
+  //
+  // struct unit_entry
+  // {
+  //    const char* name;
+  //    size_t len;
+  //    uint8_t type;
+  //    uint32_t unit;
+  //    float scale;
+  // };
+  //
+  // static const unit_entry unitNames[] = {
+  //    { "px", strlen("px"), Res_value::TYPE_DIMENSION, Res_value::COMPLEX_UNIT_PX, 1.0f },
+  //    { "dip", strlen("dip"), Res_value::TYPE_DIMENSION, Res_value::COMPLEX_UNIT_DIP, 1.0f },
+  //    { "dp", strlen("dp"), Res_value::TYPE_DIMENSION, Res_value::COMPLEX_UNIT_DIP, 1.0f },
+  //    { "sp", strlen("sp"), Res_value::TYPE_DIMENSION, Res_value::COMPLEX_UNIT_SP, 1.0f },
+  //    { "pt", strlen("pt"), Res_value::TYPE_DIMENSION, Res_value::COMPLEX_UNIT_PT, 1.0f },
+  //    { "in", strlen("in"), Res_value::TYPE_DIMENSION, Res_value::COMPLEX_UNIT_IN, 1.0f },
+  //    { "mm", strlen("mm"), Res_value::TYPE_DIMENSION, Res_value::COMPLEX_UNIT_MM, 1.0f },
+  //    { "%", strlen("%"), Res_value::TYPE_FRACTION, Res_value::COMPLEX_UNIT_FRACTION, 1.0f/100 },
+  //    { "%s", strlen("%s"), Res_value::TYPE_FRACTION, Res_value::COMPLEX_UNIT_FRACTION_PARENT,
+  // 1.0f/100 },
+  //    { NULL, 0, 0, 0, 0 }
+  // };
+  //
+  // static bool parse_unit(const char* str, Res_value* outValue,
+  //                       float* outScale, const char** outEnd)
+  // {
+  //    const char* end = str;
+  //    while (*end != 0 && !isspace((unsigned char)*end)) {
+  //        end++;
+  //    }
+  //    const size_t len = end-str;
+  //
+  //    const char* realEnd = end;
+  //    while (*realEnd != 0 && isspace((unsigned char)*realEnd)) {
+  //        realEnd++;
+  //    }
+  //    if (*realEnd != 0) {
+  //        return false;
+  //    }
+  //
+  //    const unit_entry* cur = unitNames;
+  //    while (cur->name) {
+  //        if (len == cur->len && strncmp(cur->name, str, len) == 0) {
+  //            outValue->dataType = cur->type;
+  //            outValue->data = cur->unit << Res_value::COMPLEX_UNIT_SHIFT;
+  //            *outScale = cur->scale;
+  //            *outEnd = end;
+  //            //printf("Found unit %s for %s\n", cur->name, str);
+  //            return true;
+  //        }
+  //        cur++;
+  //    }
+  //
+  //    return false;
+  // }
+  //
+  // bool U16StringToInt(const char16_t* s, size_t len, Res_value* outValue)
+  // {
+  //    while (len > 0 && isspace16(*s)) {
+  //        s++;
+  //        len--;
+  //    }
+  //
+  //    if (len <= 0) {
+  //        return false;
+  //    }
+  //
+  //    size_t i = 0;
+  //    int64_t val = 0;
+  //    bool neg = false;
+  //
+  //    if (*s == '-') {
+  //        neg = true;
+  //        i++;
+  //    }
+  //
+  //    if (s[i] < '0' || s[i] > '9') {
+  //        return false;
+  //    }
+  //
+  //    static_assert(std::is_same<uint32_t, Res_value::data_type>::value,
+  //                  "Res_value::data_type has changed. The range checks in this "
+  //                  "function are no longer correct.");
+  //
+  //    // Decimal or hex?
+  //    bool isHex;
+  //    if (len > 1 && s[i] == '0' && s[i+1] == 'x') {
+  //        isHex = true;
+  //        i += 2;
+  //
+  //        if (neg) {
+  //            return false;
+  //        }
+  //
+  //        if (i == len) {
+  //            // Just u"0x"
+  //            return false;
+  //        }
+  //
+  //        bool error = false;
+  //        while (i < len && !error) {
+  //            val = (val*16) + get_hex(s[i], &error);
+  //            i++;
+  //
+  //            if (val > std::numeric_limits<uint32_t>::max()) {
+  //                return false;
+  //            }
+  //        }
+  //        if (error) {
+  //            return false;
+  //        }
+  //    } else {
+  //        isHex = false;
+  //        while (i < len) {
+  //            if (s[i] < '0' || s[i] > '9') {
+  //                return false;
+  //            }
+  //            val = (val*10) + s[i]-'0';
+  //            i++;
+  //
+  //            if ((neg && -val < std::numeric_limits<int32_t>::min()) ||
+  //                (!neg && val > std::numeric_limits<int32_t>::max())) {
+  //                return false;
+  //            }
+  //        }
+  //    }
+  //
+  //    if (neg) val = -val;
+  //
+  //    while (i < len && isspace16(s[i])) {
+  //        i++;
+  //    }
+  //
+  //    if (i != len) {
+  //        return false;
+  //    }
+  //
+  //    if (outValue) {
+  //        outValue->dataType =
+  //            isHex ? outValue->TYPE_INT_HEX : outValue->TYPE_INT_DEC;
+  //        outValue->data = static_cast<Res_value::data_type>(val);
+  //    }
+  //    return true;
+  // }
+  //
+  // bool ResTable::stringToInt(const char16_t* s, size_t len, Res_value* outValue)
+  // {
+  //    return U16StringToInt(s, len, outValue);
+  // }
+  //
+  // bool ResTable::stringToFloat(const char16_t* s, size_t len, Res_value* outValue)
+  // {
+  //    while (len > 0 && isspace16(*s)) {
+  //        s++;
+  //        len--;
+  //    }
+  //
+  //    if (len <= 0) {
+  //        return false;
+  //    }
+  //
+  //    char buf[128];
+  //    int i=0;
+  //    while (len > 0 && *s != 0 && i < 126) {
+  //        if (*s > 255) {
+  //            return false;
+  //        }
+  //        buf[i++] = *s++;
+  //        len--;
+  //    }
+  //
+  //    if (len > 0) {
+  //        return false;
+  //    }
+  //    if ((buf[0] < '0' || buf[0] > '9') && buf[0] != '.' && buf[0] != '-' && buf[0] != '+') {
+  //        return false;
+  //    }
+  //
+  //    buf[i] = 0;
+  //    const char* end;
+  //    float f = strtof(buf, (char**)&end);
+  //
+  //    if (*end != 0 && !isspace((unsigned char)*end)) {
+  //        // Might be a unit...
+  //        float scale;
+  //        if (parse_unit(end, outValue, &scale, &end)) {
+  //            f *= scale;
+  //            const bool neg = f < 0;
+  //            if (neg) f = -f;
+  //            uint64_t bits = (uint64_t)(f*(1<<23)+.5f);
+  //            uint32_t radix;
+  //            uint32_t shift;
+  //            if ((bits&0x7fffff) == 0) {
+  //                // Always use 23p0 if there is no fraction, just to make
+  //                // things easier to read.
+  //                radix = Res_value::COMPLEX_RADIX_23p0;
+  //                shift = 23;
+  //            } else if ((bits&0xffffffffff800000LL) == 0) {
+  //                // Magnitude is zero -- can fit in 0 bits of precision.
+  //                radix = Res_value::COMPLEX_RADIX_0p23;
+  //                shift = 0;
+  //            } else if ((bits&0xffffffff80000000LL) == 0) {
+  //                // Magnitude can fit in 8 bits of precision.
+  //                radix = Res_value::COMPLEX_RADIX_8p15;
+  //                shift = 8;
+  //            } else if ((bits&0xffffff8000000000LL) == 0) {
+  //                // Magnitude can fit in 16 bits of precision.
+  //                radix = Res_value::COMPLEX_RADIX_16p7;
+  //                shift = 16;
+  //            } else {
+  //                // Magnitude needs entire range, so no fractional part.
+  //                radix = Res_value::COMPLEX_RADIX_23p0;
+  //                shift = 23;
+  //            }
+  //            int32_t mantissa = (int32_t)(
+  //                (bits>>shift) & Res_value::COMPLEX_MANTISSA_MASK);
+  //            if (neg) {
+  //                mantissa = (-mantissa) & Res_value::COMPLEX_MANTISSA_MASK;
+  //            }
+  //            outValue->data |=
+  //                (radix<<Res_value::COMPLEX_RADIX_SHIFT)
+  //                | (mantissa<<Res_value::COMPLEX_MANTISSA_SHIFT);
+  //            //printf("Input value: %f 0x%016Lx, mult: %f, radix: %d, shift: %d, final:
+  // 0x%08x\n",
+  //            //       f * (neg ? -1 : 1), bits, f*(1<<23),
+  //            //       radix, shift, outValue->data);
+  //            return true;
+  //        }
+  //        return false;
+  //    }
+  //
+  //    while (*end != 0 && isspace((unsigned char)*end)) {
+  //        end++;
+  //    }
+  //
+  //    if (*end == 0) {
+  //        if (outValue) {
+  //            outValue->dataType = outValue->TYPE_FLOAT;
+  //            *(float*)(&outValue->data) = f;
+  //            return true;
+  //        }
+  //    }
+  //
+  //    return false;
+  // }
+  //
+  // bool ResTable::stringToValue(Res_value* outValue, String16* outString,
+  //                             const char16_t* s, size_t len,
+  //                             bool preserveSpaces, bool coerceType,
+  //                             uint32_t attrID,
+  //                             const String16* defType,
+  //                             const String16* defPackage,
+  //                             Accessor* accessor,
+  //                             void* accessorCookie,
+  //                             uint32_t attrType,
+  //                             bool enforcePrivate) const
+  // {
+  //    bool localizationSetting = accessor != NULL && accessor->getLocalizationSetting();
+  //    const char* errorMsg = NULL;
+  //
+  //    outValue->size = sizeof(Res_value);
+  //    outValue->res0 = 0;
+  //
+  //    // First strip leading/trailing whitespace.  Do this before handling
+  //    // escapes, so they can be used to force whitespace into the string.
+  //    if (!preserveSpaces) {
+  //        while (len > 0 && isspace16(*s)) {
+  //            s++;
+  //            len--;
+  //        }
+  //        while (len > 0 && isspace16(s[len-1])) {
+  //            len--;
+  //        }
+  //        // If the string ends with '\', then we keep the space after it.
+  //        if (len > 0 && s[len-1] == '\\' && s[len] != 0) {
+  //            len++;
+  //        }
+  //    }
+  //
+  //    //printf("Value for: %s\n", String8(s, len).string());
+  //
+  //    uint32_t l10nReq = ResTable_map::L10N_NOT_REQUIRED;
+  //    uint32_t attrMin = 0x80000000, attrMax = 0x7fffffff;
+  //    bool fromAccessor = false;
+  //    if (attrID != 0 && !Res_INTERNALID(attrID)) {
+  //        const ssize_t p = getResourcePackageIndex(attrID);
+  //        const bag_entry* bag;
+  //        ssize_t cnt = p >= 0 ? lockBag(attrID, &bag) : -1;
+  //        //printf("For attr 0x%08x got bag of %d\n", attrID, cnt);
+  //        if (cnt >= 0) {
+  //            while (cnt > 0) {
+  //                //printf("Entry 0x%08x = 0x%08x\n", bag->map.name.ident, bag->map.value.data);
+  //                switch (bag->map.name.ident) {
+  //                case ResTable_map::ATTR_TYPE:
+  //                    attrType = bag->map.value.data;
+  //                    break;
+  //                case ResTable_map::ATTR_MIN:
+  //                    attrMin = bag->map.value.data;
+  //                    break;
+  //                case ResTable_map::ATTR_MAX:
+  //                    attrMax = bag->map.value.data;
+  //                    break;
+  //                case ResTable_map::ATTR_L10N:
+  //                    l10nReq = bag->map.value.data;
+  //                    break;
+  //                }
+  //                bag++;
+  //                cnt--;
+  //            }
+  //            unlockBag(bag);
+  //        } else if (accessor && accessor->getAttributeType(attrID, &attrType)) {
+  //            fromAccessor = true;
+  //            if (attrType == ResTable_map::TYPE_ENUM
+  //                    || attrType == ResTable_map::TYPE_FLAGS
+  //                    || attrType == ResTable_map::TYPE_INTEGER) {
+  //                accessor->getAttributeMin(attrID, &attrMin);
+  //                accessor->getAttributeMax(attrID, &attrMax);
+  //            }
+  //            if (localizationSetting) {
+  //                l10nReq = accessor->getAttributeL10N(attrID);
+  //            }
+  //        }
+  //    }
+  //
+  //    const bool canStringCoerce =
+  //        coerceType && (attrType&ResTable_map::TYPE_STRING) != 0;
+  //
+  //    if (*s == '@') {
+  //        outValue->dataType = outValue->TYPE_REFERENCE;
+  //
+  //        // Note: we don't check attrType here because the reference can
+  //        // be to any other type; we just need to count on the client making
+  //        // sure the referenced type is correct.
+  //
+  //        //printf("Looking up ref: %s\n", String8(s, len).string());
+  //
+  //        // It's a reference!
+  //        if (len == 5 && s[1]=='n' && s[2]=='u' && s[3]=='l' && s[4]=='l') {
+  //            // Special case @null as undefined. This will be converted by
+  //            // AssetManager to TYPE_NULL with data DATA_NULL_UNDEFINED.
+  //            outValue->data = 0;
+  //            return true;
+  //        } else if (len == 6 && s[1]=='e' && s[2]=='m' && s[3]=='p' && s[4]=='t' && s[5]=='y') {
+  //            // Special case @empty as explicitly defined empty value.
+  //            outValue->dataType = Res_value::TYPE_NULL;
+  //            outValue->data = Res_value::DATA_NULL_EMPTY;
+  //            return true;
+  //        } else {
+  //            bool createIfNotFound = false;
+  //            const char16_t* resourceRefName;
+  //            int resourceNameLen;
+  //            if (len > 2 && s[1] == '+') {
+  //                createIfNotFound = true;
+  //                resourceRefName = s + 2;
+  //                resourceNameLen = len - 2;
+  //            } else if (len > 2 && s[1] == '*') {
+  //                enforcePrivate = false;
+  //                resourceRefName = s + 2;
+  //                resourceNameLen = len - 2;
+  //            } else {
+  //                createIfNotFound = false;
+  //                resourceRefName = s + 1;
+  //                resourceNameLen = len - 1;
+  //            }
+  //            String16 package, type, name;
+  //            if (!expandResourceRef(resourceRefName,resourceNameLen, &package, &type, &name,
+  //                                   defType, defPackage, &errorMsg)) {
+  //                if (accessor != NULL) {
+  //                    accessor->reportError(accessorCookie, errorMsg);
+  //                }
+  //                return false;
+  //            }
+  //
+  //            uint32_t specFlags = 0;
+  //            uint32_t rid = identifierForName(name.string(), name.size(), type.string(),
+  //                    type.size(), package.string(), package.size(), &specFlags);
+  //            if (rid != 0) {
+  //                if (enforcePrivate) {
+  //                    if (accessor == NULL || accessor->getAssetsPackage() != package) {
+  //                        if ((specFlags&ResTable_typeSpec::SPEC_PUBLIC) == 0) {
+  //                            if (accessor != NULL) {
+  //                                accessor->reportError(accessorCookie, "Resource is not
+  // public.");
+  //                            }
+  //                            return false;
+  //                        }
+  //                    }
+  //                }
+  //
+  //                if (accessor) {
+  //                    rid = Res_MAKEID(
+  //                        accessor->getRemappedPackage(Res_GETPACKAGE(rid)),
+  //                        Res_GETTYPE(rid), Res_GETENTRY(rid));
+  //                    if (kDebugTableNoisy) {
+  //                        ALOGI("Incl %s:%s/%s: 0x%08x\n",
+  //                                String8(package).string(), String8(type).string(),
+  //                                String8(name).string(), rid);
+  //                    }
+  //                }
+  //
+  //                uint32_t packageId = Res_GETPACKAGE(rid) + 1;
+  //                if (packageId != APP_PACKAGE_ID && packageId != SYS_PACKAGE_ID) {
+  //                    outValue->dataType = Res_value::TYPE_DYNAMIC_REFERENCE;
+  //                }
+  //                outValue->data = rid;
+  //                return true;
+  //            }
+  //
+  //            if (accessor) {
+  //                uint32_t rid = accessor->getCustomResourceWithCreation(package, type, name,
+  //                                                                       createIfNotFound);
+  //                if (rid != 0) {
+  //                    if (kDebugTableNoisy) {
+  //                        ALOGI("Pckg %s:%s/%s: 0x%08x\n",
+  //                                String8(package).string(), String8(type).string(),
+  //                                String8(name).string(), rid);
+  //                    }
+  //                    uint32_t packageId = Res_GETPACKAGE(rid) + 1;
+  //                    if (packageId == 0x00) {
+  //                        outValue->data = rid;
+  //                        outValue->dataType = Res_value::TYPE_DYNAMIC_REFERENCE;
+  //                        return true;
+  //                    } else if (packageId == APP_PACKAGE_ID || packageId == SYS_PACKAGE_ID) {
+  //                        // We accept packageId's generated as 0x01 in order to support
+  //                        // building the android system resources
+  //                        outValue->data = rid;
+  //                        return true;
+  //                    }
+  //                }
+  //            }
+  //        }
+  //
+  //        if (accessor != NULL) {
+  //            accessor->reportError(accessorCookie, "No resource found that matches the given
+  // name");
+  //        }
+  //        return false;
+  //    }
+  //
+  //    // if we got to here, and localization is required and it's not a reference,
+  //    // complain and bail.
+  //    if (l10nReq == ResTable_map::L10N_SUGGESTED) {
+  //        if (localizationSetting) {
+  //            if (accessor != NULL) {
+  //                accessor->reportError(accessorCookie, "This attribute must be localized.");
+  //            }
+  //        }
+  //    }
+  //
+  //    if (*s == '#') {
+  //        // It's a color!  Convert to an integer of the form 0xaarrggbb.
+  //        uint32_t color = 0;
+  //        bool error = false;
+  //        if (len == 4) {
+  //            outValue->dataType = outValue->TYPE_INT_COLOR_RGB4;
+  //            color |= 0xFF000000;
+  //            color |= get_hex(s[1], &error) << 20;
+  //            color |= get_hex(s[1], &error) << 16;
+  //            color |= get_hex(s[2], &error) << 12;
+  //            color |= get_hex(s[2], &error) << 8;
+  //            color |= get_hex(s[3], &error) << 4;
+  //            color |= get_hex(s[3], &error);
+  //        } else if (len == 5) {
+  //            outValue->dataType = outValue->TYPE_INT_COLOR_ARGB4;
+  //            color |= get_hex(s[1], &error) << 28;
+  //            color |= get_hex(s[1], &error) << 24;
+  //            color |= get_hex(s[2], &error) << 20;
+  //            color |= get_hex(s[2], &error) << 16;
+  //            color |= get_hex(s[3], &error) << 12;
+  //            color |= get_hex(s[3], &error) << 8;
+  //            color |= get_hex(s[4], &error) << 4;
+  //            color |= get_hex(s[4], &error);
+  //        } else if (len == 7) {
+  //            outValue->dataType = outValue->TYPE_INT_COLOR_RGB8;
+  //            color |= 0xFF000000;
+  //            color |= get_hex(s[1], &error) << 20;
+  //            color |= get_hex(s[2], &error) << 16;
+  //            color |= get_hex(s[3], &error) << 12;
+  //            color |= get_hex(s[4], &error) << 8;
+  //            color |= get_hex(s[5], &error) << 4;
+  //            color |= get_hex(s[6], &error);
+  //        } else if (len == 9) {
+  //            outValue->dataType = outValue->TYPE_INT_COLOR_ARGB8;
+  //            color |= get_hex(s[1], &error) << 28;
+  //            color |= get_hex(s[2], &error) << 24;
+  //            color |= get_hex(s[3], &error) << 20;
+  //            color |= get_hex(s[4], &error) << 16;
+  //            color |= get_hex(s[5], &error) << 12;
+  //            color |= get_hex(s[6], &error) << 8;
+  //            color |= get_hex(s[7], &error) << 4;
+  //            color |= get_hex(s[8], &error);
+  //        } else {
+  //            error = true;
+  //        }
+  //        if (!error) {
+  //            if ((attrType&ResTable_map::TYPE_COLOR) == 0) {
+  //                if (!canStringCoerce) {
+  //                    if (accessor != NULL) {
+  //                        accessor->reportError(accessorCookie,
+  //                                "Color types not allowed");
+  //                    }
+  //                    return false;
+  //                }
+  //            } else {
+  //                outValue->data = color;
+  //                //printf("Color input=%s, output=0x%x\n", String8(s, len).string(), color);
+  //                return true;
+  //            }
+  //        } else {
+  //            if ((attrType&ResTable_map::TYPE_COLOR) != 0) {
+  //                if (accessor != NULL) {
+  //                    accessor->reportError(accessorCookie, "Color value not valid --"
+  //                            " must be #rgb, #argb, #rrggbb, or #aarrggbb");
+  //                }
+  //                #if 0
+  //                fprintf(stderr, "%s: Color ID %s value %s is not valid\n",
+  //                        "Resource File", //(const char*)in->getPrintableSource(),
+  //                        String8(*curTag).string(),
+  //                        String8(s, len).string());
+  //                #endif
+  //                return false;
+  //            }
+  //        }
+  //    }
+  //
+  //    if (*s == '?') {
+  //        outValue->dataType = outValue->TYPE_ATTRIBUTE;
+  //
+  //        // Note: we don't check attrType here because the reference can
+  //        // be to any other type; we just need to count on the client making
+  //        // sure the referenced type is correct.
+  //
+  //        //printf("Looking up attr: %s\n", String8(s, len).string());
+  //
+  //        static const String16 attr16("attr");
+  //        String16 package, type, name;
+  //        if (!expandResourceRef(s+1, len-1, &package, &type, &name,
+  //                               &attr16, defPackage, &errorMsg)) {
+  //            if (accessor != NULL) {
+  //                accessor->reportError(accessorCookie, errorMsg);
+  //            }
+  //            return false;
+  //        }
+  //
+  //        //printf("Pkg: %s, Type: %s, Name: %s\n",
+  //        //       String8(package).string(), String8(type).string(),
+  //        //       String8(name).string());
+  //        uint32_t specFlags = 0;
+  //        uint32_t rid =
+  //            identifierForName(name.string(), name.size(),
+  //                              type.string(), type.size(),
+  //                              package.string(), package.size(), &specFlags);
+  //        if (rid != 0) {
+  //            if (enforcePrivate) {
+  //                if ((specFlags&ResTable_typeSpec::SPEC_PUBLIC) == 0) {
+  //                    if (accessor != NULL) {
+  //                        accessor->reportError(accessorCookie, "Attribute is not public.");
+  //                    }
+  //                    return false;
+  //                }
+  //            }
+  //
+  //            if (accessor) {
+  //                rid = Res_MAKEID(
+  //                    accessor->getRemappedPackage(Res_GETPACKAGE(rid)),
+  //                    Res_GETTYPE(rid), Res_GETENTRY(rid));
+  //            }
+  //
+  //            uint32_t packageId = Res_GETPACKAGE(rid) + 1;
+  //            if (packageId != APP_PACKAGE_ID && packageId != SYS_PACKAGE_ID) {
+  //                outValue->dataType = Res_value::TYPE_DYNAMIC_ATTRIBUTE;
+  //            }
+  //            outValue->data = rid;
+  //            return true;
+  //        }
+  //
+  //        if (accessor) {
+  //            uint32_t rid = accessor->getCustomResource(package, type, name);
+  //            if (rid != 0) {
+  //                uint32_t packageId = Res_GETPACKAGE(rid) + 1;
+  //                if (packageId == 0x00) {
+  //                    outValue->data = rid;
+  //                    outValue->dataType = Res_value::TYPE_DYNAMIC_ATTRIBUTE;
+  //                    return true;
+  //                } else if (packageId == APP_PACKAGE_ID || packageId == SYS_PACKAGE_ID) {
+  //                    // We accept packageId's generated as 0x01 in order to support
+  //                    // building the android system resources
+  //                    outValue->data = rid;
+  //                    return true;
+  //                }
+  //            }
+  //        }
+  //
+  //        if (accessor != NULL) {
+  //            accessor->reportError(accessorCookie, "No resource found that matches the given
+  // name");
+  //        }
+  //        return false;
+  //    }
+  //
+  //    if (stringToInt(s, len, outValue)) {
+  //        if ((attrType&ResTable_map::TYPE_INTEGER) == 0) {
+  //            // If this type does not allow integers, but does allow floats,
+  //            // fall through on this error case because the float type should
+  //            // be able to accept any integer value.
+  //            if (!canStringCoerce && (attrType&ResTable_map::TYPE_FLOAT) == 0) {
+  //                if (accessor != NULL) {
+  //                    accessor->reportError(accessorCookie, "Integer types not allowed");
+  //                }
+  //                return false;
+  //            }
+  //        } else {
+  //            if (((int32_t)outValue->data) < ((int32_t)attrMin)
+  //                    || ((int32_t)outValue->data) > ((int32_t)attrMax)) {
+  //                if (accessor != NULL) {
+  //                    accessor->reportError(accessorCookie, "Integer value out of range");
+  //                }
+  //                return false;
+  //            }
+  //            return true;
+  //        }
+  //    }
+  //
+  //    if (stringToFloat(s, len, outValue)) {
+  //        if (outValue->dataType == Res_value::TYPE_DIMENSION) {
+  //            if ((attrType&ResTable_map::TYPE_DIMENSION) != 0) {
+  //                return true;
+  //            }
+  //            if (!canStringCoerce) {
+  //                if (accessor != NULL) {
+  //                    accessor->reportError(accessorCookie, "Dimension types not allowed");
+  //                }
+  //                return false;
+  //            }
+  //        } else if (outValue->dataType == Res_value::TYPE_FRACTION) {
+  //            if ((attrType&ResTable_map::TYPE_FRACTION) != 0) {
+  //                return true;
+  //            }
+  //            if (!canStringCoerce) {
+  //                if (accessor != NULL) {
+  //                    accessor->reportError(accessorCookie, "Fraction types not allowed");
+  //                }
+  //                return false;
+  //            }
+  //        } else if ((attrType&ResTable_map::TYPE_FLOAT) == 0) {
+  //            if (!canStringCoerce) {
+  //                if (accessor != NULL) {
+  //                    accessor->reportError(accessorCookie, "Float types not allowed");
+  //                }
+  //                return false;
+  //            }
+  //        } else {
+  //            return true;
+  //        }
+  //    }
+  //
+  //    if (len == 4) {
+  //        if ((s[0] == 't' || s[0] == 'T') &&
+  //            (s[1] == 'r' || s[1] == 'R') &&
+  //            (s[2] == 'u' || s[2] == 'U') &&
+  //            (s[3] == 'e' || s[3] == 'E')) {
+  //            if ((attrType&ResTable_map::TYPE_BOOLEAN) == 0) {
+  //                if (!canStringCoerce) {
+  //                    if (accessor != NULL) {
+  //                        accessor->reportError(accessorCookie, "Boolean types not allowed");
+  //                    }
+  //                    return false;
+  //                }
+  //            } else {
+  //                outValue->dataType = outValue->TYPE_INT_BOOLEAN;
+  //                outValue->data = (uint32_t)-1;
+  //                return true;
+  //            }
+  //        }
+  //    }
+  //
+  //    if (len == 5) {
+  //        if ((s[0] == 'f' || s[0] == 'F') &&
+  //            (s[1] == 'a' || s[1] == 'A') &&
+  //            (s[2] == 'l' || s[2] == 'L') &&
+  //            (s[3] == 's' || s[3] == 'S') &&
+  //            (s[4] == 'e' || s[4] == 'E')) {
+  //            if ((attrType&ResTable_map::TYPE_BOOLEAN) == 0) {
+  //                if (!canStringCoerce) {
+  //                    if (accessor != NULL) {
+  //                        accessor->reportError(accessorCookie, "Boolean types not allowed");
+  //                    }
+  //                    return false;
+  //                }
+  //            } else {
+  //                outValue->dataType = outValue->TYPE_INT_BOOLEAN;
+  //                outValue->data = 0;
+  //                return true;
+  //            }
+  //        }
+  //    }
+  //
+  //    if ((attrType&ResTable_map::TYPE_ENUM) != 0) {
+  //        const ssize_t p = getResourcePackageIndex(attrID);
+  //        const bag_entry* bag;
+  //        ssize_t cnt = p >= 0 ? lockBag(attrID, &bag) : -1;
+  //        //printf("Got %d for enum\n", cnt);
+  //        if (cnt >= 0) {
+  //            resource_name rname;
+  //            while (cnt > 0) {
+  //                if (!Res_INTERNALID(bag->map.name.ident)) {
+  //                    //printf("Trying attr #%08x\n", bag->map.name.ident);
+  //                    if (getResourceName(bag->map.name.ident, false, &rname)) {
+  //                        #if 0
+  //                        printf("Matching %s against %s (0x%08x)\n",
+  //                               String8(s, len).string(),
+  //                               String8(rname.name, rname.nameLen).string(),
+  //                               bag->map.name.ident);
+  //                        #endif
+  //                        if (strzcmp16(s, len, rname.name, rname.nameLen) == 0) {
+  //                            outValue->dataType = bag->map.value.dataType;
+  //                            outValue->data = bag->map.value.data;
+  //                            unlockBag(bag);
+  //                            return true;
+  //                        }
+  //                    }
+  //
+  //                }
+  //                bag++;
+  //                cnt--;
+  //            }
+  //            unlockBag(bag);
+  //        }
+  //
+  //        if (fromAccessor) {
+  //            if (accessor->getAttributeEnum(attrID, s, len, outValue)) {
+  //                return true;
+  //            }
+  //        }
+  //    }
+  //
+  //    if ((attrType&ResTable_map::TYPE_FLAGS) != 0) {
+  //        const ssize_t p = getResourcePackageIndex(attrID);
+  //        const bag_entry* bag;
+  //        ssize_t cnt = p >= 0 ? lockBag(attrID, &bag) : -1;
+  //        //printf("Got %d for flags\n", cnt);
+  //        if (cnt >= 0) {
+  //            bool failed = false;
+  //            resource_name rname;
+  //            outValue->dataType = Res_value::TYPE_INT_HEX;
+  //            outValue->data = 0;
+  //            const char16_t* end = s + len;
+  //            const char16_t* pos = s;
+  //            while (pos < end && !failed) {
+  //                const char16_t* start = pos;
+  //                pos++;
+  //                while (pos < end && *pos != '|') {
+  //                    pos++;
+  //                }
+  //                //printf("Looking for: %s\n", String8(start, pos-start).string());
+  //                const bag_entry* bagi = bag;
+  //                ssize_t i;
+  //                for (i=0; i<cnt; i++, bagi++) {
+  //                    if (!Res_INTERNALID(bagi->map.name.ident)) {
+  //                        //printf("Trying attr #%08x\n", bagi->map.name.ident);
+  //                        if (getResourceName(bagi->map.name.ident, false, &rname)) {
+  //                            #if 0
+  //                            printf("Matching %s against %s (0x%08x)\n",
+  //                                   String8(start,pos-start).string(),
+  //                                   String8(rname.name, rname.nameLen).string(),
+  //                                   bagi->map.name.ident);
+  //                            #endif
+  //                            if (strzcmp16(start, pos-start, rname.name, rname.nameLen) == 0) {
+  //                                outValue->data |= bagi->map.value.data;
+  //                                break;
+  //                            }
+  //                        }
+  //                    }
+  //                }
+  //                if (i >= cnt) {
+  //                    // Didn't find this flag identifier.
+  //                    failed = true;
+  //                }
+  //                if (pos < end) {
+  //                    pos++;
+  //                }
+  //            }
+  //            unlockBag(bag);
+  //            if (!failed) {
+  //                //printf("Final flag value: 0x%lx\n", outValue->data);
+  //                return true;
+  //            }
+  //        }
+  //
+  //
+  //        if (fromAccessor) {
+  //            if (accessor->getAttributeFlags(attrID, s, len, outValue)) {
+  //                //printf("Final flag value: 0x%lx\n", outValue->data);
+  //                return true;
+  //            }
+  //        }
+  //    }
+  //
+  //    if ((attrType&ResTable_map::TYPE_STRING) == 0) {
+  //        if (accessor != NULL) {
+  //            accessor->reportError(accessorCookie, "String types not allowed");
+  //        }
+  //        return false;
+  //    }
+  //
+  //    // Generic string handling...
+  //    outValue->dataType = outValue->TYPE_STRING;
+  //    if (outString) {
+  //        bool failed = collectString(outString, s, len, preserveSpaces, &errorMsg);
+  //        if (accessor != NULL) {
+  //            accessor->reportError(accessorCookie, errorMsg);
+  //        }
+  //        return failed;
+  //    }
+  //
+  //    return true;
+  // }
+  //
+  // bool ResTable::collectString(String16* outString,
+  //                             const char16_t* s, size_t len,
+  //                             bool preserveSpaces,
+  //                             const char** outErrorMsg,
+  //                             bool append)
+  // {
+  //    String16 tmp;
+  //
+  //    char quoted = 0;
+  //    const char16_t* p = s;
+  //    while (p < (s+len)) {
+  //        while (p < (s+len)) {
+  //            const char16_t c = *p;
+  //            if (c == '\\') {
+  //                break;
+  //            }
+  //            if (!preserveSpaces) {
+  //                if (quoted == 0 && isspace16(c)
+  //                    && (c != ' ' || isspace16(*(p+1)))) {
+  //                    break;
+  //                }
+  //                if (c == '"' && (quoted == 0 || quoted == '"')) {
+  //                    break;
+  //                }
+  //                if (c == '\'' && (quoted == 0 || quoted == '\'')) {
+  //                    /*
+  //                     * In practice, when people write ' instead of \'
+  //                     * in a string, they are doing it by accident
+  //                     * instead of really meaning to use ' as a quoting
+  //                     * character.  Warn them so they don't lose it.
+  //                     */
+  //                    if (outErrorMsg) {
+  //                        *outErrorMsg = "Apostrophe not preceded by \\";
+  //                    }
+  //                    return false;
+  //                }
+  //            }
+  //            p++;
+  //        }
+  //        if (p < (s+len)) {
+  //            if (p > s) {
+  //                tmp.append(String16(s, p-s));
+  //            }
+  //            if (!preserveSpaces && (*p == '"' || *p == '\'')) {
+  //                if (quoted == 0) {
+  //                    quoted = *p;
+  //                } else {
+  //                    quoted = 0;
+  //                }
+  //                p++;
+  //            } else if (!preserveSpaces && isspace16(*p)) {
+  //                // Space outside of a quote -- consume all spaces and
+  //                // leave a single plain space char.
+  //                tmp.append(String16(" "));
+  //                p++;
+  //                while (p < (s+len) && isspace16(*p)) {
+  //                    p++;
+  //                }
+  //            } else if (*p == '\\') {
+  //                p++;
+  //                if (p < (s+len)) {
+  //                    switch (*p) {
+  //                    case 't':
+  //                        tmp.append(String16("\t"));
+  //                        break;
+  //                    case 'n':
+  //                        tmp.append(String16("\n"));
+  //                        break;
+  //                    case '#':
+  //                        tmp.append(String16("#"));
+  //                        break;
+  //                    case '@':
+  //                        tmp.append(String16("@"));
+  //                        break;
+  //                    case '?':
+  //                        tmp.append(String16("?"));
+  //                        break;
+  //                    case '"':
+  //                        tmp.append(String16("\""));
+  //                        break;
+  //                    case '\'':
+  //                        tmp.append(String16("'"));
+  //                        break;
+  //                    case '\\':
+  //                        tmp.append(String16("\\"));
+  //                        break;
+  //                    case 'u':
+  //                    {
+  //                        char16_t chr = 0;
+  //                        int i = 0;
+  //                        while (i < 4 && p[1] != 0) {
+  //                            p++;
+  //                            i++;
+  //                            int c;
+  //                            if (*p >= '0' && *p <= '9') {
+  //                                c = *p - '0';
+  //                            } else if (*p >= 'a' && *p <= 'f') {
+  //                                c = *p - 'a' + 10;
+  //                            } else if (*p >= 'A' && *p <= 'F') {
+  //                                c = *p - 'A' + 10;
+  //                            } else {
+  //                                if (outErrorMsg) {
+  //                                    *outErrorMsg = "Bad character in \\u unicode escape
+  // sequence";
+  //                                }
+  //                                return false;
+  //                            }
+  //                            chr = (chr<<4) | c;
+  //                        }
+  //                        tmp.append(String16(&chr, 1));
+  //                    } break;
+  //                    default:
+  //                        // ignore unknown escape chars.
+  //                        break;
+  //                    }
+  //                    p++;
+  //                }
+  //            }
+  //            len -= (p-s);
+  //            s = p;
+  //        }
+  //    }
+  //
+  //    if (tmp.size() != 0) {
+  //        if (len > 0) {
+  //            tmp.append(String16(s, len));
+  //        }
+  //        if (append) {
+  //            outString->append(tmp);
+  //        } else {
+  //            outString->setTo(tmp);
+  //        }
+  //    } else {
+  //        if (append) {
+  //            outString->append(String16(s, len));
+  //        } else {
+  //            outString->setTo(s, len);
+  //        }
+  //    }
+  //
+  //    return true;
+  // }
+
+  public int getBasePackageCount() {
     if (mError != NO_ERROR) {
       return 0;
     }
     return mPackageGroups.size();
   }
 
-  public String getBasePackageName(int idx)
-  {
+  public String getBasePackageName(int idx) {
     if (mError != NO_ERROR) {
       return null;
     }
-    LOG_FATAL_IF(idx >= mPackageGroups.size(),
+    LOG_FATAL_IF(
+        idx >= mPackageGroups.size(),
         "Requested package index %d past package count %d",
-        (int)idx, (int)mPackageGroups.size());
+        (int) idx,
+        (int) mPackageGroups.size());
     return mPackageGroups.get(keyFor(idx)).name;
   }
 
-  public int getBasePackageId(int idx)
-  {
+  public int getBasePackageId(int idx) {
     if (mError != NO_ERROR) {
       return 0;
     }
-    LOG_FATAL_IF(idx >= mPackageGroups.size(),
+    LOG_FATAL_IF(
+        idx >= mPackageGroups.size(),
         "Requested package index %d past package count %d",
-        (int)idx, (int)mPackageGroups.size());
+        (int) idx,
+        (int) mPackageGroups.size());
     return mPackageGroups.get(keyFor(idx)).id;
   }
 
-  int getLastTypeIdForPackage(int idx)
-  {
+  int getLastTypeIdForPackage(int idx) {
     if (mError != NO_ERROR) {
       return 0;
     }
-    LOG_FATAL_IF(idx >= mPackageGroups.size(),
+    LOG_FATAL_IF(
+        idx >= mPackageGroups.size(),
         "Requested package index %d past package count %d",
-        (int)idx, (int)mPackageGroups.size());
+        (int) idx,
+        (int) mPackageGroups.size());
     PackageGroup group = mPackageGroups.get(keyFor(idx));
     return group.largestTypeId;
   }
@@ -2439,7 +2531,7 @@ public class ResTable {
     final int e = Res_GETENTRY(resID);
 
     if (p < 0) {
-      if (Res_GETPACKAGE(resID)+1 == 0) {
+      if (Res_GETPACKAGE(resID) + 1 == 0) {
         ALOGW("No package identifier when getting name for resource number 0x%08x", resID);
       }
       return false;
@@ -2486,18 +2578,21 @@ public class ResTable {
   // The first in 'package' is always the root object (from the resource
   // table that defined the package); the ones after are skins on top of it.
   // from ResourceTypes.cpp struct ResTable::PackageGroup
-  public static class PackageGroup
-  {
+  public static class PackageGroup {
     public PackageGroup(
-        ResTable _owner, final String _name, int _id,
-        boolean appAsLib, boolean _isSystemAsset, boolean _isDynamic)
-//        : owner(_owner)
-//        , name(_name)
-//        , id(_id)
-//        , largestTypeId(0)
-//        , dynamicRefTable(static_cast<uint8_t>(_id), appAsLib)
-//        , isSystemAsset(_isSystemAsset)
-    {
+        ResTable _owner,
+        final String _name,
+        int _id,
+        boolean appAsLib,
+        boolean _isSystemAsset,
+        boolean _isDynamic)
+          //        : owner(_owner)
+          //        , name(_name)
+          //        , id(_id)
+          //        , largestTypeId(0)
+          //        , dynamicRefTable(static_cast<uint8_t>(_id), appAsLib)
+          //        , isSystemAsset(_isSystemAsset)
+        {
       this.owner = _owner;
       this.name = _name;
       this.id = _id;
@@ -2506,65 +2601,65 @@ public class ResTable {
       this.isDynamic = _isDynamic;
     }
 
-//    ~PackageGroup() {
-//      clearBagCache();
-//      final int numTypes = types.size();
-//      for (int i = 0; i < numTypes; i++) {
-//        final List<DataType> typeList = types.get(i);
-//        final int numInnerTypes = typeList.size();
-//        for (int j = 0; j < numInnerTypes; j++) {
-//          if (typeList.get(j)._package_.owner == owner) {
-//            delete typeList[j];
-//          }
-//        }
-//        typeList.clear();
-//      }
-//
-//      final int N = packages.size();
-//      for (int i=0; i<N; i++) {
-//        ResTable_package pkg = packages[i];
-//        if (pkg.owner == owner) {
-//          delete pkg;
-//        }
-//      }
-//    }
+    //    ~PackageGroup() {
+    //      clearBagCache();
+    //      final int numTypes = types.size();
+    //      for (int i = 0; i < numTypes; i++) {
+    //        final List<DataType> typeList = types.get(i);
+    //        final int numInnerTypes = typeList.size();
+    //        for (int j = 0; j < numInnerTypes; j++) {
+    //          if (typeList.get(j)._package_.owner == owner) {
+    //            delete typeList[j];
+    //          }
+    //        }
+    //        typeList.clear();
+    //      }
+    //
+    //      final int N = packages.size();
+    //      for (int i=0; i<N; i++) {
+    //        ResTable_package pkg = packages[i];
+    //        if (pkg.owner == owner) {
+    //          delete pkg;
+    //        }
+    //      }
+    //    }
 
     /**
-     * Clear all cache related data that depends on parameters/configuration.
-     * This includes the bag caches and filtered types.
+     * Clear all cache related data that depends on parameters/configuration. This includes the bag
+     * caches and filtered types.
      */
     void clearBagCache() {
-//      for (int i = 0; i < typeCacheEntries.size(); i++) {
-//        if (kDebugTableNoisy) {
-//          printf("type=0x%x\n", i);
-//        }
-//        final List<DataType> typeList = types.get(i);
-//        if (!typeList.isEmpty()) {
-//          TypeCacheEntry cacheEntry = typeCacheEntries.editItemAt(i);
-//
-//          // Reset the filtered configurations.
-//          cacheEntry.filteredConfigs.clear();
-//
-//          bag_set[][] typeBags = cacheEntry.cachedBags;
-//          if (kDebugTableNoisy) {
-//            printf("typeBags=%s\n", typeBags);
-//          }
-//
-//          if (isTruthy(typeBags)) {
-//            final int N = typeList.get(0).entryCount;
-//            if (kDebugTableNoisy) {
-//              printf("type.entryCount=0x%x\n", N);
-//            }
-//            for (int j = 0; j < N; j++) {
-//              if (typeBags[j] && typeBags[j] != (bag_set *) 0xFFFFFFFF){
-//                free(typeBags[j]);
-//              }
-//            }
-//            free(typeBags);
-//            cacheEntry.cachedBags = NULL;
-//          }
-//        }
-//      }
+      //      for (int i = 0; i < typeCacheEntries.size(); i++) {
+      //        if (kDebugTableNoisy) {
+      //          printf("type=0x%x\n", i);
+      //        }
+      //        final List<DataType> typeList = types.get(i);
+      //        if (!typeList.isEmpty()) {
+      //          TypeCacheEntry cacheEntry = typeCacheEntries.editItemAt(i);
+      //
+      //          // Reset the filtered configurations.
+      //          cacheEntry.filteredConfigs.clear();
+      //
+      //          bag_set[][] typeBags = cacheEntry.cachedBags;
+      //          if (kDebugTableNoisy) {
+      //            printf("typeBags=%s\n", typeBags);
+      //          }
+      //
+      //          if (isTruthy(typeBags)) {
+      //            final int N = typeList.get(0).entryCount;
+      //            if (kDebugTableNoisy) {
+      //              printf("type.entryCount=0x%x\n", N);
+      //            }
+      //            for (int j = 0; j < N; j++) {
+      //              if (typeBags[j] && typeBags[j] != (bag_set *) 0xFFFFFFFF){
+      //                free(typeBags[j]);
+      //              }
+      //            }
+      //            free(typeBags);
+      //            cacheEntry.cachedBags = NULL;
+      //          }
+      //        }
+      //      }
     }
 
     //    long findType16(final String type, int len) {
@@ -2617,36 +2712,36 @@ public class ResTable {
   }
 
   // --------------------------------------------------------------------
-// --------------------------------------------------------------------
-// --------------------------------------------------------------------
+  // --------------------------------------------------------------------
+  // --------------------------------------------------------------------
 
-//  struct ResTable::Header
-  public static class Header
-  {
-//    Header(ResTable* _owner) : owner(_owner), ownedData(NULL), header(NULL),
-//      resourceIDMap(NULL), resourceIDMapSize(0) { }
+  //  struct ResTable::Header
+  public static class Header {
+    //    Header(ResTable* _owner) : owner(_owner), ownedData(NULL), header(NULL),
+    //      resourceIDMap(NULL), resourceIDMapSize(0) { }
 
     public Header(ResTable owner) {
       this.owner = owner;
     }
 
-//    ~Header()
-//    {
-//      free(resourceIDMap);
-//    }
+    //    ~Header()
+    //    {
+    //      free(resourceIDMap);
+    //    }
 
-    ResTable            owner;
-    byte[]                           ownedData;
+    ResTable owner;
+    byte[] ownedData;
     ResTable_header header;
-    int                          size;
-    int                  dataEnd;
-    int                          index;
-    int                         cookie;
-
-    ResStringPool                   values = new ResStringPool();
-    int[]                       resourceIDMap;
-    int                          resourceIDMapSize;
-  };
+    int size;
+    int dataEnd;
+    int index;
+    int cookie;
+
+    ResStringPool values = new ResStringPool();
+    int[] resourceIDMap;
+    int resourceIDMapSize;
+  }
+  ;
 
   public static class Entry {
     ResTable_config config;
@@ -2707,7 +2802,8 @@ public class ResTable {
     ResStringPool keyStrings = new ResStringPool();
 
     int typeIdOffset;
-  };
+  }
+  ;
 
   public static class bag_entry {
     public int stringBlock;
@@ -2727,7 +2823,7 @@ public class ResTable {
 
     int err = getBagLocked(resID, outBag, null);
     if (err < NO_ERROR) {
-      //printf("*** get failed!  unlocking\n");
+      // printf("*** get failed!  unlocking\n");
       mLock.release();
     }
     return err;
@@ -2751,7 +2847,7 @@ public class ResTable {
       return BAD_INDEX;
     }
 
-    //printf("Get bag: id=0x%08x, p=%d, t=%d\n", resID, p, t);
+    // printf("Get bag: id=0x%08x, p=%d, t=%d\n", resID, p, t);
     PackageGroup grp = mPackageGroups.get(p);
     if (grp == NULL) {
       ALOGW("Bad identifier when getting bag for resource number 0x%08x", resID);
@@ -2760,14 +2856,15 @@ public class ResTable {
 
     final List<Type> typeConfigs = getOrDefault(grp.types, t, Collections.emptyList());
     if (typeConfigs.isEmpty()) {
-      ALOGW("Type identifier 0x%x does not exist.", t+1);
+      ALOGW("Type identifier 0x%x does not exist.", t + 1);
       return BAD_INDEX;
     }
 
     final int NENTRY = typeConfigs.get(0).entryCount;
-    if (e >= (int)NENTRY) {
-      ALOGW("Entry identifier 0x%x is larger than entry count 0x%x",
-          e, (int)typeConfigs.get(0).entryCount);
+    if (e >= (int) NENTRY) {
+      ALOGW(
+          "Entry identifier 0x%x is larger than entry count 0x%x",
+          e, (int) typeConfigs.get(0).entryCount);
       return BAD_INDEX;
     }
 
@@ -2775,35 +2872,35 @@ public class ResTable {
     TypeCacheEntry cacheEntry = grp.typeCacheEntries.editItemAt(t);
     bag_set[] typeSet = cacheEntry.cachedBags;
     // todo cache
-//    if (isTruthy(typeSet)) {
-//      bag_set set = typeSet[e];
-//      if (isTruthy(set)) {
-//        if (set != (bag_set) 0xFFFFFFFF){
-//        if (set != SENTINEL_BAG_SET){
-//          if (outTypeSpecFlags != NULL) {
-//                    outTypeSpecFlags.set(set.typeSpecFlags);
-//          }
-//          outBag.set((bag_entry *) (set + 1);
-//          if (kDebugTableSuperNoisy) {
-//            ALOGI("Found existing bag for: 0x%x\n", resID);
-//          }
-//          return set.numAttrs;
-//        }
-//        ALOGW("Attempt to retrieve bag 0x%08x which is invalid or in a cycle.",
-//            resID);
-//        return BAD_INDEX;
-//      }
-//    }
-//
+    //    if (isTruthy(typeSet)) {
+    //      bag_set set = typeSet[e];
+    //      if (isTruthy(set)) {
+    //        if (set != (bag_set) 0xFFFFFFFF){
+    //        if (set != SENTINEL_BAG_SET){
+    //          if (outTypeSpecFlags != NULL) {
+    //                    outTypeSpecFlags.set(set.typeSpecFlags);
+    //          }
+    //          outBag.set((bag_entry *) (set + 1);
+    //          if (kDebugTableSuperNoisy) {
+    //            ALOGI("Found existing bag for: 0x%x\n", resID);
+    //          }
+    //          return set.numAttrs;
+    //        }
+    //        ALOGW("Attempt to retrieve bag 0x%08x which is invalid or in a cycle.",
+    //            resID);
+    //        return BAD_INDEX;
+    //      }
+    //    }
+    //
     // Bag not found, we need to compute it!
     if (!isTruthy(typeSet)) {
       typeSet = new bag_set[NENTRY]; // (bag_set**)calloc(NENTRY, sizeof(bag_set*));
-      //cacheEntry.cachedBags = typeSet;
+      // cacheEntry.cachedBags = typeSet;
     }
-//
-//    // Mark that we are currently working on this one.
-//    typeSet[e] = (bag_set*)0xFFFFFFFF;
-//    typeSet[e] = SENTINEL_BAG_SET;
+    //
+    //    // Mark that we are currently working on this one.
+    //    typeSet[e] = (bag_set*)0xFFFFFFFF;
+    //    typeSet[e] = SENTINEL_BAG_SET;
 
     if (kDebugTableNoisy) {
       ALOGI("Building bag: %x\n", resID);
@@ -2816,12 +2913,14 @@ public class ResTable {
       return err;
     }
     final short entrySize = dtohs(entry.entry.size);
-//    const uint32_t parent = entrySize >= sizeof(ResTable_map_entry)
-//        ? dtohl(((const ResTable_map_entry*)entry.entry)->parent.ident) : 0;
-//    const uint32_t count = entrySize >= sizeof(ResTable_map_entry)
-//        ? dtohl(((const ResTable_map_entry*)entry.entry)->count) : 0;
-    ResTable_map_entry mapEntry = entrySize >= ResTable_map_entry.BASE_SIZEOF ?
-        new ResTable_map_entry(entry.entry.myBuf(), entry.entry.myOffset()) : null;
+    //    const uint32_t parent = entrySize >= sizeof(ResTable_map_entry)
+    //        ? dtohl(((const ResTable_map_entry*)entry.entry)->parent.ident) : 0;
+    //    const uint32_t count = entrySize >= sizeof(ResTable_map_entry)
+    //        ? dtohl(((const ResTable_map_entry*)entry.entry)->count) : 0;
+    ResTable_map_entry mapEntry =
+        entrySize >= ResTable_map_entry.BASE_SIZEOF
+            ? new ResTable_map_entry(entry.entry.myBuf(), entry.entry.myOffset())
+            : null;
     final int parent = mapEntry != null ? dtohl(mapEntry.parent.ident) : 0;
     final int count = mapEntry != null ? dtohl(mapEntry.count) : 0;
 
@@ -2880,11 +2979,12 @@ public class ResTable {
     set.typeSpecFlags |= entry.specFlags;
 
     // Now merge in the new attributes...
-//    int curOff = (reinterpret_cast<uintptr_t>(entry.entry) - reinterpret_cast<uintptr_t>(entry.type))
-//        + dtohs(entry.entry.size);
+    //    int curOff = (reinterpret_cast<uintptr_t>(entry.entry) -
+    // reinterpret_cast<uintptr_t>(entry.type))
+    //        + dtohs(entry.entry.size);
     int curOff = entry.entry.myOffset() - entry.type.myOffset() + entry.entry.size;
     ResTable_map map;
-//    bag_entry* entries = (bag_entry*)(set+1);
+    //    bag_entry* entries = (bag_entry*)(set+1);
     bag_entry[] entries = set.bag_entries;
     int curEntry = 0;
     int pos = 0;
@@ -2893,16 +2993,17 @@ public class ResTable {
     }
     while (pos < count) {
       if (kDebugTableNoisy) {
-//        ALOGI("Now at %s\n", curOff);
+        //        ALOGI("Now at %s\n", curOff);
         ALOGI("Now at %s\n", curEntry);
       }
 
-      if (curOff > (dtohl(entry.type.header.size)- ResTable_map.SIZEOF)) {
-        ALOGW("ResTable_map at %d is beyond type chunk data %d",
-            (int)curOff, dtohl(entry.type.header.size));
+      if (curOff > (dtohl(entry.type.header.size) - ResTable_map.SIZEOF)) {
+        ALOGW(
+            "ResTable_map at %d is beyond type chunk data %d",
+            (int) curOff, dtohl(entry.type.header.size));
         return BAD_TYPE;
       }
-//      map = (const ResTable_map*)(((const uint8_t*)entry.type) + curOff);
+      //      map = (const ResTable_map*)(((const uint8_t*)entry.type) + curOff);
       map = new ResTable_map(entry.type.myBuf(), entry.type.myOffset() + curOff);
       N++;
 
@@ -2911,7 +3012,8 @@ public class ResTable {
         // Attributes don't have a resource id as the name. They specify
         // other data, which would be wrong to change via a lookup.
         if (grp.dynamicRefTable.lookupResourceId(newName) != NO_ERROR) {
-          ALOGE("Failed resolving ResTable_map name at %d with ident 0x%08x",
+          ALOGE(
+              "Failed resolving ResTable_map name at %d with ident 0x%08x",
               (int) curEntry, (int) newName.get());
           return UNKNOWN_ERROR;
         }
@@ -2919,10 +3021,11 @@ public class ResTable {
 
       boolean isInside;
       int oldName = 0;
-      while ((isInside=(curEntry < set.numAttrs))
-          && (oldName=entries[curEntry].map.name.ident) < newName.get()) {
+      while ((isInside = (curEntry < set.numAttrs))
+          && (oldName = entries[curEntry].map.name.ident) < newName.get()) {
         if (kDebugTableNoisy) {
-          ALOGI("#0x%x: Keeping existing attribute: 0x%08x\n",
+          ALOGI(
+              "#0x%x: Keeping existing attribute: 0x%08x\n",
               curEntry, entries[curEntry].map.name.ident);
         }
         curEntry++;
@@ -2932,23 +3035,22 @@ public class ResTable {
         // This is a new attribute...  figure out what to do with it.
         if (set.numAttrs >= set.availAttrs) {
           // Need to alloc more memory...
-                final int newAvail = set.availAttrs+N;
-//          set = (bag_set[])realloc(set,
-//              sizeof(bag_set)
-//                  + sizeof(bag_entry)*newAvail);
+          final int newAvail = set.availAttrs + N;
+          //          set = (bag_set[])realloc(set,
+          //              sizeof(bag_set)
+          //                  + sizeof(bag_entry)*newAvail);
           set.resizeBagEntries(newAvail);
           set.availAttrs = newAvail;
-//          entries = (bag_entry*)(set+1);
+          //          entries = (bag_entry*)(set+1);
           entries = set.bag_entries;
           if (kDebugTableNoisy) {
-            ALOGI("Reallocated set %s, entries=%s, avail=0x%x\n",
-                set, entries, set.availAttrs);
+            ALOGI("Reallocated set %s, entries=%s, avail=0x%x\n", set, entries, set.availAttrs);
           }
         }
         if (isInside) {
           // Going in the middle, need to make space.
-//          memmove(entries+curEntry+1, entries+curEntry,
-//              sizeof(bag_entry)*(set.numAttrs-curEntry));
+          //          memmove(entries+curEntry+1, entries+curEntry,
+          //              sizeof(bag_entry)*(set.numAttrs-curEntry));
           System.arraycopy(entries, curEntry, entries, curEntry + 1, set.numAttrs - curEntry);
           entries[curEntry] = null;
           set.numAttrs++;
@@ -2969,7 +3071,7 @@ public class ResTable {
 
       cur.stringBlock = entry._package_.header.index;
       cur.map.name.ident = newName.get();
-//      cur->map.value.copyFrom_dtoh(map->value);
+      //      cur->map.value.copyFrom_dtoh(map->value);
       cur.map.value = map.value;
       final Ref<Res_value> valueRef = new Ref<>(cur.map.value);
       err = grp.dynamicRefTable.lookupResourceValue(valueRef);
@@ -2980,18 +3082,24 @@ public class ResTable {
       }
 
       if (kDebugTableNoisy) {
-        ALOGI("Setting entry #0x%x %s: block=%d, name=0x%08d, type=%d, data=0x%08x\n",
-            curEntry, cur, cur.stringBlock, cur.map.name.ident,
-            cur.map.value.dataType, cur.map.value.data);
+        ALOGI(
+            "Setting entry #0x%x %s: block=%d, name=0x%08d, type=%d, data=0x%08x\n",
+            curEntry,
+            cur,
+            cur.stringBlock,
+            cur.map.name.ident,
+            cur.map.value.dataType,
+            cur.map.value.data);
       }
 
       // On to the next!
       curEntry++;
       pos++;
       final int size = dtohs(map.value.size);
-//      curOff += size + sizeof(*map)-sizeof(map->value);
-      curOff += size + ResTable_map.SIZEOF-Res_value.SIZEOF;
-    };
+      //      curOff += size + sizeof(*map)-sizeof(map->value);
+      curOff += size + ResTable_map.SIZEOF - Res_value.SIZEOF;
+    }
+    ;
 
     if (curEntry > set.numAttrs) {
       set.numAttrs = curEntry;
@@ -3017,8 +3125,8 @@ public class ResTable {
   }
 
   static class bag_set {
-    int numAttrs;    // number in array
-    int availAttrs;  // total space in array
+    int numAttrs; // number in array
+    int availAttrs; // total space in array
     int typeSpecFlags;
     // Followed by 'numAttr' bag_entry structures.
 
@@ -3039,27 +3147,28 @@ public class ResTable {
       System.arraycopy(bag_entries, 0, newEntries, 0, Math.min(bag_entries.length, newEntryCount));
       bag_entries = newEntries;
     }
-  };
+  }
+  ;
 
   /**
-   * Configuration dependent cached data. This must be cleared when the configuration is
-   * changed (setParameters).
+   * Configuration dependent cached data. This must be cleared when the configuration is changed
+   * (setParameters).
    */
   static class TypeCacheEntry {
-//    TypeCacheEntry() : cachedBags(NULL) {}
+    //    TypeCacheEntry() : cachedBags(NULL) {}
 
     // Computed attribute bags for this type.
-//    bag_set** cachedBags;
+    //    bag_set** cachedBags;
     bag_set[] cachedBags;
 
     // Pre-filtered list of configurations (per asset path) that match the parameters set on this
     // ResTable.
     List<List<ResTable_type>> filteredConfigs;
-  };
-
+  }
+  ;
 
   private int Res_MAKEID(int packageId, int typeId, int entryId) {
-    return (((packageId+1)<<24) | (((typeId+1)&0xFF)<<16) | (entryId&0xFFFF));
+    return (((packageId + 1) << 24) | (((typeId + 1) & 0xFF) << 16) | (entryId & 0xFFFF));
   }
 
   // struct resource_name
diff --git a/resources/src/main/java/org/robolectric/res/android/ResTableTheme.java b/resources/src/main/java/org/robolectric/res/android/ResTableTheme.java
index af47122fe..2ee74e965 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResTableTheme.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResTableTheme.java
@@ -72,8 +72,7 @@ public class ResTableTheme {
     return this.mTable;
   }
 
-  public int GetAttribute(int resID, Ref<Res_value> valueRef,
-      final Ref<Integer> outTypeSpecFlags) {
+  public int GetAttribute(int resID, Ref<Res_value> valueRef, final Ref<Integer> outTypeSpecFlags) {
     int cnt = 20;
 
     if (outTypeSpecFlags != null) outTypeSpecFlags.set(0);
@@ -113,8 +112,7 @@ public class ResTableTheme {
                 outTypeSpecFlags.set(outTypeSpecFlags.get() | te.typeSpecFlags);
               }
               if (kDebugTableTheme) {
-                ALOGI("Theme value: type=0x%x, data=0x%08x",
-                    te.value.dataType, te.value.data);
+                ALOGI("Theme value: type=0x%x, data=0x%08x", te.value.dataType, te.value.data);
               }
               final int type = te.value.dataType;
               if (type == TYPE_ATTRIBUTE) {
@@ -125,8 +123,7 @@ public class ResTableTheme {
                 }
                 ALOGW("Too many attribute references, stopped at: 0x%08x\n", resID);
                 return BAD_INDEX;
-              } else if (type != TYPE_NULL
-                  || te.value.data == Res_value.DATA_NULL_EMPTY) {
+              } else if (type != TYPE_NULL || te.value.data == Res_value.DATA_NULL_EMPTY) {
                 valueRef.set(te.value);
                 return te.stringBlock;
               }
@@ -140,28 +137,32 @@ public class ResTableTheme {
     } while (true);
 
     return BAD_INDEX;
-
   }
 
-  public int resolveAttributeReference(Ref<Res_value> inOutValue,
-      int blockIndex, Ref<Integer> outLastRef,
-      final Ref<Integer> inoutTypeSpecFlags, Ref<ResTable_config> inoutConfig) {
-    //printf("Resolving type=0x%x\n", inOutValue->dataType);
+  public int resolveAttributeReference(
+      Ref<Res_value> inOutValue,
+      int blockIndex,
+      Ref<Integer> outLastRef,
+      final Ref<Integer> inoutTypeSpecFlags,
+      Ref<ResTable_config> inoutConfig) {
+    // printf("Resolving type=0x%x\n", inOutValue->dataType);
     if (inOutValue.get().dataType == TYPE_ATTRIBUTE) {
       final Ref<Integer> newTypeSpecFlags = new Ref<>(0);
       blockIndex = GetAttribute(inOutValue.get().data, inOutValue, newTypeSpecFlags);
       if (kDebugTableTheme) {
-        ALOGI("Resolving attr reference: blockIndex=%d, type=0x%x, data=0x%x\n",
-            (int)blockIndex, (int)inOutValue.get().dataType, inOutValue.get().data);
+        ALOGI(
+            "Resolving attr reference: blockIndex=%d, type=0x%x, data=0x%x\n",
+            (int) blockIndex, (int) inOutValue.get().dataType, inOutValue.get().data);
       }
-      if (inoutTypeSpecFlags != null) inoutTypeSpecFlags.set(inoutTypeSpecFlags.get() | newTypeSpecFlags.get());
-      //printf("Retrieved attribute new type=0x%x\n", inOutValue->dataType);
+      if (inoutTypeSpecFlags != null)
+        inoutTypeSpecFlags.set(inoutTypeSpecFlags.get() | newTypeSpecFlags.get());
+      // printf("Retrieved attribute new type=0x%x\n", inOutValue->dataType);
       if (blockIndex < 0) {
         return blockIndex;
       }
     }
-    return mTable.resolveReference(inOutValue, blockIndex, outLastRef,
-        inoutTypeSpecFlags, inoutConfig);
+    return mTable.resolveReference(
+        inOutValue, blockIndex, outLastRef, inoutTypeSpecFlags, inoutConfig);
   }
 
   public int applyStyle(int resID, boolean force) {
@@ -224,7 +225,7 @@ public class ResTableTheme {
           continue;
         }
         curType = t;
-        curEntries = curPI.types[t] != null ? curPI.types[t].entries: null;
+        curEntries = curPI.types[t] != null ? curPI.types[t].entries : null;
         if (curEntries == null) {
           final PackageGroup grp = mTable.mPackageGroups.get(curPackageIndex);
           final List<ResTable.Type> typeList = getOrDefault(grp.types, t, Collections.emptyList());
@@ -255,12 +256,16 @@ public class ResTableTheme {
       }
 
       if (kDebugTableNoisy) {
-        ALOGV("Attr 0x%08x: type=0x%x, data=0x%08x; curType=0x%x",
-            attrRes, bag.get()[bagIndex].map.value.dataType, bag.get()[bagIndex].map.value.data,
+        ALOGV(
+            "Attr 0x%08x: type=0x%x, data=0x%08x; curType=0x%x",
+            attrRes,
+            bag.get()[bagIndex].map.value.dataType,
+            bag.get()[bagIndex].map.value.data,
             curEntry.value.dataType);
       }
-      if (force || (curEntry.value.dataType == TYPE_NULL
-          && curEntry.value.data != Res_value.DATA_NULL_EMPTY)) {
+      if (force
+          || (curEntry.value.dataType == TYPE_NULL
+              && curEntry.value.data != Res_value.DATA_NULL_EMPTY)) {
         curEntry.stringBlock = bagEntry.stringBlock;
         curEntry.typeSpecFlags |= bagTypeSpecFlags.get();
         curEntry.value = new Res_value(bagEntry.map.value);
@@ -277,12 +282,9 @@ public class ResTableTheme {
     }
 
     return NO_ERROR;
-
   }
 
-  private void dumpToLog() {
-
-  }
+  private void dumpToLog() {}
 
   public int setTo(ResTableTheme other) {
     styles.clear();
@@ -295,7 +297,7 @@ public class ResTableTheme {
     }
 
     if (mTable == other.mTable) {
-      for (int i=0; i<Res_MAXPACKAGE; i++) {
+      for (int i = 0; i < Res_MAXPACKAGE; i++) {
         if (mPackages[i] != null) {
           mPackages[i] = null;
         }
@@ -309,12 +311,12 @@ public class ResTableTheme {
       // @todo: need to really implement this, not just copy
       // the system package (which is still wrong because it isn't
       // fixing up resource references).
-      for (int i=0; i<Res_MAXPACKAGE; i++) {
+      for (int i = 0; i < Res_MAXPACKAGE; i++) {
         if (mPackages[i] != null) {
           mPackages[i] = null;
         }
         // todo: C++ code presumably assumes index 0 is system, and only system
-        //if (i == 0 && other.mPackages[i] != null) {
+        // if (i == 0 && other.mPackages[i] != null) {
         if (other.mPackages[i] != null) {
           mPackages[i] = copy_package(other.mPackages[i]);
         } else {
@@ -347,7 +349,7 @@ public class ResTableTheme {
       if (te != null) {
         theme_entry[] newte = new theme_entry[cnt];
         newpi.types[j].entries = newte;
-//        memcpy(newte, te, cnt*sizeof(theme_entry));
+        //        memcpy(newte, te, cnt*sizeof(theme_entry));
         for (int i = 0; i < newte.length; i++) {
           newte[i] = te[i] == null ? null : new theme_entry(te[i]); // deep copy
         }
@@ -373,7 +375,8 @@ public class ResTableTheme {
         value = new Res_value(src.value);
       }
     }
-  };
+  }
+  ;
 
   static class type_info {
     int numEntries;
@@ -385,7 +388,7 @@ public class ResTableTheme {
     type_info(type_info src) {
       numEntries = src.numEntries;
       entries = new theme_entry[src.entries.length];
-      for (int i=0; i < src.entries.length; i++) {
+      for (int i = 0; i < src.entries.length; i++) {
         if (src.entries[i] == null) {
           entries[i] = null;
         } else {
@@ -393,7 +396,8 @@ public class ResTableTheme {
         }
       }
     }
-  };
+  }
+  ;
 
   static class package_info {
     type_info[] types = new type_info[Res_MAXTYPE + 1];
@@ -402,7 +406,7 @@ public class ResTableTheme {
 
     /** copy constructor. Performs a deep copy */
     package_info(package_info src) {
-      for (int i=0; i < src.types.length; i++) {
+      for (int i = 0; i < src.types.length; i++) {
         if (src.types[i] == null) {
           types[i] = null;
         } else {
@@ -410,7 +414,8 @@ public class ResTableTheme {
         }
       }
     }
-  };
+  }
+  ;
 
   static final int Res_MAXPACKAGE = 255;
   static final int Res_MAXTYPE = 255;
diff --git a/resources/src/main/java/org/robolectric/res/android/ResTable_config.java b/resources/src/main/java/org/robolectric/res/android/ResTable_config.java
index 3c4a8402d..177149ea3 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResTable_config.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResTable_config.java
@@ -74,11 +74,13 @@ import javax.annotation.Nonnull;
 /**
  * Describes a particular resource configuration.
  *
- * Transliterated from:
- * * https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/ResourceTypes.cpp
- * * https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/include/ResourceTypes.h (struct ResTable_config)
+ * <p>Transliterated from: *
+ * https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/ResourceTypes.cpp
+ * *
+ * https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/include/ResourceTypes.h
+ * (struct ResTable_config)
  *
- * Changes from 8.0.0_r4 partially applied.
+ * <p>Changes from 8.0.0_r4 partially applied.
  */
 @SuppressWarnings("NewApi")
 public class ResTable_config {
@@ -110,13 +112,14 @@ public class ResTable_config {
   public static final int SIZEOF = SCREEN_CONFIG_EXTENSION_MIN_SIZE;
 
   // Codes for specially handled languages and regions
-  static final byte[] kEnglish = new byte[] {'e', 'n'};  // packed version of "en"
-  static final byte[] kUnitedStates = new byte[] {'U', 'S'};  // packed version of "US"
-  static final byte[] kFilipino = new byte[] {(byte)0xAD, 0x05};  // packed version of "fil" ported from C {'\xAD', '\x05'}
-  static final byte[] kTagalog = new byte[] {'t', 'l'};  // packed version of "tl"
+  static final byte[] kEnglish = new byte[] {'e', 'n'}; // packed version of "en"
+  static final byte[] kUnitedStates = new byte[] {'U', 'S'}; // packed version of "US"
+  static final byte[] kFilipino =
+      new byte[] {(byte) 0xAD, 0x05}; // packed version of "fil" ported from C {'\xAD', '\x05'}
+  static final byte[] kTagalog = new byte[] {'t', 'l'}; // packed version of "tl"
 
   static ResTable_config createConfig(ByteBuffer buffer) {
-    int startPosition = buffer.position();  // The starting buffer position to calculate bytes read.
+    int startPosition = buffer.position(); // The starting buffer position to calculate bytes read.
     int size = buffer.getInt();
     int mcc = buffer.getShort() & 0xFFFF;
     int mnc = buffer.getShort() & 0xFFFF;
@@ -130,7 +133,7 @@ public class ResTable_config {
     int keyboard = UnsignedBytes.toInt(buffer.get());
     int navigation = UnsignedBytes.toInt(buffer.get());
     int inputFlags = UnsignedBytes.toInt(buffer.get());
-    buffer.get();  // 1 byte of padding
+    buffer.get(); // 1 byte of padding
     int screenWidth = buffer.getShort() & 0xFFFF;
     int screenHeight = buffer.getShort() & 0xFFFF;
     int sdkVersion = buffer.getShort() & 0xFFFF;
@@ -167,8 +170,8 @@ public class ResTable_config {
 
     if (size >= SCREEN_CONFIG_EXTENSION_MIN_SIZE) {
       screenLayout2 = (byte) UnsignedBytes.toInt(buffer.get());
-      screenConfigPad1 = buffer.get();  // Reserved padding
-      screenConfigPad2 = buffer.getShort();  // More reserved padding
+      screenConfigPad1 = buffer.get(); // Reserved padding
+      screenConfigPad2 = buffer.getShort(); // More reserved padding
     }
 
     // After parsing everything that's known, account for anything that's unknown.
@@ -176,16 +179,39 @@ public class ResTable_config {
     byte[] unknown = new byte[size - bytesRead];
     buffer.get(unknown);
 
-    return new ResTable_config(size, mcc, mnc, language, region, orientation,
-        touchscreen, density, keyboard, navigation, inputFlags, screenWidth, screenHeight,
-        sdkVersion, minorVersion, screenLayout, uiMode, smallestScreenWidthDp, screenWidthDp,
-        screenHeightDp, localeScript, localeVariant, screenLayout2, screenConfigPad1, screenConfigPad2, unknown);
+    return new ResTable_config(
+        size,
+        mcc,
+        mnc,
+        language,
+        region,
+        orientation,
+        touchscreen,
+        density,
+        keyboard,
+        navigation,
+        inputFlags,
+        screenWidth,
+        screenHeight,
+        sdkVersion,
+        minorVersion,
+        screenLayout,
+        uiMode,
+        smallestScreenWidthDp,
+        screenWidthDp,
+        screenHeightDp,
+        localeScript,
+        localeVariant,
+        screenLayout2,
+        screenConfigPad1,
+        screenConfigPad2,
+        unknown);
   }
 
   /**
    * The different types of configs that can be present in a {@link ResTable_config}.
    *
-   * The ordering of these types is roughly the same as {@code #isBetterThan}, but is not
+   * <p>The ordering of these types is roughly the same as {@code #isBetterThan}, but is not
    * guaranteed to be the same.
    */
   public enum Type {
@@ -218,14 +244,14 @@ public class ResTable_config {
   }
 
   // screenLayout bits for layout direction.
-//  public static final int MASK_LAYOUTDIR = 0xC0;
+  //  public static final int MASK_LAYOUTDIR = 0xC0;
   public static final int SHIFT_LAYOUTDIR = 6;
   public static final int LAYOUTDIR_ANY = ACONFIGURATION_LAYOUTDIR_ANY << SHIFT_LAYOUTDIR;
   public static final int LAYOUTDIR_LTR = ACONFIGURATION_LAYOUTDIR_LTR << SHIFT_LAYOUTDIR;
   public static final int LAYOUTDIR_RTL = ACONFIGURATION_LAYOUTDIR_RTL << SHIFT_LAYOUTDIR;
 
   public static final int SCREENWIDTH_ANY = 0;
-//  public static final int MASK_SCREENSIZE = 0x0f;
+  //  public static final int MASK_SCREENSIZE = 0x0f;
   public static final int SCREENSIZE_ANY = ACONFIGURATION_SCREENSIZE_ANY;
   public static final int SCREENSIZE_SMALL = ACONFIGURATION_SCREENSIZE_SMALL;
   public static final int SCREENSIZE_NORMAL = ACONFIGURATION_SCREENSIZE_NORMAL;
@@ -240,7 +266,8 @@ public class ResTable_config {
   // uiMode bits for the night switch;
   public static final int MASK_UI_MODE_NIGHT = 0x30;
   public static final int SHIFT_UI_MODE_NIGHT = 4;
-  public static final int UI_MODE_NIGHT_ANY = ACONFIGURATION_UI_MODE_NIGHT_ANY << SHIFT_UI_MODE_NIGHT;
+  public static final int UI_MODE_NIGHT_ANY =
+      ACONFIGURATION_UI_MODE_NIGHT_ANY << SHIFT_UI_MODE_NIGHT;
 
   public static final int DENSITY_DEFAULT = ACONFIGURATION_DENSITY_DEFAULT;
   public static final int DENSITY_LOW = ACONFIGURATION_DENSITY_LOW;
@@ -253,7 +280,7 @@ public class ResTable_config {
   public static final int DENSITY_ANY = ACONFIGURATION_DENSITY_ANY;
   public static final int DENSITY_NONE = ACONFIGURATION_DENSITY_NONE;
 
-  public static final int TOUCHSCREEN_ANY  = ACONFIGURATION_TOUCHSCREEN_ANY;
+  public static final int TOUCHSCREEN_ANY = ACONFIGURATION_TOUCHSCREEN_ANY;
 
   public static final int MASK_KEYSHIDDEN = 0x0003;
   public static final byte KEYSHIDDEN_ANY = ACONFIGURATION_KEYSHIDDEN_ANY;
@@ -261,7 +288,7 @@ public class ResTable_config {
   public static final byte KEYSHIDDEN_YES = ACONFIGURATION_KEYSHIDDEN_YES;
   public static final byte KEYSHIDDEN_SOFT = ACONFIGURATION_KEYSHIDDEN_SOFT;
 
-  public static final int KEYBOARD_ANY  = ACONFIGURATION_KEYBOARD_ANY;
+  public static final int KEYBOARD_ANY = ACONFIGURATION_KEYBOARD_ANY;
 
   public static final int MASK_NAVHIDDEN = 0x000c;
   public static final int SHIFT_NAVHIDDEN = 2;
@@ -269,14 +296,15 @@ public class ResTable_config {
   public static final byte NAVHIDDEN_NO = ACONFIGURATION_NAVHIDDEN_NO << SHIFT_NAVHIDDEN;
   public static final byte NAVHIDDEN_YES = ACONFIGURATION_NAVHIDDEN_YES << SHIFT_NAVHIDDEN;
 
-  public static final int NAVIGATION_ANY  = ACONFIGURATION_NAVIGATION_ANY;
+  public static final int NAVIGATION_ANY = ACONFIGURATION_NAVIGATION_ANY;
 
   public static final int SCREENHEIGHT_ANY = 0;
 
   public static final int SDKVERSION_ANY = 0;
   public static final int MINORVERSION_ANY = 0;
 
-  // from https://github.com/google/android-arscblamer/blob/master/java/com/google/devrel/gmscore/tools/apk/arsc/ResourceConfiguration.java
+  // from
+  // https://github.com/google/android-arscblamer/blob/master/java/com/google/devrel/gmscore/tools/apk/arsc/ResourceConfiguration.java
   /** The below constants are from android.content.res.Configuration. */
   static final int COLOR_MODE_WIDE_COLOR_GAMUT_MASK = 0x03;
 
@@ -325,7 +353,7 @@ public class ResTable_config {
   static final int DENSITY_DPI_XHDPI = 320;
   static final int DENSITY_DPI_XXHDPI = 480;
   static final int DENSITY_DPI_XXXHDPI = 640;
-  public static final int DENSITY_DPI_ANY  = 0xFFFE;
+  public static final int DENSITY_DPI_ANY = 0xFFFE;
   public static final int DENSITY_DPI_NONE = 0xFFFF;
 
   private static final Map<Integer, String> DENSITY_DPI_VALUES;
@@ -347,7 +375,7 @@ public class ResTable_config {
 
   static final int KEYBOARD_NOKEYS = 1;
   static final int KEYBOARD_QWERTY = 2;
-  static final int KEYBOARD_12KEY  = 3;
+  static final int KEYBOARD_12KEY = 3;
 
   private static final Map<Integer, String> KEYBOARD_VALUES;
 
@@ -360,8 +388,8 @@ public class ResTable_config {
   }
 
   static final int KEYBOARDHIDDEN_MASK = 0x03;
-  static final int KEYBOARDHIDDEN_NO   = 1;
-  static final int KEYBOARDHIDDEN_YES  = 2;
+  static final int KEYBOARDHIDDEN_NO = 1;
+  static final int KEYBOARDHIDDEN_YES = 2;
   static final int KEYBOARDHIDDEN_SOFT = 3;
 
   private static final Map<Integer, String> KEYBOARDHIDDEN_VALUES;
@@ -374,10 +402,10 @@ public class ResTable_config {
     KEYBOARDHIDDEN_VALUES = Collections.unmodifiableMap(map);
   }
 
-  static final int NAVIGATION_NONAV     = 1;
-  static final int NAVIGATION_DPAD      = 2;
+  static final int NAVIGATION_NONAV = 1;
+  static final int NAVIGATION_DPAD = 2;
   static final int NAVIGATION_TRACKBALL = 3;
-  static final int NAVIGATION_WHEEL     = 4;
+  static final int NAVIGATION_WHEEL = 4;
 
   private static final Map<Integer, String> NAVIGATION_VALUES;
 
@@ -390,9 +418,9 @@ public class ResTable_config {
     NAVIGATION_VALUES = Collections.unmodifiableMap(map);
   }
 
-  static final int NAVIGATIONHIDDEN_MASK  = 0x0C;
-  static final int NAVIGATIONHIDDEN_NO    = 0x04;
-  static final int NAVIGATIONHIDDEN_YES   = 0x08;
+  static final int NAVIGATIONHIDDEN_MASK = 0x0C;
+  static final int NAVIGATIONHIDDEN_NO = 0x04;
+  static final int NAVIGATIONHIDDEN_YES = 0x08;
 
   private static final Map<Integer, String> NAVIGATIONHIDDEN_VALUES;
 
@@ -403,11 +431,11 @@ public class ResTable_config {
     NAVIGATIONHIDDEN_VALUES = Collections.unmodifiableMap(map);
   }
 
-  public static final int ORIENTATION_ANY  = ACONFIGURATION_ORIENTATION_ANY;
+  public static final int ORIENTATION_ANY = ACONFIGURATION_ORIENTATION_ANY;
   public static final int ORIENTATION_PORT = ACONFIGURATION_ORIENTATION_PORT;
   public static final int ORIENTATION_LAND = ACONFIGURATION_ORIENTATION_LAND;
   public static final int ORIENTATION_SQUARE = ACONFIGURATION_ORIENTATION_SQUARE;
-  static final int ORIENTATION_PORTRAIT  = 0x01;
+  static final int ORIENTATION_PORTRAIT = 0x01;
   static final int ORIENTATION_LANDSCAPE = 0x02;
 
   private static final Map<Integer, String> ORIENTATION_VALUES;
@@ -420,8 +448,8 @@ public class ResTable_config {
   }
 
   static final int SCREENLAYOUT_LAYOUTDIR_MASK = 0xC0;
-  static final int SCREENLAYOUT_LAYOUTDIR_LTR  = 0x40;
-  static final int SCREENLAYOUT_LAYOUTDIR_RTL  = 0x80;
+  static final int SCREENLAYOUT_LAYOUTDIR_LTR = 0x40;
+  static final int SCREENLAYOUT_LAYOUTDIR_RTL = 0x80;
 
   private static final Map<Integer, String> SCREENLAYOUT_LAYOUTDIR_VALUES;
 
@@ -439,8 +467,8 @@ public class ResTable_config {
   public static final int SCREENLONG_NO = ACONFIGURATION_SCREENLONG_NO << SHIFT_SCREENLONG;
   public static final int SCREENLONG_YES = ACONFIGURATION_SCREENLONG_YES << SHIFT_SCREENLONG;
   static final int SCREENLAYOUT_LONG_MASK = 0x30;
-  static final int SCREENLAYOUT_LONG_NO   = 0x10;
-  static final int SCREENLAYOUT_LONG_YES  = 0x20;
+  static final int SCREENLAYOUT_LONG_NO = 0x10;
+  static final int SCREENLAYOUT_LONG_YES = 0x20;
 
   private static final Map<Integer, String> SCREENLAYOUT_LONG_VALUES;
 
@@ -458,8 +486,8 @@ public class ResTable_config {
   public static final int SCREENROUND_YES = ACONFIGURATION_SCREENROUND_YES;
 
   static final int SCREENLAYOUT_ROUND_MASK = 0x03;
-  static final int SCREENLAYOUT_ROUND_NO   = 0x01;
-  static final int SCREENLAYOUT_ROUND_YES  = 0x02;
+  static final int SCREENLAYOUT_ROUND_NO = 0x01;
+  static final int SCREENLAYOUT_ROUND_YES = 0x02;
 
   private static final Map<Integer, String> SCREENLAYOUT_ROUND_VALUES;
 
@@ -470,10 +498,10 @@ public class ResTable_config {
     SCREENLAYOUT_ROUND_VALUES = Collections.unmodifiableMap(map);
   }
 
-  static final int SCREENLAYOUT_SIZE_MASK   = 0x0F;
-  static final int SCREENLAYOUT_SIZE_SMALL  = 0x01;
+  static final int SCREENLAYOUT_SIZE_MASK = 0x0F;
+  static final int SCREENLAYOUT_SIZE_SMALL = 0x01;
   static final int SCREENLAYOUT_SIZE_NORMAL = 0x02;
-  static final int SCREENLAYOUT_SIZE_LARGE  = 0x03;
+  static final int SCREENLAYOUT_SIZE_LARGE = 0x03;
   static final int SCREENLAYOUT_SIZE_XLARGE = 0x04;
 
   private static final Map<Integer, String> SCREENLAYOUT_SIZE_VALUES;
@@ -488,8 +516,8 @@ public class ResTable_config {
   }
 
   static final int TOUCHSCREEN_NOTOUCH = 1;
-  @Deprecated static final int TOUCHSCREEN_STYLUS  = 2;
-  public static final int TOUCHSCREEN_FINGER  = 3;
+  @Deprecated static final int TOUCHSCREEN_STYLUS = 2;
+  public static final int TOUCHSCREEN_FINGER = 3;
 
   private static final Map<Integer, String> TOUCHSCREEN_VALUES;
 
@@ -501,8 +529,8 @@ public class ResTable_config {
   }
 
   static final int UI_MODE_NIGHT_MASK = 0x30;
-  public static final int UI_MODE_NIGHT_NO   = 0x10;
-  static final int UI_MODE_NIGHT_YES  = 0x20;
+  public static final int UI_MODE_NIGHT_NO = 0x10;
+  static final int UI_MODE_NIGHT_YES = 0x20;
 
   private static final Map<Integer, String> UI_MODE_NIGHT_VALUES;
 
@@ -513,12 +541,12 @@ public class ResTable_config {
     UI_MODE_NIGHT_VALUES = Collections.unmodifiableMap(map);
   }
 
-  static final int UI_MODE_TYPE_MASK       = 0x0F;
-  static final int UI_MODE_TYPE_DESK       = 0x02;
-  static final int UI_MODE_TYPE_CAR        = 0x03;
+  static final int UI_MODE_TYPE_MASK = 0x0F;
+  static final int UI_MODE_TYPE_DESK = 0x02;
+  static final int UI_MODE_TYPE_CAR = 0x03;
   static final int UI_MODE_TYPE_TELEVISION = 0x04;
-  static final int UI_MODE_TYPE_APPLIANCE  = 0x05;
-  static final int UI_MODE_TYPE_WATCH      = 0x06;
+  static final int UI_MODE_TYPE_APPLIANCE = 0x05;
+  static final int UI_MODE_TYPE_WATCH = 0x06;
   static final int UI_MODE_TYPE_VR_HEADSET = 0x07;
 
   private static final Map<Integer, String> UI_MODE_TYPE_VALUES;
@@ -631,11 +659,33 @@ public class ResTable_config {
     if (sdkVersion == this.sdkVersion) {
       return this;
     }
-    return new ResTable_config(size, mcc, mnc, language, country,
-        orientation, touchscreen, density, keyboard, navigation, inputFlags,
-        screenWidth, screenHeight, sdkVersion, minorVersion, screenLayout, uiMode,
-        smallestScreenWidthDp, screenWidthDp, screenHeightDp, localeScript, localeVariant,
-        screenLayout2, colorMode, screenConfigPad2, unknown);
+    return new ResTable_config(
+        size,
+        mcc,
+        mnc,
+        language,
+        country,
+        orientation,
+        touchscreen,
+        density,
+        keyboard,
+        navigation,
+        inputFlags,
+        screenWidth,
+        screenHeight,
+        sdkVersion,
+        minorVersion,
+        screenLayout,
+        uiMode,
+        smallestScreenWidthDp,
+        screenWidthDp,
+        screenHeightDp,
+        localeScript,
+        localeVariant,
+        screenLayout2,
+        colorMode,
+        screenConfigPad2,
+        unknown);
   }
 
   public ResTable_config(ResTable_config other) {
@@ -667,13 +717,33 @@ public class ResTable_config {
     this.unknown = other.unknown;
   }
 
-
-  public ResTable_config(int size, int mcc, int mnc, byte[] language, byte[] country,
-      int orientation, int touchscreen, int density, int keyboard, int navigation, int inputFlags,
-      int screenWidth, int screenHeight, int sdkVersion, int minorVersion, int screenLayout,
-      int uiMode, int smallestScreenWidthDp, int screenWidthDp, int screenHeightDp,
-      byte[] localeScript, byte[] localeVariant, byte screenLayout2, byte colorMode,
-      short screenConfigPad2, byte[] unknown) {
+  public ResTable_config(
+      int size,
+      int mcc,
+      int mnc,
+      byte[] language,
+      byte[] country,
+      int orientation,
+      int touchscreen,
+      int density,
+      int keyboard,
+      int navigation,
+      int inputFlags,
+      int screenWidth,
+      int screenHeight,
+      int sdkVersion,
+      int minorVersion,
+      int screenLayout,
+      int uiMode,
+      int smallestScreenWidthDp,
+      int screenWidthDp,
+      int screenHeightDp,
+      byte[] localeScript,
+      byte[] localeVariant,
+      byte screenLayout2,
+      byte colorMode,
+      short screenConfigPad2,
+      byte[] unknown) {
     this.size = size;
     this.mcc = mcc;
     this.mnc = mnc;
@@ -775,28 +845,24 @@ public class ResTable_config {
   public final byte[] localeVariant;
 
   /** An extension to {@link #screenLayout}. Contains round/notround qualifier. */
-  public byte screenLayout2;        // Contains round/notround qualifier.
-  public byte colorMode;            // Wide-gamut, HDR, etc.
-  public short screenConfigPad2;    // Reserved padding.
+  public byte screenLayout2; // Contains round/notround qualifier.
+
+  public byte colorMode; // Wide-gamut, HDR, etc.
+  public short screenConfigPad2; // Reserved padding.
 
   /** Any remaining bytes in this resource configuration that are unaccounted for. */
   @SuppressWarnings("mutable")
   public byte[] unknown;
 
-
   /**
-   *     // An extension of screenConfig.
-   union {
-   struct {
-   uint8_t screenLayout2;      // Contains round/notround qualifier.
-   uint8_t screenConfigPad1;   // Reserved padding.
-   uint16_t screenConfigPad2;  // Reserved padding.
-   };
-   uint32_t screenConfig2;
-   };
+   * // An extension of screenConfig. union { struct { uint8_t screenLayout2; // Contains
+   * round/notround qualifier. uint8_t screenConfigPad1; // Reserved padding. uint16_t
+   * screenConfigPad2; // Reserved padding. }; uint32_t screenConfig2; };
    */
   private int screenConfig2() {
-    return ((screenLayout2 & 0xff) << 24) | ((colorMode * 0xff) << 16) | (screenConfigPad2 & 0xffff);
+    return ((screenLayout2 & 0xff) << 24)
+        | ((colorMode * 0xff) << 16)
+        | (screenConfigPad2 & 0xffff);
   }
 
   // If false and localeScript is set, it means that the script of the locale
@@ -811,19 +877,19 @@ public class ResTable_config {
   // Varies in length from 3 to 8 chars. Zero-filled value.
   byte[] localeNumberingSystem = new byte[8];
 
-// --------------------------------------------------------------------
-// --------------------------------------------------------------------
-// --------------------------------------------------------------------
+  // --------------------------------------------------------------------
+  // --------------------------------------------------------------------
+  // --------------------------------------------------------------------
 
-//  void copyFromDeviceNoSwap(final ResTable_config o) {
-//    final int size = dtohl(o.size);
-//    if (size >= sizeof(ResTable_config)) {
-//        *this = o;
-//    } else {
-//      memcpy(this, &o, size);
-//      memset(((uint8_t*)this)+size, 0, sizeof(ResTable_config)-size);
-//    }
-//  }
+  //  void copyFromDeviceNoSwap(final ResTable_config o) {
+  //    final int size = dtohl(o.size);
+  //    if (size >= sizeof(ResTable_config)) {
+  //        *this = o;
+  //    } else {
+  //      memcpy(this, &o, size);
+  //      memset(((uint8_t*)this)+size, 0, sizeof(ResTable_config)-size);
+  //    }
+  //  }
 
   @Nonnull
   private String unpackLanguageOrRegion(byte[] value, int base) {
@@ -841,8 +907,7 @@ public class ResTable_config {
     return new String(value, US_ASCII);
   }
 
-  /* static */ void packLanguageOrRegion(final String in, final byte base,
-      final byte[] out) {
+  /* static */ void packLanguageOrRegion(final String in, final byte base, final byte[] out) {
     if (in == null) {
       out[0] = 0;
       out[1] = 0;
@@ -876,22 +941,22 @@ public class ResTable_config {
     return unpackLanguageOrRegion(country, 0x30);
   }
 
-//  void copyFromDtoH(final ResTable_config o) {
-//    copyFromDeviceNoSwap(o);
-//    size = sizeof(ResTable_config);
-//    mcc = dtohs(mcc);
-//    mnc = dtohs(mnc);
-//    density = dtohs(density);
-//    screenWidth = dtohs(screenWidth);
-//    screenHeight = dtohs(screenHeight);
-//    sdkVersion = dtohs(sdkVersion);
-//    minorVersion = dtohs(minorVersion);
-//    smallestScreenWidthDp = dtohs(smallestScreenWidthDp);
-//    screenWidthDp = dtohs(screenWidthDp);
-//    screenHeightDp = dtohs(screenHeightDp);
-//  }
-
-//  void ResTable_config::copyFromDtoH(const ResTable_config& o) {
+  //  void copyFromDtoH(final ResTable_config o) {
+  //    copyFromDeviceNoSwap(o);
+  //    size = sizeof(ResTable_config);
+  //    mcc = dtohs(mcc);
+  //    mnc = dtohs(mnc);
+  //    density = dtohs(density);
+  //    screenWidth = dtohs(screenWidth);
+  //    screenHeight = dtohs(screenHeight);
+  //    sdkVersion = dtohs(sdkVersion);
+  //    minorVersion = dtohs(minorVersion);
+  //    smallestScreenWidthDp = dtohs(smallestScreenWidthDp);
+  //    screenWidthDp = dtohs(screenWidthDp);
+  //    screenHeightDp = dtohs(screenHeightDp);
+  //  }
+
+  //  void ResTable_config::copyFromDtoH(const ResTable_config& o) {
   static ResTable_config fromDtoH(final ResTable_config o) {
     return new ResTable_config(
         0 /*sizeof(ResTable_config)*/,
@@ -919,22 +984,21 @@ public class ResTable_config {
         o.screenLayout2,
         o.colorMode,
         o.screenConfigPad2,
-        o.unknown
-    );
+        o.unknown);
   }
 
   void swapHtoD() {
-//    size = htodl(size);
-//    mcc = htods(mcc);
-//    mnc = htods(mnc);
-//    density = htods(density);
-//    screenWidth = htods(screenWidth);
-//    screenHeight = htods(screenHeight);
-//    sdkVersion = htods(sdkVersion);
-//    minorVersion = htods(minorVersion);
-//    smallestScreenWidthDp = htods(smallestScreenWidthDp);
-//    screenWidthDp = htods(screenWidthDp);
-//    screenHeightDp = htods(screenHeightDp);
+    //    size = htodl(size);
+    //    mcc = htods(mcc);
+    //    mnc = htods(mnc);
+    //    density = htods(density);
+    //    screenWidth = htods(screenWidth);
+    //    screenHeight = htods(screenHeight);
+    //    sdkVersion = htods(sdkVersion);
+    //    minorVersion = htods(minorVersion);
+    //    smallestScreenWidthDp = htods(smallestScreenWidthDp);
+    //    screenWidthDp = htods(screenWidthDp);
+    //    screenHeightDp = htods(screenHeightDp);
   }
 
   static final int compareLocales(final ResTable_config l, final ResTable_config r) {
@@ -953,10 +1017,10 @@ public class ResTable_config {
     final byte emptyScript[] = {'\0', '\0', '\0', '\0'};
     final byte[] lScript = l.localeScriptWasComputed ? emptyScript : l.localeScript;
     final byte[] rScript = r.localeScriptWasComputed ? emptyScript : r.localeScript;
-//    int script = memcmp(lScript, rScript);
-//    if (script) {
-//      return script;
-//    }
+    //    int script = memcmp(lScript, rScript);
+    //    if (script) {
+    //      return script;
+    //    }
     int d = arrayCompare(lScript, rScript);
     if (d != 0) return d;
 
@@ -991,7 +1055,8 @@ public class ResTable_config {
   private static final int CONFIG_ORIENTATION = AConfiguration.ACONFIGURATION_ORIENTATION;
   private static final int CONFIG_DENSITY = AConfiguration.ACONFIGURATION_DENSITY;
   private static final int CONFIG_SCREEN_SIZE = AConfiguration.ACONFIGURATION_SCREEN_SIZE;
-  private static final int CONFIG_SMALLEST_SCREEN_SIZE = AConfiguration.ACONFIGURATION_SMALLEST_SCREEN_SIZE;
+  private static final int CONFIG_SMALLEST_SCREEN_SIZE =
+      AConfiguration.ACONFIGURATION_SMALLEST_SCREEN_SIZE;
   private static final int CONFIG_VERSION = AConfiguration.ACONFIGURATION_VERSION;
   private static final int CONFIG_SCREEN_LAYOUT = AConfiguration.ACONFIGURATION_SCREEN_LAYOUT;
   private static final int CONFIG_UI_MODE = AConfiguration.ACONFIGURATION_UI_MODE;
@@ -1008,16 +1073,20 @@ public class ResTable_config {
     if (orientation != o.orientation) diffs |= CONFIG_ORIENTATION;
     if (density != o.density) diffs |= CONFIG_DENSITY;
     if (touchscreen != o.touchscreen) diffs |= CONFIG_TOUCHSCREEN;
-    if (((inputFlags^o.inputFlags)&(MASK_KEYSHIDDEN|MASK_NAVHIDDEN)) != 0)
+    if (((inputFlags ^ o.inputFlags) & (MASK_KEYSHIDDEN | MASK_NAVHIDDEN)) != 0)
       diffs |= CONFIG_KEYBOARD_HIDDEN;
     if (keyboard != o.keyboard) diffs |= CONFIG_KEYBOARD;
     if (navigation != o.navigation) diffs |= CONFIG_NAVIGATION;
     if (screenSize() != o.screenSize()) diffs |= CONFIG_SCREEN_SIZE;
     if (version() != o.version()) diffs |= CONFIG_VERSION;
-    if ((screenLayout & MASK_LAYOUTDIR) != (o.screenLayout & MASK_LAYOUTDIR)) diffs |= CONFIG_LAYOUTDIR;
-    if ((screenLayout & ~MASK_LAYOUTDIR) != (o.screenLayout & ~MASK_LAYOUTDIR)) diffs |= CONFIG_SCREEN_LAYOUT;
-    if ((screenLayout2 & MASK_SCREENROUND) != (o.screenLayout2 & MASK_SCREENROUND)) diffs |= CONFIG_SCREEN_ROUND;
-    if ((colorMode & MASK_WIDE_COLOR_GAMUT) != (o.colorMode & MASK_WIDE_COLOR_GAMUT)) diffs |= CONFIG_COLOR_MODE;
+    if ((screenLayout & MASK_LAYOUTDIR) != (o.screenLayout & MASK_LAYOUTDIR))
+      diffs |= CONFIG_LAYOUTDIR;
+    if ((screenLayout & ~MASK_LAYOUTDIR) != (o.screenLayout & ~MASK_LAYOUTDIR))
+      diffs |= CONFIG_SCREEN_LAYOUT;
+    if ((screenLayout2 & MASK_SCREENROUND) != (o.screenLayout2 & MASK_SCREENROUND))
+      diffs |= CONFIG_SCREEN_ROUND;
+    if ((colorMode & MASK_WIDE_COLOR_GAMUT) != (o.colorMode & MASK_WIDE_COLOR_GAMUT))
+      diffs |= CONFIG_COLOR_MODE;
     if ((colorMode & MASK_HDR) != (o.colorMode & MASK_HDR)) diffs |= CONFIG_COLOR_MODE;
     if (uiMode != o.uiMode) diffs |= CONFIG_UI_MODE;
     if (smallestScreenWidthDp != o.smallestScreenWidthDp) diffs |= CONFIG_SMALLEST_SCREEN_SIZE;
@@ -1041,56 +1110,55 @@ public class ResTable_config {
   // scripts and variants.
   int getImportanceScoreOfLocale() {
     return (isTruthy(localeVariant[0]) ? 4 : 0)
-        + (isTruthy(localeScript[0]) && !localeScriptWasComputed ? 2: 0)
-        + (isTruthy(localeNumberingSystem[0]) ? 1: 0);
+        + (isTruthy(localeScript[0]) && !localeScriptWasComputed ? 2 : 0)
+        + (isTruthy(localeNumberingSystem[0]) ? 1 : 0);
   }
 
   int compare(final ResTable_config o) {
-       if (imsi() != o.imsi()) {
-       return (imsi() > o.imsi()) ? 1 : -1;
-   }
-
-   int diff = compareLocales(this, o);
-   if (diff < 0) {
-       return -1;
-   }
-   if (diff > 0) {
-       return 1;
-   }
-
-   if (screenType() != o.screenType()) {
-       return (screenType() > o.screenType()) ? 1 : -1;
-   }
-   if (input() != o.input()) {
-       return (input() > o.input()) ? 1 : -1;
-   }
-   if (screenSize() != o.screenSize()) {
-       return (screenSize() > o.screenSize()) ? 1 : -1;
-   }
-   if (version() != o.version()) {
-       return (version() > o.version()) ? 1 : -1;
-   }
-   if (screenLayout != o.screenLayout) {
-       return (screenLayout > o.screenLayout) ? 1 : -1;
-   }
-   if (screenLayout2 != o.screenLayout2) {
-       return (screenLayout2 > o.screenLayout2) ? 1 : -1;
-   }
-   if (colorMode != o.colorMode) {
-       return (colorMode > o.colorMode) ? 1 : -1;
-   }
-   if (uiMode != o.uiMode) {
-       return (uiMode > o.uiMode) ? 1 : -1;
-   }
-   if (smallestScreenWidthDp != o.smallestScreenWidthDp) {
-       return (smallestScreenWidthDp > o.smallestScreenWidthDp) ? 1 : -1;
-   }
-   if (screenSizeDp() != o.screenSizeDp()) {
-       return (screenSizeDp() > o.screenSizeDp()) ? 1 : -1;
-   }
-   return 0;
-  }
+    if (imsi() != o.imsi()) {
+      return (imsi() > o.imsi()) ? 1 : -1;
+    }
 
+    int diff = compareLocales(this, o);
+    if (diff < 0) {
+      return -1;
+    }
+    if (diff > 0) {
+      return 1;
+    }
+
+    if (screenType() != o.screenType()) {
+      return (screenType() > o.screenType()) ? 1 : -1;
+    }
+    if (input() != o.input()) {
+      return (input() > o.input()) ? 1 : -1;
+    }
+    if (screenSize() != o.screenSize()) {
+      return (screenSize() > o.screenSize()) ? 1 : -1;
+    }
+    if (version() != o.version()) {
+      return (version() > o.version()) ? 1 : -1;
+    }
+    if (screenLayout != o.screenLayout) {
+      return (screenLayout > o.screenLayout) ? 1 : -1;
+    }
+    if (screenLayout2 != o.screenLayout2) {
+      return (screenLayout2 > o.screenLayout2) ? 1 : -1;
+    }
+    if (colorMode != o.colorMode) {
+      return (colorMode > o.colorMode) ? 1 : -1;
+    }
+    if (uiMode != o.uiMode) {
+      return (uiMode > o.uiMode) ? 1 : -1;
+    }
+    if (smallestScreenWidthDp != o.smallestScreenWidthDp) {
+      return (smallestScreenWidthDp > o.smallestScreenWidthDp) ? 1 : -1;
+    }
+    if (screenSizeDp() != o.screenSizeDp()) {
+      return (screenSizeDp() > o.screenSizeDp()) ? 1 : -1;
+    }
+    return 0;
+  }
 
   /** Returns true if this is the default "any" configuration. */
   public final boolean isDefault() {
@@ -1116,8 +1184,7 @@ public class ResTable_config {
         && isZeroes(localeScript)
         && isZeroes(localeVariant)
         && screenLayout2 == 0
-        && colorMode == 0
-        ;
+        && colorMode == 0;
   }
 
   private boolean isZeroes(byte[] bytes1) {
@@ -1131,7 +1198,7 @@ public class ResTable_config {
 
   @Override
   public final String toString() {
-    if (isDefault()) {  // Prevent the default configuration from returning the empty string
+    if (isDefault()) { // Prevent the default configuration from returning the empty string
       return "default";
     }
     Collection<String> parts = toStringParts().values();
@@ -1142,29 +1209,31 @@ public class ResTable_config {
   /**
    * Returns a map of the configuration parts for {@link #toString}.
    *
-   * If a configuration part is not defined for this {@link ResTable_config}, its value
-   * will be the empty string.
+   * <p>If a configuration part is not defined for this {@link ResTable_config}, its value will be
+   * the empty string.
    */
   public final Map<Type, String> toStringParts() {
-    Map<Type, String> result = new LinkedHashMap<>();  // Preserve order for #toString().
+    Map<Type, String> result = new LinkedHashMap<>(); // Preserve order for #toString().
     result.put(Type.MCC, mcc != 0 ? "mcc" + mcc : "");
     result.put(Type.MNC, mnc != 0 ? "mnc" + mnc : "");
     result.put(Type.LANGUAGE_STRING, languageString());
     result.put(Type.LOCALE_SCRIPT_STRING, localeScriptString());
     result.put(Type.REGION_STRING, !regionString().isEmpty() ? "r" + regionString() : "");
     result.put(Type.LOCALE_VARIANT_STRING, localeVariantString());
-    result.put(Type.SCREEN_LAYOUT_DIRECTION,
+    result.put(
+        Type.SCREEN_LAYOUT_DIRECTION,
         getOrDefault(SCREENLAYOUT_LAYOUTDIR_VALUES, screenLayoutDirection(), ""));
-    result.put(Type.SMALLEST_SCREEN_WIDTH_DP,
+    result.put(
+        Type.SMALLEST_SCREEN_WIDTH_DP,
         smallestScreenWidthDp != 0 ? "sw" + smallestScreenWidthDp + "dp" : "");
     result.put(Type.SCREEN_WIDTH_DP, screenWidthDp != 0 ? "w" + screenWidthDp + "dp" : "");
     result.put(Type.SCREEN_HEIGHT_DP, screenHeightDp != 0 ? "h" + screenHeightDp + "dp" : "");
-    result.put(Type.SCREEN_LAYOUT_SIZE,
-        getOrDefault(SCREENLAYOUT_SIZE_VALUES, screenLayoutSize(), ""));
-    result.put(Type.SCREEN_LAYOUT_LONG,
-        getOrDefault(SCREENLAYOUT_LONG_VALUES, screenLayoutLong(), ""));
-    result.put(Type.SCREEN_LAYOUT_ROUND,
-        getOrDefault(SCREENLAYOUT_ROUND_VALUES, screenLayoutRound(), ""));
+    result.put(
+        Type.SCREEN_LAYOUT_SIZE, getOrDefault(SCREENLAYOUT_SIZE_VALUES, screenLayoutSize(), ""));
+    result.put(
+        Type.SCREEN_LAYOUT_LONG, getOrDefault(SCREENLAYOUT_LONG_VALUES, screenLayoutLong(), ""));
+    result.put(
+        Type.SCREEN_LAYOUT_ROUND, getOrDefault(SCREENLAYOUT_ROUND_VALUES, screenLayoutRound(), ""));
     result.put(Type.COLOR_MODE_HDR, getOrDefault(COLOR_MODE_HDR_VALUES, colorModeHdr(), ""));
     result.put(
         Type.COLOR_MODE_WIDE_COLOR_GAMUT,
@@ -1176,10 +1245,11 @@ public class ResTable_config {
     result.put(Type.TOUCHSCREEN, getOrDefault(TOUCHSCREEN_VALUES, touchscreen, ""));
     result.put(Type.KEYBOARD_HIDDEN, getOrDefault(KEYBOARDHIDDEN_VALUES, keyboardHidden(), ""));
     result.put(Type.KEYBOARD, getOrDefault(KEYBOARD_VALUES, keyboard, ""));
-    result.put(Type.NAVIGATION_HIDDEN,
-        getOrDefault(NAVIGATIONHIDDEN_VALUES, navigationHidden(), ""));
+    result.put(
+        Type.NAVIGATION_HIDDEN, getOrDefault(NAVIGATIONHIDDEN_VALUES, navigationHidden(), ""));
     result.put(Type.NAVIGATION, getOrDefault(NAVIGATION_VALUES, navigation, ""));
-    result.put(Type.SCREEN_SIZE,
+    result.put(
+        Type.SCREEN_SIZE,
         screenWidth != 0 || screenHeight != 0 ? screenWidth + "x" + screenHeight : "");
 
     String sdkVersion = "";
@@ -1200,13 +1270,11 @@ public class ResTable_config {
     return value != null ? value : defaultValue;
   }
 
-
   // constants for isBetterThan...
   public static final int MASK_LAYOUTDIR = SCREENLAYOUT_LAYOUTDIR_MASK;
   static final int MASK_SCREENSIZE = SCREENLAYOUT_SIZE_MASK;
 
-  public boolean isBetterThan(
-      ResTable_config o, ResTable_config requested) {
+  public boolean isBetterThan(ResTable_config o, ResTable_config requested) {
     if (isTruthy(requested)) {
       if (isTruthy(imsi()) || isTruthy(o.imsi())) {
         if ((mcc != o.mcc) && isTruthy(requested.mcc)) {
@@ -1223,7 +1291,7 @@ public class ResTable_config {
       }
 
       if (isTruthy(screenLayout) || isTruthy(o.screenLayout)) {
-        if (isTruthy((screenLayout^o.screenLayout) & MASK_LAYOUTDIR)
+        if (isTruthy((screenLayout ^ o.screenLayout) & MASK_LAYOUTDIR)
             && isTruthy(requested.screenLayout & MASK_LAYOUTDIR)) {
           int myLayoutDir = screenLayout & MASK_LAYOUTDIR;
           int oLayoutDir = o.screenLayout & MASK_LAYOUTDIR;
@@ -1265,7 +1333,7 @@ public class ResTable_config {
       }
 
       if (isTruthy(screenLayout) || isTruthy(o.screenLayout)) {
-        if (isTruthy((screenLayout^o.screenLayout) & MASK_SCREENSIZE)
+        if (isTruthy((screenLayout ^ o.screenLayout) & MASK_SCREENSIZE)
             && isTruthy(requested.screenLayout & MASK_SCREENSIZE)) {
           // A little backwards compatibility here: undefined is
           // considered equivalent to normal.  But only if the
@@ -1292,26 +1360,26 @@ public class ResTable_config {
             return fixedMySL > fixedOSL;
           }
         }
-        if (((screenLayout^o.screenLayout) & MASK_SCREENLONG) != 0
+        if (((screenLayout ^ o.screenLayout) & MASK_SCREENLONG) != 0
             && isTruthy(requested.screenLayout & MASK_SCREENLONG)) {
           return isTruthy(screenLayout & MASK_SCREENLONG);
         }
       }
 
       if (isTruthy(screenLayout2) || isTruthy(o.screenLayout2)) {
-        if (((screenLayout2^o.screenLayout2) & MASK_SCREENROUND) != 0 &&
-            isTruthy(requested.screenLayout2 & MASK_SCREENROUND)) {
+        if (((screenLayout2 ^ o.screenLayout2) & MASK_SCREENROUND) != 0
+            && isTruthy(requested.screenLayout2 & MASK_SCREENROUND)) {
           return isTruthy(screenLayout2 & MASK_SCREENROUND);
         }
       }
 
       if (isTruthy(colorMode) || isTruthy(o.colorMode)) {
-        if (((colorMode^o.colorMode) & MASK_WIDE_COLOR_GAMUT) != 0 &&
-            isTruthy((requested.colorMode & MASK_WIDE_COLOR_GAMUT))) {
+        if (((colorMode ^ o.colorMode) & MASK_WIDE_COLOR_GAMUT) != 0
+            && isTruthy((requested.colorMode & MASK_WIDE_COLOR_GAMUT))) {
           return isTruthy(colorMode & MASK_WIDE_COLOR_GAMUT);
         }
-        if (((colorMode^o.colorMode) & MASK_HDR) != 0 &&
-            isTruthy((requested.colorMode & MASK_HDR))) {
+        if (((colorMode ^ o.colorMode) & MASK_HDR) != 0
+            && isTruthy((requested.colorMode & MASK_HDR))) {
           return isTruthy(colorMode & MASK_HDR);
         }
       }
@@ -1321,11 +1389,11 @@ public class ResTable_config {
       }
 
       if (isTruthy(uiMode) || isTruthy(o.uiMode)) {
-        if (((uiMode^o.uiMode) & MASK_UI_MODE_TYPE) != 0
+        if (((uiMode ^ o.uiMode) & MASK_UI_MODE_TYPE) != 0
             && isTruthy(requested.uiMode & MASK_UI_MODE_TYPE)) {
           return isTruthy(uiMode & MASK_UI_MODE_TYPE);
         }
-        if (((uiMode^o.uiMode) & MASK_UI_MODE_NIGHT) != 0
+        if (((uiMode ^ o.uiMode) & MASK_UI_MODE_NIGHT) != 0
             && isTruthy(requested.uiMode & MASK_UI_MODE_NIGHT)) {
           return isTruthy(uiMode & MASK_UI_MODE_NIGHT);
         }
@@ -1345,8 +1413,7 @@ public class ResTable_config {
           }
 
           int requestedDensity = requested.density;
-          if (requested.density == 0 ||
-              requested.density == DENSITY_ANY) {
+          if (requested.density == 0 || requested.density == DENSITY_ANY) {
             requestedDensity = DENSITY_MEDIUM;
           }
 
@@ -1387,11 +1454,10 @@ public class ResTable_config {
       }
 
       if (isTruthy(input()) || isTruthy(o.input())) {
-            final int keysHidden = inputFlags & MASK_KEYSHIDDEN;
-            final int oKeysHidden = o.inputFlags & MASK_KEYSHIDDEN;
+        final int keysHidden = inputFlags & MASK_KEYSHIDDEN;
+        final int oKeysHidden = o.inputFlags & MASK_KEYSHIDDEN;
         if (keysHidden != oKeysHidden) {
-                final int reqKeysHidden =
-              requested.inputFlags & MASK_KEYSHIDDEN;
+          final int reqKeysHidden = requested.inputFlags & MASK_KEYSHIDDEN;
           if (isTruthy(reqKeysHidden)) {
 
             if (keysHidden == 0) return false;
@@ -1404,11 +1470,10 @@ public class ResTable_config {
           }
         }
 
-            final int navHidden = inputFlags & MASK_NAVHIDDEN;
-            final int oNavHidden = o.inputFlags & MASK_NAVHIDDEN;
+        final int navHidden = inputFlags & MASK_NAVHIDDEN;
+        final int oNavHidden = o.inputFlags & MASK_NAVHIDDEN;
         if (navHidden != oNavHidden) {
-                final int reqNavHidden =
-              requested.inputFlags & MASK_NAVHIDDEN;
+          final int reqNavHidden = requested.inputFlags & MASK_NAVHIDDEN;
           if (isTruthy(reqNavHidden)) {
 
             if (navHidden == 0) return false;
@@ -1453,8 +1518,7 @@ public class ResTable_config {
           return (sdkVersion > o.sdkVersion);
         }
 
-        if ((minorVersion != o.minorVersion) &&
-            isTruthy(requested.minorVersion)) {
+        if ((minorVersion != o.minorVersion) && isTruthy(requested.minorVersion)) {
           return isTruthy(minorVersion);
         }
       }
@@ -1464,14 +1528,14 @@ public class ResTable_config {
     return isMoreSpecificThan(o);
   }
 
-/*
-  boolean match(final ResTable_config settings) {
-    System.out.println(this + ".match(" + settings + ")");
-    boolean result = match_(settings);
-    System.out.println("    -> " + result);
-    return result;
-  }
-*/
+  /*
+    boolean match(final ResTable_config settings) {
+      System.out.println(this + ".match(" + settings + ")");
+      boolean result = match_(settings);
+      System.out.println("    -> " + result);
+      return result;
+    }
+  */
 
   public boolean match(final ResTable_config settings) {
     if (imsi() != 0) {
@@ -1530,47 +1594,46 @@ public class ResTable_config {
     }
 
     if (screenConfig() != 0) {
-        final int layoutDir = screenLayout&MASK_LAYOUTDIR;
-        final int setLayoutDir = settings.screenLayout&MASK_LAYOUTDIR;
+      final int layoutDir = screenLayout & MASK_LAYOUTDIR;
+      final int setLayoutDir = settings.screenLayout & MASK_LAYOUTDIR;
       if (layoutDir != 0 && layoutDir != setLayoutDir) {
         return false;
       }
 
-        final int screenSize = screenLayout&MASK_SCREENSIZE;
-        final int setScreenSize = settings.screenLayout&MASK_SCREENSIZE;
+      final int screenSize = screenLayout & MASK_SCREENSIZE;
+      final int setScreenSize = settings.screenLayout & MASK_SCREENSIZE;
       // Any screen sizes for larger screens than the setting do not
       // match.
       if (screenSize != 0 && screenSize > setScreenSize) {
         return false;
       }
 
-        final int screenLong = screenLayout&MASK_SCREENLONG;
-        final int setScreenLong = settings.screenLayout&MASK_SCREENLONG;
+      final int screenLong = screenLayout & MASK_SCREENLONG;
+      final int setScreenLong = settings.screenLayout & MASK_SCREENLONG;
       if (screenLong != 0 && screenLong != setScreenLong) {
         return false;
       }
 
-        final int uiModeType = uiMode&MASK_UI_MODE_TYPE;
-        final int setUiModeType = settings.uiMode&MASK_UI_MODE_TYPE;
+      final int uiModeType = uiMode & MASK_UI_MODE_TYPE;
+      final int setUiModeType = settings.uiMode & MASK_UI_MODE_TYPE;
       if (uiModeType != 0 && uiModeType != setUiModeType) {
         return false;
       }
 
-        final int uiModeNight = uiMode&MASK_UI_MODE_NIGHT;
-        final int setUiModeNight = settings.uiMode&MASK_UI_MODE_NIGHT;
+      final int uiModeNight = uiMode & MASK_UI_MODE_NIGHT;
+      final int setUiModeNight = settings.uiMode & MASK_UI_MODE_NIGHT;
       if (uiModeNight != 0 && uiModeNight != setUiModeNight) {
         return false;
       }
 
-      if (smallestScreenWidthDp != 0
-          && smallestScreenWidthDp > settings.smallestScreenWidthDp) {
+      if (smallestScreenWidthDp != 0 && smallestScreenWidthDp > settings.smallestScreenWidthDp) {
         return false;
       }
     }
 
     if (screenConfig2() != 0) {
-        final int screenRound = screenLayout2 & MASK_SCREENROUND;
-        final int setScreenRound = settings.screenLayout2 & MASK_SCREENROUND;
+      final int screenRound = screenLayout2 & MASK_SCREENROUND;
+      final int setScreenRound = settings.screenLayout2 & MASK_SCREENROUND;
       if (screenRound != 0 && screenRound != setScreenRound) {
         return false;
       }
@@ -1591,15 +1654,13 @@ public class ResTable_config {
     if (screenSizeDp() != 0) {
       if (screenWidthDp != 0 && screenWidthDp > settings.screenWidthDp) {
         if (kDebugTableSuperNoisy) {
-          ALOGI("Filtering out width %d in requested %d", screenWidthDp,
-              settings.screenWidthDp);
+          ALOGI("Filtering out width %d in requested %d", screenWidthDp, settings.screenWidthDp);
         }
         return false;
       }
       if (screenHeightDp != 0 && screenHeightDp > settings.screenHeightDp) {
         if (kDebugTableSuperNoisy) {
-          ALOGI("Filtering out height %d in requested %d", screenHeightDp,
-              settings.screenHeightDp);
+          ALOGI("Filtering out height %d in requested %d", screenHeightDp, settings.screenHeightDp);
         }
         return false;
       }
@@ -1614,8 +1675,8 @@ public class ResTable_config {
       }
     }
     if (input() != 0) {
-        final int keysHidden = inputFlags&MASK_KEYSHIDDEN;
-        final int setKeysHidden = settings.inputFlags&MASK_KEYSHIDDEN;
+      final int keysHidden = inputFlags & MASK_KEYSHIDDEN;
+      final int setKeysHidden = settings.inputFlags & MASK_KEYSHIDDEN;
       if (keysHidden != 0 && keysHidden != setKeysHidden) {
         // For compatibility, we count a request for KEYSHIDDEN_NO as also
         // matching the more recent KEYSHIDDEN_SOFT.  Basically
@@ -1630,8 +1691,8 @@ public class ResTable_config {
           return false;
         }
       }
-        final int navHidden = inputFlags&MASK_NAVHIDDEN;
-        final int setNavHidden = settings.inputFlags&MASK_NAVHIDDEN;
+      final int navHidden = inputFlags & MASK_NAVHIDDEN;
+      final int setNavHidden = settings.inputFlags & MASK_NAVHIDDEN;
       if (navHidden != 0 && navHidden != setNavHidden) {
         return false;
       }
@@ -1661,66 +1722,67 @@ public class ResTable_config {
     return true;
   }
 
-//  void appendDirLocale(String8& out) const {
-//    if (!language[0]) {
-//      return;
-//    }
-//    const bool scriptWasProvided = localeScript[0] != '\0' && !localeScriptWasComputed;
-//    if (!scriptWasProvided && !localeVariant[0] && !localeNumberingSystem[0]) {
-//      // Legacy format.
-//      if (out.size() > 0) {
-//        out.append("-");
-//      }
-//
-//      char buf[4];
-//      size_t len = unpackLanguage(buf);
-//      out.append(buf, len);
-//
-//      if (country[0]) {
-//        out.append("-r");
-//        len = unpackRegion(buf);
-//        out.append(buf, len);
-//      }
-//      return;
-//    }
-//
-//    // We are writing the modified BCP 47 tag.
-//    // It starts with 'b+' and uses '+' as a separator.
-//
-//    if (out.size() > 0) {
-//      out.append("-");
-//    }
-//    out.append("b+");
-//
-//    char buf[4];
-//    size_t len = unpackLanguage(buf);
-//    out.append(buf, len);
-//
-//    if (scriptWasProvided) {
-//      out.append("+");
-//      out.append(localeScript, sizeof(localeScript));
-//    }
-//
-//    if (country[0]) {
-//      out.append("+");
-//      len = unpackRegion(buf);
-//      out.append(buf, len);
-//    }
-//
-//    if (localeVariant[0]) {
-//      out.append("+");
-//      out.append(localeVariant, strnlen(localeVariant, sizeof(localeVariant)));
-//    }
-//
-//    if (localeNumberingSystem[0]) {
-//      out.append("+u+nu+");
-//      out.append(localeNumberingSystem,
-//                 strnlen(localeNumberingSystem, sizeof(localeNumberingSystem)));
-//    }
-//  }
+  //  void appendDirLocale(String8& out) const {
+  //    if (!language[0]) {
+  //      return;
+  //    }
+  //    const bool scriptWasProvided = localeScript[0] != '\0' && !localeScriptWasComputed;
+  //    if (!scriptWasProvided && !localeVariant[0] && !localeNumberingSystem[0]) {
+  //      // Legacy format.
+  //      if (out.size() > 0) {
+  //        out.append("-");
+  //      }
+  //
+  //      char buf[4];
+  //      size_t len = unpackLanguage(buf);
+  //      out.append(buf, len);
+  //
+  //      if (country[0]) {
+  //        out.append("-r");
+  //        len = unpackRegion(buf);
+  //        out.append(buf, len);
+  //      }
+  //      return;
+  //    }
+  //
+  //    // We are writing the modified BCP 47 tag.
+  //    // It starts with 'b+' and uses '+' as a separator.
+  //
+  //    if (out.size() > 0) {
+  //      out.append("-");
+  //    }
+  //    out.append("b+");
+  //
+  //    char buf[4];
+  //    size_t len = unpackLanguage(buf);
+  //    out.append(buf, len);
+  //
+  //    if (scriptWasProvided) {
+  //      out.append("+");
+  //      out.append(localeScript, sizeof(localeScript));
+  //    }
+  //
+  //    if (country[0]) {
+  //      out.append("+");
+  //      len = unpackRegion(buf);
+  //      out.append(buf, len);
+  //    }
+  //
+  //    if (localeVariant[0]) {
+  //      out.append("+");
+  //      out.append(localeVariant, strnlen(localeVariant, sizeof(localeVariant)));
+  //    }
+  //
+  //    if (localeNumberingSystem[0]) {
+  //      out.append("+u+nu+");
+  //      out.append(localeNumberingSystem,
+  //                 strnlen(localeNumberingSystem, sizeof(localeNumberingSystem)));
+  //    }
+  //  }
 
   // returns string as return value instead of by mutating first arg
-  // void ResTable_config::getBcp47Locale(char str[RESTABLE_MAX_LOCALE_LEN], bool canonicalize) const {
+  // void ResTable_config::getBcp47Locale(char str[RESTABLE_MAX_LOCALE_LEN], bool canonicalize)
+  // const {
   String getBcp47Locale(boolean canonicalize) {
     StringBuilder str = new StringBuilder();
 
@@ -1734,7 +1796,7 @@ public class ResTable_config {
       if (canonicalize && areIdentical(language, kTagalog)) {
         // Replace Tagalog with Filipino if we are canonicalizing
         str.setLength(0);
-        str.append("fil");// 3-letter code for Filipino
+        str.append("fil"); // 3-letter code for Filipino
       } else {
         str.append(unpackLanguage());
       }
@@ -1778,7 +1840,9 @@ public class ResTable_config {
   }
 
   enum State {
-    BASE, UNICODE_EXTENSION, IGNORE_THE_REST
+    BASE,
+    UNICODE_EXTENSION,
+    IGNORE_THE_REST
   }
 
   enum UnicodeState {
@@ -1807,8 +1871,8 @@ public class ResTable_config {
     }
   }
 
-  static LocaleParserState assignLocaleComponent(ResTable_config config,
-      final String start, int size, LocaleParserState state) {
+  static LocaleParserState assignLocaleComponent(
+      ResTable_config config, final String start, int size, LocaleParserState state) {
 
     /* It is assumed that this function is not invoked with state.parserState
      * set to IGNORE_THE_REST. The condition is checked by setBcp47Locale
@@ -1821,12 +1885,12 @@ public class ResTable_config {
           state.parserState = State.IGNORE_THE_REST;
           break;
         case 2:
-          if (state.unicodeState == UnicodeState.NO_KEY ||
-              state.unicodeState == UnicodeState.EXPECT_KEY) {
+          if (state.unicodeState == UnicodeState.NO_KEY
+              || state.unicodeState == UnicodeState.EXPECT_KEY) {
             /* Analyze Unicode extension key. Currently only 'nu'
              * (numbering system) is supported.*/
-            if ((start.charAt(0) == 'n' || start.charAt(0) == 'N') &&
-                (start.charAt(1) == 'u' || start.charAt(1) == 'U')) {
+            if ((start.charAt(0) == 'n' || start.charAt(0) == 'N')
+                && (start.charAt(1) == 'u' || start.charAt(1) == 'U')) {
               state.unicodeState = UnicodeState.NUMBERING_SYSTEM;
             } else {
               state.unicodeState = UnicodeState.IGNORE_KEY;
@@ -1879,9 +1943,10 @@ public class ResTable_config {
         state.parserState = State.IGNORE_THE_REST;
         break;
       case 1:
-        state.parserState = (start.charAt(0) == 'u' || start.charAt(0) == 'U')
-            ? State.UNICODE_EXTENSION
-            : State.IGNORE_THE_REST;
+        state.parserState =
+            (start.charAt(0) == 'u' || start.charAt(0) == 'U')
+                ? State.UNICODE_EXTENSION
+                : State.IGNORE_THE_REST;
         break;
       case 2:
       case 3:
@@ -1948,7 +2013,7 @@ public class ResTable_config {
   }
 
   void clearLocale() {
-//    locale = 0;
+    //    locale = 0;
     clear(language);
     clear(country);
 
@@ -1967,59 +2032,31 @@ public class ResTable_config {
     }
   }
 
-
   /**
-   *     union {
-   struct {
-   // Mobile country code (from SIM).  0 means "any".
-   uint16_t mcc;
-   // Mobile network code (from SIM).  0 means "any".
-   uint16_t mnc;
-   };
-   uint32_t imsi;
-   };
+   * union { struct { // Mobile country code (from SIM). 0 means "any". uint16_t mcc; // Mobile
+   * network code (from SIM). 0 means "any". uint16_t mnc; }; uint32_t imsi; };
    */
   private int imsi() {
     return ((mcc & 0xffff) << 16) | (mnc & 0xffff);
   }
 
-  /**
-   *     union {
-   struct {
-   uint16_t screenWidth;
-   uint16_t screenHeight;
-   };
-   uint32_t screenSize;
-   };
-   */
+  /** union { struct { uint16_t screenWidth; uint16_t screenHeight; }; uint32_t screenSize; }; */
   private int screenSize() {
     return ((screenWidth & 0xffff) << 16) | (screenHeight & 0xffff);
   }
 
-
   /**
-   union {
-   struct {
-   uint8_t screenLayout;
-   uint8_t uiMode;
-   uint16_t smallestScreenWidthDp;
-   };
-   uint32_t screenConfig;
-   };
+   * union { struct { uint8_t screenLayout; uint8_t uiMode; uint16_t smallestScreenWidthDp; };
+   * uint32_t screenConfig; };
    */
   private int screenConfig() {
-    return ((screenLayout & 0xff) << 24) | ((uiMode * 0xff) << 16) | (smallestScreenWidthDp & 0xffff);
+    return ((screenLayout & 0xff) << 24)
+        | ((uiMode * 0xff) << 16)
+        | (smallestScreenWidthDp & 0xffff);
   }
 
-
   /**
-   *     union {
-   struct {
-   uint16_t screenWidthDp;
-   uint16_t screenHeightDp;
-   };
-   uint32_t screenSizeDp;
-   };
+   * union { struct { uint16_t screenWidthDp; uint16_t screenHeightDp; }; uint32_t screenSizeDp; };
    */
   private int screenSizeDp() {
     // screenWidthDp and screenHeightDp are really shorts...
@@ -2027,30 +2064,16 @@ public class ResTable_config {
   }
 
   /**
-     union {
-     struct {
-     uint8_t orientation;
-     uint8_t touchscreen;
-     uint16_t density;
-     };
-     uint32_t screenType;
-     };
+   * union { struct { uint8_t orientation; uint8_t touchscreen; uint16_t density; }; uint32_t
+   * screenType; };
    */
   private int screenType() {
     return ((orientation & 0xff) << 24) | ((touchscreen & 0xff) << 16) | (density & 0xffff);
   }
 
   /**
-   *
-   union {
-   struct {
-   uint8_t keyboard;
-   uint8_t navigation;
-   uint8_t inputFlags;
-   uint8_t inputPad0;
-   };
-   uint32_t input;
-   };
+   * union { struct { uint8_t keyboard; uint8_t navigation; uint8_t inputFlags; uint8_t inputPad0;
+   * }; uint32_t input; };
    */
   private int input() {
     // TODO is Pad Zeros?
@@ -2058,66 +2081,36 @@ public class ResTable_config {
   }
 
   /**
-   *     union {
-   struct {
-   uint16_t sdkVersion;
-   // For now minorVersion must always be 0!!!  Its meaning
-   // is currently undefined.
-   uint16_t minorVersion;
-   };
-   uint32_t version;
-   };
+   * union { struct { uint16_t sdkVersion; // For now minorVersion must always be 0!!! Its meaning
+   * // is currently undefined. uint16_t minorVersion; }; uint32_t version; };
    */
   private int version() {
     return ((sdkVersion & 0xffff) << 16) | (minorVersion & 0xffff);
   }
 
   /**
-   union {
-   struct {
-   // This field can take three different forms:
-   // - \0\0 means "any".
-   //
-   // - Two 7 bit ascii values interpreted as ISO-639-1 language
-   //   codes ('fr', 'en' etc. etc.). The high bit for both bytes is
-   //   zero.
-   //
-   // - A single 16 bit little endian packed value representing an
-   //   ISO-639-2 3 letter language code. This will be of the form:
-   //
-   //   {1, t, t, t, t, t, s, s, s, s, s, f, f, f, f, f}
-   //
-   //   bit[0, 4] = first letter of the language code
-   //   bit[5, 9] = second letter of the language code
-   //   bit[10, 14] = third letter of the language code.
-   //   bit[15] = 1 always
-   //
-   // For backwards compatibility, languages that have unambiguous
-   // two letter codes are represented in that format.
-   //
-   // The layout is always bigendian irrespective of the runtime
-   // architecture.
-   char language[2];
-
-   // This field can take three different forms:
-   // - \0\0 means "any".
-   //
-   // - Two 7 bit ascii values interpreted as 2 letter country
-   //   codes ('US', 'GB' etc.). The high bit for both bytes is zero.
-   //
-   // - An UN M.49 3 digit country code. For simplicity, these are packed
-   //   in the same manner as the language codes, though we should need
-   //   only 10 bits to represent them, instead of the 15.
-   //
-   // The layout is always bigendian irrespective of the runtime
-   // architecture.
-   char country[2];
-   };
-   uint32_t locale;
-   };
+   * union { struct { // This field can take three different forms: // - \0\0 means "any". // // -
+   * Two 7 bit ascii values interpreted as ISO-639-1 language // codes ('fr', 'en' etc. etc.). The
+   * high bit for both bytes is // zero. // // - A single 16 bit little endian packed value
+   * representing an // ISO-639-2 3 letter language code. This will be of the form: // // {1, t, t,
+   * t, t, t, s, s, s, s, s, f, f, f, f, f} // // bit[0, 4] = first letter of the language code //
+   * bit[5, 9] = second letter of the language code // bit[10, 14] = third letter of the language
+   * code. // bit[15] = 1 always // // For backwards compatibility, languages that have unambiguous
+   * // two letter codes are represented in that format. // // The layout is always bigendian
+   * irrespective of the runtime // architecture. char language[2];
+   *
+   * <p>// This field can take three different forms: // - \0\0 means "any". // // - Two 7 bit ascii
+   * values interpreted as 2 letter country // codes ('US', 'GB' etc.). The high bit for both bytes
+   * is zero. // // - An UN M.49 3 digit country code. For simplicity, these are packed // in the
+   * same manner as the language codes, though we should need // only 10 bits to represent them,
+   * instead of the 15. // // The layout is always bigendian irrespective of the runtime //
+   * architecture. char country[2]; }; uint32_t locale; };
    */
   int locale() {
-    return ((language[0] & 0xff) << 24) | ((language[1] & 0xff) << 16) | ((country[0] & 0xff) << 8) | (country[1] & 0xff);
+    return ((language[0] & 0xff) << 24)
+        | ((language[1] & 0xff) << 16)
+        | ((country[0] & 0xff) << 8)
+        | (country[1] & 0xff);
   }
 
   private boolean isLocaleBetterThan(ResTable_config o, ResTable_config requested) {
@@ -2186,9 +2179,9 @@ public class ResTable_config {
     // check the country and variant.
 
     // See if any of the regions is better than the other.
-    final int region_comparison = localeDataCompareRegions(
-        country, o.country,
-        requested.language, str(requested.localeScript), requested.country);
+    final int region_comparison =
+        localeDataCompareRegions(
+            country, o.country, requested.language, str(requested.localeScript), requested.country);
     if (region_comparison != 0) {
       return (region_comparison > 0);
     }
@@ -2201,15 +2194,13 @@ public class ResTable_config {
     }
 
     // The variants are the same, try numbering system.
-    boolean localeNumsysMatches = arrayCompare(localeNumberingSystem,
-                                             requested.localeNumberingSystem
-                                             ) == 0;
-    boolean otherNumsysMatches = arrayCompare(o.localeNumberingSystem,
-                                            requested.localeNumberingSystem
-                                            ) == 0;
+    boolean localeNumsysMatches =
+        arrayCompare(localeNumberingSystem, requested.localeNumberingSystem) == 0;
+    boolean otherNumsysMatches =
+        arrayCompare(o.localeNumberingSystem, requested.localeNumberingSystem) == 0;
 
     if (localeNumsysMatches != otherNumsysMatches) {
-        return localeNumsysMatches;
+      return localeNumsysMatches;
     }
 
     // Finally, the languages, although equivalent, may still be different
@@ -2228,13 +2219,13 @@ public class ResTable_config {
   }
 
   private boolean langsAreEquivalent(final byte[] lang1, final byte[] lang2) {
-    return areIdentical(lang1, lang2) ||
-        (areIdentical(lang1, kTagalog) && areIdentical(lang2, kFilipino)) ||
-        (areIdentical(lang1, kFilipino) && areIdentical(lang2, kTagalog));
+    return areIdentical(lang1, lang2)
+        || (areIdentical(lang1, kTagalog) && areIdentical(lang2, kFilipino))
+        || (areIdentical(lang1, kFilipino) && areIdentical(lang2, kTagalog));
   }
 
   // Checks if two language or country codes are identical
-  private boolean  areIdentical(final byte[] code1, final byte[] code2) {
+  private boolean areIdentical(final byte[] code1, final byte[] code2) {
     return code1[0] == code2[0] && code1[1] == code2[1];
   }
 
@@ -2276,7 +2267,7 @@ public class ResTable_config {
       }
     }
     if (isTruthy(screenLayout) || isTruthy(o.screenLayout)) {
-      if (((screenLayout^o.screenLayout) & MASK_LAYOUTDIR) != 0) {
+      if (((screenLayout ^ o.screenLayout) & MASK_LAYOUTDIR) != 0) {
         if (!isTruthy((screenLayout & MASK_LAYOUTDIR))) return false;
         if (!isTruthy((o.screenLayout & MASK_LAYOUTDIR))) return true;
       }
@@ -2298,28 +2289,28 @@ public class ResTable_config {
       }
     }
     if (isTruthy(screenLayout) || isTruthy(o.screenLayout)) {
-      if (((screenLayout^o.screenLayout) & MASK_SCREENSIZE) != 0) {
+      if (((screenLayout ^ o.screenLayout) & MASK_SCREENSIZE) != 0) {
         if (!isTruthy((screenLayout & MASK_SCREENSIZE))) return false;
         if (!isTruthy((o.screenLayout & MASK_SCREENSIZE))) return true;
       }
-      if (((screenLayout^o.screenLayout) & MASK_SCREENLONG) != 0) {
+      if (((screenLayout ^ o.screenLayout) & MASK_SCREENLONG) != 0) {
         if (!isTruthy((screenLayout & MASK_SCREENLONG))) return false;
         if (!isTruthy((o.screenLayout & MASK_SCREENLONG))) return true;
       }
     }
     if (isTruthy(screenLayout2) || isTruthy(o.screenLayout2)) {
-      if (((screenLayout2^o.screenLayout2) & MASK_SCREENROUND) != 0) {
+      if (((screenLayout2 ^ o.screenLayout2) & MASK_SCREENROUND) != 0) {
         if (!isTruthy((screenLayout2 & MASK_SCREENROUND))) return false;
         if (!isTruthy((o.screenLayout2 & MASK_SCREENROUND))) return true;
       }
     }
 
     if (isTruthy(colorMode) || isTruthy(o.colorMode)) {
-      if (((colorMode^o.colorMode) & MASK_HDR) != 0) {
+      if (((colorMode ^ o.colorMode) & MASK_HDR) != 0) {
         if (!isTruthy((colorMode & MASK_HDR))) return false;
         if (!isTruthy((o.colorMode & MASK_HDR))) return true;
       }
-      if (((colorMode^o.colorMode) & MASK_WIDE_COLOR_GAMUT) != 0) {
+      if (((colorMode ^ o.colorMode) & MASK_WIDE_COLOR_GAMUT) != 0) {
         if (!isTruthy((colorMode & MASK_WIDE_COLOR_GAMUT))) return false;
         if (!isTruthy((o.colorMode & MASK_WIDE_COLOR_GAMUT))) return true;
       }
@@ -2330,11 +2321,11 @@ public class ResTable_config {
       if (!isTruthy(o.orientation)) return true;
     }
     if (isTruthy(uiMode) || isTruthy(o.uiMode)) {
-      if (((uiMode^o.uiMode) & MASK_UI_MODE_TYPE) != 0) {
+      if (((uiMode ^ o.uiMode) & MASK_UI_MODE_TYPE) != 0) {
         if (!isTruthy((uiMode & MASK_UI_MODE_TYPE))) return false;
         if (!isTruthy((o.uiMode & MASK_UI_MODE_TYPE))) return true;
       }
-      if (((uiMode^o.uiMode) & MASK_UI_MODE_NIGHT) != 0) {
+      if (((uiMode ^ o.uiMode) & MASK_UI_MODE_NIGHT) != 0) {
         if (!isTruthy((uiMode & MASK_UI_MODE_NIGHT))) return false;
         if (!isTruthy((o.uiMode & MASK_UI_MODE_NIGHT))) return true;
       }
@@ -2346,11 +2337,11 @@ public class ResTable_config {
       if (!isTruthy(o.touchscreen)) return true;
     }
     if (isTruthy(input()) || isTruthy(o.input())) {
-      if (((inputFlags^o.inputFlags) & MASK_KEYSHIDDEN) != 0) {
+      if (((inputFlags ^ o.inputFlags) & MASK_KEYSHIDDEN) != 0) {
         if (!isTruthy((inputFlags & MASK_KEYSHIDDEN))) return false;
         if (!isTruthy((o.inputFlags & MASK_KEYSHIDDEN))) return true;
       }
-      if (((inputFlags^o.inputFlags) & MASK_NAVHIDDEN) != 0) {
+      if (((inputFlags ^ o.inputFlags) & MASK_NAVHIDDEN) != 0) {
         if (!isTruthy((inputFlags & MASK_NAVHIDDEN))) return false;
         if (!isTruthy((o.inputFlags & MASK_NAVHIDDEN))) return true;
       }
diff --git a/resources/src/main/java/org/robolectric/res/android/ResXMLParser.java b/resources/src/main/java/org/robolectric/res/android/ResXMLParser.java
index 39f3b7109..175082ffb 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResXMLParser.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResXMLParser.java
@@ -47,7 +47,7 @@ public class ResXMLParser {
     public static final int END_DOCUMENT = 1;
 
     public static final int FIRST_CHUNK_CODE = RES_XML_FIRST_CHUNK_TYPE;
- 
+
     public static final int START_NAMESPACE = RES_XML_START_NAMESPACE_TYPE;
     public static final int END_NAMESPACE = RES_XML_END_NAMESPACE_TYPE;
     public static final int START_TAG = RES_XML_START_ELEMENT_TYPE;
@@ -55,114 +55,103 @@ public class ResXMLParser {
     public static final int TEXT = RES_XML_CDATA_TYPE;
   }
 
-  ResXMLTree           mTree;
-  int                mEventCode;
-    ResXMLTree_node      mCurNode;
-    int                 mCurExt;
+  ResXMLTree mTree;
+  int mEventCode;
+  ResXMLTree_node mCurNode;
+  int mCurExt;
   int mSourceResourceId;
 
   public ResXMLParser(ResXMLTree tree) {
     this.mTree = tree;
     this.mEventCode = BAD_DOCUMENT;
   }
-  
+
   public void restart() {
     mCurNode = null;
     mEventCode = mTree.mError == NO_ERROR ? START_DOCUMENT : BAD_DOCUMENT;
   }
-  
+
   public ResStringPool getStrings() {
     return mTree.mStrings;
   }
 
-  int getEventType()
-  {
+  int getEventType() {
     return mEventCode;
   }
 
-  public int next()
-  {
+  public int next() {
     if (mEventCode == START_DOCUMENT) {
       mCurNode = mTree.mRootNode;
       mCurExt = mTree.mRootExt;
-      return (mEventCode=mTree.mRootCode);
+      return (mEventCode = mTree.mRootCode);
     } else if (mEventCode >= FIRST_CHUNK_CODE) {
       return nextNode();
     }
     return mEventCode;
   }
 
-  int getCommentID()
-  {
+  int getCommentID() {
     return mCurNode != null ? dtohl(mCurNode.comment.index) : -1;
   }
 
-final String getComment(Ref<Integer> outLen)
-  {
+  final String getComment(Ref<Integer> outLen) {
     int id = getCommentID();
     return id >= 0 ? mTree.mStrings.stringAt(id, outLen) : null;
   }
 
-  public int getLineNumber()
-  {
+  public int getLineNumber() {
     return mCurNode != null ? dtohl(mCurNode.lineNumber) : -1;
   }
 
-  public int getTextID()
-  {
+  public int getTextID() {
     if (mEventCode == TEXT) {
       return dtohl(new ResourceTypes.ResXMLTree_cdataExt(mTree.mBuffer.buf, mCurExt).data.index);
     }
     return -1;
   }
 
-final String getText(Ref<Integer> outLen)
-  {
+  final String getText(Ref<Integer> outLen) {
     int id = getTextID();
     return id >= 0 ? mTree.mStrings.stringAt(id, outLen) : null;
   }
 
-  int getTextValue(Res_value outValue)
-  {
+  int getTextValue(Res_value outValue) {
     if (mEventCode == TEXT) {
-      //outValue.copyFrom_dtoh(new ResourceTypes.ResXMLTree_cdataExt(mTree.mBuffer.buf, mCurExt).typedData);
+      // outValue.copyFrom_dtoh(new ResourceTypes.ResXMLTree_cdataExt(mTree.mBuffer.buf,
+      // mCurExt).typedData);
       return ResourceTypes.Res_value.SIZEOF /* sizeof(Res_value) */;
     }
     return BAD_TYPE;
   }
 
-  int getNamespacePrefixID()
-  {
+  int getNamespacePrefixID() {
     if (mEventCode == START_NAMESPACE || mEventCode == END_NAMESPACE) {
-      return dtohl(new ResourceTypes.ResXMLTree_namespaceExt(mTree.mBuffer.buf, mCurExt).prefix.index);
+      return dtohl(
+          new ResourceTypes.ResXMLTree_namespaceExt(mTree.mBuffer.buf, mCurExt).prefix.index);
     }
     return -1;
   }
 
-final String getNamespacePrefix(Ref<Integer> outLen)
-  {
+  final String getNamespacePrefix(Ref<Integer> outLen) {
     int id = getNamespacePrefixID();
-    //printf("prefix=%d  event=%s\n", id, mEventCode);
+    // printf("prefix=%d  event=%s\n", id, mEventCode);
     return id >= 0 ? mTree.mStrings.stringAt(id, outLen) : null;
   }
 
-  int getNamespaceUriID()
-  {
+  int getNamespaceUriID() {
     if (mEventCode == START_NAMESPACE || mEventCode == END_NAMESPACE) {
       return dtohl(new ResourceTypes.ResXMLTree_namespaceExt(mTree.mBuffer.buf, mCurExt).uri.index);
     }
     return -1;
   }
 
-final String getNamespaceUri(Ref<Integer> outLen)
-  {
+  final String getNamespaceUri(Ref<Integer> outLen) {
     int id = getNamespaceUriID();
-    //printf("uri=%d  event=%s\n", id, mEventCode);
+    // printf("uri=%d  event=%s\n", id, mEventCode);
     return id >= 0 ? mTree.mStrings.stringAt(id, outLen) : null;
   }
 
-  public int getElementNamespaceID()
-  {
+  public int getElementNamespaceID() {
     if (mEventCode == START_TAG) {
       return dtohl(new ResXMLTree_attrExt(mTree.mBuffer.buf, mCurExt).ns.index);
     }
@@ -172,14 +161,12 @@ final String getNamespaceUri(Ref<Integer> outLen)
     return -1;
   }
 
-final String getElementNamespace(Ref<Integer> outLen)
-  {
+  final String getElementNamespace(Ref<Integer> outLen) {
     int id = getElementNamespaceID();
     return id >= 0 ? mTree.mStrings.stringAt(id, outLen) : null;
   }
 
-  public int getElementNameID()
-  {
+  public int getElementNameID() {
     if (mEventCode == START_TAG) {
       return dtohl(new ResXMLTree_attrExt(mTree.mBuffer.buf, mCurExt).name.index);
     }
@@ -189,29 +176,26 @@ final String getElementNamespace(Ref<Integer> outLen)
     return -1;
   }
 
-final String getElementName(Ref<Integer> outLen)
-  {
+  final String getElementName(Ref<Integer> outLen) {
     int id = getElementNameID();
     return id >= 0 ? mTree.mStrings.stringAt(id, outLen) : null;
   }
 
-  public int getAttributeCount()
-  {
+  public int getAttributeCount() {
     if (mEventCode == START_TAG) {
       return dtohs(new ResXMLTree_attrExt(mTree.mBuffer.buf, mCurExt).attributeCount);
     }
     return 0;
   }
 
-  public int getAttributeNamespaceID(int idx)
-  {
+  public int getAttributeNamespaceID(int idx) {
     if (mEventCode == START_TAG) {
-        ResXMLTree_attrExt tag = new ResXMLTree_attrExt(mTree.mBuffer.buf, mCurExt);
+      ResXMLTree_attrExt tag = new ResXMLTree_attrExt(mTree.mBuffer.buf, mCurExt);
       if (idx < dtohs(tag.attributeCount)) {
-//            final ResXMLTree_attribute attr = (ResXMLTree_attribute)
-//        (((final int8_t*)tag)
-//        + dtohs(tag.attributeStart())
-//            + (dtohs(tag.attributeSize())*idx));
+        //            final ResXMLTree_attribute attr = (ResXMLTree_attribute)
+        //        (((final int8_t*)tag)
+        //        + dtohs(tag.attributeStart())
+        //            + (dtohs(tag.attributeSize())*idx));
         ResXMLTree_attribute attr = tag.attributeAt(idx);
         return dtohl(attr.ns.index);
       }
@@ -219,35 +203,32 @@ final String getElementName(Ref<Integer> outLen)
     return -2;
   }
 
-final String getAttributeNamespace(int idx, Ref<Integer> outLen)
-  {
+  final String getAttributeNamespace(int idx, Ref<Integer> outLen) {
     int id = getAttributeNamespaceID(idx);
-    //printf("attribute namespace=%d  idx=%d  event=%s\n", id, idx, mEventCode);
+    // printf("attribute namespace=%d  idx=%d  event=%s\n", id, idx, mEventCode);
     if (kDebugXMLNoisy) {
       System.out.println(String.format("getAttributeNamespace 0x%x=0x%x\n", idx, id));
     }
     return id >= 0 ? mTree.mStrings.stringAt(id, outLen) : null;
   }
 
-final String getAttributeNamespace8(int idx, Ref<Integer> outLen)
-  {
+  final String getAttributeNamespace8(int idx, Ref<Integer> outLen) {
     int id = getAttributeNamespaceID(idx);
-    //printf("attribute namespace=%d  idx=%d  event=%s\n", id, idx, mEventCode);
+    // printf("attribute namespace=%d  idx=%d  event=%s\n", id, idx, mEventCode);
     if (kDebugXMLNoisy) {
       System.out.println(String.format("getAttributeNamespace 0x%x=0x%x\n", idx, id));
     }
     return id >= 0 ? mTree.mStrings.string8At(id, outLen) : null;
   }
 
-  public int getAttributeNameID(int idx)
-  {
+  public int getAttributeNameID(int idx) {
     if (mEventCode == START_TAG) {
-        ResXMLTree_attrExt tag = new ResXMLTree_attrExt(mTree.mBuffer.buf, mCurExt);
+      ResXMLTree_attrExt tag = new ResXMLTree_attrExt(mTree.mBuffer.buf, mCurExt);
       if (idx < dtohs(tag.attributeCount)) {
-//            final ResXMLTree_attribute attr = (ResXMLTree_attribute)
-//        (((final int8_t*)tag)
-//        + dtohs(tag.attributeStart())
-//            + (dtohs(tag.attributeSize())*idx));
+        //            final ResXMLTree_attribute attr = (ResXMLTree_attribute)
+        //        (((final int8_t*)tag)
+        //        + dtohs(tag.attributeStart())
+        //            + (dtohs(tag.attributeSize())*idx));
         ResXMLTree_attribute attr = tag.attributeAt(idx);
         return dtohl(attr.name.index);
       }
@@ -255,30 +236,27 @@ final String getAttributeNamespace8(int idx, Ref<Integer> outLen)
     return -1;
   }
 
-final String getAttributeName(int idx, Ref<Integer> outLen)
-  {
+  final String getAttributeName(int idx, Ref<Integer> outLen) {
     int id = getAttributeNameID(idx);
-    //printf("attribute name=%d  idx=%d  event=%s\n", id, idx, mEventCode);
+    // printf("attribute name=%d  idx=%d  event=%s\n", id, idx, mEventCode);
     if (kDebugXMLNoisy) {
       System.out.println(String.format("getAttributeName 0x%x=0x%x\n", idx, id));
     }
     return id >= 0 ? mTree.mStrings.stringAt(id, outLen) : null;
   }
 
-final String getAttributeName8(int idx, Ref<Integer> outLen)
-  {
+  final String getAttributeName8(int idx, Ref<Integer> outLen) {
     int id = getAttributeNameID(idx);
-    //printf("attribute name=%d  idx=%d  event=%s\n", id, idx, mEventCode);
+    // printf("attribute name=%d  idx=%d  event=%s\n", id, idx, mEventCode);
     if (kDebugXMLNoisy) {
       System.out.println(String.format("getAttributeName 0x%x=0x%x\n", idx, id));
     }
     return id >= 0 ? mTree.mStrings.string8At(id, outLen) : null;
   }
 
-  public int getAttributeNameResID(int idx)
-  {
+  public int getAttributeNameResID(int idx) {
     int id = getAttributeNameID(idx);
-    if (id >= 0 && (int)id < mTree.mNumResIds) {
+    if (id >= 0 && (int) id < mTree.mNumResIds) {
       int resId = dtohl(mTree.mResIds[id]);
       if (mTree.mDynamicRefTable != null) {
         final Ref<Integer> resIdRef = new Ref<>(resId);
@@ -290,15 +268,14 @@ final String getAttributeName8(int idx, Ref<Integer> outLen)
     return 0;
   }
 
-  public int getAttributeValueStringID(int idx)
-  {
+  public int getAttributeValueStringID(int idx) {
     if (mEventCode == START_TAG) {
-        ResXMLTree_attrExt tag = new ResXMLTree_attrExt(mTree.mBuffer.buf, mCurExt);
+      ResXMLTree_attrExt tag = new ResXMLTree_attrExt(mTree.mBuffer.buf, mCurExt);
       if (idx < dtohs(tag.attributeCount)) {
-//            final ResXMLTree_attribute attr = (ResXMLTree_attribute)
-//        (((final int8_t*)tag)
-//        + dtohs(tag.attributeStart())
-//            + (dtohs(tag.attributeSize())*idx));
+        //            final ResXMLTree_attribute attr = (ResXMLTree_attribute)
+        //        (((final int8_t*)tag)
+        //        + dtohs(tag.attributeStart())
+        //            + (dtohs(tag.attributeSize())*idx));
         ResXMLTree_attribute attr = tag.attributeAt(idx);
         return dtohl(attr.rawValue.index);
       }
@@ -306,8 +283,7 @@ final String getAttributeName8(int idx, Ref<Integer> outLen)
     return -1;
   }
 
-final String getAttributeStringValue(int idx, Ref<Integer> outLen)
-  {
+  final String getAttributeStringValue(int idx, Ref<Integer> outLen) {
     int id = getAttributeValueStringID(idx);
     if (kDebugXMLNoisy) {
       System.out.println(String.format("getAttributeValue 0x%x=0x%x\n", idx, id));
@@ -315,15 +291,14 @@ final String getAttributeStringValue(int idx, Ref<Integer> outLen)
     return id >= 0 ? mTree.mStrings.stringAt(id, outLen) : null;
   }
 
-  public int getAttributeDataType(int idx)
-  {
+  public int getAttributeDataType(int idx) {
     if (mEventCode == START_TAG) {
-        final ResXMLTree_attrExt tag = new ResXMLTree_attrExt(mTree.mBuffer.buf, mCurExt);
+      final ResXMLTree_attrExt tag = new ResXMLTree_attrExt(mTree.mBuffer.buf, mCurExt);
       if (idx < dtohs(tag.attributeCount)) {
-//            final ResXMLTree_attribute attr = (ResXMLTree_attribute)
-//        (((final int8_t*)tag)
-//        + dtohs(tag.attributeStart())
-//            + (dtohs(tag.attributeSize())*idx));
+        //            final ResXMLTree_attribute attr = (ResXMLTree_attribute)
+        //        (((final int8_t*)tag)
+        //        + dtohs(tag.attributeStart())
+        //            + (dtohs(tag.attributeSize())*idx));
         ResXMLTree_attribute attr = tag.attributeAt(idx);
         int type = attr.typedValue.dataType;
         if (type != DataType.DYNAMIC_REFERENCE.code()) {
@@ -338,18 +313,17 @@ final String getAttributeStringValue(int idx, Ref<Integer> outLen)
     return DataType.NULL.code();
   }
 
-  public int getAttributeData(int idx)
-  {
+  public int getAttributeData(int idx) {
     if (mEventCode == START_TAG) {
-        ResXMLTree_attrExt tag = new ResXMLTree_attrExt(mTree.mBuffer.buf, mCurExt);
+      ResXMLTree_attrExt tag = new ResXMLTree_attrExt(mTree.mBuffer.buf, mCurExt);
       if (idx < dtohs(tag.attributeCount)) {
-//            final ResXMLTree_attribute attr = (ResXMLTree_attribute)
-//        (((final int8_t*)tag)
-//        + dtohs(tag.attributeStart)
-//            + (dtohs(tag.attributeSize)*idx));
+        //            final ResXMLTree_attribute attr = (ResXMLTree_attribute)
+        //        (((final int8_t*)tag)
+        //        + dtohs(tag.attributeStart)
+        //            + (dtohs(tag.attributeSize)*idx));
         ResXMLTree_attribute attr = tag.attributeAt(idx);
-        if (attr.typedValue.dataType != DataType.DYNAMIC_REFERENCE.code() ||
-            mTree.mDynamicRefTable == null) {
+        if (attr.typedValue.dataType != DataType.DYNAMIC_REFERENCE.code()
+            || mTree.mDynamicRefTable == null) {
           return dtohl(attr.typedValue.data);
         }
 
@@ -362,19 +336,18 @@ final String getAttributeStringValue(int idx, Ref<Integer> outLen)
     return 0;
   }
 
-  public int getAttributeValue(int idx, Ref<Res_value> outValue)
-  {
+  public int getAttributeValue(int idx, Ref<Res_value> outValue) {
     if (mEventCode == START_TAG) {
       ResXMLTree_attrExt tag = new ResXMLTree_attrExt(mTree.mBuffer.buf, mCurExt);
       if (idx < dtohs(tag.attributeCount)) {
-//            final ResXMLTree_attribute attr = (ResXMLTree_attribute)
-//        (((final int8_t*)tag)
-//        + dtohs(tag.attributeStart())
-//            + (dtohs(tag.attributeSize())*idx));
+        //            final ResXMLTree_attribute attr = (ResXMLTree_attribute)
+        //        (((final int8_t*)tag)
+        //        + dtohs(tag.attributeStart())
+        //            + (dtohs(tag.attributeSize())*idx));
         ResXMLTree_attribute attr = tag.attributeAt(idx);
         outValue.set(attr.typedValue);
-        if (mTree.mDynamicRefTable != null &&
-            mTree.mDynamicRefTable.lookupResourceValue(outValue) != NO_ERROR) {
+        if (mTree.mDynamicRefTable != null
+            && mTree.mDynamicRefTable.lookupResourceValue(outValue) != NO_ERROR) {
           return BAD_TYPE;
         }
         return ResourceTypes.Res_value.SIZEOF /* sizeof(Res_value) */;
@@ -383,17 +356,14 @@ final String getAttributeStringValue(int idx, Ref<Integer> outLen)
     return BAD_TYPE;
   }
 
-  int indexOfAttribute(final String ns, final String attr)
-  {
+  int indexOfAttribute(final String ns, final String attr) {
     String nsStr = ns != null ? ns : "";
     String attrStr = attr;
-    return indexOfAttribute(isTruthy(ns) ? nsStr : null, isTruthy(ns) ? nsStr.length() : 0,
-        attrStr, attrStr.length());
+    return indexOfAttribute(
+        isTruthy(ns) ? nsStr : null, isTruthy(ns) ? nsStr.length() : 0, attrStr, attrStr.length());
   }
 
-  public int indexOfAttribute(final String ns, int nsLen,
-                                       final String attr, int attrLen)
-  {
+  public int indexOfAttribute(final String ns, int nsLen, final String attr, int attrLen) {
     if (mEventCode == START_TAG) {
       if (attr == null) {
         return NAME_NOT_FOUND;
@@ -406,17 +376,22 @@ final String getAttributeStringValue(int idx, Ref<Integer> outLen)
         }
         attr8 = new String8(attr, attrLen);
         if (kDebugStringPoolNoisy) {
-          ALOGI("indexOfAttribute UTF8 %s (0x%x) / %s (0x%x)", ns8.string(), nsLen,
-              attr8.string(), attrLen);
+          ALOGI(
+              "indexOfAttribute UTF8 %s (0x%x) / %s (0x%x)",
+              ns8.string(), nsLen, attr8.string(), attrLen);
         }
-        for (int i=0; i<N; i++) {
+        for (int i = 0; i < N; i++) {
           final Ref<Integer> curNsLen = new Ref<>(0), curAttrLen = new Ref<>(0);
           final String curNs = getAttributeNamespace8(i, curNsLen);
           final String curAttr = getAttributeName8(i, curAttrLen);
           if (kDebugStringPoolNoisy) {
-            ALOGI("  curNs=%s (0x%x), curAttr=%s (0x%x)", curNs, curNsLen.get(), curAttr, curAttrLen.get());
+            ALOGI(
+                "  curNs=%s (0x%x), curAttr=%s (0x%x)",
+                curNs, curNsLen.get(), curAttr, curAttrLen.get());
           }
-          if (curAttr != null && curNsLen.get() == nsLen && curAttrLen.get() == attrLen
+          if (curAttr != null
+              && curNsLen.get() == nsLen
+              && curAttrLen.get() == attrLen
               && memcmp(attr8.string(), curAttr, attrLen) == 0) {
             if (ns == null) {
               if (curNs == null) {
@@ -426,7 +401,7 @@ final String getAttributeStringValue(int idx, Ref<Integer> outLen)
                 return i;
               }
             } else if (curNs != null) {
-              //printf(" -. ns=%s, curNs=%s\n",
+              // printf(" -. ns=%s, curNs=%s\n",
               //       String8(ns).string(), String8(curNs).string());
               if (memcmp(ns8.string(), curNs, nsLen) == 0) {
                 if (kDebugStringPoolNoisy) {
@@ -439,21 +414,29 @@ final String getAttributeStringValue(int idx, Ref<Integer> outLen)
         }
       } else {
         if (kDebugStringPoolNoisy) {
-          ALOGI("indexOfAttribute UTF16 %s (0x%x) / %s (0x%x)",
-              ns /*String8(ns, nsLen).string()*/, nsLen,
-              attr /*String8(attr, attrLen).string()*/, attrLen);
+          ALOGI(
+              "indexOfAttribute UTF16 %s (0x%x) / %s (0x%x)",
+              ns /*String8(ns, nsLen).string()*/,
+              nsLen,
+              attr /*String8(attr, attrLen).string()*/,
+              attrLen);
         }
-        for (int i=0; i<N; i++) {
+        for (int i = 0; i < N; i++) {
           final Ref<Integer> curNsLen = new Ref<>(0), curAttrLen = new Ref<>(0);
-                final String curNs = getAttributeNamespace(i, curNsLen);
-                final String curAttr = getAttributeName(i, curAttrLen);
+          final String curNs = getAttributeNamespace(i, curNsLen);
+          final String curAttr = getAttributeName(i, curAttrLen);
           if (kDebugStringPoolNoisy) {
-            ALOGI("  curNs=%s (0x%x), curAttr=%s (0x%x)",
-                curNs /*String8(curNs, curNsLen).string()*/, curNsLen.get(),
-                curAttr /*String8(curAttr, curAttrLen).string()*/, curAttrLen.get());
+            ALOGI(
+                "  curNs=%s (0x%x), curAttr=%s (0x%x)",
+                curNs /*String8(curNs, curNsLen).string()*/,
+                curNsLen.get(),
+                curAttr /*String8(curAttr, curAttrLen).string()*/,
+                curAttrLen.get());
           }
-          if (curAttr != null && curNsLen.get() == nsLen && curAttrLen.get() == attrLen
-              && (memcmp(attr, curAttr, attrLen*SIZEOF_CHAR/*sizeof(char16_t)*/) == 0)) {
+          if (curAttr != null
+              && curNsLen.get() == nsLen
+              && curAttrLen.get() == attrLen
+              && (memcmp(attr, curAttr, attrLen * SIZEOF_CHAR /*sizeof(char16_t)*/) == 0)) {
             if (ns == null) {
               if (curNs == null) {
                 if (kDebugStringPoolNoisy) {
@@ -462,9 +445,9 @@ final String getAttributeStringValue(int idx, Ref<Integer> outLen)
                 return i;
               }
             } else if (curNs != null) {
-              //printf(" -. ns=%s, curNs=%s\n",
+              // printf(" -. ns=%s, curNs=%s\n",
               //       String8(ns).string(), String8(curNs).string());
-              if (memcmp(ns, curNs, nsLen*SIZEOF_CHAR/*sizeof(char16_t)*/) == 0) {
+              if (memcmp(ns, curNs, nsLen * SIZEOF_CHAR /*sizeof(char16_t)*/) == 0) {
                 if (kDebugStringPoolNoisy) {
                   ALOGI("  FOUND!");
                 }
@@ -489,29 +472,26 @@ final String getAttributeStringValue(int idx, Ref<Integer> outLen)
     return 0;
   }
 
-  public int indexOfID()
-  {
+  public int indexOfID() {
     if (mEventCode == START_TAG) {
       final int idx = dtohs(new ResXMLTree_attrExt(mTree.mBuffer.buf, mCurExt).idIndex);
-      if (idx > 0) return (idx-1);
+      if (idx > 0) return (idx - 1);
     }
     return NAME_NOT_FOUND;
   }
 
-  public int indexOfClass()
-  {
+  public int indexOfClass() {
     if (mEventCode == START_TAG) {
       final int idx = dtohs(new ResXMLTree_attrExt(mTree.mBuffer.buf, mCurExt).classIndex);
-      if (idx > 0) return (idx-1);
+      if (idx > 0) return (idx - 1);
     }
     return NAME_NOT_FOUND;
   }
 
-  public int indexOfStyle()
-  {
+  public int indexOfStyle() {
     if (mEventCode == START_TAG) {
       final int idx = dtohs(new ResXMLTree_attrExt(mTree.mBuffer.buf, mCurExt).styleIndex);
-      if (idx > 0) return (idx-1);
+      if (idx > 0) return (idx - 1);
     }
     return NAME_NOT_FOUND;
   }
@@ -525,11 +505,11 @@ final String getAttributeStringValue(int idx, Ref<Integer> outLen)
       int nextOffset = mCurNode.myOffset() + dtohl(mCurNode.header.size);
       if (nextOffset >= mTree.mDataLen) {
         mCurNode = null;
-        return (mEventCode=END_DOCUMENT);
+        return (mEventCode = END_DOCUMENT);
       }
 
-//        final ResXMLTree_node next = (ResXMLTree_node)
-//      (((final int8_t*)mCurNode) + dtohl(mCurNode.header.size));
+      //        final ResXMLTree_node next = (ResXMLTree_node)
+      //      (((final int8_t*)mCurNode) + dtohl(mCurNode.header.size));
       ResXMLTree_node next = new ResXMLTree_node(mTree.mBuffer.buf, nextOffset);
       if (kDebugXMLNoisy) {
         ALOGI("Next node: prev=%s, next=%s\n", mCurNode, next);
@@ -537,12 +517,12 @@ final String getAttributeStringValue(int idx, Ref<Integer> outLen)
 
       if (next.myOffset() >= mTree.mDataLen) {
         mCurNode = null;
-        return (mEventCode=END_DOCUMENT);
+        return (mEventCode = END_DOCUMENT);
       }
 
       if (mTree.validateNode(next) != NO_ERROR) {
         mCurNode = null;
-        return (mEventCode=BAD_DOCUMENT);
+        return (mEventCode = BAD_DOCUMENT);
       }
 
       mCurNode = next;
@@ -551,7 +531,7 @@ final String getAttributeStringValue(int idx, Ref<Integer> outLen)
       mCurExt = next.myOffset() + headerSize;
       int minExtSize = 0;
       int eventCode = dtohs(next.header.type);
-      switch ((mEventCode=eventCode)) {
+      switch ((mEventCode = eventCode)) {
         case RES_XML_START_NAMESPACE_TYPE:
         case RES_XML_END_NAMESPACE_TYPE:
           minExtSize = SIZEOF_RESXMLTREE_NAMESPACE_EXT /*sizeof(ResXMLTree_namespaceExt)*/;
@@ -566,36 +546,36 @@ final String getAttributeStringValue(int idx, Ref<Integer> outLen)
           minExtSize = SIZEOF_RESXMLTREE_CDATA_EXT /*sizeof(ResXMLTree_cdataExt)*/;
           break;
         default:
-          ALOGW("Unknown XML block: header type %d in node at %d\n",
-              (int)dtohs(next.header.type),
-              (next.myOffset()-mTree.mHeader.myOffset()));
+          ALOGW(
+              "Unknown XML block: header type %d in node at %d\n",
+              (int) dtohs(next.header.type), (next.myOffset() - mTree.mHeader.myOffset()));
           continue;
       }
 
-      if ((totalSize-headerSize) < minExtSize) {
-        ALOGW("Bad XML block: header type 0x%x in node at 0x%x has size %d, need %d\n",
-            (int)dtohs(next.header.type),
-            (next.myOffset()-mTree.mHeader.myOffset()),
-        (int)(totalSize-headerSize), (int)minExtSize);
-        return (mEventCode=BAD_DOCUMENT);
+      if ((totalSize - headerSize) < minExtSize) {
+        ALOGW(
+            "Bad XML block: header type 0x%x in node at 0x%x has size %d, need %d\n",
+            (int) dtohs(next.header.type),
+            (next.myOffset() - mTree.mHeader.myOffset()),
+            (int) (totalSize - headerSize),
+            (int) minExtSize);
+        return (mEventCode = BAD_DOCUMENT);
       }
 
-      //printf("CurNode=%s, CurExt=%s, headerSize=%d, minExtSize=%d\n",
+      // printf("CurNode=%s, CurExt=%s, headerSize=%d, minExtSize=%d\n",
       //       mCurNode, mCurExt, headerSize, minExtSize);
 
       return eventCode;
     } while (true);
   }
 
-  void getPosition(ResXMLPosition pos)
-  {
+  void getPosition(ResXMLPosition pos) {
     pos.eventCode = mEventCode;
     pos.curNode = mCurNode;
     pos.curExt = mCurExt;
   }
 
-  void setPosition(final ResXMLPosition pos)
-  {
+  void setPosition(final ResXMLPosition pos) {
     mEventCode = pos.eventCode;
     mCurNode = pos.curNode;
     mCurExt = pos.curExt;
@@ -609,10 +589,10 @@ final String getAttributeStringValue(int idx, Ref<Integer> outLen)
     return mSourceResourceId;
   }
 
-  static class ResXMLPosition
-  {
-    int                eventCode;
-        ResXMLTree_node curNode;
-        int                 curExt;
-  };
+  static class ResXMLPosition {
+    int eventCode;
+    ResXMLTree_node curNode;
+    int curExt;
+  }
+  ;
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/ResXMLTree.java b/resources/src/main/java/org/robolectric/res/android/ResXMLTree.java
index 546f37246..a48d893c2 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResXMLTree.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResXMLTree.java
@@ -35,19 +35,19 @@ public class ResXMLTree {
   final DynamicRefTable mDynamicRefTable;
   public final ResXMLParser mParser;
 
-  int                    mError;
-  byte[]                       mOwnedData;
+  int mError;
+  byte[] mOwnedData;
   XmlBuffer mBuffer;
-    ResXMLTree_header mHeader;
-  int                      mSize;
+  ResXMLTree_header mHeader;
+  int mSize;
   //    final uint8_t*              mDataEnd;
   int mDataLen;
-  ResStringPool               mStrings = new ResStringPool();
-    int[]             mResIds;
-  int                      mNumResIds;
-    ResXMLTree_node mRootNode;
-    int                 mRootExt;
-  int                mRootCode;
+  ResStringPool mStrings = new ResStringPool();
+  int[] mResIds;
+  int mNumResIds;
+  ResXMLTree_node mRootNode;
+  int mRootExt;
+  int mRootCode;
 
   static volatile AtomicInteger gCount = new AtomicInteger(0);
 
@@ -59,40 +59,39 @@ public class ResXMLTree {
     mOwnedData = null;
 
     if (kDebugResXMLTree) {
-      ALOGI("Creating ResXMLTree %s #%d\n", this, gCount.getAndIncrement()+1);
+      ALOGI("Creating ResXMLTree %s #%d\n", this, gCount.getAndIncrement() + 1);
     }
     mParser.restart();
   }
 
-//  ResXMLTree() {
-//    this(null);
-//  }
+  //  ResXMLTree() {
+  //    this(null);
+  //  }
 
-//  ~ResXMLTree()
-//  {
+  //  ~ResXMLTree()
+  //  {
   @Override
   protected void finalize() {
     if (kDebugResXMLTree) {
-      ALOGI("Destroying ResXMLTree in %s #%d\n", this, gCount.getAndDecrement()-1);
+      ALOGI("Destroying ResXMLTree in %s #%d\n", this, gCount.getAndDecrement() - 1);
     }
     uninit();
   }
 
-  public int setTo(byte[] data, int size, boolean copyData)
-  {
+  public int setTo(byte[] data, int size, boolean copyData) {
     uninit();
     mParser.mEventCode = START_DOCUMENT;
 
     if (!isTruthy(data) || !isTruthy(size)) {
-      return (mError=BAD_TYPE);
+      return (mError = BAD_TYPE);
     }
 
     if (copyData) {
       mOwnedData = new byte[size];
-//      if (mOwnedData == null) {
-//        return (mError=NO_MEMORY);
-//      }
-//      memcpy(mOwnedData, data, size);
+      //      if (mOwnedData == null) {
+      //        return (mError=NO_MEMORY);
+      //      }
+      //      memcpy(mOwnedData, data, size);
       System.arraycopy(data, 0, mOwnedData, 0, size);
       data = mOwnedData;
     }
@@ -101,14 +100,14 @@ public class ResXMLTree {
     mHeader = new ResXMLTree_header(mBuffer.buf, 0);
     mSize = dtohl(mHeader.header.size);
     if (dtohs(mHeader.header.headerSize) > mSize || mSize > size) {
-      ALOGW("Bad XML block: header size %d or total size %d is larger than data size %d\n",
-          (int)dtohs(mHeader.header.headerSize),
-          (int)dtohl(mHeader.header.size), (int)size);
+      ALOGW(
+          "Bad XML block: header size %d or total size %d is larger than data size %d\n",
+          (int) dtohs(mHeader.header.headerSize), (int) dtohl(mHeader.header.size), (int) size);
       mError = BAD_TYPE;
       mParser.restart();
       return mError;
     }
-//    mDataEnd = ((final uint8_t*)mHeader) + mSize;
+    //    mDataEnd = ((final uint8_t*)mHeader) + mSize;
     mDataLen = mSize;
 
     mStrings.uninit();
@@ -119,47 +118,50 @@ public class ResXMLTree {
     // First look for a couple interesting chunks: the string block
     // and first XML node.
     ResChunk_header chunk =
-//      (final ResChunk_header*)(((final uint8_t*)mHeader) + dtohs(mHeader.header.headerSize));
+        //      (final ResChunk_header*)(((final uint8_t*)mHeader) +
+        // dtohs(mHeader.header.headerSize));
         new ResChunk_header(mBuffer.buf, mHeader.header.headerSize);
 
     ResChunk_header lastChunk = chunk;
-    while (chunk.myOffset() /*((final uint8_t*)chunk)*/ < (mDataLen- ResChunk_header.SIZEOF /*sizeof(ResChunk_header)*/) &&
-        chunk.myOffset() /*((final uint8_t*)chunk)*/ < (mDataLen-dtohl(chunk.size))) {
-      int err = validate_chunk(chunk, ResChunk_header.SIZEOF /*sizeof(ResChunk_header)*/, mDataLen, "XML");
+    while (chunk.myOffset() /*((final uint8_t*)chunk)*/
+            < (mDataLen - ResChunk_header.SIZEOF /*sizeof(ResChunk_header)*/)
+        && chunk.myOffset() /*((final uint8_t*)chunk)*/ < (mDataLen - dtohl(chunk.size))) {
+      int err =
+          validate_chunk(
+              chunk, ResChunk_header.SIZEOF /*sizeof(ResChunk_header)*/, mDataLen, "XML");
       if (err != NO_ERROR) {
         mError = err;
-//          goto done;
+        //          goto done;
         mParser.restart();
         return mError;
       }
       final short type = dtohs(chunk.type);
       final int size1 = dtohl(chunk.size);
       if (kDebugXMLNoisy) {
-//        System.out.println(String.format("Scanning @ %s: type=0x%x, size=0x%zx\n",
-//            (void*)(((uintptr_t)chunk)-((uintptr_t)mHeader)), type, size1);
+        //        System.out.println(String.format("Scanning @ %s: type=0x%x, size=0x%zx\n",
+        //            (void*)(((uintptr_t)chunk)-((uintptr_t)mHeader)), type, size1);
       }
       if (type == RES_STRING_POOL_TYPE) {
         mStrings.setTo(mBuffer.buf, chunk.myOffset(), size, false);
       } else if (type == RES_XML_RESOURCE_MAP_TYPE) {
-//        mResIds = (final int*)
-//        (((final uint8_t*)chunk)+dtohs(chunk.headerSize()));
-        mNumResIds = (dtohl(chunk.size)-dtohs(chunk.headerSize))/SIZEOF_INT /*sizeof(int)*/;
+        //        mResIds = (final int*)
+        //        (((final uint8_t*)chunk)+dtohs(chunk.headerSize()));
+        mNumResIds = (dtohl(chunk.size) - dtohs(chunk.headerSize)) / SIZEOF_INT /*sizeof(int)*/;
         mResIds = new int[mNumResIds];
         for (int i = 0; i < mNumResIds; i++) {
           mResIds[i] = mBuffer.buf.getInt(chunk.myOffset() + chunk.headerSize + i * SIZEOF_INT);
         }
-      } else if (type >= RES_XML_FIRST_CHUNK_TYPE
-          && type <= RES_XML_LAST_CHUNK_TYPE) {
+      } else if (type >= RES_XML_FIRST_CHUNK_TYPE && type <= RES_XML_LAST_CHUNK_TYPE) {
         if (validateNode(new ResXMLTree_node(mBuffer.buf, chunk)) != NO_ERROR) {
           mError = BAD_TYPE;
-//          goto done;
+          //          goto done;
           mParser.restart();
           return mError;
         }
         mParser.mCurNode = new ResXMLTree_node(mBuffer.buf, lastChunk.myOffset());
         if (mParser.nextNode() == BAD_DOCUMENT) {
           mError = BAD_TYPE;
-//          goto done;
+          //          goto done;
           mParser.restart();
           return mError;
         }
@@ -173,49 +175,49 @@ public class ResXMLTree {
         }
       }
       lastChunk = chunk;
-//      chunk = (final ResChunk_header*)
-//      (((final uint8_t*)chunk) + size1);
+      //      chunk = (final ResChunk_header*)
+      //      (((final uint8_t*)chunk) + size1);
       chunk = new ResChunk_header(mBuffer.buf, chunk.myOffset() + size1);
-  }
+    }
 
     if (mRootNode == null) {
       ALOGW("Bad XML block: no root element node found\n");
       mError = BAD_TYPE;
-//          goto done;
+      //          goto done;
       mParser.restart();
       return mError;
     }
 
     mError = mStrings.getError();
 
-  done:
+    done:
     mParser.restart();
     return mError;
   }
 
-  public int getError()
-  {
+  public int getError() {
     return mError;
   }
 
-  void uninit()
-  {
+  void uninit() {
     mError = NO_INIT;
     mStrings.uninit();
     if (isTruthy(mOwnedData)) {
-//      free(mOwnedData);
+      //      free(mOwnedData);
       mOwnedData = null;
     }
     mParser.restart();
   }
 
-  int validateNode(final ResXMLTree_node node)
-  {
+  int validateNode(final ResXMLTree_node node) {
     final short eventCode = dtohs(node.header.type);
 
-    int err = validate_chunk(
-        node.header, SIZEOF_RESXMLTREE_NODE /*sizeof(ResXMLTree_node)*/,
-      mDataLen, "ResXMLTree_node");
+    int err =
+        validate_chunk(
+            node.header,
+            SIZEOF_RESXMLTREE_NODE /*sizeof(ResXMLTree_node)*/,
+            mDataLen,
+            "ResXMLTree_node");
 
     if (err >= NO_ERROR) {
       // Only perform additional validation on START nodes
@@ -223,67 +225,67 @@ public class ResXMLTree {
         return NO_ERROR;
       }
 
-        final short headerSize = dtohs(node.header.headerSize);
-        final int size = dtohl(node.header.size);
-//        final ResXMLTree_attrExt attrExt = (final ResXMLTree_attrExt*)
-//      (((final uint8_t*)node) + headerSize);
-      ResXMLTree_attrExt attrExt = new ResXMLTree_attrExt(mBuffer.buf, node.myOffset() + headerSize);
+      final short headerSize = dtohs(node.header.headerSize);
+      final int size = dtohl(node.header.size);
+      //        final ResXMLTree_attrExt attrExt = (final ResXMLTree_attrExt*)
+      //      (((final uint8_t*)node) + headerSize);
+      ResXMLTree_attrExt attrExt =
+          new ResXMLTree_attrExt(mBuffer.buf, node.myOffset() + headerSize);
       // check for sensical values pulled out of the stream so far...
       if ((size >= headerSize + SIZEOF_RESXMLTREE_ATTR_EXT /*sizeof(ResXMLTree_attrExt)*/)
           && (attrExt.myOffset() > node.myOffset())) {
-            final int attrSize = ((int)dtohs(attrExt.attributeSize))
-            * dtohs(attrExt.attributeCount);
-        if ((dtohs(attrExt.attributeStart)+attrSize) <= (size-headerSize)) {
+        final int attrSize = ((int) dtohs(attrExt.attributeSize)) * dtohs(attrExt.attributeCount);
+        if ((dtohs(attrExt.attributeStart) + attrSize) <= (size - headerSize)) {
           return NO_ERROR;
         }
-        ALOGW("Bad XML block: node attributes use 0x%x bytes, only have 0x%x bytes\n",
-            (int)(dtohs(attrExt.attributeStart)+attrSize),
-            (int)(size-headerSize));
-      }
-        else {
-        ALOGW("Bad XML start block: node header size 0x%x, size 0x%x\n",
-            (int)headerSize, (int)size);
+        ALOGW(
+            "Bad XML block: node attributes use 0x%x bytes, only have 0x%x bytes\n",
+            (int) (dtohs(attrExt.attributeStart) + attrSize), (int) (size - headerSize));
+      } else {
+        ALOGW(
+            "Bad XML start block: node header size 0x%x, size 0x%x\n",
+            (int) headerSize, (int) size);
       }
       return BAD_TYPE;
     }
 
     return err;
 
-//    if (false) {
-//      final boolean isStart = dtohs(node.header().type()) == RES_XML_START_ELEMENT_TYPE;
-//
-//      final short headerSize = dtohs(node.header().headerSize());
-//      final int size = dtohl(node.header().size());
-//
-//      if (headerSize >= (isStart ? sizeof(ResXMLTree_attrNode) : sizeof(ResXMLTree_node))) {
-//        if (size >= headerSize) {
-//          if ((( final uint8_t*)node) <=(mDataEnd - size)){
-//            if (!isStart) {
-//              return NO_ERROR;
-//            }
-//            if ((((int) dtohs(node.attributeSize)) * dtohs(node.attributeCount))
-//                <= (size - headerSize)) {
-//              return NO_ERROR;
-//            }
-//            ALOGW("Bad XML block: node attributes use 0x%x bytes, only have 0x%x bytes\n",
-//                ((int) dtohs(node.attributeSize)) * dtohs(node.attributeCount),
-//                (int) (size - headerSize));
-//            return BAD_TYPE;
-//          }
-//          ALOGW("Bad XML block: node at 0x%x extends beyond data end 0x%x\n",
-//              (int) ((( final uint8_t*)node)-(( final uint8_t*)mHeader)),(int) mSize);
-//          return BAD_TYPE;
-//        }
-//        ALOGW("Bad XML block: node at 0x%x header size 0x%x smaller than total size 0x%x\n",
-//            (int) ((( final uint8_t*)node)-(( final uint8_t*)mHeader)),
-//        (int) headerSize, (int) size);
-//        return BAD_TYPE;
-//      }
-//      ALOGW("Bad XML block: node at 0x%x header size 0x%x too small\n",
-//          (int) ((( final uint8_t*)node)-(( final uint8_t*)mHeader)),
-//      (int) headerSize);
-//      return BAD_TYPE;
-//    }
+    //    if (false) {
+    //      final boolean isStart = dtohs(node.header().type()) == RES_XML_START_ELEMENT_TYPE;
+    //
+    //      final short headerSize = dtohs(node.header().headerSize());
+    //      final int size = dtohl(node.header().size());
+    //
+    //      if (headerSize >= (isStart ? sizeof(ResXMLTree_attrNode) : sizeof(ResXMLTree_node))) {
+    //        if (size >= headerSize) {
+    //          if ((( final uint8_t*)node) <=(mDataEnd - size)){
+    //            if (!isStart) {
+    //              return NO_ERROR;
+    //            }
+    //            if ((((int) dtohs(node.attributeSize)) * dtohs(node.attributeCount))
+    //                <= (size - headerSize)) {
+    //              return NO_ERROR;
+    //            }
+    //            ALOGW("Bad XML block: node attributes use 0x%x bytes, only have 0x%x bytes\n",
+    //                ((int) dtohs(node.attributeSize)) * dtohs(node.attributeCount),
+    //                (int) (size - headerSize));
+    //            return BAD_TYPE;
+    //          }
+    //          ALOGW("Bad XML block: node at 0x%x extends beyond data end 0x%x\n",
+    //              (int) ((( final uint8_t*)node)-(( final uint8_t*)mHeader)),(int) mSize);
+    //          return BAD_TYPE;
+    //        }
+    //        ALOGW("Bad XML block: node at 0x%x header size 0x%x smaller than total size 0x%x\n",
+    //            (int) ((( final uint8_t*)node)-(( final uint8_t*)mHeader)),
+    //        (int) headerSize, (int) size);
+    //        return BAD_TYPE;
+    //      }
+    //      ALOGW("Bad XML block: node at 0x%x header size 0x%x too small\n",
+    //          (int) ((( final uint8_t*)node)-(( final uint8_t*)mHeader)),
+    //      (int) headerSize);
+    //      return BAD_TYPE;
+    //    }
   }
 
   public ResStringPool getStrings() {
diff --git a/resources/src/main/java/org/robolectric/res/android/ResourceString.java b/resources/src/main/java/org/robolectric/res/android/ResourceString.java
index b80bba557..714592c5a 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResourceString.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResourceString.java
@@ -135,12 +135,10 @@ public final class ResourceString {
     return output.toByteArray();
   }
 
-  /**
-   * Builds a string from a null-terminated char data.
-   */
+  /** Builds a string from a null-terminated char data. */
   public static String buildString(char[] data) {
     int count = 0;
-    for (count=0; count < data.length; count++) {
+    for (count = 0; count < data.length; count++) {
       if (data[count] == 0) {
         break;
       }
@@ -158,7 +156,7 @@ public final class ResourceString {
         output.write(((length & 0x7F00) >> 8) | 0x80);
       }
       output.write(length & 0xFF);
-    } else {  // UTF-16
+    } else { // UTF-16
       // TODO(acornwall): Replace output with a little-endian output.
       if (length > 0x7FFF) {
         int highBytes = ((length & 0x7FFF0000) >> 16) | 0x8000;
@@ -200,4 +198,4 @@ public final class ResourceString {
     }
     return length;
   }
-}
\ No newline at end of file
+}
diff --git a/resources/src/main/java/org/robolectric/res/android/ResourceTable.java b/resources/src/main/java/org/robolectric/res/android/ResourceTable.java
index c69115759..6146763da 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResourceTable.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResourceTable.java
@@ -3,8 +3,7 @@ package org.robolectric.res.android;
 import org.robolectric.res.android.ResourceTypes.ResTable_map;
 
 public class ResourceTable {
-  public static class flag_entry
-  {
+  public static class flag_entry {
     public final String name;
     public final int value;
     public final String description;
@@ -14,34 +13,54 @@ public class ResourceTable {
       this.value = value;
       this.description = description;
     }
-  };
+  }
+  ;
 
   public static flag_entry[] gFormatFlags = {
-      new flag_entry("reference", ResTable_map.TYPE_REFERENCE,
-          "a reference to another resource, in the form \"<code>@[+][<i>package</i>:]<i>type</i>:<i>name</i></code>\"\n"
-          + "or to a theme attribute in the form \"<code>?[<i>package</i>:][<i>type</i>:]<i>name</i></code>\"."),
-      new flag_entry("string", ResTable_map.TYPE_STRING,
-          "a string value, using '\\\\;' to escape characters such as '\\\\n' or '\\\\uxxxx' for a unicode character."),
-      new flag_entry("integer", ResTable_map.TYPE_INTEGER,
-          "an integer value, such as \"<code>100</code>\"."),
-      new flag_entry("boolean", ResTable_map.TYPE_BOOLEAN,
-          "a boolean value, either \"<code>true</code>\" or \"<code>false</code>\"."),
-      new flag_entry("color", ResTable_map.TYPE_COLOR,
-          "a color value, in the form of \"<code>#<i>rgb</i></code>\", \"<code>#<i>argb</i></code>\",\n"
-          + "\"<code>#<i>rrggbb</i></code>\", or \"<code>#<i>aarrggbb</i></code>\"."),
-      new flag_entry("float", ResTable_map.TYPE_FLOAT,
-          "a floating point value, such as \"<code>1.2</code>\"."),
-      new flag_entry("dimension", ResTable_map.TYPE_DIMENSION,
-          "a dimension value, which is a floating point number appended with a unit such as \"<code>14.5sp</code>\".\n"
-          + "Available units are: px (pixels), dp (density-independent pixels), sp (scaled pixels based on preferred font size),\n"
-          + "in (inches), mm (millimeters)."),
-      new flag_entry("fraction", ResTable_map.TYPE_FRACTION,
-          "a fractional value, which is a floating point number appended with either % or %p, such as \"<code>14.5%</code>\".\n"
-          + "The % suffix always means a percentage of the base size; the optional %p suffix provides a size relative to\n"
-          + "some parent container."),
-      new flag_entry("enum", ResTable_map.TYPE_ENUM, null),
-      new flag_entry("flags", ResTable_map.TYPE_FLAGS, null)
-      // new flag_entry(null, 0, null)
+    new flag_entry(
+        "reference",
+        ResTable_map.TYPE_REFERENCE,
+        "a reference to another resource, in the form"
+            + " \"<code>@[+][<i>package</i>:]<i>type</i>:<i>name</i></code>\"\n"
+            + "or to a theme attribute in the form"
+            + " \"<code>?[<i>package</i>:][<i>type</i>:]<i>name</i></code>\"."),
+    new flag_entry(
+        "string",
+        ResTable_map.TYPE_STRING,
+        "a string value, using '\\\\;' to escape characters such as '\\\\n"
+            + "' or '\\\\uxxxx' for a unicode character."),
+    new flag_entry(
+        "integer", ResTable_map.TYPE_INTEGER, "an integer value, such as \"<code>100</code>\"."),
+    new flag_entry(
+        "boolean",
+        ResTable_map.TYPE_BOOLEAN,
+        "a boolean value, either \"<code>true</code>\" or \"<code>false</code>\"."),
+    new flag_entry(
+        "color",
+        ResTable_map.TYPE_COLOR,
+        "a color value, in the form of \"<code>#<i>rgb</i></code>\","
+            + " \"<code>#<i>argb</i></code>\",\n"
+            + "\"<code>#<i>rrggbb</i></code>\", or \"<code>#<i>aarrggbb</i></code>\"."),
+    new flag_entry(
+        "float", ResTable_map.TYPE_FLOAT, "a floating point value, such as \"<code>1.2</code>\"."),
+    new flag_entry(
+        "dimension",
+        ResTable_map.TYPE_DIMENSION,
+        "a dimension value, which is a floating point number appended with a unit such as"
+            + " \"<code>14.5sp</code>\".\n"
+            + "Available units are: px (pixels), dp (density-independent pixels), sp (scaled pixels"
+            + " based on preferred font size),\n"
+            + "in (inches), mm (millimeters)."),
+    new flag_entry(
+        "fraction",
+        ResTable_map.TYPE_FRACTION,
+        "a fractional value, which is a floating point number appended with either % or %p, such as"
+            + " \"<code>14.5%</code>\".\n"
+            + "The % suffix always means a percentage of the base size; the optional %p suffix"
+            + " provides a size relative to\n"
+            + "some parent container."),
+    new flag_entry("enum", ResTable_map.TYPE_ENUM, null),
+    new flag_entry("flags", ResTable_map.TYPE_FLAGS, null)
+    // new flag_entry(null, 0, null)
   };
-
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/ResourceTypes.java b/resources/src/main/java/org/robolectric/res/android/ResourceTypes.java
index c1339383e..b6da37e1d 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResourceTypes.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResourceTypes.java
@@ -18,8 +18,10 @@ import java.util.List;
 import java.util.Map;
 import org.robolectric.res.android.ResourceTypes.ResStringPool_header.Writer;
 
-// transliterated from https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/ResourceTypes.cpp
-//   and https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/include/androidfw/ResourceTypes.h
+// transliterated from
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/ResourceTypes.cpp
+//   and
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/include/androidfw/ResourceTypes.h
 public class ResourceTypes {
   public static final String ANDROID_NS = "http://schemas.android.com/apk/res/android";
   public static final String AUTO_NS = "http://schemas.android.com/apk/res-auto";
@@ -27,34 +29,30 @@ public class ResourceTypes {
   static final int kIdmapMagic = 0x504D4449;
   static final int kIdmapCurrentVersion = 0x00000001;
 
-  static int validate_chunk(ResChunk_header chunk,
-      int minSize,
-      int dataLen,
-      String name)
-  {
+  static int validate_chunk(ResChunk_header chunk, int minSize, int dataLen, String name) {
     final short headerSize = dtohs(chunk.headerSize);
     final int size = dtohl(chunk.size);
 
     if (headerSize >= minSize) {
       if (headerSize <= size) {
-        if (((headerSize|size)&0x3) == 0) {
+        if (((headerSize | size) & 0x3) == 0) {
           if (size <= dataLen) {
             return NO_ERROR;
           }
-          ALOGW("%s data size 0x%x extends beyond resource end.",
+          ALOGW(
+              "%s data size 0x%x extends beyond resource end.",
               name, size /*, (dataEnd-((const uint8_t*)chunk))*/);
           return BAD_TYPE;
         }
-        ALOGW("%s size 0x%x or headerSize 0x%x is not on an integer boundary.",
-            name, (int)size, (int)headerSize);
+        ALOGW(
+            "%s size 0x%x or headerSize 0x%x is not on an integer boundary.",
+            name, (int) size, (int) headerSize);
         return BAD_TYPE;
       }
-      ALOGW("%s size 0x%x is smaller than header size 0x%x.",
-          name, size, headerSize);
+      ALOGW("%s size 0x%x is smaller than header size 0x%x.", name, size, headerSize);
       return BAD_TYPE;
     }
-    ALOGW("%s header size 0x%04x is too small.",
-        name, headerSize);
+    ALOGW("%s header size 0x%04x is too small.", name, headerSize);
     return BAD_TYPE;
   }
 
@@ -81,19 +79,16 @@ public class ResourceTypes {
     }
   }
 
-  /** ********************************************************************
-   *  Base Types
+  /**
+   * ******************************************************************** Base Types
    *
-   *  These are standard types that are shared between multiple specific
-   *  resource types.
+   * <p>These are standard types that are shared between multiple specific resource types.
    *
-   *********************************************************************** */
-
-  /**
-   * Header that appears at the front of every data chunk in a resource.
+   * <p>**********************************************************************
    */
-  public static class ResChunk_header extends WithOffset
-  {
+
+  /** Header that appears at the front of every data chunk in a resource. */
+  public static class ResChunk_header extends WithOffset {
     static int SIZEOF = 8;
 
     // Type identifier for this chunk.  The meaning of this value depends
@@ -140,66 +135,61 @@ public class ResourceTypes {
     }
   }
 
-  public static final int RES_NULL_TYPE               = 0x0000;
-  public static final int RES_STRING_POOL_TYPE        = 0x0001;
-  public static final int RES_TABLE_TYPE              = 0x0002;
-  public static final int RES_XML_TYPE                = 0x0003;
+  public static final int RES_NULL_TYPE = 0x0000;
+  public static final int RES_STRING_POOL_TYPE = 0x0001;
+  public static final int RES_TABLE_TYPE = 0x0002;
+  public static final int RES_XML_TYPE = 0x0003;
 
   // Chunk types in RES_XML_TYPE
-  public static final int RES_XML_FIRST_CHUNK_TYPE    = 0x0100;
-  public static final int RES_XML_START_NAMESPACE_TYPE= 0x0100;
-  public static final int RES_XML_END_NAMESPACE_TYPE  = 0x0101;
-  public static final int RES_XML_START_ELEMENT_TYPE  = 0x0102;
-  public static final int RES_XML_END_ELEMENT_TYPE    = 0x0103;
-  public static final int RES_XML_CDATA_TYPE          = 0x0104;
-  public static final int RES_XML_LAST_CHUNK_TYPE     = 0x017f;
+  public static final int RES_XML_FIRST_CHUNK_TYPE = 0x0100;
+  public static final int RES_XML_START_NAMESPACE_TYPE = 0x0100;
+  public static final int RES_XML_END_NAMESPACE_TYPE = 0x0101;
+  public static final int RES_XML_START_ELEMENT_TYPE = 0x0102;
+  public static final int RES_XML_END_ELEMENT_TYPE = 0x0103;
+  public static final int RES_XML_CDATA_TYPE = 0x0104;
+  public static final int RES_XML_LAST_CHUNK_TYPE = 0x017f;
   // This contains a uint32_t array mapping strings in the string
   // pool back to resource identifiers.  It is optional.
-  public static final int RES_XML_RESOURCE_MAP_TYPE   = 0x0180;
+  public static final int RES_XML_RESOURCE_MAP_TYPE = 0x0180;
 
   // Chunk types in RES_TABLE_TYPE
-  public static final int RES_TABLE_PACKAGE_TYPE      = 0x0200;
-  public static final int RES_TABLE_TYPE_TYPE         = 0x0201;
-  public static final int RES_TABLE_TYPE_SPEC_TYPE    = 0x0202;
-  public static final int RES_TABLE_LIBRARY_TYPE      = 0x0203;
+  public static final int RES_TABLE_PACKAGE_TYPE = 0x0200;
+  public static final int RES_TABLE_TYPE_TYPE = 0x0201;
+  public static final int RES_TABLE_TYPE_SPEC_TYPE = 0x0202;
+  public static final int RES_TABLE_LIBRARY_TYPE = 0x0203;
   public static final int RES_TABLE_STAGED_ALIAS_TYPE = 0x0206;
 
-  /**
-   * Macros for building/splitting resource identifiers.
-   */
-//#define Res_VALIDID(resid) (resid != 0)
-//#define Res_CHECKID(resid) ((resid&0xFFFF0000) != 0)
-//#define Res_MAKEID(package, type, entry) \
-//(((package+1)<<24) | (((type+1)&0xFF)<<16) | (entry&0xFFFF))
-//#define Res_GETPACKAGE(id) ((id>>24)-1)
-//#define Res_GETTYPE(id) (((id>>16)&0xFF)-1)
-//#define Res_GETENTRY(id) (id&0xFFFF)
-
-//#define Res_INTERNALID(resid) ((resid&0xFFFF0000) != 0 && (resid&0xFF0000) == 0)
+  /** Macros for building/splitting resource identifiers. */
+  // #define Res_VALIDID(resid) (resid != 0)
+  // #define Res_CHECKID(resid) ((resid&0xFFFF0000) != 0)
+  // #define Res_MAKEID(package, type, entry) \
+  // (((package+1)<<24) | (((type+1)&0xFF)<<16) | (entry&0xFFFF))
+  // #define Res_GETPACKAGE(id) ((id>>24)-1)
+  // #define Res_GETTYPE(id) (((id>>16)&0xFF)-1)
+  // #define Res_GETENTRY(id) (id&0xFFFF)
+
+  // #define Res_INTERNALID(resid) ((resid&0xFFFF0000) != 0 && (resid&0xFF0000) == 0)
   private static int Res_MAKEINTERNAL(int entry) {
     return (0x01000000 | (entry & 0xFFFF));
   }
-//#define Res_MAKEARRAY(entry) (0x02000000 | (entry&0xFFFF))
 
-//  static const size_t Res_MAXPACKAGE = 255;
-//  static const size_t Res_MAXTYPE = 255;
+  // #define Res_MAKEARRAY(entry) (0x02000000 | (entry&0xFFFF))
 
-  /**
-   * Representation of a value in a resource, supplying type
-   * information.
-   */
-  public static class Res_value
-  {
+  //  static const size_t Res_MAXPACKAGE = 255;
+  //  static const size_t Res_MAXTYPE = 255;
+
+  /** Representation of a value in a resource, supplying type information. */
+  public static class Res_value {
     static final int SIZEOF = 8;
 
     // Number of bytes in this structure.
     final short size;
 
     // Always set to 0.
-//    byte res0;
+    //    byte res0;
 
     // Type of the data value.
-//    enum {
+    //    enum {
     // The 'data' is either 0 or 1, specifying this resource is either
     // undefined or empty, respectively.
     public static final int TYPE_NULL = 0x00;
@@ -253,12 +243,12 @@ public class ResourceTypes {
 
     // ...end of integer flavors.
     public static final int TYPE_LAST_INT = 0x1f;
-//  };
+    //  };
 
     public final byte dataType;
 
     // Structure of complex data values (TYPE_UNIT and TYPE_FRACTION)
-//    enum {
+    //    enum {
     // Where the unit type information is.  This gives us 16 possible
     // types, as defined below.
     public static final int COMPLEX_UNIT_SHIFT = 0;
@@ -301,25 +291,25 @@ public class ResourceTypes {
     // precision.  The top bit is the sign.
     public static final int COMPLEX_MANTISSA_SHIFT = 8;
     public static final int COMPLEX_MANTISSA_MASK = 0xffffff;
-//  };
+    //  };
 
     // Possible data values for TYPE_NULL.
-//    enum {
+    //    enum {
     // The value is not defined.
     public static final int DATA_NULL_UNDEFINED = 0;
     // The value is explicitly defined as empty.
     public static final int DATA_NULL_EMPTY = 1;
-//  };
+    //  };
 
     public static final Res_value NULL_VALUE = new Res_value((byte) TYPE_NULL, DATA_NULL_UNDEFINED);
 
     // The data for this item, as interpreted according to dataType.
-//    typedef uint32_t data_type;
+    //    typedef uint32_t data_type;
     public final int data;
 
     public Res_value() {
       this.size = 0;
-//      this.res0 = 0;
+      //      this.res0 = 0;
       this.dataType = 0;
       this.data = 0;
     }
@@ -337,14 +327,14 @@ public class ResourceTypes {
 
     public Res_value(Res_value other) {
       this.size = other.size;
-//      this.res0 = other.res0;
+      //      this.res0 = other.res0;
       this.dataType = other.dataType;
       this.data = other.data;
     }
 
     public Res_value(byte dataType, int data) {
       this.size = SIZEOF;
-//      this.res0 = 0;
+      //      this.res0 = 0;
       this.dataType = dataType;
       this.data = data;
     }
@@ -364,12 +354,12 @@ public class ResourceTypes {
       return new Res_value(dataType, data);
     }
 
-//    public void copyFrom_dtoh(Res_value other) {
-//      this.size = other.size;
-// //      this.res0 = other.res0;
-//      this.dataType = other.dataType;
-//      this.data = other.data;
-//    }
+    //    public void copyFrom_dtoh(Res_value other) {
+    //      this.size = other.size;
+    // //      this.res0 = other.res0;
+    //      this.dataType = other.dataType;
+    //      this.data = other.data;
+    //    }
 
     public Res_value copy() {
       return new Res_value(this);
@@ -381,39 +371,34 @@ public class ResourceTypes {
     }
   }
 
-/**
- *  This is a reference to a unique entry (a ResTable_entry structure)
- *  in a resource table.  The value is structured as: 0xpptteeee,
- *  where pp is the package index, tt is the type index in that
- *  package, and eeee is the entry index in that type.  The package
- *  and type values start at 1 for the first item, to help catch cases
- *  where they have not been supplied.
- */
-public static class ResTable_ref
-    {
-      public static final int SIZEOF = 4;
-
-      public int ident;
-
-      public ResTable_ref(ByteBuffer buf, int offset) {
-        ident = buf.getInt(offset);
-      }
+  /**
+   * This is a reference to a unique entry (a ResTable_entry structure) in a resource table. The
+   * value is structured as: 0xpptteeee, where pp is the package index, tt is the type index in that
+   * package, and eeee is the entry index in that type. The package and type values start at 1 for
+   * the first item, to help catch cases where they have not been supplied.
+   */
+  public static class ResTable_ref {
+    public static final int SIZEOF = 4;
 
-      public ResTable_ref() {
-        ident = 0;
-      }
+    public int ident;
 
-      @Override
-      public String toString() {
-        return "ResTable_ref{ident=" + ident + '}';
-      }
-    };
+    public ResTable_ref(ByteBuffer buf, int offset) {
+      ident = buf.getInt(offset);
+    }
 
-  /**
-   * Reference to a string in a string pool.
-   */
-  public static class ResStringPool_ref
-  {
+    public ResTable_ref() {
+      ident = 0;
+    }
+
+    @Override
+    public String toString() {
+      return "ResTable_ref{ident=" + ident + '}';
+    }
+  }
+  ;
+
+  /** Reference to a string in a string pool. */
+  public static class ResStringPool_ref {
     public static final int SIZEOF = 4;
 
     // Index into the string pool table (uint32_t-offset from the indices
@@ -435,32 +420,27 @@ public static class ResTable_ref
     }
   }
 
-/** ********************************************************************
- *  String Pool
- *
- *  A set of strings that can be references by others through a
- *  ResStringPool_ref.
- *
- *********************************************************************** */
-
-
-/**
-   * Definition for a pool of strings.  The data of this chunk is an
-   * array of uint32_t providing indices into the pool, relative to
-   * stringsStart.  At stringsStart are all of the UTF-16 strings
-   * concatenated together; each starts with a uint16_t of the string's
-   * length and each ends with a 0x0000 terminator.  If a string is >
-   * 32767 characters, the high bit of the length is set meaning to take
-   * those 15 bits as a high word and it will be followed by another
-   * uint16_t containing the low word.
+  /**
+   * ******************************************************************** String Pool
+   *
+   * <p>A set of strings that can be references by others through a ResStringPool_ref.
+   *
+   * <p>**********************************************************************
+   */
+
+  /**
+   * Definition for a pool of strings. The data of this chunk is an array of uint32_t providing
+   * indices into the pool, relative to stringsStart. At stringsStart are all of the UTF-16 strings
+   * concatenated together; each starts with a uint16_t of the string's length and each ends with a
+   * 0x0000 terminator. If a string is > 32767 characters, the high bit of the length is set meaning
+   * to take those 15 bits as a high word and it will be followed by another uint16_t containing the
+   * low word.
    *
-   * If styleCount is not zero, then immediately following the array of
-   * uint32_t indices into the string table is another array of indices
-   * into a style table starting at stylesStart.  Each entry in the
-   * style table is an array of ResStringPool_span structures.
+   * <p>If styleCount is not zero, then immediately following the array of uint32_t indices into the
+   * string table is another array of indices into a style table starting at stylesStart. Each entry
+   * in the style table is an array of ResStringPool_span structures.
    */
-  public static class ResStringPool_header extends WithOffset
-  {
+  public static class ResStringPool_header extends WithOffset {
     public static final int SIZEOF = ResChunk_header.SIZEOF + 20;
 
     final ResChunk_header header;
@@ -474,14 +454,14 @@ public static class ResTable_ref
     final int styleCount;
 
     // Flags.
-//    enum {
+    //    enum {
     // If set, the string index is sorted by the string values (based
     // on strcmp16()).
-    public static final int SORTED_FLAG = 1<<0;
+    public static final int SORTED_FLAG = 1 << 0;
 
-        // String pool is encoded in UTF-8
-        public static final int UTF8_FLAG = 1<<8;
-//  };
+    // String pool is encoded in UTF-8
+    public static final int UTF8_FLAG = 1 << 8;
+    //  };
     final int flags;
 
     // Index from header of the string data.
@@ -554,42 +534,46 @@ public static class ResTable_ref
       public void write(ByteBuffer buf) {
         freeze();
 
-        ResChunk_header.write(buf, (short) RES_STRING_POOL_TYPE, () -> {
-          // header
-          int startPos = buf.position();
-          int stringCount = strings.size();
-
-          // begin string pool...
-          buf.putInt(stringCount); // stringCount
-          buf.putInt(0); // styleCount
-          buf.putInt(UTF8_FLAG); // flags
-          IntWriter stringStart = new IntWriter(buf);
-          buf.putInt(0); // stylesStart
-
-          stringStart.write(buf.position() - startPos);
-        }, () -> {
-          // contents
-          int stringOffset = /*buf.position() + */8 + 4 * stringsAsBytes.size();
-          for (int i = 0; i < stringsAsBytes.size(); i++) {
-            String string = strings.get(i);
-            byte[] bytes = stringsAsBytes.get(i);
-            buf.putInt(stringOffset);
-            stringOffset += lenLen(string.length()) + lenLen(bytes.length) + bytes.length + 1;
-          }
-
-          for (int i = 0; i < stringsAsBytes.size(); i++) {
-            // number of chars
-            writeLen(buf, strings.get(i).length());
-
-            // number of bytes
-            writeLen(buf, stringsAsBytes.get(i).length);
-
-            // bytes
-            buf.put(stringsAsBytes.get(i));
-            // null terminator
-            buf.put((byte) '\0');
-          }
-        });
+        ResChunk_header.write(
+            buf,
+            (short) RES_STRING_POOL_TYPE,
+            () -> {
+              // header
+              int startPos = buf.position();
+              int stringCount = strings.size();
+
+              // begin string pool...
+              buf.putInt(stringCount); // stringCount
+              buf.putInt(0); // styleCount
+              buf.putInt(UTF8_FLAG); // flags
+              IntWriter stringStart = new IntWriter(buf);
+              buf.putInt(0); // stylesStart
+
+              stringStart.write(buf.position() - startPos);
+            },
+            () -> {
+              // contents
+              int stringOffset = /*buf.position() + */ 8 + 4 * stringsAsBytes.size();
+              for (int i = 0; i < stringsAsBytes.size(); i++) {
+                String string = strings.get(i);
+                byte[] bytes = stringsAsBytes.get(i);
+                buf.putInt(stringOffset);
+                stringOffset += lenLen(string.length()) + lenLen(bytes.length) + bytes.length + 1;
+              }
+
+              for (int i = 0; i < stringsAsBytes.size(); i++) {
+                // number of chars
+                writeLen(buf, strings.get(i).length());
+
+                // number of bytes
+                writeLen(buf, stringsAsBytes.get(i).length);
+
+                // bytes
+                buf.put(stringsAsBytes.get(i));
+                // null terminator
+                buf.put((byte) '\0');
+              }
+            });
       }
 
       private int lenLen(int length) {
@@ -611,17 +595,13 @@ public static class ResTable_ref
     }
   }
 
-  /**
-   * This structure defines a span of style information associated with
-   * a string in the pool.
-   */
-  public static class ResStringPool_span extends WithOffset
-  {
+  /** This structure defines a span of style information associated with a string in the pool. */
+  public static class ResStringPool_span extends WithOffset {
     public static final int SIZEOF = ResStringPool_ref.SIZEOF + 8;
 
     //    enum {
     public static final int END = 0xFFFFFFFF;
-//  };
+    //  };
 
     // This is the name of the span -- that is, the name of the XML
     // tag that defined it.  The special value END (0xFFFFFFFF) indicates
@@ -643,27 +623,25 @@ public static class ResTable_ref
     public boolean isEnd() {
       return name.index == END && firstChar == END && lastChar == END;
     }
-  };
-
+  }
+  ;
 
-  /** ********************************************************************
-   *  XML Tree
+  /**
+   * ******************************************************************** XML Tree
    *
-   *  Binary representation of an XML document.  This is designed to
-   *  express everything in an XML document, in a form that is much
-   *  easier to parse on the device.
+   * <p>Binary representation of an XML document. This is designed to express everything in an XML
+   * document, in a form that is much easier to parse on the device.
    *
-   *********************************************************************** */
+   * <p>**********************************************************************
+   */
 
   /**
-   * XML tree header.  This appears at the front of an XML tree,
-   * describing its content.  It is followed by a flat array of
-   * ResXMLTree_node structures; the hierarchy of the XML document
-   * is described by the occurrance of RES_XML_START_ELEMENT_TYPE
-   * and corresponding RES_XML_END_ELEMENT_TYPE nodes in the array.
+   * XML tree header. This appears at the front of an XML tree, describing its content. It is
+   * followed by a flat array of ResXMLTree_node structures; the hierarchy of the XML document is
+   * described by the occurrance of RES_XML_START_ELEMENT_TYPE and corresponding
+   * RES_XML_END_ELEMENT_TYPE nodes in the array.
    */
-  public static class ResXMLTree_header extends WithOffset
-  {
+  public static class ResXMLTree_header extends WithOffset {
     public final ResChunk_header header;
 
     ResXMLTree_header(ByteBuffer buf, int offset) {
@@ -672,19 +650,22 @@ public static class ResTable_ref
     }
 
     public static void write(ByteBuffer buf, Writer resStringPoolWriter, Runnable contents) {
-      ResChunk_header.write(buf, (short) RES_XML_TYPE, ()-> {}, () -> {
-        resStringPoolWriter.write(buf);
-        contents.run();
-      });
+      ResChunk_header.write(
+          buf,
+          (short) RES_XML_TYPE,
+          () -> {},
+          () -> {
+            resStringPoolWriter.write(buf);
+            contents.run();
+          });
     }
   }
 
   /**
-   * Basic XML tree node.  A single item in the XML document.  Extended info
-   * about the node can be found after header.headerSize.
+   * Basic XML tree node. A single item in the XML document. Extended info about the node can be
+   * found after header.headerSize.
    */
-  public static class ResXMLTree_node extends WithOffset
-  {
+  public static class ResXMLTree_node extends WithOffset {
     final ResChunk_header header;
 
     // Line number in original source file at which this element appeared.
@@ -710,19 +691,23 @@ public static class ResTable_ref
     }
 
     public static void write(ByteBuffer buf, int type, Runnable contents) {
-      ResChunk_header.write(buf, (short) type, () -> {
-        buf.putInt(-1); // lineNumber
-        ResStringPool_ref.write(buf, -1); // comment
-      }, contents);
+      ResChunk_header.write(
+          buf,
+          (short) type,
+          () -> {
+            buf.putInt(-1); // lineNumber
+            ResStringPool_ref.write(buf, -1); // comment
+          },
+          contents);
     }
-  };
+  }
+  ;
 
   /**
-   * Extended XML tree node for CDATA tags -- includes the CDATA string.
-   * Appears header.headerSize bytes after a ResXMLTree_node.
+   * Extended XML tree node for CDATA tags -- includes the CDATA string. Appears header.headerSize
+   * bytes after a ResXMLTree_node.
    */
-  static class ResXMLTree_cdataExt
-  {
+  static class ResXMLTree_cdataExt {
     // The raw CDATA character data.
     final ResStringPool_ref data;
 
@@ -736,14 +721,14 @@ public static class ResTable_ref
       int data = buf.getInt(offset + 8);
       this.typedData = new Res_value((byte) dataType, data);
     }
-  };
+  }
+  ;
 
   /**
-   * Extended XML tree node for namespace start/end nodes.
-   * Appears header.headerSize bytes after a ResXMLTree_node.
+   * Extended XML tree node for namespace start/end nodes. Appears header.headerSize bytes after a
+   * ResXMLTree_node.
    */
-  static class ResXMLTree_namespaceExt
-  {
+  static class ResXMLTree_namespaceExt {
     // The prefix of the namespace.
     final ResStringPool_ref prefix;
 
@@ -754,14 +739,14 @@ public static class ResTable_ref
       this.prefix = new ResStringPool_ref(buf, offset);
       this.uri = new ResStringPool_ref(buf, offset + 4);
     }
-  };
+  }
+  ;
 
   /**
-   * Extended XML tree node for element start/end nodes.
-   * Appears header.headerSize bytes after a ResXMLTree_node.
+   * Extended XML tree node for element start/end nodes. Appears header.headerSize bytes after a
+   * ResXMLTree_node.
    */
-  public static class ResXMLTree_endElementExt
-  {
+  public static class ResXMLTree_endElementExt {
     static final int SIZEOF = 8;
 
     // String of the full namespace of this element.
@@ -781,8 +766,8 @@ public static class ResTable_ref
       private final int ns;
       private final int name;
 
-      public Writer(ByteBuffer buf, ResStringPool_header.Writer resStringPoolWriter,
-          String ns, String name) {
+      public Writer(
+          ByteBuffer buf, ResStringPool_header.Writer resStringPoolWriter, String ns, String name) {
         this.buf = buf;
         this.ns = resStringPoolWriter.string(ns);
         this.name = resStringPoolWriter.string(name);
@@ -793,15 +778,14 @@ public static class ResTable_ref
         ResStringPool_ref.write(buf, name);
       }
     }
-  };
+  }
+  ;
 
   /**
-   * Extended XML tree node for start tags -- includes attribute
-   * information.
-   * Appears header.headerSize bytes after a ResXMLTree_node.
+   * Extended XML tree node for start tags -- includes attribute information. Appears
+   * header.headerSize bytes after a ResXMLTree_node.
    */
-  public static class ResXMLTree_attrExt extends WithOffset
-  {
+  public static class ResXMLTree_attrExt extends WithOffset {
     private final ByteBuffer buf;
 
     // String of the full namespace of this element.
@@ -846,8 +830,8 @@ public static class ResTable_ref
     }
 
     ResXMLTree_attribute attributeAt(int idx) {
-      return new ResXMLTree_attribute(buf,
-          myOffset() + dtohs(attributeStart) + dtohs(attributeSize) * idx);
+      return new ResXMLTree_attribute(
+          buf, myOffset() + dtohs(attributeStart) + dtohs(attributeSize) * idx);
     }
 
     public static class Writer {
@@ -861,8 +845,8 @@ public static class ResTable_ref
 
       private final List<Attr> attrs = new ArrayList<>();
 
-      public Writer(ByteBuffer buf, ResStringPool_header.Writer resStringPoolWriter,
-          String ns, String name) {
+      public Writer(
+          ByteBuffer buf, ResStringPool_header.Writer resStringPoolWriter, String ns, String name) {
         this.buf = buf;
         this.ns = resStringPoolWriter.string(ns);
         this.name = resStringPoolWriter.string(name);
@@ -931,11 +915,11 @@ public static class ResTable_ref
         }
       }
     }
-  };
+  }
+  ;
 
-  static class ResXMLTree_attribute
-  {
-    public static final int SIZEOF = 12+ ResourceTypes.Res_value.SIZEOF;
+  static class ResXMLTree_attribute {
+    public static final int SIZEOF = 12 + ResourceTypes.Res_value.SIZEOF;
 
     // Namespace of this attribute.
     final ResStringPool_ref ns;
@@ -956,33 +940,32 @@ public static class ResTable_ref
       this.typedValue = new Res_value(buf, offset + 12);
     }
 
-    public static void write(ByteBuffer buf, int ns, int name, int value, int resValueDataType,
-        int resValueData) {
+    public static void write(
+        ByteBuffer buf, int ns, int name, int value, int resValueDataType, int resValueData) {
       ResStringPool_ref.write(buf, ns);
       ResStringPool_ref.write(buf, name);
       ResStringPool_ref.write(buf, value);
       ResourceTypes.Res_value.write(buf, resValueDataType, resValueData);
     }
-  };
+  }
+  ;
 
-/** ********************************************************************
- *  RESOURCE TABLE
- *
- *********************************************************************** */
+  /**
+   * ******************************************************************** RESOURCE TABLE
+   *
+   * <p>**********************************************************************
+   */
 
   /**
-   * Header for a resource table.  Its data contains a series of
-   * additional chunks:
-   *   * A ResStringPool_header containing all table values.  This string pool
-   *     contains all of the string values in the entire resource table (not
-   *     the names of entries or type identifiers however).
-   *   * One or more ResTable_package chunks.
+   * Header for a resource table. Its data contains a series of additional chunks: * A
+   * ResStringPool_header containing all table values. This string pool contains all of the string
+   * values in the entire resource table (not the names of entries or type identifiers however). *
+   * One or more ResTable_package chunks.
    *
-   * Specific entries within a resource table can be uniquely identified
-   * with a single integer as defined by the ResTable_ref structure.
+   * <p>Specific entries within a resource table can be uniquely identified with a single integer as
+   * defined by the ResTable_ref structure.
    */
-  static class ResTable_header extends WithOffset
-  {
+  static class ResTable_header extends WithOffset {
     public static final int SIZEOF = ResChunk_header.SIZEOF + 4;
 
     final ResChunk_header header;
@@ -998,12 +981,10 @@ public static class ResTable_ref
   }
 
   /**
-   * A collection of resource data types within a package.  Followed by
-   * one or more ResTable_type and ResTable_typeSpec structures containing the
-   * entry values for each resource type.
+   * A collection of resource data types within a package. Followed by one or more ResTable_type and
+   * ResTable_typeSpec structures containing the entry values for each resource type.
    */
-  static class ResTable_package extends WithOffset
-  {
+  static class ResTable_package extends WithOffset {
     public static final int SIZEOF = ResChunk_header.SIZEOF + 4 + 128 + 20;
 
     final ResChunk_header header;
@@ -1047,7 +1028,8 @@ public static class ResTable_ref
       lastPublicKey = buf.getInt(offset + ResChunk_header.SIZEOF + 4 + 256 + 12);
       typeIdOffset = buf.getInt(offset + ResChunk_header.SIZEOF + 4 + 256 + 16);
     }
-  };
+  }
+  ;
 
   // The most specific locale can consist of:
   //
@@ -1056,24 +1038,22 @@ public static class ResTable_ref
   // - a 4 char script code prefixed by a 's'
   // - a 8 char variant code prefixed by a 'v'
   //
-// each separated by a single char separator, which sums up to a total of 24
-// chars, (25 include the string terminator). Numbering system specificator,
-// if present, can add up to 14 bytes (-u-nu-xxxxxxxx), giving 39 bytes,
-// or 40 bytes to make it 4 bytes aligned.
+  // each separated by a single char separator, which sums up to a total of 24
+  // chars, (25 include the string terminator). Numbering system specificator,
+  // if present, can add up to 14 bytes (-u-nu-xxxxxxxx), giving 39 bytes,
+  // or 40 bytes to make it 4 bytes aligned.
   public static final int RESTABLE_MAX_LOCALE_LEN = 40;
 
   /**
    * A specification of the resources defined by a particular type.
    *
-   * There should be one of these chunks for each resource type.
+   * <p>There should be one of these chunks for each resource type.
    *
-   * This structure is followed by an array of integers providing the set of
-   * configuration change flags (ResTable_config::CONFIG_*) that have multiple
-   * resources for that configuration.  In addition, the high bit is set if that
-   * resource has been made public.
+   * <p>This structure is followed by an array of integers providing the set of configuration change
+   * flags (ResTable_config::CONFIG_*) that have multiple resources for that configuration. In
+   * addition, the high bit is set if that resource has been made public.
    */
-  static class ResTable_typeSpec extends WithOffset
-  {
+  static class ResTable_typeSpec extends WithOffset {
     public static final int SIZEOF = ResChunk_header.SIZEOF + 8;
 
     final ResChunk_header header;
@@ -1091,14 +1071,15 @@ public static class ResTable_ref
     // Number of uint32_t entry configuration masks that follow.
     final int entryCount;
 
-    //enum : uint32_t {
+    // enum : uint32_t {
     // Additional flag indicating an entry is public.
     static final int SPEC_PUBLIC = 0x40000000;
 
     // Additional flag indicating an entry is overlayable at runtime.
     // Added in Android-P.
     static final int SPEC_OVERLAYABLE = 0x80000000;
-//    };
+
+    //    };
 
     public ResTable_typeSpec(ByteBuffer buf, int offset) {
       super(buf, offset);
@@ -1114,46 +1095,40 @@ public static class ResTable_ref
       int[] ints = new int[(header.size - header.headerSize) / 4];
       for (int i = 0; i < ints.length; i++) {
         ints[i] = myBuf().getInt(myOffset() + header.headerSize + i * 4);
-
       }
       return ints;
     }
-  };
+  }
+  ;
 
   /**
-   * A collection of resource entries for a particular resource data
-   * type.
+   * A collection of resource entries for a particular resource data type.
    *
-   * If the flag FLAG_SPARSE is not set in `flags`, then this struct is
-   * followed by an array of uint32_t defining the resource
-   * values, corresponding to the array of type strings in the
-   * ResTable_package::typeStrings string block. Each of these hold an
-   * index from entriesStart; a value of NO_ENTRY means that entry is
-   * not defined.
+   * <p>If the flag FLAG_SPARSE is not set in `flags`, then this struct is followed by an array of
+   * uint32_t defining the resource values, corresponding to the array of type strings in the
+   * ResTable_package::typeStrings string block. Each of these hold an index from entriesStart; a
+   * value of NO_ENTRY means that entry is not defined.
    *
-   * If the flag FLAG_SPARSE is set in `flags`, then this struct is followed
-   * by an array of ResTable_sparseTypeEntry defining only the entries that
-   * have values for this type. Each entry is sorted by their entry ID such
-   * that a binary search can be performed over the entries. The ID and offset
-   * are encoded in a uint32_t. See ResTabe_sparseTypeEntry.
+   * <p>If the flag FLAG_SPARSE is set in `flags`, then this struct is followed by an array of
+   * ResTable_sparseTypeEntry defining only the entries that have values for this type. Each entry
+   * is sorted by their entry ID such that a binary search can be performed over the entries. The ID
+   * and offset are encoded in a uint32_t. See ResTabe_sparseTypeEntry.
    *
-   * There may be multiple of these chunks for a particular resource type,
-   * supply different configuration variations for the resource values of
-   * that type.
+   * <p>There may be multiple of these chunks for a particular resource type, supply different
+   * configuration variations for the resource values of that type.
    *
-   * It would be nice to have an additional ordered index of entries, so
-   * we can do a binary search if trying to find a resource by string name.
+   * <p>It would be nice to have an additional ordered index of entries, so we can do a binary
+   * search if trying to find a resource by string name.
    */
-  static class ResTable_type extends WithOffset
-  {
+  static class ResTable_type extends WithOffset {
     //      public static final int SIZEOF = ResChunk_header.SIZEOF + 12 + ResTable_config.SIZ;
     public static final int SIZEOF_WITHOUT_CONFIG = ResChunk_header.SIZEOF + 12;
 
     final ResChunk_header header;
 
-    //enum {
+    // enum {
     public static final int NO_ENTRY = 0xFFFFFFFF;
-//    };
+    //    };
 
     // The type identifier this chunk is holding.  Type IDs start
     // at 1 (corresponding to the value of the type bits in a
@@ -1222,7 +1197,10 @@ public static class ResTable_ref
       if (isTruthy(flags & ResTable_type.FLAG_OFFSET16)) {
         short off16 = byteBuffer.getShort(offset + header.headerSize + entryIndex * 2);
         // Check for no entry (0xffff short)
-        return dtohs(off16) == -1 ? ResTable_type.NO_ENTRY : dtohs(off16) * 4;
+        if (dtohs(off16) == -1) {
+          return ResTable_type.NO_ENTRY;
+        }
+        return Short.toUnsignedInt(dtohs(off16)) * 4;
       } else if (isTruthy(flags & ResTable_type.FLAG_SPARSE)) {
         ResTable_sparseTypeEntry sparseEntry = getSparseEntry(entryIndex);
         // if (!sparse_entry) {
@@ -1261,17 +1239,18 @@ public static class ResTable_ref
       int STRING_POOL_REF_OFFSET = 4;
       return dtohl(byteBuffer.getInt(offset + entriesStart + entryOffset + STRING_POOL_REF_OFFSET));
     }
-  };
+  }
+  ;
 
   // The minimum size required to read any version of ResTable_type.
-//   constexpr size_t kResTableTypeMinSize =
-//   sizeof(ResTable_type) - sizeof(ResTable_config) + sizeof(ResTable_config::size);
+  //   constexpr size_t kResTableTypeMinSize =
+  //   sizeof(ResTable_type) - sizeof(ResTable_config) + sizeof(ResTable_config::size);
   static final int kResTableTypeMinSize =
-      ResTable_type.SIZEOF_WITHOUT_CONFIG - ResTable_config.SIZEOF + SIZEOF_INT /*sizeof(ResTable_config::size)*/;
+      ResTable_type.SIZEOF_WITHOUT_CONFIG
+          - ResTable_config.SIZEOF
+          + SIZEOF_INT /*sizeof(ResTable_config::size)*/;
 
-  /**
-   * An entry in a ResTable_type with the flag `FLAG_SPARSE` set.
-   */
+  /** An entry in a ResTable_type with the flag `FLAG_SPARSE` set. */
   static class ResTable_sparseTypeEntry extends WithOffset {
     public static final int SIZEOF = 4;
 
@@ -1280,13 +1259,14 @@ public static class ResTable_ref
 
     short idx;
     short offset;
-//    struct {
-      // The index of the entry.
-//      uint16_t idx;
 
-      // The offset from ResTable_type::entriesStart, divided by 4.
-//      uint16_t offset;
-//    };
+    //    struct {
+    // The index of the entry.
+    //      uint16_t idx;
+
+    // The offset from ResTable_type::entriesStart, divided by 4.
+    //      uint16_t offset;
+    //    };
 
     public ResTable_sparseTypeEntry(ByteBuffer buf, int offset) {
       super(buf, offset);
@@ -1294,18 +1274,16 @@ public static class ResTable_ref
       this.idx = buf.getShort(offset);
       this.offset = buf.getShort(offset + 2);
     }
-  };
+  }
+  ;
 
   /**
-   * This is the beginning of information about an entry in the resource
-   * table.  It holds the reference to the name of this entry, and is
-   * immediately followed by one of:
-   *   * A Res_value structure, if FLAG_COMPLEX is -not- set.
-   *   * An array of ResTable_map structures, if FLAG_COMPLEX is set.
-   *     These supply a set of name/value mappings of data.
+   * This is the beginning of information about an entry in the resource table. It holds the
+   * reference to the name of this entry, and is immediately followed by one of: * A Res_value
+   * structure, if FLAG_COMPLEX is -not- set. * An array of ResTable_map structures, if FLAG_COMPLEX
+   * is set. These supply a set of name/value mappings of data.
    */
-  static class ResTable_entry extends WithOffset
-  {
+  static class ResTable_entry extends WithOffset {
     public static final int SIZEOF = 4 + ResStringPool_ref.SIZEOF;
 
     // Number of bytes in this structure.
@@ -1375,15 +1353,12 @@ public static class ResTable_ref
   }
 
   /**
-   * Extended form of a ResTable_entry for map entries, defining a parent map
-   * resource from which to inherit values.
+   * Extended form of a ResTable_entry for map entries, defining a parent map resource from which to
+   * inherit values.
    */
-  static class ResTable_map_entry extends ResTable_entry
-  {
+  static class ResTable_map_entry extends ResTable_entry {
 
-    /**
-     * Indeterminate size, calculate using {@link #size} instead.
-     */
+    /** Indeterminate size, calculate using {@link #size} instead. */
     public static final Void SIZEOF = null;
 
     public static final int BASE_SIZEOF = ResTable_entry.SIZEOF + 8;
@@ -1400,14 +1375,11 @@ public static class ResTable_ref
       parent = new ResTable_ref(buf, offset + ResTable_entry.SIZEOF);
       count = buf.getInt(offset + ResTable_entry.SIZEOF + ResTable_ref.SIZEOF);
     }
-  };
+  }
+  ;
 
-  /**
-   * A single name/value mapping that is part of a complex resource
-   * entry.
-   */
-  public static class ResTable_map extends WithOffset
-  {
+  /** A single name/value mapping that is part of a complex resource entry. */
+  public static class ResTable_map extends WithOffset {
     public static final int SIZEOF = ResTable_ref.SIZEOF + ResourceTypes.Res_value.SIZEOF;
 
     // The resource identifier defining this mapping's name.  For attribute
@@ -1417,7 +1389,7 @@ public static class ResTable_ref
     public final ResTable_ref name;
 
     // Special values for 'name' when defining attribute resources.
-//enum {
+    // enum {
     // This entry holds the attribute's type code.
     public static final int ATTR_TYPE = Res_MAKEINTERNAL(0);
 
@@ -1439,10 +1411,10 @@ public static class ResTable_ref
     public static final int ATTR_FEW = Res_MAKEINTERNAL(8);
     public static final int ATTR_MANY = Res_MAKEINTERNAL(9);
 
-//    };
+    //    };
 
     // Bit mask of allowed types, for use with ATTR_TYPE.
-//enum {
+    // enum {
     // No type has been defined for this attribute, use generic
     // type handling.  The low 16 bits are for types that can be
     // handled generically; the upper 16 require additional information
@@ -1450,44 +1422,44 @@ public static class ResTable_ref
     public static final int TYPE_ANY = 0x0000FFFF;
 
     // Attribute holds a references to another resource.
-    public static final int TYPE_REFERENCE = 1<<0;
+    public static final int TYPE_REFERENCE = 1 << 0;
 
     // Attribute holds a generic string.
-    public static final int TYPE_STRING = 1<<1;
+    public static final int TYPE_STRING = 1 << 1;
 
     // Attribute holds an integer value.  ATTR_MIN and ATTR_MIN can
     // optionally specify a constrained range of possible integer values.
-    public static final int TYPE_INTEGER = 1<<2;
+    public static final int TYPE_INTEGER = 1 << 2;
 
     // Attribute holds a boolean integer.
-    public static final int TYPE_BOOLEAN = 1<<3;
+    public static final int TYPE_BOOLEAN = 1 << 3;
 
     // Attribute holds a color value.
-    public static final int TYPE_COLOR = 1<<4;
+    public static final int TYPE_COLOR = 1 << 4;
 
     // Attribute holds a floating point value.
-    public static final int TYPE_FLOAT = 1<<5;
+    public static final int TYPE_FLOAT = 1 << 5;
 
     // Attribute holds a dimension value, such as "20px".
-    public static final int TYPE_DIMENSION = 1<<6;
+    public static final int TYPE_DIMENSION = 1 << 6;
 
     // Attribute holds a fraction value, such as "20%".
-    public static final int TYPE_FRACTION = 1<<7;
+    public static final int TYPE_FRACTION = 1 << 7;
 
     // Attribute holds an enumeration.  The enumeration values are
     // supplied as additional entries in the map.
-    public static final int TYPE_ENUM = 1<<16;
+    public static final int TYPE_ENUM = 1 << 16;
 
     // Attribute holds a bitmaks of flags.  The flag bit values are
     // supplied as additional entries in the map.
-    public static final int TYPE_FLAGS = 1<<17;
-//    };
+    public static final int TYPE_FLAGS = 1 << 17;
+    //    };
 
     // Enum of localization modes, for use with ATTR_L10N.
-//enum {
+    // enum {
     public static final int L10N_NOT_REQUIRED = 0;
-    public static final int L10N_SUGGESTED    = 1;
-//    };
+    public static final int L10N_SUGGESTED = 1;
+    //    };
 
     // This mapping's value.
     public Res_value value;
@@ -1509,16 +1481,15 @@ public static class ResTable_ref
     public String toString() {
       return "ResTable_map{" + "name=" + name + ", value=" + value + '}';
     }
-  };
+  }
+  ;
 
   /**
-   * A package-id to package name mapping for any shared libraries used
-   * in this resource table. The package-id's encoded in this resource
-   * table may be different than the id's assigned at runtime. We must
-   * be able to translate the package-id's based on the package name.
+   * A package-id to package name mapping for any shared libraries used in this resource table. The
+   * package-id's encoded in this resource table may be different than the id's assigned at runtime.
+   * We must be able to translate the package-id's based on the package name.
    */
-  static class ResTable_lib_header extends WithOffset
-  {
+  static class ResTable_lib_header extends WithOffset {
     static final int SIZEOF = ResChunk_header.SIZEOF + 4;
 
     ResChunk_header header;
@@ -1532,13 +1503,11 @@ public static class ResTable_ref
       header = new ResChunk_header(buf, offset);
       count = buf.getInt(offset + ResChunk_header.SIZEOF);
     }
-  };
+  }
+  ;
 
-  /**
-   * A shared library package-id to package name entry.
-   */
-  static class ResTable_lib_entry extends WithOffset
-  {
+  /** A shared library package-id to package name entry. */
+  static class ResTable_lib_entry extends WithOffset {
     public static final int SIZEOF = 4 + 128 * SIZEOF_SHORT;
 
     // The package-id this shared library was assigned at build time.
@@ -1557,7 +1526,8 @@ public static class ResTable_ref
         packageName[i] = buf.getChar(offset + 4 + i * SIZEOF_SHORT);
       }
     }
-  };
+  }
+  ;
 
   /**
    * A map that allows rewriting staged (non-finalized) resource ids to their finalized
@@ -1653,8 +1623,7 @@ public static class ResTable_ref
     }
   } // __attribute__((packed));
 
-
-  abstract private static class FutureWriter<T> {
+  private abstract static class FutureWriter<T> {
     protected final ByteBuffer buf;
     private final int position;
 
@@ -1666,7 +1635,7 @@ public static class ResTable_ref
       ((Buffer) buf).position(position + size);
     }
 
-    abstract protected void put(int position, T value);
+    protected abstract void put(int position, T value);
 
     public void write(T value) {
       put(position, value);
diff --git a/resources/src/main/java/org/robolectric/res/android/ResourceUtils.java b/resources/src/main/java/org/robolectric/res/android/ResourceUtils.java
index 339167220..6b8bfac38 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResourceUtils.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResourceUtils.java
@@ -2,31 +2,32 @@ package org.robolectric.res.android;
 
 // transliterated from
 // https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/include/androidfw/ResourceUtils.h
-// and https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/ResourceUtils.cpp
+// and
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/ResourceUtils.cpp
 class ResourceUtils {
   // Extracts the package, type, and name from a string of the format: [[package:]type/]name
   // Validation must be performed on each extracted piece.
   // Returns false if there was a syntax error.
-//  boolean ExtractResourceName(String& str, String* out_package, String* out_type,
-//                           String* out_entry);
+  //  boolean ExtractResourceName(String& str, String* out_package, String* out_type,
+  //                           String* out_entry);
 
   static int fix_package_id(int resid, int package_id) {
     return (resid & 0x00ffffff) | (package_id << 24);
   }
 
   static int get_package_id(int resid) {
-//    return static_cast<int>((resid >> 24) & 0x000000ff);
+    //    return static_cast<int>((resid >> 24) & 0x000000ff);
     return resid >>> 24;
   }
 
   // The type ID is 1-based, so if the returned value is 0 it is invalid.
   static int get_type_id(int resid) {
-//    return static_cast<int>((resid >> 16) & 0x000000ff);
+    //    return static_cast<int>((resid >> 16) & 0x000000ff);
     return (resid & 0x00FF0000) >>> 16;
   }
 
   static int get_entry_id(int resid) {
-//    return static_cast<uint16_t>(resid & 0x0000ffff);
+    //    return static_cast<uint16_t>(resid & 0x0000ffff);
     return (short) (resid & 0x0000FFFF);
   }
 
@@ -39,40 +40,41 @@ class ResourceUtils {
   }
 
   static int make_resid(byte package_id, byte type_id, short entry_id) {
-//    return (static_cast<int>(package_id) << 24) | (static_cast<int>(type_id) << 16) |
-//        entry_id;
+    //    return (static_cast<int>(package_id) << 24) | (static_cast<int>(type_id) << 16) |
+    //        entry_id;
     return package_id << 24 | type_id << 16 | entry_id;
   }
 
-//   bool ExtractResourceName(const StringPiece& str, StringPiece* out_package, StringPiece* out_type,
-//                          StringPiece* out_entry) {
-//   *out_package = "";
-//   *out_type = "";
-//   bool has_package_separator = false;
-//   bool has_type_separator = false;
-//   const char* start = str.data();
-//   const char* end = start + str.size();
-//   const char* current = start;
-//   while (current != end) {
-//     if (out_type->size() == 0 && *current == '/') {
-//       has_type_separator = true;
-//       out_type->assign(start, current - start);
-//       start = current + 1;
-//     } else if (out_package->size() == 0 && *current == ':') {
-//       has_package_separator = true;
-//       out_package->assign(start, current - start);
-//       start = current + 1;
-//     }
-//     current++;
-//   }
-//   out_entry->assign(start, end - start);
-//
-//   return !(has_package_separator && out_package->empty()) &&
-//          !(has_type_separator && out_type->empty());
-// }
+  //   bool ExtractResourceName(const StringPiece& str, StringPiece* out_package, StringPiece*
+  // out_type,
+  //                          StringPiece* out_entry) {
+  //   *out_package = "";
+  //   *out_type = "";
+  //   bool has_package_separator = false;
+  //   bool has_type_separator = false;
+  //   const char* start = str.data();
+  //   const char* end = start + str.size();
+  //   const char* current = start;
+  //   while (current != end) {
+  //     if (out_type->size() == 0 && *current == '/') {
+  //       has_type_separator = true;
+  //       out_type->assign(start, current - start);
+  //       start = current + 1;
+  //     } else if (out_package->size() == 0 && *current == ':') {
+  //       has_package_separator = true;
+  //       out_package->assign(start, current - start);
+  //       start = current + 1;
+  //     }
+  //     current++;
+  //   }
+  //   out_entry->assign(start, end - start);
+  //
+  //   return !(has_package_separator && out_package->empty()) &&
+  //          !(has_type_separator && out_type->empty());
+  // }
 
-  static boolean ExtractResourceName(String str, Ref<String> out_package, Ref<String> out_type,
-                           final Ref<String> out_entry) {
+  static boolean ExtractResourceName(
+      String str, Ref<String> out_package, Ref<String> out_type, final Ref<String> out_entry) {
     out_package.set("");
     out_type.set("");
     boolean has_package_separator = false;
@@ -94,8 +96,7 @@ class ResourceUtils {
     }
     out_entry.set(str.substring(start, end));
 
-    return !(has_package_separator && out_package.get().isEmpty()) &&
-           !(has_type_separator && out_type.get().isEmpty());
+    return !(has_package_separator && out_package.get().isEmpty())
+        && !(has_type_separator && out_type.get().isEmpty());
   }
-
 }
diff --git a/resources/src/main/java/org/robolectric/res/android/SortedVector.java b/resources/src/main/java/org/robolectric/res/android/SortedVector.java
index 50f3f2374..a52e54895 100644
--- a/resources/src/main/java/org/robolectric/res/android/SortedVector.java
+++ b/resources/src/main/java/org/robolectric/res/android/SortedVector.java
@@ -22,17 +22,18 @@ public class SortedVector<T extends Comparable<T>> {
 
   public void add(T info) {
     mStorage.add(info);
-    Collections.sort(mStorage, new Comparator<T>() {
-      @Override
-      public int compare(T t, T t1) {
-        return t.compareTo(t1);
-      }
-    });
+    Collections.sort(
+        mStorage,
+        new Comparator<T>() {
+          @Override
+          public int compare(T t, T t1) {
+            return t.compareTo(t1);
+          }
+        });
   }
 
   public int size() {
     return mStorage.size();
-
   }
 
   public T itemAt(int contIdx) {
diff --git a/resources/src/main/java/org/robolectric/res/android/String8.java b/resources/src/main/java/org/robolectric/res/android/String8.java
index 9eae87e28..676a887f3 100644
--- a/resources/src/main/java/org/robolectric/res/android/String8.java
+++ b/resources/src/main/java/org/robolectric/res/android/String8.java
@@ -36,315 +36,317 @@ public class String8 {
   int length() {
     return mString.length();
   }
-//String8 String8::format(const char* fmt, ...)
-//{
-//    va_list args;
-//    va_start(args, fmt);
-//    String8 result(formatV(fmt, args));
-//    va_end(args);
-//    return result;
-//}
-//String8 String8::formatV(const char* fmt, va_list args)
-//{
-//    String8 result;
-//    result.appendFormatV(fmt, args);
-//    return result;
-//}
-//void String8::clear() {
-//    SharedBuffer::bufferFromData(mString)->release();
-//    mString = getEmptyString();
-//}
-//void String8::setTo(const String8& other)
-//{
-//    SharedBuffer::bufferFromData(other.mString)->acquire();
-//    SharedBuffer::bufferFromData(mString)->release();
-//    mString = other.mString;
-//}
-//status_t String8::setTo(const char* other)
-//{
-//    const char *newString = allocFromUTF8(other, strlen(other));
-//    SharedBuffer::bufferFromData(mString)->release();
-//    mString = newString;
-//    if (mString) return NO_ERROR;
-//    mString = getEmptyString();
-//    return NO_MEMORY;
-//}
-//status_t String8::setTo(const char* other, size_t len)
-//{
-//    const char *newString = allocFromUTF8(other, len);
-//    SharedBuffer::bufferFromData(mString)->release();
-//    mString = newString;
-//    if (mString) return NO_ERROR;
-//    mString = getEmptyString();
-//    return NO_MEMORY;
-//}
-//status_t String8::setTo(const char16_t* other, size_t len)
-//{
-//    const char *newString = allocFromUTF16(other, len);
-//    SharedBuffer::bufferFromData(mString)->release();
-//    mString = newString;
-//    if (mString) return NO_ERROR;
-//    mString = getEmptyString();
-//    return NO_MEMORY;
-//}
-//status_t String8::setTo(const char32_t* other, size_t len)
-//{
-//    const char *newString = allocFromUTF32(other, len);
-//    SharedBuffer::bufferFromData(mString)->release();
-//    mString = newString;
-//    if (mString) return NO_ERROR;
-//    mString = getEmptyString();
-//    return NO_MEMORY;
-//}
-//status_t String8::append(const String8& other)
-//{
-//    const size_t otherLen = other.bytes();
-//    if (bytes() == 0) {
-//        setTo(other);
-//        return NO_ERROR;
-//    } else if (otherLen == 0) {
-//        return NO_ERROR;
-//    }
-//    return real_append(other.string(), otherLen);
-//}
-public String8 append(final String other) {
-  mString.append(other);
+
+  // String8 String8::format(const char* fmt, ...)
+  // {
+  //    va_list args;
+  //    va_start(args, fmt);
+  //    String8 result(formatV(fmt, args));
+  //    va_end(args);
+  //    return result;
+  // }
+  // String8 String8::formatV(const char* fmt, va_list args)
+  // {
+  //    String8 result;
+  //    result.appendFormatV(fmt, args);
+  //    return result;
+  // }
+  // void String8::clear() {
+  //    SharedBuffer::bufferFromData(mString)->release();
+  //    mString = getEmptyString();
+  // }
+  // void String8::setTo(const String8& other)
+  // {
+  //    SharedBuffer::bufferFromData(other.mString)->acquire();
+  //    SharedBuffer::bufferFromData(mString)->release();
+  //    mString = other.mString;
+  // }
+  // status_t String8::setTo(const char* other)
+  // {
+  //    const char *newString = allocFromUTF8(other, strlen(other));
+  //    SharedBuffer::bufferFromData(mString)->release();
+  //    mString = newString;
+  //    if (mString) return NO_ERROR;
+  //    mString = getEmptyString();
+  //    return NO_MEMORY;
+  // }
+  // status_t String8::setTo(const char* other, size_t len)
+  // {
+  //    const char *newString = allocFromUTF8(other, len);
+  //    SharedBuffer::bufferFromData(mString)->release();
+  //    mString = newString;
+  //    if (mString) return NO_ERROR;
+  //    mString = getEmptyString();
+  //    return NO_MEMORY;
+  // }
+  // status_t String8::setTo(const char16_t* other, size_t len)
+  // {
+  //    const char *newString = allocFromUTF16(other, len);
+  //    SharedBuffer::bufferFromData(mString)->release();
+  //    mString = newString;
+  //    if (mString) return NO_ERROR;
+  //    mString = getEmptyString();
+  //    return NO_MEMORY;
+  // }
+  // status_t String8::setTo(const char32_t* other, size_t len)
+  // {
+  //    const char *newString = allocFromUTF32(other, len);
+  //    SharedBuffer::bufferFromData(mString)->release();
+  //    mString = newString;
+  //    if (mString) return NO_ERROR;
+  //    mString = getEmptyString();
+  //    return NO_MEMORY;
+  // }
+  // status_t String8::append(const String8& other)
+  // {
+  //    const size_t otherLen = other.bytes();
+  //    if (bytes() == 0) {
+  //        setTo(other);
+  //        return NO_ERROR;
+  //    } else if (otherLen == 0) {
+  //        return NO_ERROR;
+  //    }
+  //    return real_append(other.string(), otherLen);
+  // }
+  public String8 append(final String other) {
+    mString.append(other);
     return this;
-}
-//status_t String8::append(const char* other, size_t otherLen)
-//{
-//    if (bytes() == 0) {
-//        return setTo(other, otherLen);
-//    } else if (otherLen == 0) {
-//        return NO_ERROR;
-//    }
-//    return real_append(other, otherLen);
-//}
-//status_t String8::appendFormat(const char* fmt, ...)
-//{
-//    va_list args;
-//    va_start(args, fmt);
-//    status_t result = appendFormatV(fmt, args);
-//    va_end(args);
-//    return result;
-//}
-//status_t String8::appendFormatV(const char* fmt, va_list args)
-//{
-//    int n, result = NO_ERROR;
-//    va_list tmp_args;
-//    /* args is undefined after vsnprintf.
-//     * So we need a copy here to avoid the
-//     * second vsnprintf access undefined args.
-//     */
-//    va_copy(tmp_args, args);
-//    n = vsnprintf(NULL, 0, fmt, tmp_args);
-//    va_end(tmp_args);
-//    if (n != 0) {
-//        size_t oldLength = length();
-//        char* buf = lockBuffer(oldLength + n);
-//        if (buf) {
-//            vsnprintf(buf + oldLength, n + 1, fmt, args);
-//        } else {
-//            result = NO_MEMORY;
-//        }
-//    }
-//    return result;
-//}
-//status_t String8::real_append(const char* other, size_t otherLen)
-//{
-//    const size_t myLen = bytes();
-//
-//    SharedBuffer* buf = SharedBuffer::bufferFromData(mString)
-//        ->editResize(myLen+otherLen+1);
-//    if (buf) {
-//        char* str = (char*)buf->data();
-//        mString = str;
-//        str += myLen;
-//        memcpy(str, other, otherLen);
-//        str[otherLen] = '\0';
-//        return NO_ERROR;
-//    }
-//    return NO_MEMORY;
-//}
-//char* String8::lockBuffer(size_t size)
-//{
-//    SharedBuffer* buf = SharedBuffer::bufferFromData(mString)
-//        ->editResize(size+1);
-//    if (buf) {
-//        char* str = (char*)buf->data();
-//        mString = str;
-//        return str;
-//    }
-//    return NULL;
-//}
-//void String8::unlockBuffer()
-//{
-//    unlockBuffer(strlen(mString));
-//}
-//status_t String8::unlockBuffer(size_t size)
-//{
-//    if (size != this->size()) {
-//        SharedBuffer* buf = SharedBuffer::bufferFromData(mString)
-//            ->editResize(size+1);
-//        if (! buf) {
-//            return NO_MEMORY;
-//        }
-//        char* str = (char*)buf->data();
-//        str[size] = 0;
-//        mString = str;
-//    }
-//    return NO_ERROR;
-//}
-//ssize_t String8::find(const char* other, size_t start) const
-//{
-//    size_t len = size();
-//    if (start >= len) {
-//        return -1;
-//    }
-//    const char* s = mString+start;
-//    const char* p = strstr(s, other);
-//    return p ? p-mString : -1;
-//}
-//bool String8::removeAll(const char* other) {
-//    ssize_t index = find(other);
-//    if (index < 0) return false;
-//    char* buf = lockBuffer(size());
-//    if (!buf) return false; // out of memory
-//    size_t skip = strlen(other);
-//    size_t len = size();
-//    size_t tail = index;
-//    while (size_t(index) < len) {
-//        ssize_t next = find(other, index + skip);
-//        if (next < 0) {
-//            next = len;
-//        }
-//        memmove(buf + tail, buf + index + skip, next - index - skip);
-//        tail += next - index - skip;
-//        index = next;
-//    }
-//    unlockBuffer(tail);
-//    return true;
-//}
-//void String8::toLower()
-//{
-//    toLower(0, size());
-//}
-//void String8::toLower(size_t start, size_t length)
-//{
-//    const size_t len = size();
-//    if (start >= len) {
-//        return;
-//    }
-//    if (start+length > len) {
-//        length = len-start;
-//    }
-//    char* buf = lockBuffer(len);
-//    buf += start;
-//    while (length > 0) {
-//        *buf = tolower(*buf);
-//        buf++;
-//        length--;
-//    }
-//    unlockBuffer(len);
-//}
-//void String8::toUpper()
-//{
-//    toUpper(0, size());
-//}
-//void String8::toUpper(size_t start, size_t length)
-//{
-//    const size_t len = size();
-//    if (start >= len) {
-//        return;
-//    }
-//    if (start+length > len) {
-//        length = len-start;
-//    }
-//    char* buf = lockBuffer(len);
-//    buf += start;
-//    while (length > 0) {
-//        *buf = toupper(*buf);
-//        buf++;
-//        length--;
-//    }
-//    unlockBuffer(len);
-//}
-//size_t String8::getUtf32Length() const
-//{
-//    return utf8_to_utf32_length(mString, length());
-//}
-//int32_t String8::getUtf32At(size_t index, size_t *next_index) const
-//{
-//    return utf32_from_utf8_at(mString, length(), index, next_index);
-//}
-//void String8::getUtf32(char32_t* dst) const
-//{
-//    utf8_to_utf32(mString, length(), dst);
-//}
-//// ---------------------------------------------------------------------------
-//// Path functions
-//void String8::setPathName(const char* name)
-//{
-//    setPathName(name, strlen(name));
-//}
-//void String8::setPathName(const char* name, size_t len)
-//{
-//    char* buf = lockBuffer(len);
-//    memcpy(buf, name, len);
-//    // remove trailing path separator, if present
-//    if (len > 0 && buf[len-1] == OS_PATH_SEPARATOR)
-//        len--;
-//    buf[len] = '\0';
-//    unlockBuffer(len);
-//}
-String8 getPathLeaf() {
-  final int cp;
-  final String buf = mString.toString();
-  cp = buf.lastIndexOf('/');
-  if (cp == -1) {
-    return new String8(this);
-  } else {
-    return new String8(buf.substring(cp + 1));
   }
-}
-//String8 String8::getPathDir(void) const
-//{
-//    const char* cp;
-//    const char*const str = mString;
-//    cp = strrchr(str, OS_PATH_SEPARATOR);
-//    if (cp == NULL)
-//        return String8("");
-//    else
-//        return String8(str, cp - str);
-//}
-//String8 String8::walkPath(String8* outRemains) const
-//{
-//    const char* cp;
-//    const char*const str = mString;
-//    const char* buf = str;
-//    cp = strchr(buf, OS_PATH_SEPARATOR);
-//    if (cp == buf) {
-//        // don't include a leading '/'.
-//        buf = buf+1;
-//        cp = strchr(buf, OS_PATH_SEPARATOR);
-//    }
-//    if (cp == NULL) {
-//        String8 res = buf != str ? String8(buf) : *this;
-//        if (outRemains) *outRemains = String8("");
-//        return res;
-//    }
-//    String8 res(buf, cp-buf);
-//    if (outRemains) *outRemains = String8(cp+1);
-//    return res;
-//}
 
-/*
- * Helper function for finding the start of an extension in a pathname.
- *
- * Returns a index inside mString, or -1 if no extension was found.
- */
-private int find_extension()
-{
+  // status_t String8::append(const char* other, size_t otherLen)
+  // {
+  //    if (bytes() == 0) {
+  //        return setTo(other, otherLen);
+  //    } else if (otherLen == 0) {
+  //        return NO_ERROR;
+  //    }
+  //    return real_append(other, otherLen);
+  // }
+  // status_t String8::appendFormat(const char* fmt, ...)
+  // {
+  //    va_list args;
+  //    va_start(args, fmt);
+  //    status_t result = appendFormatV(fmt, args);
+  //    va_end(args);
+  //    return result;
+  // }
+  // status_t String8::appendFormatV(const char* fmt, va_list args)
+  // {
+  //    int n, result = NO_ERROR;
+  //    va_list tmp_args;
+  //    /* args is undefined after vsnprintf.
+  //     * So we need a copy here to avoid the
+  //     * second vsnprintf access undefined args.
+  //     */
+  //    va_copy(tmp_args, args);
+  //    n = vsnprintf(NULL, 0, fmt, tmp_args);
+  //    va_end(tmp_args);
+  //    if (n != 0) {
+  //        size_t oldLength = length();
+  //        char* buf = lockBuffer(oldLength + n);
+  //        if (buf) {
+  //            vsnprintf(buf + oldLength, n + 1, fmt, args);
+  //        } else {
+  //            result = NO_MEMORY;
+  //        }
+  //    }
+  //    return result;
+  // }
+  // status_t String8::real_append(const char* other, size_t otherLen)
+  // {
+  //    const size_t myLen = bytes();
+  //
+  //    SharedBuffer* buf = SharedBuffer::bufferFromData(mString)
+  //        ->editResize(myLen+otherLen+1);
+  //    if (buf) {
+  //        char* str = (char*)buf->data();
+  //        mString = str;
+  //        str += myLen;
+  //        memcpy(str, other, otherLen);
+  //        str[otherLen] = '\0';
+  //        return NO_ERROR;
+  //    }
+  //    return NO_MEMORY;
+  // }
+  // char* String8::lockBuffer(size_t size)
+  // {
+  //    SharedBuffer* buf = SharedBuffer::bufferFromData(mString)
+  //        ->editResize(size+1);
+  //    if (buf) {
+  //        char* str = (char*)buf->data();
+  //        mString = str;
+  //        return str;
+  //    }
+  //    return NULL;
+  // }
+  // void String8::unlockBuffer()
+  // {
+  //    unlockBuffer(strlen(mString));
+  // }
+  // status_t String8::unlockBuffer(size_t size)
+  // {
+  //    if (size != this->size()) {
+  //        SharedBuffer* buf = SharedBuffer::bufferFromData(mString)
+  //            ->editResize(size+1);
+  //        if (! buf) {
+  //            return NO_MEMORY;
+  //        }
+  //        char* str = (char*)buf->data();
+  //        str[size] = 0;
+  //        mString = str;
+  //    }
+  //    return NO_ERROR;
+  // }
+  // ssize_t String8::find(const char* other, size_t start) const
+  // {
+  //    size_t len = size();
+  //    if (start >= len) {
+  //        return -1;
+  //    }
+  //    const char* s = mString+start;
+  //    const char* p = strstr(s, other);
+  //    return p ? p-mString : -1;
+  // }
+  // bool String8::removeAll(const char* other) {
+  //    ssize_t index = find(other);
+  //    if (index < 0) return false;
+  //    char* buf = lockBuffer(size());
+  //    if (!buf) return false; // out of memory
+  //    size_t skip = strlen(other);
+  //    size_t len = size();
+  //    size_t tail = index;
+  //    while (size_t(index) < len) {
+  //        ssize_t next = find(other, index + skip);
+  //        if (next < 0) {
+  //            next = len;
+  //        }
+  //        memmove(buf + tail, buf + index + skip, next - index - skip);
+  //        tail += next - index - skip;
+  //        index = next;
+  //    }
+  //    unlockBuffer(tail);
+  //    return true;
+  // }
+  // void String8::toLower()
+  // {
+  //    toLower(0, size());
+  // }
+  // void String8::toLower(size_t start, size_t length)
+  // {
+  //    const size_t len = size();
+  //    if (start >= len) {
+  //        return;
+  //    }
+  //    if (start+length > len) {
+  //        length = len-start;
+  //    }
+  //    char* buf = lockBuffer(len);
+  //    buf += start;
+  //    while (length > 0) {
+  //        *buf = tolower(*buf);
+  //        buf++;
+  //        length--;
+  //    }
+  //    unlockBuffer(len);
+  // }
+  // void String8::toUpper()
+  // {
+  //    toUpper(0, size());
+  // }
+  // void String8::toUpper(size_t start, size_t length)
+  // {
+  //    const size_t len = size();
+  //    if (start >= len) {
+  //        return;
+  //    }
+  //    if (start+length > len) {
+  //        length = len-start;
+  //    }
+  //    char* buf = lockBuffer(len);
+  //    buf += start;
+  //    while (length > 0) {
+  //        *buf = toupper(*buf);
+  //        buf++;
+  //        length--;
+  //    }
+  //    unlockBuffer(len);
+  // }
+  // size_t String8::getUtf32Length() const
+  // {
+  //    return utf8_to_utf32_length(mString, length());
+  // }
+  // int32_t String8::getUtf32At(size_t index, size_t *next_index) const
+  // {
+  //    return utf32_from_utf8_at(mString, length(), index, next_index);
+  // }
+  // void String8::getUtf32(char32_t* dst) const
+  // {
+  //    utf8_to_utf32(mString, length(), dst);
+  // }
+  //// ---------------------------------------------------------------------------
+  //// Path functions
+  // void String8::setPathName(const char* name)
+  // {
+  //    setPathName(name, strlen(name));
+  // }
+  // void String8::setPathName(const char* name, size_t len)
+  // {
+  //    char* buf = lockBuffer(len);
+  //    memcpy(buf, name, len);
+  //    // remove trailing path separator, if present
+  //    if (len > 0 && buf[len-1] == OS_PATH_SEPARATOR)
+  //        len--;
+  //    buf[len] = '\0';
+  //    unlockBuffer(len);
+  // }
+  String8 getPathLeaf() {
+    final int cp;
+    final String buf = mString.toString();
+    cp = buf.lastIndexOf('/');
+    if (cp == -1) {
+      return new String8(this);
+    } else {
+      return new String8(buf.substring(cp + 1));
+    }
+  }
+
+  // String8 String8::getPathDir(void) const
+  // {
+  //    const char* cp;
+  //    const char*const str = mString;
+  //    cp = strrchr(str, OS_PATH_SEPARATOR);
+  //    if (cp == NULL)
+  //        return String8("");
+  //    else
+  //        return String8(str, cp - str);
+  // }
+  // String8 String8::walkPath(String8* outRemains) const
+  // {
+  //    const char* cp;
+  //    const char*const str = mString;
+  //    const char* buf = str;
+  //    cp = strchr(buf, OS_PATH_SEPARATOR);
+  //    if (cp == buf) {
+  //        // don't include a leading '/'.
+  //        buf = buf+1;
+  //        cp = strchr(buf, OS_PATH_SEPARATOR);
+  //    }
+  //    if (cp == NULL) {
+  //        String8 res = buf != str ? String8(buf) : *this;
+  //        if (outRemains) *outRemains = String8("");
+  //        return res;
+  //    }
+  //    String8 res(buf, cp-buf);
+  //    if (outRemains) *outRemains = String8(cp+1);
+  //    return res;
+  // }
+
+  /*
+   * Helper function for finding the start of an extension in a pathname.
+   *
+   * Returns a index inside mString, or -1 if no extension was found.
+   */
+  private int find_extension() {
     int lastSlashIndex;
 
     final StringBuilder str = mString;
@@ -357,19 +359,17 @@ private int find_extension()
     }
     // find the last dot
     return str.lastIndexOf(".", lastSlashIndex);
-}
+  }
 
-public String getPathExtension()
-{
+  public String getPathExtension() {
     int extIndex;
     extIndex = find_extension();
     if (extIndex != -1) {
       return mString.substring(extIndex);
-    }
-    else {
+    } else {
       return "";
     }
-}
+  }
 
   String8 getBasePath() {
     int extIndex;
@@ -391,24 +391,24 @@ public String getPathExtension()
     }
     mString.append(name);
     return this;
-}
+  }
 
-//String8& String8::convertToResPath()
-//{
-//#if OS_PATH_SEPARATOR != RES_PATH_SEPARATOR
-//    size_t len = length();
-//    if (len > 0) {
-//        char * buf = lockBuffer(len);
-//        for (char * end = buf + len; buf < end; ++buf) {
-//            if (*buf == OS_PATH_SEPARATOR)
-//                *buf = RES_PATH_SEPARATOR;
-//        }
-//        unlockBuffer(len);
-//    }
-//#endif
-//    return *this;
-//}
-//}; // namespace android
+  // String8& String8::convertToResPath()
+  // {
+  // #if OS_PATH_SEPARATOR != RES_PATH_SEPARATOR
+  //    size_t len = length();
+  //    if (len > 0) {
+  //        char * buf = lockBuffer(len);
+  //        for (char * end = buf + len; buf < end; ++buf) {
+  //            if (*buf == OS_PATH_SEPARATOR)
+  //                *buf = RES_PATH_SEPARATOR;
+  //        }
+  //        unlockBuffer(len);
+  //    }
+  // #endif
+  //    return *this;
+  // }
+  // }; // namespace android
 
   public final String string() {
     return mString.toString();
@@ -430,14 +430,13 @@ public String getPathExtension()
 
     String8 string8 = (String8) o;
 
-    return mString != null ? mString.toString().equals(string8.mString.toString()) : string8.mString == null;
+    return mString != null
+        ? mString.toString().equals(string8.mString.toString())
+        : string8.mString == null;
   }
 
   @Override
   public int hashCode() {
     return mString != null ? mString.hashCode() : 0;
   }
-
 }
-
-
diff --git a/resources/src/main/java/org/robolectric/res/android/StringPoolRef.java b/resources/src/main/java/org/robolectric/res/android/StringPoolRef.java
index b56f32f9a..0fc8bfa07 100644
--- a/resources/src/main/java/org/robolectric/res/android/StringPoolRef.java
+++ b/resources/src/main/java/org/robolectric/res/android/StringPoolRef.java
@@ -1,7 +1,8 @@
 package org.robolectric.res.android;
 
 /**
- * transliterated from https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/include/androidfw/ResourceTypes.h:541
+ * transliterated from
+ * https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/include/androidfw/ResourceTypes.h:541
  * Wrapper class that allows the caller to retrieve a string from a string pool without knowing
  * which string pool to look.
  */
diff --git a/resources/src/main/java/org/robolectric/res/android/Util.java b/resources/src/main/java/org/robolectric/res/android/Util.java
index 5b8228237..947fd8b7a 100644
--- a/resources/src/main/java/org/robolectric/res/android/Util.java
+++ b/resources/src/main/java/org/robolectric/res/android/Util.java
@@ -17,15 +17,11 @@ public class Util {
   private static final boolean DEBUG = false;
 
   static short dtohs(short v) {
-    return littleEndian
-        ? v
-        : (short) ((v << 8) | (v >> 8));
+    return littleEndian ? v : (short) ((v << 8) | (v >> 8));
   }
 
   static char dtohs(char v) {
-    return littleEndian
-        ? v
-        : (char) ((v << 8) | (v >> 8));
+    return littleEndian ? v : (char) ((v << 8) | (v >> 8));
   }
 
   static int dtohl(int v) {
@@ -35,9 +31,7 @@ public class Util {
   }
 
   static short htods(short v) {
-    return littleEndian
-        ? v
-        : (short) ((v << 8) | (v >> 8));
+    return littleEndian ? v : (short) ((v << 8) | (v >> 8));
   }
 
   static int htodl(int v) {
@@ -90,11 +84,9 @@ public class Util {
     assert !assertion : String.format(message, args);
   }
 
-  static void ATRACE_CALL() {
-  }
+  static void ATRACE_CALL() {}
 
-  public static void ATRACE_NAME(String s) {
-  }
+  public static void ATRACE_NAME(String s) {}
 
   static boolean UNLIKELY(boolean b) {
     return b;
@@ -112,7 +104,7 @@ public class Util {
     System.err.println("[WARN] " + s);
   }
 
-  static String ReadUtf16StringFromDevice(char[] src, int len/*, std::string* out*/) {
+  static String ReadUtf16StringFromDevice(char[] src, int len /*, std::string* out*/) {
     int i = 0;
     StringBuilder strBuf = new StringBuilder();
     while (src[i] != '\0' && len != 0) {
diff --git a/resources/src/main/java/org/robolectric/res/android/ZipFileRO.java b/resources/src/main/java/org/robolectric/res/android/ZipFileRO.java
index 8f884e5fd..93bb28a4d 100644
--- a/resources/src/main/java/org/robolectric/res/android/ZipFileRO.java
+++ b/resources/src/main/java/org/robolectric/res/android/ZipFileRO.java
@@ -26,30 +26,30 @@ public class ZipFileRO {
   }
 
   static class ZipEntryRO {
-        ZipEntry entry;
+    ZipEntry entry;
     String name;
     long dataOffset;
     Object cookie;
 
-    ZipEntryRO() {
-    }
+    ZipEntryRO() {}
 
     //    ~ZipEntryRO() {
     @Override
     protected void finalize() {
-//      EndIteration(cookie);
+      //      EndIteration(cookie);
     }
 
-//    private:
-//    ZipEntryRO(final ZipEntryRO& other);
-//    ZipEntryRO& operator=(final ZipEntryRO& other);
-  };
+    //    private:
+    //    ZipEntryRO(final ZipEntryRO& other);
+    //    ZipEntryRO& operator=(final ZipEntryRO& other);
+  }
+  ;
 
-//  ~ZipFileRO() {
+  //  ~ZipFileRO() {
   @Override
   protected void finalize() {
     CloseArchive();
-//    free(mFileName);
+    //    free(mFileName);
   }
 
   static int OpenArchive(String zipFileName, Ref<ZipArchiveHandle> mHandle) {
@@ -84,12 +84,11 @@ public class ZipFileRO {
   }
 
   /*
- * Open the specified file read-only.  We memory-map the entire thing and
- * close the file before returning.
- */
-/* static */
-  static ZipFileRO open(final String zipFileName)
-  {
+   * Open the specified file read-only.  We memory-map the entire thing and
+   * close the file before returning.
+   */
+  /* static */
+  static ZipFileRO open(final String zipFileName) {
     final Ref<ZipArchiveHandle> handle = new Ref<>(null);
     final int error = OpenArchive(zipFileName, handle);
     if (isTruthy(error)) {
@@ -115,8 +114,7 @@ public class ZipFileRO {
   //   return new ZipFileRO(handle, strdup(debugFileName));
   // }
 
-  org.robolectric.res.android.ZipFileRO.ZipEntryRO findEntryByName(final String entryName)
-  {
+  org.robolectric.res.android.ZipFileRO.ZipEntryRO findEntryByName(final String entryName) {
     ZipEntryRO data = new ZipEntryRO();
     data.name = String(entryName);
 
@@ -141,10 +139,14 @@ public class ZipFileRO {
    * Returns "false" if the offsets to the fields or the contents of the fields
    * appear to be bogus.
    */
-  boolean getEntryInfo(org.robolectric.res.android.ZipFileRO.ZipEntryRO entry, Ref<Short> pMethod,
-      final Ref<Long> pUncompLen, Ref<Long> pCompLen, Ref<Long> pOffset,
-      final Ref<Long> pModWhen, Ref<Long> pCrc32)
-  {
+  boolean getEntryInfo(
+      org.robolectric.res.android.ZipFileRO.ZipEntryRO entry,
+      Ref<Short> pMethod,
+      final Ref<Long> pUncompLen,
+      Ref<Long> pCompLen,
+      Ref<Long> pOffset,
+      final Ref<Long> pModWhen,
+      Ref<Long> pCrc32) {
     final ZipEntryRO zipEntry = /*reinterpret_cast<ZipEntryRO*>*/ entry;
     final ZipEntry ze = zipEntry.entry;
 
@@ -152,17 +154,17 @@ public class ZipFileRO {
       pMethod.set((short) ze.getMethod());
     }
     if (pUncompLen != null) {
-        pUncompLen.set(ze.getSize()); // uncompressed_length
+      pUncompLen.set(ze.getSize()); // uncompressed_length
     }
     if (pCompLen != null) {
-        pCompLen.set(ze.getCompressedSize());
+      pCompLen.set(ze.getCompressedSize());
     }
     if (pOffset != null) {
       throw new UnsupportedOperationException("Figure out offset");
       //        pOffset = ze.offset;
     }
     if (pModWhen != null) {
-        // todo pModWhen.set(ze.getLastModifiedTime().toMillis());
+      // todo pModWhen.set(ze.getLastModifiedTime().toMillis());
     }
     if (pCrc32 != null) {
       pCrc32.set(ze.getCrc());
@@ -175,108 +177,105 @@ public class ZipFileRO {
     return startIteration(cookie, null, null);
   }
 
-  boolean startIteration(/* void** */ Ref<Enumeration<? extends ZipEntry>> cookie, final String prefix, final String suffix)
-  {
+  boolean startIteration(
+      /* void** */ Ref<Enumeration<? extends ZipEntry>> cookie,
+      final String prefix,
+      final String suffix) {
     cookie.set(this.mHandle.zipFile.entries());
-//    ZipEntryRO* ze = new ZipEntryRO;
-//    String pe(prefix ? prefix : "");
-//    String se(suffix ? suffix : "");
-//    int error = StartIteration(mHandle, &(ze.cookie),
-//    prefix ? &pe : null,
-//      suffix ? &se : null);
-//    if (error) {
-//      ALOGW("Could not start iteration over %s: %s", mFileName, ErrorCodeString(error));
-//      delete ze;
-//      return false;
-//    }
-//
-//    *cookie = ze;
+    //    ZipEntryRO* ze = new ZipEntryRO;
+    //    String pe(prefix ? prefix : "");
+    //    String se(suffix ? suffix : "");
+    //    int error = StartIteration(mHandle, &(ze.cookie),
+    //    prefix ? &pe : null,
+    //      suffix ? &se : null);
+    //    if (error) {
+    //      ALOGW("Could not start iteration over %s: %s", mFileName, ErrorCodeString(error));
+    //      delete ze;
+    //      return false;
+    //    }
+    //
+    //    *cookie = ze;
     return true;
   }
 
-  org.robolectric.res.android.ZipFileRO.ZipEntryRO nextEntry(/*void* */ Enumeration<? extends ZipEntry> cookie)
-  {
+  org.robolectric.res.android.ZipFileRO.ZipEntryRO nextEntry(
+      /*void* */ Enumeration<? extends ZipEntry> cookie) {
     if (!cookie.hasMoreElements()) {
       return null;
     }
     ZipEntryRO zipEntryRO = new ZipEntryRO();
     zipEntryRO.entry = cookie.nextElement();
     return zipEntryRO;
-//    ZipEntryRO ze = /*reinterpret_cast<ZipEntryRO*>*/(ZipEntryRO) cookie;
-//    int error = Next(ze.cookie, &(ze.entry), &(ze.name));
-//    if (error) {
-//      if (error != -1) {
-//        ALOGW("Error iteration over %s: %s", mFileName, ErrorCodeString(error));
-//      }
-//      return null;
-//    }
-//
-//    return &(ze.entry);
+    //    ZipEntryRO ze = /*reinterpret_cast<ZipEntryRO*>*/(ZipEntryRO) cookie;
+    //    int error = Next(ze.cookie, &(ze.entry), &(ze.name));
+    //    if (error) {
+    //      if (error != -1) {
+    //        ALOGW("Error iteration over %s: %s", mFileName, ErrorCodeString(error));
+    //      }
+    //      return null;
+    //    }
+    //
+    //    return &(ze.entry);
   }
 
-  void endIteration(/*void**/ Object cookie)
-  {
-//    delete reinterpret_cast<ZipEntryRO*>(cookie);
+  void endIteration(/*void**/ Object cookie) {
+    //    delete reinterpret_cast<ZipEntryRO*>(cookie);
   }
 
-  void releaseEntry(org.robolectric.res.android.ZipFileRO.ZipEntryRO entry)
-  {
-//    delete reinterpret_cast<ZipEntryRO*>(entry);
+  void releaseEntry(org.robolectric.res.android.ZipFileRO.ZipEntryRO entry) {
+    //    delete reinterpret_cast<ZipEntryRO*>(entry);
   }
 
   /*
    * Copy the entry's filename to the buffer.
    */
-  int getEntryFileName(org.robolectric.res.android.ZipFileRO.ZipEntryRO entry, Ref<String> buffer)
-  {
+  int getEntryFileName(org.robolectric.res.android.ZipFileRO.ZipEntryRO entry, Ref<String> buffer) {
     buffer.set(entry.entry.getName());
 
-//    final ZipEntryRO* zipEntry = reinterpret_cast<ZipEntryRO*>(entry);
-//    final uint16_t requiredSize = zipEntry.name.name_length + 1;
-//
-//    if (bufLen < requiredSize) {
-//      ALOGW("Buffer too short, requires %d bytes for entry name", requiredSize);
-//      return requiredSize;
-//    }
-//
-//    memcpy(buffer, zipEntry.name.name, requiredSize - 1);
-//    buffer[requiredSize - 1] = '\0';
-//
+    //    final ZipEntryRO* zipEntry = reinterpret_cast<ZipEntryRO*>(entry);
+    //    final uint16_t requiredSize = zipEntry.name.name_length + 1;
+    //
+    //    if (bufLen < requiredSize) {
+    //      ALOGW("Buffer too short, requires %d bytes for entry name", requiredSize);
+    //      return requiredSize;
+    //    }
+    //
+    //    memcpy(buffer, zipEntry.name.name, requiredSize - 1);
+    //    buffer[requiredSize - 1] = '\0';
+    //
     return 0;
   }
 
-/*
- * Create a new FileMap object that spans the data in "entry".
- */
-  /*FileMap*/ ZipFileRO(org.robolectric.res.android.ZipFileRO.ZipEntryRO entry)
-  {
+  /*
+   * Create a new FileMap object that spans the data in "entry".
+   */
+  /*FileMap*/ ZipFileRO(org.robolectric.res.android.ZipFileRO.ZipEntryRO entry) {
     throw new UnsupportedOperationException("Implememnt me");
 
-//    final ZipEntryRO *zipEntry = reinterpret_cast<ZipEntryRO*>(entry);
-//    final ZipEntry& ze = zipEntry.entry;
-//    int fd = GetFileDescriptor(mHandle);
-//    size_t actualLen = 0;
-//
-//    if (ze.method == kCompressStored) {
-//      actualLen = ze.uncompressed_length;
-//    } else {
-//      actualLen = ze.compressed_length;
-//    }
-//
-//    FileMap* newMap = new FileMap();
-//    if (!newMap.create(mFileName, fd, ze.offset, actualLen, true)) {
-//      delete newMap;
-//      return null;
-//    }
-//
-//    return newMap;
+    //    final ZipEntryRO *zipEntry = reinterpret_cast<ZipEntryRO*>(entry);
+    //    final ZipEntry& ze = zipEntry.entry;
+    //    int fd = GetFileDescriptor(mHandle);
+    //    size_t actualLen = 0;
+    //
+    //    if (ze.method == kCompressStored) {
+    //      actualLen = ze.uncompressed_length;
+    //    } else {
+    //      actualLen = ze.compressed_length;
+    //    }
+    //
+    //    FileMap* newMap = new FileMap();
+    //    if (!newMap.create(mFileName, fd, ze.offset, actualLen, true)) {
+    //      delete newMap;
+    //      return null;
+    //    }
+    //
+    //    return newMap;
   }
 
   /*
- * Create a new FileMap object that spans the data in "entry".
- */
-  FileMap createEntryFileMap(ZipEntryRO entry)
-  {
+   * Create a new FileMap object that spans the data in "entry".
+   */
+  FileMap createEntryFileMap(ZipEntryRO entry) {
     // final _ZipEntryRO *zipEntry = reinterpret_cast<_ZipEntryRO*>(entry);
     // const ZipEntry& ze = zipEntry->entry;
     // int fd = GetFileDescriptor(mHandle);
@@ -302,18 +301,18 @@ public class ZipFileRO {
    * This doesn't verify the data's CRC, which might be useful for
    * uncompressed data.  The caller should be able to manage it.
    */
-  boolean uncompressEntry(org.robolectric.res.android.ZipFileRO.ZipEntryRO entry, Object buffer, int size)
-  {
+  boolean uncompressEntry(
+      org.robolectric.res.android.ZipFileRO.ZipEntryRO entry, Object buffer, int size) {
     throw new UnsupportedOperationException("Implememnt me");
-//    ZipEntryRO *zipEntry = reinterpret_cast<ZipEntryRO*>(entry);
-//    final int error = ExtractToMemory(mHandle, &(zipEntry.entry),
-//    (uint8_t*) buffer, size);
-//    if (error) {
-//      ALOGW("ExtractToMemory failed with %s", ErrorCodeString(error));
-//      return false;
-//    }
-//
-//    return true;
+    //    ZipEntryRO *zipEntry = reinterpret_cast<ZipEntryRO*>(entry);
+    //    final int error = ExtractToMemory(mHandle, &(zipEntry.entry),
+    //    (uint8_t*) buffer, size);
+    //    if (error) {
+    //      ALOGW("ExtractToMemory failed with %s", ErrorCodeString(error));
+    //      return false;
+    //    }
+    //
+    //    return true;
   }
 
   /*
@@ -321,17 +320,16 @@ public class ZipFileRO {
    *
    * This doesn't verify the data's CRC, but probably should.
    */
-  boolean uncompressEntry(org.robolectric.res.android.ZipFileRO.ZipEntryRO entry, int fd)
-  {
+  boolean uncompressEntry(org.robolectric.res.android.ZipFileRO.ZipEntryRO entry, int fd) {
     throw new UnsupportedOperationException("Implememnt me");
-//    ZipEntryRO *zipEntry = reinterpret_cast<ZipEntryRO*>(entry);
-//    final int error = ExtractEntryToFile(mHandle, &(zipEntry.entry), fd);
-//    if (error) {
-//      ALOGW("ExtractToMemory failed with %s", ErrorCodeString(error));
-//      return false;
-//    }
-//
-//    return true;
+    //    ZipEntryRO *zipEntry = reinterpret_cast<ZipEntryRO*>(entry);
+    //    final int error = ExtractEntryToFile(mHandle, &(zipEntry.entry), fd);
+    //    if (error) {
+    //      ALOGW("ExtractToMemory failed with %s", ErrorCodeString(error));
+    //      return false;
+    //    }
+    //
+    //    return true;
   }
 
   static String String(String string) {
diff --git a/resources/src/main/java/org/robolectric/res/builder/XmlBlock.java b/resources/src/main/java/org/robolectric/res/builder/XmlBlock.java
index f98841ec9..4e4ee2375 100644
--- a/resources/src/main/java/org/robolectric/res/builder/XmlBlock.java
+++ b/resources/src/main/java/org/robolectric/res/builder/XmlBlock.java
@@ -12,8 +12,8 @@ import org.w3c.dom.Document;
 import org.xml.sax.SAXException;
 
 /**
- * An XML block is a parsed representation of a resource XML file. Similar in nature
- * to Android's XmlBlock class.
+ * An XML block is a parsed representation of a resource XML file. Similar in nature to Android's
+ * XmlBlock class.
  */
 public class XmlBlock {
 
@@ -38,11 +38,12 @@ public class XmlBlock {
     } catch (ParserConfigurationException | IOException | SAXException e) {
       throw new RuntimeException(e);
     } finally {
-      if (inputStream != null) try {
-        inputStream.close();
-      } catch (IOException e) {
-        // ignore
-      }
+      if (inputStream != null)
+        try {
+          inputStream.close();
+        } catch (IOException e) {
+          // ignore
+        }
     }
   }
 
diff --git a/resources/src/test/java/org/robolectric/manifest/ActivityDataTest.java b/resources/src/test/java/org/robolectric/manifest/ActivityDataTest.java
index 4f9b5b537..1b9c52096 100644
--- a/resources/src/test/java/org/robolectric/manifest/ActivityDataTest.java
+++ b/resources/src/test/java/org/robolectric/manifest/ActivityDataTest.java
@@ -15,7 +15,8 @@ public class ActivityDataTest {
   public void test_non_android_namespace() {
     HashMap<String, String> attrs = new HashMap<>();
     attrs.put("testns:name", ".test.TestActivity");
-    ActivityData activityData = new ActivityData("testns", attrs, new ArrayList<IntentFilterData>());
+    ActivityData activityData =
+        new ActivityData("testns", attrs, new ArrayList<IntentFilterData>());
 
     assertThat(activityData.getName()).isEqualTo(".test.TestActivity");
     assertThat(activityData.getAllAttributes().get("android:name")).isNull();
diff --git a/resources/src/test/java/org/robolectric/manifest/MetaDataTest.java b/resources/src/test/java/org/robolectric/manifest/MetaDataTest.java
index aa35ba960..c5c3be342 100644
--- a/resources/src/test/java/org/robolectric/manifest/MetaDataTest.java
+++ b/resources/src/test/java/org/robolectric/manifest/MetaDataTest.java
@@ -16,9 +16,7 @@ import org.robolectric.res.ResourceTable;
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
 
-/**
- * Tests for {@link MetaData}
- */
+/** Tests for {@link MetaData} */
 @RunWith(JUnit4.class)
 public class MetaDataTest {
 
diff --git a/resources/src/test/java/org/robolectric/res/QualifiersTest.java b/resources/src/test/java/org/robolectric/res/QualifiersTest.java
index ac0bdbbff..73dc0cd8b 100644
--- a/resources/src/test/java/org/robolectric/res/QualifiersTest.java
+++ b/resources/src/test/java/org/robolectric/res/QualifiersTest.java
@@ -22,7 +22,7 @@ public class QualifiersTest {
     try {
       configFrom("values-unknown-v23");
       fail("Expected exception");
-    } catch(IllegalArgumentException expected) {
+    } catch (IllegalArgumentException expected) {
       assertThat(expected.getMessage()).contains("failed to parse qualifiers 'unknown-v23");
     }
   }
@@ -31,8 +31,7 @@ public class QualifiersTest {
     Path xmlFile = Paths.get(path, "whatever.xml");
     Qualifiers qualifiers = Qualifiers.fromParentDir(xmlFile.getParent());
 
-    ResTable_config config = new XmlContext("package", xmlFile, qualifiers)
-        .getConfig();
+    ResTable_config config = new XmlContext("package", xmlFile, qualifiers).getConfig();
     return config.toString();
   }
 
@@ -51,7 +50,8 @@ public class QualifiersTest {
         .isEqualTo("en-sw480dp-v23");
   }
 
-  @Test public void addScreenWidth() throws Exception {
+  @Test
+  public void addScreenWidth() throws Exception {
     assertThat(Qualifiers.addScreenWidth("", 320)).isEqualTo("w320dp");
     assertThat(Qualifiers.addScreenWidth("w160dp", 320)).isEqualTo("w160dp");
     assertThat(Qualifiers.addScreenWidth("w480dp", 320)).isEqualTo("w480dp");
@@ -61,7 +61,8 @@ public class QualifiersTest {
     assertThat(Qualifiers.addScreenWidth("en-w480dp-v23", 320)).isEqualTo("en-w480dp-v23");
   }
 
-  @Test public void getSmallestScreenWidth() {
+  @Test
+  public void getSmallestScreenWidth() {
     assertThat(Qualifiers.getSmallestScreenWidth("sw320dp")).isEqualTo(320);
     assertThat(Qualifiers.getSmallestScreenWidth("sw320dp-v7")).isEqualTo(320);
     assertThat(Qualifiers.getSmallestScreenWidth("en-rUS-sw320dp")).isEqualTo(320);
@@ -70,12 +71,14 @@ public class QualifiersTest {
     assertThat(Qualifiers.getSmallestScreenWidth("en-rUS-w320dp-v7")).isEqualTo(-1);
   }
 
-  @Test public void getAddSmallestScreenWidth() {
+  @Test
+  public void getAddSmallestScreenWidth() {
     assertThat(Qualifiers.addSmallestScreenWidth("v7", 320)).isEqualTo("v7-sw320dp");
     assertThat(Qualifiers.addSmallestScreenWidth("sw320dp-v7", 480)).isEqualTo("sw320dp-v7");
   }
 
-  @Test public void getScreenWidth() {
+  @Test
+  public void getScreenWidth() {
     assertThat(Qualifiers.getScreenWidth("w320dp")).isEqualTo(320);
     assertThat(Qualifiers.getScreenWidth("w320dp-v7")).isEqualTo(320);
     assertThat(Qualifiers.getScreenWidth("en-rUS-w320dp")).isEqualTo(320);
@@ -85,12 +88,14 @@ public class QualifiersTest {
     assertThat(Qualifiers.getScreenWidth("en-rUS-sw320dp-v7")).isEqualTo(-1);
   }
 
-  @Test public void getAddScreenWidth() {
+  @Test
+  public void getAddScreenWidth() {
     assertThat(Qualifiers.addScreenWidth("v7", 320)).isEqualTo("v7-w320dp");
     assertThat(Qualifiers.addScreenWidth("w320dp-v7", 480)).isEqualTo("w320dp-v7");
   }
 
-  @Test public void getOrientation() {
+  @Test
+  public void getOrientation() {
     assertThat(Qualifiers.getOrientation("land")).isEqualTo("land");
     assertThat(Qualifiers.getOrientation("en-rUs-land")).isEqualTo("land");
     assertThat(Qualifiers.getOrientation("port")).isEqualTo("port");
diff --git a/resources/src/test/java/org/robolectric/res/ResTypeTest.java b/resources/src/test/java/org/robolectric/res/ResTypeTest.java
index a550b2c09..268b7e439 100644
--- a/resources/src/test/java/org/robolectric/res/ResTypeTest.java
+++ b/resources/src/test/java/org/robolectric/res/ResTypeTest.java
@@ -6,9 +6,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Tests for {@link ResType}
- */
+/** Tests for {@link ResType} */
 @RunWith(JUnit4.class)
 public class ResTypeTest {
 
diff --git a/resources/src/test/java/org/robolectric/res/ResourceIdsTest.java b/resources/src/test/java/org/robolectric/res/ResourceIdsTest.java
index 472c007d3..e9d522fb0 100644
--- a/resources/src/test/java/org/robolectric/res/ResourceIdsTest.java
+++ b/resources/src/test/java/org/robolectric/res/ResourceIdsTest.java
@@ -6,9 +6,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Tests for {@link ResourceIds}
- */
+/** Tests for {@link ResourceIds} */
 @RunWith(JUnit4.class)
 public class ResourceIdsTest {
   @Test
diff --git a/resources/src/test/java/org/robolectric/res/StaxValueLoaderTest.java b/resources/src/test/java/org/robolectric/res/StaxValueLoaderTest.java
index ca45ed4cc..e2507fba6 100644
--- a/resources/src/test/java/org/robolectric/res/StaxValueLoaderTest.java
+++ b/resources/src/test/java/org/robolectric/res/StaxValueLoaderTest.java
@@ -32,29 +32,42 @@ public class StaxValueLoaderTest {
 
   @Test
   public void ignoresXliffTags() throws Exception {
-    topLevelNodeHandler.addHandler("resources", new NodeHandler()
-        .addHandler("string", new StaxValueLoader(resourceTable, "string", ResType.CHAR_SEQUENCE))
-    );
+    topLevelNodeHandler.addHandler(
+        "resources",
+        new NodeHandler()
+            .addHandler(
+                "string", new StaxValueLoader(resourceTable, "string", ResType.CHAR_SEQUENCE)));
 
-    parse("<resources xmlns:xliff=\"urn:oasis:names:tc:xliff:document:1.2\">" +
-        "<string name=\"preposition_for_date\">on <xliff:g id=\"date\" example=\"May 29\">%s</xliff:g></string>" +
-        "</resources>");
+    parse(
+        "<resources xmlns:xliff=\"urn:oasis:names:tc:xliff:document:1.2\"><string"
+            + " name=\"preposition_for_date\">on <xliff:g id=\"date\" example=\"May"
+            + " 29\">%s</xliff:g></string></resources>");
 
-    assertThat(resourceTable.getValue(new ResName("pkg:string/preposition_for_date"), new ResTable_config()).getData())
+    assertThat(
+            resourceTable
+                .getValue(new ResName("pkg:string/preposition_for_date"), new ResTable_config())
+                .getData())
         .isEqualTo("on %s");
   }
 
   @Test
   public void ignoresBTags() throws Exception {
-    topLevelNodeHandler.addHandler("resources", new NodeHandler()
-        .addHandler("item[@type='string']", new StaxValueLoader(resourceTable, "string", ResType.CHAR_SEQUENCE))
-    );
+    topLevelNodeHandler.addHandler(
+        "resources",
+        new NodeHandler()
+            .addHandler(
+                "item[@type='string']",
+                new StaxValueLoader(resourceTable, "string", ResType.CHAR_SEQUENCE)));
 
-    parse("<resources xmlns:xliff=\"urn:oasis:names:tc:xliff:document:1.2\">" +
-        "<item type=\"string\" name=\"sms_short_code_details\">This <b>may cause charges</b> on your mobile account.</item>" +
-        "</resources>");
+    parse(
+        "<resources xmlns:xliff=\"urn:oasis:names:tc:xliff:document:1.2\"><item type=\"string\""
+            + " name=\"sms_short_code_details\">This <b>may cause charges</b> on your mobile"
+            + " account.</item></resources>");
 
-    assertThat(resourceTable.getValue(new ResName("pkg:string/sms_short_code_details"), new ResTable_config()).getData())
+    assertThat(
+            resourceTable
+                .getValue(new ResName("pkg:string/sms_short_code_details"), new ResTable_config())
+                .getData())
         .isEqualTo("This may cause charges on your mobile account.");
   }
 
@@ -65,4 +78,4 @@ public class StaxValueLoaderTest {
     Qualifiers qualifiers = Qualifiers.fromParentDir(path.getParent());
     staxDocumentLoader.doParse(xmlStreamReader, new XmlContext("pkg", path, qualifiers));
   }
-}
\ No newline at end of file
+}
diff --git a/resources/src/test/java/org/robolectric/res/StyleDataTest.java b/resources/src/test/java/org/robolectric/res/StyleDataTest.java
index 26f7cf50d..88730b082 100644
--- a/resources/src/test/java/org/robolectric/res/StyleDataTest.java
+++ b/resources/src/test/java/org/robolectric/res/StyleDataTest.java
@@ -11,14 +11,18 @@ import org.junit.runners.JUnit4;
 public class StyleDataTest {
 
   private final ResName androidSearchViewStyle = new ResName("android", "attr", "searchViewStyle");
-  private final ResName myLibSearchViewStyle = new ResName("library.resource", "attr", "searchViewStyle");
+  private final ResName myLibSearchViewStyle =
+      new ResName("library.resource", "attr", "searchViewStyle");
   private final ResName myAppSearchViewStyle = new ResName("my.app", "attr", "searchViewStyle");
 
   @Test
   public void getAttrValue_willFindLibraryResourcesWithSameName() {
-    StyleData styleData = new StyleData("library.resource", "Theme_MyApp", "Theme_Material", asList(
-        new AttributeResource(myLibSearchViewStyle, "lib_value", "library.resource")
-    ));
+    StyleData styleData =
+        new StyleData(
+            "library.resource",
+            "Theme_MyApp",
+            "Theme_Material",
+            asList(new AttributeResource(myLibSearchViewStyle, "lib_value", "library.resource")));
 
     assertThat(styleData.getAttrValue(myAppSearchViewStyle).value).isEqualTo("lib_value");
     assertThat(styleData.getAttrValue(myLibSearchViewStyle).value).isEqualTo("lib_value");
@@ -28,9 +32,12 @@ public class StyleDataTest {
 
   @Test
   public void getAttrValue_willNotFindFrameworkResourcesWithSameName() {
-    StyleData styleData = new StyleData("android", "Theme_Material", "Theme", asList(
-        new AttributeResource(androidSearchViewStyle, "android_value", "android")
-    ));
+    StyleData styleData =
+        new StyleData(
+            "android",
+            "Theme_Material",
+            "Theme",
+            asList(new AttributeResource(androidSearchViewStyle, "android_value", "android")));
 
     assertThat(styleData.getAttrValue(androidSearchViewStyle).value).isEqualTo("android_value");
 
@@ -40,26 +47,33 @@ public class StyleDataTest {
 
   @Test
   public void getAttrValue_willChooseBetweenAmbiguousAttributes() {
-    StyleData styleData = new StyleData("android", "Theme_Material", "Theme", asList(
-        new AttributeResource(myLibSearchViewStyle, "lib_value", "library.resource"),
-        new AttributeResource(androidSearchViewStyle, "android_value", "android")
-    ));
+    StyleData styleData =
+        new StyleData(
+            "android",
+            "Theme_Material",
+            "Theme",
+            asList(
+                new AttributeResource(myLibSearchViewStyle, "lib_value", "library.resource"),
+                new AttributeResource(androidSearchViewStyle, "android_value", "android")));
 
     assertThat(styleData.getAttrValue(androidSearchViewStyle).value).isEqualTo("android_value");
     assertThat(styleData.getAttrValue(myLibSearchViewStyle).value).isEqualTo("lib_value");
 
     // todo: any packageNames that aren't 'android' should be treated as equivalent
-//    assertThat(styleData.getAttrValue(myAppSearchViewStyle).value).isEqualTo("lib_value");
+    //    assertThat(styleData.getAttrValue(myAppSearchViewStyle).value).isEqualTo("lib_value");
   }
 
   @Test
   public void getAttrValue_willReturnTrimmedAttributeValues() throws Exception {
-    StyleData styleData = new StyleData("library.resource", "Theme_MyApp", "Theme_Material", asList(
-            new AttributeResource(myLibSearchViewStyle, "\n lib_value ", "library.resource")
-    ));
+    StyleData styleData =
+        new StyleData(
+            "library.resource",
+            "Theme_MyApp",
+            "Theme_Material",
+            asList(
+                new AttributeResource(myLibSearchViewStyle, "\n lib_value ", "library.resource")));
 
     assertThat(styleData.getAttrValue(myAppSearchViewStyle).value).isEqualTo("\n lib_value ");
     assertThat(styleData.getAttrValue(myLibSearchViewStyle).trimmedValue).isEqualTo("lib_value");
   }
-
 }
diff --git a/resources/src/test/java/org/robolectric/res/ThemeStyleSetTest.java b/resources/src/test/java/org/robolectric/res/ThemeStyleSetTest.java
index dd87b82e2..21b0d7f79 100644
--- a/resources/src/test/java/org/robolectric/res/ThemeStyleSetTest.java
+++ b/resources/src/test/java/org/robolectric/res/ThemeStyleSetTest.java
@@ -21,24 +21,34 @@ public class ThemeStyleSetTest {
   @Test
   public void shouldFindAttributesFromAnAppliedStyle() throws Exception {
     themeStyleSet = new ThemeStyleSet();
-    themeStyleSet.apply(createStyle("style1",
-        createAttribute("string1", "string1 value from style1"),
-        createAttribute("string2", "string2 value from style1")
-    ), false);
-    themeStyleSet.apply(createStyle("style2", createAttribute("string2", "string2 value from style2")), false);
-    assertThat(themeStyleSet.getAttrValue(attrName("string1")).value).isEqualTo("string1 value from style1");
-    assertThat(themeStyleSet.getAttrValue(attrName("string2")).value).isEqualTo("string2 value from style1");
+    themeStyleSet.apply(
+        createStyle(
+            "style1",
+            createAttribute("string1", "string1 value from style1"),
+            createAttribute("string2", "string2 value from style1")),
+        false);
+    themeStyleSet.apply(
+        createStyle("style2", createAttribute("string2", "string2 value from style2")), false);
+    assertThat(themeStyleSet.getAttrValue(attrName("string1")).value)
+        .isEqualTo("string1 value from style1");
+    assertThat(themeStyleSet.getAttrValue(attrName("string2")).value)
+        .isEqualTo("string2 value from style1");
   }
 
   @Test
   public void shouldFindAttributesFromAnAppliedFromForcedStyle() throws Exception {
-    themeStyleSet.apply(createStyle("style1",
-        createAttribute("string1", "string1 value from style1"),
-        createAttribute("string2", "string2 value from style1")
-    ), false);
-    themeStyleSet.apply(createStyle("style2", createAttribute("string1", "string1 value from style2")), true);
-    assertThat(themeStyleSet.getAttrValue(attrName("string1")).value).isEqualTo("string1 value from style2");
-    assertThat(themeStyleSet.getAttrValue(attrName("string2")).value).isEqualTo("string2 value from style1");
+    themeStyleSet.apply(
+        createStyle(
+            "style1",
+            createAttribute("string1", "string1 value from style1"),
+            createAttribute("string2", "string2 value from style1")),
+        false);
+    themeStyleSet.apply(
+        createStyle("style2", createAttribute("string1", "string1 value from style2")), true);
+    assertThat(themeStyleSet.getAttrValue(attrName("string1")).value)
+        .isEqualTo("string1 value from style2");
+    assertThat(themeStyleSet.getAttrValue(attrName("string2")).value)
+        .isEqualTo("string2 value from style1");
   }
 
   private StyleData createStyle(String styleName, AttributeResource... attributeResources) {
@@ -52,4 +62,4 @@ public class ThemeStyleSetTest {
   private ResName attrName(String attrName) {
     return new ResName("package", "attr", attrName);
   }
-}
\ No newline at end of file
+}
diff --git a/resources/src/test/java/org/robolectric/res/android/ConfigDescriptionTest.java b/resources/src/test/java/org/robolectric/res/android/ConfigDescriptionTest.java
index aa199d5a0..6439ef3ca 100644
--- a/resources/src/test/java/org/robolectric/res/android/ConfigDescriptionTest.java
+++ b/resources/src/test/java/org/robolectric/res/android/ConfigDescriptionTest.java
@@ -130,276 +130,321 @@ public class ConfigDescriptionTest {
     assertThat(config.smallestScreenWidthDp).isEqualTo(320);
   }
 
-  @Test public void getScreenWidth() {
+  @Test
+  public void getScreenWidth() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("w480dp", config);
     assertThat(config.screenWidthDp).isEqualTo(480);
   }
 
-  @Test public void getScreenHeight() {
+  @Test
+  public void getScreenHeight() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("h1024dp", config);
     assertThat(config.screenHeightDp).isEqualTo(1024);
   }
 
-  @Test public void parse_screenLayoutLong_notlong() {
+  @Test
+  public void parse_screenLayoutLong_notlong() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("notlong", config);
     assertThat(config.screenLayout).isEqualTo(SCREENLONG_NO);
   }
 
-  @Test public void parse_screenRound_round() {
+  @Test
+  public void parse_screenRound_round() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("round", config);
     assertThat(config.screenLayout2).isEqualTo((byte) SCREENROUND_YES);
   }
 
-  @Test public void parse_screenRound_notround() {
+  @Test
+  public void parse_screenRound_notround() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("notround", config);
     assertThat(config.screenLayout2).isEqualTo((byte) SCREENROUND_NO);
   }
 
-  @Test public void parse_orientation_port() {
+  @Test
+  public void parse_orientation_port() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("port", config);
     assertThat(config.orientation).isEqualTo(ORIENTATION_PORT);
   }
 
-  @Test public void parse_orientation_land() {
+  @Test
+  public void parse_orientation_land() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("land", config);
     assertThat(config.orientation).isEqualTo(ORIENTATION_LAND);
   }
 
-  @Test public void parse_orientation_square() {
+  @Test
+  public void parse_orientation_square() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("square", config);
     assertThat(config.orientation).isEqualTo(ORIENTATION_SQUARE);
   }
 
-  @Test public void parse_uiModeType_car() {
+  @Test
+  public void parse_uiModeType_car() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("car", config);
     assertThat(config.uiMode).isEqualTo(UI_MODE_TYPE_CAR);
   }
 
-  @Test public void parse_uiModeType_television() {
+  @Test
+  public void parse_uiModeType_television() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("television", config);
     assertThat(config.uiMode).isEqualTo(UI_MODE_TYPE_TELEVISION);
   }
 
-  @Test public void parse_uiModeType_appliance() {
+  @Test
+  public void parse_uiModeType_appliance() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("appliance", config);
     assertThat(config.uiMode).isEqualTo(UI_MODE_TYPE_APPLIANCE);
   }
 
-  @Test public void parse_uiModeType_watch() {
+  @Test
+  public void parse_uiModeType_watch() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("watch", config);
     assertThat(config.uiMode).isEqualTo(UI_MODE_TYPE_WATCH);
   }
 
-  @Test public void parse_uiModeNight_night() {
+  @Test
+  public void parse_uiModeNight_night() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("night", config);
     assertThat(config.uiMode).isEqualTo(UI_MODE_NIGHT_YES);
   }
 
-  @Test public void parse_uiModeNight_notnight() {
+  @Test
+  public void parse_uiModeNight_notnight() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("notnight", config);
     assertThat(config.uiMode).isEqualTo(UI_MODE_NIGHT_NO);
   }
 
-  @Test public void parse_density_any() {
+  @Test
+  public void parse_density_any() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("anydpi", config);
     assertThat(config.density).isEqualTo(DENSITY_ANY);
   }
 
-  @Test public void parse_density_nodpi() {
+  @Test
+  public void parse_density_nodpi() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("nodpi", config);
     assertThat(config.density).isEqualTo(DENSITY_NONE);
   }
 
-  @Test public void parse_density_ldpi() {
+  @Test
+  public void parse_density_ldpi() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("ldpi", config);
     assertThat(config.density).isEqualTo(DENSITY_LOW);
   }
 
-  @Test public void parse_density_mdpi() {
+  @Test
+  public void parse_density_mdpi() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("mdpi", config);
     assertThat(config.density).isEqualTo(DENSITY_MEDIUM);
   }
 
-  @Test public void parse_density_tvdpi() {
+  @Test
+  public void parse_density_tvdpi() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("tvdpi", config);
     assertThat(config.density).isEqualTo(DENSITY_TV);
   }
 
-  @Test public void parse_density_hdpi() {
+  @Test
+  public void parse_density_hdpi() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("hdpi", config);
     assertThat(config.density).isEqualTo(DENSITY_HIGH);
   }
 
-  @Test public void parse_density_xhdpi() {
+  @Test
+  public void parse_density_xhdpi() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("xhdpi", config);
     assertThat(config.density).isEqualTo(DENSITY_XHIGH);
   }
 
-  @Test public void parse_density_xxhdpi() {
+  @Test
+  public void parse_density_xxhdpi() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("xxhdpi", config);
     assertThat(config.density).isEqualTo(DENSITY_XXHIGH);
   }
 
-  @Test public void parse_density_xxxhdpi() {
+  @Test
+  public void parse_density_xxxhdpi() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("xxxhdpi", config);
     assertThat(config.density).isEqualTo(DENSITY_XXXHIGH);
   }
 
-  @Test public void parsedensity_specificDpt() {
+  @Test
+  public void parsedensity_specificDpt() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("720dpi", config);
     assertThat(config.density).isEqualTo(720);
   }
 
-  @Test public void parse_touchscreen_notouch() {
+  @Test
+  public void parse_touchscreen_notouch() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("notouch", config);
     assertThat(config.touchscreen).isEqualTo(TOUCHSCREEN_NOTOUCH);
   }
 
-  @Test public void parse_touchscreen_stylus() {
+  @Test
+  public void parse_touchscreen_stylus() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("stylus", config);
     assertThat(config.touchscreen).isEqualTo(TOUCHSCREEN_STYLUS);
   }
 
-  @Test public void parse_touchscreen_finger() {
+  @Test
+  public void parse_touchscreen_finger() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("finger", config);
     assertThat(config.touchscreen).isEqualTo(TOUCHSCREEN_FINGER);
   }
 
-  @Test public void parse_keysHidden_keysexposed() {
+  @Test
+  public void parse_keysHidden_keysexposed() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("keysexposed", config);
     assertThat(config.inputFlags).isEqualTo(KEYSHIDDEN_NO);
   }
 
-  @Test public void parse_keysHidden_keyshidden() {
+  @Test
+  public void parse_keysHidden_keyshidden() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("keyshidden", config);
     assertThat(config.inputFlags).isEqualTo(KEYSHIDDEN_YES);
   }
 
-  @Test public void parse_keysHidden_keyssoft() {
+  @Test
+  public void parse_keysHidden_keyssoft() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("keyssoft", config);
     assertThat(config.inputFlags).isEqualTo(KEYSHIDDEN_SOFT);
   }
 
-  @Test public void parse_keyboard_nokeys() {
+  @Test
+  public void parse_keyboard_nokeys() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("nokeys", config);
     assertThat(config.keyboard).isEqualTo(KEYBOARD_NOKEYS);
   }
 
-  @Test public void parse_keyboard_qwerty() {
+  @Test
+  public void parse_keyboard_qwerty() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("qwerty", config);
     assertThat(config.keyboard).isEqualTo(KEYBOARD_QWERTY);
   }
 
-  @Test public void parse_keyboard_12key() {
+  @Test
+  public void parse_keyboard_12key() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("12key", config);
     assertThat(config.keyboard).isEqualTo(KEYBOARD_12KEY);
   }
 
-  @Test public void parse_navHidden_navexposed() {
+  @Test
+  public void parse_navHidden_navexposed() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("navexposed", config);
     assertThat(config.inputFlags).isEqualTo(NAVHIDDEN_NO);
   }
 
-  @Test public void parse_navHidden_navhidden() {
+  @Test
+  public void parse_navHidden_navhidden() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("navhidden", config);
     assertThat(config.inputFlags).isEqualTo(NAVHIDDEN_YES);
   }
 
-  @Test public void parse_navigation_nonav() {
+  @Test
+  public void parse_navigation_nonav() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("nonav", config);
     assertThat(config.navigation).isEqualTo(NAVIGATION_NONAV);
   }
 
-  @Test public void parse_navigation_dpad() {
+  @Test
+  public void parse_navigation_dpad() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("dpad", config);
     assertThat(config.navigation).isEqualTo(NAVIGATION_DPAD);
   }
 
-  @Test public void parse_navigation_trackball() {
+  @Test
+  public void parse_navigation_trackball() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("trackball", config);
     assertThat(config.navigation).isEqualTo(NAVIGATION_TRACKBALL);
   }
 
-  @Test public void parse_navigation_wheel() {
+  @Test
+  public void parse_navigation_wheel() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("wheel", config);
     assertThat(config.navigation).isEqualTo(NAVIGATION_WHEEL);
   }
 
-  @Test public void parse_screenSize() {
+  @Test
+  public void parse_screenSize() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("480x320", config);
     assertThat(config.screenWidth).isEqualTo(480);
     assertThat(config.screenHeight).isEqualTo(320);
   }
 
-  @Test public void parse_screenSize_ignoreWidthLessThanHeight() {
+  @Test
+  public void parse_screenSize_ignoreWidthLessThanHeight() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("320x480", config);
     assertThat(config.screenWidth).isEqualTo(0);
     assertThat(config.screenHeight).isEqualTo(0);
   }
 
-  @Test public void parse_version() {
+  @Test
+  public void parse_version() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("v12", config);
     assertThat(config.sdkVersion).isEqualTo(12);
     assertThat(config.minorVersion).isEqualTo(0);
   }
 
-  @Test public void parse_language() {
+  @Test
+  public void parse_language() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("en", config);
     assertThat(config.languageString()).isEqualTo("en");
     assertThat(config.minorVersion).isEqualTo(0);
   }
 
-  @Test public void parse_languageAndRegion() {
+  @Test
+  public void parse_languageAndRegion() {
     ResTable_config config = new ResTable_config();
     ConfigDescription.parse("fr-rFR", config);
     assertThat(config.languageString()).isEqualTo("fr");
     assertThat(config.regionString()).isEqualTo("FR");
   }
 
-  @Test public void parse_multipleQualifiers() {
+  @Test
+  public void parse_multipleQualifiers() {
     ResTable_config config = new ResTable_config();
     assertThat(ConfigDescription.parse("en-rUS-sw320dp-v7", config)).isTrue();
     assertThat(config.languageString()).isEqualTo("en");
@@ -408,7 +453,8 @@ public class ConfigDescriptionTest {
     assertThat(config.sdkVersion).isEqualTo(ConfigDescription.SDK_HONEYCOMB_MR2);
   }
 
-  @Test public void parse_multipleQualifiers_outOfOrder() {
+  @Test
+  public void parse_multipleQualifiers_outOfOrder() {
     ResTable_config config = new ResTable_config();
     assertThat(ConfigDescription.parse("v7-en-rUS-sw320dp", config)).isFalse();
   }
diff --git a/resources/src/test/java/org/robolectric/res/android/ResTableConfigTest.java b/resources/src/test/java/org/robolectric/res/android/ResTableConfigTest.java
index ad7b5c7b4..d7ff37bc3 100644
--- a/resources/src/test/java/org/robolectric/res/android/ResTableConfigTest.java
+++ b/resources/src/test/java/org/robolectric/res/android/ResTableConfigTest.java
@@ -1,4 +1,3 @@
-
 package org.robolectric.res.android;
 
 import static com.google.common.truth.Truth.assertThat;
@@ -13,99 +12,157 @@ public class ResTableConfigTest {
   public static final int MCC_US_CARRIER = 310;
   public static final int MCC_US_VERIZON = 4;
   public static final byte[] LANGUAGE_FRENCH = new byte[] {'f', 'r'};
-  private static final byte[] LANGUAGE_SPANISH = new byte[]{'e', 's'};
+  private static final byte[] LANGUAGE_SPANISH = new byte[] {'e', 's'};
 
   @Test
   public void isBetterThan_emptyConfig() {
     // When a configuration is not specified the result is always false
-    assertThat(newBuilder().build().isBetterThan(newBuilder().build(), newBuilder().build())).isFalse();
+    assertThat(newBuilder().build().isBetterThan(newBuilder().build(), newBuilder().build()))
+        .isFalse();
   }
 
   /**
    * https://developer.android.com/guide/topics/resources/providing-resources.html#MccQualifier
+   *
    * @see <a href="http://mcc-mnc.com/">http://mcc-mnc.com/</a>
    */
   @Test
   public void isBetterThan_mcc() {
     // When requested is less of a match
-    assertThat(newBuilder().setMcc(MCC_US_CARRIER).build()
-        .isBetterThan(newBuilder().setMcc(MCC_US_CARRIER).build(), newBuilder().build()))
+    assertThat(
+            newBuilder()
+                .setMcc(MCC_US_CARRIER)
+                .build()
+                .isBetterThan(newBuilder().setMcc(MCC_US_CARRIER).build(), newBuilder().build()))
         .isFalse();
 
     // When requested is a better match
-    assertThat(newBuilder().setMcc(MCC_US_CARRIER).build()
-        .isBetterThan(newBuilder().build(), newBuilder().setMcc(MCC_US_CARRIER).build()))
+    assertThat(
+            newBuilder()
+                .setMcc(MCC_US_CARRIER)
+                .build()
+                .isBetterThan(newBuilder().build(), newBuilder().setMcc(MCC_US_CARRIER).build()))
         .isTrue();
   }
 
   /**
    * https://developer.android.com/guide/topics/resources/providing-resources.html#MccQualifier
+   *
    * @see <a href="http://mcc-mnc.com/">http://mcc-mnc.com/</a>
    */
   @Test
   public void isBetterThan_mnc() {
     // When a configuration is not specified the result is always false
-    assertThat(newBuilder().build().isBetterThan(newBuilder().build(), newBuilder().build())).isFalse();
+    assertThat(newBuilder().build().isBetterThan(newBuilder().build(), newBuilder().build()))
+        .isFalse();
 
     // When requested is less of a match
-    assertThat(newBuilder().setMcc(MCC_US_CARRIER).setMnc(MCC_US_VERIZON).build()
-        .isBetterThan(newBuilder().setMcc(MCC_US_CARRIER).build(), newBuilder().build()))
+    assertThat(
+            newBuilder()
+                .setMcc(MCC_US_CARRIER)
+                .setMnc(MCC_US_VERIZON)
+                .build()
+                .isBetterThan(newBuilder().setMcc(MCC_US_CARRIER).build(), newBuilder().build()))
         .isFalse();
 
     // When requested is a better match - any US Carrier is a better match to US + Verizon
-    assertThat(newBuilder().setMcc(MCC_US_CARRIER).setMnc(MCC_US_VERIZON).build()
-        .isBetterThan(newBuilder().build(), newBuilder().setMcc(MCC_US_CARRIER).build()))
+    assertThat(
+            newBuilder()
+                .setMcc(MCC_US_CARRIER)
+                .setMnc(MCC_US_VERIZON)
+                .build()
+                .isBetterThan(newBuilder().build(), newBuilder().setMcc(MCC_US_CARRIER).build()))
         .isTrue();
 
     // When requested is a better match - any US Carrier is a better match to US + Verizon
-    assertThat(newBuilder().setMcc(MCC_US_CARRIER).setMnc(MCC_US_VERIZON).build()
-        .isBetterThan(newBuilder().setMcc(MCC_US_CARRIER).build(), newBuilder().setMcc(MCC_US_CARRIER).setMnc(MCC_US_VERIZON).build()))
+    assertThat(
+            newBuilder()
+                .setMcc(MCC_US_CARRIER)
+                .setMnc(MCC_US_VERIZON)
+                .build()
+                .isBetterThan(
+                    newBuilder().setMcc(MCC_US_CARRIER).build(),
+                    newBuilder().setMcc(MCC_US_CARRIER).setMnc(MCC_US_VERIZON).build()))
         .isTrue();
 
     // When requested is a better match - any US Carrier is not a better match to US + Verizon
-    assertThat(newBuilder().setMcc(MCC_US_CARRIER).setMnc(MCC_US_VERIZON).build()
-        .isBetterThan(newBuilder().setMcc(MCC_US_CARRIER).setMnc(MCC_US_VERIZON).build(), newBuilder().setMcc(MCC_US_CARRIER).build()))
+    assertThat(
+            newBuilder()
+                .setMcc(MCC_US_CARRIER)
+                .setMnc(MCC_US_VERIZON)
+                .build()
+                .isBetterThan(
+                    newBuilder().setMcc(MCC_US_CARRIER).setMnc(MCC_US_VERIZON).build(),
+                    newBuilder().setMcc(MCC_US_CARRIER).build()))
         .isFalse();
   }
 
   @Test
   public void isBetterThan_language() {
     // When requested has no language, is not a better match
-    assertThat(newBuilder().setLanguage(LANGUAGE_FRENCH).build()
-        .isBetterThan(newBuilder().setLanguage(LANGUAGE_FRENCH).build(), newBuilder().build()))
+    assertThat(
+            newBuilder()
+                .setLanguage(LANGUAGE_FRENCH)
+                .build()
+                .isBetterThan(
+                    newBuilder().setLanguage(LANGUAGE_FRENCH).build(), newBuilder().build()))
         .isFalse();
   }
 
   @Test
   public void isBetterThan_language_comparedNotSame_requestedEnglish() {
     // When requested has no language, is not a better match
-    assertThat(newBuilder().setLanguage(LANGUAGE_FRENCH).build()
-        .isBetterThan(newBuilder().setLanguage(LANGUAGE_SPANISH).build(), newBuilder().setLanguage(
-            ResTable_config.kEnglish).build()))
+    assertThat(
+            newBuilder()
+                .setLanguage(LANGUAGE_FRENCH)
+                .build()
+                .isBetterThan(
+                    newBuilder().setLanguage(LANGUAGE_SPANISH).build(),
+                    newBuilder().setLanguage(ResTable_config.kEnglish).build()))
         .isTrue();
   }
 
   @Test
   public void isBetterThan_language_comparedNotSame_requestedEnglishUS() {
     // When requested has no language, is not a better match
-    assertThat(newBuilder().setLanguage(LANGUAGE_FRENCH).build()
-        .isBetterThan(newBuilder().setLanguage(LANGUAGE_SPANISH).build(), newBuilder().setLanguage(
-            ResTable_config.kEnglish).build()))
+    assertThat(
+            newBuilder()
+                .setLanguage(LANGUAGE_FRENCH)
+                .build()
+                .isBetterThan(
+                    newBuilder().setLanguage(LANGUAGE_SPANISH).build(),
+                    newBuilder().setLanguage(ResTable_config.kEnglish).build()))
         .isTrue();
   }
 
   @Test
   public void isBetterThan_layoutDirection_() {
     // Requested matches this configuration
-    assertThat(newBuilder().setLayoutDirection(ResTable_config.SCREENLAYOUT_LAYOUTDIR_RTL).build()
-        .isBetterThan(newBuilder().setLayoutDirection(ResTable_config.SCREENLAYOUT_LAYOUTDIR_LTR).build(),
-            newBuilder().setLayoutDirection(ResTable_config.SCREENLAYOUT_LAYOUTDIR_RTL).build()))
+    assertThat(
+            newBuilder()
+                .setLayoutDirection(ResTable_config.SCREENLAYOUT_LAYOUTDIR_RTL)
+                .build()
+                .isBetterThan(
+                    newBuilder()
+                        .setLayoutDirection(ResTable_config.SCREENLAYOUT_LAYOUTDIR_LTR)
+                        .build(),
+                    newBuilder()
+                        .setLayoutDirection(ResTable_config.SCREENLAYOUT_LAYOUTDIR_RTL)
+                        .build()))
         .isTrue();
 
     // Requested matches this configuration
-    assertThat(newBuilder().setLayoutDirection(ResTable_config.SCREENLAYOUT_LAYOUTDIR_LTR).build()
-        .isBetterThan(newBuilder().setLayoutDirection(ResTable_config.SCREENLAYOUT_LAYOUTDIR_RTL).build(),
-            newBuilder().setLayoutDirection(ResTable_config.SCREENLAYOUT_LAYOUTDIR_RTL).build()))
+    assertThat(
+            newBuilder()
+                .setLayoutDirection(ResTable_config.SCREENLAYOUT_LAYOUTDIR_LTR)
+                .build()
+                .isBetterThan(
+                    newBuilder()
+                        .setLayoutDirection(ResTable_config.SCREENLAYOUT_LAYOUTDIR_RTL)
+                        .build(),
+                    newBuilder()
+                        .setLayoutDirection(ResTable_config.SCREENLAYOUT_LAYOUTDIR_RTL)
+                        .build()))
         .isFalse();
   }
 
@@ -114,36 +171,59 @@ public class ResTableConfigTest {
   }
 
   private static class ResTableConfigBuilder {
-        int mcc;
-        int mnc;
-        byte[] language = new byte[2];
-        byte[] region = new byte[2];
-        int orientation;
-        int touchscreen;
-        int density;
-        int keyboard;
-        int navigation;
-        int inputFlags;
-        int screenWidth;
-        int screenHeight;
-        int sdkVersion;
-        int minorVersion;
-        int screenLayout;
-        int uiMode;
-        int smallestScreenWidthDp;
-        int screenWidthDp;
-        int screenHeightDp;
-        byte[] localeScript = new byte[4];
-        byte[] localeVariant = new byte[8];
-        byte screenLayout2;
-        byte screenConfigPad1;
-        short screenConfigPad2;
+    int mcc;
+    int mnc;
+    byte[] language = new byte[2];
+    byte[] region = new byte[2];
+    int orientation;
+    int touchscreen;
+    int density;
+    int keyboard;
+    int navigation;
+    int inputFlags;
+    int screenWidth;
+    int screenHeight;
+    int sdkVersion;
+    int minorVersion;
+    int screenLayout;
+    int uiMode;
+    int smallestScreenWidthDp;
+    int screenWidthDp;
+    int screenHeightDp;
+    byte[] localeScript = new byte[4];
+    byte[] localeVariant = new byte[8];
+    byte screenLayout2;
+    byte screenConfigPad1;
+    short screenConfigPad2;
 
     ResTable_config build() {
-      return new ResTable_config(0, mcc, mnc, language, region, orientation, touchscreen, density, keyboard, navigation, inputFlags, screenWidth,
-          screenHeight, sdkVersion, minorVersion, screenLayout, uiMode, smallestScreenWidthDp, screenWidthDp, screenHeightDp, localeScript, localeVariant, screenLayout2,
-          screenConfigPad1, screenConfigPad2, null
-      );
+      return new ResTable_config(
+          0,
+          mcc,
+          mnc,
+          language,
+          region,
+          orientation,
+          touchscreen,
+          density,
+          keyboard,
+          navigation,
+          inputFlags,
+          screenWidth,
+          screenHeight,
+          sdkVersion,
+          minorVersion,
+          screenLayout,
+          uiMode,
+          smallestScreenWidthDp,
+          screenWidthDp,
+          screenHeightDp,
+          localeScript,
+          localeVariant,
+          screenLayout2,
+          screenConfigPad1,
+          screenConfigPad2,
+          null);
     }
 
     public ResTableConfigBuilder setMcc(int mcc) {
diff --git a/resources/src/test/java/org/robolectric/res/android/ResTable_configTest.java b/resources/src/test/java/org/robolectric/res/android/ResTable_configTest.java
index 501e52dcf..7ba8f01d5 100644
--- a/resources/src/test/java/org/robolectric/res/android/ResTable_configTest.java
+++ b/resources/src/test/java/org/robolectric/res/android/ResTable_configTest.java
@@ -17,8 +17,7 @@ public class ResTable_configTest {
     resTable_config.country[0] = 'u';
     resTable_config.country[1] = 'k';
 
-    assertThat(resTable_config.locale())
-        .isEqualTo(('e' << 24) | ('n' << 16) | ('u' << 8) | 'k');
+    assertThat(resTable_config.locale()).isEqualTo(('e' << 24) | ('n' << 16) | ('u' << 8) | 'k');
   }
 
   @Test
diff --git a/resources/src/test/java/org/robolectric/resources/R.java b/resources/src/test/java/org/robolectric/resources/R.java
index ea007c348..733d41b51 100644
--- a/resources/src/test/java/org/robolectric/resources/R.java
+++ b/resources/src/test/java/org/robolectric/resources/R.java
@@ -8,18 +8,19 @@
 package org.robolectric.resources;
 
 public final class R {
-    public static final class attr {
-    }
-    public static final class bool {
-        /**  mcc310 = US Carrier mnc=004 = Verizon
-         */
-        public static final int is_verizon=0x7f020000;
-    }
-    public static final class integer {
-        public static final int flock_size=0x7f030000;
-    }
-    public static final class string {
-        public static final int first_string=0x7f040000;
-        public static final int second_string=0x7f040001;
-    }
+  public static final class attr {}
+
+  public static final class bool {
+    /** mcc310 = US Carrier mnc=004 = Verizon */
+    public static final int is_verizon = 0x7f020000;
+  }
+
+  public static final class integer {
+    public static final int flock_size = 0x7f030000;
+  }
+
+  public static final class string {
+    public static final int first_string = 0x7f040000;
+    public static final int second_string = 0x7f040001;
+  }
 }
diff --git a/robolectric/build.gradle b/robolectric/build.gradle
index 859504e6d..8393d29b0 100644
--- a/robolectric/build.gradle
+++ b/robolectric/build.gradle
@@ -1,8 +1,7 @@
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
-apply plugin: DeployedRoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+}
 
 dependencies {
     annotationProcessor libs.auto.service
@@ -38,7 +37,6 @@ dependencies {
     testImplementation libs.androidx.annotation
     testImplementation libs.junit4
     testImplementation libs.truth
-    testImplementation libs.truth.java8.extension
     testImplementation libs.mockito
     testImplementation libs.hamcrest.junit
     testImplementation "androidx.test:core:$axtCoreVersion@aar"
diff --git a/robolectric/src/main/java/org/robolectric/ApkLoader.java b/robolectric/src/main/java/org/robolectric/ApkLoader.java
deleted file mode 100644
index ee9c9ea7f..000000000
--- a/robolectric/src/main/java/org/robolectric/ApkLoader.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package org.robolectric;
-
-import java.util.HashMap;
-import java.util.Map;
-import javax.annotation.Nonnull;
-import org.robolectric.manifest.AndroidManifest;
-import org.robolectric.res.PackageResourceTable;
-import org.robolectric.res.ResourceMerger;
-import org.robolectric.res.ResourcePath;
-import org.robolectric.res.ResourceTableFactory;
-
-/**
- * Mediates loading of "APKs" in legacy mode.
- */
-public class ApkLoader {
-
-  private final Map<AndroidManifest, PackageResourceTable> appResourceTableCache = new HashMap<>();
-  private PackageResourceTable compiletimeSdkResourceTable;
-
-  synchronized public PackageResourceTable getAppResourceTable(final AndroidManifest appManifest) {
-    PackageResourceTable resourceTable = appResourceTableCache.get(appManifest);
-    if (resourceTable == null) {
-      resourceTable = new ResourceMerger().buildResourceTable(appManifest);
-
-      appResourceTableCache.put(appManifest, resourceTable);
-    }
-    return resourceTable;
-  }
-
-  /**
-   * Returns the ResourceTable for the compile time SDK.
-   */
-  @Nonnull
-  synchronized public PackageResourceTable getCompileTimeSdkResourceTable() {
-    if (compiletimeSdkResourceTable == null) {
-      ResourceTableFactory resourceTableFactory = new ResourceTableFactory();
-      compiletimeSdkResourceTable = resourceTableFactory
-          .newFrameworkResourceTable(new ResourcePath(android.R.class, null, null));
-    }
-    return compiletimeSdkResourceTable;
-  }
-}
diff --git a/robolectric/src/main/java/org/robolectric/ConfigMerger.java b/robolectric/src/main/java/org/robolectric/ConfigMerger.java
index b2b5a8ae8..0e47fed4d 100644
--- a/robolectric/src/main/java/org/robolectric/ConfigMerger.java
+++ b/robolectric/src/main/java/org/robolectric/ConfigMerger.java
@@ -30,12 +30,13 @@ import org.robolectric.util.Join;
  */
 @Deprecated
 public class ConfigMerger {
-  private final Map<String, Config> packageConfigCache = new LinkedHashMap<String, Config>() {
-    @Override
-    protected boolean removeEldestEntry(Map.Entry eldest) {
-      return size() > 10;
-    }
-  };
+  private final Map<String, Config> packageConfigCache =
+      new LinkedHashMap<String, Config>() {
+        @Override
+        protected boolean removeEldestEntry(Map.Entry eldest) {
+          return size() > 10;
+        }
+      };
 
   /**
    * Calculate the {@link Config} for the given test.
@@ -69,14 +70,15 @@ public class ConfigMerger {
   /**
    * Generate {@link Config} for the specified package.
    *
-   * More specific packages, test classes, and test method configurations
-   * will override values provided here.
+   * <p>More specific packages, test classes, and test method configurations will override values
+   * provided here.
    *
-   * The default implementation uses properties provided by {@link #getConfigProperties(String)}.
+   * <p>The default implementation uses properties provided by {@link #getConfigProperties(String)}.
    *
-   * The returned object is likely to be reused for many tests.
+   * <p>The returned object is likely to be reused for many tests.
    *
-   * @param packageName the name of the package, or empty string ({@code ""}) for the top level package
+   * @param packageName the name of the package, or empty string ({@code ""}) for the top level
+   *     package
    * @return {@link Config} object for the specified package
    * @since 3.2
    */
@@ -86,7 +88,8 @@ public class ConfigMerger {
   }
 
   /**
-   * Return a {@link Properties} file for the given package name, or {@code null} if none is available.
+   * Return a {@link Properties} file for the given package name, or {@code null} if none is
+   * available.
    *
    * @since 3.2
    */
@@ -104,7 +107,8 @@ public class ConfigMerger {
     }
   }
 
-  @Nonnull @VisibleForTesting
+  @Nonnull
+  @VisibleForTesting
   List<String> packageHierarchyOf(Class<?> javaClass) {
     Package aPackage = javaClass.getPackage();
     String testPackageName = aPackage == null ? "" : aPackage.getName();
diff --git a/robolectric/src/main/java/org/robolectric/Robolectric.java b/robolectric/src/main/java/org/robolectric/Robolectric.java
index 6d43fc46a..41f312daf 100644
--- a/robolectric/src/main/java/org/robolectric/Robolectric.java
+++ b/robolectric/src/main/java/org/robolectric/Robolectric.java
@@ -20,6 +20,7 @@ import android.os.Bundle;
 import android.os.Looper;
 import android.util.AttributeSet;
 import android.view.View;
+import java.lang.reflect.Modifier;
 import javax.annotation.Nullable;
 import org.robolectric.android.AttributeSetBuilderImpl;
 import org.robolectric.android.AttributeSetBuilderImpl.ArscResourceResolver;
@@ -40,7 +41,8 @@ public class Robolectric {
     return buildService(serviceClass, null);
   }
 
-  public static <T extends Service> ServiceController<T> buildService(Class<T> serviceClass, Intent intent) {
+  public static <T extends Service> ServiceController<T> buildService(
+      Class<T> serviceClass, Intent intent) {
     return ServiceController.of(instantiateService(serviceClass, intent), intent);
   }
 
@@ -48,11 +50,13 @@ public class Robolectric {
     return buildService(serviceClass).create().get();
   }
 
-  public static <T extends IntentService> IntentServiceController<T> buildIntentService(Class<T> serviceClass) {
+  public static <T extends IntentService> IntentServiceController<T> buildIntentService(
+      Class<T> serviceClass) {
     return buildIntentService(serviceClass, null);
   }
 
-  public static <T extends IntentService> IntentServiceController<T> buildIntentService(Class<T> serviceClass, Intent intent) {
+  public static <T extends IntentService> IntentServiceController<T> buildIntentService(
+      Class<T> serviceClass, Intent intent) {
     return IntentServiceController.of(instantiateService(serviceClass, intent), intent);
   }
 
@@ -60,7 +64,8 @@ public class Robolectric {
     return buildIntentService(serviceClass).create().get();
   }
 
-  public static <T extends ContentProvider> ContentProviderController<T> buildContentProvider(Class<T> contentProviderClass) {
+  public static <T extends ContentProvider> ContentProviderController<T> buildContentProvider(
+      Class<T> contentProviderClass) {
     return ContentProviderController.of(instantiateContentProvider(contentProviderClass));
   }
 
@@ -68,7 +73,8 @@ public class Robolectric {
     return buildContentProvider(contentProviderClass).create().get();
   }
 
-  public static <T extends ContentProvider> T setupContentProvider(Class<T> contentProviderClass, String authority) {
+  public static <T extends ContentProvider> T setupContentProvider(
+      Class<T> contentProviderClass, String authority) {
     return buildContentProvider(contentProviderClass).create(authority).get();
   }
 
@@ -114,6 +120,9 @@ public class Robolectric {
     checkState(
         Thread.currentThread() == Looper.getMainLooper().getThread(),
         "buildActivity must be called on main Looper thread");
+    if (Modifier.isAbstract(activityClass.getModifiers())) {
+      throw new RuntimeException("buildActivity must be called with non-abstract class");
+    }
     return ActivityController.of(
         instantiateActivity(activityClass, intent), intent, activityOptions);
   }
@@ -218,7 +227,8 @@ public class Robolectric {
   @Deprecated
   public static <T extends Fragment> FragmentController<T> buildFragment(
       Class<T> fragmentClass, Intent intent, Bundle arguments) {
-    return FragmentController.of(ReflectionHelpers.callConstructor(fragmentClass), intent, arguments);
+    return FragmentController.of(
+        ReflectionHelpers.callConstructor(fragmentClass), intent, arguments);
   }
 
   /**
@@ -241,7 +251,8 @@ public class Robolectric {
   @Deprecated
   public static <T extends Fragment> FragmentController<T> buildFragment(
       Class<T> fragmentClass, Class<? extends Activity> activityClass, Intent intent) {
-    return FragmentController.of(ReflectionHelpers.callConstructor(fragmentClass), activityClass, intent);
+    return FragmentController.of(
+        ReflectionHelpers.callConstructor(fragmentClass), activityClass, intent);
   }
 
   /**
@@ -262,7 +273,8 @@ public class Robolectric {
   @Deprecated
   public static <T extends Fragment> FragmentController<T> buildFragment(
       Class<T> fragmentClass, Class<? extends Activity> activityClass, Bundle arguments) {
-    return FragmentController.of(ReflectionHelpers.callConstructor(fragmentClass), activityClass, arguments);
+    return FragmentController.of(
+        ReflectionHelpers.callConstructor(fragmentClass), activityClass, arguments);
   }
 
   /**
@@ -288,10 +300,12 @@ public class Robolectric {
       Class<? extends Activity> activityClass,
       Intent intent,
       Bundle arguments) {
-    return FragmentController.of(ReflectionHelpers.callConstructor(fragmentClass), activityClass, intent, arguments);
+    return FragmentController.of(
+        ReflectionHelpers.callConstructor(fragmentClass), activityClass, intent, arguments);
   }
 
-  public static <T extends BackupAgent> BackupAgentController<T> buildBackupAgent(Class<T> backupAgentClass) {
+  public static <T extends BackupAgent> BackupAgentController<T> buildBackupAgent(
+      Class<T> backupAgentClass) {
     return BackupAgentController.of(ReflectionHelpers.callConstructor(backupAgentClass));
   }
 
@@ -302,13 +316,12 @@ public class Robolectric {
   /**
    * Allows for the programmatic creation of an {@link AttributeSet}.
    *
-   * Useful for testing {@link View} classes without the need for creating XML snippets.
+   * <p>Useful for testing {@link View} classes without the need for creating XML snippets.
    */
   public static org.robolectric.android.AttributeSetBuilder buildAttributeSet() {
 
-      return new AttributeSetBuilderImpl(
-          new ArscResourceResolver(RuntimeEnvironment.getApplication())) {};
-
+    return new AttributeSetBuilderImpl(
+        new ArscResourceResolver(RuntimeEnvironment.getApplication())) {};
   }
 
   /**
@@ -321,7 +334,7 @@ public class Robolectric {
     /**
      * Set an attribute to the given value.
      *
-     * The value will be interpreted according to the attribute's format.
+     * <p>The value will be interpreted according to the attribute's format.
      *
      * @param resId The attribute resource id to set.
      * @param value The value to set.
@@ -332,7 +345,7 @@ public class Robolectric {
     /**
      * Set the style attribute to the given value.
      *
-     * The value will be interpreted as a resource reference.
+     * <p>The value will be interpreted as a resource reference.
      *
      * @param value The value for the specified attribute in this {@link AttributeSet}.
      * @return This {@link org.robolectric.android.AttributeSetBuilder}.
@@ -356,9 +369,7 @@ public class Robolectric {
     return RuntimeEnvironment.getMasterScheduler();
   }
 
-  /**
-   * Execute all runnables that have been enqueued on the foreground scheduler.
-   */
+  /** Execute all runnables that have been enqueued on the foreground scheduler. */
   public static void flushForegroundThreadScheduler() {
     getForegroundThreadScheduler().advanceToLastPostedRunnable();
   }
@@ -372,9 +383,7 @@ public class Robolectric {
     return ShadowApplication.getInstance().getBackgroundThreadScheduler();
   }
 
-  /**
-   * Execute all runnables that have been enqueued on the background scheduler.
-   */
+  /** Execute all runnables that have been enqueued on the background scheduler. */
   public static void flushBackgroundThreadScheduler() {
     getBackgroundThreadScheduler().advanceToLastPostedRunnable();
   }
diff --git a/robolectric/src/main/java/org/robolectric/RobolectricTestRunner.java b/robolectric/src/main/java/org/robolectric/RobolectricTestRunner.java
index 4cfb8f30c..31e65fbcb 100644
--- a/robolectric/src/main/java/org/robolectric/RobolectricTestRunner.java
+++ b/robolectric/src/main/java/org/robolectric/RobolectricTestRunner.java
@@ -24,16 +24,15 @@ import org.robolectric.annotation.Config;
 import org.robolectric.annotation.GraphicsMode;
 import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.LooperMode.Mode;
+import org.robolectric.annotation.ResourcesMode;
 import org.robolectric.annotation.SQLiteMode;
 import org.robolectric.config.AndroidConfigurer;
 import org.robolectric.interceptors.AndroidInterceptors;
 import org.robolectric.internal.AndroidSandbox;
-import org.robolectric.internal.BuckManifestFactory;
 import org.robolectric.internal.DefaultManifestFactory;
 import org.robolectric.internal.ManifestFactory;
 import org.robolectric.internal.ManifestIdentifier;
 import org.robolectric.internal.MavenManifestFactory;
-import org.robolectric.internal.ResourcesMode;
 import org.robolectric.internal.SandboxManager;
 import org.robolectric.internal.SandboxTestRunner;
 import org.robolectric.internal.TestEnvironment;
@@ -63,6 +62,7 @@ import org.robolectric.util.inject.Injector;
 public class RobolectricTestRunner extends SandboxTestRunner {
 
   public static final String CONFIG_PROPERTIES = "robolectric.properties";
+  private static final int MAX_DATA_DIR_NAME_LENGTH = 120;
   private static final Injector DEFAULT_INJECTOR = defaultInjector().build();
   private static final Map<ManifestIdentifier, AndroidManifest> appManifestsCache = new HashMap<>();
 
@@ -194,15 +194,14 @@ public class RobolectricTestRunner extends SandboxTestRunner {
         List<Sdk> sdksToRun = sdkPicker.selectSdks(configuration, appManifest);
         RobolectricFrameworkMethod last = null;
         for (Sdk sdk : sdksToRun) {
-            children.add(
-                last =
-                    new RobolectricFrameworkMethod(
-                        frameworkMethod.getMethod(),
-                        appManifest,
-                        sdk,
-                        configuration,
-                        ResourcesMode.BINARY,
-                        alwaysIncludeVariantMarkersInName));
+          children.add(
+              last =
+                  new RobolectricFrameworkMethod(
+                      frameworkMethod.getMethod(),
+                      appManifest,
+                      sdk,
+                      configuration,
+                      alwaysIncludeVariantMarkersInName));
         }
         if (last != null) {
           last.dontIncludeVariantMarkersInTestName();
@@ -228,7 +227,11 @@ public class RobolectricTestRunner extends SandboxTestRunner {
     Sdk sdk = roboMethod.getSdk();
 
     InstrumentationConfiguration classLoaderConfig = createClassLoaderConfig(method);
-    ResourcesMode resourcesMode = roboMethod.getResourcesMode();
+    ResourcesMode.Mode resourcesMode =
+        roboMethod.configuration == null
+            ? ResourcesMode.Mode.BINARY
+            : roboMethod.configuration.get(ResourcesMode.Mode.class);
+    ;
 
     LooperMode.Mode looperMode =
         roboMethod.configuration == null
@@ -260,18 +263,14 @@ public class RobolectricTestRunner extends SandboxTestRunner {
     Sdk sdk = roboMethod.getSdk();
     perfStatsCollector.putMetadata(
         AndroidMetadata.class,
-        new AndroidMetadata(
-            ImmutableMap.of("ro.build.version.sdk", "" + sdk.getApiLevel()),
-            roboMethod.resourcesMode.name()));
+        new AndroidMetadata(ImmutableMap.of("ro.build.version.sdk", "" + sdk.getApiLevel())));
 
     Logger.lifecycle(
         roboMethod.getDeclaringClass().getName()
             + "."
             + roboMethod.getMethod().getName()
             + ": sdk="
-            + sdk.getApiLevel()
-            + "; resources="
-            + roboMethod.resourcesMode);
+            + sdk.getApiLevel());
 
     roboMethod.setStuff(androidSandbox, androidSandbox.getTestEnvironment());
     Class<TestLifecycle> cl = androidSandbox.bootstrappedClass(getTestLifecycleClass());
@@ -279,13 +278,26 @@ public class RobolectricTestRunner extends SandboxTestRunner {
 
     AndroidManifest appManifest = roboMethod.getAppManifest();
 
+    String tmpDirName = getTempDirName(bootstrappedMethod);
     roboMethod
         .getTestEnvironment()
-        .setUpApplicationState(bootstrappedMethod, roboMethod.getConfiguration(), appManifest);
+        .setUpApplicationState(tmpDirName, roboMethod.getConfiguration(), appManifest);
 
     roboMethod.testLifecycle.beforeTest(bootstrappedMethod);
   }
 
+  /** Returns a filesystem-safe directory path name for the current test. */
+  private String getTempDirName(Method method) {
+    // Cap the size to 120 to avoid unnecessarily long directory names.
+    String directoryName =
+        (method.getDeclaringClass().getSimpleName() + "_" + method.getName())
+            .replaceAll("[^a-zA-Z0-9.-]", "_");
+    if (directoryName.length() > MAX_DATA_DIR_NAME_LENGTH) {
+      directoryName = directoryName.substring(0, MAX_DATA_DIR_NAME_LENGTH);
+    }
+    return directoryName;
+  }
+
   @Override
   protected void afterTest(FrameworkMethod method, Method bootstrappedMethod) {
     RobolectricFrameworkMethod roboMethod = (RobolectricFrameworkMethod) method;
@@ -338,11 +350,7 @@ public class RobolectricTestRunner extends SandboxTestRunner {
       return new DefaultManifestFactory(buildSystemApiProperties);
     }
 
-    if (BuckManifestFactory.isBuck()) {
-      return new BuckManifestFactory();
-    } else {
-      return new MavenManifestFactory();
-    }
+    return new MavenManifestFactory();
   }
 
   protected Properties getBuildSystemApiProperties() {
@@ -511,7 +519,6 @@ public class RobolectricTestRunner extends SandboxTestRunner {
     private final int apiLevel;
     @Nonnull private final AndroidManifest appManifest;
     @Nonnull private final Configuration configuration;
-    @Nonnull private final ResourcesMode resourcesMode;
     @Nonnull private final Sdk sdk;
 
     private final boolean alwaysIncludeVariantMarkersInName;
@@ -527,7 +534,6 @@ public class RobolectricTestRunner extends SandboxTestRunner {
           other.appManifest,
           other.getSdk(),
           other.configuration,
-          other.resourcesMode,
           other.alwaysIncludeVariantMarkersInName);
 
       includeVariantMarkersInTestName = other.includeVariantMarkersInTestName;
@@ -539,14 +545,12 @@ public class RobolectricTestRunner extends SandboxTestRunner {
         @Nonnull AndroidManifest appManifest,
         @Nonnull Sdk sdk,
         @Nonnull Configuration configuration,
-        @Nonnull ResourcesMode resourcesMode,
         boolean alwaysIncludeVariantMarkersInName) {
       super(method);
 
       this.apiLevel = sdk.getApiLevel();
       this.appManifest = appManifest;
       this.configuration = configuration;
-      this.resourcesMode = resourcesMode;
       this.alwaysIncludeVariantMarkersInName = alwaysIncludeVariantMarkersInName;
       this.sdk = sdk;
     }
@@ -595,10 +599,6 @@ public class RobolectricTestRunner extends SandboxTestRunner {
       return false;
     }
 
-    public ResourcesMode getResourcesMode() {
-      return resourcesMode;
-    }
-
     @Override
     public boolean equals(Object o) {
       if (this == o) return true;
@@ -607,14 +607,13 @@ public class RobolectricTestRunner extends SandboxTestRunner {
 
       RobolectricFrameworkMethod that = (RobolectricFrameworkMethod) o;
 
-      return apiLevel == that.apiLevel && resourcesMode == that.resourcesMode;
+      return apiLevel == that.apiLevel;
     }
 
     @Override
     public int hashCode() {
       int result = super.hashCode();
       result = 31 * result + apiLevel;
-      result = 31 * result + resourcesMode.ordinal();
       return result;
     }
 
diff --git a/robolectric/src/main/java/org/robolectric/SdkPicker.java b/robolectric/src/main/java/org/robolectric/SdkPicker.java
index 03a45b075..afa0aa1b2 100644
--- a/robolectric/src/main/java/org/robolectric/SdkPicker.java
+++ b/robolectric/src/main/java/org/robolectric/SdkPicker.java
@@ -6,7 +6,9 @@ import javax.inject.Inject;
 import org.robolectric.plugins.DefaultSdkPicker;
 import org.robolectric.plugins.SdkCollection;
 
-/** @deprecated use {@link org.robolectric.plugins.DefaultSdkPicker} instead. */
+/**
+ * @deprecated use {@link org.robolectric.plugins.DefaultSdkPicker} instead.
+ */
 @Deprecated
 public class SdkPicker extends DefaultSdkPicker {
 
@@ -14,5 +16,4 @@ public class SdkPicker extends DefaultSdkPicker {
   public SdkPicker(@Nonnull SdkCollection sdkCollection, Properties systemProperties) {
     super(sdkCollection, systemProperties);
   }
-
 }
diff --git a/robolectric/src/main/java/org/robolectric/TestLifecycleApplication.java b/robolectric/src/main/java/org/robolectric/TestLifecycleApplication.java
index 85ed3600a..10ea83d83 100644
--- a/robolectric/src/main/java/org/robolectric/TestLifecycleApplication.java
+++ b/robolectric/src/main/java/org/robolectric/TestLifecycleApplication.java
@@ -8,4 +8,4 @@ public interface TestLifecycleApplication {
   void prepareTest(Object test);
 
   void afterTest(Method method);
-}
\ No newline at end of file
+}
diff --git a/robolectric/src/main/java/org/robolectric/android/AndroidSdkShadowMatcher.java b/robolectric/src/main/java/org/robolectric/android/AndroidSdkShadowMatcher.java
index 2517f5322..943cc4a5c 100644
--- a/robolectric/src/main/java/org/robolectric/android/AndroidSdkShadowMatcher.java
+++ b/robolectric/src/main/java/org/robolectric/android/AndroidSdkShadowMatcher.java
@@ -7,9 +7,7 @@ import org.robolectric.sandbox.ShadowMatcher;
 import org.robolectric.util.Logger;
 import org.robolectric.util.ReflectionHelpers;
 
-/**
- * Android-specific rules for matching shadow classes and methods by SDK level.
- */
+/** Android-specific rules for matching shadow classes and methods by SDK level. */
 public class AndroidSdkShadowMatcher implements ShadowMatcher {
   private static final Implementation IMPLEMENTATION_DEFAULTS =
       ReflectionHelpers.defaultsFor(Implementation.class);
@@ -28,8 +26,8 @@ public class AndroidSdkShadowMatcher implements ShadowMatcher {
   @Override
   public boolean matches(Method method) {
     Implementation implementation = getImplementationAnnotation(method);
-    return implementation.minSdk() <= sdkLevel &&
-        (implementation.maxSdk() == -1 || implementation.maxSdk() >= sdkLevel);
+    return implementation.minSdk() <= sdkLevel
+        && (implementation.maxSdk() == -1 || implementation.maxSdk() >= sdkLevel);
   }
 
   private static Implementation getImplementationAnnotation(Method method) {
@@ -40,8 +38,6 @@ public class AndroidSdkShadowMatcher implements ShadowMatcher {
     if (implementation == null) {
       Logger.warn("No @Implementation annotation on " + method);
     }
-    return implementation == null
-        ? IMPLEMENTATION_DEFAULTS
-        : implementation;
+    return implementation == null ? IMPLEMENTATION_DEFAULTS : implementation;
   }
 }
diff --git a/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilder.java b/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilder.java
index 2b3484c26..d435b212c 100644
--- a/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilder.java
+++ b/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilder.java
@@ -4,15 +4,13 @@ import android.annotation.IdRes;
 import android.util.AttributeSet;
 import org.robolectric.Robolectric;
 
-/**
- * Builder of {@link AttributeSet}s.
- */
+/** Builder of {@link AttributeSet}s. */
 public interface AttributeSetBuilder extends Robolectric.AttributeSetBuilder {
 
   /**
    * Set an attribute to the given value.
    *
-   * The value will be interpreted according to the attribute's format.
+   * <p>The value will be interpreted according to the attribute's format.
    *
    * @param resId The attribute resource id to set.
    * @param value The value to set.
@@ -24,7 +22,7 @@ public interface AttributeSetBuilder extends Robolectric.AttributeSetBuilder {
   /**
    * Set the style attribute to the given value.
    *
-   * The value will be interpreted as a resource reference.
+   * <p>The value will be interpreted as a resource reference.
    *
    * @param value The value for the specified attribute in this {@link AttributeSet}.
    * @return This {@link AttributeSetBuilder}.
@@ -35,7 +33,7 @@ public interface AttributeSetBuilder extends Robolectric.AttributeSetBuilder {
   /**
    * Set the class attribute to the given value.
    *
-   * The value will be interpreted as a class name.
+   * <p>The value will be interpreted as a class name.
    *
    * @param value The value for this {@link AttributeSet}'s {@code class} attribute.
    * @return This {@link AttributeSetBuilder}.
@@ -45,7 +43,7 @@ public interface AttributeSetBuilder extends Robolectric.AttributeSetBuilder {
   /**
    * Set the id attribute to the given value.
    *
-   * The value will be interpreted as an element id name.
+   * <p>The value will be interpreted as an element id name.
    *
    * @param value The value for this {@link AttributeSet}'s {@code id} attribute.
    * @return This {@link AttributeSetBuilder}.
@@ -59,5 +57,4 @@ public interface AttributeSetBuilder extends Robolectric.AttributeSetBuilder {
    */
   @Override
   AttributeSet build();
-
 }
diff --git a/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilderImpl.java b/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilderImpl.java
index 5bbe385f8..129e01e49 100644
--- a/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilderImpl.java
+++ b/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilderImpl.java
@@ -7,8 +7,10 @@ import static org.robolectric.res.android.ResourceTypes.RES_XML_RESOURCE_MAP_TYP
 import static org.robolectric.res.android.ResourceTypes.RES_XML_START_ELEMENT_TYPE;
 import static org.robolectric.res.android.ResourceTypes.ResTable_map.ATTR_TYPE;
 import static org.robolectric.shadows.ShadowAssetManager.ATTRIBUTE_TYPE_PRECIDENCE;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.content.Context;
+import android.content.res.AssetManager;
 import android.util.AttributeSet;
 import android.util.SparseArray;
 import android.util.TypedValue;
@@ -43,17 +45,18 @@ import org.robolectric.shadows.ShadowArscAssetManager;
 import org.robolectric.shadows.ShadowAssetManager;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
+import org.robolectric.util.reflector.ForType;
 
 public class AttributeSetBuilderImpl implements AttributeSetBuilder {
   private static final int STYLE_RES_ID = Integer.MAX_VALUE - 2;
   private static final int CLASS_RES_ID = Integer.MAX_VALUE - 1;
   private static final int ID_RES_ID = Integer.MAX_VALUE;
 
-  private static final ImmutableMap<Integer, String> MAGIC_ATTRS = ImmutableMap.of(
-      STYLE_RES_ID, "style",
-      CLASS_RES_ID, "class",
-      ID_RES_ID, "id"
-  );
+  private static final ImmutableMap<Integer, String> MAGIC_ATTRS =
+      ImmutableMap.of(
+          STYLE_RES_ID, "style",
+          CLASS_RES_ID, "class",
+          ID_RES_ID, "id");
 
   private final ResourceResolver resourceResolver;
   private final Map<Integer, String> attrToValue = new TreeMap<>();
@@ -66,8 +69,8 @@ public class AttributeSetBuilderImpl implements AttributeSetBuilder {
 
     Integer getIdentifier(String name, String type, String packageName);
 
-    void parseValue(Integer attrId, ResName attrResName, AttributeResource attribute,
-        TypedValue outValue);
+    void parseValue(
+        Integer attrId, ResName attrResName, AttributeResource attribute, TypedValue outValue);
   }
 
   public static class ArscResourceResolver implements ResourceResolver {
@@ -117,17 +120,19 @@ public class AttributeSetBuilderImpl implements AttributeSetBuilder {
 
     @Override
     public Integer getIdentifier(String name, String type, String packageName) {
-      return resTable.identifierForName(name, type, packageName);
+      AssetManager assetManager = context.getAssets();
+      return reflector(AssetManagerReflector.class, assetManager)
+          .getResourceIdentifier(name, type, packageName);
     }
 
     @Override
-    public void parseValue(Integer attrId, ResName attrResName, AttributeResource attribute,
-        TypedValue outValue) {
+    public void parseValue(
+        Integer attrId, ResName attrResName, AttributeResource attribute, TypedValue outValue) {
       arscParse(attrId, attrResName, attribute, outValue);
     }
 
-    private void arscParse(Integer attrId, ResName attrResName, AttributeResource attribute,
-        TypedValue outValue) {
+    private void arscParse(
+        Integer attrId, ResName attrResName, AttributeResource attribute, TypedValue outValue) {
       String format = ShadowArscAssetManager.getResourceBagValue(attrId, ATTR_TYPE, resTable);
       Map<String, Integer> map = ShadowArscAssetManager.getResourceBagValues(attrId, resTable);
       ArrayList<Pair> pairs = new ArrayList<>();
@@ -136,10 +141,9 @@ public class AttributeSetBuilderImpl implements AttributeSetBuilder {
       }
 
       int formatFlags = Integer.parseInt(format);
-      TreeSet<flag_entry> sortedFlags = new TreeSet<>(
-          (a, b) -> ATTRIBUTE_TYPE_PRECIDENCE.compare(a.name, b.name));
-      Collections.addAll(sortedFlags,
-          org.robolectric.res.android.ResourceTable.gFormatFlags);
+      TreeSet<flag_entry> sortedFlags =
+          new TreeSet<>((a, b) -> ATTRIBUTE_TYPE_PRECIDENCE.compare(a.name, b.name));
+      Collections.addAll(sortedFlags, org.robolectric.res.android.ResourceTable.gFormatFlags);
 
       for (flag_entry flag : sortedFlags) {
         if ((formatFlags & flag.value) != 0) {
@@ -191,14 +195,15 @@ public class AttributeSetBuilderImpl implements AttributeSetBuilder {
 
   @Override
   public AttributeSet build() {
-    Class<?> xmlBlockClass = ReflectionHelpers
-        .loadClass(this.getClass().getClassLoader(), "android.content.res.XmlBlock");
+    Class<?> xmlBlockClass =
+        ReflectionHelpers.loadClass(
+            this.getClass().getClassLoader(), "android.content.res.XmlBlock");
 
     ByteBuffer buf = ByteBuffer.allocate(16 * 1024).order(ByteOrder.LITTLE_ENDIAN);
     Writer resStringPoolWriter = new Writer();
 
     final SparseArray<Integer> resIds = new SparseArray<>();
-    final int[] maxAttrNameIndex = new int[] { 0 };
+    final int[] maxAttrNameIndex = new int[] {0};
 
     ResXMLTree_attrExt.Writer dummyStart =
         new ResXMLTree_attrExt.Writer(buf, resStringPoolWriter, null, "dummy") {
@@ -293,20 +298,27 @@ public class AttributeSetBuilderImpl implements AttributeSetBuilder {
         new ResXMLTree_endElementExt.Writer(buf, resStringPoolWriter, null, "dummy");
 
     int finalMaxAttrNameIndex = maxAttrNameIndex[0];
-    ResXMLTree_header.write(buf, resStringPoolWriter, () -> {
-      if (finalMaxAttrNameIndex > 0) {
-        ResChunk_header.write(buf, (short) RES_XML_RESOURCE_MAP_TYPE, () -> {}, () -> {
-          // not particularly compact, but no big deal for our purposes...
-          for (int i = 0; i <= finalMaxAttrNameIndex; i++) {
-            Integer value = resIds.get(i);
-            buf.putInt(value == null ? 0 : value);
+    ResXMLTree_header.write(
+        buf,
+        resStringPoolWriter,
+        () -> {
+          if (finalMaxAttrNameIndex > 0) {
+            ResChunk_header.write(
+                buf,
+                (short) RES_XML_RESOURCE_MAP_TYPE,
+                () -> {},
+                () -> {
+                  // not particularly compact, but no big deal for our purposes...
+                  for (int i = 0; i <= finalMaxAttrNameIndex; i++) {
+                    Integer value = resIds.get(i);
+                    buf.putInt(value == null ? 0 : value);
+                  }
+                });
           }
-        });
-      }
 
-      ResXMLTree_node.write(buf, RES_XML_START_ELEMENT_TYPE, dummyStart::write);
-      ResXMLTree_node.write(buf, RES_XML_END_ELEMENT_TYPE, dummyEnd::write);
-    });
+          ResXMLTree_node.write(buf, RES_XML_START_ELEMENT_TYPE, dummyStart::write);
+          ResXMLTree_node.write(buf, RES_XML_END_ELEMENT_TYPE, dummyEnd::write);
+        });
 
     int size = buf.position();
     byte[] bytes = new byte[size];
@@ -315,27 +327,26 @@ public class AttributeSetBuilderImpl implements AttributeSetBuilder {
     ((Buffer) buf).position(0);
     buf.get(bytes, 0, size);
 
-    Object xmlBlockInstance = ReflectionHelpers
-        .callConstructor(xmlBlockClass, ClassParameter.from(byte[].class, bytes));
+    Object xmlBlockInstance =
+        ReflectionHelpers.callConstructor(xmlBlockClass, ClassParameter.from(byte[].class, bytes));
 
-    AttributeSet parser = ReflectionHelpers.callInstanceMethod(xmlBlockClass, xmlBlockInstance,
-        "newParser");
+    AttributeSet parser =
+        ReflectionHelpers.callInstanceMethod(xmlBlockClass, xmlBlockInstance, "newParser");
     ReflectionHelpers.callInstanceMethod(parser, "next");
     ReflectionHelpers.callInstanceMethod(parser, "next");
 
     return parser;
   }
 
-  private TypedValue parse(Integer attrId, ResName attrResName, String value,
-      String packageName) {
-    AttributeResource attribute =
-        new AttributeResource(attrResName, value, packageName);
+  private TypedValue parse(Integer attrId, ResName attrResName, String value, String packageName) {
+    AttributeResource attribute = new AttributeResource(attrResName, value, packageName);
     TypedValue outValue = new TypedValue();
 
     if (attribute.isResourceReference()) {
       ResName resourceReference = attribute.getResourceReference();
-      int id = resourceResolver.getIdentifier(resourceReference.name, resourceReference.type,
-          resourceReference.packageName);
+      int id =
+          resourceResolver.getIdentifier(
+              resourceReference.name, resourceReference.type, resourceReference.packageName);
       if (id == 0) {
         throw new IllegalArgumentException("couldn't resolve " + attribute);
       }
@@ -349,4 +360,9 @@ public class AttributeSetBuilderImpl implements AttributeSetBuilder {
     }
     return outValue;
   }
+
+  @ForType(AssetManager.class)
+  interface AssetManagerReflector {
+    int getResourceIdentifier(String name, String defType, String defPackage);
+  }
 }
diff --git a/robolectric/src/main/java/org/robolectric/android/internal/AndroidTestEnvironment.java b/robolectric/src/main/java/org/robolectric/android/internal/AndroidTestEnvironment.java
index ab29dea7f..f501b9495 100644
--- a/robolectric/src/main/java/org/robolectric/android/internal/AndroidTestEnvironment.java
+++ b/robolectric/src/main/java/org/robolectric/android/internal/AndroidTestEnvironment.java
@@ -18,7 +18,6 @@ import android.content.IntentFilter;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageParser;
 import android.content.pm.PackageParser.Package;
-import android.content.res.AssetManager;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.os.Build;
@@ -30,17 +29,17 @@ import android.provider.FontsContract;
 import android.util.DisplayMetrics;
 import androidx.test.platform.app.InstrumentationRegistry;
 import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Preconditions;
 import com.google.common.base.Supplier;
 import com.google.common.base.Suppliers;
-import java.lang.reflect.Method;
-import java.nio.file.FileSystem;
 import java.nio.file.Path;
 import java.security.Security;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 import java.util.Locale;
-import javax.annotation.Nonnull;
 import javax.inject.Named;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
@@ -49,7 +48,6 @@ import javax.net.ssl.SSLSession;
 import org.bouncycastle.jce.provider.BouncyCastleProvider;
 import org.conscrypt.OkHostnameVerifier;
 import org.conscrypt.OpenSSLProvider;
-import org.robolectric.ApkLoader;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.android.Bootstrap;
 import org.robolectric.annotation.Config;
@@ -59,22 +57,14 @@ import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.SQLiteMode;
 import org.robolectric.annotation.experimental.LazyApplication.LazyLoad;
 import org.robolectric.config.ConfigurationRegistry;
-import org.robolectric.internal.ResourcesMode;
 import org.robolectric.internal.ShadowProvider;
 import org.robolectric.internal.TestEnvironment;
 import org.robolectric.manifest.AndroidManifest;
 import org.robolectric.manifest.BroadcastReceiverData;
-import org.robolectric.manifest.RoboNotFoundException;
 import org.robolectric.nativeruntime.DefaultNativeRuntimeLoader;
 import org.robolectric.pluginapi.Sdk;
 import org.robolectric.pluginapi.TestEnvironmentLifecyclePlugin;
 import org.robolectric.pluginapi.config.ConfigurationStrategy.Configuration;
-import org.robolectric.res.Fs;
-import org.robolectric.res.PackageResourceTable;
-import org.robolectric.res.ResourcePath;
-import org.robolectric.res.ResourceTable;
-import org.robolectric.res.ResourceTableFactory;
-import org.robolectric.res.RoutingResourceTable;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ClassNameResolver;
 import org.robolectric.shadows.ShadowActivityThread;
@@ -98,6 +88,7 @@ import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.util.Scheduler;
 import org.robolectric.util.TempDirectory;
+import org.robolectric.util.Util;
 import org.robolectric.versioning.AndroidVersions;
 import org.robolectric.versioning.AndroidVersions.V;
 
@@ -105,17 +96,13 @@ import org.robolectric.versioning.AndroidVersions.V;
 public class AndroidTestEnvironment implements TestEnvironment {
 
   private static final String CONSCRYPT_PROVIDER = "Conscrypt";
-  private static final int MAX_DATA_DIR_NAME_LENGTH = 120;
 
-  private final Sdk runtimeSdk;
   private final Sdk compileSdk;
 
   private final int apiLevel;
 
   private boolean loggingInitialized = false;
   private final Path sdkJarPath;
-  private final ApkLoader apkLoader;
-  private PackageResourceTable systemResourceTable;
   private final ShadowProvider[] shadowProviders;
   private final TestEnvironmentLifecyclePlugin[] testEnvironmentLifecyclePlugins;
   private final Locale initialLocale = Locale.getDefault();
@@ -123,15 +110,11 @@ public class AndroidTestEnvironment implements TestEnvironment {
   public AndroidTestEnvironment(
       @Named("runtimeSdk") Sdk runtimeSdk,
       @Named("compileSdk") Sdk compileSdk,
-      ResourcesMode resourcesMode,
-      ApkLoader apkLoader,
       ShadowProvider[] shadowProviders,
       TestEnvironmentLifecyclePlugin[] lifecyclePlugins) {
-    this.runtimeSdk = runtimeSdk;
     this.compileSdk = compileSdk;
 
     apiLevel = runtimeSdk.getApiLevel();
-    this.apkLoader = apkLoader;
     sdkJarPath = runtimeSdk.getJarPath();
     this.shadowProviders = shadowProviders;
     this.testEnvironmentLifecyclePlugins = lifecyclePlugins;
@@ -141,7 +124,8 @@ public class AndroidTestEnvironment implements TestEnvironment {
 
   @Override
   public void setUpApplicationState(
-      Method method, Configuration configuration, AndroidManifest appManifest) {
+      String tmpDirName, Configuration configuration, AndroidManifest appManifest) {
+    Preconditions.checkArgument(tmpDirName != null && !tmpDirName.isEmpty());
     Config config = configuration.get(Config.class);
 
     ConfigurationRegistry.instance = new ConfigurationRegistry(configuration.map());
@@ -158,7 +142,7 @@ public class AndroidTestEnvironment implements TestEnvironment {
       DefaultNativeRuntimeLoader.injectAndLoad();
     }
 
-    RuntimeEnvironment.setTempDirectory(new TempDirectory(createTestDataDirRootPath(method)));
+    RuntimeEnvironment.setTempDirectory(new TempDirectory(tmpDirName));
     if (ShadowLooper.looperMode() == LooperMode.Mode.LEGACY) {
       RuntimeEnvironment.setMasterScheduler(new Scheduler());
       RuntimeEnvironment.setMainThread(Thread.currentThread());
@@ -245,7 +229,6 @@ public class AndroidTestEnvironment implements TestEnvironment {
       // force eager load of the application
       RuntimeEnvironment.getApplication();
     }
-
   }
 
   // If certain Android classes are required to be loaded in a particular order, do so here.
@@ -300,7 +283,7 @@ public class AndroidTestEnvironment implements TestEnvironment {
     ShadowApplication shadowInitialApplication = Shadow.extract(dummyInitialApplication);
     shadowInitialApplication.callAttach(systemContextImpl);
 
-    Package parsedPackage = loadAppPackage(config, appManifest);
+    Package parsedPackage = loadAppPackage(appManifest);
 
     ApplicationInfo applicationInfo = parsedPackage.applicationInfo;
     Class<? extends Application> applicationClass =
@@ -405,12 +388,12 @@ public class AndroidTestEnvironment implements TestEnvironment {
     return application;
   }
 
-  private Package loadAppPackage(Config config, AndroidManifest appManifest) {
+  private Package loadAppPackage(AndroidManifest appManifest) {
     return PerfStatsCollector.getInstance()
-        .measure("parse package", () -> loadAppPackage_measured(config, appManifest));
+        .measure("parse package", () -> loadAppPackage_measured(appManifest));
   }
 
-  private Package loadAppPackage_measured(Config config, AndroidManifest appManifest) {
+  private Package loadAppPackage_measured(AndroidManifest appManifest) {
 
     Package parsedPackage;
 
@@ -432,62 +415,6 @@ public class AndroidTestEnvironment implements TestEnvironment {
     return parsedPackage;
   }
 
-  private synchronized PackageResourceTable getSystemResourceTable() {
-    if (systemResourceTable == null) {
-      ResourcePath resourcePath = createRuntimeSdkResourcePath();
-      systemResourceTable = new ResourceTableFactory().newFrameworkResourceTable(resourcePath);
-    }
-    return systemResourceTable;
-  }
-
-  @Nonnull
-  private ResourcePath createRuntimeSdkResourcePath() {
-    try {
-      FileSystem zipFs = Fs.forJar(runtimeSdk.getJarPath());
-
-      @SuppressLint("PrivateApi")
-      Class<?> androidInternalRClass = Class.forName("com.android.internal.R");
-
-      // TODO: verify these can be loaded via raw-res path
-      return new ResourcePath(
-          android.R.class,
-          zipFs.getPath("raw-res/res"),
-          zipFs.getPath("raw-res/assets"),
-          androidInternalRClass);
-    } catch (ClassNotFoundException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  private void injectResourceStuffForLegacy(AndroidManifest appManifest) {
-    PackageResourceTable systemResourceTable = getSystemResourceTable();
-    PackageResourceTable appResourceTable = apkLoader.getAppResourceTable(appManifest);
-    RoutingResourceTable combinedAppResourceTable =
-        new RoutingResourceTable(appResourceTable, systemResourceTable);
-
-    PackageResourceTable compileTimeSdkResourceTable = apkLoader.getCompileTimeSdkResourceTable();
-    ResourceTable combinedCompileTimeResourceTable =
-        new RoutingResourceTable(appResourceTable, compileTimeSdkResourceTable);
-
-    RuntimeEnvironment.setCompileTimeResourceTable(combinedCompileTimeResourceTable);
-    RuntimeEnvironment.setAppResourceTable(combinedAppResourceTable);
-    RuntimeEnvironment.setSystemResourceTable(new RoutingResourceTable(systemResourceTable));
-
-    try {
-      appManifest.initMetaData(combinedAppResourceTable);
-    } catch (RoboNotFoundException e1) {
-      throw new Resources.NotFoundException(e1.getMessage());
-    }
-  }
-
-  private void populateAssetPaths(AssetManager assetManager, AndroidManifest appManifest) {
-    for (AndroidManifest manifest : appManifest.getAllManifests()) {
-      if (manifest.getAssetsDirectory() != null) {
-        assetManager.addAssetPath(Fs.externalize(manifest.getAssetsDirectory()));
-      }
-    }
-  }
-
   @VisibleForTesting
   static Class<? extends Application> getApplicationClass(
       AndroidManifest appManifest, Config config, ApplicationInfo applicationInfo) {
@@ -589,19 +516,6 @@ public class AndroidTestEnvironment implements TestEnvironment {
     return androidInstrumentation;
   }
 
-  /** Create a file system safe directory path name for the current test. */
-  @SuppressWarnings("DoNotCall")
-  private String createTestDataDirRootPath(Method method) {
-    // Cap the size to 120 to avoid unnecessarily long directory names.
-    String directoryName =
-        (method.getDeclaringClass().getSimpleName() + "_" + method.getName())
-            .replaceAll("[^a-zA-Z0-9.-]", "_");
-    if (directoryName.length() > MAX_DATA_DIR_NAME_LENGTH) {
-      directoryName = directoryName.substring(0, MAX_DATA_DIR_NAME_LENGTH);
-    }
-    return directoryName;
-  }
-
   @Override
   public void tearDownApplication() {
     if (RuntimeEnvironment.application != null) {
@@ -659,8 +573,21 @@ public class AndroidTestEnvironment implements TestEnvironment {
   @Override
   public void resetState() {
     Locale.setDefault(initialLocale);
+    List<Throwable> exceptions = new ArrayList<>();
     for (ShadowProvider provider : shadowProviders) {
-      provider.reset();
+      try {
+        provider.reset();
+      } catch (Throwable e) {
+        exceptions.add(e);
+      }
+    }
+
+    if (!exceptions.isEmpty()) {
+      Throwable first = exceptions.remove(0);
+      for (Throwable t : exceptions) {
+        first.addSuppressed(t);
+      }
+      Util.sneakyThrow(first);
     }
   }
 
diff --git a/robolectric/src/main/java/org/robolectric/android/internal/LocalUiController.java b/robolectric/src/main/java/org/robolectric/android/internal/LocalUiController.java
index dd1bc5cca..7bfd8a2f0 100644
--- a/robolectric/src/main/java/org/robolectric/android/internal/LocalUiController.java
+++ b/robolectric/src/main/java/org/robolectric/android/internal/LocalUiController.java
@@ -9,7 +9,6 @@ import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.shadows.ShadowLooper.shadowMainLooper;
 
 import android.annotation.SuppressLint;
-import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.SystemClock;
@@ -141,18 +140,8 @@ public class LocalUiController implements UiController {
 
   @SuppressLint("InlinedApi")
   @VisibleForTesting
-  @SuppressWarnings("deprecation")
   static KeyCharacterMap getKeyCharacterMap() {
-    KeyCharacterMap keyCharacterMap = null;
-
-    // KeyCharacterMap.VIRTUAL_KEYBOARD is present from API11.
-    // For earlier APIs we use KeyCharacterMap.BUILT_IN_KEYBOARD
-    if (Build.VERSION.SDK_INT < 11) {
-      keyCharacterMap = KeyCharacterMap.load(KeyCharacterMap.BUILT_IN_KEYBOARD);
-    } else {
-      keyCharacterMap = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);
-    }
-    return keyCharacterMap;
+    return KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);
   }
 
   @Override
diff --git a/robolectric/src/main/java/org/robolectric/internal/AndroidSandbox.java b/robolectric/src/main/java/org/robolectric/internal/AndroidSandbox.java
index 69adb67e6..14cee8379 100644
--- a/robolectric/src/main/java/org/robolectric/internal/AndroidSandbox.java
+++ b/robolectric/src/main/java/org/robolectric/internal/AndroidSandbox.java
@@ -10,8 +10,8 @@ import java.util.Set;
 import java.util.concurrent.ThreadFactory;
 import javax.inject.Inject;
 import javax.inject.Named;
-import org.robolectric.ApkLoader;
 import org.robolectric.android.internal.AndroidTestEnvironment;
+import org.robolectric.annotation.ResourcesMode;
 import org.robolectric.annotation.SQLiteMode;
 import org.robolectric.internal.bytecode.ClassInstrumentor;
 import org.robolectric.internal.bytecode.InstrumentationConfiguration;
@@ -35,8 +35,7 @@ public class AndroidSandbox extends Sandbox {
   public AndroidSandbox(
       @Named("runtimeSdk") Sdk runtimeSdk,
       @Named("compileSdk") Sdk compileSdk,
-      ResourcesMode resourcesMode,
-      ApkLoader apkLoader,
+      ResourcesMode.Mode resourcesMode,
       TestEnvironmentSpec testEnvironmentSpec,
       SdkSandboxClassLoader sdkSandboxClassLoader,
       ShadowProviders shadowProviders,
@@ -47,11 +46,10 @@ public class AndroidSandbox extends Sandbox {
 
     Injector sandboxScope =
         new Injector.Builder(robolectricClassLoader)
-            .bind(ApkLoader.class, apkLoader) // shared singleton
             .bind(TestEnvironment.class, bootstrappedClass(testEnvironmentSpec.getClazz()))
             .bind(new Injector.Key<>(Sdk.class, "runtimeSdk"), runtimeSdk)
             .bind(new Injector.Key<>(Sdk.class, "compileSdk"), compileSdk)
-            .bind(ResourcesMode.class, resourcesMode)
+            .bind(ResourcesMode.Mode.class, resourcesMode)
             .bind(ShadowProvider[].class, shadowProviders.inClassLoader(robolectricClassLoader))
             .build();
 
@@ -123,8 +121,10 @@ public class AndroidSandbox extends Sandbox {
   /** Adapter from Sdk to ResourceLoader. */
   public static class SdkSandboxClassLoader extends SandboxClassLoader {
 
-    public SdkSandboxClassLoader(InstrumentationConfiguration config,
-        @Named("runtimeSdk") Sdk runtimeSdk, ClassInstrumentor classInstrumentor) {
+    public SdkSandboxClassLoader(
+        InstrumentationConfiguration config,
+        @Named("runtimeSdk") Sdk runtimeSdk,
+        ClassInstrumentor classInstrumentor) {
       super(config, new UrlResourceProvider(toUrl(runtimeSdk.getJarPath())), classInstrumentor);
     }
 
diff --git a/robolectric/src/main/java/org/robolectric/internal/BuckManifestFactory.java b/robolectric/src/main/java/org/robolectric/internal/BuckManifestFactory.java
deleted file mode 100644
index 9efb53c51..000000000
--- a/robolectric/src/main/java/org/robolectric/internal/BuckManifestFactory.java
+++ /dev/null
@@ -1,89 +0,0 @@
-package org.robolectric.internal;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.nio.file.Path;
-import java.nio.file.Paths;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import javax.annotation.Nonnull;
-import org.robolectric.annotation.Config;
-import org.robolectric.res.Fs;
-import org.robolectric.util.Util;
-
-@SuppressWarnings("NewApi")
-public class BuckManifestFactory implements ManifestFactory {
-
-  private static final String BUCK_ROBOLECTRIC_RES_DIRECTORIES = "buck.robolectric_res_directories";
-  private static final String BUCK_ROBOLECTRIC_ASSETS_DIRECTORIES =
-      "buck.robolectric_assets_directories";
-  private static final String BUCK_ROBOLECTRIC_MANIFEST = "buck.robolectric_manifest";
-
-  @Override
-  public ManifestIdentifier identify(Config config) {
-    String buckManifest = System.getProperty(BUCK_ROBOLECTRIC_MANIFEST);
-    Path manifestFile = Paths.get(buckManifest);
-
-    String buckResDirs = System.getProperty(BUCK_ROBOLECTRIC_RES_DIRECTORIES);
-    String buckAssetsDirs = System.getProperty(BUCK_ROBOLECTRIC_ASSETS_DIRECTORIES);
-    String packageName = config.packageName();
-
-    final List<Path> buckResources = getDirectoriesFromProperty(buckResDirs);
-    final List<Path> buckAssets = getDirectoriesFromProperty(buckAssetsDirs);
-    final Path resDir =
-        buckResources.isEmpty() ? null : buckResources.get(buckResources.size() - 1);
-    final Path assetsDir = buckAssets.isEmpty() ? null : buckAssets.get(buckAssets.size() - 1);
-    final List<ManifestIdentifier> libraries;
-
-    if (resDir == null && assetsDir == null) {
-      libraries = null;
-    } else {
-      libraries = new ArrayList<>();
-
-      for (int i = 0; i < buckResources.size() - 1; i++) {
-        libraries.add(new ManifestIdentifier((String) null, null, buckResources.get(i), null, null));
-      }
-
-      for (int i = 0; i < buckAssets.size() - 1; i++) {
-        libraries.add(new ManifestIdentifier(null, null, null, buckAssets.get(i), null));
-      }
-    }
-
-    return new ManifestIdentifier(packageName, manifestFile, resDir, assetsDir, libraries);
-  }
-
-  public static boolean isBuck() {
-    return System.getProperty(BUCK_ROBOLECTRIC_MANIFEST) != null;
-  }
-
-  @Nonnull
-  private List<Path> getDirectoriesFromProperty(String property) {
-    if (property == null) {
-      return Collections.emptyList();
-    }
-
-    List<String> dirs;
-    if (property.startsWith("@")) {
-      String filename = property.substring(1);
-      try {
-        dirs = Arrays.asList(
-            new String(Util.readBytes(new FileInputStream(filename)), UTF_8).split("\\n"));
-      } catch (IOException e) {
-        throw new RuntimeException("Cannot read file " + filename);
-      }
-    } else {
-      dirs = Arrays.asList(property.split(File.pathSeparator));
-    }
-
-    List<Path> files = new ArrayList<>();
-    for (String dir : dirs) {
-      files.add(Fs.fromUrl(dir));
-    }
-    return Collections.unmodifiableList(files);
-  }
-}
diff --git a/robolectric/src/main/java/org/robolectric/internal/DefaultManifestFactory.java b/robolectric/src/main/java/org/robolectric/internal/DefaultManifestFactory.java
index c2da01e28..225dce86e 100644
--- a/robolectric/src/main/java/org/robolectric/internal/DefaultManifestFactory.java
+++ b/robolectric/src/main/java/org/robolectric/internal/DefaultManifestFactory.java
@@ -28,7 +28,8 @@ public class DefaultManifestFactory implements ManifestFactory {
 
     String manifestConfig = config.manifest();
     if (Config.NONE.equals(manifestConfig)) {
-      Logger.info("@Config(manifest = Config.NONE) specified while using Build System API, ignoring");
+      Logger.info(
+          "@Config(manifest = Config.NONE) specified while using Build System API, ignoring");
     } else if (!Config.DEFAULT_MANIFEST_NAME.equals(manifestConfig)) {
       manifestFile = getResource(manifestConfig);
     }
@@ -50,8 +51,8 @@ public class DefaultManifestFactory implements ManifestFactory {
       Logger.info("@Config(libraries) specified while using Build System API, ignoring");
     }
 
-    return new ManifestIdentifier(packageName, manifestFile, resourcesDir, assetsDir, libraryDirs,
-        apkFile);
+    return new ManifestIdentifier(
+        packageName, manifestFile, resourcesDir, assetsDir, libraryDirs, apkFile);
   }
 
   private Path getResource(String pathStr) {
diff --git a/robolectric/src/main/java/org/robolectric/internal/DeprecatedMethodMarkerException.java b/robolectric/src/main/java/org/robolectric/internal/DeprecatedMethodMarkerException.java
index 58068cc26..fc0b577d8 100644
--- a/robolectric/src/main/java/org/robolectric/internal/DeprecatedMethodMarkerException.java
+++ b/robolectric/src/main/java/org/robolectric/internal/DeprecatedMethodMarkerException.java
@@ -1,4 +1,3 @@
 package org.robolectric.internal;
 
-public class DeprecatedMethodMarkerException extends RuntimeException {
-}
+public class DeprecatedMethodMarkerException extends RuntimeException {}
diff --git a/robolectric/src/main/java/org/robolectric/internal/ManifestFactory.java b/robolectric/src/main/java/org/robolectric/internal/ManifestFactory.java
index adcbea175..153b0d1f2 100644
--- a/robolectric/src/main/java/org/robolectric/internal/ManifestFactory.java
+++ b/robolectric/src/main/java/org/robolectric/internal/ManifestFactory.java
@@ -11,12 +11,11 @@ import org.robolectric.annotation.Config;
 public interface ManifestFactory {
 
   /**
-   * Creates a {@link ManifestIdentifier} which represents an Android app, service, or library
-   * under test, indicating its manifest file, resources and assets directories, and optionally
-   * dependency libraries and an overridden package name.
+   * Creates a {@link ManifestIdentifier} which represents an Android app, service, or library under
+   * test, indicating its manifest file, resources and assets directories, and optionally dependency
+   * libraries and an overridden package name.
    *
    * @param config The merged configuration for the running test.
    */
   ManifestIdentifier identify(Config config);
-
 }
diff --git a/robolectric/src/main/java/org/robolectric/internal/ManifestIdentifier.java b/robolectric/src/main/java/org/robolectric/internal/ManifestIdentifier.java
index 20771054c..93f7d4c4e 100644
--- a/robolectric/src/main/java/org/robolectric/internal/ManifestIdentifier.java
+++ b/robolectric/src/main/java/org/robolectric/internal/ManifestIdentifier.java
@@ -40,7 +40,9 @@ public class ManifestIdentifier {
     this.apkFile = apkFile;
   }
 
-  /** @deprecated Use {@link #ManifestIdentifier(String, Path, Path, Path, List)} instead. */
+  /**
+   * @deprecated Use {@link #ManifestIdentifier(String, Path, Path, Path, List)} instead.
+   */
   @Deprecated
   public ManifestIdentifier(
       Path manifestFile, Path resDir, Path assetDir, String packageName, List<Path> libraryDirs) {
@@ -101,7 +103,8 @@ public class ManifestIdentifier {
 
     ManifestIdentifier that = (ManifestIdentifier) o;
 
-    if (manifestFile != null ? !manifestFile.equals(that.manifestFile)
+    if (manifestFile != null
+        ? !manifestFile.equals(that.manifestFile)
         : that.manifestFile != null) {
       return false;
     }
@@ -133,13 +136,20 @@ public class ManifestIdentifier {
 
   @Override
   public String toString() {
-    return "ManifestIdentifier{" +
-        "manifestFile=" + manifestFile +
-        ", resDir=" + resDir +
-        ", assetDir=" + assetDir +
-        ", packageName='" + packageName + '\'' +
-        ", libraries=" + libraries +
-        ", apkFile=" + apkFile +
-        '}';
+    return "ManifestIdentifier{"
+        + "manifestFile="
+        + manifestFile
+        + ", resDir="
+        + resDir
+        + ", assetDir="
+        + assetDir
+        + ", packageName='"
+        + packageName
+        + '\''
+        + ", libraries="
+        + libraries
+        + ", apkFile="
+        + apkFile
+        + '}';
   }
 }
diff --git a/robolectric/src/main/java/org/robolectric/internal/ResourcesMode.java b/robolectric/src/main/java/org/robolectric/internal/ResourcesMode.java
deleted file mode 100644
index b4b8d82a6..000000000
--- a/robolectric/src/main/java/org/robolectric/internal/ResourcesMode.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package org.robolectric.internal;
-
-public enum ResourcesMode {
-  BINARY
-}
diff --git a/robolectric/src/main/java/org/robolectric/internal/SandboxManager.java b/robolectric/src/main/java/org/robolectric/internal/SandboxManager.java
index 81ba37480..297dba525 100644
--- a/robolectric/src/main/java/org/robolectric/internal/SandboxManager.java
+++ b/robolectric/src/main/java/org/robolectric/internal/SandboxManager.java
@@ -8,6 +8,7 @@ import javax.inject.Inject;
 import javax.inject.Named;
 import org.robolectric.annotation.GraphicsMode;
 import org.robolectric.annotation.LooperMode;
+import org.robolectric.annotation.ResourcesMode;
 import org.robolectric.annotation.SQLiteMode;
 import org.robolectric.internal.bytecode.InstrumentationConfiguration;
 import org.robolectric.pluginapi.Sdk;
@@ -19,9 +20,7 @@ import org.robolectric.util.inject.AutoFactory;
 @SuppressLint("NewApi")
 public class SandboxManager {
 
-  /**
-   * The factor for cache size. See {@link #sandboxesByKey} for details.
-   */
+  /** The factor for cache size. See {@link #sandboxesByKey} for details. */
   private static final int CACHE_SIZE_FACTOR = 3;
 
   private final SandboxBuilder sandboxBuilder;
@@ -55,7 +54,7 @@ public class SandboxManager {
   public synchronized AndroidSandbox getAndroidSandbox(
       InstrumentationConfiguration instrumentationConfig,
       Sdk sdk,
-      ResourcesMode resourcesMode,
+      ResourcesMode.Mode resourcesMode,
       LooperMode.Mode looperMode,
       SQLiteMode.Mode sqliteMode,
       GraphicsMode.Mode graphicsMode) {
@@ -80,21 +79,21 @@ public class SandboxManager {
         InstrumentationConfiguration instrumentationConfig,
         @Named("runtimeSdk") Sdk runtimeSdk,
         @Named("compileSdk") Sdk compileSdk,
-        ResourcesMode resourcesMode,
+        ResourcesMode.Mode resourcesMode,
         SQLiteMode.Mode sqLiteMode);
   }
 
   static class SandboxKey {
     private final Sdk sdk;
     private final InstrumentationConfiguration instrumentationConfiguration;
-    private final ResourcesMode resourcesMode;
+    private final ResourcesMode.Mode resourcesMode;
     private final LooperMode.Mode looperMode;
     private final GraphicsMode.Mode graphicsMode;
 
     public SandboxKey(
         InstrumentationConfiguration instrumentationConfiguration,
         Sdk sdk,
-        ResourcesMode resourcesMode,
+        ResourcesMode.Mode resourcesMode,
         LooperMode.Mode looperMode,
         GraphicsMode.Mode graphicsMode) {
       this.sdk = sdk;
diff --git a/robolectric/src/main/java/org/robolectric/internal/TestEnvironment.java b/robolectric/src/main/java/org/robolectric/internal/TestEnvironment.java
index 333a1b17c..25ae294f3 100644
--- a/robolectric/src/main/java/org/robolectric/internal/TestEnvironment.java
+++ b/robolectric/src/main/java/org/robolectric/internal/TestEnvironment.java
@@ -1,17 +1,12 @@
 package org.robolectric.internal;
 
-import java.lang.reflect.Method;
 import org.robolectric.manifest.AndroidManifest;
 import org.robolectric.pluginapi.config.ConfigurationStrategy.Configuration;
 
-/**
- * An environment for running tests.
- */
+/** An environment for running tests. */
 public interface TestEnvironment {
 
-  void setUpApplicationState(
-      Method method,
-      Configuration config, AndroidManifest appManifest);
+  void setUpApplicationState(String tmpDirName, Configuration config, AndroidManifest appManifest);
 
   void tearDownApplication();
 
diff --git a/robolectric/src/main/java/org/robolectric/internal/dependency/LocalDependencyResolver.java b/robolectric/src/main/java/org/robolectric/internal/dependency/LocalDependencyResolver.java
index e5232d78e..5002efb61 100644
--- a/robolectric/src/main/java/org/robolectric/internal/dependency/LocalDependencyResolver.java
+++ b/robolectric/src/main/java/org/robolectric/internal/dependency/LocalDependencyResolver.java
@@ -16,17 +16,13 @@ public class LocalDependencyResolver implements DependencyResolver {
   @Override
   public URL getLocalArtifactUrl(DependencyJar dependency) {
     StringBuilder filenameBuilder = new StringBuilder();
-    filenameBuilder.append(dependency.getArtifactId())
-        .append("-")
-        .append(dependency.getVersion());
+    filenameBuilder.append(dependency.getArtifactId()).append("-").append(dependency.getVersion());
 
     if (dependency.getClassifier() != null) {
-      filenameBuilder.append("-")
-          .append(dependency.getClassifier());
+      filenameBuilder.append("-").append(dependency.getClassifier());
     }
 
-    filenameBuilder.append(".")
-        .append(dependency.getType());
+    filenameBuilder.append(".").append(dependency.getType());
 
     return fileToUrl(validateFile(new File(offlineJarDir, filenameBuilder.toString())));
   }
diff --git a/robolectric/src/main/java/org/robolectric/internal/dependency/PropertiesDependencyResolver.java b/robolectric/src/main/java/org/robolectric/internal/dependency/PropertiesDependencyResolver.java
index 837e966e5..25b7e19b9 100644
--- a/robolectric/src/main/java/org/robolectric/internal/dependency/PropertiesDependencyResolver.java
+++ b/robolectric/src/main/java/org/robolectric/internal/dependency/PropertiesDependencyResolver.java
@@ -42,8 +42,8 @@ public class PropertiesDependencyResolver implements DependencyResolver {
     String pathStr = properties.getProperty(depShortName);
     if (pathStr != null) {
       if (pathStr.indexOf(File.pathSeparatorChar) != -1) {
-        throw new IllegalArgumentException("didn't expect multiple files for " + dependency
-            + ": " + pathStr);
+        throw new IllegalArgumentException(
+            "didn't expect multiple files for " + dependency + ": " + pathStr);
       }
 
       Path path = baseDir.resolve(Paths.get(pathStr));
diff --git a/robolectric/src/main/java/org/robolectric/junit/rules/TimeoutRule.java b/robolectric/src/main/java/org/robolectric/junit/rules/TimeoutRule.java
new file mode 100644
index 000000000..58e8d9ca0
--- /dev/null
+++ b/robolectric/src/main/java/org/robolectric/junit/rules/TimeoutRule.java
@@ -0,0 +1,66 @@
+package org.robolectric.junit.rules;
+
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nonnull;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+import org.robolectric.internal.TimeLimitedStatement;
+
+/**
+ * Robolectric's replacement for JUnit's {@link org.junit.rules.Timeout Timeout}.
+ *
+ * <p>{@link org.junit.rules.Timeout Timeout} spawns a new thread, which is not compatible with
+ * Robolectric's Scheduler. Instead this Rule uses {@link
+ * org.robolectric.internal.TimeLimitedStatement TimeLimitedStatement} like {@code @Test(timeout=)}
+ * does.
+ *
+ * <p>Example usage:
+ *
+ * <pre>
+ * {@literal @}Rule public final TimeoutRule timeoutRule = TimeoutRule.seconds(40);
+ *
+ * {@literal @}Test
+ *  public void testWhichShouldFinishIn40Seconds() {
+ *    // ...
+ *  }
+ * </pre>
+ */
+public class TimeoutRule implements TestRule {
+
+  private final long timeout;
+  @Nonnull private final TimeUnit timeUnit;
+
+  /**
+   * Create a {@code TimeoutRule} instance with the timeout specified at the timeUnit of granularity
+   * of the provided {@code TimeUnit}.
+   *
+   * @param timeout the maximum time to allow the test to run before it should timeout
+   * @param timeUnit the time unit for the {@code timeout}
+   */
+  public TimeoutRule(long timeout, @Nonnull TimeUnit timeUnit) {
+    this.timeout = timeout;
+    this.timeUnit = timeUnit;
+  }
+
+  @Override
+  public Statement apply(Statement base, Description description) {
+    return new TimeLimitedStatement(timeUnit.toMillis(timeout), base);
+  }
+
+  /**
+   * Creates a {@link org.robolectric.junit.rules.TimeoutRule TimeoutRule} that will timeout a test
+   * after the given duration, in milliseconds.
+   */
+  public static TimeoutRule millis(long millis) {
+    return new TimeoutRule(millis, TimeUnit.MILLISECONDS);
+  }
+
+  /**
+   * Creates a {@link org.robolectric.junit.rules.TimeoutRule TimeoutRule} that will timeout a test
+   * after the given duration, in seconds.
+   */
+  public static TimeoutRule seconds(long seconds) {
+    return new TimeoutRule(seconds, TimeUnit.SECONDS);
+  }
+}
diff --git a/robolectric/src/main/java/org/robolectric/package-info.java b/robolectric/src/main/java/org/robolectric/package-info.java
index 23eab99b0..e68084b55 100644
--- a/robolectric/src/main/java/org/robolectric/package-info.java
+++ b/robolectric/src/main/java/org/robolectric/package-info.java
@@ -1,4 +1,2 @@
-/**
- * Package containing main Robolectric classes.
- */
-package org.robolectric;
\ No newline at end of file
+/** Package containing main Robolectric classes. */
+package org.robolectric;
diff --git a/robolectric/src/main/java/org/robolectric/plugins/ConfigConfigurer.java b/robolectric/src/main/java/org/robolectric/plugins/ConfigConfigurer.java
index c655d5677..8b9004151 100644
--- a/robolectric/src/main/java/org/robolectric/plugins/ConfigConfigurer.java
+++ b/robolectric/src/main/java/org/robolectric/plugins/ConfigConfigurer.java
@@ -25,8 +25,7 @@ public class ConfigConfigurer implements Configurer<Config> {
   }
 
   public ConfigConfigurer(
-      PackagePropertiesLoader packagePropertiesLoader,
-      GlobalConfigProvider defaultConfigProvider) {
+      PackagePropertiesLoader packagePropertiesLoader, GlobalConfigProvider defaultConfigProvider) {
     this.packagePropertiesLoader = packagePropertiesLoader;
     this.defaultConfig = Config.Builder.defaults().overlay(defaultConfigProvider.get()).build();
   }
@@ -63,5 +62,4 @@ public class ConfigConfigurer implements Configurer<Config> {
   public Config merge(@Nonnull Config parentConfig, @Nonnull Config childConfig) {
     return new Config.Builder(parentConfig).overlay(childConfig).build();
   }
-
 }
diff --git a/robolectric/src/main/java/org/robolectric/plugins/DefaultSdkPicker.java b/robolectric/src/main/java/org/robolectric/plugins/DefaultSdkPicker.java
index 02d29f7ff..9839c1439 100644
--- a/robolectric/src/main/java/org/robolectric/plugins/DefaultSdkPicker.java
+++ b/robolectric/src/main/java/org/robolectric/plugins/DefaultSdkPicker.java
@@ -36,7 +36,8 @@ public class DefaultSdkPicker implements SdkPicker {
 
   @Inject
   public DefaultSdkPicker(@Nonnull SdkCollection sdkCollection, Properties systemProperties) {
-    this(sdkCollection,
+    this(
+        sdkCollection,
         systemProperties == null ? null : systemProperties.getProperty("robolectric.enabledSdks"));
   }
 
@@ -169,5 +170,4 @@ public class DefaultSdkPicker implements SdkPicker {
 
     return sdks;
   }
-
 }
diff --git a/robolectric/src/main/java/org/robolectric/plugins/PackagePropertiesLoader.java b/robolectric/src/main/java/org/robolectric/plugins/PackagePropertiesLoader.java
index 3e2232599..145053932 100644
--- a/robolectric/src/main/java/org/robolectric/plugins/PackagePropertiesLoader.java
+++ b/robolectric/src/main/java/org/robolectric/plugins/PackagePropertiesLoader.java
@@ -19,15 +19,16 @@ import org.robolectric.pluginapi.config.Configurer;
 public class PackagePropertiesLoader {
 
   /**
-   * We should get very high cache hit rates even with a tiny cache if we're called sequentially
-   * by multiple {@link Configurer}s for the same package.
+   * We should get very high cache hit rates even with a tiny cache if we're called sequentially by
+   * multiple {@link Configurer}s for the same package.
    */
-  private final Map<String, Properties> cache = new LinkedHashMap<String, Properties>() {
-    @Override
-    protected boolean removeEldestEntry(Map.Entry<String, Properties> eldest) {
-      return size() > 3;
-    }
-  };
+  private final Map<String, Properties> cache =
+      new LinkedHashMap<String, Properties>() {
+        @Override
+        protected boolean removeEldestEntry(Map.Entry<String, Properties> eldest) {
+          return size() > 3;
+        }
+      };
 
   private Properties getConfig(@Nonnull String packageName, String propFileName) {
     StringBuilder buf = new StringBuilder();
diff --git a/robolectric/src/main/java/org/robolectric/plugins/ResourcesModeConfigurer.java b/robolectric/src/main/java/org/robolectric/plugins/ResourcesModeConfigurer.java
new file mode 100644
index 000000000..1333fa7c2
--- /dev/null
+++ b/robolectric/src/main/java/org/robolectric/plugins/ResourcesModeConfigurer.java
@@ -0,0 +1,18 @@
+package org.robolectric.plugins;
+
+import com.google.auto.service.AutoService;
+import java.util.Properties;
+import org.robolectric.annotation.ResourcesMode;
+import org.robolectric.annotation.ResourcesMode.Mode;
+import org.robolectric.pluginapi.config.Configurer;
+import org.robolectric.plugins.config.SingleValueConfigurer;
+
+/** Provides configuration to Robolectric for its {@link ResourcesMode} annotation. */
+@AutoService(Configurer.class)
+public class ResourcesModeConfigurer extends SingleValueConfigurer<ResourcesMode, Mode> {
+
+  public ResourcesModeConfigurer(
+      Properties systemProperties, PackagePropertiesLoader propertyFileLoader) {
+    super(ResourcesMode.class, Mode.class, Mode.BINARY, propertyFileLoader, systemProperties);
+  }
+}
diff --git a/robolectric/src/main/java/org/robolectric/plugins/SQLiteModeConfigurer.java b/robolectric/src/main/java/org/robolectric/plugins/SQLiteModeConfigurer.java
index d2505a17c..9aecebfac 100644
--- a/robolectric/src/main/java/org/robolectric/plugins/SQLiteModeConfigurer.java
+++ b/robolectric/src/main/java/org/robolectric/plugins/SQLiteModeConfigurer.java
@@ -39,5 +39,4 @@ public class SQLiteModeConfigurer extends SingleValueConfigurer<SQLiteMode, SQLi
     }
     return Mode.NATIVE;
   }
-
 }
diff --git a/robolectric/src/main/java/org/robolectric/plugins/SdkCollection.java b/robolectric/src/main/java/org/robolectric/plugins/SdkCollection.java
index c34c9fd06..d8bfd0792 100644
--- a/robolectric/src/main/java/org/robolectric/plugins/SdkCollection.java
+++ b/robolectric/src/main/java/org/robolectric/plugins/SdkCollection.java
@@ -10,9 +10,7 @@ import javax.inject.Inject;
 import org.robolectric.pluginapi.Sdk;
 import org.robolectric.pluginapi.SdkProvider;
 
-/**
- * Holds and provides details on the list of known SDKs.
- */
+/** Holds and provides details on the list of known SDKs. */
 @SuppressWarnings({"NewApi", "AndroidJdkLibsChecker"})
 public class SdkCollection {
 
@@ -23,20 +21,22 @@ public class SdkCollection {
   public SdkCollection(SdkProvider sdkProvider) {
     Collection<Sdk> knownSdks = sdkProvider.getSdks();
     SortedSet<Sdk> supportedSdks = new TreeSet<>();
-    knownSdks.forEach((sdk) -> {
-      if (this.knownSdks.put(sdk.getApiLevel(), sdk) != null) {
-        throw new IllegalArgumentException(
-            String.format("duplicate SDKs for API level %d", sdk.getApiLevel()));
-      }
-
-      if (sdk.isSupported()) {
-        supportedSdks.add(sdk);
-      } else {
-        System.err.printf(
-            "[Robolectric] WARN: %s. Tests won't be run on SDK %d unless explicitly requested.\n",
-            sdk.getUnsupportedMessage(), sdk.getApiLevel());
-      }
-    });
+    knownSdks.forEach(
+        (sdk) -> {
+          if (this.knownSdks.put(sdk.getApiLevel(), sdk) != null) {
+            throw new IllegalArgumentException(
+                String.format("duplicate SDKs for API level %d", sdk.getApiLevel()));
+          }
+
+          if (sdk.isSupported()) {
+            supportedSdks.add(sdk);
+          } else {
+            System.err.printf(
+                "[Robolectric] WARN: %s. Tests won't be run on SDK %d unless explicitly"
+                    + " requested.\n",
+                sdk.getUnsupportedMessage(), sdk.getApiLevel());
+          }
+        });
     this.supportedSdks = Collections.unmodifiableSortedSet(supportedSdks);
   }
 
diff --git a/robolectric/src/main/java/org/robolectric/plugins/config/SingleValueConfigurer.java b/robolectric/src/main/java/org/robolectric/plugins/config/SingleValueConfigurer.java
index cad0257e2..b1e38547c 100644
--- a/robolectric/src/main/java/org/robolectric/plugins/config/SingleValueConfigurer.java
+++ b/robolectric/src/main/java/org/robolectric/plugins/config/SingleValueConfigurer.java
@@ -151,9 +151,16 @@ public abstract class SingleValueConfigurer<A extends Annotation, T extends Enum
   }
 
   protected T valueFrom(String value) {
+    // in case someone makes an enumeration that doesn't use the standard
+    // uppercase naming convention.
     if (value == null) {
       return null;
     }
-    return Enum.valueOf(configurationType, value);
+    for (T each : configurationType.getEnumConstants()) {
+      if (each.name().equalsIgnoreCase(value)) {
+        return each;
+      }
+    }
+    throw new IllegalArgumentException("Unknown value for " + configurationType + ": " + value);
   }
 }
diff --git a/robolectric/src/main/java/org/robolectric/util/FragmentTestUtil.java b/robolectric/src/main/java/org/robolectric/util/FragmentTestUtil.java
deleted file mode 100644
index c6ded3042..000000000
--- a/robolectric/src/main/java/org/robolectric/util/FragmentTestUtil.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package org.robolectric.util;
-
-import static org.robolectric.shadows.ShadowLooper.shadowMainLooper;
-
-import android.app.Activity;
-import android.app.Fragment;
-import android.app.FragmentManager;
-import android.os.Bundle;
-import android.widget.LinearLayout;
-import org.robolectric.Robolectric;
-
-/**
- * @deprecated Please use {@link Robolectric#buildFragment(Class)} instead. This will be
- * removed in a forthcoming release,
- */
-@Deprecated
-public final class FragmentTestUtil {
-  
-  public static void startFragment(Fragment fragment) {
-    buildFragmentManager(FragmentUtilActivity.class)
-        .beginTransaction().add(fragment, null).commit();
-    shadowMainLooper().idleIfPaused();
-  }
-
-  public static void startFragment(Fragment fragment, Class<? extends Activity> activityClass) {
-    buildFragmentManager(activityClass)
-        .beginTransaction().add(fragment, null).commit();
-    shadowMainLooper().idleIfPaused();
-  }
-
-  public static void startVisibleFragment(Fragment fragment) {
-    buildFragmentManager(FragmentUtilActivity.class)
-        .beginTransaction().add(1, fragment, null).commit();
-    shadowMainLooper().idleIfPaused();
-  }
-
-  public static void startVisibleFragment(Fragment fragment,
-      Class<? extends Activity> activityClass, int containerViewId) {
-    buildFragmentManager(activityClass)
-        .beginTransaction().add(containerViewId, fragment, null).commit();
-    shadowMainLooper().idleIfPaused();
-  }
-
-  private static FragmentManager buildFragmentManager(Class<? extends Activity> activityClass) {
-    Activity activity = Robolectric.setupActivity(activityClass);
-    return activity.getFragmentManager();
-  }
-
-  private static class FragmentUtilActivity extends Activity {
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-      super.onCreate(savedInstanceState);
-      LinearLayout view = new LinearLayout(this);
-      view.setId(1);
-
-      setContentView(view);
-    }
-  }
-}
diff --git a/robolectric/src/test/java/com/foo/Receiver.java b/robolectric/src/test/java/com/foo/Receiver.java
index 719cf5136..0702ea5b3 100644
--- a/robolectric/src/test/java/com/foo/Receiver.java
+++ b/robolectric/src/test/java/com/foo/Receiver.java
@@ -7,7 +7,5 @@ import android.content.Intent;
 public class Receiver extends BroadcastReceiver {
 
   @Override
-  public void onReceive(Context context, Intent intent) {
-  }
-
+  public void onReceive(Context context, Intent intent) {}
 }
diff --git a/robolectric/src/test/java/org/robolectric/AttributeSetBuilderTest.java b/robolectric/src/test/java/org/robolectric/AttributeSetBuilderTest.java
index ae182bf00..d86ed9565 100644
--- a/robolectric/src/test/java/org/robolectric/AttributeSetBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/AttributeSetBuilderTest.java
@@ -25,29 +25,34 @@ public class AttributeSetBuilderTest {
 
   @Test
   public void getAttributeResourceValue_shouldReturnTheResourceValue() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(android.R.attr.text, "@android:string/ok")
-        .build();
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet()
+            .addAttribute(android.R.attr.text, "@android:string/ok")
+            .build();
 
     assertThat(roboAttributeSet.getAttributeResourceValue(ANDROID_NS, "text", 0))
         .isEqualTo(android.R.string.ok);
   }
 
   @Test
-  public void getAttributeResourceValueWithLeadingWhitespace_shouldReturnTheResourceValue() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(android.R.attr.text, " @android:string/ok")
-        .build();
+  public void getAttributeResourceValueWithLeadingWhitespace_shouldReturnTheResourceValue()
+      throws Exception {
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet()
+            .addAttribute(android.R.attr.text, " @android:string/ok")
+            .build();
 
     assertThat(roboAttributeSet.getAttributeResourceValue(ANDROID_NS, "text", 0))
         .isEqualTo(android.R.string.ok);
   }
 
   @Test
-  public void getSystemAttributeResourceValue_shouldReturnDefaultValueForNullResourceId() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(android.R.attr.text, AttributeResource.NULL_VALUE)
-        .build();
+  public void getSystemAttributeResourceValue_shouldReturnDefaultValueForNullResourceId()
+      throws Exception {
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet()
+            .addAttribute(android.R.attr.text, AttributeResource.NULL_VALUE)
+            .build();
 
     assertThat(
             roboAttributeSet.getAttributeResourceValue(
@@ -56,10 +61,10 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getSystemAttributeResourceValue_shouldReturnDefaultValueForNonMatchingNamespaceId() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(android.R.attr.id, "@+id/text1")
-        .build();
+  public void getSystemAttributeResourceValue_shouldReturnDefaultValueForNonMatchingNamespaceId()
+      throws Exception {
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet().addAttribute(android.R.attr.id, "@+id/text1").build();
 
     assertThat(
             roboAttributeSet.getAttributeResourceValue(
@@ -69,67 +74,64 @@ public class AttributeSetBuilderTest {
 
   @Test
   public void shouldCopeWithDefiningLocalIds() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(android.R.attr.id, "@+id/text1")
-        .build();
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet().addAttribute(android.R.attr.id, "@+id/text1").build();
 
     assertThat(roboAttributeSet.getAttributeResourceValue(ANDROID_NS, "id", 0))
         .isEqualTo(R.id.text1);
   }
 
   @Test
-  public void getAttributeResourceValue_withNamespace_shouldReturnTheResourceValue() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(R.attr.message, "@string/howdy")
-        .build();
+  public void getAttributeResourceValue_withNamespace_shouldReturnTheResourceValue()
+      throws Exception {
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet().addAttribute(R.attr.message, "@string/howdy").build();
 
     assertThat(roboAttributeSet.getAttributeResourceValue(APP_NS, "message", 0))
         .isEqualTo(R.string.howdy);
   }
 
   @Test
-  public void getAttributeResourceValue_shouldReturnDefaultValueWhenAttributeIsNull() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(android.R.attr.text, AttributeResource.NULL_VALUE)
-        .build();
+  public void getAttributeResourceValue_shouldReturnDefaultValueWhenAttributeIsNull()
+      throws Exception {
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet()
+            .addAttribute(android.R.attr.text, AttributeResource.NULL_VALUE)
+            .build();
 
-    assertThat(roboAttributeSet.getAttributeResourceValue(APP_NS, "message", -1))
-        .isEqualTo(-1);
+    assertThat(roboAttributeSet.getAttributeResourceValue(APP_NS, "message", -1)).isEqualTo(-1);
   }
 
   @Test
-  public void getAttributeResourceValue_shouldReturnDefaultValueWhenNotInAttributeSet() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .build();
+  public void getAttributeResourceValue_shouldReturnDefaultValueWhenNotInAttributeSet()
+      throws Exception {
+    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet().build();
 
-    assertThat(roboAttributeSet.getAttributeResourceValue(APP_NS, "message", -1))
-        .isEqualTo(-1);
+    assertThat(roboAttributeSet.getAttributeResourceValue(APP_NS, "message", -1)).isEqualTo(-1);
   }
 
   @Test
   public void getAttributeBooleanValue_shouldGetBooleanValuesFromAttributes() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(R.attr.isSugary, "true")
-        .build();
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet().addAttribute(R.attr.isSugary, "true").build();
 
-    assertThat(roboAttributeSet.getAttributeBooleanValue(APP_NS, "isSugary", false))
-        .isTrue();
+    assertThat(roboAttributeSet.getAttributeBooleanValue(APP_NS, "isSugary", false)).isTrue();
   }
 
   @Test
-  public void getAttributeBooleanValue_withNamespace_shouldGetBooleanValuesFromAttributes() throws Exception {
+  public void getAttributeBooleanValue_withNamespace_shouldGetBooleanValuesFromAttributes()
+      throws Exception {
     // org.robolectric.lib1.R values should be reconciled to match org.robolectric.R values.
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(R.attr.isSugary, "true")
-        .build();
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet().addAttribute(R.attr.isSugary, "true").build();
 
     assertThat(roboAttributeSet.getAttributeBooleanValue(APP_NS, "isSugary", false)).isTrue();
   }
 
   @Test
-  public void getAttributeBooleanValue_shouldReturnDefaultBooleanValueWhenNotInAttributeSet() throws Exception {
-    AttributeSet roboAttributeSet =  Robolectric.buildAttributeSet()
-        .build();
+  public void getAttributeBooleanValue_shouldReturnDefaultBooleanValueWhenNotInAttributeSet()
+      throws Exception {
+    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet().build();
 
     assertThat(
             roboAttributeSet.getAttributeBooleanValue(
@@ -139,12 +141,10 @@ public class AttributeSetBuilderTest {
 
   @Test
   public void getAttributeValue_byName_shouldReturnValueFromAttribute() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(R.attr.isSugary, "oh heck yeah")
-        .build();
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet().addAttribute(R.attr.isSugary, "oh heck yeah").build();
 
-    assertThat(roboAttributeSet.getAttributeValue(APP_NS, "isSugary"))
-        .isEqualTo("false");
+    assertThat(roboAttributeSet.getAttributeValue(APP_NS, "isSugary")).isEqualTo("false");
     assertThat(roboAttributeSet.getAttributeBooleanValue(APP_NS, "isSugary", true))
         .isEqualTo(false);
     assertThat(roboAttributeSet.getAttributeBooleanValue(APP_NS, "animalStyle", true))
@@ -152,40 +152,35 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeValue_byNameWithReference_shouldReturnFullyQualifiedValueFromAttribute() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(R.attr.isSugary, "@string/ok")
-        .build();
+  public void getAttributeValue_byNameWithReference_shouldReturnFullyQualifiedValueFromAttribute()
+      throws Exception {
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet().addAttribute(R.attr.isSugary, "@string/ok").build();
 
-    assertThat(roboAttributeSet.getAttributeValue(APP_NS, "isSugary"))
-        .isEqualTo("@" + R.string.ok);
+    assertThat(roboAttributeSet.getAttributeValue(APP_NS, "isSugary")).isEqualTo("@" + R.string.ok);
   }
 
   @Test
   public void getAttributeValue_byId_shouldReturnValueFromAttribute() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(R.attr.isSugary, "oh heck yeah")
-        .build();
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet().addAttribute(R.attr.isSugary, "oh heck yeah").build();
 
-    assertThat(roboAttributeSet.getAttributeValue(0))
-        .isEqualTo("false");
+    assertThat(roboAttributeSet.getAttributeValue(0)).isEqualTo("false");
   }
 
   @Test
-  public void getAttributeValue_byIdWithReference_shouldReturnValueFromAttribute() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(R.attr.isSugary, "@string/ok")
-        .build();
+  public void getAttributeValue_byIdWithReference_shouldReturnValueFromAttribute()
+      throws Exception {
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet().addAttribute(R.attr.isSugary, "@string/ok").build();
 
-    assertThat(roboAttributeSet.getAttributeValue(0))
-        .isEqualTo("@" + R.string.ok);
+    assertThat(roboAttributeSet.getAttributeValue(0)).isEqualTo("@" + R.string.ok);
   }
 
   @Test
   public void getAttributeIntValue_shouldReturnValueFromAttribute() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(R.attr.sugarinessPercent, "100")
-        .build();
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet().addAttribute(R.attr.sugarinessPercent, "100").build();
 
     assertThat(roboAttributeSet.getAttributeIntValue(APP_NS, "sugarinessPercent", 0))
         .isEqualTo(100);
@@ -193,65 +188,56 @@ public class AttributeSetBuilderTest {
 
   @Test
   public void getAttributeIntValue_shouldReturnHexValueFromAttribute() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(R.attr.sugarinessPercent, "0x10")
-        .build();
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet().addAttribute(R.attr.sugarinessPercent, "0x10").build();
 
-    assertThat(roboAttributeSet.getAttributeIntValue(APP_NS, "sugarinessPercent", 0))
-        .isEqualTo(16);
+    assertThat(roboAttributeSet.getAttributeIntValue(APP_NS, "sugarinessPercent", 0)).isEqualTo(16);
   }
 
   @Test
-  public void getAttributeIntValue_whenTypeAllowsIntOrEnum_withInt_shouldReturnInt() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(R.attr.numColumns, "3")
-        .build();
+  public void getAttributeIntValue_whenTypeAllowsIntOrEnum_withInt_shouldReturnInt()
+      throws Exception {
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet().addAttribute(R.attr.numColumns, "3").build();
 
-    assertThat(roboAttributeSet.getAttributeIntValue(APP_NS, "numColumns", 0))
-        .isEqualTo(3);
+    assertThat(roboAttributeSet.getAttributeIntValue(APP_NS, "numColumns", 0)).isEqualTo(3);
   }
 
   @Test
-  public void getAttributeIntValue_shouldReturnValueFromAttributeWhenNotInAttributeSet() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .build();
+  public void getAttributeIntValue_shouldReturnValueFromAttributeWhenNotInAttributeSet()
+      throws Exception {
+    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet().build();
 
     assertThat(roboAttributeSet.getAttributeIntValue(APP_NS, "sugarinessPercent", 42))
         .isEqualTo(42);
   }
 
   @Test
-  public void getAttributeIntValue_shouldReturnEnumValuesForEnumAttributesWhenNotInAttributeSet() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .build();
+  public void getAttributeIntValue_shouldReturnEnumValuesForEnumAttributesWhenNotInAttributeSet()
+      throws Exception {
+    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet().build();
 
-    assertThat(roboAttributeSet.getAttributeIntValue(APP_NS, "itemType", 24))
-        .isEqualTo(24);
+    assertThat(roboAttributeSet.getAttributeIntValue(APP_NS, "itemType", 24)).isEqualTo(24);
   }
 
   @Test
-  public void getAttributeIntValue_shouldReturnEnumValuesForEnumAttributesInAttributeSet() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(R.attr.itemType, "ungulate")
-        .build();
+  public void getAttributeIntValue_shouldReturnEnumValuesForEnumAttributesInAttributeSet()
+      throws Exception {
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet().addAttribute(R.attr.itemType, "ungulate").build();
 
-    assertThat(roboAttributeSet.getAttributeIntValue(APP_NS, "itemType", 24))
-        .isEqualTo(1);
+    assertThat(roboAttributeSet.getAttributeIntValue(APP_NS, "itemType", 24)).isEqualTo(1);
 
-    AttributeSet roboAttributeSet2 = Robolectric.buildAttributeSet()
-        .addAttribute(R.attr.itemType, "marsupial")
-        .build();
+    AttributeSet roboAttributeSet2 =
+        Robolectric.buildAttributeSet().addAttribute(R.attr.itemType, "marsupial").build();
 
-    assertThat(roboAttributeSet2.getAttributeIntValue(APP_NS, "itemType", 24))
-        .isEqualTo(0);
+    assertThat(roboAttributeSet2.getAttributeIntValue(APP_NS, "itemType", 24)).isEqualTo(0);
   }
 
   @Test
   public void shouldFailOnMissingEnumValue() throws Exception {
     try {
-      Robolectric.buildAttributeSet()
-          .addAttribute(R.attr.itemType, "simian")
-          .build();
+      Robolectric.buildAttributeSet().addAttribute(R.attr.itemType, "simian").build();
       fail("should fail");
     } catch (Exception e) {
       // expected
@@ -262,9 +248,7 @@ public class AttributeSetBuilderTest {
   @Test
   public void shouldFailOnMissingFlagValue() throws Exception {
     try {
-      Robolectric.buildAttributeSet()
-          .addAttribute(R.attr.scrollBars, "temporal")
-          .build();
+      Robolectric.buildAttributeSet().addAttribute(R.attr.scrollBars, "temporal").build();
       fail("should fail");
     } catch (Exception e) {
       // expected
@@ -273,10 +257,12 @@ public class AttributeSetBuilderTest {
   }
 
   @Test
-  public void getAttributeIntValue_shouldReturnFlagValuesForFlagAttributesInAttributeSet() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(R.attr.scrollBars, "horizontal|vertical")
-        .build();
+  public void getAttributeIntValue_shouldReturnFlagValuesForFlagAttributesInAttributeSet()
+      throws Exception {
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet()
+            .addAttribute(R.attr.scrollBars, "horizontal|vertical")
+            .build();
 
     assertThat(roboAttributeSet.getAttributeIntValue(APP_NS, "scrollBars", 24))
         .isEqualTo(0x100 | 0x200);
@@ -284,18 +270,17 @@ public class AttributeSetBuilderTest {
 
   @Test
   public void getAttributeFloatValue_shouldGetFloatValuesFromAttributes() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(R.attr.aspectRatio, "1234.456")
-        .build();
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet().addAttribute(R.attr.aspectRatio, "1234.456").build();
 
     assertThat(roboAttributeSet.getAttributeFloatValue(APP_NS, "aspectRatio", 78.9f))
         .isEqualTo(1234.456f);
   }
 
   @Test
-  public void getAttributeFloatValue_shouldReturnDefaultFloatValueWhenNotInAttributeSet() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .build();
+  public void getAttributeFloatValue_shouldReturnDefaultFloatValueWhenNotInAttributeSet()
+      throws Exception {
+    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet().build();
 
     assertThat(roboAttributeSet.getAttributeFloatValue(APP_NS, "aspectRatio", 78.9f))
         .isEqualTo(78.9f);
@@ -310,39 +295,34 @@ public class AttributeSetBuilderTest {
 
   @Test
   public void getClassAndIdAttribute_returnsAttr() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .setIdAttribute("the id")
-        .setClassAttribute("the class")
-        .build();
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet()
+            .setIdAttribute("the id")
+            .setClassAttribute("the class")
+            .build();
     assertThat(roboAttributeSet.getClassAttribute()).isEqualTo("the class");
     assertThat(roboAttributeSet.getIdAttribute()).isEqualTo("the id");
   }
 
   @Test
   public void getStyleAttribute_returnsZeroWhenNoStyle() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .build();
+    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet().build();
 
-    assertThat(roboAttributeSet.getStyleAttribute())
-        .isEqualTo(0);
+    assertThat(roboAttributeSet.getStyleAttribute()).isEqualTo(0);
   }
 
   @Test
   public void getStyleAttribute_returnsCorrectValue() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .setStyleAttribute("@style/Gastropod")
-        .build();
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet().setStyleAttribute("@style/Gastropod").build();
 
-    assertThat(roboAttributeSet.getStyleAttribute())
-        .isEqualTo(R.style.Gastropod);
+    assertThat(roboAttributeSet.getStyleAttribute()).isEqualTo(R.style.Gastropod);
   }
 
   @Test
   public void getStyleAttribute_whenStyleIsBogus() throws Exception {
     try {
-      Robolectric.buildAttributeSet()
-            .setStyleAttribute("@style/non_existent_style")
-            .build();
+      Robolectric.buildAttributeSet().setStyleAttribute("@style/non_existent_style").build();
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e)
@@ -353,33 +333,34 @@ public class AttributeSetBuilderTest {
 
   @Test
   public void getAttributeNameResource() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(R.attr.aspectRatio, "1")
-        .build();
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet().addAttribute(R.attr.aspectRatio, "1").build();
 
-    assertThat(roboAttributeSet.getAttributeNameResource(0))
-        .isEqualTo(R.attr.aspectRatio);
+    assertThat(roboAttributeSet.getAttributeNameResource(0)).isEqualTo(R.attr.aspectRatio);
   }
 
   @Test
   public void shouldReturnAttributesInOrderOfNameResId() throws Exception {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(android.R.attr.height, "1px")
-        .addAttribute(R.attr.animalStyle, "meow")
-        .addAttribute(android.R.attr.width, "1px")
-        .build();
-
-    assertThat(asList(
-        roboAttributeSet.getAttributeName(0),
-        roboAttributeSet.getAttributeName(1),
-        roboAttributeSet.getAttributeName(2)
-    )).containsExactly("height", "width", "animalStyle");
-
-    assertThat(asList(
-        roboAttributeSet.getAttributeNameResource(0),
-        roboAttributeSet.getAttributeNameResource(1),
-        roboAttributeSet.getAttributeNameResource(2)
-    )).containsExactly(android.R.attr.height, android.R.attr.width, R.attr.animalStyle);
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet()
+            .addAttribute(android.R.attr.height, "1px")
+            .addAttribute(R.attr.animalStyle, "meow")
+            .addAttribute(android.R.attr.width, "1px")
+            .build();
+
+    assertThat(
+            asList(
+                roboAttributeSet.getAttributeName(0),
+                roboAttributeSet.getAttributeName(1),
+                roboAttributeSet.getAttributeName(2)))
+        .containsExactly("height", "width", "animalStyle");
+
+    assertThat(
+            asList(
+                roboAttributeSet.getAttributeNameResource(0),
+                roboAttributeSet.getAttributeNameResource(1),
+                roboAttributeSet.getAttributeNameResource(2)))
+        .containsExactly(android.R.attr.height, android.R.attr.width, R.attr.animalStyle);
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/BootstrapDeferringRobolectricTestRunner.java b/robolectric/src/test/java/org/robolectric/BootstrapDeferringRobolectricTestRunner.java
index 72ae8b082..231308c58 100644
--- a/robolectric/src/test/java/org/robolectric/BootstrapDeferringRobolectricTestRunner.java
+++ b/robolectric/src/test/java/org/robolectric/BootstrapDeferringRobolectricTestRunner.java
@@ -51,8 +51,7 @@ public class BootstrapDeferringRobolectricTestRunner extends RobolectricTestRunn
 
   @Retention(RetentionPolicy.RUNTIME)
   @Target(ElementType.FIELD)
-  public @interface RoboInject {
-  }
+  public @interface RoboInject {}
 
   public static class MyTestLifecycle extends DefaultTestLifecycle {
     @Override
@@ -79,8 +78,6 @@ public class BootstrapDeferringRobolectricTestRunner extends RobolectricTestRunn
 
     void changeConfig(Configuration config);
 
-    boolean isLegacyResources();
-
     AndroidManifest getAppManifest();
 
     void changeAppManifest(AndroidManifest manifest);
@@ -89,5 +86,4 @@ public class BootstrapDeferringRobolectricTestRunner extends RobolectricTestRunn
 
     void resetState();
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/BootstrapWrapper.java b/robolectric/src/test/java/org/robolectric/BootstrapWrapper.java
index 5e3bfd14a..ed1f70d1c 100644
--- a/robolectric/src/test/java/org/robolectric/BootstrapWrapper.java
+++ b/robolectric/src/test/java/org/robolectric/BootstrapWrapper.java
@@ -1,10 +1,8 @@
 package org.robolectric;
 
-import java.lang.reflect.Method;
 import javax.inject.Named;
 import org.robolectric.BootstrapDeferringRobolectricTestRunner.BootstrapWrapperI;
 import org.robolectric.android.internal.AndroidTestEnvironment;
-import org.robolectric.internal.ResourcesMode;
 import org.robolectric.internal.ShadowProvider;
 import org.robolectric.manifest.AndroidManifest;
 import org.robolectric.pluginapi.Sdk;
@@ -15,25 +13,24 @@ import org.robolectric.pluginapi.config.ConfigurationStrategy.Configuration;
 public class BootstrapWrapper extends AndroidTestEnvironment implements BootstrapWrapperI {
   public AndroidTestEnvironment wrappedTestEnvironment;
   public boolean legacyResources;
-  public Method method;
+  public String tmpDirName;
   public Configuration config;
   public AndroidManifest appManifest;
 
   public BootstrapWrapper(
       @Named("runtimeSdk") Sdk runtimeSdk,
       @Named("compileSdk") Sdk compileSdk,
-      ResourcesMode resourcesMode, ApkLoader apkLoader,
       ShadowProvider[] shadowProviders,
       TestEnvironmentLifecyclePlugin[] lifecyclePlugins) {
-    super(runtimeSdk, compileSdk, resourcesMode, apkLoader, shadowProviders, lifecyclePlugins);
-    this.wrappedTestEnvironment = new AndroidTestEnvironment(runtimeSdk, compileSdk, resourcesMode,
-        apkLoader, shadowProviders, lifecyclePlugins);
+    super(runtimeSdk, compileSdk, shadowProviders, lifecyclePlugins);
+    this.wrappedTestEnvironment =
+        new AndroidTestEnvironment(runtimeSdk, compileSdk, shadowProviders, lifecyclePlugins);
   }
 
   @Override
-  public void setUpApplicationState(Method method, Configuration config,
-      AndroidManifest appManifest) {
-    this.method = method;
+  public void setUpApplicationState(
+      String tmpDirName, Configuration config, AndroidManifest appManifest) {
+    this.tmpDirName = tmpDirName;
     this.config = config;
     this.appManifest = appManifest;
 
@@ -47,7 +44,7 @@ public class BootstrapWrapper extends AndroidTestEnvironment implements Bootstra
 
   @Override
   public void callSetUpApplicationState() {
-    wrappedTestEnvironment.setUpApplicationState(method, config, appManifest);
+    wrappedTestEnvironment.setUpApplicationState(tmpDirName, config, appManifest);
   }
 
   @Override
@@ -55,11 +52,6 @@ public class BootstrapWrapper extends AndroidTestEnvironment implements Bootstra
     this.config = config;
   }
 
-  @Override
-  public boolean isLegacyResources() {
-    return legacyResources;
-  }
-
   @Override
   public AndroidManifest getAppManifest() {
     return appManifest;
diff --git a/robolectric/src/test/java/org/robolectric/ConfigTest.java b/robolectric/src/test/java/org/robolectric/ConfigTest.java
index 1329c2bf6..a13e4eea9 100644
--- a/robolectric/src/test/java/org/robolectric/ConfigTest.java
+++ b/robolectric/src/test/java/org/robolectric/ConfigTest.java
@@ -137,8 +137,7 @@ public class ConfigTest {
     Properties properties = new Properties();
     properties.setProperty("sdk", "1, 2, ALL_SDKS, TARGET_SDK, OLDEST_SDK, NEWEST_SDK, 666");
     Config config = Config.Implementation.fromProperties(properties);
-    assertThat(sdksIn(config))
-        .isEqualTo("sdk=[1, 2, -2, -3, -4, -5, 666], minSdk=-1, maxSdk=-1");
+    assertThat(sdksIn(config)).isEqualTo("sdk=[1, 2, -2, -3, -4, -5, 666], minSdk=-1, maxSdk=-1");
   }
 
   @Test
@@ -147,30 +146,26 @@ public class ConfigTest {
     properties.setProperty("minSdk", "OLDEST_SDK");
     properties.setProperty("maxSdk", "NEWEST_SDK");
     Config config = Config.Implementation.fromProperties(properties);
-    assertThat(sdksIn(config))
-        .isEqualTo("sdk=[], minSdk=-4, maxSdk=-5");
+    assertThat(sdksIn(config)).isEqualTo("sdk=[], minSdk=-4, maxSdk=-5");
   }
 
   @Test
   public void testIllegalArguments_sdkMutualExclusion() throws Exception {
     try {
-      new Config.Builder()
-          .setSdk(16, 17, 18).setMinSdk(16).setMaxSdk(18)
-          .build();
+      new Config.Builder().setSdk(16, 17, 18).setMinSdk(16).setMaxSdk(18).build();
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage())
-          .isEqualTo("sdk and minSdk/maxSdk may not be specified together (sdk=[16, 17, 18],"
-                         + " minSdk=16, maxSdk=18)");
+          .isEqualTo(
+              "sdk and minSdk/maxSdk may not be specified together (sdk=[16, 17, 18],"
+                  + " minSdk=16, maxSdk=18)");
     }
   }
 
   @Test
   public void testIllegalArguments_minMaxSdkRange() throws Exception {
     try {
-      new Config.Builder()
-          .setMinSdk(18).setMaxSdk(16)
-          .build();
+      new Config.Builder().setMinSdk(18).setMaxSdk(16).build();
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage())
diff --git a/robolectric/src/test/java/org/robolectric/ConfigTestReceiver.java b/robolectric/src/test/java/org/robolectric/ConfigTestReceiver.java
index e2804a10f..de1b0b669 100644
--- a/robolectric/src/test/java/org/robolectric/ConfigTestReceiver.java
+++ b/robolectric/src/test/java/org/robolectric/ConfigTestReceiver.java
@@ -15,10 +15,8 @@ public class ConfigTestReceiver extends BroadcastReceiver {
     intentsReceived.add(intent);
   }
 
-  static public class InnerReceiver extends BroadcastReceiver {
+  public static class InnerReceiver extends BroadcastReceiver {
     @Override
-    public void onReceive(Context context, Intent intent) {
-
-    }
+    public void onReceive(Context context, Intent intent) {}
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/DotConfigTestReceiver.java b/robolectric/src/test/java/org/robolectric/DotConfigTestReceiver.java
index 2f0c20f4f..fab602f59 100644
--- a/robolectric/src/test/java/org/robolectric/DotConfigTestReceiver.java
+++ b/robolectric/src/test/java/org/robolectric/DotConfigTestReceiver.java
@@ -7,7 +7,5 @@ import android.content.Intent;
 public class DotConfigTestReceiver extends BroadcastReceiver {
 
   @Override
-  public void onReceive(Context context, Intent intent) {
-  }
-
+  public void onReceive(Context context, Intent intent) {}
 }
diff --git a/robolectric/src/test/java/org/robolectric/FakeApp.java b/robolectric/src/test/java/org/robolectric/FakeApp.java
index 279596b01..6a32b5b8c 100644
--- a/robolectric/src/test/java/org/robolectric/FakeApp.java
+++ b/robolectric/src/test/java/org/robolectric/FakeApp.java
@@ -4,5 +4,4 @@ import android.app.Application;
 import org.robolectric.annotation.internal.Instrument;
 
 @Instrument
-public class FakeApp extends Application {
-}
+public class FakeApp extends Application {}
diff --git a/robolectric/src/test/java/org/robolectric/IncludedDependenciesTest.java b/robolectric/src/test/java/org/robolectric/IncludedDependenciesTest.java
index 8c8dc7398..f073ac29b 100644
--- a/robolectric/src/test/java/org/robolectric/IncludedDependenciesTest.java
+++ b/robolectric/src/test/java/org/robolectric/IncludedDependenciesTest.java
@@ -20,7 +20,8 @@ public class IncludedDependenciesTest {
   @Test
   public void xppShouldWork() throws Exception {
     XmlPullParser xmlPullParser = XmlPullParserFactory.newInstance().newPullParser();
-    xmlPullParser.setInput(new StringReader("<?xml version=\"1.0\" encoding=\"UTF-8\"?><test name=\"value\"/>"));
+    xmlPullParser.setInput(
+        new StringReader("<?xml version=\"1.0\" encoding=\"UTF-8\"?><test name=\"value\"/>"));
     assertEquals(XmlPullParser.START_TAG, xmlPullParser.nextTag());
     assertEquals(1, xmlPullParser.getAttributeCount());
     assertEquals("name", xmlPullParser.getAttributeName(0));
diff --git a/robolectric/src/test/java/org/robolectric/InvokeDynamicTest.java b/robolectric/src/test/java/org/robolectric/InvokeDynamicTest.java
index 109b52588..98dfc1cd8 100644
--- a/robolectric/src/test/java/org/robolectric/InvokeDynamicTest.java
+++ b/robolectric/src/test/java/org/robolectric/InvokeDynamicTest.java
@@ -69,8 +69,7 @@ public class InvokeDynamicTest {
   public static class RealCopy {
     public int x;
 
-    public void setX(int x) {
-    }
+    public void setX(int x) {}
   }
 
   @Implements(Real.class)
@@ -114,7 +113,5 @@ public class InvokeDynamicTest {
   }
 
   @Implements(value = DoNothing.class, callThroughByDefault = false)
-  public static class DoNothingShadow {
-
-  }
+  public static class DoNothingShadow {}
 }
diff --git a/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerClassLoaderTest.java b/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerClassLoaderTest.java
index aeb8de8cf..f916b0e8c 100644
--- a/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerClassLoaderTest.java
+++ b/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerClassLoaderTest.java
@@ -10,7 +10,8 @@ import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 
 /**
- * Parameterized tests using an Android class originally created outside of the Robolectric classloader.
+ * Parameterized tests using an Android class originally created outside of the Robolectric
+ * classloader.
  */
 @RunWith(ParameterizedRobolectricTestRunner.class)
 public final class ParameterizedRobolectricTestRunnerClassLoaderTest {
@@ -30,9 +31,7 @@ public final class ParameterizedRobolectricTestRunnerClassLoaderTest {
 
   @ParameterizedRobolectricTestRunner.Parameters
   public static Collection getTestData() {
-    Object[][] data = {
-        { Uri.parse("http://host/") }
-    };
+    Object[][] data = {{Uri.parse("http://host/")}};
     return Arrays.asList(data);
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerConfigTest.java b/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerConfigTest.java
index 4045cac1f..97c340e3a 100644
--- a/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerConfigTest.java
+++ b/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerConfigTest.java
@@ -40,12 +40,7 @@ public final class ParameterizedRobolectricTestRunnerConfigTest {
 
   @ParameterizedRobolectricTestRunner.Parameters(name = "ConfigTest: {0}")
   public static Collection getTestData() {
-    Object[][] data = {
-        { 1 },
-        { 2 },
-        { 3 },
-        { 4 }
-    };
+    Object[][] data = {{1}, {2}, {3}, {4}};
     return Arrays.asList(data);
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerNormalTest.java b/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerNormalTest.java
index 110f3de83..975c4b6e9 100644
--- a/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerNormalTest.java
+++ b/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerNormalTest.java
@@ -23,12 +23,13 @@ public final class ParameterizedRobolectricTestRunnerNormalTest {
   private final int expectedProduct;
   private final int expectedQuotient;
 
-  public ParameterizedRobolectricTestRunnerNormalTest(int first,
-                                                      int second,
-                                                      int expectedSum,
-                                                      int expectedDifference,
-                                                      int expectedProduct,
-                                                      int expectedQuotient) {
+  public ParameterizedRobolectricTestRunnerNormalTest(
+      int first,
+      int second,
+      int expectedSum,
+      int expectedDifference,
+      int expectedProduct,
+      int expectedQuotient) {
     this.first = first;
     this.second = second;
     this.expectedSum = expectedSum;
@@ -64,10 +65,10 @@ public final class ParameterizedRobolectricTestRunnerNormalTest {
   @ParameterizedRobolectricTestRunner.Parameters(name = "Java Math Test: {0}, {1}")
   public static Collection getTestData() {
     Object[][] data = {
-        { 1, 1, 2, 0, 1, 1 },
-        { 2, 1, 3, 1, 2, 2 },
-        { 2, 2, 4, 0, 4, 1 },
-        { 4, 4, 8, 0, 16, 1 }
+      {1, 1, 2, 0, 1, 1},
+      {2, 1, 3, 1, 2, 2},
+      {2, 2, 4, 0, 4, 1},
+      {4, 4, 8, 0, 16, 1}
     };
     return Arrays.asList(data);
   }
diff --git a/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerUriTest.java b/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerUriTest.java
index 81137c702..2e06614f6 100644
--- a/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerUriTest.java
+++ b/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerUriTest.java
@@ -21,9 +21,8 @@ public final class ParameterizedRobolectricTestRunnerUriTest {
   private final String resourcePath;
   private final Uri expectedUri;
 
-  public ParameterizedRobolectricTestRunnerUriTest(String basePath,
-                                                   String resourcePath,
-                                                   String expectedUri) {
+  public ParameterizedRobolectricTestRunnerUriTest(
+      String basePath, String resourcePath, String expectedUri) {
     this.basePath = basePath;
     this.resourcePath = resourcePath;
     this.expectedUri = Uri.parse(expectedUri);
@@ -38,10 +37,10 @@ public final class ParameterizedRobolectricTestRunnerUriTest {
   @ParameterizedRobolectricTestRunner.Parameters(name = "URI Test: {0} + {1}")
   public static Collection getTestData() {
     Object[][] data = {
-        { "http://host", "resource", "http://host/resource" },
-        { "http://host/", "resource", "http://host/resource" },
-        { "http://host", "/resource", "http://host/resource" },
-        { "http://host/", "/resource", "http://host/resource" }
+      {"http://host", "resource", "http://host/resource"},
+      {"http://host/", "resource", "http://host/resource"},
+      {"http://host", "/resource", "http://host/resource"},
+      {"http://host/", "/resource", "http://host/resource"}
     };
     return Arrays.asList(data);
   }
diff --git a/robolectric/src/test/java/org/robolectric/QualifiersTest.java b/robolectric/src/test/java/org/robolectric/QualifiersTest.java
index 1d5e4a77f..b2cdc16a4 100644
--- a/robolectric/src/test/java/org/robolectric/QualifiersTest.java
+++ b/robolectric/src/test/java/org/robolectric/QualifiersTest.java
@@ -46,50 +46,63 @@ public class QualifiersTest {
   @Test
   @Config(qualifiers = "land")
   public void orientation() throws Exception {
-    assertThat(resources.getConfiguration().orientation).isEqualTo(Configuration.ORIENTATION_LANDSCAPE);
+    assertThat(resources.getConfiguration().orientation)
+        .isEqualTo(Configuration.ORIENTATION_LANDSCAPE);
   }
 
   @Config(qualifiers = "en")
-  @Test public void shouldBeEnglish() {
+  @Test
+  public void shouldBeEnglish() {
     Locale locale = resources.getConfiguration().locale;
     assertThat(locale.getLanguage()).isEqualTo("en");
   }
 
   @Config(qualifiers = "ja")
-  @Test public void shouldBeJapanese() {
+  @Test
+  public void shouldBeJapanese() {
     Locale locale = resources.getConfiguration().locale;
     assertThat(locale.getLanguage()).isEqualTo("ja");
   }
 
   @Config(qualifiers = "fr")
-  @Test public void shouldBeFrench() {
+  @Test
+  public void shouldBeFrench() {
     Locale locale = resources.getConfiguration().locale;
     assertThat(locale.getLanguage()).isEqualTo("fr");
   }
 
-  @Test @Config(qualifiers = "fr")
+  @Test
+  @Config(qualifiers = "fr")
   public void shouldGetFromMethod() throws Exception {
     assertThat(RuntimeEnvironment.getQualifiers()).contains("fr");
   }
 
-  @Test @Config(qualifiers = "de")
+  @Test
+  @Config(qualifiers = "de")
   public void getQuantityString() throws Exception {
-    assertThat(resources.getQuantityString(R.plurals.minute, 2)).isEqualTo(
-        resources.getString(R.string.minute_plural));
+    assertThat(resources.getQuantityString(R.plurals.minute, 2))
+        .isEqualTo(resources.getString(R.string.minute_plural));
   }
 
   @Test
   public void inflateLayout_defaultsTo_sw320dp() throws Exception {
-    View view = Robolectric.setupActivity(Activity.class).getLayoutInflater().inflate(R.layout.layout_smallest_width, null);
+    View view =
+        Robolectric.setupActivity(Activity.class)
+            .getLayoutInflater()
+            .inflate(R.layout.layout_smallest_width, null);
     TextView textView = view.findViewById(R.id.text1);
     assertThat(textView.getText().toString()).isEqualTo("320");
 
     assertThat(resources.getConfiguration().smallestScreenWidthDp).isEqualTo(320);
   }
 
-  @Test @Config(qualifiers = "sw720dp")
+  @Test
+  @Config(qualifiers = "sw720dp")
   public void inflateLayout_overridesTo_sw720dp() throws Exception {
-    View view = Robolectric.setupActivity(Activity.class).getLayoutInflater().inflate(R.layout.layout_smallest_width, null);
+    View view =
+        Robolectric.setupActivity(Activity.class)
+            .getLayoutInflater()
+            .inflate(R.layout.layout_smallest_width, null);
     TextView textView = view.findViewById(R.id.text1);
     assertThat(textView.getText().toString()).isEqualTo("720");
 
@@ -108,21 +121,22 @@ public class QualifiersTest {
     assertThat(resources.getConfiguration().screenWidthDp).isEqualTo(320);
   }
 
-  @Test @Config(qualifiers = "land")
+  @Test
+  @Config(qualifiers = "land")
   public void setQualifiers_updatesSystemAndAppResources() throws Exception {
     Resources systemResources = Resources.getSystem();
     Resources appResources = getApplicationContext().getResources();
 
-    assertThat(systemResources.getConfiguration().orientation).isEqualTo(
-        Configuration.ORIENTATION_LANDSCAPE);
-    assertThat(appResources.getConfiguration().orientation).isEqualTo(
-        Configuration.ORIENTATION_LANDSCAPE);
+    assertThat(systemResources.getConfiguration().orientation)
+        .isEqualTo(Configuration.ORIENTATION_LANDSCAPE);
+    assertThat(appResources.getConfiguration().orientation)
+        .isEqualTo(Configuration.ORIENTATION_LANDSCAPE);
 
     RuntimeEnvironment.setQualifiers("port");
-    assertThat(systemResources.getConfiguration().orientation).isEqualTo(
-        Configuration.ORIENTATION_PORTRAIT);
-    assertThat(appResources.getConfiguration().orientation).isEqualTo(
-        Configuration.ORIENTATION_PORTRAIT);
+    assertThat(systemResources.getConfiguration().orientation)
+        .isEqualTo(Configuration.ORIENTATION_PORTRAIT);
+    assertThat(appResources.getConfiguration().orientation)
+        .isEqualTo(Configuration.ORIENTATION_PORTRAIT);
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerClassLoaderConfigTest.java b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerClassLoaderConfigTest.java
index bc0d4f904..4e4b0fee6 100644
--- a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerClassLoaderConfigTest.java
+++ b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerClassLoaderConfigTest.java
@@ -26,7 +26,8 @@ public class RobolectricTestRunnerClassLoaderConfigTest {
     assertThat(DummyClass.class.getName()).startsWith(DummyClass.class.getPackage().getName());
   }
 
-  @Test public void testPackagesFromParentClassLoaderAreMadeAvailableByName() {
+  @Test
+  public void testPackagesFromParentClassLoaderAreMadeAvailableByName() {
     assertThat(Test.class.getPackage()).isNotNull();
     assertThat(Package.getPackage("org.junit")).isNotNull();
     assertThat(Package.getPackage("org.junit")).isEqualTo(Test.class.getPackage());
diff --git a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerMultiApiTest.java b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerMultiApiTest.java
index 38ab0da4d..ea96e0ddc 100644
--- a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerMultiApiTest.java
+++ b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerMultiApiTest.java
@@ -41,9 +41,10 @@ public class RobolectricTestRunnerMultiApiTest {
   private static final int[] APIS_FOR_TEST = {LOLLIPOP, LOLLIPOP_MR1, M, N, N_MR1, O};
 
   private static SdkPicker delegateSdkPicker;
-  private static final Injector INJECTOR = defaultInjector()
-      .bind(SdkPicker.class, (config, usesSdk) -> delegateSdkPicker.selectSdks(config, usesSdk))
-      .build();
+  private static final Injector INJECTOR =
+      defaultInjector()
+          .bind(SdkPicker.class, (config, usesSdk) -> delegateSdkPicker.selectSdks(config, usesSdk))
+          .build();
 
   private RobolectricTestRunner runner;
   private RunNotifier runNotifier;
@@ -238,12 +239,14 @@ public class RobolectricTestRunnerMultiApiTest {
 
   @Config(sdk = Config.ALL_SDKS)
   public static class TestWithNoConfig {
-    @Test public void test() {}
+    @Test
+    public void test() {}
   }
 
   @Config(sdk = {M, N})
   public static class TestClassConfigWithSdkGroup {
-    @Test public void testShouldRunApi18() {
+    @Test
+    public void testShouldRunApi18() {
       assertThat(Build.VERSION.SDK_INT).isIn(Range.closed(M, N));
     }
   }
@@ -259,21 +262,24 @@ public class RobolectricTestRunnerMultiApiTest {
 
   @Config(minSdk = N)
   public static class TestClassNAndUp {
-    @Test public void testSomeApiLevel() {
+    @Test
+    public void testSomeApiLevel() {
       assertThat(Build.VERSION.SDK_INT).isAtLeast(N);
     }
   }
 
   @Config(maxSdk = N)
   public static class TestClassUpToAndIncludingN {
-    @Test public void testSomeApiLevel() {
+    @Test
+    public void testSomeApiLevel() {
       assertThat(Build.VERSION.SDK_INT).isAtMost(N);
     }
   }
 
   @Config(minSdk = LOLLIPOP_MR1, maxSdk = N)
   public static class TestClassBetweenLollipopMr1AndN {
-    @Test public void testSomeApiLevel() {
+    @Test
+    public void testSomeApiLevel() {
       assertThat(Build.VERSION.SDK_INT).isIn(Range.closed(LOLLIPOP_MR1, N));
     }
   }
@@ -325,8 +331,7 @@ public class RobolectricTestRunnerMultiApiTest {
   private static List<Integer> apisFor(List<FrameworkMethod> children) {
     List<Integer> apis = new ArrayList<>();
     for (FrameworkMethod child : children) {
-      apis.add(
-          ((RobolectricTestRunner.RobolectricFrameworkMethod) child).getSdk().getApiLevel());
+      apis.add(((RobolectricTestRunner.RobolectricFrameworkMethod) child).getSdk().getApiLevel());
     }
     return apis;
   }
diff --git a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerSelfTest.java b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerSelfTest.java
index d44ccbd40..6601076e6 100644
--- a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerSelfTest.java
+++ b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerSelfTest.java
@@ -80,7 +80,8 @@ public class RobolectricTestRunnerSelfTest {
     assertThat(Build.VERSION.RELEASE).isEqualTo("5.0.2");
   }
 
-  @Test public void hamcrestMatchersDontBlowUpDuringLinking() throws Exception {
+  @Test
+  public void hamcrestMatchersDontBlowUpDuringLinking() throws Exception {
     org.hamcrest.MatcherAssert.assertThat(true, CoreMatchers.is(true));
   }
 
@@ -98,7 +99,7 @@ public class RobolectricTestRunnerSelfTest {
     public void onCreate() {
       this.onCreateWasCalled = true;
     }
-    
+
     @Override
     public void onTerminate() {
       onTerminateCalledFromMain =
diff --git a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerTest.java b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerTest.java
index 8bb56391a..f24405ead 100644
--- a/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerTest.java
+++ b/robolectric/src/test/java/org/robolectric/RobolectricTestRunnerTest.java
@@ -50,7 +50,6 @@ import org.robolectric.annotation.experimental.LazyApplication;
 import org.robolectric.annotation.experimental.LazyApplication.LazyLoad;
 import org.robolectric.config.ConfigurationRegistry;
 import org.robolectric.internal.AndroidSandbox.TestEnvironmentSpec;
-import org.robolectric.internal.ResourcesMode;
 import org.robolectric.internal.ShadowProvider;
 import org.robolectric.manifest.AndroidManifest;
 import org.robolectric.pluginapi.Sdk;
@@ -100,17 +99,19 @@ public class RobolectricTestRunnerTest {
   @Test
   public void ignoredTestCanSpecifyUnsupportedSdkWithoutExploding() throws Exception {
     RobolectricTestRunner runner =
-        new RobolectricTestRunner(TestWithOldSdk.class,
+        new RobolectricTestRunner(
+            TestWithOldSdk.class,
             org.robolectric.RobolectricTestRunner.defaultInjector()
                 .bind(org.robolectric.pluginapi.SdkPicker.class, AllEnabledSdkPicker.class)
                 .build());
     runner.run(notifier);
-    assertThat(events).containsExactly(
-        "started: oldSdkMethod",
-        "failure: API level 11 is not available",
-        "finished: oldSdkMethod",
-        "ignored: ignoredOldSdkMethod"
-    ).inOrder();
+    assertThat(events)
+        .containsExactly(
+            "started: oldSdkMethod",
+            "failure: API level 11 is not available",
+            "finished: oldSdkMethod",
+            "ignored: ignoredOldSdkMethod")
+        .inOrder();
   }
 
   @Test
@@ -147,7 +148,8 @@ public class RobolectricTestRunnerTest {
         new SingleSdkRobolectricTestRunner(
             TestWithTwoMethods.class,
             SingleSdkRobolectricTestRunner.defaultInjector()
-                .bind(TestEnvironmentSpec.class,
+                .bind(
+                    TestEnvironmentSpec.class,
                     new TestEnvironmentSpec(AndroidTestEnvironmentWithFailingSetUp.class))
                 .build());
     runner.run(notifier);
@@ -162,9 +164,32 @@ public class RobolectricTestRunnerTest {
         .inOrder();
   }
 
+  @Test
+  public void noClassDefError_isReplacedByBetterLinkageError() throws Exception {
+    RobolectricTestRunner runner =
+        new SingleSdkRobolectricTestRunner(
+            TestWithTwoMethods.class,
+            SingleSdkRobolectricTestRunner.defaultInjector()
+                .bind(
+                    TestEnvironmentSpec.class,
+                    new TestEnvironmentSpec(AndroidTestEnvironmentThrowsLinkageError.class))
+                .build());
+    runner.run(notifier);
+    assertThat(events)
+        .containsExactly(
+            "started: first",
+            "failure: java.lang.ExceptionInInitializerError",
+            "finished: first",
+            "started: second",
+            "failure: java.lang.ExceptionInInitializerError",
+            "finished: second")
+        .inOrder();
+  }
+
   @Test
   public void failureInAppOnCreateDoesntBreakAllTests() throws Exception {
-    RobolectricTestRunner runner = new SingleSdkRobolectricTestRunner(TestWithBrokenAppCreate.class);
+    RobolectricTestRunner runner =
+        new SingleSdkRobolectricTestRunner(TestWithBrokenAppCreate.class);
     runner.run(notifier);
     assertThat(events)
         .containsExactly(
@@ -173,13 +198,14 @@ public class RobolectricTestRunnerTest {
             "finished: first",
             "started: second",
             "failure: fake error in application.onCreate",
-            "finished: second"
-        ).inOrder();
+            "finished: second")
+        .inOrder();
   }
 
   @Test
   public void failureInAppOnTerminateDoesntBreakAllTests() throws Exception {
-    RobolectricTestRunner runner = new SingleSdkRobolectricTestRunner(TestWithBrokenAppTerminate.class);
+    RobolectricTestRunner runner =
+        new SingleSdkRobolectricTestRunner(TestWithBrokenAppTerminate.class);
     runner.run(notifier);
     assertThat(events)
         .containsExactly(
@@ -188,8 +214,8 @@ public class RobolectricTestRunnerTest {
             "finished: first",
             "started: second",
             "failure: fake error in application.onTerminate",
-            "finished: second"
-        ).inOrder();
+            "finished: second")
+        .inOrder();
   }
 
   @Test
@@ -201,7 +227,6 @@ public class RobolectricTestRunnerTest {
             mock(AndroidManifest.class),
             sdkCollection.getSdk(16),
             mock(Configuration.class),
-            ResourcesMode.BINARY,
             false);
     RobolectricFrameworkMethod rfm17 =
         new RobolectricFrameworkMethod(
@@ -209,7 +234,6 @@ public class RobolectricTestRunnerTest {
             mock(AndroidManifest.class),
             sdkCollection.getSdk(17),
             mock(Configuration.class),
-            ResourcesMode.BINARY,
             false);
     RobolectricFrameworkMethod rfm16b =
         new RobolectricFrameworkMethod(
@@ -217,7 +241,6 @@ public class RobolectricTestRunnerTest {
             mock(AndroidManifest.class),
             sdkCollection.getSdk(16),
             mock(Configuration.class),
-            ResourcesMode.BINARY,
             false);
 
     assertThat(rfm16).isNotEqualTo(rfm17);
@@ -266,13 +289,13 @@ public class RobolectricTestRunnerTest {
   public void shouldResetThreadInterrupted() throws Exception {
     RobolectricTestRunner runner = new SingleSdkRobolectricTestRunner(TestWithInterrupt.class);
     runner.run(notifier);
-    assertThat(events).containsExactly(
-        "started: first",
-        "finished: first",
-        "started: second",
-        "failure: failed for the right reason",
-        "finished: second"
-    );
+    assertThat(events)
+        .containsExactly(
+            "started: first",
+            "finished: first",
+            "started: second",
+            "failure: failed for the right reason",
+            "finished: second");
   }
 
   @Test
@@ -307,21 +330,52 @@ public class RobolectricTestRunnerTest {
     public AndroidTestEnvironmentWithFailingSetUp(
         @Named("runtimeSdk") Sdk runtimeSdk,
         @Named("compileSdk") Sdk compileSdk,
-        ResourcesMode resourcesMode, ApkLoader apkLoader, ShadowProvider[] shadowProviders,
+        ShadowProvider[] shadowProviders,
         TestEnvironmentLifecyclePlugin[] lifecyclePlugins) {
-      super(runtimeSdk, compileSdk, resourcesMode, apkLoader, shadowProviders, lifecyclePlugins);
+      super(runtimeSdk, compileSdk, shadowProviders, lifecyclePlugins);
     }
 
     @Override
-    public void setUpApplicationState(Method method,
-        Configuration configuration, AndroidManifest appManifest) {
+    public void setUpApplicationState(
+        String tmpDirName, Configuration configuration, AndroidManifest appManifest) {
       // ConfigurationRegistry.instance is required for resetters.
-      Config config = configuration.get(Config.class);
       ConfigurationRegistry.instance = new ConfigurationRegistry(configuration.map());
       throw new RuntimeException("fake error in setUpApplicationState");
     }
   }
 
+  public static class AndroidTestEnvironmentThrowsLinkageError extends AndroidTestEnvironment {
+
+    public static final class UnloadableClass {
+      static {
+        if (true) {
+          throw new RuntimeException("error in static initializer");
+        }
+      }
+
+      public static void doStuff() {}
+
+      private UnloadableClass() {}
+    }
+
+    public AndroidTestEnvironmentThrowsLinkageError(
+        @Named("runtimeSdk") Sdk runtimeSdk,
+        @Named("compileSdk") Sdk compileSdk,
+        ShadowProvider[] shadowProviders,
+        TestEnvironmentLifecyclePlugin[] lifecyclePlugins) {
+      super(runtimeSdk, compileSdk, shadowProviders, lifecyclePlugins);
+    }
+
+    @Override
+    public void setUpApplicationState(
+        String tmpDirName, Configuration configuration, AndroidManifest appManifest) {
+      UnloadableClass.doStuff();
+    }
+
+    @Override
+    public void resetState() {}
+  }
+
   @Ignore
   public static class TestWithOldSdk {
     @Config(sdk = Build.VERSION_CODES.HONEYCOMB)
@@ -343,12 +397,10 @@ public class RobolectricTestRunnerTest {
   @Config(qualifiers = "w123dp-h456dp-land-hdpi")
   public static class TestWithTwoMethods {
     @Test
-    public void first() throws Exception {
-    }
+    public void first() throws Exception {}
 
     @Test
-    public void second() throws Exception {
-    }
+    public void second() throws Exception {}
   }
 
   @Ignore
@@ -419,8 +471,11 @@ public class RobolectricTestRunnerTest {
           out.write("hi!".getBytes(StandardCharsets.UTF_8));
         }
 
-        FileSystemProvider jarFSP = FileSystemProvider.installedProviders().stream()
-            .filter(p -> p.getScheme().equals("jar")).findFirst().get();
+        FileSystemProvider jarFSP =
+            FileSystemProvider.installedProviders().stream()
+                .filter(p -> p.getScheme().equals("jar"))
+                .findFirst()
+                .get();
         Path fakeJarFile = Paths.get(jarPath.toUri());
 
         // if Thread.interrupted() was true, this would fail in AbstractInterruptibleChannel:
@@ -508,6 +563,9 @@ public class RobolectricTestRunnerTest {
     public void testFailure(Failure failure) {
       Throwable exception = failure.getException();
       String message = exception.getMessage();
+      if (message == null) {
+        message = exception.toString();
+      }
       for (Throwable suppressed : exception.getSuppressed()) {
         message += "\nSuppressed: " + suppressed.getMessage();
       }
diff --git a/robolectric/src/test/java/org/robolectric/SingleSdkRobolectricTestRunner.java b/robolectric/src/test/java/org/robolectric/SingleSdkRobolectricTestRunner.java
index 94bf451f4..00b285526 100644
--- a/robolectric/src/test/java/org/robolectric/SingleSdkRobolectricTestRunner.java
+++ b/robolectric/src/test/java/org/robolectric/SingleSdkRobolectricTestRunner.java
@@ -21,8 +21,7 @@ public class SingleSdkRobolectricTestRunner extends RobolectricTestRunner {
   private AndroidSandbox latestSandbox;
 
   public static Injector.Builder defaultInjector() {
-    return RobolectricTestRunner.defaultInjector()
-        .bind(SdkPicker.class, SingleSdkPicker.class);
+    return RobolectricTestRunner.defaultInjector().bind(SdkPicker.class, SingleSdkPicker.class);
   }
 
   public SingleSdkRobolectricTestRunner(Class<?> testClass) throws InitializationError {
diff --git a/robolectric/src/test/java/org/robolectric/TemporaryBindingsTest.java b/robolectric/src/test/java/org/robolectric/TemporaryBindingsTest.java
index de5cf7abb..a8ae53cdd 100644
--- a/robolectric/src/test/java/org/robolectric/TemporaryBindingsTest.java
+++ b/robolectric/src/test/java/org/robolectric/TemporaryBindingsTest.java
@@ -23,7 +23,8 @@ public class TemporaryBindingsTest {
   public void overridingShadowBindingsShouldNotAffectBindingsInLaterTests() throws Exception {
     TemporaryShadowView shadowView =
         Shadow.extract(new View(ApplicationProvider.getApplicationContext()));
-    assertThat(shadowView.getClass().getSimpleName()).isEqualTo(TemporaryShadowView.class.getSimpleName());
+    assertThat(shadowView.getClass().getSimpleName())
+        .isEqualTo(TemporaryShadowView.class.getSimpleName());
   }
 
   @Test
@@ -36,6 +37,5 @@ public class TemporaryBindingsTest {
   }
 
   @Implements(View.class)
-  public static class TemporaryShadowView {
-  }
+  public static class TemporaryShadowView {}
 }
diff --git a/robolectric/src/test/java/org/robolectric/TestFakeApp.java b/robolectric/src/test/java/org/robolectric/TestFakeApp.java
index 318ef9e18..108a801ae 100644
--- a/robolectric/src/test/java/org/robolectric/TestFakeApp.java
+++ b/robolectric/src/test/java/org/robolectric/TestFakeApp.java
@@ -1,4 +1,3 @@
 package org.robolectric;
 
-public class TestFakeApp extends FakeApp {
-}
+public class TestFakeApp extends FakeApp {}
diff --git a/robolectric/src/test/java/org/robolectric/TestRunnerSequenceTest.java b/robolectric/src/test/java/org/robolectric/TestRunnerSequenceTest.java
index fd6087690..10f96618d 100644
--- a/robolectric/src/test/java/org/robolectric/TestRunnerSequenceTest.java
+++ b/robolectric/src/test/java/org/robolectric/TestRunnerSequenceTest.java
@@ -8,7 +8,6 @@ import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.List;
 import javax.annotation.Nonnull;
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.Result;
@@ -19,7 +18,6 @@ import org.junit.runners.JUnit4;
 import org.junit.runners.model.FrameworkMethod;
 import org.junit.runners.model.InitializationError;
 import org.robolectric.annotation.Config;
-import org.robolectric.annotation.internal.DoNotInstrument;
 import org.robolectric.internal.bytecode.InstrumentationConfiguration;
 import org.robolectric.internal.bytecode.Sandbox;
 
@@ -35,58 +33,48 @@ public class TestRunnerSequenceTest {
   @Before
   public void setUp() throws Exception {
     StateHolder.transcript = new ArrayList<>();
-
-    priorResourcesMode = System.getProperty("robolectric.resourcesMode");
-    System.setProperty("robolectric.resourcesMode", "legacy");
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    if (priorResourcesMode == null) {
-      System.clearProperty("robolectric.resourcesMode");
-    } else {
-      System.setProperty("robolectric.resourcesMode", priorResourcesMode);
-    }
   }
 
-  @Test public void shouldRunThingsInTheRightOrder() throws Exception {
+  @Test
+  public void shouldRunThingsInTheRightOrder() throws Exception {
     assertNoFailures(run(new Runner(SimpleTest.class)));
-    assertThat(StateHolder.transcript).containsExactly(
-        "configureSandbox",
-        "application.onCreate",
-        "beforeTest",
-        "application.beforeTest",
-        "prepareTest",
-        "application.prepareTest",
-        "TEST!",
-        "application.onTerminate",
-        "afterTest",
-        "application.afterTest"
-    );
+    assertThat(StateHolder.transcript)
+        .containsExactly(
+            "configureSandbox",
+            "application.onCreate",
+            "beforeTest",
+            "application.beforeTest",
+            "prepareTest",
+            "application.prepareTest",
+            "TEST!",
+            "application.onTerminate",
+            "afterTest",
+            "application.afterTest");
     StateHolder.transcript.clear();
   }
 
-  @Test public void whenNoAppManifest_shouldRunThingsInTheRightOrder() throws Exception {
-    assertNoFailures(run(new Runner(SimpleTest.class) {
-    }));
-    assertThat(StateHolder.transcript).containsExactly(
-        "configureSandbox",
-        "application.onCreate",
-        "beforeTest",
-        "application.beforeTest",
-        "prepareTest",
-        "application.prepareTest",
-        "TEST!",
-        "application.onTerminate",
-        "afterTest",
-        "application.afterTest"
-    );
+  @Test
+  public void whenNoAppManifest_shouldRunThingsInTheRightOrder() throws Exception {
+    assertNoFailures(run(new Runner(SimpleTest.class) {}));
+    assertThat(StateHolder.transcript)
+        .containsExactly(
+            "configureSandbox",
+            "application.onCreate",
+            "beforeTest",
+            "application.beforeTest",
+            "prepareTest",
+            "application.prepareTest",
+            "TEST!",
+            "application.onTerminate",
+            "afterTest",
+            "application.afterTest");
     StateHolder.transcript.clear();
   }
 
   @Config(application = TestRunnerSequenceTest.MyApplication.class)
   public static class SimpleTest {
-    @Test public void shouldDoNothingMuch() throws Exception {
+    @Test
+    public void shouldDoNothingMuch() throws Exception {
       StateHolder.transcript.add("TEST!");
     }
   }
@@ -116,59 +104,69 @@ public class TestRunnerSequenceTest {
     @Nonnull
     @Override
     protected InstrumentationConfiguration createClassLoaderConfig(FrameworkMethod method) {
-      InstrumentationConfiguration.Builder builder = new InstrumentationConfiguration.Builder(super.createClassLoaderConfig(method));
+      InstrumentationConfiguration.Builder builder =
+          new InstrumentationConfiguration.Builder(super.createClassLoaderConfig(method));
       builder.doNotAcquireClass(StateHolder.class);
       return builder.build();
     }
 
     @Nonnull
-    @Override protected Class<? extends TestLifecycle> getTestLifecycleClass() {
+    @Override
+    protected Class<? extends TestLifecycle> getTestLifecycleClass() {
       return MyTestLifecycle.class;
     }
 
-    @Override protected void configureSandbox(Sandbox sandbox, FrameworkMethod frameworkMethod) {
+    @Override
+    protected void configureSandbox(Sandbox sandbox, FrameworkMethod frameworkMethod) {
       StateHolder.transcript.add("configureSandbox");
       super.configureSandbox(sandbox, frameworkMethod);
     }
   }
 
-  @DoNotInstrument
   public static class MyTestLifecycle extends DefaultTestLifecycle {
 
-    @Override public void beforeTest(Method method) {
+    @Override
+    public void beforeTest(Method method) {
       StateHolder.transcript.add("beforeTest");
       super.beforeTest(method);
     }
 
-    @Override public void prepareTest(Object test) {
+    @Override
+    public void prepareTest(Object test) {
       StateHolder.transcript.add("prepareTest");
       super.prepareTest(test);
     }
 
-    @Override public void afterTest(Method method) {
+    @Override
+    public void afterTest(Method method) {
       StateHolder.transcript.add("afterTest");
       super.afterTest(method);
     }
   }
 
   public static class MyApplication extends Application implements TestLifecycleApplication {
-    @Override public void onCreate() {
+    @Override
+    public void onCreate() {
       StateHolder.transcript.add("application.onCreate");
     }
 
-    @Override public void beforeTest(Method method) {
+    @Override
+    public void beforeTest(Method method) {
       StateHolder.transcript.add("application.beforeTest");
     }
 
-    @Override public void prepareTest(Object test) {
+    @Override
+    public void prepareTest(Object test) {
       StateHolder.transcript.add("application.prepareTest");
     }
 
-    @Override public void afterTest(Method method) {
+    @Override
+    public void afterTest(Method method) {
       StateHolder.transcript.add("application.afterTest");
     }
 
-    @Override public void onTerminate() {
+    @Override
+    public void onTerminate() {
       StateHolder.transcript.add("application.onTerminate");
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/android/AndroidTranslatorClassInstrumentedTest.java b/robolectric/src/test/java/org/robolectric/android/AndroidTranslatorClassInstrumentedTest.java
index 0ea650bff..4aa4a44b1 100644
--- a/robolectric/src/test/java/org/robolectric/android/AndroidTranslatorClassInstrumentedTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/AndroidTranslatorClassInstrumentedTest.java
@@ -53,8 +53,7 @@ public class AndroidTranslatorClassInstrumentedTest {
 
   @Instrument
   public static class ClassWithPrivateConstructor {
-    private ClassWithPrivateConstructor() {
-    }
+    private ClassWithPrivateConstructor() {}
 
     public int getInt() {
       return 99;
diff --git a/robolectric/src/test/java/org/robolectric/android/BootstrapTest.java b/robolectric/src/test/java/org/robolectric/android/BootstrapTest.java
index d40f6d177..d3f302cb7 100644
--- a/robolectric/src/test/java/org/robolectric/android/BootstrapTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/BootstrapTest.java
@@ -70,9 +70,7 @@ public class BootstrapTest {
     configuration = new Configuration();
     displayMetrics = new DisplayMetrics();
 
-    optsForO = RuntimeEnvironment.getApiLevel() >= O
-        ? "nowidecg-lowdr-"
-        : "";
+    optsForO = RuntimeEnvironment.getApiLevel() >= O ? "nowidecg-lowdr-" : "";
   }
 
   @Test
@@ -152,13 +150,16 @@ public class BootstrapTest {
     assertThat(configuration.mcc).isEqualTo(0);
     assertThat(configuration.mnc).isEqualTo(0);
     assertThat(configuration.locale).isEqualTo(Locale.US);
-    assertThat(configuration.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK).isEqualTo(SCREENLAYOUT_LAYOUTDIR_LTR);
+    assertThat(configuration.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)
+        .isEqualTo(SCREENLAYOUT_LAYOUTDIR_LTR);
     assertThat(configuration.smallestScreenWidthDp).isEqualTo(320);
     assertThat(configuration.screenWidthDp).isEqualTo(320);
     assertThat(configuration.screenHeightDp).isEqualTo(470);
-    assertThat(configuration.screenLayout & SCREENLAYOUT_SIZE_MASK).isEqualTo(SCREENLAYOUT_SIZE_NORMAL);
+    assertThat(configuration.screenLayout & SCREENLAYOUT_SIZE_MASK)
+        .isEqualTo(SCREENLAYOUT_SIZE_NORMAL);
     assertThat(configuration.screenLayout & SCREENLAYOUT_LONG_MASK).isEqualTo(SCREENLAYOUT_LONG_NO);
-    assertThat(configuration.screenLayout & SCREENLAYOUT_ROUND_MASK).isEqualTo(SCREENLAYOUT_ROUND_NO);
+    assertThat(configuration.screenLayout & SCREENLAYOUT_ROUND_MASK)
+        .isEqualTo(SCREENLAYOUT_ROUND_NO);
     assertThat(configuration.orientation).isEqualTo(ORIENTATION_PORTRAIT);
     assertThat(configuration.uiMode & UI_MODE_TYPE_MASK).isEqualTo(UI_MODE_TYPE_NORMAL);
     assertThat(configuration.uiMode & UI_MODE_NIGHT_MASK).isEqualTo(UI_MODE_NIGHT_NO);
@@ -173,16 +174,13 @@ public class BootstrapTest {
     if (RuntimeEnvironment.getApiLevel() >= O) {
       assertThat(configuration.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK)
           .isEqualTo(COLOR_MODE_WIDE_COLOR_GAMUT_NO);
-      assertThat(configuration.colorMode & COLOR_MODE_HDR_MASK)
-          .isEqualTo(COLOR_MODE_HDR_NO);
+      assertThat(configuration.colorMode & COLOR_MODE_HDR_MASK).isEqualTo(COLOR_MODE_HDR_NO);
     }
   }
 
   @Test
   public void applyQualifiers_shouldHonorSpecifiedQualifiers() {
-    String altOptsForO = RuntimeEnvironment.getApiLevel() >= O
-        ? "-widecg-highdr"
-        : "";
+    String altOptsForO = RuntimeEnvironment.getApiLevel() >= O ? "-widecg-highdr" : "";
 
     Bootstrap.applyQualifiers(
         "mcc310-mnc004-fr-rFR-ldrtl-sw400dp-w480dp-h456dp-"
@@ -212,9 +210,12 @@ public class BootstrapTest {
     assertThat(configuration.smallestScreenWidthDp).isEqualTo(400);
     assertThat(configuration.screenWidthDp).isEqualTo(480);
     assertThat(configuration.screenHeightDp).isEqualTo(456);
-    assertThat(configuration.screenLayout & SCREENLAYOUT_SIZE_MASK).isEqualTo(SCREENLAYOUT_SIZE_XLARGE);
-    assertThat(configuration.screenLayout & SCREENLAYOUT_LONG_MASK).isEqualTo(SCREENLAYOUT_LONG_YES);
-    assertThat(configuration.screenLayout & SCREENLAYOUT_ROUND_MASK).isEqualTo(SCREENLAYOUT_ROUND_YES);
+    assertThat(configuration.screenLayout & SCREENLAYOUT_SIZE_MASK)
+        .isEqualTo(SCREENLAYOUT_SIZE_XLARGE);
+    assertThat(configuration.screenLayout & SCREENLAYOUT_LONG_MASK)
+        .isEqualTo(SCREENLAYOUT_LONG_YES);
+    assertThat(configuration.screenLayout & SCREENLAYOUT_ROUND_MASK)
+        .isEqualTo(SCREENLAYOUT_ROUND_YES);
     assertThat(configuration.orientation).isEqualTo(ORIENTATION_LANDSCAPE);
     assertThat(configuration.uiMode & UI_MODE_TYPE_MASK).isEqualTo(UI_MODE_TYPE_APPLIANCE);
     assertThat(configuration.uiMode & UI_MODE_NIGHT_MASK).isEqualTo(UI_MODE_NIGHT_YES);
@@ -228,8 +229,8 @@ public class BootstrapTest {
 
   @Test
   public void applyQualifiers_longShouldMakeScreenTaller() throws Exception {
-    Bootstrap.applyQualifiers("long",
-        RuntimeEnvironment.getApiLevel(), configuration, displayMetrics);
+    Bootstrap.applyQualifiers(
+        "long", RuntimeEnvironment.getApiLevel(), configuration, displayMetrics);
     assertThat(configuration.smallestScreenWidthDp).isEqualTo(320);
     assertThat(configuration.screenWidthDp).isEqualTo(320);
     assertThat(configuration.screenHeightDp).isEqualTo(587);
@@ -238,9 +239,10 @@ public class BootstrapTest {
   }
 
   @Test
-  public void whenScreenRationGreatherThan175Percent_applyQualifiers_ShouldSetLong() throws Exception {
-    Bootstrap.applyQualifiers("w400dp-h200dp",
-        RuntimeEnvironment.getApiLevel(), configuration, displayMetrics);
+  public void whenScreenRationGreatherThan175Percent_applyQualifiers_ShouldSetLong()
+      throws Exception {
+    Bootstrap.applyQualifiers(
+        "w400dp-h200dp", RuntimeEnvironment.getApiLevel(), configuration, displayMetrics);
     assertThat(configuration.screenWidthDp).isEqualTo(400);
     assertThat(configuration.screenHeightDp).isEqualTo(200);
     assertThat(configuration.screenLayout & Configuration.SCREENLAYOUT_LONG_MASK)
@@ -250,8 +252,11 @@ public class BootstrapTest {
   @Test
   public void applyQualifiers_shouldRejectUnknownQualifiers() {
     try {
-      Bootstrap.applyQualifiers("notareal-qualifier-sw400dp-w480dp-more-wrong-stuff",
-          RuntimeEnvironment.getApiLevel(), configuration, displayMetrics);
+      Bootstrap.applyQualifiers(
+          "notareal-qualifier-sw400dp-w480dp-more-wrong-stuff",
+          RuntimeEnvironment.getApiLevel(),
+          configuration,
+          displayMetrics);
       fail("should have thrown");
     } catch (IllegalArgumentException e) {
       // expected
@@ -262,8 +267,8 @@ public class BootstrapTest {
   @Test
   public void applyQualifiers_shouldRejectSdkVersion() {
     try {
-      Bootstrap.applyQualifiers("sw400dp-w480dp-v7",
-          RuntimeEnvironment.getApiLevel(), configuration, displayMetrics);
+      Bootstrap.applyQualifiers(
+          "sw400dp-w480dp-v7", RuntimeEnvironment.getApiLevel(), configuration, displayMetrics);
       fail("should have thrown");
     } catch (IllegalArgumentException e) {
       // expected
@@ -274,8 +279,8 @@ public class BootstrapTest {
   @Test
   public void applyQualifiers_shouldRejectAnydpi() {
     try {
-      Bootstrap.applyQualifiers("anydpi",
-          RuntimeEnvironment.getApiLevel(), configuration, displayMetrics);
+      Bootstrap.applyQualifiers(
+          "anydpi", RuntimeEnvironment.getApiLevel(), configuration, displayMetrics);
       fail("should have thrown");
     } catch (IllegalArgumentException e) {
       // expected
@@ -286,8 +291,8 @@ public class BootstrapTest {
   @Test
   public void applyQualifiers_shouldRejectNodpi() {
     try {
-      Bootstrap.applyQualifiers("nodpi",
-          RuntimeEnvironment.getApiLevel(), configuration, displayMetrics);
+      Bootstrap.applyQualifiers(
+          "nodpi", RuntimeEnvironment.getApiLevel(), configuration, displayMetrics);
       fail("should have thrown");
     } catch (IllegalArgumentException e) {
       // expected
@@ -297,8 +302,8 @@ public class BootstrapTest {
 
   @Test
   public void applyQualifiers_shouldSetLocaleScript() throws Exception {
-    Bootstrap.applyQualifiers("b+sr+Latn", RuntimeEnvironment.getApiLevel(),
-        configuration, displayMetrics);
+    Bootstrap.applyQualifiers(
+        "b+sr+Latn", RuntimeEnvironment.getApiLevel(), configuration, displayMetrics);
     String outQualifiers = ConfigurationV25.resourceQualifierString(configuration, displayMetrics);
 
     assertThat(configuration.locale.getScript()).isEqualTo("Latn");
@@ -315,8 +320,11 @@ public class BootstrapTest {
 
   @Test
   public void spaceSeparated_applyQualifiers_shouldReplaceQualifiers() throws Exception {
-    Bootstrap.applyQualifiers("ru-rRU-h123dp-large fr-w321dp", RuntimeEnvironment.getApiLevel(),
-        configuration, displayMetrics);
+    Bootstrap.applyQualifiers(
+        "ru-rRU-h123dp-large fr-w321dp",
+        RuntimeEnvironment.getApiLevel(),
+        configuration,
+        displayMetrics);
     String outQualifiers = ConfigurationV25.resourceQualifierString(configuration, displayMetrics);
 
     assertThat(outQualifiers).startsWith("fr-ldltr-sw321dp-w321dp-h470dp-normal");
diff --git a/robolectric/src/test/java/org/robolectric/android/CustomStateView.java b/robolectric/src/test/java/org/robolectric/android/CustomStateView.java
index 7d1831989..9ab0276c7 100644
--- a/robolectric/src/test/java/org/robolectric/android/CustomStateView.java
+++ b/robolectric/src/test/java/org/robolectric/android/CustomStateView.java
@@ -24,7 +24,7 @@ public class CustomStateView extends TextView {
   protected int[] onCreateDrawableState(int extraSpace) {
     final int[] drawableState = super.onCreateDrawableState(extraSpace + 1);
     if (extraAttribute != null) {
-      mergeDrawableStates(drawableState, new int[]{extraAttribute});
+      mergeDrawableStates(drawableState, new int[] {extraAttribute});
     }
     return drawableState;
   }
diff --git a/robolectric/src/test/java/org/robolectric/android/CustomView.java b/robolectric/src/test/java/org/robolectric/android/CustomView.java
index 53d9dc36e..e9bed3a34 100644
--- a/robolectric/src/test/java/org/robolectric/android/CustomView.java
+++ b/robolectric/src/test/java/org/robolectric/android/CustomView.java
@@ -6,7 +6,8 @@ import android.widget.LinearLayout;
 import org.robolectric.R;
 
 public class CustomView extends LinearLayout {
-  public static final String ROBOLECTRIC_RES_URI = "http://schemas.android.com/apk/res/org.robolectric";
+  public static final String ROBOLECTRIC_RES_URI =
+      "http://schemas.android.com/apk/res/org.robolectric";
   public static final String FAKE_URI = "http://example.com/fakens";
 
   public int attributeResourceValue;
diff --git a/robolectric/src/test/java/org/robolectric/android/CustomView2.java b/robolectric/src/test/java/org/robolectric/android/CustomView2.java
index c79472a52..68b874722 100644
--- a/robolectric/src/test/java/org/robolectric/android/CustomView2.java
+++ b/robolectric/src/test/java/org/robolectric/android/CustomView2.java
@@ -11,7 +11,8 @@ public class CustomView2 extends LinearLayout {
     super(context, attrs);
   }
 
-  @Override protected void onFinishInflate() {
+  @Override
+  protected void onFinishInflate() {
     childCountAfterInflate = getChildCount();
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/android/DefaultPackageManagerIntentComparatorTest.java b/robolectric/src/test/java/org/robolectric/android/DefaultPackageManagerIntentComparatorTest.java
index 81bc04c75..16a3880f4 100644
--- a/robolectric/src/test/java/org/robolectric/android/DefaultPackageManagerIntentComparatorTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/DefaultPackageManagerIntentComparatorTest.java
@@ -33,5 +33,4 @@ public class DefaultPackageManagerIntentComparatorTest {
     Intent intent2 = new Intent("actionstring1");
     assertThat(intentComparator.compare(intent1, intent2)).isEqualTo(-1);
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/android/DeviceConfigTest.java b/robolectric/src/test/java/org/robolectric/android/DeviceConfigTest.java
index ac6e9e4f5..b65a630ab 100644
--- a/robolectric/src/test/java/org/robolectric/android/DeviceConfigTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/DeviceConfigTest.java
@@ -30,16 +30,13 @@ public class DeviceConfigTest {
     displayMetrics = new DisplayMetrics();
     apiLevel = RuntimeEnvironment.getApiLevel();
 
-    optsForO = RuntimeEnvironment.getApiLevel() >= O
-        ? "nowidecg-lowdr-"
-        : "";
+    optsForO = RuntimeEnvironment.getApiLevel() >= O ? "nowidecg-lowdr-" : "";
   }
 
   @Test
   public void applyToConfiguration() {
     applyQualifiers("en-rUS-w400dp-h800dp-notround");
-    assertThat(asQualifierString())
-        .isEqualTo("en-rUS-ldltr-w400dp-h800dp-notround");
+    assertThat(asQualifierString()).isEqualTo("en-rUS-ldltr-w400dp-h800dp-notround");
   }
 
   @Test
@@ -217,8 +214,8 @@ public class DeviceConfigTest {
   //////////////////////////
 
   private void applyQualifiers(String qualifiers) {
-    DeviceConfig.applyToConfiguration(Qualifiers.parse(qualifiers),
-        apiLevel, configuration, displayMetrics);
+    DeviceConfig.applyToConfiguration(
+        Qualifiers.parse(qualifiers), apiLevel, configuration, displayMetrics);
   }
 
   private String asQualifierString() {
diff --git a/robolectric/src/test/java/org/robolectric/android/FragmentTestUtilTest.java b/robolectric/src/test/java/org/robolectric/android/FragmentTestUtilTest.java
deleted file mode 100644
index 9512c5f71..000000000
--- a/robolectric/src/test/java/org/robolectric/android/FragmentTestUtilTest.java
+++ /dev/null
@@ -1,99 +0,0 @@
-package org.robolectric.android;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.robolectric.util.FragmentTestUtil.startFragment;
-import static org.robolectric.util.FragmentTestUtil.startVisibleFragment;
-
-import android.app.Activity;
-import android.app.Fragment;
-import android.os.Bundle;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.LinearLayout;
-import android.widget.TextView;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.R;
-
-@RunWith(AndroidJUnit4.class)
-public class FragmentTestUtilTest {
-  @Test
-  public void startFragment_shouldStartFragment() {
-    final LoginFragment fragment = new LoginFragment();
-    startFragment(fragment);
-
-    assertThat(fragment.getView()).isNotNull();
-    assertThat(fragment.getActivity()).isNotNull();
-    assertThat((TextView) fragment.getView().findViewById(R.id.tacos)).isNotNull();
-  }
-
-  @Test
-  public void startVisibleFragment_shouldStartFragment() {
-    final LoginFragment fragment = new LoginFragment();
-    startVisibleFragment(fragment);
-
-    assertThat(fragment.getView()).isNotNull();
-    assertThat(fragment.getActivity()).isNotNull();
-    assertThat((TextView) fragment.getView().findViewById(R.id.tacos)).isNotNull();
-  }
-
-  @Test
-  public void startVisibleFragment_shouldAttachFragmentToActivity() {
-    final LoginFragment fragment = new LoginFragment();
-    startVisibleFragment(fragment);
-
-    assertThat(fragment.getView().getWindowToken()).isNotNull();
-  }
-
-  @Test
-  public void startFragment_shouldStartFragmentWithSpecifiedActivityClass() {
-    final LoginFragment fragment = new LoginFragment();
-    startFragment(fragment, LoginActivity.class);
-
-    assertThat(fragment.getView()).isNotNull();
-    assertThat(fragment.getActivity()).isNotNull();
-    assertThat((TextView) fragment.getView().findViewById(R.id.tacos)).isNotNull();
-    assertThat(fragment.getActivity()).isInstanceOf(LoginActivity.class);
-  }
-
-  @Test
-  public void startVisibleFragment_shouldStartFragmentWithSpecifiedActivityClass() {
-    final LoginFragment fragment = new LoginFragment();
-    startVisibleFragment(fragment, LoginActivity.class, 1);
-
-    assertThat(fragment.getView()).isNotNull();
-    assertThat(fragment.getActivity()).isNotNull();
-    assertThat((TextView) fragment.getView().findViewById(R.id.tacos)).isNotNull();
-    assertThat(fragment.getActivity()).isInstanceOf(LoginActivity.class);
-  }
-
-  @Test
-  public void startVisibleFragment_shouldAttachFragmentToActivityWithSpecifiedActivityClass() {
-    final LoginFragment fragment = new LoginFragment();
-    startVisibleFragment(fragment, LoginActivity.class, 1);
-
-    assertThat(fragment.getView().getWindowToken()).isNotNull();
-    assertThat(fragment.getActivity()).isInstanceOf(LoginActivity.class);
-  }
-
-  public static class LoginFragment extends Fragment {
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-      return inflater.inflate(R.layout.fragment_contents, container, false);
-    }
-  }
-
-  private static class LoginActivity extends Activity {
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-      super.onCreate(savedInstanceState);
-      LinearLayout view = new LinearLayout(this);
-      view.setId(1);
-
-      setContentView(view);
-    }
-  }
-}
-
diff --git a/robolectric/src/test/java/org/robolectric/android/PreferenceIntegrationTest.java b/robolectric/src/test/java/org/robolectric/android/PreferenceIntegrationTest.java
index 413aaa847..14b07ec1d 100644
--- a/robolectric/src/test/java/org/robolectric/android/PreferenceIntegrationTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/PreferenceIntegrationTest.java
@@ -119,13 +119,14 @@ public class PreferenceIntegrationTest {
     final Preference preference = screen.findPreference("preference");
 
     boolean[] holder = new boolean[1];
-    preference.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
-      @Override
-      public boolean onPreferenceClick(Preference preference) {
-        holder[0] = true;
-        return true;
-      }
-    });
+    preference.setOnPreferenceClickListener(
+        new Preference.OnPreferenceClickListener() {
+          @Override
+          public boolean onPreferenceClick(Preference preference) {
+            holder[0] = true;
+            return true;
+          }
+        });
 
     shadowOf(preference).click();
     assertThat(holder[0]).isTrue();
diff --git a/robolectric/src/test/java/org/robolectric/android/XmlResourceParserImplTest.java b/robolectric/src/test/java/org/robolectric/android/XmlResourceParserImplTest.java
index bc7301ad5..db087a50d 100644
--- a/robolectric/src/test/java/org/robolectric/android/XmlResourceParserImplTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/XmlResourceParserImplTest.java
@@ -53,8 +53,7 @@ public class XmlResourceParserImplTest {
   private void parseUntilNext(int event) throws Exception {
     while (parser.next() != event) {
       if (parser.getEventType() == XmlResourceParser.END_DOCUMENT) {
-        throw new RuntimeException("Impossible to find: " +
-            event + ". End of document reached.");
+        throw new RuntimeException("Impossible to find: " + event + ". End of document reached.");
       }
     }
   }
@@ -66,8 +65,7 @@ public class XmlResourceParserImplTest {
       factory.setIgnoringComments(true);
       factory.setIgnoringElementContentWhitespace(true);
       DocumentBuilder documentBuilder = factory.newDocumentBuilder();
-      Document document = documentBuilder.parse(
-          new ByteArrayInputStream(xmlValue.getBytes(UTF_8)));
+      Document document = documentBuilder.parse(new ByteArrayInputStream(xmlValue.getBytes(UTF_8)));
 
       parser =
           new XmlResourceParserImpl(
@@ -77,9 +75,7 @@ public class XmlResourceParserImplTest {
     } catch (Exception parsingException) {
       // Wrap XML parsing exception with a runtime
       // exception for convenience.
-      throw new RuntimeException(
-          "Cannot forge a Document from an invalid XML",
-          parsingException);
+      throw new RuntimeException("Cannot forge a Document from an invalid XML", parsingException);
     }
   }
 
@@ -245,12 +241,12 @@ public class XmlResourceParserImplTest {
     int evt;
     while ((evt = parser.next()) != XmlResourceParser.END_DOCUMENT) {
       switch (evt) {
-        case (XmlResourceParser.START_TAG): {
-          actualDepths.add(parser.getDepth());
-          break;
-        }
+        case (XmlResourceParser.START_TAG):
+          {
+            actualDepths.add(parser.getDepth());
+            break;
+          }
       }
-
     }
     assertThat(actualDepths).isEqualTo(expectedDepths);
   }
@@ -305,16 +301,16 @@ public class XmlResourceParserImplTest {
 
   @Test
   public void testGetAttribute() {
-    forgeAndOpenDocument("<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\""
-                             + " app:bar=\"bar\"/>");
+    forgeAndOpenDocument(
+        "<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\"" + " app:bar=\"bar\"/>");
     XmlResourceParserImpl parserImpl = (XmlResourceParserImpl) parser;
     assertThat(parserImpl.getAttribute(RES_AUTO_NS, "bar")).isEqualTo("bar");
   }
 
   @Test
   public void testGetAttributeNamespace() {
-    forgeAndOpenDocument("<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\""
-                             + " app:bar=\"bar\"/>");
+    forgeAndOpenDocument(
+        "<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\"" + " app:bar=\"bar\"/>");
     assertThat(parser.getAttributeNamespace(0)).isEqualTo(RES_AUTO_NS);
   }
 
@@ -426,49 +422,29 @@ public class XmlResourceParserImplTest {
 
   @Test
   public void testGetAttributeValueStringString() {
-    forgeAndOpenDocument("<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\""
-                             + " app:bar=\"bar\"/>");
+    forgeAndOpenDocument(
+        "<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\"" + " app:bar=\"bar\"/>");
     assertThat(parser.getAttributeValue(RES_AUTO_NS, "bar")).isEqualTo("bar");
   }
 
   @Test
   public void testNext() throws Exception {
     // Recorded events while parsing preferences from Android
-    List<String> expectedEvents = Arrays.asList(
-        "<xml>",
-        "<", // PreferenceScreen
-        "<", // PreferenceCategory
-        "<", // Preference
-        ">",
-        ">",
-
-        "<", // PreferenceScreen
-        "<", // Preference
-        ">",
-        "<", // Preference
-        ">",
-        ">",
-
-        "<", // CheckBoxPreference
-        ">",
-        "<", // EditTextPreference
-        ">",
-        "<", // ListPreference
-        ">",
-        "<", // Preference
-        ">",
-        "<", //RingtonePreference
-        ">",
-        "<", // Preference
-        ">",
-        "<",
-        ">",
-        "<",
-        "<",
-        ">",
-        ">",
-        ">",
-        "</xml>");
+    List<String> expectedEvents =
+        Arrays.asList(
+            "<xml>", "<", // PreferenceScreen
+            "<", // PreferenceCategory
+            "<", // Preference
+            ">", ">", "<", // PreferenceScreen
+            "<", // Preference
+            ">", "<", // Preference
+            ">", ">", "<", // CheckBoxPreference
+            ">", "<", // EditTextPreference
+            ">", "<", // ListPreference
+            ">", "<", // Preference
+            ">", "<", // RingtonePreference
+            ">", "<", // Preference
+            ">", "<", ">", "<", "<", ">", ">", ">", "</xml>");
     List<String> actualEvents = new ArrayList<>();
 
     int evt;
@@ -495,28 +471,24 @@ public class XmlResourceParserImplTest {
   @Test
   public void testRequire() throws Exception {
     parseUntilNext(XmlResourceParser.START_TAG);
-    parser.require(XmlResourceParser.START_TAG,
-        parser.getNamespace(), parser.getName());
+    parser.require(XmlResourceParser.START_TAG, parser.getNamespace(), parser.getName());
 
     try {
-      parser.require(XmlResourceParser.END_TAG,
-          parser.getNamespace(), parser.getName());
+      parser.require(XmlResourceParser.END_TAG, parser.getNamespace(), parser.getName());
       fail("Require with wrong event should have failed");
     } catch (XmlPullParserException ex) {
       // pass
     }
 
     try {
-      parser.require(XmlResourceParser.START_TAG,
-          "foo", parser.getName());
+      parser.require(XmlResourceParser.START_TAG, "foo", parser.getName());
       fail("Require with wrong namespace should have failed");
     } catch (XmlPullParserException ex) {
       // pass
     }
 
     try {
-      parser.require(XmlResourceParser.START_TAG,
-          parser.getNamespace(), "foo");
+      parser.require(XmlResourceParser.START_TAG, parser.getNamespace(), "foo");
       fail("Require with wrong tag name should have failed");
     } catch (XmlPullParserException ex) {
       // pass
@@ -530,13 +502,12 @@ public class XmlResourceParserImplTest {
       assertThat(parser.nextText()).isEqualTo(parser.getText());
       fail("nextText on a document with no text should have failed");
     } catch (XmlPullParserException ex) {
-      assertThat(parser.getEventType()).isAnyOf(XmlResourceParser.START_TAG, XmlResourceParser.END_DOCUMENT);
+      assertThat(parser.getEventType())
+          .isAnyOf(XmlResourceParser.START_TAG, XmlResourceParser.END_DOCUMENT);
     }
   }
 
-  /**
-   * Test that next tag will only return tag events.
-   */
+  /** Test that next tag will only return tag events. */
   @Test
   public void testNextTag() throws Exception {
     Set<Integer> acceptableTags = new HashSet<>();
@@ -548,26 +519,25 @@ public class XmlResourceParserImplTest {
     do {
       evt = parser.next();
       assertTrue(acceptableTags.contains(evt));
-    } while (evt == XmlResourceParser.END_TAG &&
-        "foo".equals(parser.getName()));
+    } while (evt == XmlResourceParser.END_TAG && "foo".equals(parser.getName()));
   }
 
   @Test
   public void testGetAttributeListValue_StringStringStringArrayInt() {
     String[] options = {"foo", "bar"};
-    forgeAndOpenDocument("<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\""
-                             + " app:bar=\"bar\"/>");
+    forgeAndOpenDocument(
+        "<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\"" + " app:bar=\"bar\"/>");
     assertThat(parser.getAttributeListValue(RES_AUTO_NS, "bar", options, 0)).isEqualTo(1);
 
-    forgeAndOpenDocument("<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\""
-                             + " app:bar=\"unexpected\"/>");
+    forgeAndOpenDocument(
+        "<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\"" + " app:bar=\"unexpected\"/>");
     assertThat(parser.getAttributeListValue(RES_AUTO_NS, "bar", options, 0)).isEqualTo(0);
   }
 
   @Test
   public void testGetAttributeBooleanValue_StringStringBoolean() {
-    forgeAndOpenDocument("<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\""
-                             + " app:bar=\"true\"/>");
+    forgeAndOpenDocument(
+        "<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\"" + " app:bar=\"true\"/>");
     assertThat(parser.getAttributeBooleanValue(RES_AUTO_NS, "bar", false)).isTrue();
     assertThat(parser.getAttributeBooleanValue(RES_AUTO_NS, "foo", false)).isFalse();
   }
@@ -598,16 +568,17 @@ public class XmlResourceParserImplTest {
 
   @Test
   public void testGetAttributeResourceValueWhenNotAResource() {
-    forgeAndOpenDocument("<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\""
-                             + " app:bar=\"banana\"/>");
+    forgeAndOpenDocument(
+        "<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\"" + " app:bar=\"banana\"/>");
     assertThat(parser.getAttributeResourceValue(RES_AUTO_NS, "bar", 42)).isEqualTo(42);
   }
 
   @Test
   public void testGetAttributeIntValue_StringStringInt() {
-    forgeAndOpenDocument("<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\""
-                             + " app:app=\"http://schemas.android.com/apk/res-auto\""
-                             + " app:bar=\"-12\"/>");
+    forgeAndOpenDocument(
+        "<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\""
+            + " app:app=\"http://schemas.android.com/apk/res-auto\""
+            + " app:bar=\"-12\"/>");
 
     assertThat(parser.getAttributeIntValue(RES_AUTO_NS, "bar", 0)).isEqualTo(-12);
     assertThat(parser.getAttributeIntValue(RES_AUTO_NS, "foo", 0)).isEqualTo(0);
@@ -627,16 +598,16 @@ public class XmlResourceParserImplTest {
 
   @Test
   public void testGetAttributeUnsignedIntValue_StringStringInt() {
-    forgeAndOpenDocument("<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\""
-                             + " app:bar=\"12\"/>");
+    forgeAndOpenDocument(
+        "<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\"" + " app:bar=\"12\"/>");
 
     assertThat(parser.getAttributeUnsignedIntValue(RES_AUTO_NS, "bar", 0)).isEqualTo(12);
 
     assertThat(parser.getAttributeUnsignedIntValue(RES_AUTO_NS, "foo", 0)).isEqualTo(0);
 
     // Negative unsigned int must be
-    forgeAndOpenDocument("<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\""
-                             + " app:bar=\"-12\"/>");
+    forgeAndOpenDocument(
+        "<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\"" + " app:bar=\"-12\"/>");
 
     assertWithMessage("Getting a negative number as unsigned should return the default value.")
         .that(parser.getAttributeUnsignedIntValue(RES_AUTO_NS, "bar", 0))
@@ -661,8 +632,8 @@ public class XmlResourceParserImplTest {
 
   @Test
   public void testGetAttributeFloatValue_StringStringFloat() {
-    forgeAndOpenDocument("<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\""
-                             + " app:bar=\"12.01\"/>");
+    forgeAndOpenDocument(
+        "<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\"" + " app:bar=\"12.01\"/>");
 
     assertThat(parser.getAttributeFloatValue(RES_AUTO_NS, "bar", 0.0f)).isEqualTo(12.01f);
 
@@ -678,8 +649,7 @@ public class XmlResourceParserImplTest {
 
     assertThat(parser.getAttributeFloatValue(0, 0.0f)).isEqualTo(12.01f);
 
-    assertThat(parser.getAttributeFloatValue(
-        attributeIndexOutOfIndex(), 0.0f)).isEqualTo(0.0f);
+    assertThat(parser.getAttributeFloatValue(attributeIndexOutOfIndex(), 0.0f)).isEqualTo(0.0f);
 
     forgeAndOpenDocument("<foo bar=\"unexpected\"/>");
     assertThat(parser.getAttributeFloatValue(0, 0.0f)).isEqualTo(0.0f);
@@ -688,17 +658,15 @@ public class XmlResourceParserImplTest {
   @Test
   public void testGetAttributeListValue_IntStringArrayInt() {
     String[] options = {"foo", "bar"};
-    forgeAndOpenDocument("<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\""
-                             + " app:bar=\"bar\"/>");
+    forgeAndOpenDocument(
+        "<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\"" + " app:bar=\"bar\"/>");
     assertThat(parser.getAttributeListValue(0, options, 0)).isEqualTo(1);
 
-    forgeAndOpenDocument("<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\""
-                             + " app:bar=\"unexpected\"/>");
-    assertThat(parser.getAttributeListValue(
-        0, options, 0)).isEqualTo(0);
+    forgeAndOpenDocument(
+        "<foo xmlns:app=\"http://schemas.android.com/apk/res-auto\"" + " app:bar=\"unexpected\"/>");
+    assertThat(parser.getAttributeListValue(0, options, 0)).isEqualTo(0);
 
-    assertThat(parser.getAttributeListValue(
-        attributeIndexOutOfIndex(), options, 0)).isEqualTo(0);
+    assertThat(parser.getAttributeListValue(attributeIndexOutOfIndex(), options, 0)).isEqualTo(0);
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/android/controller/BackupAgentControllerTest.java b/robolectric/src/test/java/org/robolectric/android/controller/BackupAgentControllerTest.java
index 6b90ea93b..e293d6ac4 100644
--- a/robolectric/src/test/java/org/robolectric/android/controller/BackupAgentControllerTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/controller/BackupAgentControllerTest.java
@@ -16,7 +16,8 @@ import org.robolectric.Robolectric;
 
 @RunWith(AndroidJUnit4.class)
 public class BackupAgentControllerTest {
-  private final BackupAgentController<MyBackupAgent> backupAgentController = Robolectric.buildBackupAgent(MyBackupAgent.class);
+  private final BackupAgentController<MyBackupAgent> backupAgentController =
+      Robolectric.buildBackupAgent(MyBackupAgent.class);
 
   @Test
   public void shouldSetBaseContext() throws Exception {
@@ -27,12 +28,18 @@ public class BackupAgentControllerTest {
 
   public static class MyBackupAgent extends BackupAgent {
     @Override
-    public void onBackup(ParcelFileDescriptor parcelFileDescriptor, BackupDataOutput backupDataOutput, ParcelFileDescriptor parcelFileDescriptor1) throws IOException {
+    public void onBackup(
+        ParcelFileDescriptor parcelFileDescriptor,
+        BackupDataOutput backupDataOutput,
+        ParcelFileDescriptor parcelFileDescriptor1)
+        throws IOException {
       // no op
     }
 
     @Override
-    public void onRestore(BackupDataInput backupDataInput, int i, ParcelFileDescriptor parcelFileDescriptor) throws IOException {
+    public void onRestore(
+        BackupDataInput backupDataInput, int i, ParcelFileDescriptor parcelFileDescriptor)
+        throws IOException {
       // no op
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/android/controller/ContentProviderControllerTest.java b/robolectric/src/test/java/org/robolectric/android/controller/ContentProviderControllerTest.java
index 9cdff632c..3981356b9 100644
--- a/robolectric/src/test/java/org/robolectric/android/controller/ContentProviderControllerTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/controller/ContentProviderControllerTest.java
@@ -78,7 +78,8 @@ public class ContentProviderControllerTest {
 
   @Test
   public void whenNoProviderManifestEntryFound_shouldStillInitialize() throws Exception {
-    TestContentProvider1 myContentProvider = Robolectric.buildContentProvider(NotInManifestContentProvider.class).create().get();
+    TestContentProvider1 myContentProvider =
+        Robolectric.buildContentProvider(NotInManifestContentProvider.class).create().get();
     assertThat(myContentProvider.getReadPermission()).isNull();
     assertThat(myContentProvider.getWritePermission()).isNull();
     assertThat(myContentProvider.getPathPermissions()).isNull();
diff --git a/robolectric/src/test/java/org/robolectric/android/controller/FragmentControllerTest.java b/robolectric/src/test/java/org/robolectric/android/controller/FragmentControllerTest.java
index e190b2519..b7114c8a0 100644
--- a/robolectric/src/test/java/org/robolectric/android/controller/FragmentControllerTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/controller/FragmentControllerTest.java
@@ -58,7 +58,8 @@ public class FragmentControllerTest {
   @Test
   public void attachedAfterCreate_customizedViewId() {
     final LoginFragment fragment = new LoginFragment();
-    FragmentController.of(fragment, CustomizedViewIdLoginActivity.class).create(VIEW_ID_CUSTOMIZED_LOGIN_ACTIVITY, null);
+    FragmentController.of(fragment, CustomizedViewIdLoginActivity.class)
+        .create(VIEW_ID_CUSTOMIZED_LOGIN_ACTIVITY, null);
     shadowMainLooper().idle();
 
     assertThat(fragment.getView()).isNotNull();
@@ -129,7 +130,8 @@ public class FragmentControllerTest {
 
     Intent intent = new Intent("test_action");
     intent.putExtra("test_key", "test_value");
-    FragmentController<LoginFragment> controller = FragmentController.of(fragment, LoginActivity.class, intent).create();
+    FragmentController<LoginFragment> controller =
+        FragmentController.of(fragment, LoginActivity.class, intent).create();
     shadowMainLooper().idle();
 
     Intent intentInFragment = controller.get().getActivity().getIntent();
@@ -143,7 +145,8 @@ public class FragmentControllerTest {
 
     Bundle arguments = new Bundle();
     arguments.putString("test_argument", "test_value");
-    FragmentController<LoginFragment> controller = FragmentController.of(fragment, LoginActivity.class, arguments).create();
+    FragmentController<LoginFragment> controller =
+        FragmentController.of(fragment, LoginActivity.class, arguments).create();
 
     Bundle argumentsInFragment = controller.get().getArguments();
     assertThat(argumentsInFragment.getString("test_argument")).isEqualTo("test_value");
@@ -152,7 +155,8 @@ public class FragmentControllerTest {
   @Test
   public void visible() {
     final LoginFragment fragment = new LoginFragment();
-    final FragmentController<LoginFragment> controller = FragmentController.of(fragment, LoginActivity.class);
+    final FragmentController<LoginFragment> controller =
+        FragmentController.of(fragment, LoginActivity.class);
 
     controller.create();
     shadowMainLooper().idle();
@@ -172,7 +176,8 @@ public class FragmentControllerTest {
     boolean stopCalled = false;
 
     @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+    public View onCreateView(
+        LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
       return inflater.inflate(R.layout.fragment_contents, container, false);
     }
 
diff --git a/robolectric/src/test/java/org/robolectric/android/internal/AndroidTestEnvironmentTest.java b/robolectric/src/test/java/org/robolectric/android/internal/AndroidTestEnvironmentTest.java
index c2ef9f355..90517a740 100644
--- a/robolectric/src/test/java/org/robolectric/android/internal/AndroidTestEnvironmentTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/internal/AndroidTestEnvironmentTest.java
@@ -2,8 +2,7 @@ package org.robolectric.android.internal;
 
 import static android.os.Build.VERSION_CODES.O;
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.TruthJUnit.assume;
-import static org.junit.Assert.fail;
+import static org.junit.Assert.assertThrows;
 import static org.robolectric.annotation.ConscryptMode.Mode.OFF;
 import static org.robolectric.annotation.ConscryptMode.Mode.ON;
 import static org.robolectric.annotation.LooperMode.Mode.LEGACY;
@@ -23,8 +22,10 @@ import java.security.NoSuchAlgorithmException;
 import java.security.cert.CertificateException;
 import java.security.cert.CertificateFactory;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 import java.util.Locale;
+import java.util.Map.Entry;
 import java.util.concurrent.atomic.AtomicBoolean;
 import javax.crypto.Cipher;
 import org.bouncycastle.jce.provider.BouncyCastleProvider;
@@ -42,9 +43,12 @@ import org.robolectric.annotation.ConscryptMode;
 import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.experimental.LazyApplication;
 import org.robolectric.annotation.experimental.LazyApplication.LazyLoad;
+import org.robolectric.internal.ShadowProvider;
 import org.robolectric.manifest.AndroidManifest;
 import org.robolectric.manifest.RoboNotFoundException;
+import org.robolectric.pluginapi.TestEnvironmentLifecyclePlugin;
 import org.robolectric.plugins.HierarchicalConfigurationStrategy.ConfigurationImpl;
+import org.robolectric.plugins.StubSdk;
 import org.robolectric.res.ResourceTable;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowApplication;
@@ -67,7 +71,8 @@ public class AndroidTestEnvironmentTest {
   }
 
   @Test
-  public void setUpApplicationState_setsBackgroundScheduler_toBeSameAsForeground_whenAdvancedScheduling() {
+  public void
+      setUpApplicationState_setsBackgroundScheduler_toBeSameAsForeground_whenAdvancedScheduling() {
     RoboSettings.setUseGlobalScheduler(true);
     try {
       bootstrapWrapper.callSetUpApplicationState();
@@ -103,10 +108,11 @@ public class AndroidTestEnvironmentTest {
   public void setUpApplicationState_setsMainThread_onAnotherThread() throws InterruptedException {
     final AtomicBoolean res = new AtomicBoolean();
     Thread t =
-        new Thread(() -> {
-          bootstrapWrapper.callSetUpApplicationState();
-          res.set(RuntimeEnvironment.isMainThread());
-        });
+        new Thread(
+            () -> {
+              bootstrapWrapper.callSetUpApplicationState();
+              res.set(RuntimeEnvironment.isMainThread());
+            });
     t.start();
     t.join();
     assertThat(res.get()).isTrue();
@@ -171,9 +177,7 @@ public class AndroidTestEnvironmentTest {
 
     bootstrapWrapper.callSetUpApplicationState();
 
-    String optsForO = RuntimeEnvironment.getApiLevel() >= O
-        ? "nowidecg-lowdr-"
-        : "";
+    String optsForO = RuntimeEnvironment.getApiLevel() >= O ? "nowidecg-lowdr-" : "";
     assertThat(RuntimeEnvironment.getQualifiers())
         .contains(
             "large-notlong-notround-"
@@ -185,8 +189,8 @@ public class AndroidTestEnvironmentTest {
   @Test
   public void setUpApplicationState_shouldCreateStorageDirs() {
     bootstrapWrapper.callSetUpApplicationState();
-    ApplicationInfo applicationInfo = ApplicationProvider.getApplicationContext()
-        .getApplicationInfo();
+    ApplicationInfo applicationInfo =
+        ApplicationProvider.getApplicationContext().getApplicationInfo();
 
     assertThat(applicationInfo.sourceDir).isNotNull();
     assertThat(new File(applicationInfo.sourceDir).exists()).isTrue();
@@ -202,8 +206,8 @@ public class AndroidTestEnvironmentTest {
   @Config(minSdk = Build.VERSION_CODES.N)
   public void setUpApplicationState_shouldCreateStorageDirs_Nplus() {
     bootstrapWrapper.callSetUpApplicationState();
-    ApplicationInfo applicationInfo = ApplicationProvider.getApplicationContext()
-        .getApplicationInfo();
+    ApplicationInfo applicationInfo =
+        ApplicationProvider.getApplicationContext().getApplicationInfo();
 
     assertThat(applicationInfo.credentialProtectedDataDir).isNotNull();
     assertThat(new File(applicationInfo.credentialProtectedDataDir).isDirectory()).isTrue();
@@ -227,20 +231,6 @@ public class AndroidTestEnvironmentTest {
     assertThat(events).containsExactly("terminated");
   }
 
-  @Test
-  public void testResourceNotFound() {
-    // not relevant for binary resources mode
-    assume().that(bootstrapWrapper.isLegacyResources()).isTrue();
-
-    try {
-      bootstrapWrapper.changeAppManifest(new ThrowingManifest(bootstrapWrapper.getAppManifest()));
-      bootstrapWrapper.callSetUpApplicationState();
-      fail("Expected to throw");
-    } catch (Resources.NotFoundException expected) {
-      // expected
-    }
-  }
-
   /** Can't use Mockito for classloader issues */
   static class ThrowingManifest extends AndroidManifest {
     public ThrowingManifest(AndroidManifest androidManifest) {
@@ -355,4 +345,64 @@ public class AndroidTestEnvironmentTest {
     assertThat(applicationInfo.dataDir).isNotNull();
     assertThat(new File(applicationInfo.dataDir).isDirectory()).isTrue();
   }
+
+  @Test
+  public void testResetterFails_reportsFailureAndContinues() {
+    // bootstrapWrapper is not used in this test, but calling `callSetUpApplicationState` is
+    // required to avoid exceptions in the test teardown.
+    bootstrapWrapper.callSetUpApplicationState();
+
+    WorkingShadowProvider workingShadowProvider = new WorkingShadowProvider();
+    ShadowProvider[] shadowProviders = new ShadowProvider[2];
+    shadowProviders[0] = new ThrowingShadowProvider();
+    shadowProviders[1] = workingShadowProvider;
+
+    TestEnvironmentLifecyclePlugin[] telpArray = new TestEnvironmentLifecyclePlugin[0];
+    AndroidTestEnvironment androidTestEnvironment =
+        new AndroidTestEnvironment(
+            new StubSdk(RuntimeEnvironment.getApiLevel(), true),
+            new StubSdk(RuntimeEnvironment.getApiLevel(), true),
+            shadowProviders,
+            telpArray);
+    RuntimeException e =
+        assertThrows(RuntimeException.class, () -> androidTestEnvironment.resetState());
+    assertThat(e).hasMessageThat().contains("Reset failed");
+    assertThat(workingShadowProvider.wasReset).isTrue();
+  }
+
+  private static class ThrowingShadowProvider implements ShadowProvider {
+    @Override
+    public void reset() {
+      throw new RuntimeException("Reset failed");
+    }
+
+    @Override
+    public String[] getProvidedPackageNames() {
+      return null;
+    }
+
+    @Override
+    public Collection<Entry<String, String>> getShadows() {
+      return new ArrayList<>();
+    }
+  }
+
+  private static class WorkingShadowProvider implements ShadowProvider {
+    public boolean wasReset = false;
+
+    @Override
+    public void reset() {
+      wasReset = true;
+    }
+
+    @Override
+    public String[] getProvidedPackageNames() {
+      return null;
+    }
+
+    @Override
+    public Collection<Entry<String, String>> getShadows() {
+      return new ArrayList<>();
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/android/util/concurrent/InlineExecutorServiceTest.java b/robolectric/src/test/java/org/robolectric/android/util/concurrent/InlineExecutorServiceTest.java
index b1063c69a..6c8724ab3 100644
--- a/robolectric/src/test/java/org/robolectric/android/util/concurrent/InlineExecutorServiceTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/util/concurrent/InlineExecutorServiceTest.java
@@ -13,9 +13,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Unit tests for {@link InlineExecutorService}
- */
+/** Unit tests for {@link InlineExecutorService} */
 @RunWith(JUnit4.class)
 public class InlineExecutorServiceTest {
   private List<String> executedTasksRecord;
@@ -54,10 +52,12 @@ public class InlineExecutorServiceTest {
   @Test
   public void submitCallable() throws Exception {
     Runnable runnable = () -> executedTasksRecord.add("background event ran");
-    Future<String> future = executorService.submit(() -> {
-      runnable.run();
-      return "foo";
-    });
+    Future<String> future =
+        executorService.submit(
+            () -> {
+              runnable.run();
+              return "foo";
+            });
 
     assertThat(executedTasksRecord).containsExactly("background event ran");
     assertThat(future.isDone()).isTrue();
@@ -83,13 +83,14 @@ public class InlineExecutorServiceTest {
 
   @Test
   public void exceptionsPropagated() {
-    Callable<Void> throwingCallable = new Callable<Void>() {
+    Callable<Void> throwingCallable =
+        new Callable<Void>() {
 
-      @Override
-      public Void call() throws Exception {
-        throw new IllegalStateException("I failed");
-      }
-    };
+          @Override
+          public Void call() throws Exception {
+            throw new IllegalStateException("I failed");
+          }
+        };
     try {
       executorService.submit(throwingCallable);
       fail("did not propagate exception");
@@ -100,14 +101,15 @@ public class InlineExecutorServiceTest {
 
   @Test
   public void postingTasks() throws Exception {
-    Runnable postingRunnable = new Runnable() {
-      @Override
-      public void run() {
-        executedTasksRecord.add("first");
-        executorService.execute(() -> executedTasksRecord.add("third"));
-        executedTasksRecord.add("second");
-      }
-    };
+    Runnable postingRunnable =
+        new Runnable() {
+          @Override
+          public void run() {
+            executedTasksRecord.add("first");
+            executorService.execute(() -> executedTasksRecord.add("third"));
+            executedTasksRecord.add("second");
+          }
+        };
     executorService.execute(postingRunnable);
 
     assertThat(executedTasksRecord).containsExactly("first", "second", "third").inOrder();
diff --git a/robolectric/src/test/java/org/robolectric/android/util/concurrent/PausedExecutorServiceTest.java b/robolectric/src/test/java/org/robolectric/android/util/concurrent/PausedExecutorServiceTest.java
index 677fa0444..34ea673ff 100644
--- a/robolectric/src/test/java/org/robolectric/android/util/concurrent/PausedExecutorServiceTest.java
+++ b/robolectric/src/test/java/org/robolectric/android/util/concurrent/PausedExecutorServiceTest.java
@@ -14,9 +14,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Unit tests for {@link PausedExecutorService}
- */
+/** Unit tests for {@link PausedExecutorService} */
 @RunWith(JUnit4.class)
 public class PausedExecutorServiceTest {
   private List<String> executedTasksRecord;
@@ -102,10 +100,12 @@ public class PausedExecutorServiceTest {
   @Test
   public void submitCallable() throws Exception {
     Runnable runnable = () -> executedTasksRecord.add("background event ran");
-    Future<String> future = executorService.submit(() -> {
-      runnable.run();
-      return "foo";
-    });
+    Future<String> future =
+        executorService.submit(
+            () -> {
+              runnable.run();
+              return "foo";
+            });
     executorService.runAll();
 
     assertThat(executedTasksRecord).containsExactly("background event ran");
@@ -164,9 +164,10 @@ public class PausedExecutorServiceTest {
   @Test
   @SuppressWarnings("FutureReturnValueIgnored")
   public void exceptionsPropagated() throws ExecutionException, InterruptedException {
-    Callable<Void> throwingCallable = () -> {
-      throw new IllegalStateException("I failed");
-    };
+    Callable<Void> throwingCallable =
+        () -> {
+          throw new IllegalStateException("I failed");
+        };
     try {
       executorService.submit(throwingCallable);
       executorService.runAll();
@@ -178,14 +179,15 @@ public class PausedExecutorServiceTest {
 
   @Test
   public void postingTasks() throws Exception {
-    Runnable postingRunnable = new Runnable() {
-      @Override
-      public void run() {
-        executedTasksRecord.add("first");
-        executorService.execute(() -> executedTasksRecord.add("third"));
-        executedTasksRecord.add("second");
-      }
-    };
+    Runnable postingRunnable =
+        new Runnable() {
+          @Override
+          public void run() {
+            executedTasksRecord.add("first");
+            executorService.execute(() -> executedTasksRecord.add("third"));
+            executedTasksRecord.add("second");
+          }
+        };
     executorService.execute(postingRunnable);
     executorService.runAll();
 
diff --git a/robolectric/src/test/java/org/robolectric/fakes/ConfigTestReceiver.java b/robolectric/src/test/java/org/robolectric/fakes/ConfigTestReceiver.java
index da67625bc..54ee4e84c 100644
--- a/robolectric/src/test/java/org/robolectric/fakes/ConfigTestReceiver.java
+++ b/robolectric/src/test/java/org/robolectric/fakes/ConfigTestReceiver.java
@@ -7,6 +7,5 @@ import android.content.Intent;
 public class ConfigTestReceiver extends BroadcastReceiver {
 
   @Override
-  public void onReceive(Context context, Intent intent) {
-  }
+  public void onReceive(Context context, Intent intent) {}
 }
diff --git a/robolectric/src/test/java/org/robolectric/fakes/RoboCursorTest.java b/robolectric/src/test/java/org/robolectric/fakes/RoboCursorTest.java
index 1609257c7..ffb208e5c 100644
--- a/robolectric/src/test/java/org/robolectric/fakes/RoboCursorTest.java
+++ b/robolectric/src/test/java/org/robolectric/fakes/RoboCursorTest.java
@@ -35,16 +35,16 @@ public class RoboCursorTest {
     contentResolver = ApplicationProvider.getApplicationContext().getContentResolver();
     shadowOf(contentResolver).setCursor(uri, cursor);
 
-    cursor.setColumnNames(asList(
-        STRING_COLUMN,
-        LONG_COLUMN,
-        INT_COLUMN,
-        BLOB_COLUMN,
-        SHORT_COLUMN,
-        FLOAT_COLUMN,
-        DOUBLE_COLUMN,
-        NULL_COLUMN
-    ));
+    cursor.setColumnNames(
+        asList(
+            STRING_COLUMN,
+            LONG_COLUMN,
+            INT_COLUMN,
+            BLOB_COLUMN,
+            SHORT_COLUMN,
+            FLOAT_COLUMN,
+            DOUBLE_COLUMN,
+            NULL_COLUMN));
   }
 
   @Test
@@ -59,12 +59,14 @@ public class RoboCursorTest {
   }
 
   @Test
-  public void getColumnCount_whenSetColumnNamesHasntBeenCalled_shouldReturnCountFromData() throws Exception {
+  public void getColumnCount_whenSetColumnNamesHasntBeenCalled_shouldReturnCountFromData()
+      throws Exception {
     RoboCursor cursor = new RoboCursor();
-    cursor.setResults(new Object[][]{
-        new Object[] {1, 2, 3},
-        new Object[] {1, 2},
-    });
+    cursor.setResults(
+        new Object[][] {
+          new Object[] {1, 2, 3},
+          new Object[] {1, 2},
+        });
     assertThat(cursor.getColumnCount()).isEqualTo(3);
 
     cursor.setColumnNames(asList("a", "b", "c", "d"));
@@ -80,9 +82,10 @@ public class RoboCursorTest {
 
   @Test
   public void getType_shouldReturnColumnType() throws Exception {
-    cursor.setResults(new Object[][]{new Object[]{
-        "aString", 1234L, 42, new byte[]{1, 2, 3}, 255, 1.25f, 2.5d, null
-    }});
+    cursor.setResults(
+        new Object[][] {
+          new Object[] {"aString", 1234L, 42, new byte[] {1, 2, 3}, 255, 1.25f, 2.5d, null}
+        });
     assertThat(cursor.getCount()).isEqualTo(1);
     assertThat(cursor.getType(indexOf(STRING_COLUMN))).isEqualTo(Cursor.FIELD_TYPE_STRING);
     assertThat(cursor.getType(indexOf(LONG_COLUMN))).isEqualTo(Cursor.FIELD_TYPE_INTEGER);
@@ -96,15 +99,18 @@ public class RoboCursorTest {
 
   @Test
   public void get_shouldReturnColumnValue() throws Exception {
-    cursor.setResults(new Object[][]{new Object[]{
-        "aString", 1234L, 42, new byte[]{1, 2, 3}, 255, 1.25f, 2.5d, null
-    }});
+    cursor.setResults(
+        new Object[][] {
+          new Object[] {"aString", 1234L, 42, new byte[] {1, 2, 3}, 255, 1.25f, 2.5d, null}
+        });
     assertThat(cursor.getCount()).isEqualTo(1);
     assertThat(cursor.moveToNext()).isTrue();
     assertThat(cursor.getString(indexOf(STRING_COLUMN))).isEqualTo("aString");
     assertThat(cursor.getLong(indexOf(LONG_COLUMN))).isEqualTo(1234L);
     assertThat(cursor.getInt(indexOf(INT_COLUMN))).isEqualTo(42);
-    assertThat(cursor.getBlob(indexOf(BLOB_COLUMN))).asList().containsExactly((byte) 1, (byte) 2, (byte) 3);
+    assertThat(cursor.getBlob(indexOf(BLOB_COLUMN)))
+        .asList()
+        .containsExactly((byte) 1, (byte) 2, (byte) 3);
     assertThat(cursor.getShort(indexOf(SHORT_COLUMN))).isEqualTo((short) 255);
     assertThat(cursor.getFloat(indexOf(FLOAT_COLUMN))).isEqualTo(1.25f);
     assertThat(cursor.getDouble(indexOf(DOUBLE_COLUMN))).isEqualTo(2.5d);
@@ -113,9 +119,10 @@ public class RoboCursorTest {
 
   @Test
   public void get_shouldConvert() throws Exception {
-    cursor.setResults(new Object[][]{new Object[]{
-        "aString", "1234", "42", new byte[]{1, 2, 3}, 255, "1.25", 2.5d, null
-    }});
+    cursor.setResults(
+        new Object[][] {
+          new Object[] {"aString", "1234", "42", new byte[] {1, 2, 3}, 255, "1.25", 2.5d, null}
+        });
     assertThat(cursor.getCount()).isEqualTo(1);
     assertThat(cursor.moveToNext()).isTrue();
     assertThat(cursor.getString(indexOf(INT_COLUMN))).isEqualTo("42");
@@ -128,8 +135,8 @@ public class RoboCursorTest {
   @Test
   public void moveToNext_advancesToNextRow() throws Exception {
     cursor.setResults(
-        new Object[][]{new Object[]{"aString", 1234L, 41},
-            new Object[]{"anotherString", 5678L, 42}
+        new Object[][] {
+          new Object[] {"aString", 1234L, 41}, new Object[] {"anotherString", 5678L, 42}
         });
 
     assertThat(cursor.getCount()).isEqualTo(2);
@@ -202,7 +209,7 @@ public class RoboCursorTest {
 
   @Test
   public void isBeforeFirst_shouldReturnTrueForPosition() {
-    cursor.setResults(new Object[][]{new Object[]{"Foo"}});
+    cursor.setResults(new Object[][] {new Object[] {"Foo"}});
 
     assertThat(cursor.isBeforeFirst()).isTrue();
     cursor.moveToPosition(0);
@@ -211,7 +218,7 @@ public class RoboCursorTest {
 
   @Test
   public void isAfterLast_shouldReturnTrueForPosition() {
-    cursor.setResults(new Object[][]{new Object[]{"Foo"}});
+    cursor.setResults(new Object[][] {new Object[] {"Foo"}});
 
     assertThat(cursor.isAfterLast()).isFalse();
     cursor.moveToPosition(1);
@@ -220,7 +227,7 @@ public class RoboCursorTest {
 
   @Test
   public void isFirst_shouldReturnTrueForPosition() {
-    cursor.setResults(new Object[][]{new Object[]{"Foo"}, new Object[]{"Bar"}});
+    cursor.setResults(new Object[][] {new Object[] {"Foo"}, new Object[] {"Bar"}});
 
     cursor.moveToPosition(0);
     assertThat(cursor.isFirst()).isTrue();
@@ -231,7 +238,7 @@ public class RoboCursorTest {
 
   @Test
   public void isLast_shouldReturnTrueForPosition() {
-    cursor.setResults(new Object[][]{new Object[]{"Foo"}, new Object[]{"Bar"}});
+    cursor.setResults(new Object[][] {new Object[] {"Foo"}, new Object[] {"Bar"}});
 
     cursor.moveToPosition(0);
     assertThat(cursor.isLast()).isFalse();
diff --git a/robolectric/src/test/java/org/robolectric/fakes/RoboMenuItemTest.java b/robolectric/src/test/java/org/robolectric/fakes/RoboMenuItemTest.java
index 7f31ce9a8..81739c55d 100644
--- a/robolectric/src/test/java/org/robolectric/fakes/RoboMenuItemTest.java
+++ b/robolectric/src/test/java/org/robolectric/fakes/RoboMenuItemTest.java
@@ -21,7 +21,7 @@ public class RoboMenuItemTest {
   @Before
   public void setUp() throws Exception {
     item = new RoboMenuItem(ApplicationProvider.getApplicationContext());
-    listener =  new TestOnActionExpandListener();
+    listener = new TestOnActionExpandListener();
     item.setOnActionExpandListener(listener);
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/fakes/RoboWebSettingsTest.java b/robolectric/src/test/java/org/robolectric/fakes/RoboWebSettingsTest.java
index 79370c33a..7112b59a2 100644
--- a/robolectric/src/test/java/org/robolectric/fakes/RoboWebSettingsTest.java
+++ b/robolectric/src/test/java/org/robolectric/fakes/RoboWebSettingsTest.java
@@ -6,9 +6,7 @@ import android.webkit.WebSettings;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.internal.DoNotInstrument;
 
-@DoNotInstrument
 @RunWith(AndroidJUnit4.class)
 public class RoboWebSettingsTest {
   private final RoboWebSettings webSettings = new RoboWebSettings();
diff --git a/robolectric/src/test/java/org/robolectric/gradleapp/BuildConfig.java b/robolectric/src/test/java/org/robolectric/gradleapp/BuildConfig.java
deleted file mode 100644
index d70f22b75..000000000
--- a/robolectric/src/test/java/org/robolectric/gradleapp/BuildConfig.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package org.robolectric.gradleapp;
-
-public class BuildConfig {
-  // The build system creates a BuildConfig for each flavor/build type combination,
-  // in a different intermediate directory in the build tree.
-  // APPLICATION_ID is unique for each combination. The R class is always found
-  // in the same package as BuildConfig.
-  public static final String APPLICATION_ID = "org.robolectric.gradleapp.demo";
-
-  public static final String BUILD_TYPE = "type1";
-  public static final String FLAVOR = "flavor1";
-}
diff --git a/robolectric/src/test/java/org/robolectric/gradleapp/R.java b/robolectric/src/test/java/org/robolectric/gradleapp/R.java
deleted file mode 100644
index 53a702174..000000000
--- a/robolectric/src/test/java/org/robolectric/gradleapp/R.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package org.robolectric.gradleapp;
-
-public class R {
-
-  public static class string {
-    public static int from_gradle_output = 0x7f030001;
-    public static int item_from_gradle_output = 0x7f030002;
-  }
-
-  public static class color {
-    public static int example_color = 0x7f030003;
-    public static int example_item_color = 0x7f030004;
-  }
-
-  public static class dimen {
-    public static int example_dimen = 0x7f030005;
-    public static int example_item_dimen = 0x7f030006;
-  }
-}
diff --git a/robolectric/src/test/java/org/robolectric/internal/BuckManifestFactoryTest.java b/robolectric/src/test/java/org/robolectric/internal/BuckManifestFactoryTest.java
deleted file mode 100644
index 10ac36359..000000000
--- a/robolectric/src/test/java/org/robolectric/internal/BuckManifestFactoryTest.java
+++ /dev/null
@@ -1,103 +0,0 @@
-package org.robolectric.internal;
-
-import static com.google.common.truth.Truth.assertThat;
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-import com.google.common.io.Files;
-import java.io.File;
-import java.nio.file.Paths;
-import java.util.List;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.manifest.AndroidManifest;
-import org.robolectric.res.ResourcePath;
-
-@RunWith(JUnit4.class)
-public class BuckManifestFactoryTest {
-
-  @Rule public TemporaryFolder tempFolder = new TemporaryFolder();
-
-  private Config.Builder configBuilder;
-  private BuckManifestFactory buckManifestFactory;
-
-  @Before
-  public void setUp() throws Exception {
-    configBuilder = Config.Builder.defaults().setPackageName("com.robolectric.buck");
-    System.setProperty("buck.robolectric_manifest", "buck/AndroidManifest.xml");
-    buckManifestFactory = new BuckManifestFactory();
-  }
-
-  @After
-  public void tearDown() {
-    System.clearProperty("buck.robolectric_manifest");
-    System.clearProperty("buck.robolectric_res_directories");
-    System.clearProperty("buck.robolectric_assets_directories");
-  }
-
-  @Test
-  public void identify() throws Exception {
-    ManifestIdentifier manifestIdentifier = buckManifestFactory.identify(configBuilder.build());
-    assertThat(manifestIdentifier.getManifestFile())
-        .isEqualTo(Paths.get("buck/AndroidManifest.xml"));
-    assertThat(manifestIdentifier.getPackageName()).isEqualTo("com.robolectric.buck");
-  }
-
-  @Test
-  public void multiple_res_dirs() throws Exception {
-    System.setProperty(
-        "buck.robolectric_res_directories", "buck/res1" + File.pathSeparator + "buck/res2");
-    System.setProperty(
-        "buck.robolectric_assets_directories",
-        "buck/assets1" + File.pathSeparator + "buck/assets2");
-
-    ManifestIdentifier manifestIdentifier = buckManifestFactory.identify(configBuilder.build());
-    AndroidManifest manifest = RobolectricTestRunner.createAndroidManifest(manifestIdentifier);
-    assertThat(manifest.getResDirectory()).isEqualTo(Paths.get("buck/res2"));
-    assertThat(manifest.getAssetsDirectory()).isEqualTo(Paths.get("buck/assets2"));
-
-    List<ResourcePath> resourcePathList = manifest.getIncludedResourcePaths();
-    assertThat(resourcePathList.size()).isEqualTo(3);
-    assertThat(resourcePathList)
-        .containsExactly(
-            new ResourcePath(
-                manifest.getRClass(), Paths.get("buck/res2"), Paths.get("buck/assets2")),
-            new ResourcePath(manifest.getRClass(), Paths.get("buck/res1"), null),
-            new ResourcePath(manifest.getRClass(), null, Paths.get("buck/assets1")));
-  }
-
-  @Test
-  public void pass_multiple_res_dirs_in_file() throws Exception {
-    String resDirectoriesFileName = "res-directories";
-    File resDirectoriesFile = tempFolder.newFile(resDirectoriesFileName);
-    Files.asCharSink(resDirectoriesFile, UTF_8).write("buck/res1\nbuck/res2");
-    System.setProperty(
-        "buck.robolectric_res_directories", "@" + resDirectoriesFile.getAbsolutePath());
-
-    String assetDirectoriesFileName = "asset-directories";
-    File assetDirectoriesFile = tempFolder.newFile(assetDirectoriesFileName);
-    Files.asCharSink(assetDirectoriesFile, UTF_8).write("buck/assets1\nbuck/assets2");
-    System.setProperty(
-        "buck.robolectric_assets_directories", "@" + assetDirectoriesFile.getAbsolutePath());
-
-    ManifestIdentifier manifestIdentifier = buckManifestFactory.identify(configBuilder.build());
-    AndroidManifest manifest = RobolectricTestRunner.createAndroidManifest(manifestIdentifier);
-    assertThat(manifest.getResDirectory()).isEqualTo(Paths.get("buck/res2"));
-    assertThat(manifest.getAssetsDirectory()).isEqualTo(Paths.get("buck/assets2"));
-
-    List<ResourcePath> resourcePathList = manifest.getIncludedResourcePaths();
-    assertThat(resourcePathList.size()).isEqualTo(3);
-    assertThat(resourcePathList)
-        .containsExactly(
-            new ResourcePath(
-                manifest.getRClass(), Paths.get("buck/res2"), Paths.get("buck/assets2")),
-            new ResourcePath(manifest.getRClass(), Paths.get("buck/res1"), null),
-            new ResourcePath(manifest.getRClass(), null, Paths.get("buck/assets1")));
-  }
-}
diff --git a/robolectric/src/test/java/org/robolectric/internal/bytecode/InstrumentationConfigurationTest.java b/robolectric/src/test/java/org/robolectric/internal/bytecode/InstrumentationConfigurationTest.java
index 4e67bc9f4..467726d63 100644
--- a/robolectric/src/test/java/org/robolectric/internal/bytecode/InstrumentationConfigurationTest.java
+++ b/robolectric/src/test/java/org/robolectric/internal/bytecode/InstrumentationConfigurationTest.java
@@ -67,11 +67,11 @@ public class InstrumentationConfigurationTest {
   }
 
   @Test
-  public void shouldNotAcquireRClasses() throws Exception {
+  public void shouldAcquireRClasses() throws Exception {
     assertThat(config.shouldAcquire("com.whatever.Rfoo")).isTrue();
     assertThat(config.shouldAcquire("com.whatever.fooR")).isTrue();
-    assertThat(config.shouldAcquire("com.whatever.R")).isFalse();
-    assertThat(config.shouldAcquire("com.whatever.R$anything")).isFalse();
+    assertThat(config.shouldAcquire("com.whatever.R")).isTrue();
+    assertThat(config.shouldAcquire("com.whatever.R$anything")).isTrue();
     assertThat(config.shouldAcquire("com.whatever.R$anything$else")).isTrue();
   }
 
@@ -103,7 +103,8 @@ public class InstrumentationConfigurationTest {
   public void shouldInstrumentCustomClasses() throws Exception {
     String instrumentName = "com.whatever.SomeClassNameToInstrument";
     String notInstrumentName = "com.whatever.DoNotInstrumentMe";
-    InstrumentationConfiguration customConfig = InstrumentationConfiguration.newBuilder().addInstrumentedClass(instrumentName).build();
+    InstrumentationConfiguration customConfig =
+        InstrumentationConfiguration.newBuilder().addInstrumentedClass(instrumentName).build();
     assertThat(customConfig.shouldInstrument(wrap(instrumentName))).isTrue();
     assertThat(customConfig.shouldInstrument(wrap(notInstrumentName))).isFalse();
   }
@@ -112,7 +113,8 @@ public class InstrumentationConfigurationTest {
   public void equals_ShouldCheckClassNames() throws Exception {
     String instrumentName = "com.whatever.SomeClassNameToInstrument";
     InstrumentationConfiguration baseConfig = InstrumentationConfiguration.newBuilder().build();
-    InstrumentationConfiguration customConfig = InstrumentationConfiguration.newBuilder().addInstrumentedClass(instrumentName).build();
+    InstrumentationConfiguration customConfig =
+        InstrumentationConfiguration.newBuilder().addInstrumentedClass(instrumentName).build();
 
     assertThat(baseConfig).isNotEqualTo(customConfig);
   }
@@ -120,7 +122,8 @@ public class InstrumentationConfigurationTest {
   @Test
   public void shouldNotInstrumentListedClasses() throws Exception {
     String instrumentName = "android.foo.bar";
-    InstrumentationConfiguration customConfig = InstrumentationConfiguration.newBuilder().doNotInstrumentClass(instrumentName).build();
+    InstrumentationConfiguration customConfig =
+        InstrumentationConfiguration.newBuilder().doNotInstrumentClass(instrumentName).build();
 
     assertThat(customConfig.shouldInstrument(wrap(instrumentName))).isFalse();
   }
@@ -177,7 +180,6 @@ public class InstrumentationConfigurationTest {
     assertThat(customConfig.shouldInstrument(wrap("com.random.testclass_GoodThings"))).isTrue();
     assertThat(customConfig.shouldInstrument(wrap("com.random.badpackage.testclass"))).isFalse();
     assertThat(customConfig.shouldInstrument(wrap("com.random.goodpackage.testclass"))).isTrue();
-
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/internal/bytecode/MethodSignatureTest.java b/robolectric/src/test/java/org/robolectric/internal/bytecode/MethodSignatureTest.java
index 63e98b61b..073f91d3c 100644
--- a/robolectric/src/test/java/org/robolectric/internal/bytecode/MethodSignatureTest.java
+++ b/robolectric/src/test/java/org/robolectric/internal/bytecode/MethodSignatureTest.java
@@ -11,7 +11,8 @@ public class MethodSignatureTest {
 
   @Test
   public void parse_shouldHandlePrimitiveReturnTypes() {
-    final MethodSignature signature = MethodSignature.parse("java/lang/Long/foo(Ljava/lang/Integer;)Z");
+    final MethodSignature signature =
+        MethodSignature.parse("java/lang/Long/foo(Ljava/lang/Integer;)Z");
     assertThat(signature.className).isEqualTo("java.lang.Long");
     assertThat(signature.methodName).isEqualTo("foo");
     assertThat(signature.paramTypes).asList().contains("java.lang.Integer");
@@ -20,10 +21,11 @@ public class MethodSignatureTest {
 
   @Test
   public void parse_shouldHandleObjectReturnTypes() {
-    final MethodSignature signature = MethodSignature.parse("java/lang/Long/foo(Ljava/lang/Integer;)Ljava/lang/Long;");
+    final MethodSignature signature =
+        MethodSignature.parse("java/lang/Long/foo(Ljava/lang/Integer;)Ljava/lang/Long;");
     assertThat(signature.className).isEqualTo("java.lang.Long");
     assertThat(signature.methodName).isEqualTo("foo");
     assertThat(signature.paramTypes).asList().contains("java.lang.Integer");
     assertThat(signature.returnType).isEqualTo("java.lang.Long");
   }
-}
\ No newline at end of file
+}
diff --git a/robolectric/src/test/java/org/robolectric/internal/bytecode/ShadowMapTest.java b/robolectric/src/test/java/org/robolectric/internal/bytecode/ShadowMapTest.java
index 7ad754314..4db08a531 100644
--- a/robolectric/src/test/java/org/robolectric/internal/bytecode/ShadowMapTest.java
+++ b/robolectric/src/test/java/org/robolectric/internal/bytecode/ShadowMapTest.java
@@ -58,20 +58,22 @@ public class ShadowMapTest {
     baseShadowMap = ShadowMap.createFromShadowProviders(shadowProviders);
   }
 
-  @Test public void shouldLookUpShadowClassesByNamingConvention() throws Exception {
+  @Test
+  public void shouldLookUpShadowClassesByNamingConvention() throws Exception {
     ShadowMap map = baseShadowMap.newBuilder().build();
     assertThat(map.getShadowInfo(Activity.class, ShadowMatcher.MATCH_ALL)).isNull();
   }
 
-  @Test public void shouldNotReturnMismatchedClassesJustBecauseTheSimpleNameMatches() throws Exception {
-    ShadowMap map = baseShadowMap.newBuilder()
-        .addShadowClasses(ShadowActivity.class)
-        .build();
-    assertThat(map.getShadowInfo(android.app.Activity.class, ShadowMatcher.MATCH_ALL).shadowClassName)
+  @Test
+  public void shouldNotReturnMismatchedClassesJustBecauseTheSimpleNameMatches() throws Exception {
+    ShadowMap map = baseShadowMap.newBuilder().addShadowClasses(ShadowActivity.class).build();
+    assertThat(
+            map.getShadowInfo(android.app.Activity.class, ShadowMatcher.MATCH_ALL).shadowClassName)
         .isEqualTo(ShadowActivity.class.getName());
   }
 
-  @Test public void getInvalidatedClasses_disjoin() {
+  @Test
+  public void getInvalidatedClasses_disjoin() {
     ShadowMap current =
         baseShadowMap.newBuilder().addShadowClass(A1, A2, true, false, false).build();
     ShadowMap previous =
@@ -80,7 +82,8 @@ public class ShadowMapTest {
     assertThat(current.getInvalidatedClasses(previous)).containsExactly(A1, B1);
   }
 
-  @Test public void getInvalidatedClasses_overlap() {
+  @Test
+  public void getInvalidatedClasses_overlap() {
     ShadowMap current =
         baseShadowMap
             .newBuilder()
@@ -97,7 +100,8 @@ public class ShadowMapTest {
     assertThat(current.getInvalidatedClasses(previous)).containsExactly(C1);
   }
 
-  @Test public void equalsHashCode() throws Exception {
+  @Test
+  public void equalsHashCode() throws Exception {
     ShadowMap a = baseShadowMap.newBuilder().addShadowClass(A, B, true, false, false).build();
     ShadowMap b = baseShadowMap.newBuilder().addShadowClass(A, B, true, false, false).build();
     assertThat(a).isEqualTo(b);
@@ -193,14 +197,23 @@ public class ShadowMapTest {
   static class Activity {}
 
   static class A {}
+
   static class A1 {}
+
   static class A2 {}
+
   static class B {}
+
   static class B1 {}
+
   static class B2 {}
+
   static class C1 {}
+
   static class C2 {}
+
   static class C3 {}
+
   static class X {}
 
   @Implements(value = Activity.class, maxSdk = 29)
diff --git a/robolectric/src/test/java/org/robolectric/internal/dependency/PropertiesDependencyResolverTest.java b/robolectric/src/test/java/org/robolectric/internal/dependency/PropertiesDependencyResolverTest.java
index f4562f5d2..3eed57591 100644
--- a/robolectric/src/test/java/org/robolectric/internal/dependency/PropertiesDependencyResolverTest.java
+++ b/robolectric/src/test/java/org/robolectric/internal/dependency/PropertiesDependencyResolverTest.java
@@ -39,8 +39,9 @@ public class PropertiesDependencyResolverTest {
   @Test
   public void whenAbsolutePathIsProvidedInProperties_shouldReturnFileUrl() throws Exception {
     String absolutePath = cColonBackslash ? "c:\\tmp\\file.jar" : "/tmp/file.jar";
-    DependencyResolver resolver = new PropertiesDependencyResolver(
-        propsFile("com.group:example:1.3", new File(absolutePath).getAbsoluteFile()), mock);
+    DependencyResolver resolver =
+        new PropertiesDependencyResolver(
+            propsFile("com.group:example:1.3", new File(absolutePath).getAbsoluteFile()), mock);
 
     URL url = resolver.getLocalArtifactUrl(exampleDep);
     if (cColonBackslash) {
@@ -52,29 +53,29 @@ public class PropertiesDependencyResolverTest {
 
   @Test
   public void whenRelativePathIsProvidedInProperties_shouldReturnFileUrl() throws Exception {
-    DependencyResolver resolver = new PropertiesDependencyResolver(
-        propsFile("com.group:example:1.3", new File("path", "1")), mock);
+    DependencyResolver resolver =
+        new PropertiesDependencyResolver(
+            propsFile("com.group:example:1.3", new File("path", "1")), mock);
 
     URL url = resolver.getLocalArtifactUrl(exampleDep);
-    assertThat(url).isEqualTo(
-        temporaryFolder.getRoot().toPath().resolve("path").resolve("1").toUri().toURL());
+    assertThat(url)
+        .isEqualTo(temporaryFolder.getRoot().toPath().resolve("path").resolve("1").toUri().toURL());
   }
 
   @Test
   public void whenMissingFromProperties_shouldDelegate() throws Exception {
-    DependencyResolver resolver = new PropertiesDependencyResolver(
-        propsFile("nothing", new File("interesting")), mock);
+    DependencyResolver resolver =
+        new PropertiesDependencyResolver(propsFile("nothing", new File("interesting")), mock);
 
     when(mock.getLocalArtifactUrl(exampleDep)).thenReturn(new URL("file:///path/3"));
     URL url = resolver.getLocalArtifactUrl(exampleDep);
-    assertThat(url).isEqualTo(new URL("file:///path/3")
-    );
+    assertThat(url).isEqualTo(new URL("file:///path/3"));
   }
 
   @Test
   public void whenDelegateIsNull_shouldGiveGoodMessage() throws Exception {
-    DependencyResolver resolver = new PropertiesDependencyResolver(
-        propsFile("nothing", new File("interesting")), null);
+    DependencyResolver resolver =
+        new PropertiesDependencyResolver(propsFile("nothing", new File("interesting")), null);
 
     try {
       resolver.getLocalArtifactUrl(exampleDep);
@@ -99,4 +100,4 @@ public class PropertiesDependencyResolverTest {
     }
     return file.toPath();
   }
-}
\ No newline at end of file
+}
diff --git a/robolectric/src/test/java/org/robolectric/junit/rules/TimeoutRuleTest.java b/robolectric/src/test/java/org/robolectric/junit/rules/TimeoutRuleTest.java
new file mode 100644
index 000000000..50891c7d0
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/junit/rules/TimeoutRuleTest.java
@@ -0,0 +1,52 @@
+package org.robolectric.junit.rules;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Assert;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.RuleChain;
+import org.junit.runner.Description;
+import org.junit.runner.RunWith;
+import org.junit.runners.model.Statement;
+import org.junit.runners.model.TestTimedOutException;
+
+/** Tests for {@link TimeoutRule}. */
+@RunWith(AndroidJUnit4.class)
+public final class TimeoutRuleTest {
+
+  private final TimeoutRule rule = TimeoutRule.millis(200);
+
+  @Rule public RuleChain chain = RuleChain.outerRule(rule);
+
+  @Test
+  public void testNotTimingOutFinishes() throws InterruptedException {
+    Thread.sleep(50);
+  }
+
+  @Test
+  public void testTimingOutIsInterrupted() {
+    try {
+      Thread.sleep(1000);
+      Assert.fail("Should never reach this statement");
+    } catch (InterruptedException e) {
+      // ignore expected
+    }
+  }
+
+  @Test
+  public void verifyErrorMessage() {
+    final TimeoutRule timeoutRule = TimeoutRule.millis(50);
+    final Statement threadSleepStatement =
+        new Statement() {
+          @Override
+          public void evaluate() throws Throwable {
+            Thread.sleep(1000);
+          }
+        };
+    final Statement wrappedStatement = timeoutRule.apply(threadSleepStatement, Description.EMPTY);
+
+    final TestTimedOutException exception =
+        Assert.assertThrows(TestTimedOutException.class, wrappedStatement::evaluate);
+    Assert.assertEquals("test timed out after 50 milliseconds", exception.getMessage());
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/manifest/AndroidManifestTest.java b/robolectric/src/test/java/org/robolectric/manifest/AndroidManifestTest.java
index 9c65dcf33..826b107c0 100644
--- a/robolectric/src/test/java/org/robolectric/manifest/AndroidManifestTest.java
+++ b/robolectric/src/test/java/org/robolectric/manifest/AndroidManifestTest.java
@@ -49,9 +49,8 @@ public class AndroidManifestTest {
     AndroidManifest config = newConfig("TestAndroidManifestWithPermissions.xml");
 
     assertThat(config.getPermissions().keySet())
-        .containsExactly("some_permission",
-            "permission_with_literal_label",
-            "permission_with_minimal_fields");
+        .containsExactly(
+            "some_permission", "permission_with_literal_label", "permission_with_minimal_fields");
     PermissionItemData permissionItemData = config.getPermissions().get("some_permission");
     assertThat(permissionItemData.getMetaData().getValueMap())
         .containsEntry("meta_data_name", "meta_data_value");
@@ -66,8 +65,7 @@ public class AndroidManifestTest {
   public void parseManifest_shouldReadPermissionGroups() {
     AndroidManifest config = newConfig("TestAndroidManifestWithPermissions.xml");
 
-    assertThat(config.getPermissionGroups().keySet())
-        .contains("permission_group");
+    assertThat(config.getPermissionGroups().keySet()).contains("permission_group");
     PermissionGroupItemData permissionGroupItemData =
         config.getPermissionGroups().get("permission_group");
     assertThat(permissionGroupItemData.getName()).isEqualTo("permission_group");
@@ -403,7 +401,8 @@ public class AndroidManifestTest {
 
     assertThat(config.getUsedPermissions()).hasSize(3);
     assertThat(config.getUsedPermissions().get(0)).isEqualTo(Manifest.permission.INTERNET);
-    assertThat(config.getUsedPermissions().get(1)).isEqualTo(Manifest.permission.SYSTEM_ALERT_WINDOW);
+    assertThat(config.getUsedPermissions().get(1))
+        .isEqualTo(Manifest.permission.SYSTEM_ALERT_WINDOW);
     assertThat(config.getUsedPermissions().get(2)).isEqualTo(Manifest.permission.GET_TASKS);
   }
 
@@ -447,7 +446,6 @@ public class AndroidManifestTest {
     assertThat(intentFilterData.getPathPatterns().size()).isEqualTo(1);
     assertThat(intentFilterData.getPathPrefixes().size()).isEqualTo(1);
 
-
     assertThat(intentFilterData.getSchemes().get(0)).isEqualTo("content");
     assertThat(intentFilterData.getPaths().get(0)).isEqualTo("/testPath/test.jpeg");
     assertThat(intentFilterData.getMimeTypes().get(0)).isEqualTo("video/mpeg");
@@ -492,8 +490,7 @@ public class AndroidManifestTest {
       String packageName = type.getPackage().getName();
       if (packageName.startsWith("java.")
           || packageName.equals("org.robolectric.res")
-          || packageName.equals("org.robolectric.manifest")
-          ) continue;
+          || packageName.equals("org.robolectric.manifest")) continue;
 
       wrongFields.add(field);
     }
@@ -550,22 +547,34 @@ public class AndroidManifestTest {
   public void getTransitiveManifests() {
     AndroidManifest lib1 =
         new AndroidManifest(resourceFile("lib1/AndroidManifest.xml"), null, null);
-    AndroidManifest lib2 = new AndroidManifest(resourceFile("lib2/AndroidManifest.xml"), null, null,
-        Collections.singletonList(lib1), null);
-    AndroidManifest app = new AndroidManifest(
-        resourceFile("TestAndroidManifestWithReceivers.xml"), null, null,
-        Arrays.asList(lib1, lib2), null);
+    AndroidManifest lib2 =
+        new AndroidManifest(
+            resourceFile("lib2/AndroidManifest.xml"),
+            null,
+            null,
+            Collections.singletonList(lib1),
+            null);
+    AndroidManifest app =
+        new AndroidManifest(
+            resourceFile("TestAndroidManifestWithReceivers.xml"),
+            null,
+            null,
+            Arrays.asList(lib1, lib2),
+            null);
     assertThat(app.getAllManifests()).containsExactly(app, lib1, lib2);
   }
 
   /////////////////////////////
 
   private AndroidManifest newConfigWith(String fileName, String usesSdkAttrs) throws IOException {
-    String contents = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" +
-        "<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n" +
-        "          package=\"org.robolectric\">\n" +
-        "    <uses-sdk " + usesSdkAttrs + "/>\n" +
-        "</manifest>\n";
+    String contents =
+        "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+            + "<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n"
+            + "          package=\"org.robolectric\">\n"
+            + "    <uses-sdk "
+            + usesSdkAttrs
+            + "/>\n"
+            + "</manifest>\n";
     File f = temporaryFolder.newFile(fileName);
     Files.asCharSink(f, UTF_8).write(contents);
     return new AndroidManifest(f.toPath(), null, null);
diff --git a/robolectric/src/test/java/org/robolectric/plugins/CustomConfigurerTest.java b/robolectric/src/test/java/org/robolectric/plugins/CustomConfigurerTest.java
index 20deddf35..d397d3609 100644
--- a/robolectric/src/test/java/org/robolectric/plugins/CustomConfigurerTest.java
+++ b/robolectric/src/test/java/org/robolectric/plugins/CustomConfigurerTest.java
@@ -115,14 +115,14 @@ public class CustomConfigurerTest {
             new LooperModeConfigurer(new Properties(), new PackagePropertiesLoader()),
             new SomeConfigConfigurer());
 
-    SingleSdkRobolectricTestRunner testRunner = new SingleSdkRobolectricTestRunner(
-        testClass,
-        SingleSdkRobolectricTestRunner.defaultInjector()
-            .bind(ConfigurationStrategy.class, configurationStrategy)
-            .build());
+    SingleSdkRobolectricTestRunner testRunner =
+        new SingleSdkRobolectricTestRunner(
+            testClass,
+            SingleSdkRobolectricTestRunner.defaultInjector()
+                .bind(ConfigurationStrategy.class, configurationStrategy)
+                .build());
 
     testRunner.run(notifier);
     return failureListener.failures.stream().map(Failure::getMessage).collect(toList());
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/plugins/DefaultSdkPickerTest.java b/robolectric/src/test/java/org/robolectric/plugins/DefaultSdkPickerTest.java
index 37199f929..f588e93f9 100644
--- a/robolectric/src/test/java/org/robolectric/plugins/DefaultSdkPickerTest.java
+++ b/robolectric/src/test/java/org/robolectric/plugins/DefaultSdkPickerTest.java
@@ -24,7 +24,7 @@ import org.robolectric.util.TestUtil;
 
 @RunWith(JUnit4.class)
 public class DefaultSdkPickerTest {
-  private static final int[] sdkInts = { 16, 17, 18, 19, 21, 22, 23 };
+  private static final int[] sdkInts = {16, 17, 18, 19, 21, 22, 23};
   private SdkCollection sdkCollection;
   private UsesSdk usesSdk;
   private SdkPicker sdkPicker;
@@ -48,30 +48,48 @@ public class DefaultSdkPickerTest {
     when(usesSdk.getTargetSdkVersion()).thenReturn(22);
     when(usesSdk.getMinSdkVersion()).thenReturn(19);
     when(usesSdk.getMaxSdkVersion()).thenReturn(23);
-    assertThat(sdkPicker.selectSdks(buildConfig(new Config.Builder().setSdk(Config.ALL_SDKS)), usesSdk))
-        .containsExactly(sdkCollection.getSdk(19), sdkCollection.getSdk(21),
-            sdkCollection.getSdk(22), sdkCollection.getSdk(23));
+    assertThat(
+            sdkPicker.selectSdks(
+                buildConfig(new Config.Builder().setSdk(Config.ALL_SDKS)), usesSdk))
+        .containsExactly(
+            sdkCollection.getSdk(19),
+            sdkCollection.getSdk(21),
+            sdkCollection.getSdk(22),
+            sdkCollection.getSdk(23));
   }
 
   @Test
-  public void withAllSdksConfigAndNoMinSdkVersion_shouldUseFullSdkRangeFromAndroidManifest() throws Exception {
+  public void withAllSdksConfigAndNoMinSdkVersion_shouldUseFullSdkRangeFromAndroidManifest()
+      throws Exception {
     when(usesSdk.getTargetSdkVersion()).thenReturn(22);
     when(usesSdk.getMinSdkVersion()).thenReturn(1);
     when(usesSdk.getMaxSdkVersion()).thenReturn(22);
-    assertThat(sdkPicker.selectSdks(buildConfig(new Config.Builder().setSdk(Config.ALL_SDKS)), usesSdk))
-        .containsExactly(sdkCollection.getSdk(16), sdkCollection.getSdk(17),
-            sdkCollection.getSdk(18), sdkCollection.getSdk(19),
-            sdkCollection.getSdk(21), sdkCollection.getSdk(22));
+    assertThat(
+            sdkPicker.selectSdks(
+                buildConfig(new Config.Builder().setSdk(Config.ALL_SDKS)), usesSdk))
+        .containsExactly(
+            sdkCollection.getSdk(16),
+            sdkCollection.getSdk(17),
+            sdkCollection.getSdk(18),
+            sdkCollection.getSdk(19),
+            sdkCollection.getSdk(21),
+            sdkCollection.getSdk(22));
   }
 
   @Test
-  public void withAllSdksConfigAndNoMaxSdkVersion_shouldUseFullSdkRangeFromAndroidManifest() throws Exception {
+  public void withAllSdksConfigAndNoMaxSdkVersion_shouldUseFullSdkRangeFromAndroidManifest()
+      throws Exception {
     when(usesSdk.getTargetSdkVersion()).thenReturn(22);
     when(usesSdk.getMinSdkVersion()).thenReturn(19);
     when(usesSdk.getMaxSdkVersion()).thenReturn(null);
-    assertThat(sdkPicker.selectSdks(buildConfig(new Config.Builder().setSdk(Config.ALL_SDKS)), usesSdk))
-        .containsExactly(sdkCollection.getSdk(19), sdkCollection.getSdk(21),
-            sdkCollection.getSdk(22), sdkCollection.getSdk(23));
+    assertThat(
+            sdkPicker.selectSdks(
+                buildConfig(new Config.Builder().setSdk(Config.ALL_SDKS)), usesSdk))
+        .containsExactly(
+            sdkCollection.getSdk(19),
+            sdkCollection.getSdk(21),
+            sdkCollection.getSdk(22),
+            sdkCollection.getSdk(23));
   }
 
   @Test
@@ -90,11 +108,12 @@ public class DefaultSdkPickerTest {
     when(usesSdk.getMaxSdkVersion()).thenReturn(null);
 
     try {
-      sdkPicker.selectSdks(
-          buildConfig(new Config.Builder().setMinSdk(22).setMaxSdk(21)), usesSdk);
+      sdkPicker.selectSdks(buildConfig(new Config.Builder().setMinSdk(22).setMaxSdk(21)), usesSdk);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageThat().contains("minSdk may not be larger than maxSdk (minSdk=22, maxSdk=21)");
+      assertThat(e)
+          .hasMessageThat()
+          .contains("minSdk may not be larger than maxSdk (minSdk=22, maxSdk=21)");
     }
   }
 
@@ -138,8 +157,8 @@ public class DefaultSdkPickerTest {
     when(usesSdk.getMinSdkVersion()).thenReturn(19);
     when(usesSdk.getMaxSdkVersion()).thenReturn(23);
     assertThat(sdkPicker.selectSdks(buildConfig(new Config.Builder().setMinSdk(21)), usesSdk))
-        .containsExactly(sdkCollection.getSdk(21), sdkCollection.getSdk(22),
-            sdkCollection.getSdk(23));
+        .containsExactly(
+            sdkCollection.getSdk(21), sdkCollection.getSdk(22), sdkCollection.getSdk(23));
   }
 
   @Test
@@ -159,11 +178,17 @@ public class DefaultSdkPickerTest {
 
     assertThat(sdkPicker.selectSdks(buildConfig(new Config.Builder().setSdk(21)), usesSdk))
         .containsExactly(sdkCollection.getSdk(21));
-    assertThat(sdkPicker.selectSdks(buildConfig(new Config.Builder().setSdk(Config.OLDEST_SDK)), usesSdk))
+    assertThat(
+            sdkPicker.selectSdks(
+                buildConfig(new Config.Builder().setSdk(Config.OLDEST_SDK)), usesSdk))
         .containsExactly(sdkCollection.getSdk(19));
-    assertThat(sdkPicker.selectSdks(buildConfig(new Config.Builder().setSdk(Config.TARGET_SDK)), usesSdk))
+    assertThat(
+            sdkPicker.selectSdks(
+                buildConfig(new Config.Builder().setSdk(Config.TARGET_SDK)), usesSdk))
         .containsExactly(sdkCollection.getSdk(21));
-    assertThat(sdkPicker.selectSdks(buildConfig(new Config.Builder().setSdk(Config.NEWEST_SDK)), usesSdk))
+    assertThat(
+            sdkPicker.selectSdks(
+                buildConfig(new Config.Builder().setSdk(Config.NEWEST_SDK)), usesSdk))
         .containsExactly(sdkCollection.getSdk(22));
 
     assertThat(sdkPicker.selectSdks(buildConfig(new Config.Builder().setSdk(16)), usesSdk))
@@ -177,7 +202,9 @@ public class DefaultSdkPickerTest {
     when(usesSdk.getMinSdkVersion()).thenReturn(16);
     when(usesSdk.getMaxSdkVersion()).thenReturn(23);
     sdkPicker = new DefaultSdkPicker(sdkCollection, "17,18");
-    assertThat(sdkPicker.selectSdks(buildConfig(new Config.Builder().setSdk(Config.ALL_SDKS)), usesSdk))
+    assertThat(
+            sdkPicker.selectSdks(
+                buildConfig(new Config.Builder().setSdk(Config.ALL_SDKS)), usesSdk))
         .containsExactly(sdkCollection.getSdk(17), sdkCollection.getSdk(18));
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/plugins/HierarchicalConfigurationStrategyTest.java b/robolectric/src/test/java/org/robolectric/plugins/HierarchicalConfigurationStrategyTest.java
index c1e7c578d..76abbc940 100644
--- a/robolectric/src/test/java/org/robolectric/plugins/HierarchicalConfigurationStrategyTest.java
+++ b/robolectric/src/test/java/org/robolectric/plugins/HierarchicalConfigurationStrategyTest.java
@@ -30,14 +30,20 @@ import org.robolectric.shadows.testing.TestApplication;
 @RunWith(JUnit4.class)
 public class HierarchicalConfigurationStrategyTest {
 
-  @Test public void defaultValuesAreMerged() throws Exception {
+  @Test
+  public void defaultValuesAreMerged() throws Exception {
     assertThat(configFor(Test2.class, "withoutAnnotation").manifest())
         .isEqualTo("AndroidManifest.xml");
   }
 
-  @Test public void globalValuesAreMerged() throws Exception {
-    assertThat(configFor(Test2.class, "withoutAnnotation",
-        new Config.Builder().setManifest("ManifestFromGlobal.xml").build()).manifest())
+  @Test
+  public void globalValuesAreMerged() throws Exception {
+    assertThat(
+            configFor(
+                    Test2.class,
+                    "withoutAnnotation",
+                    new Config.Builder().setManifest("ManifestFromGlobal.xml").build())
+                .manifest())
         .isEqualTo("ManifestFromGlobal.xml");
   }
 
@@ -171,8 +177,9 @@ public class HierarchicalConfigurationStrategyTest {
   }
 
   @Test
-  public void whenClassAndParentClassHaveConfigAnnotation_getConfig_shouldMergeParentClassAndMethodConfig()
-      throws Exception {
+  public void
+      whenClassAndParentClassHaveConfigAnnotation_getConfig_shouldMergeParentClassAndMethodConfig()
+          throws Exception {
     assertConfig(
         configFor(Test1C.class, "withoutAnnotation"),
         new int[] {1},
@@ -214,8 +221,9 @@ public class HierarchicalConfigurationStrategyTest {
   }
 
   @Test
-  public void whenClassAndSubclassHaveConfigAnnotation_getConfig_shouldMergeClassSubclassAndMethodConfig()
-      throws Exception {
+  public void
+      whenClassAndSubclassHaveConfigAnnotation_getConfig_shouldMergeClassSubclassAndMethodConfig()
+          throws Exception {
     assertConfig(
         configFor(Test1A.class, "withoutAnnotation"),
         new int[] {1},
@@ -257,8 +265,9 @@ public class HierarchicalConfigurationStrategyTest {
   }
 
   @Test
-  public void whenClassDoesntHaveConfigAnnotationButSubclassDoes_getConfig_shouldMergeSubclassAndMethodConfig()
-      throws Exception {
+  public void
+      whenClassDoesntHaveConfigAnnotationButSubclassDoes_getConfig_shouldMergeSubclassAndMethodConfig()
+          throws Exception {
     assertConfig(
         configFor(Test2A.class, "withoutAnnotation"),
         new int[0],
@@ -394,92 +403,91 @@ public class HierarchicalConfigurationStrategyTest {
         new String[] {});
   }
 
-  @Test public void testPrecedence() throws Exception {
+  @Test
+  public void testPrecedence() throws Exception {
     SpyConfigurer spyConfigurer = new SpyConfigurer();
 
-    ConfigurationStrategy configStrategy =
-        new HierarchicalConfigurationStrategy(spyConfigurer);
+    ConfigurationStrategy configStrategy = new HierarchicalConfigurationStrategy(spyConfigurer);
 
     assertThat(computeConfig(configStrategy, Test1.class, "withoutAnnotation"))
         .isEqualTo(
             "default:(top):org:org.robolectric:org.robolectric.plugins"
-                + ":" + Test1.class.getName()
+                + ":"
+                + Test1.class.getName()
                 + ":withoutAnnotation");
 
     assertThat(computeConfig(configStrategy, Test1A.class, "withOverrideAnnotation"))
         .isEqualTo(
             "default:(top):org:org.robolectric:org.robolectric.plugins"
-                + ":" + Test1.class.getName()
-                + ":" + Test1A.class.getName()
+                + ":"
+                + Test1.class.getName()
+                + ":"
+                + Test1A.class.getName()
                 + ":withOverrideAnnotation");
   }
 
-  @Test public void testTestClassMatters() throws Exception {
+  @Test
+  public void testTestClassMatters() throws Exception {
     SpyConfigurer spyConfigurer = new SpyConfigurer();
 
-    ConfigurationStrategy configStrategy =
-        new HierarchicalConfigurationStrategy(spyConfigurer);
+    ConfigurationStrategy configStrategy = new HierarchicalConfigurationStrategy(spyConfigurer);
 
     assertThat(computeConfig(configStrategy, Test1.class, "withoutAnnotation"))
         .isEqualTo(
             "default:(top):org:org.robolectric:org.robolectric.plugins"
-                + ":" + Test1.class.getName()
+                + ":"
+                + Test1.class.getName()
                 + ":withoutAnnotation");
 
     assertThat(computeConfig(configStrategy, Test1A.class, "withoutAnnotation"))
         .isEqualTo(
             "default:(top):org:org.robolectric:org.robolectric.plugins"
-                + ":" + Test1.class.getName()
-                + ":" + Test1A.class.getName()
+                + ":"
+                + Test1.class.getName()
+                + ":"
+                + Test1A.class.getName()
                 + ":withoutAnnotation");
   }
 
-  @Test public void testBigOAndCaching() throws Exception {
+  @Test
+  public void testBigOAndCaching() throws Exception {
     SpyConfigurer spyConfigurer = new SpyConfigurer();
-    ConfigurationStrategy configStrategy =
-        new HierarchicalConfigurationStrategy(spyConfigurer);
+    ConfigurationStrategy configStrategy = new HierarchicalConfigurationStrategy(spyConfigurer);
     computeConfig(configStrategy, Test1A.class, "withoutAnnotation");
 
-    assertThat(spyConfigurer.log).containsExactly(
-        "default",
-        "withoutAnnotation",
-        Test1A.class.getName(),
-        Test1.class.getName(),
-        "org.robolectric.plugins",
-        "org.robolectric",
-        "org",
-        "(top)"
-    ).inOrder();
+    assertThat(spyConfigurer.log)
+        .containsExactly(
+            "default",
+            "withoutAnnotation",
+            Test1A.class.getName(),
+            Test1.class.getName(),
+            "org.robolectric.plugins",
+            "org.robolectric",
+            "org",
+            "(top)")
+        .inOrder();
 
     spyConfigurer.log.clear();
     computeConfig(configStrategy, Test1.class, "withoutAnnotation");
-    assertThat(spyConfigurer.log).containsExactly(
-        "withoutAnnotation"
-    ).inOrder();
+    assertThat(spyConfigurer.log).containsExactly("withoutAnnotation").inOrder();
 
     spyConfigurer.log.clear();
     computeConfig(configStrategy, Test2A.class, "withOverrideAnnotation");
-    assertThat(spyConfigurer.log).containsExactly(
-        "withOverrideAnnotation",
-        Test2A.class.getName(),
-        Test2.class.getName()
-    ).inOrder();
+    assertThat(spyConfigurer.log)
+        .containsExactly("withOverrideAnnotation", Test2A.class.getName(), Test2.class.getName())
+        .inOrder();
   }
 
   /////////////////////////////
 
-
-  private String computeConfig(ConfigurationStrategy configStrategy,
-      Class<?> testClass, String methodName)
+  private String computeConfig(
+      ConfigurationStrategy configStrategy, Class<?> testClass, String methodName)
       throws NoSuchMethodException {
-    return configStrategy
-        .getConfig(testClass,
-            testClass.getMethod(methodName))
-        .get(String.class);
+    return configStrategy.getConfig(testClass, testClass.getMethod(methodName)).get(String.class);
   }
 
-  private Config configFor(Class<?> testClass, String methodName,
-      final Map<String, String> configProperties) {
+  private Config configFor(
+      Class<?> testClass, String methodName, final Map<String, String> configProperties) {
     return configFor(testClass, methodName, configProperties, null);
   }
 
@@ -488,25 +496,30 @@ public class HierarchicalConfigurationStrategyTest {
     return configFor(testClass, methodName, globalConfig);
   }
 
-  private Config configFor(Class<?> testClass, String methodName,
-      Config.Implementation globalConfig) {
+  private Config configFor(
+      Class<?> testClass, String methodName, Config.Implementation globalConfig) {
     return configFor(testClass, methodName, new HashMap<>(), globalConfig);
   }
 
-  private Config configFor(Class<?> testClass, String methodName,
-      final Map<String, String> configProperties, Config.Implementation globalConfig) {
+  private Config configFor(
+      Class<?> testClass,
+      String methodName,
+      final Map<String, String> configProperties,
+      Config.Implementation globalConfig) {
     Method info = getMethod(testClass, methodName);
-    PackagePropertiesLoader packagePropertiesLoader = new PackagePropertiesLoader() {
-      @Override
-      InputStream getResourceAsStream(String resourceName) {
-        String properties = configProperties.get(resourceName);
-        return properties == null ? null : new ByteArrayInputStream(properties.getBytes(UTF_8));
-      }
-    };
+    PackagePropertiesLoader packagePropertiesLoader =
+        new PackagePropertiesLoader() {
+          @Override
+          InputStream getResourceAsStream(String resourceName) {
+            String properties = configProperties.get(resourceName);
+            return properties == null ? null : new ByteArrayInputStream(properties.getBytes(UTF_8));
+          }
+        };
     ConfigurationStrategy defaultConfigStrategy =
         new HierarchicalConfigurationStrategy(
-            new ConfigConfigurer(packagePropertiesLoader, () ->
-                globalConfig == null ? Config.Builder.defaults().build() : globalConfig));
+            new ConfigConfigurer(
+                packagePropertiesLoader,
+                () -> globalConfig == null ? Config.Builder.defaults().build() : globalConfig));
     Configuration config = defaultConfigStrategy.getConfig(testClass, info);
     return config.get(Config.class);
   }
@@ -559,13 +572,11 @@ public class HierarchicalConfigurationStrategyTest {
       assetDir = "test/assets")
   public static class Test1 {
     @Test
-    public void withoutAnnotation() throws Exception {
-    }
+    public void withoutAnnotation() throws Exception {}
 
     @Test
     @Config
-    public void withDefaultsAnnotation() throws Exception {
-    }
+    public void withDefaultsAnnotation() throws Exception {}
 
     @Test
     @Config(
@@ -585,13 +596,11 @@ public class HierarchicalConfigurationStrategyTest {
   @Ignore
   public static class Test2 {
     @Test
-    public void withoutAnnotation() throws Exception {
-    }
+    public void withoutAnnotation() throws Exception {}
 
     @Test
     @Config
-    public void withDefaultsAnnotation() throws Exception {
-    }
+    public void withDefaultsAnnotation() throws Exception {}
 
     @Test
     @Config(
@@ -610,26 +619,22 @@ public class HierarchicalConfigurationStrategyTest {
 
   @Ignore
   @Config(qualifiers = "from-subclass")
-  public static class Test1A extends Test1 {
-  }
+  public static class Test1A extends Test1 {}
 
   @Ignore
   @Config(qualifiers = "from-subclass")
-  public static class Test2A extends Test2 {
-  }
+  public static class Test2A extends Test2 {}
 
   @Ignore
   public static class Test1B extends Test1 {
     @Override
     @Test
-    public void withoutAnnotation() throws Exception {
-    }
+    public void withoutAnnotation() throws Exception {}
 
     @Override
     @Test
     @Config
-    public void withDefaultsAnnotation() throws Exception {
-    }
+    public void withDefaultsAnnotation() throws Exception {}
 
     @Override
     @Test
diff --git a/robolectric/src/test/java/org/robolectric/plugins/LooperModeConfigurerClassTest.java b/robolectric/src/test/java/org/robolectric/plugins/LooperModeConfigurerClassTest.java
index 960f82598..603b6f186 100644
--- a/robolectric/src/test/java/org/robolectric/plugins/LooperModeConfigurerClassTest.java
+++ b/robolectric/src/test/java/org/robolectric/plugins/LooperModeConfigurerClassTest.java
@@ -14,9 +14,7 @@ import org.robolectric.shadows.ShadowLegacyLooper;
 import org.robolectric.shadows.ShadowLooper;
 import org.robolectric.shadows.ShadowPausedLooper;
 
-/**
- * Unit tests for classes annotated with @LooperMode.
- */
+/** Unit tests for classes annotated with @LooperMode. */
 @RunWith(AndroidJUnit4.class)
 @LooperMode(Mode.PAUSED)
 public class LooperModeConfigurerClassTest {
diff --git a/robolectric/src/test/java/org/robolectric/plugins/LooperModeConfigurerTest.java b/robolectric/src/test/java/org/robolectric/plugins/LooperModeConfigurerTest.java
index 0f50bb334..bc0290f6b 100644
--- a/robolectric/src/test/java/org/robolectric/plugins/LooperModeConfigurerTest.java
+++ b/robolectric/src/test/java/org/robolectric/plugins/LooperModeConfigurerTest.java
@@ -8,9 +8,7 @@ import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import org.robolectric.annotation.LooperMode;
 
-/**
- * Unit tests for methods annotated with @LooperMode.
- */
+/** Unit tests for methods annotated with @LooperMode. */
 @RunWith(JUnit4.class)
 public class LooperModeConfigurerTest {
 
diff --git a/robolectric/src/test/java/org/robolectric/plugins/SdkCollectionTest.java b/robolectric/src/test/java/org/robolectric/plugins/SdkCollectionTest.java
index 65db19824..a7781f127 100644
--- a/robolectric/src/test/java/org/robolectric/plugins/SdkCollectionTest.java
+++ b/robolectric/src/test/java/org/robolectric/plugins/SdkCollectionTest.java
@@ -71,13 +71,14 @@ public class SdkCollectionTest {
   @Test
   public void getKnownSdks_shouldReturnAll() throws Exception {
     assertThat(sdkCollection.getKnownSdks())
-        .containsExactly(fakeSdk1234, fakeSdk1235, fakeSdk1236, fakeUnsupportedSdk1237).inOrder();
+        .containsExactly(fakeSdk1234, fakeSdk1235, fakeSdk1236, fakeUnsupportedSdk1237)
+        .inOrder();
   }
 
   @Test
   public void getSupportedSdks_shouldReturnOnlySupported() throws Exception {
     assertThat(sdkCollection.getSupportedSdks())
-        .containsExactly(fakeSdk1234, fakeSdk1235, fakeSdk1236).inOrder();
+        .containsExactly(fakeSdk1234, fakeSdk1235, fakeSdk1236)
+        .inOrder();
   }
-
-}
\ No newline at end of file
+}
diff --git a/robolectric/src/test/java/org/robolectric/plugins/config/LooperModeConfigurerPkgTest.java b/robolectric/src/test/java/org/robolectric/plugins/config/LooperModeConfigurerPkgTest.java
index b1acd529c..2ed04a7bf 100644
--- a/robolectric/src/test/java/org/robolectric/plugins/config/LooperModeConfigurerPkgTest.java
+++ b/robolectric/src/test/java/org/robolectric/plugins/config/LooperModeConfigurerPkgTest.java
@@ -9,9 +9,7 @@ import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.LooperMode.Mode;
 import org.robolectric.config.ConfigurationRegistry;
 
-/**
- * Unit tests for packages annotated with @LooperMode.
- */
+/** Unit tests for packages annotated with @LooperMode. */
 @RunWith(AndroidJUnit4.class)
 public class LooperModeConfigurerPkgTest {
 
diff --git a/robolectric/src/test/java/org/robolectric/plugins/config/SingleValueConfigurerTest.java b/robolectric/src/test/java/org/robolectric/plugins/config/SingleValueConfigurerTest.java
index bf9a7b49f..1a88e89ec 100644
--- a/robolectric/src/test/java/org/robolectric/plugins/config/SingleValueConfigurerTest.java
+++ b/robolectric/src/test/java/org/robolectric/plugins/config/SingleValueConfigurerTest.java
@@ -4,6 +4,7 @@ import static com.google.common.truth.Truth.assertThat;
 
 import java.util.Properties;
 import javax.annotation.Nonnull;
+import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -55,6 +56,32 @@ public final class SingleValueConfigurerTest {
     assertThat(reader.getConfigFor("foo")).isEqualTo(Value.OFF);
   }
 
+  @Test
+  public void testNonStandardCasing() {
+    String valueName = "valueConfig";
+    Properties props = new Properties();
+    props.setProperty(valueName, "oFF");
+    PackagePropertiesLoader ppl = new OverridePackagePropertiesLoader(props);
+    Properties systemProps = new Properties();
+    systemProps.setProperty(valueName, "On");
+    ValueConfigReader reader = new ValueConfigReader(systemProps, ppl, Value.ON);
+    assertThat(reader.propertyName()).isEqualTo(valueName);
+    assertThat(reader.defaultConfig()).isEqualTo(Value.ON);
+    assertThat(reader.getConfigFor("foo")).isEqualTo(Value.OFF);
+  }
+
+  @Test
+  public void testIllegalValueThrows() {
+    String valueName = "valueConfig";
+    Properties props = new Properties();
+    props.setProperty(valueName, "none");
+    PackagePropertiesLoader ppl = new OverridePackagePropertiesLoader(props);
+    Properties systemProps = new Properties();
+    systemProps.setProperty(valueName, "none");
+    ValueConfigReader reader = new ValueConfigReader(systemProps, ppl, Value.ON);
+    Assert.assertThrows(IllegalArgumentException.class, () -> reader.getConfigFor("foo"));
+  }
+
   @Test
   public void testReadingPropertyFileFlippedDefaultValue() {
     String valueName = "valueConfig";
diff --git a/robolectric/src/test/java/org/robolectric/res/DrawableResourceLoaderNoRunnerTest.java b/robolectric/src/test/java/org/robolectric/res/DrawableResourceLoaderNoRunnerTest.java
index e2ecc430b..3e8c1e171 100644
--- a/robolectric/src/test/java/org/robolectric/res/DrawableResourceLoaderNoRunnerTest.java
+++ b/robolectric/src/test/java/org/robolectric/res/DrawableResourceLoaderNoRunnerTest.java
@@ -33,6 +33,10 @@ public class DrawableResourceLoaderNoRunnerTest {
     DrawableResourceLoader testLoader = new DrawableResourceLoader(resourceTable);
     testLoader.findDrawableResources(resourcePath);
 
-    assertThat(resourceTable.getValue(new ResName("org.robolectric", "drawable", "foo"), new ResTable_config()).isFile()).isTrue();
+    assertThat(
+            resourceTable
+                .getValue(new ResName("org.robolectric", "drawable", "foo"), new ResTable_config())
+                .isFile())
+        .isTrue();
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/res/ResBundleTest.java b/robolectric/src/test/java/org/robolectric/res/ResBundleTest.java
index 0c4927cfa..b1feb4240 100644
--- a/robolectric/src/test/java/org/robolectric/res/ResBundleTest.java
+++ b/robolectric/src/test/java/org/robolectric/res/ResBundleTest.java
@@ -130,37 +130,36 @@ public class ResBundleTest {
 
   @Test
   public void shouldMatchQualifiersPerAndroidSpec() throws Exception {
-    assertEquals("en-port", asResMap(
-        "",
-        "en",
-        "fr-rCA",
+    assertEquals(
         "en-port",
-        "en-notouch-12key",
-        "port-ldpi",
-        "land-notouch-12key").pick(resName,
-        from("en-rGB-port-hdpi-notouch-12key-v25")).asString());
+        asResMap(
+                "",
+                "en",
+                "fr-rCA",
+                "en-port",
+                "en-notouch-12key",
+                "port-ldpi",
+                "land-notouch-12key")
+            .pick(resName, from("en-rGB-port-hdpi-notouch-12key-v25"))
+            .asString());
   }
 
   @Test
   public void shouldMatchQualifiersInSizeRange() throws Exception {
-    assertEquals("sw300dp-port", asResMap(
-        "",
-        "sw200dp",
-        "sw350dp-port",
+    assertEquals(
         "sw300dp-port",
-        "sw300dp").pick(resName,
-        from("sw320dp-port-v25")).asString());
+        asResMap("", "sw200dp", "sw350dp-port", "sw300dp-port", "sw300dp")
+            .pick(resName, from("sw320dp-port-v25"))
+            .asString());
   }
 
   @Test
   public void shouldPreferWidthOverHeight() throws Exception {
-    assertEquals("sw300dp-w200dp", asResMap(
-        "",
-        "sw200dp",
-        "sw200dp-w300dp",
+    assertEquals(
         "sw300dp-w200dp",
-        "w300dp").pick(resName,
-        from("sw320dp-w320dp-v25")).asString());
+        asResMap("", "sw200dp", "sw200dp-w300dp", "sw300dp-w200dp", "w300dp")
+            .pick(resName, from("sw320dp-w320dp-v25"))
+            .asString());
   }
 
   @Test
@@ -171,12 +170,18 @@ public class ResBundleTest {
     when(xmlContext.getConfig()).thenReturn(new ResTable_config());
     when(xmlContext.getPackageName()).thenReturn("org.robolectric");
 
-    TypedResource firstValue = new TypedResource<>("first_value", ResType.CHAR_SEQUENCE, xmlContext);
-    TypedResource secondValue = new TypedResource<>("second_value", ResType.CHAR_SEQUENCE, xmlContext);
+    TypedResource firstValue =
+        new TypedResource<>("first_value", ResType.CHAR_SEQUENCE, xmlContext);
+    TypedResource secondValue =
+        new TypedResource<>("second_value", ResType.CHAR_SEQUENCE, xmlContext);
     bundle.put(new ResName("org.robolectric", "string", "resource_name"), firstValue);
     bundle.put(new ResName("org.robolectric", "string", "resource_name"), secondValue);
 
-    assertThat(bundle.get(new ResName("org.robolectric", "string", "resource_name"), from("")).getData()).isEqualTo("first_value");
+    assertThat(
+            bundle
+                .get(new ResName("org.robolectric", "string", "resource_name"), from(""))
+                .getData())
+        .isEqualTo("first_value");
   }
 
   private ResBundle.ResMap asResMap(String... qualifierses) {
@@ -202,10 +207,9 @@ public class ResBundleTest {
 
   private static ResTable_config from(String qualifiers) {
     ResTable_config config = new ResTable_config();
-    if (!Strings.isNullOrEmpty(qualifiers) &&
-        !ConfigDescription.parse(qualifiers, config, false)) {
+    if (!Strings.isNullOrEmpty(qualifiers) && !ConfigDescription.parse(qualifiers, config, false)) {
       throw new IllegalArgumentException("Invalid qualifiers \"" + qualifiers + "\"");
     }
     return config;
   }
-}
\ No newline at end of file
+}
diff --git a/robolectric/src/test/java/org/robolectric/res/ResNameTest.java b/robolectric/src/test/java/org/robolectric/res/ResNameTest.java
index 7859bc2f4..c0c0ee84a 100644
--- a/robolectric/src/test/java/org/robolectric/res/ResNameTest.java
+++ b/robolectric/src/test/java/org/robolectric/res/ResNameTest.java
@@ -8,18 +8,25 @@ import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
 public class ResNameTest {
-  @Test public void shouldQualify() throws Exception {
-    assertThat(ResName.qualifyResourceName("some.package:type/name", null, null)).isEqualTo("some.package:type/name");
-    assertThat(ResName.qualifyResourceName("some.package:type/name", "default.package", "deftype")).isEqualTo("some.package:type/name");
+  @Test
+  public void shouldQualify() throws Exception {
+    assertThat(ResName.qualifyResourceName("some.package:type/name", null, null))
+        .isEqualTo("some.package:type/name");
+    assertThat(ResName.qualifyResourceName("some.package:type/name", "default.package", "deftype"))
+        .isEqualTo("some.package:type/name");
     assertThat(ResName.qualifyResourceName("*android:type/name", "default.package", "deftype"))
         .isEqualTo("android:type/name");
-    assertThat(ResName.qualifyResourceName("some.package:name", "default.package", "deftype")).isEqualTo("some.package:deftype/name");
-    assertThat(ResName.qualifyResourceName("type/name", "default.package", "deftype")).isEqualTo("default.package:type/name");
-    assertThat(ResName.qualifyResourceName("name", "default.package", "deftype")).isEqualTo("default.package:deftype/name");
+    assertThat(ResName.qualifyResourceName("some.package:name", "default.package", "deftype"))
+        .isEqualTo("some.package:deftype/name");
+    assertThat(ResName.qualifyResourceName("type/name", "default.package", "deftype"))
+        .isEqualTo("default.package:type/name");
+    assertThat(ResName.qualifyResourceName("name", "default.package", "deftype"))
+        .isEqualTo("default.package:deftype/name");
     assertThat(ResName.qualifyResourceName("someRawString", "default.package", null)).isNull();
   }
 
-  @Test public void shouldQualifyResNameFromString() throws Exception {
+  @Test
+  public void shouldQualifyResNameFromString() throws Exception {
     assertThat(ResName.qualifyResName("some.package:type/name", "default_package", "default_type"))
         .isEqualTo(new ResName("some.package", "type", "name"));
     assertThat(ResName.qualifyResName("some.package:name", "default_package", "default_type"))
@@ -40,14 +47,14 @@ public class ResNameTest {
 
   @Test
   public void qualifyFromFilePathShouldExtractResourceTypeAndNameFromQualifiedPath() {
-    final ResName actual = ResName.qualifyFromFilePath("some.package", "./res/drawable-hdpi/icon.png");
+    final ResName actual =
+        ResName.qualifyFromFilePath("some.package", "./res/drawable-hdpi/icon.png");
     assertThat(actual.getFullyQualifiedName()).isEqualTo("some.package:drawable/icon");
   }
 
   @Test
   public void hierarchicalNameHandlesWhiteSpace() {
-    String name = "TextAppearance.AppCompat.Widget.ActionMode.Subtitle\n" +
-        "    ";
+    String name = "TextAppearance.AppCompat.Widget.ActionMode.Subtitle\n" + "    ";
 
     ResName resName = new ResName("org.robolectric.example", "style", name);
     assertThat(resName.name).isEqualTo("TextAppearance.AppCompat.Widget.ActionMode.Subtitle");
@@ -57,8 +64,7 @@ public class ResNameTest {
 
   @Test
   public void simpleNameHandlesWhiteSpace() {
-    String name = "Subtitle\n" +
-        "    ";
+    String name = "Subtitle\n" + "    ";
 
     ResName resName = new ResName("org.robolectric.example", "style", name);
     assertThat(resName.name).isEqualTo("Subtitle");
@@ -68,8 +74,7 @@ public class ResNameTest {
 
   @Test
   public void fullyQualifiedNameHandlesWhiteSpace() {
-    String name = "android:style/TextAppearance.AppCompat.Widget.ActionMode.Subtitle\n" +
-        "    ";
+    String name = "android:style/TextAppearance.AppCompat.Widget.ActionMode.Subtitle\n" + "    ";
 
     ResName resName = new ResName(name);
     assertThat(resName.name).isEqualTo("TextAppearance.AppCompat.Widget.ActionMode.Subtitle");
diff --git a/robolectric/src/test/java/org/robolectric/res/ResourceParserTest.java b/robolectric/src/test/java/org/robolectric/res/ResourceParserTest.java
index 7b5d59ebe..45c4bf545 100644
--- a/robolectric/src/test/java/org/robolectric/res/ResourceParserTest.java
+++ b/robolectric/src/test/java/org/robolectric/res/ResourceParserTest.java
@@ -24,7 +24,8 @@ public class ResourceParserTest {
 
   @Test
   public void shouldLoadDrawableXmlResources() {
-    TypedResource value = resourceTable.getValue(new ResName("org.robolectric", "drawable", "rainbow"), config);
+    TypedResource value =
+        resourceTable.getValue(new ResName("org.robolectric", "drawable", "rainbow"), config);
     assertThat(value).isNotNull();
     assertThat(value.getResType()).isEqualTo(ResType.DRAWABLE);
     assertThat(value.isFile()).isTrue();
@@ -33,7 +34,8 @@ public class ResourceParserTest {
 
   @Test
   public void shouldLoadDrawableBitmapResources() {
-    TypedResource value = resourceTable.getValue(new ResName("org.robolectric", "drawable", "an_image"), config);
+    TypedResource value =
+        resourceTable.getValue(new ResName("org.robolectric", "drawable", "an_image"), config);
     assertThat(value).isNotNull();
     assertThat(value.getResType()).isEqualTo(ResType.DRAWABLE);
     assertThat(value.isFile()).isTrue();
@@ -42,7 +44,9 @@ public class ResourceParserTest {
 
   @Test
   public void shouldLoadDrawableBitmapResourcesDefinedByItemTag() {
-    TypedResource value = resourceTable.getValue(new ResName("org.robolectric", "drawable", "example_item_drawable"), config);
+    TypedResource value =
+        resourceTable.getValue(
+            new ResName("org.robolectric", "drawable", "example_item_drawable"), config);
     assertThat(value).isNotNull();
     assertThat(value.getResType()).isEqualTo(ResType.DRAWABLE);
     assertThat(value.isReference()).isTrue();
@@ -51,7 +55,9 @@ public class ResourceParserTest {
 
   @Test
   public void shouldLoadIdResourcesDefinedByItemTag() {
-    TypedResource value = resourceTable.getValue(new ResName("org.robolectric", "id", "id_declared_in_item_tag"), config);
+    TypedResource value =
+        resourceTable.getValue(
+            new ResName("org.robolectric", "id", "id_declared_in_item_tag"), config);
     assertThat(value).isNotNull();
     assertThat(value.getResType()).isEqualTo(ResType.CHAR_SEQUENCE);
     assertThat(value.isReference()).isFalse();
diff --git a/robolectric/src/test/java/org/robolectric/res/ResourceRemapperTest.java b/robolectric/src/test/java/org/robolectric/res/ResourceRemapperTest.java
index 4b0d4540d..42cd4966e 100644
--- a/robolectric/src/test/java/org/robolectric/res/ResourceRemapperTest.java
+++ b/robolectric/src/test/java/org/robolectric/res/ResourceRemapperTest.java
@@ -30,13 +30,16 @@ public class ResourceRemapperTest {
     assertThat(ApplicationRClass.string.string_one).isEqualTo(ThirdClass.string.string_one);
 
     // Resource identifiers that clash across two libraries should be remapped to different values.
-    assertThat(SecondClass.id.id_clash)
-        .isNotEqualTo(ThirdClass.id.another_id_clash);
+    assertThat(SecondClass.id.id_clash).isNotEqualTo(ThirdClass.id.another_id_clash);
 
     // Styleable arrays of values should be updated to match the remapped values.
-    assertThat(ThirdClass.styleable.SomeStyleable).isEqualTo(ApplicationRClass.styleable.SomeStyleable);
-    assertThat(SecondClass.styleable.SomeStyleable).isEqualTo(ApplicationRClass.styleable.SomeStyleable);
-    assertThat(ApplicationRClass.styleable.SomeStyleable).asList().containsExactly(ApplicationRClass.attr.attr_one, ApplicationRClass.attr.attr_two);
+    assertThat(ThirdClass.styleable.SomeStyleable)
+        .isEqualTo(ApplicationRClass.styleable.SomeStyleable);
+    assertThat(SecondClass.styleable.SomeStyleable)
+        .isEqualTo(ApplicationRClass.styleable.SomeStyleable);
+    assertThat(ApplicationRClass.styleable.SomeStyleable)
+        .asList()
+        .containsExactly(ApplicationRClass.attr.attr_one, ApplicationRClass.attr.attr_two);
   }
 
   @Test
@@ -55,11 +58,15 @@ public class ResourceRemapperTest {
     assertThat(allIds.add(ThirdClass.raw.raw_one)).isTrue();
     assertThat(allIds.add(ThirdClass.raw.raw_two)).isTrue();
 
-    assertThat(ResourceIds.getTypeIdentifier(ApplicationRClass.string.string_one)).isEqualTo(ResourceIds.getTypeIdentifier(ApplicationRClass.string.string_two));
-    assertThat(ResourceIds.getTypeIdentifier(ApplicationRClass.string.string_one)).isEqualTo(ResourceIds.getTypeIdentifier(SecondClass.string.string_three));
+    assertThat(ResourceIds.getTypeIdentifier(ApplicationRClass.string.string_one))
+        .isEqualTo(ResourceIds.getTypeIdentifier(ApplicationRClass.string.string_two));
+    assertThat(ResourceIds.getTypeIdentifier(ApplicationRClass.string.string_one))
+        .isEqualTo(ResourceIds.getTypeIdentifier(SecondClass.string.string_three));
 
-    assertThat(ResourceIds.getTypeIdentifier(ApplicationRClass.string.string_two)).isNotEqualTo(ResourceIds.getTypeIdentifier(SecondClass.integer.integer_two));
-    assertThat(ResourceIds.getTypeIdentifier(ThirdClass.raw.raw_two)).isNotEqualTo(ResourceIds.getTypeIdentifier(SecondClass.integer.integer_two));
+    assertThat(ResourceIds.getTypeIdentifier(ApplicationRClass.string.string_two))
+        .isNotEqualTo(ResourceIds.getTypeIdentifier(SecondClass.integer.integer_two));
+    assertThat(ResourceIds.getTypeIdentifier(ThirdClass.raw.raw_two))
+        .isNotEqualTo(ResourceIds.getTypeIdentifier(SecondClass.integer.integer_two));
   }
 
   public static final class FinalRClass {
@@ -81,7 +88,8 @@ public class ResourceRemapperTest {
     }
 
     public static final class styleable {
-      public static final int[] SomeStyleable = new int[]{ApplicationRClass.attr.attr_one, ApplicationRClass.attr.attr_two};
+      public static final int[] SomeStyleable =
+          new int[] {ApplicationRClass.attr.attr_one, ApplicationRClass.attr.attr_two};
       public static final int SomeStyleable_offsetX = 0;
       public static final int SomeStyleable_offsetY = 1;
     }
@@ -108,7 +116,8 @@ public class ResourceRemapperTest {
     }
 
     public static final class styleable {
-      public static final int[] SomeStyleable = new int[]{SecondClass.attr.attr_one, SecondClass.attr.attr_two};
+      public static final int[] SomeStyleable =
+          new int[] {SecondClass.attr.attr_one, SecondClass.attr.attr_two};
       public static final int SomeStyleable_offsetX = 0;
       public static final int SomeStyleable_offsetY = 1;
     }
@@ -134,10 +143,10 @@ public class ResourceRemapperTest {
     }
 
     public static final class styleable {
-      public static final int[] SomeStyleable = new int[]{ThirdClass.attr.attr_one, ThirdClass.attr.attr_two};
+      public static final int[] SomeStyleable =
+          new int[] {ThirdClass.attr.attr_one, ThirdClass.attr.attr_two};
       public static final int SomeStyleable_offsetX = 0;
       public static final int SomeStyleable_offsetY = 1;
     }
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/res/ResourceTableFactoryTest.java b/robolectric/src/test/java/org/robolectric/res/ResourceTableFactoryTest.java
index f1584f68a..b97f9f75b 100644
--- a/robolectric/src/test/java/org/robolectric/res/ResourceTableFactoryTest.java
+++ b/robolectric/src/test/java/org/robolectric/res/ResourceTableFactoryTest.java
@@ -18,31 +18,39 @@ public class ResourceTableFactoryTest {
   @Before
   public void setUp() throws Exception {
     ResourceTableFactory resourceTableFactory = new ResourceTableFactory();
-    appResourceTable = resourceTableFactory.newResourceTable("org.robolectric",
-        testResources());
+    appResourceTable = resourceTableFactory.newResourceTable("org.robolectric", testResources());
 
     systemResourceTable = resourceTableFactory.newFrameworkResourceTable(systemResources());
   }
 
   @Test
   public void shouldHandleMipmapReferences() {
-    assertThat(appResourceTable.getResourceId(new ResName("org.robolectric:mipmap/mipmap_reference"))).isEqualTo(R.mipmap.mipmap_reference);
+    assertThat(
+            appResourceTable.getResourceId(new ResName("org.robolectric:mipmap/mipmap_reference")))
+        .isEqualTo(R.mipmap.mipmap_reference);
   }
 
   @Test
   public void shouldHandleStyleable() throws Exception {
-    assertThat(appResourceTable.getResourceId(new ResName("org.robolectric:id/burritos"))).isEqualTo(R.id.burritos);
-    assertThat(appResourceTable.getResourceId(new ResName("org.robolectric:styleable/TitleBar_textStyle"))).isEqualTo(0);
+    assertThat(appResourceTable.getResourceId(new ResName("org.robolectric:id/burritos")))
+        .isEqualTo(R.id.burritos);
+    assertThat(
+            appResourceTable.getResourceId(
+                new ResName("org.robolectric:styleable/TitleBar_textStyle")))
+        .isEqualTo(0);
   }
 
   @Test
   public void shouldPrefixAllSystemResourcesWithAndroid() throws Exception {
-    assertThat(systemResourceTable.getResourceId(new ResName("android:id/text1"))).isEqualTo(android.R.id.text1);
+    assertThat(systemResourceTable.getResourceId(new ResName("android:id/text1")))
+        .isEqualTo(android.R.id.text1);
   }
 
   @Test
   public void shouldRetainPackageNameForFullyQualifiedQueries() throws Exception {
-    assertThat(systemResourceTable.getResName(android.R.id.text1).getFullyQualifiedName()).isEqualTo("android:id/text1");
-    assertThat(appResourceTable.getResName(R.id.burritos).getFullyQualifiedName()).isEqualTo("org.robolectric:id/burritos");
+    assertThat(systemResourceTable.getResName(android.R.id.text1).getFullyQualifiedName())
+        .isEqualTo("android:id/text1");
+    assertThat(appResourceTable.getResName(R.id.burritos).getFullyQualifiedName())
+        .isEqualTo("org.robolectric:id/burritos");
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/res/ResourceTestUtil.java b/robolectric/src/test/java/org/robolectric/res/ResourceTestUtil.java
index aaa289c2d..fa3866ab3 100644
--- a/robolectric/src/test/java/org/robolectric/res/ResourceTestUtil.java
+++ b/robolectric/src/test/java/org/robolectric/res/ResourceTestUtil.java
@@ -20,16 +20,17 @@ public class ResourceTestUtil {
   @SuppressWarnings("rawtypes")
   static String stringify(ResourceTable resourceTable) {
     final HashMap<String, List<TypedResource>> map = new HashMap<>();
-    resourceTable.receive(new ResourceTable.Visitor() {
-      @Override
-      public void visit(ResName key, Iterable<TypedResource> values) {
-        List<TypedResource> v = new ArrayList<>();
-        for (TypedResource value : values) {
-          v.add(value);
-        }
-        map.put(key.getFullyQualifiedName(), v);
-      }
-    });
+    resourceTable.receive(
+        new ResourceTable.Visitor() {
+          @Override
+          public void visit(ResName key, Iterable<TypedResource> values) {
+            List<TypedResource> v = new ArrayList<>();
+            for (TypedResource value : values) {
+              v.add(value);
+            }
+            map.put(key.getFullyQualifiedName(), v);
+          }
+        });
     StringBuilder buf = new StringBuilder();
     TreeSet<String> keys = new TreeSet<>(map.keySet());
     for (String key : keys) {
@@ -54,17 +55,26 @@ public class ResourceTestUtil {
         } else if (data instanceof StyleData) {
           StyleData styleData = (StyleData) data;
           final Map<String, String> attrs = new TreeMap<>();
-          styleData.visit(new StyleData.Visitor() {
-            @Override
-            public void visit(AttributeResource attributeResource) {
-              attrs.put(attributeResource.resName.getFullyQualifiedName(), attributeResource.value);
-            }
-          });
+          styleData.visit(
+              new StyleData.Visitor() {
+                @Override
+                public void visit(AttributeResource attributeResource) {
+                  attrs.put(
+                      attributeResource.resName.getFullyQualifiedName(), attributeResource.value);
+                }
+              });
           data = data.toString() + "^" + styleData.getParent() + " " + attrs;
         }
-        buf.append("  ").append(data).append(" {").append(typedResource.getResType())
-            .append("/").append(typedResource.getConfig()).append(": ")
-            .append(shortContext(typedResource)).append("}").append("\n");
+        buf.append("  ")
+            .append(data)
+            .append(" {")
+            .append(typedResource.getResType())
+            .append("/")
+            .append(typedResource.getConfig())
+            .append(": ")
+            .append(shortContext(typedResource))
+            .append("}")
+            .append("\n");
       }
     }
     return buf.toString();
diff --git a/robolectric/src/test/java/org/robolectric/res/StringResourcesTest.java b/robolectric/src/test/java/org/robolectric/res/StringResourcesTest.java
index c0b10f780..5977fb668 100644
--- a/robolectric/src/test/java/org/robolectric/res/StringResourcesTest.java
+++ b/robolectric/src/test/java/org/robolectric/res/StringResourcesTest.java
@@ -18,11 +18,14 @@ public class StringResourcesTest {
     assertThat(StringResources.escape("\"This'll work\"")).isEqualTo("This'll work");
     assertThat(StringResources.escape("This\\'ll also work")).isEqualTo("This'll also work");
 
-    assertThat(StringResources.escape("This is a \\\"good string\\\".")).isEqualTo("This is a \"good string\".");
+    assertThat(StringResources.escape("This is a \\\"good string\\\"."))
+        .isEqualTo("This is a \"good string\".");
     assertThat(StringResources.escape("This is a \"bad string with unescaped double quotes\"."))
         .isEqualTo("This is a bad string with unescaped double quotes.");
 
-    assertThat(StringResources.escape("Text with escaped backslash followed by an \\\\\"unescaped double quote."))
+    assertThat(
+            StringResources.escape(
+                "Text with escaped backslash followed by an \\\\\"unescaped double quote."))
         .isEqualTo("Text with escaped backslash followed by an \\unescaped double quote.");
   }
 
@@ -44,14 +47,18 @@ public class StringResourcesTest {
   @Test
   public void shouldTrimWhitespace() {
     assertThat(StringResources.processStringResources("    ")).isEmpty();
-    assertThat(StringResources.processStringResources("Trailingwhitespace    ")).isEqualTo("Trailingwhitespace");
-    assertThat(StringResources.processStringResources("Leadingwhitespace    ")).isEqualTo("Leadingwhitespace");
+    assertThat(StringResources.processStringResources("Trailingwhitespace    "))
+        .isEqualTo("Trailingwhitespace");
+    assertThat(StringResources.processStringResources("Leadingwhitespace    "))
+        .isEqualTo("Leadingwhitespace");
   }
 
   @Test
   public void shouldCollapseInternalWhiteSpaces() {
-    assertThat(StringResources.processStringResources("Whitespace     in     the          middle")).isEqualTo("Whitespace in the middle");
-    assertThat(StringResources.processStringResources("Some\n\n\n\nNewlines")).isEqualTo("Some Newlines");
+    assertThat(StringResources.processStringResources("Whitespace     in     the          middle"))
+        .isEqualTo("Whitespace in the middle");
+    assertThat(StringResources.processStringResources("Some\n\n\n\nNewlines"))
+        .isEqualTo("Some Newlines");
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/AssociationInfoBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/AssociationInfoBuilderTest.java
index 1f22537e6..1ebb258fb 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/AssociationInfoBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/AssociationInfoBuilderTest.java
@@ -66,7 +66,8 @@ public final class AssociationInfoBuilderTest {
     assertThat(info.isSelfManaged()).isEqualTo(SELF_MANAGED);
     assertThat(info.isNotifyOnDeviceNearby()).isEqualTo(NOTIFY_ON_DEVICE_NEARBY);
     assertThat(info.getTimeApprovedMs()).isEqualTo(APPROVED_MS);
-    assertThat(info.getLastTimeConnectedMs()).isEqualTo(LAST_TIME_CONNECTED_MS);
+    assertThat((long) ReflectionHelpers.callInstanceMethod(info, "getLastTimeConnectedMs"))
+        .isEqualTo(LAST_TIME_CONNECTED_MS);
 
     if (ReflectionHelpers.hasField(AssociationInfo.class, "mAssociatedDevice")) {
       Object associatedDevice = ReflectionHelpers.callInstanceMethod(info, "getAssociatedDevice");
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ConverterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ConverterTest.java
index 4907e2c3f..3927f0473 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ConverterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ConverterTest.java
@@ -61,4 +61,4 @@ public class ConverterTest {
         new TypedResource<>(" 100 ", ResType.INTEGER, xmlContext);
     assertThat(Converter.getConverter(ResType.INTEGER).asInt(resource)).isEqualTo(100);
   }
-}
\ No newline at end of file
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/GnssStatusBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/GnssStatusBuilderTest.java
index 8a7a79442..448390343 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/GnssStatusBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/GnssStatusBuilderTest.java
@@ -72,7 +72,6 @@ public class GnssStatusBuilderTest {
             .setHasAlmanac(HAS_ALMANAC)
             .setUsedInFix(USED_IN_FIX);
 
-
     List<GnssSatelliteInfo> satelliteInfos = new ArrayList<>();
     satelliteInfos.add(infoBuilder.setSvid(SVID).build());
     satelliteInfos.add(infoBuilder.setSvid(SVID + 1).build());
@@ -111,20 +110,21 @@ public class GnssStatusBuilderTest {
   @Config(minSdk = O)
   public void addSatellite_carrierFrequency() {
     GnssSatelliteInfo.Builder infoBuilder =
-    GnssSatelliteInfo.builder()
-        .setConstellation(GnssStatus.CONSTELLATION_GPS)
-        .setCn0DbHz(CN0)
-        .setElevation(ELEVATION)
-        .setAzimuth(AZIMUTH)
-        .setHasEphemeris(HAS_EPHEMERIS)
-        .setHasAlmanac(HAS_ALMANAC)
-        .setUsedInFix(USED_IN_FIX);
-
-    GnssStatus status = GnssStatusBuilder.create()
-        .addSatellite(infoBuilder.setSvid(SVID).build())
-        .addSatellite(infoBuilder.setSvid(SVID + 1).setCarrierFrequencyHz(null).build())
-        .addSatellite(infoBuilder.setSvid(SVID - 1).setCarrierFrequencyHz(1575.42f).build())
-        .build();
+        GnssSatelliteInfo.builder()
+            .setConstellation(GnssStatus.CONSTELLATION_GPS)
+            .setCn0DbHz(CN0)
+            .setElevation(ELEVATION)
+            .setAzimuth(AZIMUTH)
+            .setHasEphemeris(HAS_EPHEMERIS)
+            .setHasAlmanac(HAS_ALMANAC)
+            .setUsedInFix(USED_IN_FIX);
+
+    GnssStatus status =
+        GnssStatusBuilder.create()
+            .addSatellite(infoBuilder.setSvid(SVID).build())
+            .addSatellite(infoBuilder.setSvid(SVID + 1).setCarrierFrequencyHz(null).build())
+            .addSatellite(infoBuilder.setSvid(SVID - 1).setCarrierFrequencyHz(1575.42f).build())
+            .build();
 
     assertThat(status.getSatelliteCount()).isEqualTo(3);
     assertThat(status.hasCarrierFrequencyHz(0)).isFalse();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/LegacyManifestParserTest.java b/robolectric/src/test/java/org/robolectric/shadows/LegacyManifestParserTest.java
deleted file mode 100644
index 7307d9b10..000000000
--- a/robolectric/src/test/java/org/robolectric/shadows/LegacyManifestParserTest.java
+++ /dev/null
@@ -1,78 +0,0 @@
-package org.robolectric.shadows;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.robolectric.util.TestUtil.resourceFile;
-
-import android.content.pm.PackageParser.Package;
-import android.content.pm.PackageParser.Permission;
-import android.content.pm.PermissionInfo;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import java.util.List;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.manifest.AndroidManifest;
-
-/** Unit test for {@link org.robolectric.shadows.LegacyManifestParser}. */
-@RunWith(AndroidJUnit4.class)
-public class LegacyManifestParserTest {
-
-  private AndroidManifest androidManifest;
-
-  @Before
-  public void setUp() {
-    androidManifest =
-        new AndroidManifest(
-            resourceFile("TestAndroidManifestWithProtectionLevels.xml"),
-            resourceFile("res"),
-            resourceFile("assets"));
-  }
-
-  @Test
-  public void createPackage_signatureOrPrivileged_shouldParseCorrectFlags() {
-    Package parsedPackage = LegacyManifestParser.createPackage(androidManifest);
-    int protectionLevel =
-        getPermissionInfo(parsedPackage.permissions, "signature_or_privileged_permission")
-            .protectionLevel;
-    assertThat(protectionLevel)
-        .isEqualTo(PermissionInfo.PROTECTION_SIGNATURE | PermissionInfo.PROTECTION_FLAG_PRIVILEGED);
-  }
-
-  @Test
-  public void createPackage_protectionLevelNotDeclated_shouldParseToNormal() {
-    Package parsedPackage = LegacyManifestParser.createPackage(androidManifest);
-    int protectionLevel =
-        getPermissionInfo(parsedPackage.permissions, "permission_with_minimal_fields")
-            .protectionLevel;
-    assertThat(protectionLevel).isEqualTo(PermissionInfo.PROTECTION_NORMAL);
-  }
-
-  @Test
-  public void createPackage_protectionLevelVendorOrOem_shouldParseCorrectFlags() {
-    Package parsedPackage = LegacyManifestParser.createPackage(androidManifest);
-    int protectionLevel =
-        getPermissionInfo(parsedPackage.permissions, "vendor_privileged_or_oem_permission")
-            .protectionLevel;
-    assertThat(protectionLevel)
-        .isEqualTo(
-            PermissionInfo.PROTECTION_FLAG_VENDOR_PRIVILEGED | PermissionInfo.PROTECTION_FLAG_OEM);
-  }
-
-  @Test
-  public void createPackage_protectionLevelDangerous_shouldParseCorrectFlags() {
-    Package parsedPackage = LegacyManifestParser.createPackage(androidManifest);
-    int protectionLevel =
-        getPermissionInfo(parsedPackage.permissions, "dangerous_permission").protectionLevel;
-    assertThat(protectionLevel).isEqualTo(PermissionInfo.PROTECTION_DANGEROUS);
-  }
-
-  private PermissionInfo getPermissionInfo(List<Permission> permissions, String name) {
-    name = "org.robolectric." + name;
-    for (Permission permission : permissions) {
-      if (name.equals(permission.info.name)) {
-        return permission.info;
-      }
-    }
-    return null;
-  }
-}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/MediaCodecInfoBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/MediaCodecInfoBuilderTest.java
index 8e60f35c5..201a00b6b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/MediaCodecInfoBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/MediaCodecInfoBuilderTest.java
@@ -7,6 +7,7 @@ import static android.media.MediaFormat.MIMETYPE_VIDEO_VP9;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.Q;
 import static com.google.common.truth.Truth.assertThat;
+import static org.robolectric.RuntimeEnvironment.getApiLevel;
 
 import android.media.MediaCodecInfo;
 import android.media.MediaCodecInfo.CodecCapabilities;
@@ -17,8 +18,8 @@ import android.util.Range;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
+import org.robolectric.versioning.AndroidVersions.U;
 
 /** Tests for {@link MediaCodecInfoBuilder}. */
 @RunWith(AndroidJUnit4.class)
@@ -30,7 +31,6 @@ public class MediaCodecInfoBuilderTest {
 
   private static final int WIDTH = 1920;
   private static final int HEIGHT = 1080;
-  private static final Range<Integer> DEFAULT_SUPPORTED_VIDEO_SIZE_RANGE = new Range<>(2, 896);
 
   private static final MediaFormat AAC_MEDIA_FORMAT =
       createMediaFormat(
@@ -130,9 +130,9 @@ public class MediaCodecInfoBuilderTest {
     assertThat(codecCapabilities.getAudioCapabilities()).isNull();
     assertThat(codecCapabilities.getVideoCapabilities()).isNotNull();
     assertThat(codecCapabilities.getVideoCapabilities().getSupportedWidths())
-        .isEqualTo(DEFAULT_SUPPORTED_VIDEO_SIZE_RANGE);
+        .isEqualTo(getDefaultSupportedVideoSizeRange());
     assertThat(codecCapabilities.getVideoCapabilities().getSupportedHeights())
-        .isEqualTo(DEFAULT_SUPPORTED_VIDEO_SIZE_RANGE);
+        .isEqualTo(getDefaultSupportedVideoSizeRange());
     assertThat(codecCapabilities.getEncoderCapabilities()).isNotNull();
     assertThat(codecCapabilities.isFeatureSupported(CodecCapabilities.FEATURE_IntraRefresh))
         .isTrue();
@@ -364,7 +364,7 @@ public class MediaCodecInfoBuilderTest {
 
   @Test
   public void mediaCodecInfo_preQ() {
-    if (RuntimeEnvironment.getApiLevel() <= M) {
+    if (getApiLevel() <= M) {
       MediaCodecList.getCodecCount();
     }
     CodecCapabilities codecCapabilities =
@@ -429,4 +429,14 @@ public class MediaCodecInfoBuilderTest {
     }
     return mediaFormat;
   }
+
+  private static Range<Integer> getDefaultSupportedVideoSizeRange() {
+    if (getApiLevel() <= U.SDK_INT) {
+      return new Range<>(2, 896);
+    } else {
+      // Intentionally adjusted in android V see
+      // https://android-review.googlesource.com/3002925
+      return new Range<>(1, 896);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/SQLiteCursorTest.java b/robolectric/src/test/java/org/robolectric/shadows/SQLiteCursorTest.java
index c648eb30b..95e936341 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/SQLiteCursorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/SQLiteCursorTest.java
@@ -23,14 +23,15 @@ public class SQLiteCursorTest {
   public void setUp() throws Exception {
     database = SQLiteDatabase.create(null);
 
-    database.execSQL("CREATE TABLE table_name(" +
-        "id INTEGER PRIMARY KEY, " +
-        "name VARCHAR(255), " +
-        "long_value BIGINT," +
-        "float_value REAL," +
-        "double_value DOUBLE, " +
-        "blob_value BINARY, " +
-        "clob_value CLOB );");
+    database.execSQL(
+        "CREATE TABLE table_name("
+            + "id INTEGER PRIMARY KEY, "
+            + "name VARCHAR(255), "
+            + "long_value BIGINT,"
+            + "float_value REAL,"
+            + "double_value DOUBLE, "
+            + "blob_value BINARY, "
+            + "clob_value CLOB );");
 
     addPeople();
     cursor = createCursor();
@@ -205,7 +206,7 @@ public class SQLiteCursorTest {
     String sql = "UPDATE table_name set blob_value=? where id=1234";
     byte[] byteData = sql.getBytes(UTF_8);
 
-    database.execSQL(sql, new Object[]{byteData});
+    database.execSQL(sql, new Object[] {byteData});
 
     assertThat(cursor.moveToFirst()).isTrue();
 
@@ -222,7 +223,7 @@ public class SQLiteCursorTest {
     String sql = "UPDATE table_name set clob_value=? where id=1234";
     String s = "Don't CLOBber my data, please. Thank you.";
 
-    database.execSQL(sql, new Object[]{s});
+    database.execSQL(sql, new Object[] {s});
 
     assertThat(cursor.moveToFirst()).isTrue();
 
@@ -275,7 +276,7 @@ public class SQLiteCursorTest {
     String sql = "UPDATE table_name set blob_value=? where id=1234";
     byte[] byteData = sql.getBytes(UTF_8);
 
-    database.execSQL(sql, new Object[]{byteData});
+    database.execSQL(sql, new Object[] {byteData});
 
     assertThat(cursor.moveToFirst()).isTrue();
 
@@ -287,7 +288,7 @@ public class SQLiteCursorTest {
     String sql = "UPDATE table_name set blob_value=? where id=1234";
     byte[] byteData = sql.getBytes(UTF_8);
 
-    database.execSQL(sql, new Object[]{byteData});
+    database.execSQL(sql, new Object[] {byteData});
 
     assertThat(cursor.moveToFirst()).isTrue();
 
@@ -431,7 +432,7 @@ public class SQLiteCursorTest {
     String sql = "UPDATE table_name set blob_value=? where id=1234";
     byte[] byteData = sql.getBytes(UTF_8);
 
-    database.execSQL(sql, new Object[]{byteData});
+    database.execSQL(sql, new Object[] {byteData});
 
     assertThat(cursor.moveToFirst()).isTrue();
     assertThat(cursor.getType(5)).isEqualTo(Cursor.FIELD_TYPE_BLOB);
@@ -475,7 +476,7 @@ public class SQLiteCursorTest {
   }
 
   private Cursor createCursor() {
-    String sql ="SELECT * FROM table_name;";
+    String sql = "SELECT * FROM table_name;";
     Cursor cursor = database.rawQuery(sql, null);
     assertThat(cursor).isInstanceOf(SQLiteCursor.class);
     return cursor;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/SQLiteOpenHelperTest.java b/robolectric/src/test/java/org/robolectric/shadows/SQLiteOpenHelperTest.java
index 63e8f214c..a9da2908d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/SQLiteOpenHelperTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/SQLiteOpenHelperTest.java
@@ -144,10 +144,13 @@ public class SQLiteOpenHelperTest {
   }
 
   private void setupTable(SQLiteDatabase db, String table) {
-    db.execSQL("CREATE TABLE " + table + " (" +
-        "id INTEGER PRIMARY KEY AUTOINCREMENT, " +
-        "testVal INTEGER DEFAULT 0" +
-        ");");
+    db.execSQL(
+        "CREATE TABLE "
+            + table
+            + " ("
+            + "id INTEGER PRIMARY KEY AUTOINCREMENT, "
+            + "testVal INTEGER DEFAULT 0"
+            + ");");
   }
 
   private void insertData(SQLiteDatabase db, String table, int[] values) {
@@ -169,12 +172,12 @@ public class SQLiteOpenHelperTest {
     final String TABLE_NAME1 = "fart", TABLE_NAME2 = "fart2";
     SQLiteDatabase db1 = helper.getWritableDatabase();
     setupTable(db1, TABLE_NAME1);
-    insertData(db1, TABLE_NAME1, new int[]{1, 2});
+    insertData(db1, TABLE_NAME1, new int[] {1, 2});
     TestOpenHelper helper2 =
         new TestOpenHelper(ApplicationProvider.getApplicationContext(), "path2", null, 1);
     SQLiteDatabase db2 = helper2.getWritableDatabase();
     setupTable(db2, TABLE_NAME2);
-    insertData(db2, TABLE_NAME2, new int[]{4, 5, 6});
+    insertData(db2, TABLE_NAME2, new int[] {4, 5, 6});
     verifyData(db1, TABLE_NAME1, 2);
     verifyData(db2, TABLE_NAME2, 3);
     helper2.close();
@@ -189,8 +192,8 @@ public class SQLiteOpenHelperTest {
     SQLiteDatabase db2 = helper2.getWritableDatabase();
     setupTable(db1, TABLE_NAME1);
     setupTable(db2, TABLE_NAME2);
-    insertData(db1, TABLE_NAME1, new int[]{1, 2});
-    insertData(db2, TABLE_NAME2, new int[]{4, 5, 6});
+    insertData(db1, TABLE_NAME1, new int[] {1, 2});
+    insertData(db2, TABLE_NAME2, new int[] {4, 5, 6});
     verifyData(db1, TABLE_NAME1, 2);
     verifyData(db2, TABLE_NAME2, 3);
     db1.close();
@@ -213,7 +216,7 @@ public class SQLiteOpenHelperTest {
     final String TABLE_NAME1 = "fart";
     SQLiteDatabase db1 = helper.getWritableDatabase();
     setupTable(db1, TABLE_NAME1);
-    insertData(db1, TABLE_NAME1, new int[]{1, 2});
+    insertData(db1, TABLE_NAME1, new int[] {1, 2});
     verifyData(db1, TABLE_NAME1, 2);
     db1.close();
     db1 = helper.getWritableDatabase();
@@ -248,8 +251,8 @@ public class SQLiteOpenHelperTest {
 
     @Override
     public void onCreate(SQLiteDatabase database) {
-        onCreateCalled = true;
-      }
+      onCreateCalled = true;
+    }
 
     @Override
     public void onUpgrade(SQLiteDatabase database, int oldVersion, int newVersion) {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/SQLiteQueryBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/SQLiteQueryBuilderTest.java
index fe683b309..a316ec1f2 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/SQLiteQueryBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/SQLiteQueryBuilderTest.java
@@ -18,7 +18,7 @@ public class SQLiteQueryBuilderTest {
   private static final String TABLE_NAME = "sqlBuilderTest";
   private static final String COL_VALUE = "valueCol";
   private static final String COL_GROUP = "groupCol";
-  
+
   private SQLiteDatabase database;
   private SQLiteQueryBuilder builder;
 
@@ -28,10 +28,8 @@ public class SQLiteQueryBuilderTest {
   public void setUp() throws Exception {
     database = SQLiteDatabase.create(null);
 
-    database.execSQL("create table " + TABLE_NAME + " ("
-        + COL_VALUE + " TEXT, "
-        + COL_GROUP + " INTEGER"
-        + ")");
+    database.execSQL(
+        "create table " + TABLE_NAME + " (" + COL_VALUE + " TEXT, " + COL_GROUP + " INTEGER" + ")");
 
     ContentValues values = new ContentValues();
     values.put(COL_VALUE, "record1");
@@ -93,5 +91,4 @@ public class SQLiteQueryBuilderTest {
     assertThat(cursor.getCount()).isEqualTo(1);
     cursor.close();
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAbsSpinnerAdapterViewBehaviorTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAbsSpinnerAdapterViewBehaviorTest.java
index 082f723c9..4e7360aa5 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAbsSpinnerAdapterViewBehaviorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAbsSpinnerAdapterViewBehaviorTest.java
@@ -8,7 +8,8 @@ import org.junit.runner.RunWith;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowAbsSpinnerAdapterViewBehaviorTest extends AdapterViewBehavior {
-  @Override public AdapterView createAdapterView() {
+  @Override
+  public AdapterView createAdapterView() {
     return new Gallery(ApplicationProvider.getApplicationContext());
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAbsSpinnerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAbsSpinnerTest.java
index 9b1b09d7c..1c1474f7f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAbsSpinnerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAbsSpinnerTest.java
@@ -34,7 +34,7 @@ public class ShadowAbsSpinnerTest {
     spinner = new Spinner(activity);
     ((ViewGroup) activity.findViewById(android.R.id.content)).addView(spinner);
     shadowSpinner = shadowOf(spinner);
-    String [] testItems = {"foo", "bar"};
+    String[] testItems = {"foo", "bar"};
     arrayAdapter = new MyArrayAdapter(context, testItems);
   }
 
@@ -44,7 +44,7 @@ public class ShadowAbsSpinnerTest {
   }
 
   @Test
-  public void getSelectedItemShouldReturnCorrectValue(){
+  public void getSelectedItemShouldReturnCorrectValue() {
     spinner.setAdapter(arrayAdapter);
     spinner.setSelection(0);
     assertThat((String) spinner.getSelectedItem()).isEqualTo("foo");
@@ -56,7 +56,7 @@ public class ShadowAbsSpinnerTest {
   }
 
   @Test
-  public void getSelectedItemShouldReturnNull_NoAdapterSet(){
+  public void getSelectedItemShouldReturnNull_NoAdapterSet() {
     assertThat(spinner.getSelectedItem()).isNull();
   }
 
@@ -127,7 +127,8 @@ public class ShadowAbsSpinnerTest {
       super(context, android.R.layout.simple_spinner_item, testItems);
     }
 
-    @Override public View getView(int position, View convertView, ViewGroup parent) {
+    @Override
+    public View getView(int position, View convertView, ViewGroup parent) {
       return new View(getContext());
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccountManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccountManagerTest.java
index 72277bbef..6538f1382 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccountManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccountManagerTest.java
@@ -27,17 +27,20 @@ import java.util.Arrays;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowAccountManagerTest {
   private AccountManager am;
   private Activity activity;
+  private Context appContext;
 
   @Before
   public void setUp() throws Exception {
     am = AccountManager.get(ApplicationProvider.getApplicationContext());
     activity = new Activity();
+    appContext = ApplicationProvider.getApplicationContext();
   }
 
   @Test
@@ -147,8 +150,9 @@ public class ShadowAccountManagerTest {
 
     try {
       am.addAccountExplicitly(null, null, null);
-      fail("An illegal argument exception should have been thrown when trying to add a null"
-               + " account");
+      fail(
+          "An illegal argument exception should have been thrown when trying to add a null"
+              + " account");
     } catch (IllegalArgumentException iae) {
       // NOP
     }
@@ -280,7 +284,8 @@ public class ShadowAccountManagerTest {
   }
 
   @Test
-  public void testBlockingGetAuthToken() throws AuthenticatorException, OperationCanceledException, IOException {
+  public void testBlockingGetAuthToken()
+      throws AuthenticatorException, OperationCanceledException, IOException {
     Account account = new Account("name", "type");
     shadowOf(am).addAccount(account);
 
@@ -292,15 +297,17 @@ public class ShadowAccountManagerTest {
 
     try {
       am.blockingGetAuthToken(null, "token_type_1", false);
-      fail("blockingGetAuthToken() should throw an illegal argument exception if the account is"
-               + " null");
+      fail(
+          "blockingGetAuthToken() should throw an illegal argument exception if the account is"
+              + " null");
     } catch (IllegalArgumentException iae) {
       // Expected
     }
     try {
       am.blockingGetAuthToken(account, null, false);
-      fail("blockingGetAuthToken() should throw an illegal argument exception if the auth token"
-               + " type is null");
+      fail(
+          "blockingGetAuthToken() should throw an illegal argument exception if the auth token"
+              + " type is null");
     } catch (IllegalArgumentException iae) {
       // Expected
     }
@@ -338,8 +345,10 @@ public class ShadowAccountManagerTest {
     Account account = new Account("name", "type");
     shadowOf(am).addAccount(account);
 
-    TestAccountManagerCallback<Boolean> testAccountManagerCallback = new TestAccountManagerCallback<>();
-    AccountManagerFuture<Boolean> future = am.removeAccount(account, testAccountManagerCallback, null);
+    TestAccountManagerCallback<Boolean> testAccountManagerCallback =
+        new TestAccountManagerCallback<>();
+    AccountManagerFuture<Boolean> future =
+        am.removeAccount(account, testAccountManagerCallback, null);
     assertThat(future.getResult()).isTrue();
     assertThat(am.getAccountsByType("type")).isEmpty();
 
@@ -748,7 +757,8 @@ public class ShadowAccountManagerTest {
   }
 
   @Test
-  public void addAccount_whenSchedulerPaused_shouldCallCallbackAfterSchedulerUnpaused() throws Exception {
+  public void addAccount_whenSchedulerPaused_shouldCallCallbackAfterSchedulerUnpaused()
+      throws Exception {
     shadowMainLooper().pause();
     shadowOf(am).addAuthenticator("google.com");
 
@@ -773,9 +783,10 @@ public class ShadowAccountManagerTest {
         am.addAccount("unknown_account_type", "auth_token_type", null, null, activity, null, null);
     try {
       future.getResult();
-      fail("addAccount() should throw an authenticator exception if no authenticator was"
-               + " registered for this account type");
-    } catch(AuthenticatorException e) {
+      fail(
+          "addAccount() should throw an authenticator exception if no authenticator was"
+              + " registered for this account type");
+    } catch (AuthenticatorException e) {
       // Expected
     }
     assertThat(future.isDone()).isTrue();
@@ -823,7 +834,8 @@ public class ShadowAccountManagerTest {
     try {
       futureResult.getResult();
       fail("should have thrown");
-    } catch (AuthenticatorException expected) { }
+    } catch (AuthenticatorException expected) {
+    }
   }
 
   @Test
@@ -851,16 +863,15 @@ public class ShadowAccountManagerTest {
     am.setAuthToken(account, "auth_token_type", "token1");
 
     TestAccountManagerCallback<Bundle> callback = new TestAccountManagerCallback<>();
-    AccountManagerFuture<Bundle> future = am.getAuthToken(account,
-        "auth_token_type",
-        new Bundle(),
-        activity,
-        callback,
-        new Handler());
+    AccountManagerFuture<Bundle> future =
+        am.getAuthToken(
+            account, "auth_token_type", new Bundle(), activity, callback, new Handler());
 
     assertThat(future.isDone()).isTrue();
-    assertThat(future.getResult().getString(AccountManager.KEY_ACCOUNT_NAME)).isEqualTo(account.name);
-    assertThat(future.getResult().getString(AccountManager.KEY_ACCOUNT_TYPE)).isEqualTo(account.type);
+    assertThat(future.getResult().getString(AccountManager.KEY_ACCOUNT_NAME))
+        .isEqualTo(account.name);
+    assertThat(future.getResult().getString(AccountManager.KEY_ACCOUNT_TYPE))
+        .isEqualTo(account.type);
     assertThat(future.getResult().getString(AccountManager.KEY_AUTHTOKEN)).isEqualTo("token1");
 
     shadowMainLooper().idle();
@@ -874,12 +885,9 @@ public class ShadowAccountManagerTest {
     shadowOf(am).addAuthenticator("google.com");
 
     TestAccountManagerCallback<Bundle> callback = new TestAccountManagerCallback<>();
-    AccountManagerFuture<Bundle> future = am.getAuthToken(account,
-        "auth_token_type",
-        new Bundle(),
-        activity,
-        callback,
-        new Handler());
+    AccountManagerFuture<Bundle> future =
+        am.getAuthToken(
+            account, "auth_token_type", new Bundle(), activity, callback, new Handler());
 
     assertThat(future.isDone()).isTrue();
     assertThat(future.getResult().getString(AccountManager.KEY_ACCOUNT_NAME))
@@ -954,7 +962,7 @@ public class ShadowAccountManagerTest {
   public void getHasFeatures_returnsTrueWhenAllFeaturesSatisfied() throws Exception {
     Account account = new Account("name", "google.com");
     shadowOf(am).addAccount(account);
-    shadowOf(am).setFeatures(account, new String[] { "FEATURE_1", "FEATURE_2" });
+    shadowOf(am).setFeatures(account, new String[] {"FEATURE_1", "FEATURE_2"});
 
     TestAccountManagerCallback<Boolean> callback = new TestAccountManagerCallback<>();
     AccountManagerFuture<Boolean> future =
@@ -971,7 +979,7 @@ public class ShadowAccountManagerTest {
   public void getHasFeatures_returnsFalseWhenAllFeaturesNotSatisfied() throws Exception {
     Account account = new Account("name", "google.com");
     shadowOf(am).addAccount(account);
-    shadowOf(am).setFeatures(account, new String[] { "FEATURE_1" });
+    shadowOf(am).setFeatures(account, new String[] {"FEATURE_1"});
 
     TestAccountManagerCallback<Boolean> callback = new TestAccountManagerCallback<>();
     AccountManagerFuture<Boolean> future =
@@ -993,7 +1001,7 @@ public class ShadowAccountManagerTest {
 
     Account accountWithCorrectTypeButNotFeatures = new Account("account_2", "google.com");
     shadowOf(am).addAccount(accountWithCorrectTypeButNotFeatures);
-    shadowOf(am).setFeatures(accountWithCorrectTypeButNotFeatures, new String[] { "FEATURE_1" });
+    shadowOf(am).setFeatures(accountWithCorrectTypeButNotFeatures, new String[] {"FEATURE_1"});
 
     Account accountWithCorrectTypeButEmptyFeatures = new Account("account_3", "google.com");
     shadowOf(am).addAccount(accountWithCorrectTypeButEmptyFeatures);
@@ -1021,18 +1029,17 @@ public class ShadowAccountManagerTest {
 
     Account accountWithCorrectTypeAndFeatures = new Account("account_1", "google.com");
     shadowOf(am).addAccount(accountWithCorrectTypeAndFeatures);
-    shadowOf(am).setFeatures(
-        accountWithCorrectTypeAndFeatures, new String[] { "FEATURE_1", "FEATURE_2" });
+    shadowOf(am)
+        .setFeatures(accountWithCorrectTypeAndFeatures, new String[] {"FEATURE_1", "FEATURE_2"});
 
     Account accountWithCorrectTypeButNotFeatures = new Account("account_2", "google.com");
     shadowOf(am).addAccount(accountWithCorrectTypeButNotFeatures);
-    shadowOf(am).setFeatures(accountWithCorrectTypeButNotFeatures, new String[] { "FEATURE_1" });
+    shadowOf(am).setFeatures(accountWithCorrectTypeButNotFeatures, new String[] {"FEATURE_1"});
 
     Account accountWithCorrectFeaturesButNotType = new Account("account_3", "facebook.com");
     shadowOf(am).addAccount(accountWithCorrectFeaturesButNotType);
-    shadowOf(am).setFeatures(
-        accountWithCorrectFeaturesButNotType, new String[] { "FEATURE_1", "FEATURE_2" });
-
+    shadowOf(am)
+        .setFeatures(accountWithCorrectFeaturesButNotType, new String[] {"FEATURE_1", "FEATURE_2"});
 
     TestAccountManagerCallback<Account[]> callback = new TestAccountManagerCallback<>();
 
@@ -1040,7 +1047,8 @@ public class ShadowAccountManagerTest {
         am.getAccountsByTypeAndFeatures("google.com", null, callback, new Handler());
 
     assertThat(future.isDone()).isTrue();
-    assertThat(future.getResult()).asList()
+    assertThat(future.getResult())
+        .asList()
         .containsExactly(accountWithCorrectTypeAndFeatures, accountWithCorrectTypeButNotFeatures);
 
     shadowMainLooper().idle();
@@ -1125,4 +1133,31 @@ public class ShadowAccountManagerTest {
       return accountManagerFuture.getResult();
     }
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void accountManager_activityContextEnabled_differentInstancesRetrieveAccounts() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      AccountManager applicationAccountManager = appContext.getSystemService(AccountManager.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      AccountManager activityAccountManager = activity.getSystemService(AccountManager.class);
+
+      assertThat(applicationAccountManager).isNotSameInstanceAs(activityAccountManager);
+
+      Account[] applicationAccounts =
+          applicationAccountManager.getAccountsByType("com.example.account_type");
+      Account[] activityAccounts =
+          activityAccountManager.getAccountsByType("com.example.account_type");
+
+      assertThat(activityAccounts).isEqualTo(applicationAccounts);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityGroupTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityGroupTest.java
index 31b5c186f..d0021b371 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityGroupTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityGroupTest.java
@@ -14,9 +14,9 @@ public class ShadowActivityGroupTest {
 
   @Test
   public void getCurrentActivity_shouldReturnTheProvidedCurrentActivity() {
-  ActivityGroup activityGroup = new ActivityGroup();
-  Activity activity = new Activity();
-  shadowOf(activityGroup).setCurrentActivity(activity);
+    ActivityGroup activityGroup = new ActivityGroup();
+    Activity activity = new Activity();
+    shadowOf(activityGroup).setCurrentActivity(activity);
 
     assertThat(activityGroup.getCurrentActivity()).isSameInstanceAs(activity);
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityManagerTest.java
index fb1709160..ccdf1b069 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityManagerTest.java
@@ -15,6 +15,7 @@ import static org.robolectric.Shadows.shadowOf;
 
 import android.app.ActivityManager;
 import android.app.ActivityManager.AppTask;
+import android.app.ActivityManager.RecentTaskInfo;
 import android.app.Application;
 import android.app.ApplicationExitInfo;
 import android.content.ComponentName;
@@ -101,6 +102,25 @@ public class ShadowActivityManagerTest {
     assertThat(activityManager.getAppTasks()).containsExactly(task1, task2);
   }
 
+  @Test
+  public void testRecentTasks_shouldReturnTaskList() {
+    RecentTaskInfo taskInfo1 = new RecentTaskInfo();
+    taskInfo1.id = 123;
+    RecentTaskInfo taskInfo2 = new RecentTaskInfo();
+    taskInfo1.id = 234;
+    RecentTaskInfo taskInfo3 = new RecentTaskInfo();
+    taskInfo1.id = 345;
+
+    assertThat(activityManager.getRecentTasks(Integer.MAX_VALUE, 0)).isEmpty();
+    shadowActivityManager.setRecentTasks(Lists.newArrayList(taskInfo1, taskInfo2, taskInfo3));
+    assertThat(activityManager.getRecentTasks(2, 0))
+        .containsExactly(taskInfo1, taskInfo2)
+        .inOrder();
+    assertThat(activityManager.getRecentTasks(Integer.MAX_VALUE, 0))
+        .containsExactly(taskInfo1, taskInfo2, taskInfo3)
+        .inOrder();
+  }
+
   @Test
   public void getRunningAppProcesses_shouldReturnProcessList() {
     final ActivityManager.RunningAppProcessInfo process1 =
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityTest.java
index f9b136da7..aff6272ba 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityTest.java
@@ -599,6 +599,28 @@ public class ShadowActivityTest {
     }
   }
 
+  public static final class ShowWhenLockedActivity extends Activity {}
+
+  public static final class DoNotShowWhenLockedActivity extends Activity {}
+
+  @Test
+  @Config(minSdk = O_MR1)
+  public void createActivity_showWhenLockedEnabled_returnsTrueForShowWhenLocked() {
+    try (ActivityController<ShowWhenLockedActivity> controller =
+        Robolectric.buildActivity(ShowWhenLockedActivity.class)) {
+      assertThat(shadowOf(controller.get()).getShowWhenLocked()).isTrue();
+    }
+  }
+
+  @Test
+  @Config(minSdk = O_MR1)
+  public void createActivity_showWhenLockedDisabled_returnsFalseForShowWhenLocked() {
+    try (ActivityController<DoNotShowWhenLockedActivity> controller =
+        Robolectric.buildActivity(DoNotShowWhenLockedActivity.class)) {
+      assertThat(shadowOf(controller.get()).getShowWhenLocked()).isFalse();
+    }
+  }
+
   @Test // unclear what the correct behavior should be here...
   public void shouldPopulateWindowDecorViewWithMergeLayoutContents() {
     try (ActivityController<Activity> controller = Robolectric.buildActivity(Activity.class)) {
@@ -1501,6 +1523,18 @@ public class ShadowActivityTest {
     }
   }
 
+  @Test
+  public void buildActivity_abstractActivityClass_throwsRuntimeException() {
+    Throwable throwable =
+        assertThrows(
+            RuntimeException.class,
+            () -> {
+              Robolectric.buildActivity(AbstractTestActivity.class, null);
+            });
+    assertThat(throwable.getMessage())
+        .isEqualTo("buildActivity must be called with non-abstract class");
+  }
+
   @Test
   @Config(minSdk = Q)
   public void callOnGetDirectActions_succeeds() {
@@ -1777,6 +1811,9 @@ public class ShadowActivityTest {
     }
   }
 
+  /** Test Activity for abstract checking scenario. */
+  abstract static class AbstractTestActivity extends Activity {}
+
   /** Activity for testing */
   public static class TestActivityWithAnotherTheme
       extends org.robolectric.shadows.testing.TestActivity {}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAlertDialogTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAlertDialogTest.java
index f8a907f6a..454f7a845 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAlertDialogTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAlertDialogTest.java
@@ -264,7 +264,6 @@ public class ShadowAlertDialogTest {
 
     shadowAlertDialog.clickOnItem(1);
     assertThat(listener.transcript).containsExactly("clicked on 1");
-
   }
 
   @Test
@@ -280,11 +279,12 @@ public class ShadowAlertDialogTest {
   @Test
   public void shouldNotExplodeWhenNestingAlerts() {
     final Activity activity = Robolectric.buildActivity(Activity.class).create().get();
-    final AlertDialog nestedDialog = new AlertDialog.Builder(activity)
-        .setTitle("Dialog 2")
-        .setMessage("Another dialog")
-        .setPositiveButton("OK", null)
-        .create();
+    final AlertDialog nestedDialog =
+        new AlertDialog.Builder(activity)
+            .setTitle("Dialog 2")
+            .setMessage("Another dialog")
+            .setPositiveButton("OK", null)
+            .create();
 
     final AlertDialog dialog =
         new AlertDialog.Builder(activity)
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAnimationSetTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAnimationSetTest.java
index c23a27fb1..c5328ef7c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAnimationSetTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAnimationSetTest.java
@@ -18,7 +18,8 @@ public class ShadowAnimationSetTest {
   final Animation.AnimationListener moveListener = mock(Animation.AnimationListener.class);
   final Animation.AnimationListener spinListener = mock(Animation.AnimationListener.class);
 
-  @Test @Ignore("Needs additional work")
+  @Test
+  @Ignore("Needs additional work")
   public void start_shouldRunAnimation() {
     final AnimationSet set = new AnimationSet(true);
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java
index 74e52f562..5cb24b077 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java
@@ -237,6 +237,19 @@ public class ShadowAppOpsManagerTest {
     verifyNoMoreInteractions(callback);
   }
 
+  @Test
+  @Config(minSdk = VERSION_CODES.M)
+  public void startStopWatchingModeUid() {
+    OnOpChangedListener callback = mock(OnOpChangedListener.class);
+    appOps.startWatchingMode(OPSTR_FINE_LOCATION, PACKAGE_NAME1, callback);
+    appOps.setUidMode(OP_FINE_LOCATION, UID_1, MODE_ERRORED);
+    verify(callback).onOpChanged(OPSTR_FINE_LOCATION, null);
+
+    appOps.stopWatchingMode(callback);
+    appOps.setUidMode(OP_FINE_LOCATION, UID_1, MODE_ALLOWED);
+    verifyNoMoreInteractions(callback);
+  }
+
   @Test
   public void noteOp() {
     assertThat(appOps.noteOp(OP_GPS, UID_1, PACKAGE_NAME1)).isEqualTo(MODE_ALLOWED);
@@ -670,6 +683,37 @@ public class ShadowAppOpsManagerTest {
         .isTrue();
   }
 
+  @Test
+  @Config(minSdk = VERSION_CODES.P)
+  public void checkOpNoThrowString_noModeSetForUid_shouldReturnModeAllowed() {
+    assertThat(appOps.checkOpNoThrow(OPSTR_GPS, UID_1, null)).isEqualTo(MODE_ALLOWED);
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.P)
+  public void setUidMode_withModeDefault_checkOpNoThrowString_shouldReturnModeDefault() {
+    ReflectionHelpers.callInstanceMethod(
+        appOps,
+        "setUidMode",
+        ClassParameter.from(int.class, OP_GPS),
+        ClassParameter.from(int.class, UID_1),
+        ClassParameter.from(int.class, MODE_DEFAULT));
+    assertThat(appOps.checkOpNoThrow(OPSTR_GPS, UID_1, null)).isEqualTo(MODE_DEFAULT);
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.M)
+  public void checkOpNoThrow_noModeSetForUid_shouldReturnModeAllowed() {
+    assertThat(appOps.checkOpNoThrow(/* op= */ 2, UID_1, null)).isEqualTo(MODE_ALLOWED);
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.M)
+  public void setUidMode_withModeDefault_checkOpNoThrow_shouldReturnModeDefault() {
+    appOps.setUidMode(/* op= */ 2, UID_1, MODE_DEFAULT);
+    assertThat(appOps.checkOpNoThrow(/* op= */ 2, UID_1, null)).isEqualTo(MODE_DEFAULT);
+  }
+
   /** Assert that the results contain the expected op codes. */
   private void assertOps(List<PackageOps> pkgOps, Integer... expectedOps) {
     Set<Integer> actualOps = new HashSet<>();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowArrayAdapterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowArrayAdapterTest.java
index 4578b6dbf..f2c0feff9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowArrayAdapterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowArrayAdapterTest.java
@@ -24,7 +24,8 @@ public class ShadowArrayAdapterTest {
   private ArrayAdapter<Integer> arrayAdapter;
   private Application context;
 
-  @Before public void setUp() throws Exception {
+  @Before
+  public void setUp() throws Exception {
     List<Integer> list = new ArrayList<>();
     list.add(1);
     list.add(2);
@@ -63,16 +64,16 @@ public class ShadowArrayAdapterTest {
     ArrayAdapter<String> arrayAdapter =
         new ArrayAdapter<>(context, R.id.title, new String[] {"first value"});
 
-    //this assertion may look a little backwards since R.id.title is labeled
-    //textViewResourceId in the constructor parameter list, but the output is correct.
+    // this assertion may look a little backwards since R.id.title is labeled
+    // textViewResourceId in the constructor parameter list, but the output is correct.
     assertThat(Shadows.shadowOf(arrayAdapter).getResourceId()).isEqualTo(R.id.title);
     assertThat(Shadows.shadowOf(arrayAdapter).getTextViewResourceId()).isNotEqualTo(R.id.title);
     assertThat(Shadows.shadowOf(arrayAdapter).getTextViewResourceId()).isEqualTo(0);
 
     ArrayAdapter<String> arrayAdapter2 = new ArrayAdapter<>(context, R.id.title);
 
-    //this assertion may look a little backwards since R.id.title is labeled
-    //textViewResourceId in the constructor parameter list, but the output is correct.
+    // this assertion may look a little backwards since R.id.title is labeled
+    // textViewResourceId in the constructor parameter list, but the output is correct.
     assertThat(Shadows.shadowOf(arrayAdapter2).getResourceId()).isEqualTo(R.id.title);
     assertThat(Shadows.shadowOf(arrayAdapter2).getTextViewResourceId()).isNotEqualTo(R.id.title);
     assertThat(Shadows.shadowOf(arrayAdapter2).getTextViewResourceId()).isEqualTo(0);
@@ -80,8 +81,8 @@ public class ShadowArrayAdapterTest {
     ArrayAdapter<String> arrayAdapter3 =
         new ArrayAdapter<>(context, R.id.title, Collections.singletonList("first value"));
 
-    //this assertion may look a little backwards since R.id.title is labeled
-    //textViewResourceId in the constructor parameter list, but the output is correct.
+    // this assertion may look a little backwards since R.id.title is labeled
+    // textViewResourceId in the constructor parameter list, but the output is correct.
     assertThat(Shadows.shadowOf(arrayAdapter3).getResourceId()).isEqualTo(R.id.title);
     assertThat(Shadows.shadowOf(arrayAdapter3).getTextViewResourceId()).isNotEqualTo(R.id.title);
     assertThat(Shadows.shadowOf(arrayAdapter3).getTextViewResourceId()).isEqualTo(0);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAssetManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAssetManagerTest.java
index dce72fd29..1f80a7385 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAssetManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAssetManagerTest.java
@@ -24,8 +24,7 @@ import org.robolectric.Robolectric;
 @RunWith(AndroidJUnit4.class)
 public class ShadowAssetManagerTest {
 
-  @Rule
-  public ExpectedException expectedException = ExpectedException.none();
+  @Rule public ExpectedException expectedException = ExpectedException.none();
 
   private AssetManager assetManager;
   private Resources resources;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java
index 0d9d0fcbd..5b2bb532d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java
@@ -17,6 +17,7 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.content.Context;
 import android.media.AudioAttributes;
 import android.media.AudioDeviceCallback;
@@ -42,6 +43,7 @@ import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -1538,6 +1540,58 @@ public class ShadowAudioManagerTest {
     verify(callback).onAudioDevicesAdded(new AudioDeviceInfo[] {outputDevice});
   }
 
+  @Test
+  @Config(minSdk = O)
+  public void audioManager_activityContextEnabled_applicationInstanceIsNotSameAsActivityInstance() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    try {
+      AudioManager applicationAudioManager = appContext.getSystemService(AudioManager.class);
+      Activity activity = Robolectric.setupActivity(Activity.class);
+      AudioManager activityAudioManager = activity.getSystemService(AudioManager.class);
+      assertThat(applicationAudioManager).isNotSameInstanceAs(activityAudioManager);
+    } finally {
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
+
+  @Test
+  @Config(minSdk = O)
+  public void audioManager_activityContextEnabled_activityInstanceIsSameAsActivityInstance() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    try {
+      Activity activity = Robolectric.setupActivity(Activity.class);
+      AudioManager activityAudioManager = activity.getSystemService(AudioManager.class);
+      AudioManager anotherActivityAudioManager = activity.getSystemService(AudioManager.class);
+      assertThat(anotherActivityAudioManager).isSameInstanceAs(activityAudioManager);
+    } finally {
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
+
+  @Test
+  @Config(minSdk = O)
+  public void audioManager_activityContextEnabled_differentInstancesChangesAffectEachOther() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    try {
+      AudioManager applicationAudioManager = appContext.getSystemService(AudioManager.class);
+      Activity activity = Robolectric.setupActivity(Activity.class);
+      AudioManager activityAudioManager = activity.getSystemService(AudioManager.class);
+
+      activityAudioManager.setMode(AudioManager.MODE_RINGTONE);
+      assertThat(activityAudioManager.getMode()).isEqualTo(AudioManager.MODE_RINGTONE);
+      assertThat(applicationAudioManager.getMode()).isEqualTo(AudioManager.MODE_RINGTONE);
+
+      applicationAudioManager.setMode(AudioManager.MODE_NORMAL);
+      assertThat(activityAudioManager.getMode()).isEqualTo(AudioManager.MODE_NORMAL);
+      assertThat(applicationAudioManager.getMode()).isEqualTo(AudioManager.MODE_NORMAL);
+    } finally {
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
+
   private static AudioDeviceInfo createAudioDevice(int type) throws ReflectiveOperationException {
     AudioDeviceInfo info = Shadow.newInstanceOf(AudioDeviceInfo.class);
     Field portField = AudioDeviceInfo.class.getDeclaredField("mPort");
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioRecordTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioRecordTest.java
index 242cf4858..7ed0c9251 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioRecordTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioRecordTest.java
@@ -135,7 +135,7 @@ public class ShadowAudioRecordTest {
 
     audioRecord.read(new byte[100], 0, 100);
 
-    verify(source).readInByteArray(any(byte[].class), eq(0), eq(100), /* isBlocking=*/ eq(true));
+    verify(source).readInByteArray(any(byte[].class), eq(0), eq(100), /* isBlocking= */ eq(true));
     verifyNoMoreInteractions(source);
   }
 
@@ -149,7 +149,7 @@ public class ShadowAudioRecordTest {
 
     audioRecord.read(new byte[100], 0, 100, AudioRecord.READ_BLOCKING);
 
-    verify(source).readInByteArray(any(byte[].class), eq(0), eq(100), /* isBlocking=*/ eq(true));
+    verify(source).readInByteArray(any(byte[].class), eq(0), eq(100), /* isBlocking= */ eq(true));
     verifyNoMoreInteractions(source);
   }
 
@@ -163,7 +163,7 @@ public class ShadowAudioRecordTest {
 
     audioRecord.read(new byte[100], 0, 100, AudioRecord.READ_NON_BLOCKING);
 
-    verify(source).readInByteArray(any(byte[].class), eq(0), eq(100), /* isBlocking=*/ eq(false));
+    verify(source).readInByteArray(any(byte[].class), eq(0), eq(100), /* isBlocking= */ eq(false));
     verifyNoMoreInteractions(source);
   }
 
@@ -193,7 +193,7 @@ public class ShadowAudioRecordTest {
 
     audioRecord.read(new short[100], 0, 100);
 
-    verify(source).readInShortArray(any(short[].class), eq(0), eq(100), /* isBlocking=*/ eq(true));
+    verify(source).readInShortArray(any(short[].class), eq(0), eq(100), /* isBlocking= */ eq(true));
     verifyNoMoreInteractions(source);
   }
 
@@ -207,7 +207,7 @@ public class ShadowAudioRecordTest {
 
     audioRecord.read(new short[100], 0, 100, AudioRecord.READ_BLOCKING);
 
-    verify(source).readInShortArray(any(short[].class), eq(0), eq(100), /* isBlocking=*/ eq(true));
+    verify(source).readInShortArray(any(short[].class), eq(0), eq(100), /* isBlocking= */ eq(true));
     verifyNoMoreInteractions(source);
   }
 
@@ -221,7 +221,8 @@ public class ShadowAudioRecordTest {
 
     audioRecord.read(new short[100], 0, 100, AudioRecord.READ_NON_BLOCKING);
 
-    verify(source).readInShortArray(any(short[].class), eq(0), eq(100), /* isBlocking=*/ eq(false));
+    verify(source)
+        .readInShortArray(any(short[].class), eq(0), eq(100), /* isBlocking= */ eq(false));
     verifyNoMoreInteractions(source);
   }
 
@@ -256,7 +257,7 @@ public class ShadowAudioRecordTest {
 
     audioRecord.read(new float[100], 0, 100, AudioRecord.READ_BLOCKING);
 
-    verify(source).readInFloatArray(any(float[].class), eq(0), eq(100), /* isBlocking=*/ eq(true));
+    verify(source).readInFloatArray(any(float[].class), eq(0), eq(100), /* isBlocking= */ eq(true));
     verifyNoMoreInteractions(source);
   }
 
@@ -276,7 +277,8 @@ public class ShadowAudioRecordTest {
 
     audioRecord.read(new float[100], 0, 100, AudioRecord.READ_NON_BLOCKING);
 
-    verify(source).readInFloatArray(any(float[].class), eq(0), eq(100), /* isBlocking=*/ eq(false));
+    verify(source)
+        .readInFloatArray(any(float[].class), eq(0), eq(100), /* isBlocking= */ eq(false));
     verifyNoMoreInteractions(source);
   }
 
@@ -307,7 +309,7 @@ public class ShadowAudioRecordTest {
 
     audioRecord.read(ByteBuffer.allocate(100), 100);
 
-    verify(source).readInDirectBuffer(any(ByteBuffer.class), eq(100), /* isBlocking=*/ eq(true));
+    verify(source).readInDirectBuffer(any(ByteBuffer.class), eq(100), /* isBlocking= */ eq(true));
     verifyNoMoreInteractions(source);
   }
 
@@ -321,7 +323,7 @@ public class ShadowAudioRecordTest {
 
     audioRecord.read(ByteBuffer.allocate(100), 100, AudioRecord.READ_BLOCKING);
 
-    verify(source).readInDirectBuffer(any(ByteBuffer.class), eq(100), /* isBlocking=*/ eq(true));
+    verify(source).readInDirectBuffer(any(ByteBuffer.class), eq(100), /* isBlocking= */ eq(true));
     verifyNoMoreInteractions(source);
   }
 
@@ -335,7 +337,7 @@ public class ShadowAudioRecordTest {
 
     audioRecord.read(ByteBuffer.allocate(100), 100, AudioRecord.READ_NON_BLOCKING);
 
-    verify(source).readInDirectBuffer(any(ByteBuffer.class), eq(100), /* isBlocking=*/ eq(false));
+    verify(source).readInDirectBuffer(any(ByteBuffer.class), eq(100), /* isBlocking= */ eq(false));
     verifyNoMoreInteractions(source);
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapDrawableTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapDrawableTest.java
index 19e92ae2b..2bb381b58 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapDrawableTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapDrawableTest.java
@@ -93,5 +93,4 @@ public class ShadowBitmapDrawableTest {
                 ApplicationProvider.getApplicationContext().getResources(), (Bitmap) null))
         .isNotNull();
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapRegionDecoderTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapRegionDecoderTest.java
index 172cf5eac..dd1ce1a95 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapRegionDecoderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapRegionDecoderTest.java
@@ -30,7 +30,9 @@ public class ShadowBitmapRegionDecoderTest {
 
   @Test
   public void testNewInstance() throws Exception {
-    assertThat(BitmapRegionDecoder.newInstance(ByteStreams.toByteArray(getImageInputStream()), 0, 0, false))
+    assertThat(
+            BitmapRegionDecoder.newInstance(
+                ByteStreams.toByteArray(getImageInputStream()), 0, 0, false))
         .isNotNull();
     try (AssetFileDescriptor afd = getImageFd()) {
       assertThat(BitmapRegionDecoder.newInstance(afd.getFileDescriptor(), false)).isNotNull();
@@ -38,8 +40,7 @@ public class ShadowBitmapRegionDecoderTest {
     try (InputStream inputStream = getImageInputStream()) {
       assertThat(BitmapRegionDecoder.newInstance(inputStream, false)).isNotNull();
     }
-    assertThat(BitmapRegionDecoder.newInstance(getGeneratedImageFile(), false))
-        .isNotNull();
+    assertThat(BitmapRegionDecoder.newInstance(getGeneratedImageFile(), false)).isNotNull();
   }
 
   @Test
@@ -51,12 +52,12 @@ public class ShadowBitmapRegionDecoderTest {
 
   @Test
   public void testDecodeRegionReturnsExpectedSize() throws IOException {
-    BitmapRegionDecoder bitmapRegionDecoder = BitmapRegionDecoder.newInstance(getImageInputStream(), false);
-    Bitmap bitmap = bitmapRegionDecoder.decodeRegion(new Rect(10, 20, 110, 220), new BitmapFactory.Options());
-    assertThat(bitmap.getWidth())
-        .isEqualTo(100);
-    assertThat(bitmap.getHeight())
-        .isEqualTo(200);
+    BitmapRegionDecoder bitmapRegionDecoder =
+        BitmapRegionDecoder.newInstance(getImageInputStream(), false);
+    Bitmap bitmap =
+        bitmapRegionDecoder.decodeRegion(new Rect(10, 20, 110, 220), new BitmapFactory.Options());
+    assertThat(bitmap.getWidth()).isEqualTo(100);
+    assertThat(bitmap.getHeight()).isEqualTo(200);
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapTest.java
index ceeb7ef06..bd76ad8b9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapTest.java
@@ -125,10 +125,11 @@ public class ShadowBitmapTest {
 
   @Test
   public void shouldCreateBitmapWithColors() {
-    int[] colors = new int[] {
-        Color.parseColor("#ff0000"), Color.parseColor("#00ff00"), Color.parseColor("#0000ff"),
-        Color.parseColor("#990000"), Color.parseColor("#009900"), Color.parseColor("#000099")
-    };
+    int[] colors =
+        new int[] {
+          Color.parseColor("#ff0000"), Color.parseColor("#00ff00"), Color.parseColor("#0000ff"),
+          Color.parseColor("#990000"), Color.parseColor("#009900"), Color.parseColor("#000099")
+        };
     Bitmap bitmap = Bitmap.createBitmap(colors, 3, 2, Bitmap.Config.ARGB_8888);
     assertThat(bitmap.getWidth()).isEqualTo(3);
     assertThat(bitmap.getHeight()).isEqualTo(2);
@@ -232,8 +233,7 @@ public class ShadowBitmapTest {
   @Test
   public void visualize_shouldReturnDescription() {
     Bitmap bitmap = create("Bitmap One");
-    assertThat(ShadowBitmap.visualize(bitmap))
-        .isEqualTo("Bitmap One");
+    assertThat(ShadowBitmap.visualize(bitmap)).isEqualTo("Bitmap One");
   }
 
   @Test
@@ -270,18 +270,19 @@ public class ShadowBitmapTest {
 
   @Test
   public void shouldSetDensity() {
-    final Bitmap bitmap = Bitmap.createBitmap(new DisplayMetrics(), 100, 100, Bitmap.Config.ARGB_8888);
+    final Bitmap bitmap =
+        Bitmap.createBitmap(new DisplayMetrics(), 100, 100, Bitmap.Config.ARGB_8888);
     bitmap.setDensity(1000);
     assertThat(bitmap.getDensity()).isEqualTo(1000);
   }
 
   @Test
   public void shouldSetPixel() {
-    Bitmap bitmap = Bitmap.createBitmap(new int[] { 1 }, 1, 1, Bitmap.Config.ARGB_8888);
+    Bitmap bitmap = Bitmap.createBitmap(new int[] {1}, 1, 1, Bitmap.Config.ARGB_8888);
     shadowOf(bitmap).setMutable(true);
     bitmap.setPixel(0, 0, 2);
     assertThat(bitmap.getPixel(0, 0)).isEqualTo(2);
-    assertThat(shadowOf(bitmap).getCreatedFromColors()).isEqualTo(new int[] { 1 });
+    assertThat(shadowOf(bitmap).getCreatedFromColors()).isEqualTo(new int[] {1});
   }
 
   @Test
@@ -431,24 +432,18 @@ public class ShadowBitmapTest {
     Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
     Matrix matrix = new Matrix();
     transformedBitmap = Bitmap.createBitmap(bitmap, 0, 0, width, height, matrix, false);
-    assertThat(transformedBitmap.getWidth())
-        .isEqualTo(width);
-    assertThat(transformedBitmap.getHeight())
-        .isEqualTo(height);
+    assertThat(transformedBitmap.getWidth()).isEqualTo(width);
+    assertThat(transformedBitmap.getHeight()).isEqualTo(height);
 
     matrix.setRotate(90);
     transformedBitmap = Bitmap.createBitmap(bitmap, 0, 0, width, height, matrix, false);
-    assertThat(transformedBitmap.getWidth())
-        .isEqualTo(height);
-    assertThat(transformedBitmap.getHeight())
-        .isEqualTo(width);
+    assertThat(transformedBitmap.getWidth()).isEqualTo(height);
+    assertThat(transformedBitmap.getHeight()).isEqualTo(width);
 
     matrix.setScale(2, 3);
     transformedBitmap = Bitmap.createBitmap(bitmap, 0, 0, width, height, matrix, false);
-    assertThat(transformedBitmap.getWidth())
-        .isEqualTo(width * 2);
-    assertThat(transformedBitmap.getHeight())
-        .isEqualTo(height * 3);
+    assertThat(transformedBitmap.getWidth()).isEqualTo(width * 2);
+    assertThat(transformedBitmap.getHeight()).isEqualTo(height * 3);
   }
 
   @Test
@@ -470,7 +465,7 @@ public class ShadowBitmapTest {
     int reconstructedHeight = bitmapReconstructed.getHeight();
     int reconstructedWidth = bitmapReconstructed.getWidth();
 
-    //compare bitmap properties
+    // compare bitmap properties
     assertThat(originalHeight).isEqualTo(reconstructedHeight);
     assertThat(originalWidth).isEqualTo(reconstructedWidth);
     assertThat(bitmapOriginal.getConfig()).isEqualTo(bitmapReconstructed.getConfig());
@@ -479,8 +474,8 @@ public class ShadowBitmapTest {
     bitmapOriginal.getPixels(pixelsOriginal, 0, originalWidth, 0, 0, originalWidth, originalHeight);
 
     int[] pixelsReconstructed = new int[reconstructedWidth * reconstructedHeight];
-    bitmapReconstructed.getPixels(pixelsReconstructed, 0, reconstructedWidth, 0, 0,
-        reconstructedWidth, reconstructedHeight);
+    bitmapReconstructed.getPixels(
+        pixelsReconstructed, 0, reconstructedWidth, 0, 0, reconstructedWidth, reconstructedHeight);
 
     assertThat(Arrays.equals(pixelsOriginal, pixelsReconstructed)).isTrue();
   }
@@ -667,7 +662,6 @@ public class ShadowBitmapTest {
     assertThat(original.isPremultiplied()).isFalse();
   }
 
-
   @Test
   public void sameAs_bitmapsDifferentWidth() {
     Bitmap original1 = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothAdapterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothAdapterTest.java
index aadac4457..286a11323 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothAdapterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothAdapterTest.java
@@ -855,6 +855,7 @@ public class ShadowBluetoothAdapterTest {
   @Config(minSdk = U.SDK_INT)
   @Test
   public void getProfileProxy_adapterDisabled_serviceListenerNotInvoked() {
+    bluetoothAdapter.disable();
     shadowOf((Application) getApplicationContext()).grantPermissions(permission.BLUETOOTH);
     BluetoothProfile.ServiceListener listener =
         Mockito.mock(BluetoothProfile.ServiceListener.class);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothDeviceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothDeviceTest.java
index 7039d7658..5f50b3a42 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothDeviceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothDeviceTest.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows;
 import static android.Manifest.permission.BLUETOOTH_CONNECT;
 import static android.bluetooth.BluetoothClass.Device.AUDIO_VIDEO_HEADPHONES;
 import static android.bluetooth.BluetoothDevice.BOND_BONDED;
+import static android.bluetooth.BluetoothDevice.BOND_BONDING;
 import static android.bluetooth.BluetoothDevice.BOND_NONE;
 import static android.bluetooth.BluetoothDevice.DEVICE_TYPE_CLASSIC;
 import static android.os.Build.VERSION_CODES.M;
@@ -99,7 +100,7 @@ public class ShadowBluetoothDeviceTest {
 
     assertThat(shadowOf(device).getPin()).isNull();
 
-    byte[] pin = new byte[] { 1, 2, 3, 4 };
+    byte[] pin = new byte[] {1, 2, 3, 4};
     device.setPin(pin);
     assertThat(shadowOf(device).getPin()).isEqualTo(pin);
   }
@@ -195,12 +196,12 @@ public class ShadowBluetoothDeviceTest {
   public void connectGatt_withTransportPhy_doesntCrash() {
     BluetoothDevice bluetoothDevice = ShadowBluetoothDevice.newInstance(MOCK_MAC_ADDRESS);
     assertThat(
-        bluetoothDevice.connectGatt(
-            ApplicationProvider.getApplicationContext(),
-            false,
-            new BluetoothGattCallback() {},
-            BluetoothDevice.TRANSPORT_LE,
-            BluetoothDevice.PHY_LE_1M_MASK))
+            bluetoothDevice.connectGatt(
+                ApplicationProvider.getApplicationContext(),
+                false,
+                new BluetoothGattCallback() {},
+                BluetoothDevice.TRANSPORT_LE,
+                BluetoothDevice.PHY_LE_1M_MASK))
         .isNotNull();
   }
 
@@ -209,13 +210,13 @@ public class ShadowBluetoothDeviceTest {
   public void connectGatt_withTransportPhyHandler_doesntCrash() {
     BluetoothDevice bluetoothDevice = ShadowBluetoothDevice.newInstance(MOCK_MAC_ADDRESS);
     assertThat(
-        bluetoothDevice.connectGatt(
-            ApplicationProvider.getApplicationContext(),
-            false,
-            new BluetoothGattCallback() {},
-            BluetoothDevice.TRANSPORT_LE,
-            BluetoothDevice.PHY_LE_1M_MASK,
-            new Handler()))
+            bluetoothDevice.connectGatt(
+                ApplicationProvider.getApplicationContext(),
+                false,
+                new BluetoothGattCallback() {},
+                BluetoothDevice.TRANSPORT_LE,
+                BluetoothDevice.PHY_LE_1M_MASK,
+                new Handler()))
         .isNotNull();
   }
 
@@ -253,8 +254,7 @@ public class ShadowBluetoothDeviceTest {
     BluetoothGatt bluetoothGatt =
         device.connectGatt(ApplicationProvider.getApplicationContext(), false, callback);
 
-    assertThat(shadowOf(bluetoothGatt).getGattCallback())
-        .isEqualTo(callback);
+    assertThat(shadowOf(bluetoothGatt).getGattCallback()).isEqualTo(callback);
   }
 
   @Test
@@ -640,4 +640,49 @@ public class ShadowBluetoothDeviceTest {
 
     assertThat(device.isConnected()).isFalse();
   }
+
+  @Test
+  public void cancelBondProcess_bonded_verifyBondStateBonded() {
+    shadowOf(application).grantPermissions(BLUETOOTH_CONNECT);
+    BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(MOCK_MAC_ADDRESS);
+    ShadowBluetoothDevice shadowDevice = shadowOf(device);
+
+    shadowDevice.setBondState(BOND_BONDED);
+    boolean cancelBond = device.cancelBondProcess();
+    assertThat(cancelBond).isFalse();
+    assertThat(device.getBondState()).isEqualTo(BOND_BONDED);
+  }
+
+  @Test
+  public void cancelBondProcess_bonding_verifyBondStateNone() {
+    shadowOf(application).grantPermissions(BLUETOOTH_CONNECT);
+    BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(MOCK_MAC_ADDRESS);
+    ShadowBluetoothDevice shadowDevice = shadowOf(device);
+
+    shadowDevice.setBondState(BOND_BONDING);
+    boolean cancelBond = device.cancelBondProcess();
+    assertThat(cancelBond).isTrue();
+    assertThat(device.getBondState()).isEqualTo(BOND_NONE);
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.UPSIDE_DOWN_CAKE)
+  public void verifyTheDefaultConnectionHandle_isZero() {
+    shadowOf(application).grantPermissions(BLUETOOTH_CONNECT);
+    BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(MOCK_MAC_ADDRESS);
+
+    assertThat(device.getConnectionHandle(BluetoothDevice.TRANSPORT_LE)).isEqualTo(0);
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.UPSIDE_DOWN_CAKE)
+  public void verifyTheSetConnectionHandle_isTheSameAsTheGetConnectionHandle() {
+    shadowOf(application).grantPermissions(BLUETOOTH_CONNECT);
+    BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(MOCK_MAC_ADDRESS);
+    ShadowBluetoothDevice shadowDevice = shadowOf(device);
+
+    shadowDevice.setConnectionHandle(BluetoothDevice.TRANSPORT_LE, 123);
+    assertThat(device.getConnectionHandle(BluetoothDevice.TRANSPORT_LE)).isEqualTo(123);
+    assertThat(device.getConnectionHandle(BluetoothDevice.TRANSPORT_BREDR)).isEqualTo(0);
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothServerSocketTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothServerSocketTest.java
index 3066619df..6c8daa47a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothServerSocketTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothServerSocketTest.java
@@ -25,8 +25,12 @@ public class ShadowBluetoothServerSocketTest {
 
   @Before
   public void setUp() {
-    serverSocket = ShadowBluetoothServerSocket.newInstance(BluetoothSocket.TYPE_RFCOMM,
-            /*auth=*/ false, /*encrypt=*/ false, new ParcelUuid(DUMMY_UUID));
+    serverSocket =
+        ShadowBluetoothServerSocket.newInstance(
+            BluetoothSocket.TYPE_RFCOMM,
+            /* auth= */ false,
+            /* encrypt= */ false,
+            new ParcelUuid(DUMMY_UUID));
   }
 
   @Test
@@ -59,4 +63,4 @@ public class ShadowBluetoothServerSocketTest {
       // Expected.
     }
   }
-}
\ No newline at end of file
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBroadcastPendingResultTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBroadcastPendingResultTest.java
index 9adc9f24f..c03a5e4b8 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBroadcastPendingResultTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBroadcastPendingResultTest.java
@@ -11,7 +11,6 @@ import org.junit.runner.RunWith;
 public class ShadowBroadcastPendingResultTest {
   @Test
   public void testCreate() {
-    assertThat(ShadowBroadcastPendingResult.create(1, "result", new Bundle(), true))
-        .isNotNull();
+    assertThat(ShadowBroadcastPendingResult.create(1, "result", new Bundle(), true)).isNotNull();
   }
-}
\ No newline at end of file
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBundleTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBundleTest.java
index 4a079c0c4..d43212f33 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBundleTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBundleTest.java
@@ -124,8 +124,8 @@ public class ShadowBundleTest {
 
   @Test
   public void stringArray() {
-    bundle.putStringArray("foo", new String[] { "a" });
-    assertThat(bundle.getStringArray("foo")).isEqualTo(new String[]{"a"});
+    bundle.putStringArray("foo", new String[] {"a"});
+    assertThat(bundle.getStringArray("foo")).isEqualTo(new String[] {"a"});
     assertThat(bundle.getStringArray("bar")).isNull();
   }
 
@@ -151,7 +151,7 @@ public class ShadowBundleTest {
 
   @Test
   public void booleanArray() {
-    boolean [] arr = new boolean[] { false, true };
+    boolean[] arr = new boolean[] {false, true};
     bundle.putBooleanArray("foo", arr);
 
     assertThat(bundle.getBooleanArray("foo")).isEqualTo(arr);
@@ -160,7 +160,7 @@ public class ShadowBundleTest {
 
   @Test
   public void byteArray() {
-    byte [] arr = new byte[] { 12, 24 };
+    byte[] arr = new byte[] {12, 24};
     bundle.putByteArray("foo", arr);
 
     assertThat(bundle.getByteArray("foo")).isEqualTo(arr);
@@ -169,7 +169,7 @@ public class ShadowBundleTest {
 
   @Test
   public void charArray() {
-    char [] arr = new char[] { 'c', 'j' };
+    char[] arr = new char[] {'c', 'j'};
     bundle.putCharArray("foo", arr);
 
     assertThat(bundle.getCharArray("foo")).isEqualTo(arr);
@@ -178,7 +178,7 @@ public class ShadowBundleTest {
 
   @Test
   public void doubleArray() {
-    double [] arr = new double[] { 1.2, 3.4 };
+    double[] arr = new double[] {1.2, 3.4};
     bundle.putDoubleArray("foo", arr);
 
     assertThat(bundle.getDoubleArray("foo")).isEqualTo(arr);
@@ -187,7 +187,7 @@ public class ShadowBundleTest {
 
   @Test
   public void intArray() {
-    int [] arr = new int[] { 87, 65 };
+    int[] arr = new int[] {87, 65};
     bundle.putIntArray("foo", arr);
 
     assertThat(bundle.getIntArray("foo")).isEqualTo(arr);
@@ -196,7 +196,7 @@ public class ShadowBundleTest {
 
   @Test
   public void longArray() {
-    long [] arr = new long[] { 23, 11 };
+    long[] arr = new long[] {23, 11};
     bundle.putLongArray("foo", arr);
 
     assertThat(bundle.getLongArray("foo")).isEqualTo(arr);
@@ -205,7 +205,7 @@ public class ShadowBundleTest {
 
   @Test
   public void shortArray() {
-    short [] arr = new short[] { 89, 37 };
+    short[] arr = new short[] {89, 37};
     bundle.putShortArray("foo", arr);
 
     assertThat(bundle.getShortArray("foo")).isEqualTo(arr);
@@ -216,7 +216,7 @@ public class ShadowBundleTest {
   public void parcelableArray() {
     Bundle innerBundle = new Bundle();
     innerBundle.putInt("value", 1);
-    Parcelable[] arr = new Parcelable[] { innerBundle };
+    Parcelable[] arr = new Parcelable[] {innerBundle};
     bundle.putParcelableArray("foo", arr);
 
     assertThat(bundle.getParcelableArray("foo")).isEqualTo(arr);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraCharacteristicsTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraCharacteristicsTest.java
index 22ab0cab1..a3738cae3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraCharacteristicsTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraCharacteristicsTest.java
@@ -5,14 +5,11 @@ import static org.junit.Assert.fail;
 import static org.robolectric.Shadows.shadowOf;
 
 import android.hardware.camera2.CameraCharacteristics;
-import android.os.Build.VERSION_CODES;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
 
 /** Tests for {@link ShadowCameraCharacteristics}. */
-@Config(minSdk = VERSION_CODES.LOLLIPOP)
 @RunWith(AndroidJUnit4.class)
 public class ShadowCameraCharacteristicsTest {
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraDeviceImplTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraDeviceImplTest.java
index cbc79a46f..4a0c635b5 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraDeviceImplTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraDeviceImplTest.java
@@ -38,7 +38,6 @@ import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 
 /** Tests for {@link ShadowCameraDeviceImpl}. */
-@Config(minSdk = VERSION_CODES.LOLLIPOP)
 @RunWith(AndroidJUnit4.class)
 public final class ShadowCameraDeviceImplTest {
   private static final String CAMERA_ID_0 = "cameraId0";
@@ -70,7 +69,7 @@ public final class ShadowCameraDeviceImplTest {
   }
 
   @Test
-  @Config(minSdk = VERSION_CODES.LOLLIPOP, maxSdk = VERSION_CODES.Q)
+  @Config(maxSdk = VERSION_CODES.Q)
   public void createCaptureRequest() throws CameraAccessException {
     builder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_RECORD);
     CaptureRequest request = builder.build();
@@ -95,7 +94,7 @@ public final class ShadowCameraDeviceImplTest {
   public void createCaptureSession() throws CameraAccessException {
     builder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_RECORD);
     cameraDevice.createCaptureSession(
-        new ArrayList<>(), new CaptureSessionCallback(/*useExecutor=*/ false), new Handler());
+        new ArrayList<>(), new CaptureSessionCallback(/* useExecutor= */ false), new Handler());
   }
 
   @Test
@@ -109,7 +108,7 @@ public final class ShadowCameraDeviceImplTest {
             SessionConfiguration.SESSION_REGULAR,
             Collections.singletonList(new OutputConfiguration(mockSurface)),
             MoreExecutors.directExecutor(),
-            new CaptureSessionCallback(/*useExecutor=*/ true));
+            new CaptureSessionCallback(/* useExecutor= */ true));
     cameraDevice.createCaptureSession(configuration);
   }
 
@@ -125,7 +124,7 @@ public final class ShadowCameraDeviceImplTest {
             () ->
                 cameraDevice.createCaptureSession(
                     new ArrayList<>(),
-                    new CaptureSessionCallback(/*useExecutor=*/ false),
+                    new CaptureSessionCallback(/* useExecutor= */ false),
                     new Handler()));
     assertThat(thrown).hasMessageThat().contains("CameraDevice was already closed");
   }
@@ -141,7 +140,7 @@ public final class ShadowCameraDeviceImplTest {
             SessionConfiguration.SESSION_REGULAR,
             Collections.singletonList(new OutputConfiguration(mock(Surface.class))),
             MoreExecutors.directExecutor(),
-            new CaptureSessionCallback(/*useExecutor=*/ true));
+            new CaptureSessionCallback(/* useExecutor= */ true));
     IllegalStateException thrown =
         assertThrows(
             IllegalStateException.class, () -> cameraDevice.createCaptureSession(configuration));
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraManagerTest.java
index 14c751d42..a08e6b6b0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraManagerTest.java
@@ -24,7 +24,6 @@ import org.mockito.ArgumentCaptor;
 import org.robolectric.annotation.Config;
 
 /** Tests for {@link ShadowCameraManager}. */
-@Config(minSdk = VERSION_CODES.LOLLIPOP)
 @RunWith(AndroidJUnit4.class)
 public class ShadowCameraManagerTest {
 
@@ -174,7 +173,6 @@ public class ShadowCameraManagerTest {
   }
 
   @Test
-  @Config(minSdk = VERSION_CODES.LOLLIPOP)
   public void openCamera() throws CameraAccessException {
     shadowOf(cameraManager).addCamera(CAMERA_ID_0, characteristics);
 
@@ -185,7 +183,6 @@ public class ShadowCameraManagerTest {
   }
 
   @Test
-  @Config(minSdk = VERSION_CODES.LOLLIPOP)
   public void triggerDisconnect() throws CameraAccessException {
     shadowOf(cameraManager).addCamera(CAMERA_ID_0, characteristics);
 
@@ -202,7 +199,6 @@ public class ShadowCameraManagerTest {
   }
 
   @Test
-  @Config(minSdk = VERSION_CODES.LOLLIPOP)
   public void triggerDisconnect_noCameraOpen() throws CameraAccessException {
     shadowOf(cameraManager).addCamera(CAMERA_ID_0, characteristics);
     shadowOf(cameraManager).triggerDisconnect();
@@ -264,26 +260,24 @@ public class ShadowCameraManagerTest {
   }
 
   @Test
-  @Config(minSdk = VERSION_CODES.LOLLIPOP)
   public void registerCallbackAvailable() throws CameraAccessException {
     CameraManager.AvailabilityCallback mockCallback =
         mock(CameraManager.AvailabilityCallback.class);
     // Verify adding the camera triggers the callback
-    cameraManager.registerAvailabilityCallback(mockCallback, /* handler = */ null);
+    cameraManager.registerAvailabilityCallback(mockCallback, /* handler= */ null);
     shadowOf(cameraManager).addCamera(CAMERA_ID_0, characteristics);
 
     verify(mockCallback).onCameraAvailable(CAMERA_ID_0);
   }
 
   @Test
-  @Config(minSdk = VERSION_CODES.LOLLIPOP)
   public void unregisterCallbackAvailable() throws CameraAccessException {
     CameraManager.AvailabilityCallback mockCallback =
         mock(CameraManager.AvailabilityCallback.class);
 
     shadowOf(cameraManager).addCamera(CAMERA_ID_0, characteristics);
     shadowOf(cameraManager).removeCamera(CAMERA_ID_0);
-    cameraManager.registerAvailabilityCallback(mockCallback, /* handler = */ null);
+    cameraManager.registerAvailabilityCallback(mockCallback, /* handler= */ null);
     cameraManager.unregisterAvailabilityCallback(mockCallback);
 
     shadowOf(cameraManager).addCamera(CAMERA_ID_0, characteristics);
@@ -292,13 +286,12 @@ public class ShadowCameraManagerTest {
   }
 
   @Test
-  @Config(minSdk = VERSION_CODES.LOLLIPOP)
   public void registerCallbackUnavailable() throws CameraAccessException {
     CameraManager.AvailabilityCallback mockCallback =
         mock(CameraManager.AvailabilityCallback.class);
 
     // Verify that the camera unavailable callback is called when the camera is removed
-    cameraManager.registerAvailabilityCallback(mockCallback, /* handler = */ null);
+    cameraManager.registerAvailabilityCallback(mockCallback, /* handler= */ null);
     shadowOf(cameraManager).addCamera(CAMERA_ID_0, characteristics);
     shadowOf(cameraManager).removeCamera(CAMERA_ID_0);
 
@@ -306,12 +299,11 @@ public class ShadowCameraManagerTest {
   }
 
   @Test
-  @Config(minSdk = VERSION_CODES.LOLLIPOP)
   public void unregisterCallbackUnavailable() throws CameraAccessException {
     CameraManager.AvailabilityCallback mockCallback =
         mock(CameraManager.AvailabilityCallback.class);
 
-    cameraManager.registerAvailabilityCallback(mockCallback, /* handler = */ null);
+    cameraManager.registerAvailabilityCallback(mockCallback, /* handler= */ null);
     cameraManager.unregisterAvailabilityCallback(mockCallback);
 
     shadowOf(cameraManager).addCamera(CAMERA_ID_0, characteristics);
@@ -321,13 +313,12 @@ public class ShadowCameraManagerTest {
   }
 
   @Test
-  @Config(minSdk = VERSION_CODES.LOLLIPOP)
   public void registerCallbackUnavailableInvalidCameraId() throws CameraAccessException {
     CameraManager.AvailabilityCallback mockCallback =
         mock(CameraManager.AvailabilityCallback.class);
 
     // Verify that the callback is not triggered for a camera that was never added
-    cameraManager.registerAvailabilityCallback(mockCallback, /* handler = */ null);
+    cameraManager.registerAvailabilityCallback(mockCallback, /* handler= */ null);
     try {
       shadowOf(cameraManager).removeCamera(CAMERA_ID_0);
     } catch (IllegalArgumentException e) {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraSizeTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraSizeTest.java
index 243595f3a..55f853af2 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraSizeTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraSizeTest.java
@@ -38,5 +38,4 @@ public class ShadowCameraSizeTest {
     cameraSize.height = 480;
     assertThat(cameraSize.height).isEqualTo(480);
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptureRequestBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptureRequestBuilderTest.java
index e6049813f..3364ebe71 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptureRequestBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptureRequestBuilderTest.java
@@ -21,7 +21,6 @@ import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 
 /** Tests for {@link ShadowCaptureRequestBuilder}. */
-@Config(minSdk = VERSION_CODES.LOLLIPOP)
 @RunWith(AndroidJUnit4.class)
 public class ShadowCaptureRequestBuilderTest {
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptureResultTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptureResultTest.java
index 348f8e060..b77e8e5f5 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptureResultTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptureResultTest.java
@@ -5,14 +5,11 @@ import static org.junit.Assert.fail;
 import static org.robolectric.Shadows.shadowOf;
 
 import android.hardware.camera2.CaptureResult;
-import android.os.Build.VERSION_CODES;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
 
 /** Tests for {@link ShadowCaptureResult}. */
-@Config(minSdk = VERSION_CODES.LOLLIPOP)
 @RunWith(AndroidJUnit4.class)
 public class ShadowCaptureResultTest {
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCardEmulationTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCardEmulationTest.java
index c6fe1eb9b..5285bde71 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCardEmulationTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCardEmulationTest.java
@@ -9,14 +9,12 @@ import android.content.ComponentName;
 import android.content.pm.PackageManager;
 import android.nfc.NfcAdapter;
 import android.nfc.cardemulation.CardEmulation;
-import android.os.Build;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
 
 /** Test the shadow implementation of {@link CardEmulation}. */
 @RunWith(AndroidJUnit4.class)
@@ -42,7 +40,6 @@ public final class ShadowCardEmulationTest {
   }
 
   @Test
-  @Config(minSdk = Build.VERSION_CODES.LOLLIPOP)
   public void isDefaultServiceForCategory_canOverride() {
     assertThat(cardEmulation.isDefaultServiceForCategory(service, TEST_CATEGORY)).isFalse();
     ShadowCardEmulation.setDefaultServiceForCategory(service, TEST_CATEGORY);
@@ -52,7 +49,6 @@ public final class ShadowCardEmulationTest {
   }
 
   @Test
-  @Config(minSdk = Build.VERSION_CODES.LOLLIPOP)
   public void setPreferredService_canCapture() {
     assertThat(ShadowCardEmulation.getPreferredService() == null).isTrue();
     cardEmulation.setPreferredService(activity, service);
@@ -62,7 +58,6 @@ public final class ShadowCardEmulationTest {
   }
 
   @Test
-  @Config(minSdk = Build.VERSION_CODES.LOLLIPOP)
   public void categoryAllowsForegroundPreference_canSet() {
     assertThat(cardEmulation.categoryAllowsForegroundPreference(CardEmulation.CATEGORY_PAYMENT))
         .isFalse();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCarrierConfigManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCarrierConfigManagerTest.java
index acbc59085..416bb6200 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCarrierConfigManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCarrierConfigManagerTest.java
@@ -1,6 +1,7 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.M;
+import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
 
@@ -61,6 +62,27 @@ public class ShadowCarrierConfigManagerTest {
     assertThat(verifyBundle.getBoolean(BOOLEAN_KEY)).isEqualTo(BOOLEAN_VALUE);
   }
 
+  @Test
+  @Config(minSdk = UPSIDE_DOWN_CAKE)
+  public void testGetConfigForSubIdAndKeys() {
+    PersistableBundle persistableBundle = new PersistableBundle();
+    persistableBundle.putString(STRING_KEY, STRING_VALUE);
+    persistableBundle.putInt(INT_KEY, INT_VALUE);
+
+    shadowOf(carrierConfigManager).setConfigForSubId(TEST_ID, persistableBundle);
+
+    PersistableBundle verifyBundle =
+        carrierConfigManager.getConfigForSubId(TEST_ID, INT_KEY, BOOLEAN_KEY);
+    assertThat(verifyBundle).isNotNull();
+
+    assertThat(verifyBundle.keySet())
+        .containsExactly(
+            CarrierConfigManager.KEY_CARRIER_CONFIG_VERSION_STRING,
+            CarrierConfigManager.KEY_CARRIER_CONFIG_APPLIED_BOOL,
+            INT_KEY);
+    assertThat(verifyBundle.getInt(INT_KEY)).isEqualTo(INT_VALUE);
+  }
+
   @Test
   public void getConfigForSubId_defaultsToEmpty() {
     PersistableBundle persistableBundle = carrierConfigManager.getConfigForSubId(99999);
@@ -74,6 +96,20 @@ public class ShadowCarrierConfigManagerTest {
     assertThat(persistableBundle).isNull();
   }
 
+  @Test
+  @Config(minSdk = UPSIDE_DOWN_CAKE)
+  public void getConfigForSubIdAndKeys_afterSetNullConfig_returnsBaseBundle() {
+    shadowOf(carrierConfigManager).setConfigForSubId(TEST_ID, null);
+
+    PersistableBundle verifyBundle =
+        carrierConfigManager.getConfigForSubId(TEST_ID, INT_KEY, BOOLEAN_KEY);
+
+    assertThat(verifyBundle).isNotNull();
+
+    PersistableBundle baseBundle = ShadowCarrierConfigManager.BASE;
+    assertThat(verifyBundle.keySet()).isEqualTo(baseBundle.keySet());
+  }
+
   @Test
   public void overrideConfig_setNullConfig_removesOverride() {
     // Set value
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCheckBoxTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCheckBoxTest.java
index fa60547a5..f9f1b59f9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCheckBoxTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCheckBoxTest.java
@@ -21,7 +21,7 @@ public class ShadowCheckBoxTest {
     checkBox.toggle();
     assertThat(checkBox.isChecked()).isFalse();
 
-    checkBox.performClick();  // Used to support performClick(), but Android doesn't. Sigh.
-//        assertThat(checkBox.isChecked()).isFalse();
+    checkBox.performClick(); // Used to support performClick(), but Android doesn't. Sigh.
+    //        assertThat(checkBox.isChecked()).isFalse();
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCheckedTextViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCheckedTextViewTest.java
index dac1e2844..a6cc1af6e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCheckedTextViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCheckedTextViewTest.java
@@ -44,7 +44,7 @@ public class ShadowCheckedTextViewTest {
     assertFalse(view.isChecked());
     view.toggle();
     assertTrue(view.isChecked());
-    view.toggle();  // Used to support performClick(), but Android doesn't. Sigh.
+    view.toggle(); // Used to support performClick(), but Android doesn't. Sigh.
     assertFalse(view.isChecked());
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowClipboardManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowClipboardManagerTest.java
index 88ff63cea..f081b4b74 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowClipboardManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowClipboardManagerTest.java
@@ -25,7 +25,8 @@ public class ShadowClipboardManagerTest {
 
   private ClipboardManager clipboardManager;
 
-  @Before public void setUp() throws Exception {
+  @Before
+  public void setUp() throws Exception {
     clipboardManager =
         (ClipboardManager)
             ApplicationProvider.getApplicationContext().getSystemService(Context.CLIPBOARD_SERVICE);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowConfigurationTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowConfigurationTest.java
index 9e0ea9e70..fe44d943b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowConfigurationTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowConfigurationTest.java
@@ -29,10 +29,10 @@ public class ShadowConfigurationTest {
 
   @Test
   public void testSetLocale() {
-    configuration.setLocale( Locale.US );
+    configuration.setLocale(Locale.US);
     assertThat(configuration.locale).isEqualTo(Locale.US);
 
-    configuration.setLocale( Locale.FRANCE);
+    configuration.setLocale(Locale.FRANCE);
     assertThat(configuration.locale).isEqualTo(Locale.FRANCE);
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectionTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectionTest.java
index cf22c88a5..f92c651ce 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectionTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectionTest.java
@@ -28,4 +28,22 @@ public class ShadowConnectionTest {
 
     assertThat(eventOptional.get()).isEqualTo("TEST_EVENT");
   }
+
+  @Test
+  public void isDestroyed_callDestroy_returnsTrue() {
+    Connection connection = new FakeConnection();
+
+    connection.destroy();
+    boolean isDestroyed = shadowOf(connection).isDestroyed();
+
+    assertThat(isDestroyed).isTrue();
+  }
+
+  @Test
+  public void isDestroyed_doNotCallDestroy_returnsFalse() {
+    Connection connection = new FakeConnection();
+    boolean isDestroyed = shadowOf(connection).isDestroyed();
+
+    assertThat(isDestroyed).isFalse();
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectivityManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectivityManagerTest.java
index ac4374a19..2553aebb3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectivityManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectivityManagerTest.java
@@ -10,6 +10,7 @@ import static android.os.Build.VERSION_CODES.S;
 import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
@@ -82,7 +83,7 @@ public class ShadowConnectivityManagerTest {
   @Test
   public void getNetworkInfo_shouldReturnSomeForAllNetworks() {
     Network[] allNetworks = connectivityManager.getAllNetworks();
-    for (Network network: allNetworks) {
+    for (Network network : allNetworks) {
       NetworkInfo networkInfo = connectivityManager.getNetworkInfo(network);
       assertThat(networkInfo).isNotNull();
     }
@@ -183,7 +184,8 @@ public class ShadowConnectivityManagerTest {
     assertThat(info.getSubtype()).isEqualTo(TelephonyManager.NETWORK_TYPE_EDGE);
     assertThat(info.isAvailable()).isTrue();
     assertThat(info.isConnected()).isFalse();
-    assertThat(shadowOf(connectivityManager.getActiveNetwork()).getNetId()).isEqualTo(info.getType());
+    assertThat(shadowOf(connectivityManager.getActiveNetwork()).getNetId())
+        .isEqualTo(info.getType());
   }
 
   @Test
@@ -273,12 +275,14 @@ public class ShadowConnectivityManagerTest {
 
     Network returnedNetwork = networks[0];
     ShadowNetwork shadowReturnedNetwork = shadowOf(returnedNetwork);
-    assertThat(shadowReturnedNetwork.getNetId()).isNotEqualTo(ShadowConnectivityManager.NET_ID_WIFI);
+    assertThat(shadowReturnedNetwork.getNetId())
+        .isNotEqualTo(ShadowConnectivityManager.NET_ID_WIFI);
   }
 
   @Test
   public void getNetworkPreference_shouldGetDefaultValue() {
-    assertThat(connectivityManager.getNetworkPreference()).isEqualTo(ConnectivityManager.DEFAULT_NETWORK_PREFERENCE);
+    assertThat(connectivityManager.getNetworkPreference())
+        .isEqualTo(ConnectivityManager.DEFAULT_NETWORK_PREFERENCE);
   }
 
   @Test
@@ -302,7 +306,8 @@ public class ShadowConnectivityManagerTest {
   @Test
   public void setNetworkPreference_shouldSetDefaultValue() {
     connectivityManager.setNetworkPreference(ConnectivityManager.TYPE_MOBILE);
-    assertThat(connectivityManager.getNetworkPreference()).isEqualTo(connectivityManager.getNetworkPreference());
+    assertThat(connectivityManager.getNetworkPreference())
+        .isEqualTo(connectivityManager.getNetworkPreference());
     connectivityManager.setNetworkPreference(ConnectivityManager.TYPE_WIFI);
     assertThat(connectivityManager.getNetworkPreference()).isEqualTo(ConnectivityManager.TYPE_WIFI);
   }
@@ -316,6 +321,7 @@ public class ShadowConnectivityManagerTest {
     return new ConnectivityManager.NetworkCallback() {
       @Override
       public void onAvailable(Network network) {}
+
       @Override
       public void onLost(Network network) {}
     };
@@ -568,8 +574,8 @@ public class ShadowConnectivityManagerTest {
     NetworkCapabilities nc = ShadowNetworkCapabilities.newInstance();
     shadowOf(nc).addCapability(NetworkCapabilities.NET_CAPABILITY_MMS);
 
-    shadowOf(connectivityManager).setNetworkCapabilities(
-        shadowOf(connectivityManager).getActiveNetwork(), nc);
+    shadowOf(connectivityManager)
+        .setNetworkCapabilities(shadowOf(connectivityManager).getActiveNetwork(), nc);
 
     assertThat(
             shadowOf(connectivityManager)
@@ -718,4 +724,74 @@ public class ShadowConnectivityManagerTest {
     assertThat(connectivityManager.getProxyForNetwork(network)).isNull();
     assertThat(connectivityManager.getDefaultProxy()).isNull();
   }
+
+  @Test
+  public void setDefaultNetworkActive_isActiveTrue_triggersOnAvailableInCallbacks() {
+    NetworkRequest.Builder builder = new NetworkRequest.Builder();
+    ConnectivityManager.NetworkCallback callback1 = spy(createSimpleCallback());
+    ConnectivityManager.NetworkCallback callback2 = spy(createSimpleCallback());
+    ShadowConnectivityManager shadowConnectivityManager = shadowOf(connectivityManager);
+    shadowConnectivityManager.registerDefaultNetworkCallback(callback1);
+    shadowConnectivityManager.registerNetworkCallback(builder.build(), callback2);
+    shadowConnectivityManager.setActiveNetworkInfo(
+        ShadowNetworkInfo.newInstance(
+            null,
+            ConnectivityManager.TYPE_MOBILE,
+            TelephonyManager.NETWORK_TYPE_LTE,
+            true,
+            NetworkInfo.State.CONNECTED));
+
+    shadowConnectivityManager.setDefaultNetworkActive(true);
+
+    verify(callback1).onAvailable(shadowConnectivityManager.getActiveNetwork());
+    verify(callback2).onAvailable(shadowConnectivityManager.getActiveNetwork());
+  }
+
+  @Test
+  public void setDefaultNetworkActive_isActiveFalse_triggersOnLostInCallbacks() {
+    NetworkRequest.Builder builder = new NetworkRequest.Builder();
+    ConnectivityManager.NetworkCallback callback1 = spy(createSimpleCallback());
+    ConnectivityManager.NetworkCallback callback2 = spy(createSimpleCallback());
+    ShadowConnectivityManager shadowConnectivityManager = shadowOf(connectivityManager);
+    shadowConnectivityManager.registerDefaultNetworkCallback(callback1);
+    shadowConnectivityManager.registerNetworkCallback(builder.build(), callback2);
+    shadowConnectivityManager.setActiveNetworkInfo(
+        ShadowNetworkInfo.newInstance(
+            null,
+            ConnectivityManager.TYPE_MOBILE,
+            TelephonyManager.NETWORK_TYPE_LTE,
+            true,
+            NetworkInfo.State.CONNECTED));
+    Network previouslyActiveNetwork = shadowConnectivityManager.getActiveNetwork();
+
+    shadowConnectivityManager.setDefaultNetworkActive(false);
+
+    verify(callback1).onLost(previouslyActiveNetwork);
+    verify(callback2).onLost(previouslyActiveNetwork);
+  }
+
+  @Test
+  public void
+      setDefaultNetworkActive_withSetNetworkCallbacksEnabledFalse_doesNotTriggerCallbacks() {
+    NetworkRequest.Builder builder = new NetworkRequest.Builder();
+    ConnectivityManager.NetworkCallback callback1 = spy(createSimpleCallback());
+    ConnectivityManager.NetworkCallback callback2 = spy(createSimpleCallback());
+    ShadowConnectivityManager shadowConnectivityManager = shadowOf(connectivityManager);
+    shadowConnectivityManager.registerDefaultNetworkCallback(callback1);
+    shadowConnectivityManager.registerNetworkCallback(builder.build(), callback2);
+    shadowConnectivityManager.setActiveNetworkInfo(
+        ShadowNetworkInfo.newInstance(
+            null,
+            ConnectivityManager.TYPE_MOBILE,
+            TelephonyManager.NETWORK_TYPE_LTE,
+            true,
+            NetworkInfo.State.CONNECTED));
+    shadowConnectivityManager.setNetworkCallbacksEnabled(false);
+
+    shadowConnectivityManager.setDefaultNetworkActive(true);
+    shadowConnectivityManager.setDefaultNetworkActive(false);
+
+    verify(callback1, never()).onAvailable(shadowConnectivityManager.getActiveNetwork());
+    verify(callback2, never()).onAvailable(shadowConnectivityManager.getActiveNetwork());
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentObserverTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentObserverTest.java
index d2ae2cafa..3c22ce2e0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentObserverTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentObserverTest.java
@@ -68,5 +68,4 @@ public class ShadowContentObserverTest {
       this.uri = uri;
     }
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentProviderOperationBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentProviderOperationBuilderTest.java
index 60cb76d87..fab469528 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentProviderOperationBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentProviderOperationBuilderTest.java
@@ -30,44 +30,48 @@ public class ShadowContentProviderOperationBuilderTest {
     assertThat(op.getUri()).isEqualTo(uri);
 
     final ContentRequest request = new ContentRequest();
-    ContentProvider provider = new ContentProvider() {
-      @Override
-      public boolean onCreate() {
-        return true;
-      }
-
-      @Override
-      public Cursor query(Uri uri, String[] projection, String selection,
-          String[] selectionArgs, String sortOrder) {
-        return null;
-      }
-
-      @Override
-      public String getType(Uri uri) {
-        return null;
-      }
-
-      @Override
-      public Uri insert(Uri uri, ContentValues values) {
-        return null;
-      }
-
-      @Override
-      public int delete(Uri uri, String selection, String[] selectionArgs) {
-        return 0;
-      }
-
-      @Override
-      public int update(Uri uri, ContentValues values, String selection,
-          String[] selectionArgs) {
-        request.uri = uri;
-        request.values = values;
-        request.selection = selection;
-        request.selectionArgs = selectionArgs;
-        return 0;
-      }
-
-    };
+    ContentProvider provider =
+        new ContentProvider() {
+          @Override
+          public boolean onCreate() {
+            return true;
+          }
+
+          @Override
+          public Cursor query(
+              Uri uri,
+              String[] projection,
+              String selection,
+              String[] selectionArgs,
+              String sortOrder) {
+            return null;
+          }
+
+          @Override
+          public String getType(Uri uri) {
+            return null;
+          }
+
+          @Override
+          public Uri insert(Uri uri, ContentValues values) {
+            return null;
+          }
+
+          @Override
+          public int delete(Uri uri, String selection, String[] selectionArgs) {
+            return 0;
+          }
+
+          @Override
+          public int update(
+              Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+            request.uri = uri;
+            request.values = values;
+            request.selection = selection;
+            request.selectionArgs = selectionArgs;
+            return 0;
+          }
+        };
 
     op.apply(provider, null, 0);
 
@@ -77,7 +81,6 @@ public class ShadowContentProviderOperationBuilderTest {
 
     assertThat(request.values.containsKey("k1")).isTrue();
     assertThat(request.values.containsKey("k2")).isTrue();
-
   }
 
   static class ContentRequest {
@@ -86,5 +89,4 @@ public class ShadowContentProviderOperationBuilderTest {
     String[] selectionArgs;
     ContentValues values;
   }
-
-}
\ No newline at end of file
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentProviderOperationTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentProviderOperationTest.java
index d87e9b4df..f748b532e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentProviderOperationTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentProviderOperationTest.java
@@ -21,10 +21,11 @@ public class ShadowContentProviderOperationTest {
   public void reflectionShouldWork() {
     final Uri uri = Uri.parse("content://authority/path");
 
-    ContentProviderOperation op = ContentProviderOperation.newInsert(uri)
-        .withValue("insertKey", "insertValue")
-        .withValueBackReference("backKey", 2)
-        .build();
+    ContentProviderOperation op =
+        ContentProviderOperation.newInsert(uri)
+            .withValue("insertKey", "insertValue")
+            .withValueBackReference("backKey", 2)
+            .build();
 
     // insert and values back references
     assertThat(op.getUri()).isEqualTo(uri);
@@ -34,11 +35,12 @@ public class ShadowContentProviderOperationTest {
     assertThat(shadow.getValuesBackReferences().getAsInteger("backKey")).isEqualTo(2);
 
     // update and selection back references
-    op = ContentProviderOperation.newUpdate(uri)
-        .withValue("updateKey", "updateValue")
-        .withSelection("a=? and b=?", new String[] {"abc"})
-        .withSelectionBackReference(1, 3)
-        .build();
+    op =
+        ContentProviderOperation.newUpdate(uri)
+            .withValue("updateKey", "updateValue")
+            .withSelection("a=? and b=?", new String[] {"abc"})
+            .withSelectionBackReference(1, 3)
+            .build();
     assertThat(op.getUri()).isEqualTo(uri);
     shadow = Shadows.shadowOf(op);
     assertThat(shadow.getType()).isEqualTo(ShadowContentProviderOperation.TYPE_UPDATE);
@@ -48,13 +50,10 @@ public class ShadowContentProviderOperationTest {
     assertThat(shadow.getSelectionArgsBackReferences()).isEqualTo(Collections.singletonMap(1, 3));
 
     // delete and expected count
-    op = ContentProviderOperation.newDelete(uri)
-        .withExpectedCount(1)
-        .build();
+    op = ContentProviderOperation.newDelete(uri).withExpectedCount(1).build();
     assertThat(op.getUri()).isEqualTo(uri);
     shadow = Shadows.shadowOf(op);
     assertThat(shadow.getType()).isEqualTo(ShadowContentProviderOperation.TYPE_DELETE);
     assertThat(shadow.getExpectedCount()).isEqualTo(1);
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentProviderResultTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentProviderResultTest.java
index 40a47b993..6dbf60176 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentProviderResultTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentProviderResultTest.java
@@ -22,4 +22,4 @@ public class ShadowContentProviderResultTest {
     ContentProviderResult result = new ContentProviderResult(uri);
     assertThat(result.uri).isEqualTo(uri);
   }
-}
\ No newline at end of file
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java
index 94a19debb..f8371cbab 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java
@@ -1146,6 +1146,18 @@ public class ShadowContentResolverTest {
     assertThat(ShadowContentResolver.getProvider(Uri.parse("content://"))).isNull();
   }
 
+  @Test
+  public void openAssetFileDescriptor_shouldOpenDescriptor() throws IOException {
+    Robolectric.setupContentProvider(MyContentProvider.class, AUTHORITY);
+
+    try (AssetFileDescriptor afd =
+        contentResolver.openAssetFileDescriptor(
+            Uri.parse("content://" + AUTHORITY + "/whatever"), "r")) {
+      FileDescriptor descriptor = afd.getFileDescriptor();
+      assertThat(descriptor).isNotNull();
+    }
+  }
+
   @Test
   public void openTypedAssetFileDescriptor_shouldOpenDescriptor()
       throws IOException, RemoteException {
@@ -1197,11 +1209,17 @@ public class ShadowContentResolverTest {
     SyncAdapterType[] syncAdapterTypes =
         new SyncAdapterType[] {
           new SyncAdapterType(
-              "authority1", "accountType1", /* userVisible=*/ false, /* supportsUploading=*/ false),
+              "authority1",
+              "accountType1",
+              /* userVisible= */ false,
+              /* supportsUploading= */ false),
           new SyncAdapterType(
-              "authority2", "accountType2", /* userVisible=*/ true, /* supportsUploading=*/ false),
+              "authority2",
+              "accountType2",
+              /* userVisible= */ true,
+              /* supportsUploading= */ false),
           new SyncAdapterType(
-              "authority3", "accountType3", /* userVisible=*/ true, /* supportsUploading=*/ true)
+              "authority3", "accountType3", /* userVisible= */ true, /* supportsUploading= */ true)
         };
 
     ShadowContentResolver.setSyncAdapterTypes(syncAdapterTypes);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentUrisTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentUrisTest.java
index 99f3c045b..39990254b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentUrisTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentUrisTest.java
@@ -18,7 +18,8 @@ public class ShadowContentUrisTest {
     URI = Uri.parse("content://foo.com");
   }
 
-  @Test public void canAppendId() {
+  @Test
+  public void canAppendId() {
     assertThat(ContentUris.withAppendedId(URI, 1)).isEqualTo(Uri.parse("content://foo.com/1"));
   }
 
@@ -27,7 +28,8 @@ public class ShadowContentUrisTest {
     ContentUris.withAppendedId(null, 1);
   }
 
-  @Test public void canParseId() {
+  @Test
+  public void canParseId() {
     assertThat(ContentUris.parseId(Uri.withAppendedPath(URI, "1"))).isEqualTo(1L);
     assertThat(ContentUris.parseId(URI)).isEqualTo(-1L);
   }
@@ -41,5 +43,4 @@ public class ShadowContentUrisTest {
   public void parseIdThrowsUnsupportedException() {
     ContentUris.parseId(Uri.parse("mailto:bar@foo.com"));
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextHubManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextHubManagerTest.java
index a663b2b3a..caca2bd8d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextHubManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextHubManagerTest.java
@@ -2,13 +2,21 @@ package org.robolectric.shadows;
 
 import static com.google.common.truth.Truth.assertThat;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
 
 import android.content.Context;
 import android.hardware.location.ContextHubClient;
+import android.hardware.location.ContextHubClientCallback;
 import android.hardware.location.ContextHubInfo;
 import android.hardware.location.ContextHubManager;
 import android.hardware.location.ContextHubTransaction;
 import android.hardware.location.NanoAppInstanceInfo;
+import android.hardware.location.NanoAppMessage;
 import android.hardware.location.NanoAppState;
 import android.os.Build;
 import androidx.test.core.app.ApplicationProvider;
@@ -17,6 +25,7 @@ import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -63,7 +72,7 @@ public class ShadowContextHubManagerTest {
     long nanoAppId = 5;
     int nanoAppVersion = 1;
     shadowManager.addNanoApp(
-        contextHubInfoList.get(0), 0 /* nanoAppUid */, nanoAppId, nanoAppVersion);
+        contextHubInfoList.get(0), /* nanoAppUid= */ 0, nanoAppId, nanoAppVersion);
 
     ContextHubTransaction<List<NanoAppState>> transaction =
         contextHubManager.queryNanoApps(contextHubInfoList.get(0));
@@ -155,4 +164,77 @@ public class ShadowContextHubManagerTest {
 
     assertThat(info).isNull();
   }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.P)
+  public void broadcastsFromContextHub_notifiesClient() {
+    ContextHubManager contextHubManager = context.getSystemService(ContextHubManager.class);
+    ContextHubClientCallback callback = mock(ContextHubClientCallback.class);
+
+    contextHubManager.createClient(null, callback);
+
+    verify(callback, never()).onNanoAppLoaded(any(), anyLong());
+
+    ShadowContextHubManager shadowManager = Shadow.extract(contextHubManager);
+    shadowManager.broadcastNanoAppLoaded(1);
+
+    verify(callback).onNanoAppLoaded(any(), anyLong());
+    verify(callback, never()).onMessageFromNanoApp(any(), any());
+
+    shadowManager.broadcastMessageFromNanoApp(
+        NanoAppMessage.createMessageToNanoApp(1, 1, new byte[0]));
+
+    verify(callback).onMessageFromNanoApp(any(), any());
+    verify(callback, never()).onHubReset(any());
+
+    shadowManager.resetContextHub();
+
+    verify(callback).onHubReset(any());
+    verify(callback, never()).onNanoAppAborted(any(), anyLong(), anyInt());
+
+    shadowManager.broadcastNanoAppAborted(1, 0);
+
+    verify(callback).onNanoAppAborted(any(), anyLong(), anyInt());
+    verify(callback, never()).onNanoAppUnloaded(any(), anyLong());
+
+    shadowManager.broadcastNanoAppUnloaded(1);
+
+    verify(callback).onNanoAppUnloaded(any(), anyLong());
+    verify(callback, never()).onNanoAppEnabled(any(), anyLong());
+
+    shadowManager.broadcastNanoAppEnabled(1);
+
+    verify(callback).onNanoAppEnabled(any(), anyLong());
+    verify(callback, never()).onNanoAppDisabled(any(), anyLong());
+
+    shadowManager.broadcastNanoAppDisabled(1);
+
+    verify(callback).onNanoAppDisabled(any(), anyLong());
+    if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.S) {
+      // onClientAuthorizationChanged was added in S
+      verify(callback, never()).onClientAuthorizationChanged(any(), anyLong(), anyInt());
+    }
+  }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.S)
+  public void broadcastsClientAuthorizationChanged_notifiesClient() {
+    ContextHubManager contextHubManager = context.getSystemService(ContextHubManager.class);
+    ContextHubClientCallback callback = mock(ContextHubClientCallback.class);
+    contextHubManager.createClient(null, callback);
+
+    verify(callback, never()).onClientAuthorizationChanged(any(), anyLong(), anyInt());
+
+    ShadowContextHubManager shadowManager = Shadow.extract(contextHubManager);
+    shadowManager.broadcastClientAuthorizationChanged(1, 2);
+
+    verify(callback).onClientAuthorizationChanged(any(), anyLong(), anyInt());
+    verify(callback, never()).onNanoAppLoaded(any(), anyLong());
+    verify(callback, never()).onMessageFromNanoApp(any(), any());
+    verify(callback, never()).onHubReset(any());
+    verify(callback, never()).onNanoAppAborted(any(), anyLong(), anyInt());
+    verify(callback, never()).onNanoAppUnloaded(any(), anyLong());
+    verify(callback, never()).onNanoAppEnabled(any(), anyLong());
+    verify(callback, never()).onNanoAppDisabled(any(), anyLong());
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextImplTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextImplTest.java
index 2a348b1ec..159863d12 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextImplTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextImplTest.java
@@ -1,11 +1,10 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.KITKAT;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
+import static org.junit.Assert.assertThrows;
 import static org.robolectric.Shadows.shadowOf;
 
 import android.app.Application;
@@ -206,12 +205,11 @@ public class ShadowContextImplTest {
     ServiceConnection serviceConnection = buildServiceConnection();
     int flags = 0;
 
-    try {
-      context.bindServiceAsUser(serviceIntent, serviceConnection, flags, Process.myUserHandle());
-      fail("bindServiceAsUser should throw IllegalArgumentException!");
-    } catch (IllegalArgumentException e) {
-      // expected
-    }
+    assertThrows(
+        IllegalArgumentException.class,
+        () ->
+            context.bindServiceAsUser(
+                serviceIntent, serviceConnection, flags, Process.myUserHandle()));
   }
 
   @Test
@@ -226,29 +224,14 @@ public class ShadowContextImplTest {
   }
 
   @Test
-  public void bindService_shouldAllowImplicitIntentPreLollipop() {
-    context.getApplicationInfo().targetSdkVersion = KITKAT;
-    Intent serviceIntent = new Intent();
-    ServiceConnection serviceConnection = buildServiceConnection();
-    int flags = 0;
-
-    assertThat(context.bindService(serviceIntent, serviceConnection, flags)).isTrue();
-
-    assertThat(shadowOf(context).getBoundServiceConnections()).hasSize(1);
-  }
-
-  @Test
-  public void bindService_shouldThrowOnImplicitIntentOnLollipop() {
+  public void bindService_shouldThrowOnImplicitIntent() {
     Intent serviceIntent = new Intent();
     ServiceConnection serviceConnection = buildServiceConnection();
     int flags = 0;
 
-    try {
-      context.bindService(serviceIntent, serviceConnection, flags);
-      fail("bindService should throw IllegalArgumentException!");
-    } catch (IllegalArgumentException e) {
-      // expected
-    }
+    assertThrows(
+        IllegalArgumentException.class,
+        () -> context.bindService(serviceIntent, serviceConnection, flags));
   }
 
   @Test
@@ -293,36 +276,15 @@ public class ShadowContextImplTest {
   }
 
   @Test
-  public void startService_shouldAllowImplicitIntentPreLollipop() {
-    context.getApplicationInfo().targetSdkVersion = KITKAT;
-    context.startService(new Intent("dummy_action"));
-    assertThat(shadowOf(context).getNextStartedService().getAction()).isEqualTo("dummy_action");
-  }
-
-  @Test
-  public void startService_shouldThrowOnImplicitIntentOnLollipop() {
-    try {
-      context.startService(new Intent("dummy_action"));
-      fail("startService should throw IllegalArgumentException!");
-    } catch (IllegalArgumentException e) {
-      // expected
-    }
+  public void startService_shouldThrowOnImplicitIntent() {
+    assertThrows(
+        IllegalArgumentException.class, () -> context.startService(new Intent("dummy_action")));
   }
 
   @Test
-  public void stopService_shouldAllowImplicitIntentPreLollipop() {
-    context.getApplicationInfo().targetSdkVersion = KITKAT;
-    context.stopService(new Intent("dummy_action"));
-  }
-
-  @Test
-  public void stopService_shouldThrowOnImplicitIntentOnLollipop() {
-    try {
-      context.stopService(new Intent("dummy_action"));
-      fail("stopService should throw IllegalArgumentException!");
-    } catch (IllegalArgumentException e) {
-      // expected
-    }
+  public void stopService_shouldThrowOnImplicitIntent() {
+    assertThrows(
+        IllegalArgumentException.class, () -> context.stopService(new Intent("dummy_action")));
   }
 
   @Test
@@ -357,12 +319,12 @@ public class ShadowContextImplTest {
     context.sendOrderedBroadcastAsUser(
         intent,
         userHandle,
-        /*receiverPermission=*/ null,
-        /*resultReceiver=*/ null,
-        /*scheduler=*/ null,
-        /*initialCode=*/ 0,
-        /*initialData=*/ null,
-        /*initialExtras=*/ null);
+        /* receiverPermission= */ null,
+        /* resultReceiver= */ null,
+        /* scheduler= */ null,
+        /* initialCode= */ 0,
+        /* initialData= */ null,
+        /* initialExtras= */ null);
 
     assertThat(shadowOf(context).getBroadcastIntents().get(0).getAction()).isEqualTo(action);
     assertThat(shadowOf(context).getBroadcastIntentsForUser(userHandle).get(0).getAction())
@@ -371,12 +333,8 @@ public class ShadowContextImplTest {
 
   @Test
   public void createPackageContext_absent() {
-    try {
-      context.createPackageContext("doesnt.exist", 0);
-      fail("Should throw NameNotFoundException");
-    } catch (NameNotFoundException e) {
-      // expected
-    }
+    assertThrows(
+        NameNotFoundException.class, () -> context.createPackageContext("does.not.exist", 0));
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextTest.java
index 51f71d358..5ef5e86fe 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextTest.java
@@ -24,9 +24,7 @@ import org.robolectric.R;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 
-/**
- * Tests of the {@link ShadowContextImpl} class
- */
+/** Tests of the {@link ShadowContextImpl} class */
 @RunWith(AndroidJUnit4.class)
 public class ShadowContextTest {
   private final Context context = ApplicationProvider.getApplicationContext();
@@ -57,8 +55,14 @@ public class ShadowContextTest {
 
   @Test
   public void shouldCreateIfDoesNotExistAndGetApplicationDataDirectory() throws Exception {
-    File dataDir = new File(context.getPackageManager()
-        .getPackageInfo("org.robolectric", 0).applicationInfo.dataDir, "data");
+    File dataDir =
+        new File(
+            context
+                .getPackageManager()
+                .getPackageInfo("org.robolectric", 0)
+                .applicationInfo
+                .dataDir,
+            "data");
 
     assertThat(dataDir.exists()).isFalse();
 
@@ -89,10 +93,8 @@ public class ShadowContextTest {
     assertThat(context.getCacheDir()).isNotNull();
     File cacheTest = new File(context.getCacheDir(), "__test__");
 
-    assertThat(cacheTest.getAbsolutePath())
-      .startsWith(System.getProperty("java.io.tmpdir"));
-    assertThat(cacheTest.getAbsolutePath())
-        .endsWith(File.separator + "__test__");
+    assertThat(cacheTest.getAbsolutePath()).startsWith(System.getProperty("java.io.tmpdir"));
+    assertThat(cacheTest.getAbsolutePath()).endsWith(File.separator + "__test__");
 
     try (FileOutputStream fos = new FileOutputStream(cacheTest)) {
       fos.write("test".getBytes(UTF_8));
@@ -105,10 +107,8 @@ public class ShadowContextTest {
     assertThat(context.getExternalCacheDir()).isNotNull();
     File cacheTest = new File(context.getExternalCacheDir(), "__test__");
 
-    assertThat(cacheTest.getAbsolutePath())
-      .startsWith(System.getProperty("java.io.tmpdir"));
-    assertThat(cacheTest.getAbsolutePath())
-      .endsWith(File.separator + "__test__");
+    assertThat(cacheTest.getAbsolutePath()).startsWith(System.getProperty("java.io.tmpdir"));
+    assertThat(cacheTest.getAbsolutePath()).endsWith(File.separator + "__test__");
 
     try (FileOutputStream fos = new FileOutputStream(cacheTest)) {
       fos.write("test".getBytes(UTF_8));
@@ -154,15 +154,15 @@ public class ShadowContextTest {
 
   @Test
   public void getDatabasePath_shouldAllowAbsolutePaths() {
-      String testDbName;
-
-      if (System.getProperty("os.name").startsWith("Windows")) {
-        testDbName = "C:\\absolute\\full\\path\\to\\db\\abc.db";
-      } else {
-        testDbName = "/absolute/full/path/to/db/abc.db";
-      }
-      File dbFile = context.getDatabasePath(testDbName);
-      assertThat(dbFile).isEqualTo(new File(testDbName));
+    String testDbName;
+
+    if (System.getProperty("os.name").startsWith("Windows")) {
+      testDbName = "C:\\absolute\\full\\path\\to\\db\\abc.db";
+    } else {
+      testDbName = "/absolute/full/path/to/db/abc.db";
+    }
+    File dbFile = context.getDatabasePath(testDbName);
+    assertThat(dbFile).isEqualTo(new File(testDbName));
   }
 
   @Test
@@ -195,7 +195,8 @@ public class ShadowContextTest {
         context.openFileOutput("__test__", Context.MODE_PRIVATE)) {
       fileOutputStream.write(fileContents.getBytes(UTF_8));
     }
-    try (FileInputStream fileInputStream = new FileInputStream(new File(context.getFilesDir(), file.getName()))) {
+    try (FileInputStream fileInputStream =
+        new FileInputStream(new File(context.getFilesDir(), file.getName()))) {
       byte[] readBuffer = new byte[fileContents.length()];
       fileInputStream.read(readBuffer);
       assertThat(new String(readBuffer, UTF_8)).isEqualTo(fileContents);
@@ -223,7 +224,8 @@ public class ShadowContextTest {
         context.openFileOutput("__test__", Context.MODE_APPEND)) {
       fileOutputStream.write(appendedFileContents.getBytes(UTF_8));
     }
-    try (FileInputStream fileInputStream = new FileInputStream(new File(context.getFilesDir(), file.getName()))) {
+    try (FileInputStream fileInputStream =
+        new FileInputStream(new File(context.getFilesDir(), file.getName()))) {
       byte[] readBuffer = new byte[finalFileContents.length()];
       fileInputStream.read(readBuffer);
       assertThat(new String(readBuffer, UTF_8)).isEqualTo(finalFileContents);
@@ -241,7 +243,8 @@ public class ShadowContextTest {
     try (FileOutputStream fileOutputStream = context.openFileOutput("__test__", 0)) {
       fileOutputStream.write(newFileContents.getBytes(UTF_8));
     }
-    try (FileInputStream fileInputStream = new FileInputStream(new File(context.getFilesDir(), file.getName()))) {
+    try (FileInputStream fileInputStream =
+        new FileInputStream(new File(context.getFilesDir(), file.getName()))) {
       byte[] readBuffer = new byte[newFileContents.length()];
       fileInputStream.read(readBuffer);
       assertThat(new String(readBuffer, UTF_8)).isEqualTo(newFileContents);
@@ -268,13 +271,14 @@ public class ShadowContextTest {
 
   @Test
   public void obtainStyledAttributes_shouldExtractAttributesFromAttributeSet() {
-    AttributeSet roboAttributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(R.attr.itemType, "ungulate")
-        .addAttribute(R.attr.scrollBars, "horizontal|vertical")
-        .addAttribute(R.attr.quitKeyCombo, "^q")
-        .addAttribute(R.attr.aspectRatio, "1.5")
-        .addAttribute(R.attr.aspectRatioEnabled, "true")
-        .build();
+    AttributeSet roboAttributeSet =
+        Robolectric.buildAttributeSet()
+            .addAttribute(R.attr.itemType, "ungulate")
+            .addAttribute(R.attr.scrollBars, "horizontal|vertical")
+            .addAttribute(R.attr.quitKeyCombo, "^q")
+            .addAttribute(R.attr.aspectRatio, "1.5")
+            .addAttribute(R.attr.aspectRatioEnabled, "true")
+            .build();
 
     TypedArray a = context.obtainStyledAttributes(roboAttributeSet, R.styleable.CustomView);
     assertThat(a.getInt(R.styleable.CustomView_itemType, -1234)).isEqualTo(1 /* ungulate */);
@@ -284,7 +288,9 @@ public class ShadowContextTest {
     assertThat(a.getFloat(R.styleable.CustomView_aspectRatio, 1f)).isEqualTo(1.5f);
     assertThat(a.getBoolean(R.styleable.CustomView_aspectRatioEnabled, false)).isTrue();
 
-    TypedArray typedArray = context.obtainStyledAttributes(roboAttributeSet, new int[]{R.attr.quitKeyCombo, R.attr.itemType});
+    TypedArray typedArray =
+        context.obtainStyledAttributes(
+            roboAttributeSet, new int[] {R.attr.quitKeyCombo, R.attr.itemType});
     assertThat(typedArray.getString(0)).isEqualTo("^q");
     assertThat(typedArray.getInt(1, -1234)).isEqualTo(1 /* ungulate */);
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextWrapperTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextWrapperTest.java
index 502e1a4be..d0caf82d3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextWrapperTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextWrapperTest.java
@@ -186,7 +186,7 @@ public class ShadowContextWrapperTest {
         /* broadcastPermission= */ null,
         /* scheduler= */ null);
 
-    contextWrapper.sendBroadcast(new Intent("foo"), /*receiverPermission=*/ "larryPermission");
+    contextWrapper.sendBroadcast(new Intent("foo"), /* receiverPermission= */ "larryPermission");
 
     asyncAssertThat(transcript).containsExactly("Larry notified of foo");
   }
@@ -206,7 +206,7 @@ public class ShadowContextWrapperTest {
         /* scheduler= */ null);
 
     Context broadcaster = contextWithPermission("broadcasterPackage", "larryPermission");
-    broadcaster.sendBroadcast(new Intent("foo"), /*receiverPermission=*/ null);
+    broadcaster.sendBroadcast(new Intent("foo"), /* receiverPermission= */ null);
 
     asyncAssertThat(transcript).containsExactly("Larry notified of foo");
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCountDownTimerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCountDownTimerTest.java
index 78077736d..0637239a0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCountDownTimerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCountDownTimerTest.java
@@ -36,7 +36,6 @@ public class ShadowCountDownTimerTest {
     shadowCountDownTimer = Shadows.shadowOf(countDownTimer);
   }
 
-
   @Test
   public void testInvokeOnTick() {
     assertThat(msg).isNotEqualTo("onTick() is called");
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCursorAdapterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCursorAdapterTest.java
index 88c5987b6..598ec2579 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCursorAdapterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCursorAdapterTest.java
@@ -27,11 +27,11 @@ public class ShadowCursorAdapterTest {
     database = SQLiteDatabase.create(null);
     database.execSQL("CREATE TABLE table_name(_id INT PRIMARY KEY, name VARCHAR(255));");
     String[] inserts = {
-        "INSERT INTO table_name (_id, name) VALUES(1234, 'Chuck');",
-        "INSERT INTO table_name (_id, name) VALUES(1235, 'Julie');",
-        "INSERT INTO table_name (_id, name) VALUES(1236, 'Chris');",
-        "INSERT INTO table_name (_id, name) VALUES(1237, 'Brenda');",
-        "INSERT INTO table_name (_id, name) VALUES(1238, 'Jane');"
+      "INSERT INTO table_name (_id, name) VALUES(1234, 'Chuck');",
+      "INSERT INTO table_name (_id, name) VALUES(1235, 'Julie');",
+      "INSERT INTO table_name (_id, name) VALUES(1236, 'Chris');",
+      "INSERT INTO table_name (_id, name) VALUES(1237, 'Brenda');",
+      "INSERT INTO table_name (_id, name) VALUES(1238, 'Jane');"
     };
 
     for (String insert : inserts) {
@@ -87,7 +87,8 @@ public class ShadowCursorAdapterTest {
     }
   }
 
-  @Test public void shouldNotErrorOnCursorChangeWhenNoFlagsAreSet() throws Exception {
+  @Test
+  public void shouldNotErrorOnCursorChangeWhenNoFlagsAreSet() throws Exception {
     try (Cursor newCursor = database.rawQuery("SELECT * FROM table_name;", null)) {
       adapter = new TestAdapterWithFlags(curs, 0);
       adapter.changeCursor(newCursor);
@@ -102,8 +103,7 @@ public class ShadowCursorAdapterTest {
     }
 
     @Override
-    public void bindView(View view, Context context, Cursor cursor) {
-    }
+    public void bindView(View view, Context context, Cursor cursor) {}
 
     @Override
     public View newView(Context context, Cursor cursor, ViewGroup parent) {
@@ -116,11 +116,12 @@ public class ShadowCursorAdapterTest {
       super(ApplicationProvider.getApplicationContext(), c, flags);
     }
 
-    @Override public View newView(Context context, Cursor cursor, ViewGroup parent) {
+    @Override
+    public View newView(Context context, Cursor cursor, ViewGroup parent) {
       return null;
     }
 
-    @Override public void bindView(View view, Context context, Cursor cursor) {
-    }
+    @Override
+    public void bindView(View view, Context context, Cursor cursor) {}
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCursorWindowTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCursorWindowTest.java
index f21dcdf0d..0f8329ac2 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCursorWindowTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCursorWindowTest.java
@@ -23,13 +23,13 @@ public class ShadowCursorWindowTest {
   @Test
   public void shouldFillWindowWithCursor() {
     CursorWindow window = new CursorWindow("name");
-    MatrixCursor testCursor = new MatrixCursor(new String[] { "a", "b", "c", "d"});
+    MatrixCursor testCursor = new MatrixCursor(new String[] {"a", "b", "c", "d"});
     testCursor.addRow(
         new Object[] {
           12, "hello", null, new byte[] {(byte) 0xba, (byte) 0xdc, (byte) 0xaf, (byte) 0xfe}
         });
-    testCursor.addRow(new Object[] { 34, "baz",   1.2,  null  });
-    testCursor.addRow(new Object[] { 46, "foo",   2.4,  new byte[]{}  });
+    testCursor.addRow(new Object[] {34, "baz", 1.2, null});
+    testCursor.addRow(new Object[] {46, "foo", 2.4, new byte[] {}});
 
     DatabaseUtils.cursorFillWindow(testCursor, 0, window);
 
@@ -38,14 +38,15 @@ public class ShadowCursorWindowTest {
     assertThat(window.getInt(0, 0)).isEqualTo(12);
     assertThat(window.getString(0, 1)).isEqualTo("hello");
     assertThat(window.getString(0, 2)).isNull();
-    assertThat(window.getBlob(0, 3)).isEqualTo(new byte[] {(byte) 0xba, (byte) 0xdc, (byte) 0xaf, (byte) 0xfe});
+    assertThat(window.getBlob(0, 3))
+        .isEqualTo(new byte[] {(byte) 0xba, (byte) 0xdc, (byte) 0xaf, (byte) 0xfe});
 
     assertThat(window.getInt(1, 0)).isEqualTo(34);
     assertThat(window.getString(1, 1)).isEqualTo("baz");
     assertThat(window.getFloat(1, 2)).isEqualTo(1.2f);
     assertThat(window.getBlob(1, 3)).isEqualTo(null);
 
-    assertThat(window.getBlob(2, 3)).isEqualTo(new byte[]{});
+    assertThat(window.getBlob(2, 3)).isEqualTo(new byte[] {});
     testCursor.close();
     window.close();
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCursorWrapperTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCursorWrapperTest.java
index 78bbe8f5a..ae5a67af7 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCursorWrapperTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCursorWrapperTest.java
@@ -49,7 +49,6 @@ public class ShadowCursorWrapperTest {
       method.invoke(verify(mockCursor, times(1)), params);
       Mockito.verifyNoMoreInteractions(mockCursor);
     }
-
   }
 
   @Test
@@ -95,7 +94,6 @@ public class ShadowCursorWrapperTest {
     v.verifyForward("setNotificationUri", mock(ContentResolver.class), mock(Uri.class));
     v.verifyForward("unregisterContentObserver", mock(ContentObserver.class));
     v.verifyForward("unregisterDataSetObserver", mock(DataSetObserver.class));
-
   }
 
   @Test
@@ -106,5 +104,4 @@ public class ShadowCursorWrapperTest {
 
     assertThat(shadow.getWrappedCursor()).isSameInstanceAs(mockCursor);
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDatePickerDialogTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDatePickerDialogTest.java
index 50feac245..625917444 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDatePickerDialogTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDatePickerDialogTest.java
@@ -65,7 +65,7 @@ public class ShadowDatePickerDialogTest {
             ApplicationProvider.getApplicationContext(), expectedDateSetListener, 2012, 6, 7);
 
     ShadowDatePickerDialog shadowDatePickerDialog = shadowOf(datePickerDialog);
-    assertThat(shadowDatePickerDialog.getOnDateSetListenerCallback()).isEqualTo(expectedDateSetListener);
+    assertThat(shadowDatePickerDialog.getOnDateSetListenerCallback())
+        .isEqualTo(expectedDateSetListener);
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDevicePolicyManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDevicePolicyManagerTest.java
index 564ceb778..fea652f74 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDevicePolicyManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDevicePolicyManagerTest.java
@@ -839,6 +839,115 @@ public final class ShadowDevicePolicyManagerTest {
         .isTrue();
   }
 
+  @Test
+  @Config(minSdk = O)
+  public void setDelegatedScopes_secondTime_overridesPreviousDelegatedScopes() {
+    // GIVEN the caller is the device owner
+    shadowOf(devicePolicyManager).setDeviceOwner(testComponent);
+
+    // GIVEN the caller has delegated scopes
+    List<String> initialScopes = Arrays.asList(DevicePolicyManager.DELEGATION_APP_RESTRICTIONS);
+    devicePolicyManager.setDelegatedScopes(testComponent, "com.example.app", initialScopes);
+
+    // WHEN setDelegatedScopes is called again
+    List<String> newScopes = Arrays.asList(DevicePolicyManager.DELEGATION_ENABLE_SYSTEM_APP);
+    devicePolicyManager.setDelegatedScopes(testComponent, "com.example.app", newScopes);
+
+    // THEN the new scopes should be set
+    assertThat(devicePolicyManager.getDelegatedScopes(testComponent, "com.example.app"))
+        .containsExactlyElementsIn(newScopes);
+  }
+
+  @Test
+  @Config(minSdk = O)
+  public void getDelegatedScopes_notDeviceOwner_throwsSecurityException() {
+    // GIVEN the caller is not the device owner
+
+    // WHEN getDelegatedScopes is called
+    // THEN it should throw SecurityException
+    assertThrows(
+        SecurityException.class,
+        () -> devicePolicyManager.getDelegatedScopes(testComponent, "com.example.app"));
+  }
+
+  @Test
+  @Config(minSdk = O)
+  public void getDelegatedScopes_noDelegatedScopes_returnsEmptyList() {
+    // GIVEN the caller is the device owner
+    ComponentName caller = new ComponentName(context.getPackageName(), "DeviceAdminComponent");
+    shadowOf(devicePolicyManager).setDeviceOwner(caller);
+
+    // WHEN getDelegatedScopes is called
+    // THEN it should return empty list
+    assertThat(devicePolicyManager.getDelegatedScopes(caller, "com.example.app")).isEmpty();
+  }
+
+  @Test
+  @Config(minSdk = O)
+  public void getDelegatedScopes_callerIsDeviceOwner_returnsDelegatedScopes() {
+    // GIVEN the caller is the device owner
+    ComponentName caller = new ComponentName(context.getPackageName(), "DeviceAdminComponent");
+    shadowOf(devicePolicyManager).setDeviceOwner(caller);
+
+    // GIVEN the caller has delegated scopes
+    String delegatedApp = "com.example.app";
+    List<String> scopes =
+        Arrays.asList(
+            DevicePolicyManager.DELEGATION_APP_RESTRICTIONS,
+            DevicePolicyManager.DELEGATION_PERMISSION_GRANT);
+    devicePolicyManager.setDelegatedScopes(caller, delegatedApp, scopes);
+    String otherApp = "com.example.other.app";
+    devicePolicyManager.setDelegatedScopes(
+        caller,
+        otherApp,
+        Arrays.asList(
+            DevicePolicyManager.DELEGATION_ENABLE_SYSTEM_APP,
+            DevicePolicyManager.DELEGATION_PERMISSION_GRANT));
+
+    // WHEN getDelegatedScopes is called
+    // THEN it should return the correct scopes
+    assertThat(devicePolicyManager.getDelegatedScopes(caller, delegatedApp))
+        .containsExactlyElementsIn(scopes);
+  }
+
+  @Test
+  @Config(minSdk = O)
+  public void getDelegatedScopes_notOwner_failsToReturnScopesForOtherApp() {
+    // GIVEN the caller is not the device owner
+    // WHEN getDelegatedScopes is called
+    // THEN it should throw SecurityException
+    assertThrows(
+        SecurityException.class,
+        () -> devicePolicyManager.getDelegatedScopes(/* admin= */ null, "com.example.app"));
+  }
+
+  @Test
+  @Config(minSdk = O)
+  public void getDelegatedScopes_notOwner_returnScopesForSelf() {
+    // GIVEN the caller is not the device owner
+    shadowOf(devicePolicyManager).setDeviceOwner(testComponent);
+
+    // GIVEN the caller has delegated scopes
+    String delegatedApp = context.getPackageName();
+    List<String> scopes =
+        Arrays.asList(
+            DevicePolicyManager.DELEGATION_APP_RESTRICTIONS,
+            DevicePolicyManager.DELEGATION_PERMISSION_GRANT);
+    devicePolicyManager.setDelegatedScopes(testComponent, delegatedApp, scopes);
+    String otherApp = "com.example.other.app";
+    devicePolicyManager.setDelegatedScopes(
+        testComponent,
+        otherApp,
+        Arrays.asList(
+            DevicePolicyManager.DELEGATION_ENABLE_SYSTEM_APP,
+            DevicePolicyManager.DELEGATION_PERMISSION_GRANT));
+
+    // WHEN getDelegatedScopes is called
+    // THEN it should return the correct scopes
+    assertThat(devicePolicyManager.getDelegatedScopes(/* admin= */ null, delegatedApp))
+        .containsExactlyElementsIn(scopes);
+  }
+
   @Test
   public void getAccountTypesWithManagementDisabledShouldReturnNothingWhenNoAccountIsDislabed() {
     // GIVEN no account type has ever been disabled
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDialogTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDialogTest.java
index e5561e9f7..ebe78215d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDialogTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDialogTest.java
@@ -210,7 +210,8 @@ public class ShadowDialogTest {
       onStartCalled = true;
     }
 
-    @Override public void dismiss() {
+    @Override
+    public void dismiss() {
       super.dismiss();
       wasDismissed = true;
     }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerTest.java
index 5c9228e89..f044f1a33 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerTest.java
@@ -88,6 +88,13 @@ public class ShadowDisplayManagerTest {
     assertThat(display.getName()).isEqualTo("Built-in screen");
   }
 
+  @Test
+  public void addDisplay_withGivenType_shouldReflectInAddedDisplay() {
+    int displayId = ShadowDisplayManager.addDisplay("w100dp-h200dp", Display.TYPE_EXTERNAL);
+
+    assertThat(instance.getDisplay(displayId).getType()).isEqualTo(Display.TYPE_EXTERNAL);
+  }
+
   @Test
   public void addDisplay_withName_shouldReflectInAddedDisplay() {
     int displayId = ShadowDisplayManager.addDisplay("w100dp-h200dp", "VirtualDevice_1");
@@ -506,8 +513,7 @@ public class ShadowDisplayManagerTest {
         .contains("configureDefaultDisplay was called a second time");
   }
 
-  // because DisplayManagerGlobal don't exist in Jelly Bean,
-  // and we don't want them resolved as part of the test class.
+  // because we don't want DisplayManagerGlobal resolved as part of the test class.
   static class HideFromJB {
     public static DisplayManagerGlobal getGlobal() {
       return DisplayManagerGlobal.getInstance();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayTest.java
index 099c9105e..d8772eca4 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayTest.java
@@ -141,8 +141,8 @@ public class ShadowDisplayTest {
   }
 
   /**
-   * The {@link android.view.Display#getOrientation()} method is deprecated, but for
-   * testing purposes, return the value gotten from {@link android.view.Display#getRotation()}
+   * The {@link android.view.Display#getOrientation()} method is deprecated, but for testing
+   * purposes, return the value gotten from {@link android.view.Display#getRotation()}
    */
   @Test
   public void deprecatedGetOrientation_returnsGetRotation() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDrawableTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDrawableTest.java
index ced87af17..9232b0bcc 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDrawableTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDrawableTest.java
@@ -91,7 +91,8 @@ public class ShadowDrawableTest {
     assertThat(context.getResources().getDrawable(R.drawable.drawable_with_nine_patch)).isNotNull();
   }
 
-  @Test public void settingBoundsShouldInvokeCallback() {
+  @Test
+  public void settingBoundsShouldInvokeCallback() {
     TestDrawable drawable = new TestDrawable();
     assertThat(drawable.boundsChanged).isFalse();
     drawable.setBounds(0, 0, 10, 10);
@@ -134,23 +135,21 @@ public class ShadowDrawableTest {
     public boolean boundsChanged;
 
     @Override
-    public void draw(Canvas canvas) {
-    }
+    public void draw(Canvas canvas) {}
 
     @Override
-    public void setAlpha(int alpha) {
-    }
+    public void setAlpha(int alpha) {}
 
     @Override
-    public void setColorFilter(ColorFilter cf) {
-    }
+    public void setColorFilter(ColorFilter cf) {}
 
     @Override
     public int getOpacity() {
       return 0;
     }
 
-    @Override protected void onBoundsChange(Rect bounds) {
+    @Override
+    protected void onBoundsChange(Rect bounds) {
       boundsChanged = true;
       super.onBoundsChange(bounds);
     }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowEGL14Test.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowEGL14Test.java
index 459b75b65..8a75dc35d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowEGL14Test.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowEGL14Test.java
@@ -6,15 +6,12 @@ import android.opengl.EGL14;
 import android.opengl.EGLConfig;
 import android.opengl.EGLContext;
 import android.opengl.EGLDisplay;
-import android.os.Build.VERSION_CODES;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
 
 /** Unit tests for {@link ShadowEGL14Test} */
 @RunWith(AndroidJUnit4.class)
-@Config(minSdk = VERSION_CODES.LOLLIPOP)
 public final class ShadowEGL14Test {
   @Test
   public void eglGetCurrentContext() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowEditTextTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowEditTextTest.java
index 10446715f..95d892567 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowEditTextTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowEditTextTest.java
@@ -22,9 +22,8 @@ public class ShadowEditTextTest {
 
   @Before
   public void setup() {
-    AttributeSet attributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(android.R.attr.maxLength, "5")
-        .build();
+    AttributeSet attributeSet =
+        Robolectric.buildAttributeSet().addAttribute(android.R.attr.maxLength, "5").build();
 
     context = ApplicationProvider.getApplicationContext();
     editText = new EditText(context, attributeSet);
@@ -43,11 +42,13 @@ public class ShadowEditTextTest {
   }
 
   @Test
-  public void givenInitializingWithAttributeSet_whenMaxLengthDefined_thenRestrictTextLengthToMaxLength() {
+  public void
+      givenInitializingWithAttributeSet_whenMaxLengthDefined_thenRestrictTextLengthToMaxLength() {
     int maxLength = anyInteger();
-    AttributeSet attrs = Robolectric.buildAttributeSet()
-        .addAttribute(android.R.attr.maxLength, maxLength + "")
-        .build();
+    AttributeSet attrs =
+        Robolectric.buildAttributeSet()
+            .addAttribute(android.R.attr.maxLength, maxLength + "")
+            .build();
 
     EditText editText = new EditText(context, attrs);
     String excessiveInput = stringOfLength(maxLength * 2);
@@ -59,7 +60,8 @@ public class ShadowEditTextTest {
   }
 
   @Test
-  public void givenInitializingWithAttributeSet_whenMaxLengthNotDefined_thenTextLengthShouldHaveNoRestrictions() {
+  public void
+      givenInitializingWithAttributeSet_whenMaxLengthNotDefined_thenTextLengthShouldHaveNoRestrictions() {
     AttributeSet attrs = Robolectric.buildAttributeSet().build();
     EditText editText = new EditText(context, attrs);
     String input = anyString();
@@ -104,8 +106,7 @@ public class ShadowEditTextTest {
   private String stringOfLength(int length) {
     StringBuilder stringBuilder = new StringBuilder();
 
-    for (int i = 0; i < length; i++)
-      stringBuilder.append('x');
+    for (int i = 0; i < length; i++) stringBuilder.append('x');
 
     return stringBuilder.toString();
   }
@@ -113,5 +114,4 @@ public class ShadowEditTextTest {
   private int anyInteger() {
     return new Random().nextInt(1000) + 1;
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowEnvironmentTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowEnvironmentTest.java
index cb29f8677..b815fe4e9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowEnvironmentTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowEnvironmentTest.java
@@ -86,7 +86,9 @@ public class ShadowEnvironmentTest {
   public void getExternalStoragePublicDirectory_shouldReturnDirectory() {
     final File path = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES);
     assertThat(path.exists()).isTrue();
-    assertThat(path).isEqualTo(new File(ShadowEnvironment.EXTERNAL_FILES_DIR.toFile(), Environment.DIRECTORY_MOVIES));
+    assertThat(path)
+        .isEqualTo(
+            new File(ShadowEnvironment.EXTERNAL_FILES_DIR.toFile(), Environment.DIRECTORY_MOVIES));
   }
 
   @Test
@@ -253,7 +255,7 @@ public class ShadowEnvironmentTest {
   }
 
   @Test
-  @Config(maxSdk = LOLLIPOP)
+  @Config(sdk = LOLLIPOP)
   public void getExternalStorageStatePreLollipopMR1() {
     File storageDir1 = ShadowEnvironment.addExternalDir("dir1");
     File storageDir2 = ShadowEnvironment.addExternalDir("dir2");
@@ -261,10 +263,8 @@ public class ShadowEnvironmentTest {
     ShadowEnvironment.setExternalStorageState(storageDir2, Environment.MEDIA_REMOVED);
     ShadowEnvironment.setExternalStorageState("blah");
 
-    assertThat(ShadowEnvironment.getStorageState(storageDir1))
-        .isEqualTo(Environment.MEDIA_MOUNTED);
-    assertThat(ShadowEnvironment.getStorageState(storageDir2))
-        .isEqualTo(Environment.MEDIA_REMOVED);
+    assertThat(ShadowEnvironment.getStorageState(storageDir1)).isEqualTo(Environment.MEDIA_MOUNTED);
+    assertThat(ShadowEnvironment.getStorageState(storageDir2)).isEqualTo(Environment.MEDIA_REMOVED);
     assertThat(ShadowEnvironment.getStorageState(new File(storageDir1, "subpath")))
         .isEqualTo(Environment.MEDIA_MOUNTED);
     assertThat(ShadowEnvironment.getExternalStorageState()).isEqualTo("blah");
@@ -281,12 +281,10 @@ public class ShadowEnvironmentTest {
 
     assertThat(ShadowEnvironment.getExternalStorageState(storageDir1))
         .isEqualTo(Environment.MEDIA_MOUNTED);
-    assertThat(ShadowEnvironment.getStorageState(storageDir1))
-        .isEqualTo(Environment.MEDIA_MOUNTED);
+    assertThat(ShadowEnvironment.getStorageState(storageDir1)).isEqualTo(Environment.MEDIA_MOUNTED);
     assertThat(ShadowEnvironment.getExternalStorageState(storageDir2))
         .isEqualTo(Environment.MEDIA_REMOVED);
-    assertThat(ShadowEnvironment.getStorageState(storageDir2))
-        .isEqualTo(Environment.MEDIA_REMOVED);
+    assertThat(ShadowEnvironment.getStorageState(storageDir2)).isEqualTo(Environment.MEDIA_REMOVED);
     assertThat(ShadowEnvironment.getExternalStorageState(new File(storageDir1, "subpath")))
         .isEqualTo(Environment.MEDIA_MOUNTED);
     assertThat(ShadowEnvironment.getStorageState(new File(storageDir1, "subpath")))
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowEventLogTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowEventLogTest.java
index 639d91bc0..382b0defb 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowEventLogTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowEventLogTest.java
@@ -47,7 +47,7 @@ public class ShadowEventLogTest {
   }
 
   @Test
-  public void testAddEvent_testIntLog()  throws Exception {
+  public void testAddEvent_testIntLog() throws Exception {
     EventLog.Event event =
         new ShadowEventLog.EventBuilder(TEST_TAG, TEST_INT)
             .setProcessId(TEST_PROCESS_ID)
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowFileIntegrityManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowFileIntegrityManagerTest.java
index 35a1c2e40..36cc4e026 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowFileIntegrityManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowFileIntegrityManagerTest.java
@@ -2,7 +2,6 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.R;
 import static com.google.common.truth.Truth.assertThat;
-import static org.robolectric.Shadows.shadowOf;
 
 import android.security.FileIntegrityManager;
 import androidx.test.core.app.ApplicationProvider;
@@ -11,6 +10,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadow.api.Shadow;
 
 @RunWith(AndroidJUnit4.class)
 @Config(minSdk = R)
@@ -31,7 +31,8 @@ public final class ShadowFileIntegrityManagerTest {
 
   @Test
   public void isApkVeritySupported_setFalse_returnsFalse() {
-    shadowOf(fileIntegrityManager).setIsApkVeritySupported(false);
+    ((ShadowFileIntegrityManager) Shadow.extract(fileIntegrityManager))
+        .setIsApkVeritySupported(false);
 
     assertThat(fileIntegrityManager.isApkVeritySupported()).isFalse();
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowFilterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowFilterTest.java
index a1c548a1b..354df00b6 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowFilterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowFilterTest.java
@@ -15,19 +15,20 @@ public class ShadowFilterTest {
   public void testFilterShouldCallPerformFilteringAndPublishResults() {
     final AtomicBoolean performFilteringCalled = new AtomicBoolean(false);
     final AtomicBoolean publishResultsCalled = new AtomicBoolean(false);
-    Filter filter = new Filter() {
-      @Override
-      protected FilterResults performFiltering(CharSequence charSequence) {
-        performFilteringCalled.set(true);
-        return null;
-      }
+    Filter filter =
+        new Filter() {
+          @Override
+          protected FilterResults performFiltering(CharSequence charSequence) {
+            performFilteringCalled.set(true);
+            return null;
+          }
 
-      @Override
-      protected void publishResults(CharSequence charSequence, FilterResults filterResults) {
-        assertThat(filterResults).isNull();
-        publishResultsCalled.set(true);
-      }
-    };
+          @Override
+          protected void publishResults(CharSequence charSequence, FilterResults filterResults) {
+            assertThat(filterResults).isNull();
+            publishResultsCalled.set(true);
+          }
+        };
     filter.filter("");
     assertThat(performFilteringCalled.get()).isTrue();
     assertThat(publishResultsCalled.get()).isTrue();
@@ -36,21 +37,22 @@ public class ShadowFilterTest {
   @Test
   public void testFilterShouldCallListenerWithCorrectCount() {
     final AtomicBoolean listenerCalled = new AtomicBoolean(false);
-    Filter filter = new Filter() {
-      @Override
-      protected FilterResults performFiltering(CharSequence charSequence) {
-        FilterResults results = new FilterResults();
-        results.values = null;
-        results.count = 4;
-        return results;
-      }
+    Filter filter =
+        new Filter() {
+          @Override
+          protected FilterResults performFiltering(CharSequence charSequence) {
+            FilterResults results = new FilterResults();
+            results.values = null;
+            results.count = 4;
+            return results;
+          }
 
-      @Override
-      protected void publishResults(CharSequence charSequence, FilterResults filterResults) {
-        assertThat(filterResults.values).isNull();
-        assertThat(filterResults.count).isEqualTo(4);
-      }
-    };
+          @Override
+          protected void publishResults(CharSequence charSequence, FilterResults filterResults) {
+            assertThat(filterResults.values).isNull();
+            assertThat(filterResults.count).isEqualTo(4);
+          }
+        };
     filter.filter(
         "",
         i -> {
@@ -63,15 +65,16 @@ public class ShadowFilterTest {
   @Test
   public void testFilter_whenNullResults_ShouldCallListenerWithMinusOne() {
     final AtomicBoolean listenerCalled = new AtomicBoolean(false);
-    Filter filter = new Filter() {
-      @Override
-      protected FilterResults performFiltering(CharSequence charSequence) {
-        return null;
-      }
+    Filter filter =
+        new Filter() {
+          @Override
+          protected FilterResults performFiltering(CharSequence charSequence) {
+            return null;
+          }
 
-      @Override
-      protected void publishResults(CharSequence charSequence, FilterResults filterResults) {}
-    };
+          @Override
+          protected void publishResults(CharSequence charSequence, FilterResults filterResults) {}
+        };
     filter.filter(
         "",
         i -> {
@@ -84,15 +87,16 @@ public class ShadowFilterTest {
   @Test
   public void testFilter_whenExceptionThrown_ShouldReturn() {
     final AtomicBoolean listenerCalled = new AtomicBoolean(false);
-    Filter filter = new Filter() {
-      @Override
-      protected FilterResults performFiltering(CharSequence charSequence) {
-        throw new RuntimeException("unchecked exception during filtering");
-      }
+    Filter filter =
+        new Filter() {
+          @Override
+          protected FilterResults performFiltering(CharSequence charSequence) {
+            throw new RuntimeException("unchecked exception during filtering");
+          }
 
-      @Override
-      protected void publishResults(CharSequence charSequence, FilterResults filterResults) {}
-    };
+          @Override
+          protected void publishResults(CharSequence charSequence, FilterResults filterResults) {}
+        };
     filter.filter(
         "",
         resultCount -> {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowFingerprintManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowFingerprintManagerTest.java
index f0f827f41..76b080b28 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowFingerprintManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowFingerprintManagerTest.java
@@ -46,7 +46,8 @@ public class ShadowFingerprintManagerTest {
 
     shadowOf(manager).authenticationSucceeds();
 
-    ArgumentCaptor<AuthenticationResult> result = ArgumentCaptor.forClass(AuthenticationResult.class);
+    ArgumentCaptor<AuthenticationResult> result =
+        ArgumentCaptor.forClass(AuthenticationResult.class);
     verify(mockCallback).onAuthenticationSucceeded(result.capture());
 
     assertThat(result.getValue().getCryptoObject()).isEqualTo(cryptoObject);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowFrameLayoutTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowFrameLayoutTest.java
index ea4787cd3..f0e662067 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowFrameLayoutTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowFrameLayoutTest.java
@@ -31,7 +31,8 @@ public class ShadowFrameLayoutTest {
     assertThat(frameLayout.getHeight()).isEqualTo(0);
     assertThat(frameLayout.getWidth()).isEqualTo(0);
 
-    frameLayout.measure(View.MeasureSpec.makeMeasureSpec(150, View.MeasureSpec.AT_MOST),
+    frameLayout.measure(
+        View.MeasureSpec.makeMeasureSpec(150, View.MeasureSpec.AT_MOST),
         View.MeasureSpec.makeMeasureSpec(300, View.MeasureSpec.AT_MOST));
 
     assertThat(frameLayout.getHeight()).isEqualTo(0);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowGeocoderTTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowGeocoderTTest.java
index 87759abb0..fdf4ad0a9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowGeocoderTTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowGeocoderTTest.java
@@ -79,4 +79,64 @@ public class ShadowGeocoderTTest {
     assertThat(decodedAddresses).isNull();
     assertThat(errorMessage).isEqualTo(GEOCODER_ERROR_MESSAGE);
   }
+
+  @Test
+  @Config(minSdk = TIRAMISU)
+  public void getFromLocationNameSetsListenerWithTheOverwrittenListLimitingByMaxResults() {
+    ShadowGeocoder shadowGeocoder = shadowOf(geocoder);
+
+    List<Address> list =
+        Arrays.asList(new Address(Locale.getDefault()), new Address(Locale.CANADA));
+    shadowGeocoder.setFromLocation(list);
+
+    Geocoder.GeocodeListener geocodeListener = addresses -> decodedAddresses = addresses;
+
+    geocoder.getFromLocationName("test", 1, geocodeListener);
+    assertThat(decodedAddresses).containsExactly(list.get(0));
+
+    geocoder.getFromLocationName("test", 2, geocodeListener);
+    assertThat(decodedAddresses).containsExactly(list.get(0), list.get(1)).inOrder();
+
+    geocoder.getFromLocationName("test", 3, geocodeListener);
+    assertThat(decodedAddresses).containsExactly(list.get(0), list.get(1)).inOrder();
+  }
+
+  @Test
+  @Config(minSdk = TIRAMISU)
+  public void getFromLocationNameSetsListenerWithoutOverwrittenList() {
+    ShadowGeocoder shadowGeocoder = shadowOf(geocoder);
+
+    Geocoder.GeocodeListener geocodeListener = addresses -> decodedAddresses = addresses;
+    shadowGeocoder.getFromLocationName("test", 1, geocodeListener);
+
+    assertThat(decodedAddresses).hasSize(0);
+  }
+
+  @Test
+  @Config(minSdk = TIRAMISU)
+  public void getFromLocationName_onError() {
+    ShadowGeocoder shadowGeocoder = shadowOf(geocoder);
+
+    List<Address> list =
+        Arrays.asList(new Address(Locale.getDefault()), new Address(Locale.CANADA));
+    shadowGeocoder.setFromLocation(list);
+    shadowGeocoder.setErrorMessage(GEOCODER_ERROR_MESSAGE);
+
+    Geocoder.GeocodeListener geocodeListener =
+        new Geocoder.GeocodeListener() {
+          @Override
+          public void onGeocode(List<Address> list) {
+            decodedAddresses = list;
+          }
+
+          @Override
+          public void onError(@Nullable String message) {
+            errorMessage = message;
+          }
+        };
+
+    geocoder.getFromLocationName("test", 1, geocodeListener);
+    assertThat(decodedAddresses).isNull();
+    assertThat(errorMessage).isEqualTo(GEOCODER_ERROR_MESSAGE);
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowGeocoderTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowGeocoderTest.java
index 571e68cbe..00b5ac2e3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowGeocoderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowGeocoderTest.java
@@ -42,14 +42,15 @@ public class ShadowGeocoderTest {
 
   @Test
   public void getFromLocationReturnsAnEmptyArrayByDefault() throws IOException {
-    assertThat(geocoder.getFromLocation(90.0,90.0,1)).hasSize(0);
+    assertThat(geocoder.getFromLocation(90.0, 90.0, 1)).hasSize(0);
   }
 
   @Test
   public void getFromLocationReturnsTheOverwrittenListLimitingByMaxResults() throws IOException {
     ShadowGeocoder shadowGeocoder = shadowOf(geocoder);
 
-    List<Address> list = Arrays.asList(new Address(Locale.getDefault()), new Address(Locale.CANADA));
+    List<Address> list =
+        Arrays.asList(new Address(Locale.getDefault()), new Address(Locale.CANADA));
     shadowGeocoder.setFromLocation(list);
 
     List<Address> result = geocoder.getFromLocation(90.0, 90.0, 1);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowGestureDetectorTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowGestureDetectorTest.java
index 10ced80ef..5e31a4e30 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowGestureDetectorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowGestureDetectorTest.java
@@ -67,22 +67,23 @@ public class ShadowGestureDetectorTest {
   @Test
   public void getOnDoubleTapListener_shouldReturnSetDoubleTapListener() {
     GestureDetector subject = new GestureDetector(context, new TestOnGestureListener());
-    GestureDetector.OnDoubleTapListener onDoubleTapListener = new GestureDetector.OnDoubleTapListener() {
-      @Override
-      public boolean onSingleTapConfirmed(MotionEvent e) {
-        return false;
-      }
-
-      @Override
-      public boolean onDoubleTap(MotionEvent e) {
-        return false;
-      }
-
-      @Override
-      public boolean onDoubleTapEvent(MotionEvent e) {
-        return false;
-      }
-    };
+    GestureDetector.OnDoubleTapListener onDoubleTapListener =
+        new GestureDetector.OnDoubleTapListener() {
+          @Override
+          public boolean onSingleTapConfirmed(MotionEvent e) {
+            return false;
+          }
+
+          @Override
+          public boolean onDoubleTap(MotionEvent e) {
+            return false;
+          }
+
+          @Override
+          public boolean onDoubleTapEvent(MotionEvent e) {
+            return false;
+          }
+        };
 
     subject.setOnDoubleTapListener(onDoubleTapListener);
     assertEquals(shadowOf(subject).getOnDoubleTapListener(), onDoubleTapListener);
@@ -93,7 +94,8 @@ public class ShadowGestureDetectorTest {
 
   @Test
   public void getOnDoubleTapListener_shouldReturnOnGestureListenerFromConstructor() {
-    GestureDetector.OnGestureListener onGestureListener = new GestureDetector.SimpleOnGestureListener();
+    GestureDetector.OnGestureListener onGestureListener =
+        new GestureDetector.SimpleOnGestureListener();
     GestureDetector subject = new GestureDetector(context, onGestureListener);
     assertEquals(shadowOf(subject).getOnDoubleTapListener(), onGestureListener);
   }
@@ -105,8 +107,7 @@ public class ShadowGestureDetectorTest {
     }
 
     @Override
-    public void onShowPress(MotionEvent e) {
-    }
+    public void onShowPress(MotionEvent e) {}
 
     @Override
     public boolean onSingleTapUp(MotionEvent e) {
@@ -119,8 +120,7 @@ public class ShadowGestureDetectorTest {
     }
 
     @Override
-    public void onLongPress(MotionEvent e) {
-    }
+    public void onLongPress(MotionEvent e) {}
 
     @Override
     public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowHandlerThreadTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowHandlerThreadTest.java
index a64729bb8..ad3ff62c5 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowHandlerThreadTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowHandlerThreadTest.java
@@ -24,7 +24,7 @@ public class ShadowHandlerThreadTest {
   @After
   public void tearDown() throws Exception {
     // Try to ensure we've exited the thread at the end of each test
-    if ( handlerThread != null ) {
+    if (handlerThread != null) {
       handlerThread.quit();
       handlerThread.join();
     }
@@ -72,15 +72,16 @@ public class ShadowHandlerThreadTest {
 
   @Test
   public void shouldCallOnLooperPrepared() throws Exception {
-    final Boolean[] wasCalled = new Boolean[] { false };
+    final Boolean[] wasCalled = new Boolean[] {false};
     final CountDownLatch latch = new CountDownLatch(1);
-    handlerThread = new HandlerThread("test") {
-      @Override
-      protected void onLooperPrepared() {
-        wasCalled[0] = true;
-        latch.countDown();
-      }
-    };
+    handlerThread =
+        new HandlerThread("test") {
+          @Override
+          protected void onLooperPrepared() {
+            wasCalled[0] = true;
+            latch.countDown();
+          }
+        };
     handlerThread.start();
     try {
       assertNotNull(handlerThread.getLooper());
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowHtmlTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowHtmlTest.java
index cbd7a3889..654f51847 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowHtmlTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowHtmlTest.java
@@ -21,8 +21,8 @@ import org.robolectric.annotation.Config;
 @RunWith(AndroidJUnit4.class)
 public class ShadowHtmlTest {
   private static final String HTML_SHORT = "<img src='foo.png'>";
-  private static final String HTML_LONG = String.format("<img src='%s.png'>",
-      String.join("", Collections.nCopies(100, "foo")));
+  private static final String HTML_LONG =
+      String.format("<img src='%s.png'>", String.join("", Collections.nCopies(100, "foo")));
 
   private Context context;
 
@@ -58,28 +58,31 @@ public class ShadowHtmlTest {
   }
 
   @Config(maxSdk = M)
-  @Test public void testArraycopyLegacyShort() {
+  @Test
+  public void testArraycopyLegacyShort() {
     //noinspection deprecation
     Html.fromHtml(HTML_SHORT, null, null);
   }
 
   @Config(maxSdk = M)
-  @Test public void testArraycopyLegacyLong() {
+  @Test
+  public void testArraycopyLegacyLong() {
     //noinspection deprecation
     Html.fromHtml(HTML_LONG, null, null);
   }
 
-  @TargetApi(N) @Config(minSdk = N)
-  @Test public void testArraycopyShort() {
+  @TargetApi(N)
+  @Config(minSdk = N)
+  @Test
+  public void testArraycopyShort() {
     Html.fromHtml(HTML_SHORT, Html.FROM_HTML_MODE_LEGACY, null, null);
   }
 
-  /**
-   * this test requires that {@link org.ccil.cowan.tagsoup.HTMLScanner} be instrumented.
-   */
-  @TargetApi(N) @Config(minSdk = N)
-  @Test public void testArraycopyLong() {
+  /** this test requires that {@link org.ccil.cowan.tagsoup.HTMLScanner} be instrumented. */
+  @TargetApi(N)
+  @Config(minSdk = N)
+  @Test
+  public void testArraycopyLong() {
     Html.fromHtml(HTML_LONG, Html.FROM_HTML_MODE_LEGACY, null, null);
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowImageViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowImageViewTest.java
index b8d443814..cd5838294 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowImageViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowImageViewTest.java
@@ -27,7 +27,8 @@ public class ShadowImageViewTest {
     imageView.setImageBitmap(bitmap);
 
     imageView.setImageResource(R.drawable.an_image);
-    assertThat(shadowOf(imageView.getDrawable()).getCreatedFromResId()).isEqualTo(R.drawable.an_image);
+    assertThat(shadowOf(imageView.getDrawable()).getCreatedFromResId())
+        .isEqualTo(R.drawable.an_image);
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowIntentFilterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowIntentFilterTest.java
index 8cd3b7ca5..27afc863e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowIntentFilterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowIntentFilterTest.java
@@ -74,7 +74,7 @@ public class ShadowIntentFilterTest {
   }
 
   @Test
-  public void hasDataType() throws IntentFilter.MalformedMimeTypeException{
+  public void hasDataType() throws IntentFilter.MalformedMimeTypeException {
     IntentFilter intentFilter = new IntentFilter();
     assertThat(intentFilter.hasDataType("image/test")).isFalse();
     intentFilter.addDataType("image/test");
@@ -90,8 +90,10 @@ public class ShadowIntentFilterTest {
 
     Uri uriTest1 = Uri.parse("http://testHost1:1");
     Uri uriTest2 = Uri.parse("http://testHost2:2");
-    assertThat(intentFilter.matchDataAuthority(uriTest1)).isEqualTo(IntentFilter.MATCH_CATEGORY_PORT);
-    assertThat(intentFilter.matchDataAuthority(uriTest2)).isEqualTo(IntentFilter.MATCH_CATEGORY_PORT);
+    assertThat(intentFilter.matchDataAuthority(uriTest1))
+        .isEqualTo(IntentFilter.MATCH_CATEGORY_PORT);
+    assertThat(intentFilter.matchDataAuthority(uriTest2))
+        .isEqualTo(IntentFilter.MATCH_CATEGORY_PORT);
   }
 
   @Test
@@ -102,8 +104,10 @@ public class ShadowIntentFilterTest {
 
     Uri uriTest1 = Uri.parse("http://testHost1:100");
     Uri uriTest2 = Uri.parse("http://testHost2:200");
-    assertThat(intentFilter.matchDataAuthority(uriTest1)).isEqualTo(IntentFilter.MATCH_CATEGORY_HOST);
-    assertThat(intentFilter.matchDataAuthority(uriTest2)).isEqualTo(IntentFilter.MATCH_CATEGORY_HOST);
+    assertThat(intentFilter.matchDataAuthority(uriTest1))
+        .isEqualTo(IntentFilter.MATCH_CATEGORY_HOST);
+    assertThat(intentFilter.matchDataAuthority(uriTest2))
+        .isEqualTo(IntentFilter.MATCH_CATEGORY_HOST);
   }
 
   @Test
@@ -116,22 +120,19 @@ public class ShadowIntentFilterTest {
     Uri uriTest1 = Uri.parse("http://testHost1:2");
     // Host doesn't match
     Uri uriTest2 = Uri.parse("http://testHost3:2");
-    assertThat(intentFilter.matchDataAuthority(uriTest1)).isEqualTo(
-        IntentFilter.NO_MATCH_DATA);
-    assertThat(intentFilter.matchDataAuthority(uriTest2)).isEqualTo(
-        IntentFilter.NO_MATCH_DATA);
+    assertThat(intentFilter.matchDataAuthority(uriTest1)).isEqualTo(IntentFilter.NO_MATCH_DATA);
+    assertThat(intentFilter.matchDataAuthority(uriTest2)).isEqualTo(IntentFilter.NO_MATCH_DATA);
   }
 
   @Test
-  public void matchData_MatchAll() throws IntentFilter.MalformedMimeTypeException{
+  public void matchData_MatchAll() throws IntentFilter.MalformedMimeTypeException {
     IntentFilter intentFilter = new IntentFilter();
     intentFilter.addDataType("image/test");
     intentFilter.addDataScheme("http");
     intentFilter.addDataAuthority("testHost1", "1");
 
     Uri uriTest1 = Uri.parse("http://testHost1:1");
-    assertThat(intentFilter.matchData("image/test", "http", uriTest1))
-        .isAtLeast(0);
+    assertThat(intentFilter.matchData("image/test", "http", uriTest1)).isAtLeast(0);
   }
 
   @Test
@@ -141,8 +142,7 @@ public class ShadowIntentFilterTest {
     intentFilter.addDataScheme("http");
 
     Uri uriTest1 = Uri.parse("http://testHost1:1");
-    assertThat(intentFilter.matchData("image/test", "http", uriTest1))
-        .isAtLeast(0);
+    assertThat(intentFilter.matchData("image/test", "http", uriTest1)).isAtLeast(0);
   }
 
   @Test
@@ -151,16 +151,14 @@ public class ShadowIntentFilterTest {
     intentFilter.addDataScheme("http");
 
     Uri uriTest1 = Uri.parse("http://testHost1:1");
-    assertThat(intentFilter.matchData(null, "http", uriTest1))
-        .isAtLeast(0);
+    assertThat(intentFilter.matchData(null, "http", uriTest1)).isAtLeast(0);
   }
 
   @Test
   public void matchData_MatchEmpty() {
     IntentFilter intentFilter = new IntentFilter();
 
-    assertThat(intentFilter.matchData(null, "noscheme", null))
-        .isAtLeast(0);
+    assertThat(intentFilter.matchData(null, "noscheme", null)).isAtLeast(0);
   }
 
   @Test
@@ -169,8 +167,7 @@ public class ShadowIntentFilterTest {
     intentFilter.addDataType("image/testFail");
 
     Uri uriTest1 = Uri.parse("http://testHost1:1");
-    assertThat(intentFilter.matchData("image/test", "http", uriTest1))
-        .isLessThan(0);
+    assertThat(intentFilter.matchData("image/test", "http", uriTest1)).isLessThan(0);
   }
 
   @Test
@@ -180,8 +177,7 @@ public class ShadowIntentFilterTest {
     intentFilter.addDataType("image/test");
 
     Uri uriTest1 = Uri.parse("https://testHost1:1");
-    assertThat(intentFilter.matchData("image/test", "https", uriTest1))
-        .isLessThan(0);
+    assertThat(intentFilter.matchData("image/test", "https", uriTest1)).isLessThan(0);
   }
 
   @Test
@@ -192,8 +188,7 @@ public class ShadowIntentFilterTest {
     intentFilter.addDataAuthority("testHost1", "1");
 
     Uri uriTest1 = Uri.parse("http://testHost1:2");
-    assertThat(intentFilter.matchData("image/test", "http", uriTest1))
-        .isLessThan(0);
+    assertThat(intentFilter.matchData("image/test", "http", uriTest1)).isLessThan(0);
   }
 
   @Test
@@ -203,8 +198,7 @@ public class ShadowIntentFilterTest {
     intentFilter.addDataType("image/testFail");
 
     Uri uriTest1 = Uri.parse("http://testHost1:1");
-    assertThat(intentFilter.matchData("image/test", "http", uriTest1))
-        .isLessThan(0);
+    assertThat(intentFilter.matchData("image/test", "http", uriTest1)).isLessThan(0);
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowIntentServiceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowIntentServiceTest.java
index 86d6bf46e..9e21a4f14 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowIntentServiceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowIntentServiceTest.java
@@ -28,7 +28,6 @@ public class ShadowIntentServiceTest {
     }
 
     @Override
-    protected void onHandleIntent(Intent intent) {
-    }
+    protected void onHandleIntent(Intent intent) {}
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowIntentTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowIntentTest.java
index 6c07ffb7e..47c772532 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowIntentTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowIntentTest.java
@@ -34,12 +34,13 @@ public class ShadowIntentTest {
   @Test
   public void resolveActivityInfo_shouldReturnActivityInfoForExistingActivity() {
     Context context = ApplicationProvider.getApplicationContext();
-      PackageManager packageManager = context.getPackageManager();
+    PackageManager packageManager = context.getPackageManager();
 
-      Intent intent = new Intent();
-      intent.setClassName(context, TEST_ACTIVITY_CLASS_NAME);
-      ActivityInfo activityInfo = intent.resolveActivityInfo(packageManager, PackageManager.GET_ACTIVITIES);
-      assertThat(activityInfo).isNotNull();
+    Intent intent = new Intent();
+    intent.setClassName(context, TEST_ACTIVITY_CLASS_NAME);
+    ActivityInfo activityInfo =
+        intent.resolveActivityInfo(packageManager, PackageManager.GET_ACTIVITIES);
+    assertThat(activityInfo).isNotNull();
   }
 
   @Test
@@ -325,11 +326,12 @@ public class ShadowIntentTest {
     intentB.setComponent(cn);
     intentB.putExtra("FOO", 23);
 
-    int flags = Intent.FILL_IN_ACTION |
-        Intent.FILL_IN_DATA |
-        Intent.FILL_IN_CATEGORIES |
-        Intent.FILL_IN_PACKAGE |
-        Intent.FILL_IN_COMPONENT;
+    int flags =
+        Intent.FILL_IN_ACTION
+            | Intent.FILL_IN_DATA
+            | Intent.FILL_IN_CATEGORIES
+            | Intent.FILL_IN_PACKAGE
+            | Intent.FILL_IN_COMPONENT;
 
     int result = intentA.fillIn(intentB, flags);
     assertEquals("foo", intentA.getAction());
@@ -412,32 +414,33 @@ public class ShadowIntentTest {
     // without causing NPE's
     Intent intent = new Intent();
 
-    assertThat(intent.putExtra("double array", new double[] { 0.0 })).isEqualTo(intent);
+    assertThat(intent.putExtra("double array", new double[] {0.0})).isEqualTo(intent);
     assertThat(intent.putExtra("int", 0)).isEqualTo(intent);
     assertThat(intent.putExtra("CharSequence", new TestCharSequence("test"))).isEqualTo(intent);
     assertThat(intent.putExtra("char", 'a')).isEqualTo(intent);
     assertThat(intent.putExtra("Bundle", new Bundle())).isEqualTo(intent);
-    assertThat(intent.putExtra("Parcelable array", new Parcelable[] { new TestParcelable(0) }))
+    assertThat(intent.putExtra("Parcelable array", new Parcelable[] {new TestParcelable(0)}))
         .isEqualTo(intent);
     assertThat(intent.putExtra("Serializable", new TestSerializable("test"))).isEqualTo(intent);
-    assertThat(intent.putExtra("int array", new int[] { 0 })).isEqualTo(intent);
+    assertThat(intent.putExtra("int array", new int[] {0})).isEqualTo(intent);
     assertThat(intent.putExtra("float", 0f)).isEqualTo(intent);
-    assertThat(intent.putExtra("byte array", new byte[] { 0 })).isEqualTo(intent);
-    assertThat(intent.putExtra("long array", new long[] { 0L })).isEqualTo(intent);
+    assertThat(intent.putExtra("byte array", new byte[] {0})).isEqualTo(intent);
+    assertThat(intent.putExtra("long array", new long[] {0L})).isEqualTo(intent);
     assertThat(intent.putExtra("Parcelable", new TestParcelable(0))).isEqualTo(intent);
-    assertThat(intent.putExtra("float array", new float[] { 0f })).isEqualTo(intent);
+    assertThat(intent.putExtra("float array", new float[] {0f})).isEqualTo(intent);
     assertThat(intent.putExtra("long", 0L)).isEqualTo(intent);
-    assertThat(intent.putExtra("String array", new String[] { "test" })).isEqualTo(intent);
+    assertThat(intent.putExtra("String array", new String[] {"test"})).isEqualTo(intent);
     assertThat(intent.putExtra("boolean", true)).isEqualTo(intent);
-    assertThat(intent.putExtra("boolean array", new boolean[] { true })).isEqualTo(intent);
+    assertThat(intent.putExtra("boolean array", new boolean[] {true})).isEqualTo(intent);
     assertThat(intent.putExtra("short", (short) 0)).isEqualTo(intent);
     assertThat(intent.putExtra("double", 0.0)).isEqualTo(intent);
-    assertThat(intent.putExtra("short array", new short[] { 0 })).isEqualTo(intent);
+    assertThat(intent.putExtra("short array", new short[] {0})).isEqualTo(intent);
     assertThat(intent.putExtra("String", "test")).isEqualTo(intent);
     assertThat(intent.putExtra("byte", (byte) 0)).isEqualTo(intent);
-    assertThat(intent.putExtra("char array", new char[] { 'a' })).isEqualTo(intent);
-    assertThat(intent.putExtra("CharSequence array",
-        new CharSequence[] { new TestCharSequence("test") }))
+    assertThat(intent.putExtra("char array", new char[] {'a'})).isEqualTo(intent);
+    assertThat(
+            intent.putExtra(
+                "CharSequence array", new CharSequence[] {new TestCharSequence("test")}))
         .isEqualTo(intent);
   }
 
@@ -516,6 +519,5 @@ public class ShadowIntentTest {
     public CharSequence subSequence(int start, int end) {
       return s.subSequence(start, end);
     }
-
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowJsResultTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowJsResultTest.java
index e46924223..b499e7a11 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowJsResultTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowJsResultTest.java
@@ -21,7 +21,5 @@ public class ShadowJsResultTest {
 
     jsResult.cancel();
     assertTrue(shadowOf(jsResult).wasCancelled());
-
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowJsonReaderTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowJsonReaderTest.java
index 8a6f716cf..8f5fe5e95 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowJsonReaderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowJsonReaderTest.java
@@ -10,7 +10,8 @@ import org.junit.runner.RunWith;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowJsonReaderTest {
-  @Test public void shouldWork() throws Exception {
+  @Test
+  public void shouldWork() throws Exception {
     JsonReader jsonReader = new JsonReader(new StringReader("{\"abc\": \"def\"}"));
     jsonReader.beginObject();
     assertThat(jsonReader.nextName()).isEqualTo("abc");
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowKeyguardManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowKeyguardManagerTest.java
index 074740a2a..f24fcddf6 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowKeyguardManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowKeyguardManagerTest.java
@@ -117,7 +117,6 @@ public class ShadowKeyguardManagerTest {
     assertThat(manager.isDeviceLocked(USER_ID)).isFalse();
   }
 
-
   @Test
   @Config(minSdk = O)
   public void requestDismissKeyguard_dismissCancelled() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLauncherAppsTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLauncherAppsTest.java
index 340cbaab0..22583c456 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLauncherAppsTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLauncherAppsTest.java
@@ -6,6 +6,7 @@ import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.O_MR1;
 import static android.os.Build.VERSION_CODES.P;
+import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.truth.Truth.assertThat;
@@ -33,6 +34,7 @@ import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.Process;
 import android.os.UserHandle;
+import android.os.UserManager;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.ArrayList;
@@ -379,6 +381,26 @@ public class ShadowLauncherAppsTest {
                 + USER_HANDLE.getIdentifier());
   }
 
+  @Test
+  @Config(minSdk = Q)
+  public void getProfiles_returnsMainProfileByDefault() {
+    assertThat(launcherApps.getProfiles()).containsExactly(UserHandle.of(0));
+  }
+
+  @Test
+  @Config(minSdk = Q)
+  public void getProfiles_returnsAllProfiles() {
+    UserManager userManager =
+        (UserManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.USER_SERVICE);
+
+    shadowOf(userManager).addProfile(UserHandle.myUserId(), 10, "profile10", /* profileFlags= */ 0);
+    shadowOf(userManager).addProfile(UserHandle.myUserId(), 11, "profile11", /* profileFlags= */ 0);
+
+    assertThat(launcherApps.getProfiles())
+        .containsExactly(UserHandle.of(0), UserHandle.of(10), UserHandle.of(11));
+  }
+
   private List<ShortcutInfo> getPinnedShortcuts(String packageName, ComponentName activity) {
     ShortcutQuery query = new ShortcutQuery();
     query.setQueryFlags(ShortcutQuery.FLAG_MATCH_DYNAMIC | ShortcutQuery.FLAG_MATCH_PINNED);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLayerDrawableTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLayerDrawableTest.java
index e923f9db7..48437f801 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLayerDrawableTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLayerDrawableTest.java
@@ -19,17 +19,14 @@ import org.robolectric.R;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowLayerDrawableTest {
-  /**
-   * drawables
-   */
+  /** drawables */
   protected Drawable drawable1000;
+
   protected Drawable drawable2000;
   protected Drawable drawable3000;
   protected Drawable drawable4000;
 
-  /**
-   * drawables
-   */
+  /** drawables */
   protected Drawable[] drawables;
 
   @Before
@@ -43,7 +40,7 @@ public class ShadowLayerDrawableTest {
     drawable4000 =
         new BitmapDrawable(BitmapFactory.decodeResource(resources, R.drawable.fourth_image));
 
-    drawables = new Drawable[]{drawable1000, drawable2000, drawable3000};
+    drawables = new Drawable[] {drawable1000, drawable2000, drawable3000};
   }
 
   @Test
@@ -61,7 +58,8 @@ public class ShadowLayerDrawableTest {
 
     layerDrawable.setDrawableByLayerId(layerId, drawable4000);
 
-    assertEquals(shadowOf(drawable4000).getCreatedFromResId(),
+    assertEquals(
+        shadowOf(drawable4000).getCreatedFromResId(),
         shadowOf(layerDrawable.getDrawable(index)).getCreatedFromResId());
   }
 
@@ -74,7 +72,8 @@ public class ShadowLayerDrawableTest {
 
     layerDrawable.setDrawableByLayerId(layerId, drawable4000);
 
-    assertEquals(shadowOf(drawable4000).getCreatedFromResId(),
+    assertEquals(
+        shadowOf(drawable4000).getCreatedFromResId(),
         shadowOf(layerDrawable.getDrawable(index)).getCreatedFromResId());
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyAsyncTaskLoaderTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyAsyncTaskLoaderTest.java
index 5fffcb899..d8957e7cc 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyAsyncTaskLoaderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyAsyncTaskLoaderTest.java
@@ -14,9 +14,7 @@ import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.LooperMode;
 
-/**
- * Unit tests for {@link ShadowLegacyAsyncTaskLoader}.
- */
+/** Unit tests for {@link ShadowLegacyAsyncTaskLoader}. */
 @RunWith(AndroidJUnit4.class)
 @LooperMode(LEGACY)
 public class ShadowLegacyAsyncTaskLoaderTest {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyAsyncTaskTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyAsyncTaskTest.java
index 852ccb85b..67c3dbf94 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyAsyncTaskTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyAsyncTaskTest.java
@@ -20,9 +20,7 @@ import org.robolectric.Robolectric;
 import org.robolectric.annotation.LooperMode;
 import org.robolectric.util.Join;
 
-/**
- * Unit tests for {@link ShadowLegacyAsyncTask}.
- */
+/** Unit tests for {@link ShadowLegacyAsyncTask}. */
 @RunWith(AndroidJUnit4.class)
 @LooperMode(LEGACY)
 public class ShadowLegacyAsyncTaskTest {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyChoreographerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyChoreographerTest.java
index 4dfd3fd76..2ece00783 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyChoreographerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyChoreographerTest.java
@@ -14,9 +14,7 @@ import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.LooperMode.Mode;
 import org.robolectric.util.TimeUtils;
 
-/**
- * Unit tests for {@link ShadowLegacyChoreographer}.
- */
+/** Unit tests for {@link ShadowLegacyChoreographer}. */
 @RunWith(AndroidJUnit4.class)
 @LooperMode(Mode.LEGACY)
 public class ShadowLegacyChoreographerTest {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyMessageQueueTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyMessageQueueTest.java
index c2c41b07a..d606aacfc 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyMessageQueueTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyMessageQueueTest.java
@@ -41,28 +41,28 @@ public class ShadowLegacyMessageQueueTest {
   private TestHandler handler;
   private Scheduler scheduler;
   private String quitField;
-  
+
   private static class TestHandler extends Handler {
     public List<Message> handled = new ArrayList<>();
-    
+
     public TestHandler(Looper looper) {
       super(looper);
     }
-    
+
     @Override
     public void handleMessage(Message msg) {
       handled.add(msg);
     }
   }
-  
+
   private static Looper newLooper() {
     return newLooper(true);
   }
-  
+
   private static Looper newLooper(boolean canQuit) {
     return callConstructor(Looper.class, ClassParameter.from(boolean.class, canQuit));
   }
-  
+
   @Before
   public void setUp() throws Exception {
     // Queues and loopers are closely linked; can't easily test one without the other.
@@ -98,7 +98,7 @@ public class ShadowLegacyMessageQueueTest {
         ClassParameter.from(int.class, what),
         ClassParameter.from(Object.class, token));
   }
-  
+
   @Test
   public void enqueueMessage_setsHead() {
     enqueueMessage(testMessage, 100);
@@ -115,7 +115,7 @@ public class ShadowLegacyMessageQueueTest {
     enqueueMessage(testMessage, 123);
     assertWithMessage("when").that(testMessage.getWhen()).isEqualTo(123);
   }
-  
+
   @Test
   public void enqueueMessage_returnsFalse_whenQuitting() {
     setField(queue, quitField, true);
@@ -128,7 +128,7 @@ public class ShadowLegacyMessageQueueTest {
     enqueueMessage(testMessage, 1);
     assertWithMessage("scheduler_size").that(scheduler.size()).isEqualTo(0);
   }
-  
+
   @Test
   public void enqueuedMessage_isSentToHandler() {
     enqueueMessage(testMessage, 200);
@@ -137,7 +137,7 @@ public class ShadowLegacyMessageQueueTest {
     scheduler.advanceTo(200);
     assertWithMessage("handled:after").that(handler.handled).containsExactly(testMessage);
   }
-  
+
   @Test
   public void removedMessage_isNotSentToHandler() {
     enqueueMessage(testMessage, 200);
@@ -156,7 +156,7 @@ public class ShadowLegacyMessageQueueTest {
     scheduler.advanceToLastPostedRunnable();
     assertWithMessage("handled").that(handler.handled).containsExactly(m2, testMessage);
   }
-  
+
   @Test
   public void dispatchedMessage_isMarkedInUse_andRecycled() {
     Handler handler =
@@ -182,10 +182,10 @@ public class ShadowLegacyMessageQueueTest {
 
     assertWithMessage("msg2.what").that(msg2.what).isEqualTo(0);
   }
-  
-  @Test 
+
+  @Test
   public void reset_shouldClearMessageQueue() {
-    Message msg  = handler.obtainMessage(1234);
+    Message msg = handler.obtainMessage(1234);
     Message msg2 = handler.obtainMessage(5678);
     handler.sendMessage(msg);
     handler.sendMessage(msg2);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyMessageTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyMessageTest.java
index f57b20561..7df2478e6 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyMessageTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyMessageTest.java
@@ -170,7 +170,7 @@ public class ShadowLegacyMessageTest {
     Message.obtain(h, 123).sendToTarget();
     assertThat(h.hasMessages(123)).isTrue();
   }
-  
+
   @Test
   public void testSetGetNext() {
     Message msg = Message.obtain();
@@ -184,7 +184,7 @@ public class ShadowLegacyMessageTest {
   public void recycle_shouldInvokeRealObject21() {
     recycle_shouldInvokeRealObject("recycleUnchecked");
   }
-  
+
   private void recycle_shouldInvokeRealObject(String recycleMethod) {
     Handler h = new Handler();
     Message msg = Message.obtain(h, 234);
@@ -207,7 +207,7 @@ public class ShadowLegacyMessageTest {
     shadowOf(msg).recycleUnchecked();
     assertWithMessage("after recycle").that(scheduler.size()).isEqualTo(0);
   }
-  
+
   @Test
   public void reset_shouldEmptyMessagePool() {
     Message dummy1 = Message.obtain();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacySystemClockTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacySystemClockTest.java
index 2ae90cd60..5d97a77b4 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacySystemClockTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacySystemClockTest.java
@@ -66,11 +66,14 @@ public class ShadowLegacySystemClockTest {
   @Test
   public void shouldInterceptSystemTimeCalls() throws Throwable {
     ShadowSystemClock.setNanoTime(3141592L);
-    long systemNanoTime = (Long) RobolectricInternals.intercept(
-        "java/lang/System/nanoTime()J", null, null, getClass());
+    long systemNanoTime =
+        (Long)
+            RobolectricInternals.intercept("java/lang/System/nanoTime()J", null, null, getClass());
     assertThat(systemNanoTime).isEqualTo(3141592L);
-    long systemMilliTime = (Long) RobolectricInternals.intercept(
-        "java/lang/System/currentTimeMillis()J", null, null, getClass());
+    long systemMilliTime =
+        (Long)
+            RobolectricInternals.intercept(
+                "java/lang/System/currentTimeMillis()J", null, null, getClass());
     assertThat(systemMilliTime).isEqualTo(3L);
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLinkMovementMethodTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLinkMovementMethodTest.java
index 8fd537a04..e141d75e4 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLinkMovementMethodTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLinkMovementMethodTest.java
@@ -14,5 +14,4 @@ public class ShadowLinkMovementMethodTest {
   public void getInstance_shouldReturnAnInstanceOf_LinkedMovementMethod() {
     assertThat(LinkMovementMethod.getInstance()).isInstanceOf(LinkMovementMethod.class);
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowListPreferenceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowListPreferenceTest.java
index 93e6b4529..f438f01a6 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowListPreferenceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowListPreferenceTest.java
@@ -23,7 +23,7 @@ public class ShadowListPreferenceTest {
 
   @Test
   public void shouldHaveEntries() {
-    CharSequence[] entries = { "this", "is", "only", "a", "test" };
+    CharSequence[] entries = {"this", "is", "only", "a", "test"};
 
     assertThat(listPreference.getEntries()).isNull();
     listPreference.setEntries(entries);
@@ -39,7 +39,7 @@ public class ShadowListPreferenceTest {
 
   @Test
   public void shouldHaveEntryValues() {
-    CharSequence[] entryValues = { "this", "is", "only", "a", "test" };
+    CharSequence[] entryValues = {"this", "is", "only", "a", "test"};
 
     assertThat(listPreference.getEntryValues()).isNull();
     listPreference.setEntryValues(entryValues);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowListViewAdapterViewBehaviorTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowListViewAdapterViewBehaviorTest.java
index 54e4aa2b4..7e9f9896a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowListViewAdapterViewBehaviorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowListViewAdapterViewBehaviorTest.java
@@ -8,7 +8,8 @@ import org.junit.runner.RunWith;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowListViewAdapterViewBehaviorTest extends AdapterViewBehavior {
-  @Override public AdapterView createAdapterView() {
+  @Override
+  public AdapterView createAdapterView() {
     return new ListView(ApplicationProvider.getApplicationContext());
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowListViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowListViewTest.java
index 3f089aa50..38b075e59 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowListViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowListViewTest.java
@@ -220,7 +220,10 @@ public class ShadowListViewTest {
   public void getPositionForView_shouldReturnInvalidPositionForViewThatIsNotFound() {
     prepareWithListAdapter();
     View view = new View(context);
-    shadowOf(view).setMyParent(ReflectionHelpers.createNullProxy(ViewParent.class)); // Android implementation requires the item have a parent
+    shadowOf(view)
+        .setMyParent(
+            ReflectionHelpers.createNullProxy(
+                ViewParent.class)); // Android implementation requires the item have a parent
     assertThat(listView.getPositionForView(view)).isEqualTo(AdapterView.INVALID_POSITION);
   }
 
@@ -259,7 +262,8 @@ public class ShadowListViewTest {
   }
 
   @Test
-  public void givenChoiceModeIsSingleAndAnItemIsChecked_whenSettingChoiceModeToNone_thenGetCheckedItemPositionShouldReturnInvalidPosition() {
+  public void
+      givenChoiceModeIsSingleAndAnItemIsChecked_whenSettingChoiceModeToNone_thenGetCheckedItemPositionShouldReturnInvalidPosition() {
     prepareListAdapter().withChoiceMode(ListView.CHOICE_MODE_SINGLE).withAnyItemChecked();
 
     listView.setChoiceMode(ListView.CHOICE_MODE_NONE);
@@ -268,7 +272,8 @@ public class ShadowListViewTest {
   }
 
   @Test
-  public void givenChoiceModeIsMultipleAndMultipleItemsAreChecked_whenGettingCheckedItemPositions_thenReturnCheckedPositions() {
+  public void
+      givenChoiceModeIsMultipleAndMultipleItemsAreChecked_whenGettingCheckedItemPositions_thenReturnCheckedPositions() {
     prepareListAdapter().withChoiceMode(ListView.CHOICE_MODE_MULTIPLE).withAnyItemsChecked();
 
     assertThat(listView.getCheckedItemCount()).isEqualTo(checkedItemPositions.size());
@@ -278,7 +283,8 @@ public class ShadowListViewTest {
   }
 
   @Test
-  public void givenChoiceModeIsSingleAndMultipleItemsAreChecked_whenGettingCheckedItemPositions_thenReturnOnlyTheLastCheckedPosition() {
+  public void
+      givenChoiceModeIsSingleAndMultipleItemsAreChecked_whenGettingCheckedItemPositions_thenReturnOnlyTheLastCheckedPosition() {
     prepareListAdapter().withChoiceMode(ListView.CHOICE_MODE_SINGLE).withAnyItemsChecked();
 
     assertThat(listView.getCheckedItemPositions().get(lastCheckedPosition)).isTrue();
@@ -286,14 +292,16 @@ public class ShadowListViewTest {
   }
 
   @Test
-  public void givenChoiceModeIsNoneAndMultipleItemsAreChecked_whenGettingCheckedItemPositions_thenReturnNull() {
+  public void
+      givenChoiceModeIsNoneAndMultipleItemsAreChecked_whenGettingCheckedItemPositions_thenReturnNull() {
     prepareListAdapter().withChoiceMode(ListView.CHOICE_MODE_NONE).withAnyItemsChecked();
 
     assertNull(listView.getCheckedItemPositions());
   }
 
   @Test
-  public void givenItemIsNotCheckedAndChoiceModeIsSingle_whenPerformingItemClick_thenItemShouldBeChecked() {
+  public void
+      givenItemIsNotCheckedAndChoiceModeIsSingle_whenPerformingItemClick_thenItemShouldBeChecked() {
     prepareListAdapter().withChoiceMode(ListView.CHOICE_MODE_SINGLE);
     int positionToClick = anyListIndex();
 
@@ -303,7 +311,8 @@ public class ShadowListViewTest {
   }
 
   @Test
-  public void givenItemIsCheckedAndChoiceModeIsSingle_whenPerformingItemClick_thenItemShouldBeChecked() {
+  public void
+      givenItemIsCheckedAndChoiceModeIsSingle_whenPerformingItemClick_thenItemShouldBeChecked() {
     prepareListAdapter().withChoiceMode(ListView.CHOICE_MODE_SINGLE).withAnyItemChecked();
 
     listView.performItemClick(null, checkedItemPosition, 0);
@@ -312,7 +321,8 @@ public class ShadowListViewTest {
   }
 
   @Test
-  public void givenItemIsNotCheckedAndChoiceModeIsMultiple_whenPerformingItemClick_thenItemShouldBeChecked() {
+  public void
+      givenItemIsNotCheckedAndChoiceModeIsMultiple_whenPerformingItemClick_thenItemShouldBeChecked() {
     prepareListAdapter().withChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
     int positionToClick = anyListIndex();
 
@@ -323,7 +333,8 @@ public class ShadowListViewTest {
   }
 
   @Test
-  public void givenItemIsCheckedAndChoiceModeIsMultiple_whenPerformingItemClick_thenItemShouldNotBeChecked() {
+  public void
+      givenItemIsCheckedAndChoiceModeIsMultiple_whenPerformingItemClick_thenItemShouldNotBeChecked() {
     prepareListAdapter().withChoiceMode(ListView.CHOICE_MODE_MULTIPLE).withAnyItemChecked();
 
     listView.performItemClick(null, checkedItemPosition, 0);
@@ -408,7 +419,6 @@ public class ShadowListViewTest {
         listView.setItemChecked(i, true);
         lastCheckedPosition = i;
       }
-
     }
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLocationManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLocationManagerTest.java
index 2c7bb282f..6841b8c99 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLocationManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLocationManagerTest.java
@@ -902,7 +902,6 @@ public class ShadowLocationManagerTest {
   }
 
   @Test
-  @Config(minSdk = VERSION_CODES.LOLLIPOP)
   public void testRequestLocationUpdates_LocationRequest() {
     Location loc1 = createLocation(NETWORK_PROVIDER);
     Location loc2 = createLocation(NETWORK_PROVIDER);
@@ -1768,8 +1767,7 @@ public class ShadowLocationManagerTest {
     }
 
     @Override
-    public void onStatusChanged(String s, int i, Bundle bundle) {
-    }
+    public void onStatusChanged(String s, int i, Bundle bundle) {}
 
     @Override
     public void onProviderEnabled(String s) {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMagnificationControllerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMagnificationControllerTest.java
index cdd46bc95..840bbb4ae 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMagnificationControllerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMagnificationControllerTest.java
@@ -48,7 +48,7 @@ public final class ShadowMagnificationControllerTest {
   public void setCenter_setsCenterX() {
     float newCenterX = 450.0f;
 
-    magnificationController.setCenter(newCenterX, /*centerY=*/ 0.0f, /*animate=*/ false);
+    magnificationController.setCenter(newCenterX, /* centerY= */ 0.0f, /* animate= */ false);
 
     assertThat(magnificationController.getCenterX()).isEqualTo(newCenterX);
   }
@@ -57,7 +57,7 @@ public final class ShadowMagnificationControllerTest {
   public void setCenter_setsCenterY() {
     float newCenterY = 250.0f;
 
-    magnificationController.setCenter(/*centerX=*/ 0.0f, newCenterY, /*animate=*/ false);
+    magnificationController.setCenter(/* centerX= */ 0.0f, newCenterY, /* animate= */ false);
 
     assertThat(magnificationController.getCenterY()).isEqualTo(newCenterY);
   }
@@ -69,7 +69,7 @@ public final class ShadowMagnificationControllerTest {
     TestListener testListener = new TestListener();
     magnificationController.addListener(testListener);
 
-    magnificationController.setCenter(centerX, centerY, /*animate=*/ false);
+    magnificationController.setCenter(centerX, centerY, /* animate= */ false);
 
     shadowOf(Looper.getMainLooper()).idle();
     assertThat(testListener.invoked).isTrue();
@@ -81,7 +81,7 @@ public final class ShadowMagnificationControllerTest {
   public void setScale_setsScale() {
     float newScale = 5.0f;
 
-    magnificationController.setScale(newScale, /*animate=*/ false);
+    magnificationController.setScale(newScale, /* animate= */ false);
 
     assertThat(magnificationController.getScale()).isEqualTo(newScale);
   }
@@ -92,7 +92,7 @@ public final class ShadowMagnificationControllerTest {
     TestListener testListener = new TestListener();
     magnificationController.addListener(testListener);
 
-    magnificationController.setScale(scale, /*animate=*/ false);
+    magnificationController.setScale(scale, /* animate= */ false);
 
     shadowOf(Looper.getMainLooper()).idle();
     assertThat(testListener.invoked).isTrue();
@@ -101,39 +101,42 @@ public final class ShadowMagnificationControllerTest {
 
   @Test
   public void reset_resetsCenterX() {
-    magnificationController.setCenter(/*centerX=*/ 100.0f, /*centerY=*/ 0.0f, /*animate=*/ false);
+    magnificationController.setCenter(
+        /* centerX= */ 100.0f, /* centerY= */ 0.0f, /* animate= */ false);
 
-    magnificationController.reset(/*animate=*/ false);
+    magnificationController.reset(/* animate= */ false);
 
     assertThat(magnificationController.getCenterX()).isEqualTo(0.0f);
   }
 
   @Test
   public void reset_resetsCenterY() {
-    magnificationController.setCenter(/*centerX=*/ 0.0f, /*centerY=*/ 100.0f, /*animate=*/ false);
+    magnificationController.setCenter(
+        /* centerX= */ 0.0f, /* centerY= */ 100.0f, /* animate= */ false);
 
-    magnificationController.reset(/*animate=*/ false);
+    magnificationController.reset(/* animate= */ false);
 
     assertThat(magnificationController.getCenterY()).isEqualTo(0.0f);
   }
 
   @Test
   public void reset_resetsScale() {
-    magnificationController.setScale(5.0f, /*animate=*/ false);
+    magnificationController.setScale(5.0f, /* animate= */ false);
 
-    magnificationController.reset(/*animate=*/ false);
+    magnificationController.reset(/* animate= */ false);
 
     assertThat(magnificationController.getScale()).isEqualTo(1.0f);
   }
 
   @Test
   public void reset_notifiesListener() {
-    magnificationController.setCenter(/*centerX=*/ 150.5f, /*centerY=*/ 11.5f, /*animate=*/ false);
-    magnificationController.setScale(/*scale=*/ 5.0f, /*animate=*/ false);
+    magnificationController.setCenter(
+        /* centerX= */ 150.5f, /* centerY= */ 11.5f, /* animate= */ false);
+    magnificationController.setScale(/* scale= */ 5.0f, /* animate= */ false);
     TestListener testListener = new TestListener();
     magnificationController.addListener(testListener);
 
-    magnificationController.reset(/*animate=*/ false);
+    magnificationController.reset(/* animate= */ false);
 
     shadowOf(Looper.getMainLooper()).idle();
     assertThat(testListener.invoked).isTrue();
@@ -150,7 +153,7 @@ public final class ShadowMagnificationControllerTest {
 
     magnificationController.removeListener(testListener);
 
-    magnificationController.setScale(scale, /*animate=*/ false);
+    magnificationController.setScale(scale, /* animate= */ false);
     shadowOf(Looper.getMainLooper()).idle();
     assertThat(testListener.invoked).isFalse();
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMatrixCursorTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMatrixCursorTest.java
index 019a9e64c..13cb5c2f3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMatrixCursorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMatrixCursorTest.java
@@ -21,8 +21,8 @@ public class ShadowMatrixCursorTest {
 
   @Before
   public void setUp() throws Exception {
-    singleColumnSingleNullValueMatrixCursor = new MatrixCursor(new String[]{"a"});
-    singleColumnSingleNullValueMatrixCursor.addRow(new Object[]{null});
+    singleColumnSingleNullValueMatrixCursor = new MatrixCursor(new String[] {"a"});
+    singleColumnSingleNullValueMatrixCursor.addRow(new Object[] {null});
     singleColumnSingleNullValueMatrixCursor.moveToFirst();
   }
 
@@ -33,9 +33,9 @@ public class ShadowMatrixCursorTest {
 
   @Test
   public void shouldAddObjectArraysAsRows() {
-    MatrixCursor cursor = new MatrixCursor(new String[]{"a", "b", "c"});
-    cursor.addRow(new Object[]{"foo", 10L, 0.1f});
-    cursor.addRow(new Object[]{"baz", 20L, null});
+    MatrixCursor cursor = new MatrixCursor(new String[] {"a", "b", "c"});
+    cursor.addRow(new Object[] {"foo", 10L, 0.1f});
+    cursor.addRow(new Object[] {"baz", 20L, null});
     assertThat(cursor.getCount()).isEqualTo(2);
 
     assertTrue(cursor.moveToFirst());
@@ -56,7 +56,7 @@ public class ShadowMatrixCursorTest {
 
   @Test
   public void shouldAddIterablesAsRows() {
-    MatrixCursor cursor = new MatrixCursor(new String[]{"a", "b", "c"});
+    MatrixCursor cursor = new MatrixCursor(new String[] {"a", "b", "c"});
     cursor.addRow(Arrays.asList("foo", 10L, 0.1f));
     cursor.addRow(Arrays.asList("baz", 20L, null));
     assertThat(cursor.getCount()).isEqualTo(2);
@@ -79,7 +79,7 @@ public class ShadowMatrixCursorTest {
 
   @Test
   public void shouldDefineColumnNames() {
-    MatrixCursor cursor = new MatrixCursor(new String[]{"a", "b", "c"});
+    MatrixCursor cursor = new MatrixCursor(new String[] {"a", "b", "c"});
 
     assertThat(cursor.getColumnCount()).isEqualTo(3);
 
@@ -87,7 +87,7 @@ public class ShadowMatrixCursorTest {
     assertThat(cursor.getColumnName(1)).isEqualTo("b");
     assertThat(cursor.getColumnName(2)).isEqualTo("c");
 
-    assertThat(cursor.getColumnNames()).isEqualTo(new String[]{"a", "b", "c"});
+    assertThat(cursor.getColumnNames()).isEqualTo(new String[] {"a", "b", "c"});
 
     assertThat(cursor.getColumnIndex("b")).isEqualTo(1);
     assertThat(cursor.getColumnIndex("z")).isEqualTo(-1);
@@ -98,8 +98,8 @@ public class ShadowMatrixCursorTest {
   public void shouldDefineGetBlob() {
     byte[] blob = {1, 2, 3, 4};
 
-    MatrixCursor cursor = new MatrixCursor(new String[]{"a"});
-    cursor.addRow(new Object[]{blob});
+    MatrixCursor cursor = new MatrixCursor(new String[] {"a"});
+    cursor.addRow(new Object[] {blob});
     assertTrue(cursor.moveToFirst());
 
     assertThat(cursor.getBlob(0)).isEqualTo(blob);
@@ -107,8 +107,8 @@ public class ShadowMatrixCursorTest {
 
   @Test
   public void shouldAllowTypeFlexibility() {
-    MatrixCursor cursor = new MatrixCursor(new String[]{"a", "b", "c"});
-    cursor.addRow(new Object[]{42, 3.3, 'a'});
+    MatrixCursor cursor = new MatrixCursor(new String[] {"a", "b", "c"});
+    cursor.addRow(new Object[] {42, 3.3, 'a'});
     assertTrue(cursor.moveToFirst());
 
     assertThat(cursor.getString(0)).isEqualTo("42");
@@ -131,30 +131,30 @@ public class ShadowMatrixCursorTest {
 
   @Test
   public void shouldDefineGetColumnNameOrThrow() {
-    MatrixCursor cursor = new MatrixCursor(new String[]{"a", "b", "c"});
+    MatrixCursor cursor = new MatrixCursor(new String[] {"a", "b", "c"});
     assertThrows(IllegalArgumentException.class, () -> cursor.getColumnIndexOrThrow("z"));
     cursor.close();
   }
 
   @Test
   public void shouldThrowIndexOutOfBoundsExceptionWithoutData() {
-    MatrixCursor cursor = new MatrixCursor(new String[]{"a", "b", "c"});
+    MatrixCursor cursor = new MatrixCursor(new String[] {"a", "b", "c"});
     assertThrows(CursorIndexOutOfBoundsException.class, () -> cursor.getString(0));
     cursor.close();
   }
 
   @Test
   public void shouldThrowIndexOutOfBoundsExceptionForInvalidColumn() {
-    MatrixCursor cursor = new MatrixCursor(new String[]{"a", "b", "c"});
-    cursor.addRow(new Object[]{"foo", 10L, 0.1f});
+    MatrixCursor cursor = new MatrixCursor(new String[] {"a", "b", "c"});
+    cursor.addRow(new Object[] {"foo", 10L, 0.1f});
     assertThrows(CursorIndexOutOfBoundsException.class, () -> cursor.getString(3));
     cursor.close();
   }
 
   @Test
   public void shouldThrowIndexOutOfBoundsExceptionForInvalidColumnLastRow() {
-    MatrixCursor cursor = new MatrixCursor(new String[]{"a", "b", "c"});
-    cursor.addRow(new Object[]{"foo", 10L, 0.1f});
+    MatrixCursor cursor = new MatrixCursor(new String[] {"a", "b", "c"});
+    cursor.addRow(new Object[] {"foo", 10L, 0.1f});
     cursor.moveToFirst();
     cursor.moveToNext();
     assertThrows(CursorIndexOutOfBoundsException.class, () -> cursor.getString(0));
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaCodecTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaCodecTest.java
index 72a75bec1..70d495214 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaCodecTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaCodecTest.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows;
 import static com.google.common.truth.Truth.assertThat;
 import static java.util.Arrays.copyOfRange;
 import static java.util.Collections.max;
+import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.fail;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyInt;
@@ -20,7 +21,6 @@ import android.media.MediaCodec.CodecException;
 import android.media.MediaCodecInfo.CodecProfileLevel;
 import android.media.MediaCrypto;
 import android.media.MediaFormat;
-import android.os.Build;
 import android.view.Surface;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.io.IOException;
@@ -366,7 +366,8 @@ public final class ShadowMediaCodecTest {
   @Test
   public void whenCustomCodec_InputBufferIsOfExpectedSize() throws Exception {
     int inputBufferSize = 1000;
-    CodecConfig config = new CodecConfig(inputBufferSize, /*outputBufferSize=*/ 0, (in, out) -> {});
+    CodecConfig config =
+        new CodecConfig(inputBufferSize, /* outputBufferSize= */ 0, (in, out) -> {});
     ShadowMediaCodec.addEncoder(AUDIO_MIME, config);
 
     MediaCodec codec = createSyncEncoder();
@@ -378,19 +379,20 @@ public final class ShadowMediaCodecTest {
   @Test
   public void whenCustomCodec_OutputBufferIsOfExpectedSize() throws Exception {
     int outputBufferSize = 1000;
-    CodecConfig config = new CodecConfig(/*inputBufferSize=*/ 0, outputBufferSize, (in, out) -> {});
+    CodecConfig config =
+        new CodecConfig(/* inputBufferSize= */ 0, outputBufferSize, (in, out) -> {});
     ShadowMediaCodec.addEncoder(AUDIO_MIME, config);
     MediaCodec codec = createSyncEncoder();
 
-    int inputBuffer = codec.dequeueInputBuffer(/*timeoutUs=*/ 0);
+    int inputBuffer = codec.dequeueInputBuffer(/* timeoutUs= */ 0);
     codec.queueInputBuffer(
-        inputBuffer, /* offset=*/ 0, /* size=*/ 0, /* presentationTimeUs=*/ 0, /* flags=*/ 0);
+        inputBuffer, /* offset= */ 0, /* size= */ 0, /* presentationTimeUs= */ 0, /* flags= */ 0);
 
     assertThat(codec.dequeueOutputBuffer(new BufferInfo(), /* timeoutUs= */ 0))
         .isEqualTo(MediaCodec.INFO_OUTPUT_FORMAT_CHANGED);
 
     ByteBuffer outputBuffer =
-        codec.getOutputBuffer(codec.dequeueOutputBuffer(new BufferInfo(), /*timeoutUs=*/ 0));
+        codec.getOutputBuffer(codec.dequeueOutputBuffer(new BufferInfo(), /* timeoutUs= */ 0));
     assertThat(outputBuffer.capacity()).isEqualTo(outputBufferSize);
   }
 
@@ -432,7 +434,7 @@ public final class ShadowMediaCodecTest {
   @Test
   public void inSyncMode_outputBufferInfoPopulated() throws Exception {
     MediaCodec codec = createSyncEncoder();
-    int inputBuffer = codec.dequeueInputBuffer(/*timeoutUs=*/ 0);
+    int inputBuffer = codec.dequeueInputBuffer(/* timeoutUs= */ 0);
     codec.getInputBuffer(inputBuffer).put(ByteBuffer.allocateDirect(512));
     codec.queueInputBuffer(
         inputBuffer,
@@ -618,6 +620,64 @@ public final class ShadowMediaCodecTest {
     }
   }
 
+  @Test
+  public void getInputFormat_shouldThrowIllegalStateExceptionWhenCodecNotConfigured()
+      throws Exception {
+    MediaCodec codec = MediaCodec.createEncoderByType(AUDIO_MIME);
+
+    assertThrows(IllegalStateException.class, codec::getInputFormat);
+  }
+
+  @Test
+  public void getInputFormat_shouldReturnConfiguredFormatWhenCodecIsConfigured() throws Exception {
+    MediaFormat basicAacFormat = getBasicAacFormat();
+    MediaCodec codec = MediaCodec.createEncoderByType(AUDIO_MIME);
+    codec.configure(
+        basicAacFormat, /* surface= */ null, /* crypto= */ null, MediaCodec.CONFIGURE_FLAG_ENCODE);
+
+    MediaFormat codecFormat = codec.getInputFormat();
+
+    assertThat(codecFormat.getString(MediaFormat.KEY_MIME))
+        .isEqualTo(basicAacFormat.getString(MediaFormat.KEY_MIME));
+    assertThat(codecFormat.getInteger(MediaFormat.KEY_BIT_RATE))
+        .isEqualTo(basicAacFormat.getInteger(MediaFormat.KEY_BIT_RATE));
+    assertThat(codecFormat.getInteger(MediaFormat.KEY_CHANNEL_COUNT))
+        .isEqualTo(basicAacFormat.getInteger(MediaFormat.KEY_CHANNEL_COUNT));
+    assertThat(codecFormat.getInteger(MediaFormat.KEY_SAMPLE_RATE))
+        .isEqualTo(basicAacFormat.getInteger(MediaFormat.KEY_SAMPLE_RATE));
+    assertThat(codecFormat.getInteger(MediaFormat.KEY_AAC_PROFILE))
+        .isEqualTo(basicAacFormat.getInteger(MediaFormat.KEY_AAC_PROFILE));
+  }
+
+  @Test
+  public void getOutputFormat_shouldThrowIllegalStateExceptionWhenCodecNotConfigured()
+      throws Exception {
+    MediaCodec codec = MediaCodec.createEncoderByType(AUDIO_MIME);
+
+    assertThrows(IllegalStateException.class, codec::getOutputFormat);
+  }
+
+  @Test
+  public void getOutputFormat_shouldReturnConfiguredFormatWhenCodecIsConfigured() throws Exception {
+    MediaFormat basicAacFormat = getBasicAacFormat();
+    MediaCodec codec = MediaCodec.createEncoderByType(AUDIO_MIME);
+    codec.configure(
+        basicAacFormat, /* surface= */ null, /* crypto= */ null, MediaCodec.CONFIGURE_FLAG_ENCODE);
+
+    MediaFormat codecFormat = codec.getOutputFormat();
+
+    assertThat(codecFormat.getString(MediaFormat.KEY_MIME))
+        .isEqualTo(basicAacFormat.getString(MediaFormat.KEY_MIME));
+    assertThat(codecFormat.getInteger(MediaFormat.KEY_BIT_RATE))
+        .isEqualTo(basicAacFormat.getInteger(MediaFormat.KEY_BIT_RATE));
+    assertThat(codecFormat.getInteger(MediaFormat.KEY_CHANNEL_COUNT))
+        .isEqualTo(basicAacFormat.getInteger(MediaFormat.KEY_CHANNEL_COUNT));
+    assertThat(codecFormat.getInteger(MediaFormat.KEY_SAMPLE_RATE))
+        .isEqualTo(basicAacFormat.getInteger(MediaFormat.KEY_SAMPLE_RATE));
+    assertThat(codecFormat.getInteger(MediaFormat.KEY_AAC_PROFILE))
+        .isEqualTo(basicAacFormat.getInteger(MediaFormat.KEY_AAC_PROFILE));
+  }
+
   public static <T> T asyncVerify(T mock) {
     shadowMainLooper().idle();
     return verify(mock);
@@ -735,10 +795,6 @@ public final class ShadowMediaCodecTest {
   private static void writeToInputBuffer(MediaCodec codec, ByteBuffer src) {
     int inputBufferId = codec.dequeueInputBuffer(WITHOUT_TIMEOUT);
     ByteBuffer inputBuffer = codec.getInputBuffer(inputBufferId);
-    // API versions lower than 21 don't clear the buffer before returning it.
-    if (Build.VERSION.SDK_INT < 21) {
-      inputBuffer.clear();
-    }
     int srcLimit = src.limit();
     int numberOfBytesToWrite = Math.min(src.remaining(), inputBuffer.remaining());
     src.limit(src.position() + numberOfBytesToWrite);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaPlayerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaPlayerTest.java
index c05b6e90a..0b23bbe90 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaPlayerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaPlayerTest.java
@@ -25,6 +25,7 @@ import static org.robolectric.shadows.util.DataSource.toDataSource;
 
 import android.app.Application;
 import android.content.res.AssetFileDescriptor;
+import android.media.AudioAttributes;
 import android.media.AudioDeviceInfo;
 import android.media.AudioManager;
 import android.media.MediaDataSource;
@@ -119,15 +120,49 @@ public class ShadowMediaPlayerTest {
             DataSource.toDataSource("android.resource://" + context.getPackageName() + "/123"));
   }
 
+  @Test
+  public void create_withResourceIdAudioAttributesAndAudioSessionId_shouldSetDataSource() {
+    Application context = ApplicationProvider.getApplicationContext();
+    ShadowMediaPlayer.addMediaInfo(
+        DataSource.toDataSource("android.resource://" + context.getPackageName() + "/123"),
+        new ShadowMediaPlayer.MediaInfo(100, 10));
+
+    MediaPlayer mp = MediaPlayer.create(context, 123, new AudioAttributes.Builder().build(), 0);
+    ShadowMediaPlayer shadow = shadowOf(mp);
+    assertThat(shadow.getDataSource())
+        .isEqualTo(
+            DataSource.toDataSource("android.resource://" + context.getPackageName() + "/123"));
+  }
+
+  @Test
+  public void create_withResourceIdAudioAttributesAndAudioSessionId_shouldSetAudioSessionId() {
+    Application context = ApplicationProvider.getApplicationContext();
+    ShadowMediaPlayer.addMediaInfo(
+        DataSource.toDataSource("android.resource://" + context.getPackageName() + "/123"),
+        new ShadowMediaPlayer.MediaInfo(100, 10));
+
+    MediaPlayer mp = MediaPlayer.create(context, 123, new AudioAttributes.Builder().build(), 42);
+    assertThat(mp.getAudioSessionId()).isEqualTo(42);
+  }
+
   @Test
   public void testInitialState() {
     assertThat(shadowMediaPlayer.getState()).isEqualTo(IDLE);
   }
 
+  /** It is allowed to call {@link MediaPlayer#getCurrentPosition()} in the idle state. */
+  @Test
+  public void newMediaPlayer_getCurrentPosition_inIdleState() {
+    ShadowMediaPlayer.setCreateListener(
+        (player, shadow) -> shadow.setInvalidStateBehavior(InvalidStateBehavior.ASSERT));
+    MediaPlayer mediaPlayer = new MediaPlayer();
+    assertThat(mediaPlayer.getCurrentPosition()).isEqualTo(0);
+  }
+
   @Test
   public void testCreateListener() {
-    ShadowMediaPlayer.CreateListener createListener = Mockito
-        .mock(ShadowMediaPlayer.CreateListener.class);
+    ShadowMediaPlayer.CreateListener createListener =
+        Mockito.mock(ShadowMediaPlayer.CreateListener.class);
     ShadowMediaPlayer.setCreateListener(createListener);
 
     MediaPlayer newPlayer = new MediaPlayer();
@@ -140,13 +175,12 @@ public class ShadowMediaPlayerTest {
   public void testResetResetsPosition() {
     shadowMediaPlayer.setCurrentPosition(300);
     mediaPlayer.reset();
-    assertThat(shadowMediaPlayer.getCurrentPositionRaw())
-      .isEqualTo(0);
+    assertThat(shadowMediaPlayer.getCurrentPositionRaw()).isEqualTo(0);
   }
 
   @Test
   public void testPrepare() throws IOException {
-    int[] testDelays = { 0, 10, 100, 1500 };
+    int[] testDelays = {0, 10, 100, 1500};
 
     for (int delay : testDelays) {
       final long startTime = SystemClock.uptimeMillis();
@@ -216,20 +250,21 @@ public class ShadowMediaPlayerTest {
   @Config(minSdk = M)
   @Test
   public void testSetDataSourceMediaDataSource() {
-    MediaDataSource mediaDataSource = new MediaDataSource() {
-      @Override
-      public void close() {}
+    MediaDataSource mediaDataSource =
+        new MediaDataSource() {
+          @Override
+          public void close() {}
 
-      @Override
-      public int readAt(long position, byte[] buffer, int offset, int size) {
-        return 0;
-      }
+          @Override
+          public int readAt(long position, byte[] buffer, int offset, int size) {
+            return 0;
+          }
 
-      @Override
-      public long getSize() {
-        return 0;
-      }
-    };
+          @Override
+          public long getSize() {
+            return 0;
+          }
+        };
     DataSource ds = toDataSource(mediaDataSource);
     ShadowMediaPlayer.addMediaInfo(ds, info);
     mediaPlayer.setDataSource(mediaDataSource);
@@ -264,7 +299,7 @@ public class ShadowMediaPlayerTest {
   @Test
   public void testPrepareAsyncAutoCallback() {
     mediaPlayer.setOnPreparedListener(preparedListener);
-    int[] testDelays = { 0, 10, 100, 1500 };
+    int[] testDelays = {0, 10, 100, 1500};
 
     for (int delay : testDelays) {
       info.setPreparationDelay(delay);
@@ -308,8 +343,8 @@ public class ShadowMediaPlayerTest {
 
   @Test
   public void testIsPlaying() {
-    EnumSet<State> nonPlayingStates = EnumSet.of(IDLE, INITIALIZED, PREPARED,
-        PAUSED, STOPPED, PLAYBACK_COMPLETED);
+    EnumSet<State> nonPlayingStates =
+        EnumSet.of(IDLE, INITIALIZED, PREPARED, PAUSED, STOPPED, PLAYBACK_COMPLETED);
     for (State state : nonPlayingStates) {
       shadowMediaPlayer.setState(state);
       assertThat(mediaPlayer.isPlaying()).isFalse();
@@ -320,8 +355,7 @@ public class ShadowMediaPlayerTest {
 
   @Test
   public void testIsPrepared() {
-    EnumSet<State> prepStates = EnumSet.of(PREPARED, STARTED, PAUSED,
-        PLAYBACK_COMPLETED);
+    EnumSet<State> prepStates = EnumSet.of(PREPARED, STARTED, PAUSED, PLAYBACK_COMPLETED);
 
     for (State state : State.values()) {
       shadowMediaPlayer.setState(state);
@@ -503,12 +537,10 @@ public class ShadowMediaPlayerTest {
 
   @Test
   public void testAttachAuxEffectStates() {
-    testStates(new MethodSpec("attachAuxEffect", 37), EnumSet.of(IDLE, ERROR),
-        onErrorTester, null);
+    testStates(new MethodSpec("attachAuxEffect", 37), EnumSet.of(IDLE, ERROR), onErrorTester, null);
   }
 
-  private static final EnumSet<State> emptyStateSet = EnumSet
-      .noneOf(State.class);
+  private static final EnumSet<State> emptyStateSet = EnumSet.noneOf(State.class);
 
   @Test
   public void testGetAudioSessionIdStates() {
@@ -517,20 +549,18 @@ public class ShadowMediaPlayerTest {
 
   @Test
   public void testGetCurrentPositionStates() {
-    testStates("getCurrentPosition", EnumSet.of(IDLE, ERROR), onErrorTester,
-        null);
+    testStates("getCurrentPosition", EnumSet.of(ERROR), onErrorTester, null);
   }
 
   @Test
   public void testGetDurationStates() {
-    testStates("getDuration", EnumSet.of(IDLE, INITIALIZED, ERROR),
-        onErrorTester, null);
+    testStates("getDuration", EnumSet.of(IDLE, INITIALIZED, ERROR), onErrorTester, null);
   }
 
   @Test
   public void testGetVideoHeightAndWidthStates() {
-    testStates("getVideoHeight", EnumSet.of(IDLE, ERROR), logTester, null);
-    testStates("getVideoWidth", EnumSet.of(IDLE, ERROR), logTester, null);
+    testStates("getVideoHeight", EnumSet.of(ERROR), logTester, null);
+    testStates("getVideoWidth", EnumSet.of(ERROR), logTester, null);
   }
 
   @Test
@@ -547,21 +577,22 @@ public class ShadowMediaPlayerTest {
 
   @Test
   public void testPauseStates() {
-    testStates("pause",
-        EnumSet.of(IDLE, INITIALIZED, PREPARED, STOPPED, ERROR), onErrorTester,
-        PAUSED);
+    testStates(
+        "pause", EnumSet.of(IDLE, INITIALIZED, PREPARED, STOPPED, ERROR), onErrorTester, PAUSED);
   }
 
   @Test
   public void testPrepareStates() {
-    testStates("prepare",
+    testStates(
+        "prepare",
         EnumSet.of(IDLE, PREPARED, STARTED, PAUSED, PLAYBACK_COMPLETED, ERROR),
         PREPARED);
   }
 
   @Test
   public void testPrepareAsyncStates() {
-    testStates("prepareAsync",
+    testStates(
+        "prepareAsync",
         EnumSet.of(IDLE, PREPARED, STARTED, PAUSED, PLAYBACK_COMPLETED, ERROR),
         PREPARING);
   }
@@ -578,15 +609,20 @@ public class ShadowMediaPlayerTest {
 
   @Test
   public void testSeekToStates() {
-    testStates(new MethodSpec("seekTo", 38),
-        EnumSet.of(IDLE, INITIALIZED, STOPPED, ERROR), onErrorTester, null);
+    testStates(
+        new MethodSpec("seekTo", 38),
+        EnumSet.of(IDLE, INITIALIZED, STOPPED, ERROR),
+        onErrorTester,
+        null);
   }
 
   @Test
   public void testSetAudioSessionIdStates() {
-    testStates(new MethodSpec("setAudioSessionId", 40), EnumSet.of(INITIALIZED,
-        PREPARED, STARTED, PAUSED, STOPPED, PLAYBACK_COMPLETED, ERROR),
-        onErrorTester, null);
+    testStates(
+        new MethodSpec("setAudioSessionId", 40),
+        EnumSet.of(INITIALIZED, PREPARED, STARTED, PAUSED, STOPPED, PLAYBACK_COMPLETED, ERROR),
+        onErrorTester,
+        null);
   }
 
   // NOTE: This test diverges from the spec in the MediaPlayer
@@ -598,28 +634,32 @@ public class ShadowMediaPlayerTest {
   // so that is what I have emulated.
   @Test
   public void testSetAudioStreamTypeStates() {
-    testStates(new MethodSpec("setAudioStreamType", AudioManager.STREAM_MUSIC),
+    testStates(
+        new MethodSpec("setAudioStreamType", AudioManager.STREAM_MUSIC),
         EnumSet.of(PREPARED, STARTED, PAUSED, PLAYBACK_COMPLETED, ERROR),
-        onErrorTester, null);
+        onErrorTester,
+        null);
   }
 
   @Test
   public void testSetLoopingStates() {
-    testStates(new MethodSpec("setLooping", true), EnumSet.of(ERROR),
-        onErrorTester, null);
+    testStates(new MethodSpec("setLooping", true), EnumSet.of(ERROR), onErrorTester, null);
   }
 
   @Test
   public void testSetVolumeStates() {
-    testStates(new MethodSpec("setVolume", new Class<?>[] { float.class,
-        float.class }, new Object[] { 1.0f, 1.0f }), EnumSet.of(ERROR),
-        onErrorTester, null);
+    testStates(
+        new MethodSpec(
+            "setVolume", new Class<?>[] {float.class, float.class}, new Object[] {1.0f, 1.0f}),
+        EnumSet.of(ERROR),
+        onErrorTester,
+        null);
   }
 
   @Test
   public void testSetDataSourceStates() {
-    final EnumSet<State> invalidStates = EnumSet.of(INITIALIZED, PREPARED,
-        STARTED, PAUSED, PLAYBACK_COMPLETED, STOPPED, ERROR);
+    final EnumSet<State> invalidStates =
+        EnumSet.of(INITIALIZED, PREPARED, STARTED, PAUSED, PLAYBACK_COMPLETED, STOPPED, ERROR);
 
     testStates(
         new MethodSpec("setDataSource", DUMMY_SOURCE), invalidStates, iseTester, INITIALIZED);
@@ -627,20 +667,18 @@ public class ShadowMediaPlayerTest {
 
   @Test
   public void testStartStates() {
-    testStates("start",
-        EnumSet.of(IDLE, INITIALIZED, PREPARING, STOPPED, ERROR),
-        onErrorTester, STARTED);
+    testStates(
+        "start", EnumSet.of(IDLE, INITIALIZED, PREPARING, STOPPED, ERROR), onErrorTester, STARTED);
   }
 
   @Test
   public void testStopStates() {
-    testStates("stop", EnumSet.of(IDLE, INITIALIZED, ERROR), onErrorTester,
-        STOPPED);
+    testStates("stop", EnumSet.of(IDLE, INITIALIZED, ERROR), onErrorTester, STOPPED);
   }
 
   @Test
   public void testCurrentPosition() {
-    int[] positions = { 0, 1, 2, 1024 };
+    int[] positions = {0, 1, 2, 1024};
     for (int position : positions) {
       shadowMediaPlayer.setCurrentPosition(position);
       assertThat(mediaPlayer.getCurrentPosition()).isEqualTo(position);
@@ -659,8 +697,7 @@ public class ShadowMediaPlayerTest {
   private Tester logTester = new LogTester(null);
   private Tester assertTester = new ExceptionTester(AssertionError.class);
 
-  private void testStates(String methodName, EnumSet<State> invalidStates,
-      State nextState) {
+  private void testStates(String methodName, EnumSet<State> invalidStates, State nextState) {
     testStates(new MethodSpec(methodName), invalidStates, iseTester, nextState);
   }
 
@@ -684,23 +721,23 @@ public class ShadowMediaPlayerTest {
     }
 
     public MethodSpec(String method, int arg) {
-      this(method, new Class<?>[] { int.class }, new Object[] { arg });
+      this(method, new Class<?>[] {int.class}, new Object[] {arg});
     }
 
     public MethodSpec(String method, boolean arg) {
-      this(method, new Class<?>[] { boolean.class }, new Object[] { arg });
+      this(method, new Class<?>[] {boolean.class}, new Object[] {arg});
     }
 
     public MethodSpec(String method, Class<?> c) {
-      this(method, new Class<?>[] { c }, new Object[] { null });
+      this(method, new Class<?>[] {c}, new Object[] {null});
     }
 
     public MethodSpec(String method, Object o) {
-      this(method, new Class<?>[] { o.getClass() }, new Object[] { o });
+      this(method, new Class<?>[] {o.getClass()}, new Object[] {o});
     }
 
     public <T> MethodSpec(String method, T o, Class<T> c) {
-      this(method, new Class<?>[] { c }, new Object[] { o });
+      this(method, new Class<?>[] {c}, new Object[] {o});
     }
 
     public void invoke() throws InvocationTargetException {
@@ -711,18 +748,18 @@ public class ShadowMediaPlayerTest {
       }
     }
 
-    @Override public String toString() {
+    @Override
+    public String toString() {
       return method.toString();
     }
   }
 
-  private void testStates(String method, EnumSet<State> invalidStates,
-      Tester tester, State next) {
+  private void testStates(String method, EnumSet<State> invalidStates, Tester tester, State next) {
     testStates(new MethodSpec(method), invalidStates, tester, next);
   }
 
-  private void testStates(MethodSpec method, EnumSet<State> invalidStates,
-      Tester tester, State next) {
+  private void testStates(
+      MethodSpec method, EnumSet<State> invalidStates, Tester tester, State next) {
     final EnumSet<State> invalid = EnumSet.copyOf(invalidStates);
 
     // The documentation specifies that the behavior of calling any
@@ -806,9 +843,15 @@ public class ShadowMediaPlayerTest {
       try {
         method.invoke();
       } catch (InvocationTargetException e) {
-        throw new RuntimeException("Expected <" + method
-            + "> to call onError rather than throw <" + e.getTargetException()
-            + "> when called from <" + state + ">", e);
+        throw new RuntimeException(
+            "Expected <"
+                + method
+                + "> to call onError rather than throw <"
+                + e.getTargetException()
+                + "> when called from <"
+                + state
+                + ">",
+            e);
       }
       Mockito.verifyNoMoreInteractions(errorListener);
       final State finalState = shadowMediaPlayer.getState();
@@ -869,13 +912,11 @@ public class ShadowMediaPlayerTest {
       }
     } catch (InvocationTargetException e) {
       Throwable cause = e.getTargetException();
-          fail("<" + method + "> should not throw exception when in state <"
-              + state + ">" + cause);
+      fail("<" + method + "> should not throw exception when in state <" + state + ">" + cause);
     }
   }
 
-  private static final State[] seekableStates = { PREPARED, PAUSED,
-      PLAYBACK_COMPLETED, STARTED };
+  private static final State[] seekableStates = {PREPARED, PAUSED, PLAYBACK_COMPLETED, STARTED};
 
   // It is not 100% clear from the docs if seeking to < 0 should
   // invoke an error. I have assumed from the documentation
@@ -1106,7 +1147,7 @@ public class ShadowMediaPlayerTest {
     shadowMediaPlayer.setSeekDelay(-1);
 
     assertWithMessage("pendingSeek before").that(shadowMediaPlayer.getPendingSeek()).isEqualTo(-1);
-    int[] positions = { 0, 5, 2, 999 };
+    int[] positions = {0, 5, 2, 999};
     int prevPos = 0;
     for (int position : positions) {
       mediaPlayer.seekTo(position);
@@ -1262,8 +1303,7 @@ public class ShadowMediaPlayerTest {
     Mockito.verifyNoMoreInteractions(infoListener);
 
     shadowMainLooper().idleFor(Duration.ofMillis(1));
-    Mockito.verify(infoListener).onInfo(mediaPlayer,
-        MediaPlayer.MEDIA_INFO_BUFFERING_START, 0);
+    Mockito.verify(infoListener).onInfo(mediaPlayer, MediaPlayer.MEDIA_INFO_BUFFERING_START, 0);
     assertThat(shadowMediaPlayer.getCurrentPositionRaw()).isEqualTo(100);
     assertThat(shadowMediaPlayer.isReallyPlaying()).isFalse();
 
@@ -1272,8 +1312,7 @@ public class ShadowMediaPlayerTest {
 
     shadowMainLooper().idleFor(Duration.ofMillis(1));
     assertThat(shadowMediaPlayer.getCurrentPositionRaw()).isEqualTo(100);
-    Mockito.verify(infoListener).onInfo(mediaPlayer,
-        MediaPlayer.MEDIA_INFO_BUFFERING_END, 0);
+    Mockito.verify(infoListener).onInfo(mediaPlayer, MediaPlayer.MEDIA_INFO_BUFFERING_END, 0);
 
     shadowMainLooper().idleFor(Duration.ofMillis(100));
     assertThat(shadowMediaPlayer.getCurrentPositionRaw()).isEqualTo(200);
@@ -1286,8 +1325,7 @@ public class ShadowMediaPlayerTest {
 
     shadowMainLooper().idleFor(Duration.ofMillis(200));
 
-    MediaEvent e = info.scheduleInfoAtOffset(
-        500, 1, 3);
+    MediaEvent e = info.scheduleInfoAtOffset(500, 1, 3);
 
     shadowMainLooper().idleFor(Duration.ofMillis(299));
     info.removeEventAtOffset(500, e);
@@ -1364,7 +1402,8 @@ public class ShadowMediaPlayerTest {
     Map<DataSource, Exception> exceptions =
         ReflectionHelpers.getStaticField(ShadowMediaPlayer.class, "exceptions");
     DataSource ds = toDataSource("dummy");
-    Exception e = new CloneNotSupportedException(); // just a convenient, non-RuntimeException in java.lang
+    Exception e =
+        new CloneNotSupportedException(); // just a convenient, non-RuntimeException in java.lang
     exceptions.put(ds, e);
 
     try {
@@ -1402,9 +1441,8 @@ public class ShadowMediaPlayerTest {
   }
 
   /**
-   * If the looping mode was being set to {@code true}
-   * {@link MediaPlayer#setLooping(boolean)}, the MediaPlayer object shall
-   * remain in the Started state.
+   * If the looping mode was being set to {@code true} {@link MediaPlayer#setLooping(boolean)}, the
+   * MediaPlayer object shall remain in the Started state.
    */
   @Test
   public void testSetLoopingCalledWhilePlaying() {
@@ -1427,7 +1465,7 @@ public class ShadowMediaPlayerTest {
 
   @Test
   public void testSetLoopingCalledWhileStartable() {
-    final State[] startableStates = { PREPARED, PAUSED };
+    final State[] startableStates = {PREPARED, PAUSED};
     for (State state : startableStates) {
       shadowMediaPlayer.setCurrentPosition(500);
       shadowMediaPlayer.setState(state);
@@ -1441,8 +1479,8 @@ public class ShadowMediaPlayerTest {
   }
 
   /**
-   * While in the PlaybackCompleted state, calling start() can restart the
-   * playback from the beginning of the audio/video source.
+   * While in the PlaybackCompleted state, calling start() can restart the playback from the
+   * beginning of the audio/video source.
    */
   @Test
   public void testStartAfterPlaybackCompleted() {
@@ -1486,8 +1524,8 @@ public class ShadowMediaPlayerTest {
 
   @Test
   public void testResetStaticState() {
-    ShadowMediaPlayer.CreateListener createListener = Mockito
-        .mock(ShadowMediaPlayer.CreateListener.class);
+    ShadowMediaPlayer.CreateListener createListener =
+        Mockito.mock(ShadowMediaPlayer.CreateListener.class);
     ShadowMediaPlayer.setCreateListener(createListener);
     assertWithMessage("createListener")
         .that(ShadowMediaPlayer.createListener)
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaRecorderTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaRecorderTest.java
index 28be1b653..e254452e3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaRecorderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaRecorderTest.java
@@ -5,14 +5,12 @@ import static org.junit.Assert.assertThrows;
 
 import android.hardware.Camera;
 import android.media.MediaRecorder;
-import android.os.Build.VERSION_CODES;
 import android.view.Surface;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Shadows;
-import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
 @RunWith(AndroidJUnit4.class)
@@ -36,11 +34,14 @@ public class ShadowMediaRecorderTest {
 
   @Test
   public void testAudioEncoder() {
-    assertThat(shadowMediaRecorder.getAudioEncoder()).isNotEqualTo(MediaRecorder.AudioEncoder.AMR_NB);
-    assertThat(shadowMediaRecorder.getState()).isNotEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
+    assertThat(shadowMediaRecorder.getAudioEncoder())
+        .isNotEqualTo(MediaRecorder.AudioEncoder.AMR_NB);
+    assertThat(shadowMediaRecorder.getState())
+        .isNotEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
     mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);
     assertThat(shadowMediaRecorder.getAudioEncoder()).isEqualTo(MediaRecorder.AudioEncoder.AMR_NB);
-    assertThat(shadowMediaRecorder.getState()).isEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
+    assertThat(shadowMediaRecorder.getState())
+        .isEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
   }
 
   @Test
@@ -59,7 +60,8 @@ public class ShadowMediaRecorderTest {
 
   @Test
   public void testAudioSource() {
-    assertThat(shadowMediaRecorder.getAudioSource()).isNotEqualTo(MediaRecorder.AudioSource.CAMCORDER);
+    assertThat(shadowMediaRecorder.getAudioSource())
+        .isNotEqualTo(MediaRecorder.AudioSource.CAMCORDER);
     assertThat(shadowMediaRecorder.getState()).isNotEqualTo(ShadowMediaRecorder.STATE_INITIALIZED);
     mediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
     assertThat(shadowMediaRecorder.getAudioSource()).isEqualTo(MediaRecorder.AudioSource.CAMCORDER);
@@ -109,40 +111,49 @@ public class ShadowMediaRecorderTest {
 
   @Test
   public void testOutputFile() {
-    assertThat(shadowMediaRecorder.getState()).isNotEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
+    assertThat(shadowMediaRecorder.getState())
+        .isNotEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
     assertThat(shadowMediaRecorder.getOutputPath()).isNull();
     mediaRecorder.setOutputFile("/dev/null");
     assertThat(shadowMediaRecorder.getOutputPath()).isEqualTo("/dev/null");
-    assertThat(shadowMediaRecorder.getState()).isEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
+    assertThat(shadowMediaRecorder.getState())
+        .isEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
   }
 
   @Test
   public void testOutputFormat() {
-    assertThat(shadowMediaRecorder.getState()).isNotEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
-    assertThat(shadowMediaRecorder.getOutputFormat()).isNotEqualTo(MediaRecorder.OutputFormat.MPEG_4);
+    assertThat(shadowMediaRecorder.getState())
+        .isNotEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
+    assertThat(shadowMediaRecorder.getOutputFormat())
+        .isNotEqualTo(MediaRecorder.OutputFormat.MPEG_4);
     mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);
     assertThat(shadowMediaRecorder.getOutputFormat()).isEqualTo(MediaRecorder.OutputFormat.MPEG_4);
-    assertThat(shadowMediaRecorder.getState()).isEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
+    assertThat(shadowMediaRecorder.getState())
+        .isEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
   }
 
   @Test
   public void testPreviewDisplay() {
-    assertThat(shadowMediaRecorder.getState()).isNotEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
+    assertThat(shadowMediaRecorder.getState())
+        .isNotEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
     assertThat(shadowMediaRecorder.getPreviewDisplay()).isNull();
     Surface surface = Shadow.newInstanceOf(Surface.class);
     mediaRecorder.setPreviewDisplay(surface);
     assertThat(shadowMediaRecorder.getPreviewDisplay()).isNotNull();
     assertThat(shadowMediaRecorder.getPreviewDisplay()).isSameInstanceAs(surface);
-    assertThat(shadowMediaRecorder.getState()).isEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
+    assertThat(shadowMediaRecorder.getState())
+        .isEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
   }
 
   @Test
   public void testVideoEncoder() {
-    assertThat(shadowMediaRecorder.getState()).isNotEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
+    assertThat(shadowMediaRecorder.getState())
+        .isNotEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
     assertThat(shadowMediaRecorder.getVideoEncoder()).isNotEqualTo(MediaRecorder.VideoEncoder.H264);
     mediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264);
     assertThat(shadowMediaRecorder.getVideoEncoder()).isEqualTo(MediaRecorder.VideoEncoder.H264);
-    assertThat(shadowMediaRecorder.getState()).isEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
+    assertThat(shadowMediaRecorder.getState())
+        .isEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
   }
 
   @Test
@@ -154,22 +165,26 @@ public class ShadowMediaRecorderTest {
 
   @Test
   public void testVideoFrameRate() {
-    assertThat(shadowMediaRecorder.getState()).isNotEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
+    assertThat(shadowMediaRecorder.getState())
+        .isNotEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
     assertThat(shadowMediaRecorder.getVideoFrameRate()).isNotEqualTo(30);
     mediaRecorder.setVideoFrameRate(30);
     assertThat(shadowMediaRecorder.getVideoFrameRate()).isEqualTo(30);
-    assertThat(shadowMediaRecorder.getState()).isEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
+    assertThat(shadowMediaRecorder.getState())
+        .isEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
   }
 
   @Test
   public void testVideoSize() {
-    assertThat(shadowMediaRecorder.getState()).isNotEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
+    assertThat(shadowMediaRecorder.getState())
+        .isNotEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
     assertThat(shadowMediaRecorder.getVideoWidth()).isNotEqualTo(640);
     assertThat(shadowMediaRecorder.getVideoHeight()).isNotEqualTo(480);
     mediaRecorder.setVideoSize(640, 480);
     assertThat(shadowMediaRecorder.getVideoWidth()).isEqualTo(640);
     assertThat(shadowMediaRecorder.getVideoHeight()).isEqualTo(480);
-    assertThat(shadowMediaRecorder.getState()).isEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
+    assertThat(shadowMediaRecorder.getState())
+        .isEqualTo(ShadowMediaRecorder.STATE_DATA_SOURCE_CONFIGURED);
   }
 
   @Test
@@ -222,7 +237,6 @@ public class ShadowMediaRecorderTest {
   }
 
   @Test
-  @Config(minSdk = VERSION_CODES.LOLLIPOP)
   public void testGetSurface() throws Exception {
     mediaRecorder.setVideoSource(MediaRecorder.VideoSource.SURFACE);
     mediaRecorder.prepare();
@@ -230,14 +244,12 @@ public class ShadowMediaRecorderTest {
   }
 
   @Test
-  @Config(minSdk = VERSION_CODES.LOLLIPOP)
   public void testGetSurface_beforePrepare() {
     mediaRecorder.setVideoSource(MediaRecorder.VideoSource.SURFACE);
     assertThrows(IllegalStateException.class, () -> mediaRecorder.getSurface());
   }
 
   @Test
-  @Config(minSdk = VERSION_CODES.LOLLIPOP)
   public void testGetSurface_afterStop() throws Exception {
     mediaRecorder.setVideoSource(MediaRecorder.VideoSource.SURFACE);
     mediaRecorder.prepare();
@@ -247,7 +259,6 @@ public class ShadowMediaRecorderTest {
   }
 
   @Test
-  @Config(minSdk = VERSION_CODES.LOLLIPOP)
   public void testGetSurface_wrongVideoSource() throws Exception {
     mediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);
     mediaRecorder.prepare();
@@ -256,14 +267,11 @@ public class ShadowMediaRecorderTest {
 
   private static class TestErrorListener implements MediaRecorder.OnErrorListener {
     @Override
-    public void onError(MediaRecorder arg0, int arg1, int arg2) {
-    }
+    public void onError(MediaRecorder arg0, int arg1, int arg2) {}
   }
 
   private static class TestInfoListener implements MediaRecorder.OnInfoListener {
     @Override
-    public void onInfo(MediaRecorder mr, int what, int extra) {
-    }
+    public void onInfo(MediaRecorder mr, int what, int extra) {}
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaRouterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaRouterTest.java
index 44b2ee8f6..41e5b3b7b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaRouterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaRouterTest.java
@@ -48,12 +48,6 @@ public final class ShadowMediaRouterTest {
     RouteInfo bluetoothRoute = mediaRouter.getRouteAt(1);
     assertThat(bluetoothRoute.getName().toString())
         .isEqualTo(ShadowMediaRouter.BLUETOOTH_DEVICE_NAME);
-  }
-
-  @Test
-  public void testAddBluetoothRoute_checkBluetoothRouteProperties_apiJbMr2() {
-    shadowOf(mediaRouter).addBluetoothRoute();
-    RouteInfo bluetoothRoute = mediaRouter.getRouteAt(1);
     assertThat(bluetoothRoute.getDescription().toString()).isEqualTo("Bluetooth audio");
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaSessionManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaSessionManagerTest.java
index dbd37216f..bc96883ad 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaSessionManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaSessionManagerTest.java
@@ -6,7 +6,6 @@ import android.content.Context;
 import android.media.session.MediaController;
 import android.media.session.MediaSession;
 import android.media.session.MediaSessionManager;
-import android.os.Build;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.ArrayList;
@@ -15,11 +14,9 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Shadows;
-import org.robolectric.annotation.Config;
 
 /** Tests for {@link ShadowMediaSessionManager} */
 @RunWith(AndroidJUnit4.class)
-@Config(minSdk = Build.VERSION_CODES.LOLLIPOP)
 public class ShadowMediaSessionManagerTest {
 
   private MediaSessionManager mediaSessionManager;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaSessionTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaSessionTest.java
index 3f1e48621..bae7f3bc8 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaSessionTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaSessionTest.java
@@ -1,16 +1,13 @@
 package org.robolectric.shadows;
 
 import android.media.session.MediaSession;
-import android.os.Build;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
 
 /** Tests for robolectric functionality around {@link MediaSession}. */
 @RunWith(AndroidJUnit4.class)
-@Config(minSdk = Build.VERSION_CODES.LOLLIPOP)
 public class ShadowMediaSessionTest {
   @Test
   public void mediaSessionCompat_creation() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMergeCursorTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMergeCursorTest.java
index f8e3c50cf..405b67e4f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMergeCursorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMergeCursorTest.java
@@ -65,7 +65,8 @@ public class ShadowMergeCursorTest {
     dbCursor2.close();
   }
 
-  private SQLiteCursor setupTable(final String createSql, final String[] insertions, final String selectSql) {
+  private SQLiteCursor setupTable(
+      final String createSql, final String[] insertions, final String selectSql) {
     database.execSQL(createSql);
 
     for (String insert : insertions) {
@@ -93,7 +94,7 @@ public class ShadowMergeCursorTest {
   @Test
   public void testEmptyCursors() {
     // cursor list with null contents
-    cursor = new MergeCursor( new Cursor[1] );
+    cursor = new MergeCursor(new Cursor[1]);
     assertThat(cursor.getCount()).isEqualTo(0);
     assertThat(cursor.moveToFirst()).isFalse();
     assertThat(cursor.getColumnNames()).isNotNull();
@@ -103,7 +104,7 @@ public class ShadowMergeCursorTest {
     Cursor[] cursors = new Cursor[2];
     cursors[0] = null;
     cursors[1] = dbCursor1;
-    cursor = new MergeCursor( cursors );
+    cursor = new MergeCursor(cursors);
     assertThat(cursor.getCount()).isEqualTo(TABLE_1_INSERTS.length);
     assertThat(cursor.moveToFirst()).isTrue();
     assertThat(cursor.getColumnNames()).isNotNull();
@@ -115,7 +116,7 @@ public class ShadowMergeCursorTest {
     cursors[0] = null;
     cursors[1] = null;
 
-    cursor = new MergeCursor( cursors );
+    cursor = new MergeCursor(cursors);
     assertThat(cursor.getCount()).isEqualTo(0);
     assertThat(cursor.getColumnNames()).isNotNull();
 
@@ -129,7 +130,7 @@ public class ShadowMergeCursorTest {
     Cursor[] cursors = new Cursor[1];
     cursors[0] = dbCursor1;
 
-    assertBounds( cursors, TABLE_1_INSERTS.length );
+    assertBounds(cursors, TABLE_1_INSERTS.length);
   }
 
   @Test
@@ -138,16 +139,16 @@ public class ShadowMergeCursorTest {
     cursors[0] = dbCursor1;
     cursors[1] = dbCursor2;
 
-    assertBounds( cursors, TABLE_1_INSERTS.length + TABLE_2_INSERTS.length );
+    assertBounds(cursors, TABLE_1_INSERTS.length + TABLE_2_INSERTS.length);
   }
 
-  private void assertBounds( Cursor[] cursors, int expectedLength ) {
-    cursor = new MergeCursor( cursors );
+  private void assertBounds(Cursor[] cursors, int expectedLength) {
+    cursor = new MergeCursor(cursors);
 
     assertThat(cursor.getCount()).isEqualTo(expectedLength);
     assertThat(cursor.moveToFirst()).isTrue();
 
-    for ( int i = 0; i < expectedLength; i++ ) {
+    for (int i = 0; i < expectedLength; i++) {
       assertThat(cursor.moveToPosition(i)).isTrue();
       assertThat(cursor.isAfterLast()).isFalse();
     }
@@ -160,7 +161,7 @@ public class ShadowMergeCursorTest {
   public void testGetDataSingleCursor() throws Exception {
     Cursor[] cursors = new Cursor[1];
     cursors[0] = dbCursor1;
-    cursor = new MergeCursor( cursors );
+    cursor = new MergeCursor(cursors);
 
     cursor.moveToFirst();
     assertDataCursor1();
@@ -171,7 +172,7 @@ public class ShadowMergeCursorTest {
     Cursor[] cursors = new Cursor[2];
     cursors[0] = dbCursor1;
     cursors[1] = dbCursor2;
-    cursor = new MergeCursor( cursors );
+    cursor = new MergeCursor(cursors);
 
     cursor.moveToFirst();
     assertDataCursor1();
@@ -215,9 +216,9 @@ public class ShadowMergeCursorTest {
   public void testColumnNamesSingleCursor() {
     Cursor[] cursors = new Cursor[1];
     cursors[0] = dbCursor1;
-    cursor = new MergeCursor( cursors );
+    cursor = new MergeCursor(cursors);
 
-    for ( int i = 0; i < TABLE_1_INSERTS.length; i++ ) {
+    for (int i = 0; i < TABLE_1_INSERTS.length; i++) {
       cursor.moveToPosition(i);
       String[] columnNames = cursor.getColumnNames();
       assertColumnNamesCursor1(columnNames);
@@ -229,15 +230,15 @@ public class ShadowMergeCursorTest {
     Cursor[] cursors = new Cursor[2];
     cursors[0] = dbCursor1;
     cursors[1] = dbCursor2;
-    cursor = new MergeCursor( cursors );
+    cursor = new MergeCursor(cursors);
 
-    for ( int i = 0; i < TABLE_1_INSERTS.length; i++ ) {
+    for (int i = 0; i < TABLE_1_INSERTS.length; i++) {
       cursor.moveToPosition(i);
       String[] columnNames = cursor.getColumnNames();
       assertColumnNamesCursor1(columnNames);
     }
 
-    for ( int i = 0; i < TABLE_2_INSERTS.length; i++ ) {
+    for (int i = 0; i < TABLE_2_INSERTS.length; i++) {
       cursor.moveToPosition(i + TABLE_1_INSERTS.length);
       String[] columnNames = cursor.getColumnNames();
       assertColumnNamesCursor2(columnNames);
@@ -271,7 +272,7 @@ public class ShadowMergeCursorTest {
     Cursor[] cursors = new Cursor[2];
     cursors[0] = dbCursor1;
     cursors[1] = dbCursor2;
-    cursor = new MergeCursor( cursors );
+    cursor = new MergeCursor(cursors);
 
     assertThat(cursor.isClosed()).isFalse();
     assertThat(dbCursor1.isClosed()).isFalse();
@@ -283,5 +284,4 @@ public class ShadowMergeCursorTest {
     assertThat(dbCursor1.isClosed()).isTrue();
     assertThat(dbCursor2.isClosed()).isTrue();
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMimeTypeMapTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMimeTypeMapTest.java
index 47ed360b2..11f4440bd 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMimeTypeMapTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMimeTypeMapTest.java
@@ -60,11 +60,15 @@ public class ShadowMimeTypeMapTest {
     assertTrue(MimeTypeMap.getSingleton().hasMimeType(VIDEO_MIMETYPE));
     assertTrue(MimeTypeMap.getSingleton().hasMimeType(IMAGE_MIMETYPE));
 
-    assertEquals(IMAGE_EXTENSION, MimeTypeMap.getSingleton().getExtensionFromMimeType(IMAGE_MIMETYPE));
-    assertEquals(VIDEO_EXTENSION, MimeTypeMap.getSingleton().getExtensionFromMimeType(VIDEO_MIMETYPE));
-
-    assertEquals(IMAGE_MIMETYPE, MimeTypeMap.getSingleton().getMimeTypeFromExtension(IMAGE_EXTENSION));
-    assertEquals(VIDEO_MIMETYPE, MimeTypeMap.getSingleton().getMimeTypeFromExtension(VIDEO_EXTENSION));
+    assertEquals(
+        IMAGE_EXTENSION, MimeTypeMap.getSingleton().getExtensionFromMimeType(IMAGE_MIMETYPE));
+    assertEquals(
+        VIDEO_EXTENSION, MimeTypeMap.getSingleton().getExtensionFromMimeType(VIDEO_MIMETYPE));
+
+    assertEquals(
+        IMAGE_MIMETYPE, MimeTypeMap.getSingleton().getMimeTypeFromExtension(IMAGE_EXTENSION));
+    assertEquals(
+        VIDEO_MIMETYPE, MimeTypeMap.getSingleton().getMimeTypeFromExtension(VIDEO_EXTENSION));
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMotionEventTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMotionEventTest.java
index 78269500b..7c3bcb6eb 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMotionEventTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMotionEventTest.java
@@ -45,7 +45,8 @@ public class ShadowMotionEventTest {
   @Test
   public void indexShowsUpInAction() {
     shadowMotionEvent.setPointerIndex(1);
-    assertEquals(1 << MotionEvent.ACTION_POINTER_ID_SHIFT | MotionEvent.ACTION_MOVE, event.getAction());
+    assertEquals(
+        1 << MotionEvent.ACTION_POINTER_ID_SHIFT | MotionEvent.ACTION_MOVE, event.getAction());
   }
 
   @Test
@@ -75,11 +76,15 @@ public class ShadowMotionEventTest {
   public void obtainEventsWithDistinctPointerIds() {
     int[] event1Ids = {88};
     MotionEvent.PointerCoords[] event1Coords = {createCoords(5.0f, 10.0f)};
-    MotionEvent event1 = MotionEvent.obtain(0, 0, MotionEvent.ACTION_DOWN, 1, event1Ids, event1Coords, 0, 1.0f, 1.0f, 0, 0, 0, 0);
+    MotionEvent event1 =
+        MotionEvent.obtain(
+            0, 0, MotionEvent.ACTION_DOWN, 1, event1Ids, event1Coords, 0, 1.0f, 1.0f, 0, 0, 0, 0);
 
     int[] event2Ids = {99};
     MotionEvent.PointerCoords[] event2Coords = {createCoords(20.0f, 30.0f)};
-    MotionEvent event2 = MotionEvent.obtain(0, 0, MotionEvent.ACTION_DOWN, 1, event2Ids, event2Coords, 0, 1.0f, 1.0f, 0, 0, 0, 0);
+    MotionEvent event2 =
+        MotionEvent.obtain(
+            0, 0, MotionEvent.ACTION_DOWN, 1, event2Ids, event2Coords, 0, 1.0f, 1.0f, 0, 0, 0, 0);
 
     assertEquals(1, event1.getPointerCount());
     assertEquals(88, event1.getPointerId(0));
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowNetworkCapabilitiesTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowNetworkCapabilitiesTest.java
index 972e32ea5..ba00473bd 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowNetworkCapabilitiesTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowNetworkCapabilitiesTest.java
@@ -113,4 +113,15 @@ public class ShadowNetworkCapabilitiesTest {
     shadowOf(networkCapabilities).setLinkDownstreamBandwidthKbps(100);
     assertThat(networkCapabilities.getLinkDownstreamBandwidthKbps()).isEqualTo(100);
   }
+
+  @Test
+  public void resetCapabilities_resetsCapabilities() {
+    NetworkCapabilities networkCapabilities = ShadowNetworkCapabilities.newInstance();
+    ShadowNetworkCapabilities shadowNetworkCapabilities = shadowOf(networkCapabilities);
+    shadowNetworkCapabilities.addCapability(NET_CAPABILITY_MMS);
+
+    shadowNetworkCapabilities.clearCapabilities();
+
+    assertThat(networkCapabilities.hasCapability(NET_CAPABILITY_MMS)).isFalse();
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationBuilder25Test.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationBuilder25Test.java
index de671e9fe..e39e6caed 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationBuilder25Test.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationBuilder25Test.java
@@ -10,8 +10,8 @@ import org.junit.runner.RunWith;
 public class ShadowNotificationBuilder25Test extends ShadowNotificationBuilderTestBase {
 
   /**
-   * run 'em all again with android:targetSdkVersion=25 - behavior of NotificationBuilder
-   * varies based on version specified in Manifest rather than runtime framework version.
+   * run 'em all again with android:targetSdkVersion=25 - behavior of NotificationBuilder varies
+   * based on version specified in Manifest rather than runtime framework version.
    */
   @Before
   public void setup() throws Exception {
@@ -22,5 +22,4 @@ public class ShadowNotificationBuilder25Test extends ShadowNotificationBuilderTe
             .targetSdkVersion =
         Build.VERSION_CODES.N_MR1;
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationBuilderTestBase.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationBuilderTestBase.java
index fe3483e2c..39fb9235c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationBuilderTestBase.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationBuilderTestBase.java
@@ -109,40 +109,46 @@ public abstract class ShadowNotificationBuilderTestBase {
 
   @Test
   public void build_setsUsesChronometerOnNotification_true() {
-    Notification notification = builder.setUsesChronometer(true).setWhen(10).setShowWhen(true).build();
+    Notification notification =
+        builder.setUsesChronometer(true).setWhen(10).setShowWhen(true).build();
 
     assertThat(shadowOf(notification).usesChronometer()).isTrue();
   }
 
   @Test
   public void build_setsUsesChronometerOnNotification_false() {
-    Notification notification = builder.setUsesChronometer(false).setWhen(10).setShowWhen(true).build();
+    Notification notification =
+        builder.setUsesChronometer(false).setWhen(10).setShowWhen(true).build();
 
     assertThat(shadowOf(notification).usesChronometer()).isFalse();
   }
 
-  @Test @Config(maxSdk = M)
+  @Test
+  @Config(maxSdk = M)
   public void build_handlesNullContentTitle() {
     Notification notification = builder.setContentTitle(null).build();
 
     assertThat(shadowOf(notification).getContentTitle().toString()).isEmpty();
   }
 
-  @Test @Config(minSdk = N)
+  @Test
+  @Config(minSdk = N)
   public void build_handlesNullContentTitle_atLeastN() {
     Notification notification = builder.setContentTitle(null).build();
 
     assertThat(shadowOf(notification).getContentTitle()).isNull();
   }
 
-  @Test @Config(maxSdk = M)
+  @Test
+  @Config(maxSdk = M)
   public void build_handlesNullContentText() {
     Notification notification = builder.setContentText(null).build();
 
     assertThat(shadowOf(notification).getContentText().toString()).isEmpty();
   }
 
-  @Test @Config(minSdk = N)
+  @Test
+  @Config(minSdk = N)
   public void build_handlesNullContentText_atLeastN() {
     Notification notification = builder.setContentText(null).build();
 
@@ -156,14 +162,16 @@ public abstract class ShadowNotificationBuilderTestBase {
     assertThat(notification.tickerText).isNull();
   }
 
-  @Test @Config(maxSdk = M)
+  @Test
+  @Config(maxSdk = M)
   public void build_handlesNullContentInfo() {
     Notification notification = builder.setContentInfo(null).build();
 
     assertThat(shadowOf(notification).getContentInfo().toString()).isEmpty();
   }
 
-  @Test @Config(minSdk = N)
+  @Test
+  @Config(minSdk = N)
   public void build_handlesNullContentInfo_atLeastN() {
     Notification notification = builder.setContentInfo(null).build();
 
@@ -213,11 +221,14 @@ public abstract class ShadowNotificationBuilderTestBase {
 
   @Test
   public void withBigTextStyle() {
-    Notification notification = builder.setStyle(new Notification.BigTextStyle(builder)
-        .bigText("BigText")
-        .setBigContentTitle("Title")
-        .setSummaryText("Summary"))
-        .build();
+    Notification notification =
+        builder
+            .setStyle(
+                new Notification.BigTextStyle(builder)
+                    .bigText("BigText")
+                    .setBigContentTitle("Title")
+                    .setSummaryText("Summary"))
+            .build();
 
     assertThat(shadowOf(notification).getBigText().toString()).isEqualTo("BigText");
     assertThat(shadowOf(notification).getBigContentTitle().toString()).isEqualTo("Title");
@@ -233,10 +244,13 @@ public abstract class ShadowNotificationBuilderTestBase {
             ApplicationProvider.getApplicationContext().getResources(), R.drawable.an_image);
 
     Icon bigLargeIcon = Icon.createWithBitmap(bigPicture);
-    Notification notification = builder.setStyle(new Notification.BigPictureStyle(builder)
-        .bigPicture(bigPicture)
-        .bigLargeIcon(bigLargeIcon))
-        .build();
+    Notification notification =
+        builder
+            .setStyle(
+                new Notification.BigPictureStyle(builder)
+                    .bigPicture(bigPicture)
+                    .bigLargeIcon(bigLargeIcon))
+            .build();
 
     assertThat(shadowOf(notification).getBigPicture().sameAs(bigPicture)).isTrue();
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationListenerServiceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationListenerServiceTest.java
index 3a249a878..6c8f0e630 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationListenerServiceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationListenerServiceTest.java
@@ -7,7 +7,6 @@ import static org.robolectric.Shadows.shadowOf;
 import android.app.Notification;
 import android.content.ComponentName;
 import android.content.Context;
-import android.os.Build;
 import android.os.Build.VERSION_CODES;
 import android.service.notification.NotificationListenerService;
 import android.service.notification.StatusBarNotification;
@@ -21,7 +20,6 @@ import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 
 /** Test for ShadowNotificationListenerService. */
-@Config(minSdk = Build.VERSION_CODES.LOLLIPOP)
 @RunWith(AndroidJUnit4.class)
 public final class ShadowNotificationListenerServiceTest {
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationManagerTest.java
index e2bf4238e..7e9ce69a3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationManagerTest.java
@@ -72,6 +72,16 @@ public class ShadowNotificationManagerTest {
     assertThat(notificationManager.getNotificationPolicy()).isEqualTo(policy);
   }
 
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.R)
+  public void getConsolidatedNotificationPolicy() {
+    assertThat(notificationManager.getConsolidatedNotificationPolicy()).isNull();
+
+    final Policy policy = new Policy(0, 0, 0);
+    shadowOf(notificationManager).setConsolidatedNotificationPolicy(policy);
+    assertThat(notificationManager.getConsolidatedNotificationPolicy()).isEqualTo(policy);
+  }
+
   @Test
   @Config(minSdk = Build.VERSION_CODES.O)
   public void createNotificationChannel() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowObjectAnimatorTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowObjectAnimatorTest.java
index 72654a720..b078f4cb3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowObjectAnimatorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowObjectAnimatorTest.java
@@ -17,27 +17,28 @@ public class ShadowObjectAnimatorTest {
   private final AnimatorTarget target = new AnimatorTarget();
   private List<String> listenerEvents = new ArrayList<>();
 
-  private final Animator.AnimatorListener listener = new Animator.AnimatorListener() {
-    @Override
-    public void onAnimationStart(Animator animation) {
-      listenerEvents.add("started");
-    }
+  private final Animator.AnimatorListener listener =
+      new Animator.AnimatorListener() {
+        @Override
+        public void onAnimationStart(Animator animation) {
+          listenerEvents.add("started");
+        }
 
-    @Override
-    public void onAnimationEnd(Animator animation) {
-      listenerEvents.add("ended");
-    }
+        @Override
+        public void onAnimationEnd(Animator animation) {
+          listenerEvents.add("ended");
+        }
 
-    @Override
-    public void onAnimationCancel(Animator animation) {
-      listenerEvents.add("cancelled");
-    }
+        @Override
+        public void onAnimationCancel(Animator animation) {
+          listenerEvents.add("cancelled");
+        }
 
-    @Override
-    public void onAnimationRepeat(Animator animation) {
-      listenerEvents.add("repeated");
-    }
-  };
+        @Override
+        public void onAnimationRepeat(Animator animation) {
+          listenerEvents.add("repeated");
+        }
+      };
 
   @Test
   public void start_shouldRunAnimation() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowOpenGLMatrixTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowOpenGLMatrixTest.java
index 8784162c0..1e01a99f0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowOpenGLMatrixTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowOpenGLMatrixTest.java
@@ -59,12 +59,13 @@ public class ShadowOpenGLMatrixTest {
     final float[] res = new float[16];
     final float[] i = new float[16];
     Matrix.setIdentityM(i, 0);
-    final float[] m1 = new float[]{
-            1, 2, 3, 4,
-            5, 6, 7, 8,
-            9, 10, 11, 12,
-            13, 14, 15, 16
-    };
+    final float[] m1 =
+        new float[] {
+          1, 2, 3, 4,
+          5, 6, 7, 8,
+          9, 10, 11, 12,
+          13, 14, 15, 16
+        };
     Matrix.multiplyMM(res, 0, m1, 0, i, 0);
     assertThat(res).usingExactEquality().containsAtLeast(m1);
 
@@ -77,17 +78,17 @@ public class ShadowOpenGLMatrixTest {
     final float[] res = new float[32];
     final float[] i = new float[32];
     Matrix.setIdentityM(i, 16);
-    final float[] m1 = new float[]{
-            0, 0, 0, 0,
-            0, 0, 0, 0,
-            0, 0, 0, 0,
-            0, 0, 0, 0,
-
-            1, 2, 3, 4,
-            5, 6, 7, 8,
-            9, 10, 11, 12,
-            13, 14, 15, 16
-    };
+    final float[] m1 =
+        new float[] {
+          0, 0, 0, 0,
+          0, 0, 0, 0,
+          0, 0, 0, 0,
+          0, 0, 0, 0,
+          1, 2, 3, 4,
+          5, 6, 7, 8,
+          9, 10, 11, 12,
+          13, 14, 15, 16
+        };
     Matrix.multiplyMM(res, 16, m1, 16, i, 16);
     assertThat(res).usingExactEquality().containsAtLeast(m1);
 
@@ -98,26 +99,28 @@ public class ShadowOpenGLMatrixTest {
   @Test
   public void multiplyMM() {
     final float[] res = new float[16];
-    final float[] m1 = new float[]{
-            0, 1, 2, 3,
-            4, 5, 6, 7,
-            8, 9, 10, 11,
-            12, 13, 14, 15
-    };
-    final float[] m2 = new float[]{
-            0, 1, 2, 3,
-            4, 5, 6, 7,
-            8, 9, 10, 11,
-            12, 13, 14, 15
-    };
-
-    final float[] expected = new float[]{
-            56, 62, 68, 74,
-            152, 174, 196, 218,
-            248, 286, 324, 362,
-            344, 398, 452, 506
-    };
-
+    final float[] m1 =
+        new float[] {
+          0, 1, 2, 3,
+          4, 5, 6, 7,
+          8, 9, 10, 11,
+          12, 13, 14, 15
+        };
+    final float[] m2 =
+        new float[] {
+          0, 1, 2, 3,
+          4, 5, 6, 7,
+          8, 9, 10, 11,
+          12, 13, 14, 15
+        };
+
+    final float[] expected =
+        new float[] {
+          56, 62, 68, 74,
+          152, 174, 196, 218,
+          248, 286, 324, 362,
+          344, 398, 452, 506
+        };
 
     Matrix.multiplyMM(res, 0, m1, 0, m2, 0);
     assertThat(res).usingExactEquality().containsAtLeast(expected);
@@ -126,37 +129,39 @@ public class ShadowOpenGLMatrixTest {
   @Test
   public void multiplyMMWithOffset() {
     final float[] res = new float[32];
-    final float[] m1 = new float[]{
-            0, 0, 0, 0,
-            0, 0, 0, 0,
-            0, 0, 0, 0,
-            0, 0, 0, 0,
-
-            0, 1, 2, 3,
-            4, 5, 6, 7,
-            8, 9, 10, 11,
-            12, 13, 14, 15
-    };
-    final float[] m2 = new float[]{
-            0, 0, 0, 0,
-            0, 0, 0, 0,
-            0, 0, 0, 0,
-            0, 0, 0, 0,
-            56, 62, 68, 74,
-            152, 174, 196, 218,
-            248, 286, 324, 362,
-            344, 398, 452, 506
-    };
-    final float[] expected = new float[]{
-            0, 0, 0, 0,
-            0, 0, 0, 0,
-            0, 0, 0, 0,
-            0, 0, 0, 0,
-            1680, 1940, 2200, 2460,
-            4880, 5620, 6360, 7100,
-            8080, 9300, 10520, 11740,
-            11280, 12980, 14680, 16380
-    };
+    final float[] m1 =
+        new float[] {
+          0, 0, 0, 0,
+          0, 0, 0, 0,
+          0, 0, 0, 0,
+          0, 0, 0, 0,
+          0, 1, 2, 3,
+          4, 5, 6, 7,
+          8, 9, 10, 11,
+          12, 13, 14, 15
+        };
+    final float[] m2 =
+        new float[] {
+          0, 0, 0, 0,
+          0, 0, 0, 0,
+          0, 0, 0, 0,
+          0, 0, 0, 0,
+          56, 62, 68, 74,
+          152, 174, 196, 218,
+          248, 286, 324, 362,
+          344, 398, 452, 506
+        };
+    final float[] expected =
+        new float[] {
+          0, 0, 0, 0,
+          0, 0, 0, 0,
+          0, 0, 0, 0,
+          0, 0, 0, 0,
+          1680, 1940, 2200, 2460,
+          4880, 5620, 6360, 7100,
+          8080, 9300, 10520, 11740,
+          11280, 12980, 14680, 16380
+        };
 
     Matrix.multiplyMM(res, 16, m1, 16, m2, 16);
     assertThat(res).usingExactEquality().containsAtLeast(expected);
@@ -164,25 +169,28 @@ public class ShadowOpenGLMatrixTest {
 
   @Test
   public void multiplyMMRandom() {
-    final float[] m1 = new float[]{
-            0.730964f, 0.006556f, 0.999294f, 0.886486f,
-            0.703636f, 0.865595f, 0.464857f, 0.861619f,
-            0.304945f, 0.740410f, 0.059668f, 0.876067f,
-            0.048256f, 0.259968f, 0.915555f, 0.356720f,
-    };
-    final float[] m2 = new float[]{
-            0.462205f, 0.868120f, 0.520904f, 0.959729f,
-            0.531887f, 0.882446f, 0.293452f, 0.878477f,
-            0.938628f, 0.796945f, 0.757566f, 0.983955f,
-            0.346051f, 0.972866f, 0.773706f, 0.895736f,
-    };
-
-    final float[] expected = new float[]{
-            1.153855f, 1.389652f, 1.775197f, 1.956428f,
-            1.141589f, 1.212979f, 1.763527f, 1.802296f,
-            1.525360f, 1.512691f, 2.254498f, 2.533418f,
-            1.216656f, 1.650098f, 1.664312f, 2.142354f,
-    };
+    final float[] m1 =
+        new float[] {
+          0.730964f, 0.006556f, 0.999294f, 0.886486f,
+          0.703636f, 0.865595f, 0.464857f, 0.861619f,
+          0.304945f, 0.740410f, 0.059668f, 0.876067f,
+          0.048256f, 0.259968f, 0.915555f, 0.356720f,
+        };
+    final float[] m2 =
+        new float[] {
+          0.462205f, 0.868120f, 0.520904f, 0.959729f,
+          0.531887f, 0.882446f, 0.293452f, 0.878477f,
+          0.938628f, 0.796945f, 0.757566f, 0.983955f,
+          0.346051f, 0.972866f, 0.773706f, 0.895736f,
+        };
+
+    final float[] expected =
+        new float[] {
+          1.153855f, 1.389652f, 1.775197f, 1.956428f,
+          1.141589f, 1.212979f, 1.763527f, 1.802296f,
+          1.525360f, 1.512691f, 2.254498f, 2.533418f,
+          1.216656f, 1.650098f, 1.664312f, 2.142354f,
+        };
     final float[] res = new float[16];
     Matrix.multiplyMM(res, 0, m1, 0, m2, 0);
     assertMatrixWithPrecision(res, expected, 0.0001f);
@@ -238,7 +246,7 @@ public class ShadowOpenGLMatrixTest {
     final float[] res = new float[4];
     final float[] i = new float[16];
     Matrix.setIdentityM(i, 0);
-    float[] v1 = new float[]{1, 2, 3, 4};
+    float[] v1 = new float[] {1, 2, 3, 4};
     Matrix.multiplyMV(res, 0, i, 0, v1, 0);
     assertThat(res).usingExactEquality().containsAtLeast(v1);
   }
@@ -246,15 +254,16 @@ public class ShadowOpenGLMatrixTest {
   @Test
   public void multiplyMV() {
     final float[] res = new float[4];
-    final float[] m1 = new float[]{
-            0, 1, 2, 3,
-            4, 5, 6, 7,
-            8, 9, 10, 11,
-            12, 13, 14, 15
-    };
-
-    float[] v1 = new float[]{42, 239, 128, 1024};
-    float[] expected = new float[]{14268, 15701, 17134, 18567};
+    final float[] m1 =
+        new float[] {
+          0, 1, 2, 3,
+          4, 5, 6, 7,
+          8, 9, 10, 11,
+          12, 13, 14, 15
+        };
+
+    float[] v1 = new float[] {42, 239, 128, 1024};
+    float[] expected = new float[] {14268, 15701, 17134, 18567};
     Matrix.multiplyMV(res, 0, m1, 0, v1, 0);
     assertThat(res).usingExactEquality().containsAtLeast(expected);
   }
@@ -262,40 +271,38 @@ public class ShadowOpenGLMatrixTest {
   @Test
   public void multiplyMVWithOffset() {
     final float[] res = new float[5];
-    final float[] m1 = new float[]{
-            0, 0, 0, 0,
-            0, 1, 2, 3,
-            4, 5, 6, 7,
-            8, 9, 10, 11,
-            12, 13, 14, 15
-    };
-
-    float[] v1 = new float[]{
-            0, 0,
-            42, 239, 128, 1024
-    };
-    float[] expected = new float[]{
-            0,
-            14268, 15701, 17134, 18567
-    };
+    final float[] m1 =
+        new float[] {
+          0, 0, 0, 0,
+          0, 1, 2, 3,
+          4, 5, 6, 7,
+          8, 9, 10, 11,
+          12, 13, 14, 15
+        };
+
+    float[] v1 = new float[] {0, 0, 42, 239, 128, 1024};
+    float[] expected = new float[] {0, 14268, 15701, 17134, 18567};
     Matrix.multiplyMV(res, 1, m1, 4, v1, 2);
     assertThat(res).usingExactEquality().containsAtLeast(expected);
   }
 
   @Test
   public void multiplyMVRandom() {
-    final float[] m1 = new float[]{
-            0.575544f, 0.182558f, 0.097663f, 0.413832f,
-            0.781248f, 0.466904f, 0.353418f, 0.790540f,
-            0.074133f, 0.690470f, 0.619758f, 0.191669f,
-            0.953532f, 0.018836f, 0.336544f, 0.972782f,
-    };
-    final float[] v2 = new float[]{
-            0.573973f, 0.096736f, 0.330662f, 0.758732f,
-    };
-    final float[] expected = new float[]{
-            1.153910f, 0.392554f, 0.550521f, 1.115460f,
-    };
+    final float[] m1 =
+        new float[] {
+          0.575544f, 0.182558f, 0.097663f, 0.413832f,
+          0.781248f, 0.466904f, 0.353418f, 0.790540f,
+          0.074133f, 0.690470f, 0.619758f, 0.191669f,
+          0.953532f, 0.018836f, 0.336544f, 0.972782f,
+        };
+    final float[] v2 =
+        new float[] {
+          0.573973f, 0.096736f, 0.330662f, 0.758732f,
+        };
+    final float[] expected =
+        new float[] {
+          1.153910f, 0.392554f, 0.550521f, 1.115460f,
+        };
     final float[] res = new float[4];
     Matrix.multiplyMV(res, 0, m1, 0, v2, 0);
     assertMatrixWithPrecision(res, expected, 0.0001f);
@@ -308,19 +315,16 @@ public class ShadowOpenGLMatrixTest {
 
   @Test
   public void testInvertM() {
-    float[] matrix = new float[]{
-            10, 0, 0, 0,
-            0, 20, 0, 0,
-            0, 0, 30, 0,
-            40, 50, 60, 1
-    };
-
-    float[] inverse = new float[]{
-            0.1f, 0, 0, 0,
-            0, 0.05f, 0, 0,
-            0, 0, 0.03333f, 0,
-            -4, -2.5f, -2, 1
-    };
+    float[] matrix =
+        new float[] {
+          10, 0, 0, 0,
+          0, 20, 0, 0,
+          0, 0, 30, 0,
+          40, 50, 60, 1
+        };
+
+    float[] inverse =
+        new float[] {0.1f, 0, 0, 0, 0, 0.05f, 0, 0, 0, 0, 0.03333f, 0, -4, -2.5f, -2, 1};
     float[] output = new float[16];
     assertThat(Matrix.invertM(output, 0, matrix, 0)).isTrue();
 
@@ -329,24 +333,27 @@ public class ShadowOpenGLMatrixTest {
 
   @Test
   public void testMultiplyMM() {
-    float[] matrix1 = new float[]{
-            1, 2, 3, 4,
-            5, 6, 7, 8,
-            9, 10, 11, 12,
-            13, 14, 15, 16
-    };
-    float[] matrix2 = new float[]{
-            16, 15, 14, 13,
-            12, 11, 10, 9,
-            8, 7, 6, 5,
-            4, 3, 2, 1
-    };
-    float[] expected = new float[]{
-            386, 444, 502, 560,
-            274, 316, 358, 400,
-            162, 188, 214, 240,
-            50, 60, 70, 80,
-    };
+    float[] matrix1 =
+        new float[] {
+          1, 2, 3, 4,
+          5, 6, 7, 8,
+          9, 10, 11, 12,
+          13, 14, 15, 16
+        };
+    float[] matrix2 =
+        new float[] {
+          16, 15, 14, 13,
+          12, 11, 10, 9,
+          8, 7, 6, 5,
+          4, 3, 2, 1
+        };
+    float[] expected =
+        new float[] {
+          386, 444, 502, 560,
+          274, 316, 358, 400,
+          162, 188, 214, 240,
+          50, 60, 70, 80,
+        };
 
     float[] output = new float[16];
     Matrix.multiplyMM(output, 0, matrix1, 0, matrix2, 0);
@@ -355,12 +362,10 @@ public class ShadowOpenGLMatrixTest {
 
   @Test
   public void testFrustum() {
-    float[] expected = new float[]{
-            0.005f, 0, 0, 0,
-            0, 0.02f, 0, 0,
-            1.5f, 5, -1.020202f, -1,
-            0, 0, -2.020202f, 0,
-    };
+    float[] expected =
+        new float[] {
+          0.005f, 0, 0, 0, 0, 0.02f, 0, 0, 1.5f, 5, -1.020202f, -1, 0, 0, -2.020202f, 0,
+        };
     float[] output = new float[16];
     Matrix.frustumM(output, 0, 100, 500, 200, 300, 1, 100);
     assertThat(output).usingExactEquality().containsAtLeast(expected);
@@ -368,12 +373,10 @@ public class ShadowOpenGLMatrixTest {
 
   @Test
   public void testPerspectiveM() {
-    float[] expected = new float[]{
-            1145.9144f, 0, 0, 0,
-            0, 572.9572f, 0, 0,
-            0, 0, -1.020202f, -1,
-            0, 0, -2.020202f, 0,
-    };
+    float[] expected =
+        new float[] {
+          1145.9144f, 0, 0, 0, 0, 572.9572f, 0, 0, 0, 0, -1.020202f, -1, 0, 0, -2.020202f, 0,
+        };
     float[] output = new float[16];
     Matrix.perspectiveM(output, 0, 0.2f, 0.5f, 1, 100);
     assertThat(output).usingExactEquality().containsAtLeast(expected);
@@ -381,15 +384,16 @@ public class ShadowOpenGLMatrixTest {
 
   @Test
   public void testMultiplyMV() {
-    float[] matrix = new float[]{
-            2, 0, 0, 0,
-            0, 4, 0, 0,
-            0, 0, 6, 0,
-            1, 2, 3, 1
-    };
-
-    float[] vector = new float[]{5, 7, 9, 1};
-    float[] expected = new float[]{11, 30, 57, 1};
+    float[] matrix =
+        new float[] {
+          2, 0, 0, 0,
+          0, 4, 0, 0,
+          0, 0, 6, 0,
+          1, 2, 3, 1
+        };
+
+    float[] vector = new float[] {5, 7, 9, 1};
+    float[] expected = new float[] {11, 30, 57, 1};
     float[] output = new float[4];
     Matrix.multiplyMV(output, 0, matrix, 0, vector, 0);
     assertThat(output).usingExactEquality().containsAtLeast(expected);
@@ -397,36 +401,40 @@ public class ShadowOpenGLMatrixTest {
 
   @Test
   public void testSetIdentityM() {
-    float[] matrix = new float[]{
-            1, 2, 3, 4,
-            5, 6, 7, 8,
-            9, 10, 11, 12,
-            13, 14, 15, 16
-    };
-    float[] expected = new float[]{
-            1, 0, 0, 0,
-            0, 1, 0, 0,
-            0, 0, 1, 0,
-            0, 0, 0, 1
-    };
+    float[] matrix =
+        new float[] {
+          1, 2, 3, 4,
+          5, 6, 7, 8,
+          9, 10, 11, 12,
+          13, 14, 15, 16
+        };
+    float[] expected =
+        new float[] {
+          1, 0, 0, 0,
+          0, 1, 0, 0,
+          0, 0, 1, 0,
+          0, 0, 0, 1
+        };
     Matrix.setIdentityM(matrix, 0);
     assertThat(matrix).usingExactEquality().containsAtLeast(expected);
   }
 
   @Test
   public void testScaleM() {
-    float[] matrix = new float[]{
-            1, 2, 3, 4,
-            5, 6, 7, 8,
-            9, 10, 11, 12,
-            13, 14, 15, 16
-    };
-    float[] expected = new float[]{
-            2, 4, 6, 8,
-            20, 24, 28, 32,
-            54, 60, 66, 72,
-            13, 14, 15, 16
-    };
+    float[] matrix =
+        new float[] {
+          1, 2, 3, 4,
+          5, 6, 7, 8,
+          9, 10, 11, 12,
+          13, 14, 15, 16
+        };
+    float[] expected =
+        new float[] {
+          2, 4, 6, 8,
+          20, 24, 28, 32,
+          54, 60, 66, 72,
+          13, 14, 15, 16
+        };
     float[] output = new float[16];
     Matrix.scaleM(output, 0, matrix, 0, 2, 4, 6);
     assertThat(output).usingExactEquality().containsAtLeast(expected);
@@ -434,36 +442,40 @@ public class ShadowOpenGLMatrixTest {
 
   @Test
   public void testScaleMInPlace() {
-    float[] matrix = new float[]{
-            1, 2, 3, 4,
-            5, 6, 7, 8,
-            9, 10, 11, 12,
-            13, 14, 15, 16
-    };
-    float[] expected = new float[]{
-            2, 4, 6, 8,
-            20, 24, 28, 32,
-            54, 60, 66, 72,
-            13, 14, 15, 16
-    };
+    float[] matrix =
+        new float[] {
+          1, 2, 3, 4,
+          5, 6, 7, 8,
+          9, 10, 11, 12,
+          13, 14, 15, 16
+        };
+    float[] expected =
+        new float[] {
+          2, 4, 6, 8,
+          20, 24, 28, 32,
+          54, 60, 66, 72,
+          13, 14, 15, 16
+        };
     Matrix.scaleM(matrix, 0, 2, 4, 6);
     assertThat(matrix).usingExactEquality().containsAtLeast(expected);
   }
 
   @Test
   public void testTranslateM() {
-    float[] matrix = new float[]{
-            1, 2, 3, 4,
-            5, 6, 7, 8,
-            9, 10, 11, 12,
-            13, 14, 15, 16
-    };
-    float[] expected = new float[]{
-            1, 2, 3, 4,
-            5, 6, 7, 8,
-            9, 10, 11, 12,
-            89, 102, 115, 128
-    };
+    float[] matrix =
+        new float[] {
+          1, 2, 3, 4,
+          5, 6, 7, 8,
+          9, 10, 11, 12,
+          13, 14, 15, 16
+        };
+    float[] expected =
+        new float[] {
+          1, 2, 3, 4,
+          5, 6, 7, 8,
+          9, 10, 11, 12,
+          89, 102, 115, 128
+        };
     float[] output = new float[16];
     Matrix.translateM(output, 0, matrix, 0, 2, 4, 6);
     assertThat(output).usingExactEquality().containsAtLeast(expected);
@@ -471,36 +483,52 @@ public class ShadowOpenGLMatrixTest {
 
   @Test
   public void testTranslateMInPlace() {
-    float[] matrix = new float[]{
-            1, 2, 3, 4,
-            5, 6, 7, 8,
-            9, 10, 11, 12,
-            13, 14, 15, 16
-    };
-    float[] expected = new float[]{
-            1, 2, 3, 4,
-            5, 6, 7, 8,
-            9, 10, 11, 12,
-            89, 102, 115, 128
-    };
+    float[] matrix =
+        new float[] {
+          1, 2, 3, 4,
+          5, 6, 7, 8,
+          9, 10, 11, 12,
+          13, 14, 15, 16
+        };
+    float[] expected =
+        new float[] {
+          1, 2, 3, 4,
+          5, 6, 7, 8,
+          9, 10, 11, 12,
+          89, 102, 115, 128
+        };
     Matrix.translateM(matrix, 0, 2, 4, 6);
     assertThat(matrix).usingExactEquality().containsAtLeast(expected);
   }
 
   @Test
   public void testRotateM() {
-    float[] matrix = new float[]{
-            1, 2, 3, 4,
-            5, 6, 7, 8,
-            9, 10, 11, 12,
-            13, 14, 15, 16
-    };
-    float[] expected = new float[]{
-            0.95625275f, 1.9625025f, 2.968752f, 3.9750016f,
-            5.0910234f, 6.07802f, 7.0650167f, 8.052013f,
-            8.953606f, 9.960234f, 10.966862f, 11.973489f,
-            13, 14, 15, 16
-    };
+    float[] matrix =
+        new float[] {
+          1, 2, 3, 4,
+          5, 6, 7, 8,
+          9, 10, 11, 12,
+          13, 14, 15, 16
+        };
+    float[] expected =
+        new float[] {
+          0.95625275f,
+          1.9625025f,
+          2.968752f,
+          3.9750016f,
+          5.0910234f,
+          6.07802f,
+          7.0650167f,
+          8.052013f,
+          8.953606f,
+          9.960234f,
+          10.966862f,
+          11.973489f,
+          13,
+          14,
+          15,
+          16
+        };
     float[] output = new float[16];
     Matrix.rotateM(output, 0, matrix, 0, 2, 4, 6, 8);
     assertThat(output).usingExactEquality().containsAtLeast(expected);
@@ -508,36 +536,64 @@ public class ShadowOpenGLMatrixTest {
 
   @Test
   public void testRotateMInPlace() {
-    float[] matrix = new float[]{
-            1, 2, 3, 4,
-            5, 6, 7, 8,
-            9, 10, 11, 12,
-            13, 14, 15, 16
-    };
-    float[] expected = new float[]{
-            0.95625275f, 1.9625025f, 2.968752f, 3.9750016f,
-            5.0910234f, 6.07802f, 7.0650167f, 8.052013f,
-            8.953606f, 9.960234f, 10.966862f, 11.973489f,
-            13, 14, 15, 16
-    };
+    float[] matrix =
+        new float[] {
+          1, 2, 3, 4,
+          5, 6, 7, 8,
+          9, 10, 11, 12,
+          13, 14, 15, 16
+        };
+    float[] expected =
+        new float[] {
+          0.95625275f,
+          1.9625025f,
+          2.968752f,
+          3.9750016f,
+          5.0910234f,
+          6.07802f,
+          7.0650167f,
+          8.052013f,
+          8.953606f,
+          9.960234f,
+          10.966862f,
+          11.973489f,
+          13,
+          14,
+          15,
+          16
+        };
     Matrix.rotateM(matrix, 0, 2, 4, 6, 8);
     assertThat(matrix).usingExactEquality().containsAtLeast(expected);
   }
 
   @Test
   public void testSetRotateM() {
-    float[] matrix = new float[]{
-            1, 2, 3, 4,
-            5, 6, 7, 8,
-            9, 10, 11, 12,
-            13, 14, 15, 16
-    };
-    float[] expected = new float[]{
-            0.9998687f, 0.01299483f, -0.00968048f, 0,
-            -0.012931813f, 0.999895f, 0.006544677f, 0,
-            0.009764502f, -0.006418644f, 0.99993175f, 0,
-            0, 0, 0, 1
-    };
+    float[] matrix =
+        new float[] {
+          1, 2, 3, 4,
+          5, 6, 7, 8,
+          9, 10, 11, 12,
+          13, 14, 15, 16
+        };
+    float[] expected =
+        new float[] {
+          0.9998687f,
+          0.01299483f,
+          -0.00968048f,
+          0,
+          -0.012931813f,
+          0.999895f,
+          0.006544677f,
+          0,
+          0.009764502f,
+          -0.006418644f,
+          0.99993175f,
+          0,
+          0,
+          0,
+          0,
+          1
+        };
     Matrix.setRotateM(matrix, 0, 1, 2, 3, 4);
     assertThat(matrix).usingExactEquality().containsAtLeast(expected);
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowOutlineTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowOutlineTest.java
index 504c068b3..cf333f459 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowOutlineTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowOutlineTest.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-
 import android.graphics.Outline;
 import android.graphics.Path;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
@@ -10,9 +9,9 @@ import org.junit.runner.RunWith;
 @RunWith(AndroidJUnit4.class)
 public class ShadowOutlineTest {
 
-    @Test
-    public void setConvexPath_doesNothing() {
-        final Outline outline = new Outline();
-        outline.setConvexPath(new Path());
-    }
+  @Test
+  public void setConvexPath_doesNothing() {
+    final Outline outline = new Outline();
+    outline.setConvexPath(new Path());
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowOverlayManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowOverlayManagerTest.java
new file mode 100644
index 000000000..86928cab9
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowOverlayManagerTest.java
@@ -0,0 +1,207 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
+import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+
+import android.content.om.OverlayInfo;
+import android.content.om.OverlayManager;
+import android.os.UserHandle;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadow.api.Shadow;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(minSdk = UPSIDE_DOWN_CAKE)
+public final class ShadowOverlayManagerTest {
+
+  private static final OverlayInfo IMMUTABLE_ENABLED_OVERLAY =
+      new OverlayInfo(
+          /* packageName= */ "package.not.mutable",
+          /* targetPackageName= */ "target.package",
+          /* targetOverlayableName= */ "overlay.name",
+          /* category= */ "category",
+          /* baseCodePath= */ "code.path",
+          /* state= */ OverlayInfo.STATE_ENABLED,
+          /* userId= */ UserHandle.USER_SYSTEM,
+          /* priority= */ 0,
+          /* isMutable= */ false);
+  private static final OverlayInfo MUTABLE_ENABLED_OVERLAY =
+      new OverlayInfo(
+          /* packageName= */ "package.found.enabled",
+          /* targetPackageName= */ "target.package",
+          /* targetOverlayableName= */ "overlay.name",
+          /* category= */ "category",
+          /* baseCodePath= */ "code.path",
+          /* state= */ OverlayInfo.STATE_ENABLED,
+          /* userId= */ UserHandle.USER_SYSTEM,
+          /* priority= */ 0,
+          /* isMutable= */ true);
+  private static final OverlayInfo MUTABLE_DISABLED_OVERLAY =
+      new OverlayInfo(
+          /* packageName= */ "package.found.disabled",
+          /* targetPackageName= */ "target.package",
+          /* targetOverlayableName= */ "overlay.name",
+          /* category= */ "category",
+          /* baseCodePath= */ "code.path",
+          /* state= */ OverlayInfo.STATE_DISABLED,
+          /* userId= */ UserHandle.USER_SYSTEM,
+          /* priority= */ 0,
+          /* isMutable= */ true);
+
+  @Before
+  public void setUp() {
+    ShadowApplication shadowApplication = Shadow.extract(getApplicationContext());
+    shadowApplication.grantPermissions(android.Manifest.permission.CHANGE_OVERLAY_PACKAGES);
+  }
+
+  @Test
+  public void removeOverlayInfo_noExceptionIfDoesNotExist() {
+    OverlayManager overlayManager = getApplicationContext().getSystemService(OverlayManager.class);
+
+    // Test that no exceptions are thrown.
+    getShadowOverlayManager(overlayManager).removeOverlayInfo("package.does.not.exist");
+  }
+
+  @Test
+  public void getOverlayInfoNotFound_returnsNull() {
+    OverlayManager overlayManager = getApplicationContext().getSystemService(OverlayManager.class);
+
+    assertThat(overlayManager.getOverlayInfo("package.does.not.exist", UserHandle.SYSTEM)).isNull();
+  }
+
+  @Test
+  public void getOverlayInfoRemoved_returnsNull() {
+    OverlayManager overlayManager = getApplicationContext().getSystemService(OverlayManager.class);
+
+    ShadowOverlayManager shadowOverlayManager = getShadowOverlayManager(overlayManager);
+    shadowOverlayManager.addOverlayInfo(MUTABLE_ENABLED_OVERLAY);
+    shadowOverlayManager.removeOverlayInfo(MUTABLE_ENABLED_OVERLAY.packageName);
+
+    assertThat(
+            overlayManager.getOverlayInfo(MUTABLE_ENABLED_OVERLAY.packageName, UserHandle.SYSTEM))
+        .isNull();
+  }
+
+  @Test
+  public void getOverlayInfoFound_returnsOverlayInfo() {
+    OverlayManager overlayManager = getApplicationContext().getSystemService(OverlayManager.class);
+
+    getShadowOverlayManager(overlayManager).addOverlayInfo(MUTABLE_ENABLED_OVERLAY);
+
+    assertThat(
+            overlayManager.getOverlayInfo(MUTABLE_ENABLED_OVERLAY.packageName, UserHandle.SYSTEM))
+        .isEqualTo(MUTABLE_ENABLED_OVERLAY);
+  }
+
+  @Test
+  public void setEnabledNoPermissionsDoesNotExist_throwsException() {
+    ShadowApplication shadowApplication = Shadow.extract(getApplicationContext());
+    shadowApplication.denyPermissions(android.Manifest.permission.CHANGE_OVERLAY_PACKAGES);
+
+    OverlayManager overlayManager = getApplicationContext().getSystemService(OverlayManager.class);
+
+    assertThrows(
+        SecurityException.class,
+        () -> overlayManager.setEnabled("package.does.not.exist", false, UserHandle.SYSTEM));
+  }
+
+  @Test
+  public void setEnabledNotFound_throwsException() {
+    OverlayManager overlayManager = getApplicationContext().getSystemService(OverlayManager.class);
+
+    assertThrows(
+        IllegalStateException.class,
+        () -> overlayManager.setEnabled("package.does.not.exist", false, UserHandle.SYSTEM));
+  }
+
+  @Test
+  public void setEnabledImmutable_throwsException() {
+    OverlayManager overlayManager = getApplicationContext().getSystemService(OverlayManager.class);
+    getShadowOverlayManager(overlayManager).addOverlayInfo(IMMUTABLE_ENABLED_OVERLAY);
+
+    assertThrows(
+        IllegalStateException.class,
+        () ->
+            overlayManager.setEnabled(
+                IMMUTABLE_ENABLED_OVERLAY.packageName, false, UserHandle.SYSTEM));
+  }
+
+  @Test
+  public void setEnabledNoPermissionsExists_throwsException() {
+    ShadowApplication shadowApplication = Shadow.extract(getApplicationContext());
+    shadowApplication.denyPermissions(android.Manifest.permission.CHANGE_OVERLAY_PACKAGES);
+    OverlayManager overlayManager = getApplicationContext().getSystemService(OverlayManager.class);
+    getShadowOverlayManager(overlayManager).addOverlayInfo(MUTABLE_ENABLED_OVERLAY);
+
+    assertThrows(
+        SecurityException.class,
+        () ->
+            overlayManager.setEnabled(
+                MUTABLE_ENABLED_OVERLAY.packageName, false, UserHandle.SYSTEM));
+  }
+
+  @Test
+  public void setEnabled_enableEnabled_leavesEnabled() {
+    OverlayManager overlayManager = getApplicationContext().getSystemService(OverlayManager.class);
+    getShadowOverlayManager(overlayManager).addOverlayInfo(MUTABLE_ENABLED_OVERLAY);
+
+    overlayManager.setEnabled(MUTABLE_ENABLED_OVERLAY.packageName, true, UserHandle.SYSTEM);
+
+    assertThat(
+            overlayManager
+                .getOverlayInfo(MUTABLE_ENABLED_OVERLAY.packageName, UserHandle.SYSTEM)
+                .isEnabled())
+        .isTrue();
+  }
+
+  @Test
+  public void setEnabled_disableDisabled_leavesDisabled() {
+    OverlayManager overlayManager = getApplicationContext().getSystemService(OverlayManager.class);
+    getShadowOverlayManager(overlayManager).addOverlayInfo(MUTABLE_DISABLED_OVERLAY);
+
+    overlayManager.setEnabled(MUTABLE_DISABLED_OVERLAY.packageName, false, UserHandle.SYSTEM);
+
+    assertThat(
+            overlayManager
+                .getOverlayInfo(MUTABLE_DISABLED_OVERLAY.packageName, UserHandle.SYSTEM)
+                .isEnabled())
+        .isFalse();
+  }
+
+  @Test
+  public void setEnabled_enableDisabled_enables() {
+    OverlayManager overlayManager = getApplicationContext().getSystemService(OverlayManager.class);
+    getShadowOverlayManager(overlayManager).addOverlayInfo(MUTABLE_DISABLED_OVERLAY);
+
+    overlayManager.setEnabled(MUTABLE_DISABLED_OVERLAY.packageName, true, UserHandle.SYSTEM);
+
+    assertThat(
+            overlayManager
+                .getOverlayInfo(MUTABLE_DISABLED_OVERLAY.packageName, UserHandle.SYSTEM)
+                .isEnabled())
+        .isTrue();
+  }
+
+  @Test
+  public void setEnabled_disableEnabled_disables() {
+    OverlayManager overlayManager = getApplicationContext().getSystemService(OverlayManager.class);
+    getShadowOverlayManager(overlayManager).addOverlayInfo(MUTABLE_ENABLED_OVERLAY);
+
+    overlayManager.setEnabled(MUTABLE_ENABLED_OVERLAY.packageName, false, UserHandle.SYSTEM);
+
+    assertThat(
+            overlayManager
+                .getOverlayInfo(MUTABLE_ENABLED_OVERLAY.packageName, UserHandle.SYSTEM)
+                .isEnabled())
+        .isFalse();
+  }
+
+  private ShadowOverlayManager getShadowOverlayManager(OverlayManager overlayManager) {
+    return Shadow.extract(overlayManager);
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageInstallerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageInstallerTest.java
index 957241133..5c21f36f7 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageInstallerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageInstallerTest.java
@@ -1,6 +1,7 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.O;
+import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static com.google.common.collect.Iterables.getOnlyElement;
@@ -18,6 +19,7 @@ import android.content.Intent;
 import android.content.IntentSender;
 import android.content.pm.PackageInstaller;
 import android.content.pm.PackageInstaller.PreapprovalDetails;
+import android.content.pm.PackageInstaller.SessionParams;
 import android.content.pm.PackageManager;
 import android.content.pm.VersionedPackage;
 import android.graphics.Bitmap;
@@ -57,6 +59,17 @@ public class ShadowPackageInstallerTest {
     assertThat(sessionId).isNotEqualTo(0);
   }
 
+  @Config(sdk = P)
+  @Test
+  public void packageInstallerCreateSession_sessionInfoHasCorrectInstallerName() throws Exception {
+    SessionParams params = createSessionParams("packageName");
+    params.setInstallerPackageName("installerPackageName");
+    int sessionId = packageInstaller.createSession(params);
+
+    assertThat(packageInstaller.getSessionInfo(sessionId).installerPackageName)
+        .isEqualTo("installerPackageName");
+  }
+
   @Test
   public void packageInstallerCreateAndGetSession() throws Exception {
     // Act.
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageManagerTest.java
index 7f2762b02..0ffa3c05a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageManagerTest.java
@@ -1,8 +1,10 @@
 package org.robolectric.shadows;
 
+import static android.Manifest.permission.READ_CALENDAR;
 import static android.Manifest.permission.READ_CONTACTS;
 import static android.Manifest.permission.READ_SMS;
 import static android.Manifest.permission.SUSPEND_APPS;
+import static android.Manifest.permission.WRITE_CALENDAR;
 import static android.content.pm.ApplicationInfo.FLAG_ALLOW_BACKUP;
 import static android.content.pm.ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
 import static android.content.pm.ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
@@ -41,9 +43,9 @@ import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static com.google.common.collect.ImmutableList.toImmutableList;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
-import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.fail;
@@ -112,17 +114,12 @@ import androidx.test.core.app.ApplicationProvider;
 import androidx.test.core.content.pm.ApplicationInfoBuilder;
 import androidx.test.core.content.pm.PackageInfoBuilder;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
-import com.google.common.base.Function;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Iterables;
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Executors;
-import javax.annotation.Nullable;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
@@ -159,6 +156,10 @@ public class ShadowPackageManagerTest {
   private static final String TEST_PACKAGE3_NAME = "com.a.third.package";
   private static final int TEST_PACKAGE_VERSION_CODE = 10000;
   public static final int INSTALL_VERIFICATION_ID = 1234;
+  public static final String INITIATING_PACKAGE_NAME = "initiating.package";
+  public static final String INSTALLING_PACKAGE_NAME = "installing.package";
+  public static final String ORIGINATING_PACKAGE_NAME = "originating.package";
+  public static final String UPDATE_OWNER_PACKAGE_NAME = "update.owner.package";
 
   @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();
   private Context context;
@@ -776,124 +777,358 @@ public class ShadowPackageManagerTest {
   }
 
   @Test
-  public void getPermissionInfo_withMinimalFields() throws Exception {
+  public void getPermissionInfo_fromPlatform() throws Exception {
+    PermissionInfo permission = packageManager.getPermissionInfo(READ_CONTACTS, 0);
+
+    assertThat(permission.labelRes).isEqualTo(0);
+    assertThat(permission.descriptionRes).isEqualTo(0);
+    assertThat(permission.protectionLevel).isEqualTo(PermissionInfo.PROTECTION_DANGEROUS);
+    assertThat(permission.group).isEqualTo(permission_group.CONTACTS);
+  }
+
+  @Test
+  public void getPermissionInfo_fromManifest() throws Exception {
     PermissionInfo permission =
         packageManager.getPermissionInfo("org.robolectric.permission_with_minimal_fields", 0);
+
     assertThat(permission.labelRes).isEqualTo(0);
     assertThat(permission.descriptionRes).isEqualTo(0);
     assertThat(permission.protectionLevel).isEqualTo(PermissionInfo.PROTECTION_NORMAL);
   }
 
   @Test
-  public void getPermissionInfo_addedPermissions() throws Exception {
+  public void getPermissionInfo_addedPermission() throws Exception {
     PermissionInfo permissionInfo = new PermissionInfo();
     permissionInfo.name = "manually_added_permission";
     shadowOf(packageManager).addPermissionInfo(permissionInfo);
+
     PermissionInfo permission = packageManager.getPermissionInfo("manually_added_permission", 0);
+
     assertThat(permission.name).isEqualTo("manually_added_permission");
   }
 
+  @Test
+  public void getPermissionInfo_overriddenPlatformPermission() throws Exception {
+    PermissionInfo permissionInfo = new PermissionInfo();
+    permissionInfo.name = READ_CONTACTS;
+    permissionInfo.group = "my_other_permission_group";
+    shadowOf(packageManager).addPermissionInfo(permissionInfo);
+
+    PermissionInfo permission = packageManager.getPermissionInfo(READ_CONTACTS, 0);
+
+    assertThat(permission.labelRes).isEqualTo(0);
+    assertThat(permission.descriptionRes).isEqualTo(0);
+    assertThat(permission.protectionLevel).isEqualTo(PermissionInfo.PROTECTION_NORMAL);
+    assertThat(permission.group).isEqualTo("my_other_permission_group");
+  }
+
+  @Test
+  public void getPermissionGroupInfo_fromPlatform() throws Exception {
+    PermissionGroupInfo permissionGroupInfo =
+        packageManager.getPermissionGroupInfo(permission_group.CALENDAR, 0);
+
+    assertThat(permissionGroupInfo.name).isEqualTo(permission_group.CALENDAR);
+    assertThat(permissionGroupInfo.priority).isEqualTo(200);
+  }
+
   @Test
   public void getPermissionGroupInfo_fromManifest() throws Exception {
     PermissionGroupInfo permissionGroupInfo =
-        context
-            .getPackageManager()
-            .getPermissionGroupInfo("org.robolectric.package_permission_group", 0);
+        packageManager.getPermissionGroupInfo("org.robolectric.package_permission_group", 0);
+
     assertThat(permissionGroupInfo.name).isEqualTo("org.robolectric.package_permission_group");
+    assertThat(permissionGroupInfo.priority).isEqualTo(0);
   }
 
   @Test
   public void getPermissionGroupInfo_extraPermissionGroup() throws Exception {
-    PermissionGroupInfo newCameraPermission = new PermissionGroupInfo();
-    newCameraPermission.name = permission_group.CAMERA;
-    shadowOf(packageManager).addPermissionGroupInfo(newCameraPermission);
+    PermissionGroupInfo extraPermissionGroupInfo = new PermissionGroupInfo();
+    extraPermissionGroupInfo.name = "my_other_permission_group";
+    extraPermissionGroupInfo.priority = 42;
+    shadowOf(packageManager).addPermissionGroupInfo(extraPermissionGroupInfo);
+
+    PermissionGroupInfo permissionGroupInfo =
+        packageManager.getPermissionGroupInfo("my_other_permission_group", 0);
 
-    assertThat(packageManager.getPermissionGroupInfo(permission_group.CAMERA, 0).name)
-        .isEqualTo(newCameraPermission.name);
+    assertThat(permissionGroupInfo.name).isEqualTo("my_other_permission_group");
+    assertThat(permissionGroupInfo.priority).isEqualTo(42);
+  }
+
+  @Test
+  public void getPermissionGroupInfo_overriddenPlatformPermissionGroup() throws Exception {
+    PermissionGroupInfo extraPermissionGroupInfo = new PermissionGroupInfo();
+    extraPermissionGroupInfo.name = permission_group.CALENDAR;
+    extraPermissionGroupInfo.priority = 42;
+    shadowOf(packageManager).addPermissionGroupInfo(extraPermissionGroupInfo);
+
+    PermissionGroupInfo permissionGroupInfo =
+        packageManager.getPermissionGroupInfo(permission_group.CALENDAR, 0);
+
+    assertThat(permissionGroupInfo.name).isEqualTo(permission_group.CALENDAR);
+    assertThat(permissionGroupInfo.priority).isEqualTo(42);
   }
 
   @Test
   @Config(minSdk = S)
   public void getGroupOfPlatformPermission_fromManifest() throws Exception {
-    String permissionName = "org.robolectric.some_permission";
-    CountDownLatch waitForCallback = new CountDownLatch(1);
-    ShadowApplicationPackageManager pm = (ShadowApplicationPackageManager) shadowOf(packageManager);
     String[] permissionGroupArg = new String[1];
-    pm.getGroupOfPlatformPermission(
+
+    packageManager.getGroupOfPlatformPermission(
+        "org.robolectric.some_permission",
+        context.getMainExecutor(),
+        (group) -> {
+          permissionGroupArg[0] = group;
+        });
+    shadowMainLooper().idle();
+
+    assertThat(permissionGroupArg[0]).isNull();
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void getGroupOfPlatformPermission_fromExtraPermissions() throws Exception {
+    String permissionName = "some_other_permission";
+    String permissionGroupName = "some_other_permission_group";
+    PermissionInfo permissionInfo = new PermissionInfo();
+    permissionInfo.name = permissionName;
+    permissionInfo.group = permissionGroupName;
+    shadowOf(packageManager).addPermissionInfo(permissionInfo);
+    String[] permissionGroupArg = new String[1];
+
+    packageManager.getGroupOfPlatformPermission(
         permissionName,
-        Executors.newSingleThreadExecutor(),
+        context.getMainExecutor(),
         (group) -> {
           permissionGroupArg[0] = group;
-          waitForCallback.countDown();
         });
-    assertThat(waitForCallback.await(2, SECONDS)).isTrue();
-    assertThat(permissionGroupArg[0]).isEqualTo("my_permission_group");
+    shadowMainLooper().idle();
+
+    assertThat(permissionGroupArg[0]).isNull();
   }
 
   @Test
   @Config(minSdk = S)
-  public void getGroupOfPlatformPermission_unknown() throws Exception {
-    String permissionName = "unknown_permission";
-    CountDownLatch waitForCallback = new CountDownLatch(1);
-    ShadowApplicationPackageManager pm = (ShadowApplicationPackageManager) shadowOf(packageManager);
+  public void getGroupOfPlatformPermission_fromExtraPermissionsPlatformPrefix() throws Exception {
+    String permissionName = "android.permission.some_other_permission";
+    String permissionGroupName = "some_other_permission_group";
+    PermissionInfo permissionInfo = new PermissionInfo();
+    permissionInfo.name = permissionName;
+    permissionInfo.group = permissionGroupName;
+    shadowOf(packageManager).addPermissionInfo(permissionInfo);
     String[] permissionGroupArg = new String[1];
-    pm.getGroupOfPlatformPermission(
+
+    packageManager.getGroupOfPlatformPermission(
         permissionName,
-        Executors.newSingleThreadExecutor(),
+        context.getMainExecutor(),
         (group) -> {
           permissionGroupArg[0] = group;
-          waitForCallback.countDown();
         });
-    assertThat(waitForCallback.await(2, SECONDS)).isTrue();
+    shadowMainLooper().idle();
+
+    assertThat(permissionGroupArg[0]).isEqualTo(permissionGroupName);
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void getGroupOfPlatformPermission_unknown() throws Exception {
+    String[] permissionGroupArg = new String[1];
+
+    packageManager.getGroupOfPlatformPermission(
+        "unknown_permission",
+        context.getMainExecutor(),
+        (group) -> {
+          permissionGroupArg[0] = group;
+        });
+    shadowMainLooper().idle();
+
     assertThat(permissionGroupArg[0]).isNull();
   }
 
   @Test
-  public void getAllPermissionGroups_fromManifest() {
+  @Config(minSdk = S)
+  public void getGroupOfPlatformPermission_fromPlatform() throws Exception {
+    String[] permissionGroupArg = new String[1];
+
+    packageManager.getGroupOfPlatformPermission(
+        READ_CONTACTS,
+        context.getMainExecutor(),
+        (group) -> {
+          permissionGroupArg[0] = group;
+        });
+    shadowMainLooper().idle();
+
+    assertThat(permissionGroupArg[0]).isEqualTo(permission_group.CONTACTS);
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void getGroupOfPlatformPermission_overriddenPlatformPermission() throws Exception {
+    PermissionInfo permissionInfo = new PermissionInfo();
+    permissionInfo.name = READ_CONTACTS;
+    permissionInfo.group = permission_group.CALENDAR;
+    shadowOf(packageManager).addPermissionInfo(permissionInfo);
+    String[] permissionGroupArg = new String[1];
+
+    packageManager.getGroupOfPlatformPermission(
+        READ_CONTACTS,
+        context.getMainExecutor(),
+        (group) -> {
+          permissionGroupArg[0] = group;
+        });
+    shadowMainLooper().idle();
+
+    assertThat(permissionGroupArg[0]).isEqualTo(permission_group.CALENDAR);
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void getPlatformPermissionsForGroup_fromManifest() throws Exception {
+    List<List<String>> permissionsArg = new ArrayList<>();
+
+    packageManager.getPlatformPermissionsForGroup(
+        "my_permission_group",
+        context.getMainExecutor(),
+        (permissions) -> {
+          permissionsArg.add(permissions);
+        });
+    shadowMainLooper().idle();
+
+    assertThat(permissionsArg).hasSize(1);
+    assertThat(permissionsArg.get(0)).isEmpty();
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void getPlatformPermissionsForGroup_fromExtraPermissions() throws Exception {
+    String permissionName1 = "some_other_permission";
+    String permissionName2 = "android.permission.my_calendar_permission";
+    String permissionGroupName = permission_group.CALENDAR;
+    PermissionInfo permissionInfo1 = new PermissionInfo();
+    permissionInfo1.name = permissionName1;
+    permissionInfo1.group = permissionGroupName;
+    shadowOf(packageManager).addPermissionInfo(permissionInfo1);
+    PermissionInfo permissionInfo2 = new PermissionInfo();
+    permissionInfo2.name = permissionName2;
+    permissionInfo2.group = permissionGroupName;
+    shadowOf(packageManager).addPermissionInfo(permissionInfo2);
+    List<List<String>> permissionsArg = new ArrayList<>();
+
+    packageManager.getPlatformPermissionsForGroup(
+        permissionGroupName,
+        context.getMainExecutor(),
+        (permissions) -> {
+          permissionsArg.add(permissions);
+        });
+    shadowMainLooper().idle();
+
+    assertThat(permissionsArg).hasSize(1);
+    assertThat(permissionsArg.get(0)).doesNotContain(permissionName1);
+    assertThat(permissionsArg.get(0)).contains(permissionName2);
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void getPlatformPermissionsForGroup_unknown() throws Exception {
+    List<List<String>> permissionsArg = new ArrayList<>();
+
+    packageManager.getPlatformPermissionsForGroup(
+        "unknown_permission_group",
+        context.getMainExecutor(),
+        (permissions) -> {
+          permissionsArg.add(permissions);
+        });
+    shadowMainLooper().idle();
+
+    assertThat(permissionsArg).hasSize(1);
+    assertThat(permissionsArg.get(0)).isEmpty();
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void getPlatformPermissionsForGroup_fromPlatform() throws Exception {
+    List<List<String>> permissionsArg = new ArrayList<>();
+
+    packageManager.getPlatformPermissionsForGroup(
+        permission_group.CALENDAR,
+        context.getMainExecutor(),
+        (permissions) -> {
+          permissionsArg.add(permissions);
+        });
+    shadowMainLooper().idle();
+
+    assertThat(permissionsArg).hasSize(1);
+    assertThat(permissionsArg.get(0)).containsExactly(READ_CALENDAR, WRITE_CALENDAR);
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void getPlatformPermissionsForGroup_overriddenPlatformPermission() throws Exception {
+    PermissionInfo permissionInfo = new PermissionInfo();
+    permissionInfo.name = READ_CONTACTS;
+    permissionInfo.group = permission_group.CALENDAR;
+    shadowOf(packageManager).addPermissionInfo(permissionInfo);
+    List<List<String>> permissionsArg = new ArrayList<>();
+
+    packageManager.getPlatformPermissionsForGroup(
+        permission_group.CALENDAR,
+        context.getMainExecutor(),
+        (permissions) -> {
+          permissionsArg.add(permissions);
+        });
+    shadowMainLooper().idle();
+
+    assertThat(permissionsArg).hasSize(1);
+    assertThat(permissionsArg.get(0)).containsExactly(READ_CALENDAR, READ_CONTACTS, WRITE_CALENDAR);
+  }
+
+  @Test
+  public void getAllPermissionGroups_fromPlatformAndManifest() {
     List<PermissionGroupInfo> allPermissionGroups = packageManager.getAllPermissionGroups(0);
-    assertThat(allPermissionGroups).hasSize(1);
-    assertThat(allPermissionGroups.get(0).name)
-        .isEqualTo("org.robolectric.package_permission_group");
+
+    assertThat(allPermissionGroups.stream().map(info -> info.name).collect(toImmutableList()))
+        .containsExactly(
+            permission_group.CALENDAR,
+            permission_group.CONTACTS,
+            "org.robolectric.package_permission_group");
   }
 
   @Test
   public void getAllPermissionGroups_duplicateInExtraPermissions() {
-    assertThat(packageManager.getAllPermissionGroups(0)).hasSize(1);
-
     PermissionGroupInfo overriddenPermission = new PermissionGroupInfo();
     overriddenPermission.name = "org.robolectric.package_permission_group";
     shadowOf(packageManager).addPermissionGroupInfo(overriddenPermission);
     PermissionGroupInfo newCameraPermission = new PermissionGroupInfo();
-    newCameraPermission.name = permission_group.CAMERA;
+    newCameraPermission.name = "org.robolectric.package_permission_other_group";
     shadowOf(packageManager).addPermissionGroupInfo(newCameraPermission);
 
     List<PermissionGroupInfo> allPermissionGroups = packageManager.getAllPermissionGroups(0);
-    assertThat(allPermissionGroups).hasSize(2);
+
+    assertThat(allPermissionGroups.stream().map(info -> info.name).collect(toImmutableList()))
+        .containsExactly(
+            permission_group.CALENDAR,
+            permission_group.CONTACTS,
+            "org.robolectric.package_permission_group",
+            "org.robolectric.package_permission_other_group");
   }
 
   @Test
   public void getAllPermissionGroups_duplicatePermission() {
-    assertThat(packageManager.getAllPermissionGroups(0)).hasSize(1);
-
     // Package 1
-    Package pkg = new Package(TEST_PACKAGE_NAME);
-    ApplicationInfo appInfo = pkg.applicationInfo;
-    appInfo.flags = ApplicationInfo.FLAG_INSTALLED;
-    appInfo.packageName = TEST_PACKAGE_NAME;
-    appInfo.sourceDir = TEST_APP_PATH;
-    appInfo.name = TEST_PACKAGE_LABEL;
-    PermissionGroupInfo contactsPermissionGroupInfoApp1 = new PermissionGroupInfo();
-    contactsPermissionGroupInfoApp1.name = Manifest.permission_group.CONTACTS;
-    PermissionGroup contactsPermissionGroupApp1 =
-        new PermissionGroup(pkg, contactsPermissionGroupInfoApp1);
-    pkg.permissionGroups.add(contactsPermissionGroupApp1);
-    PermissionGroupInfo storagePermissionGroupInfoApp1 = new PermissionGroupInfo();
-    storagePermissionGroupInfoApp1.name = permission_group.STORAGE;
-    PermissionGroup storagePermissionGroupApp1 =
-        new PermissionGroup(pkg, storagePermissionGroupInfoApp1);
-    pkg.permissionGroups.add(storagePermissionGroupApp1);
-
-    shadowOf(packageManager).addPackageInternal(pkg);
+    Package pkg1 = new Package(TEST_PACKAGE_NAME);
+    ApplicationInfo appInfo1 = pkg1.applicationInfo;
+    appInfo1.flags = ApplicationInfo.FLAG_INSTALLED;
+    appInfo1.packageName = TEST_PACKAGE_NAME;
+    appInfo1.sourceDir = TEST_APP_PATH;
+    appInfo1.name = TEST_PACKAGE_LABEL;
+    PermissionGroupInfo pgiApp1Group1 = new PermissionGroupInfo();
+    pgiApp1Group1.name = "org.robolectric.package_permission_other_group1";
+    PermissionGroup pgApp1Group1 = new PermissionGroup(pkg1, pgiApp1Group1);
+    pkg1.permissionGroups.add(pgApp1Group1);
+    PermissionGroupInfo pgiApp1Group2 = new PermissionGroupInfo();
+    pgiApp1Group2.name = "org.robolectric.package_permission_other_group2";
+    PermissionGroup pgApp1Group2 = new PermissionGroup(pkg1, pgiApp1Group2);
+    pkg1.permissionGroups.add(pgApp1Group2);
+    shadowOf(packageManager).addPackageInternal(pkg1);
 
     // Package 2, contains one permission group that is the same
     Package pkg2 = new Package(TEST_PACKAGE2_NAME);
@@ -902,23 +1137,27 @@ public class ShadowPackageManagerTest {
     appInfo2.packageName = TEST_PACKAGE2_NAME;
     appInfo2.sourceDir = TEST_APP2_PATH;
     appInfo2.name = TEST_PACKAGE2_LABEL;
-    PermissionGroupInfo contactsPermissionGroupInfoApp2 = new PermissionGroupInfo();
-    contactsPermissionGroupInfoApp2.name = Manifest.permission_group.CONTACTS;
-    PermissionGroup contactsPermissionGroupApp2 =
-        new PermissionGroup(pkg2, contactsPermissionGroupInfoApp2);
-    pkg2.permissionGroups.add(contactsPermissionGroupApp2);
-    PermissionGroupInfo calendarPermissionGroupInfoApp2 = new PermissionGroupInfo();
-    calendarPermissionGroupInfoApp2.name = permission_group.CALENDAR;
-    PermissionGroup calendarPermissionGroupApp2 =
-        new PermissionGroup(pkg2, calendarPermissionGroupInfoApp2);
-    pkg2.permissionGroups.add(calendarPermissionGroupApp2);
-
+    PermissionGroupInfo pgiApp2Group1 = new PermissionGroupInfo();
+    pgiApp2Group1.name = "org.robolectric.package_permission_other_group1";
+    PermissionGroup pgApp2Group1 = new PermissionGroup(pkg2, pgiApp2Group1);
+    pkg2.permissionGroups.add(pgApp2Group1);
+    PermissionGroupInfo pgiApp2Group2 = new PermissionGroupInfo();
+    pgiApp2Group2.name = "org.robolectric.package_permission_other_group3";
+    PermissionGroup pgApp2Group2 = new PermissionGroup(pkg2, pgiApp2Group2);
+    pkg2.permissionGroups.add(pgApp2Group2);
     shadowOf(packageManager).addPackageInternal(pkg2);
 
-    // Make sure that the duplicate permission group does not show up in the list
-    // Total list should be: contacts, storage, calendar, "org.robolectric.package_permission_group"
     List<PermissionGroupInfo> allPermissionGroups = packageManager.getAllPermissionGroups(0);
-    assertThat(allPermissionGroups).hasSize(4);
+
+    // Make sure that the duplicate permission group does not show up in the list
+    assertThat(allPermissionGroups.stream().map(info -> info.name).collect(toImmutableList()))
+        .containsExactly(
+            permission_group.CALENDAR,
+            permission_group.CONTACTS,
+            "org.robolectric.package_permission_group",
+            "org.robolectric.package_permission_other_group1",
+            "org.robolectric.package_permission_other_group2",
+            "org.robolectric.package_permission_other_group3");
   }
 
   @Test
@@ -2981,19 +3220,6 @@ public class ShadowPackageManagerTest {
     assertThat(packageStatsCaptor.getValue().packageName).isEqualTo("org.robolectric");
   }
 
-  @Test
-  public void addCurrentToCannonicalName() {
-    shadowOf(packageManager).addCurrentToCannonicalName("current_name_1", "canonical_name_1");
-    shadowOf(packageManager).addCurrentToCannonicalName("current_name_2", "canonical_name_2");
-
-    assertThat(
-            packageManager.currentToCanonicalPackageNames(
-                new String[] {"current_name_1", "current_name_2", "some_other_name"}))
-        .asList()
-        .containsExactly("canonical_name_1", "canonical_name_2", "some_other_name")
-        .inOrder();
-  }
-
   @Test
   public void addCanonicalName() {
     shadowOf(packageManager).addCanonicalName("current_name_1", "canonical_name_1");
@@ -3225,7 +3451,7 @@ public class ShadowPackageManagerTest {
       throws Exception {
     List<PermissionInfo> permissions = packageManager.queryPermissionsByGroup(null, 0);
 
-    assertThat(Iterables.transform(permissions, getPermissionNames()))
+    assertThat(permissions.stream().map(info -> info.name).collect(toImmutableList()))
         .containsExactly(
             "org.robolectric.permission_with_minimal_fields",
             "org.robolectric.permission_with_literal_label");
@@ -3242,7 +3468,11 @@ public class ShadowPackageManagerTest {
     List<PermissionInfo> permissions = packageManager.queryPermissionsByGroup(null, 0);
     assertThat(permissions).isNotEmpty();
 
-    assertThat(permissions.get(0).name).isEqualTo(permissionInfo.name);
+    assertThat(permissions.stream().map(info -> info.name).collect(toImmutableList()))
+        .containsExactly(
+            permissionInfo.name,
+            "org.robolectric.permission_with_minimal_fields",
+            "org.robolectric.permission_with_literal_label");
   }
 
   @Test
@@ -3327,13 +3557,35 @@ public class ShadowPackageManagerTest {
 
   @Test
   @Config(minSdk = VERSION_CODES.R)
+  public void installerSourceInfo_setPackageNames() throws Exception {
+    shadowOf(packageManager)
+        .setInstallSourceInfo("target.package", INITIATING_PACKAGE_NAME, INSTALLING_PACKAGE_NAME);
+
+    InstallSourceInfo info = packageManager.getInstallSourceInfo("target.package");
+    assertThat(info.getInitiatingPackageName()).isEqualTo(INITIATING_PACKAGE_NAME);
+    assertThat(info.getInstallingPackageName()).isEqualTo(INSTALLING_PACKAGE_NAME);
+  }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.UPSIDE_DOWN_CAKE)
   public void installerSourceInfo() throws Exception {
     shadowOf(packageManager)
-        .setInstallSourceInfo("target.package", "initiating.package", "installing.package");
+        .setInstallSourceInfo(
+            "target.package",
+            INITIATING_PACKAGE_NAME,
+            new SigningInfo(),
+            ORIGINATING_PACKAGE_NAME,
+            INSTALLING_PACKAGE_NAME,
+            UPDATE_OWNER_PACKAGE_NAME,
+            PackageInstaller.PACKAGE_SOURCE_STORE);
 
     InstallSourceInfo info = packageManager.getInstallSourceInfo("target.package");
-    assertThat(info.getInitiatingPackageName()).isEqualTo("initiating.package");
-    assertThat(info.getInstallingPackageName()).isEqualTo("installing.package");
+    assertThat(info.getInitiatingPackageName()).isEqualTo(INITIATING_PACKAGE_NAME);
+    assertThat(info.getInstallingPackageName()).isEqualTo(INSTALLING_PACKAGE_NAME);
+    assertThat(info.getOriginatingPackageName()).isEqualTo(ORIGINATING_PACKAGE_NAME);
+    assertThat(info.getUpdateOwnerPackageName()).isEqualTo(UPDATE_OWNER_PACKAGE_NAME);
+    assertThat(info.getInitiatingPackageSigningInfo()).isNotNull();
+    assertThat(info.getPackageSource()).isEqualTo(PackageInstaller.PACKAGE_SOURCE_STORE);
   }
 
   @Test
@@ -3384,6 +3636,22 @@ public class ShadowPackageManagerTest {
     assertThat(activity.name).isNotEmpty();
   }
 
+  @Test
+  public void installPackage_platformPermission_throws() {
+    PackageInfo info = new PackageInfo();
+    info.packageName = "name";
+    info.activities = new ActivityInfo[] {new ActivityInfo()};
+    PermissionInfo permissionInfo = new PermissionInfo();
+    permissionInfo.name = READ_CONTACTS;
+    info.permissions = new PermissionInfo[] {permissionInfo};
+
+    try {
+      shadowOf(packageManager).installPackage(info);
+      fail("Exception expected");
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   @Test
   public void addPackageMultipleTimesShouldWork() {
     shadowOf(packageManager).addPackage("test.package");
@@ -3696,16 +3964,6 @@ public class ShadowPackageManagerTest {
     assertThat(dataDir.exists()).isTrue();
   }
 
-  private static Function<PermissionInfo, String> getPermissionNames() {
-    return new Function<PermissionInfo, String>() {
-      @Nullable
-      @Override
-      public String apply(@Nullable PermissionInfo permissionInfo) {
-        return permissionInfo.name;
-      }
-    };
-  }
-
   @Test
   public void getApplicationHiddenSettingAsUser_hidden() {
     String packageName = context.getPackageName();
@@ -4765,6 +5023,26 @@ public class ShadowPackageManagerTest {
     assertThat(defaultBrowserPackageNameUserNotAvailable).isNull();
   }
 
+  @Test
+  public void addPackageInternal_platformPermissionGroup_throws() {
+    Package pkg = new Package(TEST_PACKAGE_NAME);
+    ApplicationInfo appInfo = pkg.applicationInfo;
+    appInfo.flags = ApplicationInfo.FLAG_INSTALLED;
+    appInfo.packageName = TEST_PACKAGE_NAME;
+    appInfo.sourceDir = TEST_APP_PATH;
+    appInfo.name = TEST_PACKAGE_LABEL;
+    PermissionGroupInfo pgi = new PermissionGroupInfo();
+    pgi.name = permission_group.CALENDAR;
+    PermissionGroup pg = new PermissionGroup(pkg, pgi);
+    pkg.permissionGroups.add(pg);
+
+    try {
+      shadowOf(packageManager).addPackageInternal(pkg);
+      fail("Exception expected");
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   public String[] setPackagesSuspended(
       String[] packageNames,
       boolean suspended,
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPaintTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPaintTest.java
index 77710bc3f..d7577f001 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPaintTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPaintTest.java
@@ -117,26 +117,26 @@ public class ShadowPaintTest {
     assertThat(
             paint.breakText(
                 new char[] {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd'},
-                /*index=*/ 0,
-                /*count=*/ 11,
-                /*maxWidth=*/ 100,
-                /*measuredWidth=*/ null))
+                /* index= */ 0,
+                /* count= */ 11,
+                /* maxWidth= */ 100,
+                /* measuredWidth= */ null))
         .isGreaterThan(0);
     assertThat(
             paint.breakText(
                 "Hello World",
-                /*start=*/ 0,
-                /*end=*/ 11,
-                /*measureForwards=*/ true,
-                /*maxWidth=*/ 100,
-                /*measuredWidth=*/ null))
+                /* start= */ 0,
+                /* end= */ 11,
+                /* measureForwards= */ true,
+                /* maxWidth= */ 100,
+                /* measuredWidth= */ null))
         .isGreaterThan(0);
     assertThat(
             paint.breakText(
                 "Hello World",
-                /*measureForwards=*/ true,
-                /*maxWidth=*/ 100,
-                /*measuredWidth=*/ null))
+                /* measureForwards= */ true,
+                /* maxWidth= */ 100,
+                /* measuredWidth= */ null))
         .isGreaterThan(0);
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowParcelFileDescriptorTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowParcelFileDescriptorTest.java
index c14709fde..3d852a08a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowParcelFileDescriptorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowParcelFileDescriptorTest.java
@@ -323,8 +323,7 @@ public class ShadowParcelFileDescriptorTest {
 
   @Test
   public void testGetFd_canRead() throws IOException {
-    assumeThat("Windows is an affront to decency.",
-        File.separator, Matchers.equalTo("/"));
+    assumeThat("Windows is an affront to decency.", File.separator, Matchers.equalTo("/"));
 
     pfd = ParcelFileDescriptor.open(readOnlyFile, ParcelFileDescriptor.MODE_READ_ONLY);
     int fd = pfd.getFd();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowParcelTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowParcelTest.java
index b08224690..1cd088544 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowParcelTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowParcelTest.java
@@ -396,7 +396,7 @@ public class ShadowParcelTest {
 
   @Test
   public void testReadWriteIntArray() throws Exception {
-    final int[] ints = { 1, 2 };
+    final int[] ints = {1, 2};
     parcel.writeIntArray(ints);
     // Make sure a copy was stored.
     ints[0] = 99;
@@ -416,7 +416,7 @@ public class ShadowParcelTest {
 
   @Test
   public void testReadWriteLongArray() throws Exception {
-    final long[] longs = { 1, 2 };
+    final long[] longs = {1, 2};
     parcel.writeLongArray(longs);
     parcel.setDataPosition(0);
     final long[] longs2 = new long[longs.length];
@@ -441,7 +441,7 @@ public class ShadowParcelTest {
 
   @Test
   public void testReadWriteFloatArray() throws Exception {
-    final float[] floats = { 1.1f, 2.0f };
+    final float[] floats = {1.1f, 2.0f};
     parcel.writeFloatArray(floats);
     parcel.setDataPosition(0);
     final float[] floats2 = new float[floats.length];
@@ -458,7 +458,7 @@ public class ShadowParcelTest {
 
   @Test
   public void testReadWriteDoubleArray() throws Exception {
-    final double[] doubles = { 1.1f, 2.0f };
+    final double[] doubles = {1.1f, 2.0f};
     parcel.writeDoubleArray(doubles);
     parcel.setDataPosition(0);
     final double[] doubles2 = new double[doubles.length];
@@ -475,7 +475,7 @@ public class ShadowParcelTest {
 
   @Test
   public void testReadWriteStringArray() throws Exception {
-    final String[] strings = { "foo", "bar" };
+    final String[] strings = {"foo", "bar"};
     parcel.writeStringArray(strings);
     parcel.setDataPosition(0);
     final String[] strings2 = new String[strings.length];
@@ -633,7 +633,7 @@ public class ShadowParcelTest {
 
   @Test
   public void testWriteAndReadByteArray() {
-    byte[] bytes = new byte[] { -1, 2, 3, 127 };
+    byte[] bytes = new byte[] {-1, 2, 3, 127};
     parcel.writeByteArray(bytes);
     assertThat(parcel.dataSize()).isEqualTo(8);
     parcel.setDataPosition(0);
@@ -644,7 +644,7 @@ public class ShadowParcelTest {
 
   @Test(expected = RuntimeException.class)
   public void testWriteAndReadByteArray_badLength() {
-    byte[] bytes = new byte[] { -1, 2, 3, 127 };
+    byte[] bytes = new byte[] {-1, 2, 3, 127};
     parcel.writeByteArray(bytes);
     assertThat(parcel.dataSize()).isEqualTo(8);
     parcel.setDataPosition(0);
@@ -846,8 +846,8 @@ public class ShadowParcelTest {
 
     parcel.writeTypedList(normals);
     parcel.setDataPosition(0);
-    List<org.robolectric.shadows.TestParcelable> rehydrated = parcel
-        .createTypedArrayList(TestParcelable.CREATOR);
+    List<org.robolectric.shadows.TestParcelable> rehydrated =
+        parcel.createTypedArrayList(TestParcelable.CREATOR);
 
     assertEquals(1, rehydrated.size());
     assertEquals(23, rehydrated.get(0).contents);
@@ -860,7 +860,8 @@ public class ShadowParcelTest {
     parcel.writeParcelable(normal, 0);
     parcel.setDataPosition(0);
 
-    TestParcelablePackage rehydrated = parcel.readParcelable(TestParcelablePackage.class.getClassLoader());
+    TestParcelablePackage rehydrated =
+        parcel.readParcelable(TestParcelablePackage.class.getClassLoader());
 
     assertEquals(normal.contents, rehydrated.contents);
   }
@@ -872,7 +873,8 @@ public class ShadowParcelTest {
     parcel.writeParcelable(normal, 0);
     parcel.setDataPosition(0);
 
-    TestParcelableImpl rehydrated = parcel.readParcelable(TestParcelableImpl.class.getClassLoader());
+    TestParcelableImpl rehydrated =
+        parcel.readParcelable(TestParcelableImpl.class.getClassLoader());
 
     assertEquals(normal.contents, rehydrated.contents);
   }
@@ -916,7 +918,7 @@ public class ShadowParcelTest {
 
   @Test
   public void testCreateStringArray() {
-    String[] strs = { "a1", "b2" };
+    String[] strs = {"a1", "b2"};
     parcel.writeStringArray(strs);
     parcel.setDataPosition(0);
     String[] newStrs = parcel.createStringArray();
@@ -1335,7 +1337,7 @@ public class ShadowParcelTest {
     parcel.setDataCapacity(12);
     assertWithMessage("capacity never shrinks").that(parcel.dataCapacity()).isEqualTo(404);
   }
-  
+
   @Test
   public void testWriteAndEnforceCompatibleInterface() {
     parcel.writeInterfaceToken("com.example.IMyInterface");
@@ -1343,7 +1345,7 @@ public class ShadowParcelTest {
     parcel.enforceInterface("com.example.IMyInterface");
     // Nothing explodes
   }
-  
+
   @Test
   public void testWriteAndEnforceIncompatibleInterface() {
     parcel.writeInterfaceToken("com.example.Derp");
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPasswordTransformationMethodTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPasswordTransformationMethodTest.java
index 452b7ccd3..bd9bc9221 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPasswordTransformationMethodTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPasswordTransformationMethodTest.java
@@ -14,30 +14,33 @@ public class ShadowPasswordTransformationMethodTest {
   private PasswordTransformationMethod transformationMethod;
 
   @Before
-  public void setUp(){
+  public void setUp() {
     transformationMethod = new PasswordTransformationMethod();
   }
 
   @Test
-  public void shouldMaskInputCharacters(){
+  public void shouldMaskInputCharacters() {
     CharSequence output = transformationMethod.getTransformation("foobar", null);
-    assertThat(output.toString()).isEqualTo("\u2022\u2022\u2022\u2022\u2022\u2022"); //using the escaped characters for cross platform compatibility.
+    assertThat(output.toString())
+        .isEqualTo(
+            "\u2022\u2022\u2022\u2022\u2022\u2022"); // using the escaped characters for cross
+    // platform compatibility.
   }
 
   @Test
-  public void shouldTransformSpacesWithText(){
+  public void shouldTransformSpacesWithText() {
     CharSequence output = transformationMethod.getTransformation(" baz ", null);
     assertThat(output.toString()).isEqualTo("\u2022\u2022\u2022\u2022\u2022");
   }
 
   @Test
-  public void shouldTransformSpacesWithoutText(){
+  public void shouldTransformSpacesWithoutText() {
     CharSequence output = transformationMethod.getTransformation("    ", null);
     assertThat(output.toString()).isEqualTo("\u2022\u2022\u2022\u2022");
   }
 
   @Test
-  public void shouldNotTransformBlank(){
+  public void shouldNotTransformBlank() {
     CharSequence output = transformationMethod.getTransformation("", null);
     assertThat(output.toString()).isEqualTo("");
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPathTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPathTest.java
index 3948971eb..8d64f4912 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPathTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPathTest.java
@@ -9,11 +9,13 @@ import static org.robolectric.shadows.ShadowPath.Point.Type.LINE_TO;
 import static org.robolectric.shadows.ShadowPath.Point.Type.MOVE_TO;
 
 import android.graphics.Path;
+import android.graphics.PathIterator;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
+import org.robolectric.versioning.AndroidVersions.U;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowPathTest {
@@ -109,4 +111,20 @@ public class ShadowPathTest {
 
     assertTrue(emptyPath.isEmpty());
   }
+
+  @Config(minSdk = U.SDK_INT)
+  @Test
+  public void iterate_doesNotOOM() {
+    Path path = new Path();
+    path.moveTo(0, 0);
+    path.lineTo(0, 1);
+    path.lineTo(1, 1);
+    path.lineTo(0, 1);
+    path.lineTo(0, 0);
+    path.close();
+
+    for (PathIterator pathIterator = path.getPathIterator();
+        pathIterator.hasNext();
+        pathIterator.next()) {}
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedAsyncTaskTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedAsyncTaskTest.java
index 413662bfc..42171f2a9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedAsyncTaskTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedAsyncTaskTest.java
@@ -25,9 +25,7 @@ import org.robolectric.android.util.concurrent.PausedExecutorService;
 import org.robolectric.annotation.LooperMode;
 import org.robolectric.util.Join;
 
-/**
- * Unit tests for {@link ShadowPausedAsyncTask}.
- */
+/** Unit tests for {@link ShadowPausedAsyncTask}. */
 @RunWith(AndroidJUnit4.class)
 @LooperMode(PAUSED)
 public class ShadowPausedAsyncTaskTest {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPermissionControllerManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPermissionControllerManagerTest.java
new file mode 100644
index 000000000..a8cbbde89
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPermissionControllerManagerTest.java
@@ -0,0 +1,97 @@
+package org.robolectric.shadows;
+
+import static android.content.pm.PackageInfo.REQUESTED_PERMISSION_GRANTED;
+import static android.os.Build.VERSION_CODES.Q;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.robolectric.Shadows.shadowOf;
+import static org.robolectric.shadows.ShadowLooper.shadowMainLooper;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.permission.PermissionControllerManager;
+import android.permission.PermissionControllerManager.OnRevokeRuntimePermissionsCallback;
+import androidx.test.core.app.ApplicationProvider;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@Config(minSdk = Q)
+@RunWith(RobolectricTestRunner.class)
+public final class ShadowPermissionControllerManagerTest {
+  private Context context;
+  private PackageManager packageManager;
+
+  @Before
+  public void setUp() {
+    context = ApplicationProvider.getApplicationContext();
+    packageManager = context.getPackageManager();
+  }
+
+  @Test
+  public void testRevokeRuntimePermission() {
+    // Do not define a PermissionControllerManager class field.
+    // System APIs are not available until the Robolectric classloader is initialized.
+    PermissionControllerManager permissionControllerManager =
+        context.getSystemService(PermissionControllerManager.class);
+    int sharedUid = 12345;
+    String permission1 = "com.test.permission1";
+    String permission2 = "com.test.permission2";
+    String packageName1 = "com.test.package1";
+    PackageInfo packageInfo1 = new PackageInfo();
+    packageInfo1.packageName = packageName1;
+    packageInfo1.requestedPermissions = new String[] {permission1, permission2};
+    packageInfo1.requestedPermissionsFlags =
+        new int[] {REQUESTED_PERMISSION_GRANTED, REQUESTED_PERMISSION_GRANTED};
+    packageInfo1.applicationInfo = new ApplicationInfo();
+    packageInfo1.applicationInfo.uid = sharedUid;
+    shadowOf(packageManager).installPackage(packageInfo1);
+    String packageName2 = "com.test.package2";
+    PackageInfo packageInfo2 = new PackageInfo();
+    packageInfo2.packageName = packageName2;
+    packageInfo2.requestedPermissions = new String[] {permission1, permission2};
+    packageInfo2.requestedPermissionsFlags =
+        new int[] {REQUESTED_PERMISSION_GRANTED, REQUESTED_PERMISSION_GRANTED};
+    packageInfo2.applicationInfo = new ApplicationInfo();
+    packageInfo2.applicationInfo.uid = sharedUid;
+    shadowOf(packageManager).installPackage(packageInfo2);
+    OnRevokeRuntimePermissionsCallback callback = mock(OnRevokeRuntimePermissionsCallback.class);
+
+    ImmutableMap<String, List<String>> request1 =
+        ImmutableMap.of(
+            packageName1, ImmutableList.of(permission1),
+            packageName2, ImmutableList.of(permission2));
+    permissionControllerManager.revokeRuntimePermissions(
+        request1, /* doDryRun= */ false, -1, context.getMainExecutor(), callback);
+    shadowMainLooper().idle();
+
+    verify(callback).onRevokeRuntimePermissions(eq(request1));
+    assertThat(packageInfo1.requestedPermissionsFlags[0]).isEqualTo(0);
+    assertThat(packageInfo1.requestedPermissionsFlags[1]).isEqualTo(REQUESTED_PERMISSION_GRANTED);
+    assertThat(packageInfo2.requestedPermissionsFlags[0]).isEqualTo(REQUESTED_PERMISSION_GRANTED);
+    assertThat(packageInfo2.requestedPermissionsFlags[1]).isEqualTo(0);
+
+    ImmutableMap<String, List<String>> request2 =
+        ImmutableMap.of(
+            packageName1, ImmutableList.of(permission2),
+            packageName2, ImmutableList.of(permission1));
+    permissionControllerManager.revokeRuntimePermissions(
+        request2, /* doDryRun= */ false, -1, context.getMainExecutor(), callback);
+    shadowMainLooper().idle();
+
+    verify(callback).onRevokeRuntimePermissions(eq(request2));
+    assertThat(packageInfo1.requestedPermissionsFlags[0]).isEqualTo(0);
+    assertThat(packageInfo1.requestedPermissionsFlags[1]).isEqualTo(0);
+    assertThat(packageInfo2.requestedPermissionsFlags[0]).isEqualTo(0);
+    assertThat(packageInfo2.requestedPermissionsFlags[1]).isEqualTo(0);
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPhoneWindowTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPhoneWindowTest.java
index 52721f069..6cf67e69a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPhoneWindowTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPhoneWindowTest.java
@@ -60,4 +60,4 @@ public class ShadowPhoneWindowTest {
     window.setDecorFitsSystemWindows(false);
     assertThat(((ShadowPhoneWindow) candidate).getDecorFitsSystemWindows()).isFalse();
   }
-}
\ No newline at end of file
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceActivityTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceActivityTest.java
index 9eefefc7b..1250b4e21 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceActivityTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceActivityTest.java
@@ -53,6 +53,5 @@ public class ShadowPreferenceActivityTest {
   }
 
   @SuppressWarnings("FragmentInjection")
-  private static class TestPreferenceActivity extends PreferenceActivity {
-  }
+  private static class TestPreferenceActivity extends PreferenceActivity {}
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceActivityTestWithFragment.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceActivityTestWithFragment.java
index 203f620d8..99a046f8c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceActivityTestWithFragment.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceActivityTestWithFragment.java
@@ -27,7 +27,8 @@ public class ShadowPreferenceActivityTestWithFragment {
 
   @Before
   public void before() {
-    this.fragment = (TestPreferenceFragment) this.activity.getFragmentManager().findFragmentByTag(FRAGMENT_TAG);
+    this.fragment =
+        (TestPreferenceFragment) this.activity.getFragmentManager().findFragmentByTag(FRAGMENT_TAG);
   }
 
   @Test
@@ -50,7 +51,10 @@ public class ShadowPreferenceActivityTestWithFragment {
 
       FragmentManager fragmentManager = this.getFragmentManager();
       TestPreferenceFragment fragment = new TestPreferenceFragment();
-      fragmentManager.beginTransaction().replace(android.R.id.content, fragment, FRAGMENT_TAG).commit();
+      fragmentManager
+          .beginTransaction()
+          .replace(android.R.id.content, fragment, FRAGMENT_TAG)
+          .commit();
     }
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceGroupTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceGroupTest.java
index f21c21fda..8ba073c85 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceGroupTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceGroupTest.java
@@ -28,7 +28,7 @@ public class ShadowPreferenceGroupTest {
   @Before
   public void setUp() throws Exception {
     activity = buildActivity(Activity.class).create().get();
-    attrs =  Robolectric.buildAttributeSet().build();
+    attrs = Robolectric.buildAttributeSet().build();
 
     group = new TestPreferenceGroup(activity, attrs);
     shadow = shadowOf(group);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowProcessTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowProcessTest.java
index 7bd042bfc..a91c42069 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowProcessTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowProcessTest.java
@@ -122,7 +122,7 @@ public class ShadowProcessTest {
   public void getThreadPriority_currentThread_returnsCurrentThreadPriority() {
     android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_AUDIO);
 
-    assertThat(android.os.Process.getThreadPriority(/*tid=*/ 0))
+    assertThat(android.os.Process.getThreadPriority(/* tid= */ 0))
         .isEqualTo(android.os.Process.THREAD_PRIORITY_AUDIO);
   }
 
@@ -168,4 +168,3 @@ public class ShadowProcessTest {
     assertThat(android.os.Process.myProcessName()).isEmpty();
   }
 }
-
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowProgressBarTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowProgressBarTest.java
index b3e81790e..937143702 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowProgressBarTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowProgressBarTest.java
@@ -22,11 +22,12 @@ public class ShadowProgressBarTest {
 
   @Before
   public void setUp() {
-    AttributeSet attrs = Robolectric.buildAttributeSet()
-        .addAttribute(android.R.attr.max, "100")
-        .addAttribute(android.R.attr.indeterminate, "false")
-        .addAttribute(android.R.attr.indeterminateOnly, "false")
-        .build();
+    AttributeSet attrs =
+        Robolectric.buildAttributeSet()
+            .addAttribute(android.R.attr.max, "100")
+            .addAttribute(android.R.attr.indeterminate, "false")
+            .addAttribute(android.R.attr.indeterminateOnly, "false")
+            .build();
 
     progressBar = new ProgressBar(getApplication(), attrs);
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRangingResultTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRangingResultTest.java
new file mode 100644
index 000000000..27b82f58b
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRangingResultTest.java
@@ -0,0 +1,69 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.P;
+import static android.os.Build.VERSION_CODES.R;
+import static android.os.Build.VERSION_CODES.S;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.MacAddress;
+import android.net.wifi.rtt.RangingResult;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+/** Tests ShadowRangeringResult's builder. */
+@RunWith(AndroidJUnit4.class)
+public class ShadowRangingResultTest {
+
+  @Test
+  @Config(minSdk = P, maxSdk = R)
+  public void testBuilder_pThroughR() {
+    RangingResult result =
+        new ShadowRangingResult.Builder(
+                RangingResult.STATUS_SUCCESS,
+                MacAddress.fromString("00:0a:95:9d:68:16"),
+                1548290142, // Timestamp
+                10000) // DistanceMm
+            .setRssi(100)
+            .setDistanceStandardDeviation(200)
+            .setNumAttemptedMeasurements(3)
+            .setNumSuccessfulMeasurements(5)
+            .setUnverifiedResponderLocation(null)
+            .build();
+    assertThat(result.getMacAddress()).isEqualTo(MacAddress.fromString("00:0a:95:9d:68:16"));
+    assertThat(result.getDistanceMm()).isEqualTo(10000);
+    assertThat(result.getRssi()).isEqualTo(100);
+    assertThat(result.getDistanceStdDevMm()).isEqualTo(200);
+    assertThat(result.getNumAttemptedMeasurements()).isEqualTo(3);
+    assertThat(result.getNumSuccessfulMeasurements()).isEqualTo(5);
+    assertThat(result.getPeerHandle()).isNull();
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void testBuilder_sPlus() {
+    RangingResult result =
+        new ShadowRangingResult.Builder(
+                RangingResult.STATUS_SUCCESS,
+                MacAddress.fromString("00:0a:95:9d:68:16"),
+                1548290142, // Timestamp
+                10000) // DistanceMm
+            .setRssi(100)
+            .setDistanceStandardDeviation(200)
+            .setNumAttemptedMeasurements(3)
+            .setNumSuccessfulMeasurements(5)
+            .setUnverifiedResponderLocation(null)
+            .setIs80211mcMeasurement(true)
+            .build();
+    assertThat(result.getMacAddress()).isEqualTo(MacAddress.fromString("00:0a:95:9d:68:16"));
+    assertThat(result.getDistanceMm()).isEqualTo(10000);
+    assertThat(result.getRssi()).isEqualTo(100);
+    assertThat(result.getDistanceStdDevMm()).isEqualTo(200);
+    assertThat(result.getNumAttemptedMeasurements()).isEqualTo(3);
+    assertThat(result.getNumSuccessfulMeasurements()).isEqualTo(5);
+    assertThat(result.getPeerHandle()).isNull();
+    assertThat(result.getUnverifiedResponderLocation()).isNull();
+    assertThat(result.is80211mcMeasurement()).isTrue();
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRectTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRectTest.java
index 37951fd84..96424cafd 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowRectTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRectTest.java
@@ -11,8 +11,7 @@ import org.junit.runner.RunWith;
 @RunWith(AndroidJUnit4.class)
 public class ShadowRectTest {
   @Before
-  public void setUp() {
-  }
+  public void setUp() {}
 
   @Test
   public void constructorSetsCoordinates() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRelativeLayoutTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRelativeLayoutTest.java
index 6cc90a3b9..9149901de 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowRelativeLayoutTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRelativeLayoutTest.java
@@ -17,11 +17,17 @@ public class ShadowRelativeLayoutTest {
   public void getRules_shouldShowAddRuleData_sinceApiLevel17() {
     ImageView imageView = new ImageView(ApplicationProvider.getApplicationContext());
     RelativeLayout layout = new RelativeLayout(ApplicationProvider.getApplicationContext());
-    layout.addView(imageView, new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
-    RelativeLayout.LayoutParams layoutParams = (RelativeLayout.LayoutParams) imageView.getLayoutParams();
+    layout.addView(
+        imageView,
+        new RelativeLayout.LayoutParams(
+            ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
+    RelativeLayout.LayoutParams layoutParams =
+        (RelativeLayout.LayoutParams) imageView.getLayoutParams();
     layoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
     layoutParams.addRule(RelativeLayout.ALIGN_TOP, 1234);
     int[] rules = layoutParams.getRules();
-    assertThat(rules).isEqualTo(new int[]{0, 0, 0, 0, 0, 0, 1234, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0});
+    assertThat(rules)
+        .isEqualTo(
+            new int[] {0, 0, 0, 0, 0, 0, 1234, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0});
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRemoteCallbackListTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRemoteCallbackListTest.java
index 601089577..74dc68161 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowRemoteCallbackListTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRemoteCallbackListTest.java
@@ -47,4 +47,4 @@ public class ShadowRemoteCallbackListTest {
       return new Binder();
     }
   }
-}
\ No newline at end of file
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowResourcesTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowResourcesTest.java
index 799fce722..5f9ceabe4 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowResourcesTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowResourcesTest.java
@@ -107,7 +107,7 @@ public class ShadowResourcesTest {
   @Test
   public void openRawResourceFd_shouldReturnsValidFdForUnCompressFile() throws Exception {
     try (AssetFileDescriptor afd = resources.openRawResourceFd(R.raw.raw_resource)) {
-        assertThat(afd).isNotNull();
+      assertThat(afd).isNotNull();
     }
   }
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRestrictionsManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRestrictionsManagerTest.java
index e9bbf6862..8712a45e9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowRestrictionsManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRestrictionsManagerTest.java
@@ -23,7 +23,8 @@ public final class ShadowRestrictionsManagerTest {
   @Before
   public void setUp() {
     context = ApplicationProvider.getApplicationContext();
-    restrictionsManager = (RestrictionsManager) context.getSystemService(Context.RESTRICTIONS_SERVICE);
+    restrictionsManager =
+        (RestrictionsManager) context.getSystemService(Context.RESTRICTIONS_SERVICE);
   }
 
   @Test
@@ -41,8 +42,9 @@ public final class ShadowRestrictionsManagerTest {
 
   @Test
   public void getManifestRestrictions() {
-    RestrictionEntry restrictionEntry = Iterables.getOnlyElement(restrictionsManager
-        .getManifestRestrictions(context.getPackageName()));
+    RestrictionEntry restrictionEntry =
+        Iterables.getOnlyElement(
+            restrictionsManager.getManifestRestrictions(context.getPackageName()));
 
     assertThat(restrictionEntry.getKey()).isEqualTo("restrictionKey");
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowScaleGestureDetectorTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowScaleGestureDetectorTest.java
index 9a8276500..9fcd775d2 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowScaleGestureDetectorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowScaleGestureDetectorTest.java
@@ -21,8 +21,9 @@ public class ShadowScaleGestureDetectorTest {
 
   @Before
   public void setUp() throws Exception {
-    detector = new ScaleGestureDetector(ApplicationProvider.getApplicationContext(),
-        new TestOnGestureListener());
+    detector =
+        new ScaleGestureDetector(
+            ApplicationProvider.getApplicationContext(), new TestOnGestureListener());
     motionEvent = MotionEvent.obtain(-1, -1, MotionEvent.ACTION_UP, 100, 30, -1);
   }
 
@@ -75,7 +76,8 @@ public class ShadowScaleGestureDetectorTest {
     assertThat(detector.getFocusY()).isEqualTo(0f);
   }
 
-  private static class TestOnGestureListener implements ScaleGestureDetector.OnScaleGestureListener {
+  private static class TestOnGestureListener
+      implements ScaleGestureDetector.OnScaleGestureListener {
     @Override
     public boolean onScale(ScaleGestureDetector detector) {
       return false;
@@ -87,7 +89,6 @@ public class ShadowScaleGestureDetectorTest {
     }
 
     @Override
-    public void onScaleEnd(ScaleGestureDetector detector) {
-    }
+    public void onScaleEnd(ScaleGestureDetector detector) {}
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSecureElementServiceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSecureElementServiceTest.java
new file mode 100644
index 000000000..b12997a73
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSecureElementServiceTest.java
@@ -0,0 +1,114 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.R;
+import static com.google.common.truth.Truth.assertThat;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.junit.Assert.assertThrows;
+import static org.robolectric.annotation.LooperMode.Mode.INSTRUMENTATION_TEST;
+
+import android.content.Context;
+import android.se.omapi.Channel;
+import android.se.omapi.Reader;
+import android.se.omapi.SEService;
+import android.se.omapi.Session;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.LooperMode;
+import org.robolectric.shadows.ShadowSecureElementService.MockApplet;
+
+/** Tests for {@link ShadowMediaCodec}. */
+@LooperMode(INSTRUMENTATION_TEST)
+@RunWith(AndroidJUnit4.class)
+public final class ShadowSecureElementServiceTest {
+
+  private final Context context = ApplicationProvider.getApplicationContext();
+  private SEService seService;
+
+  @Before
+  public void setup() throws Exception {
+    CountDownLatch latch = new CountDownLatch(1);
+    seService = new SEService(context, Executors.newSingleThreadExecutor(), latch::countDown);
+    latch.await();
+  }
+
+  @Test
+  @Config(minSdk = R)
+  public void oneReader_oneChannel_openTransmitTwiceClose_success() throws Exception {
+    MockApplet mockApplet = new MockApplet("eSE", "aid".getBytes(UTF_8));
+    mockApplet.setSelectResponse("selected".getBytes(UTF_8));
+    mockApplet.addApduResponse("firstResponse".getBytes(UTF_8));
+    mockApplet.addApduResponse("secondResponse".getBytes(UTF_8));
+    ShadowSecureElementService.addMockApplet(mockApplet);
+
+    Reader[] readers = seService.getReaders();
+    assertThat(readers).hasLength(1);
+    assertThrows(IllegalArgumentException.class, () -> seService.getUiccReader(1));
+
+    Reader reader = readers[0];
+    assertThat(reader.getName()).isEqualTo("eSE");
+    assertThat(reader.getSEService()).isEqualTo(seService);
+    assertThat(reader.isSecureElementPresent()).isTrue();
+
+    Session session = reader.openSession();
+    assertThat(session).isNotNull();
+    assertThat(session.isClosed()).isFalse();
+
+    Channel channel = session.openLogicalChannel("aid".getBytes(UTF_8));
+    assertThat(channel).isNotNull();
+
+    assertThat(channel.getSelectResponse()).isEqualTo("selected".getBytes(UTF_8));
+    assertThat(channel.isBasicChannel()).isFalse();
+    assertThat(channel.isOpen()).isTrue();
+    assertThat(channel.getSession()).isEqualTo(session);
+
+    byte[] firstResponse = channel.transmit("firstCommand".getBytes(UTF_8));
+    assertThat(firstResponse).isEqualTo("firstResponse".getBytes(UTF_8));
+
+    byte[] secondResponse = channel.transmit("secondCommand".getBytes(UTF_8));
+    assertThat(secondResponse).isEqualTo("secondResponse".getBytes(UTF_8));
+
+    channel.close();
+    assertThat(channel.isOpen()).isFalse();
+
+    List<byte[]> requests = mockApplet.getAdpuRequests();
+    assertThat(requests).hasSize(2);
+    assertThat(requests.get(0)).isEqualTo("firstCommand".getBytes(UTF_8));
+    assertThat(requests.get(1)).isEqualTo("secondCommand".getBytes(UTF_8));
+
+    seService.shutdown();
+    assertThat(seService.isConnected()).isFalse();
+    assertThat(session.isClosed()).isTrue();
+  }
+
+  @Test
+  @Config(minSdk = R)
+  public void twoReaders_alsoWorks() throws Exception {
+    ShadowSecureElementService.addMockApplet(new MockApplet("SIM1", "foo".getBytes(UTF_8)));
+    ShadowSecureElementService.addMockApplet(new MockApplet("SIM2", "bar".getBytes(UTF_8)));
+
+    Reader[] readers = seService.getReaders();
+    assertThat(readers).hasLength(2);
+    assertThat(seService.getUiccReader(1)).isEqualTo(readers[0]);
+    assertThat(seService.getUiccReader(2)).isEqualTo(readers[1]);
+
+    Reader fooReader = readers[0];
+    Session fooSession = fooReader.openSession();
+    Channel fooChannel = fooSession.openBasicChannel("foo".getBytes(UTF_8));
+    assertThat(fooChannel).isNotNull();
+    assertThat(fooChannel.getSelectResponse()).isEqualTo(new byte[] {(byte) 0x90, 0x00});
+    assertThat(fooSession.openBasicChannel("bar".getBytes(UTF_8))).isNull();
+
+    Reader barReader = readers[1];
+    Session barSession = barReader.openSession();
+    Channel barChannel = barSession.openBasicChannel("bar".getBytes(UTF_8));
+    assertThat(barChannel).isNotNull();
+    assertThat(barSession.openBasicChannel("foo".getBytes(UTF_8))).isNull();
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSeekBarTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSeekBarTest.java
index 2ef14a7da..85aa57f0f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSeekBarTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSeekBarTest.java
@@ -50,11 +50,9 @@ public class ShadowSeekBarTest {
     }
 
     @Override
-    public void onStartTrackingTouch(SeekBar seekBar) {
-    }
+    public void onStartTrackingTouch(SeekBar seekBar) {}
 
     @Override
-    public void onStopTrackingTouch(SeekBar seekBar) {
-    }
+    public void onStopTrackingTouch(SeekBar seekBar) {}
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowServiceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowServiceTest.java
index 3caa6758f..ec8c0cd0a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowServiceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowServiceTest.java
@@ -27,7 +27,7 @@ import org.robolectric.shadow.api.Shadow;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowServiceTest {
-  private MyService service ;
+  private MyService service;
   private Notification.Builder notBuilder;
 
   NotificationManager nm2 =
@@ -110,8 +110,8 @@ public class ShadowServiceTest {
   }
 
   /**
-   * According to spec, if the foreground notification is not removed earlier,
-   * then it will be removed when the service is destroyed.
+   * According to spec, if the foreground notification is not removed earlier, then it will be
+   * removed when the service is destroyed.
    */
   @Test
   public void stopForegroundDoesntRemoveNotificationUnlessAsked() {
@@ -129,8 +129,8 @@ public class ShadowServiceTest {
   }
 
   /**
-   * According to spec, if the foreground notification is not removed earlier,
-   * then it will be removed when the service is destroyed.
+   * According to spec, if the foreground notification is not removed earlier, then it will be
+   * removed when the service is destroyed.
    */
   @Test
   public void onDestroyRemovesNotification() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSharedPreferencesTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSharedPreferencesTest.java
index 3d285373f..b72345309 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSharedPreferencesTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSharedPreferencesTest.java
@@ -25,7 +25,7 @@ import org.robolectric.annotation.LooperMode;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowSharedPreferencesTest {
-  private final static String FILENAME = "filename";
+  private static final String FILENAME = "filename";
   private SharedPreferences.Editor editor;
   private SharedPreferences sharedPreferences;
 
@@ -48,9 +48,9 @@ public class ShadowSharedPreferencesTest {
     editor.putLong("long", 3L);
     editor.putString("string", "foobar");
 
-    stringSet.add( "string1" );
-    stringSet.add( "string2" );
-    stringSet.add( "string3" );
+    stringSet.add("string1");
+    stringSet.add("string2");
+    stringSet.add("string3");
     editor.putStringSet("stringSet", stringSet);
   }
 
@@ -58,7 +58,8 @@ public class ShadowSharedPreferencesTest {
   public void commit_shouldStoreValues() {
     editor.commit();
 
-    SharedPreferences anotherSharedPreferences = context.getSharedPreferences(FILENAME, Context.MODE_PRIVATE);
+    SharedPreferences anotherSharedPreferences =
+        context.getSharedPreferences(FILENAME, Context.MODE_PRIVATE);
     assertTrue(anotherSharedPreferences.getBoolean("boolean", false));
     assertThat(anotherSharedPreferences.getFloat("float", 666f)).isEqualTo(1.1f);
     assertThat(anotherSharedPreferences.getInt("int", 666)).isEqualTo(2);
@@ -75,7 +76,8 @@ public class ShadowSharedPreferencesTest {
     assertThat(sharedPreferences.getString("string", "no value for key"))
         .isEqualTo("no value for key");
 
-    SharedPreferences anotherSharedPreferences = context.getSharedPreferences(FILENAME, Context.MODE_PRIVATE);
+    SharedPreferences anotherSharedPreferences =
+        context.getSharedPreferences(FILENAME, Context.MODE_PRIVATE);
     anotherSharedPreferences.edit().putString("string", "value for key").commit();
 
     editor.commit();
@@ -101,7 +103,8 @@ public class ShadowSharedPreferencesTest {
 
     editor.commit();
 
-    SharedPreferences anotherSharedPreferences = context.getSharedPreferences(FILENAME, Context.MODE_PRIVATE);
+    SharedPreferences anotherSharedPreferences =
+        context.getSharedPreferences(FILENAME, Context.MODE_PRIVATE);
     assertThat(anotherSharedPreferences.getBoolean("boolean", false)).isTrue();
     assertThat(anotherSharedPreferences.getFloat("float", 666f)).isEqualTo(1.1f);
     assertThat(anotherSharedPreferences.getInt("int", 666)).isEqualTo(2);
@@ -121,14 +124,16 @@ public class ShadowSharedPreferencesTest {
 
     editor.commit();
 
-    SharedPreferences anotherSharedPreferences = context.getSharedPreferences(FILENAME, Context.MODE_PRIVATE);
+    SharedPreferences anotherSharedPreferences =
+        context.getSharedPreferences(FILENAME, Context.MODE_PRIVATE);
     assertTrue(anotherSharedPreferences.getBoolean("boolean", false));
     assertThat(anotherSharedPreferences.getFloat("float", 666f)).isEqualTo(1.1f);
     assertThat(anotherSharedPreferences.getInt("int", 666)).isEqualTo(2);
     assertThat(anotherSharedPreferences.getLong("long", 666L)).isEqualTo(3L);
     assertThat(anotherSharedPreferences.getString("string", "wacka wa")).isEqualTo("foobar");
 
-    // Android always calls clear before put on any open editor, so here "foo" is preserved rather than cleared.
+    // Android always calls clear before put on any open editor, so here "foo" is preserved rather
+    // than cleared.
     assertThat(anotherSharedPreferences.getString("deleteMe", "awol")).isEqualTo("foo");
     assertThat(anotherSharedPreferences.getString("dontDeleteMe", "oops")).isEqualTo("baz");
   }
@@ -157,7 +162,8 @@ public class ShadowSharedPreferencesTest {
   public void apply_shouldStoreValues() {
     editor.apply();
 
-    SharedPreferences anotherSharedPreferences = context.getSharedPreferences(FILENAME, Context.MODE_PRIVATE);
+    SharedPreferences anotherSharedPreferences =
+        context.getSharedPreferences(FILENAME, Context.MODE_PRIVATE);
     assertThat(anotherSharedPreferences.getString("string", "wacka wa")).isEqualTo("foobar");
   }
 
@@ -178,7 +184,8 @@ public class ShadowSharedPreferencesTest {
     SharedPreferences anotherSharedPreferences =
         context.getSharedPreferences("bazBang", Context.MODE_PRIVATE);
 
-    SharedPreferences.OnSharedPreferenceChangeListener mockListener = mock(SharedPreferences.OnSharedPreferenceChangeListener.class);
+    SharedPreferences.OnSharedPreferenceChangeListener mockListener =
+        mock(SharedPreferences.OnSharedPreferenceChangeListener.class);
     anotherSharedPreferences.registerOnSharedPreferenceChangeListener(mockListener);
 
     anotherSharedPreferences.unregisterOnSharedPreferenceChangeListener(mockListener);
@@ -201,7 +208,7 @@ public class ShadowSharedPreferencesTest {
     anotherSharedPreferences.registerOnSharedPreferenceChangeListener(listener);
     anotherSharedPreferences.edit().putString(testKey, "bar").commit();
 
-    assertThat(transcript).containsExactly(testKey+ " called");
+    assertThat(transcript).containsExactly(testKey + " called");
   }
 
   @Test
@@ -209,7 +216,8 @@ public class ShadowSharedPreferencesTest {
     SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
     sharedPreferences.edit().putString("foo", "bar").commit();
 
-    SharedPreferences anotherSharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
+    SharedPreferences anotherSharedPreferences =
+        PreferenceManager.getDefaultSharedPreferences(context);
     String restored = anotherSharedPreferences.getString("foo", null);
     assertThat(restored).isEqualTo("bar");
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowShortcutManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowShortcutManagerTest.java
index dfccff5c6..f42d9e1cb 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowShortcutManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowShortcutManagerTest.java
@@ -116,8 +116,7 @@ public final class ShadowShortcutManagerTest {
   public void testRemoveDynamicShortcuts() {
     ShortcutInfo shortcut1 = createShortcut("id1");
     ShortcutInfo shortcut2 = createShortcut("id2");
-    shortcutManager.addDynamicShortcuts(
-        ImmutableList.of(shortcut1, shortcut2));
+    shortcutManager.addDynamicShortcuts(ImmutableList.of(shortcut1, shortcut2));
     assertThat(shortcutManager.getDynamicShortcuts()).hasSize(2);
 
     shortcutManager.removeDynamicShortcuts(ImmutableList.of("id1"));
@@ -141,8 +140,7 @@ public final class ShadowShortcutManagerTest {
   public void testUpdateShortcut_dynamic() {
     ShortcutInfo shortcut1 = createShortcutWithLabel("id1", "original");
     ShortcutInfo shortcutUpdated = createShortcutWithLabel("id1", "updated");
-    shortcutManager.addDynamicShortcuts(
-        ImmutableList.of(shortcut1));
+    shortcutManager.addDynamicShortcuts(ImmutableList.of(shortcut1));
     assertThat(shortcutManager.getDynamicShortcuts()).containsExactly(shortcut1);
 
     shortcutManager.updateShortcuts(ImmutableList.of(shortcutUpdated));
@@ -154,8 +152,7 @@ public final class ShadowShortcutManagerTest {
   public void testUpdateShortcut_pinned() {
     ShortcutInfo shortcut1 = createShortcutWithLabel("id1", "original");
     ShortcutInfo shortcutUpdated = createShortcutWithLabel("id1", "updated");
-    shortcutManager.requestPinShortcut(
-        shortcut1, null /* resultIntent */);
+    shortcutManager.requestPinShortcut(shortcut1, null /* resultIntent */);
     assertThat(shortcutManager.getPinnedShortcuts()).containsExactly(shortcut1);
 
     shortcutManager.updateShortcuts(ImmutableList.of(shortcutUpdated));
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSigningInfoTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSigningInfoTest.java
index 6f700c50f..9e2e3c0ac 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSigningInfoTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSigningInfoTest.java
@@ -19,7 +19,7 @@ import org.robolectric.shadow.api.Shadow;
 public final class ShadowSigningInfoTest {
   @Test
   public void testParceling_preservesCurrentSignatures() {
-    Signature[] signatures = { new Signature("0123"), new Signature("4657") };
+    Signature[] signatures = {new Signature("0123"), new Signature("4657")};
     SigningInfo signingInfo = Shadow.newInstanceOf(SigningInfo.class);
     shadowOf(signingInfo).setSignatures(signatures);
 
@@ -33,8 +33,8 @@ public final class ShadowSigningInfoTest {
 
   @Test
   public void testParceling_preservesPastSigningCertificates() {
-    Signature[] signatures = { new Signature("0123")};
-    Signature[] pastSignatures = { new Signature("0123"), new Signature("4567") };
+    Signature[] signatures = {new Signature("0123")};
+    Signature[] pastSignatures = {new Signature("0123"), new Signature("4567")};
     SigningInfo signingInfo = Shadow.newInstanceOf(SigningInfo.class);
     shadowOf(signingInfo).setSignatures(signatures);
     shadowOf(signingInfo).setPastSigningCertificates(pastSignatures);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSoundPoolTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSoundPoolTest.java
index d38cbb63a..be477bc64 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSoundPoolTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSoundPoolTest.java
@@ -1,19 +1,16 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.robolectric.Shadows.shadowOf;
 
-import android.media.AudioManager;
 import android.media.SoundPool;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.R;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.shadows.ShadowSoundPool.Playback;
 
 @RunWith(AndroidJUnit4.class)
@@ -149,7 +146,7 @@ public class ShadowSoundPoolTest {
   }
 
   @Test
-  public void loadSoundWithResId_positiveId () {
+  public void loadSoundWithResId_positiveId() {
     SoundPool soundPool = createSoundPool();
 
     int soundId = soundPool.load(ApplicationProvider.getApplicationContext(), R.raw.sound, 1);
@@ -158,7 +155,7 @@ public class ShadowSoundPoolTest {
   }
 
   @Test
-  public void loadSoundWithPath_positiveId () {
+  public void loadSoundWithPath_positiveId() {
     SoundPool soundPool = createSoundPool();
 
     int soundId = soundPool.load("/mnt/sdcard/sound.wav", 1);
@@ -167,8 +164,6 @@ public class ShadowSoundPoolTest {
   }
 
   private SoundPool createSoundPool() {
-    return RuntimeEnvironment.getApiLevel() >= LOLLIPOP
-        ? new SoundPool.Builder().build()
-        : new SoundPool(1, AudioManager.STREAM_MUSIC, 0);
+    return new SoundPool.Builder().build();
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSpannableStringTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSpannableStringTest.java
index 82148f881..10a1672da 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSpannableStringTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSpannableStringTest.java
@@ -96,5 +96,4 @@ public class ShadowSpannableStringTest {
       assertThat(spans[1]).isSameInstanceAs(s1);
     }
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSpannedStringTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSpannedStringTest.java
index 37f8fe4d8..0fffd0f74 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSpannedStringTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSpannedStringTest.java
@@ -27,7 +27,4 @@ public class ShadowSpannedStringTest {
   public void valueOfCharSequence_shouldReturnNewSpannedString() {
     assertEquals("foo", SpannedString.valueOf("foo").toString());
   }
-
-
 }
-
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowStrictModeTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowStrictModeTest.java
index 8c047e8c5..06e1b899b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowStrictModeTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowStrictModeTest.java
@@ -12,4 +12,4 @@ public class ShadowStrictModeTest {
     StrictMode.VmPolicy policy = new StrictMode.VmPolicy.Builder().build();
     StrictMode.setVmPolicy(policy); // should not result in an exception
   }
-}
\ No newline at end of file
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceViewTest.java
index b6719eae7..be36a9504 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceViewTest.java
@@ -88,16 +88,13 @@ public class ShadowSurfaceViewTest {
 
   private static class TestCallback implements SurfaceHolder.Callback {
     @Override
-    public void surfaceCreated(SurfaceHolder holder) {
-    }
+    public void surfaceCreated(SurfaceHolder holder) {}
 
     @Override
-    public void surfaceDestroyed(SurfaceHolder holder) {
-    }
+    public void surfaceDestroyed(SurfaceHolder holder) {}
 
     @Override
-    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
-    }
+    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {}
   }
 
   private static class TestActivity extends Activity {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTabHostTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTabHostTest.java
index b9501f199..323e258bf 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTabHostTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTabHostTest.java
@@ -129,17 +129,17 @@ public class ShadowTabHostTest {
 
     assertThat(textView.getText().toString()).isEqualTo("The Text of Foo");
   }
+
   @Test
   public void shouldRetrieveTheCurrentViewFromViewId() {
     Activity activity = Robolectric.buildActivity(Activity.class).create().get();
     activity.setContentView(org.robolectric.R.layout.main);
     TabHost tabHost = new TabHost(activity);
-    TabHost.TabSpec foo = tabHost.newTabSpec("Foo")
-    .setContent(org.robolectric.R.id.title);
+    TabHost.TabSpec foo = tabHost.newTabSpec("Foo").setContent(org.robolectric.R.id.title);
 
-     tabHost.addTab(foo);
-     tabHost.setCurrentTabByTag("Foo");
-     TextView textView = (TextView) tabHost.getCurrentView();
+    tabHost.addTab(foo);
+    tabHost.setCurrentTabByTag("Foo");
+    TextView textView = (TextView) tabHost.getCurrentView();
 
     assertThat(textView.getText().toString()).isEqualTo("Main Layout");
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTabSpecTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTabSpecTest.java
index 0cb4f6138..9d387d034 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTabSpecTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTabSpecTest.java
@@ -84,7 +84,6 @@ public class ShadowTabSpecTest {
     ShadowTabHost.ShadowTabSpec shadowFoo = shadowOf(foo);
     TextView textView = (TextView) shadowFoo.getContentView();
 
-
     assertThat(textView.getText().toString()).isEqualTo("The Text of Foo");
   }
 
@@ -101,22 +100,17 @@ public class ShadowTabSpecTest {
   private static class TestIcon extends Drawable {
 
     @Override
-    public void draw(Canvas canvas) {
-    }
+    public void draw(Canvas canvas) {}
 
     @Override
-    public void setAlpha(int alpha) {
-    }
+    public void setAlpha(int alpha) {}
 
     @Override
-    public void setColorFilter(ColorFilter cf) {
-    }
+    public void setColorFilter(ColorFilter cf) {}
 
     @Override
     public int getOpacity() {
       return 0;
     }
-
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTelecomManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTelecomManagerTest.java
index e31897355..534526be6 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTelecomManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTelecomManagerTest.java
@@ -128,13 +128,13 @@ public class ShadowTelecomManagerTest {
   @Config(minSdk = LOLLIPOP_MR1)
   public void clearAccountsForPackage() {
     PhoneAccountHandle accountHandle1 = createHandle("a.package", "OtherConnectionService", "id1");
-    telecomService.registerPhoneAccount(PhoneAccount.builder(accountHandle1, "another_package")
-        .build());
+    telecomService.registerPhoneAccount(
+        PhoneAccount.builder(accountHandle1, "another_package").build());
 
     PhoneAccountHandle accountHandle2 =
         createHandle("some.other.package", "OtherConnectionService", "id2");
-    telecomService.registerPhoneAccount(PhoneAccount.builder(accountHandle2, "another_package")
-        .build());
+    telecomService.registerPhoneAccount(
+        PhoneAccount.builder(accountHandle2, "another_package").build());
 
     telecomService.clearAccountsForPackage(accountHandle1.getComponentName().getPackageName());
 
@@ -181,15 +181,14 @@ public class ShadowTelecomManagerTest {
   @Config(minSdk = M)
   public void getCallCapablePhoneAccounts() {
     PhoneAccountHandle callCapableHandle = createHandle("id1");
-    telecomService.registerPhoneAccount(PhoneAccount.builder(callCapableHandle, "enabled")
-        .setIsEnabled(true)
-        .build());
+    telecomService.registerPhoneAccount(
+        PhoneAccount.builder(callCapableHandle, "enabled").setIsEnabled(true).build());
     PhoneAccountHandle notCallCapableHandler = createHandle("id2");
-    telecomService.registerPhoneAccount(PhoneAccount.builder(notCallCapableHandler, "disabled")
-        .setIsEnabled(false)
-        .build());
+    telecomService.registerPhoneAccount(
+        PhoneAccount.builder(notCallCapableHandler, "disabled").setIsEnabled(false).build());
 
-    List<PhoneAccountHandle> callCapablePhoneAccounts = telecomService.getCallCapablePhoneAccounts();
+    List<PhoneAccountHandle> callCapablePhoneAccounts =
+        telecomService.getCallCapablePhoneAccounts();
     assertThat(callCapablePhoneAccounts).contains(callCapableHandle);
     assertThat(callCapablePhoneAccounts).doesNotContain(notCallCapableHandler);
   }
@@ -549,6 +548,20 @@ public class ShadowTelecomManagerTest {
     assertThat(telecomService.isInCall()).isFalse();
   }
 
+  @Test
+  @Config(minSdk = Q)
+  public void canSetAndGetIsInEmergencyCall_setsBothInCallAndInEmergencyCall() {
+    shadowOf(telecomService).setIsInEmergencyCall(true);
+    assertThat(telecomService.isInEmergencyCall()).isTrue();
+    assertThat(telecomService.isInCall()).isTrue();
+  }
+
+  @Test
+  @Config(minSdk = Q)
+  public void isInEmergencyCall_setIsInEmergencyCallNotCalled_shouldReturnFalse() {
+    assertThat(telecomService.isInEmergencyCall()).isFalse();
+  }
+
   @Test
   public void getDefaultOutgoingPhoneAccount() {
     // Check initial state
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTextToSpeechTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTextToSpeechTest.java
index e3c1ee49f..48bdb44a8 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTextToSpeechTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTextToSpeechTest.java
@@ -18,6 +18,7 @@ import com.google.common.collect.ImmutableSet;
 import java.io.File;
 import java.io.IOException;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Locale;
 import java.util.concurrent.atomic.AtomicReference;
 import org.junit.Before;
@@ -381,6 +382,42 @@ public class ShadowTextToSpeechTest {
         .isEqualTo(TextToSpeech.LANG_NOT_SUPPORTED);
   }
 
+  @Test
+  public void setLanguage_languageAvailable_shouldSetVoiceToLocaleDefault() {
+    TextToSpeech textToSpeech = new TextToSpeech(activity, result -> {});
+    ShadowTextToSpeech.addLanguageAvailability(Locale.US);
+
+    textToSpeech.setLanguage(Locale.US);
+
+    assertThat(textToSpeech.getVoice().getName()).isEqualTo("en-US");
+  }
+
+  @Test
+  public void setLanguage_languageUnavailable_voiceIsNull() {
+    TextToSpeech textToSpeech = new TextToSpeech(activity, result -> {});
+
+    textToSpeech.setLanguage(Locale.US);
+
+    assertThat(textToSpeech.getVoice()).isNull();
+  }
+
+  @Test
+  public void getVoice_setVoice_returnsVoiceThatWasSet() {
+    TextToSpeech textToSpeech = new TextToSpeech(activity, result -> {});
+    Voice testVoice =
+        new Voice(
+            "test",
+            Locale.US,
+            Voice.QUALITY_NORMAL,
+            Voice.LATENCY_NORMAL,
+            /* requiresNetworkConnection= */ false,
+            new HashSet<>());
+
+    textToSpeech.setVoice(testVoice);
+
+    assertThat(textToSpeech.getVoice()).isEqualTo(testVoice);
+  }
+
   @Test
   public void getLastTextToSpeechInstance_neverConstructed_returnsNull() {
     assertThat(ShadowTextToSpeech.getLastTextToSpeechInstance()).isNull();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTextUtilsTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTextUtilsTest.java
index cc2cd2bea..65990ace7 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTextUtilsTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTextUtilsTest.java
@@ -26,9 +26,10 @@ public class ShadowTextUtilsTest {
     assertThat(TextUtils.isEmpty("123")).isFalse();
   }
 
-  @Test public void testJoin() {
-    assertThat(TextUtils.join(",", new String[]{"1"})).isEqualTo("1");
-    assertThat(TextUtils.join(",", new String[]{"1", "2", "3"})).isEqualTo("1,2,3");
+  @Test
+  public void testJoin() {
+    assertThat(TextUtils.join(",", new String[] {"1"})).isEqualTo("1");
+    assertThat(TextUtils.join(",", new String[] {"1", "2", "3"})).isEqualTo("1,2,3");
     assertThat(TextUtils.join(",", Arrays.asList("1", "2", "3"))).isEqualTo("1,2,3");
   }
 
@@ -40,17 +41,17 @@ public class ShadowTextUtilsTest {
 
   @Test
   public void testSplit() {
-    //empty
+    // empty
     assertThat(TextUtils.split("", ",").length).isEqualTo(0);
 
-    //one value
-    assertArrayEquals(TextUtils.split("abc", ","), new String[]{"abc"});
+    // one value
+    assertArrayEquals(TextUtils.split("abc", ","), new String[] {"abc"});
 
-    //two values
-    assertArrayEquals(TextUtils.split("abc,def", ","), new String[]{"abc", "def"});
+    // two values
+    assertArrayEquals(TextUtils.split("abc,def", ","), new String[] {"abc", "def"});
 
-    //two values with space
-    assertArrayEquals(TextUtils.split("abc, def", ","), new String[]{"abc", " def"});
+    // two values with space
+    assertArrayEquals(TextUtils.split("abc, def", ","), new String[] {"abc", " def"});
   }
 
   @Test
@@ -79,7 +80,8 @@ public class ShadowTextUtilsTest {
     assertThat(TextUtils.equals("ab", "a")).isFalse();
   }
 
-  @Test public void testEllipsize() {
+  @Test
+  public void testEllipsize() {
     TextPaint p = new TextPaint();
     assertThat(TextUtils.ellipsize("apples", p, 0, TextUtils.TruncateAt.END).toString())
         .isEqualTo("");
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTextViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTextViewTest.java
index 5d8234b87..752ea8cdf 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTextViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTextViewTest.java
@@ -92,10 +92,8 @@ public class ShadowTextViewTest {
     textView.setAutoLinkMask(Linkify.ALL);
     textView.setText("here's some text http://google.com/\nblah\thttp://another.com/123?456 blah");
 
-    assertThat(urlStringsFrom(textView.getUrls())).isEqualTo(asList(
-            "http://google.com",
-            "http://another.com/123?456"
-    ));
+    assertThat(urlStringsFrom(textView.getUrls()))
+        .isEqualTo(asList("http://google.com", "http://another.com/123?456"));
   }
 
   @Test
@@ -130,7 +128,8 @@ public class ShadowTextViewTest {
     textView.setTextAppearance(
         ApplicationProvider.getApplicationContext(), android.R.style.TextAppearance_Small);
 
-    assertThat(shadowOf(textView).getTextAppearanceId()).isEqualTo(android.R.style.TextAppearance_Small);
+    assertThat(shadowOf(textView).getTextAppearanceId())
+        .isEqualTo(android.R.style.TextAppearance_Small);
   }
 
   @Test
@@ -144,11 +143,13 @@ public class ShadowTextViewTest {
 
     TextView white = activity.findViewById(R.id.white_text_view);
     assertThat(white.getText().toString()).isEqualTo("White Text");
-    assertThat(white.getCurrentTextColor()).isEqualTo(activity.getResources().getColor(android.R.color.white));
+    assertThat(white.getCurrentTextColor())
+        .isEqualTo(activity.getResources().getColor(android.R.color.white));
 
     TextView grey = activity.findViewById(R.id.grey_text_view);
     assertThat(grey.getText().toString()).isEqualTo("Grey Text");
-    assertThat(grey.getCurrentTextColor()).isEqualTo(activity.getResources().getColor(R.color.grey42));
+    assertThat(grey.getCurrentTextColor())
+        .isEqualTo(activity.getResources().getColor(R.color.grey42));
   }
 
   @Test
@@ -162,11 +163,13 @@ public class ShadowTextViewTest {
 
     TextView white = activity.findViewById(R.id.white_text_view_hint);
     assertThat(white.getHint().toString()).isEqualTo("White Hint");
-    assertThat(white.getCurrentHintTextColor()).isEqualTo(activity.getResources().getColor(android.R.color.white));
+    assertThat(white.getCurrentHintTextColor())
+        .isEqualTo(activity.getResources().getColor(android.R.color.white));
 
     TextView grey = activity.findViewById(R.id.grey_text_view_hint);
     assertThat(grey.getHint().toString()).isEqualTo("Grey Hint");
-    assertThat(grey.getCurrentHintTextColor()).isEqualTo(activity.getResources().getColor(R.color.grey42));
+    assertThat(grey.getCurrentHintTextColor())
+        .isEqualTo(activity.getResources().getColor(R.color.grey42));
   }
 
   @Test
@@ -182,13 +185,16 @@ public class ShadowTextViewTest {
 
   @Test
   public void testGetInputType() {
-    assertThat(textView.getInputType()).isNotEqualTo(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
+    assertThat(textView.getInputType())
+        .isNotEqualTo(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
     textView.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
-    assertThat(textView.getInputType()).isEqualTo(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
+    assertThat(textView.getInputType())
+        .isEqualTo(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
   }
 
   @Test
-  public void givenATextViewWithATextWatcherAdded_WhenSettingTextWithTextResourceId_ShouldNotifyTextWatcher() {
+  public void
+      givenATextViewWithATextWatcherAdded_WhenSettingTextWithTextResourceId_ShouldNotifyTextWatcher() {
     MockTextWatcher mockTextWatcher = new MockTextWatcher();
     textView.addTextChangedListener(mockTextWatcher);
 
@@ -198,7 +204,8 @@ public class ShadowTextViewTest {
   }
 
   @Test
-  public void givenATextViewWithATextWatcherAdded_WhenSettingTextWithCharSequence_ShouldNotifyTextWatcher() {
+  public void
+      givenATextViewWithATextWatcherAdded_WhenSettingTextWithCharSequence_ShouldNotifyTextWatcher() {
     MockTextWatcher mockTextWatcher = new MockTextWatcher();
     textView.addTextChangedListener(mockTextWatcher);
 
@@ -218,7 +225,8 @@ public class ShadowTextViewTest {
   }
 
   @Test
-  public void givenATextViewWithMultipleTextWatchersAdded_WhenSettingText_ShouldNotifyEachTextWatcher() {
+  public void
+      givenATextViewWithMultipleTextWatchersAdded_WhenSettingText_ShouldNotifyEachTextWatcher() {
     List<MockTextWatcher> mockTextWatchers = anyNumberOfTextWatchers();
     for (MockTextWatcher textWatcher : mockTextWatchers) {
       textView.addTextChangedListener(textWatcher);
@@ -239,7 +247,8 @@ public class ShadowTextViewTest {
 
     textView.setText(NEW_TEXT);
 
-    verify(mockTextWatcher).beforeTextChanged(INITIAL_TEXT, 0, INITIAL_TEXT.length(), NEW_TEXT.length());
+    verify(mockTextWatcher)
+        .beforeTextChanged(INITIAL_TEXT, 0, INITIAL_TEXT.length(), NEW_TEXT.length());
   }
 
   @Test
@@ -250,8 +259,11 @@ public class ShadowTextViewTest {
 
     textView.setText(NEW_TEXT);
 
-    ArgumentCaptor<SpannableStringBuilder> builderCaptor = ArgumentCaptor.forClass(SpannableStringBuilder.class);
-    verify(mockTextWatcher).onTextChanged(builderCaptor.capture(), eq(0), eq(INITIAL_TEXT.length()), eq(NEW_TEXT.length()));
+    ArgumentCaptor<SpannableStringBuilder> builderCaptor =
+        ArgumentCaptor.forClass(SpannableStringBuilder.class);
+    verify(mockTextWatcher)
+        .onTextChanged(
+            builderCaptor.capture(), eq(0), eq(INITIAL_TEXT.length()), eq(NEW_TEXT.length()));
     assertThat(builderCaptor.getValue().toString()).isEqualTo(NEW_TEXT);
   }
 
@@ -281,7 +293,9 @@ public class ShadowTextViewTest {
 
     textView.append(NEW_TEXT);
 
-    verify(mockTextWatcher).beforeTextChanged(eq(INITIAL_TEXT), eq(0), eq(INITIAL_TEXT.length()), eq(INITIAL_TEXT.length()));
+    verify(mockTextWatcher)
+        .beforeTextChanged(
+            eq(INITIAL_TEXT), eq(0), eq(INITIAL_TEXT.length()), eq(INITIAL_TEXT.length()));
   }
 
   @Test
@@ -292,8 +306,11 @@ public class ShadowTextViewTest {
 
     textView.append(NEW_TEXT);
 
-    ArgumentCaptor<SpannableStringBuilder> builderCaptor = ArgumentCaptor.forClass(SpannableStringBuilder.class);
-    verify(mockTextWatcher).onTextChanged(builderCaptor.capture(), eq(0), eq(INITIAL_TEXT.length()), eq(INITIAL_TEXT.length()));
+    ArgumentCaptor<SpannableStringBuilder> builderCaptor =
+        ArgumentCaptor.forClass(SpannableStringBuilder.class);
+    verify(mockTextWatcher)
+        .onTextChanged(
+            builderCaptor.capture(), eq(0), eq(INITIAL_TEXT.length()), eq(INITIAL_TEXT.length()));
     assertThat(builderCaptor.getValue().toString()).isEqualTo(INITIAL_TEXT + NEW_TEXT);
   }
 
@@ -305,7 +322,8 @@ public class ShadowTextViewTest {
 
     textView.append(NEW_TEXT);
 
-    assertThat(mockTextWatcher.afterTextChangeArgument.toString()).isEqualTo(INITIAL_TEXT + NEW_TEXT);
+    assertThat(mockTextWatcher.afterTextChangeArgument.toString())
+        .isEqualTo(INITIAL_TEXT + NEW_TEXT);
   }
 
   @Test
@@ -349,12 +367,22 @@ public class ShadowTextViewTest {
   @Test
   public void
       testSetCompountDrawablesWithIntrinsicBounds_int_shouldCreateDrawablesWithResourceIds() {
-    textView.setCompoundDrawablesWithIntrinsicBounds(R.drawable.an_image, R.drawable.an_other_image, R.drawable.third_image, R.drawable.fourth_image);
+    textView.setCompoundDrawablesWithIntrinsicBounds(
+        R.drawable.an_image,
+        R.drawable.an_other_image,
+        R.drawable.third_image,
+        R.drawable.fourth_image);
 
-    assertEquals(R.drawable.an_image, shadowOf(textView.getCompoundDrawables()[0]).getCreatedFromResId());
-    assertEquals(R.drawable.an_other_image, shadowOf(textView.getCompoundDrawables()[1]).getCreatedFromResId());
-    assertEquals(R.drawable.third_image, shadowOf(textView.getCompoundDrawables()[2]).getCreatedFromResId());
-    assertEquals(R.drawable.fourth_image, shadowOf(textView.getCompoundDrawables()[3]).getCreatedFromResId());
+    assertEquals(
+        R.drawable.an_image, shadowOf(textView.getCompoundDrawables()[0]).getCreatedFromResId());
+    assertEquals(
+        R.drawable.an_other_image,
+        shadowOf(textView.getCompoundDrawables()[1]).getCreatedFromResId());
+    assertEquals(
+        R.drawable.third_image, shadowOf(textView.getCompoundDrawables()[2]).getCreatedFromResId());
+    assertEquals(
+        R.drawable.fourth_image,
+        shadowOf(textView.getCompoundDrawables()[3]).getCreatedFromResId());
   }
 
   @Test
@@ -397,7 +425,7 @@ public class ShadowTextViewTest {
 
   @Test
   public void canSetAndGetInputFilters() {
-    final InputFilter[] expectedFilters = new InputFilter[]{new InputFilter.LengthFilter(1)};
+    final InputFilter[] expectedFilters = new InputFilter[] {new InputFilter.LengthFilter(1)};
     textView.setFilters(expectedFilters);
     assertThat(textView.getFilters()).isSameInstanceAs(expectedFilters);
   }
@@ -422,7 +450,8 @@ public class ShadowTextViewTest {
 
     textView.setText(null);
 
-    ArgumentCaptor<SpannableStringBuilder> builderCaptor = ArgumentCaptor.forClass(SpannableStringBuilder.class);
+    ArgumentCaptor<SpannableStringBuilder> builderCaptor =
+        ArgumentCaptor.forClass(SpannableStringBuilder.class);
     verify(mockTextWatcher).onTextChanged(builderCaptor.capture(), eq(0), eq(0), eq(0));
     assertThat(builderCaptor.getValue().toString()).isEmpty();
   }
@@ -476,11 +505,16 @@ public class ShadowTextViewTest {
 
   @Test
   public void setCompoundDrawablesWithIntrinsicBounds_setsValues() {
-    textView.setCompoundDrawablesWithIntrinsicBounds(R.drawable.l0_red, R.drawable.l1_orange, R.drawable.l2_yellow, R.drawable.l3_green);
-    assertThat(shadowOf(textView).getCompoundDrawablesWithIntrinsicBoundsLeft()).isEqualTo(R.drawable.l0_red);
-    assertThat(shadowOf(textView).getCompoundDrawablesWithIntrinsicBoundsTop()).isEqualTo(R.drawable.l1_orange);
-    assertThat(shadowOf(textView).getCompoundDrawablesWithIntrinsicBoundsRight()).isEqualTo(R.drawable.l2_yellow);
-    assertThat(shadowOf(textView).getCompoundDrawablesWithIntrinsicBoundsBottom()).isEqualTo(R.drawable.l3_green);
+    textView.setCompoundDrawablesWithIntrinsicBounds(
+        R.drawable.l0_red, R.drawable.l1_orange, R.drawable.l2_yellow, R.drawable.l3_green);
+    assertThat(shadowOf(textView).getCompoundDrawablesWithIntrinsicBoundsLeft())
+        .isEqualTo(R.drawable.l0_red);
+    assertThat(shadowOf(textView).getCompoundDrawablesWithIntrinsicBoundsTop())
+        .isEqualTo(R.drawable.l1_orange);
+    assertThat(shadowOf(textView).getCompoundDrawablesWithIntrinsicBoundsRight())
+        .isEqualTo(R.drawable.l2_yellow);
+    assertThat(shadowOf(textView).getCompoundDrawablesWithIntrinsicBoundsBottom())
+        .isEqualTo(R.drawable.l3_green);
   }
 
   private List<MockTextWatcher> anyNumberOfTextWatchers() {
@@ -493,11 +527,9 @@ public class ShadowTextViewTest {
   }
 
   private void assertEachTextWatcherEventWasInvoked(MockTextWatcher mockTextWatcher) {
-    assertTrue("Expected each TextWatcher event to"
-                   + " have"
-                   + " been"
-                   + " invoked"
-                   + " once", mockTextWatcher.methodsCalled.size() == 3);
+    assertTrue(
+        "Expected each TextWatcher event to" + " have" + " been" + " invoked" + " once",
+        mockTextWatcher.methodsCalled.size() == 3);
 
     assertThat(mockTextWatcher.methodsCalled.get(0)).isEqualTo("beforeTextChanged");
     assertThat(mockTextWatcher.methodsCalled.get(1)).isEqualTo("onTextChanged");
@@ -544,7 +576,6 @@ public class ShadowTextViewTest {
       methodsCalled.add("afterTextChanged");
       afterTextChangeArgument = s;
     }
-
   }
 
   private static class TestMovementMethod implements MovementMethod {
@@ -569,8 +600,7 @@ public class ShadowTextViewTest {
     }
 
     @Override
-    public void onTakeFocus(TextView widget, Spannable text, int direction) {
-    }
+    public void onTakeFocus(TextView widget, Spannable text, int direction) {}
 
     @Override
     public boolean onTrackballEvent(TextView widget, Spannable text, MotionEvent event) {
@@ -589,8 +619,7 @@ public class ShadowTextViewTest {
     }
 
     @Override
-    public boolean onGenericMotionEvent(TextView widget, Spannable text,
-                                        MotionEvent event) {
+    public boolean onGenericMotionEvent(TextView widget, Spannable text, MotionEvent event) {
       return false;
     }
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowThemeTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowThemeTest.java
index 7c7047d66..0c146d724 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowThemeTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowThemeTest.java
@@ -137,13 +137,13 @@ public class ShadowThemeTest {
   public void setTo_shouldCopyAllAttributesToEmptyTheme() {
     Resources.Theme theme1 = resources.newTheme();
     theme1.applyStyle(R.style.Theme_Robolectric, false);
-    assertThat(theme1.obtainStyledAttributes(new int[]{R.attr.string1}).getString(0))
+    assertThat(theme1.obtainStyledAttributes(new int[] {R.attr.string1}).getString(0))
         .isEqualTo("string 1 from Theme.Robolectric");
 
     Resources.Theme theme2 = resources.newTheme();
     theme2.setTo(theme1);
 
-    assertThat(theme2.obtainStyledAttributes(new int[]{R.attr.string1}).getString(0))
+    assertThat(theme2.obtainStyledAttributes(new int[] {R.attr.string1}).getString(0))
         .isEqualTo("string 1 from Theme.Robolectric");
   }
 
@@ -156,9 +156,9 @@ public class ShadowThemeTest {
     destTheme.setTo(sourceTheme);
     destTheme.applyStyle(R.style.StyleB, true);
 
-    assertThat(destTheme.obtainStyledAttributes(new int[]{R.attr.string1}).getString(0))
+    assertThat(destTheme.obtainStyledAttributes(new int[] {R.attr.string1}).getString(0))
         .isEqualTo("string 1 from style B");
-    assertThat(sourceTheme.obtainStyledAttributes(new int[]{R.attr.string1}).getString(0))
+    assertThat(sourceTheme.obtainStyledAttributes(new int[] {R.attr.string1}).getString(0))
         .isEqualTo("string 1 from style A");
   }
 
@@ -171,9 +171,9 @@ public class ShadowThemeTest {
     destTheme.setTo(sourceTheme);
     sourceTheme.applyStyle(R.style.StyleB, true);
 
-    assertThat(destTheme.obtainStyledAttributes(new int[]{R.attr.string1}).getString(0))
+    assertThat(destTheme.obtainStyledAttributes(new int[] {R.attr.string1}).getString(0))
         .isEqualTo("string 1 from style A");
-    assertThat(sourceTheme.obtainStyledAttributes(new int[]{R.attr.string1}).getString(0))
+    assertThat(sourceTheme.obtainStyledAttributes(new int[] {R.attr.string1}).getString(0))
         .isEqualTo("string 1 from style B");
   }
 
@@ -181,11 +181,11 @@ public class ShadowThemeTest {
   public void applyStyle_withForceFalse_shouldApplyButNotOverwriteExistingAttributeValues() {
     Resources.Theme theme = resources.newTheme();
     theme.applyStyle(R.style.StyleA, false);
-    assertThat(theme.obtainStyledAttributes(new int[]{R.attr.string1}).getString(0))
+    assertThat(theme.obtainStyledAttributes(new int[] {R.attr.string1}).getString(0))
         .isEqualTo("string 1 from style A");
 
     theme.applyStyle(R.style.StyleB, false);
-    assertThat(theme.obtainStyledAttributes(new int[]{R.attr.string1}).getString(0))
+    assertThat(theme.obtainStyledAttributes(new int[] {R.attr.string1}).getString(0))
         .isEqualTo("string 1 from style A");
   }
 
@@ -193,11 +193,11 @@ public class ShadowThemeTest {
   public void applyStyle_withForceTrue_shouldApplyAndOverwriteExistingAttributeValues() {
     Resources.Theme theme = resources.newTheme();
     theme.applyStyle(R.style.StyleA, false);
-    assertThat(theme.obtainStyledAttributes(new int[]{R.attr.string1}).getString(0))
+    assertThat(theme.obtainStyledAttributes(new int[] {R.attr.string1}).getString(0))
         .isEqualTo("string 1 from style A");
 
     theme.applyStyle(R.style.StyleB, true);
-    assertThat(theme.obtainStyledAttributes(new int[]{R.attr.string1}).getString(0))
+    assertThat(theme.obtainStyledAttributes(new int[] {R.attr.string1}).getString(0))
         .isEqualTo("string 1 from style B");
   }
 
@@ -207,29 +207,48 @@ public class ShadowThemeTest {
     theme.applyStyle(R.style.Theme_Robolectric, false);
     theme.applyStyle(R.style.Theme_ThemeContainingStyleReferences, true);
 
-    assertThat(theme.obtainStyledAttributes(
-        Robolectric.buildAttributeSet().setStyleAttribute("?attr/styleReference").build(),
-        new int[]{R.attr.string2}, 0, 0).getString(0))
+    assertThat(
+            theme
+                .obtainStyledAttributes(
+                    Robolectric.buildAttributeSet()
+                        .setStyleAttribute("?attr/styleReference")
+                        .build(),
+                    new int[] {R.attr.string2},
+                    0,
+                    0)
+                .getString(0))
         .isEqualTo("string 2 from YetAnotherStyle");
 
-    assertThat(theme.obtainStyledAttributes(
-        Robolectric.buildAttributeSet().setStyleAttribute("?styleReference").build(),
-        new int[]{R.attr.string2}, 0, 0).getString(0))
+    assertThat(
+            theme
+                .obtainStyledAttributes(
+                    Robolectric.buildAttributeSet().setStyleAttribute("?styleReference").build(),
+                    new int[] {R.attr.string2},
+                    0,
+                    0)
+                .getString(0))
         .isEqualTo("string 2 from YetAnotherStyle");
   }
 
   @Test
-  public void xml_whenStyleSpecifiesAttr_obtainStyledAttribute_findsCorrectValue() throws Exception {
+  public void xml_whenStyleSpecifiesAttr_obtainStyledAttribute_findsCorrectValue()
+      throws Exception {
     Resources.Theme theme = resources.newTheme();
     theme.applyStyle(R.style.Theme_Robolectric, false);
     theme.applyStyle(R.style.Theme_ThemeContainingStyleReferences, true);
 
-    assertThat(theme.obtainStyledAttributes(getFirstElementAttrSet(R.xml.temp),
-        new int[]{R.attr.string2}, 0, 0).getString(0))
+    assertThat(
+            theme
+                .obtainStyledAttributes(
+                    getFirstElementAttrSet(R.xml.temp), new int[] {R.attr.string2}, 0, 0)
+                .getString(0))
         .isEqualTo("string 2 from YetAnotherStyle");
 
-    assertThat(theme.obtainStyledAttributes(getFirstElementAttrSet(R.xml.temp_parent),
-        new int[]{R.attr.string2}, 0, 0).getString(0))
+    assertThat(
+            theme
+                .obtainStyledAttributes(
+                    getFirstElementAttrSet(R.xml.temp_parent), new int[] {R.attr.string2}, 0, 0)
+                .getString(0))
         .isEqualTo("string 2 from YetAnotherStyle");
   }
 
@@ -239,36 +258,50 @@ public class ShadowThemeTest {
     theme.applyStyle(R.style.Theme_Robolectric, false);
     theme.applyStyle(R.style.Theme_ThemeContainingStyleReferences, true);
 
-    assertThat(theme.obtainStyledAttributes(
-        Robolectric.buildAttributeSet().addAttribute(R.attr.string2, "?attr/string1").build(),
-        new int[]{R.attr.string2}, 0, 0).getString(0))
+    assertThat(
+            theme
+                .obtainStyledAttributes(
+                    Robolectric.buildAttributeSet()
+                        .addAttribute(R.attr.string2, "?attr/string1")
+                        .build(),
+                    new int[] {R.attr.string2},
+                    0,
+                    0)
+                .getString(0))
         .isEqualTo("string 1 from Theme.Robolectric");
   }
 
   @Test
   public void dimenRef() {
-    AttributeSet attributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(android.R.attr.layout_height, "@dimen/test_px_dimen")
-        .build();
-    TypedArray typedArray = resources.newTheme().obtainStyledAttributes(
-        attributeSet, new int[]{android.R.attr.layout_height}, 0, 0);
+    AttributeSet attributeSet =
+        Robolectric.buildAttributeSet()
+            .addAttribute(android.R.attr.layout_height, "@dimen/test_px_dimen")
+            .build();
+    TypedArray typedArray =
+        resources
+            .newTheme()
+            .obtainStyledAttributes(attributeSet, new int[] {android.R.attr.layout_height}, 0, 0);
     assertThat(typedArray.getDimensionPixelSize(0, -1)).isEqualTo(15);
   }
 
   @Test
   public void dimenRefRef() {
-    AttributeSet attributeSet = Robolectric.buildAttributeSet()
-        .addAttribute(android.R.attr.layout_height, "@dimen/ref_to_px_dimen")
-        .build();
-    TypedArray typedArray = resources.newTheme().obtainStyledAttributes(
-        attributeSet, new int[]{android.R.attr.layout_height}, 0, 0);
+    AttributeSet attributeSet =
+        Robolectric.buildAttributeSet()
+            .addAttribute(android.R.attr.layout_height, "@dimen/ref_to_px_dimen")
+            .build();
+    TypedArray typedArray =
+        resources
+            .newTheme()
+            .obtainStyledAttributes(attributeSet, new int[] {android.R.attr.layout_height}, 0, 0);
     assertThat(typedArray.getDimensionPixelSize(0, -1)).isEqualTo(15);
   }
 
   @Test
   public void obtainStyledAttributes_shouldFindAttributeInDefaultStyle() {
     Theme theme = resources.newTheme();
-    TypedArray typedArray = theme.obtainStyledAttributes(R.style.StyleA, new int[]{R.attr.string1});
+    TypedArray typedArray =
+        theme.obtainStyledAttributes(R.style.StyleA, new int[] {R.attr.string1});
     assertThat(typedArray.getString(0)).isEqualTo("string 1 from style A");
   }
 
@@ -289,11 +322,11 @@ public class ShadowThemeTest {
     return (XmlResourceParser) Xml.asAttributeSet(xml);
   }
 
-  public static class TestActivityWithAnotherTheme extends TestActivity {
-  }
+  public static class TestActivityWithAnotherTheme extends TestActivity {}
 
   public static class TestWithStyleAttrActivity extends Activity {
-    @Override protected void onCreate(Bundle savedInstanceState) {
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
       super.onCreate(savedInstanceState);
       setContentView(R.layout.styles_button_with_style_layout);
     }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTouchDelegateTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTouchDelegateTest.java
index 5d92a3fe4..ab0904b40 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTouchDelegateTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTouchDelegateTest.java
@@ -49,17 +49,16 @@ public class ShadowTouchDelegateTest {
     Rect rect = new Rect(100, 5000, 200, 6000);
     TouchDelegate td =
         Shadow.newInstance(
-            TouchDelegate.class,
-            new Class[] { Rect.class, View.class },
-            new Object[] {rect, view});
+            TouchDelegate.class, new Class[] {Rect.class, View.class}, new Object[] {rect, view});
     // Make the underlying view clickable. This ensures that if a touch event does get delegated, it
     // gets reported as having been handled.
     view.setClickable(true);
 
     // Verify that a touch event in the center of the rectangle is handled.
     assertThat(
-        td.onTouchEvent(
-            MotionEvent.obtain(1, 1, MotionEvent.ACTION_DOWN, rect.centerX(), rect.centerY(), 0)))
+            td.onTouchEvent(
+                MotionEvent.obtain(
+                    1, 1, MotionEvent.ACTION_DOWN, rect.centerX(), rect.centerY(), 0)))
         .isTrue();
     // Verify that a touch event outside of the rectangle is not handled.
     assertThat(td.onTouchEvent(MotionEvent.obtain(1, 1, MotionEvent.ACTION_DOWN, 5f, 10f, 0)))
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTypedArrayTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTypedArrayTest.java
index 3b0d8d069..bc47297bd 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTypedArrayTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTypedArrayTest.java
@@ -26,94 +26,102 @@ public class ShadowTypedArrayTest {
 
   @Test
   public void getResources() {
-    assertNotNull(context.obtainStyledAttributes(new int[]{}).getResources());
+    assertNotNull(context.obtainStyledAttributes(new int[] {}).getResources());
   }
 
   @Test
   public void getInt_shouldReturnDefaultValue() {
-    assertThat(context.obtainStyledAttributes(new int[]{android.R.attr.alpha}).getInt(0, -1)).isEqualTo(-1);
+    assertThat(context.obtainStyledAttributes(new int[] {android.R.attr.alpha}).getInt(0, -1))
+        .isEqualTo(-1);
   }
 
   @Test
   public void getInteger_shouldReturnDefaultValue() {
-    assertThat(context.obtainStyledAttributes(new int[]{android.R.attr.alpha}).getInteger(0, -1)).isEqualTo(-1);
+    assertThat(context.obtainStyledAttributes(new int[] {android.R.attr.alpha}).getInteger(0, -1))
+        .isEqualTo(-1);
   }
 
   @Test
   public void getInt_withFlags_shouldReturnValue() {
-    TypedArray typedArray = context.obtainStyledAttributes(
-        Robolectric.buildAttributeSet()
-            .addAttribute(android.R.attr.gravity, "top|left")
-            .build(),
-        new int[]{android.R.attr.gravity});
+    TypedArray typedArray =
+        context.obtainStyledAttributes(
+            Robolectric.buildAttributeSet()
+                .addAttribute(android.R.attr.gravity, "top|left")
+                .build(),
+            new int[] {android.R.attr.gravity});
     assertThat(typedArray.getInt(0, -1)).isEqualTo(0x33);
   }
 
   @Test
   public void getResourceId_shouldReturnDefaultValue() {
-    assertThat(context.obtainStyledAttributes(new int[]{android.R.attr.alpha}).getResourceId(0, -1)).isEqualTo(-1);
+    assertThat(
+            context.obtainStyledAttributes(new int[] {android.R.attr.alpha}).getResourceId(0, -1))
+        .isEqualTo(-1);
   }
 
   @Test
   public void getResourceId_shouldReturnActualValue() {
-    TypedArray typedArray = context.obtainStyledAttributes(
-        Robolectric.buildAttributeSet()
-            .addAttribute(android.R.attr.id, "@+id/snippet_text")
-            .build(),
-        new int[]{android.R.attr.id});
+    TypedArray typedArray =
+        context.obtainStyledAttributes(
+            Robolectric.buildAttributeSet()
+                .addAttribute(android.R.attr.id, "@+id/snippet_text")
+                .build(),
+            new int[] {android.R.attr.id});
     assertThat(typedArray.getResourceId(0, -1)).isEqualTo(R.id.snippet_text);
   }
 
   @Test
   public void getFraction_shouldReturnDefaultValue() {
-    assertThat(context.obtainStyledAttributes(new int[]{android.R.attr.width}).getDimension(0, -1f))
+    assertThat(
+            context.obtainStyledAttributes(new int[] {android.R.attr.width}).getDimension(0, -1f))
         .isEqualTo(-1f);
   }
 
   @Test
   public void getFraction_shouldReturnGivenValue() {
-    TypedArray typedArray = context.obtainStyledAttributes(
-        Robolectric.buildAttributeSet()
-            .addAttribute(android.R.attr.width, "50%")
-            .build(),
-        new int[]{android.R.attr.width});
-    assertThat(typedArray.getFraction(0, 100, 1, -1))
-        .isEqualTo(50f);
+    TypedArray typedArray =
+        context.obtainStyledAttributes(
+            Robolectric.buildAttributeSet().addAttribute(android.R.attr.width, "50%").build(),
+            new int[] {android.R.attr.width});
+    assertThat(typedArray.getFraction(0, 100, 1, -1)).isEqualTo(50f);
   }
 
   @Test
   public void getDimension_shouldReturnDefaultValue() {
-    assertThat(context.obtainStyledAttributes(new int[]{android.R.attr.width}).getDimension(0, -1f)).isEqualTo(-1f);
+    assertThat(
+            context.obtainStyledAttributes(new int[] {android.R.attr.width}).getDimension(0, -1f))
+        .isEqualTo(-1f);
   }
 
   @Test
   public void getDimension_shouldReturnGivenValue() {
-    TypedArray typedArray = context.obtainStyledAttributes(
-        Robolectric.buildAttributeSet()
-            .addAttribute(android.R.attr.width, "50dp")
-            .build(),
-        new int[]{android.R.attr.width});
+    TypedArray typedArray =
+        context.obtainStyledAttributes(
+            Robolectric.buildAttributeSet().addAttribute(android.R.attr.width, "50dp").build(),
+            new int[] {android.R.attr.width});
     assertThat(typedArray.getDimension(0, -1)).isEqualTo(50f);
   }
 
   @Test
   public void getDrawable_withExplicitColorValue_shouldReturnColorDrawable() {
-    TypedArray typedArray = context.obtainStyledAttributes(
-        Robolectric.buildAttributeSet()
-            .addAttribute(android.R.attr.background, "#ff777777")
-            .build(),
-        new int[]{android.R.attr.background});
+    TypedArray typedArray =
+        context.obtainStyledAttributes(
+            Robolectric.buildAttributeSet()
+                .addAttribute(android.R.attr.background, "#ff777777")
+                .build(),
+            new int[] {android.R.attr.background});
     ColorDrawable drawable = (ColorDrawable) typedArray.getDrawable(0);
     assertThat(drawable.getColor()).isEqualTo(0xff777777);
   }
 
   @Test
   public void getTextArray_whenNoSuchAttribute_shouldReturnNull() {
-    TypedArray typedArray = context.obtainStyledAttributes(
-        Robolectric.buildAttributeSet()
-            .addAttribute(android.R.attr.keycode, "@array/greetings")
-            .build(),
-        new int[]{android.R.attr.absListViewStyle});
+    TypedArray typedArray =
+        context.obtainStyledAttributes(
+            Robolectric.buildAttributeSet()
+                .addAttribute(android.R.attr.keycode, "@array/greetings")
+                .build(),
+            new int[] {android.R.attr.absListViewStyle});
     CharSequence[] textArray = typedArray.getTextArray(0);
     assertThat(textArray).isInstanceOf(CharSequence[].class);
     for (CharSequence text : textArray) {
@@ -123,50 +131,52 @@ public class ShadowTypedArrayTest {
 
   @Test
   public void getTextArray_shouldReturnValues() {
-    TypedArray typedArray = context.obtainStyledAttributes(
-        Robolectric.buildAttributeSet()
-            .addAttribute(R.attr.responses, "@array/greetings")
-            .build(),
-        new int[]{R.attr.responses});
+    TypedArray typedArray =
+        context.obtainStyledAttributes(
+            Robolectric.buildAttributeSet()
+                .addAttribute(R.attr.responses, "@array/greetings")
+                .build(),
+            new int[] {R.attr.responses});
     assertThat(typedArray.getTextArray(0)).asList().containsExactly("hola", "Hello");
   }
 
   @Test
   public void hasValue_withValue() {
-    TypedArray typedArray = context.obtainStyledAttributes(
-        Robolectric.buildAttributeSet()
-            .addAttribute(R.attr.responses, "@array/greetings")
-            .build(),
-        new int[]{R.attr.responses});
+    TypedArray typedArray =
+        context.obtainStyledAttributes(
+            Robolectric.buildAttributeSet()
+                .addAttribute(R.attr.responses, "@array/greetings")
+                .build(),
+            new int[] {R.attr.responses});
     assertThat(typedArray.hasValue(0)).isTrue();
   }
 
   @Test
   public void hasValue_withoutValue() {
-    TypedArray typedArray = context.obtainStyledAttributes(
-        null,
-        new int[]{R.attr.responses});
+    TypedArray typedArray = context.obtainStyledAttributes(null, new int[] {R.attr.responses});
     assertThat(typedArray.hasValue(0)).isFalse();
   }
 
   @Test
   public void hasValue_withNullValue() {
-    TypedArray typedArray = context.obtainStyledAttributes(
-        Robolectric.buildAttributeSet()
-            .addAttribute(R.attr.responses, AttributeResource.NULL_VALUE)
-            .build(),
-        new int[]{R.attr.responses});
+    TypedArray typedArray =
+        context.obtainStyledAttributes(
+            Robolectric.buildAttributeSet()
+                .addAttribute(R.attr.responses, AttributeResource.NULL_VALUE)
+                .build(),
+            new int[] {R.attr.responses});
     assertThat(typedArray.hasValue(0)).isFalse();
   }
 
   @Test
   public void shouldEnumeratePresentValues() {
-    TypedArray typedArray = context.obtainStyledAttributes(
-        Robolectric.buildAttributeSet()
-            .addAttribute(R.attr.responses, "@array/greetings")
-            .addAttribute(R.attr.aspectRatio, "1")
-            .build(),
-        new int[]{R.attr.scrollBars, R.attr.responses, R.attr.isSugary});
+    TypedArray typedArray =
+        context.obtainStyledAttributes(
+            Robolectric.buildAttributeSet()
+                .addAttribute(R.attr.responses, "@array/greetings")
+                .addAttribute(R.attr.aspectRatio, "1")
+                .build(),
+            new int[] {R.attr.scrollBars, R.attr.responses, R.attr.isSugary});
     assertThat(typedArray.getIndexCount()).isEqualTo(1);
     assertThat(typedArray.getIndex(0)).isEqualTo(1);
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUIModeManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUIModeManagerTest.java
index 72c5e52e7..11326af57 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUIModeManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUIModeManagerTest.java
@@ -12,7 +12,6 @@ import android.app.UiModeManager;
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.res.Configuration;
-import android.os.Build.VERSION_CODES;
 import android.provider.Settings;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
@@ -25,7 +24,6 @@ import org.robolectric.shadow.api.Shadow;
 
 /** */
 @RunWith(AndroidJUnit4.class)
-@Config(minSdk = VERSION_CODES.LOLLIPOP)
 public class ShadowUIModeManagerTest {
   private Context context;
   private UiModeManager uiModeManager;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUiAutomationTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUiAutomationTest.java
index eb9e124f7..afef6eed3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUiAutomationTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUiAutomationTest.java
@@ -39,6 +39,7 @@ public class ShadowUiAutomationTest {
         .isEqualTo(1);
     assertThat(Settings.Global.getFloat(cr, Settings.Global.WINDOW_ANIMATION_SCALE)).isEqualTo(1);
   }
+
   @Test
   public void setRotation_freeze90_rotatesToLandscape() {
     UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsageStatsManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsageStatsManagerTest.java
index bd4bdb6ba..6ecfd1e2e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsageStatsManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsageStatsManagerTest.java
@@ -340,7 +340,6 @@ public class ShadowUsageStatsManagerTest {
                 pendingIntent1));
   }
 
-
   @Test
   public void queryUsageStats_noStatsAdded() {
     List<UsageStats> results = usageStatsManager.queryUsageStats(INTERVAL_WEEKLY, 0, 3000);
@@ -510,7 +509,7 @@ public class ShadowUsageStatsManagerTest {
   @Test
   @Config(minSdk = Build.VERSION_CODES.Q)
   public void
-  testRegisterUsageSessionObserver_duplicateObserverIds_shouldOverrideExistingObserver() {
+      testRegisterUsageSessionObserver_duplicateObserverIds_shouldOverrideExistingObserver() {
     PendingIntent sessionStepIntent1 =
         PendingIntent.getBroadcast(context, 0, new Intent("SESSION_STEP_ACTION1"), 0);
     PendingIntent sessionEndedIntent1 =
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbManagerTest.java
index 3ea2fdeef..14fd8f692 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbManagerTest.java
@@ -145,7 +145,7 @@ public class ShadowUsbManagerTest {
             UsbPortStatus.MODE_DUAL,
             UsbPortStatus.POWER_ROLE_SINK,
             UsbPortStatus.DATA_ROLE_DEVICE,
-            /*statusSupportedRoleCombinations=*/ 0);
+            /* statusSupportedRoleCombinations= */ 0);
 
     UsbPortStatus portStatus = (UsbPortStatus) shadowOf(usbManager).getPortStatus("port3");
     assertThat(portStatus.getCurrentMode()).isEqualTo(UsbPortStatus.MODE_DUAL);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbRequestTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbRequestTest.java
index 6c57851e7..ab2e4c220 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbRequestTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbRequestTest.java
@@ -54,7 +54,7 @@ public class ShadowUsbRequestTest {
     when(usbConfiguration.getInterface(0)).thenReturn(usbInterface);
     when(usbConfiguration.getInterface(0)).thenReturn(usbInterface);
 
-    shadowOf(usbManager).addOrUpdateUsbDevice(usbDevice, /*hasPermission=*/ true);
+    shadowOf(usbManager).addOrUpdateUsbDevice(usbDevice, /* hasPermission= */ true);
   }
 
   @After
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUwbManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUwbManagerTest.java
index bbea33710..28605e0f1 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUwbManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUwbManagerTest.java
@@ -65,13 +65,34 @@ public class ShadowUwbManagerTest {
 
     Shadow.<ShadowUwbManager>extract(manager)
         .simulateAdapterStateChange(
-            AdapterStateCallback.STATE_CHANGED_REASON_SYSTEM_REGULATION,
-            AdapterStateCallback.STATE_DISABLED);
+            AdapterStateCallback.STATE_DISABLED,
+            AdapterStateCallback.STATE_CHANGED_REASON_SYSTEM_REGULATION);
 
     verify(adapterStateCallback)
         .onStateChanged(
-            AdapterStateCallback.STATE_CHANGED_REASON_SYSTEM_REGULATION,
-            AdapterStateCallback.STATE_DISABLED);
+            AdapterStateCallback.STATE_DISABLED,
+            AdapterStateCallback.STATE_CHANGED_REASON_SYSTEM_REGULATION);
+  }
+
+  @Test
+  public void getAdapterState_returnsStateFromSimulateAdapterStateChange() {
+    UwbManager manager = (UwbManager) uwbManagerObject;
+    AdapterStateCallback adapterStateCallback = (AdapterStateCallback) adapterStateCallbackObject;
+    manager.registerAdapterStateCallback(directExecutor(), adapterStateCallback);
+
+    Shadow.<ShadowUwbManager>extract(manager)
+        .simulateAdapterStateChange(
+            AdapterStateCallback.STATE_ENABLED_ACTIVE,
+            AdapterStateCallback.STATE_CHANGED_REASON_SYSTEM_REGULATION);
+
+    assertThat(manager.getAdapterState()).isEqualTo(AdapterStateCallback.STATE_ENABLED_ACTIVE);
+
+    Shadow.<ShadowUwbManager>extract(manager)
+        .simulateAdapterStateChange(
+            AdapterStateCallback.STATE_DISABLED,
+            AdapterStateCallback.STATE_CHANGED_REASON_SYSTEM_REGULATION);
+
+    assertThat(manager.getAdapterState()).isEqualTo(AdapterStateCallback.STATE_DISABLED);
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowVMRuntimeTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowVMRuntimeTest.java
new file mode 100644
index 000000000..8cc80b644
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowVMRuntimeTest.java
@@ -0,0 +1,43 @@
+package org.robolectric.shadows;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+
+import dalvik.system.VMRuntime;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.shadow.api.Shadow;
+
+@RunWith(RobolectricTestRunner.class)
+public final class ShadowVMRuntimeTest {
+  @Test
+  public void newNonMovableArray_floatArray() {
+    VMRuntime runtime = VMRuntime.getRuntime();
+    float[] result = (float[]) runtime.newNonMovableArray(float.class, 8);
+    assertThat(result).hasLength(8);
+    long address = runtime.addressOf(result);
+    assertThat(address).isNotEqualTo(0);
+    assertThat(address).isEqualTo(runtime.addressOf(result));
+    ShadowVMRuntime shadow = Shadow.extract(runtime);
+    assertThat(shadow.getObjectForAddress(address)).isSameInstanceAs(result);
+  }
+
+  @Test
+  public void addressOf_notArray() {
+    assertThrows(
+        IllegalArgumentException.class, () -> VMRuntime.getRuntime().addressOf(new Object()));
+  }
+
+  @Test
+  public void addressOf_notPrimitiveArray() {
+    assertThrows(
+        IllegalArgumentException.class, () -> VMRuntime.getRuntime().addressOf(new Object[0]));
+  }
+
+  @Test
+  public void addressOf_notNonMoveableArray() {
+    assertThrows(
+        IllegalArgumentException.class, () -> VMRuntime.getRuntime().addressOf(new float[0]));
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowVibratorTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowVibratorTest.java
index a83adc850..ff426934d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowVibratorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowVibratorTest.java
@@ -69,7 +69,7 @@ public class ShadowVibratorTest {
 
   @Test
   public void vibratePattern() {
-    long[] pattern = new long[] { 0, 200 };
+    long[] pattern = new long[] {0, 200};
     vibrator.vibrate(pattern, 1);
 
     assertThat(shadowOf(vibrator).isVibrating()).isTrue();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowVideoViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowVideoViewTest.java
index 8e16fbc1e..ccb4acf18 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowVideoViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowVideoViewTest.java
@@ -17,7 +17,8 @@ public class ShadowVideoViewTest {
 
   private VideoView view;
 
-  @Before public void setUp() throws Exception {
+  @Before
+  public void setUp() throws Exception {
     view = new VideoView(ApplicationProvider.getApplicationContext());
   }
 
@@ -149,7 +150,7 @@ public class ShadowVideoViewTest {
     public void onPrepared(MediaPlayer mp) {}
   }
 
-  private static class TestErrorListener implements MediaPlayer.OnErrorListener  {
+  private static class TestErrorListener implements MediaPlayer.OnErrorListener {
     @Override
     public boolean onError(MediaPlayer mp, int what, int extra) {
       return false;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewGroupTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewGroupTest.java
index ad74bb4fc..de7d531f7 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewGroupTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewGroupTest.java
@@ -85,19 +85,17 @@ public class ShadowViewGroupTest {
   public void testLayoutAnimationListener() {
     assertThat(root.getLayoutAnimationListener()).isNull();
 
-    AnimationListener animationListener = new AnimationListener() {
-      @Override
-      public void onAnimationEnd(Animation a) {
-      }
-
-      @Override
-      public void onAnimationRepeat(Animation a) {
-      }
-
-      @Override
-      public void onAnimationStart(Animation a) {
-      }
-    };
+    AnimationListener animationListener =
+        new AnimationListener() {
+          @Override
+          public void onAnimationEnd(Animation a) {}
+
+          @Override
+          public void onAnimationRepeat(Animation a) {}
+
+          @Override
+          public void onAnimationStart(Animation a) {}
+        };
     root.setLayoutAnimationListener(animationListener);
 
     assertThat(root.getLayoutAnimationListener()).isSameInstanceAs(animationListener);
@@ -277,22 +275,27 @@ public class ShadowViewGroupTest {
 
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     shadowOf(root).dump(new PrintStream(out), 0);
-    String expected = "<FrameLayout>\n" +
-        "  <View/>\n" +
-        "  <View/>\n" +
-        "  <FrameLayout id=\"org.robolectric:id/snippet_text\">\n" +
-        "    <View/>\n" +
-        "    <View visibility=\"GONE\"/>\n" +
-        "    <TextView visibility=\"INVISIBLE\" text=\"Here&#39;s some text!\"/>\n" +
-        "  </FrameLayout>\n" +
-        "</FrameLayout>\n";
+    String expected =
+        "<FrameLayout>\n"
+            + "  <View/>\n"
+            + "  <View/>\n"
+            + "  <FrameLayout id=\"org.robolectric:id/snippet_text\">\n"
+            + "    <View/>\n"
+            + "    <View visibility=\"GONE\"/>\n"
+            + "    <TextView visibility=\"INVISIBLE\" text=\"Here&#39;s some text!\"/>\n"
+            + "  </FrameLayout>\n"
+            + "</FrameLayout>\n";
     assertEquals(expected.replaceAll("\n", System.lineSeparator()), out.toString());
   }
 
   @Test
   public void addViewWithLayoutParams_shouldStoreLayoutParams() {
-    FrameLayout.LayoutParams layoutParams1 = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
-    FrameLayout.LayoutParams layoutParams2 = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
+    FrameLayout.LayoutParams layoutParams1 =
+        new FrameLayout.LayoutParams(
+            ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
+    FrameLayout.LayoutParams layoutParams2 =
+        new FrameLayout.LayoutParams(
+            ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
     View child1 = new View(ApplicationProvider.getApplicationContext());
     View child2 = new View(ApplicationProvider.getApplicationContext());
     root.addView(child1, layoutParams1);
@@ -301,26 +304,27 @@ public class ShadowViewGroupTest {
     assertSame(layoutParams2, child2.getLayoutParams());
   }
 
-//  todo: re-enable this
-//  @Test @Config(minSdk = FROYO)
-//  public void getChildAt_shouldThrowIndexOutOfBoundsForInvalidIndices() { // 'cause that's what Android does
-//    assertThat(root.getChildCount()).isEqualTo(3);
-//    assertThrowsExceptionForBadIndex(13);
-//    assertThrowsExceptionForBadIndex(3);
-//    assertThrowsExceptionForBadIndex(-1);
-//  }
-//
-//  private void assertThrowsExceptionForBadIndex(int index) {
-//    try {
-//      assertThat(root.getChildAt(index)).isNull();
-//      fail("no exception");
-//    } catch (IndexOutOfBoundsException ex) {
-//      //noinspection UnnecessaryReturnStatement
-//      return;
-//    } catch (Exception ex) {
-//      fail("wrong exception type");
-//    }
-//  }
+  //  todo: re-enable this
+  //  @Test @Config(minSdk = FROYO)
+  //  public void getChildAt_shouldThrowIndexOutOfBoundsForInvalidIndices() { // 'cause that's what
+  // Android does
+  //    assertThat(root.getChildCount()).isEqualTo(3);
+  //    assertThrowsExceptionForBadIndex(13);
+  //    assertThrowsExceptionForBadIndex(3);
+  //    assertThrowsExceptionForBadIndex(-1);
+  //  }
+  //
+  //  private void assertThrowsExceptionForBadIndex(int index) {
+  //    try {
+  //      assertThat(root.getChildAt(index)).isNull();
+  //      fail("no exception");
+  //    } catch (IndexOutOfBoundsException ex) {
+  //      //noinspection UnnecessaryReturnStatement
+  //      return;
+  //    } catch (Exception ex) {
+  //      fail("wrong exception type");
+  //    }
+  //  }
 
   @Test
   public void layoutParams_shouldBeViewGroupLayoutParams() {
@@ -512,8 +516,7 @@ public class ShadowViewGroupTest {
     boolean wasCalled = false;
 
     @Override
-    public void onChildViewAdded(View parent, View child) {
-    }
+    public void onChildViewAdded(View parent, View child) {}
 
     @Override
     public void onChildViewRemoved(View parent, View child) {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewTest.java
index 9b6c2bc22..3949aff92 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewTest.java
@@ -143,12 +143,13 @@ public class ShadowViewTest {
   public void shouldFocus() throws Exception {
     final List<String> transcript = new ArrayList<>();
 
-    view.setOnFocusChangeListener(new View.OnFocusChangeListener() {
-      @Override
-      public void onFocusChange(View v, boolean hasFocus) {
-        transcript.add(hasFocus ? "Gained focus" : "Lost focus");
-      }
-    });
+    view.setOnFocusChangeListener(
+        new View.OnFocusChangeListener() {
+          @Override
+          public void onFocusChange(View v, boolean hasFocus) {
+            transcript.add(hasFocus ? "Gained focus" : "Lost focus");
+          }
+        });
 
     assertFalse(view.isFocused());
     assertFalse(view.hasFocus());
@@ -356,10 +357,8 @@ public class ShadowViewTest {
 
   @Test
   public void shouldAddOnClickListenerFromAttribute() throws Exception {
-    AttributeSet attrs = Robolectric.buildAttributeSet()
-        .addAttribute(android.R.attr.onClick, "clickMe")
-        .build()
-        ;
+    AttributeSet attrs =
+        Robolectric.buildAttributeSet().addAttribute(android.R.attr.onClick, "clickMe").build();
 
     view = new View(context, attrs);
     assertNotNull(shadowOf(view).getOnClickListener());
@@ -369,9 +368,8 @@ public class ShadowViewTest {
   public void shouldCallOnClickWithAttribute() throws Exception {
     MyActivity myActivity = buildActivity(MyActivity.class).create().get();
 
-    AttributeSet attrs = Robolectric.buildAttributeSet()
-        .addAttribute(android.R.attr.onClick, "clickMe")
-        .build();
+    AttributeSet attrs =
+        Robolectric.buildAttributeSet().addAttribute(android.R.attr.onClick, "clickMe").build();
 
     view = new View(myActivity, attrs);
     view.performClick();
@@ -382,9 +380,8 @@ public class ShadowViewTest {
   public void shouldThrowExceptionWithBadMethodName() throws Exception {
     MyActivity myActivity = buildActivity(MyActivity.class).create().get();
 
-    AttributeSet attrs = Robolectric.buildAttributeSet()
-        .addAttribute(android.R.attr.onClick, "clickYou")
-        .build();
+    AttributeSet attrs =
+        Robolectric.buildAttributeSet().addAttribute(android.R.attr.onClick, "clickYou").build();
 
     view = new View(myActivity, attrs);
     view.performClick();
@@ -483,12 +480,14 @@ public class ShadowViewTest {
   @Test
   public void dispatchTouchEvent_listensToFalseFromListener() throws Exception {
     final AtomicBoolean called = new AtomicBoolean(false);
-    view.setOnTouchListener(new View.OnTouchListener() {
-      @Override
-      public boolean onTouch(View view, MotionEvent motionEvent) {
-        called.set(true); return false;
-      }
-    });
+    view.setOnTouchListener(
+        new View.OnTouchListener() {
+          @Override
+          public boolean onTouch(View view, MotionEvent motionEvent) {
+            called.set(true);
+            return false;
+          }
+        });
     MotionEvent event = MotionEvent.obtain(0L, 0L, MotionEvent.ACTION_DOWN, 12f, 34f, 0);
     view.dispatchTouchEvent(event);
     assertThat(shadowOf(view).getLastTouchEvent()).isSameInstanceAs(event);
@@ -554,7 +553,8 @@ public class ShadowViewTest {
     assertThat(view1.getMeasuredHeight()).isEqualTo(0);
     assertThat(view1.getMeasuredWidth()).isEqualTo(0);
 
-    view1.measure(MeasureSpec.makeMeasureSpec(150, MeasureSpec.AT_MOST),
+    view1.measure(
+        MeasureSpec.makeMeasureSpec(150, MeasureSpec.AT_MOST),
         MeasureSpec.makeMeasureSpec(300, MeasureSpec.AT_MOST));
 
     assertThat(view1.getHeight()).isEqualTo(0);
@@ -573,8 +573,9 @@ public class ShadowViewTest {
     assertThat(view2.getMeasuredWidth()).isEqualTo(0);
     assertThat(view2.getMeasuredHeight()).isEqualTo(0);
 
-    view2.measure(MeasureSpec.makeMeasureSpec(200, MeasureSpec.AT_MOST),
-    MeasureSpec.makeMeasureSpec(50, MeasureSpec.AT_MOST));
+    view2.measure(
+        MeasureSpec.makeMeasureSpec(200, MeasureSpec.AT_MOST),
+        MeasureSpec.makeMeasureSpec(50, MeasureSpec.AT_MOST));
 
     assertThat(view2.getWidth()).isEqualTo(0);
     assertThat(view2.getHeight()).isEqualTo(0);
@@ -632,12 +633,13 @@ public class ShadowViewTest {
     assertThat(view.isClickable()).isTrue();
     view.setClickable(false);
     assertThat(view.isClickable()).isFalse();
-    view.setOnClickListener(new OnClickListener() {
-      @Override
-      public void onClick(View v) {
-        ;
-      }
-    });
+    view.setOnClickListener(
+        new OnClickListener() {
+          @Override
+          public void onClick(View v) {
+            ;
+          }
+        });
     assertThat(view.isClickable()).isTrue();
   }
 
@@ -648,12 +650,13 @@ public class ShadowViewTest {
     assertThat(view.isLongClickable()).isTrue();
     view.setLongClickable(false);
     assertThat(view.isLongClickable()).isFalse();
-    view.setOnLongClickListener(new OnLongClickListener() {
-      @Override
-      public boolean onLongClick(View v) {
-        return false;
-      }
-    });
+    view.setOnLongClickListener(
+        new OnLongClickListener() {
+          @Override
+          public boolean onLongClick(View v) {
+            return false;
+          }
+        });
     assertThat(view.isLongClickable()).isTrue();
   }
 
@@ -741,7 +744,8 @@ public class ShadowViewTest {
   public void performHapticFeedback_shouldSetLastPerformedHapticFeedback() throws Exception {
     assertThat(shadowOf(view).lastHapticFeedbackPerformed()).isEqualTo(-1);
     view.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
-    assertThat(shadowOf(view).lastHapticFeedbackPerformed()).isEqualTo(HapticFeedbackConstants.LONG_PRESS);
+    assertThat(shadowOf(view).lastHapticFeedbackPerformed())
+        .isEqualTo(HapticFeedbackConstants.LONG_PRESS);
   }
 
   @Test
@@ -780,8 +784,7 @@ public class ShadowViewTest {
     assertThat(view.getLayerType()).isEqualTo(View.LAYER_TYPE_SOFTWARE);
   }
 
-  private static class TestAnimation extends Animation {
-  }
+  private static class TestAnimation extends Animation {}
 
   private static class TouchableView extends View {
     MotionEvent event;
@@ -839,7 +842,8 @@ public class ShadowViewTest {
       super.onLayout(changed, l, t, r, b);
     }
 
-    @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
       setMeasuredDimension(minWidth, minHeight);
     }
   }
@@ -916,13 +920,15 @@ public class ShadowViewTest {
   @Test
   public void capturesOnSystemUiVisibilityChangeListener() throws Exception {
     TestView testView = new TestView(buildActivity(Activity.class).create().get());
-    View.OnSystemUiVisibilityChangeListener changeListener = new View.OnSystemUiVisibilityChangeListener() {
-      @Override
-      public void onSystemUiVisibilityChange(int i) { }
-    };
+    View.OnSystemUiVisibilityChangeListener changeListener =
+        new View.OnSystemUiVisibilityChangeListener() {
+          @Override
+          public void onSystemUiVisibilityChange(int i) {}
+        };
     testView.setOnSystemUiVisibilityChangeListener(changeListener);
 
-    assertThat(changeListener).isEqualTo(shadowOf(testView).getOnSystemUiVisibilityChangeListener());
+    assertThat(changeListener)
+        .isEqualTo(shadowOf(testView).getOnSystemUiVisibilityChangeListener());
   }
 
   @Test
@@ -930,10 +936,12 @@ public class ShadowViewTest {
     TestView testView = new TestView(buildActivity(Activity.class).create().get());
     assertThat(shadowOf(testView).getOnCreateContextMenuListener()).isNull();
 
-    View.OnCreateContextMenuListener createListener = new View.OnCreateContextMenuListener() {
-      @Override
-      public void onCreateContextMenu(ContextMenu contextMenu, View view, ContextMenu.ContextMenuInfo contextMenuInfo) {}
-    };
+    View.OnCreateContextMenuListener createListener =
+        new View.OnCreateContextMenuListener() {
+          @Override
+          public void onCreateContextMenu(
+              ContextMenu contextMenu, View view, ContextMenu.ContextMenuInfo contextMenuInfo) {}
+        };
 
     testView.setOnCreateContextMenuListener(createListener);
     assertThat(shadowOf(testView).getOnCreateContextMenuListener()).isEqualTo(createListener);
@@ -985,30 +993,23 @@ public class ShadowViewTest {
   public void setsGlobalVisibleRect() {
     Rect globalVisibleRect = new Rect();
     shadowOf(view).setGlobalVisibleRect(new Rect());
-    assertThat(view.getGlobalVisibleRect(globalVisibleRect))
-        .isFalse();
-    assertThat(globalVisibleRect.isEmpty())
-        .isTrue();
-    assertThat(view.getGlobalVisibleRect(globalVisibleRect, new Point(1, 1)))
-        .isFalse();
-    assertThat(globalVisibleRect.isEmpty())
-        .isTrue();
+    assertThat(view.getGlobalVisibleRect(globalVisibleRect)).isFalse();
+    assertThat(globalVisibleRect.isEmpty()).isTrue();
+    assertThat(view.getGlobalVisibleRect(globalVisibleRect, new Point(1, 1))).isFalse();
+    assertThat(globalVisibleRect.isEmpty()).isTrue();
 
     shadowOf(view).setGlobalVisibleRect(new Rect(1, 2, 3, 4));
-    assertThat(view.getGlobalVisibleRect(globalVisibleRect))
-        .isTrue();
-    assertThat(globalVisibleRect)
-        .isEqualTo(new Rect(1, 2, 3, 4));
-    assertThat(view.getGlobalVisibleRect(globalVisibleRect, new Point(1, 1)))
-        .isTrue();
-    assertThat(globalVisibleRect)
-        .isEqualTo(new Rect(0, 1, 2, 3));
+    assertThat(view.getGlobalVisibleRect(globalVisibleRect)).isTrue();
+    assertThat(globalVisibleRect).isEqualTo(new Rect(1, 2, 3, 4));
+    assertThat(view.getGlobalVisibleRect(globalVisibleRect, new Point(1, 1))).isTrue();
+    assertThat(globalVisibleRect).isEqualTo(new Rect(0, 1, 2, 3));
   }
 
   @Test
   public void usesDefaultGlobalVisibleRect() {
 
-    final ActivityController<Activity> activityController = Robolectric.buildActivity(Activity.class);
+    final ActivityController<Activity> activityController =
+        Robolectric.buildActivity(Activity.class);
     final Activity activity = activityController.get();
     TextView fooView = new TextView(activity);
     activity.setContentView(
@@ -1020,8 +1021,12 @@ public class ShadowViewTest {
     Rect globalVisibleRect = new Rect();
     assertThat(fooView.getGlobalVisibleRect(globalVisibleRect)).isTrue();
     assertThat(globalVisibleRect)
-        .isEqualTo(new Rect(0, 25,
-            DeviceConfig.DEFAULT_SCREEN_SIZE.width, DeviceConfig.DEFAULT_SCREEN_SIZE.height));
+        .isEqualTo(
+            new Rect(
+                0,
+                25,
+                DeviceConfig.DEFAULT_SCREEN_SIZE.width,
+                DeviceConfig.DEFAULT_SCREEN_SIZE.height));
   }
 
   @Test
@@ -1160,12 +1165,14 @@ public class ShadowViewTest {
       this.transcript = transcript;
     }
 
-    @Override protected void onAttachedToWindow() {
+    @Override
+    protected void onAttachedToWindow() {
       transcript.add(name + " attached");
       super.onAttachedToWindow();
     }
 
-    @Override protected void onDetachedFromWindow() {
+    @Override
+    protected void onDetachedFromWindow() {
       transcript.add(name + " detached");
       super.onDetachedFromWindow();
     }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowVpnManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowVpnManagerTest.java
index dbf7250ef..b47f5a1dc 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowVpnManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowVpnManagerTest.java
@@ -1,7 +1,6 @@
 package org.robolectric.shadows;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.robolectric.Shadows.shadowOf;
 
 import android.content.Intent;
 import android.net.Ikev2VpnProfile;
@@ -15,6 +14,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadow.api.Shadow;
 
 @RunWith(AndroidJUnit4.class)
 @Config(minSdk = VERSION_CODES.R)
@@ -25,7 +25,7 @@ public class ShadowVpnManagerTest {
   @Before
   public void setUp() throws Exception {
     vpnManager = ApplicationProvider.getApplicationContext().getSystemService(VpnManager.class);
-    shadowVpnManager = shadowOf(vpnManager);
+    shadowVpnManager = Shadow.extract(vpnManager);
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWallpaperManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWallpaperManagerTest.java
index 7bafc91b3..313114ddf 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWallpaperManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWallpaperManagerTest.java
@@ -291,8 +291,8 @@ public class ShadowWallpaperManagerTest {
 
     try (ParcelFileDescriptor parcelFileDescriptor =
         manager.getWallpaperFile(WallpaperManager.FLAG_SYSTEM)) {
-    assertThat(getBytesFromFileDescriptor(parcelFileDescriptor.getFileDescriptor()))
-        .isEqualTo(getBytesFromBitmap(TEST_IMAGE_1));
+      assertThat(getBytesFromFileDescriptor(parcelFileDescriptor.getFileDescriptor()))
+          .isEqualTo(getBytesFromBitmap(TEST_IMAGE_1));
     }
   }
 
@@ -314,8 +314,8 @@ public class ShadowWallpaperManagerTest {
 
     try (ParcelFileDescriptor parcelFileDescriptor =
         manager.getWallpaperFile(WallpaperManager.FLAG_LOCK)) {
-    assertThat(getBytesFromFileDescriptor(parcelFileDescriptor.getFileDescriptor()))
-        .isEqualTo(getBytesFromBitmap(TEST_IMAGE_3));
+      assertThat(getBytesFromFileDescriptor(parcelFileDescriptor.getFileDescriptor()))
+          .isEqualTo(getBytesFromBitmap(TEST_IMAGE_3));
     }
   }
 
@@ -368,9 +368,9 @@ public class ShadowWallpaperManagerTest {
         /* allowBackup= */ true,
         WallpaperManager.FLAG_SYSTEM);
 
-      assertThat(getBytesFromBitmap(shadowOf(manager).getBitmap(WallpaperManager.FLAG_SYSTEM)))
-          .isEqualTo(testImageBytes);
-      assertThat(shadowOf(manager).getBitmap(WallpaperManager.FLAG_LOCK)).isNull();
+    assertThat(getBytesFromBitmap(shadowOf(manager).getBitmap(WallpaperManager.FLAG_SYSTEM)))
+        .isEqualTo(testImageBytes);
+    assertThat(shadowOf(manager).getBitmap(WallpaperManager.FLAG_LOCK)).isNull();
   }
 
   @Test
@@ -383,9 +383,9 @@ public class ShadowWallpaperManagerTest {
         /* allowBackup= */ true,
         WallpaperManager.FLAG_LOCK);
 
-      assertThat(getBytesFromBitmap(shadowOf(manager).getBitmap(WallpaperManager.FLAG_LOCK)))
-          .isEqualTo(testImageBytes);
-      assertThat(shadowOf(manager).getBitmap(WallpaperManager.FLAG_SYSTEM)).isNull();
+    assertThat(getBytesFromBitmap(shadowOf(manager).getBitmap(WallpaperManager.FLAG_LOCK)))
+        .isEqualTo(testImageBytes);
+    assertThat(shadowOf(manager).getBitmap(WallpaperManager.FLAG_SYSTEM)).isNull();
   }
 
   @Test
@@ -398,9 +398,9 @@ public class ShadowWallpaperManagerTest {
         /* allowBackup= */ true,
         UNSUPPORTED_FLAG);
 
-      assertThat(shadowOf(manager).getBitmap(WallpaperManager.FLAG_LOCK)).isNull();
-      assertThat(shadowOf(manager).getBitmap(WallpaperManager.FLAG_SYSTEM)).isNull();
-      assertThat(shadowOf(manager).getBitmap(UNSUPPORTED_FLAG)).isNull();
+    assertThat(shadowOf(manager).getBitmap(WallpaperManager.FLAG_LOCK)).isNull();
+    assertThat(shadowOf(manager).getBitmap(WallpaperManager.FLAG_SYSTEM)).isNull();
+    assertThat(shadowOf(manager).getBitmap(UNSUPPORTED_FLAG)).isNull();
   }
 
   @Test
@@ -568,7 +568,7 @@ public class ShadowWallpaperManagerTest {
     InputStream inputStream = new FileInputStream(fileDescriptor);
     ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
     ByteStreams.copy(inputStream, outputStream);
-      return outputStream.toByteArray();
+    return outputStream.toByteArray();
   }
 
   private static byte[] getBytesFromBitmap(Bitmap bitmap) {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWearableSensingManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWearableSensingManagerTest.java
index bb24fc8c9..8d8f24a36 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWearableSensingManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWearableSensingManagerTest.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
 import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
 import android.app.wearable.WearableSensingManager;
@@ -59,16 +60,46 @@ public class ShadowWearableSensingManagerTest {
     ShadowWearableSensingManager shadowWearableSensingManager =
         Shadow.extract(wearableSensingManager);
 
-    PersistableBundle persistableBundle = new PersistableBundle();
-    SharedMemory sharedMemory = SharedMemory.create("name", 100);
+    PersistableBundle persistableBundle1 = new PersistableBundle();
+    PersistableBundle persistableBundle2 = new PersistableBundle();
+    SharedMemory sharedMemory1 = SharedMemory.create("name1", 100);
+    SharedMemory sharedMemory2 = SharedMemory.create("name2", 200);
     shadowWearableSensingManager.setProvideDataResult(WearableSensingManager.STATUS_ACCESS_DENIED);
 
     wearableSensingManager.provideData(
-        persistableBundle, sharedMemory, MoreExecutors.directExecutor(), callback);
+        persistableBundle1, sharedMemory1, MoreExecutors.directExecutor(), callback);
+    wearableSensingManager.provideData(
+        persistableBundle2, sharedMemory2, MoreExecutors.directExecutor(), callback);
 
-    verify(callback).accept(WearableSensingManager.STATUS_ACCESS_DENIED);
+    verify(callback, times(2)).accept(WearableSensingManager.STATUS_ACCESS_DENIED);
     assertThat(shadowWearableSensingManager.getLastDataBundle())
-        .isSameInstanceAs(persistableBundle);
-    assertThat(shadowWearableSensingManager.getLastSharedMemory()).isSameInstanceAs(sharedMemory);
+        .isSameInstanceAs(persistableBundle2);
+    assertThat(shadowWearableSensingManager.getLastSharedMemory()).isSameInstanceAs(sharedMemory2);
+    assertThat(shadowWearableSensingManager.getAllDataBundles())
+        .containsExactly(persistableBundle1, persistableBundle2);
+    assertThat(shadowWearableSensingManager.getAllSharedMemories())
+        .containsExactly(sharedMemory1, sharedMemory2);
+  }
+
+  @Test
+  public void getLastDataBundle_noDataProvided_doesNotThrow() throws Exception {
+    WearableSensingManager wearableSensingManager =
+        (WearableSensingManager)
+            getApplicationContext().getSystemService(Context.WEARABLE_SENSING_SERVICE);
+    ShadowWearableSensingManager shadowWearableSensingManager =
+        Shadow.extract(wearableSensingManager);
+
+    shadowWearableSensingManager.getLastDataBundle();
+  }
+
+  @Test
+  public void getLastSharedMemory_noDataProvided_doesNotThrow() throws Exception {
+    WearableSensingManager wearableSensingManager =
+        (WearableSensingManager)
+            getApplicationContext().getSystemService(Context.WEARABLE_SENSING_SERVICE);
+    ShadowWearableSensingManager shadowWearableSensingManager =
+        Shadow.extract(wearableSensingManager);
+
+    shadowWearableSensingManager.getLastSharedMemory();
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiManagerTest.java
index 1d376a432..252112cf6 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiManagerTest.java
@@ -1,7 +1,6 @@
 package org.robolectric.shadows;
 
 import static android.net.wifi.WifiManager.SCAN_RESULTS_AVAILABLE_ACTION;
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
@@ -38,12 +37,13 @@ import android.net.wifi.WifiManager.LocalOnlyConnectionFailureListener;
 import android.net.wifi.WifiManager.MulticastLock;
 import android.net.wifi.WifiManager.PnoScanResultsCallback;
 import android.net.wifi.WifiNetworkSpecifier;
+import android.net.wifi.WifiNetworkSuggestion;
 import android.net.wifi.WifiSsid;
 import android.net.wifi.WifiUsabilityStatsEntry;
-import android.os.Build;
 import android.util.Pair;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.ExecutorService;
@@ -56,7 +56,6 @@ import org.mockito.ArgumentCaptor;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
-import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.versioning.AndroidVersions.U;
 
 @RunWith(AndroidJUnit4.class)
@@ -75,19 +74,11 @@ public class ShadowWifiManagerTest {
 
   @Test
   public void setWifiInfo_shouldUpdateWifiInfo() {
-    WifiInfo wifiInfo = newWifiInfo();
+    WifiInfo wifiInfo = new WifiInfo();
     shadowOf(wifiManager).setConnectionInfo(wifiInfo);
     assertThat(wifiManager.getConnectionInfo()).isSameInstanceAs(wifiInfo);
   }
 
-  private static WifiInfo newWifiInfo() {
-    if (RuntimeEnvironment.getApiLevel() >= LOLLIPOP) {
-      return new WifiInfo();
-    } else {
-      return ReflectionHelpers.callConstructor(WifiInfo.class);
-    }
-  }
-
   @Test
   public void setWifiEnabled_shouldThrowSecurityExceptionWhenAccessWifiStatePermissionNotGranted() {
     shadowOf(wifiManager).setAccessWifiStatePermission(false);
@@ -358,7 +349,6 @@ public class ShadowWifiManagerTest {
   }
 
   @Test
-  @Config(minSdk = Build.VERSION_CODES.LOLLIPOP)
   public void getPrivilegedConfiguredNetworks_shouldReturnConfiguredNetworks() {
     WifiConfiguration wifiConfiguration = new WifiConfiguration();
     wifiConfiguration.networkId = 123;
@@ -1324,6 +1314,41 @@ public class ShadowWifiManagerTest {
     assertThat(listener.incomingFailures).isEmpty();
   }
 
+  @Test
+  @Config(minSdk = R)
+  public void addNetworkSuggestions_returnsSuccess() {
+    assertThat(wifiManager.getNetworkSuggestions()).isEmpty();
+    WifiNetworkSuggestion suggestion =
+        new WifiNetworkSuggestion.Builder()
+            .setSsid("TestWifi")
+            .setBssid(MacAddress.fromString("11:22:33:44:55:66"))
+            .build();
+
+    assertThat(wifiManager.addNetworkSuggestions(Collections.singletonList(suggestion)))
+        .isEqualTo(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS);
+
+    assertThat(wifiManager.getNetworkSuggestions()).containsExactly(suggestion);
+  }
+
+  @Test
+  @Config(minSdk = R)
+  public void addNetworkSuggestions_returnsError() {
+    assertThat(wifiManager.getNetworkSuggestions()).isEmpty();
+    WifiNetworkSuggestion suggestion =
+        new WifiNetworkSuggestion.Builder()
+            .setSsid("TestWifi")
+            .setBssid(MacAddress.fromString("11:22:33:44:55:66"))
+            .build();
+    ((ShadowWifiManager) Shadow.extract(wifiManager))
+        .setAddNetworkSuggestionsResult(
+            WifiManager.STATUS_NETWORK_SUGGESTIONS_ERROR_APP_DISALLOWED);
+
+    assertThat(wifiManager.addNetworkSuggestions(Collections.singletonList(suggestion)))
+        .isEqualTo(WifiManager.STATUS_NETWORK_SUGGESTIONS_ERROR_APP_DISALLOWED);
+
+    assertThat(wifiManager.getNetworkSuggestions()).isEmpty();
+  }
+
   private static final class IncomingFailure {
     private final WifiNetworkSpecifier wifiNetworkSpecifier;
     private final int failureReason;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiScannerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiScannerTest.java
new file mode 100644
index 000000000..a383bff78
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiScannerTest.java
@@ -0,0 +1,159 @@
+package org.robolectric.shadows;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertNotNull;
+import static org.robolectric.shadow.api.Shadow.extract;
+
+import android.content.Context;
+import android.net.wifi.ScanResult;
+import android.net.wifi.WifiScanner;
+import android.net.wifi.WifiScanner.ScanData;
+import android.os.Build;
+import android.os.Build.VERSION_CODES;
+import com.google.common.collect.ImmutableList;
+import com.google.common.util.concurrent.MoreExecutors;
+import java.util.Arrays;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(minSdk = VERSION_CODES.N)
+public class ShadowWifiScannerTest {
+  private static final ImmutableList<ScanResult> SCAN_RESULTS = createFakeScanResults();
+
+  /** Verifies that WifiScanner and its shadow are available without throwing exceptions. */
+  @Test
+  public void init() {
+    WifiScanner scanner =
+        (WifiScanner)
+            RuntimeEnvironment.getApplication().getSystemService(Context.WIFI_SCANNING_SERVICE);
+    assertNotNull(scanner);
+
+    ShadowWifiScanner shadowWifiScanner = extract(scanner);
+    assertNotNull(shadowWifiScanner);
+  }
+
+  /**
+   * Verifies that a listener registered via WifiScanner#registerScanListener receives results when
+   * extract(scanner).setScanResults is called.
+   *
+   * <p>WifiScanner#registerScanListener was added in Nougat.
+   */
+  @Test
+  @Config(minSdk = VERSION_CODES.N_MR1, maxSdk = VERSION_CODES.Q)
+  public void setScanResults_invokesListeners() {
+    ScanDataListener listener = new ScanDataListener();
+
+    WifiScanner scanner =
+        (WifiScanner)
+            RuntimeEnvironment.getApplication().getSystemService(Context.WIFI_SCANNING_SERVICE);
+
+    scanner.registerScanListener(listener);
+    ((ShadowWifiScanner) extract(scanner)).setScanResults(SCAN_RESULTS);
+
+    ScanData[] scanData = listener.scanData;
+    assertThat(scanData).hasLength(1);
+    assertThat(Arrays.asList(scanData[0].getResults())).containsExactlyElementsIn(SCAN_RESULTS);
+  }
+
+  /**
+   * Verifies that a listener registered via WifiScanner#registerScanListener receives results when
+   * extract(scanner).setScanResults is called.
+   *
+   * <p>Specifying an executor is only supported in R+.
+   */
+  @Test
+  @Config(minSdk = VERSION_CODES.R)
+  public void setScanResultsR_invokesListeners() {
+    ScanDataListener listener = new ScanDataListener();
+
+    WifiScanner scanner =
+        (WifiScanner)
+            RuntimeEnvironment.getApplication().getSystemService(Context.WIFI_SCANNING_SERVICE);
+
+    scanner.registerScanListener(MoreExecutors.directExecutor(), listener);
+    ((ShadowWifiScanner) extract(scanner)).setScanResults(SCAN_RESULTS);
+
+    ScanData[] scanData = listener.scanData;
+    assertThat(scanData).hasLength(1);
+    assertThat(Arrays.asList(scanData[0].getResults())).containsExactlyElementsIn(SCAN_RESULTS);
+  }
+
+  /**
+   * Verifies that WifiScanner#getSingleScanResults returns the latest scan results.
+   *
+   * <p>WifiScanner#getSingleScanResults was added in R.
+   */
+  @Test
+  @Config(minSdk = VERSION_CODES.R)
+  public void getSingleScanResults_returnsResults() {
+    WifiScanner scanner =
+        (WifiScanner)
+            RuntimeEnvironment.getApplication().getSystemService(Context.WIFI_SCANNING_SERVICE);
+
+    ((ShadowWifiScanner) extract(scanner)).setScanResults(SCAN_RESULTS);
+
+    assertThat(scanner.getSingleScanResults()).containsExactlyElementsIn(SCAN_RESULTS);
+  }
+
+  private static ImmutableList<ScanResult> createFakeScanResults() {
+    ScanResult scanResult = null;
+
+    if (Build.VERSION.SDK_INT >= VERSION_CODES.R) {
+      // informationElements added in R
+      ScanResult.InformationElement mobileInformationElement =
+          InformationElementBuilder.newBuilder()
+              .setId(107) // EID_INTERWORKING
+              .setBytes(new byte[] {1, 2, 3})
+              .build();
+      ImmutableList<ScanResult.InformationElement> informationElements =
+          ImmutableList.of(mobileInformationElement);
+      scanResult =
+          ShadowScanResult.newInstance(
+              "SSID",
+              "BSSID",
+              "Some capabilities",
+              /* level= */ -57,
+              /* frequency= */ 5,
+              /* is80211McRttResponder= */ true,
+              informationElements);
+    } else {
+      scanResult =
+          ShadowScanResult.newInstance(
+              "SSID",
+              "BSSID",
+              "Some capabilities",
+              /* level= */ -57,
+              /* frequency= */ 5,
+              /* is80211McRTTResponder= */ true);
+    }
+
+    scanResult.timestamp = 1000L;
+
+    return ImmutableList.of(scanResult);
+  }
+
+  private static class ScanDataListener implements WifiScanner.ScanListener {
+    public ScanData[] scanData = null;
+
+    @Override
+    public void onSuccess() {}
+
+    @Override
+    public void onFailure(int reason, String description) {}
+
+    @Override
+    public void onPeriodChanged(int periodInMs) {}
+
+    @Override
+    public void onResults(ScanData[] results) {
+      scanData = results;
+    }
+
+    @Override
+    public void onFullResult(ScanResult fullScanResult) {}
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerGlobalUnitTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerGlobalUnitTest.java
index 39a6bcdf1..5d1c78414 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerGlobalUnitTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerGlobalUnitTest.java
@@ -32,5 +32,4 @@ public class ShadowWindowManagerGlobalUnitTest {
       Robolectric.setupActivity(Activity.class);
     }
   }
-
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerImplTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerImplTest.java
index 946ee6709..ccc5d2c97 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerImplTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerImplTest.java
@@ -34,8 +34,8 @@ public class ShadowWindowManagerImplTest {
     windowManager = context.getSystemService(WindowManager.class);
     layoutParams =
         new LayoutParams(
-            /*w=*/ ViewGroup.LayoutParams.MATCH_PARENT,
-            /*h=*/ ViewGroup.LayoutParams.MATCH_PARENT,
+            /* w= */ ViewGroup.LayoutParams.MATCH_PARENT,
+            /* h= */ ViewGroup.LayoutParams.MATCH_PARENT,
             LayoutParams.TYPE_APPLICATION_OVERLAY,
             LayoutParams.FLAG_LAYOUT_IN_SCREEN,
             PixelFormat.TRANSLUCENT);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowTest.java
index 924cf82a9..93a679ef5 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowTest.java
@@ -38,9 +38,12 @@ public class ShadowWindowTest {
     Window window = activity.getWindow();
 
     assertThat(shadowOf(window).getFlag(WindowManager.LayoutParams.FLAG_FULLSCREEN)).isFalse();
-    window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
+    window.setFlags(
+        WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
     assertThat(shadowOf(window).getFlag(WindowManager.LayoutParams.FLAG_FULLSCREEN)).isTrue();
-    window.setFlags(WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON, WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON);
+    window.setFlags(
+        WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON,
+        WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON);
     assertThat(shadowOf(window).getFlag(WindowManager.LayoutParams.FLAG_FULLSCREEN)).isTrue();
   }
 
@@ -123,7 +126,8 @@ public class ShadowWindowTest {
     assertThat(shadowWindow.getBackgroundDrawable()).isNull();
 
     window.setBackgroundDrawableResource(R.drawable.btn_star);
-    assertThat(shadowOf(shadowWindow.getBackgroundDrawable()).createdFromResId).isEqualTo(R.drawable.btn_star);
+    assertThat(shadowOf(shadowWindow.getBackgroundDrawable()).createdFromResId)
+        .isEqualTo(R.drawable.btn_star);
   }
 
   @Test
@@ -137,14 +141,16 @@ public class ShadowWindowTest {
     assertThat(shadowWindow.getSoftInputMode()).isEqualTo(7);
   }
 
-  @Test @Config(maxSdk = LOLLIPOP_MR1)
+  @Test
+  @Config(maxSdk = LOLLIPOP_MR1)
   public void forPreM_create_shouldCreateImplPhoneWindow() throws Exception {
     assertThat(
             ShadowWindow.create(ApplicationProvider.getApplicationContext()).getClass().getName())
         .isEqualTo("com.android.internal.policy.impl.PhoneWindow");
   }
 
-  @Test @Config(minSdk = M)
+  @Test
+  @Config(minSdk = M)
   public void forM_create_shouldCreatePhoneWindow() throws Exception {
     assertThat(
             ShadowWindow.create(ApplicationProvider.getApplicationContext()).getClass().getName())
diff --git a/robolectric/src/test/java/org/robolectric/shadows/StreamConfigurationMapBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/StreamConfigurationMapBuilderTest.java
index 2d3a04b06..da614ac41 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/StreamConfigurationMapBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/StreamConfigurationMapBuilderTest.java
@@ -15,7 +15,6 @@ import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 
 /** Tests for {@link StreamConfigurationMapBuilder}. */
-@Config(minSdk = VERSION_CODES.LOLLIPOP)
 @RunWith(AndroidJUnit4.class)
 public class StreamConfigurationMapBuilderTest {
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/TestParcelable.java b/robolectric/src/test/java/org/robolectric/shadows/TestParcelable.java
index 643ec42fb..d3170ee01 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/TestParcelable.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/TestParcelable.java
@@ -33,6 +33,7 @@ class TestParcelable implements Parcelable {
           return new TestParcelable[0];
         }
       };
+
   @Override
   public void writeToParcel(Parcel dest, int flags) {
     dest.writeInt(contents);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/TestParcelableImpl.java b/robolectric/src/test/java/org/robolectric/shadows/TestParcelableImpl.java
index 9c4a8359b..e5da4e52e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/TestParcelableImpl.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/TestParcelableImpl.java
@@ -32,6 +32,7 @@ class TestParcelableImpl extends TestParcelableBase implements Parcelable {
           return new TestParcelableImpl[0];
         }
       };
+
   @Override
   public void writeToParcel(Parcel dest, int flags) {
     dest.writeInt(contents);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ViewStubTest.java b/robolectric/src/test/java/org/robolectric/shadows/ViewStubTest.java
index be1c37da8..b5ab1b886 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ViewStubTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ViewStubTest.java
@@ -22,7 +22,8 @@ import org.robolectric.Robolectric;
 public class ViewStubTest {
   private Context ctxt;
 
-  @Before public void setUp() throws Exception {
+  @Before
+  public void setUp() throws Exception {
     ctxt = ApplicationProvider.getApplicationContext();
   }
 
@@ -53,11 +54,13 @@ public class ViewStubTest {
 
   @Test
   public void shouldApplyAttributes() {
-    ViewStub viewStub = new ViewStub(ctxt,
-        Robolectric.buildAttributeSet()
-            .addAttribute(android.R.attr.inflatedId, "@+id/include_id")
-            .addAttribute(android.R.attr.layout, "@layout/media")
-            .build());
+    ViewStub viewStub =
+        new ViewStub(
+            ctxt,
+            Robolectric.buildAttributeSet()
+                .addAttribute(android.R.attr.inflatedId, "@+id/include_id")
+                .addAttribute(android.R.attr.layout, "@layout/media")
+                .build());
 
     assertThat(viewStub.getInflatedId()).isEqualTo(R.id.include_id);
     assertThat(viewStub.getLayoutResource()).isEqualTo(R.layout.media);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/XmlPullParserTest.java b/robolectric/src/test/java/org/robolectric/shadows/XmlPullParserTest.java
index 339a2e55a..e973056b6 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/XmlPullParserTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/XmlPullParserTest.java
@@ -22,15 +22,15 @@ import org.xmlpull.v1.XmlPullParserException;
 public class XmlPullParserTest {
 
   // emulator output:
-    /*
-http://schemas.android.com/apk/res/android:id(resId=16842960) type=CDATA: value=@16908308 (resId=16908308)
-http://schemas.android.com/apk/res/android:height(resId=16843093) type=CDATA: value=1234.0px (resId=-1)
-http://schemas.android.com/apk/res/android:width(resId=16843097) type=CDATA: value=1234.0px (resId=-1)
-http://schemas.android.com/apk/res/android:title(resId=16843233) type=CDATA: value=Android Title (resId=-1)
-http://schemas.android.com/apk/res/android:scrollbarFadeDuration(resId=16843432) type=CDATA: value=1111 (resId=-1)
-http://schemas.android.com/apk/res-auto:title(resId=2130771971) type=CDATA: value=App Title (resId=-1)
-:style(resId=0) type=CDATA: value=@android:style/TextAppearance.Small (resId=16973894)
-*/
+  /*
+  http://schemas.android.com/apk/res/android:id(resId=16842960) type=CDATA: value=@16908308 (resId=16908308)
+  http://schemas.android.com/apk/res/android:height(resId=16843093) type=CDATA: value=1234.0px (resId=-1)
+  http://schemas.android.com/apk/res/android:width(resId=16843097) type=CDATA: value=1234.0px (resId=-1)
+  http://schemas.android.com/apk/res/android:title(resId=16843233) type=CDATA: value=Android Title (resId=-1)
+  http://schemas.android.com/apk/res/android:scrollbarFadeDuration(resId=16843432) type=CDATA: value=1111 (resId=-1)
+  http://schemas.android.com/apk/res-auto:title(resId=2130771971) type=CDATA: value=App Title (resId=-1)
+  :style(resId=0) type=CDATA: value=@android:style/TextAppearance.Small (resId=16973894)
+  */
 
   @Test
   public void xmlParser() throws IOException, XmlPullParserException {
@@ -54,55 +54,63 @@ http://schemas.android.com/apk/res-auto:title(resId=2130771971) type=CDATA: valu
       }
     }
 
-    assertThat(attrNames).containsExactly(
-        ANDROID_NS + ":id",
-        ANDROID_NS + ":height",
-        ANDROID_NS + ":width",
-        ANDROID_NS + ":title",
-        ANDROID_NS + ":scrollbarFadeDuration",
-        AUTO_NS + ":title",
-        ":style",
-        ":class",
-        ":id"
-    );
+    assertThat(attrNames)
+        .containsExactly(
+            ANDROID_NS + ":id",
+            ANDROID_NS + ":height",
+            ANDROID_NS + ":width",
+            ANDROID_NS + ":title",
+            ANDROID_NS + ":scrollbarFadeDuration",
+            AUTO_NS + ":title",
+            ":style",
+            ":class",
+            ":id");
 
     assertAttribute(
         parser, ANDROID_NS, "id", android.R.attr.id, "@" + android.R.id.text1, android.R.id.text1);
-      assertAttribute(parser,
-          ANDROID_NS, "height", android.R.attr.height, "@" + android.R.dimen.app_icon_size,
-          android.R.dimen.app_icon_size);
-      assertAttribute(parser,
-          ANDROID_NS, "width", android.R.attr.width, "1234.0px", -1);
-      assertThat(parser.getAttributeResourceValue(null, "style", /*defaultValue=*/ -1))
-          .isEqualTo(android.R.style.TextAppearance_Small);
-
-    assertAttribute(parser,
-        ANDROID_NS, "title", android.R.attr.title, "Android Title", -1);
-    assertAttribute(parser,
-        ANDROID_NS, "scrollbarFadeDuration", android.R.attr.scrollbarFadeDuration, "1111", -1);
-    assertAttribute(parser,
-        AUTO_NS, "title", R.attr.title, "App Title", -1);
+    assertAttribute(
+        parser,
+        ANDROID_NS,
+        "height",
+        android.R.attr.height,
+        "@" + android.R.dimen.app_icon_size,
+        android.R.dimen.app_icon_size);
+    assertAttribute(parser, ANDROID_NS, "width", android.R.attr.width, "1234.0px", -1);
+    assertThat(parser.getAttributeResourceValue(null, "style", /* defaultValue= */ -1))
+        .isEqualTo(android.R.style.TextAppearance_Small);
+
+    assertAttribute(parser, ANDROID_NS, "title", android.R.attr.title, "Android Title", -1);
+    assertAttribute(
+        parser,
+        ANDROID_NS,
+        "scrollbarFadeDuration",
+        android.R.attr.scrollbarFadeDuration,
+        "1111",
+        -1);
+    assertAttribute(parser, AUTO_NS, "title", R.attr.title, "App Title", -1);
 
     assertThat(parser.getStyleAttribute()).isEqualTo(android.R.style.TextAppearance_Small);
 
-    assertThat(parser.getIdAttributeResourceValue(/*defaultValue=*/ -1))
+    assertThat(parser.getIdAttributeResourceValue(/* defaultValue= */ -1))
         .isEqualTo(android.R.id.text2);
     assertThat(parser.getClassAttribute()).isEqualTo("none");
   }
 
   @Test
   public void buildAttrSet() {
-    XmlResourceParser parser = (XmlResourceParser) Robolectric.buildAttributeSet()
-        .addAttribute(android.R.attr.width, "1234px")
-        .addAttribute(android.R.attr.height, "@android:dimen/app_icon_size")
-        .addAttribute(android.R.attr.scrollbarFadeDuration, "1111")
-        .addAttribute(android.R.attr.title, "Android Title")
-        .addAttribute(R.attr.title, "App Title")
-        .addAttribute(android.R.attr.id, "@android:id/text1")
-        .setStyleAttribute("@android:style/TextAppearance.Small")
-        .setClassAttribute("none")
-        .setIdAttribute("@android:id/text2")
-        .build();
+    XmlResourceParser parser =
+        (XmlResourceParser)
+            Robolectric.buildAttributeSet()
+                .addAttribute(android.R.attr.width, "1234px")
+                .addAttribute(android.R.attr.height, "@android:dimen/app_icon_size")
+                .addAttribute(android.R.attr.scrollbarFadeDuration, "1111")
+                .addAttribute(android.R.attr.title, "Android Title")
+                .addAttribute(R.attr.title, "App Title")
+                .addAttribute(android.R.attr.id, "@android:id/text1")
+                .setStyleAttribute("@android:style/TextAppearance.Small")
+                .setClassAttribute("none")
+                .setIdAttribute("@android:id/text2")
+                .build();
 
     assertThat(parser.getName()).isEqualTo("dummy");
     int attributeCount = parser.getAttributeCount();
@@ -111,42 +119,57 @@ http://schemas.android.com/apk/res-auto:title(resId=2130771971) type=CDATA: valu
     for (int i = 0; i < attributeCount; i++) {
       attrNames.add(parser.getAttributeNamespace(i) + ":" + parser.getAttributeName(i));
     }
-    assertThat(attrNames).containsExactly(
-        ANDROID_NS + ":id",
-        ANDROID_NS + ":height",
-        ANDROID_NS + ":width",
-        ANDROID_NS + ":title",
-        ANDROID_NS + ":scrollbarFadeDuration",
-        AUTO_NS + ":title",
-        ":style",
-        ":class",
-        ":id"
-    );
-
-    assertAttribute(parser,
-        ANDROID_NS, "id", android.R.attr.id, "@" + android.R.id.text1, android.R.id.text1);
-    assertAttribute(parser,
-        ANDROID_NS, "height", android.R.attr.height, "@" + android.R.dimen.app_icon_size,
+    assertThat(attrNames)
+        .containsExactly(
+            ANDROID_NS + ":id",
+            ANDROID_NS + ":height",
+            ANDROID_NS + ":width",
+            ANDROID_NS + ":title",
+            ANDROID_NS + ":scrollbarFadeDuration",
+            AUTO_NS + ":title",
+            ":style",
+            ":class",
+            ":id");
+
+    assertAttribute(
+        parser, ANDROID_NS, "id", android.R.attr.id, "@" + android.R.id.text1, android.R.id.text1);
+    assertAttribute(
+        parser,
+        ANDROID_NS,
+        "height",
+        android.R.attr.height,
+        "@" + android.R.dimen.app_icon_size,
         android.R.dimen.app_icon_size);
-    assertAttribute(parser,
-        ANDROID_NS, "width", android.R.attr.width, "1234.0px", -1);
-    assertAttribute(parser,
-        "", "style", 0, "@android:style/TextAppearance.Small",
+    assertAttribute(parser, ANDROID_NS, "width", android.R.attr.width, "1234.0px", -1);
+    assertAttribute(
+        parser,
+        "",
+        "style",
+        0,
+        "@android:style/TextAppearance.Small",
         android.R.style.TextAppearance_Small);
-    assertAttribute(parser,
-        ANDROID_NS, "title", android.R.attr.title, "Android Title", -1);
-    assertAttribute(parser,
-        ANDROID_NS, "scrollbarFadeDuration", android.R.attr.scrollbarFadeDuration, "1111", -1);
-    assertAttribute(parser,
-        AUTO_NS, "title", R.attr.title, "App Title", -1);
+    assertAttribute(parser, ANDROID_NS, "title", android.R.attr.title, "Android Title", -1);
+    assertAttribute(
+        parser,
+        ANDROID_NS,
+        "scrollbarFadeDuration",
+        android.R.attr.scrollbarFadeDuration,
+        "1111",
+        -1);
+    assertAttribute(parser, AUTO_NS, "title", R.attr.title, "App Title", -1);
 
     assertThat(parser.getStyleAttribute()).isEqualTo(android.R.style.TextAppearance_Small);
     assertThat(parser.getIdAttribute()).isEqualTo("@android:id/text2");
     assertThat(parser.getClassAttribute()).isEqualTo("none");
   }
 
-  void assertAttribute(XmlResourceParser parser,
-      String attrNs, String attrName, int resId, String value, int valueResId) {
+  void assertAttribute(
+      XmlResourceParser parser,
+      String attrNs,
+      String attrName,
+      int resId,
+      String value,
+      int valueResId) {
     assertThat(format(parser, attrNs, attrName))
         .isEqualTo(format(attrNs, attrName, resId, "CDATA", value, valueResId));
   }
@@ -156,21 +179,31 @@ http://schemas.android.com/apk/res-auto:title(resId=2130771971) type=CDATA: valu
     for (int i = 0; i < attributeCount; i++) {
       if (namespace.equals(parser.getAttributeNamespace(i))
           && name.equals(parser.getAttributeName(i))) {
-        return format(parser.getAttributeNamespace(i), parser.getAttributeName(i),
-            parser.getAttributeNameResource(i), parser.getAttributeType(i),
-            parser.getAttributeValue(i), parser.getAttributeResourceValue(i, -1));
+        return format(
+            parser.getAttributeNamespace(i),
+            parser.getAttributeName(i),
+            parser.getAttributeNameResource(i),
+            parser.getAttributeType(i),
+            parser.getAttributeValue(i),
+            parser.getAttributeResourceValue(i, -1));
       }
     }
     throw new RuntimeException("not found: " + namespace + ":" + name);
   }
 
-  private String format(String attrNs, String attrName,
-      int attrResId, String type, String value, int valueResId) {
-    return attrNs + ":" + attrName
-        + "(resId=" + attrResId
-        + "): type=" + type
-        + ": value=" + value
-        + "(resId=" + valueResId
+  private String format(
+      String attrNs, String attrName, int attrResId, String type, String value, int valueResId) {
+    return attrNs
+        + ":"
+        + attrName
+        + "(resId="
+        + attrResId
+        + "): type="
+        + type
+        + ": value="
+        + value
+        + "(resId="
+        + valueResId
         + ")";
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/testing/TestActivity.java b/robolectric/src/test/java/org/robolectric/shadows/testing/TestActivity.java
index 260241963..3e2b9f030 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/testing/TestActivity.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/testing/TestActivity.java
@@ -6,7 +6,8 @@ import org.robolectric.R;
 
 /** Activity for tests. */
 public class TestActivity extends Activity {
-  @Override protected void onCreate(Bundle savedInstanceState) {
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     setContentView(R.layout.styles_button_layout);
   }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/testing/TestApplication.java b/robolectric/src/test/java/org/robolectric/shadows/testing/TestApplication.java
index eb023e4f4..e4d925d49 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/testing/TestApplication.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/testing/TestApplication.java
@@ -2,5 +2,4 @@ package org.robolectric.shadows.testing;
 
 import android.app.Application;
 
-public class TestApplication extends Application {
-}
+public class TestApplication extends Application {}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/testing/TestContentProvider1.java b/robolectric/src/test/java/org/robolectric/shadows/testing/TestContentProvider1.java
index b0efcadb6..9f5013d5e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/testing/TestContentProvider1.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/testing/TestContentProvider1.java
@@ -24,7 +24,8 @@ public class TestContentProvider1 extends ContentProvider {
   }
 
   @Override
-  public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
+  public Cursor query(
+      Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
     transcript.add("query for " + uri);
     return null;
   }
diff --git a/robolectric/src/test/java/org/robolectric/test/DummyClass.java b/robolectric/src/test/java/org/robolectric/test/DummyClass.java
index e2e8cb214..ffa65cbc4 100644
--- a/robolectric/src/test/java/org/robolectric/test/DummyClass.java
+++ b/robolectric/src/test/java/org/robolectric/test/DummyClass.java
@@ -3,7 +3,9 @@ package org.robolectric.test;
 import org.robolectric.internal.bytecode.SandboxClassLoader;
 
 /**
- * Dummy class placed in package that is not loaded by parent classloader of {@link SandboxClassLoader}.
+ * Dummy class placed in package that is not loaded by parent classloader of {@link
+ * SandboxClassLoader}.
+ *
  * @see org.robolectric.RobolectricTestRunnerClassLoaderConfigTest#testGetPackage()
  */
 public class DummyClass {
diff --git a/robolectric/src/test/java/org/robolectric/tester/ConfigTestReceiverPermissionsAndActions.java b/robolectric/src/test/java/org/robolectric/tester/ConfigTestReceiverPermissionsAndActions.java
index 98c11720c..4738d20c8 100644
--- a/robolectric/src/test/java/org/robolectric/tester/ConfigTestReceiverPermissionsAndActions.java
+++ b/robolectric/src/test/java/org/robolectric/tester/ConfigTestReceiverPermissionsAndActions.java
@@ -6,6 +6,5 @@ import android.content.Intent;
 
 public class ConfigTestReceiverPermissionsAndActions extends BroadcastReceiver {
   @Override
-  public void onReceive(Context context, Intent intent) {
-  }
+  public void onReceive(Context context, Intent intent) {}
 }
diff --git a/robolectric/src/test/java/org/robolectric/util/TestUtil.java b/robolectric/src/test/java/org/robolectric/util/TestUtil.java
index e1c6ba33e..7fdc0618b 100644
--- a/robolectric/src/test/java/org/robolectric/util/TestUtil.java
+++ b/robolectric/src/test/java/org/robolectric/util/TestUtil.java
@@ -19,8 +19,8 @@ public abstract class TestUtil {
   private static ResourcePath TEST_RESOURCE_PATH;
   private static File testDirLocation;
   private static SdkCollection sdkCollection;
-  private static final Injector injector = new Injector.Builder()
-      .bind(Properties.class, System.getProperties()).build();
+  private static final Injector injector =
+      new Injector.Builder().bind(Properties.class, System.getProperties()).build();
 
   public static Path resourcesBaseDir() {
     return resourcesBaseDirFile().toPath();
@@ -84,5 +84,4 @@ public abstract class TestUtil {
   private static <T> T getInjectedInstance(Class<T> clazz) {
     return injector.getInstance(clazz);
   }
-
 }
diff --git a/robolectric/src/test/resources/AndroidManifest.xml b/robolectric/src/test/resources/AndroidManifest.xml
index 27a3dc9b3..3974af777 100644
--- a/robolectric/src/test/resources/AndroidManifest.xml
+++ b/robolectric/src/test/resources/AndroidManifest.xml
@@ -36,6 +36,7 @@
   <application android:name="org.robolectric.shadows.testing.TestApplication"
          android:theme="@style/Theme.Robolectric"
          android:label="@string/app_name"
+         android:debuggable="true"
          android:allowBackup="true"
          android:allowClearUserData="true"
          android:allowTaskReparenting="true"
@@ -130,6 +131,16 @@
 
     <activity android:name="org.robolectric.shadows.DisabledActivity" android:enabled="false"/>
 
+    <!-- showWhenLocked attribute activities  -->
+
+    <activity
+        android:name="org.robolectric.shadows.ShadowActivityTest$ShowWhenLockedActivity"
+        android:showWhenLocked="true" />
+
+    <activity
+        android:name="org.robolectric.shadows.ShadowActivityTest$DoNotShowWhenLockedActivity"
+        android:showWhenLocked="false" />
+
     <activity-alias
             android:name="org.robolectric.shadows.TestActivityAlias"
             android:targetActivity=".shadows.TestActivity">
diff --git a/robolectric/src/test/resources/resources.ap_ b/robolectric/src/test/resources/resources.ap_
index b34ec69fd..11170d3fe 100644
Binary files a/robolectric/src/test/resources/resources.ap_ and b/robolectric/src/test/resources/resources.ap_ differ
diff --git a/sandbox/build.gradle b/sandbox/build.gradle
index 358b027c2..7c2ffca70 100644
--- a/sandbox/build.gradle
+++ b/sandbox/build.gradle
@@ -1,8 +1,7 @@
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
-apply plugin: DeployedRoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+}
 
 dependencies {
     annotationProcessor libs.auto.service
diff --git a/sandbox/src/main/java/org/robolectric/config/AndroidConfigurer.java b/sandbox/src/main/java/org/robolectric/config/AndroidConfigurer.java
index 1fb7a98d2..da2322c1e 100644
--- a/sandbox/src/main/java/org/robolectric/config/AndroidConfigurer.java
+++ b/sandbox/src/main/java/org/robolectric/config/AndroidConfigurer.java
@@ -46,43 +46,26 @@ public class AndroidConfigurer {
 
     builder
         .doNotAcquireClass("org.robolectric.TestLifecycle")
-        .doNotAcquireClass("org.robolectric.manifest.AndroidManifest")
         .doNotAcquireClass("org.robolectric.RobolectricTestRunner")
-        .doNotAcquireClass("org.robolectric.RobolectricTestRunner.HelperTestRunner")
-        .doNotAcquireClass("org.robolectric.shadow.api.ShadowPicker")
-        .doNotAcquireClass("org.robolectric.res.ResourcePath")
-        .doNotAcquireClass("org.robolectric.res.ResourceTable")
-        .doNotAcquireClass("org.robolectric.ApkLoader")
-        .doNotAcquireClass("org.robolectric.res.builder.XmlBlock");
+        .doNotAcquireClass("org.robolectric.shadow.api.ShadowPicker");
 
     builder
-        .doNotAcquirePackage("javax.")
-        .doNotAcquirePackage("jdk.internal.")
-        .doNotAcquirePackage("org.junit")
+        .doNotAcquirePackage(
+            "com.almworks.sqlite4java") // Fix #958: SQLite native library must be loaded once.
+        .doNotAcquirePackage("io.mockk.proxy.")
+        .doNotAcquirePackage("kotlin.")
+        .doNotAcquirePackage("org.bouncycastle.")
+        .doNotAcquirePackage("org.conscrypt.")
         .doNotAcquirePackage("org.hamcrest")
+        .doNotAcquirePackage("org.jacoco.")
         .doNotAcquirePackage("org.objectweb.asm")
-        .doNotAcquirePackage("org.robolectric.annotation.")
-        .doNotAcquirePackage("org.robolectric.internal.")
-        .doNotAcquirePackage("org.robolectric.pluginapi.")
         .doNotAcquirePackage("org.robolectric.manifest.")
         .doNotAcquirePackage("org.robolectric.res.")
-        .doNotAcquirePackage("org.robolectric.util.")
         .doNotAcquirePackage("org.robolectric.RobolectricTestRunner$")
-        .doNotAcquirePackage("sun.")
-        .doNotAcquirePackage("com.sun.")
         .doNotAcquirePackage("org.w3c.")
         .doNotAcquirePackage("org.xml.")
-        .doNotAcquirePackage(
-            "org.specs2") // allows for android projects with mixed scala\java tests to be
-        .doNotAcquirePackage(
-            "scala.") //  run with Maven Surefire (see the RoboSpecs project on github)
-        .doNotAcquirePackage("kotlin.")
-        .doNotAcquirePackage("io.mockk.proxy.")
-        .doNotAcquirePackage("org.bouncycastle.")
-        .doNotAcquirePackage("org.conscrypt.")
-        // Fix #958: SQLite native library must be loaded once.
-        .doNotAcquirePackage("com.almworks.sqlite4java")
-        .doNotAcquirePackage("org.jacoco.");
+        .doNotAcquirePackage("org.specs2") // Required for Maven SureFire / RoboSpecs.
+        .doNotAcquirePackage("scala."); // Required for Maven SureFire / RoboSpecs.
 
     builder
         .addClassNameTranslation(
diff --git a/sandbox/src/main/java/org/robolectric/fakes/RoboExtendedResponseCache.java b/sandbox/src/main/java/org/robolectric/fakes/RoboExtendedResponseCache.java
index 2e995d213..df2aed85d 100644
--- a/sandbox/src/main/java/org/robolectric/fakes/RoboExtendedResponseCache.java
+++ b/sandbox/src/main/java/org/robolectric/fakes/RoboExtendedResponseCache.java
@@ -20,9 +20,9 @@ import java.net.CacheResponse;
 import java.net.HttpURLConnection;
 
 /**
- * A response cache that supports statistics tracking and updating stored
- * responses. Implementations of {@link java.net.ResponseCache} should implement this
- * interface to receive additional support from the HTTP engine.
+ * A response cache that supports statistics tracking and updating stored responses. Implementations
+ * of {@link java.net.ResponseCache} should implement this interface to receive additional support
+ * from the HTTP engine.
  */
 public interface RoboExtendedResponseCache {
 
@@ -33,9 +33,7 @@ public interface RoboExtendedResponseCache {
    */
   void trackResponse(RoboResponseSource source);
 
-  /**
-   * Track an conditional GET that was satisfied by this cache.
-   */
+  /** Track an conditional GET that was satisfied by this cache. */
   void trackConditionalCacheHit();
 
   /**
diff --git a/sandbox/src/main/java/org/robolectric/fakes/RoboResponseSource.java b/sandbox/src/main/java/org/robolectric/fakes/RoboResponseSource.java
index 3e366a299..7f42416a3 100644
--- a/sandbox/src/main/java/org/robolectric/fakes/RoboResponseSource.java
+++ b/sandbox/src/main/java/org/robolectric/fakes/RoboResponseSource.java
@@ -16,25 +16,19 @@
 
 package org.robolectric.fakes;
 
-/**
- * Where the HTTP client should look for a response.
- */
+/** Where the HTTP client should look for a response. */
 public enum RoboResponseSource {
 
-  /**
-   * Return the response from the cache immediately.
-   */
+  /** Return the response from the cache immediately. */
   CACHE,
 
   /**
-   * Make a conditional request to the host, returning the cache response if
-   * the cache is valid and the network response otherwise.
+   * Make a conditional request to the host, returning the cache response if the cache is valid and
+   * the network response otherwise.
    */
   CONDITIONAL_CACHE,
 
-  /**
-   * Return the response from the network.
-   */
+  /** Return the response from the network. */
   NETWORK;
 
   public boolean requiresConnection() {
diff --git a/sandbox/src/main/java/org/robolectric/interceptors/AndroidInterceptors.java b/sandbox/src/main/java/org/robolectric/interceptors/AndroidInterceptors.java
index 156713d06..e1eab842e 100644
--- a/sandbox/src/main/java/org/robolectric/interceptors/AndroidInterceptors.java
+++ b/sandbox/src/main/java/org/robolectric/interceptors/AndroidInterceptors.java
@@ -108,18 +108,18 @@ public class AndroidInterceptors {
         try {
           FileDescriptor ret = new FileDescriptor();
 
-          moveField(ret, input, "fd", /*movedOutValue=*/ -1);
+          moveField(ret, input, "fd", /* movedOutValue= */ -1);
           // "closed" is irrelevant if the fd is already -1.
-          moveField(ret, input, "closed", /*movedOutValue=*/ false);
+          moveField(ret, input, "closed", /* movedOutValue= */ false);
           // N.B.: FileDescriptor.attach() is not implemented in libcore (yet), so these won't be
           // used.
-          moveField(ret, input, "parent", /*movedOutValue=*/ null);
-          moveField(ret, input, "otherParents", /*movedOutValue=*/ null);
+          moveField(ret, input, "parent", /* movedOutValue= */ null);
+          moveField(ret, input, "otherParents", /* movedOutValue= */ null);
 
           // These only exist on Windows.
           try {
-            moveField(ret, input, "handle", /*movedOutValue=*/ -1);
-            moveField(ret, input, "append", /*movedOutValue=*/ false);
+            moveField(ret, input, "handle", /* movedOutValue= */ -1);
+            moveField(ret, input, "append", /* movedOutValue= */ false);
           } catch (ReflectiveOperationException ex) {
             // Ignore.
           }
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassHandlerBuilder.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassHandlerBuilder.java
index c1f9d1011..1143098bc 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassHandlerBuilder.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassHandlerBuilder.java
@@ -6,9 +6,10 @@ import org.robolectric.util.inject.AutoFactory;
 /**
  * Factory interface for {@link ClassHandler}.
  *
- * To inject your own ClassHandler, annotate a subclass with {@link com.google.auto.service.AutoService}(ClassHandler).
+ * <p>To inject your own ClassHandler, annotate a subclass with {@link
+ * com.google.auto.service.AutoService}(ClassHandler).
  *
- * Robolectric's default ClassHandler is {@link ShadowWrangler}.
+ * <p>Robolectric's default ClassHandler is {@link ShadowWrangler}.
  */
 @AutoFactory
 public interface ClassHandlerBuilder {
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassInstrumentor.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassInstrumentor.java
index 9d3d51af9..646e6edac 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassInstrumentor.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassInstrumentor.java
@@ -149,14 +149,11 @@ public class ClassInstrumentor {
     return instrumentedBytes;
   }
 
-  private void recordPackageStats(PerfStatsCollector perfStats, MutableClass mutableClass) {
-    String className = mutableClass.getName();
-    for (int i = className.indexOf('.'); i != -1; i = className.indexOf('.', i + 1)) {
-      perfStats.incrementCount("instrument package " + className.substring(0, i));
-    }
-  }
-
   public void instrument(MutableClass mutableClass) {
+    if (hasAnyJUnitAnnotation(mutableClass)) {
+      // Detected a JUnit related test class, skip instrumentation
+      return;
+    }
     try {
       // Need Java version >=7 to allow invokedynamic
       mutableClass.classNode.version = Math.max(mutableClass.classNode.version, Opcodes.V1_7);
@@ -199,6 +196,33 @@ public class ClassInstrumentor {
     }
   }
 
+  private void recordPackageStats(PerfStatsCollector perfStats, MutableClass mutableClass) {
+    String className = mutableClass.getName();
+    for (int i = className.indexOf('.'); i != -1; i = className.indexOf('.', i + 1)) {
+      perfStats.incrementCount("instrument package " + className.substring(0, i));
+    }
+  }
+
+  private static boolean hasAnyJUnitAnnotation(MutableClass mutableClass) {
+    for (MethodNode method : mutableClass.getMethods()) {
+      if (method.visibleAnnotations == null) {
+        continue;
+      }
+      if ((method.access & Opcodes.ACC_PUBLIC) == 0) {
+        // Only check public methods.
+        continue;
+      }
+      // Because robolectric will generate private versions of the method for
+      // internal use and any junit annotated method that is private will cause junit to
+      // throw exceptions
+      if (method.visibleAnnotations.stream()
+          .anyMatch(annotation -> annotation.desc.startsWith("Lorg/junit/"))) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   // See https://github.com/robolectric/robolectric/issues/6840
   // Adds Set(int, object) to android.util.SparseArray.
   private void addSetToSparseArray(MutableClass mutableClass) {
@@ -540,6 +564,7 @@ public class ClassInstrumentor {
     generator.endMethod();
     mutableClass.addMethod(delegatorMethodNode);
   }
+
   /**
    * Creates native stub which returns the default return value.
    *
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassNodeProvider.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassNodeProvider.java
index 71d39eff7..044d501ff 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassNodeProvider.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassNodeProvider.java
@@ -23,9 +23,8 @@ public abstract class ClassNodeProvider {
     byte[] byteCode = getClassBytes(internalClassName);
     ClassReader classReader = new ClassReader(byteCode);
     ClassNode classNode = new ClassNode();
-    classReader.accept(classNode,
-        ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
+    classReader.accept(
+        classNode, ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
     return classNode;
   }
-
 }
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassValueMap.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassValueMap.java
index 3a7dff7a1..13915ba77 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassValueMap.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassValueMap.java
@@ -8,14 +8,13 @@ import java.util.WeakHashMap;
 /**
  * {@link java.lang.ClassValue} doesn't exist in Android, so provide a trivial impl.
  *
- * Note that if T contains references to Class, this won't really be weak. That's okay.
+ * <p>Note that if T contains references to Class, this won't really be weak. That's okay.
  */
 abstract class ClassValueMap<T> {
   private final Map<Class<?>, T> map = Collections.synchronizedMap(new WeakHashMap<>());
 
   protected abstract T computeValue(Class<?> type);
 
-  @SuppressWarnings("AndroidJdkLibsChecker")
   public T get(Class<?> type) {
     return map.computeIfAbsent(type, this::computeValue);
   }
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/DirectObjectMarker.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/DirectObjectMarker.java
index f9219b20a..7a69262b4 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/DirectObjectMarker.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/DirectObjectMarker.java
@@ -1,9 +1,7 @@
 package org.robolectric.internal.bytecode;
 
 public class DirectObjectMarker {
-  public static final DirectObjectMarker INSTANCE = new DirectObjectMarker() {
-  };
+  public static final DirectObjectMarker INSTANCE = new DirectObjectMarker() {};
 
-  private DirectObjectMarker() {
-  }
+  private DirectObjectMarker() {}
 }
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentationConfiguration.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentationConfiguration.java
index 276b2438b..e99d354e8 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentationConfiguration.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentationConfiguration.java
@@ -3,7 +3,6 @@ package org.robolectric.internal.bytecode;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -19,24 +18,31 @@ import org.robolectric.annotation.internal.DoNotInstrument;
 import org.robolectric.annotation.internal.Instrument;
 import org.robolectric.shadow.api.Shadow;
 
-/**
- * Configuration rules for {@link SandboxClassLoader}.
- */
+/** Configuration rules for {@link SandboxClassLoader}. */
 public class InstrumentationConfiguration {
 
   public static Builder newBuilder() {
     return new Builder();
   }
 
-  static final Set<String> CLASSES_TO_ALWAYS_ACQUIRE = Sets.newHashSet(
-      RobolectricInternals.class.getName(),
-      InvokeDynamicSupport.class.getName(),
-      Shadow.class.getName(),
-
-      // these classes are deprecated and will be removed soon:
-      "org.robolectric.util.FragmentTestUtil",
-      "org.robolectric.util.FragmentTestUtil$FragmentUtilActivity"
-  );
+  static final ImmutableSet<String> CLASSES_TO_ALWAYS_ACQUIRE =
+      ImmutableSet.of(
+          RobolectricInternals.class.getName(),
+          InvokeDynamicSupport.class.getName(),
+          Shadow.class.getName());
+
+  static final ImmutableSet<String> PACKAGES_TO_NEVER_ACQUIRE =
+      ImmutableSet.of(
+          "com.sun",
+          "java",
+          "javax",
+          "jdk.internal",
+          "org.junit",
+          "org.robolectric.annotation.",
+          "org.robolectric.internal.",
+          "org.robolectric.pluginapi.",
+          "org.robolectric.util.",
+          "sun");
 
   // Must always acquire these as they change from API level to API level
   static final ImmutableSet<String> RESOURCES_TO_ALWAYS_ACQUIRE =
@@ -108,8 +114,8 @@ public class InstrumentationConfiguration {
   /**
    * Determine if {@link SandboxClassLoader} should load a given class.
    *
-   * @param   name The fully-qualified class name.
-   * @return  True if the class should be loaded.
+   * @param name The fully-qualified class name.
+   * @return True if the class should be loaded.
    */
   public boolean shouldAcquire(String name) {
     if (CLASSES_TO_ALWAYS_ACQUIRE.contains(name)) {
@@ -131,13 +137,18 @@ public class InstrumentationConfiguration {
       return true;
     }
 
-    for (String packageName : packagesToNotAcquire) {
-      if (name.startsWith(packageName)) return false;
+    for (String packageName : PACKAGES_TO_NEVER_ACQUIRE) {
+      if (name.startsWith(packageName)) {
+        return false;
+      }
     }
 
-    // R classes must be loaded from system CP
-    boolean isRClass = name.matches(".*\\.R(|\\$[a-z]+)$");
-    return !isRClass && !classesToNotAcquire.contains(name);
+    for (String packageName : packagesToNotAcquire) {
+      if (name.startsWith(packageName)) {
+        return false;
+      }
+    }
+    return !classesToNotAcquire.contains(name);
   }
 
   /**
@@ -194,7 +205,6 @@ public class InstrumentationConfiguration {
     if (!instrumentedClasses.equals(that.instrumentedClasses)) return false;
     if (!interceptedMethods.equals(that.interceptedMethods)) return false;
 
-
     return true;
   }
 
@@ -256,9 +266,7 @@ public class InstrumentationConfiguration {
     public final Collection<String> packagesToNotInstrument = new HashSet<>();
     public String classesToNotInstrumentRegex;
 
-
-    public Builder() {
-    }
+    public Builder() {}
 
     public Builder(InstrumentationConfiguration classLoaderConfig) {
       instrumentedPackages.addAll(classLoaderConfig.instrumentedPackages);
@@ -322,7 +330,6 @@ public class InstrumentationConfiguration {
       return this;
     }
 
-    @SuppressWarnings("AndroidJdkLibsChecker")
     public InstrumentationConfiguration build() {
       // Remove redundant packages, e.g. remove 'android.os' if 'android.' is present.
       List<String> minimalPackages = new ArrayList<>(instrumentedPackages);
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentingClassWriter.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentingClassWriter.java
index 28e64a078..aba8eddd7 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentingClassWriter.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentingClassWriter.java
@@ -6,8 +6,8 @@ import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.tree.ClassNode;
 
 /**
- * ClassWriter implementation that verifies classes by comparing type information obtained
- * from loading the classes as resources. This was taken from the ASM ClassWriter unit tests.
+ * ClassWriter implementation that verifies classes by comparing type information obtained from
+ * loading the classes as resources. This was taken from the ASM ClassWriter unit tests.
  */
 public class InstrumentingClassWriter extends ClassWriter {
 
@@ -27,8 +27,8 @@ public class InstrumentingClassWriter extends ClassWriter {
   }
 
   /**
-   * Returns the common super type of the two given types without actually loading
-   * the classes in the ClassLoader.
+   * Returns the common super type of the two given types without actually loading the classes in
+   * the ClassLoader.
    */
   @Override
   protected String getCommonSuperClass(final String type1, final String type2) {
@@ -61,8 +61,7 @@ public class InstrumentingClassWriter extends ClassWriter {
       while (true) {
         int start1 = b1.lastIndexOf(';', end1 - 1);
         int start2 = b2.lastIndexOf(';', end2 - 1);
-        if (start1 != -1 && start2 != -1
-            && end1 - start1 == end2 - start2) {
+        if (start1 != -1 && start2 != -1 && end1 - start1 == end2 - start2) {
           String p1 = b1.substring(start1 + 1, end1);
           String p2 = b2.substring(start2 + 1, end2);
           if (p1.equals(p2)) {
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/Interceptor.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/Interceptor.java
index 8edee10c2..62deab45a 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/Interceptor.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/Interceptor.java
@@ -17,12 +17,14 @@ public abstract class Interceptor {
     return methodRefs;
   }
 
-  abstract public Function<Object, Object> handle(MethodSignature methodSignature);
+  public abstract Function<Object, Object> handle(MethodSignature methodSignature);
 
-  abstract public MethodHandle getMethodHandle(String methodName, MethodType type) throws NoSuchMethodException, IllegalAccessException;
+  public abstract MethodHandle getMethodHandle(String methodName, MethodType type)
+      throws NoSuchMethodException, IllegalAccessException;
 
   @Nonnull
-  protected static Function<Object, Object> returnDefaultValue(final MethodSignature methodSignature) {
+  protected static Function<Object, Object> returnDefaultValue(
+      final MethodSignature methodSignature) {
     return new Function<Object, Object>() {
       @Override
       public Object call(Class<?> theClass, Object value, Object[] params) {
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/Interceptors.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/Interceptors.java
index 2377c6ca2..f48183cc1 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/Interceptors.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/Interceptors.java
@@ -27,7 +27,8 @@ public class Interceptors {
   }
 
   public Function<Object, Object> getInterceptionHandler(final MethodSignature methodSignature) {
-    Interceptor interceptor = findInterceptor(methodSignature.className, methodSignature.methodName);
+    Interceptor interceptor =
+        findInterceptor(methodSignature.className, methodSignature.methodName);
     if (interceptor != null) {
       return interceptor.handle(methodSignature);
     }
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/MethodCallSite.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/MethodCallSite.java
index df6f3f847..fd800a3d4 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/MethodCallSite.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/MethodCallSite.java
@@ -46,12 +46,16 @@ public class MethodCallSite extends RoboCallSite {
     return isNative;
   }
 
-  @Override public String toString() {
-    return "RoboCallSite{" +
-        "theClass=" + getTheClass() +
-        ", original=" + original +
-        ", kind=" + kind +
-        '}';
+  @Override
+  public String toString() {
+    return "RoboCallSite{"
+        + "theClass="
+        + getTheClass()
+        + ", original="
+        + original
+        + ", kind="
+        + kind
+        + '}';
   }
 
   public enum Kind {
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/MethodRef.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/MethodRef.java
index e2796ecc6..ec1f00ccb 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/MethodRef.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/MethodRef.java
@@ -1,8 +1,6 @@
 package org.robolectric.internal.bytecode;
 
-/**
- * Reference to a specific method on a class.
- */
+/** Reference to a specific method on a class. */
 public class MethodRef {
   public final String className;
   public final String methodName;
@@ -26,7 +24,8 @@ public class MethodRef {
     return className.equals(methodRef.className) && methodName.equals(methodRef.methodName);
   }
 
-  @Override public int hashCode() {
+  @Override
+  public int hashCode() {
     int result = className.hashCode();
     result = 31 * result + methodName.hashCode();
     return result;
@@ -34,9 +33,13 @@ public class MethodRef {
 
   @Override
   public String toString() {
-    return "MethodRef{" +
-        "className='" + className + '\'' +
-        ", methodName='" + methodName + '\'' +
-        '}';
+    return "MethodRef{"
+        + "className='"
+        + className
+        + '\''
+        + ", methodName='"
+        + methodName
+        + '\''
+        + '}';
   }
 }
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/MethodSignature.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/MethodSignature.java
index afc4e2c86..e3835ea8b 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/MethodSignature.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/MethodSignature.java
@@ -9,7 +9,8 @@ public class MethodSignature {
   public final String[] paramTypes;
   public final String returnType;
 
-  private MethodSignature(String className, String methodName, String[] paramTypes, String returnType) {
+  private MethodSignature(
+      String className, String methodName, String[] paramTypes, String returnType) {
     this.className = className;
     this.methodName = methodName;
     this.paramTypes = paramTypes;
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ProxyMaker.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ProxyMaker.java
index 9741ee129..5b09aaaa2 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ProxyMaker.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ProxyMaker.java
@@ -123,7 +123,7 @@ public class ProxyMaker {
     String targetName = targetType.getInternalName();
     String proxyName = targetName + "$GeneratedProxy";
     Type proxyType = Type.getType("L" + proxyName.replace('.', '/') + ";");
-    ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_FRAMES| ClassWriter.COMPUTE_MAXS);
+    ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
     writer.visit(
         V1_7,
         ACC_PUBLIC | ACC_SYNTHETIC | ACC_SUPER | ACC_FINAL,
@@ -150,7 +150,8 @@ public class ProxyMaker {
       // If an invokespecial instruction names a method which is not an instance
       // initialization method, then the type of the target reference on the operand
       // stack must be assignment compatible with the current class (JLS 5.2).
-      m.visitMethodInsn(INVOKEVIRTUAL, targetName, targetMethod, proxyMethod.getDescriptor(), false);
+      m.visitMethodInsn(
+          INVOKEVIRTUAL, targetName, targetMethod, proxyMethod.getDescriptor(), false);
       m.returnValue();
       m.endMethod();
     }
@@ -173,7 +174,8 @@ public class ProxyMaker {
       final Class<?> proxyClass = defineHiddenClass(targetClass, bytecode);
       final Field field = proxyClass.getDeclaredField(TARGET_FIELD);
       return new Factory() {
-        @Override public <E> E createProxy(Class<E> targetClass, E target) {
+        @Override
+        public <E> E createProxy(Class<E> targetClass, E target) {
           try {
             Object proxy = UNSAFE.allocateInstance(proxyClass);
 
@@ -205,8 +207,10 @@ public class ProxyMaker {
 
   private static boolean shouldProxy(java.lang.reflect.Method method) {
     int modifiers = method.getModifiers();
-    return !Modifier.isAbstract(modifiers) && !Modifier.isFinal(modifiers) && !Modifier.isPrivate(
-        modifiers) && !Modifier.isNative(modifiers);
+    return !Modifier.isAbstract(modifiers)
+        && !Modifier.isFinal(modifiers)
+        && !Modifier.isPrivate(modifiers)
+        && !Modifier.isNative(modifiers);
   }
 
   interface MethodMapper {
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/RobolectricGeneratorAdapter.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/RobolectricGeneratorAdapter.java
index e6c63b2f5..979457d11 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/RobolectricGeneratorAdapter.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/RobolectricGeneratorAdapter.java
@@ -10,9 +10,7 @@ import org.objectweb.asm.commons.GeneratorAdapter;
 import org.objectweb.asm.tree.MethodNode;
 import org.robolectric.internal.bytecode.ClassInstrumentor.TryCatch;
 
-/**
- * GeneratorAdapter implementation specific to generate code for Robolectric purposes
- */
+/** GeneratorAdapter implementation specific to generate code for Robolectric purposes */
 public class RobolectricGeneratorAdapter extends GeneratorAdapter {
   final boolean isStatic;
   private final String desc;
@@ -52,7 +50,10 @@ public class RobolectricGeneratorAdapter extends GeneratorAdapter {
   public void pushDefaultReturnValueToStack(Type type) {
     if (type.equals(Type.BOOLEAN_TYPE)) {
       push(false);
-    } else if (type.equals(Type.INT_TYPE) || type.equals(Type.SHORT_TYPE) || type.equals(Type.BYTE_TYPE) || type.equals(Type.CHAR_TYPE)) {
+    } else if (type.equals(Type.INT_TYPE)
+        || type.equals(Type.SHORT_TYPE)
+        || type.equals(Type.BYTE_TYPE)
+        || type.equals(Type.CHAR_TYPE)) {
       push(0);
     } else if (type.equals(Type.LONG_TYPE)) {
       push(0L);
@@ -71,11 +72,11 @@ public class RobolectricGeneratorAdapter extends GeneratorAdapter {
 
   void invokeMethod(String internalClassName, String methodName, String methodDesc) {
     if (isStatic()) {
-      loadArgs();                                             // this, [args]
+      loadArgs(); // this, [args]
       visitMethodInsn(Opcodes.INVOKESTATIC, internalClassName, methodName, methodDesc, false);
     } else {
-      loadThisOrNull();                                       // this
-      loadArgs();                                             // this, [args]
+      loadThisOrNull(); // this
+      loadArgs(); // this, [args]
       visitMethodInsn(Opcodes.INVOKESPECIAL, internalClassName, methodName, methodDesc, false);
     }
   }
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxClassLoader.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxClassLoader.java
index 3309d480d..35deebccf 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxClassLoader.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxClassLoader.java
@@ -147,25 +147,14 @@ public class SandboxClassLoader extends URLClassLoader {
   }
 
   protected Class<?> maybeInstrumentClass(String className) throws ClassNotFoundException {
-    final byte[] origClassBytes = getByteCode(className);
-
-    try {
-      final byte[] bytes;
-      ClassDetails classDetails = new ClassDetails(origClassBytes);
-      if (config.shouldInstrument(classDetails)) {
-        bytes = classInstrumentor.instrument(classDetails, config, classNodeProvider);
-        maybeDumpClassBytes(classDetails, bytes);
-      } else {
-        bytes = postProcessUninstrumentedClass(classDetails);
-      }
-      ensurePackage(className);
-      return defineClass(className, bytes, 0, bytes.length);
-    } catch (Exception e) {
-      throw new ClassNotFoundException("couldn't load " + className, e);
-    } catch (OutOfMemoryError e) {
-      System.err.println("[ERROR] couldn't load " + className + " in " + this);
-      throw e;
+    byte[] classBytes = getByteCode(className);
+    ClassDetails classDetails = new ClassDetails(classBytes);
+    if (config.shouldInstrument(classDetails)) {
+      classBytes = classInstrumentor.instrument(classDetails, config, classNodeProvider);
+      maybeDumpClassBytes(classDetails, classBytes);
     }
+    ensurePackage(className);
+    return defineClass(className, classBytes, 0, classBytes.length);
   }
 
   private void maybeDumpClassBytes(ClassDetails classDetails, byte[] classBytes) {
@@ -181,10 +170,6 @@ public class SandboxClassLoader extends URLClassLoader {
     }
   }
 
-  protected byte[] postProcessUninstrumentedClass(ClassDetails classDetails) {
-    return classDetails.getClassBytes();
-  }
-
   protected byte[] getByteCode(String className) throws ClassNotFoundException {
     String classFilename = className.replace('.', '/') + ".class";
     try (InputStream classBytesStream = getClassBytesAsStreamPreferringLocalUrls(classFilename)) {
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxConfig.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxConfig.java
index 60251bd26..48ea4d050 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxConfig.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxConfig.java
@@ -7,9 +7,7 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-/**
- * Configuration settings that can be used on a per-class or per-test basis.
- */
+/** Configuration settings that can be used on a per-class or per-test basis. */
 @Documented
 @Inherited
 @Retention(RetentionPolicy.RUNTIME)
@@ -20,12 +18,12 @@ public @interface SandboxConfig {
    *
    * @return A list of additional shadow classes to enable.
    */
-  Class<?>[] shadows() default {};  // DEFAULT_SHADOWS
+  Class<?>[] shadows() default {}; // DEFAULT_SHADOWS
 
   /**
    * A list of instrumented packages, in addition to those that are already instrumented.
    *
    * @return A list of additional instrumented packages.
    */
-  String[] instrumentedPackages() default {};  // DEFAULT_INSTRUMENTED_PACKAGES
+  String[] instrumentedPackages() default {}; // DEFAULT_INSTRUMENTED_PACKAGES
 }
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowImpl.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowImpl.java
index 5a5bb32b2..4f3de9e9f 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowImpl.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowImpl.java
@@ -14,13 +14,15 @@ public class ShadowImpl implements IShadow {
     return (T) ((ShadowedObject) instance).$$robo$getData();
   }
 
-  @Override public <T> T newInstanceOf(Class<T> clazz) {
+  @Override
+  public <T> T newInstanceOf(Class<T> clazz) {
     return ReflectionHelpers.callConstructor(clazz);
   }
 
   @Override
   public <T> T newInstance(Class<T> clazz, Class<?>[] parameterTypes, Object[] params) {
-    return ReflectionHelpers.callConstructor(clazz, ReflectionHelpers.ClassParameter.fromComponentLists(parameterTypes, params));
+    return ReflectionHelpers.callConstructor(
+        clazz, ReflectionHelpers.ClassParameter.fromComponentLists(parameterTypes, params));
   }
 
   /**
@@ -88,9 +90,10 @@ public class ShadowImpl implements IShadow {
 
   @Override
   public String directMethodName(String className, String methodName) {
-     return ShadowConstants.ROBO_PREFIX
-      + className.replace('.', '_').replace('$', '_')
-      + "$" + methodName;
+    return ShadowConstants.ROBO_PREFIX
+        + className.replace('.', '_').replace('$', '_')
+        + "$"
+        + methodName;
   }
 
   @Override
@@ -106,5 +109,4 @@ public class ShadowImpl implements IShadow {
       throw new RuntimeException("failed to initialize " + clazz, e);
     }
   }
-
 }
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowInfo.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowInfo.java
index b82c25b33..21cafea8b 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowInfo.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowInfo.java
@@ -35,9 +35,7 @@ public class ShadowInfo {
     this.minSdk = minSdk;
     this.maxSdk = maxSdk;
     this.shadowPickerClass =
-        DefaultShadowPicker.class.equals(shadowPickerClass)
-            ? null
-            : shadowPickerClass;
+        DefaultShadowPicker.class.equals(shadowPickerClass) ? null : shadowPickerClass;
   }
 
   ShadowInfo(String shadowedClassName, String shadowClassName, Implements annotation) {
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowInvalidator.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowInvalidator.java
index 6baa7e57d..a1a7343a1 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowInvalidator.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowInvalidator.java
@@ -9,7 +9,7 @@ public class ShadowInvalidator {
   private static final SwitchPoint DUMMY = new SwitchPoint();
 
   static {
-    SwitchPoint.invalidateAll(new SwitchPoint[] { DUMMY });
+    SwitchPoint.invalidateAll(new SwitchPoint[] {DUMMY});
   }
 
   private Map<String, SwitchPoint> switchPoints;
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowMap.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowMap.java
index 60b2f10a9..54467f9cb 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowMap.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowMap.java
@@ -34,7 +34,6 @@ public class ShadowMap {
   private final ImmutableMap<String, ShadowInfo> overriddenShadows;
   private final ImmutableMap<String, String> shadowPickers;
 
-  @SuppressWarnings("AndroidJdkLibsChecker")
   public static ShadowMap createFromShadowProviders(List<ShadowProvider> sortedProviders) {
     final ArrayListMultimap<String, String> shadowMap = ArrayListMultimap.create();
     final Map<String, String> shadowPickerMap = new HashMap<>();
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowProviders.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowProviders.java
index 2abcdab2b..a79db8288 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowProviders.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowProviders.java
@@ -12,7 +12,6 @@ import javax.annotation.Priority;
 import org.robolectric.internal.ShadowProvider;
 
 /** The set of {@link ShadowProvider} implementations found on the classpath. */
-@SuppressWarnings("AndroidJdkLibsChecker")
 public class ShadowProviders {
 
   private final ImmutableList<ShadowProvider> shadowProviders;
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowWrangler.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowWrangler.java
index b43d2f42d..1be9a90e3 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowWrangler.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowWrangler.java
@@ -9,6 +9,7 @@ import static org.robolectric.util.reflector.Reflector.reflector;
 
 import com.google.auto.service.AutoService;
 import com.google.errorprone.annotations.Keep;
+import java.lang.annotation.Annotation;
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
@@ -22,6 +23,8 @@ import java.util.Arrays;
 import java.util.List;
 import javax.annotation.Nonnull;
 import javax.annotation.Priority;
+import org.robolectric.annotation.ClassName;
+import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.annotation.ReflectorObject;
 import org.robolectric.sandbox.ShadowMatcher;
@@ -226,7 +229,6 @@ public class ShadowWrangler implements ClassHandler {
             });
   }
 
-  @SuppressWarnings({"AndroidJdkLibsChecker"})
   private MethodHandles.Lookup privateLookupFor(Class<?> lookupClass)
       throws IllegalAccessException {
     if (HAS_PRIVATE_LOOKUP_IN) {
@@ -277,6 +279,7 @@ public class ShadowWrangler implements ClassHandler {
       Class<?> shadowClass) {
     Method method =
         findShadowMethodDeclaredOnClass(shadowClass, name, types, shadowInfo.looseSignatures);
+
     if (method != null) {
       return method;
     } else {
@@ -301,7 +304,9 @@ public class ShadowWrangler implements ClassHandler {
   private Method findShadowMethodDeclaredOnClass(
       Class<?> shadowClass, String methodName, Class<?>[] paramClasses, boolean looseSignatures) {
     Method foundMethod = null;
-    for (Method method : shadowClass.getDeclaredMethods()) {
+    // Try to find shadow method with exact method name and looseSignature.
+    Method[] methods = shadowClass.getDeclaredMethods();
+    for (Method method : methods) {
       if (!method.getName().equals(methodName)
           || method.getParameterCount() != paramClasses.length) {
         continue;
@@ -318,6 +323,7 @@ public class ShadowWrangler implements ClassHandler {
         foundMethod = method;
         break;
       }
+
       if (looseSignatures) {
         boolean allParameterTypesAreObject = true;
         for (Class<?> paramClass : method.getParameterTypes()) {
@@ -330,6 +336,31 @@ public class ShadowWrangler implements ClassHandler {
           // Found a looseSignatures match, but continue looking for an exact match.
           foundMethod = method;
         }
+      } else {
+        // Or maybe support @ClassName.
+        if (parameterClassNameMatch(method, paramClasses) && shadowMatcher.matches(method)) {
+          // Found a @ClassName match, but continue looking for an exact match.
+          foundMethod = method;
+        }
+      }
+    }
+
+    if (foundMethod == null) {
+      // Try to find shadow method with Implementation#methodName's mapping name
+      for (Method method : methods) {
+        Implementation implementation = method.getAnnotation(Implementation.class);
+        if (implementation == null) {
+          continue;
+        }
+        String mappedMethodName = implementation.methodName().trim();
+        if (mappedMethodName.isEmpty() || !mappedMethodName.equals(methodName)) {
+          continue;
+        }
+        if (Arrays.equals(method.getParameterTypes(), paramClasses)
+            || parameterClassNameMatch(method, paramClasses)) {
+          foundMethod = method;
+          break;
+        }
       }
     }
 
@@ -341,6 +372,37 @@ public class ShadowWrangler implements ClassHandler {
     }
   }
 
+  /**
+   * Check whether the parameters (which could be @ClassName annotated) of the {@code method}
+   * matches {@code paramClasses}.
+   */
+  private boolean parameterClassNameMatch(Method method, Class<?>[] paramClasses) {
+    Class<?>[] parameterTypes = method.getParameterTypes();
+    if (parameterTypes.length != paramClasses.length) {
+      return false;
+    }
+
+    Annotation[][] annotations = method.getParameterAnnotations();
+    for (int i = 0; i < paramClasses.length; ++i) {
+      if (parameterTypes[i].equals(paramClasses[i])) {
+        continue;
+      }
+      if (!parameterTypes[i].equals(Object.class)) {
+        return false; // @ClassName only applicable to parameter of Object type
+      }
+      boolean matches = false;
+      for (Annotation annotation : annotations[i]) {
+        if (annotation instanceof ClassName) {
+          matches = ((ClassName) annotation).value().equals(paramClasses[i].getName());
+          break;
+        }
+      }
+      if (!matches) {
+        return false;
+      }
+    }
+    return true;
+  }
 
   @Override
   public Object intercept(String signature, Object instance, Object[] params, Class theClass)
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/TypeMapper.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/TypeMapper.java
index e42ca79b1..34d74ab05 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/TypeMapper.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/TypeMapper.java
@@ -77,7 +77,8 @@ class TypeMapper {
 
         remappedName = remapParamType(internalName.substring(count));
         if (remappedName != null) {
-          return Type.getObjectType(internalName.substring(0, count) + remappedName).getDescriptor();
+          return Type.getObjectType(internalName.substring(0, count) + remappedName)
+              .getDescriptor();
         }
         break;
 
diff --git a/sandbox/src/main/java/org/robolectric/sandbox/AlwaysTrueShadowMatcher.java b/sandbox/src/main/java/org/robolectric/sandbox/AlwaysTrueShadowMatcher.java
index 364999993..54ab2b45c 100644
--- a/sandbox/src/main/java/org/robolectric/sandbox/AlwaysTrueShadowMatcher.java
+++ b/sandbox/src/main/java/org/robolectric/sandbox/AlwaysTrueShadowMatcher.java
@@ -1,8 +1,7 @@
 package org.robolectric.sandbox;
 
-import org.robolectric.internal.bytecode.ShadowInfo;
-
 import java.lang.reflect.Method;
+import org.robolectric.internal.bytecode.ShadowInfo;
 
 class AlwaysTrueShadowMatcher implements ShadowMatcher {
   @Override
diff --git a/sandbox/src/main/java/org/robolectric/sandbox/ShadowMatcher.java b/sandbox/src/main/java/org/robolectric/sandbox/ShadowMatcher.java
index ea552258c..f67fd847f 100644
--- a/sandbox/src/main/java/org/robolectric/sandbox/ShadowMatcher.java
+++ b/sandbox/src/main/java/org/robolectric/sandbox/ShadowMatcher.java
@@ -1,12 +1,11 @@
 package org.robolectric.sandbox;
 
-import org.robolectric.internal.bytecode.ShadowInfo;
-
 import java.lang.reflect.Method;
+import org.robolectric.internal.bytecode.ShadowInfo;
 
 /**
- * ShadowMatcher is used by {@link org.robolectric.internal.bytecode.ShadowWrangler} to provide library-specific
- * rules about whether shadow classes and methods should be considered matches.
+ * ShadowMatcher is used by {@link org.robolectric.internal.bytecode.ShadowWrangler} to provide
+ * library-specific rules about whether shadow classes and methods should be considered matches.
  */
 public interface ShadowMatcher {
   ShadowMatcher MATCH_ALL = new AlwaysTrueShadowMatcher();
diff --git a/sandbox/src/main/java/org/robolectric/util/Function.java b/sandbox/src/main/java/org/robolectric/util/Function.java
index 49ccad1f0..a8721835c 100644
--- a/sandbox/src/main/java/org/robolectric/util/Function.java
+++ b/sandbox/src/main/java/org/robolectric/util/Function.java
@@ -1,8 +1,6 @@
 package org.robolectric.util;
 
-/**
- * Interface defining a function object.
- */
+/** Interface defining a function object. */
 public interface Function<R, T> {
   R call(Class<?> theClass, T value, Object[] params);
 }
diff --git a/sandbox/src/main/java/org/robolectric/util/JavaVersion.java b/sandbox/src/main/java/org/robolectric/util/JavaVersion.java
index 7f47b0acd..641368764 100644
--- a/sandbox/src/main/java/org/robolectric/util/JavaVersion.java
+++ b/sandbox/src/main/java/org/robolectric/util/JavaVersion.java
@@ -15,7 +15,8 @@ public class JavaVersion implements Comparable<JavaVersion> {
     }
   }
 
-  @Override public int compareTo(JavaVersion o) {
+  @Override
+  public int compareTo(JavaVersion o) {
     List<Integer> versions2 = o.versions;
     int max = Math.min(versions.size(), versions2.size());
     for (int i = 0; i < max; i++) {
diff --git a/sandbox/src/test/java/org/robolectric/ClassicSuperHandlingTest.java b/sandbox/src/test/java/org/robolectric/ClassicSuperHandlingTest.java
index 0441b9be6..d0c85290c 100644
--- a/sandbox/src/test/java/org/robolectric/ClassicSuperHandlingTest.java
+++ b/sandbox/src/test/java/org/robolectric/ClassicSuperHandlingTest.java
@@ -28,7 +28,8 @@ public class ClassicSuperHandlingTest {
   @Implements(Child.class)
   public static class ChildShadow extends ParentShadow {
 
-    @Override public String method(String value) {
+    @Override
+    public String method(String value) {
       return "3s-" + super.method(value);
     }
   }
@@ -36,7 +37,8 @@ public class ClassicSuperHandlingTest {
   @Implements(Parent.class)
   public static class ParentShadow extends GrandparentShadow {
 
-    @Override public String method(String value) {
+    @Override
+    public String method(String value) {
       return "2s-" + super.method(value);
     }
   }
@@ -58,14 +60,16 @@ public class ClassicSuperHandlingTest {
 
   @Instrument
   public static class Child extends Parent {
-    @Override public String method(String value) {
+    @Override
+    public String method(String value) {
       throw new RuntimeException("Stub!");
     }
   }
 
   @Instrument
   public static class Parent extends Grandparent {
-    @Override public String method(String value) {
+    @Override
+    public String method(String value) {
       throw new RuntimeException("Stub!");
     }
   }
diff --git a/sandbox/src/test/java/org/robolectric/JavaVersionTest.java b/sandbox/src/test/java/org/robolectric/JavaVersionTest.java
index c312d43ab..fde4e6660 100644
--- a/sandbox/src/test/java/org/robolectric/JavaVersionTest.java
+++ b/sandbox/src/test/java/org/robolectric/JavaVersionTest.java
@@ -47,5 +47,4 @@ public class JavaVersionTest {
   private static void checkEqual(String v1, String v2) {
     assertThat(new JavaVersion(v1).compareTo(new JavaVersion(v2))).isEqualTo(0);
   }
-
-}
\ No newline at end of file
+}
diff --git a/sandbox/src/test/java/org/robolectric/RealApisTest.java b/sandbox/src/test/java/org/robolectric/RealApisTest.java
index 88c874a9e..600a791d0 100644
--- a/sandbox/src/test/java/org/robolectric/RealApisTest.java
+++ b/sandbox/src/test/java/org/robolectric/RealApisTest.java
@@ -14,13 +14,13 @@ import org.robolectric.testing.Pony;
 public class RealApisTest {
   @Test
   @SandboxConfig(shadows = {ShimmeryShadowPony.class})
-  public void whenShadowHandlerIsInRealityBasedMode_shouldNotCallRealForUnshadowedMethod() throws Exception {
+  public void whenShadowHandlerIsInRealityBasedMode_shouldNotCallRealForUnshadowedMethod()
+      throws Exception {
     assertEquals("Off I saunter to the salon!", new Pony().saunter("the salon"));
   }
 
   @Implements(Pony.class)
-  public static class ShimmeryShadowPony extends Pony.ShadowPony {
-  }
+  public static class ShimmeryShadowPony extends Pony.ShadowPony {}
 
   @Test
   @SandboxConfig(shadows = {ShadowOfClassWithSomeConstructors.class})
@@ -39,6 +39,5 @@ public class RealApisTest {
   }
 
   @Implements(ClassWithSomeConstructors.class)
-  public static class ShadowOfClassWithSomeConstructors {
-  }
+  public static class ShadowOfClassWithSomeConstructors {}
 }
diff --git a/sandbox/src/test/java/org/robolectric/ShadowWranglerIntegrationTest.java b/sandbox/src/test/java/org/robolectric/ShadowWranglerIntegrationTest.java
index a9a810baa..39630fd27 100644
--- a/sandbox/src/test/java/org/robolectric/ShadowWranglerIntegrationTest.java
+++ b/sandbox/src/test/java/org/robolectric/ShadowWranglerIntegrationTest.java
@@ -9,6 +9,7 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.internal.Instrument;
@@ -26,28 +27,31 @@ public class ShadowWranglerIntegrationTest {
   private String name;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     name = "context";
   }
 
   @Test
-  @SandboxConfig(shadows = {ShadowForAClassWithDefaultConstructor_HavingNoConstructorDelegate.class})
-  public void testConstructorInvocation_WithDefaultConstructorAndNoConstructorDelegateOnShadowClass() throws Exception {
+  @SandboxConfig(
+      shadows = {ShadowForAClassWithDefaultConstructor_HavingNoConstructorDelegate.class})
+  public void
+      testConstructorInvocation_WithDefaultConstructorAndNoConstructorDelegateOnShadowClass() {
     AClassWithDefaultConstructor instance = new AClassWithDefaultConstructor();
-    assertThat(Shadow.<Object>extract(instance)).isInstanceOf(ShadowForAClassWithDefaultConstructor_HavingNoConstructorDelegate.class);
+    assertThat(Shadow.<Object>extract(instance))
+        .isInstanceOf(ShadowForAClassWithDefaultConstructor_HavingNoConstructorDelegate.class);
     assertThat(instance.initialized).isTrue();
   }
 
   @Test
-  @SandboxConfig(shadows = { ShadowFoo.class })
-  public void testConstructorInvocation() throws Exception {
+  @SandboxConfig(shadows = {ShadowFoo.class})
+  public void testConstructorInvocation() {
     Foo foo = new Foo(name);
     assertSame(name, shadowOf(foo).name);
   }
 
   @Test
   @SandboxConfig(shadows = {ShadowFoo.class})
-  public void testRealObjectAnnotatedFieldsAreSetBeforeConstructorIsCalled() throws Exception {
+  public void testRealObjectAnnotatedFieldsAreSetBeforeConstructorIsCalled() {
     Foo foo = new Foo(name);
     assertSame(name, shadowOf(foo).name);
     assertSame(foo, shadowOf(foo).realFooField);
@@ -58,14 +62,14 @@ public class ShadowWranglerIntegrationTest {
 
   @Test
   @SandboxConfig(shadows = {ShadowFoo.class})
-  public void testMethodDelegation() throws Exception {
+  public void testMethodDelegation() {
     Foo foo = new Foo(name);
     assertSame(name, foo.getName());
   }
 
   @Test
   @SandboxConfig(shadows = {WithEquals.class})
-  public void testEqualsMethodDelegation() throws Exception {
+  public void testEqualsMethodDelegation() {
     Foo foo1 = new Foo(name);
     Foo foo2 = new Foo(name);
     assertEquals(foo1, foo2);
@@ -73,35 +77,35 @@ public class ShadowWranglerIntegrationTest {
 
   @Test
   @SandboxConfig(shadows = {WithEquals.class})
-  public void testHashCodeMethodDelegation() throws Exception {
+  public void testHashCodeMethodDelegation() {
     Foo foo = new Foo(name);
     assertEquals(42, foo.hashCode());
   }
 
   @Test
   @SandboxConfig(shadows = {WithToString.class})
-  public void testToStringMethodDelegation() throws Exception {
+  public void testToStringMethodDelegation() {
     Foo foo = new Foo(name);
     assertEquals("the expected string", foo.toString());
   }
 
   @Test
   @SandboxConfig(shadows = {ShadowFoo.class})
-  public void testShadowSelectionSearchesSuperclasses() throws Exception {
+  public void testShadowSelectionSearchesSuperclasses() {
     TextFoo textFoo = new TextFoo(name);
     assertEquals(ShadowFoo.class, Shadow.extract(textFoo).getClass());
   }
 
   @Test
   @SandboxConfig(shadows = {ShadowFoo.class, ShadowTextFoo.class})
-  public void shouldUseMostSpecificShadow() throws Exception {
+  public void shouldUseMostSpecificShadow() {
     TextFoo textFoo = new TextFoo(name);
     assertThat(shadowOf(textFoo)).isInstanceOf(ShadowTextFoo.class);
   }
 
   @Test
   @SandboxConfig(shadows = ShadowThrowInShadowMethod.class)
-  public void shouldRemoveNoiseFromShadowedStackTraces() throws Exception {
+  public void shouldRemoveNoiseFromShadowedStackTraces() {
     ThrowInShadowMethod instance = new ThrowInShadowMethod();
 
     Exception e = null;
@@ -124,15 +128,15 @@ public class ShadowWranglerIntegrationTest {
     assertThat(stackTrace[1].getMethodName()).isEqualTo("method");
     assertThat(stackTrace[1].getLineNumber()).isLessThan(0);
 
-    assertThat(stackTrace[2].getClassName()).isEqualTo(ShadowWranglerIntegrationTest.class.getName());
+    assertThat(stackTrace[2].getClassName())
+        .isEqualTo(ShadowWranglerIntegrationTest.class.getName());
     assertThat(stackTrace[2].getMethodName()).isEqualTo("shouldRemoveNoiseFromShadowedStackTraces");
     assertThat(stackTrace[2].getLineNumber()).isGreaterThan(0);
   }
 
   @Instrument
   public static class ThrowInShadowMethod {
-    public void method() throws IOException {
-    }
+    public void method() throws IOException {}
   }
 
   @Implements(ThrowInShadowMethod.class)
@@ -142,10 +146,9 @@ public class ShadowWranglerIntegrationTest {
     }
   }
 
-
   @Test
   @SandboxConfig(shadows = ShadowThrowInRealMethod.class)
-  public void shouldRemoveNoiseFromUnshadowedStackTraces() throws Exception {
+  public void shouldRemoveNoiseFromUnshadowedStackTraces() {
     ThrowInRealMethod instance = new ThrowInRealMethod();
 
     Exception e = null;
@@ -164,7 +167,8 @@ public class ShadowWranglerIntegrationTest {
     assertThat(stackTrace[0].getMethodName()).isEqualTo("method");
     assertThat(stackTrace[0].getLineNumber()).isGreaterThan(0);
 
-    assertThat(stackTrace[1].getClassName()).isEqualTo(ShadowWranglerIntegrationTest.class.getName());
+    assertThat(stackTrace[1].getClassName())
+        .isEqualTo(ShadowWranglerIntegrationTest.class.getName());
     assertThat(stackTrace[1].getMethodName())
         .isEqualTo("shouldRemoveNoiseFromUnshadowedStackTraces");
     assertThat(stackTrace[1].getLineNumber()).isGreaterThan(0);
@@ -178,26 +182,32 @@ public class ShadowWranglerIntegrationTest {
   }
 
   @Implements(ThrowInRealMethod.class)
-  public static class ShadowThrowInRealMethod {
-  }
+  public static class ShadowThrowInRealMethod {}
 
-  @Test @SandboxConfig(shadows = {Shadow2OfChild.class, ShadowOfParent.class})
-  public void whenShadowMethodIsOverriddenInShadowWithSameShadowedClass_shouldUseOverriddenMethod() throws Exception {
+  @Test
+  @SandboxConfig(shadows = {Shadow2OfChild.class, ShadowOfParent.class})
+  public void
+      whenShadowMethodIsOverriddenInShadowWithSameShadowedClass_shouldUseOverriddenMethod() {
     assertThat(new Child().get()).isEqualTo("get from Shadow2OfChild");
   }
 
-  @Test @SandboxConfig(shadows = {Shadow22OfChild.class, ShadowOfParent.class})
-  public void whenShadowMethodIsNotOverriddenInShadowWithSameShadowedClass_shouldUseOverriddenMethod() throws Exception {
+  @Test
+  @SandboxConfig(shadows = {Shadow22OfChild.class, ShadowOfParent.class})
+  public void
+      whenShadowMethodIsNotOverriddenInShadowWithSameShadowedClass_shouldUseOverriddenMethod() {
     assertThat(new Child().get()).isEqualTo("get from Shadow2OfChild");
   }
 
-  @Test @SandboxConfig(shadows = {Shadow3OfChild.class, ShadowOfParent.class})
-  public void whenShadowMethodIsOverriddenInShadowOfAnotherClass_shouldNotUseShadowSuperclassMethods() throws Exception {
+  @Test
+  @SandboxConfig(shadows = {Shadow3OfChild.class, ShadowOfParent.class})
+  public void
+      whenShadowMethodIsOverriddenInShadowOfAnotherClass_shouldNotUseShadowSuperclassMethods() {
     assertThat(new Child().get()).isEqualTo("from child (from shadow of parent)");
   }
 
-  @Test @SandboxConfig(shadows = {ShadowOfParentWithPackageImpl.class})
-  public void whenShadowMethodIsntCorrectlyVisible_shouldNotUseShadowMethods() throws Exception {
+  @Test
+  @SandboxConfig(shadows = {ShadowOfParentWithPackageImpl.class})
+  public void whenShadowMethodIsntCorrectlyVisible_shouldNotUseShadowMethods() {
     assertThat(new Parent().get()).isEqualTo("from parent");
   }
 
@@ -251,11 +261,9 @@ public class ShadowWranglerIntegrationTest {
   }
 
   @Implements(value = Child.class)
-  public static class Shadow22OfChild extends Shadow2OfChild {
-  }
+  public static class Shadow22OfChild extends Shadow2OfChild {}
 
-  public static class SomethingOtherThanChild extends Child {
-  }
+  public static class SomethingOtherThanChild extends Child {}
 
   @Implements(value = SomethingOtherThanChild.class)
   public static class Shadow3OfChild extends ShadowOfChild {
@@ -277,8 +285,7 @@ public class ShadowWranglerIntegrationTest {
   @Implements(Foo.class)
   public static class WithEquals {
     @Implementation
-    protected void __constructor__(String s) {
-    }
+    protected void __constructor__(String s) {}
 
     @Override
     @Implementation
@@ -291,14 +298,12 @@ public class ShadowWranglerIntegrationTest {
     public int hashCode() {
       return 42;
     }
-
   }
 
   @Implements(Foo.class)
   public static class WithToString {
     @Implementation
-    protected void __constructor__(String s) {
-    }
+    protected void __constructor__(String s) {}
 
     @Override
     @Implementation
@@ -308,8 +313,7 @@ public class ShadowWranglerIntegrationTest {
   }
 
   @Implements(TextFoo.class)
-  public static class ShadowTextFoo extends ShadowFoo {
-  }
+  public static class ShadowTextFoo extends ShadowFoo {}
 
   @Instrument
   public static class TextFoo extends Foo {
@@ -328,14 +332,21 @@ public class ShadowWranglerIntegrationTest {
   }
 
   @Implements(AClassWithDefaultConstructor.class)
-  public static class ShadowForAClassWithDefaultConstructor_HavingNoConstructorDelegate {
-  }
+  public static class ShadowForAClassWithDefaultConstructor_HavingNoConstructorDelegate {}
 
   @SandboxConfig(shadows = ShadowAClassWithDifficultArgs.class)
-  @Test public void shouldAllowLooseSignatureMatches() throws Exception {
+  @Test
+  public void shouldAllowLooseSignatureMatches() {
     assertThat(new AClassWithDifficultArgs().aMethod("bc")).isEqualTo("abc");
   }
 
+  @Instrument
+  public static class AClassWithDifficultArgs {
+    public CharSequence aMethod(CharSequence s) {
+      return s;
+    }
+  }
+
   @Implements(value = AClassWithDifficultArgs.class, looseSignatures = true)
   public static class ShadowAClassWithDifficultArgs {
     @Implementation
@@ -344,15 +355,52 @@ public class ShadowWranglerIntegrationTest {
     }
   }
 
-  @Instrument
-  public static class AClassWithDifficultArgs {
-    public CharSequence aMethod(CharSequence s) {
-      return s;
+  @SandboxConfig(shadows = ShadowAClassWithDifficultArgsWithMethodRename.class)
+  @Test
+  public void methodMatch_shouldSupportMethodRename() {
+    assertThat(new AClassWithDifficultArgs().aMethod("bc")).isEqualTo("MethodRenamed-bc");
+  }
+
+  @SandboxConfig(shadows = ShadowAClassWithDifficultArgsUseClassName.class)
+  @Test
+  public void methodMatch_shouldAllowClassNameAnnotatedMatches() {
+    assertThat(new AClassWithDifficultArgs().aMethod("bc")).isEqualTo("ClassNameAnnotated-bc");
+  }
+
+  @SandboxConfig(shadows = ShadowAClassWithDifficultArgsUseClassNameWithMethodRename.class)
+  @Test
+  public void methodMatch_classNameAnnotatedMatchesSupportMethodRename() {
+    assertThat(new AClassWithDifficultArgs().aMethod("bc")).isEqualTo("ClassNameAnnotated-bc");
+  }
+
+  @Implements(value = AClassWithDifficultArgs.class)
+  public static class ShadowAClassWithDifficultArgsWithMethodRename {
+    @Implementation(methodName = "aMethod")
+    protected CharSequence renamedMethod(CharSequence s) {
+      return "MethodRenamed-" + s;
     }
   }
 
-  @Test @SandboxConfig(shadows = ShadowOfAClassWithStaticInitializer.class)
-  public void classesWithInstrumentedShadowsDontDoubleInitialize() throws Exception {
+  @Implements(value = AClassWithDifficultArgs.class)
+  public static class ShadowAClassWithDifficultArgsUseClassName {
+
+    protected Object aMethod(@ClassName("java.lang.CharSequence") Object s) {
+      return "ClassNameAnnotated-" + s;
+    }
+  }
+
+  @Implements(value = AClassWithDifficultArgs.class)
+  public static class ShadowAClassWithDifficultArgsUseClassNameWithMethodRename {
+
+    @Implementation(methodName = "aMethod")
+    protected Object renamedMethod(@ClassName("java.lang.CharSequence") Object s) {
+      return "ClassNameAnnotated-" + s;
+    }
+  }
+
+  @Test
+  @SandboxConfig(shadows = ShadowOfAClassWithStaticInitializer.class)
+  public void classesWithInstrumentedShadowsDontDoubleInitialize() {
     // if we didn't reject private shadow methods, __staticInitializer__ on the shadow
     // would be executed twice.
     new AClassWithStaticInitializer();
@@ -363,6 +411,7 @@ public class ShadowWranglerIntegrationTest {
   @Instrument
   public static class AClassWithStaticInitializer {
     static int initCount;
+
     static {
       initCount++;
     }
@@ -372,13 +421,15 @@ public class ShadowWranglerIntegrationTest {
   @Implements(AClassWithStaticInitializer.class)
   public static class ShadowOfAClassWithStaticInitializer {
     static int initCount;
+
     static {
       initCount++;
     }
   }
 
-  @Test @SandboxConfig(shadows = Shadow22OfAClassWithBrokenStaticInitializer.class)
-  public void staticInitializerShadowMethodsObeySameRules() throws Exception {
+  @Test
+  @SandboxConfig(shadows = Shadow22OfAClassWithBrokenStaticInitializer.class)
+  public void staticInitializerShadowMethodsObeySameRules() {
     new AClassWithBrokenStaticInitializer();
   }
 
@@ -399,6 +450,5 @@ public class ShadowWranglerIntegrationTest {
 
   @Implements(AClassWithBrokenStaticInitializer.class)
   public static class Shadow22OfAClassWithBrokenStaticInitializer
-      extends Shadow2OfAClassWithBrokenStaticInitializer {
-  }
+      extends Shadow2OfAClassWithBrokenStaticInitializer {}
 }
diff --git a/sandbox/src/test/java/org/robolectric/ShadowingTest.java b/sandbox/src/test/java/org/robolectric/ShadowingTest.java
index 6d22100dc..a9a1ec48e 100644
--- a/sandbox/src/test/java/org/robolectric/ShadowingTest.java
+++ b/sandbox/src/test/java/org/robolectric/ShadowingTest.java
@@ -45,8 +45,7 @@ public class ShadowingTest {
     }
   }
 
-  static class Context {
-  }
+  static class Context {}
 
   static class AccountManager {
     public static AccountManager get(Object arg) {
@@ -88,6 +87,7 @@ public class ShadowingTest {
   @Instrument
   static class Paint {
     public native void setColor(int color);
+
     public native int getColor();
   }
 
@@ -121,10 +121,10 @@ public class ShadowingTest {
     }
   }
 
-  @Instrument @SuppressWarnings({"UnusedDeclaration"})
+  @Instrument
+  @SuppressWarnings({"UnusedDeclaration"})
   public static class ClassWithNoDefaultConstructor {
-    ClassWithNoDefaultConstructor(String string) {
-    }
+    ClassWithNoDefaultConstructor(String string) {}
   }
 
   @Test
@@ -144,16 +144,13 @@ public class ShadowingTest {
     assertEquals("Off I saunter to the salon!", new Pony().saunter("the salon"));
   }
 
-  static class TextView {
-  }
+  static class TextView {}
 
   static class ColorStateList {
-    public ColorStateList(int[][] ints, int[] ints1) {
-    }
+    public ColorStateList(int[][] ints, int[] ints1) {}
   }
 
-  static class TypedArray {
-  }
+  static class TypedArray {}
 
   @Implements(TextView.class)
   public static class TextViewWithDummyGetTextColorsMethod {
@@ -168,7 +165,8 @@ public class ShadowingTest {
     ClassWithSomeConstructors o = new ClassWithSomeConstructors("my name");
     assertNull(o.name);
 
-    Method realConstructor = o.getClass().getDeclaredMethod(ShadowConstants.CONSTRUCTOR_METHOD_NAME, String.class);
+    Method realConstructor =
+        o.getClass().getDeclaredMethod(ShadowConstants.CONSTRUCTOR_METHOD_NAME, String.class);
     realConstructor.setAccessible(true);
     realConstructor.invoke(o, "my name");
     assertEquals("my name", o.name);
@@ -186,8 +184,7 @@ public class ShadowingTest {
   @Implements(ClassWithSomeConstructors.class)
   public static class ShadowOfClassWithSomeConstructors {
     @Implementation
-    protected void __constructor__(String s) {
-    }
+    protected void __constructor__(String s) {}
   }
 
   @Test
@@ -203,12 +200,10 @@ public class ShadowingTest {
   }
 
   @Instrument
-  public static class ApiImplementedClass {
-  }
+  public static class ApiImplementedClass {}
 
   @Implements(ApiImplementedClass.class)
-  public static class ShadowApiImplementedClass {
-  }
+  public static class ShadowApiImplementedClass {}
 
   @Test
   public void shouldNotInstrumentClassIfNotAddedToConfig() {
diff --git a/sandbox/src/test/java/org/robolectric/StaticInitializerTest.java b/sandbox/src/test/java/org/robolectric/StaticInitializerTest.java
index d1ea48c62..bedda49fa 100644
--- a/sandbox/src/test/java/org/robolectric/StaticInitializerTest.java
+++ b/sandbox/src/test/java/org/robolectric/StaticInitializerTest.java
@@ -25,26 +25,28 @@ public class StaticInitializerTest {
     static String name = "Floyd";
   }
 
-
   @Test
   @SandboxConfig(shadows = {ShadowClassWithoutStaticInitializerOverride.class})
-  public void whenClassHasShadowWithoutOverrideMethod_shouldPerformStaticInitialization() throws Exception {
+  public void whenClassHasShadowWithoutOverrideMethod_shouldPerformStaticInitialization()
+      throws Exception {
     assertEquals("Floyd", ClassWithStaticInitializerB.name);
 
     RobolectricInternals.performStaticInitialization(ClassWithStaticInitializerB.class);
     assertEquals("Floyd", ClassWithStaticInitializerB.name);
   }
 
-  @Instrument public static class ClassWithStaticInitializerB {
+  @Instrument
+  public static class ClassWithStaticInitializerB {
     public static String name = "Floyd";
   }
 
-  @Implements(ClassWithStaticInitializerB.class) public static class ShadowClassWithoutStaticInitializerOverride {
-  }
+  @Implements(ClassWithStaticInitializerB.class)
+  public static class ShadowClassWithoutStaticInitializerOverride {}
 
   @Test
   @SandboxConfig(shadows = {ShadowClassWithStaticInitializerOverride.class})
-  public void whenClassHasShadowWithOverrideMethod_shouldDeferStaticInitialization() throws Exception {
+  public void whenClassHasShadowWithOverrideMethod_shouldDeferStaticInitialization()
+      throws Exception {
     assertFalse(ShadowClassWithStaticInitializerOverride.initialized);
     assertEquals(null, ClassWithStaticInitializerC.name);
     assertTrue(ShadowClassWithStaticInitializerOverride.initialized);
@@ -53,7 +55,8 @@ public class StaticInitializerTest {
     assertEquals("Floyd", ClassWithStaticInitializerC.name);
   }
 
-  @Instrument public static class ClassWithStaticInitializerC {
+  @Instrument
+  public static class ClassWithStaticInitializerC {
     public static String name = "Floyd";
   }
 
diff --git a/sandbox/src/test/java/org/robolectric/ThreadSafetyTest.java b/sandbox/src/test/java/org/robolectric/ThreadSafetyTest.java
index d09b30866..a248ec46a 100644
--- a/sandbox/src/test/java/org/robolectric/ThreadSafetyTest.java
+++ b/sandbox/src/test/java/org/robolectric/ThreadSafetyTest.java
@@ -45,6 +45,7 @@ public class ThreadSafetyTest {
   @Implements(InstrumentedThread.class)
   public static class InstrumentedThreadShadow {
     @RealObject InstrumentedThread realObject;
+
     @Implementation
     protected void run() {
       Shadow.directlyOn(realObject, InstrumentedThread.class, "run");
diff --git a/sandbox/src/test/java/org/robolectric/internal/bytecode/ProxyMakerTest.java b/sandbox/src/test/java/org/robolectric/internal/bytecode/ProxyMakerTest.java
index ee7450678..38c7f9d93 100644
--- a/sandbox/src/test/java/org/robolectric/internal/bytecode/ProxyMakerTest.java
+++ b/sandbox/src/test/java/org/robolectric/internal/bytecode/ProxyMakerTest.java
@@ -11,11 +11,13 @@ import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
 public class ProxyMakerTest {
-  private static final ProxyMaker.MethodMapper IDENTITY_NAME = new ProxyMaker.MethodMapper() {
-    @Override public String getName(String className, String methodName) {
-      return methodName;
-    }
-  };
+  private static final ProxyMaker.MethodMapper IDENTITY_NAME =
+      new ProxyMaker.MethodMapper() {
+        @Override
+        public String getName(String className, String methodName) {
+          return methodName;
+        }
+      };
 
   @Test
   public void proxyCall() {
diff --git a/sandbox/src/test/java/org/robolectric/internal/bytecode/SandboxClassLoaderTest.java b/sandbox/src/test/java/org/robolectric/internal/bytecode/SandboxClassLoaderTest.java
index d68f1ca78..af93777e8 100644
--- a/sandbox/src/test/java/org/robolectric/internal/bytecode/SandboxClassLoaderTest.java
+++ b/sandbox/src/test/java/org/robolectric/internal/bytecode/SandboxClassLoaderTest.java
@@ -517,15 +517,7 @@ public class SandboxClassLoaderTest {
 
   @Nonnull
   private InstrumentationConfiguration.Builder configureBuilder() {
-    InstrumentationConfiguration.Builder builder = InstrumentationConfiguration.newBuilder();
-    builder
-        .doNotAcquirePackage("java.")
-        .doNotAcquirePackage("jdk.internal.")
-        .doNotAcquirePackage("sun.")
-        .doNotAcquirePackage("com.sun.")
-        .doNotAcquirePackage("org.robolectric.internal.")
-        .doNotAcquirePackage("org.robolectric.pluginapi.");
-    return builder;
+    return InstrumentationConfiguration.newBuilder();
   }
 
   @Test
diff --git a/sandbox/src/test/java/org/robolectric/testing/AChild.java b/sandbox/src/test/java/org/robolectric/testing/AChild.java
index d4c76bf4e..3ad542279 100644
--- a/sandbox/src/test/java/org/robolectric/testing/AChild.java
+++ b/sandbox/src/test/java/org/robolectric/testing/AChild.java
@@ -3,5 +3,4 @@ package org.robolectric.testing;
 import org.robolectric.annotation.internal.Instrument;
 
 @Instrument
-public class AChild extends AParent {
-}
+public class AChild extends AParent {}
diff --git a/sandbox/src/test/java/org/robolectric/testing/AClassThatExtendsAClassWithFinalEqualsHashCode.java b/sandbox/src/test/java/org/robolectric/testing/AClassThatExtendsAClassWithFinalEqualsHashCode.java
index c34b0b668..55a906040 100644
--- a/sandbox/src/test/java/org/robolectric/testing/AClassThatExtendsAClassWithFinalEqualsHashCode.java
+++ b/sandbox/src/test/java/org/robolectric/testing/AClassThatExtendsAClassWithFinalEqualsHashCode.java
@@ -3,5 +3,4 @@ package org.robolectric.testing;
 import org.robolectric.annotation.internal.Instrument;
 
 @Instrument
-public class AClassThatExtendsAClassWithFinalEqualsHashCode extends AClassWithFinalEqualsHashCode {
-}
+public class AClassThatExtendsAClassWithFinalEqualsHashCode extends AClassWithFinalEqualsHashCode {}
diff --git a/sandbox/src/test/java/org/robolectric/testing/AClassThatRefersToAForgettableClass.java b/sandbox/src/test/java/org/robolectric/testing/AClassThatRefersToAForgettableClass.java
index 63310609c..2edd46943 100644
--- a/sandbox/src/test/java/org/robolectric/testing/AClassThatRefersToAForgettableClass.java
+++ b/sandbox/src/test/java/org/robolectric/testing/AClassThatRefersToAForgettableClass.java
@@ -14,7 +14,8 @@ public class AClassThatRefersToAForgettableClass {
   }
 
   public String interactWithForgettableStaticMethod() {
-    return AClassToForget.memorableStaticMethod() + " forget this: " + AClassToForget.forgettableStaticMethod();
+    return AClassToForget.memorableStaticMethod()
+        + " forget this: "
+        + AClassToForget.forgettableStaticMethod();
   }
-
 }
diff --git a/sandbox/src/test/java/org/robolectric/testing/AClassToForget.java b/sandbox/src/test/java/org/robolectric/testing/AClassToForget.java
index f2b689c03..a5091480f 100644
--- a/sandbox/src/test/java/org/robolectric/testing/AClassToForget.java
+++ b/sandbox/src/test/java/org/robolectric/testing/AClassToForget.java
@@ -65,6 +65,5 @@ public class AClassToForget {
     return new short[0];
   }
 
-  public static void voidReturningMethod() {
-  }
+  public static void voidReturningMethod() {}
 }
diff --git a/sandbox/src/test/java/org/robolectric/testing/AClassToRemember.java b/sandbox/src/test/java/org/robolectric/testing/AClassToRemember.java
index 7761b7cba..ee8d5960f 100644
--- a/sandbox/src/test/java/org/robolectric/testing/AClassToRemember.java
+++ b/sandbox/src/test/java/org/robolectric/testing/AClassToRemember.java
@@ -1,4 +1,3 @@
 package org.robolectric.testing;
 
-public class AClassToRemember {
-}
+public class AClassToRemember {}
diff --git a/sandbox/src/test/java/org/robolectric/testing/AClassWithFunnyConstructors.java b/sandbox/src/test/java/org/robolectric/testing/AClassWithFunnyConstructors.java
index 7f4dfeb51..a74fb788d 100644
--- a/sandbox/src/test/java/org/robolectric/testing/AClassWithFunnyConstructors.java
+++ b/sandbox/src/test/java/org/robolectric/testing/AClassWithFunnyConstructors.java
@@ -13,7 +13,8 @@ public class AClassWithFunnyConstructors {
     this.name = name;
   }
 
-  public AClassWithFunnyConstructors(AnUninstrumentedParent uninstrumentedParent, String fooString) {
+  public AClassWithFunnyConstructors(
+      AnUninstrumentedParent uninstrumentedParent, String fooString) {
     this.uninstrumentedParent = uninstrumentedParent;
   }
 }
diff --git a/sandbox/src/test/java/org/robolectric/testing/AClassWithMethodReturningArray.java b/sandbox/src/test/java/org/robolectric/testing/AClassWithMethodReturningArray.java
index 40c6becd4..8bcd5fbea 100644
--- a/sandbox/src/test/java/org/robolectric/testing/AClassWithMethodReturningArray.java
+++ b/sandbox/src/test/java/org/robolectric/testing/AClassWithMethodReturningArray.java
@@ -6,6 +6,6 @@ import org.robolectric.annotation.internal.Instrument;
 @Instrument
 public class AClassWithMethodReturningArray {
   public String[] normalMethodReturningArray() {
-    return new String[] { "hello, working!" };
+    return new String[] {"hello, working!"};
   }
 }
diff --git a/sandbox/src/test/java/org/robolectric/testing/AClassWithNoDefaultConstructor.java b/sandbox/src/test/java/org/robolectric/testing/AClassWithNoDefaultConstructor.java
index d191452df..363990689 100644
--- a/sandbox/src/test/java/org/robolectric/testing/AClassWithNoDefaultConstructor.java
+++ b/sandbox/src/test/java/org/robolectric/testing/AClassWithNoDefaultConstructor.java
@@ -3,7 +3,8 @@ package org.robolectric.testing;
 import org.robolectric.annotation.internal.Instrument;
 
 @SuppressWarnings("UnusedDeclaration")
-@Instrument public class AClassWithNoDefaultConstructor {
+@Instrument
+public class AClassWithNoDefaultConstructor {
   private String name;
 
   AClassWithNoDefaultConstructor(String name) {
diff --git a/sandbox/src/test/java/org/robolectric/testing/AClassWithoutEqualsHashCodeToString.java b/sandbox/src/test/java/org/robolectric/testing/AClassWithoutEqualsHashCodeToString.java
index ac194e8c2..69b66319a 100644
--- a/sandbox/src/test/java/org/robolectric/testing/AClassWithoutEqualsHashCodeToString.java
+++ b/sandbox/src/test/java/org/robolectric/testing/AClassWithoutEqualsHashCodeToString.java
@@ -3,5 +3,4 @@ package org.robolectric.testing;
 import org.robolectric.annotation.internal.Instrument;
 
 @Instrument
-public class AClassWithoutEqualsHashCodeToString {
-}
+public class AClassWithoutEqualsHashCodeToString {}
diff --git a/sandbox/src/test/java/org/robolectric/testing/AFinalClass.java b/sandbox/src/test/java/org/robolectric/testing/AFinalClass.java
index c4ce30b2c..41ee813c2 100644
--- a/sandbox/src/test/java/org/robolectric/testing/AFinalClass.java
+++ b/sandbox/src/test/java/org/robolectric/testing/AFinalClass.java
@@ -3,5 +3,4 @@ package org.robolectric.testing;
 import org.robolectric.annotation.internal.Instrument;
 
 @Instrument
-public final class AFinalClass {
-}
+public final class AFinalClass {}
diff --git a/sandbox/src/test/java/org/robolectric/testing/AGrandparent.java b/sandbox/src/test/java/org/robolectric/testing/AGrandparent.java
index aef9ae1df..2c55b0d50 100644
--- a/sandbox/src/test/java/org/robolectric/testing/AGrandparent.java
+++ b/sandbox/src/test/java/org/robolectric/testing/AGrandparent.java
@@ -3,5 +3,4 @@ package org.robolectric.testing;
 import org.robolectric.annotation.internal.Instrument;
 
 @Instrument
-public class AGrandparent {
-}
+public class AGrandparent {}
diff --git a/sandbox/src/test/java/org/robolectric/testing/AParent.java b/sandbox/src/test/java/org/robolectric/testing/AParent.java
index b640e4f4a..642e56ece 100644
--- a/sandbox/src/test/java/org/robolectric/testing/AParent.java
+++ b/sandbox/src/test/java/org/robolectric/testing/AParent.java
@@ -3,5 +3,4 @@ package org.robolectric.testing;
 import org.robolectric.annotation.internal.Instrument;
 
 @Instrument
-public class AParent extends AGrandparent {
-}
+public class AParent extends AGrandparent {}
diff --git a/sandbox/src/test/java/org/robolectric/testing/AnEnum.java b/sandbox/src/test/java/org/robolectric/testing/AnEnum.java
index f063061c7..45b3b16ac 100644
--- a/sandbox/src/test/java/org/robolectric/testing/AnEnum.java
+++ b/sandbox/src/test/java/org/robolectric/testing/AnEnum.java
@@ -4,5 +4,7 @@ import org.robolectric.annotation.internal.Instrument;
 
 @Instrument
 public enum AnEnum {
-  ONE, TWO, MANY
+  ONE,
+  TWO,
+  MANY
 }
diff --git a/sandbox/src/test/java/org/robolectric/testing/AnInstrumentedClassWithoutToStringWithSuperToString.java b/sandbox/src/test/java/org/robolectric/testing/AnInstrumentedClassWithoutToStringWithSuperToString.java
index 4ad06f6e2..5a883bb76 100644
--- a/sandbox/src/test/java/org/robolectric/testing/AnInstrumentedClassWithoutToStringWithSuperToString.java
+++ b/sandbox/src/test/java/org/robolectric/testing/AnInstrumentedClassWithoutToStringWithSuperToString.java
@@ -3,5 +3,5 @@ package org.robolectric.testing;
 import org.robolectric.annotation.internal.Instrument;
 
 @Instrument
-public class AnInstrumentedClassWithoutToStringWithSuperToString extends AnUninstrumentedClassWithToString {
-}
+public class AnInstrumentedClassWithoutToStringWithSuperToString
+    extends AnUninstrumentedClassWithToString {}
diff --git a/sandbox/src/test/java/org/robolectric/testing/AnUninstrumentedClass.java b/sandbox/src/test/java/org/robolectric/testing/AnUninstrumentedClass.java
index f4f2bdf78..41d336365 100644
--- a/sandbox/src/test/java/org/robolectric/testing/AnUninstrumentedClass.java
+++ b/sandbox/src/test/java/org/robolectric/testing/AnUninstrumentedClass.java
@@ -1,4 +1,3 @@
 package org.robolectric.testing;
 
-public final class AnUninstrumentedClass {
-}
+public final class AnUninstrumentedClass {}
diff --git a/sandbox/src/test/java/org/robolectric/testing/Pony.java b/sandbox/src/test/java/org/robolectric/testing/Pony.java
index 4d1b05846..fd2341542 100644
--- a/sandbox/src/test/java/org/robolectric/testing/Pony.java
+++ b/sandbox/src/test/java/org/robolectric/testing/Pony.java
@@ -6,8 +6,7 @@ import org.robolectric.annotation.internal.Instrument;
 
 @Instrument
 public class Pony {
-  public Pony() {
-  }
+  public Pony() {}
 
   public String ride(String where) {
     return "Whinny! You're on my " + where + "!";
diff --git a/scripts/build-resources.sh b/scripts/build-resources.sh
index d85b7156c..493eeeddc 100755
--- a/scripts/build-resources.sh
+++ b/scripts/build-resources.sh
@@ -4,6 +4,8 @@ set -x
 
 # Exit the script if ANDROID_HOME is unset
 set -u
+# Exit the script on errors
+set -e
 
 rootDir=$(dirname $(dirname $0))
 projects=("robolectric" "nativeruntime")
@@ -13,8 +15,7 @@ do
   androidProjDir="$rootDir/$project"
   echo $androidProjDir
 
-  aapts=( $ANDROID_HOME/build-tools/*/aapt )
-  aapt=${aapts[-1]}
+  aapt=( $ANDROID_HOME/build-tools/34.0.0/aapt )
   inDir=$androidProjDir/src/test/resources
   outDir=$androidProjDir/src/test/resources
   javaSrc=$androidProjDir/src/test/java
@@ -24,7 +25,7 @@ do
   mkdir -p $outDir
   mkdir -p $javaSrc
 
-  $aapt p -v -f -m --auto-add-overlay -I $ANDROID_HOME/platforms/android-28/android.jar \
+  $aapt p -v -f -m --auto-add-overlay -I $ANDROID_HOME/platforms/android-34/android.jar \
     -S $inDir/res -M $inDir/AndroidManifest.xml \
     -A $inDir/assets \
     -F $outDir/resources.ap_ \
diff --git a/settings.gradle b/settings.gradle
index 1d2e82c32..256cd155a 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,3 +1,22 @@
+import org.gradle.api.initialization.resolve.RepositoriesMode
+
+pluginManagement {
+    repositories {
+        gradlePluginPortal()
+        google()
+        mavenCentral()
+    }
+}
+
+dependencyResolutionManagement {
+    repositoriesMode = RepositoriesMode.FAIL_ON_PROJECT_REPOS
+
+    repositories {
+        google()
+        mavenCentral()
+    }
+}
+
 rootProject.name = 'robolectric'
 
 include ":robolectric"
@@ -36,10 +55,11 @@ include ':integration_tests:ctesque'
 include ':integration_tests:security-providers'
 include ":integration_tests:mockk"
 include ":integration_tests:jacoco-offline"
-include ':integration_tests:compat-target28'
+include ':integration_tests:sdkcompat'
 include ":integration_tests:multidex"
 include ":integration_tests:play_services"
 include ":integration_tests:sparsearray"
 include ":integration_tests:nativegraphics"
 include ":integration_tests:room"
+include ":integration_tests:versioning"
 include ':testapp'
diff --git a/shadowapi/build.gradle b/shadowapi/build.gradle
index 3f0064fb7..c293673c1 100644
--- a/shadowapi/build.gradle
+++ b/shadowapi/build.gradle
@@ -1,8 +1,7 @@
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
-apply plugin: DeployedRoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+}
 
 dependencies {
     compileOnly libs.findbugs.jsr305
diff --git a/shadowapi/src/main/java/org/robolectric/annotation/internal/DoNotInstrument.java b/shadowapi/src/main/java/org/robolectric/annotation/internal/DoNotInstrument.java
index 4a77d97ab..94a64866b 100644
--- a/shadowapi/src/main/java/org/robolectric/annotation/internal/DoNotInstrument.java
+++ b/shadowapi/src/main/java/org/robolectric/annotation/internal/DoNotInstrument.java
@@ -6,11 +6,8 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-/**
- * Indicates that a class should not be stripped/instrumented under any circumstances.
- */
+/** Indicates that a class should not be stripped/instrumented under any circumstances. */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE})
-public @interface DoNotInstrument {
-}
+public @interface DoNotInstrument {}
diff --git a/shadowapi/src/main/java/org/robolectric/annotation/internal/Instrument.java b/shadowapi/src/main/java/org/robolectric/annotation/internal/Instrument.java
index c53e72ca2..0c9ad6739 100644
--- a/shadowapi/src/main/java/org/robolectric/annotation/internal/Instrument.java
+++ b/shadowapi/src/main/java/org/robolectric/annotation/internal/Instrument.java
@@ -6,11 +6,8 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-/**
- * Indicates that a class should always be instrumented regardless of its package.
- */
+/** Indicates that a class should always be instrumented regardless of its package. */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE})
-public @interface Instrument {
-}
+public @interface Instrument {}
diff --git a/shadowapi/src/main/java/org/robolectric/config/ConfigurationRegistry.java b/shadowapi/src/main/java/org/robolectric/config/ConfigurationRegistry.java
index dd8170dbb..8c1c0469d 100644
--- a/shadowapi/src/main/java/org/robolectric/config/ConfigurationRegistry.java
+++ b/shadowapi/src/main/java/org/robolectric/config/ConfigurationRegistry.java
@@ -20,10 +20,7 @@ public class ConfigurationRegistry {
 
   public static ConfigurationRegistry instance;
 
-  /**
-   * Returns the configuration object of the specified class, computed using
-   * {@link Configurer}.
-   */
+  /** Returns the configuration object of the specified class, computed using {@link Configurer}. */
   public static <T> T get(Class<T> configClass) {
     return instance.getInSandboxClassLoader(configClass);
   }
diff --git a/shadowapi/src/main/java/org/robolectric/internal/ShadowProvider.java b/shadowapi/src/main/java/org/robolectric/internal/ShadowProvider.java
index b3fc6f849..3e86416c7 100644
--- a/shadowapi/src/main/java/org/robolectric/internal/ShadowProvider.java
+++ b/shadowapi/src/main/java/org/robolectric/internal/ShadowProvider.java
@@ -5,21 +5,17 @@ import java.util.Collections;
 import java.util.Map;
 import java.util.Map.Entry;
 
-/**
- * Interface implemented by packages that provide shadows to Robolectric.
- */
+/** Interface implemented by packages that provide shadows to Robolectric. */
 @SuppressWarnings("NewApi")
 public interface ShadowProvider {
 
-  /**
-   * Reset the static state of all shadows provided by this package.
-   */
+  /** Reset the static state of all shadows provided by this package. */
   void reset();
 
   /**
    * Array of Java package names that are shadowed by this package.
    *
-   * @return  Array of Java package names.
+   * @return Array of Java package names.
    */
   String[] getProvidedPackageNames();
 
@@ -37,11 +33,11 @@ public interface ShadowProvider {
   Collection<Entry<String, String>> getShadows();
 
   /**
-   * Map of framework classes which may be represented by more than one shadow, to be picked
-   * at runtime.
+   * Map of framework classes which may be represented by more than one shadow, to be picked at
+   * runtime.
    *
-   * @return A map from the name of the framework class to the name of its
-   *     {#link org.robolectric.shadow.apiShadowPicker}.
+   * @return A map from the name of the framework class to the name of its {#link
+   *     org.robolectric.shadow.apiShadowPicker}.
    */
   default Map<String, String> getShadowPickerMap() {
     return Collections.emptyMap();
diff --git a/shadowapi/src/main/java/org/robolectric/shadow/api/Shadow.java b/shadowapi/src/main/java/org/robolectric/shadow/api/Shadow.java
index 02ba581a1..fb2b28e68 100644
--- a/shadowapi/src/main/java/org/robolectric/shadow/api/Shadow.java
+++ b/shadowapi/src/main/java/org/robolectric/shadow/api/Shadow.java
@@ -9,8 +9,11 @@ public class Shadow {
 
   static {
     try {
-      SHADOW_IMPL = Class.forName("org.robolectric.internal.bytecode.ShadowImpl")
-          .asSubclass(IShadow.class).getDeclaredConstructor().newInstance();
+      SHADOW_IMPL =
+          Class.forName("org.robolectric.internal.bytecode.ShadowImpl")
+              .asSubclass(IShadow.class)
+              .getDeclaredConstructor()
+              .newInstance();
     } catch (Exception e) {
       throw new RuntimeException(e);
     }
@@ -18,6 +21,7 @@ public class Shadow {
 
   /**
    * Retrieve corresponding Shadow of the object.
+   *
    * @since 3.3
    */
   @SuppressWarnings("TypeParameterUnusedInFormals")
@@ -57,21 +61,25 @@ public class Shadow {
   }
 
   @SuppressWarnings(value = {"unchecked", "TypeParameterUnusedInFormals"})
-  public static <R> R directlyOn(Object shadowedObject, String clazzName, String methodName, ClassParameter... paramValues) {
+  public static <R> R directlyOn(
+      Object shadowedObject, String clazzName, String methodName, ClassParameter... paramValues) {
     return SHADOW_IMPL.directlyOn(shadowedObject, clazzName, methodName, paramValues);
   }
 
   @SuppressWarnings("TypeParameterUnusedInFormals")
-  public static <R, T> R directlyOn(T shadowedObject, Class<T> clazz, String methodName, ClassParameter... paramValues) {
+  public static <R, T> R directlyOn(
+      T shadowedObject, Class<T> clazz, String methodName, ClassParameter... paramValues) {
     return SHADOW_IMPL.directlyOn(shadowedObject, clazz, methodName, paramValues);
   }
 
   @SuppressWarnings("TypeParameterUnusedInFormals")
-  public static <R, T> R directlyOn(Class<T> clazz, String methodName, ClassParameter... paramValues) {
+  public static <R, T> R directlyOn(
+      Class<T> clazz, String methodName, ClassParameter... paramValues) {
     return SHADOW_IMPL.directlyOn(clazz, methodName, paramValues);
   }
 
-  public static <R> R invokeConstructor(Class<? extends R> clazz, R instance, ClassParameter... paramValues) {
+  public static <R> R invokeConstructor(
+      Class<? extends R> clazz, R instance, ClassParameter... paramValues) {
     return SHADOW_IMPL.invokeConstructor(clazz, instance, paramValues);
   }
 
diff --git a/shadowapi/src/test/java/org/robolectric/util/ReflectionHelpersTest.java b/shadowapi/src/test/java/org/robolectric/util/ReflectionHelpersTest.java
index 269eb9f30..eb18eab1b 100644
--- a/shadowapi/src/test/java/org/robolectric/util/ReflectionHelpersTest.java
+++ b/shadowapi/src/test/java/org/robolectric/util/ReflectionHelpersTest.java
@@ -461,8 +461,7 @@ public class ReflectionHelpersTest {
     public String name;
     public int index;
 
-    private ExampleClass() {
-    }
+    private ExampleClass() {}
 
     private ExampleClass(String name) {
       this.name = name;
diff --git a/shadows/framework/build.gradle b/shadows/framework/build.gradle
index 492f86502..e25b4f280 100644
--- a/shadows/framework/build.gradle
+++ b/shadows/framework/build.gradle
@@ -1,10 +1,8 @@
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
-apply plugin: DeployedRoboJavaModulePlugin
-
-apply plugin: ShadowsPlugin
+plugins {
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+    alias(libs.plugins.robolectric.shadows)
+}
 
 shadows {
     packageName "org.robolectric"
diff --git a/shadows/framework/src/main/java/org/robolectric/RuntimeEnvironment.java b/shadows/framework/src/main/java/org/robolectric/RuntimeEnvironment.java
index da2a04e6a..4b6d31b23 100644
--- a/shadows/framework/src/main/java/org/robolectric/RuntimeEnvironment.java
+++ b/shadows/framework/src/main/java/org/robolectric/RuntimeEnvironment.java
@@ -15,7 +15,6 @@ import com.google.common.base.Supplier;
 import java.nio.file.Path;
 import org.robolectric.android.Bootstrap;
 import org.robolectric.android.ConfigurationV25;
-import org.robolectric.res.ResourceTable;
 import org.robolectric.shadows.ShadowDisplayManager;
 import org.robolectric.shadows.ShadowInstrumentation;
 import org.robolectric.shadows.ShadowView;
@@ -42,9 +41,6 @@ public class RuntimeEnvironment {
   private static volatile Object activityThread;
   private static int apiLevel;
   private static Scheduler masterScheduler;
-  private static ResourceTable systemResourceTable;
-  private static ResourceTable appResourceTable;
-  private static ResourceTable compileTimeResourceTable;
   private static TempDirectory tempDirectory = new TempDirectory("no-test-yet");
   private static Path androidFrameworkJar;
   public static Path compileTimeSystemResourcesFile;
@@ -276,30 +272,6 @@ public class RuntimeEnvironment {
     RuntimeEnvironment.masterScheduler = masterScheduler;
   }
 
-  public static void setSystemResourceTable(ResourceTable systemResourceTable) {
-    RuntimeEnvironment.systemResourceTable = systemResourceTable;
-  }
-
-  public static void setAppResourceTable(ResourceTable appResourceTable) {
-    RuntimeEnvironment.appResourceTable = appResourceTable;
-  }
-
-  public static ResourceTable getSystemResourceTable() {
-    return systemResourceTable;
-  }
-
-  public static ResourceTable getAppResourceTable() {
-    return appResourceTable;
-  }
-
-  public static void setCompileTimeResourceTable(ResourceTable compileTimeResourceTable) {
-    RuntimeEnvironment.compileTimeResourceTable = compileTimeResourceTable;
-  }
-
-  public static ResourceTable getCompileTimeResourceTable() {
-    return compileTimeResourceTable;
-  }
-
   public static void setTempDirectory(TempDirectory tempDirectory) {
     RuntimeEnvironment.tempDirectory = tempDirectory;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/android/Bootstrap.java b/shadows/framework/src/main/java/org/robolectric/android/Bootstrap.java
index 97d9ce294..50a775669 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/Bootstrap.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/Bootstrap.java
@@ -7,12 +7,14 @@ import android.util.DisplayMetrics;
 import org.robolectric.res.Qualifiers;
 import org.robolectric.shadows.ShadowDateUtils;
 import org.robolectric.shadows.ShadowDisplayManager;
+import org.robolectric.shadows.ShadowDisplayManagerGlobal;
 
 public class Bootstrap {
 
   private static Configuration configuration = new Configuration();
   private static DisplayMetrics displayMetrics = new DisplayMetrics();
   private static Resources displayResources;
+
   /** internal only */
   public static boolean displaySet = false;
 
@@ -39,6 +41,10 @@ public class Bootstrap {
 
   /** internal only */
   public static void resetDisplayConfiguration() {
+    // This is called to avoid the configureDefaultDisplay should only be called once exception that
+    // occurs if ShadowDisplayManagerGlobal is not properly reset during resetter.
+    ShadowDisplayManagerGlobal.reset();
+
     configuration = new Configuration();
     displayMetrics = new DisplayMetrics();
     displayResources = null;
diff --git a/shadows/framework/src/main/java/org/robolectric/android/ConfigurationV25.java b/shadows/framework/src/main/java/org/robolectric/android/ConfigurationV25.java
index ff5bb7c0b..e372a7108 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/ConfigurationV25.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/ConfigurationV25.java
@@ -15,7 +15,8 @@ import java.util.List;
 import java.util.Locale;
 import org.robolectric.RuntimeEnvironment;
 
-// adapted from https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/core/java/android/content/res/Configuration.java
+// adapted from
+// https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/core/java/android/content/res/Configuration.java
 public class ConfigurationV25 {
 
   private static String localesToResourceQualifier(List<Locale> locs) {
diff --git a/shadows/framework/src/main/java/org/robolectric/android/DeviceConfig.java b/shadows/framework/src/main/java/org/robolectric/android/DeviceConfig.java
index 2b1bd365b..0995033a3 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/DeviceConfig.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/DeviceConfig.java
@@ -96,11 +96,13 @@ public class DeviceConfig {
     }
   }
 
-  private DeviceConfig() {
-  }
+  private DeviceConfig() {}
 
-  static void applyToConfiguration(Qualifiers qualifiers, int apiLevel,
-      Configuration configuration, DisplayMetrics displayMetrics) {
+  static void applyToConfiguration(
+      Qualifiers qualifiers,
+      int apiLevel,
+      Configuration configuration,
+      DisplayMetrics displayMetrics) {
     ResTable_config resTab = qualifiers.getConfig();
 
     if (resTab.mcc != 0) {
@@ -157,11 +159,12 @@ public class DeviceConfig {
     if (isNullOrEmpty(lang) && isNullOrEmpty(region) && isNullOrEmpty(script)) {
       locale = null;
     } else {
-      locale = new Locale.Builder()
-          .setLanguage(lang)
-          .setRegion(region)
-          .setScript(script == null ? "" : script)
-          .build();
+      locale =
+          new Locale.Builder()
+              .setLanguage(lang)
+              .setRegion(region)
+              .setScript(script == null ? "" : script)
+              .build();
     }
     if (locale != null) {
       configuration.setLocale(locale);
@@ -233,8 +236,8 @@ public class DeviceConfig {
     }
   }
 
-  private static void setDensity(int densityDpi, int apiLevel, Configuration configuration,
-      DisplayMetrics displayMetrics) {
+  private static void setDensity(
+      int densityDpi, int apiLevel, Configuration configuration, DisplayMetrics displayMetrics) {
     configuration.densityDpi = densityDpi;
     displayMetrics.densityDpi = densityDpi;
     displayMetrics.density = displayMetrics.densityDpi * DisplayMetrics.DENSITY_DEFAULT_SCALE;
@@ -284,10 +287,12 @@ public class DeviceConfig {
     }
 
     if (configuration.orientation == Configuration.ORIENTATION_UNDEFINED
-        && configuration.screenWidthDp != 0 && configuration.screenHeightDp != 0) {
-      configuration.orientation = (configuration.screenWidthDp > configuration.screenHeightDp)
-          ? Configuration.ORIENTATION_LANDSCAPE
-          : Configuration.ORIENTATION_PORTRAIT;
+        && configuration.screenWidthDp != 0
+        && configuration.screenHeightDp != 0) {
+      configuration.orientation =
+          (configuration.screenWidthDp > configuration.screenHeightDp)
+              ? Configuration.ORIENTATION_LANDSCAPE
+              : Configuration.ORIENTATION_PORTRAIT;
     }
 
     if (configuration.screenWidthDp == 0) {
@@ -317,7 +322,8 @@ public class DeviceConfig {
     }
 
     if (getScreenLayoutLong(configuration) == Configuration.SCREENLAYOUT_LONG_UNDEFINED) {
-      setScreenLayoutLong(configuration,
+      setScreenLayoutLong(
+          configuration,
           ((float) greaterDimenPx) / lesserDimenPx >= 1.75
               ? Configuration.SCREENLAYOUT_LONG_YES
               : Configuration.SCREENLAYOUT_LONG_NO);
@@ -328,9 +334,10 @@ public class DeviceConfig {
     }
 
     if (configuration.orientation == Configuration.ORIENTATION_UNDEFINED) {
-      configuration.orientation = configuration.screenWidthDp > configuration.screenHeightDp
-          ? Configuration.ORIENTATION_LANDSCAPE
-          : Configuration.ORIENTATION_PORTRAIT;
+      configuration.orientation =
+          configuration.screenWidthDp > configuration.screenHeightDp
+              ? Configuration.ORIENTATION_LANDSCAPE
+              : Configuration.ORIENTATION_PORTRAIT;
     } else if (configuration.orientation == Configuration.ORIENTATION_PORTRAIT
         && configuration.screenWidthDp > configuration.screenHeightDp) {
       swapXY(configuration);
@@ -417,8 +424,7 @@ public class DeviceConfig {
 
   private static void setScreenLayoutSize(Configuration configuration, int value) {
     configuration.screenLayout =
-        (configuration.screenLayout & ~Configuration.SCREENLAYOUT_SIZE_MASK)
-            | value;
+        (configuration.screenLayout & ~Configuration.SCREENLAYOUT_SIZE_MASK) | value;
   }
 
   private static int getScreenLayoutLong(Configuration configuration) {
@@ -427,8 +433,7 @@ public class DeviceConfig {
 
   private static void setScreenLayoutLong(Configuration configuration, int value) {
     configuration.screenLayout =
-        (configuration.screenLayout & ~Configuration.SCREENLAYOUT_LONG_MASK)
-            | value;
+        (configuration.screenLayout & ~Configuration.SCREENLAYOUT_LONG_MASK) | value;
   }
 
   private static int getScreenLayoutLayoutDir(Configuration configuration) {
@@ -437,8 +442,7 @@ public class DeviceConfig {
 
   private static void setScreenLayoutLayoutDir(Configuration configuration, int value) {
     configuration.screenLayout =
-        (configuration.screenLayout & ~Configuration.SCREENLAYOUT_LAYOUTDIR_MASK)
-            | value;
+        (configuration.screenLayout & ~Configuration.SCREENLAYOUT_LAYOUTDIR_MASK) | value;
   }
 
   private static int getScreenLayoutRound(Configuration configuration) {
@@ -447,8 +451,7 @@ public class DeviceConfig {
 
   private static void setScreenLayoutRound(Configuration configuration, int value) {
     configuration.screenLayout =
-        (configuration.screenLayout & ~Configuration.SCREENLAYOUT_ROUND_MASK)
-            | value;
+        (configuration.screenLayout & ~Configuration.SCREENLAYOUT_ROUND_MASK) | value;
   }
 
   private static int getUiModeType(Configuration configuration) {
@@ -472,7 +475,8 @@ public class DeviceConfig {
   }
 
   private static void setColorModeGamut(Configuration configuration, int value) {
-    configuration.colorMode = (configuration.colorMode & ~Configuration.COLOR_MODE_WIDE_COLOR_GAMUT_MASK) | value;
+    configuration.colorMode =
+        (configuration.colorMode & ~Configuration.COLOR_MODE_WIDE_COLOR_GAMUT_MASK) | value;
   }
 
   private static int getColorModeHdr(Configuration configuration) {
@@ -480,6 +484,7 @@ public class DeviceConfig {
   }
 
   private static void setColorModeHdr(Configuration configuration, int value) {
-    configuration.colorMode = (configuration.colorMode & ~Configuration.COLOR_MODE_HDR_MASK) | value;
+    configuration.colorMode =
+        (configuration.colorMode & ~Configuration.COLOR_MODE_HDR_MASK) | value;
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/android/XmlResourceParserImpl.java b/shadows/framework/src/main/java/org/robolectric/android/XmlResourceParserImpl.java
index 646df28bf..012f0ceb8 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/XmlResourceParserImpl.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/XmlResourceParserImpl.java
@@ -26,30 +26,24 @@ import org.xmlpull.v1.XmlPullParserException;
 /**
  * Concrete implementation of the {@link XmlResourceParser}.
  *
- * Clients expects a pull parser while the resource loader
- * initialise this object with a {@link Document}.
- * This implementation navigates the dom and emulates a pull
- * parser by raising all the opportune events.
+ * <p>Clients expects a pull parser while the resource loader initialise this object with a {@link
+ * Document}. This implementation navigates the dom and emulates a pull parser by raising all the
+ * opportune events.
  *
- * Note that the original android implementation is based on
- * a set of native methods calls. Here those methods are
- * re-implemented in java when possible.
+ * <p>Note that the original android implementation is based on a set of native methods calls. Here
+ * those methods are re-implemented in java when possible.
  */
 public class XmlResourceParserImpl implements XmlResourceParser {
 
-  /**
-   * All the parser features currently supported by Android.
-   */
+  /** All the parser features currently supported by Android. */
   public static final String[] AVAILABLE_FEATURES = {
-      XmlResourceParser.FEATURE_PROCESS_NAMESPACES,
-      XmlResourceParser.FEATURE_REPORT_NAMESPACE_ATTRIBUTES
+    XmlResourceParser.FEATURE_PROCESS_NAMESPACES,
+    XmlResourceParser.FEATURE_REPORT_NAMESPACE_ATTRIBUTES
   };
-  /**
-   * All the parser features currently NOT supported by Android.
-   */
+
+  /** All the parser features currently NOT supported by Android. */
   public static final String[] UNAVAILABLE_FEATURES = {
-      XmlResourceParser.FEATURE_PROCESS_DOCDECL,
-      XmlResourceParser.FEATURE_VALIDATION
+    XmlResourceParser.FEATURE_PROCESS_DOCDECL, XmlResourceParser.FEATURE_VALIDATION
   };
 
   private final Document document;
@@ -93,8 +87,7 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   }
 
   @Override
-  public void setFeature(String name, boolean state)
-      throws XmlPullParserException {
+  public void setFeature(String name, boolean state) throws XmlPullParserException {
     if (isAndroidSupportedFeature(name) && state) {
       return;
     }
@@ -107,8 +100,7 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   }
 
   @Override
-  public void setProperty(String name, Object value)
-      throws XmlPullParserException {
+  public void setProperty(String name, Object value) throws XmlPullParserException {
     throw new XmlPullParserException("setProperty() not supported");
   }
 
@@ -131,18 +123,14 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   }
 
   @Override
-  public void defineEntityReplacementText(
-      String entityName, String replacementText)
+  public void defineEntityReplacementText(String entityName, String replacementText)
       throws XmlPullParserException {
-    throw new XmlPullParserException(
-        "defineEntityReplacementText() not supported");
+    throw new XmlPullParserException("defineEntityReplacementText() not supported");
   }
 
   @Override
-  public String getNamespacePrefix(int pos)
-      throws XmlPullParserException {
-    throw new XmlPullParserException(
-        "getNamespacePrefix() not supported");
+  public String getNamespacePrefix(int pos) throws XmlPullParserException {
+    throw new XmlPullParserException("getNamespacePrefix() not supported");
   }
 
   @Override
@@ -152,15 +140,12 @@ public class XmlResourceParserImpl implements XmlResourceParser {
 
   @Override
   public String getNamespace(String prefix) {
-    throw new RuntimeException(
-        "getNamespaceCount() not supported");
+    throw new RuntimeException("getNamespaceCount() not supported");
   }
 
   @Override
-  public int getNamespaceCount(int depth)
-      throws XmlPullParserException {
-    throw new XmlPullParserException(
-        "getNamespaceCount() not supported");
+  public int getNamespaceCount(int depth) throws XmlPullParserException {
+    throw new XmlPullParserException("getNamespaceCount() not supported");
   }
 
   @Override
@@ -169,10 +154,8 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   }
 
   @Override
-  public String getNamespaceUri(int pos)
-      throws XmlPullParserException {
-    throw new XmlPullParserException(
-        "getNamespaceUri() not supported");
+  public String getNamespaceUri(int pos) throws XmlPullParserException {
+    throw new XmlPullParserException("getNamespaceUri() not supported");
   }
 
   @Override
@@ -202,14 +185,12 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   }
 
   @Override
-  public int getEventType()
-      throws XmlPullParserException {
+  public int getEventType() throws XmlPullParserException {
     return mEventType;
   }
 
   /*package*/
-  public boolean isWhitespace(String text)
-      throws XmlPullParserException {
+  public boolean isWhitespace(String text) throws XmlPullParserException {
     if (text == null) {
       return false;
     }
@@ -217,8 +198,7 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   }
 
   @Override
-  public boolean isWhitespace()
-      throws XmlPullParserException {
+  public boolean isWhitespace() throws XmlPullParserException {
     // Note: in android whitespaces are automatically stripped.
     // Here we have to skip them manually
     return isWhitespace(getText());
@@ -342,7 +322,9 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   public String qualify(String value) {
     if (value == null) return null;
     if (AttributeResource.isResourceReference(value)) {
-      return "@" + ResName.qualifyResourceName(value.trim().substring(1).replace("+", ""), packageName, "attr");
+      return "@"
+          + ResName.qualifyResourceName(
+              value.trim().substring(1).replace("+", ""), packageName, "attr");
     } else if (AttributeResource.isStyleReference(value)) {
       return "?" + ResName.qualifyResourceName(value.trim().substring(1), packageName, "attr");
     } else {
@@ -413,138 +395,146 @@ public class XmlResourceParserImpl implements XmlResourceParser {
    */
   private int nativeNext() throws XmlPullParserException {
     switch (mEventType) {
-      case (CDSECT): {
-        throw new IllegalArgumentException(
-            "CDSECT is not handled by Android");
-      }
-      case (COMMENT): {
-        throw new IllegalArgumentException(
-            "COMMENT is not handled by Android");
-      }
-      case (DOCDECL): {
-        throw new IllegalArgumentException(
-            "DOCDECL is not handled by Android");
-      }
-      case (ENTITY_REF): {
-        throw new IllegalArgumentException(
-            "ENTITY_REF is not handled by Android");
-      }
-      case (END_DOCUMENT): {
-        // The end document event should have been filtered
-        // from the invoker. This should never happen.
-        throw new IllegalArgumentException(
-            "END_DOCUMENT should not be found here.");
-      }
-      case (END_TAG): {
-        return navigateToNextNode(currentNode);
-      }
-      case (IGNORABLE_WHITESPACE): {
-        throw new IllegalArgumentException(
-            "IGNORABLE_WHITESPACE");
-      }
-      case (PROCESSING_INSTRUCTION): {
-        throw new IllegalArgumentException(
-            "PROCESSING_INSTRUCTION");
-      }
-      case (START_DOCUMENT): {
-        currentNode = document.getDocumentElement();
-        return START_TAG;
-      }
-      case (START_TAG): {
-        if (currentNode.hasChildNodes()) {
-          // The node has children, navigate down
-          return processNextNodeType(
-              currentNode.getFirstChild());
-        } else {
-          // The node has no children
-          return END_TAG;
+      case (CDSECT):
+        {
+          throw new IllegalArgumentException("CDSECT is not handled by Android");
+        }
+      case (COMMENT):
+        {
+          throw new IllegalArgumentException("COMMENT is not handled by Android");
+        }
+      case (DOCDECL):
+        {
+          throw new IllegalArgumentException("DOCDECL is not handled by Android");
+        }
+      case (ENTITY_REF):
+        {
+          throw new IllegalArgumentException("ENTITY_REF is not handled by Android");
+        }
+      case (END_DOCUMENT):
+        {
+          // The end document event should have been filtered
+          // from the invoker. This should never happen.
+          throw new IllegalArgumentException("END_DOCUMENT should not be found here.");
+        }
+      case (END_TAG):
+        {
+          return navigateToNextNode(currentNode);
+        }
+      case (IGNORABLE_WHITESPACE):
+        {
+          throw new IllegalArgumentException("IGNORABLE_WHITESPACE");
+        }
+      case (PROCESSING_INSTRUCTION):
+        {
+          throw new IllegalArgumentException("PROCESSING_INSTRUCTION");
+        }
+      case (START_DOCUMENT):
+        {
+          currentNode = document.getDocumentElement();
+          return START_TAG;
+        }
+      case (START_TAG):
+        {
+          if (currentNode.hasChildNodes()) {
+            // The node has children, navigate down
+            return processNextNodeType(currentNode.getFirstChild());
+          } else {
+            // The node has no children
+            return END_TAG;
+          }
+        }
+      case (TEXT):
+        {
+          return navigateToNextNode(currentNode);
+        }
+      default:
+        {
+          // This can only happen if mEventType is
+          // assigned with an unmapped integer.
+          throw new RuntimeException("Robolectric-> Uknown XML event type: " + mEventType);
         }
-      }
-      case (TEXT): {
-        return navigateToNextNode(currentNode);
-      }
-      default: {
-        // This can only happen if mEventType is
-        // assigned with an unmapped integer.
-        throw new RuntimeException(
-            "Robolectric-> Uknown XML event type: " + mEventType);
-      }
     }
-
   }
 
-  /*protected*/ int processNextNodeType(Node node)
-      throws XmlPullParserException {
+  /*protected*/ int processNextNodeType(Node node) throws XmlPullParserException {
     switch (node.getNodeType()) {
-      case (Node.ATTRIBUTE_NODE): {
-        throw new IllegalArgumentException("ATTRIBUTE_NODE");
-      }
-      case (Node.CDATA_SECTION_NODE): {
-        return navigateToNextNode(node);
-      }
-      case (Node.COMMENT_NODE): {
-        return navigateToNextNode(node);
-      }
-      case (Node.DOCUMENT_FRAGMENT_NODE): {
-        throw new IllegalArgumentException("DOCUMENT_FRAGMENT_NODE");
-      }
-      case (Node.DOCUMENT_NODE): {
-        throw new IllegalArgumentException("DOCUMENT_NODE");
-      }
-      case (Node.DOCUMENT_TYPE_NODE): {
-        throw new IllegalArgumentException("DOCUMENT_TYPE_NODE");
-      }
-      case (Node.ELEMENT_NODE): {
-        currentNode = node;
-        return START_TAG;
-      }
-      case (Node.ENTITY_NODE): {
-        throw new IllegalArgumentException("ENTITY_NODE");
-      }
-      case (Node.ENTITY_REFERENCE_NODE): {
-        throw new IllegalArgumentException("ENTITY_REFERENCE_NODE");
-      }
-      case (Node.NOTATION_NODE): {
-        throw new IllegalArgumentException("DOCUMENT_TYPE_NODE");
-      }
-      case (Node.PROCESSING_INSTRUCTION_NODE): {
-        throw new IllegalArgumentException("DOCUMENT_TYPE_NODE");
-      }
-      case (Node.TEXT_NODE): {
-        if (isWhitespace(node.getNodeValue())) {
-          // Skip whitespaces
+      case (Node.ATTRIBUTE_NODE):
+        {
+          throw new IllegalArgumentException("ATTRIBUTE_NODE");
+        }
+      case (Node.CDATA_SECTION_NODE):
+        {
+          return navigateToNextNode(node);
+        }
+      case (Node.COMMENT_NODE):
+        {
           return navigateToNextNode(node);
-        } else {
+        }
+      case (Node.DOCUMENT_FRAGMENT_NODE):
+        {
+          throw new IllegalArgumentException("DOCUMENT_FRAGMENT_NODE");
+        }
+      case (Node.DOCUMENT_NODE):
+        {
+          throw new IllegalArgumentException("DOCUMENT_NODE");
+        }
+      case (Node.DOCUMENT_TYPE_NODE):
+        {
+          throw new IllegalArgumentException("DOCUMENT_TYPE_NODE");
+        }
+      case (Node.ELEMENT_NODE):
+        {
           currentNode = node;
-          return TEXT;
+          return START_TAG;
+        }
+      case (Node.ENTITY_NODE):
+        {
+          throw new IllegalArgumentException("ENTITY_NODE");
+        }
+      case (Node.ENTITY_REFERENCE_NODE):
+        {
+          throw new IllegalArgumentException("ENTITY_REFERENCE_NODE");
+        }
+      case (Node.NOTATION_NODE):
+        {
+          throw new IllegalArgumentException("DOCUMENT_TYPE_NODE");
+        }
+      case (Node.PROCESSING_INSTRUCTION_NODE):
+        {
+          throw new IllegalArgumentException("DOCUMENT_TYPE_NODE");
+        }
+      case (Node.TEXT_NODE):
+        {
+          if (isWhitespace(node.getNodeValue())) {
+            // Skip whitespaces
+            return navigateToNextNode(node);
+          } else {
+            currentNode = node;
+            return TEXT;
+          }
+        }
+      default:
+        {
+          throw new RuntimeException(
+              "Robolectric -> Unknown node type: " + node.getNodeType() + ".");
         }
-      }
-      default: {
-        throw new RuntimeException(
-            "Robolectric -> Unknown node type: " +
-                node.getNodeType() + ".");
-      }
     }
   }
 
   /**
-   * Navigate to the next node after a node and all of his
-   * children have been explored.
+   * Navigate to the next node after a node and all of his children have been explored.
    *
-   * If the node has unexplored siblings navigate to the
-   * next sibling. Otherwise return to its parent.
+   * <p>If the node has unexplored siblings navigate to the next sibling. Otherwise return to its
+   * parent.
    *
    * @param node the node which was just explored.
-   * @return {@link XmlPullParserException#START_TAG} if the given
-   *         node has siblings, {@link XmlPullParserException#END_TAG}
-   *         if the node has no unexplored siblings or
-   *         {@link XmlPullParserException#END_DOCUMENT} if the explored
-   *         was the root document.
-   * @throws XmlPullParserException if the parser fails to
-   *                                parse the next node.
+   * @return {@link XmlPullParserException#START_TAG} if the given node has siblings, {@link
+   *     XmlPullParserException#END_TAG} if the node has no unexplored siblings or {@link
+   *     XmlPullParserException#END_DOCUMENT} if the explored was the root document.
+   * @throws XmlPullParserException if the parser fails to parse the next node.
    */
-  int navigateToNextNode(Node node)
-      throws XmlPullParserException {
+  int navigateToNextNode(Node node) throws XmlPullParserException {
     Node nextNode = node.getNextSibling();
     if (nextNode != null) {
       // Move to the next siblings
@@ -566,8 +556,7 @@ public class XmlResourceParserImpl implements XmlResourceParser {
     if (type != getEventType()
         || (namespace != null && !namespace.equals(getNamespace()))
         || (name != null && !name.equals(getName()))) {
-      throw new XmlPullParserException(
-          "expected " + TYPES[type] + getPositionDescription());
+      throw new XmlPullParserException("expected " + TYPES[type] + getPositionDescription());
     }
   }
 
@@ -575,8 +564,7 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   public String nextText() throws XmlPullParserException, IOException {
     if (getEventType() != START_TAG) {
       throw new XmlPullParserException(
-          getPositionDescription()
-              + ": parser must be on START_TAG to read next text", this, null);
+          getPositionDescription() + ": parser must be on START_TAG to read next text", this, null);
     }
     int eventType = next();
     if (eventType == TEXT) {
@@ -584,16 +572,18 @@ public class XmlResourceParserImpl implements XmlResourceParser {
       eventType = next();
       if (eventType != END_TAG) {
         throw new XmlPullParserException(
-            getPositionDescription()
-                + ": event TEXT it must be immediately followed by END_TAG", this, null);
+            getPositionDescription() + ": event TEXT it must be immediately followed by END_TAG",
+            this,
+            null);
       }
       return result;
     } else if (eventType == END_TAG) {
       return "";
     } else {
       throw new XmlPullParserException(
-          getPositionDescription()
-              + ": parser must be on START_TAG or TEXT to read text", this, null);
+          getPositionDescription() + ": parser must be on START_TAG or TEXT to read text",
+          this,
+          null);
     }
   }
 
@@ -622,8 +612,8 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   }
 
   @Override
-  public int getAttributeListValue(String namespace, String attribute,
-      String[] options, int defaultValue) {
+  public int getAttributeListValue(
+      String namespace, String attribute, String[] options, int defaultValue) {
     String attr = getAttribute(namespace, attribute);
     if (attr == null) {
       return 0;
@@ -637,8 +627,8 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   }
 
   @Override
-  public boolean getAttributeBooleanValue(String namespace, String attribute,
-      boolean defaultValue) {
+  public boolean getAttributeBooleanValue(
+      String namespace, String attribute, boolean defaultValue) {
     String attr = getAttribute(namespace, attribute);
     if (attr == null) {
       return defaultValue;
@@ -670,8 +660,7 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   }
 
   @Override
-  public float getAttributeFloatValue(String namespace, String attribute,
-      float defaultValue) {
+  public float getAttributeFloatValue(String namespace, String attribute, float defaultValue) {
     String attr = getAttribute(namespace, attribute);
     if (attr == null) {
       return defaultValue;
@@ -684,8 +673,7 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   }
 
   @Override
-  public int getAttributeListValue(
-      int idx, String[] options, int defaultValue) {
+  public int getAttributeListValue(int idx, String[] options, int defaultValue) {
     try {
       String value = getAttributeValue(idx);
       List<String> optList = Arrays.asList(options);
@@ -700,8 +688,7 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   }
 
   @Override
-  public boolean getAttributeBooleanValue(
-      int idx, boolean defaultValue) {
+  public boolean getAttributeBooleanValue(int idx, boolean defaultValue) {
     try {
       return Boolean.parseBoolean(getAttributeValue(idx));
     } catch (IndexOutOfBoundsException ex) {
@@ -770,8 +757,9 @@ public class XmlResourceParserImpl implements XmlResourceParser {
   @Override
   public int getStyleAttribute() {
     String attr = getAttribute(null, "style");
-    if (attr == null ||
-        (!AttributeResource.isResourceReference(attr) && !AttributeResource.isStyleReference(attr))) {
+    if (attr == null
+        || (!AttributeResource.isResourceReference(attr)
+            && !AttributeResource.isStyleReference(attr))) {
       return 0;
     }
 
@@ -793,12 +781,15 @@ public class XmlResourceParserImpl implements XmlResourceParser {
     close();
   }
 
-  private int getResourceId(String possiblyQualifiedResourceName, String defaultPackageName, String defaultType) {
+  private int getResourceId(
+      String possiblyQualifiedResourceName, String defaultPackageName, String defaultType) {
 
     if (AttributeResource.isNull(possiblyQualifiedResourceName)) return 0;
 
     if (AttributeResource.isStyleReference(possiblyQualifiedResourceName)) {
-      ResName styleReference = AttributeResource.getStyleReference(possiblyQualifiedResourceName, defaultPackageName, "attr");
+      ResName styleReference =
+          AttributeResource.getStyleReference(
+              possiblyQualifiedResourceName, defaultPackageName, "attr");
       Integer resourceId = resourceTable.getResourceId(styleReference);
       if (resourceId == null) {
         throw new Resources.NotFoundException(styleReference.getFullyQualifiedName());
@@ -807,7 +798,9 @@ public class XmlResourceParserImpl implements XmlResourceParser {
     }
 
     if (AttributeResource.isResourceReference(possiblyQualifiedResourceName)) {
-      ResName resourceReference = AttributeResource.getResourceReference(possiblyQualifiedResourceName, defaultPackageName, defaultType);
+      ResName resourceReference =
+          AttributeResource.getResourceReference(
+              possiblyQualifiedResourceName, defaultPackageName, defaultType);
       Integer resourceId = resourceTable.getResourceId(resourceReference);
       if (resourceId == null) {
         throw new Resources.NotFoundException(resourceReference.getFullyQualifiedName());
@@ -815,12 +808,13 @@ public class XmlResourceParserImpl implements XmlResourceParser {
       return resourceId;
     }
     possiblyQualifiedResourceName = removeLeadingSpecialCharsIfAny(possiblyQualifiedResourceName);
-    ResName resName = ResName.qualifyResName(possiblyQualifiedResourceName, defaultPackageName, defaultType);
+    ResName resName =
+        ResName.qualifyResName(possiblyQualifiedResourceName, defaultPackageName, defaultType);
     Integer resourceId = resourceTable.getResourceId(resName);
     return resourceId == null ? 0 : resourceId;
   }
 
-  private static String removeLeadingSpecialCharsIfAny(String name){
+  private static String removeLeadingSpecialCharsIfAny(String name) {
     if (name.startsWith("@+")) {
       return name.substring(2);
     }
diff --git a/shadows/framework/src/main/java/org/robolectric/android/controller/ActivityController.java b/shadows/framework/src/main/java/org/robolectric/android/controller/ActivityController.java
index 56b0f4c77..1381b2e22 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/controller/ActivityController.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/controller/ActivityController.java
@@ -205,6 +205,7 @@ public class ActivityController<T extends Activity>
     invokeWhilePaused(() -> _component_.onPostResume());
     return this;
   }
+
   /**
    * Calls the same lifecycle methods on the Activity called by Android when an Activity is the top
    * most resumed activity on Q+.
diff --git a/shadows/framework/src/main/java/org/robolectric/android/controller/BackupAgentController.java b/shadows/framework/src/main/java/org/robolectric/android/controller/BackupAgentController.java
index 68aba8e96..afbde1d74 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/controller/BackupAgentController.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/controller/BackupAgentController.java
@@ -5,8 +5,8 @@ import android.content.Context;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.util.ReflectionHelpers;
 
-public class BackupAgentController<T extends BackupAgent> extends
-    ComponentController<BackupAgentController<T>, T> {
+public class BackupAgentController<T extends BackupAgent>
+    extends ComponentController<BackupAgentController<T>, T> {
   private BackupAgentController(T backupAgent) {
     super(backupAgent);
   }
@@ -20,7 +20,10 @@ public class BackupAgentController<T extends BackupAgent> extends
       return this;
     }
     Context baseContext = RuntimeEnvironment.getApplication().getBaseContext();
-    ReflectionHelpers.callInstanceMethod(BackupAgent.class, component, "attach",
+    ReflectionHelpers.callInstanceMethod(
+        BackupAgent.class,
+        component,
+        "attach",
         ReflectionHelpers.ClassParameter.from(Context.class, baseContext));
     return this;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/android/controller/ComponentController.java b/shadows/framework/src/main/java/org/robolectric/android/controller/ComponentController.java
index 367ca62e1..37754d72b 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/controller/ComponentController.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/controller/ComponentController.java
@@ -51,7 +51,8 @@ public abstract class ComponentController<C extends ComponentController<C, T>, T
     return intent;
   }
 
-  protected C invokeWhilePaused(final String methodName, final ClassParameter<?>... classParameters) {
+  protected C invokeWhilePaused(
+      final String methodName, final ClassParameter<?>... classParameters) {
     return invokeWhilePaused(
         () -> ReflectionHelpers.callInstanceMethod(component, methodName, classParameters));
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/android/controller/ContentProviderController.java b/shadows/framework/src/main/java/org/robolectric/android/controller/ContentProviderController.java
index 3643b16a8..a779d3467 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/controller/ContentProviderController.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/controller/ContentProviderController.java
@@ -12,7 +12,7 @@ import org.robolectric.RuntimeEnvironment;
 import org.robolectric.shadows.ShadowContentResolver;
 import org.robolectric.util.Logger;
 
-public class ContentProviderController<T extends ContentProvider>  {
+public class ContentProviderController<T extends ContentProvider> {
   private T contentProvider;
 
   private ContentProviderController(T contentProvider) {
@@ -23,13 +23,12 @@ public class ContentProviderController<T extends ContentProvider>  {
     return new ContentProviderController<>(contentProvider);
   }
 
-  /**
-   * Create and register {@link ContentProvider} using {@link ProviderInfo} found from manifest.
-   */
+  /** Create and register {@link ContentProvider} using {@link ProviderInfo} found from manifest. */
   public ContentProviderController<T> create() {
     Context baseContext = RuntimeEnvironment.getApplication().getBaseContext();
 
-    ComponentName componentName = createRelative(baseContext.getPackageName(), contentProvider.getClass().getName());
+    ComponentName componentName =
+        createRelative(baseContext.getPackageName(), contentProvider.getClass().getName());
 
     ProviderInfo providerInfo = null;
     try {
diff --git a/shadows/framework/src/main/java/org/robolectric/android/controller/FragmentController.java b/shadows/framework/src/main/java/org/robolectric/android/controller/FragmentController.java
index 2ffe249ae..634ab7fd6 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/controller/FragmentController.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/controller/FragmentController.java
@@ -27,7 +27,8 @@ public class FragmentController<F extends Fragment>
     return of(fragment, FragmentControllerActivity.class, null, null);
   }
 
-  public static <F extends Fragment> FragmentController<F> of(F fragment, Class<? extends Activity> activityClass) {
+  public static <F extends Fragment> FragmentController<F> of(
+      F fragment, Class<? extends Activity> activityClass) {
     return of(fragment, activityClass, null, null);
   }
 
@@ -39,21 +40,23 @@ public class FragmentController<F extends Fragment>
     return new FragmentController<>(fragment, FragmentControllerActivity.class, arguments);
   }
 
-  public static <F extends Fragment> FragmentController<F> of(F fragment, Intent intent, Bundle arguments) {
-    return new FragmentController<>(fragment, FragmentControllerActivity.class, intent,
-            arguments);
+  public static <F extends Fragment> FragmentController<F> of(
+      F fragment, Intent intent, Bundle arguments) {
+    return new FragmentController<>(fragment, FragmentControllerActivity.class, intent, arguments);
   }
 
-  public static <F extends Fragment> FragmentController<F> of(F fragment, Class<? extends Activity> activityClass, Intent intent) {
+  public static <F extends Fragment> FragmentController<F> of(
+      F fragment, Class<? extends Activity> activityClass, Intent intent) {
     return new FragmentController<>(fragment, activityClass, intent);
   }
 
-  public static <F extends Fragment> FragmentController<F> of(F fragment, Class<? extends Activity> activityClass, Bundle arguments) {
+  public static <F extends Fragment> FragmentController<F> of(
+      F fragment, Class<? extends Activity> activityClass, Bundle arguments) {
     return new FragmentController<>(fragment, activityClass, arguments);
   }
 
-  public static <F extends Fragment> FragmentController<F> of(F fragment, Class<? extends Activity> activityClass,
-                                                              Intent intent, Bundle arguments) {
+  public static <F extends Fragment> FragmentController<F> of(
+      F fragment, Class<? extends Activity> activityClass, Intent intent, Bundle arguments) {
     return new FragmentController<>(fragment, activityClass, intent, arguments);
   }
 
@@ -61,35 +64,46 @@ public class FragmentController<F extends Fragment>
     this(fragment, activityClass, intent, null);
   }
 
-  private FragmentController(F fragment, Class<? extends Activity> activityClass, Bundle arguments) {
+  private FragmentController(
+      F fragment, Class<? extends Activity> activityClass, Bundle arguments) {
     this(fragment, activityClass, null, arguments);
   }
 
-  private FragmentController(F fragment, Class<? extends Activity> activityClass,
-                             Intent intent, Bundle arguments) {
+  private FragmentController(
+      F fragment, Class<? extends Activity> activityClass, Intent intent, Bundle arguments) {
     super(fragment, intent);
     this.fragment = fragment;
     if (arguments != null) {
       this.fragment.setArguments(arguments);
     }
-    this.activityController = ActivityController.of(ReflectionHelpers.callConstructor(activityClass), intent);
+    this.activityController =
+        ActivityController.of(ReflectionHelpers.callConstructor(activityClass), intent);
   }
 
   /**
-   * Creates the activity with {@link Bundle} and adds the fragment to the view with ID {@code contentViewId}.
+   * Creates the activity with {@link Bundle} and adds the fragment to the view with ID {@code
+   * contentViewId}.
    */
   public FragmentController<F> create(final int contentViewId, final Bundle bundle) {
-    shadowMainLooper.runPaused(new Runnable() {
-      @Override
-      public void run() {
-        activityController.create(bundle).get().getFragmentManager().beginTransaction().add(contentViewId, fragment).commit();
-      }
-    });
+    shadowMainLooper.runPaused(
+        new Runnable() {
+          @Override
+          public void run() {
+            activityController
+                .create(bundle)
+                .get()
+                .getFragmentManager()
+                .beginTransaction()
+                .add(contentViewId, fragment)
+                .commit();
+          }
+        });
     return this;
   }
 
   /**
-   * Creates the activity with {@link Bundle} and adds the fragment to it. Note that the fragment will be added to the view with ID 1.
+   * Creates the activity with {@link Bundle} and adds the fragment to it. Note that the fragment
+   * will be added to the view with ID 1.
    */
   public FragmentController<F> create(Bundle bundle) {
     return create(1, bundle);
@@ -102,72 +116,79 @@ public class FragmentController<F extends Fragment>
 
   @Override
   public FragmentController<F> destroy() {
-    shadowMainLooper.runPaused(new Runnable() {
-      @Override
-      public void run() {
-        activityController.destroy();
-      }
-    });
+    shadowMainLooper.runPaused(
+        new Runnable() {
+          @Override
+          public void run() {
+            activityController.destroy();
+          }
+        });
     return this;
   }
 
   public FragmentController<F> start() {
-    shadowMainLooper.runPaused(new Runnable() {
-      @Override
-      public void run() {
-        activityController.start();
-      }
-    });
+    shadowMainLooper.runPaused(
+        new Runnable() {
+          @Override
+          public void run() {
+            activityController.start();
+          }
+        });
     return this;
   }
 
   public FragmentController<F> resume() {
-    shadowMainLooper.runPaused(new Runnable() {
-      @Override
-      public void run() {
-        activityController.resume();
-      }
-    });
+    shadowMainLooper.runPaused(
+        new Runnable() {
+          @Override
+          public void run() {
+            activityController.resume();
+          }
+        });
     return this;
   }
 
   public FragmentController<F> pause() {
-    shadowMainLooper.runPaused(new Runnable() {
-      @Override
-      public void run() {
-        activityController.pause();
-      }
-    });
+    shadowMainLooper.runPaused(
+        new Runnable() {
+          @Override
+          public void run() {
+            activityController.pause();
+          }
+        });
     return this;
   }
 
   public FragmentController<F> visible() {
-    shadowMainLooper.runPaused(new Runnable() {
-      @Override
-      public void run() {
-        activityController.visible();
-      }
-    });
+    shadowMainLooper.runPaused(
+        new Runnable() {
+          @Override
+          public void run() {
+            activityController.visible();
+          }
+        });
     return this;
   }
 
   public FragmentController<F> stop() {
-    shadowMainLooper.runPaused(new Runnable() {
-      @Override
-      public void run() {
-        activityController.stop();
-      }
-    });
+    shadowMainLooper.runPaused(
+        new Runnable() {
+          @Override
+          public void run() {
+            activityController.stop();
+          }
+        });
     return this;
   }
 
   public FragmentController<F> saveInstanceState(final Bundle outState) {
-    shadowMainLooper.runPaused(new Runnable() {
-      @Override
-      public void run() {
-        activityController.saveInstanceState(outState);
-      }
-    });
+    shadowMainLooper.runPaused(
+        new Runnable() {
+          @Override
+          public void run() {
+            activityController.saveInstanceState(outState);
+          }
+        });
     return this;
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/android/controller/IntentServiceController.java b/shadows/framework/src/main/java/org/robolectric/android/controller/IntentServiceController.java
index 4c5911eac..29fd0aaa9 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/controller/IntentServiceController.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/controller/IntentServiceController.java
@@ -14,9 +14,11 @@ import android.os.IBinder;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.util.ReflectionHelpers;
 
-public class IntentServiceController<T extends IntentService> extends ComponentController<IntentServiceController<T>, T> {
+public class IntentServiceController<T extends IntentService>
+    extends ComponentController<IntentServiceController<T>, T> {
 
-  public static <T extends IntentService> IntentServiceController<T> of(final T service, final Intent intent) {
+  public static <T extends IntentService> IntentServiceController<T> of(
+      final T service, final Intent intent) {
     final IntentServiceController<T> controller = new IntentServiceController<>(service, intent);
     controller.attach();
     return controller;
@@ -58,13 +60,15 @@ public class IntentServiceController<T extends IntentService> extends ComponentC
     return this;
   }
 
-  @Override public IntentServiceController<T> create() {
+  @Override
+  public IntentServiceController<T> create() {
     invokeWhilePaused("onCreate");
     shadowMainLooper.idleIfPaused();
     return this;
   }
 
-  @Override public IntentServiceController<T> destroy() {
+  @Override
+  public IntentServiceController<T> destroy() {
     invokeWhilePaused("onDestroy");
     shadowMainLooper.idleIfPaused();
     return this;
diff --git a/shadows/framework/src/main/java/org/robolectric/android/controller/ServiceController.java b/shadows/framework/src/main/java/org/robolectric/android/controller/ServiceController.java
index 1c5182365..4c69be1ec 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/controller/ServiceController.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/controller/ServiceController.java
@@ -13,7 +13,8 @@ import android.os.IBinder;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.util.ReflectionHelpers;
 
-public class ServiceController<T extends Service> extends ComponentController<ServiceController<T>, T> {
+public class ServiceController<T extends Service>
+    extends ComponentController<ServiceController<T>, T> {
 
   public static <T extends Service> ServiceController<T> of(T service, Intent intent) {
     ServiceController<T> controller = new ServiceController<>(service, intent);
@@ -58,13 +59,15 @@ public class ServiceController<T extends Service> extends ComponentController<Se
     return this;
   }
 
-  @Override public ServiceController<T> create() {
+  @Override
+  public ServiceController<T> create() {
     invokeWhilePaused("onCreate");
     shadowMainLooper.idleIfPaused();
     return this;
   }
 
-  @Override public ServiceController<T> destroy() {
+  @Override
+  public ServiceController<T> destroy() {
     invokeWhilePaused("onDestroy");
     shadowMainLooper.idleIfPaused();
     return this;
@@ -94,8 +97,7 @@ public class ServiceController<T extends Service> extends ComponentController<Se
 
   /**
    * @deprecated Use the appropriate builder in {@link org.robolectric.Robolectric} instead.
-   *
-   * This method will be removed in Robolectric 3.6.
+   *     <p>This method will be removed in Robolectric 3.6.
    */
   @Deprecated
   public ServiceController<T> withIntent(Intent intent) {
diff --git a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/BackgroundExecutor.java b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/BackgroundExecutor.java
index a9aaa1a12..f76bd5d75 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/BackgroundExecutor.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/BackgroundExecutor.java
@@ -3,9 +3,7 @@ package org.robolectric.android.util.concurrent;
 import java.util.concurrent.Callable;
 import java.util.concurrent.Future;
 
-/**
- * Utility class for running code off the main looper thread aka Robolectric test thread.
- */
+/** Utility class for running code off the main looper thread aka Robolectric test thread. */
 public class BackgroundExecutor {
 
   private BackgroundExecutor() {}
@@ -15,13 +13,12 @@ public class BackgroundExecutor {
     private static final BackgroundExecutor instance = new BackgroundExecutor();
   }
 
-  private final InlineExecutorService backgroundExecutorService =
-      new InlineExecutorService();
+  private final InlineExecutorService backgroundExecutorService = new InlineExecutorService();
 
   /**
    * A helper method intended for testing production code that needs to run off the main Looper.
    *
-   * Will execute given runnable in a background thread and will do a best-effort attempt at
+   * <p>Will execute given runnable in a background thread and will do a best-effort attempt at
    * propagating any exception back up to caller in their original form.
    */
   public static void runInBackground(Runnable runnable) {
diff --git a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/InlineExecutorService.java b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/InlineExecutorService.java
index 5294c4523..3d092cc3b 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/InlineExecutorService.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/InlineExecutorService.java
@@ -16,17 +16,17 @@ import org.robolectric.annotation.LooperMode;
 /**
  * Executor service that executes posted tasks as soon as they are posted.
  *
- * Intended to be a replacement for {@link RoboExecutorService} when using
- * {@link LooperMode.Mode#PAUSED}.
- * Unlike {@link RoboExecutorService}, will execute tasks on a background thread. This is useful
- * to test Android code that enforces it runs off the main thread.
+ * <p>Intended to be a replacement for {@link RoboExecutorService} when using {@link
+ * LooperMode.Mode#PAUSED}. Unlike {@link RoboExecutorService}, will execute tasks on a background
+ * thread. This is useful to test Android code that enforces it runs off the main thread.
  *
- * Also consider using {@link MoreExecutors#directExecutor()}, if your code under test can handle
+ * <p>Also consider using {@link MoreExecutors#directExecutor()}, if your code under test can handle
  * being called from main thread.
  *
- * Also see {@link PausedExecutorService} if you need control over when posted tasks are executed.
+ * <p>Also see {@link PausedExecutorService} if you need control over when posted tasks are
+ * executed.
  *
- * NOTE: Beta API, subject to change.
+ * <p>NOTE: Beta API, subject to change.
  */
 @Beta
 public class InlineExecutorService implements ExecutorService {
@@ -73,7 +73,7 @@ public class InlineExecutorService implements ExecutorService {
   @NonNull
   @Override
   public <T> Future<T> submit(@NonNull Runnable task, T result) {
-    Future<T> future =  delegateService.submit(task, result);
+    Future<T> future = delegateService.submit(task, result);
     delegateService.runAll();
     return future;
   }
@@ -102,8 +102,9 @@ public class InlineExecutorService implements ExecutorService {
 
   @NonNull
   @Override
-  public <T> List<Future<T>> invokeAll(@NonNull Collection<? extends Callable<T>> tasks,
-      long timeout, @NonNull TimeUnit unit) throws InterruptedException {
+  public <T> List<Future<T>> invokeAll(
+      @NonNull Collection<? extends Callable<T>> tasks, long timeout, @NonNull TimeUnit unit)
+      throws InterruptedException {
     return delegateService.invokeAll(tasks, timeout, unit);
   }
 
@@ -115,8 +116,9 @@ public class InlineExecutorService implements ExecutorService {
   }
 
   @Override
-  public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks, long timeout,
-      @NonNull TimeUnit unit) throws ExecutionException, InterruptedException, TimeoutException {
+  public <T> T invokeAny(
+      @NonNull Collection<? extends Callable<T>> tasks, long timeout, @NonNull TimeUnit unit)
+      throws ExecutionException, InterruptedException, TimeoutException {
     return delegateService.invokeAny(tasks, timeout, unit);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/PausedExecutorService.java b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/PausedExecutorService.java
index bb540577d..910899ebd 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/PausedExecutorService.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/PausedExecutorService.java
@@ -21,14 +21,13 @@ import org.robolectric.util.Logger;
 /**
  * Executor service that queues any posted tasks.
  *
- * Users must explicitly call {@link runAll()} to execute all pending tasks.
+ * <p>Users must explicitly call {@link runAll()} to execute all pending tasks.
  *
- * Intended to be a replacement for {@link RoboExecutorService} when using
- * {@link LooperMode.Mode#PAUSED}.
- * Unlike {@link RoboExecutorService}, will execute tasks on a background thread. This is useful
- * to test Android code that enforces it runs off the main thread.
+ * <p>Intended to be a replacement for {@link RoboExecutorService} when using {@link
+ * LooperMode.Mode#PAUSED}. Unlike {@link RoboExecutorService}, will execute tasks on a background
+ * thread. This is useful to test Android code that enforces it runs off the main thread.
  *
- * NOTE: Beta API, subject to change.
+ * <p>NOTE: Beta API, subject to change.
  */
 @Beta
 public class PausedExecutorService extends AbstractExecutorService {
@@ -105,7 +104,7 @@ public class PausedExecutorService extends AbstractExecutorService {
   /**
    * Executes the next queued task.
    *
-   * Will be ignored if called from the executor service thread to prevent deadlocks.
+   * <p>Will be ignored if called from the executor service thread to prevent deadlocks.
    *
    * @return true if task was run, false if queue was empty
    */
diff --git a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/RoboExecutorService.java b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/RoboExecutorService.java
index 8bd64da93..a1247cefd 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/RoboExecutorService.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/util/concurrent/RoboExecutorService.java
@@ -103,13 +103,14 @@ public class RoboExecutorService implements ExecutorService {
   }
 
   private <T> Future<T> schedule(final FutureTask<T> futureTask) {
-    Runnable runnable = new Runnable() {
-      @Override
-      public void run() {
-        futureTask.run();
-        runnables.remove(this);
-      }
-    };
+    Runnable runnable =
+        new Runnable() {
+          @Override
+          public void run() {
+            futureTask.run();
+            runnables.remove(this);
+          }
+        };
     runnables.add(runnable);
     scheduler.post(runnable);
 
@@ -117,22 +118,27 @@ public class RoboExecutorService implements ExecutorService {
   }
 
   @Override
-  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> callables) throws InterruptedException {
+  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> callables)
+      throws InterruptedException {
     throw new UnsupportedOperationException();
   }
 
   @Override
-  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> callables, long l, TimeUnit timeUnit) throws InterruptedException {
+  public <T> List<Future<T>> invokeAll(
+      Collection<? extends Callable<T>> callables, long l, TimeUnit timeUnit)
+      throws InterruptedException {
     throw new UnsupportedOperationException();
   }
 
   @Override
-  public <T> T invokeAny(Collection<? extends Callable<T>> callables) throws InterruptedException, ExecutionException {
+  public <T> T invokeAny(Collection<? extends Callable<T>> callables)
+      throws InterruptedException, ExecutionException {
     throw new UnsupportedOperationException();
   }
 
   @Override
-  public <T> T invokeAny(Collection<? extends Callable<T>> callables, long l, TimeUnit timeUnit) throws InterruptedException, ExecutionException, TimeoutException {
+  public <T> T invokeAny(Collection<? extends Callable<T>> callables, long l, TimeUnit timeUnit)
+      throws InterruptedException, ExecutionException, TimeoutException {
     throw new UnsupportedOperationException();
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/fakes/BaseCursor.java b/shadows/framework/src/main/java/org/robolectric/fakes/BaseCursor.java
index e6bb4cffd..79a4fa22c 100644
--- a/shadows/framework/src/main/java/org/robolectric/fakes/BaseCursor.java
+++ b/shadows/framework/src/main/java/org/robolectric/fakes/BaseCursor.java
@@ -223,7 +223,9 @@ public class BaseCursor implements Cursor {
   /*
    * Mimics ContentResolver.query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)
    */
-  public void setQuery(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
-    // Override this in your subclass if you care to implement any of the other methods based on the query that was performed.
+  public void setQuery(
+      Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
+    // Override this in your subclass if you care to implement any of the other methods based on the
+    // query that was performed.
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/fakes/RoboCursor.java b/shadows/framework/src/main/java/org/robolectric/fakes/RoboCursor.java
index f1a64ec3a..8cb5d5776 100644
--- a/shadows/framework/src/main/java/org/robolectric/fakes/RoboCursor.java
+++ b/shadows/framework/src/main/java/org/robolectric/fakes/RoboCursor.java
@@ -8,7 +8,7 @@ import java.util.List;
 
 /**
  * Robolectric implementation of {@link android.database.Cursor}.
-
+ *
  * @deprecated Use {@link android.database.MatrixCursor} instead.
  */
 @Deprecated
@@ -25,7 +25,8 @@ public class RoboCursor extends BaseCursor {
   private Bundle extras;
 
   @Override
-  public void setQuery(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
+  public void setQuery(
+      Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
     this.uri = uri;
     this.projection = projection;
     this.selection = selection;
@@ -56,13 +57,21 @@ public class RoboCursor extends BaseCursor {
   @Override
   public short getShort(int columnIndex) {
     Object value = results[resultsIndex][columnIndex];
-    return value == null ? 0 : (value instanceof Number ? ((Number) value).shortValue() : Short.parseShort(value.toString()));
+    return value == null
+        ? 0
+        : (value instanceof Number
+            ? ((Number) value).shortValue()
+            : Short.parseShort(value.toString()));
   }
 
   @Override
   public int getInt(int columnIndex) {
     Object value = results[resultsIndex][columnIndex];
-    return value == null ? 0 : (value instanceof Number ? ((Number) value).intValue() : Integer.parseInt(value.toString()));
+    return value == null
+        ? 0
+        : (value instanceof Number
+            ? ((Number) value).intValue()
+            : Integer.parseInt(value.toString()));
   }
 
   @Override
@@ -78,13 +87,21 @@ public class RoboCursor extends BaseCursor {
   @Override
   public float getFloat(int columnIndex) {
     Object value = results[resultsIndex][columnIndex];
-    return value == null ? 0 : (value instanceof Number ? ((Number) value).floatValue() : Float.parseFloat(value.toString()));
+    return value == null
+        ? 0
+        : (value instanceof Number
+            ? ((Number) value).floatValue()
+            : Float.parseFloat(value.toString()));
   }
 
   @Override
   public double getDouble(int columnIndex) {
     Object value = results[resultsIndex][columnIndex];
-    return value == null ? 0 : (value instanceof Number ? ((Number) value).doubleValue() : Double.parseDouble(value.toString()));
+    return value == null
+        ? 0
+        : (value instanceof Number
+            ? ((Number) value).doubleValue()
+            : Double.parseDouble(value.toString()));
   }
 
   @Override
@@ -166,31 +183,38 @@ public class RoboCursor extends BaseCursor {
     return resultsIndex == results.length - 1;
   }
 
-  @Override public int getPosition() {
+  @Override
+  public int getPosition() {
     return resultsIndex;
   }
 
-  @Override public boolean move(int offset) {
+  @Override
+  public boolean move(int offset) {
     return doMoveToPosition(resultsIndex + offset);
   }
 
-  @Override public boolean moveToLast() {
+  @Override
+  public boolean moveToLast() {
     return doMoveToPosition(results.length - 1);
   }
 
-  @Override public boolean moveToPrevious() {
+  @Override
+  public boolean moveToPrevious() {
     return doMoveToPosition(resultsIndex - 1);
   }
 
-  @Override public String[] getColumnNames() {
+  @Override
+  public String[] getColumnNames() {
     return columnNames.toArray(new String[columnNames.size()]);
   }
 
-  @Override public boolean isClosed() {
+  @Override
+  public boolean isClosed() {
     return closeWasCalled;
   }
 
-  @Override public Bundle getExtras() {
+  @Override
+  public Bundle getExtras() {
     return extras;
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/fakes/RoboIntentSender.java b/shadows/framework/src/main/java/org/robolectric/fakes/RoboIntentSender.java
index ce7183770..df70dda34 100644
--- a/shadows/framework/src/main/java/org/robolectric/fakes/RoboIntentSender.java
+++ b/shadows/framework/src/main/java/org/robolectric/fakes/RoboIntentSender.java
@@ -8,9 +8,7 @@ import android.content.IntentSender;
 import android.os.Handler;
 import java.util.Objects;
 
-/**
- * Robolectric implementation of {@link android.content.IntentSender}.
- */
+/** Robolectric implementation of {@link android.content.IntentSender}. */
 public class RoboIntentSender extends IntentSender {
   public Intent intent;
   private PendingIntent pendingIntent;
@@ -33,8 +31,14 @@ public class RoboIntentSender extends IntentSender {
     return pendingIntent.hashCode();
   }
 
-  @Override public void sendIntent(Context context, int code, Intent intent,
-                         final OnFinished onFinished, Handler handler, String requiredPermission)
+  @Override
+  public void sendIntent(
+      Context context,
+      int code,
+      Intent intent,
+      final OnFinished onFinished,
+      Handler handler,
+      String requiredPermission)
       throws SendIntentException {
     try {
       pendingIntent.send(context, code, intent);
diff --git a/shadows/framework/src/main/java/org/robolectric/fakes/RoboMenu.java b/shadows/framework/src/main/java/org/robolectric/fakes/RoboMenu.java
index 9a755f09d..f3001d994 100644
--- a/shadows/framework/src/main/java/org/robolectric/fakes/RoboMenu.java
+++ b/shadows/framework/src/main/java/org/robolectric/fakes/RoboMenu.java
@@ -13,9 +13,7 @@ import java.util.Comparator;
 import java.util.List;
 import org.robolectric.RuntimeEnvironment;
 
-/**
- * Robolectric implementation of {@link android.view.Menu}.
- */
+/** Robolectric implementation of {@link android.view.Menu}. */
 public class RoboMenu implements Menu {
   private List<MenuItem> menuItems = new ArrayList<>();
   private Context context;
@@ -100,8 +98,15 @@ public class RoboMenu implements Menu {
   }
 
   @Override
-  public int addIntentOptions(int groupId, int itemId, int order, ComponentName caller, Intent[] specifics,
-                              Intent intent, int flags, MenuItem[] outSpecificItems) {
+  public int addIntentOptions(
+      int groupId,
+      int itemId,
+      int order,
+      ComponentName caller,
+      Intent[] specifics,
+      Intent intent,
+      int flags,
+      MenuItem[] outSpecificItems) {
     return 0;
   }
 
@@ -112,8 +117,7 @@ public class RoboMenu implements Menu {
   }
 
   @Override
-  public void removeGroup(int groupId) {
-  }
+  public void removeGroup(int groupId) {}
 
   @Override
   public void clear() {
@@ -121,16 +125,13 @@ public class RoboMenu implements Menu {
   }
 
   @Override
-  public void setGroupCheckable(int group, boolean checkable, boolean exclusive) {
-  }
+  public void setGroupCheckable(int group, boolean checkable, boolean exclusive) {}
 
   @Override
-  public void setGroupVisible(int group, boolean visible) {
-  }
+  public void setGroupVisible(int group, boolean visible) {}
 
   @Override
-  public void setGroupEnabled(int group, boolean enabled) {
-  }
+  public void setGroupEnabled(int group, boolean enabled) {}
 
   @Override
   public boolean hasVisibleItems() {
@@ -158,8 +159,7 @@ public class RoboMenu implements Menu {
   }
 
   @Override
-  public void close() {
-  }
+  public void close() {}
 
   @Override
   public boolean performShortcut(int keyCode, KeyEvent event, int flags) {
@@ -177,8 +177,7 @@ public class RoboMenu implements Menu {
   }
 
   @Override
-  public void setQwertyMode(boolean isQwerty) {
-  }
+  public void setQwertyMode(boolean isQwerty) {}
 
   public RoboMenuItem findMenuItem(CharSequence title) {
     for (int i = 0; i < size(); i++) {
@@ -214,4 +213,3 @@ public class RoboMenu implements Menu {
     }
   }
 }
-
diff --git a/shadows/framework/src/main/java/org/robolectric/fakes/RoboMenuItem.java b/shadows/framework/src/main/java/org/robolectric/fakes/RoboMenuItem.java
index f94d45c9e..0a38e44e6 100644
--- a/shadows/framework/src/main/java/org/robolectric/fakes/RoboMenuItem.java
+++ b/shadows/framework/src/main/java/org/robolectric/fakes/RoboMenuItem.java
@@ -11,9 +11,7 @@ import android.view.SubMenu;
 import android.view.View;
 import org.robolectric.RuntimeEnvironment;
 
-/**
- * Robolectric implementation of {@link android.view.MenuItem}.
- */
+/** Robolectric implementation of {@link android.view.MenuItem}. */
 public class RoboMenuItem implements MenuItem {
   private int itemId;
   private int groupId;
@@ -228,8 +226,7 @@ public class RoboMenuItem implements MenuItem {
   }
 
   @Override
-  public void setShowAsAction(int actionEnum) {
-  }
+  public void setShowAsAction(int actionEnum) {}
 
   @Override
   public MenuItem setShowAsActionFlags(int actionEnum) {
@@ -302,4 +299,3 @@ public class RoboMenuItem implements MenuItem {
     return this;
   }
 }
-
diff --git a/shadows/framework/src/main/java/org/robolectric/fakes/RoboSubMenu.java b/shadows/framework/src/main/java/org/robolectric/fakes/RoboSubMenu.java
index 462d2b0e4..a61e1d5eb 100644
--- a/shadows/framework/src/main/java/org/robolectric/fakes/RoboSubMenu.java
+++ b/shadows/framework/src/main/java/org/robolectric/fakes/RoboSubMenu.java
@@ -7,9 +7,7 @@ import android.view.SubMenu;
 import android.view.View;
 import org.robolectric.RuntimeEnvironment;
 
-/**
- * Robolectric implementation of {@link android.view.SubMenu}.
- */
+/** Robolectric implementation of {@link android.view.SubMenu}. */
 public class RoboSubMenu extends RoboMenu implements SubMenu {
 
   public RoboSubMenu() {
@@ -46,8 +44,7 @@ public class RoboSubMenu extends RoboMenu implements SubMenu {
   }
 
   @Override
-  public void clearHeader() {
-  }
+  public void clearHeader() {}
 
   @Override
   public SubMenu setIcon(int iconRes) {
@@ -64,4 +61,3 @@ public class RoboSubMenu extends RoboMenu implements SubMenu {
     return null;
   }
 }
-
diff --git a/shadows/framework/src/main/java/org/robolectric/fakes/RoboWebSettings.java b/shadows/framework/src/main/java/org/robolectric/fakes/RoboWebSettings.java
index 79340c54a..91ccebb53 100644
--- a/shadows/framework/src/main/java/org/robolectric/fakes/RoboWebSettings.java
+++ b/shadows/framework/src/main/java/org/robolectric/fakes/RoboWebSettings.java
@@ -2,9 +2,7 @@ package org.robolectric.fakes;
 
 import android.webkit.WebSettings;
 
-/**
- * Robolectric implementation of {@link android.webkit.WebSettings}.
- */
+/** Robolectric implementation of {@link android.webkit.WebSettings}. */
 public class RoboWebSettings extends WebSettings {
   private boolean blockNetworkImage = false;
   private boolean javaScriptEnabled = false;
@@ -143,7 +141,8 @@ public class RoboWebSettings extends WebSettings {
   }
 
   @Override
-  public void setJavaScriptCanOpenWindowsAutomatically(boolean javaScriptCanOpenWindowAutomatically) {
+  public void setJavaScriptCanOpenWindowsAutomatically(
+      boolean javaScriptCanOpenWindowAutomatically) {
     this.javaScriptCanOpenWindowAutomatically = javaScriptCanOpenWindowAutomatically;
   }
 
@@ -182,7 +181,8 @@ public class RoboWebSettings extends WebSettings {
     return loadsImagesAutomatically;
   }
 
-  @Override public void setLoadsImagesAutomatically(boolean loadsImagesAutomatically) {
+  @Override
+  public void setLoadsImagesAutomatically(boolean loadsImagesAutomatically) {
     this.loadsImagesAutomatically = loadsImagesAutomatically;
   }
 
@@ -191,7 +191,8 @@ public class RoboWebSettings extends WebSettings {
     return defaultFixedFontSize;
   }
 
-  @Override public void setDefaultFixedFontSize(int defaultFixedFontSize) {
+  @Override
+  public void setDefaultFixedFontSize(int defaultFixedFontSize) {
     this.defaultFixedFontSize = defaultFixedFontSize;
   }
 
@@ -200,7 +201,8 @@ public class RoboWebSettings extends WebSettings {
     return minimumLogicalFontSize;
   }
 
-  @Override public void setMinimumLogicalFontSize(int minimumLogicalFontSize) {
+  @Override
+  public void setMinimumLogicalFontSize(int minimumLogicalFontSize) {
     this.minimumLogicalFontSize = minimumLogicalFontSize;
   }
 
@@ -209,7 +211,8 @@ public class RoboWebSettings extends WebSettings {
     return minimumFontSize;
   }
 
-  @Override public void setMinimumFontSize(int minimumFontSize) {
+  @Override
+  public void setMinimumFontSize(int minimumFontSize) {
     this.minimumFontSize = minimumFontSize;
   }
 
@@ -218,7 +221,8 @@ public class RoboWebSettings extends WebSettings {
     return fantasyFontFamily;
   }
 
-  @Override public void setFantasyFontFamily(String fantasyFontFamily) {
+  @Override
+  public void setFantasyFontFamily(String fantasyFontFamily) {
     this.fantasyFontFamily = fantasyFontFamily;
   }
 
@@ -227,7 +231,8 @@ public class RoboWebSettings extends WebSettings {
     return cursiveFontFamily;
   }
 
-  @Override public void setCursiveFontFamily(String cursiveFontFamily) {
+  @Override
+  public void setCursiveFontFamily(String cursiveFontFamily) {
     this.cursiveFontFamily = cursiveFontFamily;
   }
 
@@ -236,7 +241,8 @@ public class RoboWebSettings extends WebSettings {
     return serifFontFamily;
   }
 
-  @Override public void setSerifFontFamily(String serifFontFamily) {
+  @Override
+  public void setSerifFontFamily(String serifFontFamily) {
     this.serifFontFamily = serifFontFamily;
   }
 
@@ -245,7 +251,8 @@ public class RoboWebSettings extends WebSettings {
     return sansSerifFontFamily;
   }
 
-  @Override public void setSansSerifFontFamily(String sansSerifFontFamily) {
+  @Override
+  public void setSansSerifFontFamily(String sansSerifFontFamily) {
     this.sansSerifFontFamily = sansSerifFontFamily;
   }
 
@@ -254,7 +261,8 @@ public class RoboWebSettings extends WebSettings {
     return fixedFontFamily;
   }
 
-  @Override public void setFixedFontFamily(String fixedFontFamily) {
+  @Override
+  public void setFixedFontFamily(String fixedFontFamily) {
     this.fixedFontFamily = fixedFontFamily;
   }
 
@@ -263,7 +271,8 @@ public class RoboWebSettings extends WebSettings {
     return standardFontFamily;
   }
 
-  @Override public void setStandardFontFamily(String standardFontFamily) {
+  @Override
+  public void setStandardFontFamily(String standardFontFamily) {
     this.standardFontFamily = standardFontFamily;
   }
 
@@ -299,7 +308,7 @@ public class RoboWebSettings extends WebSettings {
 
   @Override
   public void setUserAgent(int userAgent) {
-    this.userAgent =  userAgent;
+    this.userAgent = userAgent;
   }
 
   @Override
@@ -347,6 +356,7 @@ public class RoboWebSettings extends WebSettings {
   public synchronized String getUserAgentString() {
     return userAgentString;
   }
+
   // End API 3
 
   private boolean databaseEnabled = false;
@@ -391,6 +401,7 @@ public class RoboWebSettings extends WebSettings {
   public void setGeolocationEnabled(boolean geolocationEnabled) {
     this.geolocationEnabled = geolocationEnabled;
   }
+
   // End API 5
 
   private ZoomDensity defaultZoom;
@@ -456,6 +467,7 @@ public class RoboWebSettings extends WebSettings {
   public void setAppCachePath(String appCachePath) {
     this.appCachePath = appCachePath;
   }
+
   // End API 7
 
   private boolean blockNetworkLoads = false;
@@ -480,6 +492,7 @@ public class RoboWebSettings extends WebSettings {
   public synchronized void setPluginState(WebSettings.PluginState state) {
     pluginState = state;
   }
+
   // End API 8
 
   private boolean useWebViewBackgroundForOverscrollBackground;
@@ -490,9 +503,11 @@ public class RoboWebSettings extends WebSettings {
   }
 
   @Override
-  public void setUseWebViewBackgroundForOverscrollBackground(boolean useWebViewBackgroundForOverscrollBackground) {
+  public void setUseWebViewBackgroundForOverscrollBackground(
+      boolean useWebViewBackgroundForOverscrollBackground) {
     this.useWebViewBackgroundForOverscrollBackground = useWebViewBackgroundForOverscrollBackground;
   }
+
   // End API 9
 
   private boolean enableSmoothTransition;
@@ -528,6 +543,7 @@ public class RoboWebSettings extends WebSettings {
   public boolean getDisplayZoomControls() {
     return displayZoomControls;
   }
+
   // End API 11
 
   private int textZoom = 100;
@@ -541,6 +557,7 @@ public class RoboWebSettings extends WebSettings {
   public void setTextZoom(int textZoom) {
     this.textZoom = textZoom;
   }
+
   // End API 14
 
   private boolean allowFileAccessFromFile = true;
@@ -565,7 +582,8 @@ public class RoboWebSettings extends WebSettings {
   public void setAllowUniversalAccessFromFileURLs(boolean allow) {
     allowUniversalAccessFromFile = allow;
   }
-  //End API 16
+
+  // End API 16
 
   private boolean mediaPlaybackRequiresUserGesture = true;
 
@@ -578,7 +596,8 @@ public class RoboWebSettings extends WebSettings {
   public void setMediaPlaybackRequiresUserGesture(boolean require) {
     mediaPlaybackRequiresUserGesture = require;
   }
-  //End API 17
+
+  // End API 17
 
   private int mixedContentMode;
   private boolean acceptThirdPartyCookies;
@@ -613,14 +632,14 @@ public class RoboWebSettings extends WebSettings {
   public void setAcceptThirdPartyCookies(boolean acceptThirdPartyCookies) {
     this.acceptThirdPartyCookies = acceptThirdPartyCookies;
   }
+
   // End API 21
 
   @Override
-  public void setOffscreenPreRaster(boolean enabled) {
-
-  }
+  public void setOffscreenPreRaster(boolean enabled) {}
 
-  @Override public boolean getOffscreenPreRaster() {
+  @Override
+  public boolean getOffscreenPreRaster() {
     return false;
   }
 
@@ -632,19 +651,17 @@ public class RoboWebSettings extends WebSettings {
   }
 
   @Override
-  public void setDisabledActionModeMenuItems(int menuItems) {
-
-  }
+  public void setDisabledActionModeMenuItems(int menuItems) {}
 
   // End API 24.
 
-  @Override public boolean getSafeBrowsingEnabled() {
+  @Override
+  public boolean getSafeBrowsingEnabled() {
     return false;
   }
 
-  @Override public void setSafeBrowsingEnabled(boolean enabled) {
-
-  }
+  @Override
+  public void setSafeBrowsingEnabled(boolean enabled) {}
 
   // End API 26
 
diff --git a/shadows/framework/src/main/java/org/robolectric/fakes/package-info.java b/shadows/framework/src/main/java/org/robolectric/fakes/package-info.java
index 38e02cabb..969f3d99b 100644
--- a/shadows/framework/src/main/java/org/robolectric/fakes/package-info.java
+++ b/shadows/framework/src/main/java/org/robolectric/fakes/package-info.java
@@ -1,4 +1,2 @@
-/**
- * Package containing fake implementations of Android classes.
- */
-package org.robolectric.fakes;
\ No newline at end of file
+/** Package containing fake implementations of Android classes. */
+package org.robolectric.fakes;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/AssociationInfoBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/AssociationInfoBuilder.java
index 5750126f3..4b9217ae8 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/AssociationInfoBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/AssociationInfoBuilder.java
@@ -94,7 +94,7 @@ public class AssociationInfoBuilder {
     this.revoked = revoked;
     return this;
   }
-  
+
   public AssociationInfoBuilder setLastTimeConnectedMs(long lastTimeConnectedMs) {
     this.lastTimeConnectedMs = lastTimeConnectedMs;
     return this;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/AttestedKeyPairFactory.java b/shadows/framework/src/main/java/org/robolectric/shadows/AttestedKeyPairFactory.java
index eb0b2d5a5..a4710ab4f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/AttestedKeyPairFactory.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/AttestedKeyPairFactory.java
@@ -11,4 +11,4 @@ public class AttestedKeyPairFactory {
   public static AttestedKeyPair create(KeyPair keyPair, Certificate[] attestationRecord) {
     return new AttestedKeyPair(keyPair, attestationRecord);
   }
-}
\ No newline at end of file
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ClassNameResolver.java b/shadows/framework/src/main/java/org/robolectric/shadows/ClassNameResolver.java
index 32e287547..e88d8c09a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ClassNameResolver.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ClassNameResolver.java
@@ -2,7 +2,8 @@ package org.robolectric.shadows;
 
 public class ClassNameResolver<T> {
 
-  public static <T> Class<T> resolve(String packageName, String className) throws ClassNotFoundException {
+  public static <T> Class<T> resolve(String packageName, String className)
+      throws ClassNotFoundException {
     Class<T> aClass;
     if (looksFullyQualified(className)) {
       aClass = safeClassForName(className);
@@ -15,8 +16,8 @@ public class ClassNameResolver<T> {
     }
 
     if (aClass == null) {
-      throw new ClassNotFoundException("Could not find a class for package: "
-          + packageName + " and class name: " + className);
+      throw new ClassNotFoundException(
+          "Could not find a class for package: " + packageName + " and class name: " + className);
     }
     return aClass;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/Converter.java b/shadows/framework/src/main/java/org/robolectric/shadows/Converter.java
index 30cf0d715..2559db6fd 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/Converter.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/Converter.java
@@ -14,7 +14,7 @@ import org.robolectric.util.Util;
 public class Converter<T> {
   private static int nextStringCookie = 0xbaaa5;
 
-  synchronized static int getNextStringCookie() {
+  static synchronized int getNextStringCookie() {
     return nextStringCookie++;
   }
 
@@ -97,7 +97,8 @@ public class Converter<T> {
   }
 
   private UnsupportedOperationException cantDo(String operation) {
-    return new UnsupportedOperationException(getClass().getName() + " doesn't support " + operation);
+    return new UnsupportedOperationException(
+        getClass().getName() + " doesn't support " + operation);
   }
 
   public static class FromAttrData extends Converter<AttrData> {
@@ -138,7 +139,7 @@ public class Converter<T> {
     @Override
     public boolean fillTypedValue(String data, TypedValue typedValue) {
       try {
-        typedValue.type =  ResourceHelper.getColorType(data);
+        typedValue.type = ResourceHelper.getColorType(data);
         typedValue.data = ResourceHelper.getColor(data);
         typedValue.assetCookie = 0;
         typedValue.string = null;
@@ -177,7 +178,8 @@ public class Converter<T> {
     public boolean fillTypedValue(String data, TypedValue typedValue) {
       try {
         if (data.startsWith("0x")) {
-          typedValue.type = data.startsWith("0x") ? TypedValue.TYPE_INT_HEX : TypedValue.TYPE_INT_DEC;
+          typedValue.type =
+              data.startsWith("0x") ? TypedValue.TYPE_INT_HEX : TypedValue.TYPE_INT_DEC;
         } else {
           typedValue.type = TypedValue.TYPE_INT_DEC;
         }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/Converter2.java b/shadows/framework/src/main/java/org/robolectric/shadows/Converter2.java
index 1ae3016a9..532137758 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/Converter2.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/Converter2.java
@@ -7,7 +7,7 @@ import org.robolectric.util.Util;
 public class Converter2<T> {
   private static int nextStringCookie = 0xbaaa5;
 
-  synchronized static int getNextStringCookie() {
+  static synchronized int getNextStringCookie() {
     return nextStringCookie++;
   }
 
@@ -66,10 +66,8 @@ public class Converter2<T> {
         return false;
       }
     }
-
   }
 
-
   private static class FromInt extends Converter2<String> {
     @Override
     public boolean fillTypedValue(String data, TypedValue typedValue, boolean throwOnFailure) {
@@ -87,7 +85,6 @@ public class Converter2<T> {
         return false;
       }
     }
-
   }
 
   private static class FromFraction extends Converter2<String> {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/HardwareRenderingScreenshot.java b/shadows/framework/src/main/java/org/robolectric/shadows/HardwareRenderingScreenshot.java
index 886c2a807..0fe29a9b0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/HardwareRenderingScreenshot.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/HardwareRenderingScreenshot.java
@@ -1,17 +1,19 @@
 package org.robolectric.shadows;
 
+import static android.os.Build.VERSION_CODES.P;
+import static android.os.Build.VERSION_CODES.Q;
+
 import android.content.Context;
 import android.content.res.Resources;
 import android.content.res.TypedArray;
 import android.graphics.Bitmap;
+import android.graphics.Canvas;
 import android.graphics.HardwareRenderer;
 import android.graphics.PixelFormat;
 import android.graphics.RenderNode;
 import android.media.Image;
 import android.media.Image.Plane;
 import android.media.ImageReader;
-import android.os.Build.VERSION;
-import android.os.Build.VERSION_CODES;
 import android.util.DisplayMetrics;
 import android.view.Surface;
 import android.view.View;
@@ -19,6 +21,7 @@ import android.view.ViewRootImpl;
 import com.android.internal.R;
 import com.google.common.base.Preconditions;
 import java.util.WeakHashMap;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.GraphicsMode;
 import org.robolectric.util.ReflectionHelpers;
 
@@ -43,15 +46,15 @@ public final class HardwareRenderingScreenshot {
    * GraphicsMode}.
    */
   static boolean canTakeScreenshot(View view) {
-    return VERSION.SDK_INT >= VERSION_CODES.S
-        && "hardware".equalsIgnoreCase(System.getProperty(PIXEL_COPY_RENDER_MODE, ""))
+    return RuntimeEnvironment.getApiLevel() >= P
+        && "hardware".equalsIgnoreCase(System.getProperty(PIXEL_COPY_RENDER_MODE, "hardware"))
         && ShadowView.useRealGraphics()
         && view.canHaveDisplayList();
   }
 
   /**
-   * Generates a bitmap given the current view using HardwareRenderer with native graphics calls.
-   * Requires API 31+ (S).
+   * Generates a bitmap given the current view using hardware accelerated canvases with native
+   * graphics calls. Requires API 28+ (S).
    *
    * <p>This code mirrors the behavior of LayoutLib's RenderSessionImpl.renderAndBuildResult(); see
    * https://googleplex-android.googlesource.com/platform/frameworks/layoutlib/+/refs/heads/master-layoutlib-native/bridge/src/com/android/layoutlib/bridge/impl/RenderSessionImpl.java#573
@@ -62,25 +65,27 @@ public final class HardwareRenderingScreenshot {
 
     try (ImageReader imageReader =
         ImageReader.newInstance(width, height, PixelFormat.RGBA_8888, 1)) {
-      // Note on pixel format:
-      // - Android Bitmap requires ARGB_8888.
-      // - ImageReader is configured as RGBA_8888.
-      // - However the native libs/hwui/pipeline/skia/SkiaHostPipeline.cpp always treats
-      //   the buffer as BGRA_8888, thus matching what the Android Bitmap object requires.
       ViewRootImpl viewRootImpl = view.getViewRootImpl();
       Preconditions.checkNotNull(viewRootImpl, "View not attached");
-      HardwareRenderer renderer =
-          hardwareRenderers.computeIfAbsent(viewRootImpl, k -> new HardwareRenderer());
       Surface surface = imageReader.getSurface();
-      renderer.setSurface(surface);
-      Image nativeImage = imageReader.acquireNextImage();
-
-      setupRendererShadowProperties(renderer, view);
 
-      RenderNode node = getRenderNode(view);
-      renderer.setContentRoot(node);
-
-      renderer.createRenderRequest().syncAndDraw();
+      if (RuntimeEnvironment.getApiLevel() >= Q) {
+        // HardwareRenderer is only available on API 29+ (Q).
+        HardwareRenderer renderer =
+            hardwareRenderers.computeIfAbsent(viewRootImpl, k -> new HardwareRenderer());
+        renderer.setSurface(surface);
+        setupRendererShadowProperties(renderer, view);
+        RenderNode node = getRenderNode(view);
+        renderer.setContentRoot(node);
+        renderer.createRenderRequest().syncAndDraw();
+      } else {
+        // Note this API does not set any light source properties, so it will not render
+        // drop shadows.
+        Canvas canvas = surface.lockHardwareCanvas();
+        view.draw(canvas);
+        surface.unlockCanvasAndPost(canvas);
+      }
+      Image nativeImage = imageReader.acquireNextImage();
       Plane[] planes = nativeImage.getPlanes();
       destBitmap.copyPixelsFromBuffer(planes[0].getBuffer());
       surface.release();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/LauncherAppsDelegate.java b/shadows/framework/src/main/java/org/robolectric/shadows/LauncherAppsDelegate.java
new file mode 100644
index 000000000..431c7e81e
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/LauncherAppsDelegate.java
@@ -0,0 +1,16 @@
+package org.robolectric.shadows;
+
+import android.os.UserHandle;
+import android.os.UserManager;
+import java.util.List;
+import org.robolectric.RuntimeEnvironment;
+
+/** Delegate for {@link ILauncherApps}. */
+class LauncherAppsDelegate {
+
+  public List<UserHandle> getUserProfiles() {
+    return RuntimeEnvironment.getApplication()
+        .getSystemService(UserManager.class)
+        .getUserProfiles();
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/LegacyManifestParser.java b/shadows/framework/src/main/java/org/robolectric/shadows/LegacyManifestParser.java
deleted file mode 100644
index d651a9177..000000000
--- a/shadows/framework/src/main/java/org/robolectric/shadows/LegacyManifestParser.java
+++ /dev/null
@@ -1,596 +0,0 @@
-package org.robolectric.shadows;
-
-import static android.content.pm.ApplicationInfo.FLAG_ALLOW_BACKUP;
-import static android.content.pm.ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
-import static android.content.pm.ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
-import static android.content.pm.ApplicationInfo.FLAG_DEBUGGABLE;
-import static android.content.pm.ApplicationInfo.FLAG_HAS_CODE;
-import static android.content.pm.ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
-import static android.content.pm.ApplicationInfo.FLAG_PERSISTENT;
-import static android.content.pm.ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
-import static android.content.pm.ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
-import static android.content.pm.ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
-import static android.content.pm.ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
-import static android.content.pm.ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
-import static android.content.pm.ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
-import static android.content.pm.ApplicationInfo.FLAG_TEST_ONLY;
-import static android.content.pm.ApplicationInfo.FLAG_VM_SAFE_MODE;
-import static android.os.PatternMatcher.PATTERN_LITERAL;
-import static android.os.PatternMatcher.PATTERN_PREFIX;
-import static android.os.PatternMatcher.PATTERN_SIMPLE_GLOB;
-import static java.util.Arrays.asList;
-
-import android.content.IntentFilter.MalformedMimeTypeException;
-import android.content.pm.ActivityInfo;
-import android.content.pm.ComponentInfo;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageItemInfo;
-import android.content.pm.PackageParser;
-import android.content.pm.PackageParser.Activity;
-import android.content.pm.PackageParser.ActivityIntentInfo;
-import android.content.pm.PackageParser.IntentInfo;
-import android.content.pm.PackageParser.Package;
-import android.content.pm.PackageParser.Permission;
-import android.content.pm.PackageParser.PermissionGroup;
-import android.content.pm.PackageParser.Service;
-import android.content.pm.PackageParser.ServiceIntentInfo;
-import android.content.pm.PathPermission;
-import android.content.pm.PermissionGroupInfo;
-import android.content.pm.PermissionInfo;
-import android.content.pm.ProviderInfo;
-import android.content.pm.ServiceInfo;
-import android.os.Build;
-import android.os.Build.VERSION_CODES;
-import android.os.Bundle;
-import android.os.Process;
-import android.util.Pair;
-import com.google.common.base.Strings;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.manifest.ActivityData;
-import org.robolectric.manifest.AndroidManifest;
-import org.robolectric.manifest.BroadcastReceiverData;
-import org.robolectric.manifest.ContentProviderData;
-import org.robolectric.manifest.IntentFilterData;
-import org.robolectric.manifest.IntentFilterData.DataAuthority;
-import org.robolectric.manifest.PackageItemData;
-import org.robolectric.manifest.PathPermissionData;
-import org.robolectric.manifest.PermissionGroupItemData;
-import org.robolectric.manifest.PermissionItemData;
-import org.robolectric.manifest.ServiceData;
-import org.robolectric.res.AttributeResource;
-import org.robolectric.res.ResName;
-import org.robolectric.util.ReflectionHelpers;
-
-/** Creates a {@link PackageInfo} from a {@link AndroidManifest} */
-@SuppressWarnings("NewApi")
-public class LegacyManifestParser {
-
-  private static final List<Pair<String, Integer>> APPLICATION_FLAGS =
-      asList(
-          Pair.create("android:allowBackup", FLAG_ALLOW_BACKUP),
-          Pair.create("android:allowClearUserData", FLAG_ALLOW_CLEAR_USER_DATA),
-          Pair.create("android:allowTaskReparenting", FLAG_ALLOW_TASK_REPARENTING),
-          Pair.create("android:debuggable", FLAG_DEBUGGABLE),
-          Pair.create("android:hasCode", FLAG_HAS_CODE),
-          Pair.create("android:killAfterRestore", FLAG_KILL_AFTER_RESTORE),
-          Pair.create("android:persistent", FLAG_PERSISTENT),
-          Pair.create("android:resizeable", FLAG_RESIZEABLE_FOR_SCREENS),
-          Pair.create("android:restoreAnyVersion", FLAG_RESTORE_ANY_VERSION),
-          Pair.create("android:largeScreens", FLAG_SUPPORTS_LARGE_SCREENS),
-          Pair.create("android:normalScreens", FLAG_SUPPORTS_NORMAL_SCREENS),
-          Pair.create("android:anyDensity", FLAG_SUPPORTS_SCREEN_DENSITIES),
-          Pair.create("android:smallScreens", FLAG_SUPPORTS_SMALL_SCREENS),
-          Pair.create("android:testOnly", FLAG_TEST_ONLY),
-          Pair.create("android:vmSafeMode", FLAG_VM_SAFE_MODE));
-  private static final List<Pair<String, Integer>> CONFIG_OPTIONS =
-      asList(
-          Pair.create("mcc", ActivityInfo.CONFIG_MCC),
-          Pair.create("mnc", ActivityInfo.CONFIG_MNC),
-          Pair.create("locale", ActivityInfo.CONFIG_LOCALE),
-          Pair.create("touchscreen", ActivityInfo.CONFIG_TOUCHSCREEN),
-          Pair.create("keyboard", ActivityInfo.CONFIG_KEYBOARD),
-          Pair.create("keyboardHidden", ActivityInfo.CONFIG_KEYBOARD_HIDDEN),
-          Pair.create("navigation", ActivityInfo.CONFIG_NAVIGATION),
-          Pair.create("screenLayout", ActivityInfo.CONFIG_SCREEN_LAYOUT),
-          Pair.create("fontScale", ActivityInfo.CONFIG_FONT_SCALE),
-          Pair.create("uiMode", ActivityInfo.CONFIG_UI_MODE),
-          Pair.create("orientation", ActivityInfo.CONFIG_ORIENTATION),
-          Pair.create("screenSize", ActivityInfo.CONFIG_SCREEN_SIZE),
-          Pair.create("smallestScreenSize", ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE));
-
-  public static Package createPackage(AndroidManifest androidManifest) {
-
-    Package pkg = new Package(androidManifest.getPackageName());
-
-    pkg.mVersionName = androidManifest.getVersionName();
-    pkg.mVersionCode = androidManifest.getVersionCode();
-
-    Map<String, PermissionItemData> permissionItemData = androidManifest.getPermissions();
-    for (PermissionItemData itemData : permissionItemData.values()) {
-      Permission permission = new Permission(pkg, createPermissionInfo(pkg, itemData));
-      permission.metaData = permission.info.metaData;
-      pkg.permissions.add(permission);
-    }
-
-    Map<String, PermissionGroupItemData> permissionGroupItemData =
-        androidManifest.getPermissionGroups();
-    for (PermissionGroupItemData itemData : permissionGroupItemData.values()) {
-      PermissionGroup permissionGroup =
-          new PermissionGroup(pkg, createPermissionGroupInfo(pkg, itemData));
-      permissionGroup.metaData = permissionGroup.info.metaData;
-      pkg.permissionGroups.add(permissionGroup);
-    }
-
-    pkg.requestedPermissions.addAll(androidManifest.getUsedPermissions());
-    if (RuntimeEnvironment.getApiLevel() < VERSION_CODES.M) {
-      List<Boolean> permissionsRequired =
-          ReflectionHelpers.getField(pkg, "requestedPermissionsRequired");
-      permissionsRequired.addAll(buildBooleanList(pkg.requestedPermissions.size(), true));
-    }
-
-    pkg.applicationInfo.flags = decodeFlags(androidManifest.getApplicationAttributes());
-    pkg.applicationInfo.targetSdkVersion = androidManifest.getTargetSdkVersion();
-    pkg.applicationInfo.packageName = androidManifest.getPackageName();
-    pkg.applicationInfo.processName = androidManifest.getProcessName();
-    if (!Strings.isNullOrEmpty(androidManifest.getApplicationName())) {
-      pkg.applicationInfo.className =
-          buildClassName(pkg.applicationInfo.packageName, androidManifest.getApplicationName());
-      if (RuntimeEnvironment.getApiLevel() >= VERSION_CODES.N_MR1) {
-        pkg.applicationInfo.name = pkg.applicationInfo.className;
-      }
-    }
-    pkg.applicationInfo.metaData = metaDataToBundle(androidManifest.getApplicationMetaData());
-    pkg.applicationInfo.uid = Process.myUid();
-    if (androidManifest.getThemeRef() != null) {
-      pkg.applicationInfo.theme =
-          RuntimeEnvironment.getAppResourceTable()
-              .getResourceId(
-                  ResName.qualifyResName(
-                      androidManifest.getThemeRef().replace("@", ""), pkg.packageName, "style"));
-    }
-
-    int labelRes = 0;
-    if (androidManifest.getLabelRef() != null) {
-      String fullyQualifiedName =
-          ResName.qualifyResName(androidManifest.getLabelRef(), androidManifest.getPackageName());
-      Integer id =
-          fullyQualifiedName == null
-              ? null
-              : RuntimeEnvironment.getAppResourceTable()
-                  .getResourceId(new ResName(fullyQualifiedName));
-      labelRes = id != null ? id : 0;
-    }
-
-    pkg.applicationInfo.labelRes = labelRes;
-    String labelRef = androidManifest.getLabelRef();
-    if (labelRef != null && !labelRef.startsWith("@")) {
-      pkg.applicationInfo.nonLocalizedLabel = labelRef;
-    }
-
-    Map<String, ActivityData> activityDatas = androidManifest.getActivityDatas();
-    for (ActivityData data : activityDatas.values()) {
-      ActivityInfo activityInfo = new ActivityInfo();
-      activityInfo.name = buildClassName(pkg.packageName, data.getName());
-      activityInfo.packageName = pkg.packageName;
-      activityInfo.configChanges = getConfigChanges(data);
-      activityInfo.parentActivityName = data.getParentActivityName();
-      activityInfo.metaData = metaDataToBundle(data.getMetaData().getValueMap());
-      activityInfo.applicationInfo = pkg.applicationInfo;
-      activityInfo.targetActivity = data.getTargetActivityName();
-      activityInfo.exported = data.isExported();
-      activityInfo.permission = data.getPermission();
-      activityInfo.enabled = data.isEnabled();
-      String themeRef;
-
-      // Based on ShadowActivity
-      if (data.getThemeRef() != null) {
-        themeRef = data.getThemeRef();
-      } else {
-        themeRef = androidManifest.getThemeRef();
-      }
-      if (themeRef != null) {
-        activityInfo.theme =
-            RuntimeEnvironment.getAppResourceTable()
-                .getResourceId(
-                    ResName.qualifyResName(themeRef.replace("@", ""), pkg.packageName, "style"));
-      }
-
-      if (data.getLabel() != null) {
-        activityInfo.labelRes =
-            RuntimeEnvironment.getAppResourceTable()
-                .getResourceId(
-                    ResName.qualifyResName(
-                        data.getLabel().replace("@", ""), pkg.packageName, "string"));
-        if (activityInfo.labelRes == 0) {
-          activityInfo.nonLocalizedLabel = data.getLabel();
-        }
-      }
-
-      Activity activity = createActivity(pkg, activityInfo);
-      for (IntentFilterData intentFilterData : data.getIntentFilters()) {
-        ActivityIntentInfo outInfo = new ActivityIntentInfo(activity);
-        populateIntentInfo(intentFilterData, outInfo);
-        activity.intents.add(outInfo);
-      }
-      pkg.activities.add(activity);
-    }
-
-    for (ContentProviderData data : androidManifest.getContentProviders()) {
-      ProviderInfo info = new ProviderInfo();
-      populateComponentInfo(info, pkg, data);
-      info.authority = data.getAuthorities();
-
-      List<PathPermission> permissions = new ArrayList<>();
-      for (PathPermissionData permissionData : data.getPathPermissionDatas()) {
-        permissions.add(createPathPermission(permissionData));
-      }
-      info.pathPermissions = permissions.toArray(new PathPermission[permissions.size()]);
-      info.readPermission = data.getReadPermission();
-      info.writePermission = data.getWritePermission();
-      info.grantUriPermissions = data.getGrantUriPermissions();
-      info.enabled = data.isEnabled();
-      pkg.providers.add(createProvider(pkg, info));
-    }
-
-    for (BroadcastReceiverData data : androidManifest.getBroadcastReceivers()) {
-      ActivityInfo info = new ActivityInfo();
-      populateComponentInfo(info, pkg, data);
-      info.permission = data.getPermission();
-      info.exported = data.isExported();
-      info.enabled = data.isEnabled();
-      Activity receiver = createActivity(pkg, info);
-      for (IntentFilterData intentFilterData : data.getIntentFilters()) {
-        ActivityIntentInfo outInfo = new ActivityIntentInfo(receiver);
-        populateIntentInfo(intentFilterData, outInfo);
-        receiver.intents.add(outInfo);
-      }
-      pkg.receivers.add(receiver);
-    }
-
-    for (ServiceData data : androidManifest.getServices()) {
-      ServiceInfo info = new ServiceInfo();
-      populateComponentInfo(info, pkg, data);
-      info.permission = data.getPermission();
-      info.exported = data.isExported();
-      info.enabled = data.isEnabled();
-
-      Service service = createService(pkg, info);
-      for (IntentFilterData intentFilterData : data.getIntentFilters()) {
-        ServiceIntentInfo outInfo = new ServiceIntentInfo(service);
-        populateIntentInfo(intentFilterData, outInfo);
-        service.intents.add(outInfo);
-      }
-      pkg.services.add(service);
-    }
-
-    String codePath = RuntimeEnvironment.getTempDirectory()
-        .createIfNotExists(pkg.packageName + "-codePath")
-        .toAbsolutePath()
-        .toString();
-    pkg.codePath = codePath;
-    return pkg;
-  }
-
-  private static PathPermission createPathPermission(PathPermissionData data) {
-    if (!Strings.isNullOrEmpty(data.pathPattern)) {
-      return new PathPermission(
-          data.pathPattern, PATTERN_SIMPLE_GLOB, data.readPermission, data.writePermission);
-    } else if (!Strings.isNullOrEmpty(data.path)) {
-      return new PathPermission(
-          data.path, PATTERN_LITERAL, data.readPermission, data.writePermission);
-    } else if (!Strings.isNullOrEmpty(data.pathPrefix)) {
-      return new PathPermission(
-          data.pathPrefix, PATTERN_PREFIX, data.readPermission, data.writePermission);
-    } else {
-      throw new IllegalStateException("Permission without type");
-    }
-  }
-
-  private static void populateComponentInfo(
-      ComponentInfo outInfo, Package owner, PackageItemData itemData) {
-    populatePackageItemInfo(outInfo, owner, itemData);
-    outInfo.applicationInfo = owner.applicationInfo;
-  }
-
-  private static void populatePackageItemInfo(
-      PackageItemInfo outInfo, Package owner, PackageItemData itemData) {
-    outInfo.name = buildClassName(owner.packageName, itemData.getName());
-    outInfo.packageName = owner.packageName;
-    outInfo.metaData = metaDataToBundle(itemData.getMetaData().getValueMap());
-  }
-
-  private static List<Boolean> buildBooleanList(int size, boolean defaultVal) {
-    Boolean[] barray = new Boolean[size];
-    Arrays.fill(barray, defaultVal);
-    return Arrays.asList(barray);
-  }
-
-  private static PackageParser.Provider createProvider(Package pkg, ProviderInfo info) {
-    PackageParser.Provider provider =
-        ReflectionHelpers.callConstructor(PackageParser.Provider.class);
-    populateComponent(pkg, info, provider);
-    return provider;
-  }
-
-  private static Activity createActivity(Package pkg, ActivityInfo activityInfo) {
-    Activity activity = ReflectionHelpers.callConstructor(Activity.class);
-    populateComponent(pkg, activityInfo, activity);
-    return activity;
-  }
-
-  private static Service createService(Package pkg, ServiceInfo info) {
-    PackageParser.Service service = ReflectionHelpers.callConstructor(PackageParser.Service.class);
-    populateComponent(pkg, info, service);
-    return service;
-  }
-
-  private static void populateComponent(
-      Package pkg, ComponentInfo info, PackageParser.Component component) {
-    ReflectionHelpers.setField(component, "info", info);
-    ReflectionHelpers.setField(component, "intents", new ArrayList<>());
-    ReflectionHelpers.setField(component, "owner", pkg);
-    ReflectionHelpers.setField(component, "className", info.name);
-  }
-
-  private static void populateIntentInfo(IntentFilterData intentFilterData, IntentInfo outInfo) {
-    for (String action : intentFilterData.getActions()) {
-      outInfo.addAction(action);
-    }
-    for (String category : intentFilterData.getCategories()) {
-      outInfo.addCategory(category);
-    }
-    for (DataAuthority dataAuthority : intentFilterData.getAuthorities()) {
-      outInfo.addDataAuthority(dataAuthority.getHost(), dataAuthority.getPort());
-    }
-    for (String mimeType : intentFilterData.getMimeTypes()) {
-      try {
-        outInfo.addDataType(mimeType);
-      } catch (MalformedMimeTypeException e) {
-        throw new RuntimeException(e);
-      }
-    }
-    for (String scheme : intentFilterData.getSchemes()) {
-      outInfo.addDataScheme(scheme);
-    }
-    for (String pathPattern : intentFilterData.getPathPatterns()) {
-      outInfo.addDataPath(pathPattern, PATTERN_SIMPLE_GLOB);
-    }
-    for (String pathPattern : intentFilterData.getPathPrefixes()) {
-      outInfo.addDataPath(pathPattern, PATTERN_PREFIX);
-    }
-    for (String pathPattern : intentFilterData.getPaths()) {
-      outInfo.addDataPath(pathPattern, PATTERN_LITERAL);
-    }
-  }
-
-  private static int getConfigChanges(ActivityData activityData) {
-    String s = activityData.getConfigChanges();
-
-    int res = 0;
-
-    // quick sanity check.
-    if (s == null || "".equals(s)) {
-      return res;
-    }
-
-    String[] pieces = s.split("\\|", 0);
-
-    for (String s1 : pieces) {
-      s1 = s1.trim();
-
-      for (Pair<String, Integer> pair : CONFIG_OPTIONS) {
-        if (s1.equals(pair.first)) {
-          res |= pair.second;
-          break;
-        }
-      }
-    }
-
-    // Matches platform behavior
-    if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.O) {
-      res |= ActivityInfo.CONFIG_MNC;
-      res |= ActivityInfo.CONFIG_MCC;
-    }
-
-    return res;
-  }
-
-  private static int decodeFlags(Map<String, String> applicationAttributes) {
-    int applicationFlags = 0;
-    for (Pair<String, Integer> pair : APPLICATION_FLAGS) {
-      if ("true".equals(applicationAttributes.get(pair.first))) {
-        applicationFlags |= pair.second;
-      }
-    }
-    return applicationFlags;
-  }
-
-  private static PermissionInfo createPermissionInfo(Package owner, PermissionItemData itemData) {
-    PermissionInfo permissionInfo = new PermissionInfo();
-    populatePackageItemInfo(permissionInfo, owner, itemData);
-
-    permissionInfo.group = itemData.getPermissionGroup();
-    permissionInfo.protectionLevel = decodeProtectionLevel(itemData.getProtectionLevel());
-    permissionInfo.metaData = metaDataToBundle(itemData.getMetaData().getValueMap());
-
-    String descriptionRef = itemData.getDescription();
-    if (descriptionRef != null) {
-      ResName descResName =
-          AttributeResource.getResourceReference(descriptionRef, owner.packageName, "string");
-      permissionInfo.descriptionRes =
-          RuntimeEnvironment.getAppResourceTable().getResourceId(descResName);
-    }
-
-    String labelRefOrString = itemData.getLabel();
-    if (labelRefOrString != null) {
-      if (AttributeResource.isResourceReference(labelRefOrString)) {
-        ResName labelResName =
-            AttributeResource.getResourceReference(labelRefOrString, owner.packageName, "string");
-        permissionInfo.labelRes =
-            RuntimeEnvironment.getAppResourceTable().getResourceId(labelResName);
-      } else {
-        permissionInfo.nonLocalizedLabel = labelRefOrString;
-      }
-    }
-
-    return permissionInfo;
-  }
-
-  private static PermissionGroupInfo createPermissionGroupInfo(Package owner,
-      PermissionGroupItemData itemData) {
-    PermissionGroupInfo permissionGroupInfo = new PermissionGroupInfo();
-    populatePackageItemInfo(permissionGroupInfo, owner, itemData);
-
-    permissionGroupInfo.metaData = metaDataToBundle(itemData.getMetaData().getValueMap());
-
-    String descriptionRef = itemData.getDescription();
-    if (descriptionRef != null) {
-      ResName descResName =
-          AttributeResource.getResourceReference(descriptionRef, owner.packageName, "string");
-      permissionGroupInfo.descriptionRes =
-          RuntimeEnvironment.getAppResourceTable().getResourceId(descResName);
-    }
-
-    String labelRefOrString = itemData.getLabel();
-    if (labelRefOrString != null) {
-      if (AttributeResource.isResourceReference(labelRefOrString)) {
-        ResName labelResName =
-            AttributeResource.getResourceReference(labelRefOrString, owner.packageName, "string");
-        permissionGroupInfo.labelRes =
-            RuntimeEnvironment.getAppResourceTable().getResourceId(labelResName);
-      } else {
-        permissionGroupInfo.nonLocalizedLabel = labelRefOrString;
-      }
-    }
-
-    return permissionGroupInfo;
-  }
-
-  private static int decodeProtectionLevel(String protectionLevel) {
-    if (protectionLevel == null) {
-      return PermissionInfo.PROTECTION_NORMAL;
-    }
-
-    int permissions = PermissionInfo.PROTECTION_NORMAL;
-    String[] levels = protectionLevel.split("\\|", 0);
-
-    for (String level : levels) {
-      switch (level) {
-        case "normal":
-          permissions |= PermissionInfo.PROTECTION_NORMAL;
-          break;
-        case "dangerous":
-          permissions |= PermissionInfo.PROTECTION_DANGEROUS;
-          break;
-        case "signature":
-          permissions |= PermissionInfo.PROTECTION_SIGNATURE;
-          break;
-        case "signatureOrSystem":
-          permissions |= PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM;
-          break;
-        case "privileged":
-          permissions |= PermissionInfo.PROTECTION_FLAG_PRIVILEGED;
-          break;
-        case "system":
-          permissions |= PermissionInfo.PROTECTION_FLAG_SYSTEM;
-          break;
-        case "development":
-          permissions |= PermissionInfo.PROTECTION_FLAG_DEVELOPMENT;
-          break;
-        case "appop":
-          permissions |= PermissionInfo.PROTECTION_FLAG_APPOP;
-          break;
-        case "pre23":
-          permissions |= PermissionInfo.PROTECTION_FLAG_PRE23;
-          break;
-        case "installer":
-          permissions |= PermissionInfo.PROTECTION_FLAG_INSTALLER;
-          break;
-        case "verifier":
-          permissions |= PermissionInfo.PROTECTION_FLAG_VERIFIER;
-          break;
-        case "preinstalled":
-          permissions |= PermissionInfo.PROTECTION_FLAG_PREINSTALLED;
-          break;
-        case "setup":
-          permissions |= PermissionInfo.PROTECTION_FLAG_SETUP;
-          break;
-        case "instant":
-          permissions |= PermissionInfo.PROTECTION_FLAG_INSTANT;
-          break;
-        case "runtime":
-          permissions |= PermissionInfo.PROTECTION_FLAG_RUNTIME_ONLY;
-          break;
-        case "oem":
-          permissions |= PermissionInfo.PROTECTION_FLAG_OEM;
-          break;
-        case "vendorPrivileged":
-          permissions |= PermissionInfo.PROTECTION_FLAG_VENDOR_PRIVILEGED;
-          break;
-        case "textClassifier":
-          permissions |= PermissionInfo.PROTECTION_FLAG_SYSTEM_TEXT_CLASSIFIER;
-          break;
-        default:
-          throw new IllegalArgumentException("unknown protection level " + protectionLevel);
-      }
-    }
-    return permissions;
-  }
-
-  /**
-   * Goes through the meta data and puts each value in to a bundle as the correct type.
-   *
-   * <p>Note that this will convert resource identifiers specified via the value attribute as well.
-   *
-   * @param meta Meta data to put in to a bundle
-   * @return bundle containing the meta data
-   */
-  private static Bundle metaDataToBundle(Map<String, Object> meta) {
-    if (meta.size() == 0) {
-      return null;
-    }
-
-    Bundle bundle = new Bundle();
-
-    for (Map.Entry<String, Object> entry : meta.entrySet()) {
-      String key = entry.getKey();
-      Object value = entry.getValue();
-      if (Boolean.class.isInstance(value)) {
-        bundle.putBoolean(key, (Boolean) value);
-      } else if (Float.class.isInstance(value)) {
-        bundle.putFloat(key, (Float) value);
-      } else if (Integer.class.isInstance(value)) {
-        bundle.putInt(key, (Integer) value);
-      } else {
-        bundle.putString(key, value == null ? null : value.toString());
-      }
-    }
-    return bundle;
-  }
-
-  private static String buildClassName(String pkg, String cls) {
-    if (Strings.isNullOrEmpty(cls)) {
-      throw new IllegalArgumentException("Empty class name in package " + pkg);
-    }
-    char c = cls.charAt(0);
-    if (c == '.') {
-      return (pkg + cls).intern();
-    }
-    if (cls.indexOf('.') < 0) {
-      StringBuilder b = new StringBuilder(pkg);
-      b.append('.');
-      b.append(cls);
-      return b.toString();
-    }
-    return cls;
-    // TODO: consider reenabling this for stricter platform-complaint checking
-    // if (c >= 'a' && c <= 'z') {
-    // return cls;
-    // }
-    // throw new IllegalArgumentException("Bad class name " + cls + " in package " + pkg);
-  }
-}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/NativeAndroidInput.java b/shadows/framework/src/main/java/org/robolectric/shadows/NativeAndroidInput.java
index c83728d9e..83fa45aa4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/NativeAndroidInput.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/NativeAndroidInput.java
@@ -4,7 +4,8 @@ package org.robolectric.shadows;
  * Java representation of framework native system headers Transliterated from oreo-mr1 (SDK 27)
  * frameworks/native/include/android/Input.h
  *
- * @see <a href="https://android.googlesource.com/platform/frameworks/native/+/oreo-mr1-release/include/android/input.h">include/android/input.h</a>
+ * @see <a
+ *     href="https://android.googlesource.com/platform/frameworks/native/+/oreo-mr1-release/include/android/input.h">include/android/input.h</a>
  */
 public class NativeAndroidInput {
 
@@ -14,62 +15,85 @@ public class NativeAndroidInput {
    */
   /** The key state is unknown or the requested key itself is not supported. */
   static final int AKEY_STATE_UNKNOWN = -1;
+
   /** The key is up. */
   static final int AKEY_STATE_UP = 0;
+
   /** The key is down. */
   static final int AKEY_STATE_DOWN = 1;
+
   /** The key is down but is a virtual key press that is being emulated by the system. */
   static final int AKEY_STATE_VIRTUAL = 2;
 
   /** Meta key / modifer state. */
   /** No meta keys are pressed. */
   static final int AMETA_NONE = 0;
+
   /** This mask is used to check whether one of the ALT meta keys is pressed. */
   static final int AMETA_ALT_ON = 0x02;
+
   /** This mask is used to check whether the left ALT meta key is pressed. */
   static final int AMETA_ALT_LEFT_ON = 0x10;
+
   /** This mask is used to check whether the right ALT meta key is pressed. */
   static final int AMETA_ALT_RIGHT_ON = 0x20;
+
   /** This mask is used to check whether one of the SHIFT meta keys is pressed. */
   static final int AMETA_SHIFT_ON = 0x01;
+
   /** This mask is used to check whether the left SHIFT meta key is pressed. */
   static final int AMETA_SHIFT_LEFT_ON = 0x40;
+
   /** This mask is used to check whether the right SHIFT meta key is pressed. */
   static final int AMETA_SHIFT_RIGHT_ON = 0x80;
+
   /** This mask is used to check whether the SYM meta key is pressed. */
   static final int AMETA_SYM_ON = 0x04;
+
   /** This mask is used to check whether the FUNCTION meta key is pressed. */
   static final int AMETA_FUNCTION_ON = 0x08;
+
   /** This mask is used to check whether one of the CTRL meta keys is pressed. */
   static final int AMETA_CTRL_ON = 0x1000;
+
   /** This mask is used to check whether the left CTRL meta key is pressed. */
   static final int AMETA_CTRL_LEFT_ON = 0x2000;
+
   /** This mask is used to check whether the right CTRL meta key is pressed. */
   static final int AMETA_CTRL_RIGHT_ON = 0x4000;
+
   /** This mask is used to check whether one of the META meta keys is pressed. */
   static final int AMETA_META_ON = 0x10000;
+
   /** This mask is used to check whether the left META meta key is pressed. */
   static final int AMETA_META_LEFT_ON = 0x20000;
+
   /** This mask is used to check whether the right META meta key is pressed. */
   static final int AMETA_META_RIGHT_ON = 0x40000;
+
   /** This mask is used to check whether the CAPS LOCK meta key is on. */
   static final int AMETA_CAPS_LOCK_ON = 0x100000;
+
   /** This mask is used to check whether the NUM LOCK meta key is on. */
   static final int AMETA_NUM_LOCK_ON = 0x200000;
+
   /** This mask is used to check whether the SCROLL LOCK meta key is on. */
   static final int AMETA_SCROLL_LOCK_ON = 0x400000;
 
   /** Input event types. */
   /** Indicates that the input event is a key event. */
   static final int AINPUT_EVENT_TYPE_KEY = 1;
+
   /** Indicates that the input event is a motion event. */
   static final int AINPUT_EVENT_TYPE_MOTION = 2;
 
   /** Key event actions. */
   /** The key has been pressed down. */
   static final int AKEY_EVENT_ACTION_DOWN = 0;
+
   /** The key has been released. */
   static final int AKEY_EVENT_ACTION_UP = 1;
+
   /**
    * Multiple duplicate key events have occurred in a row, or a complex string is being delivered.
    * The repeat_count property of the key event contains the number of times the given key code
@@ -81,16 +105,20 @@ public class NativeAndroidInput {
 
   /** This mask is set if the device woke because of this key event. */
   static final int AKEY_EVENT_FLAG_WOKE_HERE = 0x1;
+
   /** This mask is set if the key event was generated by a software keyboard. */
   static final int AKEY_EVENT_FLAG_SOFT_KEYBOARD = 0x2;
+
   /** This mask is set if we don't want the key event to cause us to leave touch mode. */
   static final int AKEY_EVENT_FLAG_KEEP_TOUCH_MODE = 0x4;
+
   /**
    * This mask is set if an event was known to come from a trusted part of the system. That is; the
    * event is known to come from the user; and could not have been spoofed by a third party
    * component.
    */
   static final int AKEY_EVENT_FLAG_FROM_SYSTEM = 0x8;
+
   /**
    * This mask is used for compatibility; to identify enter keys that are coming from an IME whose
    * enter key has been auto-labelled "next" or "done". This allows TextView to dispatch these as
@@ -98,6 +126,7 @@ public class NativeAndroidInput {
    * them.
    */
   static final int AKEY_EVENT_FLAG_EDITOR_ACTION = 0x10;
+
   /**
    * When associated with up key events; this indicates that the key press has been canceled.
    * Typically this is used with virtual touch screen keys; where the user can slide from the
@@ -107,24 +136,29 @@ public class NativeAndroidInput {
    * press timeout has expired.
    */
   static final int AKEY_EVENT_FLAG_CANCELED = 0x20;
+
   /**
    * This key event was generated by a virtual (on-screen) hard key area. Typically this is an area
    * of the touchscreen; outside of the regular display; dedicated to "hardware" buttons.
    */
   static final int AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY = 0x40;
+
   /** This flag is set for the first key repeat that occurs after the long press timeout. */
   static final int AKEY_EVENT_FLAG_LONG_PRESS = 0x80;
+
   /**
    * Set when a key event has AKEY_EVENT_FLAG_CANCELED set because a long press action was executed
    * while it was down.
    */
   static final int AKEY_EVENT_FLAG_CANCELED_LONG_PRESS = 0x100;
+
   /**
    * Set for AKEY_EVENT_ACTION_UP when this event's key code is still being tracked from its initial
    * down. That is; somebody requested that tracking started on the key down and a long press has
    * not caused the tracking to be canceled.
    */
   static final int AKEY_EVENT_FLAG_TRACKING = 0x200;
+
   /**
    * Set when a key event has been synthesized to implement default behavior for an event that the
    * application did not handle. Fallback key events are generated by unhandled trackball motions
@@ -143,6 +177,7 @@ public class NativeAndroidInput {
 
   /** Bit mask of the parts of the action code that are the action itself. */
   static final int AMOTION_EVENT_ACTION_MASK = 0xff;
+
   /**
    * Bits in the action code that represent a pointer index; used with
    * AMOTION_EVENT_ACTION_POINTER_DOWN and AMOTION_EVENT_ACTION_POINTER_UP. Shifting down by
@@ -150,45 +185,54 @@ public class NativeAndroidInput {
    * the pointer going up or down can be found.
    */
   static final int AMOTION_EVENT_ACTION_POINTER_INDEX_MASK = 0xff00;
+
   /** A pressed gesture has started; the motion contains the initial starting location. */
   static final int AMOTION_EVENT_ACTION_DOWN = 0;
+
   /**
    * A pressed gesture has finished; the motion contains the final release location as well as any
    * intermediate points since the last down or move event.
    */
   static final int AMOTION_EVENT_ACTION_UP = 1;
+
   /**
    * A change has happened during a press gesture (between AMOTION_EVENT_ACTION_DOWN and
    * AMOTION_EVENT_ACTION_UP). The motion contains the most recent point; as well as any
    * intermediate points since the last down or move event.
    */
   static final int AMOTION_EVENT_ACTION_MOVE = 2;
+
   /**
    * The current gesture has been aborted. You will not receive any more points in it. You should
    * treat this as an up event; but not perform any action that you normally would.
    */
   static final int AMOTION_EVENT_ACTION_CANCEL = 3;
+
   /**
    * A movement has happened outside of the normal bounds of the UI element. This does not provide a
    * full gesture; but only the initial location of the movement/touch.
    */
   static final int AMOTION_EVENT_ACTION_OUTSIDE = 4;
+
   /**
    * A non-primary pointer has gone down. The bits in AMOTION_EVENT_ACTION_POINTER_INDEX_MASK
    * indicate which pointer changed.
    */
   static final int AMOTION_EVENT_ACTION_POINTER_DOWN = 5;
+
   /**
    * A non-primary pointer has gone up. The bits in AMOTION_EVENT_ACTION_POINTER_INDEX_MASK indicate
    * which pointer changed.
    */
   static final int AMOTION_EVENT_ACTION_POINTER_UP = 6;
+
   /**
    * A change happened but the pointer is not down (unlike AMOTION_EVENT_ACTION_MOVE). The motion
    * contains the most recent point; as well as any intermediate points since the last hover move
    * event.
    */
   static final int AMOTION_EVENT_ACTION_HOVER_MOVE = 7;
+
   /**
    * The motion event contains relative vertical and/or horizontal scroll offsets. Use getAxisValue
    * to retrieve the information from AMOTION_EVENT_AXIS_VSCROLL and AMOTION_EVENT_AXIS_HSCROLL. The
@@ -196,10 +240,13 @@ public class NativeAndroidInput {
    * to the winder under the pointer; which may not be the window currently touched.
    */
   static final int AMOTION_EVENT_ACTION_SCROLL = 8;
+
   /** The pointer is not down but has entered the boundaries of a window or view. */
   static final int AMOTION_EVENT_ACTION_HOVER_ENTER = 9;
+
   /** The pointer is not down but has exited the boundaries of a window or view. */
   static final int AMOTION_EVENT_ACTION_HOVER_EXIT = 10;
+
   /* One or more buttons have been pressed. */
   static final int AMOTION_EVENT_ACTION_BUTTON_PRESS = 11;
   /* One or more buttons have been released. */
@@ -220,12 +267,16 @@ public class NativeAndroidInput {
   /** Motion event edge touch flags. */
   /** No edges intersected. */
   static final int AMOTION_EVENT_EDGE_FLAG_NONE = 0;
+
   /** Flag indicating the motion event intersected the top edge of the screen. */
   static final int AMOTION_EVENT_EDGE_FLAG_TOP = 0x01;
+
   /** Flag indicating the motion event intersected the bottom edge of the screen. */
   static final int AMOTION_EVENT_EDGE_FLAG_BOTTOM = 0x02;
+
   /** Flag indicating the motion event intersected the left edge of the screen. */
   static final int AMOTION_EVENT_EDGE_FLAG_LEFT = 0x04;
+
   /** Flag indicating the motion event intersected the right edge of the screen. */
   static final int AMOTION_EVENT_EDGE_FLAG_RIGHT = 0x08;
 
@@ -247,6 +298,7 @@ public class NativeAndroidInput {
    * (right).
    */
   static final int AMOTION_EVENT_AXIS_X = 0;
+
   /**
    * Axis constant: Y axis of a motion event.
    *
@@ -260,6 +312,7 @@ public class NativeAndroidInput {
    * to 1.0 (down or near).
    */
   static final int AMOTION_EVENT_AXIS_Y = 1;
+
   /**
    * Axis constant: Pressure axis of a motion event.
    *
@@ -271,6 +324,7 @@ public class NativeAndroidInput {
    * pressed or 0 otherwise.
    */
   static final int AMOTION_EVENT_AXIS_PRESSURE = 2;
+
   /**
    * Axis constant: Size axis of a motion event.
    *
@@ -281,6 +335,7 @@ public class NativeAndroidInput {
    * AMOTION_EVENT_AXIS_TOUCH_MAJOR} or {@link AMOTION_EVENT_AXIS_TOOL_MAJOR}.
    */
   static final int AMOTION_EVENT_AXIS_SIZE = 3;
+
   /**
    * Axis constant: TouchMajor axis of a motion event.
    *
@@ -290,6 +345,7 @@ public class NativeAndroidInput {
    * contact. The units are device-dependent.
    */
   static final int AMOTION_EVENT_AXIS_TOUCH_MAJOR = 4;
+
   /**
    * Axis constant: TouchMinor axis of a motion event.
    *
@@ -301,6 +357,7 @@ public class NativeAndroidInput {
    * <p>When the touch is circular; the major and minor axis lengths will be equal to one another.
    */
   static final int AMOTION_EVENT_AXIS_TOUCH_MINOR = 5;
+
   /**
    * Axis constant: ToolMajor axis of a motion event.
    *
@@ -315,6 +372,7 @@ public class NativeAndroidInput {
    * with the touch sensor.
    */
   static final int AMOTION_EVENT_AXIS_TOOL_MAJOR = 6;
+
   /**
    * Axis constant: ToolMinor axis of a motion event.
    *
@@ -329,6 +387,7 @@ public class NativeAndroidInput {
    * with the touch sensor.
    */
   static final int AMOTION_EVENT_AXIS_TOOL_MINOR = 7;
+
   /**
    * Axis constant: Orientation axis of a motion event.
    *
@@ -344,6 +403,7 @@ public class NativeAndroidInput {
    * pointing down; and PI/2 radians is pointing right. See also {@link AMOTION_EVENT_AXIS_TILT}.
    */
   static final int AMOTION_EVENT_AXIS_ORIENTATION = 8;
+
   /**
    * Axis constant: Vertical Scroll axis of a motion event.
    *
@@ -353,6 +413,7 @@ public class NativeAndroidInput {
    * <p>This axis should be used to scroll views vertically.
    */
   static final int AMOTION_EVENT_AXIS_VSCROLL = 9;
+
   /**
    * Axis constant: Horizontal Scroll axis of a motion event.
    *
@@ -362,6 +423,7 @@ public class NativeAndroidInput {
    * <p>This axis should be used to scroll views horizontally.
    */
   static final int AMOTION_EVENT_AXIS_HSCROLL = 10;
+
   /**
    * Axis constant: Z axis of a motion event.
    *
@@ -370,6 +432,7 @@ public class NativeAndroidInput {
    * is often reinterpreted to report the absolute X position of the second joystick instead.</em>
    */
   static final int AMOTION_EVENT_AXIS_Z = 11;
+
   /**
    * Axis constant: X Rotation axis of a motion event.
    *
@@ -377,6 +440,7 @@ public class NativeAndroidInput {
    * normalized to a range from -1.0 (counter-clockwise) to 1.0 (clockwise).
    */
   static final int AMOTION_EVENT_AXIS_RX = 12;
+
   /**
    * Axis constant: Y Rotation axis of a motion event.
    *
@@ -384,6 +448,7 @@ public class NativeAndroidInput {
    * normalized to a range from -1.0 (counter-clockwise) to 1.0 (clockwise).
    */
   static final int AMOTION_EVENT_AXIS_RY = 13;
+
   /**
    * Axis constant: Z Rotation axis of a motion event.
    *
@@ -393,6 +458,7 @@ public class NativeAndroidInput {
    * second joystick instead.
    */
   static final int AMOTION_EVENT_AXIS_RZ = 14;
+
   /**
    * Axis constant: Hat X axis of a motion event.
    *
@@ -400,6 +466,7 @@ public class NativeAndroidInput {
    * is normalized to a range from -1.0 (left) to 1.0 (right).
    */
   static final int AMOTION_EVENT_AXIS_HAT_X = 15;
+
   /**
    * Axis constant: Hat Y axis of a motion event.
    *
@@ -407,6 +474,7 @@ public class NativeAndroidInput {
    * is normalized to a range from -1.0 (up) to 1.0 (down).
    */
   static final int AMOTION_EVENT_AXIS_HAT_Y = 16;
+
   /**
    * Axis constant: Left Trigger axis of a motion event.
    *
@@ -414,6 +482,7 @@ public class NativeAndroidInput {
    * normalized to a range from 0.0 (released) to 1.0 (fully pressed).
    */
   static final int AMOTION_EVENT_AXIS_LTRIGGER = 17;
+
   /**
    * Axis constant: Right Trigger axis of a motion event.
    *
@@ -421,6 +490,7 @@ public class NativeAndroidInput {
    * normalized to a range from 0.0 (released) to 1.0 (fully pressed).
    */
   static final int AMOTION_EVENT_AXIS_RTRIGGER = 18;
+
   /**
    * Axis constant: Throttle axis of a motion event.
    *
@@ -428,6 +498,7 @@ public class NativeAndroidInput {
    * normalized to a range from 0.0 (fully open) to 1.0 (fully closed).
    */
   static final int AMOTION_EVENT_AXIS_THROTTLE = 19;
+
   /**
    * Axis constant: Rudder axis of a motion event.
    *
@@ -435,6 +506,7 @@ public class NativeAndroidInput {
    * normalized to a range from -1.0 (turn left) to 1.0 (turn right).
    */
   static final int AMOTION_EVENT_AXIS_RUDDER = 20;
+
   /**
    * Axis constant: Wheel axis of a motion event.
    *
@@ -442,6 +514,7 @@ public class NativeAndroidInput {
    * normalized to a range from -1.0 (turn left) to 1.0 (turn right).
    */
   static final int AMOTION_EVENT_AXIS_WHEEL = 21;
+
   /**
    * Axis constant: Gas axis of a motion event.
    *
@@ -449,6 +522,7 @@ public class NativeAndroidInput {
    * is normalized to a range from 0.0 (no acceleration) to 1.0 (maximum acceleration).
    */
   static final int AMOTION_EVENT_AXIS_GAS = 22;
+
   /**
    * Axis constant: Brake axis of a motion event.
    *
@@ -456,6 +530,7 @@ public class NativeAndroidInput {
    * normalized to a range from 0.0 (no braking) to 1.0 (maximum braking).
    */
   static final int AMOTION_EVENT_AXIS_BRAKE = 23;
+
   /**
    * Axis constant: Distance axis of a motion event.
    *
@@ -463,6 +538,7 @@ public class NativeAndroidInput {
    * direct contact and larger values indicate increasing distance from the surface.
    */
   static final int AMOTION_EVENT_AXIS_DISTANCE = 24;
+
   /**
    * Axis constant: Tilt axis of a motion event.
    *
@@ -471,6 +547,7 @@ public class NativeAndroidInput {
    * stylus is being held flat against the surface.
    */
   static final int AMOTION_EVENT_AXIS_TILT = 25;
+
   /**
    * Axis constant: Generic scroll axis of a motion event.
    *
@@ -478,6 +555,7 @@ public class NativeAndroidInput {
    * or horizontal. The movement of a rotating scroller is an example of this.
    */
   static final int AMOTION_EVENT_AXIS_SCROLL = 26;
+
   /**
    * Axis constant: The movement of x position of a motion event.
    *
@@ -486,87 +564,104 @@ public class NativeAndroidInput {
    * this axis reports the difference which allows the app to see how the mouse is moved.
    */
   static final int AMOTION_EVENT_AXIS_RELATIVE_X = 27;
+
   /**
    * Axis constant: The movement of y position of a motion event.
    *
    * <p>Same as {@link RELATIVE_X}; but for y position.
    */
   static final int AMOTION_EVENT_AXIS_RELATIVE_Y = 28;
+
   /**
    * Axis constant: Generic 1 axis of a motion event. The interpretation of a generic axis is
    * device-specific.
    */
   static final int AMOTION_EVENT_AXIS_GENERIC_1 = 32;
+
   /**
    * Axis constant: Generic 2 axis of a motion event. The interpretation of a generic axis is
    * device-specific.
    */
   static final int AMOTION_EVENT_AXIS_GENERIC_2 = 33;
+
   /**
    * Axis constant: Generic 3 axis of a motion event. The interpretation of a generic axis is
    * device-specific.
    */
   static final int AMOTION_EVENT_AXIS_GENERIC_3 = 34;
+
   /**
    * Axis constant: Generic 4 axis of a motion event. The interpretation of a generic axis is
    * device-specific.
    */
   static final int AMOTION_EVENT_AXIS_GENERIC_4 = 35;
+
   /**
    * Axis constant: Generic 5 axis of a motion event. The interpretation of a generic axis is
    * device-specific.
    */
   static final int AMOTION_EVENT_AXIS_GENERIC_5 = 36;
+
   /**
    * Axis constant: Generic 6 axis of a motion event. The interpretation of a generic axis is
    * device-specific.
    */
   static final int AMOTION_EVENT_AXIS_GENERIC_6 = 37;
+
   /**
    * Axis constant: Generic 7 axis of a motion event. The interpretation of a generic axis is
    * device-specific.
    */
   static final int AMOTION_EVENT_AXIS_GENERIC_7 = 38;
+
   /**
    * Axis constant: Generic 8 axis of a motion event. The interpretation of a generic axis is
    * device-specific.
    */
   static final int AMOTION_EVENT_AXIS_GENERIC_8 = 39;
+
   /**
    * Axis constant: Generic 9 axis of a motion event. The interpretation of a generic axis is
    * device-specific.
    */
   static final int AMOTION_EVENT_AXIS_GENERIC_9 = 40;
+
   /**
    * Axis constant: Generic 10 axis of a motion event. The interpretation of a generic axis is
    * device-specific.
    */
   static final int AMOTION_EVENT_AXIS_GENERIC_10 = 41;
+
   /**
    * Axis constant: Generic 11 axis of a motion event. The interpretation of a generic axis is
    * device-specific.
    */
   static final int AMOTION_EVENT_AXIS_GENERIC_11 = 42;
+
   /**
    * Axis constant: Generic 12 axis of a motion event. The interpretation of a generic axis is
    * device-specific.
    */
   static final int AMOTION_EVENT_AXIS_GENERIC_12 = 43;
+
   /**
    * Axis constant: Generic 13 axis of a motion event. The interpretation of a generic axis is
    * device-specific.
    */
   static final int AMOTION_EVENT_AXIS_GENERIC_13 = 44;
+
   /**
    * Axis constant: Generic 14 axis of a motion event. The interpretation of a generic axis is
    * device-specific.
    */
   static final int AMOTION_EVENT_AXIS_GENERIC_14 = 45;
+
   /**
    * Axis constant: Generic 15 axis of a motion event. The interpretation of a generic axis is
    * device-specific.
    */
   static final int AMOTION_EVENT_AXIS_GENERIC_15 = 46;
+
   /**
    * Axis constant: Generic 16 axis of a motion event. The interpretation of a generic axis is
    * device-specific.
@@ -582,12 +677,16 @@ public class NativeAndroidInput {
    */
   /** primary */
   static final int AMOTION_EVENT_BUTTON_PRIMARY = 1 << 0;
+
   /** secondary */
   static final int AMOTION_EVENT_BUTTON_SECONDARY = 1 << 1;
+
   /** tertiary */
   static final int AMOTION_EVENT_BUTTON_TERTIARY = 1 << 2;
+
   /** back */
   static final int AMOTION_EVENT_BUTTON_BACK = 1 << 3;
+
   /** forward */
   static final int AMOTION_EVENT_BUTTON_FORWARD = 1 << 4;
 
@@ -600,12 +699,16 @@ public class NativeAndroidInput {
    */
   /** unknown */
   static final int AMOTION_EVENT_TOOL_TYPE_UNKNOWN = 0;
+
   /** finger */
   static final int AMOTION_EVENT_TOOL_TYPE_FINGER = 1;
+
   /** stylus */
   static final int AMOTION_EVENT_TOOL_TYPE_STYLUS = 2;
+
   /** mouse */
   static final int AMOTION_EVENT_TOOL_TYPE_MOUSE = 3;
+
   /** eraser */
   static final int AMOTION_EVENT_TOOL_TYPE_ERASER = 4;
 
@@ -617,48 +720,68 @@ public class NativeAndroidInput {
    */
   /** mask */
   static final int AINPUT_SOURCE_CLASS_MASK = 0x000000ff;
+
   /** none */
   static final int AINPUT_SOURCE_CLASS_NONE = 0x00000000;
+
   /** button */
   static final int AINPUT_SOURCE_CLASS_BUTTON = 0x00000001;
+
   /** pointer */
   static final int AINPUT_SOURCE_CLASS_POINTER = 0x00000002;
+
   /** navigation */
   static final int AINPUT_SOURCE_CLASS_NAVIGATION = 0x00000004;
+
   /** position */
   static final int AINPUT_SOURCE_CLASS_POSITION = 0x00000008;
+
   /** joystick */
   static final int AINPUT_SOURCE_CLASS_JOYSTICK = 0x00000010;
 
   /** Input sources. */
   /** unknown */
   static final int AINPUT_SOURCE_UNKNOWN = 0x00000000;
+
   /** keyboard */
   static final int AINPUT_SOURCE_KEYBOARD = 0x00000100 | AINPUT_SOURCE_CLASS_BUTTON;
+
   /** dpad */
   static final int AINPUT_SOURCE_DPAD = 0x00000200 | AINPUT_SOURCE_CLASS_BUTTON;
+
   /** gamepad */
   static final int AINPUT_SOURCE_GAMEPAD = 0x00000400 | AINPUT_SOURCE_CLASS_BUTTON;
+
   /** touchscreen */
   static final int AINPUT_SOURCE_TOUCHSCREEN = 0x00001000 | AINPUT_SOURCE_CLASS_POINTER;
+
   /** mouse */
   static final int AINPUT_SOURCE_MOUSE = 0x00002000 | AINPUT_SOURCE_CLASS_POINTER;
+
   /** stylus */
   static final int AINPUT_SOURCE_STYLUS = 0x00004000 | AINPUT_SOURCE_CLASS_POINTER;
+
   /** bluetooth stylus */
   static final int AINPUT_SOURCE_BLUETOOTH_STYLUS = 0x00008000 | AINPUT_SOURCE_STYLUS;
+
   /** trackball */
   static final int AINPUT_SOURCE_TRACKBALL = 0x00010000 | AINPUT_SOURCE_CLASS_NAVIGATION;
+
   /** mouse relative */
   static final int AINPUT_SOURCE_MOUSE_RELATIVE = 0x00020000 | AINPUT_SOURCE_CLASS_NAVIGATION;
+
   /** touchpad */
   static final int AINPUT_SOURCE_TOUCHPAD = 0x00100000 | AINPUT_SOURCE_CLASS_POSITION;
+
   /** navigation */
   static final int AINPUT_SOURCE_TOUCH_NAVIGATION = 0x00200000 | AINPUT_SOURCE_CLASS_NONE;
+
   /** joystick */
   static final int AINPUT_SOURCE_JOYSTICK = 0x01000000 | AINPUT_SOURCE_CLASS_JOYSTICK;
+
   /** rotary encoder */
   static final int AINPUT_SOURCE_ROTARY_ENCODER = 0x00400000 | AINPUT_SOURCE_CLASS_NONE;
+
   /** any */
   static final int AINPUT_SOURCE_ANY = 0xffffff00;
 
@@ -669,8 +792,10 @@ public class NativeAndroidInput {
    */
   /** none */
   static final int AINPUT_KEYBOARD_TYPE_NONE = 0;
+
   /** non alphabetic */
   static final int AINPUT_KEYBOARD_TYPE_NON_ALPHABETIC = 1;
+
   /** alphabetic */
   static final int AINPUT_KEYBOARD_TYPE_ALPHABETIC = 2;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/RangingResultBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/RangingResultBuilder.java
new file mode 100644
index 000000000..4bc5d7626
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/RangingResultBuilder.java
@@ -0,0 +1,320 @@
+package org.robolectric.shadows;
+
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.net.MacAddress;
+import android.net.wifi.WifiAnnotations.ChannelWidth;
+import android.net.wifi.aware.PeerHandle;
+import android.net.wifi.rtt.RangingResult;
+import android.net.wifi.rtt.ResponderLocation;
+import android.os.Build;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.ForType;
+import org.robolectric.util.reflector.WithType;
+import org.robolectric.versioning.AndroidVersions.V;
+
+/**
+ * A builder for creating ShadowRangingResults. Status, macAddress, distance [mm] and timestamp are
+ * all mandatory fields. Additional fields can be specified by setters. Use build() to return the
+ * ShadowRangingResult object.
+ *
+ * <p>TODO:org/robolectric/shadows/ShadowLegacyTypeface Remove after V is generally available.
+ */
+public class RangingResultBuilder {
+
+  // Required Values
+  private final int status;
+  private final MacAddress mac;
+  private final int distanceMm;
+  private final long timestampMillis;
+
+  // Optional Values
+  private int distanceStdDevMm = 0;
+  private int rssi = 0;
+  private int numAttemptedMeasurements = 0;
+  private int numSuccessfulMeasurements = 0;
+  private byte[] lci = new byte[0];
+  private byte[] lcr = new byte[0];
+  private ResponderLocation unverifiedResponderLocation = null;
+  private boolean is80211mcMeasurement = true;
+
+  public RangingResultBuilder(int status, MacAddress mac, long timestampMillis, int distanceMm) {
+    this.status = status;
+    this.mac = mac;
+    this.timestampMillis = timestampMillis;
+    this.distanceMm = distanceMm;
+  }
+
+  public RangingResultBuilder setDistanceStandardDeviation(int stddev) {
+    this.distanceStdDevMm = stddev;
+    return this;
+  }
+
+  public RangingResultBuilder setRssi(int rssi) {
+    this.rssi = rssi;
+    return this;
+  }
+
+  public RangingResultBuilder setNumAttemptedMeasurements(int num) {
+    this.numAttemptedMeasurements = num;
+    return this;
+  }
+
+  public RangingResultBuilder setNumSuccessfulMeasurements(int num) {
+    this.numSuccessfulMeasurements = num;
+    return this;
+  }
+
+  public RangingResultBuilder setLci(byte[] lci) {
+    this.lci = lci;
+    return this;
+  }
+
+  public RangingResultBuilder setLcr(byte[] lcr) {
+    this.lcr = lcr;
+    return this;
+  }
+
+  public RangingResultBuilder setUnverifiedResponderLocation(
+      ResponderLocation unverifiedResponderLocation) {
+    this.unverifiedResponderLocation = unverifiedResponderLocation;
+    return this;
+  }
+
+  public RangingResultBuilder setIs80211mcMeasurement(boolean is80211mcMeasurement) {
+    this.is80211mcMeasurement = is80211mcMeasurement;
+    return this;
+  }
+
+  public RangingResult build() {
+    if (RuntimeEnvironment.getApiLevel() >= V.SDK_INT) {
+      Object builder;
+      try {
+        builder =
+            ReflectionHelpers.newInstance(
+                Class.forName("android.net.wifi.rtt.RangingResult$Builder"));
+      } catch (ClassNotFoundException e) {
+        throw new RuntimeException(e);
+      }
+
+      reflector(RangingResultBuilderReflector.class, builder).setStatus(status);
+      reflector(RangingResultBuilderReflector.class, builder).setMacAddress(mac);
+      reflector(RangingResultBuilderReflector.class, builder).setDistanceMm(distanceMm);
+      reflector(RangingResultBuilderReflector.class, builder).setDistanceStdDevMm(distanceStdDevMm);
+      reflector(RangingResultBuilderReflector.class, builder).setRssi(rssi);
+      reflector(RangingResultBuilderReflector.class, builder)
+          .setNumAttemptedMeasurements(numAttemptedMeasurements);
+      reflector(RangingResultBuilderReflector.class, builder)
+          .setNumSuccessfulMeasurements(numSuccessfulMeasurements);
+      reflector(RangingResultBuilderReflector.class, builder).setLci(lci);
+      reflector(RangingResultBuilderReflector.class, builder).setLcr(lcr);
+      reflector(RangingResultBuilderReflector.class, builder)
+          .setUnverifiedResponderLocation(unverifiedResponderLocation);
+      reflector(RangingResultBuilderReflector.class, builder)
+          .setRangingTimestampMillis(timestampMillis);
+      reflector(RangingResultBuilderReflector.class, builder)
+          .set80211mcMeasurement(is80211mcMeasurement);
+      return reflector(RangingResultBuilderReflector.class, builder).build();
+    }
+    if (RuntimeEnvironment.getApiLevel() > Build.VERSION_CODES.R) {
+      return asRangingResultS(
+          status,
+          mac,
+          distanceMm,
+          distanceStdDevMm,
+          rssi,
+          numAttemptedMeasurements,
+          numSuccessfulMeasurements,
+          lci,
+          lcr,
+          unverifiedResponderLocation,
+          timestampMillis,
+          is80211mcMeasurement);
+    }
+
+    if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.Q) {
+      return asRangingResultQ(
+          status,
+          mac,
+          distanceMm,
+          distanceStdDevMm,
+          rssi,
+          numAttemptedMeasurements,
+          numSuccessfulMeasurements,
+          lci,
+          lcr,
+          unverifiedResponderLocation,
+          timestampMillis);
+    }
+
+    return asRangingResultP(
+        status,
+        mac,
+        distanceMm,
+        distanceStdDevMm,
+        rssi,
+        numAttemptedMeasurements,
+        numSuccessfulMeasurements,
+        lci,
+        lcr,
+        timestampMillis);
+  }
+
+  private static RangingResult asRangingResultP(
+      int status,
+      MacAddress mac,
+      int distanceMm,
+      int distanceStdDevMm,
+      int rssi,
+      int numAttemptedMeasurements,
+      int numSuccessfulMeasurements,
+      byte[] lci,
+      byte[] lcr,
+      long timestampMillis) {
+    return ReflectionHelpers.callConstructor(
+        RangingResult.class,
+        ReflectionHelpers.ClassParameter.from(int.class, status),
+        ReflectionHelpers.ClassParameter.from(MacAddress.class, mac),
+        ReflectionHelpers.ClassParameter.from(int.class, distanceMm),
+        ReflectionHelpers.ClassParameter.from(int.class, distanceStdDevMm),
+        ReflectionHelpers.ClassParameter.from(int.class, rssi),
+        ReflectionHelpers.ClassParameter.from(int.class, numAttemptedMeasurements),
+        ReflectionHelpers.ClassParameter.from(int.class, numSuccessfulMeasurements),
+        ReflectionHelpers.ClassParameter.from(byte[].class, lci),
+        ReflectionHelpers.ClassParameter.from(byte[].class, lcr),
+        ReflectionHelpers.ClassParameter.from(long.class, timestampMillis));
+  }
+
+  private static RangingResult asRangingResultQ(
+      int status,
+      MacAddress mac,
+      int distanceMm,
+      int distanceStdDevMm,
+      int rssi,
+      int numAttemptedMeasurements,
+      int numSuccessfulMeasurements,
+      byte[] lci,
+      byte[] lcr,
+      ResponderLocation unverifiedResponderLocation,
+      long timestampMillis) {
+    return ReflectionHelpers.callConstructor(
+        RangingResult.class,
+        ReflectionHelpers.ClassParameter.from(int.class, status),
+        ReflectionHelpers.ClassParameter.from(MacAddress.class, mac),
+        ReflectionHelpers.ClassParameter.from(int.class, distanceMm),
+        ReflectionHelpers.ClassParameter.from(int.class, distanceStdDevMm),
+        ReflectionHelpers.ClassParameter.from(int.class, rssi),
+        ReflectionHelpers.ClassParameter.from(int.class, numAttemptedMeasurements),
+        ReflectionHelpers.ClassParameter.from(int.class, numSuccessfulMeasurements),
+        ReflectionHelpers.ClassParameter.from(byte[].class, lci),
+        ReflectionHelpers.ClassParameter.from(byte[].class, lcr),
+        ReflectionHelpers.ClassParameter.from(ResponderLocation.class, unverifiedResponderLocation),
+        ReflectionHelpers.ClassParameter.from(long.class, timestampMillis));
+  }
+
+  private static RangingResult asRangingResultS(
+      int status,
+      MacAddress mac,
+      int distanceMm,
+      int distanceStdDevMm,
+      int rssi,
+      int numAttemptedMeasurements,
+      int numSuccessfulMeasurements,
+      byte[] lci,
+      byte[] lcr,
+      ResponderLocation unverifiedResponderLocation,
+      long timestamp,
+      boolean is80211mcMeasurement) {
+    return ReflectionHelpers.callConstructor(
+        RangingResult.class,
+        ReflectionHelpers.ClassParameter.from(int.class, status),
+        ReflectionHelpers.ClassParameter.from(MacAddress.class, mac),
+        ReflectionHelpers.ClassParameter.from(int.class, distanceMm),
+        ReflectionHelpers.ClassParameter.from(int.class, distanceStdDevMm),
+        ReflectionHelpers.ClassParameter.from(int.class, rssi),
+        ReflectionHelpers.ClassParameter.from(int.class, numAttemptedMeasurements),
+        ReflectionHelpers.ClassParameter.from(int.class, numSuccessfulMeasurements),
+        ReflectionHelpers.ClassParameter.from(byte[].class, lci),
+        ReflectionHelpers.ClassParameter.from(byte[].class, lcr),
+        ReflectionHelpers.ClassParameter.from(ResponderLocation.class, unverifiedResponderLocation),
+        ReflectionHelpers.ClassParameter.from(long.class, timestamp),
+        ReflectionHelpers.ClassParameter.from(boolean.class, is80211mcMeasurement));
+  }
+
+  @ForType(className = "android.net.wifi.rtt.RangingResult$Builder")
+  interface RangingResultBuilderReflector {
+    @Accessor("mStatus")
+    void setStatus(int status);
+
+    @Accessor("mMac")
+    void setMacAddress(MacAddress macAddress);
+
+    @Accessor("mPeerHandle")
+    void setPeerHandle(PeerHandle peerHandle);
+
+    @Accessor("mDistanceMm")
+    void setDistanceMm(int distanceMm);
+
+    @Accessor("mDistanceStdDevMm")
+    void setDistanceStdDevMm(int distanceStdDevMm);
+
+    @Accessor("mRssi")
+    void setRssi(int rssi);
+
+    @Accessor("mNumAttemptedMeasurements")
+    void setNumAttemptedMeasurements(int numAttemptedMeasurements);
+
+    @Accessor("mNumSuccessfulMeasurements")
+    void setNumSuccessfulMeasurements(int numSuccessfulMeasurements);
+
+    @Accessor("mLci")
+    void setLci(byte[] lci);
+
+    @Accessor("mLcr")
+    void setLcr(byte[] lcr);
+
+    @Accessor("mResponderLocation")
+    void setUnverifiedResponderLocation(ResponderLocation responderLocation);
+
+    @Accessor("mTimestamp")
+    void setRangingTimestampMillis(long timestamp);
+
+    @Accessor("mIs80211mcMeasurement")
+    void set80211mcMeasurement(boolean is80211mcMeasurement);
+
+    @Accessor("mFrequencyMHz")
+    void setMeasurementChannelFrequencyMHz(int frequencyMHz);
+
+    @Accessor("mPacketBw")
+    void setMeasurementBandwidth(@ChannelWidth int measurementBandwidth);
+
+    @Accessor("mIs80211azNtbMeasurement")
+    void set80211azNtbMeasurement(boolean is80211azNtbMeasurement);
+
+    @Accessor("mNtbMinMeasurementTime")
+    void setMinTimeBetweenNtbMeasurementsMicros(long ntbMinMeasurementTime);
+
+    @Accessor("mNtbMaxMeasurementTime")
+    void setMaxTimeBetweenNtbMeasurementsMicros(long ntbMaxMeasurementTime);
+
+    @Accessor("mI2rTxLtfRepetitions")
+    void set80211azInitiatorTxLtfRepetitionsCount(int i2rTxLtfRepetitions);
+
+    @Accessor("mR2iTxLtfRepetitions")
+    void set80211azResponderTxLtfRepetitionsCount(int r2iTxLtfRepetitions);
+
+    @Accessor("mNumTxSpatialStreams")
+    void set80211azNumberOfTxSpatialStreams(int numTxSpatialStreams);
+
+    @Accessor("mNumRxSpatialStreams")
+    void set80211azNumberOfRxSpatialStreams(int numRxSpatialStreams);
+
+    @Accessor("mVendorData")
+    void setVendorData(
+        @WithType("java.util.List<android.net.wifi.OuiKeyedData>") Object vendorData);
+
+    RangingResult build();
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ResourceHelper.java b/shadows/framework/src/main/java/org/robolectric/shadows/ResourceHelper.java
index f031681b0..53c2d6556 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ResourceHelper.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ResourceHelper.java
@@ -21,17 +21,15 @@ import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import org.robolectric.util.Logger;
 
-/**
- * Helper class to provide various conversion method used in handling android resources.
- */
+/** Helper class to provide various conversion method used in handling android resources. */
 public final class ResourceHelper {
 
-  private final static Pattern sFloatPattern = Pattern.compile("(-?[0-9]*(?:\\.[0-9]+)?)(.*)");
-  private final static float[] sFloatOut = new float[1];
+  private static final Pattern sFloatPattern = Pattern.compile("(-?[0-9]*(?:\\.[0-9]+)?)(.*)");
+  private static final float[] sFloatOut = new float[1];
 
-  private final static TypedValue mValue = new TypedValue();
+  private static final TypedValue mValue = new TypedValue();
 
-  private final static Class<?> androidInternalR;
+  private static final Class<?> androidInternalR;
 
   static {
     try {
@@ -51,18 +49,18 @@ public final class ResourceHelper {
   public static int getColor(String value) {
     if (value != null) {
       if (value.startsWith("#") == false) {
-        throw new NumberFormatException(
-            String.format("Color value '%s' must start with #", value));
+        throw new NumberFormatException(String.format("Color value '%s' must start with #", value));
       }
 
       value = value.substring(1);
 
       // make sure it's not longer than 32bit
       if (value.length() > 8) {
-        throw new NumberFormatException(String.format(
-            "Color value '%s' is too long. Format is either" +
-            "#AARRGGBB, #RRGGBB, #RGB, or #ARGB",
-            value));
+        throw new NumberFormatException(
+            String.format(
+                "Color value '%s' is too long. Format is either"
+                    + "#AARRGGBB, #RRGGBB, #RGB, or #ARGB",
+                value));
       }
 
       if (value.length() == 3) { // RGB format
@@ -88,7 +86,7 @@ public final class ResourceHelper {
       // Integer.parseInt will fail to inferFromValue strings like "ff191919", so we use
       // a Long, but cast the result back into an int, since we know that we're only
       // dealing with 32 bit values.
-      return (int)Long.parseLong(value, 16);
+      return (int) Long.parseLong(value, 16);
     }
 
     throw new NumberFormatException();
@@ -99,7 +97,7 @@ public final class ResourceHelper {
    *
    * @param value the color value
    * @return the color as an int. For backwards compatibility, will return a default of ARGB8 if
-   *   value format is unrecognized.
+   *     value format is unrecognized.
    */
   public static int getColorType(String value) {
     if (value != null && value.startsWith("#")) {
@@ -157,8 +155,8 @@ public final class ResourceHelper {
       };
 
   /**
-   * Returns the raw value from the given attribute float-type value string.
-   * This object is only valid until the next call on to {@link ResourceHelper}.
+   * Returns the raw value from the given attribute float-type value string. This object is only
+   * valid until the next call on to {@link ResourceHelper}.
    *
    * @param attribute Attribute name.
    * @param value Attribute value.
@@ -175,14 +173,15 @@ public final class ResourceHelper {
 
   /**
    * Parse a float attribute and return the parsed value into a given TypedValue.
+   *
    * @param attribute the name of the attribute. Can be null if <var>requireUnit</var> is false.
    * @param value the string value of the attribute
    * @param outValue the TypedValue to receive the parsed value
    * @param requireUnit whether the value is expected to contain a unit.
    * @return true if success.
    */
-  public static boolean parseFloatAttribute(String attribute, String value,
-      TypedValue outValue, boolean requireUnit) {
+  public static boolean parseFloatAttribute(
+      String attribute, String value, TypedValue outValue, boolean requireUnit) {
     assert requireUnit == false || attribute != null;
 
     // remove the space before and after
@@ -206,7 +205,7 @@ public final class ResourceHelper {
 
     // check that there's no non ascii characters.
     char[] buf = value.toCharArray();
-    for (int i = 0 ; i < len ; i++) {
+    for (int i = 0; i < len; i++) {
       if (buf[i] > 255) {
         return false;
       }
@@ -256,9 +255,9 @@ public final class ResourceHelper {
             applyUnit(sUnitNames[1], outValue, sFloatOut);
             computeTypedValue(outValue, f, sFloatOut[0]);
 
-            System.out.println(String.format(
-                "Dimension \"%1$s\" in attribute \"%2$s\" is missing unit!",
-                    value, attribute));
+            System.out.println(
+                String.format(
+                    "Dimension \"%1$s\" in attribute \"%2$s\" is missing unit!", value, attribute));
           }
           return true;
         }
@@ -274,23 +273,23 @@ public final class ResourceHelper {
     if (neg) {
       value = -value;
     }
-    long bits = (long)(value*(1<<23)+.5f);
+    long bits = (long) (value * (1 << 23) + .5f);
     int radix;
     int shift;
-    if ((bits&0x7fffff) == 0) {
+    if ((bits & 0x7fffff) == 0) {
       // Always use 23p0 if there is no fraction, just to make
       // things easier to read.
       radix = TypedValue.COMPLEX_RADIX_23p0;
       shift = 23;
-    } else if ((bits&0xffffffffff800000L) == 0) {
+    } else if ((bits & 0xffffffffff800000L) == 0) {
       // Magnitude is zero -- can fit in 0 bits of precision.
       radix = TypedValue.COMPLEX_RADIX_0p23;
       shift = 0;
-    } else if ((bits&0xffffffff80000000L) == 0) {
+    } else if ((bits & 0xffffffff80000000L) == 0) {
       // Magnitude can fit in 8 bits of precision.
       radix = TypedValue.COMPLEX_RADIX_8p15;
       shift = 8;
-    } else if ((bits&0xffffff8000000000L) == 0) {
+    } else if ((bits & 0xffffff8000000000L) == 0) {
       // Magnitude can fit in 16 bits of precision.
       radix = TypedValue.COMPLEX_RADIX_16p7;
       shift = 16;
@@ -299,14 +298,12 @@ public final class ResourceHelper {
       radix = TypedValue.COMPLEX_RADIX_23p0;
       shift = 23;
     }
-    int mantissa = (int)(
-      (bits>>shift) & TypedValue.COMPLEX_MANTISSA_MASK);
+    int mantissa = (int) ((bits >> shift) & TypedValue.COMPLEX_MANTISSA_MASK);
     if (neg) {
       mantissa = (-mantissa) & TypedValue.COMPLEX_MANTISSA_MASK;
     }
     outValue.data |=
-      (radix<<TypedValue.COMPLEX_RADIX_SHIFT)
-      | (mantissa<<TypedValue.COMPLEX_MANTISSA_SHIFT);
+        (radix << TypedValue.COMPLEX_RADIX_SHIFT) | (mantissa << TypedValue.COMPLEX_MANTISSA_SHIFT);
   }
 
   private static boolean parseUnit(String str, TypedValue outValue, float[] outScale) {
@@ -328,4 +325,3 @@ public final class ResourceHelper {
     outScale[0] = unit.scale;
   }
 }
-
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ResourceHelper2.java b/shadows/framework/src/main/java/org/robolectric/shadows/ResourceHelper2.java
index db429734b..d47ef69e9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ResourceHelper2.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ResourceHelper2.java
@@ -19,18 +19,14 @@ package org.robolectric.shadows;
 import android.util.TypedValue;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.res.ResName;
 
-/**
- * Helper class to provide various conversion method used in handling android resources.
- */
+/** Helper class to provide various conversion method used in handling android resources. */
 public final class ResourceHelper2 {
 
-  private final static Pattern sFloatPattern = Pattern.compile("(-?[0-9]+(?:\\.[0-9]+)?)(.*)");
-  private final static float[] sFloatOut = new float[1];
+  private static final Pattern sFloatPattern = Pattern.compile("(-?[0-9]+(?:\\.[0-9]+)?)(.*)");
+  private static final float[] sFloatOut = new float[1];
 
-  private final static TypedValue mValue = new TypedValue();
+  private static final TypedValue mValue = new TypedValue();
 
   // ------- TypedValue stuff
   // This is taken from //device/libs/utils/ResourceTypes.cpp
@@ -49,21 +45,23 @@ public final class ResourceHelper2 {
     }
   }
 
-  private final static UnitEntry[] sUnitNames = new UnitEntry[] {
-    new UnitEntry("px", TypedValue.TYPE_DIMENSION, TypedValue.COMPLEX_UNIT_PX, 1.0f),
-    new UnitEntry("dip", TypedValue.TYPE_DIMENSION, TypedValue.COMPLEX_UNIT_DIP, 1.0f),
-    new UnitEntry("dp", TypedValue.TYPE_DIMENSION, TypedValue.COMPLEX_UNIT_DIP, 1.0f),
-    new UnitEntry("sp", TypedValue.TYPE_DIMENSION, TypedValue.COMPLEX_UNIT_SP, 1.0f),
-    new UnitEntry("pt", TypedValue.TYPE_DIMENSION, TypedValue.COMPLEX_UNIT_PT, 1.0f),
-    new UnitEntry("in", TypedValue.TYPE_DIMENSION, TypedValue.COMPLEX_UNIT_IN, 1.0f),
-    new UnitEntry("mm", TypedValue.TYPE_DIMENSION, TypedValue.COMPLEX_UNIT_MM, 1.0f),
-    new UnitEntry("%", TypedValue.TYPE_FRACTION, TypedValue.COMPLEX_UNIT_FRACTION, 1.0f/100),
-    new UnitEntry("%p", TypedValue.TYPE_FRACTION, TypedValue.COMPLEX_UNIT_FRACTION_PARENT, 1.0f/100),
-  };
+  private static final UnitEntry[] sUnitNames =
+      new UnitEntry[] {
+        new UnitEntry("px", TypedValue.TYPE_DIMENSION, TypedValue.COMPLEX_UNIT_PX, 1.0f),
+        new UnitEntry("dip", TypedValue.TYPE_DIMENSION, TypedValue.COMPLEX_UNIT_DIP, 1.0f),
+        new UnitEntry("dp", TypedValue.TYPE_DIMENSION, TypedValue.COMPLEX_UNIT_DIP, 1.0f),
+        new UnitEntry("sp", TypedValue.TYPE_DIMENSION, TypedValue.COMPLEX_UNIT_SP, 1.0f),
+        new UnitEntry("pt", TypedValue.TYPE_DIMENSION, TypedValue.COMPLEX_UNIT_PT, 1.0f),
+        new UnitEntry("in", TypedValue.TYPE_DIMENSION, TypedValue.COMPLEX_UNIT_IN, 1.0f),
+        new UnitEntry("mm", TypedValue.TYPE_DIMENSION, TypedValue.COMPLEX_UNIT_MM, 1.0f),
+        new UnitEntry("%", TypedValue.TYPE_FRACTION, TypedValue.COMPLEX_UNIT_FRACTION, 1.0f / 100),
+        new UnitEntry(
+            "%p", TypedValue.TYPE_FRACTION, TypedValue.COMPLEX_UNIT_FRACTION_PARENT, 1.0f / 100),
+      };
 
   /**
-   * Returns the raw value from the given attribute float-type value string.
-   * This object is only valid until the next call on to {@link ResourceHelper2}.
+   * Returns the raw value from the given attribute float-type value string. This object is only
+   * valid until the next call on to {@link ResourceHelper2}.
    *
    * @param attribute Attribute name.
    * @param value Attribute value.
@@ -80,15 +78,16 @@ public final class ResourceHelper2 {
 
   /**
    * Parse a float attribute and return the parsed value into a given TypedValue.
+   *
    * @param attribute the name of the attribute. Can be null if <var>requireUnit</var> is false.
    * @param value the string value of the attribute
    * @param outValue the TypedValue to receive the parsed value
    * @param requireUnit whether the value is expected to contain a unit.
    * @return true if success.
    */
-  public static boolean parseFloatAttribute(String attribute, String value,
-      TypedValue outValue, boolean requireUnit) {
-//    assert requireUnit == false || attribute != null;
+  public static boolean parseFloatAttribute(
+      String attribute, String value, TypedValue outValue, boolean requireUnit) {
+    //    assert requireUnit == false || attribute != null;
 
     // remove the space before and after
     value = value.trim();
@@ -100,7 +99,7 @@ public final class ResourceHelper2 {
 
     // check that there's no non ascii characters.
     char[] buf = value.toCharArray();
-    for (int i = 0 ; i < len ; i++) {
+    for (int i = 0; i < len; i++) {
       if (buf[i] > 255) {
         return false;
       }
@@ -150,8 +149,9 @@ public final class ResourceHelper2 {
             applyUnit(sUnitNames[1], outValue, sFloatOut);
             computeTypedValue(outValue, f, sFloatOut[0], "dp");
 
-            System.out.println(String.format(
-                "Dimension \"%1$s\" in attribute \"%2$s\" is missing unit!",
+            System.out.println(
+                String.format(
+                    "Dimension \"%1$s\" in attribute \"%2$s\" is missing unit!",
                     value, attribute == null ? "(unknown)" : attribute));
           }
           return true;
@@ -162,29 +162,30 @@ public final class ResourceHelper2 {
     return false;
   }
 
-  private static void computeTypedValue(TypedValue outValue, float value, float scale, String unit) {
+  private static void computeTypedValue(
+      TypedValue outValue, float value, float scale, String unit) {
     value *= scale;
     boolean neg = value < 0;
     if (neg) {
       value = -value;
     }
-    long bits = (long)(value*(1<<23)+.5f);
+    long bits = (long) (value * (1 << 23) + .5f);
     int radix;
     int shift;
-    if ((bits&0x7fffff) == 0) {
+    if ((bits & 0x7fffff) == 0) {
       // Always use 23p0 if there is no fraction, just to make
       // things easier to read.
       radix = TypedValue.COMPLEX_RADIX_23p0;
       shift = 23;
-    } else if ((bits&0xffffffffff800000L) == 0) {
+    } else if ((bits & 0xffffffffff800000L) == 0) {
       // Magnitude is zero -- can fit in 0 bits of precision.
       radix = TypedValue.COMPLEX_RADIX_0p23;
       shift = 0;
-    } else if ((bits&0xffffffff80000000L) == 0) {
+    } else if ((bits & 0xffffffff80000000L) == 0) {
       // Magnitude can fit in 8 bits of precision.
       radix = TypedValue.COMPLEX_RADIX_8p15;
       shift = 8;
-    } else if ((bits&0xffffff8000000000L) == 0) {
+    } else if ((bits & 0xffffff8000000000L) == 0) {
       // Magnitude can fit in 16 bits of precision.
       radix = TypedValue.COMPLEX_RADIX_16p7;
       shift = 16;
@@ -193,14 +194,12 @@ public final class ResourceHelper2 {
       radix = TypedValue.COMPLEX_RADIX_23p0;
       shift = 23;
     }
-    int mantissa = (int)(
-      (bits>>shift) & TypedValue.COMPLEX_MANTISSA_MASK);
+    int mantissa = (int) ((bits >> shift) & TypedValue.COMPLEX_MANTISSA_MASK);
     if (neg) {
       mantissa = (-mantissa) & TypedValue.COMPLEX_MANTISSA_MASK;
     }
     outValue.data |=
-      (radix<<TypedValue.COMPLEX_RADIX_SHIFT)
-      | (mantissa<<TypedValue.COMPLEX_MANTISSA_SHIFT);
+        (radix << TypedValue.COMPLEX_RADIX_SHIFT) | (mantissa << TypedValue.COMPLEX_MANTISSA_SHIFT);
 
     if ("%".equals(unit)) {
       value = value * 100;
@@ -228,4 +227,3 @@ public final class ResourceHelper2 {
     outScale[0] = unit.scale;
   }
 }
-
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ResourceModeShadowPicker.java b/shadows/framework/src/main/java/org/robolectric/shadows/ResourceModeShadowPicker.java
index 416f34d3d..86ad50c43 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ResourceModeShadowPicker.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ResourceModeShadowPicker.java
@@ -3,7 +3,11 @@ package org.robolectric.shadows;
 import android.os.Build;
 import android.os.Build.VERSION_CODES;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ResourcesMode;
+import org.robolectric.annotation.ResourcesMode.Mode;
+import org.robolectric.config.ConfigurationRegistry;
 import org.robolectric.shadow.api.ShadowPicker;
+import org.robolectric.versioning.AndroidVersions.V;
 
 public class ResourceModeShadowPicker<T> implements ShadowPicker<T> {
 
@@ -11,6 +15,7 @@ public class ResourceModeShadowPicker<T> implements ShadowPicker<T> {
   private Class<? extends T> binary9ShadowClass;
   private Class<? extends T> binary10ShadowClass;
   private Class<? extends T> binary14ShadowClass;
+  private Class<? extends T> nativeShadowClass;
 
   public ResourceModeShadowPicker(
       Class<? extends T> binaryShadowClass, Class<? extends T> binary9ShadowClass) {
@@ -31,9 +36,26 @@ public class ResourceModeShadowPicker<T> implements ShadowPicker<T> {
     this.binary14ShadowClass = binary14ShadowClass;
   }
 
+  public ResourceModeShadowPicker(
+      Class<? extends T> binaryShadowClass,
+      Class<? extends T> binary9ShadowClass,
+      Class<? extends T> binary10ShadowClass,
+      Class<? extends T> binary14ShadowClass,
+      Class<? extends T> nativeShadowClass) {
+    this.binaryShadowClass = binaryShadowClass;
+    this.binary9ShadowClass = binary9ShadowClass;
+    this.binary10ShadowClass = binary10ShadowClass;
+    this.binary14ShadowClass = binary14ShadowClass;
+    this.nativeShadowClass = nativeShadowClass;
+  }
+
   @Override
   public Class<? extends T> pickShadowClass() {
-    if (RuntimeEnvironment.getApiLevel() > VERSION_CODES.TIRAMISU) {
+    if (RuntimeEnvironment.getApiLevel() >= V.SDK_INT
+        && nativeShadowClass != null
+        && ConfigurationRegistry.get(ResourcesMode.Mode.class) == Mode.NATIVE) {
+      return nativeShadowClass;
+    } else if (RuntimeEnvironment.getApiLevel() > VERSION_CODES.TIRAMISU) {
       return binary14ShadowClass;
     } else if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.Q) {
       return binary10ShadowClass;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityNodeInfo.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityNodeInfo.java
index 76fc86ee8..07666610a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityNodeInfo.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityNodeInfo.java
@@ -42,7 +42,7 @@ import org.robolectric.util.reflector.Static;
  * Properties of {@link android.view.accessibility.AccessibilityNodeInfo} that are normally locked
  * may be changed using test APIs.
  *
- * Calls to {@code obtain()} and {@code recycle()} are tracked to help spot bugs.
+ * <p>Calls to {@code obtain()} and {@code recycle()} are tracked to help spot bugs.
  */
 @Implements(AccessibilityNodeInfo.class)
 public class ShadowAccessibilityNodeInfo {
@@ -56,27 +56,26 @@ public class ShadowAccessibilityNodeInfo {
   public static final Parcelable.Creator<AccessibilityNodeInfo> CREATOR =
       new Parcelable.Creator<AccessibilityNodeInfo>() {
 
-    @Override
-    public AccessibilityNodeInfo createFromParcel(Parcel source) {
-      return obtain(orderedInstances.get(source.readInt()).mInfo);
-    }
+        @Override
+        public AccessibilityNodeInfo createFromParcel(Parcel source) {
+          return obtain(orderedInstances.get(source.readInt()).mInfo);
+        }
 
-    @Override
-    public AccessibilityNodeInfo[] newArray(int size) {
-      return new AccessibilityNodeInfo[size];
-    }};
+        @Override
+        public AccessibilityNodeInfo[] newArray(int size) {
+          return new AccessibilityNodeInfo[size];
+        }
+      };
 
   private static int sAllocationCount = 0;
 
   private static final int PASTEABLE_MASK = 0x00000040;
 
-
   private static final int TEXT_SELECTION_SETABLE_MASK = 0x00000100;
 
   /**
-   * Uniquely identifies the origin of the AccessibilityNodeInfo for equality
-   * testing. Two instances that come from the same node info should have the
-   * same ID.
+   * Uniquely identifies the origin of the AccessibilityNodeInfo for equality testing. Two instances
+   * that come from the same node info should have the same ID.
    */
   private long mOriginNodeId;
 
@@ -98,14 +97,13 @@ public class ShadowAccessibilityNodeInfo {
 
   private AccessibilityWindowInfo accessibilityWindowInfo;
 
-  private AccessibilityNodeInfo traversalAfter; //22
+  private AccessibilityNodeInfo traversalAfter; // 22
 
-  private AccessibilityNodeInfo traversalBefore; //22
+  private AccessibilityNodeInfo traversalBefore; // 22
 
   private OnPerformActionListener actionListener;
 
-  @RealObject
-  private AccessibilityNodeInfo realAccessibilityNodeInfo;
+  @RealObject private AccessibilityNodeInfo realAccessibilityNodeInfo;
 
   @ReflectorObject AccessibilityNodeInfoReflector accessibilityNodeInfoReflector;
 
@@ -173,12 +171,10 @@ public class ShadowAccessibilityNodeInfo {
   }
 
   /**
-   * Check for leaked objects that were {@code obtain}ed but never
-   * {@code recycle}d.
+   * Check for leaked objects that were {@code obtain}ed but never {@code recycle}d.
    *
-   * @param printUnrecycledNodesToSystemErr - if true, stack traces of calls
-   *        to {@code obtain} that lack matching calls to {@code recycle} are
-   *        dumped to System.err.
+   * @param printUnrecycledNodesToSystemErr - if true, stack traces of calls to {@code obtain} that
+   *     lack matching calls to {@code recycle} are dumped to System.err.
    * @return {@code true} if there are unrecycled nodes
    */
   public static boolean areThereUnrecycledNodes(boolean printUnrecycledNodesToSystemErr) {
@@ -199,8 +195,8 @@ public class ShadowAccessibilityNodeInfo {
   }
 
   /**
-   * Clear list of obtained instance objects. {@code areThereUnrecycledNodes}
-   * will always return false if called immediately afterwards.
+   * Clear list of obtained instance objects. {@code areThereUnrecycledNodes} will always return
+   * false if called immediately afterwards.
    */
   @Resetter
   public static void resetObtainedInstances() {
@@ -279,7 +275,7 @@ public class ShadowAccessibilityNodeInfo {
 
   @Implementation
   protected boolean refresh() {
-      return refreshReturnValue;
+    return refreshReturnValue;
   }
 
   public void setRefreshReturnValue(boolean refreshReturnValue) {
@@ -362,15 +358,15 @@ public class ShadowAccessibilityNodeInfo {
     if (this.traversalAfter != null) {
       this.traversalAfter.recycle();
     }
-    
+
     this.traversalAfter = obtain(view);
   }
 
   /**
    * Sets the view whose node is visited after this one in accessibility traversal.
    *
-   * This may be useful for configuring traversal order in tests before the corresponding
-   * views have been inflated.
+   * <p>This may be useful for configuring traversal order in tests before the corresponding views
+   * have been inflated.
    *
    * @param info The previous node.
    * @see #getTraversalAfter()
@@ -404,8 +400,8 @@ public class ShadowAccessibilityNodeInfo {
   /**
    * Sets the view before whose node this one should be visited during traversal.
    *
-   * This may be useful for configuring traversal order in tests before the corresponding
-   * views have been inflated.
+   * <p>This may be useful for configuring traversal order in tests before the corresponding views
+   * have been inflated.
    *
    * @param info The view providing the preceding node.
    * @see #getTraversalBefore()
@@ -492,8 +488,7 @@ public class ShadowAccessibilityNodeInfo {
   }
 
   /**
-   * Add a child node to this one. Also initializes the parent field of the
-   * child.
+   * Add a child node to this one. Also initializes the parent field of the child.
    *
    * @param child The node to be added as a child.
    */
@@ -628,8 +623,8 @@ public class ShadowAccessibilityNodeInfo {
   }
 
   /**
-   * Private class to keep different nodes referring to the same view straight
-   * in the mObtainedInstances map.
+   * Private class to keep different nodes referring to the same view straight in the
+   * mObtainedInstances map.
    */
   private static class StrictEqualityNodeWrapper {
     public final AccessibilityNodeInfo mInfo;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityRecord.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityRecord.java
index 8b99abe66..b3bb4fff6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityRecord.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityRecord.java
@@ -12,9 +12,7 @@ import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 
-/**
- * Shadow of {@link android.view.accessibility.AccessibilityRecord}.
- */
+/** Shadow of {@link android.view.accessibility.AccessibilityRecord}. */
 @Implements(AccessibilityRecord.class)
 public class ShadowAccessibilityRecord {
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityService.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityService.java
index 38f0e64d3..68a18be4c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityService.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityService.java
@@ -185,7 +185,7 @@ public class ShadowAccessibilityService extends ShadowService {
   /**
    * Returns a list of gestures that have been dispatched.
    *
-   * Gestures are dispatched by calling {@link AccessibilityService#dispatchGesture}.
+   * <p>Gestures are dispatched by calling {@link AccessibilityService#dispatchGesture}.
    */
   public List<GestureDispatch> getGesturesDispatched() {
     return gesturesDispatched;
@@ -194,7 +194,7 @@ public class ShadowAccessibilityService extends ShadowService {
   /**
    * Sets whether the service is currently able to dispatch gestures.
    *
-   * If {@code false}, {@link AccessibilityService#dispatchGesture} will return {@code false}.
+   * <p>If {@code false}, {@link AccessibilityService#dispatchGesture} will return {@code false}.
    */
   public void setCanDispatchGestures(boolean canDispatchGestures) {
     this.canDispatchGestures = canDispatchGestures;
@@ -203,7 +203,7 @@ public class ShadowAccessibilityService extends ShadowService {
   /**
    * Represents a gesture that has been dispatched through the accessibility service.
    *
-   * Gestures are dispatched by calling {@link AccessibilityService#dispatchGesture}.
+   * <p>Gestures are dispatched by calling {@link AccessibilityService#dispatchGesture}.
    */
   public static final class GestureDispatch {
     private final GestureDescription description;
@@ -222,7 +222,7 @@ public class ShadowAccessibilityService extends ShadowService {
     /**
      * The callback that is to be invoked once the gesture has finished dispatching.
      *
-     * The shadow itself does not invoke this callback. You must manually invoke it to run it.
+     * <p>The shadow itself does not invoke this callback. You must manually invoke it to run it.
      */
     public GestureResultCallback callback() {
       return callback;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityWindowInfo.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityWindowInfo.java
index cf51b33ba..abf053771 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityWindowInfo.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityWindowInfo.java
@@ -103,20 +103,18 @@ public class ShadowAccessibilityWindowInfo {
   }
 
   /**
-   * Clear list of obtained instance objects. {@code areThereUnrecycledWindows} will always
-   * return false if called immediately afterwards.
+   * Clear list of obtained instance objects. {@code areThereUnrecycledWindows} will always return
+   * false if called immediately afterwards.
    */
   public static void resetObtainedInstances() {
     obtainedInstances.clear();
   }
 
   /**
-   * Check for leaked objects that were {@code obtain}ed but never
-   * {@code recycle}d.
+   * Check for leaked objects that were {@code obtain}ed but never {@code recycle}d.
    *
-   * @param printUnrecycledWindowsToSystemErr - if true, stack traces of calls
-   *        to {@code obtain} that lack matching calls to {@code recycle} are
-   *        dumped to System.err.
+   * @param printUnrecycledWindowsToSystemErr - if true, stack traces of calls to {@code obtain}
+   *     that lack matching calls to {@code recycle} are dumped to System.err.
    * @return {@code true} if there are unrecycled windows
    */
   public static boolean areThereUnrecycledWindows(boolean printUnrecycledWindowsToSystemErr) {
@@ -332,13 +330,12 @@ public class ShadowAccessibilityWindowInfo {
     }
 
     children.add(child);
-    ((ShadowAccessibilityWindowInfo) Shadow.extract(child)).parent =
-        mRealAccessibilityWindowInfo;
+    ((ShadowAccessibilityWindowInfo) Shadow.extract(child)).parent = mRealAccessibilityWindowInfo;
   }
 
   /**
-   * Private class to keep different windows referring to the same window straight
-   * in the mObtainedInstances map.
+   * Private class to keep different windows referring to the same window straight in the
+   * mObtainedInstances map.
    */
   private static class StrictEqualityWindowWrapper {
     public final AccessibilityWindowInfo mInfo;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccountManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccountManager.java
index 447b2dc0d..877e21f42 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccountManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccountManager.java
@@ -33,6 +33,7 @@ import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.Scheduler.IdleState;
 
 @Implements(AccountManager.class)
@@ -41,6 +42,7 @@ public class ShadowAccountManager {
   private List<Account> accounts = new ArrayList<>();
   private Map<Account, Map<String, String>> authTokens = new HashMap<>();
   private Map<String, AuthenticatorDescription> authenticators = new LinkedHashMap<>();
+
   /**
    * Maps listeners to a set of account types. If null, the listener should be notified for changes
    * to accounts of any type. Otherwise, the listener is only notified of changes to accounts of the
@@ -54,10 +56,25 @@ public class ShadowAccountManager {
   private Map<Account, Set<String>> packageVisibleAccounts = new HashMap<>();
 
   private List<Bundle> addAccountOptionsList = new ArrayList<>();
-  private Handler mainHandler;
-  private RoboAccountManagerFuture pendingAddFuture;
-  private boolean authenticationErrorOnNextResponse = false;
-  private Intent removeAccountIntent;
+  private static Handler mainHandler;
+  private static RoboAccountManagerFuture pendingAddFuture;
+  private static boolean authenticationErrorOnNextResponse = false;
+  private static Intent removeAccountIntent;
+
+  @Resetter
+  public static void reset() {
+    if (mainHandler != null) {
+      mainHandler.removeCallbacksAndMessages(null);
+      mainHandler = null;
+    }
+
+    if (pendingAddFuture != null) {
+      pendingAddFuture.cancel(true);
+      pendingAddFuture = null;
+    }
+    authenticationErrorOnNextResponse = false;
+    removeAccountIntent = null;
+  }
 
   @Implementation
   protected void __constructor__(Context context, IAccountManager service) {
@@ -218,9 +235,7 @@ public class ShadowAccountManager {
     return false;
   }
 
-  /**
-   * Removes all accounts that have been added.
-   */
+  /** Removes all accounts that have been added. */
   public void removeAllAccounts() {
     passwords.clear();
     userData.clear();
@@ -521,7 +536,11 @@ public class ShadowAccountManager {
     private final Activity activity;
     private final Bundle resultBundle;
 
-    RoboAccountManagerFuture(AccountManagerCallback<Bundle> callback, Handler handler, String accountType, Activity activity) {
+    RoboAccountManagerFuture(
+        AccountManagerCallback<Bundle> callback,
+        Handler handler,
+        String accountType,
+        Activity activity) {
       super(callback, handler);
 
       this.accountType = accountType;
@@ -592,7 +611,8 @@ public class ShadowAccountManager {
   private Map<Account, String> previousNames = new HashMap<Account, String>();
 
   /**
-   * Sets the previous name for an account, which will be returned by {@link AccountManager#getPreviousName(Account)}.
+   * Sets the previous name for an account, which will be returned by {@link
+   * AccountManager#getPreviousName(Account)}.
    *
    * @param account User account.
    * @param previousName Previous account name.
@@ -825,10 +845,12 @@ public class ShadowAccountManager {
     }
 
     @Override
-    public T getResult(long timeout, TimeUnit unit) throws OperationCanceledException, IOException, AuthenticatorException {
+    public T getResult(long timeout, TimeUnit unit)
+        throws OperationCanceledException, IOException, AuthenticatorException {
       return getResult();
     }
 
-    public abstract T doWork() throws OperationCanceledException, IOException, AuthenticatorException;
+    public abstract T doWork()
+        throws OperationCanceledException, IOException, AuthenticatorException;
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivity.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivity.java
index 448705290..3cc6186db 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivity.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivity.java
@@ -76,6 +76,7 @@ import org.robolectric.shadows.ShadowLoadedApk._LoadedApk_;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.WithType;
+import org.robolectric.versioning.AndroidVersions.V;
 
 @SuppressWarnings("NewApi")
 @Implements(value = Activity.class, looseSignatures = true)
@@ -118,12 +119,12 @@ public class ShadowActivity extends ShadowContextThemeWrapper {
   }
 
   public void callAttach(Intent intent) {
-    callAttach(intent, /*activityOptions=*/ null, /*lastNonConfigurationInstances=*/ null);
+    callAttach(intent, /* activityOptions= */ null, /* lastNonConfigurationInstances= */ null);
   }
 
   public void callAttach(Intent intent, @Nullable Bundle activityOptions) {
     callAttach(
-        intent, /*activityOptions=*/ activityOptions, /*lastNonConfigurationInstances=*/ null);
+        intent, /* activityOptions= */ activityOptions, /* lastNonConfigurationInstances= */ null);
   }
 
   public void callAttach(
@@ -164,6 +165,11 @@ public class ShadowActivity extends ShadowContextThemeWrapper {
     ActivityThread activityThread = (ActivityThread) RuntimeEnvironment.getActivityThread();
     Instrumentation instrumentation = activityThread.getInstrumentation();
 
+    if (RuntimeEnvironment.getApiLevel() >= O_MR1) {
+      // ActivityInfo.FLAG_SHOW_WHEN_LOCKED
+      showWhenLocked = (activityInfo.flags & 0x800000) != 0;
+    }
+
     Context activityContext;
     int displayId =
         activityOptions != null
@@ -832,13 +838,20 @@ public class ShadowActivity extends ShadowContextThemeWrapper {
     return streamType;
   }
 
-  @Implementation(minSdk = M)
+  @Implementation(minSdk = M, maxSdk = UPSIDE_DOWN_CAKE)
   protected void requestPermissions(String[] permissions, int requestCode) {
     lastRequestedPermission = new PermissionsRequest(permissions, requestCode);
     reflector(DirectActivityReflector.class, realActivity)
         .requestPermissions(permissions, requestCode);
   }
 
+  @Implementation(minSdk = V.SDK_INT)
+  protected void requestPermissions(String[] permissions, int requestCode, int deviceId) {
+    lastRequestedPermission = new PermissionsRequest(permissions, requestCode, deviceId);
+    reflector(DirectActivityReflector.class, realActivity)
+        .requestPermissions(permissions, requestCode, deviceId);
+  }
+
   /**
    * Starts a lock task.
    *
@@ -981,10 +994,16 @@ public class ShadowActivity extends ShadowContextThemeWrapper {
   public static class PermissionsRequest {
     public final int requestCode;
     public final String[] requestedPermissions;
+    public final int deviceId;
 
     public PermissionsRequest(String[] requestedPermissions, int requestCode) {
+      this(requestedPermissions, requestCode, Context.DEVICE_ID_DEFAULT);
+    }
+
+    public PermissionsRequest(String[] requestedPermissions, int requestCode, int deviceId) {
       this.requestedPermissions = requestedPermissions;
       this.requestCode = requestCode;
+      this.deviceId = deviceId;
     }
   }
 
@@ -1060,5 +1079,7 @@ public class ShadowActivity extends ShadowContextThemeWrapper {
     boolean onCreateOptionsMenu(Menu menu);
 
     void requestPermissions(String[] permissions, int requestCode);
+
+    void requestPermissions(String[] permissions, int requestCode, int deviceId);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManager.java
index 1811dd7f4..1e4788579 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManager.java
@@ -51,6 +51,7 @@ public class ShadowActivityManager {
   private String backgroundPackage;
   private ActivityManager.MemoryInfo memoryInfo;
   private final List<ActivityManager.AppTask> appTasks = new CopyOnWriteArrayList<>();
+  private final List<ActivityManager.RecentTaskInfo> recentTasks = new CopyOnWriteArrayList<>();
   private final List<ActivityManager.RunningTaskInfo> tasks = new CopyOnWriteArrayList<>();
   private final List<ActivityManager.RunningServiceInfo> services = new CopyOnWriteArrayList<>();
   private static final List<ActivityManager.RunningAppProcessInfo> processes =
@@ -118,6 +119,19 @@ public class ShadowActivityManager {
     return appTasks;
   }
 
+  /**
+   * For tests, returns the list of {@link android.app.ActivityManager.RecentTaskInfo} set using
+   * {@link #setAppTasks(List)} with at most {@code maxNum} tasks. Returns empty list if nothing is
+   * set {@code flags} is ignored.
+   *
+   * @see #setAppTasks(List)
+   * @return List of current AppTask.
+   */
+  @Implementation
+  protected List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum, int flags) {
+    return recentTasks.size() > maxNum ? recentTasks.subList(0, maxNum) : recentTasks;
+  }
+
   @Implementation
   protected List<ActivityManager.RunningServiceInfo> getRunningServices(int maxNum) {
     return services;
@@ -196,7 +210,9 @@ public class ShadowActivityManager {
     this.configurationInfo = configurationInfo;
   }
 
-  /** @param tasks List of running tasks. */
+  /**
+   * @param tasks List of running tasks.
+   */
   public void setTasks(List<ActivityManager.RunningTaskInfo> tasks) {
     this.tasks.clear();
     this.tasks.addAll(tasks);
@@ -213,29 +229,50 @@ public class ShadowActivityManager {
     this.appTasks.addAll(appTasks);
   }
 
-  /** @param services List of running services. */
+  /**
+   * Sets the values to be returned by {@link #getRecentTasks()}.
+   *
+   * @see #getRecentTasks()
+   * @param recentTasks List of recent tasks.
+   */
+  public void setRecentTasks(List<ActivityManager.RecentTaskInfo> recentTasks) {
+    this.recentTasks.clear();
+    this.recentTasks.addAll(recentTasks);
+  }
+
+  /**
+   * @param services List of running services.
+   */
   public void setServices(List<ActivityManager.RunningServiceInfo> services) {
     this.services.clear();
     this.services.addAll(services);
   }
 
-  /** @param processes List of running processes. */
+  /**
+   * @param processes List of running processes.
+   */
   public void setProcesses(List<ActivityManager.RunningAppProcessInfo> processes) {
     ShadowActivityManager.processes.clear();
     ShadowActivityManager.processes.addAll(processes);
   }
 
-  /** @return Get the package name of the last background processes killed. */
+  /**
+   * @return Get the package name of the last background processes killed.
+   */
   public String getBackgroundPackage() {
     return backgroundPackage;
   }
 
-  /** @param memoryClass Set the application's memory class. */
+  /**
+   * @param memoryClass Set the application's memory class.
+   */
   public void setMemoryClass(int memoryClass) {
     this.memoryClass = memoryClass;
   }
 
-  /** @param memoryInfo Set the application's memory info. */
+  /**
+   * @param memoryInfo Set the application's memory info.
+   */
   public void setMemoryInfo(ActivityManager.MemoryInfo memoryInfo) {
     this.memoryInfo = memoryInfo;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManagerNative.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManagerNative.java
index 045a771dd..0d461a319 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManagerNative.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManagerNative.java
@@ -12,7 +12,7 @@ public class ShadowActivityManagerNative {
       ReflectionHelpers.createNullProxy(IActivityManager.class);
 
   @Implementation
-  static public IActivityManager getDefault() {
+  public static IActivityManager getDefault() {
     return activityManager;
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAdapterView.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAdapterView.java
index c0226c7f9..abb81c33d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAdapterView.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAdapterView.java
@@ -43,7 +43,10 @@ public class ShadowAdapterView<T extends Adapter> extends ShadowViewGroup {
 
   public int findIndexOfItemContainingText(String targetText) {
     for (int i = 0; i < realAdapterView.getCount(); i++) {
-      View childView = realAdapterView.getAdapter().getView(i, null, new FrameLayout(realAdapterView.getContext()));
+      View childView =
+          realAdapterView
+              .getAdapter()
+              .getView(i, null, new FrameLayout(realAdapterView.getContext()));
       ShadowView shadowView = Shadow.extract(childView);
       String innerText = shadowView.innerText();
       if (innerText.contains(targetText)) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlertController.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlertController.java
index e242eb201..844fbbc91 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlertController.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlertController.java
@@ -28,7 +28,8 @@ public class ShadowAlertController {
   private int iconId;
 
   @Implementation
-  public void setTitle(CharSequence title) throws InvocationTargetException, IllegalAccessException {
+  public void setTitle(CharSequence title)
+      throws InvocationTargetException, IllegalAccessException {
     this.title = title;
     reflector(AlertControllerReflector.class, realAlertController).setTitle(title);
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlertDialog.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlertDialog.java
index 43cecb2bf..bf6854719 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlertDialog.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAlertDialog.java
@@ -15,8 +15,7 @@ import org.robolectric.util.ReflectionHelpers;
 @SuppressWarnings({"UnusedDeclaration"})
 @Implements(AlertDialog.class)
 public class ShadowAlertDialog extends ShadowDialog {
-  @RealObject
-  private AlertDialog realAlertDialog;
+  @RealObject private AlertDialog realAlertDialog;
 
   private CharSequence[] items;
   private DialogInterface.OnClickListener clickListener;
@@ -28,7 +27,8 @@ public class ShadowAlertDialog extends ShadowDialog {
   private static ShadowAlertDialog latestAlertDialog;
 
   /**
-   * @return the most recently created {@code AlertDialog}, or null if none has been created during this test run
+   * @return the most recently created {@code AlertDialog}, or null if none has been created during
+   *     this test run
    */
   public static AlertDialog getLatestAlertDialog() {
     return latestAlertDialog == null ? null : latestAlertDialog.realAlertDialog;
@@ -48,8 +48,9 @@ public class ShadowAlertDialog extends ShadowDialog {
   }
 
   /**
-   * Simulates a click on the {@code Dialog} item indicated by {@code index}. Handles both multi- and single-choice dialogs, tracks which items are currently
-   * checked and calls listeners appropriately.
+   * Simulates a click on the {@code Dialog} item indicated by {@code index}. Handles both multi-
+   * and single-choice dialogs, tracks which items are currently checked and calls listeners
+   * appropriately.
    *
    * @param index the index of the item to click on
    */
@@ -58,7 +59,8 @@ public class ShadowAlertDialog extends ShadowDialog {
     shadowListView.performItemClick(index);
   }
 
-  @Override public CharSequence getTitle() {
+  @Override
+  public CharSequence getTitle() {
     return getShadowAlertController().getTitle();
   }
 
@@ -119,6 +121,5 @@ public class ShadowAlertDialog extends ShadowDialog {
   }
 
   @Implements(AlertDialog.Builder.class)
-  public static class ShadowBuilder {
-  }
+  public static class ShadowBuilder {}
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAndroidBidi.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAndroidBidi.java
index 5971979cd..de0241fb7 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAndroidBidi.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAndroidBidi.java
@@ -13,4 +13,4 @@ public class ShadowAndroidBidi {
     // sorry, arabic, hebrew, syriac, n'ko, imperial aramaic, and old turks!
     return Layout.DIR_LEFT_TO_RIGHT;
   }
-}
\ No newline at end of file
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAnimationBridge.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAnimationBridge.java
index 7884df15d..fecf1db91 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAnimationBridge.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAnimationBridge.java
@@ -6,9 +6,7 @@ import org.robolectric.annotation.internal.DoNotInstrument;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
-/**
- * Bridge between shadows and {@link android.view.animation.Animation}.
- */
+/** Bridge between shadows and {@link android.view.animation.Animation}. */
 @DoNotInstrument
 public class ShadowAnimationBridge {
   private Animation realAnimation;
@@ -18,7 +16,9 @@ public class ShadowAnimationBridge {
   }
 
   public void applyTransformation(float interpolatedTime, Transformation transformation) {
-    ReflectionHelpers.callInstanceMethod(realAnimation, "applyTransformation",
+    ReflectionHelpers.callInstanceMethod(
+        realAnimation,
+        "applyTransformation",
         ClassParameter.from(float.class, interpolatedTime),
         ClassParameter.from(Transformation.class, transformation));
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApkAssets.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApkAssets.java
index 219233da1..72f983f93 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApkAssets.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApkAssets.java
@@ -3,13 +3,17 @@ package org.robolectric.shadows;
 // transliterated from
 // https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/core/jni/android_content_res_ApkAssets.cpp
 
-abstract public class ShadowApkAssets {
+public abstract class ShadowApkAssets {
 
   public static class Picker extends ResourceModeShadowPicker<ShadowApkAssets> {
 
     public Picker() {
-      super(null, ShadowArscApkAssets9.class);
+      super(
+          null,
+          ShadowArscApkAssets9.class,
+          ShadowArscApkAssets9.class,
+          ShadowArscApkAssets9.class,
+          ShadowNativeApkAssets.class);
     }
   }
-
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppIntegrityManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppIntegrityManager.java
index 4d7eaa507..aec31bb36 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppIntegrityManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppIntegrityManager.java
@@ -10,10 +10,7 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
 /** Shadow of {@link AppIntegrityManager} */
-@Implements(
-    value = AppIntegrityManager.class,
-    minSdk = R,
-    isInAndroidSdk = false)
+@Implements(value = AppIntegrityManager.class, minSdk = R, isInAndroidSdk = false)
 public class ShadowAppIntegrityManager {
 
   private Optional<RuleSet> recordedRuleSet;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java
index e2930b799..a02a6728b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java
@@ -111,12 +111,15 @@ public class ShadowAppOpsManager {
   /**
    * Change the operating mode for the given op in the given app package. You must pass in both the
    * uid and name of the application whose mode is being modified; if these do not match, the
-   * modification will not be applied.
+   * modification will still be applied.
    *
    * <p>This method is public for testing {@link #checkOpNoThrow}. If {@link #checkOpNoThrow} is
-   * called afterwards with the {@code op}, {@code ui}, and {@code packageName} provided, it will
+   * called afterwards with the {@code op}, {@code uid}, and {@code packageName} provided, it will
    * return the {@code mode} set here.
    *
+   * <p>The mode set by this method takes precedence over the mode set by {@link #setMode(String,
+   * int, String, int)}. This may not reflect the true implementation.
+   *
    * @param op The operation to modify. One of the OPSTR_* constants.
    * @param uid The user id of the application whose mode will be changed.
    * @param packageName The name of the application package name whose mode will be changed.
@@ -132,8 +135,8 @@ public class ShadowAppOpsManager {
   /**
    * Int version of {@link #setMode(String, int, String, int)}.
    *
-   * <p>This method is public for testing {@link #checkOpNoThrow}. If {@link #checkOpNoThrow} is *
-   * called afterwards with the {@code op}, {@code ui}, and {@code packageName} provided, it will *
+   * <p>This method is public for testing {@link #checkOpNoThrow}. If {@link #checkOpNoThrow} is
+   * called afterwards with the {@code op}, {@code uid}, and {@code packageName} provided, it will
    * return the {@code mode} set here.
    */
   @Implementation
@@ -154,6 +157,51 @@ public class ShadowAppOpsManager {
     }
   }
 
+  /**
+   * Change the operating mode for the given op in the given uid space.
+   *
+   * <p>This method is public for testing {@link #checkOpNoThrow}. If {@link #checkOpNoThrow} is
+   * called afterwards with the {@code op} and {@code uid} provided, and any {@code packageName}, it
+   * will return the {@code mode} set here.
+   *
+   * <p>The mode set by {@link #setMode(String, int, String, int)} takes precedence over the mode
+   * set by this method. This may not reflect the true implementation.
+   *
+   * @param op The operation to modify. One of the OPSTR_* constants.
+   * @param uid The user id of the application whose mode will be changed.
+   */
+  @Implementation(minSdk = P)
+  @HiddenApi
+  @SystemApi
+  @RequiresPermission(android.Manifest.permission.MANAGE_APP_OPS_MODES)
+  protected void setUidMode(String op, int uid, int mode) {
+    setUidMode(AppOpsManager.strOpToOp(op), uid, mode);
+  }
+
+  /**
+   * Int version of {@link #setUidMode(String, int, int)}.
+   *
+   * <p>This method is public for testing {@link #checkOpNoThrow}. If {@link #checkOpNoThrow} is
+   * called afterwards with the {@code op}, {@code ui}, and {@code packageName} provided, it will
+   * return the {@code mode} set here.
+   */
+  @Implementation(minSdk = M)
+  @HiddenApi
+  protected void setUidMode(int op, int uid, int mode) {
+    Integer oldMode = appModeMap.put(Key.create(uid, null, op), mode);
+    if (Objects.equals(oldMode, mode)) {
+      return;
+    }
+
+    for (Map.Entry<OnOpChangedListener, Set<Key>> entry : appOpListeners.entrySet()) {
+      for (Key key : entry.getValue()) {
+        if (op == key.getOpCode()) {
+          entry.getKey().onOpChanged(getOpString(op), null);
+        }
+      }
+    }
+  }
+
   protected String getOpString(int opCode) {
     if (RuntimeEnvironment.getApiLevel() <= TIRAMISU) {
       String[] sOpToString = ReflectionHelpers.getStaticField(AppOpsManager.class, "sOpToString");
@@ -247,10 +295,14 @@ public class ShadowAppOpsManager {
   @Implementation(minSdk = R)
   protected int unsafeCheckOpRawNoThrow(int op, int uid, String packageName) {
     Integer mode = appModeMap.get(Key.create(uid, packageName, op));
-    if (mode == null) {
-      return AppOpsManager.MODE_ALLOWED;
+    if (mode != null) {
+      return mode;
     }
-    return mode;
+    mode = appModeMap.get(Key.create(uid, null, op));
+    if (mode != null) {
+      return mode;
+    }
+    return AppOpsManager.MODE_ALLOWED;
   }
 
   /**
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppTask.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppTask.java
index 0efd3b2e8..4a8215664 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppTask.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppTask.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-
 import android.app.ActivityManager.AppTask;
 import android.app.ActivityManager.RecentTaskInfo;
 import android.app.IAppTask;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplicationPackageManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplicationPackageManager.java
index 2daa2dd4a..be2a9ef27 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplicationPackageManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplicationPackageManager.java
@@ -137,6 +137,9 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   /** {@link Uri} scheme of installed apps. */
   private static final String PACKAGE_SCHEME = "package";
 
+  public static final String PERMISSION_CONTROLLER_PACKAGE_NAME =
+      "org.robolectric.permissioncontroller";
+
   @RealObject private ApplicationPackageManager realObject;
   private final List<String> clearedApplicationUserDataPackages = new ArrayList<>();
   // A map of UserIDs to default browsers.
@@ -1098,11 +1101,19 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
 
   @Implementation
   protected PermissionInfo getPermissionInfo(String name, int flags) throws NameNotFoundException {
+    // Allow extra permissions to override sample platform permissions and package permissions.
     PermissionInfo permissionInfo = extraPermissions.get(name);
     if (permissionInfo != null) {
-      return permissionInfo;
+      return createCopyPermissionInfo(permissionInfo, flags);
+    }
+
+    permissionInfo = AOSP_PLATFORM_PERMISSIONS.get(name);
+    if (permissionInfo != null) {
+      return createCopyPermissionInfo(permissionInfo, flags);
     }
 
+    // Assume that package permissions never attempt to override sample platform permissions.
+    // This is enforced when adding a package.
     synchronized (lock) {
       for (PackageInfo packageInfo : packageInfos.values()) {
         if (packageInfo.permissions != null) {
@@ -1182,9 +1193,10 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
     return Collections.emptyList();
   }
 
+  @HiddenApi
   @Implementation(minSdk = M)
   protected String getPermissionControllerPackageName() {
-    return null;
+    return PERMISSION_CONTROLLER_PACKAGE_NAME;
   }
 
   @Implementation(maxSdk = M)
@@ -1299,24 +1311,33 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   @Implementation
   protected List<PermissionInfo> queryPermissionsByGroup(String group, int flags)
       throws NameNotFoundException {
-    List<PermissionInfo> result = new ArrayList<>();
-    for (PermissionInfo permissionInfo : extraPermissions.values()) {
-      if (Objects.equals(permissionInfo.group, group)) {
-        result.add(permissionInfo);
-      }
-    }
+    Map<String, PermissionInfo> combinedPermissions = new HashMap<>();
+
+    // Assume that package permissions never attempt to override sample platform permissions.
+    // This is enforced when adding a package.
     synchronized (lock) {
       for (PackageInfo packageInfo : packageInfos.values()) {
         if (packageInfo.permissions != null) {
-          for (PermissionInfo permission : packageInfo.permissions) {
-            if (Objects.equals(group, permission.group)) {
-              result.add(createCopyPermissionInfo(permission, flags));
-            }
+          for (PermissionInfo permissionInfo : packageInfo.permissions) {
+            combinedPermissions.put(permissionInfo.name, permissionInfo);
           }
         }
       }
     }
 
+    combinedPermissions.putAll(AOSP_PLATFORM_PERMISSIONS);
+
+    // Allow extra permissions to override sample platform permissions and package permissions.
+    // Note that overrides may remove or change the group of a permission.
+    combinedPermissions.putAll(extraPermissions);
+
+    List<PermissionInfo> result = new ArrayList<>();
+    for (PermissionInfo permissionInfo : combinedPermissions.values()) {
+      if (Objects.equals(permissionInfo.group, group)) {
+        result.add(createCopyPermissionInfo(permissionInfo, flags));
+      }
+    }
+
     if (result.isEmpty()) {
       throw new NameNotFoundException(group);
     }
@@ -1419,8 +1440,15 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   @Implementation
   protected PermissionGroupInfo getPermissionGroupInfo(String name, int flags)
       throws NameNotFoundException {
+    // Allow groups added through the shadow API to override sample platform permission groups.
+    // Assume that manifest permission groups never attempt to override sample platform permission
+    // groups. This is enforced when parsing the test app manifest.
     if (permissionGroups.containsKey(name)) {
-      return new PermissionGroupInfo(permissionGroups.get(name));
+      return createCopyPermissionGroupInfo(permissionGroups.get(name), flags);
+    }
+
+    if (AOSP_PLATFORM_PERMISSION_GROUPS.containsKey(name)) {
+      return createCopyPermissionGroupInfo(AOSP_PLATFORM_PERMISSION_GROUPS.get(name), flags);
     }
 
     throw new NameNotFoundException(name);
@@ -1431,13 +1459,31 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
    */
   @Implementation
   protected List<PermissionGroupInfo> getAllPermissionGroups(int flags) {
-    ArrayList<PermissionGroupInfo> allPermissionGroups = new ArrayList<PermissionGroupInfo>();
+    Map<String, PermissionGroupInfo> result = new HashMap<>();
 
+    for (PermissionGroupInfo permissionGroupInfo : AOSP_PLATFORM_PERMISSION_GROUPS.values()) {
+      result.put(
+          permissionGroupInfo.name, createCopyPermissionGroupInfo(permissionGroupInfo, flags));
+    }
+
+    // Allow groups added through the shadow API to override sample platform permission groups.
+    // Assume that manifest permission groups never attempt to override platform permission groups.
+    // This is enforced when parsing the test app manifest.
     for (PermissionGroupInfo permissionGroupInfo : permissionGroups.values()) {
-      allPermissionGroups.add(new PermissionGroupInfo(permissionGroupInfo));
+      result.put(
+          permissionGroupInfo.name, createCopyPermissionGroupInfo(permissionGroupInfo, flags));
     }
 
-    return allPermissionGroups;
+    return new ArrayList<>(result.values());
+  }
+
+  private static PermissionGroupInfo createCopyPermissionGroupInfo(
+      PermissionGroupInfo src, int flags) {
+    PermissionGroupInfo copy = new PermissionGroupInfo(src);
+    if ((flags & GET_META_DATA) != GET_META_DATA) {
+      copy.metaData = null;
+    }
+    return copy;
   }
 
   @Implementation
@@ -1682,21 +1728,78 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
     }
   }
 
+  /**
+   * This implementation relies on the limited list of platform permissions defined in {@link
+   * ShadowPackageManager#AOSP_PLATFORM_PERMISSIONS} and on permissions added using the
+   * {ShadowPackageManager#addPermission} API (if they have a platform permission prefix). It will
+   * not return an accurate grouping for all platform permissions that can be found on different
+   * AOSP versions.
+   */
   @Implementation(minSdk = S)
-  public void getGroupOfPlatformPermission(
+  protected void getGroupOfPlatformPermission(
       String permissionName, Executor executor, Consumer<String> callback) {
+    if (!AOSP_PLATFORM_PERMISSIONS.containsKey(permissionName)
+        && !permissionName.startsWith(AOSP_PLATFORM_PERMISSION_PREFIX)) {
+      executor.execute(() -> callback.accept(null));
+      return;
+    }
+
     String permissionGroup = null;
     try {
-      PermissionInfo permissionInfo =
-          getPermissionInfo(permissionName, PackageManager.GET_META_DATA);
+      // Use getPermissionInfo to allow for overrides of platform permissions.
+      // Note that overrides may remove or change the group of a permission.
+      PermissionInfo permissionInfo = getPermissionInfo(permissionName, /* flags= */ 0);
       permissionGroup = permissionInfo.group;
     } catch (NameNotFoundException ignored) {
-      // fall through
+      // Ignore permissions that are not found.
     }
     final String finalPermissionGroup = permissionGroup;
     executor.execute(() -> callback.accept(finalPermissionGroup));
   }
 
+  /**
+   * This implementation relies on the limited list of platform permissions defined in {@link
+   * ShadowPackageManager#AOSP_PLATFORM_PERMISSIONS} and on permissions added using the
+   * {ShadowPackageManager#addPermission} API (if they have a platform permission prefix). It will
+   * not return an accurate grouping for all platform permissions that can be found on different
+   * AOSP versions.
+   */
+  @Implementation(minSdk = S)
+  protected void getPlatformPermissionsForGroup(
+      String permissionGroupName, Executor executor, Consumer<List<String>> callback) {
+    List<String> permissions = new ArrayList<>();
+
+    if (!AOSP_PLATFORM_PERMISSION_GROUPS.containsKey(permissionGroupName)
+        && !permissionGroupName.startsWith(AOSP_PLATFORM_PERMISSION_GROUP_PREFIX)) {
+      executor.execute(() -> callback.accept(permissions));
+      return;
+    }
+
+    Set<String> permissionNames = new HashSet<>();
+    permissionNames.addAll(AOSP_PLATFORM_PERMISSIONS.keySet());
+    permissionNames.addAll(extraPermissions.keySet());
+
+    for (String permissionName : permissionNames) {
+      // Only check platform permissions.
+      if (!AOSP_PLATFORM_PERMISSIONS.containsKey(permissionName)
+          && !permissionName.startsWith(AOSP_PLATFORM_PERMISSION_PREFIX)) {
+        continue;
+      }
+      try {
+        // Use getPermissionInfo to allow for overrides of platform permissions.
+        // Note that overrides may remove or change the group of a permission.
+        PermissionInfo permissionInfo = getPermissionInfo(permissionName, /* flags= */ 0);
+        if (permissionGroupName.equals(permissionInfo.group)) {
+          permissions.add(permissionInfo.name);
+        }
+      } catch (NameNotFoundException ignored) {
+        // Ignore permissions that are not found.
+      }
+    }
+
+    executor.execute(() -> callback.accept(permissions));
+  }
+
   /** Behaves as {@link #resolveActivity(Intent, int)} and currently ignores userId. */
   @Implementation
   protected ResolveInfo resolveActivityAsUser(Intent intent, int flags, int userId) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArrayAdapter.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArrayAdapter.java
index cf2ea0e1b..92e0c3ba5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArrayAdapter.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArrayAdapter.java
@@ -17,4 +17,4 @@ public class ShadowArrayAdapter<T> extends ShadowBaseAdapter {
   public int getResourceId() {
     return ReflectionHelpers.getField(realArrayAdapter, "mResource");
   }
-}
\ No newline at end of file
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscApkAssets9.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscApkAssets9.java
index 13e95f947..31c6b26fe 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscApkAssets9.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscApkAssets9.java
@@ -187,7 +187,8 @@ public class ShadowArscApkAssets9 extends ShadowApkAssets {
     //
     // ApkAssets apk_assets = ApkAssets.LoadFromFd(std.move(dup_fd),
     //                                                                     friendly_name_utf8,
-    //                                                                     system, force_shared_lib);
+    //                                                                     system,
+    // force_shared_lib);
     // if (apk_assets == null) {
     //   String error_msg = String.format("Failed to load asset path %s from fd %d",
     //                                              friendly_name_utf8, dup_fd.get());
@@ -246,8 +247,7 @@ public class ShadowArscApkAssets9 extends ShadowApkAssets {
       return 0;
     }
 
-    CppApkAssets apk_assets =
-        Registries.NATIVE_APK_ASSETS_REGISTRY.getNativeObject(ptr);
+    CppApkAssets apk_assets = Registries.NATIVE_APK_ASSETS_REGISTRY.getNativeObject(ptr);
     Asset asset = apk_assets.Open(path_utf8, Asset.AccessMode.ACCESS_RANDOM);
     if (asset == null) {
       throw new FileNotFoundException(path_utf8);
@@ -255,14 +255,16 @@ public class ShadowArscApkAssets9 extends ShadowApkAssets {
 
     // DynamicRefTable is only needed when looking up resource references. Opening an XML file
     // directly from an ApkAssets has no notion of proper resource references.
-    ResXMLTree xml_tree = new ResXMLTree(null); // util.make_unique<ResXMLTree>(nullptr /*dynamicRefTable*/);
+    ResXMLTree xml_tree =
+        new ResXMLTree(null); // util.make_unique<ResXMLTree>(nullptr /*dynamicRefTable*/);
     int err = xml_tree.setTo(asset.getBuffer(true), (int) asset.getLength(), true);
     // asset.reset();
 
     if (err != NO_ERROR) {
       throw new FileNotFoundException("Corrupt XML binary file");
     }
-    return Registries.NATIVE_RES_XML_TREES.register(xml_tree); // reinterpret_cast<jlong>(xml_tree.release());
+    return Registries.NATIVE_RES_XML_TREES.register(
+        xml_tree); // reinterpret_cast<jlong>(xml_tree.release());
   }
 
   // // JNI registration.
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetInputStream.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetInputStream.java
index 82292453d..b5f74bc57 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetInputStream.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetInputStream.java
@@ -15,8 +15,7 @@ import org.robolectric.util.reflector.ForType;
 @Implements(value = AssetInputStream.class, shadowPicker = Picker.class)
 public class ShadowArscAssetInputStream extends ShadowAssetInputStream {
 
-  @RealObject
-  private AssetInputStream realObject;
+  @RealObject private AssetInputStream realObject;
 
   @Override
   InputStream getDelegate() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager.java
index 348ab050d..fd9e5534a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager.java
@@ -77,8 +77,7 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
   private static final int STYLE_CHANGING_CONFIGURATIONS = 4;
   private static final int STYLE_DENSITY = 5;
 
-  @RealObject
-  protected AssetManager realObject;
+  @RealObject protected AssetManager realObject;
 
   private CppAssetManager cppAssetManager;
 
@@ -109,12 +108,11 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
       throw new FileNotFoundException(fileName8);
     }
 
-
     int N = dir.getFileCount();
 
     String[] array = new String[dir.getFileCount()];
 
-    for (int i=0; i<N; i++) {
+    for (int i = 0; i < N; i++) {
       String8 name = dir.getFileName(i);
       array[i] = name.string();
     }
@@ -127,34 +125,77 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
   //   throw new UnsupportedOperationException("implement me");
   // }
 
-  @HiddenApi @Implementation(maxSdk = N_MR1)
-  final public void setConfiguration(int mcc, int mnc, String locale,
-      int orientation, int touchscreen, int density, int keyboard,
-      int keyboardHidden, int navigation, int screenWidth, int screenHeight,
-      int smallestScreenWidthDp, int screenWidthDp, int screenHeightDp,
-      int screenLayout, int uiMode, int sdkVersion) {
-    setConfiguration(mcc, mnc, locale,
-        orientation, touchscreen, density, keyboard,
-        keyboardHidden, navigation, screenWidth, screenHeight,
-        smallestScreenWidthDp, screenWidthDp, screenHeightDp,
-        screenLayout, uiMode, 0, sdkVersion);
+  @HiddenApi
+  @Implementation(maxSdk = N_MR1)
+  public final void setConfiguration(
+      int mcc,
+      int mnc,
+      String locale,
+      int orientation,
+      int touchscreen,
+      int density,
+      int keyboard,
+      int keyboardHidden,
+      int navigation,
+      int screenWidth,
+      int screenHeight,
+      int smallestScreenWidthDp,
+      int screenWidthDp,
+      int screenHeightDp,
+      int screenLayout,
+      int uiMode,
+      int sdkVersion) {
+    setConfiguration(
+        mcc,
+        mnc,
+        locale,
+        orientation,
+        touchscreen,
+        density,
+        keyboard,
+        keyboardHidden,
+        navigation,
+        screenWidth,
+        screenHeight,
+        smallestScreenWidthDp,
+        screenWidthDp,
+        screenHeightDp,
+        screenLayout,
+        uiMode,
+        0,
+        sdkVersion);
   }
 
-  @HiddenApi @Implementation(minSdk = O)
-  public void setConfiguration(int mcc, int mnc, String locale,
-      int orientation, int touchscreen, int density, int keyboard,
-      int keyboardHidden, int navigation, int screenWidth, int screenHeight,
-      int smallestScreenWidthDp, int screenWidthDp, int screenHeightDp,
-      int screenLayout, int uiMode, int colorMode, int sdkVersion) {
+  @HiddenApi
+  @Implementation(minSdk = O)
+  public void setConfiguration(
+      int mcc,
+      int mnc,
+      String locale,
+      int orientation,
+      int touchscreen,
+      int density,
+      int keyboard,
+      int keyboardHidden,
+      int navigation,
+      int screenWidth,
+      int screenHeight,
+      int smallestScreenWidthDp,
+      int screenWidthDp,
+      int screenHeightDp,
+      int screenLayout,
+      int uiMode,
+      int colorMode,
+      int sdkVersion) {
     CppAssetManager am = assetManagerForJavaObject();
     if (am == null) {
       return;
     }
 
     ResTable_config config = new ResTable_config();
-//    memset(&config, 0, sizeof(config));
+    //    memset(&config, 0, sizeof(config));
 
-//    const char* locale8 = locale != NULL ? env->GetStringUTFChars(locale, NULL) : NULL;
+    //    const char* locale8 = locale != NULL ? env->GetStringUTFChars(locale, NULL) : NULL;
 
     // Constants duplicated from Java class android.content.res.Configuration.
     int kScreenLayoutRoundMask = 0x300;
@@ -187,10 +228,11 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
 
     am.setConfiguration(config, locale);
 
-//    if (locale != null) env->ReleaseStringUTFChars(locale, locale8);
+    //    if (locale != null) env->ReleaseStringUTFChars(locale, locale8);
   }
 
-  @HiddenApi @Implementation
+  @HiddenApi
+  @Implementation
   protected static void dumpTheme(long theme, int priority, String tag, String prefix) {
     throw new UnsupportedOperationException("not yet implemented");
   }
@@ -274,11 +316,12 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
 
   @HiddenApi
   @Implementation(maxSdk = M)
-  final protected int addAssetPathNative(String path) {
+  protected final int addAssetPathNative(String path) {
     return addAssetPathNative(path, false);
   }
 
-  @HiddenApi @Implementation(minSdk = VERSION_CODES.N)
+  @HiddenApi
+  @Implementation(minSdk = VERSION_CODES.N)
   protected int addAssetPathNative(String path, boolean appAsLib) {
     if (Strings.isNullOrEmpty(path)) {
       return 0;
@@ -293,7 +336,8 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     return (res) ? cookie.get() : 0;
   }
 
-  @HiddenApi @Implementation
+  @HiddenApi
+  @Implementation
   public int getResourceIdentifier(String name, String defType, String defPackage) {
     if (Strings.isNullOrEmpty(name)) {
       return 0;
@@ -320,8 +364,10 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
       throw new IllegalArgumentException("Empty file name");
     }
 
-    if (mode != AccessMode.ACCESS_UNKNOWN.mode() && mode != AccessMode.ACCESS_RANDOM.mode()
-        && mode != AccessMode.ACCESS_STREAMING.mode() && mode != AccessMode.ACCESS_BUFFER.mode()) {
+    if (mode != AccessMode.ACCESS_UNKNOWN.mode()
+        && mode != AccessMode.ACCESS_RANDOM.mode()
+        && mode != AccessMode.ACCESS_STREAMING.mode()
+        && mode != AccessMode.ACCESS_BUFFER.mode()) {
       throw new IllegalArgumentException("Bad access mode");
     }
 
@@ -336,8 +382,10 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     return Registries.NATIVE_ASSET_REGISTRY.register(a);
   }
 
-  @HiddenApi @Implementation
-  protected ParcelFileDescriptor openAssetFd(String fileName, long[] outOffsets) throws IOException {
+  @HiddenApi
+  @Implementation
+  protected ParcelFileDescriptor openAssetFd(String fileName, long[] outOffsets)
+      throws IOException {
     CppAssetManager am = assetManagerForJavaObject();
 
     ALOGV("openAssetFd in %s", am);
@@ -370,13 +418,16 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
       return -1;
     }
     AccessMode mode = AccessMode.fromInt(accessMode);
-    if (mode != Asset.AccessMode.ACCESS_UNKNOWN && mode != Asset.AccessMode.ACCESS_RANDOM
-        && mode != Asset.AccessMode.ACCESS_STREAMING && mode != Asset.AccessMode.ACCESS_BUFFER) {
+    if (mode != Asset.AccessMode.ACCESS_UNKNOWN
+        && mode != Asset.AccessMode.ACCESS_RANDOM
+        && mode != Asset.AccessMode.ACCESS_STREAMING
+        && mode != Asset.AccessMode.ACCESS_BUFFER) {
       throw new IllegalArgumentException("Bad access mode");
     }
-    Asset a = isTruthy(cookie)
-        ? am.openNonAsset(cookie, fileName8, mode)
-        : am.openNonAsset(fileName8, mode, null);
+    Asset a =
+        isTruthy(cookie)
+            ? am.openNonAsset(cookie, fileName8, mode)
+            : am.openNonAsset(fileName8, mode, null);
     if (a == null) {
       throw new FileNotFoundException(fileName8);
     }
@@ -387,9 +438,10 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     return assetId;
   }
 
-  @HiddenApi @Implementation
-  protected ParcelFileDescriptor openNonAssetFdNative(int cookie,
-      String fileName, long[] outOffsets) throws IOException {
+  @HiddenApi
+  @Implementation
+  protected ParcelFileDescriptor openNonAssetFdNative(
+      int cookie, String fileName, long[] outOffsets) throws IOException {
     CppAssetManager am = assetManagerForJavaObject();
 
     ALOGV("openNonAssetFd in %s (Java object %s)", am, this);
@@ -398,15 +450,16 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
       return null;
     }
 
-    Asset a = isTruthy(cookie)
-        ? am.openNonAsset(cookie, fileName, Asset.AccessMode.ACCESS_RANDOM)
-        : am.openNonAsset(fileName, Asset.AccessMode.ACCESS_RANDOM, null);
+    Asset a =
+        isTruthy(cookie)
+            ? am.openNonAsset(cookie, fileName, Asset.AccessMode.ACCESS_RANDOM)
+            : am.openNonAsset(fileName, Asset.AccessMode.ACCESS_RANDOM, null);
 
     if (a == null) {
       throw new FileNotFoundException(fileName);
     }
 
-    //printf("Created Asset Stream: %p\n", a);
+    // printf("Created Asset Stream: %p\n", a);
 
     return returnParcelFileDescriptor(a, outOffsets);
   }
@@ -440,7 +493,7 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     }
 
     int bLen = bArray.length;
-    if (off < 0 || off >= bLen || len < 0 || len > bLen || (off+len) > bLen) {
+    if (off < 0 || off >= bLen || len < 0 || len > bLen || (off + len) > bLen) {
       throw new IndexOutOfBoundsException();
     }
 
@@ -485,11 +538,12 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     return Registries.NATIVE_ASSET_REGISTRY.getNativeObject(asset);
   }
 
-  @HiddenApi @Implementation
+  @HiddenApi
+  @Implementation
   protected int loadResourceValue(int ident, short density, TypedValue outValue, boolean resolve) {
     if (outValue == null) {
       throw new NullPointerException("outValue");
-      //return 0;
+      // return 0;
     }
     CppAssetManager am = assetManagerForJavaObject();
     if (am == null) {
@@ -502,37 +556,42 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     final Ref<Integer> typeSpecFlags = new Ref<>(null);
     int block = res.getResource(ident, value, false, density, typeSpecFlags, config);
     if (kThrowOnBadId) {
-        if (block == BAD_INDEX) {
-            throw new IllegalStateException("Bad resource!");
-            //return 0;
-        }
+      if (block == BAD_INDEX) {
+        throw new IllegalStateException("Bad resource!");
+        // return 0;
+      }
     }
     final Ref<Integer> ref = new Ref<>(ident);
     if (resolve) {
-        block = res.resolveReference(value, block, ref, typeSpecFlags, config);
-        if (kThrowOnBadId) {
-            if (block == BAD_INDEX) {
-              throw new IllegalStateException("Bad resource!");
-                //return 0;
-            }
+      block = res.resolveReference(value, block, ref, typeSpecFlags, config);
+      if (kThrowOnBadId) {
+        if (block == BAD_INDEX) {
+          throw new IllegalStateException("Bad resource!");
+          // return 0;
         }
+      }
     }
     if (block >= 0) {
-        //return copyValue(env, outValue, &res, value, ref, block, typeSpecFlags, &config);
-      return copyValue(outValue, res, value.get(), ref.get(), block, typeSpecFlags.get(),
-          config.get());
-
+      // return copyValue(env, outValue, &res, value, ref, block, typeSpecFlags, &config);
+      return copyValue(
+          outValue, res, value.get(), ref.get(), block, typeSpecFlags.get(), config.get());
     }
     return block;
-}
+  }
 
-  private static int copyValue(TypedValue outValue, ResTable table,  Res_value value, int ref, int block,
-      int typeSpecFlags) {
+  private static int copyValue(
+      TypedValue outValue, ResTable table, Res_value value, int ref, int block, int typeSpecFlags) {
     return copyValue(outValue, table, value, ref, block, typeSpecFlags, null);
   }
 
-  private static int copyValue(TypedValue outValue, ResTable table,  Res_value value, int ref, int block,
-      int typeSpecFlags, ResTable_config config) {
+  private static int copyValue(
+      TypedValue outValue,
+      ResTable table,
+      Res_value value,
+      int ref,
+      int block,
+      int typeSpecFlags,
+      ResTable_config config) {
     outValue.type = value.dataType;
     outValue.assetCookie = table.getTableCookie(block);
     outValue.data = value.data;
@@ -558,7 +617,7 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
 
       map = new HashMap<>();
       bag_entry[] bag_entries = entryRef.get();
-      for (int i=0; i < entryCount; i++) {
+      for (int i = 0; i < entryCount; i++) {
         bag_entry entry = bag_entries[i];
         ResourceName resourceName = new ResourceName();
         if (res.getResourceName(entry.map.name.ident, true, resourceName)) {
@@ -587,8 +646,9 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
 
   public static String getResourceBagValue(int ident, int bagEntryId, ResTable resTable) {
     TypedValue outValue = new TypedValue();
-    int blockId = ShadowArscAssetManager
-        .loadResourceBagValueInternal(ident, bagEntryId, outValue, true, resTable);
+    int blockId =
+        ShadowArscAssetManager.loadResourceBagValueInternal(
+            ident, bagEntryId, outValue, true, resTable);
     if (outValue.type == TypedValue.TYPE_STRING) {
       return resTable.getTableStringBlock(blockId).stringAt(outValue.data);
     } else {
@@ -596,8 +656,8 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     }
   }
 
-  private static int loadResourceBagValueInternal(int ident, int bagEntryId, TypedValue outValue,
-      boolean resolve, ResTable res) {
+  private static int loadResourceBagValueInternal(
+      int ident, int bagEntryId, TypedValue outValue, boolean resolve, ResTable res) {
     // Now lock down the resource object and start pulling stuff from it.
     res.lock();
 
@@ -608,7 +668,7 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     int entryCount = res.getBagLocked(ident, entryRef, typeSpecFlags);
 
     bag_entry[] bag_entries = entryRef.get();
-    for (int i=0; i < entryCount; i++) {
+    for (int i = 0; i < entryCount; i++) {
       bag_entry entry = bag_entries[i];
       if (bagEntryId == entry.map.name.ident) {
         block = entry.stringBlock;
@@ -649,20 +709,27 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
 
   // /*package*/ static final int STYLE_DENSITY = 5;
 
-/* lowercase hexadecimal notation.  */
-//# define PRIx8		"x"
-//      # define PRIx16		"x"
-//      # define PRIx32		"x"
+  /* lowercase hexadecimal notation.  */
+  // # define PRIx8		"x"
+  //      # define PRIx16		"x"
+  //      # define PRIx32		"x"
 
-  @HiddenApi @Implementation(minSdk = O, maxSdk = O_MR1)
-  protected static void applyStyle(long themeToken, int defStyleAttr, int defStyleRes,
-      long xmlParserToken, int[] inAttrs, int length, long outValuesAddress,
+  @HiddenApi
+  @Implementation(minSdk = O, maxSdk = O_MR1)
+  protected static void applyStyle(
+      long themeToken,
+      int defStyleAttr,
+      int defStyleRes,
+      long xmlParserToken,
+      int[] inAttrs,
+      int length,
+      long outValuesAddress,
       long outIndicesAddress) {
     ShadowVMRuntime shadowVMRuntime = Shadow.extract(VMRuntime.getRuntime());
-    int[] outValues = (int[])shadowVMRuntime.getObjectForAddress(outValuesAddress);
-    int[] outIndices = (int[])shadowVMRuntime.getObjectForAddress(outIndicesAddress);
-    applyStyle(themeToken, defStyleAttr, defStyleRes, xmlParserToken, inAttrs,
-        outValues, outIndices);
+    int[] outValues = (int[]) shadowVMRuntime.getObjectForAddress(outValuesAddress);
+    int[] outIndices = (int[]) shadowVMRuntime.getObjectForAddress(outIndicesAddress);
+    applyStyle(
+        themeToken, defStyleAttr, defStyleRes, xmlParserToken, inAttrs, outValues, outIndices);
   }
 
   @HiddenApi
@@ -676,18 +743,25 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
       int[] outValues,
       int[] outIndices) {
     ResTableTheme theme = Registries.NATIVE_THEME_REGISTRY.getNativeObject(themeToken);
-    ResXMLParser xmlParser = xmlParserToken == 0
-        ? null
-        : Registries.NATIVE_RES_XML_PARSERS.getNativeObject(xmlParserToken);
-    AttributeResolution.ApplyStyle(theme, xmlParser, defStyleAttr, defStyleRes,
-        attrs, attrs.length, outValues, outIndices);
+    ResXMLParser xmlParser =
+        xmlParserToken == 0
+            ? null
+            : Registries.NATIVE_RES_XML_PARSERS.getNativeObject(xmlParserToken);
+    AttributeResolution.ApplyStyle(
+        theme, xmlParser, defStyleAttr, defStyleRes, attrs, attrs.length, outValues, outIndices);
     return true;
   }
 
-  @Implementation @HiddenApi
-  protected static boolean resolveAttrs(long themeToken,
-      int defStyleAttr, int defStyleRes, int[] inValues,
-      int[] attrs, int[] outValues, int[] outIndices) {
+  @Implementation
+  @HiddenApi
+  protected static boolean resolveAttrs(
+      long themeToken,
+      int defStyleAttr,
+      int defStyleRes,
+      int[] inValues,
+      int[] attrs,
+      int[] outValues,
+      int[] outIndices) {
     if (themeToken == 0) {
       throw new NullPointerException("theme token");
     }
@@ -700,14 +774,14 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
 
     final int NI = attrs.length;
     final int NV = outValues.length;
-    if (NV < (NI*STYLE_NUM_ENTRIES)) {
+    if (NV < (NI * STYLE_NUM_ENTRIES)) {
       throw new IndexOutOfBoundsException("out values too small");
     }
 
     int[] src = attrs;
-//    if (src == null) {
-//      return JNI_FALSE;
-//    }
+    //    if (src == null) {
+    //      return JNI_FALSE;
+    //    }
 
     int[] srcValues = inValues;
     final int NSV = srcValues == null ? 0 : inValues.length;
@@ -727,18 +801,16 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
 
     ResTableTheme theme = Registries.NATIVE_THEME_REGISTRY.getNativeObject(themeToken);
 
-    boolean result = AttributeResolution.ResolveAttrs(theme, defStyleAttr, defStyleRes,
-        srcValues, NSV,
-        src, NI,
-        baseDest,
-        indices);
+    boolean result =
+        AttributeResolution.ResolveAttrs(
+            theme, defStyleAttr, defStyleRes, srcValues, NSV, src, NI, baseDest, indices);
 
     if (indices != null) {
-//      env.ReleasePrimitiveArrayCritical(outIndices, indices, 0);
+      //      env.ReleasePrimitiveArrayCritical(outIndices, indices, 0);
     }
-//    env.ReleasePrimitiveArrayCritical(outValues, baseDest, 0);
-//    env.ReleasePrimitiveArrayCritical(inValues, srcValues, 0);
-//    env.ReleasePrimitiveArrayCritical(attrs, src, 0);
+    //    env.ReleasePrimitiveArrayCritical(outValues, baseDest, 0);
+    //    env.ReleasePrimitiveArrayCritical(inValues, srcValues, 0);
+    //    env.ReleasePrimitiveArrayCritical(attrs, src, 0);
 
     return result;
   }
@@ -749,69 +821,71 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
       long xmlParserToken, int[] attrs, int[] outValues, int[] outIndices) {
     if (xmlParserToken == 0) {
       throw new NullPointerException("xmlParserToken");
-//      return JNI_FALSE;
+      //      return JNI_FALSE;
     }
     if (attrs == null) {
       throw new NullPointerException("attrs");
-//      return JNI_FALSE;
+      //      return JNI_FALSE;
     }
     if (outValues == null) {
       throw new NullPointerException("out values");
-//      return JNI_FALSE;
+      //      return JNI_FALSE;
     }
 
     CppAssetManager am = assetManagerForJavaObject();
-//    if (am == null) {
-//      return JNI_FALSE;
-//    }
+    //    if (am == null) {
+    //      return JNI_FALSE;
+    //    }
     ResTable res = am.getResources();
-//    ResXMLParser xmlParser = (ResXMLParser*)xmlParserToken;
+    //    ResXMLParser xmlParser = (ResXMLParser*)xmlParserToken;
     ResXMLParser xmlParser = Registries.NATIVE_RES_XML_PARSERS.getNativeObject(xmlParserToken);
 
-//    const int NI = env.GetArrayLength(attrs);
-//    const int NV = env.GetArrayLength(outValues);
+    //    const int NI = env.GetArrayLength(attrs);
+    //    const int NV = env.GetArrayLength(outValues);
     final int NI = attrs.length;
     final int NV = outValues.length;
-    if (NV < (NI*STYLE_NUM_ENTRIES)) {
+    if (NV < (NI * STYLE_NUM_ENTRIES)) {
       throw new IndexOutOfBoundsException("out values too small");
-//      return JNI_FALSE;
+      //      return JNI_FALSE;
     }
 
-//    int[] src = (int[])env.GetPrimitiveArrayCritical(attrs, 0);
-//    if (src == null) {
-//      return JNI_FALSE;
-//    }
+    //    int[] src = (int[])env.GetPrimitiveArrayCritical(attrs, 0);
+    //    if (src == null) {
+    //      return JNI_FALSE;
+    //    }
     int[] src = attrs;
 
-//    int[] baseDest = (int[])env.GetPrimitiveArrayCritical(outValues, 0);
+    //    int[] baseDest = (int[])env.GetPrimitiveArrayCritical(outValues, 0);
     int[] baseDest = outValues;
     if (baseDest == null) {
-//      env.ReleasePrimitiveArrayCritical(attrs, src, 0);
-//      return JNI_FALSE;
+      //      env.ReleasePrimitiveArrayCritical(attrs, src, 0);
+      //      return JNI_FALSE;
       return false;
     }
 
     int[] indices = null;
     if (outIndices != null) {
       if (outIndices.length > NI) {
-//        indices = (int[])env.GetPrimitiveArrayCritical(outIndices, 0);
+        //        indices = (int[])env.GetPrimitiveArrayCritical(outIndices, 0);
         indices = outIndices;
       }
     }
-    boolean result = AttributeResolution.RetrieveAttributes(res, xmlParser, src, NI, baseDest, indices);
+    boolean result =
+        AttributeResolution.RetrieveAttributes(res, xmlParser, src, NI, baseDest, indices);
 
     if (indices != null) {
-//      indices[0] = indicesIdx;
-//      env.ReleasePrimitiveArrayCritical(outIndices, indices, 0);
+      //      indices[0] = indicesIdx;
+      //      env.ReleasePrimitiveArrayCritical(outIndices, indices, 0);
     }
 
-//    env.ReleasePrimitiveArrayCritical(outValues, baseDest, 0);
-//    env.ReleasePrimitiveArrayCritical(attrs, src, 0);
+    //    env.ReleasePrimitiveArrayCritical(outValues, baseDest, 0);
+    //    env.ReleasePrimitiveArrayCritical(attrs, src, 0);
 
     return result;
   }
 
-  @HiddenApi @Implementation
+  @HiddenApi
+  @Implementation
   protected int getArraySize(int id) {
     CppAssetManager am = assetManagerForJavaObject();
     if (am == null) {
@@ -825,10 +899,10 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     res.unlock();
 
     return bagOff;
-
   }
 
-  @Implementation @HiddenApi
+  @Implementation
+  @HiddenApi
   protected int retrieveArray(int id, int[] outValues) {
     if (outValues == null) {
       throw new NullPointerException("out values");
@@ -845,13 +919,13 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
 
     int NV = outValues.length;
 
-//    int[] baseDest = (int[])env->GetPrimitiveArrayCritical(outValues, 0);
+    //    int[] baseDest = (int[])env->GetPrimitiveArrayCritical(outValues, 0);
     int[] baseDest = outValues;
     int[] dest = baseDest;
-//    if (dest == null) {
-//      throw new NullPointerException(env, "java/lang/OutOfMemoryError", "");
-//      return JNI_FALSE;
-//    }
+    //    if (dest == null) {
+    //      throw new NullPointerException(env, "java/lang/OutOfMemoryError", "");
+    //      return JNI_FALSE;
+    //    }
 
     // Now lock down the resource object and start pulling stuff from it.
     res.lock();
@@ -859,12 +933,13 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     final Ref<bag_entry[]> arrayEnt = new Ref<>(null);
     final Ref<Integer> arrayTypeSetFlags = new Ref<>(0);
     int bagOff = res.getBagLocked(id, arrayEnt, arrayTypeSetFlags);
-//    final ResTable::bag_entry* endArrayEnt = arrayEnt +
-//        (bagOff >= 0 ? bagOff : 0);
+    //    final ResTable::bag_entry* endArrayEnt = arrayEnt +
+    //        (bagOff >= 0 ? bagOff : 0);
 
     int destOffset = 0;
     final Ref<Integer> typeSetFlags = new Ref<>(0);
-    while (destOffset < NV && destOffset < bagOff * STYLE_NUM_ENTRIES /*&& arrayEnt < endArrayEnt*/) {
+    while (destOffset < NV
+        && destOffset < bagOff * STYLE_NUM_ENTRIES /*&& arrayEnt < endArrayEnt*/) {
       bag_entry curArrayEnt = arrayEnt.get()[destOffset / STYLE_NUM_ENTRIES];
 
       block = curArrayEnt.stringBlock;
@@ -875,10 +950,9 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
       final Ref<Integer> resid = new Ref<>(0);
       if (value.dataType != DataType.NULL.code()) {
         // Take care of resolving the found resource to its final value.
-        //printf("Resolving attribute reference\n");
+        // printf("Resolving attribute reference\n");
         final Ref<Res_value> resValueRef = new Ref<>(value);
-        int newBlock = res.resolveReference(resValueRef, block, resid,
-                    typeSetFlags, config);
+        int newBlock = res.resolveReference(resValueRef, block, resid, typeSetFlags, config);
         value = resValueRef.get();
         if (kThrowOnBadId) {
           if (newBlock == BAD_INDEX) {
@@ -893,7 +967,8 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
         value = Res_value.NULL_VALUE;
       }
 
-      //printf("Attribute 0x%08x: final type=0x%x, data=0x%08x\n", curIdent, value.dataType, value.data);
+      // printf("Attribute 0x%08x: final type=0x%x, data=0x%08x\n", curIdent, value.dataType,
+      // value.data);
 
       // Write the final value back to Java.
       dest[destOffset + STYLE_TYPE] = value.dataType;
@@ -902,19 +977,18 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
       dest[destOffset + STYLE_RESOURCE_ID] = resid.get();
       dest[destOffset + STYLE_CHANGING_CONFIGURATIONS] = typeSetFlags.get();
       dest[destOffset + STYLE_DENSITY] = config.get().density;
-//      dest += STYLE_NUM_ENTRIES;
-      destOffset+= STYLE_NUM_ENTRIES;
-//      arrayEnt++;
+      //      dest += STYLE_NUM_ENTRIES;
+      destOffset += STYLE_NUM_ENTRIES;
+      //      arrayEnt++;
     }
 
     destOffset /= STYLE_NUM_ENTRIES;
 
     res.unlock();
 
-//    env->ReleasePrimitiveArrayCritical(outValues, baseDest, 0);
+    //    env->ReleasePrimitiveArrayCritical(outValues, baseDest, 0);
 
     return destOffset;
-
   }
 
   @HiddenApi
@@ -977,7 +1051,8 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
   @Implementation
   protected static int loadThemeAttributeValue(
       long themeHandle, int ident, TypedValue outValue, boolean resolve) {
-    ResTableTheme theme = Preconditions.checkNotNull(Registries.NATIVE_THEME_REGISTRY.getNativeObject(themeHandle));
+    ResTableTheme theme =
+        Preconditions.checkNotNull(Registries.NATIVE_THEME_REGISTRY.getNativeObject(themeHandle));
     ResTable res = theme.getResTable();
 
     final Ref<Res_value> value = new Ref<>(null);
@@ -993,7 +1068,9 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
         }
       }
     }
-    return block >= 0 ? copyValue(outValue, res, value.get(), ref.get(), block, typeSpecFlags.get(), null) : block;
+    return block >= 0
+        ? copyValue(outValue, res, value.get(), ref.get(), block, typeSpecFlags.get(), null)
+        : block;
   }
 
   //  /*package*/@HiddenApi @Implementation public static final @NativeConfig
@@ -1033,7 +1110,7 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     ResXMLTree block = new ResXMLTree(dynamicRefTable);
     int err = block.setTo(a.getBuffer(true), (int) a.getLength(), true);
     a.close();
-//    delete a;
+    //    delete a;
 
     if (err != NO_ERROR) {
       throw new FileNotFoundException("Corrupt XML binary file");
@@ -1062,7 +1139,7 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     final Ref<Res_value> valueRef = new Ref<>(null);
     final bag_entry[] bag = startOfBag.get();
     int strLen = 0;
-    for (int i=0; ((int)i)<N; i++) {
+    for (int i = 0; ((int) i) < N; i++) {
       valueRef.set(bag[i].map.value);
       String str = null;
 
@@ -1074,26 +1151,26 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
         }
       }
       if (valueRef.get().dataType == DataType.STRING.code()) {
-            final ResStringPool pool = res.getTableStringBlock(block);
-            str = pool.stringAt(valueRef.get().data);
-
-            // assume we can skip utf8 vs utf 16 handling
-
-//            final char* str8 = pool.string8At(value.data, &strLen);
-//        if (str8 != NULL) {
-//          str = env.NewStringUTF(str8);
-//        } else {
-//                final char16_t* str16 = pool.stringAt(value.data, &strLen);
-//          str = env.NewString(reinterpret_cast<final jchar*>(str16),
-//              strLen);
-//        }
-//
-//        // If one of our NewString{UTF} calls failed due to memory, an
-//        // exception will be pending.
-//        if (env.ExceptionCheck()) {
-//          res.unlockBag(startOfBag);
-//          return NULL;
-//        }
+        final ResStringPool pool = res.getTableStringBlock(block);
+        str = pool.stringAt(valueRef.get().data);
+
+        // assume we can skip utf8 vs utf 16 handling
+
+        //            final char* str8 = pool.string8At(value.data, &strLen);
+        //        if (str8 != NULL) {
+        //          str = env.NewStringUTF(str8);
+        //        } else {
+        //                final char16_t* str16 = pool.stringAt(value.data, &strLen);
+        //          str = env.NewString(reinterpret_cast<final jchar*>(str16),
+        //              strLen);
+        //        }
+        //
+        //        // If one of our NewString{UTF} calls failed due to memory, an
+        //        // exception will be pending.
+        //        if (env.ExceptionCheck()) {
+        //          res.unlockBag(startOfBag);
+        //          return NULL;
+        //        }
         if (str == null) {
           res.unlockBag(startOfBag);
           return null;
@@ -1127,7 +1204,7 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
 
     final Ref<Res_value> value = new Ref<>(null);
     bag_entry[] bag = startOfBag.get();
-    for (int i = 0, j = 0; i<N; i++) {
+    for (int i = 0, j = 0; i < N; i++) {
       int stringIndex = -1;
       int stringBlock = 0;
       value.set(bag[i].map.value);
@@ -1144,20 +1221,21 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
         }
       }
 
-      //todo: It might be faster to allocate a C array to contain
+      // todo: It might be faster to allocate a C array to contain
       //      the blocknums and indices, put them in there and then
       //      do just one SetIntArrayRegion()
-      //env->SetIntArrayRegion(array, j, 1, &stringBlock);
+      // env->SetIntArrayRegion(array, j, 1, &stringBlock);
       array[j] = stringBlock;
-      //env->SetIntArrayRegion(array, j + 1, 1, &stringIndex);
-      array[j+1] = stringIndex;
+      // env->SetIntArrayRegion(array, j + 1, 1, &stringIndex);
+      array[j + 1] = stringIndex;
       j += 2;
     }
     res.unlockBag(startOfBag);
     return array;
   }
 
-  @HiddenApi @Implementation
+  @HiddenApi
+  @Implementation
   public int[] getArrayIntResource(int arrayResId) {
     CppAssetManager am = assetManagerForJavaObject();
     if (am == null) {
@@ -1165,7 +1243,7 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     }
     final ResTable res = am.getResources();
 
-//    final ResTable::bag_entry* startOfBag;
+    //    final ResTable::bag_entry* startOfBag;
     final Ref<bag_entry[]> startOfBag = new Ref<>(null);
     final int N = res.lockBag(arrayResId, startOfBag);
     if (N < 0) {
@@ -1180,23 +1258,23 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
 
     final Ref<Res_value> valueRef = new Ref<>(null);
     bag_entry[] bag = startOfBag.get();
-    for (int i=0; i<N; i++) {
+    for (int i = 0; i < N; i++) {
       valueRef.set(bag[i].map.value);
 
       // Take care of resolving the found resource to its final value.
       int block = res.resolveReference(valueRef, bag[i].stringBlock, null, null, null);
       if (kThrowOnBadId) {
         if (block == BAD_INDEX) {
-          res.unlockBag(startOfBag); // seems like this is missing from android_util_AssetManager.cpp?
+          res.unlockBag(
+              startOfBag); // seems like this is missing from android_util_AssetManager.cpp?
           throw new IllegalStateException("Bad resource!");
-//          return array;
+          //          return array;
         }
       }
       Res_value value = valueRef.get();
-      if (value.dataType >= DataType.TYPE_FIRST_INT
-          && value.dataType <= DataType.TYPE_LAST_INT) {
+      if (value.dataType >= DataType.TYPE_FIRST_INT && value.dataType <= DataType.TYPE_LAST_INT) {
         int intVal = value.data;
-//        env->SetIntArrayRegion(array, i, 1, &intVal);
+        //        env->SetIntArrayRegion(array, i, 1, &intVal);
         array[i] = intVal;
       }
     }
@@ -1229,8 +1307,9 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
       cppAssetManager.addDefaultAssets(androidFrameworkJarPath);
     }
 
-    ALOGV("Created AssetManager %s for Java object %s\n", cppAssetManager,
-        ShadowArscAssetManager.class);
+    ALOGV(
+        "Created AssetManager %s for Java object %s\n",
+        cppAssetManager, ShadowArscAssetManager.class);
   }
 
   @VisibleForTesting
@@ -1240,25 +1319,26 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     return config.get();
   }
 
-//  private native final void destroy();
-
-//  @HiddenApi
-//  @Implementation
-//  public int addOverlayPathNative(String idmapPath) {
-//    if (Strings.isNullOrEmpty(idmapPath)) {
-//      return 0;
-//    }
-//
-//    CppAssetManager am = assetManagerForJavaObject();
-//    if (am == null) {
-//      return 0;
-//    }
-//    final Ref<Integer> cookie = new Ref<>(null);
-//    boolean res = am.addOverlayPath(new String8(idmapPath), cookie);
-//    return (res) ? cookie.get() : 0;
-//  }
-
-  @HiddenApi @Implementation
+  //  private native final void destroy();
+
+  //  @HiddenApi
+  //  @Implementation
+  //  public int addOverlayPathNative(String idmapPath) {
+  //    if (Strings.isNullOrEmpty(idmapPath)) {
+  //      return 0;
+  //    }
+  //
+  //    CppAssetManager am = assetManagerForJavaObject();
+  //    if (am == null) {
+  //      return 0;
+  //    }
+  //    final Ref<Integer> cookie = new Ref<>(null);
+  //    boolean res = am.addOverlayPath(new String8(idmapPath), cookie);
+  //    return (res) ? cookie.get() : 0;
+  //  }
+
+  @HiddenApi
+  @Implementation
   protected int getStringBlockCount() {
     CppAssetManager am = assetManagerForJavaObject();
     if (am == null) {
@@ -1267,8 +1347,7 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
     return am.getResources().getTableCount();
   }
 
-  
-  synchronized private CppAssetManager assetManagerForJavaObject() {
+  private synchronized CppAssetManager assetManagerForJavaObject() {
     if (cppAssetManager == null) {
       throw new NullPointerException();
     }
@@ -1278,7 +1357,8 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
   static ParcelFileDescriptor returnParcelFileDescriptor(Asset a, long[] outOffsets)
       throws FileNotFoundException {
     final Ref<Long> startOffset = new Ref<Long>(-1L);
-    final Ref<Long> length = new Ref<Long>(-1L);;
+    final Ref<Long> length = new Ref<Long>(-1L);
+    ;
     FileDescriptor fd = a.openFileDescriptor(startOffset, length);
 
     if (fd == null) {
@@ -1329,5 +1409,4 @@ public class ShadowArscAssetManager extends ShadowAssetManager.ArscBase {
   List<AssetPath> getAssetPaths() {
     return assetManagerForJavaObject().getAssetPaths();
   }
-
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscResourcesImpl.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscResourcesImpl.java
index 9012341b8..5ca7947fa 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscResourcesImpl.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscResourcesImpl.java
@@ -42,7 +42,8 @@ public class ShadowArscResourcesImpl extends ShadowResourcesImpl {
     List<LongSparseArray<?>> resettableArrays = new ArrayList<>();
     Field[] allFields = Resources.class.getDeclaredFields();
     for (Field field : allFields) {
-      if (Modifier.isStatic(field.getModifiers()) && field.getType().equals(LongSparseArray.class)) {
+      if (Modifier.isStatic(field.getModifiers())
+          && field.getType().equals(LongSparseArray.class)) {
         field.setAccessible(true);
         try {
           LongSparseArray<?> longSparseArray = (LongSparseArray<?>) field.get(null);
@@ -58,9 +59,9 @@ public class ShadowArscResourcesImpl extends ShadowResourcesImpl {
   }
 
   /**
-   * Since {@link AssetFileDescriptor}s are not yet supported by Robolectric, {@code null} will
-   * be returned if the resource is found. If the resource cannot be found, {@link Resources.NotFoundException} will
-   * be thrown.
+   * Since {@link AssetFileDescriptor}s are not yet supported by Robolectric, {@code null} will be
+   * returned if the resource is found. If the resource cannot be found, {@link
+   * Resources.NotFoundException} will be thrown.
    */
   @Implementation(maxSdk = M)
   public AssetFileDescriptor openRawResourceFd(int id) throws Resources.NotFoundException {
@@ -74,7 +75,8 @@ public class ShadowArscResourcesImpl extends ShadowResourcesImpl {
 
     FileInputStream fis = (FileInputStream) inputStream;
     try {
-      return new AssetFileDescriptor(ParcelFileDescriptor.dup(fis.getFD()), 0, fis.getChannel().size());
+      return new AssetFileDescriptor(
+          ParcelFileDescriptor.dup(fis.getFD()), 0, fis.getChannel().size());
     } catch (IOException e) {
       throw newNotFoundException(id);
     }
@@ -85,7 +87,9 @@ public class ShadowArscResourcesImpl extends ShadowResourcesImpl {
   }
 
   @Implementation(maxSdk = N_MR1)
-  public Drawable loadDrawable(Resources wrapper, TypedValue value, int id, Resources.Theme theme, boolean useCache) throws Resources.NotFoundException {
+  public Drawable loadDrawable(
+      Resources wrapper, TypedValue value, int id, Resources.Theme theme, boolean useCache)
+      throws Resources.NotFoundException {
     Drawable drawable =
         reflector(ResourcesImplReflector.class, realResourcesImpl)
             .loadDrawable(wrapper, value, id, theme, useCache);
@@ -95,7 +99,8 @@ public class ShadowArscResourcesImpl extends ShadowResourcesImpl {
   }
 
   @Implementation(minSdk = O)
-  public Drawable loadDrawable(Resources wrapper,  TypedValue value, int id, int density, Resources.Theme theme) {
+  public Drawable loadDrawable(
+      Resources wrapper, TypedValue value, int id, int density, Resources.Theme theme) {
     Drawable drawable =
         reflector(ResourcesImplReflector.class, realResourcesImpl)
             .loadDrawable(wrapper, value, id, density, theme);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetInputStream.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetInputStream.java
index 77a177a58..95d7fe9ee 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetInputStream.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetInputStream.java
@@ -13,13 +13,15 @@ import org.robolectric.util.ReflectionHelpers;
 @SuppressWarnings("UnusedDeclaration")
 public abstract class ShadowAssetInputStream {
 
-  static AssetInputStream createAssetInputStream(InputStream delegateInputStream, long assetPtr,
-      AssetManager assetManager) {
+  static AssetInputStream createAssetInputStream(
+      InputStream delegateInputStream, long assetPtr, AssetManager assetManager) {
     Asset asset = NATIVE_ASSET_REGISTRY.getNativeObject(assetPtr);
 
-    AssetInputStream ais = ReflectionHelpers.callConstructor(AssetInputStream.class,
-        from(AssetManager.class, assetManager),
-        from(long.class, assetPtr));
+    AssetInputStream ais =
+        ReflectionHelpers.callConstructor(
+            AssetInputStream.class,
+            from(AssetManager.class, assetManager),
+            from(long.class, assetPtr));
 
     ShadowAssetInputStream sais = Shadow.extract(ais);
     return ais;
@@ -35,5 +37,4 @@ public abstract class ShadowAssetInputStream {
   abstract InputStream getDelegate();
 
   abstract boolean isNinePatch();
-
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetManager.java
index 74c9ad1e7..63df48ee7 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetManager.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-
 import android.content.res.ApkAssets;
 import android.content.res.AssetManager;
 import android.util.ArraySet;
@@ -10,6 +9,9 @@ import java.nio.file.Path;
 import java.util.Collection;
 import java.util.List;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ResourcesMode;
+import org.robolectric.annotation.ResourcesMode.Mode;
+import org.robolectric.config.ConfigurationRegistry;
 import org.robolectric.res.android.AssetPath;
 import org.robolectric.res.android.CppAssetManager;
 import org.robolectric.res.android.ResTable;
@@ -19,7 +21,7 @@ import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Static;
 
-abstract public class ShadowAssetManager {
+public abstract class ShadowAssetManager {
 
   public static final Ordering<String> ATTRIBUTE_TYPE_PRECIDENCE =
       Ordering.explicit(
@@ -35,6 +37,9 @@ abstract public class ShadowAssetManager {
           "flags",
           "string");
 
+  private static final Object resourcesModeLock = new Object();
+  private static Mode cachedResourcesMode;
+
   public static class Picker extends ResourceModeShadowPicker<ShadowAssetManager> {
 
     public Picker() {
@@ -42,8 +47,18 @@ abstract public class ShadowAssetManager {
           ShadowArscAssetManager.class,
           ShadowArscAssetManager9.class,
           ShadowArscAssetManager10.class,
-          ShadowArscAssetManager14.class);
+          ShadowArscAssetManager14.class,
+          ShadowNativeAssetManager.class);
+    }
+  }
+
+  static ResourcesMode.Mode resourcesMode() {
+    synchronized (resourcesModeLock) {
+      if (cachedResourcesMode == null) {
+        cachedResourcesMode = ConfigurationRegistry.get(ResourcesMode.Mode.class);
+      }
     }
+    return cachedResourcesMode;
   }
 
   abstract Collection<Path> getAllAssetDirs();
@@ -58,7 +73,7 @@ abstract public class ShadowAssetManager {
      * @deprecated Avoid use.
      */
     @Deprecated
-    synchronized public ResTable getCompileTimeResTable() {
+    public synchronized ResTable getCompileTimeResTable() {
       if (compileTimeResTable == null) {
         CppAssetManager compileTimeCppAssetManager = new CppAssetManager();
         for (AssetPath assetPath : getAssetPaths()) {
@@ -97,16 +112,20 @@ abstract public class ShadowAssetManager {
   @ForType(AssetManager.class)
   interface _AssetManager28_ extends _AssetManager_ {
 
-    @Static @Accessor("sSystemApkAssets")
+    @Static
+    @Accessor("sSystemApkAssets")
     ApkAssets[] getSystemApkAssets();
 
-    @Static @Accessor("sSystemApkAssets")
+    @Static
+    @Accessor("sSystemApkAssets")
     void setSystemApkAssets(ApkAssets[] apkAssets);
 
-    @Static @Accessor("sSystemApkAssetsSet")
+    @Static
+    @Accessor("sSystemApkAssetsSet")
     ArraySet<ApkAssets> getSystemApkAssetsSet();
 
-    @Static @Accessor("sSystemApkAssetsSet")
+    @Static
+    @Accessor("sSystemApkAssetsSet")
     void setSystemApkAssetsSet(ArraySet<ApkAssets> assetsSet);
 
     ApkAssets[] getApkAssets();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java
index 1d7ba935f..be14286ca 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java
@@ -44,6 +44,7 @@ import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.reflector.Constructor;
 import org.robolectric.util.reflector.ForType;
@@ -86,16 +87,16 @@ public class ShadowAudioManager {
   private final HashSet<AudioManager.AudioPlaybackCallback> audioPlaybackCallbacks =
       new HashSet<>();
   private final HashSet<AudioDeviceCallback> audioDeviceCallbacks = new HashSet<>();
-  private int ringerMode = AudioManager.RINGER_MODE_NORMAL;
-  private int mode = AudioManager.MODE_NORMAL;
-  private boolean lockMode = false;
-  private boolean bluetoothA2dpOn;
-  private boolean isBluetoothScoOn;
-  private boolean isSpeakerphoneOn;
-  private boolean isMicrophoneMuted = false;
-  private boolean isMusicActive;
-  private boolean wiredHeadsetOn;
-  private boolean isBluetoothScoAvailableOffCall = false;
+  private static int ringerMode = AudioManager.RINGER_MODE_NORMAL;
+  private static int mode = AudioManager.MODE_NORMAL;
+  private static boolean lockMode = false;
+  private static boolean bluetoothA2dpOn;
+  private static boolean isBluetoothScoOn;
+  private static boolean isSpeakerphoneOn;
+  private static boolean isMicrophoneMuted = false;
+  private static boolean isMusicActive;
+  private static boolean wiredHeadsetOn;
+  private static boolean isBluetoothScoAvailableOffCall = false;
   private final Map<String, String> parameters = new HashMap<>();
   private final Map<Integer, Boolean> streamsMuteState = new HashMap<>();
   private final Map<String, AudioPolicy> registeredAudioPolicies = new HashMap<>();
@@ -109,10 +110,10 @@ public class ShadowAudioManager {
   private List<AudioDeviceInfo> outputDevices = new ArrayList<>();
   private List<AudioDeviceInfo> availableCommunicationDevices = new ArrayList<>();
   private AudioDeviceInfo communicationDevice = null;
-  private boolean lockCommunicationDevice = false;
+  private static boolean lockCommunicationDevice = false;
   private final List<KeyEvent> dispatchedMediaKeyEvents = new ArrayList<>();
-  private boolean isHotwordStreamSupportedForLookbackAudio = false;
-  private boolean isHotwordStreamSupportedWithoutLookbackAudio = false;
+  private static boolean isHotwordStreamSupportedForLookbackAudio = false;
+  private static boolean isHotwordStreamSupportedWithoutLookbackAudio = false;
 
   public ShadowAudioManager() {
     for (int stream : ALL_STREAMS) {
@@ -231,6 +232,23 @@ public class ShadowAudioManager {
     }
   }
 
+  @Resetter
+  public static void reset() {
+    ringerMode = AudioManager.RINGER_MODE_NORMAL;
+    mode = AudioManager.MODE_NORMAL;
+    lockMode = false;
+    bluetoothA2dpOn = false;
+    isBluetoothScoOn = false;
+    isSpeakerphoneOn = false;
+    isMicrophoneMuted = false;
+    isMusicActive = false;
+    wiredHeadsetOn = false;
+    isBluetoothScoAvailableOffCall = false;
+    lockCommunicationDevice = false;
+    isHotwordStreamSupportedForLookbackAudio = false;
+    isHotwordStreamSupportedWithoutLookbackAudio = false;
+  }
+
   private void dispatchModeChangedListeners(int newMode) {
     Object modeDispatcherStub =
         reflector(ModeDispatcherStubReflector.class).newModeDispatcherStub(realAudioManager);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioSystem.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioSystem.java
index c1e78be00..1cfa80680 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioSystem.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioSystem.java
@@ -37,6 +37,7 @@ public class ShadowAudioSystem {
    */
   private static final Table<AudioFormat, Integer, Integer> directPlaybackSupportTable =
       Tables.synchronizedTable(HashBasedTable.create());
+
   /**
    * Table to store pair of {@link OffloadSupportFormat} and {@link
    * AudioAttributes#getVolumeControlStream()} with a value of Offload Playback support. Used with
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioTrack.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioTrack.java
index 52f00724e..d4fb436e0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioTrack.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioTrack.java
@@ -79,9 +79,11 @@ public class ShadowAudioTrack {
   private static final int AUDIOTRACK_ERROR_SETUP_NATIVEINITFAILED = -20;
 
   private static final String TAG = "ShadowAudioTrack";
+
   /** Direct playback support checked from {@link #native_is_direct_output_supported}. */
   private static final Multimap<AudioFormatInfo, AudioAttributesInfo> directSupportedFormats =
       Multimaps.synchronizedMultimap(HashMultimap.create());
+
   /** Non-PCM encodings allowed for creating an AudioTrack instance. */
   private static final Set<Integer> allowedNonPcmEncodings =
       Collections.synchronizedSet(new HashSet<>());
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAutofillManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAutofillManager.java
index 1a14a1d09..93e85e85f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAutofillManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAutofillManager.java
@@ -10,9 +10,7 @@ import android.view.autofill.AutofillManager;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
-/**
- * Robolectric implementation of {@link android.os.AutofillManager}.
- */
+/** Robolectric implementation of {@link android.os.AutofillManager}. */
 @Implements(value = AutofillManager.class, minSdk = O)
 public class ShadowAutofillManager {
   @Nullable private ComponentName autofillServiceComponentName = null;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBackgroundThread.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBackgroundThread.java
index 2273a03e5..5ee36f3e8 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBackgroundThread.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBackgroundThread.java
@@ -29,13 +29,16 @@ public class ShadowBackgroundThread {
   @ForType(BackgroundThread.class)
   interface _BackgroundThread_ {
 
-    @Static @Accessor("sHandler")
+    @Static
+    @Accessor("sHandler")
     void setHandler(Handler o);
 
-    @Static @Accessor("sInstance")
+    @Static
+    @Accessor("sInstance")
     void setInstance(BackgroundThread o);
 
-    @Static @Accessor("sInstance")
+    @Static
+    @Accessor("sInstance")
     BackgroundThread getInstance();
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBaseStringBlock.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBaseStringBlock.java
new file mode 100644
index 000000000..e50c36420
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBaseStringBlock.java
@@ -0,0 +1,16 @@
+package org.robolectric.shadows;
+
+public class ShadowBaseStringBlock {
+
+  public static class Picker extends ResourceModeShadowPicker<ShadowBaseStringBlock> {
+
+    public Picker() {
+      super(
+          ShadowStringBlock.class,
+          ShadowStringBlock.class,
+          ShadowStringBlock.class,
+          ShadowStringBlock.class,
+          ShadowNativeStringBlock.class);
+    }
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBaseXmlBlock.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBaseXmlBlock.java
new file mode 100644
index 000000000..0527154d2
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBaseXmlBlock.java
@@ -0,0 +1,16 @@
+package org.robolectric.shadows;
+
+public abstract class ShadowBaseXmlBlock {
+
+  public static class Picker extends ResourceModeShadowPicker<ShadowBaseXmlBlock> {
+
+    public Picker() {
+      super(
+          ShadowXmlBlock.class,
+          ShadowXmlBlock.class,
+          ShadowXmlBlock.class,
+          ShadowXmlBlock.class,
+          ShadowNativeXmlBlock.class);
+    }
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBinder.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBinder.java
index e62796b32..698146fda 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBinder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBinder.java
@@ -13,8 +13,7 @@ import org.robolectric.annotation.Resetter;
 
 @Implements(Binder.class)
 public class ShadowBinder {
-  @RealObject
-  Binder realObject;
+  @RealObject Binder realObject;
 
   private static Integer callingUid;
   private static Integer callingPid;
@@ -23,26 +22,26 @@ public class ShadowBinder {
   @Implementation
   protected boolean transact(int code, Parcel data, Parcel reply, int flags)
       throws RemoteException {
-   if (data != null) {
-     data.setDataPosition(0);
-   }
-
-   boolean result;
-   try {
-     result = new ShadowBinderBridge(realObject).onTransact(code, data, reply, flags);
-   } catch (RemoteException e) {
-     throw e;
-   } catch (Exception e) {
-     result = true;
-     if (reply != null) {
-       reply.writeException(e);
-     }
-   }
-
-   if (reply != null) {
-     reply.setDataPosition(0);
-   }
-   return result;
+    if (data != null) {
+      data.setDataPosition(0);
+    }
+
+    boolean result;
+    try {
+      result = new ShadowBinderBridge(realObject).onTransact(code, data, reply, flags);
+    } catch (RemoteException e) {
+      throw e;
+    } catch (Exception e) {
+      result = true;
+      if (reply != null) {
+        reply.writeException(e);
+      }
+    }
+
+    if (reply != null) {
+      reply.setDataPosition(0);
+    }
+    return result;
   }
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBinderBridge.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBinderBridge.java
index bbf1b8f17..b5e594c55 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBinderBridge.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBinderBridge.java
@@ -7,9 +7,7 @@ import org.robolectric.annotation.internal.DoNotInstrument;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
-/**
- * Bridge between shadow and {@link android.os.Binder}.
- */
+/** Bridge between shadow and {@link android.os.Binder}. */
 @DoNotInstrument
 public class ShadowBinderBridge {
   private Binder realBinder;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapDrawable.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapDrawable.java
index 3bdf7abf6..a846918b6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapDrawable.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapDrawable.java
@@ -51,8 +51,8 @@ public class ShadowBitmapDrawable extends ShadowDrawable {
   }
 
   /**
-   * Returns the resource id that this {@code BitmapDrawable} was loaded from. This lets
-   * your tests assert that the bitmap is correct without having to actually load the bitmap.
+   * Returns the resource id that this {@code BitmapDrawable} was loaded from. This lets your tests
+   * assert that the bitmap is correct without having to actually load the bitmap.
    *
    * @return resource id from which this {@code BitmapDrawable} was loaded
    * @deprecated use ShadowBitmap#getCreatedFromResId() instead.
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapRegionDecoder.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapRegionDecoder.java
index acef7316d..351e44a84 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapRegionDecoder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapRegionDecoder.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.graphics.BitmapRegionDecoder;
@@ -45,7 +44,8 @@ public class ShadowBitmapRegionDecoder {
     return fillWidthAndHeight(newInstance(), new FileInputStream(pathName));
   }
 
-  private static BitmapRegionDecoder fillWidthAndHeight(BitmapRegionDecoder bitmapRegionDecoder, InputStream is) {
+  private static BitmapRegionDecoder fillWidthAndHeight(
+      BitmapRegionDecoder bitmapRegionDecoder, InputStream is) {
     ShadowBitmapRegionDecoder shadowDecoder = Shadow.extract(bitmapRegionDecoder);
     Point imageSize = ImageUtil.getImageSizeFromStream(is);
     if (imageSize != null) {
@@ -67,7 +67,9 @@ public class ShadowBitmapRegionDecoder {
 
   @Implementation
   protected Bitmap decodeRegion(Rect rect, BitmapFactory.Options options) {
-    return Bitmap.createBitmap(rect.width(), rect.height(),
+    return Bitmap.createBitmap(
+        rect.width(),
+        rect.height(),
         options.inPreferredConfig != null ? options.inPreferredConfig : Bitmap.Config.ARGB_8888);
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBlockGuardOs.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBlockGuardOs.java
index 8cec641ac..fa639b0f3 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBlockGuardOs.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBlockGuardOs.java
@@ -12,4 +12,4 @@ public class ShadowBlockGuardOs {
   protected void close(FileDescriptor fd) throws ErrnoException {
     // ignore
   }
-}
\ No newline at end of file
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothAdapter.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothAdapter.java
index a9cd28b58..21e41ae14 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothAdapter.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothAdapter.java
@@ -25,10 +25,14 @@ import android.bluetooth.IBluetoothGatt;
 import android.bluetooth.le.BluetoothLeAdvertiser;
 import android.bluetooth.le.BluetoothLeScanner;
 import android.content.Context;
+import android.os.Binder;
 import android.os.Build;
 import android.os.Build.VERSION_CODES;
+import android.os.IBinder;
+import android.os.IInterface;
 import android.os.ParcelUuid;
 import android.provider.Settings;
+import android.util.Log;
 import com.google.common.collect.ImmutableList;
 import java.io.IOException;
 import java.time.Duration;
@@ -48,6 +52,7 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.annotation.Resetter;
+import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
@@ -366,21 +371,21 @@ public class ShadowBluetoothAdapter {
    * Needs looseSignatures because in Android T the return value of this method was changed from
    * bool to int.
    */
-  @Implementation
-  protected Object setScanMode(int scanMode) {
-    boolean result = true;
-    if (scanMode != BluetoothAdapter.SCAN_MODE_CONNECTABLE
-        && scanMode != BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE
-        && scanMode != BluetoothAdapter.SCAN_MODE_NONE) {
-      result = false;
-    }
-
+  @Implementation(maxSdk = S_V2)
+  protected boolean setScanMode(int scanMode) {
+    boolean result =
+        scanMode == BluetoothAdapter.SCAN_MODE_CONNECTABLE
+            || scanMode == BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE
+            || scanMode == BluetoothAdapter.SCAN_MODE_NONE;
     this.scanMode = scanMode;
-    if (RuntimeEnvironment.getApiLevel() >= VERSION_CODES.TIRAMISU) {
-      return result ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;
-    } else {
-      return result;
-    }
+    return result;
+  }
+
+  @Implementation(minSdk = TIRAMISU, methodName = "setScanMode")
+  protected int setScanModeFromT(int scanMode) {
+    return setScanMode(scanMode)
+        ? BluetoothStatusCodes.SUCCESS
+        : BluetoothStatusCodes.ERROR_UNKNOWN;
   }
 
   @Implementation(maxSdk = Q)
@@ -610,6 +615,30 @@ public class ShadowBluetoothAdapter {
     }
   }
 
+  @Implementation(minSdk = V.SDK_INT)
+  protected IBinder getProfile(int profile) {
+    if (isEnabled()) {
+      IInterface localProxy = createBinderProfileProxy(profile);
+      if (localProxy != null) {
+        Binder binder = new Binder();
+        binder.attachInterface(localProxy, "profile");
+        return binder;
+      }
+    }
+    return null;
+  }
+
+  private static IInterface createBinderProfileProxy(int profile) {
+    switch (profile) {
+      case BluetoothProfile.HEADSET:
+        return ReflectionHelpers.createNullProxy(android.bluetooth.IBluetoothHeadset.class);
+      case BluetoothProfile.A2DP:
+        return ReflectionHelpers.createNullProxy(android.bluetooth.IBluetoothA2dp.class);
+    }
+    Log.w("ShadowBluetoothAdapter", "getProfile called with unsupported profile " + profile);
+    return null;
+  }
+
   /** Returns the last value of {@link #setIsLeExtendedAdvertisingSupported}, defaulting to true. */
   @Implementation(minSdk = O)
   protected boolean isLeExtendedAdvertisingSupported() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothDevice.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothDevice.java
index ff9cd6eed..5e88df63c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothDevice.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothDevice.java
@@ -1,5 +1,6 @@
 package org.robolectric.shadows;
 
+import static android.bluetooth.BluetoothDevice.BOND_BONDING;
 import static android.bluetooth.BluetoothDevice.BOND_NONE;
 import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 import static android.os.Build.VERSION_CODES.M;
@@ -7,6 +8,7 @@ import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.O_MR1;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.S;
+import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.annotation.IntRange;
@@ -85,6 +87,7 @@ public class ShadowBluetoothDevice {
   private boolean isInSilenceMode = false;
   private boolean isConnected = false;
   @Nullable private BluetoothGattConnectionInterceptor bluetoothGattConnectionInterceptor = null;
+  private Map<Integer, Integer> connectionHandlesByTransportType = new HashMap<>();
 
   /**
    * Implements getService() in the same way the original method does, but ignores any Exceptions
@@ -217,6 +220,15 @@ public class ShadowBluetoothDevice {
     this.bondState = bondState;
   }
 
+  @Implementation
+  protected boolean cancelBondProcess() {
+    if (bondState == BOND_BONDING) {
+      setBondState(BOND_NONE);
+      return true;
+    }
+    return false;
+  }
+
   /**
    * Overrides behavior of {@link BluetoothDevice#getBondState} to return pre-set result.
    *
@@ -444,6 +456,18 @@ public class ShadowBluetoothDevice {
     this.isConnected = isConnected;
   }
 
+  @Implementation(minSdk = UPSIDE_DOWN_CAKE)
+  protected int getConnectionHandle(int transport) {
+    if (!connectionHandlesByTransportType.containsKey(transport)) {
+      return 0;
+    }
+    return connectionHandlesByTransportType.get(transport);
+  }
+
+  public void setConnectionHandle(int transport, int connectionHandle) {
+    connectionHandlesByTransportType.put(transport, connectionHandle);
+  }
+
   @Implementation(minSdk = Q)
   protected boolean isInSilenceMode() {
     checkForBluetoothConnectPermission();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothGatt.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothGatt.java
index fc8b17a04..ba0e34be8 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothGatt.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothGatt.java
@@ -35,7 +35,7 @@ import org.robolectric.util.reflector.ForType;
 public class ShadowBluetoothGatt {
 
   private static final String NULL_CALLBACK_MSG = "BluetoothGattCallback can not be null.";
-  
+
   private BluetoothGattCallback bluetoothGattCallback;
   private int connectionPriority = BluetoothGatt.CONNECTION_PRIORITY_BALANCED;
   private boolean isConnected = false;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothManager.java
index f69bd1d4f..66d464c17 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothManager.java
@@ -43,12 +43,14 @@ public class ShadowBluetoothManager {
   abstract static class BleDevice {
     /** {@link BluetoothProfile#GATT} or {@link BluetoothProfile#GATT_SERVER}. */
     abstract int profile();
+
     /**
      * State of the profile connection. One of {@link BluetoothProfile#STATE_CONNECTED}, {@link
      * BluetoothProfile#STATE_CONNECTING}, {@link BluetoothProfile#STATE_DISCONNECTED} and {@link
      * BluetoothProfile#STATE_DISCONNECTING}.
      */
     abstract int state();
+
     /** The remote bluetooth device. */
     abstract BluetoothDevice device();
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothServerSocket.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothServerSocket.java
index 70166ddad..d3e0cc8af 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothServerSocket.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothServerSocket.java
@@ -34,12 +34,12 @@ public class ShadowBluetoothServerSocket {
   }
 
   /**
-   * May block the current thread and wait until {@link BluetoothDevice} is offered via
-   * {@link #deviceConnected(BluetoothDevice)} method or timeout occurred.
+   * May block the current thread and wait until {@link BluetoothDevice} is offered via {@link
+   * #deviceConnected(BluetoothDevice)} method or timeout occurred.
    *
    * @return socket of the connected bluetooth device
    * @throws IOException if socket has been closed, thread interrupted while waiting or timeout has
-   *         occurred.
+   *     occurred.
    */
   @Implementation
   protected BluetoothSocket accept(int timeout) throws IOException {
@@ -49,8 +49,7 @@ public class ShadowBluetoothServerSocket {
 
     BluetoothSocket socket;
     try {
-      socket = timeout == -1
-              ? sockets.take() : sockets.poll(timeout, TimeUnit.MILLISECONDS);
+      socket = timeout == -1 ? sockets.take() : sockets.poll(timeout, TimeUnit.MILLISECONDS);
     } catch (InterruptedException e) {
       throw new IOException(e);
     }
@@ -67,8 +66,10 @@ public class ShadowBluetoothServerSocket {
     closed = true;
   }
 
-  /** Creates {@link BluetoothSocket} for the given device and makes this socket available
-   * immediately in the {@link #accept(int)} method. */
+  /**
+   * Creates {@link BluetoothSocket} for the given device and makes this socket available
+   * immediately in the {@link #accept(int)} method.
+   */
   public BluetoothSocket deviceConnected(BluetoothDevice device) {
     BluetoothSocket socket = Shadow.newInstanceOf(BluetoothSocket.class);
     ReflectionHelpers.setField(socket, "mDevice", device);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBroadcastPendingResult.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBroadcastPendingResult.java
index a357339a6..6d3bc7a0b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBroadcastPendingResult.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBroadcastPendingResult.java
@@ -18,11 +18,20 @@ import org.robolectric.annotation.RealObject;
 public final class ShadowBroadcastPendingResult {
   @RealObject BroadcastReceiver.PendingResult pendingResult;
 
-  static BroadcastReceiver.PendingResult create(int resultCode, String resultData, Bundle resultExtras, boolean ordered) {
+  static BroadcastReceiver.PendingResult create(
+      int resultCode, String resultData, Bundle resultExtras, boolean ordered) {
     try {
       if (getApiLevel() <= LOLLIPOP_MR1) {
         return BroadcastReceiver.PendingResult.class
-            .getConstructor(int.class, String.class, Bundle.class, int.class, boolean.class, boolean.class, IBinder.class, int.class)
+            .getConstructor(
+                int.class,
+                String.class,
+                Bundle.class,
+                int.class,
+                boolean.class,
+                boolean.class,
+                IBinder.class,
+                int.class)
             .newInstance(
                 resultCode,
                 resultData,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBroadcastReceiver.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBroadcastReceiver.java
index fa62de0f3..05ed662d9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBroadcastReceiver.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBroadcastReceiver.java
@@ -38,7 +38,8 @@ public class ShadowBroadcastReceiver {
   public void onReceive(Context context, Intent intent, AtomicBoolean abort) {
     this.abort = abort;
     onReceive(context, intent);
-    // If the underlying receiver has called goAsync(), we should not finish the pending result yet - they'll do that
+    // If the underlying receiver has called goAsync(), we should not finish the pending result yet
+    // - they'll do that
     // for us.
     if (receiver.getPendingResult() != null) {
       receiver.getPendingResult().finish();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBuild.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBuild.java
index 7b1516152..56a6b925e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBuild.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBuild.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.S;
@@ -185,31 +184,28 @@ public class ShadowBuild {
   }
 
   /**
-   * Sets the value of the {@link Build#SUPPORTED_32_BIT_ABIS} field. Available in Android L+.
+   * Sets the value of the {@link Build#SUPPORTED_32_BIT_ABIS} field.
    *
    * <p>It will be reset for the next test.
    */
-  @TargetApi(LOLLIPOP)
   public static void setSupported32BitAbis(String[] supported32BitAbis) {
     ReflectionHelpers.setStaticField(Build.class, "SUPPORTED_32_BIT_ABIS", supported32BitAbis);
   }
 
   /**
-   * Sets the value of the {@link Build#SUPPORTED_64_BIT_ABIS} field. Available in Android L+.
+   * Sets the value of the {@link Build#SUPPORTED_64_BIT_ABIS} field.
    *
    * <p>It will be reset for the next test.
    */
-  @TargetApi(LOLLIPOP)
   public static void setSupported64BitAbis(String[] supported64BitAbis) {
     ReflectionHelpers.setStaticField(Build.class, "SUPPORTED_64_BIT_ABIS", supported64BitAbis);
   }
 
   /**
-   * Sets the value of the {@link Build#SUPPORTED_ABIS} field. Available in Android L+.
+   * Sets the value of the {@link Build#SUPPORTED_ABIS} field.
    *
    * <p>It will be reset for the next test.
    */
-  @TargetApi(LOLLIPOP)
   public static void setSupportedAbis(String[] supportedAbis) {
     ReflectionHelpers.setStaticField(Build.class, "SUPPORTED_ABIS", supportedAbis);
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraCaptureSessionImpl.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraCaptureSessionImpl.java
index fce200556..2b62126d9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraCaptureSessionImpl.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraCaptureSessionImpl.java
@@ -14,9 +14,7 @@ import org.robolectric.annotation.RealObject;
 import org.robolectric.util.ReflectionHelpers;
 
 /** Shadow class for {@link CameraCaptureSessionImpl} */
-@Implements(
-    value = CameraCaptureSessionImpl.class,
-    isInAndroidSdk = false)
+@Implements(value = CameraCaptureSessionImpl.class, isInAndroidSdk = false)
 public class ShadowCameraCaptureSessionImpl {
   @RealObject private CameraCaptureSessionImpl realObject;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraDeviceImpl.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraDeviceImpl.java
index 1d3a4ed97..382815314 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraDeviceImpl.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraDeviceImpl.java
@@ -33,11 +33,7 @@ import org.robolectric.util.reflector.WithType;
 import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow class for {@link CameraDeviceImpl} */
-@Implements(
-    value = CameraDeviceImpl.class,
-    minSdk = VERSION_CODES.LOLLIPOP,
-    isInAndroidSdk = false,
-    looseSignatures = true)
+@Implements(value = CameraDeviceImpl.class, isInAndroidSdk = false, looseSignatures = true)
 public class ShadowCameraDeviceImpl {
   @RealObject private CameraDeviceImpl realObject;
   private boolean closed = false;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraManager.java
index 123099da4..c35e202b8 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraManager.java
@@ -39,7 +39,7 @@ import org.robolectric.versioning.AndroidVersions.U;
 import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow class for {@link CameraManager} */
-@Implements(value = CameraManager.class, minSdk = VERSION_CODES.LOLLIPOP)
+@Implements(value = CameraManager.class)
 public class ShadowCameraManager {
   @RealObject private CameraManager realObject;
 
@@ -193,7 +193,7 @@ public class ShadowCameraManager {
    * CameraDevice.StateCallback#onDisconnected(CameraDevice)} will not be triggered by {@link
    * CameraManager#openCamera(String, StateCallback, Handler)}.
    */
-  @Implementation(minSdk = VERSION_CODES.LOLLIPOP, maxSdk = VERSION_CODES.N)
+  @Implementation(maxSdk = VERSION_CODES.N)
   protected CameraDevice openCameraDeviceUserAsync(
       String cameraId, CameraDevice.StateCallback callback, Handler handler)
       throws CameraAccessException {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraMetadataNative.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraMetadataNative.java
index f3cde0665..b1a1cc940 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraMetadataNative.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraMetadataNative.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.Q;
 
 import android.hardware.camera2.impl.CameraMetadataNative;
@@ -8,11 +7,7 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
 /** Shadow class for {@link CameraMetadataNative} */
-@Implements(
-    value = CameraMetadataNative.class,
-    minSdk = LOLLIPOP,
-    maxSdk = Q,
-    isInAndroidSdk = false)
+@Implements(value = CameraMetadataNative.class, maxSdk = Q, isInAndroidSdk = false)
 public class ShadowCameraMetadataNative {
   @Implementation(maxSdk = Q)
   protected long nativeAllocate() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCaptureRequestBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCaptureRequestBuilder.java
index 2d6e162a3..a93412e0a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCaptureRequestBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCaptureRequestBuilder.java
@@ -2,7 +2,6 @@ package org.robolectric.shadows;
 
 import android.hardware.camera2.CaptureRequest;
 import android.hardware.camera2.CaptureRequest.Key;
-import android.os.Build.VERSION_CODES;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
@@ -10,14 +9,14 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
 /** Shadow class for {@link CaptureRequest.Builder}. */
-@Implements(value = CaptureRequest.Builder.class, minSdk = VERSION_CODES.LOLLIPOP)
+@Implements(value = CaptureRequest.Builder.class)
 public class ShadowCaptureRequestBuilder {
   private final Map<Key<?>, Object> characteristics = Collections.synchronizedMap(new HashMap<>());
 
   /**
-   * Original implementation would store its state in a local CameraMetadataNative object. Trying
-   * to set these values causes issues while testing as that starts to involve native code. We write
-   * to a managed map stored in the shadow instead.
+   * Original implementation would store its state in a local CameraMetadataNative object. Trying to
+   * set these values causes issues while testing as that starts to involve native code. We write to
+   * a managed map stored in the shadow instead.
    */
   @Implementation
   protected <T> void set(CaptureRequest.Key<T> key, T value) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCaptureResult.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCaptureResult.java
index 239a71989..ce5ac233d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCaptureResult.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCaptureResult.java
@@ -3,7 +3,6 @@ package org.robolectric.shadows;
 import android.annotation.Nullable;
 import android.hardware.camera2.CaptureResult;
 import android.hardware.camera2.CaptureResult.Key;
-import android.os.Build.VERSION_CODES;
 import com.google.common.base.Preconditions;
 import java.util.HashMap;
 import java.util.Map;
@@ -12,7 +11,7 @@ import org.robolectric.annotation.Implements;
 import org.robolectric.util.ReflectionHelpers;
 
 /** Shadow of {@link CaptureResult}. */
-@Implements(value = CaptureResult.class, minSdk = VERSION_CODES.LOLLIPOP)
+@Implements(value = CaptureResult.class)
 public class ShadowCaptureResult {
 
   private final Map<Key<?>, Object> resultsKeyToValue = new HashMap<>();
@@ -22,9 +21,7 @@ public class ShadowCaptureResult {
     return ReflectionHelpers.callConstructor(CaptureResult.class);
   }
 
-  /**
-   * Obtain a property of the CaptureResult.
-   */
+  /** Obtain a property of the CaptureResult. */
   @Implementation
   @Nullable
   @SuppressWarnings("unchecked")
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCardEmulation.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCardEmulation.java
index 3f6989a14..7f919e95a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCardEmulation.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCardEmulation.java
@@ -8,7 +8,6 @@ import android.content.ComponentName;
 import android.content.Context;
 import android.nfc.INfcCardEmulation;
 import android.nfc.cardemulation.CardEmulation;
-import android.os.Build;
 import android.provider.Settings;
 import java.util.HashMap;
 import java.util.Map;
@@ -35,13 +34,13 @@ public class ShadowCardEmulation {
     return service.equals(defaultServiceForCategoryMap.get(category));
   }
 
-  @Implementation(minSdk = Build.VERSION_CODES.LOLLIPOP)
+  @Implementation
   public boolean setPreferredService(Activity activity, ComponentName service) {
     preferredService = service;
     return true;
   }
 
-  @Implementation(minSdk = Build.VERSION_CODES.LOLLIPOP)
+  @Implementation
   public boolean unsetPreferredService(Activity activity) {
     preferredService = null;
     return true;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCarrierConfigManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCarrierConfigManager.java
index 9370a7ed2..901097b93 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCarrierConfigManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCarrierConfigManager.java
@@ -3,10 +3,12 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.Q;
 
+import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.os.PersistableBundle;
 import android.telephony.CarrierConfigManager;
-import com.google.common.base.Preconditions;
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.ImmutableSet;
 import java.util.HashMap;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
@@ -20,6 +22,14 @@ public class ShadowCarrierConfigManager {
   private final HashMap<Integer, PersistableBundle> overrideBundles = new HashMap<>();
   private boolean readPhoneStatePermission = true;
 
+  @VisibleForTesting static final PersistableBundle BASE;
+
+  static {
+    BASE = new PersistableBundle();
+    BASE.putString(CarrierConfigManager.KEY_CARRIER_CONFIG_VERSION_STRING, "version");
+    BASE.putBoolean(CarrierConfigManager.KEY_CARRIER_CONFIG_APPLIED_BOOL, false);
+  }
+
   /**
    * Returns {@link android.os.PersistableBundle} previously set by {@link #overrideConfig} or
    * {@link #setConfigForSubId(int, PersistableBundle)}, or default values for an invalid {@code
@@ -29,25 +39,51 @@ public class ShadowCarrierConfigManager {
   public PersistableBundle getConfigForSubId(int subId) {
     checkReadPhoneStatePermission();
     if (overrideBundles.containsKey(subId) && overrideBundles.get(subId) != null) {
-      return overrideBundles.get(subId);
+      return overrideBundles.get(subId) != null
+          ? new PersistableBundle(overrideBundles.get(subId))
+          : null;
     }
     if (bundles.containsKey(subId)) {
-      return bundles.get(subId);
+      return bundles.get(subId) != null ? new PersistableBundle(bundles.get(subId)) : null;
     }
     return new PersistableBundle();
   }
 
   /**
-   * @see #getConfigForSubId(int). Currently the 'keys' parameter is ignored.
+   * Returns {@link android.os.PersistableBundle} containing the specified keys for a particular
+   * subscription. {@link #setConfigForSubId(int, PersistableBundle)}, or default values for an
+   * invalid {@code subId}.
    */
   @Implementation(minSdk = U.SDK_INT)
-  protected PersistableBundle getConfigForSubId(int subId, String... keys) {
-    // TODO: consider implementing the logic in telephony service
-    // CarrierConfigLoader#getConfigSubsetForSubIdWithFeature
-    Preconditions.checkNotNull(keys);
-    Preconditions.checkArgument(
-        keys.length == 0, "filtering by keys is not currently supported in Robolectric");
-    return getConfigForSubId(subId);
+  @NonNull
+  public PersistableBundle getConfigForSubId(int subId, @NonNull String... keys) {
+    checkReadPhoneStatePermission();
+
+    PersistableBundle bundle = getConfigForSubId(subId);
+    PersistableBundle result = new PersistableBundle(BASE);
+
+    if (bundle == null) {
+      return result;
+    }
+
+    result.putAll(bundle);
+
+    if (keys.length == 0) {
+      return result;
+    }
+
+    ImmutableSet<String> requiredKeys =
+        ImmutableSet.<String>builder()
+            .addAll(BASE.keySet())
+            .addAll(ImmutableSet.copyOf(keys))
+            .build();
+    for (String key : bundle.keySet()) {
+      if (!requiredKeys.contains(key)) {
+        result.remove(key);
+      }
+    }
+
+    return result;
   }
 
   public void setReadPhoneStatePermission(boolean readPhoneStatePermission) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowChoreographer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowChoreographer.java
index 2fb779253..0cfeb053b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowChoreographer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowChoreographer.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.R;
+import static android.os.Build.VERSION_CODES.S;
 import static com.google.common.base.Preconditions.checkState;
 import static org.robolectric.shadows.ShadowLooper.looperMode;
 import static org.robolectric.util.reflector.Reflector.reflector;
@@ -13,6 +14,7 @@ import android.view.Choreographer.FrameCallback;
 import android.view.DisplayEventReceiver;
 import java.time.Duration;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.LooperMode;
@@ -24,6 +26,7 @@ import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Static;
+import org.robolectric.util.reflector.WithType;
 
 /**
  * The shadow API for {@link android.view.Choreographer}.
@@ -40,6 +43,13 @@ public abstract class ShadowChoreographer {
   private static volatile boolean isPaused = false;
   private static volatile Duration frameDelay = Duration.ofMillis(1);
 
+  /**
+   * This field is only used when {@link #isPaused()} is true. It represents the next scheduled
+   * vsync time (with respect to the system clock). See the {@link #getNextVsyncTime()} javadoc for
+   * more details.
+   */
+  private static volatile long nextVsyncTime;
+
   public static class Picker extends LooperShadowPicker<ShadowChoreographer> {
 
     public Picker() {
@@ -87,6 +97,21 @@ public abstract class ShadowChoreographer {
     return isPaused;
   }
 
+  /**
+   * This field is only used when {@link ShadowChoreographer#isPaused()} is true. It represents the
+   * next scheduled vsync time (with respect to the system clock). When the system clock is advanced
+   * to or beyond this time, a Choreographer frame will be triggered. It may be useful for tests to
+   * know when the next scheduled vsync time is in order to determine how long to idle the main
+   * looper in order to trigger the next Choreographer callback.
+   */
+  public static long getNextVsyncTime() {
+    return nextVsyncTime;
+  }
+
+  static void setNextVsyncTime(long nextVsyncTime) {
+    ShadowChoreographer.nextVsyncTime = nextVsyncTime;
+  }
+
   /**
    * Allows application to specify a fixed amount of delay when {@link #postCallback(int, Runnable,
    * Object)} is invoked. The default delay value is 0. This can be used to avoid infinite animation
@@ -161,8 +186,21 @@ public abstract class ShadowChoreographer {
         .measure("doFrame", () -> reflector.doFrame(frameTimeNanos, frame));
   }
 
+  @Implementation(minSdk = S)
+  protected void doFrame(
+      long frameTimeNanos,
+      int frame,
+      @ClassName("android.view.DisplayEventReceiver$VsyncEventData") Object vsyncEventData) {
+    if (reflector == null) {
+      reflector = reflector(ChoreographerReflector.class, realObject);
+    }
+    PerfStatsCollector.getInstance()
+        .measure("doFrame", () -> reflector.doFrame(frameTimeNanos, frame, vsyncEventData));
+  }
+
   @Resetter
   public static void reset() {
+    nextVsyncTime = 0;
     isPaused = false;
     frameDelay = Duration.ofMillis(1);
     if (RuntimeEnvironment.getApiLevel() >= N) {
@@ -188,6 +226,12 @@ public abstract class ShadowChoreographer {
     @Direct
     void doFrame(long frameTimeNanos, int frame);
 
+    @Direct
+    void doFrame(
+        long frameTimeNanos,
+        int frame,
+        @WithType("android.view.DisplayEventReceiver$VsyncEventData") Object vsyncEventData);
+
     @Accessor("mDisplayEventReceiver")
     DisplayEventReceiver getReceiver();
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowConnection.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowConnection.java
index d69882e9e..afc0b134b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowConnection.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowConnection.java
@@ -1,12 +1,16 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.N_MR1;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.os.Bundle;
 import android.telecom.Connection;
 import java.util.Optional;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.util.reflector.Direct;
+import org.robolectric.util.reflector.ForType;
 
 /**
  * Shadow for {@link Connection} that represents a phone call or connection to a remote endpoint
@@ -14,7 +18,10 @@ import org.robolectric.annotation.Implements;
  */
 @Implements(value = Connection.class, minSdk = N_MR1)
 public class ShadowConnection {
+
+  @RealObject private Connection connection;
   private String mostRecentEvent;
+  private boolean destroyed = false;
 
   /** Records the event sent through sendConnectionEvent to be accessed later by tests. */
   @Implementation
@@ -22,7 +29,24 @@ public class ShadowConnection {
     this.mostRecentEvent = event;
   }
 
+  @Implementation
+  protected void destroy() {
+    this.destroyed = true;
+
+    reflector(ConnectionReflector.class, connection).destroy();
+  }
+
   public Optional<String> getLastConnectionEvent() {
     return Optional.ofNullable(mostRecentEvent);
   }
+
+  public boolean isDestroyed() {
+    return destroyed;
+  }
+
+  @ForType(Connection.class)
+  interface ConnectionReflector {
+    @Direct
+    void destroy();
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowConnectivityManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowConnectivityManager.java
index 9083c4e5e..9380b70c4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowConnectivityManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowConnectivityManager.java
@@ -1,11 +1,9 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.S;
-import static org.robolectric.RuntimeEnvironment.getApiLevel;
 import static org.robolectric.Shadows.shadowOf;
 
 import android.app.PendingIntent;
@@ -36,6 +34,7 @@ public class ShadowConnectivityManager {
 
   private NetworkInfo activeNetworkInfo;
   private boolean backgroundDataSetting;
+  private boolean networkCallbacksEnabled = true;
   private int restrictBackgroundStatus = ConnectivityManager.RESTRICT_BACKGROUND_STATUS_DISABLED;
   private int networkPreference = ConnectivityManager.DEFAULT_NETWORK_PREFERENCE;
   private final Map<Integer, NetworkInfo> networkTypeToNetworkInfo = new HashMap<>();
@@ -56,33 +55,45 @@ public class ShadowConnectivityManager {
   private final Map<Network, ProxyInfo> proxyInfoMap = new HashMap<>();
 
   public ShadowConnectivityManager() {
-    NetworkInfo wifi = ShadowNetworkInfo.newInstance(NetworkInfo.DetailedState.DISCONNECTED,
-        ConnectivityManager.TYPE_WIFI, 0, true, false);
+    NetworkInfo wifi =
+        ShadowNetworkInfo.newInstance(
+            NetworkInfo.DetailedState.DISCONNECTED, ConnectivityManager.TYPE_WIFI, 0, true, false);
     networkTypeToNetworkInfo.put(ConnectivityManager.TYPE_WIFI, wifi);
 
-    NetworkInfo mobile = ShadowNetworkInfo.newInstance(NetworkInfo.DetailedState.CONNECTED,
-        ConnectivityManager.TYPE_MOBILE, ConnectivityManager.TYPE_MOBILE_MMS, true, true);
+    NetworkInfo mobile =
+        ShadowNetworkInfo.newInstance(
+            NetworkInfo.DetailedState.CONNECTED,
+            ConnectivityManager.TYPE_MOBILE,
+            ConnectivityManager.TYPE_MOBILE_MMS,
+            true,
+            true);
     networkTypeToNetworkInfo.put(ConnectivityManager.TYPE_MOBILE, mobile);
 
     this.activeNetworkInfo = mobile;
 
-    if (getApiLevel() >= LOLLIPOP) {
-      netIdToNetwork.put(NET_ID_WIFI, ShadowNetwork.newInstance(NET_ID_WIFI));
-      netIdToNetwork.put(NET_ID_MOBILE, ShadowNetwork.newInstance(NET_ID_MOBILE));
-      netIdToNetworkInfo.put(NET_ID_WIFI, wifi);
-      netIdToNetworkInfo.put(NET_ID_MOBILE, mobile);
+    netIdToNetwork.put(NET_ID_WIFI, ShadowNetwork.newInstance(NET_ID_WIFI));
+    netIdToNetwork.put(NET_ID_MOBILE, ShadowNetwork.newInstance(NET_ID_MOBILE));
+    netIdToNetworkInfo.put(NET_ID_WIFI, wifi);
+    netIdToNetworkInfo.put(NET_ID_MOBILE, mobile);
 
-      NetworkCapabilities wifiNetworkCapabilities = ShadowNetworkCapabilities.newInstance();
-      shadowOf(wifiNetworkCapabilities).addTransportType(NetworkCapabilities.TRANSPORT_WIFI);
-      NetworkCapabilities mobileNetworkCapabilities = ShadowNetworkCapabilities.newInstance();
-      shadowOf(mobileNetworkCapabilities).addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR);
+    NetworkCapabilities wifiNetworkCapabilities = ShadowNetworkCapabilities.newInstance();
+    shadowOf(wifiNetworkCapabilities).addTransportType(NetworkCapabilities.TRANSPORT_WIFI);
+    NetworkCapabilities mobileNetworkCapabilities = ShadowNetworkCapabilities.newInstance();
+    shadowOf(mobileNetworkCapabilities).addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR);
 
-      networkCapabilitiesMap.put(netIdToNetwork.get(NET_ID_WIFI), wifiNetworkCapabilities);
-      networkCapabilitiesMap.put(netIdToNetwork.get(NET_ID_MOBILE), mobileNetworkCapabilities);
-    }
+    networkCapabilitiesMap.put(netIdToNetwork.get(NET_ID_WIFI), wifiNetworkCapabilities);
+    networkCapabilitiesMap.put(netIdToNetwork.get(NET_ID_MOBILE), mobileNetworkCapabilities);
     defaultNetworkActive = true;
   }
 
+  /**
+   * Sets whether {@link #setDefaultNetworkActive(boolean)} triggers registered any {@link
+   * ConnectivityManager.NetworkCallback}.
+   */
+  public void setNetworkCallbacksEnabled(boolean enabled) {
+    networkCallbacksEnabled = enabled;
+  }
+
   public Set<ConnectivityManager.NetworkCallback> getNetworkCallbacks() {
     return networkCallbacks;
   }
@@ -285,9 +296,7 @@ public class ShadowConnectivityManager {
     networkTypeToNetworkInfo.put(networkType, networkInfo);
   }
 
-  /**
-   * Returns the captive portal URL previously set with {@link #setCaptivePortalServerUrl}.
-   */
+  /** Returns the captive portal URL previously set with {@link #setCaptivePortalServerUrl}. */
   @Implementation(minSdk = N)
   protected String getCaptivePortalServerUrl() {
     return captivePortalServerUrl;
@@ -302,29 +311,21 @@ public class ShadowConnectivityManager {
     this.captivePortalServerUrl = captivePortalServerUrl;
   }
 
-  @HiddenApi @Implementation
+  @HiddenApi
+  @Implementation
   public void setBackgroundDataSetting(boolean b) {
     backgroundDataSetting = b;
   }
 
   public void setActiveNetworkInfo(NetworkInfo info) {
-    if (getApiLevel() >= LOLLIPOP) {
-      activeNetworkInfo = info;
-      if (info != null) {
-        networkTypeToNetworkInfo.put(info.getType(), info);
-        netIdToNetwork.put(info.getType(), ShadowNetwork.newInstance(info.getType()));
-        netIdToNetworkInfo.put(info.getType(), info);
-      } else {
-        networkTypeToNetworkInfo.clear();
-        netIdToNetwork.clear();
-      }
+    activeNetworkInfo = info;
+    if (info != null) {
+      networkTypeToNetworkInfo.put(info.getType(), info);
+      netIdToNetwork.put(info.getType(), ShadowNetwork.newInstance(info.getType()));
+      netIdToNetworkInfo.put(info.getType(), info);
     } else {
-      activeNetworkInfo = info;
-      if (info != null) {
-        networkTypeToNetworkInfo.put(info.getType(), info);
-      } else {
-        networkTypeToNetworkInfo.clear();
-      }
+      networkTypeToNetworkInfo.clear();
+      netIdToNetwork.clear();
     }
   }
 
@@ -343,6 +344,7 @@ public class ShadowConnectivityManager {
 
   /**
    * Removes the {@code network} from the list of all {@link android.net.Network}s.
+   *
    * @param network The network.
    */
   public void removeNetwork(Network network) {
@@ -352,9 +354,7 @@ public class ShadowConnectivityManager {
     netIdToNetworkInfo.remove(netId);
   }
 
-  /**
-   * Clears the list of all {@link android.net.Network}s.
-   */
+  /** Clears the list of all {@link android.net.Network}s. */
   public void clearAllNetworks() {
     netIdToNetwork.clear();
     netIdToNetworkInfo.clear();
@@ -363,15 +363,19 @@ public class ShadowConnectivityManager {
   /**
    * Sets the active state of the default network.
    *
-   * By default this is true and affects the result of {@link
+   * <p>By default this is true and affects the result of {@link
    * ConnectivityManager#isActiveNetworkMetered()}, {@link
    * ConnectivityManager#isDefaultNetworkActive()}, {@link ConnectivityManager#getActiveNetwork()}
    * and {@link ConnectivityManager#getAllNetworkInfo()}.
    *
-   * Calling this method with {@code true} after any listeners have been registered with {@link
+   * <p>Calling this method with {@code true} after any listeners have been registered with {@link
    * ConnectivityManager#addDefaultNetworkActiveListener(OnNetworkActiveListener)} will result in
    * those listeners being fired.
    *
+   * <p>Calling this method after any {@link ConnectivityManager.NetworkCallback} have been
+   * registered will result in those callbacks being called unless {@link
+   * #setNetworkCallbacksEnabled(boolean)} has been called with a false value.
+   *
    * @param isActive The active state of the default network.
    */
   public void setDefaultNetworkActive(boolean isActive) {
@@ -383,10 +387,38 @@ public class ShadowConnectivityManager {
         }
       }
     }
+
+    if (!networkCallbacksEnabled) {
+      return;
+    }
+
+    NetworkInfo activeNetworkInfo = getActiveNetworkInfo();
+
+    if (activeNetworkInfo == null) {
+      return;
+    }
+
+    Network defaultNetwork = netIdToNetwork.get(activeNetworkInfo.getType());
+
+    if (defaultNetwork == null) {
+      return;
+    }
+
+    HashSet<ConnectivityManager.NetworkCallback> stableNetworkCallbacks =
+        new HashSet<>(networkCallbacks);
+    for (ConnectivityManager.NetworkCallback c : stableNetworkCallbacks) {
+      if (c != null) {
+        if (defaultNetworkActive) {
+          c.onAvailable(defaultNetwork);
+        } else {
+          c.onLost(defaultNetwork);
+        }
+      }
+    }
   }
 
   /**
-   * @return true by default, or the value specifed via {@link #setDefaultNetworkActive(boolean)}
+   * @return true by default, or the value specified via {@link #setDefaultNetworkActive(boolean)}
    * @see #setDefaultNetworkActive(boolean)
    */
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentProviderOperation.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentProviderOperation.java
index aa8857517..56449d78d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentProviderOperation.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentProviderOperation.java
@@ -14,15 +14,16 @@ import org.robolectric.util.ReflectionHelpers;
 
 @Implements(ContentProviderOperation.class)
 public class ShadowContentProviderOperation {
-  public final static int TYPE_INSERT = 1;
-  public final static int TYPE_UPDATE = 2;
-  public final static int TYPE_DELETE = 3;
-  public final static int TYPE_ASSERT = 4;
+  public static final int TYPE_INSERT = 1;
+  public static final int TYPE_UPDATE = 2;
+  public static final int TYPE_DELETE = 3;
+  public static final int TYPE_ASSERT = 4;
 
-  @RealObject
-  private ContentProviderOperation realOperation;
+  @RealObject private ContentProviderOperation realOperation;
 
-  /** @deprecated implementation detail - use public Android APIs instead */
+  /**
+   * @deprecated implementation detail - use public Android APIs instead
+   */
   @HiddenApi
   @Implementation
   @Deprecated
@@ -33,7 +34,9 @@ public class ShadowContentProviderOperation {
     return getFieldReflectively("mType", Integer.class);
   }
 
-  /** @deprecated implementation detail - use public Android APIs instead */
+  /**
+   * @deprecated implementation detail - use public Android APIs instead
+   */
   @Deprecated
   public String getSelection() {
     if (RuntimeEnvironment.getApiLevel() >= R) {
@@ -42,7 +45,9 @@ public class ShadowContentProviderOperation {
     return getFieldReflectively("mSelection", String.class);
   }
 
-  /** @deprecated implementation detail - use public Android APIs instead */
+  /**
+   * @deprecated implementation detail - use public Android APIs instead
+   */
   @Deprecated
   public String[] getSelectionArgs() {
     if (RuntimeEnvironment.getApiLevel() >= R) {
@@ -51,7 +56,9 @@ public class ShadowContentProviderOperation {
     return getFieldReflectively("mSelectionArgs", String[].class);
   }
 
-  /** @deprecated implementation detail - use public Android APIs instead */
+  /**
+   * @deprecated implementation detail - use public Android APIs instead
+   */
   @Deprecated
   public ContentValues getContentValues() {
     if (RuntimeEnvironment.getApiLevel() >= R) {
@@ -60,7 +67,9 @@ public class ShadowContentProviderOperation {
     return getFieldReflectively("mValues", ContentValues.class);
   }
 
-  /** @deprecated implementation detail - use public Android APIs instead */
+  /**
+   * @deprecated implementation detail - use public Android APIs instead
+   */
   @Deprecated
   public Integer getExpectedCount() {
     if (RuntimeEnvironment.getApiLevel() >= R) {
@@ -69,7 +78,9 @@ public class ShadowContentProviderOperation {
     return getFieldReflectively("mExpectedCount", Integer.class);
   }
 
-  /** @deprecated implementation detail - use public Android APIs instead */
+  /**
+   * @deprecated implementation detail - use public Android APIs instead
+   */
   @Deprecated
   public ContentValues getValuesBackReferences() {
     if (RuntimeEnvironment.getApiLevel() >= R) {
@@ -78,7 +89,9 @@ public class ShadowContentProviderOperation {
     return getFieldReflectively("mValuesBackReferences", ContentValues.class);
   }
 
-  /** @deprecated implementation detail - use public Android APIs instead */
+  /**
+   * @deprecated implementation detail - use public Android APIs instead
+   */
   @SuppressWarnings("unchecked")
   @Deprecated
   public Map<Integer, Integer> getSelectionArgsBackReferences() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentProviderResult.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentProviderResult.java
index baf44dd13..8b383ba56 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentProviderResult.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentProviderResult.java
@@ -13,7 +13,9 @@ public class ShadowContentProviderResult {
 
   @Implementation
   protected void __constructor__(Uri uri)
-      throws SecurityException, NoSuchFieldException, IllegalArgumentException,
+      throws SecurityException,
+          NoSuchFieldException,
+          IllegalArgumentException,
           IllegalAccessException {
     Field field = realResult.getClass().getField("uri");
     field.setAccessible(true);
@@ -22,10 +24,12 @@ public class ShadowContentProviderResult {
 
   @Implementation
   protected void __constructor__(int count)
-      throws SecurityException, NoSuchFieldException, IllegalArgumentException,
+      throws SecurityException,
+          NoSuchFieldException,
+          IllegalArgumentException,
           IllegalAccessException {
     Field field = realResult.getClass().getField("count");
     field.setAccessible(true);
     field.set(realResult, count);
   }
-}
\ No newline at end of file
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubManager.java
index 9991a36ee..f00290050 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubManager.java
@@ -1,28 +1,35 @@
 package org.robolectric.shadows;
 
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.annotation.Nullable;
 import android.app.PendingIntent;
 import android.content.Context;
 import android.hardware.location.ContextHubClient;
+import android.hardware.location.ContextHubClientCallback;
 import android.hardware.location.ContextHubInfo;
 import android.hardware.location.ContextHubManager;
 import android.hardware.location.ContextHubTransaction;
 import android.hardware.location.NanoAppInstanceInfo;
+import android.hardware.location.NanoAppMessage;
 import android.hardware.location.NanoAppState;
 import android.os.Build;
 import android.os.Build.VERSION;
 import android.os.Build.VERSION_CODES;
+import com.google.auto.value.AutoValue;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Multimaps;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Executor;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -44,11 +51,14 @@ public class ShadowContextHubManager {
   private static final List<ContextHubInfo> contextHubInfoList = new ArrayList<>();
   private static final List<ContextHubClient> contextHubClientWithPendingIntentList =
       new ArrayList<>();
+
   private final Map<Integer, NanoAppInstanceInfo> nanoAppUidToInfo = new ConcurrentHashMap<>();
   private final Multimap<ContextHubInfo, Integer> contextHubToNanoappUid =
       Multimaps.synchronizedMultimap(HashMultimap.<ContextHubInfo, Integer>create());
   private final HashMultimap<String, ContextHubClient> attributionTagToClientMap =
       HashMultimap.create();
+  private final Map<ContextHubClient, ContextHubClientCallbackDetails> contextHubClientCallbacks =
+      new HashMap<>();
 
   static {
     contextHubInfoList.add(new ContextHubInfo());
@@ -94,27 +104,60 @@ public class ShadowContextHubManager {
   protected Object /* ContextHubClient */ createClient(
       Object /* ContextHubInfo */ contextHubInfo,
       Object /* ContextHubClientCallback */ contextHubClientCallback) {
+    ContextHubClient client;
 
     if (Build.VERSION.SDK_INT >= VERSION_CODES.Q) {
-      return reflector(ContextHubClientReflector.class)
-          .newContextHubClient((ContextHubInfo) contextHubInfo, false);
+      client =
+          reflector(ContextHubClientReflector.class)
+              .newContextHubClient((ContextHubInfo) contextHubInfo, false);
     } else {
-      return reflector(ContextHubClientReflector.class).newContextHubClient();
+      client = reflector(ContextHubClientReflector.class).newContextHubClient();
+    }
+
+    if (contextHubClientCallback != null) {
+      contextHubClientCallbacks.put(
+          client,
+          ContextHubClientCallbackDetails.create(
+              (ContextHubClientCallback) contextHubClientCallback, directExecutor()));
     }
+    return client;
   }
 
   @Implementation(minSdk = VERSION_CODES.P)
   @HiddenApi
   protected Object /* ContextHubClient */ createClient(
-      Object /* ContextHubInfo */ contextHubInfo,
-      Object /* ContextHubClientCallback */ contextHubClientCallback,
-      Object /* Executor */ executor) {
+      ContextHubInfo contextHubInfo,
+      ContextHubClientCallback contextHubClientCallback,
+      Executor executor) {
+    ContextHubClient client;
     if (Build.VERSION.SDK_INT >= VERSION_CODES.Q) {
-      return reflector(ContextHubClientReflector.class)
-          .newContextHubClient((ContextHubInfo) contextHubInfo, false);
+      client =
+          reflector(ContextHubClientReflector.class).newContextHubClient(contextHubInfo, false);
     } else {
-      return reflector(ContextHubClientReflector.class).newContextHubClient();
+      client = reflector(ContextHubClientReflector.class).newContextHubClient();
+    }
+
+    if (contextHubClientCallback != null) {
+      contextHubClientCallbacks.put(
+          client, ContextHubClientCallbackDetails.create(contextHubClientCallback, executor));
     }
+
+    return client;
+  }
+
+  @Implementation(minSdk = VERSION_CODES.Q)
+  @HiddenApi
+  protected Object /* ContextHubClient */ createClient(
+      ContextHubInfo contextHubInfo, PendingIntent pendingIntent, long nanoAppId) {
+    ContextHubClient client;
+    if (Build.VERSION.SDK_INT >= VERSION_CODES.Q) {
+      client =
+          reflector(ContextHubClientReflector.class).newContextHubClient(contextHubInfo, false);
+    } else {
+      client = reflector(ContextHubClientReflector.class).newContextHubClient();
+    }
+    contextHubClientWithPendingIntentList.add(client);
+    return client;
   }
 
   @Implementation(minSdk = VERSION_CODES.S)
@@ -130,6 +173,13 @@ public class ShadowContextHubManager {
     if (context != null && ((Context) context).getAttributionTag() != null) {
       attributionTagToClientMap.put(((Context) context).getAttributionTag(), client);
     }
+
+    if (contextHubClientCallback != null) {
+      contextHubClientCallbacks.put(
+          client,
+          ContextHubClientCallbackDetails.create(
+              (ContextHubClientCallback) contextHubClientCallback, (Executor) executor));
+    }
     return client;
   }
 
@@ -156,6 +206,105 @@ public class ShadowContextHubManager {
     return ImmutableList.copyOf(contextHubClientWithPendingIntentList);
   }
 
+  public void resetContextHub() {
+    for (Map.Entry<ContextHubClient, ContextHubClientCallbackDetails> entry :
+        contextHubClientCallbacks.entrySet()) {
+      entry
+          .getValue()
+          .getExecutor()
+          .execute(() -> entry.getValue().getCallback().onHubReset(entry.getKey()));
+    }
+  }
+
+  public void broadcastMessageFromNanoApp(/*NanoAppMessage*/ Object message) {
+    for (Map.Entry<ContextHubClient, ContextHubClientCallbackDetails> entry :
+        contextHubClientCallbacks.entrySet()) {
+      entry
+          .getValue()
+          .getExecutor()
+          .execute(
+              () ->
+                  entry
+                      .getValue()
+                      .getCallback()
+                      .onMessageFromNanoApp(entry.getKey(), (NanoAppMessage) message));
+    }
+  }
+
+  public void broadcastNanoAppAborted(long nanoAppId, int abortCode) {
+    for (Map.Entry<ContextHubClient, ContextHubClientCallbackDetails> entry :
+        contextHubClientCallbacks.entrySet()) {
+      entry
+          .getValue()
+          .getExecutor()
+          .execute(
+              () ->
+                  entry
+                      .getValue()
+                      .getCallback()
+                      .onNanoAppAborted(entry.getKey(), nanoAppId, abortCode));
+    }
+  }
+
+  public void broadcastNanoAppLoaded(long nanoAppId) {
+    for (Map.Entry<ContextHubClient, ContextHubClientCallbackDetails> entry :
+        contextHubClientCallbacks.entrySet()) {
+      entry
+          .getValue()
+          .getExecutor()
+          .execute(() -> entry.getValue().getCallback().onNanoAppLoaded(entry.getKey(), nanoAppId));
+    }
+  }
+
+  public void broadcastNanoAppUnloaded(long nanoAppId) {
+    for (Map.Entry<ContextHubClient, ContextHubClientCallbackDetails> entry :
+        contextHubClientCallbacks.entrySet()) {
+      entry
+          .getValue()
+          .getExecutor()
+          .execute(
+              () -> entry.getValue().getCallback().onNanoAppUnloaded(entry.getKey(), nanoAppId));
+    }
+  }
+
+  public void broadcastNanoAppEnabled(long nanoAppId) {
+    for (Map.Entry<ContextHubClient, ContextHubClientCallbackDetails> entry :
+        contextHubClientCallbacks.entrySet()) {
+      entry
+          .getValue()
+          .getExecutor()
+          .execute(
+              () -> entry.getValue().getCallback().onNanoAppEnabled(entry.getKey(), nanoAppId));
+    }
+  }
+
+  public void broadcastNanoAppDisabled(long nanoAppId) {
+
+    for (Map.Entry<ContextHubClient, ContextHubClientCallbackDetails> entry :
+        contextHubClientCallbacks.entrySet()) {
+      entry
+          .getValue()
+          .getExecutor()
+          .execute(
+              () -> entry.getValue().getCallback().onNanoAppDisabled(entry.getKey(), nanoAppId));
+    }
+  }
+
+  public void broadcastClientAuthorizationChanged(long nanoAppId, int authorization) {
+    for (Map.Entry<ContextHubClient, ContextHubClientCallbackDetails> entry :
+        contextHubClientCallbacks.entrySet()) {
+      entry
+          .getValue()
+          .getExecutor()
+          .execute(
+              () ->
+                  entry
+                      .getValue()
+                      .getCallback()
+                      .onClientAuthorizationChanged(entry.getKey(), nanoAppId, authorization));
+    }
+  }
+
   @Resetter
   public static void clearContextHubClientWithPendingIntentList() {
     contextHubClientWithPendingIntentList.clear();
@@ -222,6 +371,21 @@ public class ShadowContextHubManager {
     return nanoAppUidToInfo.get(nanoAppHandle);
   }
 
+  @AutoValue
+  abstract static class ContextHubClientCallbackDetails {
+    @Nonnull
+    abstract ContextHubClientCallback getCallback();
+
+    @Nonnull
+    abstract Executor getExecutor();
+
+    static ContextHubClientCallbackDetails create(
+        ContextHubClientCallback callback, Executor executor) {
+      return new AutoValue_ShadowContextHubManager_ContextHubClientCallbackDetails(
+          callback, executor);
+    }
+  }
+
   /** Accessor interface for {@link NanoAppInstanceInfo}'s internals. */
   @ForType(NanoAppInstanceInfo.class)
   private interface ReflectorNanoAppInstanceInfo {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextImpl.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextImpl.java
index af41db2df..8ffe4430e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextImpl.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextImpl.java
@@ -24,7 +24,6 @@ import android.content.ServiceConnection;
 import android.content.SharedPreferences;
 import android.content.pm.ActivityInfo;
 import android.content.res.Configuration;
-import android.os.Build;
 import android.os.Build.VERSION_CODES;
 import android.os.Bundle;
 import android.os.Environment;
@@ -164,14 +163,14 @@ public class ShadowContextImpl {
   protected void sendBroadcast(Intent intent) {
     getShadowInstrumentation()
         .sendBroadcastWithPermission(
-            intent, /*userHandle=*/ null, /*receiverPermission=*/ null, realContextImpl);
+            intent, /* userHandle= */ null, /* receiverPermission= */ null, realContextImpl);
   }
 
   @Implementation
   protected void sendBroadcast(Intent intent, String receiverPermission) {
     getShadowInstrumentation()
         .sendBroadcastWithPermission(
-            intent, /*userHandle=*/ null, receiverPermission, realContextImpl);
+            intent, /* userHandle= */ null, receiverPermission, realContextImpl);
   }
 
   @Implementation(minSdk = TIRAMISU)
@@ -185,7 +184,7 @@ public class ShadowContextImpl {
   @RequiresPermission(android.Manifest.permission.INTERACT_ACROSS_USERS)
   protected void sendBroadcastAsUser(@RequiresPermission Intent intent, UserHandle user) {
     getShadowInstrumentation()
-        .sendBroadcastWithPermission(intent, user, /*receiverPermission=*/ null, realContextImpl);
+        .sendBroadcastWithPermission(intent, user, /* receiverPermission= */ null, realContextImpl);
   }
 
   @Implementation
@@ -214,7 +213,7 @@ public class ShadowContextImpl {
     getShadowInstrumentation()
         .sendOrderedBroadcastAsUser(
             intent,
-            /*userHandle=*/ null,
+            /* userHandle= */ null,
             receiverPermission,
             resultReceiver,
             scheduler,
@@ -377,9 +376,7 @@ public class ShadowContextImpl {
   // This is a private method in ContextImpl so we copy the relevant portions of it here.
   @Implementation
   protected void validateServiceIntent(Intent service) {
-    if (service.getComponent() == null
-        && service.getPackage() == null
-        && realContextImpl.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP) {
+    if (service.getComponent() == null && service.getPackage() == null) {
       throw new IllegalArgumentException("Service Intent must be explicit: " + service);
     }
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCookieManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCookieManager.java
index a44ecf519..6d22123bd 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCookieManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCookieManager.java
@@ -23,4 +23,4 @@ public class ShadowCookieManager {
     }
     return cookieManager;
   }
-}
\ No newline at end of file
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCrossProfileApps.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCrossProfileApps.java
index a895fcb28..f41730af2 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCrossProfileApps.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCrossProfileApps.java
@@ -6,6 +6,7 @@ import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.Manifest.permission;
 import android.annotation.RequiresPermission;
@@ -18,7 +19,6 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.pm.ActivityInfo;
 import android.content.pm.CrossProfileApps;
-import android.content.pm.ICrossProfileApps;
 import android.content.pm.PackageManager;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
@@ -39,30 +39,26 @@ import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.ForType;
 
 /** Robolectric implementation of {@link CrossProfileApps}. */
 @Implements(value = CrossProfileApps.class, minSdk = P)
 public class ShadowCrossProfileApps {
 
+  @RealObject private CrossProfileApps realObject;
   private final Set<UserHandle> targetUserProfiles = new LinkedHashSet<>();
   private final List<StartedMainActivity> startedMainActivities = new ArrayList<>();
   private final List<StartedActivity> startedActivities =
       Collections.synchronizedList(new ArrayList<>());
 
-  private Context context;
-  private PackageManager packageManager;
   // Whether the current application has the interact across profile AppOps.
   private volatile int canInteractAcrossProfileAppOps = AppOpsManager.MODE_ERRORED;
 
   // Whether the current application has requested the interact across profile permission.
   private volatile boolean hasRequestedInteractAcrossProfiles = false;
 
-  @Implementation
-  protected void __constructor__(Context context, ICrossProfileApps service) {
-    this.context = context;
-    this.packageManager = context.getPackageManager();
-  }
-
   /**
    * Returns a list of {@link UserHandle}s currently accessible. This list is populated from calls
    * to {@link #addTargetUserProfile(UserHandle)}.
@@ -246,9 +242,7 @@ public class ShadowCrossProfileApps {
     }
   }
 
-  /**
-   * Ensure the current package has the permission to interact across profiles.
-   */
+  /** Ensure the current package has the permission to interact across profiles. */
   protected void verifyHasInteractAcrossProfilesPermission() {
     if (RuntimeEnvironment.getApiLevel() >= R) {
       if (!canInteractAcrossProfiles()) {
@@ -256,7 +250,7 @@ public class ShadowCrossProfileApps {
       }
       return;
     }
-    if (context.checkSelfPermission(permission.INTERACT_ACROSS_PROFILES)
+    if (getContext().checkSelfPermission(permission.INTERACT_ACROSS_PROFILES)
         != PackageManager.PERMISSION_GRANTED) {
       throw new SecurityException(
           "Attempt to launch activity without required "
@@ -287,8 +281,10 @@ public class ShadowCrossProfileApps {
 
     boolean existsMatchingActivity =
         Iterables.any(
-            packageManager.queryIntentActivities(
-                launchIntent, MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE),
+            getContext()
+                .getPackageManager()
+                .queryIntentActivities(
+                    launchIntent, MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE),
             resolveInfo -> {
               ActivityInfo activityInfo = resolveInfo.activityInfo;
               return TextUtils.equals(activityInfo.packageName, component.getPackageName())
@@ -382,10 +378,16 @@ public class ShadowCrossProfileApps {
   }
 
   private boolean hasPermission(String permission) {
-    return context.getPackageManager().checkPermission(permission, context.getPackageName())
+    return getContext()
+            .getPackageManager()
+            .checkPermission(permission, getContext().getPackageName())
         == PackageManager.PERMISSION_GRANTED;
   }
 
+  protected Context getContext() {
+    return reflector(CrossProfileAppsReflector.class, realObject).getContext();
+  }
+
   /**
    * Forces the {code interact_across_profile} AppOps for the current package.
    *
@@ -396,8 +398,8 @@ public class ShadowCrossProfileApps {
     hasRequestedInteractAcrossProfiles = true;
     if (canInteractAcrossProfileAppOps != newMode) {
       canInteractAcrossProfileAppOps = newMode;
-      context.sendBroadcast(
-          new Intent(CrossProfileApps.ACTION_CAN_INTERACT_ACROSS_PROFILES_CHANGED));
+      getContext()
+          .sendBroadcast(new Intent(CrossProfileApps.ACTION_CAN_INTERACT_ACROSS_PROFILES_CHANGED));
     }
   }
 
@@ -424,7 +426,7 @@ public class ShadowCrossProfileApps {
    */
   @Implementation(minSdk = R)
   protected boolean canConfigureInteractAcrossProfiles(String packageName) {
-    return context.getPackageName().equals(packageName);
+    return getContext().getPackageName().equals(packageName);
   }
 
   /**
@@ -547,4 +549,10 @@ public class ShadowCrossProfileApps {
       return Objects.hash(componentName, userHandle);
     }
   }
+
+  @ForType(CrossProfileApps.class)
+  interface CrossProfileAppsReflector {
+    @Accessor("mContext")
+    Context getContext();
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCursorWrapper.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCursorWrapper.java
index 9e659a93c..bcbd418b6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCursorWrapper.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCursorWrapper.java
@@ -22,177 +22,212 @@ public class ShadowCursorWrapper implements Cursor {
     wrappedCursor = c;
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public int getCount() {
     return wrappedCursor.getCount();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public int getPosition() {
     return wrappedCursor.getPosition();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public boolean move(int i) {
     return wrappedCursor.move(i);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public boolean moveToPosition(int i) {
     return wrappedCursor.moveToPosition(i);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public boolean moveToFirst() {
     return wrappedCursor.moveToFirst();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public boolean moveToLast() {
     return wrappedCursor.moveToLast();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public boolean moveToNext() {
     return wrappedCursor.moveToNext();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public boolean moveToPrevious() {
     return wrappedCursor.moveToPrevious();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public boolean isFirst() {
     return wrappedCursor.isFirst();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public boolean isLast() {
     return wrappedCursor.isLast();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public boolean isBeforeFirst() {
     return wrappedCursor.isBeforeFirst();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public boolean isAfterLast() {
     return wrappedCursor.isAfterLast();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public int getColumnIndex(String s) {
     return wrappedCursor.getColumnIndex(s);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public int getColumnIndexOrThrow(String s) throws IllegalArgumentException {
     return wrappedCursor.getColumnIndexOrThrow(s);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public String getColumnName(int i) {
     return wrappedCursor.getColumnName(i);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public String[] getColumnNames() {
     return wrappedCursor.getColumnNames();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public int getColumnCount() {
     return wrappedCursor.getColumnCount();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public byte[] getBlob(int i) {
     return wrappedCursor.getBlob(i);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public String getString(int i) {
     return wrappedCursor.getString(i);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public void copyStringToBuffer(int i, CharArrayBuffer charArrayBuffer) {
     wrappedCursor.copyStringToBuffer(i, charArrayBuffer);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public short getShort(int i) {
     return wrappedCursor.getShort(i);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public int getInt(int i) {
     return wrappedCursor.getInt(i);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public long getLong(int i) {
     return wrappedCursor.getLong(i);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public float getFloat(int i) {
     return wrappedCursor.getFloat(i);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public double getDouble(int i) {
     return wrappedCursor.getDouble(i);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public boolean isNull(int i) {
     return wrappedCursor.isNull(i);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public void deactivate() {
     wrappedCursor.deactivate();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public boolean requery() {
     return wrappedCursor.requery();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public void close() {
     wrappedCursor.close();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public boolean isClosed() {
     return wrappedCursor.isClosed();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public void registerContentObserver(ContentObserver contentObserver) {
     wrappedCursor.registerContentObserver(contentObserver);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public void unregisterContentObserver(ContentObserver contentObserver) {
     wrappedCursor.unregisterContentObserver(contentObserver);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public void registerDataSetObserver(DataSetObserver dataSetObserver) {
     wrappedCursor.registerDataSetObserver(dataSetObserver);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public void unregisterDataSetObserver(DataSetObserver dataSetObserver) {
     wrappedCursor.unregisterDataSetObserver(dataSetObserver);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public void setNotificationUri(ContentResolver contentResolver, Uri uri) {
     wrappedCursor.setNotificationUri(contentResolver, uri);
   }
@@ -203,27 +238,32 @@ public class ShadowCursorWrapper implements Cursor {
     return wrappedCursor.getNotificationUri();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public boolean getWantsAllOnMoveCalls() {
     return wrappedCursor.getWantsAllOnMoveCalls();
   }
 
-  @Override @Implementation(minSdk = M)
+  @Override
+  @Implementation(minSdk = M)
   public void setExtras(Bundle extras) {
     wrappedCursor.setExtras(extras);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public Bundle getExtras() {
     return wrappedCursor.getExtras();
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public Bundle respond(Bundle bundle) {
     return wrappedCursor.respond(bundle);
   }
 
-  @Override @Implementation
+  @Override
+  @Implementation
   public int getType(int columnIndex) {
     return wrappedCursor.getType(columnIndex);
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDateIntervalFormat.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDateIntervalFormat.java
index dd3ff5c0d..6d239723f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDateIntervalFormat.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDateIntervalFormat.java
@@ -19,7 +19,8 @@ public class ShadowDateIntervalFormat {
   @Implementation(maxSdk = LOLLIPOP_MR1)
   public static long createDateIntervalFormat(String skeleton, String localeName, String tzName) {
     address++;
-    INTERVAL_CACHE.put(address, com.ibm.icu.text.DateIntervalFormat.getInstance(skeleton, new Locale(localeName)));
+    INTERVAL_CACHE.put(
+        address, com.ibm.icu.text.DateIntervalFormat.getInstance(skeleton, new Locale(localeName)));
     return address;
   }
 
@@ -34,7 +35,9 @@ public class ShadowDateIntervalFormat {
     StringBuffer buffer = new StringBuffer();
 
     FieldPosition pos = new FieldPosition(0);
-    INTERVAL_CACHE.get(address).format(new com.ibm.icu.util.DateInterval(fromDate, toDate), buffer, pos);
+    INTERVAL_CACHE
+        .get(address)
+        .format(new com.ibm.icu.util.DateInterval(fromDate, toDate), buffer, pos);
 
     return buffer.toString();
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDatePickerDialog.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDatePickerDialog.java
index b7a59ba05..f43342e38 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDatePickerDialog.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDatePickerDialog.java
@@ -32,7 +32,9 @@ public class ShadowDatePickerDialog extends ShadowAlertDialog {
       int dayOfMonth) {
     this.calendar = calendar;
 
-    invokeConstructor(DatePickerDialog.class, realDatePickerDialog,
+    invokeConstructor(
+        DatePickerDialog.class,
+        realDatePickerDialog,
         ClassParameter.from(Context.class, context),
         ClassParameter.from(int.class, theme),
         ClassParameter.from(DatePickerDialog.OnDateSetListener.class, callBack),
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyManager.java
index 83f659e2b..34bb3c9a6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyManager.java
@@ -156,7 +156,6 @@ public class ShadowDevicePolicyManager {
   private Object /* DevicePolicyState */ devicePolicyState;
   private @RealObject DevicePolicyManager realObject;
 
-  
   private static class PackageAndPermission {
 
     public PackageAndPermission(String packageName, String permission) {
@@ -513,40 +512,37 @@ public class ShadowDevicePolicyManager {
     }
   }
 
-  private boolean hasPackage(String caller, String packageName) {
-    if (caller == null) {
-      return false;
-    }
-    return caller.contains(packageName);
-  }
-
   private void enforceCallerDelegated(String targetScope) {
-    if (!delegatedScopePackagesMap.containsKey(targetScope)
-        || delegatedScopePackagesMap.get(targetScope).isEmpty()) {
-      throw new SecurityException(targetScope + " is not delegated to any package.");
-    }
     String caller = context.getPackageName();
-    for (String packageName : delegatedScopePackagesMap.get(targetScope)) {
-      if (hasPackage(caller, packageName)) {
-        return;
-      }
+    if (!delegatedScopePackagesMap.containsKey(caller)
+        || !delegatedScopePackagesMap.get(caller).contains(targetScope)) {
+      throw new SecurityException("[" + caller + "] is not delegated with" + targetScope);
     }
-    throw new SecurityException("[" + caller + "] is not delegated with" + targetScope);
   }
 
   @Implementation(minSdk = O)
   protected void setDelegatedScopes(
       ComponentName admin, String delegatePackage, List<String> scopes) {
     enforceDeviceOwnerOrProfileOwner(admin);
-    for (String scope : scopes) {
-      if (delegatedScopePackagesMap.containsKey(scope)) {
-        Set<String> allowPackages = delegatedScopePackagesMap.get(scope);
-        allowPackages.add(delegatePackage);
-      } else {
-        ImmutableSet<String> allowPackages = ImmutableSet.of(delegatePackage);
-        delegatedScopePackagesMap.put(scope, allowPackages);
+    delegatedScopePackagesMap.put(delegatePackage, ImmutableSet.copyOf(scopes));
+  }
+
+  @Implementation(minSdk = O)
+  protected List<String> getDelegatedScopes(ComponentName admin, String delegatePackage) {
+    Objects.requireNonNull(delegatePackage, "Delegate package is null");
+    if (admin == null) {
+      String caller = context.getPackageName();
+      if (!Objects.equals(caller, delegatePackage)) {
+        throw new SecurityException(String.format("Caller is not %s.", delegatePackage));
       }
+      // this app is retrieving its own delegated scopes
+    } else {
+      enforceDeviceOwnerOrProfileOwner(admin);
+    }
+    if (delegatedScopePackagesMap.containsKey(delegatePackage)) {
+      return ImmutableList.copyOf(delegatedScopePackagesMap.get(delegatePackage));
     }
+    return ImmutableList.of();
   }
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayEventReceiver.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayEventReceiver.java
index dc6a1cc6b..4cb4b94ca 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayEventReceiver.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayEventReceiver.java
@@ -18,7 +18,6 @@ import dalvik.system.CloseGuard;
 import java.lang.ref.WeakReference;
 import java.lang.reflect.Array;
 import java.time.Duration;
-import javax.annotation.concurrent.GuardedBy;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -109,7 +108,6 @@ public class ShadowDisplayEventReceiver {
     nativeObjRegistry.getNativeObject(receiverPtr).scheduleVsync();
   }
 
-
   @Implementation(maxSdk = R)
   protected void dispose(boolean finalized) {
     CloseGuard closeGuard = displayEventReceiverReflector.getCloseGuard();
@@ -163,9 +161,6 @@ public class ShadowDisplayEventReceiver {
     private final WeakReference<DisplayEventReceiver> receiverRef;
     private final ShadowPausedSystemClock.Listener clockListener = this::onClockAdvanced;
 
-    @GuardedBy("this")
-    private long nextVsyncTime = 0;
-
     public NativeDisplayEventReceiver(WeakReference<DisplayEventReceiver> receiverRef) {
       this.receiverRef = receiverRef;
       // register a clock listener for the async mode
@@ -174,11 +169,13 @@ public class ShadowDisplayEventReceiver {
 
     private void onClockAdvanced() {
       synchronized (this) {
+        long nextVsyncTime = ShadowChoreographer.getNextVsyncTime();
         if (nextVsyncTime == 0 || ShadowPausedSystemClock.uptimeMillis() < nextVsyncTime) {
           return;
         }
-        nextVsyncTime = 0;
+        ShadowChoreographer.setNextVsyncTime(0);
       }
+
       doVsync();
     }
 
@@ -189,8 +186,8 @@ public class ShadowDisplayEventReceiver {
     public void scheduleVsync() {
       Duration frameDelay = ShadowChoreographer.getFrameDelay();
       if (ShadowChoreographer.isPaused()) {
-        synchronized (this) {
-          nextVsyncTime = SystemClock.uptimeMillis() + frameDelay.toMillis();
+        if (ShadowChoreographer.getNextVsyncTime() < SystemClock.uptimeMillis()) {
+          ShadowChoreographer.setNextVsyncTime(SystemClock.uptimeMillis() + frameDelay.toMillis());
         }
       } else {
         // simulate an immediate callback
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManager.java
index 8bcb83f6b..c86ecb274 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManager.java
@@ -52,6 +52,7 @@ public class ShadowDisplayManager {
   private Context context;
 
   private static final String DEFAULT_DISPLAY_NAME = "Built-in screen";
+  private static final int DEFAULT_DISPLAY_TYPE = Display.TYPE_UNKNOWN;
 
   private static final HashMap<Integer, Boolean> displayIsNaturallyPortrait = new HashMap<>();
 
@@ -77,7 +78,20 @@ public class ShadowDisplayManager {
    * @return the new display's ID
    */
   public static int addDisplay(String qualifiersStr) {
-    return addDisplay(qualifiersStr, DEFAULT_DISPLAY_NAME);
+    return addDisplayInternal(qualifiersStr, DEFAULT_DISPLAY_NAME, DEFAULT_DISPLAY_TYPE);
+  }
+
+  /**
+   * Adds a physical display with given type and drain the main looper queue to ensure all the
+   * callbacks are processed.
+   *
+   * @param qualifiersStr the {@link Qualifiers} string representing characteristics of the new
+   *     display.
+   * @param displayType the integer denoting the type of the new display.
+   * @return the new display's ID
+   */
+  public static int addDisplay(String qualifiersStr, int displayType) {
+    return addDisplayInternal(qualifiersStr, DEFAULT_DISPLAY_NAME, displayType);
   }
 
   /**
@@ -90,11 +104,7 @@ public class ShadowDisplayManager {
    * @return the new display's ID
    */
   public static int addDisplay(String qualifiersStr, String displayName) {
-    int id =
-        getShadowDisplayManagerGlobal()
-            .addDisplay(createDisplayInfo(qualifiersStr, null, displayName));
-    shadowMainLooper().idle();
-    return id;
+    return addDisplayInternal(qualifiersStr, displayName, DEFAULT_DISPLAY_TYPE);
   }
 
   static IllegalStateException configureDefaultDisplayCallstack;
@@ -116,14 +126,27 @@ public class ShadowDisplayManager {
 
     shadowDisplayManagerGlobal.addDisplay(
         createDisplayInfo(
-            configuration, displayMetrics, /* isNaturallyPortrait= */ true, DEFAULT_DISPLAY_NAME));
+            configuration,
+            displayMetrics,
+            /* isNaturallyPortrait= */ true,
+            DEFAULT_DISPLAY_NAME,
+            DEFAULT_DISPLAY_TYPE));
+  }
+
+  private static int addDisplayInternal(String qualifiersStr, String displayName, int displayType) {
+    int id =
+        getShadowDisplayManagerGlobal()
+            .addDisplay(createDisplayInfo(qualifiersStr, null, displayName, displayType));
+    shadowMainLooper().idle();
+    return id;
   }
 
   private static DisplayInfo createDisplayInfo(
       Configuration configuration,
       DisplayMetrics displayMetrics,
       boolean isNaturallyPortrait,
-      String name) {
+      String name,
+      int displayType) {
     int widthPx = (int) (configuration.screenWidthDp * displayMetrics.density);
     int heightPx = (int) (configuration.screenHeightDp * displayMetrics.density);
 
@@ -149,19 +172,18 @@ public class ShadowDisplayManager {
     displayInfo.logicalDensityDpi = displayMetrics.densityDpi;
     displayInfo.physicalXDpi = displayMetrics.densityDpi;
     displayInfo.physicalYDpi = displayMetrics.densityDpi;
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-      displayInfo.state = Display.STATE_ON;
-    }
+    displayInfo.state = Display.STATE_ON;
+    displayInfo.type = displayType;
 
     return displayInfo;
   }
 
   private static DisplayInfo createDisplayInfo(String qualifiersStr, @Nullable Integer displayId) {
-    return createDisplayInfo(qualifiersStr, displayId, DEFAULT_DISPLAY_NAME);
+    return createDisplayInfo(qualifiersStr, displayId, DEFAULT_DISPLAY_NAME, DEFAULT_DISPLAY_TYPE);
   }
 
   private static DisplayInfo createDisplayInfo(
-      String qualifiersStr, @Nullable Integer displayId, String name) {
+      String qualifiersStr, @Nullable Integer displayId, String name, int displayType) {
     DisplayInfo baseDisplayInfo =
         displayId != null ? DisplayManagerGlobal.getInstance().getDisplayInfo(displayId) : null;
     Configuration configuration = new Configuration();
@@ -191,7 +213,7 @@ public class ShadowDisplayManager {
     Bootstrap.applyQualifiers(
         qualifiersStr, RuntimeEnvironment.getApiLevel(), configuration, displayMetrics);
 
-    return createDisplayInfo(configuration, displayMetrics, isNaturallyPortrait, name);
+    return createDisplayInfo(configuration, displayMetrics, isNaturallyPortrait, name, displayType);
   }
 
   private static boolean isRotated(int rotation) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDropBoxManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDropBoxManager.java
index 99a47909b..1176cc71b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDropBoxManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDropBoxManager.java
@@ -55,9 +55,7 @@ public class ShadowDropBoxManager {
     addData(tag, ShadowSystem.currentTimeMillis(), data.getBytes(UTF_8));
   }
 
-  /**
-   * Clears all entries.
-   */
+  /** Clears all entries. */
   public void reset() {
     entries.clear();
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowEGL14.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowEGL14.java
index 547b9f1ff..d83733082 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowEGL14.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowEGL14.java
@@ -5,14 +5,13 @@ import android.opengl.EGLConfig;
 import android.opengl.EGLContext;
 import android.opengl.EGLDisplay;
 import android.opengl.EGLSurface;
-import android.os.Build.VERSION_CODES;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
 /** Shadow for EGL14. Currently doesn't handle real graphics work, but avoids crashing when run. */
-@Implements(value = EGL14.class, minSdk = VERSION_CODES.LOLLIPOP)
+@Implements(value = EGL14.class)
 public class ShadowEGL14 {
   private static final long UNUSED_HANDLE_ID = 43L;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFileIntegrityManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFileIntegrityManager.java
index f00259319..8224cb548 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFileIntegrityManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFileIntegrityManager.java
@@ -7,7 +7,7 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
 /** Shadow for {@link FileIntegrityManager}. */
-@Implements(value = FileIntegrityManager.class, minSdk = R)
+@Implements(value = FileIntegrityManager.class, minSdk = R, isInAndroidSdk = false)
 public class ShadowFileIntegrityManager {
 
   private boolean isApkVeritySupported = true;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFileUtils.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFileUtils.java
index fe4c7ae53..d6733ec77 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFileUtils.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFileUtils.java
@@ -25,7 +25,8 @@ public class ShadowFileUtils {
       long count)
       throws IOException {
     // never do the native copy optimization block
-    return ReflectionHelpers.callStaticMethod(FileUtils.class,
+    return ReflectionHelpers.callStaticMethod(
+        FileUtils.class,
         "copyInternalUserspace",
         from(FileDescriptor.class, in),
         from(FileDescriptor.class, out),
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFilter.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFilter.java
index 67fcbd7e4..7197f4b8f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFilter.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFilter.java
@@ -17,14 +17,19 @@ public class ShadowFilter {
       Class<?> forName = Class.forName("android.widget.Filter$FilterResults");
       Object filtering;
       try {
-        filtering = ReflectionHelpers.callInstanceMethod(realObject, "performFiltering",
-            ClassParameter.from(CharSequence.class, constraint));
+        filtering =
+            ReflectionHelpers.callInstanceMethod(
+                realObject,
+                "performFiltering",
+                ClassParameter.from(CharSequence.class, constraint));
       } catch (Exception e) {
         e.printStackTrace();
         filtering = ReflectionHelpers.newInstance(forName);
       }
 
-      ReflectionHelpers.callInstanceMethod(realObject, "publishResults",
+      ReflectionHelpers.callInstanceMethod(
+          realObject,
+          "publishResults",
           ClassParameter.from(CharSequence.class, constraint),
           ClassParameter.from(forName, filtering));
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFingerprintManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFingerprintManager.java
index 51292fefd..9bd665cf6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFingerprintManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFingerprintManager.java
@@ -41,7 +41,8 @@ public class ShadowFingerprintManager {
 
   /**
    * Simulates a successful fingerprint authentication. An authentication request must have been
-   * issued with {@link FingerprintManager#authenticate(CryptoObject, CancellationSignal, int, AuthenticationCallback, Handler)} and not cancelled.
+   * issued with {@link FingerprintManager#authenticate(CryptoObject, CancellationSignal, int,
+   * AuthenticationCallback, Handler)} and not cancelled.
    */
   public void authenticationSucceeds() {
     if (pendingCallback == null) {
@@ -69,8 +70,9 @@ public class ShadowFingerprintManager {
   }
 
   /**
-   * Simulates a failed fingerprint authentication. An authentication request must have been
-   * issued with {@link FingerprintManager#authenticate(CryptoObject, CancellationSignal, int, AuthenticationCallback, Handler)} and not cancelled.
+   * Simulates a failed fingerprint authentication. An authentication request must have been issued
+   * with {@link FingerprintManager#authenticate(CryptoObject, CancellationSignal, int,
+   * AuthenticationCallback, Handler)} and not cancelled.
    */
   public void authenticationFails() {
     if (pendingCallback == null) {
@@ -100,10 +102,11 @@ public class ShadowFingerprintManager {
         Log.w(TAG, "authentication already canceled");
         return;
       } else {
-        cancel.setOnCancelListener(() -> {
-          this.pendingCallback = null;
-          this.pendingCryptoObject = null;
-        });
+        cancel.setOnCancelListener(
+            () -> {
+              this.pendingCallback = null;
+              this.pendingCryptoObject = null;
+            });
       }
     }
 
@@ -122,8 +125,8 @@ public class ShadowFingerprintManager {
   }
 
   /**
-   * Returns {@code false} by default, or the value specified via
-   * {@link #setHasEnrolledFingerprints(boolean)}.
+   * Returns {@code false} by default, or the value specified via {@link
+   * #setHasEnrolledFingerprints(boolean)}.
    */
   @Implementation
   protected boolean hasEnrolledFingerprints() {
@@ -171,9 +174,7 @@ public class ShadowFingerprintManager {
     this.fingerprints = Arrays.asList(fingerprints);
   }
 
-  /**
-   * Sets the return value of {@link FingerprintManager#isHardwareDetected()}.
-   */
+  /** Sets the return value of {@link FingerprintManager#isHardwareDetected()}. */
   public void setIsHardwareDetected(boolean isHardwareDetected) {
     this.isHardwareDetected = isHardwareDetected;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFontBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFontBuilder.java
index 50f8c7d60..cdd96c080 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFontBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFontBuilder.java
@@ -77,7 +77,7 @@ public class ShadowFontBuilder {
 
     // Guarded<AssetManager2>* mgr = AssetManagerForJavaObject(env, assetMgr);
     CppAssetManager2 mgr = ShadowArscAssetManager10.AssetManagerForJavaObject(assetMgr);
-    //if (mgr == nullptr) {
+    // if (mgr == nullptr) {
     if (mgr == null) {
       return 0;
     }
@@ -96,8 +96,10 @@ public class ShadowFontBuilder {
         asset = mgr.Open(path, AccessMode.ACCESS_BUFFER);
       } else if (cookie > 0) {
         // Valid java cookies are 1-based, but AssetManager cookies are 0-based.
-        // asset = locked_mgr->OpenNonAsset(str.c_str(), static_cast<ApkAssetsCookie>(cookie - 1), Asset::ACCESS_BUFFER);
-        asset = mgr.OpenNonAsset(path, ApkAssetsCookie.forInt(cookie - 1), AccessMode.ACCESS_BUFFER);
+        // asset = locked_mgr->OpenNonAsset(str.c_str(), static_cast<ApkAssetsCookie>(cookie - 1),
+        // Asset::ACCESS_BUFFER);
+        asset =
+            mgr.OpenNonAsset(path, ApkAssetsCookie.forInt(cookie - 1), AccessMode.ACCESS_BUFFER);
       } else {
         // asset = locked_mgr->OpenNonAsset(str.c_str(), Asset::ACCESS_BUFFER);
         asset = mgr.OpenNonAsset(path, AccessMode.ACCESS_BUFFER);
@@ -112,7 +114,8 @@ public class ShadowFontBuilder {
   protected static ByteBuffer nGetAssetBuffer(long nativeAsset) {
     // Asset* asset = toAsset(nativeAsset);
     Asset asset = Registries.NATIVE_ASSET_REGISTRY.getNativeObject(nativeAsset);
-    //return env->NewDirectByteBuffer(const_cast<void*>(asset->getBuffer(false)), asset->getLength());
+    // return env->NewDirectByteBuffer(const_cast<void*>(asset->getBuffer(false)),
+    // asset->getLength());
     return ByteBuffer.wrap(asset.getBuffer(false));
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFontFamily.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFontFamily.java
index 6d46c6240..904cb3e41 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFontFamily.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFontFamily.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.O;
 
 import android.content.res.AssetManager;
@@ -9,7 +8,7 @@ import android.graphics.fonts.FontVariationAxis;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
-@Implements(value = FontFamily.class, minSdk = LOLLIPOP, isInAndroidSdk = false)
+@Implements(value = FontFamily.class, isInAndroidSdk = false)
 public class ShadowFontFamily {
 
   @Implementation(minSdk = O)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGLES20.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGLES20.java
index 27d06fc28..110488bc9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGLES20.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGLES20.java
@@ -4,9 +4,7 @@ import android.opengl.GLES20;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
-/**
- * Fake implementation of {@link GLES20}
- */
+/** Fake implementation of {@link GLES20} */
 @Implements(GLES20.class)
 public class ShadowGLES20 {
   private static int framebufferCount = 0;
@@ -47,7 +45,7 @@ public class ShadowGLES20 {
       case GLES20.GL_COMPILE_STATUS:
         params[0] = GLES20.GL_TRUE;
         break;
-      default:  // no-op
+      default: // no-op
     }
   }
 
@@ -57,7 +55,7 @@ public class ShadowGLES20 {
       case GLES20.GL_LINK_STATUS:
         params[0] = GLES20.GL_TRUE;
         break;
-      default:  // no-op
+      default: // no-op
     }
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGLSurfaceView.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGLSurfaceView.java
index 157896e64..cb8cb427c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGLSurfaceView.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGLSurfaceView.java
@@ -1,15 +1,74 @@
 package org.robolectric.shadows;
 
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.content.Context;
 import android.opengl.GLSurfaceView;
+import android.util.AttributeSet;
+import java.lang.ref.WeakReference;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.annotation.Resetter;
+import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.Direct;
+import org.robolectric.util.reflector.ForType;
 
 /** Fake implementation of GLSurfaceView */
 @Implements(GLSurfaceView.class)
 public class ShadowGLSurfaceView extends ShadowSurfaceView {
+  private static final ConcurrentLinkedQueue<WeakReference<GLSurfaceView>> surfaceViews =
+      new ConcurrentLinkedQueue<>();
+
+  @RealObject private GLSurfaceView realSurfaceView;
+
+  @Implementation
+  protected void __constructor__(Context context) {
+    reflector(GLSurfaceViewReflector.class, realSurfaceView).__constructor__(context);
+    surfaceViews.add(new WeakReference<>(realSurfaceView));
+  }
+
+  @Implementation
+  protected void __constructor__(Context context, AttributeSet attrs) {
+    reflector(GLSurfaceViewReflector.class, realSurfaceView).__constructor__(context, attrs);
+    surfaceViews.add(new WeakReference<>(realSurfaceView));
+  }
+
   @Implementation
   protected void onPause() {}
 
   @Implementation
   protected void onResume() {}
+
+  private static void requestExitAndWaitGlThread(GLSurfaceView view) {
+    Object glThread = reflector(GLSurfaceViewReflector.class, view).getGLThread();
+    if (glThread != null) {
+      ReflectionHelpers.callInstanceMethod(glThread, "requestExitAndWait");
+    }
+  }
+
+  @Resetter
+  public static void reset() {
+    WeakReference<GLSurfaceView> surfaceView;
+    while ((surfaceView = surfaceViews.poll()) != null) {
+      GLSurfaceView view = surfaceView.get();
+      if (view != null) {
+        requestExitAndWaitGlThread(view);
+      }
+    }
+  }
+
+  @ForType(GLSurfaceView.class)
+  interface GLSurfaceViewReflector {
+    @Accessor("mGLThread")
+    Object getGLThread();
+
+    @Direct
+    void __constructor__(Context context);
+
+    @Direct
+    void __constructor__(Context context, AttributeSet attrs);
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGeocoder.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGeocoder.java
index ecf456a6d..68633b3d0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGeocoder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGeocoder.java
@@ -21,7 +21,9 @@ public final class ShadowGeocoder {
   private List<Address> fromLocation = new ArrayList<>();
   private String errorMessage = null;
 
-  /** @return true by default, or the value specified via {@link #setIsPresent(boolean)} */
+  /**
+   * @return true by default, or the value specified via {@link #setIsPresent(boolean)}
+   */
   @Implementation
   protected static boolean isPresent() {
     return isPresent;
@@ -73,6 +75,23 @@ public final class ShadowGeocoder {
     }
   }
 
+  /**
+   * Sets an empty list by default, or the last value set by {@link #setFromLocation(List)} in the
+   * provided {@code listener}
+   *
+   * <p>{@code locationName} is ignored by this implementation. {@code maxResults} determines the
+   * maximum number of addresses to return.
+   */
+  @Implementation(minSdk = TIRAMISU)
+  protected void getFromLocationName(
+      String locationName, int maxResults, GeocodeListener listener) {
+    if (errorMessage != null) {
+      listener.onError(errorMessage);
+    } else {
+      listener.onGeocode(fromLocation.subList(0, Math.min(maxResults, fromLocation.size())));
+    }
+  }
+
   /**
    * Sets the value to be returned by {@link Geocoder#isPresent()}.
    *
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGradientDrawable.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGradientDrawable.java
index fed709b17..ae12f99de 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGradientDrawable.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowGradientDrawable.java
@@ -31,7 +31,6 @@ public class ShadowGradientDrawable extends ShadowDrawable {
     reflector(GradientDrawableReflector.class, realGradientDrawable).setStroke(width, color);
   }
 
-
   /**
    * Returns the color of this drawable as set by the last call to {@link #setColor(int color)}.
    *
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIAppOpsService.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIAppOpsService.java
index d23459c78..dcfe653ac 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIAppOpsService.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIAppOpsService.java
@@ -17,4 +17,3 @@ public class ShadowIAppOpsService {
     }
   }
 }
-
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImageDecoder.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImageDecoder.java
index 9f9722522..a454e68ed 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImageDecoder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImageDecoder.java
@@ -141,12 +141,13 @@ public class ShadowImageDecoder {
     //     SkCodec.MinBufferedBytesNeeded()));
     // return native_create(bufferedStream, source);
 
-    return jniCreateDecoder(new ImgStream() {
-      @Override
-      protected InputStream getInputStream() {
-        return is;
-      }
-    });
+    return jniCreateDecoder(
+        new ImgStream() {
+          @Override
+          protected InputStream getInputStream() {
+            return is;
+          }
+        });
   }
 
   protected static ImageDecoder ImageDecoder_nCreateAsset(long asset_ptr, Source source)
@@ -155,8 +156,8 @@ public class ShadowImageDecoder {
     // SkStream stream = new AssetStreamAdaptor(asset);
     // return jniCreateDecoder(stream, source);
     Resources resources = ReflectionHelpers.getField(source, "mResources");
-    AssetInputStream assetInputStream = ShadowAssetInputStream.createAssetInputStream(
-        null, asset_ptr, resources.getAssets());
+    AssetInputStream assetInputStream =
+        ShadowAssetInputStream.createAssetInputStream(null, asset_ptr, resources.getAssets());
     return jniCreateDecoder(
         new ImgStream() {
           @Override
@@ -176,33 +177,40 @@ public class ShadowImageDecoder {
     //       null, source);
     // }
     // return native_create(stream, source);
-    return jniCreateDecoder(new ImgStream() {
-      @Override
-      protected InputStream getInputStream() {
-        return new ByteArrayInputStream(jbyteBuffer.array());
-      }
-    });
+    return jniCreateDecoder(
+        new ImgStream() {
+          @Override
+          protected InputStream getInputStream() {
+            return new ByteArrayInputStream(jbyteBuffer.array());
+          }
+        });
   }
 
   protected static ImageDecoder ImageDecoder_nCreateByteArray(
       byte[] byteArray, int offset, int length, Source source) {
     // SkStream stream = CreateByteArrayStreamAdaptor(byteArray, offset, length);
     // return native_create(stream, source);
-    return jniCreateDecoder(new ImgStream() {
-      @Override
-      protected InputStream getInputStream() {
-        return new ByteArrayInputStream(byteArray);
-      }
-    });
+    return jniCreateDecoder(
+        new ImgStream() {
+          @Override
+          protected InputStream getInputStream() {
+            return new ByteArrayInputStream(byteArray);
+          }
+        });
   }
 
-  protected static Bitmap ImageDecoder_nDecodeBitmap(long nativePtr,
+  protected static Bitmap ImageDecoder_nDecodeBitmap(
+      long nativePtr,
       ImageDecoder decoder,
       boolean doPostProcess,
-      int width, int height,
-      Rect cropRect, boolean mutable,
-      int allocator, boolean unpremulRequired,
-      boolean conserveMemory, boolean decodeAsAlphaMask,
+      int width,
+      int height,
+      Rect cropRect,
+      boolean mutable,
+      int allocator,
+      boolean unpremulRequired,
+      boolean conserveMemory,
+      boolean decodeAsAlphaMask,
       ColorSpace desiredColorSpace)
       throws IOException {
     CppImageDecoder cppImageDecoder = NATIVE_IMAGE_DECODER_REGISTRY.getNativeObject(nativePtr);
@@ -228,8 +236,7 @@ public class ShadowImageDecoder {
     return bitmap;
   }
 
-  static Size ImageDecoder_nGetSampledSize(long nativePtr,
-      int sampleSize) {
+  static Size ImageDecoder_nGetSampledSize(long nativePtr, int sampleSize) {
     CppImageDecoder decoder = NATIVE_IMAGE_DECODER_REGISTRY.getNativeObject(nativePtr);
     // SkISize size = decoder.mCodec.getSampledDimensions(sampleSize);
     // return env.NewObject(gSize_class, gSize_constructorMethodID, size.width(), size.height());
@@ -237,8 +244,7 @@ public class ShadowImageDecoder {
     throw new UnsupportedOperationException();
   }
 
-  static void ImageDecoder_nGetPadding(long nativePtr,
-      Rect outPadding) {
+  static void ImageDecoder_nGetPadding(long nativePtr, Rect outPadding) {
     CppImageDecoder decoder = NATIVE_IMAGE_DECODER_REGISTRY.getNativeObject(nativePtr);
     // decoder.mPeeker.getPadding(outPadding);
     if (decoder.imgStream.isNinePatch()) {
@@ -343,13 +349,18 @@ public class ShadowImageDecoder {
       boolean decodeAsAlphaMask,
       android.graphics.ColorSpace desiredColorSpace)
       throws IOException {
-    return ImageDecoder_nDecodeBitmap(nativePtr,
+    return ImageDecoder_nDecodeBitmap(
+        nativePtr,
         decoder,
         doPostProcess,
-        width, height,
-        cropRect, mutable,
-        allocator, unpremulRequired,
-        conserveMemory, decodeAsAlphaMask,
+        width,
+        height,
+        cropRect,
+        mutable,
+        allocator,
+        unpremulRequired,
+        conserveMemory,
+        decodeAsAlphaMask,
         desiredColorSpace);
   }
 
@@ -369,19 +380,23 @@ public class ShadowImageDecoder {
       long desiredColorSpace,
       boolean extended)
       throws IOException {
-    return ImageDecoder_nDecodeBitmap(nativePtr,
+    return ImageDecoder_nDecodeBitmap(
+        nativePtr,
         decoder,
         doPostProcess,
-        width, height,
-        cropRect, mutable,
-        allocator, unpremulRequired,
-        conserveMemory, decodeAsAlphaMask,
+        width,
+        height,
+        cropRect,
+        mutable,
+        allocator,
+        unpremulRequired,
+        conserveMemory,
+        decodeAsAlphaMask,
         null);
   }
 
   @Implementation
-  protected static Size nGetSampledSize(long nativePtr,
-      int sampleSize) {
+  protected static Size nGetSampledSize(long nativePtr, int sampleSize) {
     return ImageDecoder_nGetSampledSize(nativePtr, sampleSize);
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImsMmTelManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImsMmTelManager.java
index aaa1dff22..6e8dad158 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImsMmTelManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImsMmTelManager.java
@@ -38,10 +38,7 @@ import org.robolectric.util.reflector.Static;
  * @see #setImsAvailableOnDevice(boolean)
  * @see #setImsRegistered(int)
  */
-@Implements(
-    value = ImsMmTelManager.class,
-    minSdk = VERSION_CODES.Q,
-    isInAndroidSdk = false)
+@Implements(value = ImsMmTelManager.class, minSdk = VERSION_CODES.Q, isInAndroidSdk = false)
 @SystemApi
 public class ShadowImsMmTelManager {
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInCallService.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInCallService.java
index e5997eee9..e68ccac92 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInCallService.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInCallService.java
@@ -164,7 +164,9 @@ public class ShadowInCallService extends ShadowService {
     }
   }
 
-  /** @return the last value provided to {@code requestBluetoothAudio()}. */
+  /**
+   * @return the last value provided to {@code requestBluetoothAudio()}.
+   */
   @TargetApi(P)
   public BluetoothDevice getBluetoothAudio() {
     return bluetoothDevice;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java
index 6ad76286c..623302507 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java
@@ -98,6 +98,7 @@ public class ShadowInstrumentation {
 
   @GuardedBy("itself")
   private final List<Wrapper> registeredReceivers = new ArrayList<>();
+
   // map of pid+uid to granted permissions
   private final Map<Pair<Integer, Integer>, Set<String>> grantedPermissionsMap =
       Collections.synchronizedMap(new HashMap<>());
@@ -522,7 +523,7 @@ public class ShadowInstrumentation {
   void sendBroadcastWithPermission(
       Intent intent, String receiverPermission, Context context, int resultCode) {
     sendBroadcastWithPermission(
-        intent, /*userHandle=*/ null, receiverPermission, context, null, resultCode);
+        intent, /* userHandle= */ null, receiverPermission, context, null, resultCode);
   }
 
   void sendBroadcastWithPermission(
@@ -532,7 +533,7 @@ public class ShadowInstrumentation {
       @Nullable Bundle broadcastOptions,
       int resultCode) {
     sendBroadcastWithPermission(
-        intent, /*userHandle=*/ null, receiverPermission, context, broadcastOptions, resultCode);
+        intent, /* userHandle= */ null, receiverPermission, context, broadcastOptions, resultCode);
   }
 
   void sendBroadcastWithPermission(
@@ -552,7 +553,7 @@ public class ShadowInstrumentation {
     List<Wrapper> wrappers =
         getAppropriateWrappers(
             context,
-            /*userHandle=*/ null,
+            /* userHandle= */ null,
             intent,
             receiverPermission,
             /* broadcastOptions= */ null);
@@ -884,7 +885,7 @@ public class ShadowInstrumentation {
 
   void sendBroadcast(Intent intent, Context context) {
     sendBroadcastWithPermission(
-        intent, /*userHandle=*/ null, /*receiverPermission=*/ null, context);
+        intent, /* userHandle= */ null, /* receiverPermission= */ null, context);
   }
 
   Intent registerReceiver(
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIntent.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIntent.java
index bcce460ee..4e172bd24 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIntent.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowIntent.java
@@ -10,11 +10,9 @@ public class ShadowIntent {
   @RealObject private Intent realIntent;
 
   /**
-   * Returns the {@code Class} object set by
-   * {@link Intent#setClass(android.content.Context, Class)}
+   * Returns the {@code Class} object set by {@link Intent#setClass(android.content.Context, Class)}
    *
-   * @return the {@code Class} object set by
-   *         {@link Intent#setClass(android.content.Context, Class)}
+   * @return the {@code Class} object set by {@link Intent#setClass(android.content.Context, Class)}
    */
   public Class<?> getIntentClass() {
     try {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowJobScheduler.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowJobScheduler.java
index 1ecdd2340..807e9bbfb 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowJobScheduler.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowJobScheduler.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.S;
@@ -23,7 +22,7 @@ import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
-@Implements(value = JobScheduler.class, minSdk = LOLLIPOP)
+@Implements(value = JobScheduler.class)
 public abstract class ShadowJobScheduler {
 
   @Implementation
@@ -55,7 +54,7 @@ public abstract class ShadowJobScheduler {
   /** Whether to fail a job if it is set as expedited. */
   public abstract void failExpeditedJob(boolean enabled);
 
-  @Implements(value = JobSchedulerImpl.class, isInAndroidSdk = false, minSdk = LOLLIPOP)
+  @Implements(value = JobSchedulerImpl.class, isInAndroidSdk = false)
   public static class ShadowJobSchedulerImpl extends ShadowJobScheduler {
 
     private final Map<Integer, JobInfo> scheduledJobs =
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowJobService.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowJobService.java
index c527b5f5b..34e672b8a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowJobService.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowJobService.java
@@ -1,7 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
-
 import android.app.Notification;
 import android.app.job.JobParameters;
 import android.app.job.JobService;
@@ -9,7 +7,7 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.versioning.AndroidVersions.U;
 
-@Implements(value = JobService.class, minSdk = LOLLIPOP)
+@Implements(value = JobService.class)
 public class ShadowJobService extends ShadowService {
 
   private boolean isJobFinished = false;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowJsPromptResult.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowJsPromptResult.java
index 331521e54..0696169c5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowJsPromptResult.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowJsPromptResult.java
@@ -6,7 +6,7 @@ import android.webkit.JsPromptResult;
 import org.robolectric.annotation.Implements;
 
 @Implements(JsPromptResult.class)
-public class ShadowJsPromptResult extends ShadowJsResult{
+public class ShadowJsPromptResult extends ShadowJsResult {
 
   public static JsPromptResult newInstance() {
     return newInstanceOf(JsPromptResult.class);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowKeyCharacterMap.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowKeyCharacterMap.java
index b9768fb92..9f33e0705 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowKeyCharacterMap.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowKeyCharacterMap.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-
 import android.view.KeyCharacterMap;
 import android.view.KeyEvent;
 import java.util.HashMap;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowKeyguardManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowKeyguardManager.java
index d28f705d5..f1b6383a9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowKeyguardManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowKeyguardManager.java
@@ -205,8 +205,8 @@ public class ShadowKeyguardManager {
   }
 
   /**
-   * For tests on Android >= O MR1, sets the value to be returned by
-   * {@link #createConfirmFactoryResetCredentialIntent(CharSequence,CharSequence,CharSequence)}.
+   * For tests on Android >= O MR1, sets the value to be returned by {@link
+   * #createConfirmFactoryResetCredentialIntent(CharSequence,CharSequence,CharSequence)}.
    *
    * @see #createConfirmFactoryResetCredentialIntent(CharSequence,CharSequence,CharSequence)
    */
@@ -215,8 +215,8 @@ public class ShadowKeyguardManager {
   }
 
   /**
-   * Returns the intent set via
-   * {@link #setConfirmFactoryResetCredentialIntent(Intent)}, otherwise null.
+   * Returns the intent set via {@link #setConfirmFactoryResetCredentialIntent(Intent)}, otherwise
+   * null.
    */
   @Implementation(minSdk = O_MR1)
   protected Intent createConfirmFactoryResetCredentialIntent(
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLauncherApps.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLauncherApps.java
index d640f23fc..02c3f5dbf 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLauncherApps.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLauncherApps.java
@@ -1,7 +1,6 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.L;
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.N_MR1;
 import static android.os.Build.VERSION_CODES.O;
@@ -45,7 +44,7 @@ import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
 
 /** Shadow of {@link android.content.pm.LauncherApps}. */
-@Implements(value = LauncherApps.class, minSdk = LOLLIPOP)
+@Implements(value = LauncherApps.class)
 public class ShadowLauncherApps {
   private List<ShortcutInfo> shortcuts = new ArrayList<>();
   private final Multimap<UserHandle, String> enabledPackages = HashMultimap.create();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyAsyncTaskLoader.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyAsyncTaskLoader.java
index c1ad70721..4384f6590 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyAsyncTaskLoader.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyAsyncTaskLoader.java
@@ -10,10 +10,10 @@ import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.RealObject;
 
-/**
- * The shadow {@link AsyncTaskLoader} for {@link LooperMode.Mode.LEGACY}.
- */
-@Implements(value = AsyncTaskLoader.class, shadowPicker = ShadowAsyncTaskLoader.Picker.class,
+/** The shadow {@link AsyncTaskLoader} for {@link LooperMode.Mode.LEGACY}. */
+@Implements(
+    value = AsyncTaskLoader.class,
+    shadowPicker = ShadowAsyncTaskLoader.Picker.class,
     isInAndroidSdk = false)
 public class ShadowLegacyAsyncTaskLoader<D> extends ShadowAsyncTaskLoader {
   @RealObject private AsyncTaskLoader<D> realObject;
@@ -26,24 +26,28 @@ public class ShadowLegacyAsyncTaskLoader<D> extends ShadowAsyncTaskLoader {
 
   @Implementation
   protected void onForceLoad() {
-    FutureTask<D> future = new FutureTask<D>(worker) {
-      @Override
-      protected void done() {
-        try {
-          final D result = get();
-          ShadowApplication.getInstance().getForegroundThreadScheduler().post(new Runnable() {
-            @Override
-            public void run() {
-              realObject.deliverResult(result);
+    FutureTask<D> future =
+        new FutureTask<D>(worker) {
+          @Override
+          protected void done() {
+            try {
+              final D result = get();
+              ShadowApplication.getInstance()
+                  .getForegroundThreadScheduler()
+                  .post(
+                      new Runnable() {
+                        @Override
+                        public void run() {
+                          realObject.deliverResult(result);
+                        }
+                      });
+            } catch (InterruptedException e) {
+              // Ignore
+            } catch (ExecutionException e) {
+              throw new RuntimeException(e.getCause());
             }
-          });
-        } catch (InterruptedException e) {
-          // Ignore
-        } catch (ExecutionException e) {
-          throw new RuntimeException(e.getCause());
-        }
-      }
-    };
+          }
+        };
 
     ShadowApplication.getInstance().getBackgroundThreadScheduler().post(future);
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyCursorWindow.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyCursorWindow.java
index 38c91b832..90c370c3d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyCursorWindow.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyCursorWindow.java
@@ -41,8 +41,8 @@ public class ShadowLegacyCursorWindow extends ShadowCursorWindow {
         return null;
       case Cursor.FIELD_TYPE_BLOB:
         // This matches Android's behavior, which does not match the SQLite spec
-        byte[] blob = (byte[])value.value;
-        return blob == null ? new byte[]{} : blob;
+        byte[] blob = (byte[]) value.value;
+        return blob == null ? new byte[] {} : blob;
       case Cursor.FIELD_TYPE_STRING:
         // Matches the Android behavior to contain a zero-byte at the end
         byte[] stringBytes = ((String) value.value).getBytes(UTF_8);
@@ -93,29 +93,39 @@ public class ShadowLegacyCursorWindow extends ShadowCursorWindow {
   protected static boolean nativePutBlob(long windowPtr, byte[] value, int row, int column) {
     // Real Android will crash in native code if putString is called with a null value.
     Preconditions.checkNotNull(value);
-    return WINDOW_DATA.get(windowPtr).putValue(new Value(value, Cursor.FIELD_TYPE_BLOB), row, column);
+    return WINDOW_DATA
+        .get(windowPtr)
+        .putValue(new Value(value, Cursor.FIELD_TYPE_BLOB), row, column);
   }
 
   @Implementation
   protected static boolean nativePutString(long windowPtr, String value, int row, int column) {
     // Real Android will crash in native code if putString is called with a null value.
     Preconditions.checkNotNull(value);
-    return WINDOW_DATA.get(windowPtr).putValue(new Value(value, Cursor.FIELD_TYPE_STRING), row, column);
+    return WINDOW_DATA
+        .get(windowPtr)
+        .putValue(new Value(value, Cursor.FIELD_TYPE_STRING), row, column);
   }
 
   @Implementation
   protected static boolean nativePutLong(long windowPtr, long value, int row, int column) {
-    return WINDOW_DATA.get(windowPtr).putValue(new Value(value, Cursor.FIELD_TYPE_INTEGER), row, column);
+    return WINDOW_DATA
+        .get(windowPtr)
+        .putValue(new Value(value, Cursor.FIELD_TYPE_INTEGER), row, column);
   }
 
   @Implementation
   protected static boolean nativePutDouble(long windowPtr, double value, int row, int column) {
-    return WINDOW_DATA.get(windowPtr).putValue(new Value(value, Cursor.FIELD_TYPE_FLOAT), row, column);
+    return WINDOW_DATA
+        .get(windowPtr)
+        .putValue(new Value(value, Cursor.FIELD_TYPE_FLOAT), row, column);
   }
 
   @Implementation
   protected static boolean nativePutNull(long windowPtr, int row, int column) {
-    return WINDOW_DATA.get(windowPtr).putValue(new Value(null, Cursor.FIELD_TYPE_NULL), row, column);
+    return WINDOW_DATA
+        .get(windowPtr)
+        .putValue(new Value(null, Cursor.FIELD_TYPE_NULL), row, column);
   }
 
   @Implementation
@@ -146,17 +156,18 @@ public class ShadowLegacyCursorWindow extends ShadowCursorWindow {
       case Cursor.FIELD_TYPE_INTEGER:
       case Cursor.FIELD_TYPE_FLOAT:
         return (Number) value.value;
-      case Cursor.FIELD_TYPE_STRING: {
-        try {
-          return Double.parseDouble((String) value.value);
-        } catch (NumberFormatException e) {
-          return 0;
+      case Cursor.FIELD_TYPE_STRING:
+        {
+          try {
+            return Double.parseDouble((String) value.value);
+          } catch (NumberFormatException e) {
+            return 0;
+          }
         }
-      }
       case Cursor.FIELD_TYPE_BLOB:
-        throw new android.database.sqlite.SQLiteException("could not convert "+value);
+        throw new android.database.sqlite.SQLiteException("could not convert " + value);
       default:
-        throw new android.database.sqlite.SQLiteException("unknown type: "+value.type);
+        throw new android.database.sqlite.SQLiteException("unknown type: " + value.type);
     }
   }
 
@@ -187,8 +198,8 @@ public class ShadowLegacyCursorWindow extends ShadowCursorWindow {
     }
 
     public void fillWith(SQLiteStatement stmt) throws SQLiteException {
-      //Android caches results in the WindowedCursor to allow moveToPrevious() to function.
-      //Robolectric will have to cache the results too. In the rows list.
+      // Android caches results in the WindowedCursor to allow moveToPrevious() to function.
+      // Robolectric will have to cache the results too. In the rows list.
       while (stmt.step()) {
         rows.add(fillRowValues(stmt));
       }
@@ -196,11 +207,16 @@ public class ShadowLegacyCursorWindow extends ShadowCursorWindow {
 
     private static int cursorValueType(final int sqliteType) {
       switch (sqliteType) {
-        case SQLiteConstants.SQLITE_NULL:    return Cursor.FIELD_TYPE_NULL;
-        case SQLiteConstants.SQLITE_INTEGER: return Cursor.FIELD_TYPE_INTEGER;
-        case SQLiteConstants.SQLITE_FLOAT:   return Cursor.FIELD_TYPE_FLOAT;
-        case SQLiteConstants.SQLITE_TEXT:    return Cursor.FIELD_TYPE_STRING;
-        case SQLiteConstants.SQLITE_BLOB:    return Cursor.FIELD_TYPE_BLOB;
+        case SQLiteConstants.SQLITE_NULL:
+          return Cursor.FIELD_TYPE_NULL;
+        case SQLiteConstants.SQLITE_INTEGER:
+          return Cursor.FIELD_TYPE_INTEGER;
+        case SQLiteConstants.SQLITE_FLOAT:
+          return Cursor.FIELD_TYPE_FLOAT;
+        case SQLiteConstants.SQLITE_TEXT:
+          return Cursor.FIELD_TYPE_STRING;
+        case SQLiteConstants.SQLITE_BLOB:
+          return Cursor.FIELD_TYPE_BLOB;
         default:
           throw new IllegalArgumentException(
               "Bad SQLite type " + sqliteType + ". See possible values in SQLiteConstants.");
@@ -240,7 +256,7 @@ public class ShadowLegacyCursorWindow extends ShadowCursorWindow {
 
     public Row(int length) {
       values = new ArrayList<Value>(length);
-      for (int i=0; i<length; i++) {
+      for (int i = 0; i < length; i++) {
         values.add(new Value(null, Cursor.FIELD_TYPE_NULL));
       }
     }
@@ -307,5 +323,6 @@ public class ShadowLegacyCursorWindow extends ShadowCursorWindow {
   // private static native int nativeCreateFromParcel(Parcel parcel);
   // private static native void nativeWriteToParcel($ptrClass windowPtr, Parcel parcel);
   // private static native void nativeFreeLastRow($ptrClass windowPtr);
-  // private static native void nativeCopyStringToBuffer($ptrClass windowPtr, int row, int column, CharArrayBuffer buffer);
+  // private static native void nativeCopyStringToBuffer($ptrClass windowPtr, int row, int column,
+  // CharArrayBuffer buffer);
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMatrix.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMatrix.java
index fb6bb48e5..d9bdd6d92 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMatrix.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMatrix.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-
 import android.graphics.Matrix;
 import android.graphics.Matrix.ScaleToFit;
 import android.graphics.PointF;
@@ -283,7 +282,9 @@ public class ShadowLegacyMatrix extends ShadowMatrix {
   }
 
   boolean hasPerspective() {
-    return (simpleMatrix.mValues[6] != 0 || simpleMatrix.mValues[7] != 0 || simpleMatrix.mValues[8] != 1);
+    return (simpleMatrix.mValues[6] != 0
+        || simpleMatrix.mValues[7] != 0
+        || simpleMatrix.mValues[8] != 1);
   }
 
   protected AffineTransform getAffineTransform() {
@@ -370,16 +371,16 @@ public class ShadowLegacyMatrix extends ShadowMatrix {
   @Override
   public boolean equals(Object obj) {
     if (obj instanceof Matrix) {
-        return getSimpleMatrix(((Matrix) obj)).equals(simpleMatrix);
+      return getSimpleMatrix(((Matrix) obj)).equals(simpleMatrix);
     } else {
-        return obj instanceof ShadowMatrix && obj.equals(simpleMatrix);
+      return obj instanceof ShadowMatrix && obj.equals(simpleMatrix);
     }
   }
 
   @Implementation
   @Override
   public int hashCode() {
-      return Objects.hashCode(simpleMatrix);
+    return Objects.hashCode(simpleMatrix);
   }
 
   @Override
@@ -402,9 +403,7 @@ public class ShadowLegacyMatrix extends ShadowMatrix {
     return true;
   }
 
-  /**
-   * A simple implementation of an immutable matrix.
-   */
+  /** A simple implementation of an immutable matrix. */
   private static class SimpleMatrix {
     private static final SimpleMatrix IDENTITY = newIdentityMatrix();
 
@@ -439,7 +438,8 @@ public class ShadowLegacyMatrix extends ShadowMatrix {
       final float m01 = mValues[1];
       final float m10 = mValues[3];
       final float m11 = mValues[4];
-      return (m00 == 0 && m11 == 0 && m01 != 0 && m10 != 0) || (m00 != 0 && m11 != 0 && m01 == 0 && m10 == 0);
+      return (m00 == 0 && m11 == 0 && m01 != 0 && m10 != 0)
+          || (m00 != 0 && m11 != 0 && m01 == 0 && m10 == 0);
     }
 
     public void getValues(float[] values) {
@@ -450,27 +450,26 @@ public class ShadowLegacyMatrix extends ShadowMatrix {
     }
 
     public static SimpleMatrix translate(float dx, float dy) {
-      return new SimpleMatrix(new float[] {
-          1.0f, 0.0f, dx,
-          0.0f, 1.0f, dy,
-          0.0f, 0.0f, 1.0f,
-      });
+      return new SimpleMatrix(
+          new float[] {
+            1.0f, 0.0f, dx,
+            0.0f, 1.0f, dy,
+            0.0f, 0.0f, 1.0f,
+          });
     }
 
     public static SimpleMatrix scale(float sx, float sy, float px, float py) {
-      return new SimpleMatrix(new float[] {
-          sx,   0.0f, px * (1 - sx),
-          0.0f, sy,   py * (1 - sy),
-          0.0f, 0.0f, 1.0f,
-      });
+      return new SimpleMatrix(
+          new float[] {
+            sx, 0.0f, px * (1 - sx), 0.0f, sy, py * (1 - sy), 0.0f, 0.0f, 1.0f,
+          });
     }
 
     public static SimpleMatrix scale(float sx, float sy) {
-      return new SimpleMatrix(new float[] {
-          sx,   0.0f, 0.0f,
-          0.0f, sy,   0.0f,
-          0.0f, 0.0f, 1.0f,
-      });
+      return new SimpleMatrix(
+          new float[] {
+            sx, 0.0f, 0.0f, 0.0f, sy, 0.0f, 0.0f, 0.0f, 1.0f,
+          });
     }
 
     public static SimpleMatrix rotate(float degrees, float px, float py) {
@@ -488,35 +487,39 @@ public class ShadowLegacyMatrix extends ShadowMatrix {
     }
 
     public static SimpleMatrix sinCos(float sin, float cos, float px, float py) {
-      return new SimpleMatrix(new float[] {
-          cos,  -sin, sin * py + (1 - cos) * px,
-          sin,  cos,  -sin * px + (1 - cos) * py,
-          0.0f, 0.0f, 1.0f,
-      });
+      return new SimpleMatrix(
+          new float[] {
+            cos,
+            -sin,
+            sin * py + (1 - cos) * px,
+            sin,
+            cos,
+            -sin * px + (1 - cos) * py,
+            0.0f,
+            0.0f,
+            1.0f,
+          });
     }
 
     public static SimpleMatrix sinCos(float sin, float cos) {
-      return new SimpleMatrix(new float[] {
-          cos,  -sin, 0.0f,
-          sin,  cos,  0.0f,
-          0.0f, 0.0f, 1.0f,
-      });
+      return new SimpleMatrix(
+          new float[] {
+            cos, -sin, 0.0f, sin, cos, 0.0f, 0.0f, 0.0f, 1.0f,
+          });
     }
 
     public static SimpleMatrix skew(float kx, float ky, float px, float py) {
-      return new SimpleMatrix(new float[] {
-          1.0f, kx,   -kx * py,
-          ky,   1.0f, -ky * px,
-          0.0f, 0.0f, 1.0f,
-      });
+      return new SimpleMatrix(
+          new float[] {
+            1.0f, kx, -kx * py, ky, 1.0f, -ky * px, 0.0f, 0.0f, 1.0f,
+          });
     }
 
     public static SimpleMatrix skew(float kx, float ky) {
-      return new SimpleMatrix(new float[] {
-          1.0f, kx,   0.0f,
-          ky,   1.0f, 0.0f,
-          0.0f, 0.0f, 1.0f,
-      });
+      return new SimpleMatrix(
+          new float[] {
+            1.0f, kx, 0.0f, ky, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f,
+          });
     }
 
     public SimpleMatrix multiply(SimpleMatrix matrix) {
@@ -559,7 +562,8 @@ public class ShadowLegacyMatrix extends ShadowMatrix {
           point.x * mValues[3] + point.y * mValues[4] + mValues[5]);
     }
 
-    // See: https://android.googlesource.com/platform/frameworks/base/+/6fca81de9b2079ec88e785f58bf49bf1f0c105e2/tools/layoutlib/bridge/src/android/graphics/Matrix_Delegate.java
+    // See:
+    // https://android.googlesource.com/platform/frameworks/base/+/6fca81de9b2079ec88e785f58bf49bf1f0c105e2/tools/layoutlib/bridge/src/android/graphics/Matrix_Delegate.java
     protected boolean setRectToRect(RectF src, RectF dst, ScaleToFit stf) {
       if (dst.isEmpty()) {
         mValues[0] =
@@ -651,9 +655,10 @@ public class ShadowLegacyMatrix extends ShadowMatrix {
     }
 
     private float inverseDeterminant() {
-      final float determinant = mValues[0] * cross(mValues[4], mValues[8], mValues[5], mValues[7]) +
-          mValues[1] * cross(mValues[5], mValues[6], mValues[3], mValues[8]) +
-          mValues[2] * cross(mValues[3], mValues[7], mValues[4], mValues[6]);
+      final float determinant =
+          mValues[0] * cross(mValues[4], mValues[8], mValues[5], mValues[7])
+              + mValues[1] * cross(mValues[5], mValues[6], mValues[3], mValues[8])
+              + mValues[2] * cross(mValues[3], mValues[7], mValues[4], mValues[6]);
       return isNearlyZero(determinant) ? 0.0f : 1.0f / determinant;
     }
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMessage.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMessage.java
index a2d27cec0..2ba592787 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMessage.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMessage.java
@@ -25,8 +25,7 @@ import org.robolectric.util.reflector.ForType;
  */
 @Implements(value = Message.class, isInAndroidSdk = false)
 public class ShadowLegacyMessage extends ShadowMessage {
-  @RealObject
-  private Message realMessage;
+  @RealObject private Message realMessage;
   private Runnable scheduledRunnable;
 
   private void unschedule() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMessageQueue.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMessageQueue.java
index 3bb02e204..8adee661b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMessageQueue.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyMessageQueue.java
@@ -1,8 +1,6 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
-import static org.robolectric.RuntimeEnvironment.getApiLevel;
 import static org.robolectric.util.ReflectionHelpers.getField;
 import static org.robolectric.util.ReflectionHelpers.setField;
 import static org.robolectric.util.reflector.Reflector.reflector;
@@ -91,33 +89,34 @@ public class ShadowLegacyMessageQueue extends ShadowMessageQueue {
     final boolean retval =
         reflector(MessageQueueReflector.class, realQueue).enqueueMessage(msg, when);
     if (retval) {
-      final Runnable callback = new Runnable() {
-        @Override
-        public void run() {
-          synchronized (realQueue) {
-            Message m = getHead();
-            if (m == null) {
-              return;
-            }
+      final Runnable callback =
+          new Runnable() {
+            @Override
+            public void run() {
+              synchronized (realQueue) {
+                Message m = getHead();
+                if (m == null) {
+                  return;
+                }
 
-            Message n = shadowOf(m).getNext();
-            if (m == msg) {
-              setHead(n);
-            } else {
-              while (n != null) {
-                if (n == msg) {
-                  n = shadowOf(n).getNext();
-                  shadowOf(m).setNext(n);
-                  break;
+                Message n = shadowOf(m).getNext();
+                if (m == msg) {
+                  setHead(n);
+                } else {
+                  while (n != null) {
+                    if (n == msg) {
+                      n = shadowOf(n).getNext();
+                      shadowOf(m).setNext(n);
+                      break;
+                    }
+                    m = n;
+                    n = shadowOf(m).getNext();
+                  }
                 }
-                m = n;
-                n = shadowOf(m).getNext();
               }
+              dispatchMessage(msg);
             }
-          }
-          dispatchMessage(msg);
-        }
-      };
+          };
       shadowOf(msg).setScheduledRunnable(callback);
       if (when == 0) {
         scheduler.postAtFrontOfQueue(callback);
@@ -139,11 +138,7 @@ public class ShadowLegacyMessageQueue extends ShadowMessageQueue {
       msgProxy.markInUse();
       target.dispatchMessage(msg);
 
-      if (getApiLevel() >= LOLLIPOP) {
-        msgProxy.recycleUnchecked();
-      } else {
-        msgProxy.recycle();
-      }
+      msgProxy.recycleUnchecked();
     }
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyPath.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyPath.java
index 4789e56d4..5455482f9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyPath.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyPath.java
@@ -47,7 +47,7 @@ public class ShadowLegacyPath extends ShadowPath {
   protected void __constructor__(Path path) {
     ShadowLegacyPath shadowPath = extract(path);
     points = new ArrayList<>(shadowPath.getPoints());
-    mPath.append(shadowPath.mPath, /*connect=*/ false);
+    mPath.append(shadowPath.mPath, /* connect= */ false);
     mFillType = shadowPath.getFillType();
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacySQLiteConnection.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacySQLiteConnection.java
index 727929e70..841911805 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacySQLiteConnection.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacySQLiteConnection.java
@@ -90,9 +90,7 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
     return CONNECTIONS.prepareStatement(connectionPtr, newSql);
   }
 
-  /**
-   * Convert SQL with phrase COLLATE LOCALIZED or COLLATE UNICODE to COLLATE NOCASE.
-   */
+  /** Convert SQL with phrase COLLATE LOCALIZED or COLLATE UNICODE to COLLATE NOCASE. */
   static String convertSQLWithLocalizedUnicodeCollator(String sql) {
     Matcher matcher = COLLATE_LOCALIZED_UNICODE_PATTERN.matcher(sql);
     return matcher.replaceAll(" COLLATE NOCASE");
@@ -249,14 +247,15 @@ public class ShadowLegacySQLiteConnection extends ShadowSQLiteConnection {
     // not supported by sqlite4java
     return 0;
   }
-// VisibleForTesting
-static class Connections {
 
-  private final Object lock = new Object();
-  private final AtomicLong pointerCounter = new AtomicLong(0);
-  private final Map<Long, SQLiteStatement> statementsMap = new HashMap<>();
-  private final Map<Long, SQLiteConnection> connectionsMap = new HashMap<>();
-  private final Map<Long, List<Long>> statementPtrsForConnection = new HashMap<>();
+  // VisibleForTesting
+  static class Connections {
+
+    private final Object lock = new Object();
+    private final AtomicLong pointerCounter = new AtomicLong(0);
+    private final Map<Long, SQLiteStatement> statementsMap = new HashMap<>();
+    private final Map<Long, SQLiteConnection> connectionsMap = new HashMap<>();
+    private final Map<Long, List<Long>> statementPtrsForConnection = new HashMap<>();
 
     private ExecutorService dbExecutor = Executors.newSingleThreadExecutor(threadFactory());
 
@@ -269,10 +268,10 @@ static class Connections {
       };
     }
 
-  SQLiteConnection getConnection(final long connectionPtr) {
-    synchronized (lock) {
-      final SQLiteConnection connection = connectionsMap.get(connectionPtr);
-      if (connection == null) {
+    SQLiteConnection getConnection(final long connectionPtr) {
+      synchronized (lock) {
+        final SQLiteConnection connection = connectionsMap.get(connectionPtr);
+        if (connection == null) {
           throw new IllegalStateException(
               "Illegal connection pointer "
                   + connectionPtr
@@ -280,34 +279,34 @@ static class Connections {
                   + Thread.currentThread()
                   + " "
                   + connectionsMap.keySet());
+        }
+        return connection;
       }
-      return connection;
     }
-  }
 
-  SQLiteStatement getStatement(final long connectionPtr, final long statementPtr) {
-    synchronized (lock) {
-      // ensure connection is ok
-      getConnection(connectionPtr);
+    SQLiteStatement getStatement(final long connectionPtr, final long statementPtr) {
+      synchronized (lock) {
+        // ensure connection is ok
+        getConnection(connectionPtr);
 
-      final SQLiteStatement statement = statementsMap.get(statementPtr);
-      if (statement == null) {
+        final SQLiteStatement statement = statementsMap.get(statementPtr);
+        if (statement == null) {
           throw new IllegalArgumentException(
               "Invalid prepared statement pointer: "
                   + statementPtr
                   + ". Current pointers: "
                   + statementsMap.keySet());
-      }
-      if (statement.isDisposed()) {
+        }
+        if (statement.isDisposed()) {
           throw new IllegalStateException(
               "Statement " + statementPtr + " " + statement + " is disposed");
+        }
+        return statement;
       }
-      return statement;
     }
-  }
 
-  long open(final String path) {
-    synchronized (lock) {
+    long open(final String path) {
+      synchronized (lock) {
         final SQLiteConnection dbConnection =
             execute(
                 new Callable<SQLiteConnection>() {
@@ -323,21 +322,21 @@ static class Connections {
                   }
                 });
 
-      final long connectionPtr = pointerCounter.incrementAndGet();
-      connectionsMap.put(connectionPtr, dbConnection);
-      statementPtrsForConnection.put(connectionPtr, new ArrayList<>());
-      return connectionPtr;
+        final long connectionPtr = pointerCounter.incrementAndGet();
+        connectionsMap.put(connectionPtr, dbConnection);
+        statementPtrsForConnection.put(connectionPtr, new ArrayList<>());
+        return connectionPtr;
+      }
     }
-  }
 
-  long prepareStatement(final long connectionPtr, final String sql) {
-    // TODO: find a way to create collators
-    if ("REINDEX LOCALIZED".equals(sql)) {
-      return IGNORED_REINDEX_STMT;
-    }
+    long prepareStatement(final long connectionPtr, final String sql) {
+      // TODO: find a way to create collators
+      if ("REINDEX LOCALIZED".equals(sql)) {
+        return IGNORED_REINDEX_STMT;
+      }
 
-    synchronized (lock) {
-      final SQLiteConnection connection = getConnection(connectionPtr);
+      synchronized (lock) {
+        final SQLiteConnection connection = getConnection(connectionPtr);
         final SQLiteStatement statement =
             execute(
                 new Callable<SQLiteStatement>() {
@@ -347,85 +346,86 @@ static class Connections {
                   }
                 });
 
-      final long statementPtr = pointerCounter.incrementAndGet();
-      statementsMap.put(statementPtr, statement);
-      statementPtrsForConnection.get(connectionPtr).add(statementPtr);
-      return statementPtr;
+        final long statementPtr = pointerCounter.incrementAndGet();
+        statementsMap.put(statementPtr, statement);
+        statementPtrsForConnection.get(connectionPtr).add(statementPtr);
+        return statementPtr;
+      }
     }
-  }
 
-  void close(final long connectionPtr) {
-    synchronized (lock) {
-      final SQLiteConnection connection = getConnection(connectionPtr);
+    void close(final long connectionPtr) {
+      synchronized (lock) {
+        final SQLiteConnection connection = getConnection(connectionPtr);
         execute(
             () -> {
               connection.dispose();
               return null;
             });
-      connectionsMap.remove(connectionPtr);
-      statementPtrsForConnection.remove(connectionPtr);
+        connectionsMap.remove(connectionPtr);
+        statementPtrsForConnection.remove(connectionPtr);
+      }
     }
-  }
 
-  void reset() {
-    ExecutorService oldDbExecutor;
-    Collection<SQLiteConnection> openConnections;
+    void reset() {
+      ExecutorService oldDbExecutor;
+      Collection<SQLiteConnection> openConnections;
 
-    synchronized (lock) {
-      oldDbExecutor = dbExecutor;
-      openConnections = new ArrayList<>(connectionsMap.values());
+      synchronized (lock) {
+        oldDbExecutor = dbExecutor;
+        openConnections = new ArrayList<>(connectionsMap.values());
 
         dbExecutor = Executors.newSingleThreadExecutor(threadFactory());
-      connectionsMap.clear();
-      statementsMap.clear();
-      statementPtrsForConnection.clear();
-    }
+        connectionsMap.clear();
+        statementsMap.clear();
+        statementPtrsForConnection.clear();
+      }
 
-    shutdownDbExecutor(oldDbExecutor, openConnections);
-  }
+      shutdownDbExecutor(oldDbExecutor, openConnections);
+    }
 
-  private static void shutdownDbExecutor(ExecutorService executorService, Collection<SQLiteConnection> connections) {
-    for (final SQLiteConnection connection : connections) {
+    private static void shutdownDbExecutor(
+        ExecutorService executorService, Collection<SQLiteConnection> connections) {
+      for (final SQLiteConnection connection : connections) {
         getFuture(
             executorService.submit(
                 () -> {
                   connection.dispose();
                   return null;
                 }));
-    }
+      }
 
-    executorService.shutdown();
-    try {
-      executorService.awaitTermination(30, TimeUnit.SECONDS);
-    } catch (InterruptedException e) {
-      throw new RuntimeException(e);
+      executorService.shutdown();
+      try {
+        executorService.awaitTermination(30, TimeUnit.SECONDS);
+      } catch (InterruptedException e) {
+        throw new RuntimeException(e);
+      }
     }
-  }
 
-  void finalizeStmt(final long connectionPtr, final long statementPtr) {
-    if (statementPtr == IGNORED_REINDEX_STMT) {
-      return;
-    }
+    void finalizeStmt(final long connectionPtr, final long statementPtr) {
+      if (statementPtr == IGNORED_REINDEX_STMT) {
+        return;
+      }
 
-    synchronized (lock) {
-      final SQLiteStatement statement = getStatement(connectionPtr, statementPtr);
-      statementsMap.remove(statementPtr);
+      synchronized (lock) {
+        final SQLiteStatement statement = getStatement(connectionPtr, statementPtr);
+        statementsMap.remove(statementPtr);
 
         execute(
             () -> {
               statement.dispose();
               return null;
             });
+      }
     }
-  }
 
-  void cancel(final long connectionPtr) {
-    synchronized (lock) {
-      getConnection(connectionPtr); // check connection
+    void cancel(final long connectionPtr) {
+      synchronized (lock) {
+        getConnection(connectionPtr); // check connection
 
-      for (Long statementPtr : statementPtrsForConnection.get(connectionPtr)) {
-        final SQLiteStatement statement = statementsMap.get(statementPtr);
-        if (statement != null) {
+        for (Long statementPtr : statementPtrsForConnection.get(connectionPtr)) {
+          final SQLiteStatement statement = statementsMap.get(statementPtr);
+          if (statement != null) {
             execute(
                 new Callable<Void>() {
                   @Override
@@ -434,15 +434,15 @@ static class Connections {
                     return null;
                   }
                 });
+          }
         }
       }
     }
-  }
 
-  int getParameterCount(final long connectionPtr, final long statementPtr) {
-    if (statementPtr == IGNORED_REINDEX_STMT) {
-      return 0;
-    }
+    int getParameterCount(final long connectionPtr, final long statementPtr) {
+      if (statementPtr == IGNORED_REINDEX_STMT) {
+        return 0;
+      }
 
       return executeStatementOperation(
           connectionPtr,
@@ -453,13 +453,13 @@ static class Connections {
               return statement.getBindParameterCount();
             }
           });
-  }
-
-  boolean isReadOnly(final long connectionPtr, final long statementPtr) {
-    if (statementPtr == IGNORED_REINDEX_STMT) {
-      return true;
     }
 
+    boolean isReadOnly(final long connectionPtr, final long statementPtr) {
+      if (statementPtr == IGNORED_REINDEX_STMT) {
+        return true;
+      }
+
       return executeStatementOperation(
           connectionPtr,
           statementPtr,
@@ -469,9 +469,9 @@ static class Connections {
               return statement.isReadOnly();
             }
           });
-  }
+    }
 
-  long executeForLong(final long connectionPtr, final long statementPtr) {
+    long executeForLong(final long connectionPtr, final long statementPtr) {
       return executeStatementOperation(
           connectionPtr,
           statementPtr,
@@ -485,13 +485,13 @@ static class Connections {
               return statement.columnLong(0);
             }
           });
-  }
-
-  void executeStatement(final long connectionPtr, final long statementPtr) {
-    if (statementPtr == IGNORED_REINDEX_STMT) {
-      return;
     }
 
+    void executeStatement(final long connectionPtr, final long statementPtr) {
+      if (statementPtr == IGNORED_REINDEX_STMT) {
+        return;
+      }
+
       executeStatementOperation(
           connectionPtr,
           statementPtr,
@@ -502,9 +502,9 @@ static class Connections {
               return null;
             }
           });
-  }
+    }
 
-  String executeForString(final long connectionPtr, final long statementPtr) {
+    String executeForString(final long connectionPtr, final long statementPtr) {
       return executeStatementOperation(
           connectionPtr,
           statementPtr,
@@ -518,9 +518,9 @@ static class Connections {
               return statement.columnString(0);
             }
           });
-  }
+    }
 
-  int getColumnCount(final long connectionPtr, final long statementPtr) {
+    int getColumnCount(final long connectionPtr, final long statementPtr) {
       return executeStatementOperation(
           connectionPtr,
           statementPtr,
@@ -530,9 +530,9 @@ static class Connections {
               return statement.columnCount();
             }
           });
-  }
+    }
 
-  String getColumnName(final long connectionPtr, final long statementPtr, final int index) {
+    String getColumnName(final long connectionPtr, final long statementPtr, final int index) {
       return executeStatementOperation(
           connectionPtr,
           statementPtr,
@@ -542,9 +542,9 @@ static class Connections {
               return statement.getColumnName(index);
             }
           });
-  }
+    }
 
-  void bindNull(final long connectionPtr, final long statementPtr, final int index) {
+    void bindNull(final long connectionPtr, final long statementPtr, final int index) {
       executeStatementOperation(
           connectionPtr,
           statementPtr,
@@ -555,9 +555,10 @@ static class Connections {
               return null;
             }
           });
-  }
+    }
 
-  void bindLong(final long connectionPtr, final long statementPtr, final int index, final long value) {
+    void bindLong(
+        final long connectionPtr, final long statementPtr, final int index, final long value) {
       executeStatementOperation(
           connectionPtr,
           statementPtr,
@@ -568,9 +569,10 @@ static class Connections {
               return null;
             }
           });
-  }
+    }
 
-  void bindDouble(final long connectionPtr, final long statementPtr, final int index, final double value) {
+    void bindDouble(
+        final long connectionPtr, final long statementPtr, final int index, final double value) {
       executeStatementOperation(
           connectionPtr,
           statementPtr,
@@ -581,9 +583,10 @@ static class Connections {
               return null;
             }
           });
-  }
+    }
 
-  void bindString(final long connectionPtr, final long statementPtr, final int index, final String value) {
+    void bindString(
+        final long connectionPtr, final long statementPtr, final int index, final String value) {
       executeStatementOperation(
           connectionPtr,
           statementPtr,
@@ -594,9 +597,10 @@ static class Connections {
               return null;
             }
           });
-  }
+    }
 
-  void bindBlob(final long connectionPtr, final long statementPtr, final int index, final byte[] value) {
+    void bindBlob(
+        final long connectionPtr, final long statementPtr, final int index, final byte[] value) {
       executeStatementOperation(
           connectionPtr,
           statementPtr,
@@ -607,12 +611,12 @@ static class Connections {
               return null;
             }
           });
-  }
+    }
 
-  int executeForChangedRowCount(final long connectionPtr, final long statementPtr) {
-    synchronized (lock) {
-      final SQLiteConnection connection = getConnection(connectionPtr);
-      final SQLiteStatement statement = getStatement(connectionPtr, statementPtr);
+    int executeForChangedRowCount(final long connectionPtr, final long statementPtr) {
+      synchronized (lock) {
+        final SQLiteConnection connection = getConnection(connectionPtr);
+        final SQLiteStatement statement = getStatement(connectionPtr, statementPtr);
 
         return execute(
             new Callable<Integer>() {
@@ -626,13 +630,13 @@ static class Connections {
                 return connection.getChanges();
               }
             });
+      }
     }
-  }
 
-  long executeForLastInsertedRowId(final long connectionPtr, final long statementPtr) {
-    synchronized (lock) {
-      final SQLiteConnection connection = getConnection(connectionPtr);
-      final SQLiteStatement statement = getStatement(connectionPtr, statementPtr);
+    long executeForLastInsertedRowId(final long connectionPtr, final long statementPtr) {
+      synchronized (lock) {
+        final SQLiteConnection connection = getConnection(connectionPtr);
+        final SQLiteStatement statement = getStatement(connectionPtr, statementPtr);
 
         return execute(
             new Callable<Long>() {
@@ -642,10 +646,11 @@ static class Connections {
                 return connection.getChanges() > 0 ? connection.getLastInsertId() : -1L;
               }
             });
+      }
     }
-  }
 
-  long executeForCursorWindow(final long connectionPtr, final long statementPtr, final long windowPtr) {
+    long executeForCursorWindow(
+        final long connectionPtr, final long statementPtr, final long windowPtr) {
       return executeStatementOperation(
           connectionPtr,
           statementPtr,
@@ -655,9 +660,9 @@ static class Connections {
               return ShadowLegacyCursorWindow.setData(windowPtr, statement);
             }
           });
-  }
+    }
 
-  void resetStatementAndClearBindings(final long connectionPtr, final long statementPtr) {
+    void resetStatementAndClearBindings(final long connectionPtr, final long statementPtr) {
       executeStatementOperation(
           connectionPtr,
           statementPtr,
@@ -668,18 +673,18 @@ static class Connections {
               return null;
             }
           });
-  }
+    }
 
-  interface StatementOperation<T> {
-    T call(final SQLiteStatement statement) throws Exception;
-  }
+    interface StatementOperation<T> {
+      T call(final SQLiteStatement statement) throws Exception;
+    }
 
     private <T> T executeStatementOperation(
         final long connectionPtr,
         final long statementPtr,
         final StatementOperation<T> statementOperation) {
-    synchronized (lock) {
-      final SQLiteStatement statement = getStatement(connectionPtr, statementPtr);
+      synchronized (lock) {
+        final SQLiteStatement statement = getStatement(connectionPtr, statementPtr);
         return execute(
             () -> {
               return statementOperation.call(statement);
@@ -692,7 +697,7 @@ static class Connections {
      * deadlock
      */
     private <T> T execute(final Callable<T> work) {
-    synchronized (lock) {
+      synchronized (lock) {
         return PerfStatsCollector.getInstance()
             .measure("sqlite", () -> getFuture(dbExecutor.submit(work)));
       }
@@ -825,27 +830,45 @@ static class Connections {
       String message = fullMessage.toString();
       // Mapping is from throw_sqlite3_exception in android_database_SQLiteCommon.cpp
       switch (baseErrorCode) {
-      case SQLiteConstants.SQLITE_ABORT: return new SQLiteAbortException(message);
-      case SQLiteConstants.SQLITE_PERM: return new SQLiteAccessPermException(message);
-      case SQLiteConstants.SQLITE_RANGE: return new SQLiteBindOrColumnIndexOutOfRangeException(message);
-      case SQLiteConstants.SQLITE_TOOBIG: return new SQLiteBlobTooBigException(message);
-      case SQLiteConstants.SQLITE_CANTOPEN: return new SQLiteCantOpenDatabaseException(message);
-      case SQLiteConstants.SQLITE_CONSTRAINT: return new SQLiteConstraintException(message);
-      case SQLiteConstants.SQLITE_NOTADB: // fall through
-      case SQLiteConstants.SQLITE_CORRUPT: return new SQLiteDatabaseCorruptException(message);
-      case SQLiteConstants.SQLITE_BUSY: return new SQLiteDatabaseLockedException(message);
-      case SQLiteConstants.SQLITE_MISMATCH: return new SQLiteDatatypeMismatchException(message);
-      case SQLiteConstants.SQLITE_IOERR: return new SQLiteDiskIOException(message);
-      case SQLiteConstants.SQLITE_DONE: return new SQLiteDoneException(message);
-      case SQLiteConstants.SQLITE_FULL: return new SQLiteFullException(message);
-      case SQLiteConstants.SQLITE_MISUSE: return new SQLiteMisuseException(message);
-      case SQLiteConstants.SQLITE_NOMEM: return new SQLiteOutOfMemoryException(message);
-      case SQLiteConstants.SQLITE_READONLY: return new SQLiteReadOnlyDatabaseException(message);
-      case SQLiteConstants.SQLITE_LOCKED: return new SQLiteTableLockedException(message);
-      case SQLiteConstants.SQLITE_INTERRUPT: return new OperationCanceledException(message);
-      default: return new android.database.sqlite.SQLiteException(message
-          + ", base error code: " + baseErrorCode);
+        case SQLiteConstants.SQLITE_ABORT:
+          return new SQLiteAbortException(message);
+        case SQLiteConstants.SQLITE_PERM:
+          return new SQLiteAccessPermException(message);
+        case SQLiteConstants.SQLITE_RANGE:
+          return new SQLiteBindOrColumnIndexOutOfRangeException(message);
+        case SQLiteConstants.SQLITE_TOOBIG:
+          return new SQLiteBlobTooBigException(message);
+        case SQLiteConstants.SQLITE_CANTOPEN:
+          return new SQLiteCantOpenDatabaseException(message);
+        case SQLiteConstants.SQLITE_CONSTRAINT:
+          return new SQLiteConstraintException(message);
+        case SQLiteConstants.SQLITE_NOTADB: // fall through
+        case SQLiteConstants.SQLITE_CORRUPT:
+          return new SQLiteDatabaseCorruptException(message);
+        case SQLiteConstants.SQLITE_BUSY:
+          return new SQLiteDatabaseLockedException(message);
+        case SQLiteConstants.SQLITE_MISMATCH:
+          return new SQLiteDatatypeMismatchException(message);
+        case SQLiteConstants.SQLITE_IOERR:
+          return new SQLiteDiskIOException(message);
+        case SQLiteConstants.SQLITE_DONE:
+          return new SQLiteDoneException(message);
+        case SQLiteConstants.SQLITE_FULL:
+          return new SQLiteFullException(message);
+        case SQLiteConstants.SQLITE_MISUSE:
+          return new SQLiteMisuseException(message);
+        case SQLiteConstants.SQLITE_NOMEM:
+          return new SQLiteOutOfMemoryException(message);
+        case SQLiteConstants.SQLITE_READONLY:
+          return new SQLiteReadOnlyDatabaseException(message);
+        case SQLiteConstants.SQLITE_LOCKED:
+          return new SQLiteTableLockedException(message);
+        case SQLiteConstants.SQLITE_INTERRUPT:
+          return new OperationCanceledException(message);
+        default:
+          return new android.database.sqlite.SQLiteException(
+              message + ", base error code: " + baseErrorCode);
+      }
     }
   }
 }
-}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyTypeface.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyTypeface.java
index cec7d881a..bb9cc1264 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyTypeface.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyTypeface.java
@@ -1,7 +1,5 @@
 package org.robolectric.shadows;
 
-
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.N_MR1;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.O_MR1;
@@ -9,7 +7,6 @@ import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
-import static org.robolectric.RuntimeEnvironment.getApiLevel;
 import static org.robolectric.Shadows.shadowOf;
 
 import android.annotation.SuppressLint;
@@ -31,6 +28,7 @@ import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.InDevelopment;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.res.Fs;
@@ -39,6 +37,7 @@ import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.versioning.AndroidVersions.T;
 import org.robolectric.versioning.AndroidVersions.U;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow for {@link Typeface}. */
 @Implements(value = Typeface.class, looseSignatures = true, isInAndroidSdk = false)
@@ -55,10 +54,17 @@ public class ShadowLegacyTypeface extends ShadowTypeface {
   }
 
   @Implementation(minSdk = U.SDK_INT)
+  @InDevelopment
   protected void __constructor__(long fontId, String familyName) {
     description = findById(fontId);
   }
 
+  @Implementation(minSdk = V.SDK_INT)
+  @InDevelopment
+  protected void __constructor__(long fontId, String familyName, Typeface derivedFrom) {
+    description = findById(fontId);
+  }
+
   @Implementation
   protected static void __staticInitializer__() {
     Shadow.directInitialize(Typeface.class);
@@ -215,13 +221,8 @@ public class ShadowLegacyTypeface extends ShadowTypeface {
   protected static Typeface createUnderlyingTypeface(String familyName, int style) {
     long thisFontId = nextFontId.getAndIncrement();
     FONTS.put(thisFontId, new FontDesc(familyName, style));
-    if (getApiLevel() >= LOLLIPOP) {
-      return ReflectionHelpers.callConstructor(
-          Typeface.class, ClassParameter.from(long.class, thisFontId));
-    } else {
-      return ReflectionHelpers.callConstructor(
-          Typeface.class, ClassParameter.from(int.class, (int) thisFontId));
-    }
+    return ReflectionHelpers.callConstructor(
+        Typeface.class, ClassParameter.from(long.class, thisFontId));
   }
 
   private static synchronized FontDesc findById(long fontId) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocaleData.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocaleData.java
index 668ca53d2..2dc49ff3d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocaleData.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocaleData.java
@@ -113,7 +113,7 @@ public class ShadowLocaleData {
       // Lollipop MR1 uses a String
       localDataReflector.setPercent("%");
     } else {
-      // Upto Lollipop was a char
+      // Lollipop was a char
       localDataReflector.setPercent('%');
     }
 
@@ -267,4 +267,3 @@ public class ShadowLocaleData {
     void setPercentPattern(String symbol);
   }
 }
-
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java
index b27bd96d7..dfad4ac83 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java
@@ -924,9 +924,9 @@ public class ShadowLocationManager {
 
   /**
    * Returns the list of {@link RoboLocationRequest} currently registered under the given provider.
-   * Since {@link LocationRequest} was not publicly visible prior to S, and did not exist prior to
-   * Kitkat, {@link RoboLocationRequest} allows querying the location requests prior to those
-   * platforms, and also implements proper equality comparisons for testing.
+   * Since {@link LocationRequest} was not publicly visible prior to S, {@link RoboLocationRequest}
+   * allows querying the location requests prior to those platforms, and also implements proper
+   * equality comparisons for testing.
    */
   public List<RoboLocationRequest> getLegacyLocationRequests(String provider) {
     ProviderEntry providerEntry = getProviderEntry(provider);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLog.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLog.java
index b71d462b3..a27c6890a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLog.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLog.java
@@ -35,11 +35,11 @@ public class ShadowLog {
 
   private static final int EXTRA_LOG_LENGTH = "l/: \n".length();
 
-  private static final Map<String, Queue<LogItem>> logsByTag = Collections.synchronizedMap(new
-      HashMap<String, Queue<LogItem>>());
+  private static final Map<String, Queue<LogItem>> logsByTag =
+      Collections.synchronizedMap(new HashMap<String, Queue<LogItem>>());
   private static final Queue<LogItem> logs = new ConcurrentLinkedQueue<>();
-  private static final Map<String, Integer> tagToLevel = Collections.synchronizedMap(new
-      HashMap<String, Integer>());
+  private static final Map<String, Integer> tagToLevel =
+      Collections.synchronizedMap(new HashMap<String, Integer>());
 
   /**
    * Whether calling {@link Log#wtf} will throw {@link TerribleFailure}. This is analogous to
@@ -160,6 +160,7 @@ public class ShadowLog {
 
   /**
    * Sets the log level of a given tag, that {@link #isLoggable} will follow.
+   *
    * @param tag A log tag
    * @param level A log level, from {@link android.util.Log}
    */
@@ -198,13 +199,26 @@ public class ShadowLog {
   protected static char levelToChar(int level) {
     final char c;
     switch (level) {
-      case Log.ASSERT: c = 'A'; break;
-      case Log.DEBUG:  c = 'D'; break;
-      case Log.ERROR:  c = 'E'; break;
-      case Log.WARN:   c = 'W'; break;
-      case Log.INFO:   c = 'I'; break;
-      case Log.VERBOSE:c = 'V'; break;
-      default:         c = '?';
+      case Log.ASSERT:
+        c = 'A';
+        break;
+      case Log.DEBUG:
+        c = 'D';
+        break;
+      case Log.ERROR:
+        c = 'E';
+        break;
+      case Log.WARN:
+        c = 'W';
+        break;
+      case Log.INFO:
+        c = 'I';
+        break;
+      case Log.VERBOSE:
+        c = 'V';
+        break;
+      default:
+        c = '?';
     }
     return c;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLooper.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLooper.java
index 71f65f26e..dde258635 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLooper.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLooper.java
@@ -41,7 +41,9 @@ public abstract class ShadowLooper {
     return Shadow.extract(looper);
   }
 
-  /** @deprecated Use {@code shadowOf({@link Looper#getMainLooper()})} instead. */
+  /**
+   * @deprecated Use {@code shadowOf({@link Looper#getMainLooper()})} instead.
+   */
   @Deprecated
   public static ShadowLooper getShadowMainLooper() {
     return shadowLooper(getMainLooper());
@@ -147,7 +149,9 @@ public abstract class ShadowLooper {
     getShadowMainLooper().idle();
   }
 
-  /** @deprecated Use {@link #idleMainLooper(long, TimeUnit)}. */
+  /**
+   * @deprecated Use {@link #idleMainLooper(long, TimeUnit)}.
+   */
   @InlineMe(
       replacement = "ShadowLooper.idleMainLooper(interval, MILLISECONDS)",
       imports = "org.robolectric.shadows.ShadowLooper",
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMatrix.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMatrix.java
index 62b702107..5e156502d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMatrix.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMatrix.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-
 import android.graphics.Matrix;
 import java.util.List;
 import java.util.Map;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodec.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodec.java
index 4bcc972dd..d3e75330c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodec.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodec.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.N_MR1;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
@@ -98,6 +97,7 @@ public class ShadowMediaCodec {
 
   @Nullable private MediaFormat pendingOutputFormat;
   @Nullable private MediaFormat outputFormat;
+  @Nullable private MediaFormat inputFormat;
   @Nullable private String[] initialPendingOutputFormatKeys;
   @Nullable private Object[] initialPendingOutputFormatValues;
 
@@ -184,6 +184,7 @@ public class ShadowMediaCodec {
       int flags) {
     isAsync = callback != null;
     pendingOutputFormat = recreateMediaFormatFromKeysValues(keys, values);
+    inputFormat = recreateMediaFormatFromKeysValues(keys, values);
     initialPendingOutputFormatKeys = keys;
     initialPendingOutputFormatValues = values;
     fakeCodec.onConfigured(pendingOutputFormat, surface, mediaCrypto, flags);
@@ -477,7 +478,7 @@ public class ShadowMediaCodec {
   protected void freeByteBufferLocked(@Nullable ByteBuffer buffer) {}
 
   /** Shadows CodecBuffer to prevent attempting to free non-direct ByteBuffer objects. */
-  @Implements(className = "android.media.MediaCodec$BufferMap$CodecBuffer", minSdk = LOLLIPOP)
+  @Implements(className = "android.media.MediaCodec$BufferMap$CodecBuffer")
   protected static class ShadowCodecBuffer {
 
     // Seems to be required to work.
@@ -492,13 +493,26 @@ public class ShadowMediaCodec {
     protected void free() {}
   }
 
-  /** Returns a default {@link MediaFormat} if not set via {@link #getOutputFormat()}. */
+  /**
+   * Returns {@link MediaFormat} set as output format via {@link MediaCodec#configure}.
+   *
+   * @throws IllegalStateException if not in configured state.
+   */
   @Implementation
   protected MediaFormat getOutputFormat() {
-    if (outputFormat == null) {
-      return new MediaFormat();
-    }
-    return outputFormat;
+    checkState(pendingOutputFormat != null || outputFormat != null, "Codec is not configured.");
+    return pendingOutputFormat != null ? pendingOutputFormat : outputFormat;
+  }
+
+  /**
+   * Returns {@link MediaFormat} set as input format via {@link MediaCodec#configure}.
+   *
+   * @throws IllegalStateException if not in configured state.
+   */
+  @Implementation
+  protected MediaFormat getInputFormat() {
+    checkState(inputFormat != null, "Codec is not configured.");
+    return inputFormat;
   }
 
   private static void copyBufferInfo(BufferInfo from, BufferInfo to) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodecList.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodecList.java
index d16fd12e4..ad3634c81 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodecList.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodecList.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.Q;
 
@@ -23,7 +22,7 @@ import org.robolectric.util.ReflectionHelpers;
  * <p>Custom {@link MediaCodecInfo} can be created using {@link MediaCodecInfoBuilder} and added to
  * the list of codecs via {@link #addCodec}.
  */
-@Implements(value = MediaCodecList.class, minSdk = LOLLIPOP)
+@Implements(value = MediaCodecList.class)
 public class ShadowMediaCodecList {
 
   private static final List<MediaCodecInfo> mediaCodecInfos =
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaController.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaController.java
index 252bc427d..1c139b09a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaController.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaController.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.annotation.NonNull;
@@ -25,7 +24,7 @@ import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 
 /** Implementation of {@link android.media.session.MediaController}. */
-@Implements(value = MediaController.class, minSdk = LOLLIPOP)
+@Implements(value = MediaController.class)
 public class ShadowMediaController {
   @RealObject private MediaController realMediaController;
   private PlaybackState playbackState;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaMuxer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaMuxer.java
index ee0bdff35..aa2793097 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaMuxer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaMuxer.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.O;
 
 import android.annotation.NonNull;
@@ -25,7 +24,7 @@ import org.robolectric.util.ReflectionHelpers;
  * Implementation of {@link android.media.MediaMuxer} which directly passes input bytes to the
  * specified file, with no modification.
  */
-@Implements(value = MediaMuxer.class, minSdk = LOLLIPOP)
+@Implements(value = MediaMuxer.class)
 public class ShadowMediaMuxer {
   // Maps between 'native' ids and corresponding output streams.
   private static final ConcurrentHashMap<Long, FileOutputStream> outputStreams =
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaPlayer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaPlayer.java
index 8a6926c63..cc83a7f63 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaPlayer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaPlayer.java
@@ -5,6 +5,7 @@ import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.N_MR1;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.P;
+import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static org.robolectric.shadows.ShadowMediaPlayer.State.END;
 import static org.robolectric.shadows.ShadowMediaPlayer.State.ERROR;
 import static org.robolectric.shadows.ShadowMediaPlayer.State.IDLE;
@@ -17,8 +18,10 @@ import static org.robolectric.shadows.ShadowMediaPlayer.State.STARTED;
 import static org.robolectric.shadows.ShadowMediaPlayer.State.STOPPED;
 import static org.robolectric.shadows.util.DataSource.toDataSource;
 
+import android.annotation.NonNull;
 import android.content.Context;
 import android.content.res.AssetFileDescriptor;
+import android.media.AudioAttributes;
 import android.media.MediaDataSource;
 import android.media.MediaPlayer;
 import android.net.Uri;
@@ -45,6 +48,8 @@ import org.robolectric.annotation.RealObject;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.util.DataSource;
+import org.robolectric.util.ReflectionHelpers.ClassParameter;
+import org.robolectric.versioning.AndroidVersions.U;
 
 /**
  * Automated testing of media playback can be a difficult thing - especially testing that your code
@@ -402,6 +407,7 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
   private int audioStreamType;
   private boolean looping;
   private int pendingSeek = -1;
+
   /** Various source variables from setDataSource() */
   private Uri sourceUri;
 
@@ -434,7 +440,11 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
    * Flag indicating how the shadow media player should behave when a method is invoked in an
    * invalid state.
    */
-  private InvalidStateBehavior invalidStateBehavior = InvalidStateBehavior.SILENT;
+  private InvalidStateBehavior invalidStateBehavior =
+      InvalidStateBehavior.valueOf(
+          System.getProperty(
+              "robolectric.shadowMediaPlayer.invalidStateBehavior",
+              InvalidStateBehavior.SILENT.toString()));
 
   private Handler handler;
 
@@ -522,7 +532,35 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
   }
 
   @Implementation
+  protected static MediaPlayer create(
+      Context context, int resId, AudioAttributes audioAttributes, int audioSessionId) {
+    MediaPlayer mp = ShadowMediaPlayer.create(context, resId);
+    if (mp != null) {
+      ShadowMediaPlayer shadow = Shadow.extract(mp);
+      shadow.audioSessionId = audioSessionId;
+    }
+    return mp;
+  }
+
+  @Implementation(maxSdk = TIRAMISU)
   protected void __constructor__() {
+    init();
+    // Ensure that the real object is set up properly.
+    Shadow.invokeConstructor(MediaPlayer.class, player);
+  }
+
+  @Implementation(minSdk = U.SDK_INT)
+  protected void __constructor__(@NonNull Context context, int sessionId) {
+    init();
+    // Ensure that the real object is set up properly.
+    Shadow.invokeConstructor(
+        MediaPlayer.class,
+        player,
+        ClassParameter.from(Context.class, context),
+        ClassParameter.from(int.class, sessionId));
+  }
+
+  private void init() {
     // Contract of audioSessionId is that if it is 0 (which represents
     // the master mix) then that's an error. By default it generates
     // an ID that is unique system-wide. We could simulate guaranteed
@@ -542,8 +580,6 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
     if (createListener != null) {
       createListener.onCreate(player, this);
     }
-    // Ensure that the real object is set up properly.
-    Shadow.invokeConstructor(MediaPlayer.class, player);
   }
 
   private Handler getHandler(Looper looper) {
@@ -668,9 +704,7 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
     return mediaInfoProvider.map(provider -> provider.get(dataSource)).orElse(null);
   }
 
-  /**
-   * Adds a {@link MediaInfo} for a {@link DataSource}.
-   */
+  /** Adds a {@link MediaInfo} for a {@link DataSource}. */
   public static void addMediaInfo(DataSource dataSource, MediaInfo info) {
     mediaInfoMap.put(dataSource, info);
   }
@@ -1074,7 +1108,7 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
    */
   @Implementation
   protected int getCurrentPosition() {
-    checkStateError("getCurrentPosition()", attachableStates);
+    checkStateError("getCurrentPosition()", nonErrorStates);
     return getCurrentPositionRaw();
   }
 
@@ -1093,13 +1127,13 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
 
   @Implementation
   protected int getVideoHeight() {
-    checkStateLog("getVideoHeight()", attachableStates);
+    checkStateLog("getVideoHeight()", nonErrorStates);
     return videoHeight;
   }
 
   @Implementation
   protected int getVideoWidth() {
-    checkStateLog("getVideoWidth()", attachableStates);
+    checkStateLog("getVideoWidth()", nonErrorStates);
     return videoWidth;
   }
 
@@ -1340,7 +1374,9 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
     return audioStreamType;
   }
 
-  /** @return seekDelay */
+  /**
+   * @return seekDelay
+   */
   public int getSeekDelay() {
     return seekDelay;
   }
@@ -1417,7 +1453,9 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
     return leftVolume;
   }
 
-  /** @return The right channel volume. */
+  /**
+   * @return The right channel volume.
+   */
   public float getRightVolume() {
     return rightVolume;
   }
@@ -1440,12 +1478,16 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
     return preparedStates.contains(state);
   }
 
-  /** @return the OnCompletionListener */
+  /**
+   * @return the OnCompletionListener
+   */
   public MediaPlayer.OnCompletionListener getOnCompletionListener() {
     return completionListener;
   }
 
-  /** @return the OnPreparedListener */
+  /**
+   * @return the OnPreparedListener
+   */
   public MediaPlayer.OnPreparedListener getOnPreparedListener() {
     return preparedListener;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaRecorder.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaRecorder.java
index 58b035ceb..f9da0d05c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaRecorder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaRecorder.java
@@ -201,7 +201,7 @@ public class ShadowMediaRecorder {
         "getSurface must be called after prepare() and before stop()");
 
     if (recordingSurface == null) {
-      recordingSurfaceTexture = new SurfaceTexture(/*texName=*/ 0);
+      recordingSurfaceTexture = new SurfaceTexture(/* texName= */ 0);
       recordingSurface = new Surface(recordingSurfaceTexture);
     }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaSession.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaSession.java
index cbe683f29..9e5ea3546 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaSession.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaSession.java
@@ -1,13 +1,11 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
-
 import android.content.Context;
 import android.media.session.MediaSession;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
-@Implements(value = MediaSession.class, minSdk = LOLLIPOP)
+@Implements(value = MediaSession.class)
 public class ShadowMediaSession {
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaSessionManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaSessionManager.java
index 1e634d46c..c16bf6fb5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaSessionManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaSessionManager.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.S;
 import static org.robolectric.util.ReflectionHelpers.createDeepProxy;
 import static org.robolectric.util.reflector.Reflector.reflector;
@@ -24,7 +23,7 @@ import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
 
 /** Shadow for {@link MediaSessionManager}. */
-@Implements(value = MediaSessionManager.class, minSdk = LOLLIPOP)
+@Implements(value = MediaSessionManager.class)
 public class ShadowMediaSessionManager {
   private final List<MediaController> controllers = new CopyOnWriteArrayList<>();
   private final Set<OnActiveSessionsChangedListener> listeners = new CopyOnWriteArraySet<>();
@@ -78,10 +77,14 @@ public class ShadowMediaSessionManager {
 
   /**
    * Clears all controllers such that {@link #getActiveSessions(ComponentName)} will return the
-   * empty list.
+   * empty list. This will trigger a callback on each {@link OnActiveSessionsChangedListener}
+   * callback registered with this class.
    */
   public void clearControllers() {
     controllers.clear();
+    for (OnActiveSessionsChangedListener listener : listeners) {
+      listener.onActiveSessionsChanged(controllers);
+    }
   }
 
   @ForType(MediaSessionManager.class)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMemoryMappedFile.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMemoryMappedFile.java
index 98421b076..a8f824c29 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMemoryMappedFile.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMemoryMappedFile.java
@@ -1,8 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
-import static org.robolectric.RuntimeEnvironment.getApiLevel;
-
 import android.system.ErrnoException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -33,7 +30,7 @@ public class ShadowMemoryMappedFile {
       InputStream is = MemoryMappedFile.class.getResourceAsStream(TZ_DATA_2);
       if (is == null) {
         throw (Throwable)
-            exceptionClass().getConstructor(String.class, int.class).newInstance("open", -1);
+            ErrnoException.class.getConstructor(String.class, int.class).newInstance("open", -1);
       }
       try {
         MemoryMappedFile memoryMappedFile = new MemoryMappedFile(0L, 0L);
@@ -42,7 +39,7 @@ public class ShadowMemoryMappedFile {
         return memoryMappedFile;
       } catch (IOException e) {
         throw (Throwable)
-            exceptionClass()
+            ErrnoException.class
                 .getConstructor(String.class, int.class, Throwable.class)
                 .newInstance("mmap", -1, e);
       }
@@ -51,18 +48,6 @@ public class ShadowMemoryMappedFile {
     }
   }
 
-  private static Class exceptionClass() {
-    if (getApiLevel() >= LOLLIPOP) {
-      return ErrnoException.class;
-    } else {
-      try {
-        return MemoryMappedFile.class.getClassLoader().loadClass("libcore.io.ErrnoException");
-      } catch (ClassNotFoundException e) {
-        throw new RuntimeException(e);
-      }
-    }
-  }
-
   @Implementation
   public synchronized void close() throws Exception {
     bytes = null;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMessage.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMessage.java
index 09b7ce178..ac63bd91b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMessage.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMessage.java
@@ -64,10 +64,7 @@ public abstract class ShadowMessage {
    */
   public abstract void setNext(Message next);
 
-  /**
-   * Resets the static state of the {@link Message} class by
-   * emptying the message pool.
-   */
+  /** Resets the static state of the {@link Message} class by emptying the message pool. */
   @Resetter
   public static void reset() {
     Object lock = reflector(MessageReflector.class).getPoolSync();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMimeTypeMap.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMimeTypeMap.java
index a2c9f4058..572cb9019 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMimeTypeMap.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMimeTypeMap.java
@@ -38,16 +38,14 @@ public class ShadowMimeTypeMap {
 
   @Implementation
   protected String getMimeTypeFromExtension(String extension) {
-    if (extensionToMimeTypeMap.containsKey(extension))
-      return extensionToMimeTypeMap.get(extension);
+    if (extensionToMimeTypeMap.containsKey(extension)) return extensionToMimeTypeMap.get(extension);
 
     return null;
   }
 
   @Implementation
   protected String getExtensionFromMimeType(String mimeType) {
-    if (mimeTypeToExtensionMap.containsKey(mimeType))
-      return mimeTypeToExtensionMap.get(mimeType);
+    if (mimeTypeToExtensionMap.containsKey(mimeType)) return mimeTypeToExtensionMap.get(mimeType);
 
     return null;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAllocationRegistry.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAllocationRegistry.java
index e7018f36c..e3a9aaad8 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAllocationRegistry.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAllocationRegistry.java
@@ -1,18 +1,22 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.O;
+import static org.robolectric.shadow.api.Shadow.invokeConstructor;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import libcore.util.NativeAllocationRegistry;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.InDevelopment;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.nativeruntime.NativeAllocationRegistryNatives;
 import org.robolectric.shadows.ShadowNativeAllocationRegistry.Picker;
+import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.versioning.AndroidVersions.U;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow for {@link NativeAllocationRegistry} that is backed by native code */
 @Implements(
@@ -25,6 +29,32 @@ public class ShadowNativeAllocationRegistry {
 
   @RealObject protected NativeAllocationRegistry realNativeAllocationRegistry;
 
+  /**
+   * The newly introduced constructor (in version V) now performs a null check on the classLoader
+   * argument. We intercept the constructor calls so as to pass a non-null classloader. The
+   * classloader would be Robolectric's SandboxClassloader, but the value itself does not affect the
+   * behavior of actual class.
+   */
+  @InDevelopment
+  @Implementation(minSdk = V.SDK_INT)
+  protected void __constructor__(
+      ClassLoader classLoader,
+      Class clazz,
+      long freeFunction,
+      long size,
+      boolean mallocAllocation) {
+    ClassLoader loader =
+        (classLoader == null) ? Thread.currentThread().getContextClassLoader() : classLoader;
+    invokeConstructor(
+        NativeAllocationRegistry.class,
+        realNativeAllocationRegistry,
+        ClassParameter.from(ClassLoader.class, loader),
+        ClassParameter.from(Class.class, clazz),
+        ClassParameter.from(long.class, freeFunction),
+        ClassParameter.from(long.class, size),
+        ClassParameter.from(boolean.class, mallocAllocation));
+  }
+
   @Implementation
   protected Runnable registerNativeAllocation(Object referent, long nativePtr) {
     // Avoid registering native allocations for classes where native methods are no-ops (like
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeApkAssets.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeApkAssets.java
new file mode 100644
index 000000000..c09281f0a
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeApkAssets.java
@@ -0,0 +1,37 @@
+package org.robolectric.shadows;
+
+import static org.robolectric.shadows.ShadowArscApkAssets9.FRAMEWORK_APK_PATH;
+
+import android.content.res.ApkAssets;
+import android.content.res.loader.AssetsProvider;
+import java.io.IOException;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadow.api.Shadow;
+import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.util.ReflectionHelpers.ClassParameter;
+import org.robolectric.versioning.AndroidVersions.V;
+
+@Implements(
+    value = ApkAssets.class,
+    minSdk = V.SDK_INT,
+    callNativeMethodsByDefault = true,
+    shadowPicker = ShadowApkAssets.Picker.class,
+    isInAndroidSdk = false)
+public class ShadowNativeApkAssets extends ShadowApkAssets {
+  @Implementation
+  protected static long nativeLoad(int format, String path, int flags, AssetsProvider asset)
+      throws IOException {
+    if (path.equals(FRAMEWORK_APK_PATH)) {
+      path = RuntimeEnvironment.getAndroidFrameworkJarPath().toString();
+    }
+    return ReflectionHelpers.callStaticMethod(
+        ApkAssets.class,
+        Shadow.directNativeMethodName(ApkAssets.class.getName(), "nativeLoad"),
+        ClassParameter.from(int.class, format),
+        ClassParameter.from(String.class, path),
+        ClassParameter.from(int.class, flags),
+        ClassParameter.from(AssetsProvider.class, asset));
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAssetManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAssetManager.java
new file mode 100644
index 000000000..2e9959dcb
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAssetManager.java
@@ -0,0 +1,25 @@
+package org.robolectric.shadows;
+
+import android.content.res.AssetManager;
+import java.nio.file.Path;
+import java.util.Collection;
+import org.robolectric.annotation.Implements;
+import org.robolectric.versioning.AndroidVersions.V;
+
+@Implements(
+    value = AssetManager.class,
+    minSdk = V.SDK_INT,
+    callNativeMethodsByDefault = true,
+    shadowPicker = ShadowAssetManager.Picker.class)
+public class ShadowNativeAssetManager extends ShadowAssetManager {
+
+  @Override
+  Collection<Path> getAllAssetDirs() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  long getNativePtr() {
+    throw new UnsupportedOperationException();
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeBitmap.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeBitmap.java
index 7f5377ffb..4ab416812 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeBitmap.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeBitmap.java
@@ -23,6 +23,7 @@ import java.nio.Buffer;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -35,6 +36,7 @@ import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Static;
 import org.robolectric.versioning.AndroidVersions.U;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow for {@link Bitmap} that is backed by native code */
 @Implements(
@@ -362,6 +364,9 @@ public class ShadowNativeBitmap extends ShadowBitmap {
 
     @Accessor("sNamedColorSpaces")
     ColorSpace[] getNamedColorSpaces();
+
+    @Accessor("sNamedColorSpaceMap")
+    Map<Integer, ColorSpace> getNamedColorSpaceMap();
   }
 
   @Implementation
@@ -409,7 +414,19 @@ public class ShadowNativeBitmap extends ShadowBitmap {
     boolean hasColorSpace = p.readBoolean();
     if (hasColorSpace) {
       String colorSpaceName = p.readString();
-      ColorSpace[] namedColorSpaces = reflector(ColorSpaceReflector.class).getNamedColorSpaces();
+      ColorSpace[] namedColorSpaces;
+      if (RuntimeEnvironment.getApiLevel() >= V.SDK_INT) {
+        // Starting Android V, we need to access the color space map to get all supported color
+        // spaces.
+        Map<Integer, ColorSpace> namedColorSpaceMap =
+            reflector(ColorSpaceReflector.class).getNamedColorSpaceMap();
+        namedColorSpaces =
+            namedColorSpaceMap.values().toArray(new ColorSpace[namedColorSpaceMap.size()]);
+      } else {
+        // Before V, we directly access the color space array.
+        namedColorSpaces = reflector(ColorSpaceReflector.class).getNamedColorSpaces();
+      }
+
       for (ColorSpace named : namedColorSpaces) {
         if (named.getName().equals(colorSpaceName)) {
           colorSpace = named;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeCursorWindow.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeCursorWindow.java
index 6b018f38a..860df90d6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeCursorWindow.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeCursorWindow.java
@@ -1,6 +1,6 @@
 package org.robolectric.shadows;
 
-
+import static org.robolectric.RuntimeEnvironment.getApiLevel;
 
 import android.database.CharArrayBuffer;
 import android.database.CursorWindow;
@@ -9,6 +9,9 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.nativeruntime.CursorWindowNatives;
 import org.robolectric.nativeruntime.DefaultNativeRuntimeLoader;
+import org.robolectric.shadow.api.Shadow;
+import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.versioning.AndroidVersions.U;
 
 /** Shadow for {@link CursorWindow} that is backed by native code */
@@ -47,18 +50,40 @@ public class ShadowNativeCursorWindow extends ShadowCursorWindow {
     CursorWindowNatives.nativeCopyStringToBuffer(windowPtr, row, column, buffer);
   }
 
-  @Implementation(maxSdk = U.SDK_INT)
+  @Implementation
   protected static boolean nativePutBlob(long windowPtr, byte[] value, int row, int column) {
     // Real Android will crash in native code if putBlob is called with a null value.
     Preconditions.checkNotNull(value);
-    return CursorWindowNatives.nativePutBlob(windowPtr, value, row, column);
-  }
-
-  @Implementation(maxSdk = U.SDK_INT)
+    if (getApiLevel() <= U.SDK_INT) {
+      return CursorWindowNatives.nativePutBlob(windowPtr, value, row, column);
+    } else {
+      // directly call the real native method, renamed by during instrumentation
+      return ReflectionHelpers.callStaticMethod(
+          CursorWindow.class,
+          Shadow.directNativeMethodName(CursorWindow.class.getName(), "nativePutBlob"),
+          ClassParameter.from(long.class, windowPtr),
+          ClassParameter.from(byte[].class, value),
+          ClassParameter.from(int.class, row),
+          ClassParameter.from(int.class, column));
+    }
+  }
+
+  @Implementation
   protected static boolean nativePutString(long windowPtr, String value, int row, int column) {
     // Real Android will crash in native code if putString is called with a null value.
     Preconditions.checkNotNull(value);
-    return CursorWindowNatives.nativePutString(windowPtr, value, row, column);
+    if (getApiLevel() <= U.SDK_INT) {
+      return CursorWindowNatives.nativePutString(windowPtr, value, row, column);
+    } else {
+      // directly call the real native method, renamed by during instrumentation
+      return ReflectionHelpers.callStaticMethod(
+          CursorWindow.class,
+          Shadow.directNativeMethodName(CursorWindow.class.getName(), "nativePutString"),
+          ClassParameter.from(long.class, windowPtr),
+          ClassParameter.from(String.class, value),
+          ClassParameter.from(int.class, row),
+          ClassParameter.from(int.class, column));
+    }
   }
 
   @Implementation(maxSdk = U.SDK_INT)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeHardwareRenderer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeHardwareRenderer.java
index 43061f493..3b9a67e2b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeHardwareRenderer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeHardwareRenderer.java
@@ -416,8 +416,7 @@ public class ShadowNativeHardwareRenderer {
         presentationDeadlineNanos);
   }
 
-  /* We use `minSdk = S` because ImageReader is currently supported on S and above. */
-  @Implementation(minSdk = S)
+  @Implementation(minSdk = Q)
   protected static Bitmap createHardwareBitmap(RenderNode node, int width, int height) {
     // The native counterpart of this method,
     // android_view_ThreadedRenderer_createHardwareBitmapFromRenderNode,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageDecoder.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageDecoder.java
index 886f5755d..389cfafbd 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageDecoder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageDecoder.java
@@ -6,6 +6,7 @@ import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
+import android.content.res.AssetFileDescriptor;
 import android.content.res.AssetManager.AssetInputStream;
 import android.graphics.Bitmap;
 import android.graphics.ColorSpace;
@@ -119,7 +120,13 @@ public class ShadowNativeImageDecoder {
 
   @Implementation(maxSdk = Q)
   protected static ImageDecoder nCreate(FileDescriptor fd, Source src) throws IOException {
-    throw new UnsupportedEncodingException();
+    return nCreate(fd, AssetFileDescriptor.UNKNOWN_LENGTH, false, src);
+  }
+
+  @Implementation(minSdk = R, maxSdk = R)
+  protected static ImageDecoder nCreate(FileDescriptor fd, boolean preferAnimation, Source src)
+      throws IOException {
+    return nCreate(fd, AssetFileDescriptor.UNKNOWN_LENGTH, preferAnimation, src);
   }
 
   @Implementation(minSdk = S, maxSdk = U.SDK_INT)
@@ -155,8 +162,8 @@ public class ShadowNativeImageDecoder {
         unpremulRequired,
         conserveMemory,
         decodeAsAlphaMask,
-        /* desiredColorSpace = */ 0, // Desired color space is currently not supported in P.
-        /* extended = */ false);
+        /* desiredColorSpace= */ 0, // Desired color space is currently not supported in P.
+        /* extended= */ false);
   }
 
   @Implementation(minSdk = Q, maxSdk = U.SDK_INT)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReader.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReader.java
index 17f6444bf..cfdc06eae 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReader.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReader.java
@@ -1,19 +1,27 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.Q;
+import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.S_V2;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.media.Image;
 import android.media.ImageReader;
+import android.media.ImageReader.OnImageAvailableListener;
+import android.os.Handler;
 import android.view.Surface;
+import java.lang.ref.WeakReference;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
 import org.robolectric.annotation.ReflectorObject;
 import org.robolectric.nativeruntime.DefaultNativeRuntimeLoader;
 import org.robolectric.nativeruntime.ImageReaderNatives;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowNativeImageReader.Picker;
 import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
+import org.robolectric.util.reflector.Static;
 import org.robolectric.versioning.AndroidVersions.T;
 import org.robolectric.versioning.AndroidVersions.U;
 import org.robolectric.versioning.AndroidVersions.V;
@@ -21,13 +29,15 @@ import org.robolectric.versioning.AndroidVersions.V;
 /** Shadow for {@link ImageReader} that is backed by native code */
 @Implements(
     value = ImageReader.class,
-    minSdk = Q,
+    minSdk = P,
     looseSignatures = true,
     isInAndroidSdk = false,
     shadowPicker = Picker.class,
     callNativeMethodsByDefault = true)
 public class ShadowNativeImageReader {
 
+  @RealObject ImageReader realImageReader;
+
   /**
    * The {@link ImageReader} static initializer invokes its own native methods in static
    * initializer. This has to be deferred starting in Android V.
@@ -91,6 +101,19 @@ public class ShadowNativeImageReader {
     natives.nativeDiscardFreeBuffers();
   }
 
+  /**
+   * This is a Java shim to support {@link
+   * ImageReader#setOnImageAvailableListener(OnImageAvailableListener, Handler)}} until it is
+   * supported in native libhostgraphics.
+   */
+  @Implementation
+  protected Surface getSurface() {
+    Surface surface = reflector(ImageReaderReflector.class, realImageReader).getSurface();
+    ShadowNativeSurface shadowNativeSurface = Shadow.extract(surface);
+    shadowNativeSurface.setContainerImageReader(realImageReader);
+    return surface;
+  }
+
   /**
    * @return A return code {@code ACQUIRE_*}
    */
@@ -117,10 +140,20 @@ public class ShadowNativeImageReader {
     ImageReaderNatives.nativeClassInit();
   }
 
+  static void triggerOnImageAvailableCallbacks(ImageReader imageReader) {
+    reflector(ImageReaderReflector.class).postEventFromNative(new WeakReference<>(imageReader));
+  }
+
   @ForType(ImageReader.class)
   interface ImageReaderReflector {
     @Accessor("mNativeContext")
     void setMemberNativeContext(long mNativeContext);
+
+    @Direct
+    Surface getSurface();
+
+    @Static
+    void postEventFromNative(Object selfRef);
   }
 
   /** Shadow picker for {@link ImageReader}. */
@@ -131,7 +164,7 @@ public class ShadowNativeImageReader {
 
     @Override
     protected int getMinApiLevel() {
-      return Q;
+      return P;
     }
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReaderSurfaceImage.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReaderSurfaceImage.java
index 9ae13f126..e9db53cac 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReaderSurfaceImage.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReaderSurfaceImage.java
@@ -1,6 +1,6 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.Q;
+import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 
@@ -15,7 +15,7 @@ import org.robolectric.versioning.AndroidVersions.U;
 /** Shadow for {@code ImageReader.SurfaceImage} that is backed by native code. */
 @Implements(
     className = "android.media.ImageReader$SurfaceImage",
-    minSdk = Q,
+    minSdk = P,
     looseSignatures = true,
     isInAndroidSdk = false,
     shadowPicker = ShadowNativeImageReaderSurfaceImage.Picker.class,
@@ -67,7 +67,7 @@ public class ShadowNativeImageReaderSurfaceImage {
 
     @Override
     protected int getMinApiLevel() {
-      return Q;
+      return P;
     }
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePathIterator.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePathIterator.java
new file mode 100644
index 000000000..ad44d9474
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePathIterator.java
@@ -0,0 +1,75 @@
+package org.robolectric.shadows;
+
+import android.content.res.ApkAssets;
+import android.graphics.PathIterator;
+import dalvik.system.VMRuntime;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.nativeruntime.PathIteratorNatives;
+import org.robolectric.shadow.api.Shadow;
+import org.robolectric.shadows.ShadowNativePathIterator.Picker;
+import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.util.ReflectionHelpers.ClassParameter;
+import org.robolectric.versioning.AndroidVersions.U;
+import org.robolectric.versioning.AndroidVersions.V;
+
+/** Shadow for {@link PathIterator} that is backed by native code. */
+@Implements(
+    value = PathIterator.class,
+    minSdk = U.SDK_INT,
+    callNativeMethodsByDefault = true,
+    shadowPicker = Picker.class,
+    isInAndroidSdk = false /* disable shadowOf generation */)
+public class ShadowNativePathIterator {
+
+  /**
+   * The {@link PathIterator} static initializer invokes its own native methods. This has to be
+   * deferred starting in Android V.
+   */
+  @Implementation(minSdk = V.SDK_INT)
+  protected static void __staticInitializer__() {
+    // deferred
+  }
+
+  @Implementation(minSdk = U.SDK_INT, maxSdk = U.SDK_INT)
+  protected static long nCreate(long nativePath) {
+    return PathIteratorNatives.nCreate(nativePath);
+  }
+
+  @Implementation(minSdk = U.SDK_INT, maxSdk = U.SDK_INT)
+  protected static long nGetFinalizer() {
+    return PathIteratorNatives.nGetFinalizer();
+  }
+
+  @Implementation(minSdk = U.SDK_INT)
+  protected static int nNext(long nativeIterator, long pointsAddress) {
+    ShadowVMRuntime shadowVmRuntime = Shadow.extract(VMRuntime.getRuntime());
+    int token;
+    if (RuntimeEnvironment.getApiLevel() == U.SDK_INT) {
+      token = PathIteratorNatives.nNext(nativeIterator, pointsAddress);
+    } else {
+      token =
+          ReflectionHelpers.callStaticMethod(
+              PathIterator.class,
+              Shadow.directNativeMethodName(ApkAssets.class.getName(), "nNext"),
+              ClassParameter.from(long.class, nativeIterator),
+              ClassParameter.from(long.class, pointsAddress));
+    }
+    float[] points = (float[]) shadowVmRuntime.getObjectForAddress(pointsAddress);
+    shadowVmRuntime.getBackingBuffer(pointsAddress).asFloatBuffer().get(points);
+    return token;
+  }
+
+  @Implementation(minSdk = U.SDK_INT, maxSdk = U.SDK_INT)
+  protected static int nPeek(long nativeIterator) {
+    return PathIteratorNatives.nPeek(nativeIterator);
+  }
+
+  /** Shadow picker for {@link PathIterator}. */
+  public static final class Picker extends GraphicsShadowPicker<Object> {
+    public Picker() {
+      super(ShadowPathIterator.class, ShadowNativePathIterator.class);
+    }
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePositionedGlyphs.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePositionedGlyphs.java
index 3a7e8a136..9b9d60c29 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePositionedGlyphs.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePositionedGlyphs.java
@@ -14,6 +14,7 @@ import org.robolectric.versioning.AndroidVersions.U;
     value = PositionedGlyphs.class,
     minSdk = S.SDK_INT,
     shadowPicker = Picker.class,
+    isInAndroidSdk = false,
     callNativeMethodsByDefault = true)
 public class ShadowNativePositionedGlyphs {
   @Implementation(maxSdk = U.SDK_INT)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRecordingCanvasOP.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRecordingCanvasOP.java
new file mode 100644
index 000000000..4d7371214
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRecordingCanvasOP.java
@@ -0,0 +1,370 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.P;
+
+import android.graphics.Bitmap;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.nativeruntime.BaseRecordingCanvasNatives;
+import org.robolectric.shadows.ShadowNativeRecordingCanvasOP.Picker;
+
+/**
+ * Shadow for android.view.RecordingCanvas. This class was renamed to {@link BaseRecordingCanvas} in
+ * Q.
+ */
+@Implements(
+    className = "android.view.RecordingCanvas",
+    isInAndroidSdk = false,
+    minSdk = P,
+    maxSdk = P,
+    shadowPicker = Picker.class)
+public class ShadowNativeRecordingCanvasOP extends ShadowNativeCanvas {
+  @Implementation
+  protected static void nDrawBitmap(
+      long nativeCanvas,
+      Bitmap bitmap,
+      float left,
+      float top,
+      long nativePaintOrZero,
+      int canvasDensity,
+      int screenDensity,
+      int bitmapDensity) {
+    BaseRecordingCanvasNatives.nDrawBitmap(
+        nativeCanvas,
+        bitmap.getNativeInstance(),
+        left,
+        top,
+        nativePaintOrZero,
+        canvasDensity,
+        screenDensity,
+        bitmapDensity);
+  }
+
+  @Implementation
+  protected static void nDrawBitmap(
+      long nativeCanvas,
+      Bitmap bitmap,
+      float srcLeft,
+      float srcTop,
+      float srcRight,
+      float srcBottom,
+      float dstLeft,
+      float dstTop,
+      float dstRight,
+      float dstBottom,
+      long nativePaintOrZero,
+      int screenDensity,
+      int bitmapDensity) {
+    BaseRecordingCanvasNatives.nDrawBitmap(
+        nativeCanvas,
+        bitmap.getNativeInstance(),
+        srcLeft,
+        srcTop,
+        srcRight,
+        srcBottom,
+        dstLeft,
+        dstTop,
+        dstRight,
+        dstBottom,
+        nativePaintOrZero,
+        screenDensity,
+        bitmapDensity);
+  }
+
+  @Implementation
+  protected static void nDrawBitmap(
+      long nativeCanvas,
+      int[] colors,
+      int offset,
+      int stride,
+      float x,
+      float y,
+      int width,
+      int height,
+      boolean hasAlpha,
+      long nativePaintOrZero) {
+    BaseRecordingCanvasNatives.nDrawBitmap(
+        nativeCanvas, colors, offset, stride, x, y, width, height, hasAlpha, nativePaintOrZero);
+  }
+
+  @Implementation
+  protected static void nDrawColor(long nativeCanvas, int color, int mode) {
+    BaseRecordingCanvasNatives.nDrawColor(nativeCanvas, color, mode);
+  }
+
+  @Implementation
+  protected static void nDrawPaint(long nativeCanvas, long nativePaint) {
+    BaseRecordingCanvasNatives.nDrawPaint(nativeCanvas, nativePaint);
+  }
+
+  @Implementation
+  protected static void nDrawPoint(long canvasHandle, float x, float y, long paintHandle) {
+    BaseRecordingCanvasNatives.nDrawPoint(canvasHandle, x, y, paintHandle);
+  }
+
+  @Implementation
+  protected static void nDrawPoints(
+      long canvasHandle, float[] pts, int offset, int count, long paintHandle) {
+    BaseRecordingCanvasNatives.nDrawPoints(canvasHandle, pts, offset, count, paintHandle);
+  }
+
+  @Implementation
+  protected static void nDrawLine(
+      long nativeCanvas, float startX, float startY, float stopX, float stopY, long nativePaint) {
+    BaseRecordingCanvasNatives.nDrawLine(nativeCanvas, startX, startY, stopX, stopY, nativePaint);
+  }
+
+  @Implementation
+  protected static void nDrawLines(
+      long canvasHandle, float[] pts, int offset, int count, long paintHandle) {
+    BaseRecordingCanvasNatives.nDrawLines(canvasHandle, pts, offset, count, paintHandle);
+  }
+
+  @Implementation
+  protected static void nDrawRect(
+      long nativeCanvas, float left, float top, float right, float bottom, long nativePaint) {
+    BaseRecordingCanvasNatives.nDrawRect(nativeCanvas, left, top, right, bottom, nativePaint);
+  }
+
+  @Implementation
+  protected static void nDrawOval(
+      long nativeCanvas, float left, float top, float right, float bottom, long nativePaint) {
+    BaseRecordingCanvasNatives.nDrawOval(nativeCanvas, left, top, right, bottom, nativePaint);
+  }
+
+  @Implementation
+  protected static void nDrawCircle(
+      long nativeCanvas, float cx, float cy, float radius, long nativePaint) {
+    BaseRecordingCanvasNatives.nDrawCircle(nativeCanvas, cx, cy, radius, nativePaint);
+  }
+
+  @Implementation
+  protected static void nDrawArc(
+      long nativeCanvas,
+      float left,
+      float top,
+      float right,
+      float bottom,
+      float startAngle,
+      float sweep,
+      boolean useCenter,
+      long nativePaint) {
+    BaseRecordingCanvasNatives.nDrawArc(
+        nativeCanvas, left, top, right, bottom, startAngle, sweep, useCenter, nativePaint);
+  }
+
+  @Implementation
+  protected static void nDrawRoundRect(
+      long nativeCanvas,
+      float left,
+      float top,
+      float right,
+      float bottom,
+      float rx,
+      float ry,
+      long nativePaint) {
+    BaseRecordingCanvasNatives.nDrawRoundRect(
+        nativeCanvas, left, top, right, bottom, rx, ry, nativePaint);
+  }
+
+  @Implementation
+  protected static void nDrawPath(long nativeCanvas, long nativePath, long nativePaint) {
+    BaseRecordingCanvasNatives.nDrawPath(nativeCanvas, nativePath, nativePaint);
+  }
+
+  @Implementation
+  protected static void nDrawRegion(long nativeCanvas, long nativeRegion, long nativePaint) {
+    BaseRecordingCanvasNatives.nDrawRegion(nativeCanvas, nativeRegion, nativePaint);
+  }
+
+  @Implementation
+  protected static void nDrawNinePatch(
+      long nativeCanvas,
+      long nativeBitmap,
+      long ninePatch,
+      float dstLeft,
+      float dstTop,
+      float dstRight,
+      float dstBottom,
+      long nativePaintOrZero,
+      int screenDensity,
+      int bitmapDensity) {
+    BaseRecordingCanvasNatives.nDrawNinePatch(
+        nativeCanvas,
+        nativeBitmap,
+        ninePatch,
+        dstLeft,
+        dstTop,
+        dstRight,
+        dstBottom,
+        nativePaintOrZero,
+        screenDensity,
+        bitmapDensity);
+  }
+
+  @Implementation
+  protected static void nDrawBitmapMatrix(
+      long nativeCanvas, Bitmap bitmap, long nativeMatrix, long nativePaint) {
+    BaseRecordingCanvasNatives.nDrawBitmapMatrix(
+        nativeCanvas, bitmap.getNativeInstance(), nativeMatrix, nativePaint);
+  }
+
+  @Implementation
+  protected static void nDrawBitmapMesh(
+      long nativeCanvas,
+      Bitmap bitmap,
+      int meshWidth,
+      int meshHeight,
+      float[] verts,
+      int vertOffset,
+      int[] colors,
+      int colorOffset,
+      long nativePaint) {
+    BaseRecordingCanvasNatives.nDrawBitmapMesh(
+        nativeCanvas,
+        bitmap.getNativeInstance(),
+        meshWidth,
+        meshHeight,
+        verts,
+        vertOffset,
+        colors,
+        colorOffset,
+        nativePaint);
+  }
+
+  @Implementation
+  protected static void nDrawVertices(
+      long nativeCanvas,
+      int mode,
+      int n,
+      float[] verts,
+      int vertOffset,
+      float[] texs,
+      int texOffset,
+      int[] colors,
+      int colorOffset,
+      short[] indices,
+      int indexOffset,
+      int indexCount,
+      long nativePaint) {
+    BaseRecordingCanvasNatives.nDrawVertices(
+        nativeCanvas,
+        mode,
+        n,
+        verts,
+        vertOffset,
+        texs,
+        texOffset,
+        colors,
+        colorOffset,
+        indices,
+        indexOffset,
+        indexCount,
+        nativePaint);
+  }
+
+  @Implementation
+  protected static void nDrawText(
+      long nativeCanvas,
+      char[] text,
+      int index,
+      int count,
+      float x,
+      float y,
+      int flags,
+      long nativePaint) {
+    BaseRecordingCanvasNatives.nDrawText(
+        nativeCanvas, text, index, count, x, y, flags, nativePaint);
+  }
+
+  @Implementation
+  protected static void nDrawText(
+      long nativeCanvas,
+      String text,
+      int start,
+      int end,
+      float x,
+      float y,
+      int flags,
+      long nativePaint) {
+    BaseRecordingCanvasNatives.nDrawText(nativeCanvas, text, start, end, x, y, flags, nativePaint);
+  }
+
+  @Implementation
+  protected static void nDrawTextRun(
+      long nativeCanvas,
+      String text,
+      int start,
+      int end,
+      int contextStart,
+      int contextEnd,
+      float x,
+      float y,
+      boolean isRtl,
+      long nativePaint) {
+    BaseRecordingCanvasNatives.nDrawTextRun(
+        nativeCanvas, text, start, end, contextStart, contextEnd, x, y, isRtl, nativePaint);
+  }
+
+  @Implementation
+  protected static void nDrawTextRun(
+      long nativeCanvas,
+      char[] text,
+      int start,
+      int count,
+      int contextStart,
+      int contextCount,
+      float x,
+      float y,
+      boolean isRtl,
+      long nativePaint,
+      long nativePrecomputedText) {
+    BaseRecordingCanvasNatives.nDrawTextRun(
+        nativeCanvas,
+        text,
+        start,
+        count,
+        contextStart,
+        contextCount,
+        x,
+        y,
+        isRtl,
+        nativePaint,
+        nativePrecomputedText);
+  }
+
+  @Implementation
+  protected static void nDrawTextOnPath(
+      long nativeCanvas,
+      char[] text,
+      int index,
+      int count,
+      long nativePath,
+      float hOffset,
+      float vOffset,
+      int bidiFlags,
+      long nativePaint) {
+    BaseRecordingCanvasNatives.nDrawTextOnPath(
+        nativeCanvas, text, index, count, nativePath, hOffset, vOffset, bidiFlags, nativePaint);
+  }
+
+  @Implementation
+  protected static void nDrawTextOnPath(
+      long nativeCanvas,
+      String text,
+      long nativePath,
+      float hOffset,
+      float vOffset,
+      int flags,
+      long nativePaint) {
+    BaseRecordingCanvasNatives.nDrawTextOnPath(
+        nativeCanvas, text, nativePath, hOffset, vOffset, flags, nativePaint);
+  }
+
+  /** Shadow picker for android.view.RecordingCanvasOP. */
+  public static final class Picker extends GraphicsShadowPicker<Object> {
+    public Picker() {
+      super(null, ShadowNativeRecordingCanvasOP.class);
+    }
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRenderEffect.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRenderEffect.java
index 15ec56b53..73902a2c8 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRenderEffect.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRenderEffect.java
@@ -15,6 +15,7 @@ import org.robolectric.versioning.AndroidVersions.U;
     value = RenderEffect.class,
     minSdk = S,
     shadowPicker = Picker.class,
+    isInAndroidSdk = false,
     callNativeMethodsByDefault = true)
 public class ShadowNativeRenderEffect {
   static {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRuntimeShader.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRuntimeShader.java
index 8992b3874..142e47fa2 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRuntimeShader.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRuntimeShader.java
@@ -21,6 +21,7 @@ import org.robolectric.versioning.AndroidVersions.U;
     value = RuntimeShader.class,
     minSdk = R,
     shadowPicker = Picker.class,
+    isInAndroidSdk = false,
     callNativeMethodsByDefault = true)
 public class ShadowNativeRuntimeShader {
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeStringBlock.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeStringBlock.java
new file mode 100644
index 000000000..a3e64ffca
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeStringBlock.java
@@ -0,0 +1,12 @@
+package org.robolectric.shadows;
+
+import org.robolectric.annotation.Implements;
+import org.robolectric.versioning.AndroidVersions.V;
+
+@Implements(
+    className = "android.content.res.StringBlock",
+    isInAndroidSdk = false,
+    minSdk = V.SDK_INT,
+    callNativeMethodsByDefault = true,
+    shadowPicker = ShadowBaseStringBlock.Picker.class)
+public class ShadowNativeStringBlock extends ShadowBaseStringBlock {}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeSurface.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeSurface.java
index 9cdc29425..818a0378b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeSurface.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeSurface.java
@@ -8,20 +8,23 @@ import static android.os.Build.VERSION_CODES.S;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.graphics.Canvas;
-import android.graphics.HardwareRenderer;
 import android.graphics.Rect;
-import android.graphics.RenderNode;
 import android.graphics.SurfaceTexture;
 import android.hardware.HardwareBuffer;
+import android.media.ImageReader;
 import android.os.Parcel;
 import android.view.Surface;
 import android.view.Surface.OutOfResourcesException;
+import android.view.animation.AnimationUtils;
+import java.util.concurrent.TimeUnit;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.nativeruntime.DefaultNativeRuntimeLoader;
+import org.robolectric.nativeruntime.HardwareRendererNatives;
+import org.robolectric.nativeruntime.RecordingCanvasNatives;
+import org.robolectric.nativeruntime.RenderNodeNatives;
 import org.robolectric.nativeruntime.SurfaceNatives;
-import org.robolectric.shadows.ShadowNativeHardwareRenderer.HardwareRendererReflector;
 import org.robolectric.shadows.ShadowNativeSurface.Picker;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
@@ -36,6 +39,13 @@ import org.robolectric.versioning.AndroidVersions.U;
     isInAndroidSdk = false,
     callNativeMethodsByDefault = true)
 public class ShadowNativeSurface {
+
+  @RealObject private Surface realSurface;
+
+  // This field is populated when a Surface is created by an ImageReader. It is used to support
+  // the ImageReader.OnImageAvailableListener callback.
+  private ImageReader containerImageReader;
+
   @Implementation
   protected static long nativeCreateFromSurfaceTexture(SurfaceTexture surfaceTexture)
       throws OutOfResourcesException {
@@ -158,88 +168,82 @@ public class ShadowNativeSurface {
         nativeObject, frameRate, compatibility, changeFrameRateStrategy);
   }
 
-  /**
-   * Shadow for {@link Surface$HwuiContext} for Q and below that invokes HardwareRenderer methods.
-   * In Q and below, HwuiContext had its own native methods.
-   */
-  @Implements(
-      className = "android.view.Surface$HwuiContext",
-      minSdk = Q,
-      maxSdk = Q,
-      isInAndroidSdk = false,
-      shadowPicker = ShadowNativeHwuiContext.Picker.class)
-  public static class ShadowNativeHwuiContext {
-    @RealObject Object realHwuiContext;
-
-    // This object is a HardwareRenderer in Q, but is a ThreadedRenderer in O and P.
-    private Object hardwareRenderer;
-
-    @Implementation
-    protected void __constructor__(Surface surface, boolean isWideColorGamut) {
-      // Modeled after the HwuiContext constructor in R:
-      // https://cs.android.com/android/platform/superproject/+/android11-dev:frameworks/base/core/java/android/view/Surface.java
-      reflector(HwuiContextReflector.class, realHwuiContext)
-          .__constructor__(surface, isWideColorGamut);
-      HardwareRenderer hardwareRenderer = new HardwareRenderer();
-      RenderNode renderNode =
-          reflector(HwuiContextReflector.class, realHwuiContext).getRenderNode();
-      hardwareRenderer.setContentRoot(renderNode);
-      hardwareRenderer.setSurface(surface);
-      reflector(HardwareRendererReflector.class, hardwareRenderer).setWideGamut(isWideColorGamut);
-      hardwareRenderer.setLightSourceAlpha(0.0f, 0.0f);
-      hardwareRenderer.setLightSourceGeometry(0.0f, 0.0f, 0.0f, 0.0f);
-      this.hardwareRenderer = hardwareRenderer;
-    }
+  void setContainerImageReader(ImageReader realImageReader) {
+    this.containerImageReader = realImageReader;
+  }
 
-    @Implementation
-    protected void unlockAndPost(Canvas canvas) {
-      RenderNode renderNode =
-          reflector(HwuiContextReflector.class, realHwuiContext).getRenderNode();
-      renderNode.endRecording();
-      reflector(HwuiContextReflector.class, realHwuiContext).setCanvas(null);
-      ((HardwareRenderer) hardwareRenderer)
-          .createRenderRequest()
-          .setVsyncTime(System.nanoTime())
-          .syncAndDraw();
+  @Implementation
+  protected void unlockCanvasAndPost(Canvas canvas) {
+    reflector(SurfaceReflector.class, realSurface).unlockCanvasAndPost(canvas);
+    if (this.containerImageReader != null) {
+      ShadowNativeImageReader.triggerOnImageAvailableCallbacks(this.containerImageReader);
     }
+  }
 
-    @Implementation
-    protected void updateSurface() {
-      Surface surface = reflector(HwuiContextReflector.class, realHwuiContext).getOuterSurface();
-      reflector(HardwareRendererReflector.class, hardwareRenderer).setSurface(surface);
-    }
+  @Implementation(minSdk = P, maxSdk = Q)
+  protected static long nHwuiCreate(long contentRootNode, long surface, boolean isWideColorGamut) {
+    // Modeled after the HwuiContext constructor in R:
+    // https://cs.android.com/android/platform/superproject/+/android11-dev:frameworks/base/core/java/android/view/Surface.java;l=1005
 
-    @Implementation
-    protected void destroy() {
-      ((HardwareRenderer) hardwareRenderer).destroy();
-    }
+    // Set up the root render node.
+    long rootRenderNodePtr = HardwareRendererNatives.nCreateRootRenderNode();
+    RenderNodeNatives.nSetClipToBounds(rootRenderNodePtr, false);
 
-    @ForType(className = "android.view.Surface$HwuiContext")
-    interface HwuiContextReflector {
-      @Direct
-      void __constructor__(Surface surface, boolean isWideColorGamut);
+    // Set up the HardwareRenderer
+    long renderer = HardwareRendererNatives.nCreateProxy(false, rootRenderNodePtr);
 
-      @Accessor("mRenderNode")
-      RenderNode getRenderNode();
+    // Set up light-related properties.
+    HardwareRendererNatives.nSetLightAlpha(renderer, 0, 0);
+    HardwareRendererNatives.nSetLightGeometry(renderer, 0, 0, 0, 0);
 
-      @Accessor("mCanvas")
-      void setCanvas(Canvas canvas);
+    // Draw the content render node onto the root render node.
+    long recordingCanvas = RecordingCanvasNatives.nCreateDisplayListCanvas(rootRenderNodePtr, 0, 0);
+    RecordingCanvasNatives.nDrawRenderNode(recordingCanvas, contentRootNode);
+    RecordingCanvasNatives.nFinishRecording(recordingCanvas, rootRenderNodePtr);
 
-      @Accessor("this$0")
-      Surface getOuterSurface();
-    }
+    // Set the surface.
+    HardwareRendererNatives.nSetSurfacePtr(renderer, surface);
+    return renderer;
+  }
 
-    /** Shadow picker for HwuiContext. */
-    public static final class Picker extends GraphicsShadowPicker<Object> {
-      public Picker() {
-        super(null, ShadowNativeHwuiContext.class);
-      }
+  @Implementation(minSdk = O, maxSdk = O_MR1)
+  protected static long nHwuiCreate(long rootNode, long surface) {
+    return nHwuiCreate(rootNode, surface, false);
+  }
+
+  @Implementation(minSdk = O, maxSdk = Q)
+  protected static void nHwuiSetSurface(long renderer, long surface) {
+    if (surface != 0) {
+      HardwareRendererNatives.nSetSurfacePtr(renderer, surface);
     }
   }
 
-  @Implementation(minSdk = Q, maxSdk = Q)
-  protected static long nHwuiCreate(long rootNode, long surface, boolean isWideColorGamut) {
-    return 0; // no-op
+  @Implementation(minSdk = O, maxSdk = Q)
+  protected static void nHwuiDraw(long renderer) {
+    // FrameInfo changed packages from android.view.FrameInfo in P to android.graphics.FrameInfo in
+    // Q, so it's easier to just construct a long[] array with the frame data.
+    final long vsync = TimeUnit.MILLISECONDS.toNanos(AnimationUtils.currentAnimationTimeMillis());
+    final long[] frameInfo = new long[9];
+    frameInfo[0] = 1 << 2;
+    frameInfo[1] = vsync;
+    frameInfo[2] = vsync;
+    frameInfo[3] = Long.MAX_VALUE;
+    frameInfo[4] = 0;
+    HardwareRendererNatives.nSyncAndDrawFrame(renderer, frameInfo, 9);
+  }
+
+  @Implementation(minSdk = O, maxSdk = Q)
+  protected static void nHwuiDestroy(long renderer) {
+    HardwareRendererNatives.nDeleteProxy(renderer);
+  }
+
+  @ForType(Surface.class)
+  interface SurfaceReflector {
+    @Direct
+    void unlockCanvasAndPost(Canvas canvas);
+
+    @Accessor("mNativeObject")
+    long getNativeObject();
   }
 
   /** Shadow picker for {@link Surface}. */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTextRunShaper.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTextRunShaper.java
index f6aed6be2..c6cc10d68 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTextRunShaper.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTextRunShaper.java
@@ -14,6 +14,7 @@ import org.robolectric.versioning.AndroidVersions.U;
     value = TextRunShaper.class,
     minSdk = S.SDK_INT,
     shadowPicker = Picker.class,
+    isInAndroidSdk = false,
     callNativeMethodsByDefault = true)
 public class ShadowNativeTextRunShaper {
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeThreadedRenderer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeThreadedRenderer.java
index 60d2db8d8..5e5759a31 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeThreadedRenderer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeThreadedRenderer.java
@@ -2,17 +2,32 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.P;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.graphics.Canvas;
+import android.graphics.PixelFormat;
+import android.media.Image;
+import android.media.Image.Plane;
+import android.media.ImageReader;
+import android.view.Surface;
 import android.view.ThreadedRenderer;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.nativeruntime.DefaultNativeRuntimeLoader;
 import org.robolectric.nativeruntime.HardwareRendererNatives;
 import org.robolectric.shadows.ShadowNativeThreadedRenderer.Picker;
+import org.robolectric.util.reflector.ForType;
+import org.robolectric.util.reflector.WithType;
 
 /** Shadow for {@link ThreadedRenderer} that is backed by native code */
-@Implements(value = ThreadedRenderer.class, minSdk = O, maxSdk = P, shadowPicker = Picker.class)
+@Implements(
+    value = ThreadedRenderer.class,
+    minSdk = O,
+    maxSdk = P,
+    shadowPicker = Picker.class,
+    looseSignatures = true)
 public class ShadowNativeThreadedRenderer {
 
   // ThreadedRenderer specific functions. These do not exist in HardwareRenderer
@@ -174,6 +189,29 @@ public class ShadowNativeThreadedRenderer {
     return HardwareRendererNatives.nCreateHardwareBitmap(renderNode, width, height);
   }
 
+  @Implementation(minSdk = P, maxSdk = P)
+  protected static Object createHardwareBitmap(Object renderNode, Object width, Object height) {
+    try (ImageReader imageReader =
+        ImageReader.newInstance((int) width, (int) height, PixelFormat.RGBA_8888, 1)) {
+      Surface surface = imageReader.getSurface();
+      Canvas canvas = surface.lockHardwareCanvas();
+      reflector(DisplayListCanvasReflector.class, canvas).drawRenderNode(renderNode);
+      surface.unlockCanvasAndPost(canvas);
+      Image nativeImage = imageReader.acquireNextImage();
+      Plane[] planes = nativeImage.getPlanes();
+      Bitmap destBitmap = Bitmap.createBitmap((int) width, (int) height, Config.ARGB_8888);
+      destBitmap.copyPixelsFromBuffer(planes[0].getBuffer());
+      surface.release();
+      // Return an immutable copy of the Bitmap, which is what this API expects.
+      return destBitmap.copy(Config.HARDWARE, false);
+    }
+  }
+
+  @ForType(className = "android.view.DisplayListCanvas")
+  interface DisplayListCanvasReflector {
+    void drawRenderNode(@WithType("android.view.RenderNode") Object renderNode);
+  }
+
   /** Shadow picker for {@link ThreadedRenderer}. */
   public static final class Picker extends GraphicsShadowPicker<Object> {
     public Picker() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTypeface.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTypeface.java
index 60475e0f0..186b56353 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTypeface.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTypeface.java
@@ -50,7 +50,6 @@ public class ShadowNativeTypeface extends ShadowTypeface {
   private static final int STYLE_NORMAL = 0;
   private static final int STYLE_ITALIC = 1;
 
-
   @Implementation(minSdk = S)
   protected static void __staticInitializer__() {
     if (RuntimeEnvironment.getApiLevel() <= U.SDK_INT) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeXmlBlock.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeXmlBlock.java
new file mode 100644
index 000000000..eb4dfdfee
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeXmlBlock.java
@@ -0,0 +1,12 @@
+package org.robolectric.shadows;
+
+import org.robolectric.annotation.Implements;
+import org.robolectric.versioning.AndroidVersions.V;
+
+@Implements(
+    className = "android.content.res.XmlBlock",
+    isInAndroidSdk = false,
+    minSdk = V.SDK_INT,
+    callNativeMethodsByDefault = true,
+    shadowPicker = ShadowBaseXmlBlock.Picker.class)
+public class ShadowNativeXmlBlock extends ShadowBaseXmlBlock {}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetwork.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetwork.java
index d68b52a0f..87fe35d1e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetwork.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetwork.java
@@ -1,25 +1,22 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.R;
 
 import android.net.Network;
-import com.google.common.base.Preconditions;
 import java.io.FileDescriptor;
 import java.net.DatagramSocket;
 import java.net.Socket;
 import java.util.HashSet;
 import java.util.Set;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers;
 
-@Implements(value = Network.class, minSdk = LOLLIPOP)
+@Implements(value = Network.class)
 public class ShadowNetwork {
 
   @RealObject private Network realObject;
@@ -31,15 +28,10 @@ public class ShadowNetwork {
   /**
    * Creates new instance of {@link Network}, because its constructor is hidden.
    *
-   * <p>Requires API 21 (Lollipop) and above.
-   *
    * @param netId The netId.
    * @return The Network instance.
    */
   public static Network newInstance(int netId) {
-    Preconditions.checkState(
-        RuntimeEnvironment.getApiLevel() >= LOLLIPOP,
-        "android.net.Network requires API 21 (Lollipop) or above");
     return Shadow.newInstance(Network.class, new Class[] {int.class}, new Object[] {netId});
   }
 
@@ -82,8 +74,8 @@ public class ShadowNetwork {
   }
 
   /**
-   * Simulates a socket bind. isSocketBound can be called to verify that the fd was bound to
-   * this network interface, and boundSocketCount() will increment for any unique socket.
+   * Simulates a socket bind. isSocketBound can be called to verify that the fd was bound to this
+   * network interface, and boundSocketCount() will increment for any unique socket.
    */
   @Implementation(minSdk = M)
   protected void bindSocket(FileDescriptor fd) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetworkCapabilities.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetworkCapabilities.java
index 4f03aa337..a09112060 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetworkCapabilities.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetworkCapabilities.java
@@ -1,34 +1,39 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
+import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.N_MR1;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.Q;
+import static android.os.Build.VERSION_CODES.S;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.net.NetworkCapabilities;
 import android.net.NetworkSpecifier;
 import android.net.TransportInfo;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.shadow.api.Shadow;
+import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 
-/** Robolectic provides overrides for fetching and updating transport. */
-@Implements(value = NetworkCapabilities.class, minSdk = LOLLIPOP, looseSignatures = true)
+/** Robolectric provides overrides for fetching and updating transport. */
+@Implements(value = NetworkCapabilities.class, looseSignatures = true)
 public class ShadowNetworkCapabilities {
 
   @RealObject protected NetworkCapabilities realNetworkCapabilities;
 
+  public static final int NET_CAPABILITY_NOT_BANDWIDTH_CONSTRAINED = 37;
+
   public static NetworkCapabilities newInstance() {
     return Shadow.newInstanceOf(NetworkCapabilities.class);
   }
 
-  /** Updates the transport types for this network capablities to include {@code transportType}. */
+  /** Updates the transport types for this network capabilities to include {@code transportType}. */
   @HiddenApi
   @Implementation
   public NetworkCapabilities addTransportType(int transportType) {
@@ -36,7 +41,7 @@ public class ShadowNetworkCapabilities {
         .addTransportType(transportType);
   }
 
-  /** Updates the transport types for this network capablities to remove {@code transportType}. */
+  /** Updates the transport types for this network capabilities to remove {@code transportType}. */
   @HiddenApi
   @Implementation
   public NetworkCapabilities removeTransportType(int transportType) {
@@ -98,9 +103,30 @@ public class ShadowNetworkCapabilities {
         .setLinkDownstreamBandwidthKbps((int) kbps);
   }
 
+  /** Clears capabilities. */
+  public void clearCapabilities() {
+    if (RuntimeEnvironment.getApiLevel() < M) {
+      reflector(NetworkCapabilitiesReflector.class, realNetworkCapabilities)
+          .setMNetworkCapabilities(0L);
+
+      if (RuntimeEnvironment.getApiLevel() >= S) {
+        reflector(NetworkCapabilitiesReflector.class, realNetworkCapabilities)
+            .setMForbiddenNetworkCapabilities(0L);
+      }
+    } else {
+      realNetworkCapabilities.clearAll();
+    }
+  }
+
   @ForType(NetworkCapabilities.class)
   interface NetworkCapabilitiesReflector {
 
+    @Accessor("mNetworkCapabilities")
+    void setMNetworkCapabilities(long capabilities);
+
+    @Accessor("mForbiddenNetworkCapabilities")
+    void setMForbiddenNetworkCapabilities(long capabilities);
+
     @Direct
     NetworkCapabilities addTransportType(int transportType);
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetworkScoreManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetworkScoreManager.java
index 71ace5e24..3389402e3 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetworkScoreManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetworkScoreManager.java
@@ -1,16 +1,11 @@
 package org.robolectric.shadows;
 
 import android.net.NetworkScoreManager;
-import android.os.Build;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
 /** Provides testing APIs for {@link NetworkScoreManager}. */
-@Implements(
-  value = NetworkScoreManager.class,
-  isInAndroidSdk = false,
-  minSdk = Build.VERSION_CODES.LOLLIPOP
-)
+@Implements(value = NetworkScoreManager.class, isInAndroidSdk = false)
 public class ShadowNetworkScoreManager {
   private String activeScorerPackage;
   private boolean isScoringEnabled = true;
@@ -26,7 +21,9 @@ public class ShadowNetworkScoreManager {
     return true;
   }
 
-  /** @see #isScoringEnabled() */
+  /**
+   * @see #isScoringEnabled()
+   */
   @Implementation
   protected void disableScoring() {
     isScoringEnabled = false;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNoopNativeAllocationRegistry.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNoopNativeAllocationRegistry.java
index 7310b5cac..a842607cf 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNoopNativeAllocationRegistry.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNoopNativeAllocationRegistry.java
@@ -1,10 +1,15 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.N;
+import static org.robolectric.shadow.api.Shadow.invokeConstructor;
 
 import libcore.util.NativeAllocationRegistry;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.InDevelopment;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.util.ReflectionHelpers.ClassParameter;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow for {@link NativeAllocationRegistry} that is a no-op. */
 @Implements(
@@ -14,6 +19,8 @@ import org.robolectric.annotation.Implements;
     looseSignatures = true)
 public class ShadowNoopNativeAllocationRegistry {
 
+  @RealObject protected NativeAllocationRegistry realNativeAllocationRegistry;
+
   @Implementation
   protected Runnable registerNativeAllocation(Object referent, Object allocator) {
     return () -> {};
@@ -23,4 +30,30 @@ public class ShadowNoopNativeAllocationRegistry {
   protected Runnable registerNativeAllocation(Object referent, long nativePtr) {
     return () -> {};
   }
+
+  /**
+   * The newly introduced constructor (in version V) now performs a null check on the classLoader
+   * argument. We intercept the constructor calls so as to pass a non-null classloader. The
+   * classloader would be Robolectric's SandboxClassloader, but the value itself does not affect the
+   * behavior of actual class.
+   */
+  @InDevelopment
+  @Implementation(minSdk = V.SDK_INT)
+  protected void __constructor__(
+      ClassLoader classLoader,
+      Class clazz,
+      long freeFunction,
+      long size,
+      boolean mallocAllocation) {
+    ClassLoader loader =
+        (classLoader == null) ? Thread.currentThread().getContextClassLoader() : classLoader;
+    invokeConstructor(
+        NativeAllocationRegistry.class,
+        realNativeAllocationRegistry,
+        ClassParameter.from(ClassLoader.class, loader),
+        ClassParameter.from(Class.class, clazz),
+        ClassParameter.from(long.class, freeFunction),
+        ClassParameter.from(long.class, size),
+        ClassParameter.from(boolean.class, mallocAllocation));
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotification.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotification.java
index ea08d71f1..977e029a1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotification.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotification.java
@@ -27,8 +27,7 @@ import org.robolectric.shadow.api.Shadow;
 @SuppressLint("NewApi")
 public class ShadowNotification {
 
-  @RealObject
-  Notification realNotification;
+  @RealObject Notification realNotification;
 
   public CharSequence getContentTitle() {
     return RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.N
@@ -51,7 +50,8 @@ public class ShadowNotification {
   }
 
   public boolean isOngoing() {
-    return ((realNotification.flags & Notification.FLAG_ONGOING_EVENT) == Notification.FLAG_ONGOING_EVENT);
+    return ((realNotification.flags & Notification.FLAG_ONGOING_EVENT)
+        == Notification.FLAG_ONGOING_EVENT);
   }
 
   public CharSequence getBigText() {
@@ -74,7 +74,7 @@ public class ShadowNotification {
     if (getApiLevel() >= N) {
       return realNotification.extras.getCharSequence(Notification.EXTRA_SUMMARY_TEXT);
     } else {
-      return findText(applyBigContentView(),  "text");
+      return findText(applyBigContentView(), "text");
     }
   }
 
@@ -94,7 +94,8 @@ public class ShadowNotification {
       ImageView imageView =
           (ImageView) applyBigContentView().findViewById(getInternalResourceId("big_picture"));
       return imageView != null && imageView.getDrawable() != null
-          ? ((BitmapDrawable) imageView.getDrawable()).getBitmap() : null;
+          ? ((BitmapDrawable) imageView.getDrawable()).getBitmap()
+          : null;
     }
   }
 
@@ -102,7 +103,7 @@ public class ShadowNotification {
     return RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.N
         ? realNotification.extras.getBoolean(Notification.EXTRA_SHOW_WHEN)
         : findView(applyContentView(), "chronometer").getVisibility() == View.VISIBLE
-        || findView(applyContentView(), "time").getVisibility() == View.VISIBLE;
+            || findView(applyContentView(), "time").getVisibility() == View.VISIBLE;
   }
 
   private ProgressBar getProgressBar_PreN() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationListenerService.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationListenerService.java
index 7d0f86aa9..c8cc54c45 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationListenerService.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationListenerService.java
@@ -24,7 +24,7 @@ import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
 /** Shadow implementation of {@link NotificationListenerService}. */
-@Implements(value = NotificationListenerService.class, minSdk = VERSION_CODES.LOLLIPOP)
+@Implements(value = NotificationListenerService.class)
 public class ShadowNotificationListenerService extends ShadowService {
   private static final AtomicInteger rebindRequestCount = new AtomicInteger(0);
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationManager.java
index ccce95fa7..c497572a2 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationManager.java
@@ -52,6 +52,7 @@ public class ShadowNotificationManager {
 
   private int currentInteruptionFilter = INTERRUPTION_FILTER_ALL;
   private Policy notificationPolicy;
+  private Policy consolidatedNotificationPolicy;
   private String notificationDelegate;
   private int importance;
 
@@ -264,6 +265,23 @@ public class ShadowNotificationManager {
     return notificationPolicy;
   }
 
+  /**
+   * Specifies the consolidated notification policy to return
+   *
+   * @see #getConsolidatedNotificationPolicy()
+   */
+  public void setConsolidatedNotificationPolicy(Policy policy) {
+    consolidatedNotificationPolicy = policy;
+  }
+
+  /**
+   * @return the value specified via {@link #setConsolidatedNotificationPolicy(Policy)}
+   */
+  @Implementation(minSdk = R)
+  protected Policy getConsolidatedNotificationPolicy() {
+    return consolidatedNotificationPolicy;
+  }
+
   /**
    * @return the value specified via {@link #setNotificationPolicyAccessGranted(boolean)}
    */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOpenGLMatrix.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOpenGLMatrix.java
index 93f357487..427c8f78a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOpenGLMatrix.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOpenGLMatrix.java
@@ -116,15 +116,30 @@ public class ShadowOpenGLMatrix {
     final float y = rhsVec[rhsVecOffset + 1];
     final float z = rhsVec[rhsVecOffset + 2];
     final float w = rhsVec[rhsVecOffset + 3];
-    resultVec[resultVecOffset + 0] = lhsMat[I(0, 0, lhsMatOffset)] * x + lhsMat[I(1, 0, lhsMatOffset)] * y + lhsMat[I(2, 0, lhsMatOffset)] * z + lhsMat[I(3, 0, lhsMatOffset)] * w;
-    resultVec[resultVecOffset + 1] = lhsMat[I(0, 1, lhsMatOffset)] * x + lhsMat[I(1, 1, lhsMatOffset)] * y + lhsMat[I(2, 1, lhsMatOffset)] * z + lhsMat[I(3, 1, lhsMatOffset)] * w;
-    resultVec[resultVecOffset + 2] = lhsMat[I(0, 2, lhsMatOffset)] * x + lhsMat[I(1, 2, lhsMatOffset)] * y + lhsMat[I(2, 2, lhsMatOffset)] * z + lhsMat[I(3, 2, lhsMatOffset)] * w;
-    resultVec[resultVecOffset + 3] = lhsMat[I(0, 3, lhsMatOffset)] * x + lhsMat[I(1, 3, lhsMatOffset)] * y + lhsMat[I(2, 3, lhsMatOffset)] * z + lhsMat[I(3, 3, lhsMatOffset)] * w;
+    resultVec[resultVecOffset + 0] =
+        lhsMat[I(0, 0, lhsMatOffset)] * x
+            + lhsMat[I(1, 0, lhsMatOffset)] * y
+            + lhsMat[I(2, 0, lhsMatOffset)] * z
+            + lhsMat[I(3, 0, lhsMatOffset)] * w;
+    resultVec[resultVecOffset + 1] =
+        lhsMat[I(0, 1, lhsMatOffset)] * x
+            + lhsMat[I(1, 1, lhsMatOffset)] * y
+            + lhsMat[I(2, 1, lhsMatOffset)] * z
+            + lhsMat[I(3, 1, lhsMatOffset)] * w;
+    resultVec[resultVecOffset + 2] =
+        lhsMat[I(0, 2, lhsMatOffset)] * x
+            + lhsMat[I(1, 2, lhsMatOffset)] * y
+            + lhsMat[I(2, 2, lhsMatOffset)] * z
+            + lhsMat[I(3, 2, lhsMatOffset)] * w;
+    resultVec[resultVecOffset + 3] =
+        lhsMat[I(0, 3, lhsMatOffset)] * x
+            + lhsMat[I(1, 3, lhsMatOffset)] * y
+            + lhsMat[I(2, 3, lhsMatOffset)] * z
+            + lhsMat[I(3, 3, lhsMatOffset)] * w;
   }
 
   private static int I(int i, int j, int offset) {
     // #define I(_i, _j) ((_j)+ 4*(_i))
     return offset + j + 4 * i;
   }
-
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOverlayManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOverlayManager.java
new file mode 100644
index 000000000..ae01b8794
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOverlayManager.java
@@ -0,0 +1,101 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.content.Context;
+import android.content.om.OverlayInfo;
+import android.content.om.OverlayManager;
+import android.content.pm.PackageManager;
+import android.os.UserHandle;
+import java.util.HashMap;
+import java.util.Map;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.ForType;
+
+/**
+ * Basic shadow implementation for the {@link OverlayManager}.
+ *
+ * <p>This shadow exists because the overlays managed by the OverlayManager require set up at the
+ * Android base image level. This is not something that can exist for host level unit tests.
+ *
+ * <p>To simulate the image configuration, unit tests must call the {@link addOverlayInfo} function
+ * to define the available overlays.
+ *
+ * <p>This basic shadow only implements the {@link getOverlayInfo} and {@link setEnabled} functions,
+ * enabling a basic workflow for enabling or disabling Runtime Resource Overlays (RROs). It enforces
+ * the android.permissions.CHANGE_OVERLAY_PACKAGES permission.
+ *
+ * <p>It does not validate the android.permission.INTERACT_ACROSS_USERS or
+ * android.INTERACT_ACROSS_USERS_FULL permissions, which are necessary when changing packages owned
+ * by a different user.
+ */
+@Implements(value = OverlayManager.class, minSdk = UPSIDE_DOWN_CAKE, isInAndroidSdk = false)
+public final class ShadowOverlayManager {
+  private final Map<String, OverlayInfo> overlaysByPackageName = new HashMap<>();
+
+  @RealObject private OverlayManager realOverlayManager;
+
+  /**
+   * Adds or replaces the overlay based on the packageName. Expected to be used by unit tests to
+   * setup the expected overlays.
+   */
+  public void addOverlayInfo(OverlayInfo overlayInfo) {
+    overlaysByPackageName.put(overlayInfo.packageName, overlayInfo);
+  }
+
+  /**
+   * Removes an overlay with the specified packageName if it is present. If not present, nothing
+   * happens.
+   */
+  public void removeOverlayInfo(String packageName) {
+    overlaysByPackageName.remove(packageName);
+  }
+
+  @Implementation
+  @Nullable
+  protected OverlayInfo getOverlayInfo(
+      @NonNull String packageName, @NonNull UserHandle userHandle) {
+    return overlaysByPackageName.get(packageName);
+  }
+
+  @Implementation
+  protected void setEnabled(@NonNull String packageName, boolean enable, @NonNull UserHandle user) {
+    checkPermission();
+
+    OverlayInfo overlay = overlaysByPackageName.get(packageName);
+    if (overlay == null) {
+      throw new IllegalStateException(
+          "setEnabled failed; overlay name " + packageName + " not found");
+    }
+
+    if (!overlay.isMutable) {
+      throw new IllegalStateException(
+          "setEnabled failed; overlay name " + packageName + " is not mutable");
+    }
+
+    int state = enable ? OverlayInfo.STATE_ENABLED : OverlayInfo.STATE_DISABLED;
+
+    addOverlayInfo(new OverlayInfo(overlay, state));
+  }
+
+  @ForType(OverlayManager.class)
+  interface OverlayManagerReflector {
+    @Accessor("mContext")
+    Context getContext();
+  }
+
+  private void checkPermission() {
+    Context context = reflector(OverlayManagerReflector.class, realOverlayManager).getContext();
+    if (context.checkSelfPermission(android.Manifest.permission.CHANGE_OVERLAY_PACKAGES)
+        != PackageManager.PERMISSION_GRANTED) {
+      throw new SecurityException(
+          "Missing required permission: " + android.Manifest.permission.CHANGE_OVERLAY_PACKAGES);
+    }
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageInstaller.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageInstaller.java
index 247ac2111..38a0b1ff4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageInstaller.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageInstaller.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.S;
@@ -40,11 +39,11 @@ import org.robolectric.annotation.RealObject;
 import org.robolectric.shadow.api.Shadow;
 
 /** Shadow for PackageInstaller. */
-@Implements(value = PackageInstaller.class, minSdk = LOLLIPOP)
+@Implements(value = PackageInstaller.class)
 @SuppressLint("NewApi")
 public class ShadowPackageInstaller {
   /** Shadow for PackageInstaller.SessionInfo. */
-  @Implements(value = PackageInstaller.SessionInfo.class, minSdk = LOLLIPOP)
+  @Implements(value = PackageInstaller.SessionInfo.class)
   public static class ShadowSessionInfo {
     @RealObject private SessionInfo sessionInfo;
 
@@ -112,6 +111,9 @@ public class ShadowPackageInstaller {
     sessionInfo.appPackageName = params.appPackageName;
     sessionInfo.appLabel = params.appLabel;
     sessionInfo.appIcon = params.appIcon;
+    if (VERSION.SDK_INT >= P) {
+      sessionInfo.installerPackageName = params.installerPackageName;
+    }
 
     sessionInfos.put(sessionInfo.getSessionId(), sessionInfo);
 
@@ -328,7 +330,7 @@ public class ShadowPackageInstaller {
   }
 
   /** Shadow for PackageInstaller.Session. */
-  @Implements(value = PackageInstaller.Session.class, minSdk = LOLLIPOP)
+  @Implements(value = PackageInstaller.Session.class)
   public static class ShadowSession {
 
     private OutputStream outputStream;
@@ -339,7 +341,6 @@ public class ShadowPackageInstaller {
     private ShadowPackageInstaller shadowPackageInstaller;
     private PersistableBundle appMetadata = new PersistableBundle();
 
-
     @Implementation(minSdk = UPSIDE_DOWN_CAKE)
     protected void requestUserPreapproval(
         @NonNull PreapprovalDetails details, @NonNull IntentSender statusReceiver) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageManager.java
index 941f49b65..cb33a025d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageManager.java
@@ -33,6 +33,8 @@ import static java.util.Arrays.asList;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.Manifest;
+import android.Manifest.permission;
+import android.Manifest.permission_group;
 import android.annotation.UserIdInt;
 import android.app.Application;
 import android.content.BroadcastReceiver;
@@ -63,6 +65,7 @@ import android.content.pm.ProviderInfo;
 import android.content.pm.ResolveInfo;
 import android.content.pm.ServiceInfo;
 import android.content.pm.Signature;
+import android.content.pm.SigningInfo;
 import android.content.pm.pkg.FrameworkPackageUserState;
 import android.content.res.Resources;
 import android.graphics.drawable.Drawable;
@@ -77,6 +80,7 @@ import android.util.Pair;
 import com.google.common.base.Function;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.HashMultimap;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Multimap;
 import com.google.errorprone.annotations.InlineMe;
 import java.lang.reflect.Array;
@@ -164,6 +168,7 @@ public class ShadowPackageManager {
   static final SortedMap<ComponentName, List<IntentFilter>> persistentPreferredActivities =
       new TreeMap<>();
   static final Map<Pair<String, Integer>, Drawable> drawables = new LinkedHashMap<>();
+
   /**
    * Map of package names to an inner map where the key is the resource id which fetches its
    * corresponding text.
@@ -173,6 +178,7 @@ public class ShadowPackageManager {
   static final Map<String, Integer> applicationEnabledSettingMap = new HashMap<>();
   static Map<String, PermissionInfo> extraPermissions = new HashMap<>();
   static Map<String, PermissionGroupInfo> permissionGroups = new HashMap<>();
+
   /**
    * Map of package names to an inner map where the key is the permission and the integer represents
    * the permission flags set for that particular permission
@@ -195,10 +201,115 @@ public class ShadowPackageManager {
   boolean shouldShowActivityChooser = false;
   static final Map<String, Integer> distractingPackageRestrictions = new ConcurrentHashMap<>();
 
+  static final String AOSP_PLATFORM_PERMISSION_GROUP_PREFIX = "android.permission-group.";
+  static final String AOSP_PLATFORM_PERMISSION_PREFIX = "android.permission.";
+
+  /**
+   * Limited set of platform permission groups and their metadata as defined in API level 23.
+   *
+   * <p>The source of truth for the list of platform permission groups and their metadata is the
+   * core framework AndroidManifest.xml file in the Android SDK. For the latest version see:
+   * https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/res/AndroidManifest.xml
+   * Note that new groups may be added and changes to existing groups may be made in each existing
+   * and future versions.
+   */
+  static final ImmutableMap<String, PermissionGroupInfo> AOSP_PLATFORM_PERMISSION_GROUPS =
+      ImmutableMap.of(
+          permission_group.CALENDAR,
+          createPermissionGroupInfo(
+              permission_group.CALENDAR, "Calendar", "access your calendar", 200),
+          permission_group.CONTACTS,
+          createPermissionGroupInfo(
+              permission_group.CONTACTS, "Contacts", "access your contacts", 100));
+
+  /**
+   * Limited set of platform permissions and their metadata as defined in API level 23.
+   *
+   * <p>The source of truth for the list of platform permissions and their metadata is the core
+   * framework AndroidManifest.xml file in the Android SDK. For the latest version see:
+   * https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/res/AndroidManifest.xml
+   * Note that new permissions may be added and changes to existing permissions may be made in each
+   * existing and future versions.
+   *
+   * <p>The mapping of permissions to groups was removed from the core framework AndroidManifest.xml
+   * file. The current source of truth is in the Permission mainline module:
+   * https://cs.android.com/android/platform/superproject/main/+/main:packages/modules/Permission/PermissionController/src/com/android/permissioncontroller/permission/utils/PermissionMapping.kt
+   */
+  static final ImmutableMap<String, PermissionInfo> AOSP_PLATFORM_PERMISSIONS =
+      ImmutableMap.of(
+          permission.READ_CALENDAR,
+          createPermissionInfo(
+              permission.READ_CALENDAR,
+              "read calendar events plus confidential information",
+              "Allows the app to read all calendar events stored on your phone, including those of"
+                  + " friends or co-workers. This may allow the app to share or save your calendar"
+                  + " data, regardless of confidentiality or sensitivity.",
+              PermissionInfo.PROTECTION_DANGEROUS,
+              permission_group.CALENDAR),
+          permission.WRITE_CALENDAR,
+          createPermissionInfo(
+              permission.WRITE_CALENDAR,
+              "add or modify calendar events and send email to guests without owners\' knowledge",
+              "Allows the app to add, remove, change events that you can modify on your phone,"
+                  + " including those of friends or co-workers. This may allow the app to send"
+                  + " messages that appear to come from calendar owners, or modify events without"
+                  + " the owners\' knowledge.",
+              PermissionInfo.PROTECTION_DANGEROUS,
+              permission_group.CALENDAR),
+          permission.GET_ACCOUNTS,
+          createPermissionInfo(
+              permission.GET_ACCOUNTS,
+              "find accounts on the device",
+              "Allows the app to get the list of accounts known by the phone. This may include any"
+                  + " accounts created by applications you have installed.",
+              PermissionInfo.PROTECTION_DANGEROUS,
+              permission_group.CONTACTS),
+          permission.READ_CONTACTS,
+          createPermissionInfo(
+              permission.READ_CONTACTS,
+              "read your contacts",
+              "Allows the app to read data about your contacts stored on your phone, including the"
+                  + " frequency with which you\'ve called, emailed, or communicated in other ways"
+                  + " with specific individuals. This permission allows apps to save your contact"
+                  + " data, and malicious apps may share contact data without your knowledge.",
+              PermissionInfo.PROTECTION_DANGEROUS,
+              permission_group.CONTACTS),
+          permission.WRITE_CONTACTS,
+          createPermissionInfo(
+              permission.WRITE_CONTACTS,
+              "modify your contacts",
+              "Allows the app to modify the data about your contacts stored on your phone,"
+                  + " including the frequency with which you\'ve called, emailed, or communicated"
+                  + " in other ways with specific contacts. This permission allows apps to delete"
+                  + " contact data.",
+              PermissionInfo.PROTECTION_DANGEROUS,
+              permission_group.CONTACTS));
+
+  private static PermissionGroupInfo createPermissionGroupInfo(
+      String name, String label, String description, int priority) {
+    PermissionGroupInfo permissionGroupInfo = new PermissionGroupInfo();
+    permissionGroupInfo.name = name;
+    permissionGroupInfo.nonLocalizedDescription = description;
+    permissionGroupInfo.nonLocalizedLabel = label;
+    permissionGroupInfo.priority = priority;
+    return permissionGroupInfo;
+  }
+
+  private static PermissionInfo createPermissionInfo(
+      String name, String label, String description, int protectionLevel, String group) {
+    PermissionInfo permissionInfo = new PermissionInfo();
+    permissionInfo.group = group;
+    permissionInfo.name = name;
+    permissionInfo.nonLocalizedDescription = description;
+    permissionInfo.nonLocalizedLabel = label;
+    permissionInfo.protectionLevel = protectionLevel;
+    return permissionInfo;
+  }
+
   /**
    * Makes sure that given activity exists.
    *
-   * If the activity doesn't exist yet, it will be created with {@code applicationInfo} set to an
+   * <p>If the activity doesn't exist yet, it will be created with {@code applicationInfo} set to an
    * existing application, or if it doesn't exist, a new package will be created.
    *
    * @return existing or newly created activity info.
@@ -213,7 +324,7 @@ public class ShadowPackageManager {
   /**
    * Makes sure that given service exists.
    *
-   * If the service doesn't exist yet, it will be created with {@code applicationInfo} set to an
+   * <p>If the service doesn't exist yet, it will be created with {@code applicationInfo} set to an
    * existing application, or if it doesn't exist, a new package will be created.
    *
    * @return existing or newly created service info.
@@ -230,7 +341,7 @@ public class ShadowPackageManager {
   /**
    * Makes sure that given receiver exists.
    *
-   * If the receiver doesn't exist yet, it will be created with {@code applicationInfo} set to an
+   * <p>If the receiver doesn't exist yet, it will be created with {@code applicationInfo} set to an
    * existing application, or if it doesn't exist, a new package will be created.
    *
    * @return existing or newly created receiver info.
@@ -247,7 +358,7 @@ public class ShadowPackageManager {
   /**
    * Makes sure that given provider exists.
    *
-   * If the provider doesn't exist yet, it will be created with {@code applicationInfo} set to an
+   * <p>If the provider doesn't exist yet, it will be created with {@code applicationInfo} set to an
    * existing application, or if it doesn't exist, a new package will be created.
    *
    * @return existing or newly created provider info.
@@ -273,10 +384,10 @@ public class ShadowPackageManager {
   /**
    * Adds or updates given activity in the system.
    *
-   * If activity with the same {@link ComponentInfo#name} and {@code ComponentInfo#packageName}
+   * <p>If activity with the same {@link ComponentInfo#name} and {@code ComponentInfo#packageName}
    * exists it will be updated. Its {@link ComponentInfo#applicationInfo} is always set to {@link
-   * ApplicationInfo} already existing in the system, but if no application exists a new one will
-   * be created using {@link ComponentInfo#applicationInfo} in this component.
+   * ApplicationInfo} already existing in the system, but if no application exists a new one will be
+   * created using {@link ComponentInfo#applicationInfo} in this component.
    */
   public void addOrUpdateActivity(ActivityInfo activityInfo) {
     addComponent(
@@ -290,7 +401,7 @@ public class ShadowPackageManager {
   /**
    * Adds or updates given service in the system.
    *
-   * If service with the same {@link ComponentInfo#name} and {@code ComponentInfo#packageName}
+   * <p>If service with the same {@link ComponentInfo#name} and {@code ComponentInfo#packageName}
    * exists it will be updated. Its {@link ComponentInfo#applicationInfo} is always set to {@link
    * ApplicationInfo} already existing in the system, but if no application exists a new one will be
    * created using {@link ComponentInfo#applicationInfo} in this component.
@@ -307,11 +418,10 @@ public class ShadowPackageManager {
   /**
    * Adds or updates given broadcast receiver in the system.
    *
-   * If broadcast receiver with the same {@link ComponentInfo#name} and {@code
+   * <p>If broadcast receiver with the same {@link ComponentInfo#name} and {@code
    * ComponentInfo#packageName} exists it will be updated. Its {@link ComponentInfo#applicationInfo}
-   * is always set to {@link ApplicationInfo} already existing in the system, but if no
-   * application exists a new one will be created using {@link ComponentInfo#applicationInfo} in
-   * this component.
+   * is always set to {@link ApplicationInfo} already existing in the system, but if no application
+   * exists a new one will be created using {@link ComponentInfo#applicationInfo} in this component.
    */
   public void addOrUpdateReceiver(ActivityInfo receiverInfo) {
     addComponent(
@@ -325,11 +435,10 @@ public class ShadowPackageManager {
   /**
    * Adds or updates given content provider in the system.
    *
-   * If content provider with the same {@link ComponentInfo#name} and {@code
+   * <p>If content provider with the same {@link ComponentInfo#name} and {@code
    * ComponentInfo#packageName} exists it will be updated. Its {@link ComponentInfo#applicationInfo}
-   * is always set to {@link ApplicationInfo} already existing in the system, but if no
-   * application exists a new one will be created using {@link ComponentInfo#applicationInfo} in
-   * this component.
+   * is always set to {@link ApplicationInfo} already existing in the system, but if no application
+   * exists a new one will be created using {@link ComponentInfo#applicationInfo} in this component.
    */
   public void addOrUpdateProvider(ProviderInfo providerInfo) {
     addComponent(
@@ -473,7 +582,7 @@ public class ShadowPackageManager {
   /**
    * Settings for a particular package.
    *
-   * This class mirrors {@link com.android.server.pm.PackageSetting}, which is used by {@link
+   * <p>This class mirrors {@link com.android.server.pm.PackageSetting}, which is used by {@link
    * PackageManager}.
    */
   public static class PackageSetting {
@@ -599,9 +708,9 @@ public class ShadowPackageManager {
   /**
    * Sets extra resolve infos for an intent.
    *
-   * Those entries are added to whatever might be in the manifest already.
+   * <p>Those entries are added to whatever might be in the manifest already.
    *
-   * Note that all resolve infos will have {@link ResolveInfo#isDefault} field set to {@code
+   * <p>Note that all resolve infos will have {@link ResolveInfo#isDefault} field set to {@code
    * true} to allow their resolution for implicit intents. If this is not what you want, then you
    * still have the reference to those ResolveInfos, and you can set the field back to {@code
    * false}.
@@ -616,7 +725,9 @@ public class ShadowPackageManager {
     }
   }
 
-  /** @deprecated see note on {@link #addResolveInfoForIntent(Intent, ResolveInfo)}. */
+  /**
+   * @deprecated see note on {@link #addResolveInfoForIntent(Intent, ResolveInfo)}.
+   */
   @Deprecated
   public void addResolveInfoForIntent(Intent intent, List<ResolveInfo> info) {
     setResolveInfosForIntent(intent, info);
@@ -625,7 +736,7 @@ public class ShadowPackageManager {
   /**
    * Adds extra resolve info for an intent.
    *
-   * Note that this resolve info will have {@link ResolveInfo#isDefault} field set to {@code
+   * <p>Note that this resolve info will have {@link ResolveInfo#isDefault} field set to {@code
    * true} to allow its resolution for implicit intents. If this is not what you want, then please
    * use {@link #addResolveInfoForIntentNoDefaults} instead.
    *
@@ -656,7 +767,7 @@ public class ShadowPackageManager {
    * Adds the {@code info} as {@link ResolveInfo} for the intent but without applying any default
    * values.
    *
-   * In particular it will not make the {@link ResolveInfo#isDefault} field {@code true}, that
+   * <p>In particular it will not make the {@link ResolveInfo#isDefault} field {@code true}, that
    * means that this resolve info will not resolve for {@link Intent#resolveActivity} and {@link
    * Context#startActivity}.
    *
@@ -780,14 +891,14 @@ public class ShadowPackageManager {
   /**
    * Installs a package with the {@link PackageManager}.
    *
-   * In order to create PackageInfo objects in a valid state please use {@link
+   * <p>In order to create PackageInfo objects in a valid state please use {@link
    * androidx.test.core.content.pm.PackageInfoBuilder}.
    *
-   * This method automatically simulates instalation of a package in the system, so it adds a
+   * <p>This method automatically simulates instalation of a package in the system, so it adds a
    * flag {@link ApplicationInfo#FLAG_INSTALLED} to the application info and makes sure it exits. It
    * will update applicationInfo in package components as well.
    *
-   * If you don't want the package to be installed, use {@link #addPackageNoDefaults} instead.
+   * <p>If you don't want the package to be installed, use {@link #addPackageNoDefaults} instead.
    */
   public void installPackage(PackageInfo packageInfo) {
     ApplicationInfo appInfo = packageInfo.applicationInfo;
@@ -839,6 +950,26 @@ public class ShadowPackageManager {
         packageName, new InstallSourceInfo(initiatingPackage, null, null, installerPackage));
   }
 
+  /** Adds install source information for a package. */
+  public void setInstallSourceInfo(
+      String packageName,
+      @Nullable String initiatingPackageName,
+      @Nullable SigningInfo initiatingPackageSigningInfo,
+      @Nullable String originatingPackageName,
+      @Nullable String installingPackageName,
+      @Nullable String updateOwnerPackageName,
+      int packageSource) {
+    packageInstallSourceInfoMap.put(
+        packageName,
+        new InstallSourceInfo(
+            initiatingPackageName,
+            initiatingPackageSigningInfo,
+            originatingPackageName,
+            installingPackageName,
+            updateOwnerPackageName,
+            packageSource));
+  }
+
   /**
    * Adds a package to the {@link PackageManager}, but doesn't set any default values on it.
    *
@@ -864,6 +995,19 @@ public class ShadowPackageManager {
       }
       Preconditions.checkArgument(packageInfo.packageName.equals(packageStats.packageName));
 
+      if (packageInfo.permissions != null) {
+        for (PermissionInfo permissionInfo : packageInfo.permissions) {
+          if (AOSP_PLATFORM_PERMISSIONS.containsKey(permissionInfo.name)
+              || permissionInfo.name.startsWith(AOSP_PLATFORM_PERMISSION_PREFIX)) {
+            throw new IllegalArgumentException(
+                "Permission "
+                    + permissionInfo.name
+                    + " is a platform permission. Do not declare it as part of the package or test"
+                    + " app manifest.");
+          }
+        }
+      }
+
       packageInfos.put(packageInfo.packageName, packageInfo);
       packageStatsMap.put(packageInfo.packageName, packageStats);
 
@@ -878,7 +1022,9 @@ public class ShadowPackageManager {
     }
   }
 
-  /** @deprecated Use {@link #installPackage(PackageInfo)} instead. */
+  /**
+   * @deprecated Use {@link #installPackage(PackageInfo)} instead.
+   */
   @Deprecated
   public void addPackage(String packageName) {
     PackageInfo packageInfo = new PackageInfo();
@@ -905,13 +1051,13 @@ public class ShadowPackageManager {
   /**
    * Testing API allowing to retrieve internal package representation.
    *
-   * This will allow to modify the package in a way visible to Robolectric, as this is
+   * <p>This will allow to modify the package in a way visible to Robolectric, as this is
    * Robolectric's internal full package representation.
    *
-   * Note that maybe a better way is to just modify the test manifest to make those modifications
+   * <p>Note that maybe a better way is to just modify the test manifest to make those modifications
    * in a standard way.
    *
-   * Retrieving package info using {@link PackageManager#getPackageInfo} / {@link
+   * <p>Retrieving package info using {@link PackageManager#getPackageInfo} / {@link
    * PackageManager#getApplicationInfo} will return defensive copies that will be stripped out of
    * information according to provided flags. Don't use it to modify Robolectric state.
    */
@@ -947,7 +1093,7 @@ public class ShadowPackageManager {
    * itself)[https://developer.android.com/guide/topics/manifest/permission-group-element.html], as
    * part of its manifest
    *
-   * {@link android.content.pm.PackageParser.PermissionGroup}s added through this method have
+   * <p>{@link android.content.pm.PackageParser.PermissionGroup}s added through this method have
    * precedence over those specified with the same name by one of the aforementioned methods.
    *
    * @see PackageManager#getAllPermissionGroups(int)
@@ -1061,12 +1207,6 @@ public class ShadowPackageManager {
     systemSharedLibraryNames.clear();
   }
 
-  @Deprecated
-  /** @deprecated use {@link #addCanonicalName} instead.} */
-  public void addCurrentToCannonicalName(String currentName, String canonicalName) {
-    currentToCanonicalNames.put(currentName, canonicalName);
-  }
-
   /**
    * Adds a canonical package name for a package.
    *
@@ -1254,6 +1394,16 @@ public class ShadowPackageManager {
     for (PermissionGroup permissionGroup : appPackage.permissionGroups) {
       PermissionGroupInfo permissionGroupInfo =
           PackageParser.generatePermissionGroupInfo(permissionGroup, flags);
+
+      if (AOSP_PLATFORM_PERMISSION_GROUPS.containsKey(permissionGroupInfo.name)
+          || permissionGroupInfo.name.startsWith(AOSP_PLATFORM_PERMISSION_GROUP_PREFIX)) {
+        throw new IllegalArgumentException(
+            "Permission group "
+                + permissionGroupInfo.name
+                + " is a platform permission group. Do not declare it as part of the test app"
+                + " manifest.");
+      }
+
       addPermissionGroupInfo(permissionGroupInfo);
     }
     PackageInfo packageInfo = generatePackageInfo(appPackage, flags);
@@ -1439,7 +1589,7 @@ public class ShadowPackageManager {
    * @throws IllegalArgumentException if component with given name doesn't exist.
    */
   public List<IntentFilter> getIntentFiltersForReceiver(ComponentName componentName) {
-      return getIntentFiltersForComponent(componentName, receiverFilters);
+    return getIntentFiltersForComponent(componentName, receiverFilters);
   }
 
   /**
@@ -1650,7 +1800,7 @@ public class ShadowPackageManager {
   /**
    * Returns the current {@link PackageSetting} of {@code packageName}.
    *
-   * If {@code packageName} is not present in this {@link ShadowPackageManager}, this method will
+   * <p>If {@code packageName} is not present in this {@link ShadowPackageManager}, this method will
    * return null.
    */
   public PackageSetting getPackageSetting(String packageName) {
@@ -1674,7 +1824,7 @@ public class ShadowPackageManager {
   /**
    * Returns the last value provided to {@code setDistractingPackageRestrictions} for {@code pkg}.
    *
-   * Defaults to {@code PackageManager.RESTRICTION_NONE} if {@code
+   * <p>Defaults to {@code PackageManager.RESTRICTION_NONE} if {@code
    * setDistractingPackageRestrictions} has not been called for {@code pkg}.
    */
   public int getDistractingPackageRestrictions(String pkg) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageParser.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageParser.java
index 0f31e379c..89d20ea0c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageParser.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageParser.java
@@ -2,7 +2,6 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
-import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageParser;
@@ -18,7 +17,6 @@ import java.util.List;
 import java.util.Set;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implements;
-import org.robolectric.res.Fs;
 import org.robolectric.shadows.ShadowLog.LogItem;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.reflector.Accessor;
@@ -35,26 +33,18 @@ public class ShadowPackageParser {
     PackageParser packageParser = new PackageParser();
 
     try {
-      Package thePackage;
-      if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.LOLLIPOP) {
-        // TODO(christianw/brettchabot): workaround for NPE from probable bug in Q.
-        // Can be removed when upstream properly handles a null callback
-        // PackageParser#setMinAspectRatio(Package)
-        if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.Q) {
-          QHelper.setCallback(packageParser);
-        }
-        thePackage = packageParser.parsePackage(apkFile.toFile(), 0);
-      } else { // JB -> KK
-        thePackage =
-            reflector(_PackageParser_.class, packageParser)
-                .parsePackage(apkFile.toFile(), Fs.externalize(apkFile), new DisplayMetrics(), 0);
+      // TODO(christianw/brettchabot): workaround for NPE from probable bug in Q.
+      // Can be removed when upstream properly handles a null callback
+      // PackageParser#setMinAspectRatio(Package)
+      if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.Q) {
+        QHelper.setCallback(packageParser);
       }
+      Package thePackage = packageParser.parsePackage(apkFile.toFile(), 0);
 
       if (thePackage == null) {
         List<LogItem> logItems = ShadowLog.getLogsForTag("PackageParser");
         if (logItems.isEmpty()) {
-          throw new RuntimeException(
-              "Failed to parse package " + apkFile);
+          throw new RuntimeException("Failed to parse package " + apkFile);
         } else {
           LogItem logItem = logItems.get(0);
           throw new RuntimeException(
@@ -68,9 +58,7 @@ public class ShadowPackageParser {
     }
   }
 
-  /**
-   * Prevents ClassNotFoundError for Callback on pre-26.
-   */
+  /** Prevents ClassNotFoundError for Callback on pre-26. */
   private static class QHelper {
     private static void setCallback(PackageParser packageParser) {
       // TODO(christianw): this should be a CallbackImpl with the ApplicationPackageManager...
@@ -108,8 +96,7 @@ public class ShadowPackageParser {
         long firstInstallTime,
         long lastUpdateTime,
         HashSet<String> grantedPermissions,
-        @WithType("android.content.pm.PackageUserState")
-            Object state);
+        @WithType("android.content.pm.PackageUserState") Object state);
 
     // LOLLIPOP_MR1
     @Static
@@ -120,8 +107,7 @@ public class ShadowPackageParser {
         long firstInstallTime,
         long lastUpdateTime,
         ArraySet<String> grantedPermissions,
-        @WithType("android.content.pm.PackageUserState")
-            Object state);
+        @WithType("android.content.pm.PackageUserState") Object state);
 
     @Static
     PackageInfo generatePackageInfo(
@@ -141,7 +127,7 @@ public class ShadowPackageParser {
         long lastUpdateTime) {
       int apiLevel = RuntimeEnvironment.getApiLevel();
 
-      if (apiLevel <= LOLLIPOP) {
+      if (apiLevel == LOLLIPOP) {
         return generatePackageInfo(
             p,
             gids,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowParcel.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowParcel.java
index 22c021b68..53d9570c0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowParcel.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowParcel.java
@@ -1,7 +1,5 @@
 package org.robolectric.shadows;
 
-
-
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.O_MR1;
 import static android.os.Build.VERSION_CODES.P;
@@ -62,8 +60,6 @@ public class ShadowParcel {
   private static final HashMap<ClassLoader, HashMap<String, Pair<Creator<?>, Class<?>>>>
       pairedCreators = new HashMap<>();
 
-
-
   @HiddenApi
   @Implementation
   public Parcelable.Creator<?> readParcelableCreator(ClassLoader loader) {
@@ -337,7 +333,6 @@ public class ShadowParcel {
     }
   }
 
-  // nativeWriteBlob was introduced in lollipop, thus no need for a int nativePtr variant
   @Implementation
   protected static void nativeWriteBlob(long nativePtr, byte[] b, int offset, int len) {
     nativeWriteByteArray(nativePtr, b, offset, len);
@@ -378,7 +373,6 @@ public class ShadowParcel {
     return NATIVE_BYTE_BUFFER_REGISTRY.getNativeObject(nativePtr).createByteArray();
   }
 
-  // nativeReadBlob was introduced in lollipop, thus no need for a int nativePtr variant
   @Implementation
   protected static byte[] nativeReadBlob(long nativePtr) {
     return nativeCreateByteArray(nativePtr);
@@ -556,8 +550,10 @@ public class ShadowParcel {
   private static class ByteBuffer {
     /** Number of bytes in Parcel used by an int, length, or anything smaller. */
     private static final int INT_SIZE_BYTES = 4;
+
     /** Number of bytes in Parcel used by a long or double. */
     private static final int LONG_OR_DOUBLE_SIZE_BYTES = 8;
+
     /** Immutable empty byte array. */
     private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
 
@@ -565,8 +561,10 @@ public class ShadowParcel {
     private static class FakeEncodedItem implements Serializable {
       /** Number of consecutive bytes consumed by this object. */
       final int sizeBytes;
+
       /** The original typed value stored. */
       final Object value;
+
       /**
        * Whether this item's byte-encoding is all zero.
        *
@@ -602,10 +600,13 @@ public class ShadowParcel {
      * utilities are robust compared to ArrayList's bulk operations.
      */
     private FakeEncodedItem[] data;
+
     /** The read/write pointer. */
     private int dataPosition;
+
     /** The length of the buffer; the capacity is data.length. */
     private int dataSize;
+
     /**
      * Whether the next read should fail if it's past the end of the array.
      *
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPath.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPath.java
index de99c0123..58f4a1f03 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPath.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPath.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-
 import android.graphics.Path;
 import android.graphics.RectF;
 import java.util.List;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPathIterator.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPathIterator.java
new file mode 100644
index 000000000..73d0a75dd
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPathIterator.java
@@ -0,0 +1,24 @@
+package org.robolectric.shadows;
+
+import android.graphics.PathIterator;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.versioning.AndroidVersions.U;
+
+/** Shadow for {@link PathIterator} in LEGACY graphics. */
+@Implements(
+    value = PathIterator.class,
+    minSdk = U.SDK_INT,
+    isInAndroidSdk = false /* disable shadowOf generation */)
+public class ShadowPathIterator {
+
+  /**
+   * By default, Robolectric instrumentation of this native method will cause it to return zero,
+   * which conveys {@link PathIterator#VERB_MOVE}. To avoid infinite loops, update it to return
+   * {@link PathIterator#VERB_DONE}.
+   */
+  @Implementation
+  protected static int nNext(long nativeIterator, long pointsAddress) {
+    return PathIterator.VERB_DONE;
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedLooper.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedLooper.java
index aa63a6872..c836b0739 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedLooper.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedLooper.java
@@ -390,8 +390,8 @@ public final class ShadowPausedLooper extends ShadowLooper {
 
       if (isPaused()
           && !(realLooper == Looper.getMainLooper() && looperMode != Mode.INSTRUMENTATION_TEST)) {
-      unPause();
-    }
+        unPause();
+      }
       ShadowPausedChoreographer.reset(realLooper);
     }
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessage.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessage.java
index a23cae497..dd703bb0d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessage.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessage.java
@@ -1,11 +1,9 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.os.Handler;
 import android.os.Message;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.LooperMode;
@@ -34,11 +32,7 @@ public class ShadowPausedMessage extends ShadowMessage {
   @Override
   @Implementation
   public void recycleUnchecked() {
-    if (RuntimeEnvironment.getApiLevel() >= LOLLIPOP) {
-      reflector(MessageReflector.class, realMessage).recycleUnchecked();
-    } else {
-      reflector(MessageReflector.class, realMessage).recycle();
-    }
+    reflector(MessageReflector.class, realMessage).recycleUnchecked();
   }
 
   @Override
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessageQueue.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessageQueue.java
index 230313531..b5810a9f2 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessageQueue.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessageQueue.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
 import static android.os.Build.VERSION_CODES.M;
 import static com.google.common.base.Preconditions.checkState;
+import static org.robolectric.RuntimeEnvironment.getApiLevel;
 import static org.robolectric.shadow.api.Shadow.invokeConstructor;
 import static org.robolectric.util.ReflectionHelpers.ClassParameter.from;
 import static org.robolectric.util.reflector.Reflector.reflector;
@@ -23,11 +24,13 @@ import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.res.android.NativeObjRegistry;
 import org.robolectric.shadow.api.Shadow;
+import org.robolectric.shadows.ShadowMessage.MessageReflector;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.Scheduler;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /**
  * The shadow {@link} MessageQueue} for {@link LooperMode.Mode.PAUSED}
@@ -77,7 +80,7 @@ public class ShadowPausedMessageQueue extends ShadowMessageQueue {
   // nativePollOnce
   @Implementation(maxSdk = LOLLIPOP_MR1)
   protected static void nativePollOnce(Object ptr, Object timeoutMillis) {
-    long ptrLong = getLong(ptr);
+    long ptrLong = (long) ptr;
     nativeQueueRegistry.getNativeObject(ptrLong).nativePollOnce(ptrLong, (int) timeoutMillis);
   }
 
@@ -154,7 +157,7 @@ public class ShadowPausedMessageQueue extends ShadowMessageQueue {
     synchronized (realQueue) {
       Message msg = peekNextExecutableMessage();
       if (msg == null) {
-          return true;
+        return true;
       }
 
       long now = SystemClock.uptimeMillis();
@@ -234,24 +237,6 @@ public class ShadowPausedMessageQueue extends ShadowMessageQueue {
     return reflector(MessageQueueReflector.class, realQueue).getQuitting();
   }
 
-  private static long getLong(Object intOrLongObj) {
-    if (intOrLongObj instanceof Long) {
-      return (long) intOrLongObj;
-    } else {
-      Integer intObj = (Integer) intOrLongObj;
-      return intObj.longValue();
-    }
-  }
-
-  private static int getInt(Object intOrLongObj) {
-    if (intOrLongObj instanceof Integer) {
-      return (int) intOrLongObj;
-    } else {
-      Long longObj = (Long) intOrLongObj;
-      return longObj.intValue();
-    }
-  }
-
   Duration getNextScheduledTaskTime() {
     Message next = peekNextExecutableMessage();
 
@@ -310,24 +295,38 @@ public class ShadowPausedMessageQueue extends ShadowMessageQueue {
    * Returns the message at the head of the queue immediately, regardless of its scheduled time.
    * Compare to {@link #getNext()} which will only return the next message if the system clock is
    * advanced to its scheduled time.
+   *
+   * <p>This is a copy of the real MessageQueue.next implementation with the 'when' handling logic
+   * omitted.
    */
   Message getNextIgnoringWhen() {
+    MessageQueueReflector queueReflector = reflector(MessageQueueReflector.class, realQueue);
     synchronized (realQueue) {
-      Message prev = null;
+      Message prevMsg = null;
       Message msg = getMessages();
       // Head is blocked on synchronization barrier, find next asynchronous message.
       if (msg != null && msg.getTarget() == null) {
         do {
-          prev = msg;
+          prevMsg = msg;
           msg = shadowOfMsg(msg).internalGetNext();
         } while (msg != null && !msg.isAsynchronous());
       }
       if (msg != null) {
-        Message next = shadowOfMsg(msg).internalGetNext();
-        if (prev == null) {
-          reflector(MessageQueueReflector.class, realQueue).setMessages(next);
+        Message nextMsg = reflector(MessageReflector.class, msg).getNext();
+        if (prevMsg != null) {
+          reflector(MessageReflector.class, prevMsg).setNext(nextMsg);
+          if (reflector(MessageReflector.class, prevMsg).getNext() == null
+              && getApiLevel() >= V.SDK_INT) {
+            queueReflector.setLast(prevMsg);
+          }
         } else {
-          ReflectionHelpers.setField(prev, "next", next);
+          queueReflector.setMessages(nextMsg);
+          if (nextMsg == null && getApiLevel() >= V.SDK_INT) {
+            queueReflector.setLast(null);
+          }
+        }
+        if (msg.isAsynchronous() && getApiLevel() >= V.SDK_INT) {
+          queueReflector.setAsyncMessageCount(queueReflector.getAsyncMessageCount() - 1);
         }
       }
       return msg;
@@ -343,6 +342,10 @@ public class ShadowPausedMessageQueue extends ShadowMessageQueue {
       msgQueue.setMessages(null);
       msgQueue.setIdleHandlers(new ArrayList<>());
       msgQueue.setNextBarrierToken(0);
+      if (getApiLevel() >= V.SDK_INT) {
+        msgQueue.setLast(null);
+        msgQueue.setAsyncMessageCount(0);
+      }
     }
     setUncaughtException(null);
   }
@@ -427,6 +430,10 @@ public class ShadowPausedMessageQueue extends ShadowMessageQueue {
         msg = next;
       }
       reflector(MessageQueueReflector.class, realQueue).setMessages(null);
+      if (getApiLevel() >= V.SDK_INT) {
+        reflector(MessageQueueReflector.class, realQueue).setLast(null);
+        reflector(MessageQueueReflector.class, realQueue).setAsyncMessageCount(0);
+      }
     }
   }
 
@@ -459,13 +466,21 @@ public class ShadowPausedMessageQueue extends ShadowMessageQueue {
     @Accessor("mPtr")
     void setPtr(long ptr);
 
-    @Accessor("mPtr")
-    int getPtr();
-
     @Direct
     void quit(boolean b);
 
     @Accessor("mQuitting")
     boolean getQuitting();
+
+    // start for android V
+    @Accessor("mLast")
+    void setLast(Message msg);
+
+    @Accessor("mAsyncMessageCount")
+    int getAsyncMessageCount();
+
+    @Accessor("mAsyncMessageCount")
+    void setAsyncMessageCount(int asyncMessageCount);
+    // end android V
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedSystemClock.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedSystemClock.java
index 5f6edfc8b..21024ad82 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedSystemClock.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedSystemClock.java
@@ -46,9 +46,7 @@ public class ShadowPausedSystemClock extends ShadowSystemClock {
   // This is needed to accomodate Loopers which are not reset between tests
   private static final List<Listener> staticListeners = new CopyOnWriteArrayList<>();
 
-  /**
-   * Callback for clock updates
-   */
+  /** Callback for clock updates */
   interface Listener {
     void onClockAdvanced();
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPendingIntent.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPendingIntent.java
index c005d51f7..7da58626c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPendingIntent.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPendingIntent.java
@@ -9,6 +9,7 @@ import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.S;
+import static org.robolectric.RuntimeEnvironment.getApiLevel;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.annotation.NonNull;
@@ -44,6 +45,7 @@ import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
+import org.robolectric.versioning.AndroidVersions.V;
 
 @Implements(PendingIntent.class)
 @SuppressLint("NewApi")
@@ -559,7 +561,16 @@ public class ShadowPendingIntent {
     parceledPendingIntents.add(sender);
     out.writeInt(index);
 
-    if (RuntimeEnvironment.getApiLevel() >= N) {
+    if (getApiLevel() >= V.SDK_INT) {
+      ThreadLocal<List<OnMarshaledListener>> sOnMarshaledListeners =
+          ReflectionHelpers.getStaticField(PendingIntent.class, "sOnMarshaledListener");
+      List<OnMarshaledListener> listeners = sOnMarshaledListeners.get();
+      if (listeners != null) {
+        for (OnMarshaledListener listener : listeners) {
+          listener.onMarshaled(sender, out, 0);
+        }
+      }
+    } else if (getApiLevel() >= N) {
       ThreadLocal<OnMarshaledListener> sOnMarshaledListener =
           ReflectionHelpers.getStaticField(PendingIntent.class, "sOnMarshaledListener");
       OnMarshaledListener listener = sOnMarshaledListener.get();
@@ -692,7 +703,6 @@ public class ShadowPendingIntent {
       createdIntents.clear();
       parceledPendingIntents.clear();
     }
-
   }
 
   @ForType(PendingIntent.class)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPermissionControllerManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPermissionControllerManager.java
new file mode 100644
index 000000000..d34cb5e91
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPermissionControllerManager.java
@@ -0,0 +1,109 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.Q;
+import static android.permission.PermissionControllerService.SERVICE_INTERFACE;
+import static org.robolectric.Shadows.shadowOf;
+import static org.robolectric.shadows.ShadowApplicationPackageManager.PERMISSION_CONTROLLER_PACKAGE_NAME;
+
+import android.annotation.CallbackExecutor;
+import android.annotation.NonNull;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.pm.ServiceInfo;
+import android.os.Handler;
+import android.os.Process;
+import android.os.UserHandle;
+import android.permission.PermissionControllerManager;
+import android.permission.PermissionControllerManager.OnRevokeRuntimePermissionsCallback;
+import android.permission.PermissionControllerManager.Reason;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.annotation.Resetter;
+import org.robolectric.shadow.api.Shadow;
+import org.robolectric.util.ReflectionHelpers.ClassParameter;
+
+/** Shadow for {@link PermissionControllerManager}. */
+@Implements(value = PermissionControllerManager.class, minSdk = Q, isInAndroidSdk = false)
+public class ShadowPermissionControllerManager {
+  private static final AtomicBoolean resolveInfoRegistered = new AtomicBoolean();
+
+  private PackageManager packageManager;
+
+  @RealObject PermissionControllerManager realObject;
+
+  @Implementation
+  protected void __constructor__(@NonNull Context context, @NonNull Handler handler) {
+    packageManager = context.getPackageManager();
+    if (resolveInfoRegistered.compareAndSet(false, true)) {
+      ensureResolveInfoRegistered();
+    }
+    // Invoke the original constructor.
+    Shadow.invokeConstructor(
+        PermissionControllerManager.class,
+        realObject,
+        ClassParameter.from(Context.class, context),
+        ClassParameter.from(Handler.class, handler));
+  }
+
+  /**
+   * This is a very basic implementation of this API that simply forwards the call to the
+   * PackageManager. The real implementation is part of mainline and can easily evolve over time.
+   * The real implementation upholds the semantic of different permissions properties by: not
+   * revoking permissions that are considered fixed, revoking more permissions than the caller
+   * requested if they are part of the same group, and more.
+   */
+  @Implementation
+  protected void revokeRuntimePermissions(
+      @NonNull Map<String, List<String>> request,
+      boolean doDryRun,
+      @Reason int reason,
+      @NonNull @CallbackExecutor Executor executor,
+      @NonNull OnRevokeRuntimePermissionsCallback callback) {
+    if (doDryRun) {
+      throw new UnsupportedOperationException("Dry run not implemented");
+    }
+    Map<String, List<String>> result = new HashMap<>();
+    UserHandle userHandle = Process.myUserHandle();
+    for (String packageName : request.keySet()) {
+      List<String> permissions = request.get(packageName);
+      List<String> revokedPermissions = new ArrayList<>();
+      for (String permission : permissions) {
+        try {
+          packageManager.revokeRuntimePermission(packageName, permission, userHandle);
+          revokedPermissions.add(permission);
+        } catch (RuntimeException e) {
+          // Ignore errors.
+        }
+      }
+      if (!revokedPermissions.isEmpty()) {
+        result.put(packageName, revokedPermissions);
+      }
+    }
+    executor.execute(() -> callback.onRevokeRuntimePermissions(result));
+  }
+
+  private void ensureResolveInfoRegistered() {
+    Intent intent = new Intent(SERVICE_INTERFACE);
+    intent.setPackage("org.robolectric.permissioncontroller");
+    ResolveInfo resolveInfo = new ResolveInfo();
+    resolveInfo.serviceInfo = new ServiceInfo();
+    resolveInfo.serviceInfo.packageName = PERMISSION_CONTROLLER_PACKAGE_NAME;
+    resolveInfo.serviceInfo.name =
+        "org.robolectric.permissioncontroller.PermissionControllerManagerService";
+    shadowOf(packageManager).addResolveInfoForIntent(intent, resolveInfo);
+  }
+
+  @Resetter
+  public static void reset() {
+    resolveInfoRegistered.set(false);
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPhoneWindow.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPhoneWindow.java
index 3cd7ff8ff..5767d88fe 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPhoneWindow.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPhoneWindow.java
@@ -13,11 +13,12 @@ import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.util.reflector.ForType;
 
-/**
- * Shadow for PhoneWindow for APIs 23+
- */
-@Implements(className = "com.android.internal.policy.PhoneWindow", isInAndroidSdk = false,
-    minSdk = M, looseSignatures = true)
+/** Shadow for PhoneWindow for APIs 23+ */
+@Implements(
+    className = "com.android.internal.policy.PhoneWindow",
+    isInAndroidSdk = false,
+    minSdk = M,
+    looseSignatures = true)
 public class ShadowPhoneWindow extends ShadowWindow {
   protected @RealObject Window realWindow;
   protected boolean decorFitsSystemWindows = true;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPhoneWindowFor22.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPhoneWindowFor22.java
index f39f66e69..6d658e064 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPhoneWindowFor22.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPhoneWindowFor22.java
@@ -8,26 +8,30 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.util.reflector.ForType;
 
-/**
- * Shadow for the API 16-22 PhoneWindow.li
- */
-@Implements(className = "com.android.internal.policy.impl.PhoneWindow", maxSdk = LOLLIPOP_MR1,
-    looseSignatures = true, isInAndroidSdk = false)
+/** Shadow for the API 16-22 PhoneWindow.li */
+@Implements(
+    className = "com.android.internal.policy.impl.PhoneWindow",
+    maxSdk = LOLLIPOP_MR1,
+    looseSignatures = true,
+    isInAndroidSdk = false)
 public class ShadowPhoneWindowFor22 extends ShadowPhoneWindow {
 
-  @Override @Implementation(maxSdk = LOLLIPOP_MR1)
+  @Override
+  @Implementation(maxSdk = LOLLIPOP_MR1)
   public void setTitle(CharSequence title) {
     this.title = title;
     reflector(DirectPhoneWindowFor22Reflector.class, realWindow).setTitle(title);
   }
 
-  @Override @Implementation(maxSdk = LOLLIPOP_MR1)
+  @Override
+  @Implementation(maxSdk = LOLLIPOP_MR1)
   public void setBackgroundDrawable(Drawable drawable) {
     this.backgroundDrawable = drawable;
     reflector(DirectPhoneWindowFor22Reflector.class, realWindow).setBackgroundDrawable(drawable);
   }
 
-  @Override @Implementation(maxSdk = LOLLIPOP_MR1)
+  @Override
+  @Implementation(maxSdk = LOLLIPOP_MR1)
   protected int getOptionsPanelGravity() {
     return super.getOptionsPanelGravity();
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPicture.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPicture.java
index 20418669f..d49419802 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPicture.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPicture.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Picture;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPixelCopy.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPixelCopy.java
index f2bea724b..9f3c381b8 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPixelCopy.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPixelCopy.java
@@ -254,5 +254,4 @@ public class ShadowPixelCopy {
     @Constructor
     PixelCopy.Result newResult(int copyResult, Bitmap bitmap);
   }
-
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPlayerBase.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPlayerBase.java
index 58df3c3f5..5a5eaea53 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPlayerBase.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPlayerBase.java
@@ -8,7 +8,9 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.util.ReflectionHelpers;
 
-@Implements(className = "android.media.PlayerBase", isInAndroidSdk = false,
+@Implements(
+    className = "android.media.PlayerBase",
+    isInAndroidSdk = false,
     minSdk = Build.VERSION_CODES.N)
 public class ShadowPlayerBase {
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPolicyManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPolicyManager.java
index 04a0cd8e6..1912d4f6d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPolicyManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPolicyManager.java
@@ -11,10 +11,9 @@ import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
 @Implements(
-  className = "com.android.internal.policy.PolicyManager",
-  isInAndroidSdk = false,
-  maxSdk = LOLLIPOP_MR1
-)
+    className = "com.android.internal.policy.PolicyManager",
+    isInAndroidSdk = false,
+    maxSdk = LOLLIPOP_MR1)
 public class ShadowPolicyManager {
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPorterDuffColorFilter.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPorterDuffColorFilter.java
index 314510d73..255b5651b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPorterDuffColorFilter.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPorterDuffColorFilter.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.graphics.PorterDuff;
@@ -24,7 +23,7 @@ public class ShadowPorterDuffColorFilter {
   @Implementation
   public int getColor() {
 
-      return reflector(PorterDuffColorFilterReflector.class, realPorterDuffColorFilter).getColor();
+    return reflector(PorterDuffColorFilterReflector.class, realPorterDuffColorFilter).getColor();
   }
 
   /**
@@ -34,7 +33,7 @@ public class ShadowPorterDuffColorFilter {
   @Implementation
   public PorterDuff.Mode getMode() {
 
-      return reflector(PorterDuffColorFilterReflector.class, realPorterDuffColorFilter).getMode();
+    return reflector(PorterDuffColorFilterReflector.class, realPorterDuffColorFilter).getMode();
   }
 
   @ForType(PorterDuffColorFilter.class)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPosix.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPosix.java
index 5546266fe..ccf0c941d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPosix.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPosix.java
@@ -6,10 +6,8 @@ import android.system.StructStat;
 import java.io.File;
 import java.io.FileDescriptor;
 import java.time.Duration;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.util.ReflectionHelpers;
 
 /** Shadow for {@link libcore.io.Posix} */
 @Implements(
@@ -36,8 +34,7 @@ public class ShadowPosix {
       modifiedTime = Duration.ofMillis(file.lastModified()).getSeconds();
     }
 
-    if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.LOLLIPOP) {
-      return new StructStat(
+    return new StructStat(
         1, // st_dev
         0, // st_ino
         mode, // st_mode
@@ -52,16 +49,6 @@ public class ShadowPosix {
         0, // st_blksize
         0 // st_blocks
         );
-    } else {
-      Object structStat =
-          ReflectionHelpers.newInstance(
-              ReflectionHelpers.loadClass(
-                  ShadowPosix.class.getClassLoader(), "libcore.io.StructStat"));
-      setMode(mode, structStat);
-      setSize(size, structStat);
-      setModifiedTime(modifiedTime, structStat);
-      return structStat;
-    }
   }
 
   @Implementation
@@ -77,16 +64,4 @@ public class ShadowPosix {
   protected static Object fstat(FileDescriptor fd) throws ErrnoException {
     return stat(null);
   }
-
-  private static void setMode(int mode, Object structStat) {
-    ReflectionHelpers.setField(structStat, "st_mode", mode);
-  }
-
-  private static void setSize(long size, Object structStat) {
-    ReflectionHelpers.setField(structStat, "st_size", size);
-  }
-
-  private static void setModifiedTime(long modifiedTime, Object structStat) {
-    ReflectionHelpers.setField(structStat, "st_mtime", modifiedTime);
-  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPowerManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPowerManager.java
index 404479f90..ee0fd122d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPowerManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPowerManager.java
@@ -576,7 +576,7 @@ public class ShadowPowerManager {
   }
 
   @Implementation(minSdk = TIRAMISU)
-  protected void setLowPowerStandbyEnabled(boolean lowPowerStandbyEnabled) {
+  public void setLowPowerStandbyEnabled(boolean lowPowerStandbyEnabled) {
     this.lowPowerStandbyEnabled = lowPowerStandbyEnabled;
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPrecomputedText.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPrecomputedText.java
index 8e05d8977..adcc55e5c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPrecomputedText.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPrecomputedText.java
@@ -15,5 +15,4 @@ public class ShadowPrecomputedText {
   protected static long nInitBuilder() {
     return ++nativeCounter;
   }
-  
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowProcess.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowProcess.java
index c2f0b815b..9fea8a952 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowProcess.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowProcess.java
@@ -133,16 +133,12 @@ public class ShadowProcess {
     }
   }
 
-  /**
-   * Sets the identifier of this process.
-   */
+  /** Sets the identifier of this process. */
   public static void setUid(int uid) {
     ShadowProcess.uidOverride = uid;
   }
 
-  /**
-   * Sets the identifier of this process.
-   */
+  /** Sets the identifier of this process. */
   public static void setPid(int pid) {
     ShadowProcess.pid = pid;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowQueuedWork.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowQueuedWork.java
index 32f0796ae..4a6ec4b06 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowQueuedWork.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowQueuedWork.java
@@ -45,17 +45,21 @@ public class ShadowQueuedWork {
   @ForType(QueuedWork.class)
   interface _QueuedWork_ {
 
-    @Static @Accessor("sFinishers")
+    @Static
+    @Accessor("sFinishers")
     LinkedList<Runnable> getFinishers();
 
-    @Static @Accessor("sSingleThreadExecutor")
+    @Static
+    @Accessor("sSingleThreadExecutor")
     void setSingleThreadExecutor(ExecutorService o);
 
-    @Static @Accessor("sWork")
+    @Static
+    @Accessor("sWork")
     LinkedList<Runnable> getWork();
 
     // yep, it starts with 'm' but it's static
-    @Static @Accessor("mNumWaits")
+    @Static
+    @Accessor("mNumWaits")
     void setNumWaits(int i);
 
     @Static
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRangingResult.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRangingResult.java
index 2e2555854..58c191912 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRangingResult.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRangingResult.java
@@ -2,210 +2,29 @@ package org.robolectric.shadows;
 
 import android.net.MacAddress;
 import android.net.wifi.rtt.RangingResult;
-import android.net.wifi.rtt.ResponderLocation;
-import android.os.Build;
 import android.os.Build.VERSION_CODES;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implements;
-import org.robolectric.util.ReflectionHelpers;
 
-/** Shadow for {@link android.net.wifi.rtt.RangingResult}. */
+/**
+ * Shadow for {@link android.net.wifi.rtt.RangingResult}.
+ *
+ * @deprecated Use {link RangingResultBuilder} instead.
+ */
+@Deprecated
 @Implements(value = RangingResult.class, minSdk = VERSION_CODES.P)
 public class ShadowRangingResult {
 
   /**
-   * A builder for creating ShadowRangingResults. Status, macaddress, distance [mm] and timestamp
+   * A builder for creating ShadowRangingResults. Status, mac address, distance [mm] and timestamp
    * are all mandatory fields. Additional fields can be specified by setters. Use build() to return
    * the ShadowRangingResult object.
+   *
+   * @deprecated Use {link RangingResultBuilder} instead.
    */
-  public static class Builder {
-    // Required Values
-    private final int status;
-    private final MacAddress mac;
-    private final int distanceMm;
-    private final long timestampMillis;
-
-    // Optional Values
-    private int distanceStdDevMm = 0;
-    private int rssi = 0;
-    private int numAttemptedMeasurements = 0;
-    private int numSuccessfulMeasurements = 0;
-    private byte[] lci = new byte[0];
-    private byte[] lcr = new byte[0];
-    private ResponderLocation unverifiedResponderLocation = null;
-    private boolean is80211mcMeasurement = true;
-
+  @Deprecated
+  public static class Builder extends RangingResultBuilder {
     public Builder(int status, MacAddress mac, long timestampMillis, int distanceMm) {
-      this.status = status;
-      this.mac = mac;
-      this.timestampMillis = timestampMillis;
-      this.distanceMm = distanceMm;
-    }
-
-    public Builder setDistanceStandardDeviation(int stddev) {
-      this.distanceStdDevMm = stddev;
-      return this;
-    }
-
-    public Builder setRssi(int rssi) {
-      this.rssi = rssi;
-      return this;
-    }
-
-    public Builder setNumAttemptedMeasurements(int num) {
-      this.numAttemptedMeasurements = num;
-      return this;
-    }
-
-    public Builder setNumSuccessfulMeasurements(int num) {
-      this.numSuccessfulMeasurements = num;
-      return this;
-    }
-
-    public Builder setLci(byte[] lci) {
-      this.lci = lci;
-      return this;
-    }
-
-    public Builder setLcr(byte[] lcr) {
-      this.lcr = lcr;
-      return this;
+      super(status, mac, timestampMillis, distanceMm);
     }
-
-    public Builder setUnverifiedResponderLocation(ResponderLocation unverifiedResponderLocation) {
-      this.unverifiedResponderLocation = unverifiedResponderLocation;
-      return this;
-    }
-
-    public Builder setIs80211mcMeasurement(boolean is80211mcMeasurement) {
-      this.is80211mcMeasurement = is80211mcMeasurement;
-      return this;
-    }
-
-    public RangingResult build() {
-      if (RuntimeEnvironment.getApiLevel() > Build.VERSION_CODES.R) {
-        return asRangingResultS(
-            status,
-            mac,
-            distanceMm,
-            distanceStdDevMm,
-            rssi,
-            numAttemptedMeasurements,
-            numSuccessfulMeasurements,
-            lci,
-            lcr,
-            unverifiedResponderLocation,
-            timestampMillis,
-            is80211mcMeasurement);
-      }
-
-      if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.Q) {
-        return asRangingResultQ(
-            status,
-            mac,
-            distanceMm,
-            distanceStdDevMm,
-            rssi,
-            numAttemptedMeasurements,
-            numSuccessfulMeasurements,
-            lci,
-            lcr,
-            unverifiedResponderLocation,
-            timestampMillis);
-      }
-
-      return asRangingResultP(
-          status,
-          mac,
-          distanceMm,
-          distanceStdDevMm,
-          rssi,
-          numAttemptedMeasurements,
-          numSuccessfulMeasurements,
-          lci,
-          lcr,
-          timestampMillis);
-    }
-  }
-
-  private static RangingResult asRangingResultP(
-      int status,
-      MacAddress mac,
-      int distanceMm,
-      int distanceStdDevMm,
-      int rssi,
-      int numAttemptedMeasurements,
-      int numSuccessfulMeasurements,
-      byte[] lci,
-      byte[] lcr,
-      long timestampMillis) {
-    return ReflectionHelpers.callConstructor(
-        RangingResult.class,
-        ReflectionHelpers.ClassParameter.from(int.class, status),
-        ReflectionHelpers.ClassParameter.from(MacAddress.class, mac),
-        ReflectionHelpers.ClassParameter.from(int.class, distanceMm),
-        ReflectionHelpers.ClassParameter.from(int.class, distanceStdDevMm),
-        ReflectionHelpers.ClassParameter.from(int.class, rssi),
-        ReflectionHelpers.ClassParameter.from(int.class, numAttemptedMeasurements),
-        ReflectionHelpers.ClassParameter.from(int.class, numSuccessfulMeasurements),
-        ReflectionHelpers.ClassParameter.from(byte[].class, lci),
-        ReflectionHelpers.ClassParameter.from(byte[].class, lcr),
-        ReflectionHelpers.ClassParameter.from(long.class, timestampMillis));
-  }
-
-  private static RangingResult asRangingResultQ(
-      int status,
-      MacAddress mac,
-      int distanceMm,
-      int distanceStdDevMm,
-      int rssi,
-      int numAttemptedMeasurements,
-      int numSuccessfulMeasurements,
-      byte[] lci,
-      byte[] lcr,
-      ResponderLocation unverifiedResponderLocation,
-      long timestampMillis) {
-    return ReflectionHelpers.callConstructor(
-        RangingResult.class,
-        ReflectionHelpers.ClassParameter.from(int.class, status),
-        ReflectionHelpers.ClassParameter.from(MacAddress.class, mac),
-        ReflectionHelpers.ClassParameter.from(int.class, distanceMm),
-        ReflectionHelpers.ClassParameter.from(int.class, distanceStdDevMm),
-        ReflectionHelpers.ClassParameter.from(int.class, rssi),
-        ReflectionHelpers.ClassParameter.from(int.class, numAttemptedMeasurements),
-        ReflectionHelpers.ClassParameter.from(int.class, numSuccessfulMeasurements),
-        ReflectionHelpers.ClassParameter.from(byte[].class, lci),
-        ReflectionHelpers.ClassParameter.from(byte[].class, lcr),
-        ReflectionHelpers.ClassParameter.from(ResponderLocation.class, unverifiedResponderLocation),
-        ReflectionHelpers.ClassParameter.from(long.class, timestampMillis));
-  }
-
-  private static RangingResult asRangingResultS(
-      int status,
-      MacAddress mac,
-      int distanceMm,
-      int distanceStdDevMm,
-      int rssi,
-      int numAttemptedMeasurements,
-      int numSuccessfulMeasurements,
-      byte[] lci,
-      byte[] lcr,
-      ResponderLocation unverifiedResponderLocation,
-      long timestamp,
-      boolean is80211mcMeasurement) {
-    return ReflectionHelpers.callConstructor(
-        RangingResult.class,
-        ReflectionHelpers.ClassParameter.from(int.class, status),
-        ReflectionHelpers.ClassParameter.from(MacAddress.class, mac),
-        ReflectionHelpers.ClassParameter.from(int.class, distanceMm),
-        ReflectionHelpers.ClassParameter.from(int.class, distanceStdDevMm),
-        ReflectionHelpers.ClassParameter.from(int.class, rssi),
-        ReflectionHelpers.ClassParameter.from(int.class, numAttemptedMeasurements),
-        ReflectionHelpers.ClassParameter.from(int.class, numSuccessfulMeasurements),
-        ReflectionHelpers.ClassParameter.from(byte[].class, lci),
-        ReflectionHelpers.ClassParameter.from(byte[].class, lcr),
-        ReflectionHelpers.ClassParameter.from(ResponderLocation.class, unverifiedResponderLocation),
-        ReflectionHelpers.ClassParameter.from(long.class, timestamp),
-        ReflectionHelpers.ClassParameter.from(boolean.class, is80211mcMeasurement));
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRemoteCallbackList.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRemoteCallbackList.java
index 84e41c1a2..b6b7d5227 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRemoteCallbackList.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRemoteCallbackList.java
@@ -24,7 +24,8 @@ public class ShadowRemoteCallbackList<E extends IInterface> {
       this.cookie = cookie;
     }
 
-    @Override public void binderDied() {
+    @Override
+    public void binderDied() {
       synchronized (callbacks) {
         callbacks.remove(callback.asBinder());
       }
@@ -137,4 +138,4 @@ public class ShadowRemoteCallbackList<E extends IInterface> {
   protected int getRegisteredCallbackCount() {
     return callbacks.size();
   }
-}
\ No newline at end of file
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRenderNode.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRenderNode.java
index 316284435..b87b9892c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRenderNode.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRenderNode.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 
@@ -9,11 +8,7 @@ import android.graphics.Matrix;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
-@Implements(
-    className = "android.view.RenderNode",
-    isInAndroidSdk = false,
-    minSdk = LOLLIPOP,
-    maxSdk = P)
+@Implements(className = "android.view.RenderNode", isInAndroidSdk = false, maxSdk = P)
 public class ShadowRenderNode {
   private static final float NON_ZERO_EPSILON = 0.001f;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRenderNodeAnimator.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRenderNodeAnimator.java
index 5e958be4e..cc7c758c1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRenderNodeAnimator.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRenderNodeAnimator.java
@@ -55,7 +55,7 @@ public class ShadowRenderNodeAnimator {
   @Implementation
   public void doStart() {
     reflector(RenderNodeAnimatorReflector.class, realObject).doStart();
-    if (getApiLevel() <= LOLLIPOP) {
+    if (getApiLevel() == LOLLIPOP) {
       schedule();
     }
   }
@@ -65,7 +65,7 @@ public class ShadowRenderNodeAnimator {
     RenderNodeAnimatorReflector renderNodeReflector =
         reflector(RenderNodeAnimatorReflector.class, realObject);
     renderNodeReflector.cancel();
-    if (getApiLevel() <= LOLLIPOP) {
+    if (getApiLevel() == LOLLIPOP) {
       int state = renderNodeReflector.getState();
       if (state != STATE_FINISHED) {
         // In 21, RenderNodeAnimator only calls nEnd, it doesn't call the Java end method. Thus, it
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResolveInfo.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResolveInfo.java
index 0ff822388..adca093f2 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResolveInfo.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResolveInfo.java
@@ -3,7 +3,6 @@ package org.robolectric.shadows;
 import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.ResolveInfo;
-import android.os.Build;
 
 /** Utilities for {@link ResolveInfo}. */
 // TODO: Create a ResolveInfoBuilder in androidx and migrate factory methods there.
@@ -28,7 +27,8 @@ public class ShadowResolveInfo {
    * @param activityName Activity name.
    * @return Resolve info instance.
    */
-  public static ResolveInfo newResolveInfo(String displayName, String packageName, String activityName) {
+  public static ResolveInfo newResolveInfo(
+      String displayName, String packageName, String activityName) {
     ResolveInfo resInfo = new ResolveInfo();
     ActivityInfo actInfo = new ActivityInfo();
     actInfo.applicationInfo = new ApplicationInfo();
@@ -46,23 +46,7 @@ public class ShadowResolveInfo {
    * <p>Note that this is shallow copy as performed by the copy constructor existing in API 17.
    */
   public static ResolveInfo newResolveInfo(ResolveInfo orig) {
-    ResolveInfo copy;
-    if (Build.VERSION.SDK_INT >= 17) {
-      copy = new ResolveInfo(orig);
-    } else {
-      copy = new ResolveInfo();
-      copy.activityInfo = orig.activityInfo;
-      copy.serviceInfo = orig.serviceInfo;
-      copy.filter = orig.filter;
-      copy.priority = orig.priority;
-      copy.preferredOrder = orig.preferredOrder;
-      copy.match = orig.match;
-      copy.specificIndex = orig.specificIndex;
-      copy.labelRes = orig.labelRes;
-      copy.nonLocalizedLabel = orig.nonLocalizedLabel;
-      copy.icon = orig.icon;
-      copy.resolvePackageName = orig.resolvePackageName;
-    }
+    ResolveInfo copy = new ResolveInfo(orig);
     // For some reason isDefault field is not copied by the copy constructor.
     copy.isDefault = orig.isDefault;
     return copy;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResources.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResources.java
index e9b3f77e5..bd0d19df2 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResources.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResources.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-
 import static android.os.Build.VERSION_CODES.N_MR1;
 import static android.os.Build.VERSION_CODES.Q;
 import static org.robolectric.util.reflector.Reflector.reflector;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResourcesImpl.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResourcesImpl.java
index 7cfe1954d..14790fb9f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResourcesImpl.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResourcesImpl.java
@@ -7,7 +7,7 @@ import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.List;
 
-abstract public class ShadowResourcesImpl {
+public abstract class ShadowResourcesImpl {
 
   public static class Picker extends ResourceModeShadowPicker<ShadowResourcesImpl> {
 
@@ -31,7 +31,8 @@ abstract public class ShadowResourcesImpl {
     List<LongSparseArray<?>> resettableArrays = new ArrayList<>();
     Field[] allFields = Resources.class.getDeclaredFields();
     for (Field field : allFields) {
-      if (Modifier.isStatic(field.getModifiers()) && field.getType().equals(LongSparseArray.class)) {
+      if (Modifier.isStatic(field.getModifiers())
+          && field.getType().equals(LongSparseArray.class)) {
         field.setAccessible(true);
         try {
           LongSparseArray<?> longSparseArray = (LongSparseArray<?>) field.get(null);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResourcesManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResourcesManager.java
index d9651f6c9..21b5fb395 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResourcesManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResourcesManager.java
@@ -21,11 +21,9 @@ public class ShadowResourcesManager {
     reflector(_ResourcesManager_.class).setResourcesManager(null);
   }
 
-  /**
-   * Exposes {@link ResourcesManager#applyCompatConfigurationLocked(int, Configuration)}.
-   */
-  public boolean callApplyConfigurationToResourcesLocked(Configuration configuration,
-      CompatibilityInfo compatibilityInfo) {
+  /** Exposes {@link ResourcesManager#applyCompatConfigurationLocked(int, Configuration)}. */
+  public boolean callApplyConfigurationToResourcesLocked(
+      Configuration configuration, CompatibilityInfo compatibilityInfo) {
     return reflector(_ResourcesManager_.class, realResourcesManager)
         .applyConfigurationToResourcesLocked(configuration, compatibilityInfo);
   }
@@ -35,7 +33,8 @@ public class ShadowResourcesManager {
   private interface _ResourcesManager_ {
     boolean applyConfigurationToResourcesLocked(Configuration config, CompatibilityInfo compat);
 
-    @Static @Accessor("sResourcesManager")
+    @Static
+    @Accessor("sResourcesManager")
     void setResourcesManager(ResourcesManager resourcesManager);
   }
-}
\ No newline at end of file
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRestrictionsManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRestrictionsManager.java
index 5334dd9ca..cb52b9a2c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRestrictionsManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRestrictionsManager.java
@@ -1,19 +1,18 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
-
 import android.content.RestrictionsManager;
 import android.os.Bundle;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
 /** Shadow of {@link android.content.RestrictionsManager}. */
-@Implements(value = RestrictionsManager.class, minSdk=LOLLIPOP)
+@Implements(value = RestrictionsManager.class)
 public class ShadowRestrictionsManager {
   private Bundle applicationRestrictions;
 
   /**
-   * Sets the application restrictions as returned by {@link RestrictionsManager#getApplicationRestrictions()}.
+   * Sets the application restrictions as returned by {@link
+   * RestrictionsManager#getApplicationRestrictions()}.
    */
   public void setApplicationRestrictions(Bundle applicationRestrictions) {
     this.applicationRestrictions = applicationRestrictions;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResultReceiver.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResultReceiver.java
index 6ee4aa0c3..fed0e4980 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResultReceiver.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowResultReceiver.java
@@ -14,7 +14,9 @@ public class ShadowResultReceiver {
 
   @Implementation
   protected void send(int resultCode, android.os.Bundle resultData) {
-    ReflectionHelpers.callInstanceMethod(realResultReceiver, "onReceiveResult",
+    ReflectionHelpers.callInstanceMethod(
+        realResultReceiver,
+        "onReceiveResult",
         ClassParameter.from(Integer.TYPE, resultCode),
         ClassParameter.from(Bundle.class, resultData));
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRotationWatcher.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRotationWatcher.java
index 5ade25036..6c7262fcc 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRotationWatcher.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRotationWatcher.java
@@ -6,11 +6,11 @@ import com.android.internal.policy.PhoneWindow;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
-/**
- * Shadow for RotationWatcher for API 23+
- */
-@Implements(className = "com.android.internal.policy.PhoneWindow$RotationWatcher",
-    isInAndroidSdk = false, minSdk = M)
+/** Shadow for RotationWatcher for API 23+ */
+@Implements(
+    className = "com.android.internal.policy.PhoneWindow$RotationWatcher",
+    isInAndroidSdk = false,
+    minSdk = M)
 public class ShadowRotationWatcher {
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRotationWatcherFor22.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRotationWatcherFor22.java
index b27c7d61f..21c5042e1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRotationWatcherFor22.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRotationWatcherFor22.java
@@ -5,11 +5,12 @@ import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
-/**
- * Shadow for RotationWatcher for API 16-22
- */
-@Implements(className = "com.android.internal.policy.impl.PhoneWindow$RotationWatcher",
-    isInAndroidSdk = false, maxSdk = LOLLIPOP_MR1, looseSignatures = true)
+/** Shadow for RotationWatcher for API 16-22 */
+@Implements(
+    className = "com.android.internal.policy.impl.PhoneWindow$RotationWatcher",
+    isInAndroidSdk = false,
+    maxSdk = LOLLIPOP_MR1,
+    looseSignatures = true)
 public class ShadowRotationWatcherFor22 {
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSQLiteOpenHelper.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSQLiteOpenHelper.java
index a3208e034..510601aad 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSQLiteOpenHelper.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSQLiteOpenHelper.java
@@ -7,8 +7,8 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
 /**
- * Avoid calls to setIdleConnectionTimeout.
- * They shouldn't matter for tests, but sometimes induced deadlocks.
+ * Avoid calls to setIdleConnectionTimeout. They shouldn't matter for tests, but sometimes induced
+ * deadlocks.
  */
 @Implements(SQLiteOpenHelper.class)
 public class ShadowSQLiteOpenHelper {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowScanResult.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowScanResult.java
index 2d0ccef53..3294521c4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowScanResult.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowScanResult.java
@@ -44,7 +44,7 @@ public class ShadowScanResult {
       if (is80211McRTTResponder) {
         scanResult.setFlag(ScanResult.FLAG_80211mc_RESPONDER);
       } else {
-      scanResult.setFlag(0);
+        scanResult.setFlag(0);
       }
       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
         scanResult.informationElements = new ScanResult.InformationElement[0];
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSecureElementService.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSecureElementService.java
new file mode 100644
index 000000000..7a795bd6d
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSecureElementService.java
@@ -0,0 +1,257 @@
+package org.robolectric.shadows;
+
+import android.os.Build.VERSION_CODES;
+import android.os.IBinder;
+import android.se.omapi.ISecureElementChannel;
+import android.se.omapi.ISecureElementListener;
+import android.se.omapi.ISecureElementReader;
+import android.se.omapi.ISecureElementService;
+import android.se.omapi.ISecureElementSession;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
+
+/** Shadow of {@link SecureElementService} */
+@Implements(
+    value = ISecureElementService.Stub.class,
+    minSdk = VERSION_CODES.P,
+    isInAndroidSdk = false)
+public class ShadowSecureElementService {
+
+  private static final List<MockApplet> mockApplets = new ArrayList<>(0);
+
+  private ShadowSecureElementService() {}
+
+  @Implementation
+  protected static ISecureElementService asInterface(IBinder binder) {
+    return new SecureElementService();
+  }
+
+  @Resetter
+  public static void reset() {
+    mockApplets.clear();
+  }
+
+  /**
+   * Add a Reader with the specified name. Creates a reader with the specified name and returns the
+   * shadow of that reader which may be used to further configure the expected behavior by adding
+   * fake Applets.
+   */
+  public static void addMockApplet(MockApplet applet) {
+    if (getMockApplet(applet.readerName, applet.aid) != null) {
+      throw new IllegalStateException("Applet with that reader name and aid already exists");
+    }
+    mockApplets.add(applet);
+  }
+
+  private static MockApplet getMockApplet(String readerName, byte[] aid) {
+    for (MockApplet applet : mockApplets) {
+      if (applet.readerName.equals(readerName) && Arrays.equals(aid, applet.aid)) {
+        return applet;
+      }
+    }
+    return null;
+  }
+
+  /** Provide fake SE applet behavior */
+  public static class MockApplet {
+    private final byte[] aid;
+    private final String readerName;
+    private byte[] selectResponse = {(byte) 0x90, (byte) 0x00};
+    private final List<byte[]> adpuRequests = new ArrayList<>(0);
+    private final List<byte[]> adpuResponses = new ArrayList<>(0);
+
+    public MockApplet(String readerName, byte[] aid) {
+      this.readerName = readerName;
+      this.aid = aid;
+    }
+
+    public void addApduResponse(byte[] apduResponse) {
+      adpuResponses.add(apduResponse);
+    }
+
+    public void setSelectResponse(byte[] selectResponse) {
+      this.selectResponse = selectResponse;
+    }
+
+    public byte[] getSelectResponse() {
+      return selectResponse;
+    }
+
+    public List<byte[]> getAdpuRequests() {
+      return new ArrayList<>(adpuRequests);
+    }
+
+    public byte[] processRequestApdu(byte[] request) {
+      adpuRequests.add(request);
+      if (adpuResponses.isEmpty()) {
+        return null;
+      }
+      return adpuResponses.remove(0);
+    }
+  }
+
+  private static class SecureElementService extends ISecureElementService.Default {
+
+    @Override
+    public String[] getReaders() {
+      String[] readerNames = new String[mockApplets.size()];
+      for (int i = 0; i < mockApplets.size(); i++) {
+        readerNames[i] = mockApplets.get(i).readerName;
+      }
+      return readerNames;
+    }
+
+    @Override
+    public ISecureElementReader getReader(String reader) {
+      return new SecureElementReader(reader);
+    }
+
+    @Override
+    public boolean[] isNfcEventAllowed(
+        String reader, byte[] aid, String[] packageNames, int userId) {
+      throw new RuntimeException("UNIMPLEMENTED");
+    }
+  }
+
+  private static class SecureElementReader extends ISecureElementReader.Default {
+
+    private final String name;
+    private final List<SecureElementSession> sessions = new ArrayList<>(0);
+
+    SecureElementReader(String name) {
+      this.name = name;
+    }
+
+    @Override
+    public boolean isSecureElementPresent() {
+      return true;
+    }
+
+    @Override
+    public ISecureElementSession openSession() {
+      SecureElementSession session = new SecureElementSession(this);
+      sessions.add(session);
+      return session;
+    }
+
+    @Override
+    public void closeSessions() {
+      for (SecureElementSession session : sessions) {
+        session.close();
+      }
+    }
+
+    @Override
+    public boolean reset() {
+      closeSessions();
+      return true;
+    }
+
+    private MockApplet getMockApplet(byte[] aid) {
+      return ShadowSecureElementService.getMockApplet(name, aid);
+    }
+  }
+
+  private static class SecureElementSession extends ISecureElementSession.Default {
+
+    private final SecureElementReader reader;
+    private final List<SecureElementChannel> channels = new ArrayList<>(0);
+    private boolean isClosed;
+
+    SecureElementSession(SecureElementReader reader) {
+      this.reader = reader;
+    }
+
+    @Override
+    public byte[] getAtr() {
+      throw new RuntimeException();
+    }
+
+    @Override
+    public void close() {
+      isClosed = true;
+    }
+
+    @Override
+    public void closeChannels() {
+      for (SecureElementChannel channel : channels) {
+        channel.close();
+      }
+    }
+
+    @Override
+    public boolean isClosed() {
+      return isClosed;
+    }
+
+    @Override
+    public ISecureElementChannel openBasicChannel(
+        byte[] aid, byte p2, ISecureElementListener listener) {
+      return openChannel(aid, p2, listener, true);
+    }
+
+    @Override
+    public ISecureElementChannel openLogicalChannel(
+        byte[] aid, byte p2, ISecureElementListener listener) {
+      return openChannel(aid, p2, listener, false);
+    }
+
+    private ISecureElementChannel openChannel(
+        byte[] aid, byte p2, ISecureElementListener listener, boolean isBasicChannel) {
+      MockApplet mockApplet = reader.getMockApplet(aid);
+      if (mockApplet == null) {
+        return null;
+      }
+      SecureElementChannel channel = new SecureElementChannel(mockApplet, isBasicChannel);
+      channels.add(channel);
+      return channel;
+    }
+  }
+
+  private static class SecureElementChannel extends ISecureElementChannel.Default {
+
+    private final MockApplet mockApplet;
+    private final boolean isBasicChannel;
+    private boolean isClosed;
+
+    public SecureElementChannel(MockApplet mockApplet, boolean isBasicChannel) {
+      this.mockApplet = mockApplet;
+      this.isBasicChannel = isBasicChannel;
+    }
+
+    @Override
+    public void close() {
+      isClosed = true;
+      throw new RuntimeException();
+    }
+
+    @Override
+    public boolean isClosed() {
+      return isClosed;
+    }
+
+    @Override
+    public boolean isBasicChannel() {
+      return isBasicChannel;
+    }
+
+    @Override
+    public byte[] getSelectResponse() {
+      return mockApplet.getSelectResponse();
+    }
+
+    @Override
+    public byte[] transmit(byte[] command) {
+      return mockApplet.processRequestApdu(command);
+    }
+
+    @Override
+    public boolean selectNext() {
+      throw new RuntimeException("UNIMPLEMENTED");
+    }
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSensorManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSensorManager.java
index 4cea614d2..1a4cc863d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSensorManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSensorManager.java
@@ -82,7 +82,9 @@ public class ShadowSensorManager {
     return ImmutableList.copyOf(sensorMap.get(type));
   }
 
-  /** @param handler is ignored. */
+  /**
+   * @param handler is ignored.
+   */
   @Implementation
   protected boolean registerListener(
       SensorEventListener listener, Sensor sensor, int rate, Handler handler) {
@@ -242,7 +244,8 @@ public class ShadowSensorManager {
 
   @Implementation(minSdk = O)
   protected Object createDirectChannel(MemoryFile mem) {
-    return ReflectionHelpers.callConstructor(SensorDirectChannel.class,
+    return ReflectionHelpers.callConstructor(
+        SensorDirectChannel.class,
         ClassParameter.from(SensorManager.class, realObject),
         ClassParameter.from(int.class, 0),
         ClassParameter.from(int.class, SensorDirectChannel.TYPE_MEMORY_FILE),
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowService.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowService.java
index d213750c6..bbaa76e2d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowService.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowService.java
@@ -116,8 +116,8 @@ public class ShadowService extends ShadowContextWrapper {
   }
 
   /**
-   * Returns whether the last foreground notification is still "attached" to the service,
-   * meaning it will be removed when the service is destroyed.
+   * Returns whether the last foreground notification is still "attached" to the service, meaning it
+   * will be removed when the service is destroyed.
    */
   public boolean isLastForegroundNotificationAttached() {
     return lastForegroundNotificationAttached;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowServiceManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowServiceManager.java
index 11dc587bc..f9fe035f7 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowServiceManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowServiceManager.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.N_MR1;
@@ -41,6 +40,7 @@ import android.content.IClipboard;
 import android.content.IRestrictionsManager;
 import android.content.integrity.IAppIntegrityManager;
 import android.content.pm.ICrossProfileApps;
+import android.content.pm.ILauncherApps;
 import android.content.pm.IShortcutService;
 import android.content.rollback.IRollbackManager;
 import android.hardware.ISensorPrivacyManager;
@@ -64,6 +64,7 @@ import android.net.IVpnManager;
 import android.net.nsd.INsdManager;
 import android.net.vcn.IVcnManagementService;
 import android.net.wifi.IWifiManager;
+import android.net.wifi.IWifiScanner;
 import android.net.wifi.aware.IWifiAwareManager;
 import android.net.wifi.p2p.IWifiP2pManager;
 import android.net.wifi.rtt.IWifiRttManager;
@@ -223,30 +224,38 @@ public class ShadowServiceManager {
     addBinderService(binderServices, Context.APP_OPS_SERVICE, IAppOpsService.class);
     addBinderService(binderServices, "batteryproperties", IBatteryPropertiesRegistrar.class);
 
-    if (RuntimeEnvironment.getApiLevel() >= LOLLIPOP) {
-      addBinderService(binderServices, Context.RESTRICTIONS_SERVICE, IRestrictionsManager.class);
-      addBinderService(binderServices, Context.TRUST_SERVICE, ITrustManager.class);
-      addBinderService(binderServices, Context.JOB_SCHEDULER_SERVICE, IJobScheduler.class);
-      addBinderService(binderServices, Context.NETWORK_SCORE_SERVICE, INetworkScoreService.class);
-      addBinderService(binderServices, Context.USAGE_STATS_SERVICE, IUsageStatsManager.class);
-      addBinderService(binderServices, Context.MEDIA_ROUTER_SERVICE, IMediaRouterService.class);
-      addBinderService(
-          binderServices,
-          Context.MEDIA_SESSION_SERVICE,
-          ISessionManager.class,
-          BinderProxyType.DEEP);
-      addBinderService(
-          binderServices,
-          Context.VOICE_INTERACTION_MANAGER_SERVICE,
-          IVoiceInteractionManagerService.class,
-          BinderProxyType.DEEP);
-    }
+    addBinderService(binderServices, Context.RESTRICTIONS_SERVICE, IRestrictionsManager.class);
+    addBinderService(binderServices, Context.TRUST_SERVICE, ITrustManager.class);
+    addBinderService(binderServices, Context.JOB_SCHEDULER_SERVICE, IJobScheduler.class);
+    addBinderService(binderServices, Context.NETWORK_SCORE_SERVICE, INetworkScoreService.class);
+    addBinderService(binderServices, Context.USAGE_STATS_SERVICE, IUsageStatsManager.class);
+    addBinderService(binderServices, Context.MEDIA_ROUTER_SERVICE, IMediaRouterService.class);
+    addBinderService(
+        binderServices, Context.MEDIA_SESSION_SERVICE, ISessionManager.class, BinderProxyType.DEEP);
+    addBinderService(
+        binderServices,
+        Context.VOICE_INTERACTION_MANAGER_SERVICE,
+        IVoiceInteractionManagerService.class,
+        BinderProxyType.DEEP);
+    addBinderService(
+        binderServices,
+        Context.LAUNCHER_APPS_SERVICE,
+        ILauncherApps.class,
+        BinderProxyType.DELEGATING,
+        new LauncherAppsDelegate());
+
     if (RuntimeEnvironment.getApiLevel() >= M) {
       addBinderService(binderServices, Context.FINGERPRINT_SERVICE, IFingerprintService.class);
     }
     if (RuntimeEnvironment.getApiLevel() >= N) {
       addBinderService(binderServices, Context.CONTEXTHUB_SERVICE, IContextHubService.class);
       addBinderService(binderServices, Context.SOUND_TRIGGER_SERVICE, ISoundTriggerService.class);
+      addBinderService(
+          binderServices,
+          Context.WIFI_SCANNING_SERVICE,
+          IWifiScanner.class,
+          BinderProxyType.DELEGATING,
+          new WifiScannerDelegate());
     }
     if (RuntimeEnvironment.getApiLevel() >= N_MR1) {
       addBinderService(binderServices, Context.SHORTCUT_SERVICE, IShortcutService.class);
@@ -311,6 +320,7 @@ public class ShadowServiceManager {
       addBinderService(
           binderServices, Context.WEARABLE_SENSING_SERVICE, IWearableSensingManager.class);
     }
+
     return binderServices;
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSettings.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSettings.java
index 3df973d66..e2f925e1f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSettings.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSettings.java
@@ -256,8 +256,7 @@ public class ShadowSettings {
 
     @Implementation
     protected static int getInt(ContentResolver cr, String name) throws SettingNotFoundException {
-      if (Settings.Secure.LOCATION_MODE.equals(name)
-          && RuntimeEnvironment.getApiLevel() < P) {
+      if (Settings.Secure.LOCATION_MODE.equals(name) && RuntimeEnvironment.getApiLevel() < P) {
         // Map from to underlying location provider storage API to location mode
         return reflector(SettingsSecureReflector.class).getLocationModeForUser(cr, 0);
       }
@@ -267,8 +266,7 @@ public class ShadowSettings {
 
     @Implementation
     protected static int getInt(ContentResolver cr, String name, int def) {
-      if (Settings.Secure.LOCATION_MODE.equals(name)
-          && RuntimeEnvironment.getApiLevel() < P) {
+      if (Settings.Secure.LOCATION_MODE.equals(name) && RuntimeEnvironment.getApiLevel() < P) {
         // Map from to underlying location provider storage API to location mode
         return reflector(SettingsSecureReflector.class).getLocationModeForUser(cr, 0);
       }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSigningInfo.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSigningInfo.java
index 9e1d0f57b..be9912f65 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSigningInfo.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSigningInfo.java
@@ -34,17 +34,14 @@ public class ShadowSigningInfo {
   private Signature[] pastSigningCertificates;
 
   /**
-   * Set the current Signatures for this package. If signatures has a size greater than 1,
-   * {@link #hasMultipleSigners} will be true and {@link #getSigningCertificateHistory} will return
-   * null.
+   * Set the current Signatures for this package. If signatures has a size greater than 1, {@link
+   * #hasMultipleSigners} will be true and {@link #getSigningCertificateHistory} will return null.
    */
   public void setSignatures(Signature[] signatures) {
     this.signatures = signatures;
   }
 
-  /**
-   * Sets the history of Signatures for this package.
-   */
+  /** Sets the history of Signatures for this package. */
   public void setPastSigningCertificates(Signature[] pastSigningCertificates) {
     this.pastSigningCertificates = pastSigningCertificates;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSmsManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSmsManager.java
index b76edc3f1..1a72f6885 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSmsManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSmsManager.java
@@ -119,7 +119,9 @@ public class ShadowSmsManager {
         new TextMultipartParams(destinationAddress, scAddress, parts, sentIntents, deliveryIntents);
   }
 
-  /** @return Parameters for last call to {@link #sendDataMessage}. */
+  /**
+   * @return Parameters for last call to {@link #sendDataMessage}.
+   */
   public DataMessageParams getLastSentDataMessageParams() {
     return lastDataParams;
   }
@@ -129,7 +131,9 @@ public class ShadowSmsManager {
     lastDataParams = null;
   }
 
-  /** @return Parameters for last call to {@link #sendTextMessage}. */
+  /**
+   * @return Parameters for last call to {@link #sendTextMessage}.
+   */
   public TextSmsParams getLastSentTextMessageParams() {
     return lastTextSmsParams;
   }
@@ -139,7 +143,9 @@ public class ShadowSmsManager {
     lastTextSmsParams = null;
   }
 
-  /** @return Parameters for last call to {@link #sendMultipartTextMessage}. */
+  /**
+   * @return Parameters for last call to {@link #sendMultipartTextMessage}.
+   */
   public TextMultipartParams getLastSentMultipartTextMessageParams() {
     return lastTextMultipartParams;
   }
@@ -389,7 +395,9 @@ public class ShadowSmsManager {
             contentUri, locationUrl, configOverrides, sentIntent, messageId);
   }
 
-  /** @return Parameters for last call to {@link #sendMultimediaMessage}. */
+  /**
+   * @return Parameters for last call to {@link #sendMultimediaMessage}.
+   */
   public SendMultimediaMessageParams getLastSentMultimediaMessageParams() {
     return lastSentMultimediaMessageParams;
   }
@@ -399,7 +407,9 @@ public class ShadowSmsManager {
     lastSentMultimediaMessageParams = null;
   }
 
-  /** @return Parameters for last call to {@link #downloadMultimediaMessage}. */
+  /**
+   * @return Parameters for last call to {@link #downloadMultimediaMessage}.
+   */
   public DownloadMultimediaMessageParams getLastDownloadedMultimediaMessageParams() {
     return lastDownloadedMultimediaMessageParams;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpellChecker.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpellChecker.java
index d5f6b21f0..47eafecfa 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpellChecker.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpellChecker.java
@@ -4,5 +4,4 @@ import android.widget.SpellChecker;
 import org.robolectric.annotation.Implements;
 
 @Implements(value = SpellChecker.class, callThroughByDefault = false, isInAndroidSdk = false)
-public class ShadowSpellChecker {
-}
+public class ShadowSpellChecker {}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatFs.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatFs.java
index 06f0de565..469f623fa 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatFs.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatFs.java
@@ -69,7 +69,7 @@ public class ShadowStatFs {
   @Implementation
   protected void restat(String path) {
     Map.Entry<String, Stats> mapEntry = stats.floorEntry(path);
-    for (;;) {
+    for (; ; ) {
       // We will hit all matching paths, longest one first. We may hit non-matching paths before we
       // find the right one.
       if (mapEntry == null) {
@@ -116,7 +116,7 @@ public class ShadowStatFs {
 
   /**
    * Register stats for a path, which will be used when a matching {@link StatFs} instance is
-   * created.  A {@link StatFs} instance matches if it extends path. If several registered paths
+   * created. A {@link StatFs} instance matches if it extends path. If several registered paths
    * match, we pick the longest one.
    *
    * @param path path to the file
@@ -124,8 +124,8 @@ public class ShadowStatFs {
    * @param freeBlocks number of free blocks
    * @param availableBlocks number of available blocks
    */
-  public static void registerStats(String path, int blockCount, int freeBlocks,
-      int availableBlocks) {
+  public static void registerStats(
+      String path, int blockCount, int freeBlocks, int availableBlocks) {
     stats.put(path, new Stats(blockCount, freeBlocks, availableBlocks));
   }
 
@@ -158,6 +158,7 @@ public class ShadowStatFs {
       this.freeBlocks = freeBlocks;
       this.availableBlocks = availableBlocks;
     }
+
     int blockCount, freeBlocks, availableBlocks;
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStaticLayout.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStaticLayout.java
index 32fcf2aba..f483c3114 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStaticLayout.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStaticLayout.java
@@ -9,6 +9,7 @@ import static org.robolectric.util.reflector.Reflector.reflector;
 import android.text.DynamicLayout;
 import android.text.StaticLayout;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -18,7 +19,7 @@ import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
 
 /** Shadow for android.text.StaticLayout */
-@Implements(value = StaticLayout.class, looseSignatures = true)
+@Implements(value = StaticLayout.class)
 public class ShadowStaticLayout {
 
   @ForType(className = "android.text.StaticLayout$LineBreaks")
@@ -45,36 +46,36 @@ public class ShadowStaticLayout {
   @HiddenApi
   @Implementation(minSdk = M, maxSdk = O_MR1)
   public static int nComputeLineBreaks(
-      Object nativePtr,
-      Object recycle,
-      Object recycleBreaks,
-      Object recycleWidths,
-      Object recycleFlags,
-      Object recycleLength) {
+      long nativePtr,
+      @ClassName("android.text.StaticLayout$LineBreaks") Object recycle,
+      int[] recycleBreaks,
+      float[] recycleWidths,
+      int[] recycleFlags,
+      int recycleLength) {
     return 1;
   }
 
   @HiddenApi
   @Implementation(minSdk = P, maxSdk = P)
   protected static int nComputeLineBreaks(
-      Object nativePtr,
-      Object text,
-      Object measuredTextPtr,
-      Object length,
-      Object firstWidth,
-      Object firstWidthLineCount,
-      Object restWidth,
-      Object variableTabStops,
-      Object defaultTabStop,
-      Object indentsOffset,
-      Object recycle,
-      Object recycleLength,
-      Object recycleBreaks,
-      Object recycleWidths,
-      Object recycleAscents,
-      Object recycleDescents,
-      Object recycleFlags,
-      Object charWidths) {
+      long nativePtr,
+      char[] text,
+      long measuredTextPtr,
+      int length,
+      float firstWidth,
+      int firstWidthLineCount,
+      float restWidth,
+      int[] variableTabStops,
+      int defaultTabStop,
+      int indentsOffset,
+      @ClassName("android.text.StaticLayout$LineBreaks") Object recycle,
+      int recycleLength,
+      int[] recycleBreaks,
+      float[] recycleWidths,
+      float[] recycleAscents,
+      float[] recycleDescents,
+      int[] recycleFlags,
+      float[] charWidths) {
     reflector(LineBreaksReflector.class, recycle).setBreaks(new int[] {((char[]) text).length});
     return 1;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStorageManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStorageManager.java
index 0a79ee7c3..e86fb5401 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStorageManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStorageManager.java
@@ -19,9 +19,7 @@ import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.shadow.api.Shadow;
 
-/**
- * Fake implementation of {@link android.os.storage.StorageManager}
- */
+/** Fake implementation of {@link android.os.storage.StorageManager} */
 @Implements(StorageManager.class)
 public class ShadowStorageManager {
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStringBlock.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStringBlock.java
index e05ffc701..892f9ce08 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStringBlock.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStringBlock.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-
 import static org.robolectric.res.android.Util.SIZEOF_INT;
 
 import java.nio.ByteBuffer;
@@ -11,11 +10,13 @@ import org.robolectric.annotation.Resetter;
 import org.robolectric.res.android.ResStringPool;
 import org.robolectric.res.android.ResourceTypes.ResStringPool_span;
 
-@Implements(className = "android.content.res.StringBlock", isInAndroidSdk = false)
-public class ShadowStringBlock {
+@Implements(
+    className = "android.content.res.StringBlock",
+    isInAndroidSdk = false,
+    shadowPicker = ShadowBaseStringBlock.Picker.class)
+public class ShadowStringBlock extends ShadowBaseStringBlock {
 
-  @RealObject
-  Object realObject;
+  @RealObject Object realObject;
 
   @Implementation
   protected static long nativeCreate(byte[] data, int offset, int size) {
@@ -74,7 +75,8 @@ public class ShadowStringBlock {
     return array;
   }
 
-  private static void setIntArrayRegion(int[] array, int num, int numInts, ResStringPool_span spans) {
+  private static void setIntArrayRegion(
+      int[] array, int num, int numInts, ResStringPool_span spans) {
     ByteBuffer buf = spans.myBuf();
     int startOffset = spans.myOffset();
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSubscriptionManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSubscriptionManager.java
index 41b349b26..047e50ca9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSubscriptionManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSubscriptionManager.java
@@ -149,6 +149,7 @@ public class ShadowSubscriptionManager {
    * {@link #addOnSubscriptionsChangedListener} and {@link removeOnSubscriptionsChangedListener}.
    */
   private List<OnSubscriptionsChangedListener> listeners = new ArrayList<>();
+
   /**
    * Cache of subscription ids used by {@link #isNetworkRoaming}. Managed by {@link
    * #setNetworkRoamingStatus} and {@link #clearNetworkRoamingStatus}.
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSurface.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSurface.java
index 08d794286..ef83be975 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSurface.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSurface.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.Q;
 import static org.robolectric.util.reflector.Reflector.reflector;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSurfaceView.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSurfaceView.java
index 2a2dec73b..d371bf4d0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSurfaceView.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSurfaceView.java
@@ -28,9 +28,7 @@ public class ShadowSurfaceView extends ShadowView {
     return fakeSurfaceHolder;
   }
 
-  /**
-   * Robolectric implementation of {@link android.view.SurfaceHolder}.
-   */
+  /** Robolectric implementation of {@link android.view.SurfaceHolder}. */
   public static class FakeSurfaceHolder implements SurfaceHolder {
     private final Set<Callback> callbacks = new HashSet<>();
     // The default format is RGB_565.
@@ -56,16 +54,13 @@ public class ShadowSurfaceView extends ShadowView {
     }
 
     @Override
-    public void setType(int i) {
-    }
+    public void setType(int i) {}
 
     @Override
-    public void setFixedSize(int i, int i1) {
-    }
+    public void setFixedSize(int i, int i1) {}
 
     @Override
-    public void setSizeFromLayout() {
-    }
+    public void setSizeFromLayout() {}
 
     @Override
     public void setFormat(int format) {
@@ -77,8 +72,7 @@ public class ShadowSurfaceView extends ShadowView {
     }
 
     @Override
-    public void setKeepScreenOn(boolean b) {
-    }
+    public void setKeepScreenOn(boolean b) {}
 
     @Override
     public Canvas lockCanvas() {
@@ -91,8 +85,7 @@ public class ShadowSurfaceView extends ShadowView {
     }
 
     @Override
-    public void unlockCanvasAndPost(Canvas canvas) {
-    }
+    public void unlockCanvasAndPost(Canvas canvas) {}
 
     @Override
     public Rect getSurfaceFrame() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemClock.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemClock.java
index bba7005c4..90c33c9b4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemClock.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemClock.java
@@ -17,11 +17,13 @@ import org.robolectric.annotation.LooperMode.Mode;
 /**
  * The shadow API for {@link SystemClock}.
  *
- * The behavior of SystemClock in Robolectric will differ based on the current {@link
+ * <p>The behavior of SystemClock in Robolectric will differ based on the current {@link
  * LooperMode}. See {@link ShadowLegacySystemClock} and {@link ShadowPausedSystemClock} for more
  * details.
  */
-@Implements(value = SystemClock.class, shadowPicker = ShadowSystemClock.Picker.class,
+@Implements(
+    value = SystemClock.class,
+    shadowPicker = ShadowSystemClock.Picker.class,
     looseSignatures = true)
 public abstract class ShadowSystemClock {
   protected static boolean networkTimeAvailable = true;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemServiceRegistry.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemServiceRegistry.java
index 9ab967eda..2f150456a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemServiceRegistry.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemServiceRegistry.java
@@ -13,11 +13,10 @@ import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
 
 @Implements(
-  className = "android.app.SystemServiceRegistry",
-  isInAndroidSdk = false,
-  looseSignatures = true,
-  minSdk = Build.VERSION_CODES.M
-)
+    className = "android.app.SystemServiceRegistry",
+    isInAndroidSdk = false,
+    looseSignatures = true,
+    minSdk = Build.VERSION_CODES.M)
 public class ShadowSystemServiceRegistry {
 
   private static final String STATIC_SERVICE_FETCHER_CLASS_NAME =
@@ -83,12 +82,10 @@ public class ShadowSystemServiceRegistry {
 
     static String getConcreteClassName(Object serviceFetcher) {
       Class<?> serviceFetcherClass = serviceFetcher.getClass();
-      while (serviceFetcherClass != null && serviceFetcherClass.getCanonicalName() == null){
+      while (serviceFetcherClass != null && serviceFetcherClass.getCanonicalName() == null) {
         serviceFetcherClass = serviceFetcherClass.getSuperclass();
       }
-      return serviceFetcherClass == null
-          ? null
-          : serviceFetcherClass.getName();
+      return serviceFetcherClass == null ? null : serviceFetcherClass.getName();
     }
 
     default void clearInstance() {
@@ -117,9 +114,8 @@ public class ShadowSystemServiceRegistry {
   }
 
   /**
-   * Accessor interface for
-   * {@link android.app.SystemServiceRegistry.StaticApplicationContextServiceFetcher}'s
-   * internals (for N+).
+   * Accessor interface for {@link
+   * android.app.SystemServiceRegistry.StaticApplicationContextServiceFetcher}'s internals (for N+).
    */
   @ForType(className = STATIC_CONTEXT_SERVICE_FETCHER_CLASS_NAME_N)
   public interface _ServiceFetcherN_ extends _ServiceFetcher_ {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemVibrator.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemVibrator.java
index 3971c8f60..f663c6bc9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemVibrator.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemVibrator.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-
 import static android.os.Build.VERSION_CODES.N_MR1;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.P;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTabActivity.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTabActivity.java
index d6d0e849f..f72136f45 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTabActivity.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTabActivity.java
@@ -15,7 +15,7 @@ public class ShadowTabActivity extends ShadowActivityGroup {
 
   @Implementation
   protected TabHost getTabHost() {
-    if (tabhost==null) {
+    if (tabhost == null) {
       tabhost = new TabHost(realTabActivity);
     }
     return tabhost;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTabHost.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTabHost.java
index bc8248162..fad0b6933 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTabHost.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTabHost.java
@@ -23,8 +23,7 @@ public class ShadowTabHost extends ShadowViewGroup {
   private TabHost.OnTabChangeListener listener;
   private int currentTab = -1;
 
-  @RealObject
-  private TabHost realObject;
+  @RealObject private TabHost realObject;
 
   @Implementation
   protected android.widget.TabHost.TabSpec newTabSpec(java.lang.String tag) {
@@ -108,7 +107,7 @@ public class ShadowTabHost extends ShadowViewGroup {
   protected TabWidget getTabWidget() {
     Context context = realView.getContext();
     if (context instanceof Activity) {
-      return (TabWidget) ((Activity)context).findViewById(R.id.tabs);
+      return (TabWidget) ((Activity) context).findViewById(R.id.tabs);
     } else {
       return null;
     }
@@ -127,8 +126,7 @@ public class ShadowTabHost extends ShadowViewGroup {
   @Implements(TabSpec.class)
   public static class ShadowTabSpec {
 
-    @RealObject
-    TabSpec realObject;
+    @RealObject TabSpec realObject;
     private String tag;
     private View indicatorView;
     private Intent intent;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTabWidget.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTabWidget.java
index 556463db1..7fd4ac1f4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTabWidget.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTabWidget.java
@@ -10,7 +10,7 @@ import org.robolectric.annotation.Implements;
 @Implements(TabWidget.class)
 public class ShadowTabWidget extends ShadowLinearLayout {
 
-  @HiddenApi @Implementation(maxSdk = M)
-  public void initTabWidget() {
-  }
+  @HiddenApi
+  @Implementation(maxSdk = M)
+  public void initTabWidget() {}
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelecomManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelecomManager.java
index 10c6c35b6..de690464f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelecomManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelecomManager.java
@@ -1,11 +1,11 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.O;
+import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static com.google.common.base.Verify.verifyNotNull;
@@ -46,7 +46,7 @@ import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.util.ReflectionHelpers;
 
-@Implements(value = TelecomManager.class, minSdk = LOLLIPOP)
+@Implements(value = TelecomManager.class)
 public class ShadowTelecomManager {
 
   /**
@@ -74,8 +74,7 @@ public class ShadowTelecomManager {
     MANUAL,
   }
 
-  @RealObject
-  private TelecomManager realObject;
+  @RealObject private TelecomManager realObject;
 
   private final LinkedHashMap<PhoneAccountHandle, PhoneAccount> accounts = new LinkedHashMap<>();
   private final LinkedHashMap<PhoneAccountHandle, String> voicemailNumbers = new LinkedHashMap<>();
@@ -91,6 +90,7 @@ public class ShadowTelecomManager {
   private String defaultDialerPackageName;
   private String systemDefaultDialerPackageName;
   private boolean isInCall;
+  private boolean isInEmergencyCall;
   private boolean ttySupported;
   private PhoneAccountHandle userSelectedOutgoingPhoneAccount;
   private boolean readPhoneStatePermission = true;
@@ -274,7 +274,9 @@ public class ShadowTelecomManager {
     accounts.remove(accountHandle);
   }
 
-  /** @deprecated */
+  /**
+   * @deprecated
+   */
   @Deprecated
   @Implementation
   @HiddenApi
@@ -298,7 +300,9 @@ public class ShadowTelecomManager {
     }
   }
 
-  /** @deprecated */
+  /**
+   * @deprecated
+   */
   @Deprecated
   @Implementation
   @HiddenApi
@@ -311,7 +315,9 @@ public class ShadowTelecomManager {
     return defaultDialerPackageName;
   }
 
-  /** @deprecated API deprecated since Q, for testing, use setDefaultDialerPackage instead */
+  /**
+   * @deprecated API deprecated since Q, for testing, use setDefaultDialerPackage instead
+   */
   @Deprecated
   @Implementation(minSdk = M)
   @HiddenApi
@@ -368,14 +374,36 @@ public class ShadowTelecomManager {
   /**
    * Overrides behavior of {@link TelecomManager#isInCall} to return pre-set result.
    *
-   * @return Value set by calling {@link ShadowTelecomManager#setIsInCall}. If setIsInCall has not
-   *     previously been called, will return false.
+   * @return Value set by calling {@link ShadowTelecomManager#setIsInCall} or {@link
+   *     ShadowTelecomManager#setIsInEmergencyCall}. If neither has previously been called, will
+   *     return false.
    */
   @Implementation
   protected boolean isInCall() {
     return isInCall;
   }
 
+  /**
+   * Sets the return value for {@link TelecomManager#isInEmergencyCall} and {@link
+   * TelecomManager#isInCall}.
+   */
+  public void setIsInEmergencyCall(boolean isInEmergencyCall) {
+    this.isInEmergencyCall = isInEmergencyCall;
+    this.isInCall = isInEmergencyCall;
+  }
+
+  /**
+   * Overrides behavior of {@link TelecomManager#isInEmergencyCall} to return pre-set result.
+   *
+   * @return Value set by calling {@link ShadowTelecomManager#setIsInEmergencyCall}. If
+   *     setIsInEmergencyCall has not previously been called, will return false.
+   */
+  @Implementation(minSdk = Q)
+  @SystemApi
+  protected boolean isInEmergencyCall() {
+    return isInEmergencyCall;
+  }
+
   @Implementation
   @HiddenApi
   public int getCallState() {
@@ -753,7 +781,9 @@ public class ShadowTelecomManager {
     public final Bundle extras;
     protected boolean isRinging = true;
 
-    /** @deprecated Use {@link extras} instead. */
+    /**
+     * @deprecated Use {@link extras} instead.
+     */
     @Deprecated public final Bundle bundle;
 
     public CallRecord(PhoneAccountHandle phoneAccount, Bundle extras) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextToSpeech.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextToSpeech.java
index d88988322..0328e81b6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextToSpeech.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextToSpeech.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
@@ -9,7 +8,6 @@ import android.os.Bundle;
 import android.os.Handler;
 import android.os.Looper;
 import android.speech.tts.TextToSpeech;
-import android.speech.tts.TextToSpeech.Engine;
 import android.speech.tts.UtteranceProgressListener;
 import android.speech.tts.Voice;
 import com.google.common.collect.ImmutableList;
@@ -22,7 +20,6 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -113,11 +110,7 @@ public class ShadowTextToSpeech {
   @Implementation
   protected int speak(
       final String text, final int queueMode, final HashMap<String, String> params) {
-    if (RuntimeEnvironment.getApiLevel() >= LOLLIPOP) {
-      return reflector(TextToSpeechReflector.class, tts).speak(text, queueMode, params);
-    }
-    return speak(
-        text, queueMode, null, params == null ? null : params.get(Engine.KEY_PARAM_UTTERANCE_ID));
+    return reflector(TextToSpeechReflector.class, tts).speak(text, queueMode, params);
   }
 
   @Implementation
@@ -182,10 +175,30 @@ public class ShadowTextToSpeech {
     return TextToSpeech.LANG_NOT_SUPPORTED;
   }
 
+  /**
+   * Sets the text-to-speech language.
+   *
+   * <p>This method sets the current voice to the default one for the given Locale; getVoice() can
+   * be used to retrieve it.
+   */
   @Implementation
   protected int setLanguage(Locale locale) {
     this.language = locale;
-    return isLanguageAvailable(locale);
+    int languageAvailability = isLanguageAvailable(locale);
+
+    // Set to default voice (locale voice) if no voice is set.
+    if (languageAvailability >= TextToSpeech.LANG_AVAILABLE && this.currentVoice == null) {
+      setVoice(
+          new Voice(
+              locale.toLanguageTag(),
+              locale,
+              Voice.QUALITY_NORMAL,
+              Voice.LATENCY_NORMAL,
+              /* requiresNetworkConnection= */ false,
+              new HashSet<String>()));
+    }
+
+    return languageAvailability;
   }
 
   /**
@@ -243,6 +256,14 @@ public class ShadowTextToSpeech {
     return TextToSpeech.SUCCESS;
   }
 
+  /**
+   * Returns the Voice instance describing the voice currently being used for synthesis requests.
+   */
+  @Implementation
+  protected Voice getVoice() {
+    return this.currentVoice;
+  }
+
   @Implementation
   protected Set<Voice> getVoices() {
     return voices;
@@ -272,7 +293,9 @@ public class ShadowTextToSpeech {
     return shutdown;
   }
 
-  /** @return {@code true} if the TTS is stopped. */
+  /**
+   * @return {@code true} if the TTS is stopped.
+   */
   public boolean isStopped() {
     return stopped;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextView.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextView.java
index e0f707004..e7d29b4c4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextView.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextView.java
@@ -67,7 +67,7 @@ public class ShadowTextView extends ShadowView {
   /**
    * Returns the text string of this {@code TextView}.
    *
-   * Robolectric extension.
+   * <p>Robolectric extension.
    */
   @Override
   public String innerText() {
@@ -98,7 +98,8 @@ public class ShadowTextView extends ShadowView {
     return watchers;
   }
 
-  @HiddenApi @Implementation
+  @HiddenApi
+  @Implementation
   public Locale getTextServicesLocale() {
     return Locale.getDefault();
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimePickerDialog.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimePickerDialog.java
index 0c06e8927..de96601bc 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimePickerDialog.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimePickerDialog.java
@@ -11,8 +11,7 @@ import org.robolectric.util.reflector.ForType;
 
 @Implements(value = TimePickerDialog.class)
 public class ShadowTimePickerDialog extends ShadowAlertDialog {
-  @RealObject
-  protected TimePickerDialog realTimePickerDialog;
+  @RealObject protected TimePickerDialog realTimePickerDialog;
 
   public int getHourOfDay() {
     return reflector(TimePickerDialogProvider.class, realTimePickerDialog)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowToast.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowToast.java
index af095b40b..5c2810353 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowToast.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowToast.java
@@ -109,9 +109,9 @@ public class ShadowToast {
   }
 
   /**
-   * Discards the recorded {@code Toast}s. Shown toasts are automatically cleared between
-   * tests. This method allows the user to discard recorded toasts during the test in order to make assertions clearer
-   * e.g:
+   * Discards the recorded {@code Toast}s. Shown toasts are automatically cleared between tests.
+   * This method allows the user to discard recorded toasts during the test in order to make
+   * assertions clearer e.g:
    *
    * <pre>
    *
@@ -134,11 +134,11 @@ public class ShadowToast {
   }
 
   /**
-   * Returns the number of {@code Toast} requests that have been made during this test run
-   * or since {@link #reset()} has been called.
+   * Returns the number of {@code Toast} requests that have been made during this test run or since
+   * {@link #reset()} has been called.
    *
-   * @return the number of {@code Toast} requests that have been made during this test run
-   *         or since {@link #reset()} has been called.
+   * @return the number of {@code Toast} requests that have been made during this test run or since
+   *     {@link #reset()} has been called.
    */
   public static int shownToastCount() {
     ShadowApplication shadowApplication = Shadow.extract(RuntimeEnvironment.getApplication());
@@ -149,14 +149,18 @@ public class ShadowToast {
    * Returns whether or not a particular custom {@code Toast} has been shown.
    *
    * @param message the message to search for
-   * @param layoutResourceIdToCheckForMessage
-   *                the id of the resource that contains the toast messages
+   * @param layoutResourceIdToCheckForMessage the id of the resource that contains the toast
+   *     messages
    * @return whether the {@code Toast} was requested
    */
-  public static boolean showedCustomToast(CharSequence message, int layoutResourceIdToCheckForMessage) {
+  public static boolean showedCustomToast(
+      CharSequence message, int layoutResourceIdToCheckForMessage) {
     ShadowApplication shadowApplication = Shadow.extract(RuntimeEnvironment.getApplication());
     for (Toast toast : shadowApplication.getShownToasts()) {
-      String text = ((TextView) toast.getView().findViewById(layoutResourceIdToCheckForMessage)).getText().toString();
+      String text =
+          ((TextView) toast.getView().findViewById(layoutResourceIdToCheckForMessage))
+              .getText()
+              .toString();
       if (text.equals(message.toString())) {
         return true;
       }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTotalCaptureResult.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTotalCaptureResult.java
index efebb85d2..7d6eafec5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTotalCaptureResult.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTotalCaptureResult.java
@@ -1,12 +1,11 @@
 package org.robolectric.shadows;
 
 import android.hardware.camera2.TotalCaptureResult;
-import android.os.Build.VERSION_CODES;
 import org.robolectric.annotation.Implements;
 import org.robolectric.util.ReflectionHelpers;
 
 /** Shadow of {@link TotalCaptureResult}. */
-@Implements(value = TotalCaptureResult.class, minSdk = VERSION_CODES.LOLLIPOP)
+@Implements(value = TotalCaptureResult.class)
 public class ShadowTotalCaptureResult extends ShadowCaptureResult {
 
   /** Convenience method which returns a new instance of {@link TotalCaptureResult}. */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTouchDelegate.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTouchDelegate.java
index 429f2d6ea..8ac50ea7c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTouchDelegate.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTouchDelegate.java
@@ -20,7 +20,9 @@ public class ShadowTouchDelegate {
   protected void __constructor__(Rect bounds, View delegateView) {
     this.bounds = bounds;
     this.delegateView = delegateView;
-    invokeConstructor(TouchDelegate.class, realObject,
+    invokeConstructor(
+        TouchDelegate.class,
+        realObject,
         ClassParameter.from(Rect.class, bounds),
         ClassParameter.from(View.class, delegateView));
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTrace.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTrace.java
index 5d8b52be7..81dfa9c8c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTrace.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTrace.java
@@ -18,8 +18,8 @@ import java.util.Set;
 import java.util.function.Supplier;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.annotation.InDevelopment;
 import org.robolectric.annotation.Resetter;
+import org.robolectric.versioning.AndroidVersions.U;
 
 /**
  * Shadow implementation for {@link Trace}, which stores the traces locally in arrays (unlike the
@@ -112,8 +112,7 @@ public class ShadowTrace {
     previousAsyncSections.add(section);
   }
 
-  @Implementation
-  @InDevelopment
+  @Implementation(maxSdk = U.SDK_INT)
   protected static long nativeGetEnabledTags() {
     return tags;
   }
@@ -211,7 +210,7 @@ public class ShadowTrace {
 
     public abstract String getSectionName();
 
-    public abstract Integer getCookie();
+    public abstract int getCookie();
 
     public static Builder newBuilder() {
       return new AutoValue_ShadowTrace_AsyncTraceSection.Builder();
@@ -222,7 +221,7 @@ public class ShadowTrace {
     public abstract static class Builder {
       public abstract Builder setSectionName(String sectionName);
 
-      public abstract Builder setCookie(Integer cookie);
+      public abstract Builder setCookie(int cookie);
 
       public abstract AsyncTraceSection build();
     }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTransportControls.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTransportControls.java
index cb5d112ab..878057c08 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTransportControls.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTransportControls.java
@@ -13,7 +13,6 @@ import static android.media.session.PlaybackState.ACTION_SKIP_TO_PREVIOUS;
 import static android.media.session.PlaybackState.ACTION_SKIP_TO_QUEUE_ITEM;
 import static android.media.session.PlaybackState.ACTION_STOP;
 import static android.media.session.PlaybackState.STATE_NONE;
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static org.robolectric.util.reflector.Reflector.reflector;
@@ -35,7 +34,7 @@ import org.robolectric.util.reflector.ForType;
  * <p>TransportControls should always be created by first creating a corresponding MediaController;
  * *NOT*, for instance, via Shadows.newInstanceOf(TransportControls.class).
  */
-@Implements(value = TransportControls.class, minSdk = LOLLIPOP)
+@Implements(value = TransportControls.class)
 public class ShadowTransportControls {
   @RealObject protected TransportControls realTransportControls;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsageStatsManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsageStatsManager.java
index 40dc52690..5400f9d07 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsageStatsManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsageStatsManager.java
@@ -45,10 +45,7 @@ import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
 
 /** Shadow of {@link UsageStatsManager}. */
-@Implements(
-    value = UsageStatsManager.class,
-    minSdk = Build.VERSION_CODES.LOLLIPOP,
-    looseSignatures = true)
+@Implements(value = UsageStatsManager.class, looseSignatures = true)
 public class ShadowUsageStatsManager {
   private static @StandbyBuckets int currentAppStandbyBucket =
       UsageStatsManager.STANDBY_BUCKET_ACTIVE;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbRequest.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbRequest.java
index b266d043e..2463bbb28 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbRequest.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbRequest.java
@@ -90,7 +90,7 @@ public class ShadowUsbRequest {
       while (totalBytesRead < length) {
         int bytesRead =
             incomingDataPipedInputStream.read(
-                bytes, /*off=*/ totalBytesRead, /*len=*/ length - totalBytesRead);
+                bytes, /* off= */ totalBytesRead, /* len= */ length - totalBytesRead);
         if (bytesRead < 0) {
           return false;
         }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUserManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUserManager.java
index 7accd63a4..e9f712e1d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUserManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUserManager.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.N_MR1;
@@ -113,12 +112,16 @@ public class ShadowUserManager {
    */
   static class UserManagerState {
     private final Map<Integer, Integer> userPidMap = new HashMap<>();
+
     /** Holds the serial numbers for all users and profiles, indexed by UserHandle.id */
     private final BiMap<Integer, Long> userSerialNumbers = HashBiMap.create();
+
     /** Holds all UserStates, indexed by UserHandle.id */
     private final Map<Integer, UserState> userState = new HashMap<>();
+
     /** Holds the UserInfo for all registered users and profiles, indexed by UserHandle.id */
     private final Map<Integer, UserInfo> userInfoMap = new HashMap<>();
+
     /**
      * Each user holds a list of UserHandles of assocated profiles and user itself. User is indexed
      * by UserHandle.id. See UserManager.getProfiles(userId).
@@ -322,12 +325,10 @@ public class ShadowUserManager {
       // use UserHandle id as serial number unless setSerialNumberForUser() is used
       userManagerState.userSerialNumbers.put(profileUserHandle, (long) profileUserHandle);
     }
-    if (RuntimeEnvironment.getApiLevel() >= LOLLIPOP) {
-      profileUserInfo.profileGroupId = userHandle;
-      UserInfo parentUserInfo = getUserInfo(userHandle);
-      if (parentUserInfo != null) {
-        parentUserInfo.profileGroupId = userHandle;
-      }
+    profileUserInfo.profileGroupId = userHandle;
+    UserInfo parentUserInfo = getUserInfo(userHandle);
+    if (parentUserInfo != null) {
+      parentUserInfo.profileGroupId = userHandle;
     }
     userManagerState.userInfoMap.put(profileUserHandle, profileUserInfo);
     // Insert profile to the belonging user's userProfilesList
@@ -349,7 +350,9 @@ public class ShadowUserManager {
     return userUnlocked;
   }
 
-  /** @see #setUserState(UserHandle, UserState) */
+  /**
+   * @see #setUserState(UserHandle, UserState)
+   */
   @Implementation(minSdk = 24)
   protected boolean isUserUnlocked(UserHandle handle) {
     checkPermissions();
@@ -705,7 +708,9 @@ public class ShadowUserManager {
     //                + "to: check " + name);throw new SecurityException();
   }
 
-  /** @return false by default, or the value specified via {@link #setIsDemoUser(boolean)} */
+  /**
+   * @return false by default, or the value specified via {@link #setIsDemoUser(boolean)}
+   */
   @Implementation(minSdk = N_MR1)
   protected boolean isDemoUser() {
     return getUserInfo(UserHandle.myUserId()).isDemo();
@@ -728,7 +733,9 @@ public class ShadowUserManager {
     }
   }
 
-  /** @return 'true' by default, or the value specified via {@link #setIsSystemUser(boolean)} */
+  /**
+   * @return 'true' by default, or the value specified via {@link #setIsSystemUser(boolean)}
+   */
   @Implementation(minSdk = M)
   protected boolean isSystemUser() {
     if (isSystemUser == false) {
@@ -846,7 +853,9 @@ public class ShadowUserManager {
     }
   }
 
-  /** @see #setUserState(UserHandle, UserState) */
+  /**
+   * @see #setUserState(UserHandle, UserState)
+   */
   @Implementation
   protected boolean isUserRunning(UserHandle handle) {
     checkPermissions();
@@ -861,7 +870,9 @@ public class ShadowUserManager {
     }
   }
 
-  /** @see #setUserState(UserHandle, UserState) */
+  /**
+   * @see #setUserState(UserHandle, UserState)
+   */
   @Implementation
   protected boolean isUserRunningOrStopping(UserHandle handle) {
     checkPermissions();
@@ -877,7 +888,9 @@ public class ShadowUserManager {
     }
   }
 
-  /** @see #setUserState(UserHandle, UserState) */
+  /**
+   * @see #setUserState(UserHandle, UserState)
+   */
   @Implementation(minSdk = R)
   protected boolean isUserUnlockingOrUnlocked(UserHandle handle) {
     checkPermissions();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUwbManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUwbManager.java
index 118b155c1..b941ce52e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUwbManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUwbManager.java
@@ -88,6 +88,15 @@ public class ShadowUwbManager {
     return specificationInfo;
   }
 
+  /**
+   * Returns the adapter state provided by {@link ShadowUwbManager#simulateAdapterStateChange()}.
+   */
+  @Implementation
+  @AdapterState
+  protected int getAdapterState() {
+    return adapterState;
+  }
+
   /**
    * Instantiates a {@link ShadowRangingSession} with the adapter provided by {@link
    * ShadowUwbManager#setUwbAdapter()}, allowing the tester dictate the results of ranging attempts.
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVMRuntime.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVMRuntime.java
index 8bc20c406..551e31ddb 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVMRuntime.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVMRuntime.java
@@ -1,23 +1,55 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.Q;
 
-import android.annotation.TargetApi;
+import com.google.common.base.Preconditions;
 import dalvik.system.VMRuntime;
 import java.lang.ref.WeakReference;
 import java.lang.reflect.Array;
+import java.lang.reflect.Method;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.atomic.AtomicLong;
 import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
-import org.robolectric.res.android.NativeObjRegistry;
 
 @Implements(value = VMRuntime.class, isInAndroidSdk = false)
 public class ShadowVMRuntime {
 
-  private final NativeObjRegistry<WeakReference<Object>> nativeObjRegistry =
-      new NativeObjRegistry<>("VRRuntime.nativeObjectRegistry");
+  /**
+   * A map of allocated non movable arrays to the (Direct)ByteBuffer backing it
+   *
+   * <p>The JVM does not directly support newNonMovableArray. So as a workaround, this class will
+   * allocate a direct ByteBuffer for use in native code. It is the responsibility the shadow code
+   * to update any associated buffers with the data from native code.
+   */
+  private final Map<Object, ByteBuffer> realNonMovableArrays =
+      Collections.synchronizedMap(new WeakHashMap<>());
+
+  private final Map<Long, WeakReference<Object>> nonMovableArraysReverse =
+      Collections.synchronizedMap(new HashMap<>());
+
+  /**
+   * Currently, {@link android.content.res.TypedArray} uses newNonMovableArray, but does not need to
+   * access the data from native code. So in this case we will allocate a fake pointer.
+   */
+  private final Map<Object, Long> fakeNonMovableArrays =
+      Collections.synchronizedMap(new WeakHashMap<>());
+
+  private final AtomicLong nextFakeArrayPointer = new AtomicLong();
+
+  // This is a hack to get the address of a DirectByteBuffer. The Method object is cached to reduce
+  // the overhead of reflection. This method is invoked extensively during layout inflation. This
+  // reflection requires the `--add-opens=java.base/java.nio=ALL-UNNAMED` JVM flag. This value is
+  // lazy so tests can avoid having to add the flag where it is not needed.
+  private static Method addressMethod;
+
   // There actually isn't any android JNI code to call through to in Robolectric due to
   // cross-platform compatibility issues. We default to a reasonable value that reflects the devices
   // that would commonly run this code.
@@ -32,26 +64,83 @@ public class ShadowVMRuntime {
 
   @Implementation
   public Object newNonMovableArray(Class<?> type, int size) {
-    if (type.equals(int.class)) {
-      return new int[size];
+    Preconditions.checkArgument(
+        type == int.class || type == float.class, "unsupported type %s", type.getName());
+    Object arrayInstance = Array.newInstance(type, size);
+    if (type == float.class && size == 8) {
+      // This is being called from android.graphics.PathIterator, so we need to allocate a real
+      // ByteBuffer that can be accessed from native code.
+      ByteBuffer byteBuffer = ByteBuffer.allocateDirect(4 * size);
+      byteBuffer.order(ByteOrder.nativeOrder());
+      realNonMovableArrays.put(arrayInstance, byteBuffer);
+      nonMovableArraysReverse.put(
+          getAddressOfDirectByteBuffer(byteBuffer), new WeakReference<>(arrayInstance));
+    } else {
+      // This is being called from android.content.res.TypedArray, so we need to allocate a fake
+      // pointer.
+      long fakePointer = nextFakeArrayPointer.incrementAndGet();
+      fakeNonMovableArrays.put(arrayInstance, fakePointer);
+      nonMovableArraysReverse.put(fakePointer, new WeakReference<>(arrayInstance));
     }
-    return null;
+    return arrayInstance;
   }
 
-  /**
-   * Returns a unique identifier of the object instead of a 'native' address.
-   */
+  /** Returns a unique identifier of the object instead of a 'native' address. */
   @Implementation
   public long addressOf(Object obj) {
-    return nativeObjRegistry.register(new WeakReference<>(obj));
+    if (obj == null) {
+      return 0;
+    }
+    Preconditions.checkArgument(
+        obj.getClass().isArray(), "addressOf(Object) is only supported for array objects");
+    Class<?> arrayClass = obj.getClass().getComponentType();
+    Preconditions.checkArgument(
+        arrayClass.isPrimitive(),
+        "addressOf(Object) is only supported for primitive array objects");
+    if (arrayClass == float.class && Array.getLength(obj) == 8) {
+      // This is being called from android.graphics.PathIterator.
+      ByteBuffer byteBuffer = realNonMovableArrays.get(obj);
+      if (byteBuffer == null) {
+        throw new IllegalArgumentException("Trying to get address of unknown object");
+      }
+      return getAddressOfDirectByteBuffer(byteBuffer);
+    } else {
+      // This is being called from android.content.res.TypedArray.
+      Long address = fakeNonMovableArrays.get(obj);
+      if (address == null) {
+        throw new IllegalArgumentException("Trying to get address of unknown object");
+      }
+      return address;
+    }
   }
 
-  /**
-   * Returns the object previously registered with {@link #addressOf(Object)}.
-   */
-  public @Nullable
+  private long getAddressOfDirectByteBuffer(ByteBuffer byteBuffer) {
+    synchronized (ShadowVMRuntime.class) {
+      if (addressMethod == null) {
+        try {
+          addressMethod = Class.forName("java.nio.DirectByteBuffer").getMethod("address");
+          addressMethod.setAccessible(true);
+        } catch (ReflectiveOperationException e) {
+          throw new LinkageError("Error accessing address method", e);
+        }
+      }
+    }
+
+    try {
+      return (long) addressMethod.invoke(byteBuffer);
+    } catch (ReflectiveOperationException e) {
+      throw new LinkageError("Error invoking address method", e);
+    }
+  }
+
+  /** Returns the object previously registered with {@link #addressOf(Object)}. */
+  @Nullable
   Object getObjectForAddress(long address) {
-    return nativeObjRegistry.getNativeObject(address).get();
+    WeakReference<Object> weakReference = nonMovableArraysReverse.get(address);
+    if (weakReference == null) {
+      return null;
+    }
+    return weakReference.get();
   }
 
   /**
@@ -63,7 +152,6 @@ public class ShadowVMRuntime {
   }
 
   /** Sets whether the VM is running in 64-bit mode. */
-  @TargetApi(LOLLIPOP)
   public static void setIs64Bit(boolean is64Bit) {
     ShadowVMRuntime.is64Bit = is64Bit;
   }
@@ -75,11 +163,18 @@ public class ShadowVMRuntime {
   }
 
   /** Sets the instruction set of the current runtime. */
-  @TargetApi(LOLLIPOP)
   public static void setCurrentInstructionSet(@Nullable String currentInstructionSet) {
     ShadowVMRuntime.currentInstructionSet = currentInstructionSet;
   }
 
+  ByteBuffer getBackingBuffer(long address) {
+    Object array = getObjectForAddress(address);
+    if (array == null) {
+      return null;
+    }
+    return realNonMovableArrays.get(array);
+  }
+
   @Resetter
   public static void reset() {
     ShadowVMRuntime.is64Bit = true;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowValueAnimator.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowValueAnimator.java
index 30481fcb4..01f56ab65 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowValueAnimator.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowValueAnimator.java
@@ -58,8 +58,8 @@ public class ShadowValueAnimator {
   }
 
   /**
-   * Returns the value that was set as the repeat count. This is otherwise the same
-   * as getRepeatCount(), except when the count was set to infinite.
+   * Returns the value that was set as the repeat count. This is otherwise the same as
+   * getRepeatCount(), except when the count was set to infinite.
    *
    * @return Repeat count.
    */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVectorDrawable.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVectorDrawable.java
index 0153f5997..dcde678ed 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVectorDrawable.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVectorDrawable.java
@@ -27,15 +27,16 @@ import org.robolectric.annotation.Implements;
 @Implements(value = VectorDrawable.class, minSdk = N)
 public class ShadowVectorDrawable extends ShadowDrawable {
   //  private static native long nCreateTree(long rootGroupPtr);
-//  private static native long nCreateTreeFromCopy(long treeToCopy, long rootGroupPtr);
-//  private static native void nSetRendererViewportSize(long rendererPtr, float viewportWidth,
-//                                                      float viewportHeight);
-//  private static native boolean nSetRootAlpha(long rendererPtr, float alpha);
-//  private static native float nGetRootAlpha(long rendererPtr);
-//  private static native void nSetAllowCaching(long rendererPtr, boolean allowCaching);
-//
-//  private static native int nDraw(long rendererPtr, long canvasWrapperPtr,
-//                                  long colorFilterPtr, Rect bounds, boolean needsMirroring, boolean canReuseCache);
+  //  private static native long nCreateTreeFromCopy(long treeToCopy, long rootGroupPtr);
+  //  private static native void nSetRendererViewportSize(long rendererPtr, float viewportWidth,
+  //                                                      float viewportHeight);
+  //  private static native boolean nSetRootAlpha(long rendererPtr, float alpha);
+  //  private static native float nGetRootAlpha(long rendererPtr);
+  //  private static native void nSetAllowCaching(long rendererPtr, boolean allowCaching);
+  //
+  //  private static native int nDraw(long rendererPtr, long canvasWrapperPtr,
+  //                                  long colorFilterPtr, Rect bounds, boolean needsMirroring,
+  // boolean canReuseCache);
 
   private static final int STROKE_WIDTH_INDEX = 0;
   private static final int STROKE_COLOR_INDEX = 1;
@@ -142,19 +143,18 @@ public class ShadowVectorDrawable extends ShadowDrawable {
     path.fillType = fillType;
   }
 
-//  @Implementation
-//  public static void nUpdateFullPathFillGradient(long pathPtr, long fillGradientPtr) {
-//
-//  }
-//
-//  @Implementation
-//  public static void nUpdateFullPathStrokeGradient(long pathPtr, long strokeGradientPtr) {
-//
-//  }
-//
-//  private static native long nCreateClipPath();
-//  private static native long nCreateClipPath(long clipPathPtr);
-
+  //  @Implementation
+  //  public static void nUpdateFullPathFillGradient(long pathPtr, long fillGradientPtr) {
+  //
+  //  }
+  //
+  //  @Implementation
+  //  public static void nUpdateFullPathStrokeGradient(long pathPtr, long strokeGradientPtr) {
+  //
+  //  }
+  //
+  //  private static native long nCreateClipPath();
+  //  private static native long nCreateClipPath(long clipPathPtr);
 
   static class Group implements Cloneable {
     float rotation;
@@ -226,48 +226,48 @@ public class ShadowVectorDrawable extends ShadowDrawable {
     group.translateY = translateY;
   }
 
-//  private static native void nAddChild(long groupPtr, long nodePtr);
-//  private static native void nSetPathString(long pathPtr, String pathString, int length);
-//
-//  /**
-//   * The setters and getters below for paths and groups are here temporarily, and will be
-//   * removed once the animation in AVD is replaced with RenderNodeAnimator, in which case the
-//   * animation will modify these properties in native. By then no JNI hopping would be necessary
-//   * for VD during animation, and these setters and getters will be obsolete.
-//   */
-//  // Setters and getters during animation.
-//  private static native float nGetRotation(long groupPtr);
-//  private static native void nSetRotation(long groupPtr, float rotation);
-//  private static native float nGetPivotX(long groupPtr);
-//  private static native void nSetPivotX(long groupPtr, float pivotX);
-//  private static native float nGetPivotY(long groupPtr);
-//  private static native void nSetPivotY(long groupPtr, float pivotY);
-//  private static native float nGetScaleX(long groupPtr);
-//  private static native void nSetScaleX(long groupPtr, float scaleX);
-//  private static native float nGetScaleY(long groupPtr);
-//  private static native void nSetScaleY(long groupPtr, float scaleY);
-//  private static native float nGetTranslateX(long groupPtr);
-//  private static native void nSetTranslateX(long groupPtr, float translateX);
-//  private static native float nGetTranslateY(long groupPtr);
-//  private static native void nSetTranslateY(long groupPtr, float translateY);
-//
-//  // Setters and getters for VPath during animation.
-//  private static native void nSetPathData(long pathPtr, long pathDataPtr);
-//  private static native float nGetStrokeWidth(long pathPtr);
-//  private static native void nSetStrokeWidth(long pathPtr, float width);
-//  private static native int nGetStrokeColor(long pathPtr);
-//  private static native void nSetStrokeColor(long pathPtr, int strokeColor);
-//  private static native float nGetStrokeAlpha(long pathPtr);
-//  private static native void nSetStrokeAlpha(long pathPtr, float alpha);
-//  private static native int nGetFillColor(long pathPtr);
-//  private static native void nSetFillColor(long pathPtr, int fillColor);
-//  private static native float nGetFillAlpha(long pathPtr);
-//  private static native void nSetFillAlpha(long pathPtr, float fillAlpha);
-//  private static native float nGetTrimPathStart(long pathPtr);
-//  private static native void nSetTrimPathStart(long pathPtr, float trimPathStart);
-//  private static native float nGetTrimPathEnd(long pathPtr);
-//  private static native void nSetTrimPathEnd(long pathPtr, float trimPathEnd);
-//  private static native float nGetTrimPathOffset(long pathPtr);
-//  private static native void nSetTrimPathOffset(long pathPtr, float trimPathOffset);
+  //  private static native void nAddChild(long groupPtr, long nodePtr);
+  //  private static native void nSetPathString(long pathPtr, String pathString, int length);
+  //
+  //  /**
+  //   * The setters and getters below for paths and groups are here temporarily, and will be
+  //   * removed once the animation in AVD is replaced with RenderNodeAnimator, in which case the
+  //   * animation will modify these properties in native. By then no JNI hopping would be necessary
+  //   * for VD during animation, and these setters and getters will be obsolete.
+  //   */
+  //  // Setters and getters during animation.
+  //  private static native float nGetRotation(long groupPtr);
+  //  private static native void nSetRotation(long groupPtr, float rotation);
+  //  private static native float nGetPivotX(long groupPtr);
+  //  private static native void nSetPivotX(long groupPtr, float pivotX);
+  //  private static native float nGetPivotY(long groupPtr);
+  //  private static native void nSetPivotY(long groupPtr, float pivotY);
+  //  private static native float nGetScaleX(long groupPtr);
+  //  private static native void nSetScaleX(long groupPtr, float scaleX);
+  //  private static native float nGetScaleY(long groupPtr);
+  //  private static native void nSetScaleY(long groupPtr, float scaleY);
+  //  private static native float nGetTranslateX(long groupPtr);
+  //  private static native void nSetTranslateX(long groupPtr, float translateX);
+  //  private static native float nGetTranslateY(long groupPtr);
+  //  private static native void nSetTranslateY(long groupPtr, float translateY);
+  //
+  //  // Setters and getters for VPath during animation.
+  //  private static native void nSetPathData(long pathPtr, long pathDataPtr);
+  //  private static native float nGetStrokeWidth(long pathPtr);
+  //  private static native void nSetStrokeWidth(long pathPtr, float width);
+  //  private static native int nGetStrokeColor(long pathPtr);
+  //  private static native void nSetStrokeColor(long pathPtr, int strokeColor);
+  //  private static native float nGetStrokeAlpha(long pathPtr);
+  //  private static native void nSetStrokeAlpha(long pathPtr, float alpha);
+  //  private static native int nGetFillColor(long pathPtr);
+  //  private static native void nSetFillColor(long pathPtr, int fillColor);
+  //  private static native float nGetFillAlpha(long pathPtr);
+  //  private static native void nSetFillAlpha(long pathPtr, float fillAlpha);
+  //  private static native float nGetTrimPathStart(long pathPtr);
+  //  private static native void nSetTrimPathStart(long pathPtr, float trimPathStart);
+  //  private static native float nGetTrimPathEnd(long pathPtr);
+  //  private static native void nSetTrimPathEnd(long pathPtr, float trimPathEnd);
+  //  private static native float nGetTrimPathOffset(long pathPtr);
+  //  private static native void nSetTrimPathOffset(long pathPtr, float trimPathOffset);
 
-}
\ No newline at end of file
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVideoView.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVideoView.java
index 2b6a10659..7818e29dc 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVideoView.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVideoView.java
@@ -89,9 +89,9 @@ public class ShadowVideoView extends ShadowSurfaceView {
 
   @Implementation
   protected boolean canPause() {
-    return (currentState != ShadowVideoView.PAUSE &&
-        currentState != ShadowVideoView.STOP &&
-        currentState != ShadowVideoView.SUSPEND);
+    return (currentState != ShadowVideoView.PAUSE
+        && currentState != ShadowVideoView.STOP
+        && currentState != ShadowVideoView.SUSPEND);
   }
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewAnimator.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewAnimator.java
index 41a66d229..4865b5ddb 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewAnimator.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewAnimator.java
@@ -37,6 +37,9 @@ public class ShadowViewAnimator extends ShadowViewGroup {
 
   @Implementation
   protected void showPrevious() {
-    setDisplayedChild(getDisplayedChild() == 0 ? ((ViewGroup) realView).getChildCount() - 1 : getDisplayedChild() - 1);
+    setDisplayedChild(
+        getDisplayedChild() == 0
+            ? ((ViewGroup) realView).getChildCount() - 1
+            : getDisplayedChild() - 1);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewGroup.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewGroup.java
index 2f13fcf7d..200c21aa9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewGroup.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewGroup.java
@@ -37,8 +37,8 @@ public class ShadowViewGroup extends ShadowView {
   }
 
   /**
-   * Returns a string representation of this {@code ViewGroup} by concatenating all of the
-   * strings contained in all of the descendants of this {@code ViewGroup}.
+   * Returns a string representation of this {@code ViewGroup} by concatenating all of the strings
+   * contained in all of the descendants of this {@code ViewGroup}.
    */
   @Override
   public String innerText() {
@@ -60,6 +60,7 @@ public class ShadowViewGroup extends ShadowView {
 
   /**
    * Dumps the state of this {@code ViewGroup} to {@code System.out}.
+   *
    * @deprecated - Please use {@link androidx.test.espresso.util.HumanReadables#describe(View)}
    */
   @Override
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualRefBasePtr.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualRefBasePtr.java
index 34fd332ab..6823a7852 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualRefBasePtr.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualRefBasePtr.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-
 import com.android.internal.util.VirtualRefBasePtr;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVoiceInteractionService.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVoiceInteractionService.java
index 6a453d561..9925e328b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVoiceInteractionService.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVoiceInteractionService.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.Q;
 import static org.robolectric.util.reflector.Reflector.reflector;
@@ -23,7 +22,7 @@ import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 
 /** Shadow implementation of {@link android.service.voice.VoiceInteractionService}. */
-@Implements(value = VoiceInteractionService.class, minSdk = LOLLIPOP)
+@Implements(value = VoiceInteractionService.class)
 public class ShadowVoiceInteractionService extends ShadowService {
 
   private final List<Bundle> hintBundles = Collections.synchronizedList(new ArrayList<>());
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVoiceInteractionSession.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVoiceInteractionSession.java
index c2d73e9fa..4a6f87409 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVoiceInteractionSession.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVoiceInteractionSession.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static org.robolectric.util.ReflectionHelpers.callConstructor;
 
 import android.app.Dialog;
@@ -28,7 +27,7 @@ import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
 /** Shadow implementation of {@link android.service.voice.VoiceInteractionSession}. */
-@Implements(value = VoiceInteractionSession.class, minSdk = LOLLIPOP)
+@Implements(value = VoiceInteractionSession.class)
 public class ShadowVoiceInteractionSession {
 
   private final List<Intent> assistantActivityIntents = new ArrayList<>();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVpnManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVpnManager.java
index 99f807b07..17d150775 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVpnManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVpnManager.java
@@ -11,7 +11,7 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
 /** Shadow for {@link VpnManager}. */
-@Implements(value = VpnManager.class, minSdk = VERSION_CODES.R)
+@Implements(value = VpnManager.class, minSdk = VERSION_CODES.R, isInAndroidSdk = false)
 public class ShadowVpnManager {
 
   private VpnProfileState vpnProfileState;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVpnService.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVpnService.java
index 59fb2fe2b..201e75320 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVpnService.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVpnService.java
@@ -13,7 +13,9 @@ public class ShadowVpnService extends ShadowService {
 
   private static Intent prepareIntent = new Intent();
 
-  /** @see #setPrepareResult(Intent). */
+  /**
+   * @see #setPrepareResult(Intent).
+   */
   @Implementation
   protected static Intent prepare(Context context) {
     return prepareIntent;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWearableSensingManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWearableSensingManager.java
index 9713374b8..275855a21 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWearableSensingManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWearableSensingManager.java
@@ -5,6 +5,9 @@ import android.app.wearable.WearableSensingManager.StatusCode;
 import android.os.ParcelFileDescriptor;
 import android.os.PersistableBundle;
 import android.os.SharedMemory;
+import com.google.common.collect.Iterables;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.Executor;
 import java.util.function.Consumer;
 import org.robolectric.annotation.Implementation;
@@ -21,8 +24,8 @@ public class ShadowWearableSensingManager {
 
   private @StatusCode Integer provideDataStreamResult = WearableSensingManager.STATUS_SUCCESS;
   private @StatusCode Integer provideDataResult = WearableSensingManager.STATUS_SUCCESS;
-  private PersistableBundle lastDataBundle;
-  private SharedMemory lastSharedMemory;
+  private final ArrayList<PersistableBundle> dataBundleList = new ArrayList<>();
+  private final ArrayList<SharedMemory> sharedMemoryList = new ArrayList<>();
   private ParcelFileDescriptor lastParcelFileDescriptor;
 
   @Implementation
@@ -40,8 +43,8 @@ public class ShadowWearableSensingManager {
       SharedMemory sharedMemory,
       Executor executor,
       @StatusCode Consumer<Integer> statusConsumer) {
-    lastDataBundle = data;
-    lastSharedMemory = sharedMemory;
+    dataBundleList.add(data);
+    sharedMemoryList.add(sharedMemory);
     executor.execute(() -> statusConsumer.accept(provideDataResult));
   }
 
@@ -58,10 +61,18 @@ public class ShadowWearableSensingManager {
   }
 
   public PersistableBundle getLastDataBundle() {
-    return lastDataBundle;
+    return dataBundleList.isEmpty() ? null : Iterables.getLast(dataBundleList);
+  }
+
+  public List<PersistableBundle> getAllDataBundles() {
+    return new ArrayList<>(dataBundleList);
   }
 
   public SharedMemory getLastSharedMemory() {
-    return lastSharedMemory;
+    return sharedMemoryList.isEmpty() ? null : Iterables.getLast(sharedMemoryList);
+  }
+
+  public List<SharedMemory> getAllSharedMemories() {
+    return new ArrayList<>(sharedMemoryList);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiManager.java
index 05d1f3d58..5fb44efc9 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiManager.java
@@ -22,6 +22,7 @@ import android.net.wifi.WifiManager.AddNetworkResult;
 import android.net.wifi.WifiManager.LocalOnlyConnectionFailureListener;
 import android.net.wifi.WifiManager.MulticastLock;
 import android.net.wifi.WifiNetworkSpecifier;
+import android.net.wifi.WifiNetworkSuggestion;
 import android.net.wifi.WifiSsid;
 import android.net.wifi.WifiUsabilityStatsEntry;
 import android.os.Binder;
@@ -30,6 +31,7 @@ import android.os.Looper;
 import android.provider.Settings;
 import android.util.ArraySet;
 import android.util.Pair;
+import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -89,6 +91,8 @@ public class ShadowWifiManager {
   private SoftApConfiguration softApConfig;
   private final Object pnoRequestLock = new Object();
   private PnoScanRequest outstandingPnoScanRequest = null;
+  private ImmutableList<WifiNetworkSuggestion> lastAddedSuggestions = ImmutableList.of();
+  private int addNetworkSuggestionsResult;
 
   private final ConcurrentMap<LocalOnlyConnectionFailureListener, Executor>
       localOnlyConnectionFailureListenerExecutorMap = new ConcurrentHashMap<>();
@@ -107,6 +111,25 @@ public class ShadowWifiManager {
             executor.execute(() -> failureListener.onConnectionFailed(specifier, failureReason)));
   }
 
+  /** Uses the given result as the return value for {@link WifiManager#addNetworkSuggestions}. */
+  public void setAddNetworkSuggestionsResult(int result) {
+    addNetworkSuggestionsResult = result;
+  }
+
+  @Implementation(minSdk = Q)
+  protected int addNetworkSuggestions(List<WifiNetworkSuggestion> networkSuggestions) {
+    Preconditions.checkNotNull(networkSuggestions);
+    if (addNetworkSuggestionsResult == WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS) {
+      lastAddedSuggestions = ImmutableList.copyOf(networkSuggestions);
+    }
+    return addNetworkSuggestionsResult;
+  }
+
+  @Implementation(minSdk = R)
+  protected List<WifiNetworkSuggestion> getNetworkSuggestions() {
+    return lastAddedSuggestions;
+  }
+
   @Implementation(minSdk = UPSIDE_DOWN_CAKE)
   protected void addLocalOnlyConnectionFailureListener(
       Executor executor, LocalOnlyConnectionFailureListener listener) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiP2pManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiP2pManager.java
index a433db1e5..a8b2c05cc 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiP2pManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiP2pManager.java
@@ -64,17 +64,18 @@ public class ShadowWifiP2pManager {
       return;
     }
 
-    handler.post(new Runnable() {
-      @Override
-      public void run() {
-        if (nextActionFailure == -1) {
-          al.onSuccess();
-        } else {
-          al.onFailure(nextActionFailure);
-        }
-        nextActionFailure = NO_FAILURE;
-      }
-    });
+    handler.post(
+        new Runnable() {
+          @Override
+          public void run() {
+            if (nextActionFailure == -1) {
+              al.onSuccess();
+            } else {
+              al.onFailure(nextActionFailure);
+            }
+            nextActionFailure = NO_FAILURE;
+          }
+        });
   }
 
   @Implementation
@@ -83,12 +84,13 @@ public class ShadowWifiP2pManager {
       return;
     }
 
-    handler.post(new Runnable() {
-      @Override
-      public void run() {
-        gl.onGroupInfoAvailable(p2pGroupmap.get(c));
-      }
-    });
+    handler.post(
+        new Runnable() {
+          @Override
+          public void run() {
+            gl.onGroupInfoAvailable(p2pGroupmap.get(c));
+          }
+        });
   }
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiScanner.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiScanner.java
new file mode 100644
index 000000000..15e3efc57
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiScanner.java
@@ -0,0 +1,130 @@
+package org.robolectric.shadows;
+
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.net.wifi.IWifiScannerListener;
+import android.net.wifi.ScanResult;
+import android.net.wifi.WifiScanner;
+import android.net.wifi.WifiScanner.ScanData;
+import android.net.wifi.WifiScanner.ScanListener;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.os.RemoteException;
+import android.util.SparseArray;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.Executor;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.ForType;
+
+/** Shadow for {@link android.net.wifi.WifiScanner}. */
+@Implements(value = WifiScanner.class, isInAndroidSdk = false)
+public class ShadowWifiScanner {
+  @RealObject protected WifiScanner realWifiScanner;
+
+  private List<ScanResult> scanResults = new ArrayList<>();
+
+  /**
+   * This method sets the scanResults that are immediately passed to the listeners, or returned by
+   * getSingleScanResults().
+   *
+   * <p>All registered listeners are notified immediately after this is called.
+   */
+  public void setScanResults(List<ScanResult> scanResults) {
+    this.scanResults = scanResults;
+    if (VERSION.SDK_INT >= VERSION_CODES.UPSIDE_DOWN_CAKE) {
+      notifyScanListenersU();
+    } else {
+      notifyScanListeners();
+    }
+  }
+
+  @Implementation(minSdk = VERSION_CODES.R)
+  protected List<ScanResult> getSingleScanResults() {
+    return scanResults;
+  }
+
+  private void notifyScanListenersU() {
+    Object listenerMapLock =
+        reflector(WifiScannerReflector.class, realWifiScanner).getListenerMapLock();
+
+    Map<WifiScanner.ActionListener, IWifiScannerListener.Stub> listenerMap =
+        reflector(WifiScannerReflector.class, realWifiScanner).getListenerMap();
+
+    List<IWifiScannerListener.Stub> listeners = null;
+    synchronized (listenerMapLock) {
+      listeners = new ArrayList<>(listenerMap.values());
+    }
+
+    for (IWifiScannerListener.Stub listener : listeners) {
+      try {
+        listener.onResults(buildScanData());
+      } catch (RemoteException e) {
+        throw new RuntimeException("Failed to notify scan listeners", e);
+      }
+    }
+  }
+
+  private void notifyScanListeners() {
+    Object listenerMapLock =
+        reflector(WifiScannerReflector.class, realWifiScanner).getListenerMapLock();
+    SparseArray<Object> listenerMap = null;
+    SparseArray<Executor> executorMap = null;
+
+    synchronized (listenerMapLock) {
+      listenerMap =
+          reflector(WifiScannerReflector.class, realWifiScanner).getListenerSparseArray().clone();
+
+      if (VERSION.SDK_INT >= VERSION_CODES.R) {
+        executorMap =
+            reflector(WifiScannerReflector.class, realWifiScanner).getExecutorSparseArray().clone();
+      }
+    }
+
+    // Iterate over keys
+    for (int i = 0; i < listenerMap.size(); i++) {
+      int key = listenerMap.keyAt(i);
+      Object value = listenerMap.valueAt(i);
+      Executor executor = null;
+
+      if (executorMap != null) {
+        executor = executorMap.get(key);
+      }
+
+      if (executor == null) {
+        executor = directExecutor();
+      }
+
+      if (value instanceof ScanListener) {
+        ScanListener listener = (ScanListener) value;
+        executor.execute(() -> listener.onResults(buildScanData()));
+      }
+    }
+  }
+
+  @ForType(WifiScanner.class)
+  interface WifiScannerReflector {
+    @Accessor("mListenerMapLock")
+    Object getListenerMapLock();
+
+    @Accessor("mListenerMap")
+    Map<WifiScanner.ActionListener, IWifiScannerListener.Stub> getListenerMap();
+
+    @Accessor("mListenerMap")
+    SparseArray<Object> getListenerSparseArray();
+
+    @Accessor("mExecutorMap")
+    SparseArray<Executor> getExecutorSparseArray();
+  }
+
+  private ScanData[] buildScanData() {
+    return new ScanData[] {
+      new WifiScanner.ScanData(/* id= */ 0, /* flags= */ 0, scanResults.toArray(new ScanResult[0]))
+    };
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindow.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindow.java
index 78feb1bb4..e4761f778 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindow.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindow.java
@@ -38,12 +38,14 @@ public class ShadowWindow {
       new HashSet<>();
 
   public static Window create(Context context) throws ClassNotFoundException {
-    String className = getApiLevel() >= M
-        ? "com.android.internal.policy.PhoneWindow"
-        : "com.android.internal.policy.impl.PhoneWindow";
+    String className =
+        getApiLevel() >= M
+            ? "com.android.internal.policy.PhoneWindow"
+            : "com.android.internal.policy.impl.PhoneWindow";
     Class<? extends Window> phoneWindowClass =
         (Class<? extends Window>) Window.class.getClassLoader().loadClass(className);
-    return ReflectionHelpers.callConstructor(phoneWindowClass, ClassParameter.from(Context.class, context));
+    return ReflectionHelpers.callConstructor(
+        phoneWindowClass, ClassParameter.from(Context.class, context));
   }
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManager.java
index cf40fdee5..43e25e0ba 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManager.java
@@ -4,5 +4,4 @@ import android.view.WindowManager;
 import org.robolectric.annotation.Implements;
 
 @Implements(WindowManager.class)
-public class ShadowWindowManager {
-}
+public class ShadowWindowManager {}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowXmlBlock.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowXmlBlock.java
index 578549a5c..202178ebd 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowXmlBlock.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowXmlBlock.java
@@ -12,8 +12,11 @@ import org.robolectric.res.android.ResXMLTree;
 import org.robolectric.res.android.ResourceTypes.Res_value;
 import org.xmlpull.v1.XmlPullParserException;
 
-@Implements(className = "android.content.res.XmlBlock", isInAndroidSdk = false)
-public class ShadowXmlBlock {
+@Implements(
+    className = "android.content.res.XmlBlock",
+    isInAndroidSdk = false,
+    shadowPicker = ShadowBaseXmlBlock.Picker.class)
+public class ShadowXmlBlock extends ShadowBaseXmlBlock {
 
   @Implementation
   protected static long nativeCreate(byte[] bArray, int off, int len) {
@@ -22,7 +25,7 @@ public class ShadowXmlBlock {
     }
 
     int bLen = bArray.length;
-    if (off < 0 || off >= bLen || len < 0 || len > bLen || (off+len) > bLen) {
+    if (off < 0 || off >= bLen || len < 0 || len > bLen || (off + len) > bLen) {
       throw new IndexOutOfBoundsException();
     }
 
@@ -32,7 +35,7 @@ public class ShadowXmlBlock {
 
     ResXMLTree osb = new ResXMLTree(null);
     osb.setTo(b, len, true);
-//    env->ReleaseByteArrayElements(bArray, b, 0);
+    //    env->ReleaseByteArrayElements(bArray, b, 0);
 
     if (osb.getError() != NO_ERROR) {
       throw new IllegalArgumentException();
@@ -55,16 +58,16 @@ public class ShadowXmlBlock {
   @Implementation(maxSdk = VERSION_CODES.P)
   protected static long nativeCreateParseState(long obj) {
     ResXMLTree osb = Registries.NATIVE_RES_XML_TREES.getNativeObject(obj);
-//    if (osb == NULL) {
-//      jniThrowNullPointerException(env, NULL);
-//      return 0;
-//    }
+    //    if (osb == NULL) {
+    //      jniThrowNullPointerException(env, NULL);
+    //      return 0;
+    //    }
 
     ResXMLParser st = new ResXMLParser(osb);
-//    if (st == NULL) {
-//      jniThrowException(env, "java/lang/OutOfMemoryError", NULL);
-//      return 0;
-//    }
+    //    if (st == NULL) {
+    //      jniThrowException(env, "java/lang/OutOfMemoryError", NULL);
+    //      return 0;
+    //    }
 
     st.restart();
 
@@ -74,10 +77,10 @@ public class ShadowXmlBlock {
   @Implementation(minSdk = VERSION_CODES.Q)
   protected static long nativeCreateParseState(long obj, int resid) {
     ResXMLTree osb = Registries.NATIVE_RES_XML_TREES.getNativeObject(obj);
-//    if (osb == NULL) {
-//      jniThrowNullPointerException(env, NULL);
-//      return 0;
-//    }
+    //    if (osb == NULL) {
+    //      jniThrowNullPointerException(env, NULL);
+    //      return 0;
+    //    }
 
     ResXMLParser st = new ResXMLParser(osb);
     //    if (st == NULL) {
@@ -112,7 +115,7 @@ public class ShadowXmlBlock {
         case ResXMLParser.event_code_t.END_DOCUMENT:
           return 1;
         case ResXMLParser.event_code_t.BAD_DOCUMENT:
-//                goto bad;
+          //                goto bad;
           throw new XmlPullParserException("Corrupt XML binary file");
         default:
           break;
@@ -225,8 +228,9 @@ public class ShadowXmlBlock {
     Res_value value = valueRef.get();
 
     return value.dataType == org.robolectric.res.android.ResourceTypes.Res_value.TYPE_REFERENCE
-        || value.dataType == org.robolectric.res.android.ResourceTypes.Res_value.TYPE_ATTRIBUTE
-        ? value.data : 0;
+            || value.dataType == org.robolectric.res.android.ResourceTypes.Res_value.TYPE_ATTRIBUTE
+        ? value.data
+        : 0;
   }
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/StreamConfigurationMapBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/StreamConfigurationMapBuilder.java
index b6e64d2a9..546d5dfae 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/StreamConfigurationMapBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/StreamConfigurationMapBuilder.java
@@ -77,7 +77,7 @@ public final class StreamConfigurationMapBuilder {
       for (Size size : entry.getValue()) {
         configsList.add(
             new StreamConfiguration(
-                entry.getKey(), size.getWidth(), size.getHeight(), /*input=*/ false));
+                entry.getKey(), size.getWidth(), size.getHeight(), /* input= */ false));
       }
     }
 
@@ -85,7 +85,7 @@ public final class StreamConfigurationMapBuilder {
       for (Size size : entry.getValue()) {
         configsList.add(
             new StreamConfiguration(
-                entry.getKey(), size.getWidth(), size.getHeight(), /*input=*/ true));
+                entry.getKey(), size.getWidth(), size.getHeight(), /* input= */ true));
       }
     }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/SystemFeatureListInitializer.java b/shadows/framework/src/main/java/org/robolectric/shadows/SystemFeatureListInitializer.java
index 7e3d1eb1c..be4038e14 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/SystemFeatureListInitializer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/SystemFeatureListInitializer.java
@@ -13,6 +13,8 @@ final class SystemFeatureListInitializer {
     int apiLevel = RuntimeEnvironment.getApiLevel();
     Map<String, Boolean> features = new HashMap<>();
 
+    features.put(PackageManager.FEATURE_TOUCHSCREEN, true);
+
     if (apiLevel >= VERSION_CODES.N_MR1) {
       features.put(PackageManager.FEATURE_WIFI, true);
     }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/WifiScannerDelegate.java b/shadows/framework/src/main/java/org/robolectric/shadows/WifiScannerDelegate.java
new file mode 100644
index 000000000..b1d94bd71
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/WifiScannerDelegate.java
@@ -0,0 +1,106 @@
+package org.robolectric.shadows;
+
+import android.net.wifi.WifiScanner;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Messenger;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * A system service interface delegate for IWifiScanner.
+ *
+ * <p>By default, Robolectric will provide stub return results for any IWifiScanner calls. This
+ * delegate is used whenever more substantial logic is needed.
+ */
+class WifiScannerDelegate {
+  public Messenger getMessenger() {
+    return new Messenger(new Handler(Looper.getMainLooper()));
+  }
+
+  public Bundle getAvailableChannels(int band, String packageName, String featureId) {
+    Bundle bundle = new Bundle();
+
+    // Mock available WiFi channels. See https://en.wikipedia.org/wiki/List_of_WLAN_channels
+    List<Integer> availableChannels = new ArrayList<>();
+
+    switch (band) {
+      case WifiScanner.WIFI_BAND_24_GHZ:
+        availableChannels =
+            Arrays.asList(
+                2412, 2417, 2422, 2427, 2432, 2437, 2442, 2447, 2452, 2457, 2462, 2467, 2472, 2477);
+        break;
+      case WifiScanner.WIFI_BAND_5_GHZ_WITH_DFS:
+        availableChannels =
+            Arrays.asList(
+                5180, 5200, 5220, 5240, 5260, 5280, 5300, 5320, 5500, 5520, 5540, 5560, 5580, 5600,
+                5620, 5640, 5660, 5680, 5700, 5720, 5745, 5765, 5785, 5805, 5825, 5845, 5865, 5885,
+                5905, 5925, 5945, 5965, 5985);
+        break;
+      case WifiScanner.WIFI_BAND_BOTH_WITH_DFS:
+        availableChannels =
+            Arrays.asList(
+                2412, 2417, 2422, 2427, 2432, 2437, 2442, 2447, 2452, 2457, 2462, 2467, 2472, 2477,
+                5180, 5200, 5220, 5240, 5260, 5280, 5300, 5320, 5500, 5520, 5540, 5560, 5580, 5600,
+                5620, 5640, 5660, 5680, 5700, 5720, 5745, 5765, 5785, 5805, 5825, 5845, 5865, 5885,
+                5905, 5925, 5945, 5965, 5985);
+        break;
+      case WifiScanner.WIFI_BAND_6_GHZ:
+        availableChannels =
+            Arrays.asList(
+                5975, 5995, 6015, 6035, 6055, 6075, 6095, 6115, 6135, 6155, 6175, 6195, 6215, 6235,
+                6255, 6275, 6295, 6315, 6335, 6355, 6375, 6395, 6415, 6435);
+        break;
+      case WifiScanner.WIFI_BAND_24_5_WITH_DFS_6_GHZ:
+        availableChannels =
+            Arrays.asList(
+                2412, 2417, 2422, 2427, 2432, 2437, 2442, 2447, 2452, 2457, 2462, 2467, 2472, 2477,
+                5180, 5200, 5220, 5240, 5260, 5280, 5300, 5320, 5500, 5520, 5540, 5560, 5580, 5600,
+                5620, 5640, 5660, 5680, 5700, 5720, 5745, 5765, 5785, 5805, 5825, 5845, 5865, 5885,
+                5905, 5925, 5945, 5965, 5985, 6015, 6035, 6055, 6075, 6095, 6115, 6135, 6155, 6175,
+                6195, 6215, 6235, 6255, 6275, 6295, 6315, 6335, 6355, 6375, 6395, 6415, 6435);
+        break;
+      case WifiScanner.WIFI_BAND_60_GHZ:
+        availableChannels =
+            Arrays.asList(
+                58320, 58340, 58360, 58380, 58400, 58420, 58440, 58460, 58480, 58500, 58520, 58540,
+                58560, 58580, 58600, 58620, 58640, 58660, 58680, 58700, 58720, 58740, 58760, 58780,
+                58800, 58820, 58840, 58860, 58880, 58900, 58920, 58940, 58960, 58980, 59000, 59020,
+                59040, 59060, 59080, 59100, 59120, 59140, 59160, 59180, 59200, 59220, 59240, 59260,
+                59280, 59300, 59320, 59340, 59360, 59380, 59400, 59420, 59440, 59460, 59480, 59500,
+                59520, 59540, 59560, 59580, 59600, 59620, 59640, 59660, 59680, 59700, 59720, 59740,
+                59760, 59780, 59800, 59820, 59840, 59860, 59880, 59900, 59920, 59940, 59960, 59980);
+        break;
+      case WifiScanner.WIFI_BAND_24_5_WITH_DFS_6_60_GHZ:
+      case WifiScanner.WIFI_BAND_UNSPECIFIED:
+      default:
+        availableChannels =
+            Arrays.asList(
+                2412, 2417, 2422, 2427, 2432, 2437, 2442, 2447, 2452, 2457, 2462, 2467, 2472, 2477,
+                5180, 5200, 5220, 5240, 5260, 5280, 5300, 5320, 5500, 5520, 5540, 5560, 5580, 5600,
+                5620, 5640, 5660, 5680, 5700, 5720, 5745, 5765, 5785, 5805, 5825, 5845, 5865, 5885,
+                5905, 5925, 5945, 5965, 5985, 6015, 6035, 6055, 6075, 6095, 6115, 6135, 6155, 6175,
+                6195, 6215, 6235, 6255, 6275, 6295, 6315, 6335, 6355, 6375, 6395, 6415, 6435, 58320,
+                58340, 58360, 58380, 58400, 58420, 58440, 58460, 58480, 58500, 58520, 58540, 58560,
+                58580, 58600, 58620, 58640, 58660, 58680, 58700, 58720, 58740, 58760, 58780, 58800,
+                58820, 58840, 58860, 58880, 58900, 58920, 58940, 58960, 58980, 59000, 59020, 59040,
+                59060, 59080, 59100, 59120, 59140, 59160, 59180, 59200, 59220, 59240, 59260, 59280,
+                59300, 59320, 59340, 59360, 59380, 59400, 59420, 59440, 59460, 59480, 59500, 59520,
+                59540, 59560, 59580, 59600, 59620, 59640, 59660, 59680, 59700, 59720, 59740, 59760,
+                59780, 59800, 59820, 59840, 59860, 59880, 59900, 59920, 59940, 59960, 59980);
+        break;
+    }
+
+    bundle.putIntegerArrayList(
+        WifiScanner.GET_AVAILABLE_CHANNELS_EXTRA, new ArrayList<>(availableChannels));
+
+    return bundle;
+  }
+
+  public Bundle getAvailableChannels(
+      int band, String packageName, String featureId, Bundle extras) {
+    return getAvailableChannels(band, packageName, featureId);
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/_Activity_.java b/shadows/framework/src/main/java/org/robolectric/shadows/_Activity_.java
index d638630ca..bcc680bd8 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/_Activity_.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/_Activity_.java
@@ -164,7 +164,7 @@ public interface _Activity_ {
       @WithType("android.app.Activity$NonConfigurationInstances")
           Object lastNonConfigurationInstances) {
     int apiLevel = RuntimeEnvironment.getApiLevel();
-    if (apiLevel <= Build.VERSION_CODES.LOLLIPOP) {
+    if (apiLevel == Build.VERSION_CODES.LOLLIPOP) {
       attach(
           baseContext,
           activityThread,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/package-info.java b/shadows/framework/src/main/java/org/robolectric/shadows/package-info.java
index a23bef17b..ffbb2bbeb 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/package-info.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/package-info.java
@@ -1,4 +1,2 @@
-/**
- * Package containing shadow classes for the Android SDK.
- */
-package org.robolectric.shadows;
\ No newline at end of file
+/** Package containing shadow classes for the Android SDK. */
+package org.robolectric.shadows;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/util/package-info.java b/shadows/framework/src/main/java/org/robolectric/shadows/util/package-info.java
index dd7cb8941..14b3db0c1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/util/package-info.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/util/package-info.java
@@ -1,4 +1,2 @@
-/**
- * Package containing shadow related utility classes.
- */
-package org.robolectric.shadows.util;
\ No newline at end of file
+/** Package containing shadow related utility classes. */
+package org.robolectric.shadows.util;
diff --git a/shadows/httpclient/build.gradle b/shadows/httpclient/build.gradle
index 4e77a09c3..f58bdb5cc 100644
--- a/shadows/httpclient/build.gradle
+++ b/shadows/httpclient/build.gradle
@@ -1,10 +1,8 @@
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
-apply plugin: DeployedRoboJavaModulePlugin
-
-apply plugin: ShadowsPlugin
+plugins {
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+    alias(libs.plugins.robolectric.shadows)
+}
 
 shadows {
     packageName "org.robolectric.shadows.httpclient"
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/ShadowAndroidHttpClient.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/ShadowAndroidHttpClient.java
index e92f40921..88c5d3b4c 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/ShadowAndroidHttpClient.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/ShadowAndroidHttpClient.java
@@ -16,7 +16,6 @@ import org.apache.http.params.HttpParams;
 import org.apache.http.protocol.HttpContext;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.annotation.RealObject;
 import org.robolectric.util.ReflectionHelpers;
 
 @Implements(AndroidHttpClient.class)
@@ -101,4 +100,4 @@ public class ShadowAndroidHttpClient {
       throws IOException, ClientProtocolException {
     return httpClient.execute(httpHost, httpRequest, responseHandler, httpContext);
   }
-}
\ No newline at end of file
+}
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/DefaultRequestDirector.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/DefaultRequestDirector.java
index fb5668309..0c4699ce1 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/DefaultRequestDirector.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/DefaultRequestDirector.java
@@ -201,72 +201,59 @@ public class DefaultRequestDirector implements RequestDirector {
       final HttpParams params) {
 
     if (log == null) {
-      throw new IllegalArgumentException
-        ("Log may not be null.");
+      throw new IllegalArgumentException("Log may not be null.");
     }
     if (requestExec == null) {
-      throw new IllegalArgumentException
-        ("Request executor may not be null.");
+      throw new IllegalArgumentException("Request executor may not be null.");
     }
     if (conman == null) {
-      throw new IllegalArgumentException
-        ("Client connection manager may not be null.");
+      throw new IllegalArgumentException("Client connection manager may not be null.");
     }
     if (reustrat == null) {
-      throw new IllegalArgumentException
-        ("Connection reuse strategy may not be null.");
+      throw new IllegalArgumentException("Connection reuse strategy may not be null.");
     }
     if (kastrat == null) {
-      throw new IllegalArgumentException
-        ("Connection keep alive strategy may not be null.");
+      throw new IllegalArgumentException("Connection keep alive strategy may not be null.");
     }
     if (rouplan == null) {
-      throw new IllegalArgumentException
-        ("Route planner may not be null.");
+      throw new IllegalArgumentException("Route planner may not be null.");
     }
     if (httpProcessor == null) {
-      throw new IllegalArgumentException
-        ("HTTP protocol processor may not be null.");
+      throw new IllegalArgumentException("HTTP protocol processor may not be null.");
     }
     if (retryHandler == null) {
-      throw new IllegalArgumentException
-        ("HTTP request retry handler may not be null.");
+      throw new IllegalArgumentException("HTTP request retry handler may not be null.");
     }
     if (redirectHandler == null) {
-      throw new IllegalArgumentException
-        ("Redirect handler may not be null.");
+      throw new IllegalArgumentException("Redirect handler may not be null.");
     }
     if (targetAuthHandler == null) {
-      throw new IllegalArgumentException
-        ("Target authentication handler may not be null.");
+      throw new IllegalArgumentException("Target authentication handler may not be null.");
     }
     if (proxyAuthHandler == null) {
-      throw new IllegalArgumentException
-        ("Proxy authentication handler may not be null.");
+      throw new IllegalArgumentException("Proxy authentication handler may not be null.");
     }
     if (userTokenHandler == null) {
-      throw new IllegalArgumentException
-        ("User token handler may not be null.");
+      throw new IllegalArgumentException("User token handler may not be null.");
     }
     if (params == null) {
-      throw new IllegalArgumentException
-        ("HTTP parameters may not be null");
+      throw new IllegalArgumentException("HTTP parameters may not be null");
     }
-    this.log               = log;
-    this.requestExec       = requestExec;
-    this.connManager       = conman;
-    this.reuseStrategy     = reustrat;
+    this.log = log;
+    this.requestExec = requestExec;
+    this.connManager = conman;
+    this.reuseStrategy = reustrat;
     this.keepAliveStrategy = kastrat;
-    this.routePlanner      = rouplan;
-    this.httpProcessor     = httpProcessor;
-    this.retryHandler      = retryHandler;
-    this.redirectHandler   = redirectHandler;
+    this.routePlanner = rouplan;
+    this.httpProcessor = httpProcessor;
+    this.retryHandler = retryHandler;
+    this.redirectHandler = redirectHandler;
     this.targetAuthHandler = targetAuthHandler;
-    this.proxyAuthHandler  = proxyAuthHandler;
-    this.userTokenHandler  = userTokenHandler;
-    this.params            = params;
+    this.proxyAuthHandler = proxyAuthHandler;
+    this.userTokenHandler = userTokenHandler;
+    this.params = params;
 
-    this.managedConn       = null;
+    this.managedConn = null;
 
     this.redirectCount = 0;
     this.maxRedirects = this.params.getIntParameter(ClientPNames.MAX_REDIRECTS, 100);
@@ -287,7 +274,8 @@ public class DefaultRequestDirector implements RequestDirector {
       final AuthenticationHandler proxyAuthHandler,
       final UserTokenHandler userTokenHandler,
       final HttpParams params) {
-    this(LogFactory.getLog(DefaultRequestDirector.class),
+    this(
+        LogFactory.getLog(DefaultRequestDirector.class),
         requestExec,
         conman,
         reustrat,
@@ -300,24 +288,18 @@ public class DefaultRequestDirector implements RequestDirector {
         proxyAuthHandler,
         userTokenHandler,
         params);
-
   }
 
-  private RequestWrapper wrapRequest(
-      final HttpRequest request) throws ProtocolException {
+  private RequestWrapper wrapRequest(final HttpRequest request) throws ProtocolException {
     if (request instanceof HttpEntityEnclosingRequest) {
-      return new EntityEnclosingRequestWrapper(
-          (HttpEntityEnclosingRequest) request);
+      return new EntityEnclosingRequestWrapper((HttpEntityEnclosingRequest) request);
     } else {
-      return new RequestWrapper(
-          request);
+      return new RequestWrapper(request);
     }
   }
 
-
-  protected void rewriteRequestURI(
-      final RequestWrapper request,
-      final HttpRoute route) throws ProtocolException {
+  protected void rewriteRequestURI(final RequestWrapper request, final HttpRoute route)
+      throws ProtocolException {
     try {
 
       URI uri = request.getURI();
@@ -337,24 +319,21 @@ public class DefaultRequestDirector implements RequestDirector {
       }
 
     } catch (URISyntaxException ex) {
-      throw new ProtocolException("Invalid URI: " +
-          request.getRequestLine().getUri(), ex);
+      throw new ProtocolException("Invalid URI: " + request.getRequestLine().getUri(), ex);
     }
   }
 
-
   // non-javadoc, see interface ClientRequestDirector
-  @Override public HttpResponse execute(HttpHost target, HttpRequest request,
-                HttpContext context)
-    throws HttpException, IOException {
+  @Override
+  public HttpResponse execute(HttpHost target, HttpRequest request, HttpContext context)
+      throws HttpException, IOException {
 
     HttpRequest orig = request;
     RequestWrapper origWrapper = wrapRequest(orig);
     origWrapper.setParams(params);
     HttpRoute origRoute = determineRoute(target, origWrapper, context);
 
-    virtualHost = (HttpHost) orig.getParams().getParameter(
-        ClientPNames.VIRTUAL_HOST);
+    virtualHost = (HttpHost) orig.getParams().getParameter(ClientPNames.VIRTUAL_HOST);
 
     RoutedRequest roureq = new RoutedRequest(origWrapper, origRoute);
 
@@ -381,15 +360,14 @@ public class DefaultRequestDirector implements RequestDirector {
 
         // Allocate connection if needed
         if (managedConn == null) {
-          ClientConnectionRequest connRequest = connManager.requestConnection(
-              route, userToken);
+          ClientConnectionRequest connRequest = connManager.requestConnection(route, userToken);
           if (orig instanceof AbortableHttpRequest) {
             ((AbortableHttpRequest) orig).setConnectionRequest(connRequest);
           }
 
           try {
             managedConn = connRequest.getConnection(timeout, TimeUnit.MILLISECONDS);
-          } catch(InterruptedException interrupted) {
+          } catch (InterruptedException interrupted) {
             InterruptedIOException iox = new InterruptedIOException();
             iox.initCause(interrupted);
             throw iox;
@@ -444,16 +422,11 @@ public class DefaultRequestDirector implements RequestDirector {
         HttpHost proxy = route.getProxyHost();
 
         // Populate the execution context
-        context.setAttribute(ExecutionContext.HTTP_TARGET_HOST,
-            target);
-        context.setAttribute(ExecutionContext.HTTP_PROXY_HOST,
-            proxy);
-        context.setAttribute(ExecutionContext.HTTP_CONNECTION,
-            managedConn);
-        context.setAttribute(ClientContext.TARGET_AUTH_STATE,
-            targetAuthState);
-        context.setAttribute(ClientContext.PROXY_AUTH_STATE,
-            proxyAuthState);
+        context.setAttribute(ExecutionContext.HTTP_TARGET_HOST, target);
+        context.setAttribute(ExecutionContext.HTTP_PROXY_HOST, proxy);
+        context.setAttribute(ExecutionContext.HTTP_CONNECTION, managedConn);
+        context.setAttribute(ClientContext.TARGET_AUTH_STATE, targetAuthState);
+        context.setAttribute(ClientContext.PROXY_AUTH_STATE, proxyAuthState);
 
         // Run request protocol interceptors
         requestExec.preProcess(wrapper, httpProcessor, context);
@@ -468,12 +441,14 @@ public class DefaultRequestDirector implements RequestDirector {
           if (!wrapper.isRepeatable()) {
             this.log.debug("Cannot retry non-repeatable request");
             if (retryReason != null) {
-              throw new NonRepeatableRequestException("Cannot retry request " +
-                "with a non-repeatable request entity.  The cause lists the " +
-                "reason the original request failed: " + retryReason);
+              throw new NonRepeatableRequestException(
+                  "Cannot retry request "
+                      + "with a non-repeatable request entity.  The cause lists the "
+                      + "reason the original request failed: "
+                      + retryReason);
             } else {
-              throw new NonRepeatableRequestException("Cannot retry request " +
-                  "with a non-repeatable request entity.");
+              throw new NonRepeatableRequestException(
+                  "Cannot retry request " + "with a non-repeatable request entity.");
             }
           }
 
@@ -489,9 +464,11 @@ public class DefaultRequestDirector implements RequestDirector {
             managedConn.close();
             if (retryHandler.retryRequest(ex, wrapper.getExecCount(), context)) {
               if (this.log.isInfoEnabled()) {
-                this.log.info("I/O exception ("+ ex.getClass().getName() +
-                    ") caught when processing request: "
-                    + ex.getMessage());
+                this.log.info(
+                    "I/O exception ("
+                        + ex.getClass().getName()
+                        + ") caught when processing request: "
+                        + ex.getMessage());
               }
               if (this.log.isDebugEnabled()) {
                 this.log.debug(ex.getMessage(), ex);
@@ -512,9 +489,7 @@ public class DefaultRequestDirector implements RequestDirector {
               this.log.debug("Proxied connection. Need to start over.");
               retrying = false;
             }
-
           }
-
         }
 
         if (response == null) {
@@ -526,7 +501,6 @@ public class DefaultRequestDirector implements RequestDirector {
         response.setParams(params);
         requestExec.postProcess(response, httpProcessor, context);
 
-
         // The connection is in or can be brought to a re-usable state.
         reuse = reuseStrategy.keepAlive(response, context);
         if (reuse) {
@@ -573,16 +547,14 @@ public class DefaultRequestDirector implements RequestDirector {
             managedConn.setState(userToken);
           }
         }
-
       } // while not done
 
-
       // check for entity, release connection if possible
-      if ((response == null) || (response.getEntity() == null) ||
-        !response.getEntity().isStreaming()) {
+      if ((response == null)
+          || (response.getEntity() == null)
+          || !response.getEntity().isStreaming()) {
         // connection not needed and (assumed to be) in re-usable state
-        if (reuse)
-          managedConn.markReusable();
+        if (reuse) managedConn.markReusable();
         releaseConnection();
       } else {
         // install an auto-release entity
@@ -600,9 +572,8 @@ public class DefaultRequestDirector implements RequestDirector {
   } // execute
 
   /**
-   * Returns the connection back to the connection manager
-   * and prepares for retrieving a new connection during
-   * the next request.
+   * Returns the connection back to the connection manager and prepares for retrieving a new
+   * connection during the next request.
    */
   protected void releaseConnection() {
     // Release the connection through the ManagedConnection instead of the
@@ -610,58 +581,46 @@ public class DefaultRequestDirector implements RequestDirector {
     // it is released.
     try {
       managedConn.releaseConnection();
-    } catch(IOException ignored) {
+    } catch (IOException ignored) {
       this.log.debug("IOException releasing connection", ignored);
     }
     managedConn = null;
   }
 
   /**
-   * Determines the route for a request.
-   * Called by {@link #execute}
-   * to determine the route for either the original or a followup request.
-   *
-   * @param target    the target host for the request.
-   *                  Implementations may accept {@code null}
-   *                  if they can still determine a route, for example
-   *                  to a default target or by inspecting the request.
-   * @param request   the request to execute
-   * @param context   the context to use for the execution,
-   *                  never {@code null}
+   * Determines the route for a request. Called by {@link #execute} to determine the route for
+   * either the original or a followup request.
    *
-   * @return  the route the request should take
-   *
-   * @throws HttpException    in case of a problem
+   * @param target the target host for the request. Implementations may accept {@code null} if they
+   *     can still determine a route, for example to a default target or by inspecting the request.
+   * @param request the request to execute
+   * @param context the context to use for the execution, never {@code null}
+   * @return the route the request should take
+   * @throws HttpException in case of a problem
    */
-  protected HttpRoute determineRoute(HttpHost    target,
-                       HttpRequest request,
-                       HttpContext context)
-    throws HttpException {
+  protected HttpRoute determineRoute(HttpHost target, HttpRequest request, HttpContext context)
+      throws HttpException {
 
     if (target == null) {
-      target = (HttpHost) request.getParams().getParameter(
-        ClientPNames.DEFAULT_HOST);
+      target = (HttpHost) request.getParams().getParameter(ClientPNames.DEFAULT_HOST);
     }
     if (target == null) {
-      throw new IllegalStateException
-        ("Target host must not be null, or set in parameters.");
+      throw new IllegalStateException("Target host must not be null, or set in parameters.");
     }
 
     return this.routePlanner.determineRoute(target, request, context);
   }
 
-
   /**
    * Establishes the target route.
    *
-   * @param route     the route to establish
-   * @param context   the context for the request execution
-   *
-   * @throws HttpException    in case of a problem
-   * @throws IOException      in case of an IO problem
+   * @param route the route to establish
+   * @param context the context for the request execution
+   * @throws HttpException in case of a problem
+   * @throws IOException in case of an IO problem
    */
   protected void establishRoute(HttpRoute route, HttpContext context)
-    throws HttpException, IOException {
+      throws HttpException, IOException {
 
     HttpRouteDirector rowdy = new BasicRouteDirector();
     int step;
@@ -670,77 +629,67 @@ public class DefaultRequestDirector implements RequestDirector {
       step = rowdy.nextStep(route, fact);
 
       switch (step) {
+        case HttpRouteDirector.CONNECT_TARGET:
+        case HttpRouteDirector.CONNECT_PROXY:
+          managedConn.open(route, context, this.params);
+          break;
+
+        case HttpRouteDirector.TUNNEL_TARGET:
+          {
+            boolean secure = createTunnelToTarget(route, context);
+            this.log.debug("Tunnel to target created.");
+            managedConn.tunnelTarget(secure, this.params);
+          }
+          break;
 
-      case HttpRouteDirector.CONNECT_TARGET:
-      case HttpRouteDirector.CONNECT_PROXY:
-        managedConn.open(route, context, this.params);
-        break;
-
-      case HttpRouteDirector.TUNNEL_TARGET: {
-        boolean secure = createTunnelToTarget(route, context);
-        this.log.debug("Tunnel to target created.");
-        managedConn.tunnelTarget(secure, this.params);
-      }   break;
-
-      case HttpRouteDirector.TUNNEL_PROXY: {
-        // The most simple example for this case is a proxy chain
-        // of two proxies, where P1 must be tunnelled to P2.
-        // route: Source -> P1 -> P2 -> Target (3 hops)
-        // fact:  Source -> P1 -> Target       (2 hops)
-        final int hop = fact.getHopCount()-1; // the hop to establish
-        boolean secure = createTunnelToProxy(route, hop, context);
-        this.log.debug("Tunnel to proxy created.");
-        managedConn.tunnelProxy(route.getHopTarget(hop),
-                    secure, this.params);
-      }   break;
-
-
-      case HttpRouteDirector.LAYER_PROTOCOL:
-        managedConn.layerProtocol(context, this.params);
-        break;
-
-      case HttpRouteDirector.UNREACHABLE:
-        throw new IllegalStateException
-          ("Unable to establish route." +
-           "\nplanned = " + route +
-           "\ncurrent = " + fact);
-
-      case HttpRouteDirector.COMPLETE:
-        // do nothing
-        break;
-
-      default:
-        throw new IllegalStateException
-          ("Unknown step indicator "+step+" from RouteDirector.");
+        case HttpRouteDirector.TUNNEL_PROXY:
+          {
+            // The most simple example for this case is a proxy chain
+            // of two proxies, where P1 must be tunnelled to P2.
+            // route: Source -> P1 -> P2 -> Target (3 hops)
+            // fact:  Source -> P1 -> Target       (2 hops)
+            final int hop = fact.getHopCount() - 1; // the hop to establish
+            boolean secure = createTunnelToProxy(route, hop, context);
+            this.log.debug("Tunnel to proxy created.");
+            managedConn.tunnelProxy(route.getHopTarget(hop), secure, this.params);
+          }
+          break;
+
+        case HttpRouteDirector.LAYER_PROTOCOL:
+          managedConn.layerProtocol(context, this.params);
+          break;
+
+        case HttpRouteDirector.UNREACHABLE:
+          throw new IllegalStateException(
+              "Unable to establish route." + "\nplanned = " + route + "\ncurrent = " + fact);
+
+        case HttpRouteDirector.COMPLETE:
+          // do nothing
+          break;
+
+        default:
+          throw new IllegalStateException(
+              "Unknown step indicator " + step + " from RouteDirector.");
       } // switch
 
     } while (step > HttpRouteDirector.COMPLETE);
-
   } // establishConnection
 
-
   /**
-   * Creates a tunnel to the target server.
-   * The connection must be established to the (last) proxy.
-   * A CONNECT request for tunnelling through the proxy will
-   * be created and sent, the response received and checked.
-   * This method does <i>not</i> update the connection with
-   * information about the tunnel, that is left to the caller.
+   * Creates a tunnel to the target server. The connection must be established to the (last) proxy.
+   * A CONNECT request for tunnelling through the proxy will be created and sent, the response
+   * received and checked. This method does <i>not</i> update the connection with information about
+   * the tunnel, that is left to the caller.
    *
-   * @param route     the route to establish
-   * @param context   the context for request execution
-   *
-   * @return  {@code true} if the tunnelled route is secure,
-   *          {@code false} otherwise.
-   *          The implementation here always returns {@code false},
-   *          but derived classes may override.
-   *
-   * @throws HttpException    in case of a problem
-   * @throws IOException      in case of an IO problem
+   * @param route the route to establish
+   * @param context the context for request execution
+   * @return {@code true} if the tunnelled route is secure, {@code false} otherwise. The
+   *     implementation here always returns {@code false}, but derived classes may override.
+   * @throws HttpException in case of a problem
+   * @throws IOException in case of an IO problem
    */
-  protected boolean createTunnelToTarget(HttpRoute route,
-                       HttpContext context)
-    throws HttpException, IOException {
+  protected boolean createTunnelToTarget(HttpRoute route, HttpContext context)
+      throws HttpException, IOException {
 
     HttpHost proxy = route.getProxyHost();
     HttpHost target = route.getTargetHost();
@@ -759,18 +708,12 @@ public class DefaultRequestDirector implements RequestDirector {
       connect.setParams(this.params);
 
       // Populate the execution context
-      context.setAttribute(ExecutionContext.HTTP_TARGET_HOST,
-          target);
-      context.setAttribute(ExecutionContext.HTTP_PROXY_HOST,
-          proxy);
-      context.setAttribute(ExecutionContext.HTTP_CONNECTION,
-          managedConn);
-      context.setAttribute(ClientContext.TARGET_AUTH_STATE,
-          targetAuthState);
-      context.setAttribute(ClientContext.PROXY_AUTH_STATE,
-          proxyAuthState);
-      context.setAttribute(ExecutionContext.HTTP_REQUEST,
-          connect);
+      context.setAttribute(ExecutionContext.HTTP_TARGET_HOST, target);
+      context.setAttribute(ExecutionContext.HTTP_PROXY_HOST, proxy);
+      context.setAttribute(ExecutionContext.HTTP_CONNECTION, managedConn);
+      context.setAttribute(ClientContext.TARGET_AUTH_STATE, targetAuthState);
+      context.setAttribute(ClientContext.PROXY_AUTH_STATE, proxyAuthState);
+      context.setAttribute(ExecutionContext.HTTP_REQUEST, connect);
 
       this.requestExec.preProcess(connect, this.httpProcessor, context);
 
@@ -781,26 +724,24 @@ public class DefaultRequestDirector implements RequestDirector {
 
       int status = response.getStatusLine().getStatusCode();
       if (status < 200) {
-        throw new HttpException("Unexpected response to CONNECT request: " +
-            response.getStatusLine());
+        throw new HttpException(
+            "Unexpected response to CONNECT request: " + response.getStatusLine());
       }
 
-      CredentialsProvider credsProvider = (CredentialsProvider)
-        context.getAttribute(ClientContext.CREDS_PROVIDER);
+      CredentialsProvider credsProvider =
+          (CredentialsProvider) context.getAttribute(ClientContext.CREDS_PROVIDER);
 
       if (credsProvider != null && HttpClientParams.isAuthenticating(params)) {
         if (this.proxyAuthHandler.isAuthenticationRequested(response, context)) {
 
           this.log.debug("Proxy requested authentication");
-          Map<String, Header> challenges = this.proxyAuthHandler.getChallenges(
-              response, context);
+          Map<String, Header> challenges = this.proxyAuthHandler.getChallenges(response, context);
           try {
             processChallenges(
-                challenges, this.proxyAuthState, this.proxyAuthHandler,
-                response, context);
+                challenges, this.proxyAuthState, this.proxyAuthHandler, response, context);
           } catch (AuthenticationException ex) {
             if (this.log.isWarnEnabled()) {
-              this.log.warn("Authentication error: " +  ex.getMessage());
+              this.log.warn("Authentication error: " + ex.getMessage());
               break;
             }
           }
@@ -820,7 +761,6 @@ public class DefaultRequestDirector implements RequestDirector {
             } else {
               this.managedConn.close();
             }
-
           }
 
         } else {
@@ -841,8 +781,8 @@ public class DefaultRequestDirector implements RequestDirector {
       }
 
       this.managedConn.close();
-      throw new TunnelRefusedException("CONNECT refused by proxy: " +
-          response.getStatusLine(), response);
+      throw new TunnelRefusedException(
+          "CONNECT refused by proxy: " + response.getStatusLine(), response);
     }
 
     this.managedConn.markReusable();
@@ -852,31 +792,22 @@ public class DefaultRequestDirector implements RequestDirector {
     // Even if that is secure, the hop to the target may be insecure.
     // Leave it to derived classes, consider insecure by default here.
     return false;
-
   } // createTunnelToTarget
 
-
-
   /**
-   * Creates a tunnel to an intermediate proxy.
-   * This method is <i>not</i> implemented in this class.
+   * Creates a tunnel to an intermediate proxy. This method is <i>not</i> implemented in this class.
    * It just throws an exception here.
    *
-   * @param route     the route to establish
-   * @param hop       the hop in the route to establish now.
-   *                  {@code route.getHopTarget(hop)}
-   *                  will return the proxy to tunnel to.
-   * @param context   the context for request execution
-   *
-   * @return  {@code true} if the partially tunnelled connection
-   *          is secure, {@code false} otherwise.
-   *
-   * @throws HttpException    in case of a problem
-   * @throws IOException      in case of an IO problem
+   * @param route the route to establish
+   * @param hop the hop in the route to establish now. {@code route.getHopTarget(hop)} will return
+   *     the proxy to tunnel to.
+   * @param context the context for request execution
+   * @return {@code true} if the partially tunnelled connection is secure, {@code false} otherwise.
+   * @throws HttpException in case of a problem
+   * @throws IOException in case of an IO problem
    */
-  protected boolean createTunnelToProxy(HttpRoute route, int hop,
-                      HttpContext context)
-    throws HttpException, IOException {
+  protected boolean createTunnelToProxy(HttpRoute route, int hop, HttpContext context)
+      throws HttpException, IOException {
 
     // Have a look at createTunnelToTarget and replicate the parts
     // you need in a custom derived class. If your proxies don't require
@@ -887,23 +818,18 @@ public class DefaultRequestDirector implements RequestDirector {
     // complexity. Feel free to submit patches that refactor the code in
     // createTunnelToTarget to facilitate re-use for proxy tunnelling.
 
-    throw new UnsupportedOperationException
-      ("Proxy chains are not supported.");
+    throw new UnsupportedOperationException("Proxy chains are not supported.");
   }
 
-
-
   /**
-   * Creates the CONNECT request for tunnelling.
-   * Called by {@link #createTunnelToTarget createTunnelToTarget}.
-   *
-   * @param route     the route to establish
-   * @param context   the context for request execution
+   * Creates the CONNECT request for tunnelling. Called by {@link #createTunnelToTarget
+   * createTunnelToTarget}.
    *
-   * @return  the CONNECT request for tunnelling
+   * @param route the route to establish
+   * @param context the context for request execution
+   * @return the CONNECT request for tunnelling
    */
-  protected HttpRequest createConnectRequest(HttpRoute route,
-                         HttpContext context) {
+  protected HttpRequest createConnectRequest(HttpRoute route, HttpContext context) {
     // see RFC 2817, section 5.2 and
     // INTERNET-DRAFT: Tunneling TCP based protocols through
     // Web proxy servers
@@ -913,8 +839,7 @@ public class DefaultRequestDirector implements RequestDirector {
     String host = target.getHostName();
     int port = target.getPort();
     if (port < 0) {
-      Scheme scheme = connManager.getSchemeRegistry().
-        getScheme(target.getSchemeName());
+      Scheme scheme = connManager.getSchemeRegistry().getScheme(target.getSchemeName());
       port = scheme.getDefaultPort();
     }
 
@@ -925,41 +850,35 @@ public class DefaultRequestDirector implements RequestDirector {
 
     String authority = buffer.toString();
     ProtocolVersion ver = HttpProtocolParams.getVersion(params);
-    HttpRequest req = new BasicHttpRequest
-      ("CONNECT", authority, ver);
+    HttpRequest req = new BasicHttpRequest("CONNECT", authority, ver);
 
     return req;
   }
 
-
   /**
    * Analyzes a response to check need for a followup.
    *
-   * @param roureq    the request and route.
-   * @param response  the response to analayze
-   * @param context   the context used for the current request execution
-   *
-   * @return  the followup request and route if there is a followup, or
-   *          {@code null} if the response should be returned as is
-   *
-   * @throws HttpException    in case of a problem
-   * @throws IOException      in case of an IO problem
+   * @param roureq the request and route.
+   * @param response the response to analayze
+   * @param context the context used for the current request execution
+   * @return the followup request and route if there is a followup, or {@code null} if the response
+   *     should be returned as is
+   * @throws HttpException in case of a problem
+   * @throws IOException in case of an IO problem
    */
-  protected RoutedRequest handleResponse(RoutedRequest roureq,
-                       HttpResponse response,
-                       HttpContext context)
-    throws HttpException, IOException {
+  protected RoutedRequest handleResponse(
+      RoutedRequest roureq, HttpResponse response, HttpContext context)
+      throws HttpException, IOException {
 
     HttpRoute route = roureq.getRoute();
     RequestWrapper request = roureq.getRequest();
 
     HttpParams params = request.getParams();
-    if (HttpClientParams.isRedirecting(params) &&
-        this.redirectHandler.isRedirectRequested(response, context)) {
+    if (HttpClientParams.isRedirecting(params)
+        && this.redirectHandler.isRedirectRequested(response, context)) {
 
       if (redirectCount >= maxRedirects) {
-        throw new RedirectException("Maximum redirects ("
-            + maxRedirects + ") exceeded");
+        throw new RedirectException("Maximum redirects (" + maxRedirects + ") exceeded");
       }
       redirectCount++;
 
@@ -968,10 +887,7 @@ public class DefaultRequestDirector implements RequestDirector {
 
       URI uri = this.redirectHandler.getLocationURI(response, context);
 
-      HttpHost newTarget = new HttpHost(
-          uri.getHost(),
-          uri.getPort(),
-          uri.getScheme());
+      HttpHost newTarget = new HttpHost(uri.getHost(), uri.getPort(), uri.getScheme());
 
       // Unset auth scope
       targetAuthState.setAuthScope(null);
@@ -1003,29 +919,26 @@ public class DefaultRequestDirector implements RequestDirector {
       return newRequest;
     }
 
-    CredentialsProvider credsProvider = (CredentialsProvider)
-      context.getAttribute(ClientContext.CREDS_PROVIDER);
+    CredentialsProvider credsProvider =
+        (CredentialsProvider) context.getAttribute(ClientContext.CREDS_PROVIDER);
 
     if (credsProvider != null && HttpClientParams.isAuthenticating(params)) {
 
       if (this.targetAuthHandler.isAuthenticationRequested(response, context)) {
 
-        HttpHost target = (HttpHost)
-          context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
+        HttpHost target = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
         if (target == null) {
           target = route.getTargetHost();
         }
 
         this.log.debug("Target requested authentication");
-        Map<String, Header> challenges = this.targetAuthHandler.getChallenges(
-            response, context);
+        Map<String, Header> challenges = this.targetAuthHandler.getChallenges(response, context);
         try {
-          processChallenges(challenges,
-              this.targetAuthState, this.targetAuthHandler,
-              response, context);
+          processChallenges(
+              challenges, this.targetAuthState, this.targetAuthHandler, response, context);
         } catch (AuthenticationException ex) {
           if (this.log.isWarnEnabled()) {
-            this.log.warn("Authentication error: " +  ex.getMessage());
+            this.log.warn("Authentication error: " + ex.getMessage());
             return null;
           }
         }
@@ -1047,15 +960,13 @@ public class DefaultRequestDirector implements RequestDirector {
         HttpHost proxy = route.getProxyHost();
 
         this.log.debug("Proxy requested authentication");
-        Map<String, Header> challenges = this.proxyAuthHandler.getChallenges(
-            response, context);
+        Map<String, Header> challenges = this.proxyAuthHandler.getChallenges(response, context);
         try {
-          processChallenges(challenges,
-              this.proxyAuthState, this.proxyAuthHandler,
-              response, context);
+          processChallenges(
+              challenges, this.proxyAuthState, this.proxyAuthHandler, response, context);
         } catch (AuthenticationException ex) {
           if (this.log.isWarnEnabled()) {
-            this.log.warn("Authentication error: " +  ex.getMessage());
+            this.log.warn("Authentication error: " + ex.getMessage());
             return null;
           }
         }
@@ -1075,11 +986,9 @@ public class DefaultRequestDirector implements RequestDirector {
     return null;
   } // handleResponse
 
-
   /**
-   * Shuts down the connection.
-   * This method is called from a {@code catch} block in
-   * {@link #execute execute} during exception handling.
+   * Shuts down the connection. This method is called from a {@code catch} block in {@link #execute
+   * execute} during exception handling.
    */
   private void abortConnection() {
     ManagedClientConnection mcc = managedConn;
@@ -1097,20 +1006,19 @@ public class DefaultRequestDirector implements RequestDirector {
       // ensure the connection manager properly releases this connection
       try {
         mcc.releaseConnection();
-      } catch(IOException ignored) {
+      } catch (IOException ignored) {
         this.log.debug("Error releasing connection", ignored);
       }
     }
   } // abortConnection
 
-
   private void processChallenges(
       final Map<String, Header> challenges,
       final AuthState authState,
       final AuthenticationHandler authHandler,
       final HttpResponse response,
       final HttpContext context)
-        throws MalformedChallengeException, AuthenticationException {
+      throws MalformedChallengeException, AuthenticationException {
 
     AuthScheme authScheme = authState.getAuthScheme();
     if (authScheme == null) {
@@ -1122,18 +1030,14 @@ public class DefaultRequestDirector implements RequestDirector {
 
     Header challenge = challenges.get(id.toLowerCase(Locale.ENGLISH));
     if (challenge == null) {
-      throw new AuthenticationException(id +
-        " authorization challenge expected, but not found");
+      throw new AuthenticationException(id + " authorization challenge expected, but not found");
     }
     authScheme.processChallenge(challenge);
     this.log.debug("Authorization challenge processed");
   }
 
-
   private void updateAuthState(
-      final AuthState authState,
-      final HttpHost host,
-      final CredentialsProvider credsProvider) {
+      final AuthState authState, final HttpHost host, final CredentialsProvider credsProvider) {
 
     if (!authState.isValid()) {
       return;
@@ -1147,11 +1051,8 @@ public class DefaultRequestDirector implements RequestDirector {
     }
 
     AuthScheme authScheme = authState.getAuthScheme();
-    AuthScope authScope = new AuthScope(
-        hostname,
-        port,
-        authScheme.getRealm(),
-        authScheme.getSchemeName());
+    AuthScope authScope =
+        new AuthScope(hostname, port, authScheme.getRealm(), authScheme.getSchemeName());
 
     if (this.log.isDebugEnabled()) {
       this.log.debug("Authentication scope: " + authScope);
@@ -1175,5 +1076,4 @@ public class DefaultRequestDirector implements RequestDirector {
     authState.setAuthScope(authScope);
     authState.setCredentials(creds);
   }
-
 } // class DefaultClientRequestDirector
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/FakeHttp.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/FakeHttp.java
index 8b2f4a350..7710b0c76 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/FakeHttp.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/FakeHttp.java
@@ -6,20 +6,19 @@ import org.apache.http.Header;
 import org.apache.http.HttpRequest;
 import org.apache.http.HttpResponse;
 
-/**
- * Collection of static methods used interact with HTTP requests / responses.
- */
+/** Collection of static methods used interact with HTTP requests / responses. */
 public class FakeHttp {
   private static FakeHttpLayer instance = new FakeHttpLayer();
 
   /**
    * Sets up an HTTP response to be returned by calls to Apache's {@code HttpClient} implementers.
    *
-   * @param statusCode   the status code of the response
+   * @param statusCode the status code of the response
    * @param responseBody the body of the response
-   * @param headers      optional headers for the request
+   * @param headers optional headers for the request
    */
-  public static void addPendingHttpResponse(int statusCode, String responseBody, Header... headers) {
+  public static void addPendingHttpResponse(
+      int statusCode, String responseBody, Header... headers) {
     getFakeHttpLayer().addPendingHttpResponse(statusCode, responseBody, headers);
   }
 
@@ -61,7 +60,8 @@ public class FakeHttp {
   }
 
   /**
-   * Accessor to obtain HTTP requests made during the current test in the order in which they were made.
+   * Accessor to obtain HTTP requests made during the current test in the order in which they were
+   * made.
    *
    * @param index index of the request to retrieve.
    * @return the requested request.
@@ -84,12 +84,12 @@ public class FakeHttp {
   }
 
   public static boolean httpRequestWasMade(String uri) {
-    return getFakeHttpLayer().hasRequestMatchingRule(
-        new FakeHttpLayer.UriRequestMatcher(uri));
+    return getFakeHttpLayer().hasRequestMatchingRule(new FakeHttpLayer.UriRequestMatcher(uri));
   }
 
   /**
-   * Accessor to obtain metadata for an HTTP request made during the current test in the order in which they were made.
+   * Accessor to obtain metadata for an HTTP request made during the current test in the order in
+   * which they were made.
    *
    * @param index index of the request to retrieve.
    * @return the requested request metadata.
@@ -99,7 +99,8 @@ public class FakeHttp {
   }
 
   /**
-   * Accessor to obtain HTTP requests made during the current test in the order in which they were made.
+   * Accessor to obtain HTTP requests made during the current test in the order in which they were
+   * made.
    *
    * @return the requested request or null if there are none.
    */
@@ -109,7 +110,8 @@ public class FakeHttp {
   }
 
   /**
-   * Accessor to obtain metadata for an HTTP request made during the current test in the order in which they were made.
+   * Accessor to obtain metadata for an HTTP request made during the current test in the order in
+   * which they were made.
    *
    * @return the requested request metadata or null if there are none.
    */
@@ -120,8 +122,8 @@ public class FakeHttp {
   /**
    * Adds an HTTP response rule. The response will be returned when the rule is matched.
    *
-   * @param method   method to match.
-   * @param uri      uri to match.
+   * @param method method to match.
+   * @param uri uri to match.
    * @param response response to return when a match is found.
    */
   public static void addHttpResponseRule(String method, String uri, HttpResponse response) {
@@ -129,9 +131,10 @@ public class FakeHttp {
   }
 
   /**
-   * Adds an HTTP response rule with a default method of GET. The response will be returned when the rule is matched.
+   * Adds an HTTP response rule with a default method of GET. The response will be returned when the
+   * rule is matched.
    *
-   * @param uri      uri to match.
+   * @param uri uri to match.
    * @param response response to return when a match is found.
    */
   public static void addHttpResponseRule(String uri, HttpResponse response) {
@@ -141,7 +144,7 @@ public class FakeHttp {
   /**
    * Adds an HTTP response rule. The response will be returned when the rule is matched.
    *
-   * @param uri      uri to match.
+   * @param uri uri to match.
    * @param response response to return when a match is found.
    */
   public static void addHttpResponseRule(String uri, String response) {
@@ -152,21 +155,22 @@ public class FakeHttp {
    * Adds an HTTP response rule. The response will be returned when the rule is matched.
    *
    * @param requestMatcher custom {@code RequestMatcher}.
-   * @param response       response to return when a match is found.
+   * @param response response to return when a match is found.
    */
   public static void addHttpResponseRule(RequestMatcher requestMatcher, HttpResponse response) {
     getFakeHttpLayer().addHttpResponseRule(requestMatcher, response);
   }
 
   /**
-   * Adds an HTTP response rule. For each time the rule is matched, responses will be shifted
-   * off the list and returned. When all responses have been given and the rule is matched again,
-   * an exception will be thrown.
+   * Adds an HTTP response rule. For each time the rule is matched, responses will be shifted off
+   * the list and returned. When all responses have been given and the rule is matched again, an
+   * exception will be thrown.
    *
    * @param requestMatcher custom {@code RequestMatcher}.
-   * @param responses      responses to return in order when a match is found.
+   * @param responses responses to return in order when a match is found.
    */
-  public static void addHttpResponseRule(RequestMatcher requestMatcher, List<? extends HttpResponse> responses) {
+  public static void addHttpResponseRule(
+      RequestMatcher requestMatcher, List<? extends HttpResponse> responses) {
     getFakeHttpLayer().addHttpResponseRule(requestMatcher, responses);
   }
 
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/FakeHttpLayer.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/FakeHttpLayer.java
index ba508ba60..243413180 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/FakeHttpLayer.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/FakeHttpLayer.java
@@ -44,12 +44,13 @@ public class FakeHttpLayer {
   }
 
   public void addPendingHttpResponse(final HttpResponse httpResponse) {
-    addPendingHttpResponse(new HttpResponseGenerator() {
-      @Override
-      public HttpResponse getResponse(HttpRequest request) {
-        return httpResponse;
-      }
-    });
+    addPendingHttpResponse(
+        new HttpResponseGenerator() {
+          @Override
+          public HttpResponse getResponse(HttpRequest request) {
+            return httpResponse;
+          }
+        });
   }
 
   public void addPendingHttpResponse(HttpResponseGenerator httpResponseGenerator) {
@@ -76,9 +77,11 @@ public class FakeHttpLayer {
    * Add a response rule.
    *
    * @param requestMatcher Request matcher
-   * @param responses      A list of responses that are returned to matching requests in order from first to last.
+   * @param responses A list of responses that are returned to matching requests in order from first
+   *     to last.
    */
-  public void addHttpResponseRule(RequestMatcher requestMatcher, List<? extends HttpResponse> responses) {
+  public void addHttpResponseRule(
+      RequestMatcher requestMatcher, List<? extends HttpResponse> responses) {
     addHttpResponseRule(new RequestMatcherResponseRule(requestMatcher, responses));
   }
 
@@ -110,7 +113,12 @@ public class FakeHttpLayer {
     return defaultHttpResponse;
   }
 
-  public HttpResponse emulateRequest(HttpHost httpHost, HttpRequest httpRequest, HttpContext httpContext, RequestDirector requestDirector) throws HttpException, IOException {
+  public HttpResponse emulateRequest(
+      HttpHost httpHost,
+      HttpRequest httpRequest,
+      HttpContext httpContext,
+      RequestDirector requestDirector)
+      throws HttpException, IOException {
     if (logHttpRequests) {
       System.out.println("  <-- " + httpRequest.getRequestLine());
     }
@@ -141,6 +149,7 @@ public class FakeHttpLayer {
     addHttpResponse(httpResponse);
     return httpResponse;
   }
+
   public boolean hasPendingResponses() {
     return !pendingHttpResponses.isEmpty();
   }
@@ -155,10 +164,11 @@ public class FakeHttpLayer {
 
   /**
    * This method is not supposed to be consumed by tests. This exists solely for the purpose of
-   * logging real HTTP requests, so that functional/integration tests can verify if those were made, without
-   * messing with the fake http layer to actually perform the http call, instead of returning a mocked response.
+   * logging real HTTP requests, so that functional/integration tests can verify if those were made,
+   * without messing with the fake http layer to actually perform the http call, instead of
+   * returning a mocked response.
    *
-   * If you are just using mocked http calls, you should not even notice this method here.
+   * <p>If you are just using mocked http calls, you should not even notice this method here.
    *
    * @param requestInfo Request info object to add.
    */
@@ -208,11 +218,12 @@ public class FakeHttpLayer {
   }
 
   /**
-   * This method return a list containing all the HTTP responses logged by the fake http layer, be it
-   * mocked http responses, be it real http calls (if {code}interceptHttpRequests{/code} is set to false).
+   * This method return a list containing all the HTTP responses logged by the fake http layer, be
+   * it mocked http responses, be it real http calls (if {code}interceptHttpRequests{/code} is set
+   * to false).
    *
-   * It doesn't make much sense to call this method if said property is set to true, as you yourself are
-   * providing the response, but it's here nonetheless.
+   * <p>It doesn't make much sense to call this method if said property is set to true, as you
+   * yourself are providing the response, but it's here nonetheless.
    *
    * @return List of all HTTP Responses logged by the fake http layer.
    */
@@ -221,8 +232,8 @@ public class FakeHttpLayer {
   }
 
   /**
-   * As a consumer of the fake http call, you should never call this method. This should be used solely
-   * by components that exercises http calls.
+   * As a consumer of the fake http call, you should never call this method. This should be used
+   * solely by components that exercises http calls.
    *
    * @param response The final response received by the server
    */
@@ -240,26 +251,27 @@ public class FakeHttpLayer {
 
   /**
    * Helper method that returns the latest received response from the server.
+   *
    * @return The latest HTTP response or null, if no responses are available
    */
   public HttpResponse getLastHttpResponse() {
     if (httpResponses.isEmpty()) return null;
-    return httpResponses.get(httpResponses.size()-1) ;
+    return httpResponses.get(httpResponses.size() - 1);
   }
 
   /**
-   * Call this method if you want to ensure that there's no http responses logged from this point until
-   * the next response arrives. Helpful to ensure that the state is "clear" before actions are executed.
+   * Call this method if you want to ensure that there's no http responses logged from this point
+   * until the next response arrives. Helpful to ensure that the state is "clear" before actions are
+   * executed.
    */
   public void clearHttpResponses() {
     this.httpResponses.clear();
   }
 
   /**
-   * You can disable Robolectric's fake HTTP layer temporarily
-   * by calling this method.
-   * @param interceptHttpRequests whether all HTTP requests should be
-   *                              intercepted (true by default)
+   * You can disable Robolectric's fake HTTP layer temporarily by calling this method.
+   *
+   * @param interceptHttpRequests whether all HTTP requests should be intercepted (true by default)
    */
   public void interceptHttpRequests(boolean interceptHttpRequests) {
     this.interceptHttpRequests = interceptHttpRequests;
@@ -299,7 +311,8 @@ public class FakeHttpLayer {
       this.httpException = httpException;
     }
 
-    public RequestMatcherResponseRule(RequestMatcher requestMatcher, List<? extends HttpResponse> responses) {
+    public RequestMatcherResponseRule(
+        RequestMatcher requestMatcher, List<? extends HttpResponse> responses) {
       this.requestMatcher = requestMatcher;
       this.responses = responses;
     }
@@ -335,8 +348,8 @@ public class FakeHttpLayer {
 
     @Override
     public boolean matches(HttpRequest request) {
-      return request.getRequestLine().getMethod().equals(method) &&
-          request.getRequestLine().getUri().equals(uri);
+      return request.getRequestLine().getMethod().equals(method)
+          && request.getRequestLine().getUri().equals(uri);
     }
   }
 
@@ -362,7 +375,8 @@ public class FakeHttpLayer {
 
     public interface PostBodyMatcher {
       /**
-       * Hint: you can use EntityUtils.toString(actualPostBody) to help you implement your matches method.
+       * Hint: you can use EntityUtils.toString(actualPostBody) to help you implement your matches
+       * method.
        *
        * @param actualPostBody The post body of the actual request that we are matching against.
        * @return true if you consider the body to match
@@ -491,8 +505,8 @@ public class FakeHttpLayer {
 
     @Override
     public boolean matches(HttpRequest request) {
-      return request.getRequestLine().getMethod().equals(method) &&
-          uriRegex.matcher(request.getRequestLine().getUri()).matches();
+      return request.getRequestLine().getMethod().equals(method)
+          && uriRegex.matcher(request.getRequestLine().getUri()).matches();
     }
   }
 }
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpEntityStub.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpEntityStub.java
index 119ea5f14..b1b6ae267 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpEntityStub.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpEntityStub.java
@@ -10,39 +10,48 @@ import org.apache.http.HttpRequest;
 import org.apache.http.HttpResponse;
 
 public class HttpEntityStub implements HttpEntity {
-  @Override public boolean isRepeatable() {
+  @Override
+  public boolean isRepeatable() {
     return true;
   }
 
-  @Override public boolean isChunked() {
+  @Override
+  public boolean isChunked() {
     throw new UnsupportedOperationException();
   }
 
-  @Override public long getContentLength() {
+  @Override
+  public long getContentLength() {
     throw new UnsupportedOperationException();
   }
 
-  @Override public Header getContentType() {
+  @Override
+  public Header getContentType() {
     throw new UnsupportedOperationException();
   }
 
-  @Override public Header getContentEncoding() {
+  @Override
+  public Header getContentEncoding() {
     throw new UnsupportedOperationException();
   }
 
-  @Override public InputStream getContent() throws IOException, IllegalStateException {
+  @Override
+  public InputStream getContent() throws IOException, IllegalStateException {
     throw new UnsupportedOperationException();
   }
 
-  @Override public void writeTo(OutputStream outputStream) throws IOException {
+  @Override
+  public void writeTo(OutputStream outputStream) throws IOException {
     throw new UnsupportedOperationException();
   }
 
-  @Override public boolean isStreaming() {
+  @Override
+  public boolean isStreaming() {
     throw new UnsupportedOperationException();
   }
 
-  @Override public void consumeContent() throws IOException {
+  @Override
+  public void consumeContent() throws IOException {
     throw new UnsupportedOperationException();
   }
 
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpRedirect.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpRedirect.java
index 6c7013f5c..7071c8e89 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpRedirect.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpRedirect.java
@@ -56,5 +56,4 @@ class HttpRedirect extends HttpRequestBase {
   public String getMethod() {
     return this.method;
   }
-
 }
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpRequestInfo.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpRequestInfo.java
index a0b9c80db..62b2481b3 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpRequestInfo.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpRequestInfo.java
@@ -11,7 +11,11 @@ public class HttpRequestInfo {
   HttpContext httpContext;
   RequestDirector requestDirector;
 
-  public HttpRequestInfo(HttpRequest httpRequest, HttpHost httpHost, HttpContext httpContext, RequestDirector requestDirector) {
+  public HttpRequestInfo(
+      HttpRequest httpRequest,
+      HttpHost httpHost,
+      HttpContext httpContext,
+      RequestDirector requestDirector) {
     this.httpRequest = httpRequest;
     this.httpHost = httpHost;
     this.httpContext = httpContext;
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpResponseStub.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpResponseStub.java
index 26417fbaf..6206213fd 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpResponseStub.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/HttpResponseStub.java
@@ -10,112 +10,138 @@ import org.apache.http.StatusLine;
 import org.apache.http.params.HttpParams;
 
 public class HttpResponseStub implements HttpResponse {
-  @Override public StatusLine getStatusLine() {
+  @Override
+  public StatusLine getStatusLine() {
     throw new UnsupportedOperationException();
-
   }
 
-  @Override public void setStatusLine(StatusLine statusLine) {
+  @Override
+  public void setStatusLine(StatusLine statusLine) {
     throw new UnsupportedOperationException();
   }
 
-  @Override public void setStatusLine(ProtocolVersion protocolVersion, int i) {
+  @Override
+  public void setStatusLine(ProtocolVersion protocolVersion, int i) {
     throw new UnsupportedOperationException();
   }
 
-  @Override public void setStatusLine(ProtocolVersion protocolVersion, int i, String s) {
+  @Override
+  public void setStatusLine(ProtocolVersion protocolVersion, int i, String s) {
     throw new UnsupportedOperationException();
   }
 
-  @Override public void setStatusCode(int i) throws IllegalStateException {
+  @Override
+  public void setStatusCode(int i) throws IllegalStateException {
     throw new UnsupportedOperationException();
   }
 
-  @Override public void setReasonPhrase(String s) throws IllegalStateException {
+  @Override
+  public void setReasonPhrase(String s) throws IllegalStateException {
     throw new UnsupportedOperationException();
   }
 
-  @Override public HttpEntity getEntity() {
+  @Override
+  public HttpEntity getEntity() {
     throw new UnsupportedOperationException();
   }
 
-  @Override public void setEntity(HttpEntity httpEntity) {
+  @Override
+  public void setEntity(HttpEntity httpEntity) {
     throw new UnsupportedOperationException();
   }
 
-  @Override public Locale getLocale() {
+  @Override
+  public Locale getLocale() {
     throw new UnsupportedOperationException();
   }
 
-  @Override public void setLocale(Locale locale) {
+  @Override
+  public void setLocale(Locale locale) {
     throw new UnsupportedOperationException();
   }
 
-  @Override public ProtocolVersion getProtocolVersion() {
+  @Override
+  public ProtocolVersion getProtocolVersion() {
     throw new UnsupportedOperationException();
   }
 
-  @Override public boolean containsHeader(String s) {
+  @Override
+  public boolean containsHeader(String s) {
     throw new UnsupportedOperationException();
   }
 
-  @Override public Header[] getHeaders(String s) {
+  @Override
+  public Header[] getHeaders(String s) {
     throw new UnsupportedOperationException();
   }
 
-  @Override public Header getFirstHeader(String s) {
+  @Override
+  public Header getFirstHeader(String s) {
     throw new UnsupportedOperationException();
   }
 
-  @Override public Header getLastHeader(String s) {
+  @Override
+  public Header getLastHeader(String s) {
     throw new UnsupportedOperationException();
   }
 
-  @Override public Header[] getAllHeaders() {
+  @Override
+  public Header[] getAllHeaders() {
     throw new UnsupportedOperationException();
   }
 
-  @Override public void addHeader(Header header) {
+  @Override
+  public void addHeader(Header header) {
     throw new UnsupportedOperationException();
   }
 
-  @Override public void addHeader(String s, String s1) {
+  @Override
+  public void addHeader(String s, String s1) {
     throw new UnsupportedOperationException();
   }
 
-  @Override public void setHeader(Header header) {
+  @Override
+  public void setHeader(Header header) {
     throw new UnsupportedOperationException();
   }
 
-  @Override public void setHeader(String s, String s1) {
+  @Override
+  public void setHeader(String s, String s1) {
     throw new UnsupportedOperationException();
   }
 
-  @Override public void setHeaders(Header[] headers) {
+  @Override
+  public void setHeaders(Header[] headers) {
     throw new UnsupportedOperationException();
   }
 
-  @Override public void removeHeader(Header header) {
+  @Override
+  public void removeHeader(Header header) {
     throw new UnsupportedOperationException();
   }
 
-  @Override public void removeHeaders(String s) {
+  @Override
+  public void removeHeaders(String s) {
     throw new UnsupportedOperationException();
   }
 
-  @Override public HeaderIterator headerIterator() {
+  @Override
+  public HeaderIterator headerIterator() {
     throw new UnsupportedOperationException();
   }
 
-  @Override public HeaderIterator headerIterator(String s) {
+  @Override
+  public HeaderIterator headerIterator(String s) {
     throw new UnsupportedOperationException();
   }
 
-  @Override public HttpParams getParams() {
+  @Override
+  public HttpParams getParams() {
     throw new UnsupportedOperationException();
   }
 
-  @Override public void setParams(HttpParams httpParams) {
+  @Override
+  public void setParams(HttpParams httpParams) {
     throw new UnsupportedOperationException();
   }
 }
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/ParamsParser.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/ParamsParser.java
index 700ebae16..f4859c911 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/ParamsParser.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/ParamsParser.java
@@ -25,7 +25,8 @@ public class ParamsParser {
     return new LinkedHashMap<>();
   }
 
-  private static Map<String, String> parseParamsForRequestWithEntity(HttpEntityEnclosingRequestBase request) {
+  private static Map<String, String> parseParamsForRequestWithEntity(
+      HttpEntityEnclosingRequestBase request) {
     try {
       LinkedHashMap<String, String> map = new LinkedHashMap<>();
       HttpEntity entity = request.getEntity();
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/ShadowDefaultRequestDirector.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/ShadowDefaultRequestDirector.java
index 6160dfa0c..3899445e8 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/ShadowDefaultRequestDirector.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/ShadowDefaultRequestDirector.java
@@ -84,21 +84,21 @@ public class ShadowDefaultRequestDirector {
     this.httpParams = params;
 
     try {
-      redirector = new org.robolectric.shadows.httpclient.DefaultRequestDirector(
-          log,
-          requestExec,
-          conman,
-          reustrat,
-          kastrat,
-          rouplan,
-          httpProcessor,
-          retryHandler,
-          redirectHandler,
-          targetAuthHandler,
-          proxyAuthHandler,
-          userTokenHandler,
-          params
-      );
+      redirector =
+          new org.robolectric.shadows.httpclient.DefaultRequestDirector(
+              log,
+              requestExec,
+              conman,
+              reustrat,
+              kastrat,
+              rouplan,
+              httpProcessor,
+              retryHandler,
+              redirectHandler,
+              targetAuthHandler,
+              proxyAuthHandler,
+              userTokenHandler,
+              params);
     } catch (IllegalArgumentException ignored) {
       FakeHttp.getFakeHttpLayer().interceptHttpRequests(true);
     }
@@ -180,9 +180,11 @@ public class ShadowDefaultRequestDirector {
       HttpHost httpHost, HttpRequest httpRequest, HttpContext httpContext)
       throws HttpException, IOException {
     if (FakeHttp.getFakeHttpLayer().isInterceptingHttpRequests()) {
-      return FakeHttp.getFakeHttpLayer().emulateRequest(httpHost, httpRequest, httpContext, realObject);
+      return FakeHttp.getFakeHttpLayer()
+          .emulateRequest(httpHost, httpRequest, httpContext, realObject);
     } else {
-      FakeHttp.getFakeHttpLayer().addRequestInfo(new HttpRequestInfo(httpRequest, httpHost, httpContext, redirector));
+      FakeHttp.getFakeHttpLayer()
+          .addRequestInfo(new HttpRequestInfo(httpRequest, httpHost, httpContext, redirector));
       HttpResponse response = redirector.execute(httpHost, httpRequest, httpContext);
 
       if (FakeHttp.getFakeHttpLayer().isInterceptingResponseContent()) {
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/StatusLineStub.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/StatusLineStub.java
index ec978ea85..86b17a776 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/StatusLineStub.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/StatusLineStub.java
@@ -4,15 +4,18 @@ import org.apache.http.ProtocolVersion;
 import org.apache.http.StatusLine;
 
 public class StatusLineStub implements StatusLine {
-  @Override public ProtocolVersion getProtocolVersion() {
+  @Override
+  public ProtocolVersion getProtocolVersion() {
     throw new UnsupportedOperationException();
   }
 
-  @Override public int getStatusCode() {
+  @Override
+  public int getStatusCode() {
     throw new UnsupportedOperationException();
   }
 
-  @Override public String getReasonPhrase() {
+  @Override
+  public String getReasonPhrase() {
     throw new UnsupportedOperationException();
   }
 }
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/TestHttpResponse.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/TestHttpResponse.java
index 8cc8fa982..ac7d9efd1 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/TestHttpResponse.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/TestHttpResponse.java
@@ -53,19 +53,23 @@ public class TestHttpResponse extends HttpResponseStub {
     this.responseBody = responseBody.getBytes(UTF_8);
   }
 
-  @Override public StatusLine getStatusLine() {
+  @Override
+  public StatusLine getStatusLine() {
     return statusLine;
   }
 
-  @Override public HttpEntity getEntity() {
+  @Override
+  public HttpEntity getEntity() {
     return httpEntity;
   }
 
-  @Override public Header[] getAllHeaders() {
+  @Override
+  public Header[] getAllHeaders() {
     return headers;
   }
 
-  @Override public Header getFirstHeader(String s) {
+  @Override
+  public Header getFirstHeader(String s) {
     for (Header h : headers) {
       if (s.equalsIgnoreCase(h.getName())) {
         return h;
@@ -74,8 +78,9 @@ public class TestHttpResponse extends HttpResponseStub {
     return null;
   }
 
-  @Override public Header getLastHeader(String s) {
-    for (int i = headers.length -1; i >= 0; i--) {
+  @Override
+  public Header getLastHeader(String s) {
+    for (int i = headers.length - 1; i >= 0; i--) {
       if (headers[i].getName().equalsIgnoreCase(s)) {
         return headers[i];
       }
@@ -83,7 +88,8 @@ public class TestHttpResponse extends HttpResponseStub {
     return null;
   }
 
-  @Override public Header[] getHeaders(String s) {
+  @Override
+  public Header[] getHeaders(String s) {
     List<Header> found = new ArrayList<>();
     for (Header h : headers) {
       if (h.getName().equalsIgnoreCase(s)) found.add(h);
@@ -110,40 +116,46 @@ public class TestHttpResponse extends HttpResponseStub {
     }
   }
 
-  @Override public HeaderIterator headerIterator() {
+  @Override
+  public HeaderIterator headerIterator() {
     return new HeaderIterator() {
       int index = 0;
 
-      @Override public boolean hasNext() {
+      @Override
+      public boolean hasNext() {
         return index < headers.length;
       }
 
-      @Override public Header nextHeader() {
+      @Override
+      public Header nextHeader() {
         if (index >= headers.length) throw new NoSuchElementException();
         return headers[index++];
       }
 
-      @Override public Object next() {
+      @Override
+      public Object next() {
         return nextHeader();
       }
 
-      @Override public void remove() {
+      @Override
+      public void remove() {
         throw new UnsupportedOperationException();
       }
     };
   }
 
-
-  @Override public HeaderIterator headerIterator(final String s) {
+  @Override
+  public HeaderIterator headerIterator(final String s) {
     return new HeaderIterator() {
       int index = 0;
 
-      @Override public boolean hasNext() {
+      @Override
+      public boolean hasNext() {
         return nextIndex() != -1;
       }
 
       private int nextIndex() {
-        for (int i = index; i<headers.length; i++) {
+        for (int i = index; i < headers.length; i++) {
           if (headers[i].getName().equalsIgnoreCase(s)) {
             return i;
           }
@@ -151,32 +163,37 @@ public class TestHttpResponse extends HttpResponseStub {
         return -1;
       }
 
-      @Override public Header nextHeader() {
+      @Override
+      public Header nextHeader() {
         index = nextIndex();
         if (index == -1) throw new NoSuchElementException();
         return headers[index++];
       }
 
-      @Override public Object next() {
+      @Override
+      public Object next() {
         return nextHeader();
       }
 
-      @Override public void remove() {
+      @Override
+      public void remove() {
         throw new UnsupportedOperationException();
       }
     };
   }
 
-  @Override public boolean containsHeader(String s) {
+  @Override
+  public boolean containsHeader(String s) {
     return getFirstHeader(s) != null;
-
   }
 
-  @Override public HttpParams getParams() {
+  @Override
+  public HttpParams getParams() {
     return params;
   }
 
-  @Override public void setParams(HttpParams httpParams) {
+  @Override
+  public void setParams(HttpParams httpParams) {
     this.params = httpParams;
   }
 
@@ -188,60 +205,72 @@ public class TestHttpResponse extends HttpResponseStub {
 
     private ByteArrayInputStream inputStream;
 
-    @Override public long getContentLength() {
+    @Override
+    public long getContentLength() {
       return responseBody.length;
     }
 
-    @Override public Header getContentType() {
+    @Override
+    public Header getContentType() {
       return getFirstHeader("Content-Type");
     }
 
-    @Override public Header getContentEncoding() {
+    @Override
+    public Header getContentEncoding() {
       return getFirstHeader("Content-Encoding");
     }
 
-    @Override public boolean isStreaming() {
+    @Override
+    public boolean isStreaming() {
       return true;
     }
 
-    @Override public boolean isRepeatable() {
+    @Override
+    public boolean isRepeatable() {
       return true;
     }
 
-    @Override public InputStream getContent() throws IOException, IllegalStateException {
+    @Override
+    public InputStream getContent() throws IOException, IllegalStateException {
       openEntityContentStreamCount++;
-      inputStream = new ByteArrayInputStream(responseBody) {
-        @Override
-        public void close() throws IOException {
-          openEntityContentStreamCount--;
-          super.close();
-        }
-      };
+      inputStream =
+          new ByteArrayInputStream(responseBody) {
+            @Override
+            public void close() throws IOException {
+              openEntityContentStreamCount--;
+              super.close();
+            }
+          };
       return inputStream;
     }
 
-    @Override public void writeTo(OutputStream outputStream) throws IOException {
+    @Override
+    public void writeTo(OutputStream outputStream) throws IOException {
       outputStream.write(responseBody);
     }
 
-    @Override public void consumeContent() throws IOException {
-    }
+    @Override
+    public void consumeContent() throws IOException {}
   }
 
   public class TestStatusLine extends StatusLineStub {
-    @Override public ProtocolVersion getProtocolVersion() {
+    @Override
+    public ProtocolVersion getProtocolVersion() {
       return new HttpVersion(1, 0);
     }
 
-    @Override public int getStatusCode() {
+    @Override
+    public int getStatusCode() {
       return statusCode;
     }
 
-    @Override public String getReasonPhrase() {
+    @Override
+    public String getReasonPhrase() {
       return "HTTP status " + statusCode;
     }
 
-    @Override public String toString() {
+    @Override
+    public String toString() {
       return "TestStatusLine[" + getReasonPhrase() + "]";
     }
   }
diff --git a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/package-info.java b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/package-info.java
index b7a71586c..724a79285 100644
--- a/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/package-info.java
+++ b/shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/package-info.java
@@ -1,9 +1,9 @@
 /**
  * Shadows for Apache HTTP Client.
  *
- * To use this in your project, add the artifact {@code org.robolectric:shadows-httpclient}
- * to your project. These shadows are only provided for legacy compatibility. They are no
- * longer actively maintained and will be removed in a future release.
+ * <p>To use this in your project, add the artifact {@code org.robolectric:shadows-httpclient} to
+ * your project. These shadows are only provided for legacy compatibility. They are no longer
+ * actively maintained and will be removed in a future release.
  */
 @Deprecated
-package org.robolectric.shadows.httpclient;
\ No newline at end of file
+package org.robolectric.shadows.httpclient;
diff --git a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/AndroidHttpClientTest.java b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/AndroidHttpClientTest.java
index e5ef90720..0c62d8cbd 100644
--- a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/AndroidHttpClientTest.java
+++ b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/AndroidHttpClientTest.java
@@ -40,4 +40,4 @@ public class AndroidHttpClientTest {
     assertThat(CharStreams.toString(new InputStreamReader(resp.getEntity().getContent(), UTF_8)))
         .isEqualTo("foo");
   }
-}
\ No newline at end of file
+}
diff --git a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/FakeHttpTest.java b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/FakeHttpTest.java
index e65271a24..7e2ba4f83 100644
--- a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/FakeHttpTest.java
+++ b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/FakeHttpTest.java
@@ -31,13 +31,15 @@ public class FakeHttpTest {
   }
 
   @Test
-  public void httpRequestWasMade_returnsTrueIfRequestMatchingGivenRuleWasMade() throws IOException, HttpException {
+  public void httpRequestWasMade_returnsTrueIfRequestMatchingGivenRuleWasMade()
+      throws IOException, HttpException {
     makeRequest("http://example.com");
     assertTrue(FakeHttp.httpRequestWasMade("http://example.com"));
   }
 
   @Test
-  public void httpRequestWasMade_returnsFalseIfNoRequestMatchingGivenRuleWasMAde() throws IOException, HttpException {
+  public void httpRequestWasMade_returnsFalseIfNoRequestMatchingGivenRuleWasMAde()
+      throws IOException, HttpException {
     makeRequest("http://example.com");
     assertFalse(FakeHttp.httpRequestWasMade("http://example.org"));
   }
@@ -45,15 +47,28 @@ public class FakeHttpTest {
   private void makeRequest(String uri) throws HttpException, IOException {
     FakeHttp.addPendingHttpResponse(200, "a happy response body");
 
-    ConnectionKeepAliveStrategy connectionKeepAliveStrategy = new ConnectionKeepAliveStrategy() {
-      @Override
-      public long getKeepAliveDuration(HttpResponse httpResponse, HttpContext httpContext) {
-        return 0;
-      }
-
-    };
-    DefaultRequestDirector requestDirector = new DefaultRequestDirector(null, null, null, connectionKeepAliveStrategy, null, null, null, null, null, null, null, null);
+    ConnectionKeepAliveStrategy connectionKeepAliveStrategy =
+        new ConnectionKeepAliveStrategy() {
+          @Override
+          public long getKeepAliveDuration(HttpResponse httpResponse, HttpContext httpContext) {
+            return 0;
+          }
+        };
+    DefaultRequestDirector requestDirector =
+        new DefaultRequestDirector(
+            null,
+            null,
+            null,
+            connectionKeepAliveStrategy,
+            null,
+            null,
+            null,
+            null,
+            null,
+            null,
+            null,
+            null);
 
     requestDirector.execute(null, new HttpGet(uri), null);
   }
-}
\ No newline at end of file
+}
diff --git a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/ParamsParserTest.java b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/ParamsParserTest.java
index 8ecf948b8..8a1ff729b 100644
--- a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/ParamsParserTest.java
+++ b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/ParamsParserTest.java
@@ -21,7 +21,7 @@ public class ParamsParserTest {
     StringEntity entity = new StringEntity("param1=foobar");
     entity.setContentType("application/x-www-form-urlencoded");
     post.setEntity(entity);
-    Map<String,String> params = ParamsParser.parseParams(post);
+    Map<String, String> params = ParamsParser.parseParams(post);
     assertThat(params.get("param1")).isEqualTo("foobar");
   }
 
@@ -31,14 +31,14 @@ public class ParamsParserTest {
     StringEntity entity = new StringEntity("param1=foobar");
     entity.setContentType("application/x-www-form-urlencoded");
     put.setEntity(entity);
-    Map<String,String> params = ParamsParser.parseParams(put);
+    Map<String, String> params = ParamsParser.parseParams(put);
     assertThat(params.get("param1")).isEqualTo("foobar");
   }
 
   @Test
   public void parseParams_shouldDoNothingForEmptyEntity() throws Exception {
     HttpPut put = new HttpPut("example.com");
-    Map<String,String> params = ParamsParser.parseParams(put);
+    Map<String, String> params = ParamsParser.parseParams(put);
     assertThat(params).isEmpty();
   }
 
diff --git a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/ShadowDefaultRequestDirectorTest.java b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/ShadowDefaultRequestDirectorTest.java
index deaf7391b..3d58735f3 100644
--- a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/ShadowDefaultRequestDirectorTest.java
+++ b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/ShadowDefaultRequestDirectorTest.java
@@ -86,7 +86,9 @@ public class ShadowDefaultRequestDirectorTest {
   public void shouldPreferPendingResponses() throws Exception {
     FakeHttp.addPendingHttpResponse(new TestHttpResponse(200, "a happy response body"));
 
-    FakeHttp.addHttpResponseRule(HttpGet.METHOD_NAME, "http://some.uri",
+    FakeHttp.addHttpResponseRule(
+        HttpGet.METHOD_NAME,
+        "http://some.uri",
         new TestHttpResponse(200, "a cheery response body"));
 
     HttpResponse response = requestDirector.execute(null, new HttpGet("http://some.uri"), null);
@@ -98,7 +100,9 @@ public class ShadowDefaultRequestDirectorTest {
 
   @Test
   public void shouldReturnRequestsByRule() throws Exception {
-    FakeHttp.addHttpResponseRule(HttpGet.METHOD_NAME, "http://some.uri",
+    FakeHttp.addHttpResponseRule(
+        HttpGet.METHOD_NAME,
+        "http://some.uri",
         new TestHttpResponse(200, "a cheery response body"));
 
     HttpResponse response = requestDirector.execute(null, new HttpGet("http://some.uri"), null);
@@ -111,7 +115,9 @@ public class ShadowDefaultRequestDirectorTest {
   @Test
   public void shouldReturnRequestsByRule_MatchingMethod() throws Exception {
     FakeHttp.setDefaultHttpResponse(404, "no such page");
-    FakeHttp.addHttpResponseRule(HttpPost.METHOD_NAME, "http://some.uri",
+    FakeHttp.addHttpResponseRule(
+        HttpPost.METHOD_NAME,
+        "http://some.uri",
         new TestHttpResponse(200, "a cheery response body"));
 
     HttpResponse response = requestDirector.execute(null, new HttpGet("http://some.uri"), null);
@@ -337,17 +343,17 @@ public class ShadowDefaultRequestDirectorTest {
         .isEqualTo(URI.create("http://www.third.org"));
   }
 
-
   @Test
   public void shouldSupportConnectionTimeoutWithExceptions() throws Exception {
-    FakeHttp.setDefaultHttpResponse(new TestHttpResponse() {
-      @Override
-      public HttpParams getParams() {
-        HttpParams httpParams = super.getParams();
-        HttpConnectionParams.setConnectionTimeout(httpParams, -1);
-        return httpParams;
-      }
-    });
+    FakeHttp.setDefaultHttpResponse(
+        new TestHttpResponse() {
+          @Override
+          public HttpParams getParams() {
+            HttpParams httpParams = super.getParams();
+            HttpConnectionParams.setConnectionTimeout(httpParams, -1);
+            return httpParams;
+          }
+        });
 
     DefaultHttpClient client = new DefaultHttpClient();
     try {
@@ -361,14 +367,15 @@ public class ShadowDefaultRequestDirectorTest {
 
   @Test
   public void shouldSupportSocketTimeoutWithExceptions() throws Exception {
-    FakeHttp.setDefaultHttpResponse(new TestHttpResponse() {
-      @Override
-      public HttpParams getParams() {
-        HttpParams httpParams = super.getParams();
-        HttpConnectionParams.setSoTimeout(httpParams, -1);
-        return httpParams;
-      }
-    });
+    FakeHttp.setDefaultHttpResponse(
+        new TestHttpResponse() {
+          @Override
+          public HttpParams getParams() {
+            HttpParams httpParams = super.getParams();
+            HttpConnectionParams.setSoTimeout(httpParams, -1);
+            return httpParams;
+          }
+        });
 
     DefaultHttpClient client = new DefaultHttpClient();
     try {
diff --git a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/TestHttpResponseTest.java b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/TestHttpResponseTest.java
index f254648d5..bd53bd67f 100644
--- a/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/TestHttpResponseTest.java
+++ b/shadows/httpclient/src/test/java/org/robolectric/shadows/httpclient/TestHttpResponseTest.java
@@ -17,13 +17,12 @@ public class TestHttpResponseTest {
   @Test
   public void shouldSupportGetFirstHeader() throws Exception {
     HttpResponse resp =
-        new TestHttpResponse(304, "REDIRECTED",
-            new BasicHeader("Location", "http://bar.com"));
+        new TestHttpResponse(304, "REDIRECTED", new BasicHeader("Location", "http://bar.com"));
 
     assertThat(resp.getFirstHeader("None")).isNull();
     assertThat(new TestHttpResponse(200, "OK").getFirstHeader("Foo")).isNull();
 
-    for (String l : new String[] { "location", "Location" }) {
+    for (String l : new String[] {"location", "Location"}) {
       assertThat(resp.getFirstHeader(l).getValue()).isEqualTo("http://bar.com");
     }
   }
@@ -31,13 +30,15 @@ public class TestHttpResponseTest {
   @Test
   public void shouldSupportGetLastHeader() throws Exception {
     HttpResponse resp =
-        new TestHttpResponse(304, "REDIRECTED",
+        new TestHttpResponse(
+            304,
+            "REDIRECTED",
             new BasicHeader("Location", "http://bar.com"),
             new BasicHeader("Location", "http://zombo.com"));
 
     assertThat(resp.getLastHeader("None")).isNull();
 
-    for (String l : new String[] { "location", "Location" }) {
+    for (String l : new String[] {"location", "Location"}) {
       assertThat(resp.getLastHeader(l).getValue()).isEqualTo("http://zombo.com");
     }
   }
@@ -45,8 +46,7 @@ public class TestHttpResponseTest {
   @Test
   public void shouldSupportContainsHeader() throws Exception {
     HttpResponse resp =
-        new TestHttpResponse(304, "ZOMBO",
-            new BasicHeader("X-Zombo-Com", "Welcome"));
+        new TestHttpResponse(304, "ZOMBO", new BasicHeader("X-Zombo-Com", "Welcome"));
 
     assertThat(resp.containsHeader("X-Zombo-Com")).isTrue();
     assertThat(resp.containsHeader("Location")).isFalse();
@@ -55,7 +55,9 @@ public class TestHttpResponseTest {
   @Test
   public void shouldSupportHeaderIterator() throws Exception {
     HttpResponse resp =
-        new TestHttpResponse(304, "REDIRECTED",
+        new TestHttpResponse(
+            304,
+            "REDIRECTED",
             new BasicHeader("Location", "http://bar.com"),
             new BasicHeader("Location", "http://zombo.com"));
 
@@ -70,7 +72,9 @@ public class TestHttpResponseTest {
   @Test
   public void shouldSupportHeaderIteratorWithArg() throws Exception {
     HttpResponse resp =
-        new TestHttpResponse(304, "REDIRECTED",
+        new TestHttpResponse(
+            304,
+            "REDIRECTED",
             new BasicHeader("Location", "http://bar.com"),
             new BasicHeader("X-Zombo-Com", "http://zombo.com"),
             new BasicHeader("Location", "http://foo.com"));
@@ -84,16 +88,16 @@ public class TestHttpResponseTest {
     assertThat(it.hasNext()).isFalse();
   }
 
-
   @Test
   public void shouldSupportGetHeadersWithArg() throws Exception {
     HttpResponse resp =
-        new TestHttpResponse(304, "REDIRECTED",
+        new TestHttpResponse(
+            304,
+            "REDIRECTED",
             new BasicHeader("Location", "http://bar.com"),
             new BasicHeader("X-Zombo-Com", "http://zombo.com"),
             new BasicHeader("Location", "http://foo.com"));
 
-
     Header[] headers = resp.getHeaders("Location");
     assertThat(headers.length).isEqualTo(2);
     assertThat(headers[0].getValue()).isEqualTo("http://bar.com");
@@ -127,5 +131,4 @@ public class TestHttpResponseTest {
     assertThat(response.getHeaders("foo")[0].getValue()).isEqualTo("bletch");
     assertThat(response.getHeaders("foo")[1].getValue()).isEqualTo("baz");
   }
-
 }
diff --git a/shadows/multidex/build.gradle b/shadows/multidex/build.gradle
index 6dd76d3ea..9cd79281f 100644
--- a/shadows/multidex/build.gradle
+++ b/shadows/multidex/build.gradle
@@ -1,10 +1,8 @@
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
-apply plugin: DeployedRoboJavaModulePlugin
-
-apply plugin: ShadowsPlugin
+plugins {
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+    alias(libs.plugins.robolectric.shadows)
+}
 
 shadows {
     packageName "org.robolectric.shadows.multidex"
diff --git a/shadows/multidex/src/main/java/org/robolectric/shadows/multidex/ShadowAndroidXMultiDex.java b/shadows/multidex/src/main/java/org/robolectric/shadows/multidex/ShadowAndroidXMultiDex.java
index 1ef96701b..9da7ea5ac 100644
--- a/shadows/multidex/src/main/java/org/robolectric/shadows/multidex/ShadowAndroidXMultiDex.java
+++ b/shadows/multidex/src/main/java/org/robolectric/shadows/multidex/ShadowAndroidXMultiDex.java
@@ -12,5 +12,4 @@ public class ShadowAndroidXMultiDex {
   protected static void install(Context context) {
     // Do nothing since with Robolectric nothing is dexed.
   }
-
 }
diff --git a/shadows/multidex/src/main/java/org/robolectric/shadows/multidex/package-info.java b/shadows/multidex/src/main/java/org/robolectric/shadows/multidex/package-info.java
index 969b789da..78f05eae8 100644
--- a/shadows/multidex/src/main/java/org/robolectric/shadows/multidex/package-info.java
+++ b/shadows/multidex/src/main/java/org/robolectric/shadows/multidex/package-info.java
@@ -1,7 +1,7 @@
 /**
  * Shadows for the Android Multidex Library.
  *
- * To use this in your project, add the artifact {@code org.robolectric:shadows-multidex}
- * to your project.
+ * <p>To use this in your project, add the artifact {@code org.robolectric:shadows-multidex} to your
+ * project.
  */
-package org.robolectric.shadows.multidex;
\ No newline at end of file
+package org.robolectric.shadows.multidex;
diff --git a/shadows/playservices/build.gradle b/shadows/playservices/build.gradle
index 6b6759c33..4455c96ff 100644
--- a/shadows/playservices/build.gradle
+++ b/shadows/playservices/build.gradle
@@ -1,10 +1,8 @@
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
-apply plugin: DeployedRoboJavaModulePlugin
-
-apply plugin: ShadowsPlugin
+plugins {
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+    alias(libs.plugins.robolectric.shadows)
+}
 
 shadows {
     packageName "org.robolectric.shadows.gms"
diff --git a/shadows/playservices/src/main/java/org/robolectric/shadows/gms/ShadowGoogleAuthUtil.java b/shadows/playservices/src/main/java/org/robolectric/shadows/gms/ShadowGoogleAuthUtil.java
index 9e6a9b115..7c7ec4293 100644
--- a/shadows/playservices/src/main/java/org/robolectric/shadows/gms/ShadowGoogleAuthUtil.java
+++ b/shadows/playservices/src/main/java/org/robolectric/shadows/gms/ShadowGoogleAuthUtil.java
@@ -19,10 +19,10 @@ import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
 
 /**
- * Calls to static method of {@link GoogleAuthUtil} will be redirected to the provided
- * {@link GoogleAuthUtilImpl} implementation. Use {@link #provideImpl(GoogleAuthUtilImpl)}
- * to set the implementation instance. By default, a {@link GoogleAuthUtilImpl} is used in call
- * redirection. Use mocks or subclassing {@link GoogleAuthUtilImpl} to achieve desired behaviors.
+ * Calls to static method of {@link GoogleAuthUtil} will be redirected to the provided {@link
+ * GoogleAuthUtilImpl} implementation. Use {@link #provideImpl(GoogleAuthUtilImpl)} to set the
+ * implementation instance. By default, a {@link GoogleAuthUtilImpl} is used in call redirection.
+ * Use mocks or subclassing {@link GoogleAuthUtilImpl} to achieve desired behaviors.
  */
 @Implements(GoogleAuthUtil.class)
 public class ShadowGoogleAuthUtil {
@@ -49,9 +49,8 @@ public class ShadowGoogleAuthUtil {
   }
 
   @Implementation
-  public static synchronized List<AccountChangeEvent> getAccountChangeEvents(Context context,
-      int eventIndex, String accountName)
-          throws GoogleAuthException, IOException {
+  public static synchronized List<AccountChangeEvent> getAccountChangeEvents(
+      Context context, int eventIndex, String accountName) throws GoogleAuthException, IOException {
     return googleAuthUtilImpl.getAccountChangeEvents(context, eventIndex, accountName);
   }
 
@@ -68,8 +67,9 @@ public class ShadowGoogleAuthUtil {
   }
 
   @Implementation
-  public static synchronized String getToken(Context context, Account account, String scope,
-      Bundle extras) throws IOException, UserRecoverableAuthException, GoogleAuthException {
+  public static synchronized String getToken(
+      Context context, Account account, String scope, Bundle extras)
+      throws IOException, UserRecoverableAuthException, GoogleAuthException {
     return googleAuthUtilImpl.getToken(context, account, scope, extras);
   }
 
@@ -80,55 +80,65 @@ public class ShadowGoogleAuthUtil {
   }
 
   @Implementation
-  public static synchronized String getToken(Context context, String accountName, String scope,
-      Bundle extras) throws IOException, UserRecoverableAuthException, GoogleAuthException {
+  public static synchronized String getToken(
+      Context context, String accountName, String scope, Bundle extras)
+      throws IOException, UserRecoverableAuthException, GoogleAuthException {
     return googleAuthUtilImpl.getToken(context, accountName, scope, extras);
   }
 
   @Implementation
-  public static synchronized String getTokenWithNotification(Context context, Account account,
-      String scope, Bundle extras)
-          throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
+  public static synchronized String getTokenWithNotification(
+      Context context, Account account, String scope, Bundle extras)
+      throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
     return googleAuthUtilImpl.getTokenWithNotification(context, account, scope, extras);
   }
 
   @Implementation
-  public static synchronized String getTokenWithNotification(Context context, Account account,
-      String scope, Bundle extras, Intent callback)
-          throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
-    return googleAuthUtilImpl
-        .getTokenWithNotification(context, account, scope, extras, callback);
+  public static synchronized String getTokenWithNotification(
+      Context context, Account account, String scope, Bundle extras, Intent callback)
+      throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
+    return googleAuthUtilImpl.getTokenWithNotification(context, account, scope, extras, callback);
   }
 
   @Implementation
-  public static synchronized String getTokenWithNotification(Context context, Account account,
-      String scope, Bundle extras, String authority, Bundle syncBundle)
-          throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
-    return googleAuthUtilImpl
-        .getTokenWithNotification(context, account, scope, extras, authority, syncBundle);
+  public static synchronized String getTokenWithNotification(
+      Context context,
+      Account account,
+      String scope,
+      Bundle extras,
+      String authority,
+      Bundle syncBundle)
+      throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
+    return googleAuthUtilImpl.getTokenWithNotification(
+        context, account, scope, extras, authority, syncBundle);
   }
 
   @Implementation
-  public static synchronized String getTokenWithNotification(Context context, String accountName,
-      String scope, Bundle extras, Intent callback)
-          throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
-    return googleAuthUtilImpl
-        .getTokenWithNotification(context, accountName, scope, extras, callback);
+  public static synchronized String getTokenWithNotification(
+      Context context, String accountName, String scope, Bundle extras, Intent callback)
+      throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
+    return googleAuthUtilImpl.getTokenWithNotification(
+        context, accountName, scope, extras, callback);
   }
 
   @Implementation
-  public static synchronized String getTokenWithNotification(Context context, String accountName,
-      String scope, Bundle extras)
-          throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
+  public static synchronized String getTokenWithNotification(
+      Context context, String accountName, String scope, Bundle extras)
+      throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
     return googleAuthUtilImpl.getTokenWithNotification(context, accountName, scope, extras);
   }
 
   @Implementation
-  public static synchronized String getTokenWithNotification(Context context, String accountName,
-      String scope, Bundle extras, String authority, Bundle syncBundle)
-          throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
-    return googleAuthUtilImpl.getTokenWithNotification(context, accountName, scope, extras,
-        authority, syncBundle);
+  public static synchronized String getTokenWithNotification(
+      Context context,
+      String accountName,
+      String scope,
+      Bundle extras,
+      String authority,
+      Bundle syncBundle)
+      throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
+    return googleAuthUtilImpl.getTokenWithNotification(
+        context, accountName, scope, extras, authority, syncBundle);
   }
 
   @Implementation
@@ -143,8 +153,9 @@ public class ShadowGoogleAuthUtil {
     public void clearToken(Context context, String token)
         throws GooglePlayServicesAvailabilityException, GoogleAuthException, IOException {}
 
-    public List<AccountChangeEvent> getAccountChangeEvents(Context context, int eventIndex,
-        String accountName) throws GoogleAuthException, IOException {
+    public List<AccountChangeEvent> getAccountChangeEvents(
+        Context context, int eventIndex, String accountName)
+        throws GoogleAuthException, IOException {
       return new ArrayList<>();
     }
 
@@ -173,49 +184,58 @@ public class ShadowGoogleAuthUtil {
       return getToken(context, new Account(accountName, "robo"), scope, extras);
     }
 
-    public String getTokenWithNotification(Context context, Account account, String scope,
-        Bundle extras)
-            throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
+    public String getTokenWithNotification(
+        Context context, Account account, String scope, Bundle extras)
+        throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
       return "token";
     }
 
-    public String getTokenWithNotification(Context context, Account account, String scope,
-        Bundle extras, Intent callback)
-            throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
+    public String getTokenWithNotification(
+        Context context, Account account, String scope, Bundle extras, Intent callback)
+        throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
       if (callback == null) {
         throw new IllegalArgumentException("Callback cannot be null.");
       }
       return "token";
     }
 
-    public String getTokenWithNotification(Context context, Account account, String scope,
-        Bundle extras, String authority, Bundle syncBundle)
-            throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
+    public String getTokenWithNotification(
+        Context context,
+        Account account,
+        String scope,
+        Bundle extras,
+        String authority,
+        Bundle syncBundle)
+        throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
       if (authority == null || authority.length() == 0) {
         throw new IllegalArgumentException("Authority cannot be empty.");
       }
       return "token";
     }
 
-    public String getTokenWithNotification(Context context, String accountName, String scope,
-        Bundle extras)
-            throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
-      return getTokenWithNotification(context, new Account(accountName, "robo"), scope,
-          extras);
+    public String getTokenWithNotification(
+        Context context, String accountName, String scope, Bundle extras)
+        throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
+      return getTokenWithNotification(context, new Account(accountName, "robo"), scope, extras);
     }
 
-    public String getTokenWithNotification(Context context, String accountName, String scope,
-        Bundle extras, Intent callback)
-            throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
-      return getTokenWithNotification(context, new Account(accountName, "robo"), scope,
-          extras, callback);
+    public String getTokenWithNotification(
+        Context context, String accountName, String scope, Bundle extras, Intent callback)
+        throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
+      return getTokenWithNotification(
+          context, new Account(accountName, "robo"), scope, extras, callback);
     }
 
-    public String getTokenWithNotification(Context context, String accountName, String scope,
-        Bundle extras, String authority, Bundle syncBundle)
-            throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
-      return getTokenWithNotification(context, new Account(accountName, "robo"), scope,
-          extras, authority, syncBundle);
+    public String getTokenWithNotification(
+        Context context,
+        String accountName,
+        String scope,
+        Bundle extras,
+        String authority,
+        Bundle syncBundle)
+        throws IOException, UserRecoverableNotifiedException, GoogleAuthException {
+      return getTokenWithNotification(
+          context, new Account(accountName, "robo"), scope, extras, authority, syncBundle);
     }
 
     public void invalidateToken(Context context, String token) {}
diff --git a/shadows/playservices/src/main/java/org/robolectric/shadows/gms/ShadowGooglePlayServicesUtil.java b/shadows/playservices/src/main/java/org/robolectric/shadows/gms/ShadowGooglePlayServicesUtil.java
index 25ed90e1a..729b3e138 100644
--- a/shadows/playservices/src/main/java/org/robolectric/shadows/gms/ShadowGooglePlayServicesUtil.java
+++ b/shadows/playservices/src/main/java/org/robolectric/shadows/gms/ShadowGooglePlayServicesUtil.java
@@ -18,15 +18,14 @@ import org.robolectric.annotation.Resetter;
 
 /**
  * Calls to static method of {@link GooglePlayServicesUtil} will be redirected to the provided
- * {@link GooglePlayServicesUtilImpl} implementation. Use
- * {@link #provideImpl(GooglePlayServicesUtilImpl)} to
- * set the implementation instance. By default, a {@link GooglePlayServicesUtilImpl} is used in call
- * redirection. Use mocks or subclassing {@link GooglePlayServicesUtilImpl} to achieve desired
- * behaviors.
+ * {@link GooglePlayServicesUtilImpl} implementation. Use {@link
+ * #provideImpl(GooglePlayServicesUtilImpl)} to set the implementation instance. By default, a
+ * {@link GooglePlayServicesUtilImpl} is used in call redirection. Use mocks or subclassing {@link
+ * GooglePlayServicesUtilImpl} to achieve desired behaviors.
  */
 @Implements(GooglePlayServicesUtil.class)
 public class ShadowGooglePlayServicesUtil {
-  private static GooglePlayServicesUtilImpl googlePlayServicesUtilImpl = 
+  private static GooglePlayServicesUtilImpl googlePlayServicesUtilImpl =
       new GooglePlayServicesUtilImpl();
 
   public static synchronized GooglePlayServicesUtilImpl getImpl() {
@@ -53,17 +52,20 @@ public class ShadowGooglePlayServicesUtil {
   }
 
   @Implementation
-  public static synchronized boolean showErrorDialogFragment(int errorCode, Activity activity,
-      Fragment fragment, int requestCode, OnCancelListener cancelListener) {
+  public static synchronized boolean showErrorDialogFragment(
+      int errorCode,
+      Activity activity,
+      Fragment fragment,
+      int requestCode,
+      OnCancelListener cancelListener) {
     return googlePlayServicesUtilImpl.showErrorDialogFragment(
         errorCode, activity, fragment, requestCode, cancelListener);
   }
 
   @Implementation
-  public static synchronized boolean showErrorDialogFragment(int errorCode, Activity activity,
-      int requestCode) {
-    return googlePlayServicesUtilImpl.showErrorDialogFragment(
-        errorCode, activity, requestCode);
+  public static synchronized boolean showErrorDialogFragment(
+      int errorCode, Activity activity, int requestCode) {
+    return googlePlayServicesUtilImpl.showErrorDialogFragment(errorCode, activity, requestCode);
   }
 
   @Implementation
@@ -74,21 +76,21 @@ public class ShadowGooglePlayServicesUtil {
   }
 
   @Implementation
-  public static synchronized Dialog getErrorDialog(int errorCode, Activity activity,
-      int requestCode) {
+  public static synchronized Dialog getErrorDialog(
+      int errorCode, Activity activity, int requestCode) {
     return googlePlayServicesUtilImpl.getErrorDialog(errorCode, activity, requestCode);
   }
 
   @Implementation
-  public static synchronized Dialog getErrorDialog(int errorCode, Activity activity,
-      int requestCode, OnCancelListener cancelListener) {
+  public static synchronized Dialog getErrorDialog(
+      int errorCode, Activity activity, int requestCode, OnCancelListener cancelListener) {
     return googlePlayServicesUtilImpl.getErrorDialog(
         errorCode, activity, requestCode, cancelListener);
   }
 
   @Implementation
-  public static synchronized PendingIntent getErrorPendingIntent(int errorCode, Context context,
-      int requestCode) {
+  public static synchronized PendingIntent getErrorPendingIntent(
+      int errorCode, Context context, int requestCode) {
     return googlePlayServicesUtilImpl.getErrorPendingIntent(errorCode, context, requestCode);
   }
 
@@ -103,24 +105,23 @@ public class ShadowGooglePlayServicesUtil {
   }
 
   /**
-   * Class containing methods with same signatures of the static methods of
-   * {@link GooglePlayServicesUtil}.
+   * Class containing methods with same signatures of the static methods of {@link
+   * GooglePlayServicesUtil}.
    */
   public static class GooglePlayServicesUtilImpl {
     public Dialog getErrorDialog(int errorCode, Activity activity, int requestCode) {
       return getErrorDialog(errorCode, activity, requestCode, null);
     }
 
-    public Dialog getErrorDialog(int errorCode, Activity activity, int requestCode,
-        OnCancelListener cancelListener) {
+    public Dialog getErrorDialog(
+        int errorCode, Activity activity, int requestCode, OnCancelListener cancelListener) {
       if (errorCode == ConnectionResult.SUCCESS) {
         return null;
       }
       return new Dialog(RuntimeEnvironment.getApplication());
     }
 
-    public PendingIntent getErrorPendingIntent(int errorCode, Context context,
-        int requestCode) {
+    public PendingIntent getErrorPendingIntent(int errorCode, Context context, int requestCode) {
       if (errorCode == ConnectionResult.SUCCESS) {
         return null;
       }
@@ -140,8 +141,12 @@ public class ShadowGooglePlayServicesUtil {
       return ConnectionResult.SERVICE_MISSING;
     }
 
-    public boolean showErrorDialogFragment(int errorCode, Activity activity,
-        Fragment fragment, int requestCode, OnCancelListener cancelListener) {
+    public boolean showErrorDialogFragment(
+        int errorCode,
+        Activity activity,
+        Fragment fragment,
+        int requestCode,
+        OnCancelListener cancelListener) {
       return false;
     }
 
@@ -149,8 +154,8 @@ public class ShadowGooglePlayServicesUtil {
       return false;
     }
 
-    public boolean showErrorDialogFragment(int errorCode, Activity activity, int requestCode,
-        OnCancelListener cancelListener) {
+    public boolean showErrorDialogFragment(
+        int errorCode, Activity activity, int requestCode, OnCancelListener cancelListener) {
       return false;
     }
 
diff --git a/shadows/playservices/src/main/java/org/robolectric/shadows/gms/common/ShadowGoogleApiAvailability.java b/shadows/playservices/src/main/java/org/robolectric/shadows/gms/common/ShadowGoogleApiAvailability.java
index 867184a39..6d3236922 100644
--- a/shadows/playservices/src/main/java/org/robolectric/shadows/gms/common/ShadowGoogleApiAvailability.java
+++ b/shadows/playservices/src/main/java/org/robolectric/shadows/gms/common/ShadowGoogleApiAvailability.java
@@ -12,57 +12,59 @@ import org.robolectric.shadow.api.Shadow;
 
 @Implements(GoogleApiAvailability.class)
 public class ShadowGoogleApiAvailability {
-    private int availabilityCode = ConnectionResult.SERVICE_MISSING;
-    private boolean isUserResolvableError = false;
-    private String openSourceSoftwareLicenseInfo = "";
-    private Dialog errorDialog;
+  private int availabilityCode = ConnectionResult.SERVICE_MISSING;
+  private boolean isUserResolvableError = false;
+  private String openSourceSoftwareLicenseInfo = "";
+  private Dialog errorDialog;
 
-    @Implementation
-    public static GoogleApiAvailability getInstance(){
-        return InstanceHolder.INSTANCE;
-    }
+  @Implementation
+  public static GoogleApiAvailability getInstance() {
+    return InstanceHolder.INSTANCE;
+  }
 
-    @Implementation
-    public int isGooglePlayServicesAvailable(Context context){
-        return availabilityCode;
-    }
+  @Implementation
+  public int isGooglePlayServicesAvailable(Context context) {
+    return availabilityCode;
+  }
 
-    public void setIsGooglePlayServicesAvailable(int availabilityCode) {
-        this.availabilityCode = availabilityCode;
-    }
+  public void setIsGooglePlayServicesAvailable(int availabilityCode) {
+    this.availabilityCode = availabilityCode;
+  }
 
-    @Implementation
-    public final boolean isUserResolvableError(int errorCode) {
-        return isUserResolvableError;
-    }
+  @Implementation
+  public final boolean isUserResolvableError(int errorCode) {
+    return isUserResolvableError;
+  }
 
-    public void setIsUserResolvableError(final boolean isUserResolvableError){
-        this.isUserResolvableError = isUserResolvableError;
-    }
+  public void setIsUserResolvableError(final boolean isUserResolvableError) {
+    this.isUserResolvableError = isUserResolvableError;
+  }
 
-    @Implementation
-    public String getOpenSourceSoftwareLicenseInfo(Context context){
-        return openSourceSoftwareLicenseInfo;
-    }
+  @Implementation
+  public String getOpenSourceSoftwareLicenseInfo(Context context) {
+    return openSourceSoftwareLicenseInfo;
+  }
 
-    @Implementation
-    public Dialog getErrorDialog(Activity activity, int errorCode, int requestCode) {
-        return errorDialog;
-    }
+  @Implementation
+  public Dialog getErrorDialog(Activity activity, int errorCode, int requestCode) {
+    return errorDialog;
+  }
 
-    @Implementation
-    public Dialog getErrorDialog(Activity activity, int errorCode, int requestCode,
-                                 DialogInterface.OnCancelListener cancelListener) {
-        return errorDialog;
-    }
+  @Implementation
+  public Dialog getErrorDialog(
+      Activity activity,
+      int errorCode,
+      int requestCode,
+      DialogInterface.OnCancelListener cancelListener) {
+    return errorDialog;
+  }
 
-    public void setErrorDialog(final Dialog errorDialog){
-        this.errorDialog = errorDialog;
-    }
+  public void setErrorDialog(final Dialog errorDialog) {
+    this.errorDialog = errorDialog;
+  }
 
-    private static class InstanceHolder {
-        private static final GoogleApiAvailability INSTANCE = Shadow.newInstance(
-                GoogleApiAvailability.class, new Class[]{}, new Object[]{});
-
-    }
+  private static class InstanceHolder {
+    private static final GoogleApiAvailability INSTANCE =
+        Shadow.newInstance(GoogleApiAvailability.class, new Class[] {}, new Object[] {});
+  }
 }
diff --git a/shadows/playservices/src/main/java/org/robolectric/shadows/gms/package-info.java b/shadows/playservices/src/main/java/org/robolectric/shadows/gms/package-info.java
index 623837d6a..2f6993bf9 100644
--- a/shadows/playservices/src/main/java/org/robolectric/shadows/gms/package-info.java
+++ b/shadows/playservices/src/main/java/org/robolectric/shadows/gms/package-info.java
@@ -1,7 +1,7 @@
 /**
  * Shadows for the Google Play Services Library.
  *
- * To use this in your project, add the artifact {@code org.robolectric:shadows-play-services}
- * to your project.
+ * <p>To use this in your project, add the artifact {@code org.robolectric:shadows-play-services} to
+ * your project.
  */
-package org.robolectric.shadows.gms;
\ No newline at end of file
+package org.robolectric.shadows.gms;
diff --git a/shadows/playservices/src/test/java/org/robolectric/shadows/gms/ShadowGoogleAuthUtilTest.java b/shadows/playservices/src/test/java/org/robolectric/shadows/gms/ShadowGoogleAuthUtilTest.java
index de442fff8..1ee274078 100644
--- a/shadows/playservices/src/test/java/org/robolectric/shadows/gms/ShadowGoogleAuthUtilTest.java
+++ b/shadows/playservices/src/test/java/org/robolectric/shadows/gms/ShadowGoogleAuthUtilTest.java
@@ -23,17 +23,16 @@ import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.gms.ShadowGoogleAuthUtil.GoogleAuthUtilImpl;
 
-/**
- * Unit test for {@link ShadowGoogleAuthUtil}.
- */
+/** Unit test for {@link ShadowGoogleAuthUtil}. */
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, shadows = {ShadowGoogleAuthUtil.class})
+@Config(
+    manifest = Config.NONE,
+    shadows = {ShadowGoogleAuthUtil.class})
 public class ShadowGoogleAuthUtilTest {
 
   @Mock private GoogleAuthUtilImpl mockGoogleAuthUtil;
 
-  @Rule
-  public ExpectedException thrown = ExpectedException.none();
+  @Rule public ExpectedException thrown = ExpectedException.none();
 
   @Before
   public void setup() {
diff --git a/shadows/playservices/src/test/java/org/robolectric/shadows/gms/ShadowGooglePlayServicesUtilTest.java b/shadows/playservices/src/test/java/org/robolectric/shadows/gms/ShadowGooglePlayServicesUtilTest.java
index 781072d51..c828fa814 100644
--- a/shadows/playservices/src/test/java/org/robolectric/shadows/gms/ShadowGooglePlayServicesUtilTest.java
+++ b/shadows/playservices/src/test/java/org/robolectric/shadows/gms/ShadowGooglePlayServicesUtilTest.java
@@ -24,14 +24,14 @@ import org.robolectric.annotation.Config;
 import org.robolectric.shadows.gms.ShadowGooglePlayServicesUtil.GooglePlayServicesUtilImpl;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, shadows = {ShadowGooglePlayServicesUtil.class})
+@Config(
+    manifest = Config.NONE,
+    shadows = {ShadowGooglePlayServicesUtil.class})
 public class ShadowGooglePlayServicesUtilTest {
 
-  @Mock
-  private GooglePlayServicesUtilImpl mockGooglePlayServicesUtil;
+  @Mock private GooglePlayServicesUtilImpl mockGooglePlayServicesUtil;
 
-  @Rule
-  public ExpectedException thrown = ExpectedException.none();
+  @Rule public ExpectedException thrown = ExpectedException.none();
 
   @Before
   public void setup() {
@@ -60,8 +60,8 @@ public class ShadowGooglePlayServicesUtilTest {
   @Test
   public void canRedirectStaticMethodToImplementation() {
     ShadowGooglePlayServicesUtil.provideImpl(mockGooglePlayServicesUtil);
-    when(mockGooglePlayServicesUtil.isGooglePlayServicesAvailable(
-        any(Context.class))).thenReturn(ConnectionResult.INTERNAL_ERROR);
+    when(mockGooglePlayServicesUtil.isGooglePlayServicesAvailable(any(Context.class)))
+        .thenReturn(ConnectionResult.INTERNAL_ERROR);
     assertEquals(
         ConnectionResult.INTERNAL_ERROR,
         GooglePlayServicesUtil.isGooglePlayServicesAvailable(RuntimeEnvironment.getApplication()));
@@ -70,8 +70,8 @@ public class ShadowGooglePlayServicesUtilTest {
   @Test
   public void getErrorString_goesToRealImpl() {
     assertEquals("SUCCESS", GooglePlayServicesUtil.getErrorString(ConnectionResult.SUCCESS));
-    assertEquals("SERVICE_MISSING", GooglePlayServicesUtil
-        .getErrorString(ConnectionResult.SERVICE_MISSING));
+    assertEquals(
+        "SERVICE_MISSING", GooglePlayServicesUtil.getErrorString(ConnectionResult.SERVICE_MISSING));
   }
 
   @Test
@@ -86,14 +86,14 @@ public class ShadowGooglePlayServicesUtilTest {
 
   @Test
   public void getErrorDialog() {
-    assertNotNull(GooglePlayServicesUtil.getErrorDialog(
-        ConnectionResult.SERVICE_MISSING, new Activity(), 0));
-    assertNull(GooglePlayServicesUtil.getErrorDialog(
-        ConnectionResult.SUCCESS, new Activity(), 0));
-    assertNotNull(GooglePlayServicesUtil.getErrorDialog(
-        ConnectionResult.SERVICE_MISSING, new Activity(), 0, null));
-    assertNull(GooglePlayServicesUtil.getErrorDialog(
-        ConnectionResult.SUCCESS, new Activity(), 0, null));
+    assertNotNull(
+        GooglePlayServicesUtil.getErrorDialog(ConnectionResult.SERVICE_MISSING, new Activity(), 0));
+    assertNull(GooglePlayServicesUtil.getErrorDialog(ConnectionResult.SUCCESS, new Activity(), 0));
+    assertNotNull(
+        GooglePlayServicesUtil.getErrorDialog(
+            ConnectionResult.SERVICE_MISSING, new Activity(), 0, null));
+    assertNull(
+        GooglePlayServicesUtil.getErrorDialog(ConnectionResult.SUCCESS, new Activity(), 0, null));
   }
 
   @Test
diff --git a/shadows/playservices/src/test/java/org/robolectric/shadows/gms/common/ShadowGoogleApiAvailabilityTest.java b/shadows/playservices/src/test/java/org/robolectric/shadows/gms/common/ShadowGoogleApiAvailabilityTest.java
index 796b8d933..02d057a93 100644
--- a/shadows/playservices/src/test/java/org/robolectric/shadows/gms/common/ShadowGoogleApiAvailabilityTest.java
+++ b/shadows/playservices/src/test/java/org/robolectric/shadows/gms/common/ShadowGoogleApiAvailabilityTest.java
@@ -18,109 +18,108 @@ import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.gms.Shadows;
 
-/**
- * Created by diegotori on 2/14/16.
- */
+/** Created by diegotori on 2/14/16. */
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, shadows = {ShadowGoogleApiAvailability.class})
+@Config(
+    manifest = Config.NONE,
+    shadows = {ShadowGoogleApiAvailability.class})
 public class ShadowGoogleApiAvailabilityTest {
 
-    private Context roboContext;
+  private Context roboContext;
 
-    @Before
-    public void setUp() {
+  @Before
+  public void setUp() {
     roboContext = RuntimeEnvironment.getApplication();
-    }
+  }
 
-    @After
-    public void tearDown() {
-        roboContext = null;
-    }
+  @After
+  public void tearDown() {
+    roboContext = null;
+  }
 
-    @Test
-    public void getInstance() {
-        //Given the expected GoogleApiAvailability instance
-        final GoogleApiAvailability expected = GoogleApiAvailability.getInstance();
+  @Test
+  public void getInstance() {
+    // Given the expected GoogleApiAvailability instance
+    final GoogleApiAvailability expected = GoogleApiAvailability.getInstance();
 
-        //When getting the actual one from the shadow
-        final GoogleApiAvailability actual = ShadowGoogleApiAvailability.getInstance();
+    // When getting the actual one from the shadow
+    final GoogleApiAvailability actual = ShadowGoogleApiAvailability.getInstance();
 
     // Then verify that the expected is a not null and equal to the actual one
     assertThat(expected).isEqualTo(actual);
-    }
-
-    @Test
-    public void shadowOf() {
-        final ShadowGoogleApiAvailability shadowGoogleApiAvailability
-                = Shadows.shadowOf(GoogleApiAvailability.getInstance());
-        assertThat(shadowGoogleApiAvailability).isNotNull();
-    }
-
-    @Test
-    public void setIsGooglePlayServicesAvailable() {
-        //Given an expected and injected ConnectionResult code
-        final ShadowGoogleApiAvailability shadowGoogleApiAvailability
-                = Shadows.shadowOf(GoogleApiAvailability.getInstance());
-        final int expectedCode = ConnectionResult.SUCCESS;
-        shadowGoogleApiAvailability.setIsGooglePlayServicesAvailable(expectedCode);
-
-        //When getting the actual ConnectionResult code
-        final int actualCode = GoogleApiAvailability.getInstance()
-                .isGooglePlayServicesAvailable(roboContext);
-
-        //Then verify that we got back our expected code and not the default one.
-        assertThat(actualCode)
-                .isEqualTo(expectedCode);
-    }
-
-    @Test
-    public void setIsUserResolvableError() {
-        //Given an injected user resolvable error flag
-        final ShadowGoogleApiAvailability shadowGoogleApiAvailability
-                = Shadows.shadowOf(GoogleApiAvailability.getInstance());
-        shadowGoogleApiAvailability.setIsUserResolvableError(true);
-
-        //When getting the actual flag value
-        final boolean actual = GoogleApiAvailability.getInstance()
-                .isUserResolvableError(ConnectionResult.API_UNAVAILABLE);
-
-        //Then verify that its equal to true
-        assertThat(actual).isTrue();
-    }
-
-    @Test
-    public void setErrorDialog(){
-        final ShadowGoogleApiAvailability shadowGoogleApiAvailability
-                = Shadows.shadowOf(GoogleApiAvailability.getInstance());
-        final Dialog expectedDialog = mock(Dialog.class);
-        final Activity mockActivity = mock(Activity.class);
-        final int mockErrorCode = ConnectionResult.API_UNAVAILABLE;
-        final int mockRequestCode = 1234;
-        shadowGoogleApiAvailability.setErrorDialog(expectedDialog);
-
-        final Dialog actualDialog = GoogleApiAvailability.getInstance()
-                .getErrorDialog(mockActivity, mockErrorCode, mockRequestCode);
-
-        assertThat(actualDialog)
-                .isEqualTo(expectedDialog);
-    }
-
-    @Test
-    public void setErrorDialog__OnCancelListenerMethod(){
-        final ShadowGoogleApiAvailability shadowGoogleApiAvailability
-                = Shadows.shadowOf(GoogleApiAvailability.getInstance());
-        final Dialog expectedDialog = mock(Dialog.class);
-        final Activity mockActivity = mock(Activity.class);
-        final DialogInterface.OnCancelListener mockOnCancelListener =
-                mock(DialogInterface.OnCancelListener.class);
-        final int mockErrorCode = ConnectionResult.API_UNAVAILABLE;
-        final int mockRequestCode = 1234;
-        shadowGoogleApiAvailability.setErrorDialog(expectedDialog);
-
-        final Dialog actualDialog = GoogleApiAvailability.getInstance()
-                .getErrorDialog(mockActivity, mockErrorCode, mockRequestCode, mockOnCancelListener);
-
-        assertThat(actualDialog)
-                .isEqualTo(expectedDialog);
-    }
+  }
+
+  @Test
+  public void shadowOf() {
+    final ShadowGoogleApiAvailability shadowGoogleApiAvailability =
+        Shadows.shadowOf(GoogleApiAvailability.getInstance());
+    assertThat(shadowGoogleApiAvailability).isNotNull();
+  }
+
+  @Test
+  public void setIsGooglePlayServicesAvailable() {
+    // Given an expected and injected ConnectionResult code
+    final ShadowGoogleApiAvailability shadowGoogleApiAvailability =
+        Shadows.shadowOf(GoogleApiAvailability.getInstance());
+    final int expectedCode = ConnectionResult.SUCCESS;
+    shadowGoogleApiAvailability.setIsGooglePlayServicesAvailable(expectedCode);
+
+    // When getting the actual ConnectionResult code
+    final int actualCode =
+        GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(roboContext);
+
+    // Then verify that we got back our expected code and not the default one.
+    assertThat(actualCode).isEqualTo(expectedCode);
+  }
+
+  @Test
+  public void setIsUserResolvableError() {
+    // Given an injected user resolvable error flag
+    final ShadowGoogleApiAvailability shadowGoogleApiAvailability =
+        Shadows.shadowOf(GoogleApiAvailability.getInstance());
+    shadowGoogleApiAvailability.setIsUserResolvableError(true);
+
+    // When getting the actual flag value
+    final boolean actual =
+        GoogleApiAvailability.getInstance().isUserResolvableError(ConnectionResult.API_UNAVAILABLE);
+
+    // Then verify that its equal to true
+    assertThat(actual).isTrue();
+  }
+
+  @Test
+  public void setErrorDialog() {
+    final ShadowGoogleApiAvailability shadowGoogleApiAvailability =
+        Shadows.shadowOf(GoogleApiAvailability.getInstance());
+    final Dialog expectedDialog = mock(Dialog.class);
+    final Activity mockActivity = mock(Activity.class);
+    final int mockErrorCode = ConnectionResult.API_UNAVAILABLE;
+    final int mockRequestCode = 1234;
+    shadowGoogleApiAvailability.setErrorDialog(expectedDialog);
+
+    final Dialog actualDialog =
+        GoogleApiAvailability.getInstance()
+            .getErrorDialog(mockActivity, mockErrorCode, mockRequestCode);
+
+    assertThat(actualDialog).isEqualTo(expectedDialog);
+  }
+
+  @Test
+  public void setErrorDialog__OnCancelListenerMethod() {
+    final ShadowGoogleApiAvailability shadowGoogleApiAvailability =
+        Shadows.shadowOf(GoogleApiAvailability.getInstance());
+    final Dialog expectedDialog = mock(Dialog.class);
+    final Activity mockActivity = mock(Activity.class);
+    final DialogInterface.OnCancelListener mockOnCancelListener =
+        mock(DialogInterface.OnCancelListener.class);
+    final int mockErrorCode = ConnectionResult.API_UNAVAILABLE;
+    final int mockRequestCode = 1234;
+    shadowGoogleApiAvailability.setErrorDialog(expectedDialog);
+
+    final Dialog actualDialog =
+        GoogleApiAvailability.getInstance()
+            .getErrorDialog(mockActivity, mockErrorCode, mockRequestCode, mockOnCancelListener);
+
+    assertThat(actualDialog).isEqualTo(expectedDialog);
+  }
 }
diff --git a/testapp/Android.bp b/testapp/Android.bp
index a8c52b815..0f7a3588d 100644
--- a/testapp/Android.bp
+++ b/testapp/Android.bp
@@ -8,7 +8,6 @@ android_library {
     resource_dirs: ["src/main/res"],
     min_sdk_version: "16",
     target_sdk_version: "33",
-    platform_apis: true,
     manifest: "src/main/AndroidManifest.xml",
     optimize: {
         enabled: false,
diff --git a/testapp/build.gradle b/testapp/build.gradle
index 0800a09f8..1911aad9a 100644
--- a/testapp/build.gradle
+++ b/testapp/build.gradle
@@ -1,11 +1,13 @@
-apply plugin: 'com.android.library'
+plugins {
+    alias(libs.plugins.android.library)
+}
 
 android {
     compileSdk 34
     namespace 'org.robolectric.testapp'
 
     defaultConfig {
-        minSdk 19
+        minSdk 21
         targetSdk 34
         versionCode 1
         versionName "1.0"
diff --git a/testapp/src/main/AndroidManifest.xml b/testapp/src/main/AndroidManifest.xml
index 9ff190737..8ab57ceb8 100644
--- a/testapp/src/main/AndroidManifest.xml
+++ b/testapp/src/main/AndroidManifest.xml
@@ -1,7 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="org.robolectric.testapp">
-
     <application
         android:theme="@style/Theme.Robolectric" android:enabled="true">
       <activity android:name=".TestActivity" android:exported="true">
diff --git a/testapp/src/main/java/org/robolectric/testapp/AbstractTestActivity.java b/testapp/src/main/java/org/robolectric/testapp/AbstractTestActivity.java
new file mode 100644
index 000000000..02ad70562
--- /dev/null
+++ b/testapp/src/main/java/org/robolectric/testapp/AbstractTestActivity.java
@@ -0,0 +1,6 @@
+package org.robolectric.testapp;
+
+import android.app.Activity;
+
+/** Abstract test {@link Activity} for test purpose. */
+public abstract class AbstractTestActivity extends Activity {}
diff --git a/utils/build.gradle b/utils/build.gradle
index 342d22990..a655f9058 100644
--- a/utils/build.gradle
+++ b/utils/build.gradle
@@ -1,18 +1,11 @@
 import org.jetbrains.kotlin.gradle.dsl.JvmTarget
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
-apply plugin: 'kotlin'
-apply plugin: DeployedRoboJavaModulePlugin
-apply plugin: "com.diffplug.spotless"
-apply plugin: "io.gitlab.arturbosch.detekt"
-
-spotless {
-    kotlin {
-        target '**/*.kt'
-        ktfmt('0.42').googleStyle()
-    }
+
+plugins {
+    alias(libs.plugins.detekt)
+    alias(libs.plugins.kotlin.jvm)
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+    alias(libs.plugins.robolectric.spotless)
 }
 
 tasks.withType(GenerateModuleMetadata).configureEach {
diff --git a/utils/reflector/build.gradle b/utils/reflector/build.gradle
index 140e98700..5616aa6c4 100644
--- a/utils/reflector/build.gradle
+++ b/utils/reflector/build.gradle
@@ -1,8 +1,7 @@
-import org.robolectric.gradle.DeployedRoboJavaModulePlugin
-import org.robolectric.gradle.RoboJavaModulePlugin
-
-apply plugin: RoboJavaModulePlugin
-apply plugin: DeployedRoboJavaModulePlugin
+plugins {
+    alias(libs.plugins.robolectric.deployed.java.module)
+    alias(libs.plugins.robolectric.java.module)
+}
 
 dependencies {
     api libs.asm
diff --git a/utils/reflector/src/main/java/org/robolectric/util/reflector/Accessor.java b/utils/reflector/src/main/java/org/robolectric/util/reflector/Accessor.java
index 80c9ec2d4..03ebfa061 100644
--- a/utils/reflector/src/main/java/org/robolectric/util/reflector/Accessor.java
+++ b/utils/reflector/src/main/java/org/robolectric/util/reflector/Accessor.java
@@ -5,9 +5,7 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-/**
- * Indicates that the annotated method is an accessor for a non-visible field.
- */
+/** Indicates that the annotated method is an accessor for a non-visible field. */
 @Target(ElementType.METHOD)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Accessor {
diff --git a/utils/reflector/src/main/java/org/robolectric/util/reflector/ForType.java b/utils/reflector/src/main/java/org/robolectric/util/reflector/ForType.java
index dc75fd260..fd9cd9e36 100644
--- a/utils/reflector/src/main/java/org/robolectric/util/reflector/ForType.java
+++ b/utils/reflector/src/main/java/org/robolectric/util/reflector/ForType.java
@@ -5,9 +5,7 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-/**
- * Indicates that the annotated interface is an accessor object for use by {@link Reflector}.
- */
+/** Indicates that the annotated interface is an accessor object for use by {@link Reflector}. */
 @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface ForType {
diff --git a/utils/reflector/src/main/java/org/robolectric/util/reflector/ReflectorClassWriter.java b/utils/reflector/src/main/java/org/robolectric/util/reflector/ReflectorClassWriter.java
index ea9b45c6d..7f5350664 100644
--- a/utils/reflector/src/main/java/org/robolectric/util/reflector/ReflectorClassWriter.java
+++ b/utils/reflector/src/main/java/org/robolectric/util/reflector/ReflectorClassWriter.java
@@ -544,8 +544,7 @@ class ReflectorClassWriter extends ClassWriter {
       this(org.objectweb.asm.commons.Method.getMethod(method), method);
     }
 
-    private BaseAdapter(
-        org.objectweb.asm.commons.Method asmMethod, Method method) {
+    private BaseAdapter(org.objectweb.asm.commons.Method asmMethod, Method method) {
       this(
           method,
           asmMethod,
diff --git a/utils/reflector/src/main/java/org/robolectric/util/reflector/Static.java b/utils/reflector/src/main/java/org/robolectric/util/reflector/Static.java
index 66f65ceee..11221408d 100644
--- a/utils/reflector/src/main/java/org/robolectric/util/reflector/Static.java
+++ b/utils/reflector/src/main/java/org/robolectric/util/reflector/Static.java
@@ -8,6 +8,4 @@ import java.lang.annotation.Target;
 /** Marks {@link Reflector} methods which serve as accessors for static members. */
 @Target(ElementType.METHOD)
 @Retention(RetentionPolicy.RUNTIME)
-public @interface Static {
-
-}
+public @interface Static {}
diff --git a/utils/reflector/src/main/java/org/robolectric/util/reflector/UnsafeAccess.java b/utils/reflector/src/main/java/org/robolectric/util/reflector/UnsafeAccess.java
index 4f0a39ceb..85c902c57 100644
--- a/utils/reflector/src/main/java/org/robolectric/util/reflector/UnsafeAccess.java
+++ b/utils/reflector/src/main/java/org/robolectric/util/reflector/UnsafeAccess.java
@@ -78,8 +78,7 @@ public class UnsafeAccess {
         privateLookupInMethod =
             MethodHandles.class.getMethod(
                 "privateLookupIn", Class.class, MethodHandles.Lookup.class);
-        defineClassMethod =
-            MethodHandles.Lookup.class.getMethod("defineClass", byte[].class);
+        defineClassMethod = MethodHandles.Lookup.class.getMethod("defineClass", byte[].class);
       } catch (NoSuchMethodException e) {
         throw new AssertionError(e);
       }
diff --git a/utils/reflector/src/test/java/org/robolectric/util/reflector/ReflectorTest.java b/utils/reflector/src/test/java/org/robolectric/util/reflector/ReflectorTest.java
index 74dc88487..f858d88d3 100644
--- a/utils/reflector/src/test/java/org/robolectric/util/reflector/ReflectorTest.java
+++ b/utils/reflector/src/test/java/org/robolectric/util/reflector/ReflectorTest.java
@@ -176,10 +176,12 @@ public class ReflectorTest {
     @Static
     String someStaticMethod(String a, String b);
 
-    @Static @Accessor("eStatic")
+    @Static
+    @Accessor("eStatic")
     void setEStatic(String value);
 
-    @Static @Accessor("eStatic")
+    @Static
+    @Accessor("eStatic")
     String getEStatic();
 
     @Accessor("c")
diff --git a/utils/src/main/java/org/robolectric/AndroidMetadata.java b/utils/src/main/java/org/robolectric/AndroidMetadata.java
index 36566ad88..88f272fbb 100644
--- a/utils/src/main/java/org/robolectric/AndroidMetadata.java
+++ b/utils/src/main/java/org/robolectric/AndroidMetadata.java
@@ -2,24 +2,17 @@ package org.robolectric;
 
 import java.util.Map;
 
-/**
- * Data related to Android tests.
- */
+/** Data related to Android tests. */
 public class AndroidMetadata {
 
   private final Map<String, String> deviceBootProperties;
-  private final String resourcesMode;
 
-  public AndroidMetadata(Map<String, String> deviceBootProperties, String resourcesMode) {
+  public AndroidMetadata(Map<String, String> deviceBootProperties) {
     this.deviceBootProperties = deviceBootProperties;
-    this.resourcesMode = resourcesMode;
   }
 
   public Map<String, String> getDeviceBootProperties() {
     return deviceBootProperties;
   }
 
-  public String getResourcesMode() {
-    return resourcesMode;
-  }
 }
diff --git a/utils/src/main/java/org/robolectric/util/Consumer.java b/utils/src/main/java/org/robolectric/util/Consumer.java
index 4b8a2b34e..971ca2048 100644
--- a/utils/src/main/java/org/robolectric/util/Consumer.java
+++ b/utils/src/main/java/org/robolectric/util/Consumer.java
@@ -3,11 +3,10 @@ package org.robolectric.util;
 import java.util.Objects;
 
 /**
- * Represents an operation that accepts a single input argument and returns no
- * result. Unlike most other functional interfaces, {@code Consumer} is expected
- * to operate via side-effects.
+ * Represents an operation that accepts a single input argument and returns no result. Unlike most
+ * other functional interfaces, {@code Consumer} is expected to operate via side-effects.
  *
- * Included in Robolectric since Android doesn't support streams yet (as of O).
+ * <p>Included in Robolectric since Android doesn't support streams yet (as of O).
  *
  * @param <T> the type of the input to the operation
  */
@@ -23,12 +22,12 @@ public interface Consumer<T> {
   /**
    * Returns a composed {@code Consumer} that performs, in sequence, this operation followed by the
    * {@code after} operation. If performing either operation throws an exception, it is relayed to
-   * the caller of the composed operation.  If performing this operation throws an exception, the
+   * the caller of the composed operation. If performing this operation throws an exception, the
    * {@code after} operation will not be performed.
    *
    * @param after the operation to perform after this operation
    * @return a composed {@code Consumer} that performs in sequence this operation followed by the
-   * {@code after} operation
+   *     {@code after} operation
    * @throws NullPointerException if {@code after} is null
    */
   default Consumer<T> andThen(Consumer<? super T> after) {
diff --git a/utils/src/main/java/org/robolectric/util/Join.java b/utils/src/main/java/org/robolectric/util/Join.java
index a2abb42c7..8556eacb4 100644
--- a/utils/src/main/java/org/robolectric/util/Join.java
+++ b/utils/src/main/java/org/robolectric/util/Join.java
@@ -2,9 +2,7 @@ package org.robolectric.util;
 
 import java.util.Collection;
 
-/**
- * Utility class used to join strings together with a delimiter.
- */
+/** Utility class used to join strings together with a delimiter. */
 public class Join {
   public static String join(String delimiter, Collection collection) {
     String del = "";
diff --git a/utils/src/main/java/org/robolectric/util/NamedStream.java b/utils/src/main/java/org/robolectric/util/NamedStream.java
index 6d7e470aa..c23fffa00 100644
--- a/utils/src/main/java/org/robolectric/util/NamedStream.java
+++ b/utils/src/main/java/org/robolectric/util/NamedStream.java
@@ -1,7 +1,4 @@
 package org.robolectric.util;
 
-/**
- * Marker interface for {@link java.io.InputStream} that need special handling.
- */
-public interface NamedStream {
-}
+/** Marker interface for {@link java.io.InputStream} that need special handling. */
+public interface NamedStream {}
diff --git a/utils/src/main/java/org/robolectric/util/PerfStatsCollector.java b/utils/src/main/java/org/robolectric/util/PerfStatsCollector.java
index 492a7061d..1e45625fe 100644
--- a/utils/src/main/java/org/robolectric/util/PerfStatsCollector.java
+++ b/utils/src/main/java/org/robolectric/util/PerfStatsCollector.java
@@ -34,9 +34,7 @@ public class PerfStatsCollector {
     return INSTANCE;
   }
 
-  /**
-   * If not enabled, don't bother retaining perf stats, saving some memory and CPU cycles.
-   */
+  /** If not enabled, don't bother retaining perf stats, saving some memory and CPU cycles. */
   public void setEnabled(boolean isEnabled) {
     this.enabled = isEnabled;
   }
@@ -70,9 +68,7 @@ public class PerfStatsCollector {
     }
   }
 
-  /**
-   * Supplier that throws an exception.
-   */
+  /** Supplier that throws an exception. */
   // @FunctionalInterface -- not available on Android yet...
   public interface ThrowingSupplier<T, F extends Exception> {
     T get() throws F;
@@ -92,9 +88,7 @@ public class PerfStatsCollector {
     }
   }
 
-  /**
-   * Runnable that throws an exception.
-   */
+  /** Runnable that throws an exception. */
   // @FunctionalInterface -- not available on Android yet...
   public interface ThrowingRunnable<F extends Exception> {
     void run() throws F;
@@ -121,9 +115,7 @@ public class PerfStatsCollector {
     metricMap.clear();
   }
 
-  /**
-   * Event for perf stats collection.
-   */
+  /** Event for perf stats collection. */
   public class Event {
     private final String name;
     private final long startTimeNs;
@@ -153,9 +145,7 @@ public class PerfStatsCollector {
     }
   }
 
-  /**
-   * Metric key for perf stats collection.
-   */
+  /** Metric key for perf stats collection. */
   private static class MetricKey {
     private final String name;
     private final boolean success;
diff --git a/utils/src/main/java/org/robolectric/util/Scheduler.java b/utils/src/main/java/org/robolectric/util/Scheduler.java
index b203884b0..a4b25c76d 100644
--- a/utils/src/main/java/org/robolectric/util/Scheduler.java
+++ b/utils/src/main/java/org/robolectric/util/Scheduler.java
@@ -36,9 +36,7 @@ import java.util.concurrent.TimeUnit;
 @Deprecated
 public class Scheduler {
 
-  /**
-   * Describes the current state of a {@link Scheduler}.
-   */
+  /** Describes the current state of a {@link Scheduler}. */
   public enum IdleState {
     /** The {@link Scheduler} will not automatically advance the clock nor execute any runnables. */
     PAUSED,
@@ -56,6 +54,7 @@ public class Scheduler {
 
   private static final long START_TIME = 100;
   private volatile long currentTime = START_TIME;
+
   /**
    * PriorityQueue doesn't maintain ordering based on insertion; track that ourselves to preserve
    * FIFO order for posted runnables with the same scheduled time.
@@ -104,7 +103,7 @@ public class Scheduler {
   /**
    * Get the current time (as seen by the scheduler), in milliseconds.
    *
-   * @return  Current time in milliseconds.
+   * @return Current time in milliseconds.
    */
   public long getCurrentTime() {
     return currentTime;
@@ -142,7 +141,7 @@ public class Scheduler {
   /**
    * Add a runnable to the queue.
    *
-   * @param runnable    Runnable to add.
+   * @param runnable Runnable to add.
    */
   public synchronized void post(Runnable runnable) {
     postDelayed(runnable, 0, MILLISECONDS);
@@ -151,19 +150,18 @@ public class Scheduler {
   /**
    * Add a runnable to the queue to be run after a delay.
    *
-   * @param runnable    Runnable to add.
+   * @param runnable Runnable to add.
    * @param delayMillis Delay in millis.
    */
   public synchronized void postDelayed(Runnable runnable, long delayMillis) {
     postDelayed(runnable, delayMillis, MILLISECONDS);
   }
 
-  /**
-   * Add a runnable to the queue to be run after a delay.
-   */
+  /** Add a runnable to the queue to be run after a delay. */
   public synchronized void postDelayed(Runnable runnable, long delay, TimeUnit unit) {
     long delayMillis = unit.toMillis(delay);
-    if ((idleState != CONSTANT_IDLE && (isPaused() || delayMillis > 0)) || Thread.currentThread() != associatedThread) {
+    if ((idleState != CONSTANT_IDLE && (isPaused() || delayMillis > 0))
+        || Thread.currentThread() != associatedThread) {
       runnables.add(new ScheduledRunnable(runnable, currentTime + delayMillis));
     } else {
       runOrQueueRunnable(runnable, currentTime + delayMillis);
@@ -173,7 +171,7 @@ public class Scheduler {
   /**
    * Add a runnable to the head of the queue.
    *
-   * @param runnable  Runnable to add.
+   * @param runnable Runnable to add.
    */
   public synchronized void postAtFrontOfQueue(Runnable runnable) {
     if (isPaused() || Thread.currentThread() != associatedThread) {
@@ -192,7 +190,7 @@ public class Scheduler {
   /**
    * Remove a runnable from the queue.
    *
-   * @param runnable  Runnable to remove.
+   * @param runnable Runnable to remove.
    */
   public synchronized void remove(Runnable runnable) {
     Iterator<ScheduledRunnable> iterator = runnables.iterator();
@@ -222,7 +220,7 @@ public class Scheduler {
   /**
    * Run the next runnable in the queue.
    *
-   * @return  True if a runnable was executed.
+   * @return True if a runnable was executed.
    */
   public synchronized boolean advanceToNextPostedRunnable() {
     return !runnables.isEmpty() && advanceTo(runnables.peek().scheduledTime);
@@ -246,7 +244,7 @@ public class Scheduler {
   /**
    * Run all runnables that are scheduled to run in the next time interval.
    *
-   * @return  True if a runnable was executed.
+   * @return True if a runnable was executed.
    */
   public synchronized boolean advanceBy(long amount, TimeUnit unit) {
     long endingTime = currentTime + unit.toMillis(amount);
@@ -256,8 +254,8 @@ public class Scheduler {
   /**
    * Run all runnables that are scheduled before the endTime.
    *
-   * @param   endTime   Future time.
-   * @return  True if a runnable was executed.
+   * @param endTime Future time.
+   * @return True if a runnable was executed.
    */
   public synchronized boolean advanceTo(long endTime) {
     if (endTime < currentTime || runnables.isEmpty()) {
@@ -277,7 +275,7 @@ public class Scheduler {
   /**
    * Run the next runnable in the queue.
    *
-   * @return  True if a runnable was executed.
+   * @return True if a runnable was executed.
    */
   public synchronized boolean runOneTask() {
     ScheduledRunnable postedRunnable = runnables.poll();
@@ -294,15 +292,13 @@ public class Scheduler {
   /**
    * Determine if any enqueued runnables are enqueued before the current time.
    *
-   * @return  True if any runnables can be executed.
+   * @return True if any runnables can be executed.
    */
   public synchronized boolean areAnyRunnable() {
     return nextTaskIsScheduledBefore(currentTime);
   }
 
-  /**
-   * Reset the internal state of the Scheduler.
-   */
+  /** Reset the internal state of the Scheduler. */
   public synchronized void reset() {
     runnables.clear();
     idleState = UNPAUSED;
@@ -313,7 +309,7 @@ public class Scheduler {
   /**
    * Return the number of enqueued runnables.
    *
-   * @return  Number of enqueues runnables.
+   * @return Number of enqueues runnables.
    */
   public synchronized int size() {
     return runnables.size();
@@ -334,7 +330,6 @@ public class Scheduler {
       if (currentMaxTime < scheduled.scheduledTime) {
         currentMaxTime = scheduled.scheduledTime;
       }
-
     }
     return Duration.ofMillis(currentMaxTime);
   }
diff --git a/utils/src/main/java/org/robolectric/util/SimpleFuture.java b/utils/src/main/java/org/robolectric/util/SimpleFuture.java
index 3f7ef4b52..e27bf3692 100644
--- a/utils/src/main/java/org/robolectric/util/SimpleFuture.java
+++ b/utils/src/main/java/org/robolectric/util/SimpleFuture.java
@@ -66,6 +66,5 @@ public class SimpleFuture<T> {
     this.notify();
   }
 
-  protected void done() {
-  }
+  protected void done() {}
 }
diff --git a/utils/src/main/java/org/robolectric/util/SimplePerfStatsReporter.java b/utils/src/main/java/org/robolectric/util/SimplePerfStatsReporter.java
index 80cd13383..68bc24214 100644
--- a/utils/src/main/java/org/robolectric/util/SimplePerfStatsReporter.java
+++ b/utils/src/main/java/org/robolectric/util/SimplePerfStatsReporter.java
@@ -27,16 +27,15 @@ public class SimplePerfStatsReporter implements PerfStatsReporter {
   }
 
   @SuppressWarnings("AndroidJdkLibsChecker)")
-  private synchronized void finalReport() {
+  public synchronized void finalReport() {
     Map<MetricKey, MetricValue> mergedMetrics = new TreeMap<>();
     for (Data perfStatsData : perfStatsData) {
       AndroidMetadata metadata = perfStatsData.metadata.get(AndroidMetadata.class);
       Map<String, String> deviceBootProperties = metadata.getDeviceBootProperties();
       int sdkInt = Integer.parseInt(deviceBootProperties.get("ro.build.version.sdk"));
-      String resourcesMode = metadata.getResourcesMode();
 
       for (Metric metric : perfStatsData.metrics) {
-        MetricKey key = new MetricKey(metric.getName(), metric.isSuccess(), sdkInt, resourcesMode);
+        MetricKey key = new MetricKey(metric.getName(), metric.isSuccess(), sdkInt);
         MetricValue mergedMetric = mergedMetrics.get(key);
         if (mergedMetric == null) {
           mergedMetric = new MetricValue();
@@ -52,17 +51,16 @@ public class SimplePerfStatsReporter implements PerfStatsReporter {
       MetricValue value = entry.getValue();
 
       System.out.println(
-          MessageFormat
-              .format("{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}\t{7}\t{8}",
-                  key.name,
-                  key.sdkLevel,
-                  key.resourcesMode,
-                  key.success,
-                  value.count,
-                  (int) (value.minNs / 1000000),
-                  (int) (value.maxNs / 1000000),
-                  (int) (value.elapsedNs / 1000000 / value.count),
-                  (int) (value.elapsedNs / 1000000)));
+          MessageFormat.format(
+              "{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}\t{7}",
+              key.name,
+              key.sdkLevel,
+              key.success,
+              value.count,
+              (int) (value.minNs / 1000000),
+              (int) (value.maxNs / 1000000),
+              (int) (value.elapsedNs / 1000000 / value.count),
+              (int) (value.elapsedNs / 1000000)));
     }
   }
 
@@ -80,13 +78,11 @@ public class SimplePerfStatsReporter implements PerfStatsReporter {
     private final String name;
     private final boolean success;
     private final int sdkLevel;
-    private final String resourcesMode;
 
-    public MetricKey(String name, boolean success, int sdkLevel, String resourcesMode) {
+    public MetricKey(String name, boolean success, int sdkLevel) {
       this.name = name;
       this.success = success;
       this.sdkLevel = sdkLevel;
-      this.resourcesMode = resourcesMode;
     }
 
     @Override
@@ -109,9 +105,7 @@ public class SimplePerfStatsReporter implements PerfStatsReporter {
       if (sdkLevel != metricKey.sdkLevel) {
         return false;
       }
-      return resourcesMode != null
-          ? resourcesMode.equals(metricKey.resourcesMode)
-          : metricKey.resourcesMode == null;
+      return true;
     }
 
     @Override
@@ -119,7 +113,6 @@ public class SimplePerfStatsReporter implements PerfStatsReporter {
       int result = name != null ? name.hashCode() : 0;
       result = 31 * result + (success ? 1 : 0);
       result = 31 * result + sdkLevel;
-      result = 31 * result + (resourcesMode != null ? resourcesMode.hashCode() : 0);
       return result;
     }
 
@@ -130,11 +123,6 @@ public class SimplePerfStatsReporter implements PerfStatsReporter {
         return i;
       }
 
-      i = resourcesMode.compareTo(o.resourcesMode);
-      if (i != 0) {
-        return i;
-      }
-
       i = Integer.compare(sdkLevel, o.sdkLevel);
       if (i != 0) {
         return i;
diff --git a/utils/src/main/java/org/robolectric/util/SoftThreadLocal.java b/utils/src/main/java/org/robolectric/util/SoftThreadLocal.java
index 56013ea5e..d1b24370f 100644
--- a/utils/src/main/java/org/robolectric/util/SoftThreadLocal.java
+++ b/utils/src/main/java/org/robolectric/util/SoftThreadLocal.java
@@ -13,7 +13,7 @@ public abstract class SoftThreadLocal<T> {
   private final ThreadLocal<SoftReference<T>> threadLocal =
       ThreadLocal.withInitial(() -> new SoftReference<>(create()));
 
-  synchronized public T get() {
+  public synchronized T get() {
     T item = threadLocal.get().get();
     if (item == null) {
       item = create();
@@ -26,5 +26,5 @@ public abstract class SoftThreadLocal<T> {
     threadLocal.set(new SoftReference<>(item));
   }
 
-  abstract protected T create();
+  protected abstract T create();
 }
diff --git a/utils/src/main/java/org/robolectric/util/Strftime.java b/utils/src/main/java/org/robolectric/util/Strftime.java
deleted file mode 100644
index 9689ff401..000000000
--- a/utils/src/main/java/org/robolectric/util/Strftime.java
+++ /dev/null
@@ -1,513 +0,0 @@
-package org.robolectric.util;
-
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-import java.util.TimeZone;
-
-/**
- * An implementation of the Unix strftime with some glibc extensions.
- */
-public class Strftime {
-
-  /**
-   * Format a date string.
-   *
-   * @param format The format in strftime syntax.
-   * @param date The date to format.
-   * @param locale The locale to use for formatting.
-   * @param zone The timezone to use for formatting.
-   * @return The formatted datetime.
-   */
-  @SuppressWarnings("JavaUtilDate")
-  public static String format(String format, final Date date, Locale locale, TimeZone zone) {
-    StringBuilder buffer = new StringBuilder();
-
-    class Formatter {
-      SimpleDateFormat formatter;
-
-      public Formatter(
-          Date date,
-          Locale locale,
-          TimeZone timeZone) {
-        if (locale != null) {
-          formatter = new SimpleDateFormat("", locale);
-        } else {
-          formatter = new SimpleDateFormat("");
-        }
-        if (timeZone != null) {
-          formatter.setTimeZone(timeZone);
-        }
-      }
-
-      public String format(String format) {
-        formatter.applyPattern(format);
-        return formatter.format(date);
-      }
-    }
-
-    Formatter formatter = new Formatter(date, locale, zone);
-
-    Boolean inside = false;
-
-    Boolean removePad = false;
-    Boolean zeroPad = false;
-    Boolean spacePad = false;
-
-    Boolean upperCase = false;
-    Boolean swapCase = false;
-
-    StringBuilder padWidthBuffer = new StringBuilder();
-
-    for (int i = 0; i < format.length(); i++) {
-      Character c = format.charAt(i);
-
-      if (!inside && c == '%') {
-        inside = true;
-        removePad = false;
-        zeroPad = false;
-        spacePad = false;
-        upperCase = false;
-        swapCase = false;
-        padWidthBuffer = new StringBuilder();
-      } else if(inside) {
-        inside = false;
-        switch (c) {
-          // %a  Abbreviated weekday name according to locale.
-          case 'a':
-            buffer.append(
-                correctCase(
-                    formatter.format("EEE"),
-                    upperCase,
-                    swapCase));
-            break;
-
-          // %A  Full weekday name according to locale.
-          case 'A':
-            buffer.append(
-                correctCase(
-                    formatter.format("EEEE"),
-                    upperCase,
-                    swapCase));
-            break;
-
-          // %b  Abbreviated month name according to locale.
-          case 'b':
-            buffer.append(
-                correctCase(
-                    formatter.format("MMM"),
-                    upperCase,
-                    swapCase));
-            break;
-
-          // %B  Full month name according to locale.
-          case 'B':
-            buffer.append(
-                correctCase(
-                    formatter.format("MMMM"),
-                    upperCase,
-                    swapCase));
-            break;
-
-          // %c  Preferred date and time representation for locale.
-          case 'c':
-            // NOTE: en_US locale
-            buffer.append(
-                formatter.format("EEE dd MMM yyyy hh:mm:ss aa z"));
-            break;
-
-          // %C  Year divided by 100 and truncated to integer (00-99).
-          case 'C':
-            buffer.append(
-                formatter.format("y").substring(0, 2));
-            break;
-
-          // %d   Day of the month as decimal number (01-31).
-          case 'd':
-            buffer.append(
-                formatter.format("dd"));
-            break;
-
-          // %D  Same as "%m/%d/%y"
-          case 'D':
-            buffer.append(
-                formatter.format("MM/dd/yy"));
-            break;
-
-          // %e  Day of the month as decimal number, padded with space.
-          case 'e':
-            buffer.append(
-                correctPad(
-                    formatter.format("dd"),
-                    zeroPad,
-                    true,
-                    removePad,
-                    (padWidthBuffer.length() <= 0
-                        ? new StringBuilder("2")
-                        : padWidthBuffer)));
-            break;
-
-          // %E  Modifier, use a locale-dependent alternative representation.
-          case 'E':
-            inside = true;
-            throw new UnsupportedOperationException("Not implemented yet");
-//            break;
-
-          // %F  ISO 8601 date format: "%Y-%m-%d".
-          case 'F':
-            buffer.append(
-                formatter.format("yyyy-MM-dd"));
-            break;
-
-          // %g  2-digit year version of %G, (00-99)
-          case 'g':
-            buffer.append(
-                formatter.format("YY"));
-            break;
-
-          // %G  ISO 8601 week-based year.
-          case 'G':
-            buffer.append(
-                formatter.format("YYYY"));
-            break;
-
-          // %h  Like %b.
-          case 'h':
-            buffer.append(
-                formatter.format("MMM"));
-            break;
-
-          // %H  Hour (24-hour clock) as decimal number (00-23).
-          case 'H':
-            buffer.append(
-                formatter.format("HH"));
-            break;
-
-          // %I  Hour (12-hour clock) as decimal number (01-12).
-          case 'I':
-            buffer.append(
-                formatter.format("hh"));
-            break;
-
-          // %j  Day of the year as decimal number (001-366).
-          case 'j':
-            buffer.append(
-                formatter.format("DDD"));
-            break;
-
-          // %k  Hour (24-hour clock) as decimal number (0-23), space padded.
-          case 'k':
-            buffer.append(
-                correctPad(
-                    formatter.format("HH"),
-                    zeroPad,
-                    spacePad,
-                    removePad,
-                    (padWidthBuffer.length() <= 0
-                        ? new StringBuilder("2")
-                        : padWidthBuffer)));
-            break;
-
-          // %l  Hour (12-hour clock) as decimal number (1-12), space padded.
-          case 'l':
-            buffer.append(
-                correctPad(
-                    formatter.format("hh"),
-                    zeroPad,
-                    spacePad || !zeroPad,
-                    removePad,
-                    (padWidthBuffer.length() <= 0
-                        ? new StringBuilder("2")
-                        : padWidthBuffer)));
-            break;
-
-          // %m  Month as decimal number (01-12).
-          case 'm':
-            buffer.append(
-                correctPad(
-                    formatter.format("MM"),
-                    zeroPad,
-                    spacePad,
-                    removePad,
-                    (padWidthBuffer.length() <= 0
-                        ? new StringBuilder("2")
-                        : padWidthBuffer)));
-            break;
-
-          // %M  Minute as decimal number (00-59).
-          case 'M':
-            buffer.append(
-                correctCase(
-                    formatter.format("mm"),
-                    upperCase,
-                    swapCase));
-            break;
-
-          // %n  Newline.
-          case 'n':
-            buffer.append(
-                formatter.format("\n"));
-            break;
-
-          // %O  Modifier, use alternative numeric symbols (say, Roman numerals).
-          case 'O':
-            inside = true;
-            throw new UnsupportedOperationException("Not implemented yet");
-//            break;
-
-          // %p  "AM", "PM", or locale string. Noon = "PM", midnight = "AM".
-          case 'p':
-            buffer.append(
-                correctCase(
-                    formatter.format("a"),
-                    upperCase,
-                    swapCase));
-            break;
-
-          // %P  "am", "pm", or locale string. Noon = "pm", midnight = "am".
-          case 'P':
-            buffer.append(
-                correctCase(
-                    formatter.format("a").toLowerCase(),
-                    upperCase,
-                    swapCase));
-            break;
-
-          // %r  12-hour clock time.
-          case 'r':
-            buffer.append(
-                formatter.format("hh:mm:ss a"));
-            break;
-
-          // %R  24-hour clock time, "%H:%M".
-          case 'R':
-            buffer.append(
-                formatter.format("HH:mm"));
-            break;
-
-          // %s  Number of seconds since Epoch, 1970-01-01 00:00:00 +0000 (UTC).
-          case 's':
-            buffer.append(
-                ((Long) (date.getTime() / 1000)).toString());
-            break;
-
-          // %S  Second as decimal number (00-60). 60 for leap seconds.
-          case 'S':
-            buffer.append(
-                formatter.format("ss"));
-            break;
-
-          // %t  Tab.
-          case 't':
-            buffer.append(
-                formatter.format("\t"));
-            break;
-
-          // %T  24-hour time, "%H:%M:%S".
-          case 'T':
-            buffer.append(
-                formatter.format("HH:mm:ss"));
-            break;
-
-          // %u  The day of the week as a decimal, (1-7). Monday being 1.
-          case 'u':
-            buffer.append(
-                formatter.format("u"));
-            break;
-
-          // %U  week number of the current year as a decimal number, (00-53).
-          // Starting with the first Sunday as the first day of week 01.
-          case 'U':
-            throw new UnsupportedOperationException("Not implemented yet");
-            // buffer.append(
-            //     formatter.format("ww"));
-            // break;
-
-          // %V  ISO 8601 week number (00-53).
-          // Week 1 is the first week that has at least 4 days in the new year.
-          case 'V':
-            buffer.append(
-                formatter.format("ww"));
-            break;
-
-          // %w  Day of the week as a decimal, (0-6). Sunday being 0.
-          case 'w':
-            String dayNumberOfWeek = formatter.format("u"); // (1-7)
-            buffer.append(
-                (dayNumberOfWeek.equals("7") ? "0" : dayNumberOfWeek));
-            break;
-
-          // %W  Week number of the current year as a decimal number, (00-53).
-          // Starting with the first Monday as the first day of week 01.
-          case 'W':
-            throw new UnsupportedOperationException("Not implemented yet");
-            // buffer.append(
-            //     formatter.format("ww"));
-            // break;
-
-          // %x  Locale date without time.
-          case 'x':
-            buffer.append(
-                formatter.format("MM/dd/yyyy"));
-            break;
-
-          // %X  Locale time without date.
-          case 'X':
-            buffer.append(
-                formatter.format("hh:mm:ss aa"));
-            // buffer.append(
-            //     formatter.format("HH:mm:ss"));
-            break;
-
-          // %y  Year as decimal number without century (00-99).
-          case 'y':
-            buffer.append(
-                formatter.format("yy"));
-            break;
-
-          // %Y  Year as decimal number with century.
-          case 'Y':
-            buffer.append(
-                formatter.format("yyyy"));
-            break;
-
-          // %z  Numeric timezone as hour and minute offset from UTC "+hhmm" or "-hhmm".
-          case 'z':
-            buffer.append(
-                formatter.format("Z"));
-            break;
-
-          // %Z  Timezone, name, or abbreviation.
-          case 'Z':
-            buffer.append(
-                formatter.format("z"));
-            break;
-
-          // %%  Literal '%'.
-          case '%':
-            buffer.append(
-                formatter.format("%"));
-            break;
-
-          // glibc extension
-
-          // %^  Force upper case.
-          case '^':
-            inside = true;
-            upperCase = true;
-            break;
-
-          // %#  Swap case.
-          case '#':
-            inside = true;
-            swapCase = true;
-            break;
-
-          // %-  Remove padding.
-          case '-':
-            inside = true;
-            removePad = true;
-            break;
-
-          // %_  Space pad.
-          case '_':
-            inside = true;
-            spacePad = true;
-            break;
-
-          // %0  Zero pad.
-          //  0  Alternatively if preceded by another digit, defines padding width.
-          case '0':
-            inside = true;
-            if (padWidthBuffer.length() == 0) {
-              zeroPad = true;
-              spacePad = false;
-            } else {
-              padWidthBuffer.append(c);
-            }
-            break;
-
-          // %1  Padding width.
-          case '1':
-          case '2':
-          case '3':
-          case '4':
-          case '5':
-          case '6':
-          case '7':
-          case '8':
-          case '9':
-            inside = true;
-            // zeroPad = !spacePad; // Default to zero padding.
-            padWidthBuffer.append(c);
-            break;
-
-          default:
-            buffer.append(c.toString());
-            break;
-        }
-      } else {
-        buffer.append(c.toString());
-      }
-    }
-
-    return buffer.toString();
-  }
-
-  private static String correctCase(
-      String simple,
-      Boolean upperCase,
-      Boolean swapCase) {
-    if (upperCase) {
-      return simple.toUpperCase();
-    }
-
-    if (!swapCase) {
-      return simple;
-    }
-
-    // swap case
-    StringBuilder buffer = new StringBuilder();
-    for (int i = 0; i < simple.length(); i++) {
-      Character c = simple.charAt(i);
-      buffer.append(
-          (Character.isLowerCase(c)
-              ? Character.toUpperCase(c)
-              : Character.toLowerCase(c))
-          );
-    }
-
-    return buffer.toString();
-  }
-
-  private static String correctPad(
-      String simple,
-      Boolean zeroPad,
-      Boolean spacePad,
-      Boolean removePad,
-      StringBuilder padWidthBuffer) {
-    String unpadded = simple.replaceFirst("^(0+| +)(?!$)", "");
-
-    if (removePad) {
-      return unpadded;
-    }
-
-    int padWidth = 0;
-    if (padWidthBuffer.length() > 0) {
-      padWidth = (
-          Integer.parseInt(padWidthBuffer.toString()) - unpadded.length());
-    }
-
-    if (spacePad || zeroPad) {
-      StringBuilder buffer = new StringBuilder();
-      char padChar = (spacePad ? ' ' : '0');
-      for (int i = 0 ; i < padWidth ; i++) {
-        buffer.append(padChar);
-      }
-      buffer.append(unpadded);
-      return buffer.toString();
-    }
-
-    return simple;
-  }
-}
diff --git a/utils/src/main/java/org/robolectric/util/TestRunnable.java b/utils/src/main/java/org/robolectric/util/TestRunnable.java
index 1d782b06f..965d4c11a 100644
--- a/utils/src/main/java/org/robolectric/util/TestRunnable.java
+++ b/utils/src/main/java/org/robolectric/util/TestRunnable.java
@@ -3,7 +3,8 @@ package org.robolectric.util;
 public class TestRunnable implements Runnable {
   public boolean wasRun = false;
 
-  @Override public void run() {
+  @Override
+  public void run() {
     wasRun = true;
   }
 }
diff --git a/utils/src/main/java/org/robolectric/util/TimeUtils.java b/utils/src/main/java/org/robolectric/util/TimeUtils.java
index ff7b1abdd..ad182bac8 100644
--- a/utils/src/main/java/org/robolectric/util/TimeUtils.java
+++ b/utils/src/main/java/org/robolectric/util/TimeUtils.java
@@ -1,8 +1,6 @@
 package org.robolectric.util;
 
-/**
- * Utility methods for dealing with time.
- */
+/** Utility methods for dealing with time. */
 public class TimeUtils {
   public static final long NANOS_PER_MS = 1000000;
 }
diff --git a/utils/src/main/java/org/robolectric/util/Util.java b/utils/src/main/java/org/robolectric/util/Util.java
index 8f74dc28a..e7bf383bd 100644
--- a/utils/src/main/java/org/robolectric/util/Util.java
+++ b/utils/src/main/java/org/robolectric/util/Util.java
@@ -9,9 +9,7 @@ import java.net.URL;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 
-/**
- * Generic collection of utility methods.
- */
+/** Generic collection of utility methods. */
 public class Util {
 
   /**
@@ -96,7 +94,7 @@ public class Util {
       throw new RuntimeException("huh? " + localArtifactUrl, e);
     }
   }
-  
+
   public static int parseInt(String valueFor) {
     if (valueFor.startsWith("0x")) {
       return Integer.parseInt(valueFor.substring(2), 16);
@@ -108,15 +106,16 @@ public class Util {
   /**
    * Re-throw {@code t} (even if it's a checked exception) without requiring a {@code throws}
    * declaration.
-   * <p>
-   * This function declares a return type of {@link RuntimeException} but will never actually return
-   * a value. This allows you to use it with a {@code throw} statement to convince the compiler that
-   * the current branch will not complete.
+   *
+   * <p>This function declares a return type of {@link RuntimeException} but will never actually
+   * return a value. This allows you to use it with a {@code throw} statement to convince the
+   * compiler that the current branch will not complete.
+   *
    * <pre>{@code
    * throw Util.sneakyThrow(new IOException());
    * }</pre>
-   * <p>
-   * Adapted from https://www.mail-archive.com/javaposse@googlegroups.com/msg05984.html
+   *
+   * <p>Adapted from https://www.mail-archive.com/javaposse@googlegroups.com/msg05984.html
    */
   @SuppressWarnings("unchecked")
   public static <T extends Throwable> RuntimeException sneakyThrow(Throwable t) throws T {
diff --git a/utils/src/main/java/org/robolectric/util/inject/AutoFactory.java b/utils/src/main/java/org/robolectric/util/inject/AutoFactory.java
index ea3df1f27..afaf560b1 100644
--- a/utils/src/main/java/org/robolectric/util/inject/AutoFactory.java
+++ b/utils/src/main/java/org/robolectric/util/inject/AutoFactory.java
@@ -10,7 +10,7 @@ import java.lang.annotation.Target;
  * Indicates that the annotated type will be used as a factory. The type must be an interface or
  * {@link Injector} will throw an exception.
  *
- * {@link Injector} will inject an object implementing the annotated interface. When a method on
+ * <p>{@link Injector} will inject an object implementing the annotated interface. When a method on
  * the interface is called, a scoped injector will be created, any parameters passed to the method
  * will be explicitly bound, and an implementation of the method's return type will be computed and
  * returned.
@@ -18,6 +18,4 @@ import java.lang.annotation.Target;
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.TYPE)
-public @interface AutoFactory {
-
-}
+public @interface AutoFactory {}
diff --git a/utils/src/main/java/org/robolectric/util/inject/InjectionException.java b/utils/src/main/java/org/robolectric/util/inject/InjectionException.java
index 9cca73764..bc25d0b2b 100644
--- a/utils/src/main/java/org/robolectric/util/inject/InjectionException.java
+++ b/utils/src/main/java/org/robolectric/util/inject/InjectionException.java
@@ -12,6 +12,7 @@ public class InjectionException extends RuntimeException {
   public InjectionException(Class<?> clazz, String message) {
     super(clazz.getName() + ": " + message);
   }
+
   public InjectionException(Injector.Key<?> key, String message) {
     super(key + ": " + message);
   }
diff --git a/utils/src/main/java/org/robolectric/util/inject/Injector.java b/utils/src/main/java/org/robolectric/util/inject/Injector.java
index 4f5320bb7..7eee9d798 100644
--- a/utils/src/main/java/org/robolectric/util/inject/Injector.java
+++ b/utils/src/main/java/org/robolectric/util/inject/Injector.java
@@ -102,6 +102,7 @@ public class Injector {
 
   @GuardedBy("this")
   private final Map<Key<?>, Provider<?>> providers;
+
   private final Map<Key<?>, Class<?>> defaultImpls;
 
   /** Creates a new empty injector. */
@@ -111,13 +112,16 @@ public class Injector {
 
   @VisibleForTesting
   Injector(PluginFinder pluginFinder) {
-    this(null, Collections.emptyMap(), Collections.emptyMap(), Collections.emptyMap(),
-        pluginFinder);
+    this(
+        null, Collections.emptyMap(), Collections.emptyMap(), Collections.emptyMap(), pluginFinder);
   }
 
   /** Creates a new injector based on values from a Builder. */
-  private Injector(Injector superInjector, Map<Key<?>, Provider<?>> providers,
-      Map<Key<?>, Class<?>> explicitImpls, Map<Key<?>, Class<?>> defaultImpls,
+  private Injector(
+      Injector superInjector,
+      Map<Key<?>, Provider<?>> providers,
+      Map<Key<?>, Class<?>> explicitImpls,
+      Map<Key<?>, Class<?>> defaultImpls,
       PluginFinder pluginFinder) {
     this.superInjector = superInjector;
 
@@ -198,12 +202,14 @@ public class Injector {
   }
 
   /** Finds an instance for the given class. Calls are guaranteed idempotent. */
-  @Nonnull public <T> T getInstance(@Nonnull Class<T> type) {
+  @Nonnull
+  public <T> T getInstance(@Nonnull Class<T> type) {
     return getInstance(new Key<>(type));
   }
 
   /** Finds an instance for the given key. Calls are guaranteed idempotent. */
-  @Nonnull private <T> T getInstance(@Nonnull Key<T> key) {
+  @Nonnull
+  private <T> T getInstance(@Nonnull Key<T> key) {
     try {
       return getInstanceInternal(key);
     } catch (UnsatisfiedDependencyException e) {
@@ -228,16 +234,19 @@ public class Injector {
     return new Injector.Builder(this, classLoader);
   }
 
-  @Nonnull private <T> Provider<T> memoized(@Nonnull Class<? extends T> implementingClass) {
+  @Nonnull
+  private <T> Provider<T> memoized(@Nonnull Class<? extends T> implementingClass) {
     return memoized(() -> inject(implementingClass));
   }
 
-  @Nonnull private <T> Provider<T> memoized(@Nonnull Provider<T> tProvider) {
+  @Nonnull
+  private <T> Provider<T> memoized(@Nonnull Provider<T> tProvider) {
     return new MemoizingProvider<>(tProvider);
   }
 
   @SuppressWarnings("unchecked")
-  @Nonnull private <T> T inject(@Nonnull Class<? extends T> implementingClass) {
+  @Nonnull
+  private <T> T inject(@Nonnull Class<? extends T> implementingClass) {
     Constructor<T> ctor;
     try {
       ctor = findConstructor(implementingClass);
@@ -314,21 +323,24 @@ public class Injector {
   /**
    * Finds a provider for the given key.
    *
-   * Calls are guaranteed idempotent and non-blocking.
+   * <p>Calls are guaranteed idempotent and non-blocking.
    */
   @SuppressWarnings("unchecked")
   @Nonnull
   private synchronized <T> Provider<T> getProvider(final Key<T> key) {
     // Previously-gotten providers (including those from subinjectors) will already be present.
-    return (Provider<T>) providers.computeIfAbsent(key, k -> {
-      // @AutoFactory requests are always handled by the top-level injector.
-      if (key.isAutoFactory()) {
-        return memoized(new ScopeBuilderProvider<>(key.getDependencyClass()));
-      }
-
-      // Find a provider locally.
-      return findLocalProvider(key);
-    });
+    return (Provider<T>)
+        providers.computeIfAbsent(
+            key,
+            k -> {
+              // @AutoFactory requests are always handled by the top-level injector.
+              if (key.isAutoFactory()) {
+                return memoized(new ScopeBuilderProvider<>(key.getDependencyClass()));
+              }
+
+              // Find a provider locally.
+              return findLocalProvider(key);
+            });
   }
 
   private <T> Provider<T> findLocalProvider(Key<T> key) throws UnsatisfiedDependencyException {
@@ -386,8 +398,7 @@ public class Injector {
   /** Identifies an injection point. */
   public static class Key<T> {
 
-    @Nonnull
-    private final Type theInterface;
+    @Nonnull private final Type theInterface;
     private final String name;
 
     private Key(@Nonnull Type theInterface) {
@@ -426,9 +437,7 @@ public class Injector {
       StringBuilder buf = new StringBuilder();
       buf.append("Key<").append(theInterface);
       if (name != null) {
-        buf.append(" named \"")
-            .append(name)
-            .append("\"");
+        buf.append(" named \"").append(name).append("\"");
       }
       buf.append(">");
       return buf.toString();
@@ -436,13 +445,12 @@ public class Injector {
 
     String toShortString() {
       StringBuilder buf = new StringBuilder();
-      buf.append(theInterface instanceof Class
-          ? ((Class) theInterface).getSimpleName()
-          : theInterface.getTypeName());
+      buf.append(
+          theInterface instanceof Class
+              ? ((Class) theInterface).getSimpleName()
+              : theInterface.getTypeName());
       if (name != null) {
-        buf.append(" \"")
-            .append(name)
-            .append("\"");
+        buf.append(" \"").append(name).append("\"");
       }
       return buf.toString();
     }
@@ -543,8 +551,11 @@ public class Injector {
 
     @Override
     public T get() {
-      return (T) Proxy.newProxyInstance(clazz.getClassLoader(), new Class[]{clazz},
-          (proxy, method, args) -> create(method, args));
+      return (T)
+          Proxy.newProxyInstance(
+              clazz.getClassLoader(),
+              new Class[] {clazz},
+              (proxy, method, args) -> create(method, args));
     }
 
     private Object create(Method method, Object[] args) {
diff --git a/utils/src/main/java/org/robolectric/util/inject/PluginFinder.java b/utils/src/main/java/org/robolectric/util/inject/PluginFinder.java
index ae0429b48..22549e009 100644
--- a/utils/src/main/java/org/robolectric/util/inject/PluginFinder.java
+++ b/utils/src/main/java/org/robolectric/util/inject/PluginFinder.java
@@ -91,8 +91,8 @@ class PluginFinder {
   }
 
   @Nullable
-  private <T> Class<? extends T> best(Class<T> pluginType,
-      List<Class<? extends T>> serviceClasses) {
+  private <T> Class<? extends T> best(
+      Class<T> pluginType, List<Class<? extends T>> serviceClasses) {
     if (serviceClasses.isEmpty()) {
       return null;
     }
@@ -103,9 +103,10 @@ class PluginFinder {
     }
 
     int topPriority = priority(first);
-    serviceClasses = serviceClasses.stream()
-        .filter(it -> priority(it) == topPriority)
-        .collect(Collectors.toList());
+    serviceClasses =
+        serviceClasses.stream()
+            .filter(it -> priority(it) == topPriority)
+            .collect(Collectors.toList());
 
     if (serviceClasses.size() == 1) {
       return serviceClasses.get(0);
diff --git a/utils/src/main/java/org/robolectric/util/inject/Supercedes.java b/utils/src/main/java/org/robolectric/util/inject/Supercedes.java
index 5302ed2f4..d57e58e3f 100644
--- a/utils/src/main/java/org/robolectric/util/inject/Supercedes.java
+++ b/utils/src/main/java/org/robolectric/util/inject/Supercedes.java
@@ -14,5 +14,4 @@ public @interface Supercedes {
 
   /** The type that is superceded by the annotated type. */
   Class<?> value();
-
 }
diff --git a/utils/src/main/java/org/robolectric/util/package-info.java b/utils/src/main/java/org/robolectric/util/package-info.java
index e95b6b1f4..b94f13ff5 100644
--- a/utils/src/main/java/org/robolectric/util/package-info.java
+++ b/utils/src/main/java/org/robolectric/util/package-info.java
@@ -1,4 +1,2 @@
-/**
- * Package containing general utility classes.
- */
-package org.robolectric.util;
\ No newline at end of file
+/** Package containing general utility classes. */
+package org.robolectric.util;
diff --git a/utils/src/test/java/org/robolectric/util/PerfStatsCollectorTest.kt b/utils/src/test/java/org/robolectric/util/PerfStatsCollectorTest.kt
index 1c7e7ab49..bca6e014f 100644
--- a/utils/src/test/java/org/robolectric/util/PerfStatsCollectorTest.kt
+++ b/utils/src/test/java/org/robolectric/util/PerfStatsCollectorTest.kt
@@ -109,6 +109,7 @@ class PerfStatsCollectorTest {
 
   private class FakeClock : Clock {
     private var timeNs = 0
+
     override fun nanoTime(): Long {
       return timeNs.toLong()
     }
diff --git a/utils/src/test/java/org/robolectric/util/SchedulerTest.kt b/utils/src/test/java/org/robolectric/util/SchedulerTest.kt
index cbb0affd8..b514b04ff 100644
--- a/utils/src/test/java/org/robolectric/util/SchedulerTest.kt
+++ b/utils/src/test/java/org/robolectric/util/SchedulerTest.kt
@@ -213,10 +213,10 @@ class SchedulerTest {
             transcript.add("two")
             scheduler.postDelayed(AddToTranscript("three"), 1000)
           },
-          1000
+          1000,
         )
       },
-      1000
+      1000,
     )
     scheduler.advanceBy(1000)
     assertThat(transcript).containsExactly("one")
@@ -279,7 +279,7 @@ class SchedulerTest {
         scheduler.post { order.add(4) }
         order.add(2)
       },
-      0
+      0,
     )
     scheduler.postDelayed({ order.add(3) }, 0)
     scheduler.runOneTask()
@@ -303,7 +303,7 @@ class SchedulerTest {
         scheduler.post { order.add(3) }
         order.add(2)
       },
-      0
+      0,
     )
     assertWithMessage("order").that(order).containsExactly(1, 2, 3)
     assertWithMessage("size").that(scheduler.size()).isEqualTo(0)
@@ -318,7 +318,7 @@ class SchedulerTest {
         scheduler.postAtFrontOfQueue { order.add(3) }
         order.add(2)
       },
-      0
+      0,
     )
     scheduler.postDelayed({ order.add(4) }, 0)
     scheduler.advanceToLastPostedRunnable()
@@ -336,7 +336,7 @@ class SchedulerTest {
         scheduler.postAtFrontOfQueue { order.add(3) }
         order.add(2)
       },
-      0
+      0,
     )
     assertWithMessage("order").that(order).containsExactly(1, 2, 3)
     assertWithMessage("size").that(scheduler.size()).isEqualTo(0)
@@ -352,7 +352,7 @@ class SchedulerTest {
         scheduler.postDelayed({ order.add(3) }, 1)
         order.add(2)
       },
-      0
+      0,
     )
     assertWithMessage("order:before").that(order).containsExactly(1, 2)
     assertWithMessage("size:before").that(scheduler.size()).isEqualTo(1)
@@ -372,7 +372,7 @@ class SchedulerTest {
         scheduler.postDelayed({ order.add(3) }, 1)
         order.add(2)
       },
-      0
+      0,
     )
     assertWithMessage("order").that(order).containsExactly(1, 2, 3)
     assertWithMessage("size").that(scheduler.size()).isEqualTo(0)
@@ -426,7 +426,7 @@ class SchedulerTest {
     scheduler.advanceToLastPostedRunnable()
     assertThat(actualOrder).isEqualTo(ImmutableList.copyOf(Iterables.concat(orderCheck.values)))
     watch.stop()
-    assertThat(watch.elapsed().toMillis()).isLessThan(2000L);
+    assertThat(watch.elapsed().toMillis()).isLessThan(2000L)
   }
 
   @Test(timeout = 1000)
diff --git a/utils/src/test/java/org/robolectric/util/inject/InjectorTest.java b/utils/src/test/java/org/robolectric/util/inject/InjectorTest.java
index 821441a6a..bfa112ca6 100644
--- a/utils/src/test/java/org/robolectric/util/inject/InjectorTest.java
+++ b/utils/src/test/java/org/robolectric/util/inject/InjectorTest.java
@@ -34,8 +34,7 @@ public class InjectorTest {
   public void whenImplSpecified_shouldProvideInstance() throws Exception {
     injector = builder.bind(Thing.class, MyThing.class).build();
 
-    assertThat(injector.getInstance(Thing.class))
-        .isInstanceOf(MyThing.class);
+    assertThat(injector.getInstance(Thing.class)).isInstanceOf(MyThing.class);
   }
 
   @Test
@@ -48,8 +47,7 @@ public class InjectorTest {
 
   @Test
   public void whenServiceSpecified_shouldProvideInstance() throws Exception {
-    assertThat(injector.getInstance(Thing.class))
-        .isInstanceOf(ThingFromServiceConfig.class);
+    assertThat(injector.getInstance(Thing.class)).isInstanceOf(ThingFromServiceConfig.class);
   }
 
   @Test
@@ -60,16 +58,14 @@ public class InjectorTest {
 
   @Test
   public void whenConcreteClassRequested_shouldProvideInstance() throws Exception {
-    assertThat(injector.getInstance(MyUmm.class))
-        .isInstanceOf(MyUmm.class);
+    assertThat(injector.getInstance(MyUmm.class)).isInstanceOf(MyUmm.class);
   }
 
   @Test
   public void whenDefaultSpecified_shouldProvideInstance() throws Exception {
     injector = builder.bindDefault(Umm.class, MyUmm.class).build();
 
-    assertThat(injector.getInstance(Umm.class))
-        .isInstanceOf(MyUmm.class);
+    assertThat(injector.getInstance(Umm.class)).isInstanceOf(MyUmm.class);
   }
 
   @Test
@@ -93,20 +89,15 @@ public class InjectorTest {
       throws Exception {
     builder.bindDefault(Thing.class, MyThing.class);
 
-    assertThat(injector.getInstance(Thing.class))
-        .isInstanceOf(ThingFromServiceConfig.class);
+    assertThat(injector.getInstance(Thing.class)).isInstanceOf(ThingFromServiceConfig.class);
 
     builder.bindDefault(Umm.class, MyUmm.class);
-    assertThat(injector.getInstance(Thing.class))
-        .isInstanceOf(ThingFromServiceConfig.class);
+    assertThat(injector.getInstance(Thing.class)).isInstanceOf(ThingFromServiceConfig.class);
   }
 
   @Test
   public void shouldPreferSingularPublicConstructorAnnotatedInject() throws Exception {
-    injector = builder
-        .bind(Thing.class, MyThing.class)
-        .bind(Umm.class, MyUmm.class)
-        .build();
+    injector = builder.bind(Thing.class, MyThing.class).bind(Umm.class, MyUmm.class).build();
 
     Umm umm = injector.getInstance(Umm.class);
     assertThat(umm).isNotNull();
@@ -121,10 +112,8 @@ public class InjectorTest {
 
   @Test
   public void shouldAcceptSingularPublicConstructorWithoutInjectAnnotation() throws Exception {
-    injector = builder
-        .bind(Thing.class, MyThing.class)
-        .bind(Umm.class, MyUmmNoInject.class)
-        .build();
+    injector =
+        builder.bind(Thing.class, MyThing.class).bind(Umm.class, MyUmmNoInject.class).build();
 
     Umm umm = injector.getInstance(Umm.class);
     assertThat(umm).isNotNull();
@@ -143,7 +132,8 @@ public class InjectorTest {
 
     // X comes first because it has a higher priority
     assertThat(classesOf(multiThings))
-        .containsExactly(MultiThingX.class, MultiThingA.class).inOrder();
+        .containsExactly(MultiThingX.class, MultiThingA.class)
+        .inOrder();
   }
 
   @Test
@@ -152,7 +142,8 @@ public class InjectorTest {
 
     // X comes first because it has a higher priority
     assertThat(classesOf(it.multiThings))
-        .containsExactly(MultiThingX.class, MultiThingA.class).inOrder();
+        .containsExactly(MultiThingX.class, MultiThingA.class)
+        .inOrder();
   }
 
   @Test
@@ -167,7 +158,8 @@ public class InjectorTest {
     }
   }
 
-  @Test public void autoFactory_factoryMethodsCreateNewInstances() throws Exception {
+  @Test
+  public void autoFactory_factoryMethodsCreateNewInstances() throws Exception {
     injector = builder.bind(Umm.class, MyUmm.class).build();
     FooFactory factory = injector.getInstance(FooFactory.class);
     Foo chauncey = factory.create("Chauncey");
@@ -177,14 +169,16 @@ public class InjectorTest {
     assertThat(anotherChauncey).isNotSameInstanceAs(chauncey);
   }
 
-  @Test public void autoFactory_injectedValuesComeFromSuperInjector() throws Exception {
+  @Test
+  public void autoFactory_injectedValuesComeFromSuperInjector() throws Exception {
     injector = builder.bind(Umm.class, MyUmm.class).build();
     FooFactory factory = injector.getInstance(FooFactory.class);
     Foo chauncey = factory.create("Chauncey");
     assertThat(chauncey.thing).isSameInstanceAs(injector.getInstance(Thing.class));
   }
 
-  @Test public void whenFactoryRequested_createsInjectedFactory() throws Exception {
+  @Test
+  public void whenFactoryRequested_createsInjectedFactory() throws Exception {
     injector = builder.bind(Umm.class, MyUmm.class).build();
     FooFactory factory = injector.getInstance(FooFactory.class);
     Foo chauncey = factory.create("Chauncey");
@@ -196,7 +190,8 @@ public class InjectorTest {
     assertThat(chauncey.thing).isSameInstanceAs(injector.getInstance(Thing.class));
   }
 
-  @Test public void scopedInjector_shouldCheckParentBeforeProvidingDefault() throws Exception {
+  @Test
+  public void scopedInjector_shouldCheckParentBeforeProvidingDefault() throws Exception {
     injector = builder.build();
     Injector subInjector = new Injector.Builder(injector).build();
 
@@ -204,17 +199,20 @@ public class InjectorTest {
     assertThat(injector.getInstance(MyUmm.class)).isSameInstanceAs(subUmm);
   }
 
-  @Test public void shouldInjectByNamedKeys() throws Exception {
-    injector = builder
-        .bind(new Injector.Key<>(String.class, "namedThing"), "named value")
-        .bind(String.class, "unnamed value")
-        .build();
+  @Test
+  public void shouldInjectByNamedKeys() throws Exception {
+    injector =
+        builder
+            .bind(new Injector.Key<>(String.class, "namedThing"), "named value")
+            .bind(String.class, "unnamed value")
+            .build();
     NamedParams namedParams = injector.getInstance(NamedParams.class);
     assertThat(namedParams.withName).isEqualTo("named value");
     assertThat(namedParams.withoutName).isEqualTo("unnamed value");
   }
 
-  @Test public void shouldPreferPluginsOverConcreteClass() throws Exception {
+  @Test
+  public void shouldPreferPluginsOverConcreteClass() throws Exception {
     PluginFinder pluginFinder = new PluginFinder(new MyServiceFinderAdapter(pluginClasses));
     Injector injector = new Injector.Builder(null, pluginFinder).build();
     pluginClasses.add(SubclassOfConcreteThing.class);
@@ -232,7 +230,8 @@ public class InjectorTest {
     assertThat(sandbox.compileSdk).isSameInstanceAs(compileSdk);
   }
 
-  @Test @Ignore("todo")
+  @Test
+  @Ignore("todo")
   public void objectsCreatedByFactoryShareTransitiveDependencies() throws Exception {
     FakeSandboxManager sandboxManager = injector.getInstance(FakeSandboxManager.class);
     FakeSdk runtimeSdk = new FakeSdk("runtime");
@@ -257,9 +256,9 @@ public class InjectorTest {
         .contains("Failed to resolve dependency: FakeSandbox/FakeSdk/String");
   }
 
-  @Test @Ignore("todo")
-  public void shouldOnlyAttemptToResolveTypesKnownToClassLoader() throws Exception {
-  }
+  @Test
+  @Ignore("todo")
+  public void shouldOnlyAttemptToResolveTypesKnownToClassLoader() throws Exception {}
 
   /////////////////////////////
 
@@ -272,26 +271,19 @@ public class InjectorTest {
   }
 
   /** A thing. */
-  public interface Thing {
-  }
+  public interface Thing {}
 
-  public static class MyThing implements Thing {
-  }
+  public static class MyThing implements Thing {}
 
-  public static class ConcreteThing {
-  }
+  public static class ConcreteThing {}
 
-  public static class SubclassOfConcreteThing extends ConcreteThing {
-  }
+  public static class SubclassOfConcreteThing extends ConcreteThing {}
 
   /** Class for test. */
   @AutoService(Thing.class)
-  public static class ThingFromServiceConfig implements Thing {
-  }
+  public static class ThingFromServiceConfig implements Thing {}
 
-  private interface Umm {
-
-  }
+  private interface Umm {}
 
   public static class MyUmm implements Umm {
 
@@ -318,20 +310,16 @@ public class InjectorTest {
     }
   }
 
-  private interface MultiThing {
-
-  }
+  private interface MultiThing {}
 
   /** Class for test. */
   @Priority(-5)
   @AutoService(MultiThing.class)
-  public static class MultiThingA implements MultiThing {
-  }
+  public static class MultiThingA implements MultiThing {}
 
   /** Class for test. */
   @AutoService(MultiThing.class)
-  public static class MultiThingX implements MultiThing {
-  }
+  public static class MultiThingX implements MultiThing {}
 
   /** Class for test. */
   public static class ThingRequiringMultiThings {
@@ -425,8 +413,9 @@ public class InjectorTest {
 
   @AutoFactory
   private interface FakeSandboxFactory {
-    FakeSandbox createSandbox(@Named("runtimeSdk") FakeSdk runtimeSdk,
-        @Named("compileSdk") FakeSdk compileSdk);
+    FakeSandbox createSandbox(
+        @Named("runtimeSdk") FakeSdk runtimeSdk, @Named("compileSdk") FakeSdk compileSdk);
+
     FakeSandbox createSandbox();
   }
-}
\ No newline at end of file
+}
diff --git a/utils/src/test/java/org/robolectric/util/inject/PluginFinderTest.kt b/utils/src/test/java/org/robolectric/util/inject/PluginFinderTest.kt
index 91aa6bf62..a1da07d95 100644
--- a/utils/src/test/java/org/robolectric/util/inject/PluginFinderTest.kt
+++ b/utils/src/test/java/org/robolectric/util/inject/PluginFinderTest.kt
@@ -27,7 +27,7 @@ class PluginFinderTest {
         ImplMinus1::class.java,
         ImplZeroA::class.java,
         ImplOne::class.java,
-        ImplZeroB::class.java
+        ImplZeroB::class.java,
       )
     )
     Truth.assertThat(pluginFinder.findPlugin(Iface::class.java)).isEqualTo(ImplOne::class.java)
@@ -55,7 +55,7 @@ class PluginFinderTest {
         ImplMinus1::class.java,
         ImplZeroA::class.java,
         ImplOne::class.java,
-        ImplZeroB::class.java
+        ImplZeroB::class.java,
       )
     )
     Truth.assertThat(pluginFinder.findPlugins(Iface::class.java))
@@ -63,7 +63,7 @@ class PluginFinderTest {
         ImplOne::class.java,
         ImplZeroA::class.java,
         ImplZeroB::class.java,
-        ImplMinus1::class.java
+        ImplMinus1::class.java,
       )
       .inOrder()
   }
@@ -77,7 +77,7 @@ class PluginFinderTest {
         ImplZeroXSupercedesA::class.java,
         ImplZeroA::class.java,
         ImplOne::class.java,
-        ImplZeroB::class.java
+        ImplZeroB::class.java,
       )
     )
     val plugins = pluginFinder.findPlugins(Iface::class.java)
@@ -86,7 +86,7 @@ class PluginFinderTest {
         ImplOne::class.java,
         ImplZeroB::class.java,
         ImplZeroXSupercedesA::class.java,
-        ImplMinus1::class.java
+        ImplMinus1::class.java,
       )
       .inOrder()
   }
@@ -95,10 +95,12 @@ class PluginFinderTest {
   @Priority(-1) private class ImplMinus1 : Iface
 
   @Priority(0) private class ImplZeroA : Iface
+
   private class ImplZeroB : Iface
 
   @Priority(1) private class ImplOne : Iface
 
   @Supercedes(ImplZeroA::class) private class ImplZeroXSupercedesA : Iface
+
   private interface Iface
 }
diff --git a/utils/src/test/java/org/robolectric/util/inject/Thing.java b/utils/src/test/java/org/robolectric/util/inject/Thing.java
index 8dccebac8..03c90d4f5 100644
--- a/utils/src/test/java/org/robolectric/util/inject/Thing.java
+++ b/utils/src/test/java/org/robolectric/util/inject/Thing.java
@@ -1,5 +1,3 @@
 package org.robolectric.util.inject;
 
-interface Thing {
-
-}
+interface Thing {}
```

