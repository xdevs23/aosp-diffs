```diff
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..f3f4abe
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,59 @@
+*.o
+*.lo
+*.a
+*.la
+*.so
+*.so.*
+gif2raw
+gif2rgb
+gifasm
+gifbg
+gifbuild
+gifclrmp
+gifcolor
+gifecho
+giffilter
+giffix
+gifhisto
+gifinto
+gifsponge
+giftext
+giftool
+gifwedge
+doc/gif2raw.1
+doc/gif2raw.html
+doc/gif2rgb.1
+doc/gif2rgb.html
+doc/gif2x11.1
+doc/gif2x11.html
+doc/gif_lib.html
+doc/gifbg.1
+doc/gifbg.html
+doc/gifbuild.1
+doc/gifbuild.html
+doc/gifclrmp.1
+doc/gifclrmp.html
+doc/gifcolor.1
+doc/gifcolor.html
+doc/gifecho.1
+doc/gifecho.html
+doc/giffilter.1
+doc/giffilter.html
+doc/giffix.1
+doc/giffix.html
+doc/gifhisto.1
+doc/gifhisto.html
+doc/gifinto.1
+doc/gifinto.html
+doc/giflib.1
+doc/giflib.html
+doc/gifsponge.1
+doc/gifsponge.html
+doc/giftext.1
+doc/giftext.html
+doc/giftool.1
+doc/giftool.html
+doc/gifwedge.1
+doc/gifwedge.html
+doc/intro.html
+doc/staging/
diff --git a/Android.bp b/Android.bp
index afd0414..5785699 100644
--- a/Android.bp
+++ b/Android.bp
@@ -26,7 +26,6 @@ cc_library_static {
         "gifalloc.c",
         "gif_err.c",
         "gif_hash.c",
-        "openbsd-reallocarray.c",
         "quantize.c",
     ],
 
@@ -35,10 +34,14 @@ cc_library_static {
         "-Wno-format",
         "-Wno-sign-compare",
         "-Wno-unused-parameter",
-        "-DHAVE_CONFIG_H",
+        "-DHAVE_REALLOCARRAY",
     ],
 
     export_include_dirs: ["."],
 
-    vendor_available: true,
+    visibility: [
+        "//frameworks/base/core/jni",
+        "//frameworks/base/libs/hwui",
+        "//packages/apps/Messaging/jni",
+    ],
 }
diff --git a/COPYING b/COPYING
new file mode 100644
index 0000000..b9c0b50
--- /dev/null
+++ b/COPYING
@@ -0,0 +1,19 @@
+The GIFLIB distribution is Copyright (c) 1997  Eric S. Raymond
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/ChangeLog b/ChangeLog
new file mode 100644
index 0000000..b6e0194
--- /dev/null
+++ b/ChangeLog
@@ -0,0 +1,665 @@
+shipper: ignore this.
+	It's retained for archival purposes only.  The single point of
+truth about changes and the reasons for them is the repository.
+
+2007-11-10 14:50  abadger1999
+
+	* NEWS, configure.ac, lib/Makefile.am, lib/egif_lib.c,
+	lib/gif_hash.c: 4.1.6 update.  Errors in including headers could
+	lead to build problems on some platforms.
+
+2007-11-10 13:16  abadger1999
+
+	* configure.ac: Bump release version in configure.ac.
+
+2007-11-10 13:15  abadger1999
+
+	* Makefile.am: Remove PATENT_PROBLEMS from build rules as well.
+
+2007-11-10 13:09  abadger1999
+
+	* NEWS, PATENT_PROBLEMS, lib/Makefile.am: Remove PATENT_PROBLEMS as
+	  it's no longer covered.  Update NEWS and Makefile.am for the new
+	  release.
+
+2007-11-10 10:46  abadger1999
+
+	* configure.ac, util/gif2epsn.c, util/gif2iris.c, util/gif2ps.c,
+	  util/gif2rgb.c, util/gif2rle.c, util/gif2x11.c: Find and fix
+	  segfaults in the gif2* programs due to referencing the ColorMap
+	  beforefinding out if hte GifFile produced a valid colormap or was
+	  corrupt.
+
+2007-11-10 09:30  abadger1999
+
+	* lib/dgif_lib.c: Add checks to fail gracefully when corrupted
+	  images are submitted that have improper LZ codes.
+
+2007-11-10 09:22  abadger1999
+
+	* lib/: dgif_lib.c, egif_lib.c: Further checks to compile correctly
+	  on WIN32.
+
+2007-11-09 20:28  abadger1999
+
+	* util/giftext.c: Fix a SegFault when a GifFile does not store a
+	  global colormap.
+
+2007-11-09 20:13  abadger1999
+
+	* util/gif2x11.c: Fix gif2x11 to work with modern, 24 bit displays.
+
+2007-11-09 14:18  abadger1999
+
+	* configure.ac: Check for headers as well as the libraries for rle,
+	  X11, and gl_s.
+
+2007-11-09 13:24  abadger1999
+
+	* configure.ac: Merge better fix for finding an unsignd 32 bit
+	  integer type.
+
+2007-11-09 13:01  abadger1999
+
+	* configure.ac: Add configure comman line switches to turn off X11,
+	  rle, and gl support.
+
+2007-11-09 12:36  abadger1999
+
+	* configure.ac, util/Makefile.am: Fixes to build under cygwin.
+
+2007-11-09 11:49  abadger1999
+
+	* configure.ac: Make GCC check more robust.  Add a needed automake
+	  check.
+
+2007-11-09 11:48  abadger1999
+
+	* lib/dgif_lib.c: Fix closing file handles on failure in
+	  DGifOpenFileHandle().
+
+2007-11-09 11:33  abadger1999
+
+	* lib/egif_lib.c: Save files in binary mode for WIN32 as well as
+	  MSDOS.
+
+2007-11-09 11:25  abadger1999
+
+	* lib/Makefile.ms: * Makefile for building under Visual C++ from
+	  Bug #981209.
+
+2005-11-13 20:14  abadger1999
+
+	* configure.ac, lib/Makefile.am, util/Makefile.am: Changes to
+	  conditionalize -Wall upon compiling with gcc.
+
+2005-11-06 08:45  abadger1999
+
+	* lib/: gif_hash.c, gif_hash.h: Add inttypes.h to the headers we
+	  could include to get a 32-it int type.
+
+2005-11-06 08:34  abadger1999
+
+	* configure.ac: Search for ISO/ANSI definitions of uint32_t in
+	  stdint.h _and_ inttypes.h before POSIX u_int32_t in sys/types.h
+	  as some systems have sys/types.h without the definition.
+	  Eventually we need to code a test that the expected UINT32
+	  definition exists in the header we select so order does not
+	  matter.
+
+2005-11-06 08:32  abadger1999
+
+	* AUTHORS, README: Modify so that it no longer appears that esr
+	  still maintains this package.
+
+= giflib-4.1.4 =
+
+2005-10-09 Toshio Kuratomi <toshio@tiki-lounge.com> - r94    
+    * Sync with libungif r93.
+    * ChangeLog: Update to r92.
+    * NEWS: Update with combined libungif/giflib changes.
+    
+2005-10-09 Toshio Kuratomi <toshio@tiki-lounge.com> - r92    
+    * lib/gif_lib.h: Change GifPrefixType to unsigned.
+    
+2005-10-09 Toshio Kuratomi <toshio@tiki-lounge.com> - r91    
+    * ChangeLog: Update to r90.
+    * NEWS: Update on GBA and Windows fixes.
+    
+2005-10-06 Toshio Kuratomi <toshio@tiki-lounge.com> - r90    
+    Changes from Lennie Araki:
+    * gba/giftest.mak: Prefix the names of defines for the GBA build with _GBA.
+    * lib/dgif_lib.c, lib/gif_lib_private.h, lib/gif_err.c:
+      - When Compiling for Game Boy Advance, file functions are not needed so
+        exclude DGifOpenFileName(), DGifOpenFileHandle(), DGifSlurp(), and
+        PrintGifError().
+      - On Game Boy Advance we need to reduce memory usage.  Change values to
+        short int where appropriate.
+    * lib/gif_lib.h:
+      - Handle te GBA changes by defining GifPrefixType and GifWord to int
+        unless compiling on GBA.  Then use unsigned short and short
+        respectively.
+      - Fix a problem with the API on _WIN32.  DrawText conflicts with the
+        Windows API.  Call it DrawGifText instead.
+      
+2005-09-27 Toshio Kuratomi <toshio@tiki-lounge.com> - r86    
+    * Sync with libungif r85.
+    
+2005-09-27 Toshio Kuratomi <toshio@tiki-lounge.com> - r82    
+    * AUTHORS: Add Daniel Eisenbud.  Obscure email addresses.
+    * libungif.spec: Bump to version 4.1.4.
+    * configure.ac: Bump to 4.1.4.  No longer check for ranlib.
+    * doc/lzgif.txt: Change dos line encoding to UNIX.
+    * lib/dgif_lib.c: (eisenbud)
+      - Set GifFile's ColorMaps to NULL when we free a colormap object.
+      - Detect some cases of corrupted GIFs which were crashing the library.
+    * lib/egif_lib.c: Set ColorMaps to NULL when we free a colormap object.
+    * lib/gifalloc.c: Set ColorMaps to NULL when we free a colormap object.
+    * lib/dev2gif.c: Fix redefinition problem on IRIX.
+    * NEWS: Update to 4.1.4
+    * util/gifcomb.c: Set a olorMap to NULL.
+    
+2004-07-11 Toshio Kuratomi <toshio@tiki-lounge.com> - r79    
+    * gif2iris.c: Fixes from Georg Schwarz <geos[AT]epost.de>.
+      - stdlib.h is available and needs to be included on IRIX.
+      - ColorMapSize was being set from non-existent variables.
+    
+2004-05-29 Toshio Kuratomi <toshio@tiki-lounge.com> - r76    
+    * Sync with libungif-4.1.3.
+
+2004-05-29 Toshio Kuratomi <toshio@tiki-lounge.com> - r74    
+    * ChangeLog, prop=lastlog: Sync with the subversion logs.
+    
+2004-05-29 Toshio Kuratomi <toshio@tiki-lounge.com> - r73    
+    * test-unx: Add a test of extension code.
+    * lib/egif_lib.c: Remove a debugging statement
+    
+2004-05-29 Toshio Kuratomi <toshio@tiki-lounge.com> - r72    
+    * Makefile.am, doc/Makefile.am, pic/Makefile.am: Change wildcarded entries
+      into explicit filenames so make distcheck will succeed.
+    
+2004-05-29 Toshio Kuratomi <toshio@tiki-lounge.com> - r71    
+    * ChangeLog, prop=lastlog: Sync the ChangeLog for the release.
+    
+2004-05-29 Toshio Kuratomi <toshio@tiki-lounge.com> - r70    
+    * AUTHORS: Add Lennie Araki to the list of contributers.
+    * windows: The windows subdirectory and all files under it are contributions
+      from Lennie Araki to provide a nice interface on MS Windows.
+    * README: Redundancy fix.
+    * doc/gif_lib.html: Add EGifPutExtension{First,Next,Last} to the documentation
+      so people know they should use it instead of EGifPutExtension.
+    * Makefile.am: Mark the windows files to be distributed.
+    * NEWS: Complete the NEWS item for 4.1.3.
+    
+2004-05-29 Toshio Kuratomi <toshio@tiki-lounge.com> - r69    
+    * libungif.spec: Some updates from the latest RedHat spec.
+    * configure.ac: Bump version to 4.1.3.
+    * lib/gifalloc.c: Add to my comments on ESR's note about Extension blocks.
+    * lib/egif_lib.c:
+      - EGifPutComment(): reimplemented using EGifPutExtensionFirst, Next, and
+        Last so that it won't break on unusually long comments.
+      - EGifPutExtension{First,Next,Last}: Changed fwrites to WRITE so any
+        user defined write function will get called properly.
+      - EGifPutExtensionTerminate: if the Extension block is empty (Zero length)
+        then don't attempt to output a last extension block, just output the 
+        block terminator.
+      - EGifPutExtension: Comment that this function does not work when there
+        are multiple subblocks in an Extension block.  Use the functions
+        EGifPutExtension{First,Next,Last} instead.
+      - EGifSpew: Reimplement to use EGifPutExtension{First,Next,Last} so we
+        don't output broken GIFs when there are multiple sub-blocks on an
+        extension.
+    * lib/Makefile.am: Bump version to 4.1.3.
+    * NEWS: Begin writing an entry for 4.1.3.
+    * util/icon2gif.c: Few casting fixes to make gcc -Wall happy.
+    * util/gif2ps.c: printf format string corrections.
+    
+2004-05-26 Toshio Kuratomi <toshio@tiki-lounge.com> - r67    
+    * Clean up some typos.
+    
+2004-05-25 Toshio Kuratomi <toshio@tiki-lounge.com> - r66
+    * Sync with libungif-4.1.2.
+
+2004-03-03 Toshio Kuratomi <toshio@tiki-lounge.com> - r64    
+    Last minute updates to the release notes in various files.
+
+2004-03-03 Toshio Kuratomi <toshio@tiki-lounge.com> - r63    
+    * Set property lastlog to remind me when I last synced the ChangeLog
+
+2004-03-03 Toshio Kuratomi <toshio@tiki-lounge.com> - r62    
+    * ChangeLog: Update
+
+2004-03-03 Toshio Kuratomi <toshio@tiki-lounge.com> - r61    
+    * configure.ac: Bump version to 4.1.2
+    
+2004-02-22 Toshio Kuratomi <toshio@tiki-lounge.com> - r59    
+    * configure.ac, lib/Makefile.am: Bump version.  Forgot to do this for 4.1.1...
+
+2004-02-22 Toshio Kuratomi <toshio@tiki-lounge.com> - r58    
+    * TODO: Take out -Wall as that's all ready now.
+
+2004-02-22 Toshio Kuratomi <toshio@tiki-lounge.com> - r57    
+    Merge changes to the code from branch indent-audit r55
+    * README: MakeExtension deprecation note.
+    * TODO: Bunch of things I need to fix or check that I saw while doing the
+      indentation of the code.
+    * lib/getarg.h: indent changes
+    * lib/dgif_lib.c: indent changes
+      - Move stdlib.h out of #ifdef's as it's included on all platforms.
+      - Add checks to be sure malloc and MakeMapObject succeed.
+    * lib/quantize.c: indent changes
+      - Move stdlib.h out of #ifdef's as it's included on all platforms.
+      - _GifError already pulled in through gif_lib_private.h.  Remove decl.
+      - Make Count in NewColorMapType be unsigned.
+      - Separated mallocs from conditionals in a few places.  Easier reading.
+    * lib/gifalloc.c: indent changes
+      - Added four FIXME's where I think the code might not be doing what we
+        want.  Need to do more research to figure out.
+      - Add note to MakeExtension that I think it needs to be deprecated.
+      - Separated mallocs from conditionals in a few places.  Easier reading.
+      - FreeLastSavedImage: New private function to free the last image in a
+        GifFile structure.  Used to back out when unable to completely
+        allocate a new SavedImage structure.
+      - check for NULL values before deallocating in Free* functions and make
+        sure all Free* functions set the pointer to NULL after they deallocate
+        the memory.
+    * lib/egif_lib.c: indent changes
+      - EGifPutScreenDesc: If we have no colormap, output a default value for
+	its size instead of trying to reference its unallocated BitsPerPixel
+	field. (Fixes bug noted in r46)
+    * lib/gif_lib.h: indent changes
+      - Condense the #else #if VARARGS to #elif VARARGS check.
+    * lib/qprintf.c: indent changes
+      - Condense the #else #if VARARGS to #elif VARARGS check.
+    * lib/dev2gif.c: indent changes
+    * lib/getarg.c: indent changes
+    * lib/gif_lib_private.h: indent changes
+    * lib/gif_font.c: indent changes
+    * lib/gif_err.c: indent changes
+    
+2004-02-22 Toshio Kuratomi <toshio@tiki-lounge.com> - r56    
+    * lib/Makefile.am, util/Makefile.am: Add -Wall to the compilation flags so
+      we can keep the code from acquiring too much bad style.
+    
+2004-02-20 Toshio Kuratomi <toshio@tiki-lounge.com> - r46    
+    * egif_lib.c: Note for a bug fix (Can wait until after indent because
+      there's no patch.)
+    * gif_lib.h, dev2gif.c: Change int type to explicit long type in
+      DumpScreen2Gif.
+    * util/gifinto.c: Give the fprintf back its %d format.
+      GifFile->ImageCount is used as the Image number.
+    
+2004-02-20 Toshio Kuratomi <toshio@tiki-lounge.com> - r45    
+    * README: add varargs to the deprecation list
+
+2004-02-20 Toshio Kuratomi <toshio@tiki-lounge.com> - r44    
+    * test-unx: Quote the program names.
+    * lib/dgif_lib.c:
+      - Make sure memory was allocated for the colormap
+      - Some reformatting of code but no syntactic changes.
+    * lib/gif_lib.h:
+      - C++ extern "C" fix
+      - Fix typo with EGifOpen
+    * lib/qprintf.c, lib/getarg.c: Update the varargs code.  Some users reported
+      that not all systems can handle the hybridized varargs parameter lists
+      we had.  Need to use old-style declarations instead.
+    
+2004-02-20 Toshio Kuratomi <toshio@tiki-lounge.com> - r43    
+    * NEWS: Note bugfixes and deprecations
+    * README: Deprecation list is now being compiled in this file.
+    * TODO: Notes about interlace bug, -Wall status, merging of old bug status
+    
+2004-02-19 Toshio Kuratomi <toshio@tiki-lounge.com> - r42    
+    * Makefile.am: Disable testing for now because gif2x11 is broken so none
+      of the tests _appear_ to complete successfully.
+    
+2004-02-19 Toshio Kuratomi <toshio@tiki-lounge.com> - r38    
+    Merge -Wall fixes from branches/Wall-audit r29
+    * configure.ac:
+      - Make the stdarg vs varargs check simpler by relying on
+        AC_CHECK_HEADERS() magic.
+      - Check for unistd.h
+    * dgif_lib.c, gif_lib.h, egif_lib.c, gifalloc.c, quantize.c, dev2gif.c,
+      getarg.c, gif_lib_private.h, gif_font.c gif_err.c, gifinto.c, icon2gif.c,
+      raw2gif.c, gifcolor.c, gifasm.c, gif2epsn.c, gif2iris.c, gifrotat.c,
+      gifovly.c, gif2x11.c, rle2gif.c, gif2rle.c, text2gif.c, gifspnge.c,
+      gifclrmp.c, giffiltr.c, giftext.c, gifinfo.c, rgb2gif.c, gif2rgb.c, gif2ps.c
+      - Changes to get rid of -Wall compile warnings.
+        + Casting of types
+        + New header includes for unistd.h and fcntl.h
+        + Explicit declaration of many types to unsigned
+        + Removed unused variables and functions
+        + Removed VersionStr from every library file.  Instead include it via
+          gif_lib_private.h
+    * gif_lib.h, gif_lib_private.h: Moved the VersionStr into gif_lib_private.h
+      and made it a #define instead of a static char *.
+    
+2004-02-19 Toshio Kuratomi <toshio@tiki-lounge.com> - r37    
+    Deprecation notes
+
+2004-02-19 Toshio Kuratomi <toshio@tiki-lounge.com> - r36    
+    Add notes about security things to do and giflib syncing
+
+2004-02-18 Toshio Kuratomi <toshio@tiki-lounge.com> - r32  
+  * TODO: Add notes about how to go about syncing Wall-audit and indent changes
+    into giflib.  It won't be pretty.
+  * svn:ignore: Change the tarball names from libungif to giflib
+
+2004-02-18 Toshio Kuratomi <toshio@tiki-lounge.com> - r31  
+  Add config.h include to gif_hash.c
+
+2004-02-17 Toshio Kuratomi <toshio@tiki-lounge.com> - r30  
+  Sync up with libungif 4.1.1
+
+2004-02-17 Toshio Kuratomi <toshio@tiki-lounge.com> - r26    
+    Updated ChangeLog
+
+2004-02-17 Toshio Kuratomi <toshio@tiki-lounge.com>
+	* Updated libungif.spec to look more like fedora core spec
+	* Updated version numbers in all files
+
+2004-02-17 Toshio Kuratomi <toshio@tiki-lounge.com>
+	* Add the libungif*.tar.bz2 distribution tarball to the ignored files
+	* configure.ac, lib/getarg.c, lib/getarg.h, lib/gif_lib.h, lib/qprintf.c:
+	  Prefer stdarg.h over vararg.h
+	* TODO: Add information about functions that will go away in 5.0
+	  (In reality, I don't think new software uses libungif, so there may never
+	  be a 5.0 release.)
+	* lib/gif_lib.h: Change version from 4.0 to 4.1
+	* NEWS: add deprecation warning for the qprintf stuff: GifQuietPrint var and 
+	  GifQprintf function.
+
+2004-02-16 Toshio Kuratomi <toshio@tiki-lounge.com>
+	* util/gif2iris.c, util/gif2rle.c, util/gifinfo.c: Fix problems with fprintf error statements in the utils
+
+2004-02-16 Toshio Kuratomi <toshio@tiki-lounge.com>
+	Add DEVELOPERS file to the distribution.
+
+2004-02-16 Toshio Kuratomi <toshio@tiki-lounge.com>
+	* AUTHORS, libungif.spec, libungif.lsm, README, BUGS, NEWS:
+	  Lots of changes to my email address and the website/download.  (libungif is
+	  moving to sourceforge.)
+	* TODO: Few notes on cleanups that need to happen.  State what needs to be done
+	  for 4.1.1 to be released.
+
+2004-02-15 Toshio Kuratomi <toshio@tiki-lounge.com>
+	Changes imported from last cvs checkout
+	* TODO: note to check return of malloc everywhere
+	* lib/dgif_lib.c, lib/egif_lib.c: Fix some deallocation bugs
+	* lib/gifalloc.c: Fix a colormap allocation problem
+	* lib/gif_font.c: Fix to drawing text
+
+2004-02-15 Toshio Kuratomi <toshio@tiki-lounge.com>
+	Added libgetarg.a to the ignore list.
+
+2004-02-15 Toshio Kuratomi <toshio@tiki-lounge.com>
+	Changes to the build infrastructure to build under current libtool, automake,
+	and libtool.
+	* configure.in: renamed to configure.ac
+	* acconfig.h: deleted.  Functionality moved into the configure.ac
+	* autogen.sh: now runs libtoolize --automake
+	* lib/Makefile.am, util/Makefile.am: CFLAGS=>AM_CFLAGS; INCLUDES=>AM_CPPFLAGS
+	* configure.ac:
+	  - initialization macros for automake and autoconf have changed
+	  - removed checks for C++ compiler and Awk
+	  - acconfig.h functionality moved here.
+	  - add other X11 libraries to the X11_LIB define
+
+2004-02-15 Toshio Kuratomi <toshio@tiki-lounge.com>
+	* Remove INSTALL file as it's autogenerated.\n* Add stamp-h1 to ignored files
+
+2004-02-15 Toshio Kuratomi <toshio@tiki-lounge.com>
+	Additional adds and deletes to make version 4.1.0b1
+
+2004-02-15 Toshio Kuratomi <toshio@tiki-lounge.com>
+	Import of version 4.1.0b1
+
+2004-02-15 Toshio Kuratomi <toshio@tiki-lounge.com> - r10  
+  Import giflib 4.1.0
+
+2004-02-15 Toshio Kuratomi <toshio@tiki-lounge.com> - r9  
+  Copy the 4.1.0 libungif release to be the base of the 4.1.0 giflib release.
+
+2004-02-15 Toshio Kuratomi <toshio@tiki-lounge.com> - r7  
+  Release 4.1.0
+
+2004-02-15 Toshio Kuratomi <toshio@tiki-lounge.com> - r6  
+  Import of version 4.1.0
+
+2004-02-15 Toshio Kuratomi <toshio@tiki-lounge.com> - r5  
+  Set ignore patterns on the project directories.
+
+2004-02-15 Toshio Kuratomi <toshio@tiki-lounge.com> - r3  
+  Remove a Makefile.in that was left in in the first commit.
+
+2004-02-14 Toshio Kuratomi <toshio@tiki-lounge.com> - r2  
+  Commit revision 3.1.0 to subversion
+
+2004-02-14 Toshio Kuratomi <toshio@tiki-lounge.com> - r1  
+  Initial SVN Repository Layout
+
+2000  6 Feb Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+    * configure.in: Change to using config.h
+      - Every .c file: Change to using config.h.
+    * configure.in: added check for varargs header.
+    * lib/getarg.c: Changed the ifdef USE_VARARGS to ifdef HAVE_VARARGS_H.
+      - lib/getarg.h: Ditto.
+      - lib/gif_lib.h: Ditto.
+      - lib/qprintf.h: Ditto.
+
+2000  6 Feb Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+    * lib/getarg.h: Prepend an underscore to the header file define.
+    * lib/gif_lib.h: Ditto
+    * lib/gif_lib_private.h: Ditto
+    * lib/getarg.c: ifdef'd MyMalloc so it actually won't define if it already
+      is.
+
+2000 3  Feb Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+    * A new cvs repository based my private tree from home.  It now goes back
+      to giflib-3.0.
+    * Updated the cvs repository to make multiple developers possible.
+    * Merge all of Michael's patches into the distribution.
+    * DEVELOPER: Updated to reflect the new versions of
+      autoconf/automake/libtool we're using.
+    * libungif.spec: Updated a few things from the latest redhat spec file.
+
+1999 5  Dec Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+        * Update links to the web pages as I have reorganized them somewhat.
+        * Add the welcome2.gif to the pic directory and a test that utilizes
+          it to test-unx.
+
+1999 17 Nov Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+        * New cvs Repository.  Hopefully I've got everything that was in the
+          old one.  This one is available on anonymous cvs.
+        * Update to libtool 1.3.3, automake 1.4, and autoconf 2.13
+
+1999 23 May Michael R Brown <michael@arrakeen.demon.co.uk>
+        * Lots of 'const' qualifiers added, thanks Alexis
+          Wilke for finding these.
+
+1999 22 Mar Michael R Brown <michael@arrakeen.demon.co.uk>
+        * util/gif2x11.c: Patch by (who?) to fix lots of memory leeks.
+        * util/*.c:
+          lib/dgif_lib.c:
+          Makefile.in:
+          Patch by David Kaelbling to compile on IRIX 6.x. Basically fixing
+          lots of bad/missing parameter passing to printf, scanf and similar.
+        * Added pics/welcome2.gif, from Peter Merz which provokes a bug prior
+          to patch 19990224 to do with colour map management.  There is still
+          a problem with util/gifspnge processing this image, so it will not
+          be added to test-unx yet.
+
+1999 05 Mar Michael R Brown <michael@arrakeen.demon.co.uk>
+        * lib/getarg.c: Lines 107 and 189
+          Added ifdef's to use stdarg when available. On dec-alpha the
+          default code was causing programs to crash, probably because
+          it assumes a stack that grows-up.
+
+1999 24 Feb Michael R Brown <michael@arrakeen.demon.co.uk>
+        * lib/dgif_lib.c: Lines 363 and 367
+          Bug reported by Steve Sanders, where &'s where causing the
+          memcpy to overwrite the pointers. Fixed by removing the &'s
+          so that memcpy overwrote the memory pointed to.
+
+1999 09 Feb Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+        * Release 4.1.0
+
+1999 09 Feb Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+        * Merge libungif changes into the giflib tree:
+         - upgrade to libtool 1.2b
+         - util/Makefile.am: Minor change to allow compilation outside the
+           source_dir.
+         - lib/egif_lib.c: FILE_STATE_WRITE, FILE_STATE_SCREEN,
+           FILE_STATE_IMAGE, IS_WRITEABLE are now in gif_lib_private.h
+         - lib/dgif_lib.c: FILE_STATE_READ and IS_READABLE are now in
+           gif_lib_private.h
+         - lib/gif_lib_private.h: Above mentioned constants and macros are now
+           here.  FILE_STATE_READ is now 0x08 instead of 0x00.
+         - configure.in: Update version to 4.1.0
+         - lib/Makefile.am: Update libtool version to 5:0:1 (libtool)
+         - giflib.spec: Update for version 4.1.0 (Add libungif-4.1
+           compatibility stuff and change version.)
+         - giflib.lsm: Update for version 4.1.0
+         - lib/egif_lib.c: (WRITE)  change from a function to a macro.
+         - lib/dgif_lib.c: (DGifOpenFileName) close FileHandle on error.
+         - lib/dgif_lib.c: (DGifOpenFileHandle) make sure the FILE stream is
+           closed if we hit an error.
+         - lib/dev2gif.c, lib/quantize.c, lib/gif_err.c, lib/gif_lib_private.h:
+           Reflect Eric's copyright notice rather than Gershon's
+
+1999 14 Jan  Michael R Brown <michael@arrakeen.demon.co.uk>
+        * lib/gif_lib.h: Add OutputFunc type
+        * lib/gif_lib.h: Add EGifOpen for user supplied output function
+        * lib/egif_lib.c: (EGifOpenFileName) Fixed wasted memory when an
+          error occurs in EGifOpenFileHandle
+        * lib/egif_lib.c: Add EGifOpen, WRITE, and lots of changes to
+          support user supplied output function. Basically changing
+          all fwrite's to WRITE, and then all of the knock on effects.
+
+1998 17 Dec Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+        * configure.in: Change references to libungif to giflib.
+        * libungif.lsm: Rename to giflib.lsm and change to reflect giflib
+          rather than libungif.
+        * libungif.spec: Rename to giflib.spec and change to reflect giflib
+          rather than libungif.
+        * UNCOMPRESSED_GIF: Removed from this branch.
+        * PATENT_PROBLEMS: Add file explaining Unisys's patent claims. 
+        * Makefile.am: Replace libungif with giflib.
+        * README: Adapted language to giflib.
+        * lib/Makefile.am: Changed references to libungif to libgif.
+        * util/Makefile.am: Changed references to libungif to libgif.
+
+1998 17 Dec Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+        * lib/egif_lib.c: Merge LZW stuff into this branch of the library.
+          This includes numerous changes to initialize the hash table as well
+          as the code forthe encoder.
+        * lib/gif_hash.c: Functions needed for the LZW encoder.
+        * lib/gif_hash.h: Functions needed for the LZW encoder.
+        * lib/Makefile.am: Add gif_hash.c gif_hash.h to the list of sources.
+
+1998 15 Dec Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+        * lib/dgif_lib.c: (DGifSlurp) Fix a Seg Fault when an image contains
+          no extension blocks.
+
+1998 14 Dec Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+        * configure.in: Update version to 4.0
+        * lib/Makefile.am: Update libtool version to 4:0:0 (libtool)
+        * libungif.spec: Update for version 4.0 (not binary compatible with
+          giflib, change version.)
+        * lib/gif_lib_private.h: (PrivateType) New header for common stuff
+          private to the library.  Currently, this is only the Private struct.
+        * lib/dgif_lib.c: (PrivateType) Extract the Private struct to
+          gif_lib_private.h
+        * lib/egif_lib.c: (PrivateType) Extract the Private struct to
+          gif_lib_private.h
+        * lib/Makefile.am: Add gif_lib_private.h to the list of source files.
+        * lib/gif_lib.h: (ExtensionBlock) Add a Function entry to the
+          ExtensionBlock record.  Note that this is not entirely correct:
+          the GifLib ExtensionBlock structure is actually a data sub-block
+          record.  By adding the function entry here, we are pushing the
+          ExtensionBlockType in with the DataSubBlock.
+          Sometime in the future, we need to change the API to have true
+          ExtensionBlocks which have DataSubBlocks belonging to them.
+        * lib/gif_lib.h: (ExtensionBlock) Deprecate the use of Function in
+          the SavedImage struct.  Use ExtensionBlock's Function instead.
+        * lib/egif_lib.c: (EGifSpew) Changes to use the new Function variable.
+        * lib/dgif_lib.c: (DGifSlurp) Changes to put data into the new
+          Function variable.
+
+1998 3 Dec  Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+        * lib/dgif_lib.c: (DGifSlurp) Three changes:
+          - No longer allocate SaveImage in this function.  All allocations
+            of SaveImage take place in DGifGetImageDesc.
+          - Extension blocks are now associated with the Image Block that is
+            read in subsequent to them, not before.  This should now be
+            conformant to the gif89a specification.
+          - Fix an off-by-one error when copying extension data from structure
+            to structure.
+        * lib/dgif_lib.c: (DGifGetImageDesc) Change the function to do its own
+          allocation of space for the SavedImage structure no matter what.
+        * lib/egif_lib.c: (EGifSpew) The function now spits out
+          ExtensionBlocks before the associated Image Block to conform with
+          the gif89a specification.
+        * lib/egif_lib.c: (EGifOpenFileHandle) Move the write of the
+          GifVersion (gif87a or gif89a) from this function into
+          EGifPutScreenDesc so that it can be controlled by EGifSpew.  Note
+          that this is still a hack as the GifVersion write doesn't really
+          belong in either of these functions.
+        * lib/egif_lib.c: (EGifPutScreenDesc) Moved writing the version
+          (gif87a or gif89a) into the file into this function from
+          EGifOpenFileHandle.
+        * test-unx: Now test the extension code.
+        * pic/x-trans.gif: New image with Comments and transparency to test
+          the extension code with.
+
+1998 29 Nov Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+        * lib/dgif_lib.c: (DGifSlurp) Fix a few of the minor bugs plaguing
+          this function.  At this point, the function should no longer cause
+          a Seg Fault.  It is now losing all extension data however.  I know
+          how to hack a fix in, but I need to commit these changes first.
+        * lib/dgif_lib.c: (DGifGetImageDesc) Fix my bug fix: the colormap is
+          now only copied if it exists :-).
+
+1998 10 Nov Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+        * test-unx: Add a test for DGifSlurp and EGifSpew
+
+1998 14 Oct Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+        * lib/dgif_lib.c: (DGifGetImageDesc) Fix a bug where the Colormap for
+          the image description and the SaveImage were pointers to the same
+          structure, causing a SegV when DGifClosing the file.
+
+1998 9 Oct  Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+        * lib/dgif_lib.c: (DGifSlurp) memory for the extensions was not being
+          allocated.  Now I call AddExtensionBlock when I add an extension to
+          the structure.  Additionally, fix a memory leak here.
+        * configure.in, NEWS, lib/Makefile.am: Update to version 3.1.1
+        * ltmain.sh, ltconfig: removed from the cvs repository
+        * BUGS: add the BUGS file to list unresolved BUGS.
+
+1998 9 Sep  Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+        * libungif.spec: Fix wrong version in %files and %install section.
+
+1998 8 Sep  Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+        * lib/gif_hash.c, lib/gif_hash.h: Removed these because a hash table
+          is not needed to create uncompressed gifs.
+        * lib/egif_lib.c: Remove all references to the hash functions.
+        * lib/Makefile.am: Remove gif_hash.c gif_hash.h from the source files.
+        * libungif.lsm: added this file
+ 
+1998 7 Sep  Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+        * lib/dgif_lib.c, lib/gif_lib.h: (DGifOpen) Add callback to read gif
+          image through user supplied function (Peter Mehlitz).
+
+1998 6 Sep  Toshio Kuratomi <badger@prtr-13.ucsc.edu>
+        * util/*.{gif.rle}: removed files that were left by my testing
+          process and shouldn't have been in the distribution.
+        * UNCOMPRESSED_GIF: add section on why software that can decode
+          LZW compressed gifs (but not write them) is legal.
+        * .cvsignore: added .cvsignore files to ignore Makefiles and other
+          generated files in my cvs repository.
+        * Makefile.am's: Fixes to allow the dist* family of targets to work
+          correctly.  Preliminary support for make check as well.
+        * configure.in: Update version to 3.1.0
+        * lib/Makefile.am: Update libtool version to 4:0:1 libtool)
+        * libungif-3.0.spec: Update from Marc Ewing.
+        * Add int/pointer Alpha fixes from Dick Porter to many source files.
diff --git a/METADATA b/METADATA
index d8ffbe9..a255562 100644
--- a/METADATA
+++ b/METADATA
@@ -1,6 +1,22 @@
+# This project was upgraded with external_updater.
+# Usage: tools/external_updater/updater.sh update external/giflib
+# For more info, check https://cs.android.com/android/platform/superproject/main/+/main:tools/external_updater/README.md
+
+name: "giflib"
+description: "A library and utilities for processing GIFs"
 third_party {
   license_type: NOTICE
   security {
     tag: "NVD-CPE2.3:cpe:/a:giflib_project:giflib:5.1.1"
   }
+  last_upgrade_date {
+    year: 2024
+    month: 8
+    day: 26
+  }
+  identifier {
+    type: "Git"
+    value: "https://git.code.sf.net/p/giflib/code"
+    version: "5.2.2"
+  }
 }
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..87966a9
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,219 @@
+# Top-level Unix makefile for the GIFLIB package
+# Should work for all Unix versions
+#
+# If your platform has the OpenBSD reallocarray(3) call, you may
+# add -DHAVE_REALLOCARRAY to CFLAGS to use that, saving a bit
+# of code space in the shared library.
+
+#
+OFLAGS = -O0 -g
+OFLAGS  = -O2
+CFLAGS  = -std=gnu99 -fPIC -Wall -Wno-format-truncation $(OFLAGS)
+
+SHELL = /bin/sh
+TAR = tar
+INSTALL = install
+
+PREFIX = /usr/local
+BINDIR = $(PREFIX)/bin
+INCDIR = $(PREFIX)/include
+LIBDIR = $(PREFIX)/lib
+MANDIR = $(PREFIX)/share/man
+
+# No user-serviceable parts below this line
+
+VERSION:=$(shell ./getversion)
+LIBMAJOR=7
+LIBMINOR=2
+LIBPOINT=0
+LIBVER=$(LIBMAJOR).$(LIBMINOR).$(LIBPOINT)
+
+SOURCES = dgif_lib.c egif_lib.c gifalloc.c gif_err.c gif_font.c \
+	gif_hash.c openbsd-reallocarray.c
+HEADERS = gif_hash.h  gif_lib.h  gif_lib_private.h
+OBJECTS = $(SOURCES:.c=.o)
+
+USOURCES = qprintf.c quantize.c getarg.c 
+UHEADERS = getarg.h
+UOBJECTS = $(USOURCES:.c=.o)
+
+UNAME:=$(shell uname)
+
+# Some utilities are installed
+INSTALLABLE = \
+	gif2rgb \
+	gifbuild \
+	giffix \
+	giftext \
+	giftool \
+	gifclrmp
+
+# Some utilities are only used internally for testing.
+# There is a parallel list in doc/Makefile.
+# These are all candidates for removal in future releases.
+UTILS = $(INSTALLABLE) \
+	gifbg \
+	gifcolor \
+	gifecho \
+	giffilter \
+	gifhisto \
+	gifinto \
+	gifsponge \
+	gifwedge
+
+LDLIBS=libgif.a -lm
+
+MANUAL_PAGES = \
+	doc/gif2rgb.xml \
+	doc/gifbuild.xml \
+	doc/gifclrmp.xml \
+	doc/giffix.xml \
+	doc/giflib.xml \
+	doc/giftext.xml \
+	doc/giftool.xml
+
+SOEXTENSION	= so
+LIBGIFSO	= libgif.$(SOEXTENSION)
+LIBGIFSOMAJOR	= libgif.$(SOEXTENSION).$(LIBMAJOR)
+LIBGIFSOVER	= libgif.$(SOEXTENSION).$(LIBVER)
+LIBUTILSO	= libutil.$(SOEXTENSION)
+LIBUTILSOMAJOR	= libutil.$(SOEXTENSION).$(LIBMAJOR)
+ifeq ($(UNAME), Darwin)
+SOEXTENSION	= dylib
+LIBGIFSO        = libgif.$(SOEXTENSION)
+LIBGIFSOMAJOR   = libgif.$(LIBMAJOR).$(SOEXTENSION)
+LIBGIFSOVER	= libgif.$(LIBVER).$(SOEXTENSION)
+LIBUTILSO	= libutil.$(SOEXTENSION)
+LIBUTILSOMAJOR	= libutil.$(LIBMAJOR).$(SOEXTENSION)
+endif
+
+all: $(LIBGIFSO) libgif.a $(LIBUTILSO) libutil.a $(UTILS)
+ifeq ($(UNAME), Darwin)
+else
+	$(MAKE) -C doc
+endif
+
+$(UTILS):: libgif.a libutil.a
+
+$(LIBGIFSO): $(OBJECTS) $(HEADERS)
+ifeq ($(UNAME), Darwin)
+	$(CC) $(CFLAGS) -dynamiclib -current_version $(LIBVER) $(OBJECTS) -o $(LIBGIFSO)
+else
+	$(CC) $(CFLAGS) -shared $(LDFLAGS) -Wl,-soname -Wl,$(LIBGIFSOMAJOR) -o $(LIBGIFSO) $(OBJECTS)
+endif
+
+libgif.a: $(OBJECTS) $(HEADERS)
+	$(AR) rcs libgif.a $(OBJECTS)
+
+$(LIBUTILSO): $(UOBJECTS) $(UHEADERS)
+ifeq ($(UNAME), Darwin)
+	$(CC) $(CFLAGS) -dynamiclib -current_version $(LIBVER) $(OBJECTS) -o $(LIBUTILSO)
+else
+	$(CC) $(CFLAGS) -shared $(LDFLAGS) -Wl,-soname -Wl,$(LIBUTILMAJOR) -o $(LIBUTILSO) $(UOBJECTS)
+endif
+
+libutil.a: $(UOBJECTS) $(UHEADERS)
+	$(AR) rcs libutil.a $(UOBJECTS)
+
+clean:
+	rm -f $(UTILS) $(TARGET) libgetarg.a libgif.a $(LIBGIFSO) libutil.a $(LIBUTILSO) *.o
+	rm -f $(LIBGIFSOVER)
+	rm -f $(LIBGIFSOMAJOR)
+	rm -fr doc/*.1 *.html doc/staging
+
+check: all
+	$(MAKE) -C tests
+
+reflow:
+	@clang-format --style="{IndentWidth: 8, UseTab: ForIndentation}" -i $$(find . -name "*.[ch]")
+
+# Installation/uninstallation
+
+ifeq ($(UNAME), Darwin)
+install: all install-bin install-include install-lib
+else
+install: all install-bin install-include install-lib install-man
+endif
+
+install-bin: $(INSTALLABLE)
+	$(INSTALL) -d "$(DESTDIR)$(BINDIR)"
+	$(INSTALL) $^ "$(DESTDIR)$(BINDIR)"
+install-include:
+	$(INSTALL) -d "$(DESTDIR)$(INCDIR)"
+	$(INSTALL) -m 644 gif_lib.h "$(DESTDIR)$(INCDIR)"
+install-lib:
+	$(INSTALL) -d "$(DESTDIR)$(LIBDIR)"
+	$(INSTALL) -m 644 libgif.a "$(DESTDIR)$(LIBDIR)/libgif.a"
+	$(INSTALL) -m 755 $(LIBGIFSO) "$(DESTDIR)$(LIBDIR)/$(LIBGIFSOVER)"
+	ln -sf $(LIBGIFSOVER) "$(DESTDIR)$(LIBDIR)/$(LIBGIFSOMAJOR)"
+	ln -sf $(LIBGIFSOMAJOR) "$(DESTDIR)$(LIBDIR)/$(LIBGIFSO)"
+install-man:
+	$(INSTALL) -d "$(DESTDIR)$(MANDIR)/man1"
+	$(INSTALL) -m 644 $(MANUAL_PAGES) "$(DESTDIR)$(MANDIR)/man1"
+uninstall: uninstall-man uninstall-include uninstall-lib uninstall-bin
+uninstall-bin:
+	cd "$(DESTDIR)$(BINDIR)" && rm -f $(INSTALLABLE)
+uninstall-include:
+	rm -f "$(DESTDIR)$(INCDIR)/gif_lib.h"
+uninstall-lib:
+	cd "$(DESTDIR)$(LIBDIR)" && \
+		rm -f libgif.a $(LIBGIFSO) $(LIBGIFSOMAJOR) $(LIBGIFSOVER)
+uninstall-man:
+	cd "$(DESTDIR)$(MANDIR)/man1" && rm -f $(shell cd doc >/dev/null && echo *.1)
+	cd "$(DESTDIR)$(MANDIR)/man7" && rm -f $(shell cd doc >/dev/null && echo *.7)
+
+# Make distribution tarball
+#
+# We include all of the XML, and also generated manual pages
+# so people working from the distribution tarball won't need xmlto.
+
+EXTRAS =     README \
+	     NEWS \
+	     TODO \
+	     COPYING \
+	     getversion \
+	     ChangeLog \
+	     build.adoc \
+	     history.adoc \
+	     control \
+	     doc/whatsinagif \
+	     doc/gifstandard \
+
+DSOURCES = Makefile *.[ch]
+DOCS = doc/*.xml doc/*.1 doc/*.7 doc/*.html doc/index.html.in doc/00README doc/Makefile
+ALL =  $(DSOURCES) $(DOCS) tests pic $(EXTRAS)
+giflib-$(VERSION).tar.gz: $(ALL)
+	$(TAR) --transform='s:^:giflib-$(VERSION)/:' -czf giflib-$(VERSION).tar.gz $(ALL)
+giflib-$(VERSION).tar.bz2: $(ALL)
+	$(TAR) --transform='s:^:giflib-$(VERSION)/:' -cjf giflib-$(VERSION).tar.bz2 $(ALL)
+
+dist: giflib-$(VERSION).tar.gz giflib-$(VERSION).tar.bz2
+
+# Auditing tools.
+
+# Check that getversion hasn't gone pear-shaped.
+version:
+	@echo $(VERSION)
+
+# cppcheck should run clean
+cppcheck:
+	cppcheck --quiet --inline-suppr --template gcc --enable=all --suppress=unusedFunction --suppress=missingInclude --force *.[ch]
+
+# Verify the build
+distcheck: all
+	$(MAKE) giflib-$(VERSION).tar.gz
+	tar xzvf giflib-$(VERSION).tar.gz
+	$(MAKE) -C giflib-$(VERSION)
+	rm -fr giflib-$(VERSION)
+
+# release using the shipper tool
+release: all distcheck
+	$(MAKE) -C doc website
+	shipper --no-stale version=$(VERSION) | sh -e -x
+	rm -fr doc/staging
+
+# Refresh the website
+refresh: all
+	$(MAKE) -C doc website
+	shipper --no-stale -w version=$(VERSION) | sh -e -x
+	rm -fr doc/staging
diff --git a/NEWS b/NEWS
new file mode 100644
index 0000000..a3db903
--- /dev/null
+++ b/NEWS
@@ -0,0 +1,844 @@
+			GIFLIB NEWS
+
+Repository head
+===============
+
+This is a point release intended to clear up a couple of CVEs and
+apply point fixes that have been accumulating since 5.2.1 There are a
+few unresolved (but minor) memory leaks related to design issues in
+the API that still need to be resolved.
+
+Code Fixes
+----------
+
+* Fixes for CVE-2023-48161, CVE-2022-28506, 
+
+* Address SF issue #138 Documentation for obsolete utilities still installed
+
+* Address SF issue #139: Typo in "LZW image data" page ("110_2 = 4_10")
+
+* Address SF issue #140: Typo in "LZW image data" page ("LWZ")
+
+* Address SF issue #141: Typo in "Bits and bytes" page ("filed")
+
+* Note as already fixed SF issue #143: cannot compile under mingw
+
+* Address SF issue #144: giflib-5.2.1 cannot be build on windows and other platforms using c89
+
+* Address SF issue #145: Remove manual pages installation for binaries that are not installed too
+
+* Address SF issue #146: [PATCH] Limit installed man pages to binaries, move giflib to section 7
+
+* Address SF issue #147 [PATCH] Fixes to doc/whatsinagif/ content
+
+* Address SF issue #148: heap Out of Bound Read in gif2rgb.c:298 DumpScreen2RGB
+
+* Declared no-info on SF issue #150: There is a denial of service vulnerability in GIFLIB 5.2.1
+
+* Declared Won't-fix on SF issue 149: Out of source builds no longer possible
+
+* Address SF issue #151: A heap-buffer-overflow in gif2rgb.c:294:45
+
+* Address SF issue #152: Fix some typos on the html documentation and man pages
+
+* Address SF issue #153: Fix segmentation faults due to non correct checking for args
+
+* Address SF issue #154: Recover the giffilter manual page
+
+* Address SF issue #155: Add gifsponge docs
+
+* Address SF issue #157: An OutofMemory-Exception or Memory Leak in gif2rgb
+
+* Address SF issue #158: There is a null pointer problem in gif2rgb
+
+* Address SF issue #159 A heap-buffer-overflow in GIFLIB5.2.1 DumpScreen2RGB() in gif2rgb.c:298:45
+
+* Address SF issue #163: detected memory leaks in openbsd_reallocarray giflib/openbsd-reallocarray.c
+
+* Address SF issue #164: detected memory leaks in GifMakeMapObject giflib/gifalloc.c
+
+* Address SF issue #166: a read zero page leads segment fault in getarg.c and memory leaks in gif2rgb.c and gifmalloc.c
+
+* Address SF issue #167: Heap-Buffer Overflow during Image Saving in DumpScreen2RGB Function at Line 321 of gif2rgb.c
+
+Version 5.2.1
+==============
+
+This is the "Maybe I shouldn't have done a release while in surgical recovery" release.
+
+* In gifbuild.c, avoid a core dump on no color map.
+
+* Restore inadvertently removed library version numbers in Makefile.
+
+Version 5.2.0
+=============
+
+The undocumented and deprecated GifQuantizeBuffer() entry point
+has been moved to the util library to reduce libgif size and attack
+surface. Applications needing this function are couraged to link the
+util library or make their own copy.
+
+The following obsolete utility programs are no longer installed:
+gifecho, giffilter, gifinto, gifsponge. These were either installed in
+error or have been obsolesced by modern image-transformation tools
+like ImageMagick convert. They may be removed entirely in a future
+release.
+
+* Address SourceForge issue #136: Stack-buffer-overflow in gifcolor.c:84
+
+* Address SF bug #134: Giflib fails to slurp significant number of gifs
+
+* Apply SPDX convention for license tagging.
+
+Version 5.1.9
+=============
+
+The documentation directory now includes an HTMlified version of the
+GIF89 standard, and a more detailed description of how LZW compression
+is applied to GIFs.
+
+* Address SF bug #129: The latest version of giflib cannot be build on windows.
+
+* Address SF bug #126: Cannot compile giflib using c89
+
+Version 5.1.8
+=============
+
+* Address SF bug #119: MemorySanitizer: FPE on unknown address. This is CVE-2019-15133
+
+* Address SF bug #125: 5.1.7: xmlto is still required for tarball
+
+* Address SF bug #124: 5.1.7: ar invocation is not crosscompile compatible
+
+* Address SF bug #122: 5.1.7 installs manpages to wrong directory
+
+* Address SF bug #121: make: getversion: Command not found
+
+* Address SF bug #120: 5.1.7 does not build a proper library - no 
+
+Version 5.1.7
+=============
+
+Correct a minor packaging error (superfluous symlinks) in the 5.1.6 tarballs.
+
+Version 5.1.6
+=============
+
+Build Fixes
+-----------
+
+Fix library installation in the Makefile.
+
+Version 5.1.5
+=============
+
+Code Fixes
+----------
+
+* Fix SF bug #114: Null dereferences in main() of gifclrmp
+
+* Fix SF bug #113: Heap Buffer Overflow-2 in function DGifDecompressLine()
+  in cgif.c.  This had been assigned CVE-2018-11490.
+
+* Fix SF bug #111: segmentation fault in PrintCodeBlock
+
+* Fix SF bug #109: Segmentation fault of giftool reading a crafted file
+
+* Fix SF bug #107: Floating point exception in giftext utility
+
+* Fix SF bug #105: heap buffer overflow in DumpScreen2RGB in gif2rgb.c:317
+
+* Fix SF bug #104: Ineffective bounds check in DGifSlurp
+
+^ Fix SF bug #103: GIFLIB 5.1.4: DGifSlurp fails on empty comment
+
+* Fix SF bug #87: Heap buffer overflow in 5.1.2 (gif2rgb).
+
+Build Fixes
+-----------
+
+The horrible old autoconf build system has been removed with extreme prejudice. 
+You now build this simply by running "make" from the top-level directory.
+
+Version 5.1.4
+=============
+
+Code Fixes
+----------
+
+* Fix SF bug #94: giflib 5 loves to fail to load images... a LOT.
+
+* Fix SF Bug #92: Fix buffer overread in gifbuild.
+
+* Fix SF Bug #93: Add bounds check in gifbuild netscape2.0 path
+
+* Fix SF Bug #89: Fix buffer overread in gifbuild.
+
+Version 5.1.3
+=============
+
+As of this version the library and code has been seriously abused by fuzzers,
+smoking out crash bugs (now fixed) induced by various kinds of severely
+malformed GIF.
+
+Code Fixes
+----------
+
+* Prevent malloc randomess from causing the header output routine to emit
+  a GIF89 version string even when no GIF89 features are present. Only
+  breaks tests, not production code, but it's odd this wasn't caught sooner.
+
+* Prevent malloc randomess from producing sporadic failures by causing
+  sanity checks added in 5.1.2 to misfire.
+
+* Bulletproof gif2rgb against 0-height images. Addressed SF bug #78:
+  Heap overflow in gif2rgb with images of size 0, also SF bug #82.
+
+* Remove unnecessary duplicate EGifClose() in gifcolor.c. Fixes SF bug #83
+  introduced in 5.1.2.
+
+* Fix SF Bug #84: incorrect return of DGifSlurp().
+
+Version 5.1.2
+=============
+
+Code Fixes
+----------
+
+* Code hardening using reallocarray() from OpenBSD.
+
+* Sanity check in giffilter catches files with malformed extension records
+  Fixes SourceForge bug #63: malformed gif causes segfault in giffilter.
+
+* Inexpensive sanity check in DGifSlurp() catches malformed files with
+  no image descriptor. Fixes SourceForge bug #64: malformed gif causes
+  crash in giftool.
+
+* Fix SourceForge bug #66: GifDrawBoxedText8x8() modifying constant input
+  parameter.
+
+* Bail out of GIF read on invalid pixel width. Addresses Savannah bug
+  #67: invalid shift in dgif_lib.c
+
+* Fix SourceForge bug #69: #69 Malformed: Gif file with no extension
+  block after a GRAPHICS_EXT_FUNC_CODE extension causes segfault (in
+  giftext).
+
+* Fix SourceForge bug #71: Buffer overwrite when giffixing a malformed gif.
+
+* Fix SourceForge bug #73: Null pointer deference in gifclrmap (only
+  reachable with malformed GIF).
+
+* Fix SourceForge bug #74: Double free in gifsponge under 5.1.1,
+  for any valid gif image.
+
+* Fix SourceForge bug #75: GAGetArgs overflows due to uncounted use of va_arg.
+
+* Sanity check in giffix catches some malformed files. Addresses
+  SourceForge bug #77: dgif_lib.c: extension processing error
+
+
+Version 5.1.1
+=============
+
+Code Fixes
+----------
+
+* Numerous minor fixes in getarg.c. Affects only the utilities, not the
+  core library.
+
+* Fix SourceForge bug #59: DGifOpen can segfault if DGifGetScreenDesc fails.
+
+* SourceForge patch #20: In gifalloc, fix usage of realloc() in case of failure.
+
+* Fix SourceForge bug #61 Leak in gifsponge.
+
+Build Fixes
+----------
+
+* glibtoolize port fix for OS X.
+
+Version 5.1.0
+=============
+
+Changes to the API require a library major-version bump.
+
+Code Fixes
+----------
+
+* A small change to the API: DGifClose() and EGifClose() now take a
+  pointer-to-int second argument (like the corresponding openers)
+  where a diagnostic code will be deposited when they return
+  GIF_ERROR.  This replaces the old behavior in which the GifFile
+  structure was left unfreed so the Error member in it could be filled
+  and remain available.  The change was was required because it's
+  not always possible to free the struct afterwards. Case in point is
+  a C# wrapper for giflib (or any language/environment where you can't
+  just free objects allocated in a foreign shared library.)
+
+* Minor fix for SF bug #56; BitsPerPixel may be left as uninitialized
+  value when reading (truncated) gif.
+
+* Applied SF patch #17: Use a fallback on Windows where mkstemp is not
+  available.
+
+* Applied SF patch #15: Code hardening, preventing spurious
+  defective-image messages.
+
+Retirements
+-----------
+
+* Removed gif2raw from utils. Its blithe assumption that the EGA16
+  palette is a reliable default is now about 20 years obsolete. Format
+  conversion is better done with convert(1) from the ImageMagick suite,
+  anyway.
+
+Version 5.0.6
+=============
+
+Minor fix for a rare memory leak (SF bug #55).  
+
+MinGW port fixes.
+
+Repair the internal quantization function used in gif2rgb so it's
+less vulnerable to cross-platform skew due to qsort() being unstable.
+This shouldn't affect production use, it's just a cross-platform
+issue for regression testing 
+
+Version 5.0.5
+=============
+
+Set the error return properly when a screen descriptor read fails.
+Fixes for some minor API documentation bugs. Some internal manual
+pages are not to be installed.
+
+Version 5.0.4
+=============
+
+Fix for a rare misrendering bug when a GIF overruns the decompression-code 
+table. The image on which this was spotted was a relatively long-running 
+animated GIF; still images of ordinary size should have been immune.
+
+Version 5.0.3
+=============
+
+Fix a build-system glitch so it will install manpages.
+
+Version 5.0.2
+=============
+
+Documentation and polish
+------------------------
+* Partial build is now possible on systems without xmlto.
+
+Code Fixes
+----------
+* Change unused return of EGifSetGifVersion() to void.
+* Buffer overrun prevention in gifinto.
+
+Version 5.0.1
+=============
+
+Documentation and polish
+------------------------
+* There is now an installable manual page for the GIFLIB utility kit.
+
+Retirements
+-----------
+* gifinter is gone.  Use "convert -interlace line" from the ImageMagick suite.
+
+Code Fixes
+----------
+* In 5.0.0 the private gif89 bit wasn't being guaranteed cleared at
+  the beginning of EGifGetGifVersion(); this occasionally led to an
+  incorrect version prefix being issued dependent on the state of
+  malloced memory.
+* An EGifSetGifVersion() function taking a GifFile argument has been 
+  added for use with the low-level sequential API. This change requires
+  a bump of the library revision number.
+
+Version 5.0.0
+=============
+
+Changes to the API require a library major-version bump. Certain
+initialization functions have acquired an integer address argument for
+passing back an error code, in order to avoid thread-unsafe static
+storage. Application code using extension blocks will require minor
+changes. A few functions have been renamed.
+
+Code Fixes
+----------
+* Fixes applied for CVE-2005-2974 and CVE-2005-3350
+  This closes Debian bug #337972.
+
+New API Features
+----------------
+
+Thread Safety
+~~~~~~~~~~~~~
+The library is now completely re-entrant and thread-safe.
+
+* Library error handling no longer uses a static cell to store the last
+  error code registered; that made the library thread-unsafe.  For functions 
+  other than GIF file openers, the code is now put in an Error member of
+  the GifFileType structure.  The GifError() and GifLastError() functions
+  that referenced that static cell are gone, and the GifErrorString()
+  function introduced in the 4.2 release now takes an explicit error code
+  argument.
+* GIF file openers - DGifOpenFileName(), DGifOpenFileHandle(), DGifOpen(),
+  EGifOpenFileName(), EGifOpenFileHandle(), and EGifOpen() - all now take
+  a final integer address argument.  If non-null, this is used to pass
+  back an error code when the function returns NULL. 
+
+Extensions
+~~~~~~~~~~
+The ExtensionBlock API has been repaired, solving some problems with GIF89
+extension handling in earlier versions.
+
+* DGifSlurp() and EGifSpew() now preserve trailing extension blocks with
+  no following image file.
+* Three documented functions - EGifPutExtensionFirst(), EGifPutExtensionNext(),
+  and EGifPutExtensionLast() - have been relaced by new functions
+  EGifPutExtensionLeader(), EGifPutExtensionBlock(), and 
+  EGifPutExtensionTrailer().  See the Compatibility section of
+  the library API documentation for details.
+* New functions DGifSavedExtensionToGCB() and EGifGCBToSavedExtension()
+  make it easy to read and edit GIF89 graphics control blocks in saved images.
+
+Namespacing
+~~~~~~~~~~~
+All functions exported by giflib now have DGif, EGif, or Gif as a name prefix.
+
+* Three documented functions - MakeMapObject(), FreeMapObject(), and
+  UnionColorMap() - have been renamed to GifMakeMapObject(),
+  GifFreeMapObject(), and GifUnionColorMap() respectively.
+* The library Draw* functions are now prefixed GifDraw*, and the
+  text-drawing ones are suffixed with "8x8". This fixes a conflict
+  with the Windows API and leaves the door open for more general text-drawing
+  functions with different font sizes.
+
+Other changes
+~~~~~~~~~~~~~
+* DGifSlurp() and EGifSpew() now read and write interlaced images properly.
+* The amazingly obscure colormap sort flag and pixel aspect ratio
+  features of GIF are now read and preserved, for whatever good that
+  may do.
+* Six undocumented functions have been renamed; five of these take additional
+  or slightly different argument types. See the Compatibility section of
+  the library API documentation for details.
+* There's now an EGifGetGifVersion() that computes the version EGifSpew() 
+  will write.
+* QuantizeBuffer() has been returned to the core library as GifQuantizeBuffer() 
+  - turns out some important applications (notably mplayer) were using it.
+* TRUE and FALSE macros are gone, also VoidPtr.  No more namespace pollution.
+* Various arguments have been made const where possible.
+
+Retirements
+-----------
+* The (undocumented) gifinfo utility is gone.  Use giftool -f instead.
+* The gifburst utility is gone.  Everybody has image viewers that
+  can pan now, and removing it gets rid of a dependency on Perl.
+* gifcompose is gone.  It was a decent idea when I wrote it in 1989,
+  but I did the same thing better and cleaner a decade later with
+  PILdriver in the PIL package. Removing it gets rid of a dependency
+  on shell.
+* gif2x11 gifasm, gifcomb, gifflip, gifovly, gifpos, gifresize, and gifrotate
+  are all gone.  The ImageMagick display(1)/convert(1) utilities and PILdriver
+  do these things better and in a format-independent way.
+* Lennie Araki's Windows C++ wrapper is gone. It's eight years old,
+  unmaintained, he has dropped out of sight, and a better one needs to
+  be written to use the high-level GIFLIB API and GIF89 graphics
+  control extension support.  We'll carry such a wrapper when we have
+  a maintainer for it.
+* EGifSetVersion(), introduced in 4.2, is gone. The library always
+  writes GIF87 or GIF89 as required by the data. This change helps
+  with thread safety.
+
+Utilities
+---------
+* Several utilities have been renamed to (a) fix last-century's habit
+  of arbitarily smashing vowels out of names to make them just one or two
+  characters shorter, (b) ensure that every utility in this set has 'gif'
+  as a name prefix. Here's the list:
+
+	giffiltr -> giffilter
+	gifspnge -> gifsponge
+	icon2gif -> gifbuild
+	text2gif -> gifecho
+  	raw2gif  -> gif2raw
+
+* To go with its new name, gif2raw now dumps raw pixels from a GIF if the
+  (previously required) size option is missing.
+* Standalone rgb2gif is gone; the same capability is now a mode of gif2rgb.
+* giftext displays the parsed contents of GIF89 graphics control blocks.
+* gifbuild handles GIF89 graphics control blocks and Netscape animation
+  loop blocks; it can can display and update either.
+* gifrotate and other filter utilities now preserve extension blocks, 
+  including the graphics control information for transparency and delay time.
+* A new utility, giftool, supports a wide variety of filtering operations
+  on GIFs, including: setting background and transparency colors, changing
+  interlacing, setting image delays, setting the user-input flag, and setting
+  the aspect-ratio byte.  It can sequence multiple operations.
+* The test-pattern generators gifbg, gifcolor, gihisto and gifwedge and the
+  code templates giffilter and gifsponge are no longer installed by default.
+
+Documentation and polish
+------------------------
+* The history.txt and build.txt and files from 4.2.0 now have .asc extensions
+  to indicate that they use asciidoc markup, contrasting with the txt 
+  standards files from CompuServe.
+* The documentation now includes "What's In A GIF", a very detailed narrative
+  description of the file format.
+* The -A option of gifasm (for inserting a loop control block) is documented.
+* The documentation directory includes a copy of the original GIF87 
+  specification as well as GIF89's.
+* The project now has a logo.
+
+Version 4.2.0
+=============
+
+Now maintained by ESR again after handoff by Toshio Kuratomi.
+
+Code Fixes
+----------
+* Code updated internally to C99 to enable more correctness checks by
+  the compiler. Compiles under GCC 4.6.1 without errors or warnings.
+* A rare resource leak in the colormap-object maker was found with
+  Coverity and fixed.
+* The code now audits clean under Coverity and cppcheck.
+* splint cleanup begun, there's a lot of work still to do on this.
+
+New API Features
+----------------
+* The default GIF version to write is now computed at write time from
+  the types of an image's extension blocks, but can be overridden with 
+  EGifSetGifVersion().
+* EGifSpew() is now thread-safe. 
+* Two new functions, GifError() and GifErrorString(),
+  return the error state in a form that can be used by programs.
+* Two library functions - EGifOpenFileName() and EGifPutImageDesc() -
+  now have bool rather than int flag arguments. Since bool is a
+  typedef of int and TRUE/FALSE have been redefined to true/false, 
+  both source and object compatibility with older library versions
+  should be preserved. 
+* GAGetArgs(), used only in the utilities, now returns bool rather
+  than int. 
+* The undocumented GIF_LIB_VERSION symbol is gone from the library header.  
+  It has been replaced with three documented symbols: GIFLIB_MAJOR,
+  GIFLIB_MINOR, and GIFLIB_RELEASE.
+
+Retirements
+-----------
+* The gif2epsn and gif2iris utilities are gone.  They were full of
+  platform dependencies for platforms long dead.  There are enough
+  platform-independent GIF viewers in the world that these weren't
+  adding any value. Removing these gets rid of a dependency on GL.
+* The rle2gif, gif2rle, and gif2ps utilities are also gone. There are enough
+  multiformat image converters in the world that these weren't adding 
+  any value either.  Removing them reduces the codebase's dependencies.
+* The undocumented DumpScreen2Gif() is gone from the library.  The
+  only non-obsolete capture mode it supported was through X, and that
+  probably hasn't been used in years and is replaceable by any number
+  of capture utilities.  Dropping this code makes the library's 
+  portability issues go away.
+* QuantizeBuffer(), GifQprintf(), PrintGifError(), GIF_ERROR() 
+  and GIF_MESSAGE() have been removed from the core library.  
+  They were used only by the utilities. QuantizeBuffer() has been
+  inlined where it was used and the latter three are now part of the
+  utility support library.
+* The Game Boy Advanced test code is gone.  The platform was discontinued
+  in 2008; more to the point, nobody ever documented the code's assumptions
+  or expected results.
+* The Changelog file is now retained for archival purposes only, and because
+  autotools throws a hissy fit if there isn't one.  The single point of
+  truth about changes and the reasons for them is the repository history.
+
+Behavior changes
+----------------
+* The -q option of the utilities is replaced by an opposite -v (verbose)
+  option; the default is now quiet for all platforms.  Defaulting to chattiness
+  on MSDOS made sense in a world of slow text consoles, but not today.
+
+Testing
+-------
+* There is now a proper regression-test suite; run 'make' in tests/.
+  The old test-unx script is now tests/visual-check and can be run 
+  occasionally for a check with the Mark One Eyeball.
+
+Documentation
+-------------
+* Build instructions now live in build.txt
+* An overview of the giflib API now lives in api.txt.
+* Documentation is now in DocBook-XML, so either HTML or man pages can
+  be generated from it.
+
+Version 4.1.6
+=============
+Brown paper bag release.  Fix a problem with header inclusion that could
+prevent the library from building on some platforms.
+
+Version 4.1.5
+=============
+This version has some important fixes for segfaults when working with corrupt
+files.  All users are strongly encouraged to upgrade.
+
+Code Fixes
+----------
+* Fix segfault in utilities due to referencing ColorMaps in GifFiles that had
+  no ColorMap present.
+* Fix gif2x11 to work on 24 bit displays.
+* Fix for giftext segfault when the GifFile does not store a global colormap.
+* Checks to fail gracefully when an image contains improper LZ codes.
+* Close file handles on failure in DGifOpenFileHandle()
+* Checks to operate on files in binary mode on WIN32 as well as MSDOS.
+
+Building
+--------
+* Add checks to make building on Win32 easier.
+* Allow turning off gl_s, rle, and X11 support from the configure command line.
+* Fix for finding a 32 bit integer type on some platforms.
+* Only enable -Wall if we're using gcc.
+
+Version 4.1.4
+=============
+This version fixes some bugs with deallocating ColorMaps.  Fix building on
+several platforms.  Fix x86_64 builds to not hang the encoder.
+
+* Fix several areas in decoding where we removed a ColorMap from our GifFile
+  but didn't set the pointer to NULL.  This could lead to double free's of
+  the ColorMap.
+* Fix a bug in dev2gif.c where we redefined some gl types incorrectly.
+* Fix a bug in the gif LZW encoder that was triggered on modern 64 bit
+  platforms.
+* Fix building on Windows.  Note -- there has been one API changing event for
+  Windows (renaming DrawText to DrawGifText.)  This should have conflicted with
+  Windows API and therefore caused the builds to fail previously.  If you had
+  it working with DrawText before, apologies, you'll need to change to
+  DrawGifText in your code.  This only affects Windows.
+* Add support for building on The Game Boy Advance.  Note: Due to the GBA's
+  limited memory, the API for the GBA uses short's in many places where the
+  other platforms use ints.  This shouldn't affect anyone unless you've
+  been able to get an older version of the code to run on GBA and want to
+  start using this version instead.  A recompile of your dependent code
+  will be necessary in this case.
+
+Version 4.1.3
+=============
+This version fixes some bugs in the Extension writing code in
+EGifPutExtensionFirst, Next, and Last.  Using these functions, it is possible
+to output extensions that contain multiple subblocks.  Additionally, library
+code has been updated to use these functions, making it safe to output
+long Comments, and multi-block extensions read in from another file.
+
+* giflib is now hosted on sourceforge with libungif:
+  http://sourceforge.net/projects/libungif
+* Make the EGifPutExtension{First,Next,Last} family of functions use WRITE
+  so user defined WRITE methods will output them correctly.
+* Modify EGifSpew and EGifPutComment to use EGifPutExtension{First,Next,Last}
+  so we won't output broken GIFs when dealing with GIFs with multiple
+  subblocks.
+* More -Wall fixes revealed while testing on Solaris and FreeBSD.
+* Updated the gif_lib.html documentation to not use EGifPutExtension when
+  dealing with multiple subblocks.  Use EGifPutExtension{First,Next,Last}
+  instead.
+* Some Windows code from the old CVS repository now available in the windows
+  subdirectory.  I don't have a Windows environment to test and maintain this
+  but maybe someone out there will find it useful.  Caveat hacker.
+
+Version 4.1.2
+=============
+* Numerous bug fixes from people on the old libungif mailing list.
+* GIF_ERROR and GIF_MESSAGE are on the deprecation list as they are also
+  utility helper functions rather than essential to the functioning of the
+  library.
+* Complete deprecation list is now in the README file
+* Audited the sources with gcc -Wall. Everything detectable has now been fixed.
+* Ran the library code through indent.
+  
+Version 4.1.1
+=============
+* Merge in many bug fixes that were sent in while I was hiking the
+  Appalachian Trail.
+* The qprintf methods of the library are now deprecated.  Do not use 
+  GifQuietPrint or GifQprintf.  These should have been pushed out into the
+  utility helper library instead of sitting around in the library proper at
+  the same time as the getarg functions were moved out.  Getting rid of these
+  will let us get rid of our dependence on stdarg.h/varargs.h (Which a Gif
+  reading library has no business requiring.)
+
+Version 4.1.0
+=============
+* Several minor memory leaks in error conditions have been plugged.
+* New Function EGifOpen(void *userData, OutputFunc writeFunc) allows user
+  specified gif writing functions.
+* Old copyright notices in a few source files have been updated.  All library
+  copyrights should now reflect the copyright notice in the COPYING file.
+
+Version 4.0.0 -- giflib
+=======================
+This version of the giflib library merges Eric Raymond's giflib-3.0 release
+with the libungif-4.0 release to give people a binary compatible choice
+between the two libraries and gives me the chance to add bugfixes to giflib
+that have been incorporated in libungif.
+
+PLEASE READ THE FILE PATENT_PROBLEMS BEFORE USING THIS LIBRARY!
+
+Version 4.0.0
+=============
+Major fixes have been made to the code that handles Extensions.
+Unfortunately, this causes binary incompatibility with giflib-3.0 and
+libungif-3.x.  However, the API is still intact.  I am, however, deprecating
+the use of saveImage[x].Function.  Use
+saveImage[x].ExtensionBlocks[y].Function instead.
+
+Version 3.1.1
+=============
+ The following bugs which caused SegFaults have been fixed:
+ * When reading gif files with extensions, DGifSlurp would violate memory.
+ * When closing a gif that had a local colormap, DGifCloseFile would attempt
+   to free the colormap twice.
+ * Fix a potential memory leak in DGifSlurp.
+ * New function DGifOpen to allow specifying a user definable gif reading
+   function.
+
+Version 3.1.0
+=============
+ * Add a new function:
+        GifFileType *DGifOpen(void * userData, InputFunc readFunc)
+   to read the gif image from a user defined input function.
+ * A few bugfixes.
+
+Version 3.0
+===========
+
+Changes from Eric Raymond's libgif
+----------------------------------
+* A new gif encoder that makes uncompressed gifs rather than standard,
+  LZW-compressed gifs.  This is actually the major motivating factor behind
+  libungif; to provide third-party distributors a means to provide a gif
+  library without the patented LZW encoder.
+* A new configure script to make compilation of the library on multiple
+  platforms easier.  The package should now build shared libraries on all
+  platforms supported by GNU libtool.
+* Removed the getarg functions from libgif.  These were not part of the
+  public API and only used by the tools in the utils directory so I separated
+  them from the rest of the library.
+* Fixed a few bugs in the tools in the utils directory.
+
+Version 3.0
+===========
+
+New features
+------------
+* Incorporated Sirtaj Kang's changes to make both static and shared libs.
+* All the utility and library docs are HTML now.
+* The library and relevant utilities are now fully GIF89-aware.
+* Functions for drawing text and boxes on saved images are documented.
+* The distribution is now issued under a simple X-Consortium-style license.
+* Can now generate package RPMs and LSM automatically.
+* Home page with Web-acessible documentation at http://www.ccil.org/~esr/giflib
+
+Bug fixes
+---------
+* Fix giftext to not core dump on a null extension record.
+* Incorporate Philip VanBaren's change to prevent a core dump in gifasm.
+
+Version 2.3
+===========
+* Fixed a core-dump bug in gifcomb revealed by ELF environment in Linux 1.2.13.
+
+Version 2.2b
+============
+* Added gifburst tool.
+
+Version 2.2
+===========
+* Linux is supported.
+
+Version 2.1
+===========
+* Added the gifovly tool, which supports making a composite from several GIF
+  images.
+* Used gifovly to implement a full-fledged pasteup program in shell.  It's
+  called gifcompose and lives in the util directory.
+* Added a copy of the GIF89 standard to the doc directory (gif89.txt);
+  also a description of the preferred compression method (lzgif.txt).
+
+Version 2.0
+===========
+   With this version, development was taken over from Gershon Elber by Eric
+S. Raymond <esr@snark.thyrsus.com>.  Note that I, esr, have pretty much
+adhered to Gershon's coding style, even though it's quite baroque and DOS-
+headed by my standards.
+
+Library Improvements
+--------------------
+* New DGifSlurp() and EGifSpew() library entry points allow all GIF-bashing
+  to be done in core on machines with sufficient memory.  Writing code to
+  slice'n'dice multiple GIFs in non-sequential ways is now much easier (send
+  kudos and brickbats to esr, small unmarked bills preferred).
+* The interface has changed somewhat.  Members in the GifFileType structure
+  have been renamed and regrouped.  This was required for support of the
+  SavedImages member (which enables the new functions mentioned in 1).  Also,
+  there is a new data type for allocated color maps and routines to handle
+  it conveniently.
+* Some minor bugs have been fixed.  Most notably, the DGif code now correctly
+  handles the possibility of more than one code block per extension record,
+  as per the GIF spec.  It's not clear, however, that anyone ever has or
+  ever will use this feature for anything...
+
+New Tools and Options
+---------------------
+* A brand new, ultra-spiffy tool `icon2gif' is included.  It assembles named
+  GIFs with editable text color map & icon raster representations to produce
+  multi-image GIFs usable as graphical resource files.  It can also dump most
+  GIFs in the same text-only form it parses.  This makes it easy to edit GIFs
+  even if you don't have a graphics editor.
+* The gifclip utility supports a new `-c' (complement) option that allows you
+  to perform an `inverse clip', removing horizontal or vertical bands from an
+  image.
+* The gifclrmp utility supports a new `-t' switch for shuffling color index
+   values.
+* A new tool `gifcolor' generates test pattern from colormap input.
+
+New Documentation and Examples
+------------------------------
+* The documentation has been overhauled completely and translated out of the
+  dialect spoken by the estimable Mr. Elber into something like standard
+  English :-).
+* Two source code files gifspnge.c and giffiltr.c have been added to the
+  util directory.  These are GIF copiers that exercise the I/O routines,
+  provided as skeletons for your applications.  Read the comments in them
+  for more info.
+* The util Makefile for UNIX has been improved.  It now uses the cc/gcc -s
+  option rather than strip(1).  There are now separate install productions,
+  so you can test new versions in util before installation for production
+  (the top-level make script still does an install).
+
+Version 1.2
+===========
+* GIFFIX - a new tool to attempt and fix broken GIF images. Currently fix
+  images that has EOF prematurely by padding with the darkest color.
+* Make GIF2BGI display as much as it can considering the mem. avail.
+* Add -q flag to all tools for quite running scan line number mode.
+* Fix a (minor!?) bug in the GIF decoder when encountering code 4095.
+* New tools (RGB2GIF and GIF2RGB) to convert GIF to/from 24 bits RGB images.
+* New tool GIFROTAT to rotate a gif image by an arbitrary angle.
+* GifRSize was updated to resize by an arbitrary factor.
+
+Version 1.1
+===========
+* GIF2BGI - a new utility to display GIF images using Borland's BGI drivers
+  (if you have one...)
+* TEXT2GIF - Converts plain text into GIF images.
+* GIF2IRIS - SGI4D display program for GIF images.
+* GIF_LIB naming convension has been modified to make sure it has unique
+  names (see gif_lib.h).
+* Support for SGI4D gl and X11 window grabbing has been added to the
+  library. SGI4D input is quantizied into 8 bits.
+  Also support for EGA/VGA devices has been added as well.
+  see Dev2gif.c module.
+* Support for the new gif89a format has been added.
+
+
+
diff --git a/OWNERS b/OWNERS
index 1015fd5..7529cb9 100644
--- a/OWNERS
+++ b/OWNERS
@@ -1,3 +1 @@
-# Default code reviewers picked from top 3 or more developers.
-# Please update this list if you find better candidates.
-scroggo@google.com
+include platform/system/core:/janitors/OWNERS
diff --git a/README b/README
new file mode 100644
index 0000000..49cf9eb
--- /dev/null
+++ b/README
@@ -0,0 +1,45 @@
+= GIFLIB =
+
+This is the README file of GIFLIB, a library for manipulating GIF files.
+
+Latest versions of GIFLIB are currently hosted at:
+    http://sourceforge.net/projects/giflib
+
+== Overview ==
+
+GIF is a legacy format; we recommend against generating new images in
+it.  For a cleaner, more extensible design with better color support
+and compression, look up PNG.
+
+giflib provides code for reading GIF files and transforming them into 
+RGB bitmaps, and for writing RGB bitmaps as GIF files.
+
+The (permissive) open-source license is in the file COPYING.
+
+You will find build instructions in build.adoc
+
+You will find full documentation of the API in doc/ and on the 
+project website.
+
+Please report bugs to the bug tracker on sourceforge:
+
+http://sourceforge.net/tracker/?group_id=102202
+
+The project has a long and confusing history, described in history.adoc
+
+The project to-do list is in TODO.
+
+== Authors ==
+
+Gershon Elber <gershon[AT]cs.technion.sc.il>
+	original giflib code
+
+Toshio Kuratomi <toshio[AT]tiki-lounge.com>
+        uncompressed gif writing code
+        former maintainer
+
+Eric Raymond <esr[AT]snark.thyrsus.com>
+        current as well as long time former maintainer of giflib code
+
+There have been many other contributors; see the attributions in the
+version-control history to learn more.
diff --git a/README.version b/README.version
deleted file mode 100644
index 8d84679..0000000
--- a/README.version
+++ /dev/null
@@ -1,3 +0,0 @@
-URL: https://sourceforge.net/projects/giflib/files/giflib-5.1.1.tar.bz2/download
-Version: 5.1.1
-BugComponent: 24950
diff --git a/TODO b/TODO
new file mode 100644
index 0000000..c92d781
--- /dev/null
+++ b/TODO
@@ -0,0 +1,10 @@
+= GIFLIB TODO list =
+
+There is a list of GIF test suites here:
+
+https://stackoverflow.com/questions/4866093/test-suite-for-gif-containing-images-using-rarely-used-features
+
+These break the format in quite a number of interesting ways.  GIFLIB doesn't
+do as well as it could; I haven't found one that causes a core dump, yet, but
+some malformations that could be worked around are not yet.
+
diff --git a/build.adoc b/build.adoc
new file mode 100644
index 0000000..5527b8e
--- /dev/null
+++ b/build.adoc
@@ -0,0 +1,52 @@
+= Build instructions =
+
+== Building ==
+
+Building this package from a distribution tarball should be as simple as
+running make.  Install with "make install" as root.
+
+You will need xmlto to build the derived forms of the documentation
+from the DocBook-XML sources.  If you are going no modify the website,
+you will also need to have asciidoc and the ImageMagick convert(1)
+utility installed.
+
+== Testing ==
+
+You can run "make check" after the library and utilities have been built
+to see a regression test of the codebase. No output (other than
+the test header lines) is good news.
+
+== Portability note ==
+
+This codebase now assumes your compiler is C99-conformant.  If it
+isn't, the most likely trouble spot is "#include <stdint.h>"; your
+compiler may be looking for "inttypes.h" instead.  By test, the code
+is backward-conformant to C89 except that it uses bool/true/false. 
+
+One (minimal but sufficient) concession to Windows portability has been
+make; inclusion of <unistd.h> is conditional on _WIN32 not being
+defined by the compiler (if it is <io.h> is included
+instead). Requests to go any further out of the way to accommodate
+Microsoft's toolchains are unlikely be looked on favorably.
+
+== Release Procedure ==
+
+1. Check the SourceForge tracker for bugs and patches.
+
+2. Bump the version number in gif_lib.h.  Do "make version"
+   to confirm that it looks sane when extracted to the Makefile.
+
+3. Version-stamp the top entry in the NEWS file. 
+
+4. If you are changing major versions, sync the XBS-SourceForge-Folder
+   attribute in the control file.
+
+5. 'make dist' to make a tarball.
+
+6. Tag the release in the repo.
+
+7. Ship the release tarball.
+
+The last three steps can be done with "make release" if you have shipper
+installed.
+
diff --git a/config.h b/config.h
deleted file mode 100644
index 3193a1b..0000000
--- a/config.h
+++ /dev/null
@@ -1,13 +0,0 @@
-
-// giflib config.h
-
-#ifndef GIF_CONFIG_H_DEFINED
-#define GIF_CONFIG_H_DEFINED
-
-#include <sys/types.h>
-#include <stdint.h>
-#include <fcntl.h>
-
-typedef uint32_t UINT32;
-
-#endif
diff --git a/control b/control
new file mode 100644
index 0000000..0fe40db
--- /dev/null
+++ b/control
@@ -0,0 +1,19 @@
+# This is not a real Debian control file, though the syntax is compatible.
+# It's project metadata for the shipper tool
+
+Package: giflib
+
+Destinations: ~,sourceforge
+
+Description: a library for rendering and generating GIF image files.
+ This is the GIF service code in C used for over two decades by graphics
+ applications, web browsers, game consoles, ATMs, and pretty much anything
+ else that throws pixels on a display. Simple, stable, and bulletproof.
+
+XBS-Web-Directory: doc/staging
+XBS-Logo: doc/staging/giflib-logo.gif
+XBS-SourceForge-Folder: giflib-5.x
+
+XBS-VC-Tag-Template: %(version)s
+
+#XBS-Project-Tags: GIF, graphics
diff --git a/dgif_lib.c b/dgif_lib.c
index 66a1d6a..cbcf23f 100644
--- a/dgif_lib.c
+++ b/dgif_lib.c
@@ -6,37 +6,44 @@ The functions here and in egif_lib.c are partitioned carefully so that
 if you only require one of read and write capability, only one of these
 two modules will be linked.  Preserve this property!
 
+SPDX-License-Identifier: MIT
+
 *****************************************************************************/
 
-#include <stdlib.h>
+#include <fcntl.h>
 #include <limits.h>
 #include <stdint.h>
-#include <fcntl.h>
-#include <unistd.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 
 #ifdef _WIN32
 #include <io.h>
+#else
+#include <unistd.h>
 #endif /* _WIN32 */
 
 #include "gif_lib.h"
 #include "gif_lib_private.h"
 
 /* compose unsigned little endian value */
-#define UNSIGNED_LITTLE_ENDIAN(lo, hi)	((lo) | ((hi) << 8))
+#define UNSIGNED_LITTLE_ENDIAN(lo, hi) ((lo) | ((hi) << 8))
 
 /* avoid extra function call in case we use fread (TVT) */
-#define READ(_gif,_buf,_len)                                     \
-  (((GifFilePrivateType*)_gif->Private)->Read ?                   \
-    ((GifFilePrivateType*)_gif->Private)->Read(_gif,_buf,_len) : \
-    fread(_buf,1,_len,((GifFilePrivateType*)_gif->Private)->File))
+static int InternalRead(GifFileType *gif, GifByteType *buf, int len) {
+	// fprintf(stderr, "### Read: %d\n", len);
+	return (((GifFilePrivateType *)gif->Private)->Read
+	            ? ((GifFilePrivateType *)gif->Private)->Read(gif, buf, len)
+	            : fread(buf, 1, len,
+	                    ((GifFilePrivateType *)gif->Private)->File));
+}
 
 static int DGifGetWord(GifFileType *GifFile, GifWord *Word);
 static int DGifSetupDecompress(GifFileType *GifFile);
 static int DGifDecompressLine(GifFileType *GifFile, GifPixelType *Line,
                               int LineLen);
-static int DGifGetPrefixChar(GifPrefixType *Prefix, int Code, int ClearCode);
+static int DGifGetPrefixChar(const GifPrefixType *Prefix, int Code,
+                             int ClearCode);
 static int DGifDecompressInput(GifFileType *GifFile, int *Code);
 static int DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf,
                              GifByteType *NextByte);
@@ -46,20 +53,19 @@ static int DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf,
  Returns dynamically allocated GifFileType pointer which serves as the GIF
  info record.
 ******************************************************************************/
-GifFileType *
-DGifOpenFileName(const char *FileName, int *Error)
-{
-    int FileHandle;
-    GifFileType *GifFile;
-
-    if ((FileHandle = open(FileName, O_RDONLY)) == -1) {
-	if (Error != NULL)
-	    *Error = D_GIF_ERR_OPEN_FAILED;
-        return NULL;
-    }
-
-    GifFile = DGifOpenFileHandle(FileHandle, Error);
-    return GifFile;
+GifFileType *DGifOpenFileName(const char *FileName, int *Error) {
+	int FileHandle;
+	GifFileType *GifFile;
+
+	if ((FileHandle = open(FileName, O_RDONLY)) == -1) {
+		if (Error != NULL) {
+			*Error = D_GIF_ERR_OPEN_FAILED;
+		}
+		return NULL;
+	}
+
+	GifFile = DGifOpenFileHandle(FileHandle, Error);
+	return GifFile;
 }
 
 /******************************************************************************
@@ -67,449 +73,487 @@ DGifOpenFileName(const char *FileName, int *Error)
  Returns dynamically allocated GifFileType pointer which serves as the GIF
  info record.
 ******************************************************************************/
-GifFileType *
-DGifOpenFileHandle(int FileHandle, int *Error)
-{
-    char Buf[GIF_STAMP_LEN + 1];
-    GifFileType *GifFile;
-    GifFilePrivateType *Private;
-    FILE *f;
-
-    GifFile = (GifFileType *)malloc(sizeof(GifFileType));
-    if (GifFile == NULL) {
-        if (Error != NULL)
-	    *Error = D_GIF_ERR_NOT_ENOUGH_MEM;
-        (void)close(FileHandle);
-        return NULL;
-    }
-
-    /*@i1@*/memset(GifFile, '\0', sizeof(GifFileType));
-
-    /* Belt and suspenders, in case the null pointer isn't zero */
-    GifFile->SavedImages = NULL;
-    GifFile->SColorMap = NULL;
-
-    Private = (GifFilePrivateType *)calloc(1, sizeof(GifFilePrivateType));
-    if (Private == NULL) {
-        if (Error != NULL)
-	    *Error = D_GIF_ERR_NOT_ENOUGH_MEM;
-        (void)close(FileHandle);
-        free((char *)GifFile);
-        return NULL;
-    }
-
-    /*@i1@*/memset(Private, '\0', sizeof(GifFilePrivateType));
+GifFileType *DGifOpenFileHandle(int FileHandle, int *Error) {
+	char Buf[GIF_STAMP_LEN + 1];
+	GifFileType *GifFile;
+	GifFilePrivateType *Private;
+	FILE *f;
+
+	GifFile = (GifFileType *)malloc(sizeof(GifFileType));
+	if (GifFile == NULL) {
+		if (Error != NULL) {
+			*Error = D_GIF_ERR_NOT_ENOUGH_MEM;
+		}
+		(void)close(FileHandle);
+		return NULL;
+	}
+
+	/*@i1@*/ memset(GifFile, '\0', sizeof(GifFileType));
+
+	/* Belt and suspenders, in case the null pointer isn't zero */
+	GifFile->SavedImages = NULL;
+	GifFile->SColorMap = NULL;
+
+	Private = (GifFilePrivateType *)calloc(1, sizeof(GifFilePrivateType));
+	if (Private == NULL) {
+		if (Error != NULL) {
+			*Error = D_GIF_ERR_NOT_ENOUGH_MEM;
+		}
+		(void)close(FileHandle);
+		free((char *)GifFile);
+		return NULL;
+	}
+
+	/*@i1@*/ memset(Private, '\0', sizeof(GifFilePrivateType));
 
 #ifdef _WIN32
-    _setmode(FileHandle, O_BINARY);    /* Make sure it is in binary mode. */
-#endif /* _WIN32 */
+	_setmode(FileHandle, O_BINARY); /* Make sure it is in binary mode. */
+#endif                                  /* _WIN32 */
 
-    f = fdopen(FileHandle, "rb");    /* Make it into a stream: */
-
-    /*@-mustfreeonly@*/
-    GifFile->Private = (void *)Private;
-    Private->FileHandle = FileHandle;
-    Private->File = f;
-    Private->FileState = FILE_STATE_READ;
-    Private->Read = NULL;        /* don't use alternate input method (TVT) */
-    GifFile->UserData = NULL;    /* TVT */
-    /*@=mustfreeonly@*/
-
-    /* Let's see if this is a GIF file: */
-    /* coverity[check_return] */
-    if (READ(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) != GIF_STAMP_LEN) {
-        if (Error != NULL)
-	    *Error = D_GIF_ERR_READ_FAILED;
-        (void)fclose(f);
-        free((char *)Private);
-        free((char *)GifFile);
-        return NULL;
-    }
-
-    /* Check for GIF prefix at start of file */
-    Buf[GIF_STAMP_LEN] = 0;
-    if (strncmp(GIF_STAMP, Buf, GIF_VERSION_POS) != 0) {
-        if (Error != NULL)
-	    *Error = D_GIF_ERR_NOT_GIF_FILE;
-        (void)fclose(f);
-        free((char *)Private);
-        free((char *)GifFile);
-        return NULL;
-    }
-
-    if (DGifGetScreenDesc(GifFile) == GIF_ERROR) {
-        (void)fclose(f);
-        free((char *)Private);
-        free((char *)GifFile);
-        return NULL;
-    }
-
-    GifFile->Error = 0;
-
-    /* What version of GIF? */
-    Private->gif89 = (Buf[GIF_VERSION_POS] == '9');
-
-    return GifFile;
+	f = fdopen(FileHandle, "rb"); /* Make it into a stream: */
+
+	/*@-mustfreeonly@*/
+	GifFile->Private = (void *)Private;
+	Private->FileHandle = FileHandle;
+	Private->File = f;
+	Private->FileState = FILE_STATE_READ;
+	Private->Read = NULL;     /* don't use alternate input method (TVT) */
+	GifFile->UserData = NULL; /* TVT */
+	/*@=mustfreeonly@*/
+
+	/* Let's see if this is a GIF file: */
+	/* coverity[check_return] */
+	if (InternalRead(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) !=
+	    GIF_STAMP_LEN) {
+		if (Error != NULL) {
+			*Error = D_GIF_ERR_READ_FAILED;
+		}
+		(void)fclose(f);
+		free((char *)Private);
+		free((char *)GifFile);
+		return NULL;
+	}
+
+	/* Check for GIF prefix at start of file */
+	Buf[GIF_STAMP_LEN] = 0;
+	if (strncmp(GIF_STAMP, Buf, GIF_VERSION_POS) != 0) {
+		if (Error != NULL) {
+			*Error = D_GIF_ERR_NOT_GIF_FILE;
+		}
+		(void)fclose(f);
+		free((char *)Private);
+		free((char *)GifFile);
+		return NULL;
+	}
+
+	if (DGifGetScreenDesc(GifFile) == GIF_ERROR) {
+		(void)fclose(f);
+		free((char *)Private);
+		free((char *)GifFile);
+		return NULL;
+	}
+
+	GifFile->Error = 0;
+
+	/* What version of GIF? */
+	Private->gif89 = (Buf[GIF_VERSION_POS + 1] == '9');
+
+	return GifFile;
 }
 
 /******************************************************************************
  GifFileType constructor with user supplied input function (TVT)
 ******************************************************************************/
-GifFileType *
-DGifOpen(void *userData, InputFunc readFunc, int *Error)
-{
-    char Buf[GIF_STAMP_LEN + 1];
-    GifFileType *GifFile;
-    GifFilePrivateType *Private;
-
-    GifFile = (GifFileType *)malloc(sizeof(GifFileType));
-    if (GifFile == NULL) {
-        if (Error != NULL)
-	    *Error = D_GIF_ERR_NOT_ENOUGH_MEM;
-        return NULL;
-    }
-
-    memset(GifFile, '\0', sizeof(GifFileType));
-
-    /* Belt and suspenders, in case the null pointer isn't zero */
-    GifFile->SavedImages = NULL;
-    GifFile->SColorMap = NULL;
-
-    Private = (GifFilePrivateType *)calloc(1, sizeof(GifFilePrivateType));
-    if (!Private) {
-        if (Error != NULL)
-	    *Error = D_GIF_ERR_NOT_ENOUGH_MEM;
-        free((char *)GifFile);
-        return NULL;
-    }
-    /*@i1@*/memset(Private, '\0', sizeof(GifFilePrivateType));
-
-    GifFile->Private = (void *)Private;
-    Private->FileHandle = 0;
-    Private->File = NULL;
-    Private->FileState = FILE_STATE_READ;
-
-    Private->Read = readFunc;    /* TVT */
-    GifFile->UserData = userData;    /* TVT */
-
-    /* Lets see if this is a GIF file: */
-    /* coverity[check_return] */
-    if (READ(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) != GIF_STAMP_LEN) {
-        if (Error != NULL)
-	    *Error = D_GIF_ERR_READ_FAILED;
-        free((char *)Private);
-        free((char *)GifFile);
-        return NULL;
-    }
-
-    /* Check for GIF prefix at start of file */
-    Buf[GIF_STAMP_LEN] = '\0';
-    if (strncmp(GIF_STAMP, Buf, GIF_VERSION_POS) != 0) {
-        if (Error != NULL)
-	    *Error = D_GIF_ERR_NOT_GIF_FILE;
-        free((char *)Private);
-        free((char *)GifFile);
-        return NULL;
-    }
-
-    if (DGifGetScreenDesc(GifFile) == GIF_ERROR) {
-        free((char *)Private);
-        free((char *)GifFile);
-        if (Error != NULL)
-	    *Error = D_GIF_ERR_NO_SCRN_DSCR;
-        return NULL;
-    }
-
-    GifFile->Error = 0;
-
-    /* What version of GIF? */
-    Private->gif89 = (Buf[GIF_VERSION_POS] == '9');
-
-    return GifFile;
+GifFileType *DGifOpen(void *userData, InputFunc readFunc, int *Error) {
+	char Buf[GIF_STAMP_LEN + 1];
+	GifFileType *GifFile;
+	GifFilePrivateType *Private;
+
+	GifFile = (GifFileType *)malloc(sizeof(GifFileType));
+	if (GifFile == NULL) {
+		if (Error != NULL) {
+			*Error = D_GIF_ERR_NOT_ENOUGH_MEM;
+		}
+		return NULL;
+	}
+
+	memset(GifFile, '\0', sizeof(GifFileType));
+
+	/* Belt and suspenders, in case the null pointer isn't zero */
+	GifFile->SavedImages = NULL;
+	GifFile->SColorMap = NULL;
+
+	Private = (GifFilePrivateType *)calloc(1, sizeof(GifFilePrivateType));
+	if (!Private) {
+		if (Error != NULL) {
+			*Error = D_GIF_ERR_NOT_ENOUGH_MEM;
+		}
+		free((char *)GifFile);
+		return NULL;
+	}
+	/*@i1@*/ memset(Private, '\0', sizeof(GifFilePrivateType));
+
+	GifFile->Private = (void *)Private;
+	Private->FileHandle = 0;
+	Private->File = NULL;
+	Private->FileState = FILE_STATE_READ;
+
+	Private->Read = readFunc;     /* TVT */
+	GifFile->UserData = userData; /* TVT */
+
+	/* Lets see if this is a GIF file: */
+	/* coverity[check_return] */
+	if (InternalRead(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) !=
+	    GIF_STAMP_LEN) {
+		if (Error != NULL) {
+			*Error = D_GIF_ERR_READ_FAILED;
+		}
+		free((char *)Private);
+		free((char *)GifFile);
+		return NULL;
+	}
+
+	/* Check for GIF prefix at start of file */
+	Buf[GIF_STAMP_LEN] = '\0';
+	if (strncmp(GIF_STAMP, Buf, GIF_VERSION_POS) != 0) {
+		if (Error != NULL) {
+			*Error = D_GIF_ERR_NOT_GIF_FILE;
+		}
+		free((char *)Private);
+		free((char *)GifFile);
+		return NULL;
+	}
+
+	if (DGifGetScreenDesc(GifFile) == GIF_ERROR) {
+		free((char *)Private);
+		free((char *)GifFile);
+		if (Error != NULL) {
+			*Error = D_GIF_ERR_NO_SCRN_DSCR;
+		}
+		return NULL;
+	}
+
+	GifFile->Error = 0;
+
+	/* What version of GIF? */
+	Private->gif89 = (Buf[GIF_VERSION_POS + 1] == '9');
+
+	return GifFile;
 }
 
 /******************************************************************************
  This routine should be called before any other DGif calls. Note that
  this routine is called automatically from DGif file open routines.
 ******************************************************************************/
-int
-DGifGetScreenDesc(GifFileType *GifFile)
-{
-    int BitsPerPixel;
-    bool SortFlag;
-    GifByteType Buf[3];
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
-
-    if (!IS_READABLE(Private)) {
-        /* This file was NOT open for reading: */
-        GifFile->Error = D_GIF_ERR_NOT_READABLE;
-        return GIF_ERROR;
-    }
-
-    /* Put the screen descriptor into the file: */
-    if (DGifGetWord(GifFile, &GifFile->SWidth) == GIF_ERROR ||
-        DGifGetWord(GifFile, &GifFile->SHeight) == GIF_ERROR)
-        return GIF_ERROR;
-
-    if (READ(GifFile, Buf, 3) != 3) {
-        GifFile->Error = D_GIF_ERR_READ_FAILED;
-	GifFreeMapObject(GifFile->SColorMap);
-	GifFile->SColorMap = NULL;
-        return GIF_ERROR;
-    }
-    GifFile->SColorResolution = (((Buf[0] & 0x70) + 1) >> 4) + 1;
-    SortFlag = (Buf[0] & 0x08) != 0;
-    BitsPerPixel = (Buf[0] & 0x07) + 1;
-    GifFile->SBackGroundColor = Buf[1];
-    GifFile->AspectByte = Buf[2]; 
-    if (Buf[0] & 0x80) {    /* Do we have global color map? */
-	int i;
+int DGifGetScreenDesc(GifFileType *GifFile) {
+	int BitsPerPixel;
+	bool SortFlag;
+	GifByteType Buf[3];
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	if (!IS_READABLE(Private)) {
+		/* This file was NOT open for reading: */
+		GifFile->Error = D_GIF_ERR_NOT_READABLE;
+		return GIF_ERROR;
+	}
+
+	/* Put the screen descriptor into the file: */
+	if (DGifGetWord(GifFile, &GifFile->SWidth) == GIF_ERROR ||
+	    DGifGetWord(GifFile, &GifFile->SHeight) == GIF_ERROR) {
+		return GIF_ERROR;
+	}
+
+	if (InternalRead(GifFile, Buf, 3) != 3) {
+		GifFile->Error = D_GIF_ERR_READ_FAILED;
+		GifFreeMapObject(GifFile->SColorMap);
+		GifFile->SColorMap = NULL;
+		return GIF_ERROR;
+	}
+	GifFile->SColorResolution = (((Buf[0] & 0x70) + 1) >> 4) + 1;
+	SortFlag = (Buf[0] & 0x08) != 0;
+	BitsPerPixel = (Buf[0] & 0x07) + 1;
+	GifFile->SBackGroundColor = Buf[1];
+	GifFile->AspectByte = Buf[2];
+	if (Buf[0] & 0x80) { /* Do we have global color map? */
+		int i;
+
+		GifFile->SColorMap = GifMakeMapObject(1 << BitsPerPixel, NULL);
+		if (GifFile->SColorMap == NULL) {
+			GifFile->Error = D_GIF_ERR_NOT_ENOUGH_MEM;
+			return GIF_ERROR;
+		}
+
+		/* Get the global color map: */
+		GifFile->SColorMap->SortFlag = SortFlag;
+		for (i = 0; i < GifFile->SColorMap->ColorCount; i++) {
+			/* coverity[check_return] */
+			if (InternalRead(GifFile, Buf, 3) != 3) {
+				GifFreeMapObject(GifFile->SColorMap);
+				GifFile->SColorMap = NULL;
+				GifFile->Error = D_GIF_ERR_READ_FAILED;
+				return GIF_ERROR;
+			}
+			GifFile->SColorMap->Colors[i].Red = Buf[0];
+			GifFile->SColorMap->Colors[i].Green = Buf[1];
+			GifFile->SColorMap->Colors[i].Blue = Buf[2];
+		}
+	} else {
+		GifFile->SColorMap = NULL;
+	}
+
+	/*
+	 * No check here for whether the background color is in range for the
+	 * screen color map.  Possibly there should be.
+	 */
+
+	return GIF_OK;
+}
 
-        GifFile->SColorMap = GifMakeMapObject(1 << BitsPerPixel, NULL);
-        if (GifFile->SColorMap == NULL) {
-            GifFile->Error = D_GIF_ERR_NOT_ENOUGH_MEM;
-            return GIF_ERROR;
-        }
-
-        /* Get the global color map: */
-	GifFile->SColorMap->SortFlag = SortFlag;
-        for (i = 0; i < GifFile->SColorMap->ColorCount; i++) {
-	    /* coverity[check_return] */
-            if (READ(GifFile, Buf, 3) != 3) {
-                GifFreeMapObject(GifFile->SColorMap);
-                GifFile->SColorMap = NULL;
-                GifFile->Error = D_GIF_ERR_READ_FAILED;
-                return GIF_ERROR;
-            }
-            GifFile->SColorMap->Colors[i].Red = Buf[0];
-            GifFile->SColorMap->Colors[i].Green = Buf[1];
-            GifFile->SColorMap->Colors[i].Blue = Buf[2];
-        }
-    } else {
-        GifFile->SColorMap = NULL;
-    }
-
-    return GIF_OK;
+const char *DGifGetGifVersion(GifFileType *GifFile) {
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	if (Private->gif89) {
+		return GIF89_STAMP;
+	} else {
+		return GIF87_STAMP;
+	}
 }
 
 /******************************************************************************
  This routine should be called before any attempt to read an image.
 ******************************************************************************/
-int
-DGifGetRecordType(GifFileType *GifFile, GifRecordType* Type)
-{
-    GifByteType Buf;
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
-
-    if (!IS_READABLE(Private)) {
-        /* This file was NOT open for reading: */
-        GifFile->Error = D_GIF_ERR_NOT_READABLE;
-        return GIF_ERROR;
-    }
-
-    /* coverity[check_return] */
-    if (READ(GifFile, &Buf, 1) != 1) {
-        GifFile->Error = D_GIF_ERR_READ_FAILED;
-        return GIF_ERROR;
-    }
-
-    switch (Buf) {
-      case DESCRIPTOR_INTRODUCER:
-          *Type = IMAGE_DESC_RECORD_TYPE;
-          break;
-      case EXTENSION_INTRODUCER:
-          *Type = EXTENSION_RECORD_TYPE;
-          break;
-      case TERMINATOR_INTRODUCER:
-          *Type = TERMINATE_RECORD_TYPE;
-          break;
-      default:
-          *Type = UNDEFINED_RECORD_TYPE;
-          GifFile->Error = D_GIF_ERR_WRONG_RECORD;
-          return GIF_ERROR;
-    }
-
-    return GIF_OK;
+int DGifGetRecordType(GifFileType *GifFile, GifRecordType *Type) {
+	GifByteType Buf;
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	if (!IS_READABLE(Private)) {
+		/* This file was NOT open for reading: */
+		GifFile->Error = D_GIF_ERR_NOT_READABLE;
+		return GIF_ERROR;
+	}
+
+	/* coverity[check_return] */
+	if (InternalRead(GifFile, &Buf, 1) != 1) {
+		GifFile->Error = D_GIF_ERR_READ_FAILED;
+		return GIF_ERROR;
+	}
+
+	// fprintf(stderr, "### DGifGetRecordType: %02x\n", Buf);
+	switch (Buf) {
+	case DESCRIPTOR_INTRODUCER:
+		*Type = IMAGE_DESC_RECORD_TYPE;
+		break;
+	case EXTENSION_INTRODUCER:
+		*Type = EXTENSION_RECORD_TYPE;
+		break;
+	case TERMINATOR_INTRODUCER:
+		*Type = TERMINATE_RECORD_TYPE;
+		break;
+	default:
+		*Type = UNDEFINED_RECORD_TYPE;
+		GifFile->Error = D_GIF_ERR_WRONG_RECORD;
+		return GIF_ERROR;
+	}
+
+	return GIF_OK;
+}
+
+int DGifGetImageHeader(GifFileType *GifFile) {
+	unsigned int BitsPerPixel;
+	GifByteType Buf[3];
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	if (!IS_READABLE(Private)) {
+		/* This file was NOT open for reading: */
+		GifFile->Error = D_GIF_ERR_NOT_READABLE;
+		return GIF_ERROR;
+	}
+
+	if (DGifGetWord(GifFile, &GifFile->Image.Left) == GIF_ERROR ||
+	    DGifGetWord(GifFile, &GifFile->Image.Top) == GIF_ERROR ||
+	    DGifGetWord(GifFile, &GifFile->Image.Width) == GIF_ERROR ||
+	    DGifGetWord(GifFile, &GifFile->Image.Height) == GIF_ERROR) {
+		return GIF_ERROR;
+	}
+	if (InternalRead(GifFile, Buf, 1) != 1) {
+		GifFile->Error = D_GIF_ERR_READ_FAILED;
+		GifFreeMapObject(GifFile->Image.ColorMap);
+		GifFile->Image.ColorMap = NULL;
+		return GIF_ERROR;
+	}
+	BitsPerPixel = (Buf[0] & 0x07) + 1;
+	GifFile->Image.Interlace = (Buf[0] & 0x40) ? true : false;
+
+	/* Setup the colormap */
+	if (GifFile->Image.ColorMap) {
+		GifFreeMapObject(GifFile->Image.ColorMap);
+		GifFile->Image.ColorMap = NULL;
+	}
+	/* Does this image have local color map? */
+	if (Buf[0] & 0x80) {
+		unsigned int i;
+
+		GifFile->Image.ColorMap =
+		    GifMakeMapObject(1 << BitsPerPixel, NULL);
+		if (GifFile->Image.ColorMap == NULL) {
+			GifFile->Error = D_GIF_ERR_NOT_ENOUGH_MEM;
+			return GIF_ERROR;
+		}
+
+		/* Get the image local color map: */
+		for (i = 0; i < GifFile->Image.ColorMap->ColorCount; i++) {
+			/* coverity[check_return] */
+			if (InternalRead(GifFile, Buf, 3) != 3) {
+				GifFreeMapObject(GifFile->Image.ColorMap);
+				GifFile->Error = D_GIF_ERR_READ_FAILED;
+				GifFile->Image.ColorMap = NULL;
+				return GIF_ERROR;
+			}
+			GifFile->Image.ColorMap->Colors[i].Red = Buf[0];
+			GifFile->Image.ColorMap->Colors[i].Green = Buf[1];
+			GifFile->Image.ColorMap->Colors[i].Blue = Buf[2];
+		}
+	}
+
+	Private->PixelCount =
+	    (long)GifFile->Image.Width * (long)GifFile->Image.Height;
+
+	/* Reset decompress algorithm parameters. */
+	return DGifSetupDecompress(GifFile);
 }
 
 /******************************************************************************
  This routine should be called before any attempt to read an image.
  Note it is assumed the Image desc. header has been read.
 ******************************************************************************/
-int
-DGifGetImageDesc(GifFileType *GifFile)
-{
-    unsigned int BitsPerPixel;
-    GifByteType Buf[3];
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
-    SavedImage *sp;
-
-    if (!IS_READABLE(Private)) {
-        /* This file was NOT open for reading: */
-        GifFile->Error = D_GIF_ERR_NOT_READABLE;
-        return GIF_ERROR;
-    }
-
-    if (DGifGetWord(GifFile, &GifFile->Image.Left) == GIF_ERROR ||
-        DGifGetWord(GifFile, &GifFile->Image.Top) == GIF_ERROR ||
-        DGifGetWord(GifFile, &GifFile->Image.Width) == GIF_ERROR ||
-        DGifGetWord(GifFile, &GifFile->Image.Height) == GIF_ERROR)
-        return GIF_ERROR;
-    if (READ(GifFile, Buf, 1) != 1) {
-        GifFile->Error = D_GIF_ERR_READ_FAILED;
-	GifFreeMapObject(GifFile->Image.ColorMap);
-	GifFile->Image.ColorMap = NULL;
-        return GIF_ERROR;
-    }
-    BitsPerPixel = (Buf[0] & 0x07) + 1;
-    GifFile->Image.Interlace = (Buf[0] & 0x40) ? true : false;
-
-    /* Setup the colormap */
-    if (GifFile->Image.ColorMap) {
-        GifFreeMapObject(GifFile->Image.ColorMap);
-        GifFile->Image.ColorMap = NULL;
-    }
-    /* Does this image have local color map? */
-    if (Buf[0] & 0x80) {
-	unsigned int i;
-
-        GifFile->Image.ColorMap = GifMakeMapObject(1 << BitsPerPixel, NULL);
-        if (GifFile->Image.ColorMap == NULL) {
-            GifFile->Error = D_GIF_ERR_NOT_ENOUGH_MEM;
-            return GIF_ERROR;
-        }
-
-        /* Get the image local color map: */
-        for (i = 0; i < GifFile->Image.ColorMap->ColorCount; i++) {
-	    /* coverity[check_return] */
-            if (READ(GifFile, Buf, 3) != 3) {
-                GifFreeMapObject(GifFile->Image.ColorMap);
-                GifFile->Error = D_GIF_ERR_READ_FAILED;
-                GifFile->Image.ColorMap = NULL;
-                return GIF_ERROR;
-            }
-            GifFile->Image.ColorMap->Colors[i].Red = Buf[0];
-            GifFile->Image.ColorMap->Colors[i].Green = Buf[1];
-            GifFile->Image.ColorMap->Colors[i].Blue = Buf[2];
-        }
-    }
-
-    if (GifFile->SavedImages) {
-        SavedImage* new_saved_images =
-            (SavedImage *)reallocarray(GifFile->SavedImages,
-                            (GifFile->ImageCount + 1), sizeof(SavedImage));
-        if (new_saved_images == NULL) {
-            GifFile->Error = D_GIF_ERR_NOT_ENOUGH_MEM;
-            return GIF_ERROR;
-        }
-        GifFile->SavedImages = new_saved_images;
-    } else {
-        if ((GifFile->SavedImages =
-             (SavedImage *) malloc(sizeof(SavedImage))) == NULL) {
-            GifFile->Error = D_GIF_ERR_NOT_ENOUGH_MEM;
-            return GIF_ERROR;
-        }
-    }
-
-    sp = &GifFile->SavedImages[GifFile->ImageCount];
-    memcpy(&sp->ImageDesc, &GifFile->Image, sizeof(GifImageDesc));
-    if (GifFile->Image.ColorMap != NULL) {
-        sp->ImageDesc.ColorMap = GifMakeMapObject(
-                                 GifFile->Image.ColorMap->ColorCount,
-                                 GifFile->Image.ColorMap->Colors);
-        if (sp->ImageDesc.ColorMap == NULL) {
-            GifFile->Error = D_GIF_ERR_NOT_ENOUGH_MEM;
-            return GIF_ERROR;
-        }
-    }
-    sp->RasterBits = (unsigned char *)NULL;
-    sp->ExtensionBlockCount = 0;
-    sp->ExtensionBlocks = (ExtensionBlock *) NULL;
-
-    GifFile->ImageCount++;
-
-    Private->PixelCount = (long)GifFile->Image.Width *
-       (long)GifFile->Image.Height;
-
-    /* Reset decompress algorithm parameters. */
-    return DGifSetupDecompress(GifFile);
+int DGifGetImageDesc(GifFileType *GifFile) {
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+	SavedImage *sp;
+
+	if (!IS_READABLE(Private)) {
+		/* This file was NOT open for reading: */
+		GifFile->Error = D_GIF_ERR_NOT_READABLE;
+		return GIF_ERROR;
+	}
+
+	if (DGifGetImageHeader(GifFile) == GIF_ERROR) {
+		return GIF_ERROR;
+	}
+
+	if (GifFile->SavedImages) {
+		SavedImage *new_saved_images = (SavedImage *)reallocarray(
+		    GifFile->SavedImages, (GifFile->ImageCount + 1),
+		    sizeof(SavedImage));
+		if (new_saved_images == NULL) {
+			GifFile->Error = D_GIF_ERR_NOT_ENOUGH_MEM;
+			return GIF_ERROR;
+		}
+		GifFile->SavedImages = new_saved_images;
+	} else {
+		if ((GifFile->SavedImages =
+		         (SavedImage *)malloc(sizeof(SavedImage))) == NULL) {
+			GifFile->Error = D_GIF_ERR_NOT_ENOUGH_MEM;
+			return GIF_ERROR;
+		}
+	}
+
+	sp = &GifFile->SavedImages[GifFile->ImageCount];
+	memcpy(&sp->ImageDesc, &GifFile->Image, sizeof(GifImageDesc));
+	if (GifFile->Image.ColorMap != NULL) {
+		sp->ImageDesc.ColorMap =
+		    GifMakeMapObject(GifFile->Image.ColorMap->ColorCount,
+		                     GifFile->Image.ColorMap->Colors);
+		if (sp->ImageDesc.ColorMap == NULL) {
+			GifFile->Error = D_GIF_ERR_NOT_ENOUGH_MEM;
+			return GIF_ERROR;
+		}
+	}
+	sp->RasterBits = (unsigned char *)NULL;
+	sp->ExtensionBlockCount = 0;
+	sp->ExtensionBlocks = (ExtensionBlock *)NULL;
+
+	GifFile->ImageCount++;
+
+	return GIF_OK;
 }
 
 /******************************************************************************
  Get one full scanned line (Line) of length LineLen from GIF file.
 ******************************************************************************/
-int
-DGifGetLine(GifFileType *GifFile, GifPixelType *Line, int LineLen)
-{
-    GifByteType *Dummy;
-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;
-
-    if (!IS_READABLE(Private)) {
-        /* This file was NOT open for reading: */
-        GifFile->Error = D_GIF_ERR_NOT_READABLE;
-        return GIF_ERROR;
-    }
-
-    if (!LineLen)
-        LineLen = GifFile->Image.Width;
-
-    if ((Private->PixelCount -= LineLen) > 0xffff0000UL) {
-        GifFile->Error = D_GIF_ERR_DATA_TOO_BIG;
-        return GIF_ERROR;
-    }
-
-    if (DGifDecompressLine(GifFile, Line, LineLen) == GIF_OK) {
-        if (Private->PixelCount == 0) {
-            /* We probably won't be called any more, so let's clean up
-             * everything before we return: need to flush out all the
-             * rest of image until an empty block (size 0)
-             * detected. We use GetCodeNext.
-	     */
-            do
-                if (DGifGetCodeNext(GifFile, &Dummy) == GIF_ERROR)
-                    return GIF_ERROR;
-            while (Dummy != NULL) ;
-        }
-        return GIF_OK;
-    } else
-        return GIF_ERROR;
+int DGifGetLine(GifFileType *GifFile, GifPixelType *Line, int LineLen) {
+	GifByteType *Dummy;
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	if (!IS_READABLE(Private)) {
+		/* This file was NOT open for reading: */
+		GifFile->Error = D_GIF_ERR_NOT_READABLE;
+		return GIF_ERROR;
+	}
+
+	if (!LineLen) {
+		LineLen = GifFile->Image.Width;
+	}
+
+	if ((Private->PixelCount -= LineLen) > 0xffff0000UL) {
+		GifFile->Error = D_GIF_ERR_DATA_TOO_BIG;
+		return GIF_ERROR;
+	}
+
+	if (DGifDecompressLine(GifFile, Line, LineLen) == GIF_OK) {
+		if (Private->PixelCount == 0) {
+			/* We probably won't be called any more, so let's clean
+			 * up everything before we return: need to flush out all
+			 * the rest of image until an empty block (size 0)
+			 * detected. We use GetCodeNext.
+			 */
+			do {
+				if (DGifGetCodeNext(GifFile, &Dummy) ==
+				    GIF_ERROR) {
+					return GIF_ERROR;
+				}
+			} while (Dummy != NULL);
+		}
+		return GIF_OK;
+	} else {
+		return GIF_ERROR;
+	}
 }
 
 /******************************************************************************
  Put one pixel (Pixel) into GIF file.
 ******************************************************************************/
-int
-DGifGetPixel(GifFileType *GifFile, GifPixelType Pixel)
-{
-    GifByteType *Dummy;
-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;
-
-    if (!IS_READABLE(Private)) {
-        /* This file was NOT open for reading: */
-        GifFile->Error = D_GIF_ERR_NOT_READABLE;
-        return GIF_ERROR;
-    }
-    if (--Private->PixelCount > 0xffff0000UL)
-    {
-        GifFile->Error = D_GIF_ERR_DATA_TOO_BIG;
-        return GIF_ERROR;
-    }
-
-    if (DGifDecompressLine(GifFile, &Pixel, 1) == GIF_OK) {
-        if (Private->PixelCount == 0) {
-            /* We probably won't be called any more, so let's clean up
-             * everything before we return: need to flush out all the
-             * rest of image until an empty block (size 0)
-             * detected. We use GetCodeNext.
-	     */
-            do
-                if (DGifGetCodeNext(GifFile, &Dummy) == GIF_ERROR)
-                    return GIF_ERROR;
-            while (Dummy != NULL) ;
-        }
-        return GIF_OK;
-    } else
-        return GIF_ERROR;
+int DGifGetPixel(GifFileType *GifFile, GifPixelType Pixel) {
+	GifByteType *Dummy;
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	if (!IS_READABLE(Private)) {
+		/* This file was NOT open for reading: */
+		GifFile->Error = D_GIF_ERR_NOT_READABLE;
+		return GIF_ERROR;
+	}
+	if (--Private->PixelCount > 0xffff0000UL) {
+		GifFile->Error = D_GIF_ERR_DATA_TOO_BIG;
+		return GIF_ERROR;
+	}
+
+	if (DGifDecompressLine(GifFile, &Pixel, 1) == GIF_OK) {
+		if (Private->PixelCount == 0) {
+			/* We probably won't be called any more, so let's clean
+			 * up everything before we return: need to flush out all
+			 * the rest of image until an empty block (size 0)
+			 * detected. We use GetCodeNext.
+			 */
+			do {
+				if (DGifGetCodeNext(GifFile, &Dummy) ==
+				    GIF_ERROR) {
+					return GIF_ERROR;
+				}
+			} while (Dummy != NULL);
+		}
+		return GIF_OK;
+	} else {
+		return GIF_ERROR;
+	}
 }
 
 /******************************************************************************
@@ -519,26 +563,28 @@ DGifGetPixel(GifFileType *GifFile, GifPixelType Pixel)
  The Extension should NOT be freed by the user (not dynamically allocated).
  Note it is assumed the Extension description header has been read.
 ******************************************************************************/
-int
-DGifGetExtension(GifFileType *GifFile, int *ExtCode, GifByteType **Extension)
-{
-    GifByteType Buf;
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
-
-    if (!IS_READABLE(Private)) {
-        /* This file was NOT open for reading: */
-        GifFile->Error = D_GIF_ERR_NOT_READABLE;
-        return GIF_ERROR;
-    }
-
-    /* coverity[check_return] */
-    if (READ(GifFile, &Buf, 1) != 1) {
-        GifFile->Error = D_GIF_ERR_READ_FAILED;
-        return GIF_ERROR;
-    }
-    *ExtCode = Buf;
-
-    return DGifGetExtensionNext(GifFile, Extension);
+int DGifGetExtension(GifFileType *GifFile, int *ExtCode,
+                     GifByteType **Extension) {
+	GifByteType Buf;
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	// fprintf(stderr, "### -> DGifGetExtension:\n");
+	if (!IS_READABLE(Private)) {
+		/* This file was NOT open for reading: */
+		GifFile->Error = D_GIF_ERR_NOT_READABLE;
+		return GIF_ERROR;
+	}
+
+	/* coverity[check_return] */
+	if (InternalRead(GifFile, &Buf, 1) != 1) {
+		GifFile->Error = D_GIF_ERR_READ_FAILED;
+		return GIF_ERROR;
+	}
+	*ExtCode = Buf;
+	// fprintf(stderr, "### <- DGifGetExtension: %02x, about to call
+	// next\n", Buf);
+
+	return DGifGetExtensionNext(GifFile, Extension);
 }
 
 /******************************************************************************
@@ -546,28 +592,32 @@ DGifGetExtension(GifFileType *GifFile, int *ExtCode, GifByteType **Extension)
  routine should be called until NULL Extension is returned.
  The Extension should NOT be freed by the user (not dynamically allocated).
 ******************************************************************************/
-int
-DGifGetExtensionNext(GifFileType *GifFile, GifByteType ** Extension)
-{
-    GifByteType Buf;
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
-
-    if (READ(GifFile, &Buf, 1) != 1) {
-        GifFile->Error = D_GIF_ERR_READ_FAILED;
-        return GIF_ERROR;
-    }
-    if (Buf > 0) {
-        *Extension = Private->Buf;    /* Use private unused buffer. */
-        (*Extension)[0] = Buf;  /* Pascal strings notation (pos. 0 is len.). */
-	/* coverity[tainted_data,check_return] */
-        if (READ(GifFile, &((*Extension)[1]), Buf) != Buf) {
-            GifFile->Error = D_GIF_ERR_READ_FAILED;
-            return GIF_ERROR;
-        }
-    } else
-        *Extension = NULL;
-
-    return GIF_OK;
+int DGifGetExtensionNext(GifFileType *GifFile, GifByteType **Extension) {
+	GifByteType Buf;
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	// fprintf(stderr, "### -> DGifGetExtensionNext\n");
+	if (InternalRead(GifFile, &Buf, 1) != 1) {
+		GifFile->Error = D_GIF_ERR_READ_FAILED;
+		return GIF_ERROR;
+	}
+	// fprintf(stderr, "### DGifGetExtensionNext sees %d\n", Buf);
+
+	if (Buf > 0) {
+		*Extension = Private->Buf; /* Use private unused buffer. */
+		(*Extension)[0] =
+		    Buf; /* Pascal strings notation (pos. 0 is len.). */
+		         /* coverity[tainted_data,check_return] */
+		if (InternalRead(GifFile, &((*Extension)[1]), Buf) != Buf) {
+			GifFile->Error = D_GIF_ERR_READ_FAILED;
+			return GIF_ERROR;
+		}
+	} else {
+		*Extension = NULL;
+	}
+	// fprintf(stderr, "### <- DGifGetExtensionNext: %p\n", Extension);
+
+	return GIF_OK;
 }
 
 /******************************************************************************
@@ -575,120 +625,126 @@ DGifGetExtensionNext(GifFileType *GifFile, GifByteType ** Extension)
 ******************************************************************************/
 
 int DGifExtensionToGCB(const size_t GifExtensionLength,
-		       const GifByteType *GifExtension,
-		       GraphicsControlBlock *GCB)
-{
-    if (GifExtensionLength != 4) {
-	return GIF_ERROR;
-    }
-
-    GCB->DisposalMode = (GifExtension[0] >> 2) & 0x07;
-    GCB->UserInputFlag = (GifExtension[0] & 0x02) != 0;
-    GCB->DelayTime = UNSIGNED_LITTLE_ENDIAN(GifExtension[1], GifExtension[2]);
-    if (GifExtension[0] & 0x01)
-	GCB->TransparentColor = (int)GifExtension[3];
-    else
-	GCB->TransparentColor = NO_TRANSPARENT_COLOR;
-
-    return GIF_OK;
+                       const GifByteType *GifExtension,
+                       GraphicsControlBlock *GCB) {
+	if (GifExtensionLength != 4) {
+		return GIF_ERROR;
+	}
+
+	GCB->DisposalMode = (GifExtension[0] >> 2) & 0x07;
+	GCB->UserInputFlag = (GifExtension[0] & 0x02) != 0;
+	GCB->DelayTime =
+	    UNSIGNED_LITTLE_ENDIAN(GifExtension[1], GifExtension[2]);
+	if (GifExtension[0] & 0x01) {
+		GCB->TransparentColor = (int)GifExtension[3];
+	} else {
+		GCB->TransparentColor = NO_TRANSPARENT_COLOR;
+	}
+
+	return GIF_OK;
 }
 
 /******************************************************************************
  Extract the Graphics Control Block for a saved image, if it exists.
 ******************************************************************************/
 
-int DGifSavedExtensionToGCB(GifFileType *GifFile,
-			    int ImageIndex, GraphicsControlBlock *GCB)
-{
-    int i;
+int DGifSavedExtensionToGCB(GifFileType *GifFile, int ImageIndex,
+                            GraphicsControlBlock *GCB) {
+	int i;
 
-    if (ImageIndex < 0 || ImageIndex > GifFile->ImageCount - 1)
-	return GIF_ERROR;
+	if (ImageIndex < 0 || ImageIndex > GifFile->ImageCount - 1) {
+		return GIF_ERROR;
+	}
 
-    GCB->DisposalMode = DISPOSAL_UNSPECIFIED;
-    GCB->UserInputFlag = false;
-    GCB->DelayTime = 0;
-    GCB->TransparentColor = NO_TRANSPARENT_COLOR;
+	GCB->DisposalMode = DISPOSAL_UNSPECIFIED;
+	GCB->UserInputFlag = false;
+	GCB->DelayTime = 0;
+	GCB->TransparentColor = NO_TRANSPARENT_COLOR;
 
-    for (i = 0; i < GifFile->SavedImages[ImageIndex].ExtensionBlockCount; i++) {
-	ExtensionBlock *ep = &GifFile->SavedImages[ImageIndex].ExtensionBlocks[i];
-	if (ep->Function == GRAPHICS_EXT_FUNC_CODE)
-	    return DGifExtensionToGCB(ep->ByteCount, ep->Bytes, GCB);
-    }
+	for (i = 0; i < GifFile->SavedImages[ImageIndex].ExtensionBlockCount;
+	     i++) {
+		ExtensionBlock *ep =
+		    &GifFile->SavedImages[ImageIndex].ExtensionBlocks[i];
+		if (ep->Function == GRAPHICS_EXT_FUNC_CODE) {
+			return DGifExtensionToGCB(ep->ByteCount, ep->Bytes,
+			                          GCB);
+		}
+	}
 
-    return GIF_ERROR;
+	return GIF_ERROR;
 }
 
 /******************************************************************************
  This routine should be called last, to close the GIF file.
 ******************************************************************************/
-int
-DGifCloseFile(GifFileType *GifFile, int *ErrorCode)
-{
-    GifFilePrivateType *Private;
-
-    if (GifFile == NULL || GifFile->Private == NULL)
-        return GIF_ERROR;
-
-    if (GifFile->Image.ColorMap) {
-        GifFreeMapObject(GifFile->Image.ColorMap);
-        GifFile->Image.ColorMap = NULL;
-    }
-
-    if (GifFile->SColorMap) {
-        GifFreeMapObject(GifFile->SColorMap);
-        GifFile->SColorMap = NULL;
-    }
-
-    if (GifFile->SavedImages) {
-        GifFreeSavedImages(GifFile);
-        GifFile->SavedImages = NULL;
-    }
-
-    GifFreeExtensions(&GifFile->ExtensionBlockCount, &GifFile->ExtensionBlocks);
-
-    Private = (GifFilePrivateType *) GifFile->Private;
-
-    if (!IS_READABLE(Private)) {
-        /* This file was NOT open for reading: */
-	if (ErrorCode != NULL)
-	    *ErrorCode = D_GIF_ERR_NOT_READABLE;
-	free((char *)GifFile->Private);
-	free(GifFile);
-        return GIF_ERROR;
-    }
+int DGifCloseFile(GifFileType *GifFile, int *ErrorCode) {
+	GifFilePrivateType *Private;
+
+	if (GifFile == NULL || GifFile->Private == NULL) {
+		return GIF_ERROR;
+	}
+
+	if (GifFile->Image.ColorMap) {
+		GifFreeMapObject(GifFile->Image.ColorMap);
+		GifFile->Image.ColorMap = NULL;
+	}
+
+	if (GifFile->SColorMap) {
+		GifFreeMapObject(GifFile->SColorMap);
+		GifFile->SColorMap = NULL;
+	}
+
+	if (GifFile->SavedImages) {
+		GifFreeSavedImages(GifFile);
+		GifFile->SavedImages = NULL;
+	}
+
+	GifFreeExtensions(&GifFile->ExtensionBlockCount,
+	                  &GifFile->ExtensionBlocks);
+
+	Private = (GifFilePrivateType *)GifFile->Private;
+
+	if (!IS_READABLE(Private)) {
+		/* This file was NOT open for reading: */
+		if (ErrorCode != NULL) {
+			*ErrorCode = D_GIF_ERR_NOT_READABLE;
+		}
+		free((char *)GifFile->Private);
+		free(GifFile);
+		return GIF_ERROR;
+	}
+
+	if (Private->File && (fclose(Private->File) != 0)) {
+		if (ErrorCode != NULL) {
+			*ErrorCode = D_GIF_ERR_CLOSE_FAILED;
+		}
+		free((char *)GifFile->Private);
+		free(GifFile);
+		return GIF_ERROR;
+	}
 
-    if (Private->File && (fclose(Private->File) != 0)) {
-	if (ErrorCode != NULL)
-	    *ErrorCode = D_GIF_ERR_CLOSE_FAILED;
 	free((char *)GifFile->Private);
 	free(GifFile);
-        return GIF_ERROR;
-    }
-
-    free((char *)GifFile->Private);
-    free(GifFile);
-    if (ErrorCode != NULL)
-	*ErrorCode = D_GIF_SUCCEEDED;
-    return GIF_OK;
+	if (ErrorCode != NULL) {
+		*ErrorCode = D_GIF_SUCCEEDED;
+	}
+	return GIF_OK;
 }
 
 /******************************************************************************
  Get 2 bytes (word) from the given file:
 ******************************************************************************/
-static int
-DGifGetWord(GifFileType *GifFile, GifWord *Word)
-{
-    unsigned char c[2];
-
-    /* coverity[check_return] */
-    if (READ(GifFile, c, 2) != 2) {
-        GifFile->Error = D_GIF_ERR_READ_FAILED;
-        return GIF_ERROR;
-    }
-
-    *Word = (GifWord)UNSIGNED_LITTLE_ENDIAN(c[0], c[1]);
-    return GIF_OK;
+static int DGifGetWord(GifFileType *GifFile, GifWord *Word) {
+	unsigned char c[2];
+
+	/* coverity[check_return] */
+	if (InternalRead(GifFile, c, 2) != 2) {
+		GifFile->Error = D_GIF_ERR_READ_FAILED;
+		return GIF_ERROR;
+	}
+
+	*Word = (GifWord)UNSIGNED_LITTLE_ENDIAN(c[0], c[1]);
+	return GIF_OK;
 }
 
 /******************************************************************************
@@ -698,20 +754,18 @@ DGifGetWord(GifFileType *GifFile, GifWord *Word)
  to DGifGetCodeNext, until NULL block is returned.
  The block should NOT be freed by the user (not dynamically allocated).
 ******************************************************************************/
-int
-DGifGetCode(GifFileType *GifFile, int *CodeSize, GifByteType **CodeBlock)
-{
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+int DGifGetCode(GifFileType *GifFile, int *CodeSize, GifByteType **CodeBlock) {
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
-    if (!IS_READABLE(Private)) {
-        /* This file was NOT open for reading: */
-        GifFile->Error = D_GIF_ERR_NOT_READABLE;
-        return GIF_ERROR;
-    }
+	if (!IS_READABLE(Private)) {
+		/* This file was NOT open for reading: */
+		GifFile->Error = D_GIF_ERR_NOT_READABLE;
+		return GIF_ERROR;
+	}
 
-    *CodeSize = Private->BitsPerPixel;
+	*CodeSize = Private->BitsPerPixel;
 
-    return DGifGetCodeNext(GifFile, CodeBlock);
+	return DGifGetCodeNext(GifFile, CodeBlock);
 }
 
 /******************************************************************************
@@ -719,77 +773,79 @@ DGifGetCode(GifFileType *GifFile, int *CodeSize, GifByteType **CodeBlock)
  called until NULL block is returned.
  The block should NOT be freed by the user (not dynamically allocated).
 ******************************************************************************/
-int
-DGifGetCodeNext(GifFileType *GifFile, GifByteType **CodeBlock)
-{
-    GifByteType Buf;
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
-
-    /* coverity[tainted_data_argument] */
-    /* coverity[check_return] */
-    if (READ(GifFile, &Buf, 1) != 1) {
-        GifFile->Error = D_GIF_ERR_READ_FAILED;
-        return GIF_ERROR;
-    }
-
-    /* coverity[lower_bounds] */
-    if (Buf > 0) {
-        *CodeBlock = Private->Buf;    /* Use private unused buffer. */
-        (*CodeBlock)[0] = Buf;  /* Pascal strings notation (pos. 0 is len.). */
-	/* coverity[tainted_data] */
-        if (READ(GifFile, &((*CodeBlock)[1]), Buf) != Buf) {
-            GifFile->Error = D_GIF_ERR_READ_FAILED;
-            return GIF_ERROR;
-        }
-    } else {
-        *CodeBlock = NULL;
-        Private->Buf[0] = 0;    /* Make sure the buffer is empty! */
-        Private->PixelCount = 0;    /* And local info. indicate image read. */
-    }
-
-    return GIF_OK;
+int DGifGetCodeNext(GifFileType *GifFile, GifByteType **CodeBlock) {
+	GifByteType Buf;
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	/* coverity[tainted_data_argument] */
+	/* coverity[check_return] */
+	if (InternalRead(GifFile, &Buf, 1) != 1) {
+		GifFile->Error = D_GIF_ERR_READ_FAILED;
+		return GIF_ERROR;
+	}
+
+	/* coverity[lower_bounds] */
+	if (Buf > 0) {
+		*CodeBlock = Private->Buf; /* Use private unused buffer. */
+		(*CodeBlock)[0] =
+		    Buf; /* Pascal strings notation (pos. 0 is len.). */
+		         /* coverity[tainted_data] */
+		if (InternalRead(GifFile, &((*CodeBlock)[1]), Buf) != Buf) {
+			GifFile->Error = D_GIF_ERR_READ_FAILED;
+			return GIF_ERROR;
+		}
+	} else {
+		*CodeBlock = NULL;
+		Private->Buf[0] = 0; /* Make sure the buffer is empty! */
+		Private->PixelCount =
+		    0; /* And local info. indicate image read. */
+	}
+
+	return GIF_OK;
 }
 
 /******************************************************************************
  Setup the LZ decompression for this image:
 ******************************************************************************/
-static int
-DGifSetupDecompress(GifFileType *GifFile)
-{
-    int i, BitsPerPixel;
-    GifByteType CodeSize;
-    GifPrefixType *Prefix;
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
-
-    /* coverity[check_return] */
-    if (READ(GifFile, &CodeSize, 1) < 1) {    /* Read Code size from file. */
-	return GIF_ERROR;    /* Failed to read Code size. */
-    }
-    BitsPerPixel = CodeSize;
-
-    /* this can only happen on a severely malformed GIF */
-    if (BitsPerPixel > 8) {
-	GifFile->Error = D_GIF_ERR_READ_FAILED;	/* somewhat bogus error code */
-	return GIF_ERROR;    /* Failed to read Code size. */
-    }
-
-    Private->Buf[0] = 0;    /* Input Buffer empty. */
-    Private->BitsPerPixel = BitsPerPixel;
-    Private->ClearCode = (1 << BitsPerPixel);
-    Private->EOFCode = Private->ClearCode + 1;
-    Private->RunningCode = Private->EOFCode + 1;
-    Private->RunningBits = BitsPerPixel + 1;    /* Number of bits per code. */
-    Private->MaxCode1 = 1 << Private->RunningBits;    /* Max. code + 1. */
-    Private->StackPtr = 0;    /* No pixels on the pixel stack. */
-    Private->LastCode = NO_SUCH_CODE;
-    Private->CrntShiftState = 0;    /* No information in CrntShiftDWord. */
-    Private->CrntShiftDWord = 0;
-
-    Prefix = Private->Prefix;
-    for (i = 0; i <= LZ_MAX_CODE; i++)
-        Prefix[i] = NO_SUCH_CODE;
-
-    return GIF_OK;
+static int DGifSetupDecompress(GifFileType *GifFile) {
+	int i, BitsPerPixel;
+	GifByteType CodeSize;
+	GifPrefixType *Prefix;
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	/* coverity[check_return] */
+	if (InternalRead(GifFile, &CodeSize, 1) <
+	    1) { /* Read Code size from file. */
+		GifFile->Error = D_GIF_ERR_READ_FAILED;
+		return GIF_ERROR; /* Failed to read Code size. */
+	}
+	BitsPerPixel = CodeSize;
+
+	/* this can only happen on a severely malformed GIF */
+	if (BitsPerPixel > 8) {
+		GifFile->Error =
+		    D_GIF_ERR_READ_FAILED; /* somewhat bogus error code */
+		return GIF_ERROR;          /* Failed to read Code size. */
+	}
+
+	Private->Buf[0] = 0; /* Input Buffer empty. */
+	Private->BitsPerPixel = BitsPerPixel;
+	Private->ClearCode = (1 << BitsPerPixel);
+	Private->EOFCode = Private->ClearCode + 1;
+	Private->RunningCode = Private->EOFCode + 1;
+	Private->RunningBits = BitsPerPixel + 1; /* Number of bits per code. */
+	Private->MaxCode1 = 1 << Private->RunningBits; /* Max. code + 1. */
+	Private->StackPtr = 0; /* No pixels on the pixel stack. */
+	Private->LastCode = NO_SUCH_CODE;
+	Private->CrntShiftState = 0; /* No information in CrntShiftDWord. */
+	Private->CrntShiftDWord = 0;
+
+	Prefix = Private->Prefix;
+	for (i = 0; i <= LZ_MAX_CODE; i++) {
+		Prefix[i] = NO_SUCH_CODE;
+	}
+
+	return GIF_OK;
 }
 
 /******************************************************************************
@@ -798,127 +854,149 @@ DGifSetupDecompress(GifFileType *GifFile)
  This routine can be called few times (one per scan line, for example), in
  order the complete the whole image.
 ******************************************************************************/
-static int
-DGifDecompressLine(GifFileType *GifFile, GifPixelType *Line, int LineLen)
-{
-    int i = 0;
-    int j, CrntCode, EOFCode, ClearCode, CrntPrefix, LastCode, StackPtr;
-    GifByteType *Stack, *Suffix;
-    GifPrefixType *Prefix;
-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;
-
-    StackPtr = Private->StackPtr;
-    Prefix = Private->Prefix;
-    Suffix = Private->Suffix;
-    Stack = Private->Stack;
-    EOFCode = Private->EOFCode;
-    ClearCode = Private->ClearCode;
-    LastCode = Private->LastCode;
-
-    if (StackPtr > LZ_MAX_CODE) {
-        return GIF_ERROR;
-    }
-
-    if (StackPtr != 0) {
-        /* Let pop the stack off before continueing to read the GIF file: */
-        while (StackPtr != 0 && i < LineLen)
-            Line[i++] = Stack[--StackPtr];
-    }
-
-    while (i < LineLen) {    /* Decode LineLen items. */
-        if (DGifDecompressInput(GifFile, &CrntCode) == GIF_ERROR)
-            return GIF_ERROR;
-
-        if (CrntCode == EOFCode) {
-            /* Note however that usually we will not be here as we will stop
-             * decoding as soon as we got all the pixel, or EOF code will
-             * not be read at all, and DGifGetLine/Pixel clean everything.  */
-	    GifFile->Error = D_GIF_ERR_EOF_TOO_SOON;
-	    return GIF_ERROR;
-        } else if (CrntCode == ClearCode) {
-            /* We need to start over again: */
-            for (j = 0; j <= LZ_MAX_CODE; j++)
-                Prefix[j] = NO_SUCH_CODE;
-            Private->RunningCode = Private->EOFCode + 1;
-            Private->RunningBits = Private->BitsPerPixel + 1;
-            Private->MaxCode1 = 1 << Private->RunningBits;
-            LastCode = Private->LastCode = NO_SUCH_CODE;
-        } else {
-            /* Its regular code - if in pixel range simply add it to output
-             * stream, otherwise trace to codes linked list until the prefix
-             * is in pixel range: */
-            if (CrntCode < ClearCode) {
-                /* This is simple - its pixel scalar, so add it to output: */
-                Line[i++] = CrntCode;
-            } else {
-                /* Its a code to needed to be traced: trace the linked list
-                 * until the prefix is a pixel, while pushing the suffix
-                 * pixels on our stack. If we done, pop the stack in reverse
-                 * (thats what stack is good for!) order to output.  */
-                if (Prefix[CrntCode] == NO_SUCH_CODE) {
-                    CrntPrefix = LastCode;
-
-                    /* Only allowed if CrntCode is exactly the running code:
-                     * In that case CrntCode = XXXCode, CrntCode or the
-                     * prefix code is last code and the suffix char is
-                     * exactly the prefix of last code! */
-                    if (CrntCode == Private->RunningCode - 2) {
-                        Suffix[Private->RunningCode - 2] =
-                           Stack[StackPtr++] = DGifGetPrefixChar(Prefix,
-                                                                 LastCode,
-                                                                 ClearCode);
-                    } else {
-                        Suffix[Private->RunningCode - 2] =
-                           Stack[StackPtr++] = DGifGetPrefixChar(Prefix,
-                                                                 CrntCode,
-                                                                 ClearCode);
-                    }
-                } else
-                    CrntPrefix = CrntCode;
-
-                /* Now (if image is O.K.) we should not get a NO_SUCH_CODE
-                 * during the trace. As we might loop forever, in case of
-                 * defective image, we use StackPtr as loop counter and stop
-                 * before overflowing Stack[]. */
-                while (StackPtr < LZ_MAX_CODE &&
-                       CrntPrefix > ClearCode && CrntPrefix <= LZ_MAX_CODE) {
-                    Stack[StackPtr++] = Suffix[CrntPrefix];
-                    CrntPrefix = Prefix[CrntPrefix];
-                }
-                if (StackPtr >= LZ_MAX_CODE || CrntPrefix > LZ_MAX_CODE) {
-                    GifFile->Error = D_GIF_ERR_IMAGE_DEFECT;
-                    return GIF_ERROR;
-                }
-                /* Push the last character on stack: */
-                Stack[StackPtr++] = CrntPrefix;
-
-                /* Now lets pop all the stack into output: */
-                while (StackPtr != 0 && i < LineLen)
-                    Line[i++] = Stack[--StackPtr];
-            }
-            if (LastCode != NO_SUCH_CODE && Prefix[Private->RunningCode - 2] == NO_SUCH_CODE) {
-                Prefix[Private->RunningCode - 2] = LastCode;
-
-                if (CrntCode == Private->RunningCode - 2) {
-                    /* Only allowed if CrntCode is exactly the running code:
-                     * In that case CrntCode = XXXCode, CrntCode or the
-                     * prefix code is last code and the suffix char is
-                     * exactly the prefix of last code! */
-                    Suffix[Private->RunningCode - 2] =
-                       DGifGetPrefixChar(Prefix, LastCode, ClearCode);
-                } else {
-                    Suffix[Private->RunningCode - 2] =
-                       DGifGetPrefixChar(Prefix, CrntCode, ClearCode);
-                }
-            }
-            LastCode = CrntCode;
-        }
-    }
-
-    Private->LastCode = LastCode;
-    Private->StackPtr = StackPtr;
-
-    return GIF_OK;
+static int DGifDecompressLine(GifFileType *GifFile, GifPixelType *Line,
+                              int LineLen) {
+	int i = 0;
+	int j, CrntCode, EOFCode, ClearCode, CrntPrefix, LastCode, StackPtr;
+	GifByteType *Stack, *Suffix;
+	GifPrefixType *Prefix;
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	StackPtr = Private->StackPtr;
+	Prefix = Private->Prefix;
+	Suffix = Private->Suffix;
+	Stack = Private->Stack;
+	EOFCode = Private->EOFCode;
+	ClearCode = Private->ClearCode;
+	LastCode = Private->LastCode;
+
+	if (StackPtr > LZ_MAX_CODE) {
+		return GIF_ERROR;
+	}
+
+	if (StackPtr != 0) {
+		/* Let pop the stack off before continueing to read the GIF
+		 * file: */
+		while (StackPtr != 0 && i < LineLen) {
+			Line[i++] = Stack[--StackPtr];
+		}
+	}
+
+	while (i < LineLen) { /* Decode LineLen items. */
+		if (DGifDecompressInput(GifFile, &CrntCode) == GIF_ERROR) {
+			return GIF_ERROR;
+		}
+
+		if (CrntCode == EOFCode) {
+			/* Note however that usually we will not be here as we
+			 * will stop decoding as soon as we got all the pixel,
+			 * or EOF code will not be read at all, and
+			 * DGifGetLine/Pixel clean everything.  */
+			GifFile->Error = D_GIF_ERR_EOF_TOO_SOON;
+			return GIF_ERROR;
+		} else if (CrntCode == ClearCode) {
+			/* We need to start over again: */
+			for (j = 0; j <= LZ_MAX_CODE; j++) {
+				Prefix[j] = NO_SUCH_CODE;
+			}
+			Private->RunningCode = Private->EOFCode + 1;
+			Private->RunningBits = Private->BitsPerPixel + 1;
+			Private->MaxCode1 = 1 << Private->RunningBits;
+			LastCode = Private->LastCode = NO_SUCH_CODE;
+		} else {
+			/* Its regular code - if in pixel range simply add it to
+			 * output stream, otherwise trace to codes linked list
+			 * until the prefix is in pixel range: */
+			if (CrntCode < ClearCode) {
+				/* This is simple - its pixel scalar, so add it
+				 * to output: */
+				Line[i++] = CrntCode;
+			} else {
+				/* Its a code to needed to be traced: trace the
+				 * linked list until the prefix is a pixel,
+				 * while pushing the suffix pixels on our stack.
+				 * If we done, pop the stack in reverse (thats
+				 * what stack is good for!) order to output.  */
+				if (Prefix[CrntCode] == NO_SUCH_CODE) {
+					CrntPrefix = LastCode;
+
+					/* Only allowed if CrntCode is exactly
+					 * the running code: In that case
+					 * CrntCode = XXXCode, CrntCode or the
+					 * prefix code is last code and the
+					 * suffix char is exactly the prefix of
+					 * last code! */
+					if (CrntCode ==
+					    Private->RunningCode - 2) {
+						Suffix[Private->RunningCode -
+						       2] = Stack[StackPtr++] =
+						    DGifGetPrefixChar(
+						        Prefix, LastCode,
+						        ClearCode);
+					} else {
+						Suffix[Private->RunningCode -
+						       2] = Stack[StackPtr++] =
+						    DGifGetPrefixChar(
+						        Prefix, CrntCode,
+						        ClearCode);
+					}
+				} else {
+					CrntPrefix = CrntCode;
+				}
+
+				/* Now (if image is O.K.) we should not get a
+				 * NO_SUCH_CODE during the trace. As we might
+				 * loop forever, in case of defective image, we
+				 * use StackPtr as loop counter and stop before
+				 * overflowing Stack[]. */
+				while (StackPtr < LZ_MAX_CODE &&
+				       CrntPrefix > ClearCode &&
+				       CrntPrefix <= LZ_MAX_CODE) {
+					Stack[StackPtr++] = Suffix[CrntPrefix];
+					CrntPrefix = Prefix[CrntPrefix];
+				}
+				if (StackPtr >= LZ_MAX_CODE ||
+				    CrntPrefix > LZ_MAX_CODE) {
+					GifFile->Error = D_GIF_ERR_IMAGE_DEFECT;
+					return GIF_ERROR;
+				}
+				/* Push the last character on stack: */
+				Stack[StackPtr++] = CrntPrefix;
+
+				/* Now lets pop all the stack into output: */
+				while (StackPtr != 0 && i < LineLen) {
+					Line[i++] = Stack[--StackPtr];
+				}
+			}
+			if (LastCode != NO_SUCH_CODE &&
+			    Private->RunningCode - 2 < (LZ_MAX_CODE + 1) &&
+			    Prefix[Private->RunningCode - 2] == NO_SUCH_CODE) {
+				Prefix[Private->RunningCode - 2] = LastCode;
+
+				if (CrntCode == Private->RunningCode - 2) {
+					/* Only allowed if CrntCode is exactly
+					 * the running code: In that case
+					 * CrntCode = XXXCode, CrntCode or the
+					 * prefix code is last code and the
+					 * suffix char is exactly the prefix of
+					 * last code! */
+					Suffix[Private->RunningCode - 2] =
+					    DGifGetPrefixChar(Prefix, LastCode,
+					                      ClearCode);
+				} else {
+					Suffix[Private->RunningCode - 2] =
+					    DGifGetPrefixChar(Prefix, CrntCode,
+					                      ClearCode);
+				}
+			}
+			LastCode = CrntCode;
+		}
+	}
+
+	Private->LastCode = LastCode;
+	Private->StackPtr = StackPtr;
+
+	return GIF_OK;
 }
 
 /******************************************************************************
@@ -927,55 +1005,55 @@ DGifDecompressLine(GifFileType *GifFile, GifPixelType *Line, int LineLen)
  If image is defective, we might loop here forever, so we limit the loops to
  the maximum possible if image O.k. - LZ_MAX_CODE times.
 ******************************************************************************/
-static int
-DGifGetPrefixChar(GifPrefixType *Prefix, int Code, int ClearCode)
-{
-    int i = 0;
-
-    while (Code > ClearCode && i++ <= LZ_MAX_CODE) {
-        if (Code > LZ_MAX_CODE) {
-            return NO_SUCH_CODE;
-        }
-        Code = Prefix[Code];
-    }
-    return Code;
+static int DGifGetPrefixChar(const GifPrefixType *Prefix, int Code,
+                             int ClearCode) {
+	int i = 0;
+
+	while (Code > ClearCode && i++ <= LZ_MAX_CODE) {
+		if (Code > LZ_MAX_CODE) {
+			return NO_SUCH_CODE;
+		}
+		Code = Prefix[Code];
+	}
+	return Code;
 }
 
 /******************************************************************************
  Interface for accessing the LZ codes directly. Set Code to the real code
  (12bits), or to -1 if EOF code is returned.
 ******************************************************************************/
-int
-DGifGetLZCodes(GifFileType *GifFile, int *Code)
-{
-    GifByteType *CodeBlock;
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
-
-    if (!IS_READABLE(Private)) {
-        /* This file was NOT open for reading: */
-        GifFile->Error = D_GIF_ERR_NOT_READABLE;
-        return GIF_ERROR;
-    }
-
-    if (DGifDecompressInput(GifFile, Code) == GIF_ERROR)
-        return GIF_ERROR;
-
-    if (*Code == Private->EOFCode) {
-        /* Skip rest of codes (hopefully only NULL terminating block): */
-        do {
-            if (DGifGetCodeNext(GifFile, &CodeBlock) == GIF_ERROR)
-                return GIF_ERROR;
-        } while (CodeBlock != NULL) ;
-
-        *Code = -1;
-    } else if (*Code == Private->ClearCode) {
-        /* We need to start over again: */
-        Private->RunningCode = Private->EOFCode + 1;
-        Private->RunningBits = Private->BitsPerPixel + 1;
-        Private->MaxCode1 = 1 << Private->RunningBits;
-    }
-
-    return GIF_OK;
+int DGifGetLZCodes(GifFileType *GifFile, int *Code) {
+	GifByteType *CodeBlock;
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	if (!IS_READABLE(Private)) {
+		/* This file was NOT open for reading: */
+		GifFile->Error = D_GIF_ERR_NOT_READABLE;
+		return GIF_ERROR;
+	}
+
+	if (DGifDecompressInput(GifFile, Code) == GIF_ERROR) {
+		return GIF_ERROR;
+	}
+
+	if (*Code == Private->EOFCode) {
+		/* Skip rest of codes (hopefully only NULL terminating block):
+		 */
+		do {
+			if (DGifGetCodeNext(GifFile, &CodeBlock) == GIF_ERROR) {
+				return GIF_ERROR;
+			}
+		} while (CodeBlock != NULL);
+
+		*Code = -1;
+	} else if (*Code == Private->ClearCode) {
+		/* We need to start over again: */
+		Private->RunningCode = Private->EOFCode + 1;
+		Private->RunningBits = Private->BitsPerPixel + 1;
+		Private->MaxCode1 = 1 << Private->RunningBits;
+	}
+
+	return GIF_OK;
 }
 
 /******************************************************************************
@@ -984,52 +1062,48 @@ DGifGetLZCodes(GifFileType *GifFile, int *Code)
  8 bits (bytes) packets, into the real codes.
  Returns GIF_OK if read successfully.
 ******************************************************************************/
-static int
-DGifDecompressInput(GifFileType *GifFile, int *Code)
-{
-    static const unsigned short CodeMasks[] = {
-	0x0000, 0x0001, 0x0003, 0x0007,
-	0x000f, 0x001f, 0x003f, 0x007f,
-	0x00ff, 0x01ff, 0x03ff, 0x07ff,
-	0x0fff
-    };
-
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
-
-    GifByteType NextByte;
-
-    /* The image can't contain more than LZ_BITS per code. */
-    if (Private->RunningBits > LZ_BITS) {
-        GifFile->Error = D_GIF_ERR_IMAGE_DEFECT;
-        return GIF_ERROR;
-    }
-    
-    while (Private->CrntShiftState < Private->RunningBits) {
-        /* Needs to get more bytes from input stream for next code: */
-        if (DGifBufferedInput(GifFile, Private->Buf, &NextByte) == GIF_ERROR) {
-            return GIF_ERROR;
-        }
-        Private->CrntShiftDWord |=
-	    ((unsigned long)NextByte) << Private->CrntShiftState;
-        Private->CrntShiftState += 8;
-    }
-    *Code = Private->CrntShiftDWord & CodeMasks[Private->RunningBits];
-
-    Private->CrntShiftDWord >>= Private->RunningBits;
-    Private->CrntShiftState -= Private->RunningBits;
-
-    /* If code cannot fit into RunningBits bits, must raise its size. Note
-     * however that codes above 4095 are used for special signaling.
-     * If we're using LZ_BITS bits already and we're at the max code, just
-     * keep using the table as it is, don't increment Private->RunningCode.
-     */
-    if (Private->RunningCode < LZ_MAX_CODE + 2 &&
-	++Private->RunningCode > Private->MaxCode1 &&
-	Private->RunningBits < LZ_BITS) {
-        Private->MaxCode1 <<= 1;
-        Private->RunningBits++;
-    }
-    return GIF_OK;
+static int DGifDecompressInput(GifFileType *GifFile, int *Code) {
+	static const unsigned short CodeMasks[] = {
+	    0x0000, 0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f,
+	    0x007f, 0x00ff, 0x01ff, 0x03ff, 0x07ff, 0x0fff};
+
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	GifByteType NextByte;
+
+	/* The image can't contain more than LZ_BITS per code. */
+	if (Private->RunningBits > LZ_BITS) {
+		GifFile->Error = D_GIF_ERR_IMAGE_DEFECT;
+		return GIF_ERROR;
+	}
+
+	while (Private->CrntShiftState < Private->RunningBits) {
+		/* Needs to get more bytes from input stream for next code: */
+		if (DGifBufferedInput(GifFile, Private->Buf, &NextByte) ==
+		    GIF_ERROR) {
+			return GIF_ERROR;
+		}
+		Private->CrntShiftDWord |= ((unsigned long)NextByte)
+		                           << Private->CrntShiftState;
+		Private->CrntShiftState += 8;
+	}
+	*Code = Private->CrntShiftDWord & CodeMasks[Private->RunningBits];
+
+	Private->CrntShiftDWord >>= Private->RunningBits;
+	Private->CrntShiftState -= Private->RunningBits;
+
+	/* If code cannot fit into RunningBits bits, must raise its size. Note
+	 * however that codes above 4095 are used for special signaling.
+	 * If we're using LZ_BITS bits already and we're at the max code, just
+	 * keep using the table as it is, don't increment Private->RunningCode.
+	 */
+	if (Private->RunningCode < LZ_MAX_CODE + 2 &&
+	    ++Private->RunningCode > Private->MaxCode1 &&
+	    Private->RunningBits < LZ_BITS) {
+		Private->MaxCode1 <<= 1;
+		Private->RunningBits++;
+	}
+	return GIF_OK;
 }
 
 /******************************************************************************
@@ -1038,37 +1112,56 @@ DGifDecompressInput(GifFileType *GifFile, int *Code)
  The routine returns the next byte from its internal buffer (or read next
  block in if buffer empty) and returns GIF_OK if succesful.
 ******************************************************************************/
-static int
-DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf, GifByteType *NextByte)
-{
-    if (Buf[0] == 0) {
-        /* Needs to read the next buffer - this one is empty: */
-	/* coverity[check_return] */
-        if (READ(GifFile, Buf, 1) != 1) {
-            GifFile->Error = D_GIF_ERR_READ_FAILED;
-            return GIF_ERROR;
-        }
-        /* There shouldn't be any empty data blocks here as the LZW spec
-         * says the LZW termination code should come first.  Therefore we
-         * shouldn't be inside this routine at that point.
-         */
-        if (Buf[0] == 0) {
-            GifFile->Error = D_GIF_ERR_IMAGE_DEFECT;
-            return GIF_ERROR;
-        }
-        if (READ(GifFile, &Buf[1], Buf[0]) != Buf[0]) {
-            GifFile->Error = D_GIF_ERR_READ_FAILED;
-            return GIF_ERROR;
-        }
-        *NextByte = Buf[1];
-        Buf[1] = 2;    /* We use now the second place as last char read! */
-        Buf[0]--;
-    } else {
-        *NextByte = Buf[Buf[1]++];
-        Buf[0]--;
-    }
-
-    return GIF_OK;
+static int DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf,
+                             GifByteType *NextByte) {
+	if (Buf[0] == 0) {
+		/* Needs to read the next buffer - this one is empty: */
+		/* coverity[check_return] */
+		if (InternalRead(GifFile, Buf, 1) != 1) {
+			GifFile->Error = D_GIF_ERR_READ_FAILED;
+			return GIF_ERROR;
+		}
+		/* There shouldn't be any empty data blocks here as the LZW spec
+		 * says the LZW termination code should come first.  Therefore
+		 * we shouldn't be inside this routine at that point.
+		 */
+		if (Buf[0] == 0) {
+			GifFile->Error = D_GIF_ERR_IMAGE_DEFECT;
+			return GIF_ERROR;
+		}
+		if (InternalRead(GifFile, &Buf[1], Buf[0]) != Buf[0]) {
+			GifFile->Error = D_GIF_ERR_READ_FAILED;
+			return GIF_ERROR;
+		}
+		*NextByte = Buf[1];
+		Buf[1] = 2; /* We use now the second place as last char read! */
+		Buf[0]--;
+	} else {
+		*NextByte = Buf[Buf[1]++];
+		Buf[0]--;
+	}
+
+	return GIF_OK;
+}
+
+/******************************************************************************
+ This routine is called in case of error during parsing image. We need to
+ decrease image counter and reallocate memory for saved images. Not decreasing
+ ImageCount may lead to null pointer dereference, because the last element in
+ SavedImages may point to the spoilt image and null pointer buffers.
+*******************************************************************************/
+void DGifDecreaseImageCounter(GifFileType *GifFile) {
+	GifFile->ImageCount--;
+	if (GifFile->SavedImages[GifFile->ImageCount].RasterBits != NULL) {
+		free(GifFile->SavedImages[GifFile->ImageCount].RasterBits);
+	}
+
+	// Realloc array according to the new image counter.
+	SavedImage *correct_saved_images = (SavedImage *)reallocarray(
+	    GifFile->SavedImages, GifFile->ImageCount, sizeof(SavedImage));
+	if (correct_saved_images != NULL) {
+		GifFile->SavedImages = correct_saved_images;
+	}
 }
 
 /******************************************************************************
@@ -1076,117 +1169,144 @@ DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf, GifByteType *NextByte)
  the GifFileType pointer.  Call DGifOpenFileName() or DGifOpenFileHandle()
  first to initialize I/O.  Its inverse is EGifSpew().
 *******************************************************************************/
-int
-DGifSlurp(GifFileType *GifFile)
-{
-    size_t ImageSize;
-    GifRecordType RecordType;
-    SavedImage *sp;
-    GifByteType *ExtData;
-    int ExtFunction;
-
-    GifFile->ExtensionBlocks = NULL;
-    GifFile->ExtensionBlockCount = 0;
-
-    do {
-        if (DGifGetRecordType(GifFile, &RecordType) == GIF_ERROR)
-            return (GIF_ERROR);
-
-        switch (RecordType) {
-          case IMAGE_DESC_RECORD_TYPE:
-              if (DGifGetImageDesc(GifFile) == GIF_ERROR)
-                  return (GIF_ERROR);
-
-              sp = &GifFile->SavedImages[GifFile->ImageCount - 1];
-              /* Allocate memory for the image */
-              if (sp->ImageDesc.Width < 0 && sp->ImageDesc.Height < 0 &&
-                      sp->ImageDesc.Width > (INT_MAX / sp->ImageDesc.Height)) {
-                  return GIF_ERROR;
-              }
-              ImageSize = sp->ImageDesc.Width * sp->ImageDesc.Height;
-
-              if (ImageSize > (SIZE_MAX / sizeof(GifPixelType))) {
-                  return GIF_ERROR;
-              }
-              sp->RasterBits = (unsigned char *)reallocarray(NULL, ImageSize,
-                      sizeof(GifPixelType));
-
-              if (sp->RasterBits == NULL) {
-                  return GIF_ERROR;
-              }
-
-	      if (sp->ImageDesc.Interlace) {
-		  int i, j;
-		   /* 
-		    * The way an interlaced image should be read - 
-		    * offsets and jumps...
-		    */
-		  int InterlacedOffset[] = { 0, 4, 2, 1 };
-		  int InterlacedJumps[] = { 8, 8, 4, 2 };
-		  /* Need to perform 4 passes on the image */
-		  for (i = 0; i < 4; i++)
-		      for (j = InterlacedOffset[i]; 
-			   j < sp->ImageDesc.Height;
-			   j += InterlacedJumps[i]) {
-			  if (DGifGetLine(GifFile, 
-					  sp->RasterBits+j*sp->ImageDesc.Width, 
-					  sp->ImageDesc.Width) == GIF_ERROR)
-			      return GIF_ERROR;
-		      }
-	      }
-	      else {
-		  if (DGifGetLine(GifFile,sp->RasterBits,ImageSize)==GIF_ERROR)
-		      return (GIF_ERROR);
-	      }
-
-              if (GifFile->ExtensionBlocks) {
-                  sp->ExtensionBlocks = GifFile->ExtensionBlocks;
-                  sp->ExtensionBlockCount = GifFile->ExtensionBlockCount;
-
-                  GifFile->ExtensionBlocks = NULL;
-                  GifFile->ExtensionBlockCount = 0;
-              }
-              break;
-
-          case EXTENSION_RECORD_TYPE:
-              if (DGifGetExtension(GifFile,&ExtFunction,&ExtData) == GIF_ERROR)
-                  return (GIF_ERROR);
-	      /* Create an extension block with our data */
-              if (ExtData != NULL) {
-		  if (GifAddExtensionBlock(&GifFile->ExtensionBlockCount,
-					   &GifFile->ExtensionBlocks, 
-					   ExtFunction, ExtData[0], &ExtData[1])
-		      == GIF_ERROR)
-		      return (GIF_ERROR);
-	      }
-              while (ExtData != NULL) {
-                  if (DGifGetExtensionNext(GifFile, &ExtData) == GIF_ERROR)
-                      return (GIF_ERROR);
-                  /* Continue the extension block */
-		  if (ExtData != NULL)
-		      if (GifAddExtensionBlock(&GifFile->ExtensionBlockCount,
-					       &GifFile->ExtensionBlocks,
-					       CONTINUE_EXT_FUNC_CODE, 
-					       ExtData[0], &ExtData[1]) == GIF_ERROR)
-                      return (GIF_ERROR);
-              }
-              break;
-
-          case TERMINATE_RECORD_TYPE:
-              break;
-
-          default:    /* Should be trapped by DGifGetRecordType */
-              break;
-        }
-    } while (RecordType != TERMINATE_RECORD_TYPE);
-
-    /* Sanity check for corrupted file */
-    if (GifFile->ImageCount == 0) {
-	GifFile->Error = D_GIF_ERR_NO_IMAG_DSCR;
-	return(GIF_ERROR);
-    }
-
-    return (GIF_OK);
+int DGifSlurp(GifFileType *GifFile) {
+	size_t ImageSize;
+	GifRecordType RecordType;
+	SavedImage *sp;
+	GifByteType *ExtData;
+	int ExtFunction;
+
+	GifFile->ExtensionBlocks = NULL;
+	GifFile->ExtensionBlockCount = 0;
+
+	do {
+		if (DGifGetRecordType(GifFile, &RecordType) == GIF_ERROR) {
+			return (GIF_ERROR);
+		}
+
+		switch (RecordType) {
+		case IMAGE_DESC_RECORD_TYPE:
+			if (DGifGetImageDesc(GifFile) == GIF_ERROR) {
+				return (GIF_ERROR);
+			}
+
+			sp = &GifFile->SavedImages[GifFile->ImageCount - 1];
+			/* Allocate memory for the image */
+			if (sp->ImageDesc.Width <= 0 ||
+			    sp->ImageDesc.Height <= 0 ||
+			    sp->ImageDesc.Width >
+			        (INT_MAX / sp->ImageDesc.Height)) {
+				DGifDecreaseImageCounter(GifFile);
+				return GIF_ERROR;
+			}
+			ImageSize = sp->ImageDesc.Width * sp->ImageDesc.Height;
+
+			if (ImageSize > (SIZE_MAX / sizeof(GifPixelType))) {
+				DGifDecreaseImageCounter(GifFile);
+				return GIF_ERROR;
+			}
+			sp->RasterBits = (unsigned char *)reallocarray(
+			    NULL, ImageSize, sizeof(GifPixelType));
+
+			if (sp->RasterBits == NULL) {
+				DGifDecreaseImageCounter(GifFile);
+				return GIF_ERROR;
+			}
+
+			if (sp->ImageDesc.Interlace) {
+				int i, j;
+				/*
+				 * The way an interlaced image should be read -
+				 * offsets and jumps...
+				 */
+				static const int InterlacedOffset[] = {0, 4, 2,
+				                                       1};
+				static const int InterlacedJumps[] = {8, 8, 4,
+				                                      2};
+				/* Need to perform 4 passes on the image */
+				for (i = 0; i < 4; i++) {
+					for (j = InterlacedOffset[i];
+					     j < sp->ImageDesc.Height;
+					     j += InterlacedJumps[i]) {
+						if (DGifGetLine(
+						        GifFile,
+						        sp->RasterBits +
+						            j * sp->ImageDesc
+						                    .Width,
+						        sp->ImageDesc.Width) ==
+						    GIF_ERROR) {
+							DGifDecreaseImageCounter(
+							    GifFile);
+							return GIF_ERROR;
+						}
+					}
+				}
+			} else {
+				if (DGifGetLine(GifFile, sp->RasterBits,
+				                ImageSize) == GIF_ERROR) {
+					DGifDecreaseImageCounter(GifFile);
+					return GIF_ERROR;
+				}
+			}
+
+			if (GifFile->ExtensionBlocks) {
+				sp->ExtensionBlocks = GifFile->ExtensionBlocks;
+				sp->ExtensionBlockCount =
+				    GifFile->ExtensionBlockCount;
+
+				GifFile->ExtensionBlocks = NULL;
+				GifFile->ExtensionBlockCount = 0;
+			}
+			break;
+
+		case EXTENSION_RECORD_TYPE:
+			if (DGifGetExtension(GifFile, &ExtFunction, &ExtData) ==
+			    GIF_ERROR) {
+				return (GIF_ERROR);
+			}
+			/* Create an extension block with our data */
+			if (ExtData != NULL) {
+				if (GifAddExtensionBlock(
+				        &GifFile->ExtensionBlockCount,
+				        &GifFile->ExtensionBlocks, ExtFunction,
+				        ExtData[0], &ExtData[1]) == GIF_ERROR) {
+					return (GIF_ERROR);
+				}
+			}
+			for (;;) {
+				if (DGifGetExtensionNext(GifFile, &ExtData) ==
+				    GIF_ERROR) {
+					return (GIF_ERROR);
+				}
+				if (ExtData == NULL) {
+					break;
+				}
+				/* Continue the extension block */
+				if (GifAddExtensionBlock(
+				        &GifFile->ExtensionBlockCount,
+				        &GifFile->ExtensionBlocks,
+				        CONTINUE_EXT_FUNC_CODE, ExtData[0],
+				        &ExtData[1]) == GIF_ERROR) {
+					return (GIF_ERROR);
+				}
+			}
+			break;
+
+		case TERMINATE_RECORD_TYPE:
+			break;
+
+		default: /* Should be trapped by DGifGetRecordType */
+			break;
+		}
+	} while (RecordType != TERMINATE_RECORD_TYPE);
+
+	/* Sanity check for corrupted file */
+	if (GifFile->ImageCount == 0) {
+		GifFile->Error = D_GIF_ERR_NO_IMAG_DSCR;
+		return (GIF_ERROR);
+	}
+
+	return (GIF_OK);
 }
 
 /* end */
diff --git a/doc/00README b/doc/00README
new file mode 100644
index 0000000..246014c
--- /dev/null
+++ b/doc/00README
@@ -0,0 +1,13 @@
+This directory contains documentation on the API and tools. 
+The most convenient way to view it is with a browser pointed
+at the project website, but...
+
+An introduction to the package is in intro.xml
+
+API documentation lives in gif_lib.xml
+
+GIF standards documents can be found in the directory gifstandard/
+
+
+
+
diff --git a/doc/Makefile b/doc/Makefile
new file mode 100644
index 0000000..b34ece0
--- /dev/null
+++ b/doc/Makefile
@@ -0,0 +1,59 @@
+.SUFFIXES: .xml .html .txt .adoc .1 .7
+
+.xml.html:
+	xmlto xhtml-nochunks $<
+
+.xml.1:
+	xmlto man $<
+
+.xml.7:
+	xmlto man $<
+
+.xml.txt:
+	xmlto txt $<
+
+.adoc.html:
+	asciidoc $<
+
+all: allhtml manpages
+
+# The distinction between XMLMAN and XMLINTERNAL is because
+# some pages shouldn't be installed as part of a binary package;
+# they're just for test-pattern generators.
+XMLMAN1 = \
+	gif2rgb.xml \
+	gifbuild.xml \
+	gifclrmp.xml \
+	giffilter.xml \
+	giffix.xml \
+	gifsponge.xml \
+	giftext.xml \
+	giftool.xml
+XMLMAN7 = \
+	giflib.xml
+XMLINTERNAL = \
+	gifbg.xml \
+	gifcolor.xml \
+	gifecho.xml \
+	gifinto.xml \
+	gifhisto.xml \
+	gifwedge.xml
+XMLDOC = intro.xml gif_lib.xml
+XMLALL = $(XMLMAN1) $(XMLMAN7) $(XMLINTERNAL) $(XMLDOC)
+
+# Logo image file for HTML docs
+giflib-logo.gif: ../pic/gifgrid.gif
+	convert $^ -resize 50x50 $@
+
+# Philosophical choice: the website gets the internal manual pages
+allhtml: $(XMLALL:.xml=.html) giflib-logo.gif
+
+manpages: $(XMLMAN1:.xml=.1) $(XMLMAN7:.xml=.7) $(XMLINTERNAL:.xml=.1)
+
+# Prepare the website directory to deliver an update.
+# ImageMagick and asciidoc are required.
+website: allhtml
+	rm -fr staging; mkdir staging; 
+	cp -r $(XMLALL:.xml=.html) gifstandard whatsinagif giflib-logo.gif staging
+	cp index.html.in staging/index.html
+	asciidoc - <../history.adoc >staging/history.html
diff --git a/doc/gif2rgb.xml b/doc/gif2rgb.xml
new file mode 100644
index 0000000..d54f4c7
--- /dev/null
+++ b/doc/gif2rgb.xml
@@ -0,0 +1,103 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE refentry PUBLIC
+   "-//OASIS//DTD DocBook XML V4.1.2//EN"
+   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>
+<refentry id='gif2rgb.1'>
+<refentryinfo><date>2 May 2012</date></refentryinfo>
+<refmeta>
+<refentrytitle>gif2rgb</refentrytitle>
+<manvolnum>1</manvolnum>
+<refmiscinfo class="source">GIFLIB</refmiscinfo>
+<refmiscinfo class="manual">GIFLIB Documentation</refmiscinfo>
+</refmeta>
+<refnamediv id='name'>
+<refname>gif2rgb</refname>
+<refpurpose>convert images saved as GIF to 24-bit RGB triplets</refpurpose>
+</refnamediv>
+
+<refsynopsisdiv id='synopsis'>
+
+<cmdsynopsis>
+  <command>gif2rgb</command>
+      <arg choice='opt'>-v</arg>
+      <arg choice='opt'>-1</arg>
+      <arg choice='opt'>-c <replaceable>colors</replaceable></arg>
+      <arg choice='opt'>-s 
+      		<replaceable>width</replaceable>
+      		<replaceable>height</replaceable></arg>
+      <arg choice='opt'>-o <replaceable>outfile</replaceable></arg>
+      <arg choice='opt'>-h</arg>
+      <arg choice='opt'><replaceable>gif-file</replaceable></arg>
+</cmdsynopsis>
+</refsynopsisdiv>
+
+<refsect1><title>Options</title>
+
+<variablelist>
+<varlistentry>
+<term>-v</term>
+<listitem>
+<para>Verbose mode (show progress). 
+Enables printout of running scan lines.</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-1</term>
+<listitem>
+<para>Only one file in the format of RGBRGB... triplets (Each of R,
+G,B is a byte) is being read or written.  This file size is 3 * Width
+* Height. If stdin is used for input or stdout for output, this option
+is implicitly applied. The default (if not `-1') is 3 files with the
+names OutFileName.R, OutFileName.G, OutFileName.B, each of which is
+Width * Height bytes.</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-c colors </term>
+<listitem>
+<para> Specifies number of colors to use in RGB-to-GIF conversions, in
+bits per pixels, so '-c 8' actually specifies 256 colors (maximum and
+default).</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-s width height</term>
+<listitem>
+<para> Sets RGB-to-GIF conversion mode and specifies the size of the image 
+to read. </para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-o</term>
+<listitem>
+<para> specifies the name of the out file (see also `-1' above).</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-h</term>
+<listitem>
+<para> Print one line of command line help, similar to Usage above.</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+<para>By default, convert a GIF input file to RGB triplets.  If -s is 
+specified, convert RGB input to a GIF.</para>
+
+<para>If no input file is given, gif2rgb will try to read data
+from stdin.</para>
+
+</refsect1>
+<refsect1><title>Bugs</title>
+
+<para>Feeding this utility a GIF with an invalid colormap, or other
+kinds of malformations, index will produce invalid output and may
+core-dump the tool. Don't do that.</para>
+
+</refsect1>
+<refsect1><title>Author</title>
+
+<para>Gershon Elber.</para>
+
+</refsect1>
+</refentry>
diff --git a/doc/gif_lib.xml b/doc/gif_lib.xml
new file mode 100644
index 0000000..f896ee5
--- /dev/null
+++ b/doc/gif_lib.xml
@@ -0,0 +1,1245 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE article PUBLIC 
+   "-//OASIS//DTD DocBook XML V4.1.2//EN"
+   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
+<!ENTITY homepage      "http://catb.org/~esr/">
+<!ENTITY email         "esr@thyrsus.com">
+]>
+<article><title>The GIFLIB Library</title>
+
+<articleinfo>
+
+<author>
+  <firstname>Eric</firstname>
+  <othername>Steven</othername>
+  <surname>Raymond</surname>
+  <affiliation>
+    <orgname><ulink url="&homepage;">
+    Thyrsus Enterprises</ulink></orgname> 
+    <address>
+    <email>&email;</email>
+    </address>
+  </affiliation>
+</author>
+<copyright>
+  <year>2012</year>
+  <holder role="mailto:&email;">Eric S. Raymond</holder> 
+</copyright>
+
+</articleinfo>
+
+<!--
+Gershon Elber, May 1991
+Eric S. Raymond, Sep 1992
+Toshio Kuratomi, May 2004
+-->
+
+<sect1><title>Introduction</title>
+
+<para>The Graphics Interchange Format(c) is the Copyright property of
+CompuServe Incorporated.  GIF(sm) is a Service Mark property of CompuServe
+Incorporated.</para>
+
+<para>This document explains the GIF library code in directory `lib'.  The
+code is collected into a service library which is used in all the utilities in
+`util'.  It can be used in any application needs to read/write the GIF
+file format.  This document does <emphasis>not</emphasis> explain the GIF file
+format and assumes you know it, at least to the level of the GIF file
+structure.</para>
+
+</sect1>
+<sect1><title>Credit and Blame</title>
+
+<para>Gershon wrote: "This library was written because I couldn't find
+anything similar and I wanted one.  I was inspired by the RLE Utah tool kit,
+which I hoped to port to an IBM PC, but found it to be too machine specific,
+and its compression ratio too low.  I compromised on the GIF format, but I am
+not sure how long 8 bits per pixel will be enough."</para>
+
+<para>During his first spell of maintainership between 1989 and 1994, Eric
+S. Raymond (aka "ESR") ported the code to Unix, wrote the high-level
+DGIfSlurp()/EGifSpew() interface, rationalized the internal data
+structures, and did a lot of general cleanup and refactoring to
+improve the code quality.</para>
+
+<para>Between 1994 and 2012 Toshio Kuratomi fixed various tool bugs,
+build-recipe problems and rare segfaults. He partially untangled the
+somewhat misdesigned extension-block handling in earlier versions. 
+The core code was very stable during this period.</para>
+
+<para>During his second spell of maintainership, ESR fixed the
+extension API, made the library re-entrant and thread-safe, wrote a
+regression-test suite, greatly improved the documentation, and
+discarded a lot of obsolete code.</para>
+
+</sect1>
+<sect1><title>The GIF descriptor</title>
+
+<para>When a GIF file is opened, a GIF file descriptor is created which
+is a pointer to GifFileType structure as follows:</para>
+
+<programlisting>
+typedef struct GifFileType {
+    GifWord SWidth, SHeight;         /* Size of virtual canvas */
+    GifWord SColorResolution;        /* How many colors can we generate? */
+    GifWord SBackGroundColor;        /* Background color for virtual canvas */
+    GifByteType AspectByte;	     /* Used to compute pixel aspect ratio */
+    ColorMapObject *SColorMap;       /* Global colormap, NULL if nonexistent. */
+    int ImageCount;                  /* Number of current image (both APIs) */
+    GifImageDesc Image;              /* Current image (low-level API) */
+    SavedImage *SavedImages;         /* Image sequence (high-level API) */
+    int ExtensionBlockCount;         /* Count extensions past last image */
+    ExtensionBlock *ExtensionBlocks; /* Extensions past last image */    
+    int Error;			     /* Last error condition reported */
+    void *UserData;                  /* hook to attach user data (TVT) */
+    void *Private;                   /* Don't mess with this! */
+} GifFileType;
+</programlisting>
+
+<para>This structure was copied from gif_lib.h - the header file for the GIF
+library.  Any application program that uses the libgif.a library should
+include it.  Members beginning with S refer to the GIF screen; others hold
+properties of the current image (a GIF file may have more than one image)
+or point to allocated store used by various routines.</para>
+
+<para>The user almost never writes into this structure (exception: it
+may occasionally be useful to alter things in the SavedImages array and
+Trailing member), but can read any of these items at any time it is
+valid (Image information is invalid until the first image has been read;
+read; SavedImages information is valid only after a DGifSlurp() call).</para>
+
+<para>As the library needs to keep its own internal data, a Private pointer
+to hidden data is included. Applications should ignore this.</para>
+
+<para>The library allocates its own memory dynamically, on opening of files,
+and releases that once closed.  The user is never required to allocate
+any memory for any of the functions of this library, and is almost never
+required to free them directly. The "almost" in the latter clause is because
+one manual free() call may be required on a failed file close; see the
+documentation of DGifClose() and EGifClose() for details.</para>
+
+<para>Here is a module summary:</para>
+
+<variablelist>
+<varlistentry>
+<term>egif_lib.c</term>
+<listitem>
+<para>Encoding routines, all prefixed with E.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>dgif_lib.c</term>
+<listitem>
+<para>Decoding routines, all prefixed with D.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>gifalloc.c</term>
+<listitem>
+<para>Routines for colormap handling and GIF record allocation.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>gif_font.c</term>
+<listitem>
+<para>The 8x8 font table for the GIF utility font.</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+<para>The library includes a sixth file of hash-function code which is accessed
+internally only.</para>
+
+<para>Most of the routines return GIF_ERROR (see gif_lib.h) if something
+went wrong, GIF_OK otherwise.  After an error return, all routines that
+take a pointer-to-GifFileType argument set the Error member with a code that
+can be interpreted into an explanatory string with the function 
+GifErrorString() in gif_err.c. (The exception to this is the
+DGifClose() and EGifClose() routines, which deallocate that structure
+and must therefore return any error code through a pointer argument.)</para>
+
+</sect1>
+<sect1><title>Decoding (dgif_lib.c)</title>
+
+<para>The following functions are used to set up input from a GIF:</para>
+
+<programlisting id="DGifOpenFileName">
+GifFileType *DGifOpenFileName(char *GifFileName, int *ErrorCode)
+</programlisting>
+
+<para>Open a new GIF file (in binary mode, if under Windows) using the
+given GifFileName, and read its Screen information.</para>
+
+<para>If any error occurs, NULL is returned and ErrorCode is set (if
+non-NULL).</para>
+
+<programlisting id="DGifOpenFileHandle">
+GifFileType *DGifOpenFileHandle(int FileHandle, int *ErrorCode)
+</programlisting>
+
+<para>Open a new GIF file using the given FileHandle, and read its Screen
+information.</para>
+
+<para>If any error occurs, NULL is returned and ErrorCode is set (if
+non-NULL).</para>
+
+<para>Once you have acquired a handle on a GIF, the high-level
+function</para>
+
+<programlisting id="DGifSlurp">
+int DGifSlurp(GifFileType)
+</programlisting>
+
+<para>reads the rest of a complete (possibly multi-image) GIF file from the
+indicated file handle into in-core allocated structures.  It returns
+GIF_OK on success, GIF_ERROR on failure; on failure, the Error member 
+will be set.</para>
+
+<para>Once you have done this, all image, raster, and extension-block
+data in the GIF is accessable in the SavedImages member (see the
+structures in gif_lib.h).  When you have modified the image to taste,
+write it out with EGifSpew().</para>
+
+<para>One detail that may not be clear from just looking at the
+structures is how extension blocks and sub-blocks are stored.  Each
+ExtensionBlock structure represents an extension data block.  Those
+with a zero function code represent continuation data blocks attached
+to previous blocks with nonzero function codes.</para>
+
+<para>You can read from a GIF file through a function hook. Initialize
+with </para>
+
+<programlisting id="DGifOpen">
+GifFileType *DGifOpen(void *userPtr, InputFunc readFunc, int *ErrorCode)
+</programlisting>
+
+<para>and see the library header file for the type of InputFunc.</para>
+
+<para>There is also a set of deprecated functions for sequential I/O,
+described in a later section.</para>
+</sect1>
+<sect1><title>Encoding (egif_lib.c)</title>
+
+<para>The high-level function</para>
+
+<programlisting id="EGifSpew">
+int EGifSpew(GifFileType *GifFile)
+</programlisting>
+
+<para>writes a complete (possibly multi-image) GIF file to the indicated file
+handle from in-core allocated structures created by a previous DGifSlurp()
+or equivalent operations.  Its argument is a GIF file descriptor, which
+imnplicitly points to storage previously allocated by DGifSlurp().</para>
+
+<para>The file is written with a GIF87 stamp unless it contains one of the four
+special extension blocks defined in GIF89, in which case it is written
+with a GIF89 stamp.</para>
+
+<para>EGifSpew() finishes by closing the GIF (writing a termination
+record to it) and deallocating the associated storage.</para>
+
+<para>You can write to a GIF file through a function hook. Initialize
+with </para>
+
+<programlisting id="EGifOpen">
+GifFileType *EGifOpen(void *userPtr, OutputFunc writeFunc, int *ErrorCode)
+</programlisting>
+
+<para>and see the library header file for the type of OutputFunc.</para>
+
+<para>There is also a set of deprecated functions for sequential I/O,
+described in a later section.</para>
+</sect1>
+<sect1><title>Color map handling and allocation routines</title>
+
+<programlisting id="GifMakeMapObject">
+ColorMapObject *GifMakeMapObject(int ColorCount, GifColorType *ColorMap)
+</programlisting>
+
+<para>Allocate storage for a color map object with the given number of
+RGB triplet slots.  If the second argument is non-NULL, initialize
+the color table portion of the new map from it.  Returns NULL if
+memory is exhausted or if the size is not a power of 2 &lt;= 256.</para>
+
+<programlisting id="GifFreeMapObject">
+void GifFreeMapObject(ColorMapObject *Object)
+</programlisting>
+
+<para>Free the storage occupied by a ColorMapObject that is no longer
+needed.</para>
+
+<programlisting id="GifUnionColorMap">
+ColorMapObject *GifUnionColorMap(
+        ColorMapObject *ColorIn1, ColorMapObject *ColorIn2,
+        GifPixelType ColorTransIn2[])
+</programlisting>
+
+<para>Create the union of two given color maps and return it.  If the result
+won't fit into 256 colors, NULL is returned, the allocated union
+otherwise.  ColorIn1 is copied as it to ColorUnion, while colors from
+ColorIn2 are copied if they didn't exist before.  ColorTransIn2 maps
+the old ColorIn2 into ColorUnion color map table.</para>
+
+<programlisting id="GifAttachImage">
+SavedImage *GifAttachImage(GifFileType *GifFile)
+</programlisting>
+
+<para>Add an image block to the SavedImages array.  The image block is
+initially zeroed out.  This image block will be seen by any following
+EGifSpew() calls.</para>
+
+</sect1>
+<sect1><title>Graphics control extension handling</title>
+
+<para>GIF89 added a graphics control extension block, but versions
+of GIFLIB before 5.0 weren't much help in reading or modifying them.  
+This lack has been remedied with the following structure and functions:</para>
+
+<programlisting>
+typedef struct GraphicsControlBlock {
+    int DisposalMode;
+#define DISPOSAL_UNSPECIFIED      0       /* No disposal specified. */
+#define DISPOSE_DO_NOT            1       /* Leave image in place */
+#define DISPOSE_BACKGROUND        2       /* Set area too background color */
+#define DISPOSE_PREVIOUS          3       /* Restore to previous content */
+    bool UserInputFlag;      /* User confirmation required before disposal */
+    int DelayTime;           /* pre-display delay in 0.01sec units */
+    int TransparentColor;    /* Palette index for transparency, -1 if none */
+#define NO_TRANSPARENT_COLOR	-1
+} GraphicsControlBlock;
+
+int DGifSavedExtensionToGCB(GifFileType *GifFile, 
+			    int ImageIndex, 
+			    GraphicsControlBlock *GCB);
+int EGifGCBToSavedExtension(const GraphicsControlBlock *GCB, 
+			    GifFileType *GifFile, 
+			    int ImageIndex);
+</programlisting>
+
+<para>With these functions you can extract the data from a graphics
+control extension associated with a saved image into a
+GraphicsControlBlock, modify it, and write it back out.  Note that if
+the specified saved image doesn't have a graphics control extension,
+DGifSavedExtensionToGCB() will fill the GCB with default values and
+return GIF_ERROR (which can be ignored); EGifGCBToSavedExtension()
+will create a new leading extension block.</para>
+
+</sect1>
+<sect1><title>Error Handling (gif_err.c)</title>
+
+<programlisting>
+int GifErrorString(int ErrCode)
+</programlisting>
+
+<para>Returns a sting describing the specified GIFLIB error code.
+Return NULL if the argument is not a valid error code.</para>
+
+</sect1>
+<sect1><title>The GIF Utility Font</title>
+
+<para>The 8x8 utility font used in the (obsolete, no longer installed)
+gifecho and gifcolor lives in the library module gif_font.c, in a
+table called GifAsciiTable.  The library header file includes suitable
+externs and defines.</para>
+
+<para>The GIF utility font support includes entry points for drawing legends
+on in-core images, drawing boxes and rectangles, and boxing text.
+These entry points are as follows:</para>
+
+<programlisting id="GifDrawText">
+void GifDrawText8x8(
+        SavedImage *Image,
+        const int x, const int y,
+        const char *legend,
+        const int color)
+</programlisting>
+
+<para>Draw text using the 8x8 utility font on the saved image.  Upper
+left corner of the text is at image pixel (x, y).  Use the specified
+color index.</para>
+
+<programlisting id="GifDrawBox">
+void GifDrawBox(SavedImage *Image,
+        const int x, const int y,
+        const int w, const int h,
+        const int color)
+</programlisting>
+
+<para>Draw a box on the saved image.  Upper left corner of the box is at
+image pixels (x, y), width is w, height is h.  Use the specified color
+index.</para>
+
+<programlisting id="GifDrawRectangle">
+void GifDrawRectangle(SavedImage *Image,
+        const int x, const int y,
+        const int w, const int h,
+        const int color)
+</programlisting>
+
+<para>Draw a (filled) rectangle on the saved image.  Upper left corner of
+the box is at image pixels (x, y), width is w, height is h.  Use the
+specified color index.</para>
+
+<programlisting id="GifDrawBoxedText">
+void GifDrawBoxedText8x8(SavedImage *Image,
+        const int x, const int y,
+        const char *legend,
+        const int border,
+        const int bg, const int fg)
+</programlisting>
+
+<para>Draw text on a filled rectangle.  The rectangle will be sized to fit
+the text, with upper left hand corner at (x, y) on the saved image.
+The `border' argument specifies a pixel margin around the text.  The
+`bg' argument is the color table index to fill the rectangle with;
+`fg' is the color table index to draw the text with.</para>
+
+<para>This function interprets some characters in the legend string
+specially.  A tab (\t) is interpreted as a command to center the
+following text in the box.  A carriage return (\r) is interpreted
+as a request for a line break.</para>
+
+</sect1>
+<sect1><title>Error codes</title>
+
+<para>Errors as reported from the GIFLIB library are divided to two major
+categories: the encoder (errors prefixed by E_GIF_ERR), and the
+decoder (errors prefixed by D_GIF_ERR).  This document explains them
+briefly.</para>
+
+<sect2><title>Encoding errors</title>
+
+<variablelist>
+<varlistentry>
+<term><errorname>E_GIF_ERR_OPEN_FAILED</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Failed to open given file"
+   IO error result when attempt to open the given GIF file.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>E_GIF_ERR_WRITE_FAILED</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Failed to Write to given file"
+   IO error result when attempt to write to the given GIF file.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>E_GIF_ERR_HAS_SCRN_DSCR</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Screen Descriptor
+   already been set" Attempt to write second screen descriptor to same
+   GIF file. GIF file should have exactly one screen descriptor which
+   should be set directly after the file is opened.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>E_GIF_ERR_HAS_IMAG_DSCR</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Image Descriptor is still active"
+   Image descriptor should be sent before and image dump, and no second
+   image descriptor should be sent before current image dump ended. This error
+   occurred probably because current image was not complete.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>E_GIF_ERR_NO_COLOR_MAP</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Neither Global Nor
+   Local color map" An image must have either global (screen) or local
+   (image) color map.  Neither were given in this case.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>E_GIF_ERR_DATA_TOO_BIG</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "#Pixels bigger than
+   Width * Height" The number of pixels dumped for this image is
+   bigger than specified by image Height times image Width.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>E_GIF_ERR_NOT_ENOUGH_MEM</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Fail to allocate
+   required memory" Once an attemp is made to open GIF file, special
+   structures are allocated to hold internal data for it. If
+   allocation fails this error is returned.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>E_GIF_ERR_DISK_IS_FULL</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Write failed (disk full?)"
+   Writing encoded data failed.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>E_GIF_ERR_CLOSE_FAILED</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Failed to close given file"
+   Closing file failed.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname> E_GIF_ERR_NOT_WRITEABLE</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Given file was not
+   opened for write" GIF files can be opened both for read (DGIF part
+   of library) and write (EGIF part of library). This error occurs
+   when a file is opened for read (using DGIF) is given to one of the
+   encoding (EGIF) routines.</para>
+</listitem>
+</varlistentry>
+
+</variablelist>
+
+</sect2>
+<sect2><title>Decoding errors</title>
+
+<variablelist>
+<varlistentry>
+<term><errorname>D_GIF_ERR_OPEN_FAILED</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Failed to open given file"
+   IO error result when attempt to open the given GIF file.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>D_GIF_ERR_READ_FAILED</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Failed to read from given file"
+   IO error result when attempt to write to the given GIF file.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>D_GIF_ERR_NOT_GIF_FILE</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Data is not a GIF file"
+   GIF files should have special stamp identifies them as such, If that stamp
+   is not found, this error is issued.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>D_GIF_ERR_NO_SCRN_DSCR</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "No screen descriptor detected"
+   Each GIF file should have screen descriptor in its header. This error will
+   be generated if no such descriptor was found.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>D_GIF_ERR_NO_IMAG_DSCR</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "No image descriptor detected"
+   Each image should have image descriptor in its header. This error will
+   be generated if no such descriptor was found.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>D_GIF_ERR_NO_COLOR_MAP</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Neither global nor
+   local color map" An image must have either global (screen) or local
+   (image) color map.  Neither were given in this case.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>D_GIF_ERR_WRONG_RECORD</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Wrong record type detected"
+   Each record in a GIF file has a special identifier in its header. If the
+   record has an unrecognized identifier, this error is generated.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+  <term><errorname>D_GIF_ERR_DATA_TOO_BIG</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Number of pixels bigger than
+   width * height" The number of pixels dumped for this image is
+   bigger than specified by image Height times image Width.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>D_GIF_ERR_NOT_ENOUGH_MEM</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Failed to allocate
+   required memory" Once an attemp is made to open GIF file, special
+   structures are allocated to hold internal data for it. If
+   allocation fails this error is returned.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>D_GIF_ERR_CLOSE_FAILED</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Failed to close given file"
+   Closing file failed.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>D_GIF_ERR_NOT_READABLE</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Given file was not
+   opened for read" GIF files can be opened both for read (DGIF part
+   of library) and write (EGIF part of library). This error occurs
+   when a file is opened for write (using EGIF) is given to one of the
+   decoding (DGIF) routines.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>D_GIF_ERR_IMAGE_DEFECT</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Image is defective,
+   decoding aborted" This error is generated, once the decoding failed
+   - probably image is defect.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term><errorname>D_GIF_ERR_EOF_TOO_SOON</errorname></term>
+<listitem>
+   <para>Message printed using PrintGifError: "Image EOF detected,
+   before image complete" This error is generated once EOF errorname
+   is detected in encoded image before all the pixels (Width *
+   Height) has be decoded.</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+</sect2>
+</sect1>
+<sect1><title>Utility support library</title>
+
+<para>These functions are not part of the core GIF library.  They are part
+of the getarg library that supports the utilities.</para>
+
+<sect2><title>Error Handling</title>
+
+<programlisting id="PrintGifError">
+void PrintGifError(void)
+</programlisting>
+
+<para>Print a one-line diagnostic on the last giflib error to stderr.</para>
+
+</sect2>
+<sect2><title>Command Line Parsing</title>
+
+<programlisting id="GAGetArgs">
+bool GAGetArgs(int argc, char **argv, char *CtrlStr, ...)
+</programlisting>
+
+<para>Main routine of this module.  Given argc &amp; argv as received by
+the main procedure, the command line CtrlStr, and the addresses of
+all parameters, parse the command line, and update the parameters.</para>
+
+<para>The CtrlStr defines what types of variables should follow. Look at the
+beginning of getarg.c for exact usage.</para>
+
+<para>Returns false if successful, returns true on failure.</para>
+
+<programlisting id="GAPrintErrMsg">
+void GAPrintErrMsg(int Error)
+</programlisting>
+
+<para>If an error occurred in GAGetARgs, this routine may be used to print
+one line diagnostic to stderr.</para>
+
+<programlisting id="GAPrintHowTo">
+void GAPrintHowTo(char *CtrlStr)
+</programlisting>
+
+<para>Given the same CtrlStr as for GAGetArgs, can be used to print a one line
+'how to use'. </para>
+
+</sect2>
+</sect1>
+<sect1 id="sequential"><title>Sequential access</title>
+
+<para>If you are handling large images on an extremely memory-limited
+machine, you may need to use the following functions for sequential
+read and write. It's better to avoid them and use the simpler 
+DGifSlurp()/EGifSpew() interface.</para>
+
+<sect2><title>Sequential reading</title>
+
+<programlisting id="DGifGetScreenDesc">
+int DGifGetScreenDesc(GifFileType *GifFile)
+</programlisting>
+
+<para>Reads the screen information into the GifFile structure. Note this
+routine is automatically called once a file is opened, and therefore
+usually need not be called explicitly.</para>
+
+<para>Returns GIF_ERROR if something went wrong, GIF_OK otherwise.</para>
+
+<programlisting id="DGifGetRecordType">
+int DGifGetRecordType(GifFileType *GifFile, GifRecordType *GifType)
+</programlisting>
+
+<para>As the GIF file can have different records in arbitrary order, this
+routine should be called once the file was open to detect the next
+record type, and act upon it.  It can return these types in GifType:</para>
+
+<variablelist>
+<varlistentry>
+<term>1. UndefinedRecordType </term>
+<listitem>
+<para>something is wrong!</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>2. ScreenDescRecordType </term>
+<listitem>
+<para>screen information.  As the screen info is automatically read in when the file is open, this should not happen.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>3. ImageDescRecordType </term>
+<listitem>
+<para> next record is an image descriptor.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>4. ExtensionRecordType</term>
+<listitem>
+<para> next record is extension block.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>5. TrailerRecordType</term>
+<listitem>
+<para>last record reached, can close the file.</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+<para>The first two types can usually be ignored. The function
+returns GIF_ERROR if something went wrong, GIF_OK otherwise.</para>
+
+<programlisting id="DGifGetImageDesc">
+int DGifGetImageDesc(GifFileType *GifFile)
+</programlisting>
+
+<para>Reads image information into the GifFile structure.
+Returns GIF_ERROR if something went wrong, GIF_OK otherwise.</para>
+
+<programlisting id="DGifGetLine">
+int DGifGetLine(GifFileType *GifFile, PixelType *GifLine, int GifLineLen)
+</programlisting>
+
+<para>Load a block of pixels from the GIF file.  The line can be
+of any length.  More than that, this routine may be interleaved with
+DGifGetPixel until all pixels have been read.</para>
+
+<para>Returns GIF_ERROR if something went wrong, GIF_OK otherwise.</para>
+
+<programlisting>
+int DGifGetPixel(GifFileType *GifFile, PixelType GifPixel)
+</programlisting>
+
+<para>Loads one pixel from the GIF file.  This routine may be interleaved
+with <link linkend="DGifGetLine">DGifGetLine()</link>, until all pixels are
+read.  Because of the overhead per each call, use of this routine is
+not recommended.</para>
+
+<para>Returns GIF_ERROR if something went wrong, GIF_OK otherwise.</para>
+
+<programlisting>
+int DGifGetExtension(
+        GifFileType *GifFile,
+        int *GifExtCode,
+        ByteType **GifExtension)
+</programlisting>
+
+<para>Loads an extension block from the GIF file.  Extension blocks
+are optional in GIF files.  This routine should be followed by
+<link linkend="DGifGetExtensionNext">DGifGetExtensionNext</link>.</para>
+
+<para>Returns GIF_ERROR if something went wrong, GIF_OK otherwise.</para>
+
+<para><programlisting id="DGifGetExtensionNext">
+int DGifGetExtensionNext(GifFileType *GifFile, ByteType **GifExtension)
+</programlisting>
+
+As extensions may contain more than one block, use this routine to
+continue after DGifGetExtension, until *GifExtension is NULL.</para>
+
+<para>Returns GIF_ERROR if something went wrong, GIF_OK otherwise.</para>
+
+<programlisting>
+int DGifGetCode(
+        GifFileType *GifFile, 
+        int *GifCodeSize, ByteType **GifCodeBlock)
+</programlisting>
+
+<para>It sometimes may be desired to read the compressed code as is
+without decoding it.  This routine does exactly that (with
+DGifGetCodeNext), and can be used instead of DGifGetLine.</para>
+
+<para>This compressed code information can be written out using the
+EGifPutCode/EGifPutCodeNext sequence (see gifpos.c for example).
+Returns GIF_ERROR if something went wrong, GIF_OK otherwise.</para>
+
+<programlisting id="DGifGetCodeNext">
+int DGifGetCodeNext(GifFileType *GifFile, ByteType **GifCodeBlock)
+</programlisting>
+
+<para>See DGifGetCode above.</para>
+	  
+<programlisting id="DGifGetLZCodes">
+int DGifGetLZCodes(GifFileType *GifFile, int *GifCode)
+</programlisting>
+
+<para>This routine can be called instead of DGifGetLine/DGifGetPixel or
+DGifGetCode/DGifGetCodeNext to get the 12 bits LZ codes of the images.
+It will be used mainly for debugging purposes (see GifText.c for
+example).</para>
+
+<para>Returns GIF_ERROR if something went wrong, GIF_OK otherwise.</para>
+
+<programlisting id="DGifCloseFile">
+int DGifCloseFile(GifFileType *GifFile, int *ErrorCode)
+</programlisting>
+
+<para>Write a termination block to the GIF, close the GIF file and
+free all memory allocated for managing it. GifFile should not be used after
+this routine has been called.</para>
+
+<para>Returns GIF_ERROR if something went wrong, GIF_OK otherwise. When
+GIF_ERROR is returned, the diagnostic error code is left in ErrorCode.
+The GifFile structure is unconditionally freed.</para>
+
+<para>(Note: In versions before 5.1.0, the ErrorCode argument was
+absent and the GifFile structure was not freed so that the
+diagnostic error code will remain accessible in GifFile->Error.
+This behavior was changed because it caused problems for the
+implementation of library wrappers in dynamic languages.)</para>
+
+<programlisting id="DGetGifVersion">
+const char * DGifGetGifVersion(GifFileType *GifFile)
+</programlisting>
+
+<para>Get the GIF version collected during sequential read. This is
+handy for sequential API users who want to set an encoder's version
+from a decoder (e.g. for gif resizing). For the all-at-once users this
+isn't necessary because gif encoder inspects all the extension blocks,
+but sequential users do not have that luxury.</para>
+
+</sect2>
+<sect2><title>Sequential writing</title>
+
+<para>If you are handling large images on a memory-limited machine, you may need
+to use the following functions for sequential write.</para>
+
+<programlisting id="EGifOpenFileName">
+GifFileType *EGifOpenFileName(char *GifFileName, bool GifTestExistance, int *ErrorCode)
+</programlisting>
+
+<para>Open a new GIF file using the given GifFileName (in binary mode,
+if under Windows).  If GifTestExistance is TRUE, and file exists, the
+file is not destroyed, and NULL returned.</para>
+
+<para>If any error occurs, NULL is returned and the ErrorCode is set.</para>
+
+<programlisting id="EGifOpenFileHandle">
+GifFileType *EGifOpenFileHandle(int GifFileHandle, int *ErrorCode)
+</programlisting>
+
+<para>Open a new GIF file using the given GifFileHandle.</para>
+
+<para>If any error occurs, NULL is returned and ErrorCode is set.</para>
+
+<para>The file is opened in binary mode, and its buffer size is set to
+FILE_BUFFER_SIZE bytes.</para>
+
+<programlisting>
+char *EGifGetGifVersion(GifFileType *GifFile)
+</programlisting>
+
+<para>That version computation is available through this function.</para>
+
+<programlisting id="EGifSetGifVersion">
+void EGifSetGifVersion(GifFileType *GifFile, bool gif89)
+</programlisting>
+
+<para>Set the GIF type, to GIF89 if the argument is true and GIF87 if
+it is false.  The default type is GIF87. This function may be called
+aftert the GifFile record is allocated but before
+EGifPutScreenDesc().</para>
+
+<programlisting>
+int EGifPutScreenDesc(GifFileType *GifFile,
+        const int GifWidth, const GifHeight,
+        const int GifColorRes, const int GifBackGround,
+        ColorMapObject *GifColorMap)
+</programlisting>
+
+<para>Update the GifFile Screen parameters, in GifFile structure and in
+the real file.  If error occurs, returns GIF_ERROR (see gif_lib.h),
+otherwise GIF_OK.</para>
+
+<para>This routine should be called immediately after the GIF file was
+opened.</para>
+
+<programlisting>
+int EGifPutImageDesc(GifFileType *GifFile,
+        const int GifLeft, const int GifTop,
+        const int GifWidth, const GifHeight,
+        const bool GifInterlace,
+        ColorMapObject *GifColorMap)
+</programlisting>
+
+<para>Update GifFile Image parameters, in GifFile structure and in the real
+file. if error occurs returns GIF_ERROR (see gif_lib.h), otherwise
+GIF_OK.</para>
+
+<para>This routine should be called each time a new image must be
+dumped to the file.</para>
+
+<programlisting id="EGifPutLine">
+int EGifPutLine(GifFileType *GifFile, PixelType *GifLine, int GifLineLen)
+</programlisting>
+
+<para>Dumps a block of pixels out to the GIF file.  The slab can be of
+any length.  More than that, this routine may be interleaved with
+<link linkend="EGifPutPixel">EGifPutPixel()</link>, until all pixels
+have been sent.</para>
+
+<para>Returns GIF_ERROR if something went wrong, GIF_OK otherwise.</para>
+
+<programlisting id="EGifPutPixel">
+int EGifPutPixel(GifFileType *GifFile, const PixelType GifPixel)
+</programlisting>
+
+<para>Dumps one pixel to the GIF file.  This routine may be interleaved with
+<link linkend="EGifPutLine">EGifPutLine()</link>, until all pixels were sent.
+Because of the overhead for each call, use of this routine is not
+recommended.</para>
+
+<para>Returns GIF_ERROR if something went wrong, GIF_OK otherwise.</para>
+
+<programlisting id="EGifPutComment">
+int EGifPutComment(GifFileType *GifFile, char *GifComment)
+</programlisting>
+
+<para>Uses extension GIF records to save a string as a comment is the file.
+The extension code is 'C' (for Comment).</para>
+
+<para>Returns GIF_ERROR if something went wrong, GIF_OK otherwise.</para>
+
+<programlisting id="EGifPutExtension">
+int EGifPutExtension(
+        GifFileType *GifFile,
+        const int GifExtCode,
+        const int GifExtLen,
+        void *GifExtension)
+</programlisting>
+
+<para>Dumps the given extension block into the GIF file. Extension blocks
+are optional in GIF file. Extension blocks of more than 255 bytes or
+more than one block are not supported in this function.  Please use
+EGifPutExtensionFirst, EGifPutExtensionBlock, and EGifPutExtensionTrailer
+if your extension blocks may fall into this category.</para>
+
+<para>Returns GIF_ERROR if something went wrong, GIF_OK otherwise.</para>
+
+<programlisting id="EGifPutExtensionLeader">
+int EGifPutExtensionLeader(
+        GifFileType * GifFile,
+        const int GifExtCode)
+</programlisting>
+
+<para>Dumps the beginning of a GIF extension block to a GIF file.
+Extension blocks are optional in GIF files.  This function outputs the
+type code information necessary for a GIF extension block.</para>
+
+<para>Further blocks of the GIF Extension should be dumped using
+EGifPutExtensionBlock.  When finished with this extension block,
+EGifPutExtensionTrailer should be called to output the block termination.</para>
+
+<para>Returns GIF_ERROR if something went wrong, GIF_OK otherwise.</para>
+
+<programlisting id="EGifPutExtensionBlock">
+int EGifPutExtensionBlock(
+        GifFileType * GifFile,
+        const int GifExtLen,
+        const VoidPtr GifExtension)
+</programlisting>
+
+<para>Dumps a subblock of a GIF extension to a GIF File; should be
+used only following an initializing call to EGifPutExtensionLeader().
+Extension blocks are optional in GIF files.  This function will write
+the Extension Data in GifExtension to the file as a subblock of the
+preceding Extension Block.  Repeat calling of this function until all
+data subblocks have been output.</para>
+
+<para>Note that EGifPutExtensionLeader needs to be called before any
+calls to this function.  EGifPutExtensionTrailer should be called to
+finish the Extension block after all data subblocks have been
+output.</para>
+
+<para>Returns GIF_ERROR if something went wrong, GIF_OK otherwise.</para>
+
+<programlisting id="EGifPutExtensionTrailer">
+int EGifPutExtensionTrailer(
+        GifFileType * GifFile,
+        const VoidPtr GifExtension)
+</programlisting>
+
+<para>Dumps the GIF extension block terminator to a GIF File to end
+the current Extension block.</para>
+
+<para>Note that a call to EGifPutExtensionLeader is needed to open the GIF
+Extension Block prior to calling this function.</para>
+
+<para>Returns GIF_ERROR if something went wrong, GIF_OK otherwise.</para>
+
+<programlisting id="EGifPutCode">
+int EGifPutCode(
+        GifFileType *GifFile,
+        int *GifCodeSize,
+        ByteType **GifCodeBlock)
+</programlisting>
+
+<para>It sometimes may be desired to write the compressed code as is
+without decoding it.  For example a filter for a GIF file that change
+only screen size (GifPos), does not need the exact pixel values.
+Piping out the compressed image as is makes this process much
+faster.</para>
+
+<para>This routine does exactly that (with EGifPutCodeNext), and can be
+used instead of EGifPutLine.  You'll usually use this with the
+DGifGetCode/DgifGetCodeNext routines, which reads the compressed
+code, while EGifPutCode/EGifPutCodeNext write it out.  See gifpos.c
+for example.</para>
+
+<para>Returns GIF_ERROR if something went wrong, GIF_OK otherwise.</para>
+
+<programlisting id="EGifPutCodeNext">
+int EGifPutCodeNext(GifFileType *GifFile, ByteType **GifCodeBlock)
+</programlisting>
+
+<para>See EGifPutCode above.</para>
+
+<programlisting id="EGifCloseFile">
+int EGifCloseFile(GifFileType *GifFile)
+</programlisting>
+
+<para>Write a termination block to the GIF, close the GIF file, and
+free all memory allocated for managing it. GifFile should not be used
+after this routine has been called.</para>
+
+<para>Returns GIF_ERROR if something went wrong, GIF_OK otherwise. When
+GIF_ERROR is returned, the diagnostic error code is left in ErrorCode.
+The GifFile structure is unconditionally freed.</para>
+
+<para>(Note: In versions before 5.1.0, the ErrorCode argument was
+absent and the GifFile structure was not freed so that the
+diagnostic error code will remain accessible in GifFile->Error.
+This behavior was changed because it caused problems for the
+implementation of library wrappers in dynamic languages.)</para>
+</sect2>
+
+</sect1>
+<sect1 id="compatibility"><title>Forward and Backward Compatibility</title>
+
+<para>Except for some details of extension-block handling and the addition
+of read/write function hooks, the DGifSlurp()/EGifSpew() interface has
+been stable since 1990.  It is expected to remain so.</para>
+
+<para>However, the signatures of the file-opener functions were changed in 5.0
+in order to make the library fully reentrant and thread-safe - earlier library
+versions did not feature the final pointer-to-error-code argument in 
+DGifOpen() and friends.  For the same reason, the static storage queried by
+GifLastError() in older versions is gone, and that function abolished.</para>
+
+<para>The library header contains some version #defines you can use if you
+need to condition your code so it can compile with different library 
+versions</para>
+
+<para>Versions up to 4.1.6 defined a GIF_LIB_VERSION macro that was
+string-valued with a tricky format to parse.  This macro has been
+retired.</para>
+
+<para>Versions after 4.1.6 define integer-valued GIFLIB_MAJOR, GIFLIB_MINOR,
+and GIFLIB_RELEASE macros for the three components of the version. See the
+NEWS file in the GIFLIB distribution to track API changes.</para>
+
+<para>The following functions are entirely new:</para>
+
+<itemizedlist>
+<listitem><para>New functions DGifSavedExtensionToGCB() and
+EGifGCBToSavedExtension() make it easy to read and edit GIF89 graphics
+control blocks in saved images.</para></listitem>
+<listitem><para>The new function DGifGetGifVersion() is convenient
+for people doing sequential reads.</para></listitem>
+</itemizedlist>
+
+<para>A few changes in behavior were introduced in 5.0:</para>
+
+<sect2><title>General behavior</title>
+
+<itemizedlist>
+<listitem><para>The library is now fully re-entrant and
+thread-safe.</para></listitem>
+</itemizedlist>
+<itemizedlist>
+<listitem><para>  All functions exported by this library now have DGif,
+EGif, or Gif as a name prefix.</para></listitem>
+<listitem><para>The default GIF version to write is now computed at
+write time from the types of an image's extension blocks. (Formerly
+EGifSpew() behaved this way, but the sequential-writing code didn't.)
+The result of this computation is available through the new function
+EGifGetGifVersion().</para></listitem>
+</itemizedlist>
+
+</sect2>
+<sect2><title>In documented functions:</title>
+
+<itemizedlist>
+<listitem><para>GIF file openers and closers - DGifOpenFileName(),
+DGifOpenFileHandle(), DGifOpen(), DGifClose(), EGifOpenFileName(),
+EGifOpenFileHandle(), EGifOpen(), and EGifClose() - all now take a
+final integer address argument.  If non-null, this is used to pass
+back an error code when the function returns NULL.</para></listitem>
+<listitem><para>EGifSlurp() and EGifSpew() read and write
+extension blocks trailing after the last image, handle interlaced 
+images properly.</para></listitem>
+<listitem><para>EGifPutExtensionFirst() has been replaced by
+EGifPutExtensionLeader(); the difference is the new function doesn't
+take an optional block, it just writes a block
+leader.</para></listitem>
+<listitem><para>EGifPutExtensionNext() has been replaced by
+EGifPutExtensionBlock(); the difference is that the new function does
+not take and then discard a function code argument.</para></listitem>
+<listitem><para>EGifPutExtensionLast() has been replaced by
+EGifPutExtensionTrailer(); all it does is write the terminator
+block.  Split your old EGifPutExtensionLast() calls into
+EGifPutExtensionBlock() followed by
+EGifPutExtensionTrailer().</para></listitem>
+</itemizedlist>
+
+</sect2>
+<sect2><title>In undocumented functions:</title>
+
+<itemizedlist>
+<listitem><para>Some undocumented functions have been renamed. 
+AddExtensionBlock() is now GifAddExtensionBlock(), and takes an additional
+function code argument.  ApplyTranslation() is now GifApplyTranslation();
+FreeExtension() has become GifFreeExtensions() and takes a different argument
+type; MakeSavedImage() is now GifMakeSavedImage(), FreeSavedImages() is
+now GifFreeSavedImages(), and BitSize() is now GifBitSize().</para></listitem>
+<listitem><para>Three documented functions - MakeMapObject(),
+FreeMapObject(), and UnionColorMap() - have been renamed to
+GifMakeMapObject(), GifFreeMapObject(), and GifUnionColorMap()
+respectively.</para></listitem>
+</itemizedlist>
+
+</sect2>
+<sect2><title>Error handling:</title>
+
+<itemizedlist>
+<listitem><para>Library error handling no longer uses a static cell to
+store the last error code registered; that made the library
+thread-unsafe.</para></listitem>
+<listitem><para>For functions other than GIF file openers, the Error
+code is now put in an Error member of the GifFileType
+structure.</para></listitem>
+<listitem><para>The GifError() and
+GifLastError() functions that referenced that static cell are gone,
+and the GifErrorString() function introduced in the 4.2 release now
+takes an explicit error code argument.</para></listitem>
+</itemizedlist>
+</sect2>
+</sect1>
+<sect1><title>Skeletons of GIF filters</title>
+
+<para>If you are developing on a virtual-memory OS such as most flavors of
+UNIX, or are otherwise sure of having enough memory to keep all of GIFs you
+need to operate in core, writing a filter is trivial.   See the file
+gifsponge.c in util.</para>
+
+<para>A sequential filter skeleton will usually look like the example file
+giffilter.c in util.</para>
+
+<para>Please look at the utilities in the util directory for more ideas once
+you feel comfortable with these skeletons.  Also try to follow the coding
+standards of this package if you want the maintainer to officially add your new
+utility to it.</para>
+
+</sect1>
+<sect1><title>Unimplemented features</title>
+
+<para>Some features of the original GIF specification have not stood the
+test of time.  This library mostly ignores them, but they are described
+here for completeness.</para>
+
+<para>The GIF standard fails to be explicit about a small but crucial detail:
+the unsigned two-byte integer fields in it are little-endian.</para>
+
+<para>The GIF format seems to have been designed with the idea that viewers
+would render multiple images in a GIF on a common canvas, giving an effect like
+a picture wall.  The 'logical screen descriptor block' (LSDB), 6 bytes right
+after the 6-byte GIF stamp and version header at the beginning of a
+GIF file, includes both two-byte canvas width and canvas height
+fields and a canvas background color.  Each image, besides height and
+width, also has 'left' and 'top' cordinates specifying where it is to
+be placed on the canvas.</para>
+
+<para>GIFLIB can read and set these fields; the gifpos and giftool
+utilities will enable you to script such changes.  But browsers and
+modern image viewers ignore them. Nowadays multiple-image GIFs are 
+generally used either as animations in which each sub-image is a frame
+or as image libraries, with the GIF client handling compositing into
+some canvas about which the GIF format holds no information.</para>
+
+<para>Another feature of the LSDB that is generally ignored is the
+pixel aspect ratio byte.  Until 5.0, GIFLIB ignored this flag on input
+and zeroed it on output; now it is read and preserved if present.  The
+GIF standard doesn't give a rationale for it, but it seems likely that
+the designers intended it for representing image captures from the
+analog television of the day, which had rectangular pixel-equivalents.</para>
+
+<para>Yet another ignored feature of both the LSDB and sub-images is
+the sort flag, which is supposed to signal whether the colors in the
+associated color map are sorted by decreasing importance in case the
+display device can only render a limited number of them.  This feature
+reflected the high cost of dual-port memory at the time the GIF
+specification was written in the late 1980s.  That kind of limit
+disappeared in the mid-1990s.  Until 5.0, GIFLIB ignored this flag on
+input and zeroed it on output; now it is read and preserved if
+present.</para>
+
+<para>Finally, the plaintext extension block. This is an extension block 
+that contains instructions for overlaying text captions on a following image.
+GIFLIB treats these blocks as raw data, not attempting to parse out the 
+location and text data.</para>
+</sect1>
+</article>
diff --git a/doc/gifbg.xml b/doc/gifbg.xml
new file mode 100644
index 0000000..7409826
--- /dev/null
+++ b/doc/gifbg.xml
@@ -0,0 +1,145 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE refentry PUBLIC
+   "-//OASIS//DTD DocBook XML V4.1.2//EN"
+   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>
+<refentry id='gifbg.1'>
+<refentryinfo><date>2 May 2012</date></refentryinfo>
+<refmeta>
+<refentrytitle>gifbg</refentrytitle>
+<manvolnum>1</manvolnum>
+<refmiscinfo class="source">GIFLIB</refmiscinfo>
+<refmiscinfo class="manual">GIFLIB Documentation</refmiscinfo>
+</refmeta>
+<refnamediv id='name'>
+<refname>gifbg</refname>
+<refpurpose>generate a test-pattern GIF</refpurpose>
+</refnamediv>
+
+<refsynopsisdiv id='synopsis'>
+
+<cmdsynopsis>
+  <command>gifbg</command>
+      <arg choice='opt'>-v</arg>
+      <arg choice='opt'>-d <replaceable>dir</replaceable></arg>
+      <arg choice='opt'>-l <replaceable>lvls</replaceable></arg>
+      <arg choice='opt'>-c 
+      		<replaceable>R</replaceable>
+      		<replaceable>G</replaceable>
+      		<replaceable>B</replaceable></arg>
+      <arg choice='opt'>-m <replaceable>min</replaceable></arg>
+      <arg choice='opt'>-o <replaceable>max</replaceable></arg>
+      <arg choice='opt'>-s 
+      		<replaceable>w</replaceable>
+		<replaceable>h</replaceable></arg>
+      <arg choice='opt'>-h</arg>
+</cmdsynopsis>
+</refsynopsisdiv>
+
+<refsect1><title>Description</title>
+
+<para>A program to generate a single-color test pattern GIF with
+gradually changing intensity in any of the basic 8 directions.</para>
+
+<para>The gifbg program reads no input, and will dump the created GIF file
+to stdout.</para>
+
+</refsect1>
+<refsect1><title>Options</title>
+
+<variablelist>
+<varlistentry>
+<term>-v</term>
+<listitem>
+<para> Verbose mode (show progress). 
+Enables printout of running scan lines.</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-d dir</term>
+<listitem>
+<para>Select direction the intensity of the background should
+increase. Direction can be one of the 8 principal directions:</para>
+<variablelist>
+<varlistentry>
+<term>"T"</term>
+<listitem><para>for Top</para></listitem></varlistentry>
+<varlistentry>
+<term>"TR"</term>
+<listitem><para>for Top Right</para></listitem></varlistentry>
+<varlistentry>
+<term>"R"</term>
+<listitem><para>for Right</para></listitem></varlistentry>
+<varlistentry>
+<term>"BR"</term>
+<listitem><para>for Bottom Right</para></listitem></varlistentry>
+<varlistentry>
+<term>"B"</term>
+<listitem><para>for Bottom</para></listitem></varlistentry>
+<varlistentry>
+<term>"BL"</term>
+<listitem><para>for Bottom Left</para></listitem></varlistentry>
+<varlistentry>
+<term>"L"</term>
+<listitem><para>for left</para></listitem></varlistentry>
+<varlistentry>
+<term>"TL"</term>
+<listitem><para>for Top Left</para></listitem></varlistentry>
+</variablelist>
+<para>The compass directions may be use as synonyms for the above directions, so
+for example "NE" is equal to "TR".</para>
+<para>Direction is case insensitive. The default direction is Top
+(North).</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term> -l lvls</term>
+<listitem>
+<para> Numeric, nmber of levels the color will be scaled to. Default is 16.</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term> -c R G B</term>
+<listitem>
+<para> What to use as the primary background color to scale. This
+color is scaled between the minimum intensity (min) and maximum
+intensity (max) from one end of the screen to the other as defined by
+dir.  See below (-m &amp; -M) for min &amp; max. Default is Blue (0,
+0, 255).</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term> -m min</term>
+<listitem>
+<para> Minimum intensity (in percent) to scale color.  Default 10%</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term> [-M max</term>
+<listitem>
+<para> Maximum intensity (in percent) to scale color.  Default 100%</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term> -s W H</term>
+<listitem>
+<para> Size of image to create.  Default 640 by 350.</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term> -h</term>
+<listitem>
+<para> Print one line of command line help, similar to Usage above.</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+<para>If min == max = 100 (%) and lvls == 2 then boolean mask image
+of specified size will be created - all foreground.</para>
+
+</refsect1>
+<refsect1><title>Author</title>
+
+<para>Gershon Elber.</para>
+
+</refsect1>
+</refentry>
diff --git a/doc/gifbuild.xml b/doc/gifbuild.xml
new file mode 100644
index 0000000..7cbe041
--- /dev/null
+++ b/doc/gifbuild.xml
@@ -0,0 +1,217 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE refentry PUBLIC
+   "-//OASIS//DTD DocBook XML V4.1.2//EN"
+   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
+<!ENTITY email         "esr@thyrsus.com">
+]>
+<refentry id='gifbuild.1'>
+<refentryinfo><date>2 May 2012</date></refentryinfo>
+<refmeta>
+<refentrytitle>gifbuild</refentrytitle>
+<manvolnum>1</manvolnum>
+<refmiscinfo class="source">GIFLIB</refmiscinfo>
+<refmiscinfo class="manual">GIFLIB Documentation</refmiscinfo>
+</refmeta>
+<refnamediv id='name'>
+<refname>gifbuild</refname>
+<refpurpose>dump GIF data in a textual format, or undump it to a GIF</refpurpose>
+</refnamediv>
+
+<refsynopsisdiv id='synopsis'>
+
+<cmdsynopsis>
+  <command>gifbuild</command>
+      <arg choice='opt'>-v</arg>
+      <arg choice='opt'>-a</arg>
+      <arg choice='opt'>-d</arg>
+      <arg choice='opt'>-t <replaceable>translation-table</replaceable></arg>
+      <arg choice='opt'>-h</arg>
+      <arg choice='opt'><replaceable>gif-file</replaceable></arg>
+</cmdsynopsis>
+</refsynopsisdiv>
+
+<refsect1><title>Options</title>
+
+<para>A program to convert a series of editable text GIF icon specifications and
+named GIF files into a multi-image GIF, usable as a graphic resource file.
+It can also dump existing GIFs in this format.  When dumping a GIF,
+certain sanity checks are performed which may result in a warning
+emitted to standard error.</para>
+
+<para>If no GIF file is given, gifbuild will try to read a text input
+from stdin.</para>
+
+</refsect1>
+<refsect1><title>Specification Syntax</title>
+
+<para>Here is a syntax summary in informal BNF.  The token `NL' represents a
+required newline.</para>
+
+<programlisting>
+&lt;gif-spec&gt; ::= &lt;header-block&gt; &lt;image-block&gt;...
+
+&lt;header-block&gt; ::= &lt;header-declaration&gt;...
+
+&lt;header-declaration ::=
+		| screen width &lt;digits&gt; NL
+		| screen height &lt;digits&gt; NL
+		| screen colors &lt;digits&gt; NL
+		| screen background &lt;digits&gt; NL
+		| pixel aspect byte &lt;digits&gt; NL
+		| screen map &lt;color-table&gt; NL
+
+&lt;color-table&gt; ::= &lt;color-declaration&gt;... end NL
+
+&lt;color-declaration&gt; ::= rgb &lt;digits&gt; &lt;digits&gt; &lt;digits&gt; [ is &lt;key&gt;] NL
+                | sort flag {on|off} NL
+
+&lt;image-block&gt; ::= include &lt;file-name&gt; NL
+		| image NL
+			&lt;image-declaration&gt;...
+			&lt;raster-picture&gt;
+			[ &lt;extension&gt; ]
+
+&lt;image-declarations&gt; ::= image top &lt;digits&gt; NL
+			| image left &lt;digits&gt; NL
+			| image interlaced NL
+			| image map &lt;color-table&gt; NL
+			| image bits &lt;digits&gt; by &lt;digits&gt; [hex|ascii] NL &lt;raster-block&gt;
+
+&lt;extension&gt; := &lt;comment&gt; NL &lt;extension-block&gt; NL end NL
+		| &lt;plaintext&gt; NL &lt;extension-block&gt; NL end NL
+                | graphics control NL &lt;GCB-part&gt; NL end NL
+                | netscape loop  &lt;digits&gt; NL
+		| extension &lt;hex-digits&gt; NL &lt;extension-block&gt; NL end NL
+
+&lt;GCB-part&gt; ::= disposal mode &lt;digits&gt; NL
+                | user input flag {on|off} NL
+                | delay &lt;digits&gt; NL
+                | transparent index &lt;digits&gt; NL
+
+</programlisting>
+
+<para>If the data types of the <quote>screen height</quote>,
+<quote>screen width</quote>, <quote>screen background</quote>,
+<quote>image top</quote>, and <quote>image left</quote> declarations
+aren't obvious to you, what are you doing with this software?</para>
+
+<para>The <quote>pixel aspect byte</quote> declaration sets an integer 
+denominator for a fraction expressing the puxel aspect ratio.  See the
+GIF standard for details; this field is actually long obsolete.</para>
+
+<para>A color table declares color indices (in ascending order from 0)
+and may associate them with key characters (these associations are
+absent when the map is more than 94 colors lang and raster blocks
+using it must use hex pairs).  These characters can later be used in
+raster blocks.  As these must be printable and non-whitespace, you can
+only specify 94 colors per icon.  Life is like that sometimes.</para>
+
+<para>A color table declaration can also set the table's sort flag with 
+"sort flag on" or "sort flag off" on any line before the end.</para>
+
+<para>An <quote>ascii</quote> raster block is just a block of key
+characters (used for a color map of 94 or fewer colors).  A
+<quote>hex</quote> raster block uses hex digit pairs instead (used for
+a color map with more than 94 colors). The default is ASCII.  It
+should be sized correctly for the <quote>image bits</quote>
+declaration that leads it. Raster blocks from interlaced GIFs are
+dumped with the lines in non-interlaced order.</para>
+
+<para>The <quote>comment</quote>, <quote>plaintext</quote> or
+<quote>ggraphics control</quote> keywords lead defined GIF89 extension
+record data. The final GIF89 type, graphics control and application
+block, are not yet supported, but the code does recognize a Netscape
+loop block.  You can also say <quote>extension</quote> followed by a
+hexadecimal record type.  All of these extension declarations must be
+followed by an extension block, which is terminated by the keyword
+<quote>end</quote> on its own line.</para>
+
+<para>An extension block is a series of text lines, each interpreted
+as a string of bytes to fill an extension block (the terminating
+newline is stripped).  Text may include standard C-style octal and hex
+escapes preceded by a backslash.</para>
+
+<para>A graphics control block declaration creates a graphics control
+extension block; for the field semantics see the GIF89 standard, part
+23.</para>
+
+<para>A netscape loop declaration creates an application extension
+block containing a NETSCAPE 2.0 animation loop control with a
+specified repeat count (repeat count 0 means loop forever). This must
+be immediately after the header declaration. These loop blocks are
+interpreted by the Netscape/Mozilla/Firefox line of browsers.</para> 
+
+<para>All &lt;digits&gt; tokens are interpreted as decimal numerals;
+&lt;hex-digits&gt; tokens are interpreted as two hex digits (a byte). All
+coordinates are zero-origin with the top left corner (0,0).  Range
+checking is weak and signedness checking nonexistent; caveat
+hacker!</para>
+
+<para>In general, the amount of whitespace and order of declarations within a 
+header or image block is not significant, except that a raster picture
+must immediately follow its <quote>image bits</quote> bits declaration.</para>
+
+<para>The <quote>include</quote> declaration includes a named GIF as
+the next image.  The global color maps of included GIFs are merged
+with the base table defined by any <quote>screen color</quote>
+declaration.  All images of an included multi-image GIF will be
+included in order.</para>
+
+<para>Comments (preceded with <quote>#</quote>) will be ignored.</para>
+
+</refsect1>
+<refsect1><title>Options</title>
+
+<variablelist>
+<varlistentry>
+<term>-v</term>
+<listitem>
+<para>Verbose mode (show progress).
+Enables printout of running scan lines.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>-d</term>
+<listitem>
+<para> Dump the input GIF file(s) into the text form described
+above.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>-t</term>
+<listitem>
+<para>Specify name characters to use when dumping raster blocks.  Only
+valid with -d option.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>-h</term>
+<listitem>
+<para>Print one line of command line help, similar to Usage
+above.</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+</refsect1>
+<refsect1><title>Bugs</title>
+
+<para>Error checking is rudimentary.</para>
+
+</refsect1>
+<refsect1><title>Example:</title>
+
+<para>A sample icon file called <filename>sample.ico</filename> is
+included in the pic directory of the GIFLIB source
+distribution.</para>
+
+</refsect1>
+<refsect1><title>Author</title>
+
+<para>Eric S. Raymond <email>&email;</email></para>
+
+</refsect1>
+</refentry>
diff --git a/doc/gifclrmp.xml b/doc/gifclrmp.xml
new file mode 100644
index 0000000..7b337a6
--- /dev/null
+++ b/doc/gifclrmp.xml
@@ -0,0 +1,116 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE refentry PUBLIC
+   "-//OASIS//DTD DocBook XML V4.1.2//EN"
+   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>
+<refentry id='gifclrmp.1'>
+<refentryinfo><date>2 May 2012</date></refentryinfo>
+<refmeta>
+<refentrytitle>gifclrmp</refentrytitle>
+<manvolnum>1</manvolnum>
+<refmiscinfo class="source">GIFLIB</refmiscinfo>
+<refmiscinfo class="manual">GIFLIB Documentation</refmiscinfo>
+</refmeta>
+<refnamediv id='name'>
+<refname>gifclrmp</refname>
+<refpurpose>extract colormaps from GIF images</refpurpose>
+</refnamediv>
+
+<refsynopsisdiv id='synopsis'>
+
+<cmdsynopsis>
+  <command>gifclrmp</command>
+      <arg choice='opt'>-v</arg>
+      <arg choice='opt'>-s</arg>
+      <arg choice='opt'>-l <replaceable>mapfile</replaceable></arg>
+      <arg choice='opt'>-t <replaceable>trans</replaceable></arg>
+      <arg choice='opt'>-g <replaceable>gamma</replaceable></arg>
+      <arg choice='opt'>-i <replaceable>image</replaceable></arg>
+      <arg choice='opt'>-h</arg>
+      <arg choice='opt'><replaceable>gif-file</replaceable></arg>
+</cmdsynopsis>
+</refsynopsisdiv>
+
+<refsect1><title>Description</title>
+
+<para>A program to modify GIF image colormaps.  Any local colormap in
+a GIF file can be modified at a time, or the global screen one.</para>
+
+</refsect1>
+<refsect1><title>Options</title>
+
+<variablelist>
+<varlistentry>
+<term>-v</term>
+<listitem>
+<para> Verbose mode (show progress).  
+Enables printout of running scan lines. </para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-s</term>
+<listitem>
+<para>Select the global screen color map.</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-l mapfile</term>
+<listitem>
+<para> Load color map from this file instead of selected color
+map.</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-t trans</term>
+<listitem>
+<para>Change color index values.  The change is made to both the
+selected color table and the raster bits of the selected image.  A
+translation file is a list of pairs of `before' and `after' index
+values. At present, the `before' index values must be in ascending
+order starting from 0.</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-g gamma</term>
+<listitem>
+<para>Apply gamma correction to selected color map.</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-i image</term>
+<listitem>
+<para>Select the color map of the numbered image.</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-h</term>
+<listitem>
+<para>Print one command line help, similar to Usage above.</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+<para>If no GIF file is given, gifclip will try to read a GIF file
+from stdin.</para>
+
+</refsect1>
+<refsect1><title>Notes</title>
+
+<itemizedlist>
+<listitem>
+<para>The default operation is to dump out the selected color map in text
+format.</para>
+</listitem>
+<listitem>
+<para>The file to load/dump is simply one color map entry per line.  Each such
+entry line has four integers: "ColorIndex Red Green Blue", where color
+index is in ascending order starting from 1.</para>
+</listitem>
+</itemizedlist>
+
+</refsect1>
+<refsect1><title>Author</title>
+
+<para>Gershon Elber.</para>
+
+</refsect1>
+</refentry>
diff --git a/doc/gifcolor.xml b/doc/gifcolor.xml
new file mode 100644
index 0000000..1fac010
--- /dev/null
+++ b/doc/gifcolor.xml
@@ -0,0 +1,78 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE refentry PUBLIC
+   "-//OASIS//DTD DocBook XML V4.1.2//EN"
+   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>
+<refentry id='gifcolor.1'>
+<refentryinfo><date>2 May 2012</date></refentryinfo>
+<refmeta>
+<refentrytitle>gifcolor</refentrytitle>
+<manvolnum>1</manvolnum>
+<refmiscinfo class="source">GIFLIB</refmiscinfo>
+<refmiscinfo class="manual">GIFLIB Documentation</refmiscinfo>
+</refmeta>
+<refnamediv id='name'>
+<refname>gifcolor</refname>
+<refpurpose>generate color test-pattern GIFs</refpurpose>
+</refnamediv>
+
+<refsynopsisdiv id='synopsis'>
+
+<cmdsynopsis>
+  <command>gifcolor</command>
+      <arg choice='opt'>-v</arg>
+      <arg choice='opt'>-b <replaceable>background</replaceable></arg>
+      <arg choice='opt'>-h</arg>
+      <arg choice='opt'><replaceable>colormap-file</replaceable></arg>
+</cmdsynopsis>
+</refsynopsisdiv>
+
+<refsect1><title>Description</title>
+
+<para>A program to generate color test patterns.  Feed it a color map file (as
+generated, say, by the -s option of gifclrmp) and it will generate a GIF
+containing lines of the form.</para>
+
+<programlisting>
+Color %-3d: [%-3d, %-3d, %-3d]:
+</programlisting>
+
+<para>where the first number is the zero-based color index, and the
+triple is the index's [Red, Green, Blue] value.  There will be one
+such line for each color.  Each line will be set in a simple 8x8 font
+in the color it describes; thus, any lines corresponding to the GIF's
+background color will be blank.</para>
+
+</refsect1>
+<refsect1><title>Options</title>
+
+<variablelist>
+<varlistentry>
+<term>-v</term>
+<listitem>
+<para>Verbose mode (show progress).
+Enables printout of running scan lines. </para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-b</term>
+<listitem>
+<para>Set the image's backround color to a given numeric index.</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-h</term>
+<listitem>
+<para>Print one line of command line help, similar to Usage above.</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+<para>If no colormap file is specified, the color map will be read from stdin.</para>
+
+</refsect1>
+<refsect1><title>Author</title>
+
+<para>Gershon Elber.</para>
+
+</refsect1>
+</refentry>
diff --git a/doc/gifecho.xml b/doc/gifecho.xml
new file mode 100644
index 0000000..583cc37
--- /dev/null
+++ b/doc/gifecho.xml
@@ -0,0 +1,103 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE refentry PUBLIC
+   "-//OASIS//DTD DocBook XML V4.1.2//EN"
+   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>
+<refentry id='gifecho.1'>
+<refentryinfo><date>2 May 2012</date></refentryinfo>
+<refmeta>
+<refentrytitle>gifecho</refentrytitle>
+<manvolnum>1</manvolnum>
+<refmiscinfo class="source">GIFLIB</refmiscinfo>
+<refmiscinfo class="manual">GIFLIB Documentation</refmiscinfo>
+</refmeta>
+<refnamediv id='name'>
+<refname>gifecho</refname>
+<refpurpose>generate a GIF from ASCII text</refpurpose>
+</refnamediv>
+
+<refsynopsisdiv id='synopsis'>
+
+<cmdsynopsis>
+  <command>gifecho</command>
+      <arg choice='opt'>-v</arg>
+      <arg choice='opt'>-s <replaceable>colormap-size</replaceable></arg>
+      <arg choice='opt'>-f <replaceable>foreground</replaceable></arg>
+      <arg choice='opt'>-c 
+      		<replaceable>R</replaceable>
+      		<replaceable>G</replaceable>
+      		<replaceable>B</replaceable></arg>
+      <arg choice='opt'>-t <replaceable>text</replaceable></arg>
+      <arg choice='opt'>-h</arg>
+      <arg choice='opt'><replaceable>gif-file</replaceable></arg>
+</cmdsynopsis>
+</refsynopsisdiv>
+
+<refsect1><title>Description</title>
+
+<para>A program to generate GIF images out of regular text.  Text can
+be one line or multi-line, and is converted using 8 by 8 fixed
+font.</para>
+
+<para>This program reads stdin if no text is provided on the command line (-t),
+and will dump the created GIF file to stdout.</para>
+
+</refsect1>
+<refsect1><title>Options</title>
+
+<variablelist>
+<varlistentry>
+<term>-v</term>
+<listitem>
+<para>Verbose mode (show progress).
+Enables printout of running scan lines. </para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>-s colormap-size</term>
+<listitem>
+<para>Explicitly defines the size of the color map of the resulting gif image.  Usually the image will be bicolor with fg as color 1, unless [-f] is explicitly given in case the color map size will be big enough to hold it.  However it is sometimes convenient to set the color map size to certain size while the fg color is small mainly so this image may be merged with another (images must match color map size).</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>-f foreground</term>
+<listitem>
+<para> Select foreground index (background is always 0).  By default it is one and therefore the image result is bicolored. if FG is set to n then color map will be created with 2^k entries where 2^k &gt; n for minimum k, assuming k &lt;= 8.  This color map will be all zeros except this foreground index. This option is useful if this text image should be integrated into other image colormap using their colors.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>-c R G B</term>
+<listitem>
+<para> The color to use as the foreground color.  White by default.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>-t text</term>
+<listitem>
+<para> One line of text can be provided on the command line.  Note you must encapsulate the Text within quotes if it has spaces (The quotes themselves are not treated as part of the text).  If no -t option is provided, stdin is read until end of file.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>-h</term>
+<listitem>
+<para> Print one line command line help, similar to Usage above.</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+</refsect1>
+<refsect1><title>Notes</title>
+
+<para>There is a hardcoded limit of 100 the number of lines.</para>
+
+</refsect1>
+<refsect1><title>Author</title>
+
+<para>Gershon Elber.</para>
+
+</refsect1>
+</refentry>
diff --git a/doc/giffilter.xml b/doc/giffilter.xml
new file mode 100644
index 0000000..059e70e
--- /dev/null
+++ b/doc/giffilter.xml
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE refentry PUBLIC
+   "-//OASIS//DTD DocBook XML V4.1.2//EN"
+   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
+<!ENTITY email         "esr@thyrsus.com">
+]>
+<refentry id='giffilter.1'>
+<refentryinfo><date>2 May 2012</date></refentryinfo>
+<refmeta>
+<refentrytitle>giffilter</refentrytitle>
+<manvolnum>1</manvolnum>
+<refmiscinfo class="source">GIFLIB</refmiscinfo>
+<refmiscinfo class="manual">GIFLIB Documentation</refmiscinfo>
+</refmeta>
+<refnamediv id='name'>
+<refname>giffilter</refname>
+<refpurpose>expensive GIF copy, a model for filter utilities</refpurpose>
+</refnamediv>
+
+<refsynopsisdiv id='synopsis'>
+
+<cmdsynopsis>
+  <command>giffilter</command>
+</cmdsynopsis>
+</refsynopsisdiv>
+
+<refsect1><title>Description</title>
+
+<para>This is an expensive way to copy a GIF.  The source is included
+as a skeleton for more sophisticated filters.  See the source in the
+util directory for details.</para>
+
+<para>Also has some utility as a test of the sequential GIF record I/O
+routines.  The output should be bytewise identical to the input.</para>
+
+</refsect1>
+<refsect1><title>Author</title>
+
+<para>Eric S. Raymond <email>&email;</email></para>
+
+</refsect1>
+</refentry>
diff --git a/doc/giffix.xml b/doc/giffix.xml
new file mode 100644
index 0000000..fcf1145
--- /dev/null
+++ b/doc/giffix.xml
@@ -0,0 +1,63 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE refentry PUBLIC
+   "-//OASIS//DTD DocBook XML V4.1.2//EN"
+   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>
+<refentry id='giffix.1'>
+<refentryinfo><date>2 May 2012</date></refentryinfo>
+<refmeta>
+<refentrytitle>giffix</refentrytitle>
+<manvolnum>1</manvolnum>
+<refmiscinfo class="source">GIFLIB</refmiscinfo>
+<refmiscinfo class="manual">GIFLIB Documentation</refmiscinfo>
+</refmeta>
+<refnamediv id='name'>
+<refname>giffix</refname>
+<refpurpose>attempt to fix up broken GIFs</refpurpose>
+</refnamediv>
+
+<refsynopsisdiv id='synopsis'>
+
+<cmdsynopsis>
+  <command>giffix</command>
+      <arg choice='opt'>-v</arg>
+      <arg choice='opt'>-h</arg>
+      <arg choice='opt'><replaceable>gif-file</replaceable></arg>
+</cmdsynopsis>
+</refsynopsisdiv>
+
+<refsect1><title>Description</title>
+
+<para>A program that attempts to fix broken GIF images.  Currently will "fix"
+images terminated prematurely by filling the rest of the image with
+the darkest color found in the image.</para>
+
+<para>If no GIF file is given, giffix will try to read a GIF file from
+stdin.  The fixed file is dumped to stdout.</para>
+
+</refsect1>
+<refsect1><title>Options</title>
+
+<variablelist>
+<varlistentry>
+<term>-t</term>
+<listitem>
+<para>Verbose mode (show progress).
+Enables printout of running scan lines. </para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-h</term>
+<listitem>
+<para>Print one line of command line help, similar to Usage
+above.</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+</refsect1>
+<refsect1><title>Author</title>
+
+<para>Gershon Elber.</para>
+
+</refsect1>
+</refentry>
diff --git a/doc/gifhisto.xml b/doc/gifhisto.xml
new file mode 100644
index 0000000..14bd2e8
--- /dev/null
+++ b/doc/gifhisto.xml
@@ -0,0 +1,98 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE refentry PUBLIC
+   "-//OASIS//DTD DocBook XML V4.1.2//EN"
+   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>
+<refentry id='gifhisto.1'>
+<refentryinfo><date>2 May 2012</date></refentryinfo>
+<refmeta>
+<refentrytitle>gifhisto</refentrytitle>
+<manvolnum>1</manvolnum>
+<refmiscinfo class="source">GIFLIB</refmiscinfo>
+<refmiscinfo class="manual">GIFLIB Documentation</refmiscinfo>
+</refmeta>
+<refnamediv id='name'>
+<refname>gifhisto</refname>
+<refpurpose>make a color histogram from GIF colr frequencies</refpurpose>
+</refnamediv>
+
+<refsynopsisdiv id='synopsis'>
+
+<cmdsynopsis>
+  <command>gifhisto</command>
+      <arg choice='opt'>-v</arg>
+      <arg choice='opt'>-t</arg>
+      <arg choice='opt'>-s 
+      		<replaceable>width</replaceable>
+      		<replaceable>height</replaceable></arg>
+      <arg choice='opt'>-n <replaceable>image-number</replaceable></arg>
+      <arg choice='opt'>-b</arg>
+      <arg choice='opt'>-h</arg>
+      <arg choice='opt'><replaceable>gif-file</replaceable></arg>
+</cmdsynopsis>
+</refsynopsisdiv>
+
+<refsect1><title>Description</title>
+
+<para>A program to create histogram of number of pixels using each
+color.  The output can be formatted into a GIF histogram file, or as
+text file - both go to stdout.</para>
+
+<para>If no GIF file is given, gifhisto will try to read a GIF file
+from stdin.</para>
+
+</refsect1>
+<refsect1><title>Options</title>
+
+<variablelist>
+<varlistentry>
+<term>-v</term>
+<listitem>
+<para>Verbose mode (show progress). Enables printout of running scan lines. </para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-t</term>
+<listitem>
+<para>Force output to be text file of the following form: (colormap size) lines each containing two integers: number of times color appeared, and color index.  Lines are in increasing color index order. This output can be fed directly to a sort program if ordering by color frequency is desired.</para>
+<para>The colormap picked is the one to be used for the image to
+generate histogram for, as defined in GIF format.</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-s width height</term>
+<listitem>
+<para>Size of GIF histogram file.  The height of the histogram should be power of 2 dividable by number of colors in colormap.</para>
+<para>Width sets the resolution (accuracy if you like) of the histogram as
+the maximum histogram bar is scaled to fit it.</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-n image-number</term>
+<listitem>
+<para>Image number to test.  Default is one.</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-b</term>
+<listitem>
+<para>Zeros the background color count.  As only linear scale bars are
+supported and usually the background appears much more often then
+other colors, deleting the background count will improve the scaling
+of other colors.</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-h</term>
+<listitem>
+<para>Print one line of command line help, similar to Usage above.</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+</refsect1>
+<refsect1><title>Author</title>
+
+<para>Gershon Elber</para>
+
+</refsect1>
+</refentry>
diff --git a/doc/gifinto.xml b/doc/gifinto.xml
new file mode 100644
index 0000000..801f061
--- /dev/null
+++ b/doc/gifinto.xml
@@ -0,0 +1,76 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE refentry PUBLIC
+   "-//OASIS//DTD DocBook XML V4.1.2//EN"
+   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>
+<refentry id='gifinto.1'>
+<refentryinfo><date>2 May 2012</date></refentryinfo>
+<refmeta>
+<refentrytitle>gifinto</refentrytitle>
+<manvolnum>1</manvolnum>
+<refmiscinfo class="source">GIFLIB</refmiscinfo>
+<refmiscinfo class="manual">GIFLIB Documentation</refmiscinfo>
+</refmeta>
+<refnamediv id='name'>
+<refname>gifinto</refname>
+<refpurpose>save GIF on stdin to file if size over set threshold</refpurpose>
+</refnamediv>
+
+<refsynopsisdiv id='synopsis'>
+
+<cmdsynopsis>
+  <command>gifinto</command>
+      <arg choice='opt'>-v</arg>
+      <arg choice='opt'>-s <replaceable>minsize</replaceable></arg>
+      <arg choice='opt'>-h</arg>
+      <group><replaceable>outfile</replaceable></group>
+</cmdsynopsis>
+</refsynopsisdiv>
+
+<refsect1><title>Description</title>
+
+<para>A program to save stdin into a file with given name, if the
+result file has size bigger than specified (see below).  This can be
+used to save a result under the same filename we started with in a
+chain of pipes.</para>
+
+<para>Always reads a GIF file from stdin.</para>
+
+</refsect1>
+<refsect1><title>Options</title>
+
+<variablelist>
+<varlistentry>
+<term>-v</term>
+<listitem>
+<para>Verbose mode (show progress).  
+Enables printout of running scan lines.</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-s MinFileSize</term>
+<listitem>
+<para>If file is less than MinFileSize, it is deleted and not renamed
+to the given name.  This will prevent killing the file we started with if
+the result is an empty file, or the pipeline did not
+complete.</para>
+<para>The default file threshold size is 14 bytes, which is 1 bigger
+than GIF file stamp (6 bytes) plus a GIF file screen descriptor (7
+bytes), so a GIF file with only GIF stamp and screen descriptor will
+not be renamed.</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term>-h</term>
+<listitem>
+<para>Print one line of command line help, similar to Usage above.</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+</refsect1>
+<refsect1><title>Author</title>
+
+<para>Gershon Elber.</para>
+
+</refsect1>
+</refentry>
diff --git a/doc/giflib.xml b/doc/giflib.xml
new file mode 100644
index 0000000..00a2219
--- /dev/null
+++ b/doc/giflib.xml
@@ -0,0 +1,55 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE refentry PUBLIC
+   "-//OASIS//DTD DocBook XML V4.1.2//EN"
+   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
+<!ENTITY project   "http://sourceforge.net/projects/giflib/?source=directory">
+]>
+<refentry id='giflib.7'>
+<refentryinfo><date>3 June 2012</date></refentryinfo>
+<refmeta>
+<refentrytitle>giflib</refentrytitle>
+<manvolnum>7</manvolnum>
+<refmiscinfo class="source">GIFLIB</refmiscinfo>
+<refmiscinfo class="manual">GIFLIB Documentation</refmiscinfo>
+</refmeta>
+<refnamediv id='name'>
+<refname>giflib</refname>
+<refpurpose>GIFLIB utilities</refpurpose>
+</refnamediv>
+
+<refsect1><title>Description</title>
+
+<para>GIFLIB is a linkable service library and a set of utilities for
+processing images encoded using GIF (Graphics Interchange Format).</para>
+
+<para>These utilities are not intended to compete with or replace
+multi-format graphics toolkits like ImageMagick or the Python Imaging
+Library, or graphics editors such as the GIMP. Find one of those, or
+an equivalent, if you need to crop, scale, rotate, toggle interlacing,
+or perform other conventional image transformations. Rather, these are
+intended to facilitate GIF-specific operations which multi-format tools
+may not adequately support.</para>
+
+<para>API documentation for the service library is best viewed through
+a browser at the project website: &project;.</para>
+
+</refsect1>
+<refsect1><title>See Also</title>
+
+<para>
+<citerefentry><refentrytitle>gif2rgb</refentrytitle><manvolnum>1</manvolnum></citerefentry>,
+<citerefentry><refentrytitle>gifbuild</refentrytitle><manvolnum>1</manvolnum></citerefentry>,
+<citerefentry><refentrytitle>giffix</refentrytitle><manvolnum>1</manvolnum></citerefentry>,
+<citerefentry><refentrytitle>giftext</refentrytitle><manvolnum>1</manvolnum></citerefentry>,
+<citerefentry><refentrytitle>giftool</refentrytitle><manvolnum>1</manvolnum></citerefentry>,
+<citerefentry><refentrytitle>gifclrmap</refentrytitle><manvolnum>1</manvolnum></citerefentry>.
+</para>
+
+</refsect1>
+<refsect1><title>Authors</title>
+
+<para>Gershon Elber, Eric S. Raymond, Toshio Kuratomi.</para>
+
+</refsect1>
+</refentry>
+
diff --git a/doc/gifsponge.xml b/doc/gifsponge.xml
new file mode 100644
index 0000000..e1a31bc
--- /dev/null
+++ b/doc/gifsponge.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE refentry PUBLIC
+   "-//OASIS//DTD DocBook XML V4.1.2//EN"
+   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
+<!ENTITY email         "david.sephirot@gmail.com">
+]>
+<refentry id='gifsponge.1'>
+<refentryinfo><date>20 Dec 2020</date></refentryinfo>
+<refmeta>
+<refentrytitle>gifsponge</refentrytitle>
+<manvolnum>1</manvolnum>
+<refmiscinfo class="source">GIFLIB</refmiscinfo>
+<refmiscinfo class="manual">GIFLIB Documentation</refmiscinfo>
+</refmeta>
+<refnamediv id='name'>
+<refname>gifsponge</refname>
+<refpurpose>expensive GIF copy, a model for slurp utilities</refpurpose>
+</refnamediv>
+
+<refsynopsisdiv id='synopsis'>
+
+<cmdsynopsis>
+  <command>gifsponge</command>
+</cmdsynopsis>
+</refsynopsisdiv>
+
+<refsect1><title>Description</title>
+
+<para>Slurp a GIF into core, operate on it, spew it out again.
+This is an expensive way to copy a GIF.  The source is included
+as a skeleton for more sophisticated slurp utilities.  See the source in the
+util directory for details.</para>
+
+</refsect1>
+<refsect1><title>Author</title>
+
+<para>David Surez <email>&email;</email></para>
+
+</refsect1>
+</refentry>
diff --git a/doc/gifstandard/GIF89a.html b/doc/gifstandard/GIF89a.html
new file mode 100644
index 0000000..6319564
--- /dev/null
+++ b/doc/gifstandard/GIF89a.html
@@ -0,0 +1,2820 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<link rel="stylesheet" type="text/css" href="main.css">
+<link rel="stylesheet" type="text/css" href="gif89a.css">
+<script type="text/javascript" src="gif89a.js"></script>
+<title>Graphics Interchange Format Version 89a</title>
+</head>
+<body><h1>Graphics Interchange Format Version 89a</h1>
+<!-- source best viewed with tab width 4 -->
+
+<div id="notes">
+
+<p>The document below is a copy of <a
+href="http://www.w3.org/Graphics/GIF/spec-gif89a.txt">http://www.w3.org/Graphics/GIF/spec-gif89a.txt</a>,
+reformatted into HTML to make it easier to read and print.</p>
+
+<p>Notable changes:</p>
+
+<ul>
+<li>moved chapter "Cover Sheet for the GIF89a Specification" from the
+    beginning to the end</li>
+<li>removed page numbers</li>
+<li>removed redundant rows from <a href="#quickreferencetable">Quick
+    Reference Table</a></li>
+</ul>
+
+You can also read <a href="gif89.txt">the original flat text.</a>
+</div>
+
+<hr>
+
+<p> 1987, 1988, 1989, 1990</p>
+
+<p>Copyright<br>
+CompuServe Incorporated<br>
+Columbus, Ohio</p>
+
+<p>Graphics Interchange Format Programming Reference</p>
+
+<p>CompuServe Incorporated</p>
+
+<p>Document Date: 31 July 1990</p>
+
+<div class="togglevisall">
+<span onclick="SetEveryVis(0);">hide all chapters</span> |
+<span onclick="SetEveryVis(1);">show all chapters</span>
+</div>
+
+<h2>Table of Contents <span onclick="ToggleVis(0);">(hide/show)</span></h2>
+
+<div id="p0">
+
+<ol>
+	<li><a href="#disclaimer">Disclaimer</a>
+	</li><li><a href="#foreword">Foreword</a>
+	</li><li><a href="#licensing">Licensing</a>
+	</li><li><a href="#aboutthedocument">About the Document</a>
+	</li><li><a href="#generaldescription">General Description</a>
+	</li><li><a href="#versionnumbers">Version Numbers</a>
+	</li><li><a href="#encoder">The Encoder</a>
+	</li><li><a href="#decoder">The Decoder</a>
+	</li><li><a href="#compliance">Compliance</a>
+	</li><li><a href="#recommendations">About Recommendations</a>
+	</li><li><a href="#colortables">About Color Tables</a>
+	</li><li><a href="#blocksextensionsandscope">Blocks, Extensions and Scope</a>
+	</li><li><a href="#blocksizes">Block Sizes</a>
+	</li><li><a href="#embeddedprotocol">Using GIF as an embedded protocol</a>
+	</li><li><a href="#subblocks">Data Sub-blocks</a>
+	</li><li><a href="#blockterminator">Block Terminator</a>
+	</li><li><a href="#header">Header</a>
+	</li><li><a href="#logicalscreendescriptor">Logical Screen Descriptor</a>
+	</li><li><a href="#globalcolortable">Global Color Table</a>
+	</li><li><a href="#imagedescriptor">Image Descriptor</a>
+	</li><li><a href="#localcolortable">Local Color Table</a>
+	</li><li><a href="#tablebasedimagedata">Table Based Image Data</a>
+	</li><li><a href="#graphiccontrolextension">Graphic Control Extension</a>
+	</li><li><a href="#commentextension">Comment Extension</a>
+	</li><li><a href="#plaintextextension">Plain Text Extension</a>
+	</li><li><a href="#applicationextension">Application Extension</a>
+	</li><li><a href="#trailer">Trailer</a>
+</li></ol>
+
+<p>Appendices:</p>
+
+<ol style="list-style-type:upper-latin;">
+	<li><a href="#quickreferencetable">Quick Reference Table</a>
+	</li><li><a href="#gifgrammar">GIF Grammar</a>
+	</li><li><a href="#glossary">Glossary</a>
+	</li><li><a href="#conventions">Conventions</a>
+	</li><li><a href="#interlacedimages">Interlaced Images</a>
+	</li><li><a href="#lzw">Variable-Length-Code LZW Compression</a>
+	</li><li><a href="#onlinecapabilities">On-line Capabilities Dialogue</a>
+</li></ol>
+
+<p>Other:</p>
+
+<ul>
+	<li><a href="#coversheet">Cover Sheet for the GIF89a Specification</a>
+</li></ul>
+
+</div>
+
+<h2 id="disclaimer">1. Disclaimer <span onclick="ToggleVis(1);">(hide/show)</span></h2>
+
+<div id="p1">
+
+<p>The information provided herein is subject to change without notice. In no
+event will CompuServe Incorporated be liable for damages, including any loss of
+revenue, loss of profits or other incidental or consequential damages arising
+out of the use or inability to use the information; CompuServe Incorporated
+makes no claim as to the suitability of the information.</p>
+
+</div>
+
+<h2 id="foreword">2. Foreword <span onclick="ToggleVis(2);">(hide/show)</span></h2>
+
+<div id="p2">
+
+<p>This document defines the Graphics Interchange Format. The
+specification given here defines version 89a, which is an extension of version
+87a.</p>
+
+<p>The Graphics Interchange Format as specified here should be
+considered complete; any deviation from it should be considered invalid,
+including but not limited to, the use of reserved or undefined fields within
+control or data blocks, the inclusion of extraneous data within or between
+blocks, the use of methods or algorithms not specifically listed as part of the
+format, etc. In general, any and all deviations, extensions or modifications
+not specified in this document should be considered to be in violation of the
+format and should be avoided.</p>
+
+</div>
+
+<h2 id="licensing">3. Licensing <span onclick="ToggleVis(3);">(hide/show)</span></h2>
+
+<div id="p3">
+
+<p>The Graphics Interchange Format is the copyright property of
+CompuServe Incorporated. Only CompuServe Incorporated is authorized to define,
+redefine, enhance, alter, modify or change in any way the definition of the
+format.</p>
+
+<p>CompuServe Incorporated hereby grants a limited, non-exclusive, royalty-free
+license for the use of the Graphics Interchange Format in computer
+software; computer software utilizing GIF must acknowledge ownership of
+the Graphics Interchange Format and its Service Mark by CompuServe
+Incorporated, in User and Technical Documentation. Computer software utilizing
+GIF, which is distributed or may be distributed without User or Technical
+Documentation must display to the screen or printer a message acknowledging
+ownership of the Graphics Interchange Format and the Service Mark by CompuServe
+Incorporated; in this case, the acknowledgement may be displayed in an opening
+screen or leading banner, or a closing screen or trailing banner. A message
+such as the following may be used:</p>
+
+<blockquote>
+	<p><i>The Graphics Interchange Format is the Copyright property of
+	CompuServe Incorporated. GIF is a Service Mark property of
+	CompuServe Incorporated.</i></p>
+</blockquote>
+
+<p>For further information, please contact:</p>
+
+<blockquote>
+	<p>CompuServe Incorporated<br>
+	Graphics Technology Department<br>
+	5000 Arlington Center Boulevard<br>
+	Columbus, Ohio 43220<br>
+	U. S. A.</p>
+</blockquote>
+
+<p>CompuServe Incorporated maintains a mailing list with all those individuals
+and organizations who wish to receive copies of this document when it is
+corrected or revised. This service is offered free of charge; please provide us
+with your mailing address.</p>
+
+</div>
+
+<h2 id="aboutthedocument">4. About the Document <span onclick="ToggleVis(4);">(hide/show)</span></h2>
+
+<div id="p4">
+
+<p>This document describes in detail the definition of the Graphics Interchange
+Format. This document is intended as a programming reference; it is recommended
+that the entire document be read carefully before programming, because of the
+interdependence of the various parts. There is an individual section for each
+of the Format blocks. Within each section, the sub-section labeled Required
+Version refers to the version number that an encoder will have to use if the
+corresponding block is used in the Data Stream. Within each section, a diagram
+describes the individual fields in the block; the diagrams are drawn
+vertically; top bytes in the diagram appear first in the Data Stream. Bits
+within a byte are drawn most significant on the left end. Multi-byte numeric
+fields are ordered Least Significant Byte first. Numeric constants are
+represented as Hexadecimal numbers, preceded by <tt>"0x"</tt>. Bit fields
+within a byte are described in order from most significant bits to least
+significant bits.</p>
+
+</div>
+
+<h2 id="generaldescription">5. General Description <span onclick="ToggleVis(5);">(hide/show)</span></h2>
+
+<div id="p5">
+
+<p>The Graphics Interchange Format defines a protocol intended for the
+on-line transmission and interchange of raster graphic data in a way that is
+independent of the hardware used in their creation or display.</p>
+
+<p>The Graphics Interchange Format is defined in terms of blocks and
+<a href="#subblocks">sub-blocks</a> which contain relevant parameters and data
+used in the reproduction of a graphic. A GIF Data Stream is a sequence of
+protocol blocks and sub-blocks representing a collection of graphics. In
+general, the graphics in a Data Stream are assumed to be related to some
+degree, and to share some control information; it is recommended that encoders
+attempt to group together related graphics in order to minimize hardware
+changes during processing and to minimize control information overhead. For the
+same reason, unrelated graphics or graphics which require resetting hardware
+parameters should be encoded separately to the extent possible.</p>
+
+<p>A Data Stream may originate locally, as when read from a file, or it may
+originate remotely, as when transmitted over a data communications line. The
+Format is defined with the assumption that an error-free Transport Level
+Protocol is used for communications; the Format makes no provisions for
+error-detection and error-correction.</p>
+
+<p>The GIF Data Stream must be interpreted in context, that is, the application
+program must rely on information external to the Data Stream to invoke the
+decoder process.</p>
+
+</div>
+
+<h2 id="versionnumbers">6. Version Numbers <span onclick="ToggleVis(6);">(hide/show)</span></h2>
+
+<div id="p6">
+
+<p>The version number in the <a href="#header">Header</a> of a Data Stream is
+intended to identify the minimum set of capabilities required of a decoder in
+order to fully process the Data Stream. An encoder should use the earliest
+possible version number that includes all the blocks used in the Data Stream.
+Within each block section in this document, there is an entry labeled Required
+Version which specifies the earliest version number that includes the
+corresponding block. The encoder should make every attempt to use the earliest
+version number covering all the blocks in the Data Stream; the unnecessary use
+of later version numbers will hinder processing by some decoders.</p>
+
+</div>
+
+<h2 id="encoder">7. The Encoder <span onclick="ToggleVis(7);">(hide/show)</span></h2>
+
+<div id="p7">
+
+<p>The Encoder is the program used to create a GIF Data Stream. From raster
+data and other information, the encoder produces the necessary control and data
+blocks needed for reproducing the original graphics.</p>
+
+<p>The encoder has the following primary responsibilities.</p>
+
+<ul>
+	<li>Include in the Data Stream all the necessary information to reproduce
+	the graphics.
+	</li><li>Insure that a Data Stream is labeled with the earliest possible Version
+	Number that will cover the definition of all the blocks in it; this is to
+	ensure that the largest number of decoders can process the Data Stream.
+	</li><li>Ensure encoding of the graphics in such a way that the decoding process
+	is optimized. Avoid redundant information as much as possible.
+	</li><li>To the extent possible, avoid grouping graphics which might require
+	resetting hardware parameters during the decoding process.
+	</li><li>Set to zero (off) each of the bits of each and every field designated
+	as reserved. Note that some fields in the Logical Screen Descriptor and the
+	<a href="#imagedescriptor">Image Descriptor</a> were reserved under Version
+	87a, but are used under version 89a.
+</li></ul>
+
+</div>
+
+<h2 id="decoder">8. The Decoder <span onclick="ToggleVis(8);">(hide/show)</span></h2>
+
+<div id="p8">
+
+<p>The Decoder is the program used to process a GIF Data Stream. It processes
+the Data Stream sequentially, parsing the various blocks and
+<a href="#subblocks">sub-blocks</a>, using the control information to set
+hardware and process parameters and interpreting the data to render the
+graphics.</p>
+
+<p>The decoder has the following primary responsibilities.</p>
+
+<ul>
+	<li>Process each graphic in the Data Stream in sequence, without delays
+	other than those specified in the control information.
+	</li><li>Set its hardware parameters to fit, as closely as possible, the control
+	information contained in the Data Stream.
+</li></ul>
+
+</div>
+
+<h2 id="compliance">9. Compliance <span onclick="ToggleVis(9);">(hide/show)</span></h2>
+
+<div id="p9">
+
+<p>An encoder or a decoder is said to comply with a given version of the
+Graphics Interchange Format if and only if it fully conforms with and correctly
+implements the definition of the standard associated with that version. An
+encoder or a decoder may be compliant with a given version number and not
+compliant with some subsequent version.</p>
+
+</div>
+
+<h2 id="recommendations">10. About Recommendations <span onclick="ToggleVis(10);">(hide/show)</span></h2>
+
+<div id="p10">
+
+<p>Each block section in this document contains an entry labeled
+Recommendation; this section lists a set of recommendations intended to guide
+and organize the use of the particular blocks. Such recommendations are geared
+towards making the functions of encoders and decoders more efficient, as well
+as making optimal use of the communications bandwidth. It is advised that these
+recommendations be followed.</p>
+
+</div>
+
+<h2 id="colortables">11. About Color Tables <span onclick="ToggleVis(11);">(hide/show)</span></h2>
+
+<div id="p11">
+
+<p>The GIF format utilizes color tables to render raster-based graphics. A
+color table can have one of two different scopes: global or local.</p>
+
+<p>A <a href="#globalcolortable">Global Color Table</a> is used by all those
+graphics in the Data Stream which do not have a
+<a href="#localcolortable">Local Color Table</a> associated with them. The
+scope of the Global Color Table is the entire Data Stream.</p>
+
+<p>A Local Color Table is always associated with the graphic that immediately
+follows it; the scope of a Local Color Table is limited to that single graphic.
+A Local Color Table supersedes a Global Color Table, that is, if a Data Stream
+contains a Global Color Table, and an image has a Local Color Table associated
+with it, the decoder must save the Global Color Table, use the Local Color
+Table to render the image, and then restore the Global Color Table.</p>
+
+<p>Both types of color tables are optional, making it possible for a Data
+Stream to contain numerous graphics without a color table at all. For this
+reason, it is recommended that the decoder save the last Global Color Table
+used until another Global Color Table is encountered. In this way, a Data
+Stream which does not contain either a Global Color Table or a Local Color
+Table may be processed using the last Global Color Table saved. If a Global
+Color Table from a previous Stream is used, that table becomes the Global Color
+Table of the present Stream. This is intended to reduce the overhead incurred
+by color tables. In particular, it is recommended that an encoder use only one
+Global Color Table if all the images in related Data Streams can be rendered
+with the same table. If no color table is available at all, the decoder is free
+to use a system color table or a table of its own. In that case, the decoder
+may use a color table with as many colors as its hardware is able to support;
+it is recommended that such a table have black and white as its first two
+entries, so that monochrome images can be rendered adequately.</p>
+
+<p>The Definition of the GIF Format allows for a Data Stream to contain only
+the <a href="#header">Header</a>, the
+<a href="#logicalscreendescriptor">Logical Screen Descriptor</a>, a Global
+Color Table and the <a href="#trailer">GIF Trailer</a>. Such a Data Stream
+would be used to load a decoder with a Global Color Table, in preparation for
+subsequent Data Streams without a color table at all.</p>
+
+</div>
+
+<h2 id="blocksextensionsandscope">12. Blocks, Extensions and Scope <span onclick="ToggleVis(12);">(hide/show)</span></h2>
+
+<div id="p12">
+
+<p>Blocks can be classified into three groups: Control, Graphic-Rendering and
+Special Purpose.</p>
+
+<p>Control blocks, such as the <a href="#header">Header</a>, the Logical Screen
+Descriptor, the <a href="#graphiccontrolextension">Graphic Control
+Extension</a> and the <a href="#trailer">Trailer</a>, contain information used
+to control the process of the Data Stream or information used in setting
+hardware parameters.</p>
+
+<p>Graphic-Rendering blocks such as the <a href="#imagedescriptor">Image
+Descriptor</a> and the <a href="#plaintextextension">Plain Text Extension</a>
+contain information and data used to render a graphic on the display
+device.</p>
+
+<p>Special Purpose blocks such as the <a href="#commentextension">Comment
+Extension</a> and the <a href="#applicationextension">Application Extension</a>
+are neither used to control the process of the Data Stream nor do they contain
+information or data used to render a graphic on the display device.</p>
+
+<p>With the exception of the <a href="#logicalscreendescriptor">Logical Screen
+Descriptor</a> and the <a href="#globalcolortable">Global Color Table</a>,
+whose scope is the entire Data Stream, all other Control blocks have a limited
+scope, restricted to the Graphic-Rendering block that follows them. Special
+Purpose blocks do not delimit the scope of any Control blocks; Special Purpose
+blocks are transparent to the decoding process. Graphic-Rendering blocks and
+extensions are used as scope delimiters for Control blocks and extensions.</p>
+
+<p>The labels used to identify labeled blocks fall into three ranges:</p>
+
+<ul>
+	<li><tt>0x00</tt><tt>0x7F</tt> (0127) are the Graphic
+	Rendering blocks, excluding the <a href="#trailer">Trailer</a>
+	(<tt>0x3B</tt>, 59)
+	</li><li><tt>0x80</tt><tt>0xF9</tt> (128249) are the Control
+	blocks
+	</li><li><tt>0xFA</tt><tt>0xFF</tt> (250255) are the Special
+	Purpose blocks
+</li></ul>
+
+<p>These ranges are defined so that decoders can handle block scope by
+appropriately identifying block labels, even when the block itself cannot be
+processed.</p>
+
+</div>
+
+<h2 id="blocksizes">13. Block Sizes <span onclick="ToggleVis(13);">(hide/show)</span></h2>
+
+<div id="p13">
+
+<p>The Block Size field in a block, counts the number of bytes remaining in the
+block, not counting the Block Size field itself, and not counting the
+<a href="#blockterminator">Block Terminator</a>, if one is to follow. Blocks
+other than Data Blocks are intended to be of fixed length; the Block Size field
+is provided in order to facilitate skipping them, not to allow their size to
+change in the future. Data blocks and <a href="#subblocks">sub-blocks</a> are
+of variable length to accommodate the amount of data.</p>
+
+</div>
+
+<h2 id="embeddedprotocol">14. Using GIF as an embedded protocol <span onclick="ToggleVis(14);">(hide/show)</span></h2>
+
+<div id="p14">
+
+<p>As an embedded protocol, GIF may be part of larger application protocols,
+within which GIF is used to render graphics. In such a case, the application
+protocol could define a block within which the GIF Data Stream would be
+contained. The application program would then invoke a GIF decoder upon
+encountering a block of type GIF. This approach is recommended in favor of
+using <a href="#applicationextension">Application Extensions</a>, which become
+overhead for all other applications that do not process them. Because a GIF
+Data Stream must be processed in context, the application must rely on some
+means of identifying the GIF Data Stream outside of the Stream itself.</p>
+
+</div>
+
+<h2 id="subblocks">15. Data Sub-blocks <span onclick="ToggleVis(15);">(hide/show)</span></h2>
+
+<div id="p15">
+
+<h3>a. Description</h3>
+
+<p>Data Sub-blocks are units containing data. They do not have a label, these
+blocks are processed in the context of control blocks, wherever data blocks are
+specified in the format. The first byte of the Data sub-block indicates the
+number of data bytes to follow. A data sub-block may contain from 0 to 255 data
+bytes. The size of the block does not account for the size byte itself,
+therefore, the empty sub-block is one whose size field contains <tt>0x00</tt>
+(0).</p>
+
+<h3>b. Required Version</h3>
+
+<p>87a.</p>
+
+<h3>c. Syntax</h3>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td>Block Size
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">1
+		</td><td rowspan="5">Data Values
+		</td><td rowspan="5">Byte
+	</td></tr><tr>
+		<td style="text-align:center;">2
+	</td></tr><tr>
+		<td style="text-align:center;">3
+	</td></tr><tr>
+		<td style="text-align:center;">
+	</td></tr><tr>
+		<td style="text-align:center;">up to 255
+</td></tr></tbody></table>
+
+<ol style="list-style-type:lower-roman;">
+	<li>Block Size:
+	<ul>
+		<li>Number of bytes in the Data Sub-block; the size must be within 0
+		and 255 bytes, inclusive.
+	</li></ul>
+	</li><li>Data Values:
+	<ul>
+		<li>Any 8-bit value. There must be exactly as many Data Values as
+		specified by the Block Size field.
+	</li></ul>
+</li></ol>
+
+<h3>d. Extensions and Scope</h3>
+
+<p>This type of block always occurs as part of a larger unit. It does not have
+a scope of itself.</p>
+
+<h3>e. Recommendation</h3>
+
+<p>None.</p>
+
+</div>
+
+<h2 id="blockterminator">16. Block Terminator <span onclick="ToggleVis(16);">(hide/show)</span></h2>
+
+<div id="p16">
+
+<h3>a. Description</h3>
+
+<p>This zero-length <a href="#subblocks">Data Sub-block</a> is used to
+terminate a sequence of Data Sub-blocks. It contains a single byte in the
+position of the Block Size field and does not contain data.</p>
+
+<h3>b. Required Version</h3>
+
+<p>87a.</p>
+
+<h3>c. Syntax</h3>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td>Block Size
+		</td><td>Byte
+</td></tr></tbody></table>
+
+<ol style="list-style-type:lower-roman;">
+	<li>Block Size:
+	<ul>
+		<li>Number of bytes in the Data Sub-block; this field contains the
+		fixed value <tt>0x00</tt> (0).
+	</li></ul>
+	</li><li>Data Values:
+	<ul>
+		<li>This block does not contain any data.
+	</li></ul>
+</li></ol>
+
+<h3>d. Extensions and Scope</h3>
+
+<p>This block terminates the immediately preceding sequence of Data Sub-blocks.
+This block cannot be modified by any extension.</p>
+
+<h3>e. Recommendation</h3>
+
+<p>None.</p>
+
+</div>
+
+<h2 id="header">17. Header <span onclick="ToggleVis(17);">(hide/show)</span></h2>
+
+<div id="p17">
+
+<h3>a. Description</h3>
+
+<p>The Header identifies the GIF Data Stream in context. The Signature field
+marks the beginning of the Data Stream, and the Version field identifies the
+set of capabilities required of a decoder to fully process the Data Stream.
+This block is <i>required</i>; exactly one Header must be present per Data
+Stream.</p>
+
+<h3>b. Required Version</h3>
+
+<p>Not applicable. This block is not subject to a version number. This block
+must appear at the beginning of every Data Stream.</p>
+
+<h3>c. Syntax</h3>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td rowspan="3">Signature
+		</td><td rowspan="3">3 Bytes
+	</td></tr><tr>
+		<td style="text-align:center;">1
+	</td></tr><tr>
+		<td style="text-align:center;">2
+	</td></tr><tr>
+		<td style="text-align:center;">3
+		</td><td rowspan="3">Version
+		</td><td rowspan="3">3 Bytes
+	</td></tr><tr>
+		<td style="text-align:center;">4
+	</td></tr><tr>
+		<td style="text-align:center;">5
+</td></tr></tbody></table>
+
+<ol style="list-style-type:lower-roman;">
+	<li>Signature:
+	<ul>
+		<li>Identifies the GIF Data Stream. This field contains the fixed value
+		<tt>'GIF'</tt> (<tt>0x47 0x49 0x46</tt>).
+	</li></ul>
+	</li><li>Version:
+	<ul>
+		<li>Version number used to format the data stream. Identifies the
+		minimum set of capabilities necessary to a decoder to fully process the
+		contents of the Data Stream.
+		</li><li>Version Numbers as of 10 July 1990:
+		<ul>
+			<li><tt>"87a"</tt> (<tt>0x38 0x37 0x61</tt>)  May 1987
+			</li><li><tt>"89a"</tt> (<tt>0x38 0x39 0x61</tt>)  July 1989
+		</li></ul>
+		</li><li>Version numbers are ordered numerically increasing on the first two
+		digits starting with 87 (87, 88, , 99, 00, , 85, 86)
+		and alphabetically increasing on the third character (a, , z).
+	</li></ul>
+	</li><li>Extensions and Scope:
+	<ul>
+		<li>The scope of this block is the entire Data Stream. This block
+		cannot be modified by any extension.
+	</li></ul>
+</li></ol>
+
+<h3>d. Recommendations</h3>
+
+<ol style="list-style-type:lower-roman;">
+	<li>Signature:
+	<ul>
+		<li>This field identifies the beginning of the GIF Data Stream; it is
+		not intended to provide a unique signature for the identification of
+		the data. It is recommended that the GIF Data Stream be identified
+		externally by the application. (Refer to <a href="#online">Appendix
+		G</a> for on-line identification of the GIF Data Stream.)
+	</li></ul>
+	</li><li>Version:
+	<ul>
+		<li>Encoder: An encoder should use the earliest possible version number
+		that defines all the blocks used in the Data Stream. When two or more
+		Data Streams are combined, the latest of the individual version numbers
+		should be used for the resulting Data Stream.
+		</li><li>Decoder: A decoder should attempt to process the data stream to the
+		best of its ability; if it encounters a version number which it is not
+		capable of processing fully, it should nevertheless, attempt to process
+		the data stream to the best of its ability, perhaps after warning the
+		user that the data may be incomplete.
+	</li></ul>
+</li></ol>
+
+</div>
+
+<h2 id="logicalscreendescriptor">18. Logical Screen Descriptor <span onclick="ToggleVis(18);">(hide/show)</span></h2>
+
+<div id="p18">
+
+<h3>a. Description</h3>
+
+<p>The Logical Screen Descriptor contains the parameters necessary to define
+the area of the display device within which the images will be rendered. The
+coordinates in this block are given with respect to the top-left corner of the
+virtual screen; they do not necessarily refer to absolute coordinates on the
+display device. This implies that they could refer to window coordinates in a
+window-based environment or printer coordinates when a printer is used.</p>
+
+<p>This block is <i>required</i>; exactly one Logical Screen Descriptor must be
+present per Data Stream.</p>
+
+<h3>b. Required Version</h3>
+
+<p>Not applicable. This block is not subject to a version number. This block
+must appear immediately after the <a href="#header">Header</a>.</p>
+
+<h3>c. Syntax</h3>
+
+<table>
+	<tbody><tr>
+		<th rowspan="2">Byte #
+		</th><th colspan="8">Bits
+		</th><th rowspan="2">Field Name
+		</th><th rowspan="2">Type
+	</th></tr><tr>
+		<th>7
+		</th><th>6
+		</th><th>5
+		</th><th>4
+		</th><th>3
+		</th><th>2
+		</th><th>1
+		</th><th>0
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td rowspan="2" colspan="8">
+		</td><td rowspan="2">Logical Screen Width
+		</td><td rowspan="2">Unsigned
+	</td></tr><tr>
+		<td style="text-align:center;">1
+	</td></tr><tr>
+		<td style="text-align:center;">2
+		</td><td rowspan="2" colspan="8">
+		</td><td rowspan="2">Logical Screen Height
+		</td><td rowspan="2">Unsigned
+	</td></tr><tr>
+		<td style="text-align:center;">3
+	</td></tr><tr>
+		<td style="text-align:center;">4
+		</td><td>
+		</td><td colspan="3">
+		</td><td>
+		</td><td colspan="3">
+		</td><td>&lt;Packed Fields&gt;
+		</td><td>See below
+	</td></tr><tr>
+		<td style="text-align:center;">5
+		</td><td colspan="8">
+		</td><td>Background Color Index
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">6
+		</td><td colspan="8">
+		</td><td>Pixel Aspect Ratio
+		</td><td>Byte
+</td></tr></tbody></table>
+
+<p>&lt;Packed Fields&gt; =</p>
+
+<table>
+<tbody><tr>
+	<td><a href="#globalcolortable">Global Color Table</a> Flag
+	</td><td>1 Bit
+</td></tr><tr>
+	<td>Color Resolution
+	</td><td>3 Bits
+</td></tr><tr>
+	<td>Sort Flag
+	</td><td>1 Bit
+</td></tr><tr>
+	<td>Size of Global Color Table
+	</td><td>3 Bits
+</td></tr></tbody></table>
+
+<ol style="list-style-type:lower-roman;">
+	<li>Logical Screen Width:
+	<ul>
+		<li>Width, in pixels, of the Logical Screen where the images will be
+		rendered in the displaying device.
+	</li></ul>
+	</li><li>Logical Screen Height:
+	<ul>
+		<li>Height, in pixels, of the Logical Screen where the images will be
+		rendered in the displaying device.
+	</li></ul>
+	</li><li>Global Color Table Flag:
+	<ul>
+		<li>Flag indicating the presence of a Global Color Table; if the flag
+		is set, the Global Color Table will immediately follow the Logical
+		Screen Descriptor. This flag also selects the interpretation of the
+		Background Color Index; if the flag is set, the value of the Background
+		Color Index field should be used as the table index of the background
+		color. (This field is the most significant bit of the byte.)
+		</li><li>Values:
+		<ul>
+			<li>0: No Global Color Table follows, the Background Color Index
+			field is meaningless.
+			</li><li>1: A Global Color Table will immediately follow, the Background
+			Color Index field is meaningful.
+		</li></ul>
+	</li></ul>
+	</li><li>Color Resolution:
+	<ul>
+		<li>Number of bits per primary color available to the original image,
+		minus 1. This value represents the size of the entire palette from
+		which the colors in the graphic were selected, not the number of colors
+		actually used in the graphic. For example, if the value in this field
+		is 3, then the palette of the original image had 4 bits per primary
+		color available to create the image. This value should be set to
+		indicate the richness of the original palette, even if not every color
+		from the whole palette is available on the source machine.
+	</li></ul>
+	</li><li>Sort Flag:
+	<ul>
+		<li>Indicates whether the Global Color Table is sorted. If the flag is
+		set, the Global Color Table is sorted, in order of decreasing
+		importance. Typically, the order would be decreasing frequency, with
+		most frequent color first. This assists a decoder, with fewer available
+		colors, in choosing the best subset of colors; the decoder may use an
+		initial segment of the table to render the graphic.
+		</li><li>Values:
+		<ul>
+			<li>0: Not ordered.
+			</li><li>1: Ordered by decreasing importance, most important color
+			first.
+		</li></ul>
+	</li></ul>
+	</li><li>Size of Global Color Table:
+	<ul>
+		<li>If the Global Color Table Flag is set to 1, the value in this field
+		is used to calculate the number of bytes contained in the Global Color
+		Table. To determine that actual size of the color table, raise 2 to
+		[the value of the field + 1]. Even if there is no Global Color Table
+		specified, set this field according to the above formula so that
+		decoders can choose the best graphics mode to display the stream in.
+		(This field is made up of the 3 least significant bits of the byte.)
+	</li></ul>
+	</li><li>Background Color Index:
+	<ul>
+		<li>Index into the Global Color Table for the Background Color. The
+		Background Color is the color used for those pixels on the screen that
+		are not covered by an image. If the Global Color Table Flag is set to
+		(zero), this field should be zero and should be ignored.
+	</li></ul>
+	</li><li>Pixel Aspect Ratio:
+	<ul>
+		<li>Factor used to compute an approximation of the aspect ratio of the
+		pixel in the original image. If the value of the field is not 0, this
+		approximation of the aspect ratio is computed based on the formula:<br>
+		<img src="gif-aspectratio.png" alt="Aspect Ratio = (Pixel Aspect Ratio + 15)  64">
+		</li><li>The Pixel Aspect Ratio is defined to be the quotient of the pixel's
+		width over its height. The value range in this field allows
+		specification of the widest pixel of 4:1 to the tallest pixel of 1:4 in
+		increments of <img src="gif-1over64.png" alt="1/64">.
+		</li><li>Values:
+		<ul>
+			<li>0: No aspect ratio information is given.
+			</li><li>1255: Value used in the computation.
+		</li></ul>
+	</li></ul>
+</li></ol>
+
+<h3>d. Extensions and Scope</h3>
+
+<p>The scope of this block is the entire Data Stream. This block cannot be
+modified by any extension.</p>
+
+<h3>e. Recommendations</h3>
+
+<p>None.</p>
+
+</div>
+
+<h2 id="globalcolortable">19. Global Color Table <span onclick="ToggleVis(19);">(hide/show)</span></h2>
+
+<div id="p19">
+
+<h3>a. Description</h3>
+
+<p>This block contains a color table, which is a sequence of bytes representing
+<span class="rcomp">red</span>-<span class="gcomp">green</span>-<span class="bcomp">blue</span> color triplets. The Global Color Table is used by
+images without a <a href="#localcolortable">Local Color Table</a> and by <a href="#plaintextextension">Plain Text Extensions</a>. Its presence is marked by
+the Global Color Table Flag being set to 1 in the <a href="#logicalscreendescriptor">Logical Screen Descriptor</a>; if present, it
+immediately follows the Logical Screen Descriptor and contains a number of
+bytes equal to:</p>
+
+<blockquote>
+	<p>3  2<sup>Size of Global Color Table + 1</sup></p>
+</blockquote>
+
+<p>This block is <i>optional</i>; at most one Global Color Table may be present
+per Data Stream.</p>
+
+<h3>b. Required Version</h3>
+
+<p>87a.</p>
+
+<h3>c. Syntax</h3>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td><span class="rcomp">Red</span> 0
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">1
+		</td><td><span class="gcomp">Green</span> 0
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">2
+		</td><td><span class="bcomp">Blue</span> 0
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">3
+		</td><td><span class="rcomp">Red</span> 1
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">4
+		</td><td><span class="gcomp">Green</span> 1
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">
+		</td><td style="text-align:center;">
+		</td><td style="text-align:center;">
+	</td></tr><tr>
+		<td style="text-align:center;">766
+		</td><td><span class="gcomp">Green</span> 255
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">up to 767
+		</td><td><span class="bcomp">Blue</span> 255
+		</td><td>Byte
+</td></tr></tbody></table>
+
+<h3>d. Extensions and Scope</h3>
+
+<p>The scope of this block is the entire Data Stream. This block cannot be
+modified by any extension.</p>
+
+<h3>e. Recommendation</h3>
+
+<p>None.</p>
+
+</div>
+
+<h2 id="imagedescriptor">20. Image Descriptor <span onclick="ToggleVis(20);">(hide/show)</span></h2>
+
+<div id="p20">
+
+<h3>a. Description</h3>
+
+<p>Each image in the Data Stream is composed of an Image Descriptor, an
+optional <a href="#localcolortable">Local Color Table</a>, and the <a href="#tablebasedimagedata">image data</a>. Each image must fit within the
+boundaries of the Logical Screen, as defined in the <a href="#logicalscreendescriptor">Logical Screen Descriptor</a>.</p>
+
+<p>The Image Descriptor contains the parameters necessary to process a table
+based image. The coordinates given in this block refer to coordinates within
+the Logical Screen, and are given in pixels. This block is a Graphic-Rendering
+Block, optionally preceded by one or more Control blocks such as the <a href="#graphiccontrolextension">Graphic Control Extension</a>, and may be
+optionally followed by a Local Color Table; the Image Descriptor is always
+followed by the image data.</p>
+
+<p>This block is <i>required</i> for an image. Exactly one Image Descriptor
+must be present per image in the Data Stream. An unlimited number of images may
+be present per Data Stream.</p>
+
+<h3>b. Required Version</h3>
+
+<p>87a.</p>
+
+<h3>c. Syntax</h3>
+
+<table>
+	<tbody><tr>
+		<th rowspan="2">Byte #
+		</th><th colspan="8">Bits
+		</th><th rowspan="2">Field Name
+		</th><th rowspan="2">Type
+	</th></tr><tr>
+		<th>7
+		</th><th>6
+		</th><th>5
+		</th><th>4
+		</th><th>3
+		</th><th>2
+		</th><th>1
+		</th><th>0
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td colspan="8">
+		</td><td>Image Separator
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">1
+		</td><td rowspan="2" colspan="8">
+		</td><td rowspan="2">Image Left Position
+		</td><td rowspan="2">Unsigned
+	</td></tr><tr>
+		<td style="text-align:center;">2
+	</td></tr><tr>
+		<td style="text-align:center;">3
+		</td><td rowspan="2" colspan="8">
+		</td><td rowspan="2">Image Top Position
+		</td><td rowspan="2">Unsigned
+	</td></tr><tr>
+		<td style="text-align:center;">4
+	</td></tr><tr>
+		<td style="text-align:center;">5
+		</td><td rowspan="2" colspan="8">
+		</td><td rowspan="2">Image Width
+		</td><td rowspan="2">Unsigned
+	</td></tr><tr>
+		<td style="text-align:center;">6
+	</td></tr><tr>
+		<td style="text-align:center;">7
+		</td><td rowspan="2" colspan="8">
+		</td><td rowspan="2">Image Height
+		</td><td rowspan="2">Unsigned
+	</td></tr><tr>
+		<td style="text-align:center;">8
+	</td></tr><tr>
+		<td style="text-align:center;">9
+		</td><td>
+		</td><td>
+		</td><td>
+		</td><td colspan="2">
+		</td><td colspan="3">
+		</td><td>&lt;Packed Fields&gt;
+		</td><td>See below
+</td></tr></tbody></table>
+
+<p>&lt;Packed Fields&gt; =</p>
+
+<table>
+	<tbody><tr>
+		<td>Local Color Table Flag
+		</td><td>1 Bit
+	</td></tr><tr>
+		<td>Interlace Flag
+		</td><td>1 Bit
+	</td></tr><tr>
+		<td>Sort Flag
+		</td><td>1 Bit
+	</td></tr><tr>
+		<td>Reserved
+		</td><td>2 Bits
+	</td></tr><tr>
+		<td>Size of Local Color Table
+		</td><td>3 Bits
+</td></tr></tbody></table>
+
+<ol style="list-style-type:lower-roman;">
+	<li>Image Separator:
+	<ul>
+		<li>Identifies the beginning of an Image Descriptor. This field
+		contains the fixed value <tt>0x2C</tt> (44, <tt>','</tt>).
+	</li></ul>
+	</li><li>Image Left Position:
+	<ul>
+		<li>Column number, in pixels, of the left edge of the image, with
+		respect to the left edge of the Logical Screen. Leftmost column of the
+		Logical Screen is 0.
+	</li></ul>
+	</li><li>Image Top Position:
+	<ul>
+		<li>Row number, in pixels, of the top edge of the image with respect to
+		the top edge of the Logical Screen. Top row of the Logical Screen is 0.
+	</li></ul>
+	</li><li>Image Width:
+	<ul>
+		<li>Width of the image in pixels.
+	</li></ul>
+	</li><li>Image Height:
+	<ul>
+		<li>Height of the image in pixels.
+	</li></ul>
+	</li><li>Local Color Table Flag:
+	<ul>
+		<li>Indicates the presence of a Local Color Table immediately following
+		this Image Descriptor. (This field is the most significant bit of the
+		byte.)
+		</li><li>Values:
+		<ul>
+			<li>0: Local Color Table is not present. Use <a href="#globalcolortable">Global Color Table</a> if available.
+			</li><li>1: Local Color Table present, and to follow immediately after
+			this Image Descriptor.
+		</li></ul>
+	</li></ul>
+	</li><li>Interlace Flag:
+	<ul>
+		<li>Indicates if the image is interlaced. An image is interlaced in a
+		four-pass interlace pattern; see <a href="#interlacedimages">Appendix
+		E</a> for details.
+		</li><li>Values:
+		<ul>
+			<li>0: Image is not interlaced.
+			</li><li>1: Image is interlaced.
+		</li></ul>
+	</li></ul>
+	</li><li>Sort Flag:
+	<ul>
+		<li>Indicates whether the Local Color Table is sorted. If the flag is
+		set, the Local Color Table is sorted, in order of decreasing
+		importance. Typically, the order would be decreasing frequency, with
+		most frequent color first. This assists a decoder, with fewer available
+		colors, in choosing the best subset of colors; the decoder may use an
+		initial segment of the table to render the graphic.
+		</li><li>Values:
+		<ul>
+			<li>0: Not ordered.
+			</li><li>1: Ordered by decreasing importance, most important color
+			first.
+		</li></ul>
+	</li></ul>
+	</li><li>Size of Local Color Table:
+	<ul>
+		<li>If the Local Color Table Flag is set to 1, the value in this field
+		is used to calculate the number of bytes contained in the Local Color
+		Table. To determine that actual size of the color table, raise 2 to
+		[the value of the field + 1]. This value should be 0 if there is no
+		Local Color Table specified. (This field is made up of the 3 least
+		significant bits of the byte.)
+	</li></ul>
+</li></ol>
+
+<h3>d. Extensions and Scope</h3>
+
+<p>The scope of this block is the Table-based Image Data Block that follows it.
+This block may be modified by the Graphic Control Extension.</p>
+
+<h3>e. Recommendation</h3>
+
+<p>None.</p>
+
+</div>
+
+<h2 id="localcolortable">21. Local Color Table <span onclick="ToggleVis(21);">(hide/show)</span></h2>
+
+<div id="p21">
+
+<h3>a. Description</h3>
+
+<p>This block contains a color table, which is a sequence of bytes representing
+<span class="rcomp">red</span>-<span class="gcomp">green</span>-<span class="bcomp">blue</span> color triplets. The Local Color Table is used by the
+image that immediately follows. Its presence is marked by the Local Color Table
+Flag being set to 1 in the <a href="#imagedescriptor">Image Descriptor</a>; if
+present, the Local Color Table immediately follows the Image Descriptor and
+contains a number of bytes equal to:</p>
+
+<blockquote>
+	<p>3  2<sup>Size of Local Color Table + 1</sup></p>
+</blockquote>
+
+<p>If present, this color table temporarily becomes the active color table and
+the following image should be processed using it. This block is
+<i>optional</i>; at most one Local Color Table may be present per Image
+Descriptor and its scope is the single image associated with the Image
+Descriptor that precedes it.</p>
+
+<h3>b. Required Version</h3>
+
+<p>87a.</p>
+
+<h3>c. Syntax</h3>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td><span class="rcomp">Red</span> 0
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">1
+		</td><td><span class="gcomp">Green</span> 0
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">2
+		</td><td><span class="bcomp">Blue</span> 0
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">3
+		</td><td><span class="rcomp">Red</span> 1
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">4
+		</td><td><span class="gcomp">Green</span> 1
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">
+		</td><td style="text-align:center;">
+		</td><td style="text-align:center;">
+	</td></tr><tr>
+		<td style="text-align:center;">766
+		</td><td><span class="gcomp">Green</span> 255
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">up to 767
+		</td><td><span class="bcomp">Blue</span> 255
+		</td><td>Byte
+</td></tr></tbody></table>
+
+<h3>d. Extensions and Scope</h3>
+
+<p>The scope of this block is the Table-based Image Data Block that immediately
+follows it. This block cannot be modified by any extension.</p>
+
+<h3>e. Recommendations</h3>
+
+<p>None.</p>
+
+</div>
+
+<h2 id="tablebasedimagedata">22. Table Based Image Data <span onclick="ToggleVis(22);">(hide/show)</span></h2>
+
+<div id="p22">
+
+<h3>a. Description</h3>
+
+<p>The image data for a table based image consists of a sequence of <a href="#subblocks">sub-blocks</a>, of size at most 255 bytes each, containing an
+index into the active color table, for each pixel in the image. Pixel indices
+are in order of left to right and from top to bottom. Each index must be within
+the range of the size of the active color table, starting at 0. The sequence of
+indices is encoded using the LZW Algorithm with variable-length code, as
+described in <a href="#lzw">Appendix F</a>.</p>
+
+<h3>b. Required Version</h3>
+
+<p>87a.</p>
+
+<h3>c. Syntax</h3>
+
+<p>The image data format is as follows:</p>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td>LZW Minimum Code Size
+		</td><td>Byte
+</td></tr></tbody></table>
+
+<p></p>
+
+<table>
+	<tbody><tr>
+		<th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td>Image Data
+		</td><td>Data Sub-blocks
+</td></tr></tbody></table>
+
+<ol style="list-style-type:lower-roman;">
+	<li>LZW Minimum Code Size:
+	<ul>
+		<li>This byte determines the initial number of bits used for LZW codes
+		in the image data, as described in Appendix F.
+	</li></ul>
+</li></ol>
+
+<h3>d. Extensions and Scope</h3>
+
+<p>This block has no scope, it contains raster data. Extensions intended to
+modify a Table-based image must appear before the corresponding <a href="#imagedescriptor">Image Descriptor</a>.</p>
+
+<h3>e. Recommendations</h3>
+
+<p>None.</p>
+
+</div>
+
+<h2 id="graphiccontrolextension">23. Graphic Control Extension <span onclick="ToggleVis(23);">(hide/show)</span></h2>
+
+<div id="p23">
+
+<h3>a. Description</h3>
+
+<p>The Graphic Control Extension contains parameters used when processing a
+graphic rendering block. The scope of this extension is the first graphic
+rendering block to follow. The extension contains only one <a href="#subblocks">data sub-block</a>.</p>
+
+<p>This block is <i>optional</i>; at most one Graphic Control Extension may
+precede a graphic rendering block. This is the only limit to the number of
+Graphic Control Extensions that may be contained in a Data Stream.</p>
+
+<h3>b. Required Version</h3>
+
+<p>89a.</p>
+
+<h3>c. Syntax</h3>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td>Extension Introducer
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">1
+		</td><td>Graphic Control Label
+		</td><td>Byte
+</td></tr></tbody></table>
+
+<p></p>
+
+<table>
+	<tbody><tr>
+		<th rowspan="2">Byte #
+		</th><th colspan="8">Bits
+		</th><th rowspan="2">Field Name
+		</th><th rowspan="2">Type
+	</th></tr><tr>
+		<th>7
+		</th><th>6
+		</th><th>5
+		</th><th>4
+		</th><th>3
+		</th><th>2
+		</th><th>1
+		</th><th>0
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td colspan="8">
+		</td><td>Block Size
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">1
+		</td><td colspan="3">
+		</td><td colspan="3">
+		</td><td>
+		</td><td>
+		</td><td>&lt;Packed Fields&gt;
+		</td><td>See below
+	</td></tr><tr>
+		<td style="text-align:center;">2
+		</td><td rowspan="2" colspan="8">
+		</td><td rowspan="2">Delay Time
+		</td><td rowspan="2">Unsigned
+	</td></tr><tr>
+		<td style="text-align:center;">3
+	</td></tr><tr>
+		<td style="text-align:center;">4
+		</td><td colspan="8">
+		</td><td>Transparent Color Index
+		</td><td>Byte
+</td></tr></tbody></table>
+
+<p></p>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td><a href="#blockterminator">Block Terminator</a>
+		</td><td>Byte
+</td></tr></tbody></table>
+
+<p>&lt;Packed Fields&gt; =</p>
+
+<table>
+	<tbody><tr>
+		<td>Reserved
+		</td><td>3 Bits
+	</td></tr><tr>
+		<td>Disposal Method
+		</td><td>3 Bits
+	</td></tr><tr>
+		<td>User Input Flag
+		</td><td>1 Bit
+	</td></tr><tr>
+		<td>Transparent Color Flag
+		</td><td>1 Bit
+</td></tr></tbody></table>
+
+<ol style="list-style-type:lower-roman;">
+	<li>Extension Introducer:
+	<ul>
+		<li>Identifies the beginning of an extension block. This field contains
+		the fixed value <tt>0x21</tt> (33, <tt>'!'</tt>).
+	</li></ul>
+	</li><li>Graphic Control Label:
+	<ul>
+		<li>Identifies the current block as a Graphic Control Extension. This
+		field contains the fixed value <tt>0xF9</tt> (249).
+	</li></ul>
+	</li><li>Block Size:
+	<ul>
+		<li>Number of bytes in the block, after the Block Size field and up to
+		but not including the Block Terminator. This field contains the fixed
+		value <tt>0x04</tt> (4).
+	</li></ul>
+	</li><li>Disposal Method:
+	<ul>
+		<li>Indicates the way in which the graphic is to be treated after being
+		displayed.
+		</li><li>Values:
+		<ul>
+			<li>0: No disposal specified. The decoder is not required to take
+			any action.
+			</li><li>1: Do not dispose. The graphic is to be left in place.
+			</li><li>2: Restore to background color. The area used by the graphic
+			must be restored to the background color.
+			</li><li>3: Restore to previous. The decoder is required to restore the
+			area overwritten by the graphic with what was there prior to rendering the graphic.
+			</li><li>47: To be defined.
+		</li></ul>
+	</li></ul>
+	</li><li>User Input Flag:
+	<ul>
+		<li>Indicates whether or not user input is expected before continuing.
+		If the flag is set, processing will continue when user input is
+		entered. The nature of the User input is determined by the application
+		(Carriage Return, Mouse Button Click, etc.).
+		</li><li>Values:
+		<ul>
+			<li>0: User input is not expected.
+			</li><li>1: User input is expected.
+		</li></ul>
+		</li><li>When a Delay Time is used and the User Input Flag is set,
+		processing will continue when user input is received or when the delay
+		time expires, whichever occurs first.
+	</li></ul>
+	</li><li>Transparency Flag:
+	<ul>
+		<li>Indicates whether a transparency index is given in the Transparent
+		Index field. (This field is the least significant bit of the byte.)
+		</li><li>Values:
+		<ul>
+			<li>0: Transparent Index is not given.
+			</li><li>1: Transparent Index is given.
+		</li></ul>
+	</li></ul>
+	</li><li>Delay Time:
+	<ul>
+		<li>If not 0, this field specifies the number of hundredths (<img src="gif-1over100.png" alt="1/100">) of a second to wait before
+		continuing with the processing of the Data Stream. The clock starts
+		ticking immediately after the graphic is rendered. This field may be
+		used in conjunction with the User Input Flag field.
+	</li></ul>
+	</li><li>Transparency Index:
+	<ul>
+		<li>The Transparency Index is such that when encountered, the
+		corresponding pixel of the display device is not modified and
+		processing goes on to the next pixel. The index is present if and only
+		if the Transparency Flag is set to 1.
+	</li></ul>
+	</li><li>Block Terminator:
+	<ul>
+		<li>This zero-length data block marks the end of the Graphic Control
+		Extension.
+	</li></ul>
+</li></ol>
+
+<h3>d. Extensions and Scope</h3>
+
+<p>The scope of this Extension is the graphic rendering block that follows it;
+it is possible for other extensions to be present between this block and its
+target. This block can modify the <a href="#imagedescriptor">Image Descriptor
+Block</a> and the <a href="#plaintextextension">Plain Text Extension</a>.</p>
+
+<h3>e. Recommendations</h3>
+
+<ol style="list-style-type:lower-roman;">
+	<li>Disposal Method:
+	<ul>
+		<li>The mode Restore To Previous is intended to be used in small
+		sections of the graphic; the use of this mode imposes severe demands on
+		the decoder to store the section of the graphic that needs to be saved.
+		For this reason, this mode should be used sparingly. This mode is not
+		intended to save an entire graphic or large areas of a graphic; when
+		this is the case, the encoder should make every attempt to make the
+		sections of the graphic to be restored be separate graphics in the data
+		stream. In the case where a decoder is not capable of saving an area of
+		a graphic marked as Restore To Previous, it is recommended that a
+		decoder restore to the background color.
+	</li></ul>
+	</li><li>User Input Flag:
+	<ul>
+		<li>When the flag is set, indicating that user input is expected, the
+		decoder may sound the bell (<tt>0x07</tt>, 7) to alert the user that
+		input is being expected. In the absence of a specified Delay Time, the
+		decoder should wait for user input indefinitely. It is recommended that
+		the encoder not set the User Input Flag without a Delay Time specified.
+	</li></ul>
+</li></ol>
+
+</div>
+
+<h2 id="commentextension">24. Comment Extension <span onclick="ToggleVis(24);">(hide/show)</span></h2>
+
+<div id="p24">
+
+<h3>a. Description</h3>
+
+<p>The Comment Extension contains textual information which is not part of the
+actual graphics in the GIF Data Stream. It is suitable for including comments
+about the graphics, credits, descriptions or any other type of non-control and
+non-graphic data. The Comment Extension may be ignored by the decoder, or it
+may be saved for later processing; under no circumstances should a Comment
+Extension disrupt or interfere with the processing of the Data Stream.</p>
+
+<p>This block is <i>optional</i>; any number of them may appear in the Data
+Stream.</p>
+
+<h3>b. Required Version</h3>
+
+<p>89a.</p>
+
+<h3>c. Syntax</h3>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td>Extension Introducer
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">1
+		</td><td>Comment Label
+		</td><td>Byte
+</td></tr></tbody></table>
+
+<p></p>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">N
+		</td><td>Comment Data
+		</td><td><a href="#subblocks">Data Sub-blocks</a>
+</td></tr></tbody></table>
+
+<p></p>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td><a href="#blockterminator">Block Terminator</a>
+		</td><td>Byte
+</td></tr></tbody></table>
+
+<ol style="list-style-type:lower-roman;">
+	<li>Extension Introducer:
+	<ul>
+		<li>Identifies the beginning of an extension block. This field contains
+		the fixed value <tt>0x21</tt> (33, <tt>'!'</tt>).
+	</li></ul>
+	</li><li>Comment Label:
+	<ul>
+		<li>Identifies the block as a Comment Extension. This field contains
+		the fixed value <tt>0xFE</tt> (254).
+	</li></ul>
+	</li><li>Comment Data:
+	<ul>
+		<li>Sequence of sub-blocks, each of size at most 255 bytes and at least
+		1 byte, with the size in a byte preceding the data. The end of the
+		sequence is marked by the <a href="#blockterminator">Block
+		Terminator</a>.
+	</li></ul>
+	</li><li>Block Terminator:
+	<ul>
+		<li>This zero-length data block marks the end of the Comment Extension.
+	</li></ul>
+</li></ol>
+
+<h3>d. Extensions and Scope</h3>
+
+<p>This block does not have scope. This block cannot be modified by any
+extension.</p>
+
+<h3>e. Recommendations</h3>
+
+<ol style="list-style-type:lower-roman;">
+	<li>Data:
+	<ul>
+		<li>This block is intended for humans. It should contain text using the
+		7-bit ASCII character set. This block should not be used to store
+		control information for custom processing.
+	</li></ul>
+	</li><li>Position:
+	<ul>
+		<li>This block may appear at any point in the Data Stream at which a
+		block can begin; however, it is recommended that Comment Extensions do
+		not interfere with Control or Data blocks; they should be located at
+		the beginning or at the end of the Data Stream to the extent possible.
+	</li></ul>
+</li></ol>
+
+</div>
+
+<h2 id="plaintextextension">25. Plain Text Extension <span onclick="ToggleVis(25);">(hide/show)</span></h2>
+
+<div id="p25">
+
+<h3>a. Description</h3>
+
+<p>The Plain Text Extension contains textual data and the parameters necessary
+to render that data as a graphic, in a simple form. The textual data will be
+encoded with the 7-bit printable ASCII characters. Text data are rendered using
+a grid of character cells defined by the parameters in the block fields. Each
+character is rendered in an individual cell. The textual data in this block is
+to be rendered as mono-spaced characters, one character per cell, with a best
+fitting font and size. For further information, see the section on
+Recommendations below.</p>
+
+<p>The data characters are taken sequentially from the data portion of the
+block and rendered within a cell, starting with the upper left cell in the grid
+and proceeding from left to right and from top to bottom. Text data is rendered
+until the end of data is reached or the character grid is filled. The Character
+Grid contains an integral number of cells; in the case that the cell dimensions
+do not allow for an integral number, fractional cells must be discarded; an
+encoder must be careful to specify the grid dimensions accurately so that this
+does not happen.</p>
+
+<p>This block requires a <a href="#globalcolortable">Global Color Table</a> to
+be available; the colors used by this block reference the Global Color Table in
+the Stream if there is one, or the Global Color Table from a previous Stream,
+if one was saved.</p>
+
+<p>This block is a graphic rendering block, therefore it may be modified by a
+<a href="#graphiccontrolextension">Graphic Control Extension</a>.</p>
+
+<p>This block is <i>optional</i>; any number of them may appear in the Data
+Stream.</p>
+
+<h3>b. Required Version</h3>
+
+<p>89a.</p>
+
+<h3>c. Syntax</h3>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td>Extension Introducer
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">1
+		</td><td>Plain Text Label
+		</td><td>Byte
+</td></tr></tbody></table>
+
+<p></p>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td>Block Size
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">1
+		</td><td rowspan="2">Text Grid Left Position
+		</td><td rowspan="2">Unsigned
+	</td></tr><tr>
+		<td style="text-align:center;">2
+	</td></tr><tr>
+		<td style="text-align:center;">3
+		</td><td rowspan="2">Text Grid Top Position
+		</td><td rowspan="2">Unsigned
+	</td></tr><tr>
+		<td style="text-align:center;">4
+	</td></tr><tr>
+		<td style="text-align:center;">5
+		</td><td rowspan="2">Text Grid Width
+		</td><td rowspan="2">Unsigned
+	</td></tr><tr>
+		<td style="text-align:center;">6
+	</td></tr><tr>
+		<td style="text-align:center;">7
+		</td><td rowspan="2">Text Grid Height
+		</td><td rowspan="2">Unsigned
+	</td></tr><tr>
+		<td style="text-align:center;">8
+	</td></tr><tr>
+		<td style="text-align:center;">9
+		</td><td>Character Cell Width
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">10
+		</td><td>Character Cell Height
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">11
+		</td><td>Text Foreground Color Index
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">12
+		</td><td>Text Background Color Index
+		</td><td>Byte
+</td></tr></tbody></table>
+
+<p></p>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">N
+		</td><td>Plain Text Data
+		</td><td>Data Sub-blocks
+</td></tr></tbody></table>
+
+<p></p>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td><a href="#blockterminator">Block Terminator</a>
+		</td><td>Byte
+</td></tr></tbody></table>
+
+<ol style="list-style-type:lower-roman;">
+	<li>Extension Introducer:
+	<ul>
+		<li>Identifies the beginning of an extension block. This field contains
+		the fixed value <tt>0x21</tt> (33, <tt>'!'</tt>).
+	</li></ul>
+	</li><li>Plain Text Label:
+	<ul>
+		<li>Identifies the current block as a Plain Text Extension. This field
+		contains the fixed value <tt>0x01</tt> (1).
+	</li></ul>
+	</li><li>Block Size:
+	<ul>
+		<li>Number of bytes in the extension, after the Block Size field and up
+		to but not including the beginning of the data portion. This field
+		contains the fixed value <tt>0x0C</tt> (12).
+	</li></ul>
+	</li><li>Text Grid Left Position:
+	<ul>
+		<li>Column number, in pixels, of the left edge of the text grid, with
+		respect to the left edge of the Logical Screen.
+	</li></ul>
+	</li><li>Text Grid Top Position:
+	<ul>
+		<li>Row number, in pixels, of the top edge of the text grid, with
+		respect to the top edge of the Logical Screen.
+	</li></ul>
+	</li><li>Image Grid Width:
+	<ul>
+		<li>Width of the text grid in pixels.
+	</li></ul>
+	</li><li>Image Grid Height:
+	<ul>
+		<li>Height of the text grid in pixels.
+	</li></ul>
+	</li><li>Character Cell Width:
+	<ul>
+		<li>Width, in pixels, of each cell in the grid.
+	</li></ul>
+	</li><li>Character Cell Height:
+	<ul>
+		<li>Height, in pixels, of each cell in the grid.
+	</li></ul>
+	</li><li>Text Foreground Color Index:
+	<ul>
+		<li>Index into the Global Color Table to be used to render the text
+		foreground.
+	</li></ul>
+	</li><li>Text Background Color Index:
+	<ul>
+		<li>Index into the Global Color Table to be used to render the text
+		background.
+	</li></ul>
+	</li><li>Plain Text Data:
+	<ul>
+		<li>Sequence of sub-blocks, each of size at most 255 bytes and at least
+		1 byte, with the size in a byte preceding the data. The end of the
+		sequence is marked by the Block Terminator.
+	</li></ul>
+	</li><li>Block Terminator:
+	<ul>
+		<li>This zero-length data block marks the end of the Plain Text Data
+		Blocks.
+	</li></ul>
+</li></ol>
+
+<h3>d. Extensions and Scope</h3>
+
+<p>The scope of this block is the Plain Text Data Block contained in it. This
+block may be modified by the Graphic Control Extension.</p>
+
+<h3 id="p25e">e. Recommendations</h3>
+
+<p>The data in the Plain Text Extension is assumed to be preformatted. The
+selection of font and size is left to the discretion of the decoder. If
+characters less than <tt>0x20</tt> (32) or greater than <tt>0xF7</tt> (247) are
+encountered, it is recommended that the decoder display a Space character
+(<tt>0x20</tt>, 32). The encoder should use grid and cell dimensions such that
+an integral number of cells fit in the grid both horizontally as well as
+vertically. For broadest compatibility, character cell dimensions should be
+around 88 or 816 (width  height); consider an image for
+unusual sized text.</p>
+
+<p><i>Editor's (Kalle's) note: the upper limit for a printable character,
+<tt>0xF7</tt>, seems odd. Maybe they meant <tt>0x7E</tt> (126, <tt>'~'</tt>,
+the last printable 7-bit ASCII character)?</i></p>
+
+</div>
+
+<h2 id="applicationextension">26. Application Extension <span onclick="ToggleVis(26);">(hide/show)</span></h2>
+
+<div id="p26">
+
+<h3>a. Description</h3>
+
+<p>The Application Extension contains application-specific information; it
+conforms with the extension block syntax, as described below, and its block
+label is <tt>0xFF</tt> (255).</p>
+
+<h3>b. Required Version</h3>
+
+<p>89a.</p>
+
+<h3>c. Syntax</h3>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td>Extension Introducer
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">1
+		</td><td>Extension Label
+		</td><td>Byte
+</td></tr></tbody></table>
+
+<p></p>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td>Block Size
+		</td><td>Byte
+	</td></tr><tr>
+		<td style="text-align:center;">18
+		</td><td>Application Identifier
+		</td><td>8 Bytes
+	</td></tr><tr>
+		<td style="text-align:center;">911
+		</td><td>Application Authentication Code
+		</td><td>3 Bytes
+</td></tr></tbody></table>
+
+<p></p>
+
+<table>
+	<tbody><tr>
+		<th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td>Application Data
+		</td><td><a href="#subblocks">Data Sub-blocks</a>
+</td></tr></tbody></table>
+
+<p></p>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td><a href="#blockterminator">Block Terminator</a>
+		</td><td>Byte
+</td></tr></tbody></table>
+
+<ol style="list-style-type:lower-roman;">
+	<li>Extension Introducer:
+	<ul>
+		<li>Defines this block as an extension. This field contains the fixed
+		value <tt>0x21</tt> (33, <tt>'!'</tt>).
+	</li></ul>
+	</li><li>Application Extension Label:
+	<ul>
+		<li>Identifies the block as an Application Extension. This field
+		contains the fixed value <tt>0xFF</tt> (255).
+	</li></ul>
+	</li><li>Block Size:
+	<ul>
+		<li>Number of bytes in this extension block, following the Block Size
+		field, up to but not including the beginning of the Application Data.
+		This field contains the fixed value <tt>0x0B</tt> (11).
+	</li></ul>
+	</li><li>Application Identifier:
+	<ul>
+		<li>Sequence of eight printable ASCII characters used to identify the
+		application owning the Application Extension.
+	</li></ul>
+	</li><li>Application Authentication Code:
+	<ul>
+		<li>Sequence of three bytes used to authenticate the Application
+		Identifier. An Application program may use an algorithm to compute a
+		binary code that uniquely identifies it as the application owning the
+		Application Extension.
+	</li></ul>
+</li></ol>
+
+<h3>d. Extensions and Scope</h3>
+
+<p>This block does not have scope. This block cannot be modified by any extension.</p>
+
+<h3>e. Recommendation</h3>
+
+<p>None.</p>
+
+</div>
+
+<h2 id="trailer">27. Trailer <span onclick="ToggleVis(27);">(hide/show)</span></h2>
+
+<div id="p27">
+
+<h3>a. Description</h3>
+
+<p>This block is a single-field block indicating the end of the GIF Data
+Stream. It contains the fixed value <tt>0x3B</tt> (59, <tt>';'</tt>).</p>
+
+<h3>b. Required Version</h3>
+
+<p>87a.</p>
+
+<h3>c. Syntax</h3>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Field Name
+		</th><th>Type
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td>GIF Trailer
+		</td><td>Byte
+</td></tr></tbody></table>
+
+<h3>d. Extensions and Scope</h3>
+
+<p>This block does not have scope, it terminates the GIF Data Stream. This
+block may not be modified by any extension.</p>
+
+<h3>e. Recommendations</h3>
+
+<p>None.</p>
+
+</div>
+
+<h2 id="quickreferencetable">Appendix A. Quick Reference Table <span onclick="ToggleVis(28);">(hide/show)</span></h2>
+
+<div id="p28">
+
+<table>
+	<tbody><tr>
+		<th>Block Name
+		</th><th>Required?
+		</th><th>Label
+		</th><th>Extension
+		</th><th>Version
+	</th></tr><tr>
+		<th colspan="5">Unlabeled Blocks
+	</th></tr><tr>
+		<td><a href="#header">Header</a>
+		</td><td>required (one occurrence)
+		</td><td style="text-align:center;">none
+		</td><td style="text-align:center;">no
+		</td><td style="text-align:center;">N/A
+	</td></tr><tr>
+		<td><a href="#logicalscreendescriptor">Logical Screen Descriptor</a>
+		</td><td>required (one occurrence)
+		</td><td style="text-align:center;">none
+		</td><td style="text-align:center;">no
+		</td><td style="text-align:center;">87a (89a)
+	</td></tr><tr>
+		<td><a href="#globalcolortable">Global Color Table</a>
+		</td><td>optional (at most one occurrence)
+		</td><td style="text-align:center;">none
+		</td><td style="text-align:center;">no
+		</td><td style="text-align:center;">87a
+	</td></tr><tr>
+		<td><a href="#localcolortable">Local Color Table</a>
+		</td><td>optional (zero or more occurrences)
+		</td><td style="text-align:center;">none
+		</td><td style="text-align:center;">no
+		</td><td style="text-align:center;">87a
+	</td></tr><tr>
+		<th colspan="5">Graphic-Rendering Blocks
+	</th></tr><tr>
+		<td><a href="#plaintextextension">Plain Text Extension</a>
+		</td><td>optional (zero or more occurrences)
+		</td><td style="text-align:center;"><tt>0x01</tt> (1)
+		</td><td style="text-align:center;">yes
+		</td><td style="text-align:center;">89a
+	</td></tr><tr>
+		<td><a href="#imagedescriptor">Image Descriptor</a>
+		</td><td>optional (zero or more occurrences)
+		</td><td style="text-align:center;"><tt>0x2C</tt> (44, <tt>','</tt>)
+		</td><td style="text-align:center;">no
+		</td><td style="text-align:center;">87a (89a)
+	</td></tr><tr>
+		<th colspan="5">Control Blocks
+	</th></tr><tr>
+		<td><a href="#graphiccontrolextension">Graphic Control Extension</a>
+		</td><td>optional (zero or more occurrences)
+		</td><td style="text-align:center;"><tt>0xF9</tt> (249)
+		</td><td style="text-align:center;">yes
+		</td><td style="text-align:center;">89a
+	</td></tr><tr>
+		<th colspan="5">Special Purpose Blocks
+	</th></tr><tr>
+		<td><a href="#trailer">Trailer</a>
+		</td><td>required (one occurrence)
+		</td><td style="text-align:center;"><tt>0x3B</tt> (59, <tt>';'</tt>)
+		</td><td style="text-align:center;">no
+		</td><td style="text-align:center;">87a
+	</td></tr><tr>
+		<td><a href="#commentextension">Comment Extension</a>
+		</td><td>optional (zero or more occurrences)
+		</td><td style="text-align:center;"><tt>0xFE</tt> (254)
+		</td><td style="text-align:center;">yes
+		</td><td style="text-align:center;">89a
+	</td></tr><tr>
+		<td><a href="#applicationextension">Application Extension</a>
+		</td><td>optional (zero or more occurrences)
+		</td><td style="text-align:center;"><tt>0xFF</tt> (255)
+		</td><td style="text-align:center;">yes
+		</td><td style="text-align:center;">89a
+</td></tr></tbody></table>
+
+<p>Notes:</p>
+
+<ul>
+	<li>The Header is not subject to Version Numbers.
+	</li><li>(89a) The Logical Screen Descriptor and the Image Descriptor retained
+	their syntax from version 87a to version 89a, but some fields reserved
+	under version 87a are used under version 89a.
+</li></ul>
+
+</div>
+
+<h2 id="gifgrammar">Appendix B. GIF Grammar <span onclick="ToggleVis(29);">(hide/show)</span></h2>
+
+<div id="p29">
+
+<p>A Grammar is a form of notation to represent the sequence in which certain
+objects form larger objects. A grammar is also used to represent the number of
+objects that can occur at a given position. The grammar given here represents
+the sequence of blocks that form the GIF Data Stream. A grammar is given by
+listing its rules. Each rule consists of the left-hand side, followed by some
+form of equals sign, followed by the right-hand side. In a rule, the right-hand
+side describes how the left-hand side is defined. The right-hand side consists
+of a sequence of entities, with the possible presence of special symbols. The
+following legend defines the symbols used in this grammar for GIF.</p>
+
+<p>Legend:</p>
+
+<table>
+	<tbody><tr>
+		<td style="text-align:center;">&lt; &gt;
+		</td><td>grammar word
+	</td></tr><tr>
+		<td style="text-align:center;">::=
+		</td><td>defines symbol
+	</td></tr><tr>
+		<td style="text-align:center;">*
+		</td><td>zero or more occurrences
+	</td></tr><tr>
+		<td style="text-align:center;">+
+		</td><td>one or more occurrences
+	</td></tr><tr>
+		<td style="text-align:center;">|
+		</td><td>alternate element
+	</td></tr><tr>
+		<td style="text-align:center;">[ ]
+		</td><td>optional element
+</td></tr></tbody></table>
+
+<p>Example:</p>
+
+<blockquote>
+	<p>&lt;GIF Data Stream&gt; ::= <a href="#header">Header</a> &lt;Logical
+	Screen&gt; &lt;Data&gt;* <a href="#trailer">Trailer</a></p>
+</blockquote>
+
+<p>This rule defines the entity &lt;GIF Data Stream&gt; as follows. It must
+begin with a Header. The Header is followed by an entity called Logical Screen,
+which is defined below by another rule. The Logical Screen is followed by the
+entity Data, which is also defined below by another rule. Finally, the entity
+Data is followed by the Trailer. Since there is no rule defining the Header or
+the Trailer, this means that these blocks are defined in the document. The
+entity Data has a special symbol (*) following it which means that, at this
+position, the entity Data may be repeated any number of times, including 0
+times. For further reading on this subject, refer to a standard text on
+Programming Languages.</p>
+
+<h3>The Grammar</h3>
+
+<table class="invisible">
+	<tbody><tr>
+		<td>&lt;GIF Data Stream&gt;
+		</td><td>::=
+		</td><td>Header &lt;Logical Screen&gt; &lt;Data&gt;* Trailer
+	</td></tr><tr>
+		<td>&lt;Logical Screen&gt;
+		</td><td>::=
+		</td><td><a href="#logicalscreendescriptor">Logical Screen Descriptor</a>
+		[<a href="#globalcolortable">Global Color Table</a>]
+	</td></tr><tr>
+		<td>&lt;Data&gt;
+		</td><td>::=
+		</td><td>&lt;Graphic Block&gt; | &lt;Special-Purpose Block&gt;
+	</td></tr><tr>
+		<td>&lt;Graphic Block&gt;
+		</td><td>::=
+		</td><td>[<a href="#graphiccontrolextension">Graphic Control Extension</a>]
+		&lt;Graphic-Rendering Block&gt;
+	</td></tr><tr>
+		<td>&lt;Graphic-Rendering Block&gt;
+		</td><td>::=
+		</td><td>&lt;Table-Based Image&gt; | <a href="#plaintextextension">Plain
+		Text Extension</a>
+	</td></tr><tr>
+		<td>&lt;Table-Based Image&gt;
+		</td><td>::=
+		</td><td><a href="#imagedescriptor">Image Descriptor</a> [<a href="#localcolortable">Local Color Table</a>] <a href="#tablebasedimagedata">Image Data</a>
+	</td></tr><tr>
+		<td>&lt;Special-Purpose Block&gt;
+		</td><td>::=
+		</td><td><a href="#applicationextension">Application Extension</a> | <a href="#commentextension">Comment Extension</a>
+</td></tr></tbody></table>
+
+<p><i>Note:</i> The grammar indicates that it is possible for a GIF Data Stream
+to contain the Header, the Logical Screen Descriptor, a Global Color Table and
+the GIF Trailer. This special case is used to load a GIF decoder with a Global
+Color Table, in preparation for subsequent Data Streams without color tables at
+all.</p>
+
+</div>
+
+<h2 id="glossary">Appendix C. Glossary <span onclick="ToggleVis(30);">(hide/show)</span></h2>
+
+<div id="p30">
+
+<table>
+	<tbody><tr>
+		<td>Active Color Table
+		</td><td>Color table used to render the next graphic. If the next graphic is
+		an image which has a <a href="#localcolortable">Local Color Table</a>
+		associated with it, the active color table becomes the Local Color
+		Table associated with that image. If the next graphic is an image
+		without a Local Color Table, or a <a href="#plaintextextension">Plain
+		Text Extension</a>, the active color table is the <a href="#globalcolortable">Global Color Table</a> associated with the
+		Data Stream, if there is one; if there is no Global Color Table in the
+		Data Stream, the active color table is a color table saved from a
+		previous Data Stream, or one supplied by the decoder.
+	</td></tr><tr>
+		<td>Block
+		</td><td>Collection of bytes forming a protocol unit. In general, the term
+		includes labeled and unlabeled blocks, as well as Extensions.
+	</td></tr><tr>
+		<td>Data Stream
+		</td><td>The GIF Data Stream is composed of blocks and <a href="#subblocks">sub-blocks</a> representing images and graphics,
+		together with control information to render them on a display device.
+		All control and data blocks in the Data Stream must follow the <a href="#header">Header</a> and must precede the <a href="#trailer">Trailer</a>.
+	</td></tr><tr>
+		<td>Decoder
+		</td><td>A program capable of processing a GIF Data Stream to render the
+		images and graphics contained in it.
+	</td></tr><tr>
+		<td>Encoder
+		</td><td>A program capable of capturing and formatting image and graphic
+		raster data, following the definitions of the Graphics Interchange
+		Format.
+	</td></tr><tr>
+		<td>Extension
+		</td><td>A protocol block labeled by the Extension Introducer <tt>0x21</tt>
+		(33, <tt>'!'</tt>).
+	</td></tr><tr>
+		<td>Extension Introducer
+		</td><td>Label (<tt>0x21</tt>, 33, <tt>'!'</tt>) defining an Extension.
+	</td></tr><tr>
+		<td>Graphic
+		</td><td>Data which can be rendered on the screen by virtue of some
+		algorithm. The term graphic is more general than the term image; in
+		addition to images, the term graphic also includes data such as text,
+		which is rendered using character bit-maps.
+	</td></tr><tr>
+		<td>Image
+		</td><td>Data representing a picture or a drawing; an image is represented
+		by an array of pixels called the raster of the image.
+	</td></tr><tr>
+		<td>Raster
+		</td><td>Array of pixel values representing an image.
+</td></tr></tbody></table>
+
+</div>
+
+<h2 id="conventions">Appendix D. Conventions <span onclick="ToggleVis(31);">(hide/show)</span></h2>
+
+<div id="p31">
+
+<table>
+	<tbody><tr>
+		<td>Animation
+		</td><td>The Graphics Interchange Format is not intended as a platform for
+		animation, even though it can be done in a limited way.
+	</td></tr><tr>
+		<td>Byte Ordering
+		</td><td>Unless otherwise stated, multi-byte numeric fields are ordered with
+		the Least Significant Byte first.
+	</td></tr><tr>
+		<td>Color Indices
+		</td><td>Color indices always refer to the active color table, either the <a href="#globalcolortable">Global Color Table</a> or the <a href="#localcolortable">Local Color Table</a>.
+	</td></tr><tr>
+		<td>Color Order
+		</td><td>Unless otherwise stated, all triple-component RGB color values are
+		specified in <span class="rcomp">Red</span>-<span class="gcomp">Green</span>-<span class="bcomp">Blue</span> order.
+	</td></tr><tr>
+		<td>Color Tables
+		</td><td>Both color tables, the Global and the Local, are optional; if
+		present, the Global Color Table is to be used with every image in the
+		Data Stream for which a Local Color Table is not given; if present, a
+		Local Color Table overrides the Global Color Table. However, if neither
+		color table is present, the application program is free to use an
+		arbitrary color table. If the graphics in several Data Streams are
+		related and all use the same color table, an encoder could place the
+		color table as the Global Color Table in the first Data Stream and
+		leave subsequent Data Streams without a Global Color Table or any Local
+		Color Tables; in this way, the overhead for the table is eliminated. It
+		is recommended that the decoder save the previous Global Color Table to
+		be used with the Data Stream that follows, in case it does not contain
+		either a Global Color Table or any Local Color Tables. In general, this
+		allows the application program to use past color tables, significantly
+		reducing transmission overhead.
+	</td></tr><tr>
+		<td>Extension Blocks
+		</td><td>Extensions are defined using the Extension Introducer code
+		(<tt>0x21</tt>, 33, <tt>'!'</tt>) to mark the beginning of the block,
+		followed by a block label, identifying the type of extension. Extension
+		Codes are numbers in the range from <tt>0x00</tt> (0) to <tt>0xFF</tt>
+		(255), inclusive. Special purpose extensions are transparent to the
+		decoder and may be omitted when transmitting the Data Stream on-line.
+		The GIF capabilities dialogue makes the provision for the receiver to
+		request the transmission of all blocks; the default state in this
+		regard is no transmission of Special purpose blocks.
+	</td></tr><tr>
+		<td>Reserved Fields
+		</td><td>All Reserved Fields are expected to have each bit set to zero
+		(off).
+</td></tr></tbody></table>
+
+</div>
+
+<h2 id="interlacedimages">Appendix E. Interlaced Images <span onclick="ToggleVis(32);">(hide/show)</span></h2>
+
+<div id="p32">
+
+<p>The rows of an Interlaced images are arranged in the following order:</p>
+
+<table>
+	<tbody><tr>
+		<td>Group 1
+		</td><td>Pass 1
+		</td><td>Every 8th row, starting with row 0
+	</td></tr><tr>
+		<td>Group 2
+		</td><td>Pass 2
+		</td><td>Every 8th row, starting with row 4
+	</td></tr><tr>
+		<td>Group 3
+		</td><td>Pass 3
+		</td><td>Every 4th row, starting with row 2
+	</td></tr><tr>
+		<td>Group 4
+		</td><td>Pass 4
+		</td><td>Every 2nd row, starting with row 1
+</td></tr></tbody></table>
+
+<p>The following example illustrates how the rows of an interlaced image are
+ordered.</p>
+
+<table id="interlace">
+	<tbody><tr>
+		<th>Row Number
+		</th><th colspan="4">Interlace Pass
+	</th></tr><tr>
+		<td>0
+		</td><td>1
+		</td><td>
+		</td><td>
+		</td><td>
+	</td></tr><tr>
+		<td>1
+		</td><td>
+		</td><td>
+		</td><td>
+		</td><td>4
+	</td></tr><tr>
+		<td>2
+		</td><td>
+		</td><td>
+		</td><td>3
+		</td><td>
+	</td></tr><tr>
+		<td>3
+		</td><td>
+		</td><td>
+		</td><td>
+		</td><td>4
+	</td></tr><tr>
+		<td>4
+		</td><td>
+		</td><td>2
+		</td><td>
+		</td><td>
+	</td></tr><tr>
+		<td>5
+		</td><td>
+		</td><td>
+		</td><td>
+		</td><td>4
+	</td></tr><tr>
+		<td>6
+		</td><td>
+		</td><td>
+		</td><td>3
+		</td><td>
+	</td></tr><tr>
+		<td>7
+		</td><td>
+		</td><td>
+		</td><td>
+		</td><td>4
+	</td></tr><tr>
+		<td>8
+		</td><td>1
+		</td><td>
+		</td><td>
+		</td><td>
+	</td></tr><tr>
+		<td>9
+		</td><td>
+		</td><td>
+		</td><td>
+		</td><td>4
+	</td></tr><tr>
+		<td>10
+		</td><td>
+		</td><td>
+		</td><td>3
+		</td><td>
+	</td></tr><tr>
+		<td>11
+		</td><td>
+		</td><td>
+		</td><td>
+		</td><td>4
+	</td></tr><tr>
+		<td>12
+		</td><td>
+		</td><td>2
+		</td><td>
+		</td><td>
+	</td></tr><tr>
+		<td>13
+		</td><td>
+		</td><td>
+		</td><td>
+		</td><td>4
+	</td></tr><tr>
+		<td>14
+		</td><td>
+		</td><td>
+		</td><td>3
+		</td><td>
+	</td></tr><tr>
+		<td>15
+		</td><td>
+		</td><td>
+		</td><td>
+		</td><td>4
+	</td></tr><tr>
+		<td>16
+		</td><td>1
+		</td><td>
+		</td><td>
+		</td><td>
+	</td></tr><tr>
+		<td>17
+		</td><td>
+		</td><td>
+		</td><td>
+		</td><td>4
+	</td></tr><tr>
+		<td>18
+		</td><td>
+		</td><td>
+		</td><td>3
+		</td><td>
+	</td></tr><tr>
+		<td>19
+		</td><td>
+		</td><td>
+		</td><td>
+		</td><td>4
+</td></tr></tbody></table>
+
+</div>
+
+<h2 id="lzw">Appendix F. Variable-Length-Code LZW Compression <span onclick="ToggleVis(33);">(hide/show)</span></h2>
+
+<div id="p33">
+
+<p>The Variable-Length-Code LZW Compression is a variation of the Lempel-Ziv
+Compression algorithm in which variable-length codes are used to replace
+patterns detected in the original data. The algorithm uses a code or
+translation table constructed from the patterns encountered in the original
+data; each new pattern is entered into the table and its index is used to
+replace it in the compressed stream.</p>
+
+<p>The compressor takes the data from the input stream and builds a code or
+translation table with the patterns as it encounters them; each new pattern is
+entered into the code table and its index is added to the output stream; when a
+pattern is encountered which had been detected since the last code table
+refresh, its index from the code table is put on the output stream, thus
+achieving the data compression. The expander takes input from the compressed
+data stream and builds the code or translation table from it; as the compressed
+data stream is processed, codes are used to index into the code table and the
+corresponding data is put on the decompressed output stream, thus achieving
+data decompression. The details of the algorithm are explained below. The
+Variable-Length-Code aspect of the algorithm is based on an initial code size
+(LZW-initial code size), which specifies the initial number of bits used for
+the compression codes. When the number of patterns detected by the compressor
+in the input stream exceeds the number of patterns encodable with the current
+number of bits, the number of bits per LZW code is increased by one.</p>
+
+<p>The Raster Data stream that represents the actual output image can be
+represented as:</p>
+
+<table>
+	<tbody><tr>
+		<th>Field name
+	</th></tr><tr>
+		<td>LZW code size
+</td></tr></tbody></table>
+
+<p></p>
+
+<table>
+	<tbody><tr>
+		<th>Field name
+		</th><th>
+	</th></tr><tr>
+		<td>block size
+		</td><td rowspan="2">Repeated as many times as necessary.
+	</td></tr><tr>
+		<td>data bytes
+</td></tr></tbody></table>
+
+<p>(The code that terminates the LZW compressed data must appear before <a href="#blockterminator">Block Terminator</a>.)</p>
+
+<table>
+	<tbody><tr>
+		<th>Field name
+	</th></tr><tr>
+		<td>Block Terminator (<tt>0x00</tt>, 0)
+</td></tr></tbody></table>
+
+<p>The conversion of the image from a series of pixel values to a transmitted
+or stored character stream involves several steps. In brief these steps
+are:</p>
+
+<ol>
+	<li>Establish the Code Size  Define the number of bits needed to
+	represent the actual data.
+	</li><li>Compress the Data  Compress the series of image pixels to a
+	series of compression codes.
+	</li><li>Build a Series of Bytes  Take the set of compression codes and
+	convert to a string of 8-bit bytes.
+	</li><li>Package the Bytes  Package sets of bytes into blocks preceded by
+	character counts and output.
+</li></ol>
+
+<h3>1. Establish Code Size</h3>
+
+<p>The first byte of the Compressed Data stream is a value indicating the
+minimum number of bits required to represent the set of actual pixel values.
+Normally this will be the same as the number of color bits. Because of some
+algorithmic constraints however, black &amp; white images which have one color
+bit must be indicated as having a code size of 2. This code size value also
+implies that the compression codes must start out one bit longer.</p>
+
+<h3>2. Compression</h3>
+
+<p>The LZW algorithm converts a series of data values into a series of codes
+which may be raw values or a code designating a series of values. Using text
+characters as an analogy, the output code consists of a character or a code
+representing a string of characters.</p>
+
+<p>The LZW algorithm used in GIF matches algorithmically with the standard LZW
+algorithm with the following differences:</p>
+
+<ol>
+	<li>A special Clear code is defined which resets all
+	compression/decompression parameters and tables to a start-up state. The
+	value of this code is 2<sup>&lt;code size&gt;</sup>. For example if the
+	code size indicated was 4 (image was 4 bits/pixel) the Clear code value
+	would be 16 (<tt>10000</tt> binary). The Clear code can appear at any point
+	in the image data stream and therefore requires the LZW algorithm to
+	process succeeding codes as if a new data stream was starting. Encoders
+	should output a Clear code as the first code of each image data stream.
+	</li><li>An End of Information code is defined that explicitly indicates the end
+	of the image data stream. LZW processing terminates when this code is
+	encountered. It must be the last code output by the encoder for an image.
+	The value of this code is &lt;Clear code&gt;+1.
+	</li><li>The first available compression code value is &lt;Clear code&gt; + 2.
+	</li><li>The output codes are of variable length, starting at &lt;code size&gt;
+	+ 1 bits per code, up to 12 bits per code. This defines a maximum code
+	value of 4095 (<tt>0xFFF</tt>). Whenever the LZW code value would exceed
+	the current code length, the code length is increased by one. The
+	packing/unpacking of these codes must then be altered to reflect the new
+	code length.
+</li></ol>
+
+<p><i>Editor's (Kalle's) note: see also the <a href="#coversheet">Cover
+Sheet</a>.</i></p>
+
+<h3>3. Build 8-bit Bytes</h3>
+
+<p>Because the LZW compression used for GIF creates a series of variable length
+codes, of between 3 and 12 bits each, these codes must be reformed into a
+series of 8-bit bytes that will be the characters actually stored or
+transmitted. This provides additional compression of the image. The codes are
+formed into a stream of bits as if they were packed right to left and then
+picked off 8 bits at a time to be output.</p>
+
+<p>Assuming a character array of 8 bits per character and using 5 bit codes to
+be packed, an example layout would be similar to:</p>
+
+<table>
+	<tbody><tr>
+		<th>Byte #
+		</th><th>Bits
+	</th></tr><tr>
+		<td style="text-align:center;">0
+		</td><td><tt>bbbaaaaa</tt>
+	</td></tr><tr>
+		<td style="text-align:center;">1
+		</td><td><tt>dcccccbb</tt>
+	</td></tr><tr>
+		<td style="text-align:center;">2
+		</td><td><tt>eeeedddd</tt>
+	</td></tr><tr>
+		<td style="text-align:center;">3
+		</td><td><tt>ggfffffe</tt>
+	</td></tr><tr>
+		<td style="text-align:center;">4
+		</td><td><tt>hhhhhggg</tt>
+	</td></tr><tr>
+		<td style="text-align:center;">
+		</td><td><tt></tt>
+	</td></tr><tr>
+		<td style="text-align:center;">N
+		</td><td>
+</td></tr></tbody></table>
+
+<p>Note that the physical packing arrangement will change as the number of bits
+per compression code change but the concept remains the same.</p>
+
+<h3>4. Package the Bytes</h3>
+
+<p>Once the bytes have been created, they are grouped into blocks for output by
+preceding each block of 0 to 255 bytes with a character count byte. A block
+with a zero byte count terminates the Raster Data stream for a given image.
+These blocks are what are actually output for the GIF image. This block format
+has the side effect of allowing a decoding program the ability to read past the
+actual image data if necessary by reading block counts and then skipping over
+the data.</p>
+
+<h3>Further Reading</h3>
+
+<ol>
+	<li>Ziv, J. and Lempel, A.: <i>A Universal Algorithm for Sequential Data
+	Compression</i>, IEEE Transactions on Information Theory, May 1977
+	</li><li>Welch, T.: <i>A Technique for High-Performance Data Compression</i>,
+	Computer, June 1984
+	</li><li>Nelson, M.R.: <i>LZW Data Compression</i>, Dr. Dobb's Journal, October
+	1989
+</li></ol>
+
+<p><i>Editor's (Kalle's) note: see also <a href="https://web.archive.org/web/20160304075538/http://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">Wikipedia 
+LempelZivWelch</a>.</i></p>
+
+</div>
+
+<h2 id="onlinecapabilities">Appendix G. On-line Capabilities Dialogue <span onclick="ToggleVis(34);">(hide/show)</span></h2>
+
+<div id="p34">
+
+<p><i>Note:</i> This section is currently (10 July 1990) under revision; the
+information provided here should be used as general guidelines. Code written
+based on this information should be designed in a flexible way to accommodate
+any changes resulting from the revisions.</p>
+
+<p>The following sequences are defined for use in mediating control between a
+GIF sender and GIF receiver over an interactive communications line. These
+sequences do not apply to applications that involve downloading of static GIF
+files and are not considered part of a GIF file.</p>
+
+<h3>GIF Capabilities Enquiry</h3>
+
+<p>The GIF Capabilities Enquiry sequence is issued from a host and requests an
+interactive GIF decoder to return a response message that defines the graphics
+parameters for the decoder. This involves returning information about available
+screen sizes, number of bits/color supported and the amount of color detail
+supported. The escape sequence for the GIF Capabilities Enquiry is defined
+as:</p>
+
+<table>
+	<tbody><tr>
+		<td style="text-align:center;"><tt>ESC</tt>
+		</td><td style="text-align:center;"><tt>0x1B</tt> (27)
+	</td></tr><tr>
+		<td style="text-align:center;"><tt>[</tt>
+		</td><td style="text-align:center;"><tt>0x5B</tt> (91)
+	</td></tr><tr>
+		<td style="text-align:center;"><tt>&gt;</tt>
+		</td><td style="text-align:center;"><tt>0x3E</tt> (62)
+	</td></tr><tr>
+		<td style="text-align:center;"><tt>0</tt>
+		</td><td style="text-align:center;"><tt>0x30</tt> (48)
+	</td></tr><tr>
+		<td style="text-align:center;"><tt>g</tt>
+		</td><td style="text-align:center;"><tt>0x67</tt> (103)
+</td></tr></tbody></table>
+
+<h3>GIF Capabilities Response</h3>
+
+<p>The GIF Capabilities Response message is returned by an interactive GIF
+decoder and defines the decoder's display capabilities for all graphics modes
+that are supported by the software. Note that this can also include graphics
+printers as well as a monitor screen. The general format of this message
+is:</p>
+
+<p>#version;protocol{;dev, width, height, color-bits,
+color-res}&lt;CR&gt;</p>
+
+<table>
+	<tbody><tr>
+		<td><tt>'#'</tt>
+		</td><td>GIF Capabilities Response identifier character.
+	</td></tr><tr>
+		<td>version
+		</td><td>GIF format version number; initially <tt>'87a'</tt>.
+	</td></tr><tr>
+		<td>protocol=<tt>'0'</tt>
+		</td><td>No end-to-end protocol supported by decoder Transfer as direct
+		8-bit data stream.
+	</td></tr><tr>
+		<td>protocol=<tt>'1'</tt>
+		</td><td>Can use CIS B+ error correction protocol to transfer GIF data
+		interactively from the host directly to the display.
+	</td></tr><tr>
+		<td>dev=<tt>'0'</tt>
+		</td><td>Screen parameter set follows.
+	</td></tr><tr>
+		<td>dev=<tt>'1'</tt>
+		</td><td>Printer parameter set follows.
+	</td></tr><tr>
+		<td>width
+		</td><td>Maximum supported display width in pixels.
+	</td></tr><tr>
+		<td>height
+		</td><td>Maximum supported display height in pixels.
+	</td></tr><tr>
+		<td>color-bits
+		</td><td>Number of bits per pixel supported. The number of supported colors
+		is therefore 2<sup>color-bits</sup>.
+	</td></tr><tr>
+		<td>color-res
+		</td><td>Number of bits per color component supported in the hardware color
+		palette. If color-res is <tt>'0'</tt> then no hardware palette table is
+		available.
+</td></tr></tbody></table>
+
+<p>Note that all values in the GIF Capabilities Response are returned as ASCII
+decimal numbers and the message is terminated by a Carriage Return character
+(<tt>0x0D</tt>, 13).</p>
+
+<p>The following GIF Capabilities Response message describes three standard IBM
+PC <a href="https://web.archive.org/web/20160304075538/http://en.wikipedia.org/wiki/Enhanced_Graphics_Adapter">Enhanced
+Graphics Adapter</a> configurations with no printer; the GIF data stream can be
+processed within an error correcting protocol:</p>
+
+<blockquote>
+	<p><tt>#87a;1;0,320,200,4,0;0,640,200,2,2;0,640,350,4,2&lt;CR&gt;</tt></p>
+</blockquote>
+
+<h3>Enter GIF Graphics Mode</h3>
+
+<p>Two sequences are currently defined to invoke an interactive GIF decoder
+into action. The only difference between them is that different output media
+are selected. These sequences are:</p>
+
+<table>
+	<tbody><tr>
+		<td style="text-align:center;"><tt>ESC</tt>
+		</td><td style="text-align:center;"><tt>0x1B</tt> (27)
+		</td><td rowspan="5">Display GIF image on screen
+	</td></tr><tr>
+		<td style="text-align:center;"><tt>[</tt>
+		</td><td style="text-align:center;"><tt>0x5B</tt> (91)
+	</td></tr><tr>
+		<td style="text-align:center;"><tt>&gt;</tt>
+		</td><td style="text-align:center;"><tt>0x3E</tt> (62)
+	</td></tr><tr>
+		<td style="text-align:center;"><tt>1</tt>
+		</td><td style="text-align:center;"><tt>0x31</tt> (49)
+	</td></tr><tr>
+		<td style="text-align:center;"><tt>g</tt>
+		</td><td style="text-align:center;"><tt>0x67</tt> (103)
+</td></tr></tbody></table>
+
+<p></p>
+
+<table>
+	<tbody><tr>
+		<td style="text-align:center;"><tt>ESC</tt>
+		</td><td style="text-align:center;"><tt>0x1B</tt> (27)
+		</td><td rowspan="5">Display image directly to an attached graphics printer.
+		The image may optionally be displayed on the screen as well.
+	</td></tr><tr>
+		<td style="text-align:center;"><tt>[</tt>
+		</td><td style="text-align:center;"><tt>0x5B</tt> (91)
+	</td></tr><tr>
+		<td style="text-align:center;"><tt>&gt;</tt>
+		</td><td style="text-align:center;"><tt>0x3E</tt> (62)
+	</td></tr><tr>
+		<td style="text-align:center;"><tt>2</tt>
+		</td><td style="text-align:center;"><tt>0x32</tt> (50)
+	</td></tr><tr>
+		<td style="text-align:center;"><tt>g</tt>
+		</td><td style="text-align:center;"><tt>0x67</tt> (103)
+</td></tr></tbody></table>
+
+<p>Note that the <tt>'g'</tt> character terminating each sequence is in
+lowercase.</p>
+
+<h3>Interactive Environment</h3>
+
+<p>The assumed environment for the transmission of GIF image data from an
+interactive application is a full 8-bit data stream from host to micro. All 256
+character codes must be transferrable. The establishing of an 8-bit data path
+for communications will normally be taken care of by the host application
+programs. It is however up to the receiving communications programs supporting
+GIF to be able to receive and pass on all 256 8-bit codes to the GIF decoder
+software.</p>
+
+</div>
+
+<h2 id="coversheet">Cover Sheet for the GIF89a Specification <span onclick="ToggleVis(35);">(hide/show)</span></h2>
+
+<div id="p35">
+
+<h3>Deferred clear code in LZW compression</h3>
+
+<p>There has been confusion about where clear codes can be found in the data
+stream. As the specification says, they may appear at anytime. There is not a
+requirement to send a clear code when the string table is full.</p>
+
+<p>It is the encoder's decision as to when the table should be cleared. When
+the table is full, the encoder can chose to use the table as is, making no
+changes to it until the encoder chooses to clear it. The encoder during this
+time sends out codes that are of the maximum Code Size.</p>
+
+<p>As we can see from the above, when the decoder's table is full, it must not
+change the table until a clear code is received. The Code Size is that of the
+maximum Code Size. Processing other than this is done normally.</p>
+
+<p>Because of a large base of decoders that do not handle the decompression in
+this manner, we ask developers of GIF encoding software to <i>not</i> implement
+this feature until at least January 1991 and later if they see that their
+particular market is not ready for it. This will give developers of GIF
+decoding software time to implement this feature and to get it into the hands
+of their clients before the decoders start "breaking" on the new GIF's. It is
+not required that encoders change their software to take advantage of the
+deferred clear code, but it is for decoders.</p>
+
+<h3>Application Extension Block  Application Identifier</h3>
+
+<p>There will be a Courtesy Directory file located on CompuServe in the PICS
+forum. This directory will contain Application Identifiers for <a href="#applicationextension">Application Extension Blocks</a> that have been
+used by developers of GIF applications. This file is intended to help keep
+developers that wish to create Application Extension Blocks from using the same
+Application Identifiers. This is not an official directory; it is for voluntary
+participation only and does not guarantee that someone will not use the same
+identifier.</p>
+
+<p>E-Mail can be sent to Larry Wood (forum manager of PICS) indicating the
+request for inclusion in this file with an identifier.</p>
+
+</div>
+<hr>
+</body>
+</html>
diff --git a/doc/gifstandard/LZW-and-GIF-explained.html b/doc/gifstandard/LZW-and-GIF-explained.html
new file mode 100644
index 0000000..a5ec5fc
--- /dev/null
+++ b/doc/gifstandard/LZW-and-GIF-explained.html
@@ -0,0 +1,352 @@
+<html>
+<head>
+<title>An Introduction to Data Compression</title>
+</head>
+<body>
+
+<h1>LZW and GIF explained<br>
+<font size="-1">by Steve Blackstock</font>
+</h1>
+
+<p>I hope this little document will help enlighten those of you out there
+who want to know more about the Lempel-Ziv Welch (LZW) compression algorithm, and,
+specifically, the implementation that GIF uses.</p>
+
+<p>Before we start, here's a little terminology, for the purposes of this
+document:</p>
+
+<ul>
+<li>
+      <strong>character</strong>: a fundamental data element. In normal text files, this is
+just a single byte. In raster images, which is what we're interested in, it's
+an index that specifies the color of a given pixel. I'll refer to an arbitray
+character as "K".
+</li><li>
+      <strong>charstream</strong>: a stream of characters, as in a data file.
+</li><li>
+      <strong>string</strong>: a number of continuous characters, anywhere from one to very
+many characters in length. I can specify an arbitrary string as "[...]K".
+</li><li>
+      <strong>prefix</strong>: almost the same as a string, but with the implication that a
+prefix immediately precedes a character, and a prefix can have a length of
+zero. So, a prefix and a character make up a string. I will refer to an
+arbitrary prefix as "[...]".
+</li><li>
+      <strong>root</strong>: a single-character string. For most purposes, this is a
+character, but we may occasionally make a distinction. It is [...]K, where
+[...] is empty.
+</li><li>
+      <strong>code</strong>: a number, specified by a known number of bits, which maps to a
+string.
+</li><li>
+      <strong>codestream</strong>: the output stream of codes, as in the "raster data"
+</li><li>
+      <strong>entry</strong>: a code and its string.
+</li><li>
+      <strong>string table</strong>: a list of entries; usually, but not necessarily, unique.
+</li>
+</ul>
+
+<p>
+     LZW is a way of compressing data that takes advantage of repetition of
+strings in the data. Since raster data usually contains a lot of this
+repetition, LZW is a good way of compressing and decompressing it.
+     For the moment, lets consider normal LZW encoding and decoding. GIF's
+variation on the concept is just an extension from there.
+   
+</p><p>
+  LZW manipulates three objects in both compression and decompression: the
+charstream, the codestream, and the string table. In compression, the
+charstream is the input and the codestream is the output. In decompression,
+the codestream is the input and the charstream is the output. The string table
+is a product of both compression and decompression, but is never passed from
+one to the other.
+
+</p><h2>Compression</h2>
+
+<p>
+     The first thing we do in LZW compression is initialize our string table.
+To do this, we need to choose a code size (how many bits) and know how many
+values our characters can possibly take. Let's say our code size is 12 bits,
+meaning we can store 0-&gt;FFF, or 4096 entries in our string table. Lets also
+say that we have 32 possible different characters. (This corresponds to, say,
+a picture in which there are 32 different colors possible for each pixel.) To
+initialize the table, we set code#0 to character#0, code #1 to character#1,
+and so on, until code#31 to character#31. Actually, we are specifying that
+each code from 0 to 31 maps to a root. There will be no more entries in the
+table that have this property.
+
+</p><p>
+
+Now we start compressing data. Let's first define something
+called the "current prefix".  It's just a prefix that we'll store
+things in and compare things to now and then.  I will refer to it as
+"[.c.]". Initially, the current prefix has nothing in it.  Let's also
+define a "current string", which will be the current prefix plus the
+next character in the charstream.  I will refer to the current string
+as "[.c.]K", where K is some character.  OK, look at the first
+character in the charstream.  Call it P.  Make [.c.]P the current
+string.  (At this point, of course, it's just the root P.)  Now search
+through the string table to see if [.c.]P appears in it.  Of course, it
+does now, because our string table is initialized to have all roots.
+So we don't do anything.  Now make [.c.]P the current prefix.  Look at
+the next character in the charstream. Call it Q.  Add it to the
+current prefix to form [.c.]Q, the current string.  Now search through
+the string table to see if [.c.]Q appears in it. In this case, of
+course, it doesn't.  Aha! Now we get to do something.  Add [.c.]Q
+(which is PQ in this case) to the string table for code#32, and output
+the code for [.c.] to the codestream.  Now start over again with the
+current prefix being just the root Q.  Keep adding characters to [.c.]
+to form [.c.]K, until you can't find [.c.]K in the string table.  Then
+output the code for [.c.] and add [.c.]K to the string table.  In
+pseudo-code, the algorithm goes something like this:
+
+</p><pre>     [1] Initialize string table;
+     [2] [.c.] &lt;- empty;
+     [3] K &lt;- next character in charstream;
+     [4] Is [.c.]K in string table?
+         (yes: [.c.] &lt;- [.c.]K;
+               go to [3];
+         )
+         (no: add [.c.]K to the string table;
+              output the code for [.c.] to the codestream;
+              [.c.] &lt;- K;
+              go to [3];
+         )
+</pre>
+
+<p>
+       It's as simple as that! Of course, when you get to step [3] and there
+aren't any more characters left, you just output the code for [.c.] and throw
+the table away. You're done.
+
+</p><p>
+      Wanna do an example? Let's pretend we have a four-character alphabet:
+A,B,C,D. The charstream looks like ABACABA. Let's compress it. First, we
+initialize our string table to: #0=A, #1=B, #2=C, #3=D. The first character is
+A, which is in the string table, so [.c.] becomes A. Next we get AB, which is
+not in the table, so we output code #0 (for [.c.]),
+     and add AB to the string table as code #4. [.c.] becomes B. Next we get
+[.c.]A = BA, which is not in the string table, so output code #1, and add BA
+to the string table as code #5. [.c.] becomes A. Next we get AC, which is not
+in the string table. Output code #0, and add AC to the string table as code
+#6. Now [.c.] becomes C. Next we get [.c.]A = CA, which is not in the table.
+Output #2 for C, and add CA to table as code#7. Now [.c.] becomes A. Next we
+get AB, which IS in the string table, so [.c.] gets AB, and we look at ABA,
+which is not in the string table, so output the code for AB, which is #4, and
+add ABA to the string table as code #8. [.c.] becomes A. We can't get any more
+characters, so we just output #0 for the code for A, and we're done. So, the
+codestream is #0#1#0#2#4#0.
+
+</p><p>
+      A few words (four) should be said here about efficiency: use a hashing
+strategy. The search through the string table can be computationally
+intensive, and some hashing is well worth the effort. Also, note that
+"straight LZW" compression runs the risk of overflowing the string table -
+getting to a code which can't be represented in the number of bits you've set
+aside for codes. There are several ways of dealing with this problem, and GIF
+implements a very clever one, but we'll get to that.
+
+</p><p>
+      An important thing to notice is that, at any point during the
+compression, if [...]K is in the string table, [...] is there also. This fact
+suggests an efficient method for storing strings in the table. Rather than
+store the entire string of K's in the table, realize that any string can be
+expressed as a prefix plus a character: [...]K. If we're about to store [...]K
+in the table, we know that [...] is already there, so we can just store the
+code for [...] plus the final character K.
+
+
+</p><h2>Decompression</h2>
+
+Decompression is perhaps more
+difficult conceptually, but it is really easier to program.
+We again have to start with an initialized string
+table. This table comes from what knowledge we have about the charstream that
+we will eventually get, like what possible values the characters can take. In
+GIF files, this information is in the header as the number of possible pixel
+values. The beauty of LZW, though, is that this is all we need to know. We
+will build the rest of the string table as we decompress the codestream. The
+compression is done in such a way that we will never encounter a code in the
+codestream that we can't translate into a string.
+
+<p>
+We need to define something called a "current code", which I
+will refer to as "&lt;code&gt;", and an "old-code", which I will refer
+to as "&lt;old&gt;".  To start things off, look at the first code.  This
+is now &lt;code&gt;.  This code will be in the intialized string table as
+the code for a root.  Output the root to the charstream. Make this code
+the old-code &lt;old&gt;.  *Now look at the next code, and make it
+&lt;code&gt;.  It is possible that this code will not be in the string
+table, but let's assume for now that it is.  Output the string
+corresponding to &lt;code&gt; to the codestream.  Now find the first
+character in the string you just translated.  Call this K.  Add this to
+the prefix [...] generated by &lt;old&gt; to form a new string
+[...]K. Add this string [...]K to the string table, and set the
+old-code &lt;old&gt; to the current code &lt;code&gt;. Repeat from where I
+typed the asterisk, and you're all set. 
+This is the most common case so you should understand this before going
+on.
+
+</p><p> 
+
+Now let's consider the possibility that &lt;code&gt; is not in the
+string table, which as we will see can only occur for strings of the
+form P[...]P (for any character P).  Think back to compression, and
+try to understand what happens when you have a string like
+P[...]P[...]PQ appear in the charstream. Suppose P[...] is already in
+the string table, but P[...]P is not. The compressor will parse out
+P[...], and find that P[...]P is not in the string table. It will
+output the code for P[...], and add P[...]P to the string table. Then
+it will get up to P[...]P for the next string, and find that P[...]P
+is in the table, as the code just added. So it will output the code
+for P[...]P if it finds that P[...]PQ is not in the table.  The
+decompressor is always "one step behind" the compressor. When the
+decompressor sees the code for P[...]P, it will not have added that
+code to it's string table yet because it needed the beginning
+character of P[...]P to add to the string for the last code, P[...],
+to form the code for P[...]P. However, when a decompressor finds a
+code that it doesn't know yet, it will always be the very next one to
+be added to the string table.  So it can guess at what the string for
+the code should be, and, in fact, it will always be correct. If I am a
+decompressor, and I see code#124, and yet my string table has entries
+only up to code#123, I can figure out what code#124 must be, add it to
+my string table, and output the string. If code#123 generated the
+string [...], which I will refer to here as a prefix, then code#124,
+in this special case, will be [...] plus the first character of [...].
+So just add the first character of [...] to the end of itself.  Not
+too bad.
+
+
+</p><p>
+
+As an example (and a very common one) of this special case, let's
+assume we have a raster image in which the first three pixels have the
+same color value.  That is, my charstream looks like: QQQ....  For the
+sake of argument, let's say we have 32 colors, and Q is the
+color#12. The compressor will generate the code sequence
+12,32,.... (if you don't know why, take a minute to understand it.)
+Remember that #32 is not in the initial table, which goes from #0 to
+#31. The decompressor will see #12 and translate it just fine as color
+Q. Then it will see #32 and not yet know what that means. But if it
+thinks about it long enough, it can figure out that QQ should be
+entry#32 in the table and QQ should be the next string output.  So the
+decompression pseudo-code goes something like:
+
+</p><pre>     [1] Initialize string table;
+     [2] get first code: &lt;code&gt;
+     [3] output the string for &lt;code&gt; to the charstream;
+     [4] &lt;old&gt; = &lt;code&gt;
+     [5] &lt;code&gt; &lt;- next code in codestream;
+     [6] does &lt;code&gt; exist in the string table?
+         (yes: output the string for &lt;code&gt; to the charstream;
+            [...] &lt;- translation for &lt;old&gt;
+            K &lt;- first character of translation for &lt;code&gt;
+            add [...]K to the string table;        
+            &lt;old&gt; &lt;- &lt;code&gt;
+         )
+         (no: [...] &lt;- translation for &lt;old&gt;
+            K &lt;- first character of [...];
+            output [...]K to charstream and add it to string table;
+            &lt;old&gt; &lt;- &lt;code&gt;
+         )
+     [7] go to [5];
+</pre>
+
+<p>
+      Again, when you get to step [5] and there are no more codes, you're
+finished.  Outputting of strings, and finding of initial characters in strings
+are efficiency problems all to themselves, but I'm not going to suggest ways
+to do them here. Half the fun of programming is figuring these things out!
+
+</p><h2>GIF variation</h2>
+
+<p>
+
+Now for the GIF variations on the theme. In part of the header of a
+GIF file, there is a field, in the Raster Data stream, called "code
+size". This is a very misleading name for the field, but we have to
+live with it. What it is really is the "root size". The actual size,
+in bits, of the compression codes actually changes during
+compression/decompression, and I will refer to that size here as the
+"compression size".  The initial table is just the codes for all the
+roots, as usual, but two special codes are added on top of those.  The
+"code size" N is set to max(2,bits-per-pixel).  In the table the roots
+take up slots #0 through #(2**N-1), and the special codes are (2**N)
+and (2**N + 1).  The initial compression size will be N+1 bits per
+code. If you're encoding, you output the codes (N+1) bits at a time to
+start with, and if you're decoding, you grab (N+1) bits from the
+codestream at a time.  As for the special codes: &lt;CC&gt; or the clear
+code, is (2**N), and &lt;EOI&gt;, or end-of-information, is (2**N +
+1). &lt;CC&gt; tells the compressor to re- initialize the string table,
+and to reset the compression size to (N+1). &lt;EOI&gt; means there's no
+more in the codestream.
+
+</p><p>
+
+If you're encoding or decoding, you should
+start adding things to the string table at &lt;CC&gt; + 2. If you're
+encoding, you should output &lt;CC&gt; as the very first code, and then
+whenever after that you reach code #4095 (hex FFF), because GIF does
+not allow compression sizes to be greater than 12 bits. If you're
+decoding, you should reinitialize your string table when you observe
+&lt;CC&gt;.  The variable compression sizes are really no big deal. If
+you're encoding, you start with a compression size of (N+1) bits, and,
+whenever you output the code (2**(compression size)-1), you bump the
+compression size up one bit. So the next code you output will be one
+bit longer. Remember that the largest compression size is 12 bits,
+corresponding to a code of 4095. If you get that far, you must output
+&lt;CC&gt; as the next code, and start over.  If you're decoding, you
+must increase your compression size AS SOON AS YOU write entry
+#(2**(compression size) - 1) to the string table. The next code you
+READ will be one bit longer. Don't make the mistake of waiting until
+you need to add the code (2**compression size) to the table. You'll
+have already missed a bit from the last code.  The packaging of codes
+into a bitsream for the raster data is also a potential stumbling
+block for the novice encoder or decoder. The lowest order bit in the
+code should coincide with the lowest available bit in the first
+available byte in the codestream. For example, if you're starting with
+5-bit compression codes, and your first three codes are, say,
+&lt;abcde&gt;, &lt;fghij&gt;, &lt;klmno&gt;, where e, j, and o are bit#0,
+then your codestream will start off like:
+
+</p><pre>       byte#0: hijabcde
+       byte#1: .klmnofg
+</pre>
+
+<p>
+
+      So the differences between straight LZW and GIF LZW are: two additional
+special codes and variable compression sizes. If you understand LZW, and you
+understand those variations, you understand it all!
+
+</p><p>
+      Just as sort of a P.S., you may have noticed that a compressor has a
+little bit of flexibility at compression time. I specified a "greedy" approach
+to the compression, grabbing as many characters as possible before outputting
+codes. This is, in fact, the standard LZW way of doing things, and it will
+yield the best compression ratio. But there's no rule saying you can't stop
+anywhere along the line and just output the code for the current prefix,
+whether it's already in the table or not, and add that string plus the next
+character to the string table. There are various reasons for wanting to do
+this, especially if the strings get extremely long and make hashing difficult.
+If you need to, do it.
+
+</p><p>
+      Hope this helps out.----steve blackstock
+
+</p><h3>Further information</h3>
+
+The original paper that describes the LZW algorithm is:
+
+<blockquote>
+Terry A. Welch.
+A Technique for High Performance Data Compression.
+IEEE Computer, Vol. 17, No. 6, 1984, pp. 8-19. 
+</blockquote>
+
+The GIF format is described in more detail in the 
+<a href="gif87.txt">GIF87(5) - GIF 87</a> and
+<a href="gif89.txt">GIF89a(5) - GIF 89a</a> standards.
+</body>
+</html>
diff --git a/doc/gifstandard/gif-1over100.png b/doc/gifstandard/gif-1over100.png
new file mode 100644
index 0000000..5007a5b
Binary files /dev/null and b/doc/gifstandard/gif-1over100.png differ
diff --git a/doc/gifstandard/gif-1over64.png b/doc/gifstandard/gif-1over64.png
new file mode 100644
index 0000000..81ea1b0
Binary files /dev/null and b/doc/gifstandard/gif-1over64.png differ
diff --git a/doc/gifstandard/gif-aspectratio.png b/doc/gifstandard/gif-aspectratio.png
new file mode 100644
index 0000000..8ffdc5b
Binary files /dev/null and b/doc/gifstandard/gif-aspectratio.png differ
diff --git a/doc/gifstandard/gif87.txt b/doc/gifstandard/gif87.txt
new file mode 100644
index 0000000..0660834
--- /dev/null
+++ b/doc/gifstandard/gif87.txt
@@ -0,0 +1,680 @@
+
+
+
+
+                                 G I F (tm)
+
+                     Graphics Interchange Format (tm)
+
+                      A standard defining a mechanism
+                     for the storage and transmission
+                   of raster-based graphics information
+
+                               June 15, 1987
+
+                     (c) CompuServe Incorporated, 1987
+                            All rights reserved
+
+            While this document is copyrighted, the information
+          contained within is made available for use in computer
+          software without royalties, or licensing restrictions.
+          GIF and 'Graphics Interchange Format' are trademarks of
+
+                         CompuServe, Incorporated.
+                           an H&R Block Company
+                        5000 Arlington Centre Blvd.
+                           Columbus, Ohio 43220
+                              (614) 457-8600
+
+                                                                     Page 2
+
+
+
+              Graphics Interchange Format (GIF) Specification
+                             Table of Contents
+        INTRODUCTION . . . . . . . . . . . . . . . . . page 3
+        GENERAL FILE FORMAT  . . . . . . . . . . . . . page 3
+        GIF SIGNATURE  . . . . . . . . . . . . . . . . page 4
+        SCREEN DESCRIPTOR  . . . . . . . . . . . . . . page 4
+        GLOBAL COLOR MAP . . . . . . . . . . . . . . . page 5
+        IMAGE DESCRIPTOR . . . . . . . . . . . . . . . page 6
+        LOCAL COLOR MAP  . . . . . . . . . . . . . . . page 7
+        RASTER DATA  . . . . . . . . . . . . . . . . . page 7
+        GIF TERMINATOR . . . . . . . . . . . . . . . . page 8
+        GIF EXTENSION BLOCKS . . . . . . . . . . . . . page 8
+        APPENDIX A - GLOSSARY  . . . . . . . . . . . . page 9
+        APPENDIX B - INTERACTIVE SEQUENCES . . . . . . page 10
+        APPENDIX C - IMAGE PACKAGING & COMPRESSION . . page 12
+        APPENDIX D - MULTIPLE IMAGE PROCESSING . . . . page 15
+
+Graphics Interchange Format (GIF)                                    Page 3
+
+
+
+Specification
+
+INTRODUCTION
+
+        'GIF' (tm) is CompuServe's standard for defining generalized  color
+   raster   images.    This   'Graphics  Interchange  Format'  (tm)  allows
+   high-quality, high-resolution graphics to be displayed on a  variety  of
+   graphics  hardware  and is intended as an exchange and display mechanism
+   for graphics images.  The image format described  in  this  document  is
+   designed  to  support  current  and  future image technology and will in
+   addition serve as a basis for future CompuServe graphics products.
+
+        The main focus  of  this  document  is  to  provide  the  technical
+   information  necessary  for  a  programmer to implement GIF encoders and
+   decoders.  As such, some assumptions are made as to terminology relavent
+   to graphics and programming in general.
+
+        The first section of this document describes the  GIF  data  format
+   and its components and applies to all GIF decoders, either as standalone
+   programs or as part of  a  communications  package.   Appendix  B  is  a
+   section  relavent to decoders that are part of a communications software
+   package and describes the protocol requirements for entering and exiting
+   GIF mode, and responding to host interrogations.  A glossary in Appendix
+   A defines some of the terminology used in  this  document.   Appendix  C
+   gives  a  detailed  explanation  of  how  the  graphics  image itself is
+   packaged as a series of data bytes.
+
+
+                Graphics Interchange Format Data Definition
+
+ GENERAL FILE FORMAT
+
+        +-----------------------+
+        | +-------------------+ |
+        | |   GIF Signature   | |
+        | +-------------------+ |
+        | +-------------------+ |
+        | | Screen Descriptor | |
+        | +-------------------+ |
+        | +-------------------+ |
+        | | Global Color Map  | |
+        | +-------------------+ |
+        . . .               . . .
+        | +-------------------+ |    ---+    
+        | |  Image Descriptor | |       |    
+        | +-------------------+ |       |    
+        | +-------------------+ |       |   
+        | |  Local Color Map  | |       |-   Repeated 1 to n times
+        | +-------------------+ |       |    
+        | +-------------------+ |       |    
+        | |    Raster Data    | |       |    
+        | +-------------------+ |    ---+    
+        . . .               . . .    
+        |-    GIF Terminator   -|    
+        +-----------------------+
+
+Graphics Interchange Format (GIF)                                    Page 4
+
+
+
+Specification
+
+ GIF SIGNATURE
+
+        The following GIF Signature identifies  the  data  following  as  a
+   valid GIF image stream.  It consists of the following six characters:
+
+             G I F 8 7 a
+
+        The last three characters '87a' may be viewed as a  version  number
+   for  this  particular  GIF  definition  and will be used in general as a
+   reference  in  documents  regarding  GIF  that   address   any   version
+   dependencies.
+
+ SCREEN DESCRIPTOR
+
+        The Screen Descriptor describes the overall parameters for all  GIF
+   images  following.  It defines the overall dimensions of the image space
+   or logical screen required, the existance of color mapping  information,
+   background  screen color, and color depth information.  This information
+   is stored in a series of 8-bit bytes as described below.
+
+              bits
+         7 6 5 4 3 2 1 0  Byte #
+        +---------------+
+        |               |  1
+        +-Screen Width -+      Raster width in pixels (LSB first)
+        |               |  2
+        +---------------+
+        |               |  3
+        +-Screen Height-+      Raster height in pixels (LSB first)
+        |               |  4
+        +-+-----+-+-----+      M = 1, Global color map follows Descriptor
+        |M|  cr |0|pixel|  5   cr+1 = # bits of color resolution
+        +-+-----+-+-----+      pixel+1 = # bits/pixel in image
+        |   background  |  6   background=Color index of screen background
+        +---------------+          (color is defined from the Global color
+        |0 0 0 0 0 0 0 0|  7        map or default map if none specified)
+        +---------------+
+
+        The logical screen width and height can both  be  larger  than  the
+   physical  display.   How  images  larger  than  the physical display are
+   handled is implementation dependent and can take advantage  of  hardware
+   characteristics  (e.g.   Macintosh scrolling windows).  Otherwise images
+   can be clipped to the edges of the display.
+
+        The value of 'pixel' also defines  the  maximum  number  of  colors
+   within  an  image.   The  range  of  values  for 'pixel' is 0 to 7 which
+   represents 1 to 8 bits.  This translates to a range of 2 (B & W) to  256
+   colors.   Bit  3 of word 5 is reserved for future definition and must be
+   zero.
+
+Graphics Interchange Format (GIF)                                    Page 5
+
+
+
+Specification
+
+ GLOBAL COLOR MAP
+
+        The Global Color Map is optional but recommended for  images  where
+   accurate color rendition is desired.  The existence of this color map is
+   indicated in the 'M' field of byte 5 of the Screen Descriptor.  A  color
+   map  can  also  be associated with each image in a GIF file as described
+   later.  However this  global  map  will  normally  be  used  because  of
+   hardware  restrictions  in equipment available today.  In the individual
+   Image Descriptors the 'M' flag will normally be  zero.   If  the  Global
+   Color  Map  is  present,  it's definition immediately follows the Screen
+   Descriptor.   The  number  of  color  map  entries  following  a  Screen
+   Descriptor  is equal to 2**(# bits per pixel), where each entry consists
+   of three byte values representing the relative intensities of red, green
+   and blue respectively.  The structure of the Color Map block is:
+
+              bits
+         7 6 5 4 3 2 1 0  Byte #
+        +---------------+
+        | red intensity |  1    Red value for color index 0
+        +---------------+
+        |green intensity|  2    Green value for color index 0
+        +---------------+
+        | blue intensity|  3    Blue value for color index 0
+        +---------------+
+        | red intensity |  4    Red value for color index 1
+        +---------------+
+        |green intensity|  5    Green value for color index 1
+        +---------------+
+        | blue intensity|  6    Blue value for color index 1
+        +---------------+
+        :               :       (Continues for remaining colors)
+
+        Each image pixel value received will be displayed according to  its
+   closest match with an available color of the display based on this color
+   map.  The color components represent a fractional intensity  value  from
+   none  (0)  to  full (255).  White would be represented as (255,255,255),
+   black as (0,0,0) and medium yellow as (180,180,0).  For display, if  the
+   device  supports fewer than 8 bits per color component, the higher order
+   bits of each component are used.  In the creation of  a  GIF  color  map
+   entry  with  hardware  supporting  fewer  than 8 bits per component, the
+   component values for the hardware  should  be  converted  to  the  8-bit
+   format with the following calculation:
+
+        <map_value> = <component_value>*255/(2**<nbits> -1)
+
+        This assures accurate translation of colors for all  displays.   In
+   the  cases  of  creating  GIF images from hardware without color palette
+   capability, a fixed palette should be created  based  on  the  available
+   display  colors for that hardware.  If no Global Color Map is indicated,
+   a default color map is generated internally  which  maps  each  possible
+   incoming  color  index to the same hardware color index modulo <n> where
+   <n> is the number of available hardware colors.
+
+Graphics Interchange Format (GIF)                                    Page 6
+
+
+
+Specification
+
+ IMAGE DESCRIPTOR
+
+        The Image Descriptor defines the actual placement  and  extents  of
+   the  following  image within the space defined in the Screen Descriptor.
+   Also defined are flags to indicate the presence of a local color  lookup
+   map, and to define the pixel display sequence.  Each Image Descriptor is
+   introduced by an image separator  character.   The  role  of  the  Image
+   Separator  is simply to provide a synchronization character to introduce
+   an Image Descriptor.  This is desirable if a GIF file happens to contain
+   more  than  one  image.   This  character  is defined as 0x2C hex or ','
+   (comma).  When this character is encountered between images,  the  Image
+   Descriptor will follow immediately.
+
+        Any characters encountered between the end of a previous image  and
+   the image separator character are to be ignored.  This allows future GIF
+   enhancements to be present in newer image formats and yet ignored safely
+   by older software decoders.
+
+              bits
+         7 6 5 4 3 2 1 0  Byte #
+        +---------------+
+        |0 0 1 0 1 1 0 0|  1    ',' - Image separator character
+        +---------------+
+        |               |  2    Start of image in pixels from the
+        +-  Image Left -+       left side of the screen (LSB first)
+        |               |  3
+        +---------------+
+        |               |  4
+        +-  Image Top  -+       Start of image in pixels from the
+        |               |  5    top of the screen (LSB first)
+        +---------------+
+        |               |  6
+        +- Image Width -+       Width of the image in pixels (LSB first)
+        |               |  7
+        +---------------+
+        |               |  8
+        +- Image Height-+       Height of the image in pixels (LSB first)
+        |               |  9
+        +-+-+-+-+-+-----+       M=0 - Use global color map, ignore 'pixel'
+        |M|I|0|0|0|pixel| 10    M=1 - Local color map follows, use 'pixel'
+        +-+-+-+-+-+-----+       I=0 - Image formatted in Sequential order
+                                I=1 - Image formatted in Interlaced order
+                                pixel+1 - # bits per pixel for this image
+
+        The specifications for the image position and size must be confined
+   to  the  dimensions defined by the Screen Descriptor.  On the other hand
+   it is not necessary that the image fill the entire screen defined.
+
+Graphics Interchange Format (GIF)                                    Page 7
+
+
+Specification
+
+ LOCAL COLOR MAP
+
+        A Local Color Map is optional and defined here for future use.   If
+   the  'M' bit of byte 10 of the Image Descriptor is set, then a color map
+   follows the Image Descriptor that applies only to the  following  image.
+   At the end of the image, the color map will revert to that defined after
+   the Screen Descriptor.  Note that the 'pixel' field of byte  10  of  the
+   Image  Descriptor  is used only if a Local Color Map is indicated.  This
+   defines the parameters not only for the image pixel size, but determines
+   the  number  of color map entries that follow.  The bits per pixel value
+   will also revert to the value specified in the  Screen  Descriptor  when
+   processing of the image is complete.
+
+ RASTER DATA
+
+        The format of the actual image is defined as the  series  of  pixel
+   color  index  values that make up the image.  The pixels are stored left
+   to right sequentially for an image row.  By default each  image  row  is
+   written  sequentially, top to bottom.  In the case that the Interlace or
+   'I' bit is set in byte 10 of the Image Descriptor then the row order  of
+   the  image  display  follows  a  four-pass process in which the image is
+   filled in by widely spaced rows.  The first pass writes every  8th  row,
+   starting  with  the top row of the image window.  The second pass writes
+   every 8th row starting at the fifth row from the top.   The  third  pass
+   writes every 4th row starting at the third row from the top.  The fourth
+   pass completes the image, writing  every  other  row,  starting  at  the
+   second row from the top.  A graphic description of this process follows:
+
+   Image
+
+   Row  Pass 1  Pass 2  Pass 3  Pass 4          Result
+   ---------------------------------------------------
+     0  **1a**                                  **1a**
+     1                          **4a**          **4a**
+     2                  **3a**                  **3a**
+     3                          **4b**          **4b**
+     4          **2a**                          **2a**
+     5                          **4c**          **4c**
+     6                  **3b**                  **3b**
+     7                          **4d**          **4d**
+     8  **1b**                                  **1b**
+     9                          **4e**          **4e**
+    10                  **3c**                  **3c**
+    11                          **4f**          **4f**
+    12          **2b**                          **2b**
+   . . .  
+
+        The image pixel values are processed as a series of  color  indices
+   which  map  into the existing color map.  The resulting color value from
+   the map is what is actually displayed.  This series  of  pixel  indices,
+   the  number  of  which  is equal to image-width*image-height pixels, are
+   passed to the GIF image data stream one value per pixel, compressed  and
+   packaged  according  to  a  version  of the LZW compression algorithm as
+   defined in Appendix C.
+
+Graphics Interchange Format (GIF)                                    Page 8
+
+
+
+Specification
+
+ GIF TERMINATOR
+
+        In order to provide a synchronization for the termination of a  GIF
+   image  file,  a  GIF  decoder  will process the end of GIF mode when the
+   character 0x3B hex or ';' is found after an image  has  been  processed.
+   By  convention  the  decoding software will pause and wait for an action
+   indicating that the user is ready to continue.  This may be  a  carriage
+   return  entered  at  the  keyboard  or  a  mouse click.  For interactive
+   applications this user action must  be  passed  on  to  the  host  as  a
+   carriage  return  character  so  that the host application can continue.
+   The decoding software will then typically leave graphics mode and resume
+   any previous process.
+
+ GIF EXTENSION BLOCKS
+
+        To provide for orderly extension of the GIF definition, a mechanism
+   for  defining  the  packaging  of extensions within a GIF data stream is
+   necessary.  Specific GIF extensions are to be defined and documented  by
+   CompuServe in order to provide a controlled enhancement path.
+
+        GIF Extension Blocks are packaged in a manner similar to that  used
+   by the raster data though not compressed.  The basic structure is:
+
+         7 6 5 4 3 2 1 0  Byte #
+        +---------------+
+        |0 0 1 0 0 0 0 1|  1       '!' - GIF Extension Block Introducer
+        +---------------+
+        | function code |  2       Extension function code (0 to 255)
+        +---------------+    ---+
+        |  byte count   |       |
+        +---------------+       |
+        :               :       +-- Repeated as many times as necessary
+        |func data bytes|       |
+        :               :       |
+        +---------------+    ---+
+        . . .       . . .
+        +---------------+
+        |0 0 0 0 0 0 0 0|       zero byte count (terminates block)
+        +---------------+
+
+        A GIF Extension Block may immediately preceed any Image  Descriptor
+   or occur before the GIF Terminator.
+
+        All GIF decoders must be able to recognize  the  existence  of  GIF
+   Extension  Blocks  and  read past them if unable to process the function
+   code.  This ensures that older decoders will be able to process extended
+   GIF   image   files   in  the  future,  though  without  the  additional
+   functionality.
+
+Graphics Interchange Format (GIF)                                    Page 9
+
+Appendix A - Glossary
+
+                                 GLOSSARY
+
+Pixel - The smallest picture element of a  graphics  image.   This  usually
+   corresponds  to  a single dot on a graphics screen.  Image resolution is
+   typically given in units of  pixels.   For  example  a  fairly  standard
+   graphics  screen  format  is  one 320 pixels across and 200 pixels high.
+   Each pixel can  appear  as  one  of  several  colors  depending  on  the
+   capabilities of the graphics hardware.
+
+Raster - A horizontal row of pixels representing one line of an  image.   A
+   typical method of working with images since most hardware is oriented to
+   work most efficiently in this manner.
+
+LSB - Least Significant Byte.  Refers to a convention for two byte  numeric
+   values in which the less significant byte of the value preceeds the more
+   significant byte.  This convention is typical on many microcomputers.
+
+Color Map - The list of definitions of each color  used  in  a  GIF  image.
+   These  desired  colors are converted to available colors through a table
+   which is derived by assigning an incoming color index (from  the  image)
+   to  an  output  color  index  (of  the  hardware).   While the color map
+   definitons are specified in a GIF image, the output  pixel  colors  will
+   vary  based  on  the  hardware used and its ability to match the defined
+   color.
+
+Interlace - The method of displaying a GIF image in which  multiple  passes
+   are  made,  outputting  raster  lines  spaced  apart to provide a way of
+   visualizing the general content of an entire image  before  all  of  the
+   data has been processed.
+
+B Protocol - A CompuServe-developed error-correcting file transfer protocol
+   available  in  the  public  domain  and implemented in CompuServe VIDTEX
+   products.  This error checking mechanism will be used  in  transfers  of
+   GIF images for interactive applications.
+
+LZW - A sophisticated data compression algorithm  based  on  work  done  by
+   Lempel-Ziv  &  Welch  which  has  the feature of very efficient one-pass
+   encoding and decoding.  This allows the image  to  be  decompressed  and
+   displayed  at  the  same  time.   The  original  article from which this
+   technique was adapted is:
+
+          Terry  A.   Welch,  "A  Technique  for  High   Performance   Data
+          Compression", IEEE Computer, vol 17 no 6 (June 1984)
+
+        This basic algorithm is also used in the  public  domain  ARC  file
+   compression  utilities.   The  CompuServe  adaptation  of LZW for GIF is
+   described in Appendix C.
+
+Graphics Interchange Format (GIF)                                   Page 10
+
+
+
+Appendix B - Interactive Sequences
+
+           GIF Sequence Exchanges for an Interactive Environment
+
+        The following sequences are defined for use  in  mediating  control
+   between a GIF sender and GIF receiver over an interactive communications
+   line.  These  sequences  do  not  apply  to  applications  that  involve
+   downloading  of  static  GIF  files and are not considered part of a GIF
+   file.
+
+ GIF CAPABILITIES ENQUIRY
+
+        The GCE sequence is issued from a host and requests an  interactive
+   GIF  decoder  to  return  a  response  message that defines the graphics
+   parameters for the decoder.  This involves returning  information  about
+   available screen sizes, number of bits/color supported and the amount of
+   color detail supported.  The escape sequence for the GCE is defined as:
+
+        ESC [ > 0 g     (g is lower case, spaces inserted for clarity)
+                         (0x1B 0x5B 0x3E 0x30 0x67)
+
+ GIF CAPABILITIES RESPONSE
+
+        The GIF Capabilities Response message is returned by an interactive
+   GIF  decoder  and  defines  the  decoder's  display capabilities for all
+   graphics modes that are supported by the software.  Note that  this  can
+   also include graphics printers as well as a monitor screen.  The general
+   format of this message is:
+
+     #version;protocol{;dev, width, height, color-bits, color-res}... <CR>
+
+   '#'          - GCR identifier character (Number Sign)
+   version      - GIF format version number;  initially '87a'
+   protocol='0' - No end-to-end protocol supported by decoder
+                  Transfer as direct 8-bit data stream.
+   protocol='1' - Can use an error correction protocol to transfer GIF data
+               interactively from the host directly to the display.
+   dev = '0'    - Screen parameter set follows
+   dev = '1'    - Printer parameter set follows
+   width        - Maximum supported display width in pixels
+   height       - Maximum supported display height in pixels
+   color-bits   - Number of  bits  per  pixel  supported.   The  number  of
+               supported colors is therefore 2**color-bits.
+   color-res    - Number of bits  per  color  component  supported  in  the
+               hardware  color  palette.   If  color-res  is  '0'  then  no
+               hardware palette table is available.
+
+        Note that all values in the  GCR  are  returned  as  ASCII  decimal
+   numbers and the message is terminated by a Carriage Return character.
+
+Graphics Interchange Format (GIF)                                   Page 11
+
+
+
+Appendix B - Interactive Sequences
+
+        The  following   GCR   message   describes   three   standard   EGA
+   configurations  with  no  printer;  the GIF data stream can be processed
+   within an error correcting protocol:
+
+        #87a;1 ;0,320,200,4,0 ;0,640,200,2,2 ;0,640,350,4,2<CR>
+
+ ENTER GIF GRAPHICS MODE
+
+        Two sequences are currently defined to invoke  an  interactive  GIF
+   decoder into action.  The only difference between them is that different
+   output media are selected.  These sequences are:
+
+     ESC [ > 1 g   Display GIF image on screen
+                   (0x1B 0x5B 0x3E 0x31 0x67)
+     ESC [ > 2 g   Display image directly to an attached graphics  printer.
+                   The  image  may optionally be displayed on the screen as
+                   well.
+                   (0x1B 0x5B 0x3E 0x32 0x67)
+
+        Note that the 'g' character terminating each sequence is  in  lower
+   case.
+
+ INTERACTIVE ENVIRONMENT
+
+        The assumed environment for the transmission of GIF image data from
+   an  interactive  application  is  a  full 8-bit data stream from host to
+   micro.  All 256 character codes must be transferrable.  The establishing
+   of  an 8-bit data path for communications will normally be taken care of
+   by the host application programs.  It is however  up  to  the  receiving
+   communications programs supporting GIF to be able to receive and pass on
+   all 256 8-bit codes to the GIF decoder software.
+
+Graphics Interchange Format (GIF)                                   Page 12
+
+
+
+Appendix C - Image Packaging & Compression
+
+        The Raster Data stream that represents the actual output image  can
+   be represented as:
+
+         7 6 5 4 3 2 1 0
+        +---------------+
+        |   code size   |  
+        +---------------+     ---+
+        |blok byte count|        |
+        +---------------+        |
+        :               :        +-- Repeated as many times as necessary
+        |  data bytes   |        |
+        :               :        |
+        +---------------+     ---+
+        . . .       . . .
+        +---------------+
+        |0 0 0 0 0 0 0 0|       zero byte count (terminates data stream)
+        +---------------+
+
+        The conversion of the image from a series  of  pixel  values  to  a
+   transmitted or stored character stream involves several steps.  In brief
+   these steps are:
+
+   1.  Establish the Code Size -  Define  the  number  of  bits  needed  to
+       represent the actual data.
+   2.  Compress the Data - Compress the series of image pixels to a  series
+       of compression codes.
+   3.  Build a Series of Bytes - Take the  set  of  compression  codes  and
+       convert to a string of 8-bit bytes.
+   4.  Package the Bytes - Package sets of bytes into blocks  preceeded  by
+       character counts and output.
+
+ESTABLISH CODE SIZE
+
+        The first byte of the GIF Raster Data stream is a value  indicating
+   the minimum number of bits required to represent the set of actual pixel
+   values.  Normally this will be the same as the  number  of  color  bits.
+   Because  of  some  algorithmic constraints however, black & white images
+   which have one color bit must be indicated as having a code size  of  2.
+   This  code size value also implies that the compression codes must start
+   out one bit longer.
+
+COMPRESSION
+
+        The LZW algorithm converts a series of data values into a series of
+   codes  which may be raw values or a code designating a series of values.
+   Using text characters as an analogy,  the  output  code  consists  of  a
+   character or a code representing a string of characters.
+
+Graphics Interchange Format (GIF)                                   Page 13
+
+Appendix C - Image Packaging & Compression
+
+        The LZW algorithm used in  GIF  matches  algorithmically  with  the
+   standard LZW algorithm with the following differences:
+
+   1.  A   special   Clear   code   is    defined    which    resets    all
+       compression/decompression parameters and tables to a start-up state.
+       The value of this code is 2**<code size>.  For example if  the  code
+       size  indicated  was 4 (image was 4 bits/pixel) the Clear code value
+       would be 16 (10000 binary).  The Clear code can appear at any  point
+       in the image data stream and therefore requires the LZW algorithm to
+       process succeeding codes as if  a  new  data  stream  was  starting.
+       Encoders  should output a Clear code as the first code of each image
+       data stream.
+
+   2.  An End of Information code is defined that explicitly indicates  the
+       end  of  the image data stream.  LZW processing terminates when this
+       code is encountered.  It must be the last code output by the encoder
+       for an image.  The value of this code is <Clear code>+1.
+
+   3.  The first available compression code value is <Clear code>+2.
+
+   4.  The output codes are of variable length, starting  at  <code size>+1
+       bits  per code, up to 12 bits per code.  This defines a maximum code
+       value of 4095 (hex FFF).  Whenever the LZW code value  would  exceed
+       the  current  code length, the code length is increased by one.  The
+       packing/unpacking of these codes must then be altered to reflect the
+       new code length.
+
+BUILD 8-BIT BYTES
+
+        Because the LZW compression  used  for  GIF  creates  a  series  of
+   variable  length  codes, of between 3 and 12 bits each, these codes must
+   be reformed into a series of 8-bit bytes that  will  be  the  characters
+   actually stored or transmitted.  This provides additional compression of
+   the image.  The codes are formed into a stream of bits as if  they  were
+   packed  right to left and then picked off 8 bits at a time to be output.
+   Assuming a character array of 8 bits per character and using 5 bit codes
+   to be packed, an example layout would be similar to:
+
+         byte n       byte 5   byte 4   byte 3   byte 2   byte 1
+        +-.....-----+--------+--------+--------+--------+--------+
+        | and so on |hhhhhggg|ggfffffe|eeeedddd|dcccccbb|bbbaaaaa|
+        +-.....-----+--------+--------+--------+--------+--------+
+
+        Note that the physical  packing  arrangement  will  change  as  the
+   number  of  bits per compression code change but the concept remains the
+   same.
+
+PACKAGE THE BYTES
+
+        Once the bytes have been created, they are grouped into blocks  for
+   output by preceeding each block of 0 to 255 bytes with a character count
+   byte.  A block with a zero byte count terminates the Raster Data  stream
+   for  a  given  image.  These blocks are what are actually output for the
+
+Graphics Interchange Format (GIF)                                   Page 14
+
+
+
+Appendix C - Image Packaging & Compression
+
+   GIF image.  This block format has the side effect of allowing a decoding
+   program  the  ability to read past the actual image data if necessary by
+   reading block counts and then skipping over the data.
+
+Graphics Interchange Format (GIF)                                   Page 15
+
+
+
+
+Appendix D - Multiple Image Processing
+
+        Since a  GIF  data  stream  can  contain  multiple  images,  it  is
+   necessary  to  describe  processing and display of such a file.  Because
+   the image descriptor allows  for  placement  of  the  image  within  the
+   logical  screen,  it is possible to define a sequence of images that may
+   each be a partial screen, but in total  fill  the  entire  screen.   The
+   guidelines for handling the multiple image situation are:
+
+   1.  There is no pause between images.  Each is processed immediately  as
+       seen by the decoder.
+
+   2.  Each image explicitly overwrites any image  already  on  the  screen
+       inside  of  its window.  The only screen clears are at the beginning
+       and end of the  GIF  image  process.   See  discussion  on  the  GIF
+       terminator.
diff --git a/doc/gifstandard/gif89.txt b/doc/gifstandard/gif89.txt
new file mode 100644
index 0000000..9516eec
--- /dev/null
+++ b/doc/gifstandard/gif89.txt
@@ -0,0 +1,2475 @@
+
+
+    Cover Sheet for the GIF89a Specification
+
+
+    DEFERRED CLEAR CODE IN LZW COMPRESSION
+
+    There has been confusion about where clear codes can be found in the
+    data stream.  As the specification says, they may appear at anytime.  There
+    is not a requirement to send a clear code when the string table is full.
+
+    It is the encoder's decision as to when the table should be cleared.  When
+    the table is full, the encoder can chose to use the table as is, making no
+    changes to it until the encoder chooses to clear it.  The encoder during
+    this time sends out codes that are of the maximum Code Size.
+
+    As we can see from the above, when the decoder's table is full, it must
+    not change the table until a clear code is received.  The Code Size is that
+    of the maximum Code Size.  Processing other than this is done normally.
+
+    Because of a large base of decoders that do not handle the decompression in
+    this manner, we ask developers of GIF encoding software to NOT implement
+    this feature until at least January 1991 and later if they see that their
+    particular market is not ready for it.  This will give developers of GIF
+    decoding software time to implement this feature and to get it into the
+    hands of their clients before the decoders start "breaking" on the new
+    GIF's.  It is not required that encoders change their software to take
+    advantage of the deferred clear code, but it is for decoders.
+
+    APPLICATION EXTENSION BLOCK - APPLICATION IDENTIFIER
+
+    There will be a Courtesy Directory file located on CompuServe in the PICS
+    forum.  This directory will contain Application Identifiers for Application
+    Extension Blocks that have been used by developers of GIF applications.
+    This file is intended to help keep developers that wish to create
+    Application Extension Blocks from using the same Application Identifiers.
+    This is not an official directory; it is for voluntary participation only
+    and does not guarantee that someone will not use the same identifier.
+
+    E-Mail can be sent to Larry Wood (forum manager of PICS) indicating the
+    request for inclusion in this file with an identifier.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+                        GRAPHICS INTERCHANGE FORMAT(sm)
+
+                                  Version 89a
+
+                            (c)1987,1988,1989,1990
+
+                                   Copyright
+                            CompuServe Incorporated
+                                Columbus, Ohio
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+CompuServe Incorporated                           Graphics Interchange Format
+Document Date : 31 July 1990                            Programming Reference
+
+
+
+
+
+
+
+
+
+
+                               Table of Contents
+
+Disclaimer.................................................................  1
+
+Foreword...................................................................  1
+
+Licensing..................................................................  1
+
+About the Document.........................................................  2
+
+General Description........................................................  2
+
+Version Numbers............................................................  2
+
+The Encoder................................................................  3
+
+The Decoder................................................................  3
+
+Compliance.................................................................  3
+
+About Recommendations......................................................  4
+
+About Color Tables.........................................................  4
+
+Blocks, Extensions and Scope...............................................  4
+
+Block Sizes................................................................  5
+
+Using GIF as an embedded protocol..........................................  5
+
+Data Sub-blocks............................................................  5
+
+Block Terminator...........................................................  6
+
+Header.....................................................................  7
+
+Logical Screen Descriptor..................................................  8
+
+Global Color Table......................................................... 10
+
+Image Descriptor........................................................... 11
+
+Local Color Table.......................................................... 13
+
+Table Based Image Data..................................................... 14
+
+Graphic Control Extension.................................................. 15
+
+Comment Extension.......................................................... 17
+
+Plain Text Extension....................................................... 18
+
+Application Extension...................................................... 21
+
+Trailer.................................................................... 23
+
+
+
+
+
+
+
+
+
+
+
+Quick Reference Table...................................................... 24
+
+GIF Grammar................................................................ 25
+
+Glossary................................................................... 27
+
+Conventions................................................................ 28
+
+Interlaced Images.......................................................... 29
+
+Variable-Length-Code LZW Compression....................................... 30
+
+On-line Capabilities Dialogue.............................................. 33
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+                                                                         1
+
+
+1. Disclaimer.
+
+The information provided herein is subject to change without notice. In no
+event will CompuServe Incorporated be liable for damages, including any loss of
+revenue, loss of profits or other incidental or consequential damages arising
+out of the use or inability to use the information; CompuServe Incorporated
+makes no claim as to the suitability of the information.
+
+
+2. Foreword.
+
+This document defines the Graphics Interchange Format(sm). The specification
+given here defines version 89a, which is an extension of version 87a.
+
+The Graphics Interchange Format(sm) as specified here should be considered
+complete; any deviation from it should be considered invalid, including but not
+limited to, the use of reserved or undefined fields within control or data
+blocks, the inclusion of extraneous data within or between blocks, the use of
+methods or algorithms not specifically listed as part of the format, etc. In
+general, any and all deviations, extensions or modifications not specified in
+this document should be considered to be in violation of the format and should
+be avoided.
+
+
+3. Licensing.
+
+The Graphics Interchange Format(c) is the copyright property of CompuServe
+Incorporated. Only CompuServe Incorporated is authorized to define, redefine,
+enhance, alter, modify or change in any way the definition of the format.
+
+CompuServe Incorporated hereby grants a limited, non-exclusive, royalty-free
+license for the use of the Graphics Interchange Format(sm) in computer
+software; computer software utilizing GIF(sm) must acknowledge ownership of the
+Graphics Interchange Format and its Service Mark by CompuServe Incorporated, in
+User and Technical Documentation. Computer software utilizing GIF, which is
+distributed or may be distributed without User or Technical Documentation must
+display to the screen or printer a message acknowledging ownership of the
+Graphics Interchange Format and the Service Mark by CompuServe Incorporated; in
+this case, the acknowledgement may be displayed in an opening screen or leading
+banner, or a closing screen or trailing banner. A message such as the following
+may be used:
+
+      "The Graphics Interchange Format(c) is the Copyright property of
+      CompuServe Incorporated. GIF(sm) is a Service Mark property of
+      CompuServe Incorporated."
+
+For further information, please contact :
+
+      CompuServe Incorporated
+      Graphics Technology Department
+      5000 Arlington Center Boulevard
+      Columbus, Ohio  43220
+      U. S. A.
+
+CompuServe Incorporated maintains a mailing list with all those individuals and
+organizations who wish to receive copies of this document when it is corrected
+
+
+
+
+
+
+
+                                                                         2
+
+
+or revised. This service is offered free of charge; please provide us with your
+mailing address.
+
+
+4. About the Document.
+
+This document describes in detail the definition of the Graphics Interchange
+Format.  This document is intended as a programming reference; it is
+recommended that the entire document be read carefully before programming,
+because of the interdependence of the various parts. There is an individual
+section for each of the Format blocks. Within each section, the sub-section
+labeled Required Version refers to the version number that an encoder will have
+to use if the corresponding block is used in the Data Stream. Within each
+section, a diagram describes the individual fields in the block; the diagrams
+are drawn vertically; top bytes in the diagram appear first in the Data Stream.
+Bits within a byte are drawn most significant on the left end.  Multi-byte
+numeric fields are ordered Least Significant Byte first. Numeric constants are
+represented as Hexadecimal numbers, preceded by "0x".  Bit fields within a byte
+are described in order from most significant bits to least significant bits.
+
+
+5. General Description.
+
+The Graphics Interchange Format(sm) defines a protocol intended for the on-line
+transmission and interchange of raster graphic data in a way that is
+independent of the hardware used in their creation or display.
+
+The Graphics Interchange Format is defined in terms of blocks and sub-blocks
+which contain relevant parameters and data used in the reproduction of a
+graphic. A GIF Data Stream is a sequence of protocol blocks and sub-blocks
+representing a collection of graphics. In general, the graphics in a Data
+Stream are assumed to be related to some degree, and to share some control
+information; it is recommended that encoders attempt to group together related
+graphics in order to minimize hardware changes during processing and to
+minimize control information overhead. For the same reason, unrelated graphics
+or graphics which require resetting hardware parameters should be encoded
+separately to the extent possible.
+
+A Data Stream may originate locally, as when read from a file, or it may
+originate remotely, as when transmitted over a data communications line. The
+Format is defined with the assumption that an error-free Transport Level
+Protocol is used for communications; the Format makes no provisions for
+error-detection and error-correction.
+
+The GIF Data Stream must be interpreted in context, that is, the application
+program must rely on information external to the Data Stream to invoke the
+decoder process.
+
+
+6. Version Numbers.
+
+The version number in the Header of a Data Stream is intended to identify the
+minimum set of capabilities required of a decoder in order to fully process the
+Data Stream.  An encoder should use the earliest possible version number that
+includes all the blocks used in the Data Stream. Within each block section in
+this document, there is an entry labeled Required Version which specifies the
+
+
+
+
+
+
+
+                                                                         3
+
+
+earliest version number that includes the corresponding block.  The encoder
+should make every attempt to use the earliest version number covering all the
+blocks in the Data Stream; the unnecessary use of later version numbers will
+hinder processing by some decoders.
+
+
+7. The Encoder.
+
+The Encoder is the program used to create a GIF Data Stream. From raster data
+and other information, the encoder produces the necessary control and data
+blocks needed for reproducing the original graphics.
+
+The encoder has the following primary responsibilities.
+
+            - Include in the Data Stream all the necessary information to
+            reproduce  the graphics.
+
+            - Insure that a Data Stream is labeled with the earliest possible
+            Version Number that will cover the definition of all the blocks in
+            it; this is to ensure that the largest number of decoders can
+            process the Data Stream.
+
+            - Ensure encoding of the graphics in such a way that the decoding
+            process is optimized. Avoid redundant information as much as
+            possible.
+
+            - To the extent possible, avoid grouping graphics which might
+            require resetting hardware parameters during the decoding process.
+
+            - Set to zero (off) each of the bits of each and every field
+            designated as reserved. Note that some fields in the Logical Screen
+            Descriptor and the Image Descriptor were reserved under Version
+            87a, but are used under version 89a.
+
+
+8. The Decoder.
+
+The Decoder is the program used to process a GIF Data Stream. It processes the
+Data Stream sequentially, parsing the various blocks and sub-blocks, using the
+control information to set hardware and process parameters and interpreting the
+data to render the graphics.
+
+The decoder has the following primary responsibilities.
+
+            - Process each graphic in the Data Stream in sequence, without
+            delays other than those specified in the control information.
+
+            - Set its hardware parameters to fit, as closely as possible, the
+            control information contained in the Data Stream.
+
+
+9. Compliance.
+
+An encoder or a decoder is said to comply with a given version of the Graphics
+Interchange Format if and only if it fully conforms with and correctly
+implements the definition of the standard associated with that version.  An
+
+
+
+
+
+
+
+                                                                         4
+
+
+encoder or a decoder may be compliant with a given version number and not
+compliant with some subsequent version.
+
+
+10. About Recommendations.
+
+Each block section in this document contains an entry labeled Recommendation;
+this section lists a set of recommendations intended to guide and organize the
+use of the particular blocks. Such recommendations are geared towards making
+the functions of encoders and decoders more efficient, as well as making
+optimal use of the communications bandwidth.  It is advised that these
+recommendations be followed.
+
+
+11. About Color Tables.
+
+The GIF format utilizes color tables to render raster-based graphics. A color
+table can have one of two different scopes: global or local. A Global Color
+Table is used by all those graphics in the Data Stream which do not have a
+Local Color Table associated with them. The scope of the Global Color Table is
+the entire Data Stream. A Local Color Table is always associated with the
+graphic that immediately follows it; the scope of a Local Color Table is
+limited to that single graphic. A Local Color Table supersedes a Global Color
+Table, that is, if a Data Stream contains a Global Color Table, and an image
+has a Local Color Table associated with it, the decoder must save the Global
+Color Table, use the Local Color Table to render the image, and then restore
+the Global Color Table. Both types of color tables are optional, making it
+possible for a Data Stream to contain numerous graphics without a color table
+at all. For this reason, it is recommended that the decoder save the last
+Global Color Table used until another Global Color Table is encountered. In
+this way, a Data Stream which does not contain either a Global Color Table or
+a Local Color Table may be processed using the last Global Color Table saved.
+If a Global Color Table from a previous Stream is used, that table becomes the
+Global Color Table of the present Stream. This is intended to reduce the
+overhead incurred by color tables. In particular, it is recommended that an
+encoder use only one Global Color Table if all the images in related Data
+Streams can be rendered with the same table.  If no color table is available at
+all, the decoder is free to use a system color table or a table of its own. In
+that case, the decoder may use a color table with as many colors as its
+hardware is able to support; it is recommended that such a table have black and
+white as its first two entries, so that monochrome images can be rendered
+adequately.
+
+The Definition of the GIF Format allows for a Data Stream to contain only the
+Header, the Logical Screen Descriptor, a Global Color Table and the GIF
+Trailer. Such a Data Stream would be used to load a decoder with a Global Color
+Table, in preparation for subsequent Data Streams without a color table at all.
+
+
+12. Blocks, Extensions and Scope.
+
+Blocks can be classified into three groups : Control, Graphic-Rendering and
+Special Purpose.  Control blocks, such as the Header, the Logical Screen
+Descriptor, the Graphic Control Extension and the Trailer, contain information
+used to control the process of the Data Stream or information  used in setting
+hardware parameters.  Graphic-Rendering blocks such as the Image Descriptor and
+
+
+
+
+
+
+
+                                                                         5
+
+
+the Plain Text Extension contain information and data used to render a graphic
+on the display device. Special Purpose blocks such as the Comment Extension and
+the Application Extension are neither used to control the process of the Data
+Stream nor do they contain information or data used to render a graphic on the
+display device. With the exception of the Logical Screen Descriptor and the
+Global Color Table, whose scope is the entire Data Stream, all other Control
+blocks have a limited scope, restricted to the Graphic-Rendering block that
+follows them.  Special Purpose blocks do not delimit the scope of any Control
+blocks; Special Purpose blocks are transparent to the decoding process.
+Graphic-Rendering blocks and extensions are used as scope delimiters for
+Control blocks and extensions. The labels used to identify labeled blocks fall
+into three ranges : 0x00-0x7F (0-127) are the Graphic Rendering blocks,
+excluding the Trailer (0x3B); 0x80-0xF9 (128-249) are the Control blocks;
+0xFA-0xFF (250-255) are the Special Purpose blocks. These ranges are defined so
+that decoders can handle block scope by appropriately identifying block labels,
+even when the block itself cannot be processed.
+
+
+13. Block Sizes.
+
+The Block Size field in a block, counts the number of bytes remaining in the
+block, not counting the Block Size field itself, and not counting the Block
+Terminator, if one is to follow.  Blocks other than Data Blocks are intended to
+be of fixed length; the Block Size field is provided in order to facilitate
+skipping them, not to allow their size to change in the future.  Data blocks
+and sub-blocks are of variable length to accommodate the amount of data.
+
+
+14. Using GIF as an embedded protocol.
+
+As an embedded protocol, GIF may be part of larger application protocols,
+within which GIF is used to render graphics.  In such a case, the application
+protocol could define a block within which the GIF Data Stream would be
+contained. The application program would then invoke a GIF decoder upon
+encountering a block of type GIF.  This approach is recommended in favor of
+using Application Extensions, which become overhead for all other applications
+that do not process them. Because a GIF Data Stream must be processed in
+context, the application must rely on some means of identifying the GIF Data
+Stream outside of the Stream itself.
+
+
+15. Data Sub-blocks.
+
+      a. Description. Data Sub-blocks are units containing data. They do not
+      have a label, these blocks are processed in the context of control
+      blocks, wherever data blocks are specified in the format. The first byte
+      of the Data sub-block indicates the number of data bytes to follow. A
+      data sub-block may contain from 0 to 255 data bytes. The size of the
+      block does not account for the size byte itself, therefore, the empty
+      sub-block is one whose size field contains 0x00.
+
+      b. Required Version.  87a.
+
+
+
+
+
+
+
+
+
+
+
+                                                                         6
+
+
+      c. Syntax.
+
+      7 6 5 4 3 2 1 0        Field Name                    Type
+     +---------------+
+  0  |               |       Block Size                    Byte
+     +---------------+
+  1  |               |
+     +-             -+
+  2  |               |
+     +-             -+
+  3  |               |
+     +-             -+
+     |               |       Data Values                   Byte
+     +-             -+
+ up  |               |
+     +-   . . . .   -+
+ to  |               |
+     +-             -+
+     |               |
+     +-             -+
+255  |               |
+     +---------------+
+
+            i) Block Size - Number of bytes in the Data Sub-block; the size
+            must be within 0 and 255 bytes, inclusive.
+
+            ii) Data Values - Any 8-bit value. There must be exactly as many
+            Data Values as specified by the Block Size field.
+
+      d. Extensions and Scope. This type of block always occurs as part of a
+      larger unit. It does not have a scope of itself.
+
+      e. Recommendation. None.
+
+
+16. Block Terminator.
+
+      a. Description. This zero-length Data Sub-block is used to terminate a
+      sequence of Data Sub-blocks. It contains a single byte in the position of
+      the Block Size field and does not contain data.
+
+      b. Required Version.  87a.
+
+      c. Syntax.
+
+      7 6 5 4 3 2 1 0        Field Name                    Type
+     +---------------+
+  0  |               |       Block Size                    Byte
+     +---------------+
+
+            i) Block Size - Number of bytes in the Data Sub-block; this field
+            contains the fixed value 0x00.
+
+            ii) Data Values - This block does not contain any data.
+
+
+
+
+
+
+
+
+
+                                                                         7
+
+
+      d. Extensions and Scope. This block terminates the immediately preceding
+      sequence of Data Sub-blocks. This block cannot be modified by any
+      extension.
+
+      e. Recommendation. None.
+
+
+17. Header.
+
+      a. Description. The Header identifies the GIF Data Stream in context. The
+      Signature field marks the beginning of the Data Stream, and the Version
+      field identifies the set of capabilities required of a decoder to fully
+      process the Data Stream.  This block is REQUIRED; exactly one Header must
+      be present per Data Stream.
+
+      b. Required Version.  Not applicable. This block is not subject to a
+      version number. This block must appear at the beginning of every Data
+      Stream.
+
+      c. Syntax.
+
+
+      7 6 5 4 3 2 1 0        Field Name                    Type
+     +---------------+
+   0 |               |       Signature                     3 Bytes
+     +-             -+
+   1 |               |
+     +-             -+
+   2 |               |
+     +---------------+
+   3 |               |       Version                       3 Bytes
+     +-             -+
+   4 |               |
+     +-             -+
+   5 |               |
+     +---------------+
+
+            i) Signature - Identifies the GIF Data Stream. This field contains
+            the fixed value 'GIF'.
+
+            ii) Version - Version number used to format the data stream.
+            Identifies the minimum set of capabilities necessary to a decoder
+            to fully process the contents of the Data Stream.
+
+            Version Numbers as of 10 July 1990 :       "87a" - May 1987
+                                                       "89a" - July 1989
+
+            Version numbers are ordered numerically increasing on the first two
+            digits starting with 87 (87,88,...,99,00,...,85,86) and
+            alphabetically increasing on the third character (a,...,z).
+
+            iii) Extensions and Scope. The scope of this block is the entire
+            Data Stream. This block cannot be modified by any extension.
+
+
+
+
+
+
+
+
+
+
+                                                                         8
+
+
+      d. Recommendations.
+
+            i) Signature - This field identifies the beginning of the GIF Data
+            Stream; it is not intended to provide a unique signature for the
+            identification of the data. It is recommended that the GIF Data
+            Stream be identified externally by the application. (Refer to
+            Appendix G for on-line identification of the GIF Data Stream.)
+
+            ii) Version - ENCODER : An encoder should use the earliest possible
+            version number that defines all the blocks used in the Data Stream.
+            When two or more Data Streams are combined, the latest of the
+            individual version numbers should be used for the resulting Data
+            Stream. DECODER : A decoder should attempt to process the data
+            stream to the best of its ability; if it encounters a version
+            number which it is not capable of processing fully, it should
+            nevertheless, attempt to process the data stream to the best of its
+            ability, perhaps after warning the user that the data may be
+            incomplete.
+
+
+18. Logical Screen Descriptor.
+
+      a. Description.  The Logical Screen Descriptor contains the parameters
+      necessary to define the area of the display device within which the
+      images will be rendered.  The coordinates in this block are given with
+      respect to the top-left corner of the virtual screen; they do not
+      necessarily refer to absolute coordinates on the display device.  This
+      implies that they could refer to window coordinates in a window-based
+      environment or printer coordinates when a printer is used.
+
+      This block is REQUIRED; exactly one Logical Screen Descriptor must be
+      present per Data Stream.
+
+      b. Required Version.  Not applicable. This block is not subject to a
+      version number. This block must appear immediately after the Header.
+
+      c. Syntax.
+
+      7 6 5 4 3 2 1 0        Field Name                    Type
+     +---------------+
+  0  |               |       Logical Screen Width          Unsigned
+     +-             -+
+  1  |               |
+     +---------------+
+  2  |               |       Logical Screen Height         Unsigned
+     +-             -+
+  3  |               |
+     +---------------+
+  4  | |     | |     |       <Packed Fields>               See below
+     +---------------+
+  5  |               |       Background Color Index        Byte
+     +---------------+
+  6  |               |       Pixel Aspect Ratio            Byte
+     +---------------+
+
+
+
+
+
+
+
+
+
+                                                                         9
+
+
+     <Packed Fields>  =      Global Color Table Flag       1 Bit
+                             Color Resolution              3 Bits
+                             Sort Flag                     1 Bit
+                             Size of Global Color Table    3 Bits
+
+            i) Logical Screen Width - Width, in pixels, of the Logical Screen
+            where the images will be rendered in the displaying device.
+
+            ii) Logical Screen Height - Height, in pixels, of the Logical
+            Screen where the images will be rendered in the displaying device.
+
+            iii) Global Color Table Flag - Flag indicating the presence of a
+            Global Color Table; if the flag is set, the Global Color Table will
+            immediately follow the Logical Screen Descriptor. This flag also
+            selects the interpretation of the Background Color Index; if the
+            flag is set, the value of the Background Color Index field should
+            be used as the table index of the background color. (This field is
+            the most significant bit of the byte.)
+
+            Values :    0 -   No Global Color Table follows, the Background
+                              Color Index field is meaningless.
+                        1 -   A Global Color Table will immediately follow, the
+                              Background Color Index field is meaningful.
+
+            iv) Color Resolution - Number of bits per primary color available
+            to the original image, minus 1. This value represents the size of
+            the entire palette from which the colors in the graphic were
+            selected, not the number of colors actually used in the graphic.
+            For example, if the value in this field is 3, then the palette of
+            the original image had 4 bits per primary color available to create
+            the image.  This value should be set to indicate the richness of
+            the original palette, even if not every color from the whole
+            palette is available on the source machine.
+
+            v) Sort Flag - Indicates whether the Global Color Table is sorted.
+            If the flag is set, the Global Color Table is sorted, in order of
+            decreasing importance. Typically, the order would be decreasing
+            frequency, with most frequent color first. This assists a decoder,
+            with fewer available colors, in choosing the best subset of colors;
+            the decoder may use an initial segment of the table to render the
+            graphic.
+
+            Values :    0 -   Not ordered.
+                        1 -   Ordered by decreasing importance, most
+                              important color first.
+
+            vi) Size of Global Color Table - If the Global Color Table Flag is
+            set to 1, the value in this field is used to calculate the number
+            of bytes contained in the Global Color Table. To determine that
+            actual size of the color table, raise 2 to [the value of the field
+            + 1].  Even if there is no Global Color Table specified, set this
+            field according to the above formula so that decoders can choose
+            the best graphics mode to display the stream in.  (This field is
+            made up of the 3 least significant bits of the byte.)
+
+            vii) Background Color Index - Index into the Global Color Table for
+
+
+
+
+
+
+
+                                                                        10
+
+
+            the Background Color. The Background Color is the color used for
+            those pixels on the screen that are not covered by an image. If the
+            Global Color Table Flag is set to (zero), this field should be zero
+            and should be ignored.
+
+            viii) Pixel Aspect Ratio - Factor used to compute an approximation
+            of the aspect ratio of the pixel in the original image.  If the
+            value of the field is not 0, this approximation of the aspect ratio
+            is computed based on the formula:
+
+            Aspect Ratio = (Pixel Aspect Ratio + 15) / 64
+
+            The Pixel Aspect Ratio is defined to be the quotient of the pixel's
+            width over its height.  The value range in this field allows
+            specification of the widest pixel of 4:1 to the tallest pixel of
+            1:4 in increments of 1/64th.
+
+            Values :        0 -   No aspect ratio information is given.
+                       1..255 -   Value used in the computation.
+
+      d. Extensions and Scope. The scope of this block is the entire Data
+      Stream. This block cannot be modified by any extension.
+
+      e. Recommendations. None.
+
+
+19. Global Color Table.
+
+      a. Description. This block contains a color table, which is a sequence of
+      bytes representing red-green-blue color triplets. The Global Color Table
+      is used by images without a Local Color Table and by Plain Text
+      Extensions. Its presence is marked by the Global Color Table Flag being
+      set to 1 in the Logical Screen Descriptor; if present, it immediately
+      follows the Logical Screen Descriptor and contains a number of bytes
+      equal to
+                    3 x 2^(Size of Global Color Table+1).
+
+      This block is OPTIONAL; at most one Global Color Table may be present
+      per Data Stream.
+
+      b. Required Version.  87a
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+                                                                        11
+
+
+      c. Syntax.
+
+      7 6 5 4 3 2 1 0        Field Name                    Type
+     +===============+
+  0  |               |       Red 0                         Byte
+     +-             -+
+  1  |               |       Green 0                       Byte
+     +-             -+
+  2  |               |       Blue 0                        Byte
+     +-             -+
+  3  |               |       Red 1                         Byte
+     +-             -+
+     |               |       Green 1                       Byte
+     +-             -+
+ up  |               |
+     +-   . . . .   -+       ...
+ to  |               |
+     +-             -+
+     |               |       Green 255                     Byte
+     +-             -+
+767  |               |       Blue 255                      Byte
+     +===============+
+
+
+      d. Extensions and Scope. The scope of this block is the entire Data
+      Stream. This block cannot be modified by any extension.
+
+      e. Recommendation. None.
+
+
+20. Image Descriptor.
+
+      a. Description. Each image in the Data Stream is composed of an Image
+      Descriptor, an optional Local Color Table, and the image data.  Each
+      image must fit within the boundaries of the Logical Screen, as defined
+      in the Logical Screen Descriptor.
+
+      The Image Descriptor contains the parameters necessary to process a table
+      based image. The coordinates given in this block refer to coordinates
+      within the Logical Screen, and are given in pixels. This block is a
+      Graphic-Rendering Block, optionally preceded by one or more Control
+      blocks such as the Graphic Control Extension, and may be optionally
+      followed by a Local Color Table; the Image Descriptor is always followed
+      by the image data.
+
+      This block is REQUIRED for an image.  Exactly one Image Descriptor must
+      be present per image in the Data Stream.  An unlimited number of images
+      may be present per Data Stream.
+
+      b. Required Version.  87a.
+
+
+
+
+
+
+
+
+
+
+
+
+
+                                                                        12
+
+
+      c. Syntax.
+
+      7 6 5 4 3 2 1 0        Field Name                    Type
+     +---------------+
+  0  |               |       Image Separator               Byte
+     +---------------+
+  1  |               |       Image Left Position           Unsigned
+     +-             -+
+  2  |               |
+     +---------------+
+  3  |               |       Image Top Position            Unsigned
+     +-             -+
+  4  |               |
+     +---------------+
+  5  |               |       Image Width                   Unsigned
+     +-             -+
+  6  |               |
+     +---------------+
+  7  |               |       Image Height                  Unsigned
+     +-             -+
+  8  |               |
+     +---------------+
+  9  | | | |   |     |       <Packed Fields>               See below
+     +---------------+
+
+     <Packed Fields>  =      Local Color Table Flag        1 Bit
+                             Interlace Flag                1 Bit
+                             Sort Flag                     1 Bit
+                             Reserved                      2 Bits
+                             Size of Local Color Table     3 Bits
+
+           i) Image Separator - Identifies the beginning of an Image
+           Descriptor. This field contains the fixed value 0x2C.
+
+           ii) Image Left Position - Column number, in pixels, of the left edge
+           of the image, with respect to the left edge of the Logical Screen.
+           Leftmost column of the Logical Screen is 0.
+
+           iii) Image Top Position - Row number, in pixels, of the top edge of
+           the image with respect to the top edge of the Logical Screen. Top
+           row of the Logical Screen is 0.
+
+           iv) Image Width - Width of the image in pixels.
+
+           v) Image Height - Height of the image in pixels.
+
+           vi) Local Color Table Flag - Indicates the presence of a Local Color
+           Table immediately following this Image Descriptor. (This field is
+           the most significant bit of the byte.)
+
+
+           Values :    0 -   Local Color Table is not present. Use
+                             Global Color Table if available.
+                       1 -   Local Color Table present, and to follow
+                             immediately after this Image Descriptor.
+
+
+
+
+
+
+
+
+                                                                        13
+
+
+           vii) Interlace Flag - Indicates if the image is interlaced. An image
+           is interlaced in a four-pass interlace pattern; see Appendix E for
+           details.
+
+           Values :    0 - Image is not interlaced.
+                       1 - Image is interlaced.
+
+            viii) Sort Flag - Indicates whether the Local Color Table is
+            sorted.  If the flag is set, the Local Color Table is sorted, in
+            order of decreasing importance. Typically, the order would be
+            decreasing frequency, with most frequent color first. This assists
+            a decoder, with fewer available colors, in choosing the best subset
+            of colors; the decoder may use an initial segment of the table to
+            render the graphic.
+
+            Values :    0 -   Not ordered.
+                        1 -   Ordered by decreasing importance, most
+                              important color first.
+
+            ix) Size of Local Color Table - If the Local Color Table Flag is
+            set to 1, the value in this field is used to calculate the number
+            of bytes contained in the Local Color Table. To determine that
+            actual size of the color table, raise 2 to the value of the field
+            + 1. This value should be 0 if there is no Local Color Table
+            specified. (This field is made up of the 3 least significant bits
+            of the byte.)
+
+     d. Extensions and Scope. The scope of this block is the Table-based Image
+     Data Block that follows it. This block may be modified by the Graphic
+     Control Extension.
+
+     e. Recommendation. None.
+
+
+21. Local Color Table.
+
+     a. Description. This block contains a color table, which is a sequence of
+     bytes representing red-green-blue color triplets. The Local Color Table
+     is used by the image that immediately follows. Its presence is marked by
+     the Local Color Table Flag being set to 1 in the Image Descriptor; if
+     present, the Local Color Table immediately follows the Image Descriptor
+     and contains a number of bytes equal to
+                          3x2^(Size of Local Color Table+1).
+     If present, this color table temporarily becomes the active color table
+     and the following image should be processed using it. This block is
+     OPTIONAL; at most one Local Color Table may be present per Image
+     Descriptor and its scope is the single image associated with the Image
+     Descriptor that precedes it.
+
+     b. Required Version.  87a.
+
+
+
+
+
+
+
+
+
+
+
+
+
+                                                                        14
+
+
+     c. Syntax.
+
+      7 6 5 4 3 2 1 0        Field Name                    Type
+     +===============+
+  0  |               |       Red 0                         Byte
+     +-             -+
+  1  |               |       Green 0                       Byte
+     +-             -+
+  2  |               |       Blue 0                        Byte
+     +-             -+
+  3  |               |       Red 1                         Byte
+     +-             -+
+     |               |       Green 1                       Byte
+     +-             -+
+ up  |               |
+     +-   . . . .   -+       ...
+ to  |               |
+     +-             -+
+     |               |       Green 255                     Byte
+     +-             -+
+767  |               |       Blue 255                      Byte
+     +===============+
+
+
+     d. Extensions and Scope. The scope of this block is the Table-based Image
+     Data Block that immediately follows it. This block cannot be modified by
+     any extension.
+
+     e. Recommendations. None.
+
+
+22. Table Based Image Data.
+
+     a. Description. The image data for a table based image consists of a
+     sequence of sub-blocks, of size at most 255 bytes each, containing an
+     index into the active color table, for each pixel in the image.  Pixel
+     indices are in order of left to right and from top to bottom.  Each index
+     must be within the range of the size of the active color table, starting
+     at 0. The sequence of indices is encoded using the LZW Algorithm with
+     variable-length code, as described in Appendix F
+
+     b. Required Version.  87a.
+
+     c. Syntax. The image data format is as follows:
+
+      7 6 5 4 3 2 1 0        Field Name                    Type
+     +---------------+
+     |               |       LZW Minimum Code Size         Byte
+     +---------------+
+
+     +===============+
+     |               |
+     /               /       Image Data                    Data Sub-blocks
+     |               |
+     +===============+
+
+
+
+
+
+
+
+
+                                                                        15
+
+
+            i) LZW Minimum Code Size.  This byte determines the initial number
+            of bits used for LZW codes in the image data, as described in
+            Appendix F.
+
+     d. Extensions and Scope. This block has no scope, it contains raster
+     data. Extensions intended to modify a Table-based image must appear
+     before the corresponding Image Descriptor.
+
+     e. Recommendations. None.
+
+
+23. Graphic Control Extension.
+
+      a. Description. The Graphic Control Extension contains parameters used
+      when processing a graphic rendering block. The scope of this extension is
+      the first graphic rendering block to follow. The extension contains only
+      one data sub-block.
+
+      This block is OPTIONAL; at most one Graphic Control Extension may precede
+      a graphic rendering block. This is the only limit to the number of
+      Graphic Control Extensions that may be contained in a Data Stream.
+
+      b. Required Version.  89a.
+
+      c. Syntax.
+
+      7 6 5 4 3 2 1 0        Field Name                    Type
+     +---------------+
+  0  |               |       Extension Introducer          Byte
+     +---------------+
+  1  |               |       Graphic Control Label         Byte
+     +---------------+
+
+     +---------------+
+  0  |               |       Block Size                    Byte
+     +---------------+
+  1  |     |     | | |       <Packed Fields>               See below
+     +---------------+
+  2  |               |       Delay Time                    Unsigned
+     +-             -+
+  3  |               |
+     +---------------+
+  4  |               |       Transparent Color Index       Byte
+     +---------------+
+
+     +---------------+
+  0  |               |       Block Terminator              Byte
+     +---------------+
+
+
+      <Packed Fields>  =     Reserved                      3 Bits
+                             Disposal Method               3 Bits
+                             User Input Flag               1 Bit
+                             Transparent Color Flag        1 Bit
+
+            i) Extension Introducer - Identifies the beginning of an extension
+
+
+
+
+
+
+
+                                                                        16
+
+
+            block. This field contains the fixed value 0x21.
+
+            ii) Graphic Control Label - Identifies the current block as a
+            Graphic Control Extension. This field contains the fixed value
+            0xF9.
+
+            iii) Block Size - Number of bytes in the block, after the Block
+            Size field and up to but not including the Block Terminator.  This
+            field contains the fixed value 4.
+
+            iv) Disposal Method - Indicates the way in which the graphic is to
+            be treated after being displayed.
+
+            Values :    0 -   No disposal specified. The decoder is
+                              not required to take any action.
+                        1 -   Do not dispose. The graphic is to be left
+                              in place.
+                        2 -   Restore to background color. The area used by the
+                              graphic must be restored to the background color.
+                        3 -   Restore to previous. The decoder is required to
+                              restore the area overwritten by the graphic with
+                              what was there prior to rendering the graphic.
+                     4-7 -    To be defined.
+
+            v) User Input Flag - Indicates whether or not user input is
+            expected before continuing. If the flag is set, processing will
+            continue when user input is entered. The nature of the User input
+            is determined by the application (Carriage Return, Mouse Button
+            Click, etc.).
+
+            Values :    0 -   User input is not expected.
+                        1 -   User input is expected.
+
+            When a Delay Time is used and the User Input Flag is set,
+            processing will continue when user input is received or when the
+            delay time expires, whichever occurs first.
+
+            vi) Transparency Flag - Indicates whether a transparency index is
+            given in the Transparent Index field. (This field is the least
+            significant bit of the byte.)
+
+            Values :    0 -   Transparent Index is not given.
+                        1 -   Transparent Index is given.
+
+            vii) Delay Time - If not 0, this field specifies the number of
+            hundredths (1/100) of a second to wait before continuing with the
+            processing of the Data Stream. The clock starts ticking immediately
+            after the graphic is rendered. This field may be used in
+            conjunction with the User Input Flag field.
+
+            viii) Transparency Index - The Transparency Index is such that when
+            encountered, the corresponding pixel of the display device is not
+            modified and processing goes on to the next pixel. The index is
+            present if and only if the Transparency Flag is set to 1.
+
+            ix) Block Terminator - This zero-length data block marks the end of
+
+
+
+
+
+
+
+                                                                        17
+
+            the Graphic Control Extension.
+
+      d. Extensions and Scope. The scope of this Extension is the graphic
+      rendering block that follows it; it is possible for other extensions to
+      be present between this block and its target. This block can modify the
+      Image Descriptor Block and the Plain Text Extension.
+
+      e. Recommendations.
+
+            i) Disposal Method - The mode Restore To Previous is intended to be
+            used in small sections of the graphic; the use of this mode imposes
+            severe demands on the decoder to store the section of the graphic
+            that needs to be saved. For this reason, this mode should be used
+            sparingly.  This mode is not intended to save an entire graphic or
+            large areas of a graphic; when this is the case, the encoder should
+            make every attempt to make the sections of the graphic to be
+            restored be separate graphics in the data stream. In the case where
+            a decoder is not capable of saving an area of a graphic marked as
+            Restore To Previous, it is recommended that a decoder restore to
+            the background color.
+
+            ii) User Input Flag - When the flag is set, indicating that user
+            input is expected, the decoder may sound the bell (0x07) to alert
+            the user that input is being expected.  In the absence of a
+            specified Delay Time, the decoder should wait for user input
+            indefinitely.  It is recommended that the encoder not set the User
+            Input Flag without a Delay Time specified.
+
+
+24. Comment Extension.
+
+      a. Description. The Comment Extension contains textual information which
+      is not part of the actual graphics in the GIF Data Stream. It is suitable
+      for including comments about the graphics, credits, descriptions or any
+      other type of non-control and non-graphic data.  The Comment Extension
+      may be ignored by the decoder, or it may be saved for later processing;
+      under no circumstances should a Comment Extension disrupt or interfere
+      with the processing of the Data Stream.
+
+      This block is OPTIONAL; any number of them may appear in the Data Stream.
+
+      b. Required Version.  89a.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+                                                                        18
+
+
+      c. Syntax.
+
+      7 6 5 4 3 2 1 0        Field Name                    Type
+     +---------------+
+  0  |               |       Extension Introducer          Byte
+     +---------------+
+  1  |               |       Comment Label                 Byte
+     +---------------+
+
+     +===============+
+     |               |
+  N  |               |       Comment Data                  Data Sub-blocks
+     |               |
+     +===============+
+
+     +---------------+
+  0  |               |       Block Terminator              Byte
+     +---------------+
+
+            i) Extension Introducer - Identifies the beginning of an extension
+            block. This field contains the fixed value 0x21.
+
+            ii) Comment Label - Identifies the block as a Comment Extension.
+            This field contains the fixed value 0xFE.
+
+            iii) Comment Data - Sequence of sub-blocks, each of size at most
+            255 bytes and at least 1 byte, with the size in a byte preceding
+            the data.  The end of the sequence is marked by the Block
+            Terminator.
+
+            iv) Block Terminator - This zero-length data block marks the end of
+            the Comment Extension.
+
+      d. Extensions and Scope. This block does not have scope. This block
+      cannot be modified by any extension.
+
+      e. Recommendations.
+
+            i) Data - This block is intended for humans.  It should contain
+            text using the 7-bit ASCII character set. This block should
+            not be used to store control information for custom processing.
+
+            ii) Position - This block may appear at any point in the Data
+            Stream at which a block can begin; however, it is recommended that
+            Comment Extensions do not interfere with Control or Data blocks;
+            they should be located at the beginning or at the end of the Data
+            Stream to the extent possible.
+
+
+25. Plain Text Extension.
+
+      a. Description. The Plain Text Extension contains textual data and the
+      parameters necessary to render that data as a graphic, in a simple form.
+      The textual data will be encoded with the 7-bit printable ASCII
+      characters.  Text data are rendered using a grid of character cells
+
+
+
+
+
+
+
+
+                                                                        19
+
+
+      defined by the parameters in the block fields. Each character is rendered
+      in an individual cell. The textual data in this block is to be rendered
+      as mono-spaced characters, one character per cell, with a best fitting
+      font and size. For further information, see the section on
+      Recommendations below. The data characters are taken sequentially from
+      the data portion of the block and rendered within a cell, starting with
+      the upper left cell in the grid and proceeding from left to right and
+      from top to bottom. Text data is rendered until the end of data is
+      reached or the character grid is filled.  The Character Grid contains an
+      integral number of cells; in the case that the cell dimensions do not
+      allow for an integral number, fractional cells must be discarded; an
+      encoder must be careful to specify the grid dimensions accurately so that
+      this does not happen. This block requires a Global Color Table to be
+      available; the colors used by this block reference the Global Color Table
+      in the Stream if there is one, or the Global Color Table from a previous
+      Stream, if one was saved. This block is a graphic rendering block,
+      therefore it may be modified by a Graphic Control Extension.  This block
+      is OPTIONAL; any number of them may appear in the Data Stream.
+
+      b. Required Version.  89a.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+                                                                        20
+
+
+      c. Syntax.
+
+      7 6 5 4 3 2 1 0        Field Name                    Type
+     +---------------+
+  0  |               |       Extension Introducer          Byte
+     +---------------+
+  1  |               |       Plain Text Label              Byte
+     +---------------+
+
+     +---------------+
+  0  |               |       Block Size                    Byte
+     +---------------+
+  1  |               |       Text Grid Left Position       Unsigned
+     +-             -+
+  2  |               |
+     +---------------+
+  3  |               |       Text Grid Top Position        Unsigned
+     +-             -+
+  4  |               |
+     +---------------+
+  5  |               |       Text Grid Width               Unsigned
+     +-             -+
+  6  |               |
+     +---------------+
+  7  |               |       Text Grid Height              Unsigned
+     +-             -+
+  8  |               |
+     +---------------+
+  9  |               |       Character Cell Width          Byte
+     +---------------+
+ 10  |               |       Character Cell Height         Byte
+     +---------------+
+ 11  |               |       Text Foreground Color Index   Byte
+     +---------------+
+ 12  |               |       Text Background Color Index   Byte
+     +---------------+
+
+     +===============+
+     |               |
+  N  |               |       Plain Text Data               Data Sub-blocks
+     |               |
+     +===============+
+
+     +---------------+
+  0  |               |       Block Terminator              Byte
+     +---------------+
+
+            i) Extension Introducer - Identifies the beginning of an extension
+            block. This field contains the fixed value 0x21.
+
+            ii) Plain Text Label - Identifies the current block as a Plain Text
+            Extension. This field contains the fixed value 0x01.
+
+            iii) Block Size - Number of bytes in the extension, after the Block
+            Size field and up to but not including the beginning of the data
+            portion. This field contains the fixed value 12.
+
+
+
+
+
+
+
+                                                                        21
+
+
+            iv) Text Grid Left Position - Column number, in pixels, of the left
+            edge of the text grid, with respect to the left edge of the Logical
+            Screen.
+
+            v) Text Grid Top Position - Row number, in pixels, of the top edge
+            of the text grid, with respect to the top edge of the Logical
+            Screen.
+
+            vi) Image Grid Width - Width of the text grid in pixels.
+
+            vii) Image Grid Height - Height of the text grid in pixels.
+
+            viii) Character Cell Width - Width, in pixels, of each cell in the
+            grid.
+
+            ix) Character Cell Height - Height, in pixels, of each cell in the
+            grid.
+
+            x) Text Foreground Color Index - Index into the Global Color Table
+            to be used to render the text foreground.
+
+            xi) Text Background Color Index - Index into the Global Color Table
+            to be used to render the text background.
+
+            xii) Plain Text Data - Sequence of sub-blocks, each of size at most
+            255 bytes and at least 1 byte, with the size in a byte preceding
+            the data.  The end of the sequence is marked by the Block
+            Terminator.
+
+            xiii) Block Terminator - This zero-length data block marks the end
+            of the Plain Text Data Blocks.
+
+      d. Extensions and Scope. The scope of this block is the Plain Text Data
+      Block contained in it. This block may be modified by the Graphic Control
+      Extension.
+
+      e. Recommendations. The data in the Plain Text Extension is assumed to be
+      preformatted. The selection of font and size is left to the discretion of
+      the decoder.  If characters less than 0x20 or greater than 0xf7 are
+      encountered, it is recommended that the decoder display a Space character
+      (0x20). The encoder should use grid and cell dimensions such that an
+      integral number of cells fit in the grid both horizontally as well as
+      vertically.  For broadest compatibility, character cell dimensions should
+      be around 8x8 or 8x16 (width x height); consider an image for unusual
+      sized text.
+
+
+26. Application Extension.
+
+      a. Description. The Application Extension contains application-specific
+      information; it conforms with the extension block syntax, as described
+      below, and its block label is 0xFF.
+
+      b. Required Version.  89a.
+
+
+
+
+
+
+
+
+
+                                                                        22
+
+
+      c. Syntax.
+
+      7 6 5 4 3 2 1 0        Field Name                    Type
+     +---------------+
+  0  |               |       Extension Introducer          Byte
+     +---------------+
+  1  |               |       Extension Label               Byte
+     +---------------+
+
+     +---------------+
+  0  |               |       Block Size                    Byte
+     +---------------+
+  1  |               |
+     +-             -+
+  2  |               |
+     +-             -+
+  3  |               |       Application Identifier        8 Bytes
+     +-             -+
+  4  |               |
+     +-             -+
+  5  |               |
+     +-             -+
+  6  |               |
+     +-             -+
+  7  |               |
+     +-             -+
+  8  |               |
+     +---------------+
+  9  |               |
+     +-             -+
+ 10  |               |       Appl. Authentication Code     3 Bytes
+     +-             -+
+ 11  |               |
+     +---------------+
+
+     +===============+
+     |               |
+     |               |       Application Data              Data Sub-blocks
+     |               |
+     |               |
+     +===============+
+
+     +---------------+
+  0  |               |       Block Terminator              Byte
+     +---------------+
+
+            i) Extension Introducer - Defines this block as an extension. This
+            field contains the fixed value 0x21.
+
+            ii) Application Extension Label - Identifies the block as an
+            Application Extension. This field contains the fixed value 0xFF.
+
+            iii) Block Size - Number of bytes in this extension block,
+            following the Block Size field, up to but not including the
+            beginning of the Application Data. This field contains the fixed
+            value 11.
+
+
+
+
+
+
+
+                                                                        23
+
+
+            iv) Application Identifier - Sequence of eight printable ASCII
+            characters used to identify the application owning the Application
+            Extension.
+
+            v) Application Authentication Code - Sequence of three bytes used
+            to authenticate the Application Identifier. An Application program
+            may use an algorithm to compute a binary code that uniquely
+            identifies it as the application owning the Application Extension.
+
+
+      d. Extensions and Scope. This block does not have scope. This block
+      cannot be modified by any extension.
+
+      e. Recommendation. None.
+
+
+27. Trailer.
+
+      a. Description. This block is a single-field block indicating the end of
+      the GIF Data Stream.  It contains the fixed value 0x3B.
+
+      b. Required Version.  87a.
+
+      c. Syntax.
+
+      7 6 5 4 3 2 1 0        Field Name                    Type
+     +---------------+
+  0  |               |       GIF Trailer                   Byte
+     +---------------+
+
+      d. Extensions and Scope. This block does not have scope, it terminates
+      the GIF Data Stream. This block may not be modified by any extension.
+
+      e. Recommendations. None.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+                                                                        24
+
+
+Appendix
+A. Quick Reference Table.
+
+Block Name                  Required   Label       Ext.   Vers.
+Application Extension       Opt. (*)   0xFF (255)  yes    89a
+Comment Extension           Opt. (*)   0xFE (254)  yes    89a
+Global Color Table          Opt. (1)   none        no     87a
+Graphic Control Extension   Opt. (*)   0xF9 (249)  yes    89a
+Header                      Req. (1)   none        no     N/A
+Image Descriptor            Opt. (*)   0x2C (044)  no     87a (89a)
+Local Color Table           Opt. (*)   none        no     87a
+Logical Screen Descriptor   Req. (1)   none        no     87a (89a)
+Plain Text Extension        Opt. (*)   0x01 (001)  yes    89a
+Trailer                     Req. (1)   0x3B (059)  no     87a
+
+Unlabeled Blocks
+Header                      Req. (1)   none        no     N/A
+Logical Screen Descriptor   Req. (1)   none        no     87a (89a)
+Global Color Table          Opt. (1)   none        no     87a
+Local Color Table           Opt. (*)   none        no     87a
+
+Graphic-Rendering Blocks
+Plain Text Extension        Opt. (*)   0x01 (001)  yes    89a
+Image Descriptor            Opt. (*)   0x2C (044)  no     87a (89a)
+
+Control Blocks
+Graphic Control Extension   Opt. (*)   0xF9 (249)  yes    89a
+
+Special Purpose Blocks
+Trailer                     Req. (1)   0x3B (059)  no     87a
+Comment Extension           Opt. (*)   0xFE (254)  yes    89a
+Application Extension       Opt. (*)   0xFF (255)  yes    89a
+
+legend:           (1)   if present, at most one occurrence
+                  (*)   zero or more occurrences
+                  (+)   one or more occurrences
+
+Notes : The Header is not subject to Version Numbers.
+(89a) The Logical Screen Descriptor and the Image Descriptor retained their
+syntax from version 87a to version 89a, but some fields reserved under version
+87a are used under version 89a.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+                                                                        25
+
+
+Appendix
+B. GIF Grammar.
+
+A Grammar is a form of notation to represent the sequence in which certain
+objects form larger objects.  A grammar is also used to represent the number of
+objects that can occur at a given position.  The grammar given here represents
+the sequence of blocks that form the GIF Data Stream. A grammar is given by
+listing its rules.  Each rule consists of the left-hand side, followed by some
+form of equals sign, followed by the right-hand side.  In a rule, the
+right-hand side describes how the left-hand side is defined. The right-hand
+side consists of a sequence of entities, with the possible presence of special
+symbols. The following legend defines the symbols used in this grammar for GIF.
+
+Legend:           <>    grammar word
+                  ::=   defines symbol
+                  *     zero or more occurrences
+                  +     one or more occurrences
+                  |     alternate element
+                  []    optional element
+
+Example:
+
+<GIF Data Stream> ::= Header <Logical Screen> <Data>* Trailer
+
+This rule defines the entity <GIF Data Stream> as follows. It must begin with a
+Header. The Header is followed by an entity called Logical Screen, which is
+defined below by another rule. The Logical Screen is followed by the entity
+Data, which is also defined below by another rule. Finally, the entity Data is
+followed by the Trailer.  Since there is no rule defining the Header or the
+Trailer, this means that these blocks are defined in the document.  The entity
+Data has a special symbol (*) following it which means that, at this position,
+the entity Data may be repeated any number of times, including 0 times. For
+further reading on this subject, refer to a standard text on Programming
+Languages.
+
+
+The Grammar.
+
+<GIF Data Stream> ::=     Header <Logical Screen> <Data>* Trailer
+
+<Logical Screen> ::=      Logical Screen Descriptor [Global Color Table]
+
+<Data> ::=                <Graphic Block>  |
+                          <Special-Purpose Block>
+
+<Graphic Block> ::=       [Graphic Control Extension] <Graphic-Rendering Block>
+
+<Graphic-Rendering Block> ::=  <Table-Based Image>  |
+                               Plain Text Extension
+
+<Table-Based Image> ::=   Image Descriptor [Local Color Table] Image Data
+
+<Special-Purpose Block> ::=    Application Extension  |
+                               Comment Extension
+
+
+
+
+
+
+
+
+
+                                                                        26
+
+
+NOTE : The grammar indicates that it is possible for a GIF Data Stream to
+contain the Header, the Logical Screen Descriptor, a Global Color Table and the
+GIF Trailer. This special case is used to load a GIF decoder with a Global
+Color Table, in preparation for subsequent Data Streams without color tables at
+all.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+                                                                        27
+
+
+Appendix
+C. Glossary.
+
+Active Color Table - Color table used to render the next graphic. If the next
+graphic is an image which has a Local Color Table associated with it, the
+active color table becomes the Local Color Table associated with that image.
+If the next graphic is an image without a Local Color Table, or a Plain Text
+Extension, the active color table is the Global Color Table associated with the
+Data Stream, if there is one; if there is no Global Color Table in the Data
+Stream, the active color table is a color table saved from a previous Data
+Stream, or one supplied by the decoder.
+
+Block - Collection of bytes forming a protocol unit. In general, the term
+includes labeled and unlabeled blocks, as well as Extensions.
+
+Data Stream - The GIF Data Stream is composed of blocks and sub-blocks
+representing images and graphics, together with control information to render
+them on a display device. All control and data blocks in the Data Stream must
+follow the Header and must precede the Trailer.
+
+Decoder - A program capable of processing a GIF Data Stream to render the
+images and graphics contained in it.
+
+Encoder - A program capable of capturing and formatting image and graphic
+raster data, following the definitions of the Graphics Interchange Format.
+
+Extension - A protocol block labeled by the Extension Introducer 0x21.
+
+Extension Introducer - Label (0x21) defining an Extension.
+
+Graphic - Data which can be rendered on the screen by virtue of some algorithm.
+The term graphic is more general than the term image; in addition to images,
+the term graphic also includes data such as text, which is rendered using
+character bit-maps.
+
+Image - Data representing a picture or a drawing; an image is represented by an
+array of pixels called the raster of the image.
+
+Raster - Array of pixel values representing an image.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+                                                                        28
+
+
+Appendix
+D. Conventions.
+
+Animation - The Graphics Interchange Format is not intended as a platform for
+animation, even though it can be done in a limited way.
+
+Byte Ordering - Unless otherwise stated, multi-byte numeric fields are ordered
+with the Least Significant Byte first.
+
+Color Indices - Color indices always refer to the active color table, either
+the Global Color Table or the Local Color Table.
+
+Color Order - Unless otherwise stated, all triple-component RGB color values
+are specified in Red-Green-Blue order.
+
+Color Tables - Both color tables, the Global and the Local, are optional; if
+present, the Global Color Table is to be used with every image in the Data
+Stream for which a Local Color Table is not given; if present, a Local Color
+Table overrides the Global Color Table.  However, if neither color table is
+present, the application program is free to use an arbitrary color table. If
+the graphics in several Data Streams are related and all use the same color
+table, an encoder could place the color table as the Global Color Table in the
+first Data Stream and leave subsequent Data Streams without a Global Color
+Table or any Local Color Tables; in this way, the overhead for the table is
+eliminated.  It is recommended that the decoder save the previous Global Color
+Table to be used with the Data Stream that follows, in case it does not contain
+either a Global Color Table or any Local Color Tables. In general, this allows
+the application program to use past color tables, significantly reducing
+transmission overhead.
+
+Extension Blocks - Extensions are defined using the Extension Introducer code
+to mark the beginning of the block, followed by a block label, identifying the
+type of extension.  Extension Codes are numbers in the range from 0x00 to 0xFF,
+inclusive. Special purpose extensions are transparent to the decoder and may be
+omitted when transmitting the Data Stream on-line. The GIF capabilities
+dialogue makes the provision for the receiver to request the transmission of
+all blocks; the default state in this regard is no transmission of Special
+purpose blocks.
+
+Reserved Fields - All Reserved Fields are expected to have each bit set to zero
+(off).
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+                                                                        29
+
+
+Appendix
+E. Interlaced Images.
+
+The rows of an Interlaced images are arranged in the following order:
+
+      Group 1 : Every 8th. row, starting with row 0.              (Pass 1)
+      Group 2 : Every 8th. row, starting with row 4.              (Pass 2)
+      Group 3 : Every 4th. row, starting with row 2.              (Pass 3)
+      Group 4 : Every 2nd. row, starting with row 1.              (Pass 4)
+
+The Following example illustrates how the rows of an interlaced image are
+ordered.
+
+      Row Number                                        Interlace Pass
+
+ 0    -----------------------------------------       1
+ 1    -----------------------------------------                         4
+ 2    -----------------------------------------                   3
+ 3    -----------------------------------------                         4
+ 4    -----------------------------------------             2
+ 5    -----------------------------------------                         4
+ 6    -----------------------------------------                   3
+ 7    -----------------------------------------                         4
+ 8    -----------------------------------------       1
+ 9    -----------------------------------------                         4
+ 10   -----------------------------------------                   3
+ 11   -----------------------------------------                         4
+ 12   -----------------------------------------             2
+ 13   -----------------------------------------                         4
+ 14   -----------------------------------------                   3
+ 15   -----------------------------------------                         4
+ 16   -----------------------------------------       1
+ 17   -----------------------------------------                         4
+ 18   -----------------------------------------                   3
+ 19   -----------------------------------------                         4
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+                                                                        30
+
+
+Appendix
+F. Variable-Length-Code LZW Compression.
+
+The Variable-Length-Code LZW Compression is a variation of the Lempel-Ziv
+Compression algorithm in which variable-length codes are used to replace
+patterns detected in the original data. The algorithm uses a code or
+translation table constructed from the patterns encountered in the original
+data; each new pattern is entered into the table and its index is used to
+replace it in the compressed stream.
+
+The compressor takes the data from the input stream and builds a code or
+translation table with the patterns as it encounters them; each new pattern is
+entered into the code table and its index is added to the output stream; when a
+pattern is encountered which had been detected since the last code table
+refresh, its index from the code table is put on the output stream, thus
+achieving the data compression.  The expander takes input from the compressed
+data stream and builds the code or translation table from it; as the compressed
+data stream is processed, codes are used to index into the code table and the
+corresponding data is put on the decompressed output stream, thus achieving
+data decompression.  The details of the algorithm are explained below.  The
+Variable-Length-Code aspect of the algorithm is based on an initial code size
+(LZW-initial code size), which specifies the initial number of bits used for
+the compression codes.  When the number of patterns detected by the compressor
+in the input stream exceeds the number of patterns encodable with the current
+number of bits, the number of bits per LZW code is increased by one.
+
+The Raster Data stream that represents the actual output image can be
+represented as:
+
+         7 6 5 4 3 2 1 0
+        +---------------+
+        | LZW code size |
+        +---------------+
+
+        +---------------+ ----+
+        |  block size   |     |
+        +---------------+     |
+        |               |     +-- Repeated as many
+        |  data bytes   |     |   times as necessary.
+        |               |     |
+        +---------------+ ----+
+
+        . . .       . . . ------- The code that terminates the LZW
+                                  compressed data must appear before
+                                  Block Terminator.
+        +---------------+
+        |0 0 0 0 0 0 0 0|  Block Terminator
+        +---------------+
+
+The conversion of the image from a series of pixel values to a transmitted or
+stored character stream involves several steps. In brief these steps are:
+
+1. Establish the Code Size - Define the number of bits needed to represent the
+actual data.
+
+2. Compress the Data - Compress the series of image pixels to a series of
+
+
+
+
+
+
+
+                                                                        31
+
+
+compression codes.
+
+3. Build a Series of Bytes - Take the set of compression codes and convert to a
+string of 8-bit bytes.
+
+4. Package the Bytes - Package sets of bytes into blocks preceded by character
+counts and output.
+
+ESTABLISH CODE SIZE
+
+The first byte of the Compressed Data stream is a value indicating the minimum
+number of bits required to represent the set of actual pixel values. Normally
+this will be the same as the number of color bits. Because of some algorithmic
+constraints however, black & white images which have one color bit must be
+indicated as having a code size of 2.
+This code size value also implies that the compression codes must start out one
+bit longer.
+
+COMPRESSION
+
+The LZW algorithm converts a series of data values into a series of codes which
+may be raw values or a code designating a series of values. Using text
+characters as an analogy, the output code consists of a character or a code
+representing a string of characters.
+
+The LZW algorithm used in GIF matches algorithmically with the standard LZW
+algorithm with the following differences:
+
+1.  A special Clear code is defined which resets all compression/decompression
+parameters and tables to a start-up state. The value of this code is 2**<code
+size>. For example if the code size indicated was 4 (image was 4 bits/pixel)
+the Clear code value would be 16 (10000 binary). The Clear code can appear at
+any point in the image data stream and therefore requires the LZW algorithm to
+process succeeding codes as if a new data stream was starting. Encoders should
+output a Clear code as the first code of each image data stream.
+
+2. An End of Information code is defined that explicitly indicates the end of
+the image data stream. LZW processing terminates when this code is encountered.
+It must be the last code output by the encoder for an image. The value of this
+code is <Clear code>+1.
+
+3. The first available compression code value is <Clear code>+2.
+
+4. The output codes are of variable length, starting at <code size>+1 bits per
+code, up to 12 bits per code. This defines a maximum code value of 4095
+(0xFFF). Whenever the LZW code value would exceed the current code length, the
+code length is increased by one. The packing/unpacking of these codes must then
+be altered to reflect the new code length.
+
+BUILD 8-BIT BYTES
+
+Because the LZW compression used for GIF creates a series of variable length
+codes, of between 3 and 12 bits each, these codes must be reformed into a
+series of 8-bit bytes that will be the characters actually stored or
+transmitted. This provides additional compression of the image. The codes are
+formed into a stream of bits as if they were packed right to left and then
+
+
+
+
+
+
+
+                                                                        32
+
+
+picked off 8 bits at a time to be output.
+
+Assuming a character array of 8 bits per character and using 5 bit codes to be
+packed, an example layout would be similar to:
+
+
+     +---------------+
+  0  |               |    bbbaaaaa
+     +---------------+
+  1  |               |    dcccccbb
+     +---------------+
+  2  |               |    eeeedddd
+     +---------------+
+  3  |               |    ggfffffe
+     +---------------+
+  4  |               |    hhhhhggg
+     +---------------+
+           . . .
+     +---------------+
+  N  |               |
+     +---------------+
+
+
+Note that the physical packing arrangement will change as the number of bits
+per compression code change but the concept remains the same.
+
+PACKAGE THE BYTES
+
+Once the bytes have been created, they are grouped into blocks for output by
+preceding each block of 0 to 255 bytes with a character count byte. A block
+with a zero byte count terminates the Raster Data stream for a given image.
+These blocks are what are actually output for the GIF image. This block format
+has the side effect of allowing a decoding program the ability to read past the
+actual image data if necessary by reading block counts and then skipping over
+the data.
+
+
+
+FURTHER READING
+
+[1] Ziv, J. and Lempel, A. : "A Universal Algorithm for Sequential Data
+Compression", IEEE Transactions on Information Theory, May 1977.
+[2] Welch, T. : "A Technique for High-Performance Data Compression", Computer,
+June 1984.
+[3] Nelson, M.R. : "LZW Data Compression", Dr. Dobb's Journal, October 1989.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+                                                                        33
+
+
+Appendix
+G. On-line Capabilities Dialogue.
+
+NOTE : This section is currently (10 July 1990) under revision; the information
+provided here should be used as general guidelines. Code written based on this
+information should be designed in a flexible way to accommodate any changes
+resulting from the revisions.
+
+The following sequences are defined for use in mediating control between a GIF
+sender and GIF receiver over an interactive communications line. These
+sequences do not apply to applications that involve downloading of static GIF
+files and are not considered part of a GIF file.
+
+GIF CAPABILITIES ENQUIRY
+
+The GIF Capabilities Enquiry sequence is issued from a host and requests an
+interactive GIF decoder to return a response message that defines the graphics
+parameters for the decoder. This involves returning information about available
+screen sizes, number of bits/color supported and the amount of color detail
+supported. The escape sequence for the GIF Capabilities Enquiry is defined as:
+
+ESC[>0g           0x1B 0x5B 0x3E 0x30 0x67
+
+GIF CAPABILITIES RESPONSE
+
+The GIF Capabilities Response message is returned by an interactive GIF decoder
+and defines the decoder's display capabilities for all graphics modes that are
+supported by the software. Note that this can also include graphics printers as
+well as a monitor screen. The general format of this message is:
+
+#version;protocol{;dev, width, height, color-bits, color-res}...<CR>
+
+
+'#'            GIF Capabilities Response identifier character.
+version        GIF format version number;  initially '87a'.
+protocol='0'   No end-to-end protocol supported by decoder Transfer as direct
+               8-bit data stream.
+protocol='1'   Can use CIS B+ error correction protocol to transfer GIF data
+               interactively from the host directly to the display.
+dev = '0'      Screen parameter set follows.
+dev = '1'      Printer parameter set follows.
+width          Maximum supported display width in pixels.
+height         Maximum supported display height in pixels.
+color-bits     Number of bits per pixel supported. The number of supported
+               colors is therefore 2**color-bits.
+color-res      Number of bits per color component supported in the hardware
+               color palette. If color-res is '0' then no hardware palette
+               table is available.
+
+Note that all values in the GIF Capabilities Response are returned as ASCII
+decimal numbers and the message is terminated by a Carriage Return character.
+
+The following GIF Capabilities Response message describes three standard IBM PC
+Enhanced Graphics Adapter configurations with no printer; the GIF data stream
+
+
+
+
+
+
+
+
+
+                                                                        34
+
+
+can be processed within an error correcting protocol:
+
+#87a;1;0,320,200,4,0;0,640,200,2,2;0,640,350,4,2<CR>
+
+ENTER GIF GRAPHICS MODE
+
+Two sequences are currently defined to invoke an interactive GIF decoder into
+action. The only difference between them is that different output media are
+selected. These sequences are:
+
+ESC[>1g     Display GIF image on screen
+
+                  0x1B 0x5B 0x3E 0x31 0x67
+
+ESC[>2g   Display image directly to an attached graphics printer. The image may
+optionally be displayed on the screen as well.
+
+                  0x1B 0x5B 0x3E 0x32 0x67
+
+Note that the 'g' character terminating each sequence is in lowercase.
+
+INTERACTIVE ENVIRONMENT
+
+The assumed environment for the transmission of GIF image data from an
+interactive application is a full 8-bit data stream from host to micro.  All
+256 character codes must be transferrable. The establishing of an 8-bit data
+path for communications will normally be taken care of by the host application
+programs. It is however up to the receiving communications programs supporting
+GIF to be able to receive and pass on all 256 8-bit codes to the GIF decoder
+software.
+
+
diff --git a/doc/gifstandard/gif89a.css b/doc/gifstandard/gif89a.css
new file mode 100644
index 0000000..417975e
--- /dev/null
+++ b/doc/gifstandard/gif89a.css
@@ -0,0 +1,62 @@
+ul {
+	list-style-type:disc;
+}
+ul ul {
+	list-style-type:circle;
+}
+
+div#notes {
+	font-style:italic;
+}
+
+table.invisible {
+	border-spacing:0;
+}
+
+table#interlace td {
+	text-align:center;
+}
+
+div.hiddenparagraph {
+	display:none;
+}
+
+@media not print {
+	a[href*="#"] {
+		text-decoration:none;
+		color:blue;
+	}
+
+	span.rcomp {
+		background:#FAA;
+	}
+	span.gcomp {
+		background:#8F8;
+	}
+	span.bcomp {
+		background:#BBF;
+	}
+	
+	h2 span {
+		font-size:small;
+		font-weight:normal;
+		text-decoration:underline;
+	}
+
+	div.togglevisall span {
+		font-weight:bold;
+		text-decoration:underline;
+	}
+}
+
+@media print {
+	table,
+	li {
+		page-break-inside:avoid;
+	}
+
+	h2 span,
+	div.togglevisall {
+		display:none;
+	}
+}
diff --git a/doc/gifstandard/gif89a.js b/doc/gifstandard/gif89a.js
new file mode 100644
index 0000000..78e0fea
--- /dev/null
+++ b/doc/gifstandard/gif89a.js
@@ -0,0 +1,15 @@
+function ToggleVis(number) {
+	// toggle visibility of a single chapter
+	id = "p" + number;
+	c = document.getElementById(id).className;
+	c = (c == "" ? "hiddenparagraph" : "");
+	document.getElementById(id).className = c;
+}
+
+function SetEveryVis(status) {
+	// set visibility of every chapter
+	c = (status == 0 ? "hiddenparagraph" : "");
+	for(i = 0; i <= 35; i++) {
+		document.getElementById("p" + i).className = c;
+	}
+}
diff --git a/doc/gifstandard/main.css b/doc/gifstandard/main.css
new file mode 100644
index 0000000..b661500
--- /dev/null
+++ b/doc/gifstandard/main.css
@@ -0,0 +1,43 @@
+/* some pages also use their own CSS files, so: NO CUSTOM CLASS NAMES HERE */
+
+body {
+	background:white;
+	color:black;
+	font-family:sans-serif;
+}
+
+table {
+	background:black;
+	border-spacing:2px;
+}
+th, td {
+	padding:3px 5px;
+	vertical-align:middle;
+	empty-cells:show;
+}
+th {
+	background:silver;
+}
+td {
+	background:white;
+}
+
+h1 {
+	text-align:center;
+}
+pre, tt {
+	font-size:120%;
+}
+abbr {
+	text-decoration:underline;
+}
+
+@media print {
+	.noprint {
+		display:none;
+	}
+	a[href] {
+		color:black;
+		text-decoration:none;
+	}
+}
diff --git a/doc/giftext.xml b/doc/giftext.xml
new file mode 100644
index 0000000..942d1ce
--- /dev/null
+++ b/doc/giftext.xml
@@ -0,0 +1,110 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE refentry PUBLIC
+   "-//OASIS//DTD DocBook XML V4.1.2//EN"
+   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>
+<refentry id='giftext.1'>
+<refentryinfo><date>2 May 2012</date></refentryinfo>
+<refmeta>
+<refentrytitle>giftext</refentrytitle>
+<manvolnum>1</manvolnum>
+<refmiscinfo class="source">GIFLIB</refmiscinfo>
+<refmiscinfo class="manual">GIFLIB Documentation</refmiscinfo>
+</refmeta>
+<refnamediv id='name'>
+<refname>giftext</refname>
+<refpurpose>dump GIF pixels and metadata as text</refpurpose>
+</refnamediv>
+
+<refsynopsisdiv id='synopsis'>
+
+<cmdsynopsis>
+  <command>giftext</command>
+      <arg choice='opt'>-v</arg>
+      <arg choice='opt'>-c</arg>
+      <arg choice='opt'>-e</arg>
+      <arg choice='opt'>-z</arg>
+      <arg choice='opt'>-p</arg>
+      <arg choice='opt'>-r</arg>
+      <arg choice='opt'>-h</arg>
+      <arg choice='opt'><replaceable>gif-file</replaceable></arg>
+</cmdsynopsis>
+</refsynopsisdiv>
+
+<refsect1><title>Description</title>
+
+<para>A program to dump (text only) general information about GIF file.</para>
+
+<para>If no GIF file is given, giftext will try to read a GIF file
+from stdin.</para>
+
+</refsect1>
+<refsect1><title>Options</title>
+
+<variablelist>
+<varlistentry>
+<term>-v</term>
+<listitem>
+<para> Verbose mode (show progress).
+Enables printout of running scan lines. </para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>-c</term>
+<listitem>
+<para> Dumps the color maps.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>-e</term>
+<listitem>
+<para> Dumps encoded bytes - the pixels after compressed using LZ
+algorithm and chained to form bytes.  This is the form the data is
+saved in the GIF file.  Dumps in hex - 2 digit per byte.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>-z</term>
+<listitem>
+<para> Dumps the LZ codes of the image.  Dumps in hex - 3 digits per
+code (as we are limited to 12 bits).</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>-p</term>
+<listitem>
+<para> Dumps the pixels of the image.  Dumps in hex - 2 digit per
+pixel (&lt;=byte).</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>-r</term>
+<listitem>
+<para> Dumps raw pixels as one byte per pixel.  This option inhibits
+all other options and only the pixels are dumped.  This option may be
+used to convert GIF files into raw data.  Note: the color map can be
+extracted by gifclrmp utility.  If more than one image is included in
+the file, all images will be dumped in order.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>-h</term>
+<listitem>
+<para> Print one line of command line help, similar to Usage
+above.</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+</refsect1>
+<refsect1><title>Author</title>
+
+<para>Gershon Elber.</para>
+
+</refsect1>
+</refentry>
diff --git a/doc/giftool.xml b/doc/giftool.xml
new file mode 100644
index 0000000..91c77f9
--- /dev/null
+++ b/doc/giftool.xml
@@ -0,0 +1,187 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE refentry PUBLIC
+   "-//OASIS//DTD DocBook XML V4.1.2//EN"
+   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>
+<refentry id='giftool.1'>
+<refentryinfo><date>3 June 2012</date></refentryinfo>
+<refmeta>
+<refentrytitle>giftool</refentrytitle>
+<manvolnum>1</manvolnum>
+<refmiscinfo class="source">GIFLIB</refmiscinfo>
+<refmiscinfo class="manual">GIFLIB Documentation</refmiscinfo>
+</refmeta>
+<refnamediv id='name'>
+<refname>giftool</refname>
+<refpurpose>GIF transformation tool</refpurpose>
+</refnamediv>
+
+<refsynopsisdiv id='synopsis'>
+
+<cmdsynopsis>
+  <command>giftool</command>
+      <arg choice='opt'>-a <replaceable>aspect</replaceable></arg>
+      <arg choice='opt'>-b <replaceable>bgcolor</replaceable></arg>
+      <arg choice='opt'>-d <replaceable>delaytime</replaceable></arg>
+      <arg choice='opt'>-i <replaceable>interlacing</replaceable></arg>
+      <arg choice='opt'>-n <replaceable>imagelist</replaceable></arg>
+      <arg choice='opt'>-p <replaceable>left,top</replaceable></arg>
+      <arg choice='opt'>-s <replaceable>width,height</replaceable></arg>
+      <arg choice='opt'>-t <replaceable>transcolor</replaceable></arg>
+      <arg choice='opt'>-u <replaceable>sort-flag</replaceable></arg>
+      <arg choice='opt'>-x <replaceable>disposal</replaceable></arg>
+      <arg choice='opt'>-z <replaceable>sort-flag</replaceable></arg>
+</cmdsynopsis>
+</refsynopsisdiv>
+
+<refsect1><title>Description</title>
+
+<para>A filter for transforming GIFS. With no options, it's an expensive 
+copy of a GIF in standard input to standard output.  Options specify
+filtering operations and are performed in the order specified on the command 
+line.</para>
+
+<para>The -n option selects images, allowing the tool to act on a
+subset of images in a multi-image GIF.  This option takes a
+comma-separated list of decimal integers which are interpreted as
+1-origin image indices; these are the images that will be acted on.
+If no -n option is specified, the tool will select and transform all
+images.</para>
+
+<para>The -b option takes a decimal integer argument and uses it to
+set the (0-origin) screen background color index.</para>
+
+<para>The -f option accepts a printf-style format string and
+substitutes into it the values of image-descriptor and graphics-control
+fields. The string is formatted and output once for each selected
+image.  Normal C-style escapes \b, \f, \n, \r, \t. \v, and \xNN are
+interpreted; also \e produces ESC (ASCII 0x1b).  The following format
+cookies are substituted:</para>
+
+<variablelist>
+<varlistentry>
+<term>%a</term>
+<listitem><para>Pixel aspect byte.</para></listitem>
+</varlistentry>
+<varlistentry>
+<term>%b</term>
+<listitem><para>Screen background color.</para></listitem>
+</varlistentry>
+<varlistentry>
+<term>%d</term>
+<listitem><para>Image delay time</para></listitem>
+</varlistentry>
+<varlistentry>
+<term>%h</term>
+<listitem><para>Image height (y dimension)</para></listitem>
+</varlistentry>
+<varlistentry>
+<term>%n</term>
+<listitem><para>Image index</para></listitem>
+</varlistentry>
+<varlistentry>
+<term>%p</term>
+<listitem><para>Image position (as an x,y pair)</para></listitem>
+</varlistentry>
+<varlistentry>
+<term>%s</term>
+<listitem><para>Screen size (as an x,y pair)</para></listitem>
+</varlistentry>
+<varlistentry>
+<term>%t</term>
+<listitem><para>Image transparent-color index</para></listitem>
+</varlistentry>
+<varlistentry>
+<term>%u</term>
+<listitem><para>Image user-input flag (boolean)</para></listitem>
+</varlistentry>
+<varlistentry>
+<term>%v</term>
+<listitem><para>GIF version string</para></listitem>
+</varlistentry>
+<varlistentry>
+<term>%w</term>
+<listitem><para>Image width (x dimension)</para></listitem>
+</varlistentry>
+<varlistentry>
+<term>%x</term>
+<listitem><para>Image GIF89 disposal mode</para></listitem>
+</varlistentry>
+<varlistentry>
+<term>%z</term>
+<listitem><para>Image's color table sort flag (boolean, 
+false if no local color map)</para></listitem>
+</varlistentry>
+</variablelist>
+
+<para>Boolean substitutions may take a prefix to modify how they are
+displayed:</para>
+
+<variablelist>
+<varlistentry>
+<term>1</term>
+<listitem><para>"1" or "0"</para></listitem>
+</varlistentry>
+<varlistentry>
+<term>o</term>
+<listitem><para>"on" or "off"</para></listitem>
+</varlistentry>
+<varlistentry>
+<term>t</term>
+<listitem><para>"t" or "f"</para></listitem>
+</varlistentry>
+<varlistentry>
+<term>y</term>
+<listitem><para>"yes" or "no"</para></listitem>
+</varlistentry>
+</variablelist>
+
+<para>Thus, for example, "%oz" displays image sort flags using the
+strings "on" and "off". The default with no prefix is numeric.</para>
+
+<para>The -a option takes an unsigned decimal integer argument and
+uses it to set the aspect-ratio bye in the logical screen descriptor
+block.</para>
+
+<para>The -b option takes an unsigned decimal integer argument and
+uses it to set the background color index in the logical screen
+descriptor block.</para>
+
+<para>The -d option takes a decimal integer argument and uses it to set a delay
+time, in hundredths of a second, on selected images.</para>
+
+<para>The -i option sets or clears interlaccing in selected images. Acceptable arguments are "1", "0", "yes", "no", "on", "off", "t", "f"</para>
+
+<para>The -p option takes a (0-origin) x,y coordinate-pair and sets it
+as the preferred upper-left-corner coordinates of selected
+images.</para>
+
+<para>The -s option takes a (0-origin) x,y coordinate-pair and sets it
+as the expected display screen size.</para>
+
+<para>The -t option takes a decimal integer argument and uses it to set the 
+(0-origin) index of the transparency color in selected images.</para>
+
+<para>The -u option sets or clears the user-input flag in selected
+images.  Acceptable arguments are "1", "0", "yes", "no", "on", "off",
+"t", "f".</para>
+
+<para>The -x option takes a decimal integer argument and uses it to set the
+GIF89 disposal mode in selected images.</para>
+
+<para>The -z option sets or clears the color-table sort flag in
+selected images.  Acceptable arguments are "1", "0", "yes", "no",
+"on", "off", "t", "f".</para>
+
+<para>Note that the -a, -b, -p, -s, and -z options are included to
+complete the ability to modify all fields defined in the GIF standard,
+but should have no effect on how an image renders on browsers or
+modern viewers.</para>
+
+</refsect1>
+<refsect1><title>Author</title>
+
+<para>Eric S. Raymond.</para>
+
+</refsect1>
+</refentry>
+
diff --git a/doc/gifwedge.xml b/doc/gifwedge.xml
new file mode 100644
index 0000000..b1a7809
--- /dev/null
+++ b/doc/gifwedge.xml
@@ -0,0 +1,81 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE refentry PUBLIC
+   "-//OASIS//DTD DocBook XML V4.1.2//EN"
+   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>
+<refentry id='gifwedge.1'>
+<refentryinfo><date>2 May 2012</date></refentryinfo>
+<refmeta>
+<refentrytitle>gifwedge</refentrytitle>
+<manvolnum>1</manvolnum>
+<refmiscinfo class="source">GIFLIB</refmiscinfo>
+<refmiscinfo class="manual">GIFLIB Documentation</refmiscinfo>
+</refmeta>
+<refnamediv id='name'>
+<refname>gifwedge</refname>
+<refpurpose>create a GIF test pattern</refpurpose>
+</refnamediv>
+
+<refsynopsisdiv id='synopsis'>
+
+<cmdsynopsis>
+  <command>gifwedge</command>
+      <arg choice='opt'>-v</arg>
+      <arg choice='opt'>-l <replaceable>lvls</replaceable></arg>
+      <arg choice='opt'>-s 
+      		<replaceable>sizex</replaceable>
+      		<replaceable>sizey</replaceable></arg>
+      <arg choice='opt'>-h</arg>
+      <arg choice='opt'><replaceable>gif-file</replaceable></arg>
+</cmdsynopsis>
+</refsynopsisdiv>
+
+<refsect1><title>Description</title>
+
+<para>A program to create a test GIF image with intensity levels of
+the RGB colors YCM colors and white.</para>
+
+</refsect1>
+<refsect1><title>Options</title>
+
+<variablelist>
+<varlistentry>
+<term>-v</term>
+<listitem>
+<para>Verbose mode (show progress).
+Enables printout of running scan lines. </para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>-l lvls</term>
+<listitem>
+<para>Set number of intensity levels per color.  This number must be
+power of two up to 32, as Gif format can only have 256 color
+simultaneously and 7 basic colors are to be displayed.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>-s sizex sizey</term>
+<listitem>
+<para>Force image size to be SizeX by SizeY pixels. Image size will be
+rounded down to be a multiple of number of intensities horizontally,
+and 7 (colors) vertically.</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>-h</term>
+<listitem>
+<para>Print one line command line help, similar to Usage above.</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+</refsect1>
+<refsect1><title>Author</title>
+
+<para>Gershon Elber.</para>
+
+</refsect1>
+</refentry>
diff --git a/doc/index.html b/doc/index.html
new file mode 100644
index 0000000..6b426de
--- /dev/null
+++ b/doc/index.html
@@ -0,0 +1,109 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'
+    'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
+<html>
+<head>
+<link rev='made' href='mailto:esr@snark.thyrsus.com' />
+<meta name='MSSmartTagsPreventParsing' content='TRUE' />
+<title>The GIFLIB project</title>
+<script type="text/javascript">
+// JavaScript to generate a compact date representation
+
+//
+// format date as yyyy-mm-dd
+//
+function date_ddmmmyyyy(date)
+{
+  var d = date.getDate();
+  var m = date.getMonth() + 1;
+  var y = date.getFullYear();
+
+  return "" + y + "-" + (m<10?"0"+m:m) + "-" + (d<10?"0"+d:d);
+}
+
+
+//
+// get last modified date of the 
+// current document.
+//
+function date_lastmodified()
+{
+  var lmd = document.lastModified;
+  var s   = "Unknown";
+  var d1;
+
+  // check if we have a valid date
+  // before proceeding
+  if(0 != (d1=Date.parse(lmd)))
+  {
+    s = "" + date_ddmmmyyyy(new Date(d1));
+  }
+
+  return s;
+}
+// End
+</script>
+</head>
+<body>
+<table width='100%' cellpadding='0' summary='Canned page header' bgcolor="#ddd">
+<tr>
+<td><h2>The GIFLIB project</h2></td>
+<td align="center"><img src="giflib-logo.gif"></td>
+<td align='right'><script type="text/javascript">
+document.write(date_lastmodified());
+</script></td>
+</tr>
+</table>
+
+<p>The GIFLIB project maintains the giflib service library, which has
+been pulling images out of GIFs since 1989. It is deployed everywhere
+you can think of and some places you probably can't - graphics
+applications and web browsers on multiple operating systems, game
+consoles, smartphones, and likely your ATM too.</p>
+
+<p>Yes, this code is he reason GIFs were in Mosaic, the first web
+browser that could do inline graphics; it is the implementation
+Andreesen and Bina used.</p>
+
+<p>This is very mature, stable, small-footprint code with minimal
+dependencies (suitable for use in embedded deployments) that needs only
+occasional very minor bugfixes. Test reports from odd platforms and
+better regression tests are particularly welcome. Don't try to
+redesign it, applications beyond counting would break if you did.</p>
+
+<p>It's "GIFLIB" in caps as a nod to the code's origins in the dark
+and backward abysm of MS-DOS, but Unix hackers are encouraged to spell it 
+"giflib" in deference to local conventions. :-)
+
+<p>You can read GIFLIB's documentation <a href="intro.html">here</a>
+and a very detailed description of GIF <a
+href="whatsinagif/index.html">here</a>. People to thank for this code:
+Gershon Elber, Eric S. Raymond, Toshio Kuratomi.</p>
+
+<p>Before October 2006 the GIF format was encumbered by patents on the
+LZW compression it uses.  This first became an issue in 1993 when the
+patent-holders made ambiguous noises about requiring royalties.  For
+some time a subset of this code travelled as "libungif", supporting
+decompression but not compression. You can read a more detailed
+history <a href="history.html">here</a>.</p>
+
+<p>Note: The 5.x versions change the API slightly in a way that isn't
+compatible with older shared libraries.  This was required to fix 
+some known problems with the extensions API and with thread-safety.</p>
+
+<p>If you require shared-library compatibility back to ancient
+versions, build from 4.2. 4.2 and the 5.0 version are behaviorally
+almost identical; the few differences are explained <a
+href="gif_lib.html#compatibility">here</a>.
+
+<p>The SourceForge summary page (where you can download the source,
+review the project, find links to the bugtracker  and mailing list
+pages, or ask to join the project as a developer) is <a
+href="https://sourceforge.net/projects/giflib/">here</a>.
+
+<p>If you appreciate this project, and especially if you make money
+from it, please <a href="https://www.patreon.com/esr">support
+continuing maintainance on Patreon</a>.</p>
+
+</body>
+</html>
diff --git a/doc/index.html.in b/doc/index.html.in
new file mode 100644
index 0000000..3cbe2c5
--- /dev/null
+++ b/doc/index.html.in
@@ -0,0 +1,125 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'
+    'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
+<html>
+<head>
+<link rev='made' href='mailto:esr@snark.thyrsus.com' />
+<meta name='MSSmartTagsPreventParsing' content='TRUE' />
+<title>The GIFLIB project</title>
+<script type="text/javascript">
+// JavaScript to generate a compact date representation
+
+//
+// format date ISO-fashion: yyyy-mm-dd
+//
+function date_ddmmmyyyy(date)
+{
+  var d = date.getDate();
+  var m = date.getMonth() + 1;
+  var y = date.getFullYear();
+
+  return "" + y + "-" + (m<10?"0"+m:m) + "-" + (d<10?"0"+d:d);
+}
+
+//
+// get last modified date of the 
+// current document.
+//
+function date_lastmodified()
+{
+  var lmd = document.lastModified;
+  var s   = "Unknown";
+  var d1;
+
+  // check if we have a valid date
+  // before proceeding
+  if(0 != (d1=Date.parse(lmd)))
+  {
+    s = "" + date_ddmmmyyyy(new Date(d1));
+  }
+
+  return s;
+}
+// End
+</script>
+</head>
+<body>
+<table width='100%' cellpadding='0' summary='Canned page header' bgcolor="#ddd">
+<tr>
+<td><h2>The GIFLIB project</h2></td>
+<td align="center"><img src="giflib-logo.gif"></td>
+<td align='right'><script type="text/javascript">
+document.write(date_lastmodified());
+</script></td>
+</tr>
+</table>
+
+<p>The GIFLIB project maintains the giflib service library, which has
+been pulling images out of GIFs since 1989. It is deployed everywhere
+you can think of and some places you probably can't - graphics
+applications and web browsers on multiple operating systems, game
+consoles, smartphones, and likely your ATM too.</p>
+
+<p>Yes, this code is he reason GIFs were in Mosaic, the first web
+browser that could do inline graphics; it is the implementation
+Andreesen and Bina used.</p>
+
+<p>This is very mature, stable, small-footprint code with minimal
+dependencies (suitable for use in embedded deployments) that needs only
+occasional very minor bugfixes. Test reports from odd platforms and
+better regression tests are particularly welcome. Don't try to
+redesign it, applications beyond counting would break if you did.</p>
+
+<p>It's "GIFLIB" in caps as a nod to the code's origins in the dark
+and backward abysm of MS-DOS, but Unix hackers are encouraged to spell it 
+"giflib" in deference to local conventions. :-)
+
+<p>Before October 2006 the GIF format was encumbered by patents on the
+LZW compression it uses.  This first became an issue in 1993 when the
+patent-holders made ambiguous noises about requiring royalties.  For
+some time a subset of this code travelled as "libungif", supporting
+decompression but not compression. You can read a more detailed
+history <a href="history.html">here</a>.</p>
+
+<p>Note: The 5.x versions change the API slightly in a way that isn't
+compatible with older shared libraries.  This was required to fix 
+some known problems with the extensions API and with thread-safety.</p>
+
+<p>If you require shared-library compatibility back to ancient
+versions, build from 4.2. 4.2 and the 5.0 version are behaviorally
+almost identical; the few differences are explained <a
+href="gif_lib.html#compatibility">here</a>.
+
+<p>The SourceForge summary page (where you can download the source,
+review the project, find links to the bugtracker  and mailing list
+pages, or ask to join the project as a developer) is <a
+href="https://sourceforge.net/projects/giflib/">here</a>.
+
+<p>People to thank for this code: Gershon Elber, Eric S. Raymond,
+Toshio Kuratomi.</p>
+
+<p>If you appreciate this project, and especially if you make money
+from it, please <a href="https://www.patreon.com/esr">support
+continuing maintainance on Patreon</a>.</p>
+
+<p>GIFLIB technical documentation:</p>
+<ul>
+<li><a href="intro.html">GIFLIB documentation</a></li>
+<li><a href="history.html">GIFLIB's history</a></li>
+<li><a href="gif_lib.html#compatibility">Difference between 4.2 and 5.0</a></li>
+<li><a href="https://sourceforge.net/projects/giflib/">SourceForge project page</a></li>
+<li><a href="https://www.patreon.com/esr">Support this project</a></li>
+</ul>
+
+<p>GIF resources:</p>
+<ul>
+<li><a href="whatsinagif/index.html">What's In A GIF?</a></li>
+<li><a href="gifstandard/GIF89a.html">The GIF standard</a></li>
+<li><a href="gifstandard/LZW-and-GIF-explained.html">LZW and GIF explained</a></li>
+<li><a href="https://en.wikipedia.org/wiki/GIF">Wikipedia on GIF</a></li>
+</ul>
+
+<p>To support this ubiquitous code, <a href="https://www.patreon.com/bePatron?u=962938" data-patreon-widget-type="become-patron-button">Become a Patreon patron!</a><script async src="https://c6.patreon.com/becomePatronButton.bundle.js"></script></p>
+
+</body>
+</html>
diff --git a/doc/intro.xml b/doc/intro.xml
new file mode 100644
index 0000000..2a3fe5f
--- /dev/null
+++ b/doc/intro.xml
@@ -0,0 +1,225 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE article PUBLIC 
+   "-//OASIS//DTD DocBook XML V4.1.2//EN"
+   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
+<!ENTITY homepage      "http://catb.org/~esr/">
+<!ENTITY email         "esr@thyrsus.com">
+]>
+<article><title>Introduction to GIFLIB</title>
+
+<articleinfo>
+
+<author>
+  <firstname>Eric</firstname>
+  <othername>Steven</othername>
+  <surname>Raymond</surname>
+  <affiliation>
+    <orgname><ulink url="&homepage;">
+    Thyrsus Enterprises</ulink></orgname> 
+    <address>
+    <email>&email;</email>
+    </address>
+  </affiliation>
+</author>
+<copyright>
+  <year>2012</year>
+  <holder role="mailto:&email;">Eric S. Raymond</holder> 
+</copyright>
+
+</articleinfo>
+
+<para>GIFLIB is a package of portable tools and library routines for
+working with GIF images.</para>
+
+<para>The Graphics Interchange Format(c) specification is the copyrighted
+property of CompuServe Incorporated.  GIF(sm) is a service mark
+property of CompuServe Incorporated.</para>
+
+<para>This package has been released under an X Consortium-like open-source
+license.  Use and copy as you see fit.  If you make useful changes,
+add new tools, or find and fix bugs, please send your mods to the
+maintainers for general distribution.</para>
+
+<para>The util directory includes programs to clip, rotate, scale, and
+position GIF images.  These are no replacement for an interactive graphics
+editor, but they can be very useful for scripted image generation or
+transformation.</para>
+
+<para>The library includes program-callable entry points for reading and writing
+GIF files, an 8x8 utility font for embedding text in GIFs, and an error
+handler.  GIF manipulation can be done at a relatively low level by
+sequential I/O (which automatically does/undoes image compression) or at
+a higher level by slurping an entire GIF into allocated core.</para>
+
+<para>This library speaks both GIF87a and GIF89.  The differences
+between GIF87 and GIF89 are minor: in the latter, the interpretation
+of some extension block types is defined.  The library never needs to
+actually interpret these, but <ulink
+url="giftext.html">giftext</ulink> notices them and there are
+functions in the API to read and modify them.</para>
+
+<sect1><title>Utilities</title>
+
+<para>Here is a summary of the utilities in this package.  If you're looking
+at this page through a web browser, each utility name should be a
+hotlink to HTML documentation.</para>
+
+<para>Most utilities have a -v (verbose) option that will cause them to print
+the current input scan line number (counting up) whenever they read
+image input, and will print output image line number (counting down)
+when they dump output.  Utilities that only read or write always print
+in increasing order.</para>
+
+<!--
+Note: the giflib.1 man page is deliberately omitted from the following
+list of references. It's meant to be seen through man(1) only as part
+of a local installation of the tools.
+-->
+
+<sect2><title>Conversion Utilities</title>
+
+<variablelist>
+<varlistentry>
+<term><ulink url="gif2rgb.html">gif2rgb</ulink></term>
+<listitem>
+<para>convert images saved as GIF to 24-bit RGB image(s) or vice-versa</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+</sect2>
+<sect2><title>Image Manipulation Components</title>
+
+<variablelist>
+<varlistentry>
+<term><ulink url="gifclrmp.html">gifclrmp</ulink></term>
+<listitem>
+<para>modify GIF image colormaps</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term><ulink url="giffix.html">giffix</ulink></term>
+<listitem>
+<para>clumsily attempts to fix truncated GIF images</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+</sect2>
+<sect2><title>Report Generators</title>
+
+<variablelist>
+<varlistentry>
+<term><ulink url="giftext.html">giftext</ulink></term>
+<listitem>
+<para>print (text only) general information about a GIF</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+</sect2>
+<sect2><title>GIF Composition Tools</title>
+
+<variablelist>
+<varlistentry>
+<term><ulink url="gifbuild.html">gifbuild</ulink></term>
+<listitem>
+<para>converter/deconverter to/from an editable text format</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term><ulink url="giftool.html">giftool</ulink></term>
+<listitem>
+<para>GIF transformation tool</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+</sect2>
+<sect2><title>Obsolete utilities</title>
+
+<para>These are used for testing by the GFLIB developers and no longer
+installed by a normal build.</para>
+
+<variablelist>
+<varlistentry>
+<term><ulink url="gifbg.html">gifbg</ulink></term>
+<listitem>
+<para>generate a single-color test pattern GIF</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term><ulink url="gifcolor.html">gifcolor</ulink></term>
+<listitem>
+<para>generate color test patterns</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term><ulink url="gifwedge.html">gifwedge</ulink></term>
+<listitem>
+<para>create a test GIF image resembling a color monitor test pattern</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term><ulink url="gifhisto.html">gifhisto</ulink></term>
+<listitem>
+<para>generate color-frequency histogram from a GIF</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term><ulink url="gifecho.html">gifecho</ulink></term>
+<listitem>
+<para>generate GIF images out of regular text in 8x8 font</para>
+</listitem>
+</varlistentry>
+<varlistentry>
+<term><ulink url="gifinto.html">gifinto</ulink></term>
+<listitem>
+<para>end-of-pipe fitting for GIF-processing pipelines</para>
+</listitem>
+</varlistentry>
+</variablelist>
+
+
+</sect2>
+</sect1>
+<sect1><title>Library Functions</title>
+
+<para>The library contains two groups of C functions.  One group does
+sequential I/O on the stream-oriented GIF format.  The other supports
+grabbing an entire GIF into allocated core, operating on it in core,
+and then writing the modified in-core GIF out to disk.</para>
+
+<para>Unless you are on extremely memory-limited machine, you probably want
+to use the second group.</para>
+
+<para>Detailed documentation on the library entry points is in <ulink
+url="gif_lib.html">gif_lib.html</ulink>.</para>
+
+</sect1>
+<sect1><title>The GIF Standard</title>
+
+<para>The doc subdirectory includes an <ulink
+url="gifstandard/GIF89a.html">HTML presentation of the GIF
+standard</ulink>; an <ulink url="gifstandard/
+LZW-and-GIF-explained.html">explanation of Lempel-Ziv
+compression</ulink>, and the original flat-ASCII description of <ulink
+url="gifstandard/gif89.txt">GIF89 format</ulink> . For historical
+completeness, we also include a copy of the <ulink
+url="gifstandard/gif87.txt">GIF87 standard.</ulink></para>
+
+<para>You can also read a <ulink url="whatsinagif/index.html">
+detailed narrative description</ulink> of how GIFs are laid out.  It
+clarifies some points on which the standard is obscure.</para>
+
+</sect1>
+<sect1><title>Package Status</title>
+
+<para>GIFLIB's current maintainer is Eric S. Raymond.  You can find his home
+page at <ulink url="&homepage;">&homepage;</ulink>.</para>
+
+<para>GIFLIB is not under active development, but bug fixes are being
+accepted.</para>
+
+</sect1>
+</article>
diff --git a/doc/whatsinagif/animation_and_transparency.html b/doc/whatsinagif/animation_and_transparency.html
new file mode 100644
index 0000000..269a3db
--- /dev/null
+++ b/doc/whatsinagif/animation_and_transparency.html
@@ -0,0 +1,505 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html>
+<head>
+<title>What's In A GIF - Animation and Transparency</title>
+<script type="text/javascript"></script>
+<link rel="stylesheet" href="../proj.css" />
+<style type="text/css">
+.byte {font-family: Courier, fixed;
+	padding: .2em}
+.gif_header {background-color: #f9E89D}
+.gif_screen {background-color: #C8DBD9}
+.gif_color {background-color: #E1E1E1}
+.gif_graphic {background-color: #F9EB9D}
+.gif_imgdesc {background-color: #C2D1DC}
+.gif_imgdata {background-color: #D0C4C4}
+.gif_trailer {background-color: #f9E89D}
+.gif_ext {background-color: #D0CFAE}
+#global_color_size {margin-left: auto; margin-right:auto; border:1px solid black;}
+#global_color_size td {text-align:center;}
+</style>
+</head>
+<body>
+<table width='100%' cellpadding='0' summary='Canned page header' bgcolor="#ddd">
+<tr>
+<td><h2>What's In A GIF</h2></td>
+<td align="center"><img src="../giflib-logo.gif"></td>
+<td align="right">(animation and transparency)</td>
+</tr>
+</table>
+
+<div id="body">
+<div style="text-align:center; margin-top: 10px; padding-top: 10px; border-top: #cecece 1px solid">
+<p><a href="index.html">Back to the What's In A GIF index page.</a></p>
+</div>
+
+<p>In addition to being able to store simple image data, 
+GIF files (specifically GIF89a files) allow for some special features. Tricks
+such as transparency and animation can be accomplished with the 
+help of the Graphics Control Extension block. Here's a sample of what this
+block looks like:</p>
+
+<p style="text-align:center"><img src="graphic_control_ext.gif"
+alt="GIF graphics control ext block layout" style="border: 1px solid
+black" /></p>
+
+<p>I'll show you how to manipulate the bytes in this block to achieve
+special effects.</p>
+
+<h2><a name="animation">Animation</a></h2>
+
+<p>Cartoons are created by animators who draw a sequence of pictures,
+each slightly different from the one before, which, when rapidly shown
+one after the other, give the illusion of motion. Animation in GIF
+images is achieved in much the same way. Multiple images may be stored
+in the same file and you can tell the computer how much time to wait
+before showing the next image. Let's walk though the parts that make
+up this simple traffic light animation.
+</p>
+
+<p style="text-align:center"><img src="sample_2_animation.gif"
+alt="sample animated traffic light" / WIDTH="11" HEIGHT="29"></p>
+<p>
+
+<span class="byte gif_header"> 47 </span>
+<span class="byte gif_header"> 49 </span>
+<span class="byte gif_header"> 46 </span>
+<span class="byte gif_header"> 38 </span>
+<span class="byte gif_header"> 39 </span>
+<span class="byte gif_header"> 61 </span>
+<span class="byte gif_screen"> 0B </span>
+<span class="byte gif_screen"> 00 </span>
+<span class="byte gif_screen"> 1D </span>
+<span class="byte gif_screen"> 00 </span>
+<span class="byte gif_screen"> A2 </span>
+<span class="byte gif_screen"> 05 </span>
+<span class="byte gif_screen"> 00 </span>
+<span class="byte gif_color"> FF </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> FF </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> FF </span>
+<span class="byte gif_color"> FF </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 8E </span>
+<span class="byte gif_color"> 8E </span>
+<span class="byte gif_color"> 8E </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> FF </span>
+<span class="byte gif_color"> FF </span>
+<span class="byte gif_color"> FF </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_ext"> 21 </span>
+<span class="byte gif_ext"> FF </span>
+<span class="byte gif_ext"> 0B </span>
+<span class="byte gif_ext"> 4E </span>
+<span class="byte gif_ext"> 45 </span>
+<span class="byte gif_ext"> 54 </span>
+<span class="byte gif_ext"> 53 </span>
+<span class="byte gif_ext"> 43 </span>
+<span class="byte gif_ext"> 41 </span>
+<span class="byte gif_ext"> 50 </span>
+<span class="byte gif_ext"> 45 </span>
+<span class="byte gif_ext"> 32 </span>
+<span class="byte gif_ext"> 2E </span>
+<span class="byte gif_ext"> 30 </span>
+<span class="byte gif_ext"> 03 </span>
+<span class="byte gif_ext"> 01 </span>
+<span class="byte gif_ext"> 00 </span>
+<span class="byte gif_ext"> 00 </span>
+<span class="byte gif_ext"> 00 </span>
+<span class="byte gif_graphic"> 21 </span>
+<span class="byte gif_graphic"> F9 </span>
+<span class="byte gif_graphic"> 04 </span>
+<span class="byte gif_graphic"> 04 </span>
+<span class="byte gif_graphic"> 64 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_imgdesc"> 2C </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 0B </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 1D </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdata"> 03 </span>
+<span class="byte gif_imgdata"> 30 </span>
+<span class="byte gif_imgdata"> 48 </span>
+<span class="byte gif_imgdata"> BA </span>
+<span class="byte gif_imgdata"> DC </span>
+<span class="byte gif_imgdata"> DE </span>
+<span class="byte gif_imgdata"> 23 </span>
+<span class="byte gif_imgdata"> BE </span>
+<span class="byte gif_imgdata"> 48 </span>
+<span class="byte gif_imgdata"> 21 </span>
+<span class="byte gif_imgdata"> AD </span>
+<span class="byte gif_imgdata"> EB </span>
+<span class="byte gif_imgdata"> 62 </span>
+<span class="byte gif_imgdata"> A5 </span>
+<span class="byte gif_imgdata"> 25 </span>
+<span class="byte gif_imgdata"> D3 </span>
+<span class="byte gif_imgdata"> 93 </span>
+<span class="byte gif_imgdata"> F7 </span>
+<span class="byte gif_imgdata"> 8C </span>
+<span class="byte gif_imgdata"> E4 </span>
+<span class="byte gif_imgdata"> 27 </span>
+<span class="byte gif_imgdata"> 9A </span>
+<span class="byte gif_imgdata"> 1B </span>
+<span class="byte gif_imgdata"> D7 </span>
+<span class="byte gif_imgdata"> A1 </span>
+<span class="byte gif_imgdata"> 17 </span>
+<span class="byte gif_imgdata"> 9B </span>
+<span class="byte gif_imgdata"> 1E </span>
+<span class="byte gif_imgdata"> A0 </span>
+<span class="byte gif_imgdata"> F3 </span>
+<span class="byte gif_imgdata"> 96 </span>
+<span class="byte gif_imgdata"> 34 </span>
+<span class="byte gif_imgdata"> 13 </span>
+<span class="byte gif_imgdata"> DC </span>
+<span class="byte gif_imgdata"> CF </span>
+<span class="byte gif_imgdata"> AD </span>
+<span class="byte gif_imgdata"> 37 </span>
+<span class="byte gif_imgdata"> 7A </span>
+<span class="byte gif_imgdata"> 6F </span>
+<span class="byte gif_imgdata"> F7 </span>
+<span class="byte gif_imgdata"> B8 </span>
+<span class="byte gif_imgdata"> 05 </span>
+<span class="byte gif_imgdata"> 30 </span>
+<span class="byte gif_imgdata"> 28 </span>
+<span class="byte gif_imgdata"> F4 </span>
+<span class="byte gif_imgdata"> 39 </span>
+<span class="byte gif_imgdata"> 76 </span>
+<span class="byte gif_imgdata"> B5 </span>
+<span class="byte gif_imgdata"> 64 </span>
+<span class="byte gif_imgdata"> 02 </span>
+<span class="byte gif_imgdata"> 00 </span>
+<span class="byte gif_graphic"> 21 </span>
+<span class="byte gif_graphic"> F9 </span>
+<span class="byte gif_graphic"> 04 </span>
+<span class="byte gif_graphic"> 04 </span>
+<span class="byte gif_graphic"> 32 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_imgdesc"> 2C </span>
+<span class="byte gif_imgdesc"> 02 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 0B </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 07 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 10 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdata"> 03 </span>
+<span class="byte gif_imgdata"> 19 </span>
+<span class="byte gif_imgdata"> 78 </span>
+<span class="byte gif_imgdata"> 27 </span>
+<span class="byte gif_imgdata"> AC </span>
+<span class="byte gif_imgdata"> CB </span>
+<span class="byte gif_imgdata"> 0D </span>
+<span class="byte gif_imgdata"> CA </span>
+<span class="byte gif_imgdata"> 49 </span>
+<span class="byte gif_imgdata"> E1 </span>
+<span class="byte gif_imgdata"> B3 </span>
+<span class="byte gif_imgdata"> 0A </span>
+<span class="byte gif_imgdata"> BB </span>
+<span class="byte gif_imgdata"> CD </span>
+<span class="byte gif_imgdata"> F7 </span>
+<span class="byte gif_imgdata"> F8 </span>
+<span class="byte gif_imgdata"> CE </span>
+<span class="byte gif_imgdata"> 27 </span>
+<span class="byte gif_imgdata"> 1E </span>
+<span class="byte gif_imgdata"> 62 </span>
+<span class="byte gif_imgdata"> 69 </span>
+<span class="byte gif_imgdata"> 9E </span>
+<span class="byte gif_imgdata"> A3 </span>
+<span class="byte gif_imgdata"> 19 </span>
+<span class="byte gif_imgdata"> 82 </span>
+<span class="byte gif_imgdata"> 47 </span>
+<span class="byte gif_imgdata"> 02 </span>
+<span class="byte gif_imgdata"> 00 </span>
+<span class="byte gif_graphic"> 21 </span>
+<span class="byte gif_graphic"> F9 </span>
+<span class="byte gif_graphic"> 04 </span>
+<span class="byte gif_graphic"> 04 </span>
+<span class="byte gif_graphic"> 64 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_imgdesc"> 2C </span>
+<span class="byte gif_imgdesc"> 02 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 02 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 07 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 10 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdata"> 03 </span>
+<span class="byte gif_imgdata"> 19 </span>
+<span class="byte gif_imgdata"> 78 </span>
+<span class="byte gif_imgdata"> 07 </span>
+<span class="byte gif_imgdata"> AC </span>
+<span class="byte gif_imgdata"> CB </span>
+<span class="byte gif_imgdata"> 0D </span>
+<span class="byte gif_imgdata"> CA </span>
+<span class="byte gif_imgdata"> 49 </span>
+<span class="byte gif_imgdata"> E1 </span>
+<span class="byte gif_imgdata"> B3 </span>
+<span class="byte gif_imgdata"> 0A </span>
+<span class="byte gif_imgdata"> BB </span>
+<span class="byte gif_imgdata"> CD </span>
+<span class="byte gif_imgdata"> F7 </span>
+<span class="byte gif_imgdata"> F8 </span>
+<span class="byte gif_imgdata"> CE </span>
+<span class="byte gif_imgdata"> 27 </span>
+<span class="byte gif_imgdata"> 1E </span>
+<span class="byte gif_imgdata"> 62 </span>
+<span class="byte gif_imgdata"> 69 </span>
+<span class="byte gif_imgdata"> 9E </span>
+<span class="byte gif_imgdata"> A3 </span>
+<span class="byte gif_imgdata"> 19 </span>
+<span class="byte gif_imgdata"> 82 </span>
+<span class="byte gif_imgdata"> 47 </span>
+<span class="byte gif_imgdata"> 02 </span>
+<span class="byte gif_imgdata"> 00 </span>
+<span class="byte gif_trailer"> 3B </span>
+</p>
+
+<p>This file is similar to  the ones we've previously encountered. The
+bytes   start  out  with   the  GIF   header.  Next   we  have   a  <a
+href="bits_and_bytes.html#logical_screen_descriptor_block">logical
+screen descriptor</a> which  tells us that our image is  11px by 29 px
+and will have  a global color table  with 8 colors in it  (of which we
+only really need 5). Immediately after, follows the global color table
+which  tells  us what  those  colors  are  (0=red, 1=green,  2=yellow,
+3=light grey, 4=black, 5=white, 6=black [not used], 7=black [not used]
+).</p>
+
+<p>Next we encounter an <a
+href="bits_and_bytes.html#application_extension_block">application
+extension block</a>.  This is this block that causes our animation to
+repeat rather than play once and stop. The first three bytes tell us
+we are looking at (1) an extension block (2) of type
+&quot;application&quot; which is followed by (3) 11 bytes of fixed
+length data. These 11 bytes contain the ASCII character codes for
+&quot;NETSCAPE2.0&quot;. Then begins the actual &quot;application
+data&quot; which is contained in sub-blocks. There are two values that
+are stored in these sub-blocks. The first value is always the byte
+<span class="byte">01</span>. Then we have a value in the unsigned
+(lo-hi byte) format that says how many times the animation should
+repeat. You can see that our sample image has a value of 0; this means
+the animation should loop forever. These three bytes are preceded by
+the <span class="byte">03</span> that lets the decoder know that three
+bytes of data follow, and they are terminated by <span
+class="byte">00</span>, the block terminator.</p>
+
+<p>This very basic animation is essentially made up of three different
+&quot;scenes&quot;.  The first is the one with the green light lit,
+the second with the yellow, and the last with the red. You should be
+able to see three separate chunks of image data in the bytes
+above. </p>
+
+<table style="margin-left: auto;margin-right: auto">
+	<tr><th>1</th><th>2</th><th>3</th></tr>
+	<tr>
+	<td><img src="sample_2_animation_green.gif" alt="scene 1: green light" width="11" height="29"/></td>
+	<td><img src="sample_2_animation_yellow.gif" alt="scene 2: yellow light" width="11" height="29"/></td>
+	<td><img src="sample_2_animation_red.gif" alt="scene 3: red light" width="11" height="29"/></td>
+	</tr>
+</table>
+
+<p>The first chunk begins immediately after the application extension
+block.  It is there we encounter our first graphic control
+extension. As with all extensions, it begins with <span
+class="byte">21</span>. Next, the type specific label for the graphic
+control type of extension is <span class="byte">F9</span>. Next we see
+the byte size of the data in the block; this should always be <span
+class="byte">04</span>. The first of these four data blocks is a
+packed field. </p>
+
+<p>The packed field stores three values. The first three (highest)
+bits are &quot;reserved for future use&quot; so those have been left
+as zeros. The next three bits indicate the disposal method. The
+<em>disposal method</em> specifies what happens to the current image
+data when you move onto the next. We have three bits which means we
+can represent a number between 0 and 7. Our sample animated image has
+a value of 1 which tells the decoder to leave the image in place and
+draw the next image on top of it. A value of 2 would have meant that
+the canvas should be restored to the background color (as indicated by
+the logical screen descriptor). A value of 3 is defined to mean that
+the decoder should restore the canvas to its previous state before the
+current image was drawn. I don't believe that this value is widely
+supported but haven't had the chance to test it out. The behavior for
+values 4-7 are yet to be defined. If this image were not animated,
+these bits would have been set to 0 which indicates that do not wish
+to specify a disposal method. The seventh bit in they byte is the
+<em>user input flag</em>. When set to 1, that means that the decoder
+will wait for some sort of &quot;input&quot; from the person viewing
+the image before moving on to the next scene. I'm guessing it's highly
+unlikeley that you will encounter any other value that 0 for this bit.
+The final bit is the transparency flag. We will go into more detail
+about transparency in <a href="#transparency">the next
+section</a>. Since this image isn't using any transparency, we see
+this bit has been left at 0. </p>
+
+<p>The next two bytes are the delay time. This value is in the same
+unsigned lformat as all the other integers in the file. This number
+represents the number of hundredths of a second to wait before moving
+on to the next scene. We see that our sample image has specified
+a value of 100 (<span class="byte">64</span> <span class="byte">00</span>)
+in the first graphics control block which means we would wait 1 second 
+before changing our green light to yellow.</p>
+
+<p>Our graphics control extension block ends with the block
+terminator <span class="byte">00</span>. You will notice this
+type of block appearing two more times in this image, the second
+instance differing only in the delay time (the yellow light only 
+stays up for half a second).</p>
+
+<p>The next chunk is an image descriptor. The block declares that it
+will be drawing an image starting at the top left corner and taking up
+the whole canvas (11px x 29px). This block is followed by the image
+data that contains all the codes to draw the first scene, the one with
+the green light on.</p>
+
+<table style="margin-left: auto;margin-right: auto; text-align: center">
+	<tr><th>Green</th><th>(Difference)</th><th>Yellow</th></tr>
+	<tr>
+	<td><img src="sample_2_green_large.gif" alt="green light enlarged" width="33" height="87"/></td>
+	<td><img src="sample_2_green_yellow_diff.gif" alt="difference between green and yellow images"width="33" height="87"/></td>
+	<td><img src="sample_2_yellow_large.gif" alt="yellow light enlarged" width="33" height="87"/></td>
+	</tr>
+</table>
+
+<p>If we compare the first and the second scene, we see they share many
+of the same pixel color values. Rather than redrawing the whole canvas,
+we can specify just the part that changes (that is, the smallest
+rectangle that covers the part that changes). You'll see that the 
+image descriptor before the second block of image data specifies
+that it will start at the pixel at (2, 11) and draws a box that's 
+7px wide by 16px tall. This is just large enough to cover the bottom two
+lights. The works because we chose the &quot;do not dispose&quot; disposal
+method for out graphics control extension block. In the same way,
+the third and final image data block only renders the top two circles
+to both fill in the red and cover up the yellow.</p>
+	
+<h2><a name="transparency">Transparency</a></h2>
+
+<p>Normally, GIF images are rectangles that cover up what ever
+background may be beneath them. Transparency allows you to &quot;see
+though&quot; the image to whatever is below. This is a very simple
+trick to pull off in a GIF image. You can set up one color in your
+color table that is converted to &quot;invisible ink.&quot; Then, as
+the image is drawn, whenever this special color is encountered, the
+background is allowed to show through.</p>
+
+<p>There are only two pieces of data we have to set to pull this
+off. First we must set the Transparency Color Flag to 1. This is the
+lowest bit in the packed byte of the Graphic Control Extension. This
+will tell the decoder that we want our image to have a transparent
+component.  Secondly we must tell the decoder which color we want to
+use as our invisible ink. The decoder will then all you to see thought
+every pixel that contains this color. Therefore make sure it's not a
+color that you are using else where in your image. The color you
+choose must be in the active color table and you specify its value in
+the Transparent Color Index byte by setting this value to the index of
+the color in the color table.</p>
+
+<p>Let's demonstrate this by revisiting the sample image we used
+in <a href="bits_and_bytes.html">Bits and Bytes</a>. We will update this
+file to make the white center part transparent. Let's start creating
+the Graphic Control Extension block that will do this for us. Again we 
+start with the <span class="byte">21</span> <span class="byte">F9</span>
+<span class="byte">04</span> punch. In the next byte, we need to flip
+the transparent color flag to 1 (we can leave the others at zero) so 
+this whole byte is simply <span class="byte">01</span>. The next two 
+bytes can be left at zero.</p>
+
+<p>We must now specify which color to disappear.  Recall that our
+sample image had the following global color table:</p>
+
+<table style="margin-left: auto; margin-right: auto">
+	<tr><th>Index</th><th>Color</th></tr>
+	<tr><td>0</td><td><span style="color:#FFFFFF; background: #000000; font-weight: bold">White</span></td></tr>
+	<tr><td>1</td><td><span style="color:#FF0000; font-weight: bold">Red</span></td></tr>
+	<tr><td>2</td><td><span style="color:#0000FF; font-weight: bold">Blue</span></td></tr>
+	<tr><td>3</td><td><span style="font-weight: bold">Black</span></td></tr>
+</table>
+
+<p>We already know what we want to make all the white sections
+transparent.  The color white has an index of 0. Therefore we will
+specify a value of <span class="byte">00</span> for the transparent
+color index block.  Had we wanted to make the red transparent we would
+have used <span class="byte">01</span>, or <span
+class="byte">02</span> for blue.  Lastly we tack on the block
+terminator of <span class="byte">00</span> and we're done. We have
+created the following block:</p>
+
+<p>
+<span class="byte gif_graphic"> 21 </span>
+<span class="byte gif_graphic"> F9 </span>
+<span class="byte gif_graphic"> 04 </span>
+<span class="byte gif_graphic"> 01 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_graphic"> 00 </span>
+</p>
+
+<p>Now, all we have to do is plug this into our sample image right before the
+image descriptor. I've placed our original sample image on a black background
+as well as the one we just made so you can see the results. I've also included
+ones where red or blue are transparent. The last three differ by only the 
+transparent color index byte.</p>
+
+<table cellpadding="10px" style="text-align: center; margin-left: auto; margin-right: auto">
+<tr>
+<th style="width:25%">Original</th>
+<th style="width:25%">Transparent <br/>
+White (<span class="byte">00</span>)</th>
+<th style="width:25%">Transparent <br/>
+Red (<span class="byte">01</span>)</th>
+<th style="width:25%">Transparent <br/>
+Blue (<span class="byte">02</span>)</th>
+</tr>
+<tr>
+<td style="width:25%; background-color: black">
+<img src="sample_1.gif" alt="previous sample" width="10" height="10"/></td>
+<td style="width:25%; background-color: black">
+<img src="sample_1_trans.gif" alt="transparent white" width="10" height="10"/></td>
+<td style="width:25%; background-color: black">
+<img src="sample_1_trans_red.gif" alt="transparent red" width="10" height="10"/></td>
+<td style="width:25%; background-color: black">
+<img src="sample_1_trans_blue.gif" alt="transparent blue" width="10" height="10"/></td>
+</tr>
+</table>
+
+<p>This concludes our description of the bits inside GIFs.  If you
+have not already read the <a href="../gif_lib.html">documentation of
+the GIFLIB API</a>, you may wish to continue with that.</p>
+ 
+</div>
+
+<div style="text-align:center; margin-top: 10px; padding-top: 10px; border-top: #cecece 1px solid">
+<a href="../index.html">Back to GIFLIB documentation</a>
+</div>
+
+</body>
+
+</html>
diff --git a/doc/whatsinagif/bits_and_bytes.html b/doc/whatsinagif/bits_and_bytes.html
new file mode 100644
index 0000000..8be557f
--- /dev/null
+++ b/doc/whatsinagif/bits_and_bytes.html
@@ -0,0 +1,687 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html>
+<head>
+<title>What's In A GIF - Bits and Bytes</title>
+<script type="text/javascript"></script>
+<link rel="stylesheet" href="../proj.css" />
+<style type="text/css">
+.byte {font-family: Courier, fixed;
+	padding: .2em}
+.gif_header {background-color: #f9E89D}
+.gif_screen {background-color: #C8DBD9}
+.gif_color {background-color: #E1E1E1}
+.gif_graphic {background-color: #F9EB9D}
+.gif_imgdesc {background-color: #C2D1DC}
+.gif_imgdata {background-color: #D0C4C4}
+.gif_trailer {background-color: #f9E89D}
+.gif_ext {background-color: #D0CFAE}
+#global_color_size {margin-left: auto; margin-right:auto; border:1px solid black;}
+#global_color_size td {text-align:center;}
+</style>
+</head>
+<body>
+<table width='100%' cellpadding='0' summary='Canned page header' bgcolor="#ddd">
+<tr>
+<td><h2>What's In A GIF</h2></td>
+<td align="center"><img src="../giflib-logo.gif"></td>
+<td align="right">(Bits and bytes)</td>
+</tr>
+</table>
+
+<div id="body">
+<div style="text-align:center; margin-top: 10px; padding-top: 10px; border-top: #cecece 1px solid">
+<p><a href="index.html">Back to the What's In A GIF index page.</a></p>
+</div>
+
+<p>The authority on the content of GIFs is the <a
+href="../gif89.txt">GIF89a specification</a>. Originally developed at
+CompuServe in the late 1980s, it is now a W3C standard.</p>
+
+<p>A GIF file is made up of a sequence of data blocks.  The first two
+blocks are fixed length and fixed format. Later ones are variable
+length but self-describing; they consisting of a byte identifying the block
+type, followed by a payload length byte, followed by payload.</p>
+
+<p>The following railroad diagram shows all of the different types of
+blocks and where they can be in the file. Every path following the
+arrows corresponds to a valid block sequence. The large middle 
+secction, in particular, can be repeated any number of times.</p>
+
+<p style="text-align:center"><img src="gif_file_stream.gif" alt="GIF file stream diagram" style="border: 1px solid black" / WIDTH="700" HEIGHT="220"></p>
+
+<p>We will learn more by walking through a sample GIF file. You can
+see the sample file and its corresponding bytes below. </p>
+	
+<table>
+<tr>
+<td style="text-align:center; vertical-align: top; padding: 5px; width:20%"><h3>Actual Size</h3><img src="sample_1.gif" alt="sample gif, actual size" title="Actual Size" style="padding: 20px" / WIDTH="10" HEIGHT="10"><br/>(10x10)</td>
+<td style="text-align:center; vertical-align: top; padding: 5px;; width:20%"><h3>Enlarged</h3><img src="sample_1_enlarged.gif" alt="sample gif, enlarged" title="Enlarged" / WIDTH="100" HEIGHT="100"><br/>(100x100)</td>
+<td style="vertical-align: top; padding: 5px; width:60%"><h3>Bytes</h3>
+
+<span class="byte gif_header"> 47 </span>
+<span class="byte gif_header"> 49 </span>
+<span class="byte gif_header"> 46 </span>
+<span class="byte gif_header"> 38 </span>
+<span class="byte gif_header"> 39 </span>
+<span class="byte gif_header"> 61 </span>
+<span class="byte gif_screen"> 0A </span>
+<span class="byte gif_screen"> 00 </span>
+<span class="byte gif_screen"> 0A </span>
+<span class="byte gif_screen"> 00 </span>
+<span class="byte gif_screen"> 91 </span>
+<span class="byte gif_screen"> 00 </span>
+<span class="byte gif_screen"> 00 </span>
+<span class="byte gif_color"> FF </span>
+<span class="byte gif_color"> FF </span>
+<span class="byte gif_color"> FF </span>
+<span class="byte gif_color"> FF </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> FF </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_graphic"> 21 </span>
+<span class="byte gif_graphic"> F9 </span>
+<span class="byte gif_graphic"> 04 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_imgdesc"> 2C </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 0A </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 0A </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdata"> 02 </span>
+<span class="byte gif_imgdata"> 16 </span>
+<span class="byte gif_imgdata"> 8C </span>
+<span class="byte gif_imgdata"> 2D </span>
+<span class="byte gif_imgdata"> 99 </span>
+<span class="byte gif_imgdata"> 87 </span>
+<span class="byte gif_imgdata"> 2A </span>
+<span class="byte gif_imgdata"> 1C </span>
+<span class="byte gif_imgdata"> DC </span>
+<span class="byte gif_imgdata"> 33 </span>
+<span class="byte gif_imgdata"> A0 </span>
+<span class="byte gif_imgdata"> 02 </span>
+<span class="byte gif_imgdata"> 75 </span>
+<span class="byte gif_imgdata"> EC </span>
+<span class="byte gif_imgdata"> 95 </span>
+<span class="byte gif_imgdata"> FA </span>
+<span class="byte gif_imgdata"> A8 </span>
+<span class="byte gif_imgdata"> DE </span>
+<span class="byte gif_imgdata"> 60 </span>
+<span class="byte gif_imgdata"> 8C </span>
+<span class="byte gif_imgdata"> 04 </span>
+<span class="byte gif_imgdata"> 91 </span>
+<span class="byte gif_imgdata"> 4C </span>
+<span class="byte gif_imgdata"> 01 </span>
+<span class="byte gif_imgdata"> 00 </span>
+<span class="byte gif_trailer"> 3B </span>
+</td>
+</tr>
+</table>
+	
+<p>Note that not all possible block types are represented in this
+sample file. Later we'll provide samples of missing block types where
+appropriate. The different types of blocks include: <a
+href="#header_block">header</a>, <a
+href="#logical_screen_descriptor_block">logical screen descriptor</a>,
+<a href="#global_color_table_block">global color table</a>, <a
+href="#graphics_control_extension_block">graphics control
+extension</a>, <a href="#image_descriptor_block">image descriptor</a>,
+<a href="#local_color_table_block">local color table</a>, <a
+href="#image_data_block">image data</a>, <a
+href="#plain_text_extension_block">plain text extension</a>, <a
+href="#application_extension_block">application extension</a>, <a
+href="#comment_extension_block">comment extension</a>, and <a
+href="#trailer_block">trailer</a>.  Let's get started with the first
+block!</p>
+	
+<h2><a name="header_block">Header Block</a></h2>
+
+<p>From the sample file:
+<span class="byte gif_header"> 47 </span>
+<span class="byte gif_header"> 49 </span>
+<span class="byte gif_header"> 46 </span>
+<span class="byte gif_header"> 38 </span>
+<span class="byte gif_header"> 39 </span>
+<span class="byte gif_header"> 61 </span>
+</p>
+
+<p>All GIF files must start with a header block. The header takes up
+the first six bytes of the file. These bytes should all correspond to
+<a href="http://www.ascii.cl/">ASCII character codes</a>. The first
+three bytes are called the <strong>signature</strong>.  These should
+always be &quot;GIF&quot; (ie 47=&quot;G&quot;, 49=&quot;I&quot;,
+46=&quot;F&quot;). The next three specify the <strong>version</strong>
+of the specification that was used to encode the image.
+
+<p>Normally the version string will be either &quot;89a&quot; (ie
+38=&quot;8&quot;, 39=&quot;9&quot;,61=&quot;a&quot;) or &quot;87a&quot; (ie
+38=&quot;8&quot;, 37=&quot;7&quot;,61=&quot;a&quot;).  All modern
+GIF-processing software recognizes both versions, For maximum
+compatibility, GIFLIB will normally write an 87a signature unless the
+file contains GIF89 features.</p>
+
+<p style="text-align:center"><img src="header_block.gif" alt="GIF header block layout" style="border: 1px solid black" /></p>
+
+<h2><a name="logical_screen_descriptor_block">Logical Screen Descriptor</a></h2>
+<p>From Sample File: <span class="byte gif_screen"> 0A </span>
+<span class="byte gif_screen"> 00 </span><span class="byte gif_screen"> 0A </span><span class="byte gif_screen"> 00 </span><span class="byte gif_screen"> 91 </span><span class="byte gif_screen"> 00 </span><span class="byte gif_screen"> 00 </span></p>
+
+<p>The logical screen descriptor always immediately follows the
+header. This block tells the decoder how much room this image will
+take up. It is exactly seven bytes long. It starts with the
+<strong>canvas width</strong> and <strong>canvas height</strong>. 
+These value can be found in the first two pairs of two bytes each.
+Both are 16-bit, nonnegative integers (0-65,535).</p>
+
+<p>As with all the other multi-byte values in the GIF format, the
+least significant byte is stored first (little-endian format). This
+means where we would read <span class="byte"> 0A </span><span
+class="byte"> 00 </span> from the byte stream, we would normally write
+it as <span class="byte">000A</span> which is the same as 10. Thus the
+width of our sample image is 10 pixels. As a further example 255 would
+be stored as <span class="byte"> FF </span><span class="byte"> 00
+</span> but 256 would be <span class="byte"> 00 </span><span
+class="byte"> 01 </span>.</p>
+
+<p>The canvas width and height are usually ignored by modern viewers.
+The GIF format seems to have been designed with the idea that viewers
+would render multiple images in a GIF on a common canvas, giving an
+effect like a picture wall. But nowadays multiple-image GIFs are
+generally used either as animations in which each sub-image is a frame
+or as image libraries, with the GIF client handling compositing into
+some canvas about which the GIF format holds no information.Thus, the
+canvas width and height are mainly fossils. GIFLIB does extract them
+and allow you to set them, however.</p>
+
+<p>The next byte contains four fields of packed data, the "logical
+screen descriptor". To understand these, we need to expand the byte
+<span class="byte"> 91 </span> to binary as <span
+class="byte">10010001</span> and look at the fields inside it.</p>
+
+<p style="text-align:center"><img src="logical_screen_desc_block.gif" alt="GIF logical screen descriptor block layout" style="border: 1px solid black" /></p>
+
+<p>The first (most-significant) bit is the <strong>global color table
+flag</strong>. If it's 0, then there is no global color table. If it's
+1, then a global color table will follow. In our sample image, we can
+see that we will have a global color table (as will usually be the
+case).<p>
+
+<p>The next three bits are the <strong>color resolution</strong>. They
+are only meaningful if there is a global color table, and allow you to
+compute its size.  If the value of this field is N, the number of
+entries in the global color table will be 2 ^ (N+1) - that is, two
+raised to the power (N+1). Thus, the <span class="byte">001</span> in
+the sample image represents 2 bits/pixel; <span
+class="byte">111</span> would represent 8 bits/pixel.</p>
+
+<p>The GIF format shows its age here. A more modern design would
+simply have allocated a byte or two for color table length. But GIF 
+was designed when memory was much more expensive than it is today,
+and the designers felt strong pressure to economize on every bit.  
+The consequence is that color table lengths have to be an exact power
+of two. Perversely, this can force a waste of memory space in images
+with odd color counts.</p>
+
+<p>The next single bit is the <strong>sort flag</strong>. If the
+values is 1, then the colors in the global color table are sorted in
+order of &quot;decreasing importance,&quot; which typically means
+&quot;decreasing frequency&quot; in the image. This can help the image
+decoder, but is not required. In the sample file this value has been
+left at 0.</p>
+
+<p>The sort flag reflected the high cost of dual-port memory at the
+time the GIF specification was written in the late 1980s.  That kind
+of limit disappeared in the mid-1990s, and modern GIF software ignores
+this flag.  Until version 5.0, GIFLIB ignored it on input and zeroed
+it on output; 5.0 and later versions read and preserve it.</p>
+
+<p>The next byte gives us the <strong>background color
+index</strong>. This byte is only meaningful if the global color table
+flag is 1, and if there is no global color table, this byte should be
+0.. To understand it you have to remember the original "picture wall"
+rendering model for GIFs in which sub-images are composited onto a
+larger canvas.  It represents which index in the global color table
+should be used for pixels on the virtual canvas that aren't overlayed
+by an image. GIFLIB supports reading and setting this byte, but modern
+viewers and browsers generally have no use for it.</p>
+
+<p>The last byte of the logical screen descriptor is the <strong>pixel
+aspect ratio</strong>. Modern viewers don't use this.  Until 5.0,
+GIFLIB ignored this flag on input and zeroed it on output; now it is
+read and preserved if present. The GIF standard doesn't give a
+rationale for it, but it seems likely that the designers intended it
+for representing image captures from the analog television of the day,
+which had rectangular pixel-equivalents. The GIF specification says
+that if there was a value specified in this byte, N, the actual ratio
+used would be (N + 15) / 64 for all N&lt;&gt;0.</p>
+
+<h2><a name="global_color_table_block">Global Color Table</a></h2>
+
+<p>From the sample file: 
+<span class="byte gif_color"> FF </span>
+<span class="byte gif_color"> FF </span>
+<span class="byte gif_color"> FF </span>
+<span class="byte gif_color"> FF </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> FF </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+<span class="byte gif_color"> 00 </span>
+</p>
+
+<p>GIFs can have either a <strong>global color table</strong> or local
+color tables for each sub-image.  Each color table consists of a list
+of RGB (Red-Green-Blue) color component intensities, three bytes for
+each color, with intensities ranging from 0 (least) to 255 (most). The
+color (0,0,0) is deepest black, the color (255,255,255) brightest
+white. The other extreme colors are red at (255,0,0), green at
+(0,255,0) and blue at (0,0,255).</p>
+
+<p>As previously noted, the length of the global color table is
+2^(N+1) entries where N is the value of the color depth field in the
+logical screen descriptor. The table will take up 3*2^(N+1) bytes in
+the stream.</p>
+
+<div style="text-align:center">
+<table id="global_color_size">
+<tr><th>Size In Logical<br/>Screen Desc</th><th>Number Of<br/>Colors</th><th>Byte<br/>Length</th></tr>
+<tr><td>0</td><td>2</td><td>6</td></tr>
+<tr><td>1</td><td>4</td><td>12</td></tr>
+<tr><td>2</td><td>8</td><td>24</td></tr>
+<tr><td>3</td><td>16</td><td>48</td></tr>
+<tr><td>4</td><td>32</td><td>96</td></tr>
+<tr><td>5</td><td>64</td><td>192</td></tr>
+<tr><td>6</td><td>128</td><td>384</td></tr>
+<tr><td>7</td><td>256</td><td>768</td></tr>
+</table>
+</div>
+
+<p>Our sample file has a global color table size of 1. This means it
+holds 2^(1+1)=2^2=4 colors.  We can see that it takes up 12, (3*4),
+bytes as expected. We read the bytes three at a time to get each of
+the colors. The first color is #FFFFFF (white). This value is given an
+index of 0.  The second color is #FF0000 (red). The color with an
+index value of 2 is #0000FF (blue).  The last color is #000000
+(black). The index numbers will be important when we decode the actual
+image data.</p>
+
+<p>Note that this block is labeled as &quot;optional.&quot; Not every
+GIF has to specify a global color table. However, if the global color
+table flag is set to 1 in the logical screen descriptor block, the
+color table is then required to immediately follow that block.
+</p>
+
+<p style="text-align:center"><img src="global_color_table.gif" alt="GIF global color table block layout" style="border: 1px solid black" /></p>	
+
+<h2><a name="graphics_control_extension_block">Graphics Control Extension</a></h2>
+
+<p>From the sample file: 
+<span class="byte gif_graphic"> 21</span>
+<span class="byte gif_graphic"> F9 </span>
+<span class="byte gif_graphic"> 04 </span>
+<span class="byte gif_graphic"> 00</span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_graphic"> 00 </span>
+<span class="byte gif_graphic"> 00</span>
+<span class="byte gif_graphic"> 00 </span>
+</p>
+
+<p>Graphic control extension blocks are used to specify transparency
+settings and control animations. They are an optional GIF89 extension.
+The semantics of this extension will be described in detail in a later section
+(see <a href="animation_and_transparency.html">Transparency and Animation</a>); 
+for completeness we'll describe the data fields here.</p>
+
+<p>The first byte is the <strong>extension introducer</strong>. All
+<em>extension</em> blocks begin with <span
+class="byte">21</span>. Next is the <strong>graphic control
+label</strong>, <span class="byte">F9</span>, which is the value that
+flags this as a graphic control extension. Third up is the total
+<strong>block size</strong> in bytes. Next is a packed field. Bits 1-3
+are reserved for future use. Bits 4-6 indicate <strong>disposal
+method</strong>. The penultimate bit is the <strong>user input
+flag</strong> and the last is the <strong>transparent color
+flag</strong>. The <strong>delay time</strong> value follows in the
+next two bytes stored in unsigned format. After that we have the
+<strong>transparent color index</strong> byte. Finally we have the
+<strong>block terminator</strong> which is always <span
+class="byte">00</span>.</p>
+
+<p style="text-align:center"><img src="graphic_control_ext.gif"
+alt="GIF graphic control extension block layout" style="border: 1px
+solid black" /></p>
+	
+<h2><a name="image_descriptor_block">Image Descriptor</a></h2>
+
+<p>From the sample file: 
+
+<span class="byte gif_imgdesc"> 2C </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 0A </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 0A </span>
+<span class="byte gif_imgdesc"> 00 </span>
+<span class="byte gif_imgdesc"> 00 </span>
+</p>
+
+<p>A single GIF file may contain multiple images.  In the original GIF
+rendering model these wwere meant to be composited onto a larger
+virtual canvas. Nowadays nultiple images are normally used for animations.</p>
+
+<p>Each image begins with an image descriptor block. This block is
+exactly 10 bytes long.</p>
+
+<p>The first byte is the <strong>image separator</strong>. Every image
+descriptor begins with the value <span class="byte">2C</span>. The
+next 8 bytes represent the location and size of the following
+image.</p>
+
+<p>An image in the stream may not necessarily take up the entire
+canvas size defined by the logical screen descriptor. Therefore, the
+image descriptor specifies the <strong>image left position</strong>
+and <strong>image top position</strong> of where the image should
+begin on the canvas. Both these fields are usually ignored by modern
+viewers and browsers.</p>
+
+<p>Next, this block specifies the <strong>image width</strong> and
+<strong>image height</strong>. Each of these values is in the
+two-byte, unsigned little-endian format. Our sample image indicates
+that the image starts at (0,0) and is 10 pixels wide by 10 pixels
+tall. (This image does take up the whole canvas size.)</p>
+
+<p>The last byte is another packed field. In our sample file this byte is 0 so
+all of the sub-values will be zero. The first (most significant) bit in 
+the byte is the <strong>local color table flag</strong>. Setting this flag
+to 1 allows you to specify that the image data that follows uses a different
+color table than the global color table. (More information on the local
+color table follows.)</p>
+
+<p>The second bit is the <strong>interlace flag</strong>. Interlacing
+changes the way images are rendered onto the screen in a way that may
+reduce annoying visual flicker. The effect of interlacing on a display
+is that the first pass of appears immediately, displaying the graphic
+as a first as a blur and then sharpenining it up as later passes fill
+in lines. That allows the human viewer to at least get an idea of
+what's coming up rather than waiting for the entire image to be
+painted, line by line. <a
+href="http://webtutor.tamu.edu/lesson6/interlace.html">See an
+example</a>.  To support this, the scan lines of the image need to be
+stored in a different order than the normal top-down, separated into
+sections that will be rendered in four separate passes.</p>
+
+<p style="text-align:center"><img src="image_descriptor_block.gif"
+alt="GIF image descriptor block layout" style="border: 1px solid
+black" /></p>
+
+<h2><a name="local_color_table_block">Local Color Table</a></h2>
+<p>A local color table is organized the same as a global color table. The local
+color table would always immediately follow an image descriptor but will only
+be there if the local color table flag is set to 1. It is effective only for the
+block of image data that immediately follows it. If no local color table
+is specified, the global color table is used for the following image data.</p>
+
+<p>The size of the local color table can be calculated by the value
+given in the image descriptor. Just like with the global color table,
+if the image descriptor specifies a size of N, the color table will
+contain 2^(N+1) colors and will take up 3*2^(N+1) bytes.</p>
+
+<h2><a name="image_data_block">Image Data</a></h2>
+
+<p>From the sample file:
+<span class="byte gif_imgdata"> 02 </span>
+<span class="byte gif_imgdata"> 16 </span>
+<span class="byte gif_imgdata"> 8C </span>
+<span class="byte gif_imgdata"> 2D </span>
+<span class="byte gif_imgdata"> 99 </span>
+<span class="byte gif_imgdata"> 87 </span>
+<span class="byte gif_imgdata"> 2A </span>
+<span class="byte gif_imgdata"> 1C </span>
+<span class="byte gif_imgdata"> DC </span>
+<span class="byte gif_imgdata"> 33 </span>
+<span class="byte gif_imgdata"> A0 </span>
+<span class="byte gif_imgdata"> 02 </span>
+<span class="byte gif_imgdata"> 75 </span>
+<span class="byte gif_imgdata"> EC </span>
+<span class="byte gif_imgdata"> 95 </span>
+<span class="byte gif_imgdata"> FA </span>
+<span class="byte gif_imgdata"> A8 </span>
+<span class="byte gif_imgdata"> DE </span>
+<span class="byte gif_imgdata"> 60 </span>
+<span class="byte gif_imgdata"> 8C </span>
+<span class="byte gif_imgdata"> 04 </span>
+<span class="byte gif_imgdata"> 91 </span>
+<span class="byte gif_imgdata"> 4C </span>
+<span class="byte gif_imgdata"> 01 </span>
+<span class="byte gif_imgdata"> 00 </span></p>
+
+<p>Finally we get to the actual image data. The image data is composed of
+a series of output codes which tell the decoder which colors to emit
+to the canvas. These codes are combined into the bytes that make up
+the block.</p>
+
+<p>There's another section on decoding these output code into an image
+(see <a href="lzw_image_data.html">LZW Image Data</a>).  Here we'll 
+just see how to determine how long the block will be. </p>
+
+<p>The first byte of this block is the <strong>LZW minimum code
+size</strong>.  This value is used to decode the compressed output
+codes. (Again, see the section on <a href="lzw_image_data.html">LZW
+compression</a> to see how this works.)  The rest of the bytes
+represent <em>data sub-blocks</em>. Data sub-blocks are are groups of
+1 - 256 bytes. The first byte in the sub-block tells you how many
+bytes of actual data follow. This can be a value from 0 (<span
+class="byte">00</span>) it 255 (<span class="byte">FF</span>). After
+you've read those bytes, the next byte you read will tell you now many
+more bytes of data follow that one. You continue to read until you
+reach a sub-block that says that zero bytes follow.
+</p>
+
+<p>You can see our sample file has a LZW minimum code size of 2. The
+next byte tells us that 22 bytes of data follow it (<span
+class="byte">16</span> hex = 22).  After we've read those 22 bytes, we
+see the next value is 0. This means that no bytes follow and we have
+read all the data in this block.</p>
+
+<p style="text-align:center"><img src="image_data_block.gif" alt="GIF image data block layout" style="border: 1px solid black" /></p>
+
+<h2><a name="plain_text_extension_block">Plain Text Extension</a></h2>
+<p>Example (not in the sample file):
+
+<span class="byte gif_ext"> 21 </span>
+<span class="byte gif_ext"> 01 </span>
+<span class="byte gif_ext"> 0C </span>
+<span class="byte gif_ext"> 00 </span>
+<span class="byte gif_ext"> 00 </span>
+<span class="byte gif_ext"> 00 </span>
+<span class="byte gif_ext"> 00 </span>
+<span class="byte gif_ext"> 64 </span>
+<span class="byte gif_ext"> 00 </span>
+<span class="byte gif_ext"> 64 </span>
+<span class="byte gif_ext"> 00 </span>
+<span class="byte gif_ext"> 14 </span>
+<span class="byte gif_ext"> 14 </span>
+<span class="byte gif_ext"> 01 </span>
+<span class="byte gif_ext"> 00 </span>
+<span class="byte gif_ext"> 0B </span>
+<span class="byte gif_ext"> 68 </span>
+<span class="byte gif_ext"> 65 </span>
+<span class="byte gif_ext"> 6C </span>
+<span class="byte gif_ext"> 6C </span>
+<span class="byte gif_ext"> 6F </span>
+<span class="byte gif_ext"> 20 </span>
+<span class="byte gif_ext"> 77 </span>
+<span class="byte gif_ext"> 6F </span>
+<span class="byte gif_ext"> 72 </span>
+<span class="byte gif_ext"> 6C </span>
+<span class="byte gif_ext"> 64 </span>
+<span class="byte gif_ext"> 00 </span></p>
+
+<p>The GIF89 specification allows you to specify text captions to be
+overlayed on the following image.  This feature never took off; 
+browsers and image-processing applications such as Photoshop ignore
+it, and GIFLIB doesn't try to interpret it.</p>
+
+<p>The block begins with an <strong>extension introducer</strong> as all
+extension block types do. This value is always <span class="byte">21</span>.
+The next byte is the <strong>plain text label</strong>. This value of
+<span class="byte">01</span> is used to distinguish plain text extensions
+from all other extensions. The next byte is the <strong>block size</strong>.
+This tells you how many bytes there are until the actual text data begins, or
+in other words, how many bytes you can now skip. The byte value will probably be
+<span class="byte">0C</span> which means you should jump forward 12 bytes. The
+text that follows is encoded in data sub-blocks 
+(see <a href="#image_data_block">Image Data</a> to see how
+these sub-blocks are formed). The block ends when you reach a sub-block of
+length 0.</p>
+
+<h2><a name="application_extension_block">Application Extension</a></h2>
+<p>Example (not in sample file): 
+<span class="byte gif_ext"> 21 </span>
+<span class="byte gif_ext"> FF </span>
+<span class="byte gif_ext"> 0B </span>
+<span class="byte gif_ext"> 4E </span>
+<span class="byte gif_ext"> 45 </span>
+<span class="byte gif_ext"> 54 </span>
+<span class="byte gif_ext"> 53 </span>
+<span class="byte gif_ext"> 43 </span>
+<span class="byte gif_ext"> 41 </span>
+<span class="byte gif_ext"> 50 </span>
+<span class="byte gif_ext"> 45 </span>
+<span class="byte gif_ext"> 32 </span>
+<span class="byte gif_ext"> 2E </span>
+<span class="byte gif_ext"> 30 </span>
+<span class="byte gif_ext"> 03 </span>
+<span class="byte gif_ext"> 01 </span>
+<span class="byte gif_ext"> 05 </span>
+<span class="byte gif_ext"> 00 </span>
+<span class="byte gif_ext"> 00 </span>
+</p>
+
+<p>The GIF89 specification allows for application-specific information
+to be embedded in the GIF file itself. This capability is not much
+used.  About the only known public one is the Netscape 2.0</a>
+extension (described below) which is used to loop an animated GIF
+file. We'll go into more detail on looping in when we talk about <a
+href="animation_and_transparency.html">animation</a>.</p>
+
+<p>The Netscape 2.0 looping block must appear immediately after the
+global color table of the logical screen descriptor.  It is
+19 bytes long.
+
+<pre>
+byte  1        : 33 (hex 0x21) GIF Extension code
+byte  2        : 255 (hex 0xFF) Application Extension Label
+byte  3        : 11 (hex 0x0B) Length of Application Block
+                 (eleven bytes of data to follow)
+bytes 4 to 11  : "NETSCAPE"
+bytes 12 to 14 : "2.0"
+byte  15       : 3 (hex 0x03) Length of Data Sub-Block
+                 (three bytes of data to follow)
+byte  16       : 1 (hex 0x01)
+bytes 17 to 18 : 0 to 65535, an unsigned integer in
+                 little-endian byte format. This specifies the
+                 number of times the loop should
+                 be executed.
+byte  19       : 0 (hex 0x00) a Data Sub-Block Terminator.
+</pre>
+</p>
+
+<p>As with all extensions, we start with <span class="byte">21</span>
+which is the <strong>extension introducer</strong>. Next is the
+<strong>extension label</strong> which for application extensions is
+<span class="byte">FF</span>. The next value is the <strong>block
+size</strong> which tells you how many bytes there are before the
+actual application data begins. This byte value should be <span
+class="byte">0B</span> which indicates 11 bytes. These 11 bytes hold
+two pieces of information. First is the <strong>application
+identifier</strong> which takes up the first 8 bytes. These bytes
+should contain ASCII character codes that identify to which
+application the extension belongs. In the case of the example above,
+the application identifier is &quot;NETSCAPE&quot; which is
+conveniently 8 characters long. The next three bytes are the
+<strong>application authentication code</strong>. The spec says these
+bytes can be used to &quot;authenticate the application
+identifier.&quot; With the Netscape 2.0 extension, this value is simply
+a version number, &quot;2.0&quot;, hence the extensions name. What
+follows is the application data broken into data sub-blocks. As with
+the other extensions, the block terminates when you read a sub-block
+that has zero bytes of data.</p>
+
+<h2><a name="comment_extension_block">Comment Extension</a></h2>
+
+<p>Example (not in sample file): 
+<span class="byte gif_ext"> 21 </span>
+<span class="byte gif_ext"> FE </span>
+<span class="byte gif_ext"> 09 </span>
+<span class="byte gif_ext"> 62 </span>
+<span class="byte gif_ext"> 6C </span>
+<span class="byte gif_ext"> 75 </span>
+<span class="byte gif_ext"> 65 </span>
+<span class="byte gif_ext"> 62 </span>
+<span class="byte gif_ext"> 65 </span>
+<span class="byte gif_ext"> 72 </span>
+<span class="byte gif_ext"> 72 </span>
+<span class="byte gif_ext"> 79 </span>
+<span class="byte gif_ext"> 00 </span></p>
+
+<p>One last GIF89 extension type is the comment extension. This allows you
+to embed ASCII text in a GIF file, and is sometimes used to include an
+image description, image credit, or other human-readable metadata such as
+the GPS location of the image capture.</p>
+
+<p>It's probably no surprise by now that the first byte is the
+<strong>extension introducer</strong> which is <span
+class="byte">21</span>. The next byte is always <span
+class="byte">FE</span> which is the <strong>comment label</strong>.
+Then we jump right to data sub-blocks containing ASCII character codes
+for your comment. As you can see from the example we have one data
+sub-block that is 9 bytes long. If you translate the character codes
+you see that the comment is &quot;blueberry.&quot; The final byte,
+<span class="byte">00</span>, indicates a sub-block with zero bytes
+that follow which let's us know we have reached the end of the block.</p>
+
+<p style="text-align:center"><img src="comment_ext.gif" alt="GIF comment extension block layout" style="border: 1px solid black" /></p>
+
+<h2><a name="trailer_block">Trailer</a></h2>
+
+<p>From sample file: <span class="byte gif_trailer"> 3B </span></p>
+
+<p>The trailer block indicates when you've reached the end of the file.
+It is always a byte with a value of <span class="byte">3B</span>.</p>
+
+<p style="text-align:center"><img src="trailer_block.gif" alt="GIF
+trailer block layout" style="border: 1px solid black" /></p>
+
+<h2>Next: LZW Image Data</h2>
+
+<p>Now that you know what the basic parts of a GIF file are, let's next
+focus our attention on how the actual image data is stored and compressed.<p>
+
+<p><a href="lzw_image_data.html">Continue...</a></p>
+</div>
+
+<div style="text-align:center; margin-top: 10px; padding-top: 10px; border-top: #cecece 1px solid">
+<a href="../index.html">Back to GIFLIB documentation</a>
+</div>
+
+</body>
+</html>
diff --git a/doc/whatsinagif/comment_ext.gif b/doc/whatsinagif/comment_ext.gif
new file mode 100644
index 0000000..4c655a4
Binary files /dev/null and b/doc/whatsinagif/comment_ext.gif differ
diff --git a/doc/whatsinagif/gif_file_stream.gif b/doc/whatsinagif/gif_file_stream.gif
new file mode 100644
index 0000000..252d9fa
Binary files /dev/null and b/doc/whatsinagif/gif_file_stream.gif differ
diff --git a/doc/whatsinagif/global_color_table.gif b/doc/whatsinagif/global_color_table.gif
new file mode 100644
index 0000000..702bd20
Binary files /dev/null and b/doc/whatsinagif/global_color_table.gif differ
diff --git a/doc/whatsinagif/graphic_control_ext.gif b/doc/whatsinagif/graphic_control_ext.gif
new file mode 100644
index 0000000..49c7621
Binary files /dev/null and b/doc/whatsinagif/graphic_control_ext.gif differ
diff --git a/doc/whatsinagif/header_block.gif b/doc/whatsinagif/header_block.gif
new file mode 100644
index 0000000..bb14cbc
Binary files /dev/null and b/doc/whatsinagif/header_block.gif differ
diff --git a/doc/whatsinagif/image_data_block.gif b/doc/whatsinagif/image_data_block.gif
new file mode 100644
index 0000000..8cfea30
Binary files /dev/null and b/doc/whatsinagif/image_data_block.gif differ
diff --git a/doc/whatsinagif/image_descriptor_block.gif b/doc/whatsinagif/image_descriptor_block.gif
new file mode 100644
index 0000000..18721e3
Binary files /dev/null and b/doc/whatsinagif/image_descriptor_block.gif differ
diff --git a/doc/whatsinagif/index.html b/doc/whatsinagif/index.html
new file mode 100644
index 0000000..93f4946
--- /dev/null
+++ b/doc/whatsinagif/index.html
@@ -0,0 +1,46 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html>
+<head>
+<title>What's In A GIF</title>
+</head>
+<body>
+<table width='100%' cellpadding='0' summary='Canned page header' bgcolor="#ddd">
+<tr>
+<td><h2>What's In A GIF</h2></td>
+<td align="center"><img src="../giflib-logo.gif"></td>
+<td align="right">(main page)</td>
+</tr>
+</table>
+
+<div id="body">
+
+<p>These pages explain down
+to the bit level what's inside a GIF, and are offered in the hope they
+will be useful to programmers using GIFLIB.</p>
+
+<p>The explanation is in three parts:<p>
+
+<ol>
+<li><a href="bits_and_bytes.html">Bits and Bytes</a> - first we look at the
+file format that makes up a GIF file</li>
+<li><a href="lzw_image_data.html">LZW Image Data</a> - a closer 
+look at how image data is compressed within a GIF file</li>
+<li><a href="animation_and_transparency.html">Transparency and Animation</a> - 
+how some of the more advanced features of GIF files work</li>
+</ol>
+</div>
+
+<p>Due credit: much of this material was written by one Mike
+Flickinger in 2005, though it has been significantly revised and
+expanded for GIFLIB. The illustrations are all his.</p>
+
+</div>
+
+<div style="text-align:center; margin-top: 10px; padding-top: 10px; border-top: #cecece 1px solid">
+<a href="../index.html">Back to GIFLIB documentation</a>
+</div>
+
+</body>
+
+</html>
+
diff --git a/doc/whatsinagif/logical_screen_desc_block.gif b/doc/whatsinagif/logical_screen_desc_block.gif
new file mode 100644
index 0000000..73f69ce
Binary files /dev/null and b/doc/whatsinagif/logical_screen_desc_block.gif differ
diff --git a/doc/whatsinagif/lzw_decoding_bytes.gif b/doc/whatsinagif/lzw_decoding_bytes.gif
new file mode 100644
index 0000000..79a6df8
Binary files /dev/null and b/doc/whatsinagif/lzw_decoding_bytes.gif differ
diff --git a/doc/whatsinagif/lzw_encoding_codes.gif b/doc/whatsinagif/lzw_encoding_codes.gif
new file mode 100644
index 0000000..48aa814
Binary files /dev/null and b/doc/whatsinagif/lzw_encoding_codes.gif differ
diff --git a/doc/whatsinagif/lzw_image_data.html b/doc/whatsinagif/lzw_image_data.html
new file mode 100644
index 0000000..419b2a1
--- /dev/null
+++ b/doc/whatsinagif/lzw_image_data.html
@@ -0,0 +1,1101 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+
+<html>
+<head>
+<title>What's In A GIF - LZW Image Data</title>
+<style type="text/css">
+.byte {font-family: Courier, fixed;
+	padding: .2em}
+.gif_header {background-color: #f9E89D}
+.gif_screen {background-color: #C8DBD9}
+.gif_color {background-color: #E1E1E1}
+.gif_graphic {background-color: #F9EB9D}
+.gif_imgdesc {background-color: #C2D1DC}
+.gif_imgdata {background-color: #D0C4C4}
+.gif_trailer {background-color: #f9E89D}
+.gif_ext {background-color: #D0CFAE}
+#global_color_size {margin-left: auto; margin-right:auto; border:1px solid black;}
+#global_color_size th {border-bottom: 1px solid #666666}
+#global_color_size td {text-align:center;}
+.code_table {margin-left: auto; margin-right:auto; border:1px solid black;}
+.code_table th {text-align: left; border-bottom: 1px solid #666666}
+.alg_steps {margin: 0 auto; border: 1px solid black}
+.alg_steps th, .alg_steps td {border: 1px solid black}
+.alg_steps .index {padding: 0 .3em}
+.alg_steps .processed {color: #CCC}
+.alg_steps .buffer {background-color: #c0efc0; border-top: 1px solid #c0efc0; border-bottom: 1px solid #c0efc0;}
+.alg_steps .current {background-color: #e0d0e0; border-top: 1px solid #e0d0e0; border-bottom: 1px solid #e0d0e0;}
+</style>
+</head>
+<body>
+<table width='100%' cellpadding='0' summary='Canned page header' bgcolor="#ddd">
+<tr>
+<td><h2>What's In A GIF</h2></td>
+<td align="center"><img src="../giflib-logo.gif"></td>
+<td align="right">(LZW image data)</td>
+</tr>
+</table>
+
+<div id="body">
+<div style="text-align:center; margin-top: 10px; padding-top: 10px; border-top: #cecece 1px solid">
+<p><a href="index.html">Back to the GIF index page.</a></p>
+</div>
+
+<p>Now let's look at exactly how we go about storing an image in a GIF
+file. The GIF format is a raster format, meaning it stores image data
+by remembering the color of every pixel in the image. More
+specifically, GIF files remember the index of the color in a color
+table for each pixel. To make that clearer, let's review the
+sample image we used in the <a href="bits_and_bytes.html">first
+section</a>.</p>
+
+<table style="margin-left: auto; margin-right:auto;">
+<tr>
+<td style="text-align:center; vertical-align: top; padding: 5px;width:30%">
+<h3>Actual Size</h3>
+<img src="sample_1.gif" alt="sample gif, actual size" title="Actual Size"
+width="10" height="10" style="padding: 20px" /><br/>(10x10)</td>
+<td style="text-align:center; vertical-align: top; padding: 5px;; width:40%">
+<h3>Enlarged</h3>
+<img src="sample_1_enlarged.gif" alt="sample gif, enlarged"
+title="Enlarged" width="100" height="100" /><br/>(100x100)</td>
+<td style="vertical-align: top; padding: 5px; width:30%">
+<h3>Color Table</h3>
+<table>
+<tr><th>Index</th><th>Color</th></tr>
+<tr><td>0</td><td><span style="color:#FFFFFF; background: #000000; font-weight: bold">White</span></td></tr>
+<tr><td>1</td><td><span style="color:#FF0000; font-weight: bold">Red</span></td></tr>
+<tr><td>2</td><td><span style="color:#0000FF; font-weight: bold">Blue</span></td></tr>
+<tr><td>3</td><td><span style="font-weight: bold">Black</span></td></tr>
+</table>
+</td>
+</tr></table>
+
+<p>The color table came from the global color table block. The colors
+are listed in the order which they appear in the file. The first color
+is given an index of zero. When we send the codes, we always start at
+the top left of the image and work our way right. When we get to the
+end of the line, the very next code is the one that starts the next
+line. (The decoder will &quot;wrap&quot; the image based on the image
+dimensions.) We could encode our sample image in the following
+way:</p>
+
+<blockquote><p>1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1,
+1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 1, 1, 1,
+0, 0, 0, 0, 2, 2, 2, ...</p></blockquote>
+
+<p>The above listing shows the sequence required to render the first five
+lines of the image. We could continue with this method until we've
+specified the color for every pixel; however, this can result in a
+rather large file. Luckily for us, the GIF format allows us to take
+advantage of repetition in our output and to compress our data.</p>
+
+<p>Much of the following information came from John Barkaus's tutorial
+<cite>LZW and GIF Explained</cite>, which seems to have fallen off the
+web.  I've tried to provide more detailed samples as well
+as illustrations to make the process even clearer</p>
+
+<h2><a name="lzw_compression">LZW Compression</a></h2>
+
+<p>The compression method GIF use is a variant of LZW
+(Lempel-Ziv-Welch) compression. To start using this method, we need a
+<strong>code table</strong>. This code table will allow us to use
+special codes to indicate a sequence of colors rather than just one at
+a time.  The first thing we do is to <em>initialize the code
+table</em>.  We start by adding a code for each of the colors in the
+color table. This would be a local color table if one was provided, or
+the global color table. (I will be starting all codes with
+&quot;#&quot; to distinguish them from color indexes.)</p>
+
+<table class="code_table">
+<tr><th>Code</th><th>Color(s)</th></tr>
+<tr><td>#0</td><td>0</td></tr>
+<tr><td>#1</td><td>1</td></tr>
+<tr><td>#2</td><td>2</td></tr>
+<tr><td>#3</td><td>3</td></tr>
+<tr><td>#4</td><td>Clear Code</td></tr>
+<tr><td>#5</td><td>End Of Information Code</td></tr>
+</table>
+
+<p>I added a code for each of the colors in the global color table of
+our sample image. I also snuck in two special control codes.  (These
+special codes are only used in the GIF version of LZW, not in standard
+LZW compression.) Our code table is now considered initialized.</p>
+
+<p>Let me now explain what those special codes are for. The first new code 
+is the <em>clear code</em> (CC). Whenever you come across the clear code 
+in the image data, it's your cue to reinitialize the code table. (I'll 
+explain why you might need to do this in a bit.) The second new code 
+is the <em>end of information code</em> (EOI). When you come across 
+this code, this means you've reached the end of the image. Here I've placed
+the special codes right after the color codes, but actually the value of
+the special codes depends on the value of the LZW minimum code size
+from the image data block. If the LZW minimum code size is the same as
+the color table size, then special codes immediatly follow the colors; however
+it is possible to specify a larger LZW minimum code size which may leave
+a gap in the codes where no colors are assigned. This can be
+summarizaed in the <a name="color_table_size">following table</a>.</p>
+
+<div style="text-align:center">
+<table id="global_color_size">
+<tr><th>LZW Min Code<br/>Size</th><th>Color<br/>Codes</th><th>Clear<br/>Code</th><th>EOI<br/>Code</th></tr>
+<tr><td>2</td><td>#0-#3</td><td>#4</td><td>#5</td></tr>
+<tr><td>3</td><td>#0-#7</td><td>#8</td><td>#9</td></tr>
+<tr><td>4</td><td>#0-#15</td><td>#16</td><td>#17</td></tr>
+<tr><td>5</td><td>#0-#31</td><td>#32</td><td>#33</td></tr>
+<tr><td>6</td><td>#0-#63</td><td>#64</td><td>#65</td></tr>
+<tr><td>7</td><td>#0-#127</td><td>#128</td><td>#129</td></tr>
+<tr><td>8</td><td>#0-#255</td><td>#256</td><td>#257</td></tr>
+</table>
+</div>
+
+<p>Before we proceed, let me define two more terms. First the <strong>index 
+stream</strong> will be the list of indexes of the color for each of 
+the pixels. This is the input we will be compressing. The <strong>code 
+stream</strong> will be the list of codes we generate as output. The
+<strong>index buffer</strong> will be the list of color indexes
+we care &quot;currently looking at.&quot; The index buffer will contain a list
+of one or more color indexes. Now we can step though the LZW 
+compression algorithm. First, I'll just list the steps. After that
+I'll walk through the steps with our specific example.</p>
+
+<ul>
+<li>Initialize code table</li>
+<li>Always start by sending a clear code to the code stream.</li>
+<li>Read first index from index stream. This value is now the value
+for the index buffer</li>
+<li>&lt;LOOP POINT&gt;</li>
+<li>Get the next index from the index stream to the index buffer. We will
+call this index, K</li>
+<li>Is index buffer + K in our code table?</li>
+<li>Yes: 
+	<ul>
+	<li>add K to the end of the index buffer</li>
+	<li>if there are more indexes, return to LOOP POINT</li>
+	</ul>
+</li>
+<li>No: 
+	<ul>
+	<li>Add a row for index buffer + K into our code table with 
+	the next smallest code</li>
+	<li>Output the code for just the index buffer to our code steam</li>
+	<li>Index buffer is set to K</li>
+	<li>K is set to nothing</li>
+	<li>if there are more indexes, return to LOOP POINT</li>
+	</ul>
+</li>
+<li>Output code for contents of index buffer</li>
+<li>Output end-of-information code</li>
+</ul>
+
+<p>Seems simple enough, right? It really isn't all that bad. Let's
+walk though our sample image to show you how this works. (The steps I
+will be describing are summarized in the following table. Numbers
+highlighted in green are in the index buffer; numbers in purple are
+the current K value.)  We have already initialized our code table. We
+start by doing two things: we output our clear code (#4) to the code
+stream, and we read the first color index from the index stream, 1,
+into our index buffer [Step 0].</p>
+
+<p>Now we enter the main loop of the algorithm. We read the next index
+in the index stream, 1, into K [Step 1]. Next we see if we have a
+record for the index buffer plus K in the code stream. In this case we
+looking for 1,1. Currently our code table only contains single colors
+so this value is not in there. Now we will actually add a new row to
+our code table that does contain this value.  The next available code
+is #6, we will let #6 be 1,1. Note that we do not actually send this
+code to the code stream, instead we send just the code for the
+value(s) in the index buffer. The index buffer is just 1 and the code
+for 1 is #1. This is the code we output. We now reset the index buffer
+to just the value in K and K becomes nothing. [Step 2].</p>
+
+<p>We continue by reading the next index into K. [Step 3]. Now K is 1 and the
+index buffer is 1. Again we look to see if there is a value in our code
+table for the buffer plus K (1,1) and this time there is. (In fact we just
+added it.) Therefore we add K to the end of the index buffer and clear out
+K. Now our index buffer is 1,1. [Step 4].</p>
+
+<p>The next index in the index stream is yet another 1. This is our
+new K [Step 5].  Now the index buffer plus K is 1,1,1 which we do not
+have a code for in our code table. As we did before, we define a new
+code and add it to the code table. The next code would be #7; thus #7
+= 1, 1, 1. Now we kick out the code for just the values in the index
+buffer (#6 = 1,1) to the code stream and set the index buffer to be
+K. [Step 6].</p>
+
+<table class="alg_steps" cellspacing="0">
+<thead>
+<tr>
+	<th>Step</th>
+	<th>Action</th>
+	<th>Index Stream</th>
+	<th>New Code Table Row</th>
+	<th>Code Stream</th>
+</tr>
+</thead>
+<tbody>
+<tr>
+	<td>0</td>
+	<td>Init</td>
+	<td><span class="processed"></span>
+        <span class="buffer"><span class="index">1</span></span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4</td>
+</tr>
+
+<tr>
+	<td>1</td>
+	<td>Read</td>
+	<td><span class="processed"></span>
+        <span class="buffer"><span class="index">1</span></span>
+        <span class="current"><span class="index">1</span></span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4</td>
+</tr>
+
+<tr>
+	<td>2</td>
+	<td>Not Found</td>
+	<td><span class="processed"><span class="index">1</span></span>
+        <span class="buffer"><span class="index">1</span></span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>#6 - 1, 1</td>
+	<td>#4 #1</td>
+</tr>
+
+<tr>
+	<td>3</td>
+	<td>Read</td>
+	<td><span class="processed"><span class="index">1</span></span>
+        <span class="buffer"><span class="index">1</span></span>
+        <span class="current"><span class="index">1</span></span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1</td>
+</tr>
+
+<tr>
+	<td>4</td>
+	<td>Found</td>
+	<td><span class="processed"><span class="index">1</span></span>
+        <span class="buffer"><span class="index">1</span>
+        <span class="index">1</span></span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1</td>
+</tr>
+
+<tr>
+	<td>5</td>
+	<td>Read</td>
+	<td><span class="processed"><span class="index">1</span></span>
+        <span class="buffer"><span class="index">1</span>
+        <span class="index">1</span></span>
+        <span class="current"><span class="index">1</span></span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1</td>
+</tr>
+
+<tr>
+	<td>6</td>
+	<td>Not Found</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span></span>
+        <span class="buffer"><span class="index">1</span></span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>#7 - 1, 1, 1</td>
+	<td>#4 #1 #6</td>
+</tr>
+</tbody>
+<tbody id="compress_more">
+
+<tr>
+	<td>7</td>
+	<td>Read</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span></span>
+        <span class="buffer"><span class="index">1</span></span>
+        <span class="current"><span class="index">1</span></span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1 #6</td>
+</tr>
+
+<tr>
+	<td>8</td>
+	<td>Found</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span></span>
+        <span class="buffer"><span class="index">1</span>
+        <span class="index">1</span></span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1 #6</td>
+</tr>
+
+<tr>
+	<td>9</td>
+	<td>Read</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span></span>
+        <span class="buffer"><span class="index">1</span>
+        <span class="index">1</span></span>
+        <span class="current"><span class="index">2</span></span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1 #6</td>
+</tr>
+
+<tr>
+	<td>10</td>
+	<td>Not Found</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span></span>
+        <span class="buffer"><span class="index">2</span></span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>#8 - 1, 1, 2</td>
+	<td>#4 #1 #6 #6</td>
+</tr>
+
+<tr>
+	<td>11</td>
+	<td>Read</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span></span>
+        <span class="buffer"><span class="index">2</span></span>
+        <span class="current"><span class="index">2</span></span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1 #6 #6</td>
+</tr>
+
+<tr>
+	<td>12</td>
+	<td>Not Found </td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span></span>
+        <span class="buffer"><span class="index">2</span></span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>#9 - 2, 2</td>
+	<td>#4 #1 #6 #6 #2</td>
+</tr>
+
+<tr>
+	<td>13</td>
+	<td>Read</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span></span>
+        <span class="buffer"><span class="index">2</span></span>
+        <span class="current"><span class="index">2</span></span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1 #6 #6 #2</td>
+</tr>
+
+<tr>
+	<td>14</td>
+	<td>Found </td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span></span>
+        <span class="buffer"><span class="index">2</span>
+        <span class="index">2</span></span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1 #6 #6 #2</td>
+</tr>
+
+<tr>
+	<td>15</td>
+	<td>Read</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span></span>
+        <span class="buffer"><span class="index">2</span>
+        <span class="index">2</span></span>
+        <span class="current"><span class="index">2</span></span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1 #6 #6 #2</td>
+</tr>
+
+<tr>
+	<td>16</td>
+	<td>Not Found</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span></span>
+        <span class="buffer"><span class="index">2</span></span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>#10 - 2, 2, 2</td>
+	<td>#4 #1 #6 #6 #2 #9</td>
+</tr>
+
+<tr>
+	<td>17</td>
+	<td>Read</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span></span>
+        <span class="buffer"><span class="index">2</span></span>
+        <span class="current"><span class="index">2</span></span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1 #6 #6 #2 #9</td>
+</tr>
+
+<tr>
+	<td>18</td>
+	<td>Found</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span></span>
+        <span class="buffer"><span class="index">2</span>
+        <span class="index">2</span></span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1 #6 #6 #2 #9</td>
+</tr>
+
+<tr>
+	<td>19</td>
+	<td>Read</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span></span>
+        <span class="buffer"><span class="index">2</span>
+        <span class="index">2</span></span>
+        <span class="current"><span class="index">1</span></span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1 #6 #6 #2 #9</td>
+</tr>
+
+<tr>
+	<td>20</td>
+	<td>Not Found</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span></span>
+        <span class="buffer"><span class="index">1</span></span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>#11 - 2, 2, 1</td>
+	<td>#4 #1 #6 #6 #2 #9 #9</td>
+</tr>
+
+<tr>
+	<td>21</td>
+	<td>Read</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span></span>
+        <span class="buffer"><span class="index">1</span></span>
+        <span class="current"><span class="index">1</span></span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1 #6 #6 #2 #9 #9</td>
+</tr>
+
+<tr>
+	<td>22</td>
+	<td>Found</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span></span>
+        <span class="buffer"><span class="index">1</span>
+        <span class="index">1</span></span>
+        <span class="index">1</span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1 #6 #6 #2 #9 #9</td>
+</tr>
+
+<tr>
+	<td>23</td>
+	<td>Read</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span></span>
+        <span class="buffer"><span class="index">1</span>
+        <span class="index">1</span></span>
+        <span class="current"><span class="index">1</span></span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1 #6 #6 #2 #9 #9</td>
+</tr>
+
+<tr>
+	<td>24</td>
+	<td>Found</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span></span>
+        <span class="buffer"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span></span>
+        <span class="index">1</span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1 #6 #6 #2 #9 #9</td>
+</tr>
+
+<tr>
+	<td>25</td>
+	<td>Read</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span></span>
+        <span class="buffer"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span></span>
+        <span class="current"><span class="index">1</span></span>...</td>
+	<td>&nbsp;</td>
+	<td>#4 #1 #6 #6 #2 #9 #9</td>
+</tr>
+
+<tr>
+	<td>26</td>
+	<td>Not Found</td>
+	<td><span class="processed"><span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">2</span>
+        <span class="index">1</span>
+        <span class="index">1</span>
+        <span class="index">1</span></span>
+        <span class="buffer"><span class="index">1</span></span>...</td>
+	<td>#12 - 1, 1, 1, 1</td>
+	<td>#4 #1 #6 #6 #2 #9 #9 #7</td>
+</tr>
+</tbody>
+</table>
+
+<p>I've included a few more steps to help you see the pattern. You
+keep going until you run out of indexes in the index stream. When
+there is nothing new to read, you simply write out the code for
+whatever values you may have in your index buffer.  Finally you should
+send the end-of-information code to the code stream. In this example,
+that code is #5. (View the <a href="lzw_image_data_code_table.html">
+complete code table</a>.)</p>
+
+<p>As you can see we dynamically built many new codes for our code
+table as we compressed the data. For large files this can turn into a
+large number of codes. It turns out that the GIF format specifies a
+maximum code of #4095 (this happens to be the largest 12-bit
+number). If you want to use a new code, you have to clear out all of
+your old codes. You do this by sending the clear code (which for our
+sample was the #4). This tells the decoder that you are reinitializing
+your code table and it should too. Then you start building your own
+codes again starting just after the value for your end-of-information
+code (in our sample, we would start again at #6).</p>
+
+<p>The final code stream would look like this:</p>
+
+<blockquote><p>#4 #1 #6 #6 #2 #9 #9 #7 #8 #10 #2 #12 #1 #14 #15 #6 #0 #21 #0 #10 #7 #22 #23 
+#18 #26 #7 #10 #29 #13 #24 #12 #18 #16 #36 #12 #5</p></blockquote>
+
+<p>This is only 36 codes versus the 100 that would be required without compression.</p>
+
+<h2><a name="lzw_decompression">LZW Decompression</a></h2>
+
+<p> At some point we will need to turn this code stream back into
+a picture. To do this, we only need to know the values in the stream
+and the size of the color table that was used. That's it. You remember that
+big code table we built during compression? We actually have enough information
+in the code stream itself to be able to rebuild it.</p>
+
+<p>Again, i'll list the algorithm and then we will walk though an example. Let
+me define a few terms i will be using. CODE will be current code we're working 
+with. CODE-1 will be the code just before CODE in the code stream. {CODE} 
+will be the value for CODE in the code table. For example, using the code
+table we created during compression, if CODE=#7 then {CODE}=1,1,1. 
+In the same way, {CODE-1} would be the value in the code table for the 
+code that came before CODE. Looking at step 26 from the compression, 
+if CODE=#7, then {CODE-1} would be {#9}, not {#6}, which was 2,2.</p>
+
+<ul>
+<li>Initialize code table</li>
+<li>let CODE be the first code in the code stream</li>
+<li>output {CODE} to index stream</li>
+<li>&lt;LOOP POINT&gt;</li>
+<li>let CODE be the next code in the code stream</li>
+<li>is CODE in the code table?</li>
+<li>Yes: 
+	<ul>
+	<li>output {CODE} to index stream</li>
+	<li>let K be the first index in {CODE}</li>
+	<li>add {CODE-1}+K to the code table</li>
+	</ul>
+</li>
+<li>No: 
+	<ul>
+	<li>let K be the first index of {CODE-1}</li>
+	<li>output {CODE-1}+K to index stream</li>		
+	<li>add {CODE-1}+K to code table</li>
+	</ul>
+</li>
+<li>return to LOOP POINT</li>
+</ul>
+
+<p>Let's start reading though the code stream we've created to show how to 
+turn it back into a list of color indexes.  The first value in the code 
+stream should be a clear code. This means we should initialize our code 
+table. To do this we must know how many colors  are in our color table. 
+(This information comes from the first byte in the image data block in 
+the file. More on this later.) Again we will set up codes #0-#3 to be each 
+of the four colors and add in the clear code (#4) 
+and end of information code (#5).</p>
+
+<p>The next step is to read the first color code. In the following table you 
+will see the values of CODE highlighted in purple, and the values for
+CODE-1 highlighted in green. Our first CODE value is #1. We then output
+{#1}, or simply 1,  to the index stream [Step 0].</p>
+
+<p>Now we enter the main loop of the algorithm. The next code gets assigned
+to CODE which now makes that value #6. Next we check to see if this value
+is in our code table. At this time, it is not. This means we must find the 
+first index in the value of {CODE-1} and call this K. Thus K = first index of
+{CODE-1} = first index of {#1} = 1. Now we output {CODE-1} + K to the index 
+stream and add this value to our code table. The means we output 1,1 and 
+give this value a code of #6 [Step 1].</p>
+
+<table class="alg_steps" cellspacing="0">
+<tr>
+	<th>Step</th>
+	<th>Action</th>
+	<th>Code Stream</th>
+	<th>New Code Table Row</th>
+	<th>Index Stream</th>
+</tr>
+<tr>
+	<td>0</td>
+	<td>Init</td>
+	<td><span class="processed">#4</span> <span class="current">#1</span> #6 #6 #2 #9 #9 #7 ...</td>
+	<td>&nbsp;</td>
+	<td>1</td>
+</tr>
+<tr>
+	<td>1</td>
+	<td>Not Found</td>
+	<td><span class="processed">#4</span> <span class="buffer">#1</span> <span class="current">#6</span> #6 #2 #9 #9 #7 ...</td>
+	<td>#6 - 1, 1</td>
+	<td>1, 1, 1</td>
+</tr>
+<tr>
+	<td>2</td>
+	<td>Found</td>
+	<td><span class="processed">#4 #1</span> <span class="buffer">#6</span> <span class="current">#6</span> #2 #9 #9 #7 ...</td>
+	<td>#7 - 1, 1, 1</td>
+	<td>1, 1, 1, 1, 1</td>
+</tr>
+<tr>
+	<td>3</td>
+	<td>Found</td>
+	<td><span class="processed">#4 #1 #6</span> <span class="buffer">#6</span> <span class="current">#2</span> #9 #9 #7 ...</td>
+	<td>#8 - 1, 1, 2</td>
+	<td>1, 1, 1, 1, 1, 2</td>
+</tr>
+<tr>
+	<td>4</td>
+	<td>Not Found</td>
+	<td><span class="processed">#4 #1 #6 #6</span> <span class="buffer">#2</span> <span class="current">#9</span> #9 #7 ...</td>
+	<td>#9 - 2, 2</td>
+	<td>1, 1, 1, 1, 1, 2, 2, 2</td>
+</tr>
+<tr>
+	<td>5</td>
+	<td>Found</td>
+	<td><span class="processed">#4 #1 #6 #6 #2</span> <span class="buffer">#9</span> <span class="current">#9</span> #7 ...</td>
+	<td>#10 - 2, 2, 2</td>
+	<td>1, 1, 1, 1, 1, 2, 2, 2, 2, 2</td>
+</tr>
+<tr>
+	<td>6</td>
+	<td>Found</td>
+	<td><span class="processed">#4 #1 #6 #6 #2 #9</span> <span class="buffer">#9</span> <span class="current">#7</span> ...</td>
+	<td>#11 - 2, 2, 1</td>
+	<td>1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1</td>
+</tr>
+</table>
+
+<p>We start the loop again by reading the next code. CODE now would be
+#6 and this time we do have a record for this code in our code
+table. Thus we dump {#6} to the index stream which would be 1,1.
+Now we take the first index in {#6} and call that K. Here, {#6} has
+two indexes, the first of which is 1; thus K = 1. Before moving
+on, we add {CODE-1}+K to the code table. This #7 is now 1, 1, 1 [Step 2].</p>
+
+<p>I've included a few more steps so you can see the algorithm in action. While
+the explanation may sound complicated, you can see it's actually quite simple.
+You'll also notice that you end up building the exact same 
+<a href="lzw_image_data_code_table.html">code table</a>
+as the one that was created during compression. This is the reason that
+LZW is so great; we can just share the codes and not the table.</p>
+
+<h2><a name="lzw_bytes">Saving the Code Stream as Bytes</a></h2>
+
+<p>I've shown you how to go back and forth between index and code stream, but
+haven't told you what to do with them. The index stream is used to specify the
+color of each of the pixel of your image and really only shows up on screen.
+It is the code stream that is actually saved in the GIF files on your computer 
+or transmitted over the internet. In order to save these code streams, we must
+turn them into bytes. The first thought might be to store each of the codes
+as its own byte; however this would limit the max code to just #255 and 
+result in a lot of wasted bits for the small codes. To solve these problems,
+the GIF file format actually uses flexible <em>code sizes</em>.</p>
+
+<p>Flexible code sizes allow for further compression by limiting the bits
+needed to save the code stream as bytes. The <em>code size</em> is the number 
+of bits it takes to store the value of the code. When we talk about bits, 
+we're referring to the 1's and 0's that make up a byte. The codes are 
+converted to their binary values to come up with the bits. To specify 
+the code for #4, you would look at this binary equivalent, which is 100, 
+and see that you would need three bits to store this value. The largest code
+value in our sample code stream is #36 (binary: 100100) which would 
+take 6 bits to encode. Note that the number of bits i've just given is 
+the minimum number. You can make the number take up more bits by adding
+zeros to the front.</p>
+
+<p style="text-align:center"><img src="image_data_block.gif" alt="GIF image data block layout" style="border: 1px solid black" /></p>
+
+<p>We need a way to know what size each of the codes are. Recall that the 
+image data block begins with a single byte value called the 
+<em>LZW minimum code size</em>. The GIF format allows sizes as small
+as 2 bits and as large as 12 bits. This minimum code size value is typically
+the number of bits/pixel of the image. So if you have 32 colors in your image,
+you will need 5 bits/pixel (for numbers 0-31 because 31 in binary is 11111). 
+Thus, this will most likely be one more than the bit value for the size of the 
+color table you are using. (Even if you only have two colors, the minimum
+code size most be at least 2.) Refer to the <a href="#color_table_size">
+code table above</a> to remind yourself how that works.</p>
+
+<p>Here's the funny thing: the value for minimum code size isn't
+actually the smallest code size that's used in the encoding
+process. Because the minimum code size tells you how many bits are
+needed just for the different colors of the image, you still have to
+account for the two special codes that we always add to the code
+table. Therefore the actual smallest code size that will be used is
+one more than the value specified in the &quot;minimum&quot; code size
+byte. I'll call this new value the <em>first code size</em>.</p>
+
+<p>We now know how many bytes the first code will be. This size will probably 
+work for the next few codes as well, but recall that the GIF format
+allows for flexible code sizes. As larger code values get added to your 
+code table, you will soon realize that you need larger code sizes if you 
+were to output those values. When you are encoding the data, you increase
+your code size as soon as your write out the code equal to 
+2^(current code size)-1. If you are decoding from codes to indexes,
+you need to increase your code size as soon as you add the code value that
+is equal to 2^(current code size)-1 to your code table. That is, the next 
+time you grab the next section of bits, you grab one more.</p>
+
+<p>Note that the largest code size allowed is 12 bits. If you get to this
+limit, the next code you encounter should be the <em>clear code</em> which
+would tell you to reinitialize the code table. You then go back to using 
+the first code size and grow again when necessary.</p>
+
+<p>Jumping back to our sample image, we see that we have a minimum code
+size value of 2 which means out first code size will be 3 bits long. 
+Out first three codes, #1 #6 and #6, would be coded as 001 110 and 110.
+If you see at Step 6 of the encoding, we added a code of #7 to our code
+table. This is our clue to increase our code size because 7 is equal to
+2^3-1 (where 3 is our current code size). Thus, the next code we 
+write out, #2, will use the new code size of 4 and therefore look
+like 0010. In the decoding process, we again would increase our code
+size when we read the code for #7 and would read the next 4, rather than
+the next 3 bits, to get the next code. In the sample table above this
+occurs in Step 2.</p>
+
+<p>Finally we must turn all these bit values into bytes. The lowest bit of the
+code bit value gets placed in the lowest available bit of the byte. After
+you've filled up the 8 bits in the byte, you take any left over bits and 
+start a new byte. Take a look at the following illustration to see
+how that works with the codes from our sample image.</p>
+
+<p style="text-align:center"><img src="lzw_encoding_codes.gif"
+alt="Encoding LZW Codes" style="border: 1px solid black" / WIDTH="500"
+HEIGHT="220"></p>
+
+<p>You can see in the first byte that was returned (<span
+class="byte">8C</span>) that the lowest three bits (because that was
+our first code size) contain 010 which is the binary value of 6 so
+that would be the clear code we started with, #4. In the three bits to
+the left, you see 001 which out or first data code of #1. You can also
+see when we switched into code sizes of 4 bits in the second byte
+(<span class="byte">2D</span>).</p>
+
+<p>When you run out of codes but have filled less than 8 bits of the
+byte, you should just fill the remaining bits with zeros. Recall that
+the image data must be broken up onto <a
+href="bits_and_bytes.html#image_data_block">data sub-blocks</a>.  Each
+of the data sub-blocks begins with a byte that specifies how many
+bytes of data. The value will be between 1 and 255. After you read
+those bytes, the next byte indicates again how many bytes of data
+follow. You stop when you encounter a subblock that has a lenght of
+zero. That tells you when you've reached the end of the image data. In
+our sample the image the byte just after the LZW code size is <span
+class="byte">16</span> which indicates that 22 bytes of data
+follow. After we reach those, we see the next byte is <span
+class="byte">00</span> which means we are all done.</p>
+
+<p>Return codes from bytes the basically just the same process in
+reverse.  A sample illustration of the process follows which shows how
+you would extract codes if the first code size were 5 bits.</p>
+
+<p style="text-align:center"><img src="lzw_decoding_bytes.gif" alt="Decoding LZW Bytes" style="border: 1px solid black" / WIDTH="500" HEIGHT="220"></p>
+
+<h2>Next: Animation and Transparency</h2>
+
+<p>That is pretty much everything you need to know to read or generate 
+a basic image file. One of the reasons the GIF becames such a popular
+format was because it also allowed for &quot;fancier&quot; features. These
+features include animation and transparency. Next we'll look 
+at how those work.</p>
+
+<p><a href="animation_and_transparency.html">Continue...</a></p>
+</div>
+
+<div style="text-align:center; margin-top: 10px; padding-top: 10px; border-top: #cecece 1px solid">
+<a href="../index.html">Back to GIFLIB documentation</a>
+</div>
+
+</body>
+
+</html>
diff --git a/doc/whatsinagif/lzw_image_data_code_table.html b/doc/whatsinagif/lzw_image_data_code_table.html
new file mode 100644
index 0000000..688840c
--- /dev/null
+++ b/doc/whatsinagif/lzw_image_data_code_table.html
@@ -0,0 +1,81 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html>
+<head>
+	<title>What's In A GIF - LZW Image Data</title>
+	<script type="text/javascript"></script>
+	<link rel="stylesheet" href="../proj.css" />
+	<style type="text/css">
+	#code_table {margin: auto; margin-right:auto; border: 1px solid black}
+	#code_table td {text-align: right;}
+	#code_table td, #code_table th {text-align: right; border: 1px solid black;}
+	</style>
+</head>
+<body>
+<table width='100%' cellpadding='0' summary='Canned page header' bgcolor="#ddd">
+<tr>
+<td><h2>What's In A GIF</h2></td>
+<td align="center"><img src="../giflib-logo.gif"></td>
+<td align="right">(full code table)</td>
+</tr>
+</table>
+
+<div class="body">
+<div style="text-align:center; margin-top: 10px; padding-top: 10px; border-top: #cecece 1px solid">
+<p><a href="index.html">Back to the What's In A GIF index page.</a></p>
+</div>
+
+<p>
+Here's the complete code table that is generated by the sample image.
+</p>
+<table id="code_table" cellspacing="0">
+	<tr><th>Code</th>	<th>Color Index(es)</th></tr>
+	<tr><td>#0</td>		<td>0</td>	</tr>
+	<tr><td>#1</td>		<td>1</td>	</tr>
+	<tr><td>#2</td>		<td>2</td>	</tr>
+	<tr><td>#3</td>		<td>3</td>	</tr>
+	<tr><td>#4</td>		<td>clear code</td>	</tr>
+	<tr><td>#5</td>		<td>end of information code</td>	</tr>
+	<tr><td>#6</td>		<td>1, 1</td>	</tr>
+	<tr><td>#7</td>		<td>1, 1, 1</td>	</tr>
+	<tr><td>#8</td>		<td>1, 1, 2</td>	</tr>
+	<tr><td>#9</td>		<td>2, 2</td>	</tr>
+	<tr><td>#10</td>	<td>2, 2, 2</td>	</tr>
+	<tr><td>#11</td>	<td>2, 2, 1</td>	</tr>
+	<tr><td>#12</td>	<td>1, 1, 1, 1</td>	</tr>
+	<tr><td>#13</td>	<td>1, 1, 2, 2</td>	</tr>
+	<tr><td>#14</td>	<td>2, 2, 2, 2</td>	</tr>
+	<tr><td>#15</td>	<td>2, 1</td>	</tr>
+	<tr><td>#16</td>	<td>1, 1, 1, 1, 1</td>	</tr>
+	<tr><td>#17</td>	<td>1, 2</td>	</tr>
+	<tr><td>#18</td>	<td>2, 2, 2, 2, 2</td>	</tr>
+	<tr><td>#19</td>	<td>2, 1, 1</td>	</tr>
+	<tr><td>#20</td>	<td>1, 1, 0</td>	</tr>
+	<tr><td>#21</td>	<td>0, 0</td>	</tr>
+	<tr><td>#22</td>	<td>0, 0, 0</td>	</tr>
+	<tr><td>#23</td>	<td>0 ,2</td>	</tr>
+	<tr><td>#24</td>	<td>2, 2, 2, 1</td>	</tr>
+	<tr><td>#25</td>	<td>1, 1, 1, 0</td>	</tr>
+	<tr><td>#26</td>	<td>0, 0, 0, 0</td>	</tr>
+	<tr><td>#27</td>	<td>0, 2, 2</td>	</tr>
+	<tr><td>#28</td>	<td>2, 2, 2, 2, 2, 0</td>	</tr>
+	<tr><td>#29</td>	<td>0, 0, 0, 0, 1</td>	</tr>
+	<tr><td>#30</td>	<td>1, 1, 1, 2</td>	</tr>
+	<tr><td>#31</td>	<td>2, 2, 2, 0</td>	</tr>
+	<tr><td>#32</td>	<td>0, 0, 0, 0, 1, 1</td>	</tr>
+	<tr><td>#33</td>	<td>1, 1, 2, 2, 2</td>	</tr>
+	<tr><td>#34</td>	<td>2, 2, 2, 1, 1</td>	</tr>
+	<tr><td>#35</td>	<td>1, 1, 1, 1, 2</td>	</tr>
+	<tr><td>#36</td>	<td>2, 2, 2, 2, 2, 1</td>	</tr>
+	<tr><td>#37</td>	<td>1, 1, 1, 1, 1, 2</td>	</tr>
+	<tr><td>#38</td>	<td>2, 2, 2, 2, 2, 1, 1</td>	</tr>		
+</table>
+</div>
+
+<div style="text-align:center; margin-top: 10px; padding-top: 10px; border-top: #cecece 1px solid">
+<a href="../index.html">Back to GIFLIB documentation</a>
+</div>
+
+</body>
+
+</html>
+
diff --git a/doc/whatsinagif/sample_1.gif b/doc/whatsinagif/sample_1.gif
new file mode 100644
index 0000000..d89e799
Binary files /dev/null and b/doc/whatsinagif/sample_1.gif differ
diff --git a/doc/whatsinagif/sample_1_enlarged.gif b/doc/whatsinagif/sample_1_enlarged.gif
new file mode 100644
index 0000000..777c267
Binary files /dev/null and b/doc/whatsinagif/sample_1_enlarged.gif differ
diff --git a/doc/whatsinagif/sample_1_trans.gif b/doc/whatsinagif/sample_1_trans.gif
new file mode 100644
index 0000000..a5bb413
Binary files /dev/null and b/doc/whatsinagif/sample_1_trans.gif differ
diff --git a/doc/whatsinagif/sample_1_trans_blue.gif b/doc/whatsinagif/sample_1_trans_blue.gif
new file mode 100644
index 0000000..4dc3079
Binary files /dev/null and b/doc/whatsinagif/sample_1_trans_blue.gif differ
diff --git a/doc/whatsinagif/sample_1_trans_red.gif b/doc/whatsinagif/sample_1_trans_red.gif
new file mode 100644
index 0000000..fb1ca6b
Binary files /dev/null and b/doc/whatsinagif/sample_1_trans_red.gif differ
diff --git a/doc/whatsinagif/sample_2_animation.gif b/doc/whatsinagif/sample_2_animation.gif
new file mode 100644
index 0000000..3d1c19c
Binary files /dev/null and b/doc/whatsinagif/sample_2_animation.gif differ
diff --git a/doc/whatsinagif/sample_2_animation_green.gif b/doc/whatsinagif/sample_2_animation_green.gif
new file mode 100644
index 0000000..ad0169f
Binary files /dev/null and b/doc/whatsinagif/sample_2_animation_green.gif differ
diff --git a/doc/whatsinagif/sample_2_animation_red.gif b/doc/whatsinagif/sample_2_animation_red.gif
new file mode 100644
index 0000000..3f6a909
Binary files /dev/null and b/doc/whatsinagif/sample_2_animation_red.gif differ
diff --git a/doc/whatsinagif/sample_2_animation_yellow.gif b/doc/whatsinagif/sample_2_animation_yellow.gif
new file mode 100644
index 0000000..f79224b
Binary files /dev/null and b/doc/whatsinagif/sample_2_animation_yellow.gif differ
diff --git a/doc/whatsinagif/sample_2_green_large.gif b/doc/whatsinagif/sample_2_green_large.gif
new file mode 100644
index 0000000..4f6e4ef
Binary files /dev/null and b/doc/whatsinagif/sample_2_green_large.gif differ
diff --git a/doc/whatsinagif/sample_2_green_yellow_diff.gif b/doc/whatsinagif/sample_2_green_yellow_diff.gif
new file mode 100644
index 0000000..fc2b899
Binary files /dev/null and b/doc/whatsinagif/sample_2_green_yellow_diff.gif differ
diff --git a/doc/whatsinagif/sample_2_yellow_large.gif b/doc/whatsinagif/sample_2_yellow_large.gif
new file mode 100644
index 0000000..22eb01c
Binary files /dev/null and b/doc/whatsinagif/sample_2_yellow_large.gif differ
diff --git a/doc/whatsinagif/trailer_block.gif b/doc/whatsinagif/trailer_block.gif
new file mode 100644
index 0000000..d8a5b19
Binary files /dev/null and b/doc/whatsinagif/trailer_block.gif differ
diff --git a/egif_lib.c b/egif_lib.c
index 3917ec6..1526868 100644
--- a/egif_lib.c
+++ b/egif_lib.c
@@ -6,19 +6,21 @@ The functions here and in dgif_lib.c are partitioned carefully so that
 if you only require one of read and write capability, only one of these
 two modules will be linked.  Preserve this property!
 
+SPDX-License-Identifier: MIT
+
 *****************************************************************************/
 
-#include <unistd.h>
+#include <fcntl.h>
 #include <stdint.h>
-#include <stdlib.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
-#include <fcntl.h>
 
 #ifdef _WIN32
 #include <io.h>
 #else
 #include <sys/types.h>
+#include <unistd.h>
 #endif /* _WIN32 */
 #include <sys/stat.h>
 
@@ -27,54 +29,59 @@ two modules will be linked.  Preserve this property!
 
 /* Masks given codes to BitsPerPixel, to make sure all codes are in range: */
 /*@+charint@*/
-static const GifPixelType CodeMask[] = {
-    0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff
-};
+static const GifPixelType CodeMask[] = {0x00, 0x01, 0x03, 0x07, 0x0f,
+                                        0x1f, 0x3f, 0x7f, 0xff};
 /*@-charint@*/
 
-static int EGifPutWord(int Word, GifFileType * GifFile);
-static int EGifSetupCompress(GifFileType * GifFile);
-static int EGifCompressLine(GifFileType * GifFile, GifPixelType * Line,
-                            int LineLen);
-static int EGifCompressOutput(GifFileType * GifFile, int Code);
-static int EGifBufferedOutput(GifFileType * GifFile, GifByteType * Buf,
-                              int c);
+static int EGifPutWord(int Word, GifFileType *GifFile);
+static int EGifSetupCompress(GifFileType *GifFile);
+static int EGifCompressLine(GifFileType *GifFile, const GifPixelType *Line,
+                            const int LineLen);
+static int EGifCompressOutput(GifFileType *GifFile, int Code);
+static int EGifBufferedOutput(GifFileType *GifFile, GifByteType *Buf, int c);
 
 /* extract bytes from an unsigned word */
-#define LOBYTE(x)	((x) & 0xff)
-#define HIBYTE(x)	(((x) >> 8) & 0xff)
+#define LOBYTE(x) ((x)&0xff)
+#define HIBYTE(x) (((x) >> 8) & 0xff)
+
+#ifndef S_IREAD
+#define S_IREAD S_IRUSR
+#endif
 
+#ifndef S_IWRITE
+#define S_IWRITE S_IWUSR
+#endif
 /******************************************************************************
  Open a new GIF file for write, specified by name. If TestExistance then
  if the file exists this routines fails (returns NULL).
  Returns a dynamically allocated GifFileType pointer which serves as the GIF
  info record. The Error member is cleared if successful.
 ******************************************************************************/
-GifFileType *
-EGifOpenFileName(const char *FileName, const bool TestExistence, int *Error)
-{
-
-    int FileHandle;
-    GifFileType *GifFile;
-
-    if (TestExistence)
-        /* android-changed: changed "S_IREAD | S_IWRITE" to "S_IRUSR | S_IWUSR" */
-        FileHandle = open(FileName, O_WRONLY | O_CREAT | O_EXCL,
-                          S_IRUSR | S_IWUSR);
-    else
-        /* android-changed: changed "S_IREAD | S_IWRITE" to "S_IRUSR | S_IWUSR" */
-        FileHandle = open(FileName, O_WRONLY | O_CREAT | O_TRUNC,
-                          S_IRUSR | S_IWUSR);
-
-    if (FileHandle == -1) {
-        if (Error != NULL)
-	    *Error = E_GIF_ERR_OPEN_FAILED;
-        return NULL;
-    }
-    GifFile = EGifOpenFileHandle(FileHandle, Error);
-    if (GifFile == (GifFileType *) NULL)
-        (void)close(FileHandle);
-    return GifFile;
+GifFileType *EGifOpenFileName(const char *FileName, const bool TestExistence,
+                              int *Error) {
+
+	int FileHandle;
+	GifFileType *GifFile;
+
+	if (TestExistence) {
+		FileHandle = open(FileName, O_WRONLY | O_CREAT | O_EXCL,
+		                  S_IREAD | S_IWRITE);
+	} else {
+		FileHandle = open(FileName, O_WRONLY | O_CREAT | O_TRUNC,
+		                  S_IREAD | S_IWRITE);
+	}
+
+	if (FileHandle == -1) {
+		if (Error != NULL) {
+			*Error = E_GIF_ERR_OPEN_FAILED;
+		}
+		return NULL;
+	}
+	GifFile = EGifOpenFileHandle(FileHandle, Error);
+	if (GifFile == (GifFileType *)NULL) {
+		(void)close(FileHandle);
+	}
+	return GifFile;
 }
 
 /******************************************************************************
@@ -84,459 +91,458 @@ EGifOpenFileName(const char *FileName, const bool TestExistence, int *Error)
  info record.
  Only fails on a memory allocation error.
 ******************************************************************************/
-GifFileType *
-EGifOpenFileHandle(const int FileHandle, int *Error)
-{
-    GifFileType *GifFile;
-    GifFilePrivateType *Private;
-    FILE *f;
-
-    GifFile = (GifFileType *) malloc(sizeof(GifFileType));
-    if (GifFile == NULL) {
-        return NULL;
-    }
-
-    memset(GifFile, '\0', sizeof(GifFileType));
-
-    Private = (GifFilePrivateType *)malloc(sizeof(GifFilePrivateType));
-    if (Private == NULL) {
-        free(GifFile);
-        if (Error != NULL)
-	    *Error = E_GIF_ERR_NOT_ENOUGH_MEM;
-        return NULL;
-    }
-    /*@i1@*/memset(Private, '\0', sizeof(GifFilePrivateType));
-    if ((Private->HashTable = _InitHashTable()) == NULL) {
-        free(GifFile);
-        free(Private);
-        if (Error != NULL)
-	    *Error = E_GIF_ERR_NOT_ENOUGH_MEM;
-        return NULL;
-    }
+GifFileType *EGifOpenFileHandle(const int FileHandle, int *Error) {
+	GifFileType *GifFile;
+	GifFilePrivateType *Private;
+	FILE *f;
+
+	GifFile = (GifFileType *)malloc(sizeof(GifFileType));
+	if (GifFile == NULL) {
+		return NULL;
+	}
+
+	memset(GifFile, '\0', sizeof(GifFileType));
+
+	Private = (GifFilePrivateType *)malloc(sizeof(GifFilePrivateType));
+	if (Private == NULL) {
+		free(GifFile);
+		if (Error != NULL) {
+			*Error = E_GIF_ERR_NOT_ENOUGH_MEM;
+		}
+		return NULL;
+	}
+	/*@i1@*/ memset(Private, '\0', sizeof(GifFilePrivateType));
+	if ((Private->HashTable = _InitHashTable()) == NULL) {
+		free(GifFile);
+		free(Private);
+		if (Error != NULL) {
+			*Error = E_GIF_ERR_NOT_ENOUGH_MEM;
+		}
+		return NULL;
+	}
 
 #ifdef _WIN32
-    _setmode(FileHandle, O_BINARY);    /* Make sure it is in binary mode. */
-#endif /* _WIN32 */
+	_setmode(FileHandle, O_BINARY); /* Make sure it is in binary mode. */
+#endif                                  /* _WIN32 */
 
-    f = fdopen(FileHandle, "wb");    /* Make it into a stream: */
+	f = fdopen(FileHandle, "wb"); /* Make it into a stream: */
 
-    GifFile->Private = (void *)Private;
-    Private->FileHandle = FileHandle;
-    Private->File = f;
-    Private->FileState = FILE_STATE_WRITE;
-    Private->gif89 = false;
+	GifFile->Private = (void *)Private;
+	Private->FileHandle = FileHandle;
+	Private->File = f;
+	Private->FileState = FILE_STATE_WRITE;
+	Private->gif89 = false;
 
-    Private->Write = (OutputFunc) 0;    /* No user write routine (MRB) */
-    GifFile->UserData = (void *)NULL;    /* No user write handle (MRB) */
+	Private->Write = (OutputFunc)0;   /* No user write routine (MRB) */
+	GifFile->UserData = (void *)NULL; /* No user write handle (MRB) */
 
-    GifFile->Error = 0;
+	GifFile->Error = 0;
 
-    return GifFile;
+	return GifFile;
 }
 
 /******************************************************************************
  Output constructor that takes user supplied output function.
  Basically just a copy of EGifOpenFileHandle. (MRB)
 ******************************************************************************/
-GifFileType *
-EGifOpen(void *userData, OutputFunc writeFunc, int *Error)
-{
-    GifFileType *GifFile;
-    GifFilePrivateType *Private;
-
-    GifFile = (GifFileType *)malloc(sizeof(GifFileType));
-    if (GifFile == NULL) {
-        if (Error != NULL)
-	    *Error = E_GIF_ERR_NOT_ENOUGH_MEM;
-        return NULL;
-    }
-
-    memset(GifFile, '\0', sizeof(GifFileType));
-
-    Private = (GifFilePrivateType *)malloc(sizeof(GifFilePrivateType));
-    if (Private == NULL) {
-        free(GifFile);
-        if (Error != NULL)
-	    *Error = E_GIF_ERR_NOT_ENOUGH_MEM;
-        return NULL;
-    }
-
-    memset(Private, '\0', sizeof(GifFilePrivateType));
-
-    Private->HashTable = _InitHashTable();
-    if (Private->HashTable == NULL) {
-        free (GifFile);
-        free (Private);
-        if (Error != NULL)
-	    *Error = E_GIF_ERR_NOT_ENOUGH_MEM;
-        return NULL;
-    }
-
-    GifFile->Private = (void *)Private;
-    Private->FileHandle = 0;
-    Private->File = (FILE *) 0;
-    Private->FileState = FILE_STATE_WRITE;
-
-    Private->Write = writeFunc;    /* User write routine (MRB) */
-    GifFile->UserData = userData;    /* User write handle (MRB) */
-
-    Private->gif89 = false;	/* initially, write GIF87 */
-
-    GifFile->Error = 0;
-
-    return GifFile;
+GifFileType *EGifOpen(void *userData, OutputFunc writeFunc, int *Error) {
+	GifFileType *GifFile;
+	GifFilePrivateType *Private;
+
+	GifFile = (GifFileType *)malloc(sizeof(GifFileType));
+	if (GifFile == NULL) {
+		if (Error != NULL) {
+			*Error = E_GIF_ERR_NOT_ENOUGH_MEM;
+		}
+		return NULL;
+	}
+
+	memset(GifFile, '\0', sizeof(GifFileType));
+
+	Private = (GifFilePrivateType *)malloc(sizeof(GifFilePrivateType));
+	if (Private == NULL) {
+		free(GifFile);
+		if (Error != NULL) {
+			*Error = E_GIF_ERR_NOT_ENOUGH_MEM;
+		}
+		return NULL;
+	}
+
+	memset(Private, '\0', sizeof(GifFilePrivateType));
+
+	Private->HashTable = _InitHashTable();
+	if (Private->HashTable == NULL) {
+		free(GifFile);
+		free(Private);
+		if (Error != NULL) {
+			*Error = E_GIF_ERR_NOT_ENOUGH_MEM;
+		}
+		return NULL;
+	}
+
+	GifFile->Private = (void *)Private;
+	Private->FileHandle = 0;
+	Private->File = (FILE *)0;
+	Private->FileState = FILE_STATE_WRITE;
+
+	Private->Write = writeFunc;   /* User write routine (MRB) */
+	GifFile->UserData = userData; /* User write handle (MRB) */
+
+	Private->gif89 = false; /* initially, write GIF87 */
+
+	GifFile->Error = 0;
+
+	return GifFile;
 }
 
 /******************************************************************************
  Routine to compute the GIF version that will be written on output.
 ******************************************************************************/
-const char *
-EGifGetGifVersion(GifFileType *GifFile)
-{
-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;
-    int i, j;
-
-    /* 
-     * Bulletproofing - always write GIF89 if we need to.
-     * Note, we don't clear the gif89 flag here because
-     * users of the sequential API might have called EGifSetGifVersion()
-     * in order to set that flag.
-     */
-    for (i = 0; i < GifFile->ImageCount; i++) {
-        for (j = 0; j < GifFile->SavedImages[i].ExtensionBlockCount; j++) {
-            int function =
-               GifFile->SavedImages[i].ExtensionBlocks[j].Function;
-
-            if (function == COMMENT_EXT_FUNC_CODE
-                || function == GRAPHICS_EXT_FUNC_CODE
-                || function == PLAINTEXT_EXT_FUNC_CODE
-                || function == APPLICATION_EXT_FUNC_CODE)
-                Private->gif89 = true;
-        }
-    }
-    for (i = 0; i < GifFile->ExtensionBlockCount; i++) {
-	int function = GifFile->ExtensionBlocks[i].Function;
-
-	if (function == COMMENT_EXT_FUNC_CODE
-	    || function == GRAPHICS_EXT_FUNC_CODE
-	    || function == PLAINTEXT_EXT_FUNC_CODE
-	    || function == APPLICATION_EXT_FUNC_CODE)
-	    Private->gif89 = true;
-    }
- 
-    if (Private->gif89)
-	return GIF89_STAMP;
-    else
-	return GIF87_STAMP;
+const char *EGifGetGifVersion(GifFileType *GifFile) {
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+	int i, j;
+
+	/*
+	 * Bulletproofing - always write GIF89 if we need to.
+	 * Note, we don't clear the gif89 flag here because
+	 * users of the sequential API might have called EGifSetGifVersion()
+	 * in order to set that flag.
+	 */
+	for (i = 0; i < GifFile->ImageCount; i++) {
+		for (j = 0; j < GifFile->SavedImages[i].ExtensionBlockCount;
+		     j++) {
+			int function =
+			    GifFile->SavedImages[i].ExtensionBlocks[j].Function;
+
+			if (function == COMMENT_EXT_FUNC_CODE ||
+			    function == GRAPHICS_EXT_FUNC_CODE ||
+			    function == PLAINTEXT_EXT_FUNC_CODE ||
+			    function == APPLICATION_EXT_FUNC_CODE) {
+				Private->gif89 = true;
+			}
+		}
+	}
+	for (i = 0; i < GifFile->ExtensionBlockCount; i++) {
+		int function = GifFile->ExtensionBlocks[i].Function;
+
+		if (function == COMMENT_EXT_FUNC_CODE ||
+		    function == GRAPHICS_EXT_FUNC_CODE ||
+		    function == PLAINTEXT_EXT_FUNC_CODE ||
+		    function == APPLICATION_EXT_FUNC_CODE) {
+			Private->gif89 = true;
+		}
+	}
+
+	if (Private->gif89) {
+		return GIF89_STAMP;
+	} else {
+		return GIF87_STAMP;
+	}
 }
 
 /******************************************************************************
  Set the GIF version. In the extremely unlikely event that there is ever
- another version, replace the bool argument with an enum in which the 
+ another version, replace the bool argument with an enum in which the
  GIF87 value is 0 (numerically the same as bool false) and the GIF89 value
  is 1 (numerically the same as bool true).  That way we'll even preserve
  object-file compatibility!
 ******************************************************************************/
-void EGifSetGifVersion(GifFileType *GifFile, const bool gif89)
-{
-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;
+void EGifSetGifVersion(GifFileType *GifFile, const bool gif89) {
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
-    Private->gif89 = gif89;
+	Private->gif89 = gif89;
 }
 
 /******************************************************************************
  All writes to the GIF should go through this.
 ******************************************************************************/
-static int InternalWrite(GifFileType *GifFileOut, 
-		   const unsigned char *buf, size_t len)
-{
-    GifFilePrivateType *Private = (GifFilePrivateType*)GifFileOut->Private;
-    if (Private->Write)
-	return Private->Write(GifFileOut,buf,len);
-    else
-	return fwrite(buf, 1, len, Private->File);
+static int InternalWrite(GifFileType *GifFileOut, const unsigned char *buf,
+                         size_t len) {
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFileOut->Private;
+	if (Private->Write) {
+		return Private->Write(GifFileOut, buf, len);
+	} else {
+		return fwrite(buf, 1, len, Private->File);
+	}
 }
 
 /******************************************************************************
  This routine should be called before any other EGif calls, immediately
  following the GIF file opening.
 ******************************************************************************/
-int
-EGifPutScreenDesc(GifFileType *GifFile,
-                  const int Width,
-                  const int Height,
-                  const int ColorRes,
-                  const int BackGround,
-                  const ColorMapObject *ColorMap)
-{
-    GifByteType Buf[3];
-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;
-    const char *write_version;
-
-    if (Private->FileState & FILE_STATE_SCREEN) {
-        /* If already has screen descriptor - something is wrong! */
-        GifFile->Error = E_GIF_ERR_HAS_SCRN_DSCR;
-        return GIF_ERROR;
-    }
-    if (!IS_WRITEABLE(Private)) {
-        /* This file was NOT open for writing: */
-        GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
-        return GIF_ERROR;
-    }
-
-    write_version = EGifGetGifVersion(GifFile);
-
-    /* First write the version prefix into the file. */
-    if (InternalWrite(GifFile, (unsigned char *)write_version,
-              strlen(write_version)) != strlen(write_version)) {
-        GifFile->Error = E_GIF_ERR_WRITE_FAILED;
-        return GIF_ERROR;
-    }
-
-    GifFile->SWidth = Width;
-    GifFile->SHeight = Height;
-    GifFile->SColorResolution = ColorRes;
-    GifFile->SBackGroundColor = BackGround;
-    if (ColorMap) {
-        GifFile->SColorMap = GifMakeMapObject(ColorMap->ColorCount,
-                                           ColorMap->Colors);
-        if (GifFile->SColorMap == NULL) {
-            GifFile->Error = E_GIF_ERR_NOT_ENOUGH_MEM;
-            return GIF_ERROR;
-        }
-    } else
-        GifFile->SColorMap = NULL;
-
-    /*
-     * Put the logical screen descriptor into the file:
-     */
-    /* Logical Screen Descriptor: Dimensions */
-    (void)EGifPutWord(Width, GifFile);
-    (void)EGifPutWord(Height, GifFile);
-
-    /* Logical Screen Descriptor: Packed Fields */
-    /* Note: We have actual size of the color table default to the largest
-     * possible size (7+1 == 8 bits) because the decoder can use it to decide
-     * how to display the files.
-     */
-    Buf[0] = (ColorMap ? 0x80 : 0x00) | /* Yes/no global colormap */
-             ((ColorRes - 1) << 4) | /* Bits allocated to each primary color */
-        (ColorMap ? ColorMap->BitsPerPixel - 1 : 0x07 ); /* Actual size of the
-                                                            color table. */
-    if (ColorMap != NULL && ColorMap->SortFlag)
-	Buf[0] |= 0x08;
-    Buf[1] = BackGround;    /* Index into the ColorTable for background color */
-    Buf[2] = GifFile->AspectByte;     /* Pixel Aspect Ratio */
-    InternalWrite(GifFile, Buf, 3);
-
-    /* If we have Global color map - dump it also: */
-    if (ColorMap != NULL) {
-	int i;
-        for (i = 0; i < ColorMap->ColorCount; i++) {
-            /* Put the ColorMap out also: */
-            Buf[0] = ColorMap->Colors[i].Red;
-            Buf[1] = ColorMap->Colors[i].Green;
-            Buf[2] = ColorMap->Colors[i].Blue;
-            if (InternalWrite(GifFile, Buf, 3) != 3) {
-                GifFile->Error = E_GIF_ERR_WRITE_FAILED;
-                return GIF_ERROR;
-            }
-        }
-    }
-
-    /* Mark this file as has screen descriptor, and no pixel written yet: */
-    Private->FileState |= FILE_STATE_SCREEN;
-
-    return GIF_OK;
+int EGifPutScreenDesc(GifFileType *GifFile, const int Width, const int Height,
+                      const int ColorRes, const int BackGround,
+                      const ColorMapObject *ColorMap) {
+	GifByteType Buf[3];
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+	const char *write_version;
+	GifFile->SColorMap = NULL;
+
+	if (Private->FileState & FILE_STATE_SCREEN) {
+		/* If already has screen descriptor - something is wrong! */
+		GifFile->Error = E_GIF_ERR_HAS_SCRN_DSCR;
+		return GIF_ERROR;
+	}
+	if (!IS_WRITEABLE(Private)) {
+		/* This file was NOT open for writing: */
+		GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
+		return GIF_ERROR;
+	}
+
+	write_version = EGifGetGifVersion(GifFile);
+
+	/* First write the version prefix into the file. */
+	if (InternalWrite(GifFile, (unsigned char *)write_version,
+	                  strlen(write_version)) != strlen(write_version)) {
+		GifFile->Error = E_GIF_ERR_WRITE_FAILED;
+		return GIF_ERROR;
+	}
+
+	GifFile->SWidth = Width;
+	GifFile->SHeight = Height;
+	GifFile->SColorResolution = ColorRes;
+	GifFile->SBackGroundColor = BackGround;
+	if (ColorMap) {
+		GifFile->SColorMap =
+		    GifMakeMapObject(ColorMap->ColorCount, ColorMap->Colors);
+		if (GifFile->SColorMap == NULL) {
+			GifFile->Error = E_GIF_ERR_NOT_ENOUGH_MEM;
+			return GIF_ERROR;
+		}
+	} else {
+		GifFile->SColorMap = NULL;
+	}
+
+	/*
+	 * Put the logical screen descriptor into the file:
+	 */
+	/* Logical Screen Descriptor: Dimensions */
+	(void)EGifPutWord(Width, GifFile);
+	(void)EGifPutWord(Height, GifFile);
+
+	/* Logical Screen Descriptor: Packed Fields */
+	/* Note: We have actual size of the color table default to the largest
+	 * possible size (7+1 == 8 bits) because the decoder can use it to
+	 * decide how to display the files.
+	 */
+	Buf[0] =
+	    (ColorMap ? 0x80 : 0x00) | /* Yes/no global colormap */
+	    ((ColorRes - 1) << 4) | /* Bits allocated to each primary color */
+	    (ColorMap ? ColorMap->BitsPerPixel - 1
+	              : 0x07); /* Actual size of the
+	                          color table. */
+	if (ColorMap != NULL && ColorMap->SortFlag) {
+		Buf[0] |= 0x08;
+	}
+	Buf[1] =
+	    BackGround; /* Index into the ColorTable for background color */
+	Buf[2] = GifFile->AspectByte; /* Pixel Aspect Ratio */
+	InternalWrite(GifFile, Buf, 3);
+
+	/* If we have Global color map - dump it also: */
+	if (ColorMap != NULL) {
+		int i;
+		for (i = 0; i < ColorMap->ColorCount; i++) {
+			/* Put the ColorMap out also: */
+			Buf[0] = ColorMap->Colors[i].Red;
+			Buf[1] = ColorMap->Colors[i].Green;
+			Buf[2] = ColorMap->Colors[i].Blue;
+			if (InternalWrite(GifFile, Buf, 3) != 3) {
+				GifFile->Error = E_GIF_ERR_WRITE_FAILED;
+				return GIF_ERROR;
+			}
+		}
+	}
+
+	/* Mark this file as has screen descriptor, and no pixel written yet: */
+	Private->FileState |= FILE_STATE_SCREEN;
+
+	return GIF_OK;
 }
 
 /******************************************************************************
  This routine should be called before any attempt to dump an image - any
  call to any of the pixel dump routines.
 ******************************************************************************/
-int
-EGifPutImageDesc(GifFileType *GifFile,
-                 const int Left,
-                 const int Top,
-                 const int Width,
-                 const int Height,
-                 const bool Interlace,
-                 const ColorMapObject *ColorMap)
-{
-    GifByteType Buf[3];
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
-
-    if (Private->FileState & FILE_STATE_IMAGE &&
-        Private->PixelCount > 0xffff0000UL) {
-        /* If already has active image descriptor - something is wrong! */
-        GifFile->Error = E_GIF_ERR_HAS_IMAG_DSCR;
-        return GIF_ERROR;
-    }
-    if (!IS_WRITEABLE(Private)) {
-        /* This file was NOT open for writing: */
-        GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
-        return GIF_ERROR;
-    }
-    GifFile->Image.Left = Left;
-    GifFile->Image.Top = Top;
-    GifFile->Image.Width = Width;
-    GifFile->Image.Height = Height;
-    GifFile->Image.Interlace = Interlace;
-    if (ColorMap) {
-	if (GifFile->Image.ColorMap != NULL) {
-	    GifFreeMapObject(GifFile->Image.ColorMap);
-	    GifFile->Image.ColorMap = NULL;
+int EGifPutImageDesc(GifFileType *GifFile, const int Left, const int Top,
+                     const int Width, const int Height, const bool Interlace,
+                     const ColorMapObject *ColorMap) {
+	GifByteType Buf[3];
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	if (Private->FileState & FILE_STATE_IMAGE &&
+	    Private->PixelCount > 0xffff0000UL) {
+		/* If already has active image descriptor - something is wrong!
+		 */
+		GifFile->Error = E_GIF_ERR_HAS_IMAG_DSCR;
+		return GIF_ERROR;
 	}
-        GifFile->Image.ColorMap = GifMakeMapObject(ColorMap->ColorCount,
-                                                ColorMap->Colors);
-        if (GifFile->Image.ColorMap == NULL) {
-            GifFile->Error = E_GIF_ERR_NOT_ENOUGH_MEM;
-            return GIF_ERROR;
-        }
-    } else {
-        GifFile->Image.ColorMap = NULL;
-    }
-
-    /* Put the image descriptor into the file: */
-    Buf[0] = DESCRIPTOR_INTRODUCER;    /* Image separator character. */
-    InternalWrite(GifFile, Buf, 1);
-    (void)EGifPutWord(Left, GifFile);
-    (void)EGifPutWord(Top, GifFile);
-    (void)EGifPutWord(Width, GifFile);
-    (void)EGifPutWord(Height, GifFile);
-    Buf[0] = (ColorMap ? 0x80 : 0x00) |
-       (Interlace ? 0x40 : 0x00) |
-       (ColorMap ? ColorMap->BitsPerPixel - 1 : 0);
-    InternalWrite(GifFile, Buf, 1);
-
-    /* If we have Global color map - dump it also: */
-    if (ColorMap != NULL) {
-	int i;
-        for (i = 0; i < ColorMap->ColorCount; i++) {
-            /* Put the ColorMap out also: */
-            Buf[0] = ColorMap->Colors[i].Red;
-            Buf[1] = ColorMap->Colors[i].Green;
-            Buf[2] = ColorMap->Colors[i].Blue;
-            if (InternalWrite(GifFile, Buf, 3) != 3) {
-                GifFile->Error = E_GIF_ERR_WRITE_FAILED;
-                return GIF_ERROR;
-            }
-        }
-    }
-    if (GifFile->SColorMap == NULL && GifFile->Image.ColorMap == NULL) {
-        GifFile->Error = E_GIF_ERR_NO_COLOR_MAP;
-        return GIF_ERROR;
-    }
-
-    /* Mark this file as has screen descriptor: */
-    Private->FileState |= FILE_STATE_IMAGE;
-    Private->PixelCount = (long)Width *(long)Height;
-
-    /* Reset compress algorithm parameters. */
-    (void)EGifSetupCompress(GifFile);
-
-    return GIF_OK;
+	if (!IS_WRITEABLE(Private)) {
+		/* This file was NOT open for writing: */
+		GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
+		return GIF_ERROR;
+	}
+	GifFile->Image.Left = Left;
+	GifFile->Image.Top = Top;
+	GifFile->Image.Width = Width;
+	GifFile->Image.Height = Height;
+	GifFile->Image.Interlace = Interlace;
+	if (ColorMap != GifFile->Image.ColorMap) {
+		if (ColorMap) {
+			if (GifFile->Image.ColorMap != NULL) {
+				GifFreeMapObject(GifFile->Image.ColorMap);
+				GifFile->Image.ColorMap = NULL;
+			}
+			GifFile->Image.ColorMap = GifMakeMapObject(
+			    ColorMap->ColorCount, ColorMap->Colors);
+			if (GifFile->Image.ColorMap == NULL) {
+				GifFile->Error = E_GIF_ERR_NOT_ENOUGH_MEM;
+				return GIF_ERROR;
+			}
+		} else {
+			GifFile->Image.ColorMap = NULL;
+		}
+	}
+
+	/* Put the image descriptor into the file: */
+	Buf[0] = DESCRIPTOR_INTRODUCER; /* Image separator character. */
+	InternalWrite(GifFile, Buf, 1);
+	(void)EGifPutWord(Left, GifFile);
+	(void)EGifPutWord(Top, GifFile);
+	(void)EGifPutWord(Width, GifFile);
+	(void)EGifPutWord(Height, GifFile);
+	Buf[0] = (ColorMap ? 0x80 : 0x00) | (Interlace ? 0x40 : 0x00) |
+	         (ColorMap ? ColorMap->BitsPerPixel - 1 : 0);
+	InternalWrite(GifFile, Buf, 1);
+
+	/* If we have Global color map - dump it also: */
+	if (ColorMap != NULL) {
+		int i;
+		for (i = 0; i < ColorMap->ColorCount; i++) {
+			/* Put the ColorMap out also: */
+			Buf[0] = ColorMap->Colors[i].Red;
+			Buf[1] = ColorMap->Colors[i].Green;
+			Buf[2] = ColorMap->Colors[i].Blue;
+			if (InternalWrite(GifFile, Buf, 3) != 3) {
+				GifFile->Error = E_GIF_ERR_WRITE_FAILED;
+				return GIF_ERROR;
+			}
+		}
+	}
+	if (GifFile->SColorMap == NULL && GifFile->Image.ColorMap == NULL) {
+		GifFile->Error = E_GIF_ERR_NO_COLOR_MAP;
+		return GIF_ERROR;
+	}
+
+	/* Mark this file as has screen descriptor: */
+	Private->FileState |= FILE_STATE_IMAGE;
+	Private->PixelCount = (long)Width * (long)Height;
+
+	/* Reset compress algorithm parameters. */
+	(void)EGifSetupCompress(GifFile);
+
+	return GIF_OK;
 }
 
 /******************************************************************************
  Put one full scanned line (Line) of length LineLen into GIF file.
 ******************************************************************************/
-int
-EGifPutLine(GifFileType * GifFile, GifPixelType *Line, int LineLen)
-{
-    int i;
-    GifPixelType Mask;
-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;
-
-    if (!IS_WRITEABLE(Private)) {
-        /* This file was NOT open for writing: */
-        GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
-        return GIF_ERROR;
-    }
-
-    if (!LineLen)
-        LineLen = GifFile->Image.Width;
-    if (Private->PixelCount < (unsigned)LineLen) {
-        GifFile->Error = E_GIF_ERR_DATA_TOO_BIG;
-        return GIF_ERROR;
-    }
-    Private->PixelCount -= LineLen;
-
-    /* Make sure the codes are not out of bit range, as we might generate
-     * wrong code (because of overflow when we combine them) in this case: */
-    Mask = CodeMask[Private->BitsPerPixel];
-    for (i = 0; i < LineLen; i++)
-        Line[i] &= Mask;
-
-    return EGifCompressLine(GifFile, Line, LineLen);
+int EGifPutLine(GifFileType *GifFile, GifPixelType *Line, int LineLen) {
+	int i;
+	GifPixelType Mask;
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	if (!IS_WRITEABLE(Private)) {
+		/* This file was NOT open for writing: */
+		GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
+		return GIF_ERROR;
+	}
+
+	if (!LineLen) {
+		LineLen = GifFile->Image.Width;
+	}
+	if (Private->PixelCount < (unsigned)LineLen) {
+		GifFile->Error = E_GIF_ERR_DATA_TOO_BIG;
+		return GIF_ERROR;
+	}
+	Private->PixelCount -= LineLen;
+
+	/* Make sure the codes are not out of bit range, as we might generate
+	 * wrong code (because of overflow when we combine them) in this case:
+	 */
+	Mask = CodeMask[Private->BitsPerPixel];
+	for (i = 0; i < LineLen; i++) {
+		Line[i] &= Mask;
+	}
+
+	return EGifCompressLine(GifFile, Line, LineLen);
 }
 
 /******************************************************************************
  Put one pixel (Pixel) into GIF file.
 ******************************************************************************/
-int
-EGifPutPixel(GifFileType *GifFile, GifPixelType Pixel)
-{
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
-
-    if (!IS_WRITEABLE(Private)) {
-        /* This file was NOT open for writing: */
-        GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
-        return GIF_ERROR;
-    }
-
-    if (Private->PixelCount == 0) {
-        GifFile->Error = E_GIF_ERR_DATA_TOO_BIG;
-        return GIF_ERROR;
-    }
-    --Private->PixelCount;
-
-    /* Make sure the code is not out of bit range, as we might generate
-     * wrong code (because of overflow when we combine them) in this case: */
-    Pixel &= CodeMask[Private->BitsPerPixel];
-
-    return EGifCompressLine(GifFile, &Pixel, 1);
+int EGifPutPixel(GifFileType *GifFile, GifPixelType Pixel) {
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	if (!IS_WRITEABLE(Private)) {
+		/* This file was NOT open for writing: */
+		GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
+		return GIF_ERROR;
+	}
+
+	if (Private->PixelCount == 0) {
+		GifFile->Error = E_GIF_ERR_DATA_TOO_BIG;
+		return GIF_ERROR;
+	}
+	--Private->PixelCount;
+
+	/* Make sure the code is not out of bit range, as we might generate
+	 * wrong code (because of overflow when we combine them) in this case:
+	 */
+	Pixel &= CodeMask[Private->BitsPerPixel];
+
+	return EGifCompressLine(GifFile, &Pixel, 1);
 }
 
 /******************************************************************************
  Put a comment into GIF file using the GIF89 comment extension block.
 ******************************************************************************/
-int
-EGifPutComment(GifFileType *GifFile, const char *Comment)
-{
-    unsigned int length;
-    char *buf;
-
-    length = strlen(Comment);
-    if (length <= 255) {
-        return EGifPutExtension(GifFile, COMMENT_EXT_FUNC_CODE,
-                                length, Comment);
-    } else {
-        buf = (char *)Comment;
-        if (EGifPutExtensionLeader(GifFile, COMMENT_EXT_FUNC_CODE)
-                == GIF_ERROR) {
-            return GIF_ERROR;
-        }
-
-        /* Break the comment into 255 byte sub blocks */
-        while (length > 255) {
-            if (EGifPutExtensionBlock(GifFile, 255, buf) == GIF_ERROR) {
-                return GIF_ERROR;
-            }
-            buf = buf + 255;
-            length -= 255;
-        }
-        /* Output any partial block and the clear code. */
-        if (length > 0) {
-            if (EGifPutExtensionBlock(GifFile, length, buf) == GIF_ERROR) {
-                return GIF_ERROR;
-            }
-        }
-	if (EGifPutExtensionTrailer(GifFile) == GIF_ERROR) {
-	    return GIF_ERROR;
-        }
-    }
-    return GIF_OK;
+int EGifPutComment(GifFileType *GifFile, const char *Comment) {
+	unsigned int length;
+	char *buf;
+
+	length = strlen(Comment);
+	if (length <= 255) {
+		return EGifPutExtension(GifFile, COMMENT_EXT_FUNC_CODE, length,
+		                        Comment);
+	} else {
+		buf = (char *)Comment;
+		if (EGifPutExtensionLeader(GifFile, COMMENT_EXT_FUNC_CODE) ==
+		    GIF_ERROR) {
+			return GIF_ERROR;
+		}
+
+		/* Break the comment into 255 byte sub blocks */
+		while (length > 255) {
+			if (EGifPutExtensionBlock(GifFile, 255, buf) ==
+			    GIF_ERROR) {
+				return GIF_ERROR;
+			}
+			buf = buf + 255;
+			length -= 255;
+		}
+		/* Output any partial block and the clear code. */
+		if (length > 0) {
+			if (EGifPutExtensionBlock(GifFile, length, buf) ==
+			    GIF_ERROR) {
+				return GIF_ERROR;
+			}
+		}
+		if (EGifPutExtensionTrailer(GifFile) == GIF_ERROR) {
+			return GIF_ERROR;
+		}
+	}
+	return GIF_OK;
 }
 
 /******************************************************************************
@@ -544,69 +550,63 @@ EGifPutComment(GifFileType *GifFile, const char *Comment)
  extensions can be dumped using EGifPutExtensionBlock until
  EGifPutExtensionTrailer is invoked.
 ******************************************************************************/
-int
-EGifPutExtensionLeader(GifFileType *GifFile, const int ExtCode)
-{
-    GifByteType Buf[3];
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
-
-    if (!IS_WRITEABLE(Private)) {
-        /* This file was NOT open for writing: */
-        GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
-        return GIF_ERROR;
-    }
-
-    Buf[0] = EXTENSION_INTRODUCER;
-    Buf[1] = ExtCode;
-    InternalWrite(GifFile, Buf, 2);
-
-    return GIF_OK;
+int EGifPutExtensionLeader(GifFileType *GifFile, const int ExtCode) {
+	GifByteType Buf[3];
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	if (!IS_WRITEABLE(Private)) {
+		/* This file was NOT open for writing: */
+		GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
+		return GIF_ERROR;
+	}
+
+	Buf[0] = EXTENSION_INTRODUCER;
+	Buf[1] = ExtCode;
+	InternalWrite(GifFile, Buf, 2);
+
+	return GIF_OK;
 }
 
 /******************************************************************************
  Put extension block data (see GIF manual) into a GIF file.
 ******************************************************************************/
-int
-EGifPutExtensionBlock(GifFileType *GifFile, 
-		     const int ExtLen,
-		     const void *Extension)
-{
-    GifByteType Buf;
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
-
-    if (!IS_WRITEABLE(Private)) {
-        /* This file was NOT open for writing: */
-        GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
-        return GIF_ERROR;
-    }
-
-    Buf = ExtLen;
-    InternalWrite(GifFile, &Buf, 1);
-    InternalWrite(GifFile, Extension, ExtLen);
-
-    return GIF_OK;
+int EGifPutExtensionBlock(GifFileType *GifFile, const int ExtLen,
+                          const void *Extension) {
+	GifByteType Buf;
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	if (!IS_WRITEABLE(Private)) {
+		/* This file was NOT open for writing: */
+		GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
+		return GIF_ERROR;
+	}
+
+	Buf = ExtLen;
+	InternalWrite(GifFile, &Buf, 1);
+	InternalWrite(GifFile, Extension, ExtLen);
+
+	return GIF_OK;
 }
 
 /******************************************************************************
  Put a terminating block (see GIF manual) into a GIF file.
 ******************************************************************************/
-int
-EGifPutExtensionTrailer(GifFileType *GifFile) {
+int EGifPutExtensionTrailer(GifFileType *GifFile) {
 
-    GifByteType Buf;
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+	GifByteType Buf;
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
-    if (!IS_WRITEABLE(Private)) {
-        /* This file was NOT open for writing: */
-        GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
-        return GIF_ERROR;
-    }
+	if (!IS_WRITEABLE(Private)) {
+		/* This file was NOT open for writing: */
+		GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
+		return GIF_ERROR;
+	}
 
-    /* Write the block terminator */
-    Buf = 0;
-    InternalWrite(GifFile, &Buf, 1);
+	/* Write the block terminator */
+	Buf = 0;
+	InternalWrite(GifFile, &Buf, 1);
 
-    return GIF_OK;
+	return GIF_OK;
 }
 
 /******************************************************************************
@@ -615,34 +615,31 @@ EGifPutExtensionTrailer(GifFileType *GifFile) {
  most one subblock.  Extensions with more than one subblock need to use the
  EGifPutExtension{Leader,Block,Trailer} functions instead.
 ******************************************************************************/
-int
-EGifPutExtension(GifFileType *GifFile,
-                 const int ExtCode,
-                 const int ExtLen,
-                 const void *Extension) {
-
-    GifByteType Buf[3];
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
-
-    if (!IS_WRITEABLE(Private)) {
-        /* This file was NOT open for writing: */
-        GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
-        return GIF_ERROR;
-    }
-
-    if (ExtCode == 0)
-        InternalWrite(GifFile, (GifByteType *)&ExtLen, 1);
-    else {
-        Buf[0] = EXTENSION_INTRODUCER;
-        Buf[1] = ExtCode;   /* Extension Label */
-        Buf[2] = ExtLen;    /* Extension length */
-        InternalWrite(GifFile, Buf, 3);
-    }
-    InternalWrite(GifFile, Extension, ExtLen);
-    Buf[0] = 0;
-    InternalWrite(GifFile, Buf, 1);
-
-    return GIF_OK;
+int EGifPutExtension(GifFileType *GifFile, const int ExtCode, const int ExtLen,
+                     const void *Extension) {
+
+	GifByteType Buf[3];
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	if (!IS_WRITEABLE(Private)) {
+		/* This file was NOT open for writing: */
+		GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
+		return GIF_ERROR;
+	}
+
+	if (ExtCode == 0) {
+		InternalWrite(GifFile, (GifByteType *)&ExtLen, 1);
+	} else {
+		Buf[0] = EXTENSION_INTRODUCER;
+		Buf[1] = ExtCode; /* Extension Label */
+		Buf[2] = ExtLen;  /* Extension length */
+		InternalWrite(GifFile, Buf, 3);
+	}
+	InternalWrite(GifFile, Extension, ExtLen);
+	Buf[0] = 0;
+	InternalWrite(GifFile, Buf, 1);
+
+	return GIF_OK;
 }
 
 /******************************************************************************
@@ -650,49 +647,52 @@ EGifPutExtension(GifFileType *GifFile,
 ******************************************************************************/
 
 size_t EGifGCBToExtension(const GraphicsControlBlock *GCB,
-		       GifByteType *GifExtension)
-{
-    GifExtension[0] = 0;
-    GifExtension[0] |= (GCB->TransparentColor == NO_TRANSPARENT_COLOR) ? 0x00 : 0x01;
-    GifExtension[0] |= GCB->UserInputFlag ? 0x02 : 0x00;
-    GifExtension[0] |= ((GCB->DisposalMode & 0x07) << 2);
-    GifExtension[1] = LOBYTE(GCB->DelayTime);
-    GifExtension[2] = HIBYTE(GCB->DelayTime);
-    GifExtension[3] = (char)GCB->TransparentColor;
-    return 4;
+                          GifByteType *GifExtension) {
+	GifExtension[0] = 0;
+	GifExtension[0] |=
+	    (GCB->TransparentColor == NO_TRANSPARENT_COLOR) ? 0x00 : 0x01;
+	GifExtension[0] |= GCB->UserInputFlag ? 0x02 : 0x00;
+	GifExtension[0] |= ((GCB->DisposalMode & 0x07) << 2);
+	GifExtension[1] = LOBYTE(GCB->DelayTime);
+	GifExtension[2] = HIBYTE(GCB->DelayTime);
+	GifExtension[3] = (char)GCB->TransparentColor;
+	return 4;
 }
 
 /******************************************************************************
  Replace the Graphics Control Block for a saved image, if it exists.
 ******************************************************************************/
 
-int EGifGCBToSavedExtension(const GraphicsControlBlock *GCB, 
-			    GifFileType *GifFile, int ImageIndex)
-{
-    int i;
-    size_t Len;
-    GifByteType buf[sizeof(GraphicsControlBlock)]; /* a bit dodgy... */
-
-    if (ImageIndex < 0 || ImageIndex > GifFile->ImageCount - 1)
-	return GIF_ERROR;
-
-    for (i = 0; i < GifFile->SavedImages[ImageIndex].ExtensionBlockCount; i++) {
-	ExtensionBlock *ep = &GifFile->SavedImages[ImageIndex].ExtensionBlocks[i];
-	if (ep->Function == GRAPHICS_EXT_FUNC_CODE) {
-	    EGifGCBToExtension(GCB, ep->Bytes);
-	    return GIF_OK;
+int EGifGCBToSavedExtension(const GraphicsControlBlock *GCB,
+                            GifFileType *GifFile, int ImageIndex) {
+	int i;
+	size_t Len;
+	GifByteType buf[sizeof(GraphicsControlBlock)]; /* a bit dodgy... */
+
+	if (ImageIndex < 0 || ImageIndex > GifFile->ImageCount - 1) {
+		return GIF_ERROR;
+	}
+
+	for (i = 0; i < GifFile->SavedImages[ImageIndex].ExtensionBlockCount;
+	     i++) {
+		ExtensionBlock *ep =
+		    &GifFile->SavedImages[ImageIndex].ExtensionBlocks[i];
+		if (ep->Function == GRAPHICS_EXT_FUNC_CODE) {
+			EGifGCBToExtension(GCB, ep->Bytes);
+			return GIF_OK;
+		}
 	}
-    }
 
-    Len = EGifGCBToExtension(GCB, (GifByteType *)buf);
-    if (GifAddExtensionBlock(&GifFile->SavedImages[ImageIndex].ExtensionBlockCount,
-			     &GifFile->SavedImages[ImageIndex].ExtensionBlocks,
-			     GRAPHICS_EXT_FUNC_CODE,
-			     Len,
-			     (unsigned char *)buf) == GIF_ERROR)
-	return (GIF_ERROR);
+	Len = EGifGCBToExtension(GCB, (GifByteType *)buf);
+	if (GifAddExtensionBlock(
+	        &GifFile->SavedImages[ImageIndex].ExtensionBlockCount,
+	        &GifFile->SavedImages[ImageIndex].ExtensionBlocks,
+	        GRAPHICS_EXT_FUNC_CODE, Len,
+	        (unsigned char *)buf) == GIF_ERROR) {
+		return (GIF_ERROR);
+	}
 
-    return (GIF_OK);
+	return (GIF_OK);
 }
 
 /******************************************************************************
@@ -702,27 +702,26 @@ int EGifGCBToSavedExtension(const GraphicsControlBlock *GCB,
  to EGifPutCodeNext, until NULL block is given.
  The block should NOT be freed by the user (not dynamically allocated).
 ******************************************************************************/
-int
-EGifPutCode(GifFileType *GifFile, int CodeSize, const GifByteType *CodeBlock)
-{
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
-
-    if (!IS_WRITEABLE(Private)) {
-        /* This file was NOT open for writing: */
-        GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
-        return GIF_ERROR;
-    }
-
-    /* No need to dump code size as Compression set up does any for us: */
-    /* 
-     * Buf = CodeSize;
-     * if (InternalWrite(GifFile, &Buf, 1) != 1) {
-     *      GifFile->Error = E_GIF_ERR_WRITE_FAILED;
-     *      return GIF_ERROR;
-     * }
-     */
-
-    return EGifPutCodeNext(GifFile, CodeBlock);
+int EGifPutCode(GifFileType *GifFile, int CodeSize,
+                const GifByteType *CodeBlock) {
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	if (!IS_WRITEABLE(Private)) {
+		/* This file was NOT open for writing: */
+		GifFile->Error = E_GIF_ERR_NOT_WRITEABLE;
+		return GIF_ERROR;
+	}
+
+	/* No need to dump code size as Compression set up does any for us: */
+	/*
+	 * Buf = CodeSize;
+	 * if (InternalWrite(GifFile, &Buf, 1) != 1) {
+	 *      GifFile->Error = E_GIF_ERR_WRITE_FAILED;
+	 *      return GIF_ERROR;
+	 * }
+	 */
+
+	return EGifPutCodeNext(GifFile, CodeBlock);
 }
 
 /******************************************************************************
@@ -730,145 +729,142 @@ EGifPutCode(GifFileType *GifFile, int CodeSize, const GifByteType *CodeBlock)
  called with blocks of code as read via DGifGetCode/DGifGetCodeNext. If
  given buffer pointer is NULL, empty block is written to mark end of code.
 ******************************************************************************/
-int
-EGifPutCodeNext(GifFileType *GifFile, const GifByteType *CodeBlock)
-{
-    GifByteType Buf;
-    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
-
-    if (CodeBlock != NULL) {
-        if (InternalWrite(GifFile, CodeBlock, CodeBlock[0] + 1)
-               != (unsigned)(CodeBlock[0] + 1)) {
-            GifFile->Error = E_GIF_ERR_WRITE_FAILED;
-            return GIF_ERROR;
-        }
-    } else {
-        Buf = 0;
-        if (InternalWrite(GifFile, &Buf, 1) != 1) {
-            GifFile->Error = E_GIF_ERR_WRITE_FAILED;
-            return GIF_ERROR;
-        }
-        Private->PixelCount = 0;    /* And local info. indicate image read. */
-    }
-
-    return GIF_OK;
+int EGifPutCodeNext(GifFileType *GifFile, const GifByteType *CodeBlock) {
+	GifByteType Buf;
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	if (CodeBlock != NULL) {
+		if (InternalWrite(GifFile, CodeBlock, CodeBlock[0] + 1) !=
+		    (unsigned)(CodeBlock[0] + 1)) {
+			GifFile->Error = E_GIF_ERR_WRITE_FAILED;
+			return GIF_ERROR;
+		}
+	} else {
+		Buf = 0;
+		if (InternalWrite(GifFile, &Buf, 1) != 1) {
+			GifFile->Error = E_GIF_ERR_WRITE_FAILED;
+			return GIF_ERROR;
+		}
+		Private->PixelCount =
+		    0; /* And local info. indicate image read. */
+	}
+
+	return GIF_OK;
 }
 
 /******************************************************************************
  This routine should be called last, to close the GIF file.
 ******************************************************************************/
-int
-EGifCloseFile(GifFileType *GifFile, int *ErrorCode)
-{
-    GifByteType Buf;
-    GifFilePrivateType *Private;
-    FILE *File;
-
-    if (GifFile == NULL)
-        return GIF_ERROR;
-
-    Private = (GifFilePrivateType *) GifFile->Private;
-    if (Private == NULL)
-	return GIF_ERROR;
-    if (!IS_WRITEABLE(Private)) {
-        /* This file was NOT open for writing: */
-	if (ErrorCode != NULL)
-	    *ErrorCode = E_GIF_ERR_NOT_WRITEABLE;
-	free(GifFile);
-        return GIF_ERROR;
-    }
-
-    File = Private->File;
-
-    Buf = TERMINATOR_INTRODUCER;
-    InternalWrite(GifFile, &Buf, 1);
-
-    if (GifFile->Image.ColorMap) {
-        GifFreeMapObject(GifFile->Image.ColorMap);
-        GifFile->Image.ColorMap = NULL;
-    }
-    if (GifFile->SColorMap) {
-        GifFreeMapObject(GifFile->SColorMap);
-        GifFile->SColorMap = NULL;
-    }
-    if (Private) {
-        if (Private->HashTable) {
-            free((char *) Private->HashTable);
-        }
-	free((char *) Private);
-    }
-
-    if (File && fclose(File) != 0) {
-	if (ErrorCode != NULL)
-	    *ErrorCode = E_GIF_ERR_CLOSE_FAILED;
-	free(GifFile);
-        return GIF_ERROR;
-    }
-
-    free(GifFile);
-    if (ErrorCode != NULL)
-	*ErrorCode = E_GIF_SUCCEEDED;
-    return GIF_OK;
+int EGifCloseFile(GifFileType *GifFile, int *ErrorCode) {
+	GifByteType Buf;
+	GifFilePrivateType *Private;
+	FILE *File;
+
+	if (GifFile == NULL) {
+		return GIF_ERROR;
+	}
+
+	Private = (GifFilePrivateType *)GifFile->Private;
+	if (Private == NULL) {
+		return GIF_ERROR;
+	} else if (!IS_WRITEABLE(Private)) {
+		/* This file was NOT open for writing: */
+		if (ErrorCode != NULL) {
+			*ErrorCode = E_GIF_ERR_NOT_WRITEABLE;
+		}
+		free(GifFile);
+		return GIF_ERROR;
+	} else {
+		File = Private->File;
+
+		Buf = TERMINATOR_INTRODUCER;
+		InternalWrite(GifFile, &Buf, 1);
+
+		if (GifFile->Image.ColorMap) {
+			GifFreeMapObject(GifFile->Image.ColorMap);
+			GifFile->Image.ColorMap = NULL;
+		}
+		if (GifFile->SColorMap) {
+			GifFreeMapObject(GifFile->SColorMap);
+			GifFile->SColorMap = NULL;
+		}
+		if (Private->HashTable) {
+			free((char *)Private->HashTable);
+		}
+		free((char *)Private);
+
+		if (File && fclose(File) != 0) {
+			if (ErrorCode != NULL) {
+				*ErrorCode = E_GIF_ERR_CLOSE_FAILED;
+			}
+			free(GifFile);
+			return GIF_ERROR;
+		}
+
+		free(GifFile);
+		if (ErrorCode != NULL) {
+			*ErrorCode = E_GIF_SUCCEEDED;
+		}
+	}
+	return GIF_OK;
 }
 
 /******************************************************************************
  Put 2 bytes (a word) into the given file in little-endian order:
 ******************************************************************************/
-static int
-EGifPutWord(int Word, GifFileType *GifFile)
-{
-    unsigned char c[2];
-
-    c[0] = LOBYTE(Word);
-    c[1] = HIBYTE(Word);
-    if (InternalWrite(GifFile, c, 2) == 2)
-        return GIF_OK;
-    else
-        return GIF_ERROR;
+static int EGifPutWord(int Word, GifFileType *GifFile) {
+	unsigned char c[2];
+
+	c[0] = LOBYTE(Word);
+	c[1] = HIBYTE(Word);
+	if (InternalWrite(GifFile, c, 2) == 2) {
+		return GIF_OK;
+	} else {
+		return GIF_ERROR;
+	}
 }
 
 /******************************************************************************
  Setup the LZ compression for this image:
 ******************************************************************************/
-static int
-EGifSetupCompress(GifFileType *GifFile)
-{
-    int BitsPerPixel;
-    GifByteType Buf;
-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;
-
-    /* Test and see what color map to use, and from it # bits per pixel: */
-    if (GifFile->Image.ColorMap)
-        BitsPerPixel = GifFile->Image.ColorMap->BitsPerPixel;
-    else if (GifFile->SColorMap)
-        BitsPerPixel = GifFile->SColorMap->BitsPerPixel;
-    else {
-        GifFile->Error = E_GIF_ERR_NO_COLOR_MAP;
-        return GIF_ERROR;
-    }
-
-    Buf = BitsPerPixel = (BitsPerPixel < 2 ? 2 : BitsPerPixel);
-    InternalWrite(GifFile, &Buf, 1);    /* Write the Code size to file. */
-
-    Private->Buf[0] = 0;    /* Nothing was output yet. */
-    Private->BitsPerPixel = BitsPerPixel;
-    Private->ClearCode = (1 << BitsPerPixel);
-    Private->EOFCode = Private->ClearCode + 1;
-    Private->RunningCode = Private->EOFCode + 1;
-    Private->RunningBits = BitsPerPixel + 1;    /* Number of bits per code. */
-    Private->MaxCode1 = 1 << Private->RunningBits;    /* Max. code + 1. */
-    Private->CrntCode = FIRST_CODE;    /* Signal that this is first one! */
-    Private->CrntShiftState = 0;    /* No information in CrntShiftDWord. */
-    Private->CrntShiftDWord = 0;
-
-   /* Clear hash table and send Clear to make sure the decoder do the same. */
-    _ClearHashTable(Private->HashTable);
-
-    if (EGifCompressOutput(GifFile, Private->ClearCode) == GIF_ERROR) {
-        GifFile->Error = E_GIF_ERR_DISK_IS_FULL;
-        return GIF_ERROR;
-    }
-    return GIF_OK;
+static int EGifSetupCompress(GifFileType *GifFile) {
+	int BitsPerPixel;
+	GifByteType Buf;
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	/* Test and see what color map to use, and from it # bits per pixel: */
+	if (GifFile->Image.ColorMap) {
+		BitsPerPixel = GifFile->Image.ColorMap->BitsPerPixel;
+	} else if (GifFile->SColorMap) {
+		BitsPerPixel = GifFile->SColorMap->BitsPerPixel;
+	} else {
+		GifFile->Error = E_GIF_ERR_NO_COLOR_MAP;
+		return GIF_ERROR;
+	}
+
+	Buf = BitsPerPixel = (BitsPerPixel < 2 ? 2 : BitsPerPixel);
+	InternalWrite(GifFile, &Buf, 1); /* Write the Code size to file. */
+
+	Private->Buf[0] = 0; /* Nothing was output yet. */
+	Private->BitsPerPixel = BitsPerPixel;
+	Private->ClearCode = (1 << BitsPerPixel);
+	Private->EOFCode = Private->ClearCode + 1;
+	Private->RunningCode = Private->EOFCode + 1;
+	Private->RunningBits = BitsPerPixel + 1; /* Number of bits per code. */
+	Private->MaxCode1 = 1 << Private->RunningBits; /* Max. code + 1. */
+	Private->CrntCode = FIRST_CODE; /* Signal that this is first one! */
+	Private->CrntShiftState = 0;    /* No information in CrntShiftDWord. */
+	Private->CrntShiftDWord = 0;
+
+	/* Clear hash table and send Clear to make sure the decoder do the same.
+	 */
+	_ClearHashTable(Private->HashTable);
+
+	if (EGifCompressOutput(GifFile, Private->ClearCode) == GIF_ERROR) {
+		GifFile->Error = E_GIF_ERR_DISK_IS_FULL;
+		return GIF_ERROR;
+	}
+	return GIF_OK;
 }
 
 /******************************************************************************
@@ -877,87 +873,91 @@ EGifSetupCompress(GifFileType *GifFile)
  This routine can be called a few times (one per scan line, for example), in
  order to complete the whole image.
 ******************************************************************************/
-static int
-EGifCompressLine(GifFileType *GifFile,
-                 GifPixelType *Line,
-                 const int LineLen)
-{
-    int i = 0, CrntCode, NewCode;
-    unsigned long NewKey;
-    GifPixelType Pixel;
-    GifHashTableType *HashTable;
-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;
-
-    HashTable = Private->HashTable;
-
-    if (Private->CrntCode == FIRST_CODE)    /* Its first time! */
-        CrntCode = Line[i++];
-    else
-        CrntCode = Private->CrntCode;    /* Get last code in compression. */
-
-    while (i < LineLen) {   /* Decode LineLen items. */
-        Pixel = Line[i++];  /* Get next pixel from stream. */
-        /* Form a new unique key to search hash table for the code combines 
-         * CrntCode as Prefix string with Pixel as postfix char.
-         */
-        NewKey = (((uint32_t) CrntCode) << 8) + Pixel;
-        if ((NewCode = _ExistsHashTable(HashTable, NewKey)) >= 0) {
-            /* This Key is already there, or the string is old one, so
-             * simple take new code as our CrntCode:
-             */
-            CrntCode = NewCode;
-        } else {
-            /* Put it in hash table, output the prefix code, and make our
-             * CrntCode equal to Pixel.
-             */
-            if (EGifCompressOutput(GifFile, CrntCode) == GIF_ERROR) {
-                GifFile->Error = E_GIF_ERR_DISK_IS_FULL;
-                return GIF_ERROR;
-            }
-            CrntCode = Pixel;
-
-            /* If however the HashTable if full, we send a clear first and
-             * Clear the hash table.
-             */
-            if (Private->RunningCode >= LZ_MAX_CODE) {
-                /* Time to do some clearance: */
-                if (EGifCompressOutput(GifFile, Private->ClearCode)
-                        == GIF_ERROR) {
-                    GifFile->Error = E_GIF_ERR_DISK_IS_FULL;
-                    return GIF_ERROR;
-                }
-                Private->RunningCode = Private->EOFCode + 1;
-                Private->RunningBits = Private->BitsPerPixel + 1;
-                Private->MaxCode1 = 1 << Private->RunningBits;
-                _ClearHashTable(HashTable);
-            } else {
-                /* Put this unique key with its relative Code in hash table: */
-                _InsertHashTable(HashTable, NewKey, Private->RunningCode++);
-            }
-        }
-
-    }
-
-    /* Preserve the current state of the compression algorithm: */
-    Private->CrntCode = CrntCode;
-
-    if (Private->PixelCount == 0) {
-        /* We are done - output last Code and flush output buffers: */
-        if (EGifCompressOutput(GifFile, CrntCode) == GIF_ERROR) {
-            GifFile->Error = E_GIF_ERR_DISK_IS_FULL;
-            return GIF_ERROR;
-        }
-        if (EGifCompressOutput(GifFile, Private->EOFCode) == GIF_ERROR) {
-            GifFile->Error = E_GIF_ERR_DISK_IS_FULL;
-            return GIF_ERROR;
-        }
-        if (EGifCompressOutput(GifFile, FLUSH_OUTPUT) == GIF_ERROR) {
-            GifFile->Error = E_GIF_ERR_DISK_IS_FULL;
-            return GIF_ERROR;
-        }
-    }
-
-    return GIF_OK;
+static int EGifCompressLine(GifFileType *GifFile, const GifPixelType *Line,
+                            const int LineLen) {
+	int i = 0, CrntCode;
+	GifHashTableType *HashTable;
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+
+	HashTable = Private->HashTable;
+
+	if (Private->CrntCode == FIRST_CODE) { /* Its first time! */
+		CrntCode = Line[i++];
+	} else {
+		CrntCode =
+		    Private->CrntCode; /* Get last code in compression. */
+	}
+	while (i < LineLen) { /* Decode LineLen items. */
+		GifPixelType Pixel =
+		    Line[i++]; /* Get next pixel from stream. */
+		/* Form a new unique key to search hash table for the code
+		 * combines CrntCode as Prefix string with Pixel as postfix
+		 * char.
+		 */
+		int NewCode;
+		unsigned long NewKey = (((uint32_t)CrntCode) << 8) + Pixel;
+		if ((NewCode = _ExistsHashTable(HashTable, NewKey)) >= 0) {
+			/* This Key is already there, or the string is old one,
+			 * so simple take new code as our CrntCode:
+			 */
+			CrntCode = NewCode;
+		} else {
+			/* Put it in hash table, output the prefix code, and
+			 * make our CrntCode equal to Pixel.
+			 */
+			if (EGifCompressOutput(GifFile, CrntCode) ==
+			    GIF_ERROR) {
+				GifFile->Error = E_GIF_ERR_DISK_IS_FULL;
+				return GIF_ERROR;
+			}
+			CrntCode = Pixel;
+
+			/* If however the HashTable if full, we send a clear
+			 * first and Clear the hash table.
+			 */
+			if (Private->RunningCode >= LZ_MAX_CODE) {
+				/* Time to do some clearance: */
+				if (EGifCompressOutput(GifFile,
+				                       Private->ClearCode) ==
+				    GIF_ERROR) {
+					GifFile->Error = E_GIF_ERR_DISK_IS_FULL;
+					return GIF_ERROR;
+				}
+				Private->RunningCode = Private->EOFCode + 1;
+				Private->RunningBits =
+				    Private->BitsPerPixel + 1;
+				Private->MaxCode1 = 1 << Private->RunningBits;
+				_ClearHashTable(HashTable);
+			} else {
+				/* Put this unique key with its relative Code in
+				 * hash table: */
+				_InsertHashTable(HashTable, NewKey,
+				                 Private->RunningCode++);
+			}
+		}
+	}
+
+	/* Preserve the current state of the compression algorithm: */
+	Private->CrntCode = CrntCode;
+
+	if (Private->PixelCount == 0) {
+		/* We are done - output last Code and flush output buffers: */
+		if (EGifCompressOutput(GifFile, CrntCode) == GIF_ERROR) {
+			GifFile->Error = E_GIF_ERR_DISK_IS_FULL;
+			return GIF_ERROR;
+		}
+		if (EGifCompressOutput(GifFile, Private->EOFCode) ==
+		    GIF_ERROR) {
+			GifFile->Error = E_GIF_ERR_DISK_IS_FULL;
+			return GIF_ERROR;
+		}
+		if (EGifCompressOutput(GifFile, FLUSH_OUTPUT) == GIF_ERROR) {
+			GifFile->Error = E_GIF_ERR_DISK_IS_FULL;
+			return GIF_ERROR;
+		}
+	}
+
+	return GIF_OK;
 }
 
 /******************************************************************************
@@ -966,46 +966,49 @@ EGifCompressLine(GifFileType *GifFile,
  8 bits (bytes) packets.
  Returns GIF_OK if written successfully.
 ******************************************************************************/
-static int
-EGifCompressOutput(GifFileType *GifFile,
-                   const int Code)
-{
-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;
-    int retval = GIF_OK;
-
-    if (Code == FLUSH_OUTPUT) {
-        while (Private->CrntShiftState > 0) {
-            /* Get Rid of what is left in DWord, and flush it. */
-            if (EGifBufferedOutput(GifFile, Private->Buf,
-                                 Private->CrntShiftDWord & 0xff) == GIF_ERROR)
-                retval = GIF_ERROR;
-            Private->CrntShiftDWord >>= 8;
-            Private->CrntShiftState -= 8;
-        }
-        Private->CrntShiftState = 0;    /* For next time. */
-        if (EGifBufferedOutput(GifFile, Private->Buf,
-                               FLUSH_OUTPUT) == GIF_ERROR)
-            retval = GIF_ERROR;
-    } else {
-        Private->CrntShiftDWord |= ((long)Code) << Private->CrntShiftState;
-        Private->CrntShiftState += Private->RunningBits;
-        while (Private->CrntShiftState >= 8) {
-            /* Dump out full bytes: */
-            if (EGifBufferedOutput(GifFile, Private->Buf,
-                                 Private->CrntShiftDWord & 0xff) == GIF_ERROR)
-                retval = GIF_ERROR;
-            Private->CrntShiftDWord >>= 8;
-            Private->CrntShiftState -= 8;
-        }
-    }
-
-    /* If code cannt fit into RunningBits bits, must raise its size. Note */
-    /* however that codes above 4095 are used for special signaling.      */
-    if (Private->RunningCode >= Private->MaxCode1 && Code <= 4095) {
-       Private->MaxCode1 = 1 << ++Private->RunningBits;
-    }
-
-    return retval;
+static int EGifCompressOutput(GifFileType *GifFile, const int Code) {
+	GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+	int retval = GIF_OK;
+
+	if (Code == FLUSH_OUTPUT) {
+		while (Private->CrntShiftState > 0) {
+			/* Get Rid of what is left in DWord, and flush it. */
+			if (EGifBufferedOutput(GifFile, Private->Buf,
+			                       Private->CrntShiftDWord &
+			                           0xff) == GIF_ERROR) {
+				retval = GIF_ERROR;
+			}
+			Private->CrntShiftDWord >>= 8;
+			Private->CrntShiftState -= 8;
+		}
+		Private->CrntShiftState = 0; /* For next time. */
+		if (EGifBufferedOutput(GifFile, Private->Buf, FLUSH_OUTPUT) ==
+		    GIF_ERROR) {
+			retval = GIF_ERROR;
+		}
+	} else {
+		Private->CrntShiftDWord |= ((long)Code)
+		                           << Private->CrntShiftState;
+		Private->CrntShiftState += Private->RunningBits;
+		while (Private->CrntShiftState >= 8) {
+			/* Dump out full bytes: */
+			if (EGifBufferedOutput(GifFile, Private->Buf,
+			                       Private->CrntShiftDWord &
+			                           0xff) == GIF_ERROR) {
+				retval = GIF_ERROR;
+			}
+			Private->CrntShiftDWord >>= 8;
+			Private->CrntShiftState -= 8;
+		}
+	}
+
+	/* If code cannt fit into RunningBits bits, must raise its size. Note */
+	/* however that codes above 4095 are used for special signaling.      */
+	if (Private->RunningCode >= Private->MaxCode1 && Code <= 4095) {
+		Private->MaxCode1 = 1 << ++Private->RunningBits;
+	}
+
+	return retval;
 }
 
 /******************************************************************************
@@ -1014,37 +1017,35 @@ EGifCompressOutput(GifFileType *GifFile,
  The buffer is Dumped with first byte as its size, as GIF format requires.
  Returns GIF_OK if written successfully.
 ******************************************************************************/
-static int
-EGifBufferedOutput(GifFileType *GifFile,
-                   GifByteType *Buf,
-                   int c)
-{
-    if (c == FLUSH_OUTPUT) {
-        /* Flush everything out. */
-        if (Buf[0] != 0
-            && InternalWrite(GifFile, Buf, Buf[0] + 1) != (unsigned)(Buf[0] + 1)) {
-            GifFile->Error = E_GIF_ERR_WRITE_FAILED;
-            return GIF_ERROR;
-        }
-        /* Mark end of compressed data, by an empty block (see GIF doc): */
-        Buf[0] = 0;
-        if (InternalWrite(GifFile, Buf, 1) != 1) {
-            GifFile->Error = E_GIF_ERR_WRITE_FAILED;
-            return GIF_ERROR;
-        }
-    } else {
-        if (Buf[0] == 255) {
-            /* Dump out this buffer - it is full: */
-            if (InternalWrite(GifFile, Buf, Buf[0] + 1) != (unsigned)(Buf[0] + 1)) {
-                GifFile->Error = E_GIF_ERR_WRITE_FAILED;
-                return GIF_ERROR;
-            }
-            Buf[0] = 0;
-        }
-        Buf[++Buf[0]] = c;
-    }
-
-    return GIF_OK;
+static int EGifBufferedOutput(GifFileType *GifFile, GifByteType *Buf, int c) {
+	if (c == FLUSH_OUTPUT) {
+		/* Flush everything out. */
+		if (Buf[0] != 0 && InternalWrite(GifFile, Buf, Buf[0] + 1) !=
+		                       (unsigned)(Buf[0] + 1)) {
+			GifFile->Error = E_GIF_ERR_WRITE_FAILED;
+			return GIF_ERROR;
+		}
+		/* Mark end of compressed data, by an empty block (see GIF doc):
+		 */
+		Buf[0] = 0;
+		if (InternalWrite(GifFile, Buf, 1) != 1) {
+			GifFile->Error = E_GIF_ERR_WRITE_FAILED;
+			return GIF_ERROR;
+		}
+	} else {
+		if (Buf[0] == 255) {
+			/* Dump out this buffer - it is full: */
+			if (InternalWrite(GifFile, Buf, Buf[0] + 1) !=
+			    (unsigned)(Buf[0] + 1)) {
+				GifFile->Error = E_GIF_ERR_WRITE_FAILED;
+				return GIF_ERROR;
+			}
+			Buf[0] = 0;
+		}
+		Buf[++Buf[0]] = c;
+	}
+
+	return GIF_OK;
 }
 
 /******************************************************************************
@@ -1052,105 +1053,111 @@ EGifBufferedOutput(GifFileType *GifFile,
  created by DGifSlurp().
 ******************************************************************************/
 
-static int
-EGifWriteExtensions(GifFileType *GifFileOut, 
-			       ExtensionBlock *ExtensionBlocks, 
-			       int ExtensionBlockCount) 
-{
-    if (ExtensionBlocks) {
-        ExtensionBlock *ep;
-	int j;
-
-	for (j = 0; j < ExtensionBlockCount; j++) {
-	    ep = &ExtensionBlocks[j];
-	    if (ep->Function != CONTINUE_EXT_FUNC_CODE)
-		if (EGifPutExtensionLeader(GifFileOut, ep->Function) == GIF_ERROR)
-		    return (GIF_ERROR);
-	    if (EGifPutExtensionBlock(GifFileOut, ep->ByteCount, ep->Bytes) == GIF_ERROR)
-		return (GIF_ERROR);
-	    if (j == ExtensionBlockCount - 1 || (ep+1)->Function != CONTINUE_EXT_FUNC_CODE)
-		if (EGifPutExtensionTrailer(GifFileOut) == GIF_ERROR)
-		    return (GIF_ERROR);
+static int EGifWriteExtensions(GifFileType *GifFileOut,
+                               ExtensionBlock *ExtensionBlocks,
+                               int ExtensionBlockCount) {
+	if (ExtensionBlocks) {
+		int j;
+
+		for (j = 0; j < ExtensionBlockCount; j++) {
+			ExtensionBlock *ep = &ExtensionBlocks[j];
+			if (ep->Function != CONTINUE_EXT_FUNC_CODE) {
+				if (EGifPutExtensionLeader(GifFileOut,
+				                           ep->Function) ==
+				    GIF_ERROR) {
+					return (GIF_ERROR);
+				}
+			}
+			if (EGifPutExtensionBlock(GifFileOut, ep->ByteCount,
+			                          ep->Bytes) == GIF_ERROR) {
+				return (GIF_ERROR);
+			}
+			if (j == ExtensionBlockCount - 1 ||
+			    (ep + 1)->Function != CONTINUE_EXT_FUNC_CODE) {
+				if (EGifPutExtensionTrailer(GifFileOut) ==
+				    GIF_ERROR) {
+					return (GIF_ERROR);
+				}
+			}
+		}
 	}
-    }
 
-    return (GIF_OK);
+	return (GIF_OK);
 }
 
-int
-EGifSpew(GifFileType *GifFileOut) 
-{
-    int i, j; 
-
-    if (EGifPutScreenDesc(GifFileOut,
-                          GifFileOut->SWidth,
-                          GifFileOut->SHeight,
-                          GifFileOut->SColorResolution,
-                          GifFileOut->SBackGroundColor,
-                          GifFileOut->SColorMap) == GIF_ERROR) {
-        return (GIF_ERROR);
-    }
-
-    for (i = 0; i < GifFileOut->ImageCount; i++) {
-        SavedImage *sp = &GifFileOut->SavedImages[i];
-        int SavedHeight = sp->ImageDesc.Height;
-        int SavedWidth = sp->ImageDesc.Width;
-
-        /* this allows us to delete images by nuking their rasters */
-        if (sp->RasterBits == NULL)
-            continue;
-
-	if (EGifWriteExtensions(GifFileOut, 
-				sp->ExtensionBlocks,
-				sp->ExtensionBlockCount) == GIF_ERROR)
-	    return (GIF_ERROR);
-
-        if (EGifPutImageDesc(GifFileOut,
-                             sp->ImageDesc.Left,
-                             sp->ImageDesc.Top,
-                             SavedWidth,
-                             SavedHeight,
-                             sp->ImageDesc.Interlace,
-                             sp->ImageDesc.ColorMap) == GIF_ERROR)
-            return (GIF_ERROR);
-
-	if (sp->ImageDesc.Interlace) {
-	     /* 
-	      * The way an interlaced image should be written - 
-	      * offsets and jumps...
-	      */
-	    int InterlacedOffset[] = { 0, 4, 2, 1 };
-	    int InterlacedJumps[] = { 8, 8, 4, 2 };
-	    int k;
-	    /* Need to perform 4 passes on the images: */
-	    for (k = 0; k < 4; k++)
-		for (j = InterlacedOffset[k]; 
-		     j < SavedHeight;
-		     j += InterlacedJumps[k]) {
-		    if (EGifPutLine(GifFileOut, 
-				    sp->RasterBits + j * SavedWidth, 
-				    SavedWidth)	== GIF_ERROR)
+int EGifSpew(GifFileType *GifFileOut) {
+	int i, j;
+
+	if (EGifPutScreenDesc(GifFileOut, GifFileOut->SWidth,
+	                      GifFileOut->SHeight, GifFileOut->SColorResolution,
+	                      GifFileOut->SBackGroundColor,
+	                      GifFileOut->SColorMap) == GIF_ERROR) {
+		return (GIF_ERROR);
+	}
+
+	for (i = 0; i < GifFileOut->ImageCount; i++) {
+		SavedImage *sp = &GifFileOut->SavedImages[i];
+		int SavedHeight = sp->ImageDesc.Height;
+		int SavedWidth = sp->ImageDesc.Width;
+
+		/* this allows us to delete images by nuking their rasters */
+		if (sp->RasterBits == NULL) {
+			continue;
+		}
+
+		if (EGifWriteExtensions(GifFileOut, sp->ExtensionBlocks,
+		                        sp->ExtensionBlockCount) == GIF_ERROR) {
 			return (GIF_ERROR);
 		}
-	} else {
-	    for (j = 0; j < SavedHeight; j++) {
-		if (EGifPutLine(GifFileOut,
-				sp->RasterBits + j * SavedWidth,
-				SavedWidth) == GIF_ERROR)
-		    return (GIF_ERROR);
-	    }
+
+		if (EGifPutImageDesc(GifFileOut, sp->ImageDesc.Left,
+		                     sp->ImageDesc.Top, SavedWidth, SavedHeight,
+		                     sp->ImageDesc.Interlace,
+		                     sp->ImageDesc.ColorMap) == GIF_ERROR) {
+			return (GIF_ERROR);
+		}
+
+		if (sp->ImageDesc.Interlace) {
+			/*
+			 * The way an interlaced image should be written -
+			 * offsets and jumps...
+			 */
+			static const int InterlacedOffset[] = {0, 4, 2, 1};
+			static const int InterlacedJumps[] = {8, 8, 4, 2};
+			int k;
+			/* Need to perform 4 passes on the images: */
+			for (k = 0; k < 4; k++) {
+				for (j = InterlacedOffset[k]; j < SavedHeight;
+				     j += InterlacedJumps[k]) {
+					if (EGifPutLine(
+					        GifFileOut,
+					        sp->RasterBits + j * SavedWidth,
+					        SavedWidth) == GIF_ERROR) {
+						return (GIF_ERROR);
+					}
+				}
+			}
+		} else {
+			for (j = 0; j < SavedHeight; j++) {
+				if (EGifPutLine(GifFileOut,
+				                sp->RasterBits + j * SavedWidth,
+				                SavedWidth) == GIF_ERROR) {
+					return (GIF_ERROR);
+				}
+			}
+		}
 	}
-    }
 
-    if (EGifWriteExtensions(GifFileOut,
-			    GifFileOut->ExtensionBlocks,
-			    GifFileOut->ExtensionBlockCount) == GIF_ERROR)
-	return (GIF_ERROR);
+	if (EGifWriteExtensions(GifFileOut, GifFileOut->ExtensionBlocks,
+	                        GifFileOut->ExtensionBlockCount) == GIF_ERROR) {
+		return (GIF_ERROR);
+	}
 
-    if (EGifCloseFile(GifFileOut, NULL) == GIF_ERROR)
-        return (GIF_ERROR);
+	if (EGifCloseFile(GifFileOut, NULL) == GIF_ERROR) {
+		return (GIF_ERROR);
+	}
 
-    return (GIF_OK);
+	return (GIF_OK);
 }
 
 /* end */
diff --git a/getarg.c b/getarg.c
new file mode 100644
index 0000000..5c1b0dc
--- /dev/null
+++ b/getarg.c
@@ -0,0 +1,670 @@
+/***************************************************************************
+
+getarg.c - routines to grab the parameters from the command line:
+
+Names of all the routines except the main one start with GA (Get
+Arguments) to prevent conflicts.
+
+The following routines are available in this module:
+
+1. int GAGetArgs(argc, argv, CtrlStr, Variables...)
+where argc, argv are received on entry.
+CtrlStr is the contrl string (see below)
+Variables are all the variables to be set according to CtrlStr.
+Note that all the variables MUST be transfered by address.
+Return 0 on correct parsing, otherwise error number (see GetArg.h).
+
+2. GAPrintHowTo(CtrlStr)
+Print the control string to stderr, in the correct format.
+This feature is very useful in case of an error during GetArgs parsing.
+Chars equal to SPACE_CHAR are not printed (regular spaces are NOT
+allowed, and so using SPACE_CHAR you can create space in PrintHowTo).
+
+3. GAPrintErrMsg(Error)
+Describe the error to stderr, according to Error (usually returned by
+GAGetArgs).
+
+CtrlStr format:
+
+The control string passed to GetArgs controls the way argv (argc) are
+parsed. Each entry in this string must not have any spaces in it. The
+First Entry is the name of the program, which is usually ignored except
+when GAPrintHowTo is called. All the other entries (except the last one
+which we will come back to later) must have the following format:
+
+1. One letter which sets the option letter.
+2. '!' or '%' to determines if this option is really optional ('%') or
+   required ('!')...
+3. '-' must always be given.
+4. Alphanumeric string, usually ignored, but used by GAPrintHowTo to
+   print the meaning of this option.
+5. Sequences starts with '!' or '%'. Again if '!' then this sequence
+   must exist (only if its option flag is given of course), and if '%'
+   it is optional. Each sequence will continue with one or two
+   characters which defines the kind of the input:
+a: d, x, o, u - integer is expected (decimal, hex, octal base or unsigned).
+b: D, X, O, U - long integer is expected (same as above).
+c: f - float number is expected.
+d: F - double number is expected.
+e: s - string is expected.
+f: *? - any number of '?' kind (d, x, o, u, D, X, O, U, f, F, s)
+   will match this one. If '?' is numeric, it scans until
+   non-numeric input is given. If '?' is 's' then it scans
+   up to the next option or end of argv.
+
+If the last parameter given in the CtrlStr, is not an option (i.e. the
+second char is not in ['!', '%'] and the third one is not '-'), all what
+remained from argv is linked to it.
+
+The variables passed to GAGetArgs (starting from 4th parameter) MUST
+match the order of the CtrlStr:
+
+For each option, one integer address must be passed. This integer must
+be initialized with 0. If that option is given in the command line, it will
+be set.
+
+In addition, the sequences that might follow an option require the
+following parameters to pass:
+
+1. d, x, o, u - pointer to integer (int *).
+2. D, X, O, U - pointer to long (long *).
+3. f - pointer to float (float *).
+4. F - pointer to double (double *).
+5. s - pointer to char (char *). NO allocation is needed!
+6. *? - TWO variables are passed for each wild request. the first
+   one is (address of) integer, and it will return number of
+   parameters actually matched this sequence, and the second
+   one is a pointer to pointer to ? (? **), and will return an
+   address to a block of pointers to ? kind, terminated with
+   NULL pointer. NO pre-allocation is required. The caller is
+   responsible for freeing this memory, including the pointed to
+   memory.
+
+Note that these two variables are pretty like the argv/argc pair...
+
+Examples:
+
+"Example1 i%-OneInteger!d s%-Strings!*s j%- k!-Float!f Files"
+
+Will match: Example1 -i 77 -s String1 String2 String3 -k 88.2 File1 File2
+or: Example1 -s String1 -k 88.3 -i 999 -j
+but not: Example1 -i 77 78 (option i expects one integer, k must be).
+
+Note the option k must exist, and that the order of the options is not
+important. In the first examples File1 & File2 will match the Files
+in the command line.
+
+A call to GAPrintHowTo with this CtrlStr will print to stderr:
+Example1 [-i OneIngeter] [-s Strings...] [-j] -k Float Files...
+
+Notes:
+
+1. This module assumes that all the pointers to all kind of data types
+have the same length and format, i.e. sizeof(int *) == sizeof(char *).
+
+SPDX-License-Identifier: MIT
+
+**************************************************************************/
+
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "getarg.h"
+
+#define MAX_PARAM 100 /* maximum number of parameters allowed. */
+#define CTRL_STR_MAX_LEN 1024
+
+#define SPACE_CHAR '|' /* The character not to print using HowTo. */
+
+#define ARG_OK false
+
+#define ISSPACE(x) ((x) <= ' ') /* Not conventional - but works fine! */
+
+/* The two characters '%' and '!' are used in the control string: */
+#define ISCTRLCHAR(x) (((x) == '%') || ((x) == '!'))
+
+static char *GAErrorToken; /* On error, ErrorToken is set to point to it. */
+static int GATestAllSatis(char *CtrlStrCopy, char *CtrlStr,
+                          const char **argv_end, const char ***argv,
+                          void *Parameters[MAX_PARAM], int *ParamCount);
+static int GAUpdateParameters(void *Parameters[], int *ParamCount, char *Option,
+                              char *CtrlStrCopy, char *CtrlStr, char **argv_end,
+                              char ***argv);
+static int GAGetParmeters(void *Parameters[], int *ParamCount,
+                          char *CtrlStrCopy, char *Option, char **argv_end,
+                          char ***argv);
+static int GAGetMultiParmeters(void *Parameters[], int *ParamCount,
+                               char *CtrlStrCopy, char **argv_end,
+                               char ***argv);
+static void GASetParamCount(const char *CtrlStr, const int Max,
+                            int *ParamCount);
+static bool GAOptionExists(const char **argv_end, const char **argv);
+
+/***************************************************************************
+ Allocate or die
+***************************************************************************/
+static void *xmalloc(unsigned size) {
+
+	void *p;
+
+	if ((p = malloc(size)) != NULL) {
+		return p;
+	}
+
+	fprintf(stderr, "Not enough memory, exit.\n");
+	exit(2);
+
+	return NULL; /* Makes warning silent. */
+}
+/***************************************************************************
+ Routine to access the command line argument and interpret them:
+ Return ARG_OK (0) is case of successful parsing, error code else...
+***************************************************************************/
+bool GAGetArgs(int argc, char **argv, char *CtrlStr, ...) {
+
+	int i, ParamCount = 0;
+	void *Parameters[MAX_PARAM]; /* Save here parameter addresses. */
+	char CtrlStrCopy[CTRL_STR_MAX_LEN];
+	const char **argv_end = (const char **)argv + argc;
+	va_list ap;
+
+	strncpy(CtrlStrCopy, CtrlStr, sizeof(CtrlStrCopy) - 1);
+	GASetParamCount(CtrlStr, strlen(CtrlStr), &ParamCount);
+	va_start(ap, CtrlStr);
+	for (i = 1; i <= ParamCount; i++) {
+		Parameters[i - 1] = va_arg(ap, void *);
+	}
+	va_end(ap);
+
+	argv++; /* Skip the program name (first in argv/c list). */
+	while (argv < (char **)argv_end) {
+		bool Error = false;
+		if (!GAOptionExists(argv_end, (const char **)argv)) {
+			break; /* The loop. */
+		}
+		char *Option = *argv++;
+		if ((Error = GAUpdateParameters(
+		         Parameters, &ParamCount, Option, CtrlStrCopy, CtrlStr,
+		         (char **)argv_end, &argv)) != false) {
+			return Error;
+		}
+	}
+	/* Check for results and update trail of command line: */
+	return GATestAllSatis(CtrlStrCopy, CtrlStr, argv_end,
+	                      (const char ***)&argv, Parameters,
+	                      &ParamCount) != ARG_OK;
+}
+
+/***************************************************************************
+ Routine to search for unsatisfied flags - simply scan the list for !-
+ sequence. Before this scan, this routine updates the rest of the command
+ line into the last two parameters if it is requested by the CtrlStr
+ (last item in CtrlStr is NOT an option).
+ Return ARG_OK if all satisfied, CMD_ERR_AllSatis error else.
+***************************************************************************/
+static int GATestAllSatis(char *CtrlStrCopy, char *CtrlStr,
+                          const char **argv_end, const char ***argv,
+                          void *Parameters[MAX_PARAM], int *ParamCount) {
+
+	int i;
+	static char *LocalToken = NULL;
+
+	/* If LocalToken is not initialized - do it now. Note that this string
+	 * should be writable as well so we can not assign it directly.
+	 */
+	if (LocalToken == NULL) {
+		LocalToken = (char *)malloc(3);
+		strcpy(LocalToken, "-?");
+	}
+
+	/* Check if last item is an option. If not then copy rest of command
+	 * line into it as 1. NumOfprm, 2. pointer to block of pointers.
+	 */
+	for (i = strlen(CtrlStr) - 1; i > 0 && !ISSPACE(CtrlStr[i]); i--) {
+		;
+	}
+	if (!ISCTRLCHAR(CtrlStr[i + 2])) {
+		GASetParamCount(CtrlStr, i,
+		                ParamCount); /* Point in correct param. */
+		*(int *)Parameters[(*ParamCount)++] = argv_end - *argv;
+		*(char ***)Parameters[(*ParamCount)++] = *(char ***)argv;
+	}
+
+	i = 0;
+	while (++i < (int)strlen(CtrlStrCopy)) {
+		if ((CtrlStrCopy[i] == '-') && (CtrlStrCopy[i - 1] == '!')) {
+			GAErrorToken = LocalToken;
+			LocalToken[1] =
+			    CtrlStrCopy[i - 2]; /* Set the correct flag. */
+			return CMD_ERR_AllSatis;
+		}
+	}
+
+	return ARG_OK;
+}
+
+/***************************************************************************
+ Routine to update the parameters according to the given Option:
+ **************************************************************************/
+static int GAUpdateParameters(void *Parameters[], int *ParamCount, char *Option,
+                              char *CtrlStrCopy, char *CtrlStr, char **argv_end,
+                              char ***argv) {
+
+	int i;
+	bool BooleanTrue = Option[2] != '-';
+
+	if (Option[0] != '-') {
+		GAErrorToken = Option;
+		return CMD_ERR_NotAnOpt;
+	}
+	i = 0; /* Scan the CtrlStrCopy for that option: */
+	while (i + 2 < (int)strlen(CtrlStrCopy)) {
+		if ((CtrlStrCopy[i] == Option[1]) &&
+		    (ISCTRLCHAR(CtrlStrCopy[i + 1])) &&
+		    (CtrlStrCopy[i + 2] == '-')) {
+			/* We found that option! */
+			break;
+		}
+		i++;
+	}
+	if (i + 2 >= (int)strlen(CtrlStrCopy)) {
+		GAErrorToken = Option;
+		return CMD_ERR_NoSuchOpt;
+	}
+
+	/* If we are here, then we found that option in CtrlStr - Strip it off:
+	 */
+	CtrlStrCopy[i] = CtrlStrCopy[i + 1] = CtrlStrCopy[i + 2] = (char)' ';
+	GASetParamCount(CtrlStr, i, ParamCount); /* Set it to point in
+	                                            correct prm. */
+	i += 3;
+	/* Set boolean flag for that option. */
+	*(bool *)Parameters[(*ParamCount)++] = BooleanTrue;
+	if (ISSPACE(CtrlStrCopy[i])) {
+		return ARG_OK; /* Only a boolean flag is needed. */
+	}
+	/* Skip the text between the boolean option and data follows: */
+	while (!ISCTRLCHAR(CtrlStrCopy[i])) {
+		i++;
+	}
+	/* Get the parameters and return the appropriete return code: */
+	return GAGetParmeters(Parameters, ParamCount, &CtrlStrCopy[i], Option,
+	                      argv_end, argv);
+}
+
+/***************************************************************************
+ Routine to get parameters according to the CtrlStr given from argv/argc
+***************************************************************************/
+static int GAGetParmeters(void *Parameters[], int *ParamCount,
+                          char *CtrlStrCopy, char *Option, char **argv_end,
+                          char ***argv) {
+
+	int i = 0, ScanRes;
+
+	while (!(ISSPACE(CtrlStrCopy[i]))) {
+
+		if ((*argv) == argv_end) {
+			GAErrorToken = Option;
+			return CMD_ERR_NumRead;
+		}
+
+		switch (CtrlStrCopy[i + 1]) {
+		case 'd': /* Get signed integers. */
+			ScanRes = sscanf(*((*argv)++), "%d",
+			                 (int *)Parameters[(*ParamCount)++]);
+			break;
+		case 'u': /* Get unsigned integers. */
+			ScanRes =
+			    sscanf(*((*argv)++), "%u",
+			           (unsigned *)Parameters[(*ParamCount)++]);
+			break;
+		case 'x': /* Get hex integers. */
+			ScanRes =
+			    sscanf(*((*argv)++), "%x",
+			           (unsigned int *)Parameters[(*ParamCount)++]);
+			break;
+		case 'o': /* Get octal integers. */
+			ScanRes =
+			    sscanf(*((*argv)++), "%o",
+			           (unsigned int *)Parameters[(*ParamCount)++]);
+			break;
+		case 'D': /* Get signed long integers. */
+			ScanRes = sscanf(*((*argv)++), "%ld",
+			                 (long *)Parameters[(*ParamCount)++]);
+			break;
+		case 'U': /* Get unsigned long integers. */
+			ScanRes = sscanf(
+			    *((*argv)++), "%lu",
+			    (unsigned long *)Parameters[(*ParamCount)++]);
+			break;
+		case 'X': /* Get hex long integers. */
+			ScanRes = sscanf(
+			    *((*argv)++), "%lx",
+			    (unsigned long *)Parameters[(*ParamCount)++]);
+			break;
+		case 'O': /* Get octal long integers. */
+			ScanRes = sscanf(
+			    *((*argv)++), "%lo",
+			    (unsigned long *)Parameters[(*ParamCount)++]);
+			break;
+		case 'f': /* Get float number. */
+			ScanRes = sscanf(*((*argv)++), "%f",
+			                 (float *)Parameters[(*ParamCount)++]);
+			break;
+		case 'F': /* Get double float number. */
+			ScanRes = sscanf(*((*argv)++), "%lf",
+			                 (double *)Parameters[(*ParamCount)++]);
+			break;
+		case 's':            /* It as a string. */
+			ScanRes = 1; /* Allways O.K. */
+			*(char **)Parameters[(*ParamCount)++] = *((*argv)++);
+			break;
+		case '*': /* Get few parameters into one: */
+			ScanRes = GAGetMultiParmeters(Parameters, ParamCount,
+			                              &CtrlStrCopy[i], argv_end,
+			                              argv);
+			if ((ScanRes == 0) && (CtrlStrCopy[i] == '!')) {
+				GAErrorToken = Option;
+				return CMD_ERR_WildEmpty;
+			}
+			break;
+		default:
+			ScanRes = 0; /* Make optimizer warning silent. */
+		}
+		/* If reading fails and this number is a must (!) then error: */
+		if ((ScanRes == 0) && (CtrlStrCopy[i] == '!')) {
+			GAErrorToken = Option;
+			return CMD_ERR_NumRead;
+		}
+		if (CtrlStrCopy[i + 1] != '*') {
+			i += 2; /* Skip to next parameter (if any). */
+		} else {
+			i += 3; /* Skip the '*' also! */
+		}
+	}
+
+	return ARG_OK;
+}
+
+/***************************************************************************
+ Routine to get a few parameters into one pointer such that the returned
+ pointer actually points on a block of pointers to the parameters...
+ For example *F means a pointer to pointers on floats.
+ Returns number of parameters actually read.
+ This routine assumes that all pointers (on any kind of scalar) has the
+ same size (and the union below is totally ovelapped bteween dif. arrays)
+***************************************************************************/
+static int GAGetMultiParmeters(void *Parameters[], int *ParamCount,
+                               char *CtrlStrCopy, char **argv_end,
+                               char ***argv) {
+
+	int i = 0, ScanRes, NumOfPrm = 0;
+	void **Pmain, **Ptemp;
+	union TmpArray { /* Save here the temporary data before copying it to */
+		void *VoidArray[MAX_PARAM]; /* the returned pointer block. */
+		int *IntArray[MAX_PARAM];
+		long *LngArray[MAX_PARAM];
+		float *FltArray[MAX_PARAM];
+		double *DblArray[MAX_PARAM];
+		char *ChrArray[MAX_PARAM];
+	} TmpArray;
+
+	do {
+		switch (CtrlStrCopy[2]) { /* CtrlStr == '!*?' or '%*?' where ?
+			                     is. */
+		case 'd':                 /* Format to read the parameters: */
+			TmpArray.IntArray[NumOfPrm] = xmalloc(sizeof(int));
+			ScanRes = sscanf(*((*argv)++), "%d",
+			                 (int *)TmpArray.IntArray[NumOfPrm++]);
+			break;
+		case 'u':
+			TmpArray.IntArray[NumOfPrm] = xmalloc(sizeof(int));
+			ScanRes = sscanf(
+			    *((*argv)++), "%u",
+			    (unsigned int *)TmpArray.IntArray[NumOfPrm++]);
+			break;
+		case 'o':
+			TmpArray.IntArray[NumOfPrm] = xmalloc(sizeof(int));
+			ScanRes = sscanf(
+			    *((*argv)++), "%o",
+			    (unsigned int *)TmpArray.IntArray[NumOfPrm++]);
+			break;
+		case 'x':
+			TmpArray.IntArray[NumOfPrm] = xmalloc(sizeof(int));
+			ScanRes = sscanf(
+			    *((*argv)++), "%x",
+			    (unsigned int *)TmpArray.IntArray[NumOfPrm++]);
+			break;
+		case 'D':
+			TmpArray.LngArray[NumOfPrm] = xmalloc(sizeof(long));
+			ScanRes = sscanf(*((*argv)++), "%ld",
+			                 (long *)TmpArray.IntArray[NumOfPrm++]);
+			break;
+		case 'U':
+			TmpArray.LngArray[NumOfPrm] = xmalloc(sizeof(long));
+			ScanRes = sscanf(
+			    *((*argv)++), "%lu",
+			    (unsigned long *)TmpArray.IntArray[NumOfPrm++]);
+			break;
+		case 'O':
+			TmpArray.LngArray[NumOfPrm] = xmalloc(sizeof(long));
+			ScanRes = sscanf(
+			    *((*argv)++), "%lo",
+			    (unsigned long *)TmpArray.IntArray[NumOfPrm++]);
+			break;
+		case 'X':
+			TmpArray.LngArray[NumOfPrm] = xmalloc(sizeof(long));
+			ScanRes = sscanf(
+			    *((*argv)++), "%lx",
+			    (unsigned long *)TmpArray.IntArray[NumOfPrm++]);
+			break;
+		case 'f':
+			TmpArray.FltArray[NumOfPrm] = xmalloc(sizeof(float));
+			ScanRes =
+			    sscanf(*((*argv)++), "%f",
+			           // cppcheck-suppress invalidPointerCast
+			           (float *)TmpArray.LngArray[NumOfPrm++]);
+			break;
+		case 'F':
+			TmpArray.DblArray[NumOfPrm] = xmalloc(sizeof(double));
+			ScanRes =
+			    sscanf(*((*argv)++), "%lf",
+			           // cppcheck-suppress invalidPointerCast
+			           (double *)TmpArray.LngArray[NumOfPrm++]);
+			break;
+		case 's':
+			while ((*argv < argv_end) && ((**argv)[0] != '-')) {
+				TmpArray.ChrArray[NumOfPrm++] = *((*argv)++);
+			}
+			ScanRes = 0; /* Force quit from do - loop. */
+			NumOfPrm++;  /* Updated again immediately after loop! */
+			(*argv)++;   /* "" */
+			break;
+		default:
+			ScanRes = 0; /* Make optimizer warning silent. */
+		}
+	} while (ScanRes == 1); /* Exactly one parameter was read. */
+	(*argv)--;
+	NumOfPrm--;
+
+	/* Now allocate the block with the exact size, and set it: */
+	Ptemp = Pmain = xmalloc((unsigned)(NumOfPrm + 1) * sizeof(void *));
+	/* And here we use the assumption that all pointers are the same: */
+	for (i = 0; i < NumOfPrm; i++) {
+		*Ptemp++ = TmpArray.VoidArray[i];
+	}
+	*Ptemp = NULL; /* Close the block with NULL pointer. */
+
+	/* That it save the number of parameters read as first parameter to
+	 * return and the pointer to the block as second, and return: */
+	*(int *)Parameters[(*ParamCount)++] = NumOfPrm;
+	*(void ***)Parameters[(*ParamCount)++] = Pmain;
+	/* free(Pmain); -- can not free here as caller needs to access memory */
+	return NumOfPrm;
+}
+
+/***************************************************************************
+ Routine to scan the CtrlStr, up to Max and count the number of parameters
+ to that point:
+ 1. Each option is counted as one parameter - boolean variable (int)
+ 2. Within an option, each %? or !? is counted once - pointer to something
+ 3. Within an option, %*? or !*? is counted twice - one for item count
+ and one for pointer to block pointers.
+ Note ALL variables are passed by address and so of fixed size (address).
+***************************************************************************/
+static void GASetParamCount(char const *CtrlStr, const int Max,
+                            int *ParamCount) {
+	int i;
+
+	*ParamCount = 0;
+	for (i = 0; i < Max; i++) {
+		if (ISCTRLCHAR(CtrlStr[i])) {
+			if (CtrlStr[i + 1] == '*') {
+				*ParamCount += 2;
+			} else {
+				(*ParamCount)++;
+			}
+		}
+	}
+}
+
+/***************************************************************************
+ Routine to check if more option (i.e. first char == '-') exists in the
+ given list argc, argv:
+***************************************************************************/
+static bool GAOptionExists(const char **argv_end, const char **argv) {
+
+	while (argv < argv_end) {
+		if ((*argv++)[0] == '-') {
+			return true;
+		}
+	}
+	return false;
+}
+
+/***************************************************************************
+ Routine to print some error messages, for this module:
+***************************************************************************/
+void GAPrintErrMsg(int Error) {
+
+	fprintf(stderr, "Error in command line parsing - ");
+	switch (Error) {
+	case 0:;
+		fprintf(stderr, "Undefined error");
+		break;
+	case CMD_ERR_NotAnOpt:
+		fprintf(stderr, "None option Found");
+		break;
+	case CMD_ERR_NoSuchOpt:
+		fprintf(stderr, "Undefined option Found");
+		break;
+	case CMD_ERR_WildEmpty:
+		fprintf(stderr, "Empty input for '!*?' seq.");
+		break;
+	case CMD_ERR_NumRead:
+		fprintf(stderr, "Failed on reading number");
+		break;
+	case CMD_ERR_AllSatis:
+		fprintf(stderr, "Fail to satisfy");
+		break;
+	}
+	fprintf(stderr, " - '%s'.\n", GAErrorToken);
+}
+
+/***************************************************************************
+ Routine to print correct format of command line allowed:
+***************************************************************************/
+void GAPrintHowTo(char *CtrlStr) {
+
+	int i = 0;
+	bool SpaceFlag;
+
+	fprintf(stderr, "Usage: ");
+	/* Print program name - first word in ctrl. str. (optional): */
+	while (!(ISSPACE(CtrlStr[i])) && (!ISCTRLCHAR(CtrlStr[i + 1]))) {
+		fprintf(stderr, "%c", CtrlStr[i++]);
+	}
+
+	while (i < (int)strlen(CtrlStr)) {
+		// cppcheck-suppress arrayIndexThenCheck
+		while ((ISSPACE(CtrlStr[i])) && (i < (int)strlen(CtrlStr))) {
+			i++;
+		}
+		switch (CtrlStr[i + 1]) {
+		case '%':
+			fprintf(stderr, " [-%c", CtrlStr[i++]);
+			i += 2; /* Skip the '%-' or '!- after the char! */
+			SpaceFlag = true;
+			while (!ISCTRLCHAR(CtrlStr[i]) &&
+			       (i < (int)strlen(CtrlStr)) &&
+			       (!ISSPACE(CtrlStr[i]))) {
+				if (SpaceFlag) {
+					if (CtrlStr[i++] == SPACE_CHAR) {
+						fprintf(stderr, " ");
+					} else {
+						fprintf(stderr, " %c",
+						        CtrlStr[i - 1]);
+					}
+					SpaceFlag = false;
+				} else if (CtrlStr[i++] == SPACE_CHAR) {
+					fprintf(stderr, " ");
+				} else {
+					fprintf(stderr, "%c", CtrlStr[i - 1]);
+				}
+			}
+			while (!ISSPACE(CtrlStr[i]) &&
+			       (i < (int)strlen(CtrlStr))) {
+				if (CtrlStr[i] == '*') {
+					fprintf(stderr, "...");
+				}
+				i++; /* Skip the rest of it. */
+			}
+			fprintf(stderr, "]");
+			break;
+		case '!':
+			fprintf(stderr, " -%c", CtrlStr[i++]);
+			i += 2; /* Skip the '%-' or '!- after the char! */
+			SpaceFlag = true;
+			while (!ISCTRLCHAR(CtrlStr[i]) &&
+			       (i < (int)strlen(CtrlStr)) &&
+			       (!ISSPACE(CtrlStr[i]))) {
+				if (SpaceFlag) {
+					if (CtrlStr[i++] == SPACE_CHAR) {
+						fprintf(stderr, " ");
+					} else {
+						fprintf(stderr, " %c",
+						        CtrlStr[i - 1]);
+					}
+					SpaceFlag = false;
+				} else if (CtrlStr[i++] == SPACE_CHAR) {
+					fprintf(stderr, " ");
+				} else {
+					fprintf(stderr, "%c", CtrlStr[i - 1]);
+				}
+			}
+			while (!ISSPACE(CtrlStr[i]) &&
+			       (i < (int)strlen(CtrlStr))) {
+				if (CtrlStr[i] == '*') {
+					fprintf(stderr, "...");
+				}
+				i++; /* Skip the rest of it. */
+			}
+			break;
+		default: /* Not checked, but must be last one! */
+			fprintf(stderr, " ");
+			while (!ISSPACE(CtrlStr[i]) &&
+			       (i < (int)strlen(CtrlStr)) &&
+			       !ISCTRLCHAR(CtrlStr[i])) {
+				fprintf(stderr, "%c", CtrlStr[i++]);
+			}
+			fprintf(stderr, "\n");
+			return;
+		}
+	}
+	fprintf(stderr, "\n");
+}
+
+/* end */
diff --git a/getarg.h b/getarg.h
new file mode 100644
index 0000000..3bfd22b
--- /dev/null
+++ b/getarg.h
@@ -0,0 +1,54 @@
+/***************************************************************************
+
+getarg.h - Support routines for the giflib utilities
+
+SPDX-License-Identifier: MIT
+
+ **************************************************************************/
+
+#ifndef _GETARG_H
+#define _GETARG_H
+
+#include "gif_lib.h"
+#include <stdbool.h>
+
+#define VERSION_COOKIE " Version %d.%d, "
+
+/***************************************************************************
+   Error numbers as returned by GAGetArg routine:
+***************************************************************************/
+#define CMD_ERR_NotAnOpt 1  /* None Option found. */
+#define CMD_ERR_NoSuchOpt 2 /* Undefined Option Found. */
+#define CMD_ERR_WildEmpty 3 /* Empty input for !*? seq. */
+#define CMD_ERR_NumRead 4   /* Failed on reading number. */
+#define CMD_ERR_AllSatis 5  /* Fail to satisfy (must-'!') option. */
+
+bool GAGetArgs(int argc, char **argv, char *CtrlStr, ...);
+void GAPrintErrMsg(int Error);
+void GAPrintHowTo(char *CtrlStr);
+
+/******************************************************************************
+ From qprintf.c
+******************************************************************************/
+extern void GifQprintf(char *Format, ...);
+extern void PrintGifError(int ErrorCode);
+
+/******************************************************************************
+ Color table quantization
+******************************************************************************/
+int GifQuantizeBuffer(unsigned int Width, unsigned int Height,
+                      int *ColorMapSize, GifByteType *RedInput,
+                      GifByteType *GreenInput, GifByteType *BlueInput,
+                      GifByteType *OutputBuffer, GifColorType *OutputColorMap);
+
+/* These used to live in the library header */
+#define GIF_MESSAGE(Msg) fprintf(stderr, "\n%s: %s\n", PROGRAM_NAME, Msg)
+#define GIF_EXIT(Msg)                                                          \
+	{                                                                      \
+		GIF_MESSAGE(Msg);                                              \
+		exit(-3);                                                      \
+	}
+
+#endif /* _GETARG_H */
+
+/* end */
diff --git a/getversion b/getversion
new file mode 100755
index 0000000..d44c9f2
--- /dev/null
+++ b/getversion
@@ -0,0 +1,10 @@
+#!/bin/sh
+#
+# getversion - get the librarty version by analyzing its header
+#
+# Done this way so there's a single point of truth about the version.
+#
+MAJOR=`sed <gif_lib.h -n -e "/MAJOR/s/#define GIFLIB_MAJOR  *//p"`
+MINOR=`sed <gif_lib.h -n -e "/MINOR/s/#define GIFLIB_MINOR  *//p"`
+RELEASE=`sed <gif_lib.h -n -e "/RELEASE/s/#define GIFLIB_RELEASE  *//p"`
+echo ${MAJOR}.${MINOR}.${RELEASE}
diff --git a/gif2rgb.c b/gif2rgb.c
new file mode 100644
index 0000000..d51226d
--- /dev/null
+++ b/gif2rgb.c
@@ -0,0 +1,580 @@
+/*****************************************************************************
+
+gif2rgb - convert GIF to 24-bit RGB pixel triples or vice-versa
+
+SPDX-License-Identifier: MIT
+
+*****************************************************************************/
+
+/***************************************************************************
+
+Toshio Kuratomi had written this in a comment about the rgb2gif code:
+
+  Besides fixing bugs, what's really needed is for someone to work out how to
+  calculate a colormap for writing GIFs from rgb sources.  Right now, an rgb
+  source that has only two colors (b/w) is being converted into an 8 bit GIF....
+  Which is horrendously wasteful without compression.
+
+I (ESR) took this off the main to-do list in 2012 because I don't think
+the GIFLIB project actually needs to be in the converters-and-tools business.
+Plenty of hackers do that; our job is to supply stable library capability
+with our utilities mainly interesting as test tools.
+
+***************************************************************************/
+
+#include <ctype.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef _WIN32
+#include <io.h>
+#endif /* _WIN32 */
+
+#include "getarg.h"
+#include "gif_lib.h"
+
+#define PROGRAM_NAME "gif2rgb"
+
+static char *VersionStr = PROGRAM_NAME VERSION_COOKIE
+    "	Gershon Elber,	" __DATE__ ",   " __TIME__ "\n"
+    "(C) Copyright 1989 Gershon Elber.\n";
+static char *CtrlStr = PROGRAM_NAME
+    " v%- c%-#Colors!d s%-Width|Height!d!d 1%- o%-OutFileName!s h%- GifFile!*s";
+
+static void LoadRGB(char *FileName, int OneFileFlag, GifByteType **RedBuffer,
+                    GifByteType **GreenBuffer, GifByteType **BlueBuffer,
+                    int Width, int Height);
+static void SaveGif(GifByteType *OutputBuffer, int Width, int Height,
+                    int ExpColorMapSize, ColorMapObject *OutputColorMap);
+
+/******************************************************************************
+ Load RGB file into internal frame buffer.
+******************************************************************************/
+static void LoadRGB(char *FileName, int OneFileFlag, GifByteType **RedBuffer,
+                    GifByteType **GreenBuffer, GifByteType **BlueBuffer,
+                    int Width, int Height) {
+	int i;
+	unsigned long Size;
+	GifByteType *RedP, *GreenP, *BlueP;
+	FILE *rgbfp[3];
+
+	Size = ((long)Width) * Height * sizeof(GifByteType);
+
+	if ((*RedBuffer = (GifByteType *)malloc((unsigned int)Size)) == NULL ||
+	    (*GreenBuffer = (GifByteType *)malloc((unsigned int)Size)) ==
+	        NULL ||
+	    (*BlueBuffer = (GifByteType *)malloc((unsigned int)Size)) == NULL) {
+		GIF_EXIT("Failed to allocate memory required, aborted.");
+	}
+
+	RedP = *RedBuffer;
+	GreenP = *GreenBuffer;
+	BlueP = *BlueBuffer;
+
+	if (FileName != NULL) {
+		if (OneFileFlag) {
+			if ((rgbfp[0] = fopen(FileName, "rb")) == NULL) {
+				GIF_EXIT("Can't open input file name.");
+			}
+		} else {
+			static const char *Postfixes[] = {".R", ".G", ".B"};
+			char OneFileName[80];
+
+			for (i = 0; i < 3; i++) {
+				strncpy(OneFileName, FileName,
+				        sizeof(OneFileName) - 1);
+				strncat(OneFileName, Postfixes[i],
+				        sizeof(OneFileName) - 1 -
+				            strlen(OneFileName));
+
+				if ((rgbfp[i] = fopen(OneFileName, "rb")) ==
+				    NULL) {
+					GIF_EXIT("Can't open input file name.");
+				}
+			}
+		}
+	} else {
+		OneFileFlag = true;
+
+#ifdef _WIN32
+		_setmode(0, O_BINARY);
+#endif /* _WIN32 */
+
+		rgbfp[0] = stdin;
+	}
+
+	GifQprintf("\n%s: RGB image:     ", PROGRAM_NAME);
+
+	if (OneFileFlag) {
+		GifByteType *Buffer, *BufferP;
+
+		if ((Buffer = (GifByteType *)malloc(Width * 3)) == NULL) {
+			GIF_EXIT(
+			    "Failed to allocate memory required, aborted.");
+		}
+
+		for (i = 0; i < Height; i++) {
+			int j;
+			GifQprintf("\b\b\b\b%-4d", i);
+			if (fread(Buffer, Width * 3, 1, rgbfp[0]) != 1) {
+				GIF_EXIT(
+				    "Input file(s) terminated prematurly.");
+			}
+			for (j = 0, BufferP = Buffer; j < Width; j++) {
+				*RedP++ = *BufferP++;
+				*GreenP++ = *BufferP++;
+				*BlueP++ = *BufferP++;
+			}
+		}
+
+		free((char *)Buffer);
+		fclose(rgbfp[0]);
+	} else {
+		for (i = 0; i < Height; i++) {
+			GifQprintf("\b\b\b\b%-4d", i);
+			if (fread(RedP, Width, 1, rgbfp[0]) != 1 ||
+			    fread(GreenP, Width, 1, rgbfp[1]) != 1 ||
+			    fread(BlueP, Width, 1, rgbfp[2]) != 1) {
+				GIF_EXIT(
+				    "Input file(s) terminated prematurly.");
+			}
+			RedP += Width;
+			GreenP += Width;
+			BlueP += Width;
+		}
+
+		fclose(rgbfp[0]);
+		fclose(rgbfp[1]);
+		fclose(rgbfp[2]);
+	}
+}
+
+/******************************************************************************
+ Save the GIF resulting image.
+******************************************************************************/
+static void SaveGif(GifByteType *OutputBuffer, int Width, int Height,
+                    int ExpColorMapSize, ColorMapObject *OutputColorMap) {
+	int i, Error;
+	GifFileType *GifFile;
+	GifByteType *Ptr = OutputBuffer;
+
+	/* Open stdout for the output file: */
+	if ((GifFile = EGifOpenFileHandle(1, &Error)) == NULL) {
+		PrintGifError(Error);
+		exit(EXIT_FAILURE);
+	}
+
+	if (EGifPutScreenDesc(GifFile, Width, Height, ExpColorMapSize, 0,
+	                      OutputColorMap) == GIF_ERROR ||
+	    EGifPutImageDesc(GifFile, 0, 0, Width, Height, false, NULL) ==
+	        GIF_ERROR) {
+		PrintGifError(Error);
+		exit(EXIT_FAILURE);
+	}
+
+	GifQprintf("\n%s: Image 1 at (%d, %d) [%dx%d]:     ", PROGRAM_NAME,
+	           GifFile->Image.Left, GifFile->Image.Top,
+	           GifFile->Image.Width, GifFile->Image.Height);
+
+	for (i = 0; i < Height; i++) {
+		if (EGifPutLine(GifFile, Ptr, Width) == GIF_ERROR) {
+			exit(EXIT_FAILURE);
+		}
+		GifQprintf("\b\b\b\b%-4d", Height - i - 1);
+
+		Ptr += Width;
+	}
+
+	if (EGifCloseFile(GifFile, &Error) == GIF_ERROR) {
+		PrintGifError(Error);
+		exit(EXIT_FAILURE);
+	}
+}
+
+/******************************************************************************
+ Close output file (if open), and exit.
+******************************************************************************/
+static void RGB2GIF(bool OneFileFlag, int NumFiles, char *FileName,
+                    int ExpNumOfColors, int Width, int Height) {
+	int ColorMapSize;
+
+	GifByteType *RedBuffer = NULL, *GreenBuffer = NULL, *BlueBuffer = NULL,
+	            *OutputBuffer = NULL;
+	ColorMapObject *OutputColorMap = NULL;
+
+	ColorMapSize = 1 << ExpNumOfColors;
+
+	if (NumFiles == 1) {
+		LoadRGB(FileName, OneFileFlag, &RedBuffer, &GreenBuffer,
+		        &BlueBuffer, Width, Height);
+	} else {
+		LoadRGB(NULL, OneFileFlag, &RedBuffer, &GreenBuffer,
+		        &BlueBuffer, Width, Height);
+	}
+
+	if ((OutputColorMap = GifMakeMapObject(ColorMapSize, NULL)) == NULL ||
+	    (OutputBuffer = (GifByteType *)malloc(
+	         Width * Height * sizeof(GifByteType))) == NULL) {
+		GIF_EXIT("Failed to allocate memory required, aborted.");
+	}
+
+	if (GifQuantizeBuffer(Width, Height, &ColorMapSize, RedBuffer,
+	                      GreenBuffer, BlueBuffer, OutputBuffer,
+	                      OutputColorMap->Colors) == GIF_ERROR) {
+		exit(EXIT_FAILURE);
+	}
+	free((char *)RedBuffer);
+	free((char *)GreenBuffer);
+	free((char *)BlueBuffer);
+
+	SaveGif(OutputBuffer, Width, Height, ExpNumOfColors, OutputColorMap);
+}
+
+/******************************************************************************
+ The real screen dumping routine.
+******************************************************************************/
+static void DumpScreen2RGB(char *FileName, int OneFileFlag,
+                           ColorMapObject *ColorMap,
+                           const GifRowType *ScreenBuffer, int ScreenWidth,
+                           int ScreenHeight) {
+	int i, j;
+	GifRowType GifRow;
+	GifColorType *ColorMapEntry;
+	FILE *rgbfp[3];
+
+	if (FileName != NULL) {
+		if (OneFileFlag) {
+			if ((rgbfp[0] = fopen(FileName, "wb")) == NULL) {
+				GIF_EXIT("Can't open input file name.");
+			}
+		} else {
+			static char *Postfixes[] = {".R", ".G", ".B"};
+			char OneFileName[80];
+
+			for (i = 0; i < 3; i++) {
+				strncpy(OneFileName, FileName,
+				        sizeof(OneFileName) - 1);
+				strncat(OneFileName, Postfixes[i],
+				        sizeof(OneFileName) - 1 -
+				            strlen(OneFileName));
+
+				if ((rgbfp[i] = fopen(OneFileName, "wb")) ==
+				    NULL) {
+					GIF_EXIT("Can't open input file name.");
+				}
+			}
+		}
+	} else {
+		OneFileFlag = true;
+
+#ifdef _WIN32
+		_setmode(1, O_BINARY);
+#endif /* _WIN32 */
+
+		rgbfp[0] = stdout;
+	}
+
+	if (ColorMap == NULL) {
+		fprintf(stderr, "Color map pointer is NULL.\n");
+		exit(EXIT_FAILURE);
+	}
+
+	if (OneFileFlag) {
+		unsigned char *Buffer, *BufferP;
+
+		if ((Buffer = (unsigned char *)malloc(ScreenWidth * 3)) ==
+		    NULL) {
+			GIF_EXIT(
+			    "Failed to allocate memory required, aborted.");
+		}
+		for (i = 0; i < ScreenHeight; i++) {
+			GifRow = ScreenBuffer[i];
+			GifQprintf("\b\b\b\b%-4d", ScreenHeight - i);
+			for (j = 0, BufferP = Buffer; j < ScreenWidth; j++) {
+				/* Check if color is within color palete */
+				if (GifRow[j] >= ColorMap->ColorCount) {
+					GIF_EXIT(GifErrorString(
+					    D_GIF_ERR_IMAGE_DEFECT));
+				}
+				ColorMapEntry = &ColorMap->Colors[GifRow[j]];
+				*BufferP++ = ColorMapEntry->Red;
+				*BufferP++ = ColorMapEntry->Green;
+				*BufferP++ = ColorMapEntry->Blue;
+			}
+			if (fwrite(Buffer, ScreenWidth * 3, 1, rgbfp[0]) != 1) {
+				GIF_EXIT("Write to file(s) failed.");
+			}
+		}
+
+		free((char *)Buffer);
+		fclose(rgbfp[0]);
+	} else {
+		unsigned char *Buffers[3];
+
+		if ((Buffers[0] = (unsigned char *)malloc(ScreenWidth)) ==
+		        NULL ||
+		    (Buffers[1] = (unsigned char *)malloc(ScreenWidth)) ==
+		        NULL ||
+		    (Buffers[2] = (unsigned char *)malloc(ScreenWidth)) ==
+		        NULL) {
+			GIF_EXIT(
+			    "Failed to allocate memory required, aborted.");
+		}
+
+		for (i = 0; i < ScreenHeight; i++) {
+			GifRow = ScreenBuffer[i];
+			GifQprintf("\b\b\b\b%-4d", ScreenHeight - i);
+			for (j = 0; j < ScreenWidth; j++) {
+				ColorMapEntry = &ColorMap->Colors[GifRow[j]];
+				Buffers[0][j] = ColorMapEntry->Red;
+				Buffers[1][j] = ColorMapEntry->Green;
+				Buffers[2][j] = ColorMapEntry->Blue;
+			}
+			if (fwrite(Buffers[0], ScreenWidth, 1, rgbfp[0]) != 1 ||
+			    fwrite(Buffers[1], ScreenWidth, 1, rgbfp[1]) != 1 ||
+			    fwrite(Buffers[2], ScreenWidth, 1, rgbfp[2]) != 1) {
+				GIF_EXIT("Write to file(s) failed.");
+			}
+		}
+
+		free((char *)Buffers[0]);
+		free((char *)Buffers[1]);
+		free((char *)Buffers[2]);
+		fclose(rgbfp[0]);
+		fclose(rgbfp[1]);
+		fclose(rgbfp[2]);
+	}
+}
+
+static void GIF2RGB(int NumFiles, char *FileName, bool OneFileFlag,
+                    char *OutFileName) {
+	int i, j, Size, Row, Col, Width, Height, ExtCode, Count;
+	GifRecordType RecordType;
+	GifByteType *Extension;
+	GifRowType *ScreenBuffer;
+	GifFileType *GifFile;
+	static const int InterlacedOffset[] = {
+	    0, 4, 2, 1}; /* The way Interlaced image should. */
+	static const int InterlacedJumps[] = {
+	    8, 8, 4, 2}; /* be read - offsets and jumps... */
+	int ImageNum = 0;
+	ColorMapObject *ColorMap;
+
+	if (NumFiles == 1) {
+		int Error;
+		if ((GifFile = DGifOpenFileName(FileName, &Error)) == NULL) {
+			PrintGifError(Error);
+			exit(EXIT_FAILURE);
+		}
+	} else {
+		int Error;
+		/* Use stdin instead: */
+		if ((GifFile = DGifOpenFileHandle(0, &Error)) == NULL) {
+			PrintGifError(Error);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	if (GifFile->SHeight == 0 || GifFile->SWidth == 0) {
+		fprintf(stderr, "Image of width or height 0\n");
+		exit(EXIT_FAILURE);
+	}
+
+	/*
+	 * Allocate the screen as vector of column of rows. Note this
+	 * screen is device independent - it's the screen defined by the
+	 * GIF file parameters.
+	 */
+	if ((ScreenBuffer = (GifRowType *)malloc(GifFile->SHeight *
+	                                         sizeof(GifRowType))) == NULL) {
+		GIF_EXIT("Failed to allocate memory required, aborted.");
+	}
+
+	Size =
+	    GifFile->SWidth * sizeof(GifPixelType); /* Size in bytes one row.*/
+	if ((ScreenBuffer[0] = (GifRowType)malloc(Size)) ==
+	    NULL) { /* First row. */
+		GIF_EXIT("Failed to allocate memory required, aborted.");
+	}
+
+	for (i = 0; i < GifFile->SWidth;
+	     i++) { /* Set its color to BackGround. */
+		ScreenBuffer[0][i] = GifFile->SBackGroundColor;
+	}
+	for (i = 1; i < GifFile->SHeight; i++) {
+		/* Allocate the other rows, and set their color to background
+		 * too: */
+		if ((ScreenBuffer[i] = (GifRowType)malloc(Size)) == NULL) {
+			GIF_EXIT(
+			    "Failed to allocate memory required, aborted.");
+		}
+
+		memcpy(ScreenBuffer[i], ScreenBuffer[0], Size);
+	}
+
+	/* Scan the content of the GIF file and load the image(s) in: */
+	do {
+		if (DGifGetRecordType(GifFile, &RecordType) == GIF_ERROR) {
+			PrintGifError(GifFile->Error);
+			exit(EXIT_FAILURE);
+		}
+		switch (RecordType) {
+		case IMAGE_DESC_RECORD_TYPE:
+			if (DGifGetImageDesc(GifFile) == GIF_ERROR) {
+				PrintGifError(GifFile->Error);
+				exit(EXIT_FAILURE);
+			}
+			Row = GifFile->Image
+			          .Top; /* Image Position relative to Screen. */
+			Col = GifFile->Image.Left;
+			Width = GifFile->Image.Width;
+			Height = GifFile->Image.Height;
+			GifQprintf("\n%s: Image %d at (%d, %d) [%dx%d]:     ",
+			           PROGRAM_NAME, ++ImageNum, Col, Row, Width,
+			           Height);
+			if (GifFile->Image.Left + GifFile->Image.Width >
+			        GifFile->SWidth ||
+			    GifFile->Image.Top + GifFile->Image.Height >
+			        GifFile->SHeight) {
+				fprintf(stderr,
+				        "Image %d is not confined to screen "
+				        "dimension, aborted.\n",
+				        ImageNum);
+				exit(EXIT_FAILURE);
+			}
+			if (GifFile->Image.Interlace) {
+				/* Need to perform 4 passes on the images: */
+				for (Count = i = 0; i < 4; i++) {
+					for (j = Row + InterlacedOffset[i];
+					     j < Row + Height;
+					     j += InterlacedJumps[i]) {
+						GifQprintf("\b\b\b\b%-4d",
+						           Count++);
+						if (DGifGetLine(
+						        GifFile,
+						        &ScreenBuffer[j][Col],
+						        Width) == GIF_ERROR) {
+							PrintGifError(
+							    GifFile->Error);
+							exit(EXIT_FAILURE);
+						}
+					}
+				}
+			} else {
+				for (i = 0; i < Height; i++) {
+					GifQprintf("\b\b\b\b%-4d", i);
+					if (DGifGetLine(
+					        GifFile,
+					        &ScreenBuffer[Row++][Col],
+					        Width) == GIF_ERROR) {
+						PrintGifError(GifFile->Error);
+						exit(EXIT_FAILURE);
+					}
+				}
+			}
+			break;
+		case EXTENSION_RECORD_TYPE:
+			/* Skip any extension blocks in file: */
+			if (DGifGetExtension(GifFile, &ExtCode, &Extension) ==
+			    GIF_ERROR) {
+				PrintGifError(GifFile->Error);
+				exit(EXIT_FAILURE);
+			}
+			while (Extension != NULL) {
+				if (DGifGetExtensionNext(GifFile, &Extension) ==
+				    GIF_ERROR) {
+					PrintGifError(GifFile->Error);
+					exit(EXIT_FAILURE);
+				}
+			}
+			break;
+		case TERMINATE_RECORD_TYPE:
+			break;
+		default: /* Should be trapped by DGifGetRecordType. */
+			break;
+		}
+	} while (RecordType != TERMINATE_RECORD_TYPE);
+
+	/* Lets dump it - set the global variables required and do it: */
+	ColorMap = (GifFile->Image.ColorMap ? GifFile->Image.ColorMap
+	                                    : GifFile->SColorMap);
+	if (ColorMap == NULL) {
+		fprintf(stderr, "Gif Image does not have a colormap\n");
+		exit(EXIT_FAILURE);
+	}
+
+	/* check that the background color isn't garbage (SF bug #87) */
+	if (GifFile->SBackGroundColor < 0 ||
+	    GifFile->SBackGroundColor >= ColorMap->ColorCount) {
+		fprintf(stderr, "Background color out of range for colormap\n");
+		exit(EXIT_FAILURE);
+	}
+
+	DumpScreen2RGB(OutFileName, OneFileFlag, ColorMap, ScreenBuffer,
+	               GifFile->SWidth, GifFile->SHeight);
+
+	(void)free(ScreenBuffer);
+
+	{
+		int Error;
+		if (DGifCloseFile(GifFile, &Error) == GIF_ERROR) {
+			PrintGifError(Error);
+			exit(EXIT_FAILURE);
+		}
+	}
+}
+
+/******************************************************************************
+ * Interpret the command line and scan the given GIF file.
+ ******************************************************************************/
+int main(int argc, char **argv) {
+	bool Error, OutFileFlag = false, ColorFlag = false, SizeFlag = false,
+	            GifNoisyPrint = false;
+	int NumFiles, Width = 0, Height = 0, ExpNumOfColors = 8;
+	char *OutFileName, **FileName = NULL;
+	static bool OneFileFlag = false, HelpFlag = false;
+
+	if ((Error = GAGetArgs(argc, argv, CtrlStr, &GifNoisyPrint, &ColorFlag,
+	                       &ExpNumOfColors, &SizeFlag, &Width, &Height,
+	                       &OneFileFlag, &OutFileFlag, &OutFileName,
+	                       &HelpFlag, &NumFiles, &FileName)) != false ||
+	    (NumFiles > 1 && !HelpFlag)) {
+		if (Error) {
+			GAPrintErrMsg(Error);
+		} else if (NumFiles > 1) {
+			GIF_MESSAGE("Error in command line parsing - one input "
+			            "file please.");
+		}
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_FAILURE);
+	}
+
+	if (HelpFlag) {
+		(void)fprintf(stderr, VersionStr, GIFLIB_MAJOR, GIFLIB_MINOR);
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_SUCCESS);
+	}
+	if (!OutFileFlag) {
+		OutFileName = NULL;
+	}
+
+	if (SizeFlag) {
+		if ((Width <= 0 || Height <= 0) || (Height > INT_MAX / Width)) {
+			GIF_MESSAGE(
+			    "Image size would be overflow, zero or negative");
+			exit(EXIT_FAILURE);
+		}
+		RGB2GIF(OneFileFlag, NumFiles, *FileName, ExpNumOfColors, Width,
+		        Height);
+	} else {
+		GIF2RGB(NumFiles, *FileName, OneFileFlag, OutFileName);
+	}
+
+	return 0;
+}
+
+/* end */
diff --git a/gif_err.c b/gif_err.c
index 3ec2a56..0226194 100644
--- a/gif_err.c
+++ b/gif_err.c
@@ -2,6 +2,8 @@
 
 gif_err.c - handle error reporting for the GIF library.
 
+SPDX-License-Identifier: MIT
+
 ****************************************************************************/
 
 #include <stdio.h>
@@ -12,86 +14,84 @@ gif_err.c - handle error reporting for the GIF library.
 /*****************************************************************************
  Return a string description of  the last GIF error
 *****************************************************************************/
-const char *
-GifErrorString(int ErrorCode)
-{
-    const char *Err;
+const char *GifErrorString(int ErrorCode) {
+	const char *Err;
 
-    switch (ErrorCode) {
-      case E_GIF_ERR_OPEN_FAILED:
-        Err = "Failed to open given file";
-        break;
-      case E_GIF_ERR_WRITE_FAILED:
-        Err = "Failed to write to given file";
-        break;
-      case E_GIF_ERR_HAS_SCRN_DSCR:
-        Err = "Screen descriptor has already been set";
-        break;
-      case E_GIF_ERR_HAS_IMAG_DSCR:
-        Err = "Image descriptor is still active";
-        break;
-      case E_GIF_ERR_NO_COLOR_MAP:
-        Err = "Neither global nor local color map";
-        break;
-      case E_GIF_ERR_DATA_TOO_BIG:
-        Err = "Number of pixels bigger than width * height";
-        break;
-      case E_GIF_ERR_NOT_ENOUGH_MEM:
-        Err = "Failed to allocate required memory";
-        break;
-      case E_GIF_ERR_DISK_IS_FULL:
-        Err = "Write failed (disk full?)";
-        break;
-      case E_GIF_ERR_CLOSE_FAILED:
-        Err = "Failed to close given file";
-        break;
-      case E_GIF_ERR_NOT_WRITEABLE:
-        Err = "Given file was not opened for write";
-        break;
-      case D_GIF_ERR_OPEN_FAILED:
-        Err = "Failed to open given file";
-        break;
-      case D_GIF_ERR_READ_FAILED:
-        Err = "Failed to read from given file";
-        break;
-      case D_GIF_ERR_NOT_GIF_FILE:
-        Err = "Data is not in GIF format";
-        break;
-      case D_GIF_ERR_NO_SCRN_DSCR:
-        Err = "No screen descriptor detected";
-        break;
-      case D_GIF_ERR_NO_IMAG_DSCR:
-        Err = "No Image Descriptor detected";
-        break;
-      case D_GIF_ERR_NO_COLOR_MAP:
-        Err = "Neither global nor local color map";
-        break;
-      case D_GIF_ERR_WRONG_RECORD:
-        Err = "Wrong record type detected";
-        break;
-      case D_GIF_ERR_DATA_TOO_BIG:
-        Err = "Number of pixels bigger than width * height";
-        break;
-      case D_GIF_ERR_NOT_ENOUGH_MEM:
-        Err = "Failed to allocate required memory";
-        break;
-      case D_GIF_ERR_CLOSE_FAILED:
-        Err = "Failed to close given file";
-        break;
-      case D_GIF_ERR_NOT_READABLE:
-        Err = "Given file was not opened for read";
-        break;
-      case D_GIF_ERR_IMAGE_DEFECT:
-        Err = "Image is defective, decoding aborted";
-        break;
-      case D_GIF_ERR_EOF_TOO_SOON:
-        Err = "Image EOF detected before image complete";
-        break;
-      default:
-        Err = NULL;
-        break;
-    }
-    return Err;
+	switch (ErrorCode) {
+	case E_GIF_ERR_OPEN_FAILED:
+		Err = "Failed to open given file";
+		break;
+	case E_GIF_ERR_WRITE_FAILED:
+		Err = "Failed to write to given file";
+		break;
+	case E_GIF_ERR_HAS_SCRN_DSCR:
+		Err = "Screen descriptor has already been set";
+		break;
+	case E_GIF_ERR_HAS_IMAG_DSCR:
+		Err = "Image descriptor is still active";
+		break;
+	case E_GIF_ERR_NO_COLOR_MAP:
+		Err = "Neither global nor local color map";
+		break;
+	case E_GIF_ERR_DATA_TOO_BIG:
+		Err = "Number of pixels bigger than width * height";
+		break;
+	case E_GIF_ERR_NOT_ENOUGH_MEM:
+		Err = "Failed to allocate required memory";
+		break;
+	case E_GIF_ERR_DISK_IS_FULL:
+		Err = "Write failed (disk full?)";
+		break;
+	case E_GIF_ERR_CLOSE_FAILED:
+		Err = "Failed to close given file";
+		break;
+	case E_GIF_ERR_NOT_WRITEABLE:
+		Err = "Given file was not opened for write";
+		break;
+	case D_GIF_ERR_OPEN_FAILED:
+		Err = "Failed to open given file";
+		break;
+	case D_GIF_ERR_READ_FAILED:
+		Err = "Failed to read from given file";
+		break;
+	case D_GIF_ERR_NOT_GIF_FILE:
+		Err = "Data is not in GIF format";
+		break;
+	case D_GIF_ERR_NO_SCRN_DSCR:
+		Err = "No screen descriptor detected";
+		break;
+	case D_GIF_ERR_NO_IMAG_DSCR:
+		Err = "No Image Descriptor detected";
+		break;
+	case D_GIF_ERR_NO_COLOR_MAP:
+		Err = "Neither global nor local color map";
+		break;
+	case D_GIF_ERR_WRONG_RECORD:
+		Err = "Wrong record type detected";
+		break;
+	case D_GIF_ERR_DATA_TOO_BIG:
+		Err = "Number of pixels bigger than width * height";
+		break;
+	case D_GIF_ERR_NOT_ENOUGH_MEM:
+		Err = "Failed to allocate required memory";
+		break;
+	case D_GIF_ERR_CLOSE_FAILED:
+		Err = "Failed to close given file";
+		break;
+	case D_GIF_ERR_NOT_READABLE:
+		Err = "Given file was not opened for read";
+		break;
+	case D_GIF_ERR_IMAGE_DEFECT:
+		Err = "Image is defective, decoding aborted";
+		break;
+	case D_GIF_ERR_EOF_TOO_SOON:
+		Err = "Image EOF detected before image complete";
+		break;
+	default:
+		Err = NULL;
+		break;
+	}
+	return Err;
 }
 
 /* end */
diff --git a/gif_font.c b/gif_font.c
index 8a02b2d..75f9731 100644
--- a/gif_font.c
+++ b/gif_font.c
@@ -1,11 +1,13 @@
 /*****************************************************************************
- 
+
 gif_font.c - utility font handling and simple drawing for the GIF library
- 
+
+SPDX-License-Identifier: MIT
+
 ****************************************************************************/
 
-#include <string.h>
 #include <stdlib.h>
+#include <string.h>
 
 #include "gif_lib.h"
 
@@ -20,240 +22,240 @@ gif_font.c - utility font handling and simple drawing for the GIF library
  */
 /*@+charint@*/
 const unsigned char GifAsciiTable8x8[][GIF_FONT_WIDTH] = {
-    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /* Ascii 0 */
-    {0x3c, 0x42, 0xa5, 0x81, 0xbd, 0x42, 0x3c, 0x00},    /* Ascii 1 */
-    {0x3c, 0x7e, 0xdb, 0xff, 0xc3, 0x7e, 0x3c, 0x00},    /* Ascii 2 */
-    {0x00, 0xee, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00},    /* Ascii 3 */
-    {0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00},    /* Ascii 4 */
-    {0x00, 0x3c, 0x18, 0xff, 0xff, 0x08, 0x18, 0x00},    /* Ascii 5 */
-    {0x10, 0x38, 0x7c, 0xfe, 0xfe, 0x10, 0x38, 0x00},    /* Ascii 6 */
-    {0x00, 0x00, 0x18, 0x3c, 0x18, 0x00, 0x00, 0x00},    /* Ascii 7 */
-    {0xff, 0xff, 0xe7, 0xc3, 0xe7, 0xff, 0xff, 0xff},    /* Ascii 8 */
-    {0x00, 0x3c, 0x42, 0x81, 0x81, 0x42, 0x3c, 0x00},    /* Ascii 9 */
-    {0xff, 0xc3, 0xbd, 0x7e, 0x7e, 0xbd, 0xc3, 0xff},    /* Ascii 10 */
-    {0x1f, 0x07, 0x0d, 0x7c, 0xc6, 0xc6, 0x7c, 0x00},    /* Ascii 11 */
-    {0x00, 0x7e, 0xc3, 0xc3, 0x7e, 0x18, 0x7e, 0x18},    /* Ascii 12 */
-    {0x04, 0x06, 0x07, 0x04, 0x04, 0xfc, 0xf8, 0x00},    /* Ascii 13 */
-    {0x0c, 0x0a, 0x0d, 0x0b, 0xf9, 0xf9, 0x1f, 0x1f},    /* Ascii 14 */
-    {0x00, 0x92, 0x7c, 0x44, 0xc6, 0x7c, 0x92, 0x00},    /* Ascii 15 */
-    {0x00, 0x00, 0x60, 0x78, 0x7e, 0x78, 0x60, 0x00},    /* Ascii 16 */
-    {0x00, 0x00, 0x06, 0x1e, 0x7e, 0x1e, 0x06, 0x00},    /* Ascii 17 */
-    {0x18, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x18},    /* Ascii 18 */
-    {0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00},    /* Ascii 19 */
-    {0xff, 0xb6, 0x76, 0x36, 0x36, 0x36, 0x36, 0x00},    /* Ascii 20 */
-    {0x7e, 0xc1, 0xdc, 0x22, 0x22, 0x1f, 0x83, 0x7e},    /* Ascii 21 */
-    {0x00, 0x00, 0x00, 0x7e, 0x7e, 0x00, 0x00, 0x00},    /* Ascii 22 */
-    {0x18, 0x7e, 0x18, 0x18, 0x7e, 0x18, 0x00, 0xff},    /* Ascii 23 */
-    {0x18, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00},    /* Ascii 24 */
-    {0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x18, 0x00},    /* Ascii 25 */
-    {0x00, 0x04, 0x06, 0xff, 0x06, 0x04, 0x00, 0x00},    /* Ascii 26 */
-    {0x00, 0x20, 0x60, 0xff, 0x60, 0x20, 0x00, 0x00},    /* Ascii 27 */
-    {0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xff, 0x00},    /* Ascii 28 */
-    {0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00},    /* Ascii 29 */
-    {0x00, 0x00, 0x10, 0x38, 0x7c, 0xfe, 0x00, 0x00},    /* Ascii 30 */
-    {0x00, 0x00, 0x00, 0xfe, 0x7c, 0x38, 0x10, 0x00},    /* Ascii 31 */
-    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /* */
-    {0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x30, 0x00},    /* ! */
-    {0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    /* " */
-    {0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00},    /* # */
-    {0x10, 0x7c, 0xd2, 0x7c, 0x86, 0x7c, 0x10, 0x00},    /* $ */
-    {0xf0, 0x96, 0xfc, 0x18, 0x3e, 0x72, 0xde, 0x00},    /* % */
-    {0x30, 0x48, 0x30, 0x78, 0xce, 0xcc, 0x78, 0x00},    /* & */
-    {0x0c, 0x0c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},    /* ' */
-    {0x10, 0x60, 0xc0, 0xc0, 0xc0, 0x60, 0x10, 0x00},    /* ( */
-    {0x10, 0x0c, 0x06, 0x06, 0x06, 0x0c, 0x10, 0x00},    /* ) */
-    {0x00, 0x54, 0x38, 0xfe, 0x38, 0x54, 0x00, 0x00},    /* * */
-    {0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00},    /* + */
-    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x70},    /* , */
-    {0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00},    /* - */
-    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00},    /* . */
-    {0x02, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x00},    /* / */
-    {0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00},    /* 0 */
-    {0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x3c, 0x00},    /* 1 */
-    {0x7c, 0xc6, 0x06, 0x0c, 0x30, 0x60, 0xfe, 0x00},    /* 2 */
-    {0x7c, 0xc6, 0x06, 0x3c, 0x06, 0xc6, 0x7c, 0x00},    /* 3 */
-    {0x0e, 0x1e, 0x36, 0x66, 0xfe, 0x06, 0x06, 0x00},    /* 4 */
-    {0xfe, 0xc0, 0xc0, 0xfc, 0x06, 0x06, 0xfc, 0x00},    /* 5 */
-    {0x7c, 0xc6, 0xc0, 0xfc, 0xc6, 0xc6, 0x7c, 0x00},    /* 6 */
-    {0xfe, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x60, 0x00},    /* 7 */
-    {0x7c, 0xc6, 0xc6, 0x7c, 0xc6, 0xc6, 0x7c, 0x00},    /* 8 */
-    {0x7c, 0xc6, 0xc6, 0x7e, 0x06, 0xc6, 0x7c, 0x00},    /* 9 */
-    {0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00},    /* : */
-    {0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x20, 0x00},    /* }, */
-    {0x00, 0x1c, 0x30, 0x60, 0x30, 0x1c, 0x00, 0x00},    /* < */
-    {0x00, 0x00, 0x7e, 0x00, 0x7e, 0x00, 0x00, 0x00},    /* = */
-    {0x00, 0x70, 0x18, 0x0c, 0x18, 0x70, 0x00, 0x00},    /* > */
-    {0x7c, 0xc6, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00},    /* ? */
-    {0x7c, 0x82, 0x9a, 0xaa, 0xaa, 0x9e, 0x7c, 0x00},    /* @ */
-    {0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0x00},    /* A */
-    {0xfc, 0xc6, 0xc6, 0xfc, 0xc6, 0xc6, 0xfc, 0x00},    /* B */
-    {0x7c, 0xc6, 0xc6, 0xc0, 0xc0, 0xc6, 0x7c, 0x00},    /* C */
-    {0xf8, 0xcc, 0xc6, 0xc6, 0xc6, 0xcc, 0xf8, 0x00},    /* D */
-    {0xfe, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xfe, 0x00},    /* E */
-    {0xfe, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0x00},    /* F */
-    {0x7c, 0xc6, 0xc0, 0xce, 0xc6, 0xc6, 0x7e, 0x00},    /* G */
-    {0xc6, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0x00},    /* H */
-    {0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},    /* I */
-    {0x1e, 0x06, 0x06, 0x06, 0xc6, 0xc6, 0x7c, 0x00},    /* J */
-    {0xc6, 0xcc, 0xd8, 0xf0, 0xd8, 0xcc, 0xc6, 0x00},    /* K */
-    {0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0x00},    /* L */
-    {0xc6, 0xee, 0xfe, 0xd6, 0xc6, 0xc6, 0xc6, 0x00},    /* M */
-    {0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00},    /* N */
-    {0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00},    /* O */
-    {0xfc, 0xc6, 0xc6, 0xfc, 0xc0, 0xc0, 0xc0, 0x00},    /* P */
-    {0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x06},    /* Q */
-    {0xfc, 0xc6, 0xc6, 0xfc, 0xc6, 0xc6, 0xc6, 0x00},    /* R */
-    {0x78, 0xcc, 0x60, 0x30, 0x18, 0xcc, 0x78, 0x00},    /* S */
-    {0xfc, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00},    /* T */
-    {0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00},    /* U */
-    {0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00},    /* V */
-    {0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00},    /* W */
-    {0xc6, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0xc6, 0x00},    /* X */
-    {0xc3, 0xc3, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x00},    /* Y */
-    {0xfe, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0xfe, 0x00},    /* Z */
-    {0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00},    /* [ */
-    {0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x00},    /* \ */
-    {0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00},    /* ] */
-    {0x00, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00},    /* ^ */
-    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff},    /* _ */
-    {0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},    /* ` */
-    {0x00, 0x00, 0x7c, 0x06, 0x7e, 0xc6, 0x7e, 0x00},    /* a */
-    {0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xe6, 0xdc, 0x00},    /* b */
-    {0x00, 0x00, 0x7c, 0xc6, 0xc0, 0xc0, 0x7e, 0x00},    /* c */
-    {0x06, 0x06, 0x7e, 0xc6, 0xc6, 0xce, 0x76, 0x00},    /* d */
-    {0x00, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0x7e, 0x00},    /* e */
-    {0x1e, 0x30, 0x7c, 0x30, 0x30, 0x30, 0x30, 0x00},    /* f */
-    {0x00, 0x00, 0x7e, 0xc6, 0xce, 0x76, 0x06, 0x7c},    /* g */
-    {0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xc6, 0xc6, 0x00},    /* */
-    {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3c, 0x00},    /* i */
-    {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0xf0},    /* j */
-    {0xc0, 0xc0, 0xcc, 0xd8, 0xf0, 0xd8, 0xcc, 0x00},    /* k */
-    {0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00},    /* l */
-    {0x00, 0x00, 0xcc, 0xfe, 0xd6, 0xc6, 0xc6, 0x00},    /* m */
-    {0x00, 0x00, 0xfc, 0xc6, 0xc6, 0xc6, 0xc6, 0x00},    /* n */
-    {0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00},    /* o */
-    {0x00, 0x00, 0xfc, 0xc6, 0xc6, 0xe6, 0xdc, 0xc0},    /* p */
-    {0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xce, 0x76, 0x06},    /* q */
-    {0x00, 0x00, 0x6e, 0x70, 0x60, 0x60, 0x60, 0x00},    /* r */
-    {0x00, 0x00, 0x7c, 0xc0, 0x7c, 0x06, 0xfc, 0x00},    /* s */
-    {0x30, 0x30, 0x7c, 0x30, 0x30, 0x30, 0x1c, 0x00},    /* t */
-    {0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x00},    /* u */
-    {0x00, 0x00, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00},    /* v */
-    {0x00, 0x00, 0xc6, 0xc6, 0xd6, 0xfe, 0x6c, 0x00},    /* w */
-    {0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00},    /* x */
-    {0x00, 0x00, 0xc6, 0xc6, 0xce, 0x76, 0x06, 0x7c},    /* y */
-    {0x00, 0x00, 0xfc, 0x18, 0x30, 0x60, 0xfc, 0x00},    /* z */
-    {0x0e, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0e, 0x00},    /* { */
-    {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},    /* | */
-    {0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00},    /* } */
-    {0x00, 0x00, 0x70, 0x9a, 0x0e, 0x00, 0x00, 0x00},    /* ~ */
-    {0x00, 0x00, 0x18, 0x3c, 0x66, 0xff, 0x00, 0x00}    /* Ascii 127 */
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* Ascii 0 */
+    {0x3c, 0x42, 0xa5, 0x81, 0xbd, 0x42, 0x3c, 0x00}, /* Ascii 1 */
+    {0x3c, 0x7e, 0xdb, 0xff, 0xc3, 0x7e, 0x3c, 0x00}, /* Ascii 2 */
+    {0x00, 0xee, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00}, /* Ascii 3 */
+    {0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00}, /* Ascii 4 */
+    {0x00, 0x3c, 0x18, 0xff, 0xff, 0x08, 0x18, 0x00}, /* Ascii 5 */
+    {0x10, 0x38, 0x7c, 0xfe, 0xfe, 0x10, 0x38, 0x00}, /* Ascii 6 */
+    {0x00, 0x00, 0x18, 0x3c, 0x18, 0x00, 0x00, 0x00}, /* Ascii 7 */
+    {0xff, 0xff, 0xe7, 0xc3, 0xe7, 0xff, 0xff, 0xff}, /* Ascii 8 */
+    {0x00, 0x3c, 0x42, 0x81, 0x81, 0x42, 0x3c, 0x00}, /* Ascii 9 */
+    {0xff, 0xc3, 0xbd, 0x7e, 0x7e, 0xbd, 0xc3, 0xff}, /* Ascii 10 */
+    {0x1f, 0x07, 0x0d, 0x7c, 0xc6, 0xc6, 0x7c, 0x00}, /* Ascii 11 */
+    {0x00, 0x7e, 0xc3, 0xc3, 0x7e, 0x18, 0x7e, 0x18}, /* Ascii 12 */
+    {0x04, 0x06, 0x07, 0x04, 0x04, 0xfc, 0xf8, 0x00}, /* Ascii 13 */
+    {0x0c, 0x0a, 0x0d, 0x0b, 0xf9, 0xf9, 0x1f, 0x1f}, /* Ascii 14 */
+    {0x00, 0x92, 0x7c, 0x44, 0xc6, 0x7c, 0x92, 0x00}, /* Ascii 15 */
+    {0x00, 0x00, 0x60, 0x78, 0x7e, 0x78, 0x60, 0x00}, /* Ascii 16 */
+    {0x00, 0x00, 0x06, 0x1e, 0x7e, 0x1e, 0x06, 0x00}, /* Ascii 17 */
+    {0x18, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x18}, /* Ascii 18 */
+    {0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00}, /* Ascii 19 */
+    {0xff, 0xb6, 0x76, 0x36, 0x36, 0x36, 0x36, 0x00}, /* Ascii 20 */
+    {0x7e, 0xc1, 0xdc, 0x22, 0x22, 0x1f, 0x83, 0x7e}, /* Ascii 21 */
+    {0x00, 0x00, 0x00, 0x7e, 0x7e, 0x00, 0x00, 0x00}, /* Ascii 22 */
+    {0x18, 0x7e, 0x18, 0x18, 0x7e, 0x18, 0x00, 0xff}, /* Ascii 23 */
+    {0x18, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00}, /* Ascii 24 */
+    {0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x18, 0x00}, /* Ascii 25 */
+    {0x00, 0x04, 0x06, 0xff, 0x06, 0x04, 0x00, 0x00}, /* Ascii 26 */
+    {0x00, 0x20, 0x60, 0xff, 0x60, 0x20, 0x00, 0x00}, /* Ascii 27 */
+    {0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xff, 0x00}, /* Ascii 28 */
+    {0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00}, /* Ascii 29 */
+    {0x00, 0x00, 0x10, 0x38, 0x7c, 0xfe, 0x00, 0x00}, /* Ascii 30 */
+    {0x00, 0x00, 0x00, 0xfe, 0x7c, 0x38, 0x10, 0x00}, /* Ascii 31 */
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* */
+    {0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x30, 0x00}, /* ! */
+    {0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* " */
+    {0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00}, /* # */
+    {0x10, 0x7c, 0xd2, 0x7c, 0x86, 0x7c, 0x10, 0x00}, /* $ */
+    {0xf0, 0x96, 0xfc, 0x18, 0x3e, 0x72, 0xde, 0x00}, /* % */
+    {0x30, 0x48, 0x30, 0x78, 0xce, 0xcc, 0x78, 0x00}, /* & */
+    {0x0c, 0x0c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00}, /* ' */
+    {0x10, 0x60, 0xc0, 0xc0, 0xc0, 0x60, 0x10, 0x00}, /* ( */
+    {0x10, 0x0c, 0x06, 0x06, 0x06, 0x0c, 0x10, 0x00}, /* ) */
+    {0x00, 0x54, 0x38, 0xfe, 0x38, 0x54, 0x00, 0x00}, /* * */
+    {0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00}, /* + */
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x70}, /* , */
+    {0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00}, /* - */
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00}, /* . */
+    {0x02, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x00}, /* / */
+    {0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00}, /* 0 */
+    {0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x3c, 0x00}, /* 1 */
+    {0x7c, 0xc6, 0x06, 0x0c, 0x30, 0x60, 0xfe, 0x00}, /* 2 */
+    {0x7c, 0xc6, 0x06, 0x3c, 0x06, 0xc6, 0x7c, 0x00}, /* 3 */
+    {0x0e, 0x1e, 0x36, 0x66, 0xfe, 0x06, 0x06, 0x00}, /* 4 */
+    {0xfe, 0xc0, 0xc0, 0xfc, 0x06, 0x06, 0xfc, 0x00}, /* 5 */
+    {0x7c, 0xc6, 0xc0, 0xfc, 0xc6, 0xc6, 0x7c, 0x00}, /* 6 */
+    {0xfe, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x60, 0x00}, /* 7 */
+    {0x7c, 0xc6, 0xc6, 0x7c, 0xc6, 0xc6, 0x7c, 0x00}, /* 8 */
+    {0x7c, 0xc6, 0xc6, 0x7e, 0x06, 0xc6, 0x7c, 0x00}, /* 9 */
+    {0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00}, /* : */
+    {0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x20, 0x00}, /* }, */
+    {0x00, 0x1c, 0x30, 0x60, 0x30, 0x1c, 0x00, 0x00}, /* < */
+    {0x00, 0x00, 0x7e, 0x00, 0x7e, 0x00, 0x00, 0x00}, /* = */
+    {0x00, 0x70, 0x18, 0x0c, 0x18, 0x70, 0x00, 0x00}, /* > */
+    {0x7c, 0xc6, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00}, /* ? */
+    {0x7c, 0x82, 0x9a, 0xaa, 0xaa, 0x9e, 0x7c, 0x00}, /* @ */
+    {0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0x00}, /* A */
+    {0xfc, 0xc6, 0xc6, 0xfc, 0xc6, 0xc6, 0xfc, 0x00}, /* B */
+    {0x7c, 0xc6, 0xc6, 0xc0, 0xc0, 0xc6, 0x7c, 0x00}, /* C */
+    {0xf8, 0xcc, 0xc6, 0xc6, 0xc6, 0xcc, 0xf8, 0x00}, /* D */
+    {0xfe, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xfe, 0x00}, /* E */
+    {0xfe, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0x00}, /* F */
+    {0x7c, 0xc6, 0xc0, 0xce, 0xc6, 0xc6, 0x7e, 0x00}, /* G */
+    {0xc6, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0x00}, /* H */
+    {0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00}, /* I */
+    {0x1e, 0x06, 0x06, 0x06, 0xc6, 0xc6, 0x7c, 0x00}, /* J */
+    {0xc6, 0xcc, 0xd8, 0xf0, 0xd8, 0xcc, 0xc6, 0x00}, /* K */
+    {0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0x00}, /* L */
+    {0xc6, 0xee, 0xfe, 0xd6, 0xc6, 0xc6, 0xc6, 0x00}, /* M */
+    {0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00}, /* N */
+    {0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00}, /* O */
+    {0xfc, 0xc6, 0xc6, 0xfc, 0xc0, 0xc0, 0xc0, 0x00}, /* P */
+    {0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x06}, /* Q */
+    {0xfc, 0xc6, 0xc6, 0xfc, 0xc6, 0xc6, 0xc6, 0x00}, /* R */
+    {0x78, 0xcc, 0x60, 0x30, 0x18, 0xcc, 0x78, 0x00}, /* S */
+    {0xfc, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00}, /* T */
+    {0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00}, /* U */
+    {0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00}, /* V */
+    {0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00}, /* W */
+    {0xc6, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0xc6, 0x00}, /* X */
+    {0xc3, 0xc3, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x00}, /* Y */
+    {0xfe, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0xfe, 0x00}, /* Z */
+    {0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00}, /* [ */
+    {0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x00}, /* \ */
+    {0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00}, /* ] */
+    {0x00, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00}, /* ^ */
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff}, /* _ */
+    {0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00}, /* ` */
+    {0x00, 0x00, 0x7c, 0x06, 0x7e, 0xc6, 0x7e, 0x00}, /* a */
+    {0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xe6, 0xdc, 0x00}, /* b */
+    {0x00, 0x00, 0x7c, 0xc6, 0xc0, 0xc0, 0x7e, 0x00}, /* c */
+    {0x06, 0x06, 0x7e, 0xc6, 0xc6, 0xce, 0x76, 0x00}, /* d */
+    {0x00, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0x7e, 0x00}, /* e */
+    {0x1e, 0x30, 0x7c, 0x30, 0x30, 0x30, 0x30, 0x00}, /* f */
+    {0x00, 0x00, 0x7e, 0xc6, 0xce, 0x76, 0x06, 0x7c}, /* g */
+    {0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xc6, 0xc6, 0x00}, /* */
+    {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3c, 0x00}, /* i */
+    {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0xf0}, /* j */
+    {0xc0, 0xc0, 0xcc, 0xd8, 0xf0, 0xd8, 0xcc, 0x00}, /* k */
+    {0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00}, /* l */
+    {0x00, 0x00, 0xcc, 0xfe, 0xd6, 0xc6, 0xc6, 0x00}, /* m */
+    {0x00, 0x00, 0xfc, 0xc6, 0xc6, 0xc6, 0xc6, 0x00}, /* n */
+    {0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00}, /* o */
+    {0x00, 0x00, 0xfc, 0xc6, 0xc6, 0xe6, 0xdc, 0xc0}, /* p */
+    {0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xce, 0x76, 0x06}, /* q */
+    {0x00, 0x00, 0x6e, 0x70, 0x60, 0x60, 0x60, 0x00}, /* r */
+    {0x00, 0x00, 0x7c, 0xc0, 0x7c, 0x06, 0xfc, 0x00}, /* s */
+    {0x30, 0x30, 0x7c, 0x30, 0x30, 0x30, 0x1c, 0x00}, /* t */
+    {0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x00}, /* u */
+    {0x00, 0x00, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00}, /* v */
+    {0x00, 0x00, 0xc6, 0xc6, 0xd6, 0xfe, 0x6c, 0x00}, /* w */
+    {0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00}, /* x */
+    {0x00, 0x00, 0xc6, 0xc6, 0xce, 0x76, 0x06, 0x7c}, /* y */
+    {0x00, 0x00, 0xfc, 0x18, 0x30, 0x60, 0xfc, 0x00}, /* z */
+    {0x0e, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0e, 0x00}, /* { */
+    {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00}, /* | */
+    {0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00}, /* } */
+    {0x00, 0x00, 0x70, 0x9a, 0x0e, 0x00, 0x00, 0x00}, /* ~ */
+    {0x00, 0x00, 0x18, 0x3c, 0x66, 0xff, 0x00, 0x00}  /* Ascii 127 */
 };
 /*@=charint@*/
 
-void
-GifDrawText8x8(SavedImage *Image, 
-	    const int x, const int y,
-	    const char *legend,
-	    const int color)
-{
-    int i, j;
-    int base;
-    const char *cp;
+void GifDrawText8x8(SavedImage *Image, const int x, const int y,
+                    const char *legend, const int color) {
+	int i, j;
+	const char *cp;
 
-    for (i = 0; i < GIF_FONT_HEIGHT; i++) {
-        base = Image->ImageDesc.Width * (y + i) + x;
+	for (i = 0; i < GIF_FONT_HEIGHT; i++) {
+		int base = Image->ImageDesc.Width * (y + i) + x;
 
-        for (cp = legend; *cp; cp++)
-            for (j = 0; j < GIF_FONT_WIDTH; j++) {
-                if (GifAsciiTable8x8[(short)(*cp)][i] & (1 << (GIF_FONT_WIDTH - j)))
-                    Image->RasterBits[base] = color;
-                base++;
-            }
-    }
+		for (cp = legend; *cp; cp++) {
+			for (j = 0; j < GIF_FONT_WIDTH; j++) {
+				if (GifAsciiTable8x8[(short)(*cp)][i] &
+				    (1 << (GIF_FONT_WIDTH - j))) {
+					Image->RasterBits[base] = color;
+				}
+				base++;
+			}
+		}
+	}
 }
 
-void
-GifDrawBox(SavedImage *Image,
-	   const int x, const int y,
-	   const int w, const int d,
-	   const int color)
-{
-    int j, base = Image->ImageDesc.Width * y + x;
+void GifDrawBox(SavedImage *Image, const int x, const int y, const int w,
+                const int d, const int color) {
+	int j, base = Image->ImageDesc.Width * y + x;
 
-    for (j = 0; j < w; j++)
-        Image->RasterBits[base + j] =
-            Image->RasterBits[base + (d * Image->ImageDesc.Width) + j] = color;
+	for (j = 0; j < w; j++) {
+		Image->RasterBits[base + j] =
+		    Image->RasterBits[base + (d * Image->ImageDesc.Width) + j] =
+		        color;
+	}
 
-    for (j = 0; j < d; j++)
-        Image->RasterBits[base + j * Image->ImageDesc.Width] =
-            Image->RasterBits[base + j * Image->ImageDesc.Width + w] = color;
+	for (j = 0; j < d; j++) {
+		Image->RasterBits[base + j * Image->ImageDesc.Width] =
+		    Image->RasterBits[base + j * Image->ImageDesc.Width + w] =
+		        color;
+	}
 }
 
-void
-GifDrawRectangle(SavedImage *Image,
-              const int x, const int y,
-              const int w, const int d,
-              const int color)
-{
-    unsigned char *bp = Image->RasterBits + Image->ImageDesc.Width * y + x;
-    int i;
+void GifDrawRectangle(SavedImage *Image, const int x, const int y, const int w,
+                      const int d, const int color) {
+	unsigned char *bp = Image->RasterBits + Image->ImageDesc.Width * y + x;
+	int i;
 
-    for (i = 0; i < d; i++)
-        memset(bp + (i * Image->ImageDesc.Width), color, (size_t)w);
+	for (i = 0; i < d; i++) {
+		memset(bp + (i * Image->ImageDesc.Width), color, (size_t)w);
+	}
 }
 
-void
-GifDrawBoxedText8x8(SavedImage *Image,
-              const int x, const int y,
-              const char *legend,
-              const int border,
-              const int bg, const int fg)
-{
-    int j = 0, LineCount = 0, TextWidth = 0;
-    const char *cp;
-    char *dup;
+void GifDrawBoxedText8x8(SavedImage *Image, const int x, const int y,
+                         const char *legend, const int border, const int bg,
+                         const int fg) {
+	int j = 0, LineCount = 0, TextWidth = 0;
+	const char *cp;
+	char *dup;
 
-    /* compute size of text to box */
-    for (cp = legend; *cp; cp++)
-        if (*cp == '\r') {
-            if (j > TextWidth)
-                TextWidth = j;
-            j = 0;
-            LineCount++;
-        } else if (*cp != '\t')
-            ++j;
-    LineCount++;    /* count last line */
-    if (j > TextWidth)    /* last line might be longer than any previous */
-        TextWidth = j;
+	/* compute size of text to box */
+	for (cp = legend; *cp; cp++) {
+		if (*cp == '\r') {
+			if (j > TextWidth) {
+				TextWidth = j;
+			}
+			j = 0;
+			LineCount++;
+		} else if (*cp != '\t') {
+			++j;
+		}
+	}
+	LineCount++;         /* count last line */
+	if (j > TextWidth) { /* last line might be longer than any previous */
+		TextWidth = j;
+	}
 
-    /* draw the text */
-    dup = malloc(strlen(legend)+1);
-    /* FIXME: should return bad status, but that would require API change */
-    if (dup != NULL) {
-	int i = 0;
-	/* fill the box */
-	GifDrawRectangle(Image, x + 1, y + 1,
-		      border + TextWidth * GIF_FONT_WIDTH + border - 1,
-		      border + LineCount * GIF_FONT_HEIGHT + border - 1, bg);
-	(void)strcpy(dup, (char *)legend);
-	cp = strtok((char *)dup, "\r\n");
-	do {
-	    int leadspace = 0;
+	/* draw the text */
+	dup = malloc(strlen(legend) + 1);
+	/* FIXME: should return bad status, but that would require API change */
+	if (dup != NULL) {
+		int i = 0;
+		/* fill the box */
+		GifDrawRectangle(
+		    Image, x + 1, y + 1,
+		    border + TextWidth * GIF_FONT_WIDTH + border - 1,
+		    border + LineCount * GIF_FONT_HEIGHT + border - 1, bg);
+		(void)strcpy(dup, (char *)legend);
+		char *lasts;
+		cp = strtok_r(dup, "\r\n", &lasts);
+		do {
+			int leadspace = 0;
 
-	    if (cp[0] == '\t')
-		leadspace = (TextWidth - strlen(++cp)) / 2;
+			if (cp[0] == '\t') {
+				leadspace = (TextWidth - strlen(++cp)) / 2;
+			}
 
-	    GifDrawText8x8(Image, x + border + (leadspace * GIF_FONT_WIDTH),
-			   y + border + (GIF_FONT_HEIGHT * i++), cp, fg);
-	    cp = strtok((char *)NULL, "\r\n");
-	} while (cp);
-	(void)free((void *)dup);
+			GifDrawText8x8(
+			    Image, x + border + (leadspace * GIF_FONT_WIDTH),
+			    y + border + (GIF_FONT_HEIGHT * i++), cp, fg);
+			cp = strtok_r(NULL, "\r\n", &lasts);
+		} while (cp);
+		(void)free((void *)dup);
 
-	/* outline the box */
-	GifDrawBox(Image, x, y, border + TextWidth * GIF_FONT_WIDTH + border,
-		   border + LineCount * GIF_FONT_HEIGHT + border, fg);
-    }
+		/* outline the box */
+		GifDrawBox(Image, x, y,
+		           border + TextWidth * GIF_FONT_WIDTH + border,
+		           border + LineCount * GIF_FONT_HEIGHT + border, fg);
+	}
 }
 
 /* end */
diff --git a/gif_hash.c b/gif_hash.c
index 61a4d13..ad777cd 100644
--- a/gif_hash.c
+++ b/gif_hash.c
@@ -9,99 +9,98 @@ gif_hash.c -- module to support the following operations:
 
 This module is used to hash the GIF codes during encoding.
 
+SPDX-License-Identifier: MIT
+
 *****************************************************************************/
 
-#include <unistd.h>
-#include <stdint.h>
-#include <stdlib.h>
 #include <fcntl.h>
+#include <stdint.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 
-#include "gif_lib.h"
 #include "gif_hash.h"
+#include "gif_lib.h"
 #include "gif_lib_private.h"
 
 /* #define  DEBUG_HIT_RATE    Debug number of misses per hash Insert/Exists. */
 
-#ifdef	DEBUG_HIT_RATE
-static long NumberOfTests = 0,
-	    NumberOfMisses = 0;
-#endif	/* DEBUG_HIT_RATE */
+#ifdef DEBUG_HIT_RATE
+static long NumberOfTests = 0, NumberOfMisses = 0;
+#endif /* DEBUG_HIT_RATE */
 
 static int KeyItem(uint32_t Item);
 
 /******************************************************************************
  Initialize HashTable - allocate the memory needed and clear it.	      *
 ******************************************************************************/
-GifHashTableType *_InitHashTable(void)
-{
-    GifHashTableType *HashTable;
+GifHashTableType *_InitHashTable(void) {
+	GifHashTableType *HashTable;
 
-    if ((HashTable = (GifHashTableType *) malloc(sizeof(GifHashTableType)))
-	== NULL)
-	return NULL;
+	if ((HashTable = (GifHashTableType *)malloc(
+	         sizeof(GifHashTableType))) == NULL) {
+		return NULL;
+	}
 
-    _ClearHashTable(HashTable);
+	_ClearHashTable(HashTable);
 
-    return HashTable;
+	return HashTable;
 }
 
 /******************************************************************************
  Routine to clear the HashTable to an empty state.			      *
  This part is a little machine depended. Use the commented part otherwise.   *
 ******************************************************************************/
-void _ClearHashTable(GifHashTableType *HashTable)
-{
-    memset(HashTable -> HTable, 0xFF, HT_SIZE * sizeof(uint32_t));
+void _ClearHashTable(GifHashTableType *HashTable) {
+	memset(HashTable->HTable, 0xFF, HT_SIZE * sizeof(uint32_t));
 }
 
 /******************************************************************************
  Routine to insert a new Item into the HashTable. The data is assumed to be  *
  new one.								      *
 ******************************************************************************/
-void _InsertHashTable(GifHashTableType *HashTable, uint32_t Key, int Code)
-{
-    int HKey = KeyItem(Key);
-    uint32_t *HTable = HashTable -> HTable;
+void _InsertHashTable(GifHashTableType *HashTable, uint32_t Key, int Code) {
+	int HKey = KeyItem(Key);
+	uint32_t *HTable = HashTable->HTable;
 
 #ifdef DEBUG_HIT_RATE
 	NumberOfTests++;
 	NumberOfMisses++;
 #endif /* DEBUG_HIT_RATE */
 
-    while (HT_GET_KEY(HTable[HKey]) != 0xFFFFFL) {
+	while (HT_GET_KEY(HTable[HKey]) != 0xFFFFFL) {
 #ifdef DEBUG_HIT_RATE
-	    NumberOfMisses++;
+		NumberOfMisses++;
 #endif /* DEBUG_HIT_RATE */
-	HKey = (HKey + 1) & HT_KEY_MASK;
-    }
-    HTable[HKey] = HT_PUT_KEY(Key) | HT_PUT_CODE(Code);
+		HKey = (HKey + 1) & HT_KEY_MASK;
+	}
+	HTable[HKey] = HT_PUT_KEY(Key) | HT_PUT_CODE(Code);
 }
 
 /******************************************************************************
  Routine to test if given Key exists in HashTable and if so returns its code *
  Returns the Code if key was found, -1 if not.				      *
 ******************************************************************************/
-int _ExistsHashTable(GifHashTableType *HashTable, uint32_t Key)
-{
-    int HKey = KeyItem(Key);
-    uint32_t *HTable = HashTable -> HTable, HTKey;
+int _ExistsHashTable(GifHashTableType *HashTable, uint32_t Key) {
+	int HKey = KeyItem(Key);
+	uint32_t *HTable = HashTable->HTable, HTKey;
 
 #ifdef DEBUG_HIT_RATE
 	NumberOfTests++;
 	NumberOfMisses++;
 #endif /* DEBUG_HIT_RATE */
 
-    while ((HTKey = HT_GET_KEY(HTable[HKey])) != 0xFFFFFL) {
+	while ((HTKey = HT_GET_KEY(HTable[HKey])) != 0xFFFFFL) {
 #ifdef DEBUG_HIT_RATE
-	    NumberOfMisses++;
+		NumberOfMisses++;
 #endif /* DEBUG_HIT_RATE */
-	if (Key == HTKey) return HT_GET_CODE(HTable[HKey]);
-	HKey = (HKey + 1) & HT_KEY_MASK;
-    }
+		if (Key == HTKey) {
+			return HT_GET_CODE(HTable[HKey]);
+		}
+		HKey = (HKey + 1) & HT_KEY_MASK;
+	}
 
-    return -1;
+	return -1;
 }
 
 /******************************************************************************
@@ -111,22 +110,19 @@ int _ExistsHashTable(GifHashTableType *HashTable, uint32_t Key)
  Because the average hit ratio is only 2 (2 hash references per entry),      *
  evaluating more complex keys (such as twin prime keys) does not worth it!   *
 ******************************************************************************/
-static int KeyItem(uint32_t Item)
-{
-    return ((Item >> 12) ^ Item) & HT_KEY_MASK;
+static int KeyItem(uint32_t Item) {
+	return ((Item >> 12) ^ Item) & HT_KEY_MASK;
 }
 
-#ifdef	DEBUG_HIT_RATE
+#ifdef DEBUG_HIT_RATE
 /******************************************************************************
  Debugging routine to print the hit ratio - number of times the hash table   *
  was tested per operation. This routine was used to test the KeyItem routine *
 ******************************************************************************/
-void HashTablePrintHitRatio(void)
-{
-    printf("Hash Table Hit Ratio is %ld/%ld = %ld%%.\n",
-	NumberOfMisses, NumberOfTests,
-	NumberOfMisses * 100 / NumberOfTests);
+void HashTablePrintHitRatio(void) {
+	printf("Hash Table Hit Ratio is %ld/%ld = %ld%%.\n", NumberOfMisses,
+	       NumberOfTests, NumberOfMisses * 100 / NumberOfTests);
 }
-#endif	/* DEBUG_HIT_RATE */
+#endif /* DEBUG_HIT_RATE */
 
 /* end */
diff --git a/gif_hash.h b/gif_hash.h
index ac20a43..e393d80 100644
--- a/gif_hash.h
+++ b/gif_hash.h
@@ -2,31 +2,35 @@
 
 gif_hash.h - magfic constants and declarations for GIF LZW
 
+SPDX-License-Identifier: MIT
+
 ******************************************************************************/
 
 #ifndef _GIF_HASH_H_
 #define _GIF_HASH_H_
 
+#ifndef _WIN32
 #include <unistd.h>
+#endif /* _WIN32 */
 #include <stdint.h>
 
-#define HT_SIZE			8192	   /* 12bits = 4096 or twice as big! */
-#define HT_KEY_MASK		0x1FFF			      /* 13bits keys */
-#define HT_KEY_NUM_BITS		13			      /* 13bits keys */
-#define HT_MAX_KEY		8191	/* 13bits - 1, maximal code possible */
-#define HT_MAX_CODE		4095	/* Biggest code possible in 12 bits. */
+#define HT_SIZE 8192       /* 12bits = 4096 or twice as big! */
+#define HT_KEY_MASK 0x1FFF /* 13bits keys */
+#define HT_KEY_NUM_BITS 13 /* 13bits keys */
+#define HT_MAX_KEY 8191    /* 13bits - 1, maximal code possible */
+#define HT_MAX_CODE 4095   /* Biggest code possible in 12 bits. */
 
 /* The 32 bits of the long are divided into two parts for the key & code:   */
 /* 1. The code is 12 bits as our compression algorithm is limited to 12bits */
 /* 2. The key is 12 bits Prefix code + 8 bit new char or 20 bits.	    */
 /* The key is the upper 20 bits.  The code is the lower 12. */
-#define HT_GET_KEY(l)	(l >> 12)
-#define HT_GET_CODE(l)	(l & 0x0FFF)
-#define HT_PUT_KEY(l)	(l << 12)
-#define HT_PUT_CODE(l)	(l & 0x0FFF)
+#define HT_GET_KEY(l) (l >> 12)
+#define HT_GET_CODE(l) (l & 0x0FFF)
+#define HT_PUT_KEY(l) (l << 12)
+#define HT_PUT_CODE(l) (l & 0x0FFF)
 
 typedef struct GifHashTableType {
-    uint32_t HTable[HT_SIZE];
+	uint32_t HTable[HT_SIZE];
 } GifHashTableType;
 
 GifHashTableType *_InitHashTable(void);
diff --git a/gif_lib.h b/gif_lib.h
index 078930c..b3c7b19 100644
--- a/gif_lib.h
+++ b/gif_lib.h
@@ -1,7 +1,9 @@
 /******************************************************************************
- 
+
 gif_lib.h - service library for decoding and encoding GIF images
-                                                                             
+
+SPDX-License-Identifier: MIT
+
 *****************************************************************************/
 
 #ifndef _GIF_LIB_H_
@@ -12,20 +14,20 @@ extern "C" {
 #endif /* __cplusplus */
 
 #define GIFLIB_MAJOR 5
-#define GIFLIB_MINOR 1
-#define GIFLIB_RELEASE 4
+#define GIFLIB_MINOR 2
+#define GIFLIB_RELEASE 1
 
-#define GIF_ERROR   0
-#define GIF_OK      1
+#define GIF_ERROR 0
+#define GIF_OK 1
 
-#include <stddef.h>
 #include <stdbool.h>
+#include <stddef.h>
 
-#define GIF_STAMP "GIFVER"          /* First chars in file - GIF stamp.  */
+#define GIF_STAMP "GIFVER" /* First chars in file - GIF stamp.  */
 #define GIF_STAMP_LEN sizeof(GIF_STAMP) - 1
-#define GIF_VERSION_POS 3           /* Version first character in stamp. */
-#define GIF87_STAMP "GIF87a"        /* First chars in file - GIF stamp.  */
-#define GIF89_STAMP "GIF89a"        /* First chars in file - GIF stamp.  */
+#define GIF_VERSION_POS 3    /* Version first character in stamp. */
+#define GIF87_STAMP "GIF87a" /* First chars in file - GIF stamp.  */
+#define GIF89_STAMP "GIF89a" /* First chars in file - GIF stamp.  */
 
 typedef unsigned char GifPixelType;
 typedef unsigned char *GifRowType;
@@ -34,88 +36,88 @@ typedef unsigned int GifPrefixType;
 typedef int GifWord;
 
 typedef struct GifColorType {
-    GifByteType Red, Green, Blue;
+	GifByteType Red, Green, Blue;
 } GifColorType;
 
 typedef struct ColorMapObject {
-    int ColorCount;
-    int BitsPerPixel;
-    bool SortFlag;
-    GifColorType *Colors;    /* on malloc(3) heap */
+	int ColorCount;
+	int BitsPerPixel;
+	bool SortFlag;
+	GifColorType *Colors; /* on malloc(3) heap */
 } ColorMapObject;
 
 typedef struct GifImageDesc {
-    GifWord Left, Top, Width, Height;   /* Current image dimensions. */
-    bool Interlace;                     /* Sequential/Interlaced lines. */
-    ColorMapObject *ColorMap;           /* The local color map */
+	GifWord Left, Top, Width, Height; /* Current image dimensions. */
+	bool Interlace;                   /* Sequential/Interlaced lines. */
+	ColorMapObject *ColorMap;         /* The local color map */
 } GifImageDesc;
 
 typedef struct ExtensionBlock {
-    int ByteCount;
-    GifByteType *Bytes; /* on malloc(3) heap */
-    int Function;       /* The block function code */
-#define CONTINUE_EXT_FUNC_CODE    0x00    /* continuation subblock */
-#define COMMENT_EXT_FUNC_CODE     0xfe    /* comment */
-#define GRAPHICS_EXT_FUNC_CODE    0xf9    /* graphics control (GIF89) */
-#define PLAINTEXT_EXT_FUNC_CODE   0x01    /* plaintext */
-#define APPLICATION_EXT_FUNC_CODE 0xff    /* application block */
+	int ByteCount;
+	GifByteType *Bytes;            /* on malloc(3) heap */
+	int Function;                  /* The block function code */
+#define CONTINUE_EXT_FUNC_CODE 0x00    /* continuation subblock */
+#define COMMENT_EXT_FUNC_CODE 0xfe     /* comment */
+#define GRAPHICS_EXT_FUNC_CODE 0xf9    /* graphics control (GIF89) */
+#define PLAINTEXT_EXT_FUNC_CODE 0x01   /* plaintext */
+#define APPLICATION_EXT_FUNC_CODE 0xff /* application block (GIF89) */
 } ExtensionBlock;
 
 typedef struct SavedImage {
-    GifImageDesc ImageDesc;
-    GifByteType *RasterBits;         /* on malloc(3) heap */
-    int ExtensionBlockCount;         /* Count of extensions before image */    
-    ExtensionBlock *ExtensionBlocks; /* Extensions before image */    
+	GifImageDesc ImageDesc;
+	GifByteType *RasterBits;         /* on malloc(3) heap */
+	int ExtensionBlockCount;         /* Count of extensions before image */
+	ExtensionBlock *ExtensionBlocks; /* Extensions before image */
 } SavedImage;
 
 typedef struct GifFileType {
-    GifWord SWidth, SHeight;         /* Size of virtual canvas */
-    GifWord SColorResolution;        /* How many colors can we generate? */
-    GifWord SBackGroundColor;        /* Background color for virtual canvas */
-    GifByteType AspectByte;	     /* Used to compute pixel aspect ratio */
-    ColorMapObject *SColorMap;       /* Global colormap, NULL if nonexistent. */
-    int ImageCount;                  /* Number of current image (both APIs) */
-    GifImageDesc Image;              /* Current image (low-level API) */
-    SavedImage *SavedImages;         /* Image sequence (high-level API) */
-    int ExtensionBlockCount;         /* Count extensions past last image */
-    ExtensionBlock *ExtensionBlocks; /* Extensions past last image */    
-    int Error;			     /* Last error condition reported */
-    void *UserData;                  /* hook to attach user data (TVT) */
-    void *Private;                   /* Don't mess with this! */
+	GifWord SWidth, SHeight;   /* Size of virtual canvas */
+	GifWord SColorResolution;  /* How many colors can we generate? */
+	GifWord SBackGroundColor;  /* Background color for virtual canvas */
+	GifByteType AspectByte;    /* Used to compute pixel aspect ratio */
+	ColorMapObject *SColorMap; /* Global colormap, NULL if nonexistent. */
+	int ImageCount;            /* Number of current image (both APIs) */
+	GifImageDesc Image;        /* Current image (low-level API) */
+	SavedImage *SavedImages;   /* Image sequence (high-level API) */
+	int ExtensionBlockCount;   /* Count extensions past last image */
+	ExtensionBlock *ExtensionBlocks; /* Extensions past last image */
+	int Error;                       /* Last error condition reported */
+	void *UserData;                  /* hook to attach user data (TVT) */
+	void *Private;                   /* Don't mess with this! */
 } GifFileType;
 
-#define GIF_ASPECT_RATIO(n)	((n)+15.0/64.0)
+#define GIF_ASPECT_RATIO(n) ((n) + 15.0 / 64.0)
 
 typedef enum {
-    UNDEFINED_RECORD_TYPE,
-    SCREEN_DESC_RECORD_TYPE,
-    IMAGE_DESC_RECORD_TYPE, /* Begin with ',' */
-    EXTENSION_RECORD_TYPE,  /* Begin with '!' */
-    TERMINATE_RECORD_TYPE   /* Begin with ';' */
+	UNDEFINED_RECORD_TYPE,
+	SCREEN_DESC_RECORD_TYPE,
+	IMAGE_DESC_RECORD_TYPE, /* Begin with ',' */
+	EXTENSION_RECORD_TYPE,  /* Begin with '!' */
+	TERMINATE_RECORD_TYPE   /* Begin with ';' */
 } GifRecordType;
 
 /* func type to read gif data from arbitrary sources (TVT) */
-typedef int (*InputFunc) (GifFileType *, GifByteType *, int);
+typedef int (*InputFunc)(GifFileType *, GifByteType *, int);
 
 /* func type to write gif data to arbitrary targets.
  * Returns count of bytes written. (MRB)
  */
-typedef int (*OutputFunc) (GifFileType *, const GifByteType *, int);
+typedef int (*OutputFunc)(GifFileType *, const GifByteType *, int);
 
 /******************************************************************************
  GIF89 structures
 ******************************************************************************/
 
 typedef struct GraphicsControlBlock {
-    int DisposalMode;
-#define DISPOSAL_UNSPECIFIED      0       /* No disposal specified. */
-#define DISPOSE_DO_NOT            1       /* Leave image in place */
-#define DISPOSE_BACKGROUND        2       /* Set area too background color */
-#define DISPOSE_PREVIOUS          3       /* Restore to previous content */
-    bool UserInputFlag;      /* User confirmation required before disposal */
-    int DelayTime;           /* pre-display delay in 0.01sec units */
-    int TransparentColor;    /* Palette index for transparency, -1 if none */
-#define NO_TRANSPARENT_COLOR	-1
+	int DisposalMode;
+#define DISPOSAL_UNSPECIFIED 0 /* No disposal specified. */
+#define DISPOSE_DO_NOT 1       /* Leave image in place */
+#define DISPOSE_BACKGROUND 2   /* Set area too background color */
+#define DISPOSE_PREVIOUS 3     /* Restore to previous content */
+	bool UserInputFlag;    /* User confirmation required before disposal */
+	int DelayTime;         /* pre-display delay in 0.01sec units */
+	int TransparentColor;  /* Palette index for transparency, -1 if none */
+#define NO_TRANSPARENT_COLOR -1
 } GraphicsControlBlock;
 
 /******************************************************************************
@@ -127,49 +129,44 @@ GifFileType *EGifOpenFileName(const char *GifFileName,
                               const bool GifTestExistence, int *Error);
 GifFileType *EGifOpenFileHandle(const int GifFileHandle, int *Error);
 GifFileType *EGifOpen(void *userPtr, OutputFunc writeFunc, int *Error);
-int EGifSpew(GifFileType * GifFile);
+int EGifSpew(GifFileType *GifFile);
 const char *EGifGetGifVersion(GifFileType *GifFile); /* new in 5.x */
 int EGifCloseFile(GifFileType *GifFile, int *ErrorCode);
 
-#define E_GIF_SUCCEEDED          0
-#define E_GIF_ERR_OPEN_FAILED    1    /* And EGif possible errors. */
-#define E_GIF_ERR_WRITE_FAILED   2
-#define E_GIF_ERR_HAS_SCRN_DSCR  3
-#define E_GIF_ERR_HAS_IMAG_DSCR  4
-#define E_GIF_ERR_NO_COLOR_MAP   5
-#define E_GIF_ERR_DATA_TOO_BIG   6
+#define E_GIF_SUCCEEDED 0
+#define E_GIF_ERR_OPEN_FAILED 1 /* And EGif possible errors. */
+#define E_GIF_ERR_WRITE_FAILED 2
+#define E_GIF_ERR_HAS_SCRN_DSCR 3
+#define E_GIF_ERR_HAS_IMAG_DSCR 4
+#define E_GIF_ERR_NO_COLOR_MAP 5
+#define E_GIF_ERR_DATA_TOO_BIG 6
 #define E_GIF_ERR_NOT_ENOUGH_MEM 7
-#define E_GIF_ERR_DISK_IS_FULL   8
-#define E_GIF_ERR_CLOSE_FAILED   9
-#define E_GIF_ERR_NOT_WRITEABLE  10
+#define E_GIF_ERR_DISK_IS_FULL 8
+#define E_GIF_ERR_CLOSE_FAILED 9
+#define E_GIF_ERR_NOT_WRITEABLE 10
 
 /* These are legacy.  You probably do not want to call them directly */
-int EGifPutScreenDesc(GifFileType *GifFile,
-                      const int GifWidth, const int GifHeight, 
-		      const int GifColorRes,
+int EGifPutScreenDesc(GifFileType *GifFile, const int GifWidth,
+                      const int GifHeight, const int GifColorRes,
                       const int GifBackGround,
                       const ColorMapObject *GifColorMap);
-int EGifPutImageDesc(GifFileType *GifFile, 
-		     const int GifLeft, const int GifTop,
-                     const int GifWidth, const int GifHeight, 
-		     const bool GifInterlace,
+int EGifPutImageDesc(GifFileType *GifFile, const int GifLeft, const int GifTop,
+                     const int GifWidth, const int GifHeight,
+                     const bool GifInterlace,
                      const ColorMapObject *GifColorMap);
 void EGifSetGifVersion(GifFileType *GifFile, const bool gif89);
-int EGifPutLine(GifFileType *GifFile, GifPixelType *GifLine,
-                int GifLineLen);
+int EGifPutLine(GifFileType *GifFile, GifPixelType *GifLine, int GifLineLen);
 int EGifPutPixel(GifFileType *GifFile, const GifPixelType GifPixel);
 int EGifPutComment(GifFileType *GifFile, const char *GifComment);
 int EGifPutExtensionLeader(GifFileType *GifFile, const int GifExtCode);
-int EGifPutExtensionBlock(GifFileType *GifFile,
-                         const int GifExtLen, const void *GifExtension);
+int EGifPutExtensionBlock(GifFileType *GifFile, const int GifExtLen,
+                          const void *GifExtension);
 int EGifPutExtensionTrailer(GifFileType *GifFile);
-int EGifPutExtension(GifFileType *GifFile, const int GifExtCode, 
-		     const int GifExtLen,
-                     const void *GifExtension);
+int EGifPutExtension(GifFileType *GifFile, const int GifExtCode,
+                     const int GifExtLen, const void *GifExtension);
 int EGifPutCode(GifFileType *GifFile, int GifCodeSize,
                 const GifByteType *GifCodeBlock);
-int EGifPutCodeNext(GifFileType *GifFile,
-                    const GifByteType *GifCodeBlock);
+int EGifPutCodeNext(GifFileType *GifFile, const GifByteType *GifCodeBlock);
 
 /******************************************************************************
  GIF decoding routines
@@ -178,32 +175,33 @@ int EGifPutCodeNext(GifFileType *GifFile,
 /* Main entry points */
 GifFileType *DGifOpenFileName(const char *GifFileName, int *Error);
 GifFileType *DGifOpenFileHandle(int GifFileHandle, int *Error);
-int DGifSlurp(GifFileType * GifFile);
-GifFileType *DGifOpen(void *userPtr, InputFunc readFunc, int *Error);    /* new one (TVT) */
-    int DGifCloseFile(GifFileType * GifFile, int *ErrorCode);
-
-#define D_GIF_SUCCEEDED          0
-#define D_GIF_ERR_OPEN_FAILED    101    /* And DGif possible errors. */
-#define D_GIF_ERR_READ_FAILED    102
-#define D_GIF_ERR_NOT_GIF_FILE   103
-#define D_GIF_ERR_NO_SCRN_DSCR   104
-#define D_GIF_ERR_NO_IMAG_DSCR   105
-#define D_GIF_ERR_NO_COLOR_MAP   106
-#define D_GIF_ERR_WRONG_RECORD   107
-#define D_GIF_ERR_DATA_TOO_BIG   108
+int DGifSlurp(GifFileType *GifFile);
+GifFileType *DGifOpen(void *userPtr, InputFunc readFunc,
+                      int *Error); /* new one (TVT) */
+int DGifCloseFile(GifFileType *GifFile, int *ErrorCode);
+
+#define D_GIF_SUCCEEDED 0
+#define D_GIF_ERR_OPEN_FAILED 101 /* And DGif possible errors. */
+#define D_GIF_ERR_READ_FAILED 102
+#define D_GIF_ERR_NOT_GIF_FILE 103
+#define D_GIF_ERR_NO_SCRN_DSCR 104
+#define D_GIF_ERR_NO_IMAG_DSCR 105
+#define D_GIF_ERR_NO_COLOR_MAP 106
+#define D_GIF_ERR_WRONG_RECORD 107
+#define D_GIF_ERR_DATA_TOO_BIG 108
 #define D_GIF_ERR_NOT_ENOUGH_MEM 109
-#define D_GIF_ERR_CLOSE_FAILED   110
-#define D_GIF_ERR_NOT_READABLE   111
-#define D_GIF_ERR_IMAGE_DEFECT   112
-#define D_GIF_ERR_EOF_TOO_SOON   113
+#define D_GIF_ERR_CLOSE_FAILED 110
+#define D_GIF_ERR_NOT_READABLE 111
+#define D_GIF_ERR_IMAGE_DEFECT 112
+#define D_GIF_ERR_EOF_TOO_SOON 113
 
 /* These are legacy.  You probably do not want to call them directly */
 int DGifGetScreenDesc(GifFileType *GifFile);
 int DGifGetRecordType(GifFileType *GifFile, GifRecordType *GifType);
+int DGifGetImageHeader(GifFileType *GifFile);
 int DGifGetImageDesc(GifFileType *GifFile);
 int DGifGetLine(GifFileType *GifFile, GifPixelType *GifLine, int GifLineLen);
 int DGifGetPixel(GifFileType *GifFile, GifPixelType GifPixel);
-int DGifGetComment(GifFileType *GifFile, char *GifComment);
 int DGifGetExtension(GifFileType *GifFile, int *GifExtCode,
                      GifByteType **GifExtension);
 int DGifGetExtensionNext(GifFileType *GifFile, GifByteType **GifExtension);
@@ -211,21 +209,12 @@ int DGifGetCode(GifFileType *GifFile, int *GifCodeSize,
                 GifByteType **GifCodeBlock);
 int DGifGetCodeNext(GifFileType *GifFile, GifByteType **GifCodeBlock);
 int DGifGetLZCodes(GifFileType *GifFile, int *GifCode);
-
-
-/******************************************************************************
- Color table quantization (deprecated)
-******************************************************************************/
-int GifQuantizeBuffer(unsigned int Width, unsigned int Height,
-                   int *ColorMapSize, GifByteType * RedInput,
-                   GifByteType * GreenInput, GifByteType * BlueInput,
-                   GifByteType * OutputBuffer,
-                   GifColorType * OutputColorMap);
+const char *DGifGetGifVersion(GifFileType *GifFile);
 
 /******************************************************************************
  Error handling and reporting.
 ******************************************************************************/
-extern const char *GifErrorString(int ErrorCode);     /* new in 2012 - ESR */
+extern const char *GifErrorString(int ErrorCode); /* new in 2012 - ESR */
 
 /*****************************************************************************
  Everything below this point is new after version 1.2, supporting `slurp
@@ -237,29 +226,26 @@ extern const char *GifErrorString(int ErrorCode);     /* new in 2012 - ESR */
 ******************************************************************************/
 
 extern ColorMapObject *GifMakeMapObject(int ColorCount,
-                                     const GifColorType *ColorMap);
+                                        const GifColorType *ColorMap);
 extern void GifFreeMapObject(ColorMapObject *Object);
 extern ColorMapObject *GifUnionColorMap(const ColorMapObject *ColorIn1,
-                                     const ColorMapObject *ColorIn2,
-                                     GifPixelType ColorTransIn2[]);
+                                        const ColorMapObject *ColorIn2,
+                                        GifPixelType ColorTransIn2[]);
 extern int GifBitSize(int n);
 
-extern void *
-reallocarray(void *optr, size_t nmemb, size_t size);
-
 /******************************************************************************
- Support for the in-core structures allocation (slurp mode).              
+ Support for the in-core structures allocation (slurp mode).
 ******************************************************************************/
 
-extern void GifApplyTranslation(SavedImage *Image, GifPixelType Translation[]);
+extern void GifApplyTranslation(SavedImage *Image,
+                                const GifPixelType Translation[]);
 extern int GifAddExtensionBlock(int *ExtensionBlock_Count,
-				ExtensionBlock **ExtensionBlocks, 
-				int Function, 
-				unsigned int Len, unsigned char ExtData[]);
+                                ExtensionBlock **ExtensionBlocks, int Function,
+                                unsigned int Len, unsigned char ExtData[]);
 extern void GifFreeExtensions(int *ExtensionBlock_Count,
-			      ExtensionBlock **ExtensionBlocks);
+                              ExtensionBlock **ExtensionBlocks);
 extern SavedImage *GifMakeSavedImage(GifFileType *GifFile,
-                                  const SavedImage *CopyFrom);
+                                     const SavedImage *CopyFrom);
 extern void GifFreeSavedImages(GifFileType *GifFile);
 
 /******************************************************************************
@@ -267,42 +253,36 @@ extern void GifFreeSavedImages(GifFileType *GifFile);
 ******************************************************************************/
 
 int DGifExtensionToGCB(const size_t GifExtensionLength,
-		       const GifByteType *GifExtension,
-		       GraphicsControlBlock *GCB);
+                       const GifByteType *GifExtension,
+                       GraphicsControlBlock *GCB);
 size_t EGifGCBToExtension(const GraphicsControlBlock *GCB,
-		       GifByteType *GifExtension);
+                          GifByteType *GifExtension);
 
-int DGifSavedExtensionToGCB(GifFileType *GifFile, 
-			    int ImageIndex, 
-			    GraphicsControlBlock *GCB);
-int EGifGCBToSavedExtension(const GraphicsControlBlock *GCB, 
-			    GifFileType *GifFile, 
-			    int ImageIndex);
+int DGifSavedExtensionToGCB(GifFileType *GifFile, int ImageIndex,
+                            GraphicsControlBlock *GCB);
+int EGifGCBToSavedExtension(const GraphicsControlBlock *GCB,
+                            GifFileType *GifFile, int ImageIndex);
 
 /******************************************************************************
- The library's internal utility font                          
+ The library's internal utility font
 ******************************************************************************/
 
-#define GIF_FONT_WIDTH  8
+#define GIF_FONT_WIDTH 8
 #define GIF_FONT_HEIGHT 8
 extern const unsigned char GifAsciiTable8x8[][GIF_FONT_WIDTH];
 
-extern void GifDrawText8x8(SavedImage *Image,
-                     const int x, const int y,
-                     const char *legend, const int color);
+extern void GifDrawText8x8(SavedImage *Image, const int x, const int y,
+                           const char *legend, const int color);
 
-extern void GifDrawBox(SavedImage *Image,
-                    const int x, const int y,
-                    const int w, const int d, const int color);
+extern void GifDrawBox(SavedImage *Image, const int x, const int y, const int w,
+                       const int d, const int color);
 
-extern void GifDrawRectangle(SavedImage *Image,
-                   const int x, const int y,
-                   const int w, const int d, const int color);
+extern void GifDrawRectangle(SavedImage *Image, const int x, const int y,
+                             const int w, const int d, const int color);
 
-extern void GifDrawBoxedText8x8(SavedImage *Image,
-                          const int x, const int y,
-                          const char *legend,
-                          const int border, const int bg, const int fg);
+extern void GifDrawBoxedText8x8(SavedImage *Image, const int x, const int y,
+                                const char *legend, const int border,
+                                const int bg, const int fg);
 
 #ifdef __cplusplus
 }
diff --git a/gif_lib_private.h b/gif_lib_private.h
index adaf557..19578d4 100644
--- a/gif_lib_private.h
+++ b/gif_lib_private.h
@@ -2,58 +2,71 @@
 
 gif_lib_private.h - internal giflib routines and structures
 
+SPDX-License-Identifier: MIT
+
 ****************************************************************************/
 
 #ifndef _GIF_LIB_PRIVATE_H
 #define _GIF_LIB_PRIVATE_H
 
-#include "gif_lib.h"
 #include "gif_hash.h"
+#include "gif_lib.h"
 
-#define EXTENSION_INTRODUCER      0x21
-#define DESCRIPTOR_INTRODUCER     0x2c
-#define TERMINATOR_INTRODUCER     0x3b
+#ifndef SIZE_MAX
+#define SIZE_MAX UINTPTR_MAX
+#endif
 
-#define LZ_MAX_CODE         4095    /* Biggest code possible in 12 bits. */
-#define LZ_BITS             12
+#define EXTENSION_INTRODUCER 0x21
+#define DESCRIPTOR_INTRODUCER 0x2c
+#define TERMINATOR_INTRODUCER 0x3b
 
-#define FLUSH_OUTPUT        4096    /* Impossible code, to signal flush. */
-#define FIRST_CODE          4097    /* Impossible code, to signal first. */
-#define NO_SUCH_CODE        4098    /* Impossible code, to signal empty. */
+#define LZ_MAX_CODE 4095 /* Biggest code possible in 12 bits. */
+#define LZ_BITS 12
 
-#define FILE_STATE_WRITE    0x01
-#define FILE_STATE_SCREEN   0x02
-#define FILE_STATE_IMAGE    0x04
-#define FILE_STATE_READ     0x08
+#define FLUSH_OUTPUT 4096 /* Impossible code, to signal flush. */
+#define FIRST_CODE 4097   /* Impossible code, to signal first. */
+#define NO_SUCH_CODE 4098 /* Impossible code, to signal empty. */
 
-#define IS_READABLE(Private)    (Private->FileState & FILE_STATE_READ)
-#define IS_WRITEABLE(Private)   (Private->FileState & FILE_STATE_WRITE)
+#define FILE_STATE_WRITE 0x01
+#define FILE_STATE_SCREEN 0x02
+#define FILE_STATE_IMAGE 0x04
+#define FILE_STATE_READ 0x08
+
+#define IS_READABLE(Private) (Private->FileState & FILE_STATE_READ)
+#define IS_WRITEABLE(Private) (Private->FileState & FILE_STATE_WRITE)
 
 typedef struct GifFilePrivateType {
-    GifWord FileState, FileHandle,  /* Where all this data goes to! */
-      BitsPerPixel,     /* Bits per pixel (Codes uses at least this + 1). */
-      ClearCode,   /* The CLEAR LZ code. */
-      EOFCode,     /* The EOF LZ code. */
-      RunningCode, /* The next code algorithm can generate. */
-      RunningBits, /* The number of bits required to represent RunningCode. */
-      MaxCode1,    /* 1 bigger than max. possible code, in RunningBits bits. */
-      LastCode,    /* The code before the current code. */
-      CrntCode,    /* Current algorithm code. */
-      StackPtr,    /* For character stack (see below). */
-      CrntShiftState;    /* Number of bits in CrntShiftDWord. */
-    unsigned long CrntShiftDWord;   /* For bytes decomposition into codes. */
-    unsigned long PixelCount;   /* Number of pixels in image. */
-    FILE *File;    /* File as stream. */
-    InputFunc Read;     /* function to read gif input (TVT) */
-    OutputFunc Write;   /* function to write gif output (MRB) */
-    GifByteType Buf[256];   /* Compressed input is buffered here. */
-    GifByteType Stack[LZ_MAX_CODE]; /* Decoded pixels are stacked here. */
-    GifByteType Suffix[LZ_MAX_CODE + 1];    /* So we can trace the codes. */
-    GifPrefixType Prefix[LZ_MAX_CODE + 1];
-    GifHashTableType *HashTable;
-    bool gif89;
+	GifWord FileState, FileHandle, /* Where all this data goes to! */
+	    BitsPerPixel, /* Bits per pixel (Codes uses at least this + 1). */
+	    ClearCode,    /* The CLEAR LZ code. */
+	    EOFCode,      /* The EOF LZ code. */
+	    RunningCode,  /* The next code algorithm can generate. */
+	    RunningBits,  /* The number of bits required to represent
+	                     RunningCode. */
+	    MaxCode1, /* 1 bigger than max. possible code, in RunningBits bits.
+	               */
+	    LastCode, /* The code before the current code. */
+	    CrntCode, /* Current algorithm code. */
+	    StackPtr, /* For character stack (see below). */
+	    CrntShiftState;           /* Number of bits in CrntShiftDWord. */
+	unsigned long CrntShiftDWord; /* For bytes decomposition into codes. */
+	unsigned long PixelCount;     /* Number of pixels in image. */
+	FILE *File;                   /* File as stream. */
+	InputFunc Read;               /* function to read gif input (TVT) */
+	OutputFunc Write;             /* function to write gif output (MRB) */
+	GifByteType Buf[256];         /* Compressed input is buffered here. */
+	GifByteType Stack[LZ_MAX_CODE]; /* Decoded pixels are stacked here. */
+	GifByteType Suffix[LZ_MAX_CODE + 1]; /* So we can trace the codes. */
+	GifPrefixType Prefix[LZ_MAX_CODE + 1];
+	GifHashTableType *HashTable;
+	bool gif89;
 } GifFilePrivateType;
 
+#ifndef HAVE_REALLOCARRAY
+extern void *openbsd_reallocarray(void *optr, size_t nmemb, size_t size);
+#define reallocarray openbsd_reallocarray
+#endif
+
 #endif /* _GIF_LIB_PRIVATE_H */
 
 /* end */
diff --git a/gifalloc.c b/gifalloc.c
index 3b51868..47c6539 100644
--- a/gifalloc.c
+++ b/gifalloc.c
@@ -2,411 +2,424 @@
 
  GIF construction tools
 
+SPDX-License-Identifier: MIT
+
 ****************************************************************************/
 
-#include <stdlib.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 
 #include "gif_lib.h"
+#include "gif_lib_private.h"
 
-#define MAX(x, y)    (((x) > (y)) ? (x) : (y))
+#define MAX(x, y) (((x) > (y)) ? (x) : (y))
 
 /******************************************************************************
- Miscellaneous utility functions                          
+ Miscellaneous utility functions
 ******************************************************************************/
 
 /* return smallest bitfield size n will fit in */
-int
-GifBitSize(int n)
-{
-    register int i;
-
-    for (i = 1; i <= 8; i++)
-        if ((1 << i) >= n)
-            break;
-    return (i);
+int GifBitSize(int n) {
+	register int i;
+
+	for (i = 1; i <= 8; i++) {
+		if ((1 << i) >= n) {
+			break;
+		}
+	}
+	return (i);
 }
 
 /******************************************************************************
-  Color map object functions                              
+ Color map object functions
 ******************************************************************************/
 
 /*
  * Allocate a color map of given size; initialize with contents of
  * ColorMap if that pointer is non-NULL.
  */
-ColorMapObject *
-GifMakeMapObject(int ColorCount, const GifColorType *ColorMap)
-{
-    ColorMapObject *Object;
-
-    /*** FIXME: Our ColorCount has to be a power of two.  Is it necessary to
-     * make the user know that or should we automatically round up instead? */
-    if (ColorCount != (1 << GifBitSize(ColorCount))) {
-        return ((ColorMapObject *) NULL);
-    }
-    
-    Object = (ColorMapObject *)malloc(sizeof(ColorMapObject));
-    if (Object == (ColorMapObject *) NULL) {
-        return ((ColorMapObject *) NULL);
-    }
-
-    Object->Colors = (GifColorType *)calloc(ColorCount, sizeof(GifColorType));
-    if (Object->Colors == (GifColorType *) NULL) {
-	free(Object);
-        return ((ColorMapObject *) NULL);
-    }
-
-    Object->ColorCount = ColorCount;
-    Object->BitsPerPixel = GifBitSize(ColorCount);
-    Object->SortFlag = false;
-
-    if (ColorMap != NULL) {
-        memcpy((char *)Object->Colors,
-               (char *)ColorMap, ColorCount * sizeof(GifColorType));
-    }
-
-    return (Object);
+ColorMapObject *GifMakeMapObject(int ColorCount, const GifColorType *ColorMap) {
+	ColorMapObject *Object;
+
+	/*** FIXME: Our ColorCount has to be a power of two.  Is it necessary to
+	 * make the user know that or should we automatically round up instead?
+	 */
+	if (ColorCount != (1 << GifBitSize(ColorCount))) {
+		return ((ColorMapObject *)NULL);
+	}
+
+	Object = (ColorMapObject *)malloc(sizeof(ColorMapObject));
+	if (Object == (ColorMapObject *)NULL) {
+		return ((ColorMapObject *)NULL);
+	}
+
+	Object->Colors =
+	    (GifColorType *)calloc(ColorCount, sizeof(GifColorType));
+	if (Object->Colors == (GifColorType *)NULL) {
+		free(Object);
+		return ((ColorMapObject *)NULL);
+	}
+
+	Object->ColorCount = ColorCount;
+	Object->BitsPerPixel = GifBitSize(ColorCount);
+	Object->SortFlag = false;
+
+	if (ColorMap != NULL) {
+		memcpy((char *)Object->Colors, (char *)ColorMap,
+		       ColorCount * sizeof(GifColorType));
+	}
+
+	return (Object);
 }
 
 /*******************************************************************************
-Free a color map object
+ Free a color map object
 *******************************************************************************/
-void
-GifFreeMapObject(ColorMapObject *Object)
-{
-    if (Object != NULL) {
-        (void)free(Object->Colors);
-        (void)free(Object);
-    }
+void GifFreeMapObject(ColorMapObject *Object) {
+	if (Object != NULL) {
+		(void)free(Object->Colors);
+		(void)free(Object);
+	}
 }
 
 #ifdef DEBUG
-void
-DumpColorMap(ColorMapObject *Object,
-             FILE * fp)
-{
-    if (Object != NULL) {
-        int i, j, Len = Object->ColorCount;
-
-        for (i = 0; i < Len; i += 4) {
-            for (j = 0; j < 4 && j < Len; j++) {
-                (void)fprintf(fp, "%3d: %02x %02x %02x   ", i + j,
-			      Object->Colors[i + j].Red,
-			      Object->Colors[i + j].Green,
-			      Object->Colors[i + j].Blue);
-            }
-            (void)fprintf(fp, "\n");
-        }
-    }
+void DumpColorMap(ColorMapObject *Object, FILE *fp) {
+	if (Object != NULL) {
+		int i, j, Len = Object->ColorCount;
+
+		for (i = 0; i < Len; i += 4) {
+			for (j = 0; j < 4 && j < Len; j++) {
+				(void)fprintf(fp, "%3d: %02x %02x %02x   ",
+				              i + j, Object->Colors[i + j].Red,
+				              Object->Colors[i + j].Green,
+				              Object->Colors[i + j].Blue);
+			}
+			(void)fprintf(fp, "\n");
+		}
+	}
 }
 #endif /* DEBUG */
 
 /*******************************************************************************
- Compute the union of two given color maps and return it.  If result can't 
+ Compute the union of two given color maps and return it.  If result can't
  fit into 256 colors, NULL is returned, the allocated union otherwise.
  ColorIn1 is copied as is to ColorUnion, while colors from ColorIn2 are
  copied iff they didn't exist before.  ColorTransIn2 maps the old
  ColorIn2 into the ColorUnion color map table./
 *******************************************************************************/
-ColorMapObject *
-GifUnionColorMap(const ColorMapObject *ColorIn1,
-              const ColorMapObject *ColorIn2,
-              GifPixelType ColorTransIn2[])
-{
-    int i, j, CrntSlot, RoundUpTo, NewGifBitSize;
-    ColorMapObject *ColorUnion;
-
-    /*
-     * We don't worry about duplicates within either color map; if
-     * the caller wants to resolve those, he can perform unions
-     * with an empty color map.
-     */
-
-    /* Allocate table which will hold the result for sure. */
-    ColorUnion = GifMakeMapObject(MAX(ColorIn1->ColorCount,
-                               ColorIn2->ColorCount) * 2, NULL);
-
-    if (ColorUnion == NULL)
-        return (NULL);
-
-    /* 
-     * Copy ColorIn1 to ColorUnion.
-     */
-    for (i = 0; i < ColorIn1->ColorCount; i++)
-        ColorUnion->Colors[i] = ColorIn1->Colors[i];
-    CrntSlot = ColorIn1->ColorCount;
-
-    /* 
-     * Potentially obnoxious hack:
-     *
-     * Back CrntSlot down past all contiguous {0, 0, 0} slots at the end
-     * of table 1.  This is very useful if your display is limited to
-     * 16 colors.
-     */
-    while (ColorIn1->Colors[CrntSlot - 1].Red == 0
-           && ColorIn1->Colors[CrntSlot - 1].Green == 0
-           && ColorIn1->Colors[CrntSlot - 1].Blue == 0)
-        CrntSlot--;
-
-    /* Copy ColorIn2 to ColorUnion (use old colors if they exist): */
-    for (i = 0; i < ColorIn2->ColorCount && CrntSlot <= 256; i++) {
-        /* Let's see if this color already exists: */
-        for (j = 0; j < ColorIn1->ColorCount; j++)
-            if (memcmp (&ColorIn1->Colors[j], &ColorIn2->Colors[i], 
-                        sizeof(GifColorType)) == 0)
-                break;
-
-        if (j < ColorIn1->ColorCount)
-            ColorTransIn2[i] = j;    /* color exists in Color1 */
-        else {
-            /* Color is new - copy it to a new slot: */
-            ColorUnion->Colors[CrntSlot] = ColorIn2->Colors[i];
-            ColorTransIn2[i] = CrntSlot++;
-        }
-    }
-
-    if (CrntSlot > 256) {
-        GifFreeMapObject(ColorUnion);
-        return ((ColorMapObject *) NULL);
-    }
-
-    NewGifBitSize = GifBitSize(CrntSlot);
-    RoundUpTo = (1 << NewGifBitSize);
-
-    if (RoundUpTo != ColorUnion->ColorCount) {
-        register GifColorType *Map = ColorUnion->Colors;
-
-        /* 
-         * Zero out slots up to next power of 2.
-         * We know these slots exist because of the way ColorUnion's
-         * start dimension was computed.
-         */
-        for (j = CrntSlot; j < RoundUpTo; j++)
-            Map[j].Red = Map[j].Green = Map[j].Blue = 0;
-
-        /* perhaps we can shrink the map? */
-        if (RoundUpTo < ColorUnion->ColorCount) {
-            GifColorType *new_map = (GifColorType *)reallocarray(Map,
-                                 RoundUpTo, sizeof(GifColorType));
-            if( new_map == NULL ) {
-                GifFreeMapObject(ColorUnion);
-                return ((ColorMapObject *) NULL);
-            }
-            ColorUnion->Colors = new_map;
-        }
-    }
-
-    ColorUnion->ColorCount = RoundUpTo;
-    ColorUnion->BitsPerPixel = NewGifBitSize;
-
-    return (ColorUnion);
+ColorMapObject *GifUnionColorMap(const ColorMapObject *ColorIn1,
+                                 const ColorMapObject *ColorIn2,
+                                 GifPixelType ColorTransIn2[]) {
+	int i, j, CrntSlot, RoundUpTo, NewGifBitSize;
+	ColorMapObject *ColorUnion;
+
+	/*
+	 * We don't worry about duplicates within either color map; if
+	 * the caller wants to resolve those, he can perform unions
+	 * with an empty color map.
+	 */
+
+	/* Allocate table which will hold the result for sure. */
+	ColorUnion = GifMakeMapObject(
+	    MAX(ColorIn1->ColorCount, ColorIn2->ColorCount) * 2, NULL);
+
+	if (ColorUnion == NULL) {
+		return (NULL);
+	}
+
+	/*
+	 * Copy ColorIn1 to ColorUnion.
+	 */
+	for (i = 0; i < ColorIn1->ColorCount; i++) {
+		ColorUnion->Colors[i] = ColorIn1->Colors[i];
+	}
+	CrntSlot = ColorIn1->ColorCount;
+
+	/*
+	 * Potentially obnoxious hack:
+	 *
+	 * Back CrntSlot down past all contiguous {0, 0, 0} slots at the end
+	 * of table 1.  This is very useful if your display is limited to
+	 * 16 colors.
+	 */
+	while (ColorIn1->Colors[CrntSlot - 1].Red == 0 &&
+	       ColorIn1->Colors[CrntSlot - 1].Green == 0 &&
+	       ColorIn1->Colors[CrntSlot - 1].Blue == 0) {
+		CrntSlot--;
+	}
+
+	/* Copy ColorIn2 to ColorUnion (use old colors if they exist): */
+	for (i = 0; i < ColorIn2->ColorCount && CrntSlot <= 256; i++) {
+		/* Let's see if this color already exists: */
+		for (j = 0; j < ColorIn1->ColorCount; j++) {
+			if (memcmp(&ColorIn1->Colors[j], &ColorIn2->Colors[i],
+			           sizeof(GifColorType)) == 0) {
+				break;
+			}
+		}
+
+		if (j < ColorIn1->ColorCount) {
+			ColorTransIn2[i] = j; /* color exists in Color1 */
+		} else {
+			/* Color is new - copy it to a new slot: */
+			ColorUnion->Colors[CrntSlot] = ColorIn2->Colors[i];
+			ColorTransIn2[i] = CrntSlot++;
+		}
+	}
+
+	if (CrntSlot > 256) {
+		GifFreeMapObject(ColorUnion);
+		return ((ColorMapObject *)NULL);
+	}
+
+	NewGifBitSize = GifBitSize(CrntSlot);
+	RoundUpTo = (1 << NewGifBitSize);
+
+	if (RoundUpTo != ColorUnion->ColorCount) {
+		register GifColorType *Map = ColorUnion->Colors;
+
+		/*
+		 * Zero out slots up to next power of 2.
+		 * We know these slots exist because of the way ColorUnion's
+		 * start dimension was computed.
+		 */
+		for (j = CrntSlot; j < RoundUpTo; j++) {
+			Map[j].Red = Map[j].Green = Map[j].Blue = 0;
+		}
+
+		/* perhaps we can shrink the map? */
+		if (RoundUpTo < ColorUnion->ColorCount) {
+			GifColorType *new_map = (GifColorType *)reallocarray(
+			    Map, RoundUpTo, sizeof(GifColorType));
+			if (new_map == NULL) {
+				GifFreeMapObject(ColorUnion);
+				return ((ColorMapObject *)NULL);
+			}
+			ColorUnion->Colors = new_map;
+		}
+	}
+
+	ColorUnion->ColorCount = RoundUpTo;
+	ColorUnion->BitsPerPixel = NewGifBitSize;
+
+	return (ColorUnion);
 }
 
 /*******************************************************************************
  Apply a given color translation to the raster bits of an image
 *******************************************************************************/
-void
-GifApplyTranslation(SavedImage *Image, GifPixelType Translation[])
-{
-    register int i;
-    register int RasterSize = Image->ImageDesc.Height * Image->ImageDesc.Width;
-
-    for (i = 0; i < RasterSize; i++)
-        Image->RasterBits[i] = Translation[Image->RasterBits[i]];
+void GifApplyTranslation(SavedImage *Image, const GifPixelType Translation[]) {
+	register int i;
+	register int RasterSize =
+	    Image->ImageDesc.Height * Image->ImageDesc.Width;
+
+	for (i = 0; i < RasterSize; i++) {
+		Image->RasterBits[i] = Translation[Image->RasterBits[i]];
+	}
 }
 
 /******************************************************************************
- Extension record functions                              
+ Extension record functions
 ******************************************************************************/
-int
-GifAddExtensionBlock(int *ExtensionBlockCount,
-		     ExtensionBlock **ExtensionBlocks,
-		     int Function,
-		     unsigned int Len,
-		     unsigned char ExtData[])
-{
-    ExtensionBlock *ep;
-
-    if (*ExtensionBlocks == NULL)
-        *ExtensionBlocks=(ExtensionBlock *)malloc(sizeof(ExtensionBlock));
-    else {
-        ExtensionBlock* ep_new = (ExtensionBlock *)reallocarray
-				 (*ExtensionBlocks, (*ExtensionBlockCount + 1),
-                                      sizeof(ExtensionBlock));
-        if( ep_new == NULL )
-            return (GIF_ERROR);
-        *ExtensionBlocks = ep_new;
-    }
-
-    if (*ExtensionBlocks == NULL)
-        return (GIF_ERROR);
-
-    ep = &(*ExtensionBlocks)[(*ExtensionBlockCount)++];
-
-    ep->Function = Function;
-    ep->ByteCount=Len;
-    ep->Bytes = (GifByteType *)malloc(ep->ByteCount);
-    if (ep->Bytes == NULL)
-        return (GIF_ERROR);
-
-    if (ExtData != NULL) {
-        memcpy(ep->Bytes, ExtData, Len);
-    }
-
-    return (GIF_OK);
+int GifAddExtensionBlock(int *ExtensionBlockCount,
+                         ExtensionBlock **ExtensionBlocks, int Function,
+                         unsigned int Len, unsigned char ExtData[]) {
+	ExtensionBlock *ep;
+
+	if (*ExtensionBlocks == NULL) {
+		*ExtensionBlocks =
+		    (ExtensionBlock *)malloc(sizeof(ExtensionBlock));
+	} else {
+		ExtensionBlock *ep_new = (ExtensionBlock *)reallocarray(
+		    *ExtensionBlocks, (*ExtensionBlockCount + 1),
+		    sizeof(ExtensionBlock));
+		if (ep_new == NULL) {
+			return (GIF_ERROR);
+		}
+		*ExtensionBlocks = ep_new;
+	}
+
+	if (*ExtensionBlocks == NULL) {
+		return (GIF_ERROR);
+	}
+
+	ep = &(*ExtensionBlocks)[(*ExtensionBlockCount)++];
+
+	ep->Function = Function;
+	ep->ByteCount = Len;
+	ep->Bytes = (GifByteType *)malloc(ep->ByteCount);
+	if (ep->Bytes == NULL) {
+		return (GIF_ERROR);
+	}
+
+	if (ExtData != NULL) {
+		memcpy(ep->Bytes, ExtData, Len);
+	}
+
+	return (GIF_OK);
 }
 
-void
-GifFreeExtensions(int *ExtensionBlockCount,
-		  ExtensionBlock **ExtensionBlocks)
-{
-    ExtensionBlock *ep;
-
-    if (*ExtensionBlocks == NULL)
-        return;
-
-    for (ep = *ExtensionBlocks;
-	 ep < (*ExtensionBlocks + *ExtensionBlockCount); 
-	 ep++)
-        (void)free((char *)ep->Bytes);
-    (void)free((char *)*ExtensionBlocks);
-    *ExtensionBlocks = NULL;
-    *ExtensionBlockCount = 0;
+void GifFreeExtensions(int *ExtensionBlockCount,
+                       ExtensionBlock **ExtensionBlocks) {
+	ExtensionBlock *ep;
+
+	if (*ExtensionBlocks == NULL) {
+		return;
+	}
+
+	for (ep = *ExtensionBlocks;
+	     ep < (*ExtensionBlocks + *ExtensionBlockCount); ep++) {
+		(void)free((char *)ep->Bytes);
+	}
+	(void)free((char *)*ExtensionBlocks);
+	*ExtensionBlocks = NULL;
+	*ExtensionBlockCount = 0;
 }
 
 /******************************************************************************
- Image block allocation functions                          
+   Image block allocation functions
 ******************************************************************************/
 
 /* Private Function:
  * Frees the last image in the GifFile->SavedImages array
  */
-void
-FreeLastSavedImage(GifFileType *GifFile)
-{
-    SavedImage *sp;
-    
-    if ((GifFile == NULL) || (GifFile->SavedImages == NULL))
-        return;
-
-    /* Remove one SavedImage from the GifFile */
-    GifFile->ImageCount--;
-    sp = &GifFile->SavedImages[GifFile->ImageCount];
-
-    /* Deallocate its Colormap */
-    if (sp->ImageDesc.ColorMap != NULL) {
-        GifFreeMapObject(sp->ImageDesc.ColorMap);
-        sp->ImageDesc.ColorMap = NULL;
-    }
-
-    /* Deallocate the image data */
-    if (sp->RasterBits != NULL)
-        free((char *)sp->RasterBits);
-
-    /* Deallocate any extensions */
-    GifFreeExtensions(&sp->ExtensionBlockCount, &sp->ExtensionBlocks);
-
-    /*** FIXME: We could realloc the GifFile->SavedImages structure but is
-     * there a point to it? Saves some memory but we'd have to do it every
-     * time.  If this is used in GifFreeSavedImages then it would be inefficient
-     * (The whole array is going to be deallocated.)  If we just use it when
-     * we want to free the last Image it's convenient to do it here.
-     */
+void FreeLastSavedImage(GifFileType *GifFile) {
+	SavedImage *sp;
+
+	if ((GifFile == NULL) || (GifFile->SavedImages == NULL)) {
+		return;
+	}
+
+	/* Remove one SavedImage from the GifFile */
+	GifFile->ImageCount--;
+	sp = &GifFile->SavedImages[GifFile->ImageCount];
+
+	/* Deallocate its Colormap */
+	if (sp->ImageDesc.ColorMap != NULL) {
+		GifFreeMapObject(sp->ImageDesc.ColorMap);
+		sp->ImageDesc.ColorMap = NULL;
+	}
+
+	/* Deallocate the image data */
+	if (sp->RasterBits != NULL) {
+		free((char *)sp->RasterBits);
+	}
+
+	/* Deallocate any extensions */
+	GifFreeExtensions(&sp->ExtensionBlockCount, &sp->ExtensionBlocks);
+
+	/*** FIXME: We could realloc the GifFile->SavedImages structure but is
+	 * there a point to it? Saves some memory but we'd have to do it every
+	 * time.  If this is used in GifFreeSavedImages then it would be
+	 * inefficient (The whole array is going to be deallocated.)  If we just
+	 * use it when we want to free the last Image it's convenient to do it
+	 * here.
+	 */
 }
 
 /*
- * Append an image block to the SavedImages array  
+ * Append an image block to the SavedImages array
  */
-SavedImage *
-GifMakeSavedImage(GifFileType *GifFile, const SavedImage *CopyFrom)
-{
-    if (GifFile->SavedImages == NULL)
-        GifFile->SavedImages = (SavedImage *)malloc(sizeof(SavedImage));
-    else
-        GifFile->SavedImages = (SavedImage *)reallocarray(GifFile->SavedImages,
-                               (GifFile->ImageCount + 1), sizeof(SavedImage));
-
-    if (GifFile->SavedImages == NULL)
-        return ((SavedImage *)NULL);
-    else {
-        SavedImage *sp = &GifFile->SavedImages[GifFile->ImageCount++];
-        memset((char *)sp, '\0', sizeof(SavedImage));
-
-        if (CopyFrom != NULL) {
-            memcpy((char *)sp, CopyFrom, sizeof(SavedImage));
-
-            /* 
-             * Make our own allocated copies of the heap fields in the
-             * copied record.  This guards against potential aliasing
-             * problems.
-             */
-
-            /* first, the local color map */
-            if (sp->ImageDesc.ColorMap != NULL) {
-                sp->ImageDesc.ColorMap = GifMakeMapObject(
-                                         CopyFrom->ImageDesc.ColorMap->ColorCount,
-                                         CopyFrom->ImageDesc.ColorMap->Colors);
-                if (sp->ImageDesc.ColorMap == NULL) {
-                    FreeLastSavedImage(GifFile);
-                    return (SavedImage *)(NULL);
-                }
-            }
-
-            /* next, the raster */
-            sp->RasterBits = (unsigned char *)reallocarray(NULL,
-                                                  (CopyFrom->ImageDesc.Height *
-                                                  CopyFrom->ImageDesc.Width),
-						  sizeof(GifPixelType));
-            if (sp->RasterBits == NULL) {
-                FreeLastSavedImage(GifFile);
-                return (SavedImage *)(NULL);
-            }
-            memcpy(sp->RasterBits, CopyFrom->RasterBits,
-                   sizeof(GifPixelType) * CopyFrom->ImageDesc.Height *
-                   CopyFrom->ImageDesc.Width);
-
-            /* finally, the extension blocks */
-            if (sp->ExtensionBlocks != NULL) {
-                sp->ExtensionBlocks = (ExtensionBlock *)reallocarray(NULL,
-                                      CopyFrom->ExtensionBlockCount,
-				      sizeof(ExtensionBlock));
-                if (sp->ExtensionBlocks == NULL) {
-                    FreeLastSavedImage(GifFile);
-                    return (SavedImage *)(NULL);
-                }
-                memcpy(sp->ExtensionBlocks, CopyFrom->ExtensionBlocks,
-                       sizeof(ExtensionBlock) * CopyFrom->ExtensionBlockCount);
-            }
-        }
-
-        return (sp);
-    }
+SavedImage *GifMakeSavedImage(GifFileType *GifFile,
+                              const SavedImage *CopyFrom) {
+	// cppcheck-suppress ctunullpointer
+	if (GifFile->SavedImages == NULL) {
+		GifFile->SavedImages = (SavedImage *)malloc(sizeof(SavedImage));
+	} else {
+		SavedImage *newSavedImages = (SavedImage *)reallocarray(
+		    GifFile->SavedImages, (GifFile->ImageCount + 1),
+		    sizeof(SavedImage));
+		if (newSavedImages == NULL) {
+			return ((SavedImage *)NULL);
+		}
+		GifFile->SavedImages = newSavedImages;
+	}
+	if (GifFile->SavedImages == NULL) {
+		return ((SavedImage *)NULL);
+	} else {
+		SavedImage *sp = &GifFile->SavedImages[GifFile->ImageCount++];
+
+		if (CopyFrom != NULL) {
+			memcpy((char *)sp, CopyFrom, sizeof(SavedImage));
+
+			/*
+			 * Make our own allocated copies of the heap fields in
+			 * the copied record.  This guards against potential
+			 * aliasing problems.
+			 */
+
+			/* first, the local color map */
+			if (CopyFrom->ImageDesc.ColorMap != NULL) {
+				sp->ImageDesc.ColorMap = GifMakeMapObject(
+				    CopyFrom->ImageDesc.ColorMap->ColorCount,
+				    CopyFrom->ImageDesc.ColorMap->Colors);
+				if (sp->ImageDesc.ColorMap == NULL) {
+					FreeLastSavedImage(GifFile);
+					return (SavedImage *)(NULL);
+				}
+			}
+
+			/* next, the raster */
+			sp->RasterBits = (unsigned char *)reallocarray(
+			    NULL,
+			    (CopyFrom->ImageDesc.Height *
+			     CopyFrom->ImageDesc.Width),
+			    sizeof(GifPixelType));
+			if (sp->RasterBits == NULL) {
+				FreeLastSavedImage(GifFile);
+				return (SavedImage *)(NULL);
+			}
+			memcpy(sp->RasterBits, CopyFrom->RasterBits,
+			       sizeof(GifPixelType) *
+			           CopyFrom->ImageDesc.Height *
+			           CopyFrom->ImageDesc.Width);
+
+			/* finally, the extension blocks */
+			if (CopyFrom->ExtensionBlocks != NULL) {
+				sp->ExtensionBlocks =
+				    (ExtensionBlock *)reallocarray(
+				        NULL, CopyFrom->ExtensionBlockCount,
+				        sizeof(ExtensionBlock));
+				if (sp->ExtensionBlocks == NULL) {
+					FreeLastSavedImage(GifFile);
+					return (SavedImage *)(NULL);
+				}
+				memcpy(sp->ExtensionBlocks,
+				       CopyFrom->ExtensionBlocks,
+				       sizeof(ExtensionBlock) *
+				           CopyFrom->ExtensionBlockCount);
+			}
+		} else {
+			memset((char *)sp, '\0', sizeof(SavedImage));
+		}
+
+		return (sp);
+	}
 }
 
-void
-GifFreeSavedImages(GifFileType *GifFile)
-{
-    SavedImage *sp;
-
-    if ((GifFile == NULL) || (GifFile->SavedImages == NULL)) {
-        return;
-    }
-    for (sp = GifFile->SavedImages;
-         sp < GifFile->SavedImages + GifFile->ImageCount; sp++) {
-        if (sp->ImageDesc.ColorMap != NULL) {
-            GifFreeMapObject(sp->ImageDesc.ColorMap);
-            sp->ImageDesc.ColorMap = NULL;
-        }
-
-        if (sp->RasterBits != NULL)
-            free((char *)sp->RasterBits);
-	
-	GifFreeExtensions(&sp->ExtensionBlockCount, &sp->ExtensionBlocks);
-    }
-    free((char *)GifFile->SavedImages);
-    GifFile->SavedImages = NULL;
+void GifFreeSavedImages(GifFileType *GifFile) {
+	SavedImage *sp;
+
+	if ((GifFile == NULL) || (GifFile->SavedImages == NULL)) {
+		return;
+	}
+	for (sp = GifFile->SavedImages;
+	     sp < GifFile->SavedImages + GifFile->ImageCount; sp++) {
+		if (sp->ImageDesc.ColorMap != NULL) {
+			GifFreeMapObject(sp->ImageDesc.ColorMap);
+			sp->ImageDesc.ColorMap = NULL;
+		}
+
+		if (sp->RasterBits != NULL) {
+			free((char *)sp->RasterBits);
+		}
+
+		GifFreeExtensions(&sp->ExtensionBlockCount,
+		                  &sp->ExtensionBlocks);
+	}
+	free((char *)GifFile->SavedImages);
+	GifFile->SavedImages = NULL;
 }
 
 /* end */
diff --git a/gifbg.c b/gifbg.c
new file mode 100644
index 0000000..698678c
--- /dev/null
+++ b/gifbg.c
@@ -0,0 +1,389 @@
+/*****************************************************************************
+
+gifbg - generate a test-pattern GIF
+
+SPDX-License-Identifier: MIT
+
+*****************************************************************************/
+
+#include <ctype.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "getarg.h"
+#include "gif_lib.h"
+
+#define PROGRAM_NAME "gifbg"
+
+#define DEFAULT_WIDTH 640
+#define DEFAULT_HEIGHT 350
+
+#define DEFAULT_COLOR_RED 0
+#define DEFAULT_COLOR_GREEN 0
+#define DEFAULT_COLOR_BLUE 255
+
+#define DEFAULT_MIN_INTENSITY 10 /* In percent. */
+#define DEFAULT_MAX_INTENSITY 100
+
+#define DEFAULT_NUM_LEVELS 16 /* Number of colors to gen in image. */
+
+#define DIR_NONE 0 /* Direction the levels can be changed: */
+#define DIR_TOP 1
+#define DIR_TOP_RIGHT 2
+#define DIR_RIGHT 3
+#define DIR_BOT_RIGHT 4
+#define DIR_BOT 5
+#define DIR_BOT_LEFT 6
+#define DIR_LEFT 7
+#define DIR_TOP_LEFT 8
+
+#define DEFAULT_DIR "T" /* TOP (North) direction. */
+
+static char *VersionStr = PROGRAM_NAME VERSION_COOKIE
+    "	Gershon Elber,	" __DATE__ ",   " __TIME__ "\n"
+    "(C) Copyright 1989 Gershon Elber.\n";
+static char *CtrlStr = PROGRAM_NAME " v%- d%-Dir!s l%-#Lvls!d c%-R|G|B!d!d!d "
+                                    "m%-MinI!d M%-MaxI!d s%-W|H!d!d h%-";
+
+static int MaximumIntensity = DEFAULT_MAX_INTENSITY, /* In percent. */
+    MinimumIntensity = DEFAULT_MIN_INTENSITY, NumLevels = DEFAULT_NUM_LEVELS,
+           ImageWidth = DEFAULT_WIDTH, ImageHeight = DEFAULT_HEIGHT, Direction;
+static unsigned int RedColor = DEFAULT_COLOR_RED,
+                    GreenColor = DEFAULT_COLOR_GREEN,
+                    BlueColor = DEFAULT_COLOR_BLUE;
+
+static void QuitGifError(GifFileType *GifFile);
+
+/******************************************************************************
+ Interpret the command line and scan the given GIF file.
+******************************************************************************/
+int main(int argc, char **argv) {
+	int i, l, LevelWidth, LogNumLevels, ErrorCode, Count = 0;
+	bool Error, FlipDir, DoAllMaximum = false, DirectionFlag = false,
+	                     LevelsFlag = false, ColorFlag = false,
+	                     MinFlag = false, MaxFlag = false, SizeFlag = false,
+	                     HelpFlag = false, GifNoisyPrint;
+	GifPixelType Color;
+	char *DirectionStr = DEFAULT_DIR;
+	GifRowType Line;
+	ColorMapObject *ColorMap;
+	GifFileType *GifFile;
+
+	if ((Error = GAGetArgs(
+	         argc, argv, CtrlStr, &GifNoisyPrint, &DirectionFlag,
+	         &DirectionStr, &LevelsFlag, &NumLevels, &ColorFlag, &RedColor,
+	         &GreenColor, &BlueColor, &MinFlag, &MinimumIntensity, &MaxFlag,
+	         &MaximumIntensity, &SizeFlag, &ImageWidth, &ImageHeight,
+	         &HelpFlag)) != false) {
+		GAPrintErrMsg(Error);
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_FAILURE);
+	}
+
+	if (HelpFlag) {
+		(void)fprintf(stderr, VersionStr, GIFLIB_MAJOR, GIFLIB_MINOR);
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_SUCCESS);
+	}
+
+	/* Make sure intensities are in the right range: */
+	if (MinimumIntensity < 0 || MinimumIntensity > 100 ||
+	    MaximumIntensity < 0 || MaximumIntensity > 100) {
+		GIF_EXIT("Intensities (-m or -M options) are not in [0..100] "
+		         "range (percent).");
+	}
+
+	/* Convert DirectionStr to our local representation: */
+	Direction = DIR_NONE;
+	FlipDir = false;
+	/* Make sure it's upper case. */
+	for (i = 0; i < (int)strlen(DirectionStr); i++) {
+		if (islower(DirectionStr[i])) {
+			DirectionStr[i] = toupper(DirectionStr[i]);
+		}
+	}
+
+	switch (DirectionStr[0]) {
+	case 'T': /* Top or North */
+	case 'N':
+		if (strlen(DirectionStr) < 2) {
+			Direction = DIR_TOP;
+		} else {
+			switch (DirectionStr[1]) {
+			case 'R':
+			case 'E':
+				Direction = DIR_TOP_RIGHT;
+				break;
+			case 'L':
+			case 'W':
+				Direction = DIR_TOP_LEFT;
+				FlipDir = true;
+				break;
+			}
+		}
+		break;
+	case 'R': /* Right or East */
+	case 'E':
+		Direction = DIR_RIGHT;
+		break;
+	case 'B': /* Bottom or South */
+	case 'S':
+		if (strlen(DirectionStr) < 2) {
+			Direction = DIR_BOT;
+			FlipDir = true;
+		} else {
+			switch (DirectionStr[1]) {
+			case 'R':
+			case 'E':
+				Direction = DIR_BOT_RIGHT;
+				break;
+			case 'L':
+			case 'W':
+				Direction = DIR_BOT_LEFT;
+				FlipDir = true;
+				break;
+			}
+		}
+		break;
+	case 'L': /* Left or West */
+	case 'W':
+		Direction = DIR_LEFT;
+		FlipDir = true;
+		break;
+	}
+	if (Direction == DIR_NONE) {
+		GIF_EXIT("Direction requested (-d option) is weird!");
+	}
+
+	/* We are going to handle only TOP, TOP_RIGHT, RIGHT, BOT_RIGHT  so flip
+	 */
+	/* the complement cases (TOP <-> BOT for example) by flipping the
+	 */
+	/* Color i with color (NumLevels - i - 1). */
+	if (FlipDir) {
+		switch (Direction) {
+		case DIR_BOT:
+			Direction = DIR_TOP;
+			break;
+		case DIR_BOT_LEFT:
+			Direction = DIR_TOP_RIGHT;
+			break;
+		case DIR_LEFT:
+			Direction = DIR_RIGHT;
+			break;
+		case DIR_TOP_LEFT:
+			Direction = DIR_BOT_RIGHT;
+			break;
+		}
+	}
+
+	/* If binary mask is requested (special case): */
+	if (MinimumIntensity == 100 && MaximumIntensity == 100 &&
+	    NumLevels == 2) {
+		MinimumIntensity = 0;
+		DoAllMaximum = true;
+		Direction = DIR_RIGHT;
+	}
+
+	/* Make sure colors are in the right range: */
+	if (RedColor > 255 || GreenColor > 255 || BlueColor > 255) {
+		GIF_EXIT("Colors are not in the ragne [0..255].");
+	}
+
+	/* Make sure number of levels is power of 2 (up to 8 bits per pixel). */
+	for (i = 1; i < 8; i++) {
+		if (NumLevels == (1 << i)) {
+			break;
+		}
+	}
+	if (i == 8) {
+		GIF_EXIT("#Lvls (-l option) is not power of 2.");
+	}
+	LogNumLevels = i;
+
+	/* Open stdout for the output file: */
+	if ((GifFile = EGifOpenFileHandle(1, &ErrorCode)) == NULL) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+
+	/* Dump out screen description with given size and generated color map:
+	 */
+	if ((ColorMap = GifMakeMapObject(NumLevels, NULL)) == NULL) {
+		GIF_EXIT("Failed to allocate memory required, aborted.");
+	}
+
+	for (i = 1; i <= NumLevels; i++) {
+		/* Ratio will be in the range of 0..100 for required intensity:
+		 */
+		unsigned int Ratio =
+		    (MaximumIntensity * (i * (256 / NumLevels)) +
+		     MinimumIntensity * ((NumLevels - i) * (256 / NumLevels))) /
+		    256;
+		ColorMap->Colors[i - 1].Red = (RedColor * Ratio) / 100;
+		ColorMap->Colors[i - 1].Green = (GreenColor * Ratio) / 100;
+		ColorMap->Colors[i - 1].Blue = (BlueColor * Ratio) / 100;
+	}
+	if (EGifPutScreenDesc(GifFile, ImageWidth, ImageHeight, LogNumLevels, 0,
+	                      ColorMap) == GIF_ERROR) {
+		QuitGifError(GifFile);
+	}
+
+	/* Dump out the image descriptor: */
+	if (EGifPutImageDesc(GifFile, 0, 0, ImageWidth, ImageHeight, false,
+	                     NULL) == GIF_ERROR) {
+		QuitGifError(GifFile);
+	}
+
+	GifQprintf("\n%s: Image 1 at (%d, %d) [%dx%d]:     ", PROGRAM_NAME,
+	           GifFile->Image.Left, GifFile->Image.Top,
+	           GifFile->Image.Width, GifFile->Image.Height);
+
+	/* Allocate one scan line twice as big as image is, as we are going to
+	 */
+	/* shift along it, while we dump the scan lines: */
+	if ((Line = (GifRowType)malloc(sizeof(GifPixelType) * ImageWidth *
+	                               2)) == NULL) {
+		GIF_EXIT("Failed to allocate memory required, aborted.");
+	}
+
+	if (Direction == DIR_TOP) {
+		int LevelHeight;
+		/* We must evaluate the line each time level is changing: */
+		LevelHeight = ImageHeight / NumLevels;
+		for (Color = NumLevels, i = l = 0; i < ImageHeight; i++) {
+			if (i == l) {
+				int j;
+				/* Time to update the line to next color level:
+				 */
+				if (Color != 0) {
+					Color--;
+				}
+				for (j = 0; j < ImageWidth; j++) {
+					Line[j] =
+					    (FlipDir ? NumLevels - Color - 1
+					             : Color);
+				}
+				l += LevelHeight;
+			}
+			if (EGifPutLine(GifFile, Line, ImageWidth) ==
+			    GIF_ERROR) {
+				QuitGifError(GifFile);
+			}
+			GifQprintf("\b\b\b\b%-4d", Count++);
+		}
+	} else if (Direction == DIR_RIGHT) {
+		/* We pre-prepare the scan lines as going from color zero to
+		 * maximum */
+		/* color and dump the same scan line Height times:
+		 */
+		/* Note this case should handle the Boolean Mask special case.
+		 */
+		LevelWidth = ImageWidth / NumLevels;
+		if (DoAllMaximum) {
+			/* Special case - do all in maximum color: */
+			for (i = 0; i < ImageWidth; i++) {
+				Line[i] = 1;
+			}
+		} else {
+			for (Color = i = 0, l = LevelWidth; i < ImageWidth;
+			     i++, l--) {
+				if (l == 0) {
+					l = LevelWidth;
+					if (Color < NumLevels - 1) {
+						Color++;
+					}
+				}
+				Line[i] =
+				    (FlipDir ? NumLevels - Color - 1 : Color);
+			}
+		}
+
+		for (i = 0; i < ImageHeight; i++) {
+			/* coverity[uninit_use_in_call] */
+			if (EGifPutLine(GifFile, Line, ImageWidth) ==
+			    GIF_ERROR) {
+				QuitGifError(GifFile);
+			}
+			GifQprintf("\b\b\b\b%-4d", Count++);
+		}
+	} else {
+		int Accumulator, StartX, StepX;
+		/* We are in one of the TOP_RIGHT, BOT_RIGHT cases: we will */
+		/* initialize the Line with its double ImageWidth length from
+		 * the    */
+		/* minimum intensity to the maximum intensity and shift along it
+		 */
+		/* while we go along the image height. */
+		LevelWidth = ImageWidth * 2 / NumLevels;
+		for (Color = i = 0, l = LevelWidth; i < ImageWidth * 2;
+		     i++, l--) {
+			if (l == 0) {
+				l = LevelWidth;
+				if (Color < NumLevels - 1) {
+					Color++;
+				}
+			}
+			Line[i] = (FlipDir ? NumLevels - Color - 1 : Color);
+		}
+		/* We need to implement a DDA to know how much to shift Line
+		 * while   */
+		/* we go down along image height. we set the parameters for it
+		 * now:  */
+		Accumulator = 0;
+		switch (Direction) {
+		case DIR_TOP_RIGHT:
+			StartX = ImageWidth;
+			StepX = -1;
+			break;
+		case DIR_BOT_RIGHT:
+		default:
+			StartX = 0;
+			StepX = 1;
+			break;
+		}
+
+		/* Time to dump information out: */
+		for (i = 0; i < ImageHeight; i++) {
+			if (EGifPutLine(GifFile, &Line[StartX], ImageWidth) ==
+			    GIF_ERROR) {
+				QuitGifError(GifFile);
+			}
+			GifQprintf("\b\b\b\b%-4d", Count++);
+			if ((Accumulator += ImageWidth) > ImageHeight) {
+				while (Accumulator > ImageHeight) {
+					Accumulator -= ImageHeight;
+					StartX += StepX;
+				}
+				if (Direction < 0) {
+					Direction = 0;
+				}
+				if (Direction > ImageWidth) {
+					Direction = ImageWidth;
+				}
+			}
+		}
+	}
+
+	if (EGifCloseFile(GifFile, &ErrorCode) == GIF_ERROR) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+ Close output file (if open), and exit.
+******************************************************************************/
+static void QuitGifError(GifFileType *GifFile) {
+	if (GifFile != NULL) {
+		PrintGifError(GifFile->Error);
+		EGifCloseFile(GifFile, NULL);
+	}
+	exit(EXIT_FAILURE);
+}
+
+/* end */
diff --git a/gifbuild.c b/gifbuild.c
new file mode 100644
index 0000000..e8b9b0c
--- /dev/null
+++ b/gifbuild.c
@@ -0,0 +1,1021 @@
+/*****************************************************************************
+
+gifbuild - dump GIF data in a textual format, or undump it to a GIF
+
+SPDX-License-Identifier: MIT
+
+*****************************************************************************/
+
+#include <ctype.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "getarg.h"
+#include "gif_lib.h"
+
+#define PROGRAM_NAME "gifbuild"
+
+static char *VersionStr = PROGRAM_NAME VERSION_COOKIE
+    "	Eric Raymond,	" __DATE__ ",   " __TIME__ "\n"
+    "(C) Copyright 1992 Eric Raymond.\n";
+static char *CtrlStr =
+    PROGRAM_NAME " v%- d%- t%-Characters!s h%- GifFile(s)!*s";
+
+static char KeyLetters[] = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNO"
+                           "PQRSTUVWXYZ!\"#$%&'()*+,-./:<=>?@[\\]^_`{|}~";
+#define PRINTABLES (sizeof(KeyLetters) - 1)
+
+static void Icon2Gif(char *FileName, FILE *txtin, bool, int fdout);
+static void Gif2Icon(char *FileName, int fdin, int fdout, char NameTable[]);
+static int EscapeString(char *cp, char *tp);
+
+/******************************************************************************
+ Main sequence
+******************************************************************************/
+int main(int argc, char **argv) {
+	int NumFiles;
+	bool Error, DisasmFlag = false, HelpFlag = false, TextLineFlag = false,
+	            GifNoisyPrint = false;
+	char **FileNames = NULL;
+	char *TextLines[1];
+
+	if ((Error = GAGetArgs(argc, argv, CtrlStr, &GifNoisyPrint, &DisasmFlag,
+	                       &TextLineFlag, &TextLines[0], &HelpFlag,
+	                       &NumFiles, &FileNames)) != false) {
+		GAPrintErrMsg(Error);
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_FAILURE);
+	}
+
+	if (HelpFlag) {
+		(void)fprintf(stderr, VersionStr, GIFLIB_MAJOR, GIFLIB_MINOR);
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_SUCCESS);
+	}
+
+	if (!DisasmFlag && NumFiles > 1) {
+		GIF_MESSAGE(
+		    "Error in command line parsing - one  text input please.");
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_FAILURE);
+	}
+
+	if (!DisasmFlag && TextLineFlag) {
+		GIF_MESSAGE(
+		    "Error in command line parsing - -t invalid without -d.");
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_FAILURE);
+	}
+
+	if (NumFiles == 0) {
+		if (DisasmFlag)
+			Gif2Icon("Stdin", 0, 1,
+			         TextLineFlag ? TextLines[0] : KeyLetters);
+		else
+			Icon2Gif("Stdin", stdin, GifNoisyPrint, 1);
+	} else {
+		int i;
+		for (i = 0; i < NumFiles; i++) {
+			FILE *fp;
+
+			if ((fp = fopen(FileNames[i], "r")) == (FILE *)NULL) {
+				(void)fprintf(stderr, "Can't open %s\n",
+				              FileNames[i]);
+				exit(EXIT_FAILURE);
+			}
+
+			if (DisasmFlag) {
+				printf("#\n# GIF information from %s\n",
+				       FileNames[i]);
+				Gif2Icon(FileNames[i], -1, 1,
+				         TextLineFlag ? TextLines[0]
+				                      : KeyLetters);
+			} else {
+				Icon2Gif(FileNames[i], fp, GifNoisyPrint, 1);
+			}
+
+			(void)fclose(fp);
+		}
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+ Parse image directives
+******************************************************************************/
+#define PARSE_ERROR(str)                                                       \
+	(void)fprintf(stderr, "%s:%d: %s\n", FileName, LineNum, str);
+
+static void Icon2Gif(char *FileName, FILE *txtin, bool GifNoisyPrint,
+                     int fdout) {
+	unsigned int ColorMapSize = 0;
+	GifColorType GlobalColorMap[256], LocalColorMap[256],
+	    *ColorMap = GlobalColorMap;
+	char GlobalColorKeys[PRINTABLES], LocalColorKeys[PRINTABLES],
+	    *KeyTable = GlobalColorKeys;
+	bool SortFlag = false;
+	unsigned int ExtCode, intval;
+	int red, green, blue, n;
+	char buf[BUFSIZ * 2], InclusionFile[64];
+	GifFileType *GifFileOut;
+	SavedImage *NewImage = NULL;
+	int LeadingExtensionBlockCount = 0;
+	ExtensionBlock *LeadingExtensionBlocks = NULL;
+	int ErrorCode, LineNum = 0;
+
+	if ((GifFileOut = EGifOpenFileHandle(fdout, &ErrorCode)) == NULL) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+
+	/* OK, interpret directives */
+	/* coverity[tainted_data_transitive] */
+	while (fgets(buf, sizeof(buf), txtin) != (char *)NULL) {
+		char *cp;
+
+		++LineNum;
+
+		/*
+		 * Skip lines consisting only of whitespace and comments
+		 */
+		for (cp = buf; isspace((int)(*cp)); cp++) {
+			continue;
+		}
+		if (*cp == '#' || *cp == '\0') {
+			continue;
+		}
+
+		/*
+		 * If there's a trailing comment, nuke it and all preceding
+		 * whitespace. But preserve the EOL.
+		 */
+		if ((cp = strchr(buf, '#')) && (cp == strrchr(cp, '#'))) {
+			while (isspace((int)(*--cp))) {
+				continue;
+			}
+			*++cp = '\n';
+			*++cp = '\0';
+		}
+
+		/*
+		 * Explicit header declarations
+		 */
+
+		if (sscanf(buf, "screen width %d\n", &GifFileOut->SWidth) ==
+		    1) {
+			continue;
+		}
+
+		else if (sscanf(buf, "screen height %d\n",
+		                &GifFileOut->SHeight) == 1) {
+			continue;
+		}
+
+		else if (sscanf(buf, "screen colors %d\n", &n) == 1) {
+			int ResBits = GifBitSize(n);
+
+			if (n > 256 || n < 0 || n != (1 << ResBits)) {
+				PARSE_ERROR("Invalid color resolution value.");
+				exit(EXIT_FAILURE);
+			}
+
+			GifFileOut->SColorResolution = ResBits;
+			continue;
+		}
+
+		else if (sscanf(buf, "screen background %d\n",
+		                &GifFileOut->SBackGroundColor) == 1) {
+			continue;
+		}
+
+		else if (sscanf(buf, "pixel aspect byte %u\n", &intval) == 1) {
+			GifFileOut->AspectByte = (GifByteType)(intval & 0xff);
+			continue;
+		}
+
+		/*
+		 * Color table parsing
+		 */
+
+		else if (strcmp(buf, "screen map\n") == 0) {
+			if (GifFileOut->SColorMap != NULL) {
+				PARSE_ERROR("You've already declared a global "
+				            "color map.");
+				exit(EXIT_FAILURE);
+			}
+
+			ColorMapSize = 0;
+			ColorMap = GlobalColorMap;
+			SortFlag = false;
+			KeyTable = GlobalColorKeys;
+			memset(GlobalColorKeys, '\0', sizeof(GlobalColorKeys));
+		}
+
+		else if (strcmp(buf, "image map\n") == 0) {
+			if (NewImage == NULL) {
+				PARSE_ERROR("No previous image declaration.");
+				exit(EXIT_FAILURE);
+			}
+
+			ColorMapSize = 0;
+			ColorMap = LocalColorMap;
+			KeyTable = LocalColorKeys;
+			memset(LocalColorKeys, '\0', sizeof(LocalColorKeys));
+		}
+
+		else if (sscanf(buf, "	rgb %d %d %d is %c", &red, &green,
+		                &blue, &KeyTable[ColorMapSize]) == 4) {
+			if (ColorMapSize >= 256) {
+				PARSE_ERROR("Too many color entries.");
+				exit(EXIT_FAILURE);
+			}
+			ColorMap[ColorMapSize].Red = red;
+			ColorMap[ColorMapSize].Green = green;
+			ColorMap[ColorMapSize].Blue = blue;
+			ColorMapSize++;
+		}
+
+		else if (sscanf(buf, "	rgb %d %d %d", &red, &green, &blue) ==
+		         3) {
+			if (ColorMapSize >= 256) {
+				PARSE_ERROR("Too many color entries.");
+				exit(EXIT_FAILURE);
+			}
+			ColorMap[ColorMapSize].Red = red;
+			ColorMap[ColorMapSize].Green = green;
+			ColorMap[ColorMapSize].Blue = blue;
+			ColorMapSize++;
+		}
+
+		else if (strcmp(buf, "	sort flag on\n") == 0) {
+			SortFlag = true;
+		}
+
+		else if (strcmp(buf, "	sort flag off\n") == 0) {
+			SortFlag = false;
+		}
+
+		else if (strcmp(buf, "end\n") == 0) {
+			ColorMapObject *NewMap;
+
+			NewMap = GifMakeMapObject(1 << GifBitSize(ColorMapSize),
+			                          ColorMap);
+			if (NewMap == (ColorMapObject *)NULL) {
+				PARSE_ERROR("Out of memory while allocating "
+				            "new color map.");
+				exit(EXIT_FAILURE);
+			}
+
+			NewMap->SortFlag = SortFlag;
+
+			if (NewImage) {
+				NewImage->ImageDesc.ColorMap = NewMap;
+			} else {
+				GifFileOut->SColorMap = NewMap;
+			}
+		}
+
+		/* GIF inclusion */
+		/* ugly magic number is because scanf has no */
+		else if (sscanf(buf, "include %63s", InclusionFile) == 1) {
+			bool DoTranslation;
+			GifPixelType Translation[256];
+
+			GifFileType *Inclusion;
+			SavedImage *CopyFrom;
+
+			if ((Inclusion = DGifOpenFileName(
+			         InclusionFile, &ErrorCode)) == NULL) {
+				PrintGifError(ErrorCode);
+				exit(EXIT_FAILURE);
+			}
+
+			if (DGifSlurp(Inclusion) == GIF_ERROR) {
+				PARSE_ERROR("Inclusion read failed.");
+				// cppcheck-suppress knownConditionTrueFalse
+				if (Inclusion != NULL) {
+					PrintGifError(Inclusion->Error);
+					DGifCloseFile(Inclusion, NULL);
+				}
+				if (GifFileOut != NULL) {
+					EGifCloseFile(GifFileOut, NULL);
+				};
+				exit(EXIT_FAILURE);
+			}
+
+			// cppcheck-suppress nullPointerRedundantCheck
+			if ((DoTranslation = (GifFileOut->SColorMap !=
+			                      (ColorMapObject *)NULL))) {
+				ColorMapObject *UnionMap;
+
+				UnionMap = GifUnionColorMap(
+				    // cppcheck-suppress nullPointerRedundantCheck
+				    GifFileOut->SColorMap, Inclusion->SColorMap,
+				    Translation);
+
+				if (UnionMap == NULL) {
+					PARSE_ERROR("Inclusion failed --- "
+					            "global map conflict.");
+					// cppcheck-suppress nullPointerRedundantCheck
+					PrintGifError(GifFileOut->Error);
+					// cppcheck-suppress knownConditionTrueFalse
+					if (Inclusion != NULL) {
+						DGifCloseFile(Inclusion, NULL);
+					}
+					if (GifFileOut != NULL) {
+						EGifCloseFile(GifFileOut, NULL);
+					}
+					exit(EXIT_FAILURE);
+				}
+
+				GifFreeMapObject(GifFileOut->SColorMap);
+				GifFileOut->SColorMap = UnionMap;
+			}
+
+			for (CopyFrom = Inclusion->SavedImages;
+			     CopyFrom <
+			     Inclusion->SavedImages + Inclusion->ImageCount;
+			     CopyFrom++) {
+				if ((NewImage = GifMakeSavedImage(
+				         GifFileOut, CopyFrom)) == NULL) {
+					PARSE_ERROR("Inclusion failed --- out "
+					            "of memory.");
+					// cppcheck-suppress nullPointerRedundantCheck
+					PrintGifError(GifFileOut->Error);
+					// cppcheck-suppress knownConditionTrueFalse
+					if (Inclusion != NULL) {
+						DGifCloseFile(Inclusion, NULL);
+					}
+					if (GifFileOut != NULL) {
+						EGifCloseFile(GifFileOut, NULL);
+					}
+					exit(EXIT_FAILURE);
+				} else if (DoTranslation) {
+					GifApplyTranslation(NewImage,
+					                    Translation);
+				}
+
+				GifQprintf("%s: Image %d at (%d, %d) [%dx%d]: "
+				           "from %s\n",
+				           PROGRAM_NAME, GifFileOut->ImageCount,
+				           NewImage->ImageDesc.Left,
+				           NewImage->ImageDesc.Top,
+				           NewImage->ImageDesc.Width,
+				           NewImage->ImageDesc.Height,
+				           InclusionFile);
+			}
+
+			(void)DGifCloseFile(Inclusion, NULL);
+		}
+
+		/*
+		 * Extension blocks.
+		 */
+		else if (strcmp(buf, "comment\n") == 0) {
+			int bc = 0;
+			while (fgets(buf, sizeof(buf), txtin) != (char *)NULL) {
+				if (strcmp(buf, "end\n") == 0) {
+					break;
+				} else {
+					int Len;
+
+					buf[strlen(buf) - 1] = '\0';
+					Len = EscapeString(buf, buf);
+					if (GifAddExtensionBlock(
+					        &LeadingExtensionBlockCount,
+					        &LeadingExtensionBlocks,
+					        bc++ == CONTINUE_EXT_FUNC_CODE
+					            ? COMMENT_EXT_FUNC_CODE
+					            : 0,
+					        Len, (unsigned char *)buf) ==
+					    GIF_ERROR) {
+						PARSE_ERROR(
+						    "out of memory while "
+						    "adding comment block.");
+						exit(EXIT_FAILURE);
+					}
+				}
+			}
+		} else if (strcmp(buf, "plaintext\n") == 0) {
+			int bc = 0;
+			while (fgets(buf, sizeof(buf), txtin) != (char *)NULL) {
+				if (strcmp(buf, "end\n") == 0) {
+					break;
+				} else {
+					int Len;
+
+					buf[strlen(buf) - 1] = '\0';
+					Len = EscapeString(buf, buf);
+					if (GifAddExtensionBlock(
+					        &LeadingExtensionBlockCount,
+					        &LeadingExtensionBlocks,
+					        bc++ == CONTINUE_EXT_FUNC_CODE
+					            ? PLAINTEXT_EXT_FUNC_CODE
+					            : 0,
+					        Len, (unsigned char *)buf) ==
+					    GIF_ERROR) {
+						PARSE_ERROR(
+						    "out of memory while "
+						    "adding plaintext block.");
+						exit(EXIT_FAILURE);
+					}
+				}
+			}
+		} else if (strcmp(buf, "graphics control\n") == 0) {
+			GraphicsControlBlock gcb;
+			size_t Len;
+
+			memset(&gcb, '\0', sizeof(gcb));
+			gcb.TransparentColor = NO_TRANSPARENT_COLOR;
+			while (fgets(buf, sizeof(buf), txtin) != (char *)NULL) {
+				if (strcmp(buf, "end\n") == 0) {
+					break;
+				} else {
+					char *tp = buf;
+
+					while (isspace(*tp)) {
+						tp++;
+					}
+					if (sscanf(tp, "disposal mode %d\n",
+					           &gcb.DisposalMode)) {
+						continue;
+					}
+					if (strcmp(tp,
+					           "user input flag on\n") ==
+					    0) {
+						gcb.UserInputFlag = true;
+						continue;
+					}
+					if (strcmp(tp,
+					           "user input flag off\n") ==
+					    0) {
+						gcb.UserInputFlag = false;
+						continue;
+					}
+					if (sscanf(tp, "delay %d\n",
+					           &gcb.DelayTime)) {
+						continue;
+					}
+					if (sscanf(tp, "transparent index %d\n",
+					           &gcb.TransparentColor)) {
+						continue;
+					}
+					(void)fputs(tp, stderr);
+					PARSE_ERROR("unrecognized directive in "
+					            "GCB block.");
+					exit(EXIT_FAILURE);
+				}
+			}
+			Len = EGifGCBToExtension(&gcb, (GifByteType *)buf);
+			if (GifAddExtensionBlock(
+			        &LeadingExtensionBlockCount,
+			        &LeadingExtensionBlocks, GRAPHICS_EXT_FUNC_CODE,
+			        Len, (unsigned char *)buf) == GIF_ERROR) {
+				PARSE_ERROR("out of memory while adding GCB.");
+				exit(EXIT_FAILURE);
+			}
+
+		} else if (sscanf(buf, "netscape loop %u", &intval)) {
+			unsigned char params[3] = {1, 0, 0};
+			/* Create a Netscape 2.0 loop block */
+			if (GifAddExtensionBlock(
+			        &LeadingExtensionBlockCount,
+			        &LeadingExtensionBlocks,
+			        APPLICATION_EXT_FUNC_CODE, 11,
+			        (unsigned char *)"NETSCAPE2.0") == GIF_ERROR) {
+				PARSE_ERROR(
+				    "out of memory while adding loop block.");
+				exit(EXIT_FAILURE);
+			}
+			params[1] = (intval & 0xff);
+			params[2] = (intval >> 8) & 0xff;
+			if (GifAddExtensionBlock(&LeadingExtensionBlockCount,
+			                         &LeadingExtensionBlocks, 0,
+			                         sizeof(params),
+			                         params) == GIF_ERROR) {
+				PARSE_ERROR("out of memory while adding loop "
+				            "continuation.");
+				exit(EXIT_FAILURE);
+			}
+
+		} else if (sscanf(buf, "extension %x", &ExtCode)) {
+			int bc = 0;
+			while (fgets(buf, sizeof(buf), txtin) != (char *)NULL) {
+				if (strcmp(buf, "end\n") == 0) {
+					break;
+				} else {
+					int Len;
+
+					buf[strlen(buf) - 1] = '\0';
+					Len = EscapeString(buf, buf);
+					if (GifAddExtensionBlock(
+					        &LeadingExtensionBlockCount,
+					        &LeadingExtensionBlocks,
+					        bc++ == CONTINUE_EXT_FUNC_CODE
+					            ? ExtCode
+					            : 0,
+					        Len, (unsigned char *)buf) ==
+					    GIF_ERROR) {
+						PARSE_ERROR(
+						    "out of memory while "
+						    "adding extension block.");
+						exit(EXIT_FAILURE);
+					}
+				}
+			}
+		}
+
+		/*
+		 * Explicit image declarations
+		 */
+
+		else if (strcmp(buf, "image\n") == 0) {
+			if ((NewImage = GifMakeSavedImage(GifFileOut, NULL)) ==
+			    (SavedImage *)NULL) {
+				PARSE_ERROR("Out of memory while allocating "
+				            "image block.");
+				exit(EXIT_FAILURE);
+			}
+
+			/* use global table unless user specifies a local one */
+			ColorMap = GlobalColorMap;
+			KeyTable = GlobalColorKeys;
+
+			/* connect leading extension blocks */
+			NewImage->ExtensionBlockCount =
+			    LeadingExtensionBlockCount;
+			NewImage->ExtensionBlocks = LeadingExtensionBlocks;
+			LeadingExtensionBlockCount = 0;
+			LeadingExtensionBlocks = NULL;
+		}
+
+		/*
+		 * Nothing past this point is valid unless we've seen a previous
+		 * image declaration.
+		 */
+		else if (NewImage == (SavedImage *)NULL) {
+			(void)fputs(buf, stderr);
+			PARSE_ERROR("Syntax error in header block.");
+			exit(EXIT_FAILURE);
+		}
+
+		/*
+		 * Accept image attributes
+		 */
+		else if (sscanf(buf, "image top %d\n",
+		                &NewImage->ImageDesc.Top) == 1) {
+			continue;
+		}
+
+		else if (sscanf(buf, "image left %d\n",
+		                &NewImage->ImageDesc.Left) == 1) {
+			continue;
+		}
+
+		else if (strcmp(buf, "image interlaced\n") == 0) {
+			NewImage->ImageDesc.Interlace = true;
+			continue;
+		}
+
+		else if (sscanf(buf, "image bits %d by %d",
+		                &NewImage->ImageDesc.Width,
+		                &NewImage->ImageDesc.Height) == 2) {
+			int i, j;
+			static GifPixelType *Raster;
+			int c;
+			bool hex = (strstr(buf, "hex") != NULL);
+
+			/* coverity[overflow_sink] */
+			if ((Raster = (GifPixelType *)malloc(
+			         sizeof(GifPixelType) *
+			         NewImage->ImageDesc.Width *
+			         NewImage->ImageDesc.Height)) == NULL) {
+				PARSE_ERROR("Failed to allocate raster block, "
+				            "aborted.");
+				exit(EXIT_FAILURE);
+			}
+
+			GifQprintf("%s: Image %d at (%d, %d) [%dx%d]:     ",
+			           PROGRAM_NAME, GifFileOut->ImageCount,
+			           NewImage->ImageDesc.Left,
+			           NewImage->ImageDesc.Top,
+			           NewImage->ImageDesc.Width,
+			           NewImage->ImageDesc.Height);
+
+			GifByteType *tp = Raster;
+			for (i = 0; i < NewImage->ImageDesc.Height; i++) {
+
+				char *dp;
+
+				for (j = 0; j < NewImage->ImageDesc.Width;
+				     j++) {
+					if ((c = fgetc(txtin)) == EOF) {
+						PARSE_ERROR("input file ended "
+						            "prematurely.");
+						exit(EXIT_FAILURE);
+					} else if (c == '\n') {
+						--j;
+						++LineNum;
+					} else if (isspace(c)) {
+						--j;
+					} else if (hex) {
+						const static char *hexdigits =
+						    "0123456789ABCDEF";
+						unsigned char hi, lo;
+						dp = strchr(hexdigits,
+						            toupper(c));
+						if (dp == NULL) {
+							PARSE_ERROR(
+							    "Invalid hex high "
+							    "byte.");
+							exit(EXIT_FAILURE);
+						}
+						hi = (dp - hexdigits);
+						if ((c = fgetc(txtin)) == EOF) {
+							PARSE_ERROR(
+							    "input file ended "
+							    "prematurely.");
+							exit(EXIT_FAILURE);
+						}
+						dp = strchr(hexdigits,
+						            toupper(c));
+						if (dp == NULL) {
+							PARSE_ERROR(
+							    "Invalid hex low "
+							    "byte.");
+							exit(EXIT_FAILURE);
+						}
+						lo = (dp - hexdigits);
+						*tp++ = (hi << 4) | lo;
+					} else if ((dp = strchr(KeyTable, c))) {
+						*tp++ = (dp - KeyTable);
+					} else {
+						PARSE_ERROR(
+						    "Invalid ASCII pixel key.");
+						exit(EXIT_FAILURE);
+					}
+				}
+
+				if (GifNoisyPrint) {
+					fprintf(stderr, "\b\b\b\b%-4d", i);
+				}
+			}
+
+			if (GifNoisyPrint) {
+				putc('\n', stderr);
+			}
+
+			NewImage->RasterBits = (unsigned char *)Raster;
+		} else {
+			(void)fputs(buf, stderr);
+			PARSE_ERROR("Syntax error in image description.");
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	/* connect trailing extension blocks */
+	GifFileOut->ExtensionBlockCount = LeadingExtensionBlockCount;
+	GifFileOut->ExtensionBlocks = LeadingExtensionBlocks;
+	// LeadingExtensionBlockCount = 0;
+	LeadingExtensionBlocks = NULL;
+
+	EGifSpew(GifFileOut);
+}
+
+static void VisibleDumpBuffer(GifByteType *buf, int len)
+/* Visibilize a given string */
+{
+	GifByteType *cp;
+
+	for (cp = buf; cp < buf + len; cp++) {
+		if (isprint((int)(*cp)) || *cp == ' ') {
+			putchar(*cp);
+		} else if (*cp == '\n') {
+			putchar('\\');
+			putchar('n');
+		} else if (*cp == '\r') {
+			putchar('\\');
+			putchar('r');
+		} else if (*cp == '\b') {
+			putchar('\\');
+			putchar('b');
+		} else if (*cp < ' ') {
+			putchar('\\');
+			putchar('^');
+			putchar('@' + *cp);
+		} else {
+			printf("\\0x%02x", *cp);
+		}
+	}
+}
+
+static void DumpExtensions(GifFileType *GifFileOut, int ExtensionBlockCount,
+                           ExtensionBlock *ExtensionBlocks) {
+	ExtensionBlock *ep;
+
+	for (ep = ExtensionBlocks; ep < ExtensionBlocks + ExtensionBlockCount;
+	     ep++) {
+		bool last = (ep - ExtensionBlocks == (ExtensionBlockCount - 1));
+		if (ep->Function == COMMENT_EXT_FUNC_CODE) {
+			printf("comment\n");
+			VisibleDumpBuffer(ep->Bytes, ep->ByteCount);
+			putchar('\n');
+			while (!last &&
+			       ep[1].Function == CONTINUE_EXT_FUNC_CODE) {
+				++ep;
+				last = (ep - ExtensionBlocks ==
+				        (ExtensionBlockCount - 1));
+				VisibleDumpBuffer(ep->Bytes, ep->ByteCount);
+				putchar('\n');
+			}
+			printf("end\n\n");
+		} else if (ep->Function == PLAINTEXT_EXT_FUNC_CODE) {
+			printf("plaintext\n");
+			VisibleDumpBuffer(ep->Bytes, ep->ByteCount);
+			putchar('\n');
+			while (!last &&
+			       ep[1].Function == CONTINUE_EXT_FUNC_CODE) {
+				++ep;
+				last = (ep - ExtensionBlocks ==
+				        (ExtensionBlockCount - 1));
+				VisibleDumpBuffer(ep->Bytes, ep->ByteCount);
+				putchar('\n');
+			}
+			printf("end\n\n");
+		} else if (ep->Function == GRAPHICS_EXT_FUNC_CODE) {
+			GraphicsControlBlock gcb;
+			printf("graphics control\n");
+			if (DGifExtensionToGCB(ep->ByteCount, ep->Bytes,
+			                       &gcb) == GIF_ERROR) {
+				GIF_MESSAGE("invalid graphics control block");
+				exit(EXIT_FAILURE);
+			}
+			printf("\tdisposal mode %d\n", gcb.DisposalMode);
+			printf("\tuser input flag %s\n",
+			       gcb.UserInputFlag ? "on" : "off");
+			printf("\tdelay %d\n", gcb.DelayTime);
+			printf("\ttransparent index %d\n",
+			       gcb.TransparentColor);
+			printf("end\n\n");
+		} else if (!last && ep->Function == APPLICATION_EXT_FUNC_CODE &&
+		           ep->ByteCount >= 11 && (ep + 1)->ByteCount >= 3 &&
+		           memcmp(ep->Bytes, "NETSCAPE2.0", 11) == 0) {
+			unsigned char *params = (++ep)->Bytes;
+			unsigned int loopcount = params[1] | (params[2] << 8);
+			printf("netscape loop %u\n\n", loopcount);
+		} else {
+			printf("extension 0x%02x\n", ep->Function);
+			VisibleDumpBuffer(ep->Bytes, ep->ByteCount);
+			while (!last &&
+			       ep[1].Function == CONTINUE_EXT_FUNC_CODE) {
+				++ep;
+				last = (ep - ExtensionBlocks ==
+				        (ExtensionBlockCount - 1));
+				VisibleDumpBuffer(ep->Bytes, ep->ByteCount);
+				putchar('\n');
+			}
+			printf("end\n\n");
+		}
+	}
+}
+
+static void Gif2Icon(char *FileName, int fdin, int fdout, char NameTable[]) {
+	int ErrorCode, im, i, j, ColorCount = 0;
+	GifFileType *GifFile;
+
+	if (fdin == -1) {
+		if ((GifFile = DGifOpenFileName(FileName, &ErrorCode)) ==
+		    NULL) {
+			PrintGifError(ErrorCode);
+			exit(EXIT_FAILURE);
+		}
+	} else {
+		/* Use stdin instead: */
+		if ((GifFile = DGifOpenFileHandle(fdin, &ErrorCode)) == NULL) {
+			PrintGifError(ErrorCode);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	if (DGifSlurp(GifFile) == GIF_ERROR) {
+		PrintGifError(GifFile->Error);
+		exit(EXIT_FAILURE);
+	}
+
+	printf("screen width %d\nscreen height %d\n", GifFile->SWidth,
+	       GifFile->SHeight);
+
+	printf(
+	    "screen colors %d\nscreen background %d\npixel aspect byte %u\n\n",
+	    1 << GifFile->SColorResolution, GifFile->SBackGroundColor,
+	    (unsigned)GifFile->AspectByte);
+
+	if (GifFile->SColorMap) {
+		printf("screen map\n");
+
+		printf("\tsort flag %s\n",
+		       GifFile->SColorMap->SortFlag ? "on" : "off");
+
+		for (i = 0; i < GifFile->SColorMap->ColorCount; i++) {
+			if (GifFile->SColorMap->ColorCount < PRINTABLES) {
+				printf("\trgb %03d %03d %03d is %c\n",
+				       GifFile->SColorMap->Colors[i].Red,
+				       GifFile->SColorMap->Colors[i].Green,
+				       GifFile->SColorMap->Colors[i].Blue,
+				       NameTable[i]);
+			} else {
+				printf("\trgb %03d %03d %03d\n",
+				       GifFile->SColorMap->Colors[i].Red,
+				       GifFile->SColorMap->Colors[i].Green,
+				       GifFile->SColorMap->Colors[i].Blue);
+			}
+		}
+		printf("end\n\n");
+	}
+
+	for (im = 0; im < GifFile->ImageCount; im++) {
+		SavedImage *image = &GifFile->SavedImages[im];
+
+		DumpExtensions(GifFile, image->ExtensionBlockCount,
+		               image->ExtensionBlocks);
+
+		printf("image # %d\nimage left %d\nimage top %d\n", im + 1,
+		       image->ImageDesc.Left, image->ImageDesc.Top);
+		if (image->ImageDesc.Interlace) {
+			printf("image interlaced\n");
+		}
+
+		if (image->ImageDesc.ColorMap) {
+			printf("image map\n");
+
+			printf("\tsort flag %s\n",
+			       image->ImageDesc.ColorMap->SortFlag ? "on"
+			                                           : "off");
+
+			if (image->ImageDesc.ColorMap->ColorCount <
+			    PRINTABLES) {
+				for (i = 0;
+				     i < image->ImageDesc.ColorMap->ColorCount;
+				     i++) {
+					printf(
+					    "\trgb %03d %03d %03d is %c\n",
+					    image->ImageDesc.ColorMap->Colors[i]
+					        .Red,
+					    image->ImageDesc.ColorMap->Colors[i]
+					        .Green,
+					    image->ImageDesc.ColorMap->Colors[i]
+					        .Blue,
+					    NameTable[i]);
+				}
+			} else {
+				for (i = 0;
+				     i < image->ImageDesc.ColorMap->ColorCount;
+				     i++) {
+					printf(
+					    "\trgb %03d %03d %03d\n",
+					    image->ImageDesc.ColorMap->Colors[i]
+					        .Red,
+					    image->ImageDesc.ColorMap->Colors[i]
+					        .Green,
+					    image->ImageDesc.ColorMap->Colors[i]
+					        .Blue);
+				}
+			}
+			printf("end\n\n");
+		}
+
+		/* one of these conditions has to be true */
+		if (image->ImageDesc.ColorMap) {
+			ColorCount = image->ImageDesc.ColorMap->ColorCount;
+		} else if (GifFile->SColorMap) {
+			ColorCount = GifFile->SColorMap->ColorCount;
+		}
+
+		if (ColorCount < PRINTABLES) {
+			printf("image bits %d by %d\n", image->ImageDesc.Width,
+			       image->ImageDesc.Height);
+		} else {
+			printf("image bits %d by %d hex\n",
+			       image->ImageDesc.Width, image->ImageDesc.Height);
+		}
+		for (i = 0; i < image->ImageDesc.Height; i++) {
+			for (j = 0; j < image->ImageDesc.Width; j++) {
+				GifByteType ch =
+				    image->RasterBits
+				        [i * image->ImageDesc.Width + j];
+				if (ColorCount < PRINTABLES &&
+				    ch < PRINTABLES) {
+					putchar(NameTable[ch]);
+				} else {
+					printf("%02x", ch);
+				}
+			}
+			putchar('\n');
+		}
+		putchar('\n');
+	}
+
+	DumpExtensions(GifFile, GifFile->ExtensionBlockCount,
+	               GifFile->ExtensionBlocks);
+
+	/* Tell EMACS this is a picture... */
+	printf("# The following sets edit modes for GNU EMACS\n");
+	printf("# Local ");     /* ...break this up, so that EMACS doesn't */
+	printf("Variables:\n"); /* get confused when visiting *this* file! */
+	printf("# mode:picture\n");
+	printf("# truncate-lines:t\n");
+	printf("# End:\n");
+
+	if (fdin == -1) {
+		(void)printf("# End of %s dump\n", FileName);
+	}
+
+	/*
+	 * Sanity checks.
+	 */
+
+	/* check that the background color isn't garbage (SF bug #87) */
+	if (GifFile->SBackGroundColor < 0 ||
+	    (GifFile->SColorMap &&
+	     GifFile->SBackGroundColor >= GifFile->SColorMap->ColorCount)) {
+		fprintf(stderr, "gifbuild: background color invalid for screen "
+		                "colormap.\n");
+	}
+
+	if (DGifCloseFile(GifFile, &ErrorCode) == GIF_ERROR) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+}
+
+static int EscapeString(char *cp, char *tp)
+/* process standard C-style escape sequences in a string */
+{
+	char *StartAddr = tp;
+
+	while (*cp) {
+		int cval = 0;
+
+		if (*cp == '\\' && strchr("0123456789xX", cp[1])) {
+			int dcount = 0;
+
+			if (*++cp == 'x' || *cp == 'X') {
+				char *dp,
+				    *hex = "00112233445566778899aAbBcCdDeEfF";
+				for (++cp;
+				     (dp = strchr(hex, *cp)) && (dcount++ < 2);
+				     cp++) {
+					cval = (cval * 16) + (dp - hex) / 2;
+				}
+			} else if (*cp == '0') {
+				while (strchr("01234567", *cp) !=
+				           (char *)NULL &&
+				       (dcount++ < 3)) {
+					cval = (cval * 8) + (*cp++ - '0');
+				}
+			} else {
+				while ((strchr("0123456789", *cp) !=
+				        (char *)NULL) &&
+				       (dcount++ < 3)) {
+					cval = (cval * 10) + (*cp++ - '0');
+				}
+			}
+		} else if (*cp == '\\') /* C-style character escapes */
+		{
+			switch (*++cp) {
+			case '\\':
+				cval = '\\';
+				break;
+			case 'n':
+				cval = '\n';
+				break;
+			case 't':
+				cval = '\t';
+				break;
+			case 'b':
+				cval = '\b';
+				break;
+			case 'r':
+				cval = '\r';
+				break;
+			default:
+				cval = *cp;
+			}
+			cp++;
+		} else if (*cp == '^') /* expand control-character syntax */
+		{
+			cval = (*++cp & 0x1f);
+			cp++;
+		} else {
+			cval = *cp++;
+		}
+		*tp++ = cval;
+	}
+
+	return (tp - StartAddr);
+}
+
+/* end */
diff --git a/gifclrmp.c b/gifclrmp.c
new file mode 100644
index 0000000..2ddcb72
--- /dev/null
+++ b/gifclrmp.c
@@ -0,0 +1,415 @@
+/*****************************************************************************
+
+gifclrmap - extract colormaps from GIF images
+
+SPDX-License-Identifier: MIT
+
+*****************************************************************************/
+
+#include <assert.h>
+#include <ctype.h>
+#include <math.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "getarg.h"
+#include "gif_lib.h"
+
+#define PROGRAM_NAME "gifclrmp"
+
+static char *VersionStr = PROGRAM_NAME VERSION_COOKIE
+    "	Gershon Elber,	" __DATE__ ",   " __TIME__ "\n"
+    "(C) Copyright 1989 Gershon Elber.\n";
+static char *CtrlStr =
+    PROGRAM_NAME " v%- s%- t%-TranslationFile!s l%-ColorMapFile!s g%-Gamma!F "
+                 "i%-Image#!d h%- GifFile!*s";
+
+static bool SaveFlag = false, TranslateFlag = false, LoadFlag = false,
+            GammaFlag = false;
+static double Gamma = 1.0;
+static FILE *ColorFile = NULL;
+FILE *TranslateFile = NULL;
+static GifPixelType Translation[256];
+
+static ColorMapObject *ModifyColorMap(ColorMapObject *ColorMap);
+static void QuitGifError(GifFileType *GifFileIn, GifFileType *GifFileOut);
+
+/******************************************************************************
+ Interpret the command line and scan the given GIF file.
+******************************************************************************/
+int main(int argc, char **argv) {
+	int NumFiles, ExtCode, CodeSize, ImageNum = 0, ImageN, HasGIFOutput,
+	                                 ErrorCode;
+	bool Error, ImageNFlag = false, HelpFlag = false, GifNoisyPrint = false;
+	GifRecordType RecordType;
+	GifByteType *Extension, *CodeBlock;
+	char **FileName = NULL, *ColorFileName, *TranslateFileName;
+	GifFileType *GifFileIn = NULL, *GifFileOut = NULL;
+
+	if ((Error = GAGetArgs(argc, argv, CtrlStr, &GifNoisyPrint, &SaveFlag,
+	                       &TranslateFlag, &TranslateFileName, &LoadFlag,
+	                       &ColorFileName, &GammaFlag, &Gamma, &ImageNFlag,
+	                       &ImageN, &HelpFlag, &NumFiles, &FileName)) !=
+	        false ||
+	    (NumFiles > 1 && !HelpFlag)) {
+		if (Error) {
+			GAPrintErrMsg(Error);
+		} else if (NumFiles > 1) {
+			GIF_MESSAGE("Error in command line parsing - one GIF "
+			            "file please.");
+		}
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_FAILURE);
+	}
+
+	if (HelpFlag) {
+		(void)fprintf(stderr, VersionStr, GIFLIB_MAJOR, GIFLIB_MINOR);
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_SUCCESS);
+	}
+
+	if (SaveFlag + LoadFlag + GammaFlag + TranslateFlag > 1) {
+		GIF_EXIT("Can not handle more than one of -s -l, -t, or -g at "
+		         "the same time.");
+	}
+
+	/* Default action is to dump colormaps */
+	if (!SaveFlag && !LoadFlag && !GammaFlag && !TranslateFlag) {
+		SaveFlag = true;
+	}
+
+	if (NumFiles == 1) {
+		if ((GifFileIn = DGifOpenFileName(*FileName, &ErrorCode)) ==
+		    NULL) {
+			PrintGifError(ErrorCode);
+			exit(EXIT_FAILURE);
+		}
+	} else {
+		/* Use stdin instead: */
+		if ((GifFileIn = DGifOpenFileHandle(0, &ErrorCode)) == NULL) {
+			PrintGifError(ErrorCode);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	if (SaveFlag) {
+		/* We are dumping out the color map as text file to stdout: */
+		ColorFile = stdout;
+	} else {
+		if (TranslateFlag) {
+			/* We are loading new color map from specified file: */
+			if ((TranslateFile = fopen(TranslateFileName, "rt")) ==
+			    NULL) {
+				GIF_EXIT("Failed to open specified color "
+				         "translation file.");
+			}
+		}
+
+		if (LoadFlag) {
+			/* We are loading new color map from specified file: */
+			if ((ColorFile = fopen(ColorFileName, "rt")) == NULL) {
+				GIF_EXIT(
+				    "Failed to open specified color map file.");
+			}
+		}
+	}
+
+	if ((HasGIFOutput = (LoadFlag || TranslateFlag || GammaFlag)) != 0) {
+		/* Open stdout for GIF output file: */
+		if ((GifFileOut = EGifOpenFileHandle(1, &ErrorCode)) == NULL) {
+			PrintGifError(ErrorCode);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	if (!ImageNFlag) {
+		/* We are supposed to modify the screen color map, so do it: */
+		if (!GifFileIn->SColorMap) {
+			GIF_EXIT("No colormap to modify");
+		}
+		GifFileIn->SColorMap = ModifyColorMap(GifFileIn->SColorMap);
+		if (!HasGIFOutput) {
+			/* We can quit here, as we have the color map: */
+			DGifCloseFile(GifFileIn, NULL);
+			fclose(ColorFile);
+			exit(EXIT_SUCCESS);
+		}
+	}
+	/* And dump out its new possible repositioned screen information: */
+	if (HasGIFOutput) {
+		if (EGifPutScreenDesc(GifFileOut, GifFileIn->SWidth,
+		                      GifFileIn->SHeight,
+		                      GifFileIn->SColorResolution,
+		                      GifFileIn->SBackGroundColor,
+		                      GifFileIn->SColorMap) == GIF_ERROR) {
+			QuitGifError(GifFileIn, GifFileOut);
+		}
+	}
+
+	/* Scan the content of the GIF file and load the image(s) in: */
+	do {
+		if (DGifGetRecordType(GifFileIn, &RecordType) == GIF_ERROR) {
+			QuitGifError(GifFileIn, GifFileOut);
+		}
+
+		switch (RecordType) {
+		case IMAGE_DESC_RECORD_TYPE:
+			if (DGifGetImageDesc(GifFileIn) == GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+			if ((++ImageNum == ImageN) && ImageNFlag) {
+				/* We are suppose to modify this image color
+				 * map, do it: */
+				GifFileIn->SColorMap =
+				    ModifyColorMap(GifFileIn->SColorMap);
+				if (!HasGIFOutput) {
+					/* We can quit here, as we have the
+					 * color map: */
+					DGifCloseFile(GifFileIn, NULL);
+					fclose(ColorFile);
+					exit(EXIT_SUCCESS);
+				}
+			}
+			if (HasGIFOutput) {
+				if (EGifPutImageDesc(
+				        GifFileOut, GifFileIn->Image.Left,
+				        GifFileIn->Image.Top,
+				        GifFileIn->Image.Width,
+				        GifFileIn->Image.Height,
+				        GifFileIn->Image.Interlace,
+				        GifFileIn->Image.ColorMap) ==
+				    GIF_ERROR) {
+					QuitGifError(GifFileIn, GifFileOut);
+				}
+			}
+
+			if (!TranslateFlag ||
+			    (ImageNFlag && (ImageN != ImageNum))) {
+				/* Now read image itself in decoded form as we
+				 * don't */
+				/* really care what we have there, and this is
+				 * much  */
+				/* faster.
+				 */
+				if (DGifGetCode(GifFileIn, &CodeSize,
+				                &CodeBlock) == GIF_ERROR) {
+					QuitGifError(GifFileIn, GifFileOut);
+				}
+				if (HasGIFOutput) {
+					if (EGifPutCode(GifFileOut, CodeSize,
+					                CodeBlock) ==
+					    GIF_ERROR) {
+						QuitGifError(GifFileIn,
+						             GifFileOut);
+					}
+				}
+				while (CodeBlock != NULL) {
+					if (DGifGetCodeNext(GifFileIn,
+					                    &CodeBlock) ==
+					    GIF_ERROR) {
+						QuitGifError(GifFileIn,
+						             GifFileOut);
+					}
+					if (HasGIFOutput) {
+						if (EGifPutCodeNext(
+						        GifFileOut,
+						        CodeBlock) ==
+						    GIF_ERROR) {
+							QuitGifError(
+							    GifFileIn,
+							    GifFileOut);
+						}
+					}
+				}
+			} else /* we need to mung pixels intices */
+			{
+				int i;
+				register GifPixelType *cp;
+
+				GifPixelType *Line = (GifPixelType *)malloc(
+				    GifFileIn->Image.Width *
+				    sizeof(GifPixelType));
+				for (i = 0; i < GifFileIn->Image.Height; i++) {
+					if (DGifGetLine(
+					        GifFileIn, Line,
+					        GifFileIn->Image.Width) ==
+					    GIF_ERROR) {
+						QuitGifError(GifFileIn,
+						             GifFileOut);
+					}
+
+					/* translation step goes here */
+					for (cp = Line;
+					     cp < Line + GifFileIn->Image.Width;
+					     cp++) {
+						*cp = Translation[*cp];
+					}
+
+					if (EGifPutLine(
+					        GifFileOut, Line,
+					        GifFileIn->Image.Width) ==
+					    GIF_ERROR) {
+						QuitGifError(GifFileIn,
+						             GifFileOut);
+					}
+				}
+				free((char *)Line);
+			}
+			break;
+		case EXTENSION_RECORD_TYPE:
+			assert(GifFileOut != NULL); /* might pacify Coverity */
+			/* pass through extension records */
+			if (DGifGetExtension(GifFileIn, &ExtCode, &Extension) ==
+			    GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+			if (Extension == NULL) {
+				break;
+			}
+			if (EGifPutExtensionLeader(GifFileOut, ExtCode) ==
+			    GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+			if (EGifPutExtensionBlock(GifFileOut, Extension[0],
+			                          Extension + 1) == GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+			while (Extension != NULL) {
+				if (DGifGetExtensionNext(
+				        GifFileIn, &Extension) == GIF_ERROR) {
+					QuitGifError(GifFileIn, GifFileOut);
+				}
+				if (Extension != NULL) {
+					if (EGifPutExtensionBlock(
+					        GifFileOut, Extension[0],
+					        Extension + 1) == GIF_ERROR) {
+						QuitGifError(GifFileIn,
+						             GifFileOut);
+					}
+				}
+			}
+			if (EGifPutExtensionTrailer(GifFileOut) == GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+			break;
+		case TERMINATE_RECORD_TYPE:
+			break;
+		default: /* Should be trapped by DGifGetRecordType. */
+			break;
+		}
+	} while (RecordType != TERMINATE_RECORD_TYPE);
+
+	if (DGifCloseFile(GifFileIn, &ErrorCode) == GIF_ERROR) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+	if (HasGIFOutput) {
+		if (EGifCloseFile(GifFileOut, &ErrorCode) == GIF_ERROR) {
+			PrintGifError(ErrorCode);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+ Modify the given colormap according to global variables setting.
+******************************************************************************/
+static ColorMapObject *ModifyColorMap(ColorMapObject *ColorMap) {
+	int i, Dummy, Red, Green, Blue;
+
+	if (SaveFlag) {
+		/* Save this color map to ColorFile: */
+		for (i = 0; i < ColorMap->ColorCount; i++) {
+			fprintf(ColorFile, "%3d %3d %3d %3d\n", i,
+			        ColorMap->Colors[i].Red,
+			        ColorMap->Colors[i].Green,
+			        ColorMap->Colors[i].Blue);
+		}
+		return (ColorMap);
+	} else if (LoadFlag) {
+		/* Read the color map in ColorFile into this color map: */
+		for (i = 0; i < ColorMap->ColorCount; i++) {
+			if (feof(ColorFile)) {
+				GIF_EXIT("Color file to load color map from, "
+				         "too small.");
+			}
+			if (fscanf(ColorFile, "%3d %3d %3d %3d\n", &Dummy, &Red,
+			           &Green, &Blue) == 4) {
+				ColorMap->Colors[i].Red = Red;
+				ColorMap->Colors[i].Green = Green;
+				ColorMap->Colors[i].Blue = Blue;
+			}
+		}
+		return (ColorMap);
+	} else if (GammaFlag) {
+		/* Apply gamma correction to this color map: */
+		double Gamma1 = 1.0 / Gamma;
+		for (i = 0; i < ColorMap->ColorCount; i++) {
+			ColorMap->Colors[i].Red =
+			    ((int)(255 * pow(ColorMap->Colors[i].Red / 255.0,
+			                     Gamma1)));
+			ColorMap->Colors[i].Green =
+			    ((int)(255 * pow(ColorMap->Colors[i].Green / 255.0,
+			                     Gamma1)));
+			ColorMap->Colors[i].Blue =
+			    ((int)(255 * pow(ColorMap->Colors[i].Blue / 255.0,
+			                     Gamma1)));
+		}
+		return (ColorMap);
+	} else if (TranslateFlag) {
+		ColorMapObject *NewMap;
+		int Max = 0;
+
+		/* Read the translation table in TranslateFile: */
+		for (i = 0; i < ColorMap->ColorCount; i++) {
+			int tmp;
+			if (feof(TranslateFile)) {
+				GIF_EXIT("Color file to load color map from, "
+				         "too small.");
+			}
+			if (fscanf(TranslateFile, "%3d %3d\n", &Dummy, &tmp) ==
+			    2) {
+				Translation[i] = tmp & 0xff;
+				if (Translation[i] > Max) {
+					Max = Translation[i];
+				}
+			}
+		}
+
+		if ((NewMap = GifMakeMapObject(1 << GifBitSize(Max + 1),
+		                               NULL)) == NULL) {
+			GIF_EXIT("Out of memory while allocating color map!");
+		}
+
+		/* Apply the translation; we'll do it to the pixels, too */
+		for (i = 0; i < ColorMap->ColorCount; i++) {
+			NewMap->Colors[i] = ColorMap->Colors[Translation[i]];
+		}
+
+		return (NewMap);
+	} else {
+		GIF_EXIT("Nothing to do!");
+		return (ColorMap);
+	}
+}
+
+/******************************************************************************
+ Close both input and output file (if open), and exit.
+******************************************************************************/
+static void QuitGifError(GifFileType *GifFileIn, GifFileType *GifFileOut) {
+	if (GifFileIn != NULL) {
+		PrintGifError(GifFileIn->Error);
+		EGifCloseFile(GifFileIn, NULL);
+	}
+	if (GifFileOut != NULL) {
+		PrintGifError(GifFileOut->Error);
+		EGifCloseFile(GifFileOut, NULL);
+	}
+	exit(EXIT_FAILURE);
+}
+
+/* end */
diff --git a/gifcolor.c b/gifcolor.c
new file mode 100644
index 0000000..017f554
--- /dev/null
+++ b/gifcolor.c
@@ -0,0 +1,167 @@
+/*****************************************************************************
+
+gifcolor - generate color test-pattern GIFs
+
+SPDX-License-Identifier: MIT
+
+*****************************************************************************/
+
+#include <ctype.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "getarg.h"
+#include "gif_lib.h"
+
+#define PROGRAM_NAME "gifcolor"
+
+#define LINE_LEN 40
+#define IMAGEWIDTH LINE_LEN *GIF_FONT_WIDTH
+
+static char *VersionStr = PROGRAM_NAME VERSION_COOKIE
+    "	Gershon Elber,	" __DATE__ ",   " __TIME__ "\n"
+    "(C) Copyright 1989 Gershon Elber.\n";
+static char *CtrlStr = PROGRAM_NAME " v%- b%-Background!d h%-";
+
+static int BackGround = 0;
+static void QuitGifError(GifFileType *GifFile);
+static void GenRasterTextLine(GifRowType *RasterBuffer, char *TextLine,
+                              int BufferWidth, int ForeGroundIndex);
+
+/******************************************************************************
+ Interpret the command line and generate the given GIF file.
+******************************************************************************/
+int main(int argc, char **argv) {
+	int i, j, l, GifNoisyPrint, ColorMapSize, ErrorCode;
+	bool Error, BackGroundFlag = false, HelpFlag = false;
+	char Line[LINE_LEN];
+	GifRowType RasterBuffer[GIF_FONT_HEIGHT];
+	ColorMapObject *ColorMap;
+	GifFileType *GifFile;
+	GifColorType ScratchMap[256];
+	int red, green, blue;
+
+	if ((Error = GAGetArgs(argc, argv, CtrlStr, &GifNoisyPrint,
+	                       &BackGroundFlag, &BackGround, &HelpFlag)) !=
+	    false) {
+		GAPrintErrMsg(Error);
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_FAILURE);
+	}
+
+	if (HelpFlag) {
+		(void)fprintf(stderr, VersionStr, GIFLIB_MAJOR, GIFLIB_MINOR);
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_SUCCESS);
+	}
+
+	/* Allocate the raster buffer for GIF_FONT_HEIGHT scan lines. */
+	for (i = 0; i < GIF_FONT_HEIGHT; i++) {
+		if ((RasterBuffer[i] = (GifRowType)malloc(
+		         sizeof(GifPixelType) * IMAGEWIDTH)) == NULL) {
+			GIF_EXIT(
+			    "Failed to allocate memory required, aborted.");
+		}
+	}
+
+	/* Open stdout for the output file: */
+	if ((GifFile = EGifOpenFileHandle(1, &ErrorCode)) == NULL) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+
+	/* Read the color map in ColorFile into this color map: */
+	ColorMapSize = 0;
+	while (fscanf(stdin, "%*3d %3d %3d %3d\n", &red, &green, &blue) == 3) {
+		if (ColorMapSize < 256) {
+			ScratchMap[ColorMapSize].Red = red;
+			ScratchMap[ColorMapSize].Green = green;
+			ScratchMap[ColorMapSize].Blue = blue;
+			ColorMapSize++;
+		} else {
+			GIF_EXIT("Too many color map triples, aborting.");
+		}
+	}
+
+	if ((ColorMap = GifMakeMapObject(1 << GifBitSize(ColorMapSize),
+	                                 ScratchMap)) == NULL) {
+		GIF_EXIT("Failed to allocate memory required, aborted.");
+	}
+
+	if (EGifPutScreenDesc(
+	        GifFile, IMAGEWIDTH, ColorMapSize * GIF_FONT_HEIGHT,
+	        GifBitSize(ColorMapSize), BackGround, ColorMap) == GIF_ERROR) {
+		QuitGifError(GifFile);
+	}
+
+	/* Dump out the image descriptor: */
+	if (EGifPutImageDesc(GifFile, 0, 0, IMAGEWIDTH,
+	                     ColorMapSize * GIF_FONT_HEIGHT, false,
+	                     NULL) == GIF_ERROR) {
+		QuitGifError(GifFile);
+	}
+
+	GifQprintf("\n%s: Image 1 at (%d, %d) [%dx%d]:     ", PROGRAM_NAME,
+	           GifFile->Image.Left, GifFile->Image.Top,
+	           GifFile->Image.Width, GifFile->Image.Height);
+
+	for (i = l = 0; i < ColorMap->ColorCount; i++) {
+		(void)snprintf(
+		    Line, sizeof(Line), "Color %-3d: [%-3d, %-3d, %-3d] ", i,
+		    ColorMap->Colors[i].Red, ColorMap->Colors[i].Green,
+		    ColorMap->Colors[i].Blue);
+		GenRasterTextLine(RasterBuffer, Line, IMAGEWIDTH, i);
+		for (j = 0; j < GIF_FONT_HEIGHT; j++) {
+			if (EGifPutLine(GifFile, RasterBuffer[j], IMAGEWIDTH) ==
+			    GIF_ERROR) {
+				QuitGifError(GifFile);
+			}
+			GifQprintf("\b\b\b\b%-4d", l++);
+		}
+	}
+
+	if (EGifCloseFile(GifFile, &ErrorCode) == GIF_ERROR) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+ Close output file (if open), and exit.
+******************************************************************************/
+static void GenRasterTextLine(GifRowType *RasterBuffer, char *TextLine,
+                              int BufferWidth, int ForeGroundIndex) {
+	unsigned char Byte, Mask;
+	int i, j, k, CharPosX, Len = strlen(TextLine);
+
+	for (i = 0; i < BufferWidth; i++)
+		for (j = 0; j < GIF_FONT_HEIGHT; j++)
+			RasterBuffer[j][i] = BackGround;
+
+	for (i = CharPosX = 0; i < Len; i++, CharPosX += GIF_FONT_WIDTH) {
+		unsigned char c = TextLine[i];
+		for (j = 0; j < GIF_FONT_HEIGHT; j++) {
+			Byte = GifAsciiTable8x8[(unsigned short)c][j];
+			for (k = 0, Mask = 128; k < GIF_FONT_WIDTH;
+			     k++, Mask >>= 1)
+				if (Byte & Mask)
+					RasterBuffer[j][CharPosX + k] =
+					    ForeGroundIndex;
+		}
+	}
+}
+
+/******************************************************************************
+ Close output file (if open), and exit.
+******************************************************************************/
+static void QuitGifError(GifFileType *GifFile) {
+	if (GifFile != NULL) {
+		PrintGifError(GifFile->Error);
+		EGifCloseFile(GifFile, NULL);
+	}
+	exit(EXIT_FAILURE);
+}
diff --git a/gifecho.c b/gifecho.c
new file mode 100644
index 0000000..8eb005e
--- /dev/null
+++ b/gifecho.c
@@ -0,0 +1,228 @@
+/*****************************************************************************
+
+gifecho - generate a GIF from ASCII text
+
+SPDX-License-Identifier: MIT
+
+*****************************************************************************/
+
+#include <ctype.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "getarg.h"
+#include "gif_lib.h"
+
+#define PROGRAM_NAME "gifecho"
+
+#define MAX_NUM_TEXT_LINES 100 /* Maximum number of lines in file. */
+
+#define LINE_LEN 256 /* Maximum length of one text line. */
+
+#define DEFAULT_FG_INDEX 1 /* Text foreground index. */
+
+#define DEFAULT_COLOR_RED 255 /* Text foreground color. */
+#define DEFAULT_COLOR_GREEN 255
+#define DEFAULT_COLOR_BLUE 255
+
+static char *VersionStr = PROGRAM_NAME VERSION_COOKIE
+    "	Gershon Elber,	" __DATE__ ",   " __TIME__ "\n"
+    "(C) Copyright 1989 Gershon Elber.\n";
+static char *CtrlStr = PROGRAM_NAME
+    " v%- s%-ClrMapSize!d f%-FGClr!d c%-R|G|B!d!d!d t%-\"Text\"!s h%-";
+
+static unsigned int RedColor = DEFAULT_COLOR_RED,
+                    GreenColor = DEFAULT_COLOR_GREEN,
+                    BlueColor = DEFAULT_COLOR_BLUE;
+
+static void QuitGifError(GifFileType *GifFile);
+static void GenRasterTextLine(GifRowType *RasterBuffer, char *TextLine,
+                              int BufferWidth, int ForeGroundIndex);
+
+/******************************************************************************
+ Interpret the command line and generate the given GIF file.
+******************************************************************************/
+int main(int argc, char **argv) {
+	int i, j, l, ImageWidth, ImageHeight, NumOfLines, LogNumLevels,
+	    ErrorCode, NumLevels, ColorMapSize = 1,
+	                          ForeGroundIndex = DEFAULT_FG_INDEX;
+	bool Error, ClrMapSizeFlag = false, ForeGroundFlag = false,
+	            TextLineFlag = false, HelpFlag = false, ColorFlag = false,
+	            GifNoisyPrint = false;
+	char *TextLines[MAX_NUM_TEXT_LINES];
+	GifRowType RasterBuffer[GIF_FONT_HEIGHT];
+	ColorMapObject *ColorMap;
+	GifFileType *GifFile;
+
+	if ((Error =
+	         GAGetArgs(argc, argv, CtrlStr, &GifNoisyPrint, &ClrMapSizeFlag,
+	                   &ColorMapSize, &ForeGroundFlag, &ForeGroundIndex,
+	                   &ColorFlag, &RedColor, &GreenColor, &BlueColor,
+	                   &TextLineFlag, &TextLines[0], &HelpFlag)) != false) {
+		GAPrintErrMsg(Error);
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_FAILURE);
+	}
+
+	if (HelpFlag) {
+		(void)fprintf(stderr, VersionStr, GIFLIB_MAJOR, GIFLIB_MINOR);
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_SUCCESS);
+	}
+
+	if (ForeGroundIndex > 255 || ForeGroundIndex < 1) {
+		GIF_EXIT(
+		    "Foregound (-f) should be in the range 1..255, aborted.");
+	}
+
+	if (ColorMapSize > 8 || ColorMapSize < 1) {
+		GIF_EXIT(
+		    "ColorMapSize (-s) should be in the range 1..8, aborted.");
+	}
+
+	if (TextLineFlag) {
+		NumOfLines = 1;
+		ImageHeight = GIF_FONT_HEIGHT;
+		ImageWidth = GIF_FONT_WIDTH * strlen(TextLines[0]);
+	} else {
+		char Line[LINE_LEN];
+		NumOfLines = l = 0;
+		while (fgets(Line, LINE_LEN - 1, stdin)) {
+			for (i = strlen(Line); i > 0 && Line[i - 1] <= ' ';
+			     i--) {
+				;
+			}
+			Line[i] = 0;
+			if (l < i) {
+				l = i;
+			}
+			TextLines[NumOfLines++] = strdup(Line);
+			if (NumOfLines == MAX_NUM_TEXT_LINES) {
+				GIF_EXIT(
+				    "Input file has too many lines, aborted.");
+			}
+		}
+		if (NumOfLines == 0) {
+			GIF_EXIT("No input text, aborted.");
+		}
+		ImageHeight = GIF_FONT_HEIGHT * NumOfLines;
+		ImageWidth = GIF_FONT_WIDTH * l;
+	}
+
+	/* Allocate the raster buffer for GIF_FONT_HEIGHT scan lines (one text
+	 * line). */
+	for (i = 0; i < GIF_FONT_HEIGHT; i++) {
+		if ((RasterBuffer[i] = (GifRowType)malloc(
+		         sizeof(GifPixelType) * ImageWidth)) == NULL) {
+			GIF_EXIT(
+			    "Failed to allocate memory required, aborted.");
+		}
+	}
+
+	/* Open stdout for the output file: */
+	if ((GifFile = EGifOpenFileHandle(1, &ErrorCode)) == NULL) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+
+	/* Dump out screen description with given size and generated color map:
+	 */
+	for (LogNumLevels = 1, NumLevels = 2; NumLevels < ForeGroundIndex;
+	     LogNumLevels++, NumLevels <<= 1) {
+		;
+	}
+	if (NumLevels < (1 << ColorMapSize)) {
+		NumLevels = (1 << ColorMapSize);
+		LogNumLevels = ColorMapSize;
+	}
+
+	if ((ColorMap = GifMakeMapObject(NumLevels, NULL)) == NULL) {
+		GIF_EXIT("Failed to allocate memory required, aborted.");
+	}
+
+	for (i = 0; i < NumLevels; i++) {
+		ColorMap->Colors[i].Red = ColorMap->Colors[i].Green =
+		    ColorMap->Colors[i].Blue = 0;
+	}
+	ColorMap->Colors[ForeGroundIndex].Red = RedColor;
+	ColorMap->Colors[ForeGroundIndex].Green = GreenColor;
+	ColorMap->Colors[ForeGroundIndex].Blue = BlueColor;
+
+	if (EGifPutScreenDesc(GifFile, ImageWidth, ImageHeight, LogNumLevels, 0,
+	                      ColorMap) == GIF_ERROR) {
+		QuitGifError(GifFile);
+	}
+
+	/* Dump out the image descriptor: */
+	if (EGifPutImageDesc(GifFile, 0, 0, ImageWidth, ImageHeight, false,
+	                     NULL) == GIF_ERROR) {
+		QuitGifError(GifFile);
+	}
+
+	GifQprintf("\n%s: Image 1 at (%d, %d) [%dx%d]:     ", PROGRAM_NAME,
+	           GifFile->Image.Left, GifFile->Image.Top,
+	           GifFile->Image.Width, GifFile->Image.Height);
+
+	for (i = l = 0; i < NumOfLines; i++) {
+		GenRasterTextLine(RasterBuffer, TextLines[i], ImageWidth,
+		                  ForeGroundIndex);
+		for (j = 0; j < GIF_FONT_HEIGHT; j++) {
+			if (EGifPutLine(GifFile, RasterBuffer[j], ImageWidth) ==
+			    GIF_ERROR) {
+				QuitGifError(GifFile);
+			}
+			GifQprintf("\b\b\b\b%-4d", l++);
+		}
+	}
+
+	if (EGifCloseFile(GifFile, &ErrorCode) == GIF_ERROR) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+ Generate raster bits corresponding to given text
+******************************************************************************/
+static void GenRasterTextLine(GifRowType *RasterBuffer, char *TextLine,
+                              int BufferWidth, int ForeGroundIndex) {
+	unsigned char Byte, Mask;
+	int i, j, k, CharPosX, Len = strlen(TextLine);
+
+	for (i = 0; i < BufferWidth; i++) {
+		for (j = 0; j < GIF_FONT_HEIGHT; j++) {
+			RasterBuffer[j][i] = 0;
+		}
+	}
+
+	for (i = CharPosX = 0; i < Len; i++, CharPosX += GIF_FONT_WIDTH) {
+		unsigned char c = TextLine[i];
+		for (j = 0; j < GIF_FONT_HEIGHT; j++) {
+			Byte = GifAsciiTable8x8[(unsigned short)c][j];
+			for (k = 0, Mask = 128; k < GIF_FONT_WIDTH;
+			     k++, Mask >>= 1) {
+				if (Byte & Mask) {
+					RasterBuffer[j][CharPosX + k] =
+					    ForeGroundIndex;
+				}
+			}
+		}
+	}
+}
+
+/******************************************************************************
+ * Close output file (if open), and exit.
+ ******************************************************************************/
+static void QuitGifError(GifFileType *GifFile) {
+	if (GifFile != NULL) {
+		PrintGifError(GifFile->Error);
+		EGifCloseFile(GifFile, NULL);
+	}
+	exit(EXIT_FAILURE);
+}
+
+/* end */
diff --git a/giffilter.c b/giffilter.c
new file mode 100644
index 0000000..98c2af2
--- /dev/null
+++ b/giffilter.c
@@ -0,0 +1,173 @@
+/******************************************************************************
+
+giffilter.c - skeleton file for generic GIF `filter' program
+
+Sequentially read GIF records from stdin, process them, send them out.
+Most of the junk above `int main' isn't needed for the skeleton, but
+is likely to be for what you'll do with it.
+
+If you compile this, it will turn into an expensive GIF copying routine;
+stdin to stdout with no changes and minimal validation.  Well, it's a
+decent test of the low-level routines, anyway.
+
+Note: due to the vicissitudes of Lempel-Ziv compression, the output of this
+copier may not be bitwise identical to its input.  This can happen if you
+copy an image from a much more (or much *less*) memory-limited system; your
+compression may use more (or fewer) bits.  The uncompressed rasters should,
+however, be identical (you can check this with gifbuild -d).
+
+SPDX-License-Identifier: MIT
+
+******************************************************************************/
+
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "getarg.h"
+#include "gif_lib.h"
+
+#define PROGRAM_NAME "giffilter"
+
+/******************************************************************************
+ Close both input and output file (if open), and exit.
+******************************************************************************/
+static void QuitGifError(GifFileType *GifFileIn, GifFileType *GifFileOut) {
+	if (GifFileIn != NULL) {
+		PrintGifError(GifFileIn->Error);
+		EGifCloseFile(GifFileIn, NULL);
+	}
+	if (GifFileOut != NULL) {
+		PrintGifError(GifFileOut->Error);
+		EGifCloseFile(GifFileOut, NULL);
+	}
+	exit(EXIT_FAILURE);
+}
+
+/******************************************************************************
+ Main sequence
+******************************************************************************/
+int main(int argc, char **argv) {
+	GifFileType *GifFileIn = NULL, *GifFileOut = NULL;
+	GifRecordType RecordType;
+	int CodeSize, ExtCode, ErrorCode;
+	GifByteType *CodeBlock, *Extension;
+
+	/*
+	 * Command-line processing goes here.
+	 */
+
+	/* Use stdin as input (note this also read screen descriptor in: */
+	if ((GifFileIn = DGifOpenFileHandle(0, &ErrorCode)) == NULL) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+
+	/* Use the stdout as output: */
+	if ((GifFileOut = EGifOpenFileHandle(1, &ErrorCode)) == NULL) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+
+	/* And dump out its screen information: */
+	if (EGifPutScreenDesc(GifFileOut, GifFileIn->SWidth, GifFileIn->SHeight,
+	                      GifFileIn->SColorResolution,
+	                      GifFileIn->SBackGroundColor,
+	                      GifFileIn->SColorMap) == GIF_ERROR) {
+		QuitGifError(GifFileIn, GifFileOut);
+	}
+
+	/* Scan the content of the input GIF file and load the image(s) in: */
+	do {
+		if (DGifGetRecordType(GifFileIn, &RecordType) == GIF_ERROR) {
+			QuitGifError(GifFileIn, GifFileOut);
+		}
+
+		switch (RecordType) {
+		case IMAGE_DESC_RECORD_TYPE:
+			if (DGifGetImageDesc(GifFileIn) == GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+			/* Put image descriptor to out file: */
+			if (EGifPutImageDesc(
+			        GifFileOut, GifFileIn->Image.Left,
+			        GifFileIn->Image.Top, GifFileIn->Image.Width,
+			        GifFileIn->Image.Height,
+			        GifFileIn->Image.Interlace,
+			        GifFileIn->Image.ColorMap) == GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+
+			/* Now read image itself in decoded form as we dont
+			 * really   */
+			/* care what we have there, and this is much faster.
+			 */
+			if (DGifGetCode(GifFileIn, &CodeSize, &CodeBlock) ==
+			        GIF_ERROR ||
+			    EGifPutCode(GifFileOut, CodeSize, CodeBlock) ==
+			        GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+			while (CodeBlock != NULL) {
+				if (DGifGetCodeNext(GifFileIn, &CodeBlock) ==
+				        GIF_ERROR ||
+				    EGifPutCodeNext(GifFileOut, CodeBlock) ==
+				        GIF_ERROR) {
+					QuitGifError(GifFileIn, GifFileOut);
+				}
+			}
+			break;
+		case EXTENSION_RECORD_TYPE:
+			/* pass through extension records */
+			if (DGifGetExtension(GifFileIn, &ExtCode, &Extension) ==
+			        GIF_ERROR ||
+			    Extension == NULL) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+			if (EGifPutExtensionLeader(GifFileOut, ExtCode) ==
+			    GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+			if (EGifPutExtensionBlock(GifFileOut, Extension[0],
+			                          Extension + 1) == GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+			while (Extension != NULL) {
+				if (DGifGetExtensionNext(
+				        GifFileIn, &Extension) == GIF_ERROR) {
+					QuitGifError(GifFileIn, GifFileOut);
+				}
+				if (Extension != NULL) {
+					if (EGifPutExtensionBlock(
+					        GifFileOut, Extension[0],
+					        Extension + 1) == GIF_ERROR) {
+						QuitGifError(GifFileIn,
+						             GifFileOut);
+					}
+				}
+			}
+			if (EGifPutExtensionTrailer(GifFileOut) == GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+			break;
+		case TERMINATE_RECORD_TYPE:
+			break;
+		default: /* Should be trapped by DGifGetRecordType */
+			break;
+		}
+	} while (RecordType != TERMINATE_RECORD_TYPE);
+
+	if (DGifCloseFile(GifFileIn, &ErrorCode) == GIF_ERROR) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+	if (EGifCloseFile(GifFileOut, &ErrorCode) == GIF_ERROR) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+
+	return 0;
+}
+
+/* end */
diff --git a/giffix.c b/giffix.c
new file mode 100644
index 0000000..e7a79a8
--- /dev/null
+++ b/giffix.c
@@ -0,0 +1,244 @@
+/*****************************************************************************
+
+giffix - attempt to fix a truncated GIF
+
+SPDX-License-Identifier: MIT
+
+*****************************************************************************/
+
+#include <ctype.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "getarg.h"
+#include "gif_lib.h"
+
+#define PROGRAM_NAME "giffix"
+
+static char *VersionStr = PROGRAM_NAME VERSION_COOKIE
+    "	Gershon Elber,	" __DATE__ ",   " __TIME__ "\n"
+    "(C) Copyright 1989 Gershon Elber.\n";
+static char *CtrlStr = PROGRAM_NAME " v%- h%- GifFile!*s";
+
+static void QuitGifError(GifFileType *GifFileIn, GifFileType *GifFileOut);
+
+/******************************************************************************
+ Interpret the command line and scan the given GIF file.
+******************************************************************************/
+int main(int argc, char **argv) {
+	int i, j, NumFiles, ExtCode, Row, Col, Width, Height, ErrorCode,
+	    DarkestColor = 0, ColorIntens = 10000;
+	bool Error, HelpFlag = false, GifNoisyPrint = false;
+	GifRecordType RecordType;
+	GifByteType *Extension;
+	char **FileName = NULL;
+	GifRowType LineBuffer;
+	ColorMapObject *ColorMap;
+	GifFileType *GifFileIn = NULL, *GifFileOut = NULL;
+	int ImageNum = 0;
+
+	if ((Error = GAGetArgs(argc, argv, CtrlStr, &GifNoisyPrint, &HelpFlag,
+	                       &NumFiles, &FileName)) != false ||
+	    (NumFiles > 1 && !HelpFlag)) {
+		if (Error) {
+			GAPrintErrMsg(Error);
+		} else if (NumFiles > 1) {
+			GIF_MESSAGE("Error in command line parsing - one GIF "
+			            "file please.");
+		}
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_FAILURE);
+	}
+
+	if (HelpFlag) {
+		(void)fprintf(stderr, VersionStr, GIFLIB_MAJOR, GIFLIB_MINOR);
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_SUCCESS);
+	}
+
+	if (NumFiles == 1) {
+		if ((GifFileIn = DGifOpenFileName(*FileName, &ErrorCode)) ==
+		    NULL) {
+			PrintGifError(ErrorCode);
+			exit(EXIT_FAILURE);
+		}
+	} else {
+		/* Use stdin instead: */
+		if ((GifFileIn = DGifOpenFileHandle(0, &ErrorCode)) == NULL) {
+			PrintGifError(ErrorCode);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	/* Open stdout for the output file: */
+	if ((GifFileOut = EGifOpenFileHandle(1, &ErrorCode)) == NULL) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+
+	/* Dump out exactly same screen information: */
+	/* coverity[var_deref_op] */
+	if (EGifPutScreenDesc(GifFileOut, GifFileIn->SWidth, GifFileIn->SHeight,
+	                      GifFileIn->SColorResolution,
+	                      GifFileIn->SBackGroundColor,
+	                      GifFileIn->SColorMap) == GIF_ERROR) {
+		QuitGifError(GifFileIn, GifFileOut);
+	}
+
+	if ((LineBuffer = (GifRowType)malloc(GifFileIn->SWidth)) == NULL) {
+		GIF_EXIT("Failed to allocate memory required, aborted.");
+	}
+
+	/* Scan the content of the GIF file and load the image(s) in: */
+	do {
+		if (DGifGetRecordType(GifFileIn, &RecordType) == GIF_ERROR) {
+			QuitGifError(GifFileIn, GifFileOut);
+		}
+
+		switch (RecordType) {
+		case IMAGE_DESC_RECORD_TYPE:
+			if (DGifGetImageDesc(GifFileIn) == GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+			if (GifFileIn->Image.Interlace) {
+				GIF_EXIT("Cannot fix interlaced images.");
+			}
+
+			Row = GifFileIn->Image
+			          .Top; /* Image Position relative to Screen. */
+			Col = GifFileIn->Image.Left;
+			Width = GifFileIn->Image.Width;
+			Height = GifFileIn->Image.Height;
+			GifQprintf("\n%s: Image %d at (%d, %d) [%dx%d]:     ",
+			           PROGRAM_NAME, ++ImageNum, Col, Row, Width,
+			           Height);
+			if (Width > GifFileIn->SWidth) {
+				GIF_EXIT("Image is wider than total");
+			}
+
+			/* Put the image descriptor to out file: */
+			if (EGifPutImageDesc(
+			        GifFileOut, Col, Row, Width, Height, false,
+			        GifFileIn->Image.ColorMap) == GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+
+			/* Find the darkest color in color map to use as a
+			 * filler. */
+			ColorMap = (GifFileIn->Image.ColorMap
+			                ? GifFileIn->Image.ColorMap
+			                : GifFileIn->SColorMap);
+			for (i = 0; i < ColorMap->ColorCount; i++) {
+				j = ((int)ColorMap->Colors[i].Red) * 30 +
+				    ((int)ColorMap->Colors[i].Green) * 59 +
+				    ((int)ColorMap->Colors[i].Blue) * 11;
+				if (j < ColorIntens) {
+					ColorIntens = j;
+					DarkestColor = i;
+				}
+			}
+
+			/* Load the image, and dump it. */
+			for (i = 0; i < Height; i++) {
+				GifQprintf("\b\b\b\b%-4d", i);
+				if (DGifGetLine(GifFileIn, LineBuffer, Width) ==
+				    GIF_ERROR) {
+					break;
+				}
+				if (EGifPutLine(GifFileOut, LineBuffer,
+				                Width) == GIF_ERROR) {
+					QuitGifError(GifFileIn, GifFileOut);
+				}
+			}
+
+			if (i < Height) {
+				fprintf(stderr, "\nFollowing error occurred "
+				                "(and ignored):");
+				PrintGifError(GifFileIn->Error);
+
+				/* Fill in with the darkest color in color map.
+				 */
+				for (j = 0; j < Width; j++) {
+					LineBuffer[j] = DarkestColor;
+				}
+				for (; i < Height; i++) {
+					if (EGifPutLine(GifFileOut, LineBuffer,
+					                Width) == GIF_ERROR) {
+						QuitGifError(GifFileIn,
+						             GifFileOut);
+					}
+				}
+			}
+			break;
+		case EXTENSION_RECORD_TYPE:
+			/* pass through extension records */
+			if (DGifGetExtension(GifFileIn, &ExtCode, &Extension) ==
+			    GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+			if (EGifPutExtensionLeader(GifFileOut, ExtCode) ==
+			    GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+			if (Extension != NULL) {
+				if (EGifPutExtensionBlock(
+				        GifFileOut, Extension[0],
+				        Extension + 1) == GIF_ERROR) {
+					QuitGifError(GifFileIn, GifFileOut);
+				}
+			}
+			while (Extension != NULL) {
+				if (DGifGetExtensionNext(
+				        GifFileIn, &Extension) == GIF_ERROR) {
+					QuitGifError(GifFileIn, GifFileOut);
+				}
+				if (Extension != NULL) {
+					if (EGifPutExtensionBlock(
+					        GifFileOut, Extension[0],
+					        Extension + 1) == GIF_ERROR) {
+						QuitGifError(GifFileIn,
+						             GifFileOut);
+					}
+				}
+			}
+			if (EGifPutExtensionTrailer(GifFileOut) == GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+			break;
+		case TERMINATE_RECORD_TYPE:
+			break;
+		default: /* Should be trapped by DGifGetRecordType. */
+			break;
+		}
+	} while (RecordType != TERMINATE_RECORD_TYPE);
+
+	if (DGifCloseFile(GifFileIn, &ErrorCode) == GIF_ERROR) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+	if (EGifCloseFile(GifFileOut, &ErrorCode) == GIF_ERROR) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+	return 0;
+}
+
+/******************************************************************************
+ Close both input and output file (if open), and exit.
+******************************************************************************/
+static void QuitGifError(GifFileType *GifFileIn, GifFileType *GifFileOut) {
+	fprintf(stderr, "\nFollowing unrecoverable error occurred:");
+	if (GifFileIn != NULL) {
+		PrintGifError(GifFileIn->Error);
+		EGifCloseFile(GifFileIn, NULL);
+	}
+	if (GifFileOut != NULL) {
+		PrintGifError(GifFileOut->Error);
+		EGifCloseFile(GifFileOut, NULL);
+	}
+	exit(EXIT_FAILURE);
+}
+
+/* end */
diff --git a/gifhisto.c b/gifhisto.c
new file mode 100644
index 0000000..fb79ea0
--- /dev/null
+++ b/gifhisto.c
@@ -0,0 +1,298 @@
+/*****************************************************************************
+
+gifhisto - make a color histogram from image color frequencies
+
+SPDX-License-Identifier: MIT
+
+*****************************************************************************/
+
+#include <ctype.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "getarg.h"
+#include "gif_lib.h"
+
+#define PROGRAM_NAME "gifhisto"
+
+#define DEFAULT_HISTO_WIDTH 100 /* Histogram image diemnsions. */
+#define DEFAULT_HISTO_HEIGHT 256
+#define HISTO_BITS_PER_PIXEL 2 /* Size of bitmap for histogram GIF. */
+
+static char *VersionStr = PROGRAM_NAME VERSION_COOKIE
+    "	Gershon Elber,	" __DATE__ ",   " __TIME__ "\n"
+    "(C) Copyright 1989 Gershon Elber.\n";
+static char *CtrlStr = PROGRAM_NAME
+    " v%- t%- s%-Width|Height!d!d n%-ImageNumber!d b%- h%- GifFile!*s";
+
+static int ImageWidth = DEFAULT_HISTO_WIDTH, ImageHeight = DEFAULT_HISTO_HEIGHT,
+           ImageN = 1;
+static GifColorType HistoColorMap[] = {/* Constant bit map for histograms: */
+                                       {0, 0, 0},
+                                       {255, 0, 0},
+                                       {0, 255, 0},
+                                       {0, 0, 255}};
+
+static void QuitGifError(GifFileType *GifFileIn, GifFileType *GifFileOut);
+
+/******************************************************************************
+ Interpret the command line and scan the given GIF file.
+******************************************************************************/
+int main(int argc, char **argv) {
+	int i, j, ErrorCode, NumFiles, ExtCode, CodeSize, NumColors = 2,
+	                                                  ImageNum = 0;
+	bool Error, TextFlag = false, SizeFlag = false, ImageNFlag = false,
+	            BackGroundFlag = false, HelpFlag = false, GifNoisyPrint;
+	long Histogram[256];
+	GifRecordType RecordType;
+	GifByteType *Extension, *CodeBlock;
+	char **FileName = NULL;
+	GifRowType Line;
+	GifFileType *GifFileIn = NULL, *GifFileOut = NULL;
+
+	/* Same image dimension vars for both Image & ImageN as only one allowed
+	 */
+	if ((Error = GAGetArgs(argc, argv, CtrlStr, &GifNoisyPrint, &TextFlag,
+	                       &SizeFlag, &ImageWidth, &ImageHeight,
+	                       &ImageNFlag, &ImageN, &BackGroundFlag, &HelpFlag,
+	                       &NumFiles, &FileName)) != false ||
+	    (NumFiles > 1 && !HelpFlag)) {
+		if (Error) {
+			GAPrintErrMsg(Error);
+		} else if (NumFiles > 1) {
+			GIF_MESSAGE("Error in command line parsing - one GIF "
+			            "file please.");
+		}
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_FAILURE);
+	}
+
+	if (HelpFlag) {
+		(void)fprintf(stderr, VersionStr, GIFLIB_MAJOR, GIFLIB_MINOR);
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_SUCCESS);
+	}
+
+	if (NumFiles == 1) {
+		if ((GifFileIn = DGifOpenFileName(*FileName, &ErrorCode)) ==
+		    NULL) {
+			PrintGifError(ErrorCode);
+			exit(EXIT_FAILURE);
+		}
+	} else {
+		/* Use stdin instead: */
+		if ((GifFileIn = DGifOpenFileHandle(0, &ErrorCode)) == NULL) {
+			PrintGifError(ErrorCode);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	for (i = 0; i < 256; i++) {
+		Histogram[i] = 0; /* Reset counters. */
+	}
+	/* Scan the content of the GIF file and load the image(s) in: */
+	do {
+		if (DGifGetRecordType(GifFileIn, &RecordType) == GIF_ERROR) {
+			QuitGifError(GifFileIn, GifFileOut);
+		}
+
+		switch (RecordType) {
+		case IMAGE_DESC_RECORD_TYPE:
+			if (DGifGetImageDesc(GifFileIn) == GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+
+			if (GifFileIn->Image.ColorMap) {
+				NumColors =
+				    GifFileIn->Image.ColorMap->ColorCount;
+			} else if (GifFileIn->SColorMap) {
+				NumColors = GifFileIn->SColorMap->ColorCount;
+			} else {
+				GIF_EXIT("Neither Screen nor Image color map "
+				         "exists.");
+			}
+
+			if ((ImageHeight / NumColors) * NumColors !=
+			    ImageHeight) {
+				GIF_EXIT("Image height specified not dividable "
+				         "by #colors.");
+			}
+
+			if (++ImageNum == ImageN) {
+				/* This is the image we should make histogram
+				 * for:       */
+				Line =
+				    (GifRowType)malloc(GifFileIn->Image.Width *
+				                       sizeof(GifPixelType));
+				GifQprintf(
+				    "\n%s: Image %d at (%d, %d) [%dx%d]:     ",
+				    PROGRAM_NAME, ImageNum,
+				    GifFileIn->Image.Left, GifFileIn->Image.Top,
+				    GifFileIn->Image.Width,
+				    GifFileIn->Image.Height);
+
+				for (i = 0; i < GifFileIn->Image.Height; i++) {
+					if (DGifGetLine(
+					        GifFileIn, Line,
+					        GifFileIn->Image.Width) ==
+					    GIF_ERROR) {
+						QuitGifError(GifFileIn,
+						             GifFileOut);
+					}
+					for (j = 0; j < GifFileIn->Image.Width;
+					     j++) {
+						Histogram[Line[j]]++;
+					}
+					GifQprintf("\b\b\b\b%-4d", i);
+				}
+
+				free((char *)Line);
+			} else {
+				/* Skip the image: */
+				/* Now read image itself in decoded form as we
+				 * dont      */
+				/* really care what is there, and this is much
+				 * faster.   */
+				if (DGifGetCode(GifFileIn, &CodeSize,
+				                &CodeBlock) == GIF_ERROR) {
+					QuitGifError(GifFileIn, GifFileOut);
+				}
+				while (CodeBlock != NULL) {
+					if (DGifGetCodeNext(GifFileIn,
+					                    &CodeBlock) ==
+					    GIF_ERROR) {
+						QuitGifError(GifFileIn,
+						             GifFileOut);
+					}
+				}
+			}
+			break;
+		case EXTENSION_RECORD_TYPE:
+			/* Skip any extension blocks in file: */
+			if (DGifGetExtension(GifFileIn, &ExtCode, &Extension) ==
+			    GIF_ERROR) {
+				QuitGifError(GifFileIn, GifFileOut);
+			}
+
+			while (Extension != NULL) {
+				if (DGifGetExtensionNext(
+				        GifFileIn, &Extension) == GIF_ERROR) {
+					QuitGifError(GifFileIn, GifFileOut);
+				}
+			}
+			break;
+		case TERMINATE_RECORD_TYPE:
+			break;
+		default: /* Should be trapped by DGifGetRecordType. */
+			break;
+		}
+	} while (RecordType != TERMINATE_RECORD_TYPE);
+
+	/* We requested suppression of the background count: */
+	if (BackGroundFlag) {
+		Histogram[GifFileIn->SBackGroundColor] = 0;
+	}
+
+	if (DGifCloseFile(GifFileIn, &ErrorCode) == GIF_ERROR) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+
+	/* We may required to dump out the histogram as text file: */
+	if (TextFlag) {
+		for (i = 0; i < NumColors; i++) {
+			printf("%12ld  %3d\n", Histogram[i], i);
+		}
+	} else {
+		int Color, Count;
+		long Scaler;
+		/* Open stdout for the histogram output file: */
+		if ((GifFileOut = EGifOpenFileHandle(1, &ErrorCode)) == NULL) {
+			PrintGifError(ErrorCode);
+			exit(EXIT_FAILURE);
+		}
+
+		/* Dump out screen descriptor to fit histogram dimensions: */
+		if (EGifPutScreenDesc(GifFileOut, ImageWidth, ImageHeight,
+		                      HISTO_BITS_PER_PIXEL, 0,
+		                      GifMakeMapObject(4, HistoColorMap)) ==
+		    GIF_ERROR) {
+			QuitGifError(GifFileIn, GifFileOut);
+		}
+
+		/* Dump out image descriptor to fit histogram dimensions: */
+		if (EGifPutImageDesc(GifFileOut, 0, 0, ImageWidth, ImageHeight,
+		                     false, NULL) == GIF_ERROR) {
+			QuitGifError(GifFileIn, GifFileOut);
+		}
+
+		/* Prepare scan line for histogram file, and find scaler to
+		 * scale    */
+		/* histogram to be between 0 and ImageWidth: */
+		Line = (GifRowType)malloc(ImageWidth * sizeof(GifPixelType));
+		for (Scaler = 0, i = 0; i < NumColors; i++) {
+			if (Histogram[i] > Scaler) {
+				Scaler = Histogram[i];
+			}
+		}
+		Scaler /= ImageWidth;
+		if (Scaler == 0) {
+			Scaler = 1; /* In case maximum is less than width. */
+		}
+		/* Dump out the image itself: */
+		for (Count = ImageHeight, i = 0, Color = 1; i < NumColors;
+		     i++) {
+			int Size;
+			if ((Size = Histogram[i] / Scaler) > ImageWidth) {
+				Size = ImageWidth;
+			}
+			for (j = 0; j < Size; j++) {
+				Line[j] = Color;
+			}
+			for (j = Size; j < ImageWidth; j++) {
+				Line[j] = GifFileOut->SBackGroundColor;
+			}
+
+			/* Move to next color: */
+			if (++Color >= (1 << HISTO_BITS_PER_PIXEL)) {
+				Color = 1;
+			}
+
+			/* Dump this histogram entry as many times as required:
+			 */
+			for (j = 0; j < ImageHeight / NumColors; j++) {
+				if (EGifPutLine(GifFileOut, Line, ImageWidth) ==
+				    GIF_ERROR) {
+					QuitGifError(GifFileIn, GifFileOut);
+				}
+				GifQprintf("\b\b\b\b%-4d", Count--);
+			}
+		}
+
+		if (EGifCloseFile(GifFileOut, &ErrorCode) == GIF_ERROR) {
+			PrintGifError(ErrorCode);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+ Close both input and output file (if open), and exit.
+******************************************************************************/
+static void QuitGifError(GifFileType *GifFileIn, GifFileType *GifFileOut) {
+	if (GifFileIn != NULL) {
+		PrintGifError(GifFileIn->Error);
+		EGifCloseFile(GifFileIn, NULL);
+	}
+	if (GifFileOut != NULL) {
+		PrintGifError(GifFileOut->Error);
+		EGifCloseFile(GifFileOut, NULL);
+	}
+	exit(EXIT_FAILURE);
+}
+
+/* end */
diff --git a/gifinto.c b/gifinto.c
new file mode 100644
index 0000000..07c85d3
--- /dev/null
+++ b/gifinto.c
@@ -0,0 +1,197 @@
+/*****************************************************************************
+
+gifinto - save GIF on stdin to file if size over set threshold
+
+SPDX-License-Identifier: MIT
+
+*****************************************************************************/
+
+#include <ctype.h>
+#include <fcntl.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef _WIN32
+#include <io.h>
+#else
+#include <unistd.h>
+#endif /* _WIN32 */
+
+#include "getarg.h"
+#include "gif_lib.h"
+
+#define PROGRAM_NAME "gifinto"
+
+#define STRLEN 512
+
+#define DEFAULT_MIN_FILE_SIZE 14 /* More than GIF stamp + screen desc. */
+#define DEFAULT_OUT_NAME "GifInto.Gif"
+#define DEFAULT_TMP_NAME "TempInto.XXXXXX"
+
+static char *VersionStr = PROGRAM_NAME VERSION_COOKIE
+    "	Gershon Elber,	" __DATE__ ",   " __TIME__ "\n"
+    "(C) Copyright 1989 Gershon Elber.\n";
+static char *CtrlStr = PROGRAM_NAME " v%- s%-MinFileSize!d h%- GifFile!*s";
+
+static int MinFileSize = DEFAULT_MIN_FILE_SIZE;
+
+#ifdef _WIN32
+#include <errno.h>
+#include <sys/stat.h>
+int mkstemp(char *tpl) {
+	int fd = -1;
+	char *p;
+	int e = errno;
+
+	errno = 0;
+	p = _mktemp(tpl);
+	if (*p && errno == 0) {
+		errno = e;
+		fd = _open(p, _O_RDWR | _O_CREAT | _O_EXCL | _O_BINARY,
+		           _S_IREAD | _S_IWRITE);
+	}
+	return fd;
+}
+#endif
+
+/******************************************************************************
+ This is simply: read until EOF, then close the output, test its length, and
+ if non zero then rename it.
+******************************************************************************/
+int main(int argc, char **argv) {
+	int FD;
+	int NumFiles;
+	bool Error, MinSizeFlag = false, HelpFlag = false,
+	            GifNoisyPrint = false;
+	char **FileName = NULL, FoutTmpName[STRLEN + 1], FullPath[STRLEN + 1],
+	     *p;
+	FILE *Fin, *Fout;
+
+	if ((Error = GAGetArgs(argc, argv, CtrlStr, &GifNoisyPrint,
+	                       &MinSizeFlag, &MinFileSize, &HelpFlag, &NumFiles,
+	                       &FileName)) != false ||
+	    (NumFiles > 1 && !HelpFlag)) {
+		if (Error) {
+			GAPrintErrMsg(Error);
+		} else if (NumFiles != 1) {
+			GIF_MESSAGE("Error in command line parsing - one GIF "
+			            "file please.");
+		}
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_FAILURE);
+	}
+
+	if (HelpFlag) {
+		(void)fprintf(stderr, VersionStr, GIFLIB_MAJOR, GIFLIB_MINOR);
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_SUCCESS);
+	}
+
+	/* Open the stdin in binary mode and increase its buffer size: */
+#ifdef _WIN32
+	_setmode(0, O_BINARY); /* Make sure it is in binary mode. */
+#endif
+
+	Fin = fdopen(0, "rb"); /* Make it into a stream: */
+
+	if (Fin == NULL) {
+		GIF_EXIT("Failed to open input.");
+	}
+
+	/* Isolate the directory where our destination is, and set tmp file name
+	 */
+	/* in the very same directory. This code is isecure because it creates
+	 */
+	/* predictable names, but it's not worth the effort and risk to fix. */
+	if (*FileName == NULL) {
+		GIF_EXIT("No valid Filename given.");
+	}
+	if (strlen(*FileName) > STRLEN - 1) {
+		GIF_EXIT("Filename too long.");
+	}
+	memset(FullPath, '\0', sizeof(FullPath));
+	strncpy(FullPath, *FileName, STRLEN);
+	if ((p = strrchr(FullPath, '/')) != NULL ||
+	    (p = strrchr(FullPath, '\\')) != NULL) {
+		p[1] = 0;
+	} else if ((p = strrchr(FullPath, ':')) != NULL) {
+		p[1] = 0;
+	} else {
+		FullPath[0] = 0; /* No directory or disk specified. */
+	}
+	if (strlen(FullPath) > STRLEN - 1) {
+		GIF_EXIT("Filename too long.");
+	}
+	strncpy(FoutTmpName, FullPath, STRLEN); /* First setup the Path */
+	/* then add a name for the tempfile */
+	if ((strlen(FoutTmpName) + strlen(DEFAULT_TMP_NAME)) > STRLEN - 1) {
+		GIF_EXIT("Filename too long.");
+	}
+	strcat(FoutTmpName, DEFAULT_TMP_NAME);
+#ifdef _WIN32
+	char *tmpFN = _mktemp(FoutTmpName);
+	if (tmpFN) {
+		FD = open(tmpFN, O_CREAT | O_EXCL | O_WRONLY);
+	} else {
+		FD = -1;
+	}
+#else
+	FD = mkstemp(FoutTmpName); /* returns filedescriptor */
+#endif
+	if (FD == -1) {
+		GIF_EXIT("Failed to open output.");
+	}
+	Fout = fdopen(FD, "wb"); /* returns a stream with FD */
+	if (Fout == NULL) {
+		GIF_EXIT("Failed to open output.");
+	}
+
+	while (1) {
+		int c = getc(Fin);
+
+		if (feof(Fin)) {
+			break;
+		}
+		if (putc(c, Fout) == EOF) {
+			GIF_EXIT("Failed to write output.");
+		}
+	}
+
+	fclose(Fin);
+	if (ftell(Fout) >= (long)MinFileSize) {
+		fclose(Fout);
+		unlink(*FileName);
+		if (rename(FoutTmpName, *FileName) != 0) {
+			char DefaultName[STRLEN + 1];
+			memset(DefaultName, '\0', sizeof(DefaultName));
+			if ((strlen(FullPath) + strlen(DEFAULT_OUT_NAME)) >
+			    STRLEN - 1) {
+				GIF_EXIT("Filename too long.");
+			}
+			strncpy(DefaultName, FullPath, STRLEN);
+			strcat(DefaultName, DEFAULT_OUT_NAME);
+			if (rename(FoutTmpName, DefaultName) == 0) {
+				char s[STRLEN];
+				snprintf(
+				    s, STRLEN,
+				    "Failed to rename out file - left as %s.",
+				    DefaultName);
+				GIF_MESSAGE(s);
+			} else {
+				unlink(FoutTmpName);
+				GIF_MESSAGE(
+				    "Failed to rename out file - deleted.");
+			}
+		}
+	} else {
+		fclose(Fout);
+		unlink(FoutTmpName);
+		GIF_MESSAGE("File too small - not renamed.");
+	}
+
+	return 0;
+}
+
+/* end */
diff --git a/gifsponge.c b/gifsponge.c
new file mode 100644
index 0000000..e018b9c
--- /dev/null
+++ b/gifsponge.c
@@ -0,0 +1,90 @@
+/****************************************************************************
+
+gifsponge.c - skeleton file for generic GIF `sponge' program
+
+Slurp a GIF into core, operate on it, spew it out again.  Most of the
+junk above `int main' isn't needed for the skeleton, but is likely to
+be for what you'll do with it.
+
+If you compile this, it will turn into an expensive GIF copying routine;
+stdin to stdout with no changes and minimal validation.  Well, it's a
+decent test of DGifSlurp() and EGifSpew(), anyway.
+
+Note: due to the vicissitudes of Lempel-Ziv compression, the output of this
+copier may not be bitwise identical to its input.  This can happen if you
+copy an image from a much more (or much *less*) memory-limited system; your
+compression may use more (or fewer) bits.  The uncompressed rasters should,
+however, be identical (you can check this with gifbuild -d).
+
+SPDX-License-Identifier: MIT
+
+****************************************************************************/
+
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "getarg.h"
+#include "gif_lib.h"
+
+#define PROGRAM_NAME "gifsponge"
+
+int main(int argc, char **argv) {
+	int i, ErrorCode;
+	GifFileType *GifFileIn, *GifFileOut = (GifFileType *)NULL;
+
+	if ((GifFileIn = DGifOpenFileHandle(0, &ErrorCode)) == NULL) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+	if (DGifSlurp(GifFileIn) == GIF_ERROR) {
+		PrintGifError(GifFileIn->Error);
+		exit(EXIT_FAILURE);
+	}
+	if ((GifFileOut = EGifOpenFileHandle(1, &ErrorCode)) == NULL) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+
+	/*
+	 * Your operations on in-core structures go here.
+	 * This code just copies the header and each image from the incoming
+	 * file.
+	 */
+	GifFileOut->SWidth = GifFileIn->SWidth;
+	GifFileOut->SHeight = GifFileIn->SHeight;
+	GifFileOut->SColorResolution = GifFileIn->SColorResolution;
+	GifFileOut->SBackGroundColor = GifFileIn->SBackGroundColor;
+	if (GifFileIn->SColorMap) {
+		GifFileOut->SColorMap =
+		    GifMakeMapObject(GifFileIn->SColorMap->ColorCount,
+		                     GifFileIn->SColorMap->Colors);
+	} else {
+		GifFileOut->SColorMap = NULL;
+	}
+
+	for (i = 0; i < GifFileIn->ImageCount; i++) {
+		(void)GifMakeSavedImage(GifFileOut, &GifFileIn->SavedImages[i]);
+	}
+
+	/*
+	 * Note: don't do DGifCloseFile early, as this will
+	 * deallocate all the memory containing the GIF data!
+	 *
+	 * Further note: EGifSpew() doesn't try to validity-check any of this
+	 * data; it's *your* responsibility to keep your changes consistent.
+	 * Caveat hacker!
+	 */
+	if (EGifSpew(GifFileOut) == GIF_ERROR) {
+		PrintGifError(GifFileOut->Error);
+	}
+
+	if (DGifCloseFile(GifFileIn, &ErrorCode) == GIF_ERROR) {
+		PrintGifError(ErrorCode);
+	}
+
+	return 0;
+}
+
+/* end */
diff --git a/giftext.c b/giftext.c
new file mode 100644
index 0000000..f085ed6
--- /dev/null
+++ b/giftext.c
@@ -0,0 +1,529 @@
+/*****************************************************************************
+
+giftext - dump GIF pixels and metadata as text
+
+SPDX-License-Identifier: MIT
+
+*****************************************************************************/
+
+#include <ctype.h>
+#include <fcntl.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#ifdef _WIN32
+#include <io.h>
+#endif /* _WIN32 */
+
+#include "getarg.h"
+#include "gif_lib.h"
+
+#define PROGRAM_NAME "giftext"
+
+#define MAKE_PRINTABLE(c) (isprint(c) ? (c) : ' ')
+
+static char *VersionStr = PROGRAM_NAME VERSION_COOKIE
+    "	Gershon Elber,	" __DATE__ ",   " __TIME__ "\n"
+    "(C) Copyright 1989 Gershon Elber.\n";
+static char *CtrlStr = PROGRAM_NAME " v%- c%- e%- z%- p%- r%- h%- GifFile!*s";
+
+static void PrintCodeBlock(GifFileType *GifFile, GifByteType *CodeBlock,
+                           bool Reset);
+static void PrintPixelBlock(GifByteType *PixelBlock, int Len, bool Reset);
+static void PrintExtBlock(GifByteType *Extension, bool Reset);
+static void PrintLZCodes(GifFileType *GifFile);
+
+/******************************************************************************
+ Interpret the command line and scan the given GIF file.
+******************************************************************************/
+int main(int argc, char **argv) {
+	int i, j, ExtCode, ErrorCode, CodeSize, NumFiles, Len, ImageNum = 1;
+	bool Error, ColorMapFlag = false, EncodedFlag = false,
+	            LZCodesFlag = false, PixelFlag = false, HelpFlag = false,
+	            RawFlag = false, GifNoisyPrint;
+	char *GifFileName, **FileName = NULL;
+	GifPixelType *Line;
+	GifRecordType RecordType;
+	GifByteType *CodeBlock, *Extension;
+	GifFileType *GifFile;
+
+	if ((Error =
+	         GAGetArgs(argc, argv, CtrlStr, &GifNoisyPrint, &ColorMapFlag,
+	                   &EncodedFlag, &LZCodesFlag, &PixelFlag, &RawFlag,
+	                   &HelpFlag, &NumFiles, &FileName)) != false ||
+	    (NumFiles > 1 && !HelpFlag)) {
+		if (Error) {
+			GAPrintErrMsg(Error);
+		} else if (NumFiles > 1) {
+			GIF_MESSAGE("Error in command line parsing - one GIF "
+			            "file please.");
+		}
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_FAILURE);
+	}
+
+	if (HelpFlag) {
+		(void)fprintf(stderr, VersionStr, GIFLIB_MAJOR, GIFLIB_MINOR);
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_SUCCESS);
+	}
+
+	if (NumFiles == 1) {
+		GifFileName = *FileName;
+		if ((GifFile = DGifOpenFileName(*FileName, &ErrorCode)) ==
+		    NULL) {
+			PrintGifError(ErrorCode);
+			exit(EXIT_FAILURE);
+		}
+	} else {
+		/* Use stdin instead: */
+		GifFileName = "Stdin";
+		if ((GifFile = DGifOpenFileHandle(0, &ErrorCode)) == NULL) {
+			PrintGifError(ErrorCode);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	/* Because we write binary data - make sure no text will be written. */
+	if (RawFlag) {
+		ColorMapFlag = EncodedFlag = LZCodesFlag = PixelFlag = false;
+#ifdef _WIN32
+		_setmode(1, O_BINARY); /* Make sure it is in binary mode. */
+#endif                                 /* _WIN32 */
+	} else {
+		printf("\n%s:\n\n\tScreen Size - Width = %d, Height = %d.\n",
+		       GifFileName, GifFile->SWidth, GifFile->SHeight);
+		printf("\tColorResolution = %d, BitsPerPixel = %d, BackGround "
+		       "= %d, Aspect = %d.\n",
+		       GifFile->SColorResolution,
+		       GifFile->SColorMap ? GifFile->SColorMap->BitsPerPixel
+		                          : 0,
+		       GifFile->SBackGroundColor, GifFile->AspectByte);
+		if (GifFile->SColorMap) {
+			printf("\tHas Global Color Map.\n\n");
+		} else {
+			printf("\tNo Global Color Map.\n\n");
+		}
+		if (ColorMapFlag && GifFile->SColorMap) {
+			printf("\tGlobal Color Map:\n");
+			Len = GifFile->SColorMap->ColorCount;
+			printf("\tSort Flag: %s\n",
+			       GifFile->SColorMap->SortFlag ? "on" : "off");
+			for (i = 0; i < Len; i += 4) {
+				for (j = 0; j < 4 && j < Len; j++) {
+					printf("%3d: %02xh %02xh %02xh   ",
+					       i + j,
+					       GifFile->SColorMap->Colors[i + j]
+					           .Red,
+					       GifFile->SColorMap->Colors[i + j]
+					           .Green,
+					       GifFile->SColorMap->Colors[i + j]
+					           .Blue);
+				}
+				printf("\n");
+			}
+		}
+	}
+
+	do {
+		if (DGifGetRecordType(GifFile, &RecordType) == GIF_ERROR) {
+			PrintGifError(GifFile->Error);
+			exit(EXIT_FAILURE);
+		}
+		switch (RecordType) {
+		case IMAGE_DESC_RECORD_TYPE:
+			if (DGifGetImageDesc(GifFile) == GIF_ERROR) {
+				PrintGifError(GifFile->Error);
+				exit(EXIT_FAILURE);
+			}
+			if (!RawFlag) {
+				printf(
+				    "\nImage #%d:\n\n\tImage Size - Left = %d, "
+				    "Top = %d, Width = %d, Height = %d.\n",
+				    ImageNum++, GifFile->Image.Left,
+				    GifFile->Image.Top, GifFile->Image.Width,
+				    GifFile->Image.Height);
+				printf("\tImage is %s", GifFile->Image.Interlace
+				                            ? "Interlaced"
+				                            : "Non Interlaced");
+				if (GifFile->Image.ColorMap != NULL) {
+					printf(", BitsPerPixel = %d.\n",
+					       GifFile->Image.ColorMap
+					           ->BitsPerPixel);
+				} else {
+					printf(".\n");
+				}
+				if (GifFile->Image.ColorMap) {
+					printf("\tImage Has Color Map.\n");
+				} else {
+					printf("\tNo Image Color Map.\n");
+				}
+				if (ColorMapFlag && GifFile->Image.ColorMap) {
+					printf("\tSort Flag: %s\n",
+					       GifFile->Image.ColorMap->SortFlag
+					           ? "on"
+					           : "off");
+					Len = 1 << GifFile->Image.ColorMap
+					               ->BitsPerPixel;
+					for (i = 0; i < Len; i += 4) {
+						for (j = 0; j < 4 && j < Len;
+						     j++) {
+							printf(
+							    "%3d: %02xh %02xh "
+							    "%02xh   ",
+							    i + j,
+							    GifFile->Image
+							        .ColorMap
+							        ->Colors[i + j]
+							        .Red,
+							    GifFile->Image
+							        .ColorMap
+							        ->Colors[i + j]
+							        .Green,
+							    GifFile->Image
+							        .ColorMap
+							        ->Colors[i + j]
+							        .Blue);
+						}
+						printf("\n");
+					}
+				}
+			}
+
+			if (EncodedFlag) {
+				if (DGifGetCode(GifFile, &CodeSize,
+				                &CodeBlock) == GIF_ERROR) {
+					PrintGifError(GifFile->Error);
+					exit(EXIT_FAILURE);
+				}
+				printf("\nImage LZ compressed Codes (Code Size "
+				       "= %d):\n",
+				       CodeSize);
+				PrintCodeBlock(GifFile, CodeBlock, true);
+				while (CodeBlock != NULL) {
+					if (DGifGetCodeNext(GifFile,
+					                    &CodeBlock) ==
+					    GIF_ERROR) {
+						PrintGifError(GifFile->Error);
+						exit(EXIT_FAILURE);
+					}
+					PrintCodeBlock(GifFile, CodeBlock,
+					               false);
+				}
+			} else if (LZCodesFlag) {
+				PrintLZCodes(GifFile);
+			} else if (PixelFlag) {
+				Line = (GifPixelType *)malloc(
+				    GifFile->Image.Width *
+				    sizeof(GifPixelType));
+				for (i = 0; i < GifFile->Image.Height; i++) {
+					if (DGifGetLine(GifFile, Line,
+					                GifFile->Image.Width) ==
+					    GIF_ERROR) {
+						PrintGifError(GifFile->Error);
+						exit(EXIT_FAILURE);
+					}
+					PrintPixelBlock(
+					    Line, GifFile->Image.Width, i == 0);
+				}
+				PrintPixelBlock(NULL, GifFile->Image.Width,
+				                false);
+				free((char *)Line);
+			} else if (RawFlag) {
+				Line = (GifPixelType *)malloc(
+				    GifFile->Image.Width *
+				    sizeof(GifPixelType));
+				for (i = 0; i < GifFile->Image.Height; i++) {
+					if (DGifGetLine(GifFile, Line,
+					                GifFile->Image.Width) ==
+					    GIF_ERROR) {
+						PrintGifError(GifFile->Error);
+						exit(EXIT_FAILURE);
+					}
+					fwrite(Line, 1, GifFile->Image.Width,
+					       stdout);
+				}
+				free((char *)Line);
+			} else {
+				/* Skip the image: */
+				if (DGifGetCode(GifFile, &CodeSize,
+				                &CodeBlock) == GIF_ERROR) {
+					PrintGifError(GifFile->Error);
+					exit(EXIT_FAILURE);
+				}
+				while (CodeBlock != NULL) {
+					if (DGifGetCodeNext(GifFile,
+					                    &CodeBlock) ==
+					    GIF_ERROR) {
+						PrintGifError(GifFile->Error);
+						exit(EXIT_FAILURE);
+					}
+				}
+			}
+			break;
+		case EXTENSION_RECORD_TYPE:
+			if (DGifGetExtension(GifFile, &ExtCode, &Extension) ==
+			    GIF_ERROR) {
+				PrintGifError(GifFile->Error);
+				exit(EXIT_FAILURE);
+			}
+			if (!RawFlag) {
+				putchar('\n');
+				switch (ExtCode) {
+				case COMMENT_EXT_FUNC_CODE:
+					printf("GIF89 comment");
+					break;
+				case GRAPHICS_EXT_FUNC_CODE:
+					printf("GIF89 graphics control");
+					break;
+				case PLAINTEXT_EXT_FUNC_CODE:
+					printf("GIF89 plaintext");
+					break;
+				case APPLICATION_EXT_FUNC_CODE:
+					printf("GIF89 application block");
+					break;
+				default:
+					printf(
+					    "Extension record of unknown type");
+					break;
+				}
+				printf(" (Ext Code = %d [%c]):\n", ExtCode,
+				       MAKE_PRINTABLE(ExtCode));
+				PrintExtBlock(Extension, true);
+
+				if (ExtCode == GRAPHICS_EXT_FUNC_CODE) {
+					GraphicsControlBlock gcb;
+					if (Extension == NULL) {
+						printf("Invalid extension "
+						       "block\n");
+						GifFile->Error =
+						    D_GIF_ERR_IMAGE_DEFECT;
+						PrintGifError(GifFile->Error);
+						exit(EXIT_FAILURE);
+					}
+					if (DGifExtensionToGCB(
+					        Extension[0], Extension + 1,
+					        &gcb) == GIF_ERROR) {
+						PrintGifError(GifFile->Error);
+						exit(EXIT_FAILURE);
+					}
+					printf("\tDisposal Mode: %d\n",
+					       gcb.DisposalMode);
+					printf("\tUser Input Flag: %d\n",
+					       gcb.UserInputFlag);
+					printf("\tTransparency on: %s\n",
+					       gcb.TransparentColor != -1
+					           ? "yes"
+					           : "no");
+					printf("\tDelayTime: %d\n",
+					       gcb.DelayTime);
+					printf("\tTransparent Index: %d\n",
+					       gcb.TransparentColor);
+				}
+			}
+			for (;;) {
+				if (DGifGetExtensionNext(GifFile, &Extension) ==
+				    GIF_ERROR) {
+					PrintGifError(GifFile->Error);
+					exit(EXIT_FAILURE);
+				}
+				if (Extension == NULL) {
+					break;
+				}
+				PrintExtBlock(Extension, false);
+			}
+			break;
+		case TERMINATE_RECORD_TYPE:
+			break;
+		default: /* Should be trapped by DGifGetRecordType */
+			break;
+		}
+	} while (RecordType != TERMINATE_RECORD_TYPE);
+
+	if (DGifCloseFile(GifFile, &ErrorCode) == GIF_ERROR) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+
+	if (!RawFlag) {
+		printf("\nGIF file terminated normally.\n");
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+ Print the given CodeBlock - a string in pascal notation (size in first
+ place). Save local information so printing can be performed continuously,
+ or reset to start state if Reset. If CodeBlock is NULL, output is flushed
+******************************************************************************/
+static void PrintCodeBlock(GifFileType *GifFile, GifByteType *CodeBlock,
+                           bool Reset) {
+	static int CrntPlace = 0;
+	static long CodeCount = 0;
+	int i, Len;
+
+	if (Reset || CodeBlock == NULL) {
+		if (CodeBlock == NULL) {
+			long NumBytes = 0;
+			if (CrntPlace > 0) {
+				printf("\n");
+				CodeCount += CrntPlace - 16;
+			}
+			if (GifFile->Image.ColorMap) {
+				NumBytes =
+				    ((((long)GifFile->Image.Width) *
+				      GifFile->Image.Height) *
+				     GifFile->Image.ColorMap->BitsPerPixel) /
+				    8;
+			} else if (GifFile->SColorMap != NULL) {
+				NumBytes = ((((long)GifFile->Image.Width) *
+				             GifFile->Image.Height) *
+				            GifFile->SColorMap->BitsPerPixel) /
+				           8;
+			}
+			/* FIXME: What should the compression ratio be if no
+			 * color table? */
+			if (NumBytes > 0) {
+				int Percent = 100 * CodeCount / NumBytes;
+				printf("\nCompression ratio: %ld/%ld (%d%%).\n",
+				       CodeCount, NumBytes, Percent);
+			}
+			return;
+		}
+		CrntPlace = 0;
+		CodeCount = 0;
+	}
+
+	// cppcheck-suppress nullPointerRedundantCheck
+	Len = CodeBlock[0];
+	for (i = 1; i <= Len; i++) {
+		if (CrntPlace == 0) {
+			printf("\n%05lxh:  ", CodeCount);
+			CodeCount += 16;
+		}
+		(void)printf(" %02xh", CodeBlock[i]);
+		if (++CrntPlace >= 16) {
+			CrntPlace = 0;
+		}
+	}
+}
+
+/******************************************************************************
+ Print the given Extension - a string in pascal notation (size in first
+ place). Save local information so printing can be performed continuously,
+ or reset to start state if Reset. If Extension is NULL, output is flushed
+******************************************************************************/
+static void PrintExtBlock(GifByteType *Extension, bool Reset) {
+	static int CrntPlace = 0;
+	static long ExtCount = 0;
+	static char HexForm[49], AsciiForm[17];
+
+	if (Reset || Extension == NULL) {
+		if (Extension == NULL) {
+			if (CrntPlace > 0) {
+				HexForm[CrntPlace * 3] = 0;
+				AsciiForm[CrntPlace] = 0;
+				printf("\n%05lx: %-49s  %-17s\n", ExtCount,
+				       HexForm, AsciiForm);
+				return;
+			} else {
+				printf("\n");
+			}
+		}
+		CrntPlace = 0;
+		ExtCount = 0;
+	}
+
+	if (Extension != NULL) {
+		int i, Len;
+		Len = Extension[0];
+		for (i = 1; i <= Len; i++) {
+			(void)snprintf(&HexForm[CrntPlace * 3], 3, " %02x",
+			               Extension[i]);
+			(void)snprintf(&AsciiForm[CrntPlace], 3, "%c",
+			               MAKE_PRINTABLE(Extension[i]));
+			if (++CrntPlace == 16) {
+				HexForm[CrntPlace * 3] = 0;
+				AsciiForm[CrntPlace] = 0;
+				printf("\n%05lx: %-49s  %-17s", ExtCount,
+				       HexForm, AsciiForm);
+				ExtCount += 16;
+				CrntPlace = 0;
+			}
+		}
+	}
+}
+
+/******************************************************************************
+ Print the given PixelBlock of length Len.
+ Save local information so printing can be performed continuously,
+ or reset to start state if Reset. If PixelBlock is NULL, output is flushed
+******************************************************************************/
+static void PrintPixelBlock(GifByteType *PixelBlock, int Len, bool Reset) {
+	static int CrntPlace = 0;
+	static long ExtCount = 0;
+	static char HexForm[49], AsciiForm[17];
+	int i;
+
+	if (Reset || PixelBlock == NULL) {
+		if (PixelBlock == NULL) {
+			if (CrntPlace > 0) {
+				HexForm[CrntPlace * 3] = 0;
+				AsciiForm[CrntPlace] = 0;
+				printf("\n%05lx: %-49s  %-17s\n", ExtCount,
+				       HexForm, AsciiForm);
+			} else {
+				printf("\n");
+			}
+		}
+		CrntPlace = 0;
+		ExtCount = 0;
+		if (PixelBlock == NULL) {
+			return;
+		}
+	}
+
+	for (i = 0; i < Len; i++) {
+		(void)snprintf(&HexForm[CrntPlace * 3], 3, " %02x",
+		               PixelBlock[i]);
+		(void)snprintf(&AsciiForm[CrntPlace], 3, "%c",
+		               MAKE_PRINTABLE(PixelBlock[i]));
+		if (++CrntPlace == 16) {
+			HexForm[CrntPlace * 3] = 0;
+			AsciiForm[CrntPlace] = 0;
+			printf("\n%05lx: %-49s  %-17s", ExtCount, HexForm,
+			       AsciiForm);
+			ExtCount += 16;
+			CrntPlace = 0;
+		}
+	}
+}
+
+/******************************************************************************
+ Print the image as LZ codes (each 12bits), until EOF marker is reached.
+******************************************************************************/
+static void PrintLZCodes(GifFileType *GifFile) {
+	int Code, CrntPlace = 0;
+	long CodeCount = 0;
+
+	do {
+		if (CrntPlace == 0) {
+			printf("\n%05lx:", CodeCount);
+		}
+		if (DGifGetLZCodes(GifFile, &Code) == GIF_ERROR) {
+			PrintGifError(GifFile->Error);
+			exit(EXIT_FAILURE);
+		}
+		if (Code >= 0) {
+			printf(" %03x", Code); /* EOF Code is returned as -1. */
+		}
+		CodeCount++;
+		if (++CrntPlace >= 16) {
+			CrntPlace = 0;
+		}
+	} while (Code >= 0);
+}
+
+/* end */
diff --git a/giftool.c b/giftool.c
new file mode 100644
index 0000000..fc068ce
--- /dev/null
+++ b/giftool.c
@@ -0,0 +1,650 @@
+/****************************************************************************
+
+giftool.c - GIF transformation tool.
+
+SPDX-License-Identifier: MIT
+
+****************************************************************************/
+
+#include <fcntl.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "getarg.h"
+#include "getopt.h"
+#include "gif_lib.h"
+
+#define PROGRAM_NAME "giftool"
+
+#define MAX_OPERATIONS 256
+#define MAX_IMAGES 2048
+
+enum boolmode { numeric, onoff, tf, yesno };
+
+char *putbool(bool flag, enum boolmode mode) {
+	if (flag) {
+		switch (mode) {
+		case numeric:
+			return "1";
+			break;
+		case onoff:
+			return "on";
+			break;
+		case tf:
+			return "true";
+			break;
+		case yesno:
+			return "yes";
+			break;
+		}
+	} else {
+		switch (mode) {
+		case numeric:
+			return "0";
+			break;
+		case onoff:
+			return "off";
+			break;
+		case tf:
+			return "false";
+			break;
+		case yesno:
+			return "no";
+			break;
+		}
+	}
+
+	return "FAIL"; /* should never happen */
+}
+
+bool getbool(char *from) {
+	struct valmap {
+		char *name;
+		bool val;
+	} boolnames[] =
+	    {
+	        {"yes", true}, {"on", true},  {"1", true},
+	        {"t", true},   {"no", false}, {"off", false},
+	        {"0", false},  {"f", false},  {NULL, false},
+	    },
+	  *sp;
+
+	// cppcheck-suppress nullPointerRedundantCheck
+	for (sp = boolnames; sp->name; sp++) {
+		if (strcmp(sp->name, from) == 0) {
+			return sp->val;
+		}
+	}
+
+	if (sp == NULL) {
+		(void)fprintf(stderr,
+		              "giftool: %s is not a valid boolean argument.\n",
+		              // cppcheck-suppress nullPointerRedundantCheck
+		              sp->name);
+	}
+	exit(EXIT_FAILURE);
+}
+
+struct operation {
+	enum {
+		aspect,
+		delaytime,
+		background,
+		info,
+		interlace,
+		position,
+		screensize,
+		transparent,
+		userinput,
+		disposal,
+	} mode;
+	union {
+		GifByteType numerator;
+		int delay;
+		int color;
+		int dispose;
+		char *format;
+		bool flag;
+		struct {
+			int x, y;
+		} p;
+	};
+};
+
+int main(int argc, char **argv) {
+	extern char *optarg; /* set by getopt */
+	extern int optind;   /* set by getopt */
+	struct operation operations[MAX_OPERATIONS];
+	struct operation *top = operations;
+	int selected[MAX_IMAGES], nselected = 0;
+	bool have_selection = false;
+	char *cp;
+	int i, status, ErrorCode;
+	GifFileType *GifFileIn, *GifFileOut = (GifFileType *)NULL;
+	struct operation *op;
+
+	/*
+	 * Gather operations from the command line.  We use regular
+	 * getopt(3) here rather than Gershom's argument getter because
+	 * preserving the order of operations is important.
+	 */
+	while ((status = getopt(argc, argv, "a:b:d:f:i:n:p:s:u:x:")) != EOF) {
+		if (top >= operations + MAX_OPERATIONS) {
+			(void)fprintf(stderr, "giftool: too many operations.");
+			exit(EXIT_FAILURE);
+		}
+
+		switch (status) {
+		case 'a':
+			top->mode = aspect;
+			top->numerator = (GifByteType)atoi(optarg);
+			break;
+
+		case 'b':
+			top->mode = background;
+			top->color = atoi(optarg);
+			break;
+
+		case 'd':
+			top->mode = delaytime;
+			top->delay = atoi(optarg);
+			break;
+
+		case 'f':
+			top->mode = info;
+			top->format = optarg;
+			break;
+
+		case 'i':
+			top->mode = interlace;
+			top->flag = getbool(optarg);
+			break;
+
+		case 'n':
+			have_selection = true;
+			nselected = 0;
+			cp = optarg;
+			for (;;) {
+				size_t span = strspn(cp, "0123456789");
+
+				if (span > 0) {
+					selected[nselected++] = atoi(cp) - 1;
+					cp += span;
+					if (*cp == '\0') {
+						break;
+					} else if (*cp == ',') {
+						continue;
+					}
+				}
+
+				(void)fprintf(stderr,
+				              "giftool: bad selection.\n");
+				exit(EXIT_FAILURE);
+			}
+			break;
+
+		case 'p':
+		case 's':
+			if (status == 'p') {
+				top->mode = position;
+			} else {
+				top->mode = screensize;
+			}
+			cp = strchr(optarg, ',');
+			if (cp == NULL) {
+				(void)fprintf(stderr, "giftool: missing comma "
+				                      "in coordinate pair.\n");
+				exit(EXIT_FAILURE);
+			}
+			top->p.x = atoi(optarg);
+			top->p.y = atoi(cp + 1);
+			if (top->p.x < 0 || top->p.y < 0) {
+				(void)fprintf(
+				    stderr, "giftool: negative coordinate.\n");
+				exit(EXIT_FAILURE);
+			}
+			break;
+
+		case 'u':
+			top->mode = userinput;
+			top->flag = getbool(optarg);
+			break;
+
+		case 'x':
+			top->mode = disposal;
+			top->dispose = atoi(optarg);
+			break;
+
+		default:
+			fprintf(stderr,
+			        "usage: giftool [-b color] [-d delay] [-iI] "
+			        "[-t color] -[uU] [-x disposal]\n");
+			break;
+		}
+
+		++top;
+	}
+
+	/* read in a GIF */
+	if ((GifFileIn = DGifOpenFileHandle(0, &ErrorCode)) == NULL) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+	if (DGifSlurp(GifFileIn) == GIF_ERROR) {
+		PrintGifError(GifFileIn->Error);
+		exit(EXIT_FAILURE);
+	}
+	if ((GifFileOut = EGifOpenFileHandle(1, &ErrorCode)) == NULL) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+
+	/* if the selection is defaulted, compute it; otherwise bounds-check it
+	 */
+	if (!have_selection) {
+		for (i = nselected = 0; i < GifFileIn->ImageCount; i++) {
+			selected[nselected++] = i;
+		}
+	} else {
+		for (i = 0; i < nselected; i++) {
+			if (selected[i] >= GifFileIn->ImageCount ||
+			    selected[i] < 0) {
+				(void)fprintf(stderr, "giftool: selection "
+				                      "index out of bounds.\n");
+				exit(EXIT_FAILURE);
+			}
+		}
+	}
+
+	/* perform the operations we've gathered */
+	for (op = operations; op < top; op++) {
+		switch (op->mode) {
+		case background:
+			GifFileIn->SBackGroundColor = op->color;
+			break;
+
+		case delaytime:
+			for (i = 0; i < nselected; i++) {
+				GraphicsControlBlock gcb;
+
+				DGifSavedExtensionToGCB(GifFileIn, selected[i],
+				                        &gcb);
+				gcb.DelayTime = op->delay;
+				EGifGCBToSavedExtension(&gcb, GifFileIn,
+				                        selected[i]);
+			}
+			break;
+
+		case info:
+			for (i = 0; i < nselected; i++) {
+				SavedImage *ip =
+				    &GifFileIn->SavedImages[selected[i]];
+				GraphicsControlBlock gcb;
+				for (cp = op->format; *cp; cp++) {
+					if (*cp == '\\') {
+						char c;
+						switch (*++cp) {
+						case 'b':
+							(void)putchar('\b');
+							break;
+						case 'e':
+							(void)putchar(0x1b);
+							break;
+						case 'f':
+							(void)putchar('\f');
+							break;
+						case 'n':
+							(void)putchar('\n');
+							break;
+						case 'r':
+							(void)putchar('\r');
+							break;
+						case 't':
+							(void)putchar('\t');
+							break;
+						case 'v':
+							(void)putchar('\v');
+							break;
+						case 'x':
+							switch (*++cp) {
+							case '0':
+								c = (char)0x00;
+								break;
+							case '1':
+								c = (char)0x10;
+								break;
+							case '2':
+								c = (char)0x20;
+								break;
+							case '3':
+								c = (char)0x30;
+								break;
+							case '4':
+								c = (char)0x40;
+								break;
+							case '5':
+								c = (char)0x50;
+								break;
+							case '6':
+								c = (char)0x60;
+								break;
+							case '7':
+								c = (char)0x70;
+								break;
+							case '8':
+								c = (char)0x80;
+								break;
+							case '9':
+								c = (char)0x90;
+								break;
+							case 'A':
+							case 'a':
+								c = (char)0xa0;
+								break;
+							case 'B':
+							case 'b':
+								c = (char)0xb0;
+								break;
+							case 'C':
+							case 'c':
+								c = (char)0xc0;
+								break;
+							case 'D':
+							case 'd':
+								c = (char)0xd0;
+								break;
+							case 'E':
+							case 'e':
+								c = (char)0xe0;
+								break;
+							case 'F':
+							case 'f':
+								c = (char)0xf0;
+								break;
+							default:
+								return -1;
+							}
+							switch (*++cp) {
+							case '0':
+								c += 0x00;
+								break;
+							case '1':
+								c += 0x01;
+								break;
+							case '2':
+								c += 0x02;
+								break;
+							case '3':
+								c += 0x03;
+								break;
+							case '4':
+								c += 0x04;
+								break;
+							case '5':
+								c += 0x05;
+								break;
+							case '6':
+								c += 0x06;
+								break;
+							case '7':
+								c += 0x07;
+								break;
+							case '8':
+								c += 0x08;
+								break;
+							case '9':
+								c += 0x09;
+								break;
+							case 'A':
+							case 'a':
+								c += 0x0a;
+								break;
+							case 'B':
+							case 'b':
+								c += 0x0b;
+								break;
+							case 'C':
+							case 'c':
+								c += 0x0c;
+								break;
+							case 'D':
+							case 'd':
+								c += 0x0d;
+								break;
+							case 'E':
+							case 'e':
+								c += 0x0e;
+								break;
+							case 'F':
+							case 'f':
+								c += 0x0f;
+								break;
+							default:
+								return -2;
+							}
+							putchar(c);
+							break;
+						default:
+							putchar(*cp);
+							break;
+						}
+					} else if (*cp == '%') {
+						enum boolmode boolfmt;
+						SavedImage *sp =
+						    &GifFileIn->SavedImages[i];
+
+						if (cp[1] == 't') {
+							boolfmt = tf;
+							++cp;
+						} else if (cp[1] == 'o') {
+							boolfmt = onoff;
+							++cp;
+						} else if (cp[1] == 'y') {
+							boolfmt = yesno;
+							++cp;
+						} else if (cp[1] == '1') {
+							boolfmt = numeric;
+							++cp;
+						} else {
+							boolfmt = numeric;
+						}
+
+						switch (*++cp) {
+						case '%':
+							putchar('%');
+							break;
+						case 'a':
+							(void)printf(
+							    "%d",
+							    GifFileIn
+							        ->AspectByte);
+							break;
+						case 'b':
+							(void)printf(
+							    "%d",
+							    GifFileIn
+							        ->SBackGroundColor);
+							break;
+						case 'd':
+							DGifSavedExtensionToGCB(
+							    GifFileIn,
+							    selected[i], &gcb);
+							(void)printf(
+							    "%d",
+							    gcb.DelayTime);
+							break;
+						case 'h':
+							(void)printf(
+							    "%d", ip->ImageDesc
+							              .Height);
+							break;
+						case 'n':
+							(void)printf(
+							    "%d",
+							    selected[i] + 1);
+							break;
+						case 'p':
+							(void)printf(
+							    "%d,%d",
+							    ip->ImageDesc.Left,
+							    ip->ImageDesc.Top);
+							break;
+						case 's':
+							(void)printf(
+							    "%d,%d",
+							    GifFileIn->SWidth,
+							    GifFileIn->SHeight);
+							break;
+						case 'w':
+							(void)printf(
+							    "%d", ip->ImageDesc
+							              .Width);
+							break;
+						case 't':
+							DGifSavedExtensionToGCB(
+							    GifFileIn,
+							    selected[i], &gcb);
+							(void)printf(
+							    "%d",
+							    gcb.TransparentColor);
+							break;
+						case 'u':
+							DGifSavedExtensionToGCB(
+							    GifFileIn,
+							    selected[i], &gcb);
+							(void)printf(
+							    "%s",
+							    putbool(
+							        gcb.UserInputFlag,
+							        boolfmt));
+							break;
+						case 'v':
+							fputs(EGifGetGifVersion(
+							          GifFileIn),
+							      stdout);
+							break;
+						case 'x':
+							DGifSavedExtensionToGCB(
+							    GifFileIn,
+							    selected[i], &gcb);
+							(void)printf(
+							    "%d",
+							    gcb.DisposalMode);
+							break;
+						case 'z':
+							(void)printf(
+							    "%s",
+							    putbool(
+							        sp->ImageDesc
+							                .ColorMap &&
+							            sp->ImageDesc
+							                .ColorMap
+							                ->SortFlag,
+							        boolfmt));
+							break;
+						default:
+							(void)fprintf(
+							    stderr,
+							    "giftool: bad "
+							    "format %%%c\n",
+							    *cp);
+						}
+					} else {
+						(void)putchar(*cp);
+					}
+				}
+			}
+			exit(EXIT_SUCCESS);
+			break;
+
+		case interlace:
+			for (i = 0; i < nselected; i++) {
+				GifFileIn->SavedImages[selected[i]]
+				    .ImageDesc.Interlace = op->flag;
+			}
+			break;
+
+		case position:
+			for (i = 0; i < nselected; i++) {
+				GifFileIn->SavedImages[selected[i]]
+				    .ImageDesc.Left = op->p.x;
+				GifFileIn->SavedImages[selected[i]]
+				    .ImageDesc.Top = op->p.y;
+			}
+			break;
+
+		case screensize:
+			GifFileIn->SWidth = op->p.x;
+			GifFileIn->SHeight = op->p.y;
+			break;
+
+		case transparent:
+			for (i = 0; i < nselected; i++) {
+				GraphicsControlBlock gcb;
+
+				DGifSavedExtensionToGCB(GifFileIn, selected[i],
+				                        &gcb);
+				gcb.TransparentColor = op->color;
+				EGifGCBToSavedExtension(&gcb, GifFileIn,
+				                        selected[i]);
+			}
+			break;
+
+		case userinput:
+			for (i = 0; i < nselected; i++) {
+				GraphicsControlBlock gcb;
+
+				DGifSavedExtensionToGCB(GifFileIn, selected[i],
+				                        &gcb);
+				gcb.UserInputFlag = op->flag;
+				EGifGCBToSavedExtension(&gcb, GifFileIn,
+				                        selected[i]);
+			}
+			break;
+
+		case disposal:
+			for (i = 0; i < nselected; i++) {
+				GraphicsControlBlock gcb;
+
+				DGifSavedExtensionToGCB(GifFileIn, selected[i],
+				                        &gcb);
+				gcb.DisposalMode = op->dispose;
+				EGifGCBToSavedExtension(&gcb, GifFileIn,
+				                        selected[i]);
+			}
+			break;
+
+		default:
+			(void)fprintf(stderr,
+			              "giftool: unknown operation mode\n");
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	/* write out the results */
+	GifFileOut->SWidth = GifFileIn->SWidth;
+	GifFileOut->SHeight = GifFileIn->SHeight;
+	GifFileOut->SColorResolution = GifFileIn->SColorResolution;
+	GifFileOut->SBackGroundColor = GifFileIn->SBackGroundColor;
+	if (GifFileIn->SColorMap != NULL) {
+		GifFileOut->SColorMap =
+		    GifMakeMapObject(GifFileIn->SColorMap->ColorCount,
+		                     GifFileIn->SColorMap->Colors);
+	}
+
+	for (i = 0; i < GifFileIn->ImageCount; i++) {
+		(void)GifMakeSavedImage(GifFileOut, &GifFileIn->SavedImages[i]);
+	}
+
+	if (EGifSpew(GifFileOut) == GIF_ERROR) {
+		PrintGifError(GifFileOut->Error);
+	} else if (DGifCloseFile(GifFileIn, &ErrorCode) == GIF_ERROR) {
+		PrintGifError(ErrorCode);
+	}
+
+	return 0;
+}
+
+/* end */
diff --git a/gifwedge.c b/gifwedge.c
new file mode 100644
index 0000000..203d5da
--- /dev/null
+++ b/gifwedge.c
@@ -0,0 +1,153 @@
+/*****************************************************************************
+
+gifwedge - create a GIF test pattern
+
+SPDX-License-Identifier: MIT
+
+*****************************************************************************/
+
+#include <ctype.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "getarg.h"
+#include "gif_lib.h"
+
+#define PROGRAM_NAME "gifwedge"
+
+#define DEFAULT_WIDTH 640
+#define DEFAULT_HEIGHT 350
+
+#define DEFAULT_NUM_LEVELS 16 /* Number of colors to gen the image. */
+
+static char *VersionStr = PROGRAM_NAME VERSION_COOKIE
+    "	Gershon Elber,	" __DATE__ ",   " __TIME__ "\n"
+    "(C) Copyright 1989 Gershon Elber.\n";
+static char *CtrlStr = PROGRAM_NAME " v%- l%-#Lvls!d s%-Width|Height!d!d h%-";
+
+static int NumLevels = DEFAULT_NUM_LEVELS, ImageWidth = DEFAULT_WIDTH,
+           ImageHeight = DEFAULT_HEIGHT;
+
+/******************************************************************************
+ Interpret the command line and scan the given GIF file.
+******************************************************************************/
+int main(int argc, char **argv) {
+	int i, j, l, c, LevelStep, LogNumLevels, ErrorCode, Count = 0;
+	bool Error, LevelsFlag = false, SizeFlag = false, HelpFlag = false,
+	            GifNoisyPrint = false;
+	GifRowType Line;
+	ColorMapObject *ColorMap;
+	GifFileType *GifFile;
+
+	if ((Error = GAGetArgs(argc, argv, CtrlStr, &GifNoisyPrint, &LevelsFlag,
+	                       &NumLevels, &SizeFlag, &ImageWidth, &ImageHeight,
+	                       &HelpFlag)) != false) {
+		GAPrintErrMsg(Error);
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_FAILURE);
+	}
+
+	if (HelpFlag) {
+		(void)fprintf(stderr, VersionStr, GIFLIB_MAJOR, GIFLIB_MINOR);
+		GAPrintHowTo(CtrlStr);
+		exit(EXIT_SUCCESS);
+	}
+
+	/* Make sure the number of levels is power of 2 (up to 32 levels.). */
+	for (i = 1; i < 6; i++) {
+		if (NumLevels == (1 << i)) {
+			break;
+		}
+	}
+	if (i == 6) {
+		GIF_EXIT("#Lvls (-l option) is not power of 2 up to 32.");
+	}
+	LogNumLevels = i + 3; /* Multiple by 8 (see below). */
+	LevelStep = 256 / NumLevels;
+
+	/* Make sure the image dimension is a multiple of NumLevels horizontally
+	 */
+	/* and 7 (White, Red, Green, Blue and Yellow Cyan Magenta) vertically.
+	 */
+	ImageWidth = (ImageWidth / NumLevels) * NumLevels;
+	ImageHeight = (ImageHeight / 7) * 7;
+
+	/* Open stdout for the output file: */
+	if ((GifFile = EGifOpenFileHandle(1, &ErrorCode)) == NULL) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+
+	/* Dump out screen description with given size and generated color map:
+	 */
+	/* The color map has 7 NumLevels colors for White, Red, Green and then
+	 */
+	/* The secondary colors Yellow Cyan and magenta. */
+	if ((ColorMap = GifMakeMapObject(8 * NumLevels, NULL)) == NULL) {
+		GIF_EXIT("Failed to allocate memory required, aborted.");
+	}
+
+	for (i = 0; i < 8; i++) { /* Set color map. */
+		for (j = 0; j < NumLevels; j++) {
+			l = LevelStep * j;
+			c = i * NumLevels + j;
+			ColorMap->Colors[c].Red =
+			    (i == 0 || i == 1 || i == 4 || i == 6) * l;
+			ColorMap->Colors[c].Green =
+			    (i == 0 || i == 2 || i == 4 || i == 5) * l;
+			ColorMap->Colors[c].Blue =
+			    (i == 0 || i == 3 || i == 5 || i == 6) * l;
+		}
+	}
+
+	if (EGifPutScreenDesc(GifFile, ImageWidth, ImageHeight, LogNumLevels, 0,
+	                      ColorMap) == GIF_ERROR) {
+		PrintGifError(GifFile->Error);
+	}
+
+	/* Dump out the image descriptor: */
+	if (EGifPutImageDesc(GifFile, 0, 0, ImageWidth, ImageHeight, false,
+	                     NULL) == GIF_ERROR) {
+
+		PrintGifError(GifFile->Error);
+		exit(EXIT_FAILURE);
+	}
+
+	GifQprintf("\n%s: Image 1 at (%d, %d) [%dx%d]:     ", PROGRAM_NAME,
+	           GifFile->Image.Left, GifFile->Image.Top,
+	           GifFile->Image.Width, GifFile->Image.Height);
+
+	/* Allocate one scan line to be used for all image. */
+	if ((Line = (GifRowType)malloc(sizeof(GifPixelType) * ImageWidth)) ==
+	    NULL) {
+		GIF_EXIT("Failed to allocate memory required, aborted.");
+	}
+
+	/* Dump the pixels: */
+	for (c = 0; c < 7; c++) {
+		for (i = 0, l = 0; i < NumLevels; i++) {
+			for (j = 0; j < ImageWidth / NumLevels; j++) {
+				Line[l++] = i + NumLevels * c;
+			}
+		}
+		for (i = 0; i < ImageHeight / 7; i++) {
+			if (EGifPutLine(GifFile, Line, ImageWidth) ==
+			    GIF_ERROR) {
+				PrintGifError(GifFile->Error);
+				exit(EXIT_FAILURE);
+			}
+			GifQprintf("\b\b\b\b%-4d", Count++);
+		}
+	}
+
+	if (EGifCloseFile(GifFile, &ErrorCode) == GIF_ERROR) {
+		PrintGifError(ErrorCode);
+		exit(EXIT_FAILURE);
+	}
+
+	return 0;
+}
+
+/* end */
diff --git a/history.adoc b/history.adoc
new file mode 100644
index 0000000..31f7e4a
--- /dev/null
+++ b/history.adoc
@@ -0,0 +1,75 @@
+= History of GIFLIB =
+
+GIF (Graphics Interchange Format) was originally developed on the
+CompuServe timesharing service in the late 1980s.  It was described
+by a GIF standard issued in 1987 and revised in 1989.  A copy of the
+GIF89 standard is included in the doc/ directory.
+
+This code originated as a linkable library for DOS programs, together
+with command-line tools for generating and viewing and analyzing GIF
+images. The DOS code was written by Gershon Elber using Borland C
+under MS-DOS sometime between the issue of GIF87 and mid-1989 (1.0 was
+dated 14 June 1989; one portion, getarg.c, was dated 11 Mar 88).
+
+At some time no later than the end of 1989 Eric S. Raymond (aka "ESR")
+ported this DOS version to System V Unix. Between 1989 and 1992 ESR
+reworked various portions of the API, improving and simplifying 
+the code's interface.
+
+ESR's 2.1 version was the first to include the DGifSlurp()/EGifSpew()
+function pair for enabling non-sequential operations on GIF images
+(also the tools icon2gif, gifovly, and gifcompose; the last was
+removed in 5.0).
+
+ESR's Unix port was incorporated into the NCSA Mosaic browser in 1994,
+which is how GIF became (with JPEG) one of the two most popular image
+formats on the early Web.
+
+Beginning around 1993, patent claims by Unisys over the LZW
+compression method used in GIF theatened adverse legal consequences
+for users and developers of programs incorporating the format. The
+threats became serious in 1999, with Unisys demanding license fees
+for any software using the format.
+
+One response to this was the development of PNG in 1995. Another was
+that ESR sought a lead developer outside the U.S. to hand the project off 
+to, and passed it to Toshio Kuratomi.  ESR remembers this as happening
+in 1994, but that date could be wrong as some headers imply 3.0 was issued
+under  ESR's name in 1996.  But other files do date Toshio's first release
+to 1994.  Toshio shipped 4.0 in December 1998.
+
+Subsequently, the project shipped for some time as "libungif" with
+support for compressed GIFs removed to avoid the LZW patent issues.
+Compression support was merged back in after the last blocking patent
+expired in 2004; this became release 4.0.0.  After that merge the
+code was again known as giflib.
+
+By 2006, support for PNGs was sufficiently universal that GIF could be
+described as a legacy format.  Anything you can do with it GIF could
+probably be better done with PNG. Nevertheless (and despite efforts
+like "Burn All GIFs Day" in November 1999) the GIF format has remained
+widely popular.
+
+In April 2012 ESR rejoined the project to do some code cleanups 
+and auditing, and Toshio Kuratomi asked him to take back the lead.
+ESR released version 4.2 in May 2012.
+
+Version 5.0, released in June 2012, fulfilled almost all the to-do
+items from 18 years of backlog.  It made the library thread-safe, added
+direct support for GIF89 graphics control blocks, and tossed out large
+amounts of obsolete utility code.
+
+More recent version of the code (5.1.0 and onwards) have been hardened
+by both static analysis and fuzz testing.  While these failed to turn
+up bugs in normal rendering cases, they did uncover some crash and
+corruption bugs that could be tickled by carefully crafted malformed
+GIFs.
+
+This code is very old, very stable, and *everywhere* - browsers
+game consoles, smartphones, pretty much everything that opens an
+HTTP port and does graphics uses it.
+
+The utilities in this source tree were important as GIF production
+tools early in the format's history, but have been superseded by
+multi-format viewers and editors.  Most installable binary packages
+shipped as 'giflib' include the library and header file only.
diff --git a/openbsd-reallocarray.c b/openbsd-reallocarray.c
index aa70686..5f5367c 100644
--- a/openbsd-reallocarray.c
+++ b/openbsd-reallocarray.c
@@ -1,38 +1,73 @@
-/*	$OpenBSD: reallocarray.c,v 1.1 2014/05/08 21:43:49 deraadt Exp $	*/
 /*
  * Copyright (c) 2008 Otto Moerbeek <otto@drijf.net>
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * SPDX-License-Identifier: MIT
  */
 
-#include <sys/types.h>
 #include <errno.h>
 #include <stdint.h>
 #include <stdlib.h>
+#include <sys/types.h>
+
+#ifndef SIZE_MAX
+#define SIZE_MAX UINTPTR_MAX
+#endif
 
 /*
  * This is sqrt(SIZE_MAX+1), as s1*s2 <= SIZE_MAX
  * if both s1 < MUL_NO_OVERFLOW and s2 < MUL_NO_OVERFLOW
  */
-#define MUL_NO_OVERFLOW	((size_t)1 << (sizeof(size_t) * 4))
+#define MUL_NO_OVERFLOW ((size_t)1 << (sizeof(size_t) * 4))
 
-void *
-reallocarray(void *optr, size_t nmemb, size_t size)
-{
+void *openbsd_reallocarray(void *optr, size_t nmemb, size_t size) {
 	if ((nmemb >= MUL_NO_OVERFLOW || size >= MUL_NO_OVERFLOW) &&
 	    nmemb > 0 && SIZE_MAX / nmemb < size) {
 		errno = ENOMEM;
 		return NULL;
 	}
+	/*
+	 * Head off variations in realloc behavior on different
+	 * platforms (reported by MarkR <mrogers6@users.sf.net>)
+	 *
+	 * The behaviour of reallocarray is implementation-defined if
+	 * nmemb or size is zero. It can return NULL or non-NULL
+	 * depending on the platform.
+	 * https://www.securecoding.cert.org/confluence/display/c/MEM04-C.Beware+of+zero-lengthallocations
+	 *
+	 * Here are some extracts from realloc man pages on different platforms.
+	 *
+	 * void realloc( void memblock, size_t size );
+	 *
+	 * Windows:
+	 *
+	 * If there is not enough available memory to expand the block
+	 * to the given size, the original block is left unchanged,
+	 * and NULL is returned.  If size is zero, then the block
+	 * pointed to by memblock is freed; the return value is NULL,
+	 * and memblock is left pointing at a freed block.
+	 *
+	 * OpenBSD:
+	 *
+	 * If size or nmemb is equal to 0, a unique pointer to an
+	 * access protected, zero sized object is returned. Access via
+	 * this pointer will generate a SIGSEGV exception.
+	 *
+	 * Linux:
+	 *
+	 * If size was equal to 0, either NULL or a pointer suitable
+	 * to be passed to free() is returned.
+	 *
+	 * OS X:
+	 *
+	 * If size is zero and ptr is not NULL, a new, minimum sized
+	 * object is allocated and the original object is freed.
+	 *
+	 * It looks like images with zero width or height can trigger
+	 * this, and fuzzing behaviour will differ by platform, so
+	 * fuzzing on one platform may not detect zero-size allocation
+	 * problems on other platforms.
+	 */
+	if (size == 0 || nmemb == 0) {
+		return NULL;
+	}
 	return realloc(optr, size * nmemb);
 }
diff --git a/pic/NOTES b/pic/NOTES
new file mode 100644
index 0000000..f9b2b90
--- /dev/null
+++ b/pic/NOTES
@@ -0,0 +1,6 @@
+Gershon wrote:
+
+Only one of the images on .\pic was actually generated by me -
+solid2.gif, which is binary image rendered using a solid modeller I have
+developed named IRIT. The other two were released to usenet few month ago.
+I do not think so, but let me know if I violate anything here.
diff --git a/pic/fire.gif b/pic/fire.gif
new file mode 100644
index 0000000..c9265fa
Binary files /dev/null and b/pic/fire.gif differ
diff --git a/pic/gifgrid.gif b/pic/gifgrid.gif
new file mode 100644
index 0000000..777c267
Binary files /dev/null and b/pic/gifgrid.gif differ
diff --git a/pic/porsche.gif b/pic/porsche.gif
new file mode 100644
index 0000000..916014e
Binary files /dev/null and b/pic/porsche.gif differ
diff --git a/pic/sample.ico b/pic/sample.ico
new file mode 100644
index 0000000..a1c3f2d
--- /dev/null
+++ b/pic/sample.ico
@@ -0,0 +1,84 @@
+#
+# Example icon file
+#
+screen width 640
+screen height 480
+screen colors 16
+screen background 0
+
+screen map
+	rgb   0   0   0	is .	# Black
+	rgb   0   0 170	is 1	# Blue
+	rgb   0 170   0	is 2	# Green
+	rgb   0 170 170	is 3	# Cyan
+	rgb 170   0   0	is 4	# Red
+	rgb 170   0 170	is 5	# Magenta
+	rgb 170 170   0	is 6	# Brown
+	rgb 170 170 170	is 7	# LightGray
+	rgb  85  85  85	is X	# DarkGray
+	rgb  85  85 255	is 9	# LightBlue
+	rgb  85 255  85	is A	# LightGreen
+	rgb  85 255 255	is #	# LightCyan
+	rgb 255  85  85	is C	# LightRed
+	rgb 255  85 255	is D	# LightMagenta
+	rgb 255 255  85	is E	# Yellow
+	rgb 255 255 255	is F	# White
+end
+
+#
+# Shield
+#
+image
+image top 30
+image left 50
+image bits 16 by 16
+################
+################
+##XXX######XXX##
+##XXXXXXXXXXXX##
+###XXXXXXXXXX###
+###XXXXXXXXXX###
+###XXXXXXXXXX###
+###XXXXXXXXXX###
+###XXXXXXXXXX###
+###XXXXXXXXXX###
+###XXXXXXXXXX###
+####XXXXXXXX####
+#####XXXXXX#####
+######XXXX######
+################
+################
+
+comment
+This is a klugey way of embedding a comment in a GIF.
+end
+
+#
+# Questionmark
+#
+image
+image top 30
+image left 500
+image bits 16 by 16
+......XXXXX.....
+.....XXXXXXX....
+....XXX..XXXX...
+...XXX....XXXX..
+...XXX....XXXX..
+....XX...XXXX...
+........XXXX....
+.......XXXX.....
+......XXXX......
+......XXXX......
+......XXXX......
+................
+.......XX.......
+......XXXX......
+......XXXX......
+.......XX.......
+
+# The following sets edit modes for GNU EMACS
+# Local Variables:
+# mode:picture
+# truncate-lines:t
+# End:
diff --git a/pic/solid2.gif b/pic/solid2.gif
new file mode 100644
index 0000000..4e9524b
Binary files /dev/null and b/pic/solid2.gif differ
diff --git a/pic/treescap-interlaced.gif b/pic/treescap-interlaced.gif
new file mode 100644
index 0000000..15cb77b
Binary files /dev/null and b/pic/treescap-interlaced.gif differ
diff --git a/pic/treescap.gif b/pic/treescap.gif
new file mode 100644
index 0000000..f9fb545
Binary files /dev/null and b/pic/treescap.gif differ
diff --git a/pic/welcome2.gif b/pic/welcome2.gif
new file mode 100644
index 0000000..0068b3f
Binary files /dev/null and b/pic/welcome2.gif differ
diff --git a/pic/x-trans.gif b/pic/x-trans.gif
new file mode 100644
index 0000000..6dab62d
Binary files /dev/null and b/pic/x-trans.gif differ
diff --git a/qprintf.c b/qprintf.c
new file mode 100644
index 0000000..77c0876
--- /dev/null
+++ b/qprintf.c
@@ -0,0 +1,46 @@
+/*****************************************************************************
+
+ qprintf.c - module to emulate a printf with a possible quiet (disable mode.)
+
+ A global variable GifNoisyPrint controls the printing of this routine
+
+SPDX-License-Identifier: MIT
+
+*****************************************************************************/
+
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdio.h>
+
+#include "gif_lib.h"
+
+bool GifNoisyPrint = false;
+
+/*****************************************************************************
+ Same as fprintf to stderr but with optional print.
+******************************************************************************/
+void GifQprintf(char *Format, ...) {
+	va_list ArgPtr;
+
+	va_start(ArgPtr, Format);
+
+	if (GifNoisyPrint) {
+		char Line[128];
+		(void)vsnprintf(Line, sizeof(Line), Format, ArgPtr);
+		(void)fputs(Line, stderr);
+	}
+
+	va_end(ArgPtr);
+}
+
+void PrintGifError(int ErrorCode) {
+	const char *Err = GifErrorString(ErrorCode);
+
+	if (Err != NULL) {
+		fprintf(stderr, "GIF-LIB error: %s.\n", Err);
+	} else {
+		fprintf(stderr, "GIF-LIB undefined error %d.\n", ErrorCode);
+	}
+}
+
+/* end */
diff --git a/quantize.c b/quantize.c
index e5d4a59..1194876 100644
--- a/quantize.c
+++ b/quantize.c
@@ -9,36 +9,40 @@
  and was removed in 4.2.  Then it turned out some client apps were
  actually using it, so it was restored in 5.0.
 
+SPDX-License-Identifier: MIT
+
 ******************************************************************************/
 
-#include <stdlib.h>
 #include <stdio.h>
+#include <stdlib.h>
+
 #include "gif_lib.h"
 #include "gif_lib_private.h"
 
-#define ABS(x)    ((x) > 0 ? (x) : (-(x)))
+#define ABS(x) ((x) > 0 ? (x) : (-(x)))
 
 #define COLOR_ARRAY_SIZE 32768
 #define BITS_PER_PRIM_COLOR 5
-#define MAX_PRIM_COLOR      0x1f
+#define MAX_PRIM_COLOR 0x1f
 
 static int SortRGBAxis;
 
 typedef struct QuantizedColorType {
-    GifByteType RGB[3];
-    GifByteType NewColorIndex;
-    long Count;
-    struct QuantizedColorType *Pnext;
+	GifByteType RGB[3];
+	GifByteType NewColorIndex;
+	long Count;
+	struct QuantizedColorType *Pnext;
 } QuantizedColorType;
 
 typedef struct NewColorMapType {
-    GifByteType RGBMin[3], RGBWidth[3];
-    unsigned int NumEntries; /* # of QuantizedColorType in linked list below */
-    unsigned long Count; /* Total number of pixels in all the entries */
-    QuantizedColorType *QuantizedColors;
+	GifByteType RGBMin[3], RGBWidth[3];
+	unsigned int
+	    NumEntries;      /* # of QuantizedColorType in linked list below */
+	unsigned long Count; /* Total number of pixels in all the entries */
+	QuantizedColorType *QuantizedColors;
 } NewColorMapType;
 
-static int SubdivColorMap(NewColorMapType * NewColorSubdiv,
+static int SubdivColorMap(NewColorMapType *NewColorSubdiv,
                           unsigned int ColorMapSize,
                           unsigned int *NewColorMapSize);
 static int SortCmpRtn(const void *Entry1, const void *Entry2);
@@ -55,136 +59,150 @@ static int SortCmpRtn(const void *Entry1, const void *Entry2);
    Also non of the parameter are allocated by this routine.
    This function returns GIF_OK if successful, GIF_ERROR otherwise.
 ******************************************************************************/
-int
-GifQuantizeBuffer(unsigned int Width,
-               unsigned int Height,
-               int *ColorMapSize,
-               GifByteType * RedInput,
-               GifByteType * GreenInput,
-               GifByteType * BlueInput,
-               GifByteType * OutputBuffer,
-               GifColorType * OutputColorMap) {
-
-    unsigned int Index, NumOfEntries;
-    int i, j, MaxRGBError[3];
-    unsigned int NewColorMapSize;
-    long Red, Green, Blue;
-    NewColorMapType NewColorSubdiv[256];
-    QuantizedColorType *ColorArrayEntries, *QuantizedColor;
-
-    ColorArrayEntries = (QuantizedColorType *)malloc(
-                           sizeof(QuantizedColorType) * COLOR_ARRAY_SIZE);
-    if (ColorArrayEntries == NULL) {
-        return GIF_ERROR;
-    }
-
-    for (i = 0; i < COLOR_ARRAY_SIZE; i++) {
-        ColorArrayEntries[i].RGB[0] = i >> (2 * BITS_PER_PRIM_COLOR);
-        ColorArrayEntries[i].RGB[1] = (i >> BITS_PER_PRIM_COLOR) &
-           MAX_PRIM_COLOR;
-        ColorArrayEntries[i].RGB[2] = i & MAX_PRIM_COLOR;
-        ColorArrayEntries[i].Count = 0;
-    }
-
-    /* Sample the colors and their distribution: */
-    for (i = 0; i < (int)(Width * Height); i++) {
-        Index = ((RedInput[i] >> (8 - BITS_PER_PRIM_COLOR)) <<
-                  (2 * BITS_PER_PRIM_COLOR)) +
-                ((GreenInput[i] >> (8 - BITS_PER_PRIM_COLOR)) <<
-                  BITS_PER_PRIM_COLOR) +
-                (BlueInput[i] >> (8 - BITS_PER_PRIM_COLOR));
-        ColorArrayEntries[Index].Count++;
-    }
-
-    /* Put all the colors in the first entry of the color map, and call the
-     * recursive subdivision process.  */
-    for (i = 0; i < 256; i++) {
-        NewColorSubdiv[i].QuantizedColors = NULL;
-        NewColorSubdiv[i].Count = NewColorSubdiv[i].NumEntries = 0;
-        for (j = 0; j < 3; j++) {
-            NewColorSubdiv[i].RGBMin[j] = 0;
-            NewColorSubdiv[i].RGBWidth[j] = 255;
-        }
-    }
-
-    /* Find the non empty entries in the color table and chain them: */
-    for (i = 0; i < COLOR_ARRAY_SIZE; i++)
-        if (ColorArrayEntries[i].Count > 0)
-            break;
-    QuantizedColor = NewColorSubdiv[0].QuantizedColors = &ColorArrayEntries[i];
-    NumOfEntries = 1;
-    while (++i < COLOR_ARRAY_SIZE)
-        if (ColorArrayEntries[i].Count > 0) {
-            QuantizedColor->Pnext = &ColorArrayEntries[i];
-            QuantizedColor = &ColorArrayEntries[i];
-            NumOfEntries++;
-        }
-    QuantizedColor->Pnext = NULL;
-
-    NewColorSubdiv[0].NumEntries = NumOfEntries; /* Different sampled colors */
-    NewColorSubdiv[0].Count = ((long)Width) * Height; /* Pixels */
-    NewColorMapSize = 1;
-    if (SubdivColorMap(NewColorSubdiv, *ColorMapSize, &NewColorMapSize) !=
-       GIF_OK) {
-        free((char *)ColorArrayEntries);
-        return GIF_ERROR;
-    }
-    if (NewColorMapSize < *ColorMapSize) {
-        /* And clear rest of color map: */
-        for (i = NewColorMapSize; i < *ColorMapSize; i++)
-            OutputColorMap[i].Red = OutputColorMap[i].Green =
-                OutputColorMap[i].Blue = 0;
-    }
-
-    /* Average the colors in each entry to be the color to be used in the
-     * output color map, and plug it into the output color map itself. */
-    for (i = 0; i < NewColorMapSize; i++) {
-        if ((j = NewColorSubdiv[i].NumEntries) > 0) {
-            QuantizedColor = NewColorSubdiv[i].QuantizedColors;
-            Red = Green = Blue = 0;
-            while (QuantizedColor) {
-                QuantizedColor->NewColorIndex = i;
-                Red += QuantizedColor->RGB[0];
-                Green += QuantizedColor->RGB[1];
-                Blue += QuantizedColor->RGB[2];
-                QuantizedColor = QuantizedColor->Pnext;
-            }
-            OutputColorMap[i].Red = (Red << (8 - BITS_PER_PRIM_COLOR)) / j;
-            OutputColorMap[i].Green = (Green << (8 - BITS_PER_PRIM_COLOR)) / j;
-            OutputColorMap[i].Blue = (Blue << (8 - BITS_PER_PRIM_COLOR)) / j;
-        }
-    }
-
-    /* Finally scan the input buffer again and put the mapped index in the
-     * output buffer.  */
-    MaxRGBError[0] = MaxRGBError[1] = MaxRGBError[2] = 0;
-    for (i = 0; i < (int)(Width * Height); i++) {
-        Index = ((RedInput[i] >> (8 - BITS_PER_PRIM_COLOR)) <<
-                 (2 * BITS_PER_PRIM_COLOR)) +
-                ((GreenInput[i] >> (8 - BITS_PER_PRIM_COLOR)) <<
-                 BITS_PER_PRIM_COLOR) +
-                (BlueInput[i] >> (8 - BITS_PER_PRIM_COLOR));
-        Index = ColorArrayEntries[Index].NewColorIndex;
-        OutputBuffer[i] = Index;
-        if (MaxRGBError[0] < ABS(OutputColorMap[Index].Red - RedInput[i]))
-            MaxRGBError[0] = ABS(OutputColorMap[Index].Red - RedInput[i]);
-        if (MaxRGBError[1] < ABS(OutputColorMap[Index].Green - GreenInput[i]))
-            MaxRGBError[1] = ABS(OutputColorMap[Index].Green - GreenInput[i]);
-        if (MaxRGBError[2] < ABS(OutputColorMap[Index].Blue - BlueInput[i]))
-            MaxRGBError[2] = ABS(OutputColorMap[Index].Blue - BlueInput[i]);
-    }
+int GifQuantizeBuffer(unsigned int Width, unsigned int Height,
+                      int *ColorMapSize, const GifByteType *RedInput,
+                      const GifByteType *GreenInput,
+                      const GifByteType *BlueInput, GifByteType *OutputBuffer,
+                      GifColorType *OutputColorMap) {
+
+	unsigned int Index, NumOfEntries;
+	int i, j, MaxRGBError[3];
+	unsigned int NewColorMapSize;
+	long Red, Green, Blue;
+	NewColorMapType NewColorSubdiv[256];
+	QuantizedColorType *ColorArrayEntries, *QuantizedColor;
+
+	ColorArrayEntries = (QuantizedColorType *)malloc(
+	    sizeof(QuantizedColorType) * COLOR_ARRAY_SIZE);
+	if (ColorArrayEntries == NULL) {
+		return GIF_ERROR;
+	}
+
+	for (i = 0; i < COLOR_ARRAY_SIZE; i++) {
+		ColorArrayEntries[i].RGB[0] = i >> (2 * BITS_PER_PRIM_COLOR);
+		ColorArrayEntries[i].RGB[1] =
+		    (i >> BITS_PER_PRIM_COLOR) & MAX_PRIM_COLOR;
+		ColorArrayEntries[i].RGB[2] = i & MAX_PRIM_COLOR;
+		ColorArrayEntries[i].Count = 0;
+	}
+
+	/* Sample the colors and their distribution: */
+	for (i = 0; i < (int)(Width * Height); i++) {
+		Index = ((RedInput[i] >> (8 - BITS_PER_PRIM_COLOR))
+		         << (2 * BITS_PER_PRIM_COLOR)) +
+		        ((GreenInput[i] >> (8 - BITS_PER_PRIM_COLOR))
+		         << BITS_PER_PRIM_COLOR) +
+		        (BlueInput[i] >> (8 - BITS_PER_PRIM_COLOR));
+		ColorArrayEntries[Index].Count++;
+	}
+
+	/* Put all the colors in the first entry of the color map, and call the
+	 * recursive subdivision process.  */
+	for (i = 0; i < 256; i++) {
+		NewColorSubdiv[i].QuantizedColors = NULL;
+		NewColorSubdiv[i].Count = NewColorSubdiv[i].NumEntries = 0;
+		for (j = 0; j < 3; j++) {
+			NewColorSubdiv[i].RGBMin[j] = 0;
+			NewColorSubdiv[i].RGBWidth[j] = 255;
+		}
+	}
+
+	/* Find the non empty entries in the color table and chain them: */
+	for (i = 0; i < COLOR_ARRAY_SIZE; i++) {
+		if (ColorArrayEntries[i].Count > 0) {
+			break;
+		}
+	}
+	QuantizedColor = NewColorSubdiv[0].QuantizedColors =
+	    &ColorArrayEntries[i];
+	NumOfEntries = 1;
+	while (++i < COLOR_ARRAY_SIZE) {
+		if (ColorArrayEntries[i].Count > 0) {
+			QuantizedColor->Pnext = &ColorArrayEntries[i];
+			QuantizedColor = &ColorArrayEntries[i];
+			NumOfEntries++;
+		}
+	}
+	QuantizedColor->Pnext = NULL;
+
+	NewColorSubdiv[0].NumEntries =
+	    NumOfEntries; /* Different sampled colors */
+	NewColorSubdiv[0].Count = ((long)Width) * Height; /* Pixels */
+	NewColorMapSize = 1;
+	if (SubdivColorMap(NewColorSubdiv, *ColorMapSize, &NewColorMapSize) !=
+	    GIF_OK) {
+		free((char *)ColorArrayEntries);
+		return GIF_ERROR;
+	}
+	if (NewColorMapSize < *ColorMapSize) {
+		/* And clear rest of color map: */
+		for (i = NewColorMapSize; i < *ColorMapSize; i++) {
+			OutputColorMap[i].Red = OutputColorMap[i].Green =
+			    OutputColorMap[i].Blue = 0;
+		}
+	}
+
+	/* Average the colors in each entry to be the color to be used in the
+	 * output color map, and plug it into the output color map itself. */
+	for (i = 0; i < NewColorMapSize; i++) {
+		if ((j = NewColorSubdiv[i].NumEntries) > 0) {
+			QuantizedColor = NewColorSubdiv[i].QuantizedColors;
+			Red = Green = Blue = 0;
+			while (QuantizedColor) {
+				QuantizedColor->NewColorIndex = i;
+				Red += QuantizedColor->RGB[0];
+				Green += QuantizedColor->RGB[1];
+				Blue += QuantizedColor->RGB[2];
+				QuantizedColor = QuantizedColor->Pnext;
+			}
+			OutputColorMap[i].Red =
+			    (Red << (8 - BITS_PER_PRIM_COLOR)) / j;
+			OutputColorMap[i].Green =
+			    (Green << (8 - BITS_PER_PRIM_COLOR)) / j;
+			OutputColorMap[i].Blue =
+			    (Blue << (8 - BITS_PER_PRIM_COLOR)) / j;
+		}
+	}
+
+	/* Finally scan the input buffer again and put the mapped index in the
+	 * output buffer.  */
+	MaxRGBError[0] = MaxRGBError[1] = MaxRGBError[2] = 0;
+	for (i = 0; i < (int)(Width * Height); i++) {
+		Index = ((RedInput[i] >> (8 - BITS_PER_PRIM_COLOR))
+		         << (2 * BITS_PER_PRIM_COLOR)) +
+		        ((GreenInput[i] >> (8 - BITS_PER_PRIM_COLOR))
+		         << BITS_PER_PRIM_COLOR) +
+		        (BlueInput[i] >> (8 - BITS_PER_PRIM_COLOR));
+		Index = ColorArrayEntries[Index].NewColorIndex;
+		OutputBuffer[i] = Index;
+		if (MaxRGBError[0] <
+		    ABS(OutputColorMap[Index].Red - RedInput[i])) {
+			MaxRGBError[0] =
+			    ABS(OutputColorMap[Index].Red - RedInput[i]);
+		}
+		if (MaxRGBError[1] <
+		    ABS(OutputColorMap[Index].Green - GreenInput[i])) {
+			MaxRGBError[1] =
+			    ABS(OutputColorMap[Index].Green - GreenInput[i]);
+		}
+		if (MaxRGBError[2] <
+		    ABS(OutputColorMap[Index].Blue - BlueInput[i])) {
+			MaxRGBError[2] =
+			    ABS(OutputColorMap[Index].Blue - BlueInput[i]);
+		}
+	}
 
 #ifdef DEBUG
-    fprintf(stderr,
-            "Quantization L(0) errors: Red = %d, Green = %d, Blue = %d.\n",
-            MaxRGBError[0], MaxRGBError[1], MaxRGBError[2]);
+	fprintf(stderr,
+	        "Quantization L(0) errors: Red = %d, Green = %d, Blue = %d.\n",
+	        MaxRGBError[0], MaxRGBError[1], MaxRGBError[2]);
 #endif /* DEBUG */
 
-    free((char *)ColorArrayEntries);
+	free((char *)ColorArrayEntries);
 
-    *ColorMapSize = NewColorMapSize;
+	*ColorMapSize = NewColorMapSize;
 
-    return GIF_OK;
+	return GIF_OK;
 }
 
 /******************************************************************************
@@ -193,138 +211,147 @@ GifQuantizeBuffer(unsigned int Width,
  The biggest cube in one dimension is subdivide unless it has only one entry.
  Returns GIF_ERROR if failed, otherwise GIF_OK.
 *******************************************************************************/
-static int
-SubdivColorMap(NewColorMapType * NewColorSubdiv,
-               unsigned int ColorMapSize,
-               unsigned int *NewColorMapSize) {
-
-    int MaxSize;
-    unsigned int i, j, Index = 0, NumEntries, MinColor, MaxColor;
-    long Sum, Count;
-    QuantizedColorType *QuantizedColor, **SortArray;
-
-    while (ColorMapSize > *NewColorMapSize) {
-        /* Find candidate for subdivision: */
-        MaxSize = -1;
-        for (i = 0; i < *NewColorMapSize; i++) {
-            for (j = 0; j < 3; j++) {
-                if ((((int)NewColorSubdiv[i].RGBWidth[j]) > MaxSize) &&
-                      (NewColorSubdiv[i].NumEntries > 1)) {
-                    MaxSize = NewColorSubdiv[i].RGBWidth[j];
-                    Index = i;
-                    SortRGBAxis = j;
-                }
-            }
-        }
-
-        if (MaxSize == -1)
-            return GIF_OK;
-
-        /* Split the entry Index into two along the axis SortRGBAxis: */
-
-        /* Sort all elements in that entry along the given axis and split at
-         * the median.  */
-        SortArray = (QuantizedColorType **)malloc(
-                      sizeof(QuantizedColorType *) * 
-                      NewColorSubdiv[Index].NumEntries);
-        if (SortArray == NULL)
-            return GIF_ERROR;
-        for (j = 0, QuantizedColor = NewColorSubdiv[Index].QuantizedColors;
-             j < NewColorSubdiv[Index].NumEntries && QuantizedColor != NULL;
-             j++, QuantizedColor = QuantizedColor->Pnext)
-            SortArray[j] = QuantizedColor;
-
-	/*
-	 * Because qsort isn't stable, this can produce differing 
-	 * results for the order of tuples depending on platform
-	 * details of how qsort() is implemented.
-	 *
-	 * We mitigate this problem by sorting on all three axes rather
-	 * than only the one specied by SortRGBAxis; that way the instability
-	 * can only become an issue if there are multiple color indices
-	 * referring to identical RGB tuples.  Older versions of this 
-	 * sorted on only the one axis.
-	 */
-        qsort(SortArray, NewColorSubdiv[Index].NumEntries,
-              sizeof(QuantizedColorType *), SortCmpRtn);
-
-        /* Relink the sorted list into one: */
-        for (j = 0; j < NewColorSubdiv[Index].NumEntries - 1; j++)
-            SortArray[j]->Pnext = SortArray[j + 1];
-        SortArray[NewColorSubdiv[Index].NumEntries - 1]->Pnext = NULL;
-        NewColorSubdiv[Index].QuantizedColors = QuantizedColor = SortArray[0];
-        free((char *)SortArray);
-
-        /* Now simply add the Counts until we have half of the Count: */
-        Sum = NewColorSubdiv[Index].Count / 2 - QuantizedColor->Count;
-        NumEntries = 1;
-        Count = QuantizedColor->Count;
-        while (QuantizedColor->Pnext != NULL &&
-	       (Sum -= QuantizedColor->Pnext->Count) >= 0 &&
-               QuantizedColor->Pnext->Pnext != NULL) {
-            QuantizedColor = QuantizedColor->Pnext;
-            NumEntries++;
-            Count += QuantizedColor->Count;
-        }
-        /* Save the values of the last color of the first half, and first
-         * of the second half so we can update the Bounding Boxes later.
-         * Also as the colors are quantized and the BBoxes are full 0..255,
-         * they need to be rescaled.
-         */
-        MaxColor = QuantizedColor->RGB[SortRGBAxis]; /* Max. of first half */
-	/* coverity[var_deref_op] */
-        MinColor = QuantizedColor->Pnext->RGB[SortRGBAxis]; /* of second */
-        MaxColor <<= (8 - BITS_PER_PRIM_COLOR);
-        MinColor <<= (8 - BITS_PER_PRIM_COLOR);
-
-        /* Partition right here: */
-        NewColorSubdiv[*NewColorMapSize].QuantizedColors =
-           QuantizedColor->Pnext;
-        QuantizedColor->Pnext = NULL;
-        NewColorSubdiv[*NewColorMapSize].Count = Count;
-        NewColorSubdiv[Index].Count -= Count;
-        NewColorSubdiv[*NewColorMapSize].NumEntries =
-           NewColorSubdiv[Index].NumEntries - NumEntries;
-        NewColorSubdiv[Index].NumEntries = NumEntries;
-        for (j = 0; j < 3; j++) {
-            NewColorSubdiv[*NewColorMapSize].RGBMin[j] =
-               NewColorSubdiv[Index].RGBMin[j];
-            NewColorSubdiv[*NewColorMapSize].RGBWidth[j] =
-               NewColorSubdiv[Index].RGBWidth[j];
-        }
-        NewColorSubdiv[*NewColorMapSize].RGBWidth[SortRGBAxis] =
-           NewColorSubdiv[*NewColorMapSize].RGBMin[SortRGBAxis] +
-           NewColorSubdiv[*NewColorMapSize].RGBWidth[SortRGBAxis] - MinColor;
-        NewColorSubdiv[*NewColorMapSize].RGBMin[SortRGBAxis] = MinColor;
-
-        NewColorSubdiv[Index].RGBWidth[SortRGBAxis] =
-           MaxColor - NewColorSubdiv[Index].RGBMin[SortRGBAxis];
-
-        (*NewColorMapSize)++;
-    }
-
-    return GIF_OK;
+static int SubdivColorMap(NewColorMapType *NewColorSubdiv,
+                          unsigned int ColorMapSize,
+                          unsigned int *NewColorMapSize) {
+
+	unsigned int i, j, Index = 0;
+	QuantizedColorType *QuantizedColor, **SortArray;
+
+	while (ColorMapSize > *NewColorMapSize) {
+		/* Find candidate for subdivision: */
+		long Sum, Count;
+		int MaxSize = -1;
+		unsigned int NumEntries, MinColor, MaxColor;
+		for (i = 0; i < *NewColorMapSize; i++) {
+			for (j = 0; j < 3; j++) {
+				if ((((int)NewColorSubdiv[i].RGBWidth[j]) >
+				     MaxSize) &&
+				    (NewColorSubdiv[i].NumEntries > 1)) {
+					MaxSize = NewColorSubdiv[i].RGBWidth[j];
+					Index = i;
+					SortRGBAxis = j;
+				}
+			}
+		}
+
+		if (MaxSize == -1) {
+			return GIF_OK;
+		}
+
+		/* Split the entry Index into two along the axis SortRGBAxis: */
+
+		/* Sort all elements in that entry along the given axis and
+		 * split at the median.  */
+		SortArray = (QuantizedColorType **)malloc(
+		    sizeof(QuantizedColorType *) *
+		    NewColorSubdiv[Index].NumEntries);
+		if (SortArray == NULL) {
+			return GIF_ERROR;
+		}
+		for (j = 0,
+		    QuantizedColor = NewColorSubdiv[Index].QuantizedColors;
+		     j < NewColorSubdiv[Index].NumEntries &&
+		     QuantizedColor != NULL;
+		     j++, QuantizedColor = QuantizedColor->Pnext) {
+			SortArray[j] = QuantizedColor;
+		}
+
+		/*
+		 * Because qsort isn't stable, this can produce differing
+		 * results for the order of tuples depending on platform
+		 * details of how qsort() is implemented.
+		 *
+		 * We mitigate this problem by sorting on all three axes rather
+		 * than only the one specied by SortRGBAxis; that way the
+		 * instability can only become an issue if there are multiple
+		 * color indices referring to identical RGB tuples.  Older
+		 * versions of this sorted on only the one axis.
+		 */
+		qsort(SortArray, NewColorSubdiv[Index].NumEntries,
+		      sizeof(QuantizedColorType *), SortCmpRtn);
+
+		/* Relink the sorted list into one: */
+		for (j = 0; j < NewColorSubdiv[Index].NumEntries - 1; j++) {
+			SortArray[j]->Pnext = SortArray[j + 1];
+		}
+		SortArray[NewColorSubdiv[Index].NumEntries - 1]->Pnext = NULL;
+		NewColorSubdiv[Index].QuantizedColors = QuantizedColor =
+		    SortArray[0];
+		free((char *)SortArray);
+
+		/* Now simply add the Counts until we have half of the Count: */
+		Sum = NewColorSubdiv[Index].Count / 2 - QuantizedColor->Count;
+		NumEntries = 1;
+		Count = QuantizedColor->Count;
+		while (QuantizedColor->Pnext != NULL &&
+		       (Sum -= QuantizedColor->Pnext->Count) >= 0 &&
+		       QuantizedColor->Pnext->Pnext != NULL) {
+			QuantizedColor = QuantizedColor->Pnext;
+			NumEntries++;
+			Count += QuantizedColor->Count;
+		}
+		/* Save the values of the last color of the first half, and
+		 * first of the second half so we can update the Bounding Boxes
+		 * later. Also as the colors are quantized and the BBoxes are
+		 * full 0..255, they need to be rescaled.
+		 */
+		MaxColor =
+		    QuantizedColor->RGB[SortRGBAxis]; /* Max. of first half */
+		/* coverity[var_deref_op] */
+		MinColor =
+		    // cppcheck-suppress nullPointerRedundantCheck
+		    QuantizedColor->Pnext->RGB[SortRGBAxis]; /* of second */
+		MaxColor <<= (8 - BITS_PER_PRIM_COLOR);
+		MinColor <<= (8 - BITS_PER_PRIM_COLOR);
+
+		/* Partition right here: */
+		NewColorSubdiv[*NewColorMapSize].QuantizedColors =
+		    QuantizedColor->Pnext;
+		QuantizedColor->Pnext = NULL;
+		NewColorSubdiv[*NewColorMapSize].Count = Count;
+		NewColorSubdiv[Index].Count -= Count;
+		NewColorSubdiv[*NewColorMapSize].NumEntries =
+		    NewColorSubdiv[Index].NumEntries - NumEntries;
+		NewColorSubdiv[Index].NumEntries = NumEntries;
+		for (j = 0; j < 3; j++) {
+			NewColorSubdiv[*NewColorMapSize].RGBMin[j] =
+			    NewColorSubdiv[Index].RGBMin[j];
+			NewColorSubdiv[*NewColorMapSize].RGBWidth[j] =
+			    NewColorSubdiv[Index].RGBWidth[j];
+		}
+		NewColorSubdiv[*NewColorMapSize].RGBWidth[SortRGBAxis] =
+		    NewColorSubdiv[*NewColorMapSize].RGBMin[SortRGBAxis] +
+		    NewColorSubdiv[*NewColorMapSize].RGBWidth[SortRGBAxis] -
+		    MinColor;
+		NewColorSubdiv[*NewColorMapSize].RGBMin[SortRGBAxis] = MinColor;
+
+		NewColorSubdiv[Index].RGBWidth[SortRGBAxis] =
+		    MaxColor - NewColorSubdiv[Index].RGBMin[SortRGBAxis];
+
+		(*NewColorMapSize)++;
+	}
+
+	return GIF_OK;
 }
 
 /****************************************************************************
  Routine called by qsort to compare two entries.
-*****************************************************************************/
-
-static int
-SortCmpRtn(const void *Entry1,
-           const void *Entry2) {
-	   QuantizedColorType *entry1 = (*((QuantizedColorType **) Entry1));
-	   QuantizedColorType *entry2 = (*((QuantizedColorType **) Entry2));
-
-	   /* sort on all axes of the color space! */
-	   int hash1 = entry1->RGB[SortRGBAxis] * 256 * 256
-	   			+ entry1->RGB[(SortRGBAxis+1) % 3] * 256
-				+ entry1->RGB[(SortRGBAxis+2) % 3];
-	   int hash2 = entry2->RGB[SortRGBAxis] * 256 * 256
-	   			+ entry2->RGB[(SortRGBAxis+1) % 3] * 256
-				+ entry2->RGB[(SortRGBAxis+2) % 3];
-
-    return hash1 - hash2;
+ *****************************************************************************/
+
+static int SortCmpRtn(const void *Entry1, const void *Entry2) {
+	QuantizedColorType *entry1 = (*((QuantizedColorType **)Entry1));
+	QuantizedColorType *entry2 = (*((QuantizedColorType **)Entry2));
+
+	/* sort on all axes of the color space! */
+	int hash1 = entry1->RGB[SortRGBAxis] * 256 * 256 +
+	            entry1->RGB[(SortRGBAxis + 1) % 3] * 256 +
+	            entry1->RGB[(SortRGBAxis + 2) % 3];
+	int hash2 = entry2->RGB[SortRGBAxis] * 256 * 256 +
+	            entry2->RGB[(SortRGBAxis + 1) % 3] * 256 +
+	            entry2->RGB[(SortRGBAxis + 2) % 3];
+
+	return hash1 - hash2;
 }
 
 /* end */
diff --git a/tests/fire.dmp b/tests/fire.dmp
new file mode 100644
index 0000000..ef465d1
--- /dev/null
+++ b/tests/fire.dmp
@@ -0,0 +1,448 @@
+
+Stdin:
+
+	Screen Size - Width = 30, Height = 60.
+	ColorResolution = 8, BitsPerPixel = 8, BackGround = 0, Aspect = 0.
+	Has Global Color Map.
+
+
+GIF89 application block (Ext Code = 255 [ ]):
+
+GIF89 comment (Ext Code = 254 [ ]):
+
+00000:  2                                                                  
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #1:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #2:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #3:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #4:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #5:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #6:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #7:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #8:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #9:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #10:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #11:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #12:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #13:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #14:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #15:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #16:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #17:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #18:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #19:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #20:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #21:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #22:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #23:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #24:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #25:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #26:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #27:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #28:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #29:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #30:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #31:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #32:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 1
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 5
+	Transparent Index: -1
+
+Image #33:
+
+	Image Size - Left = 0, Top = 0, Width = 30, Height = 60.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF89 comment (Ext Code = 254 [ ]):
+
+00000:  4                                                 Don't flame me!  
+00010:  7                                                 polder@xs4all.nl 
+00020:  0                                                  (c) 1996 Demon  
+GIF file terminated normally.
diff --git a/tests/fire.map b/tests/fire.map
new file mode 100644
index 0000000..aa52428
--- /dev/null
+++ b/tests/fire.map
@@ -0,0 +1,256 @@
+  0 247 222 132
+  1 123  99  66
+  2 165 123  74
+  3  82  58  41
+  4 206 173  66
+  5 197 165  99
+  6  58  25  25
+  7 181 132  25
+  8 132  99  16
+  9 214 181  82
+ 10  90  49   8
+ 11  33  25  16
+ 12 115  58  25
+ 13 230 197  90
+ 14 148 123  66
+ 15 115  90  49
+ 16 132  99  33
+ 17 181 132  33
+ 18  82  41  16
+ 19 181 148  66
+ 20 173 148  99
+ 21 148 107  33
+ 22  25   0   0
+ 23 230 197 107
+ 24  82  58  25
+ 25 197 148  66
+ 26 115  82  16
+ 27 132  74   8
+ 28  74  41   8
+ 29 156 107  41
+ 30 156 115  41
+ 31  99  74  49
+ 32 181 148  41
+ 33 156  99   8
+ 34 132  99  41
+ 35 156 123  74
+ 36 181 123  49
+ 37  74  49  33
+ 38  82  58  33
+ 39 206 165  58
+ 40 181 148  99
+ 41 197 165  74
+ 42  58  16   8
+ 43  58  33   0
+ 44 156 123  33
+ 45 214 173  74
+ 46  90  41   0
+ 47  41   0   0
+ 48  90  58  25
+ 49 115  58   8
+ 50 115  82  33
+ 51 132  82  33
+ 52 165 123  41
+ 53  66  33  25
+ 54 165 132  90
+ 55 181 140  74
+ 56 181 148  74
+ 57   8   0   8
+ 58 197 148  49
+ 59 115  74   8
+ 60  74  25   0
+ 61 132  99  58
+ 62 107  66  25
+ 63 165 123  49
+ 64 189 156  74
+ 65 197 156  74
+ 66 165 115  16
+ 67  99  58   0
+ 68 230 206 115
+ 69 123  99  49
+ 70 165 123  58
+ 71  66  49  58
+ 72 197 156  66
+ 73 181 156  99
+ 74 197 165  82
+ 75  49  25  16
+ 76  58  33   8
+ 77 165 132  25
+ 78 165 132  33
+ 79 132  82   8
+ 80 206 165  99
+ 81  82  49   0
+ 82  33  16   0
+ 83  99  58  25
+ 84  99  66  16
+ 85 214 189  82
+ 86 140 107  66
+ 87 115  74  41
+ 88 173 132  33
+ 89  66  41  25
+ 90  66  49  16
+ 91 165 132  58
+ 92 181 132  58
+ 93 181 148  49
+ 94 140  90  25
+ 95 140 107  16
+ 96   8   0   0
+ 97  66  41  25
+ 98  99  66  16
+ 99 115  66  16
+100 123  66   0
+101 140  99  49
+102 140 107  58
+103  99  66  33
+104 173 132  41
+105 181 140  33
+106 140  90   8
+107 140  90  16
+108 123  82  41
+109 156 123  58
+110 189 156  49
+111 197 156  41
+112 189 148  82
+113  41   8   0
+114  41  25   8
+115 156 107  25
+116 206 165  74
+117  82  25   0
+118  25   8   0
+119  90  49   8
+120  99  58   8
+121 107  74  25
+122 156 140  74
+123  58  33  16
+124 140  90  41
+125  90  58  33
+126 189 140  74
+127  99  41   0
+128 165 115  25
+129 173 115  25
+130 206 173  82
+131 148 115  41
+132 165 132  49
+133 140  90   0
+134  66  16   0
+135 247 222 123
+136 123  90  58
+137 123  99  58
+138 165 123  66
+139 197 165  66
+140 206 165  66
+141  49  33  25
+142 173 132  25
+143 181 123  25
+144 123  90  16
+145 132  90  16
+146 206 173  90
+147 214 173  82
+148  82  49   8
+149  90  49   0
+150  25  16  16
+151  33  16   8
+152 115  58  16
+153 222 189  82
+154 222 189  90
+155 148 115  58
+156 148 115  66
+157 107  82  49
+158 115  82  41
+159 123  90  25
+160 132  90  33
+161 132  99  25
+162 173 132  41
+163 181 123  33
+164  74  49  16
+165 181 140  66
+166 173 140  90
+167 140 107  33
+168 148 107  25
+169  16   0   8
+170  16   8   8
+171 222 189  99
+172  74  49  25
+173  82  49  25
+174 189 140  58
+175 189 148  66
+176 197 148  58
+177 115  74  16
+178 123  74   8
+179 123  82   8
+180  66  33   0
+181  74  33   0
+182  74  41   0
+183 148  99  41
+184 148 107  41
+185 148 107  49
+186 148 115  49
+187  99  66  41
+188  99  74  41
+189 181 140  41
+190 181 140  49
+191 148  99   8
+192 148  99  16
+193 123  90  49
+194 132  90  41
+195 156 123  66
+196 173 123  49
+197  66  49  33
+198 197 165  49
+199 197 156  82
+200  49  16   0
+201  49  25   0
+202  58  16   0
+203  58  25   0
+204  58  25   8
+205 156 115  25
+206 156 115  33
+207 206 173  74
+208 206 181  74
+209  82  41   0
+210  82  41   8
+211  33   0   0
+212  33   0   8
+213  90  49  16
+214  90  58  16
+215 107  58   0
+216 107  58   8
+217 107  74  41
+218 115  74  33
+219 123  74  25
+220 123  82  33
+221 132  82  25
+222 156 115  41
+223 156 123  49
+224 165 115  41
+225  58  41  16
+226  66  33  16
+227 165 132  82
+228 173 140  74
+229   0   0   0
+230   8   0   0
+231 189 140  41
+232 189 148  49
+233 107  66   0
+234 115  66   8
+235  66  25   0
+236 132  99  49
+237  99  66  33
+238 156 115  58
+239 156 107   8
+240 156 115  16
+241  90  58   0
+242 115  99  58
+243 189 156  66
+244  41  25  16
+245 165 123  25
+246 165 123  33
+247 123  82  16
+248  74  49   0
+249  33   8   0
+250  99  58  16
+251 214 181  90
+252 132 107  74
+253 107  82  41
+254 165 132  41
+255  66  41  16
diff --git a/tests/fire.rgb b/tests/fire.rgb
new file mode 100644
index 0000000..8f18482
Binary files /dev/null and b/tests/fire.rgb differ
diff --git a/tests/foobar.ico b/tests/foobar.ico
new file mode 100644
index 0000000..7cac648
--- /dev/null
+++ b/tests/foobar.ico
@@ -0,0 +1,30 @@
+screen width 48
+screen height 8
+screen colors 2
+screen background 0
+pixel aspect byte 0
+
+screen map
+	sort flag off
+	rgb 000 000 000 is 0
+	rgb 255 255 255 is 1
+end
+
+image # 1
+image left 0
+image top 0
+image bits 48 by 8
+000111100000000000000000110000000000000000000000
+001100000000000000000000110000000000000000000000
+011111000111110001111100111111000111110001101110
+001100001100011011000110110001100000011001110000
+001100001100011011000110110001100111111001100000
+001100001100011011000110111001101100011001100000
+001100000111110001111100110111000111111001100000
+000000000000000000000000000000000000000000000000
+
+# The following sets edit modes for GNU EMACS
+# Local Variables:
+# mode:picture
+# truncate-lines:t
+# End:
diff --git a/tests/giffixed.ico b/tests/giffixed.ico
new file mode 100644
index 0000000..35a429a
--- /dev/null
+++ b/tests/giffixed.ico
@@ -0,0 +1,76 @@
+screen width 40
+screen height 40
+screen colors 128
+screen background 0
+pixel aspect byte 0
+
+screen map
+	sort flag off
+	rgb 046 140 093 is 0
+	rgb 000 255 255 is 1
+	rgb 000 157 000 is 2
+	rgb 081 200 086 is 3
+	rgb 190 190 190 is 4
+	rgb 110 110 110 is 5
+	rgb 255 255 000 is 6
+	rgb 136 115 095 is 7
+	rgb 231 231 231 is 8
+	rgb 000 153 102 is 9
+	rgb 000 000 000 is a
+	rgb 000 000 000 is b
+	rgb 000 000 000 is c
+	rgb 000 000 000 is d
+	rgb 000 000 000 is e
+	rgb 000 000 000 is f
+end
+
+image # 1
+image left 0
+image top 0
+image bits 40 by 40
+8888888888888888888888888888888888888885
+8888888888888888888888888888888888888855
+8844444444444444444444444444444444444455
+8845555555555555555555555555555555558455
+8845666661111111111111111111111111118455
+8845666661111111133333311111111111118455
+8845666611111133333333333311111111118455
+8845666611113333333333323391111111118455
+8845661111113333223333322231111111118455
+8845111111113333322333733291111111118455
+8845111111333333323337223239111111118455
+8845111113333337723373232222111111118455
+8845111113373333773332222229211111118455
+8845111113777733332333772229911111118455
+8845111113333732232223222229211111118455
+8845111111139392372337223779111111118455
+8845111111111929277372222222111111118455
+8845111111111111117733222122111111118455
+8845111111111111117772231111111111118455
+8845111111111111117711211111111111118455
+8845111111111111117711111111111111118455
+8845111111111111117711111111111111118455
+8845111111111111117711111111111111118455
+8845111111112222227722111111111111118455
+8845292912222222227722221111111111118455
+8845999922222222227722222222211111118455
+8845292222222222277722222222222111118455
+8845999222222227777772222222222291118455
+8845292222222227227077722222222229298455
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+
+# The following sets edit modes for GNU EMACS
+# Local Variables:
+# mode:picture
+# truncate-lines:t
+# End:
diff --git a/tests/gifgrid.dmp b/tests/gifgrid.dmp
new file mode 100644
index 0000000..14fd119
--- /dev/null
+++ b/tests/gifgrid.dmp
@@ -0,0 +1,22 @@
+
+Stdin:
+
+	Screen Size - Width = 100, Height = 100.
+	ColorResolution = 3, BitsPerPixel = 3, BackGround = 0, Aspect = 0.
+	Has Global Color Map.
+
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 0
+	User Input Flag: 0
+	Transparency on: no
+	DelayTime: 0
+	Transparent Index: -1
+
+Image #1:
+
+	Image Size - Left = 0, Top = 0, Width = 100, Height = 100.
+	Image is Non Interlaced.
+	No Image Color Map.
+
+GIF file terminated normally.
diff --git a/tests/gifgrid.ico b/tests/gifgrid.ico
new file mode 100644
index 0000000..77fd29f
--- /dev/null
+++ b/tests/gifgrid.ico
@@ -0,0 +1,128 @@
+screen width 100
+screen height 100
+screen colors 8
+screen background 0
+pixel aspect byte 0
+
+screen map
+	sort flag on
+	rgb 000 000 248 is 0
+	rgb 248 000 000 is 1
+	rgb 000 016 160 is 2
+	rgb 160 016 000 is 3
+	rgb 160 176 160 is 4
+	rgb 248 248 248 is 5
+	rgb 000 000 000 is 6
+	rgb 000 000 000 is 7
+end
+
+image # 1
+image left 0
+image top 0
+image bits 100 by 100
+3333333333333333333333333333333333333333333333333322222222222222222222222222222222222222222222222222
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3333333333333333333333333333333333333333333333333322222222222222222222222222222222222222222222222222
+3333333333333333333333333333333333333333333333333322222222222222222222222222222222222222222222222222
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3333333333333333333333333333333333333333333333333322222222222222222222222222222222222222222222222222
+3333333333333333333333333333333333333333333333333322222222222222222222222222222222222222222222222222
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3111111113311111111331111111133111111113311111111320000000022000000002200000000220000000022000000002
+3333333333333333333333333333333333333333333333333322222222222222222222222222222222222222222222222222
+3333333333333333333333333333334444444444444444444444444444444444444444222222222222222222222222222222
+3111111113311111111331111111134555555554455555555445555555544555555554200000000220000000022000000002
+3111111113311111111331111111134555555554455555555445555555544555555554200000000220000000022000000002
+3111111113311111111331111111134555555554455555555445555555544555555554200000000220000000022000000002
+3111111113311111111331111111134555555554455555555445555555544555555554200000000220000000022000000002
+3111111113311111111331111111134555555554455555555445555555544555555554200000000220000000022000000002
+3111111113311111111331111111134555555554455555555445555555544555555554200000000220000000022000000002
+3111111113311111111331111111134555555554455555555445555555544555555554200000000220000000022000000002
+3111111113311111111331111111134555555554455555555445555555544555555554200000000220000000022000000002
+3333333333333333333333333333334444444444444444444444444444444444444444222222222222222222222222222222
+3333333333333333333333333333334444444444444444444444444444444444444444222222222222222222222222222222
+3111111113311111111331111111134555555554455555555445555555544555555554200000000220000000022000000002
+3111111113311111111331111111134555555554455555555445555555544555555554200000000220000000022000000002
+3111111113311111111331111111134555555554455555555445555555544555555554200000000220000000022000000002
+3111111113311111111331111111134555555554455555555445555555544555555554200000000220000000022000000002
+3111111113311111111331111111134555555554455555555445555555544555555554200000000220000000022000000002
+3111111113311111111331111111134555555554455555555445555555544555555554200000000220000000022000000002
+3111111113311111111331111111134555555554455555555445555555544555555554200000000220000000022000000002
+3111111113311111111331111111134555555554455555555445555555544555555554200000000220000000022000000002
+3333333333333333333333333333334444444444444444444444444444444444444444222222222222222222222222222222
+2222222222222222222222222222224444444444444444444444444444444444444444333333333333333333333333333333
+2000000002200000000220000000024555555554455555555445555555544555555554311111111331111111133111111113
+2000000002200000000220000000024555555554455555555445555555544555555554311111111331111111133111111113
+2000000002200000000220000000024555555554455555555445555555544555555554311111111331111111133111111113
+2000000002200000000220000000024555555554455555555445555555544555555554311111111331111111133111111113
+2000000002200000000220000000024555555554455555555445555555544555555554311111111331111111133111111113
+2000000002200000000220000000024555555554455555555445555555544555555554311111111331111111133111111113
+2000000002200000000220000000024555555554455555555445555555544555555554311111111331111111133111111113
+2000000002200000000220000000024555555554455555555445555555544555555554311111111331111111133111111113
+2222222222222222222222222222224444444444444444444444444444444444444444333333333333333333333333333333
+2222222222222222222222222222224444444444444444444444444444444444444444333333333333333333333333333333
+2000000002200000000220000000024555555554455555555445555555544555555554311111111331111111133111111113
+2000000002200000000220000000024555555554455555555445555555544555555554311111111331111111133111111113
+2000000002200000000220000000024555555554455555555445555555544555555554311111111331111111133111111113
+2000000002200000000220000000024555555554455555555445555555544555555554311111111331111111133111111113
+2000000002200000000220000000024555555554455555555445555555544555555554311111111331111111133111111113
+2000000002200000000220000000024555555554455555555445555555544555555554311111111331111111133111111113
+2000000002200000000220000000024555555554455555555445555555544555555554311111111331111111133111111113
+2000000002200000000220000000024555555554455555555445555555544555555554311111111331111111133111111113
+2222222222222222222222222222224444444444444444444444444444444444444444333333333333333333333333333333
+2222222222222222222222222222222222222222222222222233333333333333333333333333333333333333333333333333
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2222222222222222222222222222222222222222222222222233333333333333333333333333333333333333333333333333
+2222222222222222222222222222222222222222222222222233333333333333333333333333333333333333333333333333
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2222222222222222222222222222222222222222222222222233333333333333333333333333333333333333333333333333
+2222222222222222222222222222222222222222222222222233333333333333333333333333333333333333333333333333
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2000000002200000000220000000022000000002200000000231111111133111111113311111111331111111133111111113
+2222222222222222222222222222222222222222222222222233333333333333333333333333333333333333333333333333
+
+# The following sets edit modes for GNU EMACS
+# Local Variables:
+# mode:picture
+# truncate-lines:t
+# End:
diff --git a/tests/gifgrid.map b/tests/gifgrid.map
new file mode 100644
index 0000000..505f7f0
--- /dev/null
+++ b/tests/gifgrid.map
@@ -0,0 +1,8 @@
+  0 165 178 165
+  1   4  17 165
+  2 165  17   4
+  3 255 255 255
+  4 255   0   0
+  5   0   0 255
+  6   0   0   0
+  7   0   0   0
diff --git a/tests/gifgrid.rgb b/tests/gifgrid.rgb
new file mode 100644
index 0000000..d4c6705
Binary files /dev/null and b/tests/gifgrid.rgb differ
diff --git a/tests/makefile b/tests/makefile
new file mode 100644
index 0000000..c3bb9d5
--- /dev/null
+++ b/tests/makefile
@@ -0,0 +1,163 @@
+# Regression-test suite for the giflib library and tools
+# All utilities have tests except gifbg, gifcolor, and gifhisto.
+
+.SUFFIXES: .gif .rgb
+
+# This is what to do by default
+test: render-regress \
+	gifbuild-regress \
+	gifclrmp-regress \
+	gifecho-regress \
+	giffilter-regress \
+	giffix-regress \
+	gifsponge-regress \
+	giftext-regress \
+	giftool-regress \
+	gifwedge-regress
+	@echo "No output is good news"
+
+rebuild: render-rebuild \
+		gif2rgb-rebuild \
+		gifclrmp-rebuild \
+		gifecho-rebuild \
+		giffix-rebuild \
+		giftext-rebuild \
+		gifwedge-rebuild
+
+UTILS = ..
+PICS = ../pic
+
+GIFS := $(shell ls ../pic/*.gif)
+
+# Test decompression and rendering by unpacking images,
+# converting them to RGB, and comparing that result to a check file.
+render-regress:
+	@for test in $(GIFS); \
+	do \
+	    stem=`basename $${test} | sed -e "s/.gif$$//"`; \
+	    if echo "Testing RGB rendering of $${test}" >&2; \
+	    $(UTILS)/gif2rgb -1 -o $@.$${stem}.regress $${test} 2>&1; \
+	    then cmp $${stem}.rgb $@.$${stem}.regress; \
+	    else echo "*** Nonzero return status on $${test}!"; exit 1; fi; \
+	done
+	@rm -f $@.*.regress
+render-rebuild:
+	@for test in $(GIFS); do \
+		stem=`basename $${test} | sed -e "s/.gif$$//"`; \
+		echo "Remaking $${stem}.rgb"; \
+		$(UTILS)/gif2rgb -1 -o $${stem}.rgb $${test}; \
+	done
+
+gif2rgb-rebuild:
+	@echo "Rebuilding gif2rgb checkfile."
+	@$(UTILS)/gif2rgb -c 3 -s 100 100 <gifgrid.rgb | $(UTILS)/gifbuild -d >gifgrid.ico
+gif2rgb-regress:
+	@echo "gif2rgb: Checking idempotency"
+	@$(UTILS)/gif2rgb -c 3 -s 100 100 <gifgrid.rgb | $(UTILS)/gifbuild -d | diff -u gifgrid.ico -
+
+gifbuild-regress:
+	@echo "gifbuild: basic sanity check"
+	@$(UTILS)/gifbuild -d <$(PICS)/treescap.gif | diff -u treescap.ico -
+	@echo "gifbuild: Checking idempotency on an icon file."
+	@$(UTILS)/gifbuild <$(PICS)/sample.ico | $(UTILS)/gifbuild -d > $@.sample-1.ico; $(UTILS)/gifbuild < $@.sample-1.ico | $(UTILS)/gifbuild -d > $@.sample-2.ico; diff -u $@.sample-1.ico $@.sample-2.ico; rm $@.sample-?.ico
+	@echo "gifbuild: Checking idempotency on an animation."
+	@$(UTILS)/gifbuild -d <$(PICS)/fire.gif > $@.fire1.ico
+	@$(UTILS)/gifbuild < $@.fire1.ico > $@.fire2.gif
+	@$(UTILS)/gifbuild -d < $@.fire2.gif > $@.fire2.ico
+	@diff -u  $@.fire1.ico  $@.fire2.ico
+	@rm -f $@.fire1.ico  $@.fire2.ico $@.fire2.gif
+
+gifclrmp-regress:
+	@for test in $(GIFS); \
+	do \
+	    stem=`basename $${test} | sed -e "s/.gif$$//"`; \
+	    if echo "gifclrmap: Checking colormap of $${test}" >&2; \
+	    $(UTILS)/gifclrmp <$${test} > $@.$${stem}.regress 2>&1; \
+	    then diff -u $${stem}.map $@.$${stem}.regress; \
+	    else echo "*** Nonzero return status on $${test}!"; exit 1; fi; \
+	done
+	@rm -f $@.*.regress
+gifclrmp-rebuild:
+	@for test in $(GIFS); do \
+		stem=`basename $${test} | sed -e "s/.gif$$//"`; \
+		echo "Remaking $${stem}.map"; \
+		$(UTILS)/gifclrmp <$${test} >$${stem}.map; \
+	done
+
+gifecho-rebuild:
+	@echo "Rebuilding gifecho test."
+	@$(UTILS)/gifecho -t "foobar" | $(UTILS)/gifbuild -d >foobar.ico
+gifecho-regress:
+	@echo "gifecho: Testing gifecho behavior"
+	@$(UTILS)/gifecho -t "foobar" | $(UTILS)/gifbuild -d | diff -u foobar.ico -
+
+giffilter-regress:
+	@for test in $(GIFS); \
+	do \
+	    stem=`basename $${test} | sed -e "s/.gif$$//"`; \
+	    if echo "giffiltr: Testing copy of $${test}" >&2; \
+	    $(UTILS)/giffilter <$${test} | $(UTILS)/gif2rgb > $@.$${stem}.regress 2>&1; \
+	    then cmp $${stem}.rgb $@.$${stem}.regress; \
+	    else echo "*** Nonzero return status on $${test}!"; exit 1; fi; \
+	done
+	@rm -f  $@.*.regress
+
+giffix-rebuild:
+	@echo "Rebuilding giffix test."
+	@head --bytes=-20 <$(PICS)/treescap.gif | $(UTILS)/giffix 2>/dev/null | $(UTILS)/gifbuild -d >giffixed.ico
+giffix-regress:
+	@echo "giffix: Testing giffix behavior"
+	@head --bytes=-20 <$(PICS)/treescap.gif | $(UTILS)/giffix 2>/dev/null | $(UTILS)/gifbuild -d | diff -u giffixed.ico -
+
+gifinto-regress:
+	@echo "gifinto: Checking behavior on short files."
+	@rm -f $@.giflib.tmp
+	@$(UTILS)/gifinto <$(PICS)/porsche.gif $@.giflib.tmp
+	@if test ! -f $@.giflib.tmp; then echo "gifinto failed to create a file when it should have."; fi
+	@rm -f $@.giflib.tmp
+	@echo "0123456789" | $(UTILS)/gifinto $@.giflib.tmp 2>/dev/null
+	@if test -f $@.giflib.tmp; then echo "gifinto created a file when it shouldn't have."; fi
+	@rm -f $@.giflib.tmp
+
+gifsponge-regress:
+	@for test in $(GIFS); \
+	do \
+	    stem=`basename $${test} | sed -e "s/.gif$$//"`; \
+	    if echo "gifsponge: Testing copy of $${test}" >&2; \
+	    $(UTILS)/gifsponge <$${test} | $(UTILS)/gif2rgb > $@.$${stem}.regress 2>&1; \
+	    then cmp $${stem}.rgb  $@.$${stem}.regress; \
+	    else echo "*** Nonzero return status on $${test}!"; exit 1; fi; \
+	done
+	@rm -f  $@.*.regress
+
+giftext-regress:
+	@for test in $(GIFS); \
+	do \
+	    stem=`basename $${test} | sed -e "s/.gif$$//"`; \
+	    if echo "giftext: Checking text dump of $${test}" >&2; \
+	    $(UTILS)/giftext <$${test} > $@.$${stem}.regress 2>&1; \
+	    then diff -u $${stem}.dmp  $@.$${stem}.regress; \
+	    else echo "*** Nonzero return status on $${test}!"; exit 1; fi; \
+	done
+	@rm -f  $@.*.regress
+giftext-rebuild:
+	@for test in $(GIFS); do \
+		stem=`basename $${test} | sed -e "s/.gif$$//"`; \
+		echo "Remaking $${stem}.dmp"; \
+		$(UTILS)/giftext <$${test} >$${stem}.dmp; \
+	done
+
+giftool-regress:
+	@echo "giftool: Checking that expensive copy via giftool is faithful."
+	@$(UTILS)/giftool <$(PICS)/gifgrid.gif | $(UTILS)/gif2rgb | cmp - gifgrid.rgb
+	@echo "giftool: Checking that it de-interlaces correctly."
+	@$(UTILS)/giftool -i on <$(PICS)/treescap-interlaced.gif | $(UTILS)/gif2rgb | cmp - treescap.rgb
+	@echo "giftool: Checking that it interlaces correctly."
+	@$(UTILS)/giftool -i off <$(PICS)/treescap.gif | $(UTILS)/gif2rgb | cmp - treescap-interlaced.rgb
+
+gifwedge-rebuild:
+	@echo "Remaking the gifwedge test."
+	@$(UTILS)/gifwedge >wedge.gif
+gifwedge-regress:
+	@echo "gifwedge: Checking wedge generation."
+	@$(UTILS)/gifwedge | cmp - wedge.gif
diff --git a/tests/porsche.dmp b/tests/porsche.dmp
new file mode 100644
index 0000000..dfe4086
--- /dev/null
+++ b/tests/porsche.dmp
@@ -0,0 +1,15 @@
+
+Stdin:
+
+	Screen Size - Width = 320, Height = 200.
+	ColorResolution = 4, BitsPerPixel = 5, BackGround = 0, Aspect = 0.
+	Has Global Color Map.
+
+
+Image #1:
+
+	Image Size - Left = 0, Top = 0, Width = 320, Height = 200.
+	Image is Non Interlaced.
+	No Image Color Map.
+
+GIF file terminated normally.
diff --git a/tests/porsche.map b/tests/porsche.map
new file mode 100644
index 0000000..c2912be
--- /dev/null
+++ b/tests/porsche.map
@@ -0,0 +1,32 @@
+  0   0   0   0
+  1 102  68  51
+  2  17  17  17
+  3  85  85  85
+  4  17   0   0
+  5  34   0   0
+  6  51  17  17
+  7  68  17  17
+  8  68  17  17
+  9  85  17  34
+ 10 102  34  34
+ 11 119  34  34
+ 12 136   0  51
+ 13 153  51  51
+ 14 170  51  68
+ 15 170  51  68
+ 16 187  51  68
+ 17 204  68  85
+ 18 221  68  85
+ 19 119 102 102
+ 20 136 136 136
+ 21 153 153 153
+ 22 221 153  68
+ 23 170 102   0
+ 24 153  85   0
+ 25  85  34   0
+ 26 255 255 238
+ 27 221 221 204
+ 28 187 187 187
+ 29  68  68  68
+ 30  51  51  51
+ 31  34  34  34
diff --git a/tests/porsche.rgb b/tests/porsche.rgb
new file mode 100644
index 0000000..4a24200
Binary files /dev/null and b/tests/porsche.rgb differ
diff --git a/tests/solid2.dmp b/tests/solid2.dmp
new file mode 100644
index 0000000..264e226
--- /dev/null
+++ b/tests/solid2.dmp
@@ -0,0 +1,15 @@
+
+Stdin:
+
+	Screen Size - Width = 640, Height = 400.
+	ColorResolution = 7, BitsPerPixel = 7, BackGround = 0, Aspect = 0.
+	Has Global Color Map.
+
+
+Image #1:
+
+	Image Size - Left = 0, Top = 0, Width = 640, Height = 400.
+	Image is Non Interlaced.
+	No Image Color Map.
+
+GIF file terminated normally.
diff --git a/tests/solid2.map b/tests/solid2.map
new file mode 100644
index 0000000..3edd2b6
--- /dev/null
+++ b/tests/solid2.map
@@ -0,0 +1,128 @@
+  0   0   0 255
+  1 255 255   0
+  2 253 253   0
+  3 251 251   0
+  4 249 249   0
+  5 247 247   0
+  6 245 245   0
+  7 244 244   0
+  8 242 242   0
+  9 240 240   0
+ 10 238 238   0
+ 11 236 236   0
+ 12 235 235   0
+ 13 233 233   0
+ 14 231 231   0
+ 15 229 229   0
+ 16 227 227   0
+ 17 226 226   0
+ 18 224 224   0
+ 19 222 222   0
+ 20 220 220   0
+ 21 218 218   0
+ 22 217 217   0
+ 23 215 215   0
+ 24 213 213   0
+ 25 211 211   0
+ 26 209 209   0
+ 27 208 208   0
+ 28 206 206   0
+ 29 204 204   0
+ 30 202 202   0
+ 31 200 200   0
+ 32 198 198   0
+ 33 197 197   0
+ 34 195 195   0
+ 35 193 193   0
+ 36 191 191   0
+ 37 189 189   0
+ 38 188 188   0
+ 39 186 186   0
+ 40 184 184   0
+ 41 182 182   0
+ 42 180 180   0
+ 43 179 179   0
+ 44 177 177   0
+ 45 175 175   0
+ 46 173 173   0
+ 47 171 171   0
+ 48 170 170   0
+ 49 168 168   0
+ 50 166 166   0
+ 51 164 164   0
+ 52 162 162   0
+ 53 161 161   0
+ 54 159 159   0
+ 55 157 157   0
+ 56 155 155   0
+ 57 153 153   0
+ 58 151 151   0
+ 59 150 150   0
+ 60 148 148   0
+ 61 146 146   0
+ 62 144 144   0
+ 63 142 142   0
+ 64 141 141   0
+ 65 139 139   0
+ 66 137 137   0
+ 67 135 135   0
+ 68 133 133   0
+ 69 132 132   0
+ 70 130 130   0
+ 71 128 128   0
+ 72 126 126   0
+ 73 124 124   0
+ 74 123 123   0
+ 75 121 121   0
+ 76 119 119   0
+ 77 117 117   0
+ 78 115 115   0
+ 79 114 114   0
+ 80 112 112   0
+ 81 110 110   0
+ 82 108 108   0
+ 83 106 106   0
+ 84 105 105   0
+ 85 103 103   0
+ 86 101 101   0
+ 87  99  99   0
+ 88  97  97   0
+ 89  95  95   0
+ 90  94  94   0
+ 91  92  92   0
+ 92  90  90   0
+ 93  88  88   0
+ 94  86  86   0
+ 95  85  85   0
+ 96  83  83   0
+ 97  81  81   0
+ 98  79  79   0
+ 99  77  77   0
+100  76  76   0
+101  74  74   0
+102  72  72   0
+103  70  70   0
+104  68  68   0
+105  67  67   0
+106  65  65   0
+107  63  63   0
+108  61  61   0
+109  59  59   0
+110  58  58   0
+111  56  56   0
+112  54  54   0
+113  52  52   0
+114  50  50   0
+115  48  48   0
+116  47  47   0
+117  45  45   0
+118  43  43   0
+119  41  41   0
+120  39  39   0
+121  38  38   0
+122  36  36   0
+123  34  34   0
+124  32  32   0
+125  30  30   0
+126  29  29   0
+127  27  27   0
diff --git a/tests/solid2.rgb b/tests/solid2.rgb
new file mode 100644
index 0000000..34b0a8f
Binary files /dev/null and b/tests/solid2.rgb differ
diff --git a/tests/treescap-interlaced.dmp b/tests/treescap-interlaced.dmp
new file mode 100644
index 0000000..aacf9e1
--- /dev/null
+++ b/tests/treescap-interlaced.dmp
@@ -0,0 +1,15 @@
+
+Stdin:
+
+	Screen Size - Width = 40, Height = 40.
+	ColorResolution = 7, BitsPerPixel = 4, BackGround = 0, Aspect = 0.
+	Has Global Color Map.
+
+
+Image #1:
+
+	Image Size - Left = 0, Top = 0, Width = 40, Height = 40.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF file terminated normally.
diff --git a/tests/treescap-interlaced.map b/tests/treescap-interlaced.map
new file mode 100644
index 0000000..3b7c132
--- /dev/null
+++ b/tests/treescap-interlaced.map
@@ -0,0 +1,16 @@
+  0  46 140  93
+  1   0 255 255
+  2   0 157   0
+  3  81 200  86
+  4 190 190 190
+  5 110 110 110
+  6 255 255   0
+  7 136 115  95
+  8 231 231 231
+  9   0 153 102
+ 10   0   0   0
+ 11   0   0   0
+ 12   0   0   0
+ 13   0   0   0
+ 14   0   0   0
+ 15   0   0   0
diff --git a/tests/treescap-interlaced.rgb b/tests/treescap-interlaced.rgb
new file mode 100644
index 0000000..b652658
Binary files /dev/null and b/tests/treescap-interlaced.rgb differ
diff --git a/tests/treescap.dmp b/tests/treescap.dmp
new file mode 100644
index 0000000..1a45619
--- /dev/null
+++ b/tests/treescap.dmp
@@ -0,0 +1,15 @@
+
+Stdin:
+
+	Screen Size - Width = 40, Height = 40.
+	ColorResolution = 7, BitsPerPixel = 4, BackGround = 0, Aspect = 0.
+	Has Global Color Map.
+
+
+Image #1:
+
+	Image Size - Left = 0, Top = 0, Width = 40, Height = 40.
+	Image is Non Interlaced.
+	No Image Color Map.
+
+GIF file terminated normally.
diff --git a/tests/treescap.ico b/tests/treescap.ico
new file mode 100644
index 0000000..4484a86
--- /dev/null
+++ b/tests/treescap.ico
@@ -0,0 +1,76 @@
+screen width 40
+screen height 40
+screen colors 128
+screen background 0
+pixel aspect byte 0
+
+screen map
+	sort flag off
+	rgb 046 140 093 is 0
+	rgb 000 255 255 is 1
+	rgb 000 157 000 is 2
+	rgb 081 200 086 is 3
+	rgb 190 190 190 is 4
+	rgb 110 110 110 is 5
+	rgb 255 255 000 is 6
+	rgb 136 115 095 is 7
+	rgb 231 231 231 is 8
+	rgb 000 153 102 is 9
+	rgb 000 000 000 is a
+	rgb 000 000 000 is b
+	rgb 000 000 000 is c
+	rgb 000 000 000 is d
+	rgb 000 000 000 is e
+	rgb 000 000 000 is f
+end
+
+image # 1
+image left 0
+image top 0
+image bits 40 by 40
+8888888888888888888888888888888888888885
+8888888888888888888888888888888888888855
+8844444444444444444444444444444444444455
+8845555555555555555555555555555555558455
+8845666661111111111111111111111111118455
+8845666661111111133333311111111111118455
+8845666611111133333333333311111111118455
+8845666611113333333333323391111111118455
+8845661111113333223333322231111111118455
+8845111111113333322333733291111111118455
+8845111111333333323337223239111111118455
+8845111113333337723373232222111111118455
+8845111113373333773332222229211111118455
+8845111113777733332333772229911111118455
+8845111113333732232223222229211111118455
+8845111111139392372337223779111111118455
+8845111111111929277372222222111111118455
+8845111111111111117733222122111111118455
+8845111111111111117772231111111111118455
+8845111111111111117711211111111111118455
+8845111111111111117711111111111111118455
+8845111111111111117711111111111111118455
+8845111111111111117711111111111111118455
+8845111111112222227722111111111111118455
+8845292912222222227722221111111111118455
+8845999922222222227722222222211111118455
+8845292222222222277722222222222111118455
+8845999222222227777772222222222291118455
+8845292222222227227077722222222229298455
+8845999222222222227007772222222229998455
+8845292222222222222200020002222229298455
+8845999222222222222222000000022229998455
+8845292222222222222222200000000229298455
+8845999999999999999999990000000009998455
+8845292929292929292929292000000000098455
+8845999999999999999999999000900000098455
+8848888888888888888888888888888888888455
+8844444444444444444444444444444444444455
+8555555555555555555555555555555555555555
+5555555555555555555555555555555555555555
+
+# The following sets edit modes for GNU EMACS
+# Local Variables:
+# mode:picture
+# truncate-lines:t
+# End:
diff --git a/tests/treescap.map b/tests/treescap.map
new file mode 100644
index 0000000..3b7c132
--- /dev/null
+++ b/tests/treescap.map
@@ -0,0 +1,16 @@
+  0  46 140  93
+  1   0 255 255
+  2   0 157   0
+  3  81 200  86
+  4 190 190 190
+  5 110 110 110
+  6 255 255   0
+  7 136 115  95
+  8 231 231 231
+  9   0 153 102
+ 10   0   0   0
+ 11   0   0   0
+ 12   0   0   0
+ 13   0   0   0
+ 14   0   0   0
+ 15   0   0   0
diff --git a/tests/treescap.rgb b/tests/treescap.rgb
new file mode 100644
index 0000000..b652658
Binary files /dev/null and b/tests/treescap.rgb differ
diff --git a/tests/wedge.gif b/tests/wedge.gif
new file mode 100644
index 0000000..6d0bf32
Binary files /dev/null and b/tests/wedge.gif differ
diff --git a/tests/welcome2.dmp b/tests/welcome2.dmp
new file mode 100644
index 0000000..af58400
--- /dev/null
+++ b/tests/welcome2.dmp
@@ -0,0 +1,110 @@
+
+Stdin:
+
+	Screen Size - Width = 290, Height = 48.
+	ColorResolution = 8, BitsPerPixel = 8, BackGround = 0, Aspect = 0.
+	Has Global Color Map.
+
+
+GIF89 application block (Ext Code = 255 [ ]):
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 2
+	User Input Flag: 0
+	Transparency on: yes
+	DelayTime: 100
+	Transparent Index: 0
+
+Image #1:
+
+	Image Size - Left = 0, Top = 0, Width = 290, Height = 48.
+	Image is Non Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 2
+	User Input Flag: 0
+	Transparency on: yes
+	DelayTime: 100
+	Transparent Index: 210
+
+Image #2:
+
+	Image Size - Left = 0, Top = 0, Width = 290, Height = 48.
+	Image is Non Interlaced, BitsPerPixel = 8.
+	Image Has Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 2
+	User Input Flag: 0
+	Transparency on: yes
+	DelayTime: 100
+	Transparent Index: 0
+
+Image #3:
+
+	Image Size - Left = 0, Top = 0, Width = 290, Height = 48.
+	Image is Non Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 2
+	User Input Flag: 0
+	Transparency on: yes
+	DelayTime: 100
+	Transparent Index: 210
+
+Image #4:
+
+	Image Size - Left = 0, Top = 0, Width = 290, Height = 48.
+	Image is Non Interlaced, BitsPerPixel = 8.
+	Image Has Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 2
+	User Input Flag: 0
+	Transparency on: yes
+	DelayTime: 100
+	Transparent Index: 0
+
+Image #5:
+
+	Image Size - Left = 0, Top = 0, Width = 290, Height = 48.
+	Image is Non Interlaced.
+	No Image Color Map.
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 2
+	User Input Flag: 0
+	Transparency on: yes
+	DelayTime: 100
+	Transparent Index: 210
+
+Image #6:
+
+	Image Size - Left = 0, Top = 0, Width = 290, Height = 48.
+	Image is Non Interlaced, BitsPerPixel = 8.
+	Image Has Color Map.
+
+GIF89 comment (Ext Code = 254 [ ]):
+
+00000:  5                                                 This animated GI 
+00010:  4                                                 F is created by  
+00020:  4                                                 Fairy Suryana  h 
+00030:  7                                                 ttp://members.ao 
+00040:  6                                                 l.com/BeatFacto/ 
+00050:  0                                                   http://www.dew 
+00060:  6                                                 a.com/    Fairy  
+00070:  5                                                 Suryana DJ palin 
+00080:  6                                                 g jago se dunia! 
+GIF89 application block (Ext Code = 255 [ ]):
+
+00000:  4                                                 GIFCONnb1.0      
+00010:  0                                                            new-6 
+00020:  2                                                 .gif             
+00030:  0                                                    New-5.gif     
+00040:  0                                                            new-6 
+00050:  2                                                 .gif             
+00060:  0                                                    New-5.gif     
+00070:  0                                                            new-6 
+GIF file terminated normally.
diff --git a/tests/welcome2.map b/tests/welcome2.map
new file mode 100644
index 0000000..ac30cf7
--- /dev/null
+++ b/tests/welcome2.map
@@ -0,0 +1,256 @@
+  0   0   0   0
+  1  74  74  74
+  2 222   0   0
+  3 255 255 255
+  4 172   0   0
+  5 180   0   0
+  6  82  82  82
+  7 189   0   0
+  8 213   0   0
+  9 205   0   0
+ 10  32  32  32
+ 11  98  98  98
+ 12 115 115 115
+ 13 123 123 123
+ 14  90  90  90
+ 15 197   0   0
+ 16 131 131 131
+ 17  57  57  57
+ 18  41  41  41
+ 19 106 106 106
+ 20 205 205 205
+ 21 139 139 139
+ 22 197 197 197
+ 23 180 180 180
+ 24 213 213 213
+ 25 172 172 172
+ 26 148 148 148
+ 27 230   0   0
+ 28 246 246 246
+ 29 156 156 156
+ 30 238 238 238
+ 31 189 189 189
+ 32 164 164 164
+ 33 222 222 222
+ 34  24  24  24
+ 35  65  65  65
+ 36 164   0   0
+ 37  49  49  49
+ 38 230 230 230
+ 39 172  16  16
+ 40 148  16  16
+ 41 106  49  49
+ 42 164  16  16
+ 43 123  49  49
+ 44 238  82  82
+ 45   8   8   8
+ 46 180  16  16
+ 47 189  41  41
+ 48 156  16  16
+ 49 238 172 172
+ 50  16  16  16
+ 51 131   0   0
+ 52 115  49  49
+ 53 139  24  24
+ 54  82  65  65
+ 55 230  82  82
+ 56 246 172 172
+ 57 131  57  57
+ 58 164   8   8
+ 59 156  41  41
+ 60 172   8   8
+ 61 205   8   8
+ 62 156  24  24
+ 63 139  65  65
+ 64 123  90  90
+ 65 197  65  65
+ 66 197  49  49
+ 67  98   0   0
+ 68 189  16  16
+ 69 148  90  90
+ 70 164  49  49
+ 71 222  16  16
+ 72 205  74  74
+ 73 189  57  57
+ 74 222 172 172
+ 75 255 230 230
+ 76 156  98  98
+ 77 213 164 164
+ 78 222  82  82
+ 79 189  65  65
+ 80 205 156 156
+ 81 148  24  24
+ 82 164  24  24
+ 83 197  24  24
+ 84 164  41  41
+ 85 139  82  82
+ 86 123  82  82
+ 87 148  41  41
+ 88 197  41  41
+ 89 197 131 131
+ 90 246 230 230
+ 91 148  49  49
+ 92 205  57  57
+ 93 189  49  49
+ 94 123  98  98
+ 95 180  32  32
+ 96  98  49  49
+ 97 205 139 139
+ 98 230  24  24
+ 99 180  65  65
+100 189  24  24
+101 197 123 123
+102 213  82  82
+103 213 148 148
+104 139   0   0
+105 115  74  74
+106 148  32  32
+107 197 148 148
+108 172  74  74
+109 189 123 123
+110 222  74  74
+111 180 115 115
+112 205  24  24
+113 189  74  74
+114 148   0   0
+115 205  32  32
+116 164 139 139
+117 180  57  57
+118 213 115 115
+119 156  57  57
+120 123  57  57
+121 156   0   0
+122 106  82  82
+123 238 197 197
+124 230 205 205
+125 205  82  82
+126 180   8   8
+127 197  57  57
+128 180  24  24
+129 205 131 131
+130 164  90  90
+131 115  41  41
+132 238 115 115
+133 222 156 156
+134 230  57  57
+135 246 139 139
+136 139  57  57
+137 115  90  90
+138 213  41  41
+139 172  57  57
+140 172  49  49
+141 172  24  24
+142 213 172 172
+143 180  74  74
+144 180 123 123
+145 123  41  41
+146 156  82  82
+147 213   8   8
+148 255 197 197
+149 222  24  24
+150 230 164 164
+151 197  74  74
+152 213 139 139
+153  90  57  57
+154 238 139 139
+155 156  90  90
+156 189   8   8
+157 148  82  82
+158  90  65  65
+159 189 139 139
+160 213  57  57
+161 180  82  82
+162 139 123 123
+163 238 189 189
+164 164  32  32
+165 213  16  16
+166 148  57  57
+167 115  82  82
+168 123   0   0
+169 156  49  49
+170 238 213 213
+171 139  41  41
+172 106  74  74
+173 164  98  98
+174 197  98  98
+175 123 106 106
+176 156 123 123
+177 230 156 156
+178 222 164 164
+179 172 123 123
+180 189 115 115
+181 139  16  16
+182 238 164 164
+183 197  32  32
+184 213  74  74
+185 106  90  90
+186 180  41  41
+187 156 106 106
+188 172 106 106
+189 197 164 164
+190 139 115 115
+191 172  65  65
+192 164  74  74
+193 131  41  41
+194 205  65  65
+195 222 148 148
+196 205 180 180
+197 106   0   0
+198 205  49  49
+199 156   8   8
+200 213 189 189
+201 222  65  65
+202 123  32  32
+203 164  65  65
+204 164  57  57
+205 123  74  74
+206 180 131 131
+207 180  90  90
+208 213  65  65
+209 197  16  16
+210 213  24  24
+211 164  82  82
+212 123  65  65
+213 131  49  49
+214 205  16  16
+215 148 115 115
+216 148  98  98
+217 156 131 131
+218 222  98  98
+219 115  98  98
+220 197  82  82
+221 106  65  65
+222 205 115 115
+223 180  49  49
+224 115   0   0
+225 246 197 197
+226 230 172 172
+227 222 115 115
+228 197 139 139
+229 230 180 180
+230 172  98  98
+231 148  65  65
+232 106  57  57
+233 222 123 123
+234 139  32  32
+235 164 148 148
+236 148 123 123
+237 230 148 148
+238 156  32  32
+239  98  57  57
+240 222 139 139
+241 148 106 106
+242 172 115 115
+243 213 156 156
+244 230  74  74
+245  98  74  74
+246 189 148 148
+247 156 139 139
+248 172  41  41
+249 131  82  82
+250 131  98  98
+251 115  57  57
+252 172  32  32
+253 131  90  90
+254 197   8   8
+255 180 148 148
diff --git a/tests/welcome2.rgb b/tests/welcome2.rgb
new file mode 100644
index 0000000..f90245e
Binary files /dev/null and b/tests/welcome2.rgb differ
diff --git a/tests/x-trans.dmp b/tests/x-trans.dmp
new file mode 100644
index 0000000..aab58d7
--- /dev/null
+++ b/tests/x-trans.dmp
@@ -0,0 +1,24 @@
+
+Stdin:
+
+	Screen Size - Width = 100, Height = 100.
+	ColorResolution = 7, BitsPerPixel = 8, BackGround = 0, Aspect = 0.
+	Has Global Color Map.
+
+
+GIF89 comment (Ext Code = 254 [ ]):
+
+GIF89 graphics control (Ext Code = 249 [ ]):
+	Disposal Mode: 0
+	User Input Flag: 0
+	Transparency on: yes
+	DelayTime: 10
+	Transparent Index: 0
+
+Image #1:
+
+	Image Size - Left = 0, Top = 0, Width = 100, Height = 100.
+	Image is Interlaced.
+	No Image Color Map.
+
+GIF file terminated normally.
diff --git a/tests/x-trans.map b/tests/x-trans.map
new file mode 100644
index 0000000..1198462
--- /dev/null
+++ b/tests/x-trans.map
@@ -0,0 +1,256 @@
+  0 255 255 255
+  1 255 255 204
+  2 255 255 153
+  3 255 255 102
+  4 255 255  51
+  5 255 255   0
+  6 255 204 255
+  7 255 204 204
+  8 255 204 153
+  9 255 204 102
+ 10 255 204  51
+ 11 255 204   0
+ 12 255 153 255
+ 13 255 153 204
+ 14 255 153 153
+ 15 255 153 102
+ 16 255 153  51
+ 17 255 153   0
+ 18 255 102 255
+ 19 255 102 204
+ 20 255 102 153
+ 21 255 102 102
+ 22 255 102  51
+ 23 255 102   0
+ 24 255  51 255
+ 25 255  51 204
+ 26 255  51 153
+ 27 255  51 102
+ 28 255  51  51
+ 29 255  51   0
+ 30 255   0 255
+ 31 255   0 204
+ 32 255   0 153
+ 33 255   0 102
+ 34 255   0  51
+ 35 255   0   0
+ 36 204 255 255
+ 37 204 255 204
+ 38 204 255 153
+ 39 204 255 102
+ 40 204 255  51
+ 41 204 255   0
+ 42 204 204 255
+ 43 204 204 204
+ 44 204 204 153
+ 45 204 204 102
+ 46 204 204  51
+ 47 204 204   0
+ 48 204 153 255
+ 49 204 153 204
+ 50 204 153 153
+ 51 204 153 102
+ 52 204 153  51
+ 53 204 153   0
+ 54 204 102 255
+ 55 204 102 204
+ 56 204 102 153
+ 57 204 102 102
+ 58 204 102  51
+ 59 204 102   0
+ 60 204  51 255
+ 61 204  51 204
+ 62 204  51 153
+ 63 204  51 102
+ 64 204  51  51
+ 65 204  51   0
+ 66 204   0 255
+ 67 204   0 204
+ 68 204   0 153
+ 69 204   0 102
+ 70 204   0  51
+ 71 204   0   0
+ 72 153 255 255
+ 73 153 255 204
+ 74 153 255 153
+ 75 153 255 102
+ 76 153 255  51
+ 77 153 255   0
+ 78 153 204 255
+ 79 153 204 204
+ 80 153 204 153
+ 81 153 204 102
+ 82 153 204  51
+ 83 153 204   0
+ 84 153 153 255
+ 85 153 153 204
+ 86 153 153 153
+ 87 153 153 102
+ 88 153 153  51
+ 89 153 153   0
+ 90 153 102 255
+ 91 153 102 204
+ 92 153 102 153
+ 93 153 102 102
+ 94 153 102  51
+ 95 153 102   0
+ 96 153  51 255
+ 97 153  51 204
+ 98 153  51 153
+ 99 153  51 102
+100 153  51  51
+101 153  51   0
+102 153   0 255
+103 153   0 204
+104 153   0 153
+105 153   0 102
+106 153   0  51
+107 153   0   0
+108 102 255 255
+109 102 255 204
+110 102 255 153
+111 102 255 102
+112 102 255  51
+113 102 255   0
+114 102 204 255
+115 102 204 204
+116 102 204 153
+117 102 204 102
+118 102 204  51
+119 102 204   0
+120 102 153 255
+121 102 153 204
+122 102 153 153
+123 102 153 102
+124 102 153  51
+125 102 153   0
+126 102 102 255
+127 102 102 204
+128 102 102 153
+129 102 102 102
+130 102 102  51
+131 102 102   0
+132 102  51 255
+133 102  51 204
+134 102  51 153
+135 102  51 102
+136 102  51  51
+137 102  51   0
+138 102   0 255
+139 102   0 204
+140 102   0 153
+141 102   0 102
+142 102   0  51
+143 102   0   0
+144  51 255 255
+145  51 255 204
+146  51 255 153
+147  51 255 102
+148  51 255  51
+149  51 255   0
+150  51 204 255
+151  51 204 204
+152  51 204 153
+153  51 204 102
+154  51 204  51
+155  51 204   0
+156  51 153 255
+157  51 153 204
+158  51 153 153
+159  51 153 102
+160  51 153  51
+161  51 153   0
+162  51 102 255
+163  51 102 204
+164  51 102 153
+165  51 102 102
+166  51 102  51
+167  51 102   0
+168  51  51 255
+169  51  51 204
+170  51  51 153
+171  51  51 102
+172  51  51  51
+173  51  51   0
+174  51   0 255
+175  51   0 204
+176  51   0 153
+177  51   0 102
+178  51   0  51
+179  51   0   0
+180   0 255 255
+181   0 255 204
+182   0 255 153
+183   0 255 102
+184   0 255  51
+185   0 255   0
+186   0 204 255
+187   0 204 204
+188   0 204 153
+189   0 204 102
+190   0 204  51
+191   0 204   0
+192   0 153 255
+193   0 153 204
+194   0 153 153
+195   0 153 102
+196   0 153  51
+197   0 153   0
+198   0 102 255
+199   0 102 204
+200   0 102 153
+201   0 102 102
+202   0 102  51
+203   0 102   0
+204   0  51 255
+205   0  51 204
+206   0  51 153
+207   0  51 102
+208   0  51  51
+209   0  51   0
+210   0   0 255
+211   0   0 204
+212   0   0 153
+213   0   0 102
+214   0   0  51
+215   0   0   0
+216 255 255 255
+217 255 255 255
+218 255 255 255
+219 255 255 255
+220 255 255 255
+221 255 255 255
+222 255 255 255
+223 255 255 255
+224 255 255 255
+225 255 255 255
+226 255 255 255
+227 255 255 255
+228 255 255 255
+229 255 255 255
+230 255 255 255
+231 255 255 255
+232 255 255 255
+233 255 255 255
+234 255 255 255
+235 255 255 255
+236 255 255 255
+237 255 255 255
+238 255 255 255
+239 255 255 255
+240 255 255 255
+241 255 255 255
+242 255 255 255
+243 255 255 255
+244 255 255 255
+245 255 255 255
+246 255 255 255
+247 255 255 255
+248 255 255 255
+249 255 255 255
+250 255 255 255
+251 255 255 255
+252 255 255 255
+253 255 255 255
+254 255 255 255
+255 255 255 255
diff --git a/tests/x-trans.rgb b/tests/x-trans.rgb
new file mode 100644
index 0000000..a789626
--- /dev/null
+++ b/tests/x-trans.rgb
@@ -0,0 +1 @@
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
\ No newline at end of file
```

